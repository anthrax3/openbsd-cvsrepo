head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.38
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.34
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.30
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.32
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.24
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.28
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.26
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.22
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.20
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.18
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.16
	OPENBSD_5_0:1.22.0.14
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.12
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.10
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.6
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.10
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.8
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.6
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.22
date	2008.06.13.23.33.32;	author kurt;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.11.18.54.36;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.08.20.40.20;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.02.20.45.51;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.08.19.01.28;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.19.23.57.32;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.23.20.40.17;	author sturm;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.24.02.03.02;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.04.15.40.45;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.02.23.10.30;	author pvalchev;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.13.17.07.43;	author fgsch;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2002.03.19.02.02.57;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.09.22.29.40;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.19.08.31.07;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.18.18.35.24;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.20.12.25.20;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.12.49;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.52.38;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.53;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.37;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.37;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.36.03;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.35.48;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.38.48;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.29.11;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.48.21;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.09.03;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.14.01.52;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.53;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.23.25;	author miod;	state Exp;
branches;
next	;

1.11.2.1
date	2003.03.05.04.41.11;	author margarida;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2003.03.12.02.36.08;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Fixup ldscripts for i386 when linked with -pie (no change to non-pie
ldscripts). Correct the xd and xdc ldscripts (pie and pie + combreloc)
on i386 and add two new variants for pie + combreloc + Z and pie + Z on
all arches. ok drahn@@
@
text
@# This shell script emits a C file. -*- C -*-
# It does some substitutions.
# This file is now misnamed, because it supports both 32 bit and 64 bit
# ELF emulations.
test -z "${ELFSIZE}" && ELFSIZE=32
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
cat >e${EMULATION_NAME}.c <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* ${ELFSIZE} bit ELF emulation code for ${EMULATION_NAME}
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@@cygnus.com>
   ELF support by Ian Lance Taylor <ian@@cygnus.com>

This file is part of GLD, the Gnu Linker.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "bfd.h"
#include "sysdep.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "getopt.h"

#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include <ldgram.h>
#include "elf/common.h"

/* Declare functions used by various EXTRA_EM_FILEs.  */
static void gld${EMULATION_NAME}_before_parse (void);
static void gld${EMULATION_NAME}_after_open (void);
static void gld${EMULATION_NAME}_before_allocation (void);
static bfd_boolean gld${EMULATION_NAME}_place_orphan
  (lang_input_statement_type *file, asection *s);
static void gld${EMULATION_NAME}_finish (void);

EOF
case ${target} in
  *-*-openbsd*)
    cat >>e${EMULATION_NAME}.c <<EOF
#include <sys/types.h>
#include <dirent.h>

/* Search a directory for a .so file.  */

static char * gld${EMULATION_NAME}_search_dir_needed (const char *dirlist, const char *filename);

static char * gld${EMULATION_NAME}_search_dir (const char *dirname,
  const char *filename, int req_maj, int req_min);

static char * gld${EMULATION_NAME}_split_lib_name (char *name, int *pmaj,
  int *pmin);

/* THIS FUNCTION MODIFIES THE name ARGUMENT string */
static char *
gld${EMULATION_NAME}_split_lib_name (name, pmaj, pmin)
  char *name;
  int *pmaj, *pmin;
{
  char*eptr, *lib = name;
  char *s;
  int found_so = 0;

  *pmaj = -1;
  *pmin = -1;
  
  if (strncmp(lib, "lib", 3) == 0)   
    lib += 3;

  s = lib;
  while (found_so == 0)
    {
      s = strstr(s, ".so");

      /* if .so not found, return not found, invalid lib name */
      if (s == NULL)
	{
	  return NULL;
	}

      /* if .so is at end of string, fine return with pmaj/pmin -1 */
      if (s[3] == '\0')
	{
	  *s = '\0';
	  return lib;
	}

      if (s[3] == '.')
	{
	  *s = '\0';
	  found_so = 1;
	}
      /* skip over the ".so" */
      s += 3;
    }

  
  /* lib[name].so.[M].[N] */
  /*  s          ^        */
  s += 1;

  /* lib[name].so.[M].[N] */
  /*  s           ^       */
  *pmaj = strtoul (s, &eptr, 10);

  /* lib[name].so.[M]X... */
  /*  eptr           ^    */
  if (*eptr != '.' || s == eptr)
    return NULL; /* invalid, must have minor */

  s = eptr+1;

  /* lib[name].so.[M].[N]  */
  /*  s               ^    */
  *pmin = strtoul (s, &eptr, 10);

  /* lib[name].so.[M].[N]  */
  /*  eptr               ^ */
  if (*eptr != '\0' || s == eptr)
    return NULL;  /* minor must be last field of library */

  return lib;
}

static char *
gld${EMULATION_NAME}_search_dir_needed (dirlist, filename)
    const char *dirlist;
    const char *filename;
{
  char *dlist, *dlist_alloc, *dir;
  char *fnam, *fnam_alloc, *lib;
  char *found = NULL;
  int maj = -1, min = -1;
  
  dlist_alloc = dlist = xstrdup(dirlist);
  fnam_alloc = fnam = xstrdup(filename);
  
  lib = gld${EMULATION_NAME}_split_lib_name(fnam, &maj, &min);
  
  while (lib != NULL && found == NULL)
    {
      dir = strsep(&dlist, ":");
      if (dir == NULL)
	break;
      if (*dir == '\0')
	continue; /* skip dirlist of ...::... */
      found = gld${EMULATION_NAME}_search_dir(dir, lib, maj, min);
    }
  
  free(dlist_alloc);
  free(fnam_alloc);
  return found;
}


static char *
gld${EMULATION_NAME}_search_dir (dirname, filename, req_maj, req_min)
     const char *dirname;
     const char *filename;
     int req_maj, req_min;
{
  const char *dot;
  unsigned int len;
  char *found;
  int max_maj, max_min;
  DIR *dir;
  struct dirent *entry;
  unsigned int dirnamelen;
  char *full_path;
  int statval;
  struct stat st;

  dot = strchr (filename, '.');
  len = strlen (filename);
  found = NULL;
  max_maj = max_min = 0;

  dir = opendir (dirname);
  if (dir == NULL)
    return NULL;
  dirnamelen = strlen (dirname);
  
  while ((entry = readdir (dir)) != NULL)
    {
      const char *s;
      char *eptr, *eptr1;
      int found_maj, found_min;

      if (strncmp (entry->d_name, "lib", 3) != 0
	  || strncmp (entry->d_name + 3, filename, len) != 0)
	continue;

      /* We accept libfoo.so without a version number, even though the
         native linker does not.  This is more convenient for packages
         which just generate .so files for shared libraries, as on ELF
         systems.  */
      if (strncmp (entry->d_name + 3 + len, ".so", 3) != 0)
	continue;

      if (entry->d_name[6 + len] == '\0')
	;
      else if (entry->d_name[6 + len] == '.'
	       && ISDIGIT ((unsigned char) entry->d_name[7 + len]))
	;
      else
	continue;

      for (s = entry->d_name + 6 + len; *s != '\0'; s++)
	if (*s != '.' && ! ISDIGIT ((unsigned char) *s))
	  break;
      if (*s != '\0')
	continue;

      /* We've found a .so file.  Work out the major and minor
	 version numbers.  */
      found_maj = -1;
      found_min = -1;

      /* do allow libN.so */
      if (entry->d_name[6 + len] == '.') {
	found_maj = strtoul (entry->d_name + 7 + len, &eptr, 10);

	/* do not support libN.so. or libN.so.X */
	if (*eptr != '.' || ((entry->d_name + 3 + len) == eptr)) 
	  continue;

	found_min = strtoul (eptr+1, &eptr1, 10);

	/* do not support libN.so.X. or libN.so.X.Y.[anything] */
	if (*eptr1 != '\0' || (eptr+1 == eptr1)) 
	  continue;
      }

      /* Make sure the file really exists (ignore broken symlinks).  */
      full_path = xmalloc (dirnamelen + 1 + strlen (entry->d_name) + 1);
      sprintf (full_path, "%s/%s", dirname, entry->d_name);
      statval = stat (full_path, &st);
      free (full_path);
      if (statval != 0)
	continue;

      /* We've found a match for the name we are searching for.  See
	 if this is the version we should use.  */
      if (((req_maj == -1) && (found == NULL
	    || (found_maj > max_maj)
	    || (found_maj == max_maj && (found_min > max_min))))
	  || ((found_maj == req_maj) && (found_min >= req_min)
	    && (found_min > max_min)))
	{
	  if (found != NULL)
	    free (found);
	  found = (char *) xmalloc (dirnamelen + strlen (entry->d_name) + 2);
	  sprintf (found, "%s/%s", dirname, entry->d_name);
	  max_maj = found_maj;
	  max_min = found_min;
	}
    }

  closedir (dir);

  return found;
}

EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
EOF

# Import any needed special functions and/or overrides.
#
if test -n "$EXTRA_EM_FILE" ; then
. ${srcdir}/emultempl/${EXTRA_EM_FILE}.em
fi

# Functions in this file can be overridden by setting the LDEMUL_* shell
# variables.  If the name of the overriding function is the same as is
# defined in this file, then don't output this file's version.
# If a different overriding name is given then output the standard function
# as presumably it is called from the overriding function.
#
if test x"$LDEMUL_BEFORE_PARSE" != xgld"$EMULATION_NAME"_before_parse; then
cat >>e${EMULATION_NAME}.c <<EOF

static void
gld${EMULATION_NAME}_before_parse (void)
{
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
  config.dynamic_link = ${DYNAMIC_LINK-TRUE};
  config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo TRUE ; else echo FALSE ; fi`;
}

EOF
fi

if test x"$LDEMUL_RECOGNIZED_FILE" != xgld"${EMULATION_NAME}"_load_symbols; then
cat >>e${EMULATION_NAME}.c <<EOF
/* Handle as_needed DT_NEEDED.  */

static bfd_boolean
gld${EMULATION_NAME}_load_symbols (lang_input_statement_type *entry)
{
  if (!entry->as_needed
      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)
    return FALSE;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  bfd_elf_set_dyn_lib_class (entry->the_bfd, DYN_AS_NEEDED);

  /* Continue on with normal load_symbols processing.  */
  return FALSE;
}
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF

/* These variables are required to pass information back and forth
   between after_open and check_needed and stat_needed and vercheck.  */

static struct bfd_link_needed_list *global_needed;
static struct stat global_stat;
static bfd_boolean global_found;
static struct bfd_link_needed_list *global_vercheck_needed;
static bfd_boolean global_vercheck_failed;


/* On Linux, it's possible to have different versions of the same
   shared library linked against different versions of libc.  The
   dynamic linker somehow tags which libc version to use in
   /etc/ld.so.cache, and, based on the libc that it sees in the
   executable, chooses which version of the shared library to use.

   We try to do a similar check here by checking whether this shared
   library needs any other shared libraries which may conflict with
   libraries we have already included in the link.  If it does, we
   skip it, and try to find another shared library farther on down the
   link path.

   This is called via lang_for_each_input_file.
   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object
   which we are checking.  This sets GLOBAL_VERCHECK_FAILED if we find
   a conflicting version.  */

static void
gld${EMULATION_NAME}_vercheck (lang_input_statement_type *s)
{
  const char *soname;
  struct bfd_link_needed_list *l;

  if (global_vercheck_failed)
    return;
  if (s->the_bfd == NULL
      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)
    return;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = lbasename (bfd_get_filename (s->the_bfd));

  for (l = global_vercheck_needed; l != NULL; l = l->next)
    {
      const char *suffix;

      if (strcmp (soname, l->name) == 0)
	{
	  /* Probably can't happen, but it's an easy check.  */
	  continue;
	}

      if (strchr (l->name, '/') != NULL)
	continue;

      suffix = strstr (l->name, ".so.");
      if (suffix == NULL)
	continue;

      suffix += sizeof ".so." - 1;

      if (strncmp (soname, l->name, suffix - l->name) == 0)
	{
	  /* Here we know that S is a dynamic object FOO.SO.VER1, and
	     the object we are considering needs a dynamic object
	     FOO.SO.VER2, and VER1 and VER2 are different.  This
	     appears to be a version mismatch, so we tell the caller
	     to try a different version of this library.  */
	  global_vercheck_failed = TRUE;
	  return;
	}
    }
}


/* See if an input file matches a DT_NEEDED entry by running stat on
   the file.  */

static void
gld${EMULATION_NAME}_stat_needed (lang_input_statement_type *s)
{
  struct stat st;
  const char *suffix;
  const char *soname;

  if (global_found)
    return;
  if (s->the_bfd == NULL)
    return;

  if (bfd_stat (s->the_bfd, &st) != 0)
    {
      einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
      return;
    }

  if (st.st_dev == global_stat.st_dev
      && st.st_ino == global_stat.st_ino)
    {
      global_found = TRUE;
      return;
    }

  /* We issue a warning if it looks like we are including two
     different versions of the same shared library.  For example,
     there may be a problem if -lc picks up libc.so.6 but some other
     shared library has a DT_NEEDED entry of libc.so.5.  This is a
     heuristic test, and it will only work if the name looks like
     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.
     If we really want to issue warnings about mixing version numbers
     of shared libraries, we need to find a better way.  */

  if (strchr (global_needed->name, '/') != NULL)
    return;
  suffix = strstr (global_needed->name, ".so.");
  if (suffix == NULL)
    return;
  suffix += sizeof ".so." - 1;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = lbasename (s->filename);

  if (strncmp (soname, global_needed->name, suffix - global_needed->name) == 0)
    einfo ("%P: warning: %s, needed by %B, may conflict with %s\n",
	   global_needed->name, global_needed->by, soname);
}


/* This function is called for each possible name for a dynamic object
   named by a DT_NEEDED entry.  The FORCE parameter indicates whether
   to skip the check for a conflicting version.  */

static bfd_boolean
gld${EMULATION_NAME}_try_needed (const char *name, int force)
{
  bfd *abfd;
  char *soname;

  abfd = bfd_openr (name, bfd_get_target (output_bfd));
  if (abfd == NULL)
    return FALSE;
  if (! bfd_check_format (abfd, bfd_object))
    {
      bfd_close (abfd);
      return FALSE;
    }
  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
    {
      bfd_close (abfd);
      return FALSE;
    }

  /* For DT_NEEDED, they have to match.  */
  if (abfd->xvec != output_bfd->xvec)
    {
      bfd_close (abfd);
      return FALSE;
    }

  /* Check whether this object would include any conflicting library
     versions.  If FORCE is set, then we skip this check; we use this
     the second time around, if we couldn't find any compatible
     instance of the shared library.  */

  if (! force)
    {
      struct bfd_link_needed_list *needed;

      if (! bfd_elf_get_bfd_needed_list (abfd, &needed))
	einfo ("%F%P:%B: bfd_elf_get_bfd_needed_list failed: %E\n", abfd);

      if (needed != NULL)
	{
	  global_vercheck_needed = needed;
	  global_vercheck_failed = FALSE;
	  lang_for_each_input_file (gld${EMULATION_NAME}_vercheck);
	  if (global_vercheck_failed)
	    {
	      bfd_close (abfd);
	      /* Return FALSE to force the caller to move on to try
		 another file on the search path.  */
	      return FALSE;
	    }

	  /* But wait!  It gets much worse.  On Linux, if a shared
	     library does not use libc at all, we are supposed to skip
	     it the first time around in case we encounter a shared
	     library later on with the same name which does use the
	     version of libc that we want.  This is much too horrible
	     to use on any system other than Linux.  */

EOF
case ${target} in
  *-*-linux-gnu*)
    cat >>e${EMULATION_NAME}.c <<EOF
	  {
	    struct bfd_link_needed_list *l;

	    for (l = needed; l != NULL; l = l->next)
	      if (strncmp (l->name, "libc.so", 7) == 0)
		break;
	    if (l == NULL)
	      {
		bfd_close (abfd);
		return FALSE;
	      }
	  }

EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
	}
    }

  /* We've found a dynamic object matching the DT_NEEDED entry.  */

  /* We have already checked that there is no other input file of the
     same name.  We must now check again that we are not including the
     same file twice.  We need to do this because on many systems
     libc.so is a symlink to, e.g., libc.so.1.  The SONAME entry will
     reference libc.so.1.  If we have already included libc.so, we
     don't want to include libc.so.1 if they are the same file, and we
     can only check that using stat.  */

  if (bfd_stat (abfd, &global_stat) != 0)
    einfo ("%F%P:%B: bfd_stat failed: %E\n", abfd);

  /* First strip off everything before the last '/'.  */
  soname = xstrdup (lbasename (abfd->filename));

  if (trace_file_tries)
    info_msg (_("found %s at %s\n"), soname, name);

  global_found = FALSE;
  lang_for_each_input_file (gld${EMULATION_NAME}_stat_needed);
  if (global_found)
    {
      /* Return TRUE to indicate that we found the file, even though
	 we aren't going to do anything with it.  */
      free (soname);
      return TRUE;
    }

  /* Specify the soname to use.  */
  bfd_elf_set_dt_needed_name (abfd, soname);

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  bfd_elf_set_dyn_lib_class (abfd, DYN_DT_NEEDED);

  /* Add this file into the symbol table.  */
  if (! bfd_link_add_symbols (abfd, &link_info))
    einfo ("%F%B: could not read symbols: %E\n", abfd);

  return TRUE;
}


/* Search for a needed file in a path.  */

static bfd_boolean
gld${EMULATION_NAME}_search_needed (const char *path, const char *name, int force)
{
  const char *s;
  size_t len;

  if (name[0] == '/')
    return gld${EMULATION_NAME}_try_needed (name, force);

  if (path == NULL || *path == '\0')
    return FALSE;

EOF
case ${target} in
  *-*-openbsd*)
    cat >>e${EMULATION_NAME}.c <<EOF
  {
    char *found;
    if ((found = gld${EMULATION_NAME}_search_dir_needed(path, name)) != NULL) {
      if (gld${EMULATION_NAME}_try_needed (found, force)) {
	return TRUE;
      }
      free(found);
    }
  }

EOF
esac
cat >>e${EMULATION_NAME}.c <<EOF
  len = strlen (name);
  while (1)
    {
      char *filename, *sset;

      s = strchr (path, ':');
      if (s == NULL)
	s = path + strlen (path);

      filename = (char *) xmalloc (s - path + len + 2);
      if (s == path)
	sset = filename;
      else
	{
	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);

      if (gld${EMULATION_NAME}_try_needed (filename, force))
	return TRUE;

      free (filename);

      if (*s == '\0')
	break;
      path = s + 1;
    }

  return FALSE;
}

EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
  cat >>e${EMULATION_NAME}.c <<EOF

/* Add the sysroot to every entry in a colon-separated path.  */

static char *
gld${EMULATION_NAME}_add_sysroot (const char *path)
{
  int len, colons, i;
  char *ret, *p;

  len = strlen (path);
  colons = 0;
  i = 0;
  while (path[i])
    if (path[i++] == ':')
      colons++;

  if (path[i])
    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
  p = ret + strlen (ret);
  i = 0;
  while (path[i])
    if (path[i] == ':')
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
	p = p + strlen (p);
      }
    else
      *p++ = path[i++];

  *p = 0;
  return ret;
}

EOF
  case ${target} in
    *-*-linux-gnu*)
      cat >>e${EMULATION_NAME}.c <<EOF
/* For a native linker, check the file /etc/ld.so.conf for directories
   in which we may find shared libraries.  /etc/ld.so.conf is really
   only meaningful on Linux.  */

static bfd_boolean
gld${EMULATION_NAME}_check_ld_so_conf (const char *name, int force)
{
  static bfd_boolean initialized;
  static char *ld_so_conf;

  if (! initialized)
    {
      FILE *f;
      char *tmppath;

      tmppath = concat (ld_sysroot, "/etc/ld.so.conf", NULL);
      f = fopen (tmppath, FOPEN_RT);
      free (tmppath);
      if (f != NULL)
	{
	  char *b;
	  size_t len, alloc;
	  int c;

	  len = 0;
	  alloc = 100;
	  b = (char *) xmalloc (alloc);

	  while ((c = getc (f)) != EOF)
	    {
	      if (len + 1 >= alloc)
		{
		  alloc *= 2;
		  b = (char *) xrealloc (b, alloc);
		}
	      if (c != ':'
		  && c != ' '
		  && c != '\t'
		  && c != '\n'
		  && c != ',')
		{
		  b[len] = c;
		  ++len;
		}
	      else
		{
		  if (len > 0 && b[len - 1] != ':')
		    {
		      b[len] = ':';
		      ++len;
		    }
		}
	    }

	  if (len > 0 && b[len - 1] == ':')
	    --len;

	  if (len > 0)
	    b[len] = '\0';
	  else
	    {
	      free (b);
	      b = NULL;
	    }

	  fclose (f);

	  if (b)
	    {
	      char *d = gld${EMULATION_NAME}_add_sysroot (b);
	      free (b);
	      b = d;
	    }

	  ld_so_conf = b;
	}

      initialized = TRUE;
    }

  if (ld_so_conf == NULL)
    return FALSE;

  return gld${EMULATION_NAME}_search_needed (ld_so_conf, name, force);
}

EOF
    # Linux
    ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF

/* See if an input file matches a DT_NEEDED entry by name.  */

static void
gld${EMULATION_NAME}_check_needed (lang_input_statement_type *s)
{
  if (global_found)
    return;

  if (s->filename != NULL)
    {
      const char *f;

      if (strcmp (s->filename, global_needed->name) == 0)
	{
	  global_found = TRUE;
	  return;
	}

      if (s->search_dirs_flag)
	{
	  f = strrchr (s->filename, '/');
	  if (f != NULL
	      && strcmp (f + 1, global_needed->name) == 0)
	    {
	      global_found = TRUE;
	      return;
	    }
	}
    }

  if (s->the_bfd != NULL)
    {
      const char *soname;

      soname = bfd_elf_get_dt_soname (s->the_bfd);
      if (soname != NULL
	  && strcmp (soname, global_needed->name) == 0)
	{
	  global_found = TRUE;
	  return;
	}
    }
}

EOF

if test x"$LDEMUL_AFTER_OPEN" != xgld"$EMULATION_NAME"_after_open; then
cat >>e${EMULATION_NAME}.c <<EOF

/* This is called after all the input files have been opened.  */

static void
gld${EMULATION_NAME}_after_open (void)
{
  struct bfd_link_needed_list *needed, *l;

  /* We only need to worry about this when doing a final link.  */
  if (link_info.relocatable || !link_info.executable)
    return;

  /* Get the list of files which appear in DT_NEEDED entries in
     dynamic objects included in the link (often there will be none).
     For each such file, we want to track down the corresponding
     library, and include the symbol table in the link.  This is what
     the runtime dynamic linker will do.  Tracking the files down here
     permits one dynamic object to include another without requiring
     special action by the person doing the link.  Note that the
     needed list can actually grow while we are stepping through this
     loop.  */
  needed = bfd_elf_get_needed_list (output_bfd, &link_info);
  for (l = needed; l != NULL; l = l->next)
    {
      struct bfd_link_needed_list *ll;
      int force;

      /* If we've already seen this file, skip it.  */
      for (ll = needed; ll != l; ll = ll->next)
	if (strcmp (ll->name, l->name) == 0)
	  break;
      if (ll != l)
	continue;

      /* See if this file was included in the link explicitly.  */
      global_needed = l;
      global_found = FALSE;
      lang_for_each_input_file (gld${EMULATION_NAME}_check_needed);
      if (global_found)
	continue;

      if (trace_file_tries)
	info_msg (_("%s needed by %B\n"), l->name, l->by);

      /* We need to find this file and include the symbol table.  We
	 want to search for the file in the same way that the dynamic
	 linker will search.  That means that we want to use
	 rpath_link, rpath, then the environment variable
	 LD_LIBRARY_PATH (native only), then the DT_RPATH/DT_RUNPATH
	 entries (native only), then the linker script LIB_SEARCH_DIRS.
	 We look at the -L arguments to build the search path.

	 We search twice.  The first time, we skip objects which may
	 introduce version mismatches.  The second time, we force
	 their use.  See gld${EMULATION_NAME}_vercheck comment.  */
      for (force = 0; force < 2; force++)
	{
	  size_t len;
	  search_dirs_type *search;
EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
	  char *lib_path;
	  struct bfd_link_needed_list *rp;
	  int found;
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF

	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
						  l->name, force))
	    break;
EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath,
						  l->name, force))
	    break;
EOF
fi
if [ "x${NATIVE}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
	  if (getenv ("LD_RUN_PATH") != NULL
	      && command_line.rpath_link == NULL
	      && command_line.rpath == NULL)
	    {
	      lib_path = getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
						      force))
		break;
	    }

	 len = strlen(search_head->name);
	 lib_path = xstrdup(search_head->name);
	 for (search = search_head->next; search != NULL;
	      search = search->next)
	   {
	     size_t nlen;

	     nlen = strlen(search->name);
	     lib_path = xrealloc(lib_path, len + nlen + 2);
	     lib_path[len] = ':';
	     strcpy(lib_path + len + 1, search->name);
	     len += nlen + 1;
	   }

	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
	   {
	     free(lib_path);
	     break;
	   }
	 free(lib_path);

	 lib_path = getenv ("LD_LIBRARY_PATH");
	 if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
	    break;
EOF
fi
if [ "x${USE_LIBPATH}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
	  found = 0;
	  rp = bfd_elf_get_runpath_list (output_bfd, &link_info);
	  for (; !found && rp != NULL; rp = rp->next)
	    {
	      char *tmpname = gld${EMULATION_NAME}_add_sysroot (rp->name);
	      found = (rp->by == l->by
		       && gld${EMULATION_NAME}_search_needed (tmpname,
							      l->name,
							      force));
	      free (tmpname);
	    }
	  if (found)
	    break;

EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
	  len = strlen (l->name);
	  for (search = search_head; search != NULL; search = search->next)
	    {
	      char *filename;

	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, "%s/%s", search->name, l->name);
	      if (gld${EMULATION_NAME}_try_needed (filename, force))
		break;
	      free (filename);
	    }
	  if (search != NULL)
	    break;
EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
  case ${target} in
    *-*-linux-gnu*)
      cat >>e${EMULATION_NAME}.c <<EOF
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
	    break;
EOF
    # Linux
    ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
	}

      if (force < 2)
	continue;

      einfo ("%P: warning: %s, needed by %B, not found (try using -rpath or -rpath-link)\n",
	     l->name, l->by);
    }
}

EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF

/* Look through an expression for an assignment statement.  */

static void
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
{
  struct bfd_link_hash_entry *h;

  switch (exp->type.node_class)
    {
    case etree_provide:
      h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,
				FALSE, FALSE, FALSE);
      if (h == NULL)
	break;

      /* We call record_link_assignment even if the symbol is defined.
	 This is because if it is defined by a dynamic object, we
	 actually want to use the value defined by the linker script,
	 not the value from the dynamic object (because we are setting
	 symbols like etext).  If the symbol is defined by a regular
	 object, then, as it happens, calling record_link_assignment
	 will do no harm.  */

      /* Fall through.  */
    case etree_assign:
      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (! (bfd_elf_record_link_assignment
		 (output_bfd, &link_info, exp->assign.dst,
		  exp->type.node_class == etree_provide ? TRUE : FALSE)))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;

    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;

    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;

    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;

    default:
      break;
    }
}


/* This is called by the before_allocation routine via
   lang_for_each_statement.  It locates any assignment statements, and
   tells the ELF backend about them, in case they are assignments to
   symbols which are referred to by dynamic objects.  */

static void
gld${EMULATION_NAME}_find_statement_assignment (lang_statement_union_type *s)
{
  if (s->header.type == lang_assignment_statement_enum)
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}

EOF

if test x"$LDEMUL_BEFORE_ALLOCATION" != xgld"$EMULATION_NAME"_before_allocation; then
  if test x"${ELF_INTERPRETER_NAME+set}" = xset; then
    ELF_INTERPRETER_SET_DEFAULT="
  if (sinterp != NULL)
    {
      sinterp->contents = ${ELF_INTERPRETER_NAME};
      sinterp->_raw_size = strlen (sinterp->contents) + 1;
    }

"
  else
    ELF_INTERPRETER_SET_DEFAULT=
  fi
cat >>e${EMULATION_NAME}.c <<EOF

/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gld${EMULATION_NAME}_before_allocation (void)
{
  const char *rpath;
  asection *sinterp;

  if (link_info.hash->type == bfd_link_elf_hash_table)
    _bfd_elf_tls_setup (output_bfd, &link_info);

  /* If we are going to make any variable assignments, we need to let
     the ELF backend know about them in case the variables are
     referred to by dynamic objects.  */
  lang_for_each_statement (gld${EMULATION_NAME}_find_statement_assignment);

  /* Let the ELF backend work out the sizes of any sections required
     by dynamic linking.  */
  rpath = command_line.rpath;
  if (rpath == NULL)
    rpath = (const char *) getenv ("LD_RUN_PATH");
  if (! (bfd_elf_size_dynamic_sections
	 (output_bfd, command_line.soname, rpath,
	  command_line.filter_shlib,
	  (const char * const *) command_line.auxiliary_filters,
	  &link_info, &sinterp, lang_elf_version_info)))
    einfo ("%P%F: failed to set dynamic section sizes: %E\n");
${ELF_INTERPRETER_SET_DEFAULT}
  /* Let the user override the dynamic linker we are using.  */
  if (command_line.interpreter != NULL
      && sinterp != NULL)
    {
      sinterp->contents = (bfd_byte *) command_line.interpreter;
      sinterp->_raw_size = strlen (command_line.interpreter) + 1;
    }

  /* Look for any sections named .gnu.warning.  As a GNU extensions,
     we treat such sections as containing warning messages.  We print
     out the warning message, and then zero out the section size so
     that it does not get copied into the output file.  */

  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	asection *s;
	bfd_size_type sz;
	char *msg;
	bfd_boolean ret;

	if (is->just_syms_flag)
	  continue;

	s = bfd_get_section_by_name (is->the_bfd, ".gnu.warning");
	if (s == NULL)
	  continue;

	sz = bfd_section_size (is->the_bfd, s);
	msg = xmalloc ((size_t) (sz + 1));
	if (! bfd_get_section_contents (is->the_bfd, s,	msg, (file_ptr) 0, sz))
	  einfo ("%F%B: Can't read contents of section .gnu.warning: %E\n",
		 is->the_bfd);
	msg[sz] = '\0';
	ret = link_info.callbacks->warning (&link_info, msg,
					    (const char *) NULL,
					    is->the_bfd, (asection *) NULL,
					    (bfd_vma) 0);
	ASSERT (ret);
	free (msg);

	/* Clobber the section size, so that we don't waste copying the
	   warning into the output file.  */
	s->_raw_size = 0;
      }
  }
}

EOF
fi

if test x"$LDEMUL_OPEN_DYNAMIC_ARCHIVE" != xgld"$EMULATION_NAME"_open_dynamic_archive; then
cat >>e${EMULATION_NAME}.c <<EOF

/* Try to open a dynamic archive.  This is where we know that ELF
   dynamic libraries have an extension of .so (or .sl on oddball systems
   like hpux).  */

static bfd_boolean
gld${EMULATION_NAME}_open_dynamic_archive
  (const char *arch, search_dirs_type *search, lang_input_statement_type *entry)
{
  const char *filename;
  char *string;

  if (! entry->is_archive)
    return FALSE;

  filename = entry->filename;
EOF
case ${target} in
  *-*-openbsd*)
    cat >>e${EMULATION_NAME}.c <<EOF
  string = gld${EMULATION_NAME}_search_dir(search->name, filename, -1, -1);
  if (string == NULL)
    return FALSE;
EOF
   ;;
  *)
    cat >>e${EMULATION_NAME}.c <<EOF
  /* This allocates a few bytes too many when EXTRA_SHLIB_EXTENSION
     is defined, but it does not seem worth the headache to optimize
     away those two bytes of space.  */
  string = (char *) xmalloc (strlen (search->name)
			     + strlen (filename)
			     + strlen (arch)
#ifdef EXTRA_SHLIB_EXTENSION
			     + strlen (EXTRA_SHLIB_EXTENSION)
#endif
			     + sizeof "/lib.so");

  sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);

EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
#ifdef EXTRA_SHLIB_EXTENSION
  /* Try the .so extension first.  If that fails build a new filename
     using EXTRA_SHLIB_EXTENSION.  */
  if (! ldfile_try_open_bfd (string, entry))
    sprintf (string, "%s/lib%s%s%s", search->name,
	     filename, arch, EXTRA_SHLIB_EXTENSION);
#endif

  if (! ldfile_try_open_bfd (string, entry))
    {
      free (string);
      return FALSE;
    }

  entry->filename = string;

  /* We have found a dynamic object to include in the link.  The ELF
     backend linker will create a DT_NEEDED entry in the .dynamic
     section naming this file.  If this file includes a DT_SONAME
     entry, it will be used.  Otherwise, the ELF linker will just use
     the name of the file.  For an archive found by searching, like
     this one, the DT_NEEDED entry should consist of just the name of
     the file, without the path information used to find it.  Note
     that we only need to do this if we have a dynamic object; an
     archive will never be referenced by a DT_NEEDED entry.

     FIXME: This approach--using bfd_elf_set_dt_needed_name--is not
     very pretty.  I haven't been able to think of anything that is
     pretty, though.  */
  if (bfd_check_format (entry->the_bfd, bfd_object)
      && (entry->the_bfd->flags & DYNAMIC) != 0)
    {
      ASSERT (entry->is_archive && entry->search_dirs_flag);

      /* Rather than duplicating the logic above.  Just use the
	 filename we recorded earlier.  */

      filename = lbasename (entry->filename);
      bfd_elf_set_dt_needed_name (entry->the_bfd, filename);
    }

  return TRUE;
}

EOF
fi

if test x"$LDEMUL_PLACE_ORPHAN" != xgld"$EMULATION_NAME"_place_orphan; then
cat >>e${EMULATION_NAME}.c <<EOF

/* A variant of lang_output_section_find.  Used by place_orphan.  */

static lang_output_section_statement_type *
output_rel_find (asection *sec, int isdyn)
{
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;
  lang_output_section_statement_type *last = NULL;
  lang_output_section_statement_type *last_alloc = NULL;
  lang_output_section_statement_type *last_rel = NULL;
  lang_output_section_statement_type *last_rel_alloc = NULL;
  int rela = sec->name[4] == 'a';

  for (u = lang_output_section_statement.head; u; u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (strncmp (".rel", lookup->name, 4) == 0)
	{
	  int lookrela = lookup->name[4] == 'a';

	  /* .rel.dyn must come before all other reloc sections, to suit
	     GNU ld.so.  */
	  if (isdyn)
	    break;

	  /* Don't place after .rel.plt as doing so results in wrong
	     dynamic tags.  */
	  if (strcmp (".plt", lookup->name + 4 + lookrela) == 0)
	    break;

	  if (rela == lookrela || last_rel == NULL)
	    last_rel = lookup;
	  if ((rela == lookrela || last_rel_alloc == NULL)
	      && lookup->bfd_section != NULL
	      && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	    last_rel_alloc = lookup;
	}

      last = lookup;
      if (lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	last_alloc = lookup;
    }

  if (last_rel_alloc)
    return last_rel_alloc;

  if (last_rel)
    return last_rel;

  if (last_alloc)
    return last_alloc;

  return last;
}

/* Find the last output section before given output statement.
   Used by place_orphan.  */

static asection *
output_prev_sec_find (lang_output_section_statement_type *os)
{
  asection *s = (asection *) NULL;
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (lookup == os)
	return s;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	s = lookup->bfd_section;
    }

  return NULL;
}

/* Place an orphan section.  We use this to put random SHF_ALLOC
   sections in the right segment.  */

struct orphan_save {
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
  lang_statement_union_type **os_tail;
};

static bfd_boolean
gld${EMULATION_NAME}_place_orphan (lang_input_statement_type *file, asection *s)
{
  static struct orphan_save hold_text;
  static struct orphan_save hold_rodata;
  static struct orphan_save hold_data;
  static struct orphan_save hold_bss;
  static struct orphan_save hold_rel;
  static struct orphan_save hold_interp;
  static struct orphan_save hold_sdata;
  static int count = 1;
  struct orphan_save *place;
  lang_statement_list_type *old;
  lang_statement_list_type add;
  etree_type *address;
  const char *secname;
  const char *ps = NULL;
  lang_output_section_statement_type *os;
  lang_statement_union_type **os_tail;
  etree_type *load_base;
  int isdyn = 0;

  secname = bfd_get_section_name (s->owner, s);
  if (! link_info.relocatable
      && link_info.combreloc
      && (s->flags & SEC_ALLOC)
      && strncmp (secname, ".rel", 4) == 0)
    {
      if (secname[4] == 'a')
	secname = ".rela.dyn";
      else
	secname = ".rel.dyn";
      isdyn = 1;
    }

  if (isdyn || (!config.unique_orphan_sections && !unique_section_p (secname)))
    {
      /* Look through the script to see where to place this section.  */
      os = lang_output_section_find (secname);

      if (os != NULL
	  && (os->bfd_section == NULL
	      || ((s->flags ^ os->bfd_section->flags)
		  & (SEC_LOAD | SEC_ALLOC)) == 0))
	{
	  /* We already have an output section statement with this
	     name, and its bfd section, if any, has compatible flags.  */
	  lang_add_section (&os->children, s, os, file);
	  return TRUE;
	}
    }

  if (hold_text.os == NULL)
    hold_text.os = lang_output_section_find (".text");

  /* If this is a final link, then always put .gnu.warning.SYMBOL
     sections into the .text section to get them out of the way.  */
  if (link_info.executable
      && ! link_info.relocatable
      && strncmp (secname, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0
      && hold_text.os != NULL)
    {
      lang_add_section (&hold_text.os->children, s, hold_text.os, file);
      return TRUE;
    }

  /* Decide which segment the section should go in based on the
     section name and section flags.  We put loadable .note sections
     right after the .interp section, so that the PT_NOTE segment is
     stored right after the program headers where the OS can read it
     in the first page.  */
#define HAVE_SECTION(hold, name) \
(hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)

  if ((s->flags & SEC_EXCLUDE) != 0 && !link_info.relocatable)
    {
      if (s->output_section == NULL)
	s->output_section = bfd_abs_section_ptr;
      return TRUE;
    }

  place = NULL;
  if ((s->flags & SEC_ALLOC) == 0)
    ;
  else if ((s->flags & SEC_LOAD) != 0
	   && strncmp (secname, ".note", 5) == 0
	   && HAVE_SECTION (hold_interp, ".interp"))
    place = &hold_interp;
  else if ((s->flags & SEC_HAS_CONTENTS) == 0
	   && HAVE_SECTION (hold_bss, ".bss"))
    place = &hold_bss;
  else if ((s->flags & SEC_SMALL_DATA) != 0
	   && HAVE_SECTION (hold_sdata, ".sdata"))
    place = &hold_sdata;
  else if ((s->flags & SEC_READONLY) == 0
	   && HAVE_SECTION (hold_data, ".data"))
    place = &hold_data;
  else if (strncmp (secname, ".rel", 4) == 0
	   && (s->flags & SEC_LOAD) != 0
	   && (hold_rel.os != NULL
	       || (hold_rel.os = output_rel_find (s, isdyn)) != NULL))
    place = &hold_rel;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == SEC_READONLY
	   && HAVE_SECTION (hold_rodata, ".rodata"))
    place = &hold_rodata;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == (SEC_CODE | SEC_READONLY)
	   && hold_text.os != NULL)
    place = &hold_text;

#undef HAVE_SECTION

  /* Choose a unique name for the section.  This will be needed if the
     same section name appears in the input file with different
     loadable or allocatable characteristics.  */
  if (bfd_get_section_by_name (output_bfd, secname) != NULL)
    {
      secname = bfd_get_unique_section_name (output_bfd, secname, &count);
      if (secname == NULL)
	einfo ("%F%P: place_orphan failed: %E\n");
    }

  /* Start building a list of statements for this section.
     First save the current statement pointer.  */
  old = stat_ptr;

  /* If we have found an appropriate place for the output section
     statements for this orphan, add them to our own private list,
     inserting them later into the global statement list.  */
  if (place != NULL)
    {
      stat_ptr = &add;
      lang_list_init (stat_ptr);
    }

  if (config.build_constructors)
    {
      /* If the name of the section is representable in C, then create
	 symbols to mark the start and the end of the section.  */
      for (ps = secname; *ps != '\0'; ps++)
	if (! ISALNUM (*ps) && *ps != '_')
	  break;
      if (*ps == '\0')
	{
	  char *symname;
	  etree_type *e_align;

	  symname = (char *) xmalloc (ps - secname + sizeof "__start_");
	  sprintf (symname, "__start_%s", secname);
	  e_align = exp_unop (ALIGN_K,
			      exp_intop ((bfd_vma) 1 << s->alignment_power));
	  lang_add_assignment (exp_assop ('=', symname, e_align));
	}
    }

  address = NULL;
  if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
    address = exp_intop ((bfd_vma) 0);

  load_base = NULL;
  if (place != NULL && place->os->load_base != NULL)
    {
      etree_type *lma_from_vma;
      lma_from_vma = exp_binop ('-', place->os->load_base,
				exp_nameop (ADDR, place->os->name));
      load_base = exp_binop ('+', lma_from_vma,
			     exp_nameop (ADDR, secname));
    }

  os_tail = lang_output_section_statement.tail;
  os = lang_enter_output_section_statement (secname, address, 0,
					    (etree_type *) NULL,
					    (etree_type *) NULL,
					    load_base);

  lang_add_section (&os->children, s, os, file);

  lang_leave_output_section_statement
    ((bfd_vma) 0, "*default*",
     (struct lang_output_section_phdr_list *) NULL, NULL);

  if (config.build_constructors && *ps == '\0')
    {
      char *symname;

      /* lang_leave_ouput_section_statement resets stat_ptr.  Put
	 stat_ptr back where we want it.  */
      if (place != NULL)
	stat_ptr = &add;

      symname = (char *) xmalloc (ps - secname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", secname);
      lang_add_assignment (exp_assop ('=', symname,
				      exp_nameop (NAME, ".")));
    }

  /* Restore the global list pointer.  */
  stat_ptr = old;

  if (place != NULL && os->bfd_section != NULL)
    {
      asection *snew, **pps;

      snew = os->bfd_section;

      /* Shuffle the bfd section list to make the output file look
	 neater.  This is really only cosmetic.  */
      if (place->section == NULL)
	{
	  asection *bfd_section = place->os->bfd_section;

	  /* If the output statement hasn't been used to place
	     any input sections (and thus doesn't have an output
	     bfd_section), look for the closest prior output statement
	     having an output section.  */
	  if (bfd_section == NULL)
	    bfd_section = output_prev_sec_find (place->os);

	  if (bfd_section != NULL && bfd_section != snew)
	    place->section = &bfd_section->next;
	}

      if (place->section != NULL)
	{
	  /* Unlink the section.  */
	  for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	    ;
	  bfd_section_list_remove (output_bfd, pps);

	  /* Now tack it on to the "place->os" section list.  */
	  bfd_section_list_insert (output_bfd, place->section, snew);
	}

      /* Save the end of this list.  Further ophans of this type will
	 follow the one we've just added.  */
      place->section = &snew->next;

      /* The following is non-cosmetic.  We try to put the output
	 statements in some sort of reasonable order here, because
	 they determine the final load addresses of the orphan
	 sections.  In addition, placing output statements in the
	 wrong order may require extra segments.  For instance,
	 given a typical situation of all read-only sections placed
	 in one segment and following that a segment containing all
	 the read-write sections, we wouldn't want to place an orphan
	 read/write section before or amongst the read-only ones.  */
      if (add.head != NULL)
	{
	  lang_statement_union_type *newly_added_os;

	  if (place->stmt == NULL)
	    {
	      /* Put the new statement list right at the head.  */
	      *add.tail = place->os->header.next;
	      place->os->header.next = add.head;

	      place->os_tail = &place->os->next;
	    }
	  else
	    {
	      /* Put it after the last orphan statement we added.  */
	      *add.tail = *place->stmt;
	      *place->stmt = add.head;
	    }

	  /* Fix the global list pointer if we happened to tack our
	     new list at the tail.  */
	  if (*old->tail == add.head)
	    old->tail = add.tail;

	  /* Save the end of this list.  */
	  place->stmt = add.tail;

	  /* Do the same for the list of output section statements.  */
	  newly_added_os = *os_tail;
	  *os_tail = NULL;
	  newly_added_os->output_section_statement.next = *place->os_tail;
	  *place->os_tail = newly_added_os;
	  place->os_tail = &newly_added_os->output_section_statement.next;

	  /* Fixing the global list pointer here is a little different.
	     We added to the list in lang_enter_output_section_statement,
	     trimmed off the new output_section_statment above when
	     assigning *os_tail = NULL, but possibly added it back in
	     the same place when assigning *place->os_tail.  */
	  if (*os_tail == NULL)
	    lang_output_section_statement.tail = os_tail;
	}
    }

  return TRUE;
}
EOF
fi

if test x"$LDEMUL_FINISH" != xgld"$EMULATION_NAME"_finish; then
cat >>e${EMULATION_NAME}.c <<EOF

static void
gld${EMULATION_NAME}_finish (void)
{
  if (bfd_elf_discard_info (output_bfd, &link_info))
    {
      lang_reset_memory_regions ();

      /* Resize the sections.  */
      lang_size_sections (stat_ptr->head, abs_output_section,
			  &stat_ptr->head, 0, (bfd_vma) 0, NULL, TRUE);

      /* Redo special stuff.  */
      ldemul_after_allocation ();

      /* Do the assignments again.  */
      lang_do_assignments (stat_ptr->head, abs_output_section,
			   (fill_type *) 0, (bfd_vma) 0);
    }
}
EOF
fi

if test x"$LDEMUL_GET_SCRIPT" != xgld"$EMULATION_NAME"_get_script; then
cat >>e${EMULATION_NAME}.c <<EOF

static char *
gld${EMULATION_NAME}_get_script (int *isfile)
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
if cmp -s ldscripts/${EMULATION_NAME}.x ldscripts/${EMULATION_NAME}.xn; then : ; else
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_PIE_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.pie && link_info.combreloc && config.data_bss_contig == TRUE) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdcz                >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.pie && link_info.combreloc) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdc                >> e${EMULATION_NAME}.c
fi
echo '  ; else if (link_info.pie && config.data_bss_contig == TRUE) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdz                >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.pie) return'	       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xd                 >> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_SHLIB_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.shared && link_info.combreloc) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xsc                >> e${EMULATION_NAME}.c
fi
echo '  ; else if (link_info.shared) return'	       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs                 >> e${EMULATION_NAME}.c
fi
echo '  ; else if (config.data_bss_contig == TRUE) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xz                 >> e${EMULATION_NAME}.c
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.combreloc) return'        >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xc                 >> e${EMULATION_NAME}.c
fi
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 1;

  if (link_info.relocatable && config.build_constructors)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
EOF
if cmp -s ldscripts/${EMULATION_NAME}.x ldscripts/${EMULATION_NAME}.xn; then :
else
cat >>e${EMULATION_NAME}.c <<EOF
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
EOF
fi
if test -n "$GENERATE_PIE_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.pie && link_info.combreloc && config.data_bss_contig == TRUE)
    return "ldscripts/${EMULATION_NAME}.xdcz";
  else if (link_info.pie && link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xdc";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.pie && config.data_bss_contig == TRUE)
    return "ldscripts/${EMULATION_NAME}.xdz";
  else if (link_info.pie)
    return "ldscripts/${EMULATION_NAME}.xd";
EOF
fi
if test -n "$GENERATE_SHLIB_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.shared && link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xsc";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.shared)
    return "ldscripts/${EMULATION_NAME}.xs";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
  else if (config.data_bss_contig == TRUE)
    return "ldscripts/${EMULATION_NAME}.xz";
EOF
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xc";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
  else
    return "ldscripts/${EMULATION_NAME}.x";
}

EOF
fi
fi

if test -n "$PARSE_AND_LIST_ARGS_CASES" -o x"$GENERATE_SHLIB_SCRIPT" = xyes; then

if test -n "$PARSE_AND_LIST_PROLOGUE" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_PROLOGUE
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF

#define OPTION_DISABLE_NEW_DTAGS	(400)
#define OPTION_ENABLE_NEW_DTAGS		(OPTION_DISABLE_NEW_DTAGS + 1)
#define OPTION_GROUP			(OPTION_ENABLE_NEW_DTAGS + 1)
#define OPTION_EH_FRAME_HDR		(OPTION_GROUP + 1)

static void
gld${EMULATION_NAME}_add_options
  (int ns, char **shortopts, int nl, struct option **longopts,
   int nrl ATTRIBUTE_UNUSED, struct option **really_longopts ATTRIBUTE_UNUSED)
{
  static const char xtra_short[] = "${PARSE_AND_LIST_SHORTOPTS}z:";
  static const struct option xtra_long[] = {
EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
cat >>e${EMULATION_NAME}.c <<EOF
    {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
    {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
    {"eh-frame-hdr", no_argument, NULL, OPTION_EH_FRAME_HDR},
    {"Bgroup", no_argument, NULL, OPTION_GROUP},
EOF
fi

if test -n "$PARSE_AND_LIST_LONGOPTS" ; then
cat >>e${EMULATION_NAME}.c <<EOF
    $PARSE_AND_LIST_LONGOPTS
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
    {NULL, no_argument, NULL, 0}
  };

  *shortopts = (char *) xrealloc (*shortopts, ns + sizeof (xtra_short));
  memcpy (*shortopts + ns, &xtra_short, sizeof (xtra_short));
  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

static bfd_boolean
gld${EMULATION_NAME}_handle_option (int optc)
{
  switch (optc)
    {
    default:
      return FALSE;

EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
cat >>e${EMULATION_NAME}.c <<EOF
    case OPTION_DISABLE_NEW_DTAGS:
      link_info.new_dtags = FALSE;
      break;

    case OPTION_ENABLE_NEW_DTAGS:
      link_info.new_dtags = TRUE;
      break;

    case OPTION_EH_FRAME_HDR:
      link_info.eh_frame_hdr = TRUE;
      break;

    case OPTION_GROUP:
      link_info.flags_1 |= (bfd_vma) DF_1_GROUP;
      /* Groups must be self-contained.  */
      link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
      link_info.unresolved_syms_in_shared_libs = RM_GENERATE_ERROR;
      break;

    case 'z':
      if (strcmp (optarg, "initfirst") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INITFIRST;
      else if (strcmp (optarg, "interpose") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INTERPOSE;
      else if (strcmp (optarg, "loadfltr") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_LOADFLTR;
      else if (strcmp (optarg, "nodefaultlib") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODEFLIB;
      else if (strcmp (optarg, "nodelete") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODELETE;
      else if (strcmp (optarg, "nodlopen") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NOOPEN;
      else if (strcmp (optarg, "nodump") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODUMP;
      else if (strcmp (optarg, "now") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_BIND_NOW;
	  link_info.flags_1 |= (bfd_vma) DF_1_NOW;
	}
      else if (strcmp (optarg, "origin") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_ORIGIN;
	  link_info.flags_1 |= (bfd_vma) DF_1_ORIGIN;
	}
      else if (strcmp (optarg, "defs") == 0)
	link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
      else if (strcmp (optarg, "muldefs") == 0)
	link_info.allow_multiple_definition = TRUE;
      else if (strcmp (optarg, "combreloc") == 0)
	link_info.combreloc = TRUE;
      else if (strcmp (optarg, "nocombreloc") == 0)
	link_info.combreloc = FALSE;
      else if (strcmp (optarg, "nocopyreloc") == 0)
	link_info.nocopyreloc = TRUE;
      else if (strcmp (optarg, "execstack") == 0)
	{
	  link_info.execstack = TRUE;
	  link_info.noexecstack = FALSE;
	}
      else if (strcmp (optarg, "noexecstack") == 0)
	{
	  link_info.noexecstack = TRUE;
	  link_info.execstack = FALSE;
	}
      /* What about the other Solaris -z options? FIXME.  */
      break;
EOF
fi

if test -n "$PARSE_AND_LIST_ARGS_CASES" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_ARGS_CASES
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
    }

  return TRUE;
}

EOF

if test x"$LDEMUL_LIST_OPTIONS" != xgld"$EMULATION_NAME"_list_options; then
cat >>e${EMULATION_NAME}.c <<EOF

static void
gld${EMULATION_NAME}_list_options (FILE * file)
{
EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
cat >>e${EMULATION_NAME}.c <<EOF
  fprintf (file, _("  -Bgroup\t\tSelects group name lookup rules for DSO\n"));
  fprintf (file, _("  --disable-new-dtags\tDisable new dynamic tags\n"));
  fprintf (file, _("  --enable-new-dtags\tEnable new dynamic tags\n"));
  fprintf (file, _("  --eh-frame-hdr\tCreate .eh_frame_hdr section\n"));
  fprintf (file, _("  -z combreloc\t\tMerge dynamic relocs into one section and sort\n"));
  fprintf (file, _("  -z defs\t\tReport unresolved symbols in object files.\n"));
  fprintf (file, _("  -z execstack\t\tMark executable as requiring executable stack\n"));
  fprintf (file, _("  -z initfirst\t\tMark DSO to be initialized first at runtime\n"));
  fprintf (file, _("  -z interpose\t\tMark object to interpose all DSOs but executable\n"));
  fprintf (file, _("  -z loadfltr\t\tMark object requiring immediate process\n"));
  fprintf (file, _("  -z muldefs\t\tAllow multiple definitions\n"));
  fprintf (file, _("  -z nocombreloc\tDon't merge dynamic relocs into one section\n"));
  fprintf (file, _("  -z nocopyreloc\tDon't create copy relocs\n"));
  fprintf (file, _("  -z nodefaultlib\tMark object not to use default search paths\n"));
  fprintf (file, _("  -z nodelete\t\tMark DSO non-deletable at runtime\n"));
  fprintf (file, _("  -z nodlopen\t\tMark DSO not available to dlopen\n"));
  fprintf (file, _("  -z nodump\t\tMark DSO not available to dldump\n"));
  fprintf (file, _("  -z noexecstack\tMark executable as not requiring executable stack\n"));
  fprintf (file, _("  -z now\t\tMark object non-lazy runtime binding\n"));
  fprintf (file, _("  -z origin\t\tMark object requiring immediate \$ORIGIN processing\n\t\t\t  at runtime\n"));
  fprintf (file, _("  -z KEYWORD\t\tIgnored for Solaris compatibility\n"));
EOF
fi

if test -n "$PARSE_AND_LIST_OPTIONS" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_OPTIONS
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
}
EOF

if test -n "$PARSE_AND_LIST_EPILOGUE" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_EPILOGUE
EOF
fi
fi
else
cat >>e${EMULATION_NAME}.c <<EOF
#define gld${EMULATION_NAME}_add_options NULL
#define gld${EMULATION_NAME}_handle_option NULL
EOF
if test x"$LDEMUL_LIST_OPTIONS" != xgld"$EMULATION_NAME"_list_options; then
cat >>e${EMULATION_NAME}.c <<EOF
#define gld${EMULATION_NAME}_list_options NULL
EOF
fi
fi

cat >>e${EMULATION_NAME}.c <<EOF

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  ${LDEMUL_BEFORE_PARSE-gld${EMULATION_NAME}_before_parse},
  ${LDEMUL_SYSLIB-syslib_default},
  ${LDEMUL_HLL-hll_default},
  ${LDEMUL_AFTER_PARSE-after_parse_default},
  ${LDEMUL_AFTER_OPEN-gld${EMULATION_NAME}_after_open},
  ${LDEMUL_AFTER_ALLOCATION-after_allocation_default},
  ${LDEMUL_SET_OUTPUT_ARCH-set_output_arch_default},
  ${LDEMUL_CHOOSE_TARGET-ldemul_default_target},
  ${LDEMUL_BEFORE_ALLOCATION-gld${EMULATION_NAME}_before_allocation},
  ${LDEMUL_GET_SCRIPT-gld${EMULATION_NAME}_get_script},
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  ${LDEMUL_FINISH-gld${EMULATION_NAME}_finish},
  ${LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS-NULL},
  ${LDEMUL_OPEN_DYNAMIC_ARCHIVE-gld${EMULATION_NAME}_open_dynamic_archive},
  ${LDEMUL_PLACE_ORPHAN-gld${EMULATION_NAME}_place_orphan},
  ${LDEMUL_SET_SYMBOLS-NULL},
  ${LDEMUL_PARSE_ARGS-NULL},
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
  ${LDEMUL_UNRECOGNIZED_FILE-NULL},
  ${LDEMUL_LIST_OPTIONS-gld${EMULATION_NAME}_list_options},
  ${LDEMUL_RECOGNIZED_FILE-gld${EMULATION_NAME}_load_symbols},
  ${LDEMUL_FIND_POTENTIAL_LIBRARIES-NULL},
  ${LDEMUL_NEW_VERS_PATTERN-NULL}
};
EOF
@


1.21
log
@Don't free pathname after successfull _try_needed call; it's cached in that
case.  Fixes "could not read symbols: File truncated" problems.
ok deraadt@@
@
text
@d1743 2
d1748 2
d1795 2
d1802 2
@


1.20
log
@Partially revert to binutils 2.14: do not put a ``warning: '' prefix
to stabs warning messages, as we already provide it in the message. This
will not change until all our supported architectures move to ELF.
@
text
@a630 1
	free(found);
@


1.19
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@a1172 1
	bfd_size_type prefix_len;
a1174 1
	const char * gnu_warning_prefix = _("warning: ");
d1184 2
a1185 5
	prefix_len = strlen (gnu_warning_prefix);
	msg = xmalloc ((size_t) (prefix_len + sz + 1));
	strcpy (msg, gnu_warning_prefix);
	if (! bfd_get_section_contents (is->the_bfd, s,	msg + prefix_len,
					(file_ptr) 0, sz))
d1188 1
a1188 1
	msg[prefix_len + sz] = '\0';
@


1.18
log
@Lookup libraries based on version numbers for implicit as well explict libraries
ok espie@@
@
text
@d16 1
a16 1
   2002, 2003 Free Software Foundation, Inc.
d56 4
a59 26
static void gld${EMULATION_NAME}_before_parse
  PARAMS ((void));
static void gld${EMULATION_NAME}_vercheck
  PARAMS ((lang_input_statement_type *));
static void gld${EMULATION_NAME}_stat_needed
  PARAMS ((lang_input_statement_type *));
static bfd_boolean gld${EMULATION_NAME}_try_needed
  PARAMS ((const char *, int));
static bfd_boolean gld${EMULATION_NAME}_search_needed
  PARAMS ((const char *, const char *, int));
static void gld${EMULATION_NAME}_check_needed
  PARAMS ((lang_input_statement_type *));
static void gld${EMULATION_NAME}_after_open
  PARAMS ((void));
static void gld${EMULATION_NAME}_find_exp_assignment
  PARAMS ((etree_type *));
static void gld${EMULATION_NAME}_find_statement_assignment
  PARAMS ((lang_statement_union_type *));
static void gld${EMULATION_NAME}_before_allocation
  PARAMS ((void));
static bfd_boolean gld${EMULATION_NAME}_open_dynamic_archive
  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
static lang_output_section_statement_type *output_rel_find
  PARAMS ((asection *));
static asection *output_prev_sec_find
  PARAMS ((lang_output_section_statement_type *));
d61 2
a62 5
  PARAMS ((lang_input_statement_type *, asection *));
static void gld${EMULATION_NAME}_finish
  PARAMS ((void));
static char *gld${EMULATION_NAME}_get_script
  PARAMS ((int *isfile));
d313 1
a313 1
gld${EMULATION_NAME}_before_parse ()
d315 1
a315 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;
d323 22
d375 1
a375 2
gld${EMULATION_NAME}_vercheck (s)
     lang_input_statement_type *s;
d412 4
a415 4
             the object we are considering needs a dynamic object
             FOO.SO.VER2, and VER1 and VER2 are different.  This
             appears to be a version mismatch, so we tell the caller
             to try a different version of this library.  */
d427 1
a427 2
gld${EMULATION_NAME}_stat_needed (s)
     lang_input_statement_type *s;
d482 1
a482 3
gld${EMULATION_NAME}_try_needed (name, force)
     const char *name;
     int force;
d529 1
a529 1
                 another file on the search path.  */
d534 5
a538 5
             library does not use libc at all, we are supposed to skip
             it the first time around in case we encounter a shared
             library later on with the same name which does use the
             version of libc that we want.  This is much too horrible
             to use on any system other than Linux.  */
d588 2
a589 2
         we aren't going to do anything with it.  */
      free(soname);
d593 7
a599 8
  /* Tell the ELF backend that we don't want the output file to have a
     DT_NEEDED entry for this file.  */
  bfd_elf_set_dt_needed_name (abfd, "");

  /* Tell the ELF backend that the output file needs a DT_NEEDED
     entry for this file if it is used to resolve the reference in
     a regular object.  */
  bfd_elf_set_dt_needed_soname (abfd, soname);
d612 1
a612 4
gld${EMULATION_NAME}_search_needed (path, name, force)
     const char *path;
     const char *name;
     int force;
a679 2
static char * gld${EMULATION_NAME}_add_sysroot PARAMS ((const char *));

d681 1
a681 2
gld${EMULATION_NAME}_add_sysroot (path)
     const char *path;
d704 1
a704 1
        *p++ = path[i++];
a722 3
static bfd_boolean gld${EMULATION_NAME}_check_ld_so_conf
  PARAMS ((const char *, int));

d724 1
a724 3
gld${EMULATION_NAME}_check_ld_so_conf (name, force)
     const char *name;
     int force;
d815 1
a815 2
gld${EMULATION_NAME}_check_needed (s)
     lang_input_statement_type *s;
d864 1
a864 1
gld${EMULATION_NAME}_after_open ()
d869 1
a869 1
  if (link_info.relocateable || link_info.shared)
d910 1
a910 1
	 We look at the -L arguments to build search path.
d942 1
a942 1
	  if (getenv("LD_RUN_PATH") != NULL
d952 13
a964 13
	  len = strlen(search_head->name);
	  lib_path = xstrdup(search_head->name);
	  for (search = search_head->next; search != NULL;
	       search = search->next)
	    {
	      size_t nlen;

	      nlen = strlen(search->name);
	      lib_path = xrealloc(lib_path, len + nlen + 2);
	      lib_path[len] = ':';
	      strcpy(lib_path + len + 1, search->name);
	      len += nlen + 1;
	    }
d967 5
a971 5
	    {
	      free(lib_path);
	      break;
	    }
	  free(lib_path);
d973 2
a974 2
	  lib_path = getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
d1043 1
a1043 2
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
d1067 1
a1067 1
	  if (! (bfd_elf${ELFSIZE}_record_link_assignment
d1103 1
a1103 2
gld${EMULATION_NAME}_find_statement_assignment (s)
     lang_statement_union_type *s;
d1130 1
a1130 1
gld${EMULATION_NAME}_before_allocation ()
d1135 3
d1148 2
a1149 2
  if (! (bfd_elf${ELFSIZE}_size_dynamic_sections
         (output_bfd, command_line.soname, rpath,
d1173 1
d1176 1
d1186 5
a1190 2
	msg = xmalloc ((size_t) sz + 1);
	if (! bfd_get_section_contents (is->the_bfd, s, msg, (file_ptr) 0, sz))
d1193 1
a1193 1
	msg[sz] = '\0';
d1219 2
a1220 4
gld${EMULATION_NAME}_open_dynamic_archive (arch, search, entry)
     const char *arch;
     search_dirs_type *search;
     lang_input_statement_type *entry;
d1310 1
a1310 2
output_rel_find (sec)
     asection *sec;
d1315 1
a1324 3
	  /* Don't place after .rel.plt as doing so results in wrong
	     dynamic tags.  Also, place allocated reloc sections before
	     non-allocated.  */
d1327 8
a1334 3
	  if (strcmp (".plt", lookup->name + 4 + lookrela) == 0
	      || (lookup->bfd_section != NULL
		  && (lookup->bfd_section->flags & SEC_ALLOC) == 0))
d1336 2
a1337 2
	  last = lookup;
	  if (rela == lookrela)
d1339 2
a1340 1
	  if (lookup->bfd_section != NULL
d1344 5
d1357 3
d1367 1
a1367 2
output_prev_sec_find (os)
     lang_output_section_statement_type *os;
d1399 1
a1399 3
gld${EMULATION_NAME}_place_orphan (file, s)
     lang_input_statement_type *file;
     asection *s;
d1421 1
a1421 1
  if (! link_info.relocateable
d1455 2
a1456 2
  if (! link_info.shared
      && ! link_info.relocateable
d1472 1
a1472 1
  if ((s->flags & SEC_EXCLUDE) != 0 && !link_info.relocateable)
d1498 1
a1498 1
	       || (hold_rel.os = output_rel_find (s)) != NULL))
d1553 1
a1553 1
  if (link_info.relocateable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
a1567 1
					    (bfd_vma) 0,
d1696 1
a1696 1
gld${EMULATION_NAME}_finish ()
d1698 1
a1698 1
  if (bfd_elf${ELFSIZE}_discard_info (output_bfd, &link_info))
d1721 1
a1721 2
gld${EMULATION_NAME}_get_script (isfile)
     int *isfile;
d1735 1
a1735 1
  if (link_info.relocateable && config.build_constructors)
d1739 1
a1739 1
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
d1747 8
d1780 1
a1780 1
  if (link_info.relocateable && config.build_constructors)
d1782 1
a1782 1
  else if (link_info.relocateable)
d1794 12
a1851 3
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));

d1853 3
a1855 7
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns;
     char **shortopts;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
a1886 3
static bfd_boolean gld${EMULATION_NAME}_handle_option
  PARAMS ((int));

d1888 1
a1888 2
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
d1914 2
a1915 1
      link_info.no_undefined = TRUE;
d1944 1
a1944 1
	link_info.no_undefined = TRUE;
d1952 11
a1962 1
        link_info.nocopyreloc = TRUE;
a1984 2
static void gld${EMULATION_NAME}_list_options PARAMS ((FILE * file));

d1986 1
a1986 2
gld${EMULATION_NAME}_list_options (file)
     FILE * file;
d1997 2
a1998 1
  fprintf (file, _("  -z defs\t\tDisallows undefined symbols\n"));
d2009 1
d2070 1
a2070 1
  ${LDEMUL_RECOGNIZED_FILE-NULL},
@


1.17
log
@remove the disabled DO_FORCE_VERS support.

ok drahn@@
@
text
@d98 110
d209 1
a209 1
gld${EMULATION_NAME}_search_dir (dirname, filename)
d212 1
d296 5
a300 4
      if (found == NULL
	  || (found_maj > max_maj)
	  || (found_maj == max_maj
	      && (found_min > max_min)))
d641 19
d1257 1
a1257 1
  string = gld${EMULATION_NAME}_search_dir(search->name, filename);
@


1.16
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@a102 1
  int force_maj, force_min;
a104 1
  char *alc;
a113 2
  force_maj = -1;
  force_min = -1;
d115 1
a115 24
#ifdef DO_FORCE_VERS
  if (dot == NULL)
    {
#endif /* DO_FORCE_VERS */
      len = strlen (filename);
      alc = NULL;
#ifdef DO_FORCE_VERS
    }
  else
    {
      force_maj = atoi (dot + 1);

      len = dot - filename;
      alc = (char *) xmalloc (len + 1);
      strncpy (alc, filename, len);
      alc[len] = '\0';
      filename = alc;

      dot = strchr (dot + 1, '.');
      if (dot != NULL)
	force_min = atoi (dot + 1);
    }
#endif /* DO_FORCE_VERS */

a174 4
      if ((force_maj != -1 && force_maj != found_maj)
	  || (force_min != -1 && force_min != found_min))
	continue;

a199 3

  if (alc != NULL)
    free (alc);
@


1.15
log
@If gld${EMULATION_NAME}_search_dir() returns NULL, return early
and try not to fopen(NULL, ...) later.

ok millert@@
@
text
@d6 5
d15 2
a16 2
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d41 2
a42 2

#include <ctype.h>
d53 1
a53 1
#include "ldgram.h"
d56 2
a57 1
static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
d62 3
a64 2
static boolean gld${EMULATION_NAME}_try_needed PARAMS ((const char *, int));
static boolean gld${EMULATION_NAME}_search_needed
d68 4
a71 2
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
d74 3
a76 2
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
static boolean gld${EMULATION_NAME}_open_dynamic_archive
d78 5
a82 2
static lang_output_section_statement_type *output_rel_find PARAMS ((void));
static boolean gld${EMULATION_NAME}_place_orphan
d84 4
a87 1
static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
d171 1
a171 1
	       && isdigit ((unsigned char) entry->d_name[7 + len]))
d177 1
a177 1
	if (*s != '.' && ! isdigit ((unsigned char) *s))
d262 11
a272 3
  ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;
  config.dynamic_link = ${DYNAMIC_LINK-true};
  config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo true ; else echo false ; fi`;
d285 1
a285 1
static boolean global_found;
d287 1
a287 1
static boolean global_vercheck_failed;
d322 1
a322 1
    soname = basename (bfd_get_filename (s->the_bfd));
d350 1
a350 1
	  global_vercheck_failed = true;
d382 1
a382 1
      global_found = true;
d404 1
a404 1
    soname = basename (s->filename);
d406 1
a406 2
  if (strncmp (soname, global_needed->name,
	       suffix - global_needed->name) == 0)
d416 1
a416 1
static boolean
d426 1
a426 1
    return false;
d429 2
a430 2
      (void) bfd_close (abfd);
      return false;
d434 9
a442 2
      (void) bfd_close (abfd);
      return false;
d460 1
a460 1
	  global_vercheck_failed = false;
d464 2
a465 2
	      (void) bfd_close (abfd);
	      /* Return false to force the caller to move on to try
d467 1
a467 1
	      return false;
d489 2
a490 2
		(void) bfd_close (abfd);
		return false;
d515 1
a515 1
  soname = xstrdup (basename (abfd->filename));
d520 1
a520 1
  global_found = false;
d524 1
a524 1
      /* Return true to indicate that we found the file, even though
d526 2
a527 2
      free (soname);
      return true;
d543 1
a543 1
  return true;
d549 1
a549 1
static boolean
d562 1
a562 1
    return false;
d584 1
a584 1
	return true;
d593 1
a593 1
  return false;
d597 13
a609 6
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
    case ${target} in
      *-*-linux-gnu*)
	cat >>e${EMULATION_NAME}.c <<EOF
d611 33
d648 1
a648 1
static boolean gld${EMULATION_NAME}_check_ld_so_conf
d651 1
a651 1
static boolean
d656 1
a656 1
  static boolean initialized;
d662 1
d664 3
a666 1
      f = fopen ("/etc/ld.so.conf", FOPEN_RT);
d716 7
d726 1
a726 1
      initialized = true;
d730 1
a730 1
    return false;
d736 2
a737 3
	# Linux
	;;
    esac
d757 1
a757 1
	  global_found = true;
d767 1
a767 1
	      global_found = true;
d781 1
a781 1
	  global_found = true;
d827 1
a827 1
      global_found = false;
d851 1
a851 3
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
a856 2
  ;;
  esac
d864 1
a864 3
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
d869 4
d907 4
a910 1

d915 1
d917 1
a917 1
		       && gld${EMULATION_NAME}_search_needed (rp->name,
d920 1
a925 2
  ;;
  esac
d944 4
a947 6
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
    case ${target} in
      *-*-linux-gnu*)
	cat >>e${EMULATION_NAME}.c <<EOF
d951 2
a952 4
	# Linux
        ;;
    esac
  ;;
d983 1
a983 1
				false, false, false);
d1001 1
a1001 1
		  exp->type.node_class == etree_provide ? true : false)))
d1045 12
d1080 1
a1080 1
	  command_line.export_dynamic, command_line.filter_shlib,
d1084 1
a1084 1

d1104 1
a1104 1
	boolean ret;
d1143 1
a1143 1
static boolean
d1153 1
a1153 1
    return false;
d1162 1
a1162 1
    return false;
d1195 1
a1195 1
      return false;
d1221 1
a1221 1
      filename = xstrdup (basename (entry->filename));
d1225 1
a1225 1
  return true;
d1230 2
d1237 2
a1238 1
output_rel_find ()
d1242 4
d1247 1
a1247 3
  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
d1250 1
a1250 3
      if (strncmp (".rel", lookup->name, 4) == 0
	  && lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
d1252 15
a1266 1
	  return lookup;
d1269 8
a1276 1
  return (lang_output_section_statement_type *) NULL;
d1279 22
a1300 1
EOF
d1302 2
a1303 2
if test x"$LDEMUL_PLACE_ORPHAN" != xgld"$EMULATION_NAME"_place_orphan; then
cat >>e${EMULATION_NAME}.c <<EOF
d1312 1
d1315 1
a1315 1
static boolean
a1332 1
  const char *outsecname;
d1335 3
d1340 11
d1352 1
a1352 1
  if (! config.unique_orphan_sections && ! unique_section_p (secname))
d1358 3
a1360 3
	  && os->bfd_section != NULL
	  && ((s->flags ^ os->bfd_section->flags)
	      & (SEC_LOAD | SEC_ALLOC)) == 0)
d1362 4
a1365 3
	  /* We have already placed a section with this name.  */
	  wild_doit (&os->children, s, os, file);
	  return true;
d1379 2
a1380 2
      wild_doit (&hold_text.os->children, s, hold_text.os, file);
      return true;
d1391 6
a1396 2
  if (s->flags & SEC_EXCLUDE)
    return false;
d1415 1
d1417 1
a1417 1
	       || (hold_rel.os = output_rel_find ()) != NULL))
d1431 1
a1431 2
  outsecname = secname;
  if (bfd_get_section_by_name (output_bfd, outsecname) != NULL)
d1433 2
a1434 4
      outsecname = bfd_get_unique_section_name (output_bfd,
						outsecname,
						&count);
      if (outsecname == NULL)
d1455 2
a1456 2
      for (ps = outsecname; *ps != '\0'; ps++)
	if (! isalnum ((unsigned char) *ps) && *ps != '_')
d1463 2
a1464 2
	  symname = (char *) xmalloc (ps - outsecname + sizeof "__start_");
	  sprintf (symname, "__start_%s", outsecname);
d1471 1
a1473 2
  else
    address = NULL;
d1475 12
a1486 1
  os = lang_enter_output_section_statement (outsecname, address, 0,
d1490 1
a1490 1
					    (etree_type *) NULL);
d1492 1
a1492 1
  wild_doit (&os->children, s, os, file);
d1496 1
a1496 1
     (struct lang_output_section_phdr_list *) NULL, "*default*");
d1507 2
a1508 2
      symname = (char *) xmalloc (ps - outsecname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", outsecname);
d1516 1
a1516 1
  if (place != NULL)
d1521 4
a1524 3
      if (place->section != NULL
	  || (place->os->bfd_section != NULL
	      && place->os->bfd_section != snew))
d1526 12
a1537 18
	  /* Shuffle the section to make the output file look neater.
	     This is really only cosmetic.  */
	  if (place->section == NULL)
	    {
#if 0
	      /* Finding the end of the list is a little tricky.  We
		 make a wild stab at it by comparing section flags.  */
	      flagword first_flags = place->os->bfd_section->flags;
	      for (pps = &place->os->bfd_section->next;
		   *pps != NULL && (*pps)->flags == first_flags;
		   pps = &(*pps)->next)
		;
	      place->section = pps;
#else
	      /* Put orphans after the first section on the list.  */
	      place->section = &place->os->bfd_section->next;
#endif
	    }
d1539 3
a1541 1
	  /*  Unlink the section.  */
d1544 1
a1544 1
	  *pps = snew->next;
d1547 1
a1547 2
	  snew->next = *place->section;
	  *place->section = snew;
a1548 1
      place->section = &snew->next;	/* Save the end of this list.  */
d1550 13
d1565 2
a1566 3
	  /* We try to put the output statements in some sort of
	     reasonable order here, because they determine the final
	     load addresses of the orphan sections.  */
d1572 2
d1589 15
d1607 1
a1607 1
  return true;
d1609 5
d1615 19
d1656 1
a1656 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1659 9
a1667 8
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c

d1669 16
a1684 9
echo '  ; else if (link_info.shared) return'		   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs                     >> e${EMULATION_NAME}.c
fi

echo '  ; else if (config.data_bss_contig == true) return'   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xz                     >> e${EMULATION_NAME}.c
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
d1693 1
a1693 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1695 1
a1695 1
  else if (link_info.relocateable == true)
d1699 4
d1705 10
d1717 4
a1720 1
  else if (config.data_bss_contig == true)
d1722 8
a1739 2
if test x"$LDEMUL_PARSE_ARGS" != xgld"$EMULATION_NAME"_parse_args; then

a1747 2
#include "getopt.h"

d1751 1
d1753 11
a1763 1
static struct option longopts[] =
d1765 2
d1771 4
a1774 8
  /* getopt allows abbreviations, so we do this to stop it from
     treating -d/-e as abbreviations for these options. */
  {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
  {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
  {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
  {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
  {"Bgroup", no_argument, NULL, OPTION_GROUP},
  {"Bgroup", no_argument, NULL, OPTION_GROUP},
d1780 1
a1780 1
 $PARSE_AND_LIST_LONGOPTS
d1785 2
a1786 2
  {NULL, no_argument, NULL, 0}
};
d1788 6
d1795 2
a1796 23
static int gld${EMULATION_NAME}_parse_args PARAMS ((int, char **));

static int
gld${EMULATION_NAME}_parse_args (argc, argv)
     int argc;
     char ** argv;
{
  int longind;
  int optc;
  static int prevoptind = -1;
  int prevopterr = opterr;
  int wanterror;

  if (prevoptind != optind)
    opterr = 0;

  wanterror = opterr;
  prevoptind = optind;

  optc = getopt_long_only (argc, argv,
			   "-${PARSE_AND_LIST_SHORTOPTS}z:", longopts,
			   &longind);
  opterr = prevopterr;
d1798 4
d1805 1
a1805 4
      if (wanterror)
	xexit (1);
      optind = prevoptind;
      return 0;
d1812 1
a1812 1
      link_info.new_dtags = false;
d1816 5
a1820 1
      link_info.new_dtags = true;
d1826 1
a1826 1
      link_info.no_undefined = true;
d1855 9
a1863 1
	link_info.no_undefined = true;
d1878 1
a1878 1
  return 1;
a1881 1
fi
d1899 2
d1905 3
d1913 1
a1913 2
  fprintf (file, _("  -z origin\t\tMark object requiring immediate \$ORIGIN processing\n"));
  fprintf (file, _("\t\t\t  at runtime\n"));
a1934 1
if test x"$LDEMUL_PARSE_ARGS" != xgld"$EMULATION_NAME"_parse_args; then
d1936 2
a1937 1
#define gld${EMULATION_NAME}_parse_args   NULL
a1938 1
fi
d1962 1
a1962 1
  ${LDEMUL_FINISH-NULL},
d1967 3
a1969 1
  ${LDEMUL_PARSE_ARGS-gld${EMULATION_NAME}_parse_args},
d1974 1
@


1.14
log
@This is a project to modify executables so that they do not have any
executable regions which are writable. If a section of an executable is
writable and executable, it is much easier for errant code to modify the
executable's behavior.

Two current areas in shared library environments which have this
critical problem are the GOT (Global Offset Table) and PLT (Procedure
Linkage Table). The PLT is required to be executable and both GOT and
PLT are writable on most architectures. On most ELF architecture
machines this would cause shared libraries to have data and BSS marked
as executable.

Padding to the linker script for programs and shared libraries/objects
to isolate the GOT and PLT into their own load sections in the
executables. This allows only the text(readonly) region and the PLT
region to be marked executable with the normal data and BSS not marked
as executable. The PLT region is still marked executable on most
architectures because the PLT lives in the "data" or "BSS" regions
and the dynamic loader will need to modify it. Since the GOT and PLT
should only ever be written by the dynamic linker, it will be modified
to mprotect those regions so that they are not writable during normal
execution. If the dynamic linker needs to modify the regions later,
(eg for lazy binding), it will mprotect the region, make the necessary
changes, and mprotect it back. Since it is possible to receive a
signal which would interrupt the program flow and perhaps cause the
dynamic linker to modify the same (or nearby) PLT references, it is now
necessary for signals to be blocked for the duration of the mprotect.

This diff was omitted from the original commit, this implements the
-Z option to produce traditional (non protected) executables.
@
text
@d1073 2
@


1.13
log
@Remove the support to force linking against a specific shlib major.minor.
This behavior broke libraries which were named libN-X.Y.so.A.B. ok pval, espie
@
text
@d1462 2
d1485 2
@


1.12
log
@xstrdup the return value of basename() before recording it in the bfd,
fixes the "NEEDED crtend.o" problem that appeared in varios ports and
had to be workarounded.  from thorpej@@NetBSD, thanks to drahn@@ for
pointing it out; ok drahn espie
@
text
@d103 1
d106 1
d109 1
d125 1
@


1.11
log
@resolve conflicts.
@
text
@d395 1
a395 1
  const char *soname;
d481 1
a481 1
  soname = basename (abfd->filename);
d492 1
@


1.11.2.1
log
@Pull patch from current:
Fix by pvalchev@@
xstrdup the return value of basename() before recording it in the bfd, fixes
the "NEEDED crtend.o" problem that appeared in various ports and had to be
workarounded. From thorpej@@NetBSD, pointed out by drahn@@.

deraadt@@ millert@@ drahn@@ ok
@
text
@d395 1
a395 1
  char *soname;
d481 1
a481 1
  soname = xstrdup (basename (abfd->filename));
a491 1
      free (soname);
@


1.11.2.2
log
@Pull patch from current.
Fix by drahn@@
Remove the support to force linking against a specific shlib
major.minor.
This behavior broke libraries which were named libN-X.Y.so.A.B.

ok deraadt@@ millert@@ drahn@@
@
text
@a102 1
#ifdef DO_FORCE_VERS
a104 1
#endif /* DO_FORCE_VERS */
a106 1
#ifdef DO_FORCE_VERS
a121 1
#endif /* DO_FORCE_VERS */
@


1.10
log
@When one shared library requires another, it will try to locate the
required shared library and include it in the link if it's not specified
explicitly.  This change makes ld look at the -L arguments specified,
and build search path.  This avoids the need for -rpath-link, and
somewhat resembles the a.out linker behaviour.  However behaviour of
-rpath and -rpath-link is still preserved as a GNU extension.

ok drahn, espie looked at it too
@
text
@d10 1
a10 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 99, 2000
d35 1
a42 2
#include "ldemul.h"
#include "ldfile.h"
d46 2
d49 1
d52 1
a52 4
static boolean gld${EMULATION_NAME}_open_dynamic_archive
  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static void gld${EMULATION_NAME}_check_needed
d56 1
d59 1
a59 2
static boolean gld${EMULATION_NAME}_try_needed PARAMS ((const char *, int));
static void gld${EMULATION_NAME}_vercheck
d61 2
a62 1
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
d65 3
a67 1
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
d222 17
d240 1
a240 1
gld${EMULATION_NAME}_before_parse()
a246 18
/* Try to open a dynamic archive.  This is where we know that ELF
   dynamic libraries have an extension of .so (or .sl on oddball systems
   like hpux).  */

static boolean
gld${EMULATION_NAME}_open_dynamic_archive (arch, search, entry)
     const char *arch;
     search_dirs_type *search;
     lang_input_statement_type *entry;
{
  const char *filename;
  char *string;

  if (! entry->is_archive)
    return false;

  filename = entry->filename;

d248 1
a248 20
case ${target} in
  *-*-openbsd*)
    cat >>e${EMULATION_NAME}.c <<EOF
  string = gld${EMULATION_NAME}_search_dir(search->name, filename);
EOF
    ;;
  *)
    cat >>e${EMULATION_NAME}.c <<EOF
  /* This allocates a few bytes too many when EXTRA_SHLIB_EXTENSION
     is defined, but it does not seem worth the headache to optimize
     away those two bytes of space.  */
  string = (char *) xmalloc (strlen (search->name)
			     + strlen (filename)
			     + strlen (arch)
#ifdef EXTRA_SHLIB_EXTENSION
			     + strlen (EXTRA_SHLIB_EXTENSION)
#endif
			     + sizeof "/lib.so");

  sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);
a249 3
EOF
    ;;
esac
a250 7
#ifdef EXTRA_SHLIB_EXTENSION
  /* Try the .so extension first.  If that fails build a new filename
     using EXTRA_SHLIB_EXTENSION.  */
  if (! ldfile_try_open_bfd (string, entry))
    sprintf (string, "%s/lib%s%s%s", search->name,
	     filename, arch, EXTRA_SHLIB_EXTENSION);
#endif
d252 2
a253 5
  if (! ldfile_try_open_bfd (string, entry))
    {
      free (string);
      return false;
    }
d255 5
a259 1
  entry->filename = string;
a260 9
  /* We have found a dynamic object to include in the link.  The ELF
     backend linker will create a DT_NEEDED entry in the .dynamic
     section naming this file.  If this file includes a DT_SONAME
     entry, it will be used.  Otherwise, the ELF linker will just use
     the name of the file.  For an archive found by searching, like
     this one, the DT_NEEDED entry should consist of just the name of
     the file, without the path information used to find it.  Note
     that we only need to do this if we have a dynamic object; an
     archive will never be referenced by a DT_NEEDED entry.
d262 5
a266 7
     FIXME: This approach--using bfd_elf_set_dt_needed_name--is not
     very pretty.  I haven't been able to think of anything that is
     pretty, though.  */
  if (bfd_check_format (entry->the_bfd, bfd_object)
      && (entry->the_bfd->flags & DYNAMIC) != 0)
    {
      char *needed_name;
d268 5
a272 1
      ASSERT (entry->is_archive && entry->search_dirs_flag);
d274 4
a277 2
      /* Rather than duplicating the logic above.  Just use the
	 filename we recorded earlier.
d279 6
a284 8
	 First strip off everything before the last '/'.  */
      filename = strrchr (entry->filename, '/');
      filename++;

      needed_name = (char *) xmalloc (strlen (filename) + 1);
      strcpy (needed_name, filename);
      bfd_elf_set_dt_needed_name (entry->the_bfd, needed_name);
    }
d286 5
a290 2
  return true;
}
d292 3
a294 5
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
d296 1
a296 16
/* For a native linker, check the file /etc/ld.so.conf for directories
   in which we may find shared libraries.  /etc/ld.so.conf is really
   only meaningful on Linux, but we check it on other systems anyhow.  */

static boolean gld${EMULATION_NAME}_check_ld_so_conf
  PARAMS ((const char *, int));

static boolean
gld${EMULATION_NAME}_check_ld_so_conf (name, force)
     const char *name;
     int force;
{
  static boolean initialized;
  static char *ld_so_conf;

  if (! initialized)
d298 1
a298 1
      FILE *f;
d300 1
a300 2
      f = fopen ("/etc/ld.so.conf", FOPEN_RT);
      if (f != NULL)
d302 3
a304 3
	  char *b;
	  size_t len, alloc;
	  int c;
d306 2
a307 3
	  len = 0;
	  alloc = 100;
	  b = (char *) xmalloc (alloc);
d309 3
a311 25
	  while ((c = getc (f)) != EOF)
	    {
	      if (len + 1 >= alloc)
		{
		  alloc *= 2;
		  b = (char *) xrealloc (b, alloc);
		}
	      if (c != ':'
		  && c != ' '
		  && c != '\t'
		  && c != '\n'
		  && c != ',')
		{
		  b[len] = c;
		  ++len;
		}
	      else
		{
		  if (len > 0 && b[len - 1] != ':')
		    {
		      b[len] = ':';
		      ++len;
		    }
		}
	    }
d313 1
a313 2
	  if (len > 0 && b[len - 1] == ':')
	    --len;
d315 9
a323 11
	  if (len > 0)
	    b[len] = '\0';
	  else
	    {
	      free (b);
	      b = NULL;
	    }

	  fclose (f);

	  ld_so_conf = b;
a324 2

      initialized = true;
a325 5

  if (ld_so_conf == NULL)
    return false;

  return gld${EMULATION_NAME}_search_needed (ld_so_conf, name, force);
a327 8
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF

/* These variables are required to pass information back and forth
   between after_open and check_needed and stat_needed and vercheck.  */
d329 2
a330 7
static struct bfd_link_needed_list *global_needed;
static struct stat global_stat;
static boolean global_found;
static struct bfd_link_needed_list *global_vercheck_needed;
static boolean global_vercheck_failed;

/* This is called after all the input files have been opened.  */
d333 2
a334 1
gld${EMULATION_NAME}_after_open ()
d336 3
a338 1
  struct bfd_link_needed_list *needed, *l;
d340 3
a342 2
  /* We only need to worry about this when doing a final link.  */
  if (link_info.relocateable || link_info.shared)
d345 1
a345 11
  /* Get the list of files which appear in DT_NEEDED entries in
     dynamic objects included in the link (often there will be none).
     For each such file, we want to track down the corresponding
     library, and include the symbol table in the link.  This is what
     the runtime dynamic linker will do.  Tracking the files down here
     permits one dynamic object to include another without requiring
     special action by the person doing the link.  Note that the
     needed list can actually grow while we are stepping through this
     loop.  */
  needed = bfd_elf_get_needed_list (output_bfd, &link_info);
  for (l = needed; l != NULL; l = l->next)
d347 2
a348 116
      struct bfd_link_needed_list *ll;
      int force;

      /* If we've already seen this file, skip it.  */
      for (ll = needed; ll != l; ll = ll->next)
	if (strcmp (ll->name, l->name) == 0)
	  break;
      if (ll != l)
	continue;

      /* See if this file was included in the link explicitly.  */
      global_needed = l;
      global_found = false;
      lang_for_each_input_file (gld${EMULATION_NAME}_check_needed);
      if (global_found)
	continue;

      /* We need to find this file and include the symbol table.  We
	 want to search for the file in the same way that the dynamic
	 linker will search.  That means that we want to use
	 rpath_link, rpath, then the environment variable
	 LD_LIBRARY_PATH (native only), then the linker script
	 LIB_SEARCH_DIRS.  We look at the -L arguments to build
	 search path.

	 We search twice.  The first time, we skip objects which may
	 introduce version mismatches.  The second time, we force
	 their use.  See gld${EMULATION_NAME}_vercheck comment.  */
      for (force = 0; force < 2; force++)
	{
	  char *lib_path;
	  size_t len;
	  search_dirs_type *search;

	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
						  l->name, force))
	    break;
	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath,
						  l->name, force))
	    break;
	  if (getenv("LD_RUN_PATH") != NULL
	      && command_line.rpath_link == NULL
	      && command_line.rpath == NULL)
	    {
	      lib_path = getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
						      force))
	        break;
	    }
	  len = strlen(search_head->name);
	  lib_path = xstrdup(search_head->name);
	  for (search = search_head->next; search != NULL;
	       search = search->next)
	    {
	      size_t nlen;

	      nlen = strlen(search->name);
	      lib_path = xrealloc(lib_path, len + nlen + 2);
	      lib_path[len] = ':';
	      strcpy(lib_path + len + 1, search->name);
	      len += nlen + 1;
	     }
	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
	                                          force))
	    {
	        free(lib_path);
		break;
	    }
	  free(lib_path);
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
	  lib_path = getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
	    break;
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
	  len = strlen (l->name);
	  for (search = search_head; search != NULL; search = search->next)
	    {
	      char *filename;

	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, "%s/%s", search->name, l->name);
	      if (gld${EMULATION_NAME}_try_needed (filename, force))
		break;
	      free (filename);
	    }
	  if (search != NULL)
	    break;
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
	    break;
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
	}

      if (force < 2)
	continue;

      einfo ("%P: warning: %s, needed by %B, not found (try using -rpath or -rpath-link)\n",
	     l->name, l->by);
a349 1
}
d351 2
a352 15
/* Search for a needed file in a path.  */

static boolean
gld${EMULATION_NAME}_search_needed (path, name, force)
     const char *path;
     const char *name;
     int force;
{
  const char *s;
  size_t len;

  if (path == NULL || *path == '\0')
    return false;
  len = strlen (name);
  while (1)
d354 3
a356 1
      char *filename, *sset;
d358 8
a365 3
      s = strchr (path, ':');
      if (s == NULL)
	s = path + strlen (path);
d367 6
a372 10
      filename = (char *) xmalloc (s - path + len + 2);
      if (s == path)
	sset = filename;
      else
	{
	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
d374 3
a376 2
      if (gld${EMULATION_NAME}_try_needed (filename, force))
	return true;
d378 5
a382 6
      free (filename);

      if (*s == '\0')
	break;
      path = s + 1;
    }
a383 2
  return false;	  
}
d395 1
d479 7
d495 1
a495 1
  /* Tell the ELF backend that don't want the output file to have a
d499 5
a510 1
/* See if an input file matches a DT_NEEDED entry by name.  */
d512 7
a518 3
static void
gld${EMULATION_NAME}_check_needed (s)
     lang_input_statement_type *s;
d520 5
a524 2
  if (global_found)
    return;
d526 4
a529 2
  if (s->filename != NULL
      && strcmp (s->filename, global_needed->name) == 0)
d531 1
a531 3
      global_found = true;
      return;
    }
d533 3
a535 3
  if (s->the_bfd != NULL)
    {
      const char *soname;
d537 4
a540 3
      soname = bfd_elf_get_dt_soname (s->the_bfd);
      if (soname != NULL
	  && strcmp (soname, global_needed->name) == 0)
d542 3
a544 2
	  global_found = true;
	  return;
d546 10
a556 6
	  
  if (s->search_dirs_flag
      && s->filename != NULL
      && strchr (global_needed->name, '/') == NULL)
    {
      const char *f;
d558 1
a558 8
      f = strrchr (s->filename, '/');
      if (f != NULL
	  && strcmp (f + 1, global_needed->name) == 0)
	{
	  global_found = true;
	  return;
	}
    }
d561 98
a658 2
/* See if an input file matches a DT_NEEDED entry by running stat on
   the file.  */
d661 1
a661 1
gld${EMULATION_NAME}_stat_needed (s)
a663 5
  struct stat st;
  const char *suffix;
  const char *soname;
  const char *f;

a665 2
  if (s->the_bfd == NULL)
    return;
d667 1
a667 1
  if (bfd_stat (s->the_bfd, &st) != 0)
d669 18
a686 2
      einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
      return;
d689 1
a689 2
  if (st.st_dev == global_stat.st_dev
      && st.st_ino == global_stat.st_ino)
d691 9
a699 2
      global_found = true;
      return;
d701 1
d703 11
a713 8
  /* We issue a warning if it looks like we are including two
     different versions of the same shared library.  For example,
     there may be a problem if -lc picks up libc.so.6 but some other
     shared library has a DT_NEEDED entry of libc.so.5.  This is a
     hueristic test, and it will only work if the name looks like
     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.
     If we really want to issue warnings about mixing version numbers
     of shared libraries, we need to find a better way.  */
d715 2
a716 1
  if (strchr (global_needed->name, '/') != NULL)
a717 4
  suffix = strstr (global_needed->name, ".so.");
  if (suffix == NULL)
    return;
  suffix += sizeof ".so." - 1;
d719 157
a875 3
  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = s->filename;
d877 2
a878 5
  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;
d880 3
a882 3
  if (strncmp (f, global_needed->name, suffix - global_needed->name) == 0)
    einfo ("%P: warning: %s, needed by %B, may conflict with %s\n",
	   global_needed->name, global_needed->by, f);
d885 2
a886 5
/* On Linux, it's possible to have different versions of the same
   shared library linked against different versions of libc.  The
   dynamic linker somehow tags which libc version to use in
   /etc/ld.so.cache, and, based on the libc that it sees in the
   executable, chooses which version of the shared library to use.
d888 1
a888 5
   We try to do a similar check here by checking whether this shared
   library needs any other shared libraries which may conflict with
   libraries we have already included in the link.  If it does, we
   skip it, and try to find another shared library farther on down the
   link path.
d890 1
a890 4
   This is called via lang_for_each_input_file.
   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object
   which we ar checking.  This sets GLOBAL_VERCHECK_FAILED if we find
   a conflicting version.  */
d893 2
a894 2
gld${EMULATION_NAME}_vercheck (s)
     lang_input_statement_type *s;
d896 35
a930 2
  const char *soname, *f;
  struct bfd_link_needed_list *l;
d932 5
a936 5
  if (global_vercheck_failed)
    return;
  if (s->the_bfd == NULL
      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)
    return;
d938 3
a940 3
  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = bfd_get_filename (s->the_bfd);
d942 4
a945 5
  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;
a946 3
  for (l = global_vercheck_needed; l != NULL; l = l->next)
    {
      const char *suffix;
d948 4
a951 5
      if (strcmp (f, l->name) == 0)
	{
	  /* Probably can't happen, but it's an easy check.  */
	  continue;
	}
d953 7
a959 2
      if (strchr (l->name, '/') != NULL)
	continue;
d961 1
a961 3
      suffix = strstr (l->name, ".so.");
      if (suffix == NULL)
	continue;
d963 2
a964 14
      suffix += sizeof ".so." - 1;

      if (strncmp (f, l->name, suffix - l->name) == 0)
	{
	  /* Here we know that S is a dynamic object FOO.SO.VER1, and
             the object we are considering needs a dynamic object
             FOO.SO.VER2, and VER1 and VER2 are different.  This
             appears to be a version mismatch, so we tell the caller
             to try a different version of this library.  */
	  global_vercheck_failed = true;
	  return;
	}
    }
}
d1040 9
a1048 4
/* This is called by the before_allocation routine via
   lang_for_each_statement.  It locates any assignment statements, and
   tells the ELF backend about them, in case they are assignments to
   symbols which are referred to by dynamic objects.  */
d1050 5
a1054 3
static void
gld${EMULATION_NAME}_find_statement_assignment (s)
     lang_statement_union_type *s;
d1056 26
a1081 3
  if (s->header.type == lang_assignment_statement_enum)
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}
d1083 1
a1083 1
/* Look through an expression for an assignment statement.  */
d1085 11
a1095 5
static void
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
{
  struct bfd_link_hash_entry *h;
d1097 1
a1097 1
  switch (exp->type.node_class)
d1099 3
a1101 5
    case etree_provide:
      h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,
				false, false, false);
      if (h == NULL)
	break;
d1103 1
a1103 7
      /* We call record_link_assignment even if the symbol is defined.
	 This is because if it is defined by a dynamic object, we
	 actually want to use the value defined by the linker script,
	 not the value from the dynamic object (because we are setting
	 symbols like etext).  If the symbol is defined by a regular
	 object, then, as it happens, calling record_link_assignment
	 will do no harm.  */
d1105 9
a1113 12
      /* Fall through.  */
    case etree_assign:
      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (! (bfd_elf${ELFSIZE}_record_link_assignment
		 (output_bfd, &link_info, exp->assign.dst,
		  exp->type.node_class == etree_provide ? true : false)))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;
d1115 7
a1121 4
    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;
d1123 2
a1124 5
    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;
d1126 3
a1128 3
    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;
d1130 1
a1130 3
    default:
      break;
    }
d1133 4
d1160 5
d1185 2
d1198 4
a1201 2
  /* Look through the script to see where to place this section.  */ 
  os = lang_output_section_find (secname);
d1203 9
a1211 7
  if (os != NULL
      && os->bfd_section != NULL
      && ((s->flags ^ os->bfd_section->flags) & (SEC_LOAD | SEC_ALLOC)) == 0)
    {
      /* We have already placed a section with this name.  */
      wild_doit (&os->children, s, os, file);
      return true;
d1243 1
a1243 1
	   && strncmp (secname, ".note", 4) == 0
d1249 3
d1270 1
a1270 1
     loadable or allocateable characteristics.  */
d1274 5
a1278 16
      unsigned int len;
      char *newname;
      unsigned int i;

      len = strlen (outsecname);
      newname = xmalloc (len + 5);
      strcpy (newname, outsecname);
      i = 0;
      do
	{
	  sprintf (newname + len, "%d", i);
	  ++i;
	}
      while (bfd_get_section_by_name (output_bfd, newname) != NULL);

      outsecname = newname;
d1419 6
d1426 1
a1426 1
gld${EMULATION_NAME}_get_script(isfile)
d1438 1
a1438 1
{			     
d1465 1
a1465 1
{			     
d1481 136
d1618 7
d1626 1
d1629 1
a1629 1
if test -n "$PARSE_AND_LIST_ARGS" ; then
a1630 2
static int  gld_${EMULATION_NAME}_parse_args PARAMS ((int, char **));
static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE * file));
d1632 31
a1662 1
 $PARSE_AND_LIST_ARGS
d1664 1
a1664 1
else
d1667 1
a1667 2
#define gld_${EMULATION_NAME}_parse_args   NULL
#define gld_${EMULATION_NAME}_list_options NULL
d1670 17
d1691 1
a1691 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
d1693 10
a1702 10
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  gld${EMULATION_NAME}_after_open,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  gld${EMULATION_NAME}_before_allocation,
  gld${EMULATION_NAME}_get_script,
d1705 10
a1714 10
  NULL, 	/* finish */
  NULL, 	/* create output section statements */
  gld${EMULATION_NAME}_open_dynamic_archive,
  gld${EMULATION_NAME}_place_orphan,
  NULL,		/* set_symbols */
  gld_${EMULATION_NAME}_parse_args,
  NULL,		/* unrecognized_file */
  gld_${EMULATION_NAME}_list_options,
  NULL,		/* recognized_file */
  NULL		/* find_potential_libraries */
@


1.9
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d470 2
a471 1
	 LIB_SEARCH_DIRS.  We do not search using the -L arguments.
d478 1
a478 1
	  const char *lib_path;
d488 2
a489 1
	  if (command_line.rpath_link == NULL
d492 1
a492 1
	      lib_path = (const char *) getenv ("LD_RUN_PATH");
d495 19
d516 1
d522 1
a522 1
	  lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
@


1.8
log
@undo change which breaks the alpha.  I did not see this change and approve it during tree lock. Grrr
@
text
@d10 1
a10 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 1999
d66 1
a68 2
static void gld${EMULATION_NAME}_place_section
  PARAMS ((lang_statement_union_type *));
d540 1
a540 1
      einfo ("%P: warning: %s, needed by %B, not found (try using --rpath)\n",
d1026 23
d1052 5
a1056 8
static asection *hold_section;
static lang_output_section_statement_type *hold_use;
static lang_output_section_statement_type *hold_text;
static lang_output_section_statement_type *hold_rodata;
static lang_output_section_statement_type *hold_data;
static lang_output_section_statement_type *hold_bss;
static lang_output_section_statement_type *hold_rel;
static lang_output_section_statement_type *hold_interp;
a1057 1
/*ARGSUSED*/
d1063 7
a1069 2
  lang_output_section_statement_type *place;
  asection *snew, **pps;
d1073 1
a1073 1
  const char *secname, *ps;
d1075 1
d1078 1
a1078 2
  if ((s->flags & SEC_ALLOC) == 0)
    return false;
d1080 2
a1081 4
  /* Look through the script to see where to place this section.  */
  hold_section = s;
  hold_use = NULL;
  lang_for_each_statement (gld${EMULATION_NAME}_place_section);
d1083 3
a1085 1
  if (hold_use != NULL)
d1088 1
a1088 1
      wild_doit (&hold_use->children, s, hold_use, file);
d1092 2
a1093 1
  secname = bfd_get_section_name (s->owner, s);
d1100 1
a1100 1
      && hold_text != NULL)
d1102 1
a1102 1
      wild_doit (&hold_text->children, s, hold_text, file);
d1111 3
a1113 1
  place = NULL;
d1116 4
d1121 3
a1123 3
      && strncmp (secname, ".note", 4) == 0
      && hold_interp != NULL)
    place = hold_interp;
d1125 2
a1126 2
	   && hold_bss != NULL)
    place = hold_bss;
d1128 2
a1129 2
	   && hold_data != NULL)
    place = hold_data;
d1131 11
a1141 11
	   && hold_rel != NULL)
    place = hold_rel;
  else if ((s->flags & SEC_CODE) == 0
	   && (s->flags & SEC_READONLY) != 0
	   && hold_rodata != NULL)
    place = hold_rodata;
  else if ((s->flags & SEC_READONLY) != 0
	   && hold_text != NULL)
    place = hold_text;
  if (place == NULL)
    return false;
d1167 8
a1174 7
  /* Create the section in the output file, and put it in the right
     place.  This shuffling is to make the output file look neater.  */
  snew = bfd_make_section (output_bfd, outsecname);
  if (snew == NULL)
      einfo ("%P%F: output format %s cannot represent section called %s\n",
	     output_bfd->xvec->name, outsecname);
  if (place->bfd_section != NULL)
d1176 2
a1177 5
      for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	;
      *pps = snew->next;
      snew->next = place->bfd_section->next;
      place->bfd_section->next = snew;
d1180 1
a1180 11
  /* Start building a list of statements for this section.  */
  old = stat_ptr;
  stat_ptr = &add;
  lang_list_init (stat_ptr);

  /* If the name of the section is representable in C, then create
     symbols to mark the start and the end of the section.  */
  for (ps = outsecname; *ps != '\0'; ps++)
    if (! isalnum ((unsigned char) *ps) && *ps != '_')
      break;
  if (*ps == '\0' && config.build_constructors)
d1182 9
a1190 1
      char *symname;
d1192 6
a1197 6
      symname = (char *) xmalloc (ps - outsecname + sizeof "__start_");
      sprintf (symname, "__start_%s", outsecname);
      lang_add_assignment (exp_assop ('=', symname,
				      exp_unop (ALIGN_K,
						exp_intop ((bfd_vma) 1
							   << s->alignment_power))));
d1200 3
a1202 1
  if (! link_info.relocateable)
a1203 2
  else
    address = exp_intop ((bfd_vma) 0);
d1205 5
a1209 5
  lang_enter_output_section_statement (outsecname, address, 0,
				       (bfd_vma) 0,
				       (etree_type *) NULL,
				       (etree_type *) NULL,
				       (etree_type *) NULL);
a1210 1
  os = lang_output_section_statement_lookup (outsecname);
d1214 2
a1215 3
    ((bfd_vma) 0, "*default*", (struct lang_output_section_phdr_list *) NULL,
     "*default*");
  stat_ptr = &add;
d1217 1
a1217 1
  if (*ps == '\0' && config.build_constructors)
d1221 5
d1232 6
a1237 3
  /* Now stick the new statement list right after PLACE.  */
  *add.tail = place->header.next;
  place->header.next = add.head;
d1239 23
a1261 1
  stat_ptr = old;
d1263 10
a1272 2
  return true;
}
d1274 17
a1290 5
static void
gld${EMULATION_NAME}_place_section (s)
     lang_statement_union_type *s;
{
  lang_output_section_statement_type *os;
d1292 4
a1295 2
  if (s->header.type != lang_output_section_statement_enum)
    return;
d1297 4
a1300 1
  os = &s->output_section_statement;
d1302 1
a1302 21
  if (strcmp (os->name, hold_section->name) == 0
      && os->bfd_section != NULL
      && ((hold_section->flags & (SEC_LOAD | SEC_ALLOC))
	  == (os->bfd_section->flags & (SEC_LOAD | SEC_ALLOC))))
    hold_use = os;

  if (strcmp (os->name, ".text") == 0)
    hold_text = os;
  else if (strcmp (os->name, ".rodata") == 0)
    hold_rodata = os;
  else if (strcmp (os->name, ".data") == 0)
    hold_data = os;
  else if (strcmp (os->name, ".bss") == 0)
    hold_bss = os;
  else if (hold_rel == NULL
	   && os->bfd_section != NULL
	   && (os->bfd_section->flags & SEC_ALLOC) != 0
	   && strncmp (os->name, ".rel", 4) == 0)
    hold_rel = os;
  else if (strcmp (os->name, ".interp") == 0)
    hold_interp = os;
@


1.7
log
@date: 2001/04/18 18:33:13;  author: drahn;  state: Exp;  lines: +41 -0
Use the /var/run/ld.so.hints for looking up transitive dependancies on shared
libraries in ld, this is done in linux with ld.so.conf, but the string
is stored in ld.so.hints for openbsd. Fixes some "-rpath" compilation
errors. as with the linux case, this is only for the native ld.
Ok'd by espie@@.
@
text
@a327 8
  case ${target} in
    *-*-openbsd*)
cat >>e${EMULATION_NAME}.c <<EOF
#include <fcntl.h>
#include <link.h>
EOF
    ;;
  esac
a347 29
EOF
  case ${target} in
    *-*-openbsd*)
      cat >>e${EMULATION_NAME}.c <<EOF
    struct hints_header hdr;
    off_t diroff;
    int fd;
    char *buf;

    f = fopen(_PATH_LD_HINTS, FOPEN_RT);
    if (f != NULL) 
    {
      if ( fread (&hdr, sizeof (struct hints_header), 1, f) == 1) {
	if (!HH_BADMAG(hdr)) {
	  diroff = (hdr.hh_strtab + hdr.hh_dirlist);
	  fseek(f, diroff, SEEK_SET);
	} else {
	  fclose(f);
	  f = NULL;
	}
      } else  {
	fclose(f);
	f = NULL;
      }
    }
EOF
  ;;
  *)
cat >>e${EMULATION_NAME}.c <<EOF
a349 4
EOF
    ;;
    esac
cat >>e${EMULATION_NAME}.c <<EOF
@


1.6
log
@Add support for major/minor version numbers.
Testing by Dale.

Ok'd deraadt@@
@
text
@d328 8
d356 29
d387 4
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d72 149
d247 9
d269 4
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d10 2
a11 1
   Copyright (C) 1991, 93, 94, 95, 1996 Free Software Foundation, Inc.
d58 4
a61 2
  PARAMS ((const char *, const char *));
static boolean gld${EMULATION_NAME}_try_needed PARAMS ((const char *));
d77 1
d81 2
a82 1
   dynamic libraries have an extension of .so.  */
d98 3
d104 3
d111 8
d146 10
a155 4
      needed_name = (char *) xmalloc (strlen (filename)
				      + strlen (arch)
				      + sizeof "lib.so");
      sprintf (needed_name, "lib%s%s.so", filename, arch);
d164 2
a165 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d172 2
a173 1
static boolean gld${EMULATION_NAME}_check_ld_so_conf PARAMS ((const char *));
d176 1
a176 1
gld${EMULATION_NAME}_check_ld_so_conf (name)
d178 1
d246 1
a246 1
  return gld${EMULATION_NAME}_search_needed (ld_so_conf, name);
d250 2
a251 1
  fi
d256 1
a256 1
   between after_open and check_needed and stat_needed.  */
d261 2
d288 1
a288 3
      const char *lib_path;
      size_t len;
      search_dirs_type *search;
d309 6
a314 8
	 LIB_SEARCH_DIRS.  We do not search using the -L arguments.  */
      if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
					      l->name))
	continue;
      if (gld${EMULATION_NAME}_search_needed (command_line.rpath, l->name))
	continue;
      if (command_line.rpath_link == NULL
	  && command_line.rpath == NULL)
d316 18
a333 4
	  lib_path = (const char *) getenv ("LD_RUN_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name))
	    continue;
	}
d336 2
a337 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d339 3
a341 3
      lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name))
	continue;
d343 2
a344 1
  fi
d347 4
a350 4
      len = strlen (l->name);
      for (search = search_head; search != NULL; search = search->next)
	{
	  char *filename;
d352 9
a360 5
	  if (search->cmdline)
	    continue;
	  filename = (char *) xmalloc (strlen (search->name) + len + 2);
	  sprintf (filename, "%s/%s", search->name, l->name);
	  if (gld${EMULATION_NAME}_try_needed (filename))
a361 4
	  free (filename);
	}
      if (search != NULL)
	continue;
d364 2
a365 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d367 2
a368 2
      if (gld${EMULATION_NAME}_check_ld_so_conf (l->name))
	continue;
d370 2
a371 1
  fi
d374 4
d387 1
a387 1
gld${EMULATION_NAME}_search_needed (path, name)
d390 1
d417 1
a417 1
      if (gld${EMULATION_NAME}_try_needed (filename))
d431 2
a432 1
   named by a DT_NEEDED entry.  */
d435 1
a435 1
gld${EMULATION_NAME}_try_needed (name)
d437 1
d455 56
d649 72
d740 5
a744 6
  if (! bfd_elf${ELFSIZE}_size_dynamic_sections (output_bfd,
						 command_line.soname,
						 rpath,
						 command_line.export_dynamic,
						 &link_info,
						 &sinterp))
a792 31

#if defined (TARGET_IS_elf32bmip) || defined (TARGET_IS_elf32lmip)
  /* For MIPS ELF the .reginfo section requires special handling.
     Each input section is 24 bytes, and the final output section must
     also be 24 bytes.  We handle this by clobbering all but the first
     input section size to 0.  The .reginfo section is handled
     specially by the backend code anyhow.  */
  {
    boolean found = false;
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	asection *s;

	if (is->just_syms_flag)
	  continue;

	s = bfd_get_section_by_name (is->the_bfd, ".reginfo");
	if (s == NULL)
	  continue;

	if (! found)
	  {
	    found = true;
	    continue;
	  }

	s->_raw_size = 0;
	s->_cooked_size = 0;
      }
  }
#endif
d875 1
d889 1
d921 4
a924 1
     section name and section flags.  */
d926 8
a933 2
  if ((s->flags & SEC_HAS_CONTENTS) == 0
      && hold_bss != NULL)
d951 24
d977 1
a977 1
  snew = bfd_make_section (output_bfd, secname);
d980 1
a980 1
	     output_bfd->xvec->name, secname);
d997 2
a998 2
  for (ps = secname; *ps != '\0'; ps++)
    if (! isalnum (*ps) && *ps != '_')
d1004 2
a1005 2
      symname = (char *) xmalloc (ps - secname + sizeof "__start_");
      sprintf (symname, "__start_%s", secname);
d1017 1
a1017 1
  lang_enter_output_section_statement (secname, address, 0,
d1023 1
a1023 1
  os = lang_output_section_statement_lookup (secname);
d1027 2
a1028 1
    ((bfd_vma) 0, "*default*", (struct lang_output_section_phdr_list *) NULL);
d1035 2
a1036 2
      symname = (char *) xmalloc (ps - secname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", secname);
d1061 4
a1064 1
  if (strcmp (os->name, hold_section->name) == 0)
d1077 1
d1080 2
d1094 1
a1094 5
sc='s/["\\]/\\&/g
s/$/\\n\\/
1s/^/"/
$s/$/n"/
'
d1101 1
a1101 12
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xu`;
  else if (link_info.relocateable == true)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xr`;
  else if (!config.text_read_only)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xbn`;
  else if (!config.magic_demand_paged)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xn`;
  else if (link_info.shared)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xs`;
  else
    return `sed "$sc" ldscripts/${EMULATION_NAME}.x`;
}
d1103 16
d1144 16
d1176 2
a1177 2
  NULL,
  NULL,
d1179 7
a1185 1
  gld${EMULATION_NAME}_place_orphan
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d330 1
a330 1
      einfo ("%P: warning: %s, needed by %B, not found\n",
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d3 3
d9 1
a9 1
/* 32 bit ELF emulation code for ${EMULATION_NAME}
d560 6
a565 6
  if (! bfd_elf32_size_dynamic_sections (output_bfd,
					 command_line.soname,
					 rpath,
					 command_line.export_dynamic,
					 &link_info,
					 &sinterp))
d688 1
a688 1
	  if (! (bfd_elf32_record_link_assignment
d723 1
d782 4
d824 3
a826 1
				      exp_nameop (NAME, ".")));
d843 2
a844 1
  lang_leave_output_section_statement ((bfd_vma) 0, "*default*");
d882 2
d889 1
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
   Copyright (C) 1991, 1993, 1994, 1995 Free Software Foundation, Inc.
d69 1
a69 1
  ldfile_output_architecture = bfd_arch_${ARCH};
d134 89
d291 2
a292 1
if [ "x${host_alias}" = "x${target_alias}" ] ; then
d298 1
d316 10
d438 3
d443 21
a463 4
    global_found = true;
  else if (s->search_dirs_flag
	   && s->filename != NULL
	   && strchr (global_needed->name, '/') == NULL)
d470 4
a473 1
	global_found = true;
d484 5
d491 4
a494 1
  if (s->the_bfd != NULL)
d496 3
a498 1
      struct stat st;
d500 5
a504 8
      if (bfd_stat (s->the_bfd, &st) != 0)
	einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
      else
	{
	  if (st.st_dev == global_stat.st_dev
	      && st.st_ino == global_stat.st_ino)
	    global_found = true;
	}
d506 30
d700 1
a700 1
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d7 1
a7 1
   Copyright (C) 1991, 93, 94, 95, 1996 Free Software Foundation, Inc.
d69 1
a69 1
  ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;
a133 89
EOF
if [ "x${host}" = "x${target}" ] ; then
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
cat >>e${EMULATION_NAME}.c <<EOF

/* For a native linker, check the file /etc/ld.so.conf for directories
   in which we may find shared libraries.  /etc/ld.so.conf is really
   only meaningful on Linux, but we check it on other systems anyhow.  */

static boolean gld${EMULATION_NAME}_check_ld_so_conf PARAMS ((const char *));

static boolean
gld${EMULATION_NAME}_check_ld_so_conf (name)
     const char *name;
{
  static boolean initialized;
  static char *ld_so_conf;

  if (! initialized)
    {
      FILE *f;

      f = fopen ("/etc/ld.so.conf", FOPEN_RT);
      if (f != NULL)
	{
	  char *b;
	  size_t len, alloc;
	  int c;

	  len = 0;
	  alloc = 100;
	  b = (char *) xmalloc (alloc);

	  while ((c = getc (f)) != EOF)
	    {
	      if (len + 1 >= alloc)
		{
		  alloc *= 2;
		  b = (char *) xrealloc (b, alloc);
		}
	      if (c != ':'
		  && c != ' '
		  && c != '\t'
		  && c != '\n'
		  && c != ',')
		{
		  b[len] = c;
		  ++len;
		}
	      else
		{
		  if (len > 0 && b[len - 1] != ':')
		    {
		      b[len] = ':';
		      ++len;
		    }
		}
	    }

	  if (len > 0 && b[len - 1] == ':')
	    --len;

	  if (len > 0)
	    b[len] = '\0';
	  else
	    {
	      free (b);
	      b = NULL;
	    }

	  fclose (f);

	  ld_so_conf = b;
	}

      initialized = true;
    }

  if (ld_so_conf == NULL)
    return false;

  return gld${EMULATION_NAME}_search_needed (ld_so_conf, name);
}

EOF
  fi
fi
cat >>e${EMULATION_NAME}.c <<EOF

d202 1
a202 2
if [ "x${host}" = "x${target}" ] ; then
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
a207 1
  fi
a224 10
EOF
if [ "x${host}" = "x${target}" ] ; then
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
      if (gld${EMULATION_NAME}_check_ld_so_conf (l->name))
	continue;
EOF
  fi
fi
cat >>e${EMULATION_NAME}.c <<EOF
a336 3
  if (global_found)
    return;

d339 4
a342 21
    {
      global_found = true;
      return;
    }

  if (s->the_bfd != NULL)
    {
      const char *soname;

      soname = bfd_elf_get_dt_soname (s->the_bfd);
      if (soname != NULL
	  && strcmp (soname, global_needed->name) == 0)
	{
	  global_found = true;
	  return;
	}
    }
	  
  if (s->search_dirs_flag
      && s->filename != NULL
      && strchr (global_needed->name, '/') == NULL)
d349 1
a349 4
	{
	  global_found = true;
	  return;
	}
a359 5
  struct stat st;
  const char *suffix;
  const char *soname;
  const char *f;

d362 1
a362 4
  if (s->the_bfd == NULL)
    return;

  if (bfd_stat (s->the_bfd, &st) != 0)
d364 1
a364 3
      einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
      return;
    }
d366 8
a373 5
  if (st.st_dev == global_stat.st_dev
      && st.st_ino == global_stat.st_ino)
    {
      global_found = true;
      return;
a374 30

  /* We issue a warning if it looks like we are including two
     different versions of the same shared library.  For example,
     there may be a problem if -lc picks up libc.so.6 but some other
     shared library has a DT_NEEDED entry of libc.so.5.  This is a
     hueristic test, and it will only work if the name looks like
     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.
     If we really want to issue warnings about mixing version numbers
     of shared libraries, we need to find a better way.  */

  if (strchr (global_needed->name, '/') != NULL)
    return;
  suffix = strstr (global_needed->name, ".so.");
  if (suffix == NULL)
    return;
  suffix += sizeof ".so." - 1;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = s->filename;

  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;

  if (strncmp (f, global_needed->name, suffix - global_needed->name) == 0)
    einfo ("%P: warning: %s, needed by %B, may conflict with %s\n",
	   global_needed->name, global_needed->by, f);
d539 1
a539 1
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a2 3
# This file is now misnamed, because it supports both 32 bit and 64 bit
# ELF emulations.
test -z "${ELFSIZE}" && ELFSIZE=32
d6 1
a6 1
/* ${ELFSIZE} bit ELF emulation code for ${EMULATION_NAME}
d557 6
a562 6
  if (! bfd_elf${ELFSIZE}_size_dynamic_sections (output_bfd,
						 command_line.soname,
						 rpath,
						 command_line.export_dynamic,
						 &link_info,
						 &sinterp))
d685 1
a685 1
	  if (! (bfd_elf${ELFSIZE}_record_link_assignment
a719 1
static lang_output_section_statement_type *hold_rodata;
a777 4
  else if ((s->flags & SEC_CODE) == 0
	   && (s->flags & SEC_READONLY) != 0
	   && hold_rodata != NULL)
    place = hold_rodata;
d816 1
a816 3
				      exp_unop (ALIGN_K,
						exp_intop ((bfd_vma) 1
							   << s->alignment_power))));
d833 1
a833 2
  lang_leave_output_section_statement
    ((bfd_vma) 0, "*default*", (struct lang_output_section_phdr_list *) NULL);
a870 2
  else if (strcmp (os->name, ".rodata") == 0)
    hold_rodata = os;
a875 1
	   && os->bfd_section != NULL
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d330 1
a330 1
      einfo ("%P: warning: %s, needed by %B, not found (try using --rpath)\n",
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d10 1
a10 1
   Copyright (C) 1991, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d560 6
a565 5
  if (! (bfd_elf${ELFSIZE}_size_dynamic_sections
         (output_bfd, command_line.soname, rpath,
	  command_line.export_dynamic, command_line.filter_shlib,
	  (const char * const *) command_line.auxiliary_filters,
	  &link_info, &sinterp, lang_elf_version_info)))
a726 1
static lang_output_section_statement_type *hold_interp;
a739 1
  const char *outsecname;
d771 1
a771 4
     section name and section flags.  We put loadable .note sections
     right after the .interp section, so that the PT_NOTE segment is
     stored right after the program headers where the OS can read it
     in the first page.  */
d773 2
a774 6
  if ((s->flags & SEC_LOAD) != 0
      && strncmp (secname, ".note", 4) == 0
      && hold_interp != NULL)
    place = hold_interp;
  else if ((s->flags & SEC_HAS_CONTENTS) == 0
	   && hold_bss != NULL)
a791 24
  /* Choose a unique name for the section.  This will be needed if the
     same section name appears in the input file with different
     loadable or allocateable characteristics.  */
  outsecname = secname;
  if (bfd_get_section_by_name (output_bfd, outsecname) != NULL)
    {
      unsigned int len;
      char *newname;
      unsigned int i;

      len = strlen (outsecname);
      newname = xmalloc (len + 5);
      strcpy (newname, outsecname);
      i = 0;
      do
	{
	  sprintf (newname + len, "%d", i);
	  ++i;
	}
      while (bfd_get_section_by_name (output_bfd, newname) != NULL);

      outsecname = newname;
    }

d794 1
a794 1
  snew = bfd_make_section (output_bfd, outsecname);
d797 1
a797 1
	     output_bfd->xvec->name, outsecname);
d814 1
a814 1
  for (ps = outsecname; *ps != '\0'; ps++)
d821 2
a822 2
      symname = (char *) xmalloc (ps - outsecname + sizeof "__start_");
      sprintf (symname, "__start_%s", outsecname);
d834 1
a834 1
  lang_enter_output_section_statement (outsecname, address, 0,
d840 1
a840 1
  os = lang_output_section_statement_lookup (outsecname);
d851 2
a852 2
      symname = (char *) xmalloc (ps - outsecname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", outsecname);
d877 1
a877 3
  if (strcmp (os->name, hold_section->name) == 0
      && ((hold_section->flags & (SEC_LOAD | SEC_ALLOC))
	  == (os->bfd_section->flags & (SEC_LOAD | SEC_ALLOC))))
a889 1
	   && (os->bfd_section->flags & SEC_ALLOC) != 0
a891 2
  else if (strcmp (os->name, ".interp") == 0)
    hold_interp = os;
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d10 1
a10 2
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d57 2
a58 4
  PARAMS ((const char *, const char *, int));
static boolean gld${EMULATION_NAME}_try_needed PARAMS ((const char *, int));
static void gld${EMULATION_NAME}_vercheck
  PARAMS ((lang_input_statement_type *));
a73 1
  config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo true ; else echo false ; fi`;
d77 1
a77 2
   dynamic libraries have an extension of .so (or .sl on oddball systems
   like hpux).  */
a92 3
  /* This allocates a few bytes too many when EXTRA_SHLIB_EXTENSION
     is defined, but it does not seem worth the headache to optimize
     away those two bytes of space.  */
a95 3
#ifdef EXTRA_SHLIB_EXTENSION
			     + strlen (EXTRA_SHLIB_EXTENSION)
#endif
a99 8
#ifdef EXTRA_SHLIB_EXTENSION
  /* Try the .so extension first.  If that fails build a new filename
     using EXTRA_SHLIB_EXTENSION.  */
  if (! ldfile_try_open_bfd (string, entry))
    sprintf (string, "%s/lib%s%s%s", search->name,
	     filename, arch, EXTRA_SHLIB_EXTENSION);
#endif

d127 4
a130 10

      /* Rather than duplicating the logic above.  Just use the
	 filename we recorded earlier.

	 First strip off everything before the last '/'.  */
      filename = strrchr (entry->filename, '/');
      filename++;

      needed_name = (char *) xmalloc (strlen (filename) + 1);
      strcpy (needed_name, filename);
d139 1
a139 2
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
d146 1
a146 2
static boolean gld${EMULATION_NAME}_check_ld_so_conf
  PARAMS ((const char *, int));
d149 1
a149 1
gld${EMULATION_NAME}_check_ld_so_conf (name, force)
a150 1
     int force;
d218 1
a218 1
  return gld${EMULATION_NAME}_search_needed (ld_so_conf, name, force);
d222 1
a222 2
  ;;
  esac
d227 1
a227 1
   between after_open and check_needed and stat_needed and vercheck.  */
a231 2
static struct bfd_link_needed_list *global_vercheck_needed;
static boolean global_vercheck_failed;
d257 3
a259 1
      int force;
d280 8
a287 6
	 LIB_SEARCH_DIRS.  We do not search using the -L arguments.

	 We search twice.  The first time, we skip objects which may
	 introduce version mismatches.  The second time, we force
	 their use.  See gld${EMULATION_NAME}_vercheck comment.  */
      for (force = 0; force < 2; force++)
d289 4
a292 18
	  const char *lib_path;
	  size_t len;
	  search_dirs_type *search;

	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
						  l->name, force))
	    break;
	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath,
						  l->name, force))
	    break;
	  if (command_line.rpath_link == NULL
	      && command_line.rpath == NULL)
	    {
	      lib_path = (const char *) getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
						      force))
		break;
	    }
d295 1
a295 2
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
d297 3
a299 3
	  lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
	    break;
d301 1
a301 2
  ;;
  esac
d304 4
a307 4
	  len = strlen (l->name);
	  for (search = search_head; search != NULL; search = search->next)
	    {
	      char *filename;
d309 5
a313 9
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, "%s/%s", search->name, l->name);
	      if (gld${EMULATION_NAME}_try_needed (filename, force))
		break;
	      free (filename);
	    }
	  if (search != NULL)
d315 4
d321 1
a321 2
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
d323 2
a324 2
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
	    break;
d326 1
a326 2
  ;;
  esac
a328 4
	}

      if (force < 2)
	continue;
d338 1
a338 1
gld${EMULATION_NAME}_search_needed (path, name, force)
a340 1
     int force;
d367 1
a367 1
      if (gld${EMULATION_NAME}_try_needed (filename, force))
d381 1
a381 2
   named by a DT_NEEDED entry.  The FORCE parameter indicates whether
   to skip the check for a conflicting version.  */
d384 1
a384 1
gld${EMULATION_NAME}_try_needed (name, force)
a385 1
     int force;
a402 56
  /* Check whether this object would include any conflicting library
     versions.  If FORCE is set, then we skip this check; we use this
     the second time around, if we couldn't find any compatible
     instance of the shared library.  */

  if (! force)
    {
      struct bfd_link_needed_list *needed;

      if (! bfd_elf_get_bfd_needed_list (abfd, &needed))
	einfo ("%F%P:%B: bfd_elf_get_bfd_needed_list failed: %E\n", abfd);

      if (needed != NULL)
	{
	  global_vercheck_needed = needed;
	  global_vercheck_failed = false;
	  lang_for_each_input_file (gld${EMULATION_NAME}_vercheck);
	  if (global_vercheck_failed)
	    {
	      (void) bfd_close (abfd);
	      /* Return false to force the caller to move on to try
                 another file on the search path.  */
	      return false;
	    }

	  /* But wait!  It gets much worse.  On Linux, if a shared
             library does not use libc at all, we are supposed to skip
             it the first time around in case we encounter a shared
             library later on with the same name which does use the
             version of libc that we want.  This is much too horrible
             to use on any system other than Linux.  */

EOF
case ${target} in
  *-*-linux-gnu*)
    cat >>e${EMULATION_NAME}.c <<EOF
	  {
	    struct bfd_link_needed_list *l;

	    for (l = needed; l != NULL; l = l->next)
	      if (strncmp (l->name, "libc.so", 7) == 0)
		break;
	    if (l == NULL)
	      {
		(void) bfd_close (abfd);
		return false;
	      }
	  }

EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
	}
    }

a540 72
/* On Linux, it's possible to have different versions of the same
   shared library linked against different versions of libc.  The
   dynamic linker somehow tags which libc version to use in
   /etc/ld.so.cache, and, based on the libc that it sees in the
   executable, chooses which version of the shared library to use.

   We try to do a similar check here by checking whether this shared
   library needs any other shared libraries which may conflict with
   libraries we have already included in the link.  If it does, we
   skip it, and try to find another shared library farther on down the
   link path.

   This is called via lang_for_each_input_file.
   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object
   which we ar checking.  This sets GLOBAL_VERCHECK_FAILED if we find
   a conflicting version.  */

static void
gld${EMULATION_NAME}_vercheck (s)
     lang_input_statement_type *s;
{
  const char *soname, *f;
  struct bfd_link_needed_list *l;

  if (global_vercheck_failed)
    return;
  if (s->the_bfd == NULL
      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)
    return;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = bfd_get_filename (s->the_bfd);

  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;

  for (l = global_vercheck_needed; l != NULL; l = l->next)
    {
      const char *suffix;

      if (strcmp (f, l->name) == 0)
	{
	  /* Probably can't happen, but it's an easy check.  */
	  continue;
	}

      if (strchr (l->name, '/') != NULL)
	continue;

      suffix = strstr (l->name, ".so.");
      if (suffix == NULL)
	continue;

      suffix += sizeof ".so." - 1;

      if (strncmp (f, l->name, suffix - l->name) == 0)
	{
	  /* Here we know that S is a dynamic object FOO.SO.VER1, and
             the object we are considering needs a dynamic object
             FOO.SO.VER2, and VER1 and VER2 are different.  This
             appears to be a version mismatch, so we tell the caller
             to try a different version of this library.  */
	  global_vercheck_failed = true;
	  return;
	}
    }
}

d613 31
d777 1
a777 3
  if (s->flags & SEC_EXCLUDE)
    return false;
  else if ((s->flags & SEC_LOAD) != 0
d847 1
a847 1
    if (! isalnum ((unsigned char) *ps) && *ps != '_')
d876 1
a876 2
    ((bfd_vma) 0, "*default*", (struct lang_output_section_phdr_list *) NULL,
     "*default*");
a909 1
      && os->bfd_section != NULL
d941 5
a945 1
sc="-f stringify.sed"
d952 12
a963 1
    return
a964 16
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c

if test -n "$GENERATE_SHLIB_SCRIPT" ; then
echo '  ; else if (link_info.shared) return'		   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs                     >> e${EMULATION_NAME}.c
fi

echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
a989 16
if test -n "$PARSE_AND_LIST_ARGS" ; then
cat >>e${EMULATION_NAME}.c <<EOF
static int  gld_${EMULATION_NAME}_parse_args PARAMS ((int, char **));
static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE * file));

 $PARSE_AND_LIST_ARGS
EOF
else

cat >>e${EMULATION_NAME}.c <<EOF
#define gld_${EMULATION_NAME}_parse_args   NULL
#define gld_${EMULATION_NAME}_list_options NULL
EOF

fi

d1006 2
a1007 2
  NULL, 	/* finish */
  NULL, 	/* create output section statements */
d1009 1
a1009 7
  gld${EMULATION_NAME}_place_orphan,
  NULL,		/* set_symbols */
  gld_${EMULATION_NAME}_parse_args,
  NULL,		/* unrecognized_file */
  gld_${EMULATION_NAME}_list_options,
  NULL,		/* recognized_file */
  NULL		/* find_potential_libraries */
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d10 1
a10 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 99, 2000
a65 1
static lang_output_section_statement_type *output_rel_find PARAMS ((void));
d68 2
d379 1
a379 1
      einfo ("%P: warning: %s, needed by %B, not found (try using -rpath or -rpath-link)\n",
a864 23
/* A variant of lang_output_section_find.  Used by place_orphan.  */

static lang_output_section_statement_type *
output_rel_find ()
{
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (strncmp (".rel", lookup->name, 4) == 0
	  && lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	{
	  return lookup;
	}
    }
  return (lang_output_section_statement_type *) NULL;
}

d868 8
a875 5
struct orphan_save {
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
};
d877 1
d883 2
a884 7
  static struct orphan_save hold_text;
  static struct orphan_save hold_rodata;
  static struct orphan_save hold_data;
  static struct orphan_save hold_bss;
  static struct orphan_save hold_rel;
  static struct orphan_save hold_interp;
  struct orphan_save *place;
d888 1
a888 1
  const char *secname;
a889 1
  const char *ps = NULL;
d892 2
a893 1
  secname = bfd_get_section_name (s->owner, s);
d895 4
a898 2
  /* Look through the script to see where to place this section.  */ 
  os = lang_output_section_find (secname);
d900 1
a900 3
  if (os != NULL
      && os->bfd_section != NULL
      && ((s->flags ^ os->bfd_section->flags) & (SEC_LOAD | SEC_ALLOC)) == 0)
d903 1
a903 1
      wild_doit (&os->children, s, os, file);
d907 1
a907 2
  if (hold_text.os == NULL)
    hold_text.os = lang_output_section_find (".text");
d914 1
a914 1
      && hold_text.os != NULL)
d916 1
a916 1
      wild_doit (&hold_text.os->children, s, hold_text.os, file);
d925 1
a925 3
#define HAVE_SECTION(hold, name) \
(hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)

a927 4

  place = NULL;
  if ((s->flags & SEC_ALLOC) == 0)
    ;
d929 3
a931 3
	   && strncmp (secname, ".note", 4) == 0
	   && HAVE_SECTION (hold_interp, ".interp"))
    place = &hold_interp;
d933 2
a934 2
	   && HAVE_SECTION (hold_bss, ".bss"))
    place = &hold_bss;
d936 2
a937 2
	   && HAVE_SECTION (hold_data, ".data"))
    place = &hold_data;
d939 11
a949 11
	   && (hold_rel.os != NULL
	       || (hold_rel.os = output_rel_find ()) != NULL))
    place = &hold_rel;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == SEC_READONLY
	   && HAVE_SECTION (hold_rodata, ".rodata"))
    place = &hold_rodata;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == (SEC_CODE | SEC_READONLY)
	   && hold_text.os != NULL)
    place = &hold_text;

#undef HAVE_SECTION
d975 16
a990 2
  /* Start building a list of statements for this section.
     First save the current statement pointer.  */
d992 2
d995 6
a1000 4
  /* If we have found an appropriate place for the output section
     statements for this orphan, add them to our own private list,
     inserting them later into the global statement list.  */
  if (place != NULL)
d1002 1
a1002 3
      stat_ptr = &add;
      lang_list_init (stat_ptr);
    }
d1004 6
a1009 18
  if (config.build_constructors)
    {
      /* If the name of the section is representable in C, then create
	 symbols to mark the start and the end of the section.  */
      for (ps = outsecname; *ps != '\0'; ps++)
	if (! isalnum ((unsigned char) *ps) && *ps != '_')
	  break;
      if (*ps == '\0')
	{
	  char *symname;
	  etree_type *e_align;

	  symname = (char *) xmalloc (ps - outsecname + sizeof "__start_");
	  sprintf (symname, "__start_%s", outsecname);
	  e_align = exp_unop (ALIGN_K,
			      exp_intop ((bfd_vma) 1 << s->alignment_power));
	  lang_add_assignment (exp_assop ('=', symname, e_align));
	}
d1012 3
a1014 1
  if (link_info.relocateable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
a1015 2
  else
    address = NULL;
d1017 5
a1021 5
  os = lang_enter_output_section_statement (outsecname, address, 0,
					    (bfd_vma) 0,
					    (etree_type *) NULL,
					    (etree_type *) NULL,
					    (etree_type *) NULL);
d1023 1
d1027 3
a1029 2
    ((bfd_vma) 0, "*default*",
     (struct lang_output_section_phdr_list *) NULL, "*default*");
d1031 1
a1031 1
  if (config.build_constructors && *ps == '\0')
a1034 5
      /* lang_leave_ouput_section_statement resets stat_ptr.  Put
	 stat_ptr back where we want it.  */
      if (place != NULL)
	stat_ptr = &add;

d1041 4
a1044 1
  /* Restore the global list pointer.  */
d1047 2
a1048 3
  if (place != NULL)
    {
      asection *snew, **pps;
d1050 5
a1054 23
      snew = os->bfd_section;
      if (place->section != NULL
	  || (place->os->bfd_section != NULL
	      && place->os->bfd_section != snew))
	{
	  /* Shuffle the section to make the output file look neater.
	     This is really only cosmetic.  */
	  if (place->section == NULL)
	    {
#if 0
	      /* Finding the end of the list is a little tricky.  We
		 make a wild stab at it by comparing section flags.  */
	      flagword first_flags = place->os->bfd_section->flags;
	      for (pps = &place->os->bfd_section->next;
		   *pps != NULL && (*pps)->flags == first_flags;
		   pps = &(*pps)->next)
		;
	      place->section = pps;
#else
	      /* Put orphans after the first section on the list.  */
	      place->section = &place->os->bfd_section->next;
#endif
	    }
d1056 2
a1057 28
	  /*  Unlink the section.  */
	  for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	    ;
	  *pps = snew->next;

	  /* Now tack it on to the "place->os" section list.  */
	  snew->next = *place->section;
	  *place->section = snew;
	}
      place->section = &snew->next;	/* Save the end of this list.  */

      if (add.head != NULL)
	{
	  /* We try to put the output statements in some sort of
	     reasonable order here, because they determine the final
	     load addresses of the orphan sections.  */
	  if (place->stmt == NULL)
	    {
	      /* Put the new statement list right at the head.  */
	      *add.tail = place->os->header.next;
	      place->os->header.next = add.head;
	    }
	  else
	    {
	      /* Put it after the last orphan statement we added.  */
	      *add.tail = *place->stmt;
	      *place->stmt = add.head;
	    }
d1059 1
a1059 4
	  /* Fix the global list pointer if we happened to tack our
	     new list at the tail.  */
	  if (*old->tail == add.head)
	    old->tail = add.tail;
d1061 21
a1081 6
	  /* Save the end of this list.  */
	  place->stmt = add.tail;
	}
    }

  return true;
@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d10 1
a10 1
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
a34 1
#include "libiberty.h"
d42 2
a46 2
#include "ldfile.h"
#include "ldemul.h"
a47 1
#include "elf/common.h"
d50 4
a53 1
static void gld${EMULATION_NAME}_vercheck
a56 1
static boolean gld${EMULATION_NAME}_try_needed PARAMS ((const char *, int));
d59 2
a60 1
static void gld${EMULATION_NAME}_check_needed
d62 1
a62 2
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
d65 1
a65 3
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
static boolean gld${EMULATION_NAME}_open_dynamic_archive
  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
a70 17
EOF

# Import any needed special functions and/or overrides.
#
if test -n "$EXTRA_EM_FILE" ; then
. ${srcdir}/emultempl/${EXTRA_EM_FILE}.em
fi

# Functions in this file can be overridden by setting the LDEMUL_* shell
# variables.  If the name of the overriding function is the same as is
# defined in this file, then don't output this file's version.
# If a different overriding name is given then output the standard function
# as presumably it is called from the overriding function.
#
if test x"$LDEMUL_BEFORE_PARSE" != xgld"$EMULATION_NAME"_before_parse; then
cat >>e${EMULATION_NAME}.c <<EOF

d72 1
a72 1
gld${EMULATION_NAME}_before_parse ()
d79 3
a81 2
EOF
fi
d83 8
a90 1
cat >>e${EMULATION_NAME}.c <<EOF
d92 2
a93 2
/* These variables are required to pass information back and forth
   between after_open and check_needed and stat_needed and vercheck.  */
d95 1
a95 5
static struct bfd_link_needed_list *global_needed;
static struct stat global_stat;
static boolean global_found;
static struct bfd_link_needed_list *global_vercheck_needed;
static boolean global_vercheck_failed;
d97 10
d108 1
a108 5
/* On Linux, it's possible to have different versions of the same
   shared library linked against different versions of libc.  The
   dynamic linker somehow tags which libc version to use in
   /etc/ld.so.cache, and, based on the libc that it sees in the
   executable, chooses which version of the shared library to use.
d110 7
a116 5
   We try to do a similar check here by checking whether this shared
   library needs any other shared libraries which may conflict with
   libraries we have already included in the link.  If it does, we
   skip it, and try to find another shared library farther on down the
   link path.
d118 1
a118 23
   This is called via lang_for_each_input_file.
   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object
   which we are checking.  This sets GLOBAL_VERCHECK_FAILED if we find
   a conflicting version.  */

static void
gld${EMULATION_NAME}_vercheck (s)
     lang_input_statement_type *s;
{
  const char *soname;
  struct bfd_link_needed_list *l;

  if (global_vercheck_failed)
    return;
  if (s->the_bfd == NULL
      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)
    return;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = basename (bfd_get_filename (s->the_bfd));

  for (l = global_vercheck_needed; l != NULL; l = l->next)
d120 2
a121 27
      const char *suffix;

      if (strcmp (soname, l->name) == 0)
	{
	  /* Probably can't happen, but it's an easy check.  */
	  continue;
	}

      if (strchr (l->name, '/') != NULL)
	continue;

      suffix = strstr (l->name, ".so.");
      if (suffix == NULL)
	continue;

      suffix += sizeof ".so." - 1;

      if (strncmp (soname, l->name, suffix - l->name) == 0)
	{
	  /* Here we know that S is a dynamic object FOO.SO.VER1, and
             the object we are considering needs a dynamic object
             FOO.SO.VER2, and VER1 and VER2 are different.  This
             appears to be a version mismatch, so we tell the caller
             to try a different version of this library.  */
	  global_vercheck_failed = true;
	  return;
	}
a122 1
}
d124 1
d126 9
a134 2
/* See if an input file matches a DT_NEEDED entry by running stat on
   the file.  */
d136 7
a142 7
static void
gld${EMULATION_NAME}_stat_needed (s)
     lang_input_statement_type *s;
{
  struct stat st;
  const char *suffix;
  const char *soname;
d144 1
a144 4
  if (global_found)
    return;
  if (s->the_bfd == NULL)
    return;
d146 2
a147 5
  if (bfd_stat (s->the_bfd, &st) != 0)
    {
      einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
      return;
    }
d149 7
a155 5
  if (st.st_dev == global_stat.st_dev
      && st.st_ino == global_stat.st_ino)
    {
      global_found = true;
      return;
d158 2
a159 8
  /* We issue a warning if it looks like we are including two
     different versions of the same shared library.  For example,
     there may be a problem if -lc picks up libc.so.6 but some other
     shared library has a DT_NEEDED entry of libc.so.5.  This is a
     heuristic test, and it will only work if the name looks like
     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.
     If we really want to issue warnings about mixing version numbers
     of shared libraries, we need to find a better way.  */
d161 5
a165 6
  if (strchr (global_needed->name, '/') != NULL)
    return;
  suffix = strstr (global_needed->name, ".so.");
  if (suffix == NULL)
    return;
  suffix += sizeof ".so." - 1;
d167 3
a169 3
  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = basename (s->filename);
d171 2
a172 10
  if (strncmp (soname, global_needed->name,
	       suffix - global_needed->name) == 0)
    einfo ("%P: warning: %s, needed by %B, may conflict with %s\n",
	   global_needed->name, global_needed->by, soname);
}


/* This function is called for each possible name for a dynamic object
   named by a DT_NEEDED entry.  The FORCE parameter indicates whether
   to skip the check for a conflicting version.  */
d175 1
a175 1
gld${EMULATION_NAME}_try_needed (name, force)
d179 2
a180 2
  bfd *abfd;
  const char *soname;
d182 1
a182 4
  abfd = bfd_openr (name, bfd_get_target (output_bfd));
  if (abfd == NULL)
    return false;
  if (! bfd_check_format (abfd, bfd_object))
d184 1
a184 8
      (void) bfd_close (abfd);
      return false;
    }
  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
    {
      (void) bfd_close (abfd);
      return false;
    }
d186 6
a191 4
  /* Check whether this object would include any conflicting library
     versions.  If FORCE is set, then we skip this check; we use this
     the second time around, if we couldn't find any compatible
     instance of the shared library.  */
d193 3
a195 3
  if (! force)
    {
      struct bfd_link_needed_list *needed;
d197 1
a197 9
      if (! bfd_elf_get_bfd_needed_list (abfd, &needed))
	einfo ("%F%P:%B: bfd_elf_get_bfd_needed_list failed: %E\n", abfd);

      if (needed != NULL)
	{
	  global_vercheck_needed = needed;
	  global_vercheck_failed = false;
	  lang_for_each_input_file (gld${EMULATION_NAME}_vercheck);
	  if (global_vercheck_failed)
d199 8
a206 179
	      (void) bfd_close (abfd);
	      /* Return false to force the caller to move on to try
                 another file on the search path.  */
	      return false;
	    }

	  /* But wait!  It gets much worse.  On Linux, if a shared
             library does not use libc at all, we are supposed to skip
             it the first time around in case we encounter a shared
             library later on with the same name which does use the
             version of libc that we want.  This is much too horrible
             to use on any system other than Linux.  */

EOF
case ${target} in
  *-*-linux-gnu*)
    cat >>e${EMULATION_NAME}.c <<EOF
	  {
	    struct bfd_link_needed_list *l;

	    for (l = needed; l != NULL; l = l->next)
	      if (strncmp (l->name, "libc.so", 7) == 0)
		break;
	    if (l == NULL)
	      {
		(void) bfd_close (abfd);
		return false;
	      }
	  }

EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
	}
    }

  /* We've found a dynamic object matching the DT_NEEDED entry.  */

  /* We have already checked that there is no other input file of the
     same name.  We must now check again that we are not including the
     same file twice.  We need to do this because on many systems
     libc.so is a symlink to, e.g., libc.so.1.  The SONAME entry will
     reference libc.so.1.  If we have already included libc.so, we
     don't want to include libc.so.1 if they are the same file, and we
     can only check that using stat.  */

  if (bfd_stat (abfd, &global_stat) != 0)
    einfo ("%F%P:%B: bfd_stat failed: %E\n", abfd);

  /* First strip off everything before the last '/'.  */
  soname = basename (abfd->filename);

  if (trace_file_tries)
    info_msg (_("found %s at %s\n"), soname, name);

  global_found = false;
  lang_for_each_input_file (gld${EMULATION_NAME}_stat_needed);
  if (global_found)
    {
      /* Return true to indicate that we found the file, even though
         we aren't going to do anything with it.  */
      return true;
    }

  /* Tell the ELF backend that we don't want the output file to have a
     DT_NEEDED entry for this file.  */
  bfd_elf_set_dt_needed_name (abfd, "");

  /* Tell the ELF backend that the output file needs a DT_NEEDED
     entry for this file if it is used to resolve the reference in
     a regular object.  */
  bfd_elf_set_dt_needed_soname (abfd, soname);

  /* Add this file into the symbol table.  */
  if (! bfd_link_add_symbols (abfd, &link_info))
    einfo ("%F%B: could not read symbols: %E\n", abfd);

  return true;
}


/* Search for a needed file in a path.  */

static boolean
gld${EMULATION_NAME}_search_needed (path, name, force)
     const char *path;
     const char *name;
     int force;
{
  const char *s;
  size_t len;

  if (name[0] == '/')
    return gld${EMULATION_NAME}_try_needed (name, force);

  if (path == NULL || *path == '\0')
    return false;
  len = strlen (name);
  while (1)
    {
      char *filename, *sset;

      s = strchr (path, ':');
      if (s == NULL)
	s = path + strlen (path);

      filename = (char *) xmalloc (s - path + len + 2);
      if (s == path)
	sset = filename;
      else
	{
	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);

      if (gld${EMULATION_NAME}_try_needed (filename, force))
	return true;

      free (filename);

      if (*s == '\0')
	break;
      path = s + 1;
    }

  return false;
}

EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
    case ${target} in
      *-*-linux-gnu*)
	cat >>e${EMULATION_NAME}.c <<EOF

/* For a native linker, check the file /etc/ld.so.conf for directories
   in which we may find shared libraries.  /etc/ld.so.conf is really
   only meaningful on Linux.  */

static boolean gld${EMULATION_NAME}_check_ld_so_conf
  PARAMS ((const char *, int));

static boolean
gld${EMULATION_NAME}_check_ld_so_conf (name, force)
     const char *name;
     int force;
{
  static boolean initialized;
  static char *ld_so_conf;

  if (! initialized)
    {
      FILE *f;

      f = fopen ("/etc/ld.so.conf", FOPEN_RT);
      if (f != NULL)
	{
	  char *b;
	  size_t len, alloc;
	  int c;

	  len = 0;
	  alloc = 100;
	  b = (char *) xmalloc (alloc);

	  while ((c = getc (f)) != EOF)
	    {
	      if (len + 1 >= alloc)
		{
		  alloc *= 2;
		  b = (char *) xrealloc (b, alloc);
		}
	      if (c != ':'
		  && c != ' '
		  && c != '\t'
d249 1
a249 3
	# Linux
	;;
    esac
d254 2
a255 1
/* See if an input file matches a DT_NEEDED entry by name.  */
d257 5
a261 47
static void
gld${EMULATION_NAME}_check_needed (s)
     lang_input_statement_type *s;
{
  if (global_found)
    return;

  if (s->filename != NULL)
    {
      const char *f;

      if (strcmp (s->filename, global_needed->name) == 0)
	{
	  global_found = true;
	  return;
	}

      if (s->search_dirs_flag)
	{
	  f = strrchr (s->filename, '/');
	  if (f != NULL
	      && strcmp (f + 1, global_needed->name) == 0)
	    {
	      global_found = true;
	      return;
	    }
	}
    }

  if (s->the_bfd != NULL)
    {
      const char *soname;

      soname = bfd_elf_get_dt_soname (s->the_bfd);
      if (soname != NULL
	  && strcmp (soname, global_needed->name) == 0)
	{
	  global_found = true;
	  return;
	}
    }
}

EOF

if test x"$LDEMUL_AFTER_OPEN" != xgld"$EMULATION_NAME"_after_open; then
cat >>e${EMULATION_NAME}.c <<EOF
a302 3
      if (trace_file_tries)
	info_msg (_("%s needed by %B\n"), l->name, l->by);

d307 2
a308 3
	 LD_LIBRARY_PATH (native only), then the DT_RPATH/DT_RUNPATH
	 entries (native only), then the linker script LIB_SEARCH_DIRS.
	 We do not search using the -L arguments.
d315 1
a317 13
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
	  const char *lib_path;
	  struct bfd_link_needed_list *rp;
	  int found;
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
a321 5
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
d333 5
a340 13

	  found = 0;
	  rp = bfd_elf_get_runpath_list (output_bfd, &link_info);
	  for (; !found && rp != NULL; rp = rp->next)
	    {
	      found = (rp->by == l->by
		       && gld${EMULATION_NAME}_search_needed (rp->name,
							      l->name,
							      force));
	    }
	  if (found)
	    break;

d365 1
a365 3
    case ${target} in
      *-*-linux-gnu*)
	cat >>e${EMULATION_NAME}.c <<EOF
a368 3
	# Linux
        ;;
    esac
d383 1
a383 2
EOF
fi
d385 8
a392 1
cat >>e${EMULATION_NAME}.c <<EOF
d394 149
a542 1
/* Look through an expression for an assignment statement.  */
d545 2
a546 2
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
d548 9
a556 1
  struct bfd_link_hash_entry *h;
d558 1
a558 1
  switch (exp->type.node_class)
d560 1
a560 5
    case etree_provide:
      h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,
				false, false, false);
      if (h == NULL)
	break;
d562 14
a575 7
      /* We call record_link_assignment even if the symbol is defined.
	 This is because if it is defined by a dynamic object, we
	 actually want to use the value defined by the linker script,
	 not the value from the dynamic object (because we are setting
	 symbols like etext).  If the symbol is defined by a regular
	 object, then, as it happens, calling record_link_assignment
	 will do no harm.  */
d577 3
a579 3
      /* Fall through.  */
    case etree_assign:
      if (strcmp (exp->assign.dst, ".") != 0)
d581 2
a582 5
	  if (! (bfd_elf${ELFSIZE}_record_link_assignment
		 (output_bfd, &link_info, exp->assign.dst,
		  exp->type.node_class == etree_provide ? true : false)))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
d584 5
a588 2
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;
d590 8
a597 4
    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;
d599 4
a602 5
    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;
d604 5
a608 3
    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;
d610 5
a614 2
    default:
      break;
a615 1
}
d617 87
d705 1
a705 4
/* This is called by the before_allocation routine via
   lang_for_each_statement.  It locates any assignment statements, and
   tells the ELF backend about them, in case they are assignments to
   symbols which are referred to by dynamic objects.  */
d707 11
a717 6
static void
gld${EMULATION_NAME}_find_statement_assignment (s)
     lang_statement_union_type *s;
{
  if (s->header.type == lang_assignment_statement_enum)
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
a719 5
EOF

if test x"$LDEMUL_BEFORE_ALLOCATION" != xgld"$EMULATION_NAME"_before_allocation; then
cat >>e${EMULATION_NAME}.c <<EOF

d794 4
a797 2
EOF
fi
d799 7
a805 2
if test x"$LDEMUL_OPEN_DYNAMIC_ARCHIVE" != xgld"$EMULATION_NAME"_open_dynamic_archive; then
cat >>e${EMULATION_NAME}.c <<EOF
d807 1
a807 3
/* Try to open a dynamic archive.  This is where we know that ELF
   dynamic libraries have an extension of .so (or .sl on oddball systems
   like hpux).  */
d809 3
a811 5
static boolean
gld${EMULATION_NAME}_open_dynamic_archive (arch, search, entry)
     const char *arch;
     search_dirs_type *search;
     lang_input_statement_type *entry;
d813 1
a813 2
  const char *filename;
  char *string;
d815 7
a821 2
  if (! entry->is_archive)
    return false;
d823 7
a829 1
  filename = entry->filename;
d831 12
a842 10
  /* This allocates a few bytes too many when EXTRA_SHLIB_EXTENSION
     is defined, but it does not seem worth the headache to optimize
     away those two bytes of space.  */
  string = (char *) xmalloc (strlen (search->name)
			     + strlen (filename)
			     + strlen (arch)
#ifdef EXTRA_SHLIB_EXTENSION
			     + strlen (EXTRA_SHLIB_EXTENSION)
#endif
			     + sizeof "/lib.so");
d844 4
a847 1
  sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);
d849 5
a853 7
#ifdef EXTRA_SHLIB_EXTENSION
  /* Try the .so extension first.  If that fails build a new filename
     using EXTRA_SHLIB_EXTENSION.  */
  if (! ldfile_try_open_bfd (string, entry))
    sprintf (string, "%s/lib%s%s%s", search->name,
	     filename, arch, EXTRA_SHLIB_EXTENSION);
#endif
d855 3
a857 5
  if (! ldfile_try_open_bfd (string, entry))
    {
      free (string);
      return false;
    }
d859 2
a860 25
  entry->filename = string;

  /* We have found a dynamic object to include in the link.  The ELF
     backend linker will create a DT_NEEDED entry in the .dynamic
     section naming this file.  If this file includes a DT_SONAME
     entry, it will be used.  Otherwise, the ELF linker will just use
     the name of the file.  For an archive found by searching, like
     this one, the DT_NEEDED entry should consist of just the name of
     the file, without the path information used to find it.  Note
     that we only need to do this if we have a dynamic object; an
     archive will never be referenced by a DT_NEEDED entry.

     FIXME: This approach--using bfd_elf_set_dt_needed_name--is not
     very pretty.  I haven't been able to think of anything that is
     pretty, though.  */
  if (bfd_check_format (entry->the_bfd, bfd_object)
      && (entry->the_bfd->flags & DYNAMIC) != 0)
    {
      ASSERT (entry->is_archive && entry->search_dirs_flag);

      /* Rather than duplicating the logic above.  Just use the
	 filename we recorded earlier.  */

      filename = xstrdup (basename (entry->filename));
      bfd_elf_set_dt_needed_name (entry->the_bfd, filename);
a861 2

  return true;
a863 4
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF

a886 5
EOF

if test x"$LDEMUL_PLACE_ORPHAN" != xgld"$EMULATION_NAME"_place_orphan; then
cat >>e${EMULATION_NAME}.c <<EOF

a906 2
  static struct orphan_save hold_sdata;
  static int count = 1;
d918 6
a923 1
  if (! config.unique_orphan_sections && ! unique_section_p (secname))
d925 3
a927 12
      /* Look through the script to see where to place this section.  */
      os = lang_output_section_find (secname);

      if (os != NULL
	  && os->bfd_section != NULL
	  && ((s->flags ^ os->bfd_section->flags)
	      & (SEC_LOAD | SEC_ALLOC)) == 0)
	{
	  /* We have already placed a section with this name.  */
	  wild_doit (&os->children, s, os, file);
	  return true;
	}
d959 1
a959 1
	   && strncmp (secname, ".note", 5) == 0
a964 3
  else if ((s->flags & SEC_SMALL_DATA) != 0
	   && HAVE_SECTION (hold_sdata, ".sdata"))
    place = &hold_sdata;
d983 1
a983 1
     loadable or allocatable characteristics.  */
d987 16
a1002 5
      outsecname = bfd_get_unique_section_name (output_bfd,
						outsecname,
						&count);
      if (outsecname == NULL)
	einfo ("%F%P: place_orphan failed: %E\n");
a1142 6
EOF
fi

if test x"$LDEMUL_GET_SCRIPT" != xgld"$EMULATION_NAME"_get_script; then
cat >>e${EMULATION_NAME}.c <<EOF

d1144 1
a1144 1
gld${EMULATION_NAME}_get_script (isfile)
d1156 1
a1156 1
{
d1183 1
a1183 1
{
a1198 1

a1199 6
fi
fi

if test -n "$PARSE_AND_LIST_ARGS_CASES" -o x"$GENERATE_SHLIB_SCRIPT" = xyes; then

if test x"$LDEMUL_PARSE_ARGS" != xgld"$EMULATION_NAME"_parse_args; then
a1200 4
if test -n "$PARSE_AND_LIST_PROLOGUE" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_PROLOGUE
EOF
d1203 1
d1205 2
d1208 1
a1208 8
#include "getopt.h"

#define OPTION_DISABLE_NEW_DTAGS	(400)
#define OPTION_ENABLE_NEW_DTAGS		(OPTION_DISABLE_NEW_DTAGS + 1)
#define OPTION_GROUP			(OPTION_ENABLE_NEW_DTAGS + 1)

static struct option longopts[] =
{
d1210 1
a1211 153
if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
cat >>e${EMULATION_NAME}.c <<EOF
  /* getopt allows abbreviations, so we do this to stop it from
     treating -d/-e as abbreviations for these options. */
  {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
  {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
  {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
  {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
  {"Bgroup", no_argument, NULL, OPTION_GROUP},
  {"Bgroup", no_argument, NULL, OPTION_GROUP},
EOF
fi

if test -n "$PARSE_AND_LIST_LONGOPTS" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_LONGOPTS
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
  {NULL, no_argument, NULL, 0}
};


static int gld${EMULATION_NAME}_parse_args PARAMS ((int, char **));

static int
gld${EMULATION_NAME}_parse_args (argc, argv)
     int argc;
     char ** argv;
{
  int longind;
  int optc;
  static int prevoptind = -1;
  int prevopterr = opterr;
  int wanterror;

  if (prevoptind != optind)
    opterr = 0;

  wanterror = opterr;
  prevoptind = optind;

  optc = getopt_long_only (argc, argv,
			   "-${PARSE_AND_LIST_SHORTOPTS}z:", longopts,
			   &longind);
  opterr = prevopterr;

  switch (optc)
    {
    default:
      if (wanterror)
	xexit (1);
      optind = prevoptind;
      return 0;

EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
cat >>e${EMULATION_NAME}.c <<EOF
    case OPTION_DISABLE_NEW_DTAGS:
      link_info.new_dtags = false;
      break;

    case OPTION_ENABLE_NEW_DTAGS:
      link_info.new_dtags = true;
      break;

    case OPTION_GROUP:
      link_info.flags_1 |= (bfd_vma) DF_1_GROUP;
      /* Groups must be self-contained.  */
      link_info.no_undefined = true;
      break;

    case 'z':
      if (strcmp (optarg, "initfirst") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INITFIRST;
      else if (strcmp (optarg, "interpose") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INTERPOSE;
      else if (strcmp (optarg, "loadfltr") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_LOADFLTR;
      else if (strcmp (optarg, "nodefaultlib") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODEFLIB;
      else if (strcmp (optarg, "nodelete") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODELETE;
      else if (strcmp (optarg, "nodlopen") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NOOPEN;
      else if (strcmp (optarg, "nodump") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODUMP;
      else if (strcmp (optarg, "now") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_BIND_NOW;
	  link_info.flags_1 |= (bfd_vma) DF_1_NOW;
	}
      else if (strcmp (optarg, "origin") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_ORIGIN;
	  link_info.flags_1 |= (bfd_vma) DF_1_ORIGIN;
	}
      else if (strcmp (optarg, "defs") == 0)
	link_info.no_undefined = true;
      /* What about the other Solaris -z options? FIXME.  */
      break;
EOF
fi

if test -n "$PARSE_AND_LIST_ARGS_CASES" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_ARGS_CASES
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
    }

  return 1;
}

EOF
fi

if test x"$LDEMUL_LIST_OPTIONS" != xgld"$EMULATION_NAME"_list_options; then
cat >>e${EMULATION_NAME}.c <<EOF

static void gld${EMULATION_NAME}_list_options PARAMS ((FILE * file));

static void
gld${EMULATION_NAME}_list_options (file)
     FILE * file;
{
EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
cat >>e${EMULATION_NAME}.c <<EOF
  fprintf (file, _("  -Bgroup\t\tSelects group name lookup rules for DSO\n"));
  fprintf (file, _("  --disable-new-dtags\tDisable new dynamic tags\n"));
  fprintf (file, _("  --enable-new-dtags\tEnable new dynamic tags\n"));
  fprintf (file, _("  -z defs\t\tDisallows undefined symbols\n"));
  fprintf (file, _("  -z initfirst\t\tMark DSO to be initialized first at runtime\n"));
  fprintf (file, _("  -z interpose\t\tMark object to interpose all DSOs but executable\n"));
  fprintf (file, _("  -z loadfltr\t\tMark object requiring immediate process\n"));
  fprintf (file, _("  -z nodefaultlib\tMark object not to use default search paths\n"));
  fprintf (file, _("  -z nodelete\t\tMark DSO non-deletable at runtime\n"));
  fprintf (file, _("  -z nodlopen\t\tMark DSO not available to dlopen\n"));
  fprintf (file, _("  -z nodump\t\tMark DSO not available to dldump\n"));
  fprintf (file, _("  -z now\t\tMark object non-lazy runtime binding\n"));
  fprintf (file, _("  -z origin\t\tMark object requiring immediate \$ORIGIN processing\n"));
  fprintf (file, _("\t\t\t  at runtime\n"));
  fprintf (file, _("  -z KEYWORD\t\tIgnored for Solaris compatibility\n"));
EOF
fi

if test -n "$PARSE_AND_LIST_OPTIONS" ; then
d1213 2
a1214 6
 $PARSE_AND_LIST_OPTIONS
EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
}
a1216 17
if test -n "$PARSE_AND_LIST_EPILOGUE" ; then
cat >>e${EMULATION_NAME}.c <<EOF
 $PARSE_AND_LIST_EPILOGUE
EOF
fi
fi
else
if test x"$LDEMUL_PARSE_ARGS" != xgld"$EMULATION_NAME"_parse_args; then
cat >>e${EMULATION_NAME}.c <<EOF
#define gld${EMULATION_NAME}_parse_args   NULL
EOF
fi
if test x"$LDEMUL_LIST_OPTIONS" != xgld"$EMULATION_NAME"_list_options; then
cat >>e${EMULATION_NAME}.c <<EOF
#define gld${EMULATION_NAME}_list_options NULL
EOF
fi
d1221 1
a1221 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
d1223 10
a1232 10
  ${LDEMUL_BEFORE_PARSE-gld${EMULATION_NAME}_before_parse},
  ${LDEMUL_SYSLIB-syslib_default},
  ${LDEMUL_HLL-hll_default},
  ${LDEMUL_AFTER_PARSE-after_parse_default},
  ${LDEMUL_AFTER_OPEN-gld${EMULATION_NAME}_after_open},
  ${LDEMUL_AFTER_ALLOCATION-after_allocation_default},
  ${LDEMUL_SET_OUTPUT_ARCH-set_output_arch_default},
  ${LDEMUL_CHOOSE_TARGET-ldemul_default_target},
  ${LDEMUL_BEFORE_ALLOCATION-gld${EMULATION_NAME}_before_allocation},
  ${LDEMUL_GET_SCRIPT-gld${EMULATION_NAME}_get_script},
d1235 10
a1244 10
  ${LDEMUL_FINISH-NULL},
  ${LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS-NULL},
  ${LDEMUL_OPEN_DYNAMIC_ARCHIVE-gld${EMULATION_NAME}_open_dynamic_archive},
  ${LDEMUL_PLACE_ORPHAN-gld${EMULATION_NAME}_place_orphan},
  ${LDEMUL_SET_SYMBOLS-NULL},
  ${LDEMUL_PARSE_ARGS-gld${EMULATION_NAME}_parse_args},
  ${LDEMUL_UNRECOGNIZED_FILE-NULL},
  ${LDEMUL_LIST_OPTIONS-gld${EMULATION_NAME}_list_options},
  ${LDEMUL_RECOGNIZED_FILE-NULL},
  ${LDEMUL_FIND_POTENTIAL_LIBRARIES-NULL},
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@a5 5
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
d10 2
a11 2
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.
d36 2
a37 2
#include "safe-ctype.h"
#include "getopt.h"
d48 1
a48 1
#include <ldgram.h>
d51 1
a51 2
static void gld${EMULATION_NAME}_before_parse
  PARAMS ((void));
d56 2
a57 3
static bfd_boolean gld${EMULATION_NAME}_try_needed
  PARAMS ((const char *, int));
static bfd_boolean gld${EMULATION_NAME}_search_needed
d61 2
a62 4
static void gld${EMULATION_NAME}_after_open
  PARAMS ((void));
static void gld${EMULATION_NAME}_find_exp_assignment
  PARAMS ((etree_type *));
d65 2
a66 3
static void gld${EMULATION_NAME}_before_allocation
  PARAMS ((void));
static bfd_boolean gld${EMULATION_NAME}_open_dynamic_archive
d68 2
a69 5
static lang_output_section_statement_type *output_rel_find
  PARAMS ((asection *));
static asection *output_prev_sec_find
  PARAMS ((lang_output_section_statement_type *));
static bfd_boolean gld${EMULATION_NAME}_place_orphan
d71 1
a71 4
static void gld${EMULATION_NAME}_finish
  PARAMS ((void));
static char *gld${EMULATION_NAME}_get_script
  PARAMS ((int *isfile));
d93 3
a95 11
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;
  config.dynamic_link = ${DYNAMIC_LINK-TRUE};
  config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo TRUE ; else echo FALSE ; fi`;
d108 1
a108 1
static bfd_boolean global_found;
d110 1
a110 1
static bfd_boolean global_vercheck_failed;
d145 1
a145 1
    soname = lbasename (bfd_get_filename (s->the_bfd));
d173 1
a173 1
	  global_vercheck_failed = TRUE;
d205 1
a205 1
      global_found = TRUE;
d227 1
a227 1
    soname = lbasename (s->filename);
d229 2
a230 1
  if (strncmp (soname, global_needed->name, suffix - global_needed->name) == 0)
d240 1
a240 1
static bfd_boolean
d250 1
a250 1
    return FALSE;
d253 2
a254 2
      bfd_close (abfd);
      return FALSE;
d258 2
a259 9
      bfd_close (abfd);
      return FALSE;
    }

  /* For DT_NEEDED, they have to match.  */
  if (abfd->xvec != output_bfd->xvec)
    {
      bfd_close (abfd);
      return FALSE;
d277 1
a277 1
	  global_vercheck_failed = FALSE;
d281 2
a282 2
	      bfd_close (abfd);
	      /* Return FALSE to force the caller to move on to try
d284 1
a284 1
	      return FALSE;
d306 2
a307 2
		bfd_close (abfd);
		return FALSE;
d332 1
a332 1
  soname = lbasename (abfd->filename);
d337 1
a337 1
  global_found = FALSE;
d341 1
a341 1
      /* Return TRUE to indicate that we found the file, even though
d343 1
a343 1
      return TRUE;
d359 1
a359 1
  return TRUE;
d365 1
a365 1
static bfd_boolean
d378 1
a378 1
    return FALSE;
d400 1
a400 1
	return TRUE;
d409 1
a409 1
  return FALSE;
d413 6
a418 13
if [ "x${USE_LIBPATH}" = xyes ] ; then
  cat >>e${EMULATION_NAME}.c <<EOF

/* Add the sysroot to every entry in a colon-separated path.  */

static char * gld${EMULATION_NAME}_add_sysroot PARAMS ((const char *));

static char *
gld${EMULATION_NAME}_add_sysroot (path)
     const char *path;
{
  int len, colons, i;
  char *ret, *p;
a419 33
  len = strlen (path);
  colons = 0;
  i = 0;
  while (path[i])
    if (path[i++] == ':')
      colons++;

  if (path[i])
    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
  p = ret + strlen (ret);
  i = 0;
  while (path[i])
    if (path[i] == ':')
      {
        *p++ = path[i++];
	strcpy (p, ld_sysroot);
	p = p + strlen (p);
      }
    else
      *p++ = path[i++];

  *p = 0;
  return ret;
}

EOF
  case ${target} in
    *-*-linux-gnu*)
      cat >>e${EMULATION_NAME}.c <<EOF
d424 1
a424 1
static bfd_boolean gld${EMULATION_NAME}_check_ld_so_conf
d427 1
a427 1
static bfd_boolean
d432 1
a432 1
  static bfd_boolean initialized;
a437 1
      char *tmppath;
d439 1
a439 3
      tmppath = concat (ld_sysroot, "/etc/ld.so.conf", NULL);
      f = fopen (tmppath, FOPEN_RT);
      free (tmppath);
a488 7
	  if (b)
	    {
	      char *d = gld${EMULATION_NAME}_add_sysroot (b);
	      free (b);
	      b = d;
	    }

d492 1
a492 1
      initialized = TRUE;
d496 1
a496 1
    return FALSE;
d502 3
a504 2
    # Linux
    ;;
d524 1
a524 1
	  global_found = TRUE;
d534 1
a534 1
	      global_found = TRUE;
d548 1
a548 1
	  global_found = TRUE;
d594 1
a594 1
      global_found = FALSE;
d618 3
a620 1
if [ "x${USE_LIBPATH}" = xyes ] ; then
d626 2
d635 3
a637 1
if [ "x${USE_LIBPATH}" = xyes ] ; then
a641 4
EOF
fi
if [ "x${NATIVE}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
d653 1
a653 4
EOF
fi
if [ "x${USE_LIBPATH}" = xyes ] ; then
cat >>e${EMULATION_NAME}.c <<EOF
a657 1
	      char *tmpname = gld${EMULATION_NAME}_add_sysroot (rp->name);
d659 1
a659 1
		       && gld${EMULATION_NAME}_search_needed (tmpname,
a661 1
	      free (tmpname);
d667 2
d687 6
a692 4
if [ "x${USE_LIBPATH}" = xyes ] ; then
  case ${target} in
    *-*-linux-gnu*)
      cat >>e${EMULATION_NAME}.c <<EOF
d696 4
a699 2
    # Linux
    ;;
d730 1
a730 1
				FALSE, FALSE, FALSE);
d748 1
a748 1
		  exp->type.node_class == etree_provide ? TRUE : FALSE)))
a791 12
  if test x"${ELF_INTERPRETER_NAME+set}" = xset; then
    ELF_INTERPRETER_SET_DEFAULT="
  if (sinterp != NULL)
    {
      sinterp->contents = ${ELF_INTERPRETER_NAME};
      sinterp->_raw_size = strlen (sinterp->contents) + 1;
    }

"
  else
    ELF_INTERPRETER_SET_DEFAULT=
  fi
d815 1
a815 1
	  command_line.filter_shlib,
d819 1
a819 1
${ELF_INTERPRETER_SET_DEFAULT}
d839 1
a839 1
	bfd_boolean ret;
d878 1
a878 1
static bfd_boolean
d888 1
a888 1
    return FALSE;
d916 1
a916 1
      return FALSE;
d942 1
a942 1
      filename = lbasename (entry->filename);
d946 1
a946 1
  return TRUE;
a950 2

if test x"$LDEMUL_PLACE_ORPHAN" != xgld"$EMULATION_NAME"_place_orphan; then
d956 1
a956 2
output_rel_find (sec)
     asection *sec;
a959 4
  lang_output_section_statement_type *last = NULL;
  lang_output_section_statement_type *last_rel = NULL;
  lang_output_section_statement_type *last_rel_alloc = NULL;
  int rela = sec->name[4] == 'a';
d961 3
a963 1
  for (u = lang_output_section_statement.head; u; u = lookup->next)
d966 3
a968 1
      if (strncmp (".rel", lookup->name, 4) == 0)
d970 1
a970 15
	  /* Don't place after .rel.plt as doing so results in wrong
	     dynamic tags.  Also, place allocated reloc sections before
	     non-allocated.  */
	  int lookrela = lookup->name[4] == 'a';

	  if (strcmp (".plt", lookup->name + 4 + lookrela) == 0
	      || (lookup->bfd_section != NULL
		  && (lookup->bfd_section->flags & SEC_ALLOC) == 0))
	    break;
	  last = lookup;
	  if (rela == lookrela)
	    last_rel = lookup;
	  if (lookup->bfd_section != NULL
	      && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	    last_rel_alloc = lookup;
d973 1
a973 8

  if (last_rel_alloc)
    return last_rel_alloc;

  if (last_rel)
    return last_rel;

  return last;
d976 1
a976 2
/* Find the last output section before given output statement.
   Used by place_orphan.  */
d978 2
a979 22
static asection *
output_prev_sec_find (os)
     lang_output_section_statement_type *os;
{
  asection *s = (asection *) NULL;
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (lookup == os)
	return s;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	s = lookup->bfd_section;
    }

  return NULL;
}
a987 1
  lang_statement_union_type **os_tail;
d990 1
a990 1
static bfd_boolean
d1008 1
a1010 3
  lang_statement_union_type **os_tail;
  etree_type *load_base;
  int isdyn = 0;
a1012 11
  if (! link_info.relocateable
      && link_info.combreloc
      && (s->flags & SEC_ALLOC)
      && strncmp (secname, ".rel", 4) == 0)
    {
      if (secname[4] == 'a')
	secname = ".rela.dyn";
      else
	secname = ".rel.dyn";
      isdyn = 1;
    }
d1014 1
a1014 1
  if (isdyn || (!config.unique_orphan_sections && !unique_section_p (secname)))
d1020 3
a1022 3
	  && (os->bfd_section == NULL
	      || ((s->flags ^ os->bfd_section->flags)
		  & (SEC_LOAD | SEC_ALLOC)) == 0))
d1024 3
a1026 4
	  /* We already have an output section statement with this
	     name, and its bfd section, if any, has compatible flags.  */
	  lang_add_section (&os->children, s, os, file);
	  return TRUE;
d1040 2
a1041 2
      lang_add_section (&hold_text.os->children, s, hold_text.os, file);
      return TRUE;
d1052 2
a1053 6
  if ((s->flags & SEC_EXCLUDE) != 0 && !link_info.relocateable)
    {
      if (s->output_section == NULL)
	s->output_section = bfd_abs_section_ptr;
      return TRUE;
    }
a1071 1
	   && (s->flags & SEC_LOAD) != 0
d1073 1
a1073 1
	       || (hold_rel.os = output_rel_find (s)) != NULL))
d1087 2
a1088 1
  if (bfd_get_section_by_name (output_bfd, secname) != NULL)
d1090 4
a1093 2
      secname = bfd_get_unique_section_name (output_bfd, secname, &count);
      if (secname == NULL)
d1114 2
a1115 2
      for (ps = secname; *ps != '\0'; ps++)
	if (! ISALNUM (*ps) && *ps != '_')
d1122 2
a1123 2
	  symname = (char *) xmalloc (ps - secname + sizeof "__start_");
	  sprintf (symname, "__start_%s", secname);
a1129 1
  address = NULL;
d1132 2
d1135 1
a1135 12
  load_base = NULL;
  if (place != NULL && place->os->load_base != NULL)
    {
      etree_type *lma_from_vma;
      lma_from_vma = exp_binop ('-', place->os->load_base,
				exp_nameop (ADDR, place->os->name));
      load_base = exp_binop ('+', lma_from_vma,
			     exp_nameop (ADDR, secname));
    }

  os_tail = lang_output_section_statement.tail;
  os = lang_enter_output_section_statement (secname, address, 0,
d1139 1
a1139 1
					    load_base);
d1141 1
a1141 1
  lang_add_section (&os->children, s, os, file);
d1145 1
a1145 1
     (struct lang_output_section_phdr_list *) NULL, NULL);
d1156 2
a1157 2
      symname = (char *) xmalloc (ps - secname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", secname);
d1165 1
a1165 1
  if (place != NULL && os->bfd_section != NULL)
d1170 3
a1172 4

      /* Shuffle the bfd section list to make the output file look
	 neater.  This is really only cosmetic.  */
      if (place->section == NULL)
d1174 18
a1191 12
	  asection *bfd_section = place->os->bfd_section;

	  /* If the output statement hasn't been used to place
	     any input sections (and thus doesn't have an output
	     bfd_section), look for the closest prior output statement
	     having an output section.  */
	  if (bfd_section == NULL)
	    bfd_section = output_prev_sec_find (place->os);

	  if (bfd_section != NULL && bfd_section != snew)
	    place->section = &bfd_section->next;
	}
d1193 1
a1193 3
      if (place->section != NULL)
	{
	  /* Unlink the section.  */
d1196 1
a1196 1
	  bfd_section_list_remove (output_bfd, pps);
d1199 2
a1200 1
	  bfd_section_list_insert (output_bfd, place->section, snew);
d1202 1
a1203 13
      /* Save the end of this list.  Further ophans of this type will
	 follow the one we've just added.  */
      place->section = &snew->next;

      /* The following is non-cosmetic.  We try to put the output
	 statements in some sort of reasonable order here, because
	 they determine the final load addresses of the orphan
	 sections.  In addition, placing output statements in the
	 wrong order may require extra segments.  For instance,
	 given a typical situation of all read-only sections placed
	 in one segment and following that a segment containing all
	 the read-write sections, we wouldn't want to place an orphan
	 read/write section before or amongst the read-only ones.  */
d1206 3
a1208 2
	  lang_statement_union_type *newly_added_os;

a1213 2

	      place->os_tail = &place->os->next;
a1228 15

	  /* Do the same for the list of output section statements.  */
	  newly_added_os = *os_tail;
	  *os_tail = NULL;
	  newly_added_os->output_section_statement.next = *place->os_tail;
	  *place->os_tail = newly_added_os;
	  place->os_tail = &newly_added_os->output_section_statement.next;

	  /* Fixing the global list pointer here is a little different.
	     We added to the list in lang_enter_output_section_statement,
	     trimmed off the new output_section_statment above when
	     assigning *os_tail = NULL, but possibly added it back in
	     the same place when assigning *place->os_tail.  */
	  if (*os_tail == NULL)
	    lang_output_section_statement.tail = os_tail;
d1232 1
a1232 1
  return TRUE;
a1233 5
EOF
fi

if test x"$LDEMUL_FINISH" != xgld"$EMULATION_NAME"_finish; then
cat >>e${EMULATION_NAME}.c <<EOF
a1234 19
static void
gld${EMULATION_NAME}_finish ()
{
  if (bfd_elf${ELFSIZE}_discard_info (output_bfd, &link_info))
    {
      lang_reset_memory_regions ();

      /* Resize the sections.  */
      lang_size_sections (stat_ptr->head, abs_output_section,
			  &stat_ptr->head, 0, (bfd_vma) 0, NULL, TRUE);

      /* Redo special stuff.  */
      ldemul_after_allocation ();

      /* Do the assignments again.  */
      lang_do_assignments (stat_ptr->head, abs_output_section,
			   (fill_type *) 0, (bfd_vma) 0);
    }
}
d1257 1
a1257 1
  if (link_info.relocateable && config.build_constructors)
d1260 11
a1270 8
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
if cmp -s ldscripts/${EMULATION_NAME}.x ldscripts/${EMULATION_NAME}.xn; then : ; else
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
d1272 4
a1275 15
if test -n "$GENERATE_SHLIB_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.shared && link_info.combreloc) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xsc                >> e${EMULATION_NAME}.c
fi
echo '  ; else if (link_info.shared) return'	       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs                 >> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.combreloc) return'        >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xc                 >> e${EMULATION_NAME}.c
fi
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c
d1284 1
a1284 1
  if (link_info.relocateable && config.build_constructors)
d1286 1
a1286 1
  else if (link_info.relocateable)
a1289 4
EOF
if cmp -s ldscripts/${EMULATION_NAME}.x ldscripts/${EMULATION_NAME}.xn; then :
else
cat >>e${EMULATION_NAME}.c <<EOF
a1291 10
EOF
fi
if test -n "$GENERATE_SHLIB_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.shared && link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xsc";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
a1293 9
EOF
fi
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xc";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
d1304 2
d1314 2
a1318 1
#define OPTION_EH_FRAME_HDR		(OPTION_GROUP + 1)
d1320 1
a1320 11
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));

static void
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns;
     char **shortopts;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
a1321 2
  static const char xtra_short[] = "${PARSE_AND_LIST_SHORTOPTS}z:";
  static const struct option xtra_long[] = {
d1326 8
a1333 4
    {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
    {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
    {"eh-frame-hdr", no_argument, NULL, OPTION_EH_FRAME_HDR},
    {"Bgroup", no_argument, NULL, OPTION_GROUP},
d1339 1
a1339 1
    $PARSE_AND_LIST_LONGOPTS
d1344 3
a1346 2
    {NULL, no_argument, NULL, 0}
  };
d1348 1
a1348 6
  *shortopts = (char *) xrealloc (*shortopts, ns + sizeof (xtra_short));
  memcpy (*shortopts + ns, &xtra_short, sizeof (xtra_short));
  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}
d1350 21
a1370 2
static bfd_boolean gld${EMULATION_NAME}_handle_option
  PARAMS ((int));
a1371 4
static bfd_boolean
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
{
d1375 4
a1378 1
      return FALSE;
d1385 1
a1385 1
      link_info.new_dtags = FALSE;
d1389 1
a1389 5
      link_info.new_dtags = TRUE;
      break;

    case OPTION_EH_FRAME_HDR:
      link_info.eh_frame_hdr = TRUE;
d1395 1
a1395 1
      link_info.no_undefined = TRUE;
d1424 1
a1424 9
	link_info.no_undefined = TRUE;
      else if (strcmp (optarg, "muldefs") == 0)
	link_info.allow_multiple_definition = TRUE;
      else if (strcmp (optarg, "combreloc") == 0)
	link_info.combreloc = TRUE;
      else if (strcmp (optarg, "nocombreloc") == 0)
	link_info.combreloc = FALSE;
      else if (strcmp (optarg, "nocopyreloc") == 0)
        link_info.nocopyreloc = TRUE;
d1439 1
a1439 1
  return TRUE;
d1443 1
a1460 2
  fprintf (file, _("  --eh-frame-hdr\tCreate .eh_frame_hdr section\n"));
  fprintf (file, _("  -z combreloc\t\tMerge dynamic relocs into one section and sort\n"));
a1464 3
  fprintf (file, _("  -z muldefs\t\tAllow multiple definitions\n"));
  fprintf (file, _("  -z nocombreloc\tDon't merge dynamic relocs into one section\n"));
  fprintf (file, _("  -z nocopyreloc\tDon't create copy relocs\n"));
d1470 2
a1471 1
  fprintf (file, _("  -z origin\t\tMark object requiring immediate \$ORIGIN processing\n\t\t\t  at runtime\n"));
d1493 1
d1495 1
a1495 2
#define gld${EMULATION_NAME}_add_options NULL
#define gld${EMULATION_NAME}_handle_option NULL
d1497 1
d1521 1
a1521 1
  ${LDEMUL_FINISH-gld${EMULATION_NAME}_finish},
d1526 1
a1526 3
  ${LDEMUL_PARSE_ARGS-NULL},
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
a1530 1
  ${LDEMUL_NEW_VERS_PATTERN-NULL}
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d16 1
a16 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d56 26
a81 4
/* Declare functions used by various EXTRA_EM_FILEs.  */
static void gld${EMULATION_NAME}_before_parse (void);
static void gld${EMULATION_NAME}_after_open (void);
static void gld${EMULATION_NAME}_before_allocation (void);
d83 5
a87 2
  (lang_input_statement_type *file, asection *s);
static void gld${EMULATION_NAME}_finish (void);
d107 1
a107 1
gld${EMULATION_NAME}_before_parse (void)
d109 9
a117 1
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
a124 22
if test x"$LDEMUL_RECOGNIZED_FILE" != xgld"${EMULATION_NAME}"_load_symbols; then
cat >>e${EMULATION_NAME}.c <<EOF
/* Handle as_needed DT_NEEDED.  */

static bfd_boolean
gld${EMULATION_NAME}_load_symbols (lang_input_statement_type *entry)
{
  if (!entry->as_needed
      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)
    return FALSE;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  bfd_elf_set_dyn_lib_class (entry->the_bfd, DYN_AS_NEEDED);

  /* Continue on with normal load_symbols processing.  */
  return FALSE;
}
EOF
fi

d155 2
a156 1
gld${EMULATION_NAME}_vercheck (lang_input_statement_type *s)
d193 4
a196 4
	     the object we are considering needs a dynamic object
	     FOO.SO.VER2, and VER1 and VER2 are different.  This
	     appears to be a version mismatch, so we tell the caller
	     to try a different version of this library.  */
d208 2
a209 1
gld${EMULATION_NAME}_stat_needed (lang_input_statement_type *s)
d264 3
a266 1
gld${EMULATION_NAME}_try_needed (const char *name, int force)
d313 1
a313 1
		 another file on the search path.  */
d318 5
a322 5
	     library does not use libc at all, we are supposed to skip
	     it the first time around in case we encounter a shared
	     library later on with the same name which does use the
	     version of libc that we want.  This is much too horrible
	     to use on any system other than Linux.  */
d372 1
a372 1
	 we aren't going to do anything with it.  */
d376 8
a383 7
  /* Specify the soname to use.  */
  bfd_elf_set_dt_needed_name (abfd, soname);

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  bfd_elf_set_dyn_lib_class (abfd, DYN_DT_NEEDED);
d396 4
a399 1
gld${EMULATION_NAME}_search_needed (const char *path, const char *name, int force)
d448 2
d451 2
a452 1
gld${EMULATION_NAME}_add_sysroot (const char *path)
d475 1
a475 1
	*p++ = path[i++];
d494 3
d498 3
a500 1
gld${EMULATION_NAME}_check_ld_so_conf (const char *name, int force)
d591 2
a592 1
gld${EMULATION_NAME}_check_needed (lang_input_statement_type *s)
d641 1
a641 1
gld${EMULATION_NAME}_after_open (void)
d646 1
a646 1
  if (link_info.relocatable || !link_info.executable)
d797 2
a798 1
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
d822 1
a822 1
	  if (! (bfd_elf_record_link_assignment
d858 2
a859 1
gld${EMULATION_NAME}_find_statement_assignment (lang_statement_union_type *s)
d886 1
a886 1
gld${EMULATION_NAME}_before_allocation (void)
a890 3
  if (link_info.hash->type == bfd_link_elf_hash_table)
    _bfd_elf_tls_setup (output_bfd, &link_info);

d901 2
a902 2
  if (! (bfd_elf_size_dynamic_sections
	 (output_bfd, command_line.soname, rpath,
a925 1
	bfd_size_type prefix_len;
a927 1
	const char * gnu_warning_prefix = _("warning: ");
d937 2
a938 5
	prefix_len = strlen (gnu_warning_prefix);
	msg = xmalloc ((size_t) (prefix_len + sz + 1));
	strcpy (msg, gnu_warning_prefix);
	if (! bfd_get_section_contents (is->the_bfd, s,	msg + prefix_len,
					(file_ptr) 0, sz))
d941 1
a941 1
	msg[prefix_len + sz] = '\0';
d967 4
a970 2
gld${EMULATION_NAME}_open_dynamic_archive
  (const char *arch, search_dirs_type *search, lang_input_statement_type *entry)
d1046 2
a1047 1
output_rel_find (asection *sec, int isdyn)
a1051 1
  lang_output_section_statement_type *last_alloc = NULL;
d1061 3
d1066 3
a1068 3
	  /* .rel.dyn must come before all other reloc sections, to suit
	     GNU ld.so.  */
	  if (isdyn)
d1070 2
a1071 7

	  /* Don't place after .rel.plt as doing so results in wrong
	     dynamic tags.  */
	  if (strcmp (".plt", lookup->name + 4 + lookrela) == 0)
	    break;

	  if (rela == lookrela || last_rel == NULL)
d1073 1
a1073 2
	  if ((rela == lookrela || last_rel_alloc == NULL)
	      && lookup->bfd_section != NULL
a1076 5

      last = lookup;
      if (lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	last_alloc = lookup;
a1084 3
  if (last_alloc)
    return last_alloc;

d1092 2
a1093 1
output_prev_sec_find (lang_output_section_statement_type *os)
d1125 3
a1127 1
gld${EMULATION_NAME}_place_orphan (lang_input_statement_type *file, asection *s)
d1149 1
a1149 1
  if (! link_info.relocatable
d1183 2
a1184 2
  if (link_info.executable
      && ! link_info.relocatable
d1200 1
a1200 1
  if ((s->flags & SEC_EXCLUDE) != 0 && !link_info.relocatable)
d1226 1
a1226 1
	       || (hold_rel.os = output_rel_find (s, isdyn)) != NULL))
d1281 1
a1281 1
  if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
d1296 1
d1425 1
a1425 1
gld${EMULATION_NAME}_finish (void)
d1427 1
a1427 1
  if (bfd_elf_discard_info (output_bfd, &link_info))
d1450 2
a1451 1
gld${EMULATION_NAME}_get_script (int *isfile)
d1465 1
a1465 1
  if (link_info.relocatable && config.build_constructors)
d1469 1
a1469 1
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
a1476 8
if test -n "$GENERATE_PIE_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.pie && link_info.combreloc) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdc                >> e${EMULATION_NAME}.c
fi
echo '  ; else if (link_info.pie) return'	       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xd                 >> e${EMULATION_NAME}.c
fi
d1500 1
a1500 1
  if (link_info.relocatable && config.build_constructors)
d1502 1
a1502 1
  else if (link_info.relocatable)
a1513 12
if test -n "$GENERATE_PIE_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.pie && link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xdc";
EOF
fi
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.pie)
    return "ldscripts/${EMULATION_NAME}.xd";
EOF
fi
d1556 3
d1560 7
a1566 3
gld${EMULATION_NAME}_add_options
  (int ns, char **shortopts, int nl, struct option **longopts,
   int nrl ATTRIBUTE_UNUSED, struct option **really_longopts ATTRIBUTE_UNUSED)
d1598 3
d1602 2
a1603 1
gld${EMULATION_NAME}_handle_option (int optc)
d1629 1
a1629 2
      link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
      link_info.unresolved_syms_in_shared_libs = RM_GENERATE_ERROR;
d1658 1
a1658 1
	link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
d1666 1
a1666 11
	link_info.nocopyreloc = TRUE;
      else if (strcmp (optarg, "execstack") == 0)
	{
	  link_info.execstack = TRUE;
	  link_info.noexecstack = FALSE;
	}
      else if (strcmp (optarg, "noexecstack") == 0)
	{
	  link_info.noexecstack = TRUE;
	  link_info.execstack = FALSE;
	}
d1689 2
d1692 2
a1693 1
gld${EMULATION_NAME}_list_options (FILE * file)
d1704 1
a1704 2
  fprintf (file, _("  -z defs\t\tReport unresolved symbols in object files.\n"));
  fprintf (file, _("  -z execstack\t\tMark executable as requiring executable stack\n"));
a1714 1
  fprintf (file, _("  -z noexecstack\tMark executable as not requiring executable stack\n"));
d1775 1
a1775 1
  ${LDEMUL_RECOGNIZED_FILE-gld${EMULATION_NAME}_load_symbols},
@


