head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.50
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.47;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.42;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.12.44;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.14;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.14;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.48.07;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.14.00.41;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.49;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.23.21;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* Linker file opening and searching.
   Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002,
   2003, 2004 Free Software Foundation, Inc.

   This file is part of GLD, the Gnu Linker.

   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* ldfile.c:  look after all the file stuff.  */

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "safe-ctype.h"
#include "ld.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldmain.h"
#include <ldgram.h>
#include "ldlex.h"
#include "ldemul.h"
#include "libiberty.h"
#include "filenames.h"

const char * ldfile_input_filename;
bfd_boolean  ldfile_assumed_script = FALSE;
const char * ldfile_output_machine_name = "";
unsigned long ldfile_output_machine;
enum bfd_architecture ldfile_output_architecture;
search_dirs_type * search_head;

#ifndef MPW
#ifdef VMS
char * slash = "";
#else
#if defined (_WIN32) && ! defined (__CYGWIN32__)
char * slash = "\\";
#else
char * slash = "/";
#endif
#endif
#else /* MPW */
/* The MPW path char is a colon.  */
char * slash = ":";
#endif /* MPW */

typedef struct search_arch
{
  char *name;
  struct search_arch *next;
} search_arch_type;

static search_dirs_type **search_tail_ptr = &search_head;
static search_arch_type *search_arch_head;
static search_arch_type **search_arch_tail_ptr = &search_arch_head;

/* Test whether a pathname, after canonicalization, is the same or a
   sub-directory of the sysroot directory.  */

static bfd_boolean
is_sysrooted_pathname (const char *name, bfd_boolean notsame)
{
  char * realname = ld_canon_sysroot ? lrealpath (name) : NULL;
  int len;
  bfd_boolean result;

  if (! realname)
    return FALSE;

  len = strlen (realname);

  if (((! notsame && len == ld_canon_sysroot_len)
       || (len >= ld_canon_sysroot_len
	   && IS_DIR_SEPARATOR (realname[ld_canon_sysroot_len])
	   && (realname[ld_canon_sysroot_len] = '\0') == '\0'))
      && FILENAME_CMP (ld_canon_sysroot, realname) == 0)
    result = TRUE;
  else
    result = FALSE;

  if (realname)
    free (realname);

  return result;
}

/* Adds NAME to the library search path.
   Makes a copy of NAME using xmalloc().  */

void
ldfile_add_library_path (const char *name, bfd_boolean cmdline)
{
  search_dirs_type *new;

  if (!cmdline && config.only_cmd_line_lib_dirs)
    return;

  new = xmalloc (sizeof (search_dirs_type));
  new->next = NULL;
  new->cmdline = cmdline;
  *search_tail_ptr = new;
  search_tail_ptr = &new->next;

  /* If a directory is marked as honoring sysroot, prepend the sysroot path
     now.  */
  if (name[0] == '=')
    {
      new->name = concat (ld_sysroot, name + 1, NULL);
      new->sysrooted = TRUE;
    }
  else
    {
      new->name = xstrdup (name);
      new->sysrooted = is_sysrooted_pathname (name, FALSE);
    }
}

/* Try to open a BFD for a lang_input_statement.  */

bfd_boolean
ldfile_try_open_bfd (const char *attempt,
		     lang_input_statement_type *entry)
{
  entry->the_bfd = bfd_openr (attempt, entry->target);

  if (trace_file_tries)
    {
      if (entry->the_bfd == NULL)
	info_msg (_("attempt to open %s failed\n"), attempt);
      else
	info_msg (_("attempt to open %s succeeded\n"), attempt);
    }

  if (entry->the_bfd == NULL)
    {
      if (bfd_get_error () == bfd_error_invalid_target)
	einfo (_("%F%P: invalid BFD target `%s'\n"), entry->target);
      return FALSE;
    }

  /* If we are searching for this file, see if the architecture is
     compatible with the output file.  If it isn't, keep searching.
     If we can't open the file as an object file, stop the search
     here.  */

  if (entry->search_dirs_flag)
    {
      bfd *check;

      if (bfd_check_format (entry->the_bfd, bfd_archive))
	check = bfd_openr_next_archived_file (entry->the_bfd, NULL);
      else
	check = entry->the_bfd;

      if (check != NULL)
	{
	  if (! bfd_check_format (check, bfd_object))
	    {
	      if (check == entry->the_bfd
		  && bfd_get_error () == bfd_error_file_not_recognized
		  && ! ldemul_unrecognized_file (entry))
		{
		  int token, skip = 0;
		  char *arg, *arg1, *arg2, *arg3;
		  extern FILE *yyin;

		  /* Try to interpret the file as a linker script.  */
		  ldfile_open_command_file (attempt);

		  ldfile_assumed_script = TRUE;
		  parser_input = input_selected;
		  ldlex_both ();
		  token = INPUT_SCRIPT;
		  while (token != 0)
		    {
		      switch (token)
			{
			case OUTPUT_FORMAT:
			  if ((token = yylex ()) != '(')
			    continue;
			  if ((token = yylex ()) != NAME)
			    continue;
			  arg1 = yylval.name;
			  arg2 = NULL;
			  arg3 = NULL;
			  token = yylex ();
			  if (token == ',')
			    {
			      if ((token = yylex ()) != NAME)
				{
				  free (arg1);
				  continue;
				}
			      arg2 = yylval.name;
			      if ((token = yylex ()) != ','
				  || (token = yylex ()) != NAME)
				{
				  free (arg1);
				  free (arg2);
				  continue;
				}
			      arg3 = yylval.name;
			      token = yylex ();
			    }
			  if (token == ')')
			    {
			      switch (command_line.endian)
				{
				default:
				case ENDIAN_UNSET:
				  arg = arg1; break;
				case ENDIAN_BIG:
				  arg = arg2 ? arg2 : arg1; break;
				case ENDIAN_LITTLE:
				  arg = arg3 ? arg3 : arg1; break;
				}
			      if (strcmp (arg, lang_get_output_target ()) != 0)
				skip = 1;
			    }
			  free (arg1);
			  if (arg2) free (arg2);
			  if (arg3) free (arg3);
			  break;
			case NAME:
			case LNAME:
			case VERS_IDENTIFIER:
			case VERS_TAG:
			  free (yylval.name);
			  break;
			case INT:
			  if (yylval.bigint.str)
			    free (yylval.bigint.str);
			  break;
			}
		      token = yylex ();
		    }
		  ldlex_popstate ();
		  ldfile_assumed_script = FALSE;
		  fclose (yyin);
		  yyin = NULL;
		  if (skip)
		    {
		      einfo (_("%P: skipping incompatible %s when searching for %s\n"),
			     attempt, entry->local_sym_name);
		      bfd_close (entry->the_bfd);
		      entry->the_bfd = NULL;
		      return FALSE;
		    }
		}
	      return TRUE;
	    }

	  if ((bfd_arch_get_compatible (check, output_bfd,
					command_line.accept_unknown_input_arch) == NULL)
	      /* XCOFF archives can have 32 and 64 bit objects.  */
	      && ! (bfd_get_flavour (check) == bfd_target_xcoff_flavour
		    && bfd_get_flavour (output_bfd) == bfd_target_xcoff_flavour
		    && bfd_check_format (entry->the_bfd, bfd_archive)))
	    {
	      einfo (_("%P: skipping incompatible %s when searching for %s\n"),
		     attempt, entry->local_sym_name);
	      bfd_close (entry->the_bfd);
	      entry->the_bfd = NULL;
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Search for and open the file specified by ENTRY.  If it is an
   archive, use ARCH, LIB and SUFFIX to modify the file name.  */

bfd_boolean
ldfile_open_file_search (const char *arch,
			 lang_input_statement_type *entry,
			 const char *lib,
			 const char *suffix)
{
  search_dirs_type *search;

  /* If this is not an archive, try to open it in the current
     directory first.  */
  if (! entry->is_archive)
    {
      if (entry->sysrooted && IS_ABSOLUTE_PATH (entry->filename))
	{
	  char *name = concat (ld_sysroot, entry->filename,
			       (const char *) NULL);
	  if (ldfile_try_open_bfd (name, entry))
	    {
	      entry->filename = name;
	      return TRUE;
	    }
	  free (name);
	}
      else if (ldfile_try_open_bfd (entry->filename, entry))
	{
	  entry->sysrooted = IS_ABSOLUTE_PATH (entry->filename)
	    && is_sysrooted_pathname (entry->filename, TRUE);
	  return TRUE;
	}

      if (IS_ABSOLUTE_PATH (entry->filename))
	return FALSE;
    }

  for (search = search_head; search != NULL; search = search->next)
    {
      char *string;

      if (entry->dynamic && ! link_info.relocatable)
	{
	  if (ldemul_open_dynamic_archive (arch, search, entry))
	    {
	      entry->sysrooted = search->sysrooted;
	      return TRUE;
	    }
	}

      string = xmalloc (strlen (search->name)
			+ strlen (slash)
			+ strlen (lib)
			+ strlen (entry->filename)
			+ strlen (arch)
			+ strlen (suffix)
			+ 1);

      if (entry->is_archive)
	sprintf (string, "%s%s%s%s%s%s", search->name, slash,
		 lib, entry->filename, arch, suffix);
      else
	sprintf (string, "%s%s%s", search->name, slash, entry->filename);

      if (ldfile_try_open_bfd (string, entry))
	{
	  entry->filename = string;
	  entry->sysrooted = search->sysrooted;
	  return TRUE;
	}

      free (string);
    }

  return FALSE;
}

/* Open the input file specified by ENTRY.  */

void
ldfile_open_file (lang_input_statement_type *entry)
{
  if (entry->the_bfd != NULL)
    return;

  if (! entry->search_dirs_flag)
    {
      if (ldfile_try_open_bfd (entry->filename, entry))
	return;
      if (strcmp (entry->filename, entry->local_sym_name) != 0)
	einfo (_("%F%P: %s (%s): No such file: %E\n"),
	       entry->filename, entry->local_sym_name);
      else
	einfo (_("%F%P: %s: No such file: %E\n"), entry->local_sym_name);
    }
  else
    {
      search_arch_type *arch;
      bfd_boolean found = FALSE;

      /* Try to open <filename><suffix> or lib<filename><suffix>.a */
      for (arch = search_arch_head; arch != NULL; arch = arch->next)
	{
	  found = ldfile_open_file_search (arch->name, entry, "lib", ".a");
	  if (found)
	    break;
#ifdef VMS
	  found = ldfile_open_file_search (arch->name, entry, ":lib", ".a");
	  if (found)
	    break;
#endif
	  found = ldemul_find_potential_libraries (arch->name, entry);
	  if (found)
	    break;
	}

      /* If we have found the file, we don't need to search directories
	 again.  */
      if (found)
	entry->search_dirs_flag = FALSE;
      else if (entry->sysrooted
	       && ld_sysroot
	       && IS_ABSOLUTE_PATH (entry->local_sym_name))
	einfo (_("%F%P: cannot find %s inside %s\n"),
	       entry->local_sym_name, ld_sysroot);
      else
	einfo (_("%F%P: cannot find %s\n"), entry->local_sym_name);
    }
}

/* Try to open NAME; if that fails, try NAME with EXTEN appended to it.  */

static FILE *
try_open (const char *name, const char *exten)
{
  FILE *result;
  char buff[1000];

  result = fopen (name, "r");

  if (trace_file_tries)
    {
      if (result == NULL)
	info_msg (_("cannot find script file %s\n"), name);
      else
	info_msg (_("opened script file %s\n"), name);
    }

  if (result != NULL)
    return result;

  if (*exten)
    {
      sprintf (buff, "%s%s", name, exten);
      result = fopen (buff, "r");

      if (trace_file_tries)
	{
	  if (result == NULL)
	    info_msg (_("cannot find script file %s\n"), buff);
	  else
	    info_msg (_("opened script file %s\n"), buff);
	}
    }

  return result;
}

/* Try to open NAME; if that fails, look for it in any directories
   specified with -L, without and with EXTEND appended.  */

FILE *
ldfile_find_command_file (const char *name, const char *extend)
{
  search_dirs_type *search;
  FILE *result;
  char buffer[1000];

  /* First try raw name.  */
  result = try_open (name, "");
  if (result == NULL)
    {
      /* Try now prefixes.  */
      for (search = search_head; search != NULL; search = search->next)
	{
	  sprintf (buffer, "%s%s%s", search->name, slash, name);

	  result = try_open (buffer, extend);
	  if (result)
	    break;
	}
    }

  return result;
}

void
ldfile_open_command_file (const char *name)
{
  FILE *ldlex_input_stack;
  ldlex_input_stack = ldfile_find_command_file (name, "");

  if (ldlex_input_stack == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      einfo (_("%P%F: cannot open linker script file %s: %E\n"), name);
    }

  lex_push_file (ldlex_input_stack, name);

  ldfile_input_filename = name;
  lineno = 1;

  saved_script_handle = ldlex_input_stack;
}

#ifdef GNU960
static char *
gnu960_map_archname (char *name)
{
  struct tabentry { char *cmd_switch; char *arch; };
  static struct tabentry arch_tab[] =
  {
	"",   "",
	"KA", "ka",
	"KB", "kb",
	"KC", "mc",	/* Synonym for MC */
	"MC", "mc",
	"CA", "ca",
	"SA", "ka",	/* Functionally equivalent to KA */
	"SB", "kb",	/* Functionally equivalent to KB */
	NULL, ""
  };
  struct tabentry *tp;

  for (tp = arch_tab; tp->cmd_switch != NULL; tp++)
    {
      if (! strcmp (name,tp->cmd_switch))
	break;
    }

  if (tp->cmd_switch == NULL)
    einfo (_("%P%F: unknown architecture: %s\n"), name);

  return tp->arch;
}

void
ldfile_add_arch (char *name)
{
  search_arch_type *new = xmalloc (sizeof (search_arch_type));

  if (*name != '\0')
    {
      if (ldfile_output_machine_name[0] != '\0')
	{
	  einfo (_("%P%F: target architecture respecified\n"));
	  return;
	}

      ldfile_output_machine_name = name;
    }

  new->next = NULL;
  new->name = gnu960_map_archname (name);
  *search_arch_tail_ptr = new;
  search_arch_tail_ptr = &new->next;
}

#else /* not GNU960 */

void
ldfile_add_arch (const char *in_name)
{
  char *name = xstrdup (in_name);
  search_arch_type *new = xmalloc (sizeof (search_arch_type));

  ldfile_output_machine_name = in_name;

  new->name = name;
  new->next = NULL;
  while (*name)
    {
      *name = TOLOWER (*name);
      name++;
    }
  *search_arch_tail_ptr = new;
  search_arch_tail_ptr = &new->next;

}
#endif

/* Set the output architecture.  */

void
ldfile_set_output_arch (const char *string, enum bfd_architecture defarch)
{
  const bfd_arch_info_type *arch = bfd_scan_arch (string);

  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else if (defarch != bfd_arch_unknown)
    ldfile_output_architecture = defarch;
  else
    einfo (_("%P%F: cannot represent machine `%s'\n"), string);
}
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a71 5
static FILE *try_open
  PARAMS ((const char *, const char *));
static bfd_boolean is_sysrooted_pathname
  PARAMS ((const char *, bfd_boolean));

d76 1
a76 3
is_sysrooted_pathname (name, notsame)
     const char *name;
     bfd_boolean notsame;
d84 1
a84 1
  
d106 1
a106 3
ldfile_add_library_path (name, cmdline)
     const char *name;
     bfd_boolean cmdline;
d113 1
a113 1
  new = (search_dirs_type *) xmalloc (sizeof (search_dirs_type));
d136 2
a137 3
ldfile_try_open_bfd (attempt, entry)
     const char *attempt;
     lang_input_statement_type *entry;
d249 1
a249 1
		        }
d291 4
a294 5
ldfile_open_file_search (arch, entry, lib, suffix)
     const char *arch;
     lang_input_statement_type *entry;
     const char *lib;
     const char *suffix;
d324 1
a324 3
  for (search = search_head;
       search != (search_dirs_type *) NULL;
       search = search->next)
d328 1
a328 1
      if (entry->dynamic && ! link_info.relocateable)
d337 7
a343 7
      string = (char *) xmalloc (strlen (search->name)
				 + strlen (slash)
				 + strlen (lib)
				 + strlen (entry->filename)
				 + strlen (arch)
				 + strlen (suffix)
				 + 1);
d367 1
a367 2
ldfile_open_file (entry)
     lang_input_statement_type *entry;
d377 1
a377 1
	einfo (_("%F%P: cannot open %s for %s: %E\n"),
d380 1
a380 1
	einfo (_("%F%P: cannot open %s: %E\n"), entry->local_sym_name);
d388 1
a388 3
      for (arch = search_arch_head;
	   arch != (search_arch_type *) NULL;
	   arch = arch->next)
d420 1
a420 3
try_open (name, exten)
     const char *name;
     const char *exten;
d459 1
a459 3
ldfile_find_command_file (name, extend)
     const char *name;
     const char *extend;
d467 1
a467 1
  if (result == (FILE *) NULL)
d470 1
a470 3
      for (search = search_head;
	   search != (search_dirs_type *) NULL;
	   search = search->next)
d484 1
a484 2
ldfile_open_command_file (name)
     const char *name;
d489 1
a489 1
  if (ldlex_input_stack == (FILE *) NULL)
d505 1
a505 2
gnu960_map_archname (name)
     char *name;
d535 1
a535 2
ldfile_add_arch (name)
     char *name;
d537 1
a537 2
  search_arch_type *new =
    (search_arch_type *) xmalloc ((bfd_size_type) (sizeof (search_arch_type)));
d550 1
a550 1
  new->next = (search_arch_type *) NULL;
d559 1
a559 2
ldfile_add_arch (in_name)
     const char *in_name;
d562 1
a562 2
  search_arch_type *new =
    (search_arch_type *) xmalloc (sizeof (search_arch_type));
d567 1
a567 1
  new->next = (search_arch_type *) NULL;
d582 1
a582 2
ldfile_set_output_arch (string)
     const char *string;
d592 2
d595 1
a595 3
    {
      einfo (_("%P%F: cannot represent machine `%s'\n"), string);
    }
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001
d5 1
a5 1
This file is part of GLD, the Gnu Linker.
d7 14
a20 14
GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d27 1
d34 1
a34 1
#include "ldgram.h"
d38 1
d40 3
a42 5
#include <ctype.h>

const char *ldfile_input_filename;
boolean ldfile_assumed_script = false;
const char *ldfile_output_machine_name = "";
d45 1
a45 1
search_dirs_type *search_head;
d49 1
a49 1
char *slash = "";
d52 1
a52 1
char *slash = "\\";
d54 1
a54 1
char *slash = "/";
d59 1
a59 1
char *slash = ":";
d62 2
a63 5
/* LOCAL */

static search_dirs_type **search_tail_ptr = &search_head;

typedef struct search_arch {
d68 1
d72 39
a110 1
static FILE *try_open PARAMS ((const char *name, const char *exten));
d115 1
a115 1
     boolean cmdline;
d119 3
a123 1
  new->name = name;
d127 13
d144 1
a144 1
boolean
d163 1
a163 1
      return false;
d183 101
a283 2
	    return true;
	  if (bfd_arch_get_compatible (check, output_bfd) == NULL)
d289 1
a289 1
	      return false;
d294 1
a294 1
  return true;
d300 1
a300 1
boolean
d313 20
a332 2
      if (ldfile_try_open_bfd (entry->filename, entry))
	return true;
d344 4
a347 1
	    return true;
a360 8
      else if (entry->filename[0] == '/' || entry->filename[0] == '.'
#if defined (__MSDOS__) || defined (_WIN32)
	       || entry->filename[0] == '\\'
	       || (isalpha (entry->filename[0])
	           && entry->filename[1] == ':')
#endif
	  )
	strcpy (string, entry->filename);
d367 2
a368 1
	  return true;
d374 1
a374 1
  return false;
d399 1
a399 1
      boolean found = false;
d422 6
a427 1
	entry->search_dirs_flag = false;
d474 1
a474 1
   specified with -L, without and with EXTEND apppended.  */
d522 2
a523 1
  had_script = true;
d586 1
a586 1
     CONST char *in_name;
d598 1
a598 2
      if (isupper ((unsigned char) *name))
	*name = tolower ((unsigned char) *name);
d611 1
a611 1
     CONST char *string;
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 98, 99, 2000
d22 1
a22 6
/*
 ldfile.c

 look after all the file stuff

 */
d36 1
d58 1
a58 1
/* The MPW path char is a colon. */
d66 2
a67 3
typedef struct search_arch 
{
  char *name; 
d73 1
a73 1
 
d135 1
a135 1
	      einfo (_("%P: skipping incompatible %s when searching for %s"),
d168 2
a169 2
       search != (search_dirs_type *)NULL;
       search = search->next) 
d192 2
a193 2
	       || entry->filename[0] == '\\' 
	       || (isalpha (entry->filename[0]) 
d230 1
a230 1
	einfo(_("%F%P: cannot open %s: %E\n"), entry->local_sym_name);
d235 1
d242 3
a244 2
	  if (ldfile_open_file_search (arch->name, entry, "lib", ".a"))
	    return;
d246 3
a248 2
	  if (ldfile_open_file_search (arch->name, entry, ":lib", ".a"))
	    return;
d250 3
a252 2
	  if (ldemul_find_potential_libraries (arch->name, entry))
	    return;
d254 7
a260 1
      einfo (_("%F%P: cannot find %s\n"), entry->local_sym_name);
d275 1
d291 1
d316 15
a330 10
  /* First try raw name */
  result = try_open(name,"");
  if (result == (FILE *)NULL) {
    /* Try now prefixes */
    for (search = search_head;
	 search != (search_dirs_type *)NULL;
	 search = search->next) {
      sprintf(buffer,"%s%s%s", search->name, slash, name);
      result = try_open(buffer, extend);
      if (result)break;
d332 1
a332 1
  }
d341 9
a349 1
  ldlex_input_stack = ldfile_find_command_file(name, "");
a350 6
  if (ldlex_input_stack == (FILE *)NULL) {
    bfd_set_error (bfd_error_system_call);
    einfo(_("%P%F: cannot open linker script file %s: %E\n"),name);
  }
  lex_push_file(ldlex_input_stack, name);
  
a355 4




d357 3
a359 4
static
char *
gnu960_map_archname( name )
char *name;
d362 2
a363 1
  static struct tabentry arch_tab[] = {
a374 1
  
d376 4
a379 3
  for ( tp = arch_tab; tp->cmd_switch != NULL; tp++ ){
    if ( !strcmp(name,tp->cmd_switch) ){
      break;
a380 1
  }
d382 3
a384 3
  if ( tp->cmd_switch == NULL ){
    einfo(_("%P%F: unknown architecture: %s\n"),name);
  }
a387 2


d389 2
a390 2
ldfile_add_arch(name)
char *name;
d393 1
a393 1
    (search_arch_type *)xmalloc((bfd_size_type)(sizeof(search_arch_type)));
d395 7
d403 1
a403 4
  if (*name != '\0') {
    if (ldfile_output_machine_name[0] != '\0') {
      einfo(_("%P%F: target architecture respecified\n"));
      return;
a404 2
    ldfile_output_machine_name = name;
  }
d406 2
a407 2
  new->next = (search_arch_type*)NULL;
  new->name = gnu960_map_archname( name );
a409 1

d412 1
a412 2
#else	/* not GNU960 */

d416 1
a416 1
     CONST char * in_name;
d418 1
a418 1
  char *name = buystring(in_name);
d425 1
a425 1
  new->next = (search_arch_type*)NULL;
d438 2
a439 1
/* Set the output architecture */
d444 1
a444 1
  const bfd_arch_info_type *arch = bfd_scan_arch(string);
d446 10
a455 8
  if (arch) {
    ldfile_output_architecture = arch->arch;
    ldfile_output_machine = arch->mach;
    ldfile_output_machine_name = arch->printable_name;
  }
  else {
    einfo(_("%P%F: cannot represent machine `%s'\n"), string);
  }
@


1.1
log
@Initial revision
@
text
@d1 3
a3 1
/* Copyright (C) 1991, 92, 93, 94 Free Software Foundation, Inc.
d9 1
a9 1
the Free Software Foundation; either version 1, or (at your option)
d18 3
a20 2
along with GLD; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d55 3
d60 1
a78 3
static boolean ldfile_open_file_search
  PARAMS ((const char *arch, lang_input_statement_type *,
	   const char *lib, const char *suffix));
d106 6
a111 2
    info_msg ("attempt to open %s %s\n", attempt,
	      entry->the_bfd == NULL ? "failed" : "succeeded");
d113 1
a113 3
  if (entry->the_bfd != NULL)
    return true;
  else
d116 1
a116 1
	einfo ("%F%P: invalid BFD target `%s'\n", entry->target);
d119 31
d155 1
a155 1
static boolean
d195 7
a201 1
      else if (entry->filename[0] == '/' || entry->filename[0] == '.')
d231 5
d252 2
d255 1
a256 2

  einfo("%F%P: cannot open %s: %E\n", entry->local_sym_name);
d273 1
a273 1
	info_msg ("cannot find script file ");
d275 1
a275 2
	info_msg ("opened script file ");
      info_msg ("%s\n",name);
d288 1
a288 1
	    info_msg ("cannot find script file ");
d290 1
a290 2
	    info_msg ("opened script file ");
	  info_msg ("%s\n", buff);
d316 1
a316 1
      sprintf(buffer,"%s/%s", search->name, name);
d333 1
a333 1
    einfo("%P%F: cannot open linker script file %s: %E\n",name);
d374 1
a374 1
    einfo("%P%F: unknown architecture: %s\n",name);
d391 1
a391 1
      einfo("%P%F: target architecture respecified\n");
d419 6
a424 4
  while (*name) {
    if (isupper(*name)) *name = tolower(*name);
    name++;
  }
d444 1
a444 1
    einfo("%P%F: cannot represent machine `%s'\n", string);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 1
a1 3
/* Linker file opening and searching.
   Copyright (C) 1991, 92, 93, 94, 95, 98, 99, 2000
   Free Software Foundation, Inc.
d7 1
a7 1
the Free Software Foundation; either version 2, or (at your option)
d16 2
a17 3
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
a51 3
#if defined (_WIN32) && ! defined (__CYGWIN32__)
char *slash = "\\";
#else
a53 1
#endif
d72 3
d102 2
a103 6
    {
      if (entry->the_bfd == NULL)
	info_msg (_("attempt to open %s failed\n"), attempt);
      else
	info_msg (_("attempt to open %s succeeded\n"), attempt);
    }
d105 3
a107 1
  if (entry->the_bfd == NULL)
d110 1
a110 1
	einfo (_("%F%P: invalid BFD target `%s'\n"), entry->target);
a112 31

  /* If we are searching for this file, see if the architecture is
     compatible with the output file.  If it isn't, keep searching.
     If we can't open the file as an object file, stop the search
     here.  */

  if (entry->search_dirs_flag)
    {
      bfd *check;

      if (bfd_check_format (entry->the_bfd, bfd_archive))
	check = bfd_openr_next_archived_file (entry->the_bfd, NULL);
      else
	check = entry->the_bfd;

      if (check != NULL)
	{
	  if (! bfd_check_format (check, bfd_object))
	    return true;
	  if (bfd_arch_get_compatible (check, output_bfd) == NULL)
	    {
	      einfo (_("%P: skipping incompatible %s when searching for %s"),
		     attempt, entry->local_sym_name);
	      bfd_close (entry->the_bfd);
	      entry->the_bfd = NULL;
	      return false;
	    }
	}
    }

  return true;
d118 1
a118 1
boolean
d158 1
a158 7
      else if (entry->filename[0] == '/' || entry->filename[0] == '.'
#if defined (__MSDOS__) || defined (_WIN32)
	       || entry->filename[0] == '\\' 
	       || (isalpha (entry->filename[0]) 
	           && entry->filename[1] == ':')
#endif
	  )
a187 5
      if (strcmp (entry->filename, entry->local_sym_name) != 0)
	einfo (_("%F%P: cannot open %s for %s: %E\n"),
	       entry->filename, entry->local_sym_name);
      else
	einfo(_("%F%P: cannot open %s: %E\n"), entry->local_sym_name);
a203 2
	  if (ldemul_find_potential_libraries (arch->name, entry))
	    return;
a204 1
      einfo (_("%F%P: cannot find %s\n"), entry->local_sym_name);
d206 2
d224 1
a224 1
	info_msg (_("cannot find script file %s\n"), name);
d226 2
a227 1
	info_msg (_("opened script file %s\n"), name);
d240 1
a240 1
	    info_msg (_("cannot find script file %s\n"), buff);
d242 2
a243 1
	    info_msg (_("opened script file %s\n"), buff);
d269 1
a269 1
      sprintf(buffer,"%s%s%s", search->name, slash, name);
d286 1
a286 1
    einfo(_("%P%F: cannot open linker script file %s: %E\n"),name);
d327 1
a327 1
    einfo(_("%P%F: unknown architecture: %s\n"),name);
d344 1
a344 1
      einfo(_("%P%F: target architecture respecified\n"));
d372 4
a375 6
  while (*name)
    {
      if (isupper ((unsigned char) *name))
	*name = tolower ((unsigned char) *name);
      name++;
    }
d395 1
a395 1
    einfo(_("%P%F: cannot represent machine `%s'\n"), string);
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001
d22 6
a27 1
/* ldfile.c:  look after all the file stuff.  */
a40 1
#include "libiberty.h"
d62 1
a62 1
/* The MPW path char is a colon.  */
d70 3
a72 2
typedef struct search_arch {
  char *name;
d78 1
a78 1

d140 1
a140 1
	      einfo (_("%P: skipping incompatible %s when searching for %s\n"),
d173 2
a174 2
       search != (search_dirs_type *) NULL;
       search = search->next)
d197 2
a198 2
	       || entry->filename[0] == '\\'
	       || (isalpha (entry->filename[0])
d235 1
a235 1
	einfo (_("%F%P: cannot open %s: %E\n"), entry->local_sym_name);
a239 1
      boolean found = false;
d246 2
a247 3
	  found = ldfile_open_file_search (arch->name, entry, "lib", ".a");
	  if (found)
	    break;
d249 2
a250 3
	  found = ldfile_open_file_search (arch->name, entry, ":lib", ".a");
	  if (found)
	    break;
d252 2
a253 3
	  found = ldemul_find_potential_libraries (arch->name, entry);
	  if (found)
	    break;
d255 1
a255 7

      /* If we have found the file, we don't need to search directories
	 again.  */
      if (found)
	entry->search_dirs_flag = false;
      else
	einfo (_("%F%P: cannot find %s\n"), entry->local_sym_name);
a269 1

a284 1

d309 10
a318 15
  /* First try raw name.  */
  result = try_open (name, "");
  if (result == (FILE *) NULL)
    {
      /* Try now prefixes.  */
      for (search = search_head;
	   search != (search_dirs_type *) NULL;
	   search = search->next)
	{
	  sprintf (buffer, "%s%s%s", search->name, slash, name);

	  result = try_open (buffer, extend);
	  if (result)
	    break;
	}
d320 1
a320 1

d329 1
a329 9
  ldlex_input_stack = ldfile_find_command_file (name, "");

  if (ldlex_input_stack == (FILE *) NULL)
    {
      bfd_set_error (bfd_error_system_call);
      einfo (_("%P%F: cannot open linker script file %s: %E\n"), name);
    }

  lex_push_file (ldlex_input_stack, name);
d331 6
d342 4
d347 4
a350 3
static char *
gnu960_map_archname (name)
     char *name;
d353 1
a353 2
  static struct tabentry arch_tab[] =
  {
d365 1
d367 3
a369 4
  for (tp = arch_tab; tp->cmd_switch != NULL; tp++)
    {
      if (! strcmp (name,tp->cmd_switch))
	break;
d371 1
d373 3
a375 3
  if (tp->cmd_switch == NULL)
    einfo (_("%P%F: unknown architecture: %s\n"), name);

d379 2
d382 2
a383 2
ldfile_add_arch (name)
     char *name;
d386 1
a386 1
    (search_arch_type *) xmalloc ((bfd_size_type) (sizeof (search_arch_type)));
a387 7
  if (*name != '\0')
    {
      if (ldfile_output_machine_name[0] != '\0')
	{
	  einfo (_("%P%F: target architecture respecified\n"));
	  return;
	}
d389 4
a392 1
      ldfile_output_machine_name = name;
d394 2
d397 2
a398 2
  new->next = (search_arch_type *) NULL;
  new->name = gnu960_map_archname (name);
d401 1
d404 2
a405 1
#else /* not GNU960 */
d409 1
a409 1
     CONST char *in_name;
d411 1
a411 1
  char *name = xstrdup (in_name);
d418 1
a418 1
  new->next = (search_arch_type *) NULL;
d431 1
a431 2
/* Set the output architecture.  */

d436 1
a436 1
  const bfd_arch_info_type *arch = bfd_scan_arch (string);
d438 8
a445 10
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    {
      einfo (_("%P%F: cannot represent machine `%s'\n"), string);
    }
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003
d5 1
a5 1
   This file is part of GLD, the Gnu Linker.
d7 14
a20 14
   GLD is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GLD is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a26 1
#include "safe-ctype.h"
d33 1
a33 1
#include <ldgram.h>
a36 1
#include "filenames.h"
d38 5
a42 3
const char * ldfile_input_filename;
bfd_boolean  ldfile_assumed_script = FALSE;
const char * ldfile_output_machine_name = "";
d45 1
a45 1
search_dirs_type * search_head;
d49 1
a49 1
char * slash = "";
d52 1
a52 1
char * slash = "\\";
d54 1
a54 1
char * slash = "/";
d59 1
a59 1
char * slash = ":";
d62 5
a66 2
typedef struct search_arch
{
a70 1
static search_dirs_type **search_tail_ptr = &search_head;
d74 1
a74 39
static FILE *try_open
  PARAMS ((const char *, const char *));
static bfd_boolean is_sysrooted_pathname
  PARAMS ((const char *, bfd_boolean));

/* Test whether a pathname, after canonicalization, is the same or a
   sub-directory of the sysroot directory.  */

static bfd_boolean
is_sysrooted_pathname (name, notsame)
     const char *name;
     bfd_boolean notsame;
{
  char * realname = ld_canon_sysroot ? lrealpath (name) : NULL;
  int len;
  bfd_boolean result;

  if (! realname)
    return FALSE;
  
  len = strlen (realname);

  if (((! notsame && len == ld_canon_sysroot_len)
       || (len >= ld_canon_sysroot_len
	   && IS_DIR_SEPARATOR (realname[ld_canon_sysroot_len])
	   && (realname[ld_canon_sysroot_len] = '\0') == '\0'))
      && FILENAME_CMP (ld_canon_sysroot, realname) == 0)
    result = TRUE;
  else
    result = FALSE;

  if (realname)
    free (realname);

  return result;
}

/* Adds NAME to the library search path.
   Makes a copy of NAME using xmalloc().  */
d79 1
a79 1
     bfd_boolean cmdline;
a82 3
  if (!cmdline && config.only_cmd_line_lib_dirs)
    return;

d85 1
a88 13

  /* If a directory is marked as honoring sysroot, prepend the sysroot path
     now.  */
  if (name[0] == '=')
    {
      new->name = concat (ld_sysroot, name + 1, NULL);
      new->sysrooted = TRUE;
    }
  else
    {
      new->name = xstrdup (name);
      new->sysrooted = is_sysrooted_pathname (name, FALSE);
    }
d93 1
a93 1
bfd_boolean
d112 1
a112 1
      return FALSE;
d132 2
a133 101
	    {
	      if (check == entry->the_bfd
		  && bfd_get_error () == bfd_error_file_not_recognized
		  && ! ldemul_unrecognized_file (entry))
		{
		  int token, skip = 0;
		  char *arg, *arg1, *arg2, *arg3;
		  extern FILE *yyin;

		  /* Try to interpret the file as a linker script.  */
		  ldfile_open_command_file (attempt);

		  ldfile_assumed_script = TRUE;
		  parser_input = input_selected;
		  ldlex_both ();
		  token = INPUT_SCRIPT;
		  while (token != 0)
		    {
		      switch (token)
			{
			case OUTPUT_FORMAT:
			  if ((token = yylex ()) != '(')
			    continue;
			  if ((token = yylex ()) != NAME)
			    continue;
			  arg1 = yylval.name;
			  arg2 = NULL;
			  arg3 = NULL;
			  token = yylex ();
			  if (token == ',')
			    {
			      if ((token = yylex ()) != NAME)
				{
				  free (arg1);
				  continue;
				}
			      arg2 = yylval.name;
			      if ((token = yylex ()) != ','
				  || (token = yylex ()) != NAME)
				{
				  free (arg1);
				  free (arg2);
				  continue;
				}
			      arg3 = yylval.name;
			      token = yylex ();
			    }
			  if (token == ')')
			    {
			      switch (command_line.endian)
				{
				default:
				case ENDIAN_UNSET:
				  arg = arg1; break;
				case ENDIAN_BIG:
				  arg = arg2 ? arg2 : arg1; break;
				case ENDIAN_LITTLE:
				  arg = arg3 ? arg3 : arg1; break;
				}
			      if (strcmp (arg, lang_get_output_target ()) != 0)
				skip = 1;
			    }
			  free (arg1);
			  if (arg2) free (arg2);
			  if (arg3) free (arg3);
			  break;
			case NAME:
			case LNAME:
			case VERS_IDENTIFIER:
			case VERS_TAG:
			  free (yylval.name);
			  break;
			case INT:
			  if (yylval.bigint.str)
			    free (yylval.bigint.str);
			  break;
		        }
		      token = yylex ();
		    }
		  ldlex_popstate ();
		  ldfile_assumed_script = FALSE;
		  fclose (yyin);
		  yyin = NULL;
		  if (skip)
		    {
		      einfo (_("%P: skipping incompatible %s when searching for %s\n"),
			     attempt, entry->local_sym_name);
		      bfd_close (entry->the_bfd);
		      entry->the_bfd = NULL;
		      return FALSE;
		    }
		}
	      return TRUE;
	    }

	  if ((bfd_arch_get_compatible (check, output_bfd,
					command_line.accept_unknown_input_arch) == NULL)
	      /* XCOFF archives can have 32 and 64 bit objects.  */
	      && ! (bfd_get_flavour (check) == bfd_target_xcoff_flavour
		    && bfd_get_flavour (output_bfd) == bfd_target_xcoff_flavour
		    && bfd_check_format (entry->the_bfd, bfd_archive)))
d139 1
a139 1
	      return FALSE;
d144 1
a144 1
  return TRUE;
d150 1
a150 1
bfd_boolean
d163 2
a164 20
      if (entry->sysrooted && IS_ABSOLUTE_PATH (entry->filename))
	{
	  char *name = concat (ld_sysroot, entry->filename,
			       (const char *) NULL);
	  if (ldfile_try_open_bfd (name, entry))
	    {
	      entry->filename = name;
	      return TRUE;
	    }
	  free (name);
	}
      else if (ldfile_try_open_bfd (entry->filename, entry))
	{
	  entry->sysrooted = IS_ABSOLUTE_PATH (entry->filename)
	    && is_sysrooted_pathname (entry->filename, TRUE);
	  return TRUE;
	}

      if (IS_ABSOLUTE_PATH (entry->filename))
	return FALSE;
d176 1
a176 4
	    {
	      entry->sysrooted = search->sysrooted;
	      return TRUE;
	    }
d190 8
d204 1
a204 2
	  entry->sysrooted = search->sysrooted;
	  return TRUE;
d210 1
a210 1
  return FALSE;
d235 1
a235 1
      bfd_boolean found = FALSE;
d258 1
a258 6
	entry->search_dirs_flag = FALSE;
      else if (entry->sysrooted
	       && ld_sysroot
	       && IS_ABSOLUTE_PATH (entry->local_sym_name))
	einfo (_("%F%P: cannot find %s inside %s\n"),
	       entry->local_sym_name, ld_sysroot);
d305 1
a305 1
   specified with -L, without and with EXTEND appended.  */
d353 1
a353 2

  saved_script_handle = ldlex_input_stack;
d416 1
a416 1
     const char *in_name;
d428 2
a429 1
      *name = TOLOWER (*name);
d442 1
a442 1
     const char *string;
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002,
   2003, 2004 Free Software Foundation, Inc.
d72 5
d81 3
a83 1
is_sysrooted_pathname (const char *name, bfd_boolean notsame)
d91 1
a91 1

d113 3
a115 1
ldfile_add_library_path (const char *name, bfd_boolean cmdline)
d122 1
a122 1
  new = xmalloc (sizeof (search_dirs_type));
d145 3
a147 2
ldfile_try_open_bfd (const char *attempt,
		     lang_input_statement_type *entry)
d259 1
a259 1
			}
d301 5
a305 4
ldfile_open_file_search (const char *arch,
			 lang_input_statement_type *entry,
			 const char *lib,
			 const char *suffix)
d335 3
a337 1
  for (search = search_head; search != NULL; search = search->next)
d341 1
a341 1
      if (entry->dynamic && ! link_info.relocatable)
d350 7
a356 7
      string = xmalloc (strlen (search->name)
			+ strlen (slash)
			+ strlen (lib)
			+ strlen (entry->filename)
			+ strlen (arch)
			+ strlen (suffix)
			+ 1);
d380 2
a381 1
ldfile_open_file (lang_input_statement_type *entry)
d391 1
a391 1
	einfo (_("%F%P: %s (%s): No such file: %E\n"),
d394 1
a394 1
	einfo (_("%F%P: %s: No such file: %E\n"), entry->local_sym_name);
d402 3
a404 1
      for (arch = search_arch_head; arch != NULL; arch = arch->next)
d436 3
a438 1
try_open (const char *name, const char *exten)
d477 3
a479 1
ldfile_find_command_file (const char *name, const char *extend)
d487 1
a487 1
  if (result == NULL)
d490 3
a492 1
      for (search = search_head; search != NULL; search = search->next)
d506 2
a507 1
ldfile_open_command_file (const char *name)
d512 1
a512 1
  if (ldlex_input_stack == NULL)
d528 2
a529 1
gnu960_map_archname (char *name)
d559 2
a560 1
ldfile_add_arch (char *name)
d562 2
a563 1
  search_arch_type *new = xmalloc (sizeof (search_arch_type));
d576 1
a576 1
  new->next = NULL;
d585 2
a586 1
ldfile_add_arch (const char *in_name)
d589 2
a590 1
  search_arch_type *new = xmalloc (sizeof (search_arch_type));
d595 1
a595 1
  new->next = NULL;
d610 2
a611 1
ldfile_set_output_arch (const char *string, enum bfd_architecture defarch)
a620 2
  else if (defarch != bfd_arch_unknown)
    ldfile_output_architecture = defarch;
d622 3
a624 1
    einfo (_("%P%F: cannot represent machine `%s'\n"), string);
@


