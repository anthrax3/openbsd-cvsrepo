head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.48;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.50;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.43;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.12.46;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.09.41;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.54.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.09.18;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.09.18;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.35.41;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.35.14;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.28.36;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.48.11;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.14.01.31;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.50;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.23.22;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* mri.c -- handle MRI style linker scripts
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2002,
   2003, 2004 Free Software Foundation, Inc.

This file is part of GLD, the Gnu Linker.

GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.

   This bit does the tree decoration when MRI style link scripts
   are parsed.

   Contributed by Steve Chamberlain <sac@@cygnus.com>.  */

#include "bfd.h"
#include "sysdep.h"
#include "ld.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldmisc.h"
#include "mri.h"
#include <ldgram.h>
#include "libiberty.h"

struct section_name_struct {
  struct section_name_struct *next;
  const char *name;
  const char *alias;
  etree_type *vma;
  etree_type *align;
  etree_type *subalign;
  int ok_to_load;
};

unsigned int symbol_truncate = 10000;
struct section_name_struct *order;
struct section_name_struct *only_load;
struct section_name_struct *address;
struct section_name_struct *alias;

struct section_name_struct *alignment;
struct section_name_struct *subalignment;

static struct section_name_struct **
lookup (const char *name, struct section_name_struct **list)
{
  struct section_name_struct **ptr = list;

  while (*ptr)
    {
      if (strcmp (name, (*ptr)->name) == 0)
	/* If this is a match, delete it, we only keep the last instance
	   of any name.  */
	*ptr = (*ptr)->next;
      else
	ptr = &((*ptr)->next);
    }

  *ptr = xmalloc (sizeof (struct section_name_struct));
  return ptr;
}

static void
mri_add_to_list (struct section_name_struct **list,
		 const char *name,
		 etree_type *vma,
		 const char *zalias,
		 etree_type *align,
		 etree_type *subalign)
{
  struct section_name_struct **ptr = lookup (name, list);

  (*ptr)->name = name;
  (*ptr)->vma = vma;
  (*ptr)->next = NULL;
  (*ptr)->ok_to_load = 0;
  (*ptr)->alias = zalias;
  (*ptr)->align = align;
  (*ptr)->subalign = subalign;
}

void
mri_output_section (const char *name, etree_type *vma)
{
  mri_add_to_list (&address, name, vma, 0, 0, 0);
}

/* If any ABSOLUTE <name> are in the script, only load those files
   marked thus.  */

void
mri_only_load (const char *name)
{
  mri_add_to_list (&only_load, name, 0, 0, 0, 0);
}

void
mri_base (etree_type *exp)
{
  base = exp;
}

static int done_tree = 0;

void
mri_draw_tree (void)
{
  if (done_tree)
    return;

#if 0   /* We don't bother with memory regions.  */
  /* Create the regions.  */
  {
    lang_memory_region_type *r;

    r = lang_memory_region_lookup("long");
    r->current = r->origin = exp_get_vma (base, (bfd_vma)0, "origin",
					  lang_first_phase_enum);
    r->length = (bfd_size_type) exp_get_vma (0, ~(bfd_vma) 0, "length",
					     lang_first_phase_enum);
  }
#endif

  /* Now build the statements for the ldlang machine.  */

  /* Attach the addresses of any which have addresses,
     and add the ones not mentioned.  */
  if (address != NULL)
    {
      struct section_name_struct *alist;
      struct section_name_struct *olist;

      if (order == NULL)
	order = address;

      for (alist = address;
	   alist != NULL;
	   alist = alist->next)
	{
	  int done = 0;

	  for (olist = order; done == 0 && olist != NULL; olist = olist->next)
	    {
	      if (strcmp (alist->name, olist->name) == 0)
		{
		  olist->vma = alist->vma;
		  done = 1;
		}
	    }

	  if (!done)
	    {
	      /* Add this onto end of order list.  */
	      mri_add_to_list (&order, alist->name, alist->vma, 0, 0, 0);
	    }
	}
    }

  /* If we're only supposed to load a subset of them in, then prune
     the list.  */
  if (only_load != NULL)
    {
      struct section_name_struct *ptr1;
      struct section_name_struct *ptr2;

      if (order == NULL)
	order = only_load;

      /* See if this name is in the list, if it is then we can load it.  */
      for (ptr1 = only_load; ptr1; ptr1 = ptr1->next)
	for (ptr2 = order; ptr2; ptr2 = ptr2->next)
	  if (strcmp (ptr2->name, ptr1->name) == 0)
	    ptr2->ok_to_load = 1;
    }
  else
    {
      /* No only load list, so everything is ok to load.  */
      struct section_name_struct *ptr;

      for (ptr = order; ptr; ptr = ptr->next)
	ptr->ok_to_load = 1;
    }

  /* Create the order of sections to load.  */
  if (order != NULL)
    {
      /* Been told to output the sections in a certain order.  */
      struct section_name_struct *p = order;

      while (p)
	{
	  struct section_name_struct *aptr;
	  etree_type *align = 0;
	  etree_type *subalign = 0;
	  struct wildcard_list *tmp;

	  /* See if an alignment has been specified.  */
	  for (aptr = alignment; aptr; aptr = aptr->next)
	    if (strcmp (aptr->name, p->name) == 0)
	      align = aptr->align;

	  for (aptr = subalignment; aptr; aptr = aptr->next)
	    if (strcmp (aptr->name, p->name) == 0)
	      subalign = aptr->subalign;

	  if (base == 0)
	    base = p->vma ? p->vma : exp_nameop (NAME, ".");

	  lang_enter_output_section_statement (p->name, base,
					       p->ok_to_load ? 0 : noload_section,
					       align, subalign, NULL);
	  base = 0;
	  tmp = xmalloc (sizeof *tmp);
	  tmp->next = NULL;
	  tmp->spec.name = p->name;
	  tmp->spec.exclude_name_list = NULL;
	  tmp->spec.sorted = FALSE;
	  lang_add_wild (NULL, tmp, FALSE);

	  /* If there is an alias for this section, add it too.  */
	  for (aptr = alias; aptr; aptr = aptr->next)
	    if (strcmp (aptr->alias, p->name) == 0)
	      {
		tmp = xmalloc (sizeof *tmp);
		tmp->next = NULL;
		tmp->spec.name = aptr->name;
		tmp->spec.exclude_name_list = NULL;
		tmp->spec.sorted = FALSE;
		lang_add_wild (NULL, tmp, FALSE);
	      }

	  lang_leave_output_section_statement (0, "*default*", NULL, NULL);

	  p = p->next;
	}
    }

  done_tree = 1;
}

void
mri_load (const char *name)
{
  base = 0;
  lang_add_input_file (name, lang_input_file_is_file_enum, NULL);
#if 0
  lang_leave_output_section_statement (0, "*default*");
#endif
}

void
mri_order (const char *name)
{
  mri_add_to_list (&order, name, 0, 0, 0, 0);
}

void
mri_alias (const char *want, const char *is, int isn)
{
  if (!is)
    {
      char buf[20];

      /* Some sections are digits.  */
      sprintf (buf, "%d", isn);

      is = xstrdup (buf);

      if (is == NULL)
	abort ();
    }

  mri_add_to_list (&alias, is, 0, want, 0, 0);
}

void
mri_name (const char *name)
{
  lang_add_output (name, 1);
}

void
mri_format (const char *name)
{
  if (strcmp (name, "S") == 0)
    lang_add_output_format ("srec", NULL, NULL, 1);

  else if (strcmp (name, "IEEE") == 0)
    lang_add_output_format ("ieee", NULL, NULL, 1);

  else if (strcmp (name, "COFF") == 0)
    lang_add_output_format ("coff-m68k", NULL, NULL, 1);

  else
    einfo (_("%P%F: unknown format type %s\n"), name);
}

void
mri_public (const char *name, etree_type *exp)
{
  lang_add_assignment (exp_assop ('=', name, exp));
}

void
mri_align (const char *name, etree_type *exp)
{
  mri_add_to_list (&alignment, name, 0, 0, exp, 0);
}

void
mri_alignmod (const char *name, etree_type *exp)
{
  mri_add_to_list (&subalignment, name, 0, 0, 0, exp);
}

void
mri_truncate (unsigned int exp)
{
  symbol_truncate = exp;
}
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2002
   Free Software Foundation, Inc.
a55 7
static struct section_name_struct **lookup
  PARAMS ((const char *name, struct section_name_struct **list));
static void mri_add_to_list PARAMS ((struct section_name_struct **list,
				     const char *name, etree_type *vma,
				     const char *zalias, etree_type *align,
				     etree_type *subalign));

d57 1
a57 3
lookup (name, list)
     const char *name;
     struct section_name_struct **list;
d71 1
a71 1
  *ptr = (struct section_name_struct *) xmalloc (sizeof (struct section_name_struct));
d76 6
a81 7
mri_add_to_list (list, name, vma, zalias, align, subalign)
     struct section_name_struct **list;
     const char *name;
     etree_type *vma;
     const char *zalias;
     etree_type *align;
     etree_type *subalign;
d87 1
a87 1
  (*ptr)->next = (struct section_name_struct *) NULL;
d95 1
a95 3
mri_output_section (name, vma)
     const char *name;
     etree_type *vma;
d104 1
a104 2
mri_only_load (name)
     const char *name;
d110 1
a110 2
mri_base (exp)
     etree_type *exp;
d118 1
a118 1
mri_draw_tree ()
d131 2
a132 2
    r->length = (bfd_size_type) exp_get_vma (0, (bfd_vma) ~((bfd_size_type)0),
					     "length", lang_first_phase_enum);
d140 1
a140 1
  if (address != (struct section_name_struct *) NULL)
d145 1
a145 1
      if (order == (struct section_name_struct *) NULL)
d149 1
a149 1
	   alist != (struct section_name_struct *) NULL;
d154 1
a154 3
	  for (olist = order;
	       done == 0 && olist != (struct section_name_struct *) NULL;
	       olist = olist->next)
d173 1
a173 1
  if (only_load != (struct section_name_struct *) NULL)
d178 1
a178 1
      if (order == (struct section_name_struct *) NULL)
d197 1
a197 1
  if (order != (struct section_name_struct *) NULL)
d223 1
a223 2
					       1, align, subalign,
					       (etree_type *) NULL);
d225 1
a225 1
	  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
d236 1
a236 1
		tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
d244 1
a244 3
	  lang_leave_output_section_statement
	    (0, "*default*", (struct lang_output_section_phdr_list *) NULL,
	     NULL);
d254 1
a254 2
mri_load (name)
     const char *name;
d257 1
a257 2
  lang_add_input_file (name,
		       lang_input_file_is_file_enum, (char *) NULL);
d264 1
a264 2
mri_order (name)
     const char *name;
d270 1
a270 4
mri_alias (want, is, isn)
     const char *want;
     const char *is;
     int isn;
d289 1
a289 2
mri_name (name)
     const char *name;
d295 1
a295 2
mri_format (name)
     const char *name;
d298 1
a298 1
    lang_add_output_format ("srec", (char *) NULL, (char *) NULL, 1);
d301 1
a301 1
    lang_add_output_format ("ieee", (char *) NULL, (char *) NULL, 1);
d304 1
a304 1
    lang_add_output_format ("coff-m68k", (char *) NULL, (char *) NULL, 1);
d311 1
a311 3
mri_public (name, exp)
     const char *name;
     etree_type *exp;
d317 1
a317 3
mri_align (name, exp)
     const char *name;
     etree_type *exp;
d323 1
a323 3
mri_alignmod (name, exp)
     const char *name;
     etree_type *exp;
d329 1
a329 2
mri_truncate (exp)
     unsigned int exp;
@


1.5
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000
d34 1
a34 1
#include "ldgram.h"
d39 2
a40 2
  CONST char *name;
  CONST char *alias;
d65 1
a65 1
     CONST char *name;
d87 1
a87 1
     CONST char *name;
d89 1
a89 1
     CONST char *zalias;
d106 1
a106 1
     CONST char *name;
d117 1
a117 1
     CONST char *name;
d152 1
a152 1
  /* Attatch the addresses of any which have addresses,
d223 1
d242 6
a247 1
	  lang_add_wild (p->name, false, (char *) NULL, false, false, NULL);
d252 8
a259 1
	      lang_add_wild (aptr->name, false, (char *) NULL, false, false, NULL);
d263 1
a263 1
	     "*default*");
d274 1
a274 1
     CONST char *name;
d286 1
a286 1
     CONST char *name;
d293 2
a294 2
     CONST char *want;
     CONST char *is;
d315 1
a315 1
     CONST char *name;
d322 1
a322 1
     CONST char *name;
d339 1
a339 1
     CONST char *name;
d347 1
a347 1
     CONST char *name;
d355 1
a355 1
     CONST char *name;
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997, 1998 Free Software Foundation, Inc.
d20 1
a20 1
02111-1307, USA.  */
d22 2
d25 1
a25 7
/* This bit does the tree decoration when MRI style link scripts are parsed */

/*
  contributed by Steve Chamberlain
  		 sac@@cygnus.com

*/
d28 1
a28 1
#include "sysdep.h" 
d45 1
a45 1
} ;
d68 1
d70 8
a77 10
  struct section_name_struct **ptr = list;
  while (*ptr) 
  {
    if (strcmp(name, (*ptr)->name) == 0) {
      /* If this is a match, delete it, we only keep the last instance
	 of any name */
      *ptr = (*ptr)->next;
    }
    else {
      ptr = &((*ptr)->next);
a78 1
  }
d80 1
a80 1
  *ptr = (struct section_name_struct *)xmalloc(sizeof(struct section_name_struct));
d93 2
a94 1
  struct section_name_struct **ptr = lookup(name,list);
d97 1
a97 1
  (*ptr)->next = (struct section_name_struct *)NULL;
a103 1

d109 1
a109 1
  mri_add_to_list(&address, name, vma, 0,0,0);
d112 2
a113 2
/* if any ABSOLUTE <name> are in the script, only load those files
marked thus */
d119 1
a119 1
  mri_add_to_list(&only_load, name, 0, 0,0,0);
a121 1

d134 7
a140 1
  if (done_tree) return;
d142 6
a147 11
  /* We don't bother with memory regions.  */
#if 0
  /* Create the regions */
 {
   lang_memory_region_type *r;
   r = lang_memory_region_lookup("long");
   r->current = r->origin = exp_get_vma(base, (bfd_vma)0, "origin",
					lang_first_phase_enum);
   r->length = (bfd_size_type) exp_get_vma(0, (bfd_vma) ~((bfd_size_type)0),
					   "length", lang_first_phase_enum);
 }
a148 2
  
  /* Now build the statements for the ldlang machine */
d150 1
d152 9
a160 8
  /* Attatch the addresses of any which have addresses, and add the
     ones not mentioned */
  if (address != (struct section_name_struct *)NULL) {
    struct section_name_struct *alist;
    struct section_name_struct *olist;
    if (order == (struct section_name_struct *)NULL) {
      order = address;
    }
d162 3
a164 11
    for (alist = address;
	 alist != (struct section_name_struct*)NULL;
	 alist = alist->next) 
    {
      int done = 0;
      for (olist = order;
	   done == 0 &&
	   olist != (struct section_name_struct *)NULL;
	   olist = olist->next) 
      {
	if (strcmp(alist->name, olist->name) == 0) 
d166 18
a183 2
	  olist->vma = alist->vma;
	  done = 1;
a184 6
      }
      if (!done) {
	/* add this onto end of order list */
	mri_add_to_list(&order, alist->name, alist->vma, 0,0,0);
      }

a186 2
  }

d189 4
d194 10
a203 10
  if (only_load != (struct section_name_struct *)NULL) 
  {
    struct section_name_struct *ptr1;
    struct section_name_struct *ptr2;
    if (order == (struct section_name_struct*)NULL)
     order = only_load;
    
    /* See if this name is in the list, if it is then we can load it
     */
    for (ptr1 = only_load; ptr1; ptr1 = ptr1->next) 
d205 5
a209 6
      for (ptr2= order; ptr2; ptr2=ptr2->next) 
      {
	if (strcmp(ptr2->name, ptr1->name)==0) {
	  ptr2->ok_to_load = 1;
	}
      }
a210 10
  }
  else 
  {
    /* No only load list, so everything is ok to load */
    struct section_name_struct *ptr;
    for (ptr = order; ptr; ptr=ptr->next) {
      ptr->ok_to_load = 1;
    }
  }

d212 2
a213 7

  /* Create the order of sections to load */
  if (order != (struct section_name_struct *)NULL) 
  {
    /* Been told to output the sections in a certain order */
    struct section_name_struct *p = order;
    while (p) 
d215 2
a216 11
      struct section_name_struct *aptr;
      etree_type *align = 0;
      etree_type *subalign = 0;
      /* See if an alignment has been specified */

      for (aptr = alignment; aptr; aptr= aptr->next)
      {
	if (strcmp(aptr->name, p->name)==0) {
	  align =  aptr->align;
	}
      }
d218 33
a250 18
      for (aptr = subalignment; aptr; aptr= aptr->next)
      {
	if (strcmp(aptr->name, p->name)==0) {
	  subalign =  aptr->subalign;
	}
      }

      if (base == 0) {
	base = p->vma ? p->vma :exp_nameop(NAME, ".");
      }
      lang_enter_output_section_statement (p->name, base,
					   p->ok_to_load ? 0 : noload_section,
					   1, align, subalign,
					   (etree_type *) NULL);
      base = 0;
      lang_add_wild (p->name, false, (char *)NULL, false, false, NULL);
      /* If there is an alias for this section, add it too */
      for (aptr = alias; aptr; aptr = aptr->next) {
d252 1
a252 2
	if (strcmp(aptr->alias, p->name)== 0) {
	  lang_add_wild (aptr->name, false, (char *)NULL, false, false, NULL);
a253 7
      }

      lang_leave_output_section_statement
	(0, "*default*", (struct lang_output_section_phdr_list *) NULL, 
         "*default*");

      p = p->next;
a254 2
  }

d257 1
a258 1
}
d264 5
a268 3
  lang_add_input_file(name,
		      lang_input_file_is_file_enum, (char *)NULL);
  /*  lang_leave_output_section_statement(0,"*default*");*/
a270 1

d275 1
a275 1
  mri_add_to_list(&order, name, 0, 0,0,0);
d278 1
a278 1
void 
d284 12
a295 9
  if (!is) {
    /* Some sections are digits - */
    char buf[20];
    sprintf(buf, "%d", isn);
    is = xstrdup (buf);
    if (is == NULL)
      abort ();
  }
  mri_add_to_list(&alias, is, 0, want,0,0);
d297 1
d300 1
a300 2

void 
d304 1
a304 2
  lang_add_output(name, 1);

a306 1

d311 11
a321 15
  if (strcmp(name, "S") == 0)
  {
    lang_add_output_format("srec", (char *) NULL, (char *) NULL, 1);
  }
  else if (strcmp(name, "IEEE") == 0)
  {
    lang_add_output_format("ieee", (char *) NULL, (char *) NULL, 1);
  }
  else if (strcmp(name, "COFF") == 0)
  {
    lang_add_output_format("coff-m68k", (char *) NULL, (char *) NULL, 1);
  }
  else {
    einfo(_("%P%F: unknown format type %s\n"), name);
  }
a323 1

d329 1
a329 1
  lang_add_assignment(exp_assop('=', name, exp));
d332 1
a332 1
void 
d337 1
a337 1
  mri_add_to_list(&alignment, name,0,0,exp,0);
d340 1
a340 1
void 
d345 1
a345 1
  mri_add_to_list(&subalignment, name,0,0,0,exp);
d348 1
a348 2

void 
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d1 3
a3 2
/* Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
   
d8 1
a8 1
the Free Software Foundation; either version 1, or (at your option)
d17 3
a19 2
along with GLD; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d38 1
a38 1

a58 2
extern char *strdup();

d255 1
a255 1
					   p->ok_to_load ? 0 : SEC_NEVER_LOAD,
d259 1
a259 1
      lang_add_wild(p->name, (char *)NULL);
d264 1
a264 1
	  lang_add_wild(aptr->name, (char *)NULL);
d269 2
a270 1
	(0, "*default*", (struct lang_output_section_phdr_list *) NULL);
d308 1
a308 1
    is =strdup(buf);
d343 1
a343 1
    einfo("%P%F: unknown format type %s\n", name);
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d267 4
a270 2
	
      lang_leave_output_section_statement(0, "*default*");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* Copyright (C) 1991, 92, 93, 94 Free Software Foundation, Inc.
a64 1
static void mri_draw_tree PARAMS ((void));
d137 1
a137 1
static void
d142 2
d153 1
a153 1

d268 1
a268 1
      lang_leave_output_section_statement(0, "long");
a280 2
  mri_draw_tree();

@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d1 1
a1 1
/* Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d65 1
d138 1
a138 1
void
a142 2
  /* We don't bother with memory regions.  */
#if 0
d152 1
a152 1
#endif
d267 1
a267 1
      lang_leave_output_section_statement(0, "*default*");
d280 2
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d267 2
a268 4

      lang_leave_output_section_statement
	(0, "*default*", (struct lang_output_section_phdr_list *) NULL);

@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d1 2
a2 3
/* mri.c -- handle MRI style linker scripts
   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.

d16 2
a17 3
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d36 1
a36 1
#include "libiberty.h"
d57 2
d255 1
a255 1
					   p->ok_to_load ? 0 : noload_section,
d307 1
a307 1
    is = xstrdup (buf);
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997, 1998 Free Software Foundation, Inc.
d8 1
a8 1
the Free Software Foundation; either version 2, or (at your option)
d259 1
a259 1
      lang_add_wild (p->name, false, (char *)NULL, false, false, NULL);
d264 1
a264 1
	  lang_add_wild (aptr->name, false, (char *)NULL, false, false, NULL);
d269 1
a269 2
	(0, "*default*", (struct lang_output_section_phdr_list *) NULL, 
         "*default*");
d342 1
a342 1
    einfo(_("%P%F: unknown format type %s\n"), name);
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d19 1
a19 1
02111-1307, USA.
a20 2
   This bit does the tree decoration when MRI style link scripts
   are parsed.
d22 7
a28 1
   Contributed by Steve Chamberlain <sac@@cygnus.com>.  */
d31 1
a31 1
#include "sysdep.h"
d48 1
a48 1
};
d71 1
d73 9
a81 9

  while (*ptr)
    {
      if (strcmp (name, (*ptr)->name) == 0)
	/* If this is a match, delete it, we only keep the last instance
	   of any name.  */
	*ptr = (*ptr)->next;
      else
	ptr = &((*ptr)->next);
d83 1
d85 1
a85 1
  *ptr = (struct section_name_struct *) xmalloc (sizeof (struct section_name_struct));
d98 1
a98 2
  struct section_name_struct **ptr = lookup (name, list);

d101 1
a101 1
  (*ptr)->next = (struct section_name_struct *) NULL;
d108 1
d114 1
a114 1
  mri_add_to_list (&address, name, vma, 0, 0, 0);
d117 2
a118 2
/* If any ABSOLUTE <name> are in the script, only load those files
   marked thus.  */
d124 1
a124 1
  mri_add_to_list (&only_load, name, 0, 0, 0, 0);
d127 1
d140 1
a140 2
  if (done_tree)
    return;
d142 14
a155 4
#if 0   /* We don't bother with memory regions.  */
  /* Create the regions.  */
  {
    lang_memory_region_type *r;
a156 7
    r = lang_memory_region_lookup("long");
    r->current = r->origin = exp_get_vma (base, (bfd_vma)0, "origin",
					  lang_first_phase_enum);
    r->length = (bfd_size_type) exp_get_vma (0, (bfd_vma) ~((bfd_size_type)0),
					     "length", lang_first_phase_enum);
  }
#endif
d158 8
a165 1
  /* Now build the statements for the ldlang machine.  */
d167 3
a169 3
  /* Attatch the addresses of any which have addresses,
     and add the ones not mentioned.  */
  if (address != (struct section_name_struct *) NULL)
d171 7
a177 9
      struct section_name_struct *alist;
      struct section_name_struct *olist;

      if (order == (struct section_name_struct *) NULL)
	order = address;

      for (alist = address;
	   alist != (struct section_name_struct *) NULL;
	   alist = alist->next)
d179 8
a186 1
	  int done = 0;
a187 17
	  for (olist = order;
	       done == 0 && olist != (struct section_name_struct *) NULL;
	       olist = olist->next)
	    {
	      if (strcmp (alist->name, olist->name) == 0)
		{
		  olist->vma = alist->vma;
		  done = 1;
		}
	    }

	  if (!done)
	    {
	      /* Add this onto end of order list.  */
	      mri_add_to_list (&order, alist->name, alist->vma, 0, 0, 0);
	    }
	}
d190 2
d194 11
a204 1
  if (only_load != (struct section_name_struct *) NULL)
d206 17
a222 2
      struct section_name_struct *ptr1;
      struct section_name_struct *ptr2;
a223 2
      if (order == (struct section_name_struct *) NULL)
	order = only_load;
d225 6
a230 7
      /* See if this name is in the list, if it is then we can load it.  */
      for (ptr1 = only_load; ptr1; ptr1 = ptr1->next)
	for (ptr2 = order; ptr2; ptr2 = ptr2->next)
	  if (strcmp (ptr2->name, ptr1->name) == 0)
	    ptr2->ok_to_load = 1;
    }
  else
d232 18
a249 2
      /* No only load list, so everything is ok to load.  */
      struct section_name_struct *ptr;
d251 11
a261 3
      for (ptr = order; ptr; ptr = ptr->next)
	ptr->ok_to_load = 1;
    }
d263 4
a266 5
  /* Create the order of sections to load.  */
  if (order != (struct section_name_struct *) NULL)
    {
      /* Been told to output the sections in a certain order.  */
      struct section_name_struct *p = order;
d268 3
a270 33
      while (p)
	{
	  struct section_name_struct *aptr;
	  etree_type *align = 0;
	  etree_type *subalign = 0;

	  /* See if an alignment has been specified.  */
	  for (aptr = alignment; aptr; aptr = aptr->next)
	    if (strcmp (aptr->name, p->name) == 0)
	      align = aptr->align;

	  for (aptr = subalignment; aptr; aptr = aptr->next)
	    if (strcmp (aptr->name, p->name) == 0)
	      subalign = aptr->subalign;

	  if (base == 0)
	    base = p->vma ? p->vma : exp_nameop (NAME, ".");

	  lang_enter_output_section_statement (p->name, base,
					       p->ok_to_load ? 0 : noload_section,
					       1, align, subalign,
					       (etree_type *) NULL);
	  base = 0;
	  lang_add_wild (p->name, false, (char *) NULL, false, false, NULL);

	  /* If there is an alias for this section, add it too.  */
	  for (aptr = alias; aptr; aptr = aptr->next)
	    if (strcmp (aptr->alias, p->name) == 0)
	      lang_add_wild (aptr->name, false, (char *) NULL, false, false, NULL);

	  lang_leave_output_section_statement
	    (0, "*default*", (struct lang_output_section_phdr_list *) NULL,
	     "*default*");
d272 1
a272 2
	  p = p->next;
	}
d274 2
d278 1
a279 1

d285 3
a287 5
  lang_add_input_file (name,
		       lang_input_file_is_file_enum, (char *) NULL);
#if 0
  lang_leave_output_section_statement (0, "*default*");
#endif
d290 1
d295 1
a295 1
  mri_add_to_list (&order, name, 0, 0, 0, 0);
d298 1
a298 1
void
d304 9
a312 3
  if (!is)
    {
      char buf[20];
d314 1
a314 2
      /* Some sections are digits.  */
      sprintf (buf, "%d", isn);
a315 8
      is = xstrdup (buf);

      if (is == NULL)
	abort ();
    }

  mri_add_to_list (&alias, is, 0, want, 0, 0);
}
d317 1
a317 1
void
d321 2
a322 1
  lang_add_output (name, 1);
d325 1
d330 16
a345 5
  if (strcmp (name, "S") == 0)
    lang_add_output_format ("srec", (char *) NULL, (char *) NULL, 1);

  else if (strcmp (name, "IEEE") == 0)
    lang_add_output_format ("ieee", (char *) NULL, (char *) NULL, 1);
a346 6
  else if (strcmp (name, "COFF") == 0)
    lang_add_output_format ("coff-m68k", (char *) NULL, (char *) NULL, 1);

  else
    einfo (_("%P%F: unknown format type %s\n"), name);
}
d353 1
a353 1
  lang_add_assignment (exp_assop ('=', name, exp));
d356 1
a356 1
void
d361 1
a361 1
  mri_add_to_list (&alignment, name, 0, 0, exp, 0);
d364 1
a364 1
void
d369 1
a369 1
  mri_add_to_list (&subalignment, name, 0, 0, 0, exp);
d372 2
a373 1
void
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2002
d34 1
a34 1
#include <ldgram.h>
d39 2
a40 2
  const char *name;
  const char *alias;
d65 1
a65 1
     const char *name;
d87 1
a87 1
     const char *name;
d89 1
a89 1
     const char *zalias;
d106 1
a106 1
     const char *name;
d117 1
a117 1
     const char *name;
d152 1
a152 1
  /* Attach the addresses of any which have addresses,
a222 1
	  struct wildcard_list *tmp;
d241 1
a241 6
	  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
	  tmp->next = NULL;
	  tmp->spec.name = p->name;
	  tmp->spec.exclude_name_list = NULL;
	  tmp->spec.sorted = FALSE;
	  lang_add_wild (NULL, tmp, FALSE);
d246 1
a246 8
	      {
		tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);
		tmp->next = NULL;
		tmp->spec.name = aptr->name;
		tmp->spec.exclude_name_list = NULL;
		tmp->spec.sorted = FALSE;
		lang_add_wild (NULL, tmp, FALSE);
	      }
d250 1
a250 1
	     NULL);
d261 1
a261 1
     const char *name;
d273 1
a273 1
     const char *name;
d280 2
a281 2
     const char *want;
     const char *is;
d302 1
a302 1
     const char *name;
d309 1
a309 1
     const char *name;
d326 1
a326 1
     const char *name;
d334 1
a334 1
     const char *name;
d342 1
a342 1
     const char *name;
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 2
a3 2
   Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2002,
   2003, 2004 Free Software Foundation, Inc.
d56 7
d64 3
a66 1
lookup (const char *name, struct section_name_struct **list)
d80 1
a80 1
  *ptr = xmalloc (sizeof (struct section_name_struct));
d85 7
a91 6
mri_add_to_list (struct section_name_struct **list,
		 const char *name,
		 etree_type *vma,
		 const char *zalias,
		 etree_type *align,
		 etree_type *subalign)
d97 1
a97 1
  (*ptr)->next = NULL;
d105 3
a107 1
mri_output_section (const char *name, etree_type *vma)
d116 2
a117 1
mri_only_load (const char *name)
d123 2
a124 1
mri_base (etree_type *exp)
d132 1
a132 1
mri_draw_tree (void)
d145 2
a146 2
    r->length = (bfd_size_type) exp_get_vma (0, ~(bfd_vma) 0, "length",
					     lang_first_phase_enum);
d154 1
a154 1
  if (address != NULL)
d159 1
a159 1
      if (order == NULL)
d163 1
a163 1
	   alist != NULL;
d168 3
a170 1
	  for (olist = order; done == 0 && olist != NULL; olist = olist->next)
d189 1
a189 1
  if (only_load != NULL)
d194 1
a194 1
      if (order == NULL)
d213 1
a213 1
  if (order != NULL)
d239 2
a240 1
					       align, subalign, NULL);
d242 1
a242 1
	  tmp = xmalloc (sizeof *tmp);
d253 1
a253 1
		tmp = xmalloc (sizeof *tmp);
d261 3
a263 1
	  lang_leave_output_section_statement (0, "*default*", NULL, NULL);
d273 2
a274 1
mri_load (const char *name)
d277 2
a278 1
  lang_add_input_file (name, lang_input_file_is_file_enum, NULL);
d285 2
a286 1
mri_order (const char *name)
d292 4
a295 1
mri_alias (const char *want, const char *is, int isn)
d314 2
a315 1
mri_name (const char *name)
d321 2
a322 1
mri_format (const char *name)
d325 1
a325 1
    lang_add_output_format ("srec", NULL, NULL, 1);
d328 1
a328 1
    lang_add_output_format ("ieee", NULL, NULL, 1);
d331 1
a331 1
    lang_add_output_format ("coff-m68k", NULL, NULL, 1);
d338 3
a340 1
mri_public (const char *name, etree_type *exp)
d346 3
a348 1
mri_align (const char *name, etree_type *exp)
d354 3
a356 1
mri_alignmod (const char *name, etree_type *exp)
d362 2
a363 1
mri_truncate (unsigned int exp)
@


