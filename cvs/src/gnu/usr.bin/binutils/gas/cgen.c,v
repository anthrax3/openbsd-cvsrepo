head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.5.0.52
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.48
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.44
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.46
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.38
	OPENBSD_5_7_BASE:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.42
	OPENBSD_5_6_BASE:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.40
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.36
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.34
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.32
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.30
	OPENBSD_5_0:1.1.1.5.0.28
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.26
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.24
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.20
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.22
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.18
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.16
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.14
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.12
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.10
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.8
	OPENBSD_4_0_BASE:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.1.1.3.0.8
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.6
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.4
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.2
	OPENBSD_3_2_BASE:1.1.1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.1.1.2.0.8
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.6
	OPENBSD_3_0_BASE:1.1.1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.4
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	new-binutils:1.1.1.1.0.12
	OPENBSD_2_6:1.1.1.1.0.10
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.8
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.6
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.4
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.2
	OPENBSD_2_2_BASE:1.1.1.1
	BINUTILS-2_8_1:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	97.05.29.09.21.35;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.29.09.21.35;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.46.07;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.31.07;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.24;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.41;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* GAS interface for targets using CGEN: Cpu tools GENerator.
   Copyright (C) 1996, 1997 Free Software Foundation, Inc.

This file is part of GAS, the GNU Assembler.

GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */

#include "ansidecl.h"
#include "bfd.h"
#include "cgen-opc.h"
#include "as.h"
#include "subsegs.h"

/* Callback to insert a register into the symbol table.
   A target may choose to let GAS parse the registers.
   ??? Not currently used.  */

void
cgen_asm_record_register (name, number)
     char *name;
     int number;
{
  /* Use symbol_create here instead of symbol_new so we don't try to
     output registers into the object file's symbol table.  */
  symbol_table_insert (symbol_create (name, reg_section,
				      number, &zero_address_frag));
}

/* We need to keep a list of fixups.  We can't simply generate them as
   we go, because that would require us to first create the frag, and
   that would screw up references to ``.''.

   This is used by cpu's with simple operands.  It keeps knowledge of what
   an `expressionS' is and what a `fixup' is out of CGEN which for the time
   being is preferable.

   OPINDEX is the index in the operand table.
   OPINFO is something the caller chooses to help in reloc determination.  */

struct fixup
{
  int opindex;
  int opinfo;
  expressionS exp;
};

#define MAX_FIXUPS 5

static struct fixup fixups[MAX_FIXUPS];
static int num_fixups;

/* Prepare to parse an instruction.
   ??? May wish to make this static and delete calls in md_assemble.  */

void
cgen_asm_init_parse ()
{
  num_fixups = 0;
}

/* Queue a fixup.  */

void
cgen_queue_fixup (opindex, opinfo, expP)
     int opindex;
     expressionS *expP;
{
  /* We need to generate a fixup for this expression.  */
  if (num_fixups >= MAX_FIXUPS)
    as_fatal ("too many fixups");
  fixups[num_fixups].exp = *expP;
  fixups[num_fixups].opindex = opindex;
  fixups[num_fixups].opinfo = opinfo;
  ++num_fixups;
}

/* Default routine to record a fixup.
   This is a cover function to fix_new.
   It exists because we record INSN with the fixup.

   FRAG and WHERE are their respective arguments to fix_new_exp.
   LENGTH is in bits.
   OPINFO is something the caller chooses to help in reloc determination.

   At this point we do not use a bfd_reloc_code_real_type for
   operands residing in the insn, but instead just use the
   operand index.  This lets us easily handle fixups for any
   operand type.  We pick a BFD reloc type in md_apply_fix.  */

fixS *
cgen_record_fixup (frag, where, insn, length, operand, opinfo, symbol, offset)
     fragS *frag;
     int where;
     const struct cgen_insn *insn;
     int length;
     const struct cgen_operand *operand;
     int opinfo;
     symbolS *symbol;
     offsetT offset;
{
  fixS *fixP;

  /* It may seem strange to use operand->attrs and not insn->attrs here,
     but it is the operand that has a pc relative relocation.  */

  fixP = fix_new (frag, where, length / 8, symbol, offset,
		  CGEN_OPERAND_ATTR (operand, CGEN_OPERAND_PCREL_ADDR) != 0,
		  (bfd_reloc_code_real_type) ((int) BFD_RELOC_UNUSED + CGEN_OPERAND_INDEX (operand)));
  fixP->tc_fix_data.insn = (PTR) insn;
  fixP->tc_fix_data.opinfo = opinfo;

  return fixP;
}

/* Default routine to record a fixup given an expression.
   This is a cover function to fix_new_exp.
   It exists because we record INSN with the fixup.

   FRAG and WHERE are their respective arguments to fix_new_exp.
   LENGTH is in bits.
   OPINFO is something the caller chooses to help in reloc determination.

   At this point we do not use a bfd_reloc_code_real_type for
   operands residing in the insn, but instead just use the
   operand index.  This lets us easily handle fixups for any
   operand type.  We pick a BFD reloc type in md_apply_fix.  */

fixS *
cgen_record_fixup_exp (frag, where, insn, length, operand, opinfo, exp)
     fragS *frag;
     int where;
     const struct cgen_insn *insn;
     int length;
     const struct cgen_operand *operand;
     int opinfo;
     expressionS *exp;
{
  fixS *fixP;

  /* It may seem strange to use operand->attrs and not insn->attrs here,
     but it is the operand that has a pc relative relocation.  */

  fixP = fix_new_exp (frag, where, length / 8, exp,
		      CGEN_OPERAND_ATTR (operand, CGEN_OPERAND_PCREL_ADDR) != 0,
		      (bfd_reloc_code_real_type) ((int) BFD_RELOC_UNUSED + CGEN_OPERAND_INDEX (operand)));
  fixP->tc_fix_data.insn = (PTR) insn;
  fixP->tc_fix_data.opinfo = opinfo;

  return fixP;
}

/* Callback for cgen interface.  Parse the expression at *STRP.
   The result is an error message or NULL for success (in which case
   *STRP is advanced past the parsed text).
   WANT is an indication of what the caller is looking for.
   If WANT == CGEN_ASM_PARSE_INIT the caller is beginning to try to match
   a table entry with the insn, reset the queued fixups counter.
   An enum cgen_parse_operand_result is stored in RESULTP.
   OPINDEX is the operand's table entry index.
   OPINFO is something the caller chooses to help in reloc determination.
   The resulting value is stored in VALUEP.  */

const char *
cgen_parse_operand (want, strP, opindex, opinfo, resultP, valueP)
     enum cgen_parse_operand_type want;
     const char **strP;
     int opindex;
     int opinfo;
     enum cgen_parse_operand_result *resultP;
     bfd_vma *valueP;
{
  char *hold;
  const char *errmsg = NULL;
  expressionS exp;

  if (want == CGEN_PARSE_OPERAND_INIT)
    {
      cgen_asm_init_parse ();
      return NULL;
    }

  hold = input_line_pointer;
  input_line_pointer = (char *) *strP;
  expression (&exp);
  *strP = input_line_pointer;
  input_line_pointer = hold;

  /* FIXME: Need to check `want'.  */

  switch (exp.X_op)
    {
    case O_illegal :
      errmsg = "illegal operand";
      *resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
      break;
    case O_absent :
      errmsg = "missing operand";
      *resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
      break;
    case O_constant :
      *valueP = exp.X_add_number;
      *resultP = CGEN_PARSE_OPERAND_RESULT_NUMBER;
      break;
    case O_register :
      *valueP = exp.X_add_number;
      *resultP = CGEN_PARSE_OPERAND_RESULT_REGISTER;
      break;
    default :
      cgen_queue_fixup (opindex, opinfo, &exp);
      *valueP = 0;
      *resultP = CGEN_PARSE_OPERAND_RESULT_QUEUED;
      break;
    }

  return errmsg;
}

/* Finish assembling instruction INSN.
   BUF contains what we've built up so far.
   LENGTH is the size of the insn in bits.  */

void
cgen_asm_finish_insn (insn, buf, length)
     const struct cgen_insn *insn;
     cgen_insn_t *buf;
     unsigned int length;
{
  int i, relax_operand;
  char *f;
  unsigned int byte_len = length / 8;

  /* ??? Target foo issues various warnings here, so one might want to provide
     a hook here.  However, our caller is defined in tc-foo.c so there
     shouldn't be a need for a hook.  */

  /* Write out the instruction.
     It is important to fetch enough space in one call to `frag_more'.
     We use (f - frag_now->fr_literal) to compute where we are and we
     don't want frag_now to change between calls.

     Relaxable instructions: We need to ensure we allocate enough
     space for the largest insn.  */

  if (CGEN_INSN_ATTR (insn, CGEN_INSN_RELAX) != 0)
    abort (); /* These currently shouldn't get here.  */

  /* Is there a relaxable insn with the relaxable operand needing a fixup?  */

  relax_operand = -1;
  if (CGEN_INSN_ATTR (insn, CGEN_INSN_RELAXABLE) != 0)
    {
      /* Scan the fixups for the operand affected by relaxing
	 (i.e. the branch address).  */

      for (i = 0; i < num_fixups; ++i)
	{
	  if (CGEN_OPERAND_ATTR (& CGEN_SYM (operand_table) [fixups[i].opindex],
				 CGEN_OPERAND_RELAX) != 0)
	    {
	      relax_operand = i;
	      break;
	    }
	}
    }

  if (relax_operand != -1)
    {
      int max_len;
      fragS *old_frag;

#ifdef TC_CGEN_MAX_RELAX
      max_len = TC_CGEN_MAX_RELAX (insn, byte_len);
#else
      max_len = CGEN_MAX_INSN_SIZE;
#endif
      /* Ensure variable part and fixed part are in same fragment.  */
      /* FIXME: Having to do this seems like a hack.  */
      frag_grow (max_len);
      /* Allocate space for the fixed part.  */
      f = frag_more (byte_len);
      /* Create a relaxable fragment for this instruction.  */
      old_frag = frag_now;
      frag_var (rs_machine_dependent,
		max_len - byte_len /* max chars */,
		0 /* variable part already allocated */,
		/* FIXME: When we machine generate the relax table,
		   machine generate a macro to compute subtype.  */
		1 /* subtype */,
		fixups[relax_operand].exp.X_add_symbol,
		fixups[relax_operand].exp.X_add_number,
		f);
      /* Record the operand number with the fragment so md_convert_frag
	 can use cgen_md_record_fixup to record the appropriate reloc.  */
      /* FIXME: fr_targ.cgen is used pending deciding whether to
	 allow a target to add members to fragS.  For more info
	 see the comment above fr_targ in as.h.  */
      old_frag->fr_targ.cgen.insn = insn;
      old_frag->fr_targ.cgen.opindex = fixups[relax_operand].opindex;
      old_frag->fr_targ.cgen.opinfo = fixups[relax_operand].opinfo;
    }
  else
    f = frag_more (byte_len);

  /* If we're recording insns as numbers (rather than a string of bytes),
     target byte order handling is deferred until now.  */
#if 0 /*def CGEN_INT_INSN*/
  switch (length)
    {
    case 16:
      if (cgen_big_endian_p)
	bfd_putb16 ((bfd_vma) *buf, f);
      else
	bfd_putl16 ((bfd_vma) *buf, f);
      break;
    case 32:
      if (cgen_big_endian_p)
	bfd_putb32 ((bfd_vma) *buf, f);
      else
	bfd_putl32 ((bfd_vma) *buf, f);
      break;
    default:
      abort ();
    }
#else
  memcpy (f, buf, byte_len);
#endif

  /* Create any fixups.  */
  for (i = 0; i < num_fixups; ++i)
    {
      /* Don't create fixups for these.  That's done during relaxation.
	 We don't need to test for CGEN_INSN_RELAX as they can't get here
	 (see above).  */
      if (CGEN_INSN_ATTR (insn, CGEN_INSN_RELAXABLE) != 0
	  && CGEN_OPERAND_ATTR (& CGEN_SYM (operand_table) [fixups[i].opindex],
				CGEN_OPERAND_RELAX) != 0)
	continue;

#ifndef md_cgen_record_fixup_exp
#define md_cgen_record_fixup_exp cgen_record_fixup_exp
#endif

      md_cgen_record_fixup_exp (frag_now, f - frag_now->fr_literal,
				insn, length,
				& CGEN_SYM (operand_table) [fixups[i].opindex],
				fixups[i].opinfo,
				&fixups[i].exp);
    }
}

/* Apply a fixup to the object code.  This is called for all the
   fixups we generated by the call to fix_new_exp, above.  In the call
   above we used a reloc code which was the largest legal reloc code
   plus the operand index.  Here we undo that to recover the operand
   index.  At this point all symbol values should be fully resolved,
   and we attempt to completely resolve the reloc.  If we can not do
   that, we determine the correct reloc code and put it back in the fixup.  */

/* FIXME: This function handles some of the fixups and bfd_install_relocation
   handles the rest.  bfd_install_relocation (or some other bfd function)
   should handle them all.  */

int
cgen_md_apply_fix3 (fixP, valueP, seg)
     fixS *fixP;
     valueT *valueP;
     segT seg;
{
  char *where = fixP->fx_frag->fr_literal + fixP->fx_where;
  valueT value;

  /* FIXME FIXME FIXME: The value we are passed in *valuep includes
     the symbol values.  Since we are using BFD_ASSEMBLER, if we are
     doing this relocation the code in write.c is going to call
     bfd_install_relocation, which is also going to use the symbol
     value.  That means that if the reloc is fully resolved we want to
     use *valuep since bfd_install_relocation is not being used.
     However, if the reloc is not fully resolved we do not want to use
     *valuep, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valuep since it includes the
     result of md_pcrel_from.  This is confusing.  */

  if (fixP->fx_addsy == (symbolS *) NULL)
    {
      value = *valueP;
      fixP->fx_done = 1;
    }
  else if (fixP->fx_pcrel)
    value = *valueP;
  else
    {
      value = fixP->fx_offset;
      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
	  else
	    {
	      /* We don't actually support subtracting a symbol.  */
 	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    "expression too complex");
	    }
	}
    }

  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
      const struct cgen_operand *operand = & CGEN_SYM (operand_table) [opindex];
      const char *errmsg;
      bfd_reloc_code_real_type reloc_type;
      struct cgen_fields fields;
      const struct cgen_insn *insn = (struct cgen_insn *) fixP->tc_fix_data.insn;

      /* If the reloc has been fully resolved finish the operand here.  */
      /* FIXME: This duplicates the capabilities of code in BFD.  */
      if (fixP->fx_done
	  /* FIXME: If partial_inplace isn't set bfd_install_relocation won't
	     finish the job.  Testing for pcrel is a temporary hack.  */
	  || fixP->fx_pcrel)
	{
	  /* This may seem like overkill, and using bfd_install_relocation or
	     some such may be preferable, but this is simple.  */
	  CGEN_FIELDS_BITSIZE (&fields) = CGEN_INSN_BITSIZE (insn);
	  CGEN_SYM (set_operand) (opindex, &value, &fields);
	  errmsg = CGEN_SYM (validate_operand) (opindex, &fields);
	  if (errmsg)
	    as_warn_where (fixP->fx_file, fixP->fx_line, "%s\n", errmsg);
	  CGEN_SYM (insert_operand) (opindex, &fields, where);
	}

      if (fixP->fx_done)
	return 1;

      /* The operand isn't fully resolved.  Determine a BFD reloc value
	 based on the operand information and leave it to
	 bfd_install_relocation.  Note that this doesn't work when
	 partial_inplace == false.  */

      reloc_type = CGEN_SYM (lookup_reloc) (insn, operand, fixP);
      if (reloc_type != BFD_RELOC_NONE)
	{
	  fixP->fx_r_type = reloc_type;
	}
      else
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"unresolved expression that must be resolved");
	  fixP->fx_done = 1;
	  return 1;
	}
    }
  else if (fixP->fx_done)
    {
      /* We're finished with this fixup.  Install it because
	 bfd_install_relocation won't be called to do it.  */
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_8:
	  md_number_to_chars (where, value, 1);
	  break;
	case BFD_RELOC_16:
	  md_number_to_chars (where, value, 2);
	  break;
	case BFD_RELOC_32:
	  md_number_to_chars (where, value, 4);
	  break;
	/* FIXME: later add support for 64 bits.  */
	default:
	  abort ();
	}
    }
  else
    {
      /* bfd_install_relocation will be called to finish things up.  */
    }

  /* Tuck `value' away for use by tc_gen_reloc.
     See the comment describing fx_addnumber in write.h.
     This field is misnamed (or misused :-).  */
  fixP->fx_addnumber = value;

  return 1;
}

/* Translate internal representation of relocation info to BFD target format.

   FIXME: To what extent can we get all relevant targets to use this?  */

arelent *
cgen_tc_gen_reloc (section, fixP)
     asection *section;
     fixS *fixP;
{
  arelent *reloc;

  reloc = (arelent *) bfd_alloc (stdoutput, sizeof (arelent));

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    "internal error: can't export reloc type %d (`%s')",
		    fixP->fx_r_type, bfd_get_reloc_code_name (fixP->fx_r_type));
      return NULL;
    }

  assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);

  reloc->sym_ptr_ptr = &fixP->fx_addsy->bsym;
  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
  reloc->addend = fixP->fx_addnumber;

  return reloc;
}
@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
a19 1
#include <setjmp.h>
a20 1
#include "libiberty.h"
d22 1
a22 2
#include "symcat.h"
#include "cgen-desc.h"
a24 5
#include "cgen.h"

/* Opcode table descriptor, must be set by md_begin.  */

CGEN_CPU_DESC gas_cgen_cpu_desc;
d32 1
a32 1
     char * name;
d38 1
a38 1
				      number, & zero_address_frag));
d59 3
a61 1
static struct fixup fixups [GAS_CGEN_MAX_FIXUPS];
d68 1
a68 1
gas_cgen_init_parse ()
d75 4
a78 4
static void
queue_fixup (opindex, opinfo, expP)
     int           opindex;
     expressionS * expP;
d81 3
a83 3
  if (num_fixups >= GAS_CGEN_MAX_FIXUPS)
    as_fatal (_("too many fixups"));
  fixups[num_fixups].exp     = * expP;
d85 2
a86 61
  fixups[num_fixups].opinfo  = opinfo;
  ++ num_fixups;
}

/* The following three functions allow a backup of the fixup chain to be made,
   and to have this backup be swapped with the current chain.  This allows
   certain ports, eg the m32r, to swap two instructions and swap their fixups
   at the same time.  */
/* ??? I think with cgen_asm_finish_insn (or something else) there is no
   more need for this.  */

static struct fixup saved_fixups [GAS_CGEN_MAX_FIXUPS];
static int saved_num_fixups;

void
gas_cgen_save_fixups ()
{
  saved_num_fixups = num_fixups;
  
  memcpy (saved_fixups, fixups, sizeof (fixups[0]) * num_fixups);

  num_fixups = 0;
}

void
gas_cgen_restore_fixups ()
{
  num_fixups = saved_num_fixups;
  
  memcpy (fixups, saved_fixups, sizeof (fixups[0]) * num_fixups);

  saved_num_fixups = 0;
}

void
gas_cgen_swap_fixups ()
{
  int tmp;
  struct fixup tmp_fixup;

  if (num_fixups == 0)
    {
      gas_cgen_restore_fixups ();
    }
  else if (saved_num_fixups == 0)
    {
      gas_cgen_save_fixups ();
    }
  else
    {
      tmp = saved_num_fixups;
      saved_num_fixups = num_fixups;
      num_fixups = tmp;
      
      for (tmp = GAS_CGEN_MAX_FIXUPS; tmp--;)
	{
	  tmp_fixup          = saved_fixups [tmp];
	  saved_fixups [tmp] = fixups [tmp];
	  fixups [tmp]       = tmp_fixup;
	}
    }
d103 9
a111 9
gas_cgen_record_fixup (frag, where, insn, length, operand, opinfo, symbol, offset)
     fragS *              frag;
     int                  where;
     const CGEN_INSN *    insn;
     int                  length;
     const CGEN_OPERAND * operand;
     int                  opinfo;
     symbolS *            symbol;
     offsetT              offset;
d113 1
a113 1
  fixS * fixP;
d119 4
a122 6
		  CGEN_OPERAND_ATTR_VALUE (operand, CGEN_OPERAND_PCREL_ADDR),
		  (bfd_reloc_code_real_type)
		    ((int) BFD_RELOC_UNUSED
		     + (int) operand->type));
  fixP->fx_cgen.insn = insn;
  fixP->fx_cgen.opinfo = opinfo;
d141 8
a148 8
gas_cgen_record_fixup_exp (frag, where, insn, length, operand, opinfo, exp)
     fragS *              frag;
     int                  where;
     const CGEN_INSN *    insn;
     int                  length;
     const CGEN_OPERAND * operand;
     int                  opinfo;
     expressionS *        exp;
d150 1
a150 1
  fixS * fixP;
d156 4
a159 6
		      CGEN_OPERAND_ATTR_VALUE (operand, CGEN_OPERAND_PCREL_ADDR),
		      (bfd_reloc_code_real_type)
		        ((int) BFD_RELOC_UNUSED
			 + (int) operand->type));
  fixP->fx_cgen.insn = insn;
  fixP->fx_cgen.opinfo = opinfo;
a163 3
/* Used for communication between the next two procedures.  */
static jmp_buf expr_jmp_buf;

d176 1
a176 2
gas_cgen_parse_operand (cd, want, strP, opindex, opinfo, resultP, valueP)
     CGEN_CPU_DESC cd;
d178 1
a178 1
     const char ** strP;
d181 2
a182 2
     enum cgen_parse_operand_result * resultP;
     bfd_vma * valueP;
d184 2
a185 9
#ifdef __STDC__
  /* These are volatile to survive the setjmp.  */
  char * volatile hold;
  enum cgen_parse_operand_result * volatile resultP_1;
#else
  static char * hold;
  static enum cgen_parse_operand_result * resultP_1;
#endif
  const char * errmsg = NULL;
d190 1
a190 1
      gas_cgen_init_parse ();
a193 1
  resultP_1 = resultP;
d195 3
a197 14
  input_line_pointer = (char *) * strP;

  /* We rely on md_operand to longjmp back to us.
     This is done via gas_cgen_md_operand.  */
  if (setjmp (expr_jmp_buf) != 0)
    {
      input_line_pointer = (char *) hold;
      * resultP_1 = CGEN_PARSE_OPERAND_RESULT_ERROR;
      return "illegal operand";
    }

  expression (& exp);

  * strP = input_line_pointer;
d205 2
a206 2
      errmsg = _("illegal operand");
      * resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
d209 2
a210 2
      errmsg = _("missing operand");
      * resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
d213 2
a214 2
      * valueP = exp.X_add_number;
      * resultP = CGEN_PARSE_OPERAND_RESULT_NUMBER;
d217 2
a218 2
      * valueP = exp.X_add_number;
      * resultP = CGEN_PARSE_OPERAND_RESULT_REGISTER;
d221 3
a223 3
      queue_fixup (opindex, opinfo, & exp);
      * valueP = 0;
      * resultP = CGEN_PARSE_OPERAND_RESULT_QUEUED;
a229 12
/* md_operand handler to catch unrecognized expressions and halt the
   parsing process so the next entry can be tried.

   ??? This could be done differently by adding code to `expression'.  */

void
gas_cgen_md_operand (expressionP)
     expressionS * expressionP;
{
  longjmp (expr_jmp_buf, 1);
}

d232 1
a232 4
   LENGTH is the size of the insn in bits.
   RELAX_P is non-zero if relaxable insns should be emitted as such.
   Otherwise they're emitted in non-relaxable forms.
   The "result" is stored in RESULT if non-NULL.  */
d235 3
a237 3
gas_cgen_finish_insn (insn, buf, length, relax_p, result)
     const CGEN_INSN * insn;
     CGEN_INSN_BYTES_PTR buf;
a238 2
     int relax_p;
     finished_insnS * result;
d240 2
a241 3
  int i;
  int relax_operand;
  char * f;
d256 1
a256 1
  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAX))
d262 1
a262 1
  if (relax_p && CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXABLE))
d267 1
a267 1
      for (i = 0; i < num_fixups; ++ i)
d269 2
a270 2
	  if (CGEN_OPERAND_ATTR_VALUE (cgen_operand_lookup_by_num (gas_cgen_cpu_desc, fixups[i].opindex),
				       CGEN_OPERAND_RELAX))
d281 1
a281 1
      fragS * old_frag;
a290 1

a292 1

a294 1

a303 1

d305 7
a311 6
	 can use gas_cgen_md_record_fixup to record the appropriate reloc.  */
      old_frag->fr_cgen.insn    = insn;
      old_frag->fr_cgen.opindex = fixups[relax_operand].opindex;
      old_frag->fr_cgen.opinfo  = fixups[relax_operand].opinfo;
      if (result)
	result->frag = old_frag;
d314 1
a314 5
    {
      f = frag_more (byte_len);
      if (result)
	result->frag = frag_now;
    }
d318 18
a335 2
#if CGEN_INT_INSN_P
  cgen_put_insn_value (gas_cgen_cpu_desc, f, length, *buf);
a342 4
      fixS *fixP;
      const CGEN_OPERAND *operand =
	cgen_operand_lookup_by_num (gas_cgen_cpu_desc, fixups[i].opindex);

d346 3
a348 3
      if (relax_p
	  && CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXABLE)
	  && CGEN_OPERAND_ATTR_VALUE (operand, CGEN_OPERAND_RELAX))
d352 1
a352 1
#define md_cgen_record_fixup_exp gas_cgen_record_fixup_exp
d355 5
a359 12
	fixP = md_cgen_record_fixup_exp (frag_now, f - frag_now->fr_literal,
					 insn, length, operand,
					 fixups[i].opinfo,
					 & fixups[i].exp);
	if (result)
	  result->fixups[i] = fixP;
    }

  if (result)
    {
      result->num_fixups = num_fixups;
      result->addr = f;
d376 4
a379 4
gas_cgen_md_apply_fix3 (fixP, valueP, seg)
     fixS *   fixP;
     valueT * valueP;
     segT     seg;
d381 1
a381 1
  char * where = fixP->fx_frag->fr_literal + fixP->fx_where;
d383 1
a383 3
  /* canonical name, since used a lot */
  CGEN_CPU_DESC cd = gas_cgen_cpu_desc;
  
d397 1
a397 1
      value = * valueP;
d401 1
a401 1
    value = * valueP;
d413 1
a413 1
			    _("expression too complex"));
d421 1
a421 1
      const CGEN_OPERAND *operand = cgen_operand_lookup_by_num (cd, opindex);
d424 2
a425 2
      CGEN_FIELDS *fields = alloca (CGEN_CPU_SIZEOF_FIELDS (cd));
      const CGEN_INSN *insn = fixP->fx_cgen.insn;
d434 5
a438 19
	  CGEN_CPU_SET_FIELDS_BITSIZE (cd) (fields, CGEN_INSN_BITSIZE (insn));
	  CGEN_CPU_SET_VMA_OPERAND (cd) (cd, opindex, fields, (bfd_vma) value);

#if CGEN_INT_INSN_P
	  {
	    CGEN_INSN_INT insn_value =
	      cgen_get_insn_value (cd, where, CGEN_INSN_BITSIZE (insn));

	    /* ??? 0 is passed for `pc' */
	    errmsg = CGEN_CPU_INSERT_OPERAND (cd) (cd, opindex, fields,
						   &insn_value, (bfd_vma) 0);
	    cgen_put_insn_value (cd, where, CGEN_INSN_BITSIZE (insn),
				 insn_value);
	  }
#else
	    /* ??? 0 is passed for `pc' */
	    errmsg = CGEN_CPU_INSERT_OPERAND (cd) (cd, opindex, fields, where,
						   (bfd_vma) 0);
#endif
d440 2
a441 1
	    as_bad_where (fixP->fx_file, fixP->fx_line, "%s", errmsg);
d452 1
a452 1
      reloc_type = md_cgen_lookup_reloc (insn, operand, fixP);
d460 1
a460 1
			_("unresolved expression that must be resolved"));
d482 1
a482 4
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("internal error: can't install fix for reloc type %d (`%s')"),
			fixP->fx_r_type, bfd_get_reloc_code_name (fixP->fx_r_type));
	  break;
d503 3
a505 3
gas_cgen_tc_gen_reloc (section, fixP)
     asection * section;
     fixS *     fixP;
d507 1
a507 1
  arelent * reloc;
d509 1
a509 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d515 1
a515 1
		    _("internal error: can't export reloc type %d (`%s')"),
d522 3
a524 9
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);

  /* Use fx_offset for these cases */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT)
    reloc->addend  = fixP->fx_offset;
  else
    reloc->addend  = fixP->fx_addnumber;
a525 1
  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d18 1
a18 1
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a28 1
#include "dwarf2dbg.h"
d40 1
a40 1
     char *name;
d46 1
a46 1
				      number, &zero_address_frag));
d60 2
a61 1
struct fixup {
d67 1
a67 1
static struct fixup fixups[GAS_CGEN_MAX_FIXUPS];
a83 1
     int           opinfo;
d89 1
a89 1
  fixups[num_fixups].exp     = *expP;
d102 1
a102 1
static struct fixup saved_fixups[GAS_CGEN_MAX_FIXUPS];
d109 1
a109 1

d119 1
a119 1

d144 1
a144 1

d178 1
a178 1
  fixS *fixP;
d217 1
a217 1
  fixS *fixP;
a234 1
static int expr_jmp_buf_p;
d249 1
a249 1
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
d251 1
a251 1
     const char **strP;
d254 2
a255 2
     enum cgen_parse_operand_result *resultP;
     bfd_vma *valueP;
d262 2
a263 2
  static char *hold;
  static enum cgen_parse_operand_result *resultP_1;
d265 1
a265 1
  const char *errmsg = NULL;
d276 1
a276 1
  input_line_pointer = (char *) *strP;
a281 1
      expr_jmp_buf_p = 0;
d283 1
a283 1
      *resultP_1 = CGEN_PARSE_OPERAND_RESULT_ERROR;
d287 1
a287 3
  expr_jmp_buf_p = 1;
  expression (&exp);
  expr_jmp_buf_p = 0;
d289 1
a289 1
  *strP = input_line_pointer;
d296 1
a296 1
    case O_illegal:
d298 1
a298 1
      *resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
d300 1
a300 1
    case O_absent:
d302 1
a302 1
      *resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
d304 3
a306 3
    case O_constant:
      *valueP = exp.X_add_number;
      *resultP = CGEN_PARSE_OPERAND_RESULT_NUMBER;
d308 3
a310 3
    case O_register:
      *valueP = exp.X_add_number;
      *resultP = CGEN_PARSE_OPERAND_RESULT_REGISTER;
d312 4
a315 4
    default:
      queue_fixup (opindex, opinfo, &exp);
      *valueP = 0;
      *resultP = CGEN_PARSE_OPERAND_RESULT_QUEUED;
d329 1
a329 1
     expressionS *expressionP ATTRIBUTE_UNUSED;
d331 1
a331 3
  /* Don't longjmp if we're not called from within cgen_parse_operand().  */
  if (expr_jmp_buf_p)
    longjmp (expr_jmp_buf, 1);
d343 1
a343 1
     const CGEN_INSN *insn;
d347 1
a347 1
     finished_insnS *result;
d351 1
a351 1
  char *f;
d367 1
a367 2
    /* These currently shouldn't get here.  */
    abort ();
d377 1
a377 1
      for (i = 0; i < num_fixups; ++i)
d391 1
a391 4
      fragS *old_frag;
      expressionS *exp;
      symbolS *sym;
      offsetT off;
a407 10
      exp = &fixups[relax_operand].exp;
      sym = exp->X_add_symbol;
      off = exp->X_add_number;
      if (exp->X_op != O_constant && exp->X_op != O_symbol)
	{
	  /* Handle complex expressions.  */
	  sym = make_expr_symbol (exp);
	  off = 0;
	}

d414 2
a415 2
		sym,
		off,
a440 3
  /* Emit DWARF2 debugging information.  */
  dwarf2_emit_insn (byte_len);

d460 6
a465 6
      fixP = md_cgen_record_fixup_exp (frag_now, f - frag_now->fr_literal,
				       insn, length, operand,
				       fixups[i].opinfo,
				       &fixups[i].exp);
      if (result)
	result->fixups[i] = fixP;
d491 1
a491 1
     segT     seg ATTRIBUTE_UNUSED;
d493 1
a493 1
  char *where = fixP->fx_frag->fr_literal + fixP->fx_where;
d495 1
a495 1
  /* Canonical name, since used a lot.  */
d497 1
a497 1

d511 1
a511 1
      value = *valueP;
d515 1
a515 1
    value = *valueP;
d526 1
a526 1
	      as_bad_where (fixP->fx_file, fixP->fx_line,
d556 1
a556 1
	    /* ??? 0 is passed for `pc'.  */
d563 3
a565 3
	  /* ??? 0 is passed for `pc'.  */
	  errmsg = CGEN_CPU_INSERT_OPERAND (cd) (cd, opindex, fields, where,
						 (bfd_vma) 0);
d607 1
a607 3
	case BFD_RELOC_64:
	  md_number_to_chars (where, value, 8);
	  break;
d634 1
a634 1
     asection * section ATTRIBUTE_UNUSED;
d637 1
a637 1
  arelent *reloc;
d645 2
a646 1
		    _("relocation is not supported"));
d655 2
a656 2
  /* Use fx_offset for these cases.  */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY
d658 1
a658 1
    reloc->addend = fixP->fx_offset;
d660 1
a660 1
    reloc->addend = fixP->fx_addnumber;
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d5 1
a5 1
   This file is part of GAS, the GNU Assembler.
d7 13
a19 13
   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a31 2
static void queue_fixup PARAMS ((int, int, expressionS *));

d62 1
a62 2
struct fixup
{
d97 6
a102 33
/* The following functions allow fixup chains to be stored, retrieved,
   and swapped.  They are a generalization of a pre-existing scheme
   for storing, restoring and swapping fixup chains that was used by
   the m32r port.  The functionality is essentially the same, only
   instead of only being able to store a single fixup chain, an entire
   array of fixup chains can be stored.  It is the user's responsibility
   to keep track of how many fixup chains have been stored and which
   elements of the array they are in.

   The algorithms used are the same as in the old scheme.  Other than the
   "array-ness" of the whole thing, the functionality is identical to the
   old scheme.

   gas_cgen_initialize_saved_fixups_array():
      Sets num_fixups_in_chain to 0 for each element. Call this from
      md_begin() if you plan to use these functions and you want the
      fixup count in each element to be set to 0 initially.  This is
      not necessary, but it's included just in case.  It performs
      the same function for each element in the array of fixup chains
      that gas_init_parse() performs for the current fixups.

   gas_cgen_save_fixups (element):
      element - element number of the array you wish to store the fixups
                to.  No mechanism is built in for tracking what element
                was last stored to.

   gas_cgen_restore_fixups (element):
      element - element number of the array you wish to restore the fixups
                from.

   gas_cgen_swap_fixups(int element):
       element - swap the current fixups with those in this element number.
*/
d104 2
a105 7
struct saved_fixups
{
  struct fixup fixup_chain[GAS_CGEN_MAX_FIXUPS];
  int num_fixups_in_chain;
};

static struct saved_fixups stored_fixups[MAX_SAVED_FIXUP_CHAINS];
d108 1
a108 1
gas_cgen_initialize_saved_fixups_array ()
d110 3
a112 1
  int i = 0;
d114 1
a114 2
  while (i < MAX_SAVED_FIXUP_CHAINS)
    stored_fixups[i++].num_fixups_in_chain = 0;
d118 1
a118 2
gas_cgen_save_fixups (i)
     int i;
d120 3
a122 5
  if (i < 0 || i >= MAX_SAVED_FIXUP_CHAINS)
    {
      as_fatal ("index into stored_fixups[] out of bounds");
      return;
    }
d124 1
a124 4
  stored_fixups[i].num_fixups_in_chain = num_fixups;
  memcpy (stored_fixups[i].fixup_chain, fixups,
	  sizeof (fixups[0]) * num_fixups);
  num_fixups = 0;
d128 1
a128 2
gas_cgen_restore_fixups (i)
     int i;
d130 4
a133 1
  if (i < 0 || i >= MAX_SAVED_FIXUP_CHAINS)
d135 1
a135 2
      as_fatal ("index into stored_fixups[] out of bounds");
      return;
d137 1
a137 12

  num_fixups = stored_fixups[i].num_fixups_in_chain;
  memcpy (fixups, stored_fixups[i].fixup_chain,
	  (sizeof (stored_fixups[i].fixup_chain[0])) * num_fixups);
  stored_fixups[i].num_fixups_in_chain = 0;
}

void
gas_cgen_swap_fixups (i)
     int i;
{
  if (i < 0 || i >= MAX_SAVED_FIXUP_CHAINS)
d139 1
a139 2
      as_fatal ("index into stored_fixups[] out of bounds");
      return;
a140 7

  if (num_fixups == 0)
    gas_cgen_restore_fixups (i);

  else if (stored_fixups[i].num_fixups_in_chain == 0)
    gas_cgen_save_fixups (i);

d143 2
a144 5
      int tmp;
      struct fixup tmp_fixup;

      tmp = stored_fixups[i].num_fixups_in_chain;
      stored_fixups[i].num_fixups_in_chain = num_fixups;
d149 3
a151 3
	  tmp_fixup = stored_fixups[i].fixup_chain [tmp];
	  stored_fixups[i].fixup_chain[tmp] = fixups [tmp];
	  fixups [tmp] = tmp_fixup;
d167 1
a167 1
   operand type.  We pick a BFD reloc type in md_apply_fix3.  */
d184 1
d207 1
a207 1
   operand type.  We pick a BFD reloc type in md_apply_fix3.  */
d223 1
d268 1
a268 1
  const char *errmsg;
d288 1
a288 1
      return _("illegal operand");
a293 1
  errmsg = NULL;
d512 2
a513 2
void
gas_cgen_md_apply_fix3 (fixP, valP, seg)
d515 1
a515 1
     valueT * valP;
d519 1
a519 1
  valueT value = * valP;
d523 11
d535 21
a555 5
    fixP->fx_done = 1;

  /* We don't actually support subtracting a symbol.  */
  if (fixP->fx_subsy != (symbolS *) NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));
d597 1
a597 1
	return;
a604 1

d606 3
a608 1
	fixP->fx_r_type = reloc_type;
d614 1
a614 1
	  return;
d642 4
a645 2
  /* else
     bfd_install_relocation will be called to finish things up.  */
d651 2
a689 12
}

/* Perform any cgen specific initialisation.
   Called after gas_cgen_cpu_desc has been created.  */

void
gas_cgen_begin ()
{
  if (flag_signed_overflow_ok)
    cgen_set_signed_overflow_ok (gas_cgen_cpu_desc);
  else
    cgen_clear_signed_overflow_ok (gas_cgen_cpu_desc);
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d32 1
a32 1
static void queue_fixup (int, int, expressionS *);
d434 1
a434 1
  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED))
d534 1
a534 1
	 We don't need to test for CGEN_INSN_RELAXED as they can't get here
@


