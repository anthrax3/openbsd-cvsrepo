head	1.11;
access;
symbols
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.12
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.12
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.10
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.10.20.06.04.06;	author daniel;	state Exp;
branches;
next	1.10;
commitid	IMB4ZRG9ouFX8LqX;

1.10
date	2013.05.17.11.36.14;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.18.21.05.18;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.02.20.45.24;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.28;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.41;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.20;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.04.31;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.23;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.35;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.35;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.29;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.43.27;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.01;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.21.46;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.10;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.31.44;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.25;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.43;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Backport fix for binutils 11867: .quad directive not assembled correctly.

Alan Modra (and Alan's employer) graciously permitted use of his patch
under GPLv2.

ok kettenis@@
@
text
@/* expr.c -operands, expressions-
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* This is really a branch office of as-read.c. I split it out to clearly
   distinguish the world of expressions from the world of statements.
   (It also gives smaller files to re-compile.)
   Here, "operand"s are of expressions, not instructions.  */

#include <string.h>
#define min(a, b)       ((a) < (b) ? (a) : (b))

#include "as.h"
#include "safe-ctype.h"
#include "obstack.h"

static void floating_constant (expressionS * expressionP);
static valueT generic_bignum_to_int32 (void);
#ifdef BFD64
static valueT generic_bignum_to_int64 (void);
#endif
static void integer_constant (int radix, expressionS * expressionP);
static void mri_char_constant (expressionS *);
static void current_location (expressionS *);
static void clean_up_expression (expressionS * expressionP);
static segT operand (expressionS *);
static operatorT operator (int *);

extern const char EXP_CHARS[], FLT_CHARS[];

/* We keep a mapping of expression symbols to file positions, so that
   we can provide better error messages.  */

struct expr_symbol_line {
  struct expr_symbol_line *next;
  symbolS *sym;
  char *file;
  unsigned int line;
};

static struct expr_symbol_line *expr_symbol_lines;

/* Build a dummy symbol to hold a complex expression.  This is how we
   build expressions up out of other expressions.  The symbol is put
   into the fake section expr_section.  */

symbolS *
make_expr_symbol (expressionS *expressionP)
{
  expressionS zero;
  symbolS *symbolP;
  struct expr_symbol_line *n;

  if (expressionP->X_op == O_symbol
      && expressionP->X_add_number == 0)
    return expressionP->X_add_symbol;

  if (expressionP->X_op == O_big)
    {
      /* This won't work, because the actual value is stored in
	 generic_floating_point_number or generic_bignum, and we are
	 going to lose it if we haven't already.  */
      if (expressionP->X_add_number > 0)
	as_bad (_("bignum invalid"));
      else
	as_bad (_("floating point number invalid"));
      zero.X_op = O_constant;
      zero.X_add_number = 0;
      zero.X_unsigned = 0;
      clean_up_expression (&zero);
      expressionP = &zero;
    }

  /* Putting constant symbols in absolute_section rather than
     expr_section is convenient for the old a.out code, for which
     S_GET_SEGMENT does not always retrieve the value put in by
     S_SET_SEGMENT.  */
  symbolP = symbol_create (FAKE_LABEL_NAME,
			   (expressionP->X_op == O_constant
			    ? absolute_section
			    : expr_section),
			   0, &zero_address_frag);
  symbol_set_value_expression (symbolP, expressionP);

  if (expressionP->X_op == O_constant)
    resolve_symbol_value (symbolP);

  n = (struct expr_symbol_line *) xmalloc (sizeof *n);
  n->sym = symbolP;
  as_where (&n->file, &n->line);
  n->next = expr_symbol_lines;
  expr_symbol_lines = n;

  return symbolP;
}

/* Return the file and line number for an expr symbol.  Return
   non-zero if something was found, 0 if no information is known for
   the symbol.  */

int
expr_symbol_where (symbolS *sym, char **pfile, unsigned int *pline)
{
  register struct expr_symbol_line *l;

  for (l = expr_symbol_lines; l != NULL; l = l->next)
    {
      if (l->sym == sym)
	{
	  *pfile = l->file;
	  *pline = l->line;
	  return 1;
	}
    }

  return 0;
}

/* Utilities for building expressions.
   Since complex expressions are recorded as symbols for use in other
   expressions these return a symbolS * and not an expressionS *.
   These explicitly do not take an "add_number" argument.  */
/* ??? For completeness' sake one might want expr_build_symbol.
   It would just return its argument.  */

/* Build an expression for an unsigned constant.
   The corresponding one for signed constants is missing because
   there's currently no need for it.  One could add an unsigned_p flag
   but that seems more clumsy.  */

symbolS *
expr_build_uconstant (offsetT value)
{
  expressionS e;

  e.X_op = O_constant;
  e.X_add_number = value;
  e.X_unsigned = 1;
  return make_expr_symbol (&e);
}

/* Build an expression for OP s1.  */

symbolS *
expr_build_unary (operatorT op, symbolS *s1)
{
  expressionS e;

  e.X_op = op;
  e.X_add_symbol = s1;
  e.X_add_number = 0;
  return make_expr_symbol (&e);
}

/* Build an expression for s1 OP s2.  */

symbolS *
expr_build_binary (operatorT op, symbolS *s1, symbolS *s2)
{
  expressionS e;

  e.X_op = op;
  e.X_add_symbol = s1;
  e.X_op_symbol = s2;
  e.X_add_number = 0;
  return make_expr_symbol (&e);
}

/* Build an expression for the current location ('.').  */

symbolS *
expr_build_dot (void)
{
  expressionS e;

  current_location (&e);
  return make_expr_symbol (&e);
}

/* Build any floating-point literal here.
   Also build any bignum literal here.  */

/* Seems atof_machine can backscan through generic_bignum and hit whatever
   happens to be loaded before it in memory.  And its way too complicated
   for me to fix right.  Thus a hack.  JF:  Just make generic_bignum bigger,
   and never write into the early words, thus they'll always be zero.
   I hate Dean's floating-point code.  Bleh.  */
LITTLENUM_TYPE generic_bignum[SIZE_OF_LARGE_NUMBER + 6];

FLONUM_TYPE generic_floating_point_number = {
  &generic_bignum[6],		/* low.  (JF: Was 0)  */
  &generic_bignum[SIZE_OF_LARGE_NUMBER + 6 - 1], /* high.  JF: (added +6)  */
  0,				/* leader.  */
  0,				/* exponent.  */
  0				/* sign.  */
};

/* If nonzero, we've been asked to assemble nan, +inf or -inf.  */
int generic_floating_point_magic;

static void
floating_constant (expressionS *expressionP)
{
  /* input_line_pointer -> floating-point constant.  */
  int error_code;

  error_code = atof_generic (&input_line_pointer, ".", EXP_CHARS,
			     &generic_floating_point_number);

  if (error_code)
    {
      if (error_code == ERROR_EXPONENT_OVERFLOW)
	{
	  as_bad (_("bad floating-point constant: exponent overflow"));
	}
      else
	{
	  as_bad (_("bad floating-point constant: unknown error code=%d"),
		  error_code);
	}
    }
  expressionP->X_op = O_big;
  /* input_line_pointer -> just after constant, which may point to
     whitespace.  */
  expressionP->X_add_number = -1;
}

static valueT
generic_bignum_to_int32 (void)
{
  valueT number =
	   ((generic_bignum[1] & LITTLENUM_MASK) << LITTLENUM_NUMBER_OF_BITS)
	   | (generic_bignum[0] & LITTLENUM_MASK);
  number &= 0xffffffff;
  return number;
}

#ifdef BFD64
static valueT
generic_bignum_to_int64 (void)
{
  valueT number =
    ((((((((valueT) generic_bignum[3] & LITTLENUM_MASK)
	  << LITTLENUM_NUMBER_OF_BITS)
	 | ((valueT) generic_bignum[2] & LITTLENUM_MASK))
	<< LITTLENUM_NUMBER_OF_BITS)
       | ((valueT) generic_bignum[1] & LITTLENUM_MASK))
      << LITTLENUM_NUMBER_OF_BITS)
     | ((valueT) generic_bignum[0] & LITTLENUM_MASK));
  return number;
}
#endif

static void
integer_constant (int radix, expressionS *expressionP)
{
  char *start;		/* Start of number.  */
  char *suffix = NULL;
  char c;
  valueT number;	/* Offset or (absolute) value.  */
  short int digit;	/* Value of next digit in current radix.  */
  short int maxdig = 0;	/* Highest permitted digit value.  */
  int too_many_digits = 0;	/* If we see >= this number of.  */
  char *name;		/* Points to name of symbol.  */
  symbolS *symbolP;	/* Points to symbol.  */

  int small;			/* True if fits in 32 bits.  */

  /* May be bignum, or may fit in 32 bits.  */
  /* Most numbers fit into 32 bits, and we want this case to be fast.
     so we pretend it will fit into 32 bits.  If, after making up a 32
     bit number, we realise that we have scanned more digits than
     comfortably fit into 32 bits, we re-scan the digits coding them
     into a bignum.  For decimal and octal numbers we are
     conservative: Some numbers may be assumed bignums when in fact
     they do fit into 32 bits.  Numbers of any radix can have excess
     leading zeros: We strive to recognise this and cast them back
     into 32 bits.  We must check that the bignum really is more than
     32 bits, and change it back to a 32-bit number if it fits.  The
     number we are looking for is expected to be positive, but if it
     fits into 32 bits as an unsigned number, we let it be a 32-bit
     number.  The cavalier approach is for speed in ordinary cases.  */
  /* This has been extended for 64 bits.  We blindly assume that if
     you're compiling in 64-bit mode, the target is a 64-bit machine.
     This should be cleaned up.  */

#ifdef BFD64
#define valuesize 64
#else /* includes non-bfd case, mostly */
#define valuesize 32
#endif

  if ((NUMBERS_WITH_SUFFIX || flag_m68k_mri) && radix == 0)
    {
      int flt = 0;

      /* In MRI mode, the number may have a suffix indicating the
	 radix.  For that matter, it might actually be a floating
	 point constant.  */
      for (suffix = input_line_pointer; ISALNUM (*suffix); suffix++)
	{
	  if (*suffix == 'e' || *suffix == 'E')
	    flt = 1;
	}

      if (suffix == input_line_pointer)
	{
	  radix = 10;
	  suffix = NULL;
	}
      else
	{
	  c = *--suffix;
	  c = TOUPPER (c);
	  if (c == 'B')
	    radix = 2;
	  else if (c == 'D')
	    radix = 10;
	  else if (c == 'O' || c == 'Q')
	    radix = 8;
	  else if (c == 'H')
	    radix = 16;
	  else if (suffix[1] == '.' || c == 'E' || flt)
	    {
	      floating_constant (expressionP);
	      return;
	    }
	  else
	    {
	      radix = 10;
	      suffix = NULL;
	    }
	}
    }

  switch (radix)
    {
    case 2:
      maxdig = 2;
      too_many_digits = valuesize + 1;
      break;
    case 8:
      maxdig = radix = 8;
      too_many_digits = (valuesize + 2) / 3 + 1;
      break;
    case 16:
      maxdig = radix = 16;
      too_many_digits = (valuesize + 3) / 4 + 1;
      break;
    case 10:
      maxdig = radix = 10;
      too_many_digits = (valuesize + 11) / 4; /* Very rough.  */
    }
#undef valuesize
  start = input_line_pointer;
  c = *input_line_pointer++;
  for (number = 0;
       (digit = hex_value (c)) < maxdig;
       c = *input_line_pointer++)
    {
      number = number * radix + digit;
    }
  /* c contains character after number.  */
  /* input_line_pointer->char after c.  */
  small = (input_line_pointer - start - 1) < too_many_digits;

  if (radix == 16 && c == '_')
    {
      /* This is literal of the form 0x333_0_12345678_1.
	 This example is equivalent to 0x00000333000000001234567800000001.  */

      int num_little_digits = 0;
      int i;
      input_line_pointer = start;	/* -> 1st digit.  */

      know (LITTLENUM_NUMBER_OF_BITS == 16);

      for (c = '_'; c == '_'; num_little_digits += 2)
	{

	  /* Convert one 64-bit word.  */
	  int ndigit = 0;
	  number = 0;
	  for (c = *input_line_pointer++;
	       (digit = hex_value (c)) < maxdig;
	       c = *(input_line_pointer++))
	    {
	      number = number * radix + digit;
	      ndigit++;
	    }

	  /* Check for 8 digit per word max.  */
	  if (ndigit > 8)
	    as_bad (_("a bignum with underscores may not have more than 8 hex digits in any word"));

	  /* Add this chunk to the bignum.
	     Shift things down 2 little digits.  */
	  know (LITTLENUM_NUMBER_OF_BITS == 16);
	  for (i = min (num_little_digits + 1, SIZE_OF_LARGE_NUMBER - 1);
	       i >= 2;
	       i--)
	    generic_bignum[i] = generic_bignum[i - 2];

	  /* Add the new digits as the least significant new ones.  */
	  generic_bignum[0] = number & 0xffffffff;
	  generic_bignum[1] = number >> 16;
	}

      /* Again, c is char after number, input_line_pointer->after c.  */

      if (num_little_digits > SIZE_OF_LARGE_NUMBER - 1)
	num_little_digits = SIZE_OF_LARGE_NUMBER - 1;

      assert (num_little_digits >= 4);

      if (num_little_digits != 8)
	as_bad (_("a bignum with underscores must have exactly 4 words"));

      /* We might have some leading zeros.  These can be trimmed to give
	 us a change to fit this constant into a small number.  */
      while (generic_bignum[num_little_digits - 1] == 0
	     && num_little_digits > 1)
	num_little_digits--;

      if (num_little_digits <= 2)
	{
	  /* will fit into 32 bits.  */
	  number = generic_bignum_to_int32 ();
	  small = 1;
	}
#ifdef BFD64
      else if (num_little_digits <= 4)
	{
	  /* Will fit into 64 bits.  */
	  number = generic_bignum_to_int64 ();
	  small = 1;
	}
#endif
      else
	{
	  small = 0;

	  /* Number of littlenums in the bignum.  */
	  number = num_little_digits;
	}
    }
  else if (!small)
    {
      /* We saw a lot of digits. manufacture a bignum the hard way.  */
      LITTLENUM_TYPE *leader;	/* -> high order littlenum of the bignum.  */
      LITTLENUM_TYPE *pointer;	/* -> littlenum we are frobbing now.  */
      long carry;

      leader = generic_bignum;
      generic_bignum[0] = 0;
      generic_bignum[1] = 0;
      generic_bignum[2] = 0;
      generic_bignum[3] = 0;
      input_line_pointer = start;	/* -> 1st digit.  */
      c = *input_line_pointer++;
      for (; (carry = hex_value (c)) < maxdig; c = *input_line_pointer++)
	{
	  for (pointer = generic_bignum; pointer <= leader; pointer++)
	    {
	      long work;

	      work = carry + radix * *pointer;
	      *pointer = work & LITTLENUM_MASK;
	      carry = work >> LITTLENUM_NUMBER_OF_BITS;
	    }
	  if (carry)
	    {
	      if (leader < generic_bignum + SIZE_OF_LARGE_NUMBER - 1)
		{
		  /* Room to grow a longer bignum.  */
		  *++leader = carry;
		}
	    }
	}
      /* Again, c is char after number.  */
      /* input_line_pointer -> after c.  */
      know (LITTLENUM_NUMBER_OF_BITS == 16);
      if (leader < generic_bignum + 2)
	{
	  /* Will fit into 32 bits.  */
	  number = generic_bignum_to_int32 ();
	  small = 1;
	}
#ifdef BFD64
      else if (leader < generic_bignum + 4)
	{
	  /* Will fit into 64 bits.  */
	  number = generic_bignum_to_int64 ();
	  small = 1;
	}
#endif
      else
	{
	  /* Number of littlenums in the bignum.  */
	  number = leader - generic_bignum + 1;
	}
    }

  if ((NUMBERS_WITH_SUFFIX || flag_m68k_mri)
      && suffix != NULL
      && input_line_pointer - 1 == suffix)
    c = *input_line_pointer++;

  if (small)
    {
      /* Here with number, in correct radix. c is the next char.
	 Note that unlike un*x, we allow "011f" "0x9f" to both mean
	 the same as the (conventional) "9f".
	 This is simply easier than checking for strict canonical
	 form.  Syntax sux!  */

      if (LOCAL_LABELS_FB && c == 'b')
	{
	  /* Backward ref to local label.
	     Because it is backward, expect it to be defined.  */
	  /* Construct a local label.  */
	  name = fb_label_name ((int) number, 0);

	  /* Seen before, or symbol is defined: OK.  */
	  symbolP = symbol_find (name);
	  if ((symbolP != NULL) && (S_IS_DEFINED (symbolP)))
	    {
	      /* Local labels are never absolute.  Don't waste time
		 checking absoluteness.  */
	      know (SEG_NORMAL (S_GET_SEGMENT (symbolP)));

	      expressionP->X_op = O_symbol;
	      expressionP->X_add_symbol = symbolP;
	    }
	  else
	    {
	      /* Either not seen or not defined.  */
	      /* @@@@ Should print out the original string instead of
		 the parsed number.  */
	      as_bad (_("backward ref to unknown label \"%d:\""),
		      (int) number);
	      expressionP->X_op = O_constant;
	    }

	  expressionP->X_add_number = 0;
	}			/* case 'b' */
      else if (LOCAL_LABELS_FB && c == 'f')
	{
	  /* Forward reference.  Expect symbol to be undefined or
	     unknown.  undefined: seen it before.  unknown: never seen
	     it before.

	     Construct a local label name, then an undefined symbol.
	     Don't create a xseg frag for it: caller may do that.
	     Just return it as never seen before.  */
	  name = fb_label_name ((int) number, 1);
	  symbolP = symbol_find_or_make (name);
	  /* We have no need to check symbol properties.  */
#ifndef many_segments
	  /* Since "know" puts its arg into a "string", we
	     can't have newlines in the argument.  */
	  know (S_GET_SEGMENT (symbolP) == undefined_section || S_GET_SEGMENT (symbolP) == text_section || S_GET_SEGMENT (symbolP) == data_section);
#endif
	  expressionP->X_op = O_symbol;
	  expressionP->X_add_symbol = symbolP;
	  expressionP->X_add_number = 0;
	}			/* case 'f' */
      else if (LOCAL_LABELS_DOLLAR && c == '$')
	{
	  /* If the dollar label is *currently* defined, then this is just
	     another reference to it.  If it is not *currently* defined,
	     then this is a fresh instantiation of that number, so create
	     it.  */

	  if (dollar_label_defined ((long) number))
	    {
	      name = dollar_label_name ((long) number, 0);
	      symbolP = symbol_find (name);
	      know (symbolP != NULL);
	    }
	  else
	    {
	      name = dollar_label_name ((long) number, 1);
	      symbolP = symbol_find_or_make (name);
	    }

	  expressionP->X_op = O_symbol;
	  expressionP->X_add_symbol = symbolP;
	  expressionP->X_add_number = 0;
	}			/* case '$' */
      else
	{
	  expressionP->X_op = O_constant;
#ifdef TARGET_WORD_SIZE
	  /* Sign extend NUMBER.  */
	  number |= (-(number >> (TARGET_WORD_SIZE - 1))) << (TARGET_WORD_SIZE - 1);
#endif
	  expressionP->X_add_number = number;
	  input_line_pointer--;	/* Restore following character.  */
	}			/* Really just a number.  */
    }
  else
    {
      /* Not a small number.  */
      expressionP->X_op = O_big;
      expressionP->X_add_number = number;	/* Number of littlenums.  */
      input_line_pointer--;	/* -> char following number.  */
    }
}

/* Parse an MRI multi character constant.  */

static void
mri_char_constant (expressionS *expressionP)
{
  int i;

  if (*input_line_pointer == '\''
      && input_line_pointer[1] != '\'')
    {
      expressionP->X_op = O_constant;
      expressionP->X_add_number = 0;
      return;
    }

  /* In order to get the correct byte ordering, we must build the
     number in reverse.  */
  for (i = SIZE_OF_LARGE_NUMBER - 1; i >= 0; i--)
    {
      int j;

      generic_bignum[i] = 0;
      for (j = 0; j < CHARS_PER_LITTLENUM; j++)
	{
	  if (*input_line_pointer == '\'')
	    {
	      if (input_line_pointer[1] != '\'')
		break;
	      ++input_line_pointer;
	    }
	  generic_bignum[i] <<= 8;
	  generic_bignum[i] += *input_line_pointer;
	  ++input_line_pointer;
	}

      if (i < SIZE_OF_LARGE_NUMBER - 1)
	{
	  /* If there is more than one littlenum, left justify the
	     last one to make it match the earlier ones.  If there is
	     only one, we can just use the value directly.  */
	  for (; j < CHARS_PER_LITTLENUM; j++)
	    generic_bignum[i] <<= 8;
	}

      if (*input_line_pointer == '\''
	  && input_line_pointer[1] != '\'')
	break;
    }

  if (i < 0)
    {
      as_bad (_("character constant too large"));
      i = 0;
    }

  if (i > 0)
    {
      int c;
      int j;

      c = SIZE_OF_LARGE_NUMBER - i;
      for (j = 0; j < c; j++)
	generic_bignum[j] = generic_bignum[i + j];
      i = c;
    }

  know (LITTLENUM_NUMBER_OF_BITS == 16);
  if (i > 2)
    {
      expressionP->X_op = O_big;
      expressionP->X_add_number = i;
    }
  else
    {
      expressionP->X_op = O_constant;
      if (i < 2)
	expressionP->X_add_number = generic_bignum[0] & LITTLENUM_MASK;
      else
	expressionP->X_add_number =
	  (((generic_bignum[1] & LITTLENUM_MASK)
	    << LITTLENUM_NUMBER_OF_BITS)
	   | (generic_bignum[0] & LITTLENUM_MASK));
    }

  /* Skip the final closing quote.  */
  ++input_line_pointer;
}

/* Return an expression representing the current location.  This
   handles the magic symbol `.'.  */

static void
current_location (expressionS *expressionp)
{
  if (now_seg == absolute_section)
    {
      expressionp->X_op = O_constant;
      expressionp->X_add_number = abs_section_offset;
    }
  else
    {
      expressionp->X_op = O_symbol;
      expressionp->X_add_symbol = symbol_temp_new_now ();
      expressionp->X_add_number = 0;
    }
}

/* In:	Input_line_pointer points to 1st char of operand, which may
	be a space.

   Out:	An expressionS.
	The operand may have been empty: in this case X_op == O_absent.
	Input_line_pointer->(next non-blank) char after operand.  */

static segT
operand (expressionS *expressionP)
{
  char c;
  symbolS *symbolP;	/* Points to symbol.  */
  char *name;		/* Points to name of symbol.  */
  segT segment;

  /* All integers are regarded as unsigned unless they are negated.
     This is because the only thing which cares whether a number is
     unsigned is the code in emit_expr which extends constants into
     bignums.  It should only sign extend negative numbers, so that
     something like ``.quad 0x80000000'' is not sign extended even
     though it appears negative if valueT is 32 bits.  */
  expressionP->X_unsigned = 1;

  /* Digits, assume it is a bignum.  */

  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand.  */
  c = *input_line_pointer++;	/* input_line_pointer -> past char in c.  */

  if (is_end_of_line[(unsigned char) c])
    goto eol;

  switch (c)
    {
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      input_line_pointer--;

      integer_constant ((NUMBERS_WITH_SUFFIX || flag_m68k_mri)
			? 0 : 10,
			expressionP);
      break;

#ifdef LITERAL_PREFIXDOLLAR_HEX
    case '$':
      /* $L is the start of a local label, not a hex constant.  */
      if (* input_line_pointer == 'L')
      goto isname;
      integer_constant (16, expressionP);
      break;
#endif

#ifdef LITERAL_PREFIXPERCENT_BIN
    case '%':
      integer_constant (2, expressionP);
      break;
#endif

    case '0':
      /* Non-decimal radix.  */

      if (NUMBERS_WITH_SUFFIX || flag_m68k_mri)
	{
	  char *s;

	  /* Check for a hex or float constant.  */
	  for (s = input_line_pointer; hex_p (*s); s++)
	    ;
	  if (*s == 'h' || *s == 'H' || *input_line_pointer == '.')
	    {
	      --input_line_pointer;
	      integer_constant (0, expressionP);
	      break;
	    }
	}
      c = *input_line_pointer;
      switch (c)
	{
	case 'o':
	case 'O':
	case 'q':
	case 'Q':
	case '8':
	case '9':
	  if (NUMBERS_WITH_SUFFIX || flag_m68k_mri)
	    {
	      integer_constant (0, expressionP);
	      break;
	    }
	  /* Fall through.  */
	default:
	default_case:
	  if (c && strchr (FLT_CHARS, c))
	    {
	      input_line_pointer++;
	      floating_constant (expressionP);
	      expressionP->X_add_number = - TOLOWER (c);
	    }
	  else
	    {
	      /* The string was only zero.  */
	      expressionP->X_op = O_constant;
	      expressionP->X_add_number = 0;
	    }

	  break;

	case 'x':
	case 'X':
	  if (flag_m68k_mri)
	    goto default_case;
	  input_line_pointer++;
	  integer_constant (16, expressionP);
	  break;

	case 'b':
	  if (LOCAL_LABELS_FB && ! (flag_m68k_mri || NUMBERS_WITH_SUFFIX))
	    {
	      /* This code used to check for '+' and '-' here, and, in
		 some conditions, fall through to call
		 integer_constant.  However, that didn't make sense,
		 as integer_constant only accepts digits.  */
	      /* Some of our code elsewhere does permit digits greater
		 than the expected base; for consistency, do the same
		 here.  */
	      if (input_line_pointer[1] < '0'
		  || input_line_pointer[1] > '9')
		{
		  /* Parse this as a back reference to label 0.  */
		  input_line_pointer--;
		  integer_constant (10, expressionP);
		  break;
		}
	      /* Otherwise, parse this as a binary number.  */
	    }
	  /* Fall through.  */
	case 'B':
	  input_line_pointer++;
	  if (flag_m68k_mri || NUMBERS_WITH_SUFFIX)
	    goto default_case;
	  integer_constant (2, expressionP);
	  break;

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	  integer_constant ((flag_m68k_mri || NUMBERS_WITH_SUFFIX)
			    ? 0 : 8,
			    expressionP);
	  break;

	case 'f':
	  if (LOCAL_LABELS_FB)
	    {
	      /* If it says "0f" and it could possibly be a floating point
		 number, make it one.  Otherwise, make it a local label,
		 and try to deal with parsing the rest later.  */
	      if (!input_line_pointer[1]
		  || (is_end_of_line[0xff & input_line_pointer[1]])
		  || strchr (FLT_CHARS, 'f') == NULL)
		goto is_0f_label;
	      {
		char *cp = input_line_pointer + 1;
		int r = atof_generic (&cp, ".", EXP_CHARS,
				      &generic_floating_point_number);
		switch (r)
		  {
		  case 0:
		  case ERROR_EXPONENT_OVERFLOW:
		    if (*cp == 'f' || *cp == 'b')
		      /* Looks like a difference expression.  */
		      goto is_0f_label;
		    else if (cp == input_line_pointer + 1)
		      /* No characters has been accepted -- looks like
			 end of operand.  */
		      goto is_0f_label;
		    else
		      goto is_0f_float;
		  default:
		    as_fatal (_("expr.c(operand): bad atof_generic return val %d"),
			      r);
		  }
	      }

	      /* Okay, now we've sorted it out.  We resume at one of these
		 two labels, depending on what we've decided we're probably
		 looking at.  */
	    is_0f_label:
	      input_line_pointer--;
	      integer_constant (10, expressionP);
	      break;

	    is_0f_float:
	      /* Fall through.  */
	      ;
	    }

	case 'd':
	case 'D':
	  if (flag_m68k_mri || NUMBERS_WITH_SUFFIX)
	    {
	      integer_constant (0, expressionP);
	      break;
	    }
	  /* Fall through.  */
	case 'F':
	case 'r':
	case 'e':
	case 'E':
	case 'g':
	case 'G':
	  input_line_pointer++;
	  floating_constant (expressionP);
	  expressionP->X_add_number = - TOLOWER (c);
	  break;

	case '$':
	  if (LOCAL_LABELS_DOLLAR)
	    {
	      integer_constant (10, expressionP);
	      break;
	    }
	  else
	    goto default_case;
	}

      break;

    case '(':
#ifndef NEED_INDEX_OPERATOR
    case '[':
#endif
      /* Didn't begin with digit & not a name.  */
      segment = expression (expressionP);
      /* expression () will pass trailing whitespace.  */
      if ((c == '(' && *input_line_pointer != ')')
	  || (c == '[' && *input_line_pointer != ']'))
	{
#ifdef RELAX_PAREN_GROUPING
	  if (c != '(')
#endif
	    as_bad (_("missing '%c'"), c == '(' ? ')' : ']');
	}
      else
	input_line_pointer++;
      SKIP_WHITESPACE ();
      /* Here with input_line_pointer -> char after "(...)".  */
      return segment;

#ifdef TC_M68K
    case 'E':
      if (! flag_m68k_mri || *input_line_pointer != '\'')
	goto de_fault;
      as_bad (_("EBCDIC constants are not supported"));
      /* Fall through.  */
    case 'A':
      if (! flag_m68k_mri || *input_line_pointer != '\'')
	goto de_fault;
      ++input_line_pointer;
      /* Fall through.  */
#endif
    case '\'':
      if (! flag_m68k_mri)
	{
	  /* Warning: to conform to other people's assemblers NO
	     ESCAPEMENT is permitted for a single quote.  The next
	     character, parity errors and all, is taken as the value
	     of the operand.  VERY KINKY.  */
	  expressionP->X_op = O_constant;
	  expressionP->X_add_number = *input_line_pointer++;
	  break;
	}

      mri_char_constant (expressionP);
      break;

    case '+':
      /* Do not accept ++e as +(+e).
	 Disabled, since the preprocessor removes whitespace.  */
      if (0 && *input_line_pointer == '+')
	goto target_op;
      (void) operand (expressionP);
      break;

#ifdef TC_M68K
    case '"':
      /* Double quote is the bitwise not operator in MRI mode.  */
      if (! flag_m68k_mri)
	goto de_fault;
      /* Fall through.  */
#endif
    case '~':
      /* '~' is permitted to start a label on the Delta.  */
      if (is_name_beginner (c))
	goto isname;
    case '!':
    case '-':
      {
        /* Do not accept --e as -(-e)
	   Disabled, since the preprocessor removes whitespace.  */
	if (0 && c == '-' && *input_line_pointer == '-')
	  goto target_op;
	
	operand (expressionP);
	if (expressionP->X_op == O_constant)
	  {
	    /* input_line_pointer -> char after operand.  */
	    if (c == '-')
	      {
		expressionP->X_add_number = - expressionP->X_add_number;
		/* Notice: '-' may overflow: no warning is given.
		   This is compatible with other people's
		   assemblers.  Sigh.  */
		expressionP->X_unsigned = 0;
	      }
	    else if (c == '~' || c == '"')
	      expressionP->X_add_number = ~ expressionP->X_add_number;
	    else
	      expressionP->X_add_number = ! expressionP->X_add_number;
	  }
	else if (expressionP->X_op == O_big
		 && expressionP->X_add_number <= 0
		 && c == '-'
		 && (generic_floating_point_number.sign == '+'
		     || generic_floating_point_number.sign == 'P'))
	  {
	    /* Negative flonum (eg, -1.000e0).  */
	    if (generic_floating_point_number.sign == '+')
	      generic_floating_point_number.sign = '-';
	    else
	      generic_floating_point_number.sign = 'N';
	  }
	else if (expressionP->X_op == O_big
		 && expressionP->X_add_number > 0)
	  {
	    int i;

	    if (c == '~' || c == '-')
	      {
		for (i = 0; i < expressionP->X_add_number; ++i)
		  generic_bignum[i] = ~generic_bignum[i];

		/* Extend the bignum to at least the size of .octa.  */
		if (expressionP->X_add_number < SIZE_OF_LARGE_NUMBER)
		  {
		    expressionP->X_add_number = SIZE_OF_LARGE_NUMBER;
		    for (; i < expressionP->X_add_number; ++i)
		      generic_bignum[i] = ~(LITTLENUM_TYPE) 0;
		  }

		if (c == '-')
		  for (i = 0; i < expressionP->X_add_number; ++i)
		    {
		      generic_bignum[i] += 1;
		      if (generic_bignum[i])
			break;
		    }
	      }
	    else if (c == '!')
	      {
		for (i = 0; i < expressionP->X_add_number; ++i)
		  if (generic_bignum[i] != 0)
		    break;
		expressionP->X_add_number = i >= expressionP->X_add_number;
		expressionP->X_op = O_constant;
		expressionP->X_unsigned = 1;
	      }
	  }
	else if (expressionP->X_op != O_illegal
		 && expressionP->X_op != O_absent)
	  {
	    expressionP->X_add_symbol = make_expr_symbol (expressionP);
	    if (c == '-')
	      expressionP->X_op = O_uminus;
	    else if (c == '~' || c == '"')
	      expressionP->X_op = O_bit_not;
	    else
	      expressionP->X_op = O_logical_not;
	    expressionP->X_add_number = 0;
	  }
	else
	  as_warn (_("Unary operator %c ignored because bad operand follows"),
		   c);
      }
      break;

#if defined (DOLLAR_DOT) || defined (TC_M68K)
    case '$':
      /* '$' is the program counter when in MRI mode, or when
	 DOLLAR_DOT is defined.  */
#ifndef DOLLAR_DOT
      if (! flag_m68k_mri)
	goto de_fault;
#endif
      if (flag_m68k_mri && hex_p (*input_line_pointer))
	{
	  /* In MRI mode, '$' is also used as the prefix for a
	     hexadecimal constant.  */
	  integer_constant (16, expressionP);
	  break;
	}

      if (is_part_of_name (*input_line_pointer))
	goto isname;

      current_location (expressionP);
      break;
#endif

    case '.':
      if (!is_part_of_name (*input_line_pointer))
	{
	  current_location (expressionP);
	  break;
	}
      else if ((strncasecmp (input_line_pointer, "startof.", 8) == 0
		&& ! is_part_of_name (input_line_pointer[8]))
	       || (strncasecmp (input_line_pointer, "sizeof.", 7) == 0
		   && ! is_part_of_name (input_line_pointer[7])))
	{
	  int start;

	  start = (input_line_pointer[1] == 't'
		   || input_line_pointer[1] == 'T');
	  input_line_pointer += start ? 8 : 7;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer != '(')
	    as_bad (_("syntax error in .startof. or .sizeof."));
	  else
	    {
	      char *buf;

	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      name = input_line_pointer;
	      c = get_symbol_end ();

	      buf = (char *) xmalloc (strlen (name) + 10);
	      if (start)
		sprintf (buf, ".startof.%s", name);
	      else
		sprintf (buf, ".sizeof.%s", name);
	      symbolP = symbol_make (buf);
	      free (buf);

	      expressionP->X_op = O_symbol;
	      expressionP->X_add_symbol = symbolP;
	      expressionP->X_add_number = 0;

	      *input_line_pointer = c;
	      SKIP_WHITESPACE ();
	      if (*input_line_pointer != ')')
		as_bad (_("syntax error in .startof. or .sizeof."));
	      else
		++input_line_pointer;
	    }
	  break;
	}
      else
	{
	  goto isname;
	}

    case ',':
    eol:
      /* Can't imagine any other kind of operand.  */
      expressionP->X_op = O_absent;
      input_line_pointer--;
      break;

#ifdef TC_M68K
    case '%':
      if (! flag_m68k_mri)
	goto de_fault;
      integer_constant (2, expressionP);
      break;

    case '@@':
      if (! flag_m68k_mri)
	goto de_fault;
      integer_constant (8, expressionP);
      break;

    case ':':
      if (! flag_m68k_mri)
	goto de_fault;

      /* In MRI mode, this is a floating point constant represented
	 using hexadecimal digits.  */

      ++input_line_pointer;
      integer_constant (16, expressionP);
      break;

    case '*':
      if (! flag_m68k_mri || is_part_of_name (*input_line_pointer))
	goto de_fault;

      current_location (expressionP);
      break;
#endif

    default:
#ifdef TC_M68K
    de_fault:
#endif
      if (is_name_beginner (c))	/* Here if did not begin with a digit.  */
	{
	  /* Identifier begins here.
	     This is kludged for speed, so code is repeated.  */
	isname:
	  name = --input_line_pointer;
	  c = get_symbol_end ();

#ifdef md_parse_name
	  /* This is a hook for the backend to parse certain names
	     specially in certain contexts.  If a name always has a
	     specific value, it can often be handled by simply
	     entering it in the symbol table.  */
	  if (md_parse_name (name, expressionP, &c))
	    {
	      *input_line_pointer = c;
	      break;
	    }
#endif

#ifdef TC_I960
	  /* The MRI i960 assembler permits
	         lda sizeof code,g13
	     FIXME: This should use md_parse_name.  */
	  if (flag_mri
	      && (strcasecmp (name, "sizeof") == 0
		  || strcasecmp (name, "startof") == 0))
	    {
	      int start;
	      char *buf;

	      start = (name[1] == 't'
		       || name[1] == 'T');

	      *input_line_pointer = c;
	      SKIP_WHITESPACE ();

	      name = input_line_pointer;
	      c = get_symbol_end ();

	      buf = (char *) xmalloc (strlen (name) + 10);
	      if (start)
		sprintf (buf, ".startof.%s", name);
	      else
		sprintf (buf, ".sizeof.%s", name);
	      symbolP = symbol_make (buf);
	      free (buf);

	      expressionP->X_op = O_symbol;
	      expressionP->X_add_symbol = symbolP;
	      expressionP->X_add_number = 0;

	      *input_line_pointer = c;
	      SKIP_WHITESPACE ();

	      break;
	    }
#endif

	  symbolP = symbol_find_or_make (name);

	  /* If we have an absolute symbol or a reg, then we know its
	     value now.  */
	  segment = S_GET_SEGMENT (symbolP);
	  if (segment == absolute_section)
	    {
	      expressionP->X_op = O_constant;
	      expressionP->X_add_number = S_GET_VALUE (symbolP);
	    }
	  else if (segment == reg_section)
	    {
	      expressionP->X_op = O_register;
	      expressionP->X_add_number = S_GET_VALUE (symbolP);
	    }
	  else
	    {
	      expressionP->X_op = O_symbol;
	      expressionP->X_add_symbol = symbolP;
	      expressionP->X_add_number = 0;
	    }
	  *input_line_pointer = c;
	}
      else
	{
	target_op:
	  /* Let the target try to parse it.  Success is indicated by changing
	     the X_op field to something other than O_absent and pointing
	     input_line_pointer past the expression.  If it can't parse the
	     expression, X_op and input_line_pointer should be unchanged.  */
	  expressionP->X_op = O_absent;
	  --input_line_pointer;
	  md_operand (expressionP);
	  if (expressionP->X_op == O_absent)
	    {
	      ++input_line_pointer;
	      as_bad (_("bad expression"));
	      expressionP->X_op = O_constant;
	      expressionP->X_add_number = 0;
	    }
	}
      break;
    }

  /* It is more 'efficient' to clean up the expressionS when they are
     created.  Doing it here saves lines of code.  */
  clean_up_expression (expressionP);
  SKIP_WHITESPACE ();		/* -> 1st char after operand.  */
  know (*input_line_pointer != ' ');

  /* The PA port needs this information.  */
  if (expressionP->X_add_symbol)
    symbol_mark_used (expressionP->X_add_symbol);

  switch (expressionP->X_op)
    {
    default:
      return absolute_section;
    case O_symbol:
      return S_GET_SEGMENT (expressionP->X_add_symbol);
    case O_register:
      return reg_section;
    }
}

/* Internal.  Simplify a struct expression for use by expr ().  */

/* In:	address of an expressionS.
	The X_op field of the expressionS may only take certain values.
	Elsewise we waste time special-case testing. Sigh. Ditto SEG_ABSENT.

   Out:	expressionS may have been modified:
	Unused fields zeroed to help expr ().  */

static void
clean_up_expression (expressionS *expressionP)
{
  switch (expressionP->X_op)
    {
    case O_illegal:
    case O_absent:
      expressionP->X_add_number = 0;
      /* Fall through.  */
    case O_big:
    case O_constant:
    case O_register:
      expressionP->X_add_symbol = NULL;
      /* Fall through.  */
    case O_symbol:
    case O_uminus:
    case O_bit_not:
      expressionP->X_op_symbol = NULL;
      break;
    default:
      break;
    }
}

/* Expression parser.  */

/* We allow an empty expression, and just assume (absolute,0) silently.
   Unary operators and parenthetical expressions are treated as operands.
   As usual, Q==quantity==operand, O==operator, X==expression mnemonics.

   We used to do an aho/ullman shift-reduce parser, but the logic got so
   warped that I flushed it and wrote a recursive-descent parser instead.
   Now things are stable, would anybody like to write a fast parser?
   Most expressions are either register (which does not even reach here)
   or 1 symbol. Then "symbol+constant" and "symbol-symbol" are common.
   So I guess it doesn't really matter how inefficient more complex expressions
   are parsed.

   After expr(RANK,resultP) input_line_pointer->operator of rank <= RANK.
   Also, we have consumed any leading or trailing spaces (operand does that)
   and done all intervening operators.

   This returns the segment of the result, which will be
   absolute_section or the segment of a symbol.  */

#undef __
#define __ O_illegal

/* Maps ASCII -> operators.  */
static const operatorT op_encoding[256] = {
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,

  __, O_bit_or_not, __, __, __, O_modulus, O_bit_and, __,
  __, __, O_multiply, O_add, __, O_subtract, __, O_divide,
  __, __, __, __, __, __, __, __,
  __, __, __, __, O_lt, __, O_gt, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __,
  __, __, __,
#ifdef NEED_INDEX_OPERATOR
  O_index,
#else
  __,
#endif
  __, __, O_bit_exclusive_or, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __,
  __, __, __, __, O_bit_inclusive_or, __, __, __,

  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
  __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __
};

/* Rank	Examples
   0	operand, (expression)
   1	||
   2	&&
   3	== <> < <= >= >
   4	+ -
   5	used for * / % in MRI mode
   6	& ^ ! |
   7	* / % << >>
   8	unary - unary ~
*/
static operator_rankT op_rank[] = {
  0,	/* O_illegal */
  0,	/* O_absent */
  0,	/* O_constant */
  0,	/* O_symbol */
  0,	/* O_symbol_rva */
  0,	/* O_register */
  0,	/* O_big */
  9,	/* O_uminus */
  9,	/* O_bit_not */
  9,	/* O_logical_not */
  8,	/* O_multiply */
  8,	/* O_divide */
  8,	/* O_modulus */
  8,	/* O_left_shift */
  8,	/* O_right_shift */
  7,	/* O_bit_inclusive_or */
  7,	/* O_bit_or_not */
  7,	/* O_bit_exclusive_or */
  7,	/* O_bit_and */
  5,	/* O_add */
  5,	/* O_subtract */
  4,	/* O_eq */
  4,	/* O_ne */
  4,	/* O_lt */
  4,	/* O_le */
  4,	/* O_ge */
  4,	/* O_gt */
  3,	/* O_logical_and */
  2,	/* O_logical_or */
  1,	/* O_index */
  0,	/* O_md1 */
  0,	/* O_md2 */
  0,	/* O_md3 */
  0,	/* O_md4 */
  0,	/* O_md5 */
  0,	/* O_md6 */
  0,	/* O_md7 */
  0,	/* O_md8 */
  0,	/* O_md9 */
  0,	/* O_md10 */
  0,	/* O_md11 */
  0,	/* O_md12 */
  0,	/* O_md13 */
  0,	/* O_md14 */
  0,	/* O_md15 */
  0,	/* O_md16 */
};

/* Unfortunately, in MRI mode for the m68k, multiplication and
   division have lower precedence than the bit wise operators.  This
   function sets the operator precedences correctly for the current
   mode.  Also, MRI uses a different bit_not operator, and this fixes
   that as well.  */

#define STANDARD_MUL_PRECEDENCE 8
#define MRI_MUL_PRECEDENCE 6

void
expr_set_precedence (void)
{
  if (flag_m68k_mri)
    {
      op_rank[O_multiply] = MRI_MUL_PRECEDENCE;
      op_rank[O_divide] = MRI_MUL_PRECEDENCE;
      op_rank[O_modulus] = MRI_MUL_PRECEDENCE;
    }
  else
    {
      op_rank[O_multiply] = STANDARD_MUL_PRECEDENCE;
      op_rank[O_divide] = STANDARD_MUL_PRECEDENCE;
      op_rank[O_modulus] = STANDARD_MUL_PRECEDENCE;
    }
}

/* Initialize the expression parser.  */

void
expr_begin (void)
{
  expr_set_precedence ();

  /* Verify that X_op field is wide enough.  */
  {
    expressionS e;
    e.X_op = O_max;
    assert (e.X_op == O_max);
  }
}

/* Return the encoding for the operator at INPUT_LINE_POINTER, and
   sets NUM_CHARS to the number of characters in the operator.
   Does not advance INPUT_LINE_POINTER.  */

static inline operatorT
operator (int *num_chars)
{
  int c;
  operatorT ret;

  c = *input_line_pointer & 0xff;
  *num_chars = 1;

  if (is_end_of_line[c])
    return O_illegal;

  switch (c)
    {
    default:
      return op_encoding[c];

    case '+':
    case '-':
      /* Do not allow a++b and a--b to be a + (+b) and a - (-b)
	 Disabled, since the preprocessor removes whitespace.  */
      if (1 || input_line_pointer[1] != c)
	return op_encoding[c];
      return O_illegal;

    case '<':
      switch (input_line_pointer[1])
	{
	default:
	  return op_encoding[c];
	case '<':
	  ret = O_left_shift;
	  break;
	case '>':
	  ret = O_ne;
	  break;
	case '=':
	  ret = O_le;
	  break;
	}
      *num_chars = 2;
      return ret;

    case '=':
      if (input_line_pointer[1] != '=')
	return op_encoding[c];

      *num_chars = 2;
      return O_eq;

    case '>':
      switch (input_line_pointer[1])
	{
	default:
	  return op_encoding[c];
	case '>':
	  ret = O_right_shift;
	  break;
	case '=':
	  ret = O_ge;
	  break;
	}
      *num_chars = 2;
      return ret;

    case '!':
      /* We accept !! as equivalent to ^ for MRI compatibility.  */
      if (input_line_pointer[1] != '!')
	{
	  if (flag_m68k_mri)
	    return O_bit_inclusive_or;
	  return op_encoding[c];
	}
      *num_chars = 2;
      return O_bit_exclusive_or;

    case '|':
      if (input_line_pointer[1] != '|')
	return op_encoding[c];

      *num_chars = 2;
      return O_logical_or;

    case '&':
      if (input_line_pointer[1] != '&')
	return op_encoding[c];

      *num_chars = 2;
      return O_logical_and;
    }

  /* NOTREACHED  */
}

/* Parse an expression.  */

segT
expr (int rankarg,		/* Larger # is higher rank.  */
      expressionS *resultP	/* Deliver result here.  */)
{
  operator_rankT rank = (operator_rankT) rankarg;
  segT retval;
  expressionS right;
  operatorT op_left;
  operatorT op_right;
  int op_chars;

  know (rank >= 0);

  /* Save the value of dot for the fixup code.  */
  if (rank == 0)
    dot_value = frag_now_fix ();

  retval = operand (resultP);

  /* operand () gobbles spaces.  */
  know (*input_line_pointer != ' ');

  op_left = operator (&op_chars);
  while (op_left != O_illegal && op_rank[(int) op_left] > rank)
    {
      segT rightseg;

      input_line_pointer += op_chars;	/* -> after operator.  */

      rightseg = expr (op_rank[(int) op_left], &right);
      if (right.X_op == O_absent)
	{
	  as_warn (_("missing operand; zero assumed"));
	  right.X_op = O_constant;
	  right.X_add_number = 0;
	  right.X_add_symbol = NULL;
	  right.X_op_symbol = NULL;
	}

      know (*input_line_pointer != ' ');

      if (op_left == O_index)
	{
	  if (*input_line_pointer != ']')
	    as_bad ("missing right bracket");
	  else
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	    }
	}

      op_right = operator (&op_chars);

      know (op_right == O_illegal
	    || op_rank[(int) op_right] <= op_rank[(int) op_left]);
      know ((int) op_left >= (int) O_multiply
	    && (int) op_left <= (int) O_logical_or);

      /* input_line_pointer->after right-hand quantity.  */
      /* left-hand quantity in resultP.  */
      /* right-hand quantity in right.  */
      /* operator in op_left.  */

      if (resultP->X_op == O_big)
	{
	  if (resultP->X_add_number > 0)
	    as_warn (_("left operand is a bignum; integer 0 assumed"));
	  else
	    as_warn (_("left operand is a float; integer 0 assumed"));
	  resultP->X_op = O_constant;
	  resultP->X_add_number = 0;
	  resultP->X_add_symbol = NULL;
	  resultP->X_op_symbol = NULL;
	}
      if (right.X_op == O_big)
	{
	  if (right.X_add_number > 0)
	    as_warn (_("right operand is a bignum; integer 0 assumed"));
	  else
	    as_warn (_("right operand is a float; integer 0 assumed"));
	  right.X_op = O_constant;
	  right.X_add_number = 0;
	  right.X_add_symbol = NULL;
	  right.X_op_symbol = NULL;
	}

      /* Optimize common cases.  */
#ifdef md_optimize_expr
      if (md_optimize_expr (resultP, op_left, &right))
	{
	  /* Skip.  */
	  ;
	}
      else
#endif
      if (op_left == O_add && right.X_op == O_constant)
	{
	  /* X + constant.  */
	  resultP->X_add_number += right.X_add_number;
	}
      /* This case comes up in PIC code.  */
      else if (op_left == O_subtract
	       && right.X_op == O_symbol
	       && resultP->X_op == O_symbol
	       && (symbol_get_frag (right.X_add_symbol)
		   == symbol_get_frag (resultP->X_add_symbol))
	       && (SEG_NORMAL (rightseg)
		   || right.X_add_symbol == resultP->X_add_symbol))
	{
	  resultP->X_add_number -= right.X_add_number;
	  resultP->X_add_number += (S_GET_VALUE (resultP->X_add_symbol)
				    - S_GET_VALUE (right.X_add_symbol));
	  resultP->X_op = O_constant;
	  resultP->X_add_symbol = 0;
	}
      else if (op_left == O_subtract && right.X_op == O_constant)
	{
	  /* X - constant.  */
	  resultP->X_add_number -= right.X_add_number;
	}
      else if (op_left == O_add && resultP->X_op == O_constant)
	{
	  /* Constant + X.  */
	  resultP->X_op = right.X_op;
	  resultP->X_add_symbol = right.X_add_symbol;
	  resultP->X_op_symbol = right.X_op_symbol;
	  resultP->X_add_number += right.X_add_number;
	  retval = rightseg;
	}
      else if (resultP->X_op == O_constant && right.X_op == O_constant)
	{
	  /* Constant OP constant.  */
	  offsetT v = right.X_add_number;
	  if (v == 0 && (op_left == O_divide || op_left == O_modulus))
	    {
	      as_warn (_("division by zero"));
	      v = 1;
	    }
	  switch (op_left)
	    {
	    default:			abort ();
	    case O_multiply:		resultP->X_add_number *= v; break;
	    case O_divide:		resultP->X_add_number /= v; break;
	    case O_modulus:		resultP->X_add_number %= v; break;
	    case O_left_shift:		resultP->X_add_number <<= v; break;
	    case O_right_shift:
	      /* We always use unsigned shifts, to avoid relying on
		 characteristics of the compiler used to compile gas.  */
	      resultP->X_add_number =
		(offsetT) ((valueT) resultP->X_add_number >> (valueT) v);
	      break;
	    case O_bit_inclusive_or:	resultP->X_add_number |= v; break;
	    case O_bit_or_not:		resultP->X_add_number |= ~v; break;
	    case O_bit_exclusive_or:	resultP->X_add_number ^= v; break;
	    case O_bit_and:		resultP->X_add_number &= v; break;
	    case O_add:			resultP->X_add_number += v; break;
	    case O_subtract:		resultP->X_add_number -= v; break;
	    case O_eq:
	      resultP->X_add_number =
		resultP->X_add_number == v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_ne:
	      resultP->X_add_number =
		resultP->X_add_number != v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_lt:
	      resultP->X_add_number =
		resultP->X_add_number <  v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_le:
	      resultP->X_add_number =
		resultP->X_add_number <= v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_ge:
	      resultP->X_add_number =
		resultP->X_add_number >= v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_gt:
	      resultP->X_add_number =
		resultP->X_add_number >  v ? ~ (offsetT) 0 : 0;
	      break;
	    case O_logical_and:
	      resultP->X_add_number = resultP->X_add_number && v;
	      break;
	    case O_logical_or:
	      resultP->X_add_number = resultP->X_add_number || v;
	      break;
	    }
	}
      else if (resultP->X_op == O_symbol
	       && right.X_op == O_symbol
	       && (op_left == O_add
		   || op_left == O_subtract
		   || (resultP->X_add_number == 0
		       && right.X_add_number == 0)))
	{
	  /* Symbol OP symbol.  */
	  resultP->X_op = op_left;
	  resultP->X_op_symbol = right.X_add_symbol;
	  if (op_left == O_add)
	    resultP->X_add_number += right.X_add_number;
	  else if (op_left == O_subtract)
	    {
	      resultP->X_add_number -= right.X_add_number;
	      if (retval == rightseg && SEG_NORMAL (retval))
		{
		  retval = absolute_section;
		  rightseg = absolute_section;
		}
	    }
	}
      else
	{
	  /* The general case.  */
	  resultP->X_add_symbol = make_expr_symbol (resultP);
	  resultP->X_op_symbol = make_expr_symbol (&right);
	  resultP->X_op = op_left;
	  resultP->X_add_number = 0;
	  resultP->X_unsigned = 1;
	}

      if (retval != rightseg)
	{
	  if (! SEG_NORMAL (retval))
	    {
	      if (retval != undefined_section || SEG_NORMAL (rightseg))
		retval = rightseg;
	    }
	  else if (SEG_NORMAL (rightseg)
#ifdef DIFF_EXPR_OK
		   && op_left != O_subtract
#endif
		   )
	    as_bad (_("operation combines symbols in different segments"));
	}

      op_left = op_right;
    }				/* While next operator is >= this rank.  */

  /* The PA port needs this information.  */
  if (resultP->X_add_symbol)
    symbol_mark_used (resultP->X_add_symbol);

  return resultP->X_op == O_constant ? absolute_section : retval;
}

/* This lives here because it belongs equally in expr.c & read.c.
   expr.c is just a branch office read.c anyway, and putting it
   here lessens the crowd at read.c.

   Assume input_line_pointer is at start of symbol name.
   Advance input_line_pointer past symbol name.
   Turn that character into a '\0', returning its former value.
   This allows a string compare (RMS wants symbol names to be strings)
   of the symbol name.
   There will always be a char following symbol name, because all good
   lines end in end-of-line.  */

char
get_symbol_end (void)
{
  char c;

  /* We accept \001 in a name in case this is being called with a
     constructed string.  */
  if (is_name_beginner (c = *input_line_pointer++) || c == '\001')
    {
      while (is_part_of_name (c = *input_line_pointer++)
	     || c == '\001')
	;
      if (is_name_ender (c))
	c = *input_line_pointer++;
    }
  *--input_line_pointer = 0;
  return (c);
}

unsigned int
get_single_number (void)
{
  expressionS exp;
  operand (&exp);
  return exp.X_add_number;
}
@


1.10
log
@Don't reject '++' and '--' in expressions.  Some versions of gcc emit these.
Fix found upstream.

ok miod@@, martynas@@
@
text
@d1088 9
a1106 1
		int nonzero = 0;
d1108 5
a1112 6
		  {
		    if (generic_bignum[i])
		      nonzero = 1;
		    generic_bignum[i] = 0;
		  }
		generic_bignum[0] = nonzero;
@


1.9
log
@Backport fix of negative bignums from binutils 2.16:

2004-08-10  Mark Mitchell  <mark@@codesourcery.com>

        * expr.c (operand): Handle the "~", "-", and "!" operators applied
        to bignums.

http://sourceware.org/cgi-bin/cvsweb.cgi/src/gas/expr.c.diff?cvsroot=src&only\
_with_tag=MAIN&r2=1.52&r1=1.51&f=u

Fixes the problem mentioned here:

http://llvm.org/bugs/show_bug.cgi?id=6528

ok jsg@@, miod@@
@
text
@d1024 3
a1026 2
      /* Do not accept ++e as +(+e) */
      if (*input_line_pointer == '+')
d1045 3
a1047 2
        /* Do not accept --e as -(-e) */
	if (c == '-' && *input_line_pointer == '-')
d1585 3
a1587 2
      /* Do not allow a++b and a--b to be a + (+b) and a - (-b) */
      if (input_line_pointer[1] != c)
@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d1077 29
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d35 2
a36 2
static void floating_constant PARAMS ((expressionS * expressionP));
static valueT generic_bignum_to_int32 PARAMS ((void));
d38 1
a38 1
static valueT generic_bignum_to_int64 PARAMS ((void));
d40 6
a45 6
static void integer_constant PARAMS ((int radix, expressionS * expressionP));
static void mri_char_constant PARAMS ((expressionS *));
static void current_location PARAMS ((expressionS *));
static void clean_up_expression PARAMS ((expressionS * expressionP));
static segT operand PARAMS ((expressionS *));
static operatorT operator PARAMS ((int *));
d66 1
a66 2
make_expr_symbol (expressionP)
     expressionS *expressionP;
a68 1
  const char *fake;
a91 2
  fake = FAKE_LABEL_NAME;

d96 1
a96 1
  symbolP = symbol_create (fake,
d120 1
a120 4
expr_symbol_where (sym, pfile, pline)
     symbolS *sym;
     char **pfile;
     unsigned int *pline;
d150 1
a150 2
expr_build_uconstant (value)
     offsetT value;
d163 1
a163 3
expr_build_unary (op, s1)
     operatorT op;
     symbolS *s1;
d176 1
a176 4
expr_build_binary (op, s1, s2)
     operatorT op;
     symbolS *s1;
     symbolS *s2;
d190 1
a190 1
expr_build_dot ()
d220 1
a220 2
floating_constant (expressionP)
     expressionS *expressionP;
d247 1
a247 1
generic_bignum_to_int32 ()
d258 1
a258 1
generic_bignum_to_int64 ()
d273 1
a273 3
integer_constant (radix, expressionP)
     int radix;
     expressionS *expressionP;
d632 1
a632 2
mri_char_constant (expressionP)
     expressionS *expressionP;
d721 1
a721 2
current_location (expressionp)
     expressionS *expressionp;
a729 5
      symbolS *symbolp;

      symbolp = symbol_new (FAKE_LABEL_NAME, now_seg,
			    (valueT) frag_now_fix (),
			    frag_now);
d731 1
a731 1
      expressionp->X_add_symbol = symbolp;
d744 1
a744 2
operand (expressionP)
     expressionS *expressionP;
d1024 3
d1044 4
d1299 1
d1349 1
a1349 2
clean_up_expression (expressionP)
     expressionS *expressionP;
d1500 1
a1500 1
expr_set_precedence ()
d1519 1
a1519 1
expr_begin ()
d1536 1
a1536 2
operator (num_chars)
     int *num_chars;
d1552 7
d1631 2
a1632 3
expr (rankarg, resultP)
     int rankarg;	/* Larger # is higher rank.  */
     expressionS *resultP;	/* Deliver result here.  */
d1890 1
a1890 1
get_symbol_end ()
d1909 1
a1909 1
get_single_number ()
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   1999, 2000, 2001
a27 1
#include <ctype.h>
d32 1
d81 2
a82 2
         generic_floating_point_number or generic_bignum, and we are
         going to lose it if we haven't already.  */
d84 1
a84 1
	as_bad (_("bignum invalid; zero assumed"));
d86 1
a86 1
	as_bad (_("floating point number invalid; zero assumed"));
d108 1
a108 1
    resolve_symbol_value (symbolP, 1);
d246 1
a246 1
	  as_bad (_("bad floating-point constant: exponent overflow, probably assembling junk"));
d250 2
a251 1
	  as_bad (_("bad floating-point constant: unknown error code=%d."), error_code);
d332 3
a334 5
         radix.  For that matter, it might actually be a floating
         point constant.  */
      for (suffix = input_line_pointer;
	   isalnum ((unsigned char) *suffix);
	   suffix++)
d348 1
a348 2
	  if (islower ((unsigned char) c))
	    c = toupper (c);
d404 1
a404 1
         This example is equivalent to 0x00000333000000001234567800000001.  */
d428 1
a428 1
	    as_bad (_("A bignum with underscores may not have more than 8 hex digits in any word."));
d451 1
a451 1
	as_bad (_("A bignum with underscores must have exactly 4 words."));
d574 1
a574 1
	      as_bad (_("backw. ref to unknown label \"%d:\", 0 assumed."),
d684 2
a685 2
             last one to make it match the earlier ones.  If there is
             only one, we can just use the value directly.  */
d697 1
a697 1
      as_bad (_("Character constant too large"));
d762 1
a762 1
   Out:	A expressionS.
d806 1
a806 1
                        expressionP);
d811 3
d831 1
a831 1
	  /* Check for a hex constant.  */
d834 1
a834 1
	  if (*s == 'h' || *s == 'H')
d862 1
a862 2
	      expressionP->X_add_number =
		- (isupper ((unsigned char) c) ? tolower (c) : c);
d984 1
a984 2
	  expressionP->X_add_number =
	    - (isupper ((unsigned char) c) ? tolower (c) : c);
d1012 1
a1012 1
	    as_bad (_("Missing '%c' assumed"), c == '(' ? ')' : ']');
d1082 12
d1115 1
a1115 1
         DOLLAR_DOT is defined.  */
d1123 1
a1123 1
             hexadecimal constant.  */
d1214 1
a1214 1
         using hexadecimal digits.  */
d1242 4
a1245 4
             specially in certain contexts.  If a name always has a
             specific value, it can often be handled by simply
             entering it in the symbol table.  */
	  if (md_parse_name (name, expressionP))
d1326 1
a1326 1
	      as_bad (_("Bad expression"));
d1357 1
a1357 1
/* In:	address of a expressionS.
a1361 2
	'foo-foo' symbol references cancelled to 0, which changes X_op
	from O_subtract to O_constant.
a1383 17
    case O_subtract:
      if (expressionP->X_op_symbol == expressionP->X_add_symbol
	  || ((symbol_get_frag (expressionP->X_op_symbol)
	       == symbol_get_frag (expressionP->X_add_symbol))
	      && SEG_NORMAL (S_GET_SEGMENT (expressionP->X_add_symbol))
	      && (S_GET_VALUE (expressionP->X_op_symbol)
		  == S_GET_VALUE (expressionP->X_add_symbol))))
	{
	  addressT diff = (S_GET_VALUE (expressionP->X_add_symbol)
			   - S_GET_VALUE (expressionP->X_op_symbol));

	  expressionP->X_op = O_constant;
	  expressionP->X_add_symbol = NULL;
	  expressionP->X_op_symbol = NULL;
	  expressionP->X_add_number += diff;
	}
      break;
d1395 1
a1395 1
   We used to do a aho/ullman shift-reduce parser, but the logic got so
d1451 1
a1451 1
   3	= <> < <= >= >
d1655 4
a1693 15
      if (retval == undefined_section)
	{
	  if (SEG_NORMAL (rightseg))
	    retval = rightseg;
	}
      else if (! SEG_NORMAL (retval))
	retval = rightseg;
      else if (SEG_NORMAL (rightseg)
	       && retval != rightseg
#ifdef DIFF_EXPR_OK
	       && op_left != O_subtract
#endif
	       )
	as_bad (_("operation combines symbols in different segments"));

d1749 2
a1750 2
	       && SEG_NORMAL (S_GET_SEGMENT (right.X_add_symbol)))

d1790 1
a1790 1
                 characteristics of the compiler used to compile gas.  */
d1845 8
a1852 1
	    resultP->X_add_number -= right.X_add_number;
d1862 15
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d21 1
a21 1
   02111-1307, USA. */
d23 4
a26 6
/*
 * This is really a branch office of as-read.c. I split it out to clearly
 * distinguish the world of expressions from the world of statements.
 * (It also gives smaller files to re-compile.)
 * Here, "operand"s are of expressions, not instructions.
 */
d45 1
a45 1
static operatorT operator PARAMS ((void));
d52 1
a52 2
struct expr_symbol_line
{
d211 2
a212 4
/*
 * Build any floating-point literal here.
 * Also build any bignum literal here.
 */
d220 7
a226 7
FLONUM_TYPE generic_floating_point_number =
{
  &generic_bignum[6],		/* low (JF: Was 0) */
  &generic_bignum[SIZE_OF_LARGE_NUMBER + 6 - 1], /* high JF: (added +6) */
  0,				/* leader */
  0,				/* exponent */
  0				/* sign */
d228 2
a229 1
/* If nonzero, we've been asked to assemble nan, +inf or -inf */
d236 1
a236 2
  /* input_line_pointer->*/
  /* floating-point constant. */
d254 2
a255 2
  /* input_line_pointer->just after constant, */
  /* which may point to whitespace. */
d259 2
a260 2
static valueT 
generic_bignum_to_int32 () 
d270 2
a271 2
static valueT 
generic_bignum_to_int64 () 
d273 8
a280 8
  valueT number = 
	   ((((((((valueT) generic_bignum[3] & LITTLENUM_MASK)
		 << LITTLENUM_NUMBER_OF_BITS)
	        | ((valueT) generic_bignum[2] & LITTLENUM_MASK))
	       << LITTLENUM_NUMBER_OF_BITS)
	      | ((valueT) generic_bignum[1] & LITTLENUM_MASK))
	     << LITTLENUM_NUMBER_OF_BITS)
	    | ((valueT) generic_bignum[0] & LITTLENUM_MASK));
d290 1
a290 1
  char *start;		/* start of number. */
d293 6
a298 6
  valueT number;	/* offset or (absolute) value */
  short int digit;	/* value of next digit in current radix */
  short int maxdig = 0;/* highest permitted digit value. */
  int too_many_digits = 0;	/* if we see >= this number of */
  char *name;		/* points to name of symbol */
  symbolS *symbolP;	/* points to symbol */
d300 1
a300 1
  int small;			/* true if fits in 32 bits. */
d302 1
a302 1
  /* May be bignum, or may fit in 32 bits. */
d315 1
a315 1
     number.  The cavalier approach is for speed in ordinary cases. */
d388 1
a388 1
      too_many_digits = (valuesize + 11) / 4; /* very rough */
d399 2
a400 2
  /* c contains character after number. */
  /* input_line_pointer->char after c. */
d403 1
a403 1
  if (radix == 16 && c == '_') 
d410 1
a410 1
      input_line_pointer = start;	/*->1st digit. */
d414 1
a414 1
      for (c = '_'; c == '_'; num_little_digits+=2)
d417 2
a418 2
	  /* Convert one 64-bit word. */
	  int ndigit = 0; 
d429 1
a429 1
	  if (ndigit > 8) 
d432 2
a433 1
	  /* Add this chunk to the bignum.  Shift things down 2 little digits.*/
d435 4
a438 2
	  for (i = min (num_little_digits + 1, SIZE_OF_LARGE_NUMBER - 1); i >= 2; i--)
	    generic_bignum[i] = generic_bignum[i-2];
d440 1
a440 1
	  /* Add the new digits as the least significant new ones. */
d445 1
a445 1
      /* Again, c is char after number, input_line_pointer->after c. */
d456 3
a458 3
       * us a change to fit this constant into a small number.
       */
      while (generic_bignum[num_little_digits-1] == 0 && num_little_digits > 1)
d460 1
a460 1
	
d463 1
a463 1
	  /* will fit into 32 bits. */
d478 3
a480 1
	  number = num_little_digits; /* number of littlenums in the bignum. */
d485 3
a487 5
      /*
       * we saw a lot of digits. manufacture a bignum the hard way.
       */
      LITTLENUM_TYPE *leader;	/*->high order littlenum of the bignum. */
      LITTLENUM_TYPE *pointer;	/*->littlenum we are frobbing now. */
d495 1
a495 1
      input_line_pointer = start;	/*->1st digit. */
d497 3
a499 7
      for (;
	   (carry = hex_value (c)) < maxdig;
	   c = *input_line_pointer++)
	{
	  for (pointer = generic_bignum;
	       pointer <= leader;
	       pointer++)
d511 1
a511 1
		  /* room to grow a longer bignum. */
d516 2
a517 2
      /* again, c is char after number, */
      /* input_line_pointer->after c. */
d521 1
a521 1
	  /* will fit into 32 bits. */
d535 2
a536 1
	  number = leader - generic_bignum + 1;	/* number of littlenums in the bignum. */
d540 2
a541 2
  if ((NUMBERS_WITH_SUFFIX || flag_m68k_mri) 
      && suffix != NULL 
d547 5
a551 6
      /*
       * here with number, in correct radix. c is the next char.
       * note that unlike un*x, we allow "011f" "0x9f" to
       * both mean the same as the (conventional) "9f". this is simply easier
       * than checking for strict canonical form. syntax sux!
       */
d555 2
a556 4
	  /*
	   * backward ref to local label.
	   * because it is backward, expect it to be defined.
	   */
d560 1
a560 1
	  /* seen before, or symbol is defined: ok */
d564 2
a565 2
	      /* local labels are never absolute. don't waste time
		 checking absoluteness. */
d573 1
a573 1
	      /* either not seen or not defined. */
d585 7
a591 8
	  /*
	   * forward reference. expect symbol to be undefined or
	   * unknown. undefined: seen it before. unknown: never seen
	   * it before.
	   * construct a local label name, then an undefined symbol.
	   * don't create a xseg frag for it: caller may do that.
	   * just return it as never seen before.
	   */
d594 1
a594 1
	  /* we have no need to check symbol properties. */
d596 1
a596 1
	  /* since "know" puts its arg into a "string", we
d635 2
a636 2
	  input_line_pointer--;	/* restore following character. */
	}			/* really just a number */
d640 1
a640 1
      /* not a small number */
d642 2
a643 2
      expressionP->X_add_number = number;	/* number of littlenums */
      input_line_pointer--;	/*->char following number. */
d761 6
a766 10
/*
 * Summary of operand().
 *
 * in:	Input_line_pointer points to 1st char of operand, which may
 *	be a space.
 *
 * out:	A expressionS.
 *	The operand may have been empty: in this case X_op == O_absent.
 *	Input_line_pointer->(next non-blank) char after operand.
 */
d773 2
a774 2
  symbolS *symbolP;	/* points to symbol */
  char *name;		/* points to name of symbol */
d785 1
a785 1
  /* digits, assume it is a bignum. */
d787 5
a791 2
  SKIP_WHITESPACE ();		/* leading whitespace is part of operand. */
  c = *input_line_pointer++;	/* input_line_pointer->past char in c. */
d806 2
a807 2
      integer_constant ((NUMBERS_WITH_SUFFIX || flag_m68k_mri) 
                        ? 0 : 10,
d811 12
d824 1
a824 1
      /* non-decimal radix */
d839 1
a839 1
        }
d866 1
a866 1
	      /* The string was only zero */
d918 2
a919 2
                            ? 0 : 8, 
                            expressionP);
d941 1
a941 1
		      /* looks like a difference expression */
d945 1
a945 1
                         end of operand. */
d964 1
a964 1
	      /* fall through */
d1004 1
a1004 1
      /* didn't begin with digit & not a name */
d1006 3
a1008 3
      /* Expression() will pass trailing whitespace */
      if ((c == '(' && *input_line_pointer++ != ')')
	  || (c == '[' && *input_line_pointer++ != ']'))
d1010 4
a1013 2
	  as_bad (_("Missing ')' assumed"));
	  input_line_pointer--;
d1015 2
d1018 1
a1018 1
      /* here with input_line_pointer->char after "(...)" */
d1037 1
a1037 1
	     ESCAPEMENT is permitted for a single quote. The next
d1039 1
a1039 1
	     of the operand. VERY KINKY.  */
d1060 1
a1060 1
      /* ~ is permitted to start a label on the Delta.  */
d1069 1
a1069 1
	    /* input_line_pointer -> char after operand */
d1073 3
a1075 2
		/* Notice: '-' may overflow: no warning is given. This is
		   compatible with other people's assemblers. Sigh.  */
d1103 2
a1104 2
      /* $ is the program counter when in MRI mode, or when DOLLAR_DOT
         is defined.  */
d1111 1
a1111 1
	  /* In MRI mode, $ is also used as the prefix for a
d1177 1
a1178 2
    case '\n':
    case '\0':
d1180 1
a1180 1
      /* can't imagine any other kind of operand */
d1221 4
a1224 8
      if (is_end_of_line[(unsigned char) c])
	goto eol;
      if (is_name_beginner (c))	/* here if did not begin with a digit */
	{
	  /*
	   * Identifier begins here.
	   * This is kludged for speed, so code is repeated.
	   */
d1277 1
a1277 1
	    }	      
d1307 1
a1307 1
	     input_line_pointer passed the expression.  If it can't parse the
d1323 2
a1324 4
  /*
   * It is more 'efficient' to clean up the expressionS when they are created.
   * Doing it here saves lines of code.
   */
d1326 1
a1326 1
  SKIP_WHITESPACE ();		/*->1st char after operand. */
d1342 1
a1342 1
}				/* operand() */
d1344 1
a1344 1
/* Internal. Simplify a struct expression for use by expr() */
d1346 8
a1353 9
/*
 * In:	address of a expressionS.
 *	The X_op field of the expressionS may only take certain values.
 *	Elsewise we waste time special-case testing. Sigh. Ditto SEG_ABSENT.
 * Out:	expressionS may have been modified:
 *	'foo-foo' symbol references cancelled to 0,
 *		which changes X_op from O_subtract to O_constant.
 *	Unused fields zeroed to help expr().
 */
d1397 1
a1397 1
/* Expression parser. */
d1399 18
a1416 20
/*
 * We allow an empty expression, and just assume (absolute,0) silently.
 * Unary operators and parenthetical expressions are treated as operands.
 * As usual, Q==quantity==operand, O==operator, X==expression mnemonics.
 *
 * We used to do a aho/ullman shift-reduce parser, but the logic got so
 * warped that I flushed it and wrote a recursive-descent parser instead.
 * Now things are stable, would anybody like to write a fast parser?
 * Most expressions are either register (which does not even reach here)
 * or 1 symbol. Then "symbol+constant" and "symbol-symbol" are common.
 * So I guess it doesn't really matter how inefficient more complex expressions
 * are parsed.
 *
 * After expr(RANK,resultP) input_line_pointer->operator of rank <= RANK.
 * Also, we have consumed any leading or trailing spaces (operand does that)
 * and done all intervening operators.
 *
 * This returns the segment of the result, which will be
 * absolute_section or the segment of a symbol.
 */
d1421 2
a1422 3
static const operatorT op_encoding[256] =
{				/* maps ASCII->operators */

d1455 12
a1466 15

/*
 *	Rank	Examples
 *	0	operand, (expression)
 *	1	||
 *	2	&&
 *	3	= <> < <= >= >
 *	4	+ -
 *	5	used for * / % in MRI mode
 *	6	& ^ ! |
 *	7	* / % << >>
 *	8	unary - unary ~
 */
static operator_rankT op_rank[] =
{
d1473 1
a1473 1
  0,	/* O_bit */
d1521 2
a1522 2
#define STANDARD_MUL_PRECEDENCE (7)
#define MRI_MUL_PRECEDENCE (5)
d1556 3
a1558 3
/* Return the encoding for the operator at INPUT_LINE_POINTER.
   Advance INPUT_LINE_POINTER to the last character in the operator
   (i.e., don't change it for a single character operator).  */
d1561 2
a1562 1
operator ()
d1568 4
d1593 1
a1593 1
      ++input_line_pointer;
d1600 1
a1600 1
      ++input_line_pointer;
d1615 1
a1615 1
      ++input_line_pointer;
d1626 1
a1626 1
      ++input_line_pointer;
d1633 1
a1633 1
      ++input_line_pointer;
d1640 1
a1640 1
      ++input_line_pointer;
d1644 1
a1644 1
  /*NOTREACHED*/
d1651 2
a1652 2
     int rankarg;	/* Larger # is higher rank. */
     expressionS *resultP;	/* Deliver result here. */
d1659 1
d1665 2
a1666 1
  know (*input_line_pointer != ' ');	/* Operand() gobbles spaces. */
d1668 1
a1668 1
  op_left = operator ();
d1673 1
a1673 1
      input_line_pointer++;	/*->after 1st character of operator. */
d1713 1
a1713 1
      op_right = operator ();
d1715 2
a1716 1
      know (op_right == O_illegal || op_rank[(int) op_right] <= op_rank[(int) op_left]);
d1720 4
a1723 4
      /* input_line_pointer->after right-hand quantity. */
      /* left-hand quantity in resultP */
      /* right-hand quantity in right. */
      /* operator in op_left. */
d1749 8
d1877 1
a1877 1
    }				/* While next operator is >= this rank. */
d1886 12
a1897 15
/*
 *			get_symbol_end()
 *
 * This lives here because it belongs equally in expr.c & read.c.
 * Expr.c is just a branch office read.c anyway, and putting it
 * here lessens the crowd at read.c.
 *
 * Assume input_line_pointer is at start of symbol name.
 * Advance input_line_pointer past symbol name.
 * Turn that character into a '\0', returning its former value.
 * This allows a string compare (RMS wants symbol names to be strings)
 * of the symbol name.
 * There will always be a char following symbol name, because all good
 * lines end in end-of-line.
 */
a1916 1

a1922 1

a1923 2

/* end of expr.c */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996
d31 1
d37 4
d45 2
d71 1
d80 16
a95 2
  /* FIXME: This should be something which decode_local_label_name
     will handle.  */
d107 1
a107 1
  symbolP->sy_value = *expressionP;
d110 1
a110 1
    resolve_symbol_value (symbolP);
d146 67
d250 1
a250 1
	  as_bad ("bad floating-point constant: exponent overflow, probably assembling junk");
d254 1
a254 1
	  as_bad ("bad floating-point constant: unknown error code=%d.", error_code);
d263 26
d330 1
a330 1
  if (flag_m68k_mri && radix == 0)
d337 3
a339 1
      for (suffix = input_line_pointer; isalnum (*suffix); suffix++)
d353 1
a353 1
	  if (islower (c))
d392 1
a392 1
      too_many_digits = (valuesize + 12) / 4; /* very rough */
d406 77
a482 1
  if (!small)
d494 2
d527 1
a527 3
	  number =
	    ((generic_bignum[1] & LITTLENUM_MASK) << LITTLENUM_NUMBER_OF_BITS)
	    | (generic_bignum[0] & LITTLENUM_MASK);
d530 8
d544 3
a546 1
  if (flag_m68k_mri && suffix != NULL && input_line_pointer - 1 == suffix)
d583 1
a583 1
	      as_bad ("backw. ref to unknown label \"%d:\", 0 assumed.",
d707 1
a707 1
      as_bad ("Character constant too large");
d815 3
a817 1
      integer_constant (flag_m68k_mri ? 0 : 10, expressionP);
d823 1
a823 1
      if (flag_m68k_mri)
d836 1
a836 2
	}

d846 1
a846 1
	  if (flag_m68k_mri)
d858 2
a859 1
	      expressionP->X_add_number = -(isupper (c) ? tolower (c) : c);
d879 1
a879 1
	  if (LOCAL_LABELS_FB && ! flag_m68k_mri)
d881 9
a889 1
	      switch (input_line_pointer[1])
d891 4
a894 24
		case '+':
		case '-':
		  /* If unambiguously a difference expression, treat
		     it as one by indicating a label; otherwise, it's
		     always a binary number.  */
		  {
		    char *cp = input_line_pointer + 1;
		    while (strchr ("0123456789", *++cp))
		      ;
		    if (*cp == 'b' || *cp == 'f')
		      goto is_0b_label;
		  }
		  goto is_0b_binary;
		case '0':    case '1':
		  /* Some of our code elsewhere does permit digits
		     greater than the expected base; for consistency,
		     do the same here.  */
		case '2':    case '3':    case '4':    case '5':
		case '6':    case '7':    case '8':    case '9':
		  goto is_0b_binary;
		case 0:
		  goto is_0b_label;
		default:
		  goto is_0b_label;
d896 1
a896 6
	    is_0b_label:
	      input_line_pointer--;
	      integer_constant (10, expressionP);
	      break;
	    is_0b_binary:
	      ;
d898 1
d901 1
a901 1
	  if (flag_m68k_mri)
d914 3
a916 1
	  integer_constant (flag_m68k_mri ? 0 : 8, expressionP);
d926 2
a927 1
		  || (is_end_of_line[0xff & input_line_pointer[1]]))
d940 4
d947 1
a947 1
		    as_fatal ("expr.c(operand): bad atof_generic return val %d",
d967 1
a967 1
	  if (flag_m68k_mri)
d981 2
a982 1
	  expressionP->X_add_number = -(isupper (c) ? tolower (c) : c);
d998 1
d1000 1
d1007 1
a1007 1
	  as_bad ("Missing ')' assumed");
d1014 1
d1018 1
a1018 1
      as_bad ("EBCDIC constants are not supported");
d1025 1
d1045 1
d1051 5
a1056 1
    case '~':
d1088 1
a1088 1
	  as_warn ("Unary operator %c ignored because bad operand follows",
d1093 1
d1114 1
d1134 1
a1134 1
	    as_bad ("syntax error in .startof. or .sizeof.");
d1159 1
a1159 1
		as_bad ("syntax error in .startof. or .sizeof.");
d1178 1
d1208 1
d1211 1
d1213 1
d1312 1
a1312 1
	      as_bad ("Bad expression");
d1330 1
a1330 1
    expressionP->X_add_symbol->sy_used = 1;
d1377 2
a1378 2
	  || ((expressionP->X_op_symbol->sy_frag
	       == expressionP->X_add_symbol->sy_frag)
d1423 1
a1423 1
static operatorT op_encoding[256] =
d1436 7
a1442 1
  __, __, __, __, __, __, O_bit_exclusive_or, __,
d1480 39
a1518 22
  8,	/* O_uminus */
  8,	/* O_bit_not */
  8,	/* O_logical_not */
  7,	/* O_multiply */
  7,	/* O_divide */
  7,	/* O_modulus */
  7,	/* O_left_shift */
  7,	/* O_right_shift */
  6,	/* O_bit_inclusive_or */
  6,	/* O_bit_or_not */
  6,	/* O_bit_exclusive_or */
  6,	/* O_bit_and */
  4,	/* O_add */
  4,	/* O_subtract */
  3,	/* O_eq */
  3,	/* O_ne */
  3,	/* O_lt */
  3,	/* O_le */
  3,	/* O_ge */
  3,	/* O_gt */
  2,	/* O_logical_and */
  1	/* O_logical_or */
d1521 8
a1528 1
/* Initialize the expression parser.  */
d1531 1
a1531 1
expr_begin ()
a1532 2
  /* In MRI mode for the m68k, multiplication and division have lower
     precedence than the bit wise operators.  */
d1535 3
a1537 4
      op_rank[O_multiply] = 5;
      op_rank[O_divide] = 5;
      op_rank[O_modulus] = 5;
      op_encoding['"'] = O_bit_not;
d1539 14
d1572 1
a1572 1
  c = *input_line_pointer;
d1597 7
d1646 1
a1646 1
}	
d1651 2
a1652 2
expr (rank, resultP)
     operator_rankT rank;	/* Larger # is higher rank. */
d1655 1
d1677 1
a1677 1
	  as_warn ("missing operand; zero assumed");
d1686 11
d1710 1
a1710 1
	as_bad ("operation combines symbols in different segments");
d1725 4
a1728 2
	  as_warn ("left operand is a %s; integer 0 assumed",
		   resultP->X_add_number > 0 ? "bignum" : "float");
d1736 4
a1739 2
	  as_warn ("right operand is a %s; integer 0 assumed",
		   right.X_add_number > 0 ? "bignum" : "float");
d1756 2
a1757 2
	       && (right.X_add_symbol->sy_frag
		   == resultP->X_add_symbol->sy_frag)
d1761 1
a1761 1
	  resultP->X_add_number += right.X_add_number;
d1787 1
a1787 1
	      as_warn ("division by zero");
d1871 1
a1871 1
    resultP->X_add_symbol->sy_used = 1;
d1898 8
a1905 3
  while (is_part_of_name (c = *input_line_pointer++)
	 || c == '\001')
    ;
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@a32 1
#include "libiberty.h"
d1521 6
a1526 1
	    case O_right_shift:		resultP->X_add_number >>= v; break;
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d43 13
d67 1
d91 6
d99 25
d1015 12
d1030 1
a1030 1
	     */
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1987, 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
d170 1
a170 1
  if (flag_mri && radix == 0)
d298 1
a298 1
  if (flag_mri && suffix != NULL && input_line_pointer - 1 == suffix)
d567 1
a567 1
      integer_constant (flag_mri ? 0 : 10, expressionP);
d573 1
a573 1
      if (flag_mri)
d591 4
d597 1
a597 1
	  if (flag_mri)
d622 1
a622 1
	  if (flag_mri)
d629 1
a629 1
	  if (LOCAL_LABELS_FB)
d667 1
a667 1
	  if (flag_mri)
d680 1
a680 1
	  integer_constant (flag_mri ? 0 : 8, expressionP);
d726 6
d766 1
d771 1
a771 1
      if (! flag_mri || *input_line_pointer != '\'')
d776 1
a776 1
      if (! flag_mri || *input_line_pointer != '\'')
d781 1
a781 1
      if (! flag_mri)
d801 1
a801 1
      if (! flag_mri)
d846 1
a846 1
      if (! flag_mri)
d849 1
a849 1
      if (flag_mri && hex_p (*input_line_pointer))
d926 1
a926 1
      if (! flag_mri)
d932 1
a932 1
      if (! flag_mri)
d938 1
a938 1
      if (! flag_mri)
d949 1
a949 1
      if (! flag_mri || is_part_of_name (*input_line_pointer))
d970 1
a970 1
	  /* The MRI i960 assemblers permits
a1233 1
#ifdef TC_M68K
d1236 1
a1236 1
  if (flag_mri)
d1243 7
a1249 1
#endif
d1306 1
a1306 1
	  if (flag_mri)
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 2
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996
   Free Software Foundation, Inc.
d169 1
a169 1
  if (flag_m68k_mri && radix == 0)
d297 1
a297 1
  if (flag_m68k_mri && suffix != NULL && input_line_pointer - 1 == suffix)
d566 1
a566 1
      integer_constant (flag_m68k_mri ? 0 : 10, expressionP);
d572 1
a572 1
      if (flag_m68k_mri)
a589 4
	case 'o':
	case 'O':
	case 'q':
	case 'Q':
d592 1
a592 1
	  if (flag_m68k_mri)
d617 1
a617 1
	  if (flag_m68k_mri)
d624 1
a624 1
	  if (LOCAL_LABELS_FB && ! flag_m68k_mri)
d662 1
a662 1
	  if (flag_m68k_mri)
d675 1
a675 1
	  integer_constant (flag_m68k_mri ? 0 : 8, expressionP);
a720 6
	  if (flag_m68k_mri)
	    {
	      integer_constant (0, expressionP);
	      break;
	    }
	  /* Fall through.  */
a754 1
      SKIP_WHITESPACE ();
d759 1
a759 1
      if (! flag_m68k_mri || *input_line_pointer != '\'')
d764 1
a764 1
      if (! flag_m68k_mri || *input_line_pointer != '\'')
d769 1
a769 1
      if (! flag_m68k_mri)
d789 1
a789 1
      if (! flag_m68k_mri)
d834 1
a834 1
      if (! flag_m68k_mri)
d837 1
a837 1
      if (flag_m68k_mri && hex_p (*input_line_pointer))
d914 1
a914 1
      if (! flag_m68k_mri)
d920 1
a920 1
      if (! flag_m68k_mri)
d926 1
a926 1
      if (! flag_m68k_mri)
d937 1
a937 1
      if (! flag_m68k_mri || is_part_of_name (*input_line_pointer))
d958 1
a958 1
	  /* The MRI i960 assembler permits
d1222 1
d1225 1
a1225 1
  if (flag_m68k_mri)
d1232 1
a1232 7

  /* Verify that X_op field is wide enough.  */
  {
    expressionS e;
    e.X_op = O_max;
    assert (e.X_op == O_max);
  }
d1289 1
a1289 1
	  if (flag_m68k_mri)
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d18 2
a19 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA. */
a41 13

/* We keep a mapping of expression symbols to file positions, so that
   we can provide better error messages.  */

struct expr_symbol_line
{
  struct expr_symbol_line *next;
  symbolS *sym;
  char *file;
  unsigned int line;
};

static struct expr_symbol_line *expr_symbol_lines;
a52 1
  struct expr_symbol_line *n;
a75 6
  n = (struct expr_symbol_line *) xmalloc (sizeof *n);
  n->sym = symbolP;
  as_where (&n->file, &n->line);
  n->next = expr_symbol_lines;
  expr_symbol_lines = n;

a77 25

/* Return the file and line number for an expr symbol.  Return
   non-zero if something was found, 0 if no information is known for
   the symbol.  */

int
expr_symbol_where (sym, pfile, pline)
     symbolS *sym;
     char **pfile;
     unsigned int *pline;
{
  register struct expr_symbol_line *l;

  for (l = expr_symbol_lines; l != NULL; l = l->next)
    {
      if (l->sym == sym)
	{
	  *pfile = l->file;
	  *pline = l->line;
	  return 1;
	}
    }

  return 0;
}
a968 12
#ifdef md_parse_name
	  /* This is a hook for the backend to parse certain names
             specially in certain contexts.  If a name always has a
             specific value, it can often be handled by simply
             entering it in the symbol table.  */
	  if (md_parse_name (name, expressionP))
	    {
	      *input_line_pointer = c;
	      break;
	    }
#endif

d972 1
a972 1
	     FIXME: This should use md_parse_name.  */
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d33 1
d1522 1
a1522 6
	    case O_right_shift:
	      /* We always use unsigned shifts, to avoid relying on
                 characteristics of the compiler used to compile gas.  */
	      resultP->X_add_number =
		(offsetT) ((valueT) resultP->X_add_number >> (valueT) v);
	      break;
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1997
a39 2
static segT operand PARAMS ((expressionS *));
static operatorT operator PARAMS ((void));
d72 2
d676 1
a676 9
	      /* This code used to check for '+' and '-' here, and, in
		 some conditions, fall through to call
		 integer_constant.  However, that didn't make sense,
		 as integer_constant only accepts digits.  */
	      /* Some of our code elsewhere does permit digits greater
		 than the expected base; for consistency, do the same
		 here.  */
	      if (input_line_pointer[1] < '0'
		  || input_line_pointer[1] > '9')
d678 24
a701 4
		  /* Parse this as a back reference to label 0.  */
		  input_line_pointer--;
		  integer_constant (10, expressionP);
		  break;
d703 6
a708 1
	      /* Otherwise, parse this as a binary number.  */
a709 1
	  /* Fall through.  */
d849 1
a850 4
      /* ~ is permitted to start a label on the Delta.  */
      if (is_name_beginner (c))
	goto isname;
    case '!':
d1485 1
a1485 1
	  resultP->X_add_number -= right.X_add_number;
d1622 3
a1624 4
  if (is_name_beginner (c = *input_line_pointer++) || c == '\001')
    while (is_part_of_name (c = *input_line_pointer++)
	   || c == '\001')
      ;
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a30 1
#define min(a, b)       ((a) < (b) ? (a) : (b))
a35 4
static valueT generic_bignum_to_int32 PARAMS ((void));
#ifdef BFD64
static valueT generic_bignum_to_int64 PARAMS ((void));
#endif
a65 1
  expressionS zero;
a73 16
  if (expressionP->X_op == O_big)
    {
      /* This won't work, because the actual value is stored in
         generic_floating_point_number or generic_bignum, and we are
         going to lose it if we haven't already.  */
      if (expressionP->X_add_number > 0)
	as_bad (_("bignum invalid; zero assumed"));
      else
	as_bad (_("floating point number invalid; zero assumed"));
      zero.X_op = O_constant;
      zero.X_add_number = 0;
      zero.X_unsigned = 0;
      clean_up_expression (&zero);
      expressionP = &zero;
    }

d85 1
a85 1
  symbol_set_value_expression (symbolP, expressionP);
d88 1
a88 1
    resolve_symbol_value (symbolP, 1);
a123 67
/* Utilities for building expressions.
   Since complex expressions are recorded as symbols for use in other
   expressions these return a symbolS * and not an expressionS *.
   These explicitly do not take an "add_number" argument.  */
/* ??? For completeness' sake one might want expr_build_symbol.
   It would just return its argument.  */

/* Build an expression for an unsigned constant.
   The corresponding one for signed constants is missing because
   there's currently no need for it.  One could add an unsigned_p flag
   but that seems more clumsy.  */

symbolS *
expr_build_uconstant (value)
     offsetT value;
{
  expressionS e;

  e.X_op = O_constant;
  e.X_add_number = value;
  e.X_unsigned = 1;
  return make_expr_symbol (&e);
}

/* Build an expression for OP s1.  */

symbolS *
expr_build_unary (op, s1)
     operatorT op;
     symbolS *s1;
{
  expressionS e;

  e.X_op = op;
  e.X_add_symbol = s1;
  e.X_add_number = 0;
  return make_expr_symbol (&e);
}

/* Build an expression for s1 OP s2.  */

symbolS *
expr_build_binary (op, s1, s2)
     operatorT op;
     symbolS *s1;
     symbolS *s2;
{
  expressionS e;

  e.X_op = op;
  e.X_add_symbol = s1;
  e.X_op_symbol = s2;
  e.X_add_number = 0;
  return make_expr_symbol (&e);
}

/* Build an expression for the current location ('.').  */

symbolS *
expr_build_dot ()
{
  expressionS e;

  current_location (&e);
  return make_expr_symbol (&e);
}

d161 1
a161 1
	  as_bad (_("bad floating-point constant: exponent overflow, probably assembling junk"));
d165 1
a165 1
	  as_bad (_("bad floating-point constant: unknown error code=%d."), error_code);
a173 26
static valueT 
generic_bignum_to_int32 () 
{
  valueT number =
	   ((generic_bignum[1] & LITTLENUM_MASK) << LITTLENUM_NUMBER_OF_BITS)
	   | (generic_bignum[0] & LITTLENUM_MASK);
  number &= 0xffffffff;
  return number;
}

#ifdef BFD64
static valueT 
generic_bignum_to_int64 () 
{
  valueT number = 
	   ((((((((valueT) generic_bignum[3] & LITTLENUM_MASK)
		 << LITTLENUM_NUMBER_OF_BITS)
	        | ((valueT) generic_bignum[2] & LITTLENUM_MASK))
	       << LITTLENUM_NUMBER_OF_BITS)
	      | ((valueT) generic_bignum[1] & LITTLENUM_MASK))
	     << LITTLENUM_NUMBER_OF_BITS)
	    | ((valueT) generic_bignum[0] & LITTLENUM_MASK));
  return number;
}
#endif

d215 1
a215 1
  if ((NUMBERS_WITH_SUFFIX || flag_m68k_mri) && radix == 0)
d222 1
a222 3
      for (suffix = input_line_pointer;
	   isalnum ((unsigned char) *suffix);
	   suffix++)
d236 1
a236 1
	  if (islower ((unsigned char) c))
d275 1
a275 1
      too_many_digits = (valuesize + 11) / 4; /* very rough */
d289 1
a289 77

  if (radix == 16 && c == '_') 
    {
      /* This is literal of the form 0x333_0_12345678_1.
         This example is equivalent to 0x00000333000000001234567800000001.  */

      int num_little_digits = 0;
      int i;
      input_line_pointer = start;	/*->1st digit. */

      know (LITTLENUM_NUMBER_OF_BITS == 16);

      for (c = '_'; c == '_'; num_little_digits+=2)
	{

	  /* Convert one 64-bit word. */
	  int ndigit = 0; 
	  number = 0;
	  for (c = *input_line_pointer++;
	       (digit = hex_value (c)) < maxdig;
	       c = *(input_line_pointer++))
	    {
	      number = number * radix + digit;
	      ndigit++;
	    }

	  /* Check for 8 digit per word max.  */
	  if (ndigit > 8) 
	    as_bad (_("A bignum with underscores may not have more than 8 hex digits in any word."));

	  /* Add this chunk to the bignum.  Shift things down 2 little digits.*/
	  know (LITTLENUM_NUMBER_OF_BITS == 16);
	  for (i = min (num_little_digits + 1, SIZE_OF_LARGE_NUMBER - 1); i >= 2; i--)
	    generic_bignum[i] = generic_bignum[i-2];

	  /* Add the new digits as the least significant new ones. */
	  generic_bignum[0] = number & 0xffffffff;
	  generic_bignum[1] = number >> 16;
	}

      /* Again, c is char after number, input_line_pointer->after c. */

      if (num_little_digits > SIZE_OF_LARGE_NUMBER - 1)
	num_little_digits = SIZE_OF_LARGE_NUMBER - 1;

      assert (num_little_digits >= 4);

      if (num_little_digits != 8)
	as_bad (_("A bignum with underscores must have exactly 4 words."));

      /* We might have some leading zeros.  These can be trimmed to give
       * us a change to fit this constant into a small number.
       */
      while (generic_bignum[num_little_digits-1] == 0 && num_little_digits > 1)
	num_little_digits--;
	
      if (num_little_digits <= 2)
	{
	  /* will fit into 32 bits. */
	  number = generic_bignum_to_int32 ();
	  small = 1;
	}
#ifdef BFD64
      else if (num_little_digits <= 4)
	{
	  /* Will fit into 64 bits.  */
	  number = generic_bignum_to_int64 ();
	  small = 1;
	}
#endif
      else
	{
	  small = 0;
	  number = num_little_digits; /* number of littlenums in the bignum. */
	}
    }
  else if (!small)
a300 2
      generic_bignum[2] = 0;
      generic_bignum[3] = 0;
d332 3
a334 8
	  number = generic_bignum_to_int32 ();
	  small = 1;
	}
#ifdef BFD64
      else if (leader < generic_bignum + 4)
	{
	  /* Will fit into 64 bits.  */
	  number = generic_bignum_to_int64 ();
a336 1
#endif
d343 1
a343 3
  if ((NUMBERS_WITH_SUFFIX || flag_m68k_mri) 
      && suffix != NULL 
      && input_line_pointer - 1 == suffix)
d380 1
a380 1
	      as_bad (_("backw. ref to unknown label \"%d:\", 0 assumed."),
d504 1
a504 1
      as_bad (_("Character constant too large"));
d612 1
a612 3
      integer_constant ((NUMBERS_WITH_SUFFIX || flag_m68k_mri) 
                        ? 0 : 10,
                        expressionP);
d618 1
a618 1
      if (NUMBERS_WITH_SUFFIX || flag_m68k_mri)
d631 2
a632 1
        }
d642 1
a642 1
	  if (NUMBERS_WITH_SUFFIX || flag_m68k_mri)
d654 1
a654 2
	      expressionP->X_add_number =
		- (isupper ((unsigned char) c) ? tolower (c) : c);
d674 1
a674 1
	  if (LOCAL_LABELS_FB && ! (flag_m68k_mri || NUMBERS_WITH_SUFFIX))
d696 1
a696 1
	  if (flag_m68k_mri || NUMBERS_WITH_SUFFIX)
d709 1
a709 3
	  integer_constant ((flag_m68k_mri || NUMBERS_WITH_SUFFIX)
                            ? 0 : 8, 
                            expressionP);
d719 1
a719 2
		  || (is_end_of_line[0xff & input_line_pointer[1]])
		  || strchr (FLT_CHARS, 'f') == NULL)
a731 4
		    else if (cp == input_line_pointer + 1)
		      /* No characters has been accepted -- looks like
                         end of operand. */
		      goto is_0f_label;
d735 1
a735 1
		    as_fatal (_("expr.c(operand): bad atof_generic return val %d"),
d755 1
a755 1
	  if (flag_m68k_mri || NUMBERS_WITH_SUFFIX)
d769 1
a769 2
	  expressionP->X_add_number =
	    - (isupper ((unsigned char) c) ? tolower (c) : c);
a784 1
#ifndef NEED_INDEX_OPERATOR
a785 1
#endif
d792 1
a792 1
	  as_bad (_("Missing ')' assumed"));
a798 1
#ifdef TC_M68K
d802 1
a802 1
      as_bad (_("EBCDIC constants are not supported"));
a808 1
#endif
a827 1
#ifdef TC_M68K
a832 1
#endif
d869 1
a869 1
	  as_warn (_("Unary operator %c ignored because bad operand follows"),
a873 1
#if defined (DOLLAR_DOT) || defined (TC_M68K)
a893 1
#endif
d913 1
a913 1
	    as_bad (_("syntax error in .startof. or .sizeof."));
d938 1
a938 1
		as_bad (_("syntax error in .startof. or .sizeof."));
a956 1
#ifdef TC_M68K
a985 1
#endif
a987 1
#ifdef TC_M68K
a988 1
#endif
d1087 1
a1087 1
	      as_bad (_("Bad expression"));
d1105 1
a1105 1
    symbol_mark_used (expressionP->X_add_symbol);
d1152 2
a1153 2
	  || ((symbol_get_frag (expressionP->X_op_symbol)
	       == symbol_get_frag (expressionP->X_add_symbol))
d1198 1
a1198 1
static const operatorT op_encoding[256] =
d1211 1
a1211 7
  __, __, __,
#ifdef NEED_INDEX_OPERATOR
  O_index,
#else
  __,
#endif
  __, __, O_bit_exclusive_or, __,
d1249 22
a1270 39
  9,	/* O_uminus */
  9,	/* O_bit_not */
  9,	/* O_logical_not */
  8,	/* O_multiply */
  8,	/* O_divide */
  8,	/* O_modulus */
  8,	/* O_left_shift */
  8,	/* O_right_shift */
  7,	/* O_bit_inclusive_or */
  7,	/* O_bit_or_not */
  7,	/* O_bit_exclusive_or */
  7,	/* O_bit_and */
  5,	/* O_add */
  5,	/* O_subtract */
  4,	/* O_eq */
  4,	/* O_ne */
  4,	/* O_lt */
  4,	/* O_le */
  4,	/* O_ge */
  4,	/* O_gt */
  3,	/* O_logical_and */
  2,	/* O_logical_or */
  1,	/* O_index */
  0,	/* O_md1 */
  0,	/* O_md2 */
  0,	/* O_md3 */
  0,	/* O_md4 */
  0,	/* O_md5 */
  0,	/* O_md6 */
  0,	/* O_md7 */
  0,	/* O_md8 */
  0,	/* O_md9 */
  0,	/* O_md10 */
  0,	/* O_md11 */
  0,	/* O_md12 */
  0,	/* O_md13 */
  0,	/* O_md14 */
  0,	/* O_md15 */
  0,	/* O_md16 */
d1273 1
a1273 8
/* Unfortunately, in MRI mode for the m68k, multiplication and
   division have lower precedence than the bit wise operators.  This
   function sets the operator precedences correctly for the current
   mode.  Also, MRI uses a different bit_not operator, and this fixes
   that as well.  */

#define STANDARD_MUL_PRECEDENCE (7)
#define MRI_MUL_PRECEDENCE (5)
d1276 1
a1276 1
expr_set_precedence ()
d1278 2
d1282 4
a1285 9
      op_rank[O_multiply] = MRI_MUL_PRECEDENCE;
      op_rank[O_divide] = MRI_MUL_PRECEDENCE;
      op_rank[O_modulus] = MRI_MUL_PRECEDENCE;
    }
  else
    {
      op_rank[O_multiply] = STANDARD_MUL_PRECEDENCE;
      op_rank[O_divide] = STANDARD_MUL_PRECEDENCE;
      op_rank[O_modulus] = STANDARD_MUL_PRECEDENCE;
a1286 8
}

/* Initialize the expression parser.  */

void
expr_begin ()
{
  expr_set_precedence ();
d1306 1
a1306 1
  c = *input_line_pointer & 0xff;
a1330 7
    case '=':
      if (input_line_pointer[1] != '=')
	return op_encoding[c];

      ++input_line_pointer;
      return O_eq;

d1373 1
a1373 1
}
d1378 2
a1379 2
expr (rankarg, resultP)
     int rankarg;	/* Larger # is higher rank. */
a1381 1
  operator_rankT rank = (operator_rankT) rankarg;
d1403 1
a1403 1
	  as_warn (_("missing operand; zero assumed"));
a1411 11
      if (op_left == O_index)
	{
	  if (*input_line_pointer != ']')
	    as_bad ("missing right bracket");
	  else
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	    }
	}

d1425 1
a1425 1
	as_bad (_("operation combines symbols in different segments"));
d1440 2
a1441 4
	  if (resultP->X_add_number > 0)
	    as_warn (_("left operand is a bignum; integer 0 assumed"));
	  else
	    as_warn (_("left operand is a float; integer 0 assumed"));
d1449 2
a1450 4
	  if (right.X_add_number > 0)
	    as_warn (_("right operand is a bignum; integer 0 assumed"));
	  else
	    as_warn (_("right operand is a float; integer 0 assumed"));
d1467 2
a1468 2
	       && (symbol_get_frag (right.X_add_symbol)
		   == symbol_get_frag (resultP->X_add_symbol))
d1498 1
a1498 1
	      as_warn (_("division by zero"));
d1582 1
a1582 1
    symbol_mark_used (resultP->X_add_symbol);
d1610 3
a1612 7
    {
      while (is_part_of_name (c = *input_line_pointer++)
	     || c == '\001')
	;
      if (is_name_ender (c))
	c = *input_line_pointer++;
    }
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001
d20 1
a20 1
   02111-1307, USA.  */
d22 6
a27 4
/* This is really a branch office of as-read.c. I split it out to clearly
   distinguish the world of expressions from the world of statements.
   (It also gives smaller files to re-compile.)
   Here, "operand"s are of expressions, not instructions.  */
d46 1
a46 1
static operatorT operator PARAMS ((int *));
d53 2
a54 1
struct expr_symbol_line {
d213 4
a216 2
/* Build any floating-point literal here.
   Also build any bignum literal here.  */
d224 7
a230 7

FLONUM_TYPE generic_floating_point_number = {
  &generic_bignum[6],		/* low.  (JF: Was 0)  */
  &generic_bignum[SIZE_OF_LARGE_NUMBER + 6 - 1], /* high.  JF: (added +6)  */
  0,				/* leader.  */
  0,				/* exponent.  */
  0				/* sign.  */
d232 1
a232 2

/* If nonzero, we've been asked to assemble nan, +inf or -inf.  */
d239 2
a240 1
  /* input_line_pointer -> floating-point constant.  */
d258 2
a259 2
  /* input_line_pointer -> just after constant, which may point to
     whitespace.  */
d263 2
a264 2
static valueT
generic_bignum_to_int32 ()
d274 2
a275 2
static valueT
generic_bignum_to_int64 ()
d277 8
a284 8
  valueT number =
    ((((((((valueT) generic_bignum[3] & LITTLENUM_MASK)
	  << LITTLENUM_NUMBER_OF_BITS)
	 | ((valueT) generic_bignum[2] & LITTLENUM_MASK))
	<< LITTLENUM_NUMBER_OF_BITS)
       | ((valueT) generic_bignum[1] & LITTLENUM_MASK))
      << LITTLENUM_NUMBER_OF_BITS)
     | ((valueT) generic_bignum[0] & LITTLENUM_MASK));
d294 1
a294 1
  char *start;		/* Start of number.  */
d297 6
a302 6
  valueT number;	/* Offset or (absolute) value.  */
  short int digit;	/* Value of next digit in current radix.  */
  short int maxdig = 0;	/* Highest permitted digit value.  */
  int too_many_digits = 0;	/* If we see >= this number of.  */
  char *name;		/* Points to name of symbol.  */
  symbolS *symbolP;	/* Points to symbol.  */
d304 1
a304 1
  int small;			/* True if fits in 32 bits.  */
d306 1
a306 1
  /* May be bignum, or may fit in 32 bits.  */
d319 1
a319 1
     number.  The cavalier approach is for speed in ordinary cases.  */
d392 1
a392 1
      too_many_digits = (valuesize + 11) / 4; /* Very rough.  */
d403 2
a404 2
  /* c contains character after number.  */
  /* input_line_pointer->char after c.  */
d407 1
a407 1
  if (radix == 16 && c == '_')
d414 1
a414 1
      input_line_pointer = start;	/* -> 1st digit.  */
d418 1
a418 1
      for (c = '_'; c == '_'; num_little_digits += 2)
d421 2
a422 2
	  /* Convert one 64-bit word.  */
	  int ndigit = 0;
d433 1
a433 1
	  if (ndigit > 8)
d436 1
a436 2
	  /* Add this chunk to the bignum.
	     Shift things down 2 little digits.  */
d438 2
a439 4
	  for (i = min (num_little_digits + 1, SIZE_OF_LARGE_NUMBER - 1);
	       i >= 2;
	       i--)
	    generic_bignum[i] = generic_bignum[i - 2];
d441 1
a441 1
	  /* Add the new digits as the least significant new ones.  */
d446 1
a446 1
      /* Again, c is char after number, input_line_pointer->after c.  */
d457 3
a459 3
	 us a change to fit this constant into a small number.  */
      while (generic_bignum[num_little_digits - 1] == 0
	     && num_little_digits > 1)
d461 1
a461 1

d464 1
a464 1
	  /* will fit into 32 bits.  */
d479 1
a479 3

	  /* Number of littlenums in the bignum.  */
	  number = num_little_digits;
d484 5
a488 3
      /* We saw a lot of digits. manufacture a bignum the hard way.  */
      LITTLENUM_TYPE *leader;	/* -> high order littlenum of the bignum.  */
      LITTLENUM_TYPE *pointer;	/* -> littlenum we are frobbing now.  */
d496 1
a496 1
      input_line_pointer = start;	/* -> 1st digit.  */
d498 7
a504 3
      for (; (carry = hex_value (c)) < maxdig; c = *input_line_pointer++)
	{
	  for (pointer = generic_bignum; pointer <= leader; pointer++)
d516 1
a516 1
		  /* Room to grow a longer bignum.  */
d521 2
a522 2
      /* Again, c is char after number.  */
      /* input_line_pointer -> after c.  */
d526 1
a526 1
	  /* Will fit into 32 bits.  */
d540 1
a540 2
	  /* Number of littlenums in the bignum.  */
	  number = leader - generic_bignum + 1;
d544 2
a545 2
  if ((NUMBERS_WITH_SUFFIX || flag_m68k_mri)
      && suffix != NULL
d551 6
a556 5
      /* Here with number, in correct radix. c is the next char.
	 Note that unlike un*x, we allow "011f" "0x9f" to both mean
	 the same as the (conventional) "9f".
	 This is simply easier than checking for strict canonical
	 form.  Syntax sux!  */
d560 4
a563 2
	  /* Backward ref to local label.
	     Because it is backward, expect it to be defined.  */
d567 1
a567 1
	  /* Seen before, or symbol is defined: OK.  */
d571 2
a572 2
	      /* Local labels are never absolute.  Don't waste time
		 checking absoluteness.  */
d580 1
a580 1
	      /* Either not seen or not defined.  */
d592 8
a599 7
	  /* Forward reference.  Expect symbol to be undefined or
	     unknown.  undefined: seen it before.  unknown: never seen
	     it before.

	     Construct a local label name, then an undefined symbol.
	     Don't create a xseg frag for it: caller may do that.
	     Just return it as never seen before.  */
d602 1
a602 1
	  /* We have no need to check symbol properties.  */
d604 1
a604 1
	  /* Since "know" puts its arg into a "string", we
d643 2
a644 2
	  input_line_pointer--;	/* Restore following character.  */
	}			/* Really just a number.  */
d648 1
a648 1
      /* Not a small number.  */
d650 2
a651 2
      expressionP->X_add_number = number;	/* Number of littlenums.  */
      input_line_pointer--;	/* -> char following number.  */
d769 10
a778 6
/* In:	Input_line_pointer points to 1st char of operand, which may
	be a space.

   Out:	A expressionS.
	The operand may have been empty: in this case X_op == O_absent.
	Input_line_pointer->(next non-blank) char after operand.  */
d785 2
a786 2
  symbolS *symbolP;	/* Points to symbol.  */
  char *name;		/* Points to name of symbol.  */
d797 1
a797 1
  /* Digits, assume it is a bignum.  */
d799 2
a800 5
  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand.  */
  c = *input_line_pointer++;	/* input_line_pointer -> past char in c.  */

  if (is_end_of_line[(unsigned char) c])
    goto eol;
d815 2
a816 2
      integer_constant ((NUMBERS_WITH_SUFFIX || flag_m68k_mri)
			? 0 : 10,
a819 12
#ifdef LITERAL_PREFIXDOLLAR_HEX
    case '$':
      integer_constant (16, expressionP);
      break;
#endif

#ifdef LITERAL_PREFIXPERCENT_BIN
    case '%':
      integer_constant (2, expressionP);
      break;
#endif

d821 1
a821 1
      /* Non-decimal radix.  */
d836 1
a836 1
	}
d863 1
a863 1
	      /* The string was only zero.  */
d915 2
a916 2
			    ? 0 : 8,
			    expressionP);
d938 1
a938 1
		      /* Looks like a difference expression.  */
d942 1
a942 1
			 end of operand.  */
d961 1
a961 1
	      /* Fall through.  */
d1001 1
a1001 1
      /* Didn't begin with digit & not a name.  */
d1003 3
a1005 3
      /* expression () will pass trailing whitespace.  */
      if ((c == '(' && *input_line_pointer != ')')
	  || (c == '[' && *input_line_pointer != ']'))
d1007 2
a1008 4
#ifdef RELAX_PAREN_GROUPING
	  if (c != '(')
#endif
	    as_bad (_("Missing '%c' assumed"), c == '(' ? ')' : ']');
a1009 2
      else
	input_line_pointer++;
d1011 1
a1011 1
      /* Here with input_line_pointer -> char after "(...)".  */
d1030 1
a1030 1
	     ESCAPEMENT is permitted for a single quote.  The next
d1032 1
a1032 1
	     of the operand.  VERY KINKY.  */
d1053 1
a1053 1
      /* '~' is permitted to start a label on the Delta.  */
d1062 1
a1062 1
	    /* input_line_pointer -> char after operand.  */
d1066 2
a1067 3
		/* Notice: '-' may overflow: no warning is given.
		   This is compatible with other people's
		   assemblers.  Sigh.  */
d1095 2
a1096 2
      /* '$' is the program counter when in MRI mode, or when
         DOLLAR_DOT is defined.  */
d1103 1
a1103 1
	  /* In MRI mode, '$' is also used as the prefix for a
a1168 1

d1170 2
d1173 1
a1173 1
      /* Can't imagine any other kind of operand.  */
d1214 8
a1221 4
      if (is_name_beginner (c))	/* Here if did not begin with a digit.  */
	{
	  /* Identifier begins here.
	     This is kludged for speed, so code is repeated.  */
d1274 1
a1274 1
	    }
d1304 1
a1304 1
	     input_line_pointer past the expression.  If it can't parse the
d1320 4
a1323 2
  /* It is more 'efficient' to clean up the expressionS when they are
     created.  Doing it here saves lines of code.  */
d1325 1
a1325 1
  SKIP_WHITESPACE ();		/* -> 1st char after operand.  */
d1341 1
a1341 1
}
d1343 1
a1343 1
/* Internal.  Simplify a struct expression for use by expr ().  */
d1345 9
a1353 8
/* In:	address of a expressionS.
	The X_op field of the expressionS may only take certain values.
	Elsewise we waste time special-case testing. Sigh. Ditto SEG_ABSENT.

   Out:	expressionS may have been modified:
	'foo-foo' symbol references cancelled to 0, which changes X_op
	from O_subtract to O_constant.
	Unused fields zeroed to help expr ().  */
d1397 1
a1397 1
/* Expression parser.  */
d1399 20
a1418 18
/* We allow an empty expression, and just assume (absolute,0) silently.
   Unary operators and parenthetical expressions are treated as operands.
   As usual, Q==quantity==operand, O==operator, X==expression mnemonics.

   We used to do a aho/ullman shift-reduce parser, but the logic got so
   warped that I flushed it and wrote a recursive-descent parser instead.
   Now things are stable, would anybody like to write a fast parser?
   Most expressions are either register (which does not even reach here)
   or 1 symbol. Then "symbol+constant" and "symbol-symbol" are common.
   So I guess it doesn't really matter how inefficient more complex expressions
   are parsed.

   After expr(RANK,resultP) input_line_pointer->operator of rank <= RANK.
   Also, we have consumed any leading or trailing spaces (operand does that)
   and done all intervening operators.

   This returns the segment of the result, which will be
   absolute_section or the segment of a symbol.  */
d1423 3
a1425 2
/* Maps ASCII -> operators.  */
static const operatorT op_encoding[256] = {
d1458 15
a1472 12
/* Rank	Examples
   0	operand, (expression)
   1	||
   2	&&
   3	= <> < <= >= >
   4	+ -
   5	used for * / % in MRI mode
   6	& ^ ! |
   7	* / % << >>
   8	unary - unary ~
*/
static operator_rankT op_rank[] = {
d1479 1
a1479 1
  0,	/* O_big */
d1527 2
a1528 2
#define STANDARD_MUL_PRECEDENCE 8
#define MRI_MUL_PRECEDENCE 6
d1562 3
a1564 3
/* Return the encoding for the operator at INPUT_LINE_POINTER, and
   sets NUM_CHARS to the number of characters in the operator.
   Does not advance INPUT_LINE_POINTER.  */
d1567 1
a1567 2
operator (num_chars)
     int *num_chars;
a1572 4
  *num_chars = 1;

  if (is_end_of_line[c])
    return O_illegal;
d1594 1
a1594 1
      *num_chars = 2;
d1601 1
a1601 1
      *num_chars = 2;
d1616 1
a1616 1
      *num_chars = 2;
d1627 1
a1627 1
      *num_chars = 2;
d1634 1
a1634 1
      *num_chars = 2;
d1641 1
a1641 1
      *num_chars = 2;
d1645 1
a1645 1
  /* NOTREACHED  */
d1652 2
a1653 2
     int rankarg;	/* Larger # is higher rank.  */
     expressionS *resultP;	/* Deliver result here.  */
a1659 1
  int op_chars;
d1665 1
a1665 2
  /* operand () gobbles spaces.  */
  know (*input_line_pointer != ' ');
d1667 1
a1667 1
  op_left = operator (&op_chars);
d1672 1
a1672 1
      input_line_pointer += op_chars;	/* -> after operator.  */
d1712 1
a1712 1
      op_right = operator (&op_chars);
d1714 1
a1714 2
      know (op_right == O_illegal
	    || op_rank[(int) op_right] <= op_rank[(int) op_left]);
d1718 4
a1721 4
      /* input_line_pointer->after right-hand quantity.  */
      /* left-hand quantity in resultP.  */
      /* right-hand quantity in right.  */
      /* operator in op_left.  */
a1746 8
#ifdef md_optimize_expr
      if (md_optimize_expr (resultP, op_left, &right))
	{
	  /* Skip.  */
	  ;
	}
      else
#endif
d1867 1
a1867 1
    }				/* While next operator is >= this rank.  */
d1876 15
a1890 12
/* This lives here because it belongs equally in expr.c & read.c.
   expr.c is just a branch office read.c anyway, and putting it
   here lessens the crowd at read.c.

   Assume input_line_pointer is at start of symbol name.
   Advance input_line_pointer past symbol name.
   Turn that character into a '\0', returning its former value.
   This allows a string compare (RMS wants symbol names to be strings)
   of the symbol name.
   There will always be a char following symbol name, because all good
   lines end in end-of-line.  */

d1910 1
d1917 1
d1919 2
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002
d28 1
a32 1
#include "safe-ctype.h"
d81 2
a82 2
	 generic_floating_point_number or generic_bignum, and we are
	 going to lose it if we haven't already.  */
d84 1
a84 1
	as_bad (_("bignum invalid"));
d86 1
a86 1
	as_bad (_("floating point number invalid"));
d108 1
a108 1
    resolve_symbol_value (symbolP);
d246 1
a246 1
	  as_bad (_("bad floating-point constant: exponent overflow"));
d250 1
a250 2
	  as_bad (_("bad floating-point constant: unknown error code=%d"),
		  error_code);
d331 5
a335 3
	 radix.  For that matter, it might actually be a floating
	 point constant.  */
      for (suffix = input_line_pointer; ISALNUM (*suffix); suffix++)
d349 2
a350 1
	  c = TOUPPER (c);
d406 1
a406 1
	 This example is equivalent to 0x00000333000000001234567800000001.  */
d430 1
a430 1
	    as_bad (_("a bignum with underscores may not have more than 8 hex digits in any word"));
d453 1
a453 1
	as_bad (_("a bignum with underscores must have exactly 4 words"));
d576 1
a576 1
	      as_bad (_("backward ref to unknown label \"%d:\""),
d686 2
a687 2
	     last one to make it match the earlier ones.  If there is
	     only one, we can just use the value directly.  */
d699 1
a699 1
      as_bad (_("character constant too large"));
d764 1
a764 1
   Out:	An expressionS.
d808 1
a808 1
			expressionP);
a812 3
      /* $L is the start of a local label, not a hex constant.  */
      if (* input_line_pointer == 'L')
      goto isname;
d830 1
a830 1
	  /* Check for a hex or float constant.  */
d833 1
a833 1
	  if (*s == 'h' || *s == 'H' || *input_line_pointer == '.')
d861 2
a862 1
	      expressionP->X_add_number = - TOLOWER (c);
d984 2
a985 1
	  expressionP->X_add_number = - TOLOWER (c);
d1013 1
a1013 1
	    as_bad (_("missing '%c'"), c == '(' ? ')' : ']');
a1082 12
	else if (expressionP->X_op == O_big
		 && expressionP->X_add_number <= 0
		 && c == '-'
		 && (generic_floating_point_number.sign == '+'
		     || generic_floating_point_number.sign == 'P'))
	  {
	    /* Negative flonum (eg, -1.000e0).  */
	    if (generic_floating_point_number.sign == '+')
	      generic_floating_point_number.sign = '-';
	    else
	      generic_floating_point_number.sign = 'N';
	  }
d1104 1
a1104 1
	 DOLLAR_DOT is defined.  */
d1112 1
a1112 1
	     hexadecimal constant.  */
d1203 1
a1203 1
	 using hexadecimal digits.  */
d1231 4
a1234 4
	     specially in certain contexts.  If a name always has a
	     specific value, it can often be handled by simply
	     entering it in the symbol table.  */
	  if (md_parse_name (name, expressionP, &c))
d1315 1
a1315 1
	      as_bad (_("bad expression"));
d1346 1
a1346 1
/* In:	address of an expressionS.
d1351 2
d1375 17
d1403 1
a1403 1
   We used to do an aho/ullman shift-reduce parser, but the logic got so
d1459 1
a1459 1
   3	== <> < <= >= >
a1662 4
  /* Save the value of dot for the fixup code.  */
  if (rank == 0)
    dot_value = frag_now_fix ();

d1698 15
d1768 2
a1769 2
	       && (SEG_NORMAL (rightseg)
		   || right.X_add_symbol == resultP->X_add_symbol))
d1809 1
a1809 1
		 characteristics of the compiler used to compile gas.  */
d1864 1
a1864 8
	    {
	      resultP->X_add_number -= right.X_add_number;
	      if (retval == rightseg && SEG_NORMAL (retval))
		{
		  retval = absolute_section;
		  rightseg = absolute_section;
		}
	    }
a1873 15
	}

      if (retval != rightseg)
	{
	  if (! SEG_NORMAL (retval))
	    {
	      if (retval != undefined_section || SEG_NORMAL (rightseg))
		retval = rightseg;
	    }
	  else if (SEG_NORMAL (rightseg)
#ifdef DIFF_EXPR_OK
		   && op_left != O_subtract
#endif
		   )
	    as_bad (_("operation combines symbols in different segments"));
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d35 2
a36 2
static void floating_constant (expressionS * expressionP);
static valueT generic_bignum_to_int32 (void);
d38 1
a38 1
static valueT generic_bignum_to_int64 (void);
d40 6
a45 6
static void integer_constant (int radix, expressionS * expressionP);
static void mri_char_constant (expressionS *);
static void current_location (expressionS *);
static void clean_up_expression (expressionS * expressionP);
static segT operand (expressionS *);
static operatorT operator (int *);
d66 2
a67 1
make_expr_symbol (expressionS *expressionP)
d70 1
d94 2
d100 1
a100 1
  symbolP = symbol_create (FAKE_LABEL_NAME,
d124 4
a127 1
expr_symbol_where (symbolS *sym, char **pfile, unsigned int *pline)
d157 2
a158 1
expr_build_uconstant (offsetT value)
d171 3
a173 1
expr_build_unary (operatorT op, symbolS *s1)
d186 4
a189 1
expr_build_binary (operatorT op, symbolS *s1, symbolS *s2)
d203 1
a203 1
expr_build_dot (void)
d233 2
a234 1
floating_constant (expressionS *expressionP)
d261 1
a261 1
generic_bignum_to_int32 (void)
d272 1
a272 1
generic_bignum_to_int64 (void)
d287 3
a289 1
integer_constant (int radix, expressionS *expressionP)
d648 2
a649 1
mri_char_constant (expressionS *expressionP)
d738 2
a739 1
current_location (expressionS *expressionp)
d748 5
d754 1
a754 1
      expressionp->X_add_symbol = symbol_temp_new_now ();
d767 2
a768 1
operand (expressionS *expressionP)
a1047 3
      /* Do not accept ++e as +(+e) */
      if (*input_line_pointer == '+')
	goto target_op;
a1064 4
        /* Do not accept --e as -(-e) */
	if (c == '-' && *input_line_pointer == '-')
	  goto target_op;
	
a1315 1
	target_op:
d1365 2
a1366 1
clean_up_expression (expressionS *expressionP)
d1517 1
a1517 1
expr_set_precedence (void)
d1536 1
a1536 1
expr_begin (void)
d1553 2
a1554 1
operator (int *num_chars)
a1569 7
    case '+':
    case '-':
      /* Do not allow a++b and a--b to be a + (+b) and a - (-b) */
      if (input_line_pointer[1] != c)
	return op_encoding[c];
      return O_illegal;

d1642 3
a1644 2
expr (int rankarg,		/* Larger # is higher rank.  */
      expressionS *resultP	/* Deliver result here.  */)
d1902 1
a1902 1
get_symbol_end (void)
d1921 1
a1921 1
get_single_number (void)
@


