head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.14
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.12
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.42
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.40
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.36
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.34
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.10.20.06.04.06;	author daniel;	state Exp;
branches;
next	1.9;
commitid	IMB4ZRG9ouFX8LqX;

1.9
date	2004.11.02.20.45.25;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.28;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.13.23.04.16;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.43;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.26;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.04.50;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.42;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.43;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.43;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.42;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.43.45;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.07;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.22.13;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.14;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.32.27;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.26;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.44;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Backport fix for binutils 11867: .quad directive not assembled correctly.

Alan Modra (and Alan's employer) graciously permitted use of his patch
under GPLv2.

ok kettenis@@
@
text
@/* read.c - read a source file -
   Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

This file is part of GAS, the GNU Assembler.

GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */

#if 0
/* If your chars aren't 8 bits, you will change this a bit.
   But then, GNU isn't spozed to run on your machine anyway.
   (RMS is so shortsighted sometimes.)  */
#define MASK_CHAR (0xFF)
#else
#define MASK_CHAR ((int)(unsigned char) -1)
#endif

/* This is the largest known floating point format (for now). It will
   grow when we do 4361 style flonums.  */
#define MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT (16)

/* Routines that read assembler source text to build spaghetti in memory.
   Another group of these functions is in the expr.c module.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "sb.h"
#include "macro.h"
#include "obstack.h"
#include "listing.h"
#include "ecoff.h"
#include "dw2gencfi.h"

#ifndef TC_START_LABEL
#define TC_START_LABEL(x,y) (x == ':')
#endif

/* Set by the object-format or the target.  */
#ifndef TC_IMPLICIT_LCOMM_ALIGNMENT
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)		\
  do								\
    {								\
      if ((SIZE) >= 8)						\
	(P2VAR) = 3;						\
      else if ((SIZE) >= 4)					\
	(P2VAR) = 2;						\
      else if ((SIZE) >= 2)					\
	(P2VAR) = 1;						\
      else							\
	(P2VAR) = 0;						\
    }								\
  while (0)
#endif

char *input_line_pointer;	/*->next char of source file to parse.  */

#if BITS_PER_CHAR != 8
/*  The following table is indexed by[(char)] and will break if
    a char does not have exactly 256 states (hopefully 0:255!)!  */
die horribly;
#endif

#ifndef LEX_AT
/* The m88k unfortunately uses @@ as a label beginner.  */
#define LEX_AT 0
#endif

#ifndef LEX_BR
/* The RS/6000 assembler uses {,},[,] as parts of symbol names.  */
#define LEX_BR 0
#endif

#ifndef LEX_PCT
/* The Delta 68k assembler permits % inside label names.  */
#define LEX_PCT 0
#endif

#ifndef LEX_QM
/* The PowerPC Windows NT assemblers permits ? inside label names.  */
#define LEX_QM 0
#endif

#ifndef LEX_HASH
/* The IA-64 assembler uses # as a suffix designating a symbol.  We include
   it in the symbol and strip it out in tc_canonicalize_symbol_name.  */
#define LEX_HASH 0
#endif

#ifndef LEX_DOLLAR
/* The a29k assembler does not permits labels to start with $.  */
#define LEX_DOLLAR 3
#endif

#ifndef LEX_TILDE
/* The Delta 68k assembler permits ~ at start of label names.  */
#define LEX_TILDE 0
#endif

/* Used by is_... macros. our ctype[].  */
char lex_type[256] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* @@ABCDEFGHIJKLMNO */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* PQRSTUVWXYZ[\]^_ */
  0, 0, 0, LEX_HASH, LEX_DOLLAR, LEX_PCT, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, /* _!"#$%&'()*+,-./ */
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, LEX_QM,	/* 0123456789:;<=>? */
  LEX_AT, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* @@ABCDEFGHIJKLMNO */
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, 0, 3, /* PQRSTUVWXYZ[\]^_ */
  0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* `abcdefghijklmno */
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, LEX_TILDE, 0, /* pqrstuvwxyz{|}~.  */
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
};

/* In: a character.
   Out: 1 if this character ends a line.  */
char is_end_of_line[256] = {
#ifdef CR_EOL
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,	/* @@abcdefghijklmno */
#else
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,	/* @@abcdefghijklmno */
#endif
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* _!"#$%&'()*+,-./ */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0123456789:;<=>? */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	/* */
};

#ifndef TC_CASE_SENSITIVE
char original_case_string[128];
#endif

/* Functions private to this file.  */

static char *buffer;	/* 1st char of each buffer of lines is here.  */
static char *buffer_limit;	/*->1 + last char in buffer.  */

/* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1
   in the tc-<CPU>.h file.  See the "Porting GAS" section of the
   internals manual.  */
int target_big_endian = TARGET_BYTES_BIG_ENDIAN;

/* Variables for handling include file directory table.  */

/* Table of pointers to directories to search for .include's.  */
char **include_dirs;

/* How many are in the table.  */
int include_dir_count;

/* Length of longest in table.  */
int include_dir_maxlen = 1;

#ifndef WORKING_DOT_WORD
struct broken_word *broken_words;
int new_broken_words;
#endif

/* The current offset into the absolute section.  We don't try to
   build frags in the absolute section, since no data can be stored
   there.  We just keep track of the current offset.  */
addressT abs_section_offset;

/* If this line had an MRI style label, it is stored in this variable.
   This is used by some of the MRI pseudo-ops.  */
symbolS *line_label;

/* This global variable is used to support MRI common sections.  We
   translate such sections into a common symbol.  This variable is
   non-NULL when we are in an MRI common section.  */
symbolS *mri_common_symbol;

/* In MRI mode, after a dc.b pseudo-op with an odd number of bytes, we
   need to align to an even byte boundary unless the next pseudo-op is
   dc.b, ds.b, or dcb.b.  This variable is set to 1 if an alignment
   may be needed.  */
static int mri_pending_align;

#ifndef NO_LISTING
#ifdef OBJ_ELF
/* This variable is set to be non-zero if the next string we see might
   be the name of the source file in DWARF debugging information.  See
   the comment in emit_expr for the format we look for.  */
static int dwarf_file_string;
#endif
#endif

static void do_align (int, char *, int, int);
static void s_align (int, int);
static int hex_float (int, char *);
static segT get_known_segmented_expression (expressionS * expP);
static void pobegin (void);
static int get_line_sb (sb *);
static void generate_file_debug (void);

void
read_begin (void)
{
  const char *p;

  pobegin ();
  obj_read_begin_hook ();

  /* Something close -- but not too close -- to a multiple of 1024.
     The debugging malloc I'm using has 24 bytes of overhead.  */
  obstack_begin (&notes, chunksize);
  obstack_begin (&cond_obstack, chunksize);

  /* Use machine dependent syntax.  */
  for (p = line_separator_chars; *p; p++)
    is_end_of_line[(unsigned char) *p] = 1;
  /* Use more.  FIXME-SOMEDAY.  */

  if (flag_mri)
    lex_type['?'] = 3;
}

/* Set up pseudo-op tables.  */

static struct hash_control *po_hash;

static const pseudo_typeS potable[] = {
  {"abort", s_abort, 0},
  {"align", s_align_ptwo, 0},
  {"ascii", stringer, 0},
  {"asciz", stringer, 1},
  {"balign", s_align_bytes, 0},
  {"balignw", s_align_bytes, -2},
  {"balignl", s_align_bytes, -4},
/* block  */
  {"byte", cons, 1},
  {"comm", s_comm, 0},
  {"common", s_mri_common, 0},
  {"common.s", s_mri_common, 1},
  {"data", s_data, 0},
  {"dc", cons, 2},
  {"dc.b", cons, 1},
  {"dc.d", float_cons, 'd'},
  {"dc.l", cons, 4},
  {"dc.s", float_cons, 'f'},
  {"dc.w", cons, 2},
  {"dc.x", float_cons, 'x'},
  {"dcb", s_space, 2},
  {"dcb.b", s_space, 1},
  {"dcb.d", s_float_space, 'd'},
  {"dcb.l", s_space, 4},
  {"dcb.s", s_float_space, 'f'},
  {"dcb.w", s_space, 2},
  {"dcb.x", s_float_space, 'x'},
  {"ds", s_space, 2},
  {"ds.b", s_space, 1},
  {"ds.d", s_space, 8},
  {"ds.l", s_space, 4},
  {"ds.p", s_space, 12},
  {"ds.s", s_space, 4},
  {"ds.w", s_space, 2},
  {"ds.x", s_space, 12},
  {"debug", s_ignore, 0},
#ifdef S_SET_DESC
  {"desc", s_desc, 0},
#endif
/* dim  */
  {"double", float_cons, 'd'},
/* dsect  */
  {"eject", listing_eject, 0},	/* Formfeed listing.  */
  {"else", s_else, 0},
  {"elsec", s_else, 0},
  {"elseif", s_elseif, (int) O_ne},
  {"end", s_end, 0},
  {"endc", s_endif, 0},
  {"endfunc", s_func, 1},
  {"endif", s_endif, 0},
  {"endr", s_bad_endr, 0},
/* endef  */
  {"equ", s_set, 0},
  {"equiv", s_set, 1},
  {"err", s_err, 0},
  {"exitm", s_mexit, 0},
/* extend  */
  {"extern", s_ignore, 0},	/* We treat all undef as ext.  */
  {"appfile", s_app_file, 1},
  {"appline", s_app_line, 0},
  {"fail", s_fail, 0},
  {"file", s_app_file, 0},
  {"fill", s_fill, 0},
  {"float", float_cons, 'f'},
  {"format", s_ignore, 0},
  {"func", s_func, 0},
  {"global", s_globl, 0},
  {"globl", s_globl, 0},
  {"hword", cons, 2},
  {"if", s_if, (int) O_ne},
  {"ifc", s_ifc, 0},
  {"ifdef", s_ifdef, 0},
  {"ifeq", s_if, (int) O_eq},
  {"ifeqs", s_ifeqs, 0},
  {"ifge", s_if, (int) O_ge},
  {"ifgt", s_if, (int) O_gt},
  {"ifle", s_if, (int) O_le},
  {"iflt", s_if, (int) O_lt},
  {"ifnc", s_ifc, 1},
  {"ifndef", s_ifdef, 1},
  {"ifne", s_if, (int) O_ne},
  {"ifnes", s_ifeqs, 1},
  {"ifnotdef", s_ifdef, 1},
  {"incbin", s_incbin, 0},
  {"include", s_include, 0},
  {"int", cons, 4},
  {"irp", s_irp, 0},
  {"irep", s_irp, 0},
  {"irpc", s_irp, 1},
  {"irepc", s_irp, 1},
  {"lcomm", s_lcomm, 0},
  {"lflags", listing_flags, 0},	/* Listing flags.  */
  {"linkonce", s_linkonce, 0},
  {"list", listing_list, 1},	/* Turn listing on.  */
  {"llen", listing_psize, 1},
  {"long", cons, 4},
  {"lsym", s_lsym, 0},
  {"macro", s_macro, 0},
  {"mexit", s_mexit, 0},
  {"mri", s_mri, 0},
  {".mri", s_mri, 0},	/* Special case so .mri works in MRI mode.  */
  {"name", s_ignore, 0},
  {"noformat", s_ignore, 0},
  {"nolist", listing_list, 0},	/* Turn listing off.  */
  {"nopage", listing_nopage, 0},
  {"octa", cons, 16},
  {"offset", s_struct, 0},
  {"org", s_org, 0},
  {"p2align", s_align_ptwo, 0},
  {"p2alignw", s_align_ptwo, -2},
  {"p2alignl", s_align_ptwo, -4},
  {"page", listing_eject, 0},
  {"plen", listing_psize, 0},
  {"print", s_print, 0},
  {"psize", listing_psize, 0},	/* Set paper size.  */
  {"purgem", s_purgem, 0},
  {"quad", cons, 8},
  {"rep", s_rept, 0},
  {"rept", s_rept, 0},
  {"rva", s_rva, 4},
  {"sbttl", listing_title, 1},	/* Subtitle of listing.  */
/* scl  */
/* sect  */
  {"set", s_set, 0},
  {"short", cons, 2},
  {"single", float_cons, 'f'},
/* size  */
  {"space", s_space, 0},
  {"skip", s_space, 0},
  {"sleb128", s_leb128, 1},
  {"spc", s_ignore, 0},
  {"stabd", s_stab, 'd'},
  {"stabn", s_stab, 'n'},
  {"stabs", s_stab, 's'},
  {"string", stringer, 1},
  {"struct", s_struct, 0},
/* tag  */
  {"text", s_text, 0},

  /* This is for gcc to use.  It's only just been added (2/94), so gcc
     won't be able to use it for a while -- probably a year or more.
     But once this has been released, check with gcc maintainers
     before deleting it or even changing the spelling.  */
  {"this_GCC_requires_the_GNU_assembler", s_ignore, 0},
  /* If we're folding case -- done for some targets, not necessarily
     all -- the above string in an input file will be converted to
     this one.  Match it either way...  */
  {"this_gcc_requires_the_gnu_assembler", s_ignore, 0},

  {"title", listing_title, 0},	/* Listing title.  */
  {"ttl", listing_title, 0},
/* type  */
  {"uleb128", s_leb128, 0},
/* use  */
/* val  */
  {"xcom", s_comm, 0},
  {"xdef", s_globl, 0},
  {"xref", s_ignore, 0},
  {"xstabs", s_xstab, 's'},
  {"word", cons, 2},
  {"zero", s_space, 0},
  {NULL, NULL, 0}			/* End sentinel.  */
};

static int pop_override_ok = 0;
static const char *pop_table_name;

void
pop_insert (const pseudo_typeS *table)
{
  const char *errtxt;
  const pseudo_typeS *pop;
  for (pop = table; pop->poc_name; pop++)
    {
      errtxt = hash_insert (po_hash, pop->poc_name, (char *) pop);
      if (errtxt && (!pop_override_ok || strcmp (errtxt, "exists")))
	as_fatal (_("error constructing %s pseudo-op table: %s"), pop_table_name,
		  errtxt);
    }
}

#ifndef md_pop_insert
#define md_pop_insert()		pop_insert(md_pseudo_table)
#endif

#ifndef obj_pop_insert
#define obj_pop_insert()	pop_insert(obj_pseudo_table)
#endif

#ifndef cfi_pop_insert
#define cfi_pop_insert()	pop_insert(cfi_pseudo_table)
#endif

static void
pobegin (void)
{
  po_hash = hash_new ();

  /* Do the target-specific pseudo ops.  */
  pop_table_name = "md";
  md_pop_insert ();

  /* Now object specific.  Skip any that were in the target table.  */
  pop_table_name = "obj";
  pop_override_ok = 1;
  obj_pop_insert ();

  /* Now portable ones.  Skip any that we've seen already.  */
  pop_table_name = "standard";
  pop_insert (potable);

#ifdef TARGET_USE_CFIPOP
  pop_table_name = "cfi";
  pop_override_ok = 1;
  cfi_pop_insert ();
#endif
}

#define HANDLE_CONDITIONAL_ASSEMBLY()					\
  if (ignore_input ())							\
    {									\
      while (!is_end_of_line[(unsigned char) *input_line_pointer++])	\
	if (input_line_pointer == buffer_limit)				\
	  break;							\
      continue;								\
    }

/* This function is used when scrubbing the characters between #APP
   and #NO_APP.  */

static char *scrub_string;
static char *scrub_string_end;

static int
scrub_from_string (char *buf, int buflen)
{
  int copy;

  copy = scrub_string_end - scrub_string;
  if (copy > buflen)
    copy = buflen;
  memcpy (buf, scrub_string, copy);
  scrub_string += copy;
  return copy;
}

/* We read the file, putting things into a web that represents what we
   have been reading.  */
void
read_a_source_file (char *name)
{
  register char c;
  register char *s;		/* String of symbol, '\0' appended.  */
  register int temp;
  pseudo_typeS *pop;

#ifdef WARN_COMMENTS
  found_comment = 0;
#endif

  buffer = input_scrub_new_file (name);

  listing_file (name);
  listing_newline (NULL);
  register_dependency (name);

  /* Generate debugging information before we've read anything in to denote
     this file as the "main" source file and not a subordinate one
     (e.g. N_SO vs N_SOL in stabs).  */
  generate_file_debug ();

  while ((buffer_limit = input_scrub_next_buffer (&input_line_pointer)) != 0)
    {				/* We have another line to parse.  */
      know (buffer_limit[-1] == '\n');	/* Must have a sentinel.  */

      while (input_line_pointer < buffer_limit)
	{
	  /* We have more of this buffer to parse.  */

	  /* We now have input_line_pointer->1st char of next line.
	     If input_line_pointer [-1] == '\n' then we just
	     scanned another line: so bump line counters.  */
	  if (is_end_of_line[(unsigned char) input_line_pointer[-1]])
	    {
#ifdef md_start_line_hook
	      md_start_line_hook ();
#endif
	      if (input_line_pointer[-1] == '\n')
		bump_line_counters ();

	      line_label = NULL;

	      if (LABELS_WITHOUT_COLONS || flag_m68k_mri)
		{
		  /* Text at the start of a line must be a label, we
		     run down and stick a colon in.  */
		  if (is_name_beginner (*input_line_pointer))
		    {
		      char *line_start = input_line_pointer;
		      char c;
		      int mri_line_macro;

		      LISTING_NEWLINE ();
		      HANDLE_CONDITIONAL_ASSEMBLY ();

		      c = get_symbol_end ();

		      /* In MRI mode, the EQU and MACRO pseudoops must
			 be handled specially.  */
		      mri_line_macro = 0;
		      if (flag_m68k_mri)
			{
			  char *rest = input_line_pointer + 1;

			  if (*rest == ':')
			    ++rest;
			  if (*rest == ' ' || *rest == '\t')
			    ++rest;
			  if ((strncasecmp (rest, "EQU", 3) == 0
			       || strncasecmp (rest, "SET", 3) == 0)
			      && (rest[3] == ' ' || rest[3] == '\t'))
			    {
			      input_line_pointer = rest + 3;
			      equals (line_start,
				      strncasecmp (rest, "SET", 3) == 0);
			      continue;
			    }
			  if (strncasecmp (rest, "MACRO", 5) == 0
			      && (rest[5] == ' '
				  || rest[5] == '\t'
				  || is_end_of_line[(unsigned char) rest[5]]))
			    mri_line_macro = 1;
			}

		      /* In MRI mode, we need to handle the MACRO
			 pseudo-op specially: we don't want to put the
			 symbol in the symbol table.  */
		      if (!mri_line_macro
#ifdef TC_START_LABEL_WITHOUT_COLON
			  && TC_START_LABEL_WITHOUT_COLON(c,
							  input_line_pointer)
#endif
			  )
			line_label = colon (line_start);
		      else
			line_label = symbol_create (line_start,
						    absolute_section,
						    (valueT) 0,
						    &zero_address_frag);

		      *input_line_pointer = c;
		      if (c == ':')
			input_line_pointer++;
		    }
		}
	    }

	  /* We are at the beginning of a line, or similar place.
	     We expect a well-formed assembler statement.
	     A "symbol-name:" is a statement.

	     Depending on what compiler is used, the order of these tests
	     may vary to catch most common case 1st.
	     Each test is independent of all other tests at the (top) level.
	     PLEASE make a compiler that doesn't use this assembler.
	     It is crufty to waste a compiler's time encoding things for this
	     assembler, which then wastes more time decoding it.
	     (And communicating via (linear) files is silly!
	     If you must pass stuff, please pass a tree!)  */
	  if ((c = *input_line_pointer++) == '\t'
	      || c == ' '
	      || c == '\f'
	      || c == 0)
	    c = *input_line_pointer++;

	  know (c != ' ');	/* No further leading whitespace.  */

#ifndef NO_LISTING
	  /* If listing is on, and we are expanding a macro, then give
	     the listing code the contents of the expanded line.  */
	  if (listing)
	    {
	      if ((listing & LISTING_MACEXP) && macro_nest > 0)
		{
		  char *copy;
		  int len;

		  /* Find the end of the current expanded macro line.  */
		  for (s = input_line_pointer - 1; *s; ++s)
		    if (is_end_of_line[(unsigned char) *s])
		      break;

		  /* Copy it for safe keeping.  Also give an indication of
		     how much macro nesting is involved at this point.  */
		  len = s - (input_line_pointer - 1);
		  copy = (char *) xmalloc (len + macro_nest + 2);
		  memset (copy, '>', macro_nest);
		  copy[macro_nest] = ' ';
		  memcpy (copy + macro_nest + 1, input_line_pointer - 1, len);
		  copy[macro_nest + 1 + len] = '\0';

		  /* Install the line with the listing facility.  */
		  listing_newline (copy);
		}
	      else
		listing_newline (NULL);
	    }
#endif
	  /* C is the 1st significant character.
	     Input_line_pointer points after that character.  */
	  if (is_name_beginner (c))
	    {
	      /* Want user-defined label or pseudo/opcode.  */
	      HANDLE_CONDITIONAL_ASSEMBLY ();

	      s = --input_line_pointer;
	      c = get_symbol_end ();	/* name's delimiter.  */

	      /* C is character after symbol.
		 That character's place in the input line is now '\0'.
		 S points to the beginning of the symbol.
		   [In case of pseudo-op, s->'.'.]
		 Input_line_pointer->'\0' where c was.  */
	      if (TC_START_LABEL (c, input_line_pointer))
		{
		  if (flag_m68k_mri)
		    {
		      char *rest = input_line_pointer + 1;

		      /* In MRI mode, \tsym: set 0 is permitted.  */
		      if (*rest == ':')
			++rest;

		      if (*rest == ' ' || *rest == '\t')
			++rest;

		      if ((strncasecmp (rest, "EQU", 3) == 0
			   || strncasecmp (rest, "SET", 3) == 0)
			  && (rest[3] == ' ' || rest[3] == '\t'))
			{
			  input_line_pointer = rest + 3;
			  equals (s, 1);
			  continue;
			}
		    }

		  line_label = colon (s);	/* User-defined label.  */
		  /* Put ':' back for error messages' sake.  */
		  *input_line_pointer++ = ':';
#ifdef tc_check_label
		  tc_check_label (line_label);
#endif
		  /* Input_line_pointer->after ':'.  */
		  SKIP_WHITESPACE ();
		}
	      else if (c == '='
		       || ((c == ' ' || c == '\t')
			   && input_line_pointer[1] == '='
#ifdef TC_EQUAL_IN_INSN
			   && !TC_EQUAL_IN_INSN (c, input_line_pointer)
#endif
			   ))
		{
		  equals (s, 1);
		  demand_empty_rest_of_line ();
		}
	      else
		{
		  /* Expect pseudo-op or machine instruction.  */
		  pop = NULL;

#ifndef TC_CASE_SENSITIVE
		  {
		    char *s2 = s;

		    strncpy (original_case_string, s2, sizeof (original_case_string));
		    original_case_string[sizeof (original_case_string) - 1] = 0;

		    while (*s2)
		      {
			*s2 = TOLOWER (*s2);
			s2++;
		      }
		  }
#endif
		  if (NO_PSEUDO_DOT || flag_m68k_mri)
		    {
		      /* The MRI assembler and the m88k use pseudo-ops
			 without a period.  */
		      pop = (pseudo_typeS *) hash_find (po_hash, s);
		      if (pop != NULL && pop->poc_handler == NULL)
			pop = NULL;
		    }

		  if (pop != NULL
		      || (!flag_m68k_mri && *s == '.'))
		    {
		      /* PSEUDO - OP.

			 WARNING: c has next char, which may be end-of-line.
			 We lookup the pseudo-op table with s+1 because we
			 already know that the pseudo-op begins with a '.'.  */

		      if (pop == NULL)
			pop = (pseudo_typeS *) hash_find (po_hash, s + 1);
		      if (pop && !pop->poc_handler)
			pop = NULL;

		      /* In MRI mode, we may need to insert an
			 automatic alignment directive.  What a hack
			 this is.  */
		      if (mri_pending_align
			  && (pop == NULL
			      || !((pop->poc_handler == cons
				    && pop->poc_val == 1)
				   || (pop->poc_handler == s_space
				       && pop->poc_val == 1)
#ifdef tc_conditional_pseudoop
				   || tc_conditional_pseudoop (pop)
#endif
				   || pop->poc_handler == s_if
				   || pop->poc_handler == s_ifdef
				   || pop->poc_handler == s_ifc
				   || pop->poc_handler == s_ifeqs
				   || pop->poc_handler == s_else
				   || pop->poc_handler == s_endif
				   || pop->poc_handler == s_globl
				   || pop->poc_handler == s_ignore)))
			{
			  do_align (1, (char *) NULL, 0, 0);
			  mri_pending_align = 0;

			  if (line_label != NULL)
			    {
			      symbol_set_frag (line_label, frag_now);
			      S_SET_VALUE (line_label, frag_now_fix ());
			    }
			}

		      /* Print the error msg now, while we still can.  */
		      if (pop == NULL)
			{
			  as_bad (_("unknown pseudo-op: `%s'"), s);
			  *input_line_pointer = c;
			  s_ignore (0);
			  continue;
			}

		      /* Put it back for error messages etc.  */
		      *input_line_pointer = c;
		      /* The following skip of whitespace is compulsory.
			 A well shaped space is sometimes all that separates
			 keyword from operands.  */
		      if (c == ' ' || c == '\t')
			input_line_pointer++;

		      /* Input_line is restored.
			 Input_line_pointer->1st non-blank char
			 after pseudo-operation.  */
		      (*pop->poc_handler) (pop->poc_val);

		      /* If that was .end, just get out now.  */
		      if (pop->poc_handler == s_end)
			goto quit;
		    }
		  else
		    {
		      int inquote = 0;
#ifdef QUOTES_IN_INSN
		      int inescape = 0;
#endif

		      /* WARNING: c has char, which may be end-of-line.  */
		      /* Also: input_line_pointer->`\0` where c was.  */
		      *input_line_pointer = c;
		      while (!is_end_of_line[(unsigned char) *input_line_pointer]
			     || inquote
#ifdef TC_EOL_IN_INSN
			     || TC_EOL_IN_INSN (input_line_pointer)
#endif
			     )
			{
			  if (flag_m68k_mri && *input_line_pointer == '\'')
			    inquote = !inquote;
#ifdef QUOTES_IN_INSN
			  if (inescape)
			    inescape = 0;
			  else if (*input_line_pointer == '"')
			    inquote = !inquote;
			  else if (*input_line_pointer == '\\')
			    inescape = 1;
#endif
			  input_line_pointer++;
			}

		      c = *input_line_pointer;
		      *input_line_pointer = '\0';

		      generate_lineno_debug ();

		      if (macro_defined)
			{
			  sb out;
			  const char *err;
			  macro_entry *macro;

			  if (check_macro (s, &out, &err, &macro))
			    {
			      if (err != NULL)
				as_bad ("%s", err);
			      *input_line_pointer++ = c;
			      input_scrub_include_sb (&out,
						      input_line_pointer, 1);
			      sb_kill (&out);
			      buffer_limit =
				input_scrub_next_buffer (&input_line_pointer);
#ifdef md_macro_info
			      md_macro_info (macro);
#endif
			      continue;
			    }
			}

		      if (mri_pending_align)
			{
			  do_align (1, (char *) NULL, 0, 0);
			  mri_pending_align = 0;
			  if (line_label != NULL)
			    {
			      symbol_set_frag (line_label, frag_now);
			      S_SET_VALUE (line_label, frag_now_fix ());
			    }
			}

		      md_assemble (s);	/* Assemble 1 instruction.  */

		      *input_line_pointer++ = c;

		      /* We resume loop AFTER the end-of-line from
			 this instruction.  */
		    }
		}
	      continue;
	    }

	  /* Empty statement?  */
	  if (is_end_of_line[(unsigned char) c])
	    continue;

	  if ((LOCAL_LABELS_DOLLAR || LOCAL_LABELS_FB) && ISDIGIT (c))
	    {
	      /* local label  ("4:")  */
	      char *backup = input_line_pointer;

	      HANDLE_CONDITIONAL_ASSEMBLY ();

	      temp = c - '0';

	      /* Read the whole number.  */
	      while (ISDIGIT (*input_line_pointer))
		{
		  temp = (temp * 10) + *input_line_pointer - '0';
		  ++input_line_pointer;
		}

	      if (LOCAL_LABELS_DOLLAR
		  && *input_line_pointer == '$'
		  && *(input_line_pointer + 1) == ':')
		{
		  input_line_pointer += 2;

		  if (dollar_label_defined (temp))
		    {
		      as_fatal (_("label \"%d$\" redefined"), temp);
		    }

		  define_dollar_label (temp);
		  colon (dollar_label_name (temp, 0));
		  continue;
		}

	      if (LOCAL_LABELS_FB
		  && *input_line_pointer++ == ':')
		{
		  fb_label_instance_inc (temp);
		  colon (fb_label_name (temp, 0));
		  continue;
		}

	      input_line_pointer = backup;
	    }			/* local label  ("4:") */

	  if (c && strchr (line_comment_chars, c))
	    {			/* Its a comment.  Better say APP or NO_APP.  */
	      sb sbuf;
	      char *ends;
	      char *new_buf;
	      char *new_tmp;
	      unsigned int new_length;
	      char *tmp_buf = 0;

	      bump_line_counters ();
	      s = input_line_pointer;
	      if (strncmp (s, "APP\n", 4))
		continue;	/* We ignore it */
	      s += 4;

	      sb_new (&sbuf);
	      ends = strstr (s, "#NO_APP\n");

	      if (!ends)
		{
		  unsigned int tmp_len;
		  unsigned int num;

		  /* The end of the #APP wasn't in this buffer.  We
		     keep reading in buffers until we find the #NO_APP
		     that goes with this #APP  There is one.  The specs
		     guarantee it...  */
		  tmp_len = buffer_limit - s;
		  tmp_buf = xmalloc (tmp_len + 1);
		  memcpy (tmp_buf, s, tmp_len);
		  do
		    {
		      new_tmp = input_scrub_next_buffer (&buffer);
		      if (!new_tmp)
			break;
		      else
			buffer_limit = new_tmp;
		      input_line_pointer = buffer;
		      ends = strstr (buffer, "#NO_APP\n");
		      if (ends)
			num = ends - buffer;
		      else
			num = buffer_limit - buffer;

		      tmp_buf = xrealloc (tmp_buf, tmp_len + num);
		      memcpy (tmp_buf + tmp_len, buffer, num);
		      tmp_len += num;
		    }
		  while (!ends);

		  input_line_pointer = ends ? ends + 8 : NULL;

		  s = tmp_buf;
		  ends = s + tmp_len;

		}
	      else
		{
		  input_line_pointer = ends + 8;
		}

	      scrub_string = s;
	      scrub_string_end = ends;

	      new_length = ends - s;
	      new_buf = (char *) xmalloc (new_length);
	      new_tmp = new_buf;
	      for (;;)
		{
		  int space;
		  int size;

		  space = (new_buf + new_length) - new_tmp;
		  size = do_scrub_chars (scrub_from_string, new_tmp, space);

		  if (size < space)
		    {
		      new_tmp[size] = 0;
		      break;
		    }

		  new_buf = xrealloc (new_buf, new_length + 100);
		  new_tmp = new_buf + new_length;
		  new_length += 100;
		}

	      if (tmp_buf)
		free (tmp_buf);

	      /* We've "scrubbed" input to the preferred format.  In the
		 process we may have consumed the whole of the remaining
		 file (and included files).  We handle this formatted
		 input similar to that of macro expansion, letting
		 actual macro expansion (possibly nested) and other
		 input expansion work.  Beware that in messages, line
		 numbers and possibly file names will be incorrect.  */
	      sb_add_string (&sbuf, new_buf);
	      input_scrub_include_sb (&sbuf, input_line_pointer, 0);
	      sb_kill (&sbuf);
	      buffer_limit = input_scrub_next_buffer (&input_line_pointer);
	      free (new_buf);
	      continue;
	    }

	  HANDLE_CONDITIONAL_ASSEMBLY ();

#ifdef tc_unrecognized_line
	  if (tc_unrecognized_line (c))
	    continue;
#endif
	  input_line_pointer--;
	  /* Report unknown char as ignored.  */
	  demand_empty_rest_of_line ();
	}

#ifdef md_after_pass_hook
      md_after_pass_hook ();
#endif
    }

 quit:

#ifdef md_cleanup
  md_cleanup ();
#endif
  /* Close the input file.  */
  input_scrub_close ();
#ifdef WARN_COMMENTS
  {
    if (warn_comment && found_comment)
      as_warn_where (found_comment_file, found_comment,
		     "first comment found here");
  }
#endif
}

/* For most MRI pseudo-ops, the line actually ends at the first
   nonquoted space.  This function looks for that point, stuffs a null
   in, and sets *STOPCP to the character that used to be there, and
   returns the location.

   Until I hear otherwise, I am going to assume that this is only true
   for the m68k MRI assembler.  */

char *
mri_comment_field (char *stopcp)
{
  char *s;
#ifdef TC_M68K
  int inquote = 0;

  know (flag_m68k_mri);

  for (s = input_line_pointer;
       ((!is_end_of_line[(unsigned char) *s] && *s != ' ' && *s != '\t')
	|| inquote);
       s++)
    {
      if (*s == '\'')
	inquote = !inquote;
    }
#else
  for (s = input_line_pointer;
       !is_end_of_line[(unsigned char) *s];
       s++)
    ;
#endif
  *stopcp = *s;
  *s = '\0';

  return s;
}

/* Skip to the end of an MRI comment field.  */

void
mri_comment_end (char *stop, int stopc)
{
  know (flag_mri);

  input_line_pointer = stop;
  *stop = stopc;
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    ++input_line_pointer;
}

void
s_abort (int ignore ATTRIBUTE_UNUSED)
{
  as_fatal (_(".abort detected.  Abandoning ship."));
}

/* Guts of .align directive.  N is the power of two to which to align.
   FILL may be NULL, or it may point to the bytes of the fill pattern.
   LEN is the length of whatever FILL points to, if anything.  MAX is
   the maximum number of characters to skip when doing the alignment,
   or 0 if there is no maximum.  */

static void
do_align (int n, char *fill, int len, int max)
{
  if (now_seg == absolute_section)
    {
      if (fill != NULL)
	while (len-- > 0)
	  if (*fill++ != '\0')
	    {
	      as_warn (_("ignoring fill value in absolute section"));
	      break;
	    }
      fill = NULL;
      len = 0;
    }

#ifdef md_do_align
  md_do_align (n, fill, len, max, just_record_alignment);
#endif

  /* Only make a frag if we HAVE to...  */
  if (n != 0 && !need_pass_2)
    {
      if (fill == NULL)
	{
	  if (subseg_text_p (now_seg))
	    frag_align_code (n, max);
	  else
	    frag_align (n, 0, max);
	}
      else if (len <= 1)
	frag_align (n, *fill, max);
      else
	frag_align_pattern (n, fill, len, max);
    }

#ifdef md_do_align
 just_record_alignment: ATTRIBUTE_UNUSED_LABEL
#endif

  record_alignment (now_seg, n - OCTETS_PER_BYTE_POWER);
}

/* Handle the .align pseudo-op.  A positive ARG is a default alignment
   (in bytes).  A negative ARG is the negative of the length of the
   fill pattern.  BYTES_P is non-zero if the alignment value should be
   interpreted as the byte boundary, rather than the power of 2.  */

static void
s_align (int arg, int bytes_p)
{
  register unsigned int align;
  char *stop = NULL;
  char stopc;
  offsetT fill = 0;
  int max;
  int fill_p;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  if (is_end_of_line[(unsigned char) *input_line_pointer])
    {
      if (arg < 0)
	align = 0;
      else
	align = arg;	/* Default value from pseudo-op table.  */
    }
  else
    {
      align = get_absolute_expression ();
      SKIP_WHITESPACE ();
    }

  if (bytes_p)
    {
      /* Convert to a power of 2.  */
      if (align != 0)
	{
	  unsigned int i;

	  for (i = 0; (align & 1) == 0; align >>= 1, ++i)
	    ;
	  if (align != 1)
	    as_bad (_("alignment not a power of 2"));

	  align = i;
	}
    }

  if (align > 15)
    {
      align = 15;
      as_warn (_("alignment too large: %u assumed"), align);
    }

  if (*input_line_pointer != ',')
    {
      fill_p = 0;
      max = 0;
    }
  else
    {
      ++input_line_pointer;
      if (*input_line_pointer == ',')
	fill_p = 0;
      else
	{
	  fill = get_absolute_expression ();
	  SKIP_WHITESPACE ();
	  fill_p = 1;
	}

      if (*input_line_pointer != ',')
	max = 0;
      else
	{
	  ++input_line_pointer;
	  max = get_absolute_expression ();
	}
    }

  if (!fill_p)
    {
      if (arg < 0)
	as_warn (_("expected fill pattern missing"));
      do_align (align, (char *) NULL, 0, max);
    }
  else
    {
      int fill_len;

      if (arg >= 0)
	fill_len = 1;
      else
	fill_len = -arg;
      if (fill_len <= 1)
	{
	  char fill_char;

	  fill_char = fill;
	  do_align (align, &fill_char, fill_len, max);
	}
      else
	{
	  char ab[16];

	  if ((size_t) fill_len > sizeof ab)
	    abort ();
	  md_number_to_chars (ab, fill, fill_len);
	  do_align (align, ab, fill_len, max);
	}
    }

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

/* Handle the .align pseudo-op on machines where ".align 4" means
   align to a 4 byte boundary.  */

void
s_align_bytes (int arg)
{
  s_align (arg, 1);
}

/* Handle the .align pseudo-op on machines where ".align 4" means align
   to a 2**4 boundary.  */

void
s_align_ptwo (int arg)
{
  s_align (arg, 0);
}

symbolS *
s_comm_internal (int param,
		 symbolS *(*comm_parse_extra) (int, symbolS *, addressT))
{
  char *name;
  char c;
  char *p;
  offsetT temp, size;
  symbolS *symbolP = NULL;
  char *stop = NULL;
  char stopc;
  expressionS exp;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  name = input_line_pointer;
  c = get_symbol_end ();
  /* Just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      goto out;
    }

  SKIP_WHITESPACE ();

  /* Accept an optional comma after the name.  The comma used to be
     required, but Irix 5 cc does not generate it for .lcomm.  */
  if (*input_line_pointer == ',')
    input_line_pointer++;

  *p = 0;
  temp = get_absolute_expr (&exp);
  size = temp;
#ifdef BFD_ASSEMBLER
  size &= ((offsetT) 2 << (stdoutput->arch_info->bits_per_address - 1)) - 1;
#endif
  if (exp.X_op == O_absent)
    {
      as_bad (_("missing size expression"));
      *p = c;
      ignore_rest_of_line ();
      goto out;
    }
  else if (temp != size || !exp.X_unsigned)
    {
      as_warn (_("size (%ld) out of range, ignored"), (long) temp);
      *p = c;
      ignore_rest_of_line ();
      goto out;
    }

  symbolP = symbol_find_or_make (name);
  if (S_IS_DEFINED (symbolP) && !S_IS_COMMON (symbolP))
    {
      symbolP = NULL;
      as_bad (_("symbol `%s' is already defined"), name);
      *p = c;
      ignore_rest_of_line ();
      goto out;
    }

  size = S_GET_VALUE (symbolP);
  if (size == 0)
    size = temp;
  else if (size != temp)
    as_warn (_("size of \"%s\" is already %ld; not changing to %ld"),
	     name, (long) size, (long) temp);

  *p = c;
  if (comm_parse_extra != NULL)
    symbolP = (*comm_parse_extra) (param, symbolP, size);
  else
    {
      S_SET_VALUE (symbolP, (valueT) size);
      S_SET_EXTERNAL (symbolP);
#ifdef OBJ_VMS
      {
	extern int flag_one;
	if (size == 0 || !flag_one)
	  S_GET_OTHER (symbolP) = const_flag;
      }
#endif
    }

  know (symbolP == NULL || symbolP->sy_frag == &zero_address_frag);
  demand_empty_rest_of_line ();
 out:
  if (flag_mri)
    mri_comment_end (stop, stopc);
  return symbolP;
}

void
s_comm (int ignore)
{
  s_comm_internal (ignore, NULL);
}

/* The MRI COMMON pseudo-op.  We handle this by creating a common
   symbol with the appropriate name.  We make s_space do the right
   thing by increasing the size.  */

void
s_mri_common (int small ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char *alc = NULL;
  symbolS *sym;
  offsetT align;
  char *stop = NULL;
  char stopc;

  if (!flag_mri)
    {
      s_comm (0);
      return;
    }

  stop = mri_comment_field (&stopc);

  SKIP_WHITESPACE ();

  name = input_line_pointer;
  if (!ISDIGIT (*name))
    c = get_symbol_end ();
  else
    {
      do
	{
	  ++input_line_pointer;
	}
      while (ISDIGIT (*input_line_pointer));

      c = *input_line_pointer;
      *input_line_pointer = '\0';

      if (line_label != NULL)
	{
	  alc = (char *) xmalloc (strlen (S_GET_NAME (line_label))
				  + (input_line_pointer - name)
				  + 1);
	  sprintf (alc, "%s%s", name, S_GET_NAME (line_label));
	  name = alc;
	}
    }

  sym = symbol_find_or_make (name);
  *input_line_pointer = c;
  if (alc != NULL)
    free (alc);

  if (*input_line_pointer != ',')
    align = 0;
  else
    {
      ++input_line_pointer;
      align = get_absolute_expression ();
    }

  if (S_IS_DEFINED (sym) && !S_IS_COMMON (sym))
    {
      as_bad (_("symbol `%s' is already defined"), S_GET_NAME (sym));
      ignore_rest_of_line ();
      mri_comment_end (stop, stopc);
      return;
    }

  S_SET_EXTERNAL (sym);
  mri_common_symbol = sym;

#ifdef S_SET_ALIGN
  if (align != 0)
    S_SET_ALIGN (sym, align);
#endif

  if (line_label != NULL)
    {
      expressionS exp;
      exp.X_op = O_symbol;
      exp.X_add_symbol = sym;
      exp.X_add_number = 0;
      symbol_set_value_expression (line_label, &exp);
      symbol_set_frag (line_label, &zero_address_frag);
      S_SET_SEGMENT (line_label, expr_section);
    }

  /* FIXME: We just ignore the small argument, which distinguishes
     COMMON and COMMON.S.  I don't know what we can do about it.  */

  /* Ignore the type and hptype.  */
  if (*input_line_pointer == ',')
    input_line_pointer += 2;
  if (*input_line_pointer == ',')
    input_line_pointer += 2;

  demand_empty_rest_of_line ();

  mri_comment_end (stop, stopc);
}

void
s_data (int ignore ATTRIBUTE_UNUSED)
{
  segT section;
  register int temp;

  temp = get_absolute_expression ();
  if (flag_readonly_data_in_text)
    {
      section = text_section;
      temp += 1000;
    }
  else
    section = data_section;

  subseg_set (section, (subsegT) temp);

#ifdef OBJ_VMS
  const_flag = 0;
#endif
  demand_empty_rest_of_line ();
}

/* Handle the .appfile pseudo-op.  This is automatically generated by
   do_scrub_chars when a preprocessor # line comment is seen with a
   file name.  This default definition may be overridden by the object
   or CPU specific pseudo-ops.  This function is also the default
   definition for .file; the APPFILE argument is 1 for .appfile, 0 for
   .file.  */

void
s_app_file_string (char *file)
{
#ifdef LISTING
  if (listing)
    listing_source_file (file);
#endif
  register_dependency (file);
#ifdef obj_app_file
  obj_app_file (file);
#endif
}

void
s_app_file (int appfile)
{
  register char *s;
  int length;

  /* Some assemblers tolerate immediately following '"'.  */
  if ((s = demand_copy_string (&length)) != 0)
    {
      /* If this is a fake .appfile, a fake newline was inserted into
	 the buffer.  Passing -2 to new_logical_line tells it to
	 account for it.  */
      int may_omit
	= (!new_logical_line (s, appfile ? -2 : -1) && appfile);

      /* In MRI mode, the preprocessor may have inserted an extraneous
	 backquote.  */
      if (flag_m68k_mri
	  && *input_line_pointer == '\''
	  && is_end_of_line[(unsigned char) input_line_pointer[1]])
	++input_line_pointer;

      demand_empty_rest_of_line ();
      if (!may_omit)
	s_app_file_string (s);
    }
}

/* Handle the .appline pseudo-op.  This is automatically generated by
   do_scrub_chars when a preprocessor # line comment is seen.  This
   default definition may be overridden by the object or CPU specific
   pseudo-ops.  */

void
s_app_line (int ignore ATTRIBUTE_UNUSED)
{
  int l;

  /* The given number is that of the next line.  */
  l = get_absolute_expression () - 1;
  if (l < 0)
    /* Some of the back ends can't deal with non-positive line numbers.
       Besides, it's silly.  */
    as_warn (_("line numbers must be positive; line number %d rejected"),
	     l + 1);
  else
    {
      new_logical_line ((char *) NULL, l);
#ifdef LISTING
      if (listing)
	listing_source_line (l);
#endif
    }
  demand_empty_rest_of_line ();
}

/* Handle the .end pseudo-op.  Actually, the real work is done in
   read_a_source_file.  */

void
s_end (int ignore ATTRIBUTE_UNUSED)
{
  if (flag_mri)
    {
      /* The MRI assembler permits the start symbol to follow .end,
	 but we don't support that.  */
      SKIP_WHITESPACE ();
      if (!is_end_of_line[(unsigned char) *input_line_pointer]
	  && *input_line_pointer != '*'
	  && *input_line_pointer != '!')
	as_warn (_("start address not supported"));
    }
}

/* Handle the .err pseudo-op.  */

void
s_err (int ignore ATTRIBUTE_UNUSED)
{
  as_bad (_(".err encountered"));
  demand_empty_rest_of_line ();
}

/* Handle the MRI fail pseudo-op.  */

void
s_fail (int ignore ATTRIBUTE_UNUSED)
{
  offsetT temp;
  char *stop = NULL;
  char stopc;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  temp = get_absolute_expression ();
  if (temp >= 500)
    as_warn (_(".fail %ld encountered"), (long) temp);
  else
    as_bad (_(".fail %ld encountered"), (long) temp);

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

void
s_fill (int ignore ATTRIBUTE_UNUSED)
{
  expressionS rep_exp;
  long size = 1;
  register long fill = 0;
  char *p;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  get_known_segmented_expression (&rep_exp);
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      size = get_absolute_expression ();
      if (*input_line_pointer == ',')
	{
	  input_line_pointer++;
	  fill = get_absolute_expression ();
	}
    }

  /* This is to be compatible with BSD 4.2 AS, not for any rational reason.  */
#define BSD_FILL_SIZE_CROCK_8 (8)
  if (size > BSD_FILL_SIZE_CROCK_8)
    {
      as_warn (_(".fill size clamped to %d"), BSD_FILL_SIZE_CROCK_8);
      size = BSD_FILL_SIZE_CROCK_8;
    }
  if (size < 0)
    {
      as_warn (_("size negative; .fill ignored"));
      size = 0;
    }
  else if (rep_exp.X_op == O_constant && rep_exp.X_add_number <= 0)
    {
      if (rep_exp.X_add_number < 0)
	as_warn (_("repeat < 0; .fill ignored"));
      size = 0;
    }

  if (size && !need_pass_2)
    {
      if (rep_exp.X_op == O_constant)
	{
	  p = frag_var (rs_fill, (int) size, (int) size,
			(relax_substateT) 0, (symbolS *) 0,
			(offsetT) rep_exp.X_add_number,
			(char *) 0);
	}
      else
	{
	  /* We don't have a constant repeat count, so we can't use
	     rs_fill.  We can get the same results out of rs_space,
	     but its argument is in bytes, so we must multiply the
	     repeat count by size.  */

	  symbolS *rep_sym;
	  rep_sym = make_expr_symbol (&rep_exp);
	  if (size != 1)
	    {
	      expressionS size_exp;
	      size_exp.X_op = O_constant;
	      size_exp.X_add_number = size;

	      rep_exp.X_op = O_multiply;
	      rep_exp.X_add_symbol = rep_sym;
	      rep_exp.X_op_symbol = make_expr_symbol (&size_exp);
	      rep_exp.X_add_number = 0;
	      rep_sym = make_expr_symbol (&rep_exp);
	    }

	  p = frag_var (rs_space, (int) size, (int) size,
			(relax_substateT) 0, rep_sym, (offsetT) 0, (char *) 0);
	}

      memset (p, 0, (unsigned int) size);

      /* The magic number BSD_FILL_SIZE_CROCK_4 is from BSD 4.2 VAX
	 flavoured AS.  The following bizarre behaviour is to be
	 compatible with above.  I guess they tried to take up to 8
	 bytes from a 4-byte expression and they forgot to sign
	 extend.  */
#define BSD_FILL_SIZE_CROCK_4 (4)
      md_number_to_chars (p, (valueT) fill,
			  (size > BSD_FILL_SIZE_CROCK_4
			   ? BSD_FILL_SIZE_CROCK_4
			   : (int) size));
      /* Note: .fill (),0 emits no frag (since we are asked to .fill 0 bytes)
	 but emits no error message because it seems a legal thing to do.
	 It is a degenerate case of .fill but could be emitted by a
	 compiler.  */
    }
  demand_empty_rest_of_line ();
}

void
s_globl (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  int c;
  symbolS *symbolP;
  char *stop = NULL;
  char stopc;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      S_SET_EXTERNAL (symbolP);

      *input_line_pointer = c;
      SKIP_WHITESPACE ();
      c = *input_line_pointer;
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (is_end_of_line[(unsigned char) *input_line_pointer])
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

/* Handle the MRI IRP and IRPC pseudo-ops.  */

void
s_irp (int irpc)
{
  char *file;
  unsigned int line;
  sb s;
  const char *err;
  sb out;

  as_where (&file, &line);

  sb_new (&s);
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    sb_add_char (&s, *input_line_pointer++);

  sb_new (&out);

  err = expand_irp (irpc, 0, &s, &out, get_line_sb);
  if (err != NULL)
    as_bad_where (file, line, "%s", err);

  sb_kill (&s);

  input_scrub_include_sb (&out, input_line_pointer, 1);
  sb_kill (&out);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Handle the .linkonce pseudo-op.  This tells the assembler to mark
   the section to only be linked once.  However, this is not supported
   by most object file formats.  This takes an optional argument,
   which is what to do about duplicates.  */

void
s_linkonce (int ignore ATTRIBUTE_UNUSED)
{
  enum linkonce_type type;

  SKIP_WHITESPACE ();

  type = LINKONCE_DISCARD;

  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *s;
      char c;

      s = input_line_pointer;
      c = get_symbol_end ();
      if (strcasecmp (s, "discard") == 0)
	type = LINKONCE_DISCARD;
      else if (strcasecmp (s, "one_only") == 0)
	type = LINKONCE_ONE_ONLY;
      else if (strcasecmp (s, "same_size") == 0)
	type = LINKONCE_SAME_SIZE;
      else if (strcasecmp (s, "same_contents") == 0)
	type = LINKONCE_SAME_CONTENTS;
      else
	as_warn (_("unrecognized .linkonce type `%s'"), s);

      *input_line_pointer = c;
    }

#ifdef obj_handle_link_once
  obj_handle_link_once (type);
#else /* ! defined (obj_handle_link_once) */
#ifdef BFD_ASSEMBLER
  {
    flagword flags;

    if ((bfd_applicable_section_flags (stdoutput) & SEC_LINK_ONCE) == 0)
      as_warn (_(".linkonce is not supported for this object file format"));

    flags = bfd_get_section_flags (stdoutput, now_seg);
    flags |= SEC_LINK_ONCE;
    switch (type)
      {
      default:
	abort ();
      case LINKONCE_DISCARD:
	flags |= SEC_LINK_DUPLICATES_DISCARD;
	break;
      case LINKONCE_ONE_ONLY:
	flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
	break;
      case LINKONCE_SAME_SIZE:
	flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
	break;
      case LINKONCE_SAME_CONTENTS:
	flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
	break;
      }
    if (!bfd_set_section_flags (stdoutput, now_seg, flags))
      as_bad (_("bfd_set_section_flags: %s"),
	      bfd_errmsg (bfd_get_error ()));
  }
#else /* ! defined (BFD_ASSEMBLER) */
  as_warn (_(".linkonce is not supported for this object file format"));
#endif /* ! defined (BFD_ASSEMBLER) */
#endif /* ! defined (obj_handle_link_once) */

  demand_empty_rest_of_line ();
}

void
bss_alloc (symbolS *symbolP, addressT size, int align)
{
  char *pfrag;
  segT current_seg = now_seg;
  subsegT current_subseg = now_subseg;
  segT bss_seg = bss_section;

#if defined (TC_MIPS) || defined (TC_ALPHA)
  if (OUTPUT_FLAVOR == bfd_target_ecoff_flavour
      || OUTPUT_FLAVOR == bfd_target_elf_flavour)
    {
      /* For MIPS and Alpha ECOFF or ELF, small objects are put in .sbss.  */
      if (size <= bfd_get_gp_size (stdoutput))
	{
	  bss_seg = subseg_new (".sbss", 1);
	  seg_info (bss_seg)->bss = 1;
#ifdef BFD_ASSEMBLER
	  if (!bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
	    as_warn (_("error setting flags for \".sbss\": %s"),
		     bfd_errmsg (bfd_get_error ()));
#endif
	}
    }
#endif
  subseg_set (bss_seg, 1);

  if (align)
    {
      record_alignment (bss_seg, align);
      frag_align (align, 0, 0);
    }

  /* Detach from old frag.  */
  if (S_GET_SEGMENT (symbolP) == bss_seg)
    symbol_get_frag (symbolP)->fr_symbol = NULL;

  symbol_set_frag (symbolP, frag_now);
  pfrag = frag_var (rs_org, 1, 1, 0, symbolP, size, NULL);
  *pfrag = 0;

#ifdef S_SET_SIZE
  S_SET_SIZE (symbolP, size);
#endif
  S_SET_SEGMENT (symbolP, bss_seg);

#ifdef OBJ_COFF
  /* The symbol may already have been created with a preceding
     ".globl" directive -- be careful not to step on storage class
     in that case.  Otherwise, set it to static.  */
  if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
    S_SET_STORAGE_CLASS (symbolP, C_STAT);
#endif /* OBJ_COFF */

  subseg_set (current_seg, current_subseg);
}

offsetT
parse_align (int align_bytes)
{
  expressionS exp;
  addressT align;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
    no_align:
      as_bad (_("expected alignment after size"));
      ignore_rest_of_line ();
      return -1;
    }

  input_line_pointer++;
  SKIP_WHITESPACE ();

  align = get_absolute_expr (&exp);
  if (exp.X_op == O_absent)
    goto no_align;

  if (!exp.X_unsigned)
    {
      as_warn (_("alignment negative; 0 assumed"));
      align = 0;
    }

  if (align_bytes && align != 0)
    {
      /* convert to a power of 2 alignment */
      unsigned int alignp2 = 0;
      while ((align & 1) == 0)
	align >>= 1, ++alignp2;
      if (align != 1)
	{
	  as_bad (_("alignment not a power of 2"));
	  ignore_rest_of_line ();
	  return -1;
	}
      align = alignp2;
    }
  return align;
}

/* Called from s_comm_internal after symbol name and size have been
   parsed.  NEEDS_ALIGN is 0 if it was an ".lcomm" (2 args only),
   1 if this was a ".bss" directive which has a 3rd argument
   (alignment as a power of 2), or 2 if this was a ".bss" directive
   with alignment in bytes.  */

symbolS *
s_lcomm_internal (int needs_align, symbolS *symbolP, addressT size)
{
  addressT align = 0;

  if (needs_align)
    {
      align = parse_align (needs_align - 1);
      if (align == (addressT) -1)
	return NULL;
    }
  else
    /* Assume some objects may require alignment on some systems.  */
    TC_IMPLICIT_LCOMM_ALIGNMENT (size, align);

  bss_alloc (symbolP, size, align);
  return symbolP;
}

void
s_lcomm (int needs_align)
{
  s_comm_internal (needs_align, s_lcomm_internal);
}

void
s_lcomm_bytes (int needs_align)
{
  s_comm_internal (needs_align * 2, s_lcomm_internal);
}

void
s_lsym (int ignore ATTRIBUTE_UNUSED)
{
  register char *name;
  register char c;
  register char *p;
  expressionS exp;
  register symbolS *symbolP;

  /* We permit ANY defined expression: BSD4.2 demands constants.  */
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      *p = 0;
      as_bad (_("expected comma after \"%s\""), name);
      *p = c;
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;
  expression (&exp);

  if (exp.X_op != O_constant
      && exp.X_op != O_register)
    {
      as_bad (_("bad expression"));
      ignore_rest_of_line ();
      return;
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);

  /* FIXME-SOON I pulled a (&& symbolP->sy_other == 0 &&
     symbolP->sy_desc == 0) out of this test because coff doesn't have
     those fields, and I can't see when they'd ever be tripped.  I
     don't think I understand why they were here so I may have
     introduced a bug. As recently as 1.37 didn't have this test
     anyway.  xoxorich.  */

  if (S_GET_SEGMENT (symbolP) == undefined_section
      && S_GET_VALUE (symbolP) == 0)
    {
      /* The name might be an undefined .global symbol; be sure to
	 keep the "external" bit.  */
      S_SET_SEGMENT (symbolP,
		     (exp.X_op == O_constant
		      ? absolute_section
		      : reg_section));
      S_SET_VALUE (symbolP, (valueT) exp.X_add_number);
    }
  else
    {
      as_bad (_("symbol `%s' is already defined"), name);
    }

  *p = c;
  demand_empty_rest_of_line ();
}

/* Read a line into an sb.  Returns the character that ended the line
   or zero if there are no more lines.  */

static int
get_line_sb (sb *line)
{
  char quote1, quote2, inquote;
  unsigned char c;

  if (input_line_pointer[-1] == '\n')
    bump_line_counters ();

  if (input_line_pointer >= buffer_limit)
    {
      buffer_limit = input_scrub_next_buffer (&input_line_pointer);
      if (buffer_limit == 0)
	return 0;
    }

  /* If app.c sets any other characters to LEX_IS_STRINGQUOTE, this
     code needs to be changed.  */
  if (!flag_m68k_mri)
    quote1 = '"';
  else
    quote1 = '\0';

  quote2 = '\0';
  if (flag_m68k_mri)
    quote2 = '\'';
#ifdef LEX_IS_STRINGQUOTE
  quote2 = '\'';
#endif

  inquote = '\0';

  while ((c = * input_line_pointer ++) != 0
	 && (!is_end_of_line[c]
	     || (inquote != '\0' && c != '\n')))
    {
      if (inquote == c)
	inquote = '\0';
      else if (inquote == '\0')
	{
	  if (c == quote1)
	    inquote = quote1;
	  else if (c == quote2)
	    inquote = quote2;
	}

      sb_add_char (line, c);
    }

  /* Don't skip multiple end-of-line characters, because that breaks support
     for the IA-64 stop bit (;;) which looks like two consecutive end-of-line
     characters but isn't.  Instead just skip one end of line character and
     return the character skipped so that the caller can re-insert it if
     necessary.   */
  return c;
}

/* Define a macro.  This is an interface to macro.c.  */

void
s_macro (int ignore ATTRIBUTE_UNUSED)
{
  char *file;
  unsigned int line;
  sb s;
  sb label;
  const char *err;
  const char *name;

  as_where (&file, &line);

  sb_new (&s);
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    sb_add_char (&s, *input_line_pointer++);

  sb_new (&label);
  if (line_label != NULL)
    sb_add_string (&label, S_GET_NAME (line_label));

  err = define_macro (0, &s, &label, get_line_sb, &name);
  if (err != NULL)
    as_bad_where (file, line, "%s", err);
  else
    {
      if (line_label != NULL)
	{
	  S_SET_SEGMENT (line_label, undefined_section);
	  S_SET_VALUE (line_label, 0);
	  symbol_set_frag (line_label, &zero_address_frag);
	}

      if (((NO_PSEUDO_DOT || flag_m68k_mri)
	   && hash_find (po_hash, name) != NULL)
	  || (!flag_m68k_mri
	      && *name == '.'
	      && hash_find (po_hash, name + 1) != NULL))
	as_warn (_("attempt to redefine pseudo-op `%s' ignored"),
		 name);
    }

  sb_kill (&s);
}

/* Handle the .mexit pseudo-op, which immediately exits a macro
   expansion.  */

void
s_mexit (int ignore ATTRIBUTE_UNUSED)
{
  cond_exit_macro (macro_nest);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Switch in and out of MRI mode.  */

void
s_mri (int ignore ATTRIBUTE_UNUSED)
{
  int on, old_flag;

  on = get_absolute_expression ();
  old_flag = flag_mri;
  if (on != 0)
    {
      flag_mri = 1;
#ifdef TC_M68K
      flag_m68k_mri = 1;
#endif
      macro_mri_mode (1);
    }
  else
    {
      flag_mri = 0;
#ifdef TC_M68K
      flag_m68k_mri = 0;
#endif
      macro_mri_mode (0);
    }

  /* Operator precedence changes in m68k MRI mode, so we need to
     update the operator rankings.  */
  expr_set_precedence ();

#ifdef MRI_MODE_CHANGE
  if (on != old_flag)
    MRI_MODE_CHANGE (on);
#endif

  demand_empty_rest_of_line ();
}

/* Handle changing the location counter.  */

static void
do_org (segT segment, expressionS *exp, int fill)
{
  if (segment != now_seg && segment != absolute_section)
    as_bad (_("invalid segment \"%s\""), segment_name (segment));

  if (now_seg == absolute_section)
    {
      if (fill != 0)
	as_warn (_("ignoring fill value in absolute section"));
      if (exp->X_op != O_constant)
	{
	  as_bad (_("only constant offsets supported in absolute section"));
	  exp->X_add_number = 0;
	}
      abs_section_offset = exp->X_add_number;
    }
  else
    {
      char *p;
      symbolS *sym = exp->X_add_symbol;
      offsetT off = exp->X_add_number * OCTETS_PER_BYTE;

      if (exp->X_op != O_constant && exp->X_op != O_symbol)
	{
	  /* Handle complex expressions.  */
	  sym = make_expr_symbol (exp);
	  off = 0;
	}

      p = frag_var (rs_org, 1, 1, (relax_substateT) 0, sym, off, (char *) 0);
      *p = fill;
    }
}

void
s_org (int ignore ATTRIBUTE_UNUSED)
{
  register segT segment;
  expressionS exp;
  register long temp_fill;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  /* The m68k MRI assembler has a different meaning for .org.  It
     means to create an absolute section at a given address.  We can't
     support that--use a linker script instead.  */
  if (flag_m68k_mri)
    {
      as_bad (_("MRI style ORG pseudo-op not supported"));
      ignore_rest_of_line ();
      return;
    }

  /* Don't believe the documentation of BSD 4.2 AS.  There is no such
     thing as a sub-segment-relative origin.  Any absolute origin is
     given a warning, then assumed to be segment-relative.  Any
     segmented origin expression ("foo+42") had better be in the right
     segment or the .org is ignored.

     BSD 4.2 AS warns if you try to .org backwards. We cannot because
     we never know sub-segment sizes when we are reading code.  BSD
     will crash trying to emit negative numbers of filler bytes in
     certain .orgs. We don't crash, but see as-write for that code.

     Don't make frag if need_pass_2==1.  */
  segment = get_known_segmented_expression (&exp);
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
    }
  else
    temp_fill = 0;

  if (!need_pass_2)
    do_org (segment, &exp, temp_fill);

  demand_empty_rest_of_line ();
}

/* Handle parsing for the MRI SECT/SECTION pseudo-op.  This should be
   called by the obj-format routine which handles section changing
   when in MRI mode.  It will create a new section, and return it.  It
   will set *TYPE to the section type: one of 'C' (code), 'D' (data),
   'M' (mixed), or 'R' (romable).  If BFD_ASSEMBLER is defined, the
   flags will be set in the section.  */

void
s_mri_sect (char *type ATTRIBUTE_UNUSED)
{
#ifdef TC_M68K

  char *name;
  char c;
  segT seg;

  SKIP_WHITESPACE ();

  name = input_line_pointer;
  if (!ISDIGIT (*name))
    c = get_symbol_end ();
  else
    {
      do
	{
	  ++input_line_pointer;
	}
      while (ISDIGIT (*input_line_pointer));

      c = *input_line_pointer;
      *input_line_pointer = '\0';
    }

  name = xstrdup (name);

  *input_line_pointer = c;

  seg = subseg_new (name, 0);

  if (*input_line_pointer == ',')
    {
      int align;

      ++input_line_pointer;
      align = get_absolute_expression ();
      record_alignment (seg, align);
    }

  *type = 'C';
  if (*input_line_pointer == ',')
    {
      c = *++input_line_pointer;
      c = TOUPPER (c);
      if (c == 'C' || c == 'D' || c == 'M' || c == 'R')
	*type = c;
      else
	as_bad (_("unrecognized section type"));
      ++input_line_pointer;

#ifdef BFD_ASSEMBLER
      {
	flagword flags;

	flags = SEC_NO_FLAGS;
	if (*type == 'C')
	  flags = SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE;
	else if (*type == 'D' || *type == 'M')
	  flags = SEC_ALLOC | SEC_LOAD | SEC_DATA;
	else if (*type == 'R')
	  flags = SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_READONLY | SEC_ROM;
	if (flags != SEC_NO_FLAGS)
	  {
	    if (!bfd_set_section_flags (stdoutput, seg, flags))
	      as_warn (_("error setting flags for \"%s\": %s"),
		       bfd_section_name (stdoutput, seg),
		       bfd_errmsg (bfd_get_error ()));
	  }
      }
#endif
    }

  /* Ignore the HP type.  */
  if (*input_line_pointer == ',')
    input_line_pointer += 2;

  demand_empty_rest_of_line ();

#else /* ! TC_M68K */
#ifdef TC_I960

  char *name;
  char c;
  segT seg;

  SKIP_WHITESPACE ();

  name = input_line_pointer;
  c = get_symbol_end ();

  name = xstrdup (name);

  *input_line_pointer = c;

  seg = subseg_new (name, 0);

  if (*input_line_pointer != ',')
    *type = 'C';
  else
    {
      char *sectype;

      ++input_line_pointer;
      SKIP_WHITESPACE ();
      sectype = input_line_pointer;
      c = get_symbol_end ();
      if (*sectype == '\0')
	*type = 'C';
      else if (strcasecmp (sectype, "text") == 0)
	*type = 'C';
      else if (strcasecmp (sectype, "data") == 0)
	*type = 'D';
      else if (strcasecmp (sectype, "romdata") == 0)
	*type = 'R';
      else
	as_warn (_("unrecognized section type `%s'"), sectype);
      *input_line_pointer = c;
    }

  if (*input_line_pointer == ',')
    {
      char *seccmd;

      ++input_line_pointer;
      SKIP_WHITESPACE ();
      seccmd = input_line_pointer;
      c = get_symbol_end ();
      if (strcasecmp (seccmd, "absolute") == 0)
	{
	  as_bad (_("absolute sections are not supported"));
	  *input_line_pointer = c;
	  ignore_rest_of_line ();
	  return;
	}
      else if (strcasecmp (seccmd, "align") == 0)
	{
	  int align;

	  *input_line_pointer = c;
	  align = get_absolute_expression ();
	  record_alignment (seg, align);
	}
      else
	{
	  as_warn (_("unrecognized section command `%s'"), seccmd);
	  *input_line_pointer = c;
	}
    }

  demand_empty_rest_of_line ();

#else /* ! TC_I960 */
  /* The MRI assembler seems to use different forms of .sect for
     different targets.  */
  as_bad ("MRI mode not supported for this target");
  ignore_rest_of_line ();
#endif /* ! TC_I960 */
#endif /* ! TC_M68K */
}

/* Handle the .print pseudo-op.  */

void
s_print (int ignore ATTRIBUTE_UNUSED)
{
  char *s;
  int len;

  s = demand_copy_C_string (&len);
  if (s != NULL)
    printf ("%s\n", s);
  demand_empty_rest_of_line ();
}

/* Handle the .purgem pseudo-op.  */

void
s_purgem (int ignore ATTRIBUTE_UNUSED)
{
  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      char *name;
      char c;

      SKIP_WHITESPACE ();
      name = input_line_pointer;
      c = get_symbol_end ();
      delete_macro (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();
    }
  while (*input_line_pointer++ == ',');

  --input_line_pointer;
  demand_empty_rest_of_line ();
}

/* Handle the .rept pseudo-op.  */

void
s_bad_endr (int ignore ATTRIBUTE_UNUSED)
{
  as_warn (_(".endr encountered without preceeding .rept, .irc, or .irp"));
  demand_empty_rest_of_line ();
}

/* Handle the .rept pseudo-op.  */

void
s_rept (int ignore ATTRIBUTE_UNUSED)
{
  int count;

  count = get_absolute_expression ();

  do_repeat (count, "REPT", "ENDR");
}

/* This function provides a generic repeat block implementation.   It allows
   different directives to be used as the start/end keys.  */

void
do_repeat (int count, const char *start, const char *end)
{
  sb one;
  sb many;

  sb_new (&one);
  if (!buffer_and_nest (start, end, &one, get_line_sb))
    {
      as_bad (_("%s without %s"), start, end);
      return;
    }

  sb_new (&many);
  while (count-- > 0)
    sb_add_sb (&many, &one);

  sb_kill (&one);

  input_scrub_include_sb (&many, input_line_pointer, 1);
  sb_kill (&many);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Skip to end of current repeat loop; EXTRA indicates how many additional
   input buffers to skip.  Assumes that conditionals preceding the loop end
   are properly nested.

   This function makes it easier to implement a premature "break" out of the
   loop.  The EXTRA arg accounts for other buffers we might have inserted,
   such as line substitutions.  */

void
end_repeat (int extra)
{
  cond_exit_macro (macro_nest);
  while (extra-- >= 0)
    buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Handle the .equ, .equiv and .set directives.  If EQUIV is 1, then
   this is .equiv, and it is an error if the symbol is already
   defined.  */

void
s_set (int equiv)
{
  register char *name;
  register char delim;
  register char *end_name;
  register symbolS *symbolP;

  /* Especial apologies for the random logic:
     this just grew, and could be parsed much more simply!
     Dean in haste.  */
  name = input_line_pointer;
  delim = get_symbol_end ();
  end_name = input_line_pointer;
  *end_name = delim;

  if (name == end_name)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      *end_name = 0;
      as_bad (_("expected comma after \"%s\""), name);
      *end_name = delim;
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;
  *end_name = 0;

  if (name[0] == '.' && name[1] == '\0')
    {
      /* Turn '. = mumble' into a .org mumble.  */
      register segT segment;
      expressionS exp;

      segment = get_known_segmented_expression (&exp);

      if (!need_pass_2)
	do_org (segment, &exp, 0);

      *end_name = delim;
      return;
    }

  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
	 for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct *listing_tail;
	  fragS *dummy_frag = (fragS *) xmalloc (sizeof (fragS));
	  memset (dummy_frag, 0, sizeof (fragS));
	  dummy_frag->fr_type = rs_fill;
	  dummy_frag->line = listing_tail;
	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
	  dummy_frag->fr_symbol = symbolP;
	}
      else
#endif
	symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);

#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF */
    }

  symbol_table_insert (symbolP);

  *end_name = delim;

  if (equiv
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));

  pseudo_set (symbolP);
  demand_empty_rest_of_line ();
}

void
s_space (int mult)
{
  expressionS exp;
  expressionS val;
  char *p = 0;
  char *stop = NULL;
  char stopc;
  int bytes;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  /* In m68k MRI mode, we need to align to a word boundary, unless
     this is ds.b.  */
  if (flag_m68k_mri && mult > 1)
    {
      if (now_seg == absolute_section)
	{
	  abs_section_offset += abs_section_offset & 1;
	  if (line_label != NULL)
	    S_SET_VALUE (line_label, abs_section_offset);
	}
      else if (mri_common_symbol != NULL)
	{
	  valueT val;

	  val = S_GET_VALUE (mri_common_symbol);
	  if ((val & 1) != 0)
	    {
	      S_SET_VALUE (mri_common_symbol, val + 1);
	      if (line_label != NULL)
		{
		  expressionS *symexp;

		  symexp = symbol_get_value_expression (line_label);
		  know (symexp->X_op == O_symbol);
		  know (symexp->X_add_symbol == mri_common_symbol);
		  symexp->X_add_number += 1;
		}
	    }
	}
      else
	{
	  do_align (1, (char *) NULL, 0, 0);
	  if (line_label != NULL)
	    {
	      symbol_set_frag (line_label, frag_now);
	      S_SET_VALUE (line_label, frag_now_fix ());
	    }
	}
    }

  bytes = mult;

  expression (&exp);

  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      expression (&val);
    }
  else
    {
      val.X_op = O_constant;
      val.X_add_number = 0;
    }

  if (val.X_op != O_constant
      || val.X_add_number < - 0x80
      || val.X_add_number > 0xff
      || (mult != 0 && mult != 1 && val.X_add_number != 0))
    {
      if (exp.X_op != O_constant)
	as_bad (_("unsupported variable size or fill value"));
      else
	{
	  offsetT i;

	  if (mult == 0)
	    mult = 1;
	  bytes = mult * exp.X_add_number;
	  for (i = 0; i < exp.X_add_number; i++)
	    emit_expr (&val, mult);
	}
    }
  else
    {
      if (exp.X_op == O_constant)
	{
	  long repeat;

	  repeat = exp.X_add_number;
	  if (mult)
	    repeat *= mult;
	  bytes = repeat;
	  if (repeat <= 0)
	    {
	      if (!flag_mri)
		as_warn (_(".space repeat count is zero, ignored"));
	      else if (repeat < 0)
		as_warn (_(".space repeat count is negative, ignored"));
	      goto getout;
	    }

	  /* If we are in the absolute section, just bump the offset.  */
	  if (now_seg == absolute_section)
	    {
	      abs_section_offset += repeat;
	      goto getout;
	    }

	  /* If we are secretly in an MRI common section, then
	     creating space just increases the size of the common
	     symbol.  */
	  if (mri_common_symbol != NULL)
	    {
	      S_SET_VALUE (mri_common_symbol,
			   S_GET_VALUE (mri_common_symbol) + repeat);
	      goto getout;
	    }

	  if (!need_pass_2)
	    p = frag_var (rs_fill, 1, 1, (relax_substateT) 0, (symbolS *) 0,
			  (offsetT) repeat, (char *) 0);
	}
      else
	{
	  if (now_seg == absolute_section)
	    {
	      as_bad (_("space allocation too complex in absolute section"));
	      subseg_set (text_section, 0);
	    }

	  if (mri_common_symbol != NULL)
	    {
	      as_bad (_("space allocation too complex in common section"));
	      mri_common_symbol = NULL;
	    }

	  if (!need_pass_2)
	    p = frag_var (rs_space, 1, 1, (relax_substateT) 0,
			  make_expr_symbol (&exp), (offsetT) 0, (char *) 0);
	}

      if (p)
	*p = val.X_add_number;
    }

 getout:

  /* In MRI mode, after an odd number of bytes, we must align to an
     even word boundary, unless the next instruction is a dc.b, ds.b
     or dcb.b.  */
  if (flag_mri && (bytes & 1) != 0)
    mri_pending_align = 1;

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

/* This is like s_space, but the value is a floating point number with
   the given precision.  This is for the MRI dcb.s pseudo-op and
   friends.  */

void
s_float_space (int float_type)
{
  offsetT count;
  int flen;
  char temp[MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT];
  char *stop = NULL;
  char stopc;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  count = get_absolute_expression ();

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("missing value"));
      ignore_rest_of_line ();
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
    }

  ++input_line_pointer;

  SKIP_WHITESPACE ();

  /* Skip any 0{letter} that may be present.  Don't even check if the
   * letter is legal.  */
  if (input_line_pointer[0] == '0'
      && ISALPHA (input_line_pointer[1]))
    input_line_pointer += 2;

  /* Accept :xxxx, where the x's are hex digits, for a floating point
     with the exact digits specified.  */
  if (input_line_pointer[0] == ':')
    {
      flen = hex_float (float_type, temp);
      if (flen < 0)
	{
	  ignore_rest_of_line ();
	  if (flag_mri)
	    mri_comment_end (stop, stopc);
	  return;
	}
    }
  else
    {
      char *err;

      err = md_atof (float_type, temp, &flen);
      know (flen <= MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT);
      know (flen > 0);
      if (err)
	{
	  as_bad (_("bad floating literal: %s"), err);
	  ignore_rest_of_line ();
	  if (flag_mri)
	    mri_comment_end (stop, stopc);
	  return;
	}
    }

  while (--count >= 0)
    {
      char *p;

      p = frag_more (flen);
      memcpy (p, temp, (unsigned int) flen);
    }

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

/* Handle the .struct pseudo-op, as found in MIPS assemblers.  */

void
s_struct (int ignore ATTRIBUTE_UNUSED)
{
  char *stop = NULL;
  char stopc;

  if (flag_mri)
    stop = mri_comment_field (&stopc);
  abs_section_offset = get_absolute_expression ();
  subseg_set (absolute_section, 0);
  demand_empty_rest_of_line ();
  if (flag_mri)
    mri_comment_end (stop, stopc);
}

void
s_text (int ignore ATTRIBUTE_UNUSED)
{
  register int temp;

  temp = get_absolute_expression ();
  subseg_set (text_section, (subsegT) temp);
  demand_empty_rest_of_line ();
#ifdef OBJ_VMS
  const_flag &= ~IN_DEFAULT_SECTION;
#endif
}


/* Verify that we are at the end of a line.  If not, issue an error and
   skip to EOL.  */

void
demand_empty_rest_of_line (void)
{
  SKIP_WHITESPACE ();
  if (is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;
  else
    {
      if (ISPRINT (*input_line_pointer))
	as_bad (_("junk at end of line, first unrecognized character is `%c'"),
		 *input_line_pointer);
      else
	as_bad (_("junk at end of line, first unrecognized character valued 0x%x"),
		 *input_line_pointer);
      ignore_rest_of_line ();
    }
  
  /* Return pointing just after end-of-line.  */
  know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
}

/* Silently advance to the end of line.  Use this after already having
   issued an error about something bad.  */

void
ignore_rest_of_line (void)
{
  while (input_line_pointer < buffer_limit
	 && !is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;

  input_line_pointer++;

  /* Return pointing just after end-of-line.  */
  know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
}

void
discard_rest_of_line (void)
{
  while (input_line_pointer < buffer_limit
	 && !is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;

  input_line_pointer++;

  /* Return pointing just after end-of-line.  */
  know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
}

/* In:	Pointer to a symbol.
	Input_line_pointer->expression.

   Out:	Input_line_pointer->just after any whitespace after expression.
	Tried to set symbol to value of expression.
	Will change symbols type, value, and frag;  */

void
pseudo_set (symbolS *symbolP)
{
  expressionS exp;
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
  int ext;
#endif /* OBJ_AOUT or OBJ_BOUT */

  know (symbolP);		/* NULL pointer is logic error.  */
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
  ext = S_IS_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */

  (void) expression (&exp);

  if (exp.X_op == O_illegal)
    as_bad (_("illegal expression"));
  else if (exp.X_op == O_absent)
    as_bad (_("missing expression"));
  else if (exp.X_op == O_big)
    {
      if (exp.X_add_number > 0)
	as_bad (_("bignum invalid"));
      else
	as_bad (_("floating point number invalid"));
    }
  else if (exp.X_op == O_subtract
	   && SEG_NORMAL (S_GET_SEGMENT (exp.X_add_symbol))
	   && (symbol_get_frag (exp.X_add_symbol)
	       == symbol_get_frag (exp.X_op_symbol)))
    {
      exp.X_op = O_constant;
      exp.X_add_number = (S_GET_VALUE (exp.X_add_symbol)
			  - S_GET_VALUE (exp.X_op_symbol));
    }

  switch (exp.X_op)
    {
    case O_illegal:
    case O_absent:
    case O_big:
      exp.X_add_number = 0;
      /* Fall through.  */
    case O_constant:
      S_SET_SEGMENT (symbolP, absolute_section);
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
      if (ext)
	S_SET_EXTERNAL (symbolP);
      else
	S_CLEAR_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */
      S_SET_VALUE (symbolP, (valueT) exp.X_add_number);
      if (exp.X_op != O_constant)
	symbol_set_frag (symbolP, &zero_address_frag);
      break;

    case O_register:
      S_SET_SEGMENT (symbolP, reg_section);
      S_SET_VALUE (symbolP, (valueT) exp.X_add_number);
      symbol_set_frag (symbolP, &zero_address_frag);
      break;

    case O_symbol:
      if (S_GET_SEGMENT (exp.X_add_symbol) == undefined_section
	  || exp.X_add_number != 0)
	symbol_set_value_expression (symbolP, &exp);
      else if (symbol_section_p (symbolP))
	as_bad ("attempt to set value of section symbol");
      else
	{
	  symbolS *s = exp.X_add_symbol;

	  S_SET_SEGMENT (symbolP, S_GET_SEGMENT (s));
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
	  if (ext)
	    S_SET_EXTERNAL (symbolP);
	  else
	    S_CLEAR_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */
	  S_SET_VALUE (symbolP,
		       exp.X_add_number + S_GET_VALUE (s));
	  symbol_set_frag (symbolP, symbol_get_frag (s));
	  copy_symbol_attributes (symbolP, s);
	}
      break;

    default:
      /* The value is some complex expression.
	 FIXME: Should we set the segment to anything?  */
      symbol_set_value_expression (symbolP, &exp);
      break;
    }
}

/*			cons()

   CONStruct more frag of .bytes, or .words etc.
   Should need_pass_2 be 1 then emit no frag(s).
   This understands EXPRESSIONS.

   Bug (?)

   This has a split personality. We use expression() to read the
   value. We can detect if the value won't fit in a byte or word.
   But we can't detect if expression() discarded significant digits
   in the case of a long. Not worth the crocks required to fix it.  */

/* Select a parser for cons expressions.  */

/* Some targets need to parse the expression in various fancy ways.
   You can define TC_PARSE_CONS_EXPRESSION to do whatever you like
   (for example, the HPPA does this).  Otherwise, you can define
   BITFIELD_CONS_EXPRESSIONS to permit bitfields to be specified, or
   REPEAT_CONS_EXPRESSIONS to permit repeat counts.  If none of these
   are defined, which is the normal case, then only simple expressions
   are permitted.  */

#ifdef TC_M68K
static void
parse_mri_cons (expressionS *exp, unsigned int nbytes);
#endif

#ifndef TC_PARSE_CONS_EXPRESSION
#ifdef BITFIELD_CONS_EXPRESSIONS
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) parse_bitfield_cons (EXP, NBYTES)
static void
parse_bitfield_cons (expressionS *exp, unsigned int nbytes);
#endif
#ifdef REPEAT_CONS_EXPRESSIONS
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) parse_repeat_cons (EXP, NBYTES)
static void
parse_repeat_cons (expressionS *exp, unsigned int nbytes);
#endif

/* If we haven't gotten one yet, just call expression.  */
#ifndef TC_PARSE_CONS_EXPRESSION
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) expression (EXP)
#endif
#endif

void
do_parse_cons_expression (expressionS *exp,
			  int nbytes ATTRIBUTE_UNUSED)
{
  TC_PARSE_CONS_EXPRESSION (exp, nbytes);
}


/* Worker to do .byte etc statements.
   Clobbers input_line_pointer and checks end-of-line.  */

static void
cons_worker (register int nbytes,	/* 1=.byte, 2=.word, 4=.long.  */
	     int rva)
{
  int c;
  expressionS exp;
  char *stop = NULL;
  char stopc;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  c = 0;
  do
    {
#ifdef TC_M68K
      if (flag_m68k_mri)
	parse_mri_cons (&exp, (unsigned int) nbytes);
      else
#endif
	TC_PARSE_CONS_EXPRESSION (&exp, (unsigned int) nbytes);

      if (rva)
	{
	  if (exp.X_op == O_symbol)
	    exp.X_op = O_symbol_rva;
	  else
	    as_fatal (_("rva without symbol"));
	}
      emit_expr (&exp, (unsigned int) nbytes);
      ++c;
    }
  while (*input_line_pointer++ == ',');

  /* In MRI mode, after an odd number of bytes, we must align to an
     even word boundary, unless the next instruction is a dc.b, ds.b
     or dcb.b.  */
  if (flag_mri && nbytes == 1 && (c & 1) != 0)
    mri_pending_align = 1;

  input_line_pointer--;		/* Put terminator back into stream.  */

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

void
cons (int size)
{
  cons_worker (size, 0);
}

void
s_rva (int size)
{
  cons_worker (size, 1);
}

/* Put the contents of expression EXP into the object file using
   NBYTES bytes.  If need_pass_2 is 1, this does nothing.  */

void
emit_expr (expressionS *exp, unsigned int nbytes)
{
  operatorT op;
  register char *p;
  valueT extra_digit = 0;

  /* Don't do anything if we are going to make another pass.  */
  if (need_pass_2)
    return;

  dot_value = frag_now_fix ();

#ifndef NO_LISTING
#ifdef OBJ_ELF
  /* When gcc emits DWARF 1 debugging pseudo-ops, a line number will
     appear as a four byte positive constant in the .line section,
     followed by a 2 byte 0xffff.  Look for that case here.  */
  {
    static int dwarf_line = -1;

    if (strcmp (segment_name (now_seg), ".line") != 0)
      dwarf_line = -1;
    else if (dwarf_line >= 0
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && (exp->X_add_number == -1 || exp->X_add_number == 0xffff))
      listing_source_line ((unsigned int) dwarf_line);
    else if (nbytes == 4
	     && exp->X_op == O_constant
	     && exp->X_add_number >= 0)
      dwarf_line = exp->X_add_number;
    else
      dwarf_line = -1;
  }

  /* When gcc emits DWARF 1 debugging pseudo-ops, a file name will
     appear as a 2 byte TAG_compile_unit (0x11) followed by a 2 byte
     AT_sibling (0x12) followed by a four byte address of the sibling
     followed by a 2 byte AT_name (0x38) followed by the name of the
     file.  We look for that case here.  */
  {
    static int dwarf_file = 0;

    if (strcmp (segment_name (now_seg), ".debug") != 0)
      dwarf_file = 0;
    else if (dwarf_file == 0
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && exp->X_add_number == 0x11)
      dwarf_file = 1;
    else if (dwarf_file == 1
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && exp->X_add_number == 0x12)
      dwarf_file = 2;
    else if (dwarf_file == 2
	     && nbytes == 4)
      dwarf_file = 3;
    else if (dwarf_file == 3
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && exp->X_add_number == 0x38)
      dwarf_file = 4;
    else
      dwarf_file = 0;

    /* The variable dwarf_file_string tells stringer that the string
       may be the name of the source file.  */
    if (dwarf_file == 4)
      dwarf_file_string = 1;
    else
      dwarf_file_string = 0;
  }
#endif
#endif

  if (check_eh_frame (exp, &nbytes))
    return;

  op = exp->X_op;

  /* Allow `.word 0' in the absolute section.  */
  if (now_seg == absolute_section)
    {
      if (op != O_constant || exp->X_add_number != 0)
	as_bad (_("attempt to store value in absolute section"));
      abs_section_offset += nbytes;
      return;
    }

  /* Handle a negative bignum.  */
  if (op == O_uminus
      && exp->X_add_number == 0
      && symbol_get_value_expression (exp->X_add_symbol)->X_op == O_big
      && symbol_get_value_expression (exp->X_add_symbol)->X_add_number > 0)
    {
      int i;
      unsigned long carry;

      exp = symbol_get_value_expression (exp->X_add_symbol);

      /* Negate the bignum: one's complement each digit and add 1.  */
      carry = 1;
      for (i = 0; i < exp->X_add_number; i++)
	{
	  unsigned long next;

	  next = (((~(generic_bignum[i] & LITTLENUM_MASK))
		   & LITTLENUM_MASK)
		  + carry);
	  generic_bignum[i] = next & LITTLENUM_MASK;
	  carry = next >> LITTLENUM_NUMBER_OF_BITS;
	}

      /* We can ignore any carry out, because it will be handled by
	 extra_digit if it is needed.  */

      extra_digit = (valueT) -1;
      op = O_big;
    }

  if (op == O_absent || op == O_illegal)
    {
      as_warn (_("zero assumed for missing expression"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_big && exp->X_add_number <= 0)
    {
      as_bad (_("floating point number invalid"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_register)
    {
      as_warn (_("register value used as expression"));
      op = O_constant;
    }

  p = frag_more ((int) nbytes);

#ifndef WORKING_DOT_WORD
  /* If we have the difference of two symbols in a word, save it on
     the broken_words list.  See the code in write.c.  */
  if (op == O_subtract && nbytes == 2)
    {
      struct broken_word *x;

      x = (struct broken_word *) xmalloc (sizeof (struct broken_word));
      x->next_broken_word = broken_words;
      broken_words = x;
      x->seg = now_seg;
      x->subseg = now_subseg;
      x->frag = frag_now;
      x->word_goes_here = p;
      x->dispfrag = 0;
      x->add = exp->X_add_symbol;
      x->sub = exp->X_op_symbol;
      x->addnum = exp->X_add_number;
      x->added = 0;
      x->use_jump = 0;
      new_broken_words++;
      return;
    }
#endif

  /* If we have an integer, but the number of bytes is too large to
     pass to md_number_to_chars, handle it as a bignum.  */
  if (op == O_constant && nbytes > sizeof (valueT))
    {
      valueT val;
      int gencnt;

      if (!exp->X_unsigned && exp->X_add_number < 0)
	extra_digit = (valueT) -1;
      val = (valueT) exp->X_add_number;
      gencnt = 0;
      do
	{
	  generic_bignum[gencnt] = val & LITTLENUM_MASK;
	  val >>= LITTLENUM_NUMBER_OF_BITS;
	  ++gencnt;
	}
      while (val != 0);
      op = exp->X_op = O_big;
      exp->X_add_number = gencnt;
    }

  if (op == O_constant)
    {
      register valueT get;
      register valueT use;
      register valueT mask;
      valueT hibit;
      register valueT unmask;

      /* JF << of >= number of bits in the object is undefined.  In
	 particular SPARC (Sun 4) has problems.  */
      if (nbytes >= sizeof (valueT))
	{
	  mask = 0;
	  if (nbytes > sizeof (valueT))
	    hibit = 0;
	  else
	    hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
	}
      else
	{
	  /* Don't store these bits.  */
	  mask = ~(valueT) 0 << (BITS_PER_CHAR * nbytes);
	  hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
	}

      unmask = ~mask;		/* Do store these bits.  */

#ifdef NEVER
      "Do this mod if you want every overflow check to assume SIGNED 2's complement data.";
      mask = ~(unmask >> 1);	/* Includes sign bit now.  */
#endif

      get = exp->X_add_number;
      use = get & unmask;
      if ((get & mask) != 0
	  && ((get & mask) != mask
	      || (get & hibit) == 0))
	{		/* Leading bits contain both 0s & 1s.  */
	  as_warn (_("value 0x%lx truncated to 0x%lx"),
		   (unsigned long) get, (unsigned long) use);
	}
      /* Put bytes in right order.  */
      md_number_to_chars (p, use, (int) nbytes);
    }
  else if (op == O_big)
    {
      unsigned int size;
      LITTLENUM_TYPE *nums;

      size = exp->X_add_number * CHARS_PER_LITTLENUM;
      if (nbytes < size)
	{
	  int i = nbytes / CHARS_PER_LITTLENUM;
	  if (i != 0)
	    {
	      LITTLENUM_TYPE sign = 0;
	      if ((generic_bignum[--i]
		   & (1 << (LITTLENUM_NUMBER_OF_BITS - 1))) != 0)
		sign = ~(LITTLENUM_TYPE) 0;
	      while (++i < exp->X_add_number)
		if (generic_bignum[i] != sign)
		  break;
	    }
	  if (i < exp->X_add_number)
	    as_warn (_("bignum truncated to %d bytes"), nbytes);
	  size = nbytes;
	}

      if (nbytes == 1)
	{
	  md_number_to_chars (p, (valueT) generic_bignum[0], 1);
	  return;
	}
      know (nbytes % CHARS_PER_LITTLENUM == 0);

      if (target_big_endian)
	{
	  while (nbytes > size)
	    {
	      md_number_to_chars (p, extra_digit, CHARS_PER_LITTLENUM);
	      nbytes -= CHARS_PER_LITTLENUM;
	      p += CHARS_PER_LITTLENUM;
	    }

	  nums = generic_bignum + size / CHARS_PER_LITTLENUM;
	  while (size >= CHARS_PER_LITTLENUM)
	    {
	      --nums;
	      md_number_to_chars (p, (valueT) *nums, CHARS_PER_LITTLENUM);
	      size -= CHARS_PER_LITTLENUM;
	      p += CHARS_PER_LITTLENUM;
	    }
	}
      else
	{
	  nums = generic_bignum;
	  while (size >= CHARS_PER_LITTLENUM)
	    {
	      md_number_to_chars (p, (valueT) *nums, CHARS_PER_LITTLENUM);
	      ++nums;
	      size -= CHARS_PER_LITTLENUM;
	      p += CHARS_PER_LITTLENUM;
	      nbytes -= CHARS_PER_LITTLENUM;
	    }

	  while (nbytes >= CHARS_PER_LITTLENUM)
	    {
	      md_number_to_chars (p, extra_digit, CHARS_PER_LITTLENUM);
	      nbytes -= CHARS_PER_LITTLENUM;
	      p += CHARS_PER_LITTLENUM;
	    }
	}
    }
  else
    {
      memset (p, 0, nbytes);

      /* Now we need to generate a fixS to record the symbol value.
	 This is easy for BFD.  For other targets it can be more
	 complex.  For very complex cases (currently, the HPPA and
	 NS32K), you can define TC_CONS_FIX_NEW to do whatever you
	 want.  For simpler cases, you can define TC_CONS_RELOC to be
	 the name of the reloc code that should be stored in the fixS.
	 If neither is defined, the code uses NO_RELOC if it is
	 defined, and otherwise uses 0.  */

#ifdef BFD_ASSEMBLER
#ifdef TC_CONS_FIX_NEW
      TC_CONS_FIX_NEW (frag_now, p - frag_now->fr_literal, nbytes, exp);
#else
      {
	bfd_reloc_code_real_type r;

	switch (nbytes)
	  {
	  case 1:
	    r = BFD_RELOC_8;
	    break;
	  case 2:
	    r = BFD_RELOC_16;
	    break;
	  case 4:
	    r = BFD_RELOC_32;
	    break;
	  case 8:
	    r = BFD_RELOC_64;
	    break;
	  default:
	    as_bad (_("unsupported BFD relocation size %u"), nbytes);
	    r = BFD_RELOC_32;
	    break;
	  }
	fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp,
		     0, r);
      }
#endif
#else
#ifdef TC_CONS_FIX_NEW
      TC_CONS_FIX_NEW (frag_now, p - frag_now->fr_literal, nbytes, exp);
#else
      /* Figure out which reloc number to use.  Use TC_CONS_RELOC if
	 it is defined, otherwise use NO_RELOC if it is defined,
	 otherwise use 0.  */
#ifndef TC_CONS_RELOC
#ifdef NO_RELOC
#define TC_CONS_RELOC NO_RELOC
#else
#define TC_CONS_RELOC 0
#endif
#endif
      fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp, 0,
		   TC_CONS_RELOC);
#endif /* TC_CONS_FIX_NEW */
#endif /* BFD_ASSEMBLER */
    }
}

#ifdef BITFIELD_CONS_EXPRESSIONS

/* i960 assemblers, (eg, asm960), allow bitfields after ".byte" as
   w:x,y:z, where w and y are bitwidths and x and y are values.  They
   then pack them all together. We do a little better in that we allow
   them in words, longs, etc. and we'll pack them in target byte order
   for you.

   The rules are: pack least significant bit first, if a field doesn't
   entirely fit, put it in the next unit.  Overflowing the bitfield is
   explicitly *not* even a warning.  The bitwidth should be considered
   a "mask".

   To use this function the tc-XXX.h file should define
   BITFIELD_CONS_EXPRESSIONS.  */

static void
parse_bitfield_cons (exp, nbytes)
     expressionS *exp;
     unsigned int nbytes;
{
  unsigned int bits_available = BITS_PER_CHAR * nbytes;
  char *hold = input_line_pointer;

  (void) expression (exp);

  if (*input_line_pointer == ':')
    {
      /* Bitfields.  */
      long value = 0;

      for (;;)
	{
	  unsigned long width;

	  if (*input_line_pointer != ':')
	    {
	      input_line_pointer = hold;
	      break;
	    }			/* Next piece is not a bitfield.  */

	  /* In the general case, we can't allow
	     full expressions with symbol
	     differences and such.  The relocation
	     entries for symbols not defined in this
	     assembly would require arbitrary field
	     widths, positions, and masks which most
	     of our current object formats don't
	     support.

	     In the specific case where a symbol
	     *is* defined in this assembly, we
	     *could* build fixups and track it, but
	     this could lead to confusion for the
	     backends.  I'm lazy. I'll take any
	     SEG_ABSOLUTE. I think that means that
	     you can use a previous .set or
	     .equ type symbol.  xoxorich.  */

	  if (exp->X_op == O_absent)
	    {
	      as_warn (_("using a bit field width of zero"));
	      exp->X_add_number = 0;
	      exp->X_op = O_constant;
	    }			/* Implied zero width bitfield.  */

	  if (exp->X_op != O_constant)
	    {
	      *input_line_pointer = '\0';
	      as_bad (_("field width \"%s\" too complex for a bitfield"), hold);
	      *input_line_pointer = ':';
	      demand_empty_rest_of_line ();
	      return;
	    }			/* Too complex.  */

	  if ((width = exp->X_add_number) > (BITS_PER_CHAR * nbytes))
	    {
	      as_warn (_("field width %lu too big to fit in %d bytes: truncated to %d bits"),
		       width, nbytes, (BITS_PER_CHAR * nbytes));
	      width = BITS_PER_CHAR * nbytes;
	    }			/* Too big.  */

	  if (width > bits_available)
	    {
	      /* FIXME-SOMEDAY: backing up and reparsing is wasteful.  */
	      input_line_pointer = hold;
	      exp->X_add_number = value;
	      break;
	    }			/* Won't fit.  */

	  /* Skip ':'.  */
	  hold = ++input_line_pointer;

	  (void) expression (exp);
	  if (exp->X_op != O_constant)
	    {
	      char cache = *input_line_pointer;

	      *input_line_pointer = '\0';
	      as_bad (_("field value \"%s\" too complex for a bitfield"), hold);
	      *input_line_pointer = cache;
	      demand_empty_rest_of_line ();
	      return;
	    }			/* Too complex.  */

	  value |= ((~(-1 << width) & exp->X_add_number)
		    << ((BITS_PER_CHAR * nbytes) - bits_available));

	  if ((bits_available -= width) == 0
	      || is_it_end_of_statement ()
	      || *input_line_pointer != ',')
	    {
	      break;
	    }			/* All the bitfields we're gonna get.  */

	  hold = ++input_line_pointer;
	  (void) expression (exp);
	}

      exp->X_add_number = value;
      exp->X_op = O_constant;
      exp->X_unsigned = 1;
    }
}

#endif /* BITFIELD_CONS_EXPRESSIONS */

/* Handle an MRI style string expression.  */

#ifdef TC_M68K
static void
parse_mri_cons (exp, nbytes)
     expressionS *exp;
     unsigned int nbytes;
{
  if (*input_line_pointer != '\''
      && (input_line_pointer[1] != '\''
	  || (*input_line_pointer != 'A'
	      && *input_line_pointer != 'E')))
    TC_PARSE_CONS_EXPRESSION (exp, nbytes);
  else
    {
      unsigned int scan;
      unsigned int result = 0;

      /* An MRI style string.  Cut into as many bytes as will fit into
	 a nbyte chunk, left justify if necessary, and separate with
	 commas so we can try again later.  */
      if (*input_line_pointer == 'A')
	++input_line_pointer;
      else if (*input_line_pointer == 'E')
	{
	  as_bad (_("EBCDIC constants are not supported"));
	  ++input_line_pointer;
	}

      input_line_pointer++;
      for (scan = 0; scan < nbytes; scan++)
	{
	  if (*input_line_pointer == '\'')
	    {
	      if (input_line_pointer[1] == '\'')
		{
		  input_line_pointer++;
		}
	      else
		break;
	    }
	  result = (result << 8) | (*input_line_pointer++);
	}

      /* Left justify.  */
      while (scan < nbytes)
	{
	  result <<= 8;
	  scan++;
	}

      /* Create correct expression.  */
      exp->X_op = O_constant;
      exp->X_add_number = result;

      /* Fake it so that we can read the next char too.  */
      if (input_line_pointer[0] != '\'' ||
	  (input_line_pointer[0] == '\'' && input_line_pointer[1] == '\''))
	{
	  input_line_pointer -= 2;
	  input_line_pointer[0] = ',';
	  input_line_pointer[1] = '\'';
	}
      else
	input_line_pointer++;
    }
}
#endif /* TC_M68K */

#ifdef REPEAT_CONS_EXPRESSIONS

/* Parse a repeat expression for cons.  This is used by the MIPS
   assembler.  The format is NUMBER:COUNT; NUMBER appears in the
   object file COUNT times.

   To use this for a target, define REPEAT_CONS_EXPRESSIONS.  */

static void
parse_repeat_cons (exp, nbytes)
     expressionS *exp;
     unsigned int nbytes;
{
  expressionS count;
  register int i;

  expression (exp);

  if (*input_line_pointer != ':')
    {
      /* No repeat count.  */
      return;
    }

  ++input_line_pointer;
  expression (&count);
  if (count.X_op != O_constant
      || count.X_add_number <= 0)
    {
      as_warn (_("unresolvable or nonpositive repeat count; using 1"));
      return;
    }

  /* The cons function is going to output this expression once.  So we
     output it count - 1 times.  */
  for (i = count.X_add_number - 1; i > 0; i--)
    emit_expr (exp, nbytes);
}

#endif /* REPEAT_CONS_EXPRESSIONS */

/* Parse a floating point number represented as a hex constant.  This
   permits users to specify the exact bits they want in the floating
   point number.  */

static int
hex_float (int float_type, char *bytes)
{
  int length;
  int i;

  switch (float_type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      length = 4;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      length = 8;
      break;

    case 'x':
    case 'X':
      length = 12;
      break;

    case 'p':
    case 'P':
      length = 12;
      break;

    default:
      as_bad (_("unknown floating type type '%c'"), float_type);
      return -1;
    }

  /* It would be nice if we could go through expression to parse the
     hex constant, but if we get a bignum it's a pain to sort it into
     the buffer correctly.  */
  i = 0;
  while (hex_p (*input_line_pointer) || *input_line_pointer == '_')
    {
      int d;

      /* The MRI assembler accepts arbitrary underscores strewn about
	 through the hex constant, so we ignore them as well.  */
      if (*input_line_pointer == '_')
	{
	  ++input_line_pointer;
	  continue;
	}

      if (i >= length)
	{
	  as_warn (_("floating point constant too large"));
	  return -1;
	}
      d = hex_value (*input_line_pointer) << 4;
      ++input_line_pointer;
      while (*input_line_pointer == '_')
	++input_line_pointer;
      if (hex_p (*input_line_pointer))
	{
	  d += hex_value (*input_line_pointer);
	  ++input_line_pointer;
	}
      if (target_big_endian)
	bytes[i] = d;
      else
	bytes[length - i - 1] = d;
      ++i;
    }

  if (i < length)
    {
      if (target_big_endian)
	memset (bytes + i, 0, length - i);
      else
	memset (bytes, 0, length - i);
    }

  return length;
}

/*			float_cons()

   CONStruct some more frag chars of .floats .ffloats etc.
   Makes 0 or more new frags.
   If need_pass_2 == 1, no frags are emitted.
   This understands only floating literals, not expressions. Sorry.

   A floating constant is defined by atof_generic(), except it is preceded
   by 0d 0f 0g or 0h. After observing the STRANGE way my BSD AS does its
   reading, I decided to be incompatible. This always tries to give you
   rounded bits to the precision of the pseudo-op. Former AS did premature
   truncation, restored noisy bits instead of trailing 0s AND gave you
   a choice of 2 flavours of noise according to which of 2 floating-point
   scanners you directed AS to use.

   In:	input_line_pointer->whitespace before, or '0' of flonum.  */

void
float_cons (/* Clobbers input_line-pointer, checks end-of-line.  */
	    register int float_type	/* 'f':.ffloat ... 'F':.float ...  */)
{
  register char *p;
  int length;			/* Number of chars in an object.  */
  register char *err;		/* Error from scanning floating literal.  */
  char temp[MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT];

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  do
    {
      /* input_line_pointer->1st char of a flonum (we hope!).  */
      SKIP_WHITESPACE ();

      /* Skip any 0{letter} that may be present. Don't even check if the
	 letter is legal. Someone may invent a "z" format and this routine
	 has no use for such information. Lusers beware: you get
	 diagnostics if your input is ill-conditioned.  */
      if (input_line_pointer[0] == '0'
	  && ISALPHA (input_line_pointer[1]))
	input_line_pointer += 2;

      /* Accept :xxxx, where the x's are hex digits, for a floating
	 point with the exact digits specified.  */
      if (input_line_pointer[0] == ':')
	{
	  ++input_line_pointer;
	  length = hex_float (float_type, temp);
	  if (length < 0)
	    {
	      ignore_rest_of_line ();
	      return;
	    }
	}
      else
	{
	  err = md_atof (float_type, temp, &length);
	  know (length <= MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT);
	  know (length > 0);
	  if (err)
	    {
	      as_bad (_("bad floating literal: %s"), err);
	      ignore_rest_of_line ();
	      return;
	    }
	}

      if (!need_pass_2)
	{
	  int count;

	  count = 1;

#ifdef REPEAT_CONS_EXPRESSIONS
	  if (*input_line_pointer == ':')
	    {
	      expressionS count_exp;

	      ++input_line_pointer;
	      expression (&count_exp);

	      if (count_exp.X_op != O_constant
		  || count_exp.X_add_number <= 0)
		as_warn (_("unresolvable or nonpositive repeat count; using 1"));
	      else
		count = count_exp.X_add_number;
	    }
#endif

	  while (--count >= 0)
	    {
	      p = frag_more (length);
	      memcpy (p, temp, (unsigned int) length);
	    }
	}
      SKIP_WHITESPACE ();
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  --input_line_pointer;
  demand_empty_rest_of_line ();
}

/* Return the size of a LEB128 value.  */

static inline int
sizeof_sleb128 (offsetT value)
{
  register int size = 0;
  register unsigned byte;

  do
    {
      byte = (value & 0x7f);
      /* Sadly, we cannot rely on typical arithmetic right shift behaviour.
	 Fortunately, we can structure things so that the extra work reduces
	 to a noop on systems that do things "properly".  */
      value = (value >> 7) | ~(-(offsetT)1 >> 7);
      size += 1;
    }
  while (!(((value == 0) && ((byte & 0x40) == 0))
	   || ((value == -1) && ((byte & 0x40) != 0))));

  return size;
}

static inline int
sizeof_uleb128 (valueT value)
{
  register int size = 0;
  register unsigned byte;

  do
    {
      byte = (value & 0x7f);
      value >>= 7;
      size += 1;
    }
  while (value != 0);

  return size;
}

int
sizeof_leb128 (valueT value, int sign)
{
  if (sign)
    return sizeof_sleb128 ((offsetT) value);
  else
    return sizeof_uleb128 (value);
}

/* Output a LEB128 value.  */

static inline int
output_sleb128 (char *p, offsetT value)
{
  register char *orig = p;
  register int more;

  do
    {
      unsigned byte = (value & 0x7f);

      /* Sadly, we cannot rely on typical arithmetic right shift behaviour.
	 Fortunately, we can structure things so that the extra work reduces
	 to a noop on systems that do things "properly".  */
      value = (value >> 7) | ~(-(offsetT)1 >> 7);

      more = !((((value == 0) && ((byte & 0x40) == 0))
		|| ((value == -1) && ((byte & 0x40) != 0))));
      if (more)
	byte |= 0x80;

      *p++ = byte;
    }
  while (more);

  return p - orig;
}

static inline int
output_uleb128 (char *p, valueT value)
{
  char *orig = p;

  do
    {
      unsigned byte = (value & 0x7f);
      value >>= 7;
      if (value != 0)
	/* More bytes to follow.  */
	byte |= 0x80;

      *p++ = byte;
    }
  while (value != 0);

  return p - orig;
}

int
output_leb128 (char *p, valueT value, int sign)
{
  if (sign)
    return output_sleb128 (p, (offsetT) value);
  else
    return output_uleb128 (p, value);
}

/* Do the same for bignums.  We combine sizeof with output here in that
   we don't output for NULL values of P.  It isn't really as critical as
   for "normal" values that this be streamlined.  */

static inline int
output_big_sleb128 (char *p, LITTLENUM_TYPE *bignum, int size)
{
  char *orig = p;
  valueT val = 0;
  int loaded = 0;
  unsigned byte;

  /* Strip leading sign extensions off the bignum.  */
  while (size > 0 && bignum[size - 1] == (LITTLENUM_TYPE) -1)
    size--;

  do
    {
      if (loaded < 7 && size > 0)
	{
	  val |= (*bignum << loaded);
	  loaded += 8 * CHARS_PER_LITTLENUM;
	  size--;
	  bignum++;
	}

      byte = val & 0x7f;
      loaded -= 7;
      val >>= 7;

      if (size == 0)
	{
	  if ((val == 0 && (byte & 0x40) == 0)
	      || (~(val | ~(((valueT) 1 << loaded) - 1)) == 0
		  && (byte & 0x40) != 0))
	    byte |= 0x80;
	}

      if (orig)
	*p = byte;
      p++;
    }
  while (byte & 0x80);

  return p - orig;
}

static inline int
output_big_uleb128 (char *p, LITTLENUM_TYPE *bignum, int size)
{
  char *orig = p;
  valueT val = 0;
  int loaded = 0;
  unsigned byte;

  /* Strip leading zeros off the bignum.  */
  /* XXX: Is this needed?  */
  while (size > 0 && bignum[size - 1] == 0)
    size--;

  do
    {
      if (loaded < 7 && size > 0)
	{
	  val |= (*bignum << loaded);
	  loaded += 8 * CHARS_PER_LITTLENUM;
	  size--;
	  bignum++;
	}

      byte = val & 0x7f;
      loaded -= 7;
      val >>= 7;

      if (size > 0 || val)
	byte |= 0x80;

      if (orig)
	*p = byte;
      p++;
    }
  while (byte & 0x80);

  return p - orig;
}

static int
output_big_leb128 (char *p, LITTLENUM_TYPE *bignum, int size, int sign)
{
  if (sign)
    return output_big_sleb128 (p, bignum, size);
  else
    return output_big_uleb128 (p, bignum, size);
}

/* Generate the appropriate fragments for a given expression to emit a
   leb128 value.  */

void
emit_leb128_expr (expressionS *exp, int sign)
{
  operatorT op = exp->X_op;
  int nbytes;

  if (op == O_absent || op == O_illegal)
    {
      as_warn (_("zero assumed for missing expression"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_big && exp->X_add_number <= 0)
    {
      as_bad (_("floating point number invalid"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_register)
    {
      as_warn (_("register value used as expression"));
      op = O_constant;
    }

  /* Let check_eh_frame know that data is being emitted.  nbytes == -1 is
     a signal that this is leb128 data.  It shouldn't optimize this away.  */
  nbytes = -1;
  if (check_eh_frame (exp, &nbytes))
    abort ();

  /* Let the backend know that subsequent data may be byte aligned.  */
#ifdef md_cons_align
  md_cons_align (1);
#endif

  if (op == O_constant)
    {
      /* If we've got a constant, emit the thing directly right now.  */

      valueT value = exp->X_add_number;
      int size;
      char *p;

      size = sizeof_leb128 (value, sign);
      p = frag_more (size);
      output_leb128 (p, value, sign);
    }
  else if (op == O_big)
    {
      /* O_big is a different sort of constant.  */

      int size;
      char *p;

      size = output_big_leb128 (NULL, generic_bignum, exp->X_add_number, sign);
      p = frag_more (size);
      output_big_leb128 (p, generic_bignum, exp->X_add_number, sign);
    }
  else
    {
      /* Otherwise, we have to create a variable sized fragment and
	 resolve things later.  */

      frag_var (rs_leb128, sizeof_uleb128 (~(valueT) 0), 0, sign,
		make_expr_symbol (exp), 0, (char *) NULL);
    }
}

/* Parse the .sleb128 and .uleb128 pseudos.  */

void
s_leb128 (int sign)
{
  expressionS exp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  do
    {
      expression (&exp);
      emit_leb128_expr (&exp, sign);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;
  demand_empty_rest_of_line ();
}

/* We read 0 or more ',' separated, double-quoted strings.
   Caller should have checked need_pass_2 is FALSE because we don't
   check it.  */

void
stringer (/* Worker to do .ascii etc statements.  */
	  /* Checks end-of-line.  */
	  register int append_zero	/* 0: don't append '\0', else 1.  */)
{
  register unsigned int c;
  char *start;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  /* The following awkward logic is to parse ZERO or more strings,
     comma separated. Recall a string expression includes spaces
     before the opening '\"' and spaces after the closing '\"'.
     We fake a leading ',' if there is (supposed to be)
     a 1st, expression. We keep demanding expressions for each ','.  */
  if (is_it_end_of_statement ())
    {
      c = 0;			/* Skip loop.  */
      ++input_line_pointer;	/* Compensate for end of loop.  */
    }
  else
    {
      c = ',';			/* Do loop.  */
    }
  /* If we have been switched into the abs_section then we
     will not have an obstack onto which we can hang strings.  */
  if (now_seg == absolute_section)
    {
      as_bad (_("strings must be placed into a section"));
      c = 0;
      ignore_rest_of_line ();
    }

  while (c == ',' || c == '<' || c == '"')
    {
      SKIP_WHITESPACE ();
      switch (*input_line_pointer)
	{
	case '\"':
	  ++input_line_pointer;	/*->1st char of string.  */
	  start = input_line_pointer;
	  while (is_a_char (c = next_char_of_string ()))
	    {
	      FRAG_APPEND_1_CHAR (c);
	    }
	  if (append_zero)
	    {
	      FRAG_APPEND_1_CHAR (0);
	    }
	  know (input_line_pointer[-1] == '\"');

#ifndef NO_LISTING
#ifdef OBJ_ELF
	  /* In ELF, when gcc is emitting DWARF 1 debugging output, it
	     will emit .string with a filename in the .debug section
	     after a sequence of constants.  See the comment in
	     emit_expr for the sequence.  emit_expr will set
	     dwarf_file_string to non-zero if this string might be a
	     source file name.  */
	  if (strcmp (segment_name (now_seg), ".debug") != 0)
	    dwarf_file_string = 0;
	  else if (dwarf_file_string)
	    {
	      c = input_line_pointer[-1];
	      input_line_pointer[-1] = '\0';
	      listing_source_file (start);
	      input_line_pointer[-1] = c;
	    }
#endif
#endif

	  break;
	case '<':
	  input_line_pointer++;
	  c = get_single_number ();
	  FRAG_APPEND_1_CHAR (c);
	  if (*input_line_pointer != '>')
	    {
	      as_bad (_("expected <nn>"));
	    }
	  input_line_pointer++;
	  break;
	case ',':
	  input_line_pointer++;
	  break;
	}
      SKIP_WHITESPACE ();
      c = *input_line_pointer;
    }

  demand_empty_rest_of_line ();
}				/* stringer() */

/* FIXME-SOMEDAY: I had trouble here on characters with the
    high bits set.  We'll probably also have trouble with
    multibyte chars, wide chars, etc.  Also be careful about
    returning values bigger than 1 byte.  xoxorich.  */

unsigned int
next_char_of_string (void)
{
  register unsigned int c;

  c = *input_line_pointer++ & CHAR_MASK;
  switch (c)
    {
    case '\"':
      c = NOT_A_CHAR;
      break;

    case '\n':
      as_warn (_("unterminated string; newline inserted"));
      bump_line_counters ();
      break;

#ifndef NO_STRING_ESCAPES
    case '\\':
      switch (c = *input_line_pointer++)
	{
	case 'b':
	  c = '\b';
	  break;

	case 'f':
	  c = '\f';
	  break;

	case 'n':
	  c = '\n';
	  break;

	case 'r':
	  c = '\r';
	  break;

	case 't':
	  c = '\t';
	  break;

	case 'v':
	  c = '\013';
	  break;

	case '\\':
	case '"':
	  break;		/* As itself.  */

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  {
	    long number;
	    int i;

	    for (i = 0, number = 0;
		 i < 3 && ISDIGIT (c);
		 c = *input_line_pointer++, i++)
	      {
		number = number * 8 + c - '0';
	      }

	    c = number & 0xff;
	  }
	  --input_line_pointer;
	  break;

	case 'x':
	case 'X':
	  {
	    long number;

	    number = 0;
	    c = *input_line_pointer++;
	    while (ISXDIGIT (c))
	      {
		if (ISDIGIT (c))
		  number = number * 16 + c - '0';
		else if (ISUPPER (c))
		  number = number * 16 + c - 'A' + 10;
		else
		  number = number * 16 + c - 'a' + 10;
		c = *input_line_pointer++;
	      }
	    c = number & 0xff;
	    --input_line_pointer;
	  }
	  break;

	case '\n':
	  /* To be compatible with BSD 4.2 as: give the luser a linefeed!!  */
	  as_warn (_("unterminated string; newline inserted"));
	  c = '\n';
	  bump_line_counters ();
	  break;

	default:

#ifdef ONLY_STANDARD_ESCAPES
	  as_bad (_("bad escaped character in string"));
	  c = '?';
#endif /* ONLY_STANDARD_ESCAPES */

	  break;
	}
      break;
#endif /* ! defined (NO_STRING_ESCAPES) */

    default:
      break;
    }
  return (c);
}

static segT
get_segmented_expression (register expressionS *expP)
{
  register segT retval;

  retval = expression (expP);
  if (expP->X_op == O_illegal
      || expP->X_op == O_absent
      || expP->X_op == O_big)
    {
      as_bad (_("expected address expression"));
      expP->X_op = O_constant;
      expP->X_add_number = 0;
      retval = absolute_section;
    }
  return retval;
}

static segT
get_known_segmented_expression (register expressionS *expP)
{
  register segT retval;

  if ((retval = get_segmented_expression (expP)) == undefined_section)
    {
      /* There is no easy way to extract the undefined symbol from the
	 expression.  */
      if (expP->X_add_symbol != NULL
	  && S_GET_SEGMENT (expP->X_add_symbol) != expr_section)
	as_warn (_("symbol \"%s\" undefined; zero assumed"),
		 S_GET_NAME (expP->X_add_symbol));
      else
	as_warn (_("some symbol undefined; zero assumed"));
      retval = absolute_section;
      expP->X_op = O_constant;
      expP->X_add_number = 0;
    }
  know (retval == absolute_section || SEG_NORMAL (retval));
  return (retval);
}

offsetT
get_absolute_expr (expressionS *exp)
{
  expression (exp);
  if (exp->X_op != O_constant)
    {
      if (exp->X_op != O_absent)
	as_bad (_("bad or irreducible absolute expression"));
      exp->X_add_number = 0;
    }
  return exp->X_add_number;
}

offsetT
get_absolute_expression (void)
{
  expressionS exp;

  return get_absolute_expr (&exp);
}

char				/* Return terminator.  */
get_absolute_expression_and_terminator (long *val_pointer /* Return value of expression.  */)
{
  /* FIXME: val_pointer should probably be offsetT *.  */
  *val_pointer = (long) get_absolute_expression ();
  return (*input_line_pointer++);
}

/* Like demand_copy_string, but return NULL if the string contains any '\0's.
   Give a warning if that happens.  */

char *
demand_copy_C_string (int *len_pointer)
{
  register char *s;

  if ((s = demand_copy_string (len_pointer)) != 0)
    {
      register int len;

      for (len = *len_pointer; len > 0; len--)
	{
	  if (*s == 0)
	    {
	      s = 0;
	      len = 1;
	      *len_pointer = 0;
	      as_bad (_("this string may not contain \'\\0\'"));
	    }
	}
    }

  return s;
}

/* Demand string, but return a safe (=private) copy of the string.
   Return NULL if we can't read a string here.  */

char *
demand_copy_string (int *lenP)
{
  register unsigned int c;
  register int len;
  char *retval;

  len = 0;
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '\"')
    {
      input_line_pointer++;	/* Skip opening quote.  */

      while (is_a_char (c = next_char_of_string ()))
	{
	  obstack_1grow (&notes, c);
	  len++;
	}
      /* JF this next line is so demand_copy_C_string will return a
	 null terminated string.  */
      obstack_1grow (&notes, '\0');
      retval = obstack_finish (&notes);
    }
  else
    {
      as_bad (_("missing string"));
      retval = NULL;
      ignore_rest_of_line ();
    }
  *lenP = len;
  return (retval);
}

/* In:	Input_line_pointer->next character.

   Do:	Skip input_line_pointer over all whitespace.

   Out:	1 if input_line_pointer->end-of-line.  */

int
is_it_end_of_statement (void)
{
  SKIP_WHITESPACE ();
  return (is_end_of_line[(unsigned char) *input_line_pointer]);
}

void
equals (char *sym_name, int reassign)
{
  register symbolS *symbolP;	/* Symbol we are working with.  */
  char *stop = NULL;
  char stopc;

  input_line_pointer++;
  if (*input_line_pointer == '=')
    input_line_pointer++;

  while (*input_line_pointer == ' ' || *input_line_pointer == '\t')
    input_line_pointer++;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  if (sym_name[0] == '.' && sym_name[1] == '\0')
    {
      /* Turn '. = mumble' into a .org mumble.  */
      register segT segment;
      expressionS exp;

      segment = get_known_segmented_expression (&exp);
      if (!need_pass_2)
	do_org (segment, &exp, 0);
    }
  else
    {
#ifdef OBJ_COFF
      int local;

      symbolP = symbol_find (sym_name);
      local = symbolP == NULL;
      if (local)
#endif /* OBJ_COFF */
      symbolP = symbol_find_or_make (sym_name);
      /* Permit register names to be redefined.  */
      if (!reassign
	  && S_IS_DEFINED (symbolP)
	  && S_GET_SEGMENT (symbolP) != reg_section)
	as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));

#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      if (local)
	SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF */

      pseudo_set (symbolP);
    }

  if (flag_mri)
    {
      /* Check garbage after the expression.  */
      demand_empty_rest_of_line ();
      mri_comment_end (stop, stopc);
    }
}

/* .incbin -- include a file verbatim at the current location.  */

void
s_incbin (int x ATTRIBUTE_UNUSED)
{
  FILE * binfile;
  char * path;
  char * filename;
  char * binfrag;
  long   skip = 0;
  long   count = 0;
  long   bytes;
  int    len;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  SKIP_WHITESPACE ();
  filename = demand_copy_string (& len);
  if (filename == NULL)
    return;

  SKIP_WHITESPACE ();

  /* Look for optional skip and count.  */
  if (* input_line_pointer == ',')
    {
      ++ input_line_pointer;
      skip = get_absolute_expression ();

      SKIP_WHITESPACE ();

      if (* input_line_pointer == ',')
	{
	  ++ input_line_pointer;

	  count = get_absolute_expression ();
	  if (count == 0)
	    as_warn (_(".incbin count zero, ignoring `%s'"), filename);

	  SKIP_WHITESPACE ();
	}
    }

  demand_empty_rest_of_line ();

  /* Try opening absolute path first, then try include dirs.  */
  binfile = fopen (filename, FOPEN_RB);
  if (binfile == NULL)
    {
      int i;

      path = xmalloc ((unsigned long) len + include_dir_maxlen + 5);

      for (i = 0; i < include_dir_count; i++)
	{
	  sprintf (path, "%s/%s", include_dirs[i], filename);

	  binfile = fopen (path, FOPEN_RB);
	  if (binfile != NULL)
	    break;
	}

      if (binfile == NULL)
	as_bad (_("file not found: %s"), filename);
    }
  else
    path = xstrdup (filename);

  if (binfile)
    {
      long   file_len;

      register_dependency (path);

      /* Compute the length of the file.  */
      if (fseek (binfile, 0, SEEK_END) != 0)
	{
	  as_bad (_("seek to end of .incbin file failed `%s'"), path);
	  goto done;
	}
      file_len = ftell (binfile);

      /* If a count was not specified use the size of the file.  */
      if (count == 0)
	count = file_len;

      if (skip + count > file_len)
	{
	  as_bad (_("skip (%ld) + count (%ld) larger than file size (%ld)"),
		  skip, count, file_len);
	  goto done;
	}

      if (fseek (binfile, skip, SEEK_SET) != 0)
	{
	  as_bad (_("could not skip to %ld in file `%s'"), skip, path);
	  goto done;
	}

      /* Allocate frag space and store file contents in it.  */
      binfrag = frag_more (count);

      bytes = fread (binfrag, 1, count, binfile);
      if (bytes < count)
	as_warn (_("truncated file `%s', %ld of %ld bytes read"),
		 path, bytes, count);
    }
done:
  if (binfile != NULL)
    fclose (binfile);
  if (path)
    free (path);
}

/* .include -- include a file at this point.  */

void
s_include (int arg ATTRIBUTE_UNUSED)
{
  char *filename;
  int i;
  FILE *try;
  char *path;

  if (!flag_m68k_mri)
    {
      filename = demand_copy_string (&i);
      if (filename == NULL)
	{
	  /* demand_copy_string has already printed an error and
	     called ignore_rest_of_line.  */
	  return;
	}
    }
  else
    {
      SKIP_WHITESPACE ();
      i = 0;
      while (!is_end_of_line[(unsigned char) *input_line_pointer]
	     && *input_line_pointer != ' '
	     && *input_line_pointer != '\t')
	{
	  obstack_1grow (&notes, *input_line_pointer);
	  ++input_line_pointer;
	  ++i;
	}

      obstack_1grow (&notes, '\0');
      filename = obstack_finish (&notes);
      while (!is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
  path = xmalloc ((unsigned long) i + include_dir_maxlen + 5 /* slop */ );

  for (i = 0; i < include_dir_count; i++)
    {
      strcpy (path, include_dirs[i]);
      strcat (path, "/");
      strcat (path, filename);
      if (0 != (try = fopen (path, FOPEN_RT)))
	{
	  fclose (try);
	  goto gotit;
	}
    }

  free (path);
  path = filename;
gotit:
  /* malloc Storage leak when file is found on path.  FIXME-SOMEDAY.  */
  register_dependency (path);
  input_scrub_insert_file (path);
}

void
add_include_dir (char *path)
{
  int i;

  if (include_dir_count == 0)
    {
      include_dirs = (char **) xmalloc (2 * sizeof (*include_dirs));
      include_dirs[0] = ".";	/* Current dir.  */
      include_dir_count = 2;
    }
  else
    {
      include_dir_count++;
      include_dirs =
	(char **) realloc (include_dirs,
			   include_dir_count * sizeof (*include_dirs));
    }

  include_dirs[include_dir_count - 1] = path;	/* New one.  */

  i = strlen (path);
  if (i > include_dir_maxlen)
    include_dir_maxlen = i;
}

/* Output debugging information to denote the source file.  */

static void
generate_file_debug (void)
{
  if (debug_type == DEBUG_STABS)
    stabs_generate_asm_file ();
}

/* Output line number debugging information for the current source line.  */

void
generate_lineno_debug (void)
{
  switch (debug_type)
    {
    case DEBUG_UNSPECIFIED:
    case DEBUG_NONE:
    case DEBUG_DWARF:
      break;
    case DEBUG_STABS:
      stabs_generate_asm_lineno ();
      break;
    case DEBUG_ECOFF:
      ecoff_generate_asm_lineno ();
      break;
    case DEBUG_DWARF2:
      /* ??? We could here indicate to dwarf2dbg.c that something
	 has changed.  However, since there is additional backend
	 support that is required (calling dwarf2_emit_insn), we
	 let dwarf2dbg.c call as_where on its own.  */
      break;
    }
}

/* Output debugging information to mark a function entry point or end point.
   END_P is zero for .func, and non-zero for .endfunc.  */

void
s_func (int end_p)
{
  do_s_func (end_p, NULL);
}

/* Subroutine of s_func so targets can choose a different default prefix.
   If DEFAULT_PREFIX is NULL, use the target's "leading char".  */

void
do_s_func (int end_p, const char *default_prefix)
{
  /* Record the current function so that we can issue an error message for
     misplaced .func,.endfunc, and also so that .endfunc needs no
     arguments.  */
  static char *current_name;
  static char *current_label;

  if (end_p)
    {
      if (current_name == NULL)
	{
	  as_bad (_("missing .func"));
	  ignore_rest_of_line ();
	  return;
	}

      if (debug_type == DEBUG_STABS)
	stabs_generate_asm_endfunc (current_name, current_label);

      current_name = current_label = NULL;
    }
  else /* ! end_p */
    {
      char *name, *label;
      char delim1, delim2;

      if (current_name != NULL)
	{
	  as_bad (_(".endfunc missing for previous .func"));
	  ignore_rest_of_line ();
	  return;
	}

      name = input_line_pointer;
      delim1 = get_symbol_end ();
      name = xstrdup (name);
      *input_line_pointer = delim1;
      SKIP_WHITESPACE ();
      if (*input_line_pointer != ',')
	{
	  if (default_prefix)
	    asprintf (&label, "%s%s", default_prefix, name);
	  else
	    {
	      char leading_char = 0;
#ifdef BFD_ASSEMBLER
	      leading_char = bfd_get_symbol_leading_char (stdoutput);
#endif
	      /* Missing entry point, use function's name with the leading
		 char prepended.  */
	      if (leading_char)
		asprintf (&label, "%c%s", leading_char, name);
	      else
		label = name;
	    }
	}
      else
	{
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  label = input_line_pointer;
	  delim2 = get_symbol_end ();
	  label = xstrdup (label);
	  *input_line_pointer = delim2;
	}

      if (debug_type == DEBUG_STABS)
	stabs_generate_asm_func (name, label);

      current_name = name;
      current_label = label;
    }

  demand_empty_rest_of_line ();
}

void
s_ignore (int arg ATTRIBUTE_UNUSED)
{
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      ++input_line_pointer;
    }
  ++input_line_pointer;
}

void
read_print_statistics (FILE *file)
{
  hash_print_statistics (file, "pseudo-op table", po_hash);
}

/* Inserts the given line into the input stream.

   This call avoids macro/conditionals nesting checking, since the contents of
   the line are assumed to replace the contents of a line already scanned.

   An appropriate use of this function would be substitution of input lines when
   called by md_start_line_hook().  The given line is assumed to already be
   properly scrubbed.  */

void
input_scrub_insert_line (const char *line)
{
  sb newline;
  sb_new (&newline);
  sb_add_string (&newline, line);
  input_scrub_include_sb (&newline, input_line_pointer, 0);
  sb_kill (&newline);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Insert a file into the input stream; the path must resolve to an actual
   file; no include path searching or dependency registering is performed.  */

void
input_scrub_insert_file (char *path)
{
  input_scrub_include_file (path, input_line_pointer);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}
@


1.9
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@a3551 2
      know (nbytes % CHARS_PER_LITTLENUM == 0);

d3555 13
a3567 1
	  as_warn (_("bignum truncated to %d bytes"), nbytes);
d3570 7
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d35 1
a35 1
/* Routines that read assembler source text to build spagetti in memory.
d46 1
d54 1
a54 1
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)        	\
d56 9
a64 9
    {                                                   	\
      if ((SIZE) >= 8)                                      	\
	(P2VAR) = 3;                                        	\
      else if ((SIZE) >= 4)                                 	\
	(P2VAR) = 2;                                        	\
      else if ((SIZE) >= 2)                                 	\
	(P2VAR) = 1;                                        	\
      else                                                  	\
	(P2VAR) = 0;                                        	\
d158 1
a158 1
#ifdef  IGNORE_OPCODE_CASE
d217 7
a223 20
static void cons_worker PARAMS ((int, int));
static int scrub_from_string PARAMS ((char *, int));
static void do_align PARAMS ((int, char *, int, int));
static void s_align PARAMS ((int, int));
static void s_lcomm_internal PARAMS ((int, int));
static int hex_float PARAMS ((int, char *));
static inline int sizeof_sleb128 PARAMS ((offsetT));
static inline int sizeof_uleb128 PARAMS ((valueT));
static inline int output_sleb128 PARAMS ((char *, offsetT));
static inline int output_uleb128 PARAMS ((char *, valueT));
static inline int output_big_sleb128 PARAMS ((char *, LITTLENUM_TYPE *, int));
static inline int output_big_uleb128 PARAMS ((char *, LITTLENUM_TYPE *, int));
static int output_big_leb128 PARAMS ((char *, LITTLENUM_TYPE *, int, int));
static void do_org PARAMS ((segT, expressionS *, int));
char *demand_copy_string PARAMS ((int *lenP));
static segT get_segmented_expression PARAMS ((expressionS *expP));
static segT get_known_segmented_expression PARAMS ((expressionS * expP));
static void pobegin PARAMS ((void));
static int get_line_sb PARAMS ((sb *));
static void generate_file_debug PARAMS ((void));
d226 1
a226 1
read_begin ()
d420 1
a420 2
pop_insert (table)
     const pseudo_typeS *table;
d441 4
d446 1
a446 1
pobegin ()
d462 6
d486 1
a486 3
scrub_from_string (buf, buflen)
     char *buf;
     int buflen;
d501 1
a501 2
read_a_source_file (name)
     char *name;
d587 2
a588 2
                         pseudo-op specially: we don't want to put the
                         symbol in the symbol table.  */
d609 1
a609 1
	  /* We are at the begining of a line, or similar place.
d671 4
a674 4
	         That character's place in the input line is now '\0'.
	         S points to the beginning of the symbol.
	           [In case of pseudo-op, s->'.'.]
	         Input_line_pointer->'\0' where c was.  */
d701 3
d723 1
a723 1
#ifdef IGNORE_OPCODE_CASE
d740 1
a740 1
                         without a period.  */
d751 3
a753 3
		         WARNING: c has next char, which may be end-of-line.
		         We lookup the pseudo-op table with s+1 because we
		         already know that the pseudo-op begins with a '.'.  */
d757 2
d761 2
a762 2
                         automatic alignment directive.  What a hack
                         this is.  */
d809 2
a810 2
		         Input_line_pointer->1st non-blank char
		         after pseudo-operation.  */
d970 1
a970 1
		     guarentee it...  */
d1056 1
a1056 1
	  ignore_rest_of_line ();
d1089 1
a1089 2
mri_comment_field (stopcp)
     char *stopcp;
d1120 1
a1120 3
mri_comment_end (stop, stopc)
     char *stop;
     int stopc;
d1131 1
a1131 2
s_abort (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1143 1
a1143 5
do_align (n, fill, len, max)
     int n;
     char *fill;
     int len;
     int max;
d1191 1
a1191 3
s_align (arg, bytes_p)
     int arg;
     int bytes_p;
d1306 1
a1306 2
s_align_bytes (arg)
     int arg;
d1315 1
a1315 2
s_align_ptwo (arg)
     int arg;
d1320 3
a1322 3
void
s_comm (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1324 5
a1328 5
  register char *name;
  register char c;
  register char *p;
  offsetT temp;
  register symbolS *symbolP;
d1331 1
d1346 1
a1346 1
      return;
d1351 12
a1362 1
  if (*input_line_pointer != ',')
d1364 1
a1364 2
      *p = 0;
      as_bad (_("expected comma after \"%s\""), name);
d1367 1
a1367 3
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
d1369 1
a1369 4

  input_line_pointer++;		/* skip ',' */

  if ((temp = get_absolute_expression ()) < 0)
d1371 2
a1372 1
      as_warn (_(".COMMon length (%ld) < 0 ignored"), (long) temp);
d1374 1
a1374 3
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
a1376 1
  *p = 0;
a1377 2
  *p = c;

d1380 3
a1382 2
      as_bad (_("symbol `%s' is already defined"),
	      S_GET_NAME (symbolP));
d1384 1
a1384 3
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
d1387 10
a1396 8
  if (S_GET_VALUE (symbolP))
    {
      if (S_GET_VALUE (symbolP) != (valueT) temp)
	as_bad (_("length of .comm \"%s\" is already %ld; not changing to %ld"),
		S_GET_NAME (symbolP),
		(long) S_GET_VALUE (symbolP),
		(long) temp);
    }
d1399 1
a1399 1
      S_SET_VALUE (symbolP, (valueT) temp);
d1401 7
a1408 8
#ifdef OBJ_VMS
  {
    extern int flag_one;
    if (!temp || !flag_one)
      S_GET_OTHER(symbolP) = const_flag;
  }
#endif /* not OBJ_VMS */
  know (symbolP->sy_frag == &zero_address_frag);
d1410 1
d1412 1
a1412 1

d1415 8
a1422 1
}				/* s_comm() */
d1429 1
a1429 2
s_mri_common (small)
     int small ATTRIBUTE_UNUSED;
d1528 1
a1528 2
s_data (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1558 1
a1558 2
s_app_file_string (file)
     char *file;
d1571 1
a1571 2
s_app_file (appfile)
     int appfile;
d1586 1
a1586 1
         backquote.  */
d1604 1
a1604 2
s_app_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1630 1
a1630 2
s_end (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1635 1
a1635 1
         but we don't support that.  */
d1647 1
a1647 2
s_err (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1656 1
a1656 2
s_fail (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1678 1
a1678 2
s_fill (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1758 4
a1761 4
         flavoured AS.  The following bizarre behaviour is to be
         compatible with above.  I guess they tried to take up to 8
         bytes from a 4-byte expression and they forgot to sign
         extend.  */
d1768 2
a1769 2
         but emits no error message because it seems a legal thing to do.
         It is a degenerate case of .fill but could be emitted by a
d1776 1
a1776 2
s_globl (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1816 1
a1816 2
s_irp (irpc)
     int irpc;
d1849 1
a1849 2
s_linkonce (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1919 2
a1920 8
static void
s_lcomm_internal (needs_align, bytes_p)
     /* 1 if this was a ".bss" directive, which may require a 3rd argument
	(alignment); 0 if it was an ".lcomm" (2 args only).  */
     int needs_align;
     /* 1 if the alignment value should be interpreted as the byte boundary,
	rather than the power of 2.  */
     int bytes_p;
d1922 1
a1922 5
  register char *name;
  register char c;
  register char *p;
  register int temp;
  register symbolS *symbolP;
a1924 2
  const int max_alignment = 15;
  int align = 0;
a1926 35
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();

  /* Accept an optional comma after the name.  The comma used to be
     required, but Irix 5 cc does not generate it.  */
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
    }

  if (is_end_of_line[(unsigned char) *input_line_pointer])
    {
      as_bad (_("missing size expression"));
      return;
    }

  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_("BSS length (%d) < 0 ignored"), temp);
      ignore_rest_of_line ();
      return;
    }

d1932 1
a1932 1
      if ((unsigned) temp <= bfd_get_gp_size (stdoutput))
d1944 1
d1946 1
a1946 1
  if (!needs_align)
d1948 3
a1950 1
      TC_IMPLICIT_LCOMM_ALIGNMENT (temp, align);
d1952 3
a1954 4
      /* Still zero unless TC_IMPLICIT_LCOMM_ALIGNMENT set it.  */
      if (align)
	record_alignment (bss_seg, align);
    }
d1956 3
a1958 4
  if (needs_align)
    {
      align = 0;
      SKIP_WHITESPACE ();
d1960 4
a1963 6
      if (*input_line_pointer != ',')
	{
	  as_bad (_("expected comma after size"));
	  ignore_rest_of_line ();
	  return;
	}
d1965 7
a1971 2
      input_line_pointer++;
      SKIP_WHITESPACE ();
d1973 2
a1974 5
      if (is_end_of_line[(unsigned char) *input_line_pointer])
	{
	  as_bad (_("missing alignment"));
	  return;
	}
d1976 5
a1980 1
      align = get_absolute_expression ();
d1982 8
a1989 6
      if (bytes_p)
	{
	  /* Convert to a power of 2.  */
	  if (align != 0)
	    {
	      unsigned int i;
d1991 2
a1992 7
	      for (i = 0; (align & 1) == 0; align >>= 1, ++i)
		;
	      if (align != 1)
		as_bad (_("alignment not a power of 2"));
	      align = i;
	    }
	}
d1994 3
a1996 10
      if (align > max_alignment)
	{
	  align = max_alignment;
	  as_warn (_("alignment too large; %d assumed"), align);
	}
      else if (align < 0)
	{
	  align = 0;
	  as_warn (_("alignment negative; 0 assumed"));
	}
d1998 4
a2001 1
      record_alignment (bss_seg, align);
d2003 2
a2004 1
  else
d2006 5
a2010 3
      /* Assume some objects may require alignment on some systems.  */
#if defined (TC_ALPHA) && ! defined (VMS)
      if (temp > 1)
d2012 3
a2014 3
	  align = ffs (temp) - 1;
	  if (temp % (1 << align))
	    abort ();
d2016 1
a2016 1
#endif
d2018 8
d2027 4
a2030 3
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
d2032 1
a2032 12
  if (
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT) \
     || defined (OBJ_BOUT) || defined (OBJ_MAYBE_BOUT))
#ifdef BFD_ASSEMBLER
      (OUTPUT_FLAVOR != bfd_target_aout_flavour
       || (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0)) &&
#else
      (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0) &&
#endif
#endif
      (S_GET_SEGMENT (symbolP) == bss_seg
       || (!S_IS_DEFINED (symbolP) && S_GET_VALUE (symbolP) == 0)))
d2034 3
a2036 31
      char *pfrag;

      subseg_set (bss_seg, 1);

      if (align)
	frag_align (align, 0, 0);

      /* Detach from old frag.  */
      if (S_GET_SEGMENT (symbolP) == bss_seg)
	symbol_get_frag (symbolP)->fr_symbol = NULL;

      symbol_set_frag (symbolP, frag_now);
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			(offsetT) temp, (char *) 0);
      *pfrag = 0;

      S_SET_SEGMENT (symbolP, bss_seg);

#ifdef OBJ_COFF
      /* The symbol may already have been created with a preceding
         ".globl" directive -- be careful not to step on storage class
         in that case.  Otherwise, set it to static.  */
      if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
	{
	  S_SET_STORAGE_CLASS (symbolP, C_STAT);
	}
#endif /* OBJ_COFF */

#ifdef S_SET_SIZE
      S_SET_SIZE (symbolP, temp);
#endif
d2039 2
a2040 3
    as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));

  subseg_set (current_seg, current_subseg);
d2042 2
a2043 1
  demand_empty_rest_of_line ();
d2047 1
a2047 2
s_lcomm (needs_align)
     int needs_align;
d2049 1
a2049 1
  s_lcomm_internal (needs_align, 0);
d2053 1
a2053 2
s_lcomm_bytes (needs_align)
     int needs_align;
d2055 1
a2055 1
  s_lcomm_internal (needs_align, 1);
d2059 1
a2059 2
s_lsym (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2136 1
a2136 2
get_line_sb (line)
     sb *line;
d2195 1
a2195 2
s_macro (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2242 1
a2242 2
s_mexit (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2251 1
a2251 2
s_mri (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2289 1
a2289 4
do_org (segment, exp, fill)
     segT segment;
     expressionS *exp;
     int fill;
d2324 1
a2324 2
s_org (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2379 1
a2379 2
s_mri_sect (type)
     char *type ATTRIBUTE_UNUSED;
d2543 1
a2543 2
s_print (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2549 2
a2550 1
  printf ("%s\n", s);
d2557 1
a2557 2
s_purgem (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2586 1
a2586 2
s_bad_endr (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2595 1
a2595 2
s_rept (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2608 1
a2608 4
do_repeat (count, start, end)
     int count;
     const char *start;
     const char *end;
d2640 1
a2640 2
end_repeat (extra)
     int extra;
d2652 1
a2652 2
s_set (equiv)
     int equiv;
d2709 1
a2709 1
         for this symbol.  */
d2744 1
a2744 2
s_space (mult)
     int mult;
d2916 1
a2916 2
s_float_space (float_type)
     int float_type;
d2996 1
a2996 2
s_struct (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3011 1
a3011 2
s_text (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3023 4
d3028 1
a3028 1
demand_empty_rest_of_line ()
a3033 10
    ignore_rest_of_line ();

  /* Return having already swallowed end-of-line.  */
}

void
ignore_rest_of_line ()
{
  /* For suspect lines: gives warning.  */
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
d3036 1
a3036 1
	as_warn (_("rest of line ignored; first ignored character is `%c'"),
d3039 1
a3039 1
	as_warn (_("rest of line ignored; first ignored character valued 0x%x"),
d3041 9
d3051 6
a3056 4
      while (input_line_pointer < buffer_limit
	     && !is_end_of_line[(unsigned char) *input_line_pointer])
	input_line_pointer++;
    }
d3065 1
a3065 1
discard_rest_of_line ()
d3078 1
a3078 1
  	Input_line_pointer->expression.
d3081 2
a3082 2
  	Tried to set symbol to value of expression.
  	Will change symbols type, value, and frag;  */
d3085 1
a3085 2
pseudo_set (symbolP)
     symbolS *symbolP;
d3178 1
a3178 1
/*  			cons()
d3203 1
a3203 1
parse_mri_cons PARAMS ((expressionS *exp, unsigned int nbytes));
d3210 1
a3210 1
parse_bitfield_cons PARAMS ((expressionS *exp, unsigned int nbytes));
d3215 1
a3215 1
parse_repeat_cons PARAMS ((expressionS *exp, unsigned int nbytes));
d3224 8
d3236 2
a3237 3
cons_worker (nbytes, rva)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long.  */
     int rva;
d3300 1
a3300 2
cons (size)
     int size;
d3306 1
a3306 2
s_rva (size)
     int size;
d3315 1
a3315 3
emit_expr (exp, nbytes)
     expressionS *exp;
     unsigned int nbytes;
d3325 2
d3671 1
a3671 1
   The rules are: pack least significat bit first, if a field doesn't
d3905 1
a3905 3
hex_float (float_type, bytes)
     int float_type;
     char *bytes;
d3989 1
a3989 1
/*  			float_cons()
d4000 1
a4000 1
   truncatation, restored noisy bits instead of trailing 0s AND gave you
d4007 2
a4008 3
float_cons (float_type)
     /* Clobbers input_line-pointer, checks end-of-line.  */
     register int float_type;	/* 'f':.ffloat ... 'F':.float ...  */
d4031 3
a4033 3
         letter is legal. Someone may invent a "z" format and this routine
         has no use for such information. Lusers beware: you get
         diagnostics if your input is ill-conditioned.  */
d4039 1
a4039 1
         point with the exact digits specified.  */
d4103 1
a4103 2
sizeof_sleb128 (value)
     offsetT value;
d4124 1
a4124 2
sizeof_uleb128 (value)
     valueT value;
d4141 1
a4141 3
sizeof_leb128 (value, sign)
     valueT value;
     int sign;
d4152 1
a4152 3
output_sleb128 (p, value)
     char *p;
     offsetT value;
d4179 1
a4179 3
output_uleb128 (p, value)
     char *p;
     valueT value;
d4199 1
a4199 4
output_leb128 (p, value, sign)
     char *p;
     valueT value;
     int sign;
d4212 1
a4212 4
output_big_sleb128 (p, bignum, size)
     char *p;
     LITTLENUM_TYPE *bignum;
     int size;
d4255 1
a4255 4
output_big_uleb128 (p, bignum, size)
     char *p;
     LITTLENUM_TYPE *bignum;
     int size;
d4294 1
a4294 4
output_big_leb128 (p, bignum, size, sign)
     char *p;
     LITTLENUM_TYPE *bignum;
     int size, sign;
d4306 1
a4306 3
emit_leb128_expr (exp, sign)
     expressionS *exp;
     int sign;
d4376 1
a4376 2
s_leb128 (sign)
     int sign;
d4380 8
d4404 3
a4406 3
stringer (append_zero)		/* Worker to do .ascii etc statements.  */
     /* Checks end-of-line.  */
     register int append_zero;	/* 0: don't append '\0', else 1.  */
d4437 1
a4437 1
  
d4459 5
a4463 5
             will emit .string with a filename in the .debug section
             after a sequence of constants.  See the comment in
             emit_expr for the sequence.  emit_expr will set
             dwarf_file_string to non-zero if this string might be a
             source file name.  */
d4504 1
a4504 1
next_char_of_string ()
d4626 1
a4626 2
get_segmented_expression (expP)
     register expressionS *expP;
d4644 1
a4644 2
get_known_segmented_expression (expP)
     register expressionS *expP;
d4667 1
a4667 2
get_absolute_expr (exp)
     expressionS *exp;
d4680 1
a4680 1
get_absolute_expression ()
d4688 1
a4688 2
get_absolute_expression_and_terminator (val_pointer)
     long *val_pointer;		/* Return value of expression.  */
d4699 1
a4699 2
demand_copy_C_string (len_pointer)
     int *len_pointer;
d4726 1
a4726 2
demand_copy_string (lenP)
     int *lenP;
d4750 1
a4750 1
      as_warn (_("missing string"));
d4765 1
a4765 1
is_it_end_of_statement ()
d4772 1
a4772 3
equals (sym_name, reassign)
     char *sym_name;
     int reassign;
d4826 1
a4826 1
      ignore_rest_of_line ();
d4834 1
a4834 2
s_incbin (x)
     int x ATTRIBUTE_UNUSED;
d4950 1
a4950 2
s_include (arg)
     int arg ATTRIBUTE_UNUSED;
d4963 1
a4963 1
             called ignore_rest_of_line.  */
d5010 1
a5010 2
add_include_dir (path)
     char *path;
d5038 1
a5038 1
generate_file_debug ()
d5047 1
a5047 1
generate_lineno_debug ()
d5074 1
a5074 2
s_func (end_p)
     int end_p;
d5083 1
a5083 3
do_s_func (end_p, default_prefix)
     int end_p;
     const char *default_prefix;
d5161 1
a5161 2
s_ignore (arg)
     int arg ATTRIBUTE_UNUSED;
d5171 1
a5171 2
read_print_statistics (file)
     FILE *file;
d5181 1
a5181 1
   An appropriate use of this function would be substition of input lines when
d5186 1
a5186 2
input_scrub_insert_line (line)
     const char *line;
d5200 1
a5200 2
input_scrub_insert_file (path)
     char *path;
@


1.7
log
@Reverse the order of a test in the loop invariant.  It makes more
sense this way and works around an apparent gcc optimizer bug on
macppc related to inline functions.  OK drahn@@
@
text
@d3 1
a3 1
   1998, 1999, 2000 Free Software Foundation, Inc.
a37 3
/* For isdigit ().  */
#include <ctype.h>

d39 1
d48 1
a48 1
#define TC_START_LABEL(x,y) (x==':')
a170 4
static char *old_buffer;	/* JF a hack.  */
static char *old_input;
static char *old_limit;

d314 1
d347 1
d532 1
a532 3
    contin:			/* JF this goto is my fault I admit it.
				   Someone brave please re-write the whole
				   input section here?  Pleeze???  */
d735 1
a735 2
			if (isupper ((unsigned char) *s2))
			  *s2 = tolower (*s2);
d795 1
a795 1
			  as_bad (_("Unknown pseudo-op:  `%s'"), s);
d859 1
a859 1
			  if (check_macro (s, &out, '\0', &err, &macro))
d902 1
a902 2
	  if ((LOCAL_LABELS_DOLLAR || LOCAL_LABELS_FB)
	      && isdigit ((unsigned char) c))
d912 1
a912 1
	      while (isdigit ((unsigned char) *input_line_pointer))
d947 1
d960 1
d1022 1
a1022 1
		      new_tmp += size;
a1032 6
	      old_buffer = buffer;
	      old_input = input_line_pointer;
	      old_limit = buffer_limit;
	      buffer = new_buf;
	      input_line_pointer = new_buf;
	      buffer_limit = new_tmp;
d1034 12
d1055 2
a1056 2
	  /* as_warn (_("Junk character %d."),c); Now done by ignore_rest.  */
	  input_line_pointer--;	/* Report unknown char as ignored.  */
a1062 14

      if (old_buffer)
	{
	  free (buffer);
	  bump_line_counters ();
	  if (old_input != 0)
	    {
	      buffer = old_buffer;
	      input_line_pointer = old_input;
	      buffer_limit = old_limit;
	      old_buffer = 0;
	      goto contin;
	    }
	}
d1154 13
d1188 1
a1188 1
 just_record_alignment:
d1237 1
a1237 1
	    as_bad (_("Alignment not a power of 2"));
d1246 1
a1246 1
      as_bad (_("Alignment too large: %u assumed"), align);
d1353 8
d1365 3
a1367 1
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
d1378 1
a1378 1
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
d1391 1
a1391 1
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
d1402 1
a1402 1
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
d1454 1
a1454 1
  if (!isdigit ((unsigned char) *name))
d1462 1
a1462 1
      while (isdigit ((unsigned char) *input_line_pointer));
d1492 1
a1492 1
      as_bad (_("attempt to re-define symbol `%s'"), S_GET_NAME (sym));
d1563 14
d1601 1
a1601 10
	{
#ifdef LISTING
	  if (listing)
	    listing_source_file (s);
#endif
	  register_dependency (s);
#ifdef obj_app_file
	  obj_app_file (s);
#endif
	}
d1621 1
a1621 1
    as_warn (_("Line numbers must be positive; line number %d rejected."),
d1717 1
a1717 1
      as_warn (_(".fill size clamped to %d."), BSD_FILL_SIZE_CROCK_8);
d1722 1
a1722 1
      as_warn (_("Size negative: .fill ignored."));
d1728 1
a1728 1
	as_warn (_("Repeat < 0, .fill ignored"));
d1770 1
a1770 1
         flavoured AS.  The following bizzare behaviour is to be
d1773 1
a1773 1
         extend. Un*x Sux.  */
d1814 1
a1814 1
	  if (*input_line_pointer == '\n')
d1846 1
a1846 1
  err = expand_irp (irpc, 0, &s, &out, get_line_sb, '\0');
d1958 8
d1976 1
a1976 1
  if (*input_line_pointer == '\n')
d1978 1
a1978 1
      as_bad (_("Missing size expression"));
d1984 1
a1984 1
      as_warn (_("BSS length (%d.) <0! Ignored."), temp);
d1994 1
a1994 1
      if (temp <= bfd_get_gp_size (stdoutput))
d2023 1
a2023 1
	  as_bad (_("Expected comma after size"));
d2031 1
a2031 1
      if (*input_line_pointer == '\n')
d2033 1
a2033 1
	  as_bad (_("Missing alignment"));
d2049 1
a2049 1
		as_bad (_("Alignment not a power of 2"));
d2057 1
a2057 1
	  as_warn (_("Alignment too large: %d. assumed."), align);
d2062 1
a2062 1
	  as_warn (_("Alignment negative. 0 assumed."));
d2130 1
a2130 2
    as_bad (_("Ignoring attempt to re-define symbol `%s'."),
	    S_GET_NAME (symbolP));
d2166 8
d2179 1
a2179 1
      as_bad (_("Expected comma after name \"%s\""), name);
d2219 1
a2219 1
      as_bad (_("Symbol %s already defined"), name);
d2226 2
a2227 1
/* Read a line into an sb.  */
d2234 1
d2262 3
a2264 2
  while (!is_end_of_line[(unsigned char) *input_line_pointer]
	 || (inquote != '\0' && *input_line_pointer != '\n'))
d2266 1
a2266 1
      if (inquote == *input_line_pointer)
d2270 1
a2270 1
	  if (*input_line_pointer == quote1)
d2272 1
a2272 1
	  else if (*input_line_pointer == quote2)
d2276 1
a2276 1
      sb_add_char (line, *input_line_pointer++);
d2279 6
a2284 9
  while (input_line_pointer < buffer_limit
	 && is_end_of_line[(unsigned char) *input_line_pointer])
    {
      if (input_line_pointer[-1] == '\n')
	bump_line_counters ();
      ++input_line_pointer;
    }

  return 1;
d2287 1
a2287 2
/* Define a macro.  This is an interface to macro.c, which is shared
   between gas and gasp.  */
d2393 1
a2393 2
    as_bad (_("invalid segment \"%s\"; segment \"%s\" assumed"),
	    segment_name (segment), segment_name (now_seg));
d2493 1
a2493 1
  if (!isdigit ((unsigned char) *name))
d2501 1
a2501 1
      while (isdigit ((unsigned char) *input_line_pointer));
d2526 1
a2526 1
      c = toupper ((unsigned char) c);
d2690 10
d2777 8
d2790 1
a2790 1
      as_bad (_("Expected comma after name \"%s\""), name);
d2848 1
a2848 1
    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
d2934 1
a2934 1
	as_bad (_("Unsupported variable size or fill value"));
d3059 1
a3059 1
      && isalpha ((unsigned char) input_line_pointer[1]))
d3084 1
a3084 1
	  as_bad (_("Bad floating literal: %s"), err);
d3156 3
a3158 3
      if (isprint ((unsigned char) *input_line_pointer))
	as_bad (_("Rest of line ignored. First ignored character is `%c'."),
		*input_line_pointer);
d3160 2
a3161 2
	as_bad (_("Rest of line ignored. First ignored character valued 0x%x."),
		*input_line_pointer);
d3211 1
a3211 1
    as_bad (_("illegal expression; zero assumed"));
d3213 1
a3213 1
    as_bad (_("missing expression; zero assumed"));
d3217 1
a3217 1
	as_bad (_("bignum invalid; zero assumed"));
d3219 1
a3219 1
	as_bad (_("floating point number invalid; zero assumed"));
a3221 2
	   && (S_GET_SEGMENT (exp.X_add_symbol)
	       == S_GET_SEGMENT (exp.X_op_symbol))
d3262 1
a3262 1
	as_bad ("invalid attempt to set value of section symbol");
d3550 1
a3550 1
      as_bad (_("floating point number invalid; zero assumed"));
d3581 1
d3647 1
a3647 1
	  as_warn (_("Value 0x%lx truncated to 0x%lx."),
d3663 1
a3663 1
	  as_warn (_("Bignum truncated to %d bytes"), nbytes);
d3677 1
a3677 1
	  while (size > 0)
d3688 1
a3688 1
	  while (size > 0)
d3697 1
a3697 1
	  while (nbytes > 0)
d3994 1
a3994 1
      as_warn (_("Unresolvable or nonpositive repeat count; using 1"));
d4045 1
a4045 1
      as_bad (_("Unknown floating type type '%c'"), float_type);
d4067 1
a4067 1
	  as_warn (_("Floating point constant too large"));
d4144 1
a4144 1
	  && isalpha ((unsigned char) input_line_pointer[1]))
d4166 1
a4166 1
	      as_bad (_("Bad floating literal: %s"), err);
d4450 1
a4450 1
      as_bad (_("floating point number invalid; zero assumed"));
d4553 9
d4607 1
a4607 1
	      as_bad (_("Expected <nn>"));
d4640 1
a4640 1
      as_warn (_("Unterminated string: Newline inserted."));
d4691 1
a4691 1
		 i < 3 && isdigit (c);
d4709 1
a4709 1
	    while (isxdigit (c))
d4711 1
a4711 1
		if (isdigit (c))
d4713 1
a4713 1
		else if (isupper (c))
d4726 1
a4726 1
	  as_warn (_("Unterminated string: Newline inserted."));
d4734 1
a4734 1
	  as_bad (_("Bad escaped character in string, '?' assumed"));
d4760 1
a4760 1
      as_bad (_("expected address expression; zero assumed"));
d4793 14
d4811 1
a4811 8
  expression (&exp);
  if (exp.X_op != O_constant)
    {
      if (exp.X_op != O_absent)
	as_bad (_("bad or irreducible absolute expression; zero assumed"));
      exp.X_add_number = 0;
    }
  return exp.X_add_number;
d4843 1
a4843 1
	      as_bad (_("This string may not contain \'\\0\'"));
d4880 1
a4880 1
      as_warn (_("Missing string"));
d4944 1
a4944 1
	as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
d4963 117
d5128 1
a5128 1
      if (0 != (try = fopen (path, "r")))
@


1.6
log
@resolve conflicts.
@
text
@d4638 1
a4638 1
		 isdigit (c) && i < 3;
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 2
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
   2000 Free Software Foundation, Inc.
d20 1
a20 1
02111-1307, USA. */
d23 4
a26 5
#define MASK_CHAR (0xFF)	/* If your chars aren't 8 bits, you will
				   change this a bit.  But then, GNU isn't
				   spozed to run on your machine anyway.
				   (RMS is so shortsighted sometimes.)
				   */
d28 1
a28 1
#define MASK_CHAR ((int)(unsigned char)-1)
a30 1

d32 1
a32 2
   grow when we do 4361 style flonums. */

d38 1
a38 1
/* for isdigit() */
d55 13
a67 19
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)        \
 do {                                                   \
  if ((SIZE) >= 8)                                      \
    (P2VAR) = 3;                                        \
  else if ((SIZE) >= 4)                                 \
    (P2VAR) = 2;                                        \
  else if ((SIZE) >= 2)                                 \
    (P2VAR) = 1;                                        \
  else                                                  \
    (P2VAR) = 0;                                        \
 } while (0)
#endif

/* The NOP_OPCODE is for the alignment fill value.
 * fill it a nop instruction so that the disassembler does not choke
 * on it
 */
#ifndef NOP_OPCODE
#define NOP_OPCODE 0x00
d70 1
a70 1
char *input_line_pointer;	/*->next char of source file to parse. */
d99 2
d114 2
a115 3
/* used by is_... macros. our ctype[] */
char lex_type[256] =
{
d123 1
a123 1
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, LEX_TILDE, 0, /* pqrstuvwxyz{|}~. */
d134 3
a136 8

/*
 * In: a character.
 * Out: 1 if this character ends a line.
 */
#define Z_ (0)
char is_end_of_line[256] =
{
d138 1
a138 1
  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, 99, Z_, Z_,	/* @@abcdefghijklmno */
d140 1
a140 1
  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_, Z_,	/* @@abcdefghijklmno */
d142 19
a160 7
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
#ifdef TC_HPPA
  Z_,99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* _!"#$%&'()*+,-./ */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* 0123456789:;<=>? */
#else
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_,	/* 0123456789:;<=>? */
a161 11
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
};
#undef Z_
d163 1
a163 1
/* Functions private to this file. */
d165 2
a166 2
static char *buffer;	/* 1st char of each buffer of lines is here. */
static char *buffer_limit;	/*->1 + last char in buffer. */
d168 3
a170 2
/* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1 in the
   tc-<CPU>.h file.  See the "Porting GAS" section of the internals manual. */
d173 1
a173 1
static char *old_buffer;	/* JF a hack */
d177 4
a180 1
/* Variables for handling include file directory table. */
d182 5
a186 4
char **include_dirs;	/* Table of pointers to directories to
			   search for .include's */
int include_dir_count;	/* How many are in the table */
int include_dir_maxlen = 1;/* Length of longest in table */
a242 1

d256 1
a256 1
  /* Use machine dependent syntax */
d259 1
a259 1
  /* Use more.  FIXME-SOMEDAY. */
d265 1
a265 1
/* set up pseudo-op tables */
d269 1
a269 2
static const pseudo_typeS potable[] =
{
d277 1
a277 1
/* block */
d309 1
a309 1
/* dim */
d311 2
a312 2
/* dsect */
  {"eject", listing_eject, 0},	/* Formfeed listing */
d320 1
a320 1
/* endef */
d325 2
a326 2
/* extend */
  {"extern", s_ignore, 0},	/* We treat all undef as ext */
d359 1
a359 1
  {"lflags", listing_flags, 0},	/* Listing flags */
d361 1
a361 1
  {"list", listing_list, 1},	/* Turn listing on */
d371 1
a371 1
  {"nolist", listing_list, 0},	/* Turn listing off */
d382 1
a382 1
  {"psize", listing_psize, 0},	/* set paper size */
d388 3
a390 3
  {"sbttl", listing_title, 1},	/* Subtitle of listing */
/* scl */
/* sect */
d394 1
a394 1
/* size */
d404 1
a404 1
/* tag */
d417 1
a417 1
  {"title", listing_title, 0},	/* Listing title */
d419 1
a419 1
/* type */
d421 2
a422 2
/* use */
/* val */
d429 1
a429 1
  {NULL, NULL, 0}			/* end sentinel */
d458 1
a458 1
static void 
d463 1
a463 1
  /* Do the target-specific pseudo ops. */
d467 1
a467 1
  /* Now object specific.  Skip any that were in the target table. */
d472 1
a472 1
  /* Now portable ones.  Skip any that we've seen already. */
d480 1
a480 1
      while (! is_end_of_line[(unsigned char) *input_line_pointer++])	\
a485 1

d507 3
a509 6
/*	read_a_source_file()
 *
 * We read the file, putting things into a web that
 * represents what we have been reading.
 */
void 
d514 1
a514 1
  register char *s;		/* string of symbol, '\0' appended */
d518 4
d534 2
a535 2
    {				/* We have another line to parse. */
      know (buffer_limit[-1] == '\n');	/* Must have a sentinel. */
d541 1
a541 1
	  /* We have more of this buffer to parse. */
d543 3
a545 5
	  /*
	   * We now have input_line_pointer->1st char of next line.
	   * If input_line_pointer [-1] == '\n' then we just
	   * scanned another line: so bump line counters.
	   */
a550 1

d601 1
a601 1
		      if (! mri_line_macro 
d603 2
a604 2
                          && TC_START_LABEL_WITHOUT_COLON(c, 
                                                          input_line_pointer)
d606 1
a606 1
                          )
d621 12
a632 14
	  /*
	   * We are at the begining of a line, or similar place.
	   * We expect a well-formed assembler statement.
	   * A "symbol-name:" is a statement.
	   *
	   * Depending on what compiler is used, the order of these tests
	   * may vary to catch most common case 1st.
	   * Each test is independent of all other tests at the (top) level.
	   * PLEASE make a compiler that doesn't use this assembler.
	   * It is crufty to waste a compiler's time encoding things for this
	   * assembler, which then wastes more time decoding it.
	   * (And communicating via (linear) files is silly!
	   * If you must pass stuff, please pass a tree!)
	   */
d637 3
a639 4
	    {
	      c = *input_line_pointer++;
	    }
	  know (c != ' ');	/* No further leading whitespace. */
d652 1
a652 1
		  for (s = input_line_pointer-1; *s ; ++s)
d658 1
a658 1
		  len = s - (input_line_pointer-1);
d662 2
a663 2
		  memcpy (copy + macro_nest + 1, input_line_pointer-1, len);
		  copy[macro_nest+1+len] = '\0';
d672 2
a673 5

	  /*
	   * C is the 1st significant character.
	   * Input_line_pointer points after that character.
	   */
d676 1
a676 1
	      /* want user-defined label or pseudo/opcode */
d680 8
a687 9
	      c = get_symbol_end ();	/* name's delimiter */
	      /*
	       * C is character after symbol.
	       * That character's place in the input line is now '\0'.
	       * S points to the beginning of the symbol.
	       *   [In case of pseudo-op, s->'.'.]
	       * Input_line_pointer->'\0' where c was.
	       */
	      if (TC_START_LABEL(c, input_line_pointer))
a693 1

d696 1
d699 1
d710 4
a713 3
		  line_label = colon (s);	/* user-defined label */
		  *input_line_pointer++ = ':';	/* Put ':' back for error messages' sake. */
		  /* Input_line_pointer->after ':'. */
a714 2


d720 1
a720 1
			   && ! TC_EQUAL_IN_INSN (c, input_line_pointer)
d728 2
a729 1
		{		/* expect pseudo-op or machine instruction */
a731 1
#define IGNORE_OPCODE_CASE
d735 4
a746 1

d757 1
a757 1
		      || (! flag_m68k_mri && *s == '.'))
d759 5
a763 7
		      /*
		       * PSEUDO - OP.
		       *
		       * WARNING: c has next char, which may be end-of-line.
		       * We lookup the pseudo-op table with s+1 because we
		       * already know that the pseudo-op begins with a '.'.
		       */
d773 4
a776 4
			      || ! ((pop->poc_handler == cons
				     && pop->poc_val == 1)
				    || (pop->poc_handler == s_space
					&& pop->poc_val == 1)
d778 1
a778 1
				    || tc_conditional_pseudoop (pop)
d780 8
a787 8
				    || pop->poc_handler == s_if
				    || pop->poc_handler == s_ifdef
				    || pop->poc_handler == s_ifc
				    || pop->poc_handler == s_ifeqs
				    || pop->poc_handler == s_else
				    || pop->poc_handler == s_endif
				    || pop->poc_handler == s_globl
				    || pop->poc_handler == s_ignore)))
d791 1
d799 1
a799 1
		      /* Print the error msg now, while we still can */
d808 1
a808 1
		      /* Put it back for error messages etc. */
d812 1
a812 1
			 keyword from operands. */
d815 4
a818 5
		      /*
		       * Input_line is restored.
		       * Input_line_pointer->1st non-blank char
		       * after pseudo-operation.
		       */
d832 2
a833 2
		      /* WARNING: c has char, which may be end-of-line. */
		      /* Also: input_line_pointer->`\0` where c was. */
d843 1
a843 1
			    inquote = ! inquote;
d848 1
a848 1
			    inquote = ! inquote;
d864 1
a864 1
                          macro_entry *macro;
d877 1
a877 1
                              md_macro_info (macro);
d894 1
a894 1
		      md_assemble (s);	/* Assemble 1 instruction. */
d899 3
a901 3
			 this instruction. */
		    }		/* if (*s=='.') */
		}		/* if c==':' */
d903 1
a903 2
	    }			/* if (is_name_beginner(c) */

d912 1
a912 1
	      /* local label  ("4:") */
d919 1
d924 1
a924 1
		}		/* read the whole number */
d954 1
a954 1
	    {			/* Its a comment.  Better say APP or NO_APP */
d977 1
a977 1
		     guarentee it. . . */
d1045 1
d1055 2
a1056 3

	  /* as_warn("Junk character %d.",c);  Now done by ignore_rest */
	  input_line_pointer--;	/* Report unknown char as ignored. */
d1058 1
a1058 1
	}			/* while (input_line_pointer<buffer_limit) */
d1077 1
a1077 1
    }				/* while (more buffers to scan) */
d1082 10
a1091 1
  md_cleanup();
a1092 1
  input_scrub_close ();		/* Close the input file */
d1107 1
a1108 2

  char *s;
d1114 1
a1114 1
       ((! is_end_of_line[(unsigned char) *s] && *s != ' ' && *s != '\t')
d1119 1
a1119 1
	inquote = ! inquote;
a1120 4
  *stopcp = *s;
  *s = '\0';
  return s;

d1122 3
a1124 4

  char *s;

  for (s = input_line_pointer; ! is_end_of_line[(unsigned char) *s]; s++)
d1126 1
d1129 1
a1130 3

#endif

d1144 1
a1144 1
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
d1148 1
a1148 1
void 
d1161 1
a1161 1
static void 
a1167 2
  char default_fill;

d1172 1
a1172 11
  if (fill == NULL)
    {
      if (subseg_text_p (now_seg))
	default_fill = NOP_OPCODE;
      else
	default_fill = 0;
      fill = &default_fill;
      len = 1;
    }

  /* Only make a frag if we HAVE to. . . */
d1175 8
a1182 1
      if (len <= 1)
d1220 1
a1220 1
	align = arg;	/* Default value from pseudo-op table */
d1239 1
d1276 1
a1276 1
  if (! fill_p)
d1289 1
a1289 1
	fill_len = - arg;
d1317 1
a1317 1
void 
d1327 1
a1327 1
void 
d1334 1
a1334 1
void 
d1351 1
a1351 1
  /* just after name is now '\0' */
d1355 1
d1364 1
d1366 1
d1375 1
d1379 2
a1380 1
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d1389 1
d1406 1
a1406 1
    if ( (!temp) || !flag_one)
d1434 1
a1434 1
  if (! flag_mri)
d1445 1
a1445 1
  if (! isdigit ((unsigned char) *name))
d1454 1
d1481 1
a1481 1
  if (S_IS_DEFINED (sym) && ! S_IS_COMMON (sym))
d1553 1
a1553 1
void 
d1560 1
a1560 1
  /* Some assemblers tolerate immediately following '"' */
d1567 1
a1567 1
	= (! new_logical_line (s, appfile ? -2 : -1) && appfile);
d1577 1
a1577 1
      if (! may_omit)
d1607 2
a1608 1
    as_warn (_("Line numbers must be positive; line number %d rejected."), l+1);
d1632 1
a1632 1
      if (! is_end_of_line[(unsigned char) *input_line_pointer]
d1674 1
a1674 1
void 
d1752 1
d1754 1
d1756 4
a1759 4
       * flavoured AS.  The following bizzare behaviour is to be
       * compatible with above.  I guess they tried to take up to 8
       * bytes from a 4-byte expression and they forgot to sign
       * extend. Un*x Sux. */
d1766 3
a1768 3
       * but emits no error message because it seems a legal thing to do.
       * It is a degenerate case of .fill but could be emitted by a compiler.
       */
d1773 1
a1773 1
void 
d1827 1
a1827 1
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
d1858 1
a1858 1
  if (! is_end_of_line[(unsigned char) *input_line_pointer])
d1908 1
a1908 1
    if (! bfd_set_section_flags (stdoutput, now_seg, flags))
d1920 1
a1920 1
static void 
d1923 1
a1923 1
	(alignment); 0 if it was an ".lcomm" (2 args only)  */
d1926 1
a1926 1
	rather than the power of 2. */
d1977 1
a1977 1
	  if (! bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
d1985 8
a1992 8
   if (!needs_align)
     {
       TC_IMPLICIT_LCOMM_ALIGNMENT (temp, align);

       /* Still zero unless TC_IMPLICIT_LCOMM_ALIGNMENT set it.  */
       if (align)
         record_alignment(bss_seg, align);
     }
d1998 1
d2005 1
d2008 1
d2014 1
d2016 1
d2031 1
d2042 1
d2044 1
a2044 1
    }				/* if needs align */
d2081 2
a2082 1
					/* detach from old frag	*/
d2087 1
a2087 1
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
d2096 1
a2096 1
         in that case.  Otherwise, set it to static. */
d2114 1
a2114 1
}				/* s_lcomm_internal() */
d2123 2
a2124 1
void s_lcomm_bytes (needs_align)
d2130 1
a2130 1
void 
d2140 1
a2140 1
  /* we permit ANY defined expression: BSD4.2 demands constants */
d2146 1
d2155 1
d2158 1
d2166 1
d2175 1
a2175 1
     anyway.  xoxorich. */
d2181 1
a2181 1
	 keep the "external" bit. */
d2192 1
d2195 1
a2195 1
}				/* s_lsym() */
d2217 1
a2217 1
  if (! flag_m68k_mri)
d2230 2
a2231 1
  while (! is_end_of_line[(unsigned char) *input_line_pointer]
d2243 1
d2246 1
d2254 1
d2275 1
a2275 1
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
d2296 1
a2296 1
	  || (! flag_m68k_mri
d2382 2
d2385 8
a2392 2
      p = frag_var (rs_org, 1, 1, (relax_substateT) 0, exp->X_add_symbol,
		    exp->X_add_number * OCTETS_PER_BYTE, (char *) NULL);
d2397 1
a2397 1
void 
d2444 1
a2444 1
}				/* s_org() */
d2464 1
a2464 1
  
d2466 1
a2466 1
  if (! isdigit ((unsigned char) *name))
d2475 1
d2519 1
a2519 1
	    if (! bfd_set_section_flags (stdoutput, seg, flags))
d2605 1
a2605 1
  demand_empty_rest_of_line ();	  
d2670 1
a2670 1
  do_repeat(count, "REPT", "ENDR");
d2674 1
a2674 1
   different directives to be used as the start/end keys. */
d2678 3
a2680 3
      int count;
      const char *start;
      const char *end;
d2686 1
a2686 1
  if (! buffer_and_nest (start, end, &one, get_line_sb))
d2705 1
a2705 1
   are properly nested. 
d2709 1
a2709 1
   such as line substitutions. */
d2713 1
a2713 1
  int extra;
d2724 1
a2724 1
void 
d2733 3
a2735 5
  /*
   * Especial apologies for the random logic:
   * this just grew, and could be parsed much more simply!
   * Dean in haste.
   */
d2756 1
a2756 1
      /* Turn '. = mumble' into a .org mumble */
d2779 2
a2780 2
	  fragS *dummy_frag = (fragS *) xmalloc (sizeof(fragS));
	  memset (dummy_frag, 0, sizeof(fragS));
d2788 2
a2789 2
        symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
			    
d2791 1
a2791 1
      /* "set" symbols are local unless otherwise specified. */
d2794 1
a2794 2

    }				/* make a new symbol */
d2807 1
a2807 1
}				/* s_set() */
d2809 1
a2809 1
void 
d2913 1
a2913 1
	      if (! flag_mri)
d2948 1
d2954 1
d3091 1
a3091 1
}				/* s_text() */
d3093 1
a3093 2

void 
d3098 1
a3098 3
    {
      input_line_pointer++;
    }
d3100 4
a3103 5
    {
      ignore_rest_of_line ();
    }
  /* Return having already swallowed end-of-line. */
}				/* Return pointing just after end-of-line. */
d3106 1
a3106 1
ignore_rest_of_line ()		/* For suspect lines: gives warning. */
d3108 1
d3117 1
d3120 1
a3120 3
	{
	  input_line_pointer++;
	}
d3122 4
a3125 1
  input_line_pointer++;		/* Return pointing just after end-of-line. */
d3133 6
a3138 5
         && !is_end_of_line[(unsigned char) *input_line_pointer])
    {
      input_line_pointer++;
    }
  input_line_pointer++;         /* Return pointing just after end-of-line. */
d3142 7
a3148 10
/*
 *			pseudo_set()
 *
 * In:	Pointer to a symbol.
 *	Input_line_pointer->expression.
 *
 * Out:	Input_line_pointer->just after any whitespace after expression.
 *	Tried to set symbol to value of expression.
 *	Will change symbols type, value, and frag;
 */
d3158 1
a3158 1
  know (symbolP);		/* NULL pointer is logic error. */
d3205 1
a3205 1
        symbol_set_frag (symbolP, &zero_address_frag);
d3246 12
a3257 14
/*
 *			cons()
 *
 * CONStruct more frag of .bytes, or .words etc.
 * Should need_pass_2 be 1 then emit no frag(s).
 * This understands EXPRESSIONS.
 *
 * Bug (?)
 *
 * This has a split personality. We use expression() to read the
 * value. We can detect if the value won't fit in a byte or word.
 * But we can't detect if expression() discarded significant digits
 * in the case of a long. Not worth the crocks required to fix it.
 */
d3277 1
a3277 1
static void 
d3292 4
a3295 4
/* worker to do .byte etc statements */
/* clobbers input_line_pointer, checks */
/* end-of-line. */
static void 
d3297 1
a3297 1
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
d3352 1
a3352 1
  input_line_pointer--;		/* Put terminator back into stream. */
a3359 1

d3367 1
a3367 1
void 
d3485 1
a3485 1
	  next = (((~ (generic_bignum[i] & LITTLENUM_MASK))
d3550 1
a3550 1
      if (! exp->X_unsigned && exp->X_add_number < 0)
d3574 1
a3574 1
	 particular SPARC (Sun 4) has problems */
d3585 1
a3585 1
	  /* Don't store these bits. */
d3590 1
a3590 1
      unmask = ~mask;		/* Do store these bits. */
d3594 1
a3594 1
      mask = ~(unmask >> 1);	/* Includes sign bit now. */
d3602 1
a3602 1
	{		/* Leading bits contain both 0s & 1s. */
d3606 1
a3606 1
      /* put bytes in right order. */
d3741 1
a3741 1
static void 
d3752 2
a3753 1
    {			/* bitfields */
d3764 1
a3764 1
	    }			/* next piece is not a bitfield */
d3782 1
a3782 1
	     .equ type symbol.  xoxorich. */
d3789 1
a3789 1
	    }			/* implied zero width bitfield */
d3798 1
a3798 1
	    }			/* too complex */
d3805 1
a3805 1
	    }			/* too big */
d3813 1
a3813 1
	    }			/* won't fit */
d3815 2
a3816 1
	  hold = ++input_line_pointer; /* skip ':' */
d3828 1
a3828 1
	    }			/* too complex */
d3838 1
a3838 1
	    }			/* all the bitfields we're gonna get */
d3842 1
a3842 1
	}			/* forever loop */
d3847 2
a3848 2
    }				/* if looks like a bitfield */
}				/* parse_bitfield_cons() */
d3896 1
a3896 1
      /* Left justify */
d3902 2
a3903 1
      /* Create correct expression */
d3906 2
a3907 1
      /* Fake it so that we can read the next char too */
d4014 1
a4014 1
	 through the hex constant, so we ignore them as well. */
d4053 16
a4068 19
/*
 *			float_cons()
 *
 * CONStruct some more frag chars of .floats .ffloats etc.
 * Makes 0 or more new frags.
 * If need_pass_2 == 1, no frags are emitted.
 * This understands only floating literals, not expressions. Sorry.
 *
 * A floating constant is defined by atof_generic(), except it is preceded
 * by 0d 0f 0g or 0h. After observing the STRANGE way my BSD AS does its
 * reading, I decided to be incompatible. This always tries to give you
 * rounded bits to the precision of the pseudo-op. Former AS did premature
 * truncatation, restored noisy bits instead of trailing 0s AND gave you
 * a choice of 2 flavours of noise according to which of 2 floating-point
 * scanners you directed AS to use.
 *
 * In:	input_line_pointer->whitespace before, or '0' of flonum.
 *
 */
d4072 2
a4073 2
     /* Clobbers input_line-pointer, checks end-of-line. */
     register int float_type;	/* 'f':.ffloat ... 'F':.float ... */
d4076 2
a4077 2
  int length;			/* Number of chars in an object. */
  register char *err;		/* Error from scanning floating literal. */
d4092 1
a4092 1
      /* input_line_pointer->1st char of a flonum (we hope!). */
d4096 3
a4098 4
       * letter is legal. Someone may invent a "z" format and this routine
       * has no use for such information. Lusers beware: you get
       * diagnostics if your input is ill-conditioned.
       */
d4141 1
d4144 1
a4144 3
		{
		  as_warn (_("unresolvable or nonpositive repeat count; using 1"));
		}
d4160 2
a4161 1
  --input_line_pointer;		/* Put terminator back into stream.  */
d4163 1
a4163 1
}				/* float_cons() */
d4165 1
a4165 1
/* Return the size of a LEB128 value */
d4299 1
a4299 1
  while (size > 0 && bignum[size-1] == (LITTLENUM_TYPE)-1)
d4319 1
a4319 1
	      || (~(val | ~(((valueT)1 << loaded) - 1)) == 0
d4346 1
a4346 1
  while (size > 0 && bignum[size-1] == 0)
d4391 1
a4391 1
emit_leb128_expr(exp, sign)
d4396 1
d4416 11
d4452 1
a4452 1
      /* Otherwise, we have to create a variable sized fragment and 
d4455 1
a4455 1
      frag_var (rs_leb128, sizeof_uleb128 (~(valueT)0), 0, sign,
d4468 6
a4473 4
  do {
    expression (&exp);
    emit_leb128_expr (&exp, sign);
  } while (*input_line_pointer++ == ',');
d4479 3
a4481 7
/*
 *			stringer()
 *
 * We read 0 or more ',' separated, double-quoted strings.
 *
 * Caller should have checked need_pass_2 is FALSE because we don't check it.
 */
d4483 4
a4486 5

void 
stringer (append_zero)		/* Worker to do .ascii etc statements. */
     /* Checks end-of-line. */
     register int append_zero;	/* 0: don't append '\0', else 1 */
d4495 5
a4499 8
  /*
   * The following awkward logic is to parse ZERO or more strings,
   * comma separated. Recall a string expression includes spaces
   * before the opening '\"' and spaces after the closing '\"'.
   * We fake a leading ',' if there is (supposed to be)
   * a 1st, expression. We keep demanding expressions for each
   * ','.
   */
d4502 2
a4503 2
      c = 0;			/* Skip loop. */
      ++input_line_pointer;	/* Compensate for end of loop. */
d4507 1
a4507 1
      c = ',';			/* Do loop. */
d4515 1
a4515 1
	  ++input_line_pointer;	/*->1st char of string. */
d4572 1
a4572 1
    returning values bigger than 1 byte.  xoxorich. */
d4574 1
a4574 1
unsigned int 
d4621 1
a4621 1
	  break;		/* As itself. */
d4637 3
a4639 1
	    for (i = 0, number = 0; isdigit (c) && i < 3; c = *input_line_pointer++, i++)
d4643 1
d4672 1
a4672 1
	  /* To be compatible with BSD 4.2 as: give the luser a linefeed!! */
d4686 1
a4686 1
	}			/* switch on escaped char */
d4692 1
a4692 1
    }				/* switch on char */
d4694 1
a4694 1
}				/* next_char_of_string() */
d4715 1
a4715 1
static segT 
d4737 1
a4737 1
}				/* get_known_segmented_expression() */
d4754 1
a4754 1
char				/* return terminator */
d4756 1
a4756 1
     long *val_pointer;		/* return value of expression */
d4763 3
a4765 6
/*
 *			demand_copy_C_string()
 *
 * Like demand_copy_string, but return NULL if the string contains any '\0's.
 * Give a warning if that happens.
 */
d4787 1
d4791 3
a4793 6
/*
 *			demand_copy_string()
 *
 * Demand string, but return a safe (=private) copy of the string.
 * Return NULL if we can't read a string here.
 */
d4806 1
a4806 1
      input_line_pointer++;	/* Skip opening quote. */
d4814 1
a4814 1
	 null terminated string. */
d4826 1
a4826 1
}				/* demand_copy_string() */
d4828 7
a4834 10
/*
 *		is_it_end_of_statement()
 *
 * In:	Input_line_pointer->next character.
 *
 * Do:	Skip input_line_pointer over all whitespace.
 *
 * Out:	1 if input_line_pointer->end-of-line.
*/
int 
d4839 1
a4839 1
}				/* is_it_end_of_statement() */
d4841 1
a4841 1
void 
d4846 1
a4846 1
  register symbolS *symbolP;	/* symbol we are working with */
d4862 1
a4862 1
      /* Turn '. = mumble' into a .org mumble */
d4872 7
d4881 1
a4881 1
      if (! reassign
d4885 7
d4896 6
a4901 5
     {
       ignore_rest_of_line (); /* check garbage after the expression */
       mri_comment_end (stop, stopc);
     }
}				/* equals() */
d4903 1
a4903 1
/* .include -- include a file at this point. */
d4905 1
a4905 2
/* ARGSUSED */
void 
d4914 1
a4914 1
  if (! flag_m68k_mri)
d4928 1
a4928 1
      while (! is_end_of_line[(unsigned char) *input_line_pointer]
d4936 1
d4939 1
a4939 1
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
d4942 1
d4945 1
d4957 1
d4961 1
a4961 1
  /* malloc Storage leak when file is found on path.  FIXME-SOMEDAY. */
d4964 1
a4964 1
}				/* s_include() */
d4966 1
a4966 1
void 
d4975 1
a4975 1
      include_dirs[0] = ".";	/* Current dir */
d4981 3
a4983 2
      include_dirs = (char **) realloc (include_dirs,
				include_dir_count * sizeof (*include_dirs));
d4986 1
a4986 1
  include_dirs[include_dir_count - 1] = path;	/* New one */
d4991 1
a4991 1
}				/* add_include_dir() */
a5006 12
#ifdef ECOFF_DEBUGGING
  /* ECOFF assemblers automatically generate debugging information. 
     FIXME: This should probably be handled elsewhere.  */
  if (debug_type == DEBUG_UNSPECIFIED)
    {
      if (ECOFF_DEBUGGING && ecoff_no_current_file ())
        debug_type = DEBUG_ECOFF;
      else
	debug_type = DEBUG_NONE;
    }
#endif

d5011 1
a5018 1
    case DEBUG_DWARF:
d5020 4
a5023 1
      /* FIXME.  */
d5068 2
a5069 2
      char *name,*label;
      char delim1,delim2;
d5121 1
a5121 1
void 
a5131 1

d5139 2
a5140 2
/* Inserts the given line into the input stream.  
   
d5150 1
a5150 1
  const char *line;
d5161 1
a5161 1
   file; no include path searching or dependency registering is performed.  */ 
d5165 1
a5165 1
  char *path;
a5169 2

/* end of read.c */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 2
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 1996
   Free Software Foundation, Inc.
d18 3
a20 2
along with GAS; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d56 15
a80 2
int generate_asm_lineno = 0;	/* flag to generate line stab for .s file */

d107 4
d116 5
d126 1
a126 1
  0, 0, 0, 0, LEX_DOLLAR, LEX_PCT, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, /* _!"#$%&'()*+,-./ */
d131 9
a139 8
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, 0, 0, /* pqrstuvwxyz{|}~. */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
d147 1
a147 1
#define _ (0)
d151 1
a151 1
  _, _, _, _, _, _, _, _, _, _, 99, _, _, 99, _, _,	/* @@abcdefghijklmno */
d153 1
a153 1
  _, _, _, _, _, _, _, _, _, _, 99, _, _, _, _, _,	/* @@abcdefghijklmno */
d155 1
a155 1
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
d157 2
a158 2
  _,99, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* _!"#$%&'()*+,-./ */
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* 0123456789:;<=>? */
d160 2
a161 2
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
  _, _, _, _, _, _, _, _, _, _, _, 99, _, _, _, _,	/* 0123456789:;<=>? */
d163 9
a171 9
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,	/* */
d173 1
a173 1
#undef _
d180 2
a181 7
#ifdef TARGET_BYTES_BIG_ENDIAN
/* Hack to deal with tc-*.h defining TARGET_BYTES_BIG_ENDIAN to empty
   instead of to 0 or 1.  */
#if 5 - TARGET_BYTES_BIG_ENDIAN - 5 == 10
#undef  TARGET_BYTES_BIG_ENDIAN
#define TARGET_BYTES_BIG_ENDIAN 1
#endif
a182 3
#else
int target_big_endian /* = 0 */;
#endif
d188 1
a188 1
/* Variables for handling include file directory list. */
d190 1
a190 1
char **include_dirs;	/* List of pointers to directories to
d192 2
a193 2
int include_dir_count;	/* How many are in the list */
int include_dir_maxlen = 1;/* Length of longest in list */
d220 14
a233 2
static int scrub_from_string PARAMS ((char **));
static void do_align PARAMS ((int, char *, int));
d235 7
d248 1
d324 1
d327 1
d331 1
d343 1
d406 1
d429 1
d438 1
a438 1
  {NULL}			/* end sentinel */
d454 1
a454 1
	as_fatal ("error constructing %s pseudo-op table: %s", pop_table_name,
d503 12
a514 9
scrub_from_string (from)
     char **from;
{
  int size;

  *from = scrub_string;
  size = scrub_string_end - scrub_string;
  scrub_string = scrub_string_end;
  return size;
d534 7
a540 1
  listing_newline ("");
d568 1
a568 5
	      if (flag_m68k_mri
#ifdef LABELS_WITHOUT_COLONS
		  || 1
#endif
		  )
d576 1
d578 1
d583 3
a585 2
		      /* In MRI mode, the EQU pseudoop must be
			 handled specially.  */
d599 2
a600 1
			      equals (line_start);
d603 5
d610 15
a624 1
		      line_label = colon (line_start);
d655 33
a687 1
	  LISTING_NEWLINE ();
d723 1
a723 1
			  equals (s);
d736 2
a737 1
		       || (input_line_pointer[1] == '='
d743 1
a743 1
		  equals (s);
d756 1
a756 1
			if (isupper (*s2))
d763 1
a763 5
		  if (flag_m68k_mri
#ifdef NO_PSEUDO_DOT
		      || 1
#endif
		      )
d794 12
a805 1
					&& pop->poc_val == 1))))
d807 1
a807 1
			  do_align (1, (char *) NULL, 0);
d809 5
d819 1
a819 1
			  as_bad ("Unknown pseudo-op:  `%s'", s);
d844 1
a844 1
		    {		/* machine instruction */
d846 3
a848 6

		      if (mri_pending_align)
			{
			  do_align (1, (char *) NULL, 0);
			  mri_pending_align = 0;
			}
d862 8
d876 1
a876 15
#ifdef OBJ_GENERATE_ASM_LINENO
		      if (generate_asm_lineno == 0)
			{
		          if (ecoff_no_current_file ())
			    generate_asm_lineno = 1;
			}
		      if (generate_asm_lineno == 1)
		        {
			  unsigned int lineno;
			  char *s;

			  as_where (&s, &lineno);
			  OBJ_GENERATE_ASM_LINENO (s, lineno);
		        }
#endif
d882 1
d884 1
a884 1
			  if (check_macro (s, &out, '\0', &err))
d887 1
a887 1
				as_bad (err);
d890 1
a890 1
						      input_line_pointer);
d894 3
d901 11
d929 1
a929 1
	      && isdigit (c))
d938 1
a938 1
	      while (isdigit (*input_line_pointer))
d952 1
a952 1
		      as_fatal ("label \"%d$\" redefined", temp);
d1167 1
a1167 1
     int ignore;
d1169 1
a1169 1
  as_fatal (".abort detected.  Abandoning ship.");
d1172 6
a1177 1
/* Guts of .align directive.  */
d1179 1
a1179 1
do_align (n, fill, len)
d1183 1
d1185 2
d1188 1
a1188 1
  md_do_align (n, fill, len, just_record_alignment);
d1190 2
a1191 1
  if (!fill)
d1193 2
a1194 8
      /* @@@@ Fix this right for BFD!  */
      static char zero;
      static char nop_opcode = NOP_OPCODE;

      if (now_seg != data_section && now_seg != bss_section)
	{
	  fill = &nop_opcode;
	}
d1196 2
a1197 3
	{
	  fill = &zero;
	}
d1202 1
a1202 1
  if (n && !need_pass_2)
d1205 1
a1205 1
	frag_align (n, *fill);
d1207 1
a1207 1
	frag_align_pattern (n, fill, len);
d1214 1
a1214 1
  record_alignment (now_seg, n);
d1217 7
a1223 3
/* For machines where ".align 4" means align to a 4 byte boundary. */
void 
s_align_bytes (arg)
d1225 1
d1227 1
a1227 4
  register unsigned int temp;
  char temp_fill;
  unsigned int i = 0;
  unsigned long max_alignment = 1 << 15;
d1230 3
d1240 1
a1240 1
	temp = 0;
d1242 1
a1242 1
	temp = arg;	/* Default value from pseudo-op table */
d1245 4
a1248 1
    temp = get_absolute_expression ();
d1250 1
a1250 1
  if (temp > max_alignment)
d1252 11
a1262 1
      as_bad ("Alignment too large: %d. assumed.", temp = max_alignment);
d1265 1
a1265 3
  /* For the sparc, `.align (1<<n)' actually means `.align n' so we
     have to convert it.  */
  if (temp != 0)
d1267 2
a1268 2
      for (i = 0; (temp & 1) == 0; temp >>= 1, ++i)
	;
a1269 2
  if (temp != 1)
    as_bad ("Alignment not a power of 2");
d1271 6
a1276 2
  temp = i;
  if (*input_line_pointer == ',')
d1278 3
a1280 7
      offsetT fillval;
      int len;

      input_line_pointer++;
      fillval = get_absolute_expression ();
      if (arg >= 0)
	len = 1;
a1281 2
	len = - arg;
      if (len <= 1)
d1283 3
a1285 2
	  temp_fill = fillval;
	  do_align (temp, &temp_fill, len);
d1287 3
d1292 2
a1293 6
	  char ab[16];

	  if (len > sizeof ab)
	    abort ();
	  md_number_to_chars (ab, fillval, len);
	  do_align (temp, ab, len);
d1296 2
a1297 1
  else
d1300 2
a1301 2
	as_warn ("expected fill pattern missing");
      do_align (temp, (char *) NULL, 0);
d1303 1
a1303 30

  if (flag_mri)
    mri_comment_end (stop, stopc);

  demand_empty_rest_of_line ();
}

/* For machines where ".align 4" means align to 2**4 boundary. */
void 
s_align_ptwo (arg)
     int arg;
{
  register int temp;
  char temp_fill;
  long max_alignment = 15;
  char *stop = NULL;
  char stopc;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  temp = get_absolute_expression ();
  if (temp > max_alignment)
    as_bad ("Alignment too large: %d. assumed.", temp = max_alignment);
  else if (temp < 0)
    {
      as_bad ("Alignment negative. 0 assumed.");
      temp = 0;
    }
  if (*input_line_pointer == ',')
d1305 1
a1305 2
      offsetT fillval;
      int len;
a1306 2
      input_line_pointer++;
      fillval = get_absolute_expression ();
d1308 1
a1308 1
	len = 1;
d1310 2
a1311 2
	len = - arg;
      if (len <= 1)
d1313 4
a1316 2
	  temp_fill = fillval;
	  do_align (temp, &temp_fill, len);
d1322 1
a1322 1
	  if (len > sizeof ab)
d1324 2
a1325 2
	  md_number_to_chars (ab, fillval, len);
	  do_align (temp, ab, len);
d1328 2
a1329 6
  else
    {
      if (arg < 0)
	as_warn ("expected fill pattern missing");
      do_align (temp, (char *) NULL, 0);
    }
d1333 4
d1338 15
a1352 1
  demand_empty_rest_of_line ();
d1357 1
a1357 1
     int ignore;
d1378 2
a1379 1
      as_bad ("Expected comma after symbol-name: rest of line ignored.");
a1381 1
      ignore_rest_of_line ();
d1387 2
a1388 1
      as_warn (".COMMon length (%ld.) <0! Ignored.", (long) temp);
a1390 1
      ignore_rest_of_line ();
d1396 1
a1396 1
  if (S_IS_DEFINED (symbolP))
d1398 1
a1398 1
      as_bad ("Ignoring attempt to re-define symbol `%s'.",
d1400 1
a1402 1
      ignore_rest_of_line ();
d1408 1
a1408 1
	as_bad ("Length of .comm \"%s\" is already %ld. Not changed to %ld.",
d1427 2
a1430 2

  demand_empty_rest_of_line ();
d1439 1
a1439 1
     int small;
d1495 1
a1495 1
  if (S_IS_DEFINED (sym))
d1497 4
a1500 9
#if defined (S_IS_COMMON) || defined (BFD_ASSEMBLER)
      if (! S_IS_COMMON (sym))
#endif
	{
	  as_bad ("attempt to re-define symbol `%s'", S_GET_NAME (sym));
	  mri_comment_end (stop, stopc);
	  ignore_rest_of_line ();
	  return;
	}
d1513 6
a1518 4
      line_label->sy_value.X_op = O_symbol;
      line_label->sy_value.X_add_symbol = sym;
      line_label->sy_value.X_add_number = S_GET_VALUE (sym);
      line_label->sy_frag = &zero_address_frag;
d1531 2
a1533 2

  demand_empty_rest_of_line ();
d1538 1
a1538 1
     int ignore;
d1580 2
a1581 1
      new_logical_line (s, appfile ? -2 : -1);
d1591 2
d1594 2
a1595 2
      if (listing)
	listing_source_file (s);
d1597 1
a1597 1
    }
d1599 1
a1599 1
  obj_app_file (s);
d1601 2
d1612 1
a1612 1
     int ignore;
d1621 1
a1621 1
    as_warn ("Line numbers must be positive; line number %d rejected.", l+1);
d1638 1
a1638 1
     int ignore;
d1648 1
a1648 1
	as_warn ("start address not supported");
d1656 1
a1656 1
     int ignore;
d1658 1
a1658 1
  as_bad (".err encountered");
d1666 1
a1666 1
     int ignore;
d1677 1
a1677 1
    as_warn (".fail %ld encountered", (long) temp);
d1679 3
a1681 1
    as_bad (".fail %ld encountered", (long) temp);
a1684 2

  demand_empty_rest_of_line ();
d1689 1
a1689 1
     int ignore;
d1691 3
a1693 3
  long temp_repeat = 0;
  long temp_size = 1;
  register long temp_fill = 0;
d1700 1
a1700 1
  temp_repeat = get_absolute_expression ();
d1704 1
a1704 1
      temp_size = get_absolute_expression ();
d1708 1
a1708 1
	  temp_fill = get_absolute_expression ();
d1711 1
d1714 1
a1714 1
  if (temp_size > BSD_FILL_SIZE_CROCK_8)
d1716 2
a1717 2
      as_warn (".fill size clamped to %d.", BSD_FILL_SIZE_CROCK_8);
      temp_size = BSD_FILL_SIZE_CROCK_8;
d1719 1
a1719 1
  if (temp_size < 0)
d1721 2
a1722 2
      as_warn ("Size negative: .fill ignored.");
      temp_size = 0;
d1724 1
a1724 1
  else if (temp_repeat <= 0)
d1726 3
a1728 3
      if (temp_repeat < 0)
	as_warn ("Repeat < 0, .fill ignored");
      temp_size = 0;
d1731 1
a1731 1
  if (temp_size && !need_pass_2)
d1733 33
a1765 2
      p = frag_var (rs_fill, (int) temp_size, (int) temp_size, (relax_substateT) 0, (symbolS *) 0, temp_repeat, (char *) 0);
      memset (p, 0, (unsigned int) temp_size);
d1772 2
a1773 2
      md_number_to_chars (p, (valueT) temp_fill,
			  (temp_size > BSD_FILL_SIZE_CROCK_4
d1775 1
a1775 1
			   : (int) temp_size));
d1786 1
a1786 1
     int ignore;
d1802 2
d1806 1
a1806 1
      S_SET_EXTERNAL (symbolP);
d1817 2
a1820 2

  demand_empty_rest_of_line ();
d1849 1
a1849 1
  input_scrub_include_sb (&out, input_line_pointer);
d1861 1
a1861 1
     int ignore;
d1885 1
a1885 1
	as_warn ("unrecognized .linkonce type `%s'", s);
d1898 1
a1898 1
      as_warn (".linkonce is not supported for this object file format");
d1920 1
a1920 1
      as_bad ("bfd_set_section_flags: %s",
d1924 1
a1924 1
  as_warn (".linkonce is not supported for this object file format");
d1931 2
a1932 2
void 
s_lcomm (needs_align)
d1936 3
d1967 1
a1967 1
      as_bad ("Missing size expression");
d1973 1
a1973 1
      as_warn ("BSS length (%d.) <0! Ignored.", temp);
d1989 1
a1989 1
	    as_warn ("error setting flags for \".sbss\": %s",
d1995 1
d1998 1
a1998 14
       /* FIXME. This needs to be machine independent. */
       if (temp >= 8)
	 align = 3;
       else if (temp >= 4)
	 align = 2;
       else if (temp >= 2)
	 align = 1;
       else
	 align = 0;

#ifdef OBJ_EVAX
       /* FIXME: This needs to be done in a more general fashion.  */
       align = 3;
#endif
d2000 3
a2002 1
       record_alignment(bss_seg, align);
d2011 1
a2011 1
	  as_bad ("Expected comma after size");
d2019 1
a2019 1
	  as_bad ("Missing alignment");
d2023 14
d2040 1
a2040 1
	  as_warn ("Alignment too large: %d. assumed.", align);
d2045 1
a2045 1
	  as_warn ("Alignment negative. 0 assumed.");
d2067 11
a2077 6
#if defined(OBJ_AOUT) | defined(OBJ_BOUT)
       S_GET_OTHER (symbolP) == 0 &&
       S_GET_DESC (symbolP) == 0 &&
#endif /* OBJ_AOUT or OBJ_BOUT */
       (S_GET_SEGMENT (symbolP) == bss_seg
	|| (!S_IS_DEFINED (symbolP) && S_GET_VALUE (symbolP) == 0)))
d2084 1
a2084 1
	frag_align (align, 0);
d2087 1
a2087 1
	symbolP->sy_frag->fr_symbol = NULL;
d2089 1
a2089 1
      symbolP->sy_frag = frag_now;
d2091 1
a2091 1
			temp, (char *)0);
d2111 1
a2111 1
    as_bad ("Ignoring attempt to re-define symbol `%s'.",
d2117 14
a2130 1
}				/* s_lcomm() */
d2134 1
a2134 1
     int ignore;
d2151 1
a2151 1
      as_bad ("Expected comma after name \"%s\"", name);
d2161 1
a2161 1
      as_bad ("bad expression");
d2188 1
a2188 1
      as_bad ("Symbol %s already defined", name);
d2200 2
d2212 29
a2240 2
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
    sb_add_char (line, *input_line_pointer++);
d2256 1
a2256 1
     int ignore;
d2284 1
a2284 1
	  line_label->sy_frag = &zero_address_frag;
d2287 1
a2287 5
      if (((flag_m68k_mri
#ifdef NO_PSEUDO_DOT
	    || 1
#endif
	    )
d2292 1
a2292 1
	as_warn ("attempt to redefine pseudo-op `%s' ignored",
d2304 1
a2304 1
     int ignore;
d2306 1
d2314 1
a2314 1
     int ignore;
d2326 1
d2331 1
d2333 2
d2337 4
d2358 1
a2358 1
    as_bad ("invalid segment \"%s\"; segment \"%s\" assumed",
d2364 1
a2364 1
	as_warn ("ignoring fill value in absolute section");
d2367 1
a2367 1
	  as_bad ("only constant offsets supported in absolute section");
d2377 1
a2377 1
		    exp->X_add_number, (char *) NULL);
d2384 1
a2384 1
     int ignore;
d2390 4
d2399 1
a2399 1
      as_bad ("MRI style ORG pseudo-op not supported");
d2440 1
a2440 1
     char *type;
d2487 1
a2487 1
	as_bad ("unrecognized section type");
d2504 1
a2504 1
	      as_warn ("error setting flags for \"%s\": %s",
d2555 1
a2555 1
	as_warn ("unrecognized section type `%s'", sectype);
d2569 1
a2569 1
	  as_bad ("absolute sections are not supported");
d2584 1
a2584 1
	  as_warn ("unrecognized section command `%s'", seccmd);
d2594 2
a2595 1
  abort ();
d2604 1
a2604 1
     int ignore;
d2618 1
a2618 1
     int ignore;
d2648 1
a2648 1
     int ignore;
d2651 15
a2668 2
  count = get_absolute_expression ();

d2670 1
a2670 1
  if (! buffer_and_nest ("REPT", "ENDR", &one, get_line_sb))
d2672 1
a2672 1
      as_bad ("rept without endr");
d2682 1
a2682 1
  input_scrub_include_sb (&many, input_line_pointer);
d2687 21
d2709 2
a2710 2
s_set (ignore)
     int ignore;
d2731 1
a2731 1
      as_bad ("Expected comma after name \"%s\"", name);
d2758 18
a2775 1
      symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
d2786 6
d2805 1
d2834 6
a2839 3
		  know (line_label->sy_value.X_op == O_symbol);
		  know (line_label->sy_value.X_add_symbol == mri_common_symbol);
		  line_label->sy_value.X_add_number += 1;
d2845 1
a2845 1
	  do_align (1, (char *) NULL, 0);
d2848 1
a2848 1
	      line_label->sy_frag = frag_now;
d2854 2
d2876 1
a2876 1
	as_bad ("Unsupported variable size or fill value");
d2883 1
d2897 1
d2900 4
a2903 3
	      if (! flag_mri || repeat < 0)
		as_warn (".space repeat count is %s, ignored",
			 repeat ? "negative" : "zero");
d2926 1
a2926 1
			  repeat, (char *) 0);
d2932 1
a2932 1
	      as_bad ("space allocation too complex in absolute section");
d2937 1
a2937 1
	      as_bad ("space allocation too complex in common section");
d2942 1
a2942 1
			  make_expr_symbol (&exp), 0L, (char *) 0);
d2950 9
a2960 2

  demand_empty_rest_of_line ();
d2985 2
a2986 1
      as_bad ("missing value");
a2988 1
      ignore_rest_of_line ();
d2998 2
a2999 1
  if (input_line_pointer[0] == '0' && isalpha (input_line_pointer[1]))
d3009 1
a3011 1
	  ignore_rest_of_line ();
d3024 2
a3025 1
	  as_bad ("Bad floating literal: %s", err);
a3027 1
	  ignore_rest_of_line ();
d3040 2
a3043 2

  demand_empty_rest_of_line ();
d3050 1
a3050 1
     int ignore;
d3059 1
a3061 1
  demand_empty_rest_of_line ();
d3066 1
a3066 1
     int ignore;
d3099 2
a3100 2
      if (isprint (*input_line_pointer))
	as_bad ("Rest of line ignored. First ignored character is `%c'.",
d3103 1
a3103 1
	as_bad ("Rest of line ignored. First ignored character valued 0x%x.",
d3115 12
d3154 1
a3154 1
    as_bad ("illegal expression; zero assumed");
d3156 1
a3156 1
    as_bad ("missing expression; zero assumed");
d3158 6
a3163 2
    as_bad ("%s number invalid; zero assumed",
	    exp.X_add_number > 0 ? "bignum" : "floating point");
d3168 2
a3169 1
	   && exp.X_add_symbol->sy_frag == exp.X_op_symbol->sy_frag)
d3192 2
a3193 1
      symbolP->sy_frag = &zero_address_frag;
d3199 1
a3199 1
      symbolP->sy_frag = &zero_address_frag;
d3205 3
a3207 1
	symbolP->sy_value = exp;
d3221 1
a3221 1
	  symbolP->sy_frag = s->sy_frag;
d3229 1
a3229 1
      symbolP->sy_value = exp;
d3259 1
d3262 1
d3304 1
a3306 1
      demand_empty_rest_of_line ();
d3317 1
d3321 1
d3329 1
a3329 1
	    as_fatal ("rva without symbol");
d3344 2
a3347 2

  demand_empty_rest_of_line ();
a3364 1

d3381 67
d3454 1
a3454 1
	as_bad ("attempt to store value in absolute section");
d3462 2
a3463 2
      && exp->X_add_symbol->sy_value.X_op == O_big
      && exp->X_add_symbol->sy_value.X_add_number > 0)
d3468 1
a3468 1
      exp = &exp->X_add_symbol->sy_value;
d3492 1
a3492 1
      as_warn ("zero assumed for missing expression");
d3498 1
a3498 1
      as_bad ("floating point number invalid; zero assumed");
d3504 1
a3504 1
      as_warn ("register value used as expression");
d3520 2
d3561 1
d3567 7
a3573 1
	mask = 0;
d3575 5
a3579 1
	mask = ~(valueT) 0 << (BITS_PER_CHAR * nbytes);	/* Don't store these bits. */
d3590 3
a3592 1
      if ((get & mask) != 0 && (get & mask) != mask)
d3594 1
a3594 1
	  as_warn ("Value 0x%lx truncated to 0x%lx.",
d3602 1
a3602 1
      int size;
d3610 1
a3610 1
	  as_warn ("Bignum truncated to %d bytes", nbytes);
d3687 1
a3687 1
	    as_bad ("unsupported BFD relocation size %u", nbytes);
d3776 1
a3776 1
	      as_warn ("using a bit field width of zero");
d3784 1
a3784 1
	      as_bad ("field width \"%s\" too complex for a bitfield", hold);
d3792 1
a3792 1
	      as_warn ("field width %lu too big to fit in %d bytes: truncated to %d bits",
d3813 1
a3813 1
	      as_bad ("field value \"%s\" too complex for a bitfield", hold);
d3843 1
d3856 1
a3856 1
      int scan = 0;
d3866 1
a3866 1
	  as_bad ("EBCDIC constants are not supported");
d3906 1
d3937 1
a3937 1
      as_warn ("Unresolvable or nonpositive repeat count; using 1");
d3988 1
a3988 1
      as_bad ("Unknown floating type type '%c'", float_type);
d4010 1
a4010 1
	  as_warn ("Floating point constant too large");
d4090 2
a4091 1
      if (input_line_pointer[0] == '0' && isalpha (input_line_pointer[1]))
d4113 1
a4113 1
	      as_bad ("Bad floating literal: %s", err);
d4135 1
a4135 1
		  as_warn ("unresolvable or nonpositive repeat count; using 1");
d4156 300
d4459 1
a4459 1
 * We read 0 or more ',' seperated, double-quoted strings.
d4471 1
d4479 1
a4479 1
   * comma seperated. Recall a string expression includes spaces
d4501 1
d4511 21
d4539 1
a4539 1
	      as_bad ("Expected <nn>");
d4572 1
a4572 1
      as_warn ("Unterminated string: Newline inserted.");
d4655 1
a4655 1
	  as_warn ("Unterminated string: Newline inserted.");
d4663 1
a4663 1
	  as_bad ("Bad escaped character in string, '?' assumed");
d4689 1
a4689 1
      as_bad ("expected address expression; zero assumed");
d4709 1
a4709 1
	as_warn ("symbol \"%s\" undefined; zero assumed",
d4712 1
a4712 1
	as_warn ("some symbol undefined; zero assumed");
d4730 1
a4730 1
	as_bad ("bad or irreducible absolute expression; zero assumed");
d4768 1
a4768 1
	      as_bad ("This string may not contain \'\\0\'");
d4807 1
a4807 1
      as_warn ("Missing string");
d4832 1
a4832 1
equals (sym_name)
d4834 1
d4837 1
a4837 1
  char *stop;
d4863 5
d4872 4
a4875 1
    mri_comment_end (stop, stopc);
d4883 1
a4883 1
     int arg;
a4884 1
  char *newbuf;
d4891 9
a4899 1
    filename = demand_copy_string (&i);
d4934 2
a4935 2
  newbuf = input_scrub_include_file (path, input_line_pointer);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
d4963 2
d4966 135
d5103 1
a5103 1
     int arg;
d5118 32
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@a46 1
#include "libiberty.h"
d977 4
d2053 1
d2065 1
a2065 1
  err = define_macro (0, &s, &label, get_line_sb);
d2076 12
d2536 37
d3674 4
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d50 1
a209 1
int is_it_end_of_statement PARAMS ((void));
d1600 2
a1601 1
      as_warn ("Repeat < 0, .fill ignored");
d1845 5
d1886 1
a1886 1
#ifdef TC_ALPHA
d2941 4
d3142 2
a3143 1
	  as_warn ("Value 0x%lx truncated to 0x%lx.", get, use);
d3217 25
a3241 5
      fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp, 0,
		   /* @@@@ Should look at CPU word size.  */
		   nbytes == 2 ? BFD_RELOC_16
		      : nbytes == 8 ? BFD_RELOC_64
		      : BFD_RELOC_32);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1986, 1987, 1990, 1991, 1993, 1994
d205 1
a205 1
static void do_align PARAMS ((int, char *));
d249 2
d330 1
d337 3
d347 2
d366 1
d413 2
a414 1
	as_fatal ("error constructing %s pseudo-op table", pop_table_name);
d518 1
a518 1
	      if (flag_mri
d537 1
a537 1
		      if (flag_mri)
d607 1
a607 1
		  if (flag_mri)
d661 1
a661 5
#ifndef MRI_MODE_NEEDS_PSEUDO_DOT
#define MRI_MODE_NEEDS_PSEUDO_DOT 0
#endif

		  if ((flag_mri && ! MRI_MODE_NEEDS_PSEUDO_DOT)
d675 1
a675 2
		      || ((! flag_mri || MRI_MODE_NEEDS_PSEUDO_DOT)
			  && *s == '.'))
d698 1
a698 1
			  do_align (1, (char *) NULL);
d735 1
a735 1
			  do_align (1, (char *) NULL);
d749 1
a749 1
			  if (flag_mri && *input_line_pointer == '\'')
d948 5
d998 1
a998 1
  know (flag_mri);
d1050 1
a1050 1
do_align (n, fill)
d1053 1
d1056 1
a1056 1
  md_do_align (n, fill, just_record_alignment);
d1072 1
d1074 1
d1077 6
a1082 1
    frag_align (n, *fill);
d1107 6
a1112 1
    temp = arg;			/* Default value from pseudo-op table */
d1134 3
d1138 19
a1156 2
      temp_fill = get_absolute_expression ();
      do_align (temp, &temp_fill);
d1159 5
a1163 1
    do_align (temp, (char *) 0);
d1173 2
a1174 2
s_align_ptwo (ignore)
     int ignore;
d1195 3
d1199 19
a1217 2
      temp_fill = get_absolute_expression ();
      do_align (temp, &temp_fill);
d1220 5
a1224 1
    do_align (temp, (char *) 0);
d1461 8
d1571 3
d1694 77
d1824 5
d1928 4
d2010 3
d2025 2
a2026 5
      if (*input_line_pointer == '\n')
	{
	  bump_line_counters ();
	  LISTING_NEWLINE ();
	}
a2054 2
  demand_empty_rest_of_line ();

d2081 31
a2152 1
#ifdef TC_M68K
d2156 1
a2156 1
  if (flag_mri)
a2161 1
#endif
d2193 3
a2195 3
   will set *TYPE to the section type: one of '\0' (unspecified), 'C'
   (code), 'D' (data), 'M' (mixed), or 'R' (romable).  If
   BFD_ASSEMBLER is defined, the flags will be set in the section.  */
d2223 1
a2223 3
  name = strdup (name);
  if (name == NULL)
    as_fatal ("virtual memory exhausted");
d2238 1
a2238 1
  *type = '\0';
d2255 3
a2257 3
	  flags = SEC_CODE;
	else if (*type == 'D')
	  flags = SEC_DATA;
d2259 1
a2259 1
	  flags = SEC_ROM;
d2289 1
a2289 3
  name = strdup (name);
  if (name == NULL)
    as_fatal ("virtual memory exhausted");
d2502 1
a2502 1
  long temp_fill;
a2513 1
  /* Just like .fill, but temp_size = 1 */
d2515 8
a2522 1
  if (exp.X_op == O_constant)
d2524 3
a2526 1
      long repeat;
d2528 8
a2535 13
      repeat = exp.X_add_number;
      if (mult)
	repeat *= mult;
      if (repeat <= 0)
	{
	  if (! flag_mri || repeat < 0)
	    as_warn (".space repeat count is %s, ignored",
		     repeat ? "negative" : "zero");
	  goto getout;
	}

      /* If we are in the absolute section, just bump the offset.  */
      if (now_seg == absolute_section)
d2537 1
a2537 3
	  abs_section_offset += repeat;
	  goto getout;
	}
d2539 4
a2542 7
      /* If we are secretly in an MRI common section, then creating
         space just increases the size of the common symbol.  */
      if (mri_common_symbol != NULL)
	{
	  S_SET_VALUE (mri_common_symbol,
		       S_GET_VALUE (mri_common_symbol) + repeat);
	  goto getout;
a2543 4

      if (!need_pass_2)
	p = frag_var (rs_fill, 1, 1, (relax_substateT) 0, (symbolS *) 0,
		      repeat, (char *) 0);
d2547 1
a2547 1
      if (now_seg == absolute_section)
d2549 33
a2581 2
	  as_bad ("space allocation too complex in absolute section");
	  subseg_set (text_section, 0);
d2583 1
a2583 1
      if (mri_common_symbol != NULL)
d2585 13
a2597 2
	  as_bad ("space allocation too complex in common section");
	  mri_common_symbol = NULL;
d2599 3
a2601 17
      if (!need_pass_2)
	p = frag_var (rs_space, 1, 1, (relax_substateT) 0,
		      make_expr_symbol (&exp), 0L, (char *) 0);
    }
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
    }
  else
    {
      temp_fill = 0;
    }
  if (p)
    {
      *p = temp_fill;
d2929 2
a2930 1
      mri_comment_end (stop, stopc);
d2938 1
a2938 1
      if (flag_mri)
d3758 5
d3844 1
d3948 1
a3948 3
      for (len = *len_pointer;
	   len > 0;
	   len--)
d3959 1
a3959 1
  return (s);
d4069 1
a4069 1
  if (! flag_mri)
d4146 7
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 1996
d205 1
a205 1
static void do_align PARAMS ((int, char *, int));
a248 2
  {"balignw", s_align_bytes, -2},
  {"balignl", s_align_bytes, -4},
a327 1
  {"linkonce", s_linkonce, 0},
a333 3
  {"mri", s_mri, 0},
  {".mri", s_mri, 0},	/* Special case so .mri works in MRI mode.  */
  {"name", s_ignore, 0},
a340 2
  {"p2alignw", s_align_ptwo, -2},
  {"p2alignl", s_align_ptwo, -4},
a357 1
  {"skip", s_space, 0},
d404 1
a404 2
	as_fatal ("error constructing %s pseudo-op table: %s", pop_table_name,
		  errtxt);
d508 1
a508 1
	      if (flag_m68k_mri
d527 1
a527 1
		      if (flag_m68k_mri)
d597 1
a597 1
		  if (flag_m68k_mri)
d651 5
a655 1
		  if (flag_m68k_mri
d669 2
a670 1
		      || (! flag_m68k_mri && *s == '.'))
d693 1
a693 1
			  do_align (1, (char *) NULL, 0);
d730 1
a730 1
			  do_align (1, (char *) NULL, 0);
d744 1
a744 1
			  if (flag_m68k_mri && *input_line_pointer == '\'')
a942 5
#ifdef tc_unrecognized_line
	  if (tc_unrecognized_line (c))
	    continue;
#endif

d988 1
a988 1
  know (flag_m68k_mri);
d1040 1
a1040 1
do_align (n, fill, len)
a1042 1
     int len;
d1045 1
a1045 1
  md_do_align (n, fill, len, just_record_alignment);
a1060 1
      len = 1;
a1061 1

d1064 1
a1064 6
    {
      if (len <= 1)
	frag_align (n, *fill);
      else
	frag_align_pattern (n, fill, len);
    }
d1089 1
a1089 6
    {
      if (arg < 0)
	temp = 0;
      else
	temp = arg;	/* Default value from pseudo-op table */
    }
a1110 3
      offsetT fillval;
      int len;

d1112 2
a1113 19
      fillval = get_absolute_expression ();
      if (arg >= 0)
	len = 1;
      else
	len = - arg;
      if (len <= 1)
	{
	  temp_fill = fillval;
	  do_align (temp, &temp_fill, len);
	}
      else
	{
	  char ab[16];

	  if (len > sizeof ab)
	    abort ();
	  md_number_to_chars (ab, fillval, len);
	  do_align (temp, ab, len);
	}
d1116 1
a1116 5
    {
      if (arg < 0)
	as_warn ("expected fill pattern missing");
      do_align (temp, (char *) NULL, 0);
    }
d1126 2
a1127 2
s_align_ptwo (arg)
     int arg;
a1147 3
      offsetT fillval;
      int len;

d1149 2
a1150 19
      fillval = get_absolute_expression ();
      if (arg >= 0)
	len = 1;
      else
	len = - arg;
      if (len <= 1)
	{
	  temp_fill = fillval;
	  do_align (temp, &temp_fill, len);
	}
      else
	{
	  char ab[16];

	  if (len > sizeof ab)
	    abort ();
	  md_number_to_chars (ab, fillval, len);
	  do_align (temp, ab, len);
	}
d1153 1
a1153 5
    {
      if (arg < 0)
	as_warn ("expected fill pattern missing");
      do_align (temp, (char *) NULL, 0);
    }
a1389 8

      /* In MRI mode, the preprocessor may have inserted an extraneous
         backquote.  */
      if (flag_m68k_mri
	  && *input_line_pointer == '\''
	  && is_end_of_line[(unsigned char) input_line_pointer[1]])
	++input_line_pointer;

a1491 3
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
a1611 77
/* Handle the .linkonce pseudo-op.  This tells the assembler to mark
   the section to only be linked once.  However, this is not supported
   by most object file formats.  This takes an optional argument,
   which is what to do about duplicates.  */

void
s_linkonce (ignore)
     int ignore;
{
  enum linkonce_type type;

  SKIP_WHITESPACE ();

  type = LINKONCE_DISCARD;

  if (! is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *s;
      char c;

      s = input_line_pointer;
      c = get_symbol_end ();
      if (strcasecmp (s, "discard") == 0)
	type = LINKONCE_DISCARD;
      else if (strcasecmp (s, "one_only") == 0)
	type = LINKONCE_ONE_ONLY;
      else if (strcasecmp (s, "same_size") == 0)
	type = LINKONCE_SAME_SIZE;
      else if (strcasecmp (s, "same_contents") == 0)
	type = LINKONCE_SAME_CONTENTS;
      else
	as_warn ("unrecognized .linkonce type `%s'", s);

      *input_line_pointer = c;
    }

#ifdef obj_handle_link_once
  obj_handle_link_once (type);
#else /* ! defined (obj_handle_link_once) */
#ifdef BFD_ASSEMBLER
  {
    flagword flags;

    if ((bfd_applicable_section_flags (stdoutput) & SEC_LINK_ONCE) == 0)
      as_warn (".linkonce is not supported for this object file format");

    flags = bfd_get_section_flags (stdoutput, now_seg);
    flags |= SEC_LINK_ONCE;
    switch (type)
      {
      default:
	abort ();
      case LINKONCE_DISCARD:
	flags |= SEC_LINK_DUPLICATES_DISCARD;
	break;
      case LINKONCE_ONE_ONLY:
	flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
	break;
      case LINKONCE_SAME_SIZE:
	flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
	break;
      case LINKONCE_SAME_CONTENTS:
	flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
	break;
      }
    if (! bfd_set_section_flags (stdoutput, now_seg, flags))
      as_bad ("bfd_set_section_flags: %s",
	      bfd_errmsg (bfd_get_error ()));
  }
#else /* ! defined (BFD_ASSEMBLER) */
  as_warn (".linkonce is not supported for this object file format");
#endif /* ! defined (BFD_ASSEMBLER) */
#endif /* ! defined (obj_handle_link_once) */

  demand_empty_rest_of_line ();
}

a1664 5
#ifdef BFD_ASSEMBLER
	  if (! bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
	    as_warn ("error setting flags for \".sbss\": %s",
		     bfd_errmsg (bfd_get_error ()));
#endif
a1763 4

#ifdef S_SET_SIZE
      S_SET_SIZE (symbolP, temp);
#endif
a1841 3
  if (input_line_pointer[-1] == '\n')
    bump_line_counters ();

d1854 5
a1858 2
      if (input_line_pointer[-1] == '\n')
	bump_line_counters ();
d1887 2
a1914 31
/* Switch in and out of MRI mode.  */

void
s_mri (ignore)
     int ignore;
{
  int on, old_flag;

  on = get_absolute_expression ();
  old_flag = flag_mri;
  if (on != 0)
    {
      flag_mri = 1;
#ifdef TC_M68K
      flag_m68k_mri = 1;
#endif
    }
  else
    {
      flag_mri = 0;
      flag_m68k_mri = 0;
    }

#ifdef MRI_MODE_CHANGE
  if (on != old_flag)
    MRI_MODE_CHANGE (on);
#endif

  demand_empty_rest_of_line ();
}

d1956 1
d1960 1
a1960 1
  if (flag_m68k_mri)
d1966 1
d1998 3
a2000 3
   will set *TYPE to the section type: one of 'C' (code), 'D' (data),
   'M' (mixed), or 'R' (romable).  If BFD_ASSEMBLER is defined, the
   flags will be set in the section.  */
d2028 3
a2030 1
  name = xstrdup (name);
d2045 1
a2045 1
  *type = 'C';
d2062 3
a2064 3
	  flags = SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE;
	else if (*type == 'D' || *type == 'M')
	  flags = SEC_ALLOC | SEC_LOAD | SEC_DATA;
d2066 1
a2066 1
	  flags = SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_READONLY | SEC_ROM;
d2096 3
a2098 1
  name = xstrdup (name);
d2311 1
a2311 1
  expressionS val;
d2323 1
d2325 3
d2329 10
a2338 11
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      expression (&val);
    }
  else
    {
      val.X_op = O_constant;
      val.X_add_number = 0;
    }
d2340 2
a2341 8
  if (val.X_op != O_constant
      || val.X_add_number < - 0x80
      || val.X_add_number > 0xff
      || (mult != 0 && mult != 1 && val.X_add_number != 0))
    {
      if (exp.X_op != O_constant)
	as_bad ("Unsupported variable size or fill value");
      else
d2343 3
a2345 1
	  offsetT i;
d2347 7
a2353 4
	  if (mult == 0)
	    mult = 1;
	  for (i = 0; i < exp.X_add_number; i++)
	    emit_expr (&val, mult);
d2355 4
d2362 1
a2362 1
      if (exp.X_op == O_constant)
d2364 2
a2365 33
	  long repeat;

	  repeat = exp.X_add_number;
	  if (mult)
	    repeat *= mult;
	  if (repeat <= 0)
	    {
	      if (! flag_mri || repeat < 0)
		as_warn (".space repeat count is %s, ignored",
			 repeat ? "negative" : "zero");
	      goto getout;
	    }

	  /* If we are in the absolute section, just bump the offset.  */
	  if (now_seg == absolute_section)
	    {
	      abs_section_offset += repeat;
	      goto getout;
	    }

	  /* If we are secretly in an MRI common section, then
	     creating space just increases the size of the common
	     symbol.  */
	  if (mri_common_symbol != NULL)
	    {
	      S_SET_VALUE (mri_common_symbol,
			   S_GET_VALUE (mri_common_symbol) + repeat);
	      goto getout;
	    }

	  if (!need_pass_2)
	    p = frag_var (rs_fill, 1, 1, (relax_substateT) 0, (symbolS *) 0,
			  repeat, (char *) 0);
d2367 1
a2367 1
      else
d2369 2
a2370 13
	  if (now_seg == absolute_section)
	    {
	      as_bad ("space allocation too complex in absolute section");
	      subseg_set (text_section, 0);
	    }
	  if (mri_common_symbol != NULL)
	    {
	      as_bad ("space allocation too complex in common section");
	      mri_common_symbol = NULL;
	    }
	  if (!need_pass_2)
	    p = frag_var (rs_space, 1, 1, (relax_substateT) 0,
			  make_expr_symbol (&exp), 0L, (char *) 0);
d2372 17
a2388 3

      if (p)
	*p = val.X_add_number;
d2716 1
a2716 2
      if (flag_mri)
	mri_comment_end (stop, stopc);
d2724 1
a2724 1
      if (flag_m68k_mri)
a3543 5
    case '\n':
      as_warn ("Unterminated string: Newline inserted.");
      bump_line_counters ();
      break;

a3624 1
	  bump_line_counters ();
d3728 3
a3730 1
      for (len = *len_pointer; len > 0; len--)
d3741 1
a3741 1
  return s;
d3851 1
a3851 1
  if (! flag_m68k_mri)
a3927 7

void
read_print_statistics (file)
     FILE *file;
{
  hash_print_statistics (file, "pseudo-op table", po_hash);
}
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a49 1
#include "ecoff.h"
d209 1
d1600 1
a1600 2
      if (temp_repeat < 0)
	as_warn ("Repeat < 0, .fill ignored");
a1843 5
#ifdef OBJ_EVAX
       /* FIXME: This needs to be done in a more general fashion.  */
       align = 3;
#endif

d1880 1
a1880 1
#if defined (TC_ALPHA) && ! defined (VMS)
a2934 4
#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

d3132 1
a3132 2
	  as_warn ("Value 0x%lx truncated to 0x%lx.",
		   (unsigned long) get, (unsigned long) use);
d3206 5
a3210 25
      {
	bfd_reloc_code_real_type r;

	switch (nbytes)
	  {
	  case 1:
	    r = BFD_RELOC_8;
	    break;
	  case 2:
	    r = BFD_RELOC_16;
	    break;
	  case 4:
	    r = BFD_RELOC_32;
	    break;
	  case 8:
	    r = BFD_RELOC_64;
	    break;
	  default:
	    as_bad ("unsupported BFD relocation size %u", nbytes);
	    r = BFD_RELOC_32;
	    break;
	  }
	fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp,
		     0, r);
      }
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d47 1
a977 4

#ifdef md_cleanup
  md_cleanup();
#endif
a2049 1
  const char *name;
d2061 1
a2061 1
  err = define_macro (0, &s, &label, get_line_sb, &name);
a2071 12

      if (((flag_m68k_mri
#ifdef NO_PSEUDO_DOT
	    || 1
#endif
	    )
	   && hash_find (po_hash, name) != NULL)
	  || (! flag_m68k_mri
	      && *name == '.'
	      && hash_find (po_hash, name + 1) != NULL))
	as_warn ("attempt to redefine pseudo-op `%s' ignored",
		 name);
a2519 37
  /* In m68k MRI mode, we need to align to a word boundary, unless
     this is ds.b.  */
  if (flag_m68k_mri && mult > 1)
    {
      if (now_seg == absolute_section)
	{
	  abs_section_offset += abs_section_offset & 1;
	  if (line_label != NULL)
	    S_SET_VALUE (line_label, abs_section_offset);
	}
      else if (mri_common_symbol != NULL)
	{
	  valueT val;

	  val = S_GET_VALUE (mri_common_symbol);
	  if ((val & 1) != 0)
	    {
	      S_SET_VALUE (mri_common_symbol, val + 1);
	      if (line_label != NULL)
		{
		  know (line_label->sy_value.X_op == O_symbol);
		  know (line_label->sy_value.X_add_symbol == mri_common_symbol);
		  line_label->sy_value.X_add_number += 1;
		}
	    }
	}
      else
	{
	  do_align (1, (char *) NULL, 0);
	  if (line_label != NULL)
	    {
	      line_label->sy_frag = frag_now;
	      S_SET_VALUE (line_label, frag_now_fix ());
	    }
	}
    }

a3620 4

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 1997
d18 2
a19 3
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA. */
a97 5
#ifndef LEX_TILDE
/* The Delta 68k assembler permits ~ at start of label names.  */
#define LEX_TILDE 0
#endif

d108 1
a108 1
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, LEX_TILDE, 0, /* pqrstuvwxyz{|}~. */
d156 7
a162 2
/* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1 in the
   tc-<CPU>.h file.  See the "Porting GAS" section of the internals manual. */
d164 3
a203 1
static void cons_worker PARAMS ((int, int));
d205 1
a205 2
static void do_align PARAMS ((int, char *, int, int));
static void s_align PARAMS ((int, int));
a292 1
  {"equiv", s_set, 1},
a528 1
		      int mri_line_macro;
a529 1
		      LISTING_NEWLINE ();
d534 2
a535 3
		      /* In MRI mode, the EQU and MACRO pseudoops must
			 be handled specially.  */
		      mri_line_macro = 0;
d549 1
a549 2
			      equals (line_start,
				      strncasecmp (rest, "SET", 3) == 0);
a551 5
			  if (strncasecmp (rest, "MACRO", 5) == 0
			      && (rest[5] == ' '
				  || rest[5] == '\t'
				  || is_end_of_line[(unsigned char) rest[5]]))
			    mri_line_macro = 1;
d554 1
a554 10
		      /* In MRI mode, we need to handle the MACRO
                         pseudo-op specially: we don't want to put the
                         symbol in the symbol table.  */
		      if (! mri_line_macro)
			line_label = colon (line_start);
		      else
			line_label = symbol_create (line_start,
						    absolute_section,
						    (valueT) 0,
						    &zero_address_frag);
d621 1
a621 1
			  equals (s, 1);
d634 1
a634 2
		       || ((c == ' ' || c == '\t')
			   && input_line_pointer[1] == '='
d640 1
a640 1
		  equals (s, 1);
d695 1
a695 12
					&& pop->poc_val == 1)
#ifdef tc_conditional_pseudoop
				    || tc_conditional_pseudoop (pop)
#endif
				    || pop->poc_handler == s_if
				    || pop->poc_handler == s_ifdef
				    || pop->poc_handler == s_ifc
				    || pop->poc_handler == s_ifeqs
				    || pop->poc_handler == s_else
				    || pop->poc_handler == s_endif
				    || pop->poc_handler == s_globl
				    || pop->poc_handler == s_ignore)))
d697 1
a697 1
			  do_align (1, (char *) NULL, 0, 0);
a698 5
			  if (line_label != NULL)
			    {
			      line_label->sy_frag = frag_now;
			      S_SET_VALUE (line_label, frag_now_fix ());
			    }
d729 1
a729 1
		    {
d732 6
a790 11
		      if (mri_pending_align)
			{
			  do_align (1, (char *) NULL, 0, 0);
			  mri_pending_align = 0;
			  if (line_label != NULL)
			    {
			      line_label->sy_frag = frag_now;
			      S_SET_VALUE (line_label, frag_now_fix ());
			    }
			}

d1051 1
a1051 6
/* Guts of .align directive.  N is the power of two to which to align.
   FILL may be NULL, or it may point to the bytes of the fill pattern.
   LEN is the length of whatever FILL points to, if anything.  MAX is
   the maximum number of characters to skip when doing the alignment,
   or 0 if there is no maximum.  */

d1053 1
a1053 1
do_align (n, fill, len, max)
a1056 1
     int max;
a1057 2
  char default_fill;

d1059 1
a1059 1
  md_do_align (n, fill, len, max, just_record_alignment);
d1061 5
a1066 3
  if (fill == NULL)
    {
      /* FIXME: Fix this right for BFD!  */
d1068 3
a1070 1
	default_fill = NOP_OPCODE;
d1072 3
a1074 2
	default_fill = 0;
      fill = &default_fill;
d1079 1
a1079 1
  if (n != 0 && !need_pass_2)
d1082 1
a1082 1
	frag_align (n, *fill, max);
d1084 1
a1084 1
	frag_align_pattern (n, fill, len, max);
d1094 3
a1096 7
/* Handle the .align pseudo-op.  A positive ARG is a default alignment
   (in bytes).  A negative ARG is the negative of the length of the
   fill pattern.  BYTES_P is non-zero if the alignment value should be
   interpreted as the byte boundary, rather than the power of 2.  */

static void
s_align (arg, bytes_p)
a1097 1
     int bytes_p;
d1099 4
a1102 1
  register unsigned int align;
a1104 3
  offsetT fill = 0;
  int max;
  int fill_p;
d1112 1
a1112 1
	align = 0;
d1114 1
a1114 1
	align = arg;	/* Default value from pseudo-op table */
d1117 3
d1121 1
a1121 2
      align = get_absolute_expression ();
      SKIP_WHITESPACE ();
d1124 3
a1126 1
  if (bytes_p)
d1128 2
a1129 11
      /* Convert to a power of 2.  */
      if (align != 0)
	{
	  unsigned int i;

	  for (i = 0; (align & 1) == 0; align >>= 1, ++i)
	    ;
	  if (align != 1)
	    as_bad ("Alignment not a power of 2");
	  align = i;
	}
d1131 2
d1134 2
a1135 1
  if (align > 15)
d1137 2
a1138 3
      align = 15;
      as_bad ("Alignment too large: %u assumed", align);
    }
d1140 4
a1143 10
  if (*input_line_pointer != ',')
    {
      fill_p = 0;
      max = 0;
    }
  else
    {
      ++input_line_pointer;
      if (*input_line_pointer == ',')
	fill_p = 0;
d1145 2
d1148 2
a1149 3
	  fill = get_absolute_expression ();
	  SKIP_WHITESPACE ();
	  fill_p = 1;
a1150 3

      if (*input_line_pointer != ',')
	max = 0;
d1153 6
a1158 2
	  ++input_line_pointer;
	  max = get_absolute_expression ();
d1161 1
a1161 2

  if (! fill_p)
d1165 1
a1165 1
      do_align (align, (char *) NULL, 0, max);
d1167 30
a1196 1
  else
d1198 2
a1199 1
      int fill_len;
d1201 2
d1204 1
a1204 1
	fill_len = 1;
d1206 2
a1207 2
	fill_len = - arg;
      if (fill_len <= 1)
d1209 2
a1210 4
	  char fill_char;

	  fill_char = fill;
	  do_align (align, &fill_char, fill_len, max);
d1216 1
a1216 1
	  if (fill_len > sizeof ab)
d1218 2
a1219 2
	  md_number_to_chars (ab, fill, fill_len);
	  do_align (align, ab, fill_len, max);
d1222 6
a1234 20
/* Handle the .align pseudo-op on machines where ".align 4" means
   align to a 4 byte boundary.  */

void 
s_align_bytes (arg)
     int arg;
{
  s_align (arg, 1);
}

/* Handle the .align pseud-op on machines where ".align 4" means align
   to a 2**4 boundary.  */

void 
s_align_ptwo (arg)
     int arg;
{
  s_align (arg, 0);
}

d1276 1
a1276 1
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d1375 1
a1375 1
  if (S_IS_DEFINED (sym) && ! S_IS_COMMON (sym))
d1377 9
a1385 4
      as_bad ("attempt to re-define symbol `%s'", S_GET_NAME (sym));
      mri_comment_end (stop, stopc);
      ignore_rest_of_line ();
      return;
d1610 1
a1610 3
      p = frag_var (rs_fill, (int) temp_size, (int) temp_size,
		    (relax_substateT) 0, (symbolS *) 0, (offsetT) temp_repeat,
		    (char *) 0);
d1916 1
a1916 1
	frag_align (align, 0, 0);
d1923 1
a1923 1
			(offsetT) temp, (char *) 0);
a2018 2
  char quote1, quote2, inquote;

d2029 4
a2032 30
  /* If app.c sets any other characters to LEX_IS_STRINGQUOTE, this
     code needs to be changed.  */
  if (! flag_m68k_mri)
    quote1 = '"';
  else
    quote1 = '\0';

  quote2 = '\0';
  if (flag_m68k_mri)
    quote2 = '\'';
#ifdef LEX_IS_STRINGQUOTE
  quote2 = '\'';
#endif

  inquote = '\0';
  while (! is_end_of_line[(unsigned char) *input_line_pointer]
	 || (inquote != '\0' && *input_line_pointer != '\n'))
    {
      if (inquote == *input_line_pointer)
	inquote = '\0';
      else if (inquote == '\0')
	{
	  if (*input_line_pointer == quote1)
	    inquote = quote1;
	  else if (*input_line_pointer == quote2)
	    inquote = quote2;
	}
      sb_add_char (line, *input_line_pointer++);
    }
  while (input_line_pointer < buffer_limit && *input_line_pointer == '\n')
a2099 1
  cond_exit_macro (macro_nest);
a2453 4
/* Handle the .equ, .equiv and .set directives.  If EQUIV is 1, then
   this is .equiv, and it is an error if the symbol is already
   defined.  */

d2455 2
a2456 2
s_set (equiv)
     int equiv;
a2514 6

  if (equiv
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad ("symbol `%s' already defined", S_GET_NAME (symbolP));

a2527 1
  int bytes;
d2564 1
a2564 1
	  do_align (1, (char *) NULL, 0, 0);
a2572 2
  bytes = mult;

a2599 1
	  bytes = mult * exp.X_add_number;
a2612 1
	  bytes = repeat;
d2640 1
a2640 1
			  (offsetT) repeat, (char *) 0);
d2656 1
a2656 1
			  make_expr_symbol (&exp), (offsetT) 0, (char *) 0);
a2663 7

  /* In MRI mode, after an odd number of bytes, we must align to an
     even word boundary, unless the next instruction is a dc.b, ds.b
     or dcb.b.  */
  if (flag_mri && (bytes & 1) != 0)
    mri_pending_align = 1;

a3174 1
      valueT hibit;
d3180 1
a3180 7
	{
	  mask = 0;
	  if (nbytes > sizeof (valueT))
	    hibit = 0;
	  else
	    hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
	}
d3182 1
a3182 5
	{
	  /* Don't store these bits. */
	  mask = ~(valueT) 0 << (BITS_PER_CHAR * nbytes);
	  hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
	}
d3193 1
a3193 3
      if ((get & mask) != 0
	  && ((get & mask) != mask
	      || (get & hibit) == 0))
d4107 1
a4107 1
equals (sym_name, reassign)
a4108 1
     int reassign;
a4136 5
      /* Permit register names to be redefined.  */
      if (! reassign
	  && S_IS_DEFINED (symbolP)
	  && S_GET_SEGMENT (symbolP) != reg_section)
	as_bad ("symbol `%s' already defined", S_GET_NAME (symbolP));
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 2
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
   2000 Free Software Foundation, Inc.
a55 15
/* Set by the object-format or the target.  */
#ifndef TC_IMPLICIT_LCOMM_ALIGNMENT
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)        \
 do {                                                   \
  if ((SIZE) >= 8)                                      \
    (P2VAR) = 3;                                        \
  else if ((SIZE) >= 4)                                 \
    (P2VAR) = 2;                                        \
  else if ((SIZE) >= 2)                                 \
    (P2VAR) = 1;                                        \
  else                                                  \
    (P2VAR) = 0;                                        \
 } while (0)
#endif

d66 2
a93 4
#ifndef LEX_HASH
#define LEX_HASH 0
#endif

d109 1
a109 1
  0, 0, 0, LEX_HASH, LEX_DOLLAR, LEX_PCT, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, /* _!"#$%&'()*+,-./ */
d115 7
a121 8
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
d129 1
a129 1
#define Z_ (0)
d133 1
a133 1
  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, 99, Z_, Z_,	/* @@abcdefghijklmno */
d135 1
a135 1
  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_, Z_,	/* @@abcdefghijklmno */
d137 1
a137 1
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
d139 2
a140 2
  Z_,99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* _!"#$%&'()*+,-./ */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* 0123456789:;<=>? */
d142 2
a143 2
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_,	/* 0123456789:;<=>? */
d145 9
a153 9
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
d155 1
a155 1
#undef Z_
d170 1
a170 1
/* Variables for handling include file directory table. */
d172 1
a172 1
char **include_dirs;	/* Table of pointers to directories to
d174 2
a175 2
int include_dir_count;	/* How many are in the table */
int include_dir_maxlen = 1;/* Length of longest in table */
a201 9
#ifndef NO_LISTING
#ifdef OBJ_ELF
/* This variable is set to be non-zero if the next string we see might
   be the name of the source file in DWARF debugging information.  See
   the comment in emit_expr for the format we look for.  */
static int dwarf_file_string;
#endif
#endif

d203 1
a203 1
static int scrub_from_string PARAMS ((char *, int));
a205 1
static void s_lcomm_internal PARAMS ((int, int));
a206 7
static inline int sizeof_sleb128 PARAMS ((offsetT));
static inline int sizeof_uleb128 PARAMS ((valueT));
static inline int output_sleb128 PARAMS ((char *, offsetT));
static inline int output_uleb128 PARAMS ((char *, valueT));
static inline int output_big_sleb128 PARAMS ((char *, LITTLENUM_TYPE *, int));
static inline int output_big_uleb128 PARAMS ((char *, LITTLENUM_TYPE *, int));
static int output_big_leb128 PARAMS ((char *, LITTLENUM_TYPE *, int, int));
a212 1
static void generate_file_debug PARAMS ((void));
a287 1
  {"elseif", s_elseif, (int) O_ne},
a289 1
  {"endfunc", s_func, 1},
a304 1
  {"func", s_func, 0},
a366 1
  {"sleb128", s_leb128, 1},
a388 1
  {"uleb128", s_leb128, 0},
d397 1
a397 1
  {NULL, NULL, 0}			/* end sentinel */
d413 1
a413 1
	as_fatal (_("error constructing %s pseudo-op table: %s"), pop_table_name,
d462 9
a470 12
scrub_from_string (buf, buflen)
     char *buf;
     int buflen;
{
  int copy;

  copy = scrub_string_end - scrub_string;
  if (copy > buflen)
    copy = buflen;
  memcpy (buf, scrub_string, copy);
  scrub_string += copy;
  return copy;
d490 1
a490 7
  listing_newline (NULL);
  register_dependency (name);

  /* Generate debugging information before we've read anything in to denote
     this file as the "main" source file and not a subordinate one
     (e.g. N_SO vs N_SOL in stabs).  */
  generate_file_debug ();
d518 5
a522 1
	      if (LABELS_WITHOUT_COLONS || flag_m68k_mri)
d567 1
a567 6
		      if (! mri_line_macro 
#ifdef TC_START_LABEL_WITHOUT_COLON
                          && TC_START_LABEL_WITHOUT_COLON(c, 
                                                          input_line_pointer)
#endif
                          )
d604 1
a604 33

#ifndef NO_LISTING
	  /* If listing is on, and we are expanding a macro, then give
	     the listing code the contents of the expanded line.  */
	  if (listing)
	    {
	      if ((listing & LISTING_MACEXP) && macro_nest > 0)
		{
		  char *copy;
		  int len;

		  /* Find the end of the current expanded macro line.  */
		  for (s = input_line_pointer-1; *s ; ++s)
		    if (is_end_of_line[(unsigned char) *s])
		      break;

		  /* Copy it for safe keeping.  Also give an indication of
		     how much macro nesting is involved at this point.  */
		  len = s - (input_line_pointer-1);
		  copy = (char *) xmalloc (len + macro_nest + 2);
		  memset (copy, '>', macro_nest);
		  copy[macro_nest] = ' ';
		  memcpy (copy + macro_nest + 1, input_line_pointer-1, len);
		  copy[macro_nest+1+len] = '\0';

		  /* Install the line with the listing facility.  */
		  listing_newline (copy);
		}
	      else
		listing_newline (NULL);
	    }
#endif

d673 1
a673 1
			if (isupper ((unsigned char) *s2))
d680 5
a684 1
		  if (NO_PSEUDO_DOT || flag_m68k_mri)
d732 1
a732 1
			      symbol_set_frag (line_label, frag_now);
d740 1
a740 1
			  as_bad (_("Unknown pseudo-op:  `%s'"), s);
a766 3
#ifdef QUOTES_IN_INSN
		      int inescape = 0;
#endif
a779 8
#ifdef QUOTES_IN_INSN
			  if (inescape)
			    inescape = 0;
			  else if (*input_line_pointer == '"')
			    inquote = ! inquote;
			  else if (*input_line_pointer == '\\')
			    inescape = 1;
#endif
d786 15
a800 1
		      generate_lineno_debug ();
a805 1
                          macro_entry *macro;
d807 1
a807 1
			  if (check_macro (s, &out, '\0', &err, &macro))
d810 1
a810 1
				as_bad ("%s", err);
d813 1
a813 1
						      input_line_pointer, 1);
a816 3
#ifdef md_macro_info
                              md_macro_info (macro);
#endif
d827 1
a827 1
			      symbol_set_frag (line_label, frag_now);
d849 1
a849 1
	      && isdigit ((unsigned char) c))
d858 1
a858 1
	      while (isdigit ((unsigned char) *input_line_pointer))
d872 1
a872 1
		      as_fatal (_("label \"%d$\" redefined"), temp);
d1087 1
a1087 1
     int ignore ATTRIBUTE_UNUSED;
d1089 1
a1089 1
  as_fatal (_(".abort detected.  Abandoning ship."));
d1113 2
a1114 1
      if (subseg_text_p (now_seg))
d1135 1
a1135 1
  record_alignment (now_seg, n - OCTETS_PER_BYTE_POWER);
d1181 1
a1181 1
	    as_bad (_("Alignment not a power of 2"));
d1189 1
a1189 1
      as_bad (_("Alignment too large: %u assumed"), align);
d1221 1
a1221 1
	as_warn (_("expected fill pattern missing"));
d1243 1
a1243 1
	  if ((size_t) fill_len > sizeof ab)
a1249 2
  demand_empty_rest_of_line ();

d1252 2
d1266 1
a1266 1
/* Handle the .align pseudo-op on machines where ".align 4" means align
d1278 1
a1278 1
     int ignore ATTRIBUTE_UNUSED;
d1299 1
a1299 2
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
      ignore_rest_of_line ();
d1302 1
d1308 1
a1308 2
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
      ignore_rest_of_line ();
d1311 1
d1319 1
a1319 1
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
a1320 1
      ignore_rest_of_line ();
d1323 1
d1329 1
a1329 1
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
a1347 2
  demand_empty_rest_of_line ();

d1350 2
d1360 1
a1360 1
     int small ATTRIBUTE_UNUSED;
d1418 2
a1419 1
      as_bad (_("attempt to re-define symbol `%s'"), S_GET_NAME (sym));
a1420 1
      mri_comment_end (stop, stopc);
d1434 4
a1437 6
      expressionS exp;
      exp.X_op = O_symbol;
      exp.X_add_symbol = sym;
      exp.X_add_number = 0;
      symbol_set_value_expression (line_label, &exp);
      symbol_set_frag (line_label, &zero_address_frag);
d1450 2
a1452 2

  mri_comment_end (stop, stopc);
d1457 1
a1457 1
     int ignore ATTRIBUTE_UNUSED;
d1499 1
a1499 2
      int may_omit
	= (! new_logical_line (s, appfile ? -2 : -1) && appfile);
a1508 2
      if (! may_omit)
	{
d1510 2
a1511 2
	  if (listing)
	    listing_source_file (s);
d1513 1
a1513 1
	  register_dependency (s);
d1515 1
a1515 1
	  obj_app_file (s);
a1516 2
	}
    }
d1526 1
a1526 1
     int ignore ATTRIBUTE_UNUSED;
d1535 1
a1535 1
    as_warn (_("Line numbers must be positive; line number %d rejected."), l+1);
d1552 1
a1552 1
     int ignore ATTRIBUTE_UNUSED;
d1562 1
a1562 1
	as_warn (_("start address not supported"));
d1570 1
a1570 1
     int ignore ATTRIBUTE_UNUSED;
d1572 1
a1572 1
  as_bad (_(".err encountered"));
d1580 1
a1580 1
     int ignore ATTRIBUTE_UNUSED;
d1591 1
a1591 1
    as_warn (_(".fail %ld encountered"), (long) temp);
d1593 1
a1593 3
    as_bad (_(".fail %ld encountered"), (long) temp);

  demand_empty_rest_of_line ();
d1597 2
d1603 1
a1603 1
     int ignore ATTRIBUTE_UNUSED;
d1605 3
a1607 3
  expressionS rep_exp;
  long size = 1;
  register long fill = 0;
d1614 1
a1614 1
  get_known_segmented_expression (&rep_exp);
d1618 1
a1618 1
      size = get_absolute_expression ();
d1622 1
a1622 1
	  fill = get_absolute_expression ();
a1624 1

d1627 1
a1627 1
  if (size > BSD_FILL_SIZE_CROCK_8)
d1629 2
a1630 2
      as_warn (_(".fill size clamped to %d."), BSD_FILL_SIZE_CROCK_8);
      size = BSD_FILL_SIZE_CROCK_8;
d1632 1
a1632 1
  if (size < 0)
d1634 2
a1635 2
      as_warn (_("Size negative: .fill ignored."));
      size = 0;
d1637 1
a1637 1
  else if (rep_exp.X_op == O_constant && rep_exp.X_add_number <= 0)
d1639 3
a1641 3
      if (rep_exp.X_add_number < 0)
	as_warn (_("Repeat < 0, .fill ignored"));
      size = 0;
d1644 1
a1644 1
  if (size && !need_pass_2)
d1646 4
a1649 33
      if (rep_exp.X_op == O_constant)
	{
	  p = frag_var (rs_fill, (int) size, (int) size,
			(relax_substateT) 0, (symbolS *) 0,
			(offsetT) rep_exp.X_add_number,
			(char *) 0);
	}
      else
	{
	  /* We don't have a constant repeat count, so we can't use
	     rs_fill.  We can get the same results out of rs_space,
	     but its argument is in bytes, so we must multiply the
	     repeat count by size.  */

	  symbolS *rep_sym;
	  rep_sym = make_expr_symbol (&rep_exp);
	  if (size != 1)
	    {
	      expressionS size_exp;
	      size_exp.X_op = O_constant;
	      size_exp.X_add_number = size;

	      rep_exp.X_op = O_multiply;
	      rep_exp.X_add_symbol = rep_sym;
	      rep_exp.X_op_symbol = make_expr_symbol (&size_exp);
	      rep_exp.X_add_number = 0;
	      rep_sym = make_expr_symbol (&rep_exp);
	    }

	  p = frag_var (rs_space, (int) size, (int) size,
			(relax_substateT) 0, rep_sym, (offsetT) 0, (char *) 0);
	}
      memset (p, 0, (unsigned int) size);
d1656 2
a1657 2
      md_number_to_chars (p, (valueT) fill,
			  (size > BSD_FILL_SIZE_CROCK_4
d1659 1
a1659 1
			   : (int) size));
d1670 1
a1670 1
     int ignore ATTRIBUTE_UNUSED;
a1685 2
      S_SET_EXTERNAL (symbolP);

d1688 1
a1688 1
      c = *input_line_pointer;
a1698 2
  demand_empty_rest_of_line ();

d1701 2
d1731 1
a1731 1
  input_scrub_include_sb (&out, input_line_pointer, 1);
d1743 1
a1743 1
     int ignore ATTRIBUTE_UNUSED;
d1767 1
a1767 1
	as_warn (_("unrecognized .linkonce type `%s'"), s);
d1780 1
a1780 1
      as_warn (_(".linkonce is not supported for this object file format"));
d1802 1
a1802 1
      as_bad (_("bfd_set_section_flags: %s"),
d1806 1
a1806 1
  as_warn (_(".linkonce is not supported for this object file format"));
d1813 2
a1814 2
static void 
s_lcomm_internal (needs_align, bytes_p)
a1817 3
     /* 1 if the alignment value should be interpreted as the byte boundary,
	rather than the power of 2. */
     int bytes_p;
d1846 1
a1846 1
      as_bad (_("Missing size expression"));
d1852 1
a1852 1
      as_warn (_("BSS length (%d.) <0! Ignored."), temp);
d1868 1
a1868 1
	    as_warn (_("error setting flags for \".sbss\": %s"),
a1873 1

d1876 14
a1889 1
       TC_IMPLICIT_LCOMM_ALIGNMENT (temp, align);
d1891 1
a1891 3
       /* Still zero unless TC_IMPLICIT_LCOMM_ALIGNMENT set it.  */
       if (align)
         record_alignment(bss_seg, align);
d1900 1
a1900 1
	  as_bad (_("Expected comma after size"));
d1908 1
a1908 1
	  as_bad (_("Missing alignment"));
a1911 14
      if (bytes_p)
	{
	  /* Convert to a power of 2.  */
	  if (align != 0)
	    {
	      unsigned int i;

	      for (i = 0; (align & 1) == 0; align >>= 1, ++i)
		;
	      if (align != 1)
		as_bad (_("Alignment not a power of 2"));
	      align = i;
	    }
	}
d1915 1
a1915 1
	  as_warn (_("Alignment too large: %d. assumed."), align);
d1920 1
a1920 1
	  as_warn (_("Alignment negative. 0 assumed."));
d1942 6
a1947 11
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT) \
     || defined (OBJ_BOUT) || defined (OBJ_MAYBE_BOUT))
#ifdef BFD_ASSEMBLER
      (OUTPUT_FLAVOR != bfd_target_aout_flavour
       || (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0)) &&
#else
      (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0) &&
#endif
#endif
      (S_GET_SEGMENT (symbolP) == bss_seg
       || (!S_IS_DEFINED (symbolP) && S_GET_VALUE (symbolP) == 0)))
d1957 1
a1957 1
	symbol_get_frag (symbolP)->fr_symbol = NULL;
d1959 1
a1959 1
      symbol_set_frag (symbolP, frag_now);
d1981 1
a1981 1
    as_bad (_("Ignoring attempt to re-define symbol `%s'."),
d1987 1
a1987 14
}				/* s_lcomm_internal() */

void
s_lcomm (needs_align)
     int needs_align;
{
  s_lcomm_internal (needs_align, 0);
}

void s_lcomm_bytes (needs_align)
     int needs_align;
{
  s_lcomm_internal (needs_align, 1);
}
d1991 1
a1991 1
     int ignore ATTRIBUTE_UNUSED;
d2008 1
a2008 1
      as_bad (_("Expected comma after name \"%s\""), name);
d2018 1
a2018 1
      as_bad (_("bad expression"));
d2045 1
a2045 1
      as_bad (_("Symbol %s already defined"), name);
d2098 1
a2098 2
  while (input_line_pointer < buffer_limit
	 && is_end_of_line[(unsigned char) *input_line_pointer])
d2112 1
a2112 1
     int ignore ATTRIBUTE_UNUSED;
d2140 1
a2140 1
	  symbol_set_frag (line_label, &zero_address_frag);
d2143 5
a2147 1
      if (((NO_PSEUDO_DOT || flag_m68k_mri)
d2152 1
a2152 1
	as_warn (_("attempt to redefine pseudo-op `%s' ignored"),
d2164 1
a2164 1
     int ignore ATTRIBUTE_UNUSED;
d2174 1
a2174 1
     int ignore ATTRIBUTE_UNUSED;
a2185 1
      macro_mri_mode (1);
a2189 1
#ifdef TC_M68K
a2190 2
#endif
      macro_mri_mode (0);
a2192 4
  /* Operator precedence changes in m68k MRI mode, so we need to
     update the operator rankings.  */
  expr_set_precedence ();

d2210 1
a2210 1
    as_bad (_("invalid segment \"%s\"; segment \"%s\" assumed"),
d2216 1
a2216 1
	as_warn (_("ignoring fill value in absolute section"));
d2219 1
a2219 1
	  as_bad (_("only constant offsets supported in absolute section"));
d2229 1
a2229 1
		    exp->X_add_number * OCTETS_PER_BYTE, (char *) NULL);
d2236 1
a2236 1
     int ignore ATTRIBUTE_UNUSED;
a2241 4
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

d2247 1
a2247 1
      as_bad (_("MRI style ORG pseudo-op not supported"));
d2288 1
a2288 1
     char *type ATTRIBUTE_UNUSED;
d2335 1
a2335 1
	as_bad (_("unrecognized section type"));
d2352 1
a2352 1
	      as_warn (_("error setting flags for \"%s\": %s"),
d2403 1
a2403 1
	as_warn (_("unrecognized section type `%s'"), sectype);
d2417 1
a2417 1
	  as_bad (_("absolute sections are not supported"));
d2432 1
a2432 1
	  as_warn (_("unrecognized section command `%s'"), seccmd);
d2442 1
a2442 2
  as_bad ("MRI mode not supported for this target");
  ignore_rest_of_line ();
d2451 1
a2451 1
     int ignore ATTRIBUTE_UNUSED;
d2465 1
a2465 1
     int ignore ATTRIBUTE_UNUSED;
d2495 1
a2495 1
     int ignore ATTRIBUTE_UNUSED;
d2498 2
a2502 15
  do_repeat(count, "REPT", "ENDR");
}

/* This function provides a generic repeat block implementation.   It allows
   different directives to be used as the start/end keys. */

void
do_repeat (count, start, end)
      int count;
      const char *start;
      const char *end;
{
  sb one;
  sb many;

d2504 1
a2504 1
  if (! buffer_and_nest (start, end, &one, get_line_sb))
d2506 1
a2506 1
      as_bad (_("%s without %s"), start, end);
d2516 1
a2516 1
  input_scrub_include_sb (&many, input_line_pointer, 1);
a2520 17
/* Skip to end of current repeat loop; EXTRA indicates how many additional
   input buffers to skip.  Assumes that conditionals preceding the loop end
   are properly nested. 

   This function makes it easier to implement a premature "break" out of the
   loop.  The EXTRA arg accounts for other buffers we might have inserted,
   such as line substitutions. */

void
end_repeat (extra)
  int extra;
{
  cond_exit_macro (macro_nest);
  while (extra-- >= 0)
    buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

d2548 1
a2548 1
      as_bad (_("Expected comma after name \"%s\""), name);
d2575 1
a2575 18
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
         for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct *listing_tail;
	  fragS *dummy_frag = (fragS *) xmalloc (sizeof(fragS));
	  memset (dummy_frag, 0, sizeof(fragS));
	  dummy_frag->fr_type = rs_fill;
	  dummy_frag->line = listing_tail;
	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
	  dummy_frag->fr_symbol = symbolP;
	}
      else
#endif
        symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
			    
d2590 1
a2590 1
    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
d2634 3
a2636 6
		  expressionS *symexp;

		  symexp = symbol_get_value_expression (line_label);
		  know (symexp->X_op == O_symbol);
		  know (symexp->X_add_symbol == mri_common_symbol);
		  symexp->X_add_number += 1;
d2645 1
a2645 1
	      symbol_set_frag (line_label, frag_now);
d2673 1
a2673 1
	as_bad (_("Unsupported variable size or fill value"));
d2697 3
a2699 4
	      if (! flag_mri)
		as_warn (_(".space repeat count is zero, ignored"));
	      else if (repeat < 0)
		as_warn (_(".space repeat count is negative, ignored"));
d2728 1
a2728 1
	      as_bad (_("space allocation too complex in absolute section"));
d2733 1
a2733 1
	      as_bad (_("space allocation too complex in common section"));
a2752 2
  demand_empty_rest_of_line ();

d2755 2
d2781 1
a2781 2
      as_bad (_("missing value"));
      ignore_rest_of_line ();
d2784 1
d2794 1
a2794 2
  if (input_line_pointer[0] == '0'
      && isalpha ((unsigned char) input_line_pointer[1]))
a2803 1
	  ignore_rest_of_line ();
d2806 1
d2819 1
a2819 2
	  as_bad (_("Bad floating literal: %s"), err);
	  ignore_rest_of_line ();
d2822 1
a2834 2
  demand_empty_rest_of_line ();

d2837 2
d2845 1
a2845 1
     int ignore ATTRIBUTE_UNUSED;
a2853 1
  demand_empty_rest_of_line ();
d2856 1
d2861 1
a2861 1
     int ignore ATTRIBUTE_UNUSED;
d2894 2
a2895 2
      if (isprint ((unsigned char) *input_line_pointer))
	as_bad (_("Rest of line ignored. First ignored character is `%c'."),
d2898 1
a2898 1
	as_bad (_("Rest of line ignored. First ignored character valued 0x%x."),
a2909 12
void
discard_rest_of_line ()
{
  while (input_line_pointer < buffer_limit
         && !is_end_of_line[(unsigned char) *input_line_pointer])
    {
      input_line_pointer++;
    }
  input_line_pointer++;         /* Return pointing just after end-of-line. */
  know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
}

d2937 1
a2937 1
    as_bad (_("illegal expression; zero assumed"));
d2939 1
a2939 1
    as_bad (_("missing expression; zero assumed"));
d2941 2
a2942 6
    {
      if (exp.X_add_number > 0)
	as_bad (_("bignum invalid; zero assumed"));
      else
	as_bad (_("floating point number invalid; zero assumed"));
    }
d2947 1
a2947 2
	   && (symbol_get_frag (exp.X_add_symbol)
	       == symbol_get_frag (exp.X_op_symbol)))
d2970 1
a2970 2
      if (exp.X_op != O_constant)
        symbol_set_frag (symbolP, &zero_address_frag);
d2976 1
a2976 1
      symbol_set_frag (symbolP, &zero_address_frag);
d2982 1
a2982 3
	symbol_set_value_expression (symbolP, &exp);
      else if (symbol_section_p (symbolP))
	as_bad ("invalid attempt to set value of section symbol");
d2996 1
a2996 1
	  symbol_set_frag (symbolP, symbol_get_frag (s));
d3004 1
a3004 1
      symbol_set_value_expression (symbolP, &exp);
a3033 1
#ifdef TC_M68K
a3035 1
#endif
a3076 1
      demand_empty_rest_of_line ();
d3079 1
a3089 1
#ifdef TC_M68K
a3092 1
#endif
d3100 1
a3100 1
	    as_fatal (_("rva without symbol"));
a3114 2
  demand_empty_rest_of_line ();

d3117 2
d3136 1
a3152 67
#ifndef NO_LISTING
#ifdef OBJ_ELF
  /* When gcc emits DWARF 1 debugging pseudo-ops, a line number will
     appear as a four byte positive constant in the .line section,
     followed by a 2 byte 0xffff.  Look for that case here.  */
  {
    static int dwarf_line = -1;

    if (strcmp (segment_name (now_seg), ".line") != 0)
      dwarf_line = -1;
    else if (dwarf_line >= 0
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && (exp->X_add_number == -1 || exp->X_add_number == 0xffff))
      listing_source_line ((unsigned int) dwarf_line);
    else if (nbytes == 4
	     && exp->X_op == O_constant
	     && exp->X_add_number >= 0)
      dwarf_line = exp->X_add_number;
    else
      dwarf_line = -1;
  }

  /* When gcc emits DWARF 1 debugging pseudo-ops, a file name will
     appear as a 2 byte TAG_compile_unit (0x11) followed by a 2 byte
     AT_sibling (0x12) followed by a four byte address of the sibling
     followed by a 2 byte AT_name (0x38) followed by the name of the
     file.  We look for that case here.  */
  {
    static int dwarf_file = 0;

    if (strcmp (segment_name (now_seg), ".debug") != 0)
      dwarf_file = 0;
    else if (dwarf_file == 0
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && exp->X_add_number == 0x11)
      dwarf_file = 1;
    else if (dwarf_file == 1
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && exp->X_add_number == 0x12)
      dwarf_file = 2;
    else if (dwarf_file == 2
	     && nbytes == 4)
      dwarf_file = 3;
    else if (dwarf_file == 3
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && exp->X_add_number == 0x38)
      dwarf_file = 4;
    else
      dwarf_file = 0;

    /* The variable dwarf_file_string tells stringer that the string
       may be the name of the source file.  */
    if (dwarf_file == 4)
      dwarf_file_string = 1;
    else
      dwarf_file_string = 0;
  }
#endif
#endif

  if (check_eh_frame (exp, &nbytes))
    return;

d3159 1
a3159 1
	as_bad (_("attempt to store value in absolute section"));
d3167 2
a3168 2
      && symbol_get_value_expression (exp->X_add_symbol)->X_op == O_big
      && symbol_get_value_expression (exp->X_add_symbol)->X_add_number > 0)
d3173 1
a3173 1
      exp = symbol_get_value_expression (exp->X_add_symbol);
d3197 1
a3197 1
      as_warn (_("zero assumed for missing expression"));
d3203 1
a3203 1
      as_bad (_("floating point number invalid; zero assumed"));
d3209 1
a3209 1
      as_warn (_("register value used as expression"));
a3224 2
      x->seg = now_seg;
      x->subseg = now_subseg;
d3297 1
a3297 1
	  as_warn (_("Value 0x%lx truncated to 0x%lx."),
d3305 1
a3305 1
      unsigned int size;
d3313 1
a3313 1
	  as_warn (_("Bignum truncated to %d bytes"), nbytes);
d3390 1
a3390 1
	    as_bad (_("unsupported BFD relocation size %u"), nbytes);
d3479 1
a3479 1
	      as_warn (_("using a bit field width of zero"));
d3487 1
a3487 1
	      as_bad (_("field width \"%s\" too complex for a bitfield"), hold);
d3495 1
a3495 1
	      as_warn (_("field width %lu too big to fit in %d bytes: truncated to %d bits"),
d3516 1
a3516 1
	      as_bad (_("field value \"%s\" too complex for a bitfield"), hold);
a3545 1
#ifdef TC_M68K
d3558 1
a3558 1
      unsigned int scan;
d3568 1
a3568 1
	  as_bad (_("EBCDIC constants are not supported"));
a3607 1
#endif /* TC_M68K */
d3638 1
a3638 1
      as_warn (_("Unresolvable or nonpositive repeat count; using 1"));
d3689 1
a3689 1
      as_bad (_("Unknown floating type type '%c'"), float_type);
d3711 1
a3711 1
	  as_warn (_("Floating point constant too large"));
d3791 1
a3791 2
      if (input_line_pointer[0] == '0'
	  && isalpha ((unsigned char) input_line_pointer[1]))
d3813 1
a3813 1
	      as_bad (_("Bad floating literal: %s"), err);
d3835 1
a3835 1
		  as_warn (_("unresolvable or nonpositive repeat count; using 1"));
a3855 300
/* Return the size of a LEB128 value */

static inline int
sizeof_sleb128 (value)
     offsetT value;
{
  register int size = 0;
  register unsigned byte;

  do
    {
      byte = (value & 0x7f);
      /* Sadly, we cannot rely on typical arithmetic right shift behaviour.
	 Fortunately, we can structure things so that the extra work reduces
	 to a noop on systems that do things "properly".  */
      value = (value >> 7) | ~(-(offsetT)1 >> 7);
      size += 1;
    }
  while (!(((value == 0) && ((byte & 0x40) == 0))
	   || ((value == -1) && ((byte & 0x40) != 0))));

  return size;
}

static inline int
sizeof_uleb128 (value)
     valueT value;
{
  register int size = 0;
  register unsigned byte;

  do
    {
      byte = (value & 0x7f);
      value >>= 7;
      size += 1;
    }
  while (value != 0);

  return size;
}

int
sizeof_leb128 (value, sign)
     valueT value;
     int sign;
{
  if (sign)
    return sizeof_sleb128 ((offsetT) value);
  else
    return sizeof_uleb128 (value);
}

/* Output a LEB128 value.  */

static inline int
output_sleb128 (p, value)
     char *p;
     offsetT value;
{
  register char *orig = p;
  register int more;

  do
    {
      unsigned byte = (value & 0x7f);

      /* Sadly, we cannot rely on typical arithmetic right shift behaviour.
	 Fortunately, we can structure things so that the extra work reduces
	 to a noop on systems that do things "properly".  */
      value = (value >> 7) | ~(-(offsetT)1 >> 7);

      more = !((((value == 0) && ((byte & 0x40) == 0))
		|| ((value == -1) && ((byte & 0x40) != 0))));
      if (more)
	byte |= 0x80;

      *p++ = byte;
    }
  while (more);

  return p - orig;
}

static inline int
output_uleb128 (p, value)
     char *p;
     valueT value;
{
  char *orig = p;

  do
    {
      unsigned byte = (value & 0x7f);
      value >>= 7;
      if (value != 0)
	/* More bytes to follow.  */
	byte |= 0x80;

      *p++ = byte;
    }
  while (value != 0);

  return p - orig;
}

int
output_leb128 (p, value, sign)
     char *p;
     valueT value;
     int sign;
{
  if (sign)
    return output_sleb128 (p, (offsetT) value);
  else
    return output_uleb128 (p, value);
}

/* Do the same for bignums.  We combine sizeof with output here in that
   we don't output for NULL values of P.  It isn't really as critical as
   for "normal" values that this be streamlined.  */

static inline int
output_big_sleb128 (p, bignum, size)
     char *p;
     LITTLENUM_TYPE *bignum;
     int size;
{
  char *orig = p;
  valueT val = 0;
  int loaded = 0;
  unsigned byte;

  /* Strip leading sign extensions off the bignum.  */
  while (size > 0 && bignum[size-1] == (LITTLENUM_TYPE)-1)
    size--;

  do
    {
      if (loaded < 7 && size > 0)
	{
	  val |= (*bignum << loaded);
	  loaded += 8 * CHARS_PER_LITTLENUM;
	  size--;
	  bignum++;
	}

      byte = val & 0x7f;
      loaded -= 7;
      val >>= 7;

      if (size == 0)
	{
	  if ((val == 0 && (byte & 0x40) == 0)
	      || (~(val | ~(((valueT)1 << loaded) - 1)) == 0
		  && (byte & 0x40) != 0))
	    byte |= 0x80;
	}

      if (orig)
	*p = byte;
      p++;
    }
  while (byte & 0x80);

  return p - orig;
}

static inline int
output_big_uleb128 (p, bignum, size)
     char *p;
     LITTLENUM_TYPE *bignum;
     int size;
{
  char *orig = p;
  valueT val = 0;
  int loaded = 0;
  unsigned byte;

  /* Strip leading zeros off the bignum.  */
  /* XXX: Is this needed?  */
  while (size > 0 && bignum[size-1] == 0)
    size--;

  do
    {
      if (loaded < 7 && size > 0)
	{
	  val |= (*bignum << loaded);
	  loaded += 8 * CHARS_PER_LITTLENUM;
	  size--;
	  bignum++;
	}

      byte = val & 0x7f;
      loaded -= 7;
      val >>= 7;

      if (size > 0 || val)
	byte |= 0x80;

      if (orig)
	*p = byte;
      p++;
    }
  while (byte & 0x80);

  return p - orig;
}

static int
output_big_leb128 (p, bignum, size, sign)
     char *p;
     LITTLENUM_TYPE *bignum;
     int size, sign;
{
  if (sign)
    return output_big_sleb128 (p, bignum, size);
  else
    return output_big_uleb128 (p, bignum, size);
}

/* Generate the appropriate fragments for a given expression to emit a
   leb128 value.  */

void
emit_leb128_expr(exp, sign)
     expressionS *exp;
     int sign;
{
  operatorT op = exp->X_op;

  if (op == O_absent || op == O_illegal)
    {
      as_warn (_("zero assumed for missing expression"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_big && exp->X_add_number <= 0)
    {
      as_bad (_("floating point number invalid; zero assumed"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_register)
    {
      as_warn (_("register value used as expression"));
      op = O_constant;
    }

  if (op == O_constant)
    {
      /* If we've got a constant, emit the thing directly right now.  */

      valueT value = exp->X_add_number;
      int size;
      char *p;

      size = sizeof_leb128 (value, sign);
      p = frag_more (size);
      output_leb128 (p, value, sign);
    }
  else if (op == O_big)
    {
      /* O_big is a different sort of constant.  */

      int size;
      char *p;

      size = output_big_leb128 (NULL, generic_bignum, exp->X_add_number, sign);
      p = frag_more (size);
      output_big_leb128 (p, generic_bignum, exp->X_add_number, sign);
    }
  else
    {
      /* Otherwise, we have to create a variable sized fragment and 
	 resolve things later.  */

      frag_var (rs_leb128, sizeof_uleb128 (~(valueT)0), 0, sign,
		make_expr_symbol (exp), 0, (char *) NULL);
    }
}

/* Parse the .sleb128 and .uleb128 pseudos.  */

void
s_leb128 (sign)
     int sign;
{
  expressionS exp;

  do {
    expression (&exp);
    emit_leb128_expr (&exp, sign);
  } while (*input_line_pointer++ == ',');

  input_line_pointer--;
  demand_empty_rest_of_line ();
}

d3859 1
a3859 1
 * We read 0 or more ',' separated, double-quoted strings.
a3870 1
  char *start;
d3878 1
a3878 1
   * comma separated. Recall a string expression includes spaces
a3899 1
	  start = input_line_pointer;
a3908 21

#ifndef NO_LISTING
#ifdef OBJ_ELF
	  /* In ELF, when gcc is emitting DWARF 1 debugging output, it
             will emit .string with a filename in the .debug section
             after a sequence of constants.  See the comment in
             emit_expr for the sequence.  emit_expr will set
             dwarf_file_string to non-zero if this string might be a
             source file name.  */
	  if (strcmp (segment_name (now_seg), ".debug") != 0)
	    dwarf_file_string = 0;
	  else if (dwarf_file_string)
	    {
	      c = input_line_pointer[-1];
	      input_line_pointer[-1] = '\0';
	      listing_source_file (start);
	      input_line_pointer[-1] = c;
	    }
#endif
#endif

d3916 1
a3916 1
	      as_bad (_("Expected <nn>"));
d3949 1
a3949 1
      as_warn (_("Unterminated string: Newline inserted."));
d4032 1
a4032 1
	  as_warn (_("Unterminated string: Newline inserted."));
d4040 1
a4040 1
	  as_bad (_("Bad escaped character in string, '?' assumed"));
d4066 1
a4066 1
      as_bad (_("expected address expression; zero assumed"));
d4086 1
a4086 1
	as_warn (_("symbol \"%s\" undefined; zero assumed"),
d4089 1
a4089 1
	as_warn (_("some symbol undefined; zero assumed"));
d4107 1
a4107 1
	as_bad (_("bad or irreducible absolute expression; zero assumed"));
d4145 1
a4145 1
	      as_bad (_("This string may not contain \'\\0\'"));
d4184 1
a4184 1
      as_warn (_("Missing string"));
d4214 1
a4214 1
  char *stop = NULL;
d4244 1
a4244 1
	as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
d4249 1
a4249 4
     {
       ignore_rest_of_line (); /* check garbage after the expression */
       mri_comment_end (stop, stopc);
     }
d4257 1
a4257 1
     int arg ATTRIBUTE_UNUSED;
d4259 1
d4266 1
a4266 9
    {
      filename = demand_copy_string (&i);
      if (filename == NULL)
	{
	  /* demand_copy_string has already printed an error and
             called ignore_rest_of_line.  */
	  return;
	}
    }
d4301 2
a4302 2
  register_dependency (path);
  input_scrub_insert_file (path);
a4329 68

/* Output debugging information to denote the source file.  */

static void
generate_file_debug ()
{
  if (debug_type == DEBUG_STABS)
    stabs_generate_asm_file ();
}

/* Output line number debugging information for the current source line.  */

void
generate_lineno_debug ()
{
#ifdef ECOFF_DEBUGGING
  /* ECOFF assemblers automatically generate debugging information. 
     FIXME: This should probably be handled elsewhere.  */
  if (debug_type == DEBUG_UNSPECIFIED)
    {
      if (ECOFF_DEBUGGING && ecoff_no_current_file ())
        debug_type = DEBUG_ECOFF;
      else
	debug_type = DEBUG_NONE;
    }
#endif

  switch (debug_type)
    {
    case DEBUG_UNSPECIFIED:
    case DEBUG_NONE:
      break;
    case DEBUG_STABS:
      stabs_generate_asm_lineno ();
      break;
    case DEBUG_ECOFF:
      ecoff_generate_asm_lineno ();
      break;
    case DEBUG_DWARF:
    case DEBUG_DWARF2:
      /* FIXME.  */
      break;
    }
}

/* Output debugging information to mark a function entry point or end point.
   END_P is zero for .func, and non-zero for .endfunc.  */

void
s_func (end_p)
     int end_p;
{
  do_s_func (end_p, NULL);
}

/* Subroutine of s_func so targets can choose a different default prefix.
   If DEFAULT_PREFIX is NULL, use the target's "leading char".  */

void
do_s_func (end_p, default_prefix)
     int end_p;
     const char *default_prefix;
{
  /* Record the current function so that we can issue an error message for
     misplaced .func,.endfunc, and also so that .endfunc needs no
     arguments.  */
  static char *current_name;
  static char *current_label;
a4330 69
  if (end_p)
    {
      if (current_name == NULL)
	{
	  as_bad (_("missing .func"));
	  ignore_rest_of_line ();
	  return;
	}

      if (debug_type == DEBUG_STABS)
	stabs_generate_asm_endfunc (current_name, current_label);

      current_name = current_label = NULL;
    }
  else /* ! end_p */
    {
      char *name,*label;
      char delim1,delim2;

      if (current_name != NULL)
	{
	  as_bad (_(".endfunc missing for previous .func"));
	  ignore_rest_of_line ();
	  return;
	}

      name = input_line_pointer;
      delim1 = get_symbol_end ();
      name = xstrdup (name);
      *input_line_pointer = delim1;
      SKIP_WHITESPACE ();
      if (*input_line_pointer != ',')
	{
	  if (default_prefix)
	    asprintf (&label, "%s%s", default_prefix, name);
	  else
	    {
	      char leading_char = 0;
#ifdef BFD_ASSEMBLER
	      leading_char = bfd_get_symbol_leading_char (stdoutput);
#endif
	      /* Missing entry point, use function's name with the leading
		 char prepended.  */
	      if (leading_char)
		asprintf (&label, "%c%s", leading_char, name);
	      else
		label = name;
	    }
	}
      else
	{
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  label = input_line_pointer;
	  delim2 = get_symbol_end ();
	  label = xstrdup (label);
	  *input_line_pointer = delim2;
	}

      if (debug_type == DEBUG_STABS)
	stabs_generate_asm_func (name, label);

      current_name = name;
      current_label = label;
    }

  demand_empty_rest_of_line ();
}

d4333 1
a4333 1
     int arg ATTRIBUTE_UNUSED;
a4347 32
}

/* Inserts the given line into the input stream.  
   
   This call avoids macro/conditionals nesting checking, since the contents of
   the line are assumed to replace the contents of a line already scanned.

   An appropriate use of this function would be substition of input lines when
   called by md_start_line_hook().  The given line is assumed to already be
   properly scrubbed.  */

void
input_scrub_insert_line (line)
  const char *line;
{
  sb newline;
  sb_new (&newline);
  sb_add_string (&newline, line);
  input_scrub_include_sb (&newline, input_line_pointer, 0);
  sb_kill (&newline);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Insert a file into the input stream; the path must resolve to an actual
   file; no include path searching or dependency registering is performed.  */ 

void
input_scrub_insert_file (path)
  char *path;
{
  input_scrub_include_file (path, input_line_pointer);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000 Free Software Foundation, Inc.
d20 1
a20 1
02111-1307, USA.  */
d23 5
a27 4
/* If your chars aren't 8 bits, you will change this a bit.
   But then, GNU isn't spozed to run on your machine anyway.
   (RMS is so shortsighted sometimes.)  */
#define MASK_CHAR (0xFF)
d29 1
a29 1
#define MASK_CHAR ((int)(unsigned char) -1)
d32 1
d34 2
a35 1
   grow when we do 4361 style flonums.  */
d41 1
a41 1
/* For isdigit ().  */
d58 19
a76 13
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)        	\
  do								\
    {                                                   	\
      if ((SIZE) >= 8)                                      	\
	(P2VAR) = 3;                                        	\
      else if ((SIZE) >= 4)                                 	\
	(P2VAR) = 2;                                        	\
      else if ((SIZE) >= 2)                                 	\
	(P2VAR) = 1;                                        	\
      else                                                  	\
	(P2VAR) = 0;                                        	\
    }								\
  while (0)
d79 1
a79 1
char *input_line_pointer;	/*->next char of source file to parse.  */
a107 2
/* The IA-64 assembler uses # as a suffix designating a symbol.  We include
   it in the symbol and strip it out in tc_canonicalize_symbol_name.  */
d121 3
a123 2
/* Used by is_... macros. our ctype[].  */
char lex_type[256] = {
d131 1
a131 1
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, LEX_TILDE, 0, /* pqrstuvwxyz{|}~.  */
d142 8
a149 3
/* In: a character.
   Out: 1 if this character ends a line.  */
char is_end_of_line[256] = {
d151 8
a158 1
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,	/* @@abcdefghijklmno */
d160 2
a161 1
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,	/* @@abcdefghijklmno */
d163 9
a171 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* _!"#$%&'()*+,-./ */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0123456789:;<=>? */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	/* */
d173 1
d175 1
a175 5
#ifdef  IGNORE_OPCODE_CASE
char original_case_string[128];
#endif

/* Functions private to this file.  */
d177 2
a178 2
static char *buffer;	/* 1st char of each buffer of lines is here.  */
static char *buffer_limit;	/*->1 + last char in buffer.  */
d180 2
a181 3
/* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1
   in the tc-<CPU>.h file.  See the "Porting GAS" section of the
   internals manual.  */
d184 1
a184 1
static char *old_buffer;	/* JF a hack.  */
d188 1
a188 4
/* Variables for handling include file directory table.  */

/* Table of pointers to directories to search for .include's.  */
char **include_dirs;
d190 4
a193 5
/* How many are in the table.  */
int include_dir_count;

/* Length of longest in table.  */
int include_dir_maxlen = 1;
d250 1
d264 1
a264 1
  /* Use machine dependent syntax.  */
d267 1
a267 1
  /* Use more.  FIXME-SOMEDAY.  */
d273 1
a273 1
/* Set up pseudo-op tables.  */
d277 2
a278 1
static const pseudo_typeS potable[] = {
d286 1
a286 1
/* block  */
d318 1
a318 1
/* dim  */
d320 2
a321 2
/* dsect  */
  {"eject", listing_eject, 0},	/* Formfeed listing.  */
d329 1
a329 1
/* endef  */
d334 2
a335 2
/* extend  */
  {"extern", s_ignore, 0},	/* We treat all undef as ext.  */
d368 1
a368 1
  {"lflags", listing_flags, 0},	/* Listing flags.  */
d370 1
a370 1
  {"list", listing_list, 1},	/* Turn listing on.  */
d380 1
a380 1
  {"nolist", listing_list, 0},	/* Turn listing off.  */
d391 1
a391 1
  {"psize", listing_psize, 0},	/* Set paper size.  */
d397 3
a399 3
  {"sbttl", listing_title, 1},	/* Subtitle of listing.  */
/* scl  */
/* sect  */
d403 1
a403 1
/* size  */
d413 1
a413 1
/* tag  */
d426 1
a426 1
  {"title", listing_title, 0},	/* Listing title.  */
d428 1
a428 1
/* type  */
d430 2
a431 2
/* use  */
/* val  */
d438 1
a438 1
  {NULL, NULL, 0}			/* End sentinel.  */
d467 1
a467 1
static void
d472 1
a472 1
  /* Do the target-specific pseudo ops.  */
d476 1
a476 1
  /* Now object specific.  Skip any that were in the target table.  */
d481 1
a481 1
  /* Now portable ones.  Skip any that we've seen already.  */
d489 1
a489 1
      while (!is_end_of_line[(unsigned char) *input_line_pointer++])	\
d495 1
d517 6
a522 3
/* We read the file, putting things into a web that represents what we
   have been reading.  */
void
d527 1
a527 1
  register char *s;		/* String of symbol, '\0' appended.  */
a530 4
#ifdef WARN_COMMENTS
  found_comment = 0;
#endif

d543 2
a544 2
    {				/* We have another line to parse.  */
      know (buffer_limit[-1] == '\n');	/* Must have a sentinel.  */
d550 1
a550 1
	  /* We have more of this buffer to parse.  */
d552 5
a556 3
	  /* We now have input_line_pointer->1st char of next line.
	     If input_line_pointer [-1] == '\n' then we just
	     scanned another line: so bump line counters.  */
d562 1
d613 1
a613 1
		      if (!mri_line_macro
d615 2
a616 2
			  && TC_START_LABEL_WITHOUT_COLON(c,
							  input_line_pointer)
d618 1
a618 1
			  )
d633 14
a646 12
	  /* We are at the begining of a line, or similar place.
	     We expect a well-formed assembler statement.
	     A "symbol-name:" is a statement.

	     Depending on what compiler is used, the order of these tests
	     may vary to catch most common case 1st.
	     Each test is independent of all other tests at the (top) level.
	     PLEASE make a compiler that doesn't use this assembler.
	     It is crufty to waste a compiler's time encoding things for this
	     assembler, which then wastes more time decoding it.
	     (And communicating via (linear) files is silly!
	     If you must pass stuff, please pass a tree!)  */
d651 4
a654 3
	    c = *input_line_pointer++;

	  know (c != ' ');	/* No further leading whitespace.  */
d667 1
a667 1
		  for (s = input_line_pointer - 1; *s; ++s)
d673 1
a673 1
		  len = s - (input_line_pointer - 1);
d677 2
a678 2
		  memcpy (copy + macro_nest + 1, input_line_pointer - 1, len);
		  copy[macro_nest + 1 + len] = '\0';
d687 5
a691 2
	  /* C is the 1st significant character.
	     Input_line_pointer points after that character.  */
d694 1
a694 1
	      /* Want user-defined label or pseudo/opcode.  */
d698 9
a706 8
	      c = get_symbol_end ();	/* name's delimiter.  */

	      /* C is character after symbol.
	         That character's place in the input line is now '\0'.
	         S points to the beginning of the symbol.
	           [In case of pseudo-op, s->'.'.]
	         Input_line_pointer->'\0' where c was.  */
	      if (TC_START_LABEL (c, input_line_pointer))
d713 1
a715 1

a717 1

d728 3
a730 4
		  line_label = colon (s);	/* User-defined label.  */
		  /* Put ':' back for error messages' sake.  */
		  *input_line_pointer++ = ':';
		  /* Input_line_pointer->after ':'.  */
d732 2
d739 1
a739 1
			   && !TC_EQUAL_IN_INSN (c, input_line_pointer)
d747 1
a747 2
		{
		  /* Expect pseudo-op or machine instruction.  */
d750 1
a753 4

		    strncpy (original_case_string, s2, sizeof (original_case_string));
		    original_case_string[sizeof (original_case_string) - 1] = 0;

d762 1
d773 1
a773 1
		      || (!flag_m68k_mri && *s == '.'))
d775 7
a781 5
		      /* PSEUDO - OP.

		         WARNING: c has next char, which may be end-of-line.
		         We lookup the pseudo-op table with s+1 because we
		         already know that the pseudo-op begins with a '.'.  */
d791 4
a794 4
			      || !((pop->poc_handler == cons
				    && pop->poc_val == 1)
				   || (pop->poc_handler == s_space
				       && pop->poc_val == 1)
d796 1
a796 1
				   || tc_conditional_pseudoop (pop)
d798 8
a805 8
				   || pop->poc_handler == s_if
				   || pop->poc_handler == s_ifdef
				   || pop->poc_handler == s_ifc
				   || pop->poc_handler == s_ifeqs
				   || pop->poc_handler == s_else
				   || pop->poc_handler == s_endif
				   || pop->poc_handler == s_globl
				   || pop->poc_handler == s_ignore)))
a808 1

d816 1
a816 1
		      /* Print the error msg now, while we still can.  */
d825 1
a825 1
		      /* Put it back for error messages etc.  */
d829 1
a829 1
			 keyword from operands.  */
d832 5
a836 4

		      /* Input_line is restored.
		         Input_line_pointer->1st non-blank char
		         after pseudo-operation.  */
d850 2
a851 2
		      /* WARNING: c has char, which may be end-of-line.  */
		      /* Also: input_line_pointer->`\0` where c was.  */
d861 1
a861 1
			    inquote = !inquote;
d866 1
a866 1
			    inquote = !inquote;
d882 1
a882 1
			  macro_entry *macro;
d895 1
a895 1
			      md_macro_info (macro);
d912 1
a912 1
		      md_assemble (s);	/* Assemble 1 instruction.  */
d917 3
a919 3
			 this instruction.  */
		    }
		}
d921 2
a922 1
	    }
d931 1
a931 1
	      /* local label  ("4:")  */
a937 1
	      /* Read the whole number.  */
d942 1
a942 1
		}
d972 1
a972 1
	    {			/* Its a comment.  Better say APP or NO_APP.  */
d995 1
a995 1
		     guarentee it...  */
a1062 1

d1072 3
a1074 2
	  /* as_warn (_("Junk character %d."),c); Now done by ignore_rest.  */
	  input_line_pointer--;	/* Report unknown char as ignored.  */
d1076 1
a1076 1
	}
d1095 1
a1095 1
    }
d1100 1
a1100 10
  md_cleanup ();
#endif
  /* Close the input file.  */
  input_scrub_close ();
#ifdef WARN_COMMENTS
  {
    if (warn_comment && found_comment)
      as_warn_where (found_comment_file, found_comment,
		     "first comment found here");
  }
d1102 1
d1117 2
a1119 1
#ifdef TC_M68K
d1125 1
a1125 1
       ((!is_end_of_line[(unsigned char) *s] && *s != ' ' && *s != '\t')
d1130 1
a1130 1
	inquote = !inquote;
d1132 4
d1137 4
a1140 3
  for (s = input_line_pointer;
       !is_end_of_line[(unsigned char) *s];
       s++)
a1141 1
#endif
d1144 3
a1147 1
  return s;
d1161 1
a1161 1
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
d1165 1
a1165 1
void
d1178 1
a1178 1
static void
d1185 2
d1191 11
a1201 1
  /* Only make a frag if we HAVE to...  */
d1204 1
a1204 8
      if (fill == NULL)
	{
	  if (subseg_text_p (now_seg))
	    frag_align_code (n, max);
	  else
	    frag_align (n, 0, max);
	}
      else if (len <= 1)
d1242 1
a1242 1
	align = arg;	/* Default value from pseudo-op table.  */
a1260 1

d1297 1
a1297 1
  if (!fill_p)
d1310 1
a1310 1
	fill_len = -arg;
d1338 1
a1338 1
void
d1348 1
a1348 1
void
d1355 1
a1355 1
void
d1372 1
a1372 1
  /* Just after name is now '\0'.  */
a1375 1

a1383 1

a1384 1

a1392 1

d1396 1
a1396 2

  if (S_IS_DEFINED (symbolP) && !S_IS_COMMON (symbolP))
a1404 1

d1421 1
a1421 1
    if (!temp || !flag_one)
d1449 1
a1449 1
  if (!flag_mri)
d1460 1
a1460 1
  if (!isdigit ((unsigned char) *name))
a1468 1

d1495 1
a1495 1
  if (S_IS_DEFINED (sym) && !S_IS_COMMON (sym))
d1567 1
a1567 1
void
d1574 1
a1574 1
  /* Some assemblers tolerate immediately following '"'.  */
d1581 1
a1581 1
	= (!new_logical_line (s, appfile ? -2 : -1) && appfile);
d1591 1
a1591 1
      if (!may_omit)
d1621 1
a1621 2
    as_warn (_("Line numbers must be positive; line number %d rejected."),
	     l + 1);
d1645 1
a1645 1
      if (!is_end_of_line[(unsigned char) *input_line_pointer]
d1687 1
a1687 1
void
a1764 1

a1765 1

d1767 4
a1770 4
         flavoured AS.  The following bizzare behaviour is to be
         compatible with above.  I guess they tried to take up to 8
         bytes from a 4-byte expression and they forgot to sign
         extend. Un*x Sux.  */
d1777 3
a1779 3
         but emits no error message because it seems a legal thing to do.
         It is a degenerate case of .fill but could be emitted by a
	 compiler.  */
d1784 1
a1784 1
void
d1838 1
a1838 1
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
d1869 1
a1869 1
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
d1919 1
a1919 1
    if (!bfd_set_section_flags (stdoutput, now_seg, flags))
d1931 1
a1931 1
static void
d1934 1
a1934 1
	(alignment); 0 if it was an ".lcomm" (2 args only).  */
d1937 1
a1937 1
	rather than the power of 2.  */
d1988 1
a1988 1
	  if (!bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
d1996 8
a2003 8
  if (!needs_align)
    {
      TC_IMPLICIT_LCOMM_ALIGNMENT (temp, align);

      /* Still zero unless TC_IMPLICIT_LCOMM_ALIGNMENT set it.  */
      if (align)
	record_alignment (bss_seg, align);
    }
a2008 1

a2014 1

a2016 1

a2021 1

a2022 1

a2036 1

a2046 1

d2048 1
a2048 1
    }
d2085 1
a2085 2

      /* Detach from old frag.  */
d2090 1
a2090 1
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
d2099 1
a2099 1
         in that case.  Otherwise, set it to static.  */
d2117 1
a2117 1
}
d2126 1
a2126 2
void
s_lcomm_bytes (needs_align)
d2132 1
a2132 1
void
d2142 1
a2142 1
  /* We permit ANY defined expression: BSD4.2 demands constants.  */
a2147 1

a2155 1

a2157 1

a2164 1

d2173 1
a2173 1
     anyway.  xoxorich.  */
d2179 1
a2179 1
	 keep the "external" bit.  */
a2189 1

d2192 1
a2192 1
}
d2214 1
a2214 1
  if (!flag_m68k_mri)
d2227 1
a2227 2

  while (!is_end_of_line[(unsigned char) *input_line_pointer]
a2238 1

a2240 1

a2247 1

d2268 1
a2268 1
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
d2289 1
a2289 1
	  || (!flag_m68k_mri
a2374 2
      symbolS *sym = exp->X_add_symbol;
      offsetT off = exp->X_add_number * OCTETS_PER_BYTE;
d2376 2
a2377 8
      if (exp->X_op != O_constant && exp->X_op != O_symbol)
	{
	  /* Handle complex expressions.  */
	  sym = make_expr_symbol (exp);
	  off = 0;
	}

      p = frag_var (rs_org, 1, 1, (relax_substateT) 0, sym, off, (char *) 0);
d2382 1
a2382 1
void
d2429 1
a2429 1
}
d2449 1
a2449 1

d2451 1
a2451 1
  if (!isdigit ((unsigned char) *name))
a2459 1

d2503 1
a2503 1
	    if (!bfd_set_section_flags (stdoutput, seg, flags))
d2589 1
a2589 1
  demand_empty_rest_of_line ();
d2654 1
a2654 1
  do_repeat (count, "REPT", "ENDR");
d2658 1
a2658 1
   different directives to be used as the start/end keys.  */
d2662 3
a2664 3
     int count;
     const char *start;
     const char *end;
d2670 1
a2670 1
  if (!buffer_and_nest (start, end, &one, get_line_sb))
d2689 1
a2689 1
   are properly nested.
d2693 1
a2693 1
   such as line substitutions.  */
d2697 1
a2697 1
     int extra;
d2708 1
a2708 1
void
d2717 5
a2721 3
  /* Especial apologies for the random logic:
     this just grew, and could be parsed much more simply!
     Dean in haste.  */
d2742 1
a2742 1
      /* Turn '. = mumble' into a .org mumble.  */
d2765 2
a2766 2
	  fragS *dummy_frag = (fragS *) xmalloc (sizeof (fragS));
	  memset (dummy_frag, 0, sizeof (fragS));
d2774 2
a2775 2
	symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);

d2777 1
a2777 1
      /* "set" symbols are local unless otherwise specified.  */
d2780 2
a2781 1
    }
d2794 1
a2794 1
}
d2796 1
a2796 1
void
d2900 1
a2900 1
	      if (!flag_mri)
a2934 1

a2939 1

d3076 1
a3076 1
}
d3078 2
a3079 1
void
d3084 3
a3086 1
    input_line_pointer++;
d3088 5
a3092 4
    ignore_rest_of_line ();

  /* Return having already swallowed end-of-line.  */
}
d3095 1
a3095 1
ignore_rest_of_line ()
a3096 1
  /* For suspect lines: gives warning.  */
a3104 1

d3107 3
a3109 1
	input_line_pointer++;
d3111 1
a3111 4

  input_line_pointer++;

  /* Return pointing just after end-of-line.  */
d3119 5
a3123 6
	 && !is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;

  input_line_pointer++;

  /* Return pointing just after end-of-line.  */
d3127 10
a3136 7
/* In:	Pointer to a symbol.
  	Input_line_pointer->expression.

   Out:	Input_line_pointer->just after any whitespace after expression.
  	Tried to set symbol to value of expression.
  	Will change symbols type, value, and frag;  */

d3146 1
a3146 1
  know (symbolP);		/* NULL pointer is logic error.  */
d3193 1
a3193 1
	symbol_set_frag (symbolP, &zero_address_frag);
d3234 14
a3247 12
/*  			cons()

   CONStruct more frag of .bytes, or .words etc.
   Should need_pass_2 be 1 then emit no frag(s).
   This understands EXPRESSIONS.

   Bug (?)

   This has a split personality. We use expression() to read the
   value. We can detect if the value won't fit in a byte or word.
   But we can't detect if expression() discarded significant digits
   in the case of a long. Not worth the crocks required to fix it.  */
d3267 1
a3267 1
static void
d3282 4
a3285 4
/* Worker to do .byte etc statements.
   Clobbers input_line_pointer and checks end-of-line.  */

static void
d3287 1
a3287 1
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long.  */
d3342 1
a3342 1
  input_line_pointer--;		/* Put terminator back into stream.  */
d3350 1
d3358 1
a3358 1
void
d3476 1
a3476 1
	  next = (((~(generic_bignum[i] & LITTLENUM_MASK))
d3541 1
a3541 1
      if (!exp->X_unsigned && exp->X_add_number < 0)
d3565 1
a3565 1
	 particular SPARC (Sun 4) has problems.  */
d3576 1
a3576 1
	  /* Don't store these bits.  */
d3581 1
a3581 1
      unmask = ~mask;		/* Do store these bits.  */
d3585 1
a3585 1
      mask = ~(unmask >> 1);	/* Includes sign bit now.  */
d3593 1
a3593 1
	{		/* Leading bits contain both 0s & 1s.  */
d3597 1
a3597 1
      /* Put bytes in right order.  */
d3732 1
a3732 1
static void
d3743 1
a3743 2
    {
      /* Bitfields.  */
d3754 1
a3754 1
	    }			/* Next piece is not a bitfield.  */
d3772 1
a3772 1
	     .equ type symbol.  xoxorich.  */
d3779 1
a3779 1
	    }			/* Implied zero width bitfield.  */
d3788 1
a3788 1
	    }			/* Too complex.  */
d3795 1
a3795 1
	    }			/* Too big.  */
d3803 1
a3803 1
	    }			/* Won't fit.  */
d3805 1
a3805 2
	  /* Skip ':'.  */
	  hold = ++input_line_pointer;
d3817 1
a3817 1
	    }			/* Too complex.  */
d3827 1
a3827 1
	    }			/* All the bitfields we're gonna get.  */
d3831 1
a3831 1
	}
d3836 2
a3837 2
    }
}
d3885 1
a3885 1
      /* Left justify.  */
d3891 1
a3891 2

      /* Create correct expression.  */
d3894 1
a3894 2

      /* Fake it so that we can read the next char too.  */
d4001 1
a4001 1
	 through the hex constant, so we ignore them as well.  */
d4040 19
a4058 16
/*  			float_cons()

   CONStruct some more frag chars of .floats .ffloats etc.
   Makes 0 or more new frags.
   If need_pass_2 == 1, no frags are emitted.
   This understands only floating literals, not expressions. Sorry.

   A floating constant is defined by atof_generic(), except it is preceded
   by 0d 0f 0g or 0h. After observing the STRANGE way my BSD AS does its
   reading, I decided to be incompatible. This always tries to give you
   rounded bits to the precision of the pseudo-op. Former AS did premature
   truncatation, restored noisy bits instead of trailing 0s AND gave you
   a choice of 2 flavours of noise according to which of 2 floating-point
   scanners you directed AS to use.

   In:	input_line_pointer->whitespace before, or '0' of flonum.  */
d4062 2
a4063 2
     /* Clobbers input_line-pointer, checks end-of-line.  */
     register int float_type;	/* 'f':.ffloat ... 'F':.float ...  */
d4066 2
a4067 2
  int length;			/* Number of chars in an object.  */
  register char *err;		/* Error from scanning floating literal.  */
d4082 1
a4082 1
      /* input_line_pointer->1st char of a flonum (we hope!).  */
d4086 4
a4089 3
         letter is legal. Someone may invent a "z" format and this routine
         has no use for such information. Lusers beware: you get
         diagnostics if your input is ill-conditioned.  */
a4131 1

d4134 3
a4136 1
		as_warn (_("unresolvable or nonpositive repeat count; using 1"));
d4152 1
a4152 2
  /* Put terminator back into stream.  */
  --input_line_pointer;
d4154 1
a4154 1
}
d4156 1
a4156 1
/* Return the size of a LEB128 value.  */
d4290 1
a4290 1
  while (size > 0 && bignum[size - 1] == (LITTLENUM_TYPE) -1)
d4310 1
a4310 1
	      || (~(val | ~(((valueT) 1 << loaded) - 1)) == 0
d4337 1
a4337 1
  while (size > 0 && bignum[size - 1] == 0)
d4382 1
a4382 1
emit_leb128_expr (exp, sign)
a4386 1
  int nbytes;
a4405 11
  /* Let check_eh_frame know that data is being emitted.  nbytes == -1 is
     a signal that this is leb128 data.  It shouldn't optimize this away.  */
  nbytes = -1;
  if (check_eh_frame (exp, &nbytes))
    abort ();

  /* Let the backend know that subsequent data may be byte aligned.  */
#ifdef md_cons_align
  md_cons_align (1);
#endif

d4431 1
a4431 1
      /* Otherwise, we have to create a variable sized fragment and
d4434 1
a4434 1
      frag_var (rs_leb128, sizeof_uleb128 (~(valueT) 0), 0, sign,
d4447 4
a4450 6
  do
    {
      expression (&exp);
      emit_leb128_expr (&exp, sign);
    }
  while (*input_line_pointer++ == ',');
d4456 8
a4463 3
/* We read 0 or more ',' separated, double-quoted strings.
   Caller should have checked need_pass_2 is FALSE because we don't
   check it.  */
d4465 4
a4468 4
void
stringer (append_zero)		/* Worker to do .ascii etc statements.  */
     /* Checks end-of-line.  */
     register int append_zero;	/* 0: don't append '\0', else 1.  */
d4477 8
a4484 5
  /* The following awkward logic is to parse ZERO or more strings,
     comma separated. Recall a string expression includes spaces
     before the opening '\"' and spaces after the closing '\"'.
     We fake a leading ',' if there is (supposed to be)
     a 1st, expression. We keep demanding expressions for each ','.  */
d4487 2
a4488 2
      c = 0;			/* Skip loop.  */
      ++input_line_pointer;	/* Compensate for end of loop.  */
d4492 1
a4492 1
      c = ',';			/* Do loop.  */
d4500 1
a4500 1
	  ++input_line_pointer;	/*->1st char of string.  */
d4557 1
a4557 1
    returning values bigger than 1 byte.  xoxorich.  */
d4559 1
a4559 1
unsigned int
d4606 1
a4606 1
	  break;		/* As itself.  */
d4622 1
a4622 3
	    for (i = 0, number = 0;
		 isdigit (c) && i < 3;
		 c = *input_line_pointer++, i++)
a4625 1

d4654 1
a4654 1
	  /* To be compatible with BSD 4.2 as: give the luser a linefeed!!  */
d4668 1
a4668 1
	}
d4674 1
a4674 1
    }
d4676 1
a4676 1
}
d4697 1
a4697 1
static segT
d4719 1
a4719 1
}
d4736 1
a4736 1
char				/* Return terminator.  */
d4738 1
a4738 1
     long *val_pointer;		/* Return value of expression.  */
d4745 6
a4750 3
/* Like demand_copy_string, but return NULL if the string contains any '\0's.
   Give a warning if that happens.  */

a4771 1

d4775 6
a4780 3
/* Demand string, but return a safe (=private) copy of the string.
   Return NULL if we can't read a string here.  */

d4793 1
a4793 1
      input_line_pointer++;	/* Skip opening quote.  */
d4801 1
a4801 1
	 null terminated string.  */
d4813 1
a4813 1
}
d4815 10
a4824 7
/* In:	Input_line_pointer->next character.

   Do:	Skip input_line_pointer over all whitespace.

   Out:	1 if input_line_pointer->end-of-line.  */

int
d4829 1
a4829 1
}
d4831 1
a4831 1
void
d4836 1
a4836 1
  register symbolS *symbolP;	/* Symbol we are working with.  */
d4852 1
a4852 1
      /* Turn '. = mumble' into a .org mumble.  */
a4861 7
#ifdef OBJ_COFF
      int local;

      symbolP = symbol_find (sym_name);
      local = symbolP == NULL;
      if (local)
#endif /* OBJ_COFF */
d4864 1
a4864 1
      if (!reassign
a4867 7

#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      if (local)
	SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF */

d4872 5
a4876 6
    {
      /* Check garbage after the expression.  */
      ignore_rest_of_line ();
      mri_comment_end (stop, stopc);
    }
}
d4878 1
a4878 1
/* .include -- include a file at this point.  */
d4880 2
a4881 1
void
d4890 1
a4890 1
  if (!flag_m68k_mri)
d4904 1
a4904 1
      while (!is_end_of_line[(unsigned char) *input_line_pointer]
a4911 1

d4914 1
a4914 1
      while (!is_end_of_line[(unsigned char) *input_line_pointer])
a4916 1

a4918 1

a4929 1

d4933 1
a4933 1
  /* malloc Storage leak when file is found on path.  FIXME-SOMEDAY.  */
d4936 1
a4936 1
}
d4938 1
a4938 1
void
d4947 1
a4947 1
      include_dirs[0] = ".";	/* Current dir.  */
d4953 2
a4954 3
      include_dirs =
	(char **) realloc (include_dirs,
			   include_dir_count * sizeof (*include_dirs));
d4957 1
a4957 1
  include_dirs[include_dir_count - 1] = path;	/* New one.  */
d4962 1
a4962 1
}
d4978 12
a4993 1
    case DEBUG_DWARF:
d5001 1
d5003 1
a5003 4
      /* ??? We could here indicate to dwarf2dbg.c that something
	 has changed.  However, since there is additional backend
	 support that is required (calling dwarf2_emit_insn), we
	 let dwarf2dbg.c call as_where on its own.  */
d5048 2
a5049 2
      char *name, *label;
      char delim1, delim2;
d5101 1
a5101 1
void
d5112 1
d5120 2
a5121 2
/* Inserts the given line into the input stream.

d5131 1
a5131 1
     const char *line;
d5142 1
a5142 1
   file; no include path searching or dependency registering is performed.  */
d5146 1
a5146 1
     char *path;
d5151 2
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d38 3
a41 1
#include "safe-ctype.h"
d50 1
a50 1
#define TC_START_LABEL(x,y) (x == ':')
d173 4
a319 1
  {"endr", s_bad_endr, 0},
a351 1
  {"incbin", s_incbin, 0},
d536 3
a538 1

d741 2
a742 1
			*s2 = TOLOWER (*s2);
d802 1
a802 1
			  as_bad (_("unknown pseudo-op: `%s'"), s);
d866 1
a866 1
			  if (check_macro (s, &out, &err, &macro))
d909 2
a910 1
	  if ((LOCAL_LABELS_DOLLAR || LOCAL_LABELS_FB) && ISDIGIT (c))
d920 1
a920 1
	      while (ISDIGIT (*input_line_pointer))
a954 1
	      sb sbuf;
a966 1
	      sb_new (&sbuf);
d1028 1
a1028 1
		      new_tmp[size] = 0;
d1039 6
a1045 12
	      /* We've "scrubbed" input to the preferred format.  In the
		 process we may have consumed the whole of the remaining
		 file (and included files).  We handle this formatted
		 input similar to that of macro expansion, letting
		 actual macro expansion (possibly nested) and other
		 input expansion work.  Beware that in messages, line
		 numbers and possibly file names will be incorrect.  */
	      sb_add_string (&sbuf, new_buf);
	      input_scrub_include_sb (&sbuf, input_line_pointer, 0);
	      sb_kill (&sbuf);
	      buffer_limit = input_scrub_next_buffer (&input_line_pointer);
	      free (new_buf);
d1055 2
a1056 2
	  input_line_pointer--;
	  /* Report unknown char as ignored.  */
d1063 14
a1167 13
  if (now_seg == absolute_section)
    {
      if (fill != NULL)
	while (len-- > 0)
	  if (*fill++ != '\0')
	    {
	      as_warn (_("ignoring fill value in absolute section"));
	      break;
	    }
      fill = NULL;
      len = 0;
    }

d1189 1
a1189 1
 just_record_alignment: ATTRIBUTE_UNUSED_LABEL
d1238 1
a1238 1
	    as_bad (_("alignment not a power of 2"));
d1247 1
a1247 1
      as_warn (_("alignment too large: %u assumed"), align);
a1353 8

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }

d1358 1
a1358 3
      *p = 0;
      as_bad (_("expected comma after \"%s\""), name);
      *p = c;
d1369 1
a1369 1
      as_warn (_(".COMMon length (%ld) < 0 ignored"), (long) temp);
d1382 1
a1382 1
      as_bad (_("symbol `%s' is already defined"),
d1393 1
a1393 1
	as_bad (_("length of .comm \"%s\" is already %ld; not changing to %ld"),
d1445 1
a1445 1
  if (!ISDIGIT (*name))
d1453 1
a1453 1
      while (ISDIGIT (*input_line_pointer));
d1483 1
a1483 1
      as_bad (_("symbol `%s' is already defined"), S_GET_NAME (sym));
a1553 14
s_app_file_string (file)
     char *file;
{
#ifdef LISTING
  if (listing)
    listing_source_file (file);
#endif
  register_dependency (file);
#ifdef obj_app_file
  obj_app_file (file);
#endif
}

void
d1578 10
a1587 1
	s_app_file_string (s);
d1607 1
a1607 1
    as_warn (_("line numbers must be positive; line number %d rejected"),
d1703 1
a1703 1
      as_warn (_(".fill size clamped to %d"), BSD_FILL_SIZE_CROCK_8);
d1708 1
a1708 1
      as_warn (_("size negative; .fill ignored"));
d1714 1
a1714 1
	as_warn (_("repeat < 0; .fill ignored"));
d1756 1
a1756 1
         flavoured AS.  The following bizarre behaviour is to be
d1759 1
a1759 1
         extend.  */
d1800 1
a1800 1
	  if (is_end_of_line[(unsigned char) *input_line_pointer])
d1832 1
a1832 1
  err = expand_irp (irpc, 0, &s, &out, get_line_sb);
a1943 8

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }

d1954 1
a1954 1
  if (is_end_of_line[(unsigned char) *input_line_pointer])
d1956 1
a1956 1
      as_bad (_("missing size expression"));
d1962 1
a1962 1
      as_warn (_("BSS length (%d) < 0 ignored"), temp);
d1972 1
a1972 1
      if ((unsigned) temp <= bfd_get_gp_size (stdoutput))
d2001 1
a2001 1
	  as_bad (_("expected comma after size"));
d2009 1
a2009 1
      if (is_end_of_line[(unsigned char) *input_line_pointer])
d2011 1
a2011 1
	  as_bad (_("missing alignment"));
d2027 1
a2027 1
		as_bad (_("alignment not a power of 2"));
d2035 1
a2035 1
	  as_warn (_("alignment too large; %d assumed"), align);
d2040 1
a2040 1
	  as_warn (_("alignment negative; 0 assumed"));
d2108 2
a2109 1
    as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));
a2144 8

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }

d2150 1
a2150 1
      as_bad (_("expected comma after \"%s\""), name);
d2190 1
a2190 1
      as_bad (_("symbol `%s' is already defined"), name);
d2197 1
a2197 2
/* Read a line into an sb.  Returns the character that ended the line
   or zero if there are no more lines.  */
a2203 1
  unsigned char c;
d2231 2
a2232 3
  while ((c = * input_line_pointer ++) != 0
	 && (!is_end_of_line[c]
	     || (inquote != '\0' && c != '\n')))
d2234 1
a2234 1
      if (inquote == c)
d2238 1
a2238 1
	  if (c == quote1)
d2240 1
a2240 1
	  else if (c == quote2)
d2244 1
a2244 1
      sb_add_char (line, c);
d2247 9
a2255 6
  /* Don't skip multiple end-of-line characters, because that breaks support
     for the IA-64 stop bit (;;) which looks like two consecutive end-of-line
     characters but isn't.  Instead just skip one end of line character and
     return the character skipped so that the caller can re-insert it if
     necessary.   */
  return c;
d2258 2
a2259 1
/* Define a macro.  This is an interface to macro.c.  */
d2365 2
a2366 1
    as_bad (_("invalid segment \"%s\""), segment_name (segment));
d2466 1
a2466 1
  if (!ISDIGIT (*name))
d2474 1
a2474 1
      while (ISDIGIT (*input_line_pointer));
d2499 1
a2499 1
      c = TOUPPER (c);
a2662 10
s_bad_endr (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  as_warn (_(".endr encountered without preceeding .rept, .irc, or .irp"));
  demand_empty_rest_of_line ();
}

/* Handle the .rept pseudo-op.  */

void
a2739 8

  if (name == end_name)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }

d2745 1
a2745 1
      as_bad (_("expected comma after \"%s\""), name);
d2803 1
a2803 1
    as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));
d2889 1
a2889 1
	as_bad (_("unsupported variable size or fill value"));
d3014 1
a3014 1
      && ISALPHA (input_line_pointer[1]))
d3039 1
a3039 1
	  as_bad (_("bad floating literal: %s"), err);
d3111 3
a3113 3
      if (ISPRINT (*input_line_pointer))
	as_warn (_("rest of line ignored; first ignored character is `%c'"),
		 *input_line_pointer);
d3115 2
a3116 2
	as_warn (_("rest of line ignored; first ignored character valued 0x%x"),
		 *input_line_pointer);
d3166 1
a3166 1
    as_bad (_("illegal expression"));
d3168 1
a3168 1
    as_bad (_("missing expression"));
d3172 1
a3172 1
	as_bad (_("bignum invalid"));
d3174 1
a3174 1
	as_bad (_("floating point number invalid"));
d3177 2
d3219 1
a3219 1
	as_bad ("attempt to set value of section symbol");
d3507 1
a3507 1
      as_bad (_("floating point number invalid"));
a3537 1
      x->use_jump = 0;
d3603 1
a3603 1
	  as_warn (_("value 0x%lx truncated to 0x%lx"),
d3619 1
a3619 1
	  as_warn (_("bignum truncated to %d bytes"), nbytes);
d3633 1
a3633 1
	  while (size >= CHARS_PER_LITTLENUM)
d3644 1
a3644 1
	  while (size >= CHARS_PER_LITTLENUM)
d3653 1
a3653 1
	  while (nbytes >= CHARS_PER_LITTLENUM)
d3950 1
a3950 1
      as_warn (_("unresolvable or nonpositive repeat count; using 1"));
d4001 1
a4001 1
      as_bad (_("unknown floating type type '%c'"), float_type);
d4023 1
a4023 1
	  as_warn (_("floating point constant too large"));
d4100 1
a4100 1
	  && ISALPHA (input_line_pointer[1]))
d4122 1
a4122 1
	      as_bad (_("bad floating literal: %s"), err);
d4406 1
a4406 1
      as_bad (_("floating point number invalid"));
a4508 9
  /* If we have been switched into the abs_section then we
     will not have an obstack onto which we can hang strings.  */
  if (now_seg == absolute_section)
    {
      as_bad (_("strings must be placed into a section"));
      c = 0;
      ignore_rest_of_line ();
    }
  
d4554 1
a4554 1
	      as_bad (_("expected <nn>"));
d4587 1
a4587 1
      as_warn (_("unterminated string; newline inserted"));
d4638 1
a4638 1
		 ISDIGIT (c) && i < 3;
d4656 1
a4656 1
	    while (ISXDIGIT (c))
d4658 1
a4658 1
		if (ISDIGIT (c))
d4660 1
a4660 1
		else if (ISUPPER (c))
d4673 1
a4673 1
	  as_warn (_("unterminated string; newline inserted"));
d4681 1
a4681 1
	  as_bad (_("bad escaped character in string"));
d4707 1
a4707 1
      as_bad (_("expected address expression"));
a4739 14
get_absolute_expr (exp)
     expressionS *exp;
{
  expression (exp);
  if (exp->X_op != O_constant)
    {
      if (exp->X_op != O_absent)
	as_bad (_("bad or irreducible absolute expression"));
      exp->X_add_number = 0;
    }
  return exp->X_add_number;
}

offsetT
d4744 8
a4751 1
  return get_absolute_expr (&exp);
d4783 1
a4783 1
	      as_bad (_("this string may not contain \'\\0\'"));
d4820 1
a4820 1
      as_warn (_("missing string"));
d4884 1
a4884 1
	as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));
a4902 117
/* .incbin -- include a file verbatim at the current location.  */

void
s_incbin (x)
     int x ATTRIBUTE_UNUSED;
{
  FILE * binfile;
  char * path;
  char * filename;
  char * binfrag;
  long   skip = 0;
  long   count = 0;
  long   bytes;
  int    len;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  SKIP_WHITESPACE ();
  filename = demand_copy_string (& len);
  if (filename == NULL)
    return;

  SKIP_WHITESPACE ();

  /* Look for optional skip and count.  */
  if (* input_line_pointer == ',')
    {
      ++ input_line_pointer;
      skip = get_absolute_expression ();

      SKIP_WHITESPACE ();

      if (* input_line_pointer == ',')
	{
	  ++ input_line_pointer;

	  count = get_absolute_expression ();
	  if (count == 0)
	    as_warn (_(".incbin count zero, ignoring `%s'"), filename);

	  SKIP_WHITESPACE ();
	}
    }

  demand_empty_rest_of_line ();

  /* Try opening absolute path first, then try include dirs.  */
  binfile = fopen (filename, FOPEN_RB);
  if (binfile == NULL)
    {
      int i;

      path = xmalloc ((unsigned long) len + include_dir_maxlen + 5);

      for (i = 0; i < include_dir_count; i++)
	{
	  sprintf (path, "%s/%s", include_dirs[i], filename);

	  binfile = fopen (path, FOPEN_RB);
	  if (binfile != NULL)
	    break;
	}

      if (binfile == NULL)
	as_bad (_("file not found: %s"), filename);
    }
  else
    path = xstrdup (filename);

  if (binfile)
    {
      long   file_len;

      register_dependency (path);

      /* Compute the length of the file.  */
      if (fseek (binfile, 0, SEEK_END) != 0)
	{
	  as_bad (_("seek to end of .incbin file failed `%s'"), path);
	  goto done;
	}
      file_len = ftell (binfile);

      /* If a count was not specified use the size of the file.  */
      if (count == 0)
	count = file_len;

      if (skip + count > file_len)
	{
	  as_bad (_("skip (%ld) + count (%ld) larger than file size (%ld)"),
		  skip, count, file_len);
	  goto done;
	}

      if (fseek (binfile, skip, SEEK_SET) != 0)
	{
	  as_bad (_("could not skip to %ld in file `%s'"), skip, path);
	  goto done;
	}

      /* Allocate frag space and store file contents in it.  */
      binfrag = frag_more (count);

      bytes = fread (binfrag, 1, count, binfile);
      if (bytes < count)
	as_warn (_("truncated file `%s', %ld of %ld bytes read"),
		 path, bytes, count);
    }
done:
  if (binfile != NULL)
    fclose (binfile);
  if (path)
    free (path);
}

d4951 1
a4951 1
      if (0 != (try = fopen (path, FOPEN_RT)))
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d35 1
a35 1
/* Routines that read assembler source text to build spaghetti in memory.
a45 1
#include "dw2gencfi.h"
d53 1
a53 1
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)		\
d55 9
a63 9
    {								\
      if ((SIZE) >= 8)						\
	(P2VAR) = 3;						\
      else if ((SIZE) >= 4)					\
	(P2VAR) = 2;						\
      else if ((SIZE) >= 2)					\
	(P2VAR) = 1;						\
      else							\
	(P2VAR) = 0;						\
d157 1
a157 1
#ifndef TC_CASE_SENSITIVE
d216 20
a235 7
static void do_align (int, char *, int, int);
static void s_align (int, int);
static int hex_float (int, char *);
static segT get_known_segmented_expression (expressionS * expP);
static void pobegin (void);
static int get_line_sb (sb *);
static void generate_file_debug (void);
d238 1
a238 1
read_begin (void)
d432 2
a433 1
pop_insert (const pseudo_typeS *table)
a453 4
#ifndef cfi_pop_insert
#define cfi_pop_insert()	pop_insert(cfi_pseudo_table)
#endif

d455 1
a455 1
pobegin (void)
a470 6

#ifdef TARGET_USE_CFIPOP
  pop_table_name = "cfi";
  pop_override_ok = 1;
  cfi_pop_insert ();
#endif
d489 3
a491 1
scrub_from_string (char *buf, int buflen)
d506 2
a507 1
read_a_source_file (char *name)
d593 2
a594 2
			 pseudo-op specially: we don't want to put the
			 symbol in the symbol table.  */
d615 1
a615 1
	  /* We are at the beginning of a line, or similar place.
d677 4
a680 4
		 That character's place in the input line is now '\0'.
		 S points to the beginning of the symbol.
		   [In case of pseudo-op, s->'.'.]
		 Input_line_pointer->'\0' where c was.  */
a706 3
#ifdef tc_check_label
		  tc_check_label (line_label);
#endif
d726 1
a726 1
#ifndef TC_CASE_SENSITIVE
d743 1
a743 1
			 without a period.  */
d754 3
a756 3
			 WARNING: c has next char, which may be end-of-line.
			 We lookup the pseudo-op table with s+1 because we
			 already know that the pseudo-op begins with a '.'.  */
a759 2
		      if (pop && !pop->poc_handler)
			pop = NULL;
d762 2
a763 2
			 automatic alignment directive.  What a hack
			 this is.  */
d810 2
a811 2
			 Input_line_pointer->1st non-blank char
			 after pseudo-operation.  */
d971 1
a971 1
		     guarantee it...  */
d1057 1
a1057 1
	  demand_empty_rest_of_line ();
d1090 2
a1091 1
mri_comment_field (char *stopcp)
d1122 3
a1124 1
mri_comment_end (char *stop, int stopc)
d1135 2
a1136 1
s_abort (int ignore ATTRIBUTE_UNUSED)
d1148 5
a1152 1
do_align (int n, char *fill, int len, int max)
d1200 3
a1202 1
s_align (int arg, int bytes_p)
d1317 2
a1318 1
s_align_bytes (int arg)
d1327 2
a1328 1
s_align_ptwo (int arg)
d1333 3
a1335 3
symbolS *
s_comm_internal (int param,
		 symbolS *(*comm_parse_extra) (int, symbolS *, addressT))
d1337 5
a1341 5
  char *name;
  char c;
  char *p;
  offsetT temp, size;
  symbolS *symbolP = NULL;
a1343 1
  expressionS exp;
d1358 1
a1358 1
      goto out;
d1363 1
a1363 12
  /* Accept an optional comma after the name.  The comma used to be
     required, but Irix 5 cc does not generate it for .lcomm.  */
  if (*input_line_pointer == ',')
    input_line_pointer++;

  *p = 0;
  temp = get_absolute_expr (&exp);
  size = temp;
#ifdef BFD_ASSEMBLER
  size &= ((offsetT) 2 << (stdoutput->arch_info->bits_per_address - 1)) - 1;
#endif
  if (exp.X_op == O_absent)
d1365 2
a1366 1
      as_bad (_("missing size expression"));
d1369 3
a1371 1
      goto out;
d1373 4
a1376 1
  else if (temp != size || !exp.X_unsigned)
d1378 1
a1378 2
      as_warn (_("size (%ld) out of range, ignored"), (long) temp);
      *p = c;
d1380 3
a1382 1
      goto out;
d1385 1
d1387 2
d1391 2
a1392 3
      symbolP = NULL;
      as_bad (_("symbol `%s' is already defined"), name);
      *p = c;
d1394 3
a1396 1
      goto out;
d1399 8
a1406 10
  size = S_GET_VALUE (symbolP);
  if (size == 0)
    size = temp;
  else if (size != temp)
    as_warn (_("size of \"%s\" is already %ld; not changing to %ld"),
	     name, (long) size, (long) temp);

  *p = c;
  if (comm_parse_extra != NULL)
    symbolP = (*comm_parse_extra) (param, symbolP, size);
d1409 1
a1409 1
      S_SET_VALUE (symbolP, (valueT) size);
d1411 1
d1413 7
a1419 7
      {
	extern int flag_one;
	if (size == 0 || !flag_one)
	  S_GET_OTHER (symbolP) = const_flag;
      }
#endif
    }
a1420 1
  know (symbolP == NULL || symbolP->sy_frag == &zero_address_frag);
d1422 1
a1422 1
 out:
d1425 1
a1425 8
  return symbolP;
}

void
s_comm (int ignore)
{
  s_comm_internal (ignore, NULL);
}
d1432 2
a1433 1
s_mri_common (int small ATTRIBUTE_UNUSED)
d1532 2
a1533 1
s_data (int ignore ATTRIBUTE_UNUSED)
d1563 2
a1564 1
s_app_file_string (char *file)
d1577 2
a1578 1
s_app_file (int appfile)
d1593 1
a1593 1
	 backquote.  */
d1611 2
a1612 1
s_app_line (int ignore ATTRIBUTE_UNUSED)
d1638 2
a1639 1
s_end (int ignore ATTRIBUTE_UNUSED)
d1644 1
a1644 1
	 but we don't support that.  */
d1656 2
a1657 1
s_err (int ignore ATTRIBUTE_UNUSED)
d1666 2
a1667 1
s_fail (int ignore ATTRIBUTE_UNUSED)
d1689 2
a1690 1
s_fill (int ignore ATTRIBUTE_UNUSED)
d1770 4
a1773 4
	 flavoured AS.  The following bizarre behaviour is to be
	 compatible with above.  I guess they tried to take up to 8
	 bytes from a 4-byte expression and they forgot to sign
	 extend.  */
d1780 2
a1781 2
	 but emits no error message because it seems a legal thing to do.
	 It is a degenerate case of .fill but could be emitted by a
d1788 2
a1789 1
s_globl (int ignore ATTRIBUTE_UNUSED)
d1829 2
a1830 1
s_irp (int irpc)
d1863 2
a1864 1
s_linkonce (int ignore ATTRIBUTE_UNUSED)
d1934 8
a1941 2
void
bss_alloc (symbolS *symbolP, addressT size, int align)
d1943 5
a1947 1
  char *pfrag;
d1950 2
d1954 35
d1994 1
a1994 1
      if (size <= bfd_get_gp_size (stdoutput))
a2005 1
  subseg_set (bss_seg, 1);
d2007 1
a2007 1
  if (align)
d2009 5
a2013 2
      record_alignment (bss_seg, align);
      frag_align (align, 0, 0);
d2016 4
a2019 3
  /* Detach from old frag.  */
  if (S_GET_SEGMENT (symbolP) == bss_seg)
    symbol_get_frag (symbolP)->fr_symbol = NULL;
d2021 6
a2026 3
  symbol_set_frag (symbolP, frag_now);
  pfrag = frag_var (rs_org, 1, 1, 0, symbolP, size, NULL);
  *pfrag = 0;
d2028 2
a2029 4
#ifdef S_SET_SIZE
  S_SET_SIZE (symbolP, size);
#endif
  S_SET_SEGMENT (symbolP, bss_seg);
d2031 5
a2035 7
#ifdef OBJ_COFF
  /* The symbol may already have been created with a preceding
     ".globl" directive -- be careful not to step on storage class
     in that case.  Otherwise, set it to static.  */
  if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
    S_SET_STORAGE_CLASS (symbolP, C_STAT);
#endif /* OBJ_COFF */
d2037 1
a2037 2
  subseg_set (current_seg, current_subseg);
}
d2039 6
a2044 5
offsetT
parse_align (int align_bytes)
{
  expressionS exp;
  addressT align;
d2046 7
a2052 8
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
    no_align:
      as_bad (_("expected alignment after size"));
      ignore_rest_of_line ();
      return -1;
    }
d2054 10
a2063 2
  input_line_pointer++;
  SKIP_WHITESPACE ();
d2065 1
a2065 8
  align = get_absolute_expr (&exp);
  if (exp.X_op == O_absent)
    goto no_align;

  if (!exp.X_unsigned)
    {
      as_warn (_("alignment negative; 0 assumed"));
      align = 0;
d2067 1
a2067 2

  if (align_bytes && align != 0)
d2069 3
a2071 5
      /* convert to a power of 2 alignment */
      unsigned int alignp2 = 0;
      while ((align & 1) == 0)
	align >>= 1, ++alignp2;
      if (align != 1)
d2073 3
a2075 3
	  as_bad (_("alignment not a power of 2"));
	  ignore_rest_of_line ();
	  return -1;
d2077 1
a2077 1
      align = alignp2;
a2078 2
  return align;
}
d2080 34
a2113 5
/* Called from s_comm_internal after symbol name and size have been
   parsed.  NEEDS_ALIGN is 0 if it was an ".lcomm" (2 args only),
   1 if this was a ".bss" directive which has a 3rd argument
   (alignment as a power of 2), or 2 if this was a ".bss" directive
   with alignment in bytes.  */
d2115 9
a2123 4
symbolS *
s_lcomm_internal (int needs_align, symbolS *symbolP, addressT size)
{
  addressT align = 0;
d2125 3
a2127 5
  if (needs_align)
    {
      align = parse_align (needs_align - 1);
      if (align == (addressT) -1)
	return NULL;
d2130 3
a2132 2
    /* Assume some objects may require alignment on some systems.  */
    TC_IMPLICIT_LCOMM_ALIGNMENT (size, align);
d2134 1
a2134 2
  bss_alloc (symbolP, size, align);
  return symbolP;
d2138 2
a2139 1
s_lcomm (int needs_align)
d2141 1
a2141 1
  s_comm_internal (needs_align, s_lcomm_internal);
d2145 2
a2146 1
s_lcomm_bytes (int needs_align)
d2148 1
a2148 1
  s_comm_internal (needs_align * 2, s_lcomm_internal);
d2152 2
a2153 1
s_lsym (int ignore ATTRIBUTE_UNUSED)
d2230 2
a2231 1
get_line_sb (sb *line)
d2290 2
a2291 1
s_macro (int ignore ATTRIBUTE_UNUSED)
d2338 2
a2339 1
s_mexit (int ignore ATTRIBUTE_UNUSED)
d2348 2
a2349 1
s_mri (int ignore ATTRIBUTE_UNUSED)
d2387 4
a2390 1
do_org (segT segment, expressionS *exp, int fill)
d2425 2
a2426 1
s_org (int ignore ATTRIBUTE_UNUSED)
d2481 2
a2482 1
s_mri_sect (char *type ATTRIBUTE_UNUSED)
d2646 2
a2647 1
s_print (int ignore ATTRIBUTE_UNUSED)
d2653 1
a2653 2
  if (s != NULL)
    printf ("%s\n", s);
d2660 2
a2661 1
s_purgem (int ignore ATTRIBUTE_UNUSED)
d2690 2
a2691 1
s_bad_endr (int ignore ATTRIBUTE_UNUSED)
d2700 2
a2701 1
s_rept (int ignore ATTRIBUTE_UNUSED)
d2714 4
a2717 1
do_repeat (int count, const char *start, const char *end)
d2749 2
a2750 1
end_repeat (int extra)
d2762 2
a2763 1
s_set (int equiv)
d2820 1
a2820 1
	 for this symbol.  */
d2855 2
a2856 1
s_space (int mult)
d3028 2
a3029 1
s_float_space (int float_type)
d3109 2
a3110 1
s_struct (int ignore ATTRIBUTE_UNUSED)
d3125 2
a3126 1
s_text (int ignore ATTRIBUTE_UNUSED)
a3137 4

/* Verify that we are at the end of a line.  If not, issue an error and
   skip to EOL.  */

d3139 1
a3139 1
demand_empty_rest_of_line (void)
d3145 10
d3157 1
a3157 1
	as_bad (_("junk at end of line, first unrecognized character is `%c'"),
d3160 1
a3160 1
	as_bad (_("junk at end of line, first unrecognized character valued 0x%x"),
d3162 4
a3165 1
      ignore_rest_of_line ();
a3166 14
  
  /* Return pointing just after end-of-line.  */
  know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
}

/* Silently advance to the end of line.  Use this after already having
   issued an error about something bad.  */

void
ignore_rest_of_line (void)
{
  while (input_line_pointer < buffer_limit
	 && !is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;
d3175 1
a3175 1
discard_rest_of_line (void)
d3188 1
a3188 1
	Input_line_pointer->expression.
d3191 2
a3192 2
	Tried to set symbol to value of expression.
	Will change symbols type, value, and frag;  */
d3195 2
a3196 1
pseudo_set (symbolS *symbolP)
d3289 1
a3289 1
/*			cons()
d3314 1
a3314 1
parse_mri_cons (expressionS *exp, unsigned int nbytes);
d3321 1
a3321 1
parse_bitfield_cons (expressionS *exp, unsigned int nbytes);
d3326 1
a3326 1
parse_repeat_cons (expressionS *exp, unsigned int nbytes);
a3334 8
void
do_parse_cons_expression (expressionS *exp,
			  int nbytes ATTRIBUTE_UNUSED)
{
  TC_PARSE_CONS_EXPRESSION (exp, nbytes);
}


d3339 3
a3341 2
cons_worker (register int nbytes,	/* 1=.byte, 2=.word, 4=.long.  */
	     int rva)
d3404 2
a3405 1
cons (int size)
d3411 2
a3412 1
s_rva (int size)
d3421 3
a3423 1
emit_expr (expressionS *exp, unsigned int nbytes)
a3432 2
  dot_value = frag_now_fix ();

d3777 1
a3777 1
   The rules are: pack least significant bit first, if a field doesn't
d4011 3
a4013 1
hex_float (int float_type, char *bytes)
d4097 1
a4097 1
/*			float_cons()
d4108 1
a4108 1
   truncation, restored noisy bits instead of trailing 0s AND gave you
d4115 3
a4117 2
float_cons (/* Clobbers input_line-pointer, checks end-of-line.  */
	    register int float_type	/* 'f':.ffloat ... 'F':.float ...  */)
d4140 3
a4142 3
	 letter is legal. Someone may invent a "z" format and this routine
	 has no use for such information. Lusers beware: you get
	 diagnostics if your input is ill-conditioned.  */
d4148 1
a4148 1
	 point with the exact digits specified.  */
d4212 2
a4213 1
sizeof_sleb128 (offsetT value)
d4234 2
a4235 1
sizeof_uleb128 (valueT value)
d4252 3
a4254 1
sizeof_leb128 (valueT value, int sign)
d4265 3
a4267 1
output_sleb128 (char *p, offsetT value)
d4294 3
a4296 1
output_uleb128 (char *p, valueT value)
d4316 4
a4319 1
output_leb128 (char *p, valueT value, int sign)
d4332 4
a4335 1
output_big_sleb128 (char *p, LITTLENUM_TYPE *bignum, int size)
d4378 4
a4381 1
output_big_uleb128 (char *p, LITTLENUM_TYPE *bignum, int size)
d4420 4
a4423 1
output_big_leb128 (char *p, LITTLENUM_TYPE *bignum, int size, int sign)
d4435 3
a4437 1
emit_leb128_expr (expressionS *exp, int sign)
d4507 2
a4508 1
s_leb128 (int sign)
a4511 8
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

d4528 3
a4530 3
stringer (/* Worker to do .ascii etc statements.  */
	  /* Checks end-of-line.  */
	  register int append_zero	/* 0: don't append '\0', else 1.  */)
d4561 1
a4561 1

d4583 5
a4587 5
	     will emit .string with a filename in the .debug section
	     after a sequence of constants.  See the comment in
	     emit_expr for the sequence.  emit_expr will set
	     dwarf_file_string to non-zero if this string might be a
	     source file name.  */
d4628 1
a4628 1
next_char_of_string (void)
d4750 2
a4751 1
get_segmented_expression (register expressionS *expP)
d4769 2
a4770 1
get_known_segmented_expression (register expressionS *expP)
d4793 2
a4794 1
get_absolute_expr (expressionS *exp)
d4807 1
a4807 1
get_absolute_expression (void)
d4815 2
a4816 1
get_absolute_expression_and_terminator (long *val_pointer /* Return value of expression.  */)
d4827 2
a4828 1
demand_copy_C_string (int *len_pointer)
d4855 2
a4856 1
demand_copy_string (int *lenP)
d4880 1
a4880 1
      as_bad (_("missing string"));
d4895 1
a4895 1
is_it_end_of_statement (void)
d4902 3
a4904 1
equals (char *sym_name, int reassign)
d4958 1
a4958 1
      demand_empty_rest_of_line ();
d4966 2
a4967 1
s_incbin (int x ATTRIBUTE_UNUSED)
d5083 2
a5084 1
s_include (int arg ATTRIBUTE_UNUSED)
d5097 1
a5097 1
	     called ignore_rest_of_line.  */
d5144 2
a5145 1
add_include_dir (char *path)
d5173 1
a5173 1
generate_file_debug (void)
d5182 1
a5182 1
generate_lineno_debug (void)
d5209 2
a5210 1
s_func (int end_p)
d5219 3
a5221 1
do_s_func (int end_p, const char *default_prefix)
d5299 2
a5300 1
s_ignore (int arg ATTRIBUTE_UNUSED)
d5310 2
a5311 1
read_print_statistics (FILE *file)
d5321 1
a5321 1
   An appropriate use of this function would be substitution of input lines when
d5326 2
a5327 1
input_scrub_insert_line (const char *line)
d5341 2
a5342 1
input_scrub_insert_file (char *path)
@


