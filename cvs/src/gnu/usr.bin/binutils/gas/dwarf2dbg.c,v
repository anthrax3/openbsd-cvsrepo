head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.18
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.20
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.16
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.12
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.14
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.10
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.4.0.32
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.30
	OPENBSD_5_0:1.1.1.4.0.28
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.26
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.24
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.20
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.22
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.18
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.16
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.14
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.12
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.10
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.8
	OPENBSD_4_0_BASE:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.02.13.03.46.46;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.12.14.46.09;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.46.09;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.31.28;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.25;	author drahn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.11.02.20.22.42;	author miod;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Add support for .loc directive options basic_block, prologue_end, and epilogue_begin.

Backported from binutils 2.17.

ok miod@@
@
text
@/* dwarf2dbg.c - DWARF2 debug support
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
   Contributed by David Mosberger-Tang <davidm@@hpl.hp.com>

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Logical line numbers can be controlled by the compiler via the
   following directives:

	.file FILENO "file.c"
	.loc  FILENO LINENO [COLUMN] [basic_block] [prologue_end] \
	      [epilogue_begin] [is_stmt VALUE] [isa VALUE]
*/

#include "ansidecl.h"
#include "as.h"
#include "safe-ctype.h"

#ifdef HAVE_LIMITS_H
#include <limits.h>
#else
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifndef INT_MAX
#define INT_MAX (int) (((unsigned) (-1)) >> 1)
#endif
#endif

#include "dwarf2dbg.h"
#include <filenames.h>

#ifndef DWARF2_FORMAT
# define DWARF2_FORMAT() dwarf2_format_32bit
#endif

#ifndef DWARF2_ADDR_SIZE
# define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8)
#endif

#ifdef BFD_ASSEMBLER

#include "subsegs.h"

#include "elf/dwarf2.h"

/* Since we can't generate the prolog until the body is complete, we
   use three different subsegments for .debug_line: one holding the
   prolog, one for the directory and filename info, and one for the
   body ("statement program").  */
#define DL_PROLOG	0
#define DL_FILES	1
#define DL_BODY		2

/* First special line opcde - leave room for the standard opcodes.
   Note: If you want to change this, you'll have to update the
   "standard_opcode_lengths" table that is emitted below in
   out_debug_line().  */
#define DWARF2_LINE_OPCODE_BASE		13

#ifndef DWARF2_LINE_BASE
  /* Minimum line offset in a special line info. opcode.  This value
     was chosen to give a reasonable range of values.  */
# define DWARF2_LINE_BASE		-5
#endif

/* Range of line offsets in a special line info. opcode.  */
#ifndef DWARF2_LINE_RANGE
# define DWARF2_LINE_RANGE		14
#endif

#ifndef DWARF2_LINE_MIN_INSN_LENGTH
  /* Define the architecture-dependent minimum instruction length (in
     bytes).  This value should be rather too small than too big.  */
# define DWARF2_LINE_MIN_INSN_LENGTH	1
#endif

/* Flag that indicates the initial value of the is_stmt_start flag.  */
#define	DWARF2_LINE_DEFAULT_IS_STMT	1

/* Given a special op, return the line skip amount.  */
#define SPECIAL_LINE(op) \
	(((op) - DWARF2_LINE_OPCODE_BASE)%DWARF2_LINE_RANGE + DWARF2_LINE_BASE)

/* Given a special op, return the address skip amount (in units of
   DWARF2_LINE_MIN_INSN_LENGTH.  */
#define SPECIAL_ADDR(op) (((op) - DWARF2_LINE_OPCODE_BASE)/DWARF2_LINE_RANGE)

/* The maximum address skip amount that can be encoded with a special op.  */
#define MAX_SPECIAL_ADDR_DELTA		SPECIAL_ADDR(255)

struct line_entry {
  struct line_entry *next;
  fragS *frag;
  addressT frag_ofs;
  struct dwarf2_line_info loc;
};

struct line_subseg {
  struct line_subseg *next;
  subsegT subseg;
  struct line_entry *head;
  struct line_entry **ptail;
};

struct line_seg {
  struct line_seg *next;
  segT seg;
  struct line_subseg *head;
  symbolS *text_start;
  symbolS *text_end;
};

/* Collects data for all line table entries during assembly.  */
static struct line_seg *all_segs;

struct file_entry {
  const char *filename;
  unsigned int dir;
};

/* Table of files used by .debug_line.  */
static struct file_entry *files;
static unsigned int files_in_use;
static unsigned int files_allocated;

/* Table of directories used by .debug_line.  */
static char **dirs;
static unsigned int dirs_in_use;
static unsigned int dirs_allocated;

/* TRUE when we've seen a .loc directive recently.  Used to avoid
   doing work when there's nothing to do.  */
static bfd_boolean loc_directive_seen;

/* Current location as indicated by the most recent .loc directive.  */
static struct dwarf2_line_info current = {
  1, 1, 0, 0,
  DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0
};

/* The size of an address on the target.  */
static unsigned int sizeof_address;

static struct line_subseg *get_line_subseg (segT, subsegT);
static unsigned int get_filenum (const char *, unsigned int);
static struct frag *first_frag_for_seg (segT);
static struct frag *last_frag_for_seg (segT);
static void out_byte (int);
static void out_opcode (int);
static void out_two (int);
static void out_four (int);
static void out_abbrev (int, int);
static void out_uleb128 (addressT);
static offsetT get_frag_fix (fragS *);
static void out_set_addr (segT, fragS *, addressT);
static int size_inc_line_addr (int, addressT);
static void emit_inc_line_addr (int, addressT, char *, int);
static void out_inc_line_addr (int, addressT);
static void relax_inc_line_addr (int, segT, fragS *, addressT,
				 fragS *, addressT);
static void process_entries (segT, struct line_entry *);
static void out_file_list (void);
static void out_debug_line (segT);
static void out_debug_aranges (segT, segT);
static void out_debug_abbrev (segT);
static void out_debug_info (segT, segT, segT);

#ifndef TC_DWARF2_EMIT_OFFSET
# define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset
static void generic_dwarf2_emit_offset (symbolS *, unsigned int);

/* Create an offset to .dwarf2_*.  */

static void
generic_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
{
  expressionS expr;

  expr.X_op = O_symbol;
  expr.X_add_symbol = symbol;
  expr.X_add_number = 0;
  emit_expr (&expr, size);
}
#endif

/* Find or create an entry for SEG+SUBSEG in ALL_SEGS.  */

static struct line_subseg *
get_line_subseg (segT seg, subsegT subseg)
{
  static segT last_seg;
  static subsegT last_subseg;
  static struct line_subseg *last_line_subseg;

  struct line_seg *s;
  struct line_subseg **pss, *ss;

  if (seg == last_seg && subseg == last_subseg)
    return last_line_subseg;

  for (s = all_segs; s; s = s->next)
    if (s->seg == seg)
      goto found_seg;

  s = (struct line_seg *) xmalloc (sizeof (*s));
  s->next = all_segs;
  s->seg = seg;
  s->head = NULL;
  all_segs = s;

 found_seg:
  for (pss = &s->head; (ss = *pss) != NULL ; pss = &ss->next)
    {
      if (ss->subseg == subseg)
	goto found_subseg;
      if (ss->subseg > subseg)
	break;
    }

  ss = (struct line_subseg *) xmalloc (sizeof (*ss));
  ss->next = *pss;
  ss->subseg = subseg;
  ss->head = NULL;
  ss->ptail = &ss->head;
  *pss = ss;

 found_subseg:
  last_seg = seg;
  last_subseg = subseg;
  last_line_subseg = ss;

  return ss;
}

/* Record an entry for LOC occurring at OFS within the current fragment.  */

void
dwarf2_gen_line_info (addressT ofs, struct dwarf2_line_info *loc)
{
  struct line_subseg *ss;
  struct line_entry *e;
  static unsigned int line = -1;
  static unsigned int filenum = -1;

  /* Early out for as-yet incomplete location information.  */
  if (loc->filenum == 0 || loc->line == 0)
    return;

  /* Don't emit sequences of line symbols for the same line when the
     symbols apply to assembler code.  It is necessary to emit
     duplicate line symbols when a compiler asks for them, because GDB
     uses them to determine the end of the prologue.  */
  if (debug_type == DEBUG_DWARF2
      && line == loc->line && filenum == loc->filenum)
    return;

  line = loc->line;
  filenum = loc->filenum;

  e = (struct line_entry *) xmalloc (sizeof (*e));
  e->next = NULL;
  e->frag = frag_now;
  e->frag_ofs = ofs;
  e->loc = *loc;

  ss = get_line_subseg (now_seg, now_subseg);
  *ss->ptail = e;
  ss->ptail = &e->next;
}

/* Returns the current source information.  If .file directives have
   been encountered, the info for the corresponding source file is
   returned.  Otherwise, the info for the assembly source file is
   returned.  */

void
dwarf2_where (struct dwarf2_line_info *line)
{
  if (debug_type == DEBUG_DWARF2)
    {
      char *filename;
      as_where (&filename, &line->line);
      line->filenum = get_filenum (filename, 0);
      line->column = 0;
      line->flags = DWARF2_FLAG_IS_STMT;
      line->isa = current.isa;
    }
  else
    *line = current;
}

/* A hook to allow the target backend to inform the line number state 
   machine of isa changes when assembler debug info is enabled.  */

void
dwarf2_set_isa (unsigned int isa)
{
  current.isa = isa;
}

/* Called for each machine instruction, or relatively atomic group of
   machine instructions (ie built-in macro).  The instruction or group
   is SIZE bytes in length.  If dwarf2 line number generation is called
   for, emit a line statement appropriately.  */

void
dwarf2_emit_insn (int size)
{
  struct dwarf2_line_info loc;

  if (loc_directive_seen)
    {
      /* Use the last location established by a .loc directive, not
	 the value returned by dwarf2_where().  That calls as_where()
	 which will return either the logical input file name (foo.c)
	or the physical input file name (foo.s) and not the file name
	specified in the most recent .loc directive (eg foo.h).  */
      loc = current;

      /* Unless we generate DWARF2 debugging information for each
	 assembler line, we only emit one line symbol for one LOC.  */
      if (debug_type != DEBUG_DWARF2)
	loc_directive_seen = FALSE;
    }
  else if (debug_type != DEBUG_DWARF2)
    return;
  else
    dwarf2_where (&loc);

  dwarf2_gen_line_info (frag_now_fix () - size, &loc);

  current.flags &= ~(DWARF2_FLAG_BASIC_BLOCK
		     | DWARF2_FLAG_PROLOGUE_END
		     | DWARF2_FLAG_EPILOGUE_BEGIN);
}

/* Get a .debug_line file number for FILENAME.  If NUM is nonzero,
   allocate it on that file table slot, otherwise return the first
   empty one.  */

static unsigned int
get_filenum (const char *filename, unsigned int num)
{
  static unsigned int last_used, last_used_dir_len;
  const char *file;
  size_t dir_len;
  unsigned int i, dir;

  if (num == 0 && last_used)
    {
      if (! files[last_used].dir
	  && strcmp (filename, files[last_used].filename) == 0)
	return last_used;
      if (files[last_used].dir
	  && strncmp (filename, dirs[files[last_used].dir],
		      last_used_dir_len) == 0
	  && IS_DIR_SEPARATOR (filename [last_used_dir_len])
	  && strcmp (filename + last_used_dir_len + 1,
		     files[last_used].filename) == 0)
	return last_used;
    }

  file = lbasename (filename);
  /* Don't make empty string from / or A: from A:/ .  */
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  if (file <= filename + 3)
    file = filename;
#else
  if (file == filename + 1)
    file = filename;
#endif
  dir_len = file - filename;

  dir = 0;
  if (dir_len)
    {
      --dir_len;
      for (dir = 1; dir < dirs_in_use; ++dir)
	if (strncmp (filename, dirs[dir], dir_len) == 0
	    && dirs[dir][dir_len] == '\0')
	  break;

      if (dir >= dirs_in_use)
	{
	  if (dir >= dirs_allocated)
	    {
	      dirs_allocated = dir + 32;
	      dirs = (char **)
		     xrealloc (dirs, (dir + 32) * sizeof (const char *));
	    }

	  dirs[dir] = xmalloc (dir_len + 1);
	  memcpy (dirs[dir], filename, dir_len);
	  dirs[dir][dir_len] = '\0';
	  dirs_in_use = dir + 1;
	}
    }

  if (num == 0)
    {
      for (i = 1; i < files_in_use; ++i)
	if (files[i].dir == dir
	    && files[i].filename
	    && strcmp (file, files[i].filename) == 0)
	  {
	    last_used = i;
	    last_used_dir_len = dir_len;
	    return i;
	  }
    }
  else
    i = num;

  if (i >= files_allocated)
    {
      unsigned int old = files_allocated;

      files_allocated = i + 32;
      files = (struct file_entry *)
	xrealloc (files, (i + 32) * sizeof (struct file_entry));

      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));
    }

  files[i].filename = num ? file : xstrdup (file);
  files[i].dir = dir;
  files_in_use = i + 1;
  last_used = i;
  last_used_dir_len = dir_len;

  return i;
}

/* Handle two forms of .file directive:
   - Pass .file "source.c" to s_app_file
   - Handle .file 1 "source.c" by adding an entry to the DWARF-2 file table

   If an entry is added to the file table, return a pointer to the filename. */

char *
dwarf2_directive_file (int dummy ATTRIBUTE_UNUSED)
{
  offsetT num;
  char *filename;
  int filename_len;

  /* Continue to accept a bare string and pass it off.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      s_app_file (0);
      return NULL;
    }

  num = get_absolute_expression ();
  filename = demand_copy_C_string (&filename_len);
  if (filename == NULL)
    return NULL;
  demand_empty_rest_of_line ();

  if (num < 1)
    {
      as_bad (_("file number less than one"));
      return NULL;
    }

  if (num < (int) files_in_use && files[num].filename != 0)
    {
      as_bad (_("file number %ld already allocated"), (long) num);
      return NULL;
    }

  get_filenum (filename, num);

  return filename;
}

void
dwarf2_directive_loc (int dummy ATTRIBUTE_UNUSED)
{
  offsetT filenum, line;

  filenum = get_absolute_expression ();
  SKIP_WHITESPACE ();
  line = get_absolute_expression ();

  if (filenum < 1)
    {
      as_bad (_("file number less than one"));
      return;
    }
  if (filenum >= (int) files_in_use || files[filenum].filename == 0)
    {
      as_bad (_("unassigned file number %ld"), (long) filenum);
      return;
    }

  current.filenum = filenum;
  current.line = line;

#ifndef NO_LISTING
  if (listing)
    {
      if (files[filenum].dir)
	{
	  size_t dir_len = strlen (dirs[files[filenum].dir]);
	  size_t file_len = strlen (files[filenum].filename);
	  char *cp = (char *) alloca (dir_len + 1 + file_len + 1);

	  memcpy (cp, dirs[files[filenum].dir], dir_len);
	  cp[dir_len] = '/';
	  memcpy (cp + dir_len + 1, files[filenum].filename, file_len);
	  cp[dir_len + file_len + 1] = '\0';
	  listing_source_file (cp);
	}
      else
	listing_source_file (files[filenum].filename);
      listing_source_line (line);
    }
#endif

  SKIP_WHITESPACE ();
  if (ISDIGIT (*input_line_pointer))
    {
      current.column = get_absolute_expression ();
      SKIP_WHITESPACE ();
    }

  while (ISALPHA (*input_line_pointer))
    {
      char *p, c;
      offsetT value;

      p = input_line_pointer;
      c = get_symbol_end ();

      if (strcmp (p, "basic_block") == 0)
	{
	  current.flags |= DWARF2_FLAG_BASIC_BLOCK;
	  *input_line_pointer = c;
	}
      else if (strcmp (p, "prologue_end") == 0)
	{
	  current.flags |= DWARF2_FLAG_PROLOGUE_END;
	  *input_line_pointer = c;
	}
      else if (strcmp (p, "epilogue_begin") == 0)
	{
	  current.flags |= DWARF2_FLAG_EPILOGUE_BEGIN;
	  *input_line_pointer = c;
	}
      else if (strcmp (p, "is_stmt") == 0)
	{
	  *input_line_pointer = c;
	  value = get_absolute_expression ();
	  if (value == 0)
	    current.flags &= ~DWARF2_FLAG_IS_STMT;
	  else if (value == 1)
	    current.flags |= DWARF2_FLAG_IS_STMT;
	  else
	    {
	      as_bad (_("is_stmt value not 0 or 1"));
	      return;
	    }
	}
      else if (strcmp (p, "isa") == 0)
	{
          *input_line_pointer = c;
	  value = get_absolute_expression ();
	  if (value >= 0)
	    current.isa = value;
	  else
	    {
	      as_bad (_("isa number less than zero"));
	      return;
	    }
	}
      else
	{
	  as_bad (_("unknown .loc sub-directive `%s'"), p);
          *input_line_pointer = c;
	  return;
	}

      SKIP_WHITESPACE ();
    }

  demand_empty_rest_of_line ();
  loc_directive_seen = TRUE;
}

static struct frag *
first_frag_for_seg (segT seg)
{
  frchainS *f, *first = NULL;

  for (f = frchain_root; f; f = f->frch_next)
    if (f->frch_seg == seg
	&& (! first || first->frch_subseg > f->frch_subseg))
      first = f;

  return first ? first->frch_root : NULL;
}

static struct frag *
last_frag_for_seg (segT seg)
{
  frchainS *f, *last = NULL;

  for (f = frchain_root; f; f = f->frch_next)
    if (f->frch_seg == seg
	&& (! last || last->frch_subseg < f->frch_subseg))
      last= f;

  return last ? last->frch_last : NULL;
}

/* Emit a single byte into the current segment.  */

static inline void
out_byte (int byte)
{
  FRAG_APPEND_1_CHAR (byte);
}

/* Emit a statement program opcode into the current segment.  */

static inline void
out_opcode (int opc)
{
  out_byte (opc);
}

/* Emit a two-byte word into the current segment.  */

static inline void
out_two (int data)
{
  md_number_to_chars (frag_more (2), data, 2);
}

/* Emit a four byte word into the current segment.  */

static inline void
out_four (int data)
{
  md_number_to_chars (frag_more (4), data, 4);
}

/* Emit an unsigned "little-endian base 128" number.  */

static void
out_uleb128 (addressT value)
{
  output_leb128 (frag_more (sizeof_leb128 (value, 0)), value, 0);
}

/* Emit a tuple for .debug_abbrev.  */

static inline void
out_abbrev (int name, int form)
{
  out_uleb128 (name);
  out_uleb128 (form);
}

/* Get the size of a fragment.  */

static offsetT
get_frag_fix (fragS *frag)
{
  frchainS *fr;

  if (frag->fr_next)
    return frag->fr_fix;

  /* If a fragment is the last in the chain, special measures must be
     taken to find its size before relaxation, since it may be pending
     on some subsegment chain.  */
  for (fr = frchain_root; fr; fr = fr->frch_next)
    if (fr->frch_last == frag)
      return (char *) obstack_next_free (&fr->frch_obstack) - frag->fr_literal;

  abort ();
}

/* Set an absolute address (may result in a relocation entry).  */

static void
out_set_addr (segT seg, fragS *frag, addressT ofs)
{
  expressionS expr;
  symbolS *sym;

  sym = symbol_temp_new (seg, ofs, frag);

  out_opcode (DW_LNS_extended_op);
  out_uleb128 (sizeof_address + 1);

  out_opcode (DW_LNE_set_address);
  expr.X_op = O_symbol;
  expr.X_add_symbol = sym;
  expr.X_add_number = 0;
  emit_expr (&expr, sizeof_address);
}

#if DWARF2_LINE_MIN_INSN_LENGTH > 1
static void scale_addr_delta (addressT *);

static void
scale_addr_delta (addressT *addr_delta)
{
  static int printed_this = 0;
  if (*addr_delta % DWARF2_LINE_MIN_INSN_LENGTH != 0)
    {
      if (!printed_this)
	as_bad("unaligned opcodes detected in executable segment");
      printed_this = 1;
    }
  *addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
}
#else
#define scale_addr_delta(A)
#endif

/* Encode a pair of line and address skips as efficiently as possible.
   Note that the line skip is signed, whereas the address skip is unsigned.

   The following two routines *must* be kept in sync.  This is
   enforced by making emit_inc_line_addr abort if we do not emit
   exactly the expected number of bytes.  */

static int
size_inc_line_addr (int line_delta, addressT addr_delta)
{
  unsigned int tmp, opcode;
  int len = 0;

  /* Scale the address delta by the minimum instruction length.  */
  scale_addr_delta (&addr_delta);

  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.
     We cannot use special opcodes here, since we want the end_sequence
     to emit the matrix entry.  */
  if (line_delta == INT_MAX)
    {
      if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
	len = 1;
      else
	len = 1 + sizeof_leb128 (addr_delta, 0);
      return len + 3;
    }

  /* Bias the line delta by the base.  */
  tmp = line_delta - DWARF2_LINE_BASE;

  /* If the line increment is out of range of a special opcode, we
     must encode it with DW_LNS_advance_line.  */
  if (tmp >= DWARF2_LINE_RANGE)
    {
      len = 1 + sizeof_leb128 (line_delta, 1);
      line_delta = 0;
      tmp = 0 - DWARF2_LINE_BASE;
    }

  /* Bias the opcode by the special opcode base.  */
  tmp += DWARF2_LINE_OPCODE_BASE;

  /* Avoid overflow when addr_delta is large.  */
  if (addr_delta < 256 + MAX_SPECIAL_ADDR_DELTA)
    {
      /* Try using a special opcode.  */
      opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	return len + 1;

      /* Try using DW_LNS_const_add_pc followed by special op.  */
      opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	return len + 2;
    }

  /* Otherwise use DW_LNS_advance_pc.  */
  len += 1 + sizeof_leb128 (addr_delta, 0);

  /* DW_LNS_copy or special opcode.  */
  len += 1;

  return len;
}

static void
emit_inc_line_addr (int line_delta, addressT addr_delta, char *p, int len)
{
  unsigned int tmp, opcode;
  int need_copy = 0;
  char *end = p + len;

  /* Scale the address delta by the minimum instruction length.  */
  scale_addr_delta (&addr_delta);

  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.
     We cannot use special opcodes here, since we want the end_sequence
     to emit the matrix entry.  */
  if (line_delta == INT_MAX)
    {
      if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
	*p++ = DW_LNS_const_add_pc;
      else
	{
	  *p++ = DW_LNS_advance_pc;
	  p += output_leb128 (p, addr_delta, 0);
	}

      *p++ = DW_LNS_extended_op;
      *p++ = 1;
      *p++ = DW_LNE_end_sequence;
      goto done;
    }

  /* Bias the line delta by the base.  */
  tmp = line_delta - DWARF2_LINE_BASE;

  /* If the line increment is out of range of a special opcode, we
     must encode it with DW_LNS_advance_line.  */
  if (tmp >= DWARF2_LINE_RANGE)
    {
      *p++ = DW_LNS_advance_line;
      p += output_leb128 (p, line_delta, 1);

      line_delta = 0;
      tmp = 0 - DWARF2_LINE_BASE;
      need_copy = 1;
    }

  /* Prettier, I think, to use DW_LNS_copy instead of a "line +0, addr +0"
     special opcode.  */
  if (line_delta == 0 && addr_delta == 0)
    {
      *p++ = DW_LNS_copy;
      goto done;
    }

  /* Bias the opcode by the special opcode base.  */
  tmp += DWARF2_LINE_OPCODE_BASE;

  /* Avoid overflow when addr_delta is large.  */
  if (addr_delta < 256 + MAX_SPECIAL_ADDR_DELTA)
    {
      /* Try using a special opcode.  */
      opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	{
	  *p++ = opcode;
	  goto done;
	}

      /* Try using DW_LNS_const_add_pc followed by special op.  */
      opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	{
	  *p++ = DW_LNS_const_add_pc;
	  *p++ = opcode;
	  goto done;
	}
    }

  /* Otherwise use DW_LNS_advance_pc.  */
  *p++ = DW_LNS_advance_pc;
  p += output_leb128 (p, addr_delta, 0);

  if (need_copy)
    *p++ = DW_LNS_copy;
  else
    *p++ = tmp;

 done:
  assert (p == end);
}

/* Handy routine to combine calls to the above two routines.  */

static void
out_inc_line_addr (int line_delta, addressT addr_delta)
{
  int len = size_inc_line_addr (line_delta, addr_delta);
  emit_inc_line_addr (line_delta, addr_delta, frag_more (len), len);
}

/* Generate a variant frag that we can use to relax address/line
   increments between fragments of the target segment.  */

static void
relax_inc_line_addr (int line_delta, segT seg,
		     fragS *to_frag, addressT to_ofs,
		     fragS *from_frag, addressT from_ofs)
{
  symbolS *to_sym, *from_sym;
  expressionS expr;
  int max_chars;

  to_sym = symbol_temp_new (seg, to_ofs, to_frag);
  from_sym = symbol_temp_new (seg, from_ofs, from_frag);

  expr.X_op = O_subtract;
  expr.X_add_symbol = to_sym;
  expr.X_op_symbol = from_sym;
  expr.X_add_number = 0;

  /* The maximum size of the frag is the line delta with a maximum
     sized address delta.  */
  max_chars = size_inc_line_addr (line_delta, -DWARF2_LINE_MIN_INSN_LENGTH);

  frag_var (rs_dwarf2dbg, max_chars, max_chars, 1,
	    make_expr_symbol (&expr), line_delta, NULL);
}

/* The function estimates the size of a rs_dwarf2dbg variant frag
   based on the current values of the symbols.  It is called before
   the relaxation loop.  We set fr_subtype to the expected length.  */

int
dwarf2dbg_estimate_size_before_relax (fragS *frag)
{
  offsetT addr_delta;
  int size;

  addr_delta = resolve_symbol_value (frag->fr_symbol);
  size = size_inc_line_addr (frag->fr_offset, addr_delta);

  frag->fr_subtype = size;

  return size;
}

/* This function relaxes a rs_dwarf2dbg variant frag based on the
   current values of the symbols.  fr_subtype is the current length
   of the frag.  This returns the change in frag length.  */

int
dwarf2dbg_relax_frag (fragS *frag)
{
  int old_size, new_size;

  old_size = frag->fr_subtype;
  new_size = dwarf2dbg_estimate_size_before_relax (frag);

  return new_size - old_size;
}

/* This function converts a rs_dwarf2dbg variant frag into a normal
   fill frag.  This is called after all relaxation has been done.
   fr_subtype will be the desired length of the frag.  */

void
dwarf2dbg_convert_frag (fragS *frag)
{
  offsetT addr_diff;

  addr_diff = resolve_symbol_value (frag->fr_symbol);

  /* fr_var carries the max_chars that we created the fragment with.
     fr_subtype carries the current expected length.  We must, of
     course, have allocated enough memory earlier.  */
  assert (frag->fr_var >= (int) frag->fr_subtype);

  emit_inc_line_addr (frag->fr_offset, addr_diff,
		      frag->fr_literal + frag->fr_fix, frag->fr_subtype);

  frag->fr_fix += frag->fr_subtype;
  frag->fr_type = rs_fill;
  frag->fr_var = 0;
  frag->fr_offset = 0;
}

/* Generate .debug_line content for the chain of line number entries
   beginning at E, for segment SEG.  */

static void
process_entries (segT seg, struct line_entry *e)
{
  unsigned filenum = 1;
  unsigned line = 1;
  unsigned column = 0;
  unsigned isa = 0;
  unsigned flags = DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0;
  fragS *frag = NULL;
  fragS *last_frag;
  addressT frag_ofs = 0;
  addressT last_frag_ofs;
  struct line_entry *next;

  while (e)
    {
      int changed = 0;

      if (filenum != e->loc.filenum)
	{
	  filenum = e->loc.filenum;
	  out_opcode (DW_LNS_set_file);
	  out_uleb128 (filenum);
	  changed = 1;
	}

      if (column != e->loc.column)
	{
	  column = e->loc.column;
	  out_opcode (DW_LNS_set_column);
	  out_uleb128 (column);
	  changed = 1;
	}

      if (isa != e->loc.isa)
	{
	  isa = e->loc.isa;
	  out_opcode (DW_LNS_set_isa);
	  out_uleb128 (isa);
	  changed = 1;
	}

      if ((e->loc.flags ^ flags) & DWARF2_FLAG_IS_STMT)
	{
	  flags = e->loc.flags;
	  out_opcode (DW_LNS_negate_stmt);
	  changed = 1;
	}

      if (e->loc.flags & DWARF2_FLAG_BASIC_BLOCK)
	{
	  out_opcode (DW_LNS_set_basic_block);
	  changed = 1;
	}

      if (e->loc.flags & DWARF2_FLAG_PROLOGUE_END)
	{
	  out_opcode (DW_LNS_set_prologue_end);
	  changed = 1;
	}

      if (e->loc.flags & DWARF2_FLAG_EPILOGUE_BEGIN)
	{
	  out_opcode (DW_LNS_set_epilogue_begin);
	  changed = 1;
	}

      /* Don't try to optimize away redundant entries; gdb wants two
	 entries for a function where the code starts on the same line as
	 the {, and there's no way to identify that case here.  Trust gcc
	 to optimize appropriately.  */
      if (1 /* line != e->loc.line || changed */)
	{
	  int line_delta = e->loc.line - line;
	  if (frag == NULL)
	    {
	      out_set_addr (seg, e->frag, e->frag_ofs);
	      out_inc_line_addr (line_delta, 0);
	    }
	  else if (frag == e->frag)
	    out_inc_line_addr (line_delta, e->frag_ofs - frag_ofs);
	  else
	    relax_inc_line_addr (line_delta, seg, e->frag, e->frag_ofs,
				 frag, frag_ofs);

	  frag = e->frag;
	  frag_ofs = e->frag_ofs;
	  line = e->loc.line;
	}
      else if (frag == NULL)
	{
	  out_set_addr (seg, e->frag, e->frag_ofs);
	  frag = e->frag;
	  frag_ofs = e->frag_ofs;
	}

      next = e->next;
      free (e);
      e = next;
    }

  /* Emit a DW_LNE_end_sequence for the end of the section.  */
  last_frag = last_frag_for_seg (seg);
  last_frag_ofs = get_frag_fix (last_frag);
  if (frag == last_frag)
    out_inc_line_addr (INT_MAX, last_frag_ofs - frag_ofs);
  else
    relax_inc_line_addr (INT_MAX, seg, last_frag, last_frag_ofs,
			 frag, frag_ofs);
}

/* Emit the directory and file tables for .debug_line.  */

static void
out_file_list (void)
{
  size_t size;
  char *cp;
  unsigned int i;

  /* Emit directory list.  */
  for (i = 1; i < dirs_in_use; ++i)
    {
      size = strlen (dirs[i]) + 1;
      cp = frag_more (size);
      memcpy (cp, dirs[i], size);
    }
  /* Terminate it.  */
  out_byte ('\0');

  for (i = 1; i < files_in_use; ++i)
    {
      if (files[i].filename == NULL)
	{
	  as_bad (_("unassigned file number %ld"), (long) i);
	  /* Prevent a crash later, particularly for file 1.  */
	  files[i].filename = "";
	  continue;
	}

      size = strlen (files[i].filename) + 1;
      cp = frag_more (size);
      memcpy (cp, files[i].filename, size);

      out_uleb128 (files[i].dir);	/* directory number */
      out_uleb128 (0);			/* last modification timestamp */
      out_uleb128 (0);			/* filesize */
    }

  /* Terminate filename list.  */
  out_byte (0);
}

/* Emit the collected .debug_line data.  */

static void
out_debug_line (segT line_seg)
{
  expressionS expr;
  symbolS *line_start;
  symbolS *prologue_end;
  symbolS *line_end;
  struct line_seg *s;
  enum dwarf2_format d2f;
  int sizeof_offset;

  subseg_set (line_seg, 0);

  line_start = symbol_temp_new_now ();
  prologue_end = symbol_temp_make ();
  line_end = symbol_temp_make ();

  /* Total length of the information for this compilation unit.  */
  expr.X_op = O_subtract;
  expr.X_add_symbol = line_end;
  expr.X_op_symbol = line_start;

  d2f = DWARF2_FORMAT ();
  if (d2f == dwarf2_format_32bit)
    {
      expr.X_add_number = -4;
      emit_expr (&expr, 4);
      sizeof_offset = 4;
    }
  else if (d2f == dwarf2_format_64bit)
    {
      expr.X_add_number = -12;
      out_four (-1);
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else if (d2f == dwarf2_format_64bit_irix)
    {
      expr.X_add_number = -8;
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else
    {
      as_fatal (_("internal error: unknown dwarf2 format"));
    }

  /* Version.  */
  out_two (2);

  /* Length of the prologue following this length.  */
  expr.X_op = O_subtract;
  expr.X_add_symbol = prologue_end;
  expr.X_op_symbol = line_start;
  expr.X_add_number = - (4 + 2 + 4);
  emit_expr (&expr, sizeof_offset);

  /* Parameters of the state machine.  */
  out_byte (DWARF2_LINE_MIN_INSN_LENGTH);
  out_byte (DWARF2_LINE_DEFAULT_IS_STMT);
  out_byte (DWARF2_LINE_BASE);
  out_byte (DWARF2_LINE_RANGE);
  out_byte (DWARF2_LINE_OPCODE_BASE);

  /* Standard opcode lengths.  */
  out_byte (0);			/* DW_LNS_copy */
  out_byte (1);			/* DW_LNS_advance_pc */
  out_byte (1);			/* DW_LNS_advance_line */
  out_byte (1);			/* DW_LNS_set_file */
  out_byte (1);			/* DW_LNS_set_column */
  out_byte (0);			/* DW_LNS_negate_stmt */
  out_byte (0);			/* DW_LNS_set_basic_block */
  out_byte (0);			/* DW_LNS_const_add_pc */
  out_byte (1);			/* DW_LNS_fixed_advance_pc */
  out_byte (0);			/* DW_LNS_set_prologue_end */
  out_byte (0);			/* DW_LNS_set_epilogue_begin */
  out_byte (1);			/* DW_LNS_set_isa */

  out_file_list ();

  symbol_set_value_now (prologue_end);

  /* For each section, emit a statement program.  */
  for (s = all_segs; s; s = s->next)
    process_entries (s->seg, s->head->head);

  symbol_set_value_now (line_end);
}

/* Emit data for .debug_aranges.  */

static void
out_debug_aranges (segT aranges_seg, segT info_seg)
{
  unsigned int addr_size = sizeof_address;
  addressT size, skip;
  struct line_seg *s;
  expressionS expr;
  char *p;

  size = 4 + 2 + 4 + 1 + 1;

  skip = 2 * addr_size - (size & (2 * addr_size - 1));
  if (skip == 2 * addr_size)
    skip = 0;
  size += skip;

  for (s = all_segs; s; s = s->next)
    size += 2 * addr_size;

  size += 2 * addr_size;

  subseg_set (aranges_seg, 0);

  /* Length of the compilation unit.  */
  out_four (size - 4);

  /* Version.  */
  out_two (2);

  /* Offset to .debug_info.  */
  /* ??? sizeof_offset */
  TC_DWARF2_EMIT_OFFSET (section_symbol (info_seg), 4);

  /* Size of an address (offset portion).  */
  out_byte (addr_size);

  /* Size of a segment descriptor.  */
  out_byte (0);

  /* Align the header.  */
  if (skip)
    frag_align (ffs (2 * addr_size) - 1, 0, 0);

  for (s = all_segs; s; s = s->next)
    {
      fragS *frag;
      symbolS *beg, *end;

      frag = first_frag_for_seg (s->seg);
      beg = symbol_temp_new (s->seg, 0, frag);
      s->text_start = beg;

      frag = last_frag_for_seg (s->seg);
      end = symbol_temp_new (s->seg, get_frag_fix (frag), frag);
      s->text_end = end;

      expr.X_op = O_symbol;
      expr.X_add_symbol = beg;
      expr.X_add_number = 0;
      emit_expr (&expr, addr_size);

      expr.X_op = O_subtract;
      expr.X_add_symbol = end;
      expr.X_op_symbol = beg;
      expr.X_add_number = 0;
      emit_expr (&expr, addr_size);
    }

  p = frag_more (2 * addr_size);
  md_number_to_chars (p, 0, addr_size);
  md_number_to_chars (p + addr_size, 0, addr_size);
}

/* Emit data for .debug_abbrev.  Note that this must be kept in
   sync with out_debug_info below.  */

static void
out_debug_abbrev (segT abbrev_seg)
{
  subseg_set (abbrev_seg, 0);

  out_uleb128 (1);
  out_uleb128 (DW_TAG_compile_unit);
  out_byte (DW_CHILDREN_no);
  out_abbrev (DW_AT_stmt_list, DW_FORM_data4);
  if (all_segs->next == NULL)
    {
      out_abbrev (DW_AT_low_pc, DW_FORM_addr);
      out_abbrev (DW_AT_high_pc, DW_FORM_addr);
    }
  out_abbrev (DW_AT_name, DW_FORM_string);
  out_abbrev (DW_AT_comp_dir, DW_FORM_string);
  out_abbrev (DW_AT_producer, DW_FORM_string);
  out_abbrev (DW_AT_language, DW_FORM_data2);
  out_abbrev (0, 0);

  /* Terminate the abbreviations for this compilation unit.  */
  out_byte (0);
}

/* Emit a description of this compilation unit for .debug_info.  */

static void
out_debug_info (segT info_seg, segT abbrev_seg, segT line_seg)
{
  char producer[128];
  char *comp_dir;
  expressionS expr;
  symbolS *info_start;
  symbolS *info_end;
  char *p;
  int len;
  enum dwarf2_format d2f;
  int sizeof_offset;

  subseg_set (info_seg, 0);

  info_start = symbol_temp_new_now ();
  info_end = symbol_temp_make ();

  /* Compilation Unit length.  */
  expr.X_op = O_subtract;
  expr.X_add_symbol = info_end;
  expr.X_op_symbol = info_start;

  d2f = DWARF2_FORMAT ();
  if (d2f == dwarf2_format_32bit)
    {
      expr.X_add_number = -4;
      emit_expr (&expr, 4);
      sizeof_offset = 4;
    }
  else if (d2f == dwarf2_format_64bit)
    {
      expr.X_add_number = -12;
      out_four (-1);
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else if (d2f == dwarf2_format_64bit_irix)
    {
      expr.X_add_number = -8;
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else
    {
      as_fatal (_("internal error: unknown dwarf2 format"));
    }

  /* DWARF version.  */
  out_two (2);

  /* .debug_abbrev offset */
  TC_DWARF2_EMIT_OFFSET (section_symbol (abbrev_seg), sizeof_offset);

  /* Target address size.  */
  out_byte (sizeof_address);

  /* DW_TAG_compile_unit DIE abbrev */
  out_uleb128 (1);

  /* DW_AT_stmt_list */
  /* ??? sizeof_offset */
  TC_DWARF2_EMIT_OFFSET (section_symbol (line_seg), 4);

  /* These two attributes may only be emitted if all of the code is
     contiguous.  Multiple sections are not that.  */
  if (all_segs->next == NULL)
    {
      /* DW_AT_low_pc */
      expr.X_op = O_symbol;
      expr.X_add_symbol = all_segs->text_start;
      expr.X_add_number = 0;
      emit_expr (&expr, sizeof_address);

      /* DW_AT_high_pc */
      expr.X_op = O_symbol;
      expr.X_add_symbol = all_segs->text_end;
      expr.X_add_number = 0;
      emit_expr (&expr, sizeof_address);
    }

  /* DW_AT_name.  We don't have the actual file name that was present
     on the command line, so assume files[1] is the main input file.
     We're not supposed to get called unless at least one line number
     entry was emitted, so this should always be defined.  */
  if (!files || files_in_use < 1)
    abort ();
  if (files[1].dir)
    {
      len = strlen (dirs[files[1].dir]);
      p = frag_more (len + 1);
      memcpy (p, dirs[files[1].dir], len);
      p[len] = '/';
    }
  len = strlen (files[1].filename) + 1;
  p = frag_more (len);
  memcpy (p, files[1].filename, len);

  /* DW_AT_comp_dir */
  comp_dir = getpwd ();
  len = strlen (comp_dir) + 1;
  p = frag_more (len);
  memcpy (p, comp_dir, len);

  /* DW_AT_producer */
  sprintf (producer, "GNU AS %s", VERSION);
  len = strlen (producer) + 1;
  p = frag_more (len);
  memcpy (p, producer, len);

  /* DW_AT_language.  Yes, this is probably not really MIPS, but the
     dwarf2 draft has no standard code for assembler.  */
  out_two (DW_LANG_Mips_Assembler);

  symbol_set_value_now (info_end);
}

void
dwarf2_finish (void)
{
  segT line_seg;
  struct line_seg *s;

  /* We don't need to do anything unless:
     - Some debug information was recorded via .file/.loc
     - or, we are generating DWARF2 information ourself (--gdwarf2)
     - or, there is a user-provided .debug_info section which could
       reference the file table in the .debug_line section we generate
       below.  */
  if (all_segs == NULL
      && debug_type != DEBUG_DWARF2
      && bfd_get_section_by_name (stdoutput, ".debug_info") == NULL)
    return;

  /* Calculate the size of an address for the target machine.  */
  sizeof_address = DWARF2_ADDR_SIZE (stdoutput);

  /* Create and switch to the line number section.  */
  line_seg = subseg_new (".debug_line", 0);
  bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY);

  /* For each subsection, chain the debug entries together.  */
  for (s = all_segs; s; s = s->next)
    {
      struct line_subseg *ss = s->head;
      struct line_entry **ptail = ss->ptail;

      while ((ss = ss->next) != NULL)
	{
	  *ptail = ss->head;
	  ptail = ss->ptail;
	}
    }

  out_debug_line (line_seg);

  /* If this is assembler generated line info, we need .debug_info
     and .debug_abbrev sections as well.  */
  if (all_segs != NULL && debug_type == DEBUG_DWARF2)
    {
      segT abbrev_seg;
      segT info_seg;
      segT aranges_seg;

      info_seg = subseg_new (".debug_info", 0);
      abbrev_seg = subseg_new (".debug_abbrev", 0);
      aranges_seg = subseg_new (".debug_aranges", 0);

      bfd_set_section_flags (stdoutput, info_seg, SEC_READONLY);
      bfd_set_section_flags (stdoutput, abbrev_seg, SEC_READONLY);
      bfd_set_section_flags (stdoutput, aranges_seg, SEC_READONLY);

      record_alignment (aranges_seg, ffs (2 * sizeof_address) - 1);

      out_debug_aranges (aranges_seg, info_seg);
      out_debug_abbrev (abbrev_seg);
      out_debug_info (info_seg, abbrev_seg, line_seg);
    }
}

#else
void
dwarf2_finish ()
{
}

int
dwarf2dbg_estimate_size_before_relax (frag)
     fragS *frag ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
  return 0;
}

int
dwarf2dbg_relax_frag (frag)
     fragS *frag ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
  return 0;
}

void
dwarf2dbg_convert_frag (frag)
     fragS *frag ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
}

void
dwarf2_emit_insn (size)
     int size ATTRIBUTE_UNUSED;
{
}

char *
dwarf2_directive_file (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  s_app_file (0);
  return NULL;
}

void
dwarf2_directive_loc (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
}
#endif /* BFD_ASSEMBLER */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
d23 1
a23 1
   following two directives:
d26 3
a28 1
	.loc  FILENO LINENO [COLUMN]
d30 3
a32 1
   FILENO is the filenumber.  */
d34 10
a43 1
#include "ansidecl.h"
a44 1
#include "as.h"
d46 12
d73 2
a74 2
   dwarf2_finish().  */
#define DWARF2_LINE_OPCODE_BASE		10
d90 1
a90 1
# define DWARF2_LINE_MIN_INSN_LENGTH	4
d93 1
a93 10
/* Flag that indicates the initial value of the is_stmt_start flag.
   In the present implementation, we do not mark any lines as
   the beginning of a source statement, because that information
   is not made available by the GCC front-end.  */
#define	DWARF2_LINE_DEFAULT_IS_STMT	1

/* Flag that indicates the initial value of the is_stmt_start flag.
   In the present implementation, we do not mark any lines as
   the beginning of a source statement, because that information
   is not made available by the GCC front-end.  */
d107 92
a198 137
#define INITIAL_STATE						\
  /* Initialize as per DWARF2.0 standard.  */			\
  0,					/* address */		\
  1,					/* file */		\
  1,					/* line */		\
  0,					/* column */		\
  DWARF2_LINE_DEFAULT_IS_STMT,		/* is_stmt */		\
  0,					/* basic_block */	\
  1					/* empty_sequence */

static struct
  {
    /* state machine state as per DWARF2 manual: */
    struct dwarf2_sm
      {
	addressT addr;
	unsigned int filenum;
	unsigned int line;
	unsigned int column;
	unsigned int
	  is_stmt : 1,
	  basic_block : 1,
	  empty_sequence : 1;		/* current code sequence has no DWARF2 directives? */
      }
    sm;

    unsigned int
      any_dwarf2_directives : 1;	/* did we emit any DWARF2 line debug directives? */

    fragS * frag;	/* frag that "addr" is relative to */
    segT text_seg;	/* text segment "addr" is relative to */
    subsegT text_subseg;
    segT line_seg;	/* ".debug_line" segment */
    int last_filename;	/* index of last filename that was used */
    int num_filenames;	/* index of last filename in use */
    int filename_len;	/* length of the filename array */
    struct
      {
	int dir;	/* valid after gen_dir_list() only */
	char *name; /* full path before gen_dir_list(), filename afterwards */
      }
    *file;

    struct dwarf2_line_info current;	/* current source info: */

    /* counters for statistical purposes: */
    unsigned int num_line_entries;
    unsigned int opcode_hist[256];	/* histogram of opcode frequencies */
  }
ls =
  {
    {
      INITIAL_STATE
    },
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    NULL,
    { NULL, 0, 0, 0, 0 },
    0,
    {
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    }
  };


/* Function prototypes: */
static void out_uleb128 PARAMS ((addressT));
static void out_sleb128 PARAMS ((offsetT));
static void gen_addr_line PARAMS ((int, addressT));
static void reset_state_machine PARAMS ((void));
static void out_set_addr PARAMS ((addressT));
static void out_end_sequence PARAMS ((void));
static int get_filenum PARAMS ((int, char *));
static void gen_dir_list PARAMS ((void));
static void gen_file_list PARAMS ((void));
static void print_stats PARAMS ((unsigned long));


#define out_byte(byte)	FRAG_APPEND_1_CHAR(byte)
#define out_opcode(opc)	(out_byte ((opc)), ++ls.opcode_hist[(opc) & 0xff])

/* Output an unsigned "little-endian base 128" number.  */
static void
out_uleb128 (value)
     addressT value;
{
  unsigned char byte, more = 0x80;

  do
    {
      byte = value & 0x7f;
      value >>= 7;
      if (value == 0)
	more = 0;
      out_byte (more | byte);
    }
  while (more);
}

/* Output a signed "little-endian base 128" number.  */
static void
out_sleb128 (value)
     offsetT value;
{
  unsigned char byte, more = 0x80;

  do
    {
      byte = value & 0x7f;
      value >>= 7;
      if (((value == 0) && ((byte & 0x40) == 0))
	  || ((value == -1) && ((byte & 0x40) != 0)))
	more = 0;
      out_byte (more | byte);
    }
  while (more);
d200 3
d204 2
a205 7
/* Encode a pair of line and address skips as efficiently as possible.
   Note that the line skip is signed, whereas the address skip is
   unsigned.  */
static void
gen_addr_line (line_delta, addr_delta)
     int line_delta;
     addressT addr_delta;
d207 40
a246 1
  unsigned int tmp, opcode;
d248 2
a249 1
  tmp = line_delta - DWARF2_LINE_BASE;
d251 1
a251 7
  if (tmp >= DWARF2_LINE_RANGE)
    {
      out_opcode (DW_LNS_advance_line);
      out_sleb128 (line_delta);
      tmp = 0 - DWARF2_LINE_BASE;
      line_delta = 0;
    }
d253 7
a259 1
  tmp += DWARF2_LINE_OPCODE_BASE;
d261 3
a263 7
  /* try using a special opcode: */
  opcode = tmp + addr_delta*DWARF2_LINE_RANGE;
  if (opcode <= 255)
    {
      out_opcode (opcode);
      return;
    }
d265 7
a271 8
  /* try using DW_LNS_const_add_pc followed by special op: */
  opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA)*DWARF2_LINE_RANGE;
  if (opcode <= 255)
    {
      out_opcode (DW_LNS_const_add_pc);
      out_opcode (opcode);
      return;
    }
d273 2
a274 2
  out_opcode (DW_LNS_advance_pc);
  out_uleb128 (addr_delta);
d276 9
a284 4
  if (line_delta)
    out_opcode (tmp);		/* output line-delta */
  else
    out_opcode (DW_LNS_copy);	/* append new row with current info */
d287 7
a293 2
static void
reset_state_machine ()
d295 12
a306 1
  static const struct dwarf2_sm initial_state = { INITIAL_STATE };
d308 2
a309 2
  ls.sm = initial_state;
}
d311 2
a312 4
/* Set an absolute address (may results in a relocation entry): */
static void
out_set_addr (addr)
     addressT addr;
d314 2
a315 5
  subsegT saved_subseg;
  segT saved_seg;
  expressionS expr;
  symbolS *sym;
  int bytes_per_address;
d317 4
a320 2
  saved_seg = now_seg;
  saved_subseg = now_subseg;
d322 4
a325 2
  subseg_set (ls.text_seg, ls.text_subseg);
  sym = symbol_new (".L0\001", now_seg, addr, frag_now);
d327 18
a344 1
  subseg_set (saved_seg, saved_subseg);
d346 1
a346 6
#ifdef BFD_ASSEMBLER
  bytes_per_address = bfd_arch_bits_per_address (stdoutput) / 8;
#else
  /* FIXME.  */
  bytes_per_address = 4;
#endif
d348 4
a351 2
  out_opcode (DW_LNS_extended_op);
  out_uleb128 (bytes_per_address + 1);
d353 3
a355 6
  out_opcode (DW_LNE_set_address);
  expr.X_op = O_symbol;
  expr.X_add_symbol = sym;
  expr.X_add_number = 0;
  emit_expr (&expr, bytes_per_address);
}
d357 2
a358 4
/* Emit DW_LNS_end_sequence and reset state machine.  Does not
   preserve the current segment/sub-segment!  */
static void
out_end_sequence ()
d360 29
a388 2
  addressT addr, delta;
  fragS *text_frag;
d390 2
a391 1
  if (ls.text_seg)
d393 7
a399 15
      subseg_set (ls.text_seg, ls.text_subseg);
#ifdef md_current_text_addr
      addr = md_current_text_addr ();
#else
      addr = frag_now_fix ();
#endif
      text_frag = frag_now;
      subseg_set (ls.line_seg, DL_BODY);
      if (text_frag != ls.frag)
	{
	  out_set_addr (addr);
	  ls.sm.addr = addr;
	  ls.frag = text_frag;
	}
      else
d401 1
a401 2
	  delta = (addr - ls.sm.addr) / DWARF2_LINE_MIN_INSN_LENGTH;
	  if (delta > 0)
d403 3
a405 5
	      /* Advance address without updating the line-debug
		 matrix---the end_sequence entry is used only to tell
		 the debugger the end of the sequence.*/
	      out_opcode (DW_LNS_advance_pc);
	      out_uleb128 (delta);
d407 5
d414 13
d428 9
a436 1
    subseg_set (ls.line_seg, DL_BODY);
d438 8
a445 3
  out_opcode (DW_LNS_extended_op);
  out_uleb128 (1);
  out_byte (DW_LNE_end_sequence);
d447 1
a447 1
  reset_state_machine ();
d450 8
a457 8
/* Look up a filenumber either by filename or by filenumber.  If both
   a filenumber and a filename are specified, lookup by filename takes
   precedence.  If the filename cannot be found, it is added to the
   filetable and the filenumber for the new entry is returned.  */
static int
get_filenum (filenum, file)
     int filenum;
     char *file;
d459 3
a461 2
  int i, last = filenum - 1;
  char char0 = file[0];
d463 7
a469 4
  /* If filenum is out of range of the filename table, then try using the
     table entry returned from the previous call.  */
  if (last >= ls.num_filenames || last < 0)
    last = ls.last_filename;
d471 5
a475 4
  /* Do a quick check against the specified or previously used filenum.  */
  if (ls.num_filenames > 0 && ls.file[last].name[0] == char0
      && strcmp (ls.file[last].name + 1, file + 1) == 0)
    return last + 1;
d477 1
a477 2
  /* no match, fall back to simple linear scan: */
  for (i = 0; i < ls.num_filenames; ++i)
d479 2
a480 6
      if (ls.file[i].name[0] == char0
	  && strcmp (ls.file[i].name + 1, file + 1) == 0)
	{
	  ls.last_filename = i;
	  return i + 1;
	}
d483 1
a483 2
  /* no match: enter new filename */
  if (ls.num_filenames >= ls.filename_len)
d485 2
a486 2
      ls.filename_len += 13;
      ls.file = xrealloc (ls.file, ls.filename_len * sizeof (ls.file[0]));
d488 4
a491 4
  ls.file[ls.num_filenames].dir = 0;
  ls.file[ls.num_filenames].name = file;
  ls.last_filename = ls.num_filenames;
  return ++ls.num_filenames;
a493 3
/* Emit an entry in the line number table if the address or line has changed.
   ADDR is relative to the current frag in the text section.  */

d495 1
a495 3
dwarf2_gen_line_info (addr, l)
     addressT addr;
     struct dwarf2_line_info *l;
d497 40
a536 5
  unsigned int filenum = l->filenum;
  unsigned int any_output = 0;
  subsegT saved_subseg;
  segT saved_seg;
  fragS *saved_frag;
d538 6
a543 3
  if (flag_debug)
    fprintf (stderr, "line: addr %lx file `%s' line %u col %u flags %x\n",
	     (unsigned long) addr, l->filename, l->line, l->column, l->flags);
d545 1
a545 1
  if (filenum > 0 && !l->filename)
d547 12
a558 1
      if (filenum >= (unsigned int) ls.num_filenames)
d560 38
a597 1
	  as_warn ("Encountered bad file number in line number debug info!");
d600 2
a602 4
  else if (l->filename)
    filenum = get_filenum (filenum, l->filename);
  else
    return;	/* no filename, no filnum => no play */
d604 121
a724 5
  /* Must save these before the subseg_new call, as that call will change
     them.  */
  saved_seg = now_seg;
  saved_subseg = now_subseg;
  saved_frag = frag_now;
d726 5
a730 1
  if (!ls.line_seg)
d732 8
a739 2
#ifdef BFD_ASSEMBLER
      symbolS *secsym;
d742 6
a747 1
      ls.line_seg = subseg_new (".debug_line", 0);
d749 8
a756 2
#ifdef BFD_ASSEMBLER
      bfd_set_section_flags (stdoutput, ls.line_seg, SEC_READONLY);
d758 7
a764 4
      /* We're going to need this symbol.  */
      secsym = symbol_find (".debug_line");
      if (secsym != NULL)
        symbol_set_bfdsym (secsym, ls.line_seg->symbol);
d766 2
a767 2
        symbol_table_insert (section_symbol (ls.line_seg));
#endif
d770 2
a771 1
  subseg_set (ls.line_seg, DL_BODY);
d773 3
a775 1
  if (ls.text_seg != saved_seg || ls.text_subseg != saved_subseg)
d777 3
a779 11
      if (!ls.sm.empty_sequence)
	{
	  out_end_sequence ();		/* terminate previous sequence */
	  ls.sm.empty_sequence = 1;
	}
      any_output = 1;
      ls.text_seg = saved_seg;
      ls.text_subseg = saved_subseg;
      out_set_addr (addr);
      ls.sm.addr = addr;
      ls.frag = saved_frag;
d782 5
a786 1
  if (ls.sm.filenum != filenum)
d788 9
a796 4
      any_output = 1;
      out_opcode (DW_LNS_set_file);
      out_uleb128 (filenum);
      ls.sm.filenum = filenum;
d799 23
a821 1
  if (ls.sm.column != l->column)
d823 12
a834 4
      any_output = 1;
      out_opcode (DW_LNS_set_column);
      out_uleb128 (l->column);
      ls.sm.column = l->column;
d837 6
a842 1
  if (((l->flags & DWARF2_FLAG_BEGIN_STMT) != 0) != ls.sm.is_stmt)
d844 6
a849 2
      any_output = 1;
      out_opcode (DW_LNS_negate_stmt);
d852 3
a854 1
  if (l->flags & DWARF2_FLAG_BEGIN_BLOCK)
d856 2
a857 2
      any_output = 1;
      out_opcode (DW_LNS_set_basic_block);
d860 5
a864 1
  if (ls.sm.line != l->line)
d866 11
a876 2
      any_output = 1;
      if (saved_frag != ls.frag)
d878 3
a880 7
	  /* If a new frag got allocated (for whatever reason), then
	     deal with it by generating a reference symbol.  Note: no
	     end_sequence needs to be generated because the address did
	     not really decrease (only the reference point changed).  */
	  out_set_addr (addr);
	  ls.sm.addr = addr;
	  ls.frag = saved_frag;
a881 5
      gen_addr_line (l->line - ls.sm.line,
		     (addr - ls.sm.addr) / DWARF2_LINE_MIN_INSN_LENGTH);
      ls.sm.basic_block = 0;
      ls.sm.line = l->line;
      ls.sm.addr = addr;
d884 14
a897 1
  subseg_set (saved_seg, saved_subseg);
d899 5
a903 3
  ls.num_line_entries += any_output;
  if (any_output)
    ls.sm.empty_sequence = 0;
d906 3
d910 63
a972 1
gen_dir_list ()
d974 3
a976 2
  char *str, *slash, *dir_list, *dp, *cp;
  int i, j, num_dirs;
d978 16
a993 2
  dir_list = frag_more (0);
  num_dirs = 0;
d995 15
a1009 1
  for (i = 0; i < ls.num_filenames; ++i)
d1011 40
a1050 3
      str = ls.file[i].name;
      slash = strrchr (str, '/');
      if (slash)
d1052 18
a1069 2
	  *slash = '\0';
	  for (j = 0, dp = dir_list; j < num_dirs; ++j)
d1071 2
a1072 6
	      if (strcmp (str, dp) == 0)
		{
		  ls.file[i].dir = j + 1;
		  break;
		}
	      dp += strlen (dp);
d1074 15
a1088 10
	  if (j >= num_dirs)
	    {
	      /* didn't find this directory: append it to the list */
	      size_t size = strlen (str) + 1;
	      cp = frag_more (size);
	      memcpy (cp, str, size);
	      ls.file[i].dir = ++num_dirs;
	    }
	  *slash = '/';
	  ls.file[i].name = slash + 1;
d1090 4
d1095 9
a1103 1
  out_byte ('\0');	/* terminate directory list */
d1106 2
d1109 1
a1109 1
gen_file_list ()
d1113 1
a1113 1
  int i;
d1115 2
a1116 1
  for (i = 0; i < ls.num_filenames; ++i)
d1118 18
a1135 1
      size = strlen (ls.file[i].name) + 1;
d1137 1
a1137 1
      memcpy (cp, ls.file[i].name, size);
d1139 1
a1139 1
      out_uleb128 (ls.file[i].dir);	/* directory number */
d1143 3
a1145 1
  out_byte (0);		/* terminate filename list */
d1148 2
d1151 1
a1151 2
print_stats (total_size)
     unsigned long total_size;
d1153 40
a1192 1
  static const char *opc_name[] =
d1194 72
a1265 6
      "extended", "copy", "advance_pc", "advance_line", "set_file",
      "set_column", "negate_stmt", "set_basic_block", "const_add_pc",
      "fixed_advance_pc"
    };
  size_t i;
  int j;
d1267 2
a1268 2
  fprintf (stderr, "Average size: %g bytes/line\n",
	   total_size / (double) ls.num_line_entries);
d1270 3
a1272 1
  fprintf (stderr, "\nStandard opcode histogram:\n");
d1274 11
a1284 1
  for (i = 0; i < sizeof (opc_name)/sizeof (opc_name[0]); ++i)
d1286 21
a1306 4
      fprintf (stderr, "%s", opc_name[i]);
      for (j = strlen (opc_name[i]); j < 16; ++j)
	fprintf (stderr, " ");
      fprintf (stderr, ": %u\n", ls.opcode_hist[i]);
d1309 48
a1356 1
  fprintf (stderr, "\nSpecial opcodes:\naddr\t\t\t\tline skip\n");
d1358 2
a1359 4
  fprintf (stderr, "skip: ");
  for (j = DWARF2_LINE_BASE; j < DWARF2_LINE_BASE + DWARF2_LINE_RANGE; ++j)
    fprintf (stderr, "%3d", j);
  fprintf (stderr, "\n-----");
d1361 20
a1380 1
  for (; i < 256; ++i)
d1382 3
a1384 6
      j = SPECIAL_LINE (i);
      if (j == DWARF2_LINE_BASE)
	fprintf (stderr, "\n%4u: ",
		 ((unsigned int)
		  DWARF2_LINE_MIN_INSN_LENGTH * SPECIAL_ADDR (i)));
      fprintf (stderr, " %2u", ls.opcode_hist[i]);
d1386 72
a1457 1
  fprintf (stderr, "\n");
d1461 1
a1461 1
dwarf2_finish ()
d1463 2
a1464 4
  addressT body_size, total_size, prolog_size;
  subsegT saved_subseg;
  segT saved_seg;
  char *cp;
d1466 9
a1474 2
  if (!ls.line_seg)
    /* no .debug_line segment, no work to do... */
d1477 2
a1478 2
  saved_seg = now_seg;
  saved_subseg = now_subseg;
d1480 3
a1482 38
  if (!ls.sm.empty_sequence)
    out_end_sequence ();
  total_size = body_size = frag_now_fix ();

  /* now generate the directory and file lists: */
  subseg_set (ls.line_seg, DL_FILES);
  gen_dir_list ();
  gen_file_list ();
  total_size += frag_now_fix ();

  /* and now the header ("statement program prolog", in DWARF2 lingo...) */
  subseg_set (ls.line_seg, DL_PROLOG);

  cp = frag_more (15 + DWARF2_LINE_OPCODE_BASE - 1);

  total_size += frag_now_fix ();
  prolog_size = total_size - body_size - 10;

# define STUFF(val,size)	md_number_to_chars (cp, val, size); cp += size;
  STUFF (total_size - 4, 4);	/* length */
  STUFF (2, 2);			/* version */
  STUFF (prolog_size, 4);	/* prologue_length */
  STUFF (DWARF2_LINE_MIN_INSN_LENGTH, 1);
  STUFF (DWARF2_LINE_DEFAULT_IS_STMT, 1);
  STUFF (DWARF2_LINE_BASE, 1);
  STUFF (DWARF2_LINE_RANGE, 1);
  STUFF (DWARF2_LINE_OPCODE_BASE, 1);

  /* standard_opcode_lengths: */
  STUFF (0, 1);			/* DW_LNS_copy */
  STUFF (1, 1);			/* DW_LNS_advance_pc */
  STUFF (1, 1);			/* DW_LNS_advance_line */
  STUFF (1, 1);			/* DW_LNS_set_file */
  STUFF (1, 1);			/* DW_LNS_set_column */
  STUFF (0, 1);			/* DW_LNS_negate_stmt */
  STUFF (0, 1);			/* DW_LNS_set_basic_block */
  STUFF (0, 1);			/* DW_LNS_const_add_pc */
  STUFF (1, 1);			/* DW_LNS_fixed_advance_pc */
d1484 5
a1488 1
  subseg_set (saved_seg, saved_subseg);
d1490 6
a1495 3
  if (flag_debug)
    print_stats (total_size);
}
d1497 1
a1497 5
void
dwarf2_directive_file (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  int len;
d1499 3
a1501 3
  /* Continue to accept a bare string and pass it off.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
d1503 3
a1505 3
      s_app_file (0);
      return;
    }
d1507 3
a1509 1
  ls.any_dwarf2_directives = 1;
d1511 3
a1513 4
  if (debug_type == DEBUG_NONE)
    /* Automatically turn on DWARF2 debug info unless something else
       has been selected.  */
    debug_type = DEBUG_DWARF2;
d1515 1
a1515 2
  ls.current.filenum = get_absolute_expression ();
  ls.current.filename = demand_copy_C_string (&len);
d1517 4
a1520 1
  demand_empty_rest_of_line ();
d1523 1
d1525 7
a1531 2
dwarf2_directive_loc (dummy)
     int dummy ATTRIBUTE_UNUSED;
d1533 3
a1535 1
  ls.any_dwarf2_directives = 1;
d1537 7
a1543 6
  ls.current.filenum = get_absolute_expression ();
  SKIP_WHITESPACE ();
  ls.current.line = get_absolute_expression ();
  SKIP_WHITESPACE ();
  ls.current.column = get_absolute_expression ();
  demand_empty_rest_of_line ();
d1545 6
a1550 1
  ls.current.flags = DWARF2_FLAG_BEGIN_STMT;
d1552 12
a1563 4
#ifndef NO_LISTING
  if (listing)
    listing_source_line (ls.current.line);
#endif
d1567 2
a1568 2
dwarf2_where (line)
     struct dwarf2_line_info *line;
d1570 1
a1570 9
  if (ls.any_dwarf2_directives)
    *line = ls.current;
  else
    {
      as_where (&line->filename, &line->line);
      line->filenum = 0;
      line->column = 0;
      line->flags = DWARF2_FLAG_BEGIN_STMT;
    }
d1572 1
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d31 1
a32 14

#ifdef HAVE_LIMITS_H
#include <limits.h>
#else
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifndef INT_MAX
#define INT_MAX (int) (((unsigned) (-1)) >> 1)
#endif
#endif

#ifdef BFD_ASSEMBLER

d66 1
a66 1
# define DWARF2_LINE_MIN_INSN_LENGTH	1
d75 6
d92 25
a116 121
struct line_entry {
  struct line_entry *next;
  fragS *frag;
  addressT frag_ofs;
  struct dwarf2_line_info loc;
};

struct line_subseg {
  struct line_subseg *next;
  subsegT subseg;
  struct line_entry *head;
  struct line_entry **ptail;
};

struct line_seg {
  struct line_seg *next;
  segT seg;
  struct line_subseg *head;
  symbolS *text_start;
  symbolS *text_end;
};

/* Collects data for all line table entries during assembly.  */
static struct line_seg *all_segs;

struct file_entry {
  char *filename;
  unsigned int dir;
};

/* Table of files used by .debug_line.  */
static struct file_entry *files;
static unsigned int files_in_use;
static unsigned int files_allocated;

/* True when we've seen a .loc directive recently.  Used to avoid
   doing work when there's nothing to do.  */
static boolean loc_directive_seen;

/* Current location as indicated by the most recent .loc directive.  */
static struct dwarf2_line_info current;

/* Fake label name.  */
static char const fake_label_name[] = ".L0\001";

/* The size of an address on the target.  */
static unsigned int sizeof_address;

static struct line_subseg *get_line_subseg PARAMS ((segT, subsegT));
static unsigned int get_filenum PARAMS ((const char *));
static struct frag *first_frag_for_seg PARAMS ((segT));
static struct frag *last_frag_for_seg PARAMS ((segT));
static void out_byte PARAMS ((int));
static void out_opcode PARAMS ((int));
static void out_two PARAMS ((int));
static void out_four PARAMS ((int));
static void out_abbrev PARAMS ((int, int));
static void out_uleb128 PARAMS ((addressT));
static symbolS *symbol_new_now PARAMS ((void));
static void set_symbol_value_now PARAMS ((symbolS *));
static offsetT get_frag_fix PARAMS ((fragS *));
static void out_set_addr PARAMS ((segT, fragS *, addressT));
static int size_inc_line_addr PARAMS ((int, addressT));
static void emit_inc_line_addr PARAMS ((int, addressT, char *, int));
static void out_inc_line_addr PARAMS ((int, addressT));
static void relax_inc_line_addr PARAMS ((int, segT, fragS *, addressT,
					 fragS *, addressT));
static void process_entries PARAMS ((segT, struct line_entry *));
static void out_file_list PARAMS ((void));
static void out_debug_line PARAMS ((segT));
static void out_debug_aranges PARAMS ((segT, segT));
static void out_debug_abbrev PARAMS ((segT));
static void out_debug_info PARAMS ((segT, segT, segT));

/* Find or create an entry for SEG+SUBSEG in ALL_SEGS.  */

static struct line_subseg *
get_line_subseg (seg, subseg)
     segT seg;
     subsegT subseg;
{
  static segT last_seg;
  static subsegT last_subseg;
  static struct line_subseg *last_line_subseg;

  struct line_seg *s;
  struct line_subseg **pss, *ss;

  if (seg == last_seg && subseg == last_subseg)
    return last_line_subseg;

  for (s = all_segs; s; s = s->next)
    if (s->seg == seg)
      goto found_seg;

  s = (struct line_seg *) xmalloc (sizeof (*s));
  s->next = all_segs;
  s->seg = seg;
  s->head = NULL;
  all_segs = s;

 found_seg:
  for (pss = &s->head; (ss = *pss) != NULL ; pss = &ss->next)
    {
      if (ss->subseg == subseg)
	goto found_subseg;
      if (ss->subseg > subseg)
	break;
    }

  ss = (struct line_subseg *) xmalloc (sizeof (*ss));
  ss->next = *pss;
  ss->subseg = subseg;
  ss->head = NULL;
  ss->ptail = &ss->head;
  *pss = ss;

 found_subseg:
  last_seg = seg;
  last_subseg = subseg;
  last_line_subseg = ss;
d118 2
a119 2
  return ss;
}
d121 13
a133 9
/* Record an entry for LOC ocurring at OFS within the current fragment.  */

void
dwarf2_gen_line_info (ofs, loc)
     addressT ofs;
     struct dwarf2_line_info *loc;
{
  struct line_subseg *ss;
  struct line_entry *e;
d135 1
a135 14
  /* Early out for as-yet incomplete location information.  */
  if (loc->filenum == 0 || loc->line == 0)
    return;

  e = (struct line_entry *) xmalloc (sizeof (*e));
  e->next = NULL;
  e->frag = frag_now;
  e->frag_ofs = ofs;
  e->loc = *loc;

  ss = get_line_subseg (now_seg, now_subseg);
  *ss->ptail = e;
  ss->ptail = &e->next;
}
d137 37
a173 11
void
dwarf2_where (line)
     struct dwarf2_line_info *line;
{
  if (debug_type == DEBUG_DWARF2)
    {
      char *filename;
      as_where (&filename, &line->line);
      line->filenum = get_filenum (filename);
      line->column = 0;
      line->flags = DWARF2_FLAG_BEGIN_STMT;
d175 1
a175 3
  else
    *line = current;
}
a176 4
/* Called for each machine instruction, or relatively atomic group of
   machine instructions (ie built-in macro).  The instruction or group
   is SIZE bytes in length.  If dwarf2 line number generation is called
   for, emit a line statement appropriately.  */
d178 11
a188 5
void
dwarf2_emit_insn (size)
     int size;
{
  struct dwarf2_line_info loc;
a189 3
  if (debug_type != DEBUG_DWARF2 && ! loc_directive_seen)
    return;
  loc_directive_seen = false;
d191 2
a192 3
  dwarf2_where (&loc);
  dwarf2_gen_line_info (frag_now_fix () - size, &loc);
}
d194 4
a197 5
/* Get a .debug_line file number for FILENAME.  */

static unsigned int
get_filenum (filename)
     const char *filename;
d199 1
a199 6
  static unsigned int last_used;
  unsigned int i;

  if (last_used)
    if (strcmp (filename, files[last_used].filename) == 0)
      return last_used;
d201 1
a201 5
  for (i = 1; i < files_in_use; ++i)
    if (strcmp (filename, files[i].filename) == 0)
      return i;

  if (i >= files_allocated)
d203 5
a207 7
      unsigned int old = files_allocated;

      files_allocated = i + 32;
      files = (struct file_entry *)
	xrealloc (files, (i + 32) * sizeof (struct file_entry));

      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));
d209 1
a209 7

  files[i].filename = xstrdup (filename);
  files[i].dir = 0;
  files_in_use = i + 1;
  last_used = i;

  return i;
d212 4
a215 5
/* Handle the .file directive.  */

void
dwarf2_directive_file (dummy)
     int dummy ATTRIBUTE_UNUSED;
d217 1
a217 3
  offsetT num;
  char *filename;
  int filename_len;
d219 1
a219 3
  /* Continue to accept a bare string and pass it off.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
d221 6
a226 2
      s_app_file (0);
      return;
d228 2
d231 9
a239 3
  num = get_absolute_expression ();
  filename = demand_copy_C_string (&filename_len);
  demand_empty_rest_of_line ();
d241 1
a241 5
  if (num < 1)
    {
      as_bad (_("File number less than one"));
      return;
    }
d243 1
a243 1
  if (num < files_in_use && files[num].filename != 0)
d245 4
a248 2
      as_bad (_("File number %ld already allocated"), (long) num);
      return;
d251 1
a251 7
  if (num >= (int) files_allocated)
    {
      unsigned int old = files_allocated;

      files_allocated = num + 16;
      files = (struct file_entry *)
	xrealloc (files, (num + 16) * sizeof (struct file_entry));
d253 3
a255 23
      /* Zero the new memory.  */
      memset (files + old, 0, (num + 16 - old) * sizeof (struct file_entry));
    }

  files[num].filename = filename;
  files[num].dir = 0;
  files_in_use = num + 1;
}

void
dwarf2_directive_loc (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  offsetT filenum, line, column;

  filenum = get_absolute_expression ();
  SKIP_WHITESPACE ();
  line = get_absolute_expression ();
  SKIP_WHITESPACE ();
  column = get_absolute_expression ();
  demand_empty_rest_of_line ();

  if (filenum < 1)
d257 1
a257 1
      as_bad (_("File number less than one"));
d260 4
a263 1
  if (filenum >= (int) files_in_use || files[filenum].filename == 0)
d265 2
a266 1
      as_bad (_("Unassigned file number %ld"), (long) filenum);
d270 2
a271 4
  current.filenum = filenum;
  current.line = line;
  current.column = column;
  current.flags = DWARF2_FLAG_BEGIN_STMT;
d273 4
a276 6
  loc_directive_seen = true;

#ifndef NO_LISTING
  if (listing)
    listing_source_line (line);
#endif
a277 6

static struct frag *
first_frag_for_seg (seg)
     segT seg;
{
  frchainS *f, *first = NULL;
d279 2
a280 11
  for (f = frchain_root; f; f = f->frch_next)
    if (f->frch_seg == seg
	&& (! first || first->frch_subseg > f->frch_subseg))
      first = f;

  return first ? first->frch_root : NULL;
}

static struct frag *
last_frag_for_seg (seg)
     segT seg;
d282 1
a282 6
  frchainS *f, *last = NULL;

  for (f = frchain_root; f; f = f->frch_next)
    if (f->frch_seg == seg
	&& (! last || last->frch_subseg < f->frch_subseg))
      last= f;
d284 1
a284 1
  return last ? last->frch_last : NULL;
a285 2

/* Emit a single byte into the current segment.  */
d287 4
a290 3
static inline void
out_byte (byte)
     int byte;
d292 5
a296 2
  FRAG_APPEND_1_CHAR (byte);
}
d298 2
a299 1
/* Emit a statement program opcode into the current segment.  */
d301 2
a302 6
static inline void
out_opcode (opc)
     int opc;
{
  out_byte (opc);
}
d304 1
a304 1
/* Emit a two-byte word into the current segment.  */
d306 6
a311 6
static inline void
out_two (data)
     int data;
{
  md_number_to_chars (frag_more (2), data, 2);
}
d313 2
a314 1
/* Emit a four byte word into the current segment.  */
d316 5
a320 5
static inline void
out_four (data)
     int data;
{
  md_number_to_chars (frag_more (4), data, 4);
d323 2
a324 2
/* Emit an unsigned "little-endian base 128" number.  */

d326 1
a326 2
out_uleb128 (value)
     addressT value;
d328 2
a329 2
  output_leb128 (frag_more (sizeof_leb128 (value, 0)), value, 0);
}
d331 31
a361 1
/* Emit a tuple for .debug_abbrev.  */
d363 3
a365 9
static inline void
out_abbrev (name, form)
     int name, form;
{
  out_uleb128 (name);
  out_uleb128 (form);
}

/* Create a new fake symbol whose value is the current position.  */
d367 1
a367 4
static symbolS *
symbol_new_now ()
{
  return symbol_new (fake_label_name, now_seg, frag_now_fix (), frag_now);
d370 8
a377 5
/* Set the value of SYM to the current position in the current segment.  */

static void
set_symbol_value_now (sym)
     symbolS *sym;
d379 2
a380 4
  S_SET_SEGMENT (sym, now_seg);
  S_SET_VALUE (sym, frag_now_fix ());
  symbol_set_frag (sym, frag_now);
}
d382 4
a385 1
/* Get the size of a fragment.  */
d387 4
a390 5
static offsetT
get_frag_fix (frag)
     fragS *frag;
{
  frchainS *fr;
d392 10
a401 2
  if (frag->fr_next)
    return frag->fr_fix;
d403 10
a412 11
  /* If a fragment is the last in the chain, special measures must be
     taken to find its size before relaxation, since it may be pending
     on some subsegment chain.  */
  for (fr = frchain_root; fr; fr = fr->frch_next)
    if (fr->frch_last == frag)
      {
	return ((char *) obstack_next_free (&fr->frch_obstack)
		- frag->fr_literal);
      }

  abort ();
d415 2
a416 1
/* Set an absolute address (may result in a relocation entry).  */
d418 4
a421 5
static void
out_set_addr (seg, frag, ofs)
     segT seg;
     fragS *frag;
     addressT ofs;
d423 5
a427 2
  expressionS expr;
  symbolS *sym;
d429 3
a431 1
  sym = symbol_new (fake_label_name, seg, ofs, frag);
d433 12
a444 2
  out_opcode (DW_LNS_extended_op);
  out_uleb128 (sizeof_address + 1);
d446 5
a450 6
  out_opcode (DW_LNE_set_address);
  expr.X_op = O_symbol;
  expr.X_add_symbol = sym;
  expr.X_add_number = 0;
  emit_expr (&expr, sizeof_address);
}
d452 5
a456 2
/* Encode a pair of line and address skips as efficiently as possible.
   Note that the line skip is signed, whereas the address skip is unsigned.
d458 1
a458 3
   The following two routines *must* be kept in sync.  This is
   enforced by making emit_inc_line_addr abort if we do not emit
   exactly the expected number of bytes.  */
d460 2
a461 7
static int
size_inc_line_addr (line_delta, addr_delta)
     int line_delta;
     addressT addr_delta;
{
  unsigned int tmp, opcode;
  int len = 0;
d463 6
a468 4
  /* Scale the address delta by the minimum instruction length.  */
#if DWARF2_LINE_MIN_INSN_LENGTH > 1
  assert (addr_delta % DWARF2_LINE_MIN_INSN_LENGTH == 0);
  addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
d470 1
d472 3
a474 4
  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.
     We cannot use special opcodes here, since we want the end_sequence
     to emit the matrix entry.  */
  if (line_delta == INT_MAX)
d476 11
a486 5
      if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
	len = 1;
      else
	len = 1 + sizeof_leb128 (addr_delta, 0);
      return len + 3;
d489 1
a489 6
  /* Bias the line delta by the base.  */
  tmp = line_delta - DWARF2_LINE_BASE;

  /* If the line increment is out of range of a special opcode, we
     must encode it with DW_LNS_advance_line.  */
  if (tmp >= DWARF2_LINE_RANGE)
d491 4
a494 3
      len = 1 + sizeof_leb128 (line_delta, 1);
      line_delta = 0;
      tmp = 0 - DWARF2_LINE_BASE;
d497 1
a497 5
  /* Bias the opcode by the special opcode base.  */
  tmp += DWARF2_LINE_OPCODE_BASE;

  /* Avoid overflow when addr_delta is large.  */
  if (addr_delta < 256 + MAX_SPECIAL_ADDR_DELTA)
d499 4
a502 9
      /* Try using a special opcode.  */
      opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	return len + 1;

      /* Try using DW_LNS_const_add_pc followed by special op.  */
      opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	return len + 2;
d505 1
a505 29
  /* Otherwise use DW_LNS_advance_pc.  */
  len += 1 + sizeof_leb128 (addr_delta, 0);

  /* DW_LNS_copy or special opcode.  */
  len += 1;

  return len;
}

static void
emit_inc_line_addr (line_delta, addr_delta, p, len)
     int line_delta;
     addressT addr_delta;
     char *p;
     int len;
{
  unsigned int tmp, opcode;
  int need_copy = 0;
  char *end = p + len;

#if DWARF2_LINE_MIN_INSN_LENGTH > 1
  /* Scale the address delta by the minimum instruction length.  */
  assert (addr_delta % DWARF2_LINE_MIN_INSN_LENGTH == 0);
  addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
#endif
  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.
     We cannot use special opcodes here, since we want the end_sequence
     to emit the matrix entry.  */
  if (line_delta == INT_MAX)
d507 2
a508 12
      if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
	*p++ = DW_LNS_const_add_pc;
      else
	{
	  *p++ = DW_LNS_advance_pc;
	  p += output_leb128 (p, addr_delta, 0);
	}

      *p++ = DW_LNS_extended_op;
      *p++ = 1;
      *p++ = DW_LNE_end_sequence;
      goto done;
d511 1
a511 6
  /* Bias the line delta by the base.  */
  tmp = line_delta - DWARF2_LINE_BASE;

  /* If the line increment is out of range of a special opcode, we
     must encode it with DW_LNS_advance_line.  */
  if (tmp >= DWARF2_LINE_RANGE)
d513 2
a514 14
      *p++ = DW_LNS_advance_line;
      p += output_leb128 (p, line_delta, 1);

      /* Prettier, I think, to use DW_LNS_copy instead of a
	 "line +0, addr +0" special opcode.  */
      if (addr_delta == 0)
	{
	  *p++ = DW_LNS_copy;
	  goto done;
	}

      line_delta = 0;
      tmp = 0 - DWARF2_LINE_BASE;
      need_copy = 1;
d517 1
a517 5
  /* Bias the opcode by the special opcode base.  */
  tmp += DWARF2_LINE_OPCODE_BASE;

  /* Avoid overflow when addr_delta is large.  */
  if (addr_delta < 256 + MAX_SPECIAL_ADDR_DELTA)
d519 2
a520 11
      /* Try using a special opcode.  */
      opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	{
	  *p++ = opcode;
	  goto done;
	}

      /* Try using DW_LNS_const_add_pc followed by special op.  */
      opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
      if (opcode <= 255)
d522 7
a528 3
	  *p++ = DW_LNS_const_add_pc;
	  *p++ = opcode;
	  goto done;
d530 5
d537 1
a537 8
  /* Otherwise use DW_LNS_advance_pc.  */
  *p++ = DW_LNS_advance_pc;
  p += output_leb128 (p, addr_delta, 0);

  if (need_copy)
    *p++ = DW_LNS_copy;
  else
    *p++ = tmp;
d539 3
a541 2
 done:
  assert (p == end);
a543 2
/* Handy routine to combine calls to the above two routines.  */

d545 1
a545 64
out_inc_line_addr (line_delta, addr_delta)
     int line_delta;
     addressT addr_delta;
{
  int len = size_inc_line_addr (line_delta, addr_delta);
  emit_inc_line_addr (line_delta, addr_delta, frag_more (len), len);
}

/* Generate a variant frag that we can use to relax address/line
   increments between fragments of the target segment.  */

static void
relax_inc_line_addr (line_delta, seg, to_frag, to_ofs, from_frag, from_ofs)
     int line_delta;
     segT seg;
     fragS *to_frag, *from_frag;
     addressT to_ofs, from_ofs;
{
  symbolS *to_sym, *from_sym;
  expressionS expr;
  int max_chars;

  to_sym = symbol_new (fake_label_name, seg, to_ofs, to_frag);
  from_sym = symbol_new (fake_label_name, seg, from_ofs, from_frag);

  expr.X_op = O_subtract;
  expr.X_add_symbol = to_sym;
  expr.X_op_symbol = from_sym;
  expr.X_add_number = 0;

  /* The maximum size of the frag is the line delta with a maximum
     sized address delta.  */
  max_chars = size_inc_line_addr (line_delta, -DWARF2_LINE_MIN_INSN_LENGTH);

  frag_var (rs_dwarf2dbg, max_chars, max_chars, 1,
	    make_expr_symbol (&expr), line_delta, NULL);
}

/* The function estimates the size of a rs_dwarf2dbg variant frag
   based on the current values of the symbols.  It is called before
   the relaxation loop.  We set fr_subtype to the expected length.  */

int
dwarf2dbg_estimate_size_before_relax (frag)
     fragS *frag;
{
  offsetT addr_delta;
  int size;

  addr_delta = resolve_symbol_value (frag->fr_symbol, 0);
  size = size_inc_line_addr (frag->fr_offset, addr_delta);

  frag->fr_subtype = size;

  return size;
}

/* This function relaxes a rs_dwarf2dbg variant frag based on the
   current values of the symbols.  fr_subtype is the current length
   of the frag.  This returns the change in frag length.  */

int
dwarf2dbg_relax_frag (frag)
     fragS *frag;
d547 2
a548 1
  int old_size, new_size;
d550 2
a551 5
  old_size = frag->fr_subtype;
  new_size = dwarf2dbg_estimate_size_before_relax (frag);

  return new_size - old_size;
}
d553 1
a553 45
/* This function converts a rs_dwarf2dbg variant frag into a normal
   fill frag.  This is called after all relaxation has been done.
   fr_subtype will be the desired length of the frag.  */

void
dwarf2dbg_convert_frag (frag)
     fragS *frag;
{
  offsetT addr_diff;

  addr_diff = resolve_symbol_value (frag->fr_symbol, 1);

  /* fr_var carries the max_chars that we created the fragment with.
     fr_subtype carries the current expected length.  We must, of
     course, have allocated enough memory earlier.  */
  assert (frag->fr_var >= (int) frag->fr_subtype);

  emit_inc_line_addr (frag->fr_offset, addr_diff,
		      frag->fr_literal + frag->fr_fix, frag->fr_subtype);

  frag->fr_fix += frag->fr_subtype;
  frag->fr_type = rs_fill;
  frag->fr_var = 0;
  frag->fr_offset = 0;
}

/* Generate .debug_line content for the chain of line number entries
   beginning at E, for segment SEG.  */

static void
process_entries (seg, e)
     segT seg;
     struct line_entry *e;
{
  unsigned filenum = 1;
  unsigned line = 1;
  unsigned column = 0;
  unsigned flags = DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_BEGIN_STMT : 0;
  fragS *frag = NULL;
  fragS *last_frag;
  addressT frag_ofs = 0;
  addressT last_frag_ofs;
  struct line_entry *next;

  while (e)
d555 3
a557 3
      int changed = 0;

      if (filenum != e->loc.filenum)
d559 11
a569 35
	  filenum = e->loc.filenum;
	  out_opcode (DW_LNS_set_file);
	  out_uleb128 (filenum);
	  changed = 1;
	}

      if (column != e->loc.column)
	{
	  column = e->loc.column;
	  out_opcode (DW_LNS_set_column);
	  out_uleb128 (column);
	  changed = 1;
	}

      if ((e->loc.flags ^ flags) & DWARF2_FLAG_BEGIN_STMT)
	{
	  flags = e->loc.flags;
	  out_opcode (DW_LNS_negate_stmt);
	  changed = 1;
	}

      if (e->loc.flags & DWARF2_FLAG_BEGIN_BLOCK)
	{
	  out_opcode (DW_LNS_set_basic_block);
	  changed = 1;
	}

      /* Don't try to optimize away redundant entries; gdb wants two
	 entries for a function where the code starts on the same line as
	 the {, and there's no way to identify that case here.  Trust gcc
	 to optimize appropriately.  */
      if (1 /* line != e->loc.line || changed */)
	{
	  int line_delta = e->loc.line - line;
	  if (frag == NULL)
d571 5
a575 2
	      out_set_addr (seg, e->frag, e->frag_ofs);
	      out_inc_line_addr (line_delta, 0);
d577 2
a578 15
	  else if (frag == e->frag)
	    out_inc_line_addr (line_delta, e->frag_ofs - frag_ofs);
	  else
	    relax_inc_line_addr (line_delta, seg, e->frag, e->frag_ofs,
				 frag, frag_ofs);

	  frag = e->frag;
	  frag_ofs = e->frag_ofs;
	  line = e->loc.line;
	}
      else if (frag == NULL)
	{
	  out_set_addr (seg, e->frag, e->frag_ofs);
	  frag = e->frag;
	  frag_ofs = e->frag_ofs;
a579 4

      next = e->next;
      free (e);
      e = next;
d581 1
a581 9

  /* Emit a DW_LNE_end_sequence for the end of the section.  */
  last_frag = last_frag_for_seg (seg);
  last_frag_ofs = get_frag_fix (last_frag);
  if (frag == last_frag)
    out_inc_line_addr (INT_MAX, last_frag_ofs - frag_ofs);
  else
    relax_inc_line_addr (INT_MAX, seg, last_frag, last_frag_ofs,
			 frag, frag_ofs);
a583 2
/* Emit the directory and file tables for .debug_line.  */

d585 1
a585 1
out_file_list ()
d589 1
a589 4
  unsigned int i;

  /* Terminate directory list.  */
  out_byte ('\0');
d591 1
a591 1
  for (i = 1; i < files_in_use; ++i)
d593 1
a593 7
      if (files[i].filename == NULL)
	{
	  as_bad (_("Unassigned file number %u"), i);
	  continue;
	}

      size = strlen (files[i].filename) + 1;
d595 1
a595 1
      memcpy (cp, files[i].filename, size);
d597 1
a597 1
      out_uleb128 (files[i].dir);	/* directory number */
d601 1
a601 3

  /* Terminate filename list.  */
  out_byte (0);
a603 2
/* Emit the collected .debug_line data.  */

d605 2
a606 2
out_debug_line (line_seg)
     segT line_seg;
d608 8
a615 54
  expressionS expr;
  symbolS *line_start;
  symbolS *prologue_end;
  symbolS *line_end;
  struct line_seg *s;

  subseg_set (line_seg, 0);

  line_start = symbol_new_now ();
  prologue_end = symbol_make (fake_label_name);
  line_end = symbol_make (fake_label_name);

  /* Total length of the information for this compilation unit.  */
  expr.X_op = O_subtract;
  expr.X_add_symbol = line_end;
  expr.X_op_symbol = line_start;
  expr.X_add_number = -4;
  emit_expr (&expr, 4);

  /* Version.  */
  out_two (2);

  /* Length of the prologue following this length.  */
  expr.X_op = O_subtract;
  expr.X_add_symbol = prologue_end;
  expr.X_op_symbol = line_start;
  expr.X_add_number = - (4 + 2 + 4);
  emit_expr (&expr, 4);

  /* Parameters of the state machine.  */
  out_byte (DWARF2_LINE_MIN_INSN_LENGTH);
  out_byte (DWARF2_LINE_DEFAULT_IS_STMT);
  out_byte (DWARF2_LINE_BASE);
  out_byte (DWARF2_LINE_RANGE);
  out_byte (DWARF2_LINE_OPCODE_BASE);

  /* Standard opcode lengths.  */
  out_byte (0);			/* DW_LNS_copy */
  out_byte (1);			/* DW_LNS_advance_pc */
  out_byte (1);			/* DW_LNS_advance_line */
  out_byte (1);			/* DW_LNS_set_file */
  out_byte (1);			/* DW_LNS_set_column */
  out_byte (0);			/* DW_LNS_negate_stmt */
  out_byte (0);			/* DW_LNS_set_basic_block */
  out_byte (0);			/* DW_LNS_const_add_pc */
  out_byte (1);			/* DW_LNS_fixed_advance_pc */

  out_file_list ();

  set_symbol_value_now (prologue_end);

  /* For each section, emit a statement program.  */
  for (s = all_segs; s; s = s->next)
    process_entries (s->seg, s->head->head);
d617 2
a618 2
  set_symbol_value_now (line_end);
}
d620 1
a620 1
/* Emit data for .debug_aranges.  */
d622 7
a628 10
static void
out_debug_aranges (aranges_seg, info_seg)
     segT aranges_seg;
     segT info_seg;
{
  unsigned int addr_size = sizeof_address;
  addressT size, skip;
  struct line_seg *s;
  expressionS expr;
  char *p;
d630 1
a630 1
  size = 4 + 2 + 4 + 1 + 1;
d632 4
a635 4
  skip = 2 * addr_size - (size & (2 * addr_size - 1));
  if (skip == 2 * addr_size)
    skip = 0;
  size += skip;
d637 1
a637 30
  for (s = all_segs; s; s = s->next)
    size += 2 * addr_size;

  size += 2 * addr_size;

  subseg_set (aranges_seg, 0);

  /* Length of the compilation unit.  */
  out_four (size - 4);

  /* Version.  */
  out_two (2);

  /* Offset to .debug_info.  */
  expr.X_op = O_symbol;
  expr.X_add_symbol = section_symbol (info_seg);
  expr.X_add_number = 0;
  emit_expr (&expr, 4);

  /* Size of an address (offset portion).  */
  out_byte (addr_size);

  /* Size of a segment descriptor.  */
  out_byte (0);

  /* Align the header.  */
  if (skip)
    frag_align (ffs (2 * addr_size) - 1, 0, 0);

  for (s = all_segs; s; s = s->next)
d639 6
a644 21
      fragS *frag;
      symbolS *beg, *end;

      frag = first_frag_for_seg (s->seg);
      beg = symbol_new (fake_label_name, s->seg, 0, frag);
      s->text_start = beg;

      frag = last_frag_for_seg (s->seg);
      end = symbol_new (fake_label_name, s->seg, get_frag_fix (frag), frag);
      s->text_end = end;

      expr.X_op = O_symbol;
      expr.X_add_symbol = beg;
      expr.X_add_number = 0;
      emit_expr (&expr, addr_size);

      expr.X_op = O_subtract;
      expr.X_add_symbol = end;
      expr.X_op_symbol = beg;
      expr.X_add_number = 0;
      emit_expr (&expr, addr_size);
d646 1
a646 4

  p = frag_more (2 * addr_size);
  md_number_to_chars (p, 0, addr_size);
  md_number_to_chars (p + addr_size, 0, addr_size);
d649 2
a650 6
/* Emit data for .debug_abbrev.  Note that this must be kept in
   sync with out_debug_info below.  */

static void
out_debug_abbrev (abbrev_seg)
     segT abbrev_seg;
d652 4
a655 1
  subseg_set (abbrev_seg, 0);
d657 3
a659 17
  out_uleb128 (1);
  out_uleb128 (DW_TAG_compile_unit);
  out_byte (DW_CHILDREN_no);
  out_abbrev (DW_AT_stmt_list, DW_FORM_data4);
  if (all_segs->next == NULL)
    {
      out_abbrev (DW_AT_low_pc, DW_FORM_addr);
      out_abbrev (DW_AT_high_pc, DW_FORM_addr);
    }
  out_abbrev (DW_AT_comp_dir, DW_FORM_string);
  out_abbrev (DW_AT_producer, DW_FORM_string);
  out_abbrev (DW_AT_language, DW_FORM_data2);
  out_abbrev (0, 0);

  /* Terminate the abbreviations for this compilation unit.  */
  out_byte (0);
}
d661 2
a662 1
/* Emit a description of this compilation unit for .debug_info.  */
d664 38
a701 25
static void
out_debug_info (info_seg, abbrev_seg, line_seg)
     segT info_seg;
     segT abbrev_seg;
     segT line_seg;
{
  char producer[128];
  char *comp_dir;
  expressionS expr;
  symbolS *info_start;
  symbolS *info_end;
  char *p;
  int len;

  subseg_set (info_seg, 0);

  info_start = symbol_new_now ();
  info_end = symbol_make (fake_label_name);

  /* Compilation Unit length.  */
  expr.X_op = O_subtract;
  expr.X_add_symbol = info_end;
  expr.X_op_symbol = info_start;
  expr.X_add_number = -4;
  emit_expr (&expr, 4);
d703 1
a703 14
  /* DWARF version.  */
  out_two (2);

  /* .debug_abbrev offset */
  expr.X_op = O_symbol;
  expr.X_add_symbol = section_symbol (abbrev_seg);
  expr.X_add_number = 0;
  emit_expr (&expr, 4);

  /* Target address size.  */
  out_byte (sizeof_address);

  /* DW_TAG_compile_unit DIE abbrev */
  out_uleb128 (1);
d705 2
a706 40
  /* DW_AT_stmt_list */
  expr.X_op = O_symbol;
  expr.X_add_symbol = section_symbol (line_seg);
  expr.X_add_number = 0;
  emit_expr (&expr, 4);

  /* These two attributes may only be emitted if all of the code is
     contiguous.  Multiple sections are not that.  */
  if (all_segs->next == NULL)
    {
      /* DW_AT_low_pc */
      expr.X_op = O_symbol;
      expr.X_add_symbol = all_segs->text_start;
      expr.X_add_number = 0;
      emit_expr (&expr, sizeof_address);

      /* DW_AT_high_pc */
      expr.X_op = O_symbol;
      expr.X_add_symbol = all_segs->text_end;
      expr.X_add_number = 0;
      emit_expr (&expr, sizeof_address);
    }

  /* DW_AT_comp_dir */
  comp_dir = getpwd ();
  len = strlen (comp_dir) + 1;
  p = frag_more (len);
  memcpy (p, comp_dir, len);

  /* DW_AT_producer */
  sprintf (producer, "GNU AS %s", VERSION);
  len = strlen (producer) + 1;
  p = frag_more (len);
  memcpy (p, producer, len);

  /* DW_AT_language.  Yes, this is probably not really MIPS, but the
     dwarf2 draft has no standard code for assembler.  */
  out_two (DW_LANG_Mips_Assembler);

  set_symbol_value_now (info_end);
d710 2
a711 1
dwarf2_finish ()
d713 1
a713 2
  segT line_seg;
  struct line_seg *s;
d715 3
a717 13
  /* If no debug information was recorded, nothing to do.  */
  if (all_segs == NULL)
    return;

  /* Calculate the size of an address for the target machine.  */
  sizeof_address = bfd_arch_bits_per_address (stdoutput) / 8;

  /* Create and switch to the line number section.  */
  line_seg = subseg_new (".debug_line", 0);
  bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY);

  /* For each subsection, chain the debug entries together.  */
  for (s = all_segs; s; s = s->next)
d719 2
a720 8
      struct line_subseg *ss = s->head;
      struct line_entry **ptail = ss->ptail;

      while ((ss = ss->next) != NULL)
	{
	  *ptail = ss->head;
	  ptail = ss->ptail;
	}
d723 1
a723 1
  out_debug_line (line_seg);
d725 4
a728 7
  /* If this is assembler generated line info, we need .debug_info
     and .debug_abbrev sections as well.  */
  if (debug_type == DEBUG_DWARF2)
    {
      segT abbrev_seg;
      segT info_seg;
      segT aranges_seg;
d730 2
a731 3
      info_seg = subseg_new (".debug_info", 0);
      abbrev_seg = subseg_new (".debug_abbrev", 0);
      aranges_seg = subseg_new (".debug_aranges", 0);
d733 1
a733 10
      bfd_set_section_flags (stdoutput, info_seg, SEC_READONLY);
      bfd_set_section_flags (stdoutput, abbrev_seg, SEC_READONLY);
      bfd_set_section_flags (stdoutput, aranges_seg, SEC_READONLY);

      record_alignment (aranges_seg, ffs (2 * sizeof_address) - 1);

      out_debug_aranges (aranges_seg, info_seg);
      out_debug_abbrev (abbrev_seg);
      out_debug_info (info_seg, abbrev_seg, line_seg);
    }
a735 1
#else
d737 2
a738 1
dwarf2_finish ()
d740 1
a740 1
}
d742 6
a747 7
int
dwarf2dbg_estimate_size_before_relax (frag)
     fragS *frag ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
  return 0;
}
d749 1
a749 7
int
dwarf2dbg_relax_frag (frag)
     fragS *frag ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
  return 0;
}
d751 4
a754 5
void
dwarf2dbg_convert_frag (frag)
     fragS *frag ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
d758 2
a759 2
dwarf2_emit_insn (size)
     int size ATTRIBUTE_UNUSED;
d761 9
a770 15

void
dwarf2_directive_file (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  s_app_file (0);
}

void
dwarf2_directive_loc (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
}
#endif /* BFD_ASSEMBLER */
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a43 15
#include "dwarf2dbg.h"
#include <filenames.h>

#ifndef DWARF2_FORMAT
# define DWARF2_FORMAT() dwarf2_format_32bit
#endif

#ifndef DWARF2_ADDR_SIZE
# define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8);
#endif

#ifndef TC_DWARF2_EMIT_OFFSET
# define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset
#endif

d46 1
d125 1
a125 1
  const char *filename;
d134 1
a134 6
/* Table of directories used by .debug_line.  */
static char **dirs;
static unsigned int dirs_in_use;
static unsigned int dirs_allocated;

/* TRUE when we've seen a .loc directive recently.  Used to avoid
d136 1
a136 1
static bfd_boolean loc_directive_seen;
a146 1
static void generic_dwarf2_emit_offset PARAMS((symbolS *, unsigned int));
d148 1
a148 1
static unsigned int get_filenum PARAMS ((const char *, unsigned int));
a172 15
/* Create an offset to .dwarf2_*.  */

static void
generic_dwarf2_emit_offset (symbol, size)
     symbolS *symbol;
     unsigned int size;
{
  expressionS expr;

  expr.X_op = O_symbol;
  expr.X_add_symbol = symbol;
  expr.X_add_number = 0;
  emit_expr (&expr, size);
}

a232 2
  static unsigned int line = -1;
  static unsigned int filenum = -1;
a237 11
  /* Don't emit sequences of line symbols for the same line when the
     symbols apply to assembler code.  It is necessary to emit
     duplicate line symbols when a compiler asks for them, because GDB
     uses them to determine the end of the prologue.  */
  if (debug_type == DEBUG_DWARF2
      && line == loc->line && filenum == loc->filenum)
    return;

  line = loc->line;
  filenum = loc->filenum;

d257 1
a257 1
      line->filenum = get_filenum (filename, 0);
d276 1
a276 15
  if (loc_directive_seen)
    {
      /* Use the last location established by a .loc directive, not
	 the value returned by dwarf2_where().  That calls as_where()
	 which will return either the logical input file name (foo.c)
	or the physical input file name (foo.s) and not the file name
	specified in the most recent .loc directive (eg foo.h).  */
      loc = current;

      /* Unless we generate DWARF2 debugging information for each
	 assembler line, we only emit one line symbol for one LOC.  */
      if (debug_type != DEBUG_DWARF2)
	loc_directive_seen = FALSE;
    }
  else if (debug_type != DEBUG_DWARF2)
d278 1
a278 2
  else
    dwarf2_where (& loc);
d280 1
d284 1
a284 3
/* Get a .debug_line file number for FILENAME.  If NUM is nonzero,
   allocate it on that file table slot, otherwise return the first
   empty one.  */
d287 1
a287 1
get_filenum (filename, num)
a288 1
     unsigned int num;
d290 2
a291 29
  static unsigned int last_used, last_used_dir_len;
  const char *file;
  size_t dir_len;
  unsigned int i, dir;

  if (num == 0 && last_used)
    {
      if (! files[last_used].dir
	  && strcmp (filename, files[last_used].filename) == 0)
	return last_used;
      if (files[last_used].dir
	  && strncmp (filename, dirs[files[last_used].dir],
		      last_used_dir_len) == 0
	  && IS_DIR_SEPARATOR (filename [last_used_dir_len])
	  && strcmp (filename + last_used_dir_len + 1,
		     files[last_used].filename) == 0)
	return last_used;
    }

  file = lbasename (filename);
  /* Don't make empty string from / or A: from A:/ .  */
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  if (file <= filename + 3)
    file = filename;
#else
  if (file == filename + 1)
    file = filename;
#endif
  dir_len = file - filename;
d293 3
a295 8
  dir = 0;
  if (dir_len)
    {
      --dir_len;
      for (dir = 1; dir < dirs_in_use; ++dir)
	if (memcmp (filename, dirs[dir], dir_len) == 0
	    && dirs[dir][dir_len] == '\0')
	  break;
d297 3
a299 30
      if (dir >= dirs_in_use)
	{
	  if (dir >= dirs_allocated)
	    {
	      dirs_allocated = dir + 32;
	      dirs = (char **)
		     xrealloc (dirs, (dir + 32) * sizeof (const char *));
	    }

	  dirs[dir] = xmalloc (dir_len + 1);
	  memcpy (dirs[dir], filename, dir_len);
	  dirs[dir][dir_len] = '\0';
	  dirs_in_use = dir + 1;
	}
    }

  if (num == 0)
    {
      for (i = 1; i < files_in_use; ++i)
	if (files[i].dir == dir
	    && files[i].filename
	    && strcmp (file, files[i].filename) == 0)
	  {
	    last_used = i;
	    last_used_dir_len = dir_len;
	    return i;
	  }
    }
  else
    i = num;
d312 2
a313 2
  files[i].filename = num ? file : xstrdup (file);
  files[i].dir = dir;
a315 1
  last_used_dir_len = dir_len;
d320 1
a320 3
/* Handle two forms of .file directive:
   - Pass .file "source.c" to s_app_file
   - Handle .file 1 "source.c" by adding an entry to the DWARF-2 file table
d322 1
a322 3
   If an entry is added to the file table, return a pointer to the filename. */

char *
d335 1
a335 1
      return NULL;
d344 2
a345 2
      as_bad (_("file number less than one"));
      return NULL;
d348 1
a348 1
  if (num < (int) files_in_use && files[num].filename != 0)
d350 2
a351 2
      as_bad (_("file number %ld already allocated"), (long) num);
      return NULL;
d354 7
a360 1
  get_filenum (filename, num);
d362 7
a368 1
  return filename;
d386 1
a386 1
      as_bad (_("file number less than one"));
d391 1
a391 1
      as_bad (_("unassigned file number %ld"), (long) filenum);
d400 1
a400 1
  loc_directive_seen = TRUE;
d404 1
a404 17
    {
      if (files[filenum].dir)
	{
	  size_t dir_len = strlen (dirs[files[filenum].dir]);
	  size_t file_len = strlen (files[filenum].filename);
	  char *cp = (char *) alloca (dir_len + 1 + file_len + 1);

	  memcpy (cp, dirs[files[filenum].dir], dir_len);
	  cp[dir_len] = '/';
	  memcpy (cp + dir_len + 1, files[filenum].filename, file_len);
	  cp[dir_len + file_len + 1] = '\0';
	  listing_source_file (cp);
	}
      else
	listing_source_file (files[filenum].filename);
      listing_source_line (line);
    }
d527 2
a528 3
	long align_mask = -1 << get_recorded_alignment (fr->frch_seg);
	return (((char *) obstack_next_free (&fr->frch_obstack)
		 - frag->fr_literal) + ~align_mask) & align_mask;
a556 20
#if DWARF2_LINE_MIN_INSN_LENGTH > 1
static void scale_addr_delta PARAMS ((addressT *));

static void
scale_addr_delta (addr_delta)
     addressT *addr_delta;
{
  static int printed_this = 0;
  if (*addr_delta % DWARF2_LINE_MIN_INSN_LENGTH != 0)
    {
      if (!printed_this)
	as_bad("unaligned opcodes detected in executable segment");
      printed_this = 1;
    }
  *addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
}
#else
#define scale_addr_delta(A)
#endif

d573 4
a576 1
  scale_addr_delta (&addr_delta);
d639 1
d641 3
a643 2
  scale_addr_delta (&addr_delta);

d775 1
a775 1
  addr_delta = resolve_symbol_value (frag->fr_symbol);
d809 1
a809 1
  addr_diff = resolve_symbol_value (frag->fr_symbol);
d929 1
a929 8
  /* Emit directory list.  */
  for (i = 1; i < dirs_in_use; ++i)
    {
      size = strlen (dirs[i]) + 1;
      cp = frag_more (size);
      memcpy (cp, dirs[i], size);
    }
  /* Terminate it.  */
d936 1
a936 3
	  as_bad (_("unassigned file number %ld"), (long) i);
	  /* Prevent a crash later, particularly for file 1.  */
	  files[i].filename = "";
a963 2
  enum dwarf2_format d2f;
  int sizeof_offset;
d975 2
a976 25

  d2f = DWARF2_FORMAT ();
  if (d2f == dwarf2_format_32bit)
    {
      expr.X_add_number = -4;
      emit_expr (&expr, 4);
      sizeof_offset = 4;
    }
  else if (d2f == dwarf2_format_64bit)
    {
      expr.X_add_number = -12;
      out_four (-1);
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else if (d2f == dwarf2_format_64bit_irix)
    {
      expr.X_add_number = -8;
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else
    {
      as_fatal (_("internal error: unknown dwarf2 format"));
    }
d986 1
a986 1
  emit_expr (&expr, sizeof_offset);
d1051 4
a1054 2
  /* ??? sizeof_offset */
  TC_DWARF2_EMIT_OFFSET (section_symbol (info_seg), 4);
a1113 1
  out_abbrev (DW_AT_name, DW_FORM_string);
a1137 2
  enum dwarf2_format d2f;
  int sizeof_offset;
d1148 2
a1149 25

  d2f = DWARF2_FORMAT ();
  if (d2f == dwarf2_format_32bit)
    {
      expr.X_add_number = -4;
      emit_expr (&expr, 4);
      sizeof_offset = 4;
    }
  else if (d2f == dwarf2_format_64bit)
    {
      expr.X_add_number = -12;
      out_four (-1);
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else if (d2f == dwarf2_format_64bit_irix)
    {
      expr.X_add_number = -8;
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else
    {
      as_fatal (_("internal error: unknown dwarf2 format"));
    }
d1155 4
a1158 1
  TC_DWARF2_EMIT_OFFSET (section_symbol (abbrev_seg), sizeof_offset);
d1167 4
a1170 2
  /* ??? sizeof_offset */
  TC_DWARF2_EMIT_OFFSET (section_symbol (line_seg), 4);
a1188 17
  /* DW_AT_name.  We don't have the actual file name that was present
     on the command line, so assume files[1] is the main input file.
     We're not supposed to get called unless at least one line number
     entry was emitted, so this should always be defined.  */
  if (!files || files_in_use < 1)
    abort ();
  if (files[1].dir)
    {
      len = strlen (dirs[files[1].dir]);
      p = frag_more (len + 1);
      memcpy (p, dirs[files[1].dir], len);
      p[len] = '/';
    }
  len = strlen (files[1].filename) + 1;
  p = frag_more (len);
  memcpy (p, files[1].filename, len);

d1214 2
a1215 9
  /* We don't need to do anything unless:
     - Some debug information was recorded via .file/.loc
     - or, we are generating DWARF2 information ourself (--gdwarf2)
     - or, there is a user-provided .debug_info section which could
       reference the file table in the .debug_line section we generate
       below.  */
  if (all_segs == NULL
      && debug_type != DEBUG_DWARF2
      && bfd_get_section_by_name (stdoutput, ".debug_info") == NULL)
d1219 1
a1219 1
  sizeof_address = DWARF2_ADDR_SIZE (stdoutput);
d1242 1
a1242 1
  if (all_segs != NULL && debug_type == DEBUG_DWARF2)
d1299 1
a1299 1
char *
a1303 1
  return NULL;
@


1.1.1.4
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d52 5
a56 1
# define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8)
d160 3
d166 26
a191 23
static struct line_subseg *get_line_subseg (segT, subsegT);
static unsigned int get_filenum (const char *, unsigned int);
static struct frag *first_frag_for_seg (segT);
static struct frag *last_frag_for_seg (segT);
static void out_byte (int);
static void out_opcode (int);
static void out_two (int);
static void out_four (int);
static void out_abbrev (int, int);
static void out_uleb128 (addressT);
static offsetT get_frag_fix (fragS *);
static void out_set_addr (segT, fragS *, addressT);
static int size_inc_line_addr (int, addressT);
static void emit_inc_line_addr (int, addressT, char *, int);
static void out_inc_line_addr (int, addressT);
static void relax_inc_line_addr (int, segT, fragS *, addressT,
				 fragS *, addressT);
static void process_entries (segT, struct line_entry *);
static void out_file_list (void);
static void out_debug_line (segT);
static void out_debug_aranges (segT, segT);
static void out_debug_abbrev (segT);
static void out_debug_info (segT, segT, segT);
a192 4
#ifndef TC_DWARF2_EMIT_OFFSET
# define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset
static void generic_dwarf2_emit_offset (symbolS *, unsigned int);

d196 3
a198 1
generic_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
a206 1
#endif
d211 3
a213 1
get_line_subseg (segT seg, subsegT subseg)
d259 1
a259 1
/* Record an entry for LOC occurring at OFS within the current fragment.  */
d262 3
a264 1
dwarf2_gen_line_info (addressT ofs, struct dwarf2_line_info *loc)
d298 2
a299 1
dwarf2_where (struct dwarf2_line_info *line)
d319 2
a320 1
dwarf2_emit_insn (int size)
d351 3
a353 1
get_filenum (const char *filename, unsigned int num)
d390 1
a390 1
	if (strncmp (filename, dirs[dir], dir_len) == 0
d452 2
a453 1
dwarf2_directive_file (int dummy ATTRIBUTE_UNUSED)
d489 2
a490 1
dwarf2_directive_loc (int dummy ATTRIBUTE_UNUSED)
d542 2
a543 1
first_frag_for_seg (segT seg)
d556 2
a557 1
last_frag_for_seg (segT seg)
d572 2
a573 1
out_byte (int byte)
d581 2
a582 1
out_opcode (int opc)
d590 2
a591 1
out_two (int data)
d599 2
a600 1
out_four (int data)
d608 2
a609 1
out_uleb128 (addressT value)
d617 2
a618 1
out_abbrev (int name, int form)
d624 19
d646 2
a647 1
get_frag_fix (fragS *frag)
d659 5
a663 1
      return (char *) obstack_next_free (&fr->frch_obstack) - frag->fr_literal;
d671 4
a674 1
out_set_addr (segT seg, fragS *frag, addressT ofs)
d679 1
a679 1
  sym = symbol_temp_new (seg, ofs, frag);
d692 1
a692 1
static void scale_addr_delta (addressT *);
d695 2
a696 1
scale_addr_delta (addressT *addr_delta)
d719 3
a721 1
size_inc_line_addr (int line_delta, addressT addr_delta)
d780 5
a784 1
emit_inc_line_addr (int line_delta, addressT addr_delta, char *p, int len)
d875 3
a877 1
out_inc_line_addr (int line_delta, addressT addr_delta)
d887 5
a891 3
relax_inc_line_addr (int line_delta, segT seg,
		     fragS *to_frag, addressT to_ofs,
		     fragS *from_frag, addressT from_ofs)
d897 2
a898 2
  to_sym = symbol_temp_new (seg, to_ofs, to_frag);
  from_sym = symbol_temp_new (seg, from_ofs, from_frag);
d918 2
a919 1
dwarf2dbg_estimate_size_before_relax (fragS *frag)
d937 2
a938 1
dwarf2dbg_relax_frag (fragS *frag)
d953 2
a954 1
dwarf2dbg_convert_frag (fragS *frag)
d978 3
a980 1
process_entries (segT seg, struct line_entry *e)
d1072 1
a1072 1
out_file_list (void)
d1114 2
a1115 1
out_debug_line (segT line_seg)
d1127 3
a1129 3
  line_start = symbol_temp_new_now ();
  prologue_end = symbol_temp_make ();
  line_end = symbol_temp_make ();
d1191 1
a1191 1
  symbol_set_value_now (prologue_end);
d1197 1
a1197 1
  symbol_set_value_now (line_end);
d1203 3
a1205 1
out_debug_aranges (segT aranges_seg, segT info_seg)
d1253 1
a1253 1
      beg = symbol_temp_new (s->seg, 0, frag);
d1257 1
a1257 1
      end = symbol_temp_new (s->seg, get_frag_fix (frag), frag);
d1281 2
a1282 1
out_debug_abbrev (segT abbrev_seg)
d1308 4
a1311 1
out_debug_info (segT info_seg, segT abbrev_seg, segT line_seg)
d1325 2
a1326 2
  info_start = symbol_temp_new_now ();
  info_end = symbol_temp_make ();
d1424 1
a1424 1
  symbol_set_value_now (info_end);
d1428 1
a1428 1
dwarf2_finish (void)
@


