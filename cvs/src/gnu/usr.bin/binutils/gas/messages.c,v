head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.25;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.43;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.24;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.04.46;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.42;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.42;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.40;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.43.41;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.06;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.22.07;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.14;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.32.16;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.44;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* messages.c - error reporter -
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001, 2003
   Free Software Foundation, Inc.
   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "as.h"

#include <stdio.h>
#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif

#ifdef USE_STDARG
#include <stdarg.h>
#endif

#ifdef USE_VARARGS
#include <varargs.h>
#endif

#if !defined (USE_STDARG) && !defined (USE_VARARGS)
/* Roll our own.  */
#define va_alist REST
#define va_dcl
typedef int * va_list;
#define va_start(ARGS)	ARGS = &REST
#define va_end(ARGS)
#endif

static void identify (char *);
static void as_show_where (void);
static void as_warn_internal (char *, unsigned int, char *);
static void as_bad_internal (char *, unsigned int, char *);

/* Despite the rest of the comments in this file, (FIXME-SOON),
   here is the current scheme for error messages etc:

   as_fatal() is used when gas is quite confused and
   continuing the assembly is pointless.  In this case we
   exit immediately with error status.

   as_bad() is used to mark errors that result in what we
   presume to be a useless object file.  Say, we ignored
   something that might have been vital.  If we see any of
   these, assembly will continue to the end of the source,
   no object file will be produced, and we will terminate
   with error status.  The new option, -Z, tells us to
   produce an object file anyway but we still exit with
   error status.  The assumption here is that you don't want
   this object file but we could be wrong.

   as_warn() is used when we have an error from which we
   have a plausible error recovery.  eg, masking the top
   bits of a constant that is longer than will fit in the
   destination.  In this case we will continue to assemble
   the source, although we may have made a bad assumption,
   and we will produce an object file and return normal exit
   status (ie, no error).  The new option -X tells us to
   treat all as_warn() errors as as_bad() errors.  That is,
   no object file will be produced and we will exit with
   error status.  The idea here is that we don't kill an
   entire make because of an error that we knew how to
   correct.  On the other hand, sometimes you might want to
   stop the make at these points.

   as_tsktsk() is used when we see a minor error for which
   our error recovery action is almost certainly correct.
   In this case, we print a message and then assembly
   continues as though no error occurred.  */

static void
identify (char *file)
{
  static int identified;

  if (identified)
    return;
  identified++;

  if (!file)
    {
      unsigned int x;
      as_where (&file, &x);
    }

  if (file)
    fprintf (stderr, "%s: ", file);
  fprintf (stderr, _("Assembler messages:\n"));
}

/* The number of warnings issued.  */
static int warning_count;

int
had_warnings (void)
{
  return warning_count;
}

/* Nonzero if we've hit a 'bad error', and should not write an obj file,
   and exit with a nonzero error code.  */

static int error_count;

int
had_errors (void)
{
  return error_count;
}

/* Print the current location to stderr.  */

static void
as_show_where (void)
{
  char *file;
  unsigned int line;

  as_where (&file, &line);
  identify (file);
  if (file)
    fprintf (stderr, "%s:%u: ", file, line);
}

/* Like perror(3), but with more info.  */

void
as_perror (const char *gripe,		/* Unpunctuated error theme.  */
	   const char *filename)
{
  const char *errtxt;
  int saved_errno = errno;

  as_show_where ();
  fprintf (stderr, gripe, filename);
  errno = saved_errno;
#ifdef BFD_ASSEMBLER
  errtxt = bfd_errmsg (bfd_get_error ());
#else
  errtxt = xstrerror (errno);
#endif
  fprintf (stderr, ": %s\n", errtxt);
  errno = 0;
#ifdef BFD_ASSEMBLER
  bfd_set_error (bfd_error_no_error);
#endif
}

/* Send to stderr a string as a warning, and locate warning
   in input file(s).
   Please only use this for when we have some recovery action.
   Please explain in string (which may have '\n's) what recovery was
   done.  */

#ifdef USE_STDARG
void
as_tsktsk (const char *format, ...)
{
  va_list args;

  as_show_where ();
  va_start (args, format);
  vfprintf (stderr, format, args);
  va_end (args);
  (void) putc ('\n', stderr);
}
#else
void
as_tsktsk (format, va_alist)
     const char *format;
     va_dcl
{
  va_list args;

  as_show_where ();
  va_start (args);
  vfprintf (stderr, format, args);
  va_end (args);
  (void) putc ('\n', stderr);
}
#endif /* not NO_STDARG */

/* The common portion of as_warn and as_warn_where.  */

static void
as_warn_internal (char *file, unsigned int line, char *buffer)
{
  ++warning_count;

  if (file == NULL)
    as_where (&file, &line);

  identify (file);
  if (file)
    fprintf (stderr, "%s:%u: ", file, line);
  fprintf (stderr, _("Warning: "));
  fputs (buffer, stderr);
  (void) putc ('\n', stderr);
#ifndef NO_LISTING
  listing_warning (buffer);
#endif
}

/* Send to stderr a string as a warning, and locate warning
   in input file(s).
   Please only use this for when we have some recovery action.
   Please explain in string (which may have '\n's) what recovery was
   done.  */

#ifdef USE_STDARG
void
as_warn (const char *format, ...)
{
  va_list args;
  char buffer[2000];

  if (!flag_no_warnings)
    {
      va_start (args, format);
      vsprintf (buffer, format, args);
      va_end (args);
      as_warn_internal ((char *) NULL, 0, buffer);
    }
}
#else
void
as_warn (format, va_alist)
     const char *format;
     va_dcl
{
  va_list args;
  char buffer[2000];

  if (!flag_no_warnings)
    {
      va_start (args);
      vsprintf (buffer, format, args);
      va_end (args);
      as_warn_internal ((char *) NULL, 0, buffer);
    }
}
#endif /* not NO_STDARG */

/* Like as_bad but the file name and line number are passed in.
   Unfortunately, we have to repeat the function in order to handle
   the varargs correctly and portably.  */

#ifdef USE_STDARG
void
as_warn_where (char *file, unsigned int line, const char *format, ...)
{
  va_list args;
  char buffer[2000];

  if (!flag_no_warnings)
    {
      va_start (args, format);
      vsprintf (buffer, format, args);
      va_end (args);
      as_warn_internal (file, line, buffer);
    }
}
#else
void
as_warn_where (file, line, format, va_alist)
     char *file;
     unsigned int line;
     const char *format;
     va_dcl
{
  va_list args;
  char buffer[2000];

  if (!flag_no_warnings)
    {
      va_start (args);
      vsprintf (buffer, format, args);
      va_end (args);
      as_warn_internal (file, line, buffer);
    }
}
#endif /* not NO_STDARG */

/* The common portion of as_bad and as_bad_where.  */

static void
as_bad_internal (char *file, unsigned int line, char *buffer)
{
  ++error_count;

  if (file == NULL)
    as_where (&file, &line);

  identify (file);
  if (file)
    fprintf (stderr, "%s:%u: ", file, line);
  fprintf (stderr, _("Error: "));
  fputs (buffer, stderr);
  (void) putc ('\n', stderr);
#ifndef NO_LISTING
  listing_error (buffer);
#endif
}

/* Send to stderr a string as a warning, and locate warning in input
   file(s).  Please us when there is no recovery, but we want to
   continue processing but not produce an object file.
   Please explain in string (which may have '\n's) what recovery was
   done.  */

#ifdef USE_STDARG
void
as_bad (const char *format, ...)
{
  va_list args;
  char buffer[2000];

  va_start (args, format);
  vsprintf (buffer, format, args);
  va_end (args);

  as_bad_internal ((char *) NULL, 0, buffer);
}

#else
void
as_bad (format, va_alist)
     const char *format;
     va_dcl
{
  va_list args;
  char buffer[2000];

  va_start (args);
  vsprintf (buffer, format, args);
  va_end (args);

  as_bad_internal ((char *) NULL, 0, buffer);
}
#endif /* not NO_STDARG */

/* Like as_bad but the file name and line number are passed in.
   Unfortunately, we have to repeat the function in order to handle
   the varargs correctly and portably.  */

#ifdef USE_STDARG
void
as_bad_where (char *file, unsigned int line, const char *format, ...)
{
  va_list args;
  char buffer[2000];

  va_start (args, format);
  vsprintf (buffer, format, args);
  va_end (args);

  as_bad_internal (file, line, buffer);
}

#else
void
as_bad_where (file, line, format, va_alist)
     char *file;
     unsigned int line;
     const char *format;
     va_dcl
{
  va_list args;
  char buffer[2000];

  va_start (args);
  vsprintf (buffer, format, args);
  va_end (args);

  as_bad_internal (file, line, buffer);
}
#endif /* not NO_STDARG */

/* Send to stderr a string as a fatal message, and print location of
   error in input file(s).
   Please only use this for when we DON'T have some recovery action.
   It xexit()s with a warning status.  */

#ifdef USE_STDARG
void
as_fatal (const char *format, ...)
{
  va_list args;

  as_show_where ();
  va_start (args, format);
  fprintf (stderr, _("Fatal error: "));
  vfprintf (stderr, format, args);
  (void) putc ('\n', stderr);
  va_end (args);
  /* Delete the output file, if it exists.  This will prevent make from
     thinking that a file was created and hence does not need rebuilding.  */
  if (out_file_name != NULL)
    unlink (out_file_name);
  xexit (EXIT_FAILURE);
}
#else
void
as_fatal (format, va_alist)
     char *format;
     va_dcl
{
  va_list args;

  as_show_where ();
  va_start (args);
  fprintf (stderr, _("Fatal error: "));
  vfprintf (stderr, format, args);
  (void) putc ('\n', stderr);
  va_end (args);
  xexit (EXIT_FAILURE);
}
#endif /* not NO_STDARG */

/* Indicate assertion failure.
   Arguments: Filename, line number, optional function name.  */

void
as_assert (const char *file, int line, const char *fn)
{
  as_show_where ();
  fprintf (stderr, _("Internal error!\n"));
  if (fn)
    fprintf (stderr, _("Assertion failure in %s at %s line %d.\n"),
	     fn, file, line);
  else
    fprintf (stderr, _("Assertion failure at %s line %d.\n"), file, line);
  fprintf (stderr, _("Please report this bug.\n"));
  xexit (EXIT_FAILURE);
}

/* as_abort: Print a friendly message saying how totally hosed we are,
   and exit without producing a core file.  */

void
as_abort (const char *file, int line, const char *fn)
{
  as_show_where ();
  if (fn)
    fprintf (stderr, _("Internal error, aborting at %s line %d in %s\n"),
	     file, line, fn);
  else
    fprintf (stderr, _("Internal error, aborting at %s line %d\n"),
	     file, line);
  fprintf (stderr, _("Please report this bug.\n"));
  xexit (EXIT_FAILURE);
}

/* Support routines.  */

void
fprint_value (FILE *file, valueT val)
{
  if (sizeof (val) <= sizeof (long))
    {
      fprintf (file, "%ld", (long) val);
      return;
    }
#ifdef BFD_ASSEMBLER
  if (sizeof (val) <= sizeof (bfd_vma))
    {
      fprintf_vma (file, val);
      return;
    }
#endif
  abort ();
}

void
sprint_value (char *buf, valueT val)
{
  if (sizeof (val) <= sizeof (long))
    {
      sprintf (buf, "%ld", (long) val);
      return;
    }
#ifdef BFD_ASSEMBLER
  if (sizeof (val) <= sizeof (bfd_vma))
    {
      sprintf_vma (buf, val);
      return;
    }
#endif
  abort ();
}
@


1.6
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001
d45 4
a48 4
static void identify PARAMS ((char *));
static void as_show_where PARAMS ((void));
static void as_warn_internal PARAMS ((char *, unsigned int, char *));
static void as_bad_internal PARAMS ((char *, unsigned int, char *));
d51 34
a84 35
 * here is the current scheme for error messages etc:
 *
 * as_fatal() is used when gas is quite confused and
 * continuing the assembly is pointless.  In this case we
 * exit immediately with error status.
 *
 * as_bad() is used to mark errors that result in what we
 * presume to be a useless object file.  Say, we ignored
 * something that might have been vital.  If we see any of
 * these, assembly will continue to the end of the source,
 * no object file will be produced, and we will terminate
 * with error status.  The new option, -Z, tells us to
 * produce an object file anyway but we still exit with
 * error status.  The assumption here is that you don't want
 * this object file but we could be wrong.
 *
 * as_warn() is used when we have an error from which we
 * have a plausible error recovery.  eg, masking the top
 * bits of a constant that is longer than will fit in the
 * destination.  In this case we will continue to assemble
 * the source, although we may have made a bad assumption,
 * and we will produce an object file and return normal exit
 * status (ie, no error).  The new option -X tells us to
 * treat all as_warn() errors as as_bad() errors.  That is,
 * no object file will be produced and we will exit with
 * error status.  The idea here is that we don't kill an
 * entire make because of an error that we knew how to
 * correct.  On the other hand, sometimes you might want to
 * stop the make at these points.
 *
 * as_tsktsk() is used when we see a minor error for which
 * our error recovery action is almost certainly correct.
 * In this case, we print a message and then assembly
 * continues as though no error occurred.
 */
d87 1
a87 2
identify (file)
     char *file;
d90 1
d110 1
a110 1
had_warnings ()
d112 1
a112 1
  return (warning_count);
d121 1
a121 1
had_errors ()
d123 1
a123 1
  return (error_count);
d129 1
a129 1
as_show_where ()
d143 2
a144 3
as_perror (gripe, filename)
     const char *gripe;		/* Unpunctuated error theme.  */
     const char *filename;
d147 1
d151 1
d201 1
a201 4
as_warn_internal (file, line, buffer)
     char *file;
     unsigned int line;
     char *buffer;
d302 1
a302 4
as_bad_internal (file, line, buffer)
     char *file;
     unsigned int line;
     char *buffer;
d439 1
a439 3
as_assert (file, line, fn)
     const char *file, *fn;
     int line;
d456 1
a456 3
as_abort (file, line, fn)
     const char *file, *fn;
     int line;
d472 1
a472 3
fprint_value (file, val)
     FILE *file;
     valueT val;
d490 1
a490 3
sprint_value (buf, val)
     char *buf;
     valueT val;
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 1998
d19 1
a19 1
   02111-1307, USA. */
d50 1
a50 2
/*
 * Despite the rest of the comments in this file, (FIXME-SOON),
d107 2
a108 1
static int warning_count;	/* Count of number of warnings issued */
d110 1
a110 1
int 
d117 1
a117 1
   and exit with a nonzero error code */
d121 1
a121 1
int 
a126 1

d141 1
a141 5
/*
 *			a s _ p e r r o r
 *
 * Like perror(3), but with more info.
 */
d143 1
a143 1
void 
d145 1
a145 1
     const char *gripe;		/* Unpunctuated error theme. */
d164 5
a168 8
/*
 *			a s _ t s k t s k ()
 *
 * Send to stderr a string as a warning, and locate warning
 * in input file(s).
 * Please only use this for when we have some recovery action.
 * Please explain in string (which may have '\n's) what recovery was done.
 */
d171 2
a172 2
void 
as_tsktsk (const char *format,...)
d181 1
a181 1
}				/* as_tsktsk() */
d183 1
a183 1
void 
d195 1
a195 1
}				/* as_tsktsk() */
d222 5
a226 8
/*
 *			a s _ w a r n ()
 *
 * Send to stderr a string as a warning, and locate warning
 * in input file(s).
 * Please only use this for when we have some recovery action.
 * Please explain in string (which may have '\n's) what recovery was done.
 */
d229 2
a230 2
void 
as_warn (const char *format,...)
d242 1
a242 1
}				/* as_warn() */
d244 1
a244 2
/*VARARGS1 */
void 
d259 1
a259 1
}				/* as_warn() */
d262 3
a264 3
/* as_warn_where, like as_bad but the file name and line number are
   passed in.  Unfortunately, we have to repeat the function in order
   to handle the varargs correctly and portably.  */
d267 2
a268 2
void 
as_warn_where (char *file, unsigned int line, const char *format,...)
d280 1
a280 1
}				/* as_warn() */
d282 1
a282 2
/*VARARGS1 */
void 
d299 1
a299 1
}				/* as_warn() */
d326 5
a330 8
/*
 *			a s _ b a d ()
 *
 * Send to stderr a string as a warning, and locate warning in input file(s).
 * Please us when there is no recovery, but we want to continue processing
 * but not produce an object file.
 * Please explain in string (which may have '\n's) what recovery was done.
 */
d333 2
a334 2
void 
as_bad (const char *format,...)
d347 1
a347 2
/*VARARGS1 */
void 
d363 3
a365 3
/* as_bad_where, like as_bad but the file name and line number are
   passed in.  Unfortunately, we have to repeat the function in order
   to handle the varargs correctly and portably.  */
d368 2
a369 2
void 
as_bad_where (char *file, unsigned int line, const char *format,...)
d382 1
a382 2
/*VARARGS1 */
void 
d400 4
a403 8
/*
 *			a s _ f a t a l ()
 *
 * Send to stderr a string as a fatal message, and print location of error in
 * input file(s).
 * Please only use this for when we DON'T have some recovery action.
 * It xexit()s with a warning status.
 */
d406 2
a407 2
void 
as_fatal (const char *format,...)
d417 4
d422 1
a422 1
}				/* as_fatal() */
d424 1
a424 2
/*VARARGS1*/
void 
d438 1
a438 1
}				/* as_fatal() */
d441 2
a442 4
/*
 * as_assert: Indicate assertion failure.
 * Arguments: Filename, line number, optional function name.
 */
d462 1
a519 2

/* end of messages.c */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 2
   Copyright (C) 1987, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.

d45 1
d105 1
a105 1
  fprintf (stderr, "Assembler messages:\n");
d222 1
a222 1
  fprintf (stderr, "Warning: ");
d244 1
a244 1
  char buffer[200];
d262 1
a262 1
  char buffer[200];
d283 1
a283 1
  char buffer[200];
d303 1
a303 1
  char buffer[200];
d331 1
a331 1
  fprintf (stderr, "Error: ");
d353 1
a353 1
  char buffer[200];
d370 1
a370 1
  char buffer[200];
d389 1
a389 1
  char buffer[200];
d408 1
a408 1
  char buffer[200];
d435 1
a435 1
  fprintf (stderr, "Fatal error: ");
d452 1
a452 1
  fprintf (stderr, "Fatal error: ");
d471 1
a471 2
  fprintf (stderr, "Internal error!\n");
  fprintf (stderr, "Assertion failure");
d473 5
a477 3
    fprintf (stderr, " in %s", fn);
  fprintf (stderr, " at %s line %d.\n", file, line);
  fprintf (stderr, "Please report this bug.\n");
a488 1
  fprintf (stderr, "Internal error, aborting at %s line %d", file, line);
d490 6
a495 2
    fprintf (stderr, " in %s", fn);
  fprintf (stderr, "\nPlease report this bug.\n");
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@a21 1
#include "libiberty.h"
a43 2

extern char *xstrerror PARAMS ((int));	/* from libiberty */
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1991, 1992, 1995 Free Software Foundation, Inc.
d17 3
a19 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d22 1
d506 1
a506 1
      fprintf (file, "%ld", val);
d526 1
a526 1
      sprintf (buf, "%ld", val);
@


1.1
log
@Initial revision
@
text
@d424 1
a424 1
 * It exit()s with a warning status.
d439 1
a439 1
  exit (EXIT_FAILURE);
d456 1
a456 1
  exit (EXIT_FAILURE);
d477 1
a477 1
  exit (EXIT_FAILURE);
d492 1
a492 1
  exit (EXIT_FAILURE);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d424 1
a424 1
 * It xexit()s with a warning status.
d439 1
a439 1
  xexit (EXIT_FAILURE);
d456 1
a456 1
  xexit (EXIT_FAILURE);
d477 1
a477 1
  xexit (EXIT_FAILURE);
d492 1
a492 1
  xexit (EXIT_FAILURE);
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA. */
a20 1
#include "libiberty.h"
d504 1
a504 1
      fprintf (file, "%ld", (long) val);
d524 1
a524 1
      sprintf (buf, "%ld", (long) val);
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d22 1
d45 2
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 2
a3 2
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 1997
   Free Software Foundation, Inc.
a44 1
static void identify PARAMS ((char *));
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 1998
d105 1
a105 1
  fprintf (stderr, _("Assembler messages:\n"));
d222 1
a222 1
  fprintf (stderr, _("Warning: "));
d244 1
a244 1
  char buffer[2000];
d262 1
a262 1
  char buffer[2000];
d283 1
a283 1
  char buffer[2000];
d303 1
a303 1
  char buffer[2000];
d331 1
a331 1
  fprintf (stderr, _("Error: "));
d353 1
a353 1
  char buffer[2000];
d370 1
a370 1
  char buffer[2000];
d389 1
a389 1
  char buffer[2000];
d408 1
a408 1
  char buffer[2000];
d435 1
a435 1
  fprintf (stderr, _("Fatal error: "));
d452 1
a452 1
  fprintf (stderr, _("Fatal error: "));
d471 2
a472 1
  fprintf (stderr, _("Internal error!\n"));
d474 3
a476 5
    fprintf (stderr, _("Assertion failure in %s at %s line %d.\n"),
	     fn, file, line);
  else
    fprintf (stderr, _("Assertion failure at %s line %d.\n"), file, line);
  fprintf (stderr, _("Please report this bug.\n"));
d488 1
d490 2
a491 6
    fprintf (stderr, _("Internal error, aborting at %s line %d in %s\n"),
	     file, line, fn);
  else
    fprintf (stderr, _("Internal error, aborting at %s line %d\n"),
	     file, line);
  fprintf (stderr, _("Please report this bug.\n"));
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001
d19 1
a19 1
   02111-1307, USA.  */
d50 2
a51 1
/* Despite the rest of the comments in this file, (FIXME-SOON),
d108 1
a108 2
/* The number of warnings issued.  */
static int warning_count;
d110 1
a110 1
int
d117 1
a117 1
   and exit with a nonzero error code.  */
d121 1
a121 1
int
d127 1
d142 5
a146 1
/* Like perror(3), but with more info.  */
d148 1
a148 1
void
d150 1
a150 1
     const char *gripe;		/* Unpunctuated error theme.  */
d169 8
a176 5
/* Send to stderr a string as a warning, and locate warning
   in input file(s).
   Please only use this for when we have some recovery action.
   Please explain in string (which may have '\n's) what recovery was
   done.  */
d179 2
a180 2
void
as_tsktsk (const char *format, ...)
d189 1
a189 1
}
d191 1
a191 1
void
d203 1
a203 1
}
d230 8
a237 5
/* Send to stderr a string as a warning, and locate warning
   in input file(s).
   Please only use this for when we have some recovery action.
   Please explain in string (which may have '\n's) what recovery was
   done.  */
d240 2
a241 2
void
as_warn (const char *format, ...)
d253 1
a253 1
}
d255 2
a256 1
void
d271 1
a271 1
}
d274 3
a276 3
/* Like as_bad but the file name and line number are passed in.
   Unfortunately, we have to repeat the function in order to handle
   the varargs correctly and portably.  */
d279 2
a280 2
void
as_warn_where (char *file, unsigned int line, const char *format, ...)
d292 1
a292 1
}
d294 2
a295 1
void
d312 1
a312 1
}
d339 8
a346 5
/* Send to stderr a string as a warning, and locate warning in input
   file(s).  Please us when there is no recovery, but we want to
   continue processing but not produce an object file.
   Please explain in string (which may have '\n's) what recovery was
   done.  */
d349 2
a350 2
void
as_bad (const char *format, ...)
d363 2
a364 1
void
d380 3
a382 3
/* Like as_bad but the file name and line number are passed in.
   Unfortunately, we have to repeat the function in order to handle
   the varargs correctly and portably.  */
d385 2
a386 2
void
as_bad_where (char *file, unsigned int line, const char *format, ...)
d399 2
a400 1
void
d418 8
a425 4
/* Send to stderr a string as a fatal message, and print location of
   error in input file(s).
   Please only use this for when we DON'T have some recovery action.
   It xexit()s with a warning status.  */
d428 2
a429 2
void
as_fatal (const char *format, ...)
a438 4
  /* Delete the output file, if it exists.  This will prevent make from
     thinking that a file was created and hence does not need rebuilding.  */
  if (out_file_name != NULL)
    unlink (out_file_name);
d440 1
a440 1
}
d442 2
a443 1
void
d457 1
a457 1
}
d460 4
a463 2
/* Indicate assertion failure.
   Arguments: Filename, line number, optional function name.  */
a482 1

d540 2
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001, 2003
d45 4
a48 4
static void identify (char *);
static void as_show_where (void);
static void as_warn_internal (char *, unsigned int, char *);
static void as_bad_internal (char *, unsigned int, char *);
d51 35
a85 34
   here is the current scheme for error messages etc:

   as_fatal() is used when gas is quite confused and
   continuing the assembly is pointless.  In this case we
   exit immediately with error status.

   as_bad() is used to mark errors that result in what we
   presume to be a useless object file.  Say, we ignored
   something that might have been vital.  If we see any of
   these, assembly will continue to the end of the source,
   no object file will be produced, and we will terminate
   with error status.  The new option, -Z, tells us to
   produce an object file anyway but we still exit with
   error status.  The assumption here is that you don't want
   this object file but we could be wrong.

   as_warn() is used when we have an error from which we
   have a plausible error recovery.  eg, masking the top
   bits of a constant that is longer than will fit in the
   destination.  In this case we will continue to assemble
   the source, although we may have made a bad assumption,
   and we will produce an object file and return normal exit
   status (ie, no error).  The new option -X tells us to
   treat all as_warn() errors as as_bad() errors.  That is,
   no object file will be produced and we will exit with
   error status.  The idea here is that we don't kill an
   entire make because of an error that we knew how to
   correct.  On the other hand, sometimes you might want to
   stop the make at these points.

   as_tsktsk() is used when we see a minor error for which
   our error recovery action is almost certainly correct.
   In this case, we print a message and then assembly
   continues as though no error occurred.  */
d88 2
a89 1
identify (char *file)
a91 1

d111 1
a111 1
had_warnings (void)
d113 1
a113 1
  return warning_count;
d122 1
a122 1
had_errors (void)
d124 1
a124 1
  return error_count;
d130 1
a130 1
as_show_where (void)
d144 3
a146 2
as_perror (const char *gripe,		/* Unpunctuated error theme.  */
	   const char *filename)
a148 1
  int saved_errno = errno;
a151 1
  errno = saved_errno;
d201 4
a204 1
as_warn_internal (char *file, unsigned int line, char *buffer)
d305 4
a308 1
as_bad_internal (char *file, unsigned int line, char *buffer)
d445 3
a447 1
as_assert (const char *file, int line, const char *fn)
d464 3
a466 1
as_abort (const char *file, int line, const char *fn)
d482 3
a484 1
fprint_value (FILE *file, valueT val)
d502 3
a504 1
sprint_value (char *buf, valueT val)
@


