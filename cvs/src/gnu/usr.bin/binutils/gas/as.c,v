head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.12
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.34
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.32
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.28
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.26
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.24
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.22
	OPENBSD_5_0:1.11.0.20
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.18
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.16
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.12
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.14
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.10
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.8
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.8
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.6.0.8
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	new-binutils:1.5.0.14
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.08.31.13.40.02;	author tobiasu;	state Exp;
branches;
next	1.11;
commitid	dbwlUkpK0xDlII16;

1.11
date	2006.10.24.04.48.00;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.02.20.45.22;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.17.21.54.28;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.19.13.50.20;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.12.19.11.40;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	97.01.21.10.33.02;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.14;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.04.10;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.13;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.31;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.31;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.20;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.43.11;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.13.54;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.21.31;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.07;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.31.02;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.24;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.41;	author miod;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Backport @@file support from binutils-2.17

@@file allows reading command line arguments from a file. Gcc now uses this to
pass very long arguments lists to ld.

ok guenther@@ miod@@
@
text
@/* as.c - GAS main program.
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Main program for AS; a 32-bit assembler of GNU.
   Understands command arguments.
   Has a few routines that don't fit in other modules because they
   are shared.
  
  			bugs
  
   : initialisers
  	Since no-one else says they will support them in future: I
   don't support them now.  */

#include "ansidecl.h"

#define COMMON

#include "as.h"
#include "subsegs.h"
#include "output-file.h"
#include "sb.h"
#include "macro.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"

#ifdef BFD_ASSEMBLER
#include "bfdver.h"
#endif

#ifdef HAVE_ITBL_CPU
#include "itbl-ops.h"
#else
#define itbl_parse(itbl_file) 1
#define itbl_init()
#endif

#ifdef HAVE_SBRK
#ifdef NEED_DECLARATION_SBRK
extern PTR sbrk ();
#endif
#endif

#ifdef USING_CGEN
/* Perform any cgen specific initialisation for gas.  */
extern void gas_cgen_begin (void);
#endif

/* Keep a record of the itbl files we read in.  */
struct itbl_file_list
{
  struct itbl_file_list *next;
  char *name;
};

/* We build a list of defsyms as we read the options, and then define
   them after we have initialized everything.  */
struct defsym_list
{
  struct defsym_list *next;
  char *name;
  valueT value;
};


/* True if a listing is wanted.  */
int listing;

/* Type of debugging to generate.  */
enum debug_info_type debug_type = DEBUG_UNSPECIFIED;
int use_gnu_debug_info_extensions = 0;

/* Maximum level of macro nesting.  */
int max_macro_nest = 100;

/* argv[0]  */
char * myname;

/* The default obstack chunk size.  If we set this to zero, the
   obstack code will use whatever will fit in a 4096 byte block.  */
int chunksize = 0;

/* To monitor memory allocation more effectively, make this non-zero.
   Then the chunk sizes for gas and bfd will be reduced.  */
int debug_memory = 0;

/* Enable verbose mode.  */
int verbose = 0;

#ifdef BFD_ASSEMBLER
segT reg_section;
segT expr_section;
segT text_section;
segT data_section;
segT bss_section;
#endif

/* Name of listing file.  */
static char *listing_filename = NULL;

static struct defsym_list *defsyms;

static struct itbl_file_list *itbl_files;

static long start_time;


#ifdef USE_EMULATIONS
#define EMULATION_ENVIRON "AS_EMULATION"

extern struct emulation mipsbelf, mipslelf, mipself;
extern struct emulation mipsbecoff, mipslecoff, mipsecoff;
extern struct emulation i386coff, i386elf, i386aout;
extern struct emulation crisaout, criself;

static struct emulation *const emulations[] = { EMULATIONS };
static const int n_emulations = sizeof (emulations) / sizeof (emulations[0]);

static void
select_emulation_mode (int argc, char **argv)
{
  int i;
  char *p, *em = 0;

  for (i = 1; i < argc; i++)
    if (!strncmp ("--em", argv[i], 4))
      break;

  if (i == argc)
    goto do_default;

  p = strchr (argv[i], '=');
  if (p)
    p++;
  else
    p = argv[i + 1];

  if (!p || !*p)
    as_fatal (_("missing emulation mode name"));
  em = p;

 do_default:
  if (em == 0)
    em = getenv (EMULATION_ENVIRON);
  if (em == 0)
    em = DEFAULT_EMULATION;

  if (em)
    {
      for (i = 0; i < n_emulations; i++)
	if (!strcmp (emulations[i]->name, em))
	  break;
      if (i == n_emulations)
	as_fatal (_("unrecognized emulation name `%s'"), em);
      this_emulation = emulations[i];
    }
  else
    this_emulation = emulations[0];

  this_emulation->init ();
}

const char *
default_emul_bfd_name (void)
{
  abort ();
  return NULL;
}

void
common_emul_init (void)
{
  this_format = this_emulation->format;

  if (this_emulation->leading_underscore == 2)
    this_emulation->leading_underscore = this_format->dfl_leading_underscore;

  if (this_emulation->default_endian != 2)
    target_big_endian = this_emulation->default_endian;

  if (this_emulation->fake_label_name == 0)
    {
      if (this_emulation->leading_underscore)
	this_emulation->fake_label_name = "L0\001";
      else
	/* What other parameters should we test?  */
	this_emulation->fake_label_name = ".L0\001";
    }
}
#endif

void
print_version_id (void)
{
  static int printed;

  if (printed)
    return;
  printed = 1;

#ifdef BFD_ASSEMBLER
  fprintf (stderr, _("GNU assembler version %s (%s) using BFD version %s"),
	   VERSION, TARGET_ALIAS, BFD_VERSION_STRING);
#else
  fprintf (stderr, _("GNU assembler version %s (%s)"), VERSION, TARGET_ALIAS);
#endif
  fprintf (stderr, "\n");
}

static void
show_usage (FILE * stream)
{
  fprintf (stream, _("Usage: %s [option...] [asmfile...]\n"), myname);

  fprintf (stream, _("\
Options:\n\
  -a[sub-option...]	  turn on listings\n\
                      	  Sub-options [default hls]:\n\
                      	  c      omit false conditionals\n\
                      	  d      omit debugging directives\n\
                      	  h      include high-level source\n\
                      	  l      include assembly\n\
                      	  m      include macro expansions\n\
                      	  n      omit forms processing\n\
                      	  s      include symbols\n\
                      	  =FILE  list to FILE (must be last sub-option)\n"));

  fprintf (stream, _("\
  -D                      produce assembler debugging messages\n"));
  fprintf (stream, _("\
  --defsym SYM=VAL        define symbol SYM to given value\n"));
#ifdef USE_EMULATIONS
  {
    int i;
    char *def_em;

    fprintf (stream, "\
  --em=[");
    for (i = 0; i < n_emulations - 1; i++)
      fprintf (stream, "%s | ", emulations[i]->name);
    fprintf (stream, "%s]\n", emulations[i]->name);

    def_em = getenv (EMULATION_ENVIRON);
    if (!def_em)
      def_em = DEFAULT_EMULATION;
    fprintf (stream, _("\
                          emulate output (default %s)\n"), def_em);
  }
#endif
#if defined BFD_ASSEMBLER && (defined OBJ_ELF || defined OBJ_MAYBE_ELF)
  fprintf (stream, _("\
  --execstack             require executable stack for this object\n"));
  fprintf (stream, _("\
  --noexecstack           don't require executable stack for this object\n"));
#endif
  fprintf (stream, _("\
  -f                      skip whitespace and comment preprocessing\n"));
  fprintf (stream, _("\
  --gstabs                generate stabs debugging information\n"));
  fprintf (stream, _("\
  --gstabs+               generate stabs debug info with GNU extensions\n"));
  fprintf (stream, _("\
  --gdwarf2               generate DWARF2 debugging information\n"));
  fprintf (stream, _("\
  --help                  show this message and exit\n"));
  fprintf (stream, _("\
  --target-help           show target specific options\n"));
  fprintf (stream, _("\
  -I DIR                  add DIR to search list for .include directives\n"));
  fprintf (stream, _("\
  -J                      don't warn about signed overflow\n"));
  fprintf (stream, _("\
  -K                      warn when differences altered for long displacements\n"));
  fprintf (stream, _("\
  -L,--keep-locals        keep local symbols (e.g. starting with `L')\n"));
  fprintf (stream, _("\
  -M,--mri                assemble in MRI compatibility mode\n"));
  fprintf (stream, _("\
  --MD FILE               write dependency information in FILE (default none)\n"));
  fprintf (stream, _("\
  -nocpp                  ignored\n"));
  fprintf (stream, _("\
  -o OBJFILE              name the object-file output OBJFILE (default a.out)\n"));
  fprintf (stream, _("\
  -R                      fold data section into text section\n"));
  fprintf (stream, _("\
  --statistics            print various measured statistics from execution\n"));
  fprintf (stream, _("\
  --strip-local-absolute  strip local absolute symbols\n"));
  fprintf (stream, _("\
  --traditional-format    Use same format as native assembler when possible\n"));
  fprintf (stream, _("\
  --version               print assembler version number and exit\n"));
  fprintf (stream, _("\
  -W  --no-warn           suppress warnings\n"));
  fprintf (stream, _("\
  --warn                  don't suppress warnings\n"));
  fprintf (stream, _("\
  --fatal-warnings        treat warnings as errors\n"));
  fprintf (stream, _("\
  --itbl INSTTBL          extend instruction set to include instructions\n\
                          matching the specifications defined in file INSTTBL\n"));
  fprintf (stream, _("\
  -w                      ignored\n"));
  fprintf (stream, _("\
  -X                      ignored\n"));
  fprintf (stream, _("\
  -Z                      generate object file even after errors\n"));
  fprintf (stream, _("\
  --listing-lhs-width     set the width in words of the output data column of\n\
                          the listing\n"));
  fprintf (stream, _("\
  --listing-lhs-width2    set the width in words of the continuation lines\n\
                          of the output data column; ignored if smaller than\n\
                          the width of the first line\n"));
  fprintf (stream, _("\
  --listing-rhs-width     set the max width in characters of the lines from\n\
                          the source file\n"));
  fprintf (stream, _("\
  --listing-cont-lines    set the maximum number of continuation lines used\n\
                          for the output data column of the listing\n"));

  md_show_usage (stream);

  fputc ('\n', stream);
  fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
}

/* Since it is easy to do here we interpret the special arg "-"
   to mean "use stdin" and we set that argv[] pointing to "".
   After we have munged argv[], the only things left are source file
   name(s) and ""(s) denoting stdin. These file names are used
   (perhaps more than once) later.

   check for new machine-dep cmdline options in
   md_parse_option definitions in config/tc-*.c.  */

static void
parse_args (int * pargc, char *** pargv)
{
  int old_argc;
  int new_argc;
  char ** old_argv;
  char ** new_argv;
  /* Starting the short option string with '-' is for programs that
     expect options and other ARGV-elements in any order and that care about
     the ordering of the two.  We describe each non-option ARGV-element
     as if it were the argument of an option with character code 1.  */
  char *shortopts;
  extern const char *md_shortopts;
  static const char std_shortopts[] =
  {
    '-', 'J',
#ifndef WORKING_DOT_WORD
    /* -K is not meaningful if .word is not being hacked.  */
    'K',
#endif
    'L', 'M', 'R', 'W', 'Z', 'a', ':', ':', 'D', 'f', 'I', ':', 'o', ':',
#ifndef VMS
    /* -v takes an argument on VMS, so we don't make it a generic
       option.  */
    'v',
#endif
    'w', 'X',
    /* New option for extending instruction set (see also --itbl below).  */
    't', ':',
    '\0'
  };
  struct option *longopts;
  extern struct option md_longopts[];
  extern size_t md_longopts_size;
  /* Codes used for the long options with no short synonyms.  */
  enum option_values
    {
      OPTION_HELP = OPTION_STD_BASE,
      OPTION_NOCPP,
      OPTION_STATISTICS,
      OPTION_VERSION,
      OPTION_DUMPCONFIG,
      OPTION_VERBOSE,
      OPTION_EMULATION,
      OPTION_DEFSYM,
      OPTION_INSTTBL,
      OPTION_LISTING_LHS_WIDTH,
      OPTION_LISTING_LHS_WIDTH2,
      OPTION_LISTING_RHS_WIDTH,
      OPTION_LISTING_CONT_LINES,
      OPTION_DEPFILE,
      OPTION_GSTABS,
      OPTION_GSTABS_PLUS,
      OPTION_STRIP_LOCAL_ABSOLUTE,
      OPTION_TRADITIONAL_FORMAT,
      OPTION_GDWARF2,
      OPTION_WARN,
      OPTION_TARGET_HELP,
      OPTION_EXECSTACK,
      OPTION_NOEXECSTACK,
      OPTION_WARN_FATAL
    };
  
  static const struct option std_longopts[] =
  {
    {"help", no_argument, NULL, OPTION_HELP},
    /* getopt allows abbreviations, so we do this to stop it from
       treating -k as an abbreviation for --keep-locals.  Some
       ports use -k to enable PIC assembly.  */
    {"keep-locals", no_argument, NULL, 'L'},
    {"keep-locals", no_argument, NULL, 'L'},
    {"mri", no_argument, NULL, 'M'},
    {"nocpp", no_argument, NULL, OPTION_NOCPP},
    {"statistics", no_argument, NULL, OPTION_STATISTICS},
    {"version", no_argument, NULL, OPTION_VERSION},
    {"dump-config", no_argument, NULL, OPTION_DUMPCONFIG},
    {"verbose", no_argument, NULL, OPTION_VERBOSE},
    {"emulation", required_argument, NULL, OPTION_EMULATION},
    {"defsym", required_argument, NULL, OPTION_DEFSYM},
    /* New option for extending instruction set (see also -t above).
       The "-t file" or "--itbl file" option extends the basic set of
       valid instructions by reading "file", a text file containing a
       list of instruction formats.  The additional opcodes and their
       formats are added to the built-in set of instructions, and
       mnemonics for new registers may also be defined.  */
    {"itbl", required_argument, NULL, OPTION_INSTTBL},
    {"listing-lhs-width", required_argument, NULL, OPTION_LISTING_LHS_WIDTH},
    {"listing-lhs-width2", required_argument, NULL, OPTION_LISTING_LHS_WIDTH2},
    {"listing-rhs-width", required_argument, NULL, OPTION_LISTING_RHS_WIDTH},
    {"listing-cont-lines", required_argument, NULL, OPTION_LISTING_CONT_LINES},
    {"MD", required_argument, NULL, OPTION_DEPFILE},
    {"gstabs", no_argument, NULL, OPTION_GSTABS},
    {"gstabs+", no_argument, NULL, OPTION_GSTABS_PLUS},
    {"strip-local-absolute", no_argument, NULL, OPTION_STRIP_LOCAL_ABSOLUTE},
    {"traditional-format", no_argument, NULL, OPTION_TRADITIONAL_FORMAT},
    {"gdwarf2", no_argument, NULL, OPTION_GDWARF2},
    {"no-warn", no_argument, NULL, 'W'},
    {"warn", no_argument, NULL, OPTION_WARN},
    {"target-help", no_argument, NULL, OPTION_TARGET_HELP},
#if defined BFD_ASSEMBLER && (defined OBJ_ELF || defined OBJ_MAYBE_ELF)
    {"execstack", no_argument, NULL, OPTION_EXECSTACK},
    {"noexecstack", no_argument, NULL, OPTION_NOEXECSTACK},
#endif
    {"fatal-warnings", no_argument, NULL, OPTION_WARN_FATAL}
    /* When you add options here, check that they do not collide with
       OPTION_MD_BASE.  See as.h.  */
  };

  /* Construct the option lists from the standard list and the target
     dependent list.  Include space for an extra NULL option and
     always NULL terminate.  */
  shortopts = concat (std_shortopts, md_shortopts, (char *) NULL);
  longopts = xmalloc (sizeof (std_longopts) + md_longopts_size + sizeof (struct option));
  memcpy (longopts, std_longopts, sizeof (std_longopts));
  memcpy (((char *) longopts) + sizeof (std_longopts), md_longopts, md_longopts_size);
  memset (((char *) longopts) + sizeof (std_longopts) + md_longopts_size,
	  0, sizeof (struct option));

  /* Make a local copy of the old argv.  */
  old_argc = *pargc;
  old_argv = *pargv;

  /* Initialize a new argv that contains no options.  */
  new_argv = xmalloc (sizeof (char *) * (old_argc + 1));
  new_argv[0] = old_argv[0];
  new_argc = 1;
  new_argv[new_argc] = NULL;

  while (1)
    {
      /* getopt_long_only is like getopt_long, but '-' as well as '--' can
	 indicate a long option.  */
      int longind;
      int optc = getopt_long_only (old_argc, old_argv, shortopts, longopts,
				   &longind);

      if (optc == -1)
	break;

      switch (optc)
	{
	default:
	  /* md_parse_option should return 1 if it recognizes optc,
	     0 if not.  */
	  if (md_parse_option (optc, optarg) != 0)
	    break;
	  /* `-v' isn't included in the general short_opts list, so check for
	     it explicitly here before deciding we've gotten a bad argument.  */
	  if (optc == 'v')
	    {
#ifdef VMS
	      /* Telling getopt to treat -v's value as optional can result
		 in it picking up a following filename argument here.  The
		 VMS code in md_parse_option can return 0 in that case,
		 but it has no way of pushing the filename argument back.  */
	      if (optarg && *optarg)
		new_argv[new_argc++] = optarg, new_argv[new_argc] = NULL;
	      else
#else
	      case 'v':
#endif
	      case OPTION_VERBOSE:
		print_version_id ();
		verbose = 1;
	      break;
	    }
	  /* Fall through.  */

	case '?':
	  exit (EXIT_FAILURE);

	case 1:			/* File name.  */
	  if (!strcmp (optarg, "-"))
	    optarg = "";
	  new_argv[new_argc++] = optarg;
	  new_argv[new_argc] = NULL;
	  break;

	case OPTION_TARGET_HELP:
	  md_show_usage (stdout);
	  exit (EXIT_SUCCESS);

	case OPTION_HELP:
	  show_usage (stdout);
	  exit (EXIT_SUCCESS);

	case OPTION_NOCPP:
	  break;

	case OPTION_STATISTICS:
	  flag_print_statistics = 1;
	  break;

	case OPTION_STRIP_LOCAL_ABSOLUTE:
	  flag_strip_local_absolute = 1;
	  break;

	case OPTION_TRADITIONAL_FORMAT:
	  flag_traditional_format = 1;
	  break;

	case OPTION_VERSION:
	  /* This output is intended to follow the GNU standards document.  */
#ifdef BFD_ASSEMBLER
	  printf (_("GNU assembler %s\n"), BFD_VERSION_STRING);
#else
	  printf (_("GNU assembler %s\n"), VERSION);
#endif
	  printf (_("Copyright 2002 Free Software Foundation, Inc.\n"));
	  printf (_("\
This program is free software; you may redistribute it under the terms of\n\
the GNU General Public License.  This program has absolutely no warranty.\n"));
	  printf (_("This assembler was configured for a target of `%s'.\n"),
		  TARGET_ALIAS);
	  exit (EXIT_SUCCESS);

	case OPTION_EMULATION:
#ifdef USE_EMULATIONS
	  if (strcmp (optarg, this_emulation->name))
	    as_fatal (_("multiple emulation names specified"));
#else
	  as_fatal (_("emulations not handled in this configuration"));
#endif
	  break;

	case OPTION_DUMPCONFIG:
	  fprintf (stderr, _("alias = %s\n"), TARGET_ALIAS);
	  fprintf (stderr, _("canonical = %s\n"), TARGET_CANONICAL);
	  fprintf (stderr, _("cpu-type = %s\n"), TARGET_CPU);
#ifdef TARGET_OBJ_FORMAT
	  fprintf (stderr, _("format = %s\n"), TARGET_OBJ_FORMAT);
#endif
#ifdef TARGET_FORMAT
	  fprintf (stderr, _("bfd-target = %s\n"), TARGET_FORMAT);
#endif
	  exit (EXIT_SUCCESS);

	case OPTION_DEFSYM:
	  {
	    char *s;
	    valueT i;
	    struct defsym_list *n;

	    for (s = optarg; *s != '\0' && *s != '='; s++)
	      ;
	    if (*s == '\0')
	      as_fatal (_("bad defsym; format is --defsym name=value"));
	    *s++ = '\0';
#ifdef BFD_ASSEMBLER
	    i = bfd_scan_vma (s, (const char **) NULL, 0);
#else
	    i = strtol (s, (char **) NULL, 0);
#endif
	    n = xmalloc (sizeof *n);
	    n->next = defsyms;
	    n->name = optarg;
	    n->value = i;
	    defsyms = n;
	  }
	  break;

	case OPTION_INSTTBL:
	case 't':
	  {
	    /* optarg is the name of the file containing the instruction
	       formats, opcodes, register names, etc.  */
	    struct itbl_file_list *n;

	    if (optarg == NULL)
	      {
		as_warn (_("no file name following -t option"));
		break;
	      }

	    n = xmalloc (sizeof * n);
	    n->next = itbl_files;
	    n->name = optarg;
	    itbl_files = n;

	    /* Parse the file and add the new instructions to our internal
	       table.  If multiple instruction tables are specified, the
	       information from this table gets appended onto the existing
	       internal table.  */
	    itbl_files->name = xstrdup (optarg);
	    if (itbl_parse (itbl_files->name) != 0)
	      as_fatal (_("failed to read instruction table %s\n"),
			itbl_files->name);
	  }
	  break;

	case OPTION_DEPFILE:
	  start_dependencies (optarg);
	  break;

	case OPTION_GSTABS_PLUS:
	  use_gnu_debug_info_extensions = 1;
	  /* Fall through.  */
	case OPTION_GSTABS:
	  debug_type = DEBUG_STABS;
	  break;

	case OPTION_GDWARF2:
	  debug_type = DEBUG_DWARF2;
	  break;

	case 'J':
	  flag_signed_overflow_ok = 1;
	  break;

#ifndef WORKING_DOT_WORD
	case 'K':
	  flag_warn_displacement = 1;
	  break;
#endif
	case 'L':
	  flag_keep_locals = 1;
	  break;

	case OPTION_LISTING_LHS_WIDTH:
	  listing_lhs_width = atoi (optarg);
	  if (listing_lhs_width_second < listing_lhs_width)
	    listing_lhs_width_second = listing_lhs_width;
	  break;
	case OPTION_LISTING_LHS_WIDTH2:
	  {
	    int tmp = atoi (optarg);
	    if (tmp > listing_lhs_width)
	      listing_lhs_width_second = tmp;
	  }
	  break;
	case OPTION_LISTING_RHS_WIDTH:
	  listing_rhs_width = atoi (optarg);
	  break;
	case OPTION_LISTING_CONT_LINES:
	  listing_lhs_cont_lines = atoi (optarg);
	  break;

	case 'M':
	  flag_mri = 1;
#ifdef TC_M68K
	  flag_m68k_mri = 1;
#endif
	  break;

	case 'R':
	  flag_readonly_data_in_text = 1;
	  break;

	case 'W':
	  flag_no_warnings = 1;
	  break;

	case OPTION_WARN:
	  flag_no_warnings = 0;
	  flag_fatal_warnings = 0;
	  break;

	case OPTION_WARN_FATAL:
	  flag_no_warnings = 0;
	  flag_fatal_warnings = 1;
	  break;

#if defined BFD_ASSEMBLER && (defined OBJ_ELF || defined OBJ_MAYBE_ELF)
	case OPTION_EXECSTACK:
	  flag_execstack = 1;
	  flag_noexecstack = 0;
	  break;

	case OPTION_NOEXECSTACK:
	  flag_noexecstack = 1;
	  flag_execstack = 0;
	  break;
#endif
	case 'Z':
	  flag_always_generate_output = 1;
	  break;

	case 'a':
	  if (optarg)
	    {
	      if (md_parse_option (optc, optarg) != 0)
		break;

	      while (*optarg)
		{
		  switch (*optarg)
		    {
		    case 'c':
		      listing |= LISTING_NOCOND;
		      break;
		    case 'd':
		      listing |= LISTING_NODEBUG;
		      break;
		    case 'h':
		      listing |= LISTING_HLL;
		      break;
		    case 'l':
		      listing |= LISTING_LISTING;
		      break;
		    case 'm':
		      listing |= LISTING_MACEXP;
		      break;
		    case 'n':
		      listing |= LISTING_NOFORM;
		      break;
		    case 's':
		      listing |= LISTING_SYMBOLS;
		      break;
		    case '=':
		      listing_filename = xstrdup (optarg + 1);
		      optarg += strlen (listing_filename);
		      break;
		    default:
		      as_fatal (_("invalid listing option `%c'"), *optarg);
		      break;
		    }
		  optarg++;
		}
	    }
	  if (!listing)
	    listing = LISTING_DEFAULT;
	  break;

	case 'D':
	  /* DEBUG is implemented: it debugs different
	     things from other people's assemblers.  */
	  flag_debug = 1;
	  break;

	case 'f':
	  flag_no_comments = 1;
	  break;

	case 'I':
	  {			/* Include file directory.  */
	    char *temp = xstrdup (optarg);
	    add_include_dir (temp);
	    break;
	  }

	case 'o':
	  out_file_name = xstrdup (optarg);
	  break;

	case 'w':
	  break;

	case 'X':
	  /* -X means treat warnings as errors.  */
	  break;
	}
    }

  free (shortopts);
  free (longopts);

  *pargc = new_argc;
  *pargv = new_argv;

#ifdef md_after_parse_args
  md_after_parse_args ();
#endif
}

static void
dump_statistics (void)
{
#ifdef HAVE_SBRK
  char *lim = (char *) sbrk (0);
#endif
  long run_time = get_run_time () - start_time;

  fprintf (stderr, _("%s: total time in assembly: %ld.%06ld\n"),
	   myname, run_time / 1000000, run_time % 1000000);
#ifdef HAVE_SBRK
  fprintf (stderr, _("%s: data size %ld\n"),
	   myname, (long) (lim - (char *) &environ));
#endif

  subsegs_print_statistics (stderr);
  write_print_statistics (stderr);
  symbol_print_statistics (stderr);
  read_print_statistics (stderr);

#ifdef tc_print_statistics
  tc_print_statistics (stderr);
#endif

#ifdef obj_print_statistics
  obj_print_statistics (stderr);
#endif
}

#ifndef OBJ_VMS
static void
close_output_file (void)
{
  output_file_close (out_file_name);
}
#endif

/* The interface between the macro code and gas expression handling.  */

static int
macro_expr (const char *emsg, int idx, sb *in, int *val)
{
  char *hold;
  expressionS ex;

  sb_terminate (in);

  hold = input_line_pointer;
  input_line_pointer = in->ptr + idx;
  expression (&ex);
  idx = input_line_pointer - in->ptr;
  input_line_pointer = hold;

  if (ex.X_op != O_constant)
    as_bad ("%s", emsg);

  *val = (int) ex.X_add_number;

  return idx;
}

/* Here to attempt 1 pass over each input file.
   We scan argv[*] looking for filenames or exactly "" which is
   shorthand for stdin. Any argv that is NULL is not a file-name.
   We set need_pass_2 TRUE if, after this, we still have unresolved
   expressions of the form (unknown value)+-(unknown value).

   Note the un*x semantics: there is only 1 logical input file, but it
   may be a catenation of many 'physical' input files.  */

static void
perform_an_assembly_pass (int argc, char ** argv)
{
  int saw_a_file = 0;
#ifdef BFD_ASSEMBLER
  flagword applicable;
#endif

  need_pass_2 = 0;

#ifndef BFD_ASSEMBLER
#ifdef MANY_SEGMENTS
  {
    unsigned int i;
    for (i = SEG_E0; i < SEG_UNKNOWN; i++)
      segment_info[i].fix_root = 0;
  }
  /* Create the three fixed ones.  */
  {
    segT seg;

#ifdef TE_APOLLO
    seg = subseg_new (".wtext", 0);
#else
    seg = subseg_new (".text", 0);
#endif
    assert (seg == SEG_E0);
    seg = subseg_new (".data", 0);
    assert (seg == SEG_E1);
    seg = subseg_new (".bss", 0);
    assert (seg == SEG_E2);
#ifdef TE_APOLLO
    create_target_segments ();
#endif
  }

#else /* not MANY_SEGMENTS.  */
  text_fix_root = NULL;
  data_fix_root = NULL;
  bss_fix_root = NULL;
#endif /* not MANY_SEGMENTS.  */
#else /* BFD_ASSEMBLER.  */
  /* Create the standard sections, and those the assembler uses
     internally.  */
  text_section = subseg_new (TEXT_SECTION_NAME, 0);
  data_section = subseg_new (DATA_SECTION_NAME, 0);
  bss_section = subseg_new (BSS_SECTION_NAME, 0);
  /* @@@@ FIXME -- we're setting the RELOC flag so that sections are assumed
     to have relocs, otherwise we don't find out in time.  */
  applicable = bfd_applicable_section_flags (stdoutput);
  bfd_set_section_flags (stdoutput, text_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_CODE | SEC_READONLY));
  bfd_set_section_flags (stdoutput, data_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_DATA));
  bfd_set_section_flags (stdoutput, bss_section, applicable & SEC_ALLOC);
  seg_info (bss_section)->bss = 1;
  subseg_new (BFD_ABS_SECTION_NAME, 0);
  subseg_new (BFD_UND_SECTION_NAME, 0);
  reg_section = subseg_new ("*GAS `reg' section*", 0);
  expr_section = subseg_new ("*GAS `expr' section*", 0);

#endif /* BFD_ASSEMBLER.  */

  subseg_set (text_section, 0);

  /* This may add symbol table entries, which requires having an open BFD,
     and sections already created, in BFD_ASSEMBLER mode.  */
  md_begin ();

#ifdef USING_CGEN
  gas_cgen_begin ();
#endif
#ifdef obj_begin
  obj_begin ();
#endif

  /* Skip argv[0].  */
  argv++;
  argc--;

  while (argc--)
    {
      if (*argv)
	{			/* Is it a file-name argument?  */
	  PROGRESS (1);
	  saw_a_file++;
	  /* argv->"" if stdin desired, else->filename.  */
	  read_a_source_file (*argv);
	}
      argv++;			/* Completed that argv.  */
    }
  if (!saw_a_file)
    read_a_source_file ("");
}


int
main (int argc, char ** argv)
{
  int macro_alternate;
  int macro_strip_at;
  int keep_it;

  start_time = get_run_time ();

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  if (debug_memory)
    chunksize = 64;

#ifdef HOST_SPECIAL_INIT
  HOST_SPECIAL_INIT (argc, argv);
#endif

  myname = argv[0];
  xmalloc_set_program_name (myname);

  expandargv (&argc, &argv);

  START_PROGRESS (myname, 0);

#ifndef OBJ_DEFAULT_OUTPUT_FILE_NAME
#define OBJ_DEFAULT_OUTPUT_FILE_NAME "a.out"
#endif

  out_file_name = OBJ_DEFAULT_OUTPUT_FILE_NAME;

  hex_init ();
#ifdef BFD_ASSEMBLER
  bfd_init ();
  bfd_set_error_program_name (myname);
#endif

#ifdef USE_EMULATIONS
  select_emulation_mode (argc, argv);
#endif

  PROGRESS (1);
  symbol_begin ();
  frag_init ();
  subsegs_begin ();
  parse_args (&argc, &argv);
  read_begin ();
  input_scrub_begin ();
  expr_begin ();

#ifndef OBJ_VMS /* Does its own file handling. */
  /* It has to be called after dump_statistics (). */
  xatexit (close_output_file);
#endif

  if (flag_print_statistics)
    xatexit (dump_statistics);

  macro_alternate = 0;
  macro_strip_at = 0;
#ifdef TC_I960
  macro_strip_at = flag_mri;
#endif
#ifdef TC_A29K
  /* For compatibility with the AMD 29K family macro assembler
     specification.  */
  macro_alternate = 1;
  macro_strip_at = 1;
#endif

  macro_init (macro_alternate, flag_mri, macro_strip_at, macro_expr);

  PROGRESS (1);

#ifdef BFD_ASSEMBLER
  output_file_create (out_file_name);
  assert (stdoutput != 0);
#endif

#ifdef tc_init_after_args
  tc_init_after_args ();
#endif

  itbl_init ();

  /* Now that we have fully initialized, and have created the output
     file, define any symbols requested by --defsym command line
     arguments.  */
  while (defsyms != NULL)
    {
      symbolS *sym;
      struct defsym_list *next;

      sym = symbol_new (defsyms->name, absolute_section, defsyms->value,
			&zero_address_frag);
      symbol_table_insert (sym);
      next = defsyms->next;
      free (defsyms);
      defsyms = next;
    }

  PROGRESS (1);

  /* Assemble it.  */
  perform_an_assembly_pass (argc, argv);

  cond_finish_check (-1);

#ifdef md_end
  md_end ();
#endif

#if defined BFD_ASSEMBLER && (defined OBJ_ELF || defined OBJ_MAYBE_ELF)
  if ((flag_execstack || flag_noexecstack)
      && OUTPUT_FLAVOR == bfd_target_elf_flavour)
    {
      segT gnustack;

      gnustack = subseg_new (".note.GNU-stack", 0);
      bfd_set_section_flags (stdoutput, gnustack,
			     SEC_READONLY | (flag_execstack ? SEC_CODE : 0));
                                                                             
    }
#endif

  /* If we've been collecting dwarf2 .debug_line info, either for
     assembly debugging or on behalf of the compiler, emit it now.  */
  dwarf2_finish ();

  /* If we constructed dwarf2 .eh_frame info, either via .cfi 
     directives from the user or by the backend, emit it now.  */
  cfi_finish ();

  if (seen_at_least_1_file ()
      && (flag_always_generate_output || had_errors () == 0))
    keep_it = 1;
  else
    keep_it = 0;

#if defined (BFD_ASSEMBLER) || !defined (BFD)
  /* This used to be done at the start of write_object_file in
     write.c, but that caused problems when doing listings when
     keep_it was zero.  This could probably be moved above md_end, but
     I didn't want to risk the change.  */
  subsegs_finish ();
#endif

  if (keep_it)
    write_object_file ();

#ifndef NO_LISTING
  listing_print (listing_filename);
#endif

  if (flag_fatal_warnings && had_warnings () > 0 && had_errors () == 0)
    as_bad (_("%d warnings, treating warnings as errors"), had_warnings ());

  if (had_errors () > 0 && ! flag_always_generate_output)
    keep_it = 0;

  if (!keep_it)
    unlink (out_file_name);

  input_scrub_end ();

  END_PROGRESS (myname);

  /* Use xexit instead of return, because under VMS environments they
     may not place the same interpretation on the value given.  */
  if (had_errors () > 0)
    xexit (EXIT_FAILURE);

  /* Only generate dependency file if assembler was successful.  */
  print_dependencies ();

  xexit (EXIT_SUCCESS);
}

@


1.11
log
@fix a crash with --statistics.  closing file in the wrong place.
from dasn.  ok deraadt
@
text
@d1017 2
@


1.10
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d850 8
d1044 5
a1145 7
#endif

#ifndef OBJ_VMS /* Does its own file handling.  */
#ifndef BFD_ASSEMBLER
  if (keep_it)
#endif
    output_file_close (out_file_name);
@


1.9
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d24 9
a32 10
 * Understands command arguments.
 * Has a few routines that don't fit in other modules because they
 * are shared.
 *
 *			bugs
 *
 * : initialisers
 *	Since no-one else says they will support them in future: I
 * don't support them now.
 */
d44 1
a62 5
static void show_usage PARAMS ((FILE *));
static void parse_args PARAMS ((int *, char ***));
static void dump_statistics PARAMS ((void));
static void perform_an_assembly_pass PARAMS ((int argc, char **argv));
static int macro_expr PARAMS ((const char *, int, sb *, int *));
d65 1
a65 1
extern void gas_cgen_begin PARAMS ((void));
d68 17
a87 3
/* Name of listing file.  */
static char *listing_filename = NULL;

a88 1

d90 1
d96 1
a96 5
char *myname;
#ifdef BFD_ASSEMBLER
segT reg_section, expr_section;
segT text_section, data_section, bss_section;
#endif
d106 10
a115 2
/* We build a list of defsyms as we read the options, and then define
   them after we have initialized everything.  */
d117 2
a118 5
struct defsym_list {
  struct defsym_list *next;
  char *name;
  valueT value;
};
d122 1
a122 1
/* Keep a record of the itbl files we read in.  */
d124 1
a124 4
struct itbl_file_list {
  struct itbl_file_list *next;
  char *name;
};
a125 1
static struct itbl_file_list *itbl_files;
a137 2
static void select_emulation_mode PARAMS ((int, char **));

d139 1
a139 3
select_emulation_mode (argc, argv)
     int argc;
     char **argv;
d183 1
a183 1
default_emul_bfd_name ()
d190 1
a190 1
common_emul_init ()
d212 1
a212 1
print_version_id ()
d215 1
d230 1
a230 2
show_usage (stream)
     FILE *stream;
d269 6
d280 2
d358 1
a358 3
parse_args (pargc, pargv)
     int *pargc;
     char ***pargv;
d360 4
a363 3
  int old_argc, new_argc;
  char **old_argv, **new_argv;

a367 1

d370 2
a371 1
  static const char std_shortopts[] = {
d377 1
a377 1
    'L', 'M', 'R', 'W', 'Z', 'f', 'a', ':', ':', 'D', 'I', ':', 'o', ':',
d384 1
a384 1
    /* New option for extending instruction set (see also --itbl below)  */
d391 31
a421 2
  static const struct option std_longopts[] = {
#define OPTION_HELP (OPTION_STD_BASE)
a428 1
#define OPTION_NOCPP (OPTION_STD_BASE + 1)
a429 1
#define OPTION_STATISTICS (OPTION_STD_BASE + 2)
a430 1
#define OPTION_VERSION (OPTION_STD_BASE + 3)
a431 1
#define OPTION_DUMPCONFIG (OPTION_STD_BASE + 4)
a432 1
#define OPTION_VERBOSE (OPTION_STD_BASE + 5)
a433 1
#define OPTION_EMULATION (OPTION_STD_BASE + 6)
a434 1
#define OPTION_DEFSYM (OPTION_STD_BASE + 7)
a435 1
#define OPTION_INSTTBL (OPTION_STD_BASE + 8)
a442 1
#define OPTION_LISTING_LHS_WIDTH (OPTION_STD_BASE + 9)
a443 1
#define OPTION_LISTING_LHS_WIDTH2 (OPTION_STD_BASE + 10)
a444 1
#define OPTION_LISTING_RHS_WIDTH (OPTION_STD_BASE + 11)
a445 1
#define OPTION_LISTING_CONT_LINES (OPTION_STD_BASE + 12)
a446 1
#define OPTION_DEPFILE (OPTION_STD_BASE + 13)
a447 1
#define OPTION_GSTABS (OPTION_STD_BASE + 14)
d449 1
a449 1
#define OPTION_STRIP_LOCAL_ABSOLUTE (OPTION_STD_BASE + 15)
a450 1
#define OPTION_TRADITIONAL_FORMAT (OPTION_STD_BASE + 16)
a451 1
#define OPTION_GDWARF2 (OPTION_STD_BASE + 17)
a453 1
#define OPTION_WARN (OPTION_STD_BASE + 18)
a454 1
#define OPTION_TARGET_HELP (OPTION_STD_BASE + 19)
d456 4
a459 1
#define OPTION_WARN_FATAL (OPTION_STD_BASE + 20)
d469 1
a469 3
  longopts = (struct option *) xmalloc (sizeof (std_longopts)
					+ md_longopts_size
					+ sizeof (struct option));
d471 2
a472 3
  memcpy ((char *) longopts + sizeof (std_longopts),
	  md_longopts, md_longopts_size);
  memset ((char *) longopts + sizeof (std_longopts) + md_longopts_size,
d480 1
a480 1
  new_argv = (char **) xmalloc (sizeof (char *) * (old_argc + 1));
d504 1
a504 1
	     it explicity here before deciding we've gotten a bad argument.  */
d520 1
d610 1
a610 1
	    n = (struct defsym_list *) xmalloc (sizeof *n);
d631 1
a631 1
	    n = (struct itbl_file_list *) xmalloc (sizeof *n);
d651 3
a670 1

d719 11
d821 139
a959 1
static long start_time;
d961 19
a979 1
int main PARAMS ((int, char **));
d982 1
a982 3
main (argc, argv)
     int argc;
     char **argv;
d1093 13
d1110 4
d1135 1
a1135 1
#ifndef OBJ_VMS /* does its own file handling */
a1165 163
static void
dump_statistics ()
{
#ifdef HAVE_SBRK
  char *lim = (char *) sbrk (0);
#endif
  long run_time = get_run_time () - start_time;

  fprintf (stderr, _("%s: total time in assembly: %ld.%06ld\n"),
	   myname, run_time / 1000000, run_time % 1000000);
#ifdef HAVE_SBRK
  fprintf (stderr, _("%s: data size %ld\n"),
	   myname, (long) (lim - (char *) &environ));
#endif

  subsegs_print_statistics (stderr);
  write_print_statistics (stderr);
  symbol_print_statistics (stderr);
  read_print_statistics (stderr);

#ifdef tc_print_statistics
  tc_print_statistics (stderr);
#endif
#ifdef obj_print_statistics
  obj_print_statistics (stderr);
#endif
}

/* Here to attempt 1 pass over each input file.
   We scan argv[*] looking for filenames or exactly "" which is
   shorthand for stdin. Any argv that is NULL is not a file-name.
   We set need_pass_2 TRUE if, after this, we still have unresolved
   expressions of the form (unknown value)+-(unknown value).

   Note the un*x semantics: there is only 1 logical input file, but it
   may be a catenation of many 'physical' input files.  */

static void
perform_an_assembly_pass (argc, argv)
     int argc;
     char **argv;
{
  int saw_a_file = 0;
#ifdef BFD_ASSEMBLER
  flagword applicable;
#endif

  need_pass_2 = 0;

#ifndef BFD_ASSEMBLER
#ifdef MANY_SEGMENTS
  {
    unsigned int i;
    for (i = SEG_E0; i < SEG_UNKNOWN; i++)
      segment_info[i].fix_root = 0;
  }
  /* Create the three fixed ones.  */
  {
    segT seg;

#ifdef TE_APOLLO
    seg = subseg_new (".wtext", 0);
#else
    seg = subseg_new (".text", 0);
#endif
    assert (seg == SEG_E0);
    seg = subseg_new (".data", 0);
    assert (seg == SEG_E1);
    seg = subseg_new (".bss", 0);
    assert (seg == SEG_E2);
#ifdef TE_APOLLO
    create_target_segments ();
#endif
  }

#else /* not MANY_SEGMENTS */
  text_fix_root = NULL;
  data_fix_root = NULL;
  bss_fix_root = NULL;
#endif /* not MANY_SEGMENTS */
#else /* BFD_ASSEMBLER */
  /* Create the standard sections, and those the assembler uses
     internally.  */
  text_section = subseg_new (TEXT_SECTION_NAME, 0);
  data_section = subseg_new (DATA_SECTION_NAME, 0);
  bss_section = subseg_new (BSS_SECTION_NAME, 0);
  /* @@@@ FIXME -- we're setting the RELOC flag so that sections are assumed
     to have relocs, otherwise we don't find out in time.  */
  applicable = bfd_applicable_section_flags (stdoutput);
  bfd_set_section_flags (stdoutput, text_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_CODE | SEC_READONLY));
  bfd_set_section_flags (stdoutput, data_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_DATA));
  bfd_set_section_flags (stdoutput, bss_section, applicable & SEC_ALLOC);
  seg_info (bss_section)->bss = 1;
  subseg_new (BFD_ABS_SECTION_NAME, 0);
  subseg_new (BFD_UND_SECTION_NAME, 0);
  reg_section = subseg_new ("*GAS `reg' section*", 0);
  expr_section = subseg_new ("*GAS `expr' section*", 0);

#endif /* BFD_ASSEMBLER */

  subseg_set (text_section, 0);

  /* This may add symbol table entries, which requires having an open BFD,
     and sections already created, in BFD_ASSEMBLER mode.  */
  md_begin ();

#ifdef USING_CGEN
  gas_cgen_begin ();
#endif
#ifdef obj_begin
  obj_begin ();
#endif

  /* Skip argv[0].  */
  argv++;
  argc--;

  while (argc--)
    {
      if (*argv)
	{			/* Is it a file-name argument?  */
	  PROGRESS (1);
	  saw_a_file++;
	  /* argv->"" if stdin desired, else->filename  */
	  read_a_source_file (*argv);
	}
      argv++;			/* completed that argv  */
    }
  if (!saw_a_file)
    read_a_source_file ("");
}

/* The interface between the macro code and gas expression handling.  */

static int
macro_expr (emsg, idx, in, val)
     const char *emsg;
     int idx;
     sb *in;
     int *val;
{
  char *hold;
  expressionS ex;

  sb_terminate (in);

  hold = input_line_pointer;
  input_line_pointer = in->ptr + idx;
  expression (&ex);
  idx = input_line_pointer - in->ptr;
  input_line_pointer = hold;

  if (ex.X_op != O_constant)
    as_bad ("%s", emsg);

  *val = (int) ex.X_add_number;

  return idx;
}
@


1.8
log
@Add a second keep-locals entry to stop getopt from treating -k as an
abbreviation for --keep-locals. from binutils-current.
millert@@ ok.
@
text
@d3 1
a3 1
   1999, 2000, 2001
d46 4
d68 4
d219 1
a219 1
	   VERSION, TARGET_ALIAS, BFD_VERSION);
d361 1
a361 1
  extern CONST char *md_shortopts;
d515 2
a516 2
          md_show_usage (stdout);
          exit (EXIT_SUCCESS);
d539 3
d543 2
a544 1
	  printf (_("Copyright 2001 Free Software Foundation, Inc.\n"));
d606 1
a606 1
		as_warn (_("No file name following -t option\n"));
d621 2
a622 5
	      {
		fprintf (stderr, _("Failed to read instruction table %s\n"),
			 itbl_files->name);
		exit (EXIT_SUCCESS);
	      }
d781 4
d789 2
d805 3
d812 1
a812 7
    {
#ifdef BFD_ASSEMBLER
      extern long _bfd_chunksize;
      _bfd_chunksize = 64;
#endif
      chunksize = 64;
    }
d1071 3
@


1.7
log
@resolve conflicts.
@
text
@d377 4
@


1.6
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d21 1
a21 1
   02111-1307, USA. */
d23 1
a23 2
/*
 * Main program for AS; a 32-bit assembler of GNU.
a27 1
 *
a32 1
 *
d44 1
d65 2
a66 1
int listing;			/* true if a listing is wanted */
d68 2
a69 1
static char *listing_filename = NULL;	/* Name of listing file.  */
d73 1
a73 1
enum debug_info_type debug_type = DEBUG_NONE;
a75 1

d78 2
a79 1
char *myname;			/* argv[0] */
d96 1
a96 2
struct defsym_list
{
d104 1
a104 1
/* Keep a record of the itbl files we read in. */
d106 1
a106 2
struct itbl_file_list
{
d119 1
d145 1
a145 1
    p = argv[i+1];
a234 1
                      	  L      include line debug statistics (if applicable)\n\
d248 1
a248 1
    for (i = 0; i < n_emulations-1; i++)
d253 1
a253 1
    if (!def_em) 
d268 2
d330 8
a337 10
/*
 * Since it is easy to do here we interpret the special arg "-"
 * to mean "use stdin" and we set that argv[] pointing to "".
 * After we have munged argv[], the only things left are source file
 * name(s) and ""(s) denoting stdin. These file names are used
 * (perhaps more than once) later.
 *
 * check for new machine-dep cmdline options in
 * md_parse_option definitions in config/tc-*.c
 */
d354 2
a355 3
  static const char std_shortopts[] =
    {
      '-', 'J',
d357 2
a358 2
      /* -K is not meaningful if .word is not being hacked.  */
      'K',
d360 1
a360 1
      'L', 'M', 'R', 'W', 'Z', 'f', 'a', ':', ':', 'D', 'I', ':', 'o', ':',
d362 9
a370 9
      /* -v takes an argument on VMS, so we don't make it a generic
         option.  */
      'v',
#endif
      'w', 'X',
      /* New option for extending instruction set (see also --itbl below) */
      't', ':',
      '\0'
    };
d404 1
a404 1
    {"listing-lhs-width", required_argument, NULL, OPTION_LISTING_LHS_WIDTH2},
d422 3
a424 1
#define OPTION_WARN_FATAL (OPTION_STD_BASE + 19)
d426 2
d430 3
a432 2
  /* Construct the option lists from the standard list and the
     target dependent list.  */
d434 3
a436 1
  longopts = (struct option *) xmalloc (sizeof (std_longopts) + md_longopts_size);
d440 2
d481 1
a481 1
		new_argv[new_argc++] = optarg,  new_argv[new_argc] = NULL;
d490 1
a490 1
	  /*FALLTHRU*/
d502 4
d528 1
a528 1
	  printf (_("Copyright 2000 Free Software Foundation, Inc.\n"));
d560 1
a560 1
	    long i;
d568 3
d572 1
d584 2
a585 2
	    /* optarg is the name of the file containing the instruction 
	       formats, opcodes, register names, etc. */
d590 1
a590 1
		as_warn ( _("No file name following -t option\n") );
d593 1
a593 1
	    
d600 3
a602 3
	       table.  If multiple instruction tables are specified, the 
	       information from this table gets appended onto the existing 
	       internal table. */
d606 1
a606 1
		fprintf (stderr, _("Failed to read instruction table %s\n"), 
d620 1
a620 1
 
d640 1
a640 1
	  listing_lhs_width = atoi(optarg);
d646 1
a646 1
	    int tmp = atoi(optarg);
d652 1
a652 1
	  listing_rhs_width = atoi(optarg);
d655 1
a655 1
	  listing_lhs_cont_lines = atoi(optarg);
d690 3
d734 2
a735 2
	  /* DEBUG is implemented: it debugs different */
	  /* things from other people's assemblers. */
d744 1
a744 1
	  {			/* Include file directory */
d758 1
a758 1
	  /* -X means treat warnings as errors */
d772 1
a772 1
int 
d827 1
a827 1
  parse_args (&argc, &argv); 
d880 2
a881 1
  perform_an_assembly_pass (argc, argv);	/* Assemble it. */
d889 4
d921 2
a922 2
  if (flag_fatal_warnings && had_warnings() > 0 && had_errors () == 0)
    as_bad (_("%d warnings, treating warnings as errors"), had_warnings());
d973 8
d982 1
a982 12
/*			perform_an_assembly_pass()
 *
 * Here to attempt 1 pass over each input file.
 * We scan argv[*] looking for filenames or exactly "" which is
 * shorthand for stdin. Any argv that is NULL is not a file-name.
 * We set need_pass_2 TRUE if, after this, we still have unresolved
 * expressions of the form (unknown value)+-(unknown value).
 *
 * Note the un*x semantics: there is only 1 logical input file, but it
 * may be a catenation of many 'physical' input files.
 */
static void 
d1001 1
a1001 1
  /* Create the three fixed ones */
d1032 1
a1032 1
     to have relocs, otherwise we don't find out in time. */
d1059 4
a1062 2
  argv++;			/* skip argv[0] */
  argc--;			/* skip argv[0] */
d1066 1
a1066 1
	{			/* Is it a file-name argument? */
d1069 1
a1069 1
	  /* argv->"" if stdin desired, else->filename */
d1072 1
a1072 1
      argv++;			/* completed that argv */
d1076 1
a1076 1
}				/* perform_an_assembly_pass() */
a1104 2

/* end of as.c */
@


1.5
log
@Clone NetBSD config for us, add handling of temporary local labels
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996
d47 7
d60 3
d70 4
d84 3
a86 1
int chunksize = 5000;
a102 8

void
print_version_id ()
{
  static int printed;
  if (printed)
    return;
  printed = 1;
d104 1
a104 6
  fprintf (stderr, "GNU assembler version %s (%s)", GAS_VERSION, TARGET_ALIAS);
#ifdef BFD_ASSEMBLER
  fprintf (stderr, ", using BFD version %s", BFD_VERSION);
#endif
  fprintf (stderr, "\n");
}
d106 1
a106 3
void
show_usage (stream)
     FILE *stream;
d108 3
a110 37
  fprintf (stream, "Usage: %s [option...] [asmfile...]\n", myname);

  fprintf (stream, "\
Options:\n\
-a[sub-option...]	turn on listings\n\
  Sub-options [default hls]:\n\
  d	omit debugging directives\n\
  h	include high-level source\n\
  l	include assembly\n\
  n	omit forms processing\n\
  s	include symbols\n\
  =file set listing file name (must be last sub-option)\n");
  fprintf (stream, "\
-D			produce assembler debugging messages\n\
--defsym SYM=VAL	define symbol SYM to given value\n\
-f			skip whitespace and comment preprocessing\n\
--help			show this message and exit\n\
-I DIR			add DIR to search list for .include directives\n\
-J			don't warn about signed overflow\n\
-K			warn when differences altered for long displacements\n\
-L			keep local symbols (starting with `L')\n");
  fprintf (stream, "\
-M,--mri		assemble in MRI compatibility mode\n\
-nocpp			ignored\n\
-o OBJFILE		name the object-file output OBJFILE (default a.out)\n\
-R			fold data section into text section\n\
--statistics		print various measured statistics from execution\n\
--version		print assembler version number and exit\n\
-W			suppress warnings\n\
-w			ignored\n\
-X			ignored\n\
-Z			generate object file even after errors\n");

  md_show_usage (stream);

  fprintf (stream, "\nReport bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
}
d112 2
d119 1
d124 2
d148 1
a148 1
    as_fatal ("missing emulation mode name");
d163 1
a163 1
	as_fatal ("unrecognized emulation name `%s'", em);
d201 128
d340 1
a340 1
void
d369 2
d379 1
d394 32
a425 1
    {"defsym", required_argument, NULL, OPTION_DEFSYM}
d506 8
d516 3
a518 3
	  printf ("GNU assembler %s\n", GAS_VERSION);
	  printf ("Copyright 1996 Free Software Foundation, Inc.\n");
	  printf ("\
d520 2
a521 2
the GNU General Public License.  This program has absolutely no warranty.\n");
	  printf ("This assembler was configured for a target of `%s'.\n",
d528 1
a528 1
	    as_fatal ("multiple emulation names specified");
d530 1
a530 1
	  as_fatal ("emulations not handled in this configuration");
d535 3
a537 3
	  fprintf (stderr, "alias = %s\n", TARGET_ALIAS);
	  fprintf (stderr, "canonical = %s\n", TARGET_CANONICAL);
	  fprintf (stderr, "cpu-type = %s\n", TARGET_CPU);
d539 1
a539 1
	  fprintf (stderr, "format = %s\n", TARGET_OBJ_FORMAT);
d542 1
a542 1
	  fprintf (stderr, "bfd-target = %s\n", TARGET_FORMAT);
d555 1
a555 1
	      as_fatal ("bad defsym; format is --defsym name=value");
d566 44
d624 19
d658 10
d679 3
d691 3
d705 1
a705 1
		      as_fatal ("invalid listing option `%c'", *optarg);
a741 7

#if defined (TE_NetBSD) || defined (TE_OpenBSD)
	case 'k':
	  flag_pic = 1;
	  break;
#endif

a751 1
static void dump_statistics ();
d765 6
d809 1
a809 1
  parse_args (&argc, &argv);
d842 2
d864 2
d871 1
a871 2
      && !((had_warnings () && flag_always_generate_output)
	   || had_errors () > 0))
d876 8
d898 6
d913 1
a913 2
  if ((had_warnings () && flag_always_generate_output)
      || had_errors () > 0)
d915 4
a924 1
  extern char **environ;
d930 1
a930 1
  fprintf (stderr, "%s: total time in assembly: %ld.%06ld\n",
d933 1
a933 1
  fprintf (stderr, "%s: data size %ld\n",
d1008 3
a1010 3
  text_section = subseg_new (".text", 0);
  data_section = subseg_new (".data", 0);
  bss_section = subseg_new (".bss", 0);
a1016 1
  /* @@@@ FIXME -- SEC_CODE seems to mean code only, rather than code possibly.*/
d1018 2
a1019 1
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC));
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d522 1
a522 1
#ifdef TE_NetBSD
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@a37 1
#include "libiberty.h"
d141 2
d373 8
a380 1
	  print_version_id ();
d521 7
d796 4
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d48 6
d77 11
a149 1
static const char *emulation_name;
d203 1
d400 1
a400 1
	    symbolS *sym;
d408 5
a412 3
	    sym = symbol_new (optarg, absolute_section, (valueT) i,
			      &zero_address_frag);
	    symbol_table_insert (sym);
d607 16
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1987, 1990, 1991, 1992, 1994 Free Software Foundation, Inc.
d116 1
a116 1
--statistics		print maximum bytes and total seconds used\n\
d412 3
d452 1
a452 3
		      listing_filename = strdup (optarg + 1);
		      if (listing_filename == NULL)
			as_fatal ("virtual memory exhausted");
d478 1
a478 3
	    char *temp = strdup (optarg);
	    if (!temp)
	      as_fatal ("virtual memory exhausted");
d484 1
a484 3
	  out_file_name = strdup (optarg);
	  if (!out_file_name)
	    as_fatal ("virtual memory exhausted");
d503 3
d514 2
a515 1
  long start_time = get_run_time ();
d544 1
d555 1
a556 1
  parse_args (&argc, &argv);
d560 3
d624 12
a635 3
  if (flag_print_statistics)
    {
      extern char **environ;
d637 1
a637 1
      char *lim = (char *) sbrk (0);
d639 1
a639 1
      long run_time = get_run_time () - start_time;
d641 2
a642 2
      fprintf (stderr, "%s: total time in assembly: %ld.%06ld\n",
	       myname, run_time / 1000000, run_time % 1000000);
d644 2
a645 2
      fprintf (stderr, "%s: data size %ld\n",
	       myname, (long) (lim - (char *) &environ));
a646 1
    }
d648 11
a658 6
  /* Use exit instead of return, because under VMS environments they
     may not place the same interpretation on the value given.  */
  if ((had_warnings () && flag_always_generate_output)
      || had_errors () > 0)
    exit (EXIT_FAILURE);
  exit (EXIT_SUCCESS);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 2
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996
   Free Software Foundation, Inc.
d115 1
a115 1
--statistics		print various measured statistics from execution\n\
a410 3
#ifdef TC_M68K
	  flag_m68k_mri = 1;
#endif
d448 3
a450 1
		      listing_filename = xstrdup (optarg + 1);
d476 3
a478 1
	    char *temp = xstrdup (optarg);
d484 3
a486 1
	  out_file_name = xstrdup (optarg);
a504 3
static void dump_statistics ();
static long start_time;

d513 1
a513 2

  start_time = get_run_time ();
a541 1
  bfd_set_error_program_name (myname);
d552 1
a553 1
  read_begin ();
a556 3
  if (flag_print_statistics)
    xatexit (dump_statistics);

d618 3
a620 12
  /* Use xexit instead of return, because under VMS environments they
     may not place the same interpretation on the value given.  */
  if ((had_warnings () && flag_always_generate_output)
      || had_errors () > 0)
    xexit (EXIT_FAILURE);
  xexit (EXIT_SUCCESS);
}

static void
dump_statistics ()
{
  extern char **environ;
d622 1
a622 1
  char *lim = (char *) sbrk (0);
d624 1
a624 1
  long run_time = get_run_time () - start_time;
d626 2
a627 2
  fprintf (stderr, "%s: total time in assembly: %ld.%06ld\n",
	   myname, run_time / 1000000, run_time % 1000000);
d629 2
a630 2
  fprintf (stderr, "%s: data size %ld\n",
	   myname, (long) (lim - (char *) &environ));
d632 1
d634 6
a639 11
  subsegs_print_statistics (stderr);
  write_print_statistics (stderr);
  symbol_print_statistics (stderr);
  read_print_statistics (stderr);

#ifdef tc_print_statistics
  tc_print_statistics (stderr);
#endif
#ifdef obj_print_statistics
  obj_print_statistics (stderr);
#endif
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d18 2
a19 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA. */
a46 6
#ifdef HAVE_SBRK
#ifdef NEED_DECLARATION_SBRK
extern PTR sbrk ();
#endif
#endif

a69 11
/* We build a list of defsyms as we read the options, and then define
   them after we have initialized everything.  */

struct defsym_list
{
  struct defsym_list *next;
  char *name;
  valueT value;
};

static struct defsym_list *defsyms;
d132 1
a185 1
  return NULL;
d382 1
a382 1
	    struct defsym_list *n;
d390 3
a392 5
	    n = (struct defsym_list *) xmalloc (sizeof *n);
	    n->next = defsyms;
	    n->name = optarg;
	    n->value = i;
	    defsyms = n;
a586 16

  /* Now that we have fully initialized, and have created the output
     file, define any symbols requested by --defsym command line
     arguments.  */
  while (defsyms != NULL)
    {
      symbolS *sym;
      struct defsym_list *next;

      sym = symbol_new (defsyms->name, absolute_section, defsyms->value,
			&zero_address_frag);
      symbol_table_insert (sym);
      next = defsyms->next;
      free (defsyms);
      defsyms = next;
    }
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d38 1
a141 2

  fprintf (stream, "\nReport bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d372 1
a372 8
	  /* This output is intended to follow the GNU standards document.  */
	  printf ("GNU assembler %s\n", GAS_VERSION);
	  printf ("Copyright 1996 Free Software Foundation, Inc.\n");
	  printf ("\
This program is free software; you may redistribute it under the terms of\n\
the GNU General Public License.  This program has absolutely no warranty.\n");
	  printf ("This assembler was configured for a target of `%s'.\n",
		  TARGET_ALIAS);
a780 4

#ifdef obj_begin
  obj_begin ();
#endif
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1997
a45 4
#ifndef HAVE_ITBL_CPU
#define itbl_parse(itbl_file) 1
#define itbl_init()
#endif
a52 3
static void show_usage PARAMS ((FILE *));
static void parse_args PARAMS ((int *, char ***));
static void dump_statistics PARAMS ((void));
a86 10

/* Keep a record of the itbl files we read in. */

struct itbl_file_list
{
  struct itbl_file_list *next;
  char *name;
};

static struct itbl_file_list *itbl_files;
d103 1
a103 1
static void
a112 1
  c	omit false conditionals\n\
a135 2
--itbl INSTTBL		extend instruction set to include instructions\n\
			matching the specifications defined in file INSTTBL\n\
a149 1
extern struct emulation i386coff, i386elf;
a153 2
static void select_emulation_mode PARAMS ((int, char **));

d240 1
a240 1
static void
a268 2
      /* New option for extending instruction set (see also --itbl below) */
      't',
d291 1
a291 9
    {"defsym", required_argument, NULL, OPTION_DEFSYM},
#define OPTION_INSTTBL (OPTION_STD_BASE + 8)
    /* New option for extending instruction set (see also -t above).
       The "-t file" or "--itbl file" option extends the basic set of
       valid instructions by reading "file", a text file containing a
       list of instruction formats.  The additional opcodes and their
       formats are added to the built-in set of instructions, and
       mnemonics for new registers may also be defined.  */
    {"itbl", required_argument, NULL, OPTION_INSTTBL}
d375 1
a375 1
	  printf ("Copyright 1997 Free Software Foundation, Inc.\n");
a423 26
	case OPTION_INSTTBL:
	case 't':
	  {
	    /* optarg is the name of the file containing the instruction 
	       formats, opcodes, register names, etc. */
	    struct itbl_file_list *n;

	    n = (struct itbl_file_list *) xmalloc (sizeof *n);
	    n->next = itbl_files;
	    n->name = optarg;
	    itbl_files = n;

	    /* Parse the file and add the new instructions to our internal
	       table.  If multiple instruction tables are specified, the 
	       information from this table gets appended onto the existing 
	       internal table. */
	    itbl_files->name = xstrdup (optarg);
	    if (itbl_parse (itbl_files->name) != 0)
	      {
		fprintf (stderr, "Failed to read instruction table %s\n", 
			 itbl_files->name);
		exit (EXIT_SUCCESS);
	      }
	  }
	  break;

a463 3
		    case 'c':
		      listing |= LISTING_NOCOND;
		      break;
d531 1
a544 1

d583 1
a583 1
  parse_args (&argc, &argv); 
a615 2
  itbl_init ();

a635 2
  cond_finish_check (-1);

d641 2
a642 1
      && (flag_always_generate_output || had_errors () == 0))
a660 3
  if (had_errors () > 0 && ! flag_always_generate_output)
    keep_it = 0;

d670 2
a671 1
  if (had_errors () > 0)
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d46 1
a46 4

#ifdef HAVE_ITBL_CPU
#include "itbl-ops.h"
#else
a66 4
/* Type of debugging to generate.  */

enum debug_info_type debug_type = DEBUG_NONE;

d77 1
a77 3
/* The default obstack chunk size.  If we set this to zero, the
   obstack code will use whatever will fit in a 4096 byte block.  */
int chunksize = 0;
d105 60
d170 1
a170 1
extern struct emulation i386coff, i386elf, i386aout;
d199 1
a199 1
    as_fatal (_("missing emulation mode name"));
d214 1
a214 1
	as_fatal (_("unrecognized emulation name `%s'"), em);
a251 128
void
print_version_id ()
{
  static int printed;
  if (printed)
    return;
  printed = 1;

#ifdef BFD_ASSEMBLER
  fprintf (stderr, _("GNU assembler version %s (%s) using BFD version %s"),
	   VERSION, TARGET_ALIAS, BFD_VERSION);
#else
  fprintf (stderr, _("GNU assembler version %s (%s)"), VERSION, TARGET_ALIAS);
#endif
  fprintf (stderr, "\n");
}

static void
show_usage (stream)
     FILE *stream;
{
  fprintf (stream, _("Usage: %s [option...] [asmfile...]\n"), myname);

  fprintf (stream, _("\
Options:\n\
  -a[sub-option...]	  turn on listings\n\
                      	  Sub-options [default hls]:\n\
                      	  c      omit false conditionals\n\
                      	  d      omit debugging directives\n\
                      	  h      include high-level source\n\
                      	  l      include assembly\n\
                      	  m      include macro expansions\n\
                      	  n      omit forms processing\n\
                      	  s      include symbols\n\
                      	  L      include line debug statistics (if applicable)\n\
                      	  =FILE  list to FILE (must be last sub-option)\n"));

  fprintf (stream, _("\
  -D                      produce assembler debugging messages\n"));
  fprintf (stream, _("\
  --defsym SYM=VAL        define symbol SYM to given value\n"));
#ifdef USE_EMULATIONS
  {
    int i;
    char *def_em;

    fprintf (stream, "\
  --em=[");
    for (i = 0; i < n_emulations-1; i++)
      fprintf (stream, "%s | ", emulations[i]->name);
    fprintf (stream, "%s]\n", emulations[i]->name);

    def_em = getenv (EMULATION_ENVIRON);
    if (!def_em) 
      def_em = DEFAULT_EMULATION;
    fprintf (stream, _("\
                          emulate output (default %s)\n"), def_em);
  }
#endif
  fprintf (stream, _("\
  -f                      skip whitespace and comment preprocessing\n"));
  fprintf (stream, _("\
  --gstabs                generate stabs debugging information\n"));
  fprintf (stream, _("\
  --gdwarf2               generate DWARF2 debugging information\n"));
  fprintf (stream, _("\
  --help                  show this message and exit\n"));
  fprintf (stream, _("\
  -I DIR                  add DIR to search list for .include directives\n"));
  fprintf (stream, _("\
  -J                      don't warn about signed overflow\n"));
  fprintf (stream, _("\
  -K                      warn when differences altered for long displacements\n"));
  fprintf (stream, _("\
  -L,--keep-locals        keep local symbols (e.g. starting with `L')\n"));
  fprintf (stream, _("\
  -M,--mri                assemble in MRI compatibility mode\n"));
  fprintf (stream, _("\
  --MD FILE               write dependency information in FILE (default none)\n"));
  fprintf (stream, _("\
  -nocpp                  ignored\n"));
  fprintf (stream, _("\
  -o OBJFILE              name the object-file output OBJFILE (default a.out)\n"));
  fprintf (stream, _("\
  -R                      fold data section into text section\n"));
  fprintf (stream, _("\
  --statistics            print various measured statistics from execution\n"));
  fprintf (stream, _("\
  --strip-local-absolute  strip local absolute symbols\n"));
  fprintf (stream, _("\
  --traditional-format    Use same format as native assembler when possible\n"));
  fprintf (stream, _("\
  --version               print assembler version number and exit\n"));
  fprintf (stream, _("\
  -W  --no-warn           suppress warnings\n"));
  fprintf (stream, _("\
  --warn                  don't suppress warnings\n"));
  fprintf (stream, _("\
  --fatal-warnings        treat warnings as errors\n"));
  fprintf (stream, _("\
  --itbl INSTTBL          extend instruction set to include instructions\n\
                          matching the specifications defined in file INSTTBL\n"));
  fprintf (stream, _("\
  -w                      ignored\n"));
  fprintf (stream, _("\
  -X                      ignored\n"));
  fprintf (stream, _("\
  -Z                      generate object file even after errors\n"));
  fprintf (stream, _("\
  --listing-lhs-width     set the width in words of the output data column of\n\
                          the listing\n"));
  fprintf (stream, _("\
  --listing-lhs-width2    set the width in words of the continuation lines\n\
                          of the output data column; ignored if smaller than\n\
                          the width of the first line\n"));
  fprintf (stream, _("\
  --listing-rhs-width     set the max width in characters of the lines from\n\
                          the source file\n"));
  fprintf (stream, _("\
  --listing-cont-lines    set the maximum number of continuation lines used\n\
                          for the output data column of the listing\n"));

  md_show_usage (stream);

  fputc ('\n', stream);
  fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
}

d293 1
a293 1
      't', ':',
a301 1
    {"keep-locals", no_argument, NULL, 'L'},
d324 1
a324 24
    {"itbl", required_argument, NULL, OPTION_INSTTBL},
#define OPTION_LISTING_LHS_WIDTH (OPTION_STD_BASE + 9)
    {"listing-lhs-width", required_argument, NULL, OPTION_LISTING_LHS_WIDTH},
#define OPTION_LISTING_LHS_WIDTH2 (OPTION_STD_BASE + 10)
    {"listing-lhs-width", required_argument, NULL, OPTION_LISTING_LHS_WIDTH2},
#define OPTION_LISTING_RHS_WIDTH (OPTION_STD_BASE + 11)
    {"listing-rhs-width", required_argument, NULL, OPTION_LISTING_RHS_WIDTH},
#define OPTION_LISTING_CONT_LINES (OPTION_STD_BASE + 12)
    {"listing-cont-lines", required_argument, NULL, OPTION_LISTING_CONT_LINES},
#define OPTION_DEPFILE (OPTION_STD_BASE + 13)
    {"MD", required_argument, NULL, OPTION_DEPFILE},
#define OPTION_GSTABS (OPTION_STD_BASE + 14)
    {"gstabs", no_argument, NULL, OPTION_GSTABS},
#define OPTION_STRIP_LOCAL_ABSOLUTE (OPTION_STD_BASE + 15)
    {"strip-local-absolute", no_argument, NULL, OPTION_STRIP_LOCAL_ABSOLUTE},
#define OPTION_TRADITIONAL_FORMAT (OPTION_STD_BASE + 16)
    {"traditional-format", no_argument, NULL, OPTION_TRADITIONAL_FORMAT},
#define OPTION_GDWARF2 (OPTION_STD_BASE + 17)
    {"gdwarf2", no_argument, NULL, OPTION_GDWARF2},
    {"no-warn", no_argument, NULL, 'W'},
#define OPTION_WARN (OPTION_STD_BASE + 18)
    {"warn", no_argument, NULL, OPTION_WARN},
#define OPTION_WARN_FATAL (OPTION_STD_BASE + 19)
    {"fatal-warnings", no_argument, NULL, OPTION_WARN_FATAL}
a404 8
	case OPTION_STRIP_LOCAL_ABSOLUTE:
	  flag_strip_local_absolute = 1;
	  break;

	case OPTION_TRADITIONAL_FORMAT:
	  flag_traditional_format = 1;
	  break;

d407 3
a409 3
	  printf (_("GNU assembler %s\n"), VERSION);
	  printf (_("Copyright 2000 Free Software Foundation, Inc.\n"));
	  printf (_("\
d411 2
a412 2
the GNU General Public License.  This program has absolutely no warranty.\n"));
	  printf (_("This assembler was configured for a target of `%s'.\n"),
d419 1
a419 1
	    as_fatal (_("multiple emulation names specified"));
d421 1
a421 1
	  as_fatal (_("emulations not handled in this configuration"));
d426 3
a428 3
	  fprintf (stderr, _("alias = %s\n"), TARGET_ALIAS);
	  fprintf (stderr, _("canonical = %s\n"), TARGET_CANONICAL);
	  fprintf (stderr, _("cpu-type = %s\n"), TARGET_CPU);
d430 1
a430 1
	  fprintf (stderr, _("format = %s\n"), TARGET_OBJ_FORMAT);
d433 1
a433 1
	  fprintf (stderr, _("bfd-target = %s\n"), TARGET_FORMAT);
d446 1
a446 1
	      as_fatal (_("bad defsym; format is --defsym name=value"));
a463 6
	    if (optarg == NULL)
	      {
		as_warn ( _("No file name following -t option\n") );
		break;
	      }
	    
d476 1
a476 1
		fprintf (stderr, _("Failed to read instruction table %s\n"), 
a482 12
	case OPTION_DEPFILE:
	  start_dependencies (optarg);
	  break;

	case OPTION_GSTABS:
	  debug_type = DEBUG_STABS;
	  break;
 
	case OPTION_GDWARF2:
	  debug_type = DEBUG_DWARF2;
	  break;

a496 19
	case OPTION_LISTING_LHS_WIDTH:
	  listing_lhs_width = atoi(optarg);
	  if (listing_lhs_width_second < listing_lhs_width)
	    listing_lhs_width_second = listing_lhs_width;
	  break;
	case OPTION_LISTING_LHS_WIDTH2:
	  {
	    int tmp = atoi(optarg);
	    if (tmp > listing_lhs_width)
	      listing_lhs_width_second = tmp;
	  }
	  break;
	case OPTION_LISTING_RHS_WIDTH:
	  listing_rhs_width = atoi(optarg);
	  break;
	case OPTION_LISTING_CONT_LINES:
	  listing_lhs_cont_lines = atoi(optarg);
	  break;

a511 10
	case OPTION_WARN:
	  flag_no_warnings = 0;
	  flag_fatal_warnings = 0;
	  break;

	case OPTION_WARN_FATAL:
	  flag_no_warnings = 0;
	  flag_fatal_warnings = 1;
	  break;

a534 3
		    case 'm':
		      listing |= LISTING_MACEXP;
		      break;
d546 1
a546 1
		      as_fatal (_("invalid listing option `%c'"), *optarg);
a605 5
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);
a711 8
#if defined (BFD_ASSEMBLER) || !defined (BFD)
  /* This used to be done at the start of write_object_file in
     write.c, but that caused problems when doing listings when
     keep_it was zero.  This could probably be moved above md_end, but
     I didn't want to risk the change.  */
  subsegs_finish ();
#endif

a725 3
  if (flag_fatal_warnings && had_warnings() > 0 && had_errors () == 0)
    as_bad (_("%d warnings, treating warnings as errors"), had_warnings());

a739 4

  /* Only generate dependency file if assembler was successful.  */
  print_dependencies ();

d746 1
d752 1
a752 1
  fprintf (stderr, _("%s: total time in assembly: %ld.%06ld\n"),
d755 1
a755 1
  fprintf (stderr, _("%s: data size %ld\n"),
d830 3
a832 3
  text_section = subseg_new (TEXT_SECTION_NAME, 0);
  data_section = subseg_new (DATA_SECTION_NAME, 0);
  bss_section = subseg_new (BSS_SECTION_NAME, 0);
d839 1
d841 1
a841 2
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_DATA));
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001
d20 1
a20 1
   02111-1307, USA.  */
d22 2
a23 1
/* Main program for AS; a 32-bit assembler of GNU.
d28 1
d34 1
a45 1
#include "dwarf2dbg.h"
d66 1
a66 2
/* True if a listing is wanted.  */
int listing;
d68 1
a68 2
/* Name of listing file.  */
static char *listing_filename = NULL;
d72 1
a72 1
enum debug_info_type debug_type = DEBUG_UNSPECIFIED;
d75 1
d78 1
a78 2
/* argv[0]  */
char *myname;
d95 2
a96 1
struct defsym_list {
d104 1
a104 1
/* Keep a record of the itbl files we read in.  */
d106 2
a107 1
struct itbl_file_list {
a119 1
extern struct emulation crisaout, criself;
d145 1
a145 1
    p = argv[i + 1];
d235 1
d249 1
a249 1
    for (i = 0; i < n_emulations - 1; i++)
d254 1
a254 1
    if (!def_em)
a268 2
  --target-help           show target specific options\n"));
  fprintf (stream, _("\
d329 10
a338 8
/* Since it is easy to do here we interpret the special arg "-"
   to mean "use stdin" and we set that argv[] pointing to "".
   After we have munged argv[], the only things left are source file
   name(s) and ""(s) denoting stdin. These file names are used
   (perhaps more than once) later.

   check for new machine-dep cmdline options in
   md_parse_option definitions in config/tc-*.c.  */
d355 3
a357 2
  static const char std_shortopts[] = {
    '-', 'J',
d359 2
a360 2
    /* -K is not meaningful if .word is not being hacked.  */
    'K',
d362 1
a362 1
    'L', 'M', 'R', 'W', 'Z', 'f', 'a', ':', ':', 'D', 'I', ':', 'o', ':',
d364 9
a372 9
    /* -v takes an argument on VMS, so we don't make it a generic
       option.  */
    'v',
#endif
    'w', 'X',
    /* New option for extending instruction set (see also --itbl below)  */
    't', ':',
    '\0'
  };
d406 1
a406 1
    {"listing-lhs-width2", required_argument, NULL, OPTION_LISTING_LHS_WIDTH2},
d424 1
a424 3
#define OPTION_TARGET_HELP (OPTION_STD_BASE + 19)
    {"target-help", no_argument, NULL, OPTION_TARGET_HELP},
#define OPTION_WARN_FATAL (OPTION_STD_BASE + 20)
a425 2
    /* When you add options here, check that they do not collide with
       OPTION_MD_BASE.  See as.h.  */
d428 2
a429 3
  /* Construct the option lists from the standard list and the target
     dependent list.  Include space for an extra NULL option and
     always NULL terminate.  */
d431 1
a431 3
  longopts = (struct option *) xmalloc (sizeof (std_longopts)
					+ md_longopts_size
					+ sizeof (struct option));
a434 2
  memset ((char *) longopts + sizeof (std_longopts) + md_longopts_size,
	  0, sizeof (struct option));
d474 1
a474 1
		new_argv[new_argc++] = optarg, new_argv[new_argc] = NULL;
d483 1
a483 1
	  /* Fall through.  */
a494 4
	case OPTION_TARGET_HELP:
          md_show_usage (stdout);
          exit (EXIT_SUCCESS);

d517 1
a517 1
	  printf (_("Copyright 2001 Free Software Foundation, Inc.\n"));
d549 1
a549 1
	    valueT i;
a556 3
#ifdef BFD_ASSEMBLER
	    i = bfd_scan_vma (s, (const char **) NULL, 0);
#else
a557 1
#endif
d569 2
a570 2
	    /* optarg is the name of the file containing the instruction
	       formats, opcodes, register names, etc.  */
d575 1
a575 1
		as_warn (_("No file name following -t option\n"));
d578 1
a578 1

d585 3
a587 3
	       table.  If multiple instruction tables are specified, the
	       information from this table gets appended onto the existing
	       internal table.  */
d591 1
a591 1
		fprintf (stderr, _("Failed to read instruction table %s\n"),
d605 1
a605 1

d625 1
a625 1
	  listing_lhs_width = atoi (optarg);
d631 1
a631 1
	    int tmp = atoi (optarg);
d637 1
a637 1
	  listing_rhs_width = atoi (optarg);
d640 1
a640 1
	  listing_lhs_cont_lines = atoi (optarg);
a674 3
	      if (md_parse_option (optc, optarg) != 0)
		break;

d716 2
a717 2
	  /* DEBUG is implemented: it debugs different
	     things from other people's assemblers.  */
d726 1
a726 1
	  {			/* Include file directory.  */
d740 1
a740 1
	  /* -X means treat warnings as errors.  */
d754 1
a754 1
int
d809 1
a809 1
  parse_args (&argc, &argv);
d862 1
a862 2
  /* Assemble it.  */
  perform_an_assembly_pass (argc, argv);
a869 4
  /* If we've been collecting dwarf2 .debug_line info, either for
     assembly debugging or on behalf of the compiler, emit it now.  */
  dwarf2_finish ();

d898 2
a899 2
  if (flag_fatal_warnings && had_warnings () > 0 && had_errors () == 0)
    as_bad (_("%d warnings, treating warnings as errors"), had_warnings ());
a949 5
/* Here to attempt 1 pass over each input file.
   We scan argv[*] looking for filenames or exactly "" which is
   shorthand for stdin. Any argv that is NULL is not a file-name.
   We set need_pass_2 TRUE if, after this, we still have unresolved
   expressions of the form (unknown value)+-(unknown value).
d951 12
a962 4
   Note the un*x semantics: there is only 1 logical input file, but it
   may be a catenation of many 'physical' input files.  */

static void
d981 1
a981 1
  /* Create the three fixed ones.  */
d1012 1
a1012 1
     to have relocs, otherwise we don't find out in time.  */
d1039 2
a1040 4
  /* Skip argv[0].  */
  argv++;
  argc--;

d1044 1
a1044 1
	{			/* Is it a file-name argument?  */
d1047 1
a1047 1
	  /* argv->"" if stdin desired, else->filename  */
d1050 1
a1050 1
      argv++;			/* completed that argv  */
d1054 1
a1054 1
}
d1083 2
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002
a45 4
#ifdef BFD_ASSEMBLER
#include "bfdver.h"
#endif

a63 4
#ifdef USING_CGEN
/* Perform any cgen specific initialisation for gas.  */
extern void gas_cgen_begin PARAMS ((void));
#endif
d211 1
a211 1
	   VERSION, TARGET_ALIAS, BFD_VERSION_STRING);
d353 1
a353 1
  extern const char *md_shortopts;
a376 4
    /* getopt allows abbreviations, so we do this to stop it from
       treating -k as an abbreviation for --keep-locals.  Some
       ports use -k to enable PIC assembly.  */
    {"keep-locals", no_argument, NULL, 'L'},
d503 2
a504 2
	  md_show_usage (stdout);
	  exit (EXIT_SUCCESS);
a526 3
#ifdef BFD_ASSEMBLER
	  printf (_("GNU assembler %s\n"), BFD_VERSION_STRING);
#else
d528 1
a528 2
#endif
	  printf (_("Copyright 2002 Free Software Foundation, Inc.\n"));
d590 1
a590 1
		as_warn (_("no file name following -t option"));
d605 5
a609 2
	      as_fatal (_("failed to read instruction table %s\n"),
			itbl_files->name);
a767 4

#ifdef md_after_parse_args
  md_after_parse_args ();
#endif
a771 2
int main PARAMS ((int, char **));

a785 3
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
d790 7
a796 1
    chunksize = 64;
a1054 3
#ifdef USING_CGEN
  gas_cgen_begin ();
#endif
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d24 10
a33 9
   Understands command arguments.
   Has a few routines that don't fit in other modules because they
   are shared.
  
  			bugs
  
   : initialisers
  	Since no-one else says they will support them in future: I
   don't support them now.  */
a44 1
#include "dw2gencfi.h"
d63 5
d70 1
a70 1
extern void gas_cgen_begin (void);
a72 17
/* Keep a record of the itbl files we read in.  */
struct itbl_file_list
{
  struct itbl_file_list *next;
  char *name;
};

/* We build a list of defsyms as we read the options, and then define
   them after we have initialized everything.  */
struct defsym_list
{
  struct defsym_list *next;
  char *name;
  valueT value;
};


d76 3
d80 1
a81 1
int use_gnu_debug_info_extensions = 0;
d87 5
a91 1
char * myname;
d101 2
a102 2
/* Enable verbose mode.  */
int verbose = 0;
d104 5
a108 10
#ifdef BFD_ASSEMBLER
segT reg_section;
segT expr_section;
segT text_section;
segT data_section;
segT bss_section;
#endif

/* Name of listing file.  */
static char *listing_filename = NULL;
d112 1
a112 1
static struct itbl_file_list *itbl_files;
d114 4
a117 1
static long start_time;
d119 1
d132 2
d135 3
a137 1
select_emulation_mode (int argc, char **argv)
d181 1
a181 1
default_emul_bfd_name (void)
d188 1
a188 1
common_emul_init (void)
d210 1
a210 1
print_version_id (void)
a212 1

d227 2
a228 1
show_usage (FILE * stream)
a266 6
#if defined BFD_ASSEMBLER && (defined OBJ_ELF || defined OBJ_MAYBE_ELF)
  fprintf (stream, _("\
  --execstack             require executable stack for this object\n"));
  fprintf (stream, _("\
  --noexecstack           don't require executable stack for this object\n"));
#endif
a271 2
  --gstabs+               generate stabs debug info with GNU extensions\n"));
  fprintf (stream, _("\
d348 3
a350 1
parse_args (int * pargc, char *** pargv)
d352 3
a354 4
  int old_argc;
  int new_argc;
  char ** old_argv;
  char ** new_argv;
d359 1
d362 1
a362 2
  static const char std_shortopts[] =
  {
d368 1
a368 1
    'L', 'M', 'R', 'W', 'Z', 'a', ':', ':', 'D', 'f', 'I', ':', 'o', ':',
d375 1
a375 1
    /* New option for extending instruction set (see also --itbl below).  */
d382 2
a383 31
  /* Codes used for the long options with no short synonyms.  */
  enum option_values
    {
      OPTION_HELP = OPTION_STD_BASE,
      OPTION_NOCPP,
      OPTION_STATISTICS,
      OPTION_VERSION,
      OPTION_DUMPCONFIG,
      OPTION_VERBOSE,
      OPTION_EMULATION,
      OPTION_DEFSYM,
      OPTION_INSTTBL,
      OPTION_LISTING_LHS_WIDTH,
      OPTION_LISTING_LHS_WIDTH2,
      OPTION_LISTING_RHS_WIDTH,
      OPTION_LISTING_CONT_LINES,
      OPTION_DEPFILE,
      OPTION_GSTABS,
      OPTION_GSTABS_PLUS,
      OPTION_STRIP_LOCAL_ABSOLUTE,
      OPTION_TRADITIONAL_FORMAT,
      OPTION_GDWARF2,
      OPTION_WARN,
      OPTION_TARGET_HELP,
      OPTION_EXECSTACK,
      OPTION_NOEXECSTACK,
      OPTION_WARN_FATAL
    };
  
  static const struct option std_longopts[] =
  {
d391 1
d393 1
d395 1
d397 1
d399 1
d401 1
d403 1
d405 1
d413 1
d415 1
d417 1
d419 1
d421 1
d423 1
d425 1
a425 1
    {"gstabs+", no_argument, NULL, OPTION_GSTABS_PLUS},
d427 1
d429 1
d432 1
d434 1
d436 1
a436 4
#if defined BFD_ASSEMBLER && (defined OBJ_ELF || defined OBJ_MAYBE_ELF)
    {"execstack", no_argument, NULL, OPTION_EXECSTACK},
    {"noexecstack", no_argument, NULL, OPTION_NOEXECSTACK},
#endif
d446 3
a448 1
  longopts = xmalloc (sizeof (std_longopts) + md_longopts_size + sizeof (struct option));
d450 3
a452 2
  memcpy (((char *) longopts) + sizeof (std_longopts), md_longopts, md_longopts_size);
  memset (((char *) longopts) + sizeof (std_longopts) + md_longopts_size,
d460 1
a460 1
  new_argv = xmalloc (sizeof (char *) * (old_argc + 1));
d484 1
a484 1
	     it explicitly here before deciding we've gotten a bad argument.  */
a499 1
		verbose = 1;
d589 1
a589 1
	    n = xmalloc (sizeof *n);
d610 1
a610 1
	    n = xmalloc (sizeof * n);
a629 3
	case OPTION_GSTABS_PLUS:
	  use_gnu_debug_info_extensions = 1;
	  /* Fall through.  */
d647 1
a695 11
#if defined BFD_ASSEMBLER && (defined OBJ_ELF || defined OBJ_MAYBE_ELF)
	case OPTION_EXECSTACK:
	  flag_execstack = 1;
	  flag_noexecstack = 0;
	  break;

	case OPTION_NOEXECSTACK:
	  flag_noexecstack = 1;
	  flag_execstack = 0;
	  break;
#endif
d787 1
a787 7
static void
dump_statistics (void)
{
#ifdef HAVE_SBRK
  char *lim = (char *) sbrk (0);
#endif
  long run_time = get_run_time () - start_time;
d789 1
a789 151
  fprintf (stderr, _("%s: total time in assembly: %ld.%06ld\n"),
	   myname, run_time / 1000000, run_time % 1000000);
#ifdef HAVE_SBRK
  fprintf (stderr, _("%s: data size %ld\n"),
	   myname, (long) (lim - (char *) &environ));
#endif

  subsegs_print_statistics (stderr);
  write_print_statistics (stderr);
  symbol_print_statistics (stderr);
  read_print_statistics (stderr);

#ifdef tc_print_statistics
  tc_print_statistics (stderr);
#endif

#ifdef obj_print_statistics
  obj_print_statistics (stderr);
#endif
}

/* The interface between the macro code and gas expression handling.  */

static int
macro_expr (const char *emsg, int idx, sb *in, int *val)
{
  char *hold;
  expressionS ex;

  sb_terminate (in);

  hold = input_line_pointer;
  input_line_pointer = in->ptr + idx;
  expression (&ex);
  idx = input_line_pointer - in->ptr;
  input_line_pointer = hold;

  if (ex.X_op != O_constant)
    as_bad ("%s", emsg);

  *val = (int) ex.X_add_number;

  return idx;
}

/* Here to attempt 1 pass over each input file.
   We scan argv[*] looking for filenames or exactly "" which is
   shorthand for stdin. Any argv that is NULL is not a file-name.
   We set need_pass_2 TRUE if, after this, we still have unresolved
   expressions of the form (unknown value)+-(unknown value).

   Note the un*x semantics: there is only 1 logical input file, but it
   may be a catenation of many 'physical' input files.  */

static void
perform_an_assembly_pass (int argc, char ** argv)
{
  int saw_a_file = 0;
#ifdef BFD_ASSEMBLER
  flagword applicable;
#endif

  need_pass_2 = 0;

#ifndef BFD_ASSEMBLER
#ifdef MANY_SEGMENTS
  {
    unsigned int i;
    for (i = SEG_E0; i < SEG_UNKNOWN; i++)
      segment_info[i].fix_root = 0;
  }
  /* Create the three fixed ones.  */
  {
    segT seg;

#ifdef TE_APOLLO
    seg = subseg_new (".wtext", 0);
#else
    seg = subseg_new (".text", 0);
#endif
    assert (seg == SEG_E0);
    seg = subseg_new (".data", 0);
    assert (seg == SEG_E1);
    seg = subseg_new (".bss", 0);
    assert (seg == SEG_E2);
#ifdef TE_APOLLO
    create_target_segments ();
#endif
  }

#else /* not MANY_SEGMENTS.  */
  text_fix_root = NULL;
  data_fix_root = NULL;
  bss_fix_root = NULL;
#endif /* not MANY_SEGMENTS.  */
#else /* BFD_ASSEMBLER.  */
  /* Create the standard sections, and those the assembler uses
     internally.  */
  text_section = subseg_new (TEXT_SECTION_NAME, 0);
  data_section = subseg_new (DATA_SECTION_NAME, 0);
  bss_section = subseg_new (BSS_SECTION_NAME, 0);
  /* @@@@ FIXME -- we're setting the RELOC flag so that sections are assumed
     to have relocs, otherwise we don't find out in time.  */
  applicable = bfd_applicable_section_flags (stdoutput);
  bfd_set_section_flags (stdoutput, text_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_CODE | SEC_READONLY));
  bfd_set_section_flags (stdoutput, data_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_DATA));
  bfd_set_section_flags (stdoutput, bss_section, applicable & SEC_ALLOC);
  seg_info (bss_section)->bss = 1;
  subseg_new (BFD_ABS_SECTION_NAME, 0);
  subseg_new (BFD_UND_SECTION_NAME, 0);
  reg_section = subseg_new ("*GAS `reg' section*", 0);
  expr_section = subseg_new ("*GAS `expr' section*", 0);

#endif /* BFD_ASSEMBLER.  */

  subseg_set (text_section, 0);

  /* This may add symbol table entries, which requires having an open BFD,
     and sections already created, in BFD_ASSEMBLER mode.  */
  md_begin ();

#ifdef USING_CGEN
  gas_cgen_begin ();
#endif
#ifdef obj_begin
  obj_begin ();
#endif

  /* Skip argv[0].  */
  argv++;
  argc--;

  while (argc--)
    {
      if (*argv)
	{			/* Is it a file-name argument?  */
	  PROGRESS (1);
	  saw_a_file++;
	  /* argv->"" if stdin desired, else->filename.  */
	  read_a_source_file (*argv);
	}
      argv++;			/* Completed that argv.  */
    }
  if (!saw_a_file)
    read_a_source_file ("");
}

d792 3
a794 1
main (int argc, char ** argv)
a904 13
#if defined BFD_ASSEMBLER && (defined OBJ_ELF || defined OBJ_MAYBE_ELF)
  if ((flag_execstack || flag_noexecstack)
      && OUTPUT_FLAVOR == bfd_target_elf_flavour)
    {
      segT gnustack;

      gnustack = subseg_new (".note.GNU-stack", 0);
      bfd_set_section_flags (stdoutput, gnustack,
			     SEC_READONLY | (flag_execstack ? SEC_CODE : 0));
                                                                             
    }
#endif

a908 4
  /* If we constructed dwarf2 .eh_frame info, either via .cfi 
     directives from the user or by the backend, emit it now.  */
  cfi_finish ();

d930 1
a930 1
#ifndef OBJ_VMS /* Does its own file handling.  */
d961 163
@


