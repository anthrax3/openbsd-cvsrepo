head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.24;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.28;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.42;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.39;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.39;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.46.11;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.31.55;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.26;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.43;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* input_file.c - Deal with Input Files -
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2003
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Confines all details of reading source bytes to this module.
   All O/S specific crocks should live here.
   What we lose in "efficiency" we gain in modularity.
   Note we don't need to #include the "as.h" file. No common coupling!  */

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include "as.h"
#include "input-file.h"
#include "safe-ctype.h"

static int input_file_get (char *, int);

/* This variable is non-zero if the file currently being read should be
   preprocessed by app.  It is zero if the file can be read straight in.  */
int preprocess = 0;

/* This code opens a file, then delivers BUFFER_SIZE character
   chunks of the file on demand.
   BUFFER_SIZE is supposed to be a number chosen for speed.
   The caller only asks once what BUFFER_SIZE is, and asks before
   the nature of the input files (if any) is known.  */

#define BUFFER_SIZE (32 * 1024)

/* We use static data: the data area is not sharable.  */

static FILE *f_in;
static char *file_name;

/* Struct for saving the state of this module for file includes.  */
struct saved_file
  {
    FILE * f_in;
    char * file_name;
    int    preprocess;
    char * app_save;
  };

/* These hooks accommodate most operating systems.  */

void
input_file_begin (void)
{
  f_in = (FILE *) 0;
}

void
input_file_end (void)
{
}

/* Return BUFFER_SIZE.  */
unsigned int
input_file_buffer_size (void)
{
  return (BUFFER_SIZE);
}

int
input_file_is_open (void)
{
  return f_in != (FILE *) 0;
}

/* Push the state of our input, returning a pointer to saved info that
   can be restored with input_file_pop ().  */

char *
input_file_push (void)
{
  register struct saved_file *saved;

  saved = (struct saved_file *) xmalloc (sizeof *saved);

  saved->f_in = f_in;
  saved->file_name = file_name;
  saved->preprocess = preprocess;
  if (preprocess)
    saved->app_save = app_push ();

  /* Initialize for new file.  */
  input_file_begin ();

  return (char *) saved;
}

void
input_file_pop (char *arg)
{
  register struct saved_file *saved = (struct saved_file *) arg;

  input_file_end ();		/* Close out old file.  */

  f_in = saved->f_in;
  file_name = saved->file_name;
  preprocess = saved->preprocess;
  if (preprocess)
    app_pop (saved->app_save);

  free (arg);
}

void
input_file_open (char *filename, /* "" means use stdin. Must not be 0.  */
		 int pre)
{
  int c;
  char buf[80];

  preprocess = pre;

  assert (filename != 0);	/* Filename may not be NULL.  */
  if (filename[0])
    {
      f_in = fopen (filename, FOPEN_RT);
      file_name = filename;
    }
  else
    {
      /* Use stdin for the input file.  */
      f_in = stdin;
      /* For error messages.  */
      file_name = _("{standard input}");
    }

  if (f_in)
    c = getc (f_in);

  if (f_in == NULL || ferror (f_in))
    {
#ifdef BFD_ASSEMBLER
      bfd_set_error (bfd_error_system_call);
#endif
      as_perror (_("Can't open %s for reading"), file_name);

      if (f_in)
	{
	  fclose (f_in);
	  f_in = NULL;
	}
      return;
    }

  if (c == '#')
    {
      /* Begins with comment, may not want to preprocess.  */
      c = getc (f_in);
      if (c == 'N')
	{
	  fgets (buf, 80, f_in);
	  if (!strncmp (buf, "O_APP", 5) && ISSPACE (buf[5]))
	    preprocess = 0;
	  if (!strchr (buf, '\n'))
	    ungetc ('#', f_in);	/* It was longer.  */
	  else
	    ungetc ('\n', f_in);
	}
      else if (c == 'A')
	{
	  fgets (buf, 80, f_in);
	  if (!strncmp (buf, "PP", 2) && ISSPACE (buf[2]))
	    preprocess = 1;
	  if (!strchr (buf, '\n'))
	    ungetc ('#', f_in);
	  else
	    ungetc ('\n', f_in);
	}
      else if (c == '\n')
	ungetc ('\n', f_in);
      else
	ungetc ('#', f_in);
    }
  else
    ungetc (c, f_in);
}

/* Close input file.  */

void
input_file_close (void)
{
  /* Don't close a null file pointer.  */
  if (f_in != NULL)
    fclose (f_in);

  f_in = 0;
}

/* This function is passed to do_scrub_chars.  */

static int
input_file_get (char *buf, int buflen)
{
  int size;

  size = fread (buf, sizeof (char), buflen, f_in);
  if (size < 0)
    {
#ifdef BFD_ASSEMBLER
      bfd_set_error (bfd_error_system_call);
#endif
      as_perror (_("Can't read from %s"), file_name);
      size = 0;
    }
  return size;
}

/* Read a buffer from the input file.  */

char *
input_file_give_next_buffer (char *where /* Where to place 1st character of new buffer.  */)
{
  char *return_value;		/* -> Last char of what we read, + 1.  */
  register int size;

  if (f_in == (FILE *) 0)
    return 0;
  /* fflush (stdin); could be done here if you want to synchronise
     stdin and stdout, for the case where our input file is stdin.
     Since the assembler shouldn't do any output to stdout, we
     don't bother to synch output and input.  */
  if (preprocess)
    size = do_scrub_chars (input_file_get, where, BUFFER_SIZE);
  else
    size = fread (where, sizeof (char), BUFFER_SIZE, f_in);
  if (size < 0)
    {
#ifdef BFD_ASSEMBLER
      bfd_set_error (bfd_error_system_call);
#endif
      as_perror (_("Can't read from %s"), file_name);
      size = 0;
    }
  if (size)
    return_value = where + size;
  else
    {
      if (fclose (f_in))
	{
#ifdef BFD_ASSEMBLER
	  bfd_set_error (bfd_error_system_call);
#endif
	  as_perror (_("Can't close %s"), file_name);
	}
      f_in = (FILE *) 0;
      return_value = 0;
    }

  return return_value;
}
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001
d29 1
d34 1
a34 1
static int input_file_get PARAMS ((char *, int));
d62 1
a62 1
/* These hooks accomodate most operating systems.  */
d65 1
a65 1
input_file_begin ()
d71 1
a71 1
input_file_end ()
d77 1
a77 1
input_file_buffer_size ()
d83 1
a83 1
input_file_is_open ()
d92 1
a92 1
input_file_push ()
d111 1
a111 2
input_file_pop (arg)
     char *arg;
d127 2
a128 3
input_file_open (filename, pre)
     char *filename;		/* "" means use stdin. Must not be 0.  */
     int pre;
d137 1
a137 1
    {				/* We have a file name. Suck it and see.  */
d142 2
a143 1
    {				/* use stdin for the input file.  */
d145 2
a146 1
      file_name = _("{standard input}");	/* For error messages.  */
d148 5
a152 1
  if (f_in == (FILE *) 0)
d154 10
a163 2
      as_bad (_("can't open %s for reading"), file_name);
      as_perror ("%s", file_name);
a166 1
  c = getc (f_in);
d203 1
a203 1
input_file_close ()
d215 1
a215 3
input_file_get (buf, buflen)
     char *buf;
     int buflen;
d222 3
d234 1
a234 2
input_file_give_next_buffer (where)
     char *where;		/* Where to place 1st character of new buffer.  */
d251 3
d262 6
a267 1
	as_perror (_("Can't close %s"), file_name);
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000
d22 4
a25 6
/*
 * Confines all details of reading source bytes to this module.
 * All O/S specific crocks should live here.
 * What we lose in "efficiency" we gain in modularity.
 * Note we don't need to #include the "as.h" file. No common coupling!
 */
a28 1

d31 1
d36 1
a36 2
   preprocessed by app.  It is zero if the file can be read straight in.
   */
d39 5
a43 7
/*
 * This code opens a file, then delivers BUFFER_SIZE character
 * chunks of the file on demand.
 * BUFFER_SIZE is supposed to be a number chosen for speed.
 * The caller only asks once what BUFFER_SIZE is, and asks before
 * the nature of the input files (if any) is known.
 */
d47 1
a47 3
/*
 * We use static data: the data area is not sharable.
 */
d53 7
a59 6
struct saved_file {
  FILE *f_in;
  char *file_name;
  int preprocess;
  char *app_save;
};
d89 1
d103 2
a104 1
  input_file_begin ();		/* Initialize for new file */
d115 1
a115 1
  input_file_end ();		/* Close out old file */
d139 1
a139 1
      f_in = fopen (filename, "r");
d149 1
a149 1
      as_bad (_("Can't open %s for reading."), file_name);
d156 2
a157 1
    {				/* Begins with comment, may not want to preprocess */
d162 1
a162 1
	  if (!strcmp (buf, "O_APP\n"))
d165 11
a175 1
	    ungetc ('#', f_in);	/* It was longer */
d189 1
d193 1
d195 2
a196 3
    {
      fclose (f_in);
    }				/* don't close a null file pointer */
d229 4
a232 6
  /*
   * fflush (stdin); could be done here if you want to synchronise
   * stdin and stdout, for the case where our input file is stdin.
   * Since the assembler shouldn't do any output to stdout, we
   * don't bother to synch output and input.
   */
d251 2
a252 1
  return (return_value);
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 98, 1999
d60 6
a65 7
struct saved_file
  {
    FILE *f_in;
    char *file_name;
    int preprocess;
    char *app_save;
  };
d67 1
a67 1
/* These hooks accomodate most operating systems. */
d69 1
a69 1
void 
d75 1
a75 1
void 
d80 2
a81 2
/* Return BUFFER_SIZE. */
unsigned int 
d87 1
a87 1
int 
d132 1
a132 1
     char *filename;		/* "" means use stdin. Must not be 0. */
d140 1
a140 1
  assert (filename != 0);	/* Filename may not be NULL. */
d142 1
a142 1
    {				/* We have a file name. Suck it and see. */
d147 1
a147 1
    {				/* use stdin for the input file. */
d149 1
a149 1
      file_name = _("{standard input}");	/* For error messages. */
d182 1
a182 1
void 
d190 1
a190 1
}				/* input_file_close() */
d214 1
a214 1
     char *where;		/* Where to place 1st character of new buffer. */
d216 1
a216 1
  char *return_value;		/* -> Last char of what we read, + 1. */
a246 2

/* end of input-file.c */
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1987, 1990, 1991, 1992 Free Software Foundation, Inc.
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d35 1
a35 1
static int input_file_get PARAMS ((char **));
d150 1
a150 1
      file_name = "{standard input}";	/* For error messages. */
d154 1
a154 1
      as_bad ("Can't open %s for reading.", file_name);
d196 3
a198 2
input_file_get (from)
     char **from;
a199 1
  static char buf[BUFFER_SIZE];
d202 1
a202 1
  size = fread (buf, sizeof (char), sizeof buf, f_in);
d205 1
a205 1
      as_perror ("Can't read from %s", file_name);
a207 1
  *from = buf;
d234 1
a234 1
      as_perror ("Can't read from %s", file_name);
d242 1
a242 1
	as_perror ("Can't close %s", file_name);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 98, 1999
   Free Software Foundation, Inc.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d33 1
a33 1
static int input_file_get PARAMS ((char *, int));
d148 1
a148 1
      file_name = _("{standard input}");	/* For error messages. */
d152 1
a152 1
      as_bad (_("Can't open %s for reading."), file_name);
d194 2
a195 3
input_file_get (buf, buflen)
     char *buf;
     int buflen;
d197 1
d200 1
a200 1
  size = fread (buf, sizeof (char), buflen, f_in);
d203 1
a203 1
      as_perror (_("Can't read from %s"), file_name);
d206 1
d233 1
a233 1
      as_perror (_("Can't read from %s"), file_name);
d241 1
a241 1
	as_perror (_("Can't close %s"), file_name);
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000
d60 7
a66 6
struct saved_file {
  FILE *f_in;
  char *file_name;
  int preprocess;
  char *app_save;
};
d68 1
a68 1
/* These hooks accomodate most operating systems.  */
d70 1
a70 1
void
d76 1
a76 1
void
d81 2
a82 2
/* Return BUFFER_SIZE.  */
unsigned int
d88 1
a88 1
int
d133 1
a133 1
     char *filename;		/* "" means use stdin. Must not be 0.  */
d141 1
a141 1
  assert (filename != 0);	/* Filename may not be NULL.  */
d143 1
a143 1
    {				/* We have a file name. Suck it and see.  */
d148 1
a148 1
    {				/* use stdin for the input file.  */
d150 1
a150 1
      file_name = _("{standard input}");	/* For error messages.  */
d183 1
a183 1
void
d191 1
a191 1
}
d215 1
a215 1
     char *where;		/* Where to place 1st character of new buffer.  */
d217 1
a217 1
  char *return_value;		/* -> Last char of what we read, + 1.  */
d248 2
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001
d22 6
a27 4
/* Confines all details of reading source bytes to this module.
   All O/S specific crocks should live here.
   What we lose in "efficiency" we gain in modularity.
   Note we don't need to #include the "as.h" file. No common coupling!  */
d31 1
a33 1
#include "safe-ctype.h"
d38 2
a39 1
   preprocessed by app.  It is zero if the file can be read straight in.  */
d42 7
a48 5
/* This code opens a file, then delivers BUFFER_SIZE character
   chunks of the file on demand.
   BUFFER_SIZE is supposed to be a number chosen for speed.
   The caller only asks once what BUFFER_SIZE is, and asks before
   the nature of the input files (if any) is known.  */
d52 3
a54 1
/* We use static data: the data area is not sharable.  */
d60 6
a65 7
struct saved_file
  {
    FILE * f_in;
    char * file_name;
    int    preprocess;
    char * app_save;
  };
a94 1

d108 1
a108 2
  /* Initialize for new file.  */
  input_file_begin ();
d119 1
a119 1
  input_file_end ();		/* Close out old file.  */
d143 1
a143 1
      f_in = fopen (filename, FOPEN_RT);
d153 1
a153 1
      as_bad (_("can't open %s for reading"), file_name);
d160 1
a160 2
    {
      /* Begins with comment, may not want to preprocess.  */
d165 1
a165 1
	  if (!strncmp (buf, "O_APP", 5) && ISSPACE (buf[5]))
d168 1
a168 11
	    ungetc ('#', f_in);	/* It was longer.  */
	  else
	    ungetc ('\n', f_in);
	}
      else if (c == 'A')
	{
	  fgets (buf, 80, f_in);
	  if (!strncmp (buf, "PP", 2) && ISSPACE (buf[2]))
	    preprocess = 1;
	  if (!strchr (buf, '\n'))
	    ungetc ('#', f_in);
a181 1

a184 1
  /* Don't close a null file pointer.  */
d186 3
a188 2
    fclose (f_in);

d221 6
a226 4
  /* fflush (stdin); could be done here if you want to synchronise
     stdin and stdout, for the case where our input file is stdin.
     Since the assembler shouldn't do any output to stdout, we
     don't bother to synch output and input.  */
d245 1
a245 2

  return return_value;
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2003
a28 1
#include <errno.h>
d33 1
a33 1
static int input_file_get (char *, int);
d61 1
a61 1
/* These hooks accommodate most operating systems.  */
d64 1
a64 1
input_file_begin (void)
d70 1
a70 1
input_file_end (void)
d76 1
a76 1
input_file_buffer_size (void)
d82 1
a82 1
input_file_is_open (void)
d91 1
a91 1
input_file_push (void)
d110 2
a111 1
input_file_pop (char *arg)
d127 3
a129 2
input_file_open (char *filename, /* "" means use stdin. Must not be 0.  */
		 int pre)
d138 1
a138 1
    {
d143 1
a143 2
    {
      /* Use stdin for the input file.  */
d145 1
a145 2
      /* For error messages.  */
      file_name = _("{standard input}");
d147 1
a147 5

  if (f_in)
    c = getc (f_in);

  if (f_in == NULL || ferror (f_in))
d149 2
a150 10
#ifdef BFD_ASSEMBLER
      bfd_set_error (bfd_error_system_call);
#endif
      as_perror (_("Can't open %s for reading"), file_name);

      if (f_in)
	{
	  fclose (f_in);
	  f_in = NULL;
	}
d154 1
d191 1
a191 1
input_file_close (void)
d203 3
a205 1
input_file_get (char *buf, int buflen)
a211 3
#ifdef BFD_ASSEMBLER
      bfd_set_error (bfd_error_system_call);
#endif
d221 2
a222 1
input_file_give_next_buffer (char *where /* Where to place 1st character of new buffer.  */)
a238 3
#ifdef BFD_ASSEMBLER
      bfd_set_error (bfd_error_system_call);
#endif
d247 1
a247 6
	{
#ifdef BFD_ASSEMBLER
	  bfd_set_error (bfd_error_system_call);
#endif
	  as_perror (_("Can't close %s"), file_name);
	}
@


