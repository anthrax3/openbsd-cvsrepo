head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.54
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.24;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.28;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.42;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.37;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.37;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.29.09.21.51;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.46.10;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.31.48;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.25;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.43;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* frags.h - Header file for the frag concept.
   Copyright 1987, 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#ifndef FRAGS_H
#define FRAGS_H

#ifdef ANSI_PROTOTYPES
struct obstack;
#endif

/* A code fragment (frag) is some known number of chars, followed by some
   unknown number of chars. Typically the unknown number of chars is an
   instruction address whose size is yet unknown. We always know the greatest
   possible size the unknown number of chars may become, and reserve that
   much room at the end of the frag.
   Once created, frags do not change address during assembly.
   We chain the frags in (a) forward-linked list(s). The object-file address
   of the 1st char of a frag is generally not known until after relax().
   Many things at assembly time describe an address by {object-file-address
   of a particular frag}+offset.

   BUG: it may be smarter to have a single pointer off to various different
   notes for different frag kinds.  See how code pans.  */

struct frag {
  /* Object file address (as an octet offset).  */
  addressT fr_address;
  /* When relaxing multiple times, remember the address the frag had
     in the last relax pass.  */
  addressT last_fr_address;

  /* (Fixed) number of octets we know we have.  May be 0.  */
  offsetT fr_fix;
  /* May be used for (Variable) number of octets after above.
     The generic frag handling code no longer makes any use of fr_var.  */
  offsetT fr_var;
  /* For variable-length tail.  */
  offsetT fr_offset;
  /* For variable-length tail.  */
  symbolS *fr_symbol;
  /* Points to opcode low addr byte, for relaxation.  */
  char *fr_opcode;

  /* Chain forward; ascending address order.  Rooted in frch_root.  */
  struct frag *fr_next;

  /* Where the frag was created, or where it became a variant frag.  */
  char *fr_file;
  unsigned int fr_line;

#ifndef NO_LISTING
  struct list_info_struct *line;
#endif

  /* Flipped each relax pass so we can easily determine whether
     fr_address has been adjusted.  */
  unsigned int relax_marker:1;

  /* What state is my tail in? */
  relax_stateT fr_type;
  relax_substateT fr_subtype;

#ifdef USING_CGEN
  /* Don't include this unless using CGEN to keep frag size down.  */
  struct {
    /* CGEN_INSN entry for this instruction.  */
    const struct cgen_insn *insn;
    /* Index into operand table.  */
    int opindex;
    /* Target specific data, usually reloc number.  */
    int opinfo;
  } fr_cgen;
#endif

#ifdef TC_FRAG_TYPE
  TC_FRAG_TYPE tc_frag_data;
#endif

  /* Data begins here.  */
  char fr_literal[1];
};

#define SIZEOF_STRUCT_FRAG \
((char *) zero_address_frag.fr_literal - (char *) &zero_address_frag)
/* We want to say fr_literal[0] above.  */

/* Current frag we are building.  This frag is incomplete.  It is,
   however, included in frchain_now.  The fr_fix field is bogus;
   instead, use frag_now_fix ().  */
COMMON fragS *frag_now;
extern addressT frag_now_fix (void);
extern addressT frag_now_fix_octets (void);

/* For foreign-segment symbol fixups.  */
COMMON fragS zero_address_frag;
/* For local common (N_BSS segment) fixups.  */
COMMON fragS bss_address_frag;

#if 0
/* A macro to speed up appending exactly 1 char to current frag.  */
/* JF changed < 1 to <= 1 to avoid a race condition.  */
#define FRAG_APPEND_1_CHAR(datum)			\
{							\
  if (obstack_room (&frags) <= 1)			\
    {							\
      frag_wane (frag_now);				\
      frag_new (0);					\
    }							\
  obstack_1grow (&frags, datum);			\
}
#else
extern void frag_append_1_char (int);
#define FRAG_APPEND_1_CHAR(X) frag_append_1_char (X)
#endif

void frag_init (void);
fragS *frag_alloc (struct obstack *);
void frag_grow (unsigned int nchars);
char *frag_more (int nchars);
void frag_align (int alignment, int fill_character, int max);
void frag_align_pattern (int alignment, const char *fill_pattern,
			 int n_fill, int max);
void frag_align_code (int alignment, int max);
void frag_new (int old_frags_var_max_size);
void frag_wane (fragS * fragP);
int frag_room (void);

char *frag_variant (relax_stateT type,
		    int max_chars,
		    int var,
		    relax_substateT subtype,
		    symbolS * symbol,
		    offsetT offset,
		    char *opcode);

char *frag_var (relax_stateT type,
		int max_chars,
		int var,
		relax_substateT subtype,
		symbolS * symbol,
		offsetT offset,
		char *opcode);

#endif /* FRAGS_H */
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d109 2
a110 2
extern addressT frag_now_fix PARAMS ((void));
extern addressT frag_now_fix_octets PARAMS ((void));
d119 1
a119 1
/* JF changed < 1 to <= 1 to avoid a race conditon.  */
d130 1
a130 1
extern void frag_append_1_char PARAMS ((int));
d134 11
a144 12
void frag_init PARAMS ((void));
fragS *frag_alloc PARAMS ((struct obstack *));
void frag_grow PARAMS ((unsigned int nchars));
char *frag_more PARAMS ((int nchars));
void frag_align PARAMS ((int alignment, int fill_character, int max));
void frag_align_pattern PARAMS ((int alignment,
				 const char *fill_pattern,
				 int n_fill,
				 int max));
void frag_align_code PARAMS ((int alignment, int max));
void frag_new PARAMS ((int old_frags_var_max_size));
void frag_wane PARAMS ((fragS * fragP));
d146 7
a152 7
char *frag_variant PARAMS ((relax_stateT type,
			    int max_chars,
			    int var,
			    relax_substateT subtype,
			    symbolS * symbol,
			    offsetT offset,
			    char *opcode));
d154 7
a160 7
char *frag_var PARAMS ((relax_stateT type,
			int max_chars,
			int var,
			relax_substateT subtype,
			symbolS * symbol,
			offsetT offset,
			char *opcode));
@


1.3
log
@resolve conflicts.
@
text
@d41 1
a41 1
   notes for different frag kinds.  See how code pans.   */
d46 3
a48 2
  /* Chain forward; ascending address order.  Rooted in frch_root.  */
  struct frag *fr_next;
d56 2
a58 2
  /* For variable-length tail.  */
  offsetT fr_offset;
d62 7
a95 4

  /* Where the frag was created, or where it became a variant frag.  */
  char *fr_file;
  unsigned int fr_line;
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 97, 98, 99, 2000
d29 16
a44 19
/*
 * A code fragment (frag) is some known number of chars, followed by some
 * unknown number of chars. Typically the unknown number of chars is an
 * instruction address whose size is yet unknown. We always know the greatest
 * possible size the unknown number of chars may become, and reserve that
 * much room at the end of the frag.
 * Once created, frags do not change address during assembly.
 * We chain the frags in (a) forward-linked list(s). The object-file address
 * of the 1st char of a frag is generally not known until after relax().
 * Many things at assembly time describe an address by {object-file-address
 * of a particular frag}+offset.

 BUG: it may be smarter to have a single pointer off to various different
 notes for different frag kinds. See how code pans
 */

struct frag
{
  /* Object file address (as an octet offset). */
d46 1
a46 1
  /* Chain forward; ascending address order.  Rooted in frch_root. */
d49 1
a49 1
  /* (Fixed) number of octets we know we have.  May be 0. */
d54 1
a54 1
  /* For variable-length tail. */
d56 1
a56 1
  /* For variable-length tail. */
d65 4
d98 2
a99 2
((char *)zero_address_frag.fr_literal-(char *)&zero_address_frag)
/* We want to say fr_literal[0] above. */
d108 1
a108 1
/* For foreign-segment symbol fixups. */
d110 1
a110 1
/* For local common (N_BSS segment) fixups. */
d114 10
a123 12
/*
 * A macro to speed up appending exactly 1 char
 * to current frag.
 */
/* JF changed < 1 to <= 1 to avoid a race conditon */
#define FRAG_APPEND_1_CHAR(datum)	\
{					\
  if (obstack_room( &frags ) <= 1) {\
    frag_wane (frag_now);	\
    frag_new (0);		\
  }				\
  obstack_1grow( &frags, datum );	\
a129 1

d139 1
@


1.1
log
@Initial revision
@
text
@d2 2
a3 2

   Copyright (C) 1987, 1992 Free Software Foundation, Inc.
d18 93
a110 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d133 1
d136 1
a136 1
void frag_align PARAMS ((int alignment, int fill_character));
d139 2
a140 1
				 int n_fill));
d149 1
a149 1
			    long offset,
d157 1
a157 1
			long offset,
d160 1
a160 1
/* end of frags.h */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 2
a3 1
   Copyright (C) 1987, 92, 93, 94, 95, 1997 Free Software Foundation, Inc.
d18 2
a19 7
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#ifdef ANSI_PROTOTYPES
struct obstack;
#endif
a41 1
fragS *frag_alloc PARAMS ((struct obstack *));
d44 1
a44 1
void frag_align PARAMS ((int alignment, int fill_character, int max));
d47 1
a47 2
				 int n_fill,
				 int max));
d56 1
a56 1
			    offsetT offset,
d64 1
a64 1
			offsetT offset,
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1987, 92, 93, 94, 95, 97, 98, 99, 2000
   Free Software Foundation, Inc.
a20 3
#ifndef FRAGS_H
#define FRAGS_H

a24 83
/*
 * A code fragment (frag) is some known number of chars, followed by some
 * unknown number of chars. Typically the unknown number of chars is an
 * instruction address whose size is yet unknown. We always know the greatest
 * possible size the unknown number of chars may become, and reserve that
 * much room at the end of the frag.
 * Once created, frags do not change address during assembly.
 * We chain the frags in (a) forward-linked list(s). The object-file address
 * of the 1st char of a frag is generally not known until after relax().
 * Many things at assembly time describe an address by {object-file-address
 * of a particular frag}+offset.

 BUG: it may be smarter to have a single pointer off to various different
 notes for different frag kinds. See how code pans
 */

struct frag
{
  /* Object file address (as an octet offset). */
  addressT fr_address;
  /* Chain forward; ascending address order.  Rooted in frch_root. */
  struct frag *fr_next;

  /* (Fixed) number of octets we know we have.  May be 0. */
  offsetT fr_fix;
  /* May be used for (Variable) number of octets after above.
     The generic frag handling code no longer makes any use of fr_var.  */
  offsetT fr_var;
  /* For variable-length tail. */
  symbolS *fr_symbol;
  /* For variable-length tail. */
  offsetT fr_offset;
  /* Points to opcode low addr byte, for relaxation.  */
  char *fr_opcode;

#ifndef NO_LISTING
  struct list_info_struct *line;
#endif

  /* What state is my tail in? */
  relax_stateT fr_type;
  relax_substateT fr_subtype;

#ifdef USING_CGEN
  /* Don't include this unless using CGEN to keep frag size down.  */
  struct {
    /* CGEN_INSN entry for this instruction.  */
    const struct cgen_insn *insn;
    /* Index into operand table.  */
    int opindex;
    /* Target specific data, usually reloc number.  */
    int opinfo;
  } fr_cgen;
#endif

#ifdef TC_FRAG_TYPE
  TC_FRAG_TYPE tc_frag_data;
#endif

  /* Where the frag was created, or where it became a variant frag.  */
  char *fr_file;
  unsigned int fr_line;

  /* Data begins here.  */
  char fr_literal[1];
};

#define SIZEOF_STRUCT_FRAG \
((char *)zero_address_frag.fr_literal-(char *)&zero_address_frag)
/* We want to say fr_literal[0] above. */

/* Current frag we are building.  This frag is incomplete.  It is,
   however, included in frchain_now.  The fr_fix field is bogus;
   instead, use frag_now_fix ().  */
COMMON fragS *frag_now;
extern addressT frag_now_fix PARAMS ((void));
extern addressT frag_now_fix_octets PARAMS ((void));

/* For foreign-segment symbol fixups. */
COMMON fragS zero_address_frag;
/* For local common (N_BSS segment) fixups. */
COMMON fragS bss_address_frag;

d73 1
a73 1
#endif /* FRAGS_H */
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1987, 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001
d29 19
a47 16
/* A code fragment (frag) is some known number of chars, followed by some
   unknown number of chars. Typically the unknown number of chars is an
   instruction address whose size is yet unknown. We always know the greatest
   possible size the unknown number of chars may become, and reserve that
   much room at the end of the frag.
   Once created, frags do not change address during assembly.
   We chain the frags in (a) forward-linked list(s). The object-file address
   of the 1st char of a frag is generally not known until after relax().
   Many things at assembly time describe an address by {object-file-address
   of a particular frag}+offset.

   BUG: it may be smarter to have a single pointer off to various different
   notes for different frag kinds.  See how code pans.   */

struct frag {
  /* Object file address (as an octet offset).  */
d49 1
a49 1
  /* Chain forward; ascending address order.  Rooted in frch_root.  */
d52 1
a52 1
  /* (Fixed) number of octets we know we have.  May be 0.  */
d57 1
a57 1
  /* For variable-length tail.  */
d59 1
a59 1
  /* For variable-length tail.  */
a67 4
  /* Flipped each relax pass so we can easily determine whether
     fr_address has been adjusted.  */
  unsigned int relax_marker:1;

d97 2
a98 2
((char *) zero_address_frag.fr_literal - (char *) &zero_address_frag)
/* We want to say fr_literal[0] above.  */
d107 1
a107 1
/* For foreign-segment symbol fixups.  */
d109 1
a109 1
/* For local common (N_BSS segment) fixups.  */
d113 12
a124 10
/* A macro to speed up appending exactly 1 char to current frag.  */
/* JF changed < 1 to <= 1 to avoid a race conditon.  */
#define FRAG_APPEND_1_CHAR(datum)			\
{							\
  if (obstack_room (&frags) <= 1)			\
    {							\
      frag_wane (frag_now);				\
      frag_new (0);					\
    }							\
  obstack_1grow (&frags, datum);			\
d131 1
a140 1
void frag_align_code PARAMS ((int alignment, int max));
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d41 1
a41 1
   notes for different frag kinds.  See how code pans.  */
d46 2
a47 3
  /* When relaxing multiple times, remember the address the frag had
     in the last relax pass.  */
  addressT last_fr_address;
d55 2
a57 2
  /* For variable-length tail.  */
  symbolS *fr_symbol;
a60 7
  /* Chain forward; ascending address order.  Rooted in frch_root.  */
  struct frag *fr_next;

  /* Where the frag was created, or where it became a variant frag.  */
  char *fr_file;
  unsigned int fr_line;

d88 4
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d109 2
a110 2
extern addressT frag_now_fix (void);
extern addressT frag_now_fix_octets (void);
d119 1
a119 1
/* JF changed < 1 to <= 1 to avoid a race condition.  */
d130 1
a130 1
extern void frag_append_1_char (int);
d134 12
a145 11
void frag_init (void);
fragS *frag_alloc (struct obstack *);
void frag_grow (unsigned int nchars);
char *frag_more (int nchars);
void frag_align (int alignment, int fill_character, int max);
void frag_align_pattern (int alignment, const char *fill_pattern,
			 int n_fill, int max);
void frag_align_code (int alignment, int max);
void frag_new (int old_frags_var_max_size);
void frag_wane (fragS * fragP);
int frag_room (void);
d147 7
a153 7
char *frag_variant (relax_stateT type,
		    int max_chars,
		    int var,
		    relax_substateT subtype,
		    symbolS * symbol,
		    offsetT offset,
		    char *opcode);
d155 7
a161 7
char *frag_var (relax_stateT type,
		int max_chars,
		int var,
		relax_substateT subtype,
		symbolS * symbol,
		offsetT offset,
		char *opcode);
@


