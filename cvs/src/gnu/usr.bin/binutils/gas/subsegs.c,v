head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.25;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.44;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.04.56;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.46;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.45;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.45;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.47;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.43.49;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.22.18;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.46.15;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.32.30;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.26;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.44;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* subsegs.c - subsegments -
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2002
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Segments & sub-segments.  */

#include "as.h"

#include "subsegs.h"
#include "obstack.h"

frchainS *frchain_root, *frchain_now;

static struct obstack frchains;

#ifndef BFD_ASSEMBLER
#ifdef MANY_SEGMENTS
segment_info_type segment_info[SEG_MAXIMUM_ORDINAL];

#else
/* Commented in "subsegs.h".  */
frchainS *data0_frchainP, *bss0_frchainP;

#endif /* MANY_SEGMENTS */
char const *const seg_name[] = {
  "absolute",
#ifdef MANY_SEGMENTS
  "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9",
  "e10", "e11", "e12", "e13", "e14", "e15", "e16", "e17", "e18", "e19",
  "e20", "e21", "e22", "e23", "e24", "e25", "e26", "e27", "e28", "e29",
  "e30", "e31", "e32", "e33", "e34", "e35", "e36", "e37", "e38", "e39",
#else
  "text",
  "data",
  "bss",
#endif /* MANY_SEGMENTS */
  "unknown",
  "ASSEMBLER-INTERNAL-LOGIC-ERROR!",
  "expr",
  "debug",
  "transfert vector preload",
  "transfert vector postload",
  "register",
  "",
};				/* Used by error reporters, dumpers etc.  */
#else /* BFD_ASSEMBLER */

/* Gas segment information for bfd_abs_section_ptr and
   bfd_und_section_ptr.  */
static segment_info_type *abs_seg_info;
static segment_info_type *und_seg_info;

#endif /* BFD_ASSEMBLER */

static void subseg_set_rest (segT, subsegT);

static fragS dummy_frag;

static frchainS absolute_frchain;

void
subsegs_begin (void)
{
  /* Check table(s) seg_name[], seg_N_TYPE[] is in correct order */
#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
  know (SEG_ABSOLUTE == 0);
  know (SEG_TEXT == 1);
  know (SEG_DATA == 2);
  know (SEG_BSS == 3);
  know (SEG_UNKNOWN == 4);
  know (SEG_GOOF == 5);
  know (SEG_EXPR == 6);
  know (SEG_DEBUG == 7);
  know (SEG_NTV == 8);
  know (SEG_PTV == 9);
  know (SEG_REGISTER == 10);
  know (SEG_MAXIMUM_ORDINAL == SEG_REGISTER);
#endif

  obstack_begin (&frchains, chunksize);
#if __GNUC__ >= 2
  obstack_alignment_mask (&frchains) = __alignof__ (frchainS) - 1;
#endif

  frchain_root = NULL;
  frchain_now = NULL;		/* Warn new_subseg() that we are booting.  */

  frag_now = &dummy_frag;

#ifndef BFD_ASSEMBLER
  now_subseg = 42;		/* Lie for 1st call to subseg_new.  */
#ifdef MANY_SEGMENTS
  {
    int i;
    for (i = SEG_E0; i < SEG_UNKNOWN; i++)
      {
	subseg_set (i, 0);
	segment_info[i].frchainP = frchain_now;
      }
  }
#else
  subseg_set (SEG_DATA, 0);	/* .data 0 */
  data0_frchainP = frchain_now;

  subseg_set (SEG_BSS, 0);
  bss0_frchainP = frchain_now;

#endif /* ! MANY_SEGMENTS */
#endif /* ! BFD_ASSEMBLER */

  absolute_frchain.frch_seg = absolute_section;
  absolute_frchain.frch_subseg = 0;
#ifdef BFD_ASSEMBLER
  absolute_frchain.fix_root = absolute_frchain.fix_tail = 0;
#endif
  absolute_frchain.frch_frag_now = &zero_address_frag;
  absolute_frchain.frch_root = absolute_frchain.frch_last = &zero_address_frag;
}

/*
 *			subseg_change()
 *
 * Change the subsegment we are in, BUT DO NOT MAKE A NEW FRAG for the
 * subsegment. If we are already in the correct subsegment, change nothing.
 * This is used eg as a worker for subseg_set [which does make a new frag_now]
 * and for changing segments after we have read the source. We construct eg
 * fixSs even after the source file is read, so we do have to keep the
 * segment context correct.
 */
void
subseg_change (register segT seg, register int subseg)
{
  now_seg = seg;
  now_subseg = subseg;

  if (now_seg == absolute_section)
    return;

#ifdef BFD_ASSEMBLER
  {
    segment_info_type *seginfo;
    seginfo = (segment_info_type *) bfd_get_section_userdata (stdoutput, seg);
    if (! seginfo)
      {
	seginfo = (segment_info_type *) xmalloc (sizeof (*seginfo));
	memset ((PTR) seginfo, 0, sizeof (*seginfo));
	seginfo->fix_root = NULL;
	seginfo->fix_tail = NULL;
	seginfo->bfd_section = seg;
	seginfo->sym = 0;
	if (seg == bfd_abs_section_ptr)
	  abs_seg_info = seginfo;
	else if (seg == bfd_und_section_ptr)
	  und_seg_info = seginfo;
	else
	  bfd_set_section_userdata (stdoutput, seg, (PTR) seginfo);
      }
  }
#else
#ifdef MANY_SEGMENTS
  seg_fix_rootP = &segment_info[seg].fix_root;
  seg_fix_tailP = &segment_info[seg].fix_tail;
#else
  if (seg == SEG_DATA)
    {
      seg_fix_rootP = &data_fix_root;
      seg_fix_tailP = &data_fix_tail;
    }
  else if (seg == SEG_TEXT)
    {
      seg_fix_rootP = &text_fix_root;
      seg_fix_tailP = &text_fix_tail;
    }
  else
    {
      know (seg == SEG_BSS);
      seg_fix_rootP = &bss_fix_root;
      seg_fix_tailP = &bss_fix_tail;
    }

#endif
#endif
}

static void
subseg_set_rest (segT seg, subsegT subseg)
{
  register frchainS *frcP;	/* crawl frchain chain */
  register frchainS **lastPP;	/* address of last pointer */
  frchainS *newP;		/* address of new frchain */

  mri_common_symbol = NULL;

  if (frag_now && frchain_now)
    frchain_now->frch_frag_now = frag_now;

  assert (frchain_now == 0
	  || now_seg == undefined_section
	  || now_seg == absolute_section
	  || frchain_now->frch_last == frag_now);

  subseg_change (seg, (int) subseg);

  if (seg == absolute_section)
    {
      frchain_now = &absolute_frchain;
      frag_now = &zero_address_frag;
      return;
    }

  assert (frchain_now == 0
	  || now_seg == undefined_section
	  || frchain_now->frch_last == frag_now);

  /*
   * Attempt to find or make a frchain for that sub seg.
   * Crawl along chain of frchainSs, begins @@ frchain_root.
   * If we need to make a frchainS, link it into correct
   * position of chain rooted in frchain_root.
   */
  for (frcP = *(lastPP = &frchain_root);
       frcP && frcP->frch_seg <= seg;
       frcP = *(lastPP = &frcP->frch_next))
    {
      if (frcP->frch_seg == seg
	  && frcP->frch_subseg >= subseg)
	{
	  break;
	}
    }
  /*
   * frcP:		Address of the 1st frchainS in correct segment with
   *		frch_subseg >= subseg.
   *		We want to either use this frchainS, or we want
   *		to insert a new frchainS just before it.
   *
   *		If frcP==NULL, then we are at the end of the chain
   *		of frchainS-s. A NULL frcP means we fell off the end
   *		of the chain looking for a
   *		frch_subseg >= subseg, so we
   *		must make a new frchainS.
   *
   *		If we ever maintain a pointer to
   *		the last frchainS in the chain, we change that pointer
   *		ONLY when frcP==NULL.
   *
   * lastPP:	Address of the pointer with value frcP;
   *		Never NULL.
   *		May point to frchain_root.
   *
   */
  if (!frcP
      || (frcP->frch_seg > seg
	  || frcP->frch_subseg > subseg))	/* Kinky logic only works with 2 segments.  */
    {
      /*
       * This should be the only code that creates a frchainS.
       */
      newP = (frchainS *) obstack_alloc (&frchains, sizeof (frchainS));
      newP->frch_subseg = subseg;
      newP->frch_seg = seg;
#ifdef BFD_ASSEMBLER
      newP->fix_root = NULL;
      newP->fix_tail = NULL;
#endif
      obstack_begin (&newP->frch_obstack, chunksize);
#if __GNUC__ >= 2
      obstack_alignment_mask (&newP->frch_obstack) = __alignof__ (fragS) - 1;
#endif
      newP->frch_frag_now = frag_alloc (&newP->frch_obstack);
      newP->frch_frag_now->fr_type = rs_fill;

      newP->frch_root = newP->frch_last = newP->frch_frag_now;

      *lastPP = newP;
      newP->frch_next = frcP;	/* perhaps NULL */

#ifdef BFD_ASSEMBLER
      {
	segment_info_type *seginfo;
	seginfo = seg_info (seg);
	if (seginfo && seginfo->frchainP == frcP)
	  seginfo->frchainP = newP;
      }
#endif

      frcP = newP;
    }
  /*
   * Here with frcP pointing to the frchainS for subseg.
   */
  frchain_now = frcP;
  frag_now = frcP->frch_frag_now;

  assert (frchain_now->frch_last == frag_now);
}

/*
 *			subseg_set(segT, subsegT)
 *
 * If you attempt to change to the current subsegment, nothing happens.
 *
 * In:	segT, subsegT code for new subsegment.
 *	frag_now -> incomplete frag for current subsegment.
 *	If frag_now==NULL, then there is no old, incomplete frag, so
 *	the old frag is not closed off.
 *
 * Out:	now_subseg, now_seg updated.
 *	Frchain_now points to the (possibly new) struct frchain for this
 *	sub-segment.
 *	Frchain_root updated if needed.
 */

#ifndef BFD_ASSEMBLER

segT
subseg_new (segname, subseg)
     const char *segname;
     subsegT subseg;
{
  int i;

  for (i = 0; i < (int) SEG_MAXIMUM_ORDINAL; i++)
    {
      const char *s;

      s = segment_name ((segT) i);
      if (strcmp (segname, s) == 0
	  || (segname[0] == '.'
	      && strcmp (segname + 1, s) == 0))
	{
	  subseg_set ((segT) i, subseg);
	  return (segT) i;
	}
#ifdef obj_segment_name
      s = obj_segment_name ((segT) i);
      if (strcmp (segname, s) == 0
	  || (segname[0] == '.'
	      && strcmp (segname + 1, s) == 0))
	{
	  subseg_set ((segT) i, subseg);
	  return (segT) i;
	}
#endif
    }

#ifdef obj_add_segment
  {
    segT new_seg;
    new_seg = obj_add_segment (segname);
    subseg_set (new_seg, subseg);
    return new_seg;
  }
#else
  as_bad (_("attempt to switch to nonexistent segment \"%s\""), segname);
  return now_seg;
#endif
}

void
subseg_set (seg, subseg)	/* begin assembly for a new sub-segment */
     register segT seg;		/* SEG_DATA or SEG_TEXT */
     register subsegT subseg;
{
#ifndef MANY_SEGMENTS
  know (seg == SEG_DATA
	|| seg == SEG_TEXT
	|| seg == SEG_BSS
	|| seg == SEG_ABSOLUTE);
#endif

  if (seg != now_seg || subseg != now_subseg)
    {				/* we just changed sub-segments */
      subseg_set_rest (seg, subseg);
    }
  mri_common_symbol = NULL;
}

#else /* BFD_ASSEMBLER */

segT
subseg_get (const char *segname, int force_new)
{
  segT secptr;
  segment_info_type *seginfo;
  const char *now_seg_name = (now_seg
			      ? bfd_get_section_name (stdoutput, now_seg)
			      : 0);

  if (!force_new
      && now_seg_name
      && (now_seg_name == segname
	  || !strcmp (now_seg_name, segname)))
    return now_seg;

  if (!force_new)
    secptr = bfd_make_section_old_way (stdoutput, segname);
  else
    secptr = bfd_make_section_anyway (stdoutput, segname);

#ifdef obj_sec_set_private_data
  obj_sec_set_private_data (stdoutput, secptr);
#endif

  seginfo = seg_info (secptr);
  if (! seginfo)
    {
      /* Check whether output_section is set first because secptr may
	 be bfd_abs_section_ptr.  */
      if (secptr->output_section != secptr)
	secptr->output_section = secptr;
      seginfo = (segment_info_type *) xmalloc (sizeof (*seginfo));
      memset ((PTR) seginfo, 0, sizeof (*seginfo));
      seginfo->fix_root = NULL;
      seginfo->fix_tail = NULL;
      seginfo->bfd_section = secptr;
      if (secptr == bfd_abs_section_ptr)
	abs_seg_info = seginfo;
      else if (secptr == bfd_und_section_ptr)
	und_seg_info = seginfo;
      else
	bfd_set_section_userdata (stdoutput, secptr, (PTR) seginfo);
      seginfo->frchainP = NULL;
      seginfo->lineno_list_head = seginfo->lineno_list_tail = NULL;
      seginfo->sym = NULL;
      seginfo->dot = NULL;
    }
  return secptr;
}

segT
subseg_new (const char *segname, subsegT subseg)
{
  segT secptr;
  segment_info_type *seginfo;

  secptr = subseg_get (segname, 0);
  subseg_set_rest (secptr, subseg);
  seginfo = seg_info (secptr);
  if (! seginfo->frchainP)
    seginfo->frchainP = frchain_now;
  return secptr;
}

/* Like subseg_new, except a new section is always created, even if
   a section with that name already exists.  */
segT
subseg_force_new (const char *segname, subsegT subseg)
{
  segT secptr;
  segment_info_type *seginfo;

  secptr = subseg_get (segname, 1);
  subseg_set_rest (secptr, subseg);
  seginfo = seg_info (secptr);
  if (! seginfo->frchainP)
    seginfo->frchainP = frchain_now;
  return secptr;
}

void
subseg_set (segT secptr, subsegT subseg)
{
  if (! (secptr == now_seg && subseg == now_subseg))
    subseg_set_rest (secptr, subseg);
  mri_common_symbol = NULL;
}

#ifndef obj_sec_sym_ok_for_reloc
#define obj_sec_sym_ok_for_reloc(SEC)	0
#endif

/* Get the gas information we are storing for a section.  */

segment_info_type *
seg_info (segT sec)
{
  if (sec == bfd_abs_section_ptr)
    return abs_seg_info;
  else if (sec == bfd_und_section_ptr)
    return und_seg_info;
  else
    return (segment_info_type *) bfd_get_section_userdata (stdoutput, sec);
}

symbolS *
section_symbol (segT sec)
{
  segment_info_type *seginfo = seg_info (sec);
  symbolS *s;

  if (seginfo == 0)
    abort ();
  if (seginfo->sym)
    return seginfo->sym;

#ifndef EMIT_SECTION_SYMBOLS
#define EMIT_SECTION_SYMBOLS 1
#endif

  if (! EMIT_SECTION_SYMBOLS || symbol_table_frozen)
    {
      /* Here we know it won't be going into the symbol table.  */
      s = symbol_create (sec->symbol->name, sec, 0, &zero_address_frag);
    }
  else
    {
      s = symbol_find_base (sec->symbol->name, 0);
      if (s == NULL)
	s = symbol_new (sec->symbol->name, sec, 0, &zero_address_frag);
      else
	{
	  if (S_GET_SEGMENT (s) == undefined_section)
	    {
	      S_SET_SEGMENT (s, sec);
	      symbol_set_frag (s, &zero_address_frag);
	    }
	}
    }

  S_CLEAR_EXTERNAL (s);

  /* Use the BFD section symbol, if possible.  */
  if (obj_sec_sym_ok_for_reloc (sec))
    symbol_set_bfdsym (s, sec->symbol);
  else
    symbol_get_bfdsym (s)->flags |= BSF_SECTION_SYM;

  seginfo->sym = s;
  return s;
}

#endif /* BFD_ASSEMBLER */

/* Return whether the specified segment is thought to hold text.  */

#ifndef BFD_ASSEMBLER
const char * const nontext_section_names[] = {
  ".eh_frame",
  ".gcc_except_table",
#ifdef OBJ_COFF
#ifndef COFF_LONG_SECTION_NAMES
  ".eh_fram",
  ".gcc_exc",
#endif
#endif
  NULL
};
#endif /* ! BFD_ASSEMBLER */

int
subseg_text_p (segT sec)
{
#ifdef BFD_ASSEMBLER
  return (bfd_get_section_flags (stdoutput, sec) & SEC_CODE) != 0;
#else /* ! BFD_ASSEMBLER */
  const char * const *p;

  if (sec == data_section || sec == bss_section || sec == absolute_section)
    return 0;

  for (p = nontext_section_names; *p != NULL; ++p)
    {
      if (strcmp (segment_name (sec), *p) == 0)
	return 0;

#ifdef obj_segment_name
      if (strcmp (obj_segment_name (sec), *p) == 0)
	return 0;
#endif
    }

  return 1;

#endif /* ! BFD_ASSEMBLER */
}

void
subsegs_print_statistics (FILE *file)
{
  frchainS *frchp;
  fprintf (file, "frag chains:\n");
  for (frchp = frchain_root; frchp; frchp = frchp->frch_next)
    {
      int count = 0;
      fragS *fragp;

      /* If frch_subseg is non-zero, it's probably been chained onto
	 the end of a previous subsection.  Don't count it again.  */
      if (frchp->frch_subseg != 0)
	continue;

      /* Skip gas-internal sections.  */
      if (segment_name (frchp->frch_seg)[0] == '*')
	continue;

      for (fragp = frchp->frch_root; fragp; fragp = fragp->fr_next)
	{
#if 0
	  switch (fragp->fr_type)
	    {
	    case rs_fill:
	      fprintf (file, "f"); break;
	    case rs_align:
	      fprintf (file, "a"); break;
	    case rs_align_code:
	      fprintf (file, "c"); break;
	    case rs_org:
	      fprintf (file, "o"); break;
	    case rs_machine_dependent:
	      fprintf (file, "m"); break;
	    case rs_space:
	      fprintf (file, "s"); break;
	    case 0:
	      fprintf (file, "0"); break;
	    default:
	      fprintf (file, "?"); break;
	    }
#endif
	  count++;
	}
      fprintf (file, "\n");
      fprintf (file, "\t%p %-10s\t%10d frags\n", (void *) frchp,
	       segment_name (frchp->frch_seg), count);
    }
}

/* end of subsegs.c */
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d73 1
a73 1
static void subseg_set_rest PARAMS ((segT, subsegT));
d80 1
a80 1
subsegs_begin ()
d149 1
a149 3
subseg_change (seg, subseg)
     register segT seg;
     register int subseg;
d204 1
a204 3
subseg_set_rest (seg, subseg)
     segT seg;
     subsegT subseg;
d400 1
a400 3
subseg_get (segname, force_new)
     const char *segname;
     int force_new;
d419 4
d450 1
a450 3
subseg_new (segname, subseg)
     const char *segname;
     subsegT subseg;
d466 1
a466 3
subseg_force_new (segname, subseg)
     const char *segname;
     subsegT subseg;
d480 1
a480 3
subseg_set (secptr, subseg)
     segT secptr;
     subsegT subseg;
d494 1
a494 2
seg_info (sec)
     segT sec;
d505 1
a505 2
section_symbol (sec)
     segT sec;
d570 1
a570 2
subseg_text_p (sec)
     segT sec;
d597 1
a597 2
subsegs_print_statistics (file)
     FILE *file;
@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   1999, 2000
d377 1
a377 1
  as_bad (_("Attempt to switch to nonexistent segment \"%s\""), segname);
d429 1
a429 1
         be bfd_abs_section_ptr.  */
d529 1
a529 5
  if (! EMIT_SECTION_SYMBOLS
#ifdef BFD_ASSEMBLER
      || symbol_table_frozen
#endif
      )
d532 1
a532 1
      s = symbol_create (sec->name, sec, 0, &zero_address_frag);
d536 1
a536 1
      s = symbol_find_base (sec->name, 0);
d538 1
a538 1
	s = symbol_new (sec->name, sec, 0, &zero_address_frag);
d554 2
d588 1
a588 1
  if (sec == data_section || sec == bss_section)
d653 1
a653 1
      fprintf (file, "\t%p %-10s\t%10d frags\n", frchp,
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d23 1
a23 3
/*
 * Segments & sub-segments.
 */
d39 1
a39 1
/* Commented in "subsegs.h". */
d43 1
a43 2
char const *const seg_name[] =
{
d63 1
a63 1
};				/* Used by error reporters, dumpers etc. */
d104 1
a104 1
  frchain_now = NULL;		/* Warn new_subseg() that we are booting. */
d109 1
a109 1
  now_subseg = 42;		/* Lie for 1st call to subseg_new. */
d276 1
a276 1
	  || frcP->frch_subseg > subseg))	/* Kinky logic only works with 2 segments. */
d308 1
a308 1
      
d568 1
a568 2
const char * const nontext_section_names[] =
{
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996
a282 1
      extern fragS *frag_alloc ();
d290 1
a290 1
      obstack_begin (&newP->frch_obstack, 5000);
d301 10
d379 1
a379 1
  as_bad ("Attempt to switch to nonexistent segment \"%s\"", segname);
d536 4
a539 2
    /* Here we know it won't be going into the symbol table.  */
    s = symbol_create (sec->name, sec, 0, &zero_address_frag);
d541 14
a554 1
    s = symbol_new (sec->name, sec, 0, &zero_address_frag);
d559 1
a559 1
    s->bsym = sec->symbol;
d566 45
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1990, 1991, 1992, 1993, 1994
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a211 1
  long tmp;			/* JF for obstack alignment hacking */
a214 2
  register fragS *former_last_fragP;
  register fragS *new_fragP;
d524 1
a524 1
      && symbol_table_frozen
@


1.1
log
@Initial revision
@
text
@d48 3
d519 1
a519 3
  s = symbol_find (sec->name);
  if (!s)
    {
d524 1
a524 1
      if (! EMIT_SECTION_SYMBOLS
d526 1
a526 1
	  && symbol_table_frozen
d528 10
a537 6
	  )
	/* Here we know it won't be going into the symbol table.  */
	s = symbol_create (sec->name, sec, 0, &zero_address_frag);
      else
	s = symbol_new (sec->name, sec, 0, &zero_address_frag);
      S_CLEAR_EXTERNAL (s);
a538 4
      /* Use the BFD section symbol, if possible.  */
      if (obj_sec_sym_ok_for_reloc (sec))
	s->bsym = sec->symbol;
    }
d544 51
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@a47 3
  "e10", "e11", "e12", "e13", "e14", "e15", "e16", "e17", "e18", "e19",
  "e20", "e21", "e22", "e23", "e24", "e25", "e26", "e27", "e28", "e29",
  "e30", "e31", "e32", "e33", "e34", "e35", "e36", "e37", "e38", "e39",
d516 3
a518 1

d523 1
a523 1
  if (! EMIT_SECTION_SYMBOLS
d525 1
a525 1
      && symbol_table_frozen
d527 6
a532 10
      )
    /* Here we know it won't be going into the symbol table.  */
    s = symbol_create (sec->name, sec, 0, &zero_address_frag);
  else
    s = symbol_new (sec->name, sec, 0, &zero_address_frag);
  S_CLEAR_EXTERNAL (s);

  /* Use the BFD section symbol, if possible.  */
  if (obj_sec_sym_ok_for_reloc (sec))
    s->bsym = sec->symbol;
d534 4
a542 51

void
subsegs_print_statistics (file)
     FILE *file;
{
  frchainS *frchp;
  fprintf (file, "frag chains:\n");
  for (frchp = frchain_root; frchp; frchp = frchp->frch_next)
    {
      int count = 0;
      fragS *fragp;

      /* If frch_subseg is non-zero, it's probably been chained onto
	 the end of a previous subsection.  Don't count it again.  */
      if (frchp->frch_subseg != 0)
	continue;

      /* Skip gas-internal sections.  */
      if (segment_name (frchp->frch_seg)[0] == '*')
	continue;

      for (fragp = frchp->frch_root; fragp; fragp = fragp->fr_next)
	{
#if 0
	  switch (fragp->fr_type)
	    {
	    case rs_fill:
	      fprintf (file, "f"); break;
	    case rs_align:
	      fprintf (file, "a"); break;
	    case rs_align_code:
	      fprintf (file, "c"); break;
	    case rs_org:
	      fprintf (file, "o"); break;
	    case rs_machine_dependent:
	      fprintf (file, "m"); break;
	    case rs_space:
	      fprintf (file, "s"); break;
	    case 0:
	      fprintf (file, "0"); break;
	    default:
	      fprintf (file, "?"); break;
	    }
#endif
	  count++;
	}
      fprintf (file, "\n");
      fprintf (file, "\t%p %-10s\t%10d frags\n", frchp,
	       segment_name (frchp->frch_seg), count);
    }
}
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996
d18 2
a19 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d211 1
d215 2
d526 1
a526 1
      || symbol_table_frozen
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1997
d283 1
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d290 1
a290 1
      obstack_begin (&newP->frch_obstack, chunksize);
a300 10

#ifdef BFD_ASSEMBLER
      {
	segment_info_type *seginfo;
	seginfo = seg_info (seg);
	if (seginfo && seginfo->frchainP == frcP)
	  seginfo->frchainP = newP;
      }
#endif
      
d369 1
a369 1
  as_bad (_("Attempt to switch to nonexistent segment \"%s\""), segname);
d526 2
a527 4
    {
      /* Here we know it won't be going into the symbol table.  */
      s = symbol_create (sec->name, sec, 0, &zero_address_frag);
    }
d529 1
a529 14
    {
      s = symbol_find_base (sec->name, 0);
      if (s == NULL)
	s = symbol_new (sec->name, sec, 0, &zero_address_frag);
      else
	{
	  if (S_GET_SEGMENT (s) == undefined_section)
	    {
	      S_SET_SEGMENT (s, sec);
	      symbol_set_frag (s, &zero_address_frag);
	    }
	}
    }

d534 1
a534 1
    symbol_set_bfdsym (s, sec->symbol);
a540 45

/* Return whether the specified segment is thought to hold text.  */

#ifndef BFD_ASSEMBLER
const char * const nontext_section_names[] =
{
  ".eh_frame",
  ".gcc_except_table",
#ifdef OBJ_COFF
#ifndef COFF_LONG_SECTION_NAMES
  ".eh_fram",
  ".gcc_exc",
#endif
#endif
  NULL
};
#endif /* ! BFD_ASSEMBLER */

int
subseg_text_p (sec)
     segT sec;
{
#ifdef BFD_ASSEMBLER
  return (bfd_get_section_flags (stdoutput, sec) & SEC_CODE) != 0;
#else /* ! BFD_ASSEMBLER */
  const char * const *p;

  if (sec == data_section || sec == bss_section)
    return 0;

  for (p = nontext_section_names; *p != NULL; ++p)
    {
      if (strcmp (segment_name (sec), *p) == 0)
	return 0;

#ifdef obj_segment_name
      if (strcmp (obj_segment_name (sec), *p) == 0)
	return 0;
#endif
    }

  return 1;

#endif /* ! BFD_ASSEMBLER */
}
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000
d22 3
a24 1
/* Segments & sub-segments.  */
d40 1
a40 1
/* Commented in "subsegs.h".  */
d44 2
a45 1
char const *const seg_name[] = {
d65 1
a65 1
};				/* Used by error reporters, dumpers etc.  */
d106 1
a106 1
  frchain_now = NULL;		/* Warn new_subseg() that we are booting.  */
d111 1
a111 1
  now_subseg = 42;		/* Lie for 1st call to subseg_new.  */
d278 1
a278 1
	  || frcP->frch_subseg > subseg))	/* Kinky logic only works with 2 segments.  */
d310 1
a310 1

d570 2
a571 1
const char * const nontext_section_names[] = {
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1999, 2000, 2002
d377 1
a377 1
  as_bad (_("attempt to switch to nonexistent segment \"%s\""), segname);
d429 1
a429 1
	 be bfd_abs_section_ptr.  */
d529 5
a533 1
  if (! EMIT_SECTION_SYMBOLS || symbol_table_frozen)
d536 1
a536 1
      s = symbol_create (sec->symbol->name, sec, 0, &zero_address_frag);
d540 1
a540 1
      s = symbol_find_base (sec->symbol->name, 0);
d542 1
a542 1
	s = symbol_new (sec->symbol->name, sec, 0, &zero_address_frag);
a557 2
  else
    symbol_get_bfdsym (s)->flags |= BSF_SECTION_SYM;
d590 1
a590 1
  if (sec == data_section || sec == bss_section || sec == absolute_section)
d655 1
a655 1
      fprintf (file, "\t%p %-10s\t%10d frags\n", (void *) frchp,
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d73 1
a73 1
static void subseg_set_rest (segT, subsegT);
d80 1
a80 1
subsegs_begin (void)
d149 3
a151 1
subseg_change (register segT seg, register int subseg)
d206 3
a208 1
subseg_set_rest (segT seg, subsegT subseg)
d404 3
a406 1
subseg_get (const char *segname, int force_new)
a424 4
#ifdef obj_sec_set_private_data
  obj_sec_set_private_data (stdoutput, secptr);
#endif

d452 3
a454 1
subseg_new (const char *segname, subsegT subseg)
d470 3
a472 1
subseg_force_new (const char *segname, subsegT subseg)
d486 3
a488 1
subseg_set (segT secptr, subsegT subseg)
d502 2
a503 1
seg_info (segT sec)
d514 2
a515 1
section_symbol (segT sec)
d580 2
a581 1
subseg_text_p (segT sec)
d608 2
a609 1
subsegs_print_statistics (FILE *file)
@


