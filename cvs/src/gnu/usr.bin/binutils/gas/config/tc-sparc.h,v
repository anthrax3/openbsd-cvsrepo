head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.48
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.44
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.46
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.38
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.42
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.40
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.36
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.34
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.32
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.30
	OPENBSD_5_0:1.11.0.28
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.26
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.24
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.20
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.22
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.18
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.16
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.14
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.12
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.8.0.8
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.7.0.16
	OPENBSD_2_7_BASE:1.7
	new-binutils:1.7.0.14
	OPENBSD_2_6:1.7.0.12
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.10
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2004.11.02.20.45.30;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.17.21.54.31;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.13.17.07.37;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.12.19.11.53;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	97.01.21.10.33.07;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.03.34.53;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.09.04.19.06.23;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.09.20.12.46;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.08.21.20.45;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.08.18.17.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.13;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.13;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.52;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.45.18;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.36;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.23.25;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.31;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.37.05;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.33;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-sparc.h - Macros and type defines for the sparc.
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2,
   or (at your option) any later version.

   GAS is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with GAS; see the file COPYING.  If not, write
   to the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#ifndef TC_SPARC
#define TC_SPARC 1

#ifdef ANSI_PROTOTYPES
struct frag;
#endif

/* This is used to set the default value for `target_big_endian'.  */
#define TARGET_BYTES_BIG_ENDIAN 1

#define LOCAL_LABELS_FB 1

#define TARGET_ARCH bfd_arch_sparc

extern const char *sparc_target_format PARAMS ((void));
#define TARGET_FORMAT sparc_target_format ()

#define RELOC_EXPANSION_POSSIBLE
#define MAX_RELOC_EXPANSION 2

#if 0
#ifdef TE_SPARCAOUT
/* Bi-endian support may eventually be unconditional, but until things are
   working well it's only provided for targets that need it.  */
#define SPARC_BIENDIAN
#endif
#endif
/* Make it unconditional and check if -EL is valid after option parsing */
#define SPARC_BIENDIAN

#define WORKING_DOT_WORD

#define md_convert_frag(b,s,f) \
  as_fatal (_("sparc convert_frag\n"))
#define md_estimate_size_before_relax(f,s) \
  (as_fatal (_("estimate_size_before_relax called")), 1)

#define LISTING_HEADER "SPARC GAS "

extern int sparc_pic_code;

/* We require .word, et. al., to be aligned correctly.  */
#define md_cons_align(nbytes) sparc_cons_align (nbytes)
extern void sparc_cons_align PARAMS ((int));

#define HANDLE_ALIGN(fragp) sparc_handle_align (fragp)
extern void sparc_handle_align PARAMS ((struct frag *));

#define MAX_MEM_FOR_RS_ALIGN_CODE  (3 + 4 + 4)

/* I know that "call 0" fails in sparc-coff if this doesn't return 1.  I
   don't know about other relocation types, or other formats, yet.  */
#ifdef OBJ_COFF
#define TC_FORCE_RELOCATION_ABS(FIX)		\
  ((FIX)->fx_r_type == BFD_RELOC_32_PCREL_S2	\
   || TC_FORCE_RELOCATION (FIX))

#define RELOC_REQUIRES_SYMBOL
#endif

#ifdef OBJ_AOUT
/* This expression evaluates to true if the relocation is for a local
   object for which we still want to do the relocation at runtime.
   False if we are willing to perform this relocation while building
   the .o file.  */

#define TC_FORCE_RELOCATION_LOCAL(FIX)		\
  (!(FIX)->fx_pcrel				\
   || (FIX)->fx_plt				\
   || (sparc_pic_code				\
       && S_IS_EXTERNAL ((FIX)->fx_addsy))	\
   || TC_FORCE_RELOCATION (FIX))
#endif

#ifdef OBJ_ELF
/* Don't turn certain relocs into relocations against sections.  This
   is required for the dynamic linker to operate properly.  When
   generating PIC, we need to keep any non PC relative reloc.  The PIC
   part of this test must be parallel to the code in tc_gen_reloc which
   converts relocations to GOT relocations.  */
#define tc_fix_adjustable(FIX)						\
  ((FIX)->fx_r_type != BFD_RELOC_VTABLE_INHERIT				\
   && (FIX)->fx_r_type != BFD_RELOC_VTABLE_ENTRY			\
   && ((FIX)->fx_r_type < BFD_RELOC_SPARC_TLS_GD_HI22			\
       || (FIX)->fx_r_type > BFD_RELOC_SPARC_TLS_TPOFF64)		\
   && (! sparc_pic_code							\
       || ((FIX)->fx_r_type != BFD_RELOC_HI22				\
	   && (FIX)->fx_r_type != BFD_RELOC_LO10			\
	   && (FIX)->fx_r_type != BFD_RELOC_SPARC13			\
	   && ((FIX)->fx_r_type != BFD_RELOC_32_PCREL_S2		\
	       || !generic_force_reloc (FIX))				\
	   && ((FIX)->fx_pcrel						\
	       || ((FIX)->fx_subsy != NULL				\
		   && (S_GET_SEGMENT ((FIX)->fx_subsy)			\
		       == S_GET_SEGMENT ((FIX)->fx_addsy)))		\
	       || S_IS_LOCAL ((FIX)->fx_addsy)))))

/* Values passed to md_apply_fix3 don't include the symbol value.  */
#define MD_APPLY_SYM_VALUE(FIX) 0

/* Finish up the entire symtab.  */
#define tc_adjust_symtab() sparc_adjust_symtab ()
extern void sparc_adjust_symtab PARAMS ((void));
#endif

#ifdef OBJ_AOUT
/* When generating PIC code, we must not adjust any reloc which will
   turn into a reloc against the global offset table, nor any reloc
   which we will need if a symbol is overridden.  */
#define tc_fix_adjustable(FIX)						\
  (! sparc_pic_code							\
   || ((FIX)->fx_pcrel							\
       && ((FIX)->fx_addsy == NULL					\
	   || (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
	       && ! S_IS_WEAK ((FIX)->fx_addsy))))			\
   || (FIX)->fx_r_type == BFD_RELOC_16					\
   || (FIX)->fx_r_type == BFD_RELOC_32)
#endif

#define elf_tc_final_processing sparc_elf_final_processing
extern void sparc_elf_final_processing PARAMS ((void));

#define md_operand(x)

extern void sparc_md_end PARAMS ((void));
#define md_end() sparc_md_end ()

#endif

#ifdef OBJ_ELF
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) sparc_cons (EXP, NBYTES)
extern void sparc_cons PARAMS ((expressionS *, int));
#endif

#define TC_CONS_FIX_NEW cons_fix_new_sparc
extern void cons_fix_new_sparc
  PARAMS ((struct frag *, int, unsigned int, struct expressionS *));

#define TC_FIX_TYPE	valueT

#define TC_INIT_FIX_DATA(X)			\
  do						\
     {						\
       (X)->tc_fix_data = 0;			\
     }						\
  while (0)

#define TC_FIX_DATA_PRINT(FILE, FIX)					\
  do									\
    {									\
      fprintf ((FILE), "addend2=%ld\n",   				\
	      (unsigned long) (FIX)->tc_fix_data);			\
    }									\
  while (0)

#define TARGET_USE_CFIPOP 1

#define tc_cfi_frame_initial_instructions sparc_cfi_frame_initial_instructions
extern void sparc_cfi_frame_initial_instructions PARAMS ((void));

#define tc_regname_to_dw2regnum sparc_regname_to_dw2regnum
extern int sparc_regname_to_dw2regnum PARAMS ((const char *regname));

#define tc_cfi_emit_pcrel_expr sparc_cfi_emit_pcrel_expr
extern void sparc_cfi_emit_pcrel_expr PARAMS ((expressionS *, unsigned int));

extern int sparc_cie_data_alignment;

#define DWARF2_LINE_MIN_INSN_LENGTH     4
#define DWARF2_DEFAULT_RETURN_COLUMN    15
#define DWARF2_CIE_DATA_ALIGNMENT       sparc_cie_data_alignment

/* end of tc-sparc.h */
@


1.10
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d177 16
a192 1
#define DWARF2_LINE_MIN_INSN_LENGTH 4
@


1.9
log
@resolve conflicts.
@
text
@d3 1
a3 1
   1999, 2000 Free Software Foundation, Inc.
d57 1
a57 1
  (as_fatal(_("estimate_size_before_relax called")), 1)
a71 26
#if defined (OBJ_ELF) || defined (OBJ_AOUT)

/* This expression evaluates to false if the relocation is for a local
   object for which we still want to do the relocation at runtime.
   True if we are willing to perform this relocation while building
   the .o file.

   If the reloc is against an externally visible symbol, then the
   a.out assembler should not do the relocation if generating PIC, and
   the ELF assembler should never do the relocation.  */

#ifdef OBJ_ELF
#define obj_relocate_extern 0
#else
#define obj_relocate_extern (! sparc_pic_code)
#endif

#define TC_RELOC_RTSYM_LOC_FIXUP(FIX)  \
  (obj_relocate_extern \
   || (FIX)->fx_addsy == NULL \
   || (! S_IS_EXTERNAL ((FIX)->fx_addsy) \
       && ! S_IS_WEAK ((FIX)->fx_addsy) \
       && S_IS_DEFINED ((FIX)->fx_addsy) \
       && ! S_IS_COMMON ((FIX)->fx_addsy)))
#endif

d75 4
a78 4
#define TC_FORCE_RELOCATION(FIXP)	\
	((FIXP)->fx_r_type == BFD_RELOC_32_PCREL_S2 \
	 && ((FIXP)->fx_addsy == 0 \
	     || S_GET_SEGMENT ((FIXP)->fx_addsy) == absolute_section))
d82 12
a93 3
#ifdef OBJ_ELF
#define TC_FORCE_RELOCATION(fixp) elf32_sparc_force_relocation(fixp)
extern int elf32_sparc_force_relocation PARAMS ((struct fix *));
a95 3
#define MD_APPLY_FIX3
#define TC_HANDLES_FX_DONE

d97 5
a101 6
/* Keep relocations against global symbols.  Don't turn them into
   relocations against sections.  This is required for the dynamic
   linker to operate properly.  When generating PIC, we need to keep
   any non PC relative reloc.  The PIC part of this test must be
   parallel to the code in tc_gen_reloc which converts relocations to
   GOT relocations.  */
d103 1
a103 3
  (! S_IS_EXTERNAL ((FIX)->fx_addsy)					\
   && ! S_IS_WEAK ((FIX)->fx_addsy)					\
   && (FIX)->fx_r_type != BFD_RELOC_VTABLE_INHERIT			\
d105 2
d112 1
a112 4
	       || (S_IS_DEFINED ((FIX)->fx_addsy)			\
		   && ! S_IS_COMMON ((FIX)->fx_addsy)			\
		   && ! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
		   && ! S_IS_WEAK ((FIX)->fx_addsy)))			\
d119 3
d151 5
d169 1
a169 1
#define TC_FIX_DATA_PRINT(FILE, FIXP)					\
d173 1
a173 1
	      (unsigned long) (FIXP)->tc_fix_data);			\
@


1.8
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1989, 90-96, 97, 98, 1999 Free Software Foundation, Inc.
d54 2
a55 1
#define md_convert_frag(b,s,f)		{as_fatal (_("sparc convert_frag\n"));}
d57 1
a57 1
			(as_fatal(_("estimate_size_before_relax called")),1)
a62 11
#define md_do_align(n, fill, len, max, around)				\
if ((n) && (n) <= 10 && !need_pass_2 && !(fill)				\
    && subseg_text_p (now_seg))						\
  {									\
    char *p;								\
    p = frag_var (rs_align_code, 1 << n, 1, (relax_substateT) 1024,	\
                  (symbolS *) 0, (offsetT) (n), (char *) 0);		\
    *p = 0x00;								\
    goto around;							\
  }

d66 1
d70 2
d183 1
a183 1
  while(0)
d188 1
a188 1
      fprintf((FILE), "addend2=%ld\n",   				\
d191 3
a193 1
  while(0)
@


1.7
log
@Clone NetBSD config for us, add handling of temporary local labels
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90-95, 1996 Free Software Foundation, Inc.
d21 1
d24 7
d35 5
a39 2
/* This is used to set the default value for `target_big_endian'.  */
#define TARGET_BYTES_BIG_ENDIAN 1
d41 1
a41 4
#ifdef OBJ_AOUT
#if defined(TE_NetBSD) || defined(TE_OpenBSD)
#define TARGET_FORMAT "a.out-sparc-netbsd"
#else
a42 2
extern int target_big_endian;
#define TARGET_FORMAT (target_big_endian ? "a.out-sunos-big" : "a.out-sparc-little")
a45 2
#else
#define TARGET_FORMAT "a.out-sunos-big"
d48 3
a50 12
#endif
#ifdef OBJ_BOUT
#define TARGET_FORMAT "b.out.big"
#endif
#ifdef OBJ_ELF
#ifdef SPARC_ARCH64
#define TARGET_FORMAT "elf64-sparc"
#else
#define TARGET_FORMAT "elf32-sparc"
#endif
#define LOCAL_LABEL(name)	(((name)[0] == '.' && (name)[1] == 'L') || !strncmp ((name), "_.L_", 4))
#endif
d53 1
a53 3
#define md_convert_frag(b,s,f)		{as_fatal ("sparc convert_frag\n");}
#define md_create_long_jump(p,f,t,fr,s)	as_fatal("sparc_create_long_jump")
#define md_create_short_jump(p,f,t,fr,s) as_fatal("sparc_create_short_jump")
d55 1
a55 2
			(as_fatal("estimate_size_before_relax called"),1)
void tc_aout_pre_write_hook ();
d61 11
d76 1
a76 1
extern void sparc_handle_align ();
d114 6
d126 26
a151 9
   any non PC relative reloc.  */
#define tc_fix_adjustable(FIX)				\
  (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
   && ! S_IS_WEAK ((FIX)->fx_addsy)			\
   && (! sparc_pic_code					\
       || (FIX)->fx_pcrel				\
       || ((FIX)->fx_subsy != NULL			\
	   && (S_GET_SEGMENT ((FIX)->fx_subsy)		\
	       == S_GET_SEGMENT ((FIX)->fx_addsy)))))
d156 9
a164 5
   turn into a reloc against the global offset table.  */
#define tc_fix_adjustable(FIX) \
  (! sparc_pic_code \
   || (FIX)->fx_pcrel \
   || (FIX)->fx_r_type == BFD_RELOC_16 \
d168 3
d175 23
@


1.6
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d31 1
a31 1
#ifdef TE_NetBSD
@


1.5
log
@Merge the Cygnus 960904 sources
@
text
@d26 4
d34 7
d44 1
d118 8
a125 4
#define tc_fix_adjustable(FIX) \
  (! S_IS_EXTERNAL ((FIX)->fx_addsy) \
   && ! S_IS_WEAK ((FIX)->fx_addsy) \
   && (! sparc_pic_code || (FIX)->fx_pcrel))
@


1.4
log
@Resolve conflicts with 0609 Cygnus import
@
text
@d57 6
d70 9
a78 2
   If we are generating PIC, and the reloc is against an externally
   visible symbol, we do not want gas to do the relocation.  */
d81 1
a81 1
  (! sparc_pic_code \
@


1.3
log
@As it is highly unlikely OpenBSD's object file format will divert from
NetBSD's, alias it instead of implementing a distinct but identical
configuration.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d18 2
a19 1
   to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d37 3
a39 1
#ifndef sparcv9
d41 1
a41 4
#else	/* sparcv9 */
#define TARGET_FORMAT "elf64-sparc" /* v9 */
#define ENV64			/* v9 */
#endif	/* sparcv9 */
d71 1
d95 1
d110 3
@


1.2
log
@Support OpenBSD configuration, by cloning NetBSD config entries.
@
text
@a28 3
#ifdef TE_OpenBSD
#define TARGET_FORMAT "a.out-sparc-openbsd"
#else
a29 1
#endif
@


1.1
log
@Initial revision
@
text
@d29 3
d33 1
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90-95, 1996 Free Software Foundation, Inc.
d18 1
a18 2
   to the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d36 1
a36 3
#ifdef SPARC_ARCH64
#define TARGET_FORMAT "elf64-sparc"
#else
d38 4
a41 1
#endif
a70 1
       && ! S_IS_WEAK ((FIX)->fx_addsy) \
a93 1
   && ! S_IS_WEAK ((FIX)->fx_addsy) \
a107 3

extern void sparc_md_end PARAMS ((void));
#define md_end() sparc_md_end ()
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a56 6
/* We require .word, et. al., to be aligned correctly.  */
#define md_cons_align(nbytes) sparc_cons_align (nbytes)
extern void sparc_cons_align PARAMS ((int));
#define HANDLE_ALIGN(fragp) sparc_handle_align (fragp)
extern void sparc_handle_align ();

d64 2
a65 9
   If the reloc is against an externally visible symbol, then the
   a.out assembler should not do the relocation if generating PIC, and
   the ELF assembler should never do the relocation.  */

#ifdef OBJ_ELF
#define obj_relocate_extern 0
#else
#define obj_relocate_extern (! sparc_pic_code)
#endif
d68 1
a68 1
  (obj_relocate_extern \
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a25 4

/* This is used to set the default value for `target_big_endian'.  */
#define TARGET_BYTES_BIG_ENDIAN 1

a29 7
#ifdef TE_SPARCAOUT
extern int target_big_endian;
#define TARGET_FORMAT (target_big_endian ? "a.out-sunos-big" : "a.out-sparc-little")
/* Bi-endian support may eventually be unconditional, but until things are
   working well it's only provided for targets that need it.  */
#define SPARC_BIENDIAN
#else
a32 1
#endif
d106 4
a109 8
#define tc_fix_adjustable(FIX)				\
  (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
   && ! S_IS_WEAK ((FIX)->fx_addsy)			\
   && (! sparc_pic_code					\
       || (FIX)->fx_pcrel				\
       || ((FIX)->fx_subsy != NULL			\
	   && (S_GET_SEGMENT ((FIX)->fx_subsy)		\
	       == S_GET_SEGMENT ((FIX)->fx_addsy)))))
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90-96, 1997 Free Software Foundation, Inc.
a20 1
#ifndef TC_SPARC
d23 3
a25 3
#ifdef ANSI_PROTOTYPES
struct frag;
#endif
a29 4
#define LOCAL_LABELS_FB 1

#define TARGET_ARCH bfd_arch_sparc

d54 1
d63 1
d73 1
a73 1
extern void sparc_handle_align PARAMS ((struct frag *));
a110 1
#define MD_APPLY_FIX3
a141 2

#endif
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90-96, 97, 98, 1999 Free Software Foundation, Inc.
d35 4
a38 7
extern const char *sparc_target_format PARAMS ((void));
#define TARGET_FORMAT sparc_target_format ()

#define RELOC_EXPANSION_POSSIBLE
#define MAX_RELOC_EXPANSION 2

#if 0
d40 2
d45 13
a59 3
/* Make it unconditional and check if -EL is valid after option parsing */
#define SPARC_BIENDIAN

d62 3
a64 1
#define md_convert_frag(b,s,f)		{as_fatal (_("sparc convert_frag\n"));}
d66 1
a66 1
			(as_fatal(_("estimate_size_before_relax called")),1)
a71 11
#define md_do_align(n, fill, len, max, around)				\
if ((n) && (n) <= 10 && !need_pass_2 && !(fill)				\
    && subseg_text_p (now_seg))						\
  {									\
    char *p;								\
    p = frag_var (rs_align_code, 1 << n, 1, (relax_substateT) 1024,	\
                  (symbolS *) 0, (offsetT) (n), (char *) 0);		\
    *p = 0x00;								\
    goto around;							\
  }

a113 5
#ifdef OBJ_ELF
#define TC_FORCE_RELOCATION(fixp) elf32_sparc_force_relocation(fixp)
extern int elf32_sparc_force_relocation PARAMS ((struct fix *));
#endif

d121 9
a129 26
   any non PC relative reloc.  The PIC part of this test must be
   parallel to the code in tc_gen_reloc which converts relocations to
   GOT relocations.  */
#define tc_fix_adjustable(FIX)						\
  (! S_IS_EXTERNAL ((FIX)->fx_addsy)					\
   && ! S_IS_WEAK ((FIX)->fx_addsy)					\
   && (FIX)->fx_r_type != BFD_RELOC_VTABLE_INHERIT			\
   && (FIX)->fx_r_type != BFD_RELOC_VTABLE_ENTRY			\
   && (! sparc_pic_code							\
       || ((FIX)->fx_r_type != BFD_RELOC_HI22				\
	   && (FIX)->fx_r_type != BFD_RELOC_LO10			\
	   && (FIX)->fx_r_type != BFD_RELOC_SPARC13			\
	   && ((FIX)->fx_r_type != BFD_RELOC_32_PCREL_S2		\
	       || (S_IS_DEFINED ((FIX)->fx_addsy)			\
		   && ! S_IS_COMMON ((FIX)->fx_addsy)			\
		   && ! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
		   && ! S_IS_WEAK ((FIX)->fx_addsy)))			\
	   && ((FIX)->fx_pcrel						\
	       || ((FIX)->fx_subsy != NULL				\
		   && (S_GET_SEGMENT ((FIX)->fx_subsy)			\
		       == S_GET_SEGMENT ((FIX)->fx_addsy)))		\
	       || S_IS_LOCAL ((FIX)->fx_addsy)))))

/* Finish up the entire symtab.  */
#define tc_adjust_symtab() sparc_adjust_symtab ()
extern void sparc_adjust_symtab PARAMS ((void));
d134 5
a138 9
   turn into a reloc against the global offset table, nor any reloc
   which we will need if a symbol is overridden.  */
#define tc_fix_adjustable(FIX)						\
  (! sparc_pic_code							\
   || ((FIX)->fx_pcrel							\
       && ((FIX)->fx_addsy == NULL					\
	   || (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
	       && ! S_IS_WEAK ((FIX)->fx_addsy))))			\
   || (FIX)->fx_r_type == BFD_RELOC_16					\
a141 3
#define elf_tc_final_processing sparc_elf_final_processing
extern void sparc_elf_final_processing PARAMS ((void));

a147 21

#define TC_CONS_FIX_NEW cons_fix_new_sparc
extern void cons_fix_new_sparc
  PARAMS ((struct frag *, int, unsigned int, struct expressionS *));

#define TC_FIX_TYPE	valueT

#define TC_INIT_FIX_DATA(X)			\
  do						\
     {						\
       (X)->tc_fix_data = 0;			\
     }						\
  while(0)

#define TC_FIX_DATA_PRINT(FILE, FIXP)					\
  do									\
    {									\
      fprintf((FILE), "addend2=%ld\n",   				\
	      (unsigned long) (FIXP)->tc_fix_data);			\
    }									\
  while(0)
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000 Free Software Foundation, Inc.
d53 1
a53 2
#define md_convert_frag(b,s,f) \
  as_fatal (_("sparc convert_frag\n"))
d55 1
a55 1
  (as_fatal(_("estimate_size_before_relax called")), 1)
d61 11
a74 1

a77 2
#define MAX_MEM_FOR_RS_ALIGN_CODE  (3 + 4 + 4)

d189 1
a189 1
  while (0)
d194 1
a194 1
      fprintf ((FILE), "addend2=%ld\n",   				\
d197 1
a197 3
  while (0)

#define DWARF2_LINE_MIN_INSN_LENGTH 4
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d57 1
a57 1
  (as_fatal (_("estimate_size_before_relax called")), 1)
d72 26
d101 4
a104 4
#define TC_FORCE_RELOCATION_ABS(FIX)		\
  ((FIX)->fx_r_type == BFD_RELOC_32_PCREL_S2	\
   || TC_FORCE_RELOCATION (FIX))

d108 4
a111 5
#ifdef OBJ_AOUT
/* This expression evaluates to true if the relocation is for a local
   object for which we still want to do the relocation at runtime.
   False if we are willing to perform this relocation while building
   the .o file.  */
d113 2
a114 7
#define TC_FORCE_RELOCATION_LOCAL(FIX)		\
  (!(FIX)->fx_pcrel				\
   || (FIX)->fx_plt				\
   || (sparc_pic_code				\
       && S_IS_EXTERNAL ((FIX)->fx_addsy))	\
   || TC_FORCE_RELOCATION (FIX))
#endif
d117 6
a122 5
/* Don't turn certain relocs into relocations against sections.  This
   is required for the dynamic linker to operate properly.  When
   generating PIC, we need to keep any non PC relative reloc.  The PIC
   part of this test must be parallel to the code in tc_gen_reloc which
   converts relocations to GOT relocations.  */
d124 3
a126 1
  ((FIX)->fx_r_type != BFD_RELOC_VTABLE_INHERIT				\
a127 2
   && ((FIX)->fx_r_type < BFD_RELOC_SPARC_TLS_GD_HI22			\
       || (FIX)->fx_r_type > BFD_RELOC_SPARC_TLS_TPOFF64)		\
d133 4
a136 1
	       || !generic_force_reloc (FIX))				\
a142 3
/* Values passed to md_apply_fix3 don't include the symbol value.  */
#define MD_APPLY_SYM_VALUE(FIX) 0

a171 5
#ifdef OBJ_ELF
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) sparc_cons (EXP, NBYTES)
extern void sparc_cons PARAMS ((expressionS *, int));
#endif

d185 1
a185 1
#define TC_FIX_DATA_PRINT(FILE, FIX)					\
d189 1
a189 1
	      (unsigned long) (FIX)->tc_fix_data);			\
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d177 1
a177 16
#define TARGET_USE_CFIPOP 1

#define tc_cfi_frame_initial_instructions sparc_cfi_frame_initial_instructions
extern void sparc_cfi_frame_initial_instructions PARAMS ((void));

#define tc_regname_to_dw2regnum sparc_regname_to_dw2regnum
extern int sparc_regname_to_dw2regnum PARAMS ((const char *regname));

#define tc_cfi_emit_pcrel_expr sparc_cfi_emit_pcrel_expr
extern void sparc_cfi_emit_pcrel_expr PARAMS ((expressionS *, unsigned int));

extern int sparc_cie_data_alignment;

#define DWARF2_LINE_MIN_INSN_LENGTH     4
#define DWARF2_DEFAULT_RETURN_COLUMN    15
#define DWARF2_CIE_DATA_ALIGNMENT       sparc_cie_data_alignment
@


