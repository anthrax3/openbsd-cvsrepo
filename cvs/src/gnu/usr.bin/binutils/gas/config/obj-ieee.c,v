head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.54
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.26;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.47;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.58;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.58;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.05.29.09.22.42;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.46.20;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.33.15;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.27;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.48;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* obj-format for ieee-695 records.
   Copyright 1991, 1992, 1993, 1994, 1997, 2000
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Created by Steve Chamberlain <steve@@cygnus.com>.  */

/* This will hopefully become the port through which bfd and gas talk,
   for the moment, only ieee is known to work well.  */

#include "bfd.h"
#include "as.h"
#include "subsegs.h"
#include "output-file.h"
#include "frags.h"

bfd *abfd;

/* How many addresses does the .align take?  */

static relax_addressT
relax_align (address, alignment)
     /* Address now.  */
     register relax_addressT address;

     /* Alignment (binary).  */
     register long alignment;
{
  relax_addressT mask;
  relax_addressT new_address;

  mask = ~((~0) << alignment);
  new_address = (address + mask) & (~mask);
  return (new_address - address);
}

/* Calculate the size of the frag chain
   and create a bfd section to contain all of it.  */

static void
size_section (abfd, idx)
     bfd *abfd;
     unsigned int idx;
{
  asection *sec;
  unsigned int size = 0;
  fragS *frag = segment_info[idx].frag_root;

  while (frag)
    {
      if (frag->fr_address != size)
	{
	  printf (_("Out of step\n"));
	  size = frag->fr_address;
	}
      size += frag->fr_fix;
      switch (frag->fr_type)
	{
	case rs_fill:
	case rs_org:
	  size += frag->fr_offset * frag->fr_var;
	  break;
	case rs_align:
	case rs_align_code:
	  {
	    addressT off;

	    off = relax_align (size, frag->fr_offset);
	    if (frag->fr_subtype != 0 && off > frag->fr_subtype)
	      off = 0;
	    size += off;
	  }
	}
      frag = frag->fr_next;
    }
  if (size)
    {
      char *name = segment_info[idx].name;

      if (name == (char *) NULL)
	name = ".data";

      segment_info[idx].user_stuff =
	(char *) (sec = bfd_make_section (abfd, name));
      /* Make it output through itself.  */
      sec->output_section = sec;
      sec->flags |= SEC_HAS_CONTENTS;
      bfd_set_section_size (abfd, sec, size);
    }
}

/* Run through a frag chain and write out the data to go with it.  */

static void
fill_section (abfd, idx)
     bfd *abfd;
     unsigned int idx;
{
  asection *sec = segment_info[idx].user_stuff;

  if (sec)
    {
      fragS *frag = segment_info[idx].frag_root;
      unsigned int offset = 0;
      while (frag)
	{
	  unsigned int fill_size;
	  unsigned int count;
	  switch (frag->fr_type)
	    {
	    case rs_fill:
	    case rs_align:
	    case rs_org:
	      if (frag->fr_fix)
		{
		  bfd_set_section_contents (abfd,
					    sec,
					    frag->fr_literal,
					    frag->fr_address,
					    frag->fr_fix);
		}
	      offset += frag->fr_fix;
	      fill_size = frag->fr_var;
	      if (fill_size)
		{
		  unsigned int off = frag->fr_fix;
		  for (count = frag->fr_offset; count; count--)
		    {
		      bfd_set_section_contents (abfd, sec,
						frag->fr_literal +
						frag->fr_fix,
						frag->fr_address + off,
						fill_size);
		      off += fill_size;
		    }
		}
	      break;
	    default:
	      abort ();
	    }
	  frag = frag->fr_next;
	}
    }
}

/* Count the relocations in a chain.  */

static unsigned int
count_entries_in_chain (idx)
     unsigned int idx;
{
  unsigned int nrelocs;
  fixS *fixup_ptr;

  /* Count the relocations.  */
  fixup_ptr = segment_info[idx].fix_root;
  nrelocs = 0;
  while (fixup_ptr != (fixS *) NULL)
    {
      fixup_ptr = fixup_ptr->fx_next;
      nrelocs++;
    }
  return nrelocs;
}

/* Output all the relocations for a section.  */

void
do_relocs_for (idx)
     unsigned int idx;
{
  unsigned int nrelocs;
  arelent **reloc_ptr_vector;
  arelent *reloc_vector;
  asymbol **ptrs;
  asection *section = (asection *) (segment_info[idx].user_stuff);
  unsigned int i;
  fixS *from;

  if (section)
    {
      nrelocs = count_entries_in_chain (idx);

      reloc_ptr_vector =
	(arelent **) malloc ((nrelocs + 1) * sizeof (arelent *));
      reloc_vector = (arelent *) malloc (nrelocs * sizeof (arelent));
      ptrs = (asymbol **) malloc (nrelocs * sizeof (asymbol *));
      from = segment_info[idx].fix_root;
      for (i = 0; i < nrelocs; i++)
	{
	  arelent *to = reloc_vector + i;
	  asymbol *s;
	  reloc_ptr_vector[i] = to;
	  to->howto = (reloc_howto_type *) (from->fx_r_type);

#if 0
	  /* We can't represent complicated things in a reloc yet.  */
	  if (from->fx_addsy == 0 || from->fx_subsy != 0)
	    abort ();
#endif

	  s = &(from->fx_addsy->sy_symbol.sy);
	  to->address = ((char *) (from->fx_frag->fr_address +
				   from->fx_where))
	    - ((char *) (&(from->fx_frag->fr_literal)));
	  to->addend = from->fx_offset;
	  /* If we know the symbol which we want to relocate to, turn
	     this reloaction into a section relative.

	     If this relocation is pcrelative, and we know the
	     destination, we still want to keep the relocation - since
	     the linker might relax some of the bytes, but it stops
	     being pc relative and turns into an absolute relocation.  */
	  if (s)
	    {
	      if ((s->flags & BSF_UNDEFINED) == 0)
		{
		  to->section = s->section;

		  /* We can refer directly to the value field here,
		     rather than using S_GET_VALUE, because this is
		     only called after do_symbols, which sets up the
		     value field.  */
		  to->addend += s->value;

		  to->sym_ptr_ptr = 0;
		  if (to->howto->pcrel_offset)
		    /* This is a pcrel relocation, the addend should
		       be adjusted.  */
		    to->addend -= to->address + 1;
		}
	      else
		{
		  to->section = 0;
		  *ptrs = &(from->fx_addsy->sy_symbol.sy);
		  to->sym_ptr_ptr = ptrs;

		  if (to->howto->pcrel_offset)
		    /* This is a pcrel relocation, the addend should
		       be adjusted.  */
		    to->addend -= to->address - 1;
		}
	    }
	  else
	    to->section = 0;

	  ptrs++;
	  from = from->fx_next;
	}

      /* Attach to the section.  */
      section->orelocation = reloc_ptr_vector;
      section->reloc_count = nrelocs;
      section->flags |= SEC_LOAD;
    }
}

/* Do the symbols.  */

static void
do_symbols (abfd)
     bfd *abfd;
{
  extern symbolS *symbol_rootP;
  symbolS *ptr;
  asymbol **symbol_ptr_vec;
  asymbol *symbol_vec;
  unsigned int count = 0;
  unsigned int index;

  for (ptr = symbol_rootP;
       ptr != (symbolS *) NULL;
       ptr = ptr->sy_next)
    {
      if (SEG_NORMAL (ptr->sy_symbol.seg))
	{
	  ptr->sy_symbol.sy.section =
	    (asection *) (segment_info[ptr->sy_symbol.seg].user_stuff);
	  S_SET_VALUE (ptr, S_GET_VALUE (ptr));
	  if (ptr->sy_symbol.sy.flags == 0)
	    ptr->sy_symbol.sy.flags = BSF_LOCAL;
	}
      else
	{
	  switch (ptr->sy_symbol.seg)
	    {
	    case SEG_ABSOLUTE:
	      ptr->sy_symbol.sy.flags |= BSF_ABSOLUTE;
	      ptr->sy_symbol.sy.section = 0;
	      break;
	    case SEG_UNKNOWN:
	      ptr->sy_symbol.sy.flags = BSF_UNDEFINED;
	      ptr->sy_symbol.sy.section = 0;
	      break;
	    default:
	      abort ();
	    }
	}
      ptr->sy_symbol.sy.value = S_GET_VALUE (ptr);
      count++;
    }
  symbol_ptr_vec = (asymbol **) malloc ((count + 1) * sizeof (asymbol *));

  index = 0;
  for (ptr = symbol_rootP;
       ptr != (symbolS *) NULL;
       ptr = ptr->sy_next)
    {
      symbol_ptr_vec[index] = &(ptr->sy_symbol.sy);
      index++;
    }
  symbol_ptr_vec[index] = 0;
  abfd->outsymbols = symbol_ptr_vec;
  abfd->symcount = count;
}

/* The generic as->bfd converter. Other backends may have special case
   code.  */

void
bfd_as_write_hook ()
{
  int i;

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    size_section (abfd, i);

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    fill_section (abfd, i);

  do_symbols (abfd);

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    do_relocs_for (i);
}

S_SET_SEGMENT (x, y)
     symbolS *x;
     int y;
{
  x->sy_symbol.seg = y;
}

S_IS_DEFINED (x)
     symbolS *x;
{
  if (SEG_NORMAL (x->sy_symbol.seg))
    {
      return 1;
    }
  switch (x->sy_symbol.seg)
    {
    case SEG_UNKNOWN:
      return 0;
    default:
      abort ();
    }
}

S_IS_EXTERNAL (x)
{
  abort ();
}

S_GET_DESC (x)
{
  abort ();
}

S_GET_SEGMENT (x)
     symbolS *x;
{
  return x->sy_symbol.seg;
}

S_SET_EXTERNAL (x)
     symbolS *x;
{
  x->sy_symbol.sy.flags |= BSF_GLOBAL | BSF_EXPORT;
}

S_SET_NAME (x, y)
     symbolS *x;
     char *y;
{
  x->sy_symbol.sy.name = y;
}

S_GET_OTHER (x)
{
  abort ();
}

S_IS_DEBUG (x)
{
  abort ();
}

#ifndef segment_name
char *
segment_name ()
{
  abort ();
}
#endif

void
obj_read_begin_hook ()
{
}

static void
obj_ieee_section (ignore)
     int ignore;
{
  extern char *input_line_pointer;
  extern char is_end_of_line[];
  char *p = input_line_pointer;
  char *s = p;
  int i;

  /* Look up the name, if it doesn't exist, make it.  */
  while (*p && *p != ' ' && *p != ',' && !is_end_of_line[*p])
    {
      p++;
    }
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      if (segment_info[i].hadone)
	{
	  if (strncmp (segment_info[i].name, s, p - s) == 0)
	    goto ok;
	}
      else
	break;
    }
  if (i == SEG_UNKNOWN)
    {
      as_bad (_("too many sections"));
      return;
    }

  segment_info[i].hadone = 1;
  segment_info[i].name = malloc (p - s + 1);
  memcpy (segment_info[i].name, s, p - s);
  segment_info[i].name[p - s] = 0;
ok:
  subseg_set (i, 0);
  while (!is_end_of_line[*p])
    p++;
  input_line_pointer = p;
}

const pseudo_typeS obj_pseudo_table[] =
{
  {"section", obj_ieee_section, 0},
  {"data.b" , cons            , 1},
  {"data.w" , cons            , 2},
  {"data.l" , cons            , 4},
  {"export" , s_globl         , 0},
  {"option" , s_ignore        , 0},
  {"end"    , s_ignore        , 0},
  {"import" , s_ignore        , 0},
  {"sdata"  , stringer        , 0},
  0,
};

void
obj_symbol_new_hook (symbolP)
     symbolS *symbolP;
{
  symbolP->sy_symbol.sy.the_bfd = abfd;
}

#if 1

#ifndef SUB_SEGMENT_ALIGN
#ifdef HANDLE_ALIGN
/* The last subsegment gets an alignment corresponding to the alignment
   of the section.  This allows proper nop-filling at the end of
   code-bearing sections.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
   ? get_recorded_alignment (SEG) : 0)
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 2
#endif
#endif

extern void
write_object_file ()
{
  int i;
  struct frchain *frchain_ptr;
  struct frag *frag_ptr;

  abfd = bfd_openw (out_file_name, "ieee");

  if (abfd == 0)
    {
      as_perror (_("FATAL: Can't create %s"), out_file_name);
      exit (EXIT_FAILURE);
    }
  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, bfd_arch_h8300, 0);
  subseg_set (1, 0);
  subseg_set (2, 0);
  subseg_set (3, 0);

  /* Run through all the sub-segments and align them up.  Also
     close any open frags.  We tack a .fill onto the end of the
     frag chain so that any .align's size can be worked by looking
     at the next frag.  */
  for (frchain_ptr = frchain_root;
       frchain_ptr != (struct frchain *) NULL;
       frchain_ptr = frchain_ptr->frch_next)
    {
      int alignment;

      subseg_set (frchain_ptr->frch_seg, frchain_ptr->frch_subseg);

      alignment = SUB_SEGMENT_ALIGN (now_seg, frchain_ptr)

#ifdef md_do_align
      md_do_align (alignment, (char *) NULL, 0, 0, alignment_done);
#endif
      if (subseg_text_p (now_seg))
	frag_align_code (alignment, 0);
      else
	frag_align (alignment, 0, 0);

#ifdef md_do_align
    alignment_done:
#endif

      frag_wane (frag_now);
      frag_now->fr_fix = 0;
      know (frag_now->fr_next == NULL);
    }

  /* Now build one big frag chain for each segment, linked through
     fr_next.  */
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      fragS **prev_frag_ptr_ptr;
      struct frchain *next_frchain_ptr;

#if 0
      struct frag **head_ptr = segment_info[i].frag_root;
#endif

      segment_info[i].frag_root = segment_info[i].frchainP->frch_root;
#if 0
      /* I'm not sure what this is for.  */
      for (frchain_ptr = segment_info[i].frchainP->frch_root;
	   frchain_ptr != (struct frchain *) NULL;
	   frchain_ptr = frchain_ptr->frch_next)
	{
	  *head_ptr = frchain_ptr;
	  head_ptr = &frchain_ptr->next;
	}
#endif
    }

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    relax_segment (segment_info[i].frag_root, i);

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;

  /* Now the addresses of the frags are correct within the segment.  */

  bfd_as_write_hook ();
  bfd_close (abfd);
}

#endif

H_SET_TEXT_SIZE (a, b)
{
  abort ();
}

H_GET_TEXT_SIZE ()
{
  abort ();
}

H_SET_BSS_SIZE ()
{
  abort ();
}

H_SET_STRING_SIZE ()
{
  abort ();
}

H_SET_RELOCATION_SIZE ()
{
  abort ();
}

H_SET_MAGIC_NUMBER ()
{
  abort ();
}

H_GET_FILE_SIZE ()
{
  abort ();
}

H_GET_TEXT_RELOCATION_SIZE ()
{
  abort ();
}
@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d267 1
a267 1
      /* Attatch to the section.  */
a469 4
void cons ();
void s_ignore ();

void s_globl ();
d495 1
a495 1
/* The last subsegment gets an aligment corresponding to the alignment
@


1.3
log
@resolve conflicts.
@
text
@d295 1
a295 1
	  S_SET_VALUE (ptr, S_GET_VALUE (ptr) + ptr->sy_frag->fr_address);
d496 14
d529 5
d538 1
a538 4
      /* Run through all the sub-segments and align them up.  Also
	 close any open frags.  We tack a .fill onto the end of the
	 frag chain so that any .align's size can be worked by looking
	 at the next frag.  */
d541 13
a553 2
#ifndef SUB_SEGMENT_ALIGN
#define SUB_SEGMENT_ALIGN(SEG) 2
d555 1
a555 1
      frag_align (SUB_SEGMENT_ALIGN (now_seg), 0, 0);
d587 3
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 1997, 1998 Free Software Foundation, Inc.
d20 1
a20 1
   02111-1307, USA. */
d22 1
d24 2
a25 10
/*
  created by

  steve chamberlain steve@@cygnus.com
  */

/*
  this will hopefully become the port through which bfd and gas talk,
  for the moment, only ieee is known to work well.
  */
d35 2
a36 1
/* How many addresses does the .align take? */
d39 5
a43 2
     register relax_addressT address;	/* Address now. */
     register long alignment;	/* Alignment (binary). */
d51 4
a54 1
}				/* relax_align() */
a55 2
/* calculate the size of the frag chain and create a bfd section
   to contain all of it */
d57 3
a59 3
DEFUN (size_section, (abfd, idx),
       bfd * abfd AND
       unsigned int idx)
d64 1
d95 1
d97 5
a101 5
	{
	  name = ".data";
	}
      segment_info[idx].user_stuff = (char *) (sec = bfd_make_section (abfd, name));
      /* Make it output through itself */
d108 2
a109 1
/* run through a frag chain and write out the data to go with it */
d111 3
a113 3
DEFUN (fill_section, (abfd, idx),
       bfd * abfd AND
       unsigned int idx)
d116 1
d162 1
a162 1
/* Count the relocations in a chain */
d165 2
a166 2
DEFUN (count_entries_in_chain, (idx),
       unsigned int idx)
d171 1
a171 1
  /* Count the relocations */
d182 2
a183 1
/* output all the relocations for a section */
d185 2
a186 2
DEFUN (do_relocs_for, (idx),
       unsigned int idx)
d195 1
d200 2
a201 1
      reloc_ptr_vector = (arelent **) malloc ((nrelocs + 1) * sizeof (arelent *));
d212 4
a215 2
#if 0	  /* We can't represent complicated things in a reloc yet */
	  if (from->fx_addsy == 0 || from->fx_subsy != 0) abort();
d229 1
a229 1
	     being pc relative and turns into an absolute relocation. */
d244 3
a246 4
		    {
		      /* This is a pcrel relocation, the addend should be adjusted */
		      to->addend -= to->address + 1;
		    }
d255 3
a257 4
		    {
		      /* This is a pcrel relocation, the addend should be adjusted */
		      to->addend -= to->address - 1;
		    }
a258 1

d261 1
a261 3
	    {
	      to->section = 0;
	    }
d267 1
a267 1
      /* attatch to the section */
d274 2
a275 1
/* do the symbols.. */
d277 2
a278 2
DEFUN (do_symbols, (abfd),
       bfd * abfd)
a286 1

d297 1
a297 3
	    {
	      ptr->sy_symbol.sy.flags = BSF_LOCAL;
	    }
d334 1
a334 1
   code */
d337 1
a337 1
DEFUN_VOID (bfd_as_write_hook)
d342 1
a342 4
    {
      size_section (abfd, i);
    }

a350 1

d437 2
a438 1
  /* Look up the name, if it doesn't exist, make it */
d448 1
a448 4
	    {
	      goto ok;

	    }
a467 1

a469 1

a472 1

d477 8
a484 8
  {"data.b", cons, 1},
  {"data.w", cons, 2},
  {"data.l", cons, 4},
  {"export", s_globl, 0},
  {"option", s_ignore, 0},
  {"end", s_ignore, 0},
  {"import", s_ignore, 0},
  {"sdata", stringer, 0},
a485 1

a487 2


a494 4




d497 1
a497 1
DEFUN_VOID (write_object_file)
d519 4
a522 4
      /* Run through all the sub-segments and align them up. Also close any
	 open frags. We tack a .fill onto the end of the frag chain so
	 that any .align's size can be worked by looking at the next
	 frag.  */
d535 1
a535 1
	   fr_next. */
a537 1

d541 3
a543 1
      /*	struct frag **head_ptr = segment_info[i].frag_root;*/
d547 1
a547 1
      /* Im not sure what this is for */
a554 2


d559 1
a559 3
    {
      relax_segment (segment_info[i].frag_root, i);
    }
d561 1
a561 1
  /* Now the addresses of the frags are correct within the segment */
a607 2

/* end of obj-ieee.c */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1991, 1992 Free Software Foundation, Inc.
d17 3
a19 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d69 1
a69 1
	  printf ("Out of step\n");
d80 9
a88 1
	  size += relax_align (size, frag->fr_offset);
d418 1
d424 1
d460 1
a460 1
      as_bad ("too many sections");
d522 1
a522 1
      as_perror ("FATAL: Can't create %s", out_file_name);
d543 1
a543 1
      frag_align (SUB_SEGMENT_ALIGN (now_seg), 0);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 1997 Free Software Foundation, Inc.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA. */
d79 1
a79 9
	case rs_align_code:
	  {
	    addressT off;

	    off = relax_align (size, frag->fr_offset);
	    if (frag->fr_subtype != 0 && off > frag->fr_subtype)
	      off = 0;
	    size += off;
	  }
a408 1
#ifndef segment_name
a413 1
#endif
d532 1
a532 1
      frag_align (SUB_SEGMENT_ALIGN (now_seg), 0, 0);
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 1997, 1998 Free Software Foundation, Inc.
d69 1
a69 1
	  printf (_("Out of step\n"));
d460 1
a460 1
      as_bad (_("too many sections"));
d522 1
a522 1
      as_perror (_("FATAL: Can't create %s"), out_file_name);
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1997, 2000
   Free Software Foundation, Inc.
d19 1
a19 1
   02111-1307, USA.  */
a20 1
/* Created by Steve Chamberlain <steve@@cygnus.com>.  */
d22 10
a31 2
/* This will hopefully become the port through which bfd and gas talk,
   for the moment, only ieee is known to work well.  */
d41 1
a41 2
/* How many addresses does the .align take?  */

d44 2
a45 5
     /* Address now.  */
     register relax_addressT address;

     /* Alignment (binary).  */
     register long alignment;
d53 1
a53 4
}

/* Calculate the size of the frag chain
   and create a bfd section to contain all of it.  */
d55 2
d58 3
a60 3
size_section (abfd, idx)
     bfd *abfd;
     unsigned int idx;
a64 1

a94 1

d96 5
a100 5
	name = ".data";

      segment_info[idx].user_stuff =
	(char *) (sec = bfd_make_section (abfd, name));
      /* Make it output through itself.  */
d107 1
a107 2
/* Run through a frag chain and write out the data to go with it.  */

d109 3
a111 3
fill_section (abfd, idx)
     bfd *abfd;
     unsigned int idx;
a113 1

d159 1
a159 1
/* Count the relocations in a chain.  */
d162 2
a163 2
count_entries_in_chain (idx)
     unsigned int idx;
d168 1
a168 1
  /* Count the relocations.  */
d179 1
a179 2
/* Output all the relocations for a section.  */

d181 2
a182 2
do_relocs_for (idx)
     unsigned int idx;
a190 1

d195 1
a195 2
      reloc_ptr_vector =
	(arelent **) malloc ((nrelocs + 1) * sizeof (arelent *));
d206 2
a207 4
#if 0
	  /* We can't represent complicated things in a reloc yet.  */
	  if (from->fx_addsy == 0 || from->fx_subsy != 0)
	    abort ();
d221 1
a221 1
	     being pc relative and turns into an absolute relocation.  */
d236 4
a239 3
		    /* This is a pcrel relocation, the addend should
		       be adjusted.  */
		    to->addend -= to->address + 1;
d248 4
a251 3
		    /* This is a pcrel relocation, the addend should
		       be adjusted.  */
		    to->addend -= to->address - 1;
d253 1
d256 3
a258 1
	    to->section = 0;
d264 1
a264 1
      /* Attatch to the section.  */
d271 1
a271 2
/* Do the symbols.  */

d273 2
a274 2
do_symbols (abfd)
     bfd *abfd;
d283 1
d294 3
a296 1
	    ptr->sy_symbol.sy.flags = BSF_LOCAL;
d333 1
a333 1
   code.  */
d336 1
a336 1
bfd_as_write_hook ()
d341 4
a344 1
    size_section (abfd, i);
d353 1
d440 1
a440 2

  /* Look up the name, if it doesn't exist, make it.  */
d450 4
a453 1
	    goto ok;
d473 1
d476 1
d480 1
d485 8
a492 8
  {"data.b" , cons            , 1},
  {"data.w" , cons            , 2},
  {"data.l" , cons            , 4},
  {"export" , s_globl         , 0},
  {"option" , s_ignore        , 0},
  {"end"    , s_ignore        , 0},
  {"import" , s_ignore        , 0},
  {"sdata"  , stringer        , 0},
d494 1
d497 2
d506 4
d512 1
a512 1
write_object_file ()
d534 4
a537 4
      /* Run through all the sub-segments and align them up.  Also
	 close any open frags.  We tack a .fill onto the end of the
	 frag chain so that any .align's size can be worked by looking
	 at the next frag.  */
d550 1
a550 1
     fr_next.  */
d553 1
d557 1
a557 3
#if 0
      struct frag **head_ptr = segment_info[i].frag_root;
#endif
d561 1
a561 1
      /* I'm not sure what this is for.  */
d569 2
d575 3
a577 1
    relax_segment (segment_info[i].frag_root, i);
d579 1
a579 1
  /* Now the addresses of the frags are correct within the segment.  */
d626 2
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d295 1
a295 1
	  S_SET_VALUE (ptr, S_GET_VALUE (ptr));
a495 14

#ifndef SUB_SEGMENT_ALIGN
#ifdef HANDLE_ALIGN
/* The last subsegment gets an aligment corresponding to the alignment
   of the section.  This allows proper nop-filling at the end of
   code-bearing sections.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
   ? get_recorded_alignment (SEG) : 0)
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 2
#endif
#endif

a514 5

  /* Run through all the sub-segments and align them up.  Also
     close any open frags.  We tack a .fill onto the end of the
     frag chain so that any .align's size can be worked by looking
     at the next frag.  */
d519 4
a522 1
      int alignment;
d525 2
a526 5

      alignment = SUB_SEGMENT_ALIGN (now_seg, frchain_ptr)

#ifdef md_do_align
      md_do_align (alignment, (char *) NULL, 0, 0, alignment_done);
d528 1
a528 9
      if (subseg_text_p (now_seg))
	frag_align_code (alignment, 0);
      else
	frag_align (alignment, 0, 0);

#ifdef md_do_align
    alignment_done:
#endif

a559 3

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d267 1
a267 1
      /* Attach to the section.  */
d470 4
d499 1
a499 1
/* The last subsegment gets an alignment corresponding to the alignment
@


