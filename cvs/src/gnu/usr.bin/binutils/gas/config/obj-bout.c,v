head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.5
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.4
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.3
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.26;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.46;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.55;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.55;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.12;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.09.12.14.46.18;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.05.13.13.32.55;	author fgsch;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.05.17.20.42.27;	author drahn;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.11.02.20.22.47;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* b.out object file format
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2,
   or (at your option) any later version.

   GAS is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "as.h"
#include "obstack.h"

/* In: segT   Out: N_TYPE bits  */
const short seg_N_TYPE[] =
{
  N_ABS,
  N_TEXT,
  N_DATA,
  N_BSS,
  N_UNDF,			/* unknown  */
  N_UNDF,			/* error  */
  N_UNDF,			/* expression  */
  N_UNDF,			/* debug  */
  N_UNDF,			/* ntv  */
  N_UNDF,			/* ptv  */
  N_REGISTER,			/* register  */
};

const segT N_TYPE_seg[N_TYPE + 2] =
{				/* N_TYPE == 0x1E = 32-2  */
  SEG_UNKNOWN,			/* N_UNDF == 0  */
  SEG_GOOF,
  SEG_ABSOLUTE,			/* N_ABS == 2  */
  SEG_GOOF,
  SEG_TEXT,			/* N_TEXT == 4  */
  SEG_GOOF,
  SEG_DATA,			/* N_DATA == 6  */
  SEG_GOOF,
  SEG_BSS,			/* N_BSS == 8  */
  SEG_GOOF,
  SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF,
  SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF,
  SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF,
  SEG_REGISTER,			/* dummy N_REGISTER for regs = 30  */
  SEG_GOOF,
};

static void obj_bout_line PARAMS ((int));

const pseudo_typeS obj_pseudo_table[] =
{
  {"line", obj_bout_line, 0},	/* Source code line number.  */

/* coff debugging directives.  Currently ignored silently.  */
  {"def", s_ignore, 0},
  {"dim", s_ignore, 0},
  {"endef", s_ignore, 0},
  {"ln", s_ignore, 0},
  {"scl", s_ignore, 0},
  {"size", s_ignore, 0},
  {"tag", s_ignore, 0},
  {"type", s_ignore, 0},
  {"val", s_ignore, 0},

/* other stuff we don't handle */
  {"ABORT", s_ignore, 0},
  {"ident", s_ignore, 0},

  {NULL, NULL, 0}		/* End sentinel.  */
};

/* Relocation.  */

/* Crawl along a fixS chain. Emit the segment's relocations.  */

void
obj_emit_relocations (where, fixP, segment_address_in_file)
     char **where;
     fixS *fixP;		/* Fixup chain for this segment.  */
     relax_addressT segment_address_in_file;
{
  for (; fixP; fixP = fixP->fx_next)
    {
      if (fixP->fx_done == 0
	  || fixP->fx_r_type != NO_RELOC)
	{
	  symbolS *sym;

	  sym = fixP->fx_addsy;
	  while (sym->sy_value.X_op == O_symbol
		 && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
	    sym = sym->sy_value.X_add_symbol;
	  fixP->fx_addsy = sym;

	  tc_bout_fix_to_chars (*where, fixP, segment_address_in_file);
	  *where += sizeof (struct relocation_info);
	}			/* if there's a symbol  */
    }				/* for each fixup  */
}

/* Aout file generation & utilities .  */

/* Convert a lvalue to machine dependent data.  */

void
obj_header_append (where, headers)
     char **where;
     object_headers *headers;
{
  /* Always leave in host byte order.  */

  headers->header.a_talign = section_alignment[SEG_TEXT];

  /* Force to at least 2.  */
  if (headers->header.a_talign < 2)
    {
      headers->header.a_talign = 2;
    }

  headers->header.a_dalign = section_alignment[SEG_DATA];
  headers->header.a_balign = section_alignment[SEG_BSS];

  headers->header.a_tload = 0;
  headers->header.a_dload =
    md_section_align (SEG_DATA, H_GET_TEXT_SIZE (headers));

  headers->header.a_relaxable = linkrelax;

#ifdef CROSS_COMPILE
  md_number_to_chars (*where, headers->header.a_magic, sizeof (headers->header.a_magic));
  *where += sizeof (headers->header.a_magic);
  md_number_to_chars (*where, headers->header.a_text, sizeof (headers->header.a_text));
  *where += sizeof (headers->header.a_text);
  md_number_to_chars (*where, headers->header.a_data, sizeof (headers->header.a_data));
  *where += sizeof (headers->header.a_data);
  md_number_to_chars (*where, headers->header.a_bss, sizeof (headers->header.a_bss));
  *where += sizeof (headers->header.a_bss);
  md_number_to_chars (*where, headers->header.a_syms, sizeof (headers->header.a_syms));
  *where += sizeof (headers->header.a_syms);
  md_number_to_chars (*where, headers->header.a_entry, sizeof (headers->header.a_entry));
  *where += sizeof (headers->header.a_entry);
  md_number_to_chars (*where, headers->header.a_trsize, sizeof (headers->header.a_trsize));
  *where += sizeof (headers->header.a_trsize);
  md_number_to_chars (*where, headers->header.a_drsize, sizeof (headers->header.a_drsize));
  *where += sizeof (headers->header.a_drsize);
  md_number_to_chars (*where, headers->header.a_tload, sizeof (headers->header.a_tload));
  *where += sizeof (headers->header.a_tload);
  md_number_to_chars (*where, headers->header.a_dload, sizeof (headers->header.a_dload));
  *where += sizeof (headers->header.a_dload);
  md_number_to_chars (*where, headers->header.a_talign, sizeof (headers->header.a_talign));
  *where += sizeof (headers->header.a_talign);
  md_number_to_chars (*where, headers->header.a_dalign, sizeof (headers->header.a_dalign));
  *where += sizeof (headers->header.a_dalign);
  md_number_to_chars (*where, headers->header.a_balign, sizeof (headers->header.a_balign));
  *where += sizeof (headers->header.a_balign);
  md_number_to_chars (*where, headers->header.a_relaxable, sizeof (headers->header.a_relaxable));
  *where += sizeof (headers->header.a_relaxable);
#else /* ! CROSS_COMPILE */
  append (where, (char *) &headers->header, sizeof (headers->header));
#endif /* ! CROSS_COMPILE */
}

void
obj_symbol_to_chars (where, symbolP)
     char **where;
     symbolS *symbolP;
{
  md_number_to_chars ((char *) &(S_GET_OFFSET (symbolP)),
		      S_GET_OFFSET (symbolP),
		      sizeof (S_GET_OFFSET (symbolP)));

  md_number_to_chars ((char *) &(S_GET_DESC (symbolP)),
		      S_GET_DESC (symbolP),
		      sizeof (S_GET_DESC (symbolP)));

  md_number_to_chars ((char *) &symbolP->sy_symbol.n_value,
		      S_GET_VALUE (symbolP),
		      sizeof (symbolP->sy_symbol.n_value));

  append (where, (char *) &symbolP->sy_symbol, sizeof (obj_symbol_type));
}

void
obj_emit_symbols (where, symbol_rootP)
     char **where;
     symbolS *symbol_rootP;
{
  symbolS *symbolP;

  /* Emit all symbols left in the symbol chain.  */
  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      /* Used to save the offset of the name.  It is used to point to
	 the string in memory but must be a file offset.  */
      char *temp;

      temp = S_GET_NAME (symbolP);
      S_SET_OFFSET (symbolP, symbolP->sy_name_offset);

      /* Any symbol still undefined and is not a dbg symbol is made N_EXT.  */
      if (!S_IS_DEBUG (symbolP) && !S_IS_DEFINED (symbolP))
	S_SET_EXTERNAL (symbolP);

      obj_symbol_to_chars (where, symbolP);
      S_SET_NAME (symbolP, temp);
    }
}

void
obj_symbol_new_hook (symbolP)
     symbolS *symbolP;
{
  S_SET_OTHER (symbolP, 0);
  S_SET_DESC (symbolP, 0);
}

static void
obj_bout_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* Assume delimiter is part of expression.  */
  /* BSD4.2 as fails with delightful bug, so we are not being
     incompatible here.  */
  new_logical_line ((char *) NULL, (int) (get_absolute_expression ()));
  demand_empty_rest_of_line ();
}

void
obj_read_begin_hook ()
{
}

void
obj_crawl_symbol_chain (headers)
     object_headers *headers;
{
  symbolS **symbolPP;
  symbolS *symbolP;
  int symbol_number = 0;

  tc_crawl_symbol_chain (headers);

  symbolPP = &symbol_rootP;	/* -> last symbol chain link.  */
  while ((symbolP = *symbolPP) != NULL)
    {
      if (flag_readonly_data_in_text && (S_GET_SEGMENT (symbolP) == SEG_DATA))
	{
	  S_SET_SEGMENT (symbolP, SEG_TEXT);
	}			/* if pushing data into text  */

      resolve_symbol_value (symbolP);

      /* Skip symbols which were equated to undefined or common
	 symbols.  */
      if (symbolP->sy_value.X_op == O_symbol
	  && (! S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP)))
	{
	  *symbolPP = symbol_next (symbolP);
	  continue;
	}

      /* OK, here is how we decide which symbols go out into the
	 brave new symtab.  Symbols that do are:

	 * symbols with no name (stabd's?)
	 * symbols with debug info in their N_TYPE

	 Symbols that don't are:
	 * symbols that are registers
	 * symbols with \1 as their 3rd character (numeric labels)
	 * "local labels" as defined by S_LOCAL_NAME(name)
	 if the -L switch was passed to gas.

	 All other symbols are output.  We complain if a deleted
	 symbol was marked external.  */

      if (1
	  && !S_IS_REGISTER (symbolP)
	  && (!S_GET_NAME (symbolP)
	      || S_IS_DEBUG (symbolP)
#ifdef TC_I960
      /* FIXME-SOON this ifdef seems highly dubious to me.  xoxorich.  */
	      || !S_IS_DEFINED (symbolP)
	      || S_IS_EXTERNAL (symbolP)
#endif /* TC_I960 */
	      || (S_GET_NAME (symbolP)[0] != '\001'
		  && (flag_keep_locals || !S_LOCAL_NAME (symbolP)))))
	{
	  symbolP->sy_number = symbol_number++;

	  /* The + 1 after strlen account for the \0 at the end of
	     each string.  */
	  if (!S_IS_STABD (symbolP))
	    {
	      /* Ordinary case.  */
	      symbolP->sy_name_offset = string_byte_count;
	      string_byte_count += strlen (S_GET_NAME (symbolP)) + 1;
	    }
	  else			/* .Stabd case.  */
	    symbolP->sy_name_offset = 0;
	  symbolPP = &(symbolP->sy_next);
	}
      else
	{
	  if (S_IS_EXTERNAL (symbolP) || !S_IS_DEFINED (symbolP))
	    {
	      as_bad (_("Local symbol %s never defined"),
		      S_GET_NAME (symbolP));
	    }			/* Oops.  */

	  /* Unhook it from the chain.  */
	  *symbolPP = symbol_next (symbolP);
	}			/* if this symbol should be in the output  */
    }				/* for each symbol  */

  H_SET_SYMBOL_TABLE_SIZE (headers, symbol_number);
}

/* Find strings by crawling along symbol table chain.  */

void
obj_emit_strings (where)
     char **where;
{
  symbolS *symbolP;

#ifdef CROSS_COMPILE
  /* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
  md_number_to_chars (*where, string_byte_count, sizeof (string_byte_count));
  *where += sizeof (string_byte_count);
#else /* CROSS_COMPILE */
  append (where, (char *) &string_byte_count,
	  (unsigned long) sizeof (string_byte_count));
#endif /* CROSS_COMPILE */

  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      if (S_GET_NAME (symbolP))
	append (where, S_GET_NAME (symbolP),
		(unsigned long) (strlen (S_GET_NAME (symbolP)) + 1));
    }				/* Walk symbol chain.  */
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d261 1
a261 1
	}			/* if pusing data into text  */
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001
d81 1
a81 1
  {NULL}			/* End sentinel.  */
d231 1
a231 1
     int ignore;
d263 1
a263 1
      resolve_symbol_value (symbolP, 1);
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 1996
d20 1
a20 1
   02111-1307, USA. */
d24 3
a26 2
const short			/* in: segT   out: N_TYPE bits */
  seg_N_TYPE[] =
d32 7
a38 7
  N_UNDF,			/* unknown */
  N_UNDF,			/* error */
  N_UNDF,			/* expression */
  N_UNDF,			/* debug */
  N_UNDF,			/* ntv */
  N_UNDF,			/* ptv */
  N_REGISTER,			/* register */
d42 2
a43 2
{				/* N_TYPE == 0x1E = 32-2 */
  SEG_UNKNOWN,			/* N_UNDF == 0 */
d45 1
a45 1
  SEG_ABSOLUTE,			/* N_ABS == 2 */
d47 1
a47 1
  SEG_TEXT,			/* N_TEXT == 4 */
d49 1
a49 1
  SEG_DATA,			/* N_DATA == 6 */
d51 1
a51 1
  SEG_BSS,			/* N_BSS == 8 */
d56 1
a56 1
  SEG_REGISTER,			/* dummy N_REGISTER for regs = 30 */
d64 1
a64 1
  {"line", obj_bout_line, 0},	/* source code line number */
d66 1
a66 1
/* coff debugging directives.  Currently ignored silently */
d81 4
a84 2
  {NULL}			/* end sentinel */
};				/* obj_pseudo_table */
d86 1
a86 1
/* Relocation. */
a87 5
/*
 *		emit_relocations()
 *
 * Crawl along a fixS chain. Emit the segment's relocations.
 */
d91 1
a91 1
     fixS *fixP;		/* Fixup chain for this segment. */
d109 3
a111 2
	}			/* if there's a symbol */
    }				/* for each fixup */
d113 1
a113 1
}				/* emit_relocations() */
d115 1
a115 1
/* Aout file generation & utilities */
a116 1
/* Convert a lvalue to machine dependent data */
d122 1
a122 1
  /* Always leave in host byte order */
d126 1
d130 1
a130 1
    }				/* force to at least 2 */
d136 2
a137 1
  headers->header.a_dload = md_section_align (SEG_DATA, H_GET_TEXT_SIZE (headers));
d173 1
a173 1
}				/* a_header_append() */
d180 11
a190 3
  md_number_to_chars ((char *) &(S_GET_OFFSET (symbolP)), S_GET_OFFSET (symbolP), sizeof (S_GET_OFFSET (symbolP)));
  md_number_to_chars ((char *) &(S_GET_DESC (symbolP)), S_GET_DESC (symbolP), sizeof (S_GET_DESC (symbolP)));
  md_number_to_chars ((char *) &symbolP->sy_symbol.n_value, S_GET_VALUE (symbolP), sizeof (symbolP->sy_symbol.n_value));
d193 1
a193 1
}				/* obj_symbol_to_chars() */
d202 1
a202 3
  /*
	 * Emit all symbols left in the symbol chain.
	 */
d205 2
a206 2
      /* Used to save the offset of the name. It is used to point
		   to the string in memory but must be a file offset. */
d212 1
a212 1
      /* Any symbol still undefined and is not a dbg symbol is made N_EXT. */
d219 1
a219 1
}				/* emit_symbols() */
d233 3
a235 3
  /* Assume delimiter is part of expression. */
  /* BSD4.2 as fails with delightful bug, so we */
  /* are not being incompatible here. */
d238 1
a238 1
}				/* obj_bout_line() */
d255 1
a255 1
  symbolPP = &symbol_rootP;	/*->last symbol chain link. */
d261 1
a261 1
	}			/* if pusing data into text */
d276 1
a276 1
		
d279 1
a279 1
		
d285 1
a285 1
		
d287 1
a287 2
	 symbol was marked external. */

d294 1
a294 1
      /* FIXME-SOON this ifdef seems highly dubious to me.  xoxorich. */
d298 2
a299 1
	      || (S_GET_NAME (symbolP)[0] != '\001' && (flag_keep_locals || !S_LOCAL_NAME (symbolP)))))
d303 2
a304 2
	  /* The + 1 after strlen account for the \0 at the
			   end of each string */
d307 1
a307 1
	      /* Ordinary case. */
d311 1
a311 1
	  else			/* .Stabd case. */
d313 1
a313 1
	  symbolPP = &(symbol_next (symbolP));
d319 3
a321 2
	      as_bad (_("Local symbol %s never defined"), S_GET_NAME (symbolP));
	    }			/* oops. */
d323 1
a323 1
	  /* Unhook it from the chain */
d325 2
a326 2
	}			/* if this symbol should be in the output */
    }				/* for each symbol */
d331 1
a331 3
/*
 * Find strings by crawling along symbol table chain.
 */
d344 2
a345 1
  append (where, (char *) &string_byte_count, (unsigned long) sizeof (string_byte_count));
d351 3
a353 2
	append (where, S_GET_NAME (symbolP), (unsigned long) (strlen (S_GET_NAME (symbolP)) + 1));
    }				/* walk symbol chain */
a354 2

/* end of obj-bout.c */
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d17 4
a20 3
   You should have received a copy of the GNU General Public
   License along with GAS; see the file COPYING.  If not, write
   to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d257 1
a257 1
      resolve_symbol_value (symbolP);
d313 1
a313 1
	      as_bad ("Local symbol %s never defined", S_GET_NAME (symbolP));
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.
d100 8
d257 9
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 2
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 1996
   Free Software Foundation, Inc.
a98 8
	  symbolS *sym;

	  sym = fixP->fx_addsy;
	  while (sym->sy_value.X_op == O_symbol
		 && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
	    sym = sym->sy_value.X_add_symbol;
	  fixP->fx_addsy = sym;

a247 9

      /* Skip symbols which were equated to undefined or common
	 symbols.  */
      if (symbolP->sy_value.X_op == O_symbol
	  && (! S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP)))
	{
	  *symbolPP = symbol_next (symbolP);
	  continue;
	}
@


1.1.1.3
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d17 3
a19 4
   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA. */
d256 1
a256 1
      resolve_symbol_value (symbolP, 1);
d312 1
a312 1
	      as_bad (_("Local symbol %s never defined"), S_GET_NAME (symbolP));
@


1.1.1.4
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001
d20 1
a20 1
   02111-1307, USA.  */
d24 2
a25 3

/* In: segT   Out: N_TYPE bits  */
const short seg_N_TYPE[] =
d31 7
a37 7
  N_UNDF,			/* unknown  */
  N_UNDF,			/* error  */
  N_UNDF,			/* expression  */
  N_UNDF,			/* debug  */
  N_UNDF,			/* ntv  */
  N_UNDF,			/* ptv  */
  N_REGISTER,			/* register  */
d41 2
a42 2
{				/* N_TYPE == 0x1E = 32-2  */
  SEG_UNKNOWN,			/* N_UNDF == 0  */
d44 1
a44 1
  SEG_ABSOLUTE,			/* N_ABS == 2  */
d46 1
a46 1
  SEG_TEXT,			/* N_TEXT == 4  */
d48 1
a48 1
  SEG_DATA,			/* N_DATA == 6  */
d50 1
a50 1
  SEG_BSS,			/* N_BSS == 8  */
d55 1
a55 1
  SEG_REGISTER,			/* dummy N_REGISTER for regs = 30  */
d63 1
a63 1
  {"line", obj_bout_line, 0},	/* Source code line number.  */
d65 1
a65 1
/* coff debugging directives.  Currently ignored silently.  */
d80 2
a81 4
  {NULL}			/* End sentinel.  */
};

/* Relocation.  */
d83 1
a83 1
/* Crawl along a fixS chain. Emit the segment's relocations.  */
d85 5
d93 1
a93 1
     fixS *fixP;		/* Fixup chain for this segment.  */
d111 2
a112 3
	}			/* if there's a symbol  */
    }				/* for each fixup  */
}
d114 1
a114 1
/* Aout file generation & utilities .  */
d116 1
a116 1
/* Convert a lvalue to machine dependent data.  */
d118 1
d124 1
a124 1
  /* Always leave in host byte order.  */
a127 1
  /* Force to at least 2.  */
d131 1
a131 1
    }
d137 1
a137 2
  headers->header.a_dload =
    md_section_align (SEG_DATA, H_GET_TEXT_SIZE (headers));
d173 1
a173 1
}
d180 3
a182 11
  md_number_to_chars ((char *) &(S_GET_OFFSET (symbolP)),
		      S_GET_OFFSET (symbolP),
		      sizeof (S_GET_OFFSET (symbolP)));

  md_number_to_chars ((char *) &(S_GET_DESC (symbolP)),
		      S_GET_DESC (symbolP),
		      sizeof (S_GET_DESC (symbolP)));

  md_number_to_chars ((char *) &symbolP->sy_symbol.n_value,
		      S_GET_VALUE (symbolP),
		      sizeof (symbolP->sy_symbol.n_value));
d185 1
a185 1
}
d194 3
a196 1
  /* Emit all symbols left in the symbol chain.  */
d199 2
a200 2
      /* Used to save the offset of the name.  It is used to point to
	 the string in memory but must be a file offset.  */
d206 1
a206 1
      /* Any symbol still undefined and is not a dbg symbol is made N_EXT.  */
d213 1
a213 1
}
d227 3
a229 3
  /* Assume delimiter is part of expression.  */
  /* BSD4.2 as fails with delightful bug, so we are not being
     incompatible here.  */
d232 1
a232 1
}
d249 1
a249 1
  symbolPP = &symbol_rootP;	/* -> last symbol chain link.  */
d255 1
a255 1
	}			/* if pusing data into text  */
d270 1
a270 1

d273 1
a273 1

d279 3
a282 2
	 All other symbols are output.  We complain if a deleted
	 symbol was marked external.  */
d289 1
a289 1
      /* FIXME-SOON this ifdef seems highly dubious to me.  xoxorich.  */
d293 1
a293 2
	      || (S_GET_NAME (symbolP)[0] != '\001'
		  && (flag_keep_locals || !S_LOCAL_NAME (symbolP)))))
d297 2
a298 2
	  /* The + 1 after strlen account for the \0 at the end of
	     each string.  */
d301 1
a301 1
	      /* Ordinary case.  */
d305 1
a305 1
	  else			/* .Stabd case.  */
d307 1
a307 1
	  symbolPP = &(symbolP->sy_next);
d313 2
a314 3
	      as_bad (_("Local symbol %s never defined"),
		      S_GET_NAME (symbolP));
	    }			/* Oops.  */
d316 1
a316 1
	  /* Unhook it from the chain.  */
d318 2
a319 2
	}			/* if this symbol should be in the output  */
    }				/* for each symbol  */
d324 3
a326 1
/* Find strings by crawling along symbol table chain.  */
d339 1
a339 2
  append (where, (char *) &string_byte_count,
	  (unsigned long) sizeof (string_byte_count));
d345 2
a346 3
	append (where, S_GET_NAME (symbolP),
		(unsigned long) (strlen (S_GET_NAME (symbolP)) + 1));
    }				/* Walk symbol chain.  */
d348 2
@


1.1.1.5
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002
d81 1
a81 1
  {NULL, NULL, 0}		/* End sentinel.  */
d231 1
a231 1
     int ignore ATTRIBUTE_UNUSED;
d263 1
a263 1
      resolve_symbol_value (symbolP);
@


1.1.1.6
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d261 1
a261 1
	}			/* if pushing data into text  */
@


