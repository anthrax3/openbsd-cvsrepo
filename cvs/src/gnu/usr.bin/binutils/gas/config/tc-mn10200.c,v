head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.2.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.29;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.31;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.36;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.52;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.34.47;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.19.14.14.29;	author niklas;	state dead;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	97.05.29.09.23.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.46.29;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.36.32;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.32;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.54;	author miod;	state Exp;
branches;
next	;

1.1.2.1
date	96.11.19.14.14.29;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-mn10200.c -- Assembler code for the Matsushita 10200
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/mn10200.h"

/* Structure to hold information about predefined registers.  */
struct reg_name
{
  const char *name;
  int value;
};

/* Generic assembler global variables which must be defined by all
   targets.  */

/* Characters which always start a comment.  */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = ";#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";

const relax_typeS md_relax_table[] = {
  /* bCC relaxing  */
  {0x81, -0x7e, 2, 1},
  {0x8004, -0x7ffb, 5, 2},
  {0x800006, -0x7ffff9, 7, 0},
  /* bCCx relaxing  */
  {0x81, -0x7e, 3, 4},
  {0x8004, -0x7ffb, 6, 5},
  {0x800006, -0x7ffff9, 8, 0},
  /* jsr relaxing  */
  {0x8004, -0x7ffb, 3, 7},
  {0x800006, -0x7ffff9, 5, 0},
  /* jmp relaxing  */
  {0x81, -0x7e, 2, 9},
  {0x8004, -0x7ffb, 3, 10},
  {0x800006, -0x7ffff9, 5, 0},

};

/* Local functions.  */
static void mn10200_insert_operand PARAMS ((unsigned long *, unsigned long *,
					    const struct mn10200_operand *,
					    offsetT, char *, unsigned,
					    unsigned));
static unsigned long check_operand PARAMS ((unsigned long,
					    const struct mn10200_operand *,
					    offsetT));
static int reg_name_search PARAMS ((const struct reg_name *, int, const char *));
static bfd_boolean data_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean address_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean other_register_name PARAMS ((expressionS *expressionP));

/* Fixups.  */
#define MAX_INSN_FIXUPS (5)
struct mn10200_fixup
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};
struct mn10200_fixup fixups[MAX_INSN_FIXUPS];
static int fc;

const char *md_shortopts = "";
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { NULL,       NULL,           0 }
};

/* Opcode hash table.  */
static struct hash_control *mn10200_hash;

/* This table is sorted. Suitable for searching by a binary search.  */
static const struct reg_name data_registers[] =
{
  { "d0", 0 },
  { "d1", 1 },
  { "d2", 2 },
  { "d3", 3 },
};
#define DATA_REG_NAME_CNT				\
  (sizeof (data_registers) / sizeof (struct reg_name))

static const struct reg_name address_registers[] =
{
  { "a0", 0 },
  { "a1", 1 },
  { "a2", 2 },
  { "a3", 3 },
};
#define ADDRESS_REG_NAME_CNT					\
  (sizeof (address_registers) / sizeof (struct reg_name))

static const struct reg_name other_registers[] =
{
  { "mdr", 0 },
  { "psw", 0 },
};
#define OTHER_REG_NAME_CNT				\
  (sizeof (other_registers) / sizeof (struct reg_name))

/* reg_name_search does a binary search of the given register table
   to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure.  */

static int
reg_name_search (regs, regcount, name)
     const struct reg_name *regs;
     int regcount;
     const char *name;
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return regs[middle].value;
    }
  while (low <= high);
  return -1;
}

/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */

static bfd_boolean
data_register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (data_registers, DATA_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */

static bfd_boolean
address_register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (address_registers, ADDRESS_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */

static bfd_boolean
other_register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (other_registers, OTHER_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

void
md_show_usage (stream)
     FILE *stream;
{
  fprintf (stream, _("MN10200 options:\n\
none yet\n"));
}

int
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
{
  return 0;
}

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

char *
md_atof (type, litp, sizep)
     int type;
     char *litp;
     int *sizep;
{
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  for (i = prec - 1; i >= 0; i--)
    {
      md_number_to_chars (litp, (valueT) words[i], 2);
      litp += 2;
    }

  return NULL;
}

void
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     fragS *fragP;
{
  static unsigned long label_count = 0;
  char buf[40];

  subseg_change (sec, 0);
  if (fragP->fr_subtype == 0)
    {
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 2;
    }
  else if (fragP->fr_subtype == 1)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset] & 0xff;

      switch (opcode)
	{
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 1, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 2] = 0xfc;
      fix_new (fragP, fragP->fr_fix + 3, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else if (fragP->fr_subtype == 2)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset] & 0xff;

      switch (opcode)
	{
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 1, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 2] = 0xf4;
      fragP->fr_literal[offset + 3] = 0xe0;
      fix_new (fragP, fragP->fr_fix + 4, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 7;
    }
  else if (fragP->fr_subtype == 3)
    {
      fix_new (fragP, fragP->fr_fix + 2, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 4)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xfc:
	  opcode = 0xfd;
	  break;
	case 0xfd:
	  opcode = 0xfc;
	  break;
	case 0xfe:
	  opcode = 0xff;
	  break;
	case 0xff:
	  opcode = 0xfe;
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	case 0xec:
	  opcode = 0xed;
	  break;
	case 0xed:
	  opcode = 0xec;
	  break;
	case 0xee:
	  opcode = 0xef;
	  break;
	case 0xef:
	  opcode = 0xee;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xfc;
      fix_new (fragP, fragP->fr_fix + 4, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 6;
    }
  else if (fragP->fr_subtype == 5)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xfc:
	  opcode = 0xfd;
	  break;
	case 0xfd:
	  opcode = 0xfc;
	  break;
	case 0xfe:
	  opcode = 0xff;
	  break;
	case 0xff:
	  opcode = 0xfe;
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	case 0xec:
	  opcode = 0xed;
	  break;
	case 0xed:
	  opcode = 0xec;
	  break;
	case 0xee:
	  opcode = 0xef;
	  break;
	case 0xef:
	  opcode = 0xee;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xf4;
      fragP->fr_literal[offset + 4] = 0xe0;
      fix_new (fragP, fragP->fr_fix + 5, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 8;
    }
  else if (fragP->fr_subtype == 6)
    {
      fix_new (fragP, fragP->fr_fix + 1, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 7)
    {
      int offset = fragP->fr_fix;
      fragP->fr_literal[offset] = 0xf4;
      fragP->fr_literal[offset + 1] = 0xe1;

      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else if (fragP->fr_subtype == 8)
    {
      fragP->fr_literal[fragP->fr_fix] = 0xea;
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 2;
    }
  else if (fragP->fr_subtype == 9)
    {
      int offset = fragP->fr_fix;
      fragP->fr_literal[offset] = 0xfc;

      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 10)
    {
      int offset = fragP->fr_fix;
      fragP->fr_literal[offset] = 0xf4;
      fragP->fr_literal[offset + 1] = 0xe0;

      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else
    abort ();
}

valueT
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_begin ()
{
  char *prev_name = "";
  register const struct mn10200_opcode *op;

  mn10200_hash = hash_new ();

  /* Insert unique names into hash table.  The MN10200 instruction set
     has many identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */

  op = mn10200_opcodes;
  while (op->name)
    {
      if (strcmp (prev_name, op->name))
	{
	  prev_name = (char *) op->name;
	  hash_insert (mn10200_hash, op->name, (char *) op);
	}
      op++;
    }

  /* This is both a simplification (we don't have to write md_apply_fix3)
     and support for future optimizations (branch shortening and similar
     stuff in the linker.  */
  linkrelax = 1;
}

void
md_assemble (str)
     char *str;
{
  char *s;
  struct mn10200_opcode *opcode;
  struct mn10200_opcode *next_opcode;
  const unsigned char *opindex_ptr;
  int next_opindex, relaxable;
  unsigned long insn, extension, size = 0;
  char *f;
  int i;
  int match;

  /* Get the opcode.  */
  for (s = str; *s != '\0' && !ISSPACE (*s); s++)
    ;
  if (*s != '\0')
    *s++ = '\0';

  /* Find the first opcode with the proper name.  */
  opcode = (struct mn10200_opcode *) hash_find (mn10200_hash, str);
  if (opcode == NULL)
    {
      as_bad (_("Unrecognized opcode: `%s'"), str);
      return;
    }

  str = s;
  while (ISSPACE (*str))
    ++str;

  input_line_pointer = str;

  for (;;)
    {
      const char *errmsg = NULL;
      int op_idx;
      char *hold;
      int extra_shift = 0;

      relaxable = 0;
      fc = 0;
      match = 0;
      next_opindex = 0;
      insn = opcode->opcode;
      extension = 0;
      for (op_idx = 1, opindex_ptr = opcode->operands;
	   *opindex_ptr != 0;
	   opindex_ptr++, op_idx++)
	{
	  const struct mn10200_operand *operand;
	  expressionS ex;

	  if (next_opindex == 0)
	    {
	      operand = &mn10200_operands[*opindex_ptr];
	    }
	  else
	    {
	      operand = &mn10200_operands[next_opindex];
	      next_opindex = 0;
	    }

	  errmsg = NULL;

	  while (*str == ' ' || *str == ',')
	    ++str;

	  if (operand->flags & MN10200_OPERAND_RELAX)
	    relaxable = 1;

	  /* Gather the operand.  */
	  hold = input_line_pointer;
	  input_line_pointer = str;

	  if (operand->flags & MN10200_OPERAND_PAREN)
	    {
	      if (*input_line_pointer != ')' && *input_line_pointer != '(')
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      input_line_pointer++;
	      goto keep_going;
	    }
	  /* See if we can match the operands.  */
	  else if (operand->flags & MN10200_OPERAND_DREG)
	    {
	      if (!data_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10200_OPERAND_AREG)
	    {
	      if (!address_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10200_OPERAND_PSW)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcmp (start, "psw") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10200_OPERAND_MDR)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcmp (start, "mdr") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (data_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (address_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (other_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (*str == ')' || *str == '(')
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else
	    {
	      expression (&ex);
	    }

	  switch (ex.X_op)
	    {
	    case O_illegal:
	      errmsg = _("illegal operand");
	      goto error;
	    case O_absent:
	      errmsg = _("missing operand");
	      goto error;
	    case O_register:
	      if ((operand->flags
		   & (MN10200_OPERAND_DREG | MN10200_OPERAND_AREG)) == 0)
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      if (opcode->format == FMT_2 || opcode->format == FMT_5)
		extra_shift = 8;
	      else if (opcode->format == FMT_3 || opcode->format == FMT_6
		       || opcode->format == FMT_7)
		extra_shift = 16;
	      else
		extra_shift = 0;

	      mn10200_insert_operand (&insn, &extension, operand,
				      ex.X_add_number, (char *) NULL,
				      0, extra_shift);

	      break;

	    case O_constant:
	      /* If this operand can be promoted, and it doesn't
		 fit into the allocated bitfield for this insn,
		 then promote it (ie this opcode does not match).  */
	      if (operand->flags
		  & (MN10200_OPERAND_PROMOTE | MN10200_OPERAND_RELAX)
		  && !check_operand (insn, operand, ex.X_add_number))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      mn10200_insert_operand (&insn, &extension, operand,
				      ex.X_add_number, (char *) NULL,
				      0, 0);
	      break;

	    default:
	      /* If this operand can be promoted, then this opcode didn't
		 match since we can't know if it needed promotion!  */
	      if (operand->flags & MN10200_OPERAND_PROMOTE)
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      /* We need to generate a fixup for this expression.  */
	      if (fc >= MAX_INSN_FIXUPS)
		as_fatal (_("too many fixups"));
	      fixups[fc].exp = ex;
	      fixups[fc].opindex = *opindex_ptr;
	      fixups[fc].reloc = BFD_RELOC_UNUSED;
	      ++fc;
	      break;
	    }

keep_going:
	  str = input_line_pointer;
	  input_line_pointer = hold;

	  while (*str == ' ' || *str == ',')
	    ++str;

	}

      /* Make sure we used all the operands!  */
      if (*str != ',')
	match = 1;

    error:
      if (match == 0)
	{
	  next_opcode = opcode + 1;
	  if (!strcmp (next_opcode->name, opcode->name))
	    {
	      opcode = next_opcode;
	      continue;
	    }

	  as_bad ("%s", errmsg);
	  return;
	}
      break;
    }

  while (ISSPACE (*str))
    ++str;

  if (*str != '\0')
    as_bad (_("junk at end of line: `%s'"), str);

  input_line_pointer = str;

  if (opcode->format == FMT_1)
    size = 1;
  else if (opcode->format == FMT_2 || opcode->format == FMT_4)
    size = 2;
  else if (opcode->format == FMT_3 || opcode->format == FMT_5)
    size = 3;
  else if (opcode->format == FMT_6)
    size = 4;
  else if (opcode->format == FMT_7)
    size = 5;
  else
    abort ();

  /* Write out the instruction.  */

  if (relaxable && fc > 0)
    {
      int type;

      /* bCC  */
      if (size == 2 && opcode->opcode != 0xfc0000)
	{
	  /* Handle bra specially.  Basically treat it like jmp so
	     that we automatically handle 8, 16 and 32 bit offsets
	     correctly as well as jumps to an undefined address.

	     It is also important to not treat it like other bCC
	     instructions since the long forms of bra is different
	     from other bCC instructions.  */
	  if (opcode->opcode == 0xea00)
	    type = 8;
	  else
	    type = 0;
	}
      /* jsr  */
      else if (size == 3 && opcode->opcode == 0xfd0000)
	type = 6;
      /* jmp  */
      else if (size == 3 && opcode->opcode == 0xfc0000)
	type = 8;
      /* bCCx  */
      else
	type = 3;

      f = frag_var (rs_machine_dependent, 8, 8 - size, type,
		    fixups[0].exp.X_add_symbol,
		    fixups[0].exp.X_add_number,
		    (char *)fixups[0].opindex);
      number_to_chars_bigendian (f, insn, size);
      if (8 - size > 4)
	{
	  number_to_chars_bigendian (f + size, 0, 4);
	  number_to_chars_bigendian (f + size + 4, 0, 8 - size - 4);
	}
      else
	number_to_chars_bigendian (f + size, 0, 8 - size);
    }

  else
    {
      f = frag_more (size);

      /* Oh, what a mess.  The instruction is in big endian format, but
	 16 and 24bit immediates are little endian!  */
      if (opcode->format == FMT_3)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xff, 1);
	  number_to_chars_littleendian (f + 1, insn & 0xffff, 2);
	}
      else if (opcode->format == FMT_6)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, insn & 0xffff, 2);
	}
      else if (opcode->format == FMT_7)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, insn & 0xffff, 2);
	  number_to_chars_littleendian (f + 4, extension & 0xff, 1);
	}
      else
	{
	  number_to_chars_bigendian (f, insn, size > 4 ? 4 : size);
	}

      /* Create any fixups.  */
      for (i = 0; i < fc; i++)
	{
	  const struct mn10200_operand *operand;

	  operand = &mn10200_operands[fixups[i].opindex];
	  if (fixups[i].reloc != BFD_RELOC_UNUSED)
	    {
	      reloc_howto_type *reloc_howto;
	      int size;
	      int offset;
	      fixS *fixP;

	      reloc_howto = bfd_reloc_type_lookup (stdoutput,
						   fixups[i].reloc);

	      if (!reloc_howto)
		abort ();

	      size = bfd_get_reloc_size (reloc_howto);

	      if (size < 1 || size > 4)
		abort ();

	      offset = 4 - size;
	      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset,
				  size,
				  &fixups[i].exp,
				  reloc_howto->pc_relative,
				  fixups[i].reloc);

	      /* PC-relative offsets are from the first byte of the
		 next instruction, not from the start of the current
		 instruction.  */
	      if (reloc_howto->pc_relative)
		fixP->fx_offset += size;
	    }
	  else
	    {
	      int reloc, pcrel, reloc_size, offset;
	      fixS *fixP;

	      reloc = BFD_RELOC_NONE;
	      /* How big is the reloc?  Remember SPLIT relocs are
		 implicitly 32bits.  */
	      reloc_size = operand->bits;

	      offset = size - reloc_size / 8;

	      /* Is the reloc pc-relative?  */
	      pcrel = (operand->flags & MN10200_OPERAND_PCREL) != 0;

	      /* Choose a proper BFD relocation type.  */
	      if (pcrel)
		{
		  if (reloc_size == 8)
		    reloc = BFD_RELOC_8_PCREL;
		  else if (reloc_size == 24)
		    reloc = BFD_RELOC_24_PCREL;
		  else
		    abort ();
		}
	      else
		{
		  if (reloc_size == 32)
		    reloc = BFD_RELOC_32;
		  else if (reloc_size == 16)
		    reloc = BFD_RELOC_16;
		  else if (reloc_size == 8)
		    reloc = BFD_RELOC_8;
		  else if (reloc_size == 24)
		    reloc = BFD_RELOC_24;
		  else
		    abort ();
		}

	      /* Convert the size of the reloc into what fix_new_exp
                 wants.  */
	      reloc_size = reloc_size / 8;
	      if (reloc_size == 8)
		reloc_size = 0;
	      else if (reloc_size == 16)
		reloc_size = 1;
	      else if (reloc_size == 32 || reloc_size == 24)
		reloc_size = 2;

	      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset,
				  reloc_size, &fixups[i].exp, pcrel,
				  ((bfd_reloc_code_real_type) reloc));

	      /* PC-relative offsets are from the first byte of the
		 next instruction, not from the start of the current
		 instruction.  */
	      if (pcrel)
		fixP->fx_offset += size;
	    }
	}
    }
}

/* If while processing a fixup, a reloc really needs to be created
   Then it is done here.  */

arelent *
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *reloc;
  reloc = (arelent *) xmalloc (sizeof (arelent));

  if (fixp->fx_subsy != NULL)
    {
      /* FIXME: We should resolve difference expressions if possible
	 here.  At least this is better than silently ignoring the
	 subtrahend.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("can't resolve `%s' {%s section} - `%s' {%s section}"),
		    fixp->fx_addsy ? S_GET_NAME (fixp->fx_addsy) : "0",
		    segment_name (fixp->fx_addsy
				  ? S_GET_SEGMENT (fixp->fx_addsy)
				  : absolute_section),
		    S_GET_NAME (fixp->fx_subsy),
		    segment_name (S_GET_SEGMENT (fixp->fx_addsy)));
    }

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->addend = fixp->fx_offset;
  return reloc;
}

int
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp;
     asection *seg;
{
  if (fragp->fr_subtype == 6
      && (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 7;
  else if (fragp->fr_subtype == 8
	   && (!S_IS_DEFINED (fragp->fr_symbol)
	       || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 10;

  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
}

long
md_pcrel_from (fixp)
     fixS *fixp;
{
  return fixp->fx_frag->fr_address;
#if 0
  if (fixp->fx_addsy != (symbolS *) NULL && !S_IS_DEFINED (fixp->fx_addsy))
    {
      /* The symbol is undefined.  Let the linker figure it out.  */
      return 0;
    }
  return fixp->fx_frag->fr_address + fixp->fx_where;
#endif
}

void
md_apply_fix3 (fixP, valP, seg)
     fixS * fixP;
     valueT * valP ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
{
  /* We shouldn't ever get here because linkrelax is nonzero.  */
  abort ();
  fixP->fx_done = 1;
}

/* Insert an operand value into an instruction.  */

static void
mn10200_insert_operand (insnp, extensionp, operand, val, file, line, shift)
     unsigned long *insnp;
     unsigned long *extensionp;
     const struct mn10200_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
     unsigned int shift;
{
  /* No need to check 24 or 32bit operands for a bit.  */
  if (operand->bits < 24
      && (operand->flags & MN10200_OPERAND_NOCHECK) == 0)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & MN10200_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      test = val;

      if (test < (offsetT) min || test > (offsetT) max)
        {
          const char *err =
            _("operand out of range (%s not between %ld and %ld)");
          char buf[100];

          sprint_value (buf, test);
          if (file == (char *) NULL)
            as_warn (err, buf, min, max);
          else
            as_warn_where (file, line, err, buf, min, max);
        }
    }

  if ((operand->flags & MN10200_OPERAND_EXTENDED) == 0)
    {
      *insnp |= (((long) val & ((1 << operand->bits) - 1))
		 << (operand->shift + shift));

      if ((operand->flags & MN10200_OPERAND_REPEATED) != 0)
	*insnp |= (((long) val & ((1 << operand->bits) - 1))
		   << (operand->shift + shift + 2));
    }
  else
    {
      *extensionp |= (val >> 16) & 0xff;
      *insnp |= val & 0xffff;
    }
}

static unsigned long
check_operand (insn, operand, val)
     unsigned long insn ATTRIBUTE_UNUSED;
     const struct mn10200_operand *operand;
     offsetT val;
{
  /* No need to check 24bit or 32bit operands for a bit.  */
  if (operand->bits < 24
      && (operand->flags & MN10200_OPERAND_NOCHECK) == 0)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & MN10200_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	return 0;
      else
	return 1;
    }
  return 1;
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1235 15
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
a22 1
#include <ctype.h>
d24 1
d84 3
a86 3
static boolean data_register_name PARAMS ((expressionS *expressionP));
static boolean address_register_name PARAMS ((expressionS *expressionP));
static boolean other_register_name PARAMS ((expressionS *expressionP));
d178 1
a178 1
 * out: A expressionS.
d185 1
a185 1
static boolean
d200 3
d213 1
a213 13
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
      return true;
    }
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
d215 4
d225 1
a225 1
 * out: A expressionS.
d232 1
a232 1
static boolean
d247 3
d260 1
a260 13
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
      return true;
    }
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
d262 4
d272 1
a272 1
 * out: A expressionS.
d279 1
a279 1
static boolean
d294 3
d307 1
a307 13
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
      return true;
    }
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
d309 4
d325 2
a326 2
     int c;
     char *arg;
d333 1
a333 1
     char *name;
d381 1
a381 1
     bfd *abfd;
d440 1
a440 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d497 1
a497 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d585 1
a585 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d665 1
a665 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d763 1
a763 1
  /* This is both a simplification (we don't have to write md_apply_fix)
d784 1
a784 1
  for (s = str; *s != '\0' && !isspace (*s); s++)
d798 1
a798 1
  while (isspace (*str))
d1032 1
a1032 1
  while (isspace (*str))
d1230 1
a1230 1
     asection *seg;
d1245 3
a1247 20

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Difference of symbols in different sections is not supported");
	  return NULL;
	}
      reloc->sym_ptr_ptr = &bfd_abs_symbol;
      reloc->addend = (S_GET_VALUE (fixp->fx_addsy)
		       - S_GET_VALUE (fixp->fx_subsy) + fixp->fx_offset);
    }
  else
    {
      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->addend = fixp->fx_offset;
    }
d1286 5
a1290 5
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
     segT seg;
d1294 1
a1294 2
  fixp->fx_done = 1;
  return 0;
d1361 1
a1361 1
     unsigned long insn;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
d25 1
a25 1
#include "subsegs.h"     
d35 2
a36 1
/* Generic assembler global variables which must be defined by all targets. */
d38 1
a38 1
/* Characters which always start a comment. */
d44 1
a44 1
/* Characters which may be used to separate multiple commands on a 
d48 1
a48 1
/* Characters which are used to indicate an exponent in a floating 
d52 1
a52 1
/* Characters which mean that a number is a floating point constant, 
a55 1

d57 1
a57 1
  /* bCC relaxing */
d61 1
a61 1
  /* bCCx relaxing */
d65 1
a65 1
  /* jsr relaxing */
d68 1
a68 1
  /* jmp relaxing */
d74 2
a75 1
/* local functions */
d88 1
a88 2

/* fixups */
d103 1
a103 1
size_t md_longopts_size = sizeof(md_longopts); 
d114 1
a114 1
/* This table is sorted. Suitable for searching by a binary search. */
d122 2
a123 1
#define DATA_REG_NAME_CNT	(sizeof(data_registers) / sizeof(struct reg_name))
d132 2
a133 1
#define ADDRESS_REG_NAME_CNT	(sizeof(address_registers) / sizeof(struct reg_name))
d140 2
a141 1
#define OTHER_REG_NAME_CNT	(sizeof(other_registers) / sizeof(struct reg_name))
d145 1
a145 1
   number from the array on success, or -1 on failure. */
d167 2
a168 2
      else 
	  return regs[middle].value;
a173 1

d184 1
d194 1
a194 1
  /* Find the spelling of the operand */
d200 2
a201 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d206 1
a206 1
      /* make the rest nice */
d209 3
a211 1
      *input_line_pointer = c;	/* put back the delimiting char */
d216 6
a221 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d236 1
d246 1
a246 1
  /* Find the spelling of the operand */
d252 2
a253 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d258 1
a258 1
      /* make the rest nice */
d261 3
a263 1
      *input_line_pointer = c;	/* put back the delimiting char */
d268 6
a273 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d288 1
d298 1
a298 1
  /* Find the spelling of the operand */
d304 2
a305 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d310 1
a310 1
      /* make the rest nice */
d313 3
a315 1
      *input_line_pointer = c;	/* put back the delimiting char */
d320 6
a325 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d332 1
a332 1
  FILE *stream;
d334 1
a334 1
  fprintf(stream, _("MN10200 options:\n\
d336 1
a336 1
} 
d348 1
a348 1
  char *name;
d355 3
a357 3
  int type;
  char *litp;
  int *sizep;
d378 1
a378 1
  
a393 1

d396 3
a398 3
  bfd *abfd;
  asection *sec;
  fragS *fragP;
d760 1
a760 1
  mn10200_hash = hash_new();
d770 1
a770 1
      if (strcmp (prev_name, op->name)) 
d785 1
a785 1
md_assemble (str) 
d799 1
a799 1
  for (s = str; *s != '\0' && ! isspace (*s); s++)
d804 2
a805 2
  /* find the first opcode with the proper name */
  opcode = (struct mn10200_opcode *)hash_find (mn10200_hash, str);
d818 1
a818 1
  for(;;)
d856 1
a856 1
	  /* Gather the operand. */
d949 1
a949 1
	  switch (ex.X_op) 
d959 1
a959 1
                   & (MN10200_OPERAND_DREG | MN10200_OPERAND_AREG)) == 0)
d965 1
a965 1
		
d973 1
a973 1
	      
d986 1
a986 1
		  && ! check_operand (insn, operand, ex.X_add_number))
d1033 1
a1033 1
        {
d1035 1
a1035 1
	  if (!strcmp(next_opcode->name, opcode->name))
d1040 1
a1040 1
	  
d1043 1
a1043 1
        }
d1046 1
a1046 1
      
d1067 1
a1067 1
         
d1074 1
a1074 1
      /* bCC */
d1084 2
a1085 2
          if (opcode->opcode == 0xea00)
            type = 8;
d1089 1
a1089 1
      /* jsr */
d1092 1
a1092 1
      /* jmp */
d1095 1
a1095 1
      /* bCCx */
d1153 2
a1154 1
	      reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
d1157 2
a1158 2
		abort();
	  
d1162 1
a1162 1
		abort();
d1167 1
a1167 1
				  &fixups[i].exp, 
d1171 3
a1173 2
	      /* PC-relative offsets are from the first byte of the next
		 instruction, not from the start of the current instruction.  */
a1191 1

d1216 2
a1217 1
	      /* Convert the size of the reloc into what fix_new_exp wants.  */
d1230 3
a1232 2
	      /* PC-relative offsets are from the first byte of the next
		 instruction, not from the start of the current instruction.  */
d1240 2
a1242 3
/* if while processing a fixup, a reloc really needs to be created */
/* then it is done here */
                 
d1255 2
a1256 2
                    _("reloc %d not supported by object file format"),
		    (int)fixp->fx_r_type);
d1274 1
a1274 1
  else 
d1288 14
a1301 24
  if (fragp->fr_subtype == 0)
    return 2;
  if (fragp->fr_subtype == 3)
    return 3;
  if (fragp->fr_subtype == 6)
    {
      if (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol))
	{
	  fragp->fr_subtype = 7;
	  return 5;
	}
      return 3;
    }
  if (fragp->fr_subtype == 8)
    {
      if (!S_IS_DEFINED (fragp->fr_symbol))
	{
	  fragp->fr_subtype = 10;
	  return 5;
	}
      return 2;
    }
} 
d1309 1
a1309 1
  if (fixp->fx_addsy != (symbolS *) NULL && ! S_IS_DEFINED (fixp->fx_addsy))
d1355 4
a1358 4
        {
          max = (1 << operand->bits) - 1;
          min = 0;
        }
a1361 1

d1411 4
a1414 4
        {
          max = (1 << operand->bits) - 1;
          min = 0;
        }
a1416 1

@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 2

   Copyright (C) 1996 Free Software Foundation.
d55 18
d74 7
a80 3
static unsigned long mn10200
  PARAMS ((unsigned long insn, const struct mn10200_operand *operand,
	   offsetT val, char *file, unsigned int line));
d82 3
a84 4
static boolean register_name PARAMS ((expressionS *expressionP));
static boolean system_register_name PARAMS ((expressionS *expressionP));
static boolean cc_name PARAMS ((expressionS *expressionP));
static bfd_reloc_code_real_type mn10200_reloc_prefix PARAMS ((void));
d114 1
a114 1
static const struct reg_name pre_defined_registers[] =
d116 4
a119 38
  { "ep", 30 },			/* ep - element ptr */
  { "gp", 4 },			/* gp - global ptr */
  { "lp", 31 },			/* lp - link ptr */
  { "r0", 0 },
  { "r1", 1 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "r16", 16 },
  { "r17", 17 },
  { "r18", 18 },
  { "r19", 19 },
  { "r2", 2 },
  { "r20", 20 },
  { "r21", 21 },
  { "r22", 22 },
  { "r23", 23 },
  { "r24", 24 },
  { "r25", 25 },
  { "r26", 26 },
  { "r27", 27 },
  { "r28", 28 },
  { "r29", 29 },
  { "r3", 3 },
  { "r30", 30 },
  { "r31", 31 },
  { "r4", 4 },
  { "r5", 5 },
  { "r6", 6 },
  { "r7", 7 },
  { "r8", 8 },
  { "r9", 9 },
  { "sp", 3 },			/* sp - stack ptr */
  { "tp", 5 },			/* tp - text ptr */
  { "zero", 0 },
d121 1
a121 2
#define REG_NAME_CNT	(sizeof(pre_defined_registers) / sizeof(struct reg_name))

d123 1
a123 1
static const struct reg_name system_registers[] = 
d125 4
a128 6
  { "eipc", 0 },
  { "eipsw", 1 },
  { "fepc", 2 },
  { "fepsw", 3 },
  { "ecr", 4 },
  { "psw", 5 },
d130 1
a130 1
#define SYSREG_NAME_CNT	(sizeof(system_registers) / sizeof(struct reg_name))
d132 1
a132 1
static const struct reg_name cc_names[] =
d134 2
a135 20
  { "c", 0x1 },
  { "ge", 0xe },
  { "gt", 0xf },
  { "h", 0xb },
  { "l", 0x1 },
  { "le", 0x7 },
  { "lt", 0x6 },
  { "n", 0x4 },
  { "nc", 0x9 },
  { "nh", 0x3 },
  { "nl", 0x9 },
  { "ns", 0xc },
  { "nv", 0x8 },
  { "nz", 0xa },
  { "p",  0xc },
  { "s", 0x4 },
  { "sa", 0xd },
  { "t", 0x5 },
  { "v", 0x0 },
  { "z", 0x2 },
d137 1
a137 1
#define CC_NAME_CNT	(sizeof(cc_names) / sizeof(struct reg_name))
d182 1
a182 1
register_name (expressionP)
d194 1
a194 1
  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT, name);
d217 1
a217 1
/* Summary of system_register_name().
d228 1
a228 1
system_register_name (expressionP)
d240 1
a240 1
  reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name);
d263 1
a263 1
/* Summary of cc_name().
d274 1
a274 1
cc_name (expressionP)
d286 1
a286 1
  reg_number = reg_name_search (cc_names, CC_NAME_CNT, name);
d291 1
a291 1
      expressionP->X_op = O_constant;
d313 2
a314 2
  fprintf(stream, "MN10200 options:\n\
none yet\n");
d355 1
a355 1
      return "bad call to md_atof";
d380 343
a722 2
  /* printf ("call to md_convert_frag \n"); */
  abort ();
d747 1
a747 1
  op     = mn10200_opcodes;
a756 1
}
d758 4
a761 22
static bfd_reloc_code_real_type
mn10200_reloc_prefix()
{
  if (strncmp(input_line_pointer, "hi0(", 4) == 0)
    {
      input_line_pointer += 4;
      return BFD_RELOC_HI16;
    }
  if (strncmp(input_line_pointer, "hi(", 3) == 0)
    {
      input_line_pointer += 3;
      return BFD_RELOC_HI16_S;
    }
  if (strncmp (input_line_pointer, "lo(", 3) == 0)
    {
      input_line_pointer += 3;
      return BFD_RELOC_LO16;
    }

  /* FIXME: implement sda, tda, zda here */

  return BFD_RELOC_UNUSED;
d772 2
a773 2
  int next_opindex;
  unsigned long insn, size;
a776 1
  bfd_reloc_code_real_type reloc;
d788 1
a788 1
      as_bad ("Unrecognized opcode: `%s'", str);
d801 3
d805 1
d810 4
a813 1
      for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
a815 1
	  char *hold;
d830 1
a830 1
	  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']')
d833 3
d840 13
a852 3

	  /* lo(), hi(), hi0(), etc... */
	  if ((reloc = mn10200_reloc_prefix()) != BFD_RELOC_UNUSED)
d854 1
a854 3
	      expression(&ex);

	      if (*input_line_pointer++ != ')')
d856 2
a857 1
		  errmsg = "syntax error: expected `)'";
d860 4
a863 2
	      
	      if (ex.X_op == O_constant)
d865 9
a873 18
		  switch (reloc)
		    {
		    case BFD_RELOC_LO16:
		      ex.X_add_number &= 0xffff;
		      break;

		    case BFD_RELOC_HI16:
		      ex.X_add_number = ((ex.X_add_number >> 16) & 0xffff);
		      break;

		    case BFD_RELOC_HI16_S:
		      ex.X_add_number = ((ex.X_add_number >> 16) & 0xffff)
			+ ((ex.X_add_number >> 15) & 1);
		      break;

		    default:
		      break;
		    }
d875 6
a880 2
		  insn = mn10200_insert_operand (insn, operand, ex.X_add_number,
					      (char *) NULL, 0);
d882 9
a890 1
	      else
d892 4
a895 7
		  if (fc > MAX_INSN_FIXUPS)
		    as_fatal ("too many fixups");

		  fixups[fc].exp = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc = reloc;
		  fc++;
d897 26
d926 3
d932 1
a932 1
	      errmsg = "illegal operand";
d935 1
a935 1
	      errmsg = "missing operand";
d938 7
d946 12
a957 2
	      insn = mn10200_insert_operand (insn, operand, ex.X_add_number,
					  (char *) NULL, 0);
d961 15
a975 2
	      insn = mn10200_insert_operand (insn, operand, ex.X_add_number,
					  (char *) NULL, 0);
d979 9
d990 1
a990 1
		as_fatal ("too many fixups");
d998 1
a998 2
	    }

d1002 1
a1002 1
	  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']')
d1004 1
d1006 4
a1009 1
      match = 1;
d1015 1
a1015 1
	  if (next_opcode->opcode != 0 && !strcmp(next_opcode->name, opcode->name))
d1031 1
a1031 1
    as_bad ("junk at end of line: `%s'", str);
d1035 7
a1041 4
  /* Write out the instruction.

     Four byte insns have an opcode with the two high bits on.  */ 
  if ((insn & 0x0600) == 0x0600)
d1043 2
d1046 7
a1052 3
    size = 2;
  f = frag_more (size);
  md_number_to_chars (f, insn, size);
d1054 24
a1077 17
  /* Create any fixups.  At this point we do not use a
     bfd_reloc_code_real_type, but instead just use the
     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
     handle fixups for any operand type, although that is admittedly
     not a very exciting feature.  We pick a BFD reloc type in
     md_apply_fix.  */
  for (i = 0; i < fc; i++)
    {
      const struct mn10200_operand *operand;

      operand = &mn10200_operands[fixups[i].opindex];
      if (fixups[i].reloc != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
	  int size;
	  int offset;
	  fixS *fixP;
d1079 13
a1091 5
	  if (!reloc_howto)
	    abort();
	  
	  size = bfd_get_reloc_size (reloc_howto);
	  offset = 4 - size;
d1093 3
a1095 2
	  if (size < 1 || size > 4)
	    abort();
d1097 17
a1113 4
	  fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset, size,
			      &fixups[i].exp, 
			      reloc_howto->pc_relative,
			      fixups[i].reloc);
d1117 96
a1212 5
	  fix_new_exp (frag_now, f - frag_now->fr_literal, 4,
		       &fixups[i].exp,
		       1 /* FIXME: MN10200_OPERAND_RELATIVE ??? */,
		       ((bfd_reloc_code_real_type)
			(fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
d1227 2
a1228 3
  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
d1233 2
a1234 1
                    "reloc %d not supported by object file format", (int)fixp->fx_r_type);
d1237 21
a1257 2
  reloc->addend = fixp->fx_addnumber;
  /*  printf("tc_gen_reloc: addr=%x  addend=%x\n", reloc->address, reloc->addend); */
d1266 23
a1288 1
  return 0;
d1295 2
d1303 1
d1312 5
a1316 2
  valueT value;
  char *where;
d1318 15
a1332 1
  if (fixp->fx_addsy == (symbolS *) NULL)
d1334 4
a1337 9
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    value = *valuep;
  else
    {
      value = fixp->fx_offset;
      if (fixp->fx_subsy != (symbolS *) NULL)
d1339 2
a1340 8
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixp->fx_subsy);
	  else
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    "expression too complex");
	    }
d1342 5
a1346 1
    }
d1348 1
a1348 1
  /* printf("md_apply_fix: value=0x%x  type=%d\n",  value, fixp->fx_r_type); */
a1349 6
  if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int opindex;
      const struct mn10200_operand *operand;
      char *where;
      unsigned long insn;
d1351 5
a1355 2
      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
      operand = &mn10200_operands[opindex];
d1357 7
a1363 2
      /* Fetch the instruction, insert the fully resolved operand
         value, and stuff the instruction back again.
d1365 4
a1368 3
	 Note the instruction has been stored in little endian
	 format!  */
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
d1370 3
a1372 20
      insn = bfd_getl32((unsigned char *) where);
      insn = mn10200_insert_operand (insn, operand, (offsetT) value,
				  fixp->fx_file, fixp->fx_line);
      bfd_putl32((bfd_vma) insn, (unsigned char *) where);

      if (fixp->fx_done)
	{
	  /* Nothing else to do here. */
	  return 1;
	}

      /* Determine a BFD reloc value based on the operand information.  
	 We are only prepared to turn a few of the operands into relocs. */

	{
	  as_bad_where(fixp->fx_file, fixp->fx_line,
		       "unresolved expression that must be resolved");
	  fixp->fx_done = 1;
	  return 1;
	}
d1374 1
a1374 1
  else if (fixp->fx_done)
d1376 2
a1377 8
      /* We still have to insert the value into memory!  */
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
      if (fixp->fx_size == 1)
	*where = value & 0xff;
      if (fixp->fx_size == 2)
	bfd_putl16(value & 0xffff, (unsigned char *) where);
      if (fixp->fx_size == 4)
	bfd_putl32(value, (unsigned char *) where);
a1378 3

  fixp->fx_addnumber = value;
  return 1;
a1380 3

/* Insert an operand value into an instruction.  */

d1382 1
a1382 1
mn10200_insert_operand (insn, operand, val, file, line)
a1385 2
     char *file;
     unsigned int line;
d1387 3
a1389 1
  if (operand->bits != 16)
d1394 6
d1409 3
a1411 11
        {
          const char *err =
            "operand out of range (%s not between %ld and %ld)";
          char buf[100];

          sprint_value (buf, test);
          if (file == (char *) NULL)
            as_warn (err, buf, min, max);
          else
            as_warn_where (file, line, err, buf, min, max);
        }
d1413 1
a1413 3

  insn |= (((long) val & ((1 << operand->bits) - 1)) << operand->shift);
  return insn;
@


1.1
log
@file tc-mn10200.c was initially added on branch CYGNUS.
@
text
@d1 884
@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@a0 1387
/* tc-mn10200.c -- Assembler code for the Matsushita 10200

   Copyright (C) 1996, 1997 Free Software Foundation.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include <ctype.h>
#include "as.h"
#include "subsegs.h"     
#include "opcode/mn10200.h"

/* Structure to hold information about predefined registers.  */
struct reg_name
{
  const char *name;
  int value;
};

/* Generic assembler global variables which must be defined by all targets. */

/* Characters which always start a comment. */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = ";#";

/* Characters which may be used to separate multiple commands on a 
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating 
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant, 
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";


const relax_typeS md_relax_table[] = {
  /* bCC relaxing */
  {0x7f, -0x80, 2, 1},
  {0x7fff, -0x8000, 5, 2},
  {0x7fffff, -0x800000, 7, 0},
  /* bCCx relaxing */
  {0x7f, -0x80, 3, 4},
  {0x7fff, -0x8000, 6, 5},
  {0x7fffff, -0x800000, 8, 0},
  /* jsr relaxing */
  {0x7fff, -0x8000, 3, 7},
  {0x7fffff, -0x8000000, 5, 0},
  /* jmp relaxing */
  {0x7f, -0x80, 2, 9},
  {0x7fff, -0x8000, 3, 10},
  {0x7fffff, -0x8000000, 5, 0},

};
/* local functions */
static void mn10200_insert_operand PARAMS ((unsigned long *, unsigned long *,
					    const struct mn10200_operand *,
					    offsetT, char *, unsigned,
					    unsigned));
static unsigned long check_operand PARAMS ((unsigned long,
					    const struct mn10200_operand *,
					    offsetT));
static int reg_name_search PARAMS ((const struct reg_name *, int, const char *));
static boolean data_register_name PARAMS ((expressionS *expressionP));
static boolean address_register_name PARAMS ((expressionS *expressionP));
static boolean other_register_name PARAMS ((expressionS *expressionP));


/* fixups */
#define MAX_INSN_FIXUPS (5)
struct mn10200_fixup
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};
struct mn10200_fixup fixups[MAX_INSN_FIXUPS];
static int fc;

const char *md_shortopts = "";
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof(md_longopts); 

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { NULL,       NULL,           0 }
};

/* Opcode hash table.  */
static struct hash_control *mn10200_hash;

/* This table is sorted. Suitable for searching by a binary search. */
static const struct reg_name data_registers[] =
{
  { "d0", 0 },
  { "d1", 1 },
  { "d2", 2 },
  { "d3", 3 },
};
#define DATA_REG_NAME_CNT	(sizeof(data_registers) / sizeof(struct reg_name))

static const struct reg_name address_registers[] =
{
  { "a0", 0 },
  { "a1", 1 },
  { "a2", 2 },
  { "a3", 3 },
};
#define ADDRESS_REG_NAME_CNT	(sizeof(address_registers) / sizeof(struct reg_name))

static const struct reg_name other_registers[] =
{
  { "mdr", 0 },
  { "psw", 0 },
};
#define OTHER_REG_NAME_CNT	(sizeof(other_registers) / sizeof(struct reg_name))

/* reg_name_search does a binary search of the given register table
   to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure. */

static int
reg_name_search (regs, regcount, name)
     const struct reg_name *regs;
     int regcount;
     const char *name;
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else 
	  return regs[middle].value;
    }
  while (low <= high);
  return -1;
}


/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: A expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
static boolean
data_register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (data_registers, DATA_REG_NAME_CNT, name);

  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      *input_line_pointer = c;	/* put back the delimiting char */
      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
      return false;
    }
}

/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: A expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
static boolean
address_register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (address_registers, ADDRESS_REG_NAME_CNT, name);

  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      *input_line_pointer = c;	/* put back the delimiting char */
      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
      return false;
    }
}

/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: A expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
static boolean
other_register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (other_registers, OTHER_REG_NAME_CNT, name);

  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      *input_line_pointer = c;	/* put back the delimiting char */
      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
      return false;
    }
}

void
md_show_usage (stream)
  FILE *stream;
{
  fprintf(stream, "MN10200 options:\n\
none yet\n");
} 

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  return 0;
}

symbolS *
md_undefined_symbol (name)
  char *name;
{
  return 0;
}

char *
md_atof (type, litp, sizep)
  int type;
  char *litp;
  int *sizep;
{
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return "bad call to md_atof";
    }
  
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  for (i = prec - 1; i >= 0; i--)
    {
      md_number_to_chars (litp, (valueT) words[i], 2);
      litp += 2;
    }

  return NULL;
}


void
md_convert_frag (abfd, sec, fragP)
  bfd *abfd;
  asection *sec;
  fragS *fragP;
{
  static unsigned long label_count = 0;
  char buf[40];

  subseg_change (sec, 0);
  if (fragP->fr_subtype == 0)
    {
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 2;
    }
  else if (fragP->fr_subtype == 1)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset] & 0xff;

      switch (opcode)
	{
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, "%s_%d", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 1, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 1, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 2] = 0xfc;
      fix_new (fragP, fragP->fr_fix + 3, 2, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else if (fragP->fr_subtype == 2)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset] & 0xff;

      switch (opcode)
	{
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, "%s_%d", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 1, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 1, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 2] = 0xf4;
      fragP->fr_literal[offset + 3] = 0xe0;
      fix_new (fragP, fragP->fr_fix + 4, 4, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 7;
    }
  else if (fragP->fr_subtype == 3)
    {
      fix_new (fragP, fragP->fr_fix + 2, 1, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 4)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xfc:
	  opcode = 0xfd;
	  break;
	case 0xfd:
	  opcode = 0xfc;
	  break;
	case 0xfe:
	  opcode = 0xff;
	  break;
	case 0xff:
	  opcode = 0xfe;
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	case 0xec:
	  opcode = 0xed;
	  break;
	case 0xed:
	  opcode = 0xec;
	  break;
	case 0xee:
	  opcode = 0xef;
	  break;
	case 0xef:
	  opcode = 0xee;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, "%s_%d", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 2, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xfc;
      fix_new (fragP, fragP->fr_fix + 4, 2, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 6;
    }
  else if (fragP->fr_subtype == 5)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xfc:
	  opcode = 0xfd;
	  break;
	case 0xfd:
	  opcode = 0xfc;
	  break;
	case 0xfe:
	  opcode = 0xff;
	  break;
	case 0xff:
	  opcode = 0xfe;
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	case 0xec:
	  opcode = 0xed;
	  break;
	case 0xed:
	  opcode = 0xec;
	  break;
	case 0xee:
	  opcode = 0xef;
	  break;
	case 0xef:
	  opcode = 0xee;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, "%s_%d", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset + 2, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xf4;
      fragP->fr_literal[offset + 4] = 0xe0;
      fix_new (fragP, fragP->fr_fix + 5, 4, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 8;
    }
  else if (fragP->fr_subtype == 6)
    {
      fix_new (fragP, fragP->fr_fix + 1, 2, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 7)
    {
      int offset = fragP->fr_fix;
      fragP->fr_literal[offset] = 0xf4;
      fragP->fr_literal[offset + 1] = 0xe1;

      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else if (fragP->fr_subtype == 8)
    {
      fragP->fr_literal[fragP->fr_fix] = 0xea;
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 2;
    }
  else if (fragP->fr_subtype == 9)
    {
      int offset = fragP->fr_fix;
      fragP->fr_literal[offset] = 0xfc;

      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
	       fragP->fr_offset + 1, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 10)
    {
      int offset = fragP->fr_fix;
      fragP->fr_literal[offset] = 0xf4;
      fragP->fr_literal[offset + 1] = 0xe0;

      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
	       fragP->fr_offset + 2, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else
    abort ();
}

valueT
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_begin ()
{
  char *prev_name = "";
  register const struct mn10200_opcode *op;

  mn10200_hash = hash_new();

  /* Insert unique names into hash table.  The MN10200 instruction set
     has many identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */

  op = mn10200_opcodes;
  while (op->name)
    {
      if (strcmp (prev_name, op->name)) 
	{
	  prev_name = (char *) op->name;
	  hash_insert (mn10200_hash, op->name, (char *) op);
	}
      op++;
    }

  /* This is both a simplification (we don't have to write md_apply_fix)
     and support for future optimizations (branch shortening and similar
     stuff in the linker.  */
  linkrelax = 1;
}

void
md_assemble (str) 
     char *str;
{
  char *s;
  struct mn10200_opcode *opcode;
  struct mn10200_opcode *next_opcode;
  const unsigned char *opindex_ptr;
  int next_opindex, relaxable;
  unsigned long insn, extension, size = 0;
  char *f;
  int i;
  int match;

  /* Get the opcode.  */
  for (s = str; *s != '\0' && ! isspace (*s); s++)
    ;
  if (*s != '\0')
    *s++ = '\0';

  /* find the first opcode with the proper name */
  opcode = (struct mn10200_opcode *)hash_find (mn10200_hash, str);
  if (opcode == NULL)
    {
      as_bad ("Unrecognized opcode: `%s'", str);
      return;
    }

  str = s;
  while (isspace (*str))
    ++str;

  input_line_pointer = str;

  for(;;)
    {
      const char *errmsg = NULL;
      int op_idx;
      char *hold;
      int extra_shift = 0;

      relaxable = 0;
      fc = 0;
      match = 0;
      next_opindex = 0;
      insn = opcode->opcode;
      extension = 0;
      for (op_idx = 1, opindex_ptr = opcode->operands;
	   *opindex_ptr != 0;
	   opindex_ptr++, op_idx++)
	{
	  const struct mn10200_operand *operand;
	  expressionS ex;

	  if (next_opindex == 0)
	    {
	      operand = &mn10200_operands[*opindex_ptr];
	    }
	  else
	    {
	      operand = &mn10200_operands[next_opindex];
	      next_opindex = 0;
	    }

	  errmsg = NULL;

	  while (*str == ' ' || *str == ',')
	    ++str;

	  if (operand->flags & MN10200_OPERAND_RELAX)
	    relaxable = 1;

	  /* Gather the operand. */
	  hold = input_line_pointer;
	  input_line_pointer = str;

	  if (operand->flags & MN10200_OPERAND_PAREN)
	    {
	      if (*input_line_pointer != ')' && *input_line_pointer != '(')
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      input_line_pointer++;
	      goto keep_going;
	    }
	  /* See if we can match the operands.  */
	  else if (operand->flags & MN10200_OPERAND_DREG)
	    {
	      if (!data_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10200_OPERAND_AREG)
	    {
	      if (!address_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10200_OPERAND_PSW)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcmp (start, "psw") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10200_OPERAND_MDR)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcmp (start, "mdr") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (data_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (address_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (other_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (*str == ')' || *str == '(')
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else
	    {
	      expression (&ex);
	    }

	  switch (ex.X_op) 
	    {
	    case O_illegal:
	      errmsg = "illegal operand";
	      goto error;
	    case O_absent:
	      errmsg = "missing operand";
	      goto error;
	    case O_register:
	      if ((operand->flags
                   & (MN10200_OPERAND_DREG | MN10200_OPERAND_AREG)) == 0)
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
		
	      if (opcode->format == FMT_2 || opcode->format == FMT_5)
		extra_shift = 8;
	      else if (opcode->format == FMT_3 || opcode->format == FMT_6
		       || opcode->format == FMT_7)
		extra_shift = 16;
	      else
		extra_shift = 0;
	      
	      mn10200_insert_operand (&insn, &extension, operand,
				      ex.X_add_number, (char *) NULL,
				      0, extra_shift);

	      break;

	    case O_constant:
	      /* If this operand can be promoted, and it doesn't
		 fit into the allocated bitfield for this insn,
		 then promote it (ie this opcode does not match).  */
	      if (operand->flags
		  & (MN10200_OPERAND_PROMOTE | MN10200_OPERAND_RELAX)
		  && ! check_operand (insn, operand, ex.X_add_number))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      mn10200_insert_operand (&insn, &extension, operand,
				      ex.X_add_number, (char *) NULL,
				      0, 0);
	      break;

	    default:
	      /* If this operand can be promoted, then this opcode didn't
		 match since we can't know if it needed promotion!  */
	      if (operand->flags & MN10200_OPERAND_PROMOTE)
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      /* We need to generate a fixup for this expression.  */
	      if (fc >= MAX_INSN_FIXUPS)
		as_fatal ("too many fixups");
	      fixups[fc].exp = ex;
	      fixups[fc].opindex = *opindex_ptr;
	      fixups[fc].reloc = BFD_RELOC_UNUSED;
	      ++fc;
	      break;
	    }

keep_going:
	  str = input_line_pointer;
	  input_line_pointer = hold;

	  while (*str == ' ' || *str == ',')
	    ++str;

	}

      /* Make sure we used all the operands!  */
      if (*str != ',')
	match = 1;

    error:
      if (match == 0)
        {
	  next_opcode = opcode + 1;
	  if (!strcmp(next_opcode->name, opcode->name))
	    {
	      opcode = next_opcode;
	      continue;
	    }
	  
	  as_bad ("%s", errmsg);
	  return;
        }
      break;
    }
      
  while (isspace (*str))
    ++str;

  if (*str != '\0')
    as_bad ("junk at end of line: `%s'", str);

  input_line_pointer = str;

  if (opcode->format == FMT_1)
    size = 1;
  else if (opcode->format == FMT_2 || opcode->format == FMT_4)
    size = 2;
  else if (opcode->format == FMT_3 || opcode->format == FMT_5)
    size = 3;
  else if (opcode->format == FMT_6)
    size = 4;
  else if (opcode->format == FMT_7)
    size = 5;
  else
    abort ();
         
  /* Write out the instruction.  */

  if (relaxable && fc > 0)
    {
      int type;

      /* bCC */
      if (size == 2 && opcode->opcode != 0xfc0000)
	type = 0;
      /* jsr */
      else if (size == 3 && opcode->opcode == 0xfd0000)
	type = 6;
      /* jmp */
      else if (size == 3 && opcode->opcode == 0xfc0000)
	type = 8;
      /* bCCx */
      else
	type = 3;

      f = frag_var (rs_machine_dependent, 8, 8 - size, type,
		    fixups[0].exp.X_add_symbol,
		    fixups[0].exp.X_add_number,
		    (char *)fixups[0].opindex);
      number_to_chars_bigendian (f, insn, size);
      if (8 - size > 4)
	{
	  number_to_chars_bigendian (f + size, 0, 4);
	  number_to_chars_bigendian (f + size + 4, 0, 8 - size - 4);
	}
      else
	number_to_chars_bigendian (f + size, 0, 8 - size);
    }

  else
    {
      f = frag_more (size);

      /* Oh, what a mess.  The instruction is in big endian format, but
	 16 and 24bit immediates are little endian!  */
      if (opcode->format == FMT_3)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xff, 1);
	  number_to_chars_littleendian (f + 1, insn & 0xffff, 2);
	}
      else if (opcode->format == FMT_6)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, insn & 0xffff, 2);
	}
      else if (opcode->format == FMT_7)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, insn & 0xffff, 2);
	  number_to_chars_littleendian (f + 4, extension & 0xff, 1);
	}
      else
	{
	  number_to_chars_bigendian (f, insn, size > 4 ? 4 : size);
	}

      /* Create any fixups.  */
      for (i = 0; i < fc; i++)
	{
	  const struct mn10200_operand *operand;

	  operand = &mn10200_operands[fixups[i].opindex];
	  if (fixups[i].reloc != BFD_RELOC_UNUSED)
	    {
	      reloc_howto_type *reloc_howto;
	      int size;
	      int offset;
	      fixS *fixP;

	      reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);

	      if (!reloc_howto)
		abort();
	  
	      size = bfd_get_reloc_size (reloc_howto);

	      if (size < 1 || size > 4)
		abort();

	      offset = 4 - size;
	      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset,
				  size,
				  &fixups[i].exp, 
				  reloc_howto->pc_relative,
				  fixups[i].reloc);
	    }
	  else
	    {
	      int reloc, pcrel, reloc_size, offset;
	      fixS *fixP;

	      reloc = BFD_RELOC_NONE;
	      /* How big is the reloc?  Remember SPLIT relocs are
		 implicitly 32bits.  */
	      reloc_size = operand->bits;

	      offset = size - reloc_size / 8;

	      /* Is the reloc pc-relative?  */
	      pcrel = (operand->flags & MN10200_OPERAND_PCREL) != 0;


	      /* Choose a proper BFD relocation type.  */
	      if (pcrel)
		{
		  if (reloc_size == 8)
		    reloc = BFD_RELOC_8_PCREL;
		  else if (reloc_size == 24)
		    reloc = BFD_RELOC_24_PCREL;
		  else
		    abort ();
		}
	      else
		{
		  if (reloc_size == 32)
		    reloc = BFD_RELOC_32;
		  else if (reloc_size == 16)
		    reloc = BFD_RELOC_16;
		  else if (reloc_size == 8)
		    reloc = BFD_RELOC_8;
		  else if (reloc_size == 24)
		    reloc = BFD_RELOC_24;
		  else
		    abort ();
		}

	      /* Convert the size of the reloc into what fix_new_exp wants.  */
	      reloc_size = reloc_size / 8;
	      if (reloc_size == 8)
		reloc_size = 0;
	      else if (reloc_size == 16)
		reloc_size = 1;
	      else if (reloc_size == 32 || reloc_size == 24)
		reloc_size = 2;

	      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset,
				  reloc_size, &fixups[i].exp, pcrel,
				  ((bfd_reloc_code_real_type) reloc));
	      if (pcrel)
		fixP->fx_offset += offset;
	    }
	}
    }
}


/* if while processing a fixup, a reloc really needs to be created */
/* then it is done here */
                 
arelent *
tc_gen_reloc (seg, fixp)
     asection *seg;
     fixS *fixp;
{
  arelent *reloc;
  reloc = (arelent *) xmalloc (sizeof (arelent));

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    "reloc %d not supported by object file format",
		    (int)fixp->fx_r_type);
      return NULL;
    }
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      reloc->sym_ptr_ptr = &bfd_abs_symbol;
      reloc->addend = (S_GET_VALUE (fixp->fx_addsy)
		       - S_GET_VALUE (fixp->fx_subsy) + fixp->fx_offset);
    }
  else 
    {
      reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
      reloc->addend = fixp->fx_offset;
    }
  return reloc;
}

int
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp;
     asection *seg;
{
  if (fragp->fr_subtype == 0)
    return 2;
  if (fragp->fr_subtype == 3)
    return 3;
  if (fragp->fr_subtype == 6)
    {
      if (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol))
	{
	  fragp->fr_subtype = 7;
	  return 5;
	}
      return 3;
    }
  if (fragp->fr_subtype == 8)
    {
      if (!S_IS_DEFINED (fragp->fr_symbol))
	{
	  fragp->fr_subtype = 10;
	  return 5;
	}
      return 2;
    }
} 

long
md_pcrel_from (fixp)
     fixS *fixp;
{
  return fixp->fx_frag->fr_address;
#if 0
  if (fixp->fx_addsy != (symbolS *) NULL && ! S_IS_DEFINED (fixp->fx_addsy))
    {
      /* The symbol is undefined.  Let the linker figure it out.  */
      return 0;
    }
  return fixp->fx_frag->fr_address + fixp->fx_where;
#endif
}

int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
     segT seg;
{
  /* We shouldn't ever get here because linkrelax is nonzero.  */
  abort ();
  fixp->fx_done = 1;
  return 0;
}

/* Insert an operand value into an instruction.  */

static void
mn10200_insert_operand (insnp, extensionp, operand, val, file, line, shift)
     unsigned long *insnp;
     unsigned long *extensionp;
     const struct mn10200_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
     unsigned int shift;
{
  /* No need to check 24 or 32bit operands for a bit.  */
  if (operand->bits < 24
      && (operand->flags & MN10200_OPERAND_NOCHECK) == 0)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & MN10200_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));
	}
      else
        {
          max = (1 << operand->bits) - 1;
          min = 0;
        }

      test = val;


      if (test < (offsetT) min || test > (offsetT) max)
        {
          const char *err =
            "operand out of range (%s not between %ld and %ld)";
          char buf[100];

          sprint_value (buf, test);
          if (file == (char *) NULL)
            as_warn (err, buf, min, max);
          else
            as_warn_where (file, line, err, buf, min, max);
        }
    }

  if ((operand->flags & MN10200_OPERAND_EXTENDED) == 0)
    {
      *insnp |= (((long) val & ((1 << operand->bits) - 1))
		 << (operand->shift + shift));

      if ((operand->flags & MN10200_OPERAND_REPEATED) != 0)
	*insnp |= (((long) val & ((1 << operand->bits) - 1))
		   << (operand->shift + shift + 2));
    }
  else
    {
      *extensionp |= (val >> 16) & 0xff;
      *insnp |= val & 0xffff;
    }
}

static unsigned long
check_operand (insn, operand, val)
     unsigned long insn;
     const struct mn10200_operand *operand;
     offsetT val;
{
  /* No need to check 24bit or 32bit operands for a bit.  */
  if (operand->bits < 24
      && (operand->flags & MN10200_OPERAND_NOCHECK) == 0)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & MN10200_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));
	}
      else
        {
          max = (1 << operand->bits) - 1;
          min = 0;
        }

      test = val;


      if (test < (offsetT) min || test > (offsetT) max)
	return 0;
      else
	return 1;
    }
  return 1;
}
@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
d58 3
a60 3
  {0x81, -0x7e, 2, 1},
  {0x8004, -0x7ffb, 5, 2},
  {0x800006, -0x7ffff9, 7, 0},
d62 3
a64 3
  {0x81, -0x7e, 3, 4},
  {0x8004, -0x7ffb, 6, 5},
  {0x800006, -0x7ffff9, 8, 0},
d66 2
a67 2
  {0x8004, -0x7ffb, 3, 7},
  {0x800006, -0x7ffff9, 5, 0},
d69 3
a71 3
  {0x81, -0x7e, 2, 9},
  {0x8004, -0x7ffb, 3, 10},
  {0x800006, -0x7ffff9, 5, 0},
d314 2
a315 2
  fprintf(stream, _("MN10200 options:\n\
none yet\n"));
d356 1
a356 1
      return _("bad call to md_atof");
d388 1
a388 1
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
d436 1
a436 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d439 1
a439 1
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
d445 1
a445 1
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
d493 1
a493 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d496 1
a496 1
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
d503 1
a503 1
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
d510 1
a510 1
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
d581 1
a581 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d584 1
a584 1
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
d590 1
a590 1
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
d661 1
a661 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d664 1
a664 1
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
d671 1
a671 1
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
d678 1
a678 1
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
d689 1
a689 1
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
d697 1
a697 1
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
d707 1
a707 1
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
d718 1
a718 1
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
d789 1
a789 1
      as_bad (_("Unrecognized opcode: `%s'"), str);
d933 1
a933 1
	      errmsg = _("illegal operand");
d936 1
a936 1
	      errmsg = _("missing operand");
d991 1
a991 1
		as_fatal (_("too many fixups"));
d1032 1
a1032 1
    as_bad (_("junk at end of line: `%s'"), str);
d1057 1
a1057 13
	{
	  /* Handle bra specially.  Basically treat it like jmp so
	     that we automatically handle 8, 16 and 32 bit offsets
	     correctly as well as jumps to an undefined address.

	     It is also important to not treat it like other bCC
	     instructions since the long forms of bra is different
	     from other bCC instructions.  */
          if (opcode->opcode == 0xea00)
            type = 8;
	  else
	    type = 0;
	}
a1137 5

	      /* PC-relative offsets are from the first byte of the next
		 instruction, not from the start of the current instruction.  */
	      if (reloc_howto->pc_relative)
		fixP->fx_offset += size;
a1190 3

	      /* PC-relative offsets are from the first byte of the next
		 instruction, not from the start of the current instruction.  */
d1192 1
a1192 1
		fixP->fx_offset += size;
d1214 1
a1214 1
                    _("reloc %d not supported by object file format"),
a1221 7
      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Difference of symbols in different sections is not supported");
	  return NULL;
	}
d1228 1
a1228 2
      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d1327 1
a1327 1
            _("operand out of range (%s not between %ld and %ld)");
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d24 1
a24 1
#include "subsegs.h"
d34 1
a34 2
/* Generic assembler global variables which must be defined by all
   targets.  */
d36 1
a36 1
/* Characters which always start a comment.  */
d42 1
a42 1
/* Characters which may be used to separate multiple commands on a
d46 1
a46 1
/* Characters which are used to indicate an exponent in a floating
d50 1
a50 1
/* Characters which mean that a number is a floating point constant,
d54 1
d56 1
a56 1
  /* bCC relaxing  */
d60 1
a60 1
  /* bCCx relaxing  */
d64 1
a64 1
  /* jsr relaxing  */
d67 1
a67 1
  /* jmp relaxing  */
d73 1
a73 2

/* Local functions.  */
d86 2
a87 1
/* Fixups.  */
d102 1
a102 1
size_t md_longopts_size = sizeof (md_longopts);
d113 1
a113 1
/* This table is sorted. Suitable for searching by a binary search.  */
d121 1
a121 2
#define DATA_REG_NAME_CNT				\
  (sizeof (data_registers) / sizeof (struct reg_name))
d130 1
a130 2
#define ADDRESS_REG_NAME_CNT					\
  (sizeof (address_registers) / sizeof (struct reg_name))
d137 1
a137 2
#define OTHER_REG_NAME_CNT				\
  (sizeof (other_registers) / sizeof (struct reg_name))
d141 1
a141 1
   number from the array on success, or -1 on failure.  */
d163 2
a164 2
      else
	return regs[middle].value;
d170 1
a180 1

d190 1
a190 1
  /* Find the spelling of the operand.  */
d196 2
a197 2
  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
d202 1
a202 1
      /* Make the rest nice.  */
d205 1
a205 3

      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d210 3
a212 6
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
a226 1

d236 1
a236 1
  /* Find the spelling of the operand.  */
d242 2
a243 2
  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
d248 1
a248 1
      /* Make the rest nice.  */
d251 1
a251 3

      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d256 3
a258 6
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
a272 1

d282 1
a282 1
  /* Find the spelling of the operand.  */
d288 2
a289 2
  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
d294 1
a294 1
      /* Make the rest nice.  */
d297 1
a297 3

      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d302 3
a304 6
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
d311 1
a311 1
     FILE *stream;
d313 1
a313 1
  fprintf (stream, _("MN10200 options:\n\
d315 1
a315 1
}
d327 1
a327 1
     char *name;
d334 3
a336 3
     int type;
     char *litp;
     int *sizep;
d357 1
a357 1

d373 1
d376 3
a378 3
     bfd *abfd;
     asection *sec;
     fragS *fragP;
d740 1
a740 1
  mn10200_hash = hash_new ();
d750 1
a750 1
      if (strcmp (prev_name, op->name))
d765 1
a765 1
md_assemble (str)
d779 1
a779 1
  for (s = str; *s != '\0' && !isspace (*s); s++)
d784 2
a785 2
  /* Find the first opcode with the proper name.  */
  opcode = (struct mn10200_opcode *) hash_find (mn10200_hash, str);
d798 1
a798 1
  for (;;)
d836 1
a836 1
	  /* Gather the operand.  */
d929 1
a929 1
	  switch (ex.X_op)
d939 1
a939 1
		   & (MN10200_OPERAND_DREG | MN10200_OPERAND_AREG)) == 0)
d945 1
a945 1

d953 1
a953 1

d966 1
a966 1
		  && !check_operand (insn, operand, ex.X_add_number))
d1013 1
a1013 1
	{
d1015 1
a1015 1
	  if (!strcmp (next_opcode->name, opcode->name))
d1020 1
a1020 1

d1023 1
a1023 1
	}
d1026 1
a1026 1

d1047 1
a1047 1

d1054 1
a1054 1
      /* bCC  */
d1064 2
a1065 2
	  if (opcode->opcode == 0xea00)
	    type = 8;
d1069 1
a1069 1
      /* jsr  */
d1072 1
a1072 1
      /* jmp  */
d1075 1
a1075 1
      /* bCCx  */
d1133 1
a1133 2
	      reloc_howto = bfd_reloc_type_lookup (stdoutput,
						   fixups[i].reloc);
d1136 2
a1137 2
		abort ();

d1141 1
a1141 1
		abort ();
d1146 1
a1146 1
				  &fixups[i].exp,
d1150 2
a1151 3
	      /* PC-relative offsets are from the first byte of the
		 next instruction, not from the start of the current
		 instruction.  */
d1170 1
d1195 1
a1195 2
	      /* Convert the size of the reloc into what fix_new_exp
                 wants.  */
d1208 2
a1209 3
	      /* PC-relative offsets are from the first byte of the
		 next instruction, not from the start of the current
		 instruction.  */
a1216 2
/* If while processing a fixup, a reloc really needs to be created
   Then it is done here.  */
d1218 3
d1233 2
a1234 2
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
d1252 1
a1252 1
  else
d1266 24
a1289 14
  if (fragp->fr_subtype == 6
      && (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 7;
  else if (fragp->fr_subtype == 8
	   && (!S_IS_DEFINED (fragp->fr_symbol)
	       || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 10;

  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
}
d1297 1
a1297 1
  if (fixp->fx_addsy != (symbolS *) NULL && !S_IS_DEFINED (fixp->fx_addsy))
d1343 4
a1346 4
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}
d1350 1
d1400 4
a1403 4
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}
d1406 1
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d23 1
a24 1
#include "safe-ctype.h"
d84 3
a86 3
static bfd_boolean data_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean address_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean other_register_name PARAMS ((expressionS *expressionP));
d178 1
a178 1
 * out: An expressionS.
d185 1
a185 1
static bfd_boolean
a199 3
  /* Put back the delimiting char.  */
  *input_line_pointer = c;

d210 13
a222 1
      return TRUE;
a223 4

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
d230 1
a230 1
 * out: An expressionS.
d237 1
a237 1
static bfd_boolean
a251 3
  /* Put back the delimiting char.  */
  *input_line_pointer = c;

d262 13
a274 1
      return TRUE;
a275 4

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
d282 1
a282 1
 * out: An expressionS.
d289 1
a289 1
static bfd_boolean
a303 3
  /* Put back the delimiting char.  */
  *input_line_pointer = c;

d314 13
a326 1
      return TRUE;
a327 4

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
d340 2
a341 2
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d348 1
a348 1
     char *name ATTRIBUTE_UNUSED;
d396 1
a396 1
     bfd *abfd ATTRIBUTE_UNUSED;
d455 1
a455 1
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
d512 1
a512 1
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
d600 1
a600 1
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
d680 1
a680 1
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
d778 1
a778 1
  /* This is both a simplification (we don't have to write md_apply_fix3)
d799 1
a799 1
  for (s = str; *s != '\0' && !ISSPACE (*s); s++)
d813 1
a813 1
  while (ISSPACE (*str))
d1047 1
a1047 1
  while (ISSPACE (*str))
d1245 1
a1245 1
     asection *seg ATTRIBUTE_UNUSED;
d1260 20
a1279 3
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->addend = fixp->fx_offset;
d1318 5
a1322 5
void
md_apply_fix3 (fixP, valP, seg)
     fixS * fixP;
     valueT * valP ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
d1326 2
a1327 1
  fixP->fx_done = 1;
d1394 1
a1394 1
     unsigned long insn ATTRIBUTE_UNUSED;
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a1234 15

  if (fixp->fx_subsy != NULL)
    {
      /* FIXME: We should resolve difference expressions if possible
	 here.  At least this is better than silently ignoring the
	 subtrahend.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("can't resolve `%s' {%s section} - `%s' {%s section}"),
		    fixp->fx_addsy ? S_GET_NAME (fixp->fx_addsy) : "0",
		    segment_name (fixp->fx_addsy
				  ? S_GET_SEGMENT (fixp->fx_addsy)
				  : absolute_section),
		    S_GET_NAME (fixp->fx_subsy),
		    segment_name (S_GET_SEGMENT (fixp->fx_addsy)));
    }
@


1.1.2.1
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a0 884
/* tc-mn10200.c -- Assembler code for the Matsushita 10200

   Copyright (C) 1996 Free Software Foundation.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include <ctype.h>
#include "as.h"
#include "subsegs.h"     
#include "opcode/mn10200.h"

/* Structure to hold information about predefined registers.  */
struct reg_name
{
  const char *name;
  int value;
};

/* Generic assembler global variables which must be defined by all targets. */

/* Characters which always start a comment. */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = ";#";

/* Characters which may be used to separate multiple commands on a 
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating 
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant, 
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";


/* local functions */
static unsigned long mn10200
  PARAMS ((unsigned long insn, const struct mn10200_operand *operand,
	   offsetT val, char *file, unsigned int line));
static int reg_name_search PARAMS ((const struct reg_name *, int, const char *));
static boolean register_name PARAMS ((expressionS *expressionP));
static boolean system_register_name PARAMS ((expressionS *expressionP));
static boolean cc_name PARAMS ((expressionS *expressionP));
static bfd_reloc_code_real_type mn10200_reloc_prefix PARAMS ((void));


/* fixups */
#define MAX_INSN_FIXUPS (5)
struct mn10200_fixup
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};
struct mn10200_fixup fixups[MAX_INSN_FIXUPS];
static int fc;

const char *md_shortopts = "";
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof(md_longopts); 

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { NULL,       NULL,           0 }
};

/* Opcode hash table.  */
static struct hash_control *mn10200_hash;

/* This table is sorted. Suitable for searching by a binary search. */
static const struct reg_name pre_defined_registers[] =
{
  { "ep", 30 },			/* ep - element ptr */
  { "gp", 4 },			/* gp - global ptr */
  { "lp", 31 },			/* lp - link ptr */
  { "r0", 0 },
  { "r1", 1 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "r16", 16 },
  { "r17", 17 },
  { "r18", 18 },
  { "r19", 19 },
  { "r2", 2 },
  { "r20", 20 },
  { "r21", 21 },
  { "r22", 22 },
  { "r23", 23 },
  { "r24", 24 },
  { "r25", 25 },
  { "r26", 26 },
  { "r27", 27 },
  { "r28", 28 },
  { "r29", 29 },
  { "r3", 3 },
  { "r30", 30 },
  { "r31", 31 },
  { "r4", 4 },
  { "r5", 5 },
  { "r6", 6 },
  { "r7", 7 },
  { "r8", 8 },
  { "r9", 9 },
  { "sp", 3 },			/* sp - stack ptr */
  { "tp", 5 },			/* tp - text ptr */
  { "zero", 0 },
};
#define REG_NAME_CNT	(sizeof(pre_defined_registers) / sizeof(struct reg_name))


static const struct reg_name system_registers[] = 
{
  { "eipc", 0 },
  { "eipsw", 1 },
  { "fepc", 2 },
  { "fepsw", 3 },
  { "ecr", 4 },
  { "psw", 5 },
};
#define SYSREG_NAME_CNT	(sizeof(system_registers) / sizeof(struct reg_name))

static const struct reg_name cc_names[] =
{
  { "c", 0x1 },
  { "ge", 0xe },
  { "gt", 0xf },
  { "h", 0xb },
  { "l", 0x1 },
  { "le", 0x7 },
  { "lt", 0x6 },
  { "n", 0x4 },
  { "nc", 0x9 },
  { "nh", 0x3 },
  { "nl", 0x9 },
  { "ns", 0xc },
  { "nv", 0x8 },
  { "nz", 0xa },
  { "p",  0xc },
  { "s", 0x4 },
  { "sa", 0xd },
  { "t", 0x5 },
  { "v", 0x0 },
  { "z", 0x2 },
};
#define CC_NAME_CNT	(sizeof(cc_names) / sizeof(struct reg_name))

/* reg_name_search does a binary search of the given register table
   to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure. */

static int
reg_name_search (regs, regcount, name)
     const struct reg_name *regs;
     int regcount;
     const char *name;
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else 
	  return regs[middle].value;
    }
  while (low <= high);
  return -1;
}


/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: A expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
static boolean
register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT, name);

  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      *input_line_pointer = c;	/* put back the delimiting char */
      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
      return false;
    }
}

/* Summary of system_register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: A expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
static boolean
system_register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name);

  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      *input_line_pointer = c;	/* put back the delimiting char */
      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
      return false;
    }
}

/* Summary of cc_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: A expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
static boolean
cc_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (cc_names, CC_NAME_CNT, name);

  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op = O_constant;
      expressionP->X_add_number = reg_number;

      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      *input_line_pointer = c;	/* put back the delimiting char */
      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
      return false;
    }
}

void
md_show_usage (stream)
  FILE *stream;
{
  fprintf(stream, "MN10200 options:\n\
none yet\n");
} 

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  return 0;
}

symbolS *
md_undefined_symbol (name)
  char *name;
{
  return 0;
}

char *
md_atof (type, litp, sizep)
  int type;
  char *litp;
  int *sizep;
{
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return "bad call to md_atof";
    }
  
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  for (i = prec - 1; i >= 0; i--)
    {
      md_number_to_chars (litp, (valueT) words[i], 2);
      litp += 2;
    }

  return NULL;
}


void
md_convert_frag (abfd, sec, fragP)
  bfd *abfd;
  asection *sec;
  fragS *fragP;
{
  /* printf ("call to md_convert_frag \n"); */
  abort ();
}

valueT
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_begin ()
{
  char *prev_name = "";
  register const struct mn10200_opcode *op;

  mn10200_hash = hash_new();

  /* Insert unique names into hash table.  The MN10200 instruction set
     has many identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */

  op     = mn10200_opcodes;
  while (op->name)
    {
      if (strcmp (prev_name, op->name)) 
	{
	  prev_name = (char *) op->name;
	  hash_insert (mn10200_hash, op->name, (char *) op);
	}
      op++;
    }
}

static bfd_reloc_code_real_type
mn10200_reloc_prefix()
{
  if (strncmp(input_line_pointer, "hi0(", 4) == 0)
    {
      input_line_pointer += 4;
      return BFD_RELOC_HI16;
    }
  if (strncmp(input_line_pointer, "hi(", 3) == 0)
    {
      input_line_pointer += 3;
      return BFD_RELOC_HI16_S;
    }
  if (strncmp (input_line_pointer, "lo(", 3) == 0)
    {
      input_line_pointer += 3;
      return BFD_RELOC_LO16;
    }

  /* FIXME: implement sda, tda, zda here */

  return BFD_RELOC_UNUSED;
}

void
md_assemble (str) 
     char *str;
{
  char *s;
  struct mn10200_opcode *opcode;
  struct mn10200_opcode *next_opcode;
  const unsigned char *opindex_ptr;
  int next_opindex;
  unsigned long insn, size;
  char *f;
  int i;
  int match;
  bfd_reloc_code_real_type reloc;

  /* Get the opcode.  */
  for (s = str; *s != '\0' && ! isspace (*s); s++)
    ;
  if (*s != '\0')
    *s++ = '\0';

  /* find the first opcode with the proper name */
  opcode = (struct mn10200_opcode *)hash_find (mn10200_hash, str);
  if (opcode == NULL)
    {
      as_bad ("Unrecognized opcode: `%s'", str);
      return;
    }

  str = s;
  while (isspace (*str))
    ++str;

  input_line_pointer = str;

  for(;;)
    {
      const char *errmsg = NULL;

      fc = 0;
      match = 0;
      next_opindex = 0;
      insn = opcode->opcode;
      for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
	{
	  const struct mn10200_operand *operand;
	  char *hold;
	  expressionS ex;

	  if (next_opindex == 0)
	    {
	      operand = &mn10200_operands[*opindex_ptr];
	    }
	  else
	    {
	      operand = &mn10200_operands[next_opindex];
	      next_opindex = 0;
	    }

	  errmsg = NULL;

	  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']')
	    ++str;

	  /* Gather the operand. */
	  hold = input_line_pointer;
	  input_line_pointer = str;


	  /* lo(), hi(), hi0(), etc... */
	  if ((reloc = mn10200_reloc_prefix()) != BFD_RELOC_UNUSED)
	    {
	      expression(&ex);

	      if (*input_line_pointer++ != ')')
		{
		  errmsg = "syntax error: expected `)'";
		  goto error;
		}
	      
	      if (ex.X_op == O_constant)
		{
		  switch (reloc)
		    {
		    case BFD_RELOC_LO16:
		      ex.X_add_number &= 0xffff;
		      break;

		    case BFD_RELOC_HI16:
		      ex.X_add_number = ((ex.X_add_number >> 16) & 0xffff);
		      break;

		    case BFD_RELOC_HI16_S:
		      ex.X_add_number = ((ex.X_add_number >> 16) & 0xffff)
			+ ((ex.X_add_number >> 15) & 1);
		      break;

		    default:
		      break;
		    }

		  insn = mn10200_insert_operand (insn, operand, ex.X_add_number,
					      (char *) NULL, 0);
		}
	      else
		{
		  if (fc > MAX_INSN_FIXUPS)
		    as_fatal ("too many fixups");

		  fixups[fc].exp = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc = reloc;
		  fc++;
		}
	    }
	  else
	    {
	  switch (ex.X_op) 
	    {
	    case O_illegal:
	      errmsg = "illegal operand";
	      goto error;
	    case O_absent:
	      errmsg = "missing operand";
	      goto error;
	    case O_register:
		
	      insn = mn10200_insert_operand (insn, operand, ex.X_add_number,
					  (char *) NULL, 0);
	      break;

	    case O_constant:
	      insn = mn10200_insert_operand (insn, operand, ex.X_add_number,
					  (char *) NULL, 0);
	      break;

	    default:
	      /* We need to generate a fixup for this expression.  */
	      if (fc >= MAX_INSN_FIXUPS)
		as_fatal ("too many fixups");
	      fixups[fc].exp = ex;
	      fixups[fc].opindex = *opindex_ptr;
	      fixups[fc].reloc = BFD_RELOC_UNUSED;
	      ++fc;
	      break;
	    }

	    }

	  str = input_line_pointer;
	  input_line_pointer = hold;

	  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']')
	    ++str;
	}
      match = 1;

    error:
      if (match == 0)
        {
	  next_opcode = opcode + 1;
	  if (next_opcode->opcode != 0 && !strcmp(next_opcode->name, opcode->name))
	    {
	      opcode = next_opcode;
	      continue;
	    }
	  
	  as_bad ("%s", errmsg);
	  return;
        }
      break;
    }
      
  while (isspace (*str))
    ++str;

  if (*str != '\0')
    as_bad ("junk at end of line: `%s'", str);

  input_line_pointer = str;

  /* Write out the instruction.

     Four byte insns have an opcode with the two high bits on.  */ 
  if ((insn & 0x0600) == 0x0600)
    size = 4;
  else
    size = 2;
  f = frag_more (size);
  md_number_to_chars (f, insn, size);

  /* Create any fixups.  At this point we do not use a
     bfd_reloc_code_real_type, but instead just use the
     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
     handle fixups for any operand type, although that is admittedly
     not a very exciting feature.  We pick a BFD reloc type in
     md_apply_fix.  */
  for (i = 0; i < fc; i++)
    {
      const struct mn10200_operand *operand;

      operand = &mn10200_operands[fixups[i].opindex];
      if (fixups[i].reloc != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
	  int size;
	  int offset;
	  fixS *fixP;

	  if (!reloc_howto)
	    abort();
	  
	  size = bfd_get_reloc_size (reloc_howto);
	  offset = 4 - size;

	  if (size < 1 || size > 4)
	    abort();

	  fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset, size,
			      &fixups[i].exp, 
			      reloc_howto->pc_relative,
			      fixups[i].reloc);
	}
      else
	{
	  fix_new_exp (frag_now, f - frag_now->fr_literal, 4,
		       &fixups[i].exp,
		       1 /* FIXME: MN10200_OPERAND_RELATIVE ??? */,
		       ((bfd_reloc_code_real_type)
			(fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
	}
    }
}


/* if while processing a fixup, a reloc really needs to be created */
/* then it is done here */
                 
arelent *
tc_gen_reloc (seg, fixp)
     asection *seg;
     fixS *fixp;
{
  arelent *reloc;
  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    "reloc %d not supported by object file format", (int)fixp->fx_r_type);
      return NULL;
    }
  reloc->addend = fixp->fx_addnumber;
  /*  printf("tc_gen_reloc: addr=%x  addend=%x\n", reloc->address, reloc->addend); */
  return reloc;
}

int
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp;
     asection *seg;
{
  return 0;
} 

long
md_pcrel_from (fixp)
     fixS *fixp;
{
  if (fixp->fx_addsy != (symbolS *) NULL && ! S_IS_DEFINED (fixp->fx_addsy))
    {
      /* The symbol is undefined.  Let the linker figure it out.  */
      return 0;
    }
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
     segT seg;
{
  valueT value;
  char *where;

  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    value = *valuep;
  else
    {
      value = fixp->fx_offset;
      if (fixp->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixp->fx_subsy);
	  else
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    "expression too complex");
	    }
	}
    }

  /* printf("md_apply_fix: value=0x%x  type=%d\n",  value, fixp->fx_r_type); */

  if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int opindex;
      const struct mn10200_operand *operand;
      char *where;
      unsigned long insn;

      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
      operand = &mn10200_operands[opindex];

      /* Fetch the instruction, insert the fully resolved operand
         value, and stuff the instruction back again.

	 Note the instruction has been stored in little endian
	 format!  */
      where = fixp->fx_frag->fr_literal + fixp->fx_where;

      insn = bfd_getl32((unsigned char *) where);
      insn = mn10200_insert_operand (insn, operand, (offsetT) value,
				  fixp->fx_file, fixp->fx_line);
      bfd_putl32((bfd_vma) insn, (unsigned char *) where);

      if (fixp->fx_done)
	{
	  /* Nothing else to do here. */
	  return 1;
	}

      /* Determine a BFD reloc value based on the operand information.  
	 We are only prepared to turn a few of the operands into relocs. */

	{
	  as_bad_where(fixp->fx_file, fixp->fx_line,
		       "unresolved expression that must be resolved");
	  fixp->fx_done = 1;
	  return 1;
	}
    }
  else if (fixp->fx_done)
    {
      /* We still have to insert the value into memory!  */
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
      if (fixp->fx_size == 1)
	*where = value & 0xff;
      if (fixp->fx_size == 2)
	bfd_putl16(value & 0xffff, (unsigned char *) where);
      if (fixp->fx_size == 4)
	bfd_putl32(value, (unsigned char *) where);
    }

  fixp->fx_addnumber = value;
  return 1;
}


/* Insert an operand value into an instruction.  */

static unsigned long
mn10200_insert_operand (insn, operand, val, file, line)
     unsigned long insn;
     const struct mn10200_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
{
  if (operand->bits != 16)
    {
      long min, max;
      offsetT test;

        {
          max = (1 << operand->bits) - 1;
          min = 0;
        }

      test = val;


      if (test < (offsetT) min || test > (offsetT) max)
        {
          const char *err =
            "operand out of range (%s not between %ld and %ld)";
          char buf[100];

          sprint_value (buf, test);
          if (file == (char *) NULL)
            as_warn (err, buf, min, max);
          else
            as_warn_where (file, line, err, buf, min, max);
        }
    }

  insn |= (((long) val & ((1 << operand->bits) - 1)) << operand->shift);
  return insn;
}
@
