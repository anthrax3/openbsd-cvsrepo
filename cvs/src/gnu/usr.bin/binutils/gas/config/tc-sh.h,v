head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.42
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.44
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.40
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.36
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.38
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.30
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.34
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.32
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.28
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.26
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.24
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.22
	OPENBSD_5_0:1.8.0.20
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.18
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.16
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.12
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.14
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.10
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.8
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.6
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.4
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2006.10.08.21.12.39;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.02.20.45.30;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.31;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.37;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.53;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.06.19;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.37;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.13;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.13;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.50;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.45.15;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.23.23;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.46.31;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.36.57;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.33;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Define superH obsd-specific emulations for ld, and use it by default.
@
text
@/* This file is tc-sh.h
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#define TC_SH

#define TARGET_ARCH bfd_arch_sh

#if ANSI_PROTOTYPES
/* The type fixS is defined (to struct fix) in write.h, but write.h uses
   definitions from this file.  To avoid problems with including write.h
   after the "right" definitions, don't; just forward-declare struct fix
   here.  */
struct fix;
struct segment_info_struct;
struct internal_reloc;
#endif

/* Whether -relax was used.  */
extern int sh_relax;

/* Whether -small was used.  */
extern int sh_small;

/* Don't try to break words.  */
#define WORKING_DOT_WORD

/* We require .long, et. al., to be aligned correctly.  */
#define md_cons_align(nbytes) sh_cons_align (nbytes)
extern void sh_cons_align (int);

/* When relaxing, we need to generate relocations for alignment
   directives.  */
#define HANDLE_ALIGN(frag) sh_handle_align (frag)
extern void sh_handle_align (fragS *);

#define MAX_MEM_FOR_RS_ALIGN_CODE (1 + 2)

/* We need to force out some relocations when relaxing.  */
#define TC_FORCE_RELOCATION(fix) sh_force_relocation (fix)
extern int sh_force_relocation (struct fix *);

/* This macro decides whether a particular reloc is an entry in a
   switch table.  It is used when relaxing, because the linker needs
   to know about all such entries so that it can adjust them if
   necessary.  */

#ifdef BFD_ASSEMBLER
#define SWITCH_TABLE_CONS(FIX) (0)
#else
#define SWITCH_TABLE_CONS(FIX)				\
  ((FIX)->fx_r_type == 0				\
   && ((FIX)->fx_size == 2				\
       || (FIX)->fx_size == 1				\
       || (FIX)->fx_size == 4))
#endif

#define SWITCH_TABLE(FIX)				\
  ((FIX)->fx_addsy != NULL				\
   && (FIX)->fx_subsy != NULL				\
   && S_GET_SEGMENT ((FIX)->fx_addsy) == text_section	\
   && S_GET_SEGMENT ((FIX)->fx_subsy) == text_section	\
   && ((FIX)->fx_r_type == BFD_RELOC_32			\
       || (FIX)->fx_r_type == BFD_RELOC_16		\
       || (FIX)->fx_r_type == BFD_RELOC_8		\
       || SWITCH_TABLE_CONS (FIX)))

#define TC_FORCE_RELOCATION_SUB_SAME(FIX, SEC)		\
  (! SEG_NORMAL (SEC)					\
   || TC_FORCE_RELOCATION (FIX)				\
   || (sh_relax && SWITCH_TABLE (FIX)))

/* Don't complain when we leave fx_subsy around.  */
#define TC_VALIDATE_FIX_SUB(FIX)			\
  (sh_relax && SWITCH_TABLE (FIX))

#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from_section (FIX, SEC)
extern long md_pcrel_from_section (struct fix *, segT);

#define IGNORE_NONSTANDARD_ESCAPES

#define LISTING_HEADER \
  (!target_big_endian \
   ? "Renesas / SuperH SH GAS Little Endian" \
   : "Renesas / SuperH SH GAS Big Endian")

#define md_operand(x)

extern const struct relax_type md_relax_table[];
#define TC_GENERIC_RELAX_TABLE md_relax_table

/* We record, for each section, whether we have most recently output a
   CODE reloc or a DATA reloc.  */
struct sh_segment_info_type
{
  int in_code : 1;
};
#define TC_SEGMENT_INFO_TYPE struct sh_segment_info_type

/* We call a routine to emit a reloc for a label, so that the linker
   can align loads and stores without crossing a label.  */
extern void sh_frob_label (void);
#define tc_frob_label(sym) sh_frob_label ()

/* We call a routine to flush pending output in order to output a DATA
   reloc when required.  */
extern void sh_flush_pending_output (void);
#define md_flush_pending_output() sh_flush_pending_output ()

#ifdef BFD_ASSEMBLER
#define tc_frob_file_before_adjust sh_frob_file
#else
#define tc_frob_file sh_frob_file
#endif
extern void sh_frob_file (void);


#ifdef OBJ_COFF
/* COFF specific definitions.  */

#define DO_NOT_STRIP 0

/* This macro translates between an internal fix and a coff reloc type.  */
#define TC_COFF_FIX2RTYPE(fix) ((fix)->fx_r_type)

#define BFD_ARCH TARGET_ARCH

#define COFF_MAGIC (!target_big_endian ? SH_ARCH_MAGIC_LITTLE : SH_ARCH_MAGIC_BIG)

/* We need to write out relocs which have not been completed.  */
#define TC_COUNT_RELOC(fix) ((fix)->fx_addsy != NULL)

#define TC_RELOC_MANGLE(seg, fix, int, paddr) \
  sh_coff_reloc_mangle ((seg), (fix), (int), (paddr))
extern void sh_coff_reloc_mangle
  (struct segment_info_struct *, struct fix *,
   struct internal_reloc *, unsigned int);

#define tc_coff_symbol_emit_hook(a) ; /* not used */

#define NEED_FX_R_TYPE 1

#define TC_KEEP_FX_OFFSET 1

#define TC_COFF_SIZEMACHDEP(frag) tc_coff_sizemachdep(frag)
extern int tc_coff_sizemachdep (fragS *);

#ifdef BFD_ASSEMBLER
#define SEG_NAME(SEG) segment_name (SEG)
#else
#define SEG_NAME(SEG) obj_segment_name (SEG)
#endif

/* We align most sections to a 16 byte boundary.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)			\
  (strncmp (SEG_NAME (SEG), ".stabstr", 8) == 0		\
   ? 0							\
   : ((strncmp (SEG_NAME (SEG), ".stab", 5) == 0	\
       || strcmp (SEG_NAME (SEG), ".ctors") == 0	\
       || strcmp (SEG_NAME (SEG), ".dtors") == 0)	\
      ? 2						\
      : (sh_small ? 2 : 4)))

#endif /* OBJ_COFF */

#ifdef OBJ_ELF
/* ELF specific definitions.  */

/* Whether or not the target is big endian */
extern int target_big_endian;
#ifdef TE_LINUX
#define TARGET_FORMAT (!target_big_endian ? "elf32-sh-linux" : "elf32-shbig-linux")
#elif defined(TE_NetBSD)
#define TARGET_FORMAT (!target_big_endian ? "elf32-shl-nbsd" : "elf32-sh-nbsd")
#elif defined(TE_OpenBSD)
#define TARGET_FORMAT (!target_big_endian ? "elf32-shl-obsd" : "elf32-sh-obsd")
#else
#define TARGET_FORMAT (!target_big_endian ? "elf32-shl" : "elf32-sh")
#endif

#define elf_tc_final_processing sh_elf_final_processing
extern void sh_elf_final_processing (void);

#define DIFF_EXPR_OK		/* foo-. gets turned into PC relative relocs */

#define GLOBAL_OFFSET_TABLE_NAME "_GLOBAL_OFFSET_TABLE_"

/* This is the relocation type for direct references to
   GLOBAL_OFFSET_TABLE.  It comes up in complicated expressions such
   as _GLOBAL_OFFSET_TABLE_+[.-.L284], which cannot be expressed
   normally with the regular expressions.  The fixup specified here
   when used at runtime implies that we should add the address of the
   GOT to the specified location, and as a result we have simplified
   the expression into something we can use.  */
#define TC_RELOC_GLOBAL_OFFSET_TABLE BFD_RELOC_SH_GOTPC

#define tc_fix_adjustable(FIX) sh_fix_adjustable(FIX)
extern bfd_boolean sh_fix_adjustable (struct fix *);

/* Values passed to md_apply_fix3 don't include symbol values.  */
#define MD_APPLY_SYM_VALUE(FIX) 0

/* This expression evaluates to true if the relocation is for a local object
   for which we still want to do the relocation at runtime.  False if we
   are willing to perform this relocation while building the .o file.

   We can't resolve references to the GOT or the PLT when creating the
   object file, since these tables are only created by the linker.
   Also, if the symbol is global, weak, common or not defined, the
   assembler can't compute the appropriate reloc, since its location
   can only be determined at link time.  */

#define TC_FORCE_RELOCATION_LOCAL(FIX)			\
  (!(FIX)->fx_pcrel					\
   || (FIX)->fx_plt					\
   || (FIX)->fx_r_type == BFD_RELOC_32_PLT_PCREL	\
   || (FIX)->fx_r_type == BFD_RELOC_32_GOT_PCREL	\
   || (FIX)->fx_r_type == BFD_RELOC_SH_GOTPC		\
   || TC_FORCE_RELOCATION (FIX))

#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX) (sh_relax && SWITCH_TABLE (FIX))

/* This keeps the subtracted symbol around, for use by PLT_PCREL
   relocs.  */
#define TC_FORCE_RELOCATION_SUB_ABS(FIX)		\
  ((FIX)->fx_r_type == BFD_RELOC_32_PLT_PCREL)

/* Don't complain when we leave fx_subsy around.  */
#undef TC_VALIDATE_FIX_SUB
#define TC_VALIDATE_FIX_SUB(FIX)			\
  ((FIX)->fx_r_type == BFD_RELOC_32_PLT_PCREL		\
   || (sh_relax && SWITCH_TABLE (FIX)))

#define md_parse_name(name, exprP, nextcharP) \
  sh_parse_name ((name), (exprP), (nextcharP))
int sh_parse_name (char const *name, expressionS *exprP, char *nextchar);

#define TC_CONS_FIX_NEW(FRAG, OFF, LEN, EXP) \
  sh_cons_fix_new ((FRAG), (OFF), (LEN), (EXP))
void sh_cons_fix_new (fragS *, int, int, expressionS *);

/* This is used to construct expressions out of @@GOTOFF, @@PLT and @@GOT
   symbols.  The relocation type is stored in X_md.  */
#define O_PIC_reloc O_md1

#define TARGET_USE_CFIPOP 1

#define tc_cfi_frame_initial_instructions sh_cfi_frame_initial_instructions
extern void sh_cfi_frame_initial_instructions (void);

#define tc_regname_to_dw2regnum sh_regname_to_dw2regnum
extern int sh_regname_to_dw2regnum (const char *regname);

/* All SH instructions are multiples of 16 bits.  */
#define DWARF2_LINE_MIN_INSN_LENGTH 2
#define DWARF2_DEFAULT_RETURN_COLUMN 17
#define DWARF2_CIE_DATA_ALIGNMENT -4

#endif /* OBJ_ELF */
@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d192 2
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@a44 3
/* All SH instructions are multiples of 16 bits.  */
#define DWARF2_LINE_MIN_INSN_LENGTH 2

d47 1
a47 1
extern void sh_cons_align PARAMS ((int));
d52 1
a52 1
extern void sh_handle_align PARAMS ((fragS *));
d58 1
a58 1
extern int sh_force_relocation PARAMS ((struct fix *));
d95 1
a95 1
extern long md_pcrel_from_section PARAMS ((struct fix *, segT));
d119 1
a119 1
extern void sh_frob_label PARAMS ((void));
d124 1
a124 1
extern void sh_flush_pending_output PARAMS ((void));
d132 1
a132 1
extern void sh_frob_file PARAMS ((void));
d153 2
a154 2
  PARAMS ((struct segment_info_struct *, struct fix *,
	   struct internal_reloc *, unsigned int));
d163 1
a163 1
extern int tc_coff_sizemachdep PARAMS ((fragS *));
d197 1
a197 1
extern void sh_elf_final_processing PARAMS ((void));
d213 1
a213 1
extern bfd_boolean sh_fix_adjustable PARAMS ((struct fix *));
d251 1
a251 3
int sh_parse_name PARAMS ((char const *name,
			   expressionS *exprP,
			   char *nextchar));
d255 1
a255 1
void sh_cons_fix_new PARAMS ((fragS *, int, int, expressionS *));
d260 13
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
a23 2
#define TARGET_BYTES_BIG_ENDIAN 0

d27 5
a35 3
/* Whether in little endian mode.  */
extern int shl;

d61 1
a61 1
extern int sh_force_relocation ();
d63 4
a66 4
#ifdef OBJ_ELF
#define obj_fix_adjustable(fixP) sh_fix_adjustable(fixP)
struct fix;
extern boolean sh_fix_adjustable PARAMS ((struct fix *));
d68 8
a75 3
/* This arranges for gas/write.c to not apply a relocation if
   obj_fix_adjustable() says it is not adjustable.  */
#define TC_FIX_ADJUSTABLE(fixP) obj_fix_adjustable (fixP)
d78 22
d102 4
a105 1
#define LISTING_HEADER (shl ? "Hitachi Super-H GAS Little Endian" : "Hitachi Super-H GAS Big Endian")
d137 1
d143 1
a143 1
/* This macro translates between an internal fix and an coff reloc type */
d148 1
a148 1
#define COFF_MAGIC (shl ? SH_ARCH_MAGIC_LITTLE : SH_ARCH_MAGIC_BIG)
d175 1
a175 1
#define SUB_SEGMENT_ALIGN(SEG)				\
a190 1

d192 3
a194 1
#define TARGET_FORMAT (shl ? "elf32-sh-linux" : "elf32-shbig-linux")
d196 1
a196 1
#define TARGET_FORMAT (shl ? "elf32-shl" : "elf32-sh")
d215 8
a222 2
/* This expression evaluates to false if the relocation is for a local object
   for which we still want to do the relocation at runtime.  True if we
a223 3
   This is only used for pcrel relocations, so GOTOFF does not need to be
   checked here.  I am not sure if some of the others are ever used with
   pcrel, but it is easier to be safe than sorry.
d231 34
a264 9
#define TC_RELOC_RTSYM_LOC_FIXUP(FIX)				\
  ((FIX)->fx_r_type != BFD_RELOC_32_PLT_PCREL			\
   && (FIX)->fx_r_type != BFD_RELOC_32_GOT_PCREL		\
   && (FIX)->fx_r_type != BFD_RELOC_SH_GOTPC			\
   && ((FIX)->fx_addsy == NULL					\
       || (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
	   && ! S_IS_WEAK ((FIX)->fx_addsy)			\
	   && S_IS_DEFINED ((FIX)->fx_addsy)			\
	   && ! S_IS_COMMON ((FIX)->fx_addsy))))
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
d45 3
d57 2
d67 4
a81 5
/* We use a special alignment function to insert the correct nop
   pattern.  */
extern int sh_do_align PARAMS ((int, const char *, int, int));
#define md_do_align(n,fill,len,max,l) if (sh_do_align (n,fill,len,max)) goto l

d161 3
d165 1
d170 36
a206 2

/* end of tc-sh.h */
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 1996 Free Software Foundation, Inc.
d23 2
d27 5
d38 3
d44 4
d57 6
d74 2
a75 2
extern int sh_do_align PARAMS ((int, const char *, int));
#define md_do_align(n,fill,len,l) if (sh_do_align (n,fill,len)) goto l
d119 3
a121 1
extern void sh_coff_reloc_mangle ();
d132 6
d139 8
a146 8
#define SUB_SEGMENT_ALIGN(SEG)					\
  (strncmp (obj_segment_name (SEG), ".stabstr", 8) == 0		\
   ? 0								\
   : ((strncmp (obj_segment_name (SEG), ".stab", 5) == 0	\
       || strcmp (obj_segment_name (SEG), ".ctors") == 0	\
       || strcmp (obj_segment_name (SEG), ".dtors") == 0)	\
      ? 2							\
      : 4))
d157 3
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@a1 1

d23 1
a23 4
/* This macro translates between an internal fix and an coff reloc type */
#define TC_COFF_FIX2RTYPE(fix) ((fix)->fx_r_type)

#define BFD_ARCH bfd_arch_sh
d25 1
a27 2
#define COFF_MAGIC (shl ? SH_ARCH_MAGIC_LITTLE : SH_ARCH_MAGIC_BIG)

d31 3
a42 7
/* We need to write out relocs which have not been completed.  */
#define TC_COUNT_RELOC(fix) ((fix)->fx_addsy != NULL)

#define TC_RELOC_MANGLE(seg, fix, int, paddr) \
  sh_coff_reloc_mangle ((seg), (fix), (int), (paddr))
extern void sh_coff_reloc_mangle ();

a44 4
#define tc_coff_symbol_emit_hook(a) ; /* not used */

#define DO_NOT_STRIP 0
#define DO_STRIP 0
a45 7
#define NEED_FX_R_TYPE 1
#define RELOC_32 1234

#define TC_KEEP_FX_OFFSET 1

#define TC_COFF_SIZEMACHDEP(frag) tc_coff_sizemachdep(frag)
extern int tc_coff_sizemachdep PARAMS ((fragS *));
a51 3
#define tc_frob_file sh_coff_frob_file
extern void sh_coff_frob_file PARAMS (());

d74 57
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.
d74 23
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d3 1
a3 1
   Copyright (C) 1993, 94, 95, 1996 Free Software Foundation, Inc.
a73 23

/* We use a special alignment function to insert the correct nop
   pattern.  */
extern int sh_do_align PARAMS ((int, const char *, int));
#define md_do_align(n,fill,len,l) if (sh_do_align (n,fill,len)) goto l

/* We record, for each section, whether we have most recently output a
   CODE reloc or a DATA reloc.  */
struct sh_segment_info_type
{
  int in_code : 1;
};
#define TC_SEGMENT_INFO_TYPE struct sh_segment_info_type

/* We call a routine to emit a reloc for a label, so that the linker
   can align loads and stores without crossing a label.  */
extern void sh_frob_label PARAMS ((void));
#define tc_frob_label(sym) sh_frob_label ()

/* We call a routine to flush pending output in order to output a DATA
   reloc when required.  */
extern void sh_flush_pending_output PARAMS ((void));
#define md_flush_pending_output() sh_flush_pending_output ()
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
d24 4
a27 1
#define TARGET_ARCH bfd_arch_sh
a28 1
/* Whether in little endian mode.  */
d31 2
a35 3
/* Don't try to break words.  */
#define WORKING_DOT_WORD

d45 7
d54 4
d59 7
d72 3
a96 57

#ifdef BFD_ASSEMBLER
#define tc_frob_file_before_adjust sh_frob_file
#else
#define tc_frob_file sh_frob_file
#endif
extern void sh_frob_file PARAMS ((void));

#ifdef OBJ_COFF
/* COFF specific definitions.  */

#define DO_NOT_STRIP 0

/* This macro translates between an internal fix and an coff reloc type */
#define TC_COFF_FIX2RTYPE(fix) ((fix)->fx_r_type)

#define BFD_ARCH TARGET_ARCH

#define COFF_MAGIC (shl ? SH_ARCH_MAGIC_LITTLE : SH_ARCH_MAGIC_BIG)

/* We need to write out relocs which have not been completed.  */
#define TC_COUNT_RELOC(fix) ((fix)->fx_addsy != NULL)

#define TC_RELOC_MANGLE(seg, fix, int, paddr) \
  sh_coff_reloc_mangle ((seg), (fix), (int), (paddr))
extern void sh_coff_reloc_mangle ();

#define tc_coff_symbol_emit_hook(a) ; /* not used */

#define NEED_FX_R_TYPE 1

#define TC_KEEP_FX_OFFSET 1

#define TC_COFF_SIZEMACHDEP(frag) tc_coff_sizemachdep(frag)
extern int tc_coff_sizemachdep PARAMS ((fragS *));

/* We align most sections to a 16 byte boundary.  */
#define SUB_SEGMENT_ALIGN(SEG)					\
  (strncmp (obj_segment_name (SEG), ".stabstr", 8) == 0		\
   ? 0								\
   : ((strncmp (obj_segment_name (SEG), ".stab", 5) == 0	\
       || strcmp (obj_segment_name (SEG), ".ctors") == 0	\
       || strcmp (obj_segment_name (SEG), ".dtors") == 0)	\
      ? 2							\
      : 4))

#endif /* OBJ_COFF */

#ifdef OBJ_ELF
/* ELF specific definitions.  */

/* Whether or not the target is big endian */
extern int target_big_endian;

#define TARGET_FORMAT (shl ? "elf32-shl" : "elf32-sh")

#endif /* OBJ_ELF */
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 1997 Free Software Foundation, Inc.
a22 2
#define TARGET_BYTES_BIG_ENDIAN 0

d54 2
a55 2
extern int sh_do_align PARAMS ((int, const char *, int, int));
#define md_do_align(n,fill,len,max,l) if (sh_do_align (n,fill,len,max)) goto l
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
a26 5
#if ANSI_PROTOTYPES
struct segment_info_struct;
struct internal_reloc;
#endif

a32 3
/* Whether -small was used.  */
extern int sh_small;

a35 4
/* We require .long, et. al., to be aligned correctly.  */
#define md_cons_align(nbytes) sh_cons_align (nbytes)
extern void sh_cons_align PARAMS ((int));

a44 6
#ifdef OBJ_ELF
#define obj_fix_adjustable(fixP) sh_fix_adjustable(fixP)
struct fix;
extern boolean sh_fix_adjustable PARAMS ((struct fix *));
#endif

d101 1
a101 3
extern void sh_coff_reloc_mangle
  PARAMS ((struct segment_info_struct *, struct fix *,
	   struct internal_reloc *, unsigned int));
a111 6
#ifdef BFD_ASSEMBLER
#define SEG_NAME(SEG) segment_name (SEG)
#else
#define SEG_NAME(SEG) obj_segment_name (SEG)
#endif

d113 8
a120 8
#define SUB_SEGMENT_ALIGN(SEG)				\
  (strncmp (SEG_NAME (SEG), ".stabstr", 8) == 0		\
   ? 0							\
   : ((strncmp (SEG_NAME (SEG), ".stab", 5) == 0	\
       || strcmp (SEG_NAME (SEG), ".ctors") == 0	\
       || strcmp (SEG_NAME (SEG), ".dtors") == 0)	\
      ? 2						\
      : (sh_small ? 2 : 4)))
a130 3

#define elf_tc_final_processing sh_elf_final_processing
extern void sh_elf_final_processing PARAMS ((void));
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
a43 3
/* All SH instructions are multiples of 16 bits.  */
#define DWARF2_LINE_MIN_INSN_LENGTH 2

a52 2
#define MAX_MEM_FOR_RS_ALIGN_CODE (1 + 2)

a60 4

/* This arranges for gas/write.c to not apply a relocation if
   obj_fix_adjustable() says it is not adjustable.  */
#define TC_FIX_ADJUSTABLE(fixP) obj_fix_adjustable (fixP)
d72 5
a155 3
#ifdef TE_LINUX
#define TARGET_FORMAT (shl ? "elf32-sh-linux" : "elf32-shbig-linux")
#else
a156 1
#endif
d161 1
a161 3
#define DIFF_EXPR_OK		/* foo-. gets turned into PC relative relocs */

#define GLOBAL_OFFSET_TABLE_NAME "_GLOBAL_OFFSET_TABLE_"
d163 1
a163 33
/* This is the relocation type for direct references to
   GLOBAL_OFFSET_TABLE.  It comes up in complicated expressions such
   as _GLOBAL_OFFSET_TABLE_+[.-.L284], which cannot be expressed
   normally with the regular expressions.  The fixup specified here
   when used at runtime implies that we should add the address of the
   GOT to the specified location, and as a result we have simplified
   the expression into something we can use.  */
#define TC_RELOC_GLOBAL_OFFSET_TABLE BFD_RELOC_SH_GOTPC

/* This expression evaluates to false if the relocation is for a local object
   for which we still want to do the relocation at runtime.  True if we
   are willing to perform this relocation while building the .o file.
   This is only used for pcrel relocations, so GOTOFF does not need to be
   checked here.  I am not sure if some of the others are ever used with
   pcrel, but it is easier to be safe than sorry.

   We can't resolve references to the GOT or the PLT when creating the
   object file, since these tables are only created by the linker.
   Also, if the symbol is global, weak, common or not defined, the
   assembler can't compute the appropriate reloc, since its location
   can only be determined at link time.  */

#define TC_RELOC_RTSYM_LOC_FIXUP(FIX)				\
  ((FIX)->fx_r_type != BFD_RELOC_32_PLT_PCREL			\
   && (FIX)->fx_r_type != BFD_RELOC_32_GOT_PCREL		\
   && (FIX)->fx_r_type != BFD_RELOC_SH_GOTPC			\
   && ((FIX)->fx_addsy == NULL					\
       || (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
	   && ! S_IS_WEAK ((FIX)->fx_addsy)			\
	   && S_IS_DEFINED ((FIX)->fx_addsy)			\
	   && ! S_IS_COMMON ((FIX)->fx_addsy))))

#endif /* OBJ_ELF */
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
d24 2
a28 5
/* The type fixS is defined (to struct fix) in write.h, but write.h uses
   definitions from this file.  To avoid problems with including write.h
   after the "right" definitions, don't; just forward-declare struct fix
   here.  */
struct fix;
d33 3
d61 1
a61 1
extern int sh_force_relocation PARAMS ((struct fix *));
d63 4
a66 4
/* This macro decides whether a particular reloc is an entry in a
   switch table.  It is used when relaxing, because the linker needs
   to know about all such entries so that it can adjust them if
   necessary.  */
d68 3
a70 8
#ifdef BFD_ASSEMBLER
#define SWITCH_TABLE_CONS(FIX) (0)
#else
#define SWITCH_TABLE_CONS(FIX)				\
  ((FIX)->fx_r_type == 0				\
   && ((FIX)->fx_size == 2				\
       || (FIX)->fx_size == 1				\
       || (FIX)->fx_size == 4))
a72 22
#define SWITCH_TABLE(FIX)				\
  ((FIX)->fx_addsy != NULL				\
   && (FIX)->fx_subsy != NULL				\
   && S_GET_SEGMENT ((FIX)->fx_addsy) == text_section	\
   && S_GET_SEGMENT ((FIX)->fx_subsy) == text_section	\
   && ((FIX)->fx_r_type == BFD_RELOC_32			\
       || (FIX)->fx_r_type == BFD_RELOC_16		\
       || (FIX)->fx_r_type == BFD_RELOC_8		\
       || SWITCH_TABLE_CONS (FIX)))

#define TC_FORCE_RELOCATION_SUB_SAME(FIX, SEC)		\
  (! SEG_NORMAL (SEC)					\
   || TC_FORCE_RELOCATION (FIX)				\
   || (sh_relax && SWITCH_TABLE (FIX)))

/* Don't complain when we leave fx_subsy around.  */
#define TC_VALIDATE_FIX_SUB(FIX)			\
  (sh_relax && SWITCH_TABLE (FIX))

#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from_section (FIX, SEC)
extern long md_pcrel_from_section PARAMS ((struct fix *, segT));

d75 1
a75 4
#define LISTING_HEADER \
  (!target_big_endian \
   ? "Renesas / SuperH SH GAS Little Endian" \
   : "Renesas / SuperH SH GAS Big Endian")
a106 1

d112 1
a112 1
/* This macro translates between an internal fix and a coff reloc type.  */
d117 1
a117 1
#define COFF_MAGIC (!target_big_endian ? SH_ARCH_MAGIC_LITTLE : SH_ARCH_MAGIC_BIG)
d144 1
a144 1
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)			\
d160 1
d162 1
a162 3
#define TARGET_FORMAT (!target_big_endian ? "elf32-sh-linux" : "elf32-shbig-linux")
#elif defined(TE_NetBSD)
#define TARGET_FORMAT (!target_big_endian ? "elf32-shl-nbsd" : "elf32-sh-nbsd")
d164 1
a164 1
#define TARGET_FORMAT (!target_big_endian ? "elf32-shl" : "elf32-sh")
d183 2
a184 8
#define tc_fix_adjustable(FIX) sh_fix_adjustable(FIX)
extern bfd_boolean sh_fix_adjustable PARAMS ((struct fix *));

/* Values passed to md_apply_fix3 don't include symbol values.  */
#define MD_APPLY_SYM_VALUE(FIX) 0

/* This expression evaluates to true if the relocation is for a local object
   for which we still want to do the relocation at runtime.  False if we
d186 3
d196 9
a204 34
#define TC_FORCE_RELOCATION_LOCAL(FIX)			\
  (!(FIX)->fx_pcrel					\
   || (FIX)->fx_plt					\
   || (FIX)->fx_r_type == BFD_RELOC_32_PLT_PCREL	\
   || (FIX)->fx_r_type == BFD_RELOC_32_GOT_PCREL	\
   || (FIX)->fx_r_type == BFD_RELOC_SH_GOTPC		\
   || TC_FORCE_RELOCATION (FIX))

#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX) (sh_relax && SWITCH_TABLE (FIX))

/* This keeps the subtracted symbol around, for use by PLT_PCREL
   relocs.  */
#define TC_FORCE_RELOCATION_SUB_ABS(FIX)		\
  ((FIX)->fx_r_type == BFD_RELOC_32_PLT_PCREL)

/* Don't complain when we leave fx_subsy around.  */
#undef TC_VALIDATE_FIX_SUB
#define TC_VALIDATE_FIX_SUB(FIX)			\
  ((FIX)->fx_r_type == BFD_RELOC_32_PLT_PCREL		\
   || (sh_relax && SWITCH_TABLE (FIX)))

#define md_parse_name(name, exprP, nextcharP) \
  sh_parse_name ((name), (exprP), (nextcharP))
int sh_parse_name PARAMS ((char const *name,
			   expressionS *exprP,
			   char *nextchar));

#define TC_CONS_FIX_NEW(FRAG, OFF, LEN, EXP) \
  sh_cons_fix_new ((FRAG), (OFF), (LEN), (EXP))
void sh_cons_fix_new PARAMS ((fragS *, int, int, expressionS *));

/* This is used to construct expressions out of @@GOTOFF, @@PLT and @@GOT
   symbols.  The relocation type is stored in X_md.  */
#define O_PIC_reloc O_md1
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d45 3
d50 1
a50 1
extern void sh_cons_align (int);
d55 1
a55 1
extern void sh_handle_align (fragS *);
d61 1
a61 1
extern int sh_force_relocation (struct fix *);
d98 1
a98 1
extern long md_pcrel_from_section (struct fix *, segT);
d122 1
a122 1
extern void sh_frob_label (void);
d127 1
a127 1
extern void sh_flush_pending_output (void);
d135 1
a135 1
extern void sh_frob_file (void);
d156 2
a157 2
  (struct segment_info_struct *, struct fix *,
   struct internal_reloc *, unsigned int);
d166 1
a166 1
extern int tc_coff_sizemachdep (fragS *);
d200 1
a200 1
extern void sh_elf_final_processing (void);
d216 1
a216 1
extern bfd_boolean sh_fix_adjustable (struct fix *);
d254 3
a256 1
int sh_parse_name (char const *name, expressionS *exprP, char *nextchar);
d260 1
a260 1
void sh_cons_fix_new (fragS *, int, int, expressionS *);
a264 13

#define TARGET_USE_CFIPOP 1

#define tc_cfi_frame_initial_instructions sh_cfi_frame_initial_instructions
extern void sh_cfi_frame_initial_instructions (void);

#define tc_regname_to_dw2regnum sh_regname_to_dw2regnum
extern int sh_regname_to_dw2regnum (const char *regname);

/* All SH instructions are multiples of 16 bits.  */
#define DWARF2_LINE_MIN_INSN_LENGTH 2
#define DWARF2_DEFAULT_RETURN_COLUMN 17
#define DWARF2_CIE_DATA_ALIGNMENT -4
@


