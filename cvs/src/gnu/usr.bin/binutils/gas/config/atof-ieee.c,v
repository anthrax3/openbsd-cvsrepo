head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.50
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.46
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.48
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.40
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.44
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.42
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.38
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.36
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.34
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.32
	OPENBSD_5_0:1.5.0.30
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.28
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.26
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.22
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.45;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.58;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.50;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.50;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.04;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.22.24;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.46.16;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.32.45;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.27;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* atof_ieee.c - turn a Flonum into an IEEE floating point number
   Copyright 1987, 1992, 1994, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "as.h"

/* Flonums returned here.  */
extern FLONUM_TYPE generic_floating_point_number;

static int next_bits PARAMS ((int));
static void unget_bits PARAMS ((int));
static void make_invalid_floating_point_number PARAMS ((LITTLENUM_TYPE *));

extern const char EXP_CHARS[];
/* Precision in LittleNums.  */
/* Don't count the gap in the m68k extended precision format.  */
#define MAX_PRECISION (5)
#define F_PRECISION (2)
#define D_PRECISION (4)
#define X_PRECISION (5)
#define P_PRECISION (5)

/* Length in LittleNums of guard bits.  */
#define GUARD (2)

#ifndef TC_LARGEST_EXPONENT_IS_NORMAL
#define TC_LARGEST_EXPONENT_IS_NORMAL(PRECISION) 0
#endif

static const unsigned long mask[] =
{
  0x00000000,
  0x00000001,
  0x00000003,
  0x00000007,
  0x0000000f,
  0x0000001f,
  0x0000003f,
  0x0000007f,
  0x000000ff,
  0x000001ff,
  0x000003ff,
  0x000007ff,
  0x00000fff,
  0x00001fff,
  0x00003fff,
  0x00007fff,
  0x0000ffff,
  0x0001ffff,
  0x0003ffff,
  0x0007ffff,
  0x000fffff,
  0x001fffff,
  0x003fffff,
  0x007fffff,
  0x00ffffff,
  0x01ffffff,
  0x03ffffff,
  0x07ffffff,
  0x0fffffff,
  0x1fffffff,
  0x3fffffff,
  0x7fffffff,
  0xffffffff,
};

static int bits_left_in_littlenum;
static int littlenums_left;
static LITTLENUM_TYPE *littlenum_pointer;

static int
next_bits (number_of_bits)
     int number_of_bits;
{
  int return_value;

  if (!littlenums_left)
    return (0);
  if (number_of_bits >= bits_left_in_littlenum)
    {
      return_value = mask[bits_left_in_littlenum] & *littlenum_pointer;
      number_of_bits -= bits_left_in_littlenum;
      return_value <<= number_of_bits;

      if (--littlenums_left)
	{
	  bits_left_in_littlenum = LITTLENUM_NUMBER_OF_BITS - number_of_bits;
	  --littlenum_pointer;
	  return_value |=
	    (*littlenum_pointer >> bits_left_in_littlenum)
	    & mask[number_of_bits];
	}
    }
  else
    {
      bits_left_in_littlenum -= number_of_bits;
      return_value =
	mask[number_of_bits] & (*littlenum_pointer >> bits_left_in_littlenum);
    }
  return return_value;
}

/* Num had better be less than LITTLENUM_NUMBER_OF_BITS.  */

static void
unget_bits (num)
     int num;
{
  if (!littlenums_left)
    {
      ++littlenum_pointer;
      ++littlenums_left;
      bits_left_in_littlenum = num;
    }
  else if (bits_left_in_littlenum + num > LITTLENUM_NUMBER_OF_BITS)
    {
      bits_left_in_littlenum =
	num - (LITTLENUM_NUMBER_OF_BITS - bits_left_in_littlenum);
      ++littlenum_pointer;
      ++littlenums_left;
    }
  else
    bits_left_in_littlenum += num;
}

static void
make_invalid_floating_point_number (words)
     LITTLENUM_TYPE *words;
{
  as_bad (_("cannot create floating-point number"));
  /* Zero the leftmost bit.  */
  words[0] = (LITTLENUM_TYPE) ((unsigned) -1) >> 1;
  words[1] = (LITTLENUM_TYPE) -1;
  words[2] = (LITTLENUM_TYPE) -1;
  words[3] = (LITTLENUM_TYPE) -1;
  words[4] = (LITTLENUM_TYPE) -1;
  words[5] = (LITTLENUM_TYPE) -1;
}

/* Warning: This returns 16-bit LITTLENUMs.  It is up to the caller to
   figure out any alignment problems and to conspire for the
   bytes/word to be emitted in the right order.  Bigendians beware!  */

/* Note that atof-ieee always has X and P precisions enabled.  it is up
   to md_atof to filter them out if the target machine does not support
   them.  */

/* Returns pointer past text consumed.  */

char *
atof_ieee (str, what_kind, words)
     char *str;			/* Text to convert to binary.  */
     int what_kind;		/* 'd', 'f', 'g', 'h'.  */
     LITTLENUM_TYPE *words;	/* Build the binary here.  */
{
  /* Extra bits for zeroed low-order bits.
     The 1st MAX_PRECISION are zeroed, the last contain flonum bits.  */
  static LITTLENUM_TYPE bits[MAX_PRECISION + MAX_PRECISION + GUARD];
  char *return_value;
  /* Number of 16-bit words in the format.  */
  int precision;
  long exponent_bits;
  FLONUM_TYPE save_gen_flonum;

  /* We have to save the generic_floating_point_number because it
     contains storage allocation about the array of LITTLENUMs where
     the value is actually stored.  We will allocate our own array of
     littlenums below, but have to restore the global one on exit.  */
  save_gen_flonum = generic_floating_point_number;

  return_value = str;
  generic_floating_point_number.low = bits + MAX_PRECISION;
  generic_floating_point_number.high = NULL;
  generic_floating_point_number.leader = NULL;
  generic_floating_point_number.exponent = 0;
  generic_floating_point_number.sign = '\0';

  /* Use more LittleNums than seems necessary: the highest flonum may
     have 15 leading 0 bits, so could be useless.  */

  memset (bits, '\0', sizeof (LITTLENUM_TYPE) * MAX_PRECISION);

  switch (what_kind)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      precision = F_PRECISION;
      exponent_bits = 8;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      precision = D_PRECISION;
      exponent_bits = 11;
      break;

    case 'x':
    case 'X':
    case 'e':
    case 'E':
      precision = X_PRECISION;
      exponent_bits = 15;
      break;

    case 'p':
    case 'P':

      precision = P_PRECISION;
      exponent_bits = -1;
      break;

    default:
      make_invalid_floating_point_number (words);
      return (NULL);
    }

  generic_floating_point_number.high
    = generic_floating_point_number.low + precision - 1 + GUARD;

  if (atof_generic (&return_value, ".", EXP_CHARS,
		    &generic_floating_point_number))
    {
      make_invalid_floating_point_number (words);
      return (NULL);
    }
  gen_to_words (words, precision, exponent_bits);

  /* Restore the generic_floating_point_number's storage alloc (and
     everything else).  */
  generic_floating_point_number = save_gen_flonum;

  return return_value;
}

/* Turn generic_floating_point_number into a real float/double/extended.  */

int
gen_to_words (words, precision, exponent_bits)
     LITTLENUM_TYPE *words;
     int precision;
     long exponent_bits;
{
  int return_value = 0;

  long exponent_1;
  long exponent_2;
  long exponent_3;
  long exponent_4;
  int exponent_skippage;
  LITTLENUM_TYPE word1;
  LITTLENUM_TYPE *lp;
  LITTLENUM_TYPE *words_end;

  words_end = words + precision;
#ifdef TC_M68K
  if (precision == X_PRECISION)
    /* On the m68k the extended precision format has a gap of 16 bits
       between the exponent and the mantissa.  */
    words_end++;
#endif

  if (generic_floating_point_number.low > generic_floating_point_number.leader)
    {
      /* 0.0e0 seen.  */
      if (generic_floating_point_number.sign == '+')
	words[0] = 0x0000;
      else
	words[0] = 0x8000;
      memset (&words[1], '\0',
	      (words_end - words - 1) * sizeof (LITTLENUM_TYPE));
      return return_value;
    }

  /* NaN:  Do the right thing.  */
  if (generic_floating_point_number.sign == 0)
    {
      if (TC_LARGEST_EXPONENT_IS_NORMAL (precision))
	as_warn ("NaNs are not supported by this target\n");
      if (precision == F_PRECISION)
	{
	  words[0] = 0x7fff;
	  words[1] = 0xffff;
	}
      else if (precision == X_PRECISION)
	{
#ifdef TC_M68K
	  words[0] = 0x7fff;
	  words[1] = 0;
	  words[2] = 0xffff;
	  words[3] = 0xffff;
	  words[4] = 0xffff;
	  words[5] = 0xffff;
#else /* ! TC_M68K  */
#ifdef TC_I386
	  words[0] = 0xffff;
	  words[1] = 0xc000;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
#else /* ! TC_I386  */
	  abort ();
#endif /* ! TC_I386  */
#endif /* ! TC_M68K  */
	}
      else
	{
	  words[0] = 0x7fff;
	  words[1] = 0xffff;
	  words[2] = 0xffff;
	  words[3] = 0xffff;
	}
      return return_value;
    }
  else if (generic_floating_point_number.sign == 'P')
    {
      if (TC_LARGEST_EXPONENT_IS_NORMAL (precision))
	as_warn ("Infinities are not supported by this target\n");

      /* +INF:  Do the right thing.  */
      if (precision == F_PRECISION)
	{
	  words[0] = 0x7f80;
	  words[1] = 0;
	}
      else if (precision == X_PRECISION)
	{
#ifdef TC_M68K
	  words[0] = 0x7fff;
	  words[1] = 0;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
	  words[5] = 0;
#else /* ! TC_M68K  */
#ifdef TC_I386
	  words[0] = 0x7fff;
	  words[1] = 0x8000;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
#else /* ! TC_I386  */
	  abort ();
#endif /* ! TC_I386  */
#endif /* ! TC_M68K  */
	}
      else
	{
	  words[0] = 0x7ff0;
	  words[1] = 0;
	  words[2] = 0;
	  words[3] = 0;
	}
      return return_value;
    }
  else if (generic_floating_point_number.sign == 'N')
    {
      if (TC_LARGEST_EXPONENT_IS_NORMAL (precision))
	as_warn ("Infinities are not supported by this target\n");

      /* Negative INF.  */
      if (precision == F_PRECISION)
	{
	  words[0] = 0xff80;
	  words[1] = 0x0;
	}
      else if (precision == X_PRECISION)
	{
#ifdef TC_M68K
	  words[0] = 0xffff;
	  words[1] = 0;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
	  words[5] = 0;
#else /* ! TC_M68K  */
#ifdef TC_I386
	  words[0] = 0xffff;
	  words[1] = 0x8000;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
#else /* ! TC_I386  */
	  abort ();
#endif /* ! TC_I386  */
#endif /* ! TC_M68K  */
	}
      else
	{
	  words[0] = 0xfff0;
	  words[1] = 0x0;
	  words[2] = 0x0;
	  words[3] = 0x0;
	}
      return return_value;
    }

  /* The floating point formats we support have:
     Bit 15 is sign bit.
     Bits 14:n are excess-whatever exponent.
     Bits n-1:0 (if any) are most significant bits of fraction.
     Bits 15:0 of the next word(s) are the next most significant bits.

     So we need: number of bits of exponent, number of bits of
     mantissa.  */
  bits_left_in_littlenum = LITTLENUM_NUMBER_OF_BITS;
  littlenum_pointer = generic_floating_point_number.leader;
  littlenums_left = (1
		     + generic_floating_point_number.leader
		     - generic_floating_point_number.low);

  /* Seek (and forget) 1st significant bit.  */
  for (exponent_skippage = 0; !next_bits (1); ++exponent_skippage);;
  exponent_1 = (generic_floating_point_number.exponent
		+ generic_floating_point_number.leader
		+ 1
		- generic_floating_point_number.low);

  /* Radix LITTLENUM_RADIX, point just higher than
     generic_floating_point_number.leader.  */
  exponent_2 = exponent_1 * LITTLENUM_NUMBER_OF_BITS;

  /* Radix 2.  */
  exponent_3 = exponent_2 - exponent_skippage;

  /* Forget leading zeros, forget 1st bit.  */
  exponent_4 = exponent_3 + ((1 << (exponent_bits - 1)) - 2);

  /* Offset exponent.  */
  lp = words;

  /* Word 1.  Sign, exponent and perhaps high bits.  */
  word1 = ((generic_floating_point_number.sign == '+')
	   ? 0
	   : (1 << (LITTLENUM_NUMBER_OF_BITS - 1)));

  /* Assume 2's complement integers.  */
  if (exponent_4 <= 0)
    {
      int prec_bits;
      int num_bits;

      unget_bits (1);
      num_bits = -exponent_4;
      prec_bits =
	LITTLENUM_NUMBER_OF_BITS * precision - (exponent_bits + 1 + num_bits);
#ifdef TC_I386
      if (precision == X_PRECISION && exponent_bits == 15)
	{
	  /* On the i386 a denormalized extended precision float is
	     shifted down by one, effectively decreasing the exponent
	     bias by one.  */
	  prec_bits -= 1;
	  num_bits += 1;
	}
#endif

      if (num_bits >= LITTLENUM_NUMBER_OF_BITS - exponent_bits)
	{
	  /* Bigger than one littlenum.  */
	  num_bits -= (LITTLENUM_NUMBER_OF_BITS - 1) - exponent_bits;
	  *lp++ = word1;
	  if (num_bits + exponent_bits + 1
	      > precision * LITTLENUM_NUMBER_OF_BITS)
	    {
	      /* Exponent overflow.  */
	      make_invalid_floating_point_number (words);
	      return return_value;
	    }
#ifdef TC_M68K
	  if (precision == X_PRECISION && exponent_bits == 15)
	    *lp++ = 0;
#endif
	  while (num_bits >= LITTLENUM_NUMBER_OF_BITS)
	    {
	      num_bits -= LITTLENUM_NUMBER_OF_BITS;
	      *lp++ = 0;
	    }
	  if (num_bits)
	    *lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS - (num_bits));
	}
      else
	{
	  if (precision == X_PRECISION && exponent_bits == 15)
	    {
	      *lp++ = word1;
#ifdef TC_M68K
	      *lp++ = 0;
#endif
	      *lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS - num_bits);
	    }
	  else
	    {
	      word1 |= next_bits ((LITTLENUM_NUMBER_OF_BITS - 1)
				  - (exponent_bits + num_bits));
	      *lp++ = word1;
	    }
	}
      while (lp < words_end)
	*lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS);

      /* Round the mantissa up, but don't change the number.  */
      if (next_bits (1))
	{
	  --lp;
	  if (prec_bits >= LITTLENUM_NUMBER_OF_BITS)
	    {
	      int n = 0;
	      int tmp_bits;

	      n = 0;
	      tmp_bits = prec_bits;
	      while (tmp_bits > LITTLENUM_NUMBER_OF_BITS)
		{
		  if (lp[n] != (LITTLENUM_TYPE) - 1)
		    break;
		  --n;
		  tmp_bits -= LITTLENUM_NUMBER_OF_BITS;
		}
	      if (tmp_bits > LITTLENUM_NUMBER_OF_BITS
		  || (lp[n] & mask[tmp_bits]) != mask[tmp_bits]
		  || (prec_bits != (precision * LITTLENUM_NUMBER_OF_BITS
				    - exponent_bits - 1)
#ifdef TC_I386
		      /* An extended precision float with only the integer
			 bit set would be invalid.  That must be converted
			 to the smallest normalized number.  */
		      && !(precision == X_PRECISION
			   && prec_bits == (precision * LITTLENUM_NUMBER_OF_BITS
					    - exponent_bits - 2))
#endif
		      ))
		{
		  unsigned long carry;

		  for (carry = 1; carry && (lp >= words); lp--)
		    {
		      carry = *lp + carry;
		      *lp = carry;
		      carry >>= LITTLENUM_NUMBER_OF_BITS;
		    }
		}
	      else
		{
		  /* This is an overflow of the denormal numbers.  We
                     need to forget what we have produced, and instead
                     generate the smallest normalized number.  */
		  lp = words;
		  word1 = ((generic_floating_point_number.sign == '+')
			   ? 0
			   : (1 << (LITTLENUM_NUMBER_OF_BITS - 1)));
		  word1 |= (1
			    << ((LITTLENUM_NUMBER_OF_BITS - 1)
				- exponent_bits));
		  *lp++ = word1;
#ifdef TC_I386
		  /* Set the integer bit in the extended precision format.
		     This cannot happen on the m68k where the mantissa
		     just overflows into the integer bit above.  */
		  if (precision == X_PRECISION)
		    *lp++ = 1 << (LITTLENUM_NUMBER_OF_BITS - 1);
#endif
		  while (lp < words_end)
		    *lp++ = 0;
		}
	    }
	  else
	    *lp += 1;
	}

      return return_value;
    }
  else if ((unsigned long) exponent_4 > mask[exponent_bits]
	   || (! TC_LARGEST_EXPONENT_IS_NORMAL (precision)
	       && (unsigned long) exponent_4 == mask[exponent_bits]))
    {
      /* Exponent overflow.  Lose immediately.  */

      /* We leave return_value alone: admit we read the
	 number, but return a floating exception
	 because we can't encode the number.  */
      make_invalid_floating_point_number (words);
      return return_value;
    }
  else
    {
      word1 |= (exponent_4 << ((LITTLENUM_NUMBER_OF_BITS - 1) - exponent_bits))
	| next_bits ((LITTLENUM_NUMBER_OF_BITS - 1) - exponent_bits);
    }

  *lp++ = word1;

  /* X_PRECISION is special: on the 68k, it has 16 bits of zero in the
     middle.  Either way, it is then followed by a 1 bit.  */
  if (exponent_bits == 15 && precision == X_PRECISION)
    {
#ifdef TC_M68K
      *lp++ = 0;
#endif
      *lp++ = (1 << (LITTLENUM_NUMBER_OF_BITS - 1)
	       | next_bits (LITTLENUM_NUMBER_OF_BITS - 1));
    }

  /* The rest of the words are just mantissa bits.  */
  while (lp < words_end)
    *lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS);

  if (next_bits (1))
    {
      unsigned long carry;
      /* Since the NEXT bit is a 1, round UP the mantissa.
	 The cunning design of these hidden-1 floats permits
	 us to let the mantissa overflow into the exponent, and
	 it 'does the right thing'. However, we lose if the
	 highest-order bit of the lowest-order word flips.
	 Is that clear?  */

      /* #if (sizeof(carry)) < ((sizeof(bits[0]) * BITS_PER_CHAR) + 2)
	 Please allow at least 1 more bit in carry than is in a LITTLENUM.
	 We need that extra bit to hold a carry during a LITTLENUM carry
	 propagation. Another extra bit (kept 0) will assure us that we
	 don't get a sticky sign bit after shifting right, and that
	 permits us to propagate the carry without any masking of bits.
	 #endif */
      for (carry = 1, lp--; carry; lp--)
	{
	  carry = *lp + carry;
	  *lp = carry;
	  carry >>= LITTLENUM_NUMBER_OF_BITS;
	  if (lp == words)
	    break;
	}
      if (precision == X_PRECISION && exponent_bits == 15)
	{
	  /* Extended precision numbers have an explicit integer bit
	     that we may have to restore.  */
	  if (lp == words)
	    {
#ifdef TC_M68K
	      /* On the m68k there is a gap of 16 bits.  We must
		 explicitly propagate the carry into the exponent.  */
	      words[0] += words[1];
	      words[1] = 0;
	      lp++;
#endif
	      /* Put back the integer bit.  */
	      lp[1] |= 1 << (LITTLENUM_NUMBER_OF_BITS - 1);
	    }
	}
      if ((word1 ^ *words) & (1 << (LITTLENUM_NUMBER_OF_BITS - 1)))
	{
	  /* We leave return_value alone: admit we read the number,
	     but return a floating exception because we can't encode
	     the number.  */
	  *words &= ~(1 << (LITTLENUM_NUMBER_OF_BITS - 1));
#if 0
	  make_invalid_floating_point_number (words);
	  return return_value;
#endif
	}
    }
  return return_value;
}

#if 0
/* Unused.  */
/* This routine is a real kludge.  Someone really should do it better,
   but I'm too lazy, and I don't understand this stuff all too well
   anyway. (JF)  */

static void
int_to_gen (x)
     long x;
{
  char buf[20];
  char *bufp;

  sprintf (buf, "%ld", x);
  bufp = &buf[0];
  if (atof_generic (&bufp, ".", EXP_CHARS, &generic_floating_point_number))
    as_bad (_("Error converting number to floating point (Exponent overflow?)"));
}
#endif

#ifdef TEST
char *
print_gen (gen)
     FLONUM_TYPE *gen;
{
  FLONUM_TYPE f;
  LITTLENUM_TYPE arr[10];
  double dv;
  float fv;
  static char sbuf[40];

  if (gen)
    {
      f = generic_floating_point_number;
      generic_floating_point_number = *gen;
    }
  gen_to_words (&arr[0], 4, 11);
  memcpy (&dv, &arr[0], sizeof (double));
  sprintf (sbuf, "%x %x %x %x %.14G   ", arr[0], arr[1], arr[2], arr[3], dv);
  gen_to_words (&arr[0], 2, 8);
  memcpy (&fv, &arr[0], sizeof (float));
  sprintf (sbuf + strlen (sbuf), "%x %x %.12g\n", arr[0], arr[1], fv);

  if (gen)
    generic_floating_point_number = f;

  return (sbuf);
}

#endif
@


1.4
log
@resolve conflicts.
@
text
@a21 7
/* Some float formats are based on the IEEE standard, but use the
   largest exponent for normal numbers instead of NaNs and infinites.
   The macro TC_LARGEST_EXPONENT_IS_NORMAL should evaluate to true
   if the target machine uses such a format.  The macro can depend on
   command line flags if necessary.  There is no need to define the
   macro if it would always be 0.  */

d44 1
a44 1
#define TC_LARGEST_EXPONENT_IS_NORMAL 0
d298 1
a298 1
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
d337 1
a337 1
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
d378 1
a378 1
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
d594 1
a594 1
	   || (! TC_LARGEST_EXPONENT_IS_NORMAL
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d22 7
d39 1
a39 1
/* Precision in LittleNums. */
d47 1
a47 1
/* Length in LittleNums of guard bits. */
d50 4
a90 1

d113 3
a115 1
	  return_value |= (*littlenum_pointer >> bits_left_in_littlenum) & mask[number_of_bits];
d121 2
a122 1
      return_value = mask[number_of_bits] & (*littlenum_pointer >> bits_left_in_littlenum);
d124 1
a124 1
  return (return_value);
d127 2
a128 1
/* Num had better be less than LITTLENUM_NUMBER_OF_BITS */
d141 2
a142 1
      bits_left_in_littlenum = num - (LITTLENUM_NUMBER_OF_BITS - bits_left_in_littlenum);
d155 2
a156 1
  words[0] = (LITTLENUM_TYPE) ((unsigned) -1) >> 1; /* Zero the leftmost bit */
d164 3
a166 6
/************************************************************************\
 *	Warning: this returns 16-bit LITTLENUMs. It is up to the caller	*
 *	to figure out any alignment problems and to conspire for the	*
 *	bytes/word to be emitted in the right order. Bigendians beware!	*
 *									*
\************************************************************************/
d172 2
a173 1
/* Returns pointer past text consumed. */
d176 3
a178 3
     char *str;			/* Text to convert to binary. */
     int what_kind;		/* 'd', 'f', 'g', 'h' */
     LITTLENUM_TYPE *words;	/* Build the binary here. */
d180 2
a181 2
  /* Extra bits for zeroed low-order bits.  The 1st MAX_PRECISION are
     zeroed, the last contain flonum bits. */
d184 1
a184 1
  /* Number of 16-bit words in the format. */
d203 1
a203 1
     have 15 leading 0 bits, so could be useless. */
d264 1
d292 1
a292 1
      /* 0.0e0 seen. */
d299 1
a299 1
      return (return_value);
d302 1
a302 1
  /* NaN:  Do the right thing */
d305 2
d321 1
a321 1
#else /* ! TC_M68K */
d328 1
a328 1
#else /* ! TC_I386 */
d330 2
a331 2
#endif /* ! TC_I386 */
#endif /* ! TC_M68K */
d344 4
a347 1
      /* +INF:  Do the right thing */
d362 1
a362 1
#else /* ! TC_M68K */
d369 1
a369 1
#else /* ! TC_I386 */
d371 2
a372 2
#endif /* ! TC_I386 */
#endif /* ! TC_M68K */
d381 1
a381 1
      return (return_value);
d385 4
a388 1
      /* Negative INF */
d403 1
a403 1
#else /* ! TC_M68K */
d410 1
a410 1
#else /* ! TC_I386 */
d412 2
a413 2
#endif /* ! TC_I386 */
#endif /* ! TC_M68K */
d422 1
a422 1
      return (return_value);
d424 9
a432 10
  /*
   * The floating point formats we support have:
   * Bit 15 is sign bit.
   * Bits 14:n are excess-whatever exponent.
   * Bits n-1:0 (if any) are most significant bits of fraction.
   * Bits 15:0 of the next word(s) are the next most significant bits.
   *
   * So we need: number of bits of exponent, number of bits of
   * mantissa.
   */
d438 2
a439 1
  /* Seek (and forget) 1st significant bit */
d445 1
d447 1
a447 1
     generic_floating_point_number.leader. */
d449 2
a450 1
  /* Radix 2. */
d452 2
a453 1
  /* Forget leading zeros, forget 1st bit. */
a454 1
  /* Offset exponent. */
d456 1
d459 1
a459 1
  /* Word 1. Sign, exponent and perhaps high bits. */
d464 1
a464 1
  /* Assume 2's complement integers. */
d472 2
a473 1
      prec_bits = LITTLENUM_NUMBER_OF_BITS * precision - (exponent_bits + 1 + num_bits);
d487 1
a487 1
	  /* Bigger than one littlenum */
d490 2
a491 1
	  if (num_bits + exponent_bits + 1 > precision * LITTLENUM_NUMBER_OF_BITS)
d493 1
a493 1
	      /* Exponent overflow */
d495 1
a495 1
	      return (return_value);
d521 2
a522 1
	      word1 |= next_bits ((LITTLENUM_NUMBER_OF_BITS - 1) - (exponent_bits + num_bits));
d529 1
a529 1
      /* Round the mantissa up, but don't change the number */
d600 9
a608 11
  else if ((unsigned long) exponent_4 >= mask[exponent_bits])
    {
      /*
       * Exponent overflow. Lose immediately.
       */

      /*
       * We leave return_value alone: admit we read the
       * number, but return a floating exception
       * because we can't encode the number.
       */
d621 1
a621 1
     middle.  Either way, it is then followed by a 1 bit. */
d631 1
a631 1
  /* The rest of the words are just mantissa bits. */
d638 6
a643 8
      /*
       * Since the NEXT bit is a 1, round UP the mantissa.
       * The cunning design of these hidden-1 floats permits
       * us to let the mantissa overflow into the exponent, and
       * it 'does the right thing'. However, we lose if the
       * highest-order bit of the lowest-order word flips.
       * Is that clear?
       */
d668 1
a668 1
		 explicitly propagate the carry into the exponent. */
d673 1
a673 1
	      /* Put back the integer bit.  */ 
d676 1
a676 1
 	}
d679 3
a681 4
	  /* We leave return_value alone: admit we read the
	   * number, but return a floating exception
	   * because we can't encode the number.
	   */
d683 4
a686 2
	  /* make_invalid_floating_point_number (words); */
	  /* return return_value; */
d689 1
a689 1
  return (return_value);
d692 2
a693 1
#if 0 /* unused */
d697 1
d736 1
a736 3
    {
      generic_floating_point_number = f;
    }
a741 2

/* end of atof-ieee.c */
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 2
a3 1
   Copyright (C) 1987, 1992 Free Software Foundation, Inc.
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d24 2
a25 1
extern FLONUM_TYPE generic_floating_point_number;	/* Flonums returned here. */
d27 3
a29 3
#ifndef NULL
#define NULL (0)
#endif
d139 1
a139 1
  as_bad ("cannot create floating-point number");
d163 1
a163 1
     char what_kind;		/* 'd', 'f', 'g', 'h' */
d463 1
a463 1
	  if (num_bits + exponent_bits + 1 >= precision * LITTLENUM_NUMBER_OF_BITS)
d504 1
a504 1
	  if (prec_bits > LITTLENUM_NUMBER_OF_BITS)
d518 13
a530 1
	      if (tmp_bits > LITTLENUM_NUMBER_OF_BITS || (lp[n] & mask[tmp_bits]) != mask[tmp_bits])
d541 23
d565 1
a565 1
	  else if ((*lp & mask[prec_bits]) != mask[prec_bits])
d571 1
a571 1
  else if (exponent_4 >= mask[exponent_bits])
d627 1
a627 1
      for (carry = 1, lp--; carry && (lp >= words); lp--)
d632 2
d680 1
a680 1
    as_bad ("Error converting number to floating point (Exponent overflow?)");
@


1.1
log
@Initial revision
@
text
@d30 2
a31 1
#define MAX_PRECISION (6)
d34 2
a35 2
#define X_PRECISION (6)
#define P_PRECISION (6)
d262 9
d279 2
a280 1
      memset (&words[1], '\0', sizeof (LITTLENUM_TYPE) * (precision - 1));
d292 21
d330 21
d368 21
d436 1
a436 1
  if (exponent_4 < 1 && exponent_4 >= -62)
d444 1
d446 8
a453 1
	prec_bits -= LITTLENUM_NUMBER_OF_BITS + 1;
d466 1
d468 2
a469 5
	    {
	      *lp++ = 0;
	      *lp++ = 0;
	      num_bits -= LITTLENUM_NUMBER_OF_BITS - 1;
	    }
d483 1
d485 2
a486 10
	      if (num_bits == LITTLENUM_NUMBER_OF_BITS)
		{
		  *lp++ = 0;
		  *lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS - 1);
		}
	      else if (num_bits == LITTLENUM_NUMBER_OF_BITS - 1)
		*lp++ = 0;
	      else
		*lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS - 1 - num_bits);
	      num_bits = 0;
d494 1
a494 1
      while (lp < words + precision)
d528 1
a528 1
	    lp++;
d533 1
a533 1
  else if (exponent_4 & ~mask[exponent_bits])
d555 2
a556 2
  /* X_PRECISION is special: it has 16 bits of zero in the middle,
     followed by a 1 bit. */
d559 1
d561 3
a563 1
      *lp++ = 1 << (LITTLENUM_NUMBER_OF_BITS) | next_bits (LITTLENUM_NUMBER_OF_BITS - 1);
d567 1
a567 1
  while (lp < words + precision)
d595 17
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d30 1
a30 2
/* Don't count the gap in the m68k extended precision format.  */
#define MAX_PRECISION (5)
d33 2
a34 2
#define X_PRECISION (5)
#define P_PRECISION (5)
a260 9
  LITTLENUM_TYPE *words_end;

  words_end = words + precision;
#ifdef TC_M68K
  if (precision == X_PRECISION)
    /* On the m68k the extended precision format has a gap of 16 bits
       between the exponent and the mantissa.  */
    words_end++;
#endif
d269 1
a269 2
      memset (&words[1], '\0',
	      (words_end - words - 1) * sizeof (LITTLENUM_TYPE));
a280 21
      else if (precision == X_PRECISION)
	{
#ifdef TC_M68K
	  words[0] = 0x7fff;
	  words[1] = 0;
	  words[2] = 0xffff;
	  words[3] = 0xffff;
	  words[4] = 0xffff;
	  words[5] = 0xffff;
#else /* ! TC_M68K */
#ifdef TC_I386
	  words[0] = 0xffff;
	  words[1] = 0xc000;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
#else /* ! TC_I386 */
	  abort ();
#endif /* ! TC_I386 */
#endif /* ! TC_M68K */
	}
a297 21
      else if (precision == X_PRECISION)
	{
#ifdef TC_M68K
	  words[0] = 0x7fff;
	  words[1] = 0;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
	  words[5] = 0;
#else /* ! TC_M68K */
#ifdef TC_I386
	  words[0] = 0x7fff;
	  words[1] = 0x8000;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
#else /* ! TC_I386 */
	  abort ();
#endif /* ! TC_I386 */
#endif /* ! TC_M68K */
	}
a314 21
      else if (precision == X_PRECISION)
	{
#ifdef TC_M68K
	  words[0] = 0xffff;
	  words[1] = 0;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
	  words[5] = 0;
#else /* ! TC_M68K */
#ifdef TC_I386
	  words[0] = 0xffff;
	  words[1] = 0x8000;
	  words[2] = 0;
	  words[3] = 0;
	  words[4] = 0;
#else /* ! TC_I386 */
	  abort ();
#endif /* ! TC_I386 */
#endif /* ! TC_M68K */
	}
d362 1
a362 1
  if (exponent_4 <= 0)
a369 1
#ifdef TC_I386
d371 1
a371 8
	{
	  /* On the i386 a denormalized extended precision float is
	     shifted down by one, effectively decreasing the exponent
	     bias by one.  */
	  prec_bits -= 1;
	  num_bits += 1;
	}
#endif
a383 1
#ifdef TC_M68K
d385 5
a389 2
	    *lp++ = 0;
#endif
a402 1
#ifdef TC_M68K
d404 10
a413 2
#endif
	      *lp++ = next_bits (LITTLENUM_NUMBER_OF_BITS - num_bits);
d421 1
a421 1
      while (lp < words_end)
d455 1
a455 1
	    *lp += 1;
d460 1
a460 1
  else if (exponent_4 >= mask[exponent_bits])
d482 2
a483 2
  /* X_PRECISION is special: on the 68k, it has 16 bits of zero in the
     middle.  Either way, it is then followed by a 1 bit. */
a485 1
#ifdef TC_M68K
d487 1
a487 3
#endif
      *lp++ = (1 << (LITTLENUM_NUMBER_OF_BITS - 1)
	       | next_bits (LITTLENUM_NUMBER_OF_BITS - 1));
d491 1
a491 1
  while (lp < words_end)
a518 17
      if (precision == X_PRECISION && exponent_bits == 15)
	{
	  /* Extended precision numbers have an explicit integer bit
	     that we may have to restore.  */
	  if (lp == words)
	    {
#ifdef TC_M68K
	      /* On the m68k there is a gap of 16 bits.  We must
		 explicitly propagate the carry into the exponent. */
	      words[0] += words[1];
	      words[1] = 0;
	      lp++;
#endif
	      /* Put back the integer bit.  */ 
	      lp[1] |= 1 << (LITTLENUM_NUMBER_OF_BITS - 1);
	    }
 	}
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d22 1
a22 2
/* Flonums returned here.  */
extern FLONUM_TYPE generic_floating_point_number;
d24 3
a26 3
static int next_bits PARAMS ((int));
static void unget_bits PARAMS ((int));
static void make_invalid_floating_point_number PARAMS ((LITTLENUM_TYPE *));
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d138 1
a138 1
  as_bad (_("cannot create floating-point number"));
d162 1
a162 1
     int what_kind;		/* 'd', 'f', 'g', 'h' */
d462 1
a462 1
	  if (num_bits + exponent_bits + 1 > precision * LITTLENUM_NUMBER_OF_BITS)
d503 1
a503 1
	  if (prec_bits >= LITTLENUM_NUMBER_OF_BITS)
d517 1
a517 13
	      if (tmp_bits > LITTLENUM_NUMBER_OF_BITS
		  || (lp[n] & mask[tmp_bits]) != mask[tmp_bits]
		  || (prec_bits != (precision * LITTLENUM_NUMBER_OF_BITS
				    - exponent_bits - 1)
#ifdef TC_I386
		      /* An extended precision float with only the integer
			 bit set would be invalid.  That must be converted
			 to the smallest normalized number.  */
		      && !(precision == X_PRECISION
			   && prec_bits == (precision * LITTLENUM_NUMBER_OF_BITS
					    - exponent_bits - 2))
#endif
		      ))
a527 23
	      else
		{
		  /* This is an overflow of the denormal numbers.  We
                     need to forget what we have produced, and instead
                     generate the smallest normalized number.  */
		  lp = words;
		  word1 = ((generic_floating_point_number.sign == '+')
			   ? 0
			   : (1 << (LITTLENUM_NUMBER_OF_BITS - 1)));
		  word1 |= (1
			    << ((LITTLENUM_NUMBER_OF_BITS - 1)
				- exponent_bits));
		  *lp++ = word1;
#ifdef TC_I386
		  /* Set the integer bit in the extended precision format.
		     This cannot happen on the m68k where the mantissa
		     just overflows into the integer bit above.  */
		  if (precision == X_PRECISION)
		    *lp++ = 1 << (LITTLENUM_NUMBER_OF_BITS - 1);
#endif
		  while (lp < words_end)
		    *lp++ = 0;
		}
d529 1
a529 1
	  else
d535 1
a535 1
  else if ((unsigned long) exponent_4 >= mask[exponent_bits])
d591 1
a591 1
      for (carry = 1, lp--; carry; lp--)
a595 2
	  if (lp == words)
	    break;
d642 1
a642 1
    as_bad (_("Error converting number to floating point (Exponent overflow?)"));
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1987, 1992, 1994, 1996, 1997, 1998, 1999, 2000, 2001
a21 7
/* Some float formats are based on the IEEE standard, but use the
   largest exponent for normal numbers instead of NaNs and infinites.
   The macro TC_LARGEST_EXPONENT_IS_NORMAL should evaluate to true
   if the target machine uses such a format.  The macro can depend on
   command line flags if necessary.  There is no need to define the
   macro if it would always be 0.  */

d32 1
a32 1
/* Precision in LittleNums.  */
d40 1
a40 1
/* Length in LittleNums of guard bits.  */
a42 4
#ifndef TC_LARGEST_EXPONENT_IS_NORMAL
#define TC_LARGEST_EXPONENT_IS_NORMAL 0
#endif

d80 1
d103 1
a103 3
	  return_value |=
	    (*littlenum_pointer >> bits_left_in_littlenum)
	    & mask[number_of_bits];
d109 1
a109 2
      return_value =
	mask[number_of_bits] & (*littlenum_pointer >> bits_left_in_littlenum);
d111 1
a111 1
  return return_value;
d114 1
a114 2
/* Num had better be less than LITTLENUM_NUMBER_OF_BITS.  */

d127 1
a127 2
      bits_left_in_littlenum =
	num - (LITTLENUM_NUMBER_OF_BITS - bits_left_in_littlenum);
d140 1
a140 2
  /* Zero the leftmost bit.  */
  words[0] = (LITTLENUM_TYPE) ((unsigned) -1) >> 1;
d148 6
a153 3
/* Warning: This returns 16-bit LITTLENUMs.  It is up to the caller to
   figure out any alignment problems and to conspire for the
   bytes/word to be emitted in the right order.  Bigendians beware!  */
d159 1
a159 2
/* Returns pointer past text consumed.  */

d162 3
a164 3
     char *str;			/* Text to convert to binary.  */
     int what_kind;		/* 'd', 'f', 'g', 'h'.  */
     LITTLENUM_TYPE *words;	/* Build the binary here.  */
d166 2
a167 2
  /* Extra bits for zeroed low-order bits.
     The 1st MAX_PRECISION are zeroed, the last contain flonum bits.  */
d170 1
a170 1
  /* Number of 16-bit words in the format.  */
d189 1
a189 1
     have 15 leading 0 bits, so could be useless.  */
a249 1

d277 1
a277 1
      /* 0.0e0 seen.  */
d284 1
a284 1
      return return_value;
d287 1
a287 1
  /* NaN:  Do the right thing.  */
a289 2
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
	as_warn ("NaNs are not supported by this target\n");
d304 1
a304 1
#else /* ! TC_M68K  */
d311 1
a311 1
#else /* ! TC_I386  */
d313 2
a314 2
#endif /* ! TC_I386  */
#endif /* ! TC_M68K  */
d327 1
a327 4
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
	as_warn ("Infinities are not supported by this target\n");

      /* +INF:  Do the right thing.  */
d342 1
a342 1
#else /* ! TC_M68K  */
d349 1
a349 1
#else /* ! TC_I386  */
d351 2
a352 2
#endif /* ! TC_I386  */
#endif /* ! TC_M68K  */
d361 1
a361 1
      return return_value;
d365 1
a365 4
      if (TC_LARGEST_EXPONENT_IS_NORMAL)
	as_warn ("Infinities are not supported by this target\n");

      /* Negative INF.  */
d380 1
a380 1
#else /* ! TC_M68K  */
d387 1
a387 1
#else /* ! TC_I386  */
d389 2
a390 2
#endif /* ! TC_I386  */
#endif /* ! TC_M68K  */
d399 1
a399 1
      return return_value;
d401 10
a410 9

  /* The floating point formats we support have:
     Bit 15 is sign bit.
     Bits 14:n are excess-whatever exponent.
     Bits n-1:0 (if any) are most significant bits of fraction.
     Bits 15:0 of the next word(s) are the next most significant bits.

     So we need: number of bits of exponent, number of bits of
     mantissa.  */
d416 1
a416 2

  /* Seek (and forget) 1st significant bit.  */
a421 1

d423 1
a423 1
     generic_floating_point_number.leader.  */
d425 1
a425 2

  /* Radix 2.  */
d427 1
a427 2

  /* Forget leading zeros, forget 1st bit.  */
d429 1
a430 1
  /* Offset exponent.  */
d433 1
a433 1
  /* Word 1.  Sign, exponent and perhaps high bits.  */
d438 1
a438 1
  /* Assume 2's complement integers.  */
d446 1
a446 2
      prec_bits =
	LITTLENUM_NUMBER_OF_BITS * precision - (exponent_bits + 1 + num_bits);
d460 1
a460 1
	  /* Bigger than one littlenum.  */
d463 1
a463 2
	  if (num_bits + exponent_bits + 1
	      > precision * LITTLENUM_NUMBER_OF_BITS)
d465 1
a465 1
	      /* Exponent overflow.  */
d467 1
a467 1
	      return return_value;
d493 1
a493 2
	      word1 |= next_bits ((LITTLENUM_NUMBER_OF_BITS - 1)
				  - (exponent_bits + num_bits));
d500 1
a500 1
      /* Round the mantissa up, but don't change the number.  */
d571 11
a581 9
  else if ((unsigned long) exponent_4 > mask[exponent_bits]
	   || (! TC_LARGEST_EXPONENT_IS_NORMAL
	       && (unsigned long) exponent_4 == mask[exponent_bits]))
    {
      /* Exponent overflow.  Lose immediately.  */

      /* We leave return_value alone: admit we read the
	 number, but return a floating exception
	 because we can't encode the number.  */
d594 1
a594 1
     middle.  Either way, it is then followed by a 1 bit.  */
d604 1
a604 1
  /* The rest of the words are just mantissa bits.  */
d611 8
a618 6
      /* Since the NEXT bit is a 1, round UP the mantissa.
	 The cunning design of these hidden-1 floats permits
	 us to let the mantissa overflow into the exponent, and
	 it 'does the right thing'. However, we lose if the
	 highest-order bit of the lowest-order word flips.
	 Is that clear?  */
d643 1
a643 1
		 explicitly propagate the carry into the exponent.  */
d648 1
a648 1
	      /* Put back the integer bit.  */
d651 1
a651 1
	}
d654 4
a657 3
	  /* We leave return_value alone: admit we read the number,
	     but return a floating exception because we can't encode
	     the number.  */
d659 2
a660 4
#if 0
	  make_invalid_floating_point_number (words);
	  return return_value;
#endif
d663 1
a663 1
  return return_value;
d666 1
a666 2
#if 0
/* Unused.  */
a669 1

d708 3
a710 1
    generic_floating_point_number = f;
d716 2
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d22 7
d51 1
a51 1
#define TC_LARGEST_EXPONENT_IS_NORMAL(PRECISION) 0
d305 1
a305 1
      if (TC_LARGEST_EXPONENT_IS_NORMAL (precision))
d344 1
a344 1
      if (TC_LARGEST_EXPONENT_IS_NORMAL (precision))
d385 1
a385 1
      if (TC_LARGEST_EXPONENT_IS_NORMAL (precision))
d601 1
a601 1
	   || (! TC_LARGEST_EXPONENT_IS_NORMAL (precision)
@


