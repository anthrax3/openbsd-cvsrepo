head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.28;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.30;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.36;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.50;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.44;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.05.55;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.08;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.08;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.41;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.44.55;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.25;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.23.08;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.26;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.35.56;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.31;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.53;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-m68k.c -- Assemble for the m68k family
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "obstack.h"
#include "subsegs.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"

#include "opcode/m68k.h"
#include "m68k-parse.h"

#if defined (OBJ_ELF)
#include "elf/m68k.h"
#endif

/* This string holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  The macro
   tc_comment_chars points to this.  We use this, rather than the
   usual comment_chars, so that the --bitwise-or option will work.  */
#if defined (TE_SVR4) || defined (TE_DELTA)
const char *m68k_comment_chars = "|#";
#else
const char *m68k_comment_chars = "|";
#endif

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#*";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant, as
   in "0f12.456" or "0d1.2345e12".  */

const char FLT_CHARS[] = "rRsSfFdDxXeEpP";

/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c .  Ideally it shouldn't have to know about it at all,
   but nothing is ideal around here.  */

const int md_reloc_size = 8;	/* Size of relocation record.  */

/* Are we trying to generate PIC code?  If so, absolute references
   ought to be made into linkage table references or pc-relative
   references.  Not implemented.  For ELF there are other means
   to denote pic relocations.  */
int flag_want_pic;

static int flag_short_refs;	/* -l option.  */
static int flag_long_jumps;	/* -S option.  */
static int flag_keep_pcrel;	/* --pcrel option.  */

#ifdef REGISTER_PREFIX_OPTIONAL
int flag_reg_prefix_optional = REGISTER_PREFIX_OPTIONAL;
#else
int flag_reg_prefix_optional;
#endif

/* Whether --register-prefix-optional was used on the command line.  */
static int reg_prefix_optional_seen;

/* The floating point coprocessor to use by default.  */
static enum m68k_register m68k_float_copnum = COP1;

/* If this is non-zero, then references to number(%pc) will be taken
   to refer to number, rather than to %pc + number.  */
static int m68k_abspcadd;

/* If this is non-zero, then the quick forms of the move, add, and sub
   instructions are used when possible.  */
static int m68k_quick = 1;

/* If this is non-zero, then if the size is not specified for a base
   or outer displacement, the assembler assumes that the size should
   be 32 bits.  */
static int m68k_rel32 = 1;

/* This is non-zero if m68k_rel32 was set from the command line.  */
static int m68k_rel32_from_cmdline;

/* The default width to use for an index register when using a base
   displacement.  */
static enum m68k_size m68k_index_width_default = SIZE_LONG;

/* We want to warn if any text labels are misaligned.  In order to get
   the right line number, we need to record the line number for each
   label.  */
struct label_line
{
  struct label_line *next;
  symbolS *label;
  char *file;
  unsigned int line;
  int text;
};

/* The list of labels.  */

static struct label_line *labels;

/* The current label.  */

static struct label_line *current_label;

/* Its an arbitrary name:  This means I don't approve of it.
   See flames below.  */
static struct obstack robyn;

struct m68k_incant
  {
    const char *m_operands;
    unsigned long m_opcode;
    short m_opnum;
    short m_codenum;
    int m_arch;
    struct m68k_incant *m_next;
  };

#define getone(x)	((((x)->m_opcode)>>16)&0xffff)
#define gettwo(x)	(((x)->m_opcode)&0xffff)

static const enum m68k_register m68000_control_regs[] = { 0 };
static const enum m68k_register m68010_control_regs[] = {
  SFC, DFC, USP, VBR,
  0
};
static const enum m68k_register m68020_control_regs[] = {
  SFC, DFC, USP, VBR, CACR, CAAR, MSP, ISP,
  0
};
static const enum m68k_register m68040_control_regs[] = {
  SFC, DFC, CACR, TC, ITT0, ITT1, DTT0, DTT1,
  USP, VBR, MSP, ISP, MMUSR, URP, SRP,
  0
};
static const enum m68k_register m68060_control_regs[] = {
  SFC, DFC, CACR, TC, ITT0, ITT1, DTT0, DTT1, BUSCR,
  USP, VBR, URP, SRP, PCR,
  0
};
static const enum m68k_register mcf_control_regs[] = {
  CACR, TC, ACR0, ACR1, ACR2, ACR3, VBR, ROMBAR,
  RAMBAR0, RAMBAR1, MBAR,
  0
};
static const enum m68k_register mcf528x_control_regs[] = {
  CACR, ACR0, ACR1, VBR, FLASHBAR, RAMBAR,
  0
};
static const enum m68k_register mcfv4e_control_regs[] = {
  CACR, TC, ITT0, ITT1, DTT0, DTT1, BUSCR, VBR, PC, ROMBAR,
  ROMBAR1, RAMBAR0, RAMBAR1, MPCR, EDRAMBAR, SECMBAR, MBAR, MBAR0, MBAR1,
  PCR1U0, PCR1L0, PCR1U1, PCR1L1, PCR2U0, PCR2L0, PCR2U1, PCR2L1,
  PCR3U0, PCR3L0, PCR3U1, PCR3L1,
  0
};
#define cpu32_control_regs m68010_control_regs

static const enum m68k_register *control_regs;

/* Internal form of a 68020 instruction.  */
struct m68k_it
{
  const char *error;
  const char *args;		/* List of opcode info.  */
  int numargs;

  int numo;			/* Number of shorts in opcode.  */
  short opcode[11];

  struct m68k_op operands[6];

  int nexp;			/* Number of exprs in use.  */
  struct m68k_exp exprs[4];

  int nfrag;			/* Number of frags we have to produce.  */
  struct
    {
      int fragoff;		/* Where in the current opcode the frag ends.  */
      symbolS *fadd;
      offsetT foff;
      int fragty;
    }
  fragb[4];

  int nrel;			/* Num of reloc strucs in use.  */
  struct
    {
      int n;
      expressionS exp;
      char wid;
      char pcrel;
      /* In a pc relative address the difference between the address
	 of the offset and the address that the offset is relative
	 to.  This depends on the addressing mode.  Basically this
	 is the value to put in the offset field to address the
	 first byte of the offset, without regarding the special
	 significance of some values (in the branch instruction, for
	 example).  */
      int pcrel_fix;
#ifdef OBJ_ELF
      /* Whether this expression needs special pic relocation, and if
	 so, which.  */
      enum pic_relocation pic_reloc;
#endif
    }
  reloc[5];			/* Five is enough???  */
};

#define cpu_of_arch(x)		((x) & (m68000up | mcf))
#define float_of_arch(x)	((x) & mfloat)
#define mmu_of_arch(x)		((x) & mmmu)
#define arch_coldfire_p(x)	((x) & mcf)
#define arch_coldfire_v4e_p(x)	((x) & mcfv4e)

/* Macros for determining if cpu supports a specific addressing mode.  */
#define HAVE_LONG_BRANCH(x)     ((x) & (m68020|m68030|m68040|m68060|cpu32|mcf5407|mcfv4e))

static struct m68k_it the_ins;	/* The instruction being assembled.  */

#define op(ex)		((ex)->exp.X_op)
#define adds(ex)	((ex)->exp.X_add_symbol)
#define subs(ex)	((ex)->exp.X_op_symbol)
#define offs(ex)	((ex)->exp.X_add_number)

/* Macros for adding things to the m68k_it struct.  */
#define addword(w)	the_ins.opcode[the_ins.numo++]=(w)

/* Static functions.  */
static void insop PARAMS ((int, const struct m68k_incant *));
static void add_fix PARAMS ((int, struct m68k_exp *, int, int));
static void add_frag PARAMS ((symbolS *, offsetT, int));

/* Like addword, but goes BEFORE general operands.  */

static void
insop (w, opcode)
     int w;
     const struct m68k_incant *opcode;
{
  int z;
  for (z = the_ins.numo; z > opcode->m_codenum; --z)
    the_ins.opcode[z] = the_ins.opcode[z - 1];
  for (z = 0; z < the_ins.nrel; z++)
    the_ins.reloc[z].n += 2;
  for (z = 0; z < the_ins.nfrag; z++)
    the_ins.fragb[z].fragoff++;
  the_ins.opcode[opcode->m_codenum] = w;
  the_ins.numo++;
}

/* The numo+1 kludge is so we can hit the low order byte of the prev word.
   Blecch.  */
static void
add_fix (width, exp, pc_rel, pc_fix)
     int width;
     struct m68k_exp *exp;
     int pc_rel;
     int pc_fix;
{
  the_ins.reloc[the_ins.nrel].n = ((width == 'B' || width == '3')
				   ? (the_ins.numo*2-1)
				   : (((width)=='b')
				      ? (the_ins.numo*2+1)
				      : (the_ins.numo*2)));
  the_ins.reloc[the_ins.nrel].exp = exp->exp;
  the_ins.reloc[the_ins.nrel].wid = width;
  the_ins.reloc[the_ins.nrel].pcrel_fix = pc_fix;
#ifdef OBJ_ELF
  the_ins.reloc[the_ins.nrel].pic_reloc = exp->pic_reloc;
#endif
  the_ins.reloc[the_ins.nrel++].pcrel = pc_rel;
}

/* Cause an extra frag to be generated here, inserting up to 10 bytes
   (that value is chosen in the frag_var call in md_assemble).  TYPE
   is the subtype of the frag to be generated; its primary type is
   rs_machine_dependent.

   The TYPE parameter is also used by md_convert_frag_1 and
   md_estimate_size_before_relax.  The appropriate type of fixup will
   be emitted by md_convert_frag_1.

   ADD becomes the FR_SYMBOL field of the frag, and OFF the FR_OFFSET.  */
static void
add_frag (add, off, type)
     symbolS *add;
     offsetT off;
     int type;
{
  the_ins.fragb[the_ins.nfrag].fragoff = the_ins.numo;
  the_ins.fragb[the_ins.nfrag].fadd = add;
  the_ins.fragb[the_ins.nfrag].foff = off;
  the_ins.fragb[the_ins.nfrag++].fragty = type;
}

#define isvar(ex) \
  (op (ex) != O_constant && op (ex) != O_big)

static char *crack_operand PARAMS ((char *str, struct m68k_op *opP));
static int get_num PARAMS ((struct m68k_exp *exp, int ok));
static void m68k_ip PARAMS ((char *));
static void insert_reg PARAMS ((const char *, int));
static void select_control_regs PARAMS ((void));
static void init_regtable PARAMS ((void));
static int reverse_16_bits PARAMS ((int in));
static int reverse_8_bits PARAMS ((int in));
static void install_gen_operand PARAMS ((int mode, int val));
static void install_operand PARAMS ((int mode, int val));
static void s_bss PARAMS ((int));
static void s_data1 PARAMS ((int));
static void s_data2 PARAMS ((int));
static void s_even PARAMS ((int));
static void s_proc PARAMS ((int));
static void mri_chip PARAMS ((void));
static void s_chip PARAMS ((int));
static void s_fopt PARAMS ((int));
static void s_opt PARAMS ((int));
static void s_reg PARAMS ((int));
static void s_restore PARAMS ((int));
static void s_save PARAMS ((int));
static void s_mri_if PARAMS ((int));
static void s_mri_else PARAMS ((int));
static void s_mri_endi PARAMS ((int));
static void s_mri_break PARAMS ((int));
static void s_mri_next PARAMS ((int));
static void s_mri_for PARAMS ((int));
static void s_mri_endf PARAMS ((int));
static void s_mri_repeat PARAMS ((int));
static void s_mri_until PARAMS ((int));
static void s_mri_while PARAMS ((int));
static void s_mri_endw PARAMS ((int));
static void md_convert_frag_1 PARAMS ((fragS *));

static int current_architecture;

struct m68k_cpu
  {
    unsigned long arch;
    const char *name;
    int alias;
  };

static const struct m68k_cpu archs[] =
  {
    { m68000,  "68000", 0 },
    { m68010,  "68010", 0 },
    { m68020,  "68020", 0 },
    { m68030,  "68030", 0 },
    { m68040,  "68040", 0 },
    { m68060,  "68060", 0 },
    { cpu32,   "cpu32", 0 },
    { m68881,  "68881", 0 },
    { m68851,  "68851", 0 },
    { mcf5200, "5200",  0 },
    { mcf5206e,"5206e", 0 },
    { mcf528x, "528x",  0 },
    { mcf5307, "5307",  0 },
    { mcf5407, "5407",  0 },
    { mcfv4e,  "cfv4e", 0 },
    /* Aliases (effectively, so far as gas is concerned) for the above
       cpus.  */
    { m68020, "68k", 1 },
    { m68000, "68008", 1 },
    { m68000, "68302", 1 },
    { m68000, "68306", 1 },
    { m68000, "68307", 1 },
    { m68000, "68322", 1 },
    { m68000, "68356", 1 },
    { m68000, "68ec000", 1 },
    { m68000, "68hc000", 1 },
    { m68000, "68hc001", 1 },
    { m68020, "68ec020", 1 },
    { m68030, "68ec030", 1 },
    { m68040, "68ec040", 1 },
    { m68060, "68ec060", 1 },
    { cpu32,  "68330", 1 },
    { cpu32,  "68331", 1 },
    { cpu32,  "68332", 1 },
    { cpu32,  "68333", 1 },
    { cpu32,  "68334", 1 },
    { cpu32,  "68336", 1 },
    { cpu32,  "68340", 1 },
    { cpu32,  "68341", 1 },
    { cpu32,  "68349", 1 },
    { cpu32,  "68360", 1 },
    { m68881, "68882", 1 },
    { mcf5200, "5202", 1 },
    { mcf5200, "5204", 1 },
    { mcf5200, "5206", 1 },
    { mcf5407, "cfv4", 1 },
  };

static const int n_archs = sizeof (archs) / sizeof (archs[0]);

/* This is the assembler relaxation table for m68k. m68k is a rich CISC
   architecture and we have a lot of relaxation modes.  */

/* Macros used in the relaxation code.  */
#define TAB(x,y)	(((x) << 2) + (y))
#define TABTYPE(x)      ((x) >> 2)

/* Relaxation states.  */
#define BYTE		0
#define SHORT		1
#define LONG		2
#define SZ_UNDEF	3

/* Here are all the relaxation modes we support.  First we can relax ordinary
   branches.  On 68020 and higher and on CPU32 all branch instructions take
   three forms, so on these CPUs all branches always remain as such.  When we
   have to expand to the LONG form on a 68000, though, we substitute an
   absolute jump instead.  This is a direct replacement for unconditional
   branches and a branch over a jump for conditional branches.  However, if the
   user requires PIC and disables this with --pcrel, we can only relax between
   BYTE and SHORT forms, punting if that isn't enough.  This gives us four
   different relaxation modes for branches:  */

#define BRANCHBWL	0	/* Branch byte, word, or long.  */
#define BRABSJUNC	1	/* Absolute jump for LONG, unconditional.  */
#define BRABSJCOND	2	/* Absolute jump for LONG, conditional.  */
#define BRANCHBW	3	/* Branch byte or word.  */

/* We also relax coprocessor branches and DBcc's.  All CPUs that support
   coprocessor branches support them in word and long forms, so we have only
   one relaxation mode for them.  DBcc's are word only on all CPUs.  We can
   relax them to the LONG form with a branch-around sequence.  This sequence
   can use a long branch (if available) or an absolute jump (if acceptable).
   This gives us two relaxation modes.  If long branches are not available and
   absolute jumps are not acceptable, we don't relax DBcc's.  */

#define FBRANCH		4	/* Coprocessor branch.  */
#define DBCCLBR		5	/* DBcc relaxable with a long branch.  */
#define DBCCABSJ	6	/* DBcc relaxable with an absolute jump.  */

/* That's all for instruction relaxation.  However, we also relax PC-relative
   operands.  Specifically, we have three operand relaxation modes.  On the
   68000 PC-relative operands can only be 16-bit, but on 68020 and higher and
   on CPU32 they may be 16-bit or 32-bit.  For the latter we relax between the
   two.  Also PC+displacement+index operands in their simple form (with a non-
   suppressed index without memory indirection) are supported on all CPUs, but
   on the 68000 the displacement can be 8-bit only, whereas on 68020 and higher
   and on CPU32 we relax it to SHORT and LONG forms as well using the extended
   form of the PC+displacement+index operand.  Finally, some absolute operands
   can be relaxed down to 16-bit PC-relative.  */

#define PCREL1632	7	/* 16-bit or 32-bit PC-relative.  */
#define PCINDEX		8	/* PC + displacement + index. */
#define ABSTOPCREL	9	/* Absolute relax down to 16-bit PC-relative.  */

/* Note that calls to frag_var need to specify the maximum expansion
   needed; this is currently 10 bytes for DBCC.  */

/* The fields are:
   How far Forward this mode will reach:
   How far Backward this mode will reach:
   How many bytes this mode will add to the size of the frag
   Which mode to go to if the offset won't fit in this one

   Please check tc-m68k.h:md_prepare_relax_scan if changing this table.  */
relax_typeS md_relax_table[] =
{
  {   127,   -128,  0, TAB (BRANCHBWL, SHORT) },
  { 32767, -32768,  2, TAB (BRANCHBWL, LONG) },
  {     0,	0,  4, 0 },
  {     1,	1,  0, 0 },

  {   127,   -128,  0, TAB (BRABSJUNC, SHORT) },
  { 32767, -32768,  2, TAB (BRABSJUNC, LONG) },
  {	0,	0,  4, 0 },
  {	1,	1,  0, 0 },

  {   127,   -128,  0, TAB (BRABSJCOND, SHORT) },
  { 32767, -32768,  2, TAB (BRABSJCOND, LONG) },
  {	0,	0,  6, 0 },
  {	1,	1,  0, 0 },

  {   127,   -128,  0, TAB (BRANCHBW, SHORT) },
  {	0,	0,  2, 0 },
  {	1,	1,  0, 0 },
  {	1,	1,  0, 0 },

  {	1, 	1,  0, 0 },		/* FBRANCH doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (FBRANCH, LONG) },
  {	0,	0,  4, 0 },
  {	1, 	1,  0, 0 },

  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (DBCCLBR, LONG) },
  {	0,	0, 10, 0 },
  {	1,	1,  0, 0 },

  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (DBCCABSJ, LONG) },
  {	0,	0, 10, 0 },
  {	1,	1,  0, 0 },

  {	1, 	1,  0, 0 },		/* PCREL1632 doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (PCREL1632, LONG) },
  {	0,	0,  6, 0 },
  {	1,	1,  0, 0 },

  {   125,   -130,  0, TAB (PCINDEX, SHORT) },
  { 32765, -32770,  2, TAB (PCINDEX, LONG) },
  {	0,	0,  4, 0 },
  {	1,	1,  0, 0 },

  {	1,	1,  0, 0 },		/* ABSTOPCREL doesn't come BYTE.  */
  { 32767, -32768,  2, TAB (ABSTOPCREL, LONG) },
  {	0,	0,  4, 0 },
  {	1,	1,  0, 0 },
};

/* These are the machine dependent pseudo-ops.  These are included so
   the assembler can work on the output from the SUN C compiler, which
   generates these.  */

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */
const pseudo_typeS md_pseudo_table[] =
{
  {"data1", s_data1, 0},
  {"data2", s_data2, 0},
  {"bss", s_bss, 0},
  {"even", s_even, 0},
  {"skip", s_space, 0},
  {"proc", s_proc, 0},
#if defined (TE_SUN3) || defined (OBJ_ELF)
  {"align", s_align_bytes, 0},
#endif
#ifdef OBJ_ELF
  {"swbeg", s_ignore, 0},
#endif
  {"extend", float_cons, 'x'},
  {"ldouble", float_cons, 'x'},

  /* The following pseudo-ops are supported for MRI compatibility.  */
  {"chip", s_chip, 0},
  {"comline", s_space, 1},
  {"fopt", s_fopt, 0},
  {"mask2", s_ignore, 0},
  {"opt", s_opt, 0},
  {"reg", s_reg, 0},
  {"restore", s_restore, 0},
  {"save", s_save, 0},

  {"if", s_mri_if, 0},
  {"if.b", s_mri_if, 'b'},
  {"if.w", s_mri_if, 'w'},
  {"if.l", s_mri_if, 'l'},
  {"else", s_mri_else, 0},
  {"else.s", s_mri_else, 's'},
  {"else.l", s_mri_else, 'l'},
  {"endi", s_mri_endi, 0},
  {"break", s_mri_break, 0},
  {"break.s", s_mri_break, 's'},
  {"break.l", s_mri_break, 'l'},
  {"next", s_mri_next, 0},
  {"next.s", s_mri_next, 's'},
  {"next.l", s_mri_next, 'l'},
  {"for", s_mri_for, 0},
  {"for.b", s_mri_for, 'b'},
  {"for.w", s_mri_for, 'w'},
  {"for.l", s_mri_for, 'l'},
  {"endf", s_mri_endf, 0},
  {"repeat", s_mri_repeat, 0},
  {"until", s_mri_until, 0},
  {"until.b", s_mri_until, 'b'},
  {"until.w", s_mri_until, 'w'},
  {"until.l", s_mri_until, 'l'},
  {"while", s_mri_while, 0},
  {"while.b", s_mri_while, 'b'},
  {"while.w", s_mri_while, 'w'},
  {"while.l", s_mri_while, 'l'},
  {"endw", s_mri_endw, 0},

  {0, 0, 0}
};

/* The mote pseudo ops are put into the opcode table, since they
   don't start with a . they look like opcodes to gas.
   */

#ifdef M68KCOFF
extern void obj_coff_section PARAMS ((int));
#endif

const pseudo_typeS mote_pseudo_table[] =
{

  {"dcl", cons, 4},
  {"dc", cons, 2},
  {"dcw", cons, 2},
  {"dcb", cons, 1},

  {"dsl", s_space, 4},
  {"ds", s_space, 2},
  {"dsw", s_space, 2},
  {"dsb", s_space, 1},

  {"xdef", s_globl, 0},
#ifdef OBJ_ELF
  {"align", s_align_bytes, 0},
#else
  {"align", s_align_ptwo, 0},
#endif
#ifdef M68KCOFF
  {"sect", obj_coff_section, 0},
  {"section", obj_coff_section, 0},
#endif
  {0, 0, 0}
};

#define issbyte(x)	((x)>=-128 && (x)<=127)
#define isubyte(x)	((x)>=0 && (x)<=255)
#define issword(x)	((x)>=-32768 && (x)<=32767)
#define isuword(x)	((x)>=0 && (x)<=65535)

#define isbyte(x)	((x)>= -255 && (x)<=255)
#define isword(x)	((x)>=-65536 && (x)<=65535)
#define islong(x)	(1)

extern char *input_line_pointer;

static char notend_table[256];
static char alt_notend_table[256];
#define notend(s)						\
  (! (notend_table[(unsigned char) *s]				\
      || (*s == ':'						\
	  && alt_notend_table[(unsigned char) s[1]])))

#if defined (M68KCOFF) && !defined (BFD_ASSEMBLER)

#ifdef NO_PCREL_RELOCS

int
make_pcrel_absolute(fixP, add_number)
    fixS *fixP;
    long *add_number;
{
  register unsigned char *opcode = fixP->fx_frag->fr_opcode;

  /* Rewrite the PC relative instructions to absolute address ones.
     these are rumored to be faster, and the apollo linker refuses
     to deal with the PC relative relocations.  */
  if (opcode[0] == 0x60 && opcode[1] == 0xff) /* BRA -> JMP.  */
    {
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative branch to absolute jump"));
      opcode[0] = 0x4e;
      opcode[1] = 0xf9;
    }
  else if (opcode[0] == 0x61 && opcode[1] == 0xff) /* BSR -> JSR.  */
    {
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative BSR to absolute JSR"));
      opcode[0] = 0x4e;
      opcode[1] = 0xb9;
    }
  else
    as_fatal (_("Unknown PC relative instruction"));
  *add_number -= 4;
  return 0;
}

#endif /* NO_PCREL_RELOCS */

short
tc_coff_fix2rtype (fixP)
     fixS *fixP;
{
  if (fixP->fx_tcbit && fixP->fx_size == 4)
    return R_RELLONG_NEG;
#ifdef NO_PCREL_RELOCS
  know (fixP->fx_pcrel == 0);
  return (fixP->fx_size == 1 ? R_RELBYTE
	  : fixP->fx_size == 2 ? R_DIR16
	  : R_DIR32);
#else
  return (fixP->fx_pcrel ?
	  (fixP->fx_size == 1 ? R_PCRBYTE :
	   fixP->fx_size == 2 ? R_PCRWORD :
	   R_PCRLONG) :
	  (fixP->fx_size == 1 ? R_RELBYTE :
	   fixP->fx_size == 2 ? R_RELWORD :
	   R_RELLONG));
#endif
}

#endif

#ifdef OBJ_ELF

/* Return zero if the reference to SYMBOL from within the same segment may
   be relaxed.  */

/* On an ELF system, we can't relax an externally visible symbol,
   because it may be overridden by a shared library.  However, if
   TARGET_OS is "elf", then we presume that we are assembling for an
   embedded system, in which case we don't have to worry about shared
   libraries, and we can relax any external sym.  */

#define relaxable_symbol(symbol) \
  (!((S_IS_EXTERNAL (symbol) && EXTERN_FORCE_RELOC) \
     || S_IS_WEAK (symbol)))

/* Compute the relocation code for a fixup of SIZE bytes, using pc
   relative relocation if PCREL is non-zero.  PIC says whether a special
   pic relocation was requested.  */

static bfd_reloc_code_real_type get_reloc_code
  PARAMS ((int, int, enum pic_relocation));

static bfd_reloc_code_real_type
get_reloc_code (size, pcrel, pic)
     int size;
     int pcrel;
     enum pic_relocation pic;
{
  switch (pic)
    {
    case pic_got_pcrel:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_GOT_PCREL;
	case 2:
	  return BFD_RELOC_16_GOT_PCREL;
	case 4:
	  return BFD_RELOC_32_GOT_PCREL;
	}
      break;

    case pic_got_off:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_GOTOFF;
	case 2:
	  return BFD_RELOC_16_GOTOFF;
	case 4:
	  return BFD_RELOC_32_GOTOFF;
	}
      break;

    case pic_plt_pcrel:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_PLT_PCREL;
	case 2:
	  return BFD_RELOC_16_PLT_PCREL;
	case 4:
	  return BFD_RELOC_32_PLT_PCREL;
	}
      break;

    case pic_plt_off:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_PLTOFF;
	case 2:
	  return BFD_RELOC_16_PLTOFF;
	case 4:
	  return BFD_RELOC_32_PLTOFF;
	}
      break;

    case pic_none:
      if (pcrel)
	{
	  switch (size)
	    {
	    case 1:
	      return BFD_RELOC_8_PCREL;
	    case 2:
	      return BFD_RELOC_16_PCREL;
	    case 4:
	      return BFD_RELOC_32_PCREL;
	    }
	}
      else
	{
	  switch (size)
	    {
	    case 1:
	      return BFD_RELOC_8;
	    case 2:
	      return BFD_RELOC_16;
	    case 4:
	      return BFD_RELOC_32;
	    }
	}
    }

  if (pcrel)
    {
      if (pic == pic_none)
	as_bad (_("Can not do %d byte pc-relative relocation"), size);
      else
	as_bad (_("Can not do %d byte pc-relative pic relocation"), size);
    }
  else
    {
      if (pic == pic_none)
	as_bad (_("Can not do %d byte relocation"), size);
      else
	as_bad (_("Can not do %d byte pic relocation"), size);
    }

  return BFD_RELOC_NONE;
}

/* Here we decide which fixups can be adjusted to make them relative
   to the beginning of the section instead of the symbol.  Basically
   we need to make sure that the dynamic relocations are done
   correctly, so in some cases we force the original symbol to be
   used.  */
int
tc_m68k_fix_adjustable (fixP)
     fixS *fixP;
{
  /* Adjust_reloc_syms doesn't know about the GOT.  */
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_8_GOT_PCREL:
    case BFD_RELOC_16_GOT_PCREL:
    case BFD_RELOC_32_GOT_PCREL:
    case BFD_RELOC_8_GOTOFF:
    case BFD_RELOC_16_GOTOFF:
    case BFD_RELOC_32_GOTOFF:
    case BFD_RELOC_8_PLT_PCREL:
    case BFD_RELOC_16_PLT_PCREL:
    case BFD_RELOC_32_PLT_PCREL:
    case BFD_RELOC_8_PLTOFF:
    case BFD_RELOC_16_PLTOFF:
    case BFD_RELOC_32_PLTOFF:
      return 0;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return 0;

    default:
      return 1;
    }
}

#else /* !OBJ_ELF */

#define get_reloc_code(SIZE,PCREL,OTHER) NO_RELOC

#define relaxable_symbol(symbol) 1

#endif /* OBJ_ELF */

#ifdef BFD_ASSEMBLER

arelent *
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *reloc;
  bfd_reloc_code_real_type code;

  /* If the tcbit is set, then this was a fixup of a negative value
     that was never resolved.  We do not have a reloc to handle this,
     so just return.  We assume that other code will have detected this
     situation and produced a helpful error message, so we just tell the
     user that the reloc cannot be produced.  */
  if (fixp->fx_tcbit)
    {
      if (fixp->fx_addsy)
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("Unable to produce reloc against symbol '%s'"),
		      S_GET_NAME (fixp->fx_addsy));
      return NULL;
    }

  if (fixp->fx_r_type != BFD_RELOC_NONE)
    {
      code = fixp->fx_r_type;

      /* Since DIFF_EXPR_OK is defined in tc-m68k.h, it is possible
         that fixup_segment converted a non-PC relative reloc into a
         PC relative reloc.  In such a case, we need to convert the
         reloc code.  */
      if (fixp->fx_pcrel)
	{
	  switch (code)
	    {
	    case BFD_RELOC_8:
	      code = BFD_RELOC_8_PCREL;
	      break;
	    case BFD_RELOC_16:
	      code = BFD_RELOC_16_PCREL;
	      break;
	    case BFD_RELOC_32:
	      code = BFD_RELOC_32_PCREL;
	      break;
	    case BFD_RELOC_8_PCREL:
	    case BFD_RELOC_16_PCREL:
	    case BFD_RELOC_32_PCREL:
	    case BFD_RELOC_8_GOT_PCREL:
	    case BFD_RELOC_16_GOT_PCREL:
	    case BFD_RELOC_32_GOT_PCREL:
	    case BFD_RELOC_8_GOTOFF:
	    case BFD_RELOC_16_GOTOFF:
	    case BFD_RELOC_32_GOTOFF:
	    case BFD_RELOC_8_PLT_PCREL:
	    case BFD_RELOC_16_PLT_PCREL:
	    case BFD_RELOC_32_PLT_PCREL:
	    case BFD_RELOC_8_PLTOFF:
	    case BFD_RELOC_16_PLTOFF:
	    case BFD_RELOC_32_PLTOFF:
	      break;
	    default:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("Cannot make %s relocation PC relative"),
			    bfd_get_reloc_code_name (code));
	    }
	}
    }
  else
    {
#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
      switch (F (fixp->fx_size, fixp->fx_pcrel))
	{
#define MAP(SZ,PCREL,TYPE)	case F(SZ,PCREL): code = (TYPE); break
	  MAP (1, 0, BFD_RELOC_8);
	  MAP (2, 0, BFD_RELOC_16);
	  MAP (4, 0, BFD_RELOC_32);
	  MAP (1, 1, BFD_RELOC_8_PCREL);
	  MAP (2, 1, BFD_RELOC_16_PCREL);
	  MAP (4, 1, BFD_RELOC_32_PCREL);
	default:
	  abort ();
	}
    }
#undef F
#undef MAP

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
#ifndef OBJ_ELF
  if (fixp->fx_pcrel)
    reloc->addend = fixp->fx_addnumber;
  else
    reloc->addend = 0;
#else
  if (!fixp->fx_pcrel)
    reloc->addend = fixp->fx_addnumber;
  else
    reloc->addend = (section->vma
		     /* Explicit sign extension in case char is
			unsigned.  */
		     + ((fixp->fx_pcrel_adjust & 0xff) ^ 0x80) - 0x80
		     + fixp->fx_addnumber
		     + md_pcrel_from (fixp));
#endif

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  assert (reloc->howto != 0);

  return reloc;
}

#endif /* BFD_ASSEMBLER */

/* Handle of the OPCODE hash table.  NULL means any use before
   m68k_ip_begin() will crash.  */
static struct hash_control *op_hash;

/* Assemble an m68k instruction.  */

static void
m68k_ip (instring)
     char *instring;
{
  register char *p;
  register struct m68k_op *opP;
  register const struct m68k_incant *opcode;
  register const char *s;
  register int tmpreg = 0, baseo = 0, outro = 0, nextword;
  char *pdot, *pdotmove;
  enum m68k_size siz1, siz2;
  char c;
  int losing;
  int opsfound;
  LITTLENUM_TYPE words[6];
  LITTLENUM_TYPE *wordp;
  unsigned long ok_arch = 0;

  if (*instring == ' ')
    instring++;			/* Skip leading whitespace.  */

  /* Scan up to end of operation-code, which MUST end in end-of-string
     or exactly 1 space.  */
  pdot = 0;
  for (p = instring; *p != '\0'; p++)
    {
      if (*p == ' ')
	break;
      if (*p == '.')
	pdot = p;
    }

  if (p == instring)
    {
      the_ins.error = _("No operator");
      return;
    }

  /* p now points to the end of the opcode name, probably whitespace.
     Make sure the name is null terminated by clobbering the
     whitespace, look it up in the hash table, then fix it back.
     Remove a dot, first, since the opcode tables have none.  */
  if (pdot != NULL)
    {
      for (pdotmove = pdot; pdotmove < p; pdotmove++)
	*pdotmove = pdotmove[1];
      p--;
    }

  c = *p;
  *p = '\0';
  opcode = (const struct m68k_incant *) hash_find (op_hash, instring);
  *p = c;

  if (pdot != NULL)
    {
      for (pdotmove = p; pdotmove > pdot; pdotmove--)
	*pdotmove = pdotmove[-1];
      *pdot = '.';
      ++p;
    }

  if (opcode == NULL)
    {
      the_ins.error = _("Unknown operator");
      return;
    }

  /* Found a legitimate opcode, start matching operands.  */
  while (*p == ' ')
    ++p;

  if (opcode->m_operands == 0)
    {
      char *old = input_line_pointer;
      *old = '\n';
      input_line_pointer = p;
      /* Ahh - it's a motorola style psuedo op.  */
      mote_pseudo_table[opcode->m_opnum].poc_handler
	(mote_pseudo_table[opcode->m_opnum].poc_val);
      input_line_pointer = old;
      *old = 0;

      return;
    }

  if (flag_mri && opcode->m_opnum == 0)
    {
      /* In MRI mode, random garbage is allowed after an instruction
         which accepts no operands.  */
      the_ins.args = opcode->m_operands;
      the_ins.numargs = opcode->m_opnum;
      the_ins.numo = opcode->m_codenum;
      the_ins.opcode[0] = getone (opcode);
      the_ins.opcode[1] = gettwo (opcode);
      return;
    }

  for (opP = &the_ins.operands[0]; *p; opP++)
    {
      p = crack_operand (p, opP);

      if (opP->error)
	{
	  the_ins.error = opP->error;
	  return;
	}
    }

  opsfound = opP - &the_ins.operands[0];

  /* This ugly hack is to support the floating pt opcodes in their
     standard form.  Essentially, we fake a first enty of type COP#1 */
  if (opcode->m_operands[0] == 'I')
    {
      int n;

      for (n = opsfound; n > 0; --n)
	the_ins.operands[n] = the_ins.operands[n - 1];

      memset ((char *) (&the_ins.operands[0]), '\0',
	      sizeof (the_ins.operands[0]));
      the_ins.operands[0].mode = CONTROL;
      the_ins.operands[0].reg = m68k_float_copnum;
      opsfound++;
    }

  /* We've got the operands.  Find an opcode that'll accept them.  */
  for (losing = 0;;)
    {
      /* If we didn't get the right number of ops, or we have no
	 common model with this pattern then reject this pattern.  */

      ok_arch |= opcode->m_arch;
      if (opsfound != opcode->m_opnum
	  || ((opcode->m_arch & current_architecture) == 0))
	++losing;
      else
	{
	  for (s = opcode->m_operands, opP = &the_ins.operands[0];
	       *s && !losing;
	       s += 2, opP++)
	    {
	      /* Warning: this switch is huge! */
	      /* I've tried to organize the cases into this order:
		 non-alpha first, then alpha by letter.  Lower-case
		 goes directly before uppercase counterpart.  */
	      /* Code with multiple case ...: gets sorted by the lowest
		 case ... it belongs to.  I hope this makes sense.  */
	      switch (*s)
		{
		case '!':
		  switch (opP->mode)
		    {
		    case IMMED:
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case AINC:
		    case ADEC:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case '<':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case IMMED:
		    case ADEC:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case '>':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case IMMED:
		    case AINC:
		    case REGLST:
		      losing++;
		      break;
		    case ABSL:
		      break;
		    default:
		      if (opP->reg == PC
			  || opP->reg == ZPC)
			losing++;
		      break;
		    }
		  break;

		case 'm':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		      break;
		    default:
		      losing++;
		    }
		  break;

		case 'n':
		  switch (opP->mode)
		    {
		    case DISP:
		      break;
		    default:
		      losing++;
		    }
		  break;

		case 'o':
		  switch (opP->mode)
		    {
		    case BASE:
		    case ABSL:
		    case IMMED:
		      break;
		    default:
		      losing++;
		    }
		  break;

		case 'p':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		      break;
		    case DISP:
		      if (opP->reg == PC || opP->reg == ZPC)
			losing++;
		      break;
		    default:
		      losing++;
		    }
		  break;

		case 'q':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		      break;
		    case DISP:
		      if (opP->reg == PC || opP->reg == ZPC)
			losing++;
		      break;
		    default:
		      losing++;
		      break;
		    }
		  break;

		case 'v':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		    case ABSL:
		      break;
		    case DISP:
		      if (opP->reg == PC || opP->reg == ZPC)
			losing++;
		      break;
		    default:
		      losing++;
		      break;
		    }
		  break;

		case '#':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (s[1] == 'b'
			   && ! isvar (&opP->disp)
			   && (opP->disp.exp.X_op != O_constant
			       || ! isbyte (opP->disp.exp.X_add_number)))
		    losing++;
		  else if (s[1] == 'B'
			   && ! isvar (&opP->disp)
			   && (opP->disp.exp.X_op != O_constant
			       || ! issbyte (opP->disp.exp.X_add_number)))
		    losing++;
		  else if (s[1] == 'w'
			   && ! isvar (&opP->disp)
			   && (opP->disp.exp.X_op != O_constant
			       || ! isword (opP->disp.exp.X_add_number)))
		    losing++;
		  else if (s[1] == 'W'
			   && ! isvar (&opP->disp)
			   && (opP->disp.exp.X_op != O_constant
			       || ! issword (opP->disp.exp.X_add_number)))
		    losing++;
		  break;

		case '^':
		case 'T':
		  if (opP->mode != IMMED)
		    losing++;
		  break;

		case '$':
		  if (opP->mode == AREG
		      || opP->mode == CONTROL
		      || opP->mode == FPREG
		      || opP->mode == IMMED
		      || opP->mode == REGLST
		      || (opP->mode != ABSL
			  && (opP->reg == PC
			      || opP->reg == ZPC)))
		    losing++;
		  break;

		case '%':
		  if (opP->mode == CONTROL
		      || opP->mode == FPREG
		      || opP->mode == REGLST
		      || opP->mode == IMMED
		      || (opP->mode != ABSL
			  && (opP->reg == PC
			      || opP->reg == ZPC)))
		    losing++;
		  break;

		case '&':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case IMMED:
		    case AINC:
		    case ADEC:
		    case REGLST:
		      losing++;
		      break;
		    case ABSL:
		      break;
		    default:
		      if (opP->reg == PC
			  || opP->reg == ZPC)
			losing++;
		      break;
		    }
		  break;

		case '*':
		  if (opP->mode == CONTROL
		      || opP->mode == FPREG
		      || opP->mode == REGLST)
		    losing++;
		  break;

		case '+':
		  if (opP->mode != AINC)
		    losing++;
		  break;

		case '-':
		  if (opP->mode != ADEC)
		    losing++;
		  break;

		case '/':
		  switch (opP->mode)
		    {
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case AINC:
		    case ADEC:
		    case IMMED:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case ';':
		  switch (opP->mode)
		    {
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case '?':
		  switch (opP->mode)
		    {
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case AINC:
		    case ADEC:
		    case IMMED:
		    case REGLST:
		      losing++;
		      break;
		    case ABSL:
		      break;
		    default:
		      if (opP->reg == PC || opP->reg == ZPC)
			losing++;
		      break;
		    }
		  break;

		case '@@':
		  switch (opP->mode)
		    {
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case IMMED:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case '~':	/* For now! (JF FOO is this right?) */
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case CONTROL:
		    case FPREG:
		    case IMMED:
		    case REGLST:
		      losing++;
		      break;
		    case ABSL:
		      break;
		    default:
		      if (opP->reg == PC
			  || opP->reg == ZPC)
			losing++;
		      break;
		    }
		  break;

		case '3':
		  if (opP->mode != CONTROL
		      || (opP->reg != TT0 && opP->reg != TT1))
		    losing++;
		  break;

		case 'A':
		  if (opP->mode != AREG)
		    losing++;
		  break;

		case 'a':
		  if (opP->mode != AINDR)
		    ++losing;
		  break;

		case 'B':	/* FOO */
		  if (opP->mode != ABSL
		      || (flag_long_jumps
			  && strncmp (instring, "jbsr", 4) == 0))
		    losing++;
		  break;

                case 'b':
                  switch (opP->mode)
                    {
                    case IMMED:
                    case ABSL:
                    case AREG:
                    case FPREG:
                    case CONTROL:
                    case POST:
                    case PRE:
                    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
                    }
                  break;

		case 'C':
		  if (opP->mode != CONTROL || opP->reg != CCR)
		    losing++;
		  break;

		case 'd':
		  if (opP->mode != DISP
		      || opP->reg < ADDR0
		      || opP->reg > ADDR7)
		    losing++;
		  break;

		case 'D':
		  if (opP->mode != DREG)
		    losing++;
		  break;

		case 'E':
		  if (opP->reg != ACC)
		    losing++;
		  break;

		case 'F':
		  if (opP->mode != FPREG)
		    losing++;
		  break;

		case 'G':
		  if (opP->reg != MACSR)
		    losing++;
		  break;

		case 'H':
		  if (opP->reg != MASK)
		    losing++;
		  break;

		case 'I':
		  if (opP->mode != CONTROL
		      || opP->reg < COP0
		      || opP->reg > COP7)
		    losing++;
		  break;

		case 'J':
		  if (opP->mode != CONTROL
		      || opP->reg < USP
		      || opP->reg > last_movec_reg)
		    losing++;
		  else
		    {
		      const enum m68k_register *rp;
		      for (rp = control_regs; *rp; rp++)
			if (*rp == opP->reg)
			  break;
		      if (*rp == 0)
			losing++;
		    }
		  break;

		case 'k':
		  if (opP->mode != IMMED)
		    losing++;
		  break;

		case 'l':
		case 'L':
		  if (opP->mode == DREG
		      || opP->mode == AREG
		      || opP->mode == FPREG)
		    {
		      if (s[1] == '8')
			losing++;
		      else
			{
			  switch (opP->mode)
			    {
			    case DREG:
			      opP->mask = 1 << (opP->reg - DATA0);
			      break;
			    case AREG:
			      opP->mask = 1 << (opP->reg - ADDR0 + 8);
			      break;
			    case FPREG:
			      opP->mask = 1 << (opP->reg - FP0 + 16);
			      break;
			    default:
			      abort ();
			    }
			  opP->mode = REGLST;
			}
		    }
		  else if (opP->mode == CONTROL)
		    {
		      if (s[1] != '8')
			losing++;
		      else
			{
			  switch (opP->reg)
			    {
			    case FPI:
			      opP->mask = 1 << 24;
			      break;
			    case FPS:
			      opP->mask = 1 << 25;
			      break;
			    case FPC:
			      opP->mask = 1 << 26;
			      break;
			    default:
			      losing++;
			      break;
			    }
			  opP->mode = REGLST;
			}
		    }
		  else if (opP->mode != REGLST)
		    losing++;
		  else if (s[1] == '8' && (opP->mask & 0x0ffffff) != 0)
		    losing++;
		  else if (s[1] == '3' && (opP->mask & 0x7000000) != 0)
		    losing++;
		  break;

		case 'M':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || ! issbyte (opP->disp.exp.X_add_number))
		    losing++;
		  else if (! m68k_quick
			   && instring[3] != 'q'
			   && instring[4] != 'q')
		    losing++;
		  break;

		case 'O':
		  if (opP->mode != DREG
		      && opP->mode != IMMED
		      && opP->mode != ABSL)
		    losing++;
		  break;

		case 'Q':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || opP->disp.exp.X_add_number < 1
			   || opP->disp.exp.X_add_number > 8)
		    losing++;
		  else if (! m68k_quick
			   && (strncmp (instring, "add", 3) == 0
			       || strncmp (instring, "sub", 3) == 0)
			   && instring[3] != 'q')
		    losing++;
		  break;

		case 'R':
		  if (opP->mode != DREG && opP->mode != AREG)
		    losing++;
		  break;

		case 'r':
		  if (opP->mode != AINDR
		      && (opP->mode != BASE
			  || (opP->reg != 0
			      && opP->reg != ZADDR0)
			  || opP->disp.exp.X_op != O_absent
			  || ((opP->index.reg < DATA0
			       || opP->index.reg > DATA7)
			      && (opP->index.reg < ADDR0
				  || opP->index.reg > ADDR7))
			  || opP->index.size != SIZE_UNSPEC
			  || opP->index.scale != 1))
		    losing++;
		  break;

		case 's':
		  if (opP->mode != CONTROL
		      || ! (opP->reg == FPI
			    || opP->reg == FPS
			    || opP->reg == FPC))
		    losing++;
		  break;

		case 'S':
		  if (opP->mode != CONTROL || opP->reg != SR)
		    losing++;
		  break;

		case 't':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || opP->disp.exp.X_add_number < 0
			   || opP->disp.exp.X_add_number > 7)
		    losing++;
		  break;

		case 'U':
		  if (opP->mode != CONTROL || opP->reg != USP)
		    losing++;
		  break;

		case 'x':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || opP->disp.exp.X_add_number < -1
                           || opP->disp.exp.X_add_number > 7
                           || opP->disp.exp.X_add_number == 0)
		    losing++;
		  break;

		  /* JF these are out of order.  We could put them
		     in order if we were willing to put up with
		     bunches of #ifdef m68851s in the code.

		     Don't forget that you need these operands
		     to use 68030 MMU instructions.  */
#ifndef NO_68851
		  /* Memory addressing mode used by pflushr.  */
		case '|':
		  if (opP->mode == CONTROL
		      || opP->mode == FPREG
		      || opP->mode == DREG
		      || opP->mode == AREG
		      || opP->mode == REGLST)
		    losing++;
		  /* We should accept immediate operands, but they
                     supposedly have to be quad word, and we don't
                     handle that.  I would like to see what a Motorola
                     assembler does before doing something here.  */
		  if (opP->mode == IMMED)
		    losing++;
		  break;

		case 'f':
		  if (opP->mode != CONTROL
		      || (opP->reg != SFC && opP->reg != DFC))
		    losing++;
		  break;

		case '0':
		  if (opP->mode != CONTROL || opP->reg != TC)
		    losing++;
		  break;

		case '1':
		  if (opP->mode != CONTROL || opP->reg != AC)
		    losing++;
		  break;

		case '2':
		  if (opP->mode != CONTROL
		      || (opP->reg != CAL
			  && opP->reg != VAL
			  && opP->reg != SCC))
		    losing++;
		  break;

		case 'V':
		  if (opP->mode != CONTROL
		      || opP->reg != VAL)
		    losing++;
		  break;

		case 'W':
		  if (opP->mode != CONTROL
		      || (opP->reg != DRP
			  && opP->reg != SRP
			  && opP->reg != CRP))
		    losing++;
		  break;

		case 'w':
		  switch (opP->mode)
		    {
		      case IMMED:
		      case ABSL:
		      case AREG:
		      case DREG:
		      case FPREG:
		      case CONTROL:
		      case POST:
		      case PRE:
		      case REGLST:
			losing++;
			break;
		      default:
			break;
		    }
		  break;

		case 'X':
		  if (opP->mode != CONTROL
		      || (!(opP->reg >= BAD && opP->reg <= BAD + 7)
			  && !(opP->reg >= BAC && opP->reg <= BAC + 7)))
		    losing++;
		  break;

		case 'Y':
		  if (opP->mode != CONTROL || opP->reg != PSR)
		    losing++;
		  break;

		case 'Z':
		  if (opP->mode != CONTROL || opP->reg != PCSR)
		    losing++;
		  break;
#endif
		case 'c':
		  if (opP->mode != CONTROL
		      || (opP->reg != NC
			  && opP->reg != IC
			  && opP->reg != DC
			  && opP->reg != BC))
		    losing++;
		  break;

		case '_':
		  if (opP->mode != ABSL)
		    ++losing;
		  break;

		case 'u':
		  if (opP->reg < DATA0L || opP->reg > ADDR7U)
		    losing++;
		  /* FIXME: kludge instead of fixing parser:
                     upper/lower registers are *not* CONTROL
                     registers, but ordinary ones.  */
		  if ((opP->reg >= DATA0L && opP->reg <= DATA7L)
		      || (opP->reg >= DATA0U && opP->reg <= DATA7U))
		    opP->mode = DREG;
		  else
		    opP->mode = AREG;
		  break;

		 case 'y':
		   if (!(opP->mode == AINDR
			 || (opP->mode == DISP && !(opP->reg == PC ||
						    opP->reg == ZPC))))
		     losing++;
		   break;

		 case 'z':
		   if (!(opP->mode == AINDR || opP->mode == DISP))
		     losing++;
		   break;

		default:
		  abort ();
		}

	      if (losing)
		break;
	    }
	}

      if (!losing)
	break;

      opcode = opcode->m_next;

      if (!opcode)
	{
	  if (ok_arch
	      && !(ok_arch & current_architecture))
	    {
	      char buf[200], *cp;

	      strcpy (buf,
		      _("invalid instruction for this architecture; needs "));
	      cp = buf + strlen (buf);
	      switch (ok_arch)
		{
		case cfloat:
		  strcpy (cp, _("ColdFire fpu (cfv4e)"));
		  break;
		case mfloat:
		  strcpy (cp, _("fpu (68040, 68060 or 68881/68882)"));
		  break;
		case mmmu:
		  strcpy (cp, _("mmu (68030 or 68851)"));
		  break;
		case m68020up:
		  strcpy (cp, _("68020 or higher"));
		  break;
		case m68000up:
		  strcpy (cp, _("68000 or higher"));
		  break;
		case m68010up:
		  strcpy (cp, _("68010 or higher"));
		  break;
		default:
		  {
		    int got_one = 0, idx;
		    for (idx = 0;
			 idx < (int) (sizeof (archs) / sizeof (archs[0]));
			 idx++)
		      {
			if ((archs[idx].arch & ok_arch)
			    && ! archs[idx].alias)
			  {
			    if (got_one)
			      {
				strcpy (cp, " or ");
				cp += strlen (cp);
			      }
			    got_one = 1;
			    strcpy (cp, archs[idx].name);
			    cp += strlen (cp);
			  }
		      }
		  }
		}
	      cp = xmalloc (strlen (buf) + 1);
	      strcpy (cp, buf);
	      the_ins.error = cp;
	    }
	  else
	    the_ins.error = _("operands mismatch");
	  return;
	}

      losing = 0;
    }

  /* Now assemble it.  */
  the_ins.args = opcode->m_operands;
  the_ins.numargs = opcode->m_opnum;
  the_ins.numo = opcode->m_codenum;
  the_ins.opcode[0] = getone (opcode);
  the_ins.opcode[1] = gettwo (opcode);

  for (s = the_ins.args, opP = &the_ins.operands[0]; *s; s += 2, opP++)
    {
      /* This switch is a doozy.
       Watch the first step; its a big one! */
      switch (s[0])
	{

	case '*':
	case '~':
	case '%':
	case ';':
	case '@@':
	case '!':
	case '&':
	case '$':
	case '?':
	case '/':
	case '<':
	case '>':
	case 'b':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'v':
	case 'w':
	case 'y':
	case 'z':
#ifndef NO_68851
	case '|':
#endif
	  switch (opP->mode)
	    {
	    case IMMED:
	      tmpreg = 0x3c;	/* 7.4 */
	      if (strchr ("bwl", s[1]))
		nextword = get_num (&opP->disp, 90);
	      else
		nextword = get_num (&opP->disp, 0);
	      if (isvar (&opP->disp))
		add_fix (s[1], &opP->disp, 0, 0);
	      switch (s[1])
		{
		case 'b':
		  if (!isbyte (nextword))
		    opP->error = _("operand out of range");
		  addword (nextword);
		  baseo = 0;
		  break;
		case 'w':
		  if (!isword (nextword))
		    opP->error = _("operand out of range");
		  addword (nextword);
		  baseo = 0;
		  break;
		case 'W':
		  if (!issword (nextword))
		    opP->error = _("operand out of range");
		  addword (nextword);
		  baseo = 0;
		  break;
		case 'l':
		  addword (nextword >> 16);
		  addword (nextword);
		  baseo = 0;
		  break;

		case 'f':
		  baseo = 2;
		  outro = 8;
		  break;
		case 'F':
		  baseo = 4;
		  outro = 11;
		  break;
		case 'x':
		  baseo = 6;
		  outro = 15;
		  break;
		case 'p':
		  baseo = 6;
		  outro = -1;
		  break;
		default:
		  abort ();
		}
	      if (!baseo)
		break;

	      /* We gotta put out some float.  */
	      if (op (&opP->disp) != O_big)
		{
		  valueT val;
		  int gencnt;

		  /* Can other cases happen here?  */
		  if (op (&opP->disp) != O_constant)
		    abort ();

		  val = (valueT) offs (&opP->disp);
		  gencnt = 0;
		  do
		    {
		      generic_bignum[gencnt] = (LITTLENUM_TYPE) val;
		      val >>= LITTLENUM_NUMBER_OF_BITS;
		      ++gencnt;
		    }
		  while (val != 0);
		  offs (&opP->disp) = gencnt;
		}
	      if (offs (&opP->disp) > 0)
		{
		  if (offs (&opP->disp) > baseo)
		    {
		      as_warn (_("Bignum too big for %c format; truncated"),
			       s[1]);
		      offs (&opP->disp) = baseo;
		    }
		  baseo -= offs (&opP->disp);
		  while (baseo--)
		    addword (0);
		  for (wordp = generic_bignum + offs (&opP->disp) - 1;
		       offs (&opP->disp)--;
		       --wordp)
		    addword (*wordp);
		  break;
		}
	      gen_to_words (words, baseo, (long) outro);
	      for (wordp = words; baseo--; wordp++)
		addword (*wordp);
	      break;
	    case DREG:
	      tmpreg = opP->reg - DATA;	/* 0.dreg */
	      break;
	    case AREG:
	      tmpreg = 0x08 + opP->reg - ADDR;	/* 1.areg */
	      break;
	    case AINDR:
	      tmpreg = 0x10 + opP->reg - ADDR;	/* 2.areg */
	      break;
	    case ADEC:
	      tmpreg = 0x20 + opP->reg - ADDR;	/* 4.areg */
	      break;
	    case AINC:
	      tmpreg = 0x18 + opP->reg - ADDR;	/* 3.areg */
	      break;
	    case DISP:

	      nextword = get_num (&opP->disp, 90);

	      if (opP->reg == PC
		  && ! isvar (&opP->disp)
		  && m68k_abspcadd)
		{
		  opP->disp.exp.X_op = O_symbol;
#ifndef BFD_ASSEMBLER
		  opP->disp.exp.X_add_symbol = &abs_symbol;
#else
		  opP->disp.exp.X_add_symbol =
		    section_symbol (absolute_section);
#endif
		}

	      /* Force into index mode.  Hope this works.  */

	      /* We do the first bit for 32-bit displacements, and the
		 second bit for 16 bit ones.  It is possible that we
		 should make the default be WORD instead of LONG, but
		 I think that'd break GCC, so we put up with a little
		 inefficiency for the sake of working output.  */

	      if (!issword (nextword)
		  || (isvar (&opP->disp)
		      && ((opP->disp.size == SIZE_UNSPEC
			   && flag_short_refs == 0
			   && cpu_of_arch (current_architecture) >= m68020
			   && ! arch_coldfire_p (current_architecture))
			  || opP->disp.size == SIZE_LONG)))
		{
		  if (cpu_of_arch (current_architecture) < m68020
		      || arch_coldfire_p (current_architecture))
		    opP->error =
		      _("displacement too large for this architecture; needs 68020 or higher");
		  if (opP->reg == PC)
		    tmpreg = 0x3B;	/* 7.3 */
		  else
		    tmpreg = 0x30 + opP->reg - ADDR;	/* 6.areg */
		  if (isvar (&opP->disp))
		    {
		      if (opP->reg == PC)
			{
			  if (opP->disp.size == SIZE_LONG
#ifdef OBJ_ELF
			      /* If the displacement needs pic
				 relocation it cannot be relaxed.  */
			      || opP->disp.pic_reloc != pic_none
#endif
			      )
			    {
			      addword (0x0170);
			      add_fix ('l', &opP->disp, 1, 2);
			    }
			  else
			    {
			      add_frag (adds (&opP->disp),
					offs (&opP->disp),
					TAB (PCREL1632, SZ_UNDEF));
			      break;
			    }
			}
		      else
			{
			  addword (0x0170);
			  add_fix ('l', &opP->disp, 0, 0);
			}
		    }
		  else
		    addword (0x0170);
		  addword (nextword >> 16);
		}
	      else
		{
		  if (opP->reg == PC)
		    tmpreg = 0x3A;	/* 7.2 */
		  else
		    tmpreg = 0x28 + opP->reg - ADDR;	/* 5.areg */

		  if (isvar (&opP->disp))
		    {
		      if (opP->reg == PC)
			{
			  add_fix ('w', &opP->disp, 1, 0);
			}
		      else
			add_fix ('w', &opP->disp, 0, 0);
		    }
		}
	      addword (nextword);
	      break;

	    case POST:
	    case PRE:
	    case BASE:
	      nextword = 0;
	      baseo = get_num (&opP->disp, 90);
	      if (opP->mode == POST || opP->mode == PRE)
		outro = get_num (&opP->odisp, 90);
	      /* Figure out the `addressing mode'.
		 Also turn on the BASE_DISABLE bit, if needed.  */
	      if (opP->reg == PC || opP->reg == ZPC)
		{
		  tmpreg = 0x3b;	/* 7.3 */
		  if (opP->reg == ZPC)
		    nextword |= 0x80;
		}
	      else if (opP->reg == 0)
		{
		  nextword |= 0x80;
		  tmpreg = 0x30;	/* 6.garbage */
		}
	      else if (opP->reg >= ZADDR0 && opP->reg <= ZADDR7)
		{
		  nextword |= 0x80;
		  tmpreg = 0x30 + opP->reg - ZADDR0;
		}
	      else
		tmpreg = 0x30 + opP->reg - ADDR;	/* 6.areg */

	      siz1 = opP->disp.size;
	      if (opP->mode == POST || opP->mode == PRE)
		siz2 = opP->odisp.size;
	      else
		siz2 = SIZE_UNSPEC;

	      /* Index register stuff.  */
	      if (opP->index.reg != 0
		  && opP->index.reg >= DATA
		  && opP->index.reg <= ADDR7)
		{
		  nextword |= (opP->index.reg - DATA) << 12;

		  if (opP->index.size == SIZE_LONG
		      || (opP->index.size == SIZE_UNSPEC
			  && m68k_index_width_default == SIZE_LONG))
		    nextword |= 0x800;

		  if ((opP->index.scale != 1
		       && cpu_of_arch (current_architecture) < m68020)
		      || (opP->index.scale == 8
			  && (arch_coldfire_p (current_architecture)
                              && !arch_coldfire_v4e_p(current_architecture))))
		    {
		      opP->error =
			_("scale factor invalid on this architecture; needs cpu32 or 68020 or higher");
		    }

		  if (arch_coldfire_p (current_architecture)
		      && opP->index.size == SIZE_WORD)
		    opP->error = _("invalid index size for coldfire");

		  switch (opP->index.scale)
		    {
		    case 1:
		      break;
		    case 2:
		      nextword |= 0x200;
		      break;
		    case 4:
		      nextword |= 0x400;
		      break;
		    case 8:
		      nextword |= 0x600;
		      break;
		    default:
		      abort ();
		    }
		  /* IF its simple,
		     GET US OUT OF HERE! */

		  /* Must be INDEX, with an index register.  Address
		     register cannot be ZERO-PC, and either :b was
		     forced, or we know it will fit.  For a 68000 or
		     68010, force this mode anyways, because the
		     larger modes aren't supported.  */
		  if (opP->mode == BASE
		      && ((opP->reg >= ADDR0
			   && opP->reg <= ADDR7)
			  || opP->reg == PC))
		    {
		      if (siz1 == SIZE_BYTE
			  || cpu_of_arch (current_architecture) < m68020
			  || arch_coldfire_p (current_architecture)
			  || (siz1 == SIZE_UNSPEC
			      && ! isvar (&opP->disp)
			      && issbyte (baseo)))
			{
 			  nextword += baseo & 0xff;
 			  addword (nextword);
 			  if (isvar (&opP->disp))
			    {
			      /* Do a byte relocation.  If it doesn't
				 fit (possible on m68000) let the
				 fixup processing complain later.  */
			      if (opP->reg == PC)
				add_fix ('B', &opP->disp, 1, 1);
			      else
				add_fix ('B', &opP->disp, 0, 0);
			    }
			  else if (siz1 != SIZE_BYTE)
			    {
			      if (siz1 != SIZE_UNSPEC)
				as_warn (_("Forcing byte displacement"));
			      if (! issbyte (baseo))
				opP->error = _("byte displacement out of range");
			    }

			  break;
			}
		      else if (siz1 == SIZE_UNSPEC
			       && opP->reg == PC
			       && isvar (&opP->disp)
			       && subs (&opP->disp) == NULL
#ifdef OBJ_ELF
			       /* If the displacement needs pic
				  relocation it cannot be relaxed.  */
			       && opP->disp.pic_reloc == pic_none
#endif
			       )
			{
			  /* The code in md_convert_frag_1 needs to be
                             able to adjust nextword.  Call frag_grow
                             to ensure that we have enough space in
                             the frag obstack to make all the bytes
                             contiguous.  */
			  frag_grow (14);
			  nextword += baseo & 0xff;
			  addword (nextword);
			  add_frag (adds (&opP->disp), offs (&opP->disp),
				    TAB (PCINDEX, SZ_UNDEF));

			  break;
			}
		    }
		}
	      else
		{
		  nextword |= 0x40;	/* No index reg.  */
		  if (opP->index.reg >= ZDATA0
		      && opP->index.reg <= ZDATA7)
		    nextword |= (opP->index.reg - ZDATA0) << 12;
		  else if (opP->index.reg >= ZADDR0
			   || opP->index.reg <= ZADDR7)
		    nextword |= (opP->index.reg - ZADDR0 + 8) << 12;
		}

	      /* It isn't simple.  */

	      if (cpu_of_arch (current_architecture) < m68020
		  || arch_coldfire_p (current_architecture))
		opP->error =
		  _("invalid operand mode for this architecture; needs 68020 or higher");

	      nextword |= 0x100;
	      /* If the guy specified a width, we assume that it is
		 wide enough.  Maybe it isn't.  If so, we lose.  */
	      switch (siz1)
		{
		case SIZE_UNSPEC:
		  if (isvar (&opP->disp)
		      ? m68k_rel32
		      : ! issword (baseo))
		    {
		      siz1 = SIZE_LONG;
		      nextword |= 0x30;
		    }
		  else if (! isvar (&opP->disp) && baseo == 0)
		    nextword |= 0x10;
		  else
		    {
		      nextword |= 0x20;
		      siz1 = SIZE_WORD;
		    }
		  break;
		case SIZE_BYTE:
		  as_warn (_(":b not permitted; defaulting to :w"));
		  /* Fall through.  */
		case SIZE_WORD:
		  nextword |= 0x20;
		  break;
		case SIZE_LONG:
		  nextword |= 0x30;
		  break;
		}

	      /* Figure out inner displacement stuff.  */
	      if (opP->mode == POST || opP->mode == PRE)
		{
		  if (cpu_of_arch (current_architecture) & cpu32)
		    opP->error = _("invalid operand mode for this architecture; needs 68020 or higher");
		  switch (siz2)
		    {
		    case SIZE_UNSPEC:
		      if (isvar (&opP->odisp)
			  ? m68k_rel32
			  : ! issword (outro))
			{
			  siz2 = SIZE_LONG;
			  nextword |= 0x3;
			}
		      else if (! isvar (&opP->odisp) && outro == 0)
			nextword |= 0x1;
		      else
			{
			  nextword |= 0x2;
			  siz2 = SIZE_WORD;
			}
		      break;
		    case 1:
		      as_warn (_(":b not permitted; defaulting to :w"));
		      /* Fall through.  */
		    case 2:
		      nextword |= 0x2;
		      break;
		    case 3:
		      nextword |= 0x3;
		      break;
		    }
		  if (opP->mode == POST
		      && (nextword & 0x40) == 0)
		    nextword |= 0x04;
		}
	      addword (nextword);

	      if (siz1 != SIZE_UNSPEC && isvar (&opP->disp))
		{
		  if (opP->reg == PC || opP->reg == ZPC)
		    add_fix (siz1 == SIZE_LONG ? 'l' : 'w', &opP->disp, 1, 2);
		  else
		    add_fix (siz1 == SIZE_LONG ? 'l' : 'w', &opP->disp, 0, 0);
		}
	      if (siz1 == SIZE_LONG)
		addword (baseo >> 16);
	      if (siz1 != SIZE_UNSPEC)
		addword (baseo);

	      if (siz2 != SIZE_UNSPEC && isvar (&opP->odisp))
		add_fix (siz2 == SIZE_LONG ? 'l' : 'w', &opP->odisp, 0, 0);
	      if (siz2 == SIZE_LONG)
		addword (outro >> 16);
	      if (siz2 != SIZE_UNSPEC)
		addword (outro);

	      break;

	    case ABSL:
	      nextword = get_num (&opP->disp, 90);
	      switch (opP->disp.size)
		{
		default:
		  abort ();
		case SIZE_UNSPEC:
		  if (!isvar (&opP->disp) && issword (offs (&opP->disp)))
		    {
		      tmpreg = 0x38;	/* 7.0 */
		      addword (nextword);
		      break;
		    }
		  if (isvar (&opP->disp)
		      && !subs (&opP->disp)
		      && adds (&opP->disp)
#ifdef OBJ_ELF
		      /* If the displacement needs pic relocation it
			 cannot be relaxed.  */
		      && opP->disp.pic_reloc == pic_none
#endif
		      && !flag_long_jumps
		      && !strchr ("~%&$?", s[0]))
		    {
		      tmpreg = 0x3A;	/* 7.2 */
		      add_frag (adds (&opP->disp),
				offs (&opP->disp),
				TAB (ABSTOPCREL, SZ_UNDEF));
		      break;
		    }
		  /* Fall through into long.  */
		case SIZE_LONG:
		  if (isvar (&opP->disp))
		    add_fix ('l', &opP->disp, 0, 0);

		  tmpreg = 0x39;/* 7.1 mode */
		  addword (nextword >> 16);
		  addword (nextword);
		  break;

		case SIZE_BYTE:
		  as_bad (_("unsupported byte value; use a different suffix"));
		  /* Fall through.  */

		case SIZE_WORD:
		  if (isvar (&opP->disp))
		    add_fix ('w', &opP->disp, 0, 0);

		  tmpreg = 0x38;/* 7.0 mode */
		  addword (nextword);
		  break;
		}
	      break;
	    case CONTROL:
	    case FPREG:
	    default:
	      as_bad (_("unknown/incorrect operand"));
	      /* abort (); */
	    }
	  install_gen_operand (s[1], tmpreg);
	  break;

	case '#':
	case '^':
	  switch (s[1])
	    {			/* JF: I hate floating point! */
	    case 'j':
	      tmpreg = 70;
	      break;
	    case '8':
	      tmpreg = 20;
	      break;
	    case 'C':
	      tmpreg = 50;
	      break;
	    case '3':
	    default:
	      tmpreg = 90;
	      break;
	    }
	  tmpreg = get_num (&opP->disp, tmpreg);
	  if (isvar (&opP->disp))
	    add_fix (s[1], &opP->disp, 0, 0);
	  switch (s[1])
	    {
	    case 'b':		/* Danger:  These do no check for
				   certain types of overflow.
				   user beware! */
	      if (!isbyte (tmpreg))
		opP->error = _("out of range");
	      insop (tmpreg, opcode);
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n =
		  (opcode->m_codenum) * 2 + 1;
	      break;
	    case 'B':
	      if (!issbyte (tmpreg))
		opP->error = _("out of range");
	      the_ins.opcode[the_ins.numo - 1] |= tmpreg & 0xff;
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n = opcode->m_codenum * 2 - 1;
	      break;
	    case 'w':
	      if (!isword (tmpreg))
		opP->error = _("out of range");
	      insop (tmpreg, opcode);
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n = (opcode->m_codenum) * 2;
	      break;
	    case 'W':
	      if (!issword (tmpreg))
		opP->error = _("out of range");
	      insop (tmpreg, opcode);
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n = (opcode->m_codenum) * 2;
	      break;
	    case 'l':
	      /* Because of the way insop works, we put these two out
		 backwards.  */
	      insop (tmpreg, opcode);
	      insop (tmpreg >> 16, opcode);
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n = (opcode->m_codenum) * 2;
	      break;
	    case '3':
	      tmpreg &= 0xFF;
	    case '8':
	    case 'C':
	    case 'j':
	      install_operand (s[1], tmpreg);
	      break;
	    default:
	      abort ();
	    }
	  break;

	case '+':
	case '-':
	case 'A':
	case 'a':
	  install_operand (s[1], opP->reg - ADDR);
	  break;

	case 'B':
	  tmpreg = get_num (&opP->disp, 90);
	  switch (s[1])
	    {
	    case 'B':
	      add_fix ('B', &opP->disp, 1, -1);
	      break;
	    case 'W':
	      add_fix ('w', &opP->disp, 1, 0);
	      addword (0);
	      break;
	    case 'L':
	    long_branch:
	      if (! HAVE_LONG_BRANCH (current_architecture))
		as_warn (_("Can't use long branches on 68000/68010/5200"));
	      the_ins.opcode[0] |= 0xff;
	      add_fix ('l', &opP->disp, 1, 0);
	      addword (0);
	      addword (0);
	      break;
	    case 'g':
	      if (subs (&opP->disp))	/* We can't relax it.  */
		goto long_branch;

#ifdef OBJ_ELF
	      /* If the displacement needs pic relocation it cannot be
		 relaxed.  */
	      if (opP->disp.pic_reloc != pic_none)
		goto long_branch;
#endif
	      /* This could either be a symbol, or an absolute
		 address.  If it's an absolute address, turn it into
		 an absolute jump right here and keep it out of the
		 relaxer.  */
	      if (adds (&opP->disp) == 0)
		{
		  if (the_ins.opcode[0] == 0x6000)	/* jbra */
		    the_ins.opcode[0] = 0x4EF9;
		  else if (the_ins.opcode[0] == 0x6100)	/* jbsr */
		    the_ins.opcode[0] = 0x4EB9;
		  else					/* jCC */
		    {
		      the_ins.opcode[0] ^= 0x0100;
		      the_ins.opcode[0] |= 0x0006;
		      addword (0x4EF9);
		    }
		  add_fix ('l', &opP->disp, 0, 0);
		  addword (0);
		  addword (0);
		  break;
		}

	      /* Now we know it's going into the relaxer.  Now figure
		 out which mode.  We try in this order of preference:
		 long branch, absolute jump, byte/word branches only.  */
	      if (HAVE_LONG_BRANCH (current_architecture))
		add_frag (adds (&opP->disp), offs (&opP->disp),
			  TAB (BRANCHBWL, SZ_UNDEF));
	      else if (! flag_keep_pcrel)
		{
		  if ((the_ins.opcode[0] == 0x6000)
		      || (the_ins.opcode[0] == 0x6100))
		    add_frag (adds (&opP->disp), offs (&opP->disp),
			      TAB (BRABSJUNC, SZ_UNDEF));
		  else
		    add_frag (adds (&opP->disp), offs (&opP->disp),
			      TAB (BRABSJCOND, SZ_UNDEF));
		}
	      else
		add_frag (adds (&opP->disp), offs (&opP->disp),
			  TAB (BRANCHBW, SZ_UNDEF));
	      break;
	    case 'w':
	      if (isvar (&opP->disp))
		{
		  /* Check for DBcc instructions.  We can relax them,
		     but only if we have long branches and/or absolute
		     jumps.  */
		  if (((the_ins.opcode[0] & 0xf0f8) == 0x50c8)
		      && (HAVE_LONG_BRANCH (current_architecture)
			  || (! flag_keep_pcrel)))
		    {
		      if (HAVE_LONG_BRANCH (current_architecture))
			add_frag (adds (&opP->disp), offs (&opP->disp),
				  TAB (DBCCLBR, SZ_UNDEF));
		      else
			add_frag (adds (&opP->disp), offs (&opP->disp),
				  TAB (DBCCABSJ, SZ_UNDEF));
		      break;
		    }
		  add_fix ('w', &opP->disp, 1, 0);
		}
	      addword (0);
	      break;
	    case 'C':		/* Fixed size LONG coproc branches.  */
	      add_fix ('l', &opP->disp, 1, 0);
	      addword (0);
	      addword (0);
	      break;
	    case 'c':		/* Var size Coprocesssor branches.  */
	      if (subs (&opP->disp) || (adds (&opP->disp) == 0))
		{
		  the_ins.opcode[the_ins.numo - 1] |= 0x40;
		  add_fix ('l', &opP->disp, 1, 0);
		  addword (0);
		  addword (0);
		}
	      else
		add_frag (adds (&opP->disp), offs (&opP->disp),
			  TAB (FBRANCH, SZ_UNDEF));
	      break;
	    default:
	      abort ();
	    }
	  break;

	case 'C':		/* Ignore it.  */
	  break;

	case 'd':		/* JF this is a kludge.  */
	  install_operand ('s', opP->reg - ADDR);
	  tmpreg = get_num (&opP->disp, 90);
	  if (!issword (tmpreg))
	    {
	      as_warn (_("Expression out of range, using 0"));
	      tmpreg = 0;
	    }
	  addword (tmpreg);
	  break;

	case 'D':
	  install_operand (s[1], opP->reg - DATA);
	  break;

	case 'E':		/* Ignore it.  */
	  break;

	case 'F':
	  install_operand (s[1], opP->reg - FP0);
	  break;

	case 'G':		/* Ignore it.  */
	case 'H':
	  break;

	case 'I':
	  tmpreg = opP->reg - COP0;
	  install_operand (s[1], tmpreg);
	  break;

	case 'J':		/* JF foo.  */
	  switch (opP->reg)
	    {
	    case SFC:
	      tmpreg = 0x000;
	      break;
	    case DFC:
	      tmpreg = 0x001;
	      break;
	    case CACR:
	      tmpreg = 0x002;
	      break;
	    case TC:
	      tmpreg = 0x003;
	      break;
	    case ACR0:
	    case ITT0:
	      tmpreg = 0x004;
	      break;
	    case ACR1:
	    case ITT1:
	      tmpreg = 0x005;
	      break;
	    case ACR2:
	    case DTT0:
	      tmpreg = 0x006;
	      break;
	    case ACR3:
	    case DTT1:
	      tmpreg = 0x007;
	      break;
	    case BUSCR:
	      tmpreg = 0x008;
	      break;

	    case USP:
	      tmpreg = 0x800;
	      break;
	    case VBR:
	      tmpreg = 0x801;
	      break;
	    case CAAR:
	      tmpreg = 0x802;
	      break;
	    case MSP:
	      tmpreg = 0x803;
	      break;
	    case ISP:
	      tmpreg = 0x804;
	      break;
	    case MMUSR:
	      tmpreg = 0x805;
	      break;
	    case URP:
	      tmpreg = 0x806;
	      break;
	    case SRP:
	      tmpreg = 0x807;
	      break;
	    case PCR:
	      tmpreg = 0x808;
	      break;
            case ROMBAR:
	      tmpreg = 0xC00;
	      break;
            case ROMBAR1:
              tmpreg = 0xC01;
              break;
	    case FLASHBAR:
	    case RAMBAR0:
	      tmpreg = 0xC04;
	      break;
	    case RAMBAR:
	    case RAMBAR1:
	      tmpreg = 0xC05;
	      break;
            case MPCR:
              tmpreg = 0xC0C;
              break;
            case EDRAMBAR:
              tmpreg = 0xC0D;
              break;
            case MBAR0:
            case SECMBAR:
              tmpreg = 0xC0E;
              break;
            case MBAR1:
	    case MBAR:
	      tmpreg = 0xC0F;
	      break;
            case PCR1U0:
              tmpreg = 0xD02;
              break;
            case PCR1L0:
              tmpreg = 0xD03;
              break;
            case PCR2U0:
              tmpreg = 0xD04;
              break;
            case PCR2L0:
              tmpreg = 0xD05;
              break;
            case PCR3U0:
              tmpreg = 0xD06;
              break;
            case PCR3L0:
              tmpreg = 0xD07;
              break;
            case PCR1L1:
              tmpreg = 0xD0A;
              break;
            case PCR1U1:
              tmpreg = 0xD0B;
              break;
            case PCR2L1:
              tmpreg = 0xD0C;
              break;
            case PCR2U1:
              tmpreg = 0xD0D;
              break;
            case PCR3L1:
              tmpreg = 0xD0E;
              break;
            case PCR3U1:
              tmpreg = 0xD0F;
              break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;

	case 'k':
	  tmpreg = get_num (&opP->disp, 55);
	  install_operand (s[1], tmpreg & 0x7f);
	  break;

	case 'l':
	  tmpreg = opP->mask;
	  if (s[1] == 'w')
	    {
	      if (tmpreg & 0x7FF0000)
		as_bad (_("Floating point register in register list"));
	      insop (reverse_16_bits (tmpreg), opcode);
	    }
	  else
	    {
	      if (tmpreg & 0x700FFFF)
		as_bad (_("Wrong register in floating-point reglist"));
	      install_operand (s[1], reverse_8_bits (tmpreg >> 16));
	    }
	  break;

	case 'L':
	  tmpreg = opP->mask;
	  if (s[1] == 'w')
	    {
	      if (tmpreg & 0x7FF0000)
		as_bad (_("Floating point register in register list"));
	      insop (tmpreg, opcode);
	    }
	  else if (s[1] == '8')
	    {
	      if (tmpreg & 0x0FFFFFF)
		as_bad (_("incorrect register in reglist"));
	      install_operand (s[1], tmpreg >> 24);
	    }
	  else
	    {
	      if (tmpreg & 0x700FFFF)
		as_bad (_("wrong register in floating-point reglist"));
	      else
		install_operand (s[1], tmpreg >> 16);
	    }
	  break;

	case 'M':
	  install_operand (s[1], get_num (&opP->disp, 60));
	  break;

	case 'O':
	  tmpreg = ((opP->mode == DREG)
		    ? 0x20 + (int) (opP->reg - DATA)
		    : (get_num (&opP->disp, 40) & 0x1F));
	  install_operand (s[1], tmpreg);
	  break;

	case 'Q':
	  tmpreg = get_num (&opP->disp, 10);
	  if (tmpreg == 8)
	    tmpreg = 0;
	  install_operand (s[1], tmpreg);
	  break;

	case 'R':
	  /* This depends on the fact that ADDR registers are eight
	     more than their corresponding DATA regs, so the result
	     will have the ADDR_REG bit set.  */
	  install_operand (s[1], opP->reg - DATA);
	  break;

	case 'r':
	  if (opP->mode == AINDR)
	    install_operand (s[1], opP->reg - DATA);
	  else
	    install_operand (s[1], opP->index.reg - DATA);
	  break;

	case 's':
	  if (opP->reg == FPI)
	    tmpreg = 0x1;
	  else if (opP->reg == FPS)
	    tmpreg = 0x2;
	  else if (opP->reg == FPC)
	    tmpreg = 0x4;
	  else
	    abort ();
	  install_operand (s[1], tmpreg);
	  break;

	case 'S':		/* Ignore it.  */
	  break;

	case 'T':
	  install_operand (s[1], get_num (&opP->disp, 30));
	  break;

	case 'U':		/* Ignore it.  */
	  break;

	case 'c':
	  switch (opP->reg)
	    {
	    case NC:
	      tmpreg = 0;
	      break;
	    case DC:
	      tmpreg = 1;
	      break;
	    case IC:
	      tmpreg = 2;
	      break;
	    case BC:
	      tmpreg = 3;
	      break;
	    default:
	      as_fatal (_("failed sanity check"));
	    }			/* switch on cache token.  */
	  install_operand (s[1], tmpreg);
	  break;
#ifndef NO_68851
	  /* JF: These are out of order, I fear.  */
	case 'f':
	  switch (opP->reg)
	    {
	    case SFC:
	      tmpreg = 0;
	      break;
	    case DFC:
	      tmpreg = 1;
	      break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;

	case '0':
	case '1':
	case '2':
	  switch (opP->reg)
	    {
	    case TC:
	      tmpreg = 0;
	      break;
	    case CAL:
	      tmpreg = 4;
	      break;
	    case VAL:
	      tmpreg = 5;
	      break;
	    case SCC:
	      tmpreg = 6;
	      break;
	    case AC:
	      tmpreg = 7;
	      break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;

	case 'V':
	  if (opP->reg == VAL)
	    break;
	  abort ();

	case 'W':
	  switch (opP->reg)
	    {
	    case DRP:
	      tmpreg = 1;
	      break;
	    case SRP:
	      tmpreg = 2;
	      break;
	    case CRP:
	      tmpreg = 3;
	      break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;

	case 'X':
	  switch (opP->reg)
	    {
	    case BAD:
	    case BAD + 1:
	    case BAD + 2:
	    case BAD + 3:
	    case BAD + 4:
	    case BAD + 5:
	    case BAD + 6:
	    case BAD + 7:
	      tmpreg = (4 << 10) | ((opP->reg - BAD) << 2);
	      break;

	    case BAC:
	    case BAC + 1:
	    case BAC + 2:
	    case BAC + 3:
	    case BAC + 4:
	    case BAC + 5:
	    case BAC + 6:
	    case BAC + 7:
	      tmpreg = (5 << 10) | ((opP->reg - BAC) << 2);
	      break;

	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;
	case 'Y':
	  know (opP->reg == PSR);
	  break;
	case 'Z':
	  know (opP->reg == PCSR);
	  break;
#endif /* m68851 */
	case '3':
	  switch (opP->reg)
	    {
	    case TT0:
	      tmpreg = 2;
	      break;
	    case TT1:
	      tmpreg = 3;
	      break;
	    default:
	      abort ();
	    }
	  install_operand (s[1], tmpreg);
	  break;
	case 't':
	  tmpreg = get_num (&opP->disp, 20);
	  install_operand (s[1], tmpreg);
	  break;
	case '_':	/* used only for move16 absolute 32-bit address.  */
	  if (isvar (&opP->disp))
	    add_fix ('l', &opP->disp, 0, 0);
	  tmpreg = get_num (&opP->disp, 90);
	  addword (tmpreg >> 16);
	  addword (tmpreg & 0xFFFF);
	  break;
	case 'u':
	  install_operand (s[1], opP->reg - DATA0L);
	  opP->reg -= (DATA0L);
	  opP->reg &= 0x0F;	/* remove upper/lower bit.  */
	  break;
	case 'x':
	  tmpreg = get_num (&opP->disp, 80);
	  if (tmpreg == -1)
	    tmpreg = 0;
	  install_operand (s[1], tmpreg);
	  break;
	default:
	  abort ();
	}
    }

  /* By the time whe get here (FINALLY) the_ins contains the complete
     instruction, ready to be emitted. . .  */
}

static int
reverse_16_bits (in)
     int in;
{
  int out = 0;
  int n;

  static int mask[16] =
  {
    0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000
  };
  for (n = 0; n < 16; n++)
    {
      if (in & mask[n])
	out |= mask[15 - n];
    }
  return out;
}				/* reverse_16_bits() */

static int
reverse_8_bits (in)
     int in;
{
  int out = 0;
  int n;

  static int mask[8] =
  {
    0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
  };

  for (n = 0; n < 8; n++)
    {
      if (in & mask[n])
	out |= mask[7 - n];
    }
  return out;
}				/* reverse_8_bits() */

/* Cause an extra frag to be generated here, inserting up to 10 bytes
   (that value is chosen in the frag_var call in md_assemble).  TYPE
   is the subtype of the frag to be generated; its primary type is
   rs_machine_dependent.

   The TYPE parameter is also used by md_convert_frag_1 and
   md_estimate_size_before_relax.  The appropriate type of fixup will
   be emitted by md_convert_frag_1.

   ADD becomes the FR_SYMBOL field of the frag, and OFF the FR_OFFSET.  */
static void
install_operand (mode, val)
     int mode;
     int val;
{
  switch (mode)
    {
    case 's':
      the_ins.opcode[0] |= val & 0xFF;	/* JF FF is for M kludge.  */
      break;
    case 'd':
      the_ins.opcode[0] |= val << 9;
      break;
    case '1':
      the_ins.opcode[1] |= val << 12;
      break;
    case '2':
      the_ins.opcode[1] |= val << 6;
      break;
    case '3':
      the_ins.opcode[1] |= val;
      break;
    case '4':
      the_ins.opcode[2] |= val << 12;
      break;
    case '5':
      the_ins.opcode[2] |= val << 6;
      break;
    case '6':
      /* DANGER!  This is a hack to force cas2l and cas2w cmds to be
	 three words long! */
      the_ins.numo++;
      the_ins.opcode[2] |= val;
      break;
    case '7':
      the_ins.opcode[1] |= val << 7;
      break;
    case '8':
      the_ins.opcode[1] |= val << 10;
      break;
#ifndef NO_68851
    case '9':
      the_ins.opcode[1] |= val << 5;
      break;
#endif

    case 't':
      the_ins.opcode[1] |= (val << 10) | (val << 7);
      break;
    case 'D':
      the_ins.opcode[1] |= (val << 12) | val;
      break;
    case 'g':
      the_ins.opcode[0] |= val = 0xff;
      break;
    case 'i':
      the_ins.opcode[0] |= val << 9;
      break;
    case 'C':
      the_ins.opcode[1] |= val;
      break;
    case 'j':
      the_ins.opcode[1] |= val;
      the_ins.numo++;		/* What a hack.  */
      break;
    case 'k':
      the_ins.opcode[1] |= val << 4;
      break;
    case 'b':
    case 'w':
    case 'W':
    case 'l':
      break;
    case 'e':
      the_ins.opcode[0] |= (val << 6);
      break;
    case 'L':
      the_ins.opcode[1] = (val >> 16);
      the_ins.opcode[2] = val & 0xffff;
      break;
    case 'm':
      the_ins.opcode[0] |= ((val & 0x8) << (6 - 3));
      the_ins.opcode[0] |= ((val & 0x7) << 9);
      the_ins.opcode[1] |= ((val & 0x10) << (7 - 4));
      break;
    case 'n':
      the_ins.opcode[0] |= ((val & 0x8) << (6 - 3));
      the_ins.opcode[0] |= ((val & 0x7) << 9);
      break;
    case 'o':
      the_ins.opcode[1] |= val << 12;
      the_ins.opcode[1] |= ((val & 0x10) << (7 - 4));
      break;
    case 'M':
      the_ins.opcode[0] |= (val & 0xF);
      the_ins.opcode[1] |= ((val & 0x10) << (6 - 4));
      break;
    case 'N':
      the_ins.opcode[1] |= (val & 0xF);
      the_ins.opcode[1] |= ((val & 0x10) << (6 - 4));
      break;
    case 'h':
      the_ins.opcode[1] |= ((val != 1) << 10);
      break;
    case 'c':
    default:
      as_fatal (_("failed sanity check."));
    }
}				/* install_operand() */

static void
install_gen_operand (mode, val)
     int mode;
     int val;
{
  switch (mode)
    {
    case 's':
      the_ins.opcode[0] |= val;
      break;
    case 'd':
      /* This is a kludge!!! */
      the_ins.opcode[0] |= (val & 0x07) << 9 | (val & 0x38) << 3;
      break;
    case 'b':
    case 'w':
    case 'l':
    case 'f':
    case 'F':
    case 'x':
    case 'p':
      the_ins.opcode[0] |= val;
      break;
      /* more stuff goes here.  */
    default:
      as_fatal (_("failed sanity check."));
    }
}				/* install_gen_operand() */

/*
 * verify that we have some number of paren pairs, do m68k_ip_op(), and
 * then deal with the bitfield hack.
 */

static char *
crack_operand (str, opP)
     register char *str;
     register struct m68k_op *opP;
{
  register int parens;
  register int c;
  register char *beg_str;
  int inquote = 0;

  if (!str)
    {
      return str;
    }
  beg_str = str;
  for (parens = 0; *str && (parens > 0 || inquote || notend (str)); str++)
    {
      if (! inquote)
	{
	  if (*str == '(')
	    parens++;
	  else if (*str == ')')
	    {
	      if (!parens)
		{			/* ERROR.  */
		  opP->error = _("Extra )");
		  return str;
		}
	      --parens;
	    }
	}
      if (flag_mri && *str == '\'')
	inquote = ! inquote;
    }
  if (!*str && parens)
    {				/* ERROR.  */
      opP->error = _("Missing )");
      return str;
    }
  c = *str;
  *str = '\0';
  if (m68k_ip_op (beg_str, opP) != 0)
    {
      *str = c;
      return str;
    }
  *str = c;
  if (c == '}')
    c = *++str;			/* JF bitfield hack.  */
  if (c)
    {
      c = *++str;
      if (!c)
	as_bad (_("Missing operand"));
    }

  /* Detect MRI REG symbols and convert them to REGLSTs.  */
  if (opP->mode == CONTROL && (int)opP->reg < 0)
    {
      opP->mode = REGLST;
      opP->mask = ~(int)opP->reg;
      opP->reg = 0;
    }

  return str;
}

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.
   */

static void
insert_reg (regname, regnum)
     const char *regname;
     int regnum;
{
  char buf[100];
  int i;

#ifdef REGISTER_PREFIX
  if (!flag_reg_prefix_optional)
    {
      buf[0] = REGISTER_PREFIX;
      strcpy (buf + 1, regname);
      regname = buf;
    }
#endif

  symbol_table_insert (symbol_new (regname, reg_section, regnum,
				   &zero_address_frag));

  for (i = 0; regname[i]; i++)
    buf[i] = TOUPPER (regname[i]);
  buf[i] = '\0';

  symbol_table_insert (symbol_new (buf, reg_section, regnum,
				   &zero_address_frag));
}

struct init_entry
  {
    const char *name;
    int number;
  };

static const struct init_entry init_table[] =
{
  { "d0", DATA0 },
  { "d1", DATA1 },
  { "d2", DATA2 },
  { "d3", DATA3 },
  { "d4", DATA4 },
  { "d5", DATA5 },
  { "d6", DATA6 },
  { "d7", DATA7 },
  { "a0", ADDR0 },
  { "a1", ADDR1 },
  { "a2", ADDR2 },
  { "a3", ADDR3 },
  { "a4", ADDR4 },
  { "a5", ADDR5 },
  { "a6", ADDR6 },
  { "fp", ADDR6 },
  { "a7", ADDR7 },
  { "sp", ADDR7 },
  { "ssp", ADDR7 },
  { "fp0", FP0 },
  { "fp1", FP1 },
  { "fp2", FP2 },
  { "fp3", FP3 },
  { "fp4", FP4 },
  { "fp5", FP5 },
  { "fp6", FP6 },
  { "fp7", FP7 },
  { "fpi", FPI },
  { "fpiar", FPI },
  { "fpc", FPI },
  { "fps", FPS },
  { "fpsr", FPS },
  { "fpc", FPC },
  { "fpcr", FPC },
  { "control", FPC },
  { "status", FPS },
  { "iaddr", FPI },

  { "cop0", COP0 },
  { "cop1", COP1 },
  { "cop2", COP2 },
  { "cop3", COP3 },
  { "cop4", COP4 },
  { "cop5", COP5 },
  { "cop6", COP6 },
  { "cop7", COP7 },
  { "pc", PC },
  { "zpc", ZPC },
  { "sr", SR },

  { "ccr", CCR },
  { "cc", CCR },

  { "acc", ACC },
  { "macsr", MACSR },
  { "mask", MASK },

  /* Control registers.  */
  { "sfc", SFC },		/* Source Function Code.  */
  { "sfcr", SFC },
  { "dfc", DFC },		/* Destination Function Code.  */
  { "dfcr", DFC },
  { "cacr", CACR },		/* Cache Control Register.  */
  { "caar", CAAR },		/* Cache Address Register.  */

  { "usp", USP },		/* User Stack Pointer.  */
  { "vbr", VBR },		/* Vector Base Register.  */
  { "msp", MSP },		/* Master Stack Pointer.  */
  { "isp", ISP },		/* Interrupt Stack Pointer.  */

  { "itt0", ITT0 },		/* Instruction Transparent Translation Reg 0.  */
  { "itt1", ITT1 },		/* Instruction Transparent Translation Reg 1.  */
  { "dtt0", DTT0 },		/* Data Transparent Translation Register 0.  */
  { "dtt1", DTT1 },		/* Data Transparent Translation Register 1.  */

  /* 68ec040 versions of same */
  { "iacr0", ITT0 },		/* Instruction Access Control Register 0.  */
  { "iacr1", ITT1 },		/* Instruction Access Control Register 0.  */
  { "dacr0", DTT0 },		/* Data Access Control Register 0.  */
  { "dacr1", DTT1 },		/* Data Access Control Register 0.  */

  /* mcf5200 versions of same.  The ColdFire programmer's reference
     manual indicated that the order is 2,3,0,1, but Ken Rose
     <rose@@netcom.com> says that 0,1,2,3 is the correct order.  */
  { "acr0", ACR0 },		/* Access Control Unit 0.  */
  { "acr1", ACR1 },		/* Access Control Unit 1.  */
  { "acr2", ACR2 },		/* Access Control Unit 2.  */
  { "acr3", ACR3 },		/* Access Control Unit 3.  */

  { "tc", TC },			/* MMU Translation Control Register.  */
  { "tcr", TC },

  { "mmusr", MMUSR },		/* MMU Status Register.  */
  { "srp", SRP },		/* User Root Pointer.  */
  { "urp", URP },		/* Supervisor Root Pointer.  */

  { "buscr", BUSCR },
  { "pcr", PCR },

  { "rombar", ROMBAR },		/* ROM Base Address Register.  */
  { "rambar0", RAMBAR0 },	/* ROM Base Address Register.  */
  { "rambar1", RAMBAR1 },	/* ROM Base Address Register.  */
  { "mbar", MBAR },		/* Module Base Address Register.  */

  { "mbar0",    MBAR0 },	/* mcfv4e registers.  */
  { "mbar1",    MBAR1 },	/* mcfv4e registers.  */
  { "rombar0",  ROMBAR },	/* mcfv4e registers.  */
  { "rombar1",  ROMBAR1 },	/* mcfv4e registers.  */
  { "mpcr",     MPCR },		/* mcfv4e registers.  */
  { "edrambar", EDRAMBAR },	/* mcfv4e registers.  */
  { "secmbar",  SECMBAR },	/* mcfv4e registers.  */
  { "asid",     TC },		/* mcfv4e registers.  */
  { "mmubar",   BUSCR },	/* mcfv4e registers.  */
  { "pcr1u0",   PCR1U0 },	/* mcfv4e registers.  */
  { "pcr1l0",   PCR1L0 },	/* mcfv4e registers.  */
  { "pcr2u0",   PCR2U0 },	/* mcfv4e registers.  */
  { "pcr2l0",   PCR2L0 },	/* mcfv4e registers.  */
  { "pcr3u0",   PCR3U0 },	/* mcfv4e registers.  */
  { "pcr3l0",   PCR3L0 },	/* mcfv4e registers.  */
  { "pcr1u1",   PCR1U1 },	/* mcfv4e registers.  */
  { "pcr1l1",   PCR1L1 },	/* mcfv4e registers.  */
  { "pcr2u1",   PCR2U1 },	/* mcfv4e registers.  */
  { "pcr2l1",   PCR2L1 },	/* mcfv4e registers.  */
  { "pcr3u1",   PCR3U1 },	/* mcfv4e registers.  */
  { "pcr3l1",   PCR3L1 },	/* mcfv4e registers.  */

  { "flashbar", FLASHBAR }, 	/* mcf528x registers.  */
  { "rambar",   RAMBAR },  	/* mcf528x registers.  */
  /* End of control registers.  */

  { "ac", AC },
  { "bc", BC },
  { "cal", CAL },
  { "crp", CRP },
  { "drp", DRP },
  { "pcsr", PCSR },
  { "psr", PSR },
  { "scc", SCC },
  { "val", VAL },
  { "bad0", BAD0 },
  { "bad1", BAD1 },
  { "bad2", BAD2 },
  { "bad3", BAD3 },
  { "bad4", BAD4 },
  { "bad5", BAD5 },
  { "bad6", BAD6 },
  { "bad7", BAD7 },
  { "bac0", BAC0 },
  { "bac1", BAC1 },
  { "bac2", BAC2 },
  { "bac3", BAC3 },
  { "bac4", BAC4 },
  { "bac5", BAC5 },
  { "bac6", BAC6 },
  { "bac7", BAC7 },

  { "ic", IC },
  { "dc", DC },
  { "nc", NC },

  { "tt0", TT0 },
  { "tt1", TT1 },
  /* 68ec030 versions of same.  */
  { "ac0", TT0 },
  { "ac1", TT1 },
  /* 68ec030 access control unit, identical to 030 MMU status reg.  */
  { "acusr", PSR },

  /* Suppressed data and address registers.  */
  { "zd0", ZDATA0 },
  { "zd1", ZDATA1 },
  { "zd2", ZDATA2 },
  { "zd3", ZDATA3 },
  { "zd4", ZDATA4 },
  { "zd5", ZDATA5 },
  { "zd6", ZDATA6 },
  { "zd7", ZDATA7 },
  { "za0", ZADDR0 },
  { "za1", ZADDR1 },
  { "za2", ZADDR2 },
  { "za3", ZADDR3 },
  { "za4", ZADDR4 },
  { "za5", ZADDR5 },
  { "za6", ZADDR6 },
  { "za7", ZADDR7 },

  /* Upper and lower data and address registers, used by macw and msacw.  */
  { "d0l", DATA0L },
  { "d1l", DATA1L },
  { "d2l", DATA2L },
  { "d3l", DATA3L },
  { "d4l", DATA4L },
  { "d5l", DATA5L },
  { "d6l", DATA6L },
  { "d7l", DATA7L },

  { "a0l", ADDR0L },
  { "a1l", ADDR1L },
  { "a2l", ADDR2L },
  { "a3l", ADDR3L },
  { "a4l", ADDR4L },
  { "a5l", ADDR5L },
  { "a6l", ADDR6L },
  { "a7l", ADDR7L },

  { "d0u", DATA0U },
  { "d1u", DATA1U },
  { "d2u", DATA2U },
  { "d3u", DATA3U },
  { "d4u", DATA4U },
  { "d5u", DATA5U },
  { "d6u", DATA6U },
  { "d7u", DATA7U },

  { "a0u", ADDR0U },
  { "a1u", ADDR1U },
  { "a2u", ADDR2U },
  { "a3u", ADDR3U },
  { "a4u", ADDR4U },
  { "a5u", ADDR5U },
  { "a6u", ADDR6U },
  { "a7u", ADDR7U },

  { 0, 0 }
};

static void
init_regtable ()
{
  int i;
  for (i = 0; init_table[i].name; i++)
    insert_reg (init_table[i].name, init_table[i].number);
}

static int no_68851, no_68881;

#ifdef OBJ_AOUT
/* a.out machine type.  Default to 68020.  */
int m68k_aout_machtype = 2;
#endif

void
md_assemble (str)
     char *str;
{
  const char *er;
  short *fromP;
  char *toP = NULL;
  int m, n = 0;
  char *to_beg_P;
  int shorts_this_frag;
  fixS *fixP;

  /* In MRI mode, the instruction and operands are separated by a
     space.  Anything following the operands is a comment.  The label
     has already been removed.  */
  if (flag_mri)
    {
      char *s;
      int fields = 0;
      int infield = 0;
      int inquote = 0;

      for (s = str; *s != '\0'; s++)
	{
	  if ((*s == ' ' || *s == '\t') && ! inquote)
	    {
	      if (infield)
		{
		  ++fields;
		  if (fields >= 2)
		    {
		      *s = '\0';
		      break;
		    }
		  infield = 0;
		}
	    }
	  else
	    {
	      if (! infield)
		infield = 1;
	      if (*s == '\'')
		inquote = ! inquote;
	    }
	}
    }

  memset ((char *) (&the_ins), '\0', sizeof (the_ins));
  m68k_ip (str);
  er = the_ins.error;
  if (!er)
    {
      for (n = 0; n < the_ins.numargs; n++)
	if (the_ins.operands[n].error)
	  {
	    er = the_ins.operands[n].error;
	    break;
	  }
    }
  if (er)
    {
      as_bad (_("%s -- statement `%s' ignored"), er, str);
      return;
    }

  /* If there is a current label, record that it marks an instruction.  */
  if (current_label != NULL)
    {
      current_label->text = 1;
      current_label = NULL;
    }

#ifdef OBJ_ELF
  /* Tie dwarf2 debug info to the address at the start of the insn.  */
  dwarf2_emit_insn (0);
#endif

  if (the_ins.nfrag == 0)
    {
      /* No frag hacking involved; just put it out.  */
      toP = frag_more (2 * the_ins.numo);
      fromP = &the_ins.opcode[0];
      for (m = the_ins.numo; m; --m)
	{
	  md_number_to_chars (toP, (long) (*fromP), 2);
	  toP += 2;
	  fromP++;
	}
      /* Put out symbol-dependent info.  */
      for (m = 0; m < the_ins.nrel; m++)
	{
	  switch (the_ins.reloc[m].wid)
	    {
	    case 'B':
	      n = 1;
	      break;
	    case 'b':
	      n = 1;
	      break;
	    case '3':
	      n = 1;
	      break;
	    case 'w':
	    case 'W':
	      n = 2;
	      break;
	    case 'l':
	      n = 4;
	      break;
	    default:
	      as_fatal (_("Don't know how to figure width of %c in md_assemble()"),
			the_ins.reloc[m].wid);
	    }

	  fixP = fix_new_exp (frag_now,
			      ((toP - frag_now->fr_literal)
			       - the_ins.numo * 2 + the_ins.reloc[m].n),
			      n,
			      &the_ins.reloc[m].exp,
			      the_ins.reloc[m].pcrel,
			      get_reloc_code (n, the_ins.reloc[m].pcrel,
					      the_ins.reloc[m].pic_reloc));
	  fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
	  if (the_ins.reloc[m].wid == 'B')
	    fixP->fx_signed = 1;
	}
      return;
    }

  /* There's some frag hacking.  */
  {
    /* Calculate the max frag size.  */
    int wid;

    wid = 2 * the_ins.fragb[0].fragoff;
    for (n = 1; n < the_ins.nfrag; n++)
      wid += 2 * (the_ins.numo - the_ins.fragb[n - 1].fragoff);
    /* frag_var part.  */
    wid += 10;
    /* Make sure the whole insn fits in one chunk, in particular that
       the var part is attached, as we access one byte before the
       variable frag for byte branches.  */
    frag_grow (wid);
  }

  for (n = 0, fromP = &the_ins.opcode[0]; n < the_ins.nfrag; n++)
    {
      int wid;

      if (n == 0)
	wid = 2 * the_ins.fragb[n].fragoff;
      else
	wid = 2 * (the_ins.numo - the_ins.fragb[n - 1].fragoff);
      toP = frag_more (wid);
      to_beg_P = toP;
      shorts_this_frag = 0;
      for (m = wid / 2; m; --m)
	{
	  md_number_to_chars (toP, (long) (*fromP), 2);
	  toP += 2;
	  fromP++;
	  shorts_this_frag++;
	}
      for (m = 0; m < the_ins.nrel; m++)
	{
	  if ((the_ins.reloc[m].n) >= 2 * shorts_this_frag)
	    {
	      the_ins.reloc[m].n -= 2 * shorts_this_frag;
	      break;
	    }
	  wid = the_ins.reloc[m].wid;
	  if (wid == 0)
	    continue;
	  the_ins.reloc[m].wid = 0;
	  wid = (wid == 'b') ? 1 : (wid == 'w') ? 2 : (wid == 'l') ? 4 : 4000;

	  fixP = fix_new_exp (frag_now,
			      ((toP - frag_now->fr_literal)
			       - the_ins.numo * 2 + the_ins.reloc[m].n),
			      wid,
			      &the_ins.reloc[m].exp,
			      the_ins.reloc[m].pcrel,
			      get_reloc_code (wid, the_ins.reloc[m].pcrel,
					      the_ins.reloc[m].pic_reloc));
	  fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
	}
      (void) frag_var (rs_machine_dependent, 10, 0,
		       (relax_substateT) (the_ins.fragb[n].fragty),
		       the_ins.fragb[n].fadd, the_ins.fragb[n].foff, to_beg_P);
    }
  n = (the_ins.numo - the_ins.fragb[n - 1].fragoff);
  shorts_this_frag = 0;
  if (n)
    {
      toP = frag_more (n * sizeof (short));
      while (n--)
	{
	  md_number_to_chars (toP, (long) (*fromP), 2);
	  toP += 2;
	  fromP++;
	  shorts_this_frag++;
	}
    }
  for (m = 0; m < the_ins.nrel; m++)
    {
      int wid;

      wid = the_ins.reloc[m].wid;
      if (wid == 0)
	continue;
      the_ins.reloc[m].wid = 0;
      wid = (wid == 'b') ? 1 : (wid == 'w') ? 2 : (wid == 'l') ? 4 : 4000;

      fixP = fix_new_exp (frag_now,
			  ((the_ins.reloc[m].n + toP - frag_now->fr_literal)
			   - shorts_this_frag * 2),
			  wid,
			  &the_ins.reloc[m].exp,
			  the_ins.reloc[m].pcrel,
			  get_reloc_code (wid, the_ins.reloc[m].pcrel,
					  the_ins.reloc[m].pic_reloc));
      fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
    }
}

void
md_begin ()
{
  /*
   * md_begin -- set up hash tables with 68000 instructions.
   * similar to what the vax assembler does.  ---phr
   */
  /* RMS claims the thing to do is take the m68k-opcode.h table, and make
     a copy of it at runtime, adding in the information we want but isn't
     there.  I think it'd be better to have an awk script hack the table
     at compile time.  Or even just xstr the table and use it as-is.  But
     my lord ghod hath spoken, so we do it this way.  Excuse the ugly var
     names.  */

  const struct m68k_opcode *ins;
  struct m68k_incant *hack, *slak;
  const char *retval = 0;	/* Empty string, or error msg text.  */
  int i;

  if (flag_mri)
    {
      flag_reg_prefix_optional = 1;
      m68k_abspcadd = 1;
      if (! m68k_rel32_from_cmdline)
	m68k_rel32 = 0;
    }

  op_hash = hash_new ();

  obstack_begin (&robyn, 4000);
  for (i = 0; i < m68k_numopcodes; i++)
    {
      hack = slak = (struct m68k_incant *) obstack_alloc (&robyn, sizeof (struct m68k_incant));
      do
	{
	  ins = &m68k_opcodes[i];
	  /* We *could* ignore insns that don't match our arch here
	     but just leaving them out of the hash.  */
	  slak->m_operands = ins->args;
	  slak->m_opnum = strlen (slak->m_operands) / 2;
	  slak->m_arch = ins->arch;
	  slak->m_opcode = ins->opcode;
	  /* This is kludgey.  */
	  slak->m_codenum = ((ins->match) & 0xffffL) ? 2 : 1;
	  if (i + 1 != m68k_numopcodes
	      && !strcmp (ins->name, m68k_opcodes[i + 1].name))
	    {
	      slak->m_next = (struct m68k_incant *) obstack_alloc (&robyn, sizeof (struct m68k_incant));
	      i++;
	    }
	  else
	    slak->m_next = 0;
	  slak = slak->m_next;
	}
      while (slak);

      retval = hash_insert (op_hash, ins->name, (char *) hack);
      if (retval)
	as_fatal (_("Internal Error:  Can't hash %s: %s"), ins->name, retval);
    }

  for (i = 0; i < m68k_numaliases; i++)
    {
      const char *name = m68k_opcode_aliases[i].primary;
      const char *alias = m68k_opcode_aliases[i].alias;
      PTR val = hash_find (op_hash, name);
      if (!val)
	as_fatal (_("Internal Error: Can't find %s in hash table"), name);
      retval = hash_insert (op_hash, alias, val);
      if (retval)
	as_fatal (_("Internal Error: Can't hash %s: %s"), alias, retval);
    }

  /* In MRI mode, all unsized branches are variable sized.  Normally,
     they are word sized.  */
  if (flag_mri)
    {
      static struct m68k_opcode_alias mri_aliases[] =
	{
	  { "bhi",	"jhi", },
	  { "bls",	"jls", },
	  { "bcc",	"jcc", },
	  { "bcs",	"jcs", },
	  { "bne",	"jne", },
	  { "beq",	"jeq", },
	  { "bvc",	"jvc", },
	  { "bvs",	"jvs", },
	  { "bpl",	"jpl", },
	  { "bmi",	"jmi", },
	  { "bge",	"jge", },
	  { "blt",	"jlt", },
	  { "bgt",	"jgt", },
	  { "ble",	"jle", },
	  { "bra",	"jra", },
	  { "bsr",	"jbsr", },
	};

      for (i = 0;
	   i < (int) (sizeof mri_aliases / sizeof mri_aliases[0]);
	   i++)
	{
	  const char *name = mri_aliases[i].primary;
	  const char *alias = mri_aliases[i].alias;
	  PTR val = hash_find (op_hash, name);
	  if (!val)
	    as_fatal (_("Internal Error: Can't find %s in hash table"), name);
	  retval = hash_jam (op_hash, alias, val);
	  if (retval)
	    as_fatal (_("Internal Error: Can't hash %s: %s"), alias, retval);
	}
    }

  for (i = 0; i < (int) sizeof (notend_table); i++)
    {
      notend_table[i] = 0;
      alt_notend_table[i] = 0;
    }
  notend_table[','] = 1;
  notend_table['{'] = 1;
  notend_table['}'] = 1;
  alt_notend_table['a'] = 1;
  alt_notend_table['A'] = 1;
  alt_notend_table['d'] = 1;
  alt_notend_table['D'] = 1;
  alt_notend_table['#'] = 1;
  alt_notend_table['&'] = 1;
  alt_notend_table['f'] = 1;
  alt_notend_table['F'] = 1;
#ifdef REGISTER_PREFIX
  alt_notend_table[REGISTER_PREFIX] = 1;
#endif

  /* We need to put '(' in alt_notend_table to handle
       cas2 %d0:%d2,%d3:%d4,(%a0):(%a1)
     */
  alt_notend_table['('] = 1;

  /* We need to put '@@' in alt_notend_table to handle
       cas2 %d0:%d2,%d3:%d4,@@(%d0):@@(%d1)
     */
  alt_notend_table['@@'] = 1;

  /* We need to put digits in alt_notend_table to handle
       bfextu %d0{24:1},%d0
     */
  alt_notend_table['0'] = 1;
  alt_notend_table['1'] = 1;
  alt_notend_table['2'] = 1;
  alt_notend_table['3'] = 1;
  alt_notend_table['4'] = 1;
  alt_notend_table['5'] = 1;
  alt_notend_table['6'] = 1;
  alt_notend_table['7'] = 1;
  alt_notend_table['8'] = 1;
  alt_notend_table['9'] = 1;

#ifndef MIT_SYNTAX_ONLY
  /* Insert pseudo ops, these have to go into the opcode table since
     gas expects pseudo ops to start with a dot.  */
  {
    int n = 0;
    while (mote_pseudo_table[n].poc_name)
      {
	hack = (struct m68k_incant *)
	  obstack_alloc (&robyn, sizeof (struct m68k_incant));
	hash_insert (op_hash,
		     mote_pseudo_table[n].poc_name, (char *) hack);
	hack->m_operands = 0;
	hack->m_opnum = n;
	n++;
      }
  }
#endif

  init_regtable ();

#ifdef OBJ_ELF
  record_alignment (text_section, 2);
  record_alignment (data_section, 2);
  record_alignment (bss_section, 2);
#endif
}

static void
select_control_regs ()
{
  /* Note which set of "movec" control registers is available.  */
  switch (cpu_of_arch (current_architecture))
    {
    case 0:
      as_warn (_("architecture not yet selected: defaulting to 68020"));
      control_regs = m68020_control_regs;
      break;
      
    case m68000:
      control_regs = m68000_control_regs;
      break;
    case m68010:
      control_regs = m68010_control_regs;
      break;
    case m68020:
    case m68030:
      control_regs = m68020_control_regs;
      break;
    case m68040:
      control_regs = m68040_control_regs;
      break;
    case m68060:
      control_regs = m68060_control_regs;
      break;
    case cpu32:
      control_regs = cpu32_control_regs;
      break;
    case mcf5200:
    case mcf5206e:
    case mcf5307:
    case mcf5407:
      control_regs = mcf_control_regs;
      break;
    case mcf528x:
      control_regs = mcf528x_control_regs;
      break;
    case mcfv4e:
      control_regs = mcfv4e_control_regs;
      break;
    default:
      abort ();
    }
}

void
m68k_init_after_args ()
{
  if (cpu_of_arch (current_architecture) == 0)
    {
      int i;
      const char *default_cpu = TARGET_CPU;

      if (*default_cpu == 'm')
	default_cpu++;
      for (i = 0; i < n_archs; i++)
	if (strcasecmp (default_cpu, archs[i].name) == 0)
	  break;
      if (i == n_archs)
	{
	  as_bad (_("unrecognized default cpu `%s' ???"), TARGET_CPU);
	  current_architecture |= m68020;
	}
      else
	current_architecture |= archs[i].arch;
    }
  /* Permit m68881 specification with all cpus; those that can't work
     with a coprocessor could be doing emulation.  */
  if (current_architecture & m68851)
    {
      if (current_architecture & m68040)
	{
	  as_warn (_("68040 and 68851 specified; mmu instructions may assemble incorrectly"));
	}
    }
  /* What other incompatibilities could we check for?  */

  /* Toss in some default assumptions about coprocessors.  */
  if (!no_68881
      && (cpu_of_arch (current_architecture)
	  /* Can CPU32 have a 68881 coprocessor??  */
	  & (m68020 | m68030 | cpu32)))
    {
      current_architecture |= m68881;
    }
  if (!no_68851
      && (cpu_of_arch (current_architecture) & m68020up) != 0
      && (cpu_of_arch (current_architecture) & m68040up) == 0)
    {
      current_architecture |= m68851;
    }
  if (no_68881 && (current_architecture & m68881))
    as_bad (_("options for 68881 and no-68881 both given"));
  if (no_68851 && (current_architecture & m68851))
    as_bad (_("options for 68851 and no-68851 both given"));

#ifdef OBJ_AOUT
  /* Work out the magic number.  This isn't very general.  */
  if (current_architecture & m68000)
    m68k_aout_machtype = 0;
  else if (current_architecture & m68010)
    m68k_aout_machtype = 1;
  else if (current_architecture & m68020)
    m68k_aout_machtype = 2;
  else
    m68k_aout_machtype = 2;
#endif

  /* Note which set of "movec" control registers is available.  */
  select_control_regs ();

  if (cpu_of_arch (current_architecture) < m68020
      || arch_coldfire_p (current_architecture))
    md_relax_table[TAB (PCINDEX, BYTE)].rlx_more = 0;
}

/* This is called when a label is defined.  */

void
m68k_frob_label (sym)
     symbolS *sym;
{
  struct label_line *n;

  n = (struct label_line *) xmalloc (sizeof *n);
  n->next = labels;
  n->label = sym;
  as_where (&n->file, &n->line);
  n->text = 0;
  labels = n;
  current_label = n;
}

/* This is called when a value that is not an instruction is emitted.  */

void
m68k_flush_pending_output ()
{
  current_label = NULL;
}

/* This is called at the end of the assembly, when the final value of
   the label is known.  We warn if this is a text symbol aligned at an
   odd location.  */

void
m68k_frob_symbol (sym)
     symbolS *sym;
{
  if (S_GET_SEGMENT (sym) == reg_section
      && (int) S_GET_VALUE (sym) < 0)
    {
      S_SET_SEGMENT (sym, absolute_section);
      S_SET_VALUE (sym, ~(int)S_GET_VALUE (sym));
    }
  else if ((S_GET_VALUE (sym) & 1) != 0)
    {
      struct label_line *l;

      for (l = labels; l != NULL; l = l->next)
	{
	  if (l->label == sym)
	    {
	      if (l->text)
		as_warn_where (l->file, l->line,
			       _("text label `%s' aligned to odd boundary"),
			       S_GET_NAME (sym));
	      break;
	    }
	}
    }
}

/* This is called if we go in or out of MRI mode because of the .mri
   pseudo-op.  */

void
m68k_mri_mode_change (on)
     int on;
{
  if (on)
    {
      if (! flag_reg_prefix_optional)
	{
	  flag_reg_prefix_optional = 1;
#ifdef REGISTER_PREFIX
	  init_regtable ();
#endif
	}
      m68k_abspcadd = 1;
      if (! m68k_rel32_from_cmdline)
	m68k_rel32 = 0;
    }
  else
    {
      if (! reg_prefix_optional_seen)
	{
#ifdef REGISTER_PREFIX_OPTIONAL
	  flag_reg_prefix_optional = REGISTER_PREFIX_OPTIONAL;
#else
	  flag_reg_prefix_optional = 0;
#endif
#ifdef REGISTER_PREFIX
	  init_regtable ();
#endif
	}
      m68k_abspcadd = 0;
      if (! m68k_rel32_from_cmdline)
	m68k_rel32 = 1;
    }
}

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

void
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
{
  number_to_chars_bigendian (buf, val, n);
}

void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
{
  offsetT val = *valP;
  addressT upper_limit;
  offsetT lower_limit;

  /* This is unnecessary but it convinces the native rs6000 compiler
     to generate the code we want.  */
  char *buf = fixP->fx_frag->fr_literal;
  buf += fixP->fx_where;
  /* End ibm compiler workaround.  */

  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;

#ifdef OBJ_ELF
  if (fixP->fx_addsy)
    {
      memset (buf, 0, fixP->fx_size);
      fixP->fx_addnumber = val;	/* Remember value for emit_reloc.  */

      if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
	  && !S_IS_DEFINED (fixP->fx_addsy)
	  && !S_IS_WEAK (fixP->fx_addsy))
	S_SET_WEAK (fixP->fx_addsy);
      return;
    }
#endif

#ifdef BFD_ASSEMBLER
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return;
#endif

  switch (fixP->fx_size)
    {
      /* The cast to offsetT below are necessary to make code
	 correct for machines where ints are smaller than offsetT.  */
    case 1:
      *buf++ = val;
      upper_limit = 0x7f;
      lower_limit = - (offsetT) 0x80;
      break;
    case 2:
      *buf++ = (val >> 8);
      *buf++ = val;
      upper_limit = 0x7fff;
      lower_limit = - (offsetT) 0x8000;
      break;
    case 4:
      *buf++ = (val >> 24);
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      upper_limit = 0x7fffffff;
      lower_limit = - (offsetT) 0x7fffffff - 1;	/* Avoid constant overflow.  */
      break;
    default:
      BAD_CASE (fixP->fx_size);
    }

  /* Fix up a negative reloc.  */
  if (fixP->fx_addsy == NULL && fixP->fx_subsy != NULL)
    {
      fixP->fx_addsy = fixP->fx_subsy;
      fixP->fx_subsy = NULL;
      fixP->fx_tcbit = 1;
    }

  /* For non-pc-relative values, it's conceivable we might get something
     like "0xff" for a byte field.  So extend the upper part of the range
     to accept such numbers.  We arbitrarily disallow "-0xff" or "0xff+0xff",
     so that we can do any range checking at all.  */
  if (! fixP->fx_pcrel && ! fixP->fx_signed)
    upper_limit = upper_limit * 2 + 1;

  if ((addressT) val > upper_limit
      && (val > 0 || val < lower_limit))
    as_bad_where (fixP->fx_file, fixP->fx_line, _("value out of range"));

  /* A one byte PC-relative reloc means a short branch.  We can't use
     a short branch with a value of 0 or -1, because those indicate
     different opcodes (branches with longer offsets).  fixup_segment
     in write.c may have clobbered fx_pcrel, so we need to examine the
     reloc type.  */
  if ((fixP->fx_pcrel
#ifdef BFD_ASSEMBLER
       || fixP->fx_r_type == BFD_RELOC_8_PCREL
#endif
       )
      && fixP->fx_size == 1
      && (fixP->fx_addsy == NULL
	  || S_IS_DEFINED (fixP->fx_addsy))
      && (val == 0 || val == -1))
    as_bad_where (fixP->fx_file, fixP->fx_line, _("invalid byte branch offset"));
}

/* *fragP has been relaxed to its final size, and now needs to have
   the bytes inside it modified to conform to the new size  There is UGLY
   MAGIC here. ..
   */
static void
md_convert_frag_1 (fragP)
     register fragS *fragP;
{
  long disp;
  fixS *fixP;

  /* Address in object code of the displacement.  */
  register int object_address = fragP->fr_fix + fragP->fr_address;

  /* Address in gas core of the place to store the displacement.  */
  /* This convinces the native rs6000 compiler to generate the code we
     want.  */
  register char *buffer_address = fragP->fr_literal;
  buffer_address += fragP->fr_fix;
  /* End ibm compiler workaround.  */

  /* The displacement of the address, from current location.  */
  disp = fragP->fr_symbol ? S_GET_VALUE (fragP->fr_symbol) : 0;
  disp = (disp + fragP->fr_offset) - object_address;

  switch (fragP->fr_subtype)
    {
    case TAB (BRANCHBWL, BYTE):
    case TAB (BRABSJUNC, BYTE):
    case TAB (BRABSJCOND, BYTE):
    case TAB (BRANCHBW, BYTE):
      know (issbyte (disp));
      if (disp == 0)
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("short branch with zero offset: use :w"));
      fixP = fix_new (fragP, fragP->fr_fix - 1, 1, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC8);
      fixP->fx_pcrel_adjust = -1;
      break;
    case TAB (BRANCHBWL, SHORT):
    case TAB (BRABSJUNC, SHORT):
    case TAB (BRABSJCOND, SHORT):
    case TAB (BRANCHBW, SHORT):
      fragP->fr_opcode[1] = 0x00;
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (BRANCHBWL, LONG):
      fragP->fr_opcode[1] = (char) 0xFF;
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC32);
      fragP->fr_fix += 4;
      break;
    case TAB (BRABSJUNC, LONG):
      if (fragP->fr_opcode[0] == 0x61)		/* jbsr */
	{
	  if (flag_keep_pcrel)
    	    as_fatal(_("Tried to convert PC relative BSR to absolute JSR"));
	  fragP->fr_opcode[0] = 0x4E;
	  fragP->fr_opcode[1] = (char) 0xB9; /* JSR with ABSL LONG operand.  */
	  fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
		   0, RELAX_RELOC_ABS32);
	  fragP->fr_fix += 4;
	}
      else if (fragP->fr_opcode[0] == 0x60)	/* jbra */
	{
	  if (flag_keep_pcrel)
	    as_fatal(_("Tried to convert PC relative branch to absolute jump"));
	  fragP->fr_opcode[0] = 0x4E;
	  fragP->fr_opcode[1] = (char) 0xF9; /* JMP with ABSL LONG operand.  */
	  fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
		   0, RELAX_RELOC_ABS32);
	  fragP->fr_fix += 4;
	}
      else
	{
	  /* This cannot happen, because jbsr and jbra are the only two
	     unconditional branches.  */
	  abort ();
	}
      break;
    case TAB (BRABSJCOND, LONG):
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative conditional branch to absolute jump"));

      /* Only Bcc 68000 instructions can come here
	 Change bcc into b!cc/jmp absl long.  */
      fragP->fr_opcode[0] ^= 0x01;	/* Invert bcc.  */
      fragP->fr_opcode[1]  = 0x06;	/* Branch offset = 6.  */

      /* JF: these used to be fr_opcode[2,3], but they may be in a
	   different frag, in which case referring to them is a no-no.
	   Only fr_opcode[0,1] are guaranteed to work.  */
      *buffer_address++ = 0x4e;	/* put in jmp long (0x4ef9) */
      *buffer_address++ = (char) 0xf9;
      fragP->fr_fix += 2;	/* Account for jmp instruction.  */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
	       fragP->fr_offset, 0, RELAX_RELOC_ABS32);
      fragP->fr_fix += 4;
      break;
    case TAB (FBRANCH, SHORT):
      know ((fragP->fr_opcode[1] & 0x40) == 0);
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (FBRANCH, LONG):
      fragP->fr_opcode[1] |= 0x40;	/* Turn on LONG bit.  */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC32);
      fragP->fr_fix += 4;
      break;
    case TAB (DBCCLBR, SHORT):
    case TAB (DBCCABSJ, SHORT):
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (DBCCLBR, LONG):
      /* Only DBcc instructions can come here.
	 Change dbcc into dbcc/bral.
	 JF: these used to be fr_opcode[2-7], but that's wrong.  */
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert DBcc to absolute jump"));

      *buffer_address++ = 0x00;	/* Branch offset = 4.  */
      *buffer_address++ = 0x04;
      *buffer_address++ = 0x60;	/* Put in bra pc+6.  */
      *buffer_address++ = 0x06;
      *buffer_address++ = 0x60;     /* Put in bral (0x60ff).  */
      *buffer_address++ = (char) 0xff;

      fragP->fr_fix += 6;	/* Account for bra/jmp instructions.  */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset, 1,
	       RELAX_RELOC_PC32);
      fragP->fr_fix += 4;
      break;
    case TAB (DBCCABSJ, LONG):
      /* Only DBcc instructions can come here.
	 Change dbcc into dbcc/jmp.
	 JF: these used to be fr_opcode[2-7], but that's wrong.  */
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative conditional branch to absolute jump"));

      *buffer_address++ = 0x00;		/* Branch offset = 4.  */
      *buffer_address++ = 0x04;
      *buffer_address++ = 0x60;		/* Put in bra pc + 6.  */
      *buffer_address++ = 0x06;
      *buffer_address++ = 0x4e;		/* Put in jmp long (0x4ef9).  */
      *buffer_address++ = (char) 0xf9;

      fragP->fr_fix += 6;		/* Account for bra/jmp instructions.  */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset, 0,
	       RELAX_RELOC_ABS32);
      fragP->fr_fix += 4;
      break;
    case TAB (PCREL1632, SHORT):
      fragP->fr_opcode[1] &= ~0x3F;
      fragP->fr_opcode[1] |= 0x3A; /* 072 - mode 7.2 */
      fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (PCREL1632, LONG):
      /* Already set to mode 7.3; this indicates: PC indirect with
	 suppressed index, 32-bit displacement.  */
      *buffer_address++ = 0x01;
      *buffer_address++ = 0x70;
      fragP->fr_fix += 2;
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fixP->fx_pcrel_adjust = 2;
      fragP->fr_fix += 4;
      break;
    case TAB (PCINDEX, BYTE):
      assert (fragP->fr_fix >= 2);
      buffer_address[-2] &= ~1;
      fixP = fix_new (fragP, fragP->fr_fix - 1, 1, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC8);
      fixP->fx_pcrel_adjust = 1;
      break;
    case TAB (PCINDEX, SHORT):
      assert (fragP->fr_fix >= 2);
      buffer_address[-2] |= 0x1;
      buffer_address[-1] = 0x20;
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC16);
      fixP->fx_pcrel_adjust = 2;
      fragP->fr_fix += 2;
      break;
    case TAB (PCINDEX, LONG):
      assert (fragP->fr_fix >= 2);
      buffer_address[-2] |= 0x1;
      buffer_address[-1] = 0x30;
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fixP->fx_pcrel_adjust = 2;
      fragP->fr_fix += 4;
      break;
    case TAB (ABSTOPCREL, SHORT):
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (ABSTOPCREL, LONG):
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative conditional branch to absolute jump"));
      /* The thing to do here is force it to ABSOLUTE LONG, since
	 ABSTOPCREL is really trying to shorten an ABSOLUTE address anyway.  */
      if ((fragP->fr_opcode[1] & 0x3F) != 0x3A)
	abort ();
      fragP->fr_opcode[1] &= ~0x3F;
      fragP->fr_opcode[1] |= 0x39;	/* Mode 7.1 */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       0, RELAX_RELOC_ABS32);
      fragP->fr_fix += 4;
      break;
    }
}

#ifndef BFD_ASSEMBLER

void
md_convert_frag (headers, sec, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
{
  md_convert_frag_1 (fragP);
}

#else

void
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
{
  md_convert_frag_1 (fragP);
}
#endif

/* Force truly undefined symbols to their maximum size, and generally set up
   the frag list to be relaxed
   */
int
md_estimate_size_before_relax (fragP, segment)
     register fragS *fragP;
     segT segment;
{
  /* Handle SZ_UNDEF first, it can be changed to BYTE or SHORT.  */
  switch (fragP->fr_subtype)
    {
    case TAB (BRANCHBWL, SZ_UNDEF):
    case TAB (BRABSJUNC, SZ_UNDEF):
    case TAB (BRABSJCOND, SZ_UNDEF):
      {
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
	  {
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), BYTE);
	  }
	else if (flag_short_refs)
	  {
	    /* Symbol is undefined and we want short ref.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	  }
	else
	  {
	    /* Symbol is still undefined.  Make it LONG.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), LONG);
	  }
	break;
      }

    case TAB (BRANCHBW, SZ_UNDEF):
      {
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
	  {
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), BYTE);
	  }
	else
	  {
	    /* Symbol is undefined and we don't have long branches.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	  }
	break;
      }

    case TAB (FBRANCH, SZ_UNDEF):
    case TAB (DBCCLBR, SZ_UNDEF):
    case TAB (DBCCABSJ, SZ_UNDEF):
    case TAB (PCREL1632, SZ_UNDEF):
      {
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs)
	  {
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	  }
	else
	  {
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), LONG);
	  }
	break;
      }

    case TAB (PCINDEX, SZ_UNDEF):
      if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	   && relaxable_symbol (fragP->fr_symbol)))
	{
	  fragP->fr_subtype = TAB (PCINDEX, BYTE);
	}
      else
	{
	  fragP->fr_subtype = TAB (PCINDEX, LONG);
	}
      break;

    case TAB (ABSTOPCREL, SZ_UNDEF):
      {
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol)))
	  {
	    fragP->fr_subtype = TAB (ABSTOPCREL, SHORT);
	  }
	else
	  {
	    fragP->fr_subtype = TAB (ABSTOPCREL, LONG);
	  }
	break;
      }

    default:
      break;
    }

  /* Now that SZ_UNDEF are taken care of, check others.  */
  switch (fragP->fr_subtype)
    {
    case TAB (BRANCHBWL, BYTE):
    case TAB (BRABSJUNC, BYTE):
    case TAB (BRABSJCOND, BYTE):
    case TAB (BRANCHBW, BYTE):
      /* We can't do a short jump to the next instruction, so in that
	 case we force word mode.  If the symbol is at the start of a
	 frag, and it is the next frag with any data in it (usually
	 this is just the next frag, but assembler listings may
	 introduce empty frags), we must use word mode.  */
      if (fragP->fr_symbol)
	{
	  fragS *sym_frag;

	  sym_frag = symbol_get_frag (fragP->fr_symbol);
	  if (S_GET_VALUE (fragP->fr_symbol) == sym_frag->fr_address)
	    {
	      fragS *l;

	      for (l = fragP->fr_next; l && l != sym_frag; l = l->fr_next)
		if (l->fr_fix != 0)
		  break;
	      if (l == sym_frag)
		fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	    }
	}
      break;
    default:
      break;
    }
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

#if defined(OBJ_AOUT) | defined(OBJ_BOUT)
/* the bit-field entries in the relocation_info struct plays hell
   with the byte-order problems of cross-assembly.  So as a hack,
   I added this mach. dependent ri twiddler.  Ugly, but it gets
   you there. -KWK  */
/* on m68k: first 4 bytes are normal unsigned long, next three bytes
   are symbolnum, most sig. byte first.  Last byte is broken up with
   bit 7 as pcrel, bits 6 & 5 as length, bit 4 as pcrel, and the lower
   nibble as nuthin. (on Sun 3 at least) */
/* Translate the internal relocation information into target-specific
   format.  */
#ifdef comment
void
md_ri_to_chars (the_bytes, ri)
     char *the_bytes;
     struct reloc_info_generic *ri;
{
  /* This is easy.  */
  md_number_to_chars (the_bytes, ri->r_address, 4);
  /* Now the fun stuff.  */
  the_bytes[4] = (ri->r_symbolnum >> 16) & 0x0ff;
  the_bytes[5] = (ri->r_symbolnum >>  8) & 0x0ff;
  the_bytes[6] =  ri->r_symbolnum        & 0x0ff;
  the_bytes[7] = (((ri->r_pcrel << 7) & 0x80) | ((ri->r_length << 5) & 0x60) |
		  ((ri->r_extern << 4) & 0x10));
}

#endif

#ifndef BFD_ASSEMBLER
void
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  /*
   * In: length of relocation (or of address) in chars: 1, 2 or 4.
   * Out: GNU LD relocation length code: 0, 1, or 2.
   */

  static const unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
  long r_symbolnum;

  know (fixP->fx_addsy != NULL);

  md_number_to_chars (where,
       fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
		      4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);

  where[4] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[6] = r_symbolnum & 0x0ff;
  where[7] = (((fixP->fx_pcrel << 7) & 0x80) | ((nbytes_r_length[fixP->fx_size] << 5) & 0x60) |
	      (((!S_IS_DEFINED (fixP->fx_addsy)) << 4) & 0x10));
}
#endif

#endif /* OBJ_AOUT or OBJ_BOUT */

#ifndef WORKING_DOT_WORD
const int md_short_jump_size = 4;
const int md_long_jump_size = 6;

void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
{
  valueT offset;

  offset = to_addr - (from_addr + 2);

  md_number_to_chars (ptr, (valueT) 0x6000, 2);
  md_number_to_chars (ptr + 2, (valueT) offset, 2);
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  valueT offset;

  if (!HAVE_LONG_BRANCH(current_architecture))
    {
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative branch to absolute jump"));
      offset = to_addr - S_GET_VALUE (to_symbol);
      md_number_to_chars (ptr, (valueT) 0x4EF9, 2);
      md_number_to_chars (ptr + 2, (valueT) offset, 4);
      fix_new (frag, (ptr + 2) - frag->fr_literal, 4, to_symbol, (offsetT) 0,
	       0, NO_RELOC);
    }
  else
    {
      offset = to_addr - (from_addr + 2);
      md_number_to_chars (ptr, (valueT) 0x60ff, 2);
      md_number_to_chars (ptr + 2, (valueT) offset, 4);
    }
}

#endif

/* Different values of OK tell what its OK to return.  Things that
   aren't OK are an error (what a shock, no?)

   0:  Everything is OK
   10:  Absolute 1:8	   only
   20:  Absolute 0:7	   only
   30:  absolute 0:15	   only
   40:  Absolute 0:31	   only
   50:  absolute 0:127	   only
   55:  absolute -64:63    only
   60:  absolute -128:127  only
   70:  absolute 0:4095	   only
   80:  absolute -1, 1:7   only
   90:  No bignums.          */

static int
get_num (exp, ok)
     struct m68k_exp *exp;
     int ok;
{
  if (exp->exp.X_op == O_absent)
    {
      /* Do the same thing the VAX asm does.  */
      op (exp) = O_constant;
      adds (exp) = 0;
      subs (exp) = 0;
      offs (exp) = 0;
      if (ok == 10)
	{
	  as_warn (_("expression out of range: defaulting to 1"));
	  offs (exp) = 1;
	}
    }
  else if (exp->exp.X_op == O_constant)
    {
      switch (ok)
	{
	case 10:
	  if (offs (exp) < 1 || offs (exp) > 8)
	    {
	      as_warn (_("expression out of range: defaulting to 1"));
	      offs (exp) = 1;
	    }
	  break;
	case 20:
	  if (offs (exp) < 0 || offs (exp) > 7)
	    goto outrange;
	  break;
	case 30:
	  if (offs (exp) < 0 || offs (exp) > 15)
	    goto outrange;
	  break;
	case 40:
	  if (offs (exp) < 0 || offs (exp) > 32)
	    goto outrange;
	  break;
	case 50:
	  if (offs (exp) < 0 || offs (exp) > 127)
	    goto outrange;
	  break;
	case 55:
	  if (offs (exp) < -64 || offs (exp) > 63)
	    goto outrange;
	  break;
	case 60:
	  if (offs (exp) < -128 || offs (exp) > 127)
	    goto outrange;
	  break;
	case 70:
	  if (offs (exp) < 0 || offs (exp) > 4095)
	    {
	    outrange:
	      as_warn (_("expression out of range: defaulting to 0"));
	      offs (exp) = 0;
	    }
	  break;
	case 80:
	  if (offs (exp) < -1
              || offs (exp) > 7
              || offs (exp) == 0)
	    {
	      as_warn (_("expression out of range: defaulting to 1"));
	      offs (exp) = 1;
	    }
	  break;
	default:
	  break;
	}
    }
  else if (exp->exp.X_op == O_big)
    {
      if (offs (exp) <= 0	/* flonum.  */
	  && (ok == 90		/* no bignums */
	      || (ok > 10	/* Small-int ranges including 0 ok.  */
		  /* If we have a flonum zero, a zero integer should
		     do as well (e.g., in moveq).  */
		  && generic_floating_point_number.exponent == 0
		  && generic_floating_point_number.low[0] == 0)))
	{
	  /* HACK! Turn it into a long.  */
	  LITTLENUM_TYPE words[6];

	  gen_to_words (words, 2, 8L);	/* These numbers are magic!  */
	  op (exp) = O_constant;
	  adds (exp) = 0;
	  subs (exp) = 0;
	  offs (exp) = words[1] | (words[0] << 16);
	}
      else if (ok != 0)
	{
	  op (exp) = O_constant;
	  adds (exp) = 0;
	  subs (exp) = 0;
	  offs (exp) = (ok == 10) ? 1 : 0;
	  as_warn (_("Can't deal with expression; defaulting to %ld"),
		   offs (exp));
	}
    }
  else
    {
      if (ok >= 10 && ok <= 80)
	{
	  op (exp) = O_constant;
	  adds (exp) = 0;
	  subs (exp) = 0;
	  offs (exp) = (ok == 10) ? 1 : 0;
	  as_warn (_("Can't deal with expression; defaulting to %ld"),
		   offs (exp));
	}
    }

  if (exp->size != SIZE_UNSPEC)
    {
      switch (exp->size)
	{
	case SIZE_UNSPEC:
	case SIZE_LONG:
	  break;
	case SIZE_BYTE:
	  if (!isbyte (offs (exp)))
	    as_warn (_("expression doesn't fit in BYTE"));
	  break;
	case SIZE_WORD:
	  if (!isword (offs (exp)))
	    as_warn (_("expression doesn't fit in WORD"));
	  break;
	}
    }

  return offs (exp);
}

/* These are the back-ends for the various machine dependent pseudo-ops.  */

static void
s_data1 (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  subseg_set (data_section, 1);
  demand_empty_rest_of_line ();
}

static void
s_data2 (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  subseg_set (data_section, 2);
  demand_empty_rest_of_line ();
}

static void
s_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* We don't support putting frags in the BSS segment, we fake it
     by marking in_bss, then looking at s_skip for clues.  */

  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();
}

static void
s_even (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  register int temp;
  register long temp_fill;

  temp = 1;			/* JF should be 2? */
  temp_fill = get_absolute_expression ();
  if (!need_pass_2)		/* Never make frag if expect extra pass.  */
    frag_align (temp, (int) temp_fill, 0);
  demand_empty_rest_of_line ();
  record_alignment (now_seg, temp);
}

static void
s_proc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  demand_empty_rest_of_line ();
}

/* Pseudo-ops handled for MRI compatibility.  */

/* This function returns non-zero if the argument is a conditional
   pseudo-op.  This is called when checking whether a pending
   alignment is needed.  */

int
m68k_conditional_pseudoop (pop)
     pseudo_typeS *pop;
{
  return (pop->poc_handler == s_mri_if
	  || pop->poc_handler == s_mri_else);
}

/* Handle an MRI style chip specification.  */

static void
mri_chip ()
{
  char *s;
  char c;
  int i;

  s = input_line_pointer;
  /* We can't use get_symbol_end since the processor names are not proper
     symbols.  */
  while (is_part_of_name (c = *input_line_pointer++))
    ;
  *--input_line_pointer = 0;
  for (i = 0; i < n_archs; i++)
    if (strcasecmp (s, archs[i].name) == 0)
      break;
  if (i >= n_archs)
    {
      as_bad (_("%s: unrecognized processor name"), s);
      *input_line_pointer = c;
      ignore_rest_of_line ();
      return;
    }
  *input_line_pointer = c;

  if (*input_line_pointer == '/')
    current_architecture = 0;
  else
    current_architecture &= m68881 | m68851;
  current_architecture |= archs[i].arch;

  while (*input_line_pointer == '/')
    {
      ++input_line_pointer;
      s = input_line_pointer;
      /* We can't use get_symbol_end since the processor names are not
	 proper symbols.  */
      while (is_part_of_name (c = *input_line_pointer++))
	;
      *--input_line_pointer = 0;
      if (strcmp (s, "68881") == 0)
	current_architecture |= m68881;
      else if (strcmp (s, "68851") == 0)
	current_architecture |= m68851;
      *input_line_pointer = c;
    }

  /* Update info about available control registers.  */
  select_control_regs ();
}

/* The MRI CHIP pseudo-op.  */

static void
s_chip (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *stop = NULL;
  char stopc;

  if (flag_mri)
    stop = mri_comment_field (&stopc);
  mri_chip ();
  if (flag_mri)
    mri_comment_end (stop, stopc);
  demand_empty_rest_of_line ();
}

/* The MRI FOPT pseudo-op.  */

static void
s_fopt (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  SKIP_WHITESPACE ();

  if (strncasecmp (input_line_pointer, "ID=", 3) == 0)
    {
      int temp;

      input_line_pointer += 3;
      temp = get_absolute_expression ();
      if (temp < 0 || temp > 7)
	as_bad (_("bad coprocessor id"));
      else
	m68k_float_copnum = COP0 + temp;
    }
  else
    {
      as_bad (_("unrecognized fopt option"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();
}

/* The structure used to handle the MRI OPT pseudo-op.  */

struct opt_action
{
  /* The name of the option.  */
  const char *name;

  /* If this is not NULL, just call this function.  The first argument
     is the ARG field of this structure, the second argument is
     whether the option was negated.  */
  void (*pfn) PARAMS ((int arg, int on));

  /* If this is not NULL, and the PFN field is NULL, set the variable
     this points to.  Set it to the ARG field if the option was not
     negated, and the NOTARG field otherwise.  */
  int *pvar;

  /* The value to pass to PFN or to assign to *PVAR.  */
  int arg;

  /* The value to assign to *PVAR if the option is negated.  If PFN is
     NULL, and PVAR is not NULL, and ARG and NOTARG are the same, then
     the option may not be negated.  */
  int notarg;
};

/* The table used to handle the MRI OPT pseudo-op.  */

static void skip_to_comma PARAMS ((int, int));
static void opt_nest PARAMS ((int, int));
static void opt_chip PARAMS ((int, int));
static void opt_list PARAMS ((int, int));
static void opt_list_symbols PARAMS ((int, int));

static const struct opt_action opt_table[] =
{
  { "abspcadd", 0, &m68k_abspcadd, 1, 0 },

  /* We do relaxing, so there is little use for these options.  */
  { "b", 0, 0, 0, 0 },
  { "brs", 0, 0, 0, 0 },
  { "brb", 0, 0, 0, 0 },
  { "brl", 0, 0, 0, 0 },
  { "brw", 0, 0, 0, 0 },

  { "c", 0, 0, 0, 0 },
  { "cex", 0, 0, 0, 0 },
  { "case", 0, &symbols_case_sensitive, 1, 0 },
  { "cl", 0, 0, 0, 0 },
  { "cre", 0, 0, 0, 0 },
  { "d", 0, &flag_keep_locals, 1, 0 },
  { "e", 0, 0, 0, 0 },
  { "f", 0, &flag_short_refs, 1, 0 },
  { "frs", 0, &flag_short_refs, 1, 0 },
  { "frl", 0, &flag_short_refs, 0, 1 },
  { "g", 0, 0, 0, 0 },
  { "i", 0, 0, 0, 0 },
  { "m", 0, 0, 0, 0 },
  { "mex", 0, 0, 0, 0 },
  { "mc", 0, 0, 0, 0 },
  { "md", 0, 0, 0, 0 },
  { "nest", opt_nest, 0, 0, 0 },
  { "next", skip_to_comma, 0, 0, 0 },
  { "o", 0, 0, 0, 0 },
  { "old", 0, 0, 0, 0 },
  { "op", skip_to_comma, 0, 0, 0 },
  { "pco", 0, 0, 0, 0 },
  { "p", opt_chip, 0, 0, 0 },
  { "pcr", 0, 0, 0, 0 },
  { "pcs", 0, 0, 0, 0 },
  { "r", 0, 0, 0, 0 },
  { "quick", 0, &m68k_quick, 1, 0 },
  { "rel32", 0, &m68k_rel32, 1, 0 },
  { "s", opt_list, 0, 0, 0 },
  { "t", opt_list_symbols, 0, 0, 0 },
  { "w", 0, &flag_no_warnings, 0, 1 },
  { "x", 0, 0, 0, 0 }
};

#define OPTCOUNT ((int) (sizeof opt_table / sizeof opt_table[0]))

/* The MRI OPT pseudo-op.  */

static void
s_opt (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  do
    {
      int t;
      char *s;
      char c;
      int i;
      const struct opt_action *o;

      SKIP_WHITESPACE ();

      t = 1;
      if (*input_line_pointer == '-')
	{
	  ++input_line_pointer;
	  t = 0;
	}
      else if (strncasecmp (input_line_pointer, "NO", 2) == 0)
	{
	  input_line_pointer += 2;
	  t = 0;
	}

      s = input_line_pointer;
      c = get_symbol_end ();

      for (i = 0, o = opt_table; i < OPTCOUNT; i++, o++)
	{
	  if (strcasecmp (s, o->name) == 0)
	    {
	      if (o->pfn)
		{
		  /* Restore input_line_pointer now in case the option
		     takes arguments.  */
		  *input_line_pointer = c;
		  (*o->pfn) (o->arg, t);
		}
	      else if (o->pvar != NULL)
		{
		  if (! t && o->arg == o->notarg)
		    as_bad (_("option `%s' may not be negated"), s);
		  *input_line_pointer = c;
		  *o->pvar = t ? o->arg : o->notarg;
		}
	      else
		*input_line_pointer = c;
	      break;
	    }
	}
      if (i >= OPTCOUNT)
	{
	  as_bad (_("option `%s' not recognized"), s);
	  *input_line_pointer = c;
	}
    }
  while (*input_line_pointer++ == ',');

  /* Move back to terminating character.  */
  --input_line_pointer;
  demand_empty_rest_of_line ();
}

/* Skip ahead to a comma.  This is used for OPT options which we do
   not support and which take arguments.  */

static void
skip_to_comma (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on ATTRIBUTE_UNUSED;
{
  while (*input_line_pointer != ','
	 && ! is_end_of_line[(unsigned char) *input_line_pointer])
    ++input_line_pointer;
}

/* Handle the OPT NEST=depth option.  */

static void
opt_nest (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on ATTRIBUTE_UNUSED;
{
  if (*input_line_pointer != '=')
    {
      as_bad (_("bad format of OPT NEST=depth"));
      return;
    }

  ++input_line_pointer;
  max_macro_nest = get_absolute_expression ();
}

/* Handle the OPT P=chip option.  */

static void
opt_chip (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on ATTRIBUTE_UNUSED;
{
  if (*input_line_pointer != '=')
    {
      /* This is just OPT P, which we do not support.  */
      return;
    }

  ++input_line_pointer;
  mri_chip ();
}

/* Handle the OPT S option.  */

static void
opt_list (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on;
{
  listing_list (on);
}

/* Handle the OPT T option.  */

static void
opt_list_symbols (arg, on)
     int arg ATTRIBUTE_UNUSED;
     int on;
{
  if (on)
    listing |= LISTING_SYMBOLS;
  else
    listing &= ~LISTING_SYMBOLS;
}

/* Handle the MRI REG pseudo-op.  */

static void
s_reg (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *s;
  int c;
  struct m68k_op rop;
  int mask;
  char *stop = NULL;
  char stopc;

  if (line_label == NULL)
    {
      as_bad (_("missing label"));
      ignore_rest_of_line ();
      return;
    }

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  SKIP_WHITESPACE ();

  s = input_line_pointer;
  while (ISALNUM (*input_line_pointer)
#ifdef REGISTER_PREFIX
	 || *input_line_pointer == REGISTER_PREFIX
#endif
	 || *input_line_pointer == '/'
	 || *input_line_pointer == '-')
    ++input_line_pointer;
  c = *input_line_pointer;
  *input_line_pointer = '\0';

  if (m68k_ip_op (s, &rop) != 0)
    {
      if (rop.error == NULL)
	as_bad (_("bad register list"));
      else
	as_bad (_("bad register list: %s"), rop.error);
      *input_line_pointer = c;
      ignore_rest_of_line ();
      return;
    }

  *input_line_pointer = c;

  if (rop.mode == REGLST)
    mask = rop.mask;
  else if (rop.mode == DREG)
    mask = 1 << (rop.reg - DATA0);
  else if (rop.mode == AREG)
    mask = 1 << (rop.reg - ADDR0 + 8);
  else if (rop.mode == FPREG)
    mask = 1 << (rop.reg - FP0 + 16);
  else if (rop.mode == CONTROL
	   && rop.reg == FPI)
    mask = 1 << 24;
  else if (rop.mode == CONTROL
	   && rop.reg == FPS)
    mask = 1 << 25;
  else if (rop.mode == CONTROL
	   && rop.reg == FPC)
    mask = 1 << 26;
  else
    {
      as_bad (_("bad register list"));
      ignore_rest_of_line ();
      return;
    }

  S_SET_SEGMENT (line_label, reg_section);
  S_SET_VALUE (line_label, ~mask);
  symbol_set_frag (line_label, &zero_address_frag);

  if (flag_mri)
    mri_comment_end (stop, stopc);

  demand_empty_rest_of_line ();
}

/* This structure is used for the MRI SAVE and RESTORE pseudo-ops.  */

struct save_opts
{
  struct save_opts *next;
  int abspcadd;
  int symbols_case_sensitive;
  int keep_locals;
  int short_refs;
  int architecture;
  int quick;
  int rel32;
  int listing;
  int no_warnings;
  /* FIXME: We don't save OPT S.  */
};

/* This variable holds the stack of saved options.  */

static struct save_opts *save_stack;

/* The MRI SAVE pseudo-op.  */

static void
s_save (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  struct save_opts *s;

  s = (struct save_opts *) xmalloc (sizeof (struct save_opts));
  s->abspcadd = m68k_abspcadd;
  s->symbols_case_sensitive = symbols_case_sensitive;
  s->keep_locals = flag_keep_locals;
  s->short_refs = flag_short_refs;
  s->architecture = current_architecture;
  s->quick = m68k_quick;
  s->rel32 = m68k_rel32;
  s->listing = listing;
  s->no_warnings = flag_no_warnings;

  s->next = save_stack;
  save_stack = s;

  demand_empty_rest_of_line ();
}

/* The MRI RESTORE pseudo-op.  */

static void
s_restore (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  struct save_opts *s;

  if (save_stack == NULL)
    {
      as_bad (_("restore without save"));
      ignore_rest_of_line ();
      return;
    }

  s = save_stack;
  save_stack = s->next;

  m68k_abspcadd = s->abspcadd;
  symbols_case_sensitive = s->symbols_case_sensitive;
  flag_keep_locals = s->keep_locals;
  flag_short_refs = s->short_refs;
  current_architecture = s->architecture;
  m68k_quick = s->quick;
  m68k_rel32 = s->rel32;
  listing = s->listing;
  flag_no_warnings = s->no_warnings;

  free (s);

  demand_empty_rest_of_line ();
}

/* Types of MRI structured control directives.  */

enum mri_control_type
{
  mri_for,
  mri_if,
  mri_repeat,
  mri_while
};

/* This structure is used to stack the MRI structured control
   directives.  */

struct mri_control_info
{
  /* The directive within which this one is enclosed.  */
  struct mri_control_info *outer;

  /* The type of directive.  */
  enum mri_control_type type;

  /* Whether an ELSE has been in an IF.  */
  int else_seen;

  /* The add or sub statement at the end of a FOR.  */
  char *incr;

  /* The label of the top of a FOR or REPEAT loop.  */
  char *top;

  /* The label to jump to for the next iteration, or the else
     expression of a conditional.  */
  char *next;

  /* The label to jump to to break out of the loop, or the label past
     the end of a conditional.  */
  char *bottom;
};

/* The stack of MRI structured control directives.  */

static struct mri_control_info *mri_control_stack;

/* The current MRI structured control directive index number, used to
   generate label names.  */

static int mri_control_index;

/* Some function prototypes.  */

static void mri_assemble PARAMS ((char *));
static char *mri_control_label PARAMS ((void));
static struct mri_control_info *push_mri_control
  PARAMS ((enum mri_control_type));
static void pop_mri_control PARAMS ((void));
static int parse_mri_condition PARAMS ((int *));
static int parse_mri_control_operand
  PARAMS ((int *, char **, char **, char **, char **));
static int swap_mri_condition PARAMS ((int));
static int reverse_mri_condition PARAMS ((int));
static void build_mri_control_operand
  PARAMS ((int, int, char *, char *, char *, char *, const char *,
	   const char *, int));
static void parse_mri_control_expression
  PARAMS ((char *, int, const char *, const char *, int));

/* Assemble an instruction for an MRI structured control directive.  */

static void
mri_assemble (str)
     char *str;
{
  char *s;

  /* md_assemble expects the opcode to be in lower case.  */
  for (s = str; *s != ' ' && *s != '\0'; s++)
    *s = TOLOWER (*s);

  md_assemble (str);
}

/* Generate a new MRI label structured control directive label name.  */

static char *
mri_control_label ()
{
  char *n;

  n = (char *) xmalloc (20);
  sprintf (n, "%smc%d", FAKE_LABEL_NAME, mri_control_index);
  ++mri_control_index;
  return n;
}

/* Create a new MRI structured control directive.  */

static struct mri_control_info *
push_mri_control (type)
     enum mri_control_type type;
{
  struct mri_control_info *n;

  n = (struct mri_control_info *) xmalloc (sizeof (struct mri_control_info));

  n->type = type;
  n->else_seen = 0;
  if (type == mri_if || type == mri_while)
    n->top = NULL;
  else
    n->top = mri_control_label ();
  n->next = mri_control_label ();
  n->bottom = mri_control_label ();

  n->outer = mri_control_stack;
  mri_control_stack = n;

  return n;
}

/* Pop off the stack of MRI structured control directives.  */

static void
pop_mri_control ()
{
  struct mri_control_info *n;

  n = mri_control_stack;
  mri_control_stack = n->outer;
  if (n->top != NULL)
    free (n->top);
  free (n->next);
  free (n->bottom);
  free (n);
}

/* Recognize a condition code in an MRI structured control expression.  */

static int
parse_mri_condition (pcc)
     int *pcc;
{
  char c1, c2;

  know (*input_line_pointer == '<');

  ++input_line_pointer;
  c1 = *input_line_pointer++;
  c2 = *input_line_pointer++;

  if (*input_line_pointer != '>')
    {
      as_bad (_("syntax error in structured control directive"));
      return 0;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  c1 = TOLOWER (c1);
  c2 = TOLOWER (c2);

  *pcc = (c1 << 8) | c2;

  return 1;
}

/* Parse a single operand in an MRI structured control expression.  */

static int
parse_mri_control_operand (pcc, leftstart, leftstop, rightstart, rightstop)
     int *pcc;
     char **leftstart;
     char **leftstop;
     char **rightstart;
     char **rightstop;
{
  char *s;

  SKIP_WHITESPACE ();

  *pcc = -1;
  *leftstart = NULL;
  *leftstop = NULL;
  *rightstart = NULL;
  *rightstop = NULL;

  if (*input_line_pointer == '<')
    {
      /* It's just a condition code.  */
      return parse_mri_condition (pcc);
    }

  /* Look ahead for the condition code.  */
  for (s = input_line_pointer; *s != '\0'; ++s)
    {
      if (*s == '<' && s[1] != '\0' && s[2] != '\0' && s[3] == '>')
	break;
    }
  if (*s == '\0')
    {
      as_bad (_("missing condition code in structured control directive"));
      return 0;
    }

  *leftstart = input_line_pointer;
  *leftstop = s;
  if (*leftstop > *leftstart
      && ((*leftstop)[-1] == ' ' || (*leftstop)[-1] == '\t'))
    --*leftstop;

  input_line_pointer = s;
  if (! parse_mri_condition (pcc))
    return 0;

  /* Look ahead for AND or OR or end of line.  */
  for (s = input_line_pointer; *s != '\0'; ++s)
    {
      /* We must make sure we don't misinterpret AND/OR at the end of labels!
         if d0 <eq> #FOOAND and d1 <ne> #BAROR then
                        ^^^                 ^^ */
      if ((s == input_line_pointer
	   || *(s-1) == ' '
	   || *(s-1) == '\t')
	  && ((strncasecmp (s, "AND", 3) == 0
	       && (s[3] == '.' || ! is_part_of_name (s[3])))
	      || (strncasecmp (s, "OR", 2) == 0
		  && (s[2] == '.' || ! is_part_of_name (s[2])))))
	break;
    }

  *rightstart = input_line_pointer;
  *rightstop = s;
  if (*rightstop > *rightstart
      && ((*rightstop)[-1] == ' ' || (*rightstop)[-1] == '\t'))
    --*rightstop;

  input_line_pointer = s;

  return 1;
}

#define MCC(b1, b2) (((b1) << 8) | (b2))

/* Swap the sense of a condition.  This changes the condition so that
   it generates the same result when the operands are swapped.  */

static int
swap_mri_condition (cc)
     int cc;
{
  switch (cc)
    {
    case MCC ('h', 'i'): return MCC ('c', 's');
    case MCC ('l', 's'): return MCC ('c', 'c');
    /* <HS> is an alias for <CC>.  */
    case MCC ('h', 's'):
    case MCC ('c', 'c'): return MCC ('l', 's');
    /* <LO> is an alias for <CS>.  */
    case MCC ('l', 'o'):
    case MCC ('c', 's'): return MCC ('h', 'i');
    case MCC ('p', 'l'): return MCC ('m', 'i');
    case MCC ('m', 'i'): return MCC ('p', 'l');
    case MCC ('g', 'e'): return MCC ('l', 'e');
    case MCC ('l', 't'): return MCC ('g', 't');
    case MCC ('g', 't'): return MCC ('l', 't');
    case MCC ('l', 'e'): return MCC ('g', 'e');
    /* Issue a warning for conditions we can not swap.  */
    case MCC ('n', 'e'): return MCC ('n', 'e'); // no problem here
    case MCC ('e', 'q'): return MCC ('e', 'q'); // also no problem
    case MCC ('v', 'c'):
    case MCC ('v', 's'):
    default :
	   as_warn (_("Condition <%c%c> in structured control directive can not be encoded correctly"),
		         (char) (cc >> 8), (char) (cc));
      break;
    }
  return cc;
}

/* Reverse the sense of a condition.  */

static int
reverse_mri_condition (cc)
     int cc;
{
  switch (cc)
    {
    case MCC ('h', 'i'): return MCC ('l', 's');
    case MCC ('l', 's'): return MCC ('h', 'i');
    /* <HS> is an alias for <CC> */
    case MCC ('h', 's'): return MCC ('l', 'o');
    case MCC ('c', 'c'): return MCC ('c', 's');
    /* <LO> is an alias for <CS> */
    case MCC ('l', 'o'): return MCC ('h', 's');
    case MCC ('c', 's'): return MCC ('c', 'c');
    case MCC ('n', 'e'): return MCC ('e', 'q');
    case MCC ('e', 'q'): return MCC ('n', 'e');
    case MCC ('v', 'c'): return MCC ('v', 's');
    case MCC ('v', 's'): return MCC ('v', 'c');
    case MCC ('p', 'l'): return MCC ('m', 'i');
    case MCC ('m', 'i'): return MCC ('p', 'l');
    case MCC ('g', 'e'): return MCC ('l', 't');
    case MCC ('l', 't'): return MCC ('g', 'e');
    case MCC ('g', 't'): return MCC ('l', 'e');
    case MCC ('l', 'e'): return MCC ('g', 't');
    }
  return cc;
}

/* Build an MRI structured control expression.  This generates test
   and branch instructions.  It goes to TRUELAB if the condition is
   true, and to FALSELAB if the condition is false.  Exactly one of
   TRUELAB and FALSELAB will be NULL, meaning to fall through.  QUAL
   is the size qualifier for the expression.  EXTENT is the size to
   use for the branch.  */

static void
build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
			   rightstop, truelab, falselab, extent)
     int qual;
     int cc;
     char *leftstart;
     char *leftstop;
     char *rightstart;
     char *rightstop;
     const char *truelab;
     const char *falselab;
     int extent;
{
  char *buf;
  char *s;

  if (leftstart != NULL)
    {
      struct m68k_op leftop, rightop;
      char c;

      /* Swap the compare operands, if necessary, to produce a legal
	 m68k compare instruction.  Comparing a register operand with
	 a non-register operand requires the register to be on the
	 right (cmp, cmpa).  Comparing an immediate value with
	 anything requires the immediate value to be on the left
	 (cmpi).  */

      c = *leftstop;
      *leftstop = '\0';
      (void) m68k_ip_op (leftstart, &leftop);
      *leftstop = c;

      c = *rightstop;
      *rightstop = '\0';
      (void) m68k_ip_op (rightstart, &rightop);
      *rightstop = c;

      if (rightop.mode == IMMED
	  || ((leftop.mode == DREG || leftop.mode == AREG)
	      && (rightop.mode != DREG && rightop.mode != AREG)))
	{
	  char *temp;

     /* Correct conditional handling:
        if #1 <lt> d0 then  ;means if (1 < d0)
           ...
        endi

        should assemble to:

         cmp #1,d0        if we do *not* swap the operands
         bgt true         we need the swapped condition!
         ble false
        true:
         ...
        false:
     */
	  temp = leftstart;
	  leftstart = rightstart;
	  rightstart = temp;
	  temp = leftstop;
	  leftstop = rightstop;
	  rightstop = temp;
	}
      else
	{
	  cc = swap_mri_condition (cc);
	}
    }

  if (truelab == NULL)
    {
      cc = reverse_mri_condition (cc);
      truelab = falselab;
    }

  if (leftstart != NULL)
    {
      buf = (char *) xmalloc (20
			      + (leftstop - leftstart)
			      + (rightstop - rightstart));
      s = buf;
      *s++ = 'c';
      *s++ = 'm';
      *s++ = 'p';
      if (qual != '\0')
	*s++ = TOLOWER (qual);
      *s++ = ' ';
      memcpy (s, leftstart, leftstop - leftstart);
      s += leftstop - leftstart;
      *s++ = ',';
      memcpy (s, rightstart, rightstop - rightstart);
      s += rightstop - rightstart;
      *s = '\0';
      mri_assemble (buf);
      free (buf);
    }

  buf = (char *) xmalloc (20 + strlen (truelab));
  s = buf;
  *s++ = 'b';
  *s++ = cc >> 8;
  *s++ = cc & 0xff;
  if (extent != '\0')
    *s++ = TOLOWER (extent);
  *s++ = ' ';
  strcpy (s, truelab);
  mri_assemble (buf);
  free (buf);
}

/* Parse an MRI structured control expression.  This generates test
   and branch instructions.  STOP is where the expression ends.  It
   goes to TRUELAB if the condition is true, and to FALSELAB if the
   condition is false.  Exactly one of TRUELAB and FALSELAB will be
   NULL, meaning to fall through.  QUAL is the size qualifier for the
   expression.  EXTENT is the size to use for the branch.  */

static void
parse_mri_control_expression (stop, qual, truelab, falselab, extent)
     char *stop;
     int qual;
     const char *truelab;
     const char *falselab;
     int extent;
{
  int c;
  int cc;
  char *leftstart;
  char *leftstop;
  char *rightstart;
  char *rightstop;

  c = *stop;
  *stop = '\0';

  if (! parse_mri_control_operand (&cc, &leftstart, &leftstop,
				   &rightstart, &rightstop))
    {
      *stop = c;
      return;
    }

  if (strncasecmp (input_line_pointer, "AND", 3) == 0)
    {
      const char *flab;

      if (falselab != NULL)
	flab = falselab;
      else
	flab = mri_control_label ();

      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, (const char *) NULL, flab, extent);

      input_line_pointer += 3;
      if (*input_line_pointer != '.'
	  || input_line_pointer[1] == '\0')
	qual = '\0';
      else
	{
	  qual = input_line_pointer[1];
	  input_line_pointer += 2;
	}

      if (! parse_mri_control_operand (&cc, &leftstart, &leftstop,
				       &rightstart, &rightstop))
	{
	  *stop = c;
	  return;
	}

      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, truelab, falselab, extent);

      if (falselab == NULL)
	colon (flab);
    }
  else if (strncasecmp (input_line_pointer, "OR", 2) == 0)
    {
      const char *tlab;

      if (truelab != NULL)
	tlab = truelab;
      else
	tlab = mri_control_label ();

      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, tlab, (const char *) NULL, extent);

      input_line_pointer += 2;
      if (*input_line_pointer != '.'
	  || input_line_pointer[1] == '\0')
	qual = '\0';
      else
	{
	  qual = input_line_pointer[1];
	  input_line_pointer += 2;
	}

      if (! parse_mri_control_operand (&cc, &leftstart, &leftstop,
				       &rightstart, &rightstop))
	{
	  *stop = c;
	  return;
	}

      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, truelab, falselab, extent);

      if (truelab == NULL)
	colon (tlab);
    }
  else
    {
      build_mri_control_operand (qual, cc, leftstart, leftstop, rightstart,
				 rightstop, truelab, falselab, extent);
    }

  *stop = c;
  if (input_line_pointer != stop)
    as_bad (_("syntax error in structured control directive"));
}

/* Handle the MRI IF pseudo-op.  This may be a structured control
   directive, or it may be a regular assembler conditional, depending
   on its operands.  */

static void
s_mri_if (qual)
     int qual;
{
  char *s;
  int c;
  struct mri_control_info *n;

  /* A structured control directive must end with THEN with an
     optional qualifier.  */
  s = input_line_pointer;
  /* We only accept '*' as introduction of comments if preceded by white space
     or at first column of a line (I think this can't actually happen here?)
     This is important when assembling:
       if d0 <ne> 12(a0,d0*2) then
       if d0 <ne> #CONST*20   then.  */
  while ( ! (    is_end_of_line[(unsigned char) *s]
              || (     flag_mri
                   && *s == '*'
                   && (    s == input_line_pointer
                        || *(s-1) == ' '
                        || *(s-1) == '\t'))))
    ++s;
  --s;
  while (s > input_line_pointer && (*s == ' ' || *s == '\t'))
    --s;

  if (s - input_line_pointer > 1
      && s[-1] == '.')
    s -= 2;

  if (s - input_line_pointer < 3
      || strncasecmp (s - 3, "THEN", 4) != 0)
    {
      if (qual != '\0')
	{
	  as_bad (_("missing then"));
	  ignore_rest_of_line ();
	  return;
	}

      /* It's a conditional.  */
      s_if (O_ne);
      return;
    }

  /* Since this might be a conditional if, this pseudo-op will be
     called even if we are supported to be ignoring input.  Double
     check now.  Clobber *input_line_pointer so that ignore_input
     thinks that this is not a special pseudo-op.  */
  c = *input_line_pointer;
  *input_line_pointer = 0;
  if (ignore_input ())
    {
      *input_line_pointer = c;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
  *input_line_pointer = c;

  n = push_mri_control (mri_if);

  parse_mri_control_expression (s - 3, qual, (const char *) NULL,
				n->next, s[1] == '.' ? s[2] : '\0');

  if (s[1] == '.')
    input_line_pointer = s + 3;
  else
    input_line_pointer = s + 1;

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI else pseudo-op.  If we are currently doing an MRI
   structured IF, associate the ELSE with the IF.  Otherwise, assume
   it is a conditional else.  */

static void
s_mri_else (qual)
     int qual;
{
  int c;
  char *buf;
  char q[2];

  if (qual == '\0'
      && (mri_control_stack == NULL
	  || mri_control_stack->type != mri_if
	  || mri_control_stack->else_seen))
    {
      s_else (0);
      return;
    }

  c = *input_line_pointer;
  *input_line_pointer = 0;
  if (ignore_input ())
    {
      *input_line_pointer = c;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
  *input_line_pointer = c;

  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_if
      || mri_control_stack->else_seen)
    {
      as_bad (_("else without matching if"));
      ignore_rest_of_line ();
      return;
    }

  mri_control_stack->else_seen = 1;

  buf = (char *) xmalloc (20 + strlen (mri_control_stack->bottom));
  q[0] = TOLOWER (qual);
  q[1] = '\0';
  sprintf (buf, "bra%s %s", q, mri_control_stack->bottom);
  mri_assemble (buf);
  free (buf);

  colon (mri_control_stack->next);

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI ENDI pseudo-op.  */

static void
s_mri_endi (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_if)
    {
      as_bad (_("endi without matching if"));
      ignore_rest_of_line ();
      return;
    }

  /* ignore_input will not return true for ENDI, so we don't need to
     worry about checking it again here.  */

  if (! mri_control_stack->else_seen)
    colon (mri_control_stack->next);
  colon (mri_control_stack->bottom);

  pop_mri_control ();

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI BREAK pseudo-op.  */

static void
s_mri_break (extent)
     int extent;
{
  struct mri_control_info *n;
  char *buf;
  char ex[2];

  n = mri_control_stack;
  while (n != NULL
	 && n->type != mri_for
	 && n->type != mri_repeat
	 && n->type != mri_while)
    n = n->outer;
  if (n == NULL)
    {
      as_bad (_("break outside of structured loop"));
      ignore_rest_of_line ();
      return;
    }

  buf = (char *) xmalloc (20 + strlen (n->bottom));
  ex[0] = TOLOWER (extent);
  ex[1] = '\0';
  sprintf (buf, "bra%s %s", ex, n->bottom);
  mri_assemble (buf);
  free (buf);

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI NEXT pseudo-op.  */

static void
s_mri_next (extent)
     int extent;
{
  struct mri_control_info *n;
  char *buf;
  char ex[2];

  n = mri_control_stack;
  while (n != NULL
	 && n->type != mri_for
	 && n->type != mri_repeat
	 && n->type != mri_while)
    n = n->outer;
  if (n == NULL)
    {
      as_bad (_("next outside of structured loop"));
      ignore_rest_of_line ();
      return;
    }

  buf = (char *) xmalloc (20 + strlen (n->next));
  ex[0] = TOLOWER (extent);
  ex[1] = '\0';
  sprintf (buf, "bra%s %s", ex, n->next);
  mri_assemble (buf);
  free (buf);

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI FOR pseudo-op.  */

static void
s_mri_for (qual)
     int qual;
{
  const char *varstart, *varstop;
  const char *initstart, *initstop;
  const char *endstart, *endstop;
  const char *bystart, *bystop;
  int up;
  int by;
  int extent;
  struct mri_control_info *n;
  char *buf;
  char *s;
  char ex[2];

  /* The syntax is
       FOR.q var = init { TO | DOWNTO } end [ BY by ] DO.e
     */

  SKIP_WHITESPACE ();
  varstart = input_line_pointer;

  /* Look for the '='.  */
  while (! is_end_of_line[(unsigned char) *input_line_pointer]
	 && *input_line_pointer != '=')
    ++input_line_pointer;
  if (*input_line_pointer != '=')
    {
      as_bad (_("missing ="));
      ignore_rest_of_line ();
      return;
    }

  varstop = input_line_pointer;
  if (varstop > varstart
      && (varstop[-1] == ' ' || varstop[-1] == '\t'))
    --varstop;

  ++input_line_pointer;

  initstart = input_line_pointer;

  /* Look for TO or DOWNTO.  */
  up = 1;
  initstop = NULL;
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
    {
      if (strncasecmp (input_line_pointer, "TO", 2) == 0
	  && ! is_part_of_name (input_line_pointer[2]))
	{
	  initstop = input_line_pointer;
	  input_line_pointer += 2;
	  break;
	}
      if (strncasecmp (input_line_pointer, "DOWNTO", 6) == 0
	  && ! is_part_of_name (input_line_pointer[6]))
	{
	  initstop = input_line_pointer;
	  up = 0;
	  input_line_pointer += 6;
	  break;
	}
      ++input_line_pointer;
    }
  if (initstop == NULL)
    {
      as_bad (_("missing to or downto"));
      ignore_rest_of_line ();
      return;
    }
  if (initstop > initstart
      && (initstop[-1] == ' ' || initstop[-1] == '\t'))
    --initstop;

  SKIP_WHITESPACE ();
  endstart = input_line_pointer;

  /* Look for BY or DO.  */
  by = 0;
  endstop = NULL;
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
    {
      if (strncasecmp (input_line_pointer, "BY", 2) == 0
	  && ! is_part_of_name (input_line_pointer[2]))
	{
	  endstop = input_line_pointer;
	  by = 1;
	  input_line_pointer += 2;
	  break;
	}
      if (strncasecmp (input_line_pointer, "DO", 2) == 0
	  && (input_line_pointer[2] == '.'
	      || ! is_part_of_name (input_line_pointer[2])))
	{
	  endstop = input_line_pointer;
	  input_line_pointer += 2;
	  break;
	}
      ++input_line_pointer;
    }
  if (endstop == NULL)
    {
      as_bad (_("missing do"));
      ignore_rest_of_line ();
      return;
    }
  if (endstop > endstart
      && (endstop[-1] == ' ' || endstop[-1] == '\t'))
    --endstop;

  if (! by)
    {
      bystart = "#1";
      bystop = bystart + 2;
    }
  else
    {
      SKIP_WHITESPACE ();
      bystart = input_line_pointer;

      /* Look for DO.  */
      bystop = NULL;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	{
	  if (strncasecmp (input_line_pointer, "DO", 2) == 0
	      && (input_line_pointer[2] == '.'
		  || ! is_part_of_name (input_line_pointer[2])))
	    {
	      bystop = input_line_pointer;
	      input_line_pointer += 2;
	      break;
	    }
	  ++input_line_pointer;
	}
      if (bystop == NULL)
	{
	  as_bad (_("missing do"));
	  ignore_rest_of_line ();
	  return;
	}
      if (bystop > bystart
	  && (bystop[-1] == ' ' || bystop[-1] == '\t'))
	--bystop;
    }

  if (*input_line_pointer != '.')
    extent = '\0';
  else
    {
      extent = input_line_pointer[1];
      input_line_pointer += 2;
    }

  /* We have fully parsed the FOR operands.  Now build the loop.  */
  n = push_mri_control (mri_for);

  buf = (char *) xmalloc (50 + (input_line_pointer - varstart));

  /* Move init,var.  */
  s = buf;
  *s++ = 'm';
  *s++ = 'o';
  *s++ = 'v';
  *s++ = 'e';
  if (qual != '\0')
    *s++ = TOLOWER (qual);
  *s++ = ' ';
  memcpy (s, initstart, initstop - initstart);
  s += initstop - initstart;
  *s++ = ',';
  memcpy (s, varstart, varstop - varstart);
  s += varstop - varstart;
  *s = '\0';
  mri_assemble (buf);

  colon (n->top);

  /* cmp end,var.  */
  s = buf;
  *s++ = 'c';
  *s++ = 'm';
  *s++ = 'p';
  if (qual != '\0')
    *s++ = TOLOWER (qual);
  *s++ = ' ';
  memcpy (s, endstart, endstop - endstart);
  s += endstop - endstart;
  *s++ = ',';
  memcpy (s, varstart, varstop - varstart);
  s += varstop - varstart;
  *s = '\0';
  mri_assemble (buf);

  /* bcc bottom.  */
  ex[0] = TOLOWER (extent);
  ex[1] = '\0';
  if (up)
    sprintf (buf, "blt%s %s", ex, n->bottom);
  else
    sprintf (buf, "bgt%s %s", ex, n->bottom);
  mri_assemble (buf);

  /* Put together the add or sub instruction used by ENDF.  */
  s = buf;
  if (up)
    strcpy (s, "add");
  else
    strcpy (s, "sub");
  s += 3;
  if (qual != '\0')
    *s++ = TOLOWER (qual);
  *s++ = ' ';
  memcpy (s, bystart, bystop - bystart);
  s += bystop - bystart;
  *s++ = ',';
  memcpy (s, varstart, varstop - varstart);
  s += varstop - varstart;
  *s = '\0';
  n->incr = buf;

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI ENDF pseudo-op.  */

static void
s_mri_endf (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_for)
    {
      as_bad (_("endf without for"));
      ignore_rest_of_line ();
      return;
    }

  colon (mri_control_stack->next);

  mri_assemble (mri_control_stack->incr);

  sprintf (mri_control_stack->incr, "bra %s", mri_control_stack->top);
  mri_assemble (mri_control_stack->incr);

  free (mri_control_stack->incr);

  colon (mri_control_stack->bottom);

  pop_mri_control ();

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI REPEAT pseudo-op.  */

static void
s_mri_repeat (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  struct mri_control_info *n;

  n = push_mri_control (mri_repeat);
  colon (n->top);
  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }
  demand_empty_rest_of_line ();
}

/* Handle the MRI UNTIL pseudo-op.  */

static void
s_mri_until (qual)
     int qual;
{
  char *s;

  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_repeat)
    {
      as_bad (_("until without repeat"));
      ignore_rest_of_line ();
      return;
    }

  colon (mri_control_stack->next);

  for (s = input_line_pointer; ! is_end_of_line[(unsigned char) *s]; s++)
    ;

  parse_mri_control_expression (s, qual, (const char *) NULL,
				mri_control_stack->top, '\0');

  colon (mri_control_stack->bottom);

  input_line_pointer = s;

  pop_mri_control ();

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI WHILE pseudo-op.  */

static void
s_mri_while (qual)
     int qual;
{
  char *s;

  struct mri_control_info *n;

  s = input_line_pointer;
  /* We only accept '*' as introduction of comments if preceded by white space
     or at first column of a line (I think this can't actually happen here?)
     This is important when assembling:
       while d0 <ne> 12(a0,d0*2) do
       while d0 <ne> #CONST*20   do.  */
  while (! (is_end_of_line[(unsigned char) *s]
	    || (flag_mri
		&& *s == '*'
		&& (s == input_line_pointer
		    || *(s-1) == ' '
		    || *(s-1) == '\t'))))
    s++;
  --s;
  while (*s == ' ' || *s == '\t')
    --s;
  if (s - input_line_pointer > 1
      && s[-1] == '.')
    s -= 2;
  if (s - input_line_pointer < 2
      || strncasecmp (s - 1, "DO", 2) != 0)
    {
      as_bad (_("missing do"));
      ignore_rest_of_line ();
      return;
    }

  n = push_mri_control (mri_while);

  colon (n->next);

  parse_mri_control_expression (s - 1, qual, (const char *) NULL, n->bottom,
				s[1] == '.' ? s[2] : '\0');

  input_line_pointer = s + 1;
  if (*input_line_pointer == '.')
    input_line_pointer += 2;

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* Handle the MRI ENDW pseudo-op.  */

static void
s_mri_endw (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *buf;

  if (mri_control_stack == NULL
      || mri_control_stack->type != mri_while)
    {
      as_bad (_("endw without while"));
      ignore_rest_of_line ();
      return;
    }

  buf = (char *) xmalloc (20 + strlen (mri_control_stack->next));
  sprintf (buf, "bra %s", mri_control_stack->next);
  mri_assemble (buf);
  free (buf);

  colon (mri_control_stack->bottom);

  pop_mri_control ();

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/*
 * md_parse_option
 *	Invocation line includes a switch not recognized by the base assembler.
 *	See if it's a processor-specific option.  These are:
 *
 *	-[A]m[c]68000, -[A]m[c]68008, -[A]m[c]68010, -[A]m[c]68020, -[A]m[c]68030, -[A]m[c]68040
 *	-[A]m[c]68881, -[A]m[c]68882, -[A]m[c]68851
 *		Select the architecture.  Instructions or features not
 *		supported by the selected architecture cause fatal
 *		errors.  More than one may be specified.  The default is
 *		-m68020 -m68851 -m68881.  Note that -m68008 is a synonym
 *		for -m68000, and -m68882 is a synonym for -m68881.
 *	-[A]m[c]no-68851, -[A]m[c]no-68881
 *		Don't accept 688?1 instructions.  (The "c" is kind of silly,
 *		so don't use or document it, but that's the way the parsing
 *		works).
 *
 *	-pic	Indicates PIC.
 *	-k	Indicates PIC.  (Sun 3 only.)
 *      --pcrel Never turn PC-relative branches into absolute jumps.
 *
 *	--bitwise-or
 *		Permit `|' to be used in expressions.
 *
 */

#ifdef OBJ_ELF
const char *md_shortopts = "lSA:m:kQ:V";
#else
const char *md_shortopts = "lSA:m:k";
#endif

struct option md_longopts[] = {
#define OPTION_PIC (OPTION_MD_BASE)
  {"pic", no_argument, NULL, OPTION_PIC},
#define OPTION_REGISTER_PREFIX_OPTIONAL (OPTION_MD_BASE + 1)
  {"register-prefix-optional", no_argument, NULL,
     OPTION_REGISTER_PREFIX_OPTIONAL},
#define OPTION_BITWISE_OR (OPTION_MD_BASE + 2)
  {"bitwise-or", no_argument, NULL, OPTION_BITWISE_OR},
#define OPTION_BASE_SIZE_DEFAULT_16 (OPTION_MD_BASE + 3)
  {"base-size-default-16", no_argument, NULL, OPTION_BASE_SIZE_DEFAULT_16},
#define OPTION_BASE_SIZE_DEFAULT_32 (OPTION_MD_BASE + 4)
  {"base-size-default-32", no_argument, NULL, OPTION_BASE_SIZE_DEFAULT_32},
#define OPTION_DISP_SIZE_DEFAULT_16 (OPTION_MD_BASE + 5)
  {"disp-size-default-16", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_16},
#define OPTION_DISP_SIZE_DEFAULT_32 (OPTION_MD_BASE + 6)
  {"disp-size-default-32", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_32},
#define OPTION_PCREL (OPTION_MD_BASE + 7)
  {"pcrel", no_argument, NULL, OPTION_PCREL},
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
    {
    case 'l':			/* -l means keep external to 2 bit offset
				   rather than 16 bit one.  */
      flag_short_refs = 1;
      break;

    case 'S':			/* -S means that jbsr's always turn into
				   jsr's.  */
      flag_long_jumps = 1;
      break;

    case OPTION_PCREL:		/* --pcrel means never turn PC-relative
				   branches into absolute jumps.  */
      flag_keep_pcrel = 1;
      break;

    case 'A':
      if (*arg == 'm')
	arg++;
      /* Intentional fall-through.  */
    case 'm':

      if (arg[0] == 'n' && arg[1] == 'o' && arg[2] == '-')
	{
	  int i;
	  unsigned long arch;
	  const char *oarg = arg;

	  arg += 3;
	  if (*arg == 'm')
	    {
	      arg++;
	      if (arg[0] == 'c' && arg[1] == '6')
		arg++;
	    }
	  for (i = 0; i < n_archs; i++)
	    if (!strcmp (arg, archs[i].name))
	      break;
	  if (i == n_archs)
	    {
	    unknown:
	      as_bad (_("unrecognized option `%s'"), oarg);
	      return 0;
	    }
	  arch = archs[i].arch;
	  if (arch == m68881)
	    no_68881 = 1;
	  else if (arch == m68851)
	    no_68851 = 1;
	  else
	    goto unknown;
	}
      else
	{
	  int i;

	  if (arg[0] == 'c' && arg[1] == '6')
	    arg++;

	  for (i = 0; i < n_archs; i++)
	    if (!strcmp (arg, archs[i].name))
	      {
		unsigned long arch = archs[i].arch;
		if (cpu_of_arch (arch))
		  /* It's a cpu spec.  */
		  {
		    current_architecture &= ~m68000up;
		    current_architecture |= arch;
		  }
		else if (arch == m68881)
		  {
		    current_architecture |= m68881;
		    no_68881 = 0;
		  }
		else if (arch == m68851)
		  {
		    current_architecture |= m68851;
		    no_68851 = 0;
		  }
		else
		  /* ??? */
		  abort ();
		break;
	      }
	  if (i == n_archs)
	    {
	      as_bad (_("unrecognized architecture specification `%s'"), arg);
	      return 0;
	    }
	}
      break;

    case OPTION_PIC:
    case 'k':
      flag_want_pic = 1;
      break;			/* -pic, Position Independent Code.  */

    case OPTION_REGISTER_PREFIX_OPTIONAL:
      flag_reg_prefix_optional = 1;
      reg_prefix_optional_seen = 1;
      break;

      /* -V: SVR4 argument to print version ID.  */
    case 'V':
      print_version_id ();
      break;

      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

    case OPTION_BITWISE_OR:
      {
	char *n, *t;
	const char *s;

	n = (char *) xmalloc (strlen (m68k_comment_chars) + 1);
	t = n;
	for (s = m68k_comment_chars; *s != '\0'; s++)
	  if (*s != '|')
	    *t++ = *s;
	*t = '\0';
	m68k_comment_chars = n;
      }
      break;

    case OPTION_BASE_SIZE_DEFAULT_16:
      m68k_index_width_default = SIZE_WORD;
      break;

    case OPTION_BASE_SIZE_DEFAULT_32:
      m68k_index_width_default = SIZE_LONG;
      break;

    case OPTION_DISP_SIZE_DEFAULT_16:
      m68k_rel32 = 0;
      m68k_rel32_from_cmdline = 1;
      break;

    case OPTION_DISP_SIZE_DEFAULT_32:
      m68k_rel32 = 1;
      m68k_rel32_from_cmdline = 1;
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (stream)
     FILE *stream;
{
  const char *default_cpu = TARGET_CPU;
  int i;
  unsigned int default_arch;

  /* Get the canonical name for the default target CPU.  */
  if (*default_cpu == 'm')
    default_cpu++;
  for (i = 0; i < n_archs; i++)
    {
      if (strcasecmp (default_cpu, archs[i].name) == 0)
	{
	  default_arch = archs[i].arch;
	  for (i = 0; i < n_archs; i++)
	    {
	      if (archs[i].arch == default_arch
		  && !archs[i].alias)
		{
		  default_cpu = archs[i].name;
		  break;
		}
	    }
	}
    }

  fprintf (stream, _("\
680X0 options:\n\
-l			use 1 word for refs to undefined symbols [default 2]\n\
-m68000 | -m68008 | -m68010 | -m68020 | -m68030 | -m68040 | -m68060 |\n\
-m68302 | -m68331 | -m68332 | -m68333 | -m68340 | -m68360 | -mcpu32 |\n\
-m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m528x  | -m5307  |\n\
-m5407  | -mcfv4  | -mcfv4e\n\
			specify variant of 680X0 architecture [default %s]\n\
-m68881 | -m68882 | -mno-68881 | -mno-68882\n\
			target has/lacks floating-point coprocessor\n\
			[default yes for 68020, 68030, and cpu32]\n"),
          default_cpu);
  fprintf (stream, _("\
-m68851 | -mno-68851\n\
			target has/lacks memory-management unit coprocessor\n\
			[default yes for 68020 and up]\n\
-pic, -k		generate position independent code\n\
-S			turn jbsr into jsr\n\
--pcrel                 never turn PC-relative branches into absolute jumps\n\
--register-prefix-optional\n\
			recognize register names without prefix character\n\
--bitwise-or		do not treat `|' as a comment character\n"));
  fprintf (stream, _("\
--base-size-default-16	base reg without size is 16 bits\n\
--base-size-default-32	base reg without size is 32 bits (default)\n\
--disp-size-default-16	displacement with unknown size is 16 bits\n\
--disp-size-default-32	displacement with unknown size is 32 bits (default)\n"));
}

#ifdef TEST2

/* TEST2:  Test md_assemble() */
/* Warning, this routine probably doesn't work anymore.  */
int
main ()
{
  struct m68k_it the_ins;
  char buf[120];
  char *cp;
  int n;

  m68k_ip_begin ();
  for (;;)
    {
      if (!gets (buf) || !*buf)
	break;
      if (buf[0] == '|' || buf[1] == '.')
	continue;
      for (cp = buf; *cp; cp++)
	if (*cp == '\t')
	  *cp = ' ';
      if (is_label (buf))
	continue;
      memset (&the_ins, '\0', sizeof (the_ins));
      m68k_ip (&the_ins, buf);
      if (the_ins.error)
	{
	  printf (_("Error %s in %s\n"), the_ins.error, buf);
	}
      else
	{
	  printf (_("Opcode(%d.%s): "), the_ins.numo, the_ins.args);
	  for (n = 0; n < the_ins.numo; n++)
	    printf (" 0x%x", the_ins.opcode[n] & 0xffff);
	  printf ("    ");
	  print_the_insn (&the_ins.opcode[0], stdout);
	  (void) putchar ('\n');
	}
      for (n = 0; n < strlen (the_ins.args) / 2; n++)
	{
	  if (the_ins.operands[n].error)
	    {
	      printf ("op%d Error %s in %s\n", n, the_ins.operands[n].error, buf);
	      continue;
	    }
	  printf ("mode %d, reg %d, ", the_ins.operands[n].mode, the_ins.operands[n].reg);
	  if (the_ins.operands[n].b_const)
	    printf ("Constant: '%.*s', ", 1 + the_ins.operands[n].e_const - the_ins.operands[n].b_const, the_ins.operands[n].b_const);
	  printf ("ireg %d, isiz %d, imul %d, ", the_ins.operands[n].ireg, the_ins.operands[n].isiz, the_ins.operands[n].imul);
	  if (the_ins.operands[n].b_iadd)
	    printf ("Iadd: '%.*s',", 1 + the_ins.operands[n].e_iadd - the_ins.operands[n].b_iadd, the_ins.operands[n].b_iadd);
	  (void) putchar ('\n');
	}
    }
  m68k_ip_end ();
  return 0;
}

is_label (str)
     char *str;
{
  while (*str == ' ')
    str++;
  while (*str && *str != ' ')
    str++;
  if (str[-1] == ':' || str[1] == '=')
    return 1;
  return 0;
}

#endif

/* Possible states for relaxation:

   0 0	branch offset	byte	(bra, etc)
   0 1			word
   0 2			long

   1 0	indexed offsets	byte	a0@@(32,d4:w:1) etc
   1 1			word
   1 2			long

   2 0	two-offset index word-word a0@@(32,d4)@@(45) etc
   2 1			word-long
   2 2			long-word
   2 3			long-long

   */

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
{
#ifdef OBJ_AOUT
#ifdef BFD_ASSEMBLER
  /* For a.out, force the section size to be aligned.  If we don't do
     this, BFD will align it for us, but it will not write out the
     final bytes of the section.  This may be a bug in BFD, but it is
     easier to fix it here since that is how the other a.out targets
     work.  */
  int align;

  align = bfd_get_section_alignment (stdoutput, segment);
  size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
#endif
#endif

  return size;
}

/* Exactly what point is a PC-relative offset relative TO?
   On the 68k, it is relative to the address of the first extension
   word.  The difference between the addresses of the offset and the
   first extension word is stored in fx_pcrel_adjust.  */
long
md_pcrel_from (fixP)
     fixS *fixP;
{
  int adjust;

  /* Because fx_pcrel_adjust is a char, and may be unsigned, we explicitly
     sign extend the value here.  */
  adjust = ((fixP->fx_pcrel_adjust & 0xff) ^ 0x80) - 0x80;
  if (adjust == 64)
    adjust = -1;
  return fixP->fx_where + fixP->fx_frag->fr_address - adjust;
}

#ifndef BFD_ASSEMBLER
#ifdef OBJ_COFF

void
tc_coff_symbol_emit_hook (ignore)
     symbolS *ignore ATTRIBUTE_UNUSED;
{
}

int
tc_coff_sizemachdep (frag)
     fragS *frag;
{
  switch (frag->fr_subtype & 0x3)
    {
    case BYTE:
      return 1;
    case SHORT:
      return 2;
    case LONG:
      return 4;
    default:
      abort ();
      return 0;
    }
}

#endif
#endif
#ifdef OBJ_ELF
void
m68k_elf_final_processing ()
{
  /* Set file-specific flags if this is a cpu32 processor.  */
  if (cpu_of_arch (current_architecture) & cpu32)
    elf_elfheader (stdoutput)->e_flags |= EF_CPU32;
  else if ((cpu_of_arch (current_architecture) & m68000up)
	   && !(cpu_of_arch (current_architecture) & m68020up))
    elf_elfheader (stdoutput)->e_flags |= EF_M68000;
}
#endif

int
tc_m68k_regname_to_dw2regnum (const char *regname)
{
  unsigned int regnum;
  static const char *const regnames[] =
    {
      "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
      "a0", "a1", "a2", "a3", "a4", "a5", "a6", "sp",
      "fp0", "fp1", "fp2", "fp3", "fp4", "fp5", "fp6", "fp7",
      "pc"
    };

  for (regnum = 0; regnum < ARRAY_SIZE (regnames); regnum++)
    if (strcmp (regname, regnames[regnum]) == 0)
      return regnum;

  return -1;
}

void
tc_m68k_frame_initial_instructions (void)
{
  static int sp_regno = -1;

  if (sp_regno < 0)
    sp_regno = tc_m68k_regname_to_dw2regnum ("sp");

  cfi_add_CFA_def_cfa (sp_regno, -DWARF2_CIE_DATA_ALIGNMENT);
  cfi_add_CFA_offset (DWARF2_DEFAULT_RETURN_COLUMN, DWARF2_CIE_DATA_ALIGNMENT);
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 2
   2000, 2001, 2002
   Free Software Foundation, Inc.
d27 1
d57 1
a57 1
/* Chars that can be used to separate mant from exp in floating point nums */
d69 1
a69 1
const int md_reloc_size = 8;	/* Size of relocation record */
d77 2
a78 2
static int flag_short_refs;	/* -l option */
static int flag_long_jumps;	/* -S option */
a115 1

d133 2
a134 2
/* Its an arbitrary name:  This means I don't approve of it */
/* See flames below */
d170 1
a170 1
  CACR, TC, ITT0, ITT1, DTT0, DTT1, VBR, ROMBAR,
d174 11
d189 1
a189 1
/* internal form of a 68020 instruction */
d193 1
a193 1
  const char *args;		/* list of opcode info */
d196 1
a196 1
  int numo;			/* Number of shorts in opcode */
d201 1
a201 1
  int nexp;			/* number of exprs in use */
d204 1
a204 1
  int nfrag;			/* Number of frags we have to produce */
d207 1
a207 1
      int fragoff;		/* Where in the current opcode the frag ends */
d214 1
a214 1
  int nrel;			/* Num of reloc strucs in use */
d235 1
a235 1
  reloc[5];			/* Five is enough??? */
d238 1
a238 1
#define cpu_of_arch(x)		((x) & (m68000up|mcf))
d241 2
a242 1
#define arch_coldfire_p(x)	(((x) & mcf) != 0)
d244 2
a245 2
/* Macros for determining if cpu supports a specific addressing mode */
#define HAVE_LONG_BRANCH(x)     ((x) & (m68020|m68030|m68040|m68060|cpu32|mcf5407))
d247 1
a247 1
static struct m68k_it the_ins;	/* the instruction being assembled */
d254 1
a254 2
/* Macros for adding things to the m68k_it struct */

a257 1

d262 2
a263 1
/* Like addword, but goes BEFORE general operands */
d374 15
a388 13
    { m68000, "68000", 0 },
    { m68010, "68010", 0 },
    { m68020, "68020", 0 },
    { m68030, "68030", 0 },
    { m68040, "68040", 0 },
    { m68060, "68060", 0 },
    { cpu32,  "cpu32", 0 },
    { m68881, "68881", 0 },
    { m68851, "68851", 0 },
    { mcf5200, "5200", 0 },
    { mcf5206e, "5206e", 0 },
    { mcf5307, "5307", 0},
    { mcf5407, "5407", 0},
d419 1
d447 4
a450 4
#define BRANCHBWL	0	/* branch byte, word, or long */
#define BRABSJUNC	1	/* absolute jump for LONG, unconditional */
#define BRABSJCOND	2	/* absolute jump for LONG, conditional */
#define BRANCHBW	3	/* branch byte or word */
d460 3
a462 3
#define FBRANCH		4	/* coprocessor branch */
#define DBCCLBR		5	/* DBcc relaxable with a long branch */
#define DBCCABSJ	6	/* DBcc relaxable with an absolute jump */
d475 3
a477 3
#define PCREL1632	7	/* 16-bit or 32-bit PC-relative */
#define PCINDEX		8	/* PC+displacement+index */
#define ABSTOPCREL	9	/* absolute relax down to 16-bit PC-relative */
d511 1
a511 1
  {	1, 	1,  0, 0 },		/* FBRANCH doesn't come BYTE */
d516 1
a516 1
  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE */
d521 1
a521 1
  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE */
d526 1
a526 1
  {	1, 	1,  0, 0 },		/* PCREL1632 doesn't come BYTE */
d536 1
a536 1
  {	1,	1,  0, 0 },		/* ABSTOPCREL doesn't come BYTE */
d544 1
a544 2
   generates these.
   */
d550 1
a550 2
   Integer arg to pass to the function
   */
a567 6
#ifdef OBJ_ELF
  /* Dwarf2 support for Gcc.  */
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
#endif

d674 4
a677 5
  /* rewrite the PC relative instructions to absolute address ones.
   * these are rumoured to be faster, and the apollo linker refuses
   * to deal with the PC relative relocations.
   */
  if (opcode[0] == 0x60 && opcode[1] == 0xff) /* BRA -> JMP */
d679 2
d684 1
a684 1
  else if (opcode[0] == 0x61 && opcode[1] == 0xff) /* BSR -> JSR */
d686 2
d735 1
a735 1
  (!((S_IS_EXTERNAL (symbol) && strcmp (TARGET_OS, "elf") != 0)		\
d855 1
a855 1
  /* adjust_reloc_syms doesn't know about the GOT */
d1030 1
a1030 1
    instring++;			/* skip leading whitespace */
d1079 1
a1079 1
  /* found a legitimate opcode, start matching operands */
d1088 1
a1088 1
      /* Ahh - it's a motorola style psuedo op */
d1138 1
a1138 1
  /* We've got the operands.  Find an opcode that'll accept them */
d1515 18
d1737 10
d1754 1
a1754 1
		  /* Memory addressing mode used by pflushr */
d1808 19
d1850 1
a1850 3
		    {
		      losing++;
		    }		/* not a cache specifier.  */
d1871 12
d1885 1
a1885 1
		}		/* switch on type of operand */
d1889 2
a1890 2
	    }			/* for each operand */
	}			/* if immediately wrong */
d1893 1
a1893 3
	{
	  break;
	}			/* got it.  */
d1909 3
d1956 1
a1956 1
	}			/* Fell off the end */
d1961 1
a1961 2
  /* now assemble it */

d1987 1
d1994 3
d2005 1
a2005 1
		nextword = get_num (&opP->disp, 80);
d2058 1
a2058 1
	      /* We gotta put out some float */
d2117 1
a2117 1
	      nextword = get_num (&opP->disp, 80);
d2132 1
a2132 1
	      /* Force into index mode.  Hope this works */
d2213 1
a2213 1
	      baseo = get_num (&opP->disp, 80);
d2215 1
a2215 1
		outro = get_num (&opP->odisp, 80);
d2243 1
a2243 1
	      /* Index register stuff */
d2258 2
a2259 1
			  && arch_coldfire_p (current_architecture)))
d2355 1
a2355 1
		  nextword |= 0x40;	/* No index reg */
d2403 1
a2403 1
	      /* Figure out innner displacement stuff */
d2464 1
a2464 1
	      nextword = get_num (&opP->disp, 80);
d2493 1
a2493 1
		  /* Fall through into long */
d2506 2
a2507 1
		case SIZE_WORD:	/* Word */
d2540 1
a2540 1
	      tmpreg = 80;
d2607 1
a2607 1
	  tmpreg = get_num (&opP->disp, 80);
d2627 1
a2627 1
	      if (subs (&opP->disp))	/* We can't relax it */
d2700 1
a2700 1
	    case 'C':		/* Fixed size LONG coproc branches */
d2705 1
a2705 1
	    case 'c':		/* Var size Coprocesssor branches */
d2722 1
a2722 1
	case 'C':		/* Ignore it */
d2725 1
a2725 1
	case 'd':		/* JF this is a kludge */
d2727 1
a2727 1
	  tmpreg = get_num (&opP->disp, 80);
d2740 1
a2740 1
	case 'E':		/* Ignore it */
d2747 1
a2747 1
	case 'G':		/* Ignore it */
d2756 1
a2756 1
	case 'J':		/* JF foo */
d2771 1
d2775 1
d2779 1
d2783 1
d2821 4
d2828 1
d2832 11
d2846 36
d2953 1
a2953 1
	     will have the ADDR_REG bit set */
d2976 1
a2976 1
	case 'S':		/* Ignore it */
d2983 1
a2983 1
	case 'U':		/* Ignore it */
d3003 1
a3003 1
	    }			/* switch on cache token */
d3127 1
a3127 1
	case '_':	/* used only for move16 absolute 32-bit address */
d3130 1
a3130 1
	  tmpreg = get_num (&opP->disp, 80);
d3137 7
a3143 1
	  opP->reg &= 0x0F;	/* remove upper/lower bit */
d3212 1
a3212 1
      the_ins.opcode[0] |= val & 0xFF;	/* JF FF is for M kludge */
d3267 1
a3267 1
      the_ins.numo++;		/* What a hack */
d3337 1
a3337 1
      /* more stuff goes here */
d3372 1
a3372 1
		{			/* ERROR */
d3383 1
a3383 1
    {				/* ERROR */
d3396 1
a3396 1
    c = *++str;			/* JF bitfield hack */
d3513 2
a3514 2
  /* control registers */
  { "sfc", SFC },		/* Source Function Code */
d3516 1
a3516 1
  { "dfc", DFC },		/* Destination Function Code */
d3518 2
a3519 2
  { "cacr", CACR },		/* Cache Control Register */
  { "caar", CAAR },		/* Cache Address Register */
d3521 9
a3529 9
  { "usp", USP },		/* User Stack Pointer */
  { "vbr", VBR },		/* Vector Base Register */
  { "msp", MSP },		/* Master Stack Pointer */
  { "isp", ISP },		/* Interrupt Stack Pointer */

  { "itt0", ITT0 },		/* Instruction Transparent Translation Reg 0 */
  { "itt1", ITT1 },		/* Instruction Transparent Translation Reg 1 */
  { "dtt0", DTT0 },		/* Data Transparent Translation Register 0 */
  { "dtt1", DTT1 },		/* Data Transparent Translation Register 1 */
d3532 4
a3535 4
  { "iacr0", ITT0 },		/* Instruction Access Control Register 0 */
  { "iacr1", ITT1 },		/* Instruction Access Control Register 0 */
  { "dacr0", DTT0 },		/* Data Access Control Register 0 */
  { "dacr1", DTT1 },		/* Data Access Control Register 0 */
d3540 4
a3543 4
  { "acr0", ITT0 },		/* Access Control Unit 0 */
  { "acr1", ITT1 },		/* Access Control Unit 1 */
  { "acr2", DTT0 },		/* Access Control Unit 2 */
  { "acr3", DTT1 },		/* Access Control Unit 3 */
d3545 1
a3545 1
  { "tc", TC },			/* MMU Translation Control Register */
d3548 3
a3550 3
  { "mmusr", MMUSR },		/* MMU Status Register */
  { "srp", SRP },		/* User Root Pointer */
  { "urp", URP },		/* Supervisor Root Pointer */
d3555 30
a3584 5
  { "rombar", ROMBAR },		/* ROM Base Address Register */
  { "rambar0", RAMBAR0 },	/* ROM Base Address Register */
  { "rambar1", RAMBAR1 },	/* ROM Base Address Register */
  { "mbar", MBAR },		/* Module Base Address Register */
  /* end of control registers */
d3618 1
a3618 1
  /* 68ec030 versions of same */
d3621 1
a3621 1
  /* 68ec030 access control unit, identical to 030 MMU status reg */
d3776 1
a3776 1
      /* No frag hacking involved; just put it out */
d3785 1
a3785 1
      /* put out symbol-dependent info */
d3826 1
a3826 1
  /* There's some frag hacking */
d3938 1
a3938 1
  const char *retval = 0;	/* empty string, or error msg text */
d3964 1
a3964 1
	  /* This is kludgey */
d4080 1
a4080 1
     gas expects pseudo ops to start with a dot */
d4141 6
d4319 1
a4319 1
/* Equal to MAX_PRECISION in atof-ieee.c */
d4404 1
a4404 1
  /* end ibm compiler workaround */
d4415 1
a4415 1
      fixP->fx_addnumber = val;	/* Remember value for emit_reloc */
d4452 1
a4452 1
      lower_limit = - (offsetT) 0x7fffffff - 1;	/* avoid constant overflow */
d4513 1
a4513 1
  /* end ibm compiler workaround */
d4551 2
d4554 1
a4554 1
	  fragP->fr_opcode[1] = (char) 0xB9; /* JSR with ABSL LONG operand */
d4561 2
d4564 1
a4564 1
	  fragP->fr_opcode[1] = (char) 0xF9; /* JMP with ABSL LONG operand */
d4577 2
a4578 2
      /* Only Bcc 68000 instructions can come here.  */
      /* Change bcc into b!cc/jmp absl long.  */
d4580 4
a4583 2
      fragP->fr_opcode[0] ^= 0x01;	/* invert bcc */
      fragP->fr_opcode[1] = 0x6;/* branch offset = 6 */
d4586 1
a4586 1
	   different frag, in which case refering to them is a no-no.
d4590 1
a4590 1
      fragP->fr_fix += 2;	/* account for jmp instruction */
d4602 1
a4602 1
      fragP->fr_opcode[1] |= 0x40;	/* Turn on LONG bit */
d4614 5
a4618 2
      /* only DBcc instructions can come here */
      /* Change dbcc into dbcc/bral.  */
d4620 1
a4620 2
      /* JF: these used to be fr_opcode[2-7], but that's wrong */
      *buffer_address++ = 0x00;	/* branch offset = 4 */
d4622 1
a4622 1
      *buffer_address++ = 0x60;	/* put in bra pc+6 */
d4627 1
a4627 1
      fragP->fr_fix += 6;	/* account for bra/jmp instructions */
d4633 5
a4637 2
      /* only DBcc instructions can come here */
      /* Change dbcc into dbcc/jmp.  */
d4639 1
a4639 2
      /* JF: these used to be fr_opcode[2-7], but that's wrong */
      *buffer_address++ = 0x00;	/* branch offset = 4 */
d4641 1
a4641 1
      *buffer_address++ = 0x60;	/* put in bra pc+6 */
d4643 1
a4643 1
      *buffer_address++ = 0x4e;     /* Put in jmp long (0x4ef9).  */
d4646 1
a4646 1
      fragP->fr_fix += 6;	/* account for bra/jmp instructions */
d4700 2
d4703 1
a4703 1
	 ABSTOPCREL is really trying to shorten an ABSOLUTE address anyway */
d4873 1
a4873 1
   you there. -KWK */
d4886 1
a4886 1
  /* this is easy */
d4888 1
a4888 1
  /* now the fun stuff */
d4890 2
a4891 2
  the_bytes[5] = (ri->r_symbolnum >> 8) & 0x0ff;
  the_bytes[6] = ri->r_symbolnum & 0x0ff;
d4896 1
a4896 1
#endif /* comment */
d4963 2
d4985 5
a4989 5
   10:  Absolute 1:8	only
   20:  Absolute 0:7	only
   30:  absolute 0:15	only
   40:  Absolute 0:31	only
   50:  absolute 0:127	only
d4991 4
a4994 5
   60:  absolute -128:127	only
   70:  absolute 0:4095	only
   80:  No bignums

   */
d5003 1
a5003 1
      /* Do the same thing the VAX asm does */
d5057 9
d5072 3
a5074 3
      if (offs (exp) <= 0	/* flonum */
	  && (ok == 80		/* no bignums */
	      || (ok > 10	/* small-int ranges including 0 ok */
d5080 1
a5080 1
	  /* HACK! Turn it into a long */
d5083 1
a5083 1
	  gen_to_words (words, 2, 8L);	/* These numbers are magic! */
d5101 1
a5101 1
      if (ok >= 10 && ok <= 70)
d5446 1
a5446 1
   not suppor tand which take arguments.  */
d5931 1
a5931 1
    /* <HS> is an alias for <CC> */
d5934 1
a5934 1
    /* <LO> is an alias for <CS> */
d5943 1
a5943 1
    /* issue a warning for conditions we can not swap */
d6237 1
a6237 1
       if d0 <ne> #CONST*20   then */
a6631 1

d6636 1
a6636 1
  /* move init,var */
d6655 1
a6655 1
  /* cmp end,var */
d6671 1
a6671 1
  /* bcc bottom */
d6815 1
a6815 1
       while d0 <ne> #CONST*20   do */
d6953 1
a6953 1
				   rather than 16 bit one */
d6970 1
a6970 1
      /* intentional fall-through */
d7046 1
a7046 1
      break;			/* -pic, Position Independent Code */
d7136 2
a7137 1
-m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m5307  | -m5407\n\
d7163 2
a7164 2
/* Warning, this routine probably doesn't work anymore */

d7333 1
a7333 1
  /* Set file-specific flags if this is a cpu32 processor */
d7341 31
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000, 2001
a22 1
#include <ctype.h>
d24 1
d27 1
d58 1
a58 1
CONST char EXP_CHARS[] = "eE";
d63 1
a63 1
CONST char FLT_CHARS[] = "rRsSfFdDxXeEpP";
d260 4
a263 4
  for(z=the_ins.numo;z>opcode->m_codenum;--z)
    the_ins.opcode[z]=the_ins.opcode[z-1];
  for(z=0;z<the_ins.nrel;z++)
    the_ins.reloc[z].n+=2;
d266 1
a266 1
  the_ins.opcode[opcode->m_codenum]=w;
d309 4
a312 4
  the_ins.fragb[the_ins.nfrag].fragoff=the_ins.numo;
  the_ins.fragb[the_ins.nfrag].fadd=add;
  the_ins.fragb[the_ins.nfrag].foff=off;
  the_ins.fragb[the_ins.nfrag++].fragty=type;
a350 1
static void md_apply_fix_2 PARAMS ((fixS *, offsetT));
d434 4
a437 4
#define BRANCHBWL	1	/* branch byte, word, or long */
#define BRABSJUNC	2	/* absolute jump for LONG, unconditional */
#define BRABSJCOND	3	/* absolute jump for LONG, conditional */
#define BRANCHBW	4	/* branch byte or word */
d447 3
a449 3
#define FBRANCH		5	/* coprocessor branch */
#define DBCCLBR		6	/* DBcc relaxable with a long branch */
#define DBCCABSJ	7	/* DBcc relaxable with an absolute jump */
d462 3
a464 3
#define PCREL1632	8	/* 16-bit or 32-bit PC-relative */
#define PCINDEX		9	/* PC+displacement+index */
#define ABSTOPCREL	10	/* absolute relax down to 16-bit PC-relative */
d474 2
a475 1
   */
d478 49
a526 54
  {1, 1, 0, 0},			/* First entries aren't used */
  {1, 1, 0, 0},			/* For no good reason except */
  {1, 1, 0, 0},			/* that the VAX doesn't either */
  {1, 1, 0, 0},

  {(127), (-128), 0, TAB (BRANCHBWL, SHORT)},
  {(32767), (-32768), 2, TAB (BRANCHBWL, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},

  {(127), (-128), 0, TAB (BRABSJUNC, SHORT)},
  {(32767), (-32768), 2, TAB (BRABSJUNC, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},

  {(127), (-128), 0, TAB (BRABSJCOND, SHORT)},
  {(32767), (-32768), 2, TAB (BRABSJCOND, LONG)},
  {0, 0, 6, 0},
  {1, 1, 0, 0},

  {(127), (-128), 0, TAB (BRANCHBW, SHORT)},
  {0, 0, 2, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* FBRANCH doesn't come BYTE */
  {(32767), (-32768), 2, TAB (FBRANCH, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* DBCC doesn't come BYTE */
  {(32767), (-32768), 2, TAB (DBCCLBR, LONG)},
  {0, 0, 10, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* DBCC doesn't come BYTE */
  {(32767), (-32768), 2, TAB (DBCCABSJ, LONG)},
  {0, 0, 10, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* PCREL1632 doesn't come BYTE */
  {32767, -32768, 2, TAB (PCREL1632, LONG)},
  {0, 0, 6, 0},
  {1, 1, 0, 0},

  {125, -130, 0, TAB (PCINDEX, SHORT)},
  {32765, -32770, 2, TAB (PCINDEX, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* ABSTOPCREL doesn't come BYTE */
  {(32767), (-32768), 2, TAB (ABSTOPCREL, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},
d557 6
d614 1
a614 1
CONST pseudo_typeS mote_pseudo_table[] =
a650 2
static char mklower_table[256];
#define mklower(c) (mklower_table[(unsigned char) (c)])
a846 4
  /* Prevent all adjustments to global symbols.  */
  if (! relaxable_symbol (fixP->fx_addsy))
    return 0;

d885 1
a885 1
     asection *section;
d899 3
a901 2
	as_bad (_("Unable to produce reloc against symbol '%s'"),
		S_GET_NAME (fixp->fx_addsy));
d1223 1
a1223 1
                  break;
d1233 1
a1233 1
                  break;
d1245 1
a1245 1
                  break;
d1258 1
a1258 1
                        losing++;
d1263 1
a1263 1
                  break;
d1275 1
a1275 1
                        losing++;
d1281 1
a1281 1
                  break;
d1294 1
a1294 1
                        losing++;
d2274 4
a2277 4
 			  nextword += baseo & 0xff;
 			  addword (nextword);
 			  add_frag (adds (&opP->disp), offs (&opP->disp),
 				    TAB (PCINDEX, SZ_UNDEF));
d2280 1
a2280 1
 			}
d2572 1
a2572 1
		    the_ins.opcode[0] = 0x4EF1;
d2574 1
a2574 1
		    the_ins.opcode[0] = 0x4EB1;
d2579 1
a2579 1
		      addword (0x4EF1);
d3308 1
a3308 1
    buf[i] = islower (regname[i]) ? toupper (regname[i]) : regname[i];
d3611 5
d3778 4
a3781 5
  register const struct m68k_opcode *ins;
  register struct m68k_incant *hack, *slak;
  register const char *retval = 0;	/* empty string, or error msg text */
  register int i;
  register char c;
a3875 3
  for (i = 0; i < (int) sizeof (mklower_table); i++)
    mklower_table[i] = (isupper (c = (char) i)) ? tolower (c) : c;

d3953 5
d4226 2
a4227 2
static void
md_apply_fix_2 (fixP, val)
d4229 2
a4230 1
     offsetT val;
d4232 1
d4244 3
d4269 2
a4270 2
      /* The cast to offsetT below are necessary to make code correct for
	 machines where ints are smaller than offsetT */
a4329 18
#ifdef BFD_ASSEMBLER
int
md_apply_fix (fixP, valp)
     fixS *fixP;
     valueT *valp;
{
  md_apply_fix_2 (fixP, (addressT) *valp);
  return 1;
}
#else
void md_apply_fix (fixP, val)
     fixS *fixP;
     long val;
{
  md_apply_fix_2 (fixP, (addressT) val);
}
#endif

a4354 4
#ifdef BFD_ASSEMBLER
  disp += symbol_get_frag (fragP->fr_symbol)->fr_address;
#endif

d4363 2
a4364 1
	as_bad (_("short branch with zero offset: use :w"));
a4569 4
  int old_fix;

  old_fix = fragP->fr_fix;

d4666 10
a4675 16
	 case we force word mode.  At this point S_GET_VALUE should
	 return the offset of the symbol within its frag.  If the
	 symbol is at the start of a frag, and it is the next frag
	 with any data in it (usually this is just the next frag, but
	 assembler listings may introduce empty frags), we must use
	 word mode.  */
      if (fragP->fr_symbol && S_GET_VALUE (fragP->fr_symbol) == 0)
	{
	  fragS *stop;
	  fragS *l;

	  stop = symbol_get_frag (fragP->fr_symbol);
	  for (l = fragP->fr_next; l != stop; l = l->fr_next)
	    if (l->fr_fix + l->fr_var != 0)
	      break;
	  if (l == stop)
d4677 7
a4683 1
	      fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
d4690 1
a4690 2
  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
  return fragP->fr_var + fragP->fr_fix - old_fix;
d4734 1
a4734 1
  static CONST unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
d4758 2
a4759 2
CONST int md_short_jump_size = 4;
CONST int md_long_jump_size = 6;
d5326 1
a5326 1
    listing &=~ LISTING_SYMBOLS;
d5355 1
a5355 1
  while (isalnum ((unsigned char) *input_line_pointer)
d5567 1
a5567 4
    {
      if (isupper ((unsigned char) *s))
	*s = tolower ((unsigned char) *s);
    }
d5649 2
a5650 4
  if (isupper (c1))
    c1 = tolower (c1);
  if (isupper (c2))
    c2 = tolower (c2);
d5708 10
a5717 4
      if ((strncasecmp (s, "AND", 3) == 0
	   && (s[3] == '.' || ! is_part_of_name (s[3])))
	  || (strncasecmp (s, "OR", 2) == 0
	      && (s[2] == '.' || ! is_part_of_name (s[2]))))
d5745 2
d5748 2
d5757 9
d5780 2
d5783 2
d5851 14
a5864 1
	  cc = swap_mri_condition (cc);
d5872 4
d5894 1
a5894 1
	*s++ = qual;
d5912 1
a5912 1
    *s++ = extent;
d6047 11
a6057 2
  while (! is_end_of_line[(unsigned char) *s]
	 && (! flag_mri || *s != '*'))
d6162 1
a6162 1
  q[0] = qual;
d6235 1
a6235 1
  ex[0] = extent;
d6274 1
a6274 1
  ex[0] = extent;
d6458 1
a6458 1
    *s++ = qual;
d6476 1
a6476 1
    *s++ = qual;
d6487 1
a6487 1
  ex[0] = extent;
d6503 1
a6503 1
    *s++ = qual;
d6626 11
a6636 2
  while (! is_end_of_line[(unsigned char) *s]
	 && (! flag_mri || *s != '*'))
d6733 1
a6733 1
CONST char *md_shortopts = "lSA:m:kQ:V";
d6735 1
a6735 1
CONST char *md_shortopts = "lSA:m:k";
d6784 1
a6784 1
 	arg++;
d6922 24
d6952 1
a6952 1
			specify variant of 680X0 architecture [default 68020]\n\
d6955 2
a6956 1
			[default yes for 68020, 68030, and cpu32]\n"));
d7144 2
a7145 1
void m68k_elf_final_processing()
d7147 6
a7152 3
   /* Set file-specific flags if this is a cpu32 processor */
   if (cpu_of_arch (current_architecture) & cpu32)
     elf_elfheader (stdoutput)->e_flags |= EF_CPU32;
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d50 2
a51 2
   #NO_APP at the beginning of its output. */
/* Also note that comments like this one will always work. */
d54 1
a54 1
const char line_separator_chars[] = "";
d72 1
a72 1
   references.  Not implemented.  For ELF there are other means 
d78 1
a136 29
#define TAB(x,y)	(((x)<<2)+(y))
#define TABTYPE(xy)     ((xy) >> 2)
#define BYTE		0
#define SHORT		1
#define LONG		2
#define SZ_UNDEF	3
#undef BRANCH
/* Case `g' except when BCC68000 is applicable.  */
#define ABRANCH		1
/* Coprocessor branches.  */
#define FBRANCH		2
/* Mode 7.2 -- program counter indirect with (16-bit) displacement,
   supported on all cpus.  Widens to 32-bit absolute.  */
#define PCREL		3
/* For inserting an extra jmp instruction with long offset on 68000,
   for expanding conditional branches.  (Not bsr or bra.)  Since the
   68000 doesn't support 32-bit displacements for conditional
   branches, we fake it by reversing the condition and branching
   around a jmp with an absolute long operand.  */
#define BCC68000        4
/* For the DBcc "instructions".  If the displacement requires 32 bits,
   the branch-around-a-jump game is played here too.  */
#define DBCC            5
/* Not currently used?  */
#define PCLEA		6
/* Mode AINDX (apc-relative) using PC, with variable target, might fit
   in 16 or 8 bits.  */
#define PCINDEX		7

d170 1
a170 1
  CACR, TC, ITT0, ITT1, DTT0, DTT1, VBR, ROMBAR, 
d233 1
a233 1
#define HAVE_LONG_BRANCH(x)	((x) & (m68020|m68030|m68040|m68060|cpu32))
d355 6
a360 5
struct m68k_cpu {
  unsigned long arch;
  const char *name;
  int alias;
};
d362 46
a407 44
static const struct m68k_cpu archs[] = {
  { m68000, "68000", 0 },
  { m68010, "68010", 0 },
  { m68020, "68020", 0 },
  { m68030, "68030", 0 },
  { m68040, "68040", 0 },
  { m68060, "68060", 0 },
  { cpu32,  "cpu32", 0 },
  { m68881, "68881", 0 },
  { m68851, "68851", 0 },
  { mcf5200, "5200", 0 },
  { mcf5206e, "5206e", 0 },
  { mcf5307, "5307", 0},
  /* Aliases (effectively, so far as gas is concerned) for the above
     cpus.  */
  { m68020, "68k", 1 },
  { m68000, "68008", 1 },
  { m68000, "68302", 1 },
  { m68000, "68306", 1 },
  { m68000, "68307", 1 },
  { m68000, "68322", 1 },
  { m68000, "68356", 1 },
  { m68000, "68ec000", 1 },
  { m68000, "68hc000", 1 },
  { m68000, "68hc001", 1 },
  { m68020, "68ec020", 1 },
  { m68030, "68ec030", 1 },
  { m68040, "68ec040", 1 },
  { m68060, "68ec060", 1 },
  { cpu32,  "68330", 1 },
  { cpu32,  "68331", 1 },
  { cpu32,  "68332", 1 },
  { cpu32,  "68333", 1 },
  { cpu32,  "68334", 1 },
  { cpu32,  "68336", 1 },
  { cpu32,  "68340", 1 },
  { cpu32,  "68341", 1 },
  { cpu32,  "68349", 1 },
  { cpu32,  "68360", 1 },
  { m68881, "68882", 1 },
  { mcf5200, "5202", 1 },
  { mcf5200, "5204", 1 },
  { mcf5200, "5206", 1 },
};
d411 2
a412 2
/* BCC68000 is for patching in an extra jmp instruction for long offsets
   on the 68000.  The 68000 doesn't support long branches with branchs */
d414 51
a464 2
/* This table desribes how you change sizes for the various types of variable
   size expressions.  This version only supports two kinds. */
d482 2
a483 2
  {(127), (-128), 0, TAB (ABRANCH, SHORT)},
  {(32767), (-32768), 2, TAB (ABRANCH, LONG)},
d487 2
a488 2
  {1, 1, 0, 0},			/* FBRANCH doesn't come BYTE */
  {(32767), (-32768), 2, TAB (FBRANCH, LONG)},
d492 12
a503 2
  {1, 1, 0, 0},			/* PCREL doesn't come BYTE */
  {(32767), (-32768), 2, TAB (PCREL, LONG)},
d507 3
a509 3
  {(127), (-128), 0, TAB (BCC68000, SHORT)},
  {(32767), (-32768), 2, TAB (BCC68000, LONG)},
  {0, 0, 6, 0},			/* jmp long space */
d513 2
a514 2
  {(32767), (-32768), 2, TAB (DBCC, LONG)},
  {0, 0, 10, 0},		/* bra/jmp long space */
d517 2
a518 2
  {1, 1, 0, 0},			/* PCLEA doesn't come BYTE */
  {32767, -32768, 2, TAB (PCLEA, LONG)},
a521 1
  /* For, e.g., jmp pcrel indexed.  */
d526 5
a603 1

d650 1
a650 1
#define mklower(c) (mklower_table[(unsigned char)(c)])
d717 13
d847 2
a848 3
  /* Prevent all adjustments to global symbols. */
  if (S_IS_EXTERNAL (fixP->fx_addsy)
      || S_IS_WEAK (fixP->fx_addsy))
d881 2
d895 5
d901 6
a906 1
    abort ();
d985 3
a987 2
		     + (fixp->fx_pcrel_adjust == 64
			? -1 : fixp->fx_pcrel_adjust)
a999 21
/* Return zero if the reference to SYMBOL from within the same segment may
   be relaxed.  */
#ifdef OBJ_ELF

/* On an ELF system, we can't relax an externally visible symbol,
   because it may be overridden by a shared library.  However, if
   TARGET_OS is "elf", then we presume that we are assembling for an
   embedded system, in which case we don't have to worry about shared
   libraries, and we can relax anything.  */

#define relaxable_symbol(symbol)		\
  (strcmp (TARGET_OS, "elf") == 0		\
   || (! S_IS_EXTERNAL (symbol)			\
       && ! S_IS_WEAK (symbol)))

#else

#define relaxable_symbol(symbol) 1

#endif
 
d1028 1
a1028 1
     or exactly 1 space. */
d1137 1
a1137 1
	 common model with this pattern then reject this pattern. */
d1800 1
a1800 1
		    }		/* not a cache specifier. */
d1813 1
a1813 1
                     registers, but ordinary ones. */
d1833 1
a1833 1
	}			/* got it. */
d2109 1
a2109 1
					TAB (PCLEA, SZ_UNDEF));
d2189 1
a2189 1
		  if ((opP->index.scale != 1 
d2191 1
a2191 1
		      || (opP->index.scale == 8 
a2416 2
		      && S_GET_SEGMENT (adds (&opP->disp)) == now_seg
		      && relaxable_symbol (adds (&opP->disp))
d2423 1
a2423 1
				TAB (PCREL, SZ_UNDEF));
d2452 1
a2452 1
	      /* abort(); */
d2543 1
a2543 5
	      /* The pc_fix argument winds up in fx_pcrel_adjust,
                 which is a char, and may therefore be unsigned.  We
                 want to pass -1, but we pass 64 instead, and convert
                 back in md_pcrel_from.  */
	      add_fix ('B', &opP->disp, 1, 64);
d2551 1
a2551 1
	      if (!HAVE_LONG_BRANCH(current_architecture))
d2553 1
a2553 1
	      the_ins.opcode[the_ins.numo - 1] |= 0xff;
d2568 21
d2590 4
a2593 10
	      /* This could either be a symbol, or an absolute
		 address.  No matter, the frag hacking will finger it
		 out.  Not quite: it can't switch from BRANCH to
		 BCC68000 for the case where opnd is absolute (it
		 needs to use the 68000 hack since no conditional abs
		 jumps).  */
	      if (( !HAVE_LONG_BRANCH(current_architecture)
		   || (0 == adds (&opP->disp)))
		  && (the_ins.opcode[0] >= 0x6200)
		  && (the_ins.opcode[0] <= 0x6f00))
d2595 11
a2605 1
			  TAB (BCC68000, SZ_UNDEF));
d2608 1
a2608 1
			  TAB (ABRANCH, SZ_UNDEF));
d2613 6
a2618 3
#if 1
		  /* check for DBcc instruction */
		  if ((the_ins.opcode[0] & 0xf0f8) == 0x50c8)
d2620 6
a2625 4
		      /* size varies if patch */
		      /* needed for long form */
		      add_frag (adds (&opP->disp), offs (&opP->disp),
				TAB (DBCC, SZ_UNDEF));
a2627 1
#endif
d2638 1
a2638 1
	      if (subs (&opP->disp))
a2639 10
		  add_fix ('l', &opP->disp, 1, 0);
		  add_frag ((symbolS *) 0, (offsetT) 0, TAB (FBRANCH, LONG));
		}
	      else if (adds (&opP->disp))
		add_frag (adds (&opP->disp), offs (&opP->disp),
			  TAB (FBRANCH, SZ_UNDEF));
	      else
		{
		  /* add_frag ((symbolS *) 0, offs (&opP->disp),
		     	       TAB(FBRANCH,SHORT)); */
d2645 3
d2883 1
a2883 1
	  /* JF: These are out of order, I fear. */
d3021 1
a3021 1
     instruction, ready to be emitted. . . */
d3487 1
a3487 1
  /* Upper and lower data and address registers, used by macw and msacw. */
d3667 15
d3800 1
a3800 1
	     but just leaving them out of the hash. */
d3977 1
d4156 2
a4157 2
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP .  An error message is
d4237 1
a4237 4
  if (val & 0x80000000)
    val |= ~(addressT)0x7fffffff;
  else
    val &= 0x7fffffff;
a4348 1
  long ext = 0;
d4356 1
a4356 1
     want. */
d4371 4
a4374 2
    case TAB (BCC68000, BYTE):
    case TAB (ABRANCH, BYTE):
d4378 12
a4389 2
      fragP->fr_opcode[1] = disp;
      ext = 0;
d4391 5
a4395 9
    case TAB (DBCC, SHORT):
      know (issword (disp));
      ext = 2;
      break;
    case TAB (BCC68000, SHORT):
    case TAB (ABRANCH, SHORT):
      know (issword (disp));
      fragP->fr_opcode[1] = 0x00;
      ext = 2;
d4397 2
a4398 2
    case TAB (ABRANCH, LONG):
      if (!HAVE_LONG_BRANCH(current_architecture))
d4400 13
a4412 34
	  if (fragP->fr_opcode[0] == 0x61)
	    /* BSR */
	    {
	      fragP->fr_opcode[0] = 0x4E;
	      fragP->fr_opcode[1] = (char) 0xB9; /* JBSR with ABSL LONG offset */

	      fix_new (fragP,
		       fragP->fr_fix,
		       4,
		       fragP->fr_symbol,
		       fragP->fr_offset,
		       0,
		       NO_RELOC);

	      fragP->fr_fix += 4;
	      ext = 0;
	    }
	  /* BRA */
	  else if (fragP->fr_opcode[0] == 0x60)
	    {
	      fragP->fr_opcode[0] = 0x4E;
	      fragP->fr_opcode[1] = (char) 0xF9; /* JMP  with ABSL LONG offset */
	      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		       fragP->fr_offset, 0, NO_RELOC);
	      fragP->fr_fix += 4;
	      ext = 0;
	    }
	  else
	    {
	      /* This should never happen, because if it's a conditional
	         branch and we are on a 68000, BCC68000 should have been
	         picked instead of ABRANCH. */
	      abort ();
	    }
d4416 3
a4418 2
	  fragP->fr_opcode[1] = (char) 0xff;
	  ext = 4;
d4421 4
a4424 3
    case TAB (BCC68000, LONG):
      /* only Bcc 68000 instructions can come here */
      /* change bcc into b!cc/jmp absl long */
d4430 1
a4430 1
	   Only fr_opcode[0,1] are guaranteed to work. */
d4435 13
a4447 1
	       fragP->fr_offset, 0, NO_RELOC);
a4448 1
      ext = 0;
d4450 10
a4459 3
    case TAB (DBCC, LONG):
      /* only DBcc 68000 instructions can come here */
      /* change dbcc into dbcc/jmp absl long */
d4465 2
a4466 2
      *buffer_address++ = 0x4e;	/* put in jmp long (0x4ef9) */
      *buffer_address++ = (char) 0xf9;
d4469 2
a4470 2
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
	       fragP->fr_offset, 0, NO_RELOC);
a4471 1
      ext = 0;
d4473 15
a4487 23
    case TAB (FBRANCH, SHORT):
      know ((fragP->fr_opcode[1] & 0x40) == 0);
      ext = 2;
      break;
    case TAB (FBRANCH, LONG):
      fragP->fr_opcode[1] |= 0x40;	/* Turn on LONG bit */
      ext = 4;
      break;
    case TAB (PCREL, SHORT):
      ext = 2;
      break;
    case TAB (PCREL, LONG):
      /* The thing to do here is force it to ABSOLUTE LONG, since
	PCREL is really trying to shorten an ABSOLUTE address anyway */
      /* JF FOO This code has not been tested */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       0, NO_RELOC);
      if ((fragP->fr_opcode[1] & 0x3F) != 0x3A)
	as_bad (_("Internal error (long PC-relative operand) for insn 0x%04x at 0x%lx"),
		(unsigned) fragP->fr_opcode[0],
		(unsigned long) fragP->fr_address);
      fragP->fr_opcode[1] &= ~0x3F;
      fragP->fr_opcode[1] |= 0x39;	/* Mode 7.1 */
a4488 1
      ext = 0;
d4490 1
a4490 3
    case TAB (PCLEA, SHORT):
      fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, NO_RELOC);
d4493 3
a4495 1
      ext = 2;
d4497 1
a4497 4
    case TAB (PCLEA, LONG):
      fixP = fix_new (fragP, (int) (fragP->fr_fix) + 2, 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, NO_RELOC);
      fixP->fx_pcrel_adjust = 2;
d4503 4
a4506 1
      ext = 4;
a4507 1

a4508 6
      disp += 2;
      if (!issbyte (disp))
	{
	  as_bad (_("displacement doesn't fit in one byte"));
	  disp = 0;
	}
d4511 3
a4513 2
      buffer_address[-1] = disp;
      ext = 0;
a4515 2
      disp += 2;
      assert (issword (disp));
d4520 1
a4520 2
		      fragP->fr_offset, (fragP->fr_opcode[1] & 077) == 073,
		      NO_RELOC);
d4522 1
a4522 1
      ext = 2;
a4524 5
      disp += 2;
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		      fragP->fr_offset, (fragP->fr_opcode[1] & 077) == 073,
		      NO_RELOC);
      fixP->fx_pcrel_adjust = 2;
d4528 20
a4547 1
      ext = 4;
a4549 6

  if (ext)
    {
      md_number_to_chars (buffer_address, (long) disp, (int) ext);
      fragP->fr_fix += ext;
    }
a4583 1
  register char *buffer_address = fragP->fr_fix + fragP->fr_literal;
d4587 1
a4587 1
  /* handle SZ_UNDEF first, it can be changed to BYTE or SHORT */
d4590 3
a4592 2

    case TAB (ABRANCH, SZ_UNDEF):
d4594 1
a4594 2
	if ((fragP->fr_symbol != NULL)	/* Not absolute */
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment
a4597 1
	    break;
d4599 1
a4599 9
	else if ((fragP->fr_symbol != NULL) && flag_short_refs)
	  {			/* Symbol is undefined and we want short ref */
	    fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 2;
	    frag_wane (fragP);
	    break;
	  }
	else if ((fragP->fr_symbol == 0) || !HAVE_LONG_BRANCH(current_architecture))
d4601 2
a4602 27
	    /* On 68000, or for absolute value, switch to abs long */
	    /* FIXME, we should check abs val, pick short or long */
	    if (fragP->fr_opcode[0] == 0x61)
	      {
		fragP->fr_opcode[0] = 0x4E;
		fragP->fr_opcode[1] = (char) 0xB9; /* JBSR with ABSL LONG offset */
		fix_new (fragP, fragP->fr_fix, 4,
			 fragP->fr_symbol, fragP->fr_offset, 0, NO_RELOC);
		fragP->fr_fix += 4;
		frag_wane (fragP);
	      }
	    else if (fragP->fr_opcode[0] == 0x60)
	      {
		fragP->fr_opcode[0] = 0x4E;
		fragP->fr_opcode[1] = (char) 0xF9; /* JMP  with ABSL LONG offset */
		fix_new (fragP, fragP->fr_fix, 4,
			 fragP->fr_symbol, fragP->fr_offset, 0, NO_RELOC);
		fragP->fr_fix += 4;
		frag_wane (fragP);
	      }
	    else
	      {
		/* This should never happen, because if it's a conditional
		   branch and we are on a 68000, BCC68000 should have been
		   picked instead of ABRANCH. */
		abort ();
	      }
d4605 3
a4607 7
	  {			/* Symbol is still undefined.  Make it simple */
	    fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 4;
	    fragP->fr_opcode[1] = (char) 0xff;
	    frag_wane (fragP);
	    break;
a4608 1

d4610 1
a4610 1
      }				/* case TAB(ABRANCH,SZ_UNDEF) */
d4612 1
a4612 1
    case TAB (FBRANCH, SZ_UNDEF):
d4614 2
a4615 3
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs)
d4617 1
a4617 2
	    fragP->fr_subtype = TAB (FBRANCH, SHORT);
	    fragP->fr_var += 2;
d4621 2
a4622 5
	    fix_new (fragP, (int) fragP->fr_fix, 4, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 4;
	    fragP->fr_opcode[1] |= 0x40; /* Turn on LONG bit */
	    frag_wane (fragP);
d4625 1
a4625 1
      }				/* TAB(FBRANCH,SZ_UNDEF) */
d4627 4
a4630 1
    case TAB (PCREL, SZ_UNDEF):
d4636 1
a4636 2
	    fragP->fr_subtype = TAB (PCREL, SHORT);
	    fragP->fr_var += 2;
d4640 1
a4640 2
	    fragP->fr_subtype = TAB (PCREL, LONG);
	    fragP->fr_var += 4;
d4643 1
a4643 94
      }				/* TAB(PCREL,SZ_UNDEF) */

    case TAB (BCC68000, SZ_UNDEF):
      {
	if ((fragP->fr_symbol != NULL)
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
	  {
	    fragP->fr_subtype = TAB (BCC68000, BYTE);
	    break;
	  }
	/* only Bcc 68000 instructions can come here */
	if ((fragP->fr_symbol != NULL) && flag_short_refs)
	  {
	    /* the user wants short refs, so emit one */
	    fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 2;
	  }
	else
	  {
	    /* change bcc into b!cc/jmp absl long */
	    fragP->fr_opcode[0] ^= 0x01;	/* invert bcc */
	    fragP->fr_opcode[1] = 0x06;	/* branch offset = 6 */
	    /* JF: these were fr_opcode[2,3] */
	    buffer_address[0] = 0x4e;	/* put in jmp long (0x4ef9) */
	    buffer_address[1] = (char) 0xf9;
	    fragP->fr_fix += 2;	/* account for jmp instruction */
	    fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		     fragP->fr_offset, 0, NO_RELOC);
	    fragP->fr_fix += 4;
	  }
	frag_wane (fragP);
	break;
      }				/* case TAB(BCC68000,SZ_UNDEF) */

    case TAB (DBCC, SZ_UNDEF):
      {
	if (fragP->fr_symbol != NULL
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
	  {
	    fragP->fr_subtype = TAB (DBCC, SHORT);
	    fragP->fr_var += 2;
	    break;
	  }
	/* only DBcc 68000 instructions can come here */

	if (fragP->fr_symbol != NULL && flag_short_refs)
	  {
	    /* the user wants short refs, so emit one */
	    fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 2;
	  }
	else
	  {
	    /* change dbcc into dbcc/jmp absl long */
	    /* JF: these used to be fr_opcode[2-4], which is wrong. */
	    buffer_address[0] = 0x00;	/* branch offset = 4 */
	    buffer_address[1] = 0x04;
	    buffer_address[2] = 0x60;	/* put in bra pc + ... */
	    /* JF: these were fr_opcode[5-7] */
	    buffer_address[3] = 0x06;	/* Plus 6 */
	    buffer_address[4] = 0x4e;	/* put in jmp long (0x4ef9) */
	    buffer_address[5] = (char) 0xf9;
	    fragP->fr_fix += 6;	/* account for bra/jmp instruction */
	    fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
		     fragP->fr_offset, 0, NO_RELOC);
	    fragP->fr_fix += 4;
	  }

	frag_wane (fragP);
	break;
      }				/* case TAB(DBCC,SZ_UNDEF) */

    case TAB (PCLEA, SZ_UNDEF):
      {
	if (((S_GET_SEGMENT (fragP->fr_symbol)) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs
	    || cpu_of_arch (current_architecture) < m68020
	    || cpu_of_arch (current_architecture) == mcf5200)
	  {
	    fragP->fr_subtype = TAB (PCLEA, SHORT);
	    fragP->fr_var += 2;
	  }
	else
	  {
	    fragP->fr_subtype = TAB (PCLEA, LONG);
	    fragP->fr_var += 6;
	  }
	break;
      }				/* TAB(PCLEA,SZ_UNDEF) */
d4647 1
a4647 3
	   && relaxable_symbol (fragP->fr_symbol))
	  || cpu_of_arch (current_architecture) < m68020
	  || cpu_of_arch (current_architecture) == mcf5200)
a4653 1
	  fragP->fr_var += 4;
d4657 14
d4675 1
a4675 1
  /* now that SZ_UNDEF are taken care of, check others */
d4678 4
a4681 2
    case TAB (BCC68000, BYTE):
    case TAB (ABRANCH, BYTE):
a4700 1
	      fragP->fr_var += 2;
d4707 1
d4721 1
a4721 1
   format. */
d5003 1
a5003 1
  if (!need_pass_2)		/* Never make frag if expect extra pass. */
d5866 1
a5866 1
      
d5888 1
a5888 1
      
d6690 1
d6719 2
d6723 1
a6723 1
size_t md_longopts_size = sizeof(md_longopts);
d6742 5
d6887 1
a6887 1
  fprintf(stream, _("\
d6890 3
a6892 3
-m68000 | -m68008 | -m68010 | -m68020 | -m68030 | -m68040 | -m68060\n\
 | -m68302 | -m68331 | -m68332 | -m68333 | -m68340 | -m68360\n\
 | -mcpu32 | -m5200\n\
d6897 1
a6897 1
  fprintf(stream, _("\
d6903 1
a7005 1
/* ARGSUSED */
d7039 1
a7039 1
   first extension word is stored in fx_pcrel_adjust. */
d7046 3
a7048 3
  /* Because fx_pcrel_adjust is a char, and may be unsigned, we store
     -1 as 64.  */
  adjust = fixP->fx_pcrel_adjust;
a7056 1
/*ARGSUSED*/
a7090 1
/* end of tc-m68k.c */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d30 4
d38 1
a38 1
#if (defined (OBJ_ELF) && ! defined (TE_PSOS) && ! defined (TE_LINUX)) || defined (TE_DELTA)
d51 1
a51 1
const char line_comment_chars[] = "#";
d103 28
d196 1
a196 1
static const enum m68k_register mcf5200_control_regs[] = {
d225 1
a225 1
      long foff;
d254 1
a254 1
#define cpu_of_arch(x)		((x) & (m68000up|mcf5200))
d257 4
d273 6
d283 1
a283 1
     struct m68k_incant *opcode;
d300 1
a300 1
     char width;
d330 1
a330 1
add_frag(add,off,type)
d332 1
a332 1
     long off;
d346 4
d377 2
d399 2
d404 1
d406 4
a409 1
  { m68000, "68008", 1 },
d421 2
d424 2
d428 3
d569 4
a572 1
extern void obj_coff_section ();
d646 1
a646 1
    as_fatal ("Unknown PC relative instruction");
d769 15
a783 3
  as_bad ("Can not do %d byte %s%srelocation", size,
	  pcrel ? "pc-relative " : "",
	  pic == pic_none ? "" : "pic ");
d797 2
a798 1
  if (S_IS_EXTERNAL (fixP->fx_addsy))
d818 4
d885 1
a885 1
			    "Cannot make %s relocation PC relative",
d909 3
a911 3
  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  assert (reloc != 0);
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d937 21
d964 1
a964 1
void
d970 1
a970 1
  register struct m68k_incant *opcode;
a977 1
  char *crack_operand ();
d998 1
a998 1
      the_ins.error = "No operator";
d1015 1
a1015 1
  opcode = (struct m68k_incant *) hash_find (op_hash, instring);
d1028 1
a1028 1
      the_ins.error = "Unknown operator";
d1133 1
a1133 1
		case '`':
d1136 4
d1141 12
d1157 1
d1160 17
d1178 61
d1241 16
d1258 1
d1271 5
d1485 5
d1495 10
a1583 8
		  else if (opP->mode == ABSL
			   && opP->disp.size == SIZE_UNSPEC
			   && opP->disp.exp.X_op == O_constant)
		    {
		      /* This is what the MRI REG pseudo-op generates.  */
		      opP->mode = REGLST;
		      opP->mask = opP->disp.exp.X_add_number;
		    }
d1766 13
d1803 1
a1803 1
		      "invalid instruction for this architecture; needs ");
d1808 1
a1808 1
		  strcpy (cp, "fpu (68040, 68060 or 68881/68882)");
d1811 1
a1811 1
		  strcpy (cp, "mmu (68030 or 68851)");
d1814 1
a1814 1
		  strcpy (cp, "68020 or higher");
d1817 1
a1817 1
		  strcpy (cp, "68000 or higher");
d1820 1
a1820 1
		  strcpy (cp, "68010 or higher");
d1825 2
a1826 1
		    for (idx = 0; idx < sizeof (archs) / sizeof (archs[0]);
d1849 1
a1849 1
	    the_ins.error = "operands mismatch";
d1881 8
a1888 1
	case '`':
d1906 1
a1906 1
		    opP->error = "operand out of range";
d1912 1
a1912 1
		    opP->error = "operand out of range";
d1918 1
a1918 1
		    opP->error = "operand out of range";
d1975 1
a1975 1
		      as_warn ("Bignum too big for %c format; truncated",
d2036 2
a2037 1
			   && cpu_of_arch (current_architecture) >= m68020)
d2040 2
a2041 1
		  if (cpu_of_arch (current_architecture) < m68020)
d2043 1
a2043 1
		      "displacement too large for this architecture; needs 68020 or higher";
d2142 3
a2144 2
		  if (opP->index.size == SIZE_UNSPEC
		      || opP->index.size == SIZE_LONG)
d2150 1
a2150 1
			  && current_architecture == mcf5200))
d2153 1
a2153 1
			"scale factor invalid on this architecture; needs cpu32 or 68020 or higher";
d2156 4
d2191 1
d2211 1
a2211 1
				as_warn ("Forcing byte displacement");
d2213 1
a2213 1
				opP->error = "byte displacement out of range";
d2229 6
d2257 2
a2258 1
	      if (cpu_of_arch (current_architecture) < m68020)
d2260 1
a2260 1
		  "invalid operand mode for this architecture; needs 68020 or higher";
d2284 1
a2284 1
		  as_warn (":b not permitted; defaulting to :w");
d2298 1
a2298 1
		    opP->error = "invalid operand mode for this architecture; needs 68020 or higher";
d2318 1
a2318 1
		      as_warn (":b not permitted; defaulting to :w");
a2366 2
		  /* Don't generate pc relative code on 68010 and
		     68000.  */
d2376 1
a2376 1
		      && cpu_of_arch (current_architecture) >= m68020
d2396 3
d2411 1
a2411 1
	      as_bad ("unknown/incorrect operand");
d2444 1
a2444 1
		opP->error = "out of range";
d2450 7
d2459 1
a2459 1
		opP->error = "out of range";
d2466 1
a2466 1
		opP->error = "out of range";
d2483 1
d2515 2
a2516 2
	      if (cpu_of_arch (current_architecture) < m68020)
		as_warn ("Can't use long branches on 68000/68010");
d2539 1
a2539 1
	      if (((cpu_of_arch (current_architecture) < m68020)
d2576 1
a2576 1
		  add_frag ((symbolS *) 0, (long) 0, TAB (FBRANCH, LONG));
d2583 2
a2584 2
		  /* add_frag((symbolS *) 0, offs(&opP->disp),
		     TAB(FBRANCH,SHORT)); */
d2604 1
a2604 1
	      as_warn ("Expression out of range, using 0");
d2614 3
d2621 4
d2716 1
a2716 1
		as_bad ("Floating point register in register list");
d2722 1
a2722 1
		as_bad ("Wrong register in floating-point reglist");
d2732 1
a2732 1
		as_bad ("Floating point register in register list");
d2738 1
a2738 1
		as_bad ("incorrect register in reglist");
d2744 1
a2744 1
		as_bad ("wrong register in floating-point reglist");
d2756 1
a2756 1
		    ? 0x20 + opP->reg - DATA
d2820 1
a2820 1
	      as_fatal ("failed sanity check");
d2946 2
d2952 5
d3096 24
d3122 1
a3122 1
      as_fatal ("failed sanity check.");
d3151 1
a3151 1
      as_fatal ("failed sanity check.");
d3185 1
a3185 1
		  opP->error = "Extra )";
d3196 1
a3196 1
      opP->error = "Missing )";
d3213 1
a3213 1
	as_bad ("Missing operand");
d3215 9
d3232 1
a3232 1
void
d3234 1
a3234 1
     char *regname;
d3321 4
d3429 37
d3469 1
a3469 1
void
d3545 1
a3545 1
      as_bad ("%s -- statement `%s' ignored", er, str);
d3549 7
d3582 1
d3589 1
a3589 1
	      as_fatal ("Don't know how to figure width of %c in md_assemble()",
d3602 2
d3706 1
a3706 1
  register unsigned int i;
d3713 2
a3714 1
      m68k_rel32 = 0;
d3748 1
a3748 1
	as_fatal ("Internal Error:  Can't hash %s: %s", ins->name, retval);
d3757 1
a3757 1
	as_fatal ("Internal Error: Can't find %s in hash table", name);
d3760 1
a3760 1
	as_fatal ("Internal Error: Can't hash %s: %s", alias, retval);
d3787 3
a3789 1
      for (i = 0; i < sizeof mri_aliases / sizeof mri_aliases[0]; i++)
d3795 1
a3795 1
	    as_fatal ("Internal Error: Can't find %s in hash table", name);
d3798 1
a3798 1
	    as_fatal ("Internal Error: Can't hash %s: %s", alias, retval);
d3802 1
a3802 1
  for (i = 0; i < sizeof (mklower_table); i++)
d3805 1
a3805 1
  for (i = 0; i < sizeof (notend_table); i++)
d3902 3
a3904 1
      control_regs = mcf5200_control_regs;
d3926 1
a3926 1
	  as_bad ("unrecognized default cpu `%s' ???", TARGET_CPU);
d3938 1
a3938 1
	  as_warn ("68040 and 68851 specified; mmu instructions may assemble incorrectly");
d3958 1
a3958 1
    as_bad ("options for 68881 and no-68881 both given");
d3960 1
a3960 1
    as_bad ("options for 68851 and no-68851 both given");
d3977 2
a3978 1
  if (cpu_of_arch (current_architecture) < m68020)
d3981 19
d4001 38
d4056 2
a4057 1
      m68k_rel32 = 0;
d4073 2
a4074 1
      m68k_rel32 = 1;
a4095 1
  char *atof_ieee ();
d4125 1
a4125 1
      return "Bad call to MD_ATOF()";
d4173 5
d4182 6
d4227 1
a4227 1
  if (!fixP->fx_pcrel)
d4232 1
a4232 1
    as_bad_where (fixP->fx_file, fixP->fx_line, "value out of range");
d4236 8
a4243 2
     different opcodes (branches with longer offsets).  */
  if (fixP->fx_pcrel
d4248 1
a4248 1
    as_bad_where (fixP->fx_file, fixP->fx_line, "invalid byte branch offset");
d4273 1
a4273 1
void
d4296 1
a4296 1
  disp += fragP->fr_symbol->sy_frag->fr_address;
d4305 1
a4305 1
	as_bad ("short branch with zero offset: use :w");
d4320 1
a4320 1
      if (cpu_of_arch (current_architecture) < m68020)
d4351 4
a4354 1
	      as_bad ("Long branch offset not supported.");
d4415 1
a4415 1
	as_bad ("Internal error (long PC-relative operand) for insn 0x%04x at 0x%lx",
d4446 1
a4446 1
	  as_bad ("displacement doesn't fit in one byte");
d4490 2
a4491 2
     object_headers *headers;
     segT sec;
d4501 2
a4502 2
     bfd *abfd;
     segT sec;
d4529 2
a4530 1
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment)
d4535 9
a4543 1
	else if ((fragP->fr_symbol == 0) || (cpu_of_arch (current_architecture) < m68020))
d4567 4
a4570 1
		as_warn ("Long branch offset to extern symbol not supported.");
d4588 3
a4590 1
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment || flag_short_refs)
d4608 3
a4610 3
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	    || flag_short_refs
	    || cpu_of_arch (current_architecture) < m68020)
d4626 2
a4627 1
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment)
d4633 1
a4633 3
	/* change bcc into b!cc/jmp absl long */
	fragP->fr_opcode[0] ^= 0x01;	/* invert bcc */
	if (flag_short_refs)
d4635 1
a4635 5
	    fragP->fr_opcode[1] = 0x04;	/* branch offset = 6 */
	    /* JF: these were fr_opcode[2,3] */
	    buffer_address[0] = 0x4e;	/* put in jmp long (0x4ef9) */
	    buffer_address[1] = (char) 0xf8;
	    fragP->fr_fix += 2;	/* account for jmp instruction */
d4637 1
a4637 1
		     fragP->fr_offset, 0, NO_RELOC);
d4642 2
d4659 3
a4661 1
	if (fragP->fr_symbol != NULL && S_GET_SEGMENT (fragP->fr_symbol) == segment)
a4667 5
	/* change dbcc into dbcc/jmp absl long */
	/* JF: these used to be fr_opcode[2-4], which is wrong. */
	buffer_address[0] = 0x00;	/* branch offset = 4 */
	buffer_address[1] = 0x04;
	buffer_address[2] = 0x60;	/* put in bra pc + ... */
d4669 1
a4669 1
	if (flag_short_refs)
d4671 1
a4671 5
	    /* JF: these were fr_opcode[5-7] */
	    buffer_address[3] = 0x04;	/* plus 4 */
	    buffer_address[4] = 0x4e;	/* Put in Jump Word */
	    buffer_address[5] = (char) 0xf8;
	    fragP->fr_fix += 6;	/* account for bra/jmp instruction */
d4673 1
a4673 1
		     fragP->fr_offset, 0, NO_RELOC);
d4678 5
d4699 2
a4700 1
	if ((S_GET_SEGMENT (fragP->fr_symbol)) == segment
d4702 2
a4703 1
	    || cpu_of_arch (current_architecture) < m68020)
d4717 4
a4720 2
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment
	  || cpu_of_arch (current_architecture) < m68020)
d4749 1
d4752 2
a4753 3
	  for (l = fragP->fr_next;
	       l != fragP->fr_symbol->sy_frag;
	       l = l->fr_next)
d4756 1
a4756 1
	  if (l == fragP->fr_symbol->sy_frag)
d4841 2
a4842 2
     fragS *frag;
     symbolS *to_symbol;
d4861 1
a4861 1
  if (cpu_of_arch (current_architecture) < m68020)
d4909 1
a4909 1
	  as_warn ("expression out of range: defaulting to 1");
d4920 1
a4920 1
	      as_warn ("expression out of range: defaulting to 1");
d4952 1
a4952 1
	      as_warn ("expression out of range: defaulting to 0");
d4985 1
a4985 1
	  as_warn ("Can't deal with expression; defaulting to %ld",
d4997 1
a4997 1
	  as_warn ("Can't deal with expression; defaulting to %ld",
d5011 1
a5011 1
	    as_warn ("expression doesn't fit in BYTE");
d5015 1
a5015 1
	    as_warn ("expression doesn't fit in WORD");
a5023 1
void demand_empty_rest_of_line ();	/* Hate those extra verbose names */
d5027 1
a5027 1
     int ignore;
d5035 1
a5035 1
     int ignore;
d5043 1
a5043 1
     int ignore;
d5054 1
a5054 1
     int ignore;
d5062 1
a5062 1
    frag_align (temp, (int) temp_fill);
d5064 1
d5069 1
a5069 1
     int ignore;
d5076 12
d5098 5
a5102 1
  c = get_symbol_end ();
d5108 1
a5108 1
      as_bad ("%s: unrecognized processor name", s);
d5125 5
a5129 1
      c = get_symbol_end ();
d5145 1
a5145 1
     int ignore;
d5162 1
a5162 1
     int ignore;
d5173 1
a5173 1
	as_bad ("bad coprocessor id");
d5179 1
a5179 1
      as_bad ("unrecognized fopt option");
d5266 1
a5266 1
#define OPTCOUNT (sizeof opt_table / sizeof opt_table[0])
d5272 1
a5272 1
     int ignore;
d5313 1
a5313 1
		    as_bad ("option `%s' may not be negated", s);
d5324 1
a5324 1
	  as_bad ("option `%s' not recognized", s);
d5340 2
a5341 2
     int arg;
     int on;
d5352 2
a5353 2
     int arg;
     int on;
d5357 1
a5357 1
      as_bad ("bad format of OPT NEST=depth");
d5369 2
a5370 2
     int arg;
     int on;
d5386 1
a5386 1
     int arg;
d5396 1
a5396 1
     int arg;
d5409 1
a5409 1
     int ignore;
d5414 1
a5414 1
  unsigned long mask;
d5420 1
a5420 1
      as_bad ("missing label");
d5444 1
a5444 1
	as_bad ("bad register list");
d5446 1
a5446 1
	as_bad ("bad register list: %s", rop.error);
d5473 1
a5473 1
      as_bad ("bad register list");
d5478 3
a5480 3
  S_SET_SEGMENT (line_label, absolute_section);
  S_SET_VALUE (line_label, mask);
  line_label->sy_frag = &zero_address_frag;
d5513 1
a5513 1
     int ignore;
d5538 1
a5538 1
     int ignore;
d5544 1
a5544 1
      as_bad ("restore without save");
d5617 1
d5633 18
d5721 1
a5721 1
      as_bad ("syntax error in structured control directive");
d5772 1
a5772 1
      as_bad ("missing condition code in structured control directive");
d5943 1
a5943 1
      md_assemble (buf);
d5956 1
a5956 1
  md_assemble (buf);
d6070 1
a6070 1
    as_bad ("syntax error in structured control directive");
d6104 1
a6104 1
	  as_bad ("missing then");
d6186 1
a6186 1
      as_bad ("else without matching if");
d6197 1
a6197 1
  md_assemble (buf);
d6215 1
a6215 1
     int ignore;
d6220 1
a6220 1
      as_bad ("endi without matching if");
d6261 1
a6261 1
      as_bad ("break outside of structured loop");
d6270 1
a6270 1
  md_assemble (buf);
d6300 1
a6300 1
      as_bad ("next outside of structured loop");
d6309 1
a6309 1
  md_assemble (buf);
d6352 1
a6352 1
      as_bad ("missing =");
d6390 1
a6390 1
      as_bad ("missing to or downto");
d6426 1
a6426 1
      as_bad ("missing do");
d6460 1
a6460 1
	  as_bad ("missing do");
d6498 1
a6498 1
  md_assemble (buf);
d6516 1
a6516 1
  md_assemble (buf);
d6525 1
a6525 1
  md_assemble (buf);
d6558 1
a6558 1
     int ignore;
d6563 1
a6563 1
      as_bad ("endf without for");
d6570 1
a6570 1
  md_assemble (mri_control_stack->incr);
d6573 1
a6573 1
  md_assemble (mri_control_stack->incr);
d6594 1
a6594 1
     int ignore;
d6619 1
a6619 1
      as_bad ("until without repeat");
d6670 1
a6670 1
      as_bad ("missing do");
d6699 1
a6699 1
     int ignore;
d6706 1
a6706 1
      as_bad ("endw without while");
d6713 1
a6713 1
  md_assemble (buf);
d6768 8
d6822 1
a6822 1
	      as_bad ("unrecognized option `%s'", oarg);
d6867 1
a6867 1
	      as_bad ("unrecognized architecture specification `%s'", arg);
d6908 18
d6937 1
a6937 1
  fprintf(stream, "\
d6946 2
a6947 2
			[default yes for 68020, 68030, and cpu32]\n");
  fprintf(stream, "\
d6955 6
a6960 1
--bitwise-or		do not treat `|' as a comment character\n");
d6991 1
a6991 1
	  printf ("Error %s in %s\n", the_ins.error, buf);
d6995 1
a6995 1
	  printf ("Opcode(%d.%s): ", the_ins.numo, the_ins.args);
d7058 1
a7058 1
     char *name;
d7066 1
a7066 1
     segT segment;
d7069 15
a7083 1
  return size;			/* Byte alignment is fine */
d7105 2
d7110 1
a7110 1
     symbolS *ignore;
d7131 10
a7141 1

@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d262 1
a262 1
  the_ins.reloc[the_ins.nrel].n = (((width)=='B')
d3027 7
a3033 5
  /* mcf5200 versions of same */
  { "acr2", ITT0 },		/* Access Control Unit 2 */
  { "acr3", ITT1 },		/* Access Control Unit 3 */
  { "acr0", DTT0 },		/* Access Control Unit 0 */
  { "acr1", DTT1 },		/* Access Control Unit 1 */
d3213 1
a3213 1
	      n = 2;
d3504 33
d3601 1
a3601 27
  switch (cpu_of_arch (current_architecture))
    {
    case m68000:
      control_regs = m68000_control_regs;
      break;
    case m68010:
      control_regs = m68010_control_regs;
      break;
    case m68020:
    case m68030:
      control_regs = m68020_control_regs;
      break;
    case m68040:
      control_regs = m68040_control_regs;
      break;
    case m68060:
      control_regs = m68060_control_regs;
      break;
    case cpu32:
      control_regs = cpu32_control_regs;
      break;
    case mcf5200:
      control_regs = mcf5200_control_regs;
      break;
    default:
      abort ();
    }
d4650 3
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d163 5
d221 1
a221 1
#define cpu_of_arch(x)		((x) & m68000up)
d349 1
d361 1
d765 43
a807 1
    code = fixp->fx_r_type;
d839 1
a839 1
  else if ((fixp->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0)
a844 4
  else
    reloc->addend = (fixp->fx_offset
		     + (fixp->fx_pcrel_adjust == 64
			? -1 : fixp->fx_pcrel_adjust));
d995 1
d998 1
a998 4
	{
	  ++losing;
	  ok_arch |= opcode->m_arch;
	}
d1379 3
a1381 1
		  if (opP->mode != DREG && opP->mode != IMMED)
d1562 1
a1562 1
	      int len;
d1604 1
a1604 2
	      len = cp - buf + 1;
	      cp = malloc (len);
d1897 4
a1900 1
		  if (cpu_of_arch (current_architecture) < m68020)
d1902 2
a1903 5
		      if (opP->index.scale != 1)
			{
			  opP->error =
			    "scale factor invalid on this architecture; needs 68020 or higher";
			}
d2035 2
d2410 12
d3003 2
a3004 3
  { "usp", USP },
  { "isp", ISP },
  { "sfc", SFC },
d3006 1
a3006 1
  { "dfc", DFC },
d3008 2
a3009 2
  { "cacr", CACR },
  { "caar", CAAR },
d3011 28
a3038 1
  { "vbr", VBR },
a3039 9
  { "msp", MSP },
  { "itt0", ITT0 },
  { "itt1", ITT1 },
  { "dtt0", DTT0 },
  { "dtt1", DTT1 },
  { "mmusr", MMUSR },
  { "tc", TC },
  { "srp", SRP },
  { "urp", URP },
d3043 6
d3461 14
d3587 3
d6370 2
a6371 1
	char *n, *t, *s;
d6399 1
a6399 1
 | -mcpu32\n\
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
a21 1
#define  NO_RELOC 0
d29 6
a34 4
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful */
#if defined (OBJ_ELF) || defined (TE_DELTA)
const char comment_chars[] = "|#";
d36 1
a36 1
const char comment_chars[] = "|";
d66 2
a67 1
   references.  */
d79 3
d207 5
d265 3
d331 1
d335 9
a343 9
  { m68000, "68000" },
  { m68010, "68010" },
  { m68020, "68020" },
  { m68030, "68030" },
  { m68040, "68040" },
  { m68060, "68060" },
  { cpu32,  "cpu32" },
  { m68881, "68881" },
  { m68851, "68851" },
d346 16
a361 16
  { m68020, "68k" },
  { m68000, "68302" },
  { m68000, "68008" },
  { m68000, "68ec000" },
  { m68000, "68hc000" },
  { m68000, "68hc001" },
  { m68020, "68ec020" },
  { m68030, "68ec030" },
  { m68040, "68ec040" },
  { cpu32,  "68330" },
  { cpu32,  "68331" },
  { cpu32,  "68332" },
  { cpu32,  "68333" },
  { cpu32,  "68340" },
  { cpu32,  "68360" },
  { m68881, "68882" },
d444 1
a444 1
#ifdef TE_SUN3
d450 2
d516 3
d520 1
d605 139
d757 4
d762 2
a763 2
  switch (F (fixp->fx_size, fixp->fx_pcrel))
    {
d765 9
a773 8
      MAP (1, 0, BFD_RELOC_8);
      MAP (2, 0, BFD_RELOC_16);
      MAP (4, 0, BFD_RELOC_32);
      MAP (1, 1, BFD_RELOC_8_PCREL);
      MAP (2, 1, BFD_RELOC_16_PCREL);
      MAP (4, 1, BFD_RELOC_32_PCREL);
    default:
      abort ();
d775 2
d782 1
d787 14
d1544 2
a1545 1
			if (archs[idx].arch & ok_arch)
d1748 3
d1759 5
a1763 8
#if 0
			  addword (0x0170);
			  add_fix ('l', &opP->disp, 1, 2);
			  addword (0), addword (0);
#else
			  add_frag (adds (&opP->disp),
				    offs (&opP->disp),
				    TAB (PCLEA, SZ_UNDEF));
d1765 12
a1776 1
			  break;
d1922 7
a1928 1
			       && subs (&opP->disp) == NULL)
d2064 5
d2138 2
a2139 1
		the_ins.reloc[the_ins.nrel - 1].n = (opcode->m_codenum) * 2;
d2209 7
d3149 2
a3150 1
			      NO_RELOC);
d3194 2
a3195 1
			      NO_RELOC);
d3231 2
a3232 1
			  NO_RELOC);
d3399 6
d3500 37
d3628 9
d4167 21
a4187 7
      /* We can't do a short jump to the next instruction,
	   so we force word mode.  */
      if (fragP->fr_symbol && S_GET_VALUE (fragP->fr_symbol) == 0 &&
	  fragP->fr_symbol->sy_frag == fragP->fr_next)
	{
	  fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	  fragP->fr_var += 2;
d6134 3
d6151 2
d6257 1
d6260 7
d6268 14
a6281 1
    case 'V':
d6312 2
a6313 1
			recognize register names without prefix character\n");
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d22 1
d30 4
a33 6
/* This string holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  The macro
   tc_comment_chars points to this.  We use this, rather than the
   usual comment_chars, so that the --bitwise-or option will work.  */
#if (defined (OBJ_ELF) && ! defined (TE_PSOS) && ! defined (TE_LINUX)) || defined (TE_DELTA)
const char *m68k_comment_chars = "|#";
d35 1
a35 1
const char *m68k_comment_chars = "|";
d65 1
a65 2
   references.  Not implemented.  For ELF there are other means 
   to denote pic relocations.  */
a76 3
/* Whether --register-prefix-optional was used on the command line.  */
static int reg_prefix_optional_seen;

a201 5
#ifdef OBJ_ELF
      /* Whether this expression needs special pic relocation, and if
	 so, which.  */
      enum pic_relocation pic_reloc;
#endif
a254 3
#ifdef OBJ_ELF
  the_ins.reloc[the_ins.nrel].pic_reloc = exp->pic_reloc;
#endif
a317 1
  int alias;
d321 9
a329 9
  { m68000, "68000", 0 },
  { m68010, "68010", 0 },
  { m68020, "68020", 0 },
  { m68030, "68030", 0 },
  { m68040, "68040", 0 },
  { m68060, "68060", 0 },
  { cpu32,  "cpu32", 0 },
  { m68881, "68881", 0 },
  { m68851, "68851", 0 },
d332 16
a347 16
  { m68020, "68k", 1 },
  { m68000, "68302", 1 },
  { m68000, "68008", 1 },
  { m68000, "68ec000", 1 },
  { m68000, "68hc000", 1 },
  { m68000, "68hc001", 1 },
  { m68020, "68ec020", 1 },
  { m68030, "68ec030", 1 },
  { m68040, "68ec040", 1 },
  { cpu32,  "68330", 1 },
  { cpu32,  "68331", 1 },
  { cpu32,  "68332", 1 },
  { cpu32,  "68333", 1 },
  { cpu32,  "68340", 1 },
  { cpu32,  "68360", 1 },
  { m68881, "68882", 1 },
d430 1
a430 1
#if defined (TE_SUN3) || defined (OBJ_ELF)
a435 2
  {"extend", float_cons, 'x'},
  {"ldouble", float_cons, 'x'},
a499 3
#ifdef OBJ_ELF
  {"align", s_align_bytes, 0},
#else
a500 1
#endif
a584 139
#ifdef OBJ_ELF

/* Compute the relocation code for a fixup of SIZE bytes, using pc
   relative relocation if PCREL is non-zero.  PIC says whether a special
   pic relocation was requested.  */

static bfd_reloc_code_real_type get_reloc_code
  PARAMS ((int, int, enum pic_relocation));

static bfd_reloc_code_real_type
get_reloc_code (size, pcrel, pic)
     int size;
     int pcrel;
     enum pic_relocation pic;
{
  switch (pic)
    {
    case pic_got_pcrel:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_GOT_PCREL;
	case 2:
	  return BFD_RELOC_16_GOT_PCREL;
	case 4:
	  return BFD_RELOC_32_GOT_PCREL;
	}
      break;

    case pic_got_off:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_GOTOFF;
	case 2:
	  return BFD_RELOC_16_GOTOFF;
	case 4:
	  return BFD_RELOC_32_GOTOFF;
	}
      break;

    case pic_plt_pcrel:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_PLT_PCREL;
	case 2:
	  return BFD_RELOC_16_PLT_PCREL;
	case 4:
	  return BFD_RELOC_32_PLT_PCREL;
	}
      break;

    case pic_plt_off:
      switch (size)
	{
	case 1:
	  return BFD_RELOC_8_PLTOFF;
	case 2:
	  return BFD_RELOC_16_PLTOFF;
	case 4:
	  return BFD_RELOC_32_PLTOFF;
	}
      break;

    case pic_none:
      if (pcrel)
	{
	  switch (size)
	    {
	    case 1:
	      return BFD_RELOC_8_PCREL;
	    case 2:
	      return BFD_RELOC_16_PCREL;
	    case 4:
	      return BFD_RELOC_32_PCREL;
	    }
	}
      else
	{
	  switch (size)
	    {
	    case 1:
	      return BFD_RELOC_8;
	    case 2:
	      return BFD_RELOC_16;
	    case 4:
	      return BFD_RELOC_32;
	    }
	}
    }

  as_bad ("Can not do %d byte %s%srelocation", size,
	  pcrel ? "pc-relative " : "",
	  pic == pic_none ? "" : "pic ");
  return BFD_RELOC_NONE;
}

/* Here we decide which fixups can be adjusted to make them relative
   to the beginning of the section instead of the symbol.  Basically
   we need to make sure that the dynamic relocations are done
   correctly, so in some cases we force the original symbol to be
   used.  */
int
tc_m68k_fix_adjustable (fixP)
     fixS *fixP;
{
  /* Prevent all adjustments to global symbols. */
  if (S_IS_EXTERNAL (fixP->fx_addsy))
    return 0;

  /* adjust_reloc_syms doesn't know about the GOT */
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_8_GOT_PCREL:
    case BFD_RELOC_16_GOT_PCREL:
    case BFD_RELOC_32_GOT_PCREL:
    case BFD_RELOC_8_GOTOFF:
    case BFD_RELOC_16_GOTOFF:
    case BFD_RELOC_32_GOTOFF:
    case BFD_RELOC_8_PLT_PCREL:
    case BFD_RELOC_16_PLT_PCREL:
    case BFD_RELOC_32_PLT_PCREL:
    case BFD_RELOC_8_PLTOFF:
    case BFD_RELOC_16_PLTOFF:
    case BFD_RELOC_32_PLTOFF:
      return 0;

    default:
      return 1;
    }
}

#else /* !OBJ_ELF */

#define get_reloc_code(SIZE,PCREL,OTHER) NO_RELOC

#endif /* OBJ_ELF */

d598 2
a599 3
  if (fixp->fx_r_type != BFD_RELOC_NONE)
    code = fixp->fx_r_type;
  else
a600 3
#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
      switch (F (fixp->fx_size, fixp->fx_pcrel))
	{
d602 8
a609 9
	  MAP (1, 0, BFD_RELOC_8);
	  MAP (2, 0, BFD_RELOC_16);
	  MAP (4, 0, BFD_RELOC_32);
	  MAP (1, 1, BFD_RELOC_8_PCREL);
	  MAP (2, 1, BFD_RELOC_16_PCREL);
	  MAP (4, 1, BFD_RELOC_32_PCREL);
	default:
	  abort ();
	}
a610 2
#undef F
#undef MAP
a615 1
#ifndef OBJ_ELF
a619 14
#else
  if (!fixp->fx_pcrel)
    reloc->addend = fixp->fx_addnumber;
  else if ((fixp->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0)
    reloc->addend = (section->vma
		     + (fixp->fx_pcrel_adjust == 64
			? -1 : fixp->fx_pcrel_adjust)
		     + fixp->fx_addnumber
		     + md_pcrel_from (fixp));
  else
    reloc->addend = (fixp->fx_offset
		     + (fixp->fx_pcrel_adjust == 64
			? -1 : fixp->fx_pcrel_adjust));
#endif
d1363 1
a1363 2
			if ((archs[idx].arch & ok_arch)
			    && ! archs[idx].alias)
a1565 3
		  if (cpu_of_arch (current_architecture) < m68020)
		    opP->error =
		      "displacement too large for this architecture; needs 68020 or higher";
d1574 8
a1581 5
			  if (opP->disp.size == SIZE_LONG
#ifdef OBJ_ELF
			      /* If the displacement needs pic
				 relocation it cannot be relaxed.  */
			      || opP->disp.pic_reloc != pic_none
d1583 1
a1583 12
			      )
			    {
			      addword (0x0170);
			      add_fix ('l', &opP->disp, 1, 2);
			    }
			  else
			    {
			      add_frag (adds (&opP->disp),
					offs (&opP->disp),
					TAB (PCLEA, SZ_UNDEF));
			      break;
			    }
d1729 1
a1729 7
			       && subs (&opP->disp) == NULL
#ifdef OBJ_ELF
			       /* If the displacement needs pic
				  relocation it cannot be relaxed.  */
			       && opP->disp.pic_reloc == pic_none
#endif
			       )
a1864 5
#ifdef OBJ_ELF
		      /* If the displacement needs pic relocation it
			 cannot be relaxed.  */
		      && opP->disp.pic_reloc == pic_none
#endif
d1934 1
a1934 2
		the_ins.reloc[the_ins.nrel - 1].n =
		  (opcode->m_codenum) * 2 + 1;
a2003 7
#ifdef OBJ_ELF
	      /* If the displacement needs pic relocation it cannot be
		 relaxed.  */
	      if (opP->disp.pic_reloc != pic_none)
		goto long_branch;
#endif

d2937 1
a2937 2
			      get_reloc_code (n, the_ins.reloc[m].pcrel,
					      the_ins.reloc[m].pic_reloc));
d2981 1
a2981 2
			      get_reloc_code (wid, the_ins.reloc[m].pcrel,
					      the_ins.reloc[m].pic_reloc));
d3017 1
a3017 2
			  get_reloc_code (wid, the_ins.reloc[m].pcrel,
					  the_ins.reloc[m].pic_reloc));
a3183 6

#ifdef OBJ_ELF
  record_alignment (text_section, 2);
  record_alignment (data_section, 2);
  record_alignment (bss_section, 2);
#endif
a3278 37
/* This is called if we go in or out of MRI mode because of the .mri
   pseudo-op.  */

void
m68k_mri_mode_change (on)
     int on;
{
  if (on)
    {
      if (! flag_reg_prefix_optional)
	{
	  flag_reg_prefix_optional = 1;
#ifdef REGISTER_PREFIX
	  init_regtable ();
#endif
	}
      m68k_abspcadd = 1;
      m68k_rel32 = 0;
    }
  else
    {
      if (! reg_prefix_optional_seen)
	{
#ifdef REGISTER_PREFIX_OPTIONAL
	  flag_reg_prefix_optional = REGISTER_PREFIX_OPTIONAL;
#else
	  flag_reg_prefix_optional = 0;
#endif
#ifdef REGISTER_PREFIX
	  init_regtable ();
#endif
	}
      m68k_abspcadd = 0;
      m68k_rel32 = 1;
    }
}

a3369 9
#ifdef OBJ_ELF
  if (fixP->fx_addsy)
    {
      memset (buf, 0, fixP->fx_size);
      fixP->fx_addnumber = val;	/* Remember value for emit_reloc */
      return;
    }
#endif

d3900 7
a3906 21
      /* We can't do a short jump to the next instruction, so in that
	 case we force word mode.  At this point S_GET_VALUE should
	 return the offset of the symbol within its frag.  If the
	 symbol is at the start of a frag, and it is the next frag
	 with any data in it (usually this is just the next frag, but
	 assembler listings may introduce empty frags), we must use
	 word mode.  */
      if (fragP->fr_symbol && S_GET_VALUE (fragP->fr_symbol) == 0)
	{
	  fragS *l;

	  for (l = fragP->fr_next;
	       l != fragP->fr_symbol->sy_frag;
	       l = l->fr_next)
	    if (l->fr_fix + l->fr_var != 0)
	      break;
	  if (l == fragP->fr_symbol->sy_frag)
	    {
	      fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
	      fragP->fr_var += 2;
	    }
a5852 3
 *	--bitwise-or
 *		Permit `|' to be used in expressions.
 *
a5866 2
#define OPTION_BITWISE_OR (OPTION_MD_BASE + 2)
  {"bitwise-or", no_argument, NULL, OPTION_BITWISE_OR},
a5970 1
      reg_prefix_optional_seen = 1;
d5973 1
a5973 1
      /* -V: SVR4 argument to print version ID.  */
a5974 20
      print_version_id ();
      break;

      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

    case OPTION_BITWISE_OR:
      {
	char *n, *t, *s;

	n = (char *) xmalloc (strlen (m68k_comment_chars) + 1);
	t = n;
	for (s = m68k_comment_chars; *s != '\0'; s++)
	  if (*s != '|')
	    *t++ = *s;
	*t = '\0';
	m68k_comment_chars = n;
      }
d6005 1
a6005 2
			recognize register names without prefix character\n\
--bitwise-or		do not treat `|' as a comment character\n");
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a162 5
static const enum m68k_register mcf5200_control_regs[] = {
  CACR, TC, ITT0, ITT1, DTT0, DTT1, VBR, ROMBAR, 
  RAMBAR0, RAMBAR1, MBAR,
  0
};
d216 1
a216 1
#define cpu_of_arch(x)		((x) & (m68000up|mcf5200))
a343 1
  { mcf5200, "5200", 0 },
a354 1
  { m68060, "68ec060", 1 },
d758 1
a758 43
    {
      code = fixp->fx_r_type;

      /* Since DIFF_EXPR_OK is defined in tc-m68k.h, it is possible
         that fixup_segment converted a non-PC relative reloc into a
         PC relative reloc.  In such a case, we need to convert the
         reloc code.  */
      if (fixp->fx_pcrel)
	{
	  switch (code)
	    {
	    case BFD_RELOC_8:
	      code = BFD_RELOC_8_PCREL;
	      break;
	    case BFD_RELOC_16:
	      code = BFD_RELOC_16_PCREL;
	      break;
	    case BFD_RELOC_32:
	      code = BFD_RELOC_32_PCREL;
	      break;
	    case BFD_RELOC_8_PCREL:
	    case BFD_RELOC_16_PCREL:
	    case BFD_RELOC_32_PCREL:
	    case BFD_RELOC_8_GOT_PCREL:
	    case BFD_RELOC_16_GOT_PCREL:
	    case BFD_RELOC_32_GOT_PCREL:
	    case BFD_RELOC_8_GOTOFF:
	    case BFD_RELOC_16_GOTOFF:
	    case BFD_RELOC_32_GOTOFF:
	    case BFD_RELOC_8_PLT_PCREL:
	    case BFD_RELOC_16_PLT_PCREL:
	    case BFD_RELOC_32_PLT_PCREL:
	    case BFD_RELOC_8_PLTOFF:
	    case BFD_RELOC_16_PLTOFF:
	    case BFD_RELOC_32_PLTOFF:
	      break;
	    default:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    "Cannot make %s relocation PC relative",
			    bfd_get_reloc_code_name (code));
	    }
	}
    }
d790 1
a790 1
  else
d796 4
a949 1
      ok_arch |= opcode->m_arch;
d952 4
a955 1
	++losing;
d1336 1
a1336 3
		  if (opP->mode != DREG
		      && opP->mode != IMMED
		      && opP->mode != ABSL)
d1517 1
a1517 1

d1559 2
a1560 1
	      cp = xmalloc (strlen (buf) + 1);
d1853 1
a1853 4
		  if ((opP->index.scale != 1 
		       && cpu_of_arch (current_architecture) < m68020)
		      || (opP->index.scale == 8 
			  && current_architecture == mcf5200))
d1855 5
a1859 2
		      opP->error =
			"scale factor invalid on this architecture; needs cpu32 or 68020 or higher";
a1990 2
		  if (cpu_of_arch (current_architecture) & cpu32)
		    opP->error = "invalid operand mode for this architecture; needs 68020 or higher";
a2363 12
            case ROMBAR:
	      tmpreg = 0xC00;
	      break;
	    case RAMBAR0:
	      tmpreg = 0xC04;
	      break;
	    case RAMBAR1:
	      tmpreg = 0xC05;
	      break;
	    case MBAR:
	      tmpreg = 0xC0F;
	      break;
d2945 3
a2947 2
  /* control registers */
  { "sfc", SFC },		/* Source Function Code */
d2949 1
a2949 1
  { "dfc", DFC },		/* Destination Function Code */
d2951 2
a2952 2
  { "cacr", CACR },		/* Cache Control Register */
  { "caar", CAAR },		/* Cache Address Register */
d2954 1
a2954 28
  { "usp", USP },		/* User Stack Pointer */
  { "vbr", VBR },		/* Vector Base Register */
  { "msp", MSP },		/* Master Stack Pointer */
  { "isp", ISP },		/* Interrupt Stack Pointer */

  { "itt0", ITT0 },		/* Instruction Transparent Translation Reg 0 */
  { "itt1", ITT1 },		/* Instruction Transparent Translation Reg 1 */
  { "dtt0", DTT0 },		/* Data Transparent Translation Register 0 */
  { "dtt1", DTT1 },		/* Data Transparent Translation Register 1 */

  /* 68ec040 versions of same */
  { "iacr0", ITT0 },		/* Instruction Access Control Register 0 */
  { "iacr1", ITT1 },		/* Instruction Access Control Register 0 */
  { "dacr0", DTT0 },		/* Data Access Control Register 0 */
  { "dacr1", DTT1 },		/* Data Access Control Register 0 */

  /* mcf5200 versions of same */
  { "acr2", ITT0 },		/* Access Control Unit 2 */
  { "acr3", ITT1 },		/* Access Control Unit 3 */
  { "acr0", DTT0 },		/* Access Control Unit 0 */
  { "acr1", DTT1 },		/* Access Control Unit 1 */

  { "tc", TC },			/* MMU Translation Control Register */
  { "tcr", TC },

  { "mmusr", MMUSR },		/* MMU Status Register */
  { "srp", SRP },		/* User Root Pointer */
  { "urp", URP },		/* Supervisor Root Pointer */
d2956 9
a2967 6
  { "rombar", ROMBAR },		/* ROM Base Address Register */
  { "rambar0", RAMBAR0 },	/* ROM Base Address Register */
  { "rambar1", RAMBAR1 },	/* ROM Base Address Register */
  { "mbar", MBAR },		/* Module Base Address Register */
  /* end of control registers */

a3379 14
  /* We need to put digits in alt_notend_table to handle
       bfextu %d0{24:1},%d0
     */
  alt_notend_table['0'] = 1;
  alt_notend_table['1'] = 1;
  alt_notend_table['2'] = 1;
  alt_notend_table['3'] = 1;
  alt_notend_table['4'] = 1;
  alt_notend_table['5'] = 1;
  alt_notend_table['6'] = 1;
  alt_notend_table['7'] = 1;
  alt_notend_table['8'] = 1;
  alt_notend_table['9'] = 1;

a3491 3
    case mcf5200:
      control_regs = mcf5200_control_regs;
      break;
d6272 1
a6272 2
	char *n, *t;
	const char *s;
d6300 1
a6300 1
 | -mcpu32 | -m5200\n\
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d262 1
a262 1
  the_ins.reloc[the_ins.nrel].n = ((width == 'B' || width == '3')
d3027 5
a3031 7
  /* mcf5200 versions of same.  The ColdFire programmer's reference
     manual indicated that the order is 2,3,0,1, but Ken Rose
     <rose@@netcom.com> says that 0,1,2,3 is the correct order.  */
  { "acr0", ITT0 },		/* Access Control Unit 0 */
  { "acr1", ITT1 },		/* Access Control Unit 1 */
  { "acr2", DTT0 },		/* Access Control Unit 2 */
  { "acr3", DTT1 },		/* Access Control Unit 3 */
d3211 1
a3211 1
	      n = 1;
a3501 33
static void
select_control_regs ()
{
  /* Note which set of "movec" control registers is available.  */
  switch (cpu_of_arch (current_architecture))
    {
    case m68000:
      control_regs = m68000_control_regs;
      break;
    case m68010:
      control_regs = m68010_control_regs;
      break;
    case m68020:
    case m68030:
      control_regs = m68020_control_regs;
      break;
    case m68040:
      control_regs = m68040_control_regs;
      break;
    case m68060:
      control_regs = m68060_control_regs;
      break;
    case cpu32:
      control_regs = cpu32_control_regs;
      break;
    case mcf5200:
      control_regs = mcf5200_control_regs;
      break;
    default:
      abort ();
    }
}

d3566 27
a3592 1
  select_control_regs ();
a4640 3

  /* Update info about available control registers.  */
  select_control_regs ();
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 2
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 1997
   Free Software Foundation, Inc.
d33 1
a33 1
#if defined (TE_SVR4) || defined (TE_DELTA)
d46 1
a46 1
const char line_comment_chars[] = "#*";
a97 28
/* This is non-zero if m68k_rel32 was set from the command line.  */
static int m68k_rel32_from_cmdline;

/* The default width to use for an index register when using a base
   displacement.  */
static enum m68k_size m68k_index_width_default = SIZE_LONG;

/* We want to warn if any text labels are misaligned.  In order to get
   the right line number, we need to record the line number for each
   label.  */

struct label_line
{
  struct label_line *next;
  symbolS *label;
  char *file;
  unsigned int line;
  int text;
};

/* The list of labels.  */

static struct label_line *labels;

/* The current label.  */

static struct label_line *current_label;

d192 1
a192 1
      offsetT foff;
a224 3
/* Macros for determining if cpu supports a specific addressing mode */
#define HAVE_LONG_BRANCH(x)	((x) & (m68020|m68030|m68040|m68060|cpu32))

a235 6
/* Static functions.  */

static void insop PARAMS ((int, struct m68k_incant *));
static void add_fix PARAMS ((int, struct m68k_exp *, int, int));
static void add_frag PARAMS ((symbolS *, offsetT, int));

d257 1
a257 1
     int width;
d287 1
a287 1
add_frag (add, off, type)
d289 1
a289 1
     offsetT off;
a302 4
static void m68k_ip PARAMS ((char *));
static void insert_reg PARAMS ((const char *, int));
static void select_control_regs PARAMS ((void));
static void init_regtable PARAMS ((void));
a329 2
static void md_apply_fix_2 PARAMS ((fixS *, offsetT));
static void md_convert_frag_1 PARAMS ((fragS *));
d507 1
a507 4

#ifdef M68KCOFF
extern void obj_coff_section PARAMS ((int));
#endif
d827 2
a828 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d875 1
a1048 93
		case '<':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case IMMED:
		    case ADEC:
		    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
		    }
		  break;

		case '>':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case FPREG:
		    case CONTROL:
		    case IMMED:
		    case AINC:
		    case REGLST:
		      losing++;
		      break;
		    case ABSL:
		      break;
		    default:
		      if (opP->reg == PC
			  || opP->reg == ZPC)
			losing++;
		      break;
		    }
		  break;

		case 'm':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		      break;
		    default:
		      losing++;
		    }
                  break;

		case 'n':
		  switch (opP->mode)
		    {
		    case DISP:
		      break;
		    default:
		      losing++;
		    }
                  break;

		case 'o':
		  switch (opP->mode)
		    {
		    case BASE:
		    case ABSL:
		    case IMMED:
		      break;
		    default:
		      losing++;
		    }
                  break;

		case 'p':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		      break;
		    case DISP:
		      if (opP->reg == PC || opP->reg == ZPC)
                        losing++;
		      break;
		    default:
		      losing++;
		    }
                  break;

a1056 5
		  else if (s[1] == 'B'
			   && ! isvar (&opP->disp)
			   && (opP->disp.exp.X_op != O_constant
			       || ! issbyte (opP->disp.exp.X_add_number)))
		    losing++;
a1641 6
	case '<':
	case '>':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
d1893 2
a1894 3
		  if (opP->index.size == SIZE_LONG
		      || (opP->index.size == SIZE_UNSPEC
			  && m68k_index_width_default == SIZE_LONG))
a1973 6
			  /* The code in md_convert_frag_1 needs to be
                             able to adjust nextword.  Call frag_grow
                             to ensure that we have enough space in
                             the frag obstack to make all the bytes
                             contiguous.  */
			  frag_grow (14);
d2116 1
a2116 1
		      && HAVE_LONG_BRANCH(current_architecture)
a2186 7
	    case 'B':
	      if (!issbyte (tmpreg))
		opP->error = "out of range";
	      opcode->m_opcode |= tmpreg;
	      if (isvar (&opP->disp))
		the_ins.reloc[the_ins.nrel - 1].n = opcode->m_codenum * 2 - 1;
	      break;
a2212 1
	    case 'j':
d2244 2
a2245 2
	      if (!HAVE_LONG_BRANCH(current_architecture))
		as_warn ("Can't use long branches on 68000/68010/5200");
d2268 1
a2268 1
	      if (( !HAVE_LONG_BRANCH(current_architecture)
d2305 1
a2305 1
		  add_frag ((symbolS *) 0, (offsetT) 0, TAB (FBRANCH, LONG));
d2312 2
a2313 2
		  /* add_frag ((symbolS *) 0, offs (&opP->disp),
		     	       TAB(FBRANCH,SHORT)); */
d2916 1
a2916 1
     const char *regname;
a3189 7
  /* If there is a current label, record that it marks an instruction.  */
  if (current_label != NULL)
    {
      current_label->text = 1;
      current_label = NULL;
    }

a3215 1
	    case 'W':
a3234 2
	  if (the_ins.reloc[m].wid == 'B')
	    fixP->fx_signed = 1;
d3344 1
a3344 2
      if (! m68k_rel32_from_cmdline)
	m68k_rel32 = 0;
a3605 2

/* This is called when a label is defined.  */
a3606 49
void
m68k_frob_label (sym)
     symbolS *sym;
{
  struct label_line *n;

  n = (struct label_line *) xmalloc (sizeof *n);
  n->next = labels;
  n->label = sym;
  as_where (&n->file, &n->line);
  n->text = 0;
  labels = n;
  current_label = n;
}

/* This is called when a value that is not an instruction is emitted.  */

void
m68k_flush_pending_output ()
{
  current_label = NULL;
}

/* This is called at the end of the assembly, when the final value of
   the label is known.  We warn if this is a text symbol aligned at an
   odd location.  */

void
m68k_frob_symbol (sym)
     symbolS *sym;
{
  if ((S_GET_VALUE (sym) & 1) != 0)
    {
      struct label_line *l;

      for (l = labels; l != NULL; l = l->next)
	{
	  if (l->label == sym)
	    {
	      if (l->text)
		as_warn_where (l->file, l->line,
			       "text label `%s' aligned to odd boundary",
			       S_GET_NAME (sym));
	      break;
	    }
	}
    }
}

d3624 1
a3624 2
      if (! m68k_rel32_from_cmdline)
	m68k_rel32 = 0;
d3640 1
a3640 2
      if (! m68k_rel32_from_cmdline)
	m68k_rel32 = 1;
d3662 1
d3783 1
a3783 1
  if (! fixP->fx_pcrel && ! fixP->fx_signed)
d3870 1
a3870 1
      if (!HAVE_LONG_BRANCH(current_architecture))
d4081 1
a4081 1
	else if ((fragP->fr_symbol == 0) || !HAVE_LONG_BRANCH(current_architecture))
d4395 1
a4395 1
  if (!HAVE_LONG_BRANCH(current_architecture))
d4558 1
d4597 1
a4597 1
    frag_align (temp, (int) temp_fill, 0);
a4598 1
  record_alignment (now_seg, temp);
a4609 12
/* This function returns non-zero if the argument is a conditional
   pseudo-op.  This is called when checking whether a pending
   alignment is needed.  */

int
m68k_conditional_pseudoop (pop)
     pseudo_typeS *pop;
{
  return (pop->poc_handler == s_mri_if
	  || pop->poc_handler == s_mri_else);
}

d4620 1
a4620 5
  /* We can't use get_symbol_end since the processor names are not proper
     symbols.  */
  while (is_part_of_name (c = *input_line_pointer++))
    ;
  *--input_line_pointer = 0;
d4643 1
a4643 5
      /* We can't use get_symbol_end since the processor names are not
	 proper symbols.  */
      while (is_part_of_name (c = *input_line_pointer++))
	;
      *--input_line_pointer = 0;
a6262 8
#define OPTION_BASE_SIZE_DEFAULT_16 (OPTION_MD_BASE + 3)
  {"base-size-default-16", no_argument, NULL, OPTION_BASE_SIZE_DEFAULT_16},
#define OPTION_BASE_SIZE_DEFAULT_32 (OPTION_MD_BASE + 4)
  {"base-size-default-32", no_argument, NULL, OPTION_BASE_SIZE_DEFAULT_32},
#define OPTION_DISP_SIZE_DEFAULT_16 (OPTION_MD_BASE + 5)
  {"disp-size-default-16", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_16},
#define OPTION_DISP_SIZE_DEFAULT_32 (OPTION_MD_BASE + 6)
  {"disp-size-default-32", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_32},
a6394 18
    case OPTION_BASE_SIZE_DEFAULT_16:
      m68k_index_width_default = SIZE_WORD;
      break;

    case OPTION_BASE_SIZE_DEFAULT_32:
      m68k_index_width_default = SIZE_LONG;
      break;

    case OPTION_DISP_SIZE_DEFAULT_16:
      m68k_rel32 = 0;
      m68k_rel32_from_cmdline = 1;
      break;

    case OPTION_DISP_SIZE_DEFAULT_32:
      m68k_rel32 = 1;
      m68k_rel32_from_cmdline = 1;
      break;

a6424 5
  fprintf (stream, "\
--base-size-default-16	base reg without size is 16 bits\n\
--base-size-default-32	base reg without size is 32 bits (default)\n\
--disp-size-default-16	displacement with unknown size is 16 bits\n\
--disp-size-default-32	displacement with unknown size is 32 bits (default)\n");
a6554 2
#ifdef OBJ_COFF

a6578 2

#endif
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1987, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a29 4
#if defined (OBJ_ELF)
#include "elf/m68k.h"
#endif

d192 1
a192 1
static const enum m68k_register mcf_control_regs[] = {
d250 1
a250 1
#define cpu_of_arch(x)		((x) & (m68000up|mcf))
a252 1
#define arch_coldfire_p(x)	(((x) & mcf) != 0)
d270 1
a270 1
static void insop PARAMS ((int, const struct m68k_incant *));
d278 1
a278 1
     const struct m68k_incant *opcode;
a393 2
  { mcf5206e, "5206e", 0 },
  { mcf5307, "5307", 0},
d397 1
a398 5
  { m68000, "68302", 1 },
  { m68000, "68306", 1 },
  { m68000, "68307", 1 },
  { m68000, "68322", 1 },
  { m68000, "68356", 1 },
a409 2
  { cpu32,  "68334", 1 },
  { cpu32,  "68336", 1 },
a410 2
  { cpu32,  "68341", 1 },
  { cpu32,  "68349", 1 },
a412 3
  { mcf5200, "5202", 1 },
  { mcf5200, "5204", 1 },
  { mcf5200, "5206", 1 },
d628 1
a628 1
    as_fatal (_("Unknown PC relative instruction"));
d751 3
a753 15
  if (pcrel)
    {
      if (pic == pic_none)
	as_bad (_("Can not do %d byte pc-relative relocation"), size);
      else
	as_bad (_("Can not do %d byte pc-relative pic relocation"), size);
    }
  else
    {
      if (pic == pic_none)
	as_bad (_("Can not do %d byte relocation"), size);
      else
	as_bad (_("Can not do %d byte pic relocation"), size);
    }

d767 1
a767 2
  if (S_IS_EXTERNAL (fixP->fx_addsy)
      || S_IS_WEAK (fixP->fx_addsy))
a786 4
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return 0;

d850 1
a850 1
			    _("Cannot make %s relocation PC relative"),
d875 1
a875 2
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
a900 21
/* Return zero if the reference to SYMBOL from within the same segment may
   be relaxed.  */
#ifdef OBJ_ELF

/* On an ELF system, we can't relax an externally visible symbol,
   because it may be overridden by a shared library.  However, if
   TARGET_OS is "elf", then we presume that we are assembling for an
   embedded system, in which case we don't have to worry about shared
   libraries, and we can relax anything.  */

#define relaxable_symbol(symbol)		\
  (strcmp (TARGET_OS, "elf") == 0		\
   || (! S_IS_EXTERNAL (symbol)			\
       && ! S_IS_WEAK (symbol)))

#else

#define relaxable_symbol(symbol) 1

#endif
 
d907 1
a907 1
static void
d913 1
a913 1
  register const struct m68k_incant *opcode;
d941 1
a941 1
      the_ins.error = _("No operator");
d958 1
a958 1
  opcode = (const struct m68k_incant *) hash_find (op_hash, instring);
d971 1
a971 1
      the_ins.error = _("Unknown operator");
d1076 18
a1186 37
		case 'q':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		      break;
		    case DISP:
		      if (opP->reg == PC || opP->reg == ZPC)
                        losing++;
		      break;
		    default:
		      losing++;
		      break;
		    }
                  break;

		case 'v':
		  switch (opP->mode)
		    {
		    case DREG:
		    case AINDR:
		    case AINC:
		    case ADEC:
		    case ABSL:
		      break;
		    case DISP:
		      if (opP->reg == PC || opP->reg == ZPC)
                        losing++;
		      break;
		    default:
		      losing++;
		      break;
		    }
		  break;

a1408 5
		case 'E':
		  if (opP->reg != ACC)
		    losing++;
		  break;

a1413 10
		case 'G':
		  if (opP->reg != MACSR)
		    losing++;
		  break;

		case 'H':
		  if (opP->reg != MASK)
		    losing++;
		  break;

d1493 8
a1682 13
		case 'u':
		  if (opP->reg < DATA0L || opP->reg > ADDR7U)
		    losing++;
		  /* FIXME: kludge instead of fixing parser:
                     upper/lower registers are *not* CONTROL
                     registers, but ordinary ones. */
		  if ((opP->reg >= DATA0L && opP->reg <= DATA7L)
		      || (opP->reg >= DATA0U && opP->reg <= DATA7U))
		    opP->mode = DREG;
		  else
		    opP->mode = AREG;
		  break;

d1707 1
a1707 1
		      _("invalid instruction for this architecture; needs "));
d1712 1
a1712 1
		  strcpy (cp, _("fpu (68040, 68060 or 68881/68882)"));
d1715 1
a1715 1
		  strcpy (cp, _("mmu (68030 or 68851)"));
d1718 1
a1718 1
		  strcpy (cp, _("68020 or higher"));
d1721 1
a1721 1
		  strcpy (cp, _("68000 or higher"));
d1724 1
a1724 1
		  strcpy (cp, _("68010 or higher"));
d1729 1
a1729 2
		    for (idx = 0;
			 idx < (int) (sizeof (archs) / sizeof (archs[0]));
d1752 1
a1752 1
	    the_ins.error = _("operands mismatch");
d1784 1
a1790 2
	case 'q':
	case 'v':
d1808 1
a1808 1
		    opP->error = _("operand out of range");
d1814 1
a1814 1
		    opP->error = _("operand out of range");
d1820 1
a1820 1
		    opP->error = _("operand out of range");
d1877 1
a1877 1
		      as_warn (_("Bignum too big for %c format; truncated"),
d1938 1
a1938 2
			   && cpu_of_arch (current_architecture) >= m68020
			   && ! arch_coldfire_p (current_architecture))
d1941 1
a1941 2
		  if (cpu_of_arch (current_architecture) < m68020
		      || arch_coldfire_p (current_architecture))
d1943 1
a1943 1
		      _("displacement too large for this architecture; needs 68020 or higher");
d2050 1
a2050 1
			  && arch_coldfire_p (current_architecture)))
d2053 1
a2053 1
			_("scale factor invalid on this architecture; needs cpu32 or 68020 or higher");
a2055 4
		  if (arch_coldfire_p (current_architecture)
		      && opP->index.size == SIZE_WORD)
		    opP->error = _("invalid index size for coldfire");

a2086 1
			  || arch_coldfire_p (current_architecture)
d2106 1
a2106 1
				as_warn (_("Forcing byte displacement"));
d2108 1
a2108 1
				opP->error = _("byte displacement out of range");
d2152 1
a2152 2
	      if (cpu_of_arch (current_architecture) < m68020
		  || arch_coldfire_p (current_architecture))
d2154 1
a2154 1
		  _("invalid operand mode for this architecture; needs 68020 or higher");
d2178 1
a2178 1
		  as_warn (_(":b not permitted; defaulting to :w"));
d2192 1
a2192 1
		    opP->error = _("invalid operand mode for this architecture; needs 68020 or higher");
d2212 1
a2212 1
		      as_warn (_(":b not permitted; defaulting to :w"));
d2261 2
d2272 1
a2272 1
		      && relaxable_symbol (adds (&opP->disp))
a2291 3
		case SIZE_BYTE:
		  as_bad (_("unsupported byte value; use a different suffix"));
		  /* Fall through.  */
d2304 1
a2304 1
	      as_bad (_("unknown/incorrect operand"));
d2337 1
a2337 1
		opP->error = _("out of range");
d2345 2
a2346 2
		opP->error = _("out of range");
	      the_ins.opcode[the_ins.numo - 1] |= tmpreg & 0xff;
d2352 1
a2352 1
		opP->error = _("out of range");
d2359 1
a2359 1
		opP->error = _("out of range");
d2409 1
a2409 1
		as_warn (_("Can't use long branches on 68000/68010/5200"));
d2497 1
a2497 1
	      as_warn (_("Expression out of range, using 0"));
a2506 3
	case 'E':		/* Ignore it */
	  break;

a2510 4
	case 'G':		/* Ignore it */
	case 'H':
	  break;

d2602 1
a2602 1
		as_bad (_("Floating point register in register list"));
d2608 1
a2608 1
		as_bad (_("Wrong register in floating-point reglist"));
d2618 1
a2618 1
		as_bad (_("Floating point register in register list"));
d2624 1
a2624 1
		as_bad (_("incorrect register in reglist"));
d2630 1
a2630 1
		as_bad (_("wrong register in floating-point reglist"));
d2642 1
a2642 1
		    ? 0x20 + (int) (opP->reg - DATA)
d2706 1
a2706 1
	      as_fatal (_("failed sanity check"));
a2831 2
	  if (isvar (&opP->disp))
	    add_fix ('l', &opP->disp, 0, 0);
a2835 5
	case 'u':
	  install_operand (s[1], opP->reg - DATA0L);
	  opP->reg -= (DATA0L);
	  opP->reg &= 0x0F;	/* remove upper/lower bit */
	  break;
a2974 24
    case 'm':
      the_ins.opcode[0] |= ((val & 0x8) << (6 - 3));
      the_ins.opcode[0] |= ((val & 0x7) << 9);
      the_ins.opcode[1] |= ((val & 0x10) << (7 - 4));
      break;
    case 'n':
      the_ins.opcode[0] |= ((val & 0x8) << (6 - 3));
      the_ins.opcode[0] |= ((val & 0x7) << 9);
      break;
    case 'o':
      the_ins.opcode[1] |= val << 12;
      the_ins.opcode[1] |= ((val & 0x10) << (7 - 4));
      break;
    case 'M':
      the_ins.opcode[0] |= (val & 0xF);
      the_ins.opcode[1] |= ((val & 0x10) << (6 - 4));
      break;
    case 'N':
      the_ins.opcode[1] |= (val & 0xF);
      the_ins.opcode[1] |= ((val & 0x10) << (6 - 4));
      break;
    case 'h':
      the_ins.opcode[1] |= ((val != 1) << 10);
      break;
d2977 1
a2977 1
      as_fatal (_("failed sanity check."));
d3006 1
a3006 1
      as_fatal (_("failed sanity check."));
d3040 1
a3040 1
		  opP->error = _("Extra )");
d3051 1
a3051 1
      opP->error = _("Missing )");
d3068 1
a3068 9
	as_bad (_("Missing operand"));
    }

  /* Detect MRI REG symbols and convert them to REGLSTs.  */
  if (opP->mode == CONTROL && (int)opP->reg < 0)
    {
      opP->mode = REGLST;
      opP->mask = ~(int)opP->reg;
      opP->reg = 0;
a3069 1

d3078 1
a3078 1
static void
a3166 4
  { "acc", ACC },
  { "macsr", MACSR },
  { "mask", MASK },

a3270 37
  /* Upper and lower data and address registers, used by macw and msacw. */
  { "d0l", DATA0L },
  { "d1l", DATA1L },
  { "d2l", DATA2L },
  { "d3l", DATA3L },
  { "d4l", DATA4L },
  { "d5l", DATA5L },
  { "d6l", DATA6L },
  { "d7l", DATA7L },

  { "a0l", ADDR0L },
  { "a1l", ADDR1L },
  { "a2l", ADDR2L },
  { "a3l", ADDR3L },
  { "a4l", ADDR4L },
  { "a5l", ADDR5L },
  { "a6l", ADDR6L },
  { "a7l", ADDR7L },

  { "d0u", DATA0U },
  { "d1u", DATA1U },
  { "d2u", DATA2U },
  { "d3u", DATA3U },
  { "d4u", DATA4U },
  { "d5u", DATA5U },
  { "d6u", DATA6U },
  { "d7u", DATA7U },

  { "a0u", ADDR0U },
  { "a1u", ADDR1U },
  { "a2u", ADDR2U },
  { "a3u", ADDR3U },
  { "a4u", ADDR4U },
  { "a5u", ADDR5U },
  { "a6u", ADDR6U },
  { "a7u", ADDR7U },

d3274 1
a3274 1
static void
d3350 1
a3350 1
      as_bad (_("%s -- statement `%s' ignored"), er, str);
d3394 1
a3394 1
	      as_fatal (_("Don't know how to figure width of %c in md_assemble()"),
d3511 1
a3511 1
  register int i;
d3553 1
a3553 1
	as_fatal (_("Internal Error:  Can't hash %s: %s"), ins->name, retval);
d3562 1
a3562 1
	as_fatal (_("Internal Error: Can't find %s in hash table"), name);
d3565 1
a3565 1
	as_fatal (_("Internal Error: Can't hash %s: %s"), alias, retval);
d3592 1
a3592 3
      for (i = 0;
	   i < (int) (sizeof mri_aliases / sizeof mri_aliases[0]);
	   i++)
d3598 1
a3598 1
	    as_fatal (_("Internal Error: Can't find %s in hash table"), name);
d3601 1
a3601 1
	    as_fatal (_("Internal Error: Can't hash %s: %s"), alias, retval);
d3605 1
a3605 1
  for (i = 0; i < (int) sizeof (mklower_table); i++)
d3608 1
a3608 1
  for (i = 0; i < (int) sizeof (notend_table); i++)
d3705 1
a3705 3
    case mcf5206e:
    case mcf5307:
      control_regs = mcf_control_regs;
d3727 1
a3727 1
	  as_bad (_("unrecognized default cpu `%s' ???"), TARGET_CPU);
d3739 1
a3739 1
	  as_warn (_("68040 and 68851 specified; mmu instructions may assemble incorrectly"));
d3759 1
a3759 1
    as_bad (_("options for 68881 and no-68881 both given"));
d3761 1
a3761 1
    as_bad (_("options for 68851 and no-68851 both given"));
d3778 1
a3778 2
  if (cpu_of_arch (current_architecture) < m68020
      || arch_coldfire_p (current_architecture))
d3815 1
a3815 7
  if (S_GET_SEGMENT (sym) == reg_section
      && (int) S_GET_VALUE (sym) < 0)
    {
      S_SET_SEGMENT (sym, absolute_section);
      S_SET_VALUE (sym, ~(int)S_GET_VALUE (sym));
    }
  else if ((S_GET_VALUE (sym) & 1) != 0)
d3825 1
a3825 1
			       _("text label `%s' aligned to odd boundary"),
d3919 1
a3919 1
      return _("Bad call to MD_ATOF()");
a3966 5

      if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
	  && !S_IS_DEFINED (fixP->fx_addsy)
	  && !S_IS_WEAK (fixP->fx_addsy))
	S_SET_WEAK (fixP->fx_addsy);
a3970 6
#ifdef BFD_ASSEMBLER
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return;
#endif

d4015 1
a4015 1
    as_bad_where (fixP->fx_file, fixP->fx_line, _("value out of range"));
d4019 2
a4020 8
     different opcodes (branches with longer offsets).  fixup_segment
     in write.c may have clobbered fx_pcrel, so we need to examine the
     reloc type.  */
  if ((fixP->fx_pcrel
#ifdef BFD_ASSEMBLER
       || fixP->fx_r_type == BFD_RELOC_8_PCREL
#endif
       )
d4025 1
a4025 1
    as_bad_where (fixP->fx_file, fixP->fx_line, _("invalid byte branch offset"));
d4050 1
a4050 1
static void
d4073 1
a4073 1
  disp += symbol_get_frag (fragP->fr_symbol)->fr_address;
d4082 1
a4082 1
	as_bad (_("short branch with zero offset: use :w"));
d4128 1
a4128 4
	      /* This should never happen, because if it's a conditional
	         branch and we are on a 68000, BCC68000 should have been
	         picked instead of ABRANCH. */
	      abort ();
d4189 1
a4189 1
	as_bad (_("Internal error (long PC-relative operand) for insn 0x%04x at 0x%lx"),
d4220 1
a4220 1
	  as_bad (_("displacement doesn't fit in one byte"));
d4264 2
a4265 2
     object_headers *headers ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
d4275 2
a4276 2
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
d4303 1
a4303 2
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
a4307 8
	else if ((fragP->fr_symbol != NULL) && flag_short_refs)
	  {			/* Symbol is undefined and we want short ref */
	    fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
		     fragP->fr_offset, 1, NO_RELOC);
	    fragP->fr_fix += 2;
	    frag_wane (fragP);
	    break;
	  }
d4332 1
a4332 4
		/* This should never happen, because if it's a conditional
		   branch and we are on a 68000, BCC68000 should have been
		   picked instead of ABRANCH. */
		abort ();
d4350 1
a4350 3
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs)
d4368 3
a4370 3
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol))
	    || flag_short_refs)
d4386 1
a4386 2
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
d4392 3
a4394 1
	if ((fragP->fr_symbol != NULL) && flag_short_refs)
d4396 5
a4400 1
	    /* the user wants short refs, so emit one */
d4402 1
a4402 1
		     fragP->fr_offset, 1, NO_RELOC);
a4406 2
	    /* change bcc into b!cc/jmp absl long */
	    fragP->fr_opcode[0] ^= 0x01;	/* invert bcc */
d4422 1
a4422 3
	if (fragP->fr_symbol != NULL
	    && S_GET_SEGMENT (fragP->fr_symbol) == segment
	    && relaxable_symbol (fragP->fr_symbol))
d4429 5
d4435 1
a4435 1
	if (fragP->fr_symbol != NULL && flag_short_refs)
d4437 5
a4441 1
	    /* the user wants short refs, so emit one */
d4443 1
a4443 1
		     fragP->fr_offset, 1, NO_RELOC);
a4447 5
	    /* change dbcc into dbcc/jmp absl long */
	    /* JF: these used to be fr_opcode[2-4], which is wrong. */
	    buffer_address[0] = 0x00;	/* branch offset = 4 */
	    buffer_address[1] = 0x04;
	    buffer_address[2] = 0x60;	/* put in bra pc + ... */
d4464 1
a4464 2
	if (((S_GET_SEGMENT (fragP->fr_symbol)) == segment
	     && relaxable_symbol (fragP->fr_symbol))
d4466 1
a4466 2
	    || cpu_of_arch (current_architecture) < m68020
	    || cpu_of_arch (current_architecture) == mcf5200)
d4480 2
a4481 4
      if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	   && relaxable_symbol (fragP->fr_symbol))
	  || cpu_of_arch (current_architecture) < m68020
	  || cpu_of_arch (current_architecture) == mcf5200)
a4509 1
	  fragS *stop;
d4512 3
a4514 2
	  stop = symbol_get_frag (fragP->fr_symbol);
	  for (l = fragP->fr_next; l != stop; l = l->fr_next)
d4517 1
a4517 1
	  if (l == stop)
d4602 2
a4603 2
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d4670 1
a4670 1
	  as_warn (_("expression out of range: defaulting to 1"));
d4681 1
a4681 1
	      as_warn (_("expression out of range: defaulting to 1"));
d4713 1
a4713 1
	      as_warn (_("expression out of range: defaulting to 0"));
d4746 1
a4746 1
	  as_warn (_("Can't deal with expression; defaulting to %ld"),
d4758 1
a4758 1
	  as_warn (_("Can't deal with expression; defaulting to %ld"),
d4772 1
a4772 1
	    as_warn (_("expression doesn't fit in BYTE"));
d4776 1
a4776 1
	    as_warn (_("expression doesn't fit in WORD"));
d4788 1
a4788 1
     int ignore ATTRIBUTE_UNUSED;
d4796 1
a4796 1
     int ignore ATTRIBUTE_UNUSED;
d4804 1
a4804 1
     int ignore ATTRIBUTE_UNUSED;
d4815 1
a4815 1
     int ignore ATTRIBUTE_UNUSED;
d4830 1
a4830 1
     int ignore ATTRIBUTE_UNUSED;
d4869 1
a4869 1
      as_bad (_("%s: unrecognized processor name"), s);
d4906 1
a4906 1
     int ignore ATTRIBUTE_UNUSED;
d4923 1
a4923 1
     int ignore ATTRIBUTE_UNUSED;
d4934 1
a4934 1
	as_bad (_("bad coprocessor id"));
d4940 1
a4940 1
      as_bad (_("unrecognized fopt option"));
d5027 1
a5027 1
#define OPTCOUNT ((int) (sizeof opt_table / sizeof opt_table[0]))
d5033 1
a5033 1
     int ignore ATTRIBUTE_UNUSED;
d5074 1
a5074 1
		    as_bad (_("option `%s' may not be negated"), s);
d5085 1
a5085 1
	  as_bad (_("option `%s' not recognized"), s);
d5101 2
a5102 2
     int arg ATTRIBUTE_UNUSED;
     int on ATTRIBUTE_UNUSED;
d5113 2
a5114 2
     int arg ATTRIBUTE_UNUSED;
     int on ATTRIBUTE_UNUSED;
d5118 1
a5118 1
      as_bad (_("bad format of OPT NEST=depth"));
d5130 2
a5131 2
     int arg ATTRIBUTE_UNUSED;
     int on ATTRIBUTE_UNUSED;
d5147 1
a5147 1
     int arg ATTRIBUTE_UNUSED;
d5157 1
a5157 1
     int arg ATTRIBUTE_UNUSED;
d5170 1
a5170 1
     int ignore ATTRIBUTE_UNUSED;
d5175 1
a5175 1
  int mask;
d5181 1
a5181 1
      as_bad (_("missing label"));
d5205 1
a5205 1
	as_bad (_("bad register list"));
d5207 1
a5207 1
	as_bad (_("bad register list: %s"), rop.error);
d5234 1
a5234 1
      as_bad (_("bad register list"));
d5239 3
a5241 3
  S_SET_SEGMENT (line_label, reg_section);
  S_SET_VALUE (line_label, ~mask);
  symbol_set_frag (line_label, &zero_address_frag);
d5274 1
a5274 1
     int ignore ATTRIBUTE_UNUSED;
d5299 1
a5299 1
     int ignore ATTRIBUTE_UNUSED;
d5305 1
a5305 1
      as_bad (_("restore without save"));
a5377 1
static void mri_assemble PARAMS ((char *));
a5392 18
/* Assemble an instruction for an MRI structured control directive.  */

static void
mri_assemble (str)
     char *str;
{
  char *s;

  /* md_assemble expects the opcode to be in lower case.  */
  for (s = str; *s != ' ' && *s != '\0'; s++)
    {
      if (isupper ((unsigned char) *s))
	*s = tolower ((unsigned char) *s);
    }

  md_assemble (str);
}

d5463 1
a5463 1
      as_bad (_("syntax error in structured control directive"));
d5514 1
a5514 1
      as_bad (_("missing condition code in structured control directive"));
d5685 1
a5685 1
      mri_assemble (buf);
d5698 1
a5698 1
  mri_assemble (buf);
d5812 1
a5812 1
    as_bad (_("syntax error in structured control directive"));
d5846 1
a5846 1
	  as_bad (_("missing then"));
d5928 1
a5928 1
      as_bad (_("else without matching if"));
d5939 1
a5939 1
  mri_assemble (buf);
d5957 1
a5957 1
     int ignore ATTRIBUTE_UNUSED;
d5962 1
a5962 1
      as_bad (_("endi without matching if"));
d6003 1
a6003 1
      as_bad (_("break outside of structured loop"));
d6012 1
a6012 1
  mri_assemble (buf);
d6042 1
a6042 1
      as_bad (_("next outside of structured loop"));
d6051 1
a6051 1
  mri_assemble (buf);
d6094 1
a6094 1
      as_bad (_("missing ="));
d6132 1
a6132 1
      as_bad (_("missing to or downto"));
d6168 1
a6168 1
      as_bad (_("missing do"));
d6202 1
a6202 1
	  as_bad (_("missing do"));
d6240 1
a6240 1
  mri_assemble (buf);
d6258 1
a6258 1
  mri_assemble (buf);
d6267 1
a6267 1
  mri_assemble (buf);
d6300 1
a6300 1
     int ignore ATTRIBUTE_UNUSED;
d6305 1
a6305 1
      as_bad (_("endf without for"));
d6312 1
a6312 1
  mri_assemble (mri_control_stack->incr);
d6315 1
a6315 1
  mri_assemble (mri_control_stack->incr);
d6336 1
a6336 1
     int ignore ATTRIBUTE_UNUSED;
d6361 1
a6361 1
      as_bad (_("until without repeat"));
d6412 1
a6412 1
      as_bad (_("missing do"));
d6441 1
a6441 1
     int ignore ATTRIBUTE_UNUSED;
d6448 1
a6448 1
      as_bad (_("endw without while"));
d6455 1
a6455 1
  mri_assemble (buf);
d6564 1
a6564 1
	      as_bad (_("unrecognized option `%s'"), oarg);
d6609 1
a6609 1
	      as_bad (_("unrecognized architecture specification `%s'"), arg);
d6679 1
a6679 1
  fprintf(stream, _("\
d6688 2
a6689 2
			[default yes for 68020, 68030, and cpu32]\n"));
  fprintf(stream, _("\
d6697 2
a6698 2
--bitwise-or		do not treat `|' as a comment character\n"));
  fprintf (stream, _("\
d6702 1
a6702 1
--disp-size-default-32	displacement with unknown size is 32 bits (default)\n"));
d6733 1
a6733 1
	  printf (_("Error %s in %s\n"), the_ins.error, buf);
d6737 1
a6737 1
	  printf (_("Opcode(%d.%s): "), the_ins.numo, the_ins.args);
d6800 1
a6800 1
     char *name ATTRIBUTE_UNUSED;
d6808 1
a6808 1
     segT segment ATTRIBUTE_UNUSED;
d6811 1
a6811 15
#ifdef OBJ_AOUT
#ifdef BFD_ASSEMBLER
  /* For a.out, force the section size to be aligned.  If we don't do
     this, BFD will align it for us, but it will not write out the
     final bytes of the section.  This may be a bug in BFD, but it is
     easier to fix it here since that is how the other a.out targets
     work.  */
  int align;

  align = bfd_get_section_alignment (stdoutput, segment);
  size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
#endif
#endif

  return size;
d6838 1
a6838 1
     symbolS *ignore ATTRIBUTE_UNUSED;
d6862 1
a6862 8
#ifdef OBJ_ELF
void m68k_elf_final_processing()
{
   /* Set file-specific flags if this is a cpu32 processor */
   if (cpu_of_arch (current_architecture) & cpu32)
     elf_elfheader (stdoutput)->e_flags |= EF_CPU32;
}
#endif
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d49 2
a50 2
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
d53 1
a53 1
const char line_separator_chars[] = ";";
d71 1
a71 1
   references.  Not implemented.  For ELF there are other means
a76 1
static int flag_keep_pcrel;	/* --pcrel option.  */
d135 29
d197 1
a197 1
  CACR, TC, ITT0, ITT1, DTT0, DTT1, VBR, ROMBAR,
d260 1
a260 1
#define HAVE_LONG_BRANCH(x)     ((x) & (m68020|m68030|m68040|m68060|cpu32|mcf5407))
d382 5
a386 6
struct m68k_cpu
  {
    unsigned long arch;
    const char *name;
    int alias;
  };
d388 44
a431 46
static const struct m68k_cpu archs[] =
  {
    { m68000, "68000", 0 },
    { m68010, "68010", 0 },
    { m68020, "68020", 0 },
    { m68030, "68030", 0 },
    { m68040, "68040", 0 },
    { m68060, "68060", 0 },
    { cpu32,  "cpu32", 0 },
    { m68881, "68881", 0 },
    { m68851, "68851", 0 },
    { mcf5200, "5200", 0 },
    { mcf5206e, "5206e", 0 },
    { mcf5307, "5307", 0},
    { mcf5407, "5407", 0},
    /* Aliases (effectively, so far as gas is concerned) for the above
       cpus.  */
    { m68020, "68k", 1 },
    { m68000, "68008", 1 },
    { m68000, "68302", 1 },
    { m68000, "68306", 1 },
    { m68000, "68307", 1 },
    { m68000, "68322", 1 },
    { m68000, "68356", 1 },
    { m68000, "68ec000", 1 },
    { m68000, "68hc000", 1 },
    { m68000, "68hc001", 1 },
    { m68020, "68ec020", 1 },
    { m68030, "68ec030", 1 },
    { m68040, "68ec040", 1 },
    { m68060, "68ec060", 1 },
    { cpu32,  "68330", 1 },
    { cpu32,  "68331", 1 },
    { cpu32,  "68332", 1 },
    { cpu32,  "68333", 1 },
    { cpu32,  "68334", 1 },
    { cpu32,  "68336", 1 },
    { cpu32,  "68340", 1 },
    { cpu32,  "68341", 1 },
    { cpu32,  "68349", 1 },
    { cpu32,  "68360", 1 },
    { m68881, "68882", 1 },
    { mcf5200, "5202", 1 },
    { mcf5200, "5204", 1 },
    { mcf5200, "5206", 1 },
  };
d435 2
a436 2
/* This is the assembler relaxation table for m68k. m68k is a rich CISC
   architecture and we have a lot of relaxation modes.  */
d438 2
a439 51
/* Macros used in the relaxation code.  */
#define TAB(x,y)	(((x) << 2) + (y))
#define TABTYPE(x)      ((x) >> 2)

/* Relaxation states.  */
#define BYTE		0
#define SHORT		1
#define LONG		2
#define SZ_UNDEF	3

/* Here are all the relaxation modes we support.  First we can relax ordinary
   branches.  On 68020 and higher and on CPU32 all branch instructions take
   three forms, so on these CPUs all branches always remain as such.  When we
   have to expand to the LONG form on a 68000, though, we substitute an
   absolute jump instead.  This is a direct replacement for unconditional
   branches and a branch over a jump for conditional branches.  However, if the
   user requires PIC and disables this with --pcrel, we can only relax between
   BYTE and SHORT forms, punting if that isn't enough.  This gives us four
   different relaxation modes for branches:  */

#define BRANCHBWL	1	/* branch byte, word, or long */
#define BRABSJUNC	2	/* absolute jump for LONG, unconditional */
#define BRABSJCOND	3	/* absolute jump for LONG, conditional */
#define BRANCHBW	4	/* branch byte or word */

/* We also relax coprocessor branches and DBcc's.  All CPUs that support
   coprocessor branches support them in word and long forms, so we have only
   one relaxation mode for them.  DBcc's are word only on all CPUs.  We can
   relax them to the LONG form with a branch-around sequence.  This sequence
   can use a long branch (if available) or an absolute jump (if acceptable).
   This gives us two relaxation modes.  If long branches are not available and
   absolute jumps are not acceptable, we don't relax DBcc's.  */

#define FBRANCH		5	/* coprocessor branch */
#define DBCCLBR		6	/* DBcc relaxable with a long branch */
#define DBCCABSJ	7	/* DBcc relaxable with an absolute jump */

/* That's all for instruction relaxation.  However, we also relax PC-relative
   operands.  Specifically, we have three operand relaxation modes.  On the
   68000 PC-relative operands can only be 16-bit, but on 68020 and higher and
   on CPU32 they may be 16-bit or 32-bit.  For the latter we relax between the
   two.  Also PC+displacement+index operands in their simple form (with a non-
   suppressed index without memory indirection) are supported on all CPUs, but
   on the 68000 the displacement can be 8-bit only, whereas on 68020 and higher
   and on CPU32 we relax it to SHORT and LONG forms as well using the extended
   form of the PC+displacement+index operand.  Finally, some absolute operands
   can be relaxed down to 16-bit PC-relative.  */

#define PCREL1632	8	/* 16-bit or 32-bit PC-relative */
#define PCINDEX		9	/* PC+displacement+index */
#define ABSTOPCREL	10	/* absolute relax down to 16-bit PC-relative */
d457 2
a458 2
  {(127), (-128), 0, TAB (BRANCHBWL, SHORT)},
  {(32767), (-32768), 2, TAB (BRANCHBWL, LONG)},
d462 2
a463 2
  {(127), (-128), 0, TAB (BRABSJUNC, SHORT)},
  {(32767), (-32768), 2, TAB (BRABSJUNC, LONG)},
d467 2
a468 12
  {(127), (-128), 0, TAB (BRABSJCOND, SHORT)},
  {(32767), (-32768), 2, TAB (BRABSJCOND, LONG)},
  {0, 0, 6, 0},
  {1, 1, 0, 0},

  {(127), (-128), 0, TAB (BRANCHBW, SHORT)},
  {0, 0, 2, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  {1, 1, 0, 0},			/* FBRANCH doesn't come BYTE */
  {(32767), (-32768), 2, TAB (FBRANCH, LONG)},
d472 3
a474 3
  {1, 1, 0, 0},			/* DBCC doesn't come BYTE */
  {(32767), (-32768), 2, TAB (DBCCLBR, LONG)},
  {0, 0, 10, 0},
d478 2
a479 2
  {(32767), (-32768), 2, TAB (DBCCABSJ, LONG)},
  {0, 0, 10, 0},
d482 2
a483 2
  {1, 1, 0, 0},			/* PCREL1632 doesn't come BYTE */
  {32767, -32768, 2, TAB (PCREL1632, LONG)},
d487 1
a491 5

  {1, 1, 0, 0},			/* ABSTOPCREL doesn't come BYTE */
  {(32767), (-32768), 2, TAB (ABSTOPCREL, LONG)},
  {0, 0, 4, 0},
  {1, 1, 0, 0},
d565 1
d612 1
a612 1
#define mklower(c) (mklower_table[(unsigned char) (c)])
a678 13
/* Return zero if the reference to SYMBOL from within the same segment may
   be relaxed.  */

/* On an ELF system, we can't relax an externally visible symbol,
   because it may be overridden by a shared library.  However, if
   TARGET_OS is "elf", then we presume that we are assembling for an
   embedded system, in which case we don't have to worry about shared
   libraries, and we can relax any external sym.  */

#define relaxable_symbol(symbol) \
  (!((S_IS_EXTERNAL (symbol) && strcmp (TARGET_OS, "elf") != 0)		\
     || S_IS_WEAK (symbol)))

d796 3
a798 2
  /* Prevent all adjustments to global symbols.  */
  if (! relaxable_symbol (fixP->fx_addsy))
a830 2
#define relaxable_symbol(symbol) 1

a842 5
  /* If the tcbit is set, then this was a fixup of a negative value
     that was never resolved.  We do not have a reloc to handle this,
     so just return.  We assume that other code will have detected this
     situation and produced a helpful error message, so we just tell the
     user that the reloc cannot be produced.  */
d844 1
a844 6
    {
      if (fixp->fx_addsy)
	as_bad (_("Unable to produce reloc against symbol '%s'"),
		S_GET_NAME (fixp->fx_addsy));
      return NULL;
    }
d923 2
a924 3
		     /* Explicit sign extension in case char is
			unsigned.  */
		     + ((fixp->fx_pcrel_adjust & 0xff) ^ 0x80) - 0x80
d937 21
d986 1
a986 1
     or exactly 1 space.  */
d1095 1
a1095 1
	 common model with this pattern then reject this pattern.  */
d1758 1
a1758 1
		    }		/* not a cache specifier.  */
d1771 1
a1771 1
                     registers, but ordinary ones.  */
d1791 1
a1791 1
	}			/* got it.  */
d2067 1
a2067 1
					TAB (PCREL1632, SZ_UNDEF));
d2147 1
a2147 1
		  if ((opP->index.scale != 1
d2149 1
a2149 1
		      || (opP->index.scale == 8
d2375 2
d2383 1
a2383 1
				TAB (ABSTOPCREL, SZ_UNDEF));
d2412 1
a2412 1
	      /* abort (); */
d2503 5
a2507 1
	      add_fix ('B', &opP->disp, 1, -1);
d2515 1
a2515 1
	      if (! HAVE_LONG_BRANCH (current_architecture))
d2517 1
a2517 1
	      the_ins.opcode[0] |= 0xff;
d2532 1
d2534 9
a2542 25
		 address.  If it's an absolute address, turn it into
		 an absolute jump right here and keep it out of the
		 relaxer.  */
	      if (adds (&opP->disp) == 0)
		{
		  if (the_ins.opcode[0] == 0x6000)	/* jbra */
		    the_ins.opcode[0] = 0x4EF1;
		  else if (the_ins.opcode[0] == 0x6100)	/* jbsr */
		    the_ins.opcode[0] = 0x4EB1;
		  else					/* jCC */
		    {
		      the_ins.opcode[0] ^= 0x0100;
		      the_ins.opcode[0] |= 0x0006;
		      addword (0x4EF1);
		    }
		  add_fix ('l', &opP->disp, 0, 0);
		  addword (0);
		  addword (0);
		  break;
		}

	      /* Now we know it's going into the relaxer.  Now figure
		 out which mode.  We try in this order of preference:
		 long branch, absolute jump, byte/word branches only.  */
	      if (HAVE_LONG_BRANCH (current_architecture))
d2544 1
a2544 11
			  TAB (BRANCHBWL, SZ_UNDEF));
	      else if (! flag_keep_pcrel)
		{
		  if ((the_ins.opcode[0] == 0x6000)
		      || (the_ins.opcode[0] == 0x6100))
		    add_frag (adds (&opP->disp), offs (&opP->disp),
			      TAB (BRABSJUNC, SZ_UNDEF));
		  else
		    add_frag (adds (&opP->disp), offs (&opP->disp),
			      TAB (BRABSJCOND, SZ_UNDEF));
		}
d2547 1
a2547 1
			  TAB (BRANCHBW, SZ_UNDEF));
d2552 3
a2554 6
		  /* Check for DBcc instructions.  We can relax them,
		     but only if we have long branches and/or absolute
		     jumps.  */
		  if (((the_ins.opcode[0] & 0xf0f8) == 0x50c8)
		      && (HAVE_LONG_BRANCH (current_architecture)
			  || (! flag_keep_pcrel)))
d2556 4
a2559 6
		      if (HAVE_LONG_BRANCH (current_architecture))
			add_frag (adds (&opP->disp), offs (&opP->disp),
				  TAB (DBCCLBR, SZ_UNDEF));
		      else
			add_frag (adds (&opP->disp), offs (&opP->disp),
				  TAB (DBCCABSJ, SZ_UNDEF));
d2562 1
d2573 1
a2573 1
	      if (subs (&opP->disp) || (adds (&opP->disp) == 0))
d2575 10
a2589 3
	      else
		add_frag (adds (&opP->disp), offs (&opP->disp),
			  TAB (FBRANCH, SZ_UNDEF));
d2825 1
a2825 1
	  /* JF: These are out of order, I fear.  */
d2963 1
a2963 1
     instruction, ready to be emitted. . .  */
d3429 1
a3429 1
  /* Upper and lower data and address registers, used by macw and msacw.  */
a3608 15
  {
    /* Calculate the max frag size.  */
    int wid;

    wid = 2 * the_ins.fragb[0].fragoff;
    for (n = 1; n < the_ins.nfrag; n++)
      wid += 2 * (the_ins.numo - the_ins.fragb[n - 1].fragoff);
    /* frag_var part.  */
    wid += 10;
    /* Make sure the whole insn fits in one chunk, in particular that
       the var part is attached, as we access one byte before the
       variable frag for byte branches.  */
    frag_grow (wid);
  }

d3727 1
a3727 1
	     but just leaving them out of the hash.  */
a3903 1
    case mcf5407:
d4082 2
a4083 2
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
d4163 4
a4166 1
  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;
d4278 1
d4286 1
a4286 1
     want.  */
d4301 2
a4302 4
    case TAB (BRANCHBWL, BYTE):
    case TAB (BRABSJUNC, BYTE):
    case TAB (BRABSJCOND, BYTE):
    case TAB (BRANCHBW, BYTE):
d4306 10
a4315 8
      fixP = fix_new (fragP, fragP->fr_fix - 1, 1, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC8);
      fixP->fx_pcrel_adjust = -1;
      break;
    case TAB (BRANCHBWL, SHORT):
    case TAB (BRABSJUNC, SHORT):
    case TAB (BRABSJCOND, SHORT):
    case TAB (BRANCHBW, SHORT):
d4317 1
a4317 3
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
d4319 2
a4320 8
    case TAB (BRANCHBWL, LONG):
      fragP->fr_opcode[1] = (char) 0xFF;
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC32);
      fragP->fr_fix += 4;
      break;
    case TAB (BRABSJUNC, LONG):
      if (fragP->fr_opcode[0] == 0x61)		/* jbsr */
d4322 34
a4355 13
	  fragP->fr_opcode[0] = 0x4E;
	  fragP->fr_opcode[1] = (char) 0xB9; /* JSR with ABSL LONG operand */
	  fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
		   0, RELAX_RELOC_ABS32);
	  fragP->fr_fix += 4;
	}
      else if (fragP->fr_opcode[0] == 0x60)	/* jbra */
	{
	  fragP->fr_opcode[0] = 0x4E;
	  fragP->fr_opcode[1] = (char) 0xF9; /* JMP with ABSL LONG operand */
	  fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
		   0, RELAX_RELOC_ABS32);
	  fragP->fr_fix += 4;
d4359 2
a4360 3
	  /* This cannot happen, because jbsr and jbra are the only two
	     unconditional branches.  */
	  abort ();
d4363 3
a4365 4
    case TAB (BRABSJCOND, LONG):
      /* Only Bcc 68000 instructions can come here.  */
      /* Change bcc into b!cc/jmp absl long.  */

d4371 1
a4371 1
	   Only fr_opcode[0,1] are guaranteed to work.  */
d4376 1
a4376 13
	       fragP->fr_offset, 0, RELAX_RELOC_ABS32);
      fragP->fr_fix += 4;
      break;
    case TAB (FBRANCH, SHORT):
      know ((fragP->fr_opcode[1] & 0x40) == 0);
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (FBRANCH, LONG):
      fragP->fr_opcode[1] |= 0x40;	/* Turn on LONG bit */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC32);
d4378 1
d4380 3
a4382 10
    case TAB (DBCCLBR, SHORT):
    case TAB (DBCCABSJ, SHORT):
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (DBCCLBR, LONG):
      /* only DBcc instructions can come here */
      /* Change dbcc into dbcc/bral.  */

d4388 2
a4389 2
      *buffer_address++ = 0x60;     /* Put in bral (0x60ff).  */
      *buffer_address++ = (char) 0xff;
d4392 2
a4393 2
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset, 1,
	       RELAX_RELOC_PC32);
d4395 12
d4408 12
a4419 15
    case TAB (DBCCABSJ, LONG):
      /* only DBcc instructions can come here */
      /* Change dbcc into dbcc/jmp.  */

      /* JF: these used to be fr_opcode[2-7], but that's wrong */
      *buffer_address++ = 0x00;	/* branch offset = 4 */
      *buffer_address++ = 0x04;
      *buffer_address++ = 0x60;	/* put in bra pc+6 */
      *buffer_address++ = 0x06;
      *buffer_address++ = 0x4e;     /* Put in jmp long (0x4ef9).  */
      *buffer_address++ = (char) 0xf9;

      fragP->fr_fix += 6;	/* account for bra/jmp instructions */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset, 0,
	       RELAX_RELOC_ABS32);
d4421 1
d4423 3
a4425 1
    case TAB (PCREL1632, SHORT):
d4428 1
a4428 3
      fix_new (fragP, (int) (fragP->fr_fix), 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
d4430 4
a4433 1
    case TAB (PCREL1632, LONG):
d4439 1
a4439 4
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fixP->fx_pcrel_adjust = 2;
      fragP->fr_fix += 4;
d4441 1
d4443 6
d4451 2
a4452 3
      fixP = fix_new (fragP, fragP->fr_fix - 1, 1, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC8);
      fixP->fx_pcrel_adjust = 1;
d4455 2
d4461 2
a4462 1
		      fragP->fr_offset, 1, RELAX_RELOC_PC16);
d4464 1
a4464 1
      fragP->fr_fix += 2;
d4467 5
d4475 1
a4475 20
      fixP = fix_new (fragP, (int) (fragP->fr_fix), 4, fragP->fr_symbol,
		      fragP->fr_offset, 1, RELAX_RELOC_PC32);
      fixP->fx_pcrel_adjust = 2;
      fragP->fr_fix += 4;
      break;
    case TAB (ABSTOPCREL, SHORT):
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, RELAX_RELOC_PC16);
      fragP->fr_fix += 2;
      break;
    case TAB (ABSTOPCREL, LONG):
      /* The thing to do here is force it to ABSOLUTE LONG, since
	 ABSTOPCREL is really trying to shorten an ABSOLUTE address anyway */
      if ((fragP->fr_opcode[1] & 0x3F) != 0x3A)
	abort ();
      fragP->fr_opcode[1] &= ~0x3F;
      fragP->fr_opcode[1] |= 0x39;	/* Mode 7.1 */
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol, fragP->fr_offset,
	       0, RELAX_RELOC_ABS32);
      fragP->fr_fix += 4;
d4477 6
d4518 1
d4522 1
a4522 1
  /* Handle SZ_UNDEF first, it can be changed to BYTE or SHORT.  */
d4525 2
a4526 3
    case TAB (BRANCHBWL, SZ_UNDEF):
    case TAB (BRABSJUNC, SZ_UNDEF):
    case TAB (BRABSJCOND, SZ_UNDEF):
d4528 2
a4529 1
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment
d4533 1
d4535 9
a4543 1
	else if (flag_short_refs)
d4545 49
a4593 2
	    /* Symbol is undefined and we want short ref.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
d4597 5
a4601 2
	    /* Symbol is still undefined.  Make it LONG.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), LONG);
d4604 52
a4655 1
      }
d4657 1
a4657 1
    case TAB (BRANCHBW, SZ_UNDEF):
d4659 2
a4660 1
	if (S_GET_SEGMENT (fragP->fr_symbol) == segment
d4663 12
a4674 1
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), BYTE);
d4678 13
a4690 2
	    /* Symbol is undefined and we don't have long branches.  */
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
d4692 2
d4695 1
a4695 1
      }
d4697 1
a4697 4
    case TAB (FBRANCH, SZ_UNDEF):
    case TAB (DBCCLBR, SZ_UNDEF):
    case TAB (DBCCABSJ, SZ_UNDEF):
    case TAB (PCREL1632, SZ_UNDEF):
d4699 1
a4699 1
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
d4701 3
a4703 1
	    || flag_short_refs)
d4705 2
a4706 1
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
d4710 2
a4711 1
	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), LONG);
d4714 1
a4714 1
      }
d4718 3
a4720 1
	   && relaxable_symbol (fragP->fr_symbol)))
d4727 1
a4730 14
    case TAB (ABSTOPCREL, SZ_UNDEF):
      {
	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
	     && relaxable_symbol (fragP->fr_symbol)))
	  {
	    fragP->fr_subtype = TAB (ABSTOPCREL, SHORT);
	  }
	else
	  {
	    fragP->fr_subtype = TAB (ABSTOPCREL, LONG);
	  }
	break;
      }

d4735 1
a4735 1
  /* Now that SZ_UNDEF are taken care of, check others.  */
d4738 2
a4739 4
    case TAB (BRANCHBWL, BYTE):
    case TAB (BRABSJUNC, BYTE):
    case TAB (BRABSJCOND, BYTE):
    case TAB (BRANCHBW, BYTE):
d4759 1
a4765 1
  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
d4779 1
a4779 1
   format.  */
d5061 1
a5061 1
  if (!need_pass_2)		/* Never make frag if expect extra pass.  */
d5924 1
a5924 1

d5946 1
a5946 1

a6747 1
 *      --pcrel Never turn PC-relative branches into absolute jumps.
a6775 2
#define OPTION_PCREL (OPTION_MD_BASE + 7)
  {"pcrel", no_argument, NULL, OPTION_PCREL},
d6778 1
a6778 1
size_t md_longopts_size = sizeof (md_longopts);
a6796 5
    case OPTION_PCREL:		/* --pcrel means never turn PC-relative
				   branches into absolute jumps.  */
      flag_keep_pcrel = 1;
      break;

d6937 1
a6937 1
  fprintf (stream, _("\
d6940 3
a6942 3
-m68000 | -m68008 | -m68010 | -m68020 | -m68030 | -m68040 | -m68060 |\n\
-m68302 | -m68331 | -m68332 | -m68333 | -m68340 | -m68360 | -mcpu32 |\n\
-m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m5307  | -m5407\n\
d6947 1
a6947 1
  fprintf (stream, _("\
a6952 1
--pcrel                 never turn PC-relative branches into absolute jumps\n\
d7055 1
d7089 1
a7089 1
   first extension word is stored in fx_pcrel_adjust.  */
d7096 3
a7098 3
  /* Because fx_pcrel_adjust is a char, and may be unsigned, we explicitly
     sign extend the value here.  */
  adjust = ((fixP->fx_pcrel_adjust & 0xff) ^ 0x80) - 0x80;
d7107 1
d7142 1
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002
d23 1
a24 1
#include "safe-ctype.h"
a26 1
#include "dwarf2dbg.h"
d57 1
a57 1
const char EXP_CHARS[] = "eE";
d62 1
a62 1
const char FLT_CHARS[] = "rRsSfFdDxXeEpP";
d259 4
a262 4
  for (z = the_ins.numo; z > opcode->m_codenum; --z)
    the_ins.opcode[z] = the_ins.opcode[z - 1];
  for (z = 0; z < the_ins.nrel; z++)
    the_ins.reloc[z].n += 2;
d265 1
a265 1
  the_ins.opcode[opcode->m_codenum] = w;
d308 4
a311 4
  the_ins.fragb[the_ins.nfrag].fragoff = the_ins.numo;
  the_ins.fragb[the_ins.nfrag].fadd = add;
  the_ins.fragb[the_ins.nfrag].foff = off;
  the_ins.fragb[the_ins.nfrag++].fragty = type;
d350 1
d434 4
a437 4
#define BRANCHBWL	0	/* branch byte, word, or long */
#define BRABSJUNC	1	/* absolute jump for LONG, unconditional */
#define BRABSJCOND	2	/* absolute jump for LONG, conditional */
#define BRANCHBW	3	/* branch byte or word */
d447 3
a449 3
#define FBRANCH		4	/* coprocessor branch */
#define DBCCLBR		5	/* DBcc relaxable with a long branch */
#define DBCCABSJ	6	/* DBcc relaxable with an absolute jump */
d462 3
a464 3
#define PCREL1632	7	/* 16-bit or 32-bit PC-relative */
#define PCINDEX		8	/* PC+displacement+index */
#define ABSTOPCREL	9	/* absolute relax down to 16-bit PC-relative */
d474 1
a474 2

   Please check tc-m68k.h:md_prepare_relax_scan if changing this table.  */
d477 54
a530 49
  {   127,   -128,  0, TAB (BRANCHBWL, SHORT) },
  { 32767, -32768,  2, TAB (BRANCHBWL, LONG) },
  {     0,	0,  4, 0 },
  {     1,	1,  0, 0 },

  {   127,   -128,  0, TAB (BRABSJUNC, SHORT) },
  { 32767, -32768,  2, TAB (BRABSJUNC, LONG) },
  {	0,	0,  4, 0 },
  {	1,	1,  0, 0 },

  {   127,   -128,  0, TAB (BRABSJCOND, SHORT) },
  { 32767, -32768,  2, TAB (BRABSJCOND, LONG) },
  {	0,	0,  6, 0 },
  {	1,	1,  0, 0 },

  {   127,   -128,  0, TAB (BRANCHBW, SHORT) },
  {	0,	0,  2, 0 },
  {	1,	1,  0, 0 },
  {	1,	1,  0, 0 },

  {	1, 	1,  0, 0 },		/* FBRANCH doesn't come BYTE */
  { 32767, -32768,  2, TAB (FBRANCH, LONG) },
  {	0,	0,  4, 0 },
  {	1, 	1,  0, 0 },

  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE */
  { 32767, -32768,  2, TAB (DBCCLBR, LONG) },
  {	0,	0, 10, 0 },
  {	1,	1,  0, 0 },

  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE */
  { 32767, -32768,  2, TAB (DBCCABSJ, LONG) },
  {	0,	0, 10, 0 },
  {	1,	1,  0, 0 },

  {	1, 	1,  0, 0 },		/* PCREL1632 doesn't come BYTE */
  { 32767, -32768,  2, TAB (PCREL1632, LONG) },
  {	0,	0,  6, 0 },
  {	1,	1,  0, 0 },

  {   125,   -130,  0, TAB (PCINDEX, SHORT) },
  { 32765, -32770,  2, TAB (PCINDEX, LONG) },
  {	0,	0,  4, 0 },
  {	1,	1,  0, 0 },

  {	1,	1,  0, 0 },		/* ABSTOPCREL doesn't come BYTE */
  { 32767, -32768,  2, TAB (ABSTOPCREL, LONG) },
  {	0,	0,  4, 0 },
  {	1,	1,  0, 0 },
a560 6
#ifdef OBJ_ELF
  /* Dwarf2 support for Gcc.  */
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
#endif

d612 1
a612 1
const pseudo_typeS mote_pseudo_table[] =
d649 2
d847 4
d889 1
a889 1
     asection *section ATTRIBUTE_UNUSED;
d903 2
a904 3
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("Unable to produce reloc against symbol '%s'"),
		      S_GET_NAME (fixp->fx_addsy));
d1226 1
a1226 1
		  break;
d1236 1
a1236 1
		  break;
d1248 1
a1248 1
		  break;
d1261 1
a1261 1
			losing++;
d1266 1
a1266 1
		  break;
d1278 1
a1278 1
			losing++;
d1284 1
a1284 1
		  break;
d1297 1
a1297 1
			losing++;
d2277 4
a2280 4
			  nextword += baseo & 0xff;
			  addword (nextword);
			  add_frag (adds (&opP->disp), offs (&opP->disp),
				    TAB (PCINDEX, SZ_UNDEF));
d2283 1
a2283 1
			}
d2575 1
a2575 1
		    the_ins.opcode[0] = 0x4EF9;
d2577 1
a2577 1
		    the_ins.opcode[0] = 0x4EB9;
d2582 1
a2582 1
		      addword (0x4EF9);
d3311 1
a3311 1
    buf[i] = TOUPPER (regname[i]);
a3613 5
#ifdef OBJ_ELF
  /* Tie dwarf2 debug info to the address at the start of the insn.  */
  dwarf2_emit_insn (0);
#endif

d3776 5
a3780 4
  const struct m68k_opcode *ins;
  struct m68k_incant *hack, *slak;
  const char *retval = 0;	/* empty string, or error msg text */
  int i;
d3875 3
a3954 5
    case 0:
      as_warn (_("architecture not yet selected: defaulting to 68020"));
      control_regs = m68020_control_regs;
      break;
      
d4223 2
a4224 2
void
md_apply_fix3 (fixP, valP, seg)
d4226 1
a4226 2
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
a4227 1
  offsetT val = *valP;
a4238 3
  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;

d4261 2
a4262 2
      /* The cast to offsetT below are necessary to make code
	 correct for machines where ints are smaller than offsetT.  */
d4322 18
d4365 4
d4377 1
a4377 2
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("short branch with zero offset: use :w"));
d4583 4
d4683 16
a4698 10
	 case we force word mode.  If the symbol is at the start of a
	 frag, and it is the next frag with any data in it (usually
	 this is just the next frag, but assembler listings may
	 introduce empty frags), we must use word mode.  */
      if (fragP->fr_symbol)
	{
	  fragS *sym_frag;

	  sym_frag = symbol_get_frag (fragP->fr_symbol);
	  if (S_GET_VALUE (fragP->fr_symbol) == sym_frag->fr_address)
d4700 1
a4700 7
	      fragS *l;

	      for (l = fragP->fr_next; l && l != sym_frag; l = l->fr_next)
		if (l->fr_fix != 0)
		  break;
	      if (l == sym_frag)
		fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
d4707 2
a4708 1
  return md_relax_table[fragP->fr_subtype].rlx_length;
d4752 1
a4752 1
  static const unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
d4776 2
a4777 2
const int md_short_jump_size = 4;
const int md_long_jump_size = 6;
d5344 1
a5344 1
    listing &= ~LISTING_SYMBOLS;
d5373 1
a5373 1
  while (ISALNUM (*input_line_pointer)
d5585 4
a5588 1
    *s = TOLOWER (*s);
d5670 4
a5673 2
  c1 = TOLOWER (c1);
  c2 = TOLOWER (c2);
d5731 4
a5734 10
      /* We must make sure we don't misinterpret AND/OR at the end of labels!
         if d0 <eq> #FOOAND and d1 <ne> #BAROR then
                        ^^^                 ^^ */
      if ((s == input_line_pointer
	   || *(s-1) == ' '
	   || *(s-1) == '\t')
	  && ((strncasecmp (s, "AND", 3) == 0
	       && (s[3] == '.' || ! is_part_of_name (s[3])))
	      || (strncasecmp (s, "OR", 2) == 0
		  && (s[2] == '.' || ! is_part_of_name (s[2])))))
a5761 2
    /* <HS> is an alias for <CC> */
    case MCC ('h', 's'):
a5762 2
    /* <LO> is an alias for <CS> */
    case MCC ('l', 'o'):
a5769 9
    /* issue a warning for conditions we can not swap */
    case MCC ('n', 'e'): return MCC ('n', 'e'); // no problem here
    case MCC ('e', 'q'): return MCC ('e', 'q'); // also no problem
    case MCC ('v', 'c'):
    case MCC ('v', 's'):
    default :
	   as_warn (_("Condition <%c%c> in structured control directive can not be encoded correctly"),
		         (char) (cc >> 8), (char) (cc));
      break;
a5783 2
    /* <HS> is an alias for <CC> */
    case MCC ('h', 's'): return MCC ('l', 'o');
a5784 2
    /* <LO> is an alias for <CS> */
    case MCC ('l', 'o'): return MCC ('h', 's');
d5851 1
a5851 14
     /* Correct conditional handling:
        if #1 <lt> d0 then  ;means if (1 < d0)
           ...
        endi

        should assemble to:

         cmp #1,d0        if we do *not* swap the operands
         bgt true         we need the swapped condition!
         ble false
        true:
         ...
        false:
     */
a5858 4
      else
	{
	  cc = swap_mri_condition (cc);
	}
d5877 1
a5877 1
	*s++ = TOLOWER (qual);
d5895 1
a5895 1
    *s++ = TOLOWER (extent);
d6030 2
a6031 11
  /* We only accept '*' as introduction of comments if preceded by white space
     or at first column of a line (I think this can't actually happen here?)
     This is important when assembling:
       if d0 <ne> 12(a0,d0*2) then
       if d0 <ne> #CONST*20   then */
  while ( ! (    is_end_of_line[(unsigned char) *s]
              || (     flag_mri
                   && *s == '*'
                   && (    s == input_line_pointer
                        || *(s-1) == ' '
                        || *(s-1) == '\t'))))
d6136 1
a6136 1
  q[0] = TOLOWER (qual);
d6209 1
a6209 1
  ex[0] = TOLOWER (extent);
d6248 1
a6248 1
  ex[0] = TOLOWER (extent);
d6432 1
a6432 1
    *s++ = TOLOWER (qual);
d6450 1
a6450 1
    *s++ = TOLOWER (qual);
d6461 1
a6461 1
  ex[0] = TOLOWER (extent);
d6477 1
a6477 1
    *s++ = TOLOWER (qual);
d6600 2
a6601 11
  /* We only accept '*' as introduction of comments if preceded by white space
     or at first column of a line (I think this can't actually happen here?)
     This is important when assembling:
       while d0 <ne> 12(a0,d0*2) do
       while d0 <ne> #CONST*20   do */
  while (! (is_end_of_line[(unsigned char) *s]
	    || (flag_mri
		&& *s == '*'
		&& (s == input_line_pointer
		    || *(s-1) == ' '
		    || *(s-1) == '\t'))))
d6698 1
a6698 1
const char *md_shortopts = "lSA:m:kQ:V";
d6700 1
a6700 1
const char *md_shortopts = "lSA:m:k";
d6749 1
a6749 1
	arg++;
a6886 24
  const char *default_cpu = TARGET_CPU;
  int i;
  unsigned int default_arch;

  /* Get the canonical name for the default target CPU.  */
  if (*default_cpu == 'm')
    default_cpu++;
  for (i = 0; i < n_archs; i++)
    {
      if (strcasecmp (default_cpu, archs[i].name) == 0)
	{
	  default_arch = archs[i].arch;
	  for (i = 0; i < n_archs; i++)
	    {
	      if (archs[i].arch == default_arch
		  && !archs[i].alias)
		{
		  default_cpu = archs[i].name;
		  break;
		}
	    }
	}
    }

d6893 1
a6893 1
			specify variant of 680X0 architecture [default %s]\n\
d6896 1
a6896 2
			[default yes for 68020, 68030, and cpu32]\n"),
          default_cpu);
d7084 1
a7084 2
void
m68k_elf_final_processing ()
d7086 3
a7088 6
  /* Set file-specific flags if this is a cpu32 processor */
  if (cpu_of_arch (current_architecture) & cpu32)
    elf_elfheader (stdoutput)->e_flags |= EF_CPU32;
  else if ((cpu_of_arch (current_architecture) & m68000up)
	   && !(cpu_of_arch (current_architecture) & m68020up))
    elf_elfheader (stdoutput)->e_flags |= EF_M68000;
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 2
a4 1
   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a27 1
#include "dw2gencfi.h"
d57 1
a57 1
/* Chars that can be used to separate mant from exp in floating point nums.  */
d69 1
a69 1
const int md_reloc_size = 8;	/* Size of relocation record.  */
d77 2
a78 2
static int flag_short_refs;	/* -l option.  */
static int flag_long_jumps;	/* -S option.  */
d116 1
d134 2
a135 2
/* Its an arbitrary name:  This means I don't approve of it.
   See flames below.  */
d171 1
a171 1
  CACR, TC, ACR0, ACR1, ACR2, ACR3, VBR, ROMBAR,
a174 11
static const enum m68k_register mcf528x_control_regs[] = {
  CACR, ACR0, ACR1, VBR, FLASHBAR, RAMBAR,
  0
};
static const enum m68k_register mcfv4e_control_regs[] = {
  CACR, TC, ITT0, ITT1, DTT0, DTT1, BUSCR, VBR, PC, ROMBAR,
  ROMBAR1, RAMBAR0, RAMBAR1, MPCR, EDRAMBAR, SECMBAR, MBAR, MBAR0, MBAR1,
  PCR1U0, PCR1L0, PCR1U1, PCR1L1, PCR2U0, PCR2L0, PCR2U1, PCR2L1,
  PCR3U0, PCR3L0, PCR3U1, PCR3L1,
  0
};
d179 1
a179 1
/* Internal form of a 68020 instruction.  */
d183 1
a183 1
  const char *args;		/* List of opcode info.  */
d186 1
a186 1
  int numo;			/* Number of shorts in opcode.  */
d191 1
a191 1
  int nexp;			/* Number of exprs in use.  */
d194 1
a194 1
  int nfrag;			/* Number of frags we have to produce.  */
d197 1
a197 1
      int fragoff;		/* Where in the current opcode the frag ends.  */
d204 1
a204 1
  int nrel;			/* Num of reloc strucs in use.  */
d225 1
a225 1
  reloc[5];			/* Five is enough???  */
d228 1
a228 1
#define cpu_of_arch(x)		((x) & (m68000up | mcf))
d231 1
a231 2
#define arch_coldfire_p(x)	((x) & mcf)
#define arch_coldfire_v4e_p(x)	((x) & mcfv4e)
d233 2
a234 2
/* Macros for determining if cpu supports a specific addressing mode.  */
#define HAVE_LONG_BRANCH(x)     ((x) & (m68020|m68030|m68040|m68060|cpu32|mcf5407|mcfv4e))
d236 1
a236 1
static struct m68k_it the_ins;	/* The instruction being assembled.  */
d243 2
a244 1
/* Macros for adding things to the m68k_it struct.  */
d248 1
d253 1
a253 2
/* Like addword, but goes BEFORE general operands.  */

d364 13
a376 15
    { m68000,  "68000", 0 },
    { m68010,  "68010", 0 },
    { m68020,  "68020", 0 },
    { m68030,  "68030", 0 },
    { m68040,  "68040", 0 },
    { m68060,  "68060", 0 },
    { cpu32,   "cpu32", 0 },
    { m68881,  "68881", 0 },
    { m68851,  "68851", 0 },
    { mcf5200, "5200",  0 },
    { mcf5206e,"5206e", 0 },
    { mcf528x, "528x",  0 },
    { mcf5307, "5307",  0 },
    { mcf5407, "5407",  0 },
    { mcfv4e,  "cfv4e", 0 },
a406 1
    { mcf5407, "cfv4", 1 },
d434 4
a437 4
#define BRANCHBWL	0	/* Branch byte, word, or long.  */
#define BRABSJUNC	1	/* Absolute jump for LONG, unconditional.  */
#define BRABSJCOND	2	/* Absolute jump for LONG, conditional.  */
#define BRANCHBW	3	/* Branch byte or word.  */
d447 3
a449 3
#define FBRANCH		4	/* Coprocessor branch.  */
#define DBCCLBR		5	/* DBcc relaxable with a long branch.  */
#define DBCCABSJ	6	/* DBcc relaxable with an absolute jump.  */
d462 3
a464 3
#define PCREL1632	7	/* 16-bit or 32-bit PC-relative.  */
#define PCINDEX		8	/* PC + displacement + index. */
#define ABSTOPCREL	9	/* Absolute relax down to 16-bit PC-relative.  */
d498 1
a498 1
  {	1, 	1,  0, 0 },		/* FBRANCH doesn't come BYTE.  */
d503 1
a503 1
  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE.  */
d508 1
a508 1
  {	1,	1,  0, 0 },		/* DBCC doesn't come BYTE.  */
d513 1
a513 1
  {	1, 	1,  0, 0 },		/* PCREL1632 doesn't come BYTE.  */
d523 1
a523 1
  {	1,	1,  0, 0 },		/* ABSTOPCREL doesn't come BYTE.  */
d531 2
a532 1
   generates these.  */
d538 2
a539 1
   Integer arg to pass to the function.  */
d557 6
d669 5
a673 4
  /* Rewrite the PC relative instructions to absolute address ones.
     these are rumored to be faster, and the apollo linker refuses
     to deal with the PC relative relocations.  */
  if (opcode[0] == 0x60 && opcode[1] == 0xff) /* BRA -> JMP.  */
a674 2
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative branch to absolute jump"));
d678 1
a678 1
  else if (opcode[0] == 0x61 && opcode[1] == 0xff) /* BSR -> JSR.  */
a679 2
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative BSR to absolute JSR"));
d727 1
a727 1
  (!((S_IS_EXTERNAL (symbol) && EXTERN_FORCE_RELOC) \
d847 1
a847 1
  /* Adjust_reloc_syms doesn't know about the GOT.  */
d1022 1
a1022 1
    instring++;			/* Skip leading whitespace.  */
d1071 1
a1071 1
  /* Found a legitimate opcode, start matching operands.  */
d1080 1
a1080 1
      /* Ahh - it's a motorola style psuedo op.  */
d1130 1
a1130 1
  /* We've got the operands.  Find an opcode that'll accept them.  */
a1506 18
                case 'b':
                  switch (opP->mode)
                    {
                    case IMMED:
                    case ABSL:
                    case AREG:
                    case FPREG:
                    case CONTROL:
                    case POST:
                    case PRE:
                    case REGLST:
		      losing++;
		      break;
		    default:
		      break;
                    }
                  break;

a1710 10
		case 'x':
		  if (opP->mode != IMMED)
		    losing++;
		  else if (opP->disp.exp.X_op != O_constant
			   || opP->disp.exp.X_add_number < -1
                           || opP->disp.exp.X_add_number > 7
                           || opP->disp.exp.X_add_number == 0)
		    losing++;
		  break;

d1718 1
a1718 1
		  /* Memory addressing mode used by pflushr.  */
a1771 19
		case 'w':
		  switch (opP->mode)
		    {
		      case IMMED:
		      case ABSL:
		      case AREG:
		      case DREG:
		      case FPREG:
		      case CONTROL:
		      case POST:
		      case PRE:
		      case REGLST:
			losing++;
			break;
		      default:
			break;
		    }
		  break;

d1795 3
a1797 1
		    losing++;
a1817 12
		 case 'y':
		   if (!(opP->mode == AINDR
			 || (opP->mode == DISP && !(opP->reg == PC ||
						    opP->reg == ZPC))))
		     losing++;
		   break;

		 case 'z':
		   if (!(opP->mode == AINDR || opP->mode == DISP))
		     losing++;
		   break;

d1820 1
a1820 1
		}
d1824 2
a1825 2
	    }
	}
d1828 3
a1830 1
	break;
a1845 3
		case cfloat:
		  strcpy (cp, _("ColdFire fpu (cfv4e)"));
		  break;
d1890 1
a1890 1
	}
d1895 2
a1896 1
  /* Now assemble it.  */
a1921 1
	case 'b':
a1927 3
	case 'w':
	case 'y':
	case 'z':
d1936 1
a1936 1
		nextword = get_num (&opP->disp, 90);
d1989 1
a1989 1
	      /* We gotta put out some float.  */
d2048 1
a2048 1
	      nextword = get_num (&opP->disp, 90);
d2063 1
a2063 1
	      /* Force into index mode.  Hope this works.  */
d2144 1
a2144 1
	      baseo = get_num (&opP->disp, 90);
d2146 1
a2146 1
		outro = get_num (&opP->odisp, 90);
d2174 1
a2174 1
	      /* Index register stuff.  */
d2189 1
a2189 2
			  && (arch_coldfire_p (current_architecture)
                              && !arch_coldfire_v4e_p(current_architecture))))
d2285 1
a2285 1
		  nextword |= 0x40;	/* No index reg.  */
d2333 1
a2333 1
	      /* Figure out inner displacement stuff.  */
d2394 1
a2394 1
	      nextword = get_num (&opP->disp, 90);
d2423 1
a2423 1
		  /* Fall through into long.  */
d2436 1
a2436 2

		case SIZE_WORD:
d2469 1
a2469 1
	      tmpreg = 90;
d2536 1
a2536 1
	  tmpreg = get_num (&opP->disp, 90);
d2556 1
a2556 1
	      if (subs (&opP->disp))	/* We can't relax it.  */
d2629 1
a2629 1
	    case 'C':		/* Fixed size LONG coproc branches.  */
d2634 1
a2634 1
	    case 'c':		/* Var size Coprocesssor branches.  */
d2651 1
a2651 1
	case 'C':		/* Ignore it.  */
d2654 1
a2654 1
	case 'd':		/* JF this is a kludge.  */
d2656 1
a2656 1
	  tmpreg = get_num (&opP->disp, 90);
d2669 1
a2669 1
	case 'E':		/* Ignore it.  */
d2676 1
a2676 1
	case 'G':		/* Ignore it.  */
d2685 1
a2685 1
	case 'J':		/* JF foo.  */
a2699 1
	    case ACR0:
a2702 1
	    case ACR1:
a2705 1
	    case ACR2:
a2708 1
	    case ACR3:
a2745 4
            case ROMBAR1:
              tmpreg = 0xC01;
              break;
	    case FLASHBAR:
a2748 1
	    case RAMBAR:
a2751 11
            case MPCR:
              tmpreg = 0xC0C;
              break;
            case EDRAMBAR:
              tmpreg = 0xC0D;
              break;
            case MBAR0:
            case SECMBAR:
              tmpreg = 0xC0E;
              break;
            case MBAR1:
a2754 36
            case PCR1U0:
              tmpreg = 0xD02;
              break;
            case PCR1L0:
              tmpreg = 0xD03;
              break;
            case PCR2U0:
              tmpreg = 0xD04;
              break;
            case PCR2L0:
              tmpreg = 0xD05;
              break;
            case PCR3U0:
              tmpreg = 0xD06;
              break;
            case PCR3L0:
              tmpreg = 0xD07;
              break;
            case PCR1L1:
              tmpreg = 0xD0A;
              break;
            case PCR1U1:
              tmpreg = 0xD0B;
              break;
            case PCR2L1:
              tmpreg = 0xD0C;
              break;
            case PCR2U1:
              tmpreg = 0xD0D;
              break;
            case PCR3L1:
              tmpreg = 0xD0E;
              break;
            case PCR3U1:
              tmpreg = 0xD0F;
              break;
d2826 1
a2826 1
	     will have the ADDR_REG bit set.  */
d2849 1
a2849 1
	case 'S':		/* Ignore it.  */
d2856 1
a2856 1
	case 'U':		/* Ignore it.  */
d2876 1
a2876 1
	    }			/* switch on cache token.  */
d3000 1
a3000 1
	case '_':	/* used only for move16 absolute 32-bit address.  */
d3003 1
a3003 1
	  tmpreg = get_num (&opP->disp, 90);
d3010 1
a3010 7
	  opP->reg &= 0x0F;	/* remove upper/lower bit.  */
	  break;
	case 'x':
	  tmpreg = get_num (&opP->disp, 80);
	  if (tmpreg == -1)
	    tmpreg = 0;
	  install_operand (s[1], tmpreg);
d3079 1
a3079 1
      the_ins.opcode[0] |= val & 0xFF;	/* JF FF is for M kludge.  */
d3134 1
a3134 1
      the_ins.numo++;		/* What a hack.  */
d3204 1
a3204 1
      /* more stuff goes here.  */
d3239 1
a3239 1
		{			/* ERROR.  */
d3250 1
a3250 1
    {				/* ERROR.  */
d3263 1
a3263 1
    c = *++str;			/* JF bitfield hack.  */
d3380 2
a3381 2
  /* Control registers.  */
  { "sfc", SFC },		/* Source Function Code.  */
d3383 1
a3383 1
  { "dfc", DFC },		/* Destination Function Code.  */
d3385 2
a3386 2
  { "cacr", CACR },		/* Cache Control Register.  */
  { "caar", CAAR },		/* Cache Address Register.  */
d3388 9
a3396 9
  { "usp", USP },		/* User Stack Pointer.  */
  { "vbr", VBR },		/* Vector Base Register.  */
  { "msp", MSP },		/* Master Stack Pointer.  */
  { "isp", ISP },		/* Interrupt Stack Pointer.  */

  { "itt0", ITT0 },		/* Instruction Transparent Translation Reg 0.  */
  { "itt1", ITT1 },		/* Instruction Transparent Translation Reg 1.  */
  { "dtt0", DTT0 },		/* Data Transparent Translation Register 0.  */
  { "dtt1", DTT1 },		/* Data Transparent Translation Register 1.  */
d3399 4
a3402 4
  { "iacr0", ITT0 },		/* Instruction Access Control Register 0.  */
  { "iacr1", ITT1 },		/* Instruction Access Control Register 0.  */
  { "dacr0", DTT0 },		/* Data Access Control Register 0.  */
  { "dacr1", DTT1 },		/* Data Access Control Register 0.  */
d3407 4
a3410 4
  { "acr0", ACR0 },		/* Access Control Unit 0.  */
  { "acr1", ACR1 },		/* Access Control Unit 1.  */
  { "acr2", ACR2 },		/* Access Control Unit 2.  */
  { "acr3", ACR3 },		/* Access Control Unit 3.  */
d3412 1
a3412 1
  { "tc", TC },			/* MMU Translation Control Register.  */
d3415 3
a3417 3
  { "mmusr", MMUSR },		/* MMU Status Register.  */
  { "srp", SRP },		/* User Root Pointer.  */
  { "urp", URP },		/* Supervisor Root Pointer.  */
d3422 5
a3426 30
  { "rombar", ROMBAR },		/* ROM Base Address Register.  */
  { "rambar0", RAMBAR0 },	/* ROM Base Address Register.  */
  { "rambar1", RAMBAR1 },	/* ROM Base Address Register.  */
  { "mbar", MBAR },		/* Module Base Address Register.  */

  { "mbar0",    MBAR0 },	/* mcfv4e registers.  */
  { "mbar1",    MBAR1 },	/* mcfv4e registers.  */
  { "rombar0",  ROMBAR },	/* mcfv4e registers.  */
  { "rombar1",  ROMBAR1 },	/* mcfv4e registers.  */
  { "mpcr",     MPCR },		/* mcfv4e registers.  */
  { "edrambar", EDRAMBAR },	/* mcfv4e registers.  */
  { "secmbar",  SECMBAR },	/* mcfv4e registers.  */
  { "asid",     TC },		/* mcfv4e registers.  */
  { "mmubar",   BUSCR },	/* mcfv4e registers.  */
  { "pcr1u0",   PCR1U0 },	/* mcfv4e registers.  */
  { "pcr1l0",   PCR1L0 },	/* mcfv4e registers.  */
  { "pcr2u0",   PCR2U0 },	/* mcfv4e registers.  */
  { "pcr2l0",   PCR2L0 },	/* mcfv4e registers.  */
  { "pcr3u0",   PCR3U0 },	/* mcfv4e registers.  */
  { "pcr3l0",   PCR3L0 },	/* mcfv4e registers.  */
  { "pcr1u1",   PCR1U1 },	/* mcfv4e registers.  */
  { "pcr1l1",   PCR1L1 },	/* mcfv4e registers.  */
  { "pcr2u1",   PCR2U1 },	/* mcfv4e registers.  */
  { "pcr2l1",   PCR2L1 },	/* mcfv4e registers.  */
  { "pcr3u1",   PCR3U1 },	/* mcfv4e registers.  */
  { "pcr3l1",   PCR3L1 },	/* mcfv4e registers.  */

  { "flashbar", FLASHBAR }, 	/* mcf528x registers.  */
  { "rambar",   RAMBAR },  	/* mcf528x registers.  */
  /* End of control registers.  */
d3460 1
a3460 1
  /* 68ec030 versions of same.  */
d3463 1
a3463 1
  /* 68ec030 access control unit, identical to 030 MMU status reg.  */
d3618 1
a3618 1
      /* No frag hacking involved; just put it out.  */
d3627 1
a3627 1
      /* Put out symbol-dependent info.  */
d3668 1
a3668 1
  /* There's some frag hacking.  */
d3780 1
a3780 1
  const char *retval = 0;	/* Empty string, or error msg text.  */
d3806 1
a3806 1
	  /* This is kludgey.  */
d3922 1
a3922 1
     gas expects pseudo ops to start with a dot.  */
a3982 6
    case mcf528x:
      control_regs = mcf528x_control_regs;
      break;
    case mcfv4e:
      control_regs = mcfv4e_control_regs;
      break;
d4155 1
a4155 1
/* Equal to MAX_PRECISION in atof-ieee.c.  */
d4240 1
a4240 1
  /* End ibm compiler workaround.  */
d4251 1
a4251 1
      fixP->fx_addnumber = val;	/* Remember value for emit_reloc.  */
d4288 1
a4288 1
      lower_limit = - (offsetT) 0x7fffffff - 1;	/* Avoid constant overflow.  */
d4349 1
a4349 1
  /* End ibm compiler workaround.  */
a4386 2
	  if (flag_keep_pcrel)
    	    as_fatal(_("Tried to convert PC relative BSR to absolute JSR"));
d4388 1
a4388 1
	  fragP->fr_opcode[1] = (char) 0xB9; /* JSR with ABSL LONG operand.  */
a4394 2
	  if (flag_keep_pcrel)
	    as_fatal(_("Tried to convert PC relative branch to absolute jump"));
d4396 1
a4396 1
	  fragP->fr_opcode[1] = (char) 0xF9; /* JMP with ABSL LONG operand.  */
d4409 2
a4410 2
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative conditional branch to absolute jump"));
d4412 2
a4413 4
      /* Only Bcc 68000 instructions can come here
	 Change bcc into b!cc/jmp absl long.  */
      fragP->fr_opcode[0] ^= 0x01;	/* Invert bcc.  */
      fragP->fr_opcode[1]  = 0x06;	/* Branch offset = 6.  */
d4416 1
a4416 1
	   different frag, in which case referring to them is a no-no.
d4420 1
a4420 1
      fragP->fr_fix += 2;	/* Account for jmp instruction.  */
d4432 1
a4432 1
      fragP->fr_opcode[1] |= 0x40;	/* Turn on LONG bit.  */
d4444 2
a4445 5
      /* Only DBcc instructions can come here.
	 Change dbcc into dbcc/bral.
	 JF: these used to be fr_opcode[2-7], but that's wrong.  */
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert DBcc to absolute jump"));
d4447 2
a4448 1
      *buffer_address++ = 0x00;	/* Branch offset = 4.  */
d4450 1
a4450 1
      *buffer_address++ = 0x60;	/* Put in bra pc+6.  */
d4455 1
a4455 1
      fragP->fr_fix += 6;	/* Account for bra/jmp instructions.  */
d4461 2
a4462 5
      /* Only DBcc instructions can come here.
	 Change dbcc into dbcc/jmp.
	 JF: these used to be fr_opcode[2-7], but that's wrong.  */
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative conditional branch to absolute jump"));
d4464 2
a4465 1
      *buffer_address++ = 0x00;		/* Branch offset = 4.  */
d4467 1
a4467 1
      *buffer_address++ = 0x60;		/* Put in bra pc + 6.  */
d4469 1
a4469 1
      *buffer_address++ = 0x4e;		/* Put in jmp long (0x4ef9).  */
d4472 1
a4472 1
      fragP->fr_fix += 6;		/* Account for bra/jmp instructions.  */
a4525 2
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative conditional branch to absolute jump"));
d4527 1
a4527 1
	 ABSTOPCREL is really trying to shorten an ABSOLUTE address anyway.  */
d4697 1
a4697 1
   you there. -KWK  */
d4710 1
a4710 1
  /* This is easy.  */
d4712 1
a4712 1
  /* Now the fun stuff.  */
d4714 2
a4715 2
  the_bytes[5] = (ri->r_symbolnum >>  8) & 0x0ff;
  the_bytes[6] =  ri->r_symbolnum        & 0x0ff;
d4720 1
a4720 1
#endif
a4786 2
      if (flag_keep_pcrel)
    	as_fatal(_("Tried to convert PC relative branch to absolute jump"));
d4807 5
a4811 5
   10:  Absolute 1:8	   only
   20:  Absolute 0:7	   only
   30:  absolute 0:15	   only
   40:  Absolute 0:31	   only
   50:  absolute 0:127	   only
d4813 5
a4817 4
   60:  absolute -128:127  only
   70:  absolute 0:4095	   only
   80:  absolute -1, 1:7   only
   90:  No bignums.          */
d4826 1
a4826 1
      /* Do the same thing the VAX asm does.  */
a4879 9
	case 80:
	  if (offs (exp) < -1
              || offs (exp) > 7
              || offs (exp) == 0)
	    {
	      as_warn (_("expression out of range: defaulting to 1"));
	      offs (exp) = 1;
	    }
	  break;
d4886 3
a4888 3
      if (offs (exp) <= 0	/* flonum.  */
	  && (ok == 90		/* no bignums */
	      || (ok > 10	/* Small-int ranges including 0 ok.  */
d4894 1
a4894 1
	  /* HACK! Turn it into a long.  */
d4897 1
a4897 1
	  gen_to_words (words, 2, 8L);	/* These numbers are magic!  */
d4915 1
a4915 1
      if (ok >= 10 && ok <= 80)
d5260 1
a5260 1
   not support and which take arguments.  */
d5745 1
a5745 1
    /* <HS> is an alias for <CC>.  */
d5748 1
a5748 1
    /* <LO> is an alias for <CS>.  */
d5757 1
a5757 1
    /* Issue a warning for conditions we can not swap.  */
d6051 1
a6051 1
       if d0 <ne> #CONST*20   then.  */
d6446 1
d6451 1
a6451 1
  /* Move init,var.  */
d6470 1
a6470 1
  /* cmp end,var.  */
d6486 1
a6486 1
  /* bcc bottom.  */
d6630 1
a6630 1
       while d0 <ne> #CONST*20   do.  */
d6768 1
a6768 1
				   rather than 16 bit one.  */
d6785 1
a6785 1
      /* Intentional fall-through.  */
d6861 1
a6861 1
      break;			/* -pic, Position Independent Code.  */
d6951 1
a6951 2
-m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m528x  | -m5307  |\n\
-m5407  | -mcfv4  | -mcfv4e\n\
d6977 2
a6978 2
/* Warning, this routine probably doesn't work anymore.  */
int
d7147 1
a7147 1
  /* Set file-specific flags if this is a cpu32 processor.  */
a7154 31

int
tc_m68k_regname_to_dw2regnum (const char *regname)
{
  unsigned int regnum;
  static const char *const regnames[] =
    {
      "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
      "a0", "a1", "a2", "a3", "a4", "a5", "a6", "sp",
      "fp0", "fp1", "fp2", "fp3", "fp4", "fp5", "fp6", "fp7",
      "pc"
    };

  for (regnum = 0; regnum < ARRAY_SIZE (regnames); regnum++)
    if (strcmp (regname, regnames[regnum]) == 0)
      return regnum;

  return -1;
}

void
tc_m68k_frame_initial_instructions (void)
{
  static int sp_regno = -1;

  if (sp_regno < 0)
    sp_regno = tc_m68k_regname_to_dw2regnum ("sp");

  cfi_add_CFA_def_cfa (sp_regno, -DWARF2_CIE_DATA_ALIGNMENT);
  cfi_add_CFA_offset (DWARF2_DEFAULT_RETURN_COLUMN, DWARF2_CIE_DATA_ALIGNMENT);
}
@


