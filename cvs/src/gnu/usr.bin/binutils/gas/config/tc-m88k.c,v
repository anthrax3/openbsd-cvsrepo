head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.12
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.8
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.10
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2013.08.11.09.43.54;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.20.22.54.13;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.15.19.34.35;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.01.00.02.00;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.02.20.45.28;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.30;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.36;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.51;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.25;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.09;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.09;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.43;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.23.10;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.46.27;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.35.58;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.31;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.53;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@A few fixes from Tim Mcintosh:
- provide 88110 syntactic sugar for the control register names
- correctly handle -m options
- and a minor fix to allow the register prefix to correctly be recognized in
  front of the condition codes (only needed for SVR4)
@
text
@/* m88k.c -- Assembler for the Motorola 88000
   Contributed by Devon Bowen of Buffalo University
   and Torbjorn Granlund of the Swedish Institute of Computer Science.
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
   2000, 2001, 2002
   Free Software Foundation, Inc.

This file is part of GAS, the GNU Assembler.

GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "m88k-opcode.h"

#if defined (OBJ_ELF)
#include "elf/m88k.h"
#endif

#ifdef BFD_ASSEMBLER
#define	RELOC_LO16	BFD_RELOC_LO16
#define	RELOC_HI16	BFD_RELOC_HI16
#define	RELOC_PC16	BFD_RELOC_18_PCREL_S2
#define	RELOC_PC26	BFD_RELOC_28_PCREL_S2
#define	RELOC_32	BFD_RELOC_32
#define NO_RELOC	BFD_RELOC_NONE
#endif

struct field_val_assoc
{
  char *name;
  unsigned val;
};

struct field_val_assoc m88100_cr_regs[] =
{
  {"PID", 0},
  {"PSR", 1},
  {"EPSR", 2},
  {"SSBR", 3},
  {"SXIP", 4},
  {"SNIP", 5},
  {"SFIP", 6},
  {"VBR", 7},
  {"DMT0", 8},
  {"DMD0", 9},
  {"DMA0", 10},
  {"DMT1", 11},
  {"DMD1", 12},
  {"DMA1", 13},
  {"DMT2", 14},
  {"DMD2", 15},
  {"DMA2", 16},
  {"SR0", 17},
  {"SR1", 18},
  {"SR2", 19},
  {"SR3", 20},

  {NULL, 0},
};

struct field_val_assoc m88110_cr_regs[] =
{
  {"PID", 0},
  {"PSR", 1},
  {"EPSR", 2},
  {"EXIP", 4},
  {"ENIP", 5},
  {"VBR", 7},
  {"SRX", 16},
  {"SR0", 17},
  {"SR1", 18},
  {"SR2", 19},
  {"SR3", 20},
  {"ICMD", 25},
  {"ICTL", 26},
  {"ISAR", 27},
  {"ISAP", 28},
  {"IUAP", 29},
  {"IIR", 30},
  {"IBP", 31},
  {"IPPU", 32},
  {"IPPL", 33},
  {"ISR", 34},
  {"ILAR", 35},
  {"IPAR", 36},
  {"DCMD", 40},
  {"DCTL", 41},
  {"DSAR", 42},
  {"DSAP", 43},
  {"DUAP", 44},
  {"DIR", 45},
  {"DBP", 46},
  {"DPPU", 47},
  {"DPPL", 48},
  {"DSR", 49},
  {"DLAR", 50},
  {"DPAR", 51},

  {NULL, 0},
};

struct field_val_assoc fcr_regs[] =
{
  {"FPECR", 0},
  {"FPHS1", 1},
  {"FPLS1", 2},
  {"FPHS2", 3},
  {"FPLS2", 4},
  {"FPPT", 5},
  {"FPRH", 6},
  {"FPRL", 7},
  {"FPIT", 8},

  {"FPSR", 62},
  {"FPCR", 63},

  {NULL, 0},
};

struct field_val_assoc cmpslot[] =
{
/* Integer	Floating point */
  {"nc", 0},
  {"cp", 1},
  {"eq", 2},
  {"ne", 3},
  {"gt", 4},
  {"le", 5},
  {"lt", 6},
  {"ge", 7},
  {"hi", 8},	{"ou", 8},
  {"ls", 9},	{"ib", 9},
  {"lo", 10},	{"in", 10},
  {"hs", 11},	{"ob", 11},
  {"be", 12},	{"ue", 12},
  {"nb", 13},	{"lg", 13},
  {"he", 14},	{"ug", 14},
  {"nh", 15},	{"ule", 15},
		{"ul", 16},
		{"uge", 17},

  {NULL, 0},
};

struct field_val_assoc cndmsk[] =
{
  {"gt0", 1},
  {"eq0", 2},
  {"ge0", 3},
  {"lt0", 12},
  {"ne0", 13},
  {"le0", 14},

  {NULL, 0},
};

struct m88k_insn
{
  unsigned long opcode;
  expressionS exp;
  enum m88k_reloc_type reloc;
};

static char *get_bf PARAMS ((char *param, unsigned *valp));
static char *get_cmp PARAMS ((char *param, unsigned *valp));
static char *get_cnd PARAMS ((char *param, unsigned *valp));
static char *get_bf2 PARAMS ((char *param, int bc));
static char *get_bf_offset_expression PARAMS ((char *param, unsigned *offsetp));
static char *get_cr PARAMS ((char *param, unsigned *regnop));
static char *get_fcr PARAMS ((char *param, unsigned *regnop));
static char *get_imm16 PARAMS ((char *param, struct m88k_insn *insn));
static char *get_o6 PARAMS ((char *param, unsigned *valp));
static char *match_name PARAMS ((char *, struct field_val_assoc *, unsigned *));
static char *get_reg PARAMS ((char *param, unsigned *regnop, unsigned int reg_prefix));
static char *get_vec9 PARAMS ((char *param, unsigned *valp));
static char *getval PARAMS ((char *param, unsigned int *valp));
static char *get_pcr PARAMS ((char *param, struct m88k_insn *insn,
		      enum m88k_reloc_type reloc));

static int calcop PARAMS ((struct m88k_opcode *format,
			   char *param, struct m88k_insn *insn));

static void s_m88k_88110 PARAMS ((int));

static struct hash_control *op_hash = NULL;

/* Current cpu (either 88100 or 88110, or 0 if unspecified).  Defaults to
   zero, overriden with -m<cpu> options or assembler pseudo-ops.  */
static int current_cpu = 0;

/* These chars start a comment anywhere in a source file (except inside
   another comment.  */
#if defined(OBJ_ELF)
const char comment_chars[] = "|";
#elif defined(OBJ_AOUT)
const char comment_chars[] = "|#";
#else
const char comment_chars[] = ";";
#endif

/* These chars only start a comment at the beginning of a line.  */
#if defined(OBJ_AOUT)
const char line_comment_chars[] = ";";
#else
const char line_comment_chars[] = "#";
#endif

#if defined(OBJ_ELF)
const char line_separator_chars[] = ";";
#else
const char line_separator_chars[] = "";
#endif

/* Chars that can be used to separate mant from exp in floating point nums */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant */
/* as in 0f123.456 */
/* or    0H1.234E-12 (see exp chars above) */
const char FLT_CHARS[] = "dDfF";

const pseudo_typeS md_pseudo_table[] =
{
#ifndef OBJ_ELF
  {"align", s_align_bytes, 4},
#else
  /* handled with s_align_ptwo in read.c potable[] */
#endif
  {"bss", s_lcomm, 1},
  {"def", s_set, 0},
  {"half", cons, 2},
  {"requires_88110", s_m88k_88110, 0},
  {"sbss", s_lcomm, 1},
#if !defined(OBJ_ELF) || !defined(TE_OpenBSD) /* i.e. NO_PSEUDO_DOT == 1 */
  /* Force set to be treated as an instruction.  */
  {"set", NULL, 0},
  {".set", s_set, 0},
#endif
  {"uahalf", cons, 2},
  {"uaword", cons, 4},
  {"word", cons, 4}, /* override potable[] which has word == short */
  {NULL, NULL, 0}
};

static void
s_m88k_88110(i)
     int i ATTRIBUTE_UNUSED;
{
  current_cpu = 88110;
}

void
md_begin ()
{
  const char *retval = NULL;
  unsigned int i = 0;

  /* Initialize hash table.  */
  op_hash = hash_new ();

  while (*m88k_opcodes[i].name)
    {
      char *name = m88k_opcodes[i].name;

      /* Hash each mnemonic and record its position.  */
      retval = hash_insert (op_hash, name, &m88k_opcodes[i]);

      if (retval != NULL)
	as_fatal (_("Can't hash instruction '%s':%s"),
		  m88k_opcodes[i].name, retval);

      /* Skip to next unique mnemonic or end of list.  */
      for (i++; !strcmp (m88k_opcodes[i].name, name); i++)
	;
    }

#ifdef OBJ_ELF
  record_alignment (text_section, 2);
  record_alignment (data_section, 2);
  record_alignment (bss_section, 2);

  bfd_set_private_flags (stdoutput, 0);
#endif
}

const char *md_shortopts = "m:";
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
    {
    case 'm':
      if (strcmp (arg, "88100") == 0)
	current_cpu = 88100;
      else if (strcmp (arg, "88110") == 0)
	current_cpu = 88110;
      else
	as_bad (_("Option `%s' is not recognized."), arg);
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (stream)
     FILE *stream;
{
  fputs (_("\
M88k options:\n\
  -m88100 | -m88110       select processor type\n"),
	 stream);
}

#ifdef OBJ_ELF
enum m88k_pic_reloc_type {
  pic_reloc_none,
  pic_reloc_abdiff,
  pic_reloc_gotrel,
  pic_reloc_plt
};

static bfd_reloc_code_real_type
m88k_get_reloc_code(struct m88k_insn *insn)
{
  switch (insn->exp.X_md)
    {
    default:
    case pic_reloc_none:
      return insn->reloc;

    case pic_reloc_abdiff:
      if (insn->reloc == BFD_RELOC_LO16)
	return BFD_RELOC_LO16_BASEREL;
      if (insn->reloc == BFD_RELOC_HI16)
	return BFD_RELOC_HI16_BASEREL;
      break;

    case pic_reloc_gotrel:
      if (insn->reloc == BFD_RELOC_LO16)
	return BFD_RELOC_LO16_GOTOFF;
      if (insn->reloc == BFD_RELOC_HI16)
	return BFD_RELOC_HI16_GOTOFF;
      break;

    case pic_reloc_plt:
      if (insn->reloc == BFD_RELOC_32)
	return BFD_RELOC_32_PLTOFF;
      if (insn->reloc == BFD_RELOC_28_PCREL_S2)
	return BFD_RELOC_32_PLT_PCREL;
      break;
    }

  as_bad ("Can't process pic type %d relocation type %d",
	  insn->exp.X_md, insn->reloc);

  return BFD_RELOC_NONE;
}
#else
#define m88k_get_reloc_code(insn)	(insn).reloc
#endif

void
md_assemble (op)
     char *op;
{
  char *param, *thisfrag;
  char c;
  struct m88k_opcode *format;
  struct m88k_insn insn;
  fixS *fixP;

  assert (op);

  /* Skip over instruction to find parameters.  */
  for (param = op; *param != 0 && !ISSPACE (*param); param++)
    ;
  c = *param;
  *param++ = '\0';

  /* Try to find the instruction in the hash table.  */
  /* XXX will not match XRF flavours of 88100 instructions on 88110 */
  if ((format = (struct m88k_opcode *) hash_find (op_hash, op)) == NULL)
    {
      as_bad (_("Invalid mnemonic '%s'"), op);
      return;
    }

  /* Try parsing this instruction into insn.  */
  insn.exp.X_add_symbol = 0;
  insn.exp.X_op_symbol = 0;
  insn.exp.X_add_number = 0;
  insn.exp.X_op = O_illegal;
  insn.exp.X_md = pic_reloc_none;
  insn.reloc = NO_RELOC;

  while (!calcop (format, param, &insn))
    {
      /* If it doesn't parse try the next instruction.  */
      if (!strcmp (format[0].name, format[1].name))
	format++;
      else
	{
	  as_fatal (_("Parameter syntax error"));
	  return;
	}
    }

  /* Grow the current frag and plop in the opcode.  */
  thisfrag = frag_more (4);
  md_number_to_chars (thisfrag, insn.opcode, 4);

  /* If this instruction requires labels mark it for later.  */
  switch (insn.reloc)
    {
    case NO_RELOC:
      break;

    case RELOC_LO16:
    case RELOC_HI16:
      fixP = fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal + 2,
		   2,
		   &insn.exp,
		   0,
		   m88k_get_reloc_code(&insn));
      fixP->fx_no_overflow = 1;
      break;

#ifdef M88KCOFF
    case RELOC_IW16:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal,
		   4,
		   &insn.exp,
		   0,
		   m88k_get_reloc_code(&insn));
      break;
#endif

    case RELOC_PC16:
#ifdef OBJ_ELF
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal ,
		   4,
		   &insn.exp,
		   1,
		   m88k_get_reloc_code(&insn));
#else
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal + 2,
		   2,
		   &insn.exp,
		   1,
		   m88k_get_reloc_code(&insn));
#endif
      break;

    case RELOC_PC26:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal,
		   4,
		   &insn.exp,
		   1,
		   m88k_get_reloc_code(&insn));
      break;

    case RELOC_32:
      fix_new_exp (frag_now,
		   thisfrag - frag_now->fr_literal,
		   4,
		   &insn.exp,
		   0,
		   m88k_get_reloc_code(&insn));
      break;

    default:
      as_fatal (_("Unknown relocation type"));
      break;
    }
}

static int
calcop (format, param, insn)
     struct m88k_opcode *format;
     char *param;
     struct m88k_insn *insn;
{
  char *fmt = format->op_spec;
  int f;
  unsigned val;
  unsigned opcode;
  unsigned int reg_prefix = 'r';

  insn->opcode = format->opcode;
  opcode = 0;

  /*
   * Instructions which have no arguments (such as rte) will get
   * correctly reported only if param == "", although there could be
   * whitespace following the instruction.
   * Rather than eating whitespace here, let's assume everything is
   * fine. If there were non-wanted arguments, they will be parsed as
   * an incorrect opcode at the offending line, so that's not too bad.
   * -- miod
   */
  if (*fmt == '\0')
    return 1;

  for (;;)
    {
      if (param == NULL)
	return 0;

      f = *fmt++;
      switch (f)
	{
	case 0:
	  insn->opcode |= opcode;
	  return (*param == 0 || *param == '\n');

	default:
	  if (f != *param++)
	    return 0;
	  break;

	case 'd':
	  param = get_reg (param, &val, reg_prefix);
	  reg_prefix = 'r';
	  opcode |= val << 21;
	  break;

	case 'o':
	  param = get_o6 (param, &val);
	  opcode |= ((val >> 2) << 7);
	  break;

	case 'x':
	  reg_prefix = 'x';
	  break;

	case '1':
	  param = get_reg (param, &val, reg_prefix);
	  reg_prefix = 'r';
	  opcode |= val << 16;
	  break;

	case '2':
	  param = get_reg (param, &val, reg_prefix);
	  reg_prefix = 'r';
	  opcode |= val;
	  break;

	case '3':
	  param = get_reg (param, &val, 'r');
	  opcode |= (val << 16) | val;
	  break;

	case 'I':
	  param = get_imm16 (param, insn);
	  break;

	case 'b':
	  param = get_bf (param, &val);
	  opcode |= val;
	  break;

	case 'p':
	  param = get_pcr (param, insn, RELOC_PC16);
	  break;

	case 'P':
	  param = get_pcr (param, insn, RELOC_PC26);
	  break;

	case 'B':
	  param = get_cmp (param, &val);
	  opcode |= val;
	  break;

	case 'M':
	  param = get_cnd (param, &val);
	  opcode |= val;
	  break;

	case 'c':
	  param = get_cr (param, &val);
	  opcode |= val << 5;
	  break;

	case 'f':
	  param = get_fcr (param, &val);
	  opcode |= val << 5;
	  break;

	case 'V':
	  param = get_vec9 (param, &val);
	  opcode |= val;
	  break;

	case '?':
	  /* Having this here repeats the warning sometimes.
	   But can't we stand that?  */
	  as_warn (_("Use of obsolete instruction"));
	  break;
	}
    }
}

static char *
match_name (param, assoc_tab, valp)
     char *param;
     struct field_val_assoc *assoc_tab;
     unsigned *valp;
{
  int i;
  char *name;
  int name_len;

  for (i = 0;; i++)
    {
      name = assoc_tab[i].name;
      if (name == NULL)
	return NULL;
      name_len = strlen (name);
      if (!strncmp (param, name, name_len))
	{
	  *valp = assoc_tab[i].val;
	  return param + name_len;
	}
    }
}

static char *
get_reg (param, regnop, reg_prefix)
     char *param;
     unsigned *regnop;
     unsigned int reg_prefix;
{
  unsigned c;
  unsigned regno;

#ifdef REGISTER_PREFIX
  c = *param++;
  if (c != REGISTER_PREFIX)
    return NULL;
#endif

  c = *param++;
  if (c == reg_prefix)
    {
      regno = *param++ - '0';
      if (regno < 10)
	{
	  if (regno == 0)
	    {
	      *regnop = 0;
	      return param;
	    }
	  c = *param - '0';
	  if (c < 10)
	    {
	      regno = regno * 10 + c;
	      if (c < 32)
		{
		  *regnop = regno;
		  return param + 1;
		}
	    }
	  else
	    {
	      *regnop = regno;
	      return param;
	    }
	}
      return NULL;
    }
  else if (c == 's' && param[0] == 'p')
    {
      *regnop = 31;
      return param + 1;
    }

  return NULL;
}

static char *
get_imm16 (param, insn)
     char *param;
     struct m88k_insn *insn;
{
  enum m88k_reloc_type reloc = NO_RELOC;
  unsigned int val;
  char *save_ptr;
#ifdef REGISTER_PREFIX
  int found_prefix = 0;
#endif

#ifdef REGISTER_PREFIX
  if (*param == REGISTER_PREFIX)
    {
      param++;
      found_prefix = 1;
    }
#endif

  if (!strncmp (param, "hi16", 4) && !ISALNUM (param[4]))
    {
      reloc = RELOC_HI16;
      param += 4;
    }
  else if (!strncmp (param, "lo16", 4) && !ISALNUM (param[4]))
    {
      reloc = RELOC_LO16;
      param += 4;
    }
#ifdef M88KCOFF
  else if (!strncmp (param, "iw16", 4) && !ISALNUM (param[4]))
    {
      reloc = RELOC_IW16;
      param += 4;
    }
#endif

#ifdef REGISTER_PREFIX
  if (found_prefix && reloc == NO_RELOC)
    return NULL;
#endif

  save_ptr = input_line_pointer;
  input_line_pointer = param;
  expression (&insn->exp);
  param = input_line_pointer;
  input_line_pointer = save_ptr;

  val = insn->exp.X_add_number;

  if (insn->exp.X_op == O_constant)
    {
      /* Insert the value now, and reset reloc to NO_RELOC.  */
      if (reloc == NO_RELOC)
	{
	  /* Warn about too big expressions if not surrounded by xx16.  */
	  if (val > 0xffff)
	    as_warn (_("Expression truncated to 16 bits"));
	}

      if (reloc == RELOC_HI16)
	val >>= 16;

      insn->opcode |= val & 0xffff;
      reloc = NO_RELOC;
    }
  else if (reloc == NO_RELOC)
    /* We accept a symbol even without lo16, hi16, etc, and assume
       lo16 was intended.  */
    reloc = RELOC_LO16;

  insn->reloc = reloc;

  return param;
}

static char *
get_pcr (param, insn, reloc)
     char *param;
     struct m88k_insn *insn;
     enum m88k_reloc_type reloc;
{
  char *saveptr, *saveparam;

  saveptr = input_line_pointer;
  input_line_pointer = param;

  expression (&insn->exp);

  saveparam = input_line_pointer;
  input_line_pointer = saveptr;

  /* Botch: We should relocate now if O_constant.  */
  insn->reloc = reloc;

  return saveparam;
}

static char *
get_cmp (param, valp)
     char *param;
     unsigned *valp;
{
  unsigned int val;
  char *save_ptr;

  save_ptr = param;

#ifdef REGISTER_PREFIX
  /* SVR4 compiler prefixes condition codes with the register prefix */
  if (*param == REGISTER_PREFIX)
    param++;
#endif
  param = match_name (param, cmpslot, valp);
  val = *valp;

  if (param == NULL)
    {
      param = save_ptr;

      save_ptr = input_line_pointer;
      input_line_pointer = param;
      val = get_absolute_expression ();
      param = input_line_pointer;
      input_line_pointer = save_ptr;

      if (val >= 32)
	{
	  as_warn (_("Expression truncated to 5 bits"));
	  val %= 32;
	}
    }

  *valp = val << 21;
  return param;
}

static char *
get_cnd (param, valp)
     char *param;
     unsigned *valp;
{
  unsigned int val;

  if (ISDIGIT (*param))
    {
      param = getval (param, &val);

      if (val >= 32)
	{
	  as_warn (_("Expression truncated to 5 bits"));
	  val %= 32;
	}
    }
  else
    {
#ifdef REGISTER_PREFIX
      /* SVR4 compiler prefixes condition codes with the register prefix */
      if (*param == REGISTER_PREFIX)
	param++;
#endif

      param[0] = TOLOWER (param[0]);
      param[1] = TOLOWER (param[1]);

      param = match_name (param, cndmsk, valp);

      if (param == NULL)
	return NULL;

      val = *valp;
    }

  *valp = val << 21;
  return param;
}

static char *
get_bf2 (param, bc)
     char *param;
     int bc;
{
  int depth = 0;
  int c;

  for (;;)
    {
      c = *param;
      if (c == 0)
	return param;
      else if (c == '(')
	depth++;
      else if (c == ')')
	depth--;
      else if (c == bc && depth <= 0)
	return param;
      param++;
    }
}

static char *
get_bf_offset_expression (param, offsetp)
     char *param;
     unsigned *offsetp;
{
  unsigned offset;

#ifdef REGISTER_PREFIX
  /* SVR4 compiler prefixes condition codes with the register prefix */
  if (*param == REGISTER_PREFIX && ISALPHA (param[1]))
    param++;
#endif

  if (ISALPHA (param[0]))
    {
      param[0] = TOLOWER (param[0]);
      param[1] = TOLOWER (param[1]);

      param = match_name (param, cmpslot, offsetp);

      return param;
    }
  else
    {
      input_line_pointer = param;
      offset = get_absolute_expression ();
      param = input_line_pointer;
    }

  *offsetp = offset;
  return param;
}

static char *
get_bf (param, valp)
     char *param;
     unsigned *valp;
{
  unsigned offset = 0;
  unsigned width = 0;
  char *xp;
  char *save_ptr;

  xp = get_bf2 (param, '<');

  save_ptr = input_line_pointer;
  input_line_pointer = param;
  if (*xp == 0)
    {
      /* We did not find '<'.  We have an offset (width implicitly 32).  */
      param = get_bf_offset_expression (param, &offset);
      input_line_pointer = save_ptr;
      if (param == NULL)
	return NULL;
    }
  else
    {
      *xp++ = 0;		/* Overwrite the '<' */
      param = get_bf2 (xp, '>');
      if (*param == 0)
	return NULL;
      *param++ = 0;		/* Overwrite the '>' */

      width = get_absolute_expression ();
      xp = get_bf_offset_expression (xp, &offset);
      input_line_pointer = save_ptr;

      if (xp + 1 != param)
	return NULL;
    }

  *valp = ((width % 32) << 5) | (offset % 32);

  return param;
}

static char *
get_cr (param, regnop)
     char *param;
     unsigned *regnop;
{
  unsigned regno;
  unsigned c;

#ifdef REGISTER_PREFIX
  if (*param++ != REGISTER_PREFIX)
    return NULL;
#endif

  if (!strncmp (param, "cr", 2))
    {
      param += 2;

      regno = *param++ - '0';
      if (regno < 10)
	{
	  if (regno == 0)
	    {
	      *regnop = 0;
	      return param;
	    }
	  c = *param - '0';
	  if (c < 10)
	    {
	      regno = regno * 10 + c;
	      if (c < 64)
		{
		  *regnop = regno;
		  return param + 1;
		}
	    }
	  else
	    {
	      *regnop = regno;
	      return param;
	    }
	}
      return NULL;
    }

  param = match_name (param,
		      current_cpu == 88110 ? m88110_cr_regs : m88100_cr_regs,
		      regnop);

  return param;
}

static char *
get_fcr (param, regnop)
     char *param;
     unsigned *regnop;
{
  unsigned regno;
  unsigned c;

#ifdef REGISTER_PREFIX
  if (*param++ != REGISTER_PREFIX)
    return NULL;
#endif

  if (!strncmp (param, "fcr", 3))
    {
      param += 3;

      regno = *param++ - '0';
      if (regno < 10)
	{
	  if (regno == 0)
	    {
	      *regnop = 0;
	      return param;
	    }
	  c = *param - '0';
	  if (c < 10)
	    {
	      regno = regno * 10 + c;
	      if (c < 64)
		{
		  *regnop = regno;
		  return param + 1;
		}
	    }
	  else
	    {
	      *regnop = regno;
	      return param;
	    }
	}
      return NULL;
    }

  param = match_name (param, fcr_regs, regnop);

  return param;
}

static char *
get_vec9 (param, valp)
     char *param;
     unsigned *valp;
{
  unsigned val;
  char *save_ptr;

  save_ptr = input_line_pointer;
  input_line_pointer = param;
  val = get_absolute_expression ();
  param = input_line_pointer;
  input_line_pointer = save_ptr;

  if (val >= 1 << 9)
    as_warn (_("Expression truncated to 9 bits"));

  *valp = val % (1 << 9);

  return param;
}

static char *
get_o6 (param, valp)
     char *param;
     unsigned *valp;
{
  unsigned val;
  char *save_ptr;

  save_ptr = input_line_pointer;
  input_line_pointer = param;
  val = get_absolute_expression ();
  param = input_line_pointer;
  input_line_pointer = save_ptr;

  if (val & 0x3)
    as_warn (_("Removed lower 2 bits of expression"));

  *valp = val;

  return (param);
}

#define hexval(z) \
  (ISDIGIT (z) ? (z) - '0' :						\
   ISLOWER (z) ? (z) - 'a' + 10 : 					\
   ISUPPER (z) ? (z) - 'A' + 10 : (unsigned) -1)

static char *
getval (param, valp)
     char *param;
     unsigned int *valp;
{
  unsigned int val = 0;
  unsigned int c;

  c = *param++;
  if (c == '0')
    {
      c = *param++;
      if (c == 'x' || c == 'X')
	{
	  c = *param++;
	  c = hexval (c);
	  while (c < 16)
	    {
	      val = val * 16 + c;
	      c = *param++;
	      c = hexval (c);
	    }
	}
      else
	{
	  c -= '0';
	  while (c < 8)
	    {
	      val = val * 8 + c;
	      c = *param++ - '0';
	    }
	}
    }
  else
    {
      c -= '0';
      while (c < 10)
	{
	  val = val * 10 + c;
	  c = *param++ - '0';
	}
    }

  *valp = val;
  return param - 1;
}

void
md_number_to_chars (buf, val, nbytes)
     char *buf;
     valueT val;
     int nbytes;
{
  number_to_chars_bigendian (buf, val, nbytes);
}

#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

int md_short_jump_size = 4;
int md_long_jump_size = 4;

void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
     fragS *frag;
     symbolS *to_symbol;
{
  /* Since all instructions have the same width, it does not make sense to
     try and abuse a conditional instruction to get a short displacement
     (such as bb1 0, %r0, address).  */
  md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol);
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
     fragS *frag;
     symbolS *to_symbol;
{
  ptr[0] = (char) 0xc0;		/* br to_addr */
  ptr[1] = 0x00;
  ptr[2] = 0x00;
  ptr[3] = 0x00;
  fix_new (frag,
	   ptr - frag->fr_literal,
	   4,
	   to_symbol,
	   (offsetT) 0,
	   0,
	   RELOC_PC26);
}

int
md_estimate_size_before_relax (fragP, segment_type)
     fragS *fragP ATTRIBUTE_UNUSED;
     segT segment_type ATTRIBUTE_UNUSED;
{
  as_fatal (_("Relaxation should never occur"));
  return (-1);
}

#ifdef M88KCOFF

/* These functions are needed if we are linking with obj-coffbfd.c.
   That file may be replaced by a more BFD oriented version at some
   point.  If that happens, these functions should be reexamined.

   Ian Lance Taylor, Cygnus Support, 13 July 1993.  */

/* Given a fixS structure (created by a call to fix_new, above),
   return the BFD relocation type to use for it.  */

short
tc_coff_fix2rtype (fixp)
     fixS *fixp;
{
  switch (fixp->fx_r_type)
    {
    case RELOC_LO16:
      return R_LVRT16;
    case RELOC_HI16:
      return R_HVRT16;
    case RELOC_PC16:
      return R_PCR16L;
    case RELOC_PC26:
      return R_PCR26L;
    case RELOC_32:
      return R_VRT32;
    case RELOC_IW16:
      return R_VRT16;
    default:
      abort ();
    }
}

/* Apply a fixS to the object file.  Since COFF does not use addends
   in relocs, the addend is actually stored directly in the object
   file itself.  */

void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
{
  long val = * (long *) valP;
  char *buf;

  buf = fixP->fx_frag->fr_literal + fixP->fx_where;
  fixP->fx_addnumber = val;
  fixP->fx_offset = 0;

  switch (fixP->fx_r_type)
    {
    case RELOC_IW16:
      fixP->fx_offset = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_LO16:
      fixP->fx_offset = val >> 16;
      buf[0] = val >> 8;
      buf[1] = val;
      break;

    case RELOC_HI16:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      break;

    case RELOC_PC16:
      buf[0] = val >> 10;
      buf[1] = val >> 2;
      break;

    case RELOC_PC26:
      buf[0] |= (val >> 26) & 0x03;
      buf[1] = val >> 18;
      buf[2] = val >> 10;
      buf[3] = val >> 2;
      break;

    case RELOC_32:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    default:
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

#endif /* M88KCOFF */

/* Fill in rs_align_code fragments.  */

void
m88k_handle_align (fragp)
     fragS *fragp;
{
  static const unsigned char nop_pattern[] = { 0xf4, 0x00, 0x58, 0x00 };

  int bytes;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;

  if (bytes & 3)
    {
      int fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
      fragp->fr_fix += fix;
    }

  memcpy (p, nop_pattern, 4);
  fragp->fr_var = 4;
}

/* Where a PC relative offset is calculated from.  On the m88k they
   are calculated from just after the instruction.  */

long
md_pcrel_from (fixp)
     fixS *fixp;
{
  switch (fixp->fx_r_type)
    {
    case RELOC_PC16:
#ifdef OBJ_ELF
      /* FALLTHROUGH */
#else
      return fixp->fx_frag->fr_address + fixp->fx_where - 2;
#endif
    case RELOC_PC26:
#ifdef OBJ_ELF
    case BFD_RELOC_32_PLT_PCREL:
#endif
      return fixp->fx_frag->fr_address + fixp->fx_where;
    default:
      abort ();
    }
  /*NOTREACHED*/
}

#ifdef OBJ_ELF

valueT
md_section_align (segment, size)
     segT   segment ATTRIBUTE_UNUSED;
     valueT size;
{
  return size;
}

/* Generate the BFD reloc to be stuck in the object file from the
   fixup used internally in the assembler.  */

arelent *
tc_gen_reloc (sec, fixp)
     asection *sec ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *reloc;
  bfd_reloc_code_real_type code;

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* Make sure none of our internal relocations make it this far.
     They'd better have been fully resolved by this point.  */
  assert ((int) fixp->fx_r_type > 0);

  code = fixp->fx_r_type;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent `%s' relocation in object file"),
		    bfd_get_reloc_code_name (code));
      return NULL;
    }

  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
    {
      as_fatal (_("internal error? cannot generate `%s' relocation"),
		bfd_get_reloc_code_name (code));
    }
  assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);

  reloc->addend = fixp->fx_offset;

  return reloc;
}

/* Apply a fixS to the object file.  This is called for all the
   fixups we generated by the call to fix_new_exp, above.  In the call
   above we used a reloc code which was the largest legal reloc code
   plus the operand index.  Here we undo that to recover the operand
   index.  At this point all symbol values should be fully resolved,
   and we attempt to completely resolve the reloc.  If we can not do
   that, we determine the correct reloc code and put it back in the
   fixup.

   This is the ELF version.
*/

void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
{
  valueT val = * (valueT *) valP;
  char *buf;
  long insn;

  buf = fixP->fx_frag->fr_literal + fixP->fx_where;

  if (fixP->fx_subsy != NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));

  if (fixP->fx_addsy)
    {
#if 0
      /* can't empty 26-bit relocation values with memset() */
      if (fixP->fx_r_type == BFD_RELOC_28_PCREL_S2)
	{
	  insn = bfd_getb32 ((unsigned char *) buf);
	  insn &= ~0x03ffffff;
	  bfd_putb32(insn, buf);
	}
      else
	memset(buf, 0, fixP->fx_size);
#endif

      if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
	  && !S_IS_DEFINED (fixP->fx_addsy)
	  && !S_IS_WEAK (fixP->fx_addsy))
	S_SET_WEAK (fixP->fx_addsy);

      return;
    }

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return;

    case BFD_RELOC_HI16_BASEREL:
    case BFD_RELOC_LO16_BASEREL:
    case BFD_RELOC_HI16_GOTOFF:
    case BFD_RELOC_LO16_GOTOFF:
    case BFD_RELOC_32_PLTOFF:
      return;

    case BFD_RELOC_LO16:
    case BFD_RELOC_HI16:
      if (fixP->fx_pcrel)
	abort ();
      buf[0] = val >> 8;
      buf[1] = val;
      break;

    case BFD_RELOC_18_PCREL_S2:
      if ((val & 0x03) != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      "Branch to unaligned address (%lx)", (long)val);
      buf[2] = val >> 10;
      buf[3] = val >> 2;
      break;

    case BFD_RELOC_32_PLT_PCREL:
    case BFD_RELOC_28_PCREL_S2:
      if ((val & 0x03) != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      "Branch to unaligned address (%lx)", (long)val);
      buf[0] |= (val >> 26) & 0x03;
      buf[1] = val >> 18;
      buf[2] = val >> 10;
      buf[3] = val >> 2;
      break;

    case BFD_RELOC_32:
      insn = val;
      bfd_putb32(insn, buf);
      break;

    default:
      abort ();
    }

  if (/* fixP->fx_addsy == NULL && */ fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Set the ELF specific flags.  */
void
m88k_elf_final_processing ()
{
  if (current_cpu == 88110)
    elf_elfheader (stdoutput)->e_flags |= EF_M88110;
}

inline static char *
m88k_end_of_name (const char *suffix, const char *pattern, size_t patlen)
{
  if (strncmp (suffix, pattern, patlen) == 0
      && ! is_part_of_name (suffix[patlen]))
    return suffix + patlen;

  return NULL;
}

int
m88k_parse_name (name, expressionP, nextcharP)
    const char *name;
    expressionS *expressionP;
    char *nextcharP;
{
  char *next = input_line_pointer;
  char *next_end;
  enum m88k_pic_reloc_type reloc_type = pic_reloc_none;
  symbolS *symbolP;
  segT segment;

  if (*nextcharP != '#')
    return 0;

  if ((next_end = m88k_end_of_name (next + 1, "abdiff", 6)) != NULL)
    {
      reloc_type = pic_reloc_abdiff;
    }
  else if ((next_end = m88k_end_of_name (next + 1, "got_rel", 7)) != NULL)
    {
      reloc_type = pic_reloc_gotrel;
    }
  else if ((next_end = m88k_end_of_name (next + 1, "plt", 3)) != NULL)
    {
      reloc_type = pic_reloc_plt;
    }
  else
    return 0;

  symbolP = symbol_find_or_make (name);
  segment = S_GET_SEGMENT (symbolP);
  if (segment == absolute_section)
    {
      expressionP->X_op = O_constant;
      expressionP->X_add_number = S_GET_VALUE (symbolP);
    }
  else if (segment == reg_section)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = S_GET_VALUE (symbolP);
    }
  else
    {
      expressionP->X_op = O_symbol;
      expressionP->X_add_symbol = symbolP;
      expressionP->X_add_number = 0;
    }
  expressionP->X_md = reloc_type;

  *input_line_pointer = *nextcharP;
  input_line_pointer = next_end;
  *nextcharP = *input_line_pointer;
  *input_line_pointer = '\0';

  return 1;
}

int
m88k_fix_adjustable (fix)
     fixS *fix;
{
  return (fix->fx_r_type != BFD_RELOC_LO16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_HI16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_VTABLE_INHERIT
	  && fix->fx_r_type != BFD_RELOC_VTABLE_ENTRY
	  && (fix->fx_pcrel
	      || (fix->fx_subsy != NULL
		  && (S_GET_SEGMENT (fix->fx_subsy)
		      == S_GET_SEGMENT (fix->fx_addsy)))
	      || S_IS_LOCAL (fix->fx_addsy)));
}
#endif /* OBJ_ELF */

#ifdef OBJ_AOUT

/* Round up a section size to the appropriate boundary. */
valueT
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
{
#ifdef BFD_ASSEMBLER
  /* For a.out, force the section size to be aligned.  If we don't do
     this, BFD will align it for us, but it will not write out the
     final bytes of the section.  This may be a bug in BFD, but it is
     easier to fix it here since that is how the other a.out targets
     work.  */
  int align;

  align = bfd_get_section_alignment (stdoutput, segment);
  valueT mask = ((valueT) 1 << align) - 1;

  return (size + mask) & ~mask;
#else
  return (size + 7) & ~7;
#endif
}

const int md_reloc_size = 12; /* sizeof(struct relocation_info); */

void
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  long r_symbolnum;
  long r_addend = 0;
  long r_address;

  know (fixP->fx_addsy != NULL);

  r_address = fixP->fx_frag->fr_address + fixP->fx_where
	      - segment_address_in_file;
  md_number_to_chars (where, r_address, 4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
                 ? S_GET_TYPE (fixP->fx_addsy)
                 : fixP->fx_addsy->sy_number);

  where[4] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[6] = r_symbolnum & 0x0ff;
  where[7] = ((((!S_IS_DEFINED (fixP->fx_addsy)) << 7) & 0x80) | (0 & 0x70) |
	      (fixP->fx_r_type & 0xf));

  if (fixP->fx_addsy->sy_frag) {
    r_addend = fixP->fx_addsy->sy_frag->fr_address;
  }

  if (fixP->fx_pcrel) {
    r_addend -= r_address;
  } else {
    r_addend = fixP->fx_addnumber;
  }

  md_number_to_chars(&where[8], r_addend, 4);
}

void
tc_headers_hook(headers)
     object_headers *headers;
{
#if defined(TE_NetBSD) || defined(TE_OpenBSD)
  N_SET_INFO(headers->header, OMAGIC, M_88K_OPENBSD, 0);
  headers->header.a_info = htonl(headers->header.a_info);
#endif
}

#endif /* OBJ_AOUT */
@


1.9
log
@Implement tc_fix_adjustable() on ELF, and use it to prevent #got_rel
relocations to local symbols to be rewritten as relocations to the beginning
of the section they are in, plus an addend, as addend can't work for these
relocations, the way the got is set up. Inspired by tc-ppc.
@
text
@d49 1
a49 1
struct field_val_assoc cr_regs[] =
d76 41
d301 1
a301 1
const char *md_shortopts = "";
d823 1
a823 1
  if (param == REGISTER_PREFIX)
d871 1
a871 1
      if (param == REGISTER_PREFIX)
d922 1
a922 1
  if (param == REGISTER_PREFIX && ISALPHA (param[1]))
d1033 3
a1035 1
  param = match_name (param, cr_regs, regnop);
@


1.8
log
@When configured for ELF object format output, recognize #abdiff, #got_rel and
#plt symbol modifiers, and produce the appropriate relocation types.
This allows as(1) to correctly assemble PIC code.
@
text
@d1642 15
@


1.7
log
@m88k ELF toolchain, supporting static binaries only so far.

Assembler supports a register prefix of `#' when configured for SVR4, and `%'
when configured for OpenBSD. Pseudo-ops do not need a leading dot, except
when configured for OpenBSD, allowing the `set' instruction to be recognized
correctly.

Based upon various unfinished or unreliable works, including smurph@@'s early
work in 2003, my own attempts in 2004 and 2005, and Michael Kato's binutils
2.15 diff from 2005. Support for register prefixes, as well as fixing an
evil off-by-one in resolving 16-bit pc-relative relocations in ld (which would
only affect kernel .S files branching to global symbols), came as part of the
2012 work.

Not enabled yet (needs Makefile.bsd-wrapper, bfd/config.bfd and
gdb/configure.tgt updates to completely enable) so as not to disturb the
existing a.out toolchain builds; will hopefully be enabled very soon.
@
text
@d167 3
a169 1
#if defined(OBJ_AOUT) || defined(OBJ_ELF)
d176 1
a176 3
#if defined(OBJ_ELF)
const char line_comment_chars[] = "";
#elif defined(OBJ_AOUT)
d221 1
a221 1
     int i;
d256 1
a256 1
  bfd_set_private_flags (stdoutput, 0); /* XXX EF_88110 */
d298 48
d378 1
d410 1
a410 1
		   insn.reloc);
d421 1
a421 1
		   insn.reloc);
d432 1
a432 1
		   insn.reloc);
d439 1
a439 1
		   insn.reloc);
d449 1
a449 1
		   insn.reloc);
d458 1
a458 1
		   insn.reloc);
d1210 1
a1210 1

d1403 3
d1496 1
a1496 1
      if (fixP->fx_r_type == RELOC_PC26)
a1513 4
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return;

d1516 13
a1528 2
    case RELOC_LO16:
    case RELOC_HI16:
d1535 1
a1535 1
    case RELOC_PC16:
d1543 2
a1544 1
    case RELOC_PC26:
d1554 1
a1554 1
    case RELOC_32:
d1573 68
@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d30 13
d135 1
a135 1
  enum reloc_type reloc;
a150 1

d152 1
a152 1
		      enum reloc_type reloc));
d157 2
a158 1
extern char *myname;
d161 3
a163 2
/* These bits should be turned off in the first address of every segment */
int md_seg_align = 7;
d167 3
d171 1
d174 5
d180 1
d182 3
d186 1
d198 1
d200 4
a204 2
  {"dfloat", float_cons, 'd'},
  {"ffloat", float_cons, 'f'},
d206 3
a208 3
  {"bss", s_lcomm, 1},
  {"string", stringer, 0},
  {"word", cons, 4},
d212 4
d219 7
d250 8
d268 2
a269 2
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d271 16
a286 1
  return 0;
d291 1
a291 1
     FILE *stream ATTRIBUTE_UNUSED;
d293 4
d307 1
d318 1
d356 1
a356 1
      fix_new_exp (frag_now,
d362 1
d365 1
d374 1
d377 8
d391 1
d403 9
d433 12
d447 1
a447 1
      if (param == 0)
d449 1
d537 1
a537 1
	  /* Having this here repeats the warning somtimes.
d578 6
d619 1
a619 1
  return 0;
d627 1
a627 1
  enum reloc_type reloc = NO_RELOC;
d630 11
d652 1
d658 6
d703 1
a703 1
     enum reloc_type reloc;
d731 5
d779 6
d830 6
d907 5
d956 5
d1163 1
d1173 4
a1176 11
  ptr[0] = (char) 0xc0;
  ptr[1] = 0x00;
  ptr[2] = 0x00;
  ptr[3] = 0x00;
  fix_new (frag,
	   ptr - frag->fr_literal,
	   4,
	   to_symbol,
	   (offsetT) 0,
	   0,
	   RELOC_PC26);		/* Botch: Shouldn't this be RELOC_PC16? */
a1178 2
int md_long_jump_size = 4;

d1187 1
a1187 1
  ptr[0] = (char) 0xc0;
d1257 1
d1275 2
a1276 3
      fixP->fx_offset = val >> 16;
      buf[0] = val >> 8;
      buf[1] = val;
d1306 32
d1348 3
d1352 1
d1361 63
a1423 1
/* Fill in rs_align_code fragments.  */
d1426 4
a1429 2
m88k_handle_align (fragp)
     fragS *fragp;
d1431 27
a1457 1
  static const unsigned char nop_pattern[] = { 0xf4, 0x00, 0x58, 0x00 };
d1459 2
a1460 2
  int bytes;
  char *p;
d1462 2
a1463 1
  if (fragp->fr_type != rs_align_code)
d1466 32
a1497 2
  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;
d1499 2
a1500 7
  if (bytes & 3)
    {
      int fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
      fragp->fr_fix += fix;
d1503 87
a1589 2
  memcpy (p, nop_pattern, 4);
  fragp->fr_var = 4;
d1592 1
a1592 1
#endif /* M88KCOFF */
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d1065 1
a1065 1
   point.  If that happens, these functions should be rexamined.
@


1.4
log
@resolve conflicts.
@
text
@d5 1
a5 1
   2000
a24 1
#include <ctype.h>
d26 1
d128 2
d134 2
a135 1
static char *get_reg PARAMS ((char *param, unsigned *regnop, int reg_prefix));
d152 1
a152 1
   another comment */
a167 3
extern void float_cons (), cons (), s_globl (), s_space (),
  s_set (), s_lcomm ();

a173 1
  {"global", s_globl, 0},
d181 1
a181 1
  {0}
d190 1
a190 2
  /* initialize hash table */

a192 2
  /* loop until you see the end of the list */

d197 1
a197 2
      /* hash each mnemonic and record its position */

d204 1
a204 2
      /* skip to next unique mnemonic or end of list */

d210 1
a210 1
CONST char *md_shortopts = "";
d218 2
a219 2
     int c;
     char *arg;
d226 1
a226 1
     FILE *stream;
d241 2
a242 3
  /* skip over instruction to find parameters */

  for (param = op; *param != 0 && !isspace (*param); param++)
d247 1
a247 2
  /* try to find the instruction in the hash table */

d254 1
a254 2
  /* try parsing this instruction into insn */

d263 1
a263 2
      /* if it doesn't parse try the next instruction */

d273 1
a273 2
  /* grow the current frag and plop in the opcode */

d277 1
a277 2
  /* if this instruction requires labels mark it for later */

d336 1
a336 1
  int reg_prefix = 'r';
d468 1
a468 1
     int reg_prefix;
d520 1
a520 1
  if (!strncmp (param, "hi16", 4) && !isalnum (param[4]))
d525 1
a525 1
  else if (!strncmp (param, "lo16", 4) && !isalnum (param[4]))
d530 1
a530 1
  else if (!strncmp (param, "iw16", 4) && !isalnum (param[4]))
d633 1
a633 1
  if (isdigit (*param))
d645 2
a646 5
      if (isupper (*param))
	*param = tolower (*param);

      if (isupper (param[1]))
	param[1] = tolower (param[1]);
d690 1
a690 1
  if (isalpha (param[0]))
d692 2
a693 4
      if (isupper (param[0]))
	param[0] = tolower (param[0]);
      if (isupper (param[1]))
	param[1] = tolower (param[1]);
d882 1
a882 1
  return(param);
d886 3
a888 3
  (isdigit (z) ? (z) - '0' :						\
   islower (z) ? (z) - 'a' + 10 : 					\
   isupper (z) ? (z) - 'A' + 10 : -1)
a945 98
#if 0

/* This routine is never called.  What is it for?
   Ian Taylor, Cygnus Support 13 Jul 1993 */

void
md_number_to_imm (buf, val, nbytes, fixP, seg_type)
     unsigned char *buf;
     unsigned int val;
     int nbytes;
     fixS *fixP;
     int seg_type;
{
  if (seg_type != N_TEXT || fixP->fx_r_type == NO_RELOC)
    {
      switch (nbytes)
	{
	case 4:
	  *buf++ = val >> 24;
	  *buf++ = val >> 16;
	case 2:
	  *buf++ = val >> 8;
	case 1:
	  *buf = val;
	  break;

	default:
	  abort ();
	}
      return;
    }

  switch (fixP->fx_r_type)
    {
    case RELOC_IW16:
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case RELOC_LO16:
      buf[0] = val >> 8;
      buf[1] = val;
      break;

    case RELOC_HI16:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      break;

    case RELOC_PC16:
      val += 4;
      buf[0] = val >> 10;
      buf[1] = val >> 2;
      break;

    case RELOC_PC26:
      val += 4;
      buf[0] |= (val >> 26) & 0x03;
      buf[1] = val >> 18;
      buf[2] = val >> 10;
      buf[3] = val >> 2;
      break;

    case RELOC_32:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    default:
      as_fatal (_("Bad relocation type"));
      break;
    }
}

#endif /* 0 */

void
md_number_to_disp (buf, val, nbytes)
     char *buf;
     int val;
     int nbytes;
{
  as_fatal (_("md_number_to_disp not defined"));
  md_number_to_chars (buf, val, nbytes);
}

void
md_number_to_field (buf, val, nbytes)
     char *buf;
     int val;
     int nbytes;
{
  as_fatal (_("md_number_to_field not defined"));
  md_number_to_chars (buf, val, nbytes);
}

d1011 2
a1012 1
     addressT from_addr, to_addr;
d1034 2
a1035 1
     addressT from_addr, to_addr;
d1054 2
a1055 2
     fragS *fragP;
     segT segment_type;
a1060 146
#if 0

/* As far as I can tell, this routine is never called.  What is it
   doing here?
   Ian Taylor, Cygnus Support 13 Jul 1993 */

/*
 * Risc relocations are completely different, so it needs
 * this machine dependent routine to emit them.
 */
void
emit_relocations (fixP, segment_address_in_file)
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  struct reloc_info_m88k ri;
  symbolS *symbolP;
  extern char *next_object_file_charP;

  bzero ((char *) &ri, sizeof (ri));
  for (; fixP; fixP = fixP->fx_next)
    {
      if (fixP->fx_r_type >= NO_RELOC)
	{
	  fprintf (stderr, "fixP->fx_r_type = %d\n", fixP->fx_r_type);
	  abort ();
	}

      if ((symbolP = fixP->fx_addsy) != NULL)
	{
	  ri.r_address = fixP->fx_frag->fr_address +
	    fixP->fx_where - segment_address_in_file;
	  if ((symbolP->sy_type & N_TYPE) == N_UNDF)
	    {
	      ri.r_extern = 1;
	      ri.r_symbolnum = symbolP->sy_number;
	    }
	  else
	    {
	      ri.r_extern = 0;
	      ri.r_symbolnum = symbolP->sy_type & N_TYPE;
	    }
	  if (symbolP && symbol_get_frag (symbolP))
	    {
	      ri.r_addend = symbol_get_frag (symbolP)->fr_address;
	    }
	  ri.r_type = fixP->fx_r_type;
	  if (fixP->fx_pcrel)
	    {
	      ri.r_addend -= ri.r_address;
	    }
	  else
	    {
	      ri.r_addend = fixP->fx_addnumber;
	    }

	  append (&next_object_file_charP, (char *) &ri, sizeof (ri));
	}
    }
}

#endif /* 0 */

#if 0

/* This routine can be subsumed by s_lcomm in read.c.
   Ian Taylor, Cygnus Support 13 Jul 1993 */

static void
s_bss ()
{
  char *name;
  char c;
  char *p;
  int temp, bss_align;
  symbolS *symbolP;

  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_warn (_("Expected comma after name"));
      ignore_rest_of_line ();
      return;
    }
  input_line_pointer++;
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_("BSS length (%d.) <0! Ignored."), temp);
      ignore_rest_of_line ();
      return;
    }
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      bss_align = get_absolute_expression ();
    }
  else
    bss_align = 0;

  if (!S_IS_DEFINED(symbolP)
      || S_GET_SEGMENT(symbolP) == SEG_BSS)
    {
      if (! need_pass_2)
	{
	  char *p;
	  segT current_seg = now_seg;
	  subsegT current_subseg = now_subseg;

	  subseg_set (SEG_BSS, 1); /* switch to bss	*/

	  if (bss_align)
	    frag_align (bss_align, 0, 0);

	  /* detach from old frag */
	  if (symbolP->sy_type == N_BSS && symbol_get_frag (symbolP) != NULL)
	    symbol_get_frag (symbolP)->fr_symbol = NULL;

	  symbol_set_frag (symbolP, frag_now);
	  p = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
			(offsetT) temp, (char *)0);
	  *p = 0;
	  S_SET_SEGMENT (symbolP, SEG_BSS);

	  subseg_set (current_seg, current_subseg);
	}
    }
  else
    {
      as_warn (_("Ignoring attempt to re-define symbol %s."), name);
    }

  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      input_line_pointer++;
    }
}

#endif /* 0 */

d1100 4
a1103 3
md_apply_fix (fixp, val)
     fixS *fixp;
     long val;
d1105 1
d1108 2
a1109 2
  buf = fixp->fx_frag->fr_literal + fixp->fx_where;
  fixp->fx_offset = 0;
d1111 1
a1111 1
  switch (fixp->fx_r_type)
d1114 1
a1114 1
      fixp->fx_offset = val >> 16;
d1120 1
a1120 1
      fixp->fx_offset = val >> 16;
d1126 1
a1126 1
      fixp->fx_offset = val >> 16;
d1153 3
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d4 2
a5 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
a141 1

d152 1
a152 1
/* These chars only start a comment at the beginning of a line. */
d220 1
a220 1
size_t md_longopts_size = sizeof(md_longopts);
a1179 1

a1241 1

d1312 1
a1312 1
  while (!is_end_of_line[*input_line_pointer])
d1431 13
a1443 1
/* When we align the .init section, insert the correct NOP pattern.  */
d1445 10
a1454 13
int
m88k_do_align (n, fill, max, len)
     int n;
     const char *fill;
     int len;
     int max;
{
  if (fill == NULL
      && strcmp (obj_segment_name (now_seg), ".init") == 0)
    {
      static const unsigned char nop_pattern[] = { 0xf4, 0x00, 0x58, 0x00 };
      frag_align_pattern (n, nop_pattern, sizeof (nop_pattern), max);
      return 1;
d1456 3
a1458 1
  return 0;
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d4 1
a4 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 1996
d11 1
a11 1
the Free Software Foundation; either version 1, or (at your option)
d20 3
a22 2
along with GAS; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d206 1
a206 1
	as_fatal ("Can't hash instruction '%s':%s",
d258 1
a258 1
      as_bad ("Invalid mnemonic '%s'", op);
d278 1
a278 1
	  as_fatal ("Parameter syntax error");
d333 1
a333 1
      as_fatal ("Unknown relocation type");
d446 1
a446 1
	  as_warn ("Use of obsolete instruction");
d563 1
a563 1
	    as_warn ("Expression truncated to 16 bits");
d629 1
a629 1
	  as_warn ("Expression truncated to 5 bits");
d651 1
a651 1
	  as_warn ("Expression truncated to 5 bits");
d873 1
a873 1
    as_warn ("Expression truncated to 9 bits");
d895 1
a895 1
    as_warn ("Removed lower 2 bits of expression");
d1034 1
a1034 1
      as_fatal ("Bad relocation type");
d1047 1
a1047 1
  as_fatal ("md_number_to_disp not defined");
d1057 1
a1057 1
  as_fatal ("md_number_to_field not defined");
a1076 1
  char *atof_ieee ();
d1106 1
a1106 1
      return "Bad call to MD_ATOF()";
d1170 1
a1170 1
  as_fatal ("Relaxation should never occur");
d1217 1
a1217 1
	  if (symbolP && symbolP->sy_frag)
d1219 1
a1219 1
	      ri.r_addend = symbolP->sy_frag->fr_address;
d1260 1
a1260 1
      as_warn ("Expected comma after name");
d1267 1
a1267 1
      as_warn ("BSS length (%d.) <0! Ignored.", temp);
d1294 1
a1294 1
	    frag_align (bss_align, 0);
d1297 2
a1298 2
	  if (symbolP->sy_type == N_BSS && symbolP->sy_frag != NULL)
	    symbolP->sy_frag->fr_symbol = NULL;
d1300 1
a1300 1
	  symbolP->sy_frag  = frag_now;
d1302 1
a1302 1
			temp, (char *)0);
d1311 1
a1311 1
      as_warn ("Ignoring attempt to re-define symbol %s.", name);
d1436 1
a1436 1
m88k_do_align (n, fill, len)
d1440 1
d1442 1
a1442 1
  if ((fill == NULL || (*fill == 0 && len == 1))
d1446 1
a1446 1
      frag_align_pattern (n, nop_pattern, sizeof (nop_pattern));
@


1.1
log
@Initial revision
@
text
@d4 2
a5 1
   Copyright (C) 1989, 1990, 1991, 1993 Free Software Foundation, Inc.
d1436 1
a1436 1
m88k_do_align (n, fill)
d1439 1
d1441 1
a1441 1
  if (!fill
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d4 1
a4 2
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 1996
   Free Software Foundation, Inc.
d1435 1
a1435 1
m88k_do_align (n, fill, len)
a1437 1
     int len;
d1439 1
a1439 1
  if ((fill == NULL || (*fill == 0 && len == 1))
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d4 1
a4 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 1997
d20 2
a21 3
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d1076 1
d1294 1
a1294 1
	    frag_align (bss_align, 0, 0);
d1302 1
a1302 1
			(offsetT) temp, (char *)0);
d1436 1
a1436 1
m88k_do_align (n, fill, max, len)
a1439 1
     int max;
d1441 1
a1441 1
  if (fill == NULL
d1445 1
a1445 1
      frag_align_pattern (n, nop_pattern, sizeof (nop_pattern), max);
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d4 1
a4 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d11 1
a11 1
the Free Software Foundation; either version 2, or (at your option)
d206 1
a206 1
	as_fatal (_("Can't hash instruction '%s':%s"),
d258 1
a258 1
      as_bad (_("Invalid mnemonic '%s'"), op);
d278 1
a278 1
	  as_fatal (_("Parameter syntax error"));
d333 1
a333 1
      as_fatal (_("Unknown relocation type"));
d446 1
a446 1
	  as_warn (_("Use of obsolete instruction"));
d563 1
a563 1
	    as_warn (_("Expression truncated to 16 bits"));
d629 1
a629 1
	  as_warn (_("Expression truncated to 5 bits"));
d651 1
a651 1
	  as_warn (_("Expression truncated to 5 bits"));
d873 1
a873 1
    as_warn (_("Expression truncated to 9 bits"));
d895 1
a895 1
    as_warn (_("Removed lower 2 bits of expression"));
d1034 1
a1034 1
      as_fatal (_("Bad relocation type"));
d1047 1
a1047 1
  as_fatal (_("md_number_to_disp not defined"));
d1057 1
a1057 1
  as_fatal (_("md_number_to_field not defined"));
d1106 1
a1106 1
      return _("Bad call to MD_ATOF()");
d1170 1
a1170 1
  as_fatal (_("Relaxation should never occur"));
d1217 1
a1217 1
	  if (symbolP && symbol_get_frag (symbolP))
d1219 1
a1219 1
	      ri.r_addend = symbol_get_frag (symbolP)->fr_address;
d1260 1
a1260 1
      as_warn (_("Expected comma after name"));
d1267 1
a1267 1
      as_warn (_("BSS length (%d.) <0! Ignored."), temp);
d1297 2
a1298 2
	  if (symbolP->sy_type == N_BSS && symbol_get_frag (symbolP) != NULL)
	    symbol_get_frag (symbolP)->fr_symbol = NULL;
d1300 1
a1300 1
	  symbol_set_frag (symbolP, frag_now);
d1311 1
a1311 1
      as_warn (_("Ignoring attempt to re-define symbol %s."), name);
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d4 1
a4 2
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
   2000
d141 1
d152 1
a152 1
/* These chars only start a comment at the beginning of a line.  */
d220 1
a220 1
size_t md_longopts_size = sizeof (md_longopts);
d1180 1
d1243 1
d1314 1
a1314 1
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
d1433 1
a1433 1
/* Fill in rs_align_code fragments.  */
d1435 13
a1447 22
void
m88k_handle_align (fragp)
     fragS *fragp;
{
  static const unsigned char nop_pattern[] = { 0xf4, 0x00, 0x58, 0x00 };

  int bytes;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;

  if (bytes & 3)
    {
      int fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
      fragp->fr_fix += fix;
d1449 1
a1449 3

  memcpy (p, nop_pattern, 4);
  fragp->fr_var = 4;
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d5 1
a5 1
   2000, 2001, 2002
d25 1
a26 1
#include "safe-ctype.h"
a127 2
static char *get_bf2 PARAMS ((char *param, int bc));
static char *get_bf_offset_expression PARAMS ((char *param, unsigned *offsetp));
d132 1
a132 2
static char *match_name PARAMS ((char *, struct field_val_assoc *, unsigned *));
static char *get_reg PARAMS ((char *param, unsigned *regnop, unsigned int reg_prefix));
d149 1
a149 1
   another comment.  */
d165 3
d174 1
d182 1
a182 1
  {NULL, NULL, 0}
d191 2
a192 1
  /* Initialize hash table.  */
d195 2
d201 2
a202 1
      /* Hash each mnemonic and record its position.  */
d209 2
a210 1
      /* Skip to next unique mnemonic or end of list.  */
d216 1
a216 1
const char *md_shortopts = "";
d224 2
a225 2
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d232 1
a232 1
     FILE *stream ATTRIBUTE_UNUSED;
d247 3
a249 2
  /* Skip over instruction to find parameters.  */
  for (param = op; *param != 0 && !ISSPACE (*param); param++)
d254 2
a255 1
  /* Try to find the instruction in the hash table.  */
d262 2
a263 1
  /* Try parsing this instruction into insn.  */
d272 2
a273 1
      /* If it doesn't parse try the next instruction.  */
d283 2
a284 1
  /* Grow the current frag and plop in the opcode.  */
d288 2
a289 1
  /* If this instruction requires labels mark it for later.  */
d348 1
a348 1
  unsigned int reg_prefix = 'r';
d480 1
a480 1
     unsigned int reg_prefix;
d532 1
a532 1
  if (!strncmp (param, "hi16", 4) && !ISALNUM (param[4]))
d537 1
a537 1
  else if (!strncmp (param, "lo16", 4) && !ISALNUM (param[4]))
d542 1
a542 1
  else if (!strncmp (param, "iw16", 4) && !ISALNUM (param[4]))
d645 1
a645 1
  if (ISDIGIT (*param))
d657 5
a661 2
      param[0] = TOLOWER (param[0]);
      param[1] = TOLOWER (param[1]);
d705 1
a705 1
  if (ISALPHA (param[0]))
d707 4
a710 2
      param[0] = TOLOWER (param[0]);
      param[1] = TOLOWER (param[1]);
d899 1
a899 1
  return (param);
d903 3
a905 3
  (ISDIGIT (z) ? (z) - '0' :						\
   ISLOWER (z) ? (z) - 'a' + 10 : 					\
   ISUPPER (z) ? (z) - 'A' + 10 : (unsigned) -1)
d963 98
d1126 1
a1126 2
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
d1148 1
a1148 2
     addressT from_addr ATTRIBUTE_UNUSED;
     addressT to_addr ATTRIBUTE_UNUSED;
d1167 2
a1168 2
     fragS *fragP ATTRIBUTE_UNUSED;
     segT segment_type ATTRIBUTE_UNUSED;
d1174 146
d1359 3
a1361 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
a1362 1
  long val = * (long *) valP;
d1365 2
a1366 2
  buf = fixP->fx_frag->fr_literal + fixP->fx_where;
  fixP->fx_offset = 0;
d1368 1
a1368 1
  switch (fixP->fx_r_type)
d1371 1
a1371 1
      fixP->fx_offset = val >> 16;
d1377 1
a1377 1
      fixP->fx_offset = val >> 16;
d1383 1
a1383 1
      fixP->fx_offset = val >> 16;
a1409 3

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d1065 1
a1065 1
   point.  If that happens, these functions should be reexamined.
@


