head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.12.0.10
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.20
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.22
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.18
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.16
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.14
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.12
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.11.09.00.07.32;	author mlarkin;	state Exp;
branches;
next	1.16;
commitid	rosmMGDa8iHf9X7M;

1.16
date	2014.08.09.04.59.02;	author guenther;	state Exp;
branches;
next	1.15;
commitid	cR32nGzK9qwLMLvY;

1.15
date	2014.02.09.22.42.27;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2013.01.20.00.00.08;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.18.00.54.12;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.11.10.50.48;	author thib;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.02.20.45.27;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.17.21.54.30;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.01.21.41.51;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.01.17.57.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.17.03.44.27;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.36;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.50;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.42;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.05.46;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.06;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.06;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.36;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.44.47;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.24;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.23.03;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.25;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.35.01;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.30;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.52;	author miod;	state Exp;
branches;
next	;


desc
@@


1.17
log
@
Start moving some vmm things into the tree. First up is binutils so we will
be able to use the virtualization instructions.

ok'ed a long time ago, I forgot who, but deraadt@@ ok'ed it again anyway.
@
text
@/* i386.c -- Assemble code for the Intel 80386
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Intel 80386 machine specific gas.
   Written by Eliot Dresselhaus (eliot@@mgm.mit.edu).
   x86_64 support by Jan Hubicka (jh@@suse.cz)
   VIA PadLock support by Michal Ludvig (mludvig@@suse.cz)
   Bugs & suggestions are completely welcome.  This is free software.
   Please help us make it better.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"
#include "opcode/i386.h"

#ifndef REGISTER_WARNINGS
#define REGISTER_WARNINGS 1
#endif

#ifndef INFER_ADDR_PREFIX
#define INFER_ADDR_PREFIX 1
#endif

#ifndef SCALE1_WHEN_NO_INDEX
/* Specifying a scale factor besides 1 when there is no index is
   futile.  eg. `mov (%ebx,2),%al' does exactly the same as
   `mov (%ebx),%al'.  To slavishly follow what the programmer
   specified, set SCALE1_WHEN_NO_INDEX to 0.  */
#define SCALE1_WHEN_NO_INDEX 1
#endif

#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "i386"
#endif

#ifndef INLINE
#if __GNUC__ >= 2
#define INLINE __inline__
#else
#define INLINE
#endif
#endif

static INLINE unsigned int mode_from_disp_size PARAMS ((unsigned int));
static INLINE int fits_in_signed_byte PARAMS ((offsetT));
static INLINE int fits_in_unsigned_byte PARAMS ((offsetT));
static INLINE int fits_in_unsigned_word PARAMS ((offsetT));
static INLINE int fits_in_signed_word PARAMS ((offsetT));
static INLINE int fits_in_unsigned_long PARAMS ((offsetT));
static INLINE int fits_in_signed_long PARAMS ((offsetT));
static int smallest_imm_type PARAMS ((offsetT));
static offsetT offset_in_range PARAMS ((offsetT, int));
static int add_prefix PARAMS ((unsigned int));
static void set_code_flag PARAMS ((int));
static void set_16bit_gcc_code_flag PARAMS ((int));
static void set_intel_syntax PARAMS ((int));
static void set_cpu_arch PARAMS ((int));
static char *output_invalid PARAMS ((int c));
static int i386_operand PARAMS ((char *operand_string));
static int i386_intel_operand PARAMS ((char *operand_string, int got_a_float));
static const reg_entry *parse_register PARAMS ((char *reg_string,
						char **end_op));
static char *parse_insn PARAMS ((char *, char *));
static char *parse_operands PARAMS ((char *, const char *));
static void swap_operands PARAMS ((void));
static void optimize_imm PARAMS ((void));
static void optimize_disp PARAMS ((void));
static int match_template PARAMS ((void));
static int check_string PARAMS ((void));
static int process_suffix PARAMS ((void));
static int check_byte_reg PARAMS ((void));
static int check_long_reg PARAMS ((void));
static int check_qword_reg PARAMS ((void));
static int check_word_reg PARAMS ((void));
static int finalize_imm PARAMS ((void));
static int process_operands PARAMS ((void));
static const seg_entry *build_modrm_byte PARAMS ((void));
static void output_insn PARAMS ((void));
static void output_branch PARAMS ((void));
static void output_jump PARAMS ((void));
static void output_interseg_jump PARAMS ((void));
static void output_imm PARAMS ((fragS *insn_start_frag,
				offsetT insn_start_off));
static void output_disp PARAMS ((fragS *insn_start_frag,
				 offsetT insn_start_off));
#ifndef I386COFF
static void s_bss PARAMS ((int));
#endif

static const char *default_arch = DEFAULT_ARCH;

/* 'md_assemble ()' gathers together information and puts it into a
   i386_insn.  */

union i386_op
  {
    expressionS *disps;
    expressionS *imms;
    const reg_entry *regs;
  };

struct _i386_insn
  {
    /* TM holds the template for the insn were currently assembling.  */
    template tm;

    /* SUFFIX holds the instruction mnemonic suffix if given.
       (e.g. 'l' for 'movl')  */
    char suffix;

    /* OPERANDS gives the number of given operands.  */
    unsigned int operands;

    /* REG_OPERANDS, DISP_OPERANDS, MEM_OPERANDS, IMM_OPERANDS give the number
       of given register, displacement, memory operands and immediate
       operands.  */
    unsigned int reg_operands, disp_operands, mem_operands, imm_operands;

    /* TYPES [i] is the type (see above #defines) which tells us how to
       use OP[i] for the corresponding operand.  */
    unsigned int types[MAX_OPERANDS];

    /* Displacement expression, immediate expression, or register for each
       operand.  */
    union i386_op op[MAX_OPERANDS];

    /* Flags for operands.  */
    unsigned int flags[MAX_OPERANDS];
#define Operand_PCrel 1

    /* Relocation type for operand */
    enum bfd_reloc_code_real reloc[MAX_OPERANDS];

    /* BASE_REG, INDEX_REG, and LOG2_SCALE_FACTOR are used to encode
       the base index byte below.  */
    const reg_entry *base_reg;
    const reg_entry *index_reg;
    unsigned int log2_scale_factor;

    /* SEG gives the seg_entries of this insn.  They are zero unless
       explicit segment overrides are given.  */
    const seg_entry *seg[2];

    /* PREFIX holds all the given prefix opcodes (usually null).
       PREFIXES is the number of prefix opcodes.  */
    unsigned int prefixes;
    unsigned char prefix[MAX_PREFIXES];

    /* RM and SIB are the modrm byte and the sib byte where the
       addressing modes of this insn are encoded.  */

    modrm_byte rm;
    rex_byte rex;
    sib_byte sib;
  };

typedef struct _i386_insn i386_insn;

/* List of chars besides those in app.c:symbol_chars that can start an
   operand.  Used to prevent the scrubber eating vital white-space.  */
#ifdef LEX_AT
const char extra_symbol_chars[] = "*%-(@@[";
#else
const char extra_symbol_chars[] = "*%-([";
#endif

#if (defined (TE_I386AIX)				\
     || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))	\
	 && !defined (TE_LINUX)				\
	 && !defined (TE_FreeBSD)			\
	 && !defined (TE_NetBSD)			\
	 && !defined (TE_OpenBSD)))
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "#/";
#define PREFIX_SEPARATOR '\\'

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.
   Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.
   Also note that comments started like this one will always work if
   '/' isn't otherwise defined.  */
const char line_comment_chars[] = "#";

#else
/* Putting '/' here makes it impossible to use the divide operator.
   However, we need it for compatibility with SVR4 systems.  */
const char comment_chars[] = "#";
#define PREFIX_SEPARATOR '/'

const char line_comment_chars[] = "/#";
#endif

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point
   nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "fFdDxX";

/* Tables for lexical analysis.  */
static char mnemonic_chars[256];
static char register_chars[256];
static char operand_chars[256];
static char identifier_chars[256];
static char digit_chars[256];

/* Lexical macros.  */
#define is_mnemonic_char(x) (mnemonic_chars[(unsigned char) x])
#define is_operand_char(x) (operand_chars[(unsigned char) x])
#define is_register_char(x) (register_chars[(unsigned char) x])
#define is_space_char(x) ((x) == ' ')
#define is_identifier_char(x) (identifier_chars[(unsigned char) x])
#define is_digit_char(x) (digit_chars[(unsigned char) x])

/* All non-digit non-letter characters that may occur in an operand.  */
static char operand_special_chars[] = "%$-+(,)*._~/<>|&^!:[@@]";

/* md_assemble() always leaves the strings it's passed unaltered.  To
   effect this we maintain a stack of saved characters that we've smashed
   with '\0's (indicating end of strings for various sub-fields of the
   assembler instruction).  */
static char save_stack[32];
static char *save_stack_p;
#define END_STRING_AND_SAVE(s) \
	do { *save_stack_p++ = *(s); *(s) = '\0'; } while (0)
#define RESTORE_END_STRING(s) \
	do { *(s) = *--save_stack_p; } while (0)

/* The instruction we're assembling.  */
static i386_insn i;

/* Possible templates for current insn.  */
static const templates *current_templates;

/* Per instruction expressionS buffers: 2 displacements & 2 immediate max.  */
static expressionS disp_expressions[2], im_expressions[2];

/* Current operand we are working on.  */
static int this_operand;

/* We support four different modes.  FLAG_CODE variable is used to distinguish
   these.  */

enum flag_code {
	CODE_32BIT,
	CODE_16BIT,
	CODE_64BIT };
#define NUM_FLAG_CODE ((int) CODE_64BIT + 1)

static enum flag_code flag_code;
static int use_rela_relocations = 0;

/* The names used to print error messages.  */
static const char *flag_code_names[] =
  {
    "32",
    "16",
    "64"
  };

/* 1 for intel syntax,
   0 if att syntax.  */
static int intel_syntax = 0;

/* 1 if register prefix % not required.  */
static int allow_naked_reg = 0;

/* Used in 16 bit gcc mode to add an l suffix to call, ret, enter,
   leave, push, and pop instructions so that gcc has the same stack
   frame as in 32 bit mode.  */
static char stackop_size = '\0';

/* Non-zero to optimize code alignment.  */
int optimize_align_code = 1;

/* Non-zero to quieten some warnings.  */
static int quiet_warnings = 0;

/* CPU name.  */
static const char *cpu_arch_name = NULL;

/* CPU feature flags.  */
static unsigned int cpu_arch_flags = CpuUnknownFlags | CpuNo64;

/* If set, conditional jumps are not automatically promoted to handle
   larger than a byte offset.  */
static unsigned int no_cond_jump_promotion = 0;

/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
symbolS *GOT_symbol;

/* The dwarf2 return column, adjusted for 32 or 64 bit.  */
unsigned int x86_dwarf2_return_column;

/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
int x86_cie_data_alignment;

/* Interface to relax_segment.
   There are 3 major relax states for 386 jump insns because the
   different types of jumps add different sizes to frags when we're
   figuring out what sort of jump to choose to reach a given label.  */

/* Types.  */
#define UNCOND_JUMP 0
#define COND_JUMP 1
#define COND_JUMP86 2

/* Sizes.  */
#define CODE16	1
#define SMALL	0
#define SMALL16 (SMALL | CODE16)
#define BIG	2
#define BIG16	(BIG | CODE16)

#ifndef INLINE
#ifdef __GNUC__
#define INLINE __inline__
#else
#define INLINE
#endif
#endif

#define ENCODE_RELAX_STATE(type, size) \
  ((relax_substateT) (((type) << 2) | (size)))
#define TYPE_FROM_RELAX_STATE(s) \
  ((s) >> 2)
#define DISP_SIZE_FROM_RELAX_STATE(s) \
    ((((s) & 3) == BIG ? 4 : (((s) & 3) == BIG16 ? 2 : 1)))

/* This table is used by relax_frag to promote short jumps to long
   ones where necessary.  SMALL (short) jumps may be promoted to BIG
   (32 bit long) ones, and SMALL16 jumps to BIG16 (16 bit long).  We
   don't allow a short jump in a 32 bit code segment to be promoted to
   a 16 bit offset jump because it's slower (requires data size
   prefix), and doesn't work, unless the destination is in the bottom
   64k of the code segment (The top 16 bits of eip are zeroed).  */

const relax_typeS md_relax_table[] =
{
  /* The fields are:
     1) most positive reach of this state,
     2) most negative reach of this state,
     3) how many bytes this mode will have in the variable part of the frag
     4) which index into the table to try if we can't fit into this one.  */

  /* UNCOND_JUMP states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16)},
  /* dword jmp adds 4 bytes to frag:
     0 extra opcode bytes, 4 displacement bytes.  */
  {0, 0, 4, 0},
  /* word jmp adds 2 byte2 to frag:
     0 extra opcode bytes, 2 displacement bytes.  */
  {0, 0, 2, 0},

  /* COND_JUMP states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG16)},
  /* dword conditionals adds 5 bytes to frag:
     1 extra opcode byte, 4 displacement bytes.  */
  {0, 0, 5, 0},
  /* word conditionals add 3 bytes to frag:
     1 extra opcode byte, 2 displacement bytes.  */
  {0, 0, 3, 0},

  /* COND_JUMP86 states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG16)},
  /* dword conditionals adds 5 bytes to frag:
     1 extra opcode byte, 4 displacement bytes.  */
  {0, 0, 5, 0},
  /* word conditionals add 4 bytes to frag:
     1 displacement byte and a 3 byte long branch insn.  */
  {0, 0, 4, 0}
};

static const arch_entry cpu_arch[] = {
  {"i8086",	Cpu086 },
  {"i186",	Cpu086|Cpu186 },
  {"i286",	Cpu086|Cpu186|Cpu286 },
  {"i386",	Cpu086|Cpu186|Cpu286|Cpu386 },
  {"i486",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486 },
  {"i586",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuMMX },
  {"i686",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuSSE },
  {"pentium",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuMMX },
  {"pentiumpro",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuSSE },
  {"pentium4",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX|CpuSSE|CpuSSE2 },
  {"k6",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX|Cpu3dnow },
  {"athlon",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuMMX|Cpu3dnow },
  {"sledgehammer",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuSledgehammer|CpuMMX|Cpu3dnow|CpuSSE|CpuSSE2 },
  {NULL, 0 }
};

const pseudo_typeS md_pseudo_table[] =
{
#if !defined(OBJ_AOUT) && !defined(USE_ALIGN_PTWO)
  {"align", s_align_bytes, 0},
#else
  {"align", s_align_ptwo, 0},
#endif
  {"arch", set_cpu_arch, 0},
#ifndef I386COFF
  {"bss", s_bss, 0},
#endif
  {"ffloat", float_cons, 'f'},
  {"dfloat", float_cons, 'd'},
  {"tfloat", float_cons, 'x'},
  {"value", cons, 2},
  {"noopt", s_ignore, 0},
  {"optim", s_ignore, 0},
  {"code16gcc", set_16bit_gcc_code_flag, CODE_16BIT},
  {"code16", set_code_flag, CODE_16BIT},
  {"code32", set_code_flag, CODE_32BIT},
  {"code64", set_code_flag, CODE_64BIT},
  {"intel_syntax", set_intel_syntax, 1},
  {"att_syntax", set_intel_syntax, 0},
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
  {0, 0, 0}
};

/* For interface with expression ().  */
extern char *input_line_pointer;

/* Hash table for instruction mnemonic lookup.  */
static struct hash_control *op_hash;

/* Hash table for register lookup.  */
static struct hash_control *reg_hash;

void
i386_align_code (fragP, count)
     fragS *fragP;
     int count;
{
  /* Various efficient no-op patterns for aligning code labels.
     Note: Don't try to assemble the instructions in the comments.
     0L and 0w are not legal.  */
  static const char f32_1[] =
    {0x90};					/* nop			*/
  static const char f32_2[] =
    {0x89,0xf6};				/* movl %esi,%esi	*/
  static const char f32_3[] =
    {0x8d,0x76,0x00};				/* leal 0(%esi),%esi	*/
  static const char f32_4[] =
    {0x8d,0x74,0x26,0x00};			/* leal 0(%esi,1),%esi	*/
  static const char f32_5[] =
    {0x90,					/* nop			*/
     0x8d,0x74,0x26,0x00};			/* leal 0(%esi,1),%esi	*/
  static const char f32_6[] =
    {0x8d,0xb6,0x00,0x00,0x00,0x00};		/* leal 0L(%esi),%esi	*/
  static const char f32_7[] =
    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};	/* leal 0L(%esi,1),%esi */
  static const char f32_8[] =
    {0x90,					/* nop			*/
     0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};	/* leal 0L(%esi,1),%esi */
  static const char f32_9[] =
    {0x89,0xf6,					/* movl %esi,%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_10[] =
    {0x8d,0x76,0x00,				/* leal 0(%esi),%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_11[] =
    {0x8d,0x74,0x26,0x00,			/* leal 0(%esi,1),%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_12[] =
    {0x8d,0xb6,0x00,0x00,0x00,0x00,		/* leal 0L(%esi),%esi	*/
     0x8d,0xbf,0x00,0x00,0x00,0x00};		/* leal 0L(%edi),%edi	*/
  static const char f32_13[] =
    {0x8d,0xb6,0x00,0x00,0x00,0x00,		/* leal 0L(%esi),%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_14[] =
    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00,	/* leal 0L(%esi,1),%esi */
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_15[] =
    {0xeb,0x0d,0x90,0x90,0x90,0x90,0x90,	/* jmp .+15; lotsa nops	*/
     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};
  static const char f16_3[] =
    {0x8d,0x74,0x00};				/* lea 0(%esi),%esi	*/
  static const char f16_4[] =
    {0x8d,0xb4,0x00,0x00};			/* lea 0w(%si),%si	*/
  static const char f16_5[] =
    {0x90,					/* nop			*/
     0x8d,0xb4,0x00,0x00};			/* lea 0w(%si),%si	*/
  static const char f16_6[] =
    {0x89,0xf6,					/* mov %si,%si		*/
     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
  static const char f16_7[] =
    {0x8d,0x74,0x00,				/* lea 0(%si),%si	*/
     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
  static const char f16_8[] =
    {0x8d,0xb4,0x00,0x00,			/* lea 0w(%si),%si	*/
     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
  static const char *const f32_patt[] = {
    f32_1, f32_2, f32_3, f32_4, f32_5, f32_6, f32_7, f32_8,
    f32_9, f32_10, f32_11, f32_12, f32_13, f32_14, f32_15
  };
  static const char *const f16_patt[] = {
    f32_1, f32_2, f16_3, f16_4, f16_5, f16_6, f16_7, f16_8,
    f32_15, f32_15, f32_15, f32_15, f32_15, f32_15, f32_15
  };

  if (count <= 0 || count > 15)
    return;

  /* The recommended way to pad 64bit code is to use NOPs preceded by
     maximally four 0x66 prefixes.  Balance the size of nops.  */
  if (flag_code == CODE_64BIT)
    {
      int i;
      int nnops = (count + 3) / 4;
      int len = count / nnops;
      int remains = count - nnops * len;
      int pos = 0;

      for (i = 0; i < remains; i++)
	{
	  memset (fragP->fr_literal + fragP->fr_fix + pos, 0x66, len);
	  fragP->fr_literal[fragP->fr_fix + pos + len] = 0x90;
	  pos += len + 1;
	}
      for (; i < nnops; i++)
	{
	  memset (fragP->fr_literal + fragP->fr_fix + pos, 0x66, len - 1);
	  fragP->fr_literal[fragP->fr_fix + pos + len - 1] = 0x90;
	  pos += len;
	}
    }
  else
    if (flag_code == CODE_16BIT)
      {
	memcpy (fragP->fr_literal + fragP->fr_fix,
		f16_patt[count - 1], count);
	if (count > 8)
	  /* Adjust jump offset.  */
	  fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
      }
    else
      memcpy (fragP->fr_literal + fragP->fr_fix,
	      f32_patt[count - 1], count);
  fragP->fr_var = count;
}

static INLINE unsigned int
mode_from_disp_size (t)
     unsigned int t;
{
  return (t & Disp8) ? 1 : (t & (Disp16 | Disp32 | Disp32S)) ? 2 : 0;
}

static INLINE int
fits_in_signed_byte (num)
     offsetT num;
{
  return (num >= -128) && (num <= 127);
}

static INLINE int
fits_in_unsigned_byte (num)
     offsetT num;
{
  return (num & 0xff) == num;
}

static INLINE int
fits_in_unsigned_word (num)
     offsetT num;
{
  return (num & 0xffff) == num;
}

static INLINE int
fits_in_signed_word (num)
     offsetT num;
{
  return (-32768 <= num) && (num <= 32767);
}
static INLINE int
fits_in_signed_long (num)
     offsetT num ATTRIBUTE_UNUSED;
{
#ifndef BFD64
  return 1;
#else
  return (!(((offsetT) -1 << 31) & num)
	  || (((offsetT) -1 << 31) & num) == ((offsetT) -1 << 31));
#endif
}				/* fits_in_signed_long() */
static INLINE int
fits_in_unsigned_long (num)
     offsetT num ATTRIBUTE_UNUSED;
{
#ifndef BFD64
  return 1;
#else
  return (num & (((offsetT) 2 << 31) - 1)) == num;
#endif
}				/* fits_in_unsigned_long() */

static int
smallest_imm_type (num)
     offsetT num;
{
  if (cpu_arch_flags != (Cpu086 | Cpu186 | Cpu286 | Cpu386 | Cpu486 | CpuNo64))
    {
      /* This code is disabled on the 486 because all the Imm1 forms
	 in the opcode table are slower on the i486.  They're the
	 versions with the implicitly specified single-position
	 displacement, which has another syntax if you really want to
	 use that form.  */
      if (num == 1)
	return Imm1 | Imm8 | Imm8S | Imm16 | Imm32 | Imm32S | Imm64;
    }
  return (fits_in_signed_byte (num)
	  ? (Imm8S | Imm8 | Imm16 | Imm32 | Imm32S | Imm64)
	  : fits_in_unsigned_byte (num)
	  ? (Imm8 | Imm16 | Imm32 | Imm32S | Imm64)
	  : (fits_in_signed_word (num) || fits_in_unsigned_word (num))
	  ? (Imm16 | Imm32 | Imm32S | Imm64)
	  : fits_in_signed_long (num)
	  ? (Imm32 | Imm32S | Imm64)
	  : fits_in_unsigned_long (num)
	  ? (Imm32 | Imm64)
	  : Imm64);
}

static offsetT
offset_in_range (val, size)
     offsetT val;
     int size;
{
  addressT mask;

  switch (size)
    {
    case 1: mask = ((addressT) 1 <<  8) - 1; break;
    case 2: mask = ((addressT) 1 << 16) - 1; break;
    case 4: mask = ((addressT) 2 << 31) - 1; break;
#ifdef BFD64
    case 8: mask = ((addressT) 2 << 63) - 1; break;
#endif
    default: abort ();
    }

  /* If BFD64, sign extend val.  */
  if (!use_rela_relocations)
    if ((val & ~(((addressT) 2 << 31) - 1)) == 0)
      val = (val ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);

  if ((val & ~mask) != 0 && (val & ~mask) != ~mask)
    {
      char buf1[40], buf2[40];

      sprint_value (buf1, val);
      sprint_value (buf2, val & mask);
      as_warn (_("%s shortened to %s"), buf1, buf2);
    }
  return val & mask;
}

/* Returns 0 if attempting to add a prefix where one from the same
   class already exists, 1 if non rep/repne added, 2 if rep/repne
   added.  */
static int
add_prefix (prefix)
     unsigned int prefix;
{
  int ret = 1;
  int q;

  if (prefix >= REX_OPCODE && prefix < REX_OPCODE + 16
      && flag_code == CODE_64BIT)
    q = REX_PREFIX;
  else
    switch (prefix)
      {
      default:
	abort ();

      case CS_PREFIX_OPCODE:
      case DS_PREFIX_OPCODE:
      case ES_PREFIX_OPCODE:
      case FS_PREFIX_OPCODE:
      case GS_PREFIX_OPCODE:
      case SS_PREFIX_OPCODE:
	q = SEG_PREFIX;
	break;

      case REPNE_PREFIX_OPCODE:
      case REPE_PREFIX_OPCODE:
	ret = 2;
	/* fall thru */
      case LOCK_PREFIX_OPCODE:
	q = LOCKREP_PREFIX;
	break;

      case FWAIT_OPCODE:
	q = WAIT_PREFIX;
	break;

      case ADDR_PREFIX_OPCODE:
	q = ADDR_PREFIX;
	break;

      case DATA_PREFIX_OPCODE:
	q = DATA_PREFIX;
	break;
      }

  if (i.prefix[q] != 0)
    {
      as_bad (_("same type of prefix used twice"));
      return 0;
    }

  i.prefixes += 1;
  i.prefix[q] = prefix;
  return ret;
}

static void
set_code_flag (value)
     int value;
{
  flag_code = value;
  cpu_arch_flags &= ~(Cpu64 | CpuNo64);
  cpu_arch_flags |= (flag_code == CODE_64BIT ? Cpu64 : CpuNo64);
  if (value == CODE_64BIT && !(cpu_arch_flags & CpuSledgehammer))
    {
      as_bad (_("64bit mode not supported on this CPU."));
    }
  if (value == CODE_32BIT && !(cpu_arch_flags & Cpu386))
    {
      as_bad (_("32bit mode not supported on this CPU."));
    }
  stackop_size = '\0';
}

static void
set_16bit_gcc_code_flag (new_code_flag)
     int new_code_flag;
{
  flag_code = new_code_flag;
  cpu_arch_flags &= ~(Cpu64 | CpuNo64);
  cpu_arch_flags |= (flag_code == CODE_64BIT ? Cpu64 : CpuNo64);
  stackop_size = 'l';
}

static void
set_intel_syntax (syntax_flag)
     int syntax_flag;
{
  /* Find out if register prefixing is specified.  */
  int ask_naked_reg = 0;

  SKIP_WHITESPACE ();
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *string = input_line_pointer;
      int e = get_symbol_end ();

      if (strcmp (string, "prefix") == 0)
	ask_naked_reg = 1;
      else if (strcmp (string, "noprefix") == 0)
	ask_naked_reg = -1;
      else
	as_bad (_("bad argument to syntax directive."));
      *input_line_pointer = e;
    }
  demand_empty_rest_of_line ();

  intel_syntax = syntax_flag;

  if (ask_naked_reg == 0)
    allow_naked_reg = (intel_syntax
		       && (bfd_get_symbol_leading_char (stdoutput) != '\0'));
  else
    allow_naked_reg = (ask_naked_reg < 0);
}

static void
set_cpu_arch (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  SKIP_WHITESPACE ();

  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *string = input_line_pointer;
      int e = get_symbol_end ();
      int i;

      for (i = 0; cpu_arch[i].name; i++)
	{
	  if (strcmp (string, cpu_arch[i].name) == 0)
	    {
	      cpu_arch_name = cpu_arch[i].name;
	      cpu_arch_flags = (cpu_arch[i].flags
				| (flag_code == CODE_64BIT ? Cpu64 : CpuNo64));
	      break;
	    }
	}
      if (!cpu_arch[i].name)
	as_bad (_("no such architecture: `%s'"), string);

      *input_line_pointer = e;
    }
  else
    as_bad (_("missing cpu architecture"));

  no_cond_jump_promotion = 0;
  if (*input_line_pointer == ','
      && !is_end_of_line[(unsigned char) input_line_pointer[1]])
    {
      char *string = ++input_line_pointer;
      int e = get_symbol_end ();

      if (strcmp (string, "nojumps") == 0)
	no_cond_jump_promotion = 1;
      else if (strcmp (string, "jumps") == 0)
	;
      else
	as_bad (_("no such architecture modifier: `%s'"), string);

      *input_line_pointer = e;
    }

  demand_empty_rest_of_line ();
}

unsigned long
i386_mach ()
{
  if (!strcmp (default_arch, "x86_64"))
    return bfd_mach_x86_64;
  else if (!strcmp (default_arch, "i386"))
    return bfd_mach_i386_i386;
  else
    as_fatal (_("Unknown architecture"));
}

void
md_begin ()
{
  const char *hash_err;

  /* Initialize op_hash hash table.  */
  op_hash = hash_new ();

  {
    const template *optab;
    templates *core_optab;

    /* Setup for loop.  */
    optab = i386_optab;
    core_optab = (templates *) xmalloc (sizeof (templates));
    core_optab->start = optab;

    while (1)
      {
	++optab;
	if (optab->name == NULL
	    || strcmp (optab->name, (optab - 1)->name) != 0)
	  {
	    /* different name --> ship out current template list;
	       add to hash table; & begin anew.  */
	    core_optab->end = optab;
	    hash_err = hash_insert (op_hash,
				    (optab - 1)->name,
				    (PTR) core_optab);
	    if (hash_err)
	      {
		as_fatal (_("Internal Error:  Can't hash %s: %s"),
			  (optab - 1)->name,
			  hash_err);
	      }
	    if (optab->name == NULL)
	      break;
	    core_optab = (templates *) xmalloc (sizeof (templates));
	    core_optab->start = optab;
	  }
      }
  }

  /* Initialize reg_hash hash table.  */
  reg_hash = hash_new ();
  {
    const reg_entry *regtab;

    for (regtab = i386_regtab;
	 regtab < i386_regtab + sizeof (i386_regtab) / sizeof (i386_regtab[0]);
	 regtab++)
      {
	hash_err = hash_insert (reg_hash, regtab->reg_name, (PTR) regtab);
	if (hash_err)
	  as_fatal (_("Internal Error:  Can't hash %s: %s"),
		    regtab->reg_name,
		    hash_err);
      }
  }

  /* Fill in lexical tables:  mnemonic_chars, operand_chars.  */
  {
    int c;
    char *p;

    for (c = 0; c < 256; c++)
      {
	if (ISDIGIT (c))
	  {
	    digit_chars[c] = c;
	    mnemonic_chars[c] = c;
	    register_chars[c] = c;
	    operand_chars[c] = c;
	  }
	else if (ISLOWER (c))
	  {
	    mnemonic_chars[c] = c;
	    register_chars[c] = c;
	    operand_chars[c] = c;
	  }
	else if (ISUPPER (c))
	  {
	    mnemonic_chars[c] = TOLOWER (c);
	    register_chars[c] = mnemonic_chars[c];
	    operand_chars[c] = c;
	  }

	if (ISALPHA (c) || ISDIGIT (c))
	  identifier_chars[c] = c;
	else if (c >= 128)
	  {
	    identifier_chars[c] = c;
	    operand_chars[c] = c;
	  }
      }

#ifdef LEX_AT
    identifier_chars['@@'] = '@@';
#endif
    digit_chars['-'] = '-';
    mnemonic_chars['-'] = '-';
    identifier_chars['_'] = '_';
    identifier_chars['.'] = '.';

    for (p = operand_special_chars; *p != '\0'; p++)
      operand_chars[(unsigned char) *p] = *p;
  }

#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
    {
      record_alignment (text_section, 2);
      record_alignment (data_section, 2);
      record_alignment (bss_section, 2);
    }
#endif

  if (flag_code == CODE_64BIT)
    {
      x86_dwarf2_return_column = 16;
      x86_cie_data_alignment = -8;
    }
  else
    {
      x86_dwarf2_return_column = 8;
      x86_cie_data_alignment = -4;
    }
}

void
i386_print_statistics (file)
     FILE *file;
{
  hash_print_statistics (file, "i386 opcode", op_hash);
  hash_print_statistics (file, "i386 register", reg_hash);
}

#ifdef DEBUG386

/* Debugging routines for md_assemble.  */
static void pi PARAMS ((char *, i386_insn *));
static void pte PARAMS ((template *));
static void pt PARAMS ((unsigned int));
static void pe PARAMS ((expressionS *));
static void ps PARAMS ((symbolS *));

static void
pi (line, x)
     char *line;
     i386_insn *x;
{
  unsigned int i;

  fprintf (stdout, "%s: template ", line);
  pte (&x->tm);
  fprintf (stdout, "  address: base %s  index %s  scale %x\n",
	   x->base_reg ? x->base_reg->reg_name : "none",
	   x->index_reg ? x->index_reg->reg_name : "none",
	   x->log2_scale_factor);
  fprintf (stdout, "  modrm:  mode %x  reg %x  reg/mem %x\n",
	   x->rm.mode, x->rm.reg, x->rm.regmem);
  fprintf (stdout, "  sib:  base %x  index %x  scale %x\n",
	   x->sib.base, x->sib.index, x->sib.scale);
  fprintf (stdout, "  rex: 64bit %x  extX %x  extY %x  extZ %x\n",
	   (x->rex & REX_MODE64) != 0,
	   (x->rex & REX_EXTX) != 0,
	   (x->rex & REX_EXTY) != 0,
	   (x->rex & REX_EXTZ) != 0);
  for (i = 0; i < x->operands; i++)
    {
      fprintf (stdout, "    #%d:  ", i + 1);
      pt (x->types[i]);
      fprintf (stdout, "\n");
      if (x->types[i]
	  & (Reg | SReg2 | SReg3 | Control | Debug | Test | RegMMX | RegXMM))
	fprintf (stdout, "%s\n", x->op[i].regs->reg_name);
      if (x->types[i] & Imm)
	pe (x->op[i].imms);
      if (x->types[i] & Disp)
	pe (x->op[i].disps);
    }
}

static void
pte (t)
     template *t;
{
  unsigned int i;
  fprintf (stdout, " %d operands ", t->operands);
  fprintf (stdout, "opcode %x ", t->base_opcode);
  if (t->extension_opcode != None)
    fprintf (stdout, "ext %x ", t->extension_opcode);
  if (t->opcode_modifier & D)
    fprintf (stdout, "D");
  if (t->opcode_modifier & W)
    fprintf (stdout, "W");
  fprintf (stdout, "\n");
  for (i = 0; i < t->operands; i++)
    {
      fprintf (stdout, "    #%d type ", i + 1);
      pt (t->operand_types[i]);
      fprintf (stdout, "\n");
    }
}

static void
pe (e)
     expressionS *e;
{
  fprintf (stdout, "    operation     %d\n", e->X_op);
  fprintf (stdout, "    add_number    %ld (%lx)\n",
	   (long) e->X_add_number, (long) e->X_add_number);
  if (e->X_add_symbol)
    {
      fprintf (stdout, "    add_symbol    ");
      ps (e->X_add_symbol);
      fprintf (stdout, "\n");
    }
  if (e->X_op_symbol)
    {
      fprintf (stdout, "    op_symbol    ");
      ps (e->X_op_symbol);
      fprintf (stdout, "\n");
    }
}

static void
ps (s)
     symbolS *s;
{
  fprintf (stdout, "%s type %s%s",
	   S_GET_NAME (s),
	   S_IS_EXTERNAL (s) ? "EXTERNAL " : "",
	   segment_name (S_GET_SEGMENT (s)));
}

struct type_name
  {
    unsigned int mask;
    char *tname;
  }

static const type_names[] =
{
  { Reg8, "r8" },
  { Reg16, "r16" },
  { Reg32, "r32" },
  { Reg64, "r64" },
  { Imm8, "i8" },
  { Imm8S, "i8s" },
  { Imm16, "i16" },
  { Imm32, "i32" },
  { Imm32S, "i32s" },
  { Imm64, "i64" },
  { Imm1, "i1" },
  { BaseIndex, "BaseIndex" },
  { Disp8, "d8" },
  { Disp16, "d16" },
  { Disp32, "d32" },
  { Disp32S, "d32s" },
  { Disp64, "d64" },
  { InOutPortReg, "InOutPortReg" },
  { ShiftCount, "ShiftCount" },
  { Control, "control reg" },
  { Test, "test reg" },
  { Debug, "debug reg" },
  { FloatReg, "FReg" },
  { FloatAcc, "FAcc" },
  { SReg2, "SReg2" },
  { SReg3, "SReg3" },
  { Acc, "Acc" },
  { JumpAbsolute, "Jump Absolute" },
  { RegMMX, "rMMX" },
  { RegXMM, "rXMM" },
  { EsSeg, "es" },
  { 0, "" }
};

static void
pt (t)
     unsigned int t;
{
  const struct type_name *ty;

  for (ty = type_names; ty->mask; ty++)
    if (t & ty->mask)
      fprintf (stdout, "%s, ", ty->tname);
  fflush (stdout);
}

#endif /* DEBUG386 */

static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, int, bfd_reloc_code_real_type));

static bfd_reloc_code_real_type
reloc (size, pcrel, sign, other)
     int size;
     int pcrel;
     int sign;
     bfd_reloc_code_real_type other;
{
  if (other != NO_RELOC)
    return other;

  if (pcrel)
    {
      if (!sign)
	as_bad (_("There are no unsigned pc-relative relocations"));
      switch (size)
	{
	case 1: return BFD_RELOC_8_PCREL;
	case 2: return BFD_RELOC_16_PCREL;
	case 4: return BFD_RELOC_32_PCREL;
	}
      as_bad (_("can not do %d byte pc-relative relocation"), size);
    }
  else
    {
      if (sign)
	switch (size)
	  {
	  case 4: return BFD_RELOC_X86_64_32S;
	  }
      else
	switch (size)
	  {
	  case 1: return BFD_RELOC_8;
	  case 2: return BFD_RELOC_16;
	  case 4: return BFD_RELOC_32;
	  case 8: return BFD_RELOC_64;
	  }
      as_bad (_("can not do %s %d byte relocation"),
	      sign ? "signed" : "unsigned", size);
    }

  abort ();
  return BFD_RELOC_NONE;
}

/* Here we decide which fixups can be adjusted to make them relative to
   the beginning of the section instead of the symbol.  Basically we need
   to make sure that the dynamic relocations are done correctly, so in
   some cases we force the original symbol to be used.  */

int
tc_i386_fix_adjustable (fixP)
     fixS *fixP ATTRIBUTE_UNUSED;
{
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
    return 1;

  /* Don't adjust pc-relative references to merge sections in 64-bit
     mode.  */
  if (use_rela_relocations
      && (S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0
      && fixP->fx_pcrel)
    return 0;

  /* The x86_64 GOTPCREL are represented as 32bit PCrel relocations
     and changed later by validate_fix.  */
  if (GOT_symbol && fixP->fx_subsy == GOT_symbol
      && fixP->fx_r_type == BFD_RELOC_32_PCREL)
    return 0;

  /* adjust_reloc_syms doesn't know about the GOT.  */
  if (fixP->fx_r_type == BFD_RELOC_386_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_386_PLT32
      || fixP->fx_r_type == BFD_RELOC_386_GOT32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_GD
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LDM
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LDO_32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_IE_32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_IE
      || fixP->fx_r_type == BFD_RELOC_386_TLS_GOTIE
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LE_32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LE
      || fixP->fx_r_type == BFD_RELOC_X86_64_PLT32
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOT32
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTPCREL
      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSGD
      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSLD
      || fixP->fx_r_type == BFD_RELOC_X86_64_DTPOFF32
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTTPOFF
      || fixP->fx_r_type == BFD_RELOC_X86_64_TPOFF32
      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;
#endif
  return 1;
}

static int intel_float_operand PARAMS ((const char *mnemonic));

static int
intel_float_operand (mnemonic)
     const char *mnemonic;
{
  if (mnemonic[0] == 'f' && mnemonic[1] == 'i')
    return 2;

  if (mnemonic[0] == 'f')
    return 1;

  return 0;
}

/* This is the guts of the machine-dependent assembler.  LINE points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (line)
     char *line;
{
  int j;
  char mnemonic[MAX_MNEM_SIZE];

  /* Initialize globals.  */
  memset (&i, '\0', sizeof (i));
  for (j = 0; j < MAX_OPERANDS; j++)
    i.reloc[j] = NO_RELOC;
  memset (disp_expressions, '\0', sizeof (disp_expressions));
  memset (im_expressions, '\0', sizeof (im_expressions));
  save_stack_p = save_stack;

  /* First parse an instruction mnemonic & call i386_operand for the operands.
     We assume that the scrubber has arranged it so that line[0] is the valid
     start of a (possibly prefixed) mnemonic.  */

  line = parse_insn (line, mnemonic);
  if (line == NULL)
    return;

  line = parse_operands (line, mnemonic);
  if (line == NULL)
    return;

  /* Now we've parsed the mnemonic into a set of templates, and have the
     operands at hand.  */

  /* All intel opcodes have reversed operands except for "bound" and
     "enter".  We also don't reverse intersegment "jmp" and "call"
     instructions with 2 immediate operands so that the immediate segment
     precedes the offset, as it does when in AT&T mode.  "enter" and the
     intersegment "jmp" and "call" instructions are the only ones that
     have two immediate operands.  */
  if (intel_syntax && i.operands > 1
      && (strcmp (mnemonic, "bound") != 0)
      && (strcmp (mnemonic, "invlpga") != 0)
      && !((i.types[0] & Imm) && (i.types[1] & Imm)))
    swap_operands ();

  if (i.imm_operands)
    optimize_imm ();

  if (i.disp_operands)
    optimize_disp ();

  /* Next, we find a template that matches the given insn,
     making sure the overlap of the given operands types is consistent
     with the template operand types.  */

  if (!match_template ())
    return;

  if (intel_syntax)
    {
      /* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
      if (SYSV386_COMPAT
	  && (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
	i.tm.base_opcode ^= FloatR;

      /* Zap movzx and movsx suffix.  The suffix may have been set from
	 "word ptr" or "byte ptr" on the source operand, but we'll use
	 the suffix later to choose the destination register.  */
      if ((i.tm.base_opcode & ~9) == 0x0fb6)
	i.suffix = 0;
    }

  if (i.tm.opcode_modifier & FWait)
    if (!add_prefix (FWAIT_OPCODE))
      return;

  /* Check string instruction segment overrides.  */
  if ((i.tm.opcode_modifier & IsString) != 0 && i.mem_operands != 0)
    {
      if (!check_string ())
	return;
    }

  if (!process_suffix ())
    return;

  /* Make still unresolved immediate matches conform to size of immediate
     given in i.suffix.  */
  if (!finalize_imm ())
    return;

  if (i.types[0] & Imm1)
    i.imm_operands = 0;	/* kludge for shift insns.  */
  if (i.types[0] & ImplicitRegister)
    i.reg_operands--;
  if (i.types[1] & ImplicitRegister)
    i.reg_operands--;
  if (i.types[2] & ImplicitRegister)
    i.reg_operands--;

  if (i.tm.opcode_modifier & ImmExt)
    {
      expressionS *exp;

      if ((i.tm.cpu_flags & (CpuPNI|CpuXSAVE|CpuSMAP)) && i.operands > 0)
	{
	  /* These Intel Prescott New Instructions have the fixed
	     operands with an opcode suffix which is coded in the same
	     place as an 8-bit immediate field would be. Here we check
	     those operands and remove them afterwards.  */
	  unsigned int x;

	  for (x = 0; x < i.operands; x++)
	    if (i.op[x].regs->reg_num != x)
	      as_bad (_("can't use register '%%%s' as operand %d in '%s'."),
			i.op[x].regs->reg_name, x + 1, i.tm.name);
	  i.operands = 0;
 	}

      /* These AMD 3DNow! and Intel Katmai New Instructions have an
	 opcode suffix which is coded in the same place as an 8-bit
	 immediate field would be.  Here we fake an 8-bit immediate
	 operand from the opcode suffix stored in tm.extension_opcode.  */

      assert (i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);

      exp = &im_expressions[i.imm_operands++];
      i.op[i.operands].imms = exp;
      i.types[i.operands++] = Imm8;
      exp->X_op = O_constant;
      exp->X_add_number = i.tm.extension_opcode;
      i.tm.extension_opcode = None;
    }

  /* For insns with operands there are more diddles to do to the opcode.  */
  if (i.operands)
    {
      if (!process_operands ())
	return;
    }
  else if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
    {
      /* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
      as_warn (_("translating to `%sp'"), i.tm.name);
    }

  /* Handle conversion of 'int $3' --> special int3 insn.  */
  if (i.tm.base_opcode == INT_OPCODE && i.op[0].imms->X_add_number == 3)
    {
      i.tm.base_opcode = INT3_OPCODE;
      i.imm_operands = 0;
    }

  if ((i.tm.opcode_modifier & (Jump | JumpByte | JumpDword))
      && i.op[0].disps->X_op == O_constant)
    {
      /* Convert "jmp constant" (and "call constant") to a jump (call) to
	 the absolute address given by the constant.  Since ix86 jumps and
	 calls are pc relative, we need to generate a reloc.  */
      i.op[0].disps->X_add_symbol = &abs_symbol;
      i.op[0].disps->X_op = O_symbol;
    }

  if ((i.tm.opcode_modifier & Rex64) != 0)
    i.rex |= REX_MODE64;

  /* For 8 bit registers we need an empty rex prefix.  Also if the
     instruction already has a prefix, we need to convert old
     registers to new ones.  */

  if (((i.types[0] & Reg8) != 0
       && (i.op[0].regs->reg_flags & RegRex64) != 0)
      || ((i.types[1] & Reg8) != 0
	  && (i.op[1].regs->reg_flags & RegRex64) != 0)
      || (((i.types[0] & Reg8) != 0 || (i.types[1] & Reg8) != 0)
	  && i.rex != 0))
    {
      int x;

      i.rex |= REX_OPCODE;
      for (x = 0; x < 2; x++)
	{
	  /* Look for 8 bit operand that uses old registers.  */
	  if ((i.types[x] & Reg8) != 0
	      && (i.op[x].regs->reg_flags & RegRex64) == 0)
	    {
	      /* In case it is "hi" register, give up.  */
	      if (i.op[x].regs->reg_num > 3)
		as_bad (_("can't encode register '%%%s' in an instruction requiring REX prefix.\n"),
			i.op[x].regs->reg_name);

	      /* Otherwise it is equivalent to the extended register.
		 Since the encoding doesn't change this is merely
		 cosmetic cleanup for debug output.  */

	      i.op[x].regs = i.op[x].regs + 8;
	    }
	}
    }

  if (i.rex != 0)
    add_prefix (REX_OPCODE | i.rex);

  /* We are ready to output the insn.  */
  output_insn ();
}

static char *
parse_insn (line, mnemonic)
     char *line;
     char *mnemonic;
{
  char *l = line;
  char *token_start = l;
  char *mnem_p;

  /* Non-zero if we found a prefix only acceptable with string insns.  */
  const char *expecting_string_instruction = NULL;

  while (1)
    {
      mnem_p = mnemonic;
      while ((*mnem_p = mnemonic_chars[(unsigned char) *l]) != 0)
	{
	  mnem_p++;
	  if (mnem_p >= mnemonic + MAX_MNEM_SIZE)
	    {
	      as_bad (_("no such instruction: `%s'"), token_start);
	      return NULL;
	    }
	  l++;
	}
      if (!is_space_char (*l)
	  && *l != END_OF_INSN
	  && *l != PREFIX_SEPARATOR
	  && *l != ',')
	{
	  as_bad (_("invalid character %s in mnemonic"),
		  output_invalid (*l));
	  return NULL;
	}
      if (token_start == l)
	{
	  if (*l == PREFIX_SEPARATOR)
	    as_bad (_("expecting prefix; got nothing"));
	  else
	    as_bad (_("expecting mnemonic; got nothing"));
	  return NULL;
	}

      /* Look up instruction (or prefix) via hash table.  */
      current_templates = hash_find (op_hash, mnemonic);

      if (*l != END_OF_INSN
	  && (!is_space_char (*l) || l[1] != END_OF_INSN)
	  && current_templates
	  && (current_templates->start->opcode_modifier & IsPrefix))
	{
	  /* If we are in 16-bit mode, do not allow addr16 or data16.
	     Similarly, in 32-bit mode, do not allow addr32 or data32.  */
	  if ((current_templates->start->opcode_modifier & (Size16 | Size32))
	      && flag_code != CODE_64BIT
	      && (((current_templates->start->opcode_modifier & Size32) != 0)
		  ^ (flag_code == CODE_16BIT)))
	    {
	      as_bad (_("redundant %s prefix"),
		      current_templates->start->name);
	      return NULL;
	    }
	  /* Add prefix, checking for repeated prefixes.  */
	  switch (add_prefix (current_templates->start->base_opcode))
	    {
	    case 0:
	      return NULL;
	    case 2:
	      expecting_string_instruction = current_templates->start->name;
	      break;
	    }
	  /* Skip past PREFIX_SEPARATOR and reset token_start.  */
	  token_start = ++l;
	}
      else
	break;
    }

  if (!current_templates)
    {
      /* See if we can get a match by trimming off a suffix.  */
      switch (mnem_p[-1])
	{
	case WORD_MNEM_SUFFIX:
	case BYTE_MNEM_SUFFIX:
	case QWORD_MNEM_SUFFIX:
	  i.suffix = mnem_p[-1];
	  mnem_p[-1] = '\0';
	  current_templates = hash_find (op_hash, mnemonic);
	  break;
	case SHORT_MNEM_SUFFIX:
	case LONG_MNEM_SUFFIX:
	  if (!intel_syntax)
	    {
	      i.suffix = mnem_p[-1];
	      mnem_p[-1] = '\0';
	      current_templates = hash_find (op_hash, mnemonic);
	    }
	  break;

	  /* Intel Syntax.  */
	case 'd':
	  if (intel_syntax)
	    {
	      if (intel_float_operand (mnemonic))
		i.suffix = SHORT_MNEM_SUFFIX;
	      else
		i.suffix = LONG_MNEM_SUFFIX;
	      mnem_p[-1] = '\0';
	      current_templates = hash_find (op_hash, mnemonic);
	    }
	  break;
	}
      if (!current_templates)
	{
	  as_bad (_("no such instruction: `%s'"), token_start);
	  return NULL;
	}
    }

  if (current_templates->start->opcode_modifier & (Jump | JumpByte))
    {
      /* Check for a branch hint.  We allow ",pt" and ",pn" for
	 predict taken and predict not taken respectively.
	 I'm not sure that branch hints actually do anything on loop
	 and jcxz insns (JumpByte) for current Pentium4 chips.  They
	 may work in the future and it doesn't hurt to accept them
	 now.  */
      if (l[0] == ',' && l[1] == 'p')
	{
	  if (l[2] == 't')
	    {
	      if (!add_prefix (DS_PREFIX_OPCODE))
		return NULL;
	      l += 3;
	    }
	  else if (l[2] == 'n')
	    {
	      if (!add_prefix (CS_PREFIX_OPCODE))
		return NULL;
	      l += 3;
	    }
	}
    }
  /* Any other comma loses.  */
  if (*l == ',')
    {
      as_bad (_("invalid character %s in mnemonic"),
	      output_invalid (*l));
      return NULL;
    }

  /* Check if instruction is supported on specified architecture.  */
  if ((current_templates->start->cpu_flags & ~(Cpu64 | CpuNo64))
      & ~(cpu_arch_flags & ~(Cpu64 | CpuNo64)))
    {
      as_warn (_("`%s' is not supported on `%s'"),
	       current_templates->start->name, cpu_arch_name);
    }
  else if ((Cpu386 & ~cpu_arch_flags) && (flag_code != CODE_16BIT))
    {
      as_warn (_("use .code16 to ensure correct addressing mode"));
    }

  /* Check for rep/repne without a string instruction.  */
  if (expecting_string_instruction
      && !(current_templates->start->opcode_modifier & IsString))
    {
      as_bad (_("expecting string instruction after `%s'"),
	      expecting_string_instruction);
      return NULL;
    }

  return l;
}

static char *
parse_operands (l, mnemonic)
     char *l;
     const char *mnemonic;
{
  char *token_start;

  /* 1 if operand is pending after ','.  */
  unsigned int expecting_operand = 0;

  /* Non-zero if operand parens not balanced.  */
  unsigned int paren_not_balanced;

  while (*l != END_OF_INSN)
    {
      /* Skip optional white space before operand.  */
      if (is_space_char (*l))
	++l;
      if (!is_operand_char (*l) && *l != END_OF_INSN)
	{
	  as_bad (_("invalid character %s before operand %d"),
		  output_invalid (*l),
		  i.operands + 1);
	  return NULL;
	}
      token_start = l;	/* after white space */
      paren_not_balanced = 0;
      while (paren_not_balanced || *l != ',')
	{
	  if (*l == END_OF_INSN)
	    {
	      if (paren_not_balanced)
		{
		  if (!intel_syntax)
		    as_bad (_("unbalanced parenthesis in operand %d."),
			    i.operands + 1);
		  else
		    as_bad (_("unbalanced brackets in operand %d."),
			    i.operands + 1);
		  return NULL;
		}
	      else
		break;	/* we are done */
	    }
	  else if (!is_operand_char (*l) && !is_space_char (*l))
	    {
	      as_bad (_("invalid character %s in operand %d"),
		      output_invalid (*l),
		      i.operands + 1);
	      return NULL;
	    }
	  if (!intel_syntax)
	    {
	      if (*l == '(')
		++paren_not_balanced;
	      if (*l == ')')
		--paren_not_balanced;
	    }
	  else
	    {
	      if (*l == '[')
		++paren_not_balanced;
	      if (*l == ']')
		--paren_not_balanced;
	    }
	  l++;
	}
      if (l != token_start)
	{			/* Yes, we've read in another operand.  */
	  unsigned int operand_ok;
	  this_operand = i.operands++;
	  if (i.operands > MAX_OPERANDS)
	    {
	      as_bad (_("spurious operands; (%d operands/instruction max)"),
		      MAX_OPERANDS);
	      return NULL;
	    }
	  /* Now parse operand adding info to 'i' as we go along.  */
	  END_STRING_AND_SAVE (l);

	  if (intel_syntax)
	    operand_ok =
	      i386_intel_operand (token_start,
				  intel_float_operand (mnemonic));
	  else
	    operand_ok = i386_operand (token_start);

	  RESTORE_END_STRING (l);
	  if (!operand_ok)
	    return NULL;
	}
      else
	{
	  if (expecting_operand)
	    {
	    expecting_operand_after_comma:
	      as_bad (_("expecting operand after ','; got nothing"));
	      return NULL;
	    }
	  if (*l == ',')
	    {
	      as_bad (_("expecting operand before ','; got nothing"));
	      return NULL;
	    }
	}

      /* Now *l must be either ',' or END_OF_INSN.  */
      if (*l == ',')
	{
	  if (*++l == END_OF_INSN)
	    {
	      /* Just skip it, if it's \n complain.  */
	      goto expecting_operand_after_comma;
	    }
	  expecting_operand = 1;
	}
    }
  return l;
}

static void
swap_operands ()
{
  union i386_op temp_op;
  unsigned int temp_type;
  enum bfd_reloc_code_real temp_reloc;
  int xchg1 = 0;
  int xchg2 = 0;

  if (i.operands == 2)
    {
      xchg1 = 0;
      xchg2 = 1;
    }
  else if (i.operands == 3)
    {
      xchg1 = 0;
      xchg2 = 2;
    }
  temp_type = i.types[xchg2];
  i.types[xchg2] = i.types[xchg1];
  i.types[xchg1] = temp_type;
  temp_op = i.op[xchg2];
  i.op[xchg2] = i.op[xchg1];
  i.op[xchg1] = temp_op;
  temp_reloc = i.reloc[xchg2];
  i.reloc[xchg2] = i.reloc[xchg1];
  i.reloc[xchg1] = temp_reloc;

  if (i.mem_operands == 2)
    {
      const seg_entry *temp_seg;
      temp_seg = i.seg[0];
      i.seg[0] = i.seg[1];
      i.seg[1] = temp_seg;
    }
}

/* Try to ensure constant immediates are represented in the smallest
   opcode possible.  */
static void
optimize_imm ()
{
  char guess_suffix = 0;
  int op;

  if (i.suffix)
    guess_suffix = i.suffix;
  else if (i.reg_operands)
    {
      /* Figure out a suffix from the last register operand specified.
	 We can't do this properly yet, ie. excluding InOutPortReg,
	 but the following works for instructions with immediates.
	 In any case, we can't set i.suffix yet.  */
      for (op = i.operands; --op >= 0;)
	if (i.types[op] & Reg)
	  {
	    if (i.types[op] & Reg8)
	      guess_suffix = BYTE_MNEM_SUFFIX;
	    else if (i.types[op] & Reg16)
	      guess_suffix = WORD_MNEM_SUFFIX;
	    else if (i.types[op] & Reg32)
	      guess_suffix = LONG_MNEM_SUFFIX;
	    else if (i.types[op] & Reg64)
	      guess_suffix = QWORD_MNEM_SUFFIX;
	    break;
	  }
    }
  else if ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0))
    guess_suffix = WORD_MNEM_SUFFIX;

  for (op = i.operands; --op >= 0;)
    if (i.types[op] & Imm)
      {
	switch (i.op[op].imms->X_op)
	  {
	  case O_constant:
	    /* If a suffix is given, this operand may be shortened.  */
	    switch (guess_suffix)
	      {
	      case LONG_MNEM_SUFFIX:
		i.types[op] |= Imm32 | Imm64;
		break;
	      case WORD_MNEM_SUFFIX:
		i.types[op] |= Imm16 | Imm32S | Imm32 | Imm64;
		break;
	      case BYTE_MNEM_SUFFIX:
		i.types[op] |= Imm16 | Imm8 | Imm8S | Imm32S | Imm32 | Imm64;
		break;
	      }

	    /* If this operand is at most 16 bits, convert it
	       to a signed 16 bit number before trying to see
	       whether it will fit in an even smaller size.
	       This allows a 16-bit operand such as $0xffe0 to
	       be recognised as within Imm8S range.  */
	    if ((i.types[op] & Imm16)
		&& (i.op[op].imms->X_add_number & ~(offsetT) 0xffff) == 0)
	      {
		i.op[op].imms->X_add_number =
		  (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
	      }
	    if ((i.types[op] & Imm32)
		&& ((i.op[op].imms->X_add_number & ~(((offsetT) 2 << 31) - 1))
		    == 0))
	      {
		i.op[op].imms->X_add_number = ((i.op[op].imms->X_add_number
						^ ((offsetT) 1 << 31))
					       - ((offsetT) 1 << 31));
	      }
	    i.types[op] |= smallest_imm_type (i.op[op].imms->X_add_number);

	    /* We must avoid matching of Imm32 templates when 64bit
	       only immediate is available.  */
	    if (guess_suffix == QWORD_MNEM_SUFFIX)
	      i.types[op] &= ~Imm32;
	    break;

	  case O_absent:
	  case O_register:
	    abort ();

	    /* Symbols and expressions.  */
	  default:
	    /* Convert symbolic operand to proper sizes for matching.  */
	    switch (guess_suffix)
	      {
	      case QWORD_MNEM_SUFFIX:
		i.types[op] = Imm64 | Imm32S;
		break;
	      case LONG_MNEM_SUFFIX:
		i.types[op] = Imm32;
		break;
	      case WORD_MNEM_SUFFIX:
		i.types[op] = Imm16;
		break;
	      case BYTE_MNEM_SUFFIX:
		i.types[op] = Imm8 | Imm8S;
		break;
	      }
	    break;
	  }
      }
}

/* Try to use the smallest displacement type too.  */
static void
optimize_disp ()
{
  int op;

  for (op = i.operands; --op >= 0;)
    if ((i.types[op] & Disp) && i.op[op].disps->X_op == O_constant)
      {
	offsetT disp = i.op[op].disps->X_add_number;

	if (i.types[op] & Disp16)
	  {
	    /* We know this operand is at most 16 bits, so
	       convert to a signed 16 bit number before trying
	       to see whether it will fit in an even smaller
	       size.  */

	    disp = (((disp & 0xffff) ^ 0x8000) - 0x8000);
	  }
	else if (i.types[op] & Disp32)
	  {
	    /* We know this operand is at most 32 bits, so convert to a
	       signed 32 bit number before trying to see whether it will
	       fit in an even smaller size.  */
	    disp &= (((offsetT) 2 << 31) - 1);
	    disp = (disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
	  }
	if (flag_code == CODE_64BIT)
	  {
	    if (fits_in_signed_long (disp))
	      i.types[op] |= Disp32S;
	    if (fits_in_unsigned_long (disp))
	      i.types[op] |= Disp32;
	  }
	if ((i.types[op] & (Disp32 | Disp32S | Disp16))
	    && fits_in_signed_byte (disp))
	  i.types[op] |= Disp8;
      }
}

static int
match_template ()
{
  /* Points to template once we've found it.  */
  const template *t;
  unsigned int overlap0, overlap1, overlap2;
  unsigned int found_reverse_match;
  int suffix_check;

#define MATCH(overlap, given, template)				\
  ((overlap & ~JumpAbsolute)					\
   && (((given) & (BaseIndex | JumpAbsolute))			\
       == ((overlap) & (BaseIndex | JumpAbsolute))))

  /* If given types r0 and r1 are registers they must be of the same type
     unless the expected operand type register overlap is null.
     Note that Acc in a template matches every size of reg.  */
#define CONSISTENT_REGISTER_MATCH(m0, g0, t0, m1, g1, t1)	\
  (((g0) & Reg) == 0 || ((g1) & Reg) == 0			\
   || ((g0) & Reg) == ((g1) & Reg)				\
   || ((((m0) & Acc) ? Reg : (t0)) & (((m1) & Acc) ? Reg : (t1)) & Reg) == 0 )

  overlap0 = 0;
  overlap1 = 0;
  overlap2 = 0;
  found_reverse_match = 0;
  suffix_check = (i.suffix == BYTE_MNEM_SUFFIX
		  ? No_bSuf
		  : (i.suffix == WORD_MNEM_SUFFIX
		     ? No_wSuf
		     : (i.suffix == SHORT_MNEM_SUFFIX
			? No_sSuf
			: (i.suffix == LONG_MNEM_SUFFIX
			   ? No_lSuf
			   : (i.suffix == QWORD_MNEM_SUFFIX
			      ? No_qSuf
			      : (i.suffix == LONG_DOUBLE_MNEM_SUFFIX
				 ? No_xSuf : 0))))));

  t = current_templates->start;
  if (i.suffix == QWORD_MNEM_SUFFIX
      && flag_code != CODE_64BIT
      && (!intel_syntax
	  || (!(t->opcode_modifier & IgnoreSize)
	      && ! intel_float_operand (t->name)))
      && (!(t->operand_types[0] & (RegMMX | RegXMM))
	  || !(t->operand_types[t->operands > 1] & (RegMMX | RegXMM)))
      && (t->base_opcode != 0x0fc7
	  || t->extension_opcode != 1 /* cmpxchg8b */))
    t = current_templates->end;
  for (; t < current_templates->end; t++)
    {
      /* Must have right number of operands.  */
      if (i.operands != t->operands)
	continue;

      /* Check the suffix, except for some instructions in intel mode.  */
      if ((t->opcode_modifier & suffix_check)
	  && !(intel_syntax
	       && (t->opcode_modifier & IgnoreSize))
	  && !(intel_syntax
	       && t->base_opcode == 0xd9
	       && (t->extension_opcode == 5	     /* 0xd9,5 "fldcw"  */
		   || t->extension_opcode == 7)))  /* 0xd9,7 "f{n}stcw"  */
	continue;

      /* Do not verify operands when there are none.  */
      else if (!t->operands)
	{
	  if (t->cpu_flags & ~cpu_arch_flags)
	    continue;
	  /* We've found a match; break out of loop.  */
	  break;
	}

      overlap0 = i.types[0] & t->operand_types[0];
      switch (t->operands)
	{
	case 1:
	  if (!MATCH (overlap0, i.types[0], t->operand_types[0]))
	    continue;
	  break;
	case 2:
	case 3:
	  overlap1 = i.types[1] & t->operand_types[1];
	  if (!MATCH (overlap0, i.types[0], t->operand_types[0])
	      || !MATCH (overlap1, i.types[1], t->operand_types[1])
	      || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
					     t->operand_types[0],
					     overlap1, i.types[1],
					     t->operand_types[1]))
	    {
	      /* Check if other direction is valid ...  */
	      if ((t->opcode_modifier & (D | FloatD)) == 0)
		continue;

	      /* Try reversing direction of operands.  */
	      overlap0 = i.types[0] & t->operand_types[1];
	      overlap1 = i.types[1] & t->operand_types[0];
	      if (!MATCH (overlap0, i.types[0], t->operand_types[1])
		  || !MATCH (overlap1, i.types[1], t->operand_types[0])
		  || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
						 t->operand_types[1],
						 overlap1, i.types[1],
						 t->operand_types[0]))
		{
		  /* Does not match either direction.  */
		  continue;
		}
	      /* found_reverse_match holds which of D or FloatDR
		 we've found.  */
	      found_reverse_match = t->opcode_modifier & (D | FloatDR);
	    }
	  /* Found a forward 2 operand match here.  */
	  else if (t->operands == 3)
	    {
	      /* Here we make use of the fact that there are no
		 reverse match 3 operand instructions, and all 3
		 operand instructions only need to be checked for
		 register consistency between operands 2 and 3.  */
	      overlap2 = i.types[2] & t->operand_types[2];
	      if (!MATCH (overlap2, i.types[2], t->operand_types[2])
		  || !CONSISTENT_REGISTER_MATCH (overlap1, i.types[1],
						 t->operand_types[1],
						 overlap2, i.types[2],
						 t->operand_types[2]))

		continue;
	    }
	  /* Found either forward/reverse 2 or 3 operand match here:
	     slip through to break.  */
	}
      if (t->cpu_flags & ~cpu_arch_flags)
	{
	  found_reverse_match = 0;
	  continue;
	}
      /* We've found a match; break out of loop.  */
      break;
    }

  if (t == current_templates->end)
    {
      /* We found no match.  */
      as_bad (_("suffix or operands invalid for `%s'"),
	      current_templates->start->name);
      return 0;
    }

  if (!quiet_warnings)
    {
      if (!intel_syntax
	  && ((i.types[0] & JumpAbsolute)
	      != (t->operand_types[0] & JumpAbsolute)))
	{
	  as_warn (_("indirect %s without `*'"), t->name);
	}

      if ((t->opcode_modifier & (IsPrefix | IgnoreSize))
	  == (IsPrefix | IgnoreSize))
	{
	  /* Warn them that a data or address size prefix doesn't
	     affect assembly of the next line of code.  */
	  as_warn (_("stand-alone `%s' prefix"), t->name);
	}
    }

  /* Copy the template we found.  */
  i.tm = *t;
  if (found_reverse_match)
    {
      /* If we found a reverse match we must alter the opcode
	 direction bit.  found_reverse_match holds bits to change
	 (different for int & float insns).  */

      i.tm.base_opcode ^= found_reverse_match;

      i.tm.operand_types[0] = t->operand_types[1];
      i.tm.operand_types[1] = t->operand_types[0];
    }

  return 1;
}

static int
check_string ()
{
  int mem_op = (i.types[0] & AnyMem) ? 0 : 1;
  if ((i.tm.operand_types[mem_op] & EsSeg) != 0)
    {
      if (i.seg[0] != NULL && i.seg[0] != &es)
	{
	  as_bad (_("`%s' operand %d must use `%%es' segment"),
		  i.tm.name,
		  mem_op + 1);
	  return 0;
	}
      /* There's only ever one segment override allowed per instruction.
	 This instruction possibly has a legal segment override on the
	 second operand, so copy the segment to where non-string
	 instructions store it, allowing common code.  */
      i.seg[0] = i.seg[1];
    }
  else if ((i.tm.operand_types[mem_op + 1] & EsSeg) != 0)
    {
      if (i.seg[1] != NULL && i.seg[1] != &es)
	{
	  as_bad (_("`%s' operand %d must use `%%es' segment"),
		  i.tm.name,
		  mem_op + 2);
	  return 0;
	}
    }
  return 1;
}

static int
process_suffix (void)
{
  /* If matched instruction specifies an explicit instruction mnemonic
     suffix, use it.  */
  if (i.tm.opcode_modifier & (Size16 | Size32 | Size64))
    {
      if (i.tm.opcode_modifier & Size16)
	i.suffix = WORD_MNEM_SUFFIX;
      else if (i.tm.opcode_modifier & Size64)
	i.suffix = QWORD_MNEM_SUFFIX;
      else
	i.suffix = LONG_MNEM_SUFFIX;
    }
  else if (i.reg_operands)
    {
      /* If there's no instruction mnemonic suffix we try to invent one
	 based on register operands.  */
      if (!i.suffix)
	{
	  /* We take i.suffix from the last register operand specified,
	     Destination register type is more significant than source
	     register type.  */
	  int op;

	  for (op = i.operands; --op >= 0;)
	    if ((i.types[op] & Reg)
		&& !(i.tm.operand_types[op] & InOutPortReg))
	      {
		i.suffix = ((i.types[op] & Reg8) ? BYTE_MNEM_SUFFIX :
			    (i.types[op] & Reg16) ? WORD_MNEM_SUFFIX :
			    (i.types[op] & Reg64) ? QWORD_MNEM_SUFFIX :
			    LONG_MNEM_SUFFIX);
		break;
	      }
	}
      else if (i.suffix == BYTE_MNEM_SUFFIX)
	{
	  if (!check_byte_reg ())
	    return 0;
	}
      else if (i.suffix == LONG_MNEM_SUFFIX)
	{
	  if (!check_long_reg ())
	    return 0;
	}
      else if (i.suffix == QWORD_MNEM_SUFFIX)
	{
	  if (!check_qword_reg ())
	    return 0;
	}
      else if (i.suffix == WORD_MNEM_SUFFIX)
	{
	  if (!check_word_reg ())
	    return 0;
	}
      else if (intel_syntax && (i.tm.opcode_modifier & IgnoreSize))
	/* Do nothing if the instruction is going to ignore the prefix.  */
	;
      else
	abort ();
    }
  else if ((i.tm.opcode_modifier & DefaultSize) && !i.suffix)
    {
      i.suffix = stackop_size;
      if (i.suffix == QWORD_MNEM_SUFFIX
	  && (i.tm.opcode_modifier & No_qSuf))
	i.suffix = LONG_MNEM_SUFFIX;
    }

  /* Change the opcode based on the operand size given by i.suffix;
     We need not change things for byte insns.  */
  if (!i.suffix && (i.tm.opcode_modifier & W))
    {
      as_bad (_("no instruction mnemonic suffix given and no register operands; can't size instruction"));
      return 0;
    }

  if (i.suffix && i.suffix != BYTE_MNEM_SUFFIX)
    {
      /* It's not a byte, select word/dword operation.  */
      if (i.tm.opcode_modifier & W)
	{
	  if (i.tm.opcode_modifier & ShortForm)
	    i.tm.base_opcode |= 8;
	  else
	    i.tm.base_opcode |= 1;
	}

      /* Now select between word & dword operations via the operand
	 size prefix, except for instructions that will ignore this
	 prefix anyway.  */
      if (i.suffix != QWORD_MNEM_SUFFIX
	  && !(i.tm.opcode_modifier & IgnoreSize)
	  && ((i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
	      || (flag_code == CODE_64BIT
		  && (i.tm.opcode_modifier & JumpByte))))
	{
	  unsigned int prefix = DATA_PREFIX_OPCODE;

	  if (i.tm.opcode_modifier & JumpByte) /* jcxz, loop */
	    prefix = ADDR_PREFIX_OPCODE;

	  if (!add_prefix (prefix))
	    return 0;
	}

      /* Set mode64 for an operand.  */
      if (i.suffix == QWORD_MNEM_SUFFIX
	  && flag_code == CODE_64BIT
	  && (i.tm.opcode_modifier & NoRex64) == 0)
	i.rex |= REX_MODE64;

      /* Size floating point instruction.  */
      if (i.suffix == LONG_MNEM_SUFFIX)
	if (i.tm.opcode_modifier & FloatMF)
	  i.tm.base_opcode ^= 4;
    }

  return 1;
}

static int
check_byte_reg (void)
{
  int op;

  for (op = i.operands; --op >= 0;)
    {
      /* If this is an eight bit register, it's OK.  If it's the 16 or
	 32 bit version of an eight bit register, we will just use the
	 low portion, and that's OK too.  */
      if (i.types[op] & Reg8)
	continue;

      /* movzx and movsx should not generate this warning.  */
      if (intel_syntax
	  && (i.tm.base_opcode == 0xfb7
	      || i.tm.base_opcode == 0xfb6
	      || i.tm.base_opcode == 0x63
	      || i.tm.base_opcode == 0xfbe
	      || i.tm.base_opcode == 0xfbf))
	continue;

      if ((i.types[op] & WordReg) && i.op[op].regs->reg_num < 4
#if 0
	  /* Check that the template allows eight bit regs.  This
	     kills insns such as `orb $1,%edx', which maybe should be
	     allowed.  */
	  && (i.tm.operand_types[op] & (Reg8 | InOutPortReg))
#endif
	  )
	{
	  /* Prohibit these changes in the 64bit mode, since the
	     lowering is more complicated.  */
	  if (flag_code == CODE_64BIT
	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
	    {
	      as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		      i.op[op].regs->reg_name,
		      i.suffix);
	      return 0;
	    }
#if REGISTER_WARNINGS
	  if (!quiet_warnings
	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
	    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
		     (i.op[op].regs + (i.types[op] & Reg16
				       ? REGNAM_AL - REGNAM_AX
				       : REGNAM_AL - REGNAM_EAX))->reg_name,
		     i.op[op].regs->reg_name,
		     i.suffix);
#endif
	  continue;
	}
      /* Any other register is bad.  */
      if (i.types[op] & (Reg | RegMMX | RegXMM
			 | SReg2 | SReg3
			 | Control | Debug | Test
			 | FloatReg | FloatAcc))
	{
	  as_bad (_("`%%%s' not allowed with `%s%c'"),
		  i.op[op].regs->reg_name,
		  i.tm.name,
		  i.suffix);
	  return 0;
	}
    }
  return 1;
}

static int
check_long_reg ()
{
  int op;

  for (op = i.operands; --op >= 0;)
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
      {
	as_bad (_("`%%%s' not allowed with `%s%c'"),
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is missing.  */
    else if ((!quiet_warnings || flag_code == CODE_64BIT)
	     && (i.types[op] & Reg16) != 0
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	if (flag_code == CODE_64BIT)
	  {
	    as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		    i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
	  }
#if REGISTER_WARNINGS
	else
	  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
		   (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
		   i.op[op].regs->reg_name,
		   i.suffix);
#endif
      }
  /* Warn if the r prefix on a general reg is missing.  */
    else if ((i.types[op] & Reg64) != 0
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
      {
	as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		i.op[op].regs->reg_name,
		i.suffix);
	return 0;
      }
  return 1;
}

static int
check_qword_reg ()
{
  int op;

  for (op = i.operands; --op >= 0; )
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
      {
	as_bad (_("`%%%s' not allowed with `%s%c'"),
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is missing.  */
    else if (((i.types[op] & Reg16) != 0
	      || (i.types[op] & Reg32) != 0)
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		i.op[op].regs->reg_name,
		i.suffix);
	return 0;
      }
  return 1;
}

static int
check_word_reg ()
{
  int op;
  for (op = i.operands; --op >= 0;)
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
      {
	as_bad (_("`%%%s' not allowed with `%s%c'"),
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is present.  */
    else if ((!quiet_warnings || flag_code == CODE_64BIT)
	     && (i.types[op] & Reg32) != 0
	     && (i.tm.operand_types[op] & (Reg16 | Acc)) != 0)
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	if (flag_code == CODE_64BIT)
	  {
	    as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		    i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
	  }
	else
#if REGISTER_WARNINGS
	  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
		   (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
		   i.op[op].regs->reg_name,
		   i.suffix);
#endif
      }
  return 1;
}

static int
finalize_imm ()
{
  unsigned int overlap0, overlap1, overlap2;

  overlap0 = i.types[0] & i.tm.operand_types[0];
  if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S | Imm64))
      && overlap0 != Imm8 && overlap0 != Imm8S
      && overlap0 != Imm16 && overlap0 != Imm32S
      && overlap0 != Imm32 && overlap0 != Imm64)
    {
      if (i.suffix)
	{
	  overlap0 &= (i.suffix == BYTE_MNEM_SUFFIX
		       ? Imm8 | Imm8S
		       : (i.suffix == WORD_MNEM_SUFFIX
			  ? Imm16
			  : (i.suffix == QWORD_MNEM_SUFFIX
			     ? Imm64 | Imm32S
			     : Imm32)));
	}
      else if (overlap0 == (Imm16 | Imm32S | Imm32)
	       || overlap0 == (Imm16 | Imm32)
	       || overlap0 == (Imm16 | Imm32S))
	{
	  overlap0 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
		      ? Imm16 : Imm32S);
	}
      if (overlap0 != Imm8 && overlap0 != Imm8S
	  && overlap0 != Imm16 && overlap0 != Imm32S
	  && overlap0 != Imm32 && overlap0 != Imm64)
	{
	  as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
	  return 0;
	}
    }
  i.types[0] = overlap0;

  overlap1 = i.types[1] & i.tm.operand_types[1];
  if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32S | Imm32))
      && overlap1 != Imm8 && overlap1 != Imm8S
      && overlap1 != Imm16 && overlap1 != Imm32S
      && overlap1 != Imm32 && overlap1 != Imm64)
    {
      if (i.suffix)
	{
	  overlap1 &= (i.suffix == BYTE_MNEM_SUFFIX
		       ? Imm8 | Imm8S
		       : (i.suffix == WORD_MNEM_SUFFIX
			  ? Imm16
			  : (i.suffix == QWORD_MNEM_SUFFIX
			     ? Imm64 | Imm32S
			     : Imm32)));
	}
      else if (overlap1 == (Imm16 | Imm32 | Imm32S)
	       || overlap1 == (Imm16 | Imm32)
	       || overlap1 == (Imm16 | Imm32S))
	{
	  overlap1 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
		      ? Imm16 : Imm32S);
	}
      if (overlap1 != Imm8 && overlap1 != Imm8S
	  && overlap1 != Imm16 && overlap1 != Imm32S
	  && overlap1 != Imm32 && overlap1 != Imm64)
	{
	  as_bad (_("no instruction mnemonic suffix given; can't determine immediate size %x %c"),overlap1, i.suffix);
	  return 0;
	}
    }
  i.types[1] = overlap1;

  overlap2 = i.types[2] & i.tm.operand_types[2];
  assert ((overlap2 & Imm) == 0);
  i.types[2] = overlap2;

  return 1;
}

static int
process_operands ()
{
  /* Default segment register this instruction will use for memory
     accesses.  0 means unknown.  This is only for optimizing out
     unnecessary segment overrides.  */
  const seg_entry *default_seg = 0;

  /* The imul $imm, %reg instruction is converted into
     imul $imm, %reg, %reg, and the clr %reg instruction
     is converted into xor %reg, %reg.  */
  if (i.tm.opcode_modifier & regKludge)
    {
      unsigned int first_reg_op = (i.types[0] & Reg) ? 0 : 1;
      /* Pretend we saw the extra register operand.  */
      assert (i.op[first_reg_op + 1].regs == 0);
      i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
      i.types[first_reg_op + 1] = i.types[first_reg_op];
      i.reg_operands = 2;
    }

  if (i.tm.opcode_modifier & ShortForm)
    {
      /* The register or float register operand is in operand 0 or 1.  */
      unsigned int op = (i.types[0] & (Reg | FloatReg)) ? 0 : 1;
      /* Register goes in low 3 bits of opcode.  */
      i.tm.base_opcode |= i.op[op].regs->reg_num;
      if ((i.op[op].regs->reg_flags & RegRex) != 0)
	i.rex |= REX_EXTZ;
      if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
	{
	  /* Warn about some common errors, but press on regardless.
	     The first case can be generated by gcc (<= 2.8.1).  */
	  if (i.operands == 2)
	    {
	      /* Reversed arguments on faddp, fsubp, etc.  */
	      as_warn (_("translating to `%s %%%s,%%%s'"), i.tm.name,
		       i.op[1].regs->reg_name,
		       i.op[0].regs->reg_name);
	    }
	  else
	    {
	      /* Extraneous `l' suffix on fp insn.  */
	      as_warn (_("translating to `%s %%%s'"), i.tm.name,
		       i.op[0].regs->reg_name);
	    }
	}
    }
  else if (i.tm.opcode_modifier & Modrm)
    {
      /* The opcode is completed (modulo i.tm.extension_opcode which
	 must be put into the modrm byte).  Now, we make the modrm and
	 index base bytes based on all the info we've collected.  */

      default_seg = build_modrm_byte ();
    }
  else if (i.tm.opcode_modifier & (Seg2ShortForm | Seg3ShortForm))
    {
      if (i.tm.base_opcode == POP_SEG_SHORT
	  && i.op[0].regs->reg_num == 1)
	{
	  as_bad (_("you can't `pop %%cs'"));
	  return 0;
	}
      i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);
      if ((i.op[0].regs->reg_flags & RegRex) != 0)
	i.rex |= REX_EXTZ;
    }
  else if ((i.tm.base_opcode & ~(D | W)) == MOV_AX_DISP32)
    {
      default_seg = &ds;
    }
  else if ((i.tm.opcode_modifier & IsString) != 0)
    {
      /* For the string instructions that allow a segment override
	 on one of their operands, the default segment is ds.  */
      default_seg = &ds;
    }

  if (i.tm.base_opcode == 0x8d /* lea */ && i.seg[0] && !quiet_warnings)
    as_warn (_("segment override on `lea' is ineffectual"));

  /* If a segment was explicitly specified, and the specified segment
     is not the default, use an opcode prefix to select it.  If we
     never figured out what the default segment is, then default_seg
     will be zero at this point, and the specified segment prefix will
     always be used.  */
  if ((i.seg[0]) && (i.seg[0] != default_seg))
    {
      if (!add_prefix (i.seg[0]->seg_prefix))
	return 0;
    }
  return 1;
}

static const seg_entry *
build_modrm_byte ()
{
  const seg_entry *default_seg = 0;

  /* i.reg_operands MUST be the number of real register operands;
     implicit registers do not count.  */
  if (i.reg_operands == 2)
    {
      unsigned int source, dest;
      source = ((i.types[0]
		 & (Reg | RegMMX | RegXMM
		    | SReg2 | SReg3
		    | Control | Debug | Test))
		? 0 : 1);
      dest = source + 1;

      i.rm.mode = 3;
      /* One of the register operands will be encoded in the i.tm.reg
	 field, the other in the combined i.tm.mode and i.tm.regmem
	 fields.  If no form of this instruction supports a memory
	 destination operand, then we assume the source operand may
	 sometimes be a memory operand and so we need to store the
	 destination in the i.rm.reg field.  */
      if ((i.tm.operand_types[dest] & AnyMem) == 0)
	{
	  i.rm.reg = i.op[dest].regs->reg_num;
	  i.rm.regmem = i.op[source].regs->reg_num;
	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTX;
	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTZ;
	}
      else
	{
	  i.rm.reg = i.op[source].regs->reg_num;
	  i.rm.regmem = i.op[dest].regs->reg_num;
	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTZ;
	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTX;
	}
    }
  else
    {			/* If it's not 2 reg operands...  */
      if (i.mem_operands)
	{
	  unsigned int fake_zero_displacement = 0;
	  unsigned int op = ((i.types[0] & AnyMem)
			     ? 0
			     : (i.types[1] & AnyMem) ? 1 : 2);

	  default_seg = &ds;

	  if (i.base_reg == 0)
	    {
	      i.rm.mode = 0;
	      if (!i.disp_operands)
		fake_zero_displacement = 1;
	      if (i.index_reg == 0)
		{
		  /* Operand is just <disp>  */
		  if (flag_code == CODE_64BIT)
		    {
		      /* 64bit mode overwrites the 32bit absolute
			 addressing by RIP relative addressing and
			 absolute addressing is encoded by one of the
			 redundant SIB forms.  */
		      i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		      i.sib.base = NO_BASE_REGISTER;
		      i.sib.index = NO_INDEX_REGISTER;
		      i.types[op] = ((i.prefix[ADDR_PREFIX] == 0) ? Disp32S : Disp32);
		    }
		  else if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
		    {
		      i.rm.regmem = NO_BASE_REGISTER_16;
		      i.types[op] = Disp16;
		    }
		  else
		    {
		      i.rm.regmem = NO_BASE_REGISTER;
		      i.types[op] = Disp32;
		    }
		}
	      else /* !i.base_reg && i.index_reg  */
		{
		  i.sib.index = i.index_reg->reg_num;
		  i.sib.base = NO_BASE_REGISTER;
		  i.sib.scale = i.log2_scale_factor;
		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		  i.types[op] &= ~Disp;
		  if (flag_code != CODE_64BIT)
		    i.types[op] |= Disp32;	/* Must be 32 bit */
		  else
		    i.types[op] |= Disp32S;
		  if ((i.index_reg->reg_flags & RegRex) != 0)
		    i.rex |= REX_EXTY;
		}
	    }
	  /* RIP addressing for 64bit mode.  */
	  else if (i.base_reg->reg_type == BaseIndex)
	    {
	      i.rm.regmem = NO_BASE_REGISTER;
	      i.types[op] &= ~ Disp;
	      i.types[op] |= Disp32S;
	      i.flags[op] = Operand_PCrel;
	      if (! i.disp_operands)
		fake_zero_displacement = 1;
	    }
	  else if (i.base_reg->reg_type & Reg16)
	    {
	      switch (i.base_reg->reg_num)
		{
		case 3: /* (%bx)  */
		  if (i.index_reg == 0)
		    i.rm.regmem = 7;
		  else /* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
		    i.rm.regmem = i.index_reg->reg_num - 6;
		  break;
		case 5: /* (%bp)  */
		  default_seg = &ss;
		  if (i.index_reg == 0)
		    {
		      i.rm.regmem = 6;
		      if ((i.types[op] & Disp) == 0)
			{
			  /* fake (%bp) into 0(%bp)  */
			  i.types[op] |= Disp8;
			  fake_zero_displacement = 1;
			}
		    }
		  else /* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
		    i.rm.regmem = i.index_reg->reg_num - 6 + 2;
		  break;
		default: /* (%si) -> 4 or (%di) -> 5  */
		  i.rm.regmem = i.base_reg->reg_num - 6 + 4;
		}
	      i.rm.mode = mode_from_disp_size (i.types[op]);
	    }
	  else /* i.base_reg and 32/64 bit mode  */
	    {
	      if (flag_code == CODE_64BIT
		  && (i.types[op] & Disp))
		i.types[op] = (i.types[op] & Disp8) | (i.prefix[ADDR_PREFIX] == 0 ? Disp32S : Disp32);

	      i.rm.regmem = i.base_reg->reg_num;
	      if ((i.base_reg->reg_flags & RegRex) != 0)
		i.rex |= REX_EXTZ;
	      i.sib.base = i.base_reg->reg_num;
	      /* x86-64 ignores REX prefix bit here to avoid decoder
		 complications.  */
	      if ((i.base_reg->reg_num & 7) == EBP_REG_NUM)
		{
		  default_seg = &ss;
		  if (i.disp_operands == 0)
		    {
		      fake_zero_displacement = 1;
		      i.types[op] |= Disp8;
		    }
		}
	      else if (i.base_reg->reg_num == ESP_REG_NUM)
		{
		  default_seg = &ss;
		}
	      i.sib.scale = i.log2_scale_factor;
	      if (i.index_reg == 0)
		{
		  /* <disp>(%esp) becomes two byte modrm with no index
		     register.  We've already stored the code for esp
		     in i.rm.regmem ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.
		     Any base register besides %esp will not use the
		     extra modrm byte.  */
		  i.sib.index = NO_INDEX_REGISTER;
#if !SCALE1_WHEN_NO_INDEX
		  /* Another case where we force the second modrm byte.  */
		  if (i.log2_scale_factor)
		    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
#endif
		}
	      else
		{
		  i.sib.index = i.index_reg->reg_num;
		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		  if ((i.index_reg->reg_flags & RegRex) != 0)
		    i.rex |= REX_EXTY;
		}
	      i.rm.mode = mode_from_disp_size (i.types[op]);
	    }

	  if (fake_zero_displacement)
	    {
	      /* Fakes a zero displacement assuming that i.types[op]
		 holds the correct displacement size.  */
	      expressionS *exp;

	      assert (i.op[op].disps == 0);
	      exp = &disp_expressions[i.disp_operands++];
	      i.op[op].disps = exp;
	      exp->X_op = O_constant;
	      exp->X_add_number = 0;
	      exp->X_add_symbol = (symbolS *) 0;
	      exp->X_op_symbol = (symbolS *) 0;
	    }
	}

      /* Fill in i.rm.reg or i.rm.regmem field with register operand
	 (if any) based on i.tm.extension_opcode.  Again, we must be
	 careful to make sure that segment/control/debug/test/MMX
	 registers are coded into the i.rm.reg field.  */
      if (i.reg_operands)
	{
	  unsigned int op =
	    ((i.types[0]
	      & (Reg | RegMMX | RegXMM
		 | SReg2 | SReg3
		 | Control | Debug | Test))
	     ? 0
	     : ((i.types[1]
		 & (Reg | RegMMX | RegXMM
		    | SReg2 | SReg3
		    | Control | Debug | Test))
		? 1
		: 2));
	  /* If there is an extension opcode to put here, the register
	     number must be put into the regmem field.  */
	  if (i.tm.extension_opcode != None)
	    {
	      i.rm.regmem = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_EXTZ;
	    }
	  else
	    {
	      i.rm.reg = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_EXTX;
	    }

	  /* Now, if no memory operand has set i.rm.mode = 0, 1, 2 we
	     must set it to 3 to indicate this is a register operand
	     in the regmem field.  */
	  if (!i.mem_operands)
	    i.rm.mode = 3;
	}

      /* Fill in i.rm.reg field with extension opcode (if any).  */
      if (i.tm.extension_opcode != None)
	i.rm.reg = i.tm.extension_opcode;
    }
  return default_seg;
}

static void
output_branch ()
{
  char *p;
  int code16;
  int prefix;
  relax_substateT subtype;
  symbolS *sym;
  offsetT off;

  code16 = 0;
  if (flag_code == CODE_16BIT)
    code16 = CODE16;

  prefix = 0;
  if (i.prefix[DATA_PREFIX] != 0)
    {
      prefix = 1;
      i.prefixes -= 1;
      code16 ^= CODE16;
    }
  /* Pentium4 branch hints.  */
  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
    {
      prefix++;
      i.prefixes--;
    }
  if (i.prefix[REX_PREFIX] != 0)
    {
      prefix++;
      i.prefixes--;
    }

  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));

  /* It's always a symbol;  End frag & setup for relax.
     Make sure there is enough room in this frag for the largest
     instruction we may generate in md_convert_frag.  This is 2
     bytes for the opcode and room for the prefix and largest
     displacement.  */
  frag_grow (prefix + 2 + 4);
  /* Prefix and 1 opcode byte go in fr_fix.  */
  p = frag_more (prefix + 1);
  if (i.prefix[DATA_PREFIX] != 0)
    *p++ = DATA_PREFIX_OPCODE;
  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE
      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE)
    *p++ = i.prefix[SEG_PREFIX];
  if (i.prefix[REX_PREFIX] != 0)
    *p++ = i.prefix[REX_PREFIX];
  *p = i.tm.base_opcode;

  if ((unsigned char) *p == JUMP_PC_RELATIVE)
    subtype = ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL);
  else if ((cpu_arch_flags & Cpu386) != 0)
    subtype = ENCODE_RELAX_STATE (COND_JUMP, SMALL);
  else
    subtype = ENCODE_RELAX_STATE (COND_JUMP86, SMALL);
  subtype |= code16;

  sym = i.op[0].disps->X_add_symbol;
  off = i.op[0].disps->X_add_number;

  if (i.op[0].disps->X_op != O_constant
      && i.op[0].disps->X_op != O_symbol)
    {
      /* Handle complex expressions.  */
      sym = make_expr_symbol (i.op[0].disps);
      off = 0;
    }

  /* 1 possible extra opcode + 4 byte displacement go in var part.
     Pass reloc in fr_var.  */
  frag_var (rs_machine_dependent, 5, i.reloc[0], subtype, sym, off, p);
}

static void
output_jump ()
{
  char *p;
  int size;
  fixS *fixP;

  if (i.tm.opcode_modifier & JumpByte)
    {
      /* This is a loop or jecxz type instruction.  */
      size = 1;
      if (i.prefix[ADDR_PREFIX] != 0)
	{
	  FRAG_APPEND_1_CHAR (ADDR_PREFIX_OPCODE);
	  i.prefixes -= 1;
	}
      /* Pentium4 branch hints.  */
      if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
	  || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	{
	  FRAG_APPEND_1_CHAR (i.prefix[SEG_PREFIX]);
	  i.prefixes--;
	}
    }
  else
    {
      int code16;

      code16 = 0;
      if (flag_code == CODE_16BIT)
	code16 = CODE16;

      if (i.prefix[DATA_PREFIX] != 0)
	{
	  FRAG_APPEND_1_CHAR (DATA_PREFIX_OPCODE);
	  i.prefixes -= 1;
	  code16 ^= CODE16;
	}

      size = 4;
      if (code16)
	size = 2;
    }

  if (i.prefix[REX_PREFIX] != 0)
    {
      FRAG_APPEND_1_CHAR (i.prefix[REX_PREFIX]);
      i.prefixes -= 1;
    }

  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));

  p = frag_more (1 + size);
  *p++ = i.tm.base_opcode;

  fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));

  /* All jumps handled here are signed, but don't use a signed limit
     check for 32 and 16 bit jumps as we want to allow wrap around at
     4G and 64k respectively.  */
  if (size == 1)
    fixP->fx_signed = 1;
}

static void
output_interseg_jump ()
{
  char *p;
  int size;
  int prefix;
  int code16;

  code16 = 0;
  if (flag_code == CODE_16BIT)
    code16 = CODE16;

  prefix = 0;
  if (i.prefix[DATA_PREFIX] != 0)
    {
      prefix = 1;
      i.prefixes -= 1;
      code16 ^= CODE16;
    }
  if (i.prefix[REX_PREFIX] != 0)
    {
      prefix++;
      i.prefixes -= 1;
    }

  size = 4;
  if (code16)
    size = 2;

  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));

  /* 1 opcode; 2 segment; offset  */
  p = frag_more (prefix + 1 + 2 + size);

  if (i.prefix[DATA_PREFIX] != 0)
    *p++ = DATA_PREFIX_OPCODE;

  if (i.prefix[REX_PREFIX] != 0)
    *p++ = i.prefix[REX_PREFIX];

  *p++ = i.tm.base_opcode;
  if (i.op[1].imms->X_op == O_constant)
    {
      offsetT n = i.op[1].imms->X_add_number;

      if (size == 2
	  && !fits_in_unsigned_word (n)
	  && !fits_in_signed_word (n))
	{
	  as_bad (_("16-bit jump out of range"));
	  return;
	}
      md_number_to_chars (p, n, size);
    }
  else
    fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		 i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
  if (i.op[0].imms->X_op != O_constant)
    as_bad (_("can't handle non absolute segment in `%s'"),
	    i.tm.name);
  md_number_to_chars (p + size, (valueT) i.op[0].imms->X_add_number, 2);
}

static void
output_insn ()
{
  fragS *insn_start_frag;
  offsetT insn_start_off;

  /* Tie dwarf2 debug info to the address at the start of the insn.
     We can't do this after the insn has been output as the current
     frag may have been closed off.  eg. by frag_var.  */
  dwarf2_emit_insn (0);

  insn_start_frag = frag_now;
  insn_start_off = frag_now_fix ();

  /* Output jumps.  */
  if (i.tm.opcode_modifier & Jump)
    output_branch ();
  else if (i.tm.opcode_modifier & (JumpByte | JumpDword))
    output_jump ();
  else if (i.tm.opcode_modifier & JumpInterSegment)
    output_interseg_jump ();
  else
    {
      /* Output normal instructions here.  */
      char *p;
      unsigned char *q;
      unsigned int prefix;

      /* All opcodes on i386 have either 1 or 2 bytes, PadLock instructions
	 have 3 bytes.  We may use one more higher byte to specify a prefix
	 the instruction requires.  */
      if (((i.tm.cpu_flags & (CpuPadLock|CpuSSSE3|CpuAES|CpuPCLMUL)) != 0)
	  && (i.tm.base_opcode & 0xff000000) != 0)
        {
	  unsigned int prefix;
	  prefix = (i.tm.base_opcode >> 24) & 0xff;

	  if (prefix != REPE_PREFIX_OPCODE
	      || i.prefix[LOCKREP_PREFIX] != REPE_PREFIX_OPCODE)
	    add_prefix (prefix);
	}
	else if (i.tm.base_opcode == 0x660f3880 || i.tm.base_opcode == 0x660f3881) {
          /* invept and invvpid are 3 byte instructions with a
             mandatory prefix. */
          if (i.tm.base_opcode & 0xff000000)
            {
              prefix = (i.tm.base_opcode >> 24) & 0xff;
              add_prefix (prefix);
            }
	}
      else
	if ((i.tm.cpu_flags & CpuPadLock) == 0
	    && (i.tm.base_opcode & 0xff0000) != 0)
	  add_prefix ((i.tm.base_opcode >> 16) & 0xff);

      /* The prefix bytes.  */
      for (q = i.prefix;
	   q < i.prefix + sizeof (i.prefix) / sizeof (i.prefix[0]);
	   q++)
	{
	  if (*q)
	    {
	      p = frag_more (1);
	      md_number_to_chars (p, (valueT) *q, 1);
	    }
	}

      /* Now the opcode; be careful about word order here!  */
      if (fits_in_unsigned_byte (i.tm.base_opcode))
	{
	  FRAG_APPEND_1_CHAR (i.tm.base_opcode);
	}
      else
	{
	  if ((i.tm.cpu_flags & (CpuPadLock|CpuSSSE3|CpuAES|CpuPCLMUL)) != 0)
	    {
	      p = frag_more (3);
	      *p++ = (i.tm.base_opcode >> 16) & 0xff;
	    }
          else if (i.tm.base_opcode == 0x660f3880 ||
                   i.tm.base_opcode == 0x660f3881)
            {
              p = frag_more (3);
              *p++ = (i.tm.base_opcode >> 16) & 0xff;
            }
	  else
	    p = frag_more (2);

	  /* Put out high byte first: can't use md_number_to_chars!  */
	  *p++ = (i.tm.base_opcode >> 8) & 0xff;
	  *p = i.tm.base_opcode & 0xff;
	}

      /* Now the modrm byte and sib byte (if present).  */
      if (i.tm.opcode_modifier & Modrm)
	{
	  p = frag_more (1);
	  md_number_to_chars (p,
			      (valueT) (i.rm.regmem << 0
					| i.rm.reg << 3
					| i.rm.mode << 6),
			      1);
	  /* If i.rm.regmem == ESP (4)
	     && i.rm.mode != (Register mode)
	     && not 16 bit
	     ==> need second modrm byte.  */
	  if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING
	      && i.rm.mode != 3
	      && !(i.base_reg && (i.base_reg->reg_type & Reg16) != 0))
	    {
	      p = frag_more (1);
	      md_number_to_chars (p,
				  (valueT) (i.sib.base << 0
					    | i.sib.index << 3
					    | i.sib.scale << 6),
				  1);
	    }
	}

      if (i.disp_operands)
	output_disp (insn_start_frag, insn_start_off);

      if (i.imm_operands)
	output_imm (insn_start_frag, insn_start_off);
    }

#ifdef DEBUG386
  if (flag_debug)
    {
      pi (line, &i);
    }
#endif /* DEBUG386  */
}

static void
output_disp (insn_start_frag, insn_start_off)
    fragS *insn_start_frag;
    offsetT insn_start_off;
{
  char *p;
  unsigned int n;

  for (n = 0; n < i.operands; n++)
    {
      if (i.types[n] & Disp)
	{
	  if (i.op[n].disps->X_op == O_constant)
	    {
	      int size;
	      offsetT val;

	      size = 4;
	      if (i.types[n] & (Disp8 | Disp16 | Disp64))
		{
		  size = 2;
		  if (i.types[n] & Disp8)
		    size = 1;
		  if (i.types[n] & Disp64)
		    size = 8;
		}
	      val = offset_in_range (i.op[n].disps->X_add_number,
				     size);
	      p = frag_more (size);
	      md_number_to_chars (p, val, size);
	    }
	  else
	    {
	      enum bfd_reloc_code_real reloc_type;
	      int size = 4;
	      int sign = 0;
	      int pcrel = (i.flags[n] & Operand_PCrel) != 0;

	      /* The PC relative address is computed relative
		 to the instruction boundary, so in case immediate
		 fields follows, we need to adjust the value.  */
	      if (pcrel && i.imm_operands)
		{
		  int imm_size = 4;
		  unsigned int n1;

		  for (n1 = 0; n1 < i.operands; n1++)
		    if (i.types[n1] & Imm)
		      {
			if (i.types[n1] & (Imm8 | Imm8S | Imm16 | Imm64))
			  {
			    imm_size = 2;
			    if (i.types[n1] & (Imm8 | Imm8S))
			      imm_size = 1;
			    if (i.types[n1] & Imm64)
			      imm_size = 8;
			  }
			break;
		      }
		  /* We should find the immediate.  */
		  if (n1 == i.operands)
		    abort ();
		  i.op[n].disps->X_add_number -= imm_size;
		}

	      if (i.types[n] & Disp32S)
		sign = 1;

	      if (i.types[n] & (Disp16 | Disp64))
		{
		  size = 2;
		  if (i.types[n] & Disp64)
		    size = 8;
		}

	      p = frag_more (size);
	      reloc_type = reloc (size, pcrel, sign, i.reloc[n]);
	      if (reloc_type == BFD_RELOC_32
		  && GOT_symbol
		  && GOT_symbol == i.op[n].disps->X_add_symbol
		  && (i.op[n].disps->X_op == O_symbol
		      || (i.op[n].disps->X_op == O_add
			  && ((symbol_get_value_expression
			       (i.op[n].disps->X_op_symbol)->X_op)
			      == O_subtract))))
		{
		  offsetT add;

		  if (insn_start_frag == frag_now)
		    add = (p - frag_now->fr_literal) - insn_start_off;
		  else
		    {
		      fragS *fr;

		      add = insn_start_frag->fr_fix - insn_start_off;
		      for (fr = insn_start_frag->fr_next;
			   fr && fr != frag_now; fr = fr->fr_next)
			add += fr->fr_fix;
		      add += p - frag_now->fr_literal;
		    }

		  /* We don't support dynamic linking on x86-64 yet.  */
		  if (flag_code == CODE_64BIT)
		    abort ();
		  reloc_type = BFD_RELOC_386_GOTPC;
		  i.op[n].disps->X_add_number += add;
		}
	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			   i.op[n].disps, pcrel, reloc_type);
	    }
	}
    }
}

static void
output_imm (insn_start_frag, insn_start_off)
    fragS *insn_start_frag;
    offsetT insn_start_off;
{
  char *p;
  unsigned int n;

  for (n = 0; n < i.operands; n++)
    {
      if (i.types[n] & Imm)
	{
	  if (i.op[n].imms->X_op == O_constant)
	    {
	      int size;
	      offsetT val;

	      size = 4;
	      if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
		{
		  size = 2;
		  if (i.types[n] & (Imm8 | Imm8S))
		    size = 1;
		  else if (i.types[n] & Imm64)
		    size = 8;
		}
	      val = offset_in_range (i.op[n].imms->X_add_number,
				     size);
	      p = frag_more (size);
	      md_number_to_chars (p, val, size);
	    }
	  else
	    {
	      /* Not absolute_section.
		 Need a 32-bit fixup (don't support 8bit
		 non-absolute imms).  Try to support other
		 sizes ...  */
	      enum bfd_reloc_code_real reloc_type;
	      int size = 4;
	      int sign = 0;

	      if ((i.types[n] & (Imm32S))
		  && i.suffix == QWORD_MNEM_SUFFIX)
		sign = 1;
	      if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
		{
		  size = 2;
		  if (i.types[n] & (Imm8 | Imm8S))
		    size = 1;
		  if (i.types[n] & Imm64)
		    size = 8;
		}

	      p = frag_more (size);
	      reloc_type = reloc (size, 0, sign, i.reloc[n]);

	      /*   This is tough to explain.  We end up with this one if we
	       * have operands that look like
	       * "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal here is to
	       * obtain the absolute address of the GOT, and it is strongly
	       * preferable from a performance point of view to avoid using
	       * a runtime relocation for this.  The actual sequence of
	       * instructions often look something like:
	       *
	       *	call	.L66
	       * .L66:
	       *	popl	%ebx
	       *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
	       *
	       *   The call and pop essentially return the absolute address
	       * of the label .L66 and store it in %ebx.  The linker itself
	       * will ultimately change the first operand of the addl so
	       * that %ebx points to the GOT, but to keep things simple, the
	       * .o file must have this operand set so that it generates not
	       * the absolute address of .L66, but the absolute address of
	       * itself.  This allows the linker itself simply treat a GOTPC
	       * relocation as asking for a pcrel offset to the GOT to be
	       * added in, and the addend of the relocation is stored in the
	       * operand field for the instruction itself.
	       *
	       *   Our job here is to fix the operand so that it would add
	       * the correct offset so that %ebx would point to itself.  The
	       * thing that is tricky is that .-.L66 will point to the
	       * beginning of the instruction, so we need to further modify
	       * the operand so that it will point to itself.  There are
	       * other cases where you have something like:
	       *
	       *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
	       *
	       * and here no correction would be required.  Internally in
	       * the assembler we treat operands of this form as not being
	       * pcrel since the '.' is explicitly mentioned, and I wonder
	       * whether it would simplify matters to do it this way.  Who
	       * knows.  In earlier versions of the PIC patches, the
	       * pcrel_adjust field was used to store the correction, but
	       * since the expression is not pcrel, I felt it would be
	       * confusing to do it this way.  */

	      if (reloc_type == BFD_RELOC_32
		  && GOT_symbol
		  && GOT_symbol == i.op[n].imms->X_add_symbol
		  && (i.op[n].imms->X_op == O_symbol
		      || (i.op[n].imms->X_op == O_add
			  && ((symbol_get_value_expression
			       (i.op[n].imms->X_op_symbol)->X_op)
			      == O_subtract))))
		{
		  offsetT add;

		  if (insn_start_frag == frag_now)
		    add = (p - frag_now->fr_literal) - insn_start_off;
		  else
		    {
		      fragS *fr;

		      add = insn_start_frag->fr_fix - insn_start_off;
		      for (fr = insn_start_frag->fr_next;
			   fr && fr != frag_now; fr = fr->fr_next)
			add += fr->fr_fix;
		      add += p - frag_now->fr_literal;
		    }

		  /* We don't support dynamic linking on x86-64 yet.  */
		  if (flag_code == CODE_64BIT)
		    abort ();
		  reloc_type = BFD_RELOC_386_GOTPC;
		  i.op[n].imms->X_add_number += add;
		}
	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			   i.op[n].imms, 0, reloc_type);
	    }
	}
    }
}

#ifndef LEX_AT
static char *lex_got PARAMS ((enum bfd_reloc_code_real *, int *));

/* Parse operands of the form
   <symbol>@@GOTOFF+<nnn>
   and similar .plt or .got references.

   If we find one, set up the correct relocation in RELOC and copy the
   input string, minus the `@@GOTOFF' into a malloc'd buffer for
   parsing by the calling routine.  Return this buffer, and if ADJUST
   is non-null set it to the length of the string we removed from the
   input line.  Otherwise return NULL.  */
static char *
lex_got (reloc, adjust)
     enum bfd_reloc_code_real *reloc;
     int *adjust;
{
  static const char * const mode_name[NUM_FLAG_CODE] = { "32", "16", "64" };
  static const struct {
    const char *str;
    const enum bfd_reloc_code_real rel[NUM_FLAG_CODE];
  } gotrel[] = {
    { "PLT",      { BFD_RELOC_386_PLT32,      0, BFD_RELOC_X86_64_PLT32    } },
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF,     0, 0                         } },
    { "GOTPCREL", { 0,                        0, BFD_RELOC_X86_64_GOTPCREL } },
    { "TLSGD",    { BFD_RELOC_386_TLS_GD,     0, BFD_RELOC_X86_64_TLSGD    } },
    { "TLSLDM",   { BFD_RELOC_386_TLS_LDM,    0, 0                         } },
    { "TLSLD",    { 0,                        0, BFD_RELOC_X86_64_TLSLD    } },
    { "GOTTPOFF", { BFD_RELOC_386_TLS_IE_32,  0, BFD_RELOC_X86_64_GOTTPOFF } },
    { "TPOFF",    { BFD_RELOC_386_TLS_LE_32,  0, BFD_RELOC_X86_64_TPOFF32  } },
    { "NTPOFF",   { BFD_RELOC_386_TLS_LE,     0, 0                         } },
    { "DTPOFF",   { BFD_RELOC_386_TLS_LDO_32, 0, BFD_RELOC_X86_64_DTPOFF32 } },
    { "GOTNTPOFF",{ BFD_RELOC_386_TLS_GOTIE,  0, 0                         } },
    { "INDNTPOFF",{ BFD_RELOC_386_TLS_IE,     0, 0                         } },
    { "GOT",      { BFD_RELOC_386_GOT32,      0, BFD_RELOC_X86_64_GOT32    } }
  };
  char *cp;
  unsigned int j;

  for (cp = input_line_pointer; *cp != '@@'; cp++)
    if (is_end_of_line[(unsigned char) *cp])
      return NULL;

  for (j = 0; j < sizeof (gotrel) / sizeof (gotrel[0]); j++)
    {
      int len;

      len = strlen (gotrel[j].str);
      if (strncasecmp (cp + 1, gotrel[j].str, len) == 0)
	{
	  if (gotrel[j].rel[(unsigned int) flag_code] != 0)
	    {
	      int first, second;
	      char *tmpbuf, *past_reloc;

	      *reloc = gotrel[j].rel[(unsigned int) flag_code];
	      if (adjust)
		*adjust = len;

	      if (GOT_symbol == NULL)
		GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	      /* Replace the relocation token with ' ', so that
		 errors like foo@@GOTOFF1 will be detected.  */

	      /* The length of the first part of our input line.  */
	      first = cp - input_line_pointer;

	      /* The second part goes from after the reloc token until
		 (and including) an end_of_line char.  Don't use strlen
		 here as the end_of_line char may not be a NUL.  */
	      past_reloc = cp + 1 + len;
	      for (cp = past_reloc; !is_end_of_line[(unsigned char) *cp++]; )
		;
	      second = cp - past_reloc;

	      /* Allocate and copy string.  The trailing NUL shouldn't
		 be necessary, but be safe.  */
	      tmpbuf = xmalloc (first + second + 2);
	      memcpy (tmpbuf, input_line_pointer, first);
	      tmpbuf[first] = ' ';
	      memcpy (tmpbuf + first + 1, past_reloc, second);
	      tmpbuf[first + second + 1] = '\0';
	      return tmpbuf;
	    }

	  as_bad (_("@@%s reloc is not supported in %s bit mode"),
		  gotrel[j].str, mode_name[(unsigned int) flag_code]);
	  return NULL;
	}
    }

  /* Might be a symbol version string.  Don't as_bad here.  */
  return NULL;
}

/* x86_cons_fix_new is called via the expression parsing code when a
   reloc is needed.  We use this hook to get the correct .got reloc.  */
static enum bfd_reloc_code_real got_reloc = NO_RELOC;

void
x86_cons_fix_new (frag, off, len, exp)
     fragS *frag;
     unsigned int off;
     unsigned int len;
     expressionS *exp;
{
  enum bfd_reloc_code_real r = reloc (len, 0, 0, got_reloc);
  got_reloc = NO_RELOC;
  fix_new_exp (frag, off, len, exp, 0, r);
}

void
x86_cons (exp, size)
     expressionS *exp;
     int size;
{
  if (size == 4)
    {
      /* Handle @@GOTOFF and the like in an expression.  */
      char *save;
      char *gotfree_input_line;
      int adjust;

      save = input_line_pointer;
      gotfree_input_line = lex_got (&got_reloc, &adjust);
      if (gotfree_input_line)
	input_line_pointer = gotfree_input_line;

      expression (exp);

      if (gotfree_input_line)
	{
	  /* expression () has merrily parsed up to the end of line,
	     or a comma - in the wrong buffer.  Transfer how far
	     input_line_pointer has moved to the right buffer.  */
	  input_line_pointer = (save
				+ (input_line_pointer - gotfree_input_line)
				+ adjust);
	  free (gotfree_input_line);
	}
    }
  else
    expression (exp);
}
#endif

static int i386_immediate PARAMS ((char *));

static int
i386_immediate (imm_start)
     char *imm_start;
{
  char *save_input_line_pointer;
#ifndef LEX_AT
  char *gotfree_input_line;
#endif
  segT exp_seg = 0;
  expressionS *exp;

  if (i.imm_operands == MAX_IMMEDIATE_OPERANDS)
    {
      as_bad (_("only 1 or 2 immediate operands are allowed"));
      return 0;
    }

  exp = &im_expressions[i.imm_operands++];
  i.op[this_operand].imms = exp;

  if (is_space_char (*imm_start))
    ++imm_start;

  save_input_line_pointer = input_line_pointer;
  input_line_pointer = imm_start;

#ifndef LEX_AT
  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL);
  if (gotfree_input_line)
    input_line_pointer = gotfree_input_line;
#endif

  exp_seg = expression (exp);

  SKIP_WHITESPACE ();
  if (*input_line_pointer)
    as_bad (_("junk `%s' after expression"), input_line_pointer);

  input_line_pointer = save_input_line_pointer;
#ifndef LEX_AT
  if (gotfree_input_line)
    free (gotfree_input_line);
#endif

  if (exp->X_op == O_absent || exp->X_op == O_big)
    {
      /* Missing or bad expr becomes absolute 0.  */
      as_bad (_("missing or invalid immediate expression `%s' taken as 0"),
	      imm_start);
      exp->X_op = O_constant;
      exp->X_add_number = 0;
      exp->X_add_symbol = (symbolS *) 0;
      exp->X_op_symbol = (symbolS *) 0;
    }
  else if (exp->X_op == O_constant)
    {
      /* Size it properly later.  */
      i.types[this_operand] |= Imm64;
      /* If BFD64, sign extend val.  */
      if (!use_rela_relocations)
	if ((exp->X_add_number & ~(((addressT) 2 << 31) - 1)) == 0)
	  exp->X_add_number = (exp->X_add_number ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);
    }
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  else if (OUTPUT_FLAVOR == bfd_target_aout_flavour
	   && exp_seg != absolute_section
	   && exp_seg != text_section
	   && exp_seg != data_section
	   && exp_seg != bss_section
	   && exp_seg != undefined_section
	   && !bfd_is_com_section (exp_seg))
    {
      as_bad (_("unimplemented segment %s in operand"), exp_seg->name);
      return 0;
    }
#endif
  else
    {
      /* This is an address.  The size of the address will be
	 determined later, depending on destination register,
	 suffix, or the default for the section.  */
      i.types[this_operand] |= Imm8 | Imm16 | Imm32 | Imm32S | Imm64;
    }

  return 1;
}

static char *i386_scale PARAMS ((char *));

static char *
i386_scale (scale)
     char *scale;
{
  offsetT val;
  char *save = input_line_pointer;

  input_line_pointer = scale;
  val = get_absolute_expression ();

  switch (val)
    {
    case 0:
    case 1:
      i.log2_scale_factor = 0;
      break;
    case 2:
      i.log2_scale_factor = 1;
      break;
    case 4:
      i.log2_scale_factor = 2;
      break;
    case 8:
      i.log2_scale_factor = 3;
      break;
    default:
      as_bad (_("expecting scale factor of 1, 2, 4, or 8: got `%s'"),
	      scale);
      input_line_pointer = save;
      return NULL;
    }
  if (i.log2_scale_factor != 0 && i.index_reg == 0)
    {
      as_warn (_("scale factor of %d without an index register"),
	       1 << i.log2_scale_factor);
#if SCALE1_WHEN_NO_INDEX
      i.log2_scale_factor = 0;
#endif
    }
  scale = input_line_pointer;
  input_line_pointer = save;
  return scale;
}

static int i386_displacement PARAMS ((char *, char *));

static int
i386_displacement (disp_start, disp_end)
     char *disp_start;
     char *disp_end;
{
  expressionS *exp;
  segT exp_seg = 0;
  char *save_input_line_pointer;
#ifndef LEX_AT
  char *gotfree_input_line;
#endif
  int bigdisp = Disp32;

  if (flag_code == CODE_64BIT)
    {
      if (i.prefix[ADDR_PREFIX] == 0)
	bigdisp = Disp64;
    }
  else if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
    bigdisp = Disp16;
  i.types[this_operand] |= bigdisp;

  exp = &disp_expressions[i.disp_operands];
  i.op[this_operand].disps = exp;
  i.disp_operands++;
  save_input_line_pointer = input_line_pointer;
  input_line_pointer = disp_start;
  END_STRING_AND_SAVE (disp_end);

#ifndef GCC_ASM_O_HACK
#define GCC_ASM_O_HACK 0
#endif
#if GCC_ASM_O_HACK
  END_STRING_AND_SAVE (disp_end + 1);
  if ((i.types[this_operand] & BaseIndex) != 0
      && displacement_string_end[-1] == '+')
    {
      /* This hack is to avoid a warning when using the "o"
	 constraint within gcc asm statements.
	 For instance:

	 #define _set_tssldt_desc(n,addr,limit,type) \
	 __asm__ __volatile__ ( \
	 "movw %w2,%0\n\t" \
	 "movw %w1,2+%0\n\t" \
	 "rorl $16,%1\n\t" \
	 "movb %b1,4+%0\n\t" \
	 "movb %4,5+%0\n\t" \
	 "movb $0,6+%0\n\t" \
	 "movb %h1,7+%0\n\t" \
	 "rorl $16,%1" \
	 : "=o"(*(n)) : "q" (addr), "ri"(limit), "i"(type))

	 This works great except that the output assembler ends
	 up looking a bit weird if it turns out that there is
	 no offset.  You end up producing code that looks like:

	 #APP
	 movw $235,(%eax)
	 movw %dx,2+(%eax)
	 rorl $16,%edx
	 movb %dl,4+(%eax)
	 movb $137,5+(%eax)
	 movb $0,6+(%eax)
	 movb %dh,7+(%eax)
	 rorl $16,%edx
	 #NO_APP

	 So here we provide the missing zero.  */

      *displacement_string_end = '0';
    }
#endif
#ifndef LEX_AT
  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL);
  if (gotfree_input_line)
    input_line_pointer = gotfree_input_line;
#endif

  exp_seg = expression (exp);

  SKIP_WHITESPACE ();
  if (*input_line_pointer)
    as_bad (_("junk `%s' after expression"), input_line_pointer);
#if GCC_ASM_O_HACK
  RESTORE_END_STRING (disp_end + 1);
#endif
  RESTORE_END_STRING (disp_end);
  input_line_pointer = save_input_line_pointer;
#ifndef LEX_AT
  if (gotfree_input_line)
    free (gotfree_input_line);
#endif

  /* We do this to make sure that the section symbol is in
     the symbol table.  We will ultimately change the relocation
     to be relative to the beginning of the section.  */
  if (i.reloc[this_operand] == BFD_RELOC_386_GOTOFF
      || i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
    {
      if (exp->X_op != O_symbol)
	{
	  as_bad (_("bad expression used with @@%s"),
		  (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL
		   ? "GOTPCREL"
		   : "GOTOFF"));
	  return 0;
	}

      if (S_IS_LOCAL (exp->X_add_symbol)
	  && S_GET_SEGMENT (exp->X_add_symbol) != undefined_section)
	section_symbol (S_GET_SEGMENT (exp->X_add_symbol));
      exp->X_op = O_subtract;
      exp->X_op_symbol = GOT_symbol;
      if (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
	i.reloc[this_operand] = BFD_RELOC_32_PCREL;
      else
	i.reloc[this_operand] = BFD_RELOC_32;
    }

  if (exp->X_op == O_absent || exp->X_op == O_big)
    {
      /* Missing or bad expr becomes absolute 0.  */
      as_bad (_("missing or invalid displacement expression `%s' taken as 0"),
	      disp_start);
      exp->X_op = O_constant;
      exp->X_add_number = 0;
      exp->X_add_symbol = (symbolS *) 0;
      exp->X_op_symbol = (symbolS *) 0;
    }

#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  if (exp->X_op != O_constant
      && OUTPUT_FLAVOR == bfd_target_aout_flavour
      && exp_seg != absolute_section
      && exp_seg != text_section
      && exp_seg != data_section
      && exp_seg != bss_section
      && exp_seg != undefined_section
      && !bfd_is_com_section (exp_seg))
    {
      as_bad (_("unimplemented segment %s in operand"), exp_seg->name);
      return 0;
    }
#endif
  else if (flag_code == CODE_64BIT)
    i.types[this_operand] |= Disp32S | Disp32;
  return 1;
}

static int i386_index_check PARAMS ((const char *));

/* Make sure the memory operand we've been dealt is valid.
   Return 1 on success, 0 on a failure.  */

static int
i386_index_check (operand_string)
     const char *operand_string;
{
  int ok;
#if INFER_ADDR_PREFIX
  int fudged = 0;

 tryprefix:
#endif
  ok = 1;
   if (flag_code == CODE_64BIT)
     {
       unsigned RegXX = (i.prefix[ADDR_PREFIX] == 0 ? Reg64 : Reg32);

       if ((i.base_reg
	    && ((i.base_reg->reg_type & RegXX) == 0)
	    && (i.base_reg->reg_type != BaseIndex
		|| i.index_reg))
	   || (i.index_reg
	       && ((i.index_reg->reg_type & (RegXX | BaseIndex))
		   != (RegXX | BaseIndex))))
	 ok = 0;
    }
  else
    {
      if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
	{
	  /* 16bit checks.  */
	  if ((i.base_reg
	       && ((i.base_reg->reg_type & (Reg16 | BaseIndex | RegRex))
		   != (Reg16 | BaseIndex)))
	      || (i.index_reg
		  && (((i.index_reg->reg_type & (Reg16 | BaseIndex))
		       != (Reg16 | BaseIndex))
		      || !(i.base_reg
			   && i.base_reg->reg_num < 6
			   && i.index_reg->reg_num >= 6
			   && i.log2_scale_factor == 0))))
	    ok = 0;
	}
      else
	{
	  /* 32bit checks.  */
	  if ((i.base_reg
	       && (i.base_reg->reg_type & (Reg32 | RegRex)) != Reg32)
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex | RegRex))
		      != (Reg32 | BaseIndex))))
	    ok = 0;
	}
    }
  if (!ok)
    {
#if INFER_ADDR_PREFIX
      if (i.prefix[ADDR_PREFIX] == 0)
	{
	  i.prefix[ADDR_PREFIX] = ADDR_PREFIX_OPCODE;
	  i.prefixes += 1;
	  /* Change the size of any displacement too.  At most one of
	     Disp16 or Disp32 is set.
	     FIXME.  There doesn't seem to be any real need for separate
	     Disp16 and Disp32 flags.  The same goes for Imm16 and Imm32.
	     Removing them would probably clean up the code quite a lot.  */
	  if (flag_code != CODE_64BIT && (i.types[this_operand] & (Disp16 | Disp32)))
	     i.types[this_operand] ^= (Disp16 | Disp32);
	  fudged = 1;
	  goto tryprefix;
	}
      if (fudged)
	as_bad (_("`%s' is not a valid base/index expression"),
		operand_string);
      else
#endif
	as_bad (_("`%s' is not a valid %s bit base/index expression"),
		operand_string,
		flag_code_names[flag_code]);
    }
  return ok;
}

/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero
   on error.  */

static int
i386_operand (operand_string)
     char *operand_string;
{
  const reg_entry *r;
  char *end_op;
  char *op_string = operand_string;

  if (is_space_char (*op_string))
    ++op_string;

  /* We check for an absolute prefix (differentiating,
     for example, 'jmp pc_relative_label' from 'jmp *absolute_label'.  */
  if (*op_string == ABSOLUTE_PREFIX)
    {
      ++op_string;
      if (is_space_char (*op_string))
	++op_string;
      i.types[this_operand] |= JumpAbsolute;
    }

  /* Check if operand is a register.  */
  if ((*op_string == REGISTER_PREFIX || allow_naked_reg)
      && (r = parse_register (op_string, &end_op)) != NULL)
    {
      /* Check for a segment override by searching for ':' after a
	 segment register.  */
      op_string = end_op;
      if (is_space_char (*op_string))
	++op_string;
      if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
	{
	  switch (r->reg_num)
	    {
	    case 0:
	      i.seg[i.mem_operands] = &es;
	      break;
	    case 1:
	      i.seg[i.mem_operands] = &cs;
	      break;
	    case 2:
	      i.seg[i.mem_operands] = &ss;
	      break;
	    case 3:
	      i.seg[i.mem_operands] = &ds;
	      break;
	    case 4:
	      i.seg[i.mem_operands] = &fs;
	      break;
	    case 5:
	      i.seg[i.mem_operands] = &gs;
	      break;
	    }

	  /* Skip the ':' and whitespace.  */
	  ++op_string;
	  if (is_space_char (*op_string))
	    ++op_string;

	  if (!is_digit_char (*op_string)
	      && !is_identifier_char (*op_string)
	      && *op_string != '('
	      && *op_string != ABSOLUTE_PREFIX)
	    {
	      as_bad (_("bad memory operand `%s'"), op_string);
	      return 0;
	    }
	  /* Handle case of %es:*foo.  */
	  if (*op_string == ABSOLUTE_PREFIX)
	    {
	      ++op_string;
	      if (is_space_char (*op_string))
		++op_string;
	      i.types[this_operand] |= JumpAbsolute;
	    }
	  goto do_memory_reference;
	}
      if (*op_string)
	{
	  as_bad (_("junk `%s' after register"), op_string);
	  return 0;
	}
      i.types[this_operand] |= r->reg_type & ~BaseIndex;
      i.op[this_operand].regs = r;
      i.reg_operands++;
    }
  else if (*op_string == REGISTER_PREFIX)
    {
      as_bad (_("bad register name `%s'"), op_string);
      return 0;
    }
  else if (*op_string == IMMEDIATE_PREFIX)
    {
      ++op_string;
      if (i.types[this_operand] & JumpAbsolute)
	{
	  as_bad (_("immediate operand illegal with absolute jump"));
	  return 0;
	}
      if (!i386_immediate (op_string))
	return 0;
    }
  else if (is_digit_char (*op_string)
	   || is_identifier_char (*op_string)
	   || *op_string == '(')
    {
      /* This is a memory reference of some sort.  */
      char *base_string;

      /* Start and end of displacement string expression (if found).  */
      char *displacement_string_start;
      char *displacement_string_end;

    do_memory_reference:
      if ((i.mem_operands == 1
	   && (current_templates->start->opcode_modifier & IsString) == 0)
	  || i.mem_operands == 2)
	{
	  as_bad (_("too many memory references for `%s'"),
		  current_templates->start->name);
	  return 0;
	}

      /* Check for base index form.  We detect the base index form by
	 looking for an ')' at the end of the operand, searching
	 for the '(' matching it, and finding a REGISTER_PREFIX or ','
	 after the '('.  */
      base_string = op_string + strlen (op_string);

      --base_string;
      if (is_space_char (*base_string))
	--base_string;

      /* If we only have a displacement, set-up for it to be parsed later.  */
      displacement_string_start = op_string;
      displacement_string_end = base_string + 1;

      if (*base_string == ')')
	{
	  char *temp_string;
	  unsigned int parens_balanced = 1;
	  /* We've already checked that the number of left & right ()'s are
	     equal, so this loop will not be infinite.  */
	  do
	    {
	      base_string--;
	      if (*base_string == ')')
		parens_balanced++;
	      if (*base_string == '(')
		parens_balanced--;
	    }
	  while (parens_balanced);

	  temp_string = base_string;

	  /* Skip past '(' and whitespace.  */
	  ++base_string;
	  if (is_space_char (*base_string))
	    ++base_string;

	  if (*base_string == ','
	      || ((*base_string == REGISTER_PREFIX || allow_naked_reg)
		  && (i.base_reg = parse_register (base_string, &end_op)) != NULL))
	    {
	      displacement_string_end = temp_string;

	      i.types[this_operand] |= BaseIndex;

	      if (i.base_reg)
		{
		  base_string = end_op;
		  if (is_space_char (*base_string))
		    ++base_string;
		}

	      /* There may be an index reg or scale factor here.  */
	      if (*base_string == ',')
		{
		  ++base_string;
		  if (is_space_char (*base_string))
		    ++base_string;

		  if ((*base_string == REGISTER_PREFIX || allow_naked_reg)
		      && (i.index_reg = parse_register (base_string, &end_op)) != NULL)
		    {
		      base_string = end_op;
		      if (is_space_char (*base_string))
			++base_string;
		      if (*base_string == ',')
			{
			  ++base_string;
			  if (is_space_char (*base_string))
			    ++base_string;
			}
		      else if (*base_string != ')')
			{
			  as_bad (_("expecting `,' or `)' after index register in `%s'"),
				  operand_string);
			  return 0;
			}
		    }
		  else if (*base_string == REGISTER_PREFIX)
		    {
		      as_bad (_("bad register name `%s'"), base_string);
		      return 0;
		    }

		  /* Check for scale factor.  */
		  if (*base_string != ')')
		    {
		      char *end_scale = i386_scale (base_string);

		      if (!end_scale)
			return 0;

		      base_string = end_scale;
		      if (is_space_char (*base_string))
			++base_string;
		      if (*base_string != ')')
			{
			  as_bad (_("expecting `)' after scale factor in `%s'"),
				  operand_string);
			  return 0;
			}
		    }
		  else if (!i.index_reg)
		    {
		      as_bad (_("expecting index register or scale factor after `,'; got '%c'"),
			      *base_string);
		      return 0;
		    }
		}
	      else if (*base_string != ')')
		{
		  as_bad (_("expecting `,' or `)' after base register in `%s'"),
			  operand_string);
		  return 0;
		}
	    }
	  else if (*base_string == REGISTER_PREFIX)
	    {
	      as_bad (_("bad register name `%s'"), base_string);
	      return 0;
	    }
	}

      /* If there's an expression beginning the operand, parse it,
	 assuming displacement_string_start and
	 displacement_string_end are meaningful.  */
      if (displacement_string_start != displacement_string_end)
	{
	  if (!i386_displacement (displacement_string_start,
				  displacement_string_end))
	    return 0;
	}

      /* Special case for (%dx) while doing input/output op.  */
      if (i.base_reg
	  && i.base_reg->reg_type == (Reg16 | InOutPortReg)
	  && i.index_reg == 0
	  && i.log2_scale_factor == 0
	  && i.seg[i.mem_operands] == 0
	  && (i.types[this_operand] & Disp) == 0)
	{
	  i.types[this_operand] = InOutPortReg;
	  return 1;
	}

      if (i386_index_check (operand_string) == 0)
	return 0;
      i.mem_operands++;
    }
  else
    {
      /* It's not a memory operand; argh!  */
      as_bad (_("invalid char %s beginning operand %d `%s'"),
	      output_invalid (*op_string),
	      this_operand + 1,
	      op_string);
      return 0;
    }
  return 1;			/* Normal return.  */
}

/* md_estimate_size_before_relax()

   Called just before relax() for rs_machine_dependent frags.  The x86
   assembler uses these frags to handle variable size jump
   instructions.

   Any symbol that is now undefined will not become defined.
   Return the correct fr_subtype in the frag.
   Return the initial "guess for variable size of frag" to caller.
   The guess is actually the growth beyond the fixed part.  Whatever
   we do to grow the fixed or variable part contributes to our
   returned value.  */

int
md_estimate_size_before_relax (fragP, segment)
     fragS *fragP;
     segT segment;
{
  /* We've already got fragP->fr_subtype right;  all we have to do is
     check for un-relaxable symbols.  On an ELF system, we can't relax
     an externally visible symbol, because it may be overridden by a
     shared library.  */
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      || (OUTPUT_FLAVOR == bfd_target_elf_flavour
	  && (S_IS_EXTERNAL (fragP->fr_symbol)
	      || S_IS_WEAK (fragP->fr_symbol)))
#endif
      )
    {
      /* Symbol is undefined in this segment, or we need to keep a
	 reloc so that weak symbols can be overridden.  */
      int size = (fragP->fr_subtype & CODE16) ? 2 : 4;
      enum bfd_reloc_code_real reloc_type;
      unsigned char *opcode;
      int old_fr_fix;

      if (fragP->fr_var != NO_RELOC)
	reloc_type = fragP->fr_var;
      else if (size == 2)
	reloc_type = BFD_RELOC_16_PCREL;
      else
	reloc_type = BFD_RELOC_32_PCREL;

      old_fr_fix = fragP->fr_fix;
      opcode = (unsigned char *) fragP->fr_opcode;

      switch (TYPE_FROM_RELAX_STATE (fragP->fr_subtype))
	{
	case UNCOND_JUMP:
	  /* Make jmp (0xeb) a (d)word displacement jump.  */
	  opcode[0] = 0xe9;
	  fragP->fr_fix += size;
	  fix_new (fragP, old_fr_fix, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
	  break;

	case COND_JUMP86:
	  if (size == 2
	      && (!no_cond_jump_promotion || fragP->fr_var != NO_RELOC))
	    {
	      /* Negate the condition, and branch past an
		 unconditional jump.  */
	      opcode[0] ^= 1;
	      opcode[1] = 3;
	      /* Insert an unconditional jump.  */
	      opcode[2] = 0xe9;
	      /* We added two extra opcode bytes, and have a two byte
		 offset.  */
	      fragP->fr_fix += 2 + 2;
	      fix_new (fragP, old_fr_fix + 2, 2,
		       fragP->fr_symbol,
		       fragP->fr_offset, 1,
		       reloc_type);
	      break;
	    }
	  /* Fall through.  */

	case COND_JUMP:
	  if (no_cond_jump_promotion && fragP->fr_var == NO_RELOC)
	    {
	      fixS *fixP;

	      fragP->fr_fix += 1;
	      fixP = fix_new (fragP, old_fr_fix, 1,
			      fragP->fr_symbol,
			      fragP->fr_offset, 1,
			      BFD_RELOC_8_PCREL);
	      fixP->fx_signed = 1;
	      break;
	    }

	  /* This changes the byte-displacement jump 0x7N
	     to the (d)word-displacement jump 0x0f,0x8N.  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  /* We've added an opcode byte.  */
	  fragP->fr_fix += 1 + size;
	  fix_new (fragP, old_fr_fix + 1, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
	  break;

	default:
	  BAD_CASE (fragP->fr_subtype);
	  break;
	}
      frag_wane (fragP);
      return fragP->fr_fix - old_fr_fix;
    }

  /* Guess size depending on current relax state.  Initially the relax
     state will correspond to a short jump and we return 1, because
     the variable part of the frag (the branch offset) is one byte
     long.  However, we can relax a section more than once and in that
     case we must either set fr_subtype back to the unrelaxed state,
     or return the value for the appropriate branch.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* Called after relax() is finished.

   In:	Address of frag.
	fr_type == rs_machine_dependent.
	fr_subtype is what the address relaxed to.

   Out:	Any fixSs and constants are set up.
	Caller will turn frag into a ".space 0".  */

void
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
{
  unsigned char *opcode;
  unsigned char *where_to_put_displacement = NULL;
  offsetT target_address;
  offsetT opcode_address;
  unsigned int extension = 0;
  offsetT displacement_from_opcode_start;

  opcode = (unsigned char *) fragP->fr_opcode;

  /* Address we want to reach in file space.  */
  target_address = S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset;

  /* Address opcode resides at in file space.  */
  opcode_address = fragP->fr_address + fragP->fr_fix;

  /* Displacement from opcode start to fill into instruction.  */
  displacement_from_opcode_start = target_address - opcode_address;

  if ((fragP->fr_subtype & BIG) == 0)
    {
      /* Don't have to change opcode.  */
      extension = 1;		/* 1 opcode + 1 displacement  */
      where_to_put_displacement = &opcode[1];
    }
  else
    {
      if (no_cond_jump_promotion
	  && TYPE_FROM_RELAX_STATE (fragP->fr_subtype) != UNCOND_JUMP)
	as_warn_where (fragP->fr_file, fragP->fr_line, _("long jump required"));

      switch (fragP->fr_subtype)
	{
	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG):
	  extension = 4;		/* 1 opcode + 4 displacement  */
	  opcode[0] = 0xe9;
	  where_to_put_displacement = &opcode[1];
	  break;

	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16):
	  extension = 2;		/* 1 opcode + 2 displacement  */
	  opcode[0] = 0xe9;
	  where_to_put_displacement = &opcode[1];
	  break;

	case ENCODE_RELAX_STATE (COND_JUMP, BIG):
	case ENCODE_RELAX_STATE (COND_JUMP86, BIG):
	  extension = 5;		/* 2 opcode + 4 displacement  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  where_to_put_displacement = &opcode[2];
	  break;

	case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
	  extension = 3;		/* 2 opcode + 2 displacement  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  where_to_put_displacement = &opcode[2];
	  break;

	case ENCODE_RELAX_STATE (COND_JUMP86, BIG16):
	  extension = 4;
	  opcode[0] ^= 1;
	  opcode[1] = 3;
	  opcode[2] = 0xe9;
	  where_to_put_displacement = &opcode[3];
	  break;

	default:
	  BAD_CASE (fragP->fr_subtype);
	  break;
	}
    }

  /* Now put displacement after opcode.  */
  md_number_to_chars ((char *) where_to_put_displacement,
		      (valueT) (displacement_from_opcode_start - extension),
		      DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
  fragP->fr_fix += extension;
}

/* Size of byte displacement jmp.  */
int md_short_jump_size = 2;

/* Size of dword displacement jmp.  */
int md_long_jump_size = 5;

/* Size of relocation record.  */
const int md_reloc_size = 8;

void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
{
  offsetT offset;

  offset = to_addr - (from_addr + 2);
  /* Opcode for byte-disp jump.  */
  md_number_to_chars (ptr, (valueT) 0xeb, 1);
  md_number_to_chars (ptr + 1, (valueT) offset, 1);
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
{
  offsetT offset;

  offset = to_addr - (from_addr + 5);
  md_number_to_chars (ptr, (valueT) 0xe9, 1);
  md_number_to_chars (ptr + 1, (valueT) offset, 4);
}

/* Apply a fixup (fixS) to segment data, once it has been determined
   by our caller that we have all the info we need to fix it up.

   On the 386, immediates, displacements, and data pointers are all in
   the same (little-endian) format, so we don't need to care about which
   we are handling.  */

void
md_apply_fix3 (fixP, valP, seg)
     /* The fix we're to put in.  */
     fixS *fixP;
     /* Pointer to the value of the bits.  */
     valueT *valP;
     /* Segment fix is from.  */
     segT seg ATTRIBUTE_UNUSED;
{
  char *p = fixP->fx_where + fixP->fx_frag->fr_literal;
  valueT value = *valP;

#if !defined (TE_Mach)
  if (fixP->fx_pcrel)
    {
      switch (fixP->fx_r_type)
	{
	default:
	  break;

	case BFD_RELOC_32:
	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  break;
	case BFD_RELOC_16:
	  fixP->fx_r_type = BFD_RELOC_16_PCREL;
	  break;
	case BFD_RELOC_8:
	  fixP->fx_r_type = BFD_RELOC_8_PCREL;
	  break;
	}
    }

  if (fixP->fx_addsy != NULL
      && (fixP->fx_r_type == BFD_RELOC_32_PCREL
	  || fixP->fx_r_type == BFD_RELOC_16_PCREL
	  || fixP->fx_r_type == BFD_RELOC_8_PCREL)
      && !use_rela_relocations)
    {
      /* This is a hack.  There should be a better way to handle this.
	 This covers for the fact that bfd_install_relocation will
	 subtract the current location (for partial_inplace, PC relative
	 relocations); see more below.  */
#ifndef OBJ_AOUT
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour
#ifdef TE_PE
	  || OUTPUT_FLAVOR == bfd_target_coff_flavour
#endif
	  )
	value += fixP->fx_where + fixP->fx_frag->fr_address;
#endif
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
	{
	  segT sym_seg = S_GET_SEGMENT (fixP->fx_addsy);

	  if ((sym_seg == seg
	       || (symbol_section_p (fixP->fx_addsy)
		   && sym_seg != absolute_section))
	      && !generic_force_reloc (fixP))
	    {
	      /* Yes, we add the values in twice.  This is because
		 bfd_install_relocation subtracts them out again.  I think
		 bfd_install_relocation is broken, but I don't dare change
		 it.  FIXME.  */
	      value += fixP->fx_where + fixP->fx_frag->fr_address;
	    }
	}
#endif
#if defined (OBJ_COFF) && defined (TE_PE)
      /* For some reason, the PE format does not store a section
	 address offset for a PC relative symbol.  */
      if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
#endif
    }

  /* Fix a few things - the dynamic linker expects certain values here,
     and we must not disappoint it.  */
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
      && fixP->fx_addsy)
    switch (fixP->fx_r_type)
      {
      case BFD_RELOC_386_PLT32:
      case BFD_RELOC_X86_64_PLT32:
	/* Make the jump instruction point to the address of the operand.  At
	   runtime we merely add the offset to the actual PLT entry.  */
	value = -4;
	break;

      case BFD_RELOC_386_TLS_GD:
      case BFD_RELOC_386_TLS_LDM:
      case BFD_RELOC_386_TLS_IE_32:
      case BFD_RELOC_386_TLS_IE:
      case BFD_RELOC_386_TLS_GOTIE:
      case BFD_RELOC_X86_64_TLSGD:
      case BFD_RELOC_X86_64_TLSLD:
      case BFD_RELOC_X86_64_GOTTPOFF:
	value = 0; /* Fully resolved at runtime.  No addend.  */
	/* Fallthrough */
      case BFD_RELOC_386_TLS_LE:
      case BFD_RELOC_386_TLS_LDO_32:
      case BFD_RELOC_386_TLS_LE_32:
      case BFD_RELOC_X86_64_DTPOFF32:
      case BFD_RELOC_X86_64_TPOFF32:
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
	break;

      case BFD_RELOC_386_GOT32:
      case BFD_RELOC_X86_64_GOT32:
	value = 0; /* Fully resolved at runtime.  No addend.  */
	break;

      case BFD_RELOC_VTABLE_INHERIT:
      case BFD_RELOC_VTABLE_ENTRY:
	fixP->fx_done = 0;
	return;

      default:
	break;
      }
#endif /* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)  */
  *valP = value;
#endif /* !defined (TE_Mach)  */

  /* Are we finished with this relocation now?  */
  if (fixP->fx_addsy == NULL)
    fixP->fx_done = 1;
  else if (use_rela_relocations)
    {
      fixP->fx_no_overflow = 1;
      /* Remember value for tc_gen_reloc.  */
      fixP->fx_addnumber = value;
      value = 0;
    }

  md_number_to_chars (p, value, fixP->fx_size);
}

#define MAX_LITTLENUMS 6

/* Turn the string pointed to by litP into a floating point constant
   of type TYPE, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
      prec = 2;
      break;

    case 'd':
    case 'D':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 5;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to md_atof ()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  /* This loops outputs the LITTLENUMs in REVERSE order; in accord with
     the bigendian 386.  */
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

char output_invalid_buf[8];

static char *
output_invalid (c)
     int c;
{
  if (ISPRINT (c))
    sprintf (output_invalid_buf, "'%c'", c);
  else
    sprintf (output_invalid_buf, "(0x%x)", (unsigned) c);
  return output_invalid_buf;
}

/* REG_STRING starts *before* REGISTER_PREFIX.  */

static const reg_entry *
parse_register (reg_string, end_op)
     char *reg_string;
     char **end_op;
{
  char *s = reg_string;
  char *p;
  char reg_name_given[MAX_REG_NAME_SIZE + 1];
  const reg_entry *r;

  /* Skip possible REGISTER_PREFIX and possible whitespace.  */
  if (*s == REGISTER_PREFIX)
    ++s;

  if (is_space_char (*s))
    ++s;

  p = reg_name_given;
  while ((*p++ = register_chars[(unsigned char) *s]) != '\0')
    {
      if (p >= reg_name_given + MAX_REG_NAME_SIZE)
	return (const reg_entry *) NULL;
      s++;
    }

  /* For naked regs, make sure that we are not dealing with an identifier.
     This prevents confusing an identifier like `eax_var' with register
     `eax'.  */
  if (allow_naked_reg && identifier_chars[(unsigned char) *s])
    return (const reg_entry *) NULL;

  *end_op = s;

  r = (const reg_entry *) hash_find (reg_hash, reg_name_given);

  /* Handle floating point regs, allowing spaces in the (i) part.  */
  if (r == i386_regtab /* %st is first entry of table  */)
    {
      if (is_space_char (*s))
	++s;
      if (*s == '(')
	{
	  ++s;
	  if (is_space_char (*s))
	    ++s;
	  if (*s >= '0' && *s <= '7')
	    {
	      r = &i386_float_regtab[*s - '0'];
	      ++s;
	      if (is_space_char (*s))
		++s;
	      if (*s == ')')
		{
		  *end_op = s + 1;
		  return r;
		}
	    }
	  /* We have "%st(" then garbage.  */
	  return (const reg_entry *) NULL;
	}
    }

  if (r != NULL
      && ((r->reg_flags & (RegRex64 | RegRex)) | (r->reg_type & Reg64)) != 0
      && flag_code != CODE_64BIT)
    return (const reg_entry *) NULL;

  return r;
}

#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
const char *md_shortopts = "kVQ:sqn";
#else
const char *md_shortopts = "qn";
#endif

struct option md_longopts[] = {
#define OPTION_32 (OPTION_MD_BASE + 0)
  {"32", no_argument, NULL, OPTION_32},
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
#define OPTION_64 (OPTION_MD_BASE + 1)
  {"64", no_argument, NULL, OPTION_64},
#endif
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
{
  switch (c)
    {
    case 'n':
      optimize_align_code = 0;
      break;

    case 'q':
      quiet_warnings = 1;
      break;

#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

      /* -V: SVR4 argument to print version ID.  */
    case 'V':
      print_version_id ();
      break;

      /* -k: Ignore for FreeBSD compatibility.  */
    case 'k':
      break;

    case 's':
      /* -s: On i386 Solaris, this tells the native assembler to use
	 .stab instead of .stab.excl.  We always use .stab anyhow.  */
      break;

    case OPTION_64:
      {
	const char **list, **l;

	list = bfd_target_list ();
	for (l = list; *l != NULL; l++)
	  if (strcmp (*l, "elf64-x86-64") == 0)
	    {
	      default_arch = "x86_64";
	      break;
	    }
	if (*l == NULL)
	  as_fatal (_("No compiled in support for x86_64"));
	free (list);
      }
      break;
#endif

    case OPTION_32:
      default_arch = "i386";
      break;

    default:
      return 0;
    }
  return 1;
}

void
md_show_usage (stream)
     FILE *stream;
{
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  fprintf (stream, _("\
  -Q                      ignored\n\
  -V                      print assembler version number\n\
  -k                      ignored\n\
  -n                      Do not optimize code alignment\n\
  -q                      quieten some warnings\n\
  -s                      ignored\n"));
#else
  fprintf (stream, _("\
  -n                      Do not optimize code alignment\n\
  -q                      quieten some warnings\n"));
#endif
}

#if ((defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)) \
     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))

/* Pick the target format to use.  */

const char *
i386_target_format ()
{
  if (!strcmp (default_arch, "x86_64"))
    set_code_flag (CODE_64BIT);
  else if (!strcmp (default_arch, "i386"))
    set_code_flag (CODE_32BIT);
  else
    as_fatal (_("Unknown architecture"));
  switch (OUTPUT_FLAVOR)
    {
#ifdef OBJ_MAYBE_AOUT
    case bfd_target_aout_flavour:
      return AOUT_TARGET_FORMAT;
#endif
#ifdef OBJ_MAYBE_COFF
    case bfd_target_coff_flavour:
      return "coff-i386";
#endif
#if defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF)
    case bfd_target_elf_flavour:
      {
	if (flag_code == CODE_64BIT)
	  use_rela_relocations = 1;
	return flag_code == CODE_64BIT ? "elf64-x86-64" : ELF_TARGET_FORMAT;
      }
#endif
    default:
      abort ();
      return NULL;
    }
}

#endif /* OBJ_MAYBE_ more than one  */

#if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))
void i386_elf_emit_arch_note ()
{
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
      && cpu_arch_name != NULL)
    {
      char *p;
      asection *seg = now_seg;
      subsegT subseg = now_subseg;
      Elf_Internal_Note i_note;
      Elf_External_Note e_note;
      asection *note_secp;
      int len;

      /* Create the .note section.  */
      note_secp = subseg_new (".note", 0);
      bfd_set_section_flags (stdoutput,
			     note_secp,
			     SEC_HAS_CONTENTS | SEC_READONLY);

      /* Process the arch string.  */
      len = strlen (cpu_arch_name);

      i_note.namesz = len + 1;
      i_note.descsz = 0;
      i_note.type = NT_ARCH;
      p = frag_more (sizeof (e_note.namesz));
      md_number_to_chars (p, (valueT) i_note.namesz, sizeof (e_note.namesz));
      p = frag_more (sizeof (e_note.descsz));
      md_number_to_chars (p, (valueT) i_note.descsz, sizeof (e_note.descsz));
      p = frag_more (sizeof (e_note.type));
      md_number_to_chars (p, (valueT) i_note.type, sizeof (e_note.type));
      p = frag_more (len + 1);
      strcpy (p, cpu_arch_name);

      frag_align (2, 0, 0);

      subseg_set (seg, subseg);
    }
}
#endif

symbolS *
md_undefined_symbol (name)
     char *name;
{
  if (name[0] == GLOBAL_OFFSET_TABLE_NAME[0]
      && name[1] == GLOBAL_OFFSET_TABLE_NAME[1]
      && name[2] == GLOBAL_OFFSET_TABLE_NAME[2]
      && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad (_("GOT already in symbol table"));
	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, &zero_address_frag);
	};
      return GOT_symbol;
    }
  return 0;
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
{
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
    {
      /* For a.out, force the section size to be aligned.  If we don't do
	 this, BFD will align it for us, but it will not write out the
	 final bytes of the section.  This may be a bug in BFD, but it is
	 easier to fix it here since that is how the other a.out targets
	 work.  */
      int align;

      align = bfd_get_section_alignment (stdoutput, segment);
      size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
    }
#endif

  return size;
}

/* On the i386, PC-relative offsets are relative to the start of the
   next instruction.  That is, the address of the offset, plus its
   size, since the offset is always the last part of the insn.  */

long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

#ifndef I386COFF

static void
s_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int temp;

  temp = get_absolute_expression ();
  subseg_set (bss_section, (subsegT) temp);
  demand_empty_rest_of_line ();
}

#endif

void
i386_validate_fix (fixp)
     fixS *fixp;
{
  if (fixp->fx_subsy && fixp->fx_subsy == GOT_symbol)
    {
      /* GOTOFF relocation are nonsense in 64bit mode.  */
      if (fixp->fx_r_type == BFD_RELOC_32_PCREL)
	{
	  if (flag_code != CODE_64BIT)
	    abort ();
	  fixp->fx_r_type = BFD_RELOC_X86_64_GOTPCREL;
	}
      else
	{
	  if (flag_code == CODE_64BIT)
	    abort ();
	  fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
	}
      fixp->fx_subsy = 0;
    }
}

arelent *
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *rel;
  bfd_reloc_code_real_type code;

  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_X86_64_PLT32:
    case BFD_RELOC_X86_64_GOT32:
    case BFD_RELOC_X86_64_GOTPCREL:
    case BFD_RELOC_386_PLT32:
    case BFD_RELOC_386_GOT32:
    case BFD_RELOC_386_GOTOFF:
    case BFD_RELOC_386_GOTPC:
    case BFD_RELOC_386_TLS_GD:
    case BFD_RELOC_386_TLS_LDM:
    case BFD_RELOC_386_TLS_LDO_32:
    case BFD_RELOC_386_TLS_IE_32:
    case BFD_RELOC_386_TLS_IE:
    case BFD_RELOC_386_TLS_GOTIE:
    case BFD_RELOC_386_TLS_LE_32:
    case BFD_RELOC_386_TLS_LE:
    case BFD_RELOC_X86_64_32S:
    case BFD_RELOC_X86_64_TLSGD:
    case BFD_RELOC_X86_64_TLSLD:
    case BFD_RELOC_X86_64_DTPOFF32:
    case BFD_RELOC_X86_64_GOTTPOFF:
    case BFD_RELOC_X86_64_TPOFF32:
    case BFD_RELOC_RVA:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      code = fixp->fx_r_type;
      break;
    default:
      if (fixp->fx_pcrel)
	{
	  switch (fixp->fx_size)
	    {
	    default:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("can not do %d byte pc-relative relocation"),
			    fixp->fx_size);
	      code = BFD_RELOC_32_PCREL;
	      break;
	    case 1: code = BFD_RELOC_8_PCREL;  break;
	    case 2: code = BFD_RELOC_16_PCREL; break;
	    case 4: code = BFD_RELOC_32_PCREL; break;
	    }
	}
      else
	{
	  switch (fixp->fx_size)
	    {
	    default:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("can not do %d byte relocation"),
			    fixp->fx_size);
	      code = BFD_RELOC_32;
	      break;
	    case 1: code = BFD_RELOC_8;  break;
	    case 2: code = BFD_RELOC_16; break;
	    case 4: code = BFD_RELOC_32; break;
#ifdef BFD64
	    case 8: code = BFD_RELOC_64; break;
#endif
	    }
	}
      break;
    }

  if (code == BFD_RELOC_32
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      /* We don't support GOTPC on 64bit targets.  */
      if (flag_code == CODE_64BIT)
	abort ();
      code = BFD_RELOC_386_GOTPC;
    }

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);

  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  if (!use_rela_relocations)
    {
      /* HACK: Since i386 ELF uses Rel instead of Rela, encode the
	 vtable entry to be used in the relocation's section offset.  */
      if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
	rel->address = fixp->fx_offset;

      rel->addend = 0;
    }
  /* Use the rela in 64bit mode.  */
  else
    {
      if (!fixp->fx_pcrel)
	rel->addend = fixp->fx_offset;
      else
	switch (code)
	  {
	  case BFD_RELOC_X86_64_PLT32:
	  case BFD_RELOC_X86_64_GOT32:
	  case BFD_RELOC_X86_64_GOTPCREL:
	  case BFD_RELOC_X86_64_TLSGD:
	  case BFD_RELOC_X86_64_TLSLD:
	  case BFD_RELOC_X86_64_GOTTPOFF:
	    rel->addend = fixp->fx_offset - fixp->fx_size;
	    break;
	  default:
	    rel->addend = (section->vma
			   - fixp->fx_size
			   + fixp->fx_addnumber
			   + md_pcrel_from (fixp));
	    break;
	  }
    }

  rel->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (code));
      /* Set howto to a garbage value so that we can keep going.  */
      rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
      assert (rel->howto != NULL);
    }

  return rel;
}


/* Parse operands using Intel syntax. This implements a recursive descent
   parser based on the BNF grammar published in Appendix B of the MASM 6.1
   Programmer's Guide.

   FIXME: We do not recognize the full operand grammar defined in the MASM
	  documentation.  In particular, all the structure/union and
	  high-level macro operands are missing.

   Uppercase words are terminals, lower case words are non-terminals.
   Objects surrounded by double brackets '[[' ']]' are optional. Vertical
   bars '|' denote choices. Most grammar productions are implemented in
   functions called 'intel_<production>'.

   Initial production is 'expr'.

    addOp		+ | -

    alpha		[a-zA-Z]

    byteRegister	AL | AH | BL | BH | CL | CH | DL | DH

    constant		digits [[ radixOverride ]]

    dataType		BYTE | WORD | DWORD | QWORD | XWORD

    digits		decdigit
			| digits decdigit
			| digits hexdigit

    decdigit		[0-9]

    e05			e05 addOp e06
			| e06

    e06			e06 mulOp e09
			| e09

    e09			OFFSET e10
			| e09 PTR e10
			| e09 : e10
			| e10

    e10			e10 [ expr ]
			| e11

    e11			( expr )
			| [ expr ]
			| constant
			| dataType
			| id
			| $
			| register

 => expr		SHORT e05
			| e05

    gpRegister		AX | EAX | BX | EBX | CX | ECX | DX | EDX
			| BP | EBP | SP | ESP | DI | EDI | SI | ESI

    hexdigit		a | b | c | d | e | f
			| A | B | C | D | E | F

    id			alpha
			| id alpha
			| id decdigit

    mulOp		* | / | MOD

    quote		" | '

    register		specialRegister
			| gpRegister
			| byteRegister

    segmentRegister	CS | DS | ES | FS | GS | SS

    specialRegister	CR0 | CR2 | CR3
			| DR0 | DR1 | DR2 | DR3 | DR6 | DR7
			| TR3 | TR4 | TR5 | TR6 | TR7

    We simplify the grammar in obvious places (e.g., register parsing is
    done by calling parse_register) and eliminate immediate left recursion
    to implement a recursive-descent parser.

    expr	SHORT e05
		| e05

    e05		e06 e05'

    e05'	addOp e06 e05'
		| Empty

    e06		e09 e06'

    e06'	mulOp e09 e06'
		| Empty

    e09		OFFSET e10 e09'
		| e10 e09'

    e09'	PTR e10 e09'
		| : e10 e09'
		| Empty

    e10		e11 e10'

    e10'	[ expr ] e10'
		| Empty

    e11		( expr )
		| [ expr ]
		| BYTE
		| WORD
		| DWORD
		| QWORD
		| XWORD
		| .
		| $
		| register
		| id
		| constant  */

/* Parsing structure for the intel syntax parser. Used to implement the
   semantic actions for the operand grammar.  */
struct intel_parser_s
  {
    char *op_string;		/* The string being parsed.  */
    int got_a_float;		/* Whether the operand is a float.  */
    int op_modifier;		/* Operand modifier.  */
    int is_mem;			/* 1 if operand is memory reference.  */
    const reg_entry *reg;	/* Last register reference found.  */
    char *disp;			/* Displacement string being built.  */
  };

static struct intel_parser_s intel_parser;

/* Token structure for parsing intel syntax.  */
struct intel_token
  {
    int code;			/* Token code.  */
    const reg_entry *reg;	/* Register entry for register tokens.  */
    char *str;			/* String representation.  */
  };

static struct intel_token cur_token, prev_token;

/* Token codes for the intel parser. Since T_SHORT is already used
   by COFF, undefine it first to prevent a warning.  */
#define T_NIL		-1
#define T_CONST		1
#define T_REG		2
#define T_BYTE		3
#define T_WORD		4
#define	T_DWORD		5
#define T_QWORD		6
#define T_XWORD		7
#undef  T_SHORT
#define T_SHORT		8
#define T_OFFSET	9
#define T_PTR		10
#define T_ID		11

/* Prototypes for intel parser functions.  */
static int intel_match_token	PARAMS ((int code));
static void intel_get_token	PARAMS ((void));
static void intel_putback_token	PARAMS ((void));
static int intel_expr		PARAMS ((void));
static int intel_e05		PARAMS ((void));
static int intel_e05_1		PARAMS ((void));
static int intel_e06		PARAMS ((void));
static int intel_e06_1		PARAMS ((void));
static int intel_e09		PARAMS ((void));
static int intel_e09_1		PARAMS ((void));
static int intel_e10		PARAMS ((void));
static int intel_e10_1		PARAMS ((void));
static int intel_e11		PARAMS ((void));

static int
i386_intel_operand (operand_string, got_a_float)
     char *operand_string;
     int got_a_float;
{
  int ret;
  char *p;

  /* Initialize token holders.  */
  cur_token.code = prev_token.code = T_NIL;
  cur_token.reg = prev_token.reg = NULL;
  cur_token.str = prev_token.str = NULL;

  /* Initialize parser structure.  */
  p = intel_parser.op_string = (char *) malloc (strlen (operand_string) + 1);
  if (p == NULL)
    abort ();
  strcpy (intel_parser.op_string, operand_string);
  intel_parser.got_a_float = got_a_float;
  intel_parser.op_modifier = -1;
  intel_parser.is_mem = 0;
  intel_parser.reg = NULL;
  intel_parser.disp = (char *) malloc (strlen (operand_string) + 1);
  if (intel_parser.disp == NULL)
    abort ();
  intel_parser.disp[0] = '\0';

  /* Read the first token and start the parser.  */
  intel_get_token ();
  ret = intel_expr ();

  if (ret)
    {
      /* If we found a memory reference, hand it over to i386_displacement
	 to fill in the rest of the operand fields.  */
      if (intel_parser.is_mem)
	{
	  if ((i.mem_operands == 1
	       && (current_templates->start->opcode_modifier & IsString) == 0)
	      || i.mem_operands == 2)
	    {
	      as_bad (_("too many memory references for '%s'"),
		      current_templates->start->name);
	      ret = 0;
	    }
	  else
	    {
	      char *s = intel_parser.disp;
	      i.mem_operands++;

	      /* Add the displacement expression.  */
	      if (*s != '\0')
		ret = i386_displacement (s, s + strlen (s));
	      if (ret)
		ret = i386_index_check (operand_string);
	    }
	}

      /* Constant and OFFSET expressions are handled by i386_immediate.  */
      else if (intel_parser.op_modifier == OFFSET_FLAT
	       || intel_parser.reg == NULL)
	ret = i386_immediate (intel_parser.disp);
    }

  free (p);
  free (intel_parser.disp);

  return ret;
}

/* expr	SHORT e05
	| e05  */
static int
intel_expr ()
{
  /* expr  SHORT e05  */
  if (cur_token.code == T_SHORT)
    {
      intel_parser.op_modifier = SHORT;
      intel_match_token (T_SHORT);

      return (intel_e05 ());
    }

  /* expr  e05  */
  else
    return intel_e05 ();
}

/* e05	e06 e05'

   e05'	addOp e06 e05'
	| Empty  */
static int
intel_e05 ()
{
  return (intel_e06 () && intel_e05_1 ());
}

static int
intel_e05_1 ()
{
  /* e05'  addOp e06 e05'  */
  if (cur_token.code == '+' || cur_token.code == '-')
    {
      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (cur_token.code);

      return (intel_e06 () && intel_e05_1 ());
    }

  /* e05'  Empty  */
  else
    return 1;
}

/* e06	e09 e06'

   e06'	mulOp e09 e06'
	| Empty  */
static int
intel_e06 ()
{
  return (intel_e09 () && intel_e06_1 ());
}

static int
intel_e06_1 ()
{
  /* e06'  mulOp e09 e06'  */
  if (cur_token.code == '*' || cur_token.code == '/')
    {
      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (cur_token.code);

      return (intel_e09 () && intel_e06_1 ());
    }

  /* e06'  Empty  */
  else
    return 1;
}

/* e09	OFFSET e10 e09'
	| e10 e09'

   e09'	PTR e10 e09'
	| : e10 e09'
	| Empty */
static int
intel_e09 ()
{
  /* e09  OFFSET e10 e09'  */
  if (cur_token.code == T_OFFSET)
    {
      intel_parser.is_mem = 0;
      intel_parser.op_modifier = OFFSET_FLAT;
      intel_match_token (T_OFFSET);

      return (intel_e10 () && intel_e09_1 ());
    }

  /* e09  e10 e09'  */
  else
    return (intel_e10 () && intel_e09_1 ());
}

static int
intel_e09_1 ()
{
  /* e09'  PTR e10 e09' */
  if (cur_token.code == T_PTR)
    {
      if (prev_token.code == T_BYTE)
	i.suffix = BYTE_MNEM_SUFFIX;

      else if (prev_token.code == T_WORD)
	{
	  if (intel_parser.got_a_float == 2)	/* "fi..." */
	    i.suffix = SHORT_MNEM_SUFFIX;
	  else
	    i.suffix = WORD_MNEM_SUFFIX;
	}

      else if (prev_token.code == T_DWORD)
	{
	  if (intel_parser.got_a_float == 1)	/* "f..." */
	    i.suffix = SHORT_MNEM_SUFFIX;
	  else
	    i.suffix = LONG_MNEM_SUFFIX;
	}

      else if (prev_token.code == T_QWORD)
	{
	  if (intel_parser.got_a_float == 1)	/* "f..." */
	    i.suffix = LONG_MNEM_SUFFIX;
	  else
	    i.suffix = QWORD_MNEM_SUFFIX;
	}

      else if (prev_token.code == T_XWORD)
	i.suffix = LONG_DOUBLE_MNEM_SUFFIX;

      else
	{
	  as_bad (_("Unknown operand modifier `%s'\n"), prev_token.str);
	  return 0;
	}

      intel_match_token (T_PTR);

      return (intel_e10 () && intel_e09_1 ());
    }

  /* e09  : e10 e09'  */
  else if (cur_token.code == ':')
    {
      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;

      return (intel_match_token (':') && intel_e10 () && intel_e09_1 ());
    }

  /* e09'  Empty  */
  else
    return 1;
}

/* e10	e11 e10'

   e10'	[ expr ] e10'
	| Empty  */
static int
intel_e10 ()
{
  return (intel_e11 () && intel_e10_1 ());
}

static int
intel_e10_1 ()
{
  /* e10'  [ expr ]  e10'  */
  if (cur_token.code == '[')
    {
      intel_match_token ('[');

      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  If it's an offset expression, we need to keep
	 the brace in.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;
      else
	strcat (intel_parser.disp, "[");

      /* Add a '+' to the displacement string if necessary.  */
      if (*intel_parser.disp != '\0'
	  && *(intel_parser.disp + strlen (intel_parser.disp) - 1) != '+')
	strcat (intel_parser.disp, "+");

      if (intel_expr () && intel_match_token (']'))
	{
	  /* Preserve brackets when the operand is an offset expression.  */
	  if (intel_parser.op_modifier == OFFSET_FLAT)
	    strcat (intel_parser.disp, "]");

	  return intel_e10_1 ();
	}
      else
	return 0;
    }

  /* e10'  Empty  */
  else
    return 1;
}

/* e11	( expr )
	| [ expr ]
	| BYTE
	| WORD
	| DWORD
	| QWORD
	| XWORD
	| $
	| .
	| register
	| id
	| constant  */
static int
intel_e11 ()
{
  /* e11  ( expr ) */
  if (cur_token.code == '(')
    {
      intel_match_token ('(');
      strcat (intel_parser.disp, "(");

      if (intel_expr () && intel_match_token (')'))
	{
	  strcat (intel_parser.disp, ")");
	  return 1;
	}
      else
	return 0;
    }

  /* e11  [ expr ] */
  else if (cur_token.code == '[')
    {
      intel_match_token ('[');

      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  If it's an offset expression, we need to keep
	 the brace in.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;
      else
	strcat (intel_parser.disp, "[");

      /* Operands for jump/call inside brackets denote absolute addresses.  */
      if (current_templates->start->opcode_modifier & Jump
	  || current_templates->start->opcode_modifier & JumpDword
	  || current_templates->start->opcode_modifier & JumpByte
	  || current_templates->start->opcode_modifier & JumpInterSegment)
	i.types[this_operand] |= JumpAbsolute;

      /* Add a '+' to the displacement string if necessary.  */
      if (*intel_parser.disp != '\0'
	  && *(intel_parser.disp + strlen (intel_parser.disp) - 1) != '+')
	strcat (intel_parser.disp, "+");

      if (intel_expr () && intel_match_token (']'))
	{
	  /* Preserve brackets when the operand is an offset expression.  */
	  if (intel_parser.op_modifier == OFFSET_FLAT)
	    strcat (intel_parser.disp, "]");

	  return 1;
	}
      else
	return 0;
    }

  /* e11  BYTE
	  | WORD
	  | DWORD
	  | QWORD
	  | XWORD  */
  else if (cur_token.code == T_BYTE
	   || cur_token.code == T_WORD
	   || cur_token.code == T_DWORD
	   || cur_token.code == T_QWORD
	   || cur_token.code == T_XWORD)
    {
      intel_match_token (cur_token.code);

      return 1;
    }

  /* e11  $
	  | .  */
  else if (cur_token.code == '$' || cur_token.code == '.')
    {
      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (cur_token.code);

      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;

      return 1;
    }

  /* e11  register  */
  else if (cur_token.code == T_REG)
    {
      const reg_entry *reg = intel_parser.reg = cur_token.reg;

      intel_match_token (T_REG);

      /* Check for segment change.  */
      if (cur_token.code == ':')
	{
	  if (reg->reg_type & (SReg2 | SReg3))
	    {
	      switch (reg->reg_num)
		{
		case 0:
		  i.seg[i.mem_operands] = &es;
		  break;
		case 1:
		  i.seg[i.mem_operands] = &cs;
		  break;
		case 2:
		  i.seg[i.mem_operands] = &ss;
		  break;
		case 3:
		  i.seg[i.mem_operands] = &ds;
		  break;
		case 4:
		  i.seg[i.mem_operands] = &fs;
		  break;
		case 5:
		  i.seg[i.mem_operands] = &gs;
		  break;
		}
	    }
	  else
	    {
	      as_bad (_("`%s' is not a valid segment register"), reg->reg_name);
	      return 0;
	    }
	}

      /* Not a segment register. Check for register scaling.  */
      else if (cur_token.code == '*')
	{
	  if (!intel_parser.is_mem)
	    {
	      as_bad (_("Register scaling only allowed in memory operands."));
	      return 0;
	    }

	  /* What follows must be a valid scale.  */
	  if (intel_match_token ('*')
	      && strchr ("01248", *cur_token.str))
	    {
	      i.index_reg = reg;
	      i.types[this_operand] |= BaseIndex;

	      /* Set the scale after setting the register (otherwise,
		 i386_scale will complain)  */
	      i386_scale (cur_token.str);
	      intel_match_token (T_CONST);
	    }
	  else
	    {
	      as_bad (_("expecting scale factor of 1, 2, 4, or 8: got `%s'"),
		      cur_token.str);
	      return 0;
	    }
	}

      /* No scaling. If this is a memory operand, the register is either a
	 base register (first occurrence) or an index register (second
	 occurrence).  */
      else if (intel_parser.is_mem && !(reg->reg_type & (SReg2 | SReg3)))
	{
	  if (i.base_reg && i.index_reg)
	    {
	      as_bad (_("Too many register references in memory operand.\n"));
	      return 0;
	    }

	  if (i.base_reg == NULL)
	    i.base_reg = reg;
	  else
	    i.index_reg = reg;

	  i.types[this_operand] |= BaseIndex;
	}

      /* Offset modifier. Add the register to the displacement string to be
	 parsed as an immediate expression after we're done.  */
      else if (intel_parser.op_modifier == OFFSET_FLAT)
	strcat (intel_parser.disp, reg->reg_name);

      /* It's neither base nor index nor offset.  */
      else
	{
	  i.types[this_operand] |= reg->reg_type & ~BaseIndex;
	  i.op[this_operand].regs = reg;
	  i.reg_operands++;
	}

      /* Since registers are not part of the displacement string (except
	 when we're parsing offset operands), we may need to remove any
	 preceding '+' from the displacement string.  */
      if (*intel_parser.disp != '\0'
	  && intel_parser.op_modifier != OFFSET_FLAT)
	{
	  char *s = intel_parser.disp;
	  s += strlen (s) - 1;
	  if (*s == '+')
	    *s = '\0';
	}

      return 1;
    }

  /* e11  id  */
  else if (cur_token.code == T_ID)
    {
      /* Add the identifier to the displacement string.  */
      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (T_ID);

      /* The identifier represents a memory reference only if it's not
	 preceded by an offset modifier.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;

      return 1;
    }

  /* e11  constant  */
  else if (cur_token.code == T_CONST
	   || cur_token.code == '-'
	   || cur_token.code == '+')
    {
      char *save_str;

      /* Allow constants that start with `+' or `-'.  */
      if (cur_token.code == '-' || cur_token.code == '+')
	{
	  strcat (intel_parser.disp, cur_token.str);
	  intel_match_token (cur_token.code);
	  if (cur_token.code != T_CONST)
	    {
	      as_bad (_("Syntax error. Expecting a constant. Got `%s'.\n"),
		      cur_token.str);
	      return 0;
	    }
	}

      save_str = (char *) malloc (strlen (cur_token.str) + 1);
      if (save_str == NULL)
	abort ();
      strcpy (save_str, cur_token.str);

      /* Get the next token to check for register scaling.  */
      intel_match_token (cur_token.code);

      /* Check if this constant is a scaling factor for an index register.  */
      if (cur_token.code == '*')
	{
	  if (intel_match_token ('*') && cur_token.code == T_REG)
	    {
	      if (!intel_parser.is_mem)
		{
		  as_bad (_("Register scaling only allowed in memory operands."));
		  return 0;
		}

	      /* The constant is followed by `* reg', so it must be
		 a valid scale.  */
	      if (strchr ("01248", *save_str))
		{
		  i.index_reg = cur_token.reg;
		  i.types[this_operand] |= BaseIndex;

		  /* Set the scale after setting the register (otherwise,
		     i386_scale will complain)  */
		  i386_scale (save_str);
		  intel_match_token (T_REG);

		  /* Since registers are not part of the displacement
		     string, we may need to remove any preceding '+' from
		     the displacement string.  */
		  if (*intel_parser.disp != '\0')
		    {
		      char *s = intel_parser.disp;
		      s += strlen (s) - 1;
		      if (*s == '+')
			*s = '\0';
		    }

		  free (save_str);

		  return 1;
		}
	      else
		return 0;
	    }

	  /* The constant was not used for register scaling. Since we have
	     already consumed the token following `*' we now need to put it
	     back in the stream.  */
	  else
	    intel_putback_token ();
	}

      /* Add the constant to the displacement string.  */
      strcat (intel_parser.disp, save_str);
      free (save_str);

      return 1;
    }

  as_bad (_("Unrecognized token '%s'"), cur_token.str);
  return 0;
}

/* Match the given token against cur_token. If they match, read the next
   token from the operand string.  */
static int
intel_match_token (code)
     int code;
{
  if (cur_token.code == code)
    {
      intel_get_token ();
      return 1;
    }
  else
    {
      as_bad (_("Unexpected token `%s'\n"), cur_token.str);
      return 0;
    }
}

/* Read a new token from intel_parser.op_string and store it in cur_token.  */
static void
intel_get_token ()
{
  char *end_op;
  const reg_entry *reg;
  struct intel_token new_token;

  new_token.code = T_NIL;
  new_token.reg = NULL;
  new_token.str = NULL;

  /* Free the memory allocated to the previous token and move
     cur_token to prev_token.  */
  if (prev_token.str)
    free (prev_token.str);

  prev_token = cur_token;

  /* Skip whitespace.  */
  while (is_space_char (*intel_parser.op_string))
    intel_parser.op_string++;

  /* Return an empty token if we find nothing else on the line.  */
  if (*intel_parser.op_string == '\0')
    {
      cur_token = new_token;
      return;
    }

  /* The new token cannot be larger than the remainder of the operand
     string.  */
  new_token.str = (char *) malloc (strlen (intel_parser.op_string) + 1);
  if (new_token.str == NULL)
    abort ();
  new_token.str[0] = '\0';

  if (strchr ("0123456789", *intel_parser.op_string))
    {
      char *p = new_token.str;
      char *q = intel_parser.op_string;
      new_token.code = T_CONST;

      /* Allow any kind of identifier char to encompass floating point and
	 hexadecimal numbers.  */
      while (is_identifier_char (*q))
	*p++ = *q++;
      *p = '\0';

      /* Recognize special symbol names [0-9][bf].  */
      if (strlen (intel_parser.op_string) == 2
	  && (intel_parser.op_string[1] == 'b'
	      || intel_parser.op_string[1] == 'f'))
	new_token.code = T_ID;
    }

  else if (strchr ("+-/*:[]()", *intel_parser.op_string))
    {
      new_token.code = *intel_parser.op_string;
      new_token.str[0] = *intel_parser.op_string;
      new_token.str[1] = '\0';
    }

  else if ((*intel_parser.op_string == REGISTER_PREFIX || allow_naked_reg)
	   && ((reg = parse_register (intel_parser.op_string, &end_op)) != NULL))
    {
      new_token.code = T_REG;
      new_token.reg = reg;

      if (*intel_parser.op_string == REGISTER_PREFIX)
	{
	  new_token.str[0] = REGISTER_PREFIX;
	  new_token.str[1] = '\0';
	}

      strcat (new_token.str, reg->reg_name);
    }

  else if (is_identifier_char (*intel_parser.op_string))
    {
      char *p = new_token.str;
      char *q = intel_parser.op_string;

      /* A '.' or '$' followed by an identifier char is an identifier.
	 Otherwise, it's operator '.' followed by an expression.  */
      if ((*q == '.' || *q == '$') && !is_identifier_char (*(q + 1)))
	{
	  new_token.code = *q;
	  new_token.str[0] = *q;
	  new_token.str[1] = '\0';
	}
      else
	{
	  while (is_identifier_char (*q) || *q == '@@')
	    *p++ = *q++;
	  *p = '\0';

	  if (strcasecmp (new_token.str, "BYTE") == 0)
	    new_token.code = T_BYTE;

	  else if (strcasecmp (new_token.str, "WORD") == 0)
	    new_token.code = T_WORD;

	  else if (strcasecmp (new_token.str, "DWORD") == 0)
	    new_token.code = T_DWORD;

	  else if (strcasecmp (new_token.str, "QWORD") == 0)
	    new_token.code = T_QWORD;

	  else if (strcasecmp (new_token.str, "XWORD") == 0)
	    new_token.code = T_XWORD;

	  else if (strcasecmp (new_token.str, "PTR") == 0)
	    new_token.code = T_PTR;

	  else if (strcasecmp (new_token.str, "SHORT") == 0)
	    new_token.code = T_SHORT;

	  else if (strcasecmp (new_token.str, "OFFSET") == 0)
	    {
	      new_token.code = T_OFFSET;

	      /* ??? This is not mentioned in the MASM grammar but gcc
		     makes use of it with -mintel-syntax.  OFFSET may be
		     followed by FLAT:  */
	      if (strncasecmp (q, " FLAT:", 6) == 0)
		strcat (new_token.str, " FLAT:");
	    }

	  /* ??? This is not mentioned in the MASM grammar.  */
	  else if (strcasecmp (new_token.str, "FLAT") == 0)
	    new_token.code = T_OFFSET;

	  else
	    new_token.code = T_ID;
	}
    }

  else
    as_bad (_("Unrecognized token `%s'\n"), intel_parser.op_string);

  intel_parser.op_string += strlen (new_token.str);
  cur_token = new_token;
}

/* Put cur_token back into the token stream and make cur_token point to
   prev_token.  */
static void
intel_putback_token ()
{
  intel_parser.op_string -= strlen (cur_token.str);
  free (cur_token.str);
  cur_token = prev_token;

  /* Forget prev_token.  */
  prev_token.code = T_NIL;
  prev_token.reg = NULL;
  prev_token.str = NULL;
}

int
tc_x86_regname_to_dw2regnum (const char *regname)
{
  unsigned int regnum;
  unsigned int regnames_count;
  static const char *const regnames_32[] =
    {
      "eax", "ecx", "edx", "ebx",
      "esp", "ebp", "esi", "edi",
      "eip", "eflags", NULL,
      "st0", "st1", "st2", "st3",
      "st4", "st5", "st6", "st7",
      NULL, NULL,
      "xmm0", "xmm1", "xmm2", "xmm3",
      "xmm4", "xmm5", "xmm6", "xmm7",
      "mm0", "mm1", "mm2", "mm3",
      "mm4", "mm5", "mm6", "mm7",
      "fcw", "fsw", "mxcsr",
      "es", "cs", "ss", "ds", "fs", "gs", NULL, NULL,
      "tr", "ldtr"
    };
  static const char *const regnames_64[] =
    {
      "rax", "rdx", "rcx", "rbx",
      "rsi", "rdi", "rbp", "rsp",
      "r8",  "r9",  "r10", "r11",
      "r12", "r13", "r14", "r15",
      "rip",
      "xmm0",  "xmm1",  "xmm2",  "xmm3",
      "xmm4",  "xmm5",  "xmm6",  "xmm7",
      "xmm8",  "xmm9",  "xmm10", "xmm11",
      "xmm12", "xmm13", "xmm14", "xmm15",
      "st0", "st1", "st2", "st3",
      "st4", "st5", "st6", "st7",
      "mm0", "mm1", "mm2", "mm3",
      "mm4", "mm5", "mm6", "mm7",
      "rflags",
      "es", "cs", "ss", "ds", "fs", "gs", NULL, NULL,
      "fs.base", "gs.base", NULL, NULL,
      "tr", "ldtr",
      "mxcsr", "fcw", "fsw"
    };
  const char *const *regnames;

  if (flag_code == CODE_64BIT)
    {
      regnames = regnames_64;
      regnames_count = ARRAY_SIZE (regnames_64);
    }
  else
    {
      regnames = regnames_32;
      regnames_count = ARRAY_SIZE (regnames_32);
    }

  for (regnum = 0; regnum < regnames_count; regnum++)
    if (regnames[regnum] != NULL
	&& strcmp (regname, regnames[regnum]) == 0)
      return regnum;

  return -1;
}

void
tc_x86_frame_initial_instructions (void)
{
  static unsigned int sp_regno;

  if (!sp_regno)
    sp_regno = tc_x86_regname_to_dw2regnum (flag_code == CODE_64BIT
					    ? "rsp" : "esp");

  cfi_add_CFA_def_cfa (sp_regno, -x86_cie_data_alignment);
  cfi_add_CFA_offset (x86_dwarf2_return_column, x86_cie_data_alignment);
}
@


1.16
log
@Backport from binutils-2.17 the correct i386/amd64 register->int assignments
for CFI.  This changes the unwind information generated on amd64.
@
text
@d1321 1
d3159 1
d3174 9
d3212 6
@


1.15
log
@Add support for i386 XSAVE family of instructions: xgetbv, xsetbv, xsave,
xrstor, and xsaveopt.

based on kettenis's original that did xgetbv and xsetbv
ok kettenis@@
@
text
@d6216 1
a6216 1
  char *regnames_32[] =
d6220 11
a6230 1
      "eip"
d6232 1
a6232 1
  char *regnames_64[] =
d6234 3
a6236 3
      "rax", "rbx", "rcx", "rdx",
      "rdi", "rsi", "rbp", "rsp",
      "r8", "r9", "r10", "r11",
d6238 14
a6251 1
      "rip"
d6253 1
a6253 1
  char **regnames;
d6267 2
a6268 1
    if (strcmp (regname, regnames[regnum]) == 0)
@


1.14
log
@Backport two fixes for amd64 from binutils 2.16.

- For DefaultSize instructions, don't guess a 'q' suffix if the instruction
  doesn't support it.
- Corrections for x86_64 assembly.

ok miod@@
@
text
@d1383 1
a1383 1
      if ((i.tm.cpu_flags & (CpuPNI|CpuSMAP)) && i.operands > 0)
@


1.13
log
@Add support for stac/clac instructions to manipulate the flag
that controls the behaviour of Intel's Supervisor Mode Access Prevention
(SMAP) feature.

'looks correct' miod@@ ok deraadt@@
@
text
@d1913 1
a1913 1
		i.types[op] = Imm32 | Imm64;
d1916 1
a1916 2
		i.types[op] = Imm16 | Imm32 | Imm64;
		break;
d1919 1
a1919 2
		i.types[op] = Imm8 | Imm8S | Imm16 | Imm32S | Imm32;
		break;
d2007 12
a2018 3
  for (t = current_templates->start;
       t < current_templates->end;
       t++)
d2185 1
a2185 1
process_suffix ()
d2208 1
d2249 3
a2255 1

d2283 1
d2299 2
a2300 4
	{
	  if (i.tm.opcode_modifier & FloatMF)
	    i.tm.base_opcode ^= 4;
	}
d2307 1
a2307 1
check_byte_reg ()
d2310 1
d2505 1
a2505 1
  if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S))
d2734 1
a2734 15
		  if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0)
		      && (flag_code != CODE_64BIT))
		    {
		      i.rm.regmem = NO_BASE_REGISTER_16;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp16;
		    }
		  else if (flag_code != CODE_64BIT
			   || (i.prefix[ADDR_PREFIX] != 0))
		    {
		      i.rm.regmem = NO_BASE_REGISTER;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp32;
		    }
		  else
d2743 11
a2753 2
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp32S;
d2775 1
a2775 1
	      i.types[op] &= ~Disp;
d2778 2
d2815 2
a2816 6
		{
		  if (i.types[op] & Disp8)
		    i.types[op] = Disp8 | Disp32S;
		  else
		    i.types[op] = Disp32S;
		}
d3949 12
a3960 24
  if (flag_code == CODE_64BIT)
    {
      if (i.prefix[ADDR_PREFIX] == 0)
	{
	  /* 64bit checks.  */
	  if ((i.base_reg
	       && ((i.base_reg->reg_type & Reg64) == 0)
		   && (i.base_reg->reg_type != BaseIndex
		       || i.index_reg))
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg64 | BaseIndex))
		      != (Reg64 | BaseIndex))))
	    ok = 0;
	}
      else
	{
	  /* 32bit checks.  */
	  if ((i.base_reg
	       && (i.base_reg->reg_type & (Reg32 | RegRex)) != Reg32)
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex | RegRex))
		      != (Reg32 | BaseIndex))))
	    ok = 0;
	}
d3993 1
a3993 2
      if (flag_code != CODE_64BIT
	  && i.prefix[ADDR_PREFIX] == 0 && stackop_size != '\0')
d4002 1
a4002 1
	  if (i.types[this_operand] & (Disp16 | Disp32))
a4014 1
      return 0;
d4016 1
a4016 1
  return 1;
d4840 1
a4840 1
      && (r->reg_flags & (RegRex64 | RegRex)) != 0
d4842 1
a4842 3
    {
      return (const reg_entry *) NULL;
    }
@


1.12
log
@Add support for Intel AES-NI and the CLMUL_ instructions, plus a few others
that are needed to omplement accelerated AES (and AES-GCM mode) on newer
Intel cores.

Diff from Mike Belopuhov.

no objections/ok miod@@
@
text
@d1383 1
a1383 1
      if ((i.tm.cpu_flags & CpuPNI) && i.operands > 0)
@


1.11
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d3159 1
a3159 1
      if ((i.tm.cpu_flags & CpuPadLock) != 0
d3193 1
a3193 1
	  if ((i.tm.cpu_flags & CpuPadLock) != 0)
@


1.10
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d26 1
d34 1
a52 6
#ifdef BFD_ASSEMBLER
#define RELOC_ENUM enum bfd_reloc_code_real
#else
#define RELOC_ENUM int
#endif

d153 1
a153 1
    RELOC_ENUM reloc[MAX_OPERANDS];
d244 1
a244 1
/* All non-digit non-letter charcters that may occur in an operand.  */
d302 3
d321 6
d804 2
a805 9
    {
#ifdef BFD_ASSEMBLER
      allow_naked_reg = (intel_syntax
			 && (bfd_get_symbol_leading_char (stdoutput) != '\0'));
#else
      /* Conservative default.  */
      allow_naked_reg = 0;
#endif
    }
a859 1
#ifdef BFD_ASSEMBLER
a869 1
#endif
d987 11
a1162 1
#ifdef BFD_ASSEMBLER
d1231 6
a1262 28
#else
#define reloc(SIZE,PCREL,SIGN,OTHER)	0
#define BFD_RELOC_8			0
#define BFD_RELOC_16			0
#define BFD_RELOC_32			0
#define BFD_RELOC_8_PCREL		0
#define BFD_RELOC_16_PCREL		0
#define BFD_RELOC_32_PCREL		0
#define BFD_RELOC_386_PLT32		0
#define BFD_RELOC_386_GOT32		0
#define BFD_RELOC_386_GOTOFF		0
#define BFD_RELOC_386_TLS_GD		0
#define BFD_RELOC_386_TLS_LDM		0
#define BFD_RELOC_386_TLS_LDO_32	0
#define BFD_RELOC_386_TLS_IE_32		0
#define BFD_RELOC_386_TLS_IE		0
#define BFD_RELOC_386_TLS_GOTIE		0
#define BFD_RELOC_386_TLS_LE_32		0
#define BFD_RELOC_386_TLS_LE		0
#define BFD_RELOC_X86_64_PLT32		0
#define BFD_RELOC_X86_64_GOT32		0
#define BFD_RELOC_X86_64_GOTPCREL	0
#define BFD_RELOC_X86_64_TLSGD		0
#define BFD_RELOC_X86_64_TLSLD		0
#define BFD_RELOC_X86_64_DTPOFF32	0
#define BFD_RELOC_X86_64_GOTTPOFF	0
#define BFD_RELOC_X86_64_TPOFF32	0
#endif
d1381 17
a1402 2
      expressionS *exp;

d1787 1
a1787 1
  RELOC_ENUM temp_reloc;
a3128 1

d3156 17
a3172 4
      /* All opcodes on i386 have either 1 or 2 bytes.  We may use third
	 byte for the SSE instructions to specify a prefix they require.  */
      if (i.tm.base_opcode & 0xff0000)
	add_prefix ((i.tm.base_opcode >> 16) & 0xff);
d3193 8
a3200 1
	  p = frag_more (2);
d3280 1
a3280 1
	      RELOC_ENUM reloc_type;
a3323 1
#ifdef BFD_ASSEMBLER
a3353 1
#endif
d3398 1
a3398 1
	      RELOC_ENUM reloc_type;
d3416 1
a3416 1
#ifdef BFD_ASSEMBLER
a3488 1
#endif
d3497 1
a3497 1
static char *lex_got PARAMS ((RELOC_ENUM *, int *));
d3510 1
a3510 1
     RELOC_ENUM *reloc;
d3516 1
a3516 1
    const RELOC_ENUM rel[NUM_FLAG_CODE];
d3594 1
a3594 1
static RELOC_ENUM got_reloc = NO_RELOC;
d3603 1
a3603 1
  RELOC_ENUM r = reloc (len, 0, 0, got_reloc);
d3709 1
a3709 4
  else if (1
#ifdef BFD_ASSEMBLER
	   && OUTPUT_FLAVOR == bfd_target_aout_flavour
#endif
d3715 1
a3715 4
#ifdef BFD_ASSEMBLER
	   && !bfd_is_com_section (exp_seg)
#endif
	   )
a3716 1
#ifdef BFD_ASSEMBLER
a3717 3
#else
      as_bad (_("unimplemented segment type %d in operand"), exp_seg);
#endif
a3873 1
#ifdef BFD_ASSEMBLER
a3898 1
#endif
a3912 1
#ifdef BFD_ASSEMBLER
a3913 1
#endif
d3919 1
a3919 4
#ifdef BFD_ASSEMBLER
      && !bfd_is_com_section (exp_seg)
#endif
      )
a3920 1
#ifdef BFD_ASSEMBLER
a3921 3
#else
      as_bad (_("unimplemented segment type %d in operand"), exp_seg);
#endif
d4350 1
a4350 1
      RELOC_ENUM reloc_type;
a4448 7
#ifndef BFD_ASSEMBLER
void
md_convert_frag (headers, sec, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
#else
a4453 1
#endif
d4592 1
a4592 1
#if defined (BFD_ASSEMBLER) && !defined (TE_Mach)
d4657 1
a4657 1
     and we must not dissappoint it.  */
d4703 1
a4703 1
#endif /* defined (BFD_ASSEMBLER) && !defined (TE_Mach)  */
a4707 1
#ifdef BFD_ASSEMBLER
d4715 1
a4715 1
#endif
d4861 1
a4861 1
const char *md_shortopts = "kVQ:sq";
d4863 1
a4863 1
const char *md_shortopts = "q";
d4884 4
d4949 1
d4954 1
a4958 1
#ifdef BFD_ASSEMBLER
a5039 1
#endif /* BFD_ASSEMBLER  */
a5068 1
#ifdef BFD_ASSEMBLER
a5082 1
#endif
a5112 2
#ifdef BFD_ASSEMBLER

a5271 67
#else /* !BFD_ASSEMBLER  */

#if (defined(OBJ_AOUT) | defined(OBJ_BOUT))
void
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  /* In:  length of relocation (or of address) in chars: 1, 2 or 4.
     Out: GNU LD relocation length code: 0, 1, or 2.  */

  static const unsigned char nbytes_r_length[] = { 42, 0, 1, 42, 2 };
  long r_symbolnum;

  know (fixP->fx_addsy != NULL);

  md_number_to_chars (where,
		      (valueT) (fixP->fx_frag->fr_address
				+ fixP->fx_where - segment_address_in_file),
		      4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);

  where[6] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[4] = r_symbolnum & 0x0ff;
  where[7] = ((((!S_IS_DEFINED (fixP->fx_addsy)) << 3) & 0x08)
	      | ((nbytes_r_length[fixP->fx_size] << 1) & 0x06)
	      | (((fixP->fx_pcrel << 0) & 0x01) & 0x0f));
}

#endif /* OBJ_AOUT or OBJ_BOUT.  */

#if defined (I386COFF)

short
tc_coff_fix2rtype (fixP)
     fixS *fixP;
{
  if (fixP->fx_r_type == R_IMAGEBASE)
    return R_IMAGEBASE;

  return (fixP->fx_pcrel ?
	  (fixP->fx_size == 1 ? R_PCRBYTE :
	   fixP->fx_size == 2 ? R_PCRWORD :
	   R_PCRLONG) :
	  (fixP->fx_size == 1 ? R_RELBYTE :
	   fixP->fx_size == 2 ? R_RELWORD :
	   R_DIR32));
}

int
tc_coff_sizemachdep (frag)
     fragS *frag;
{
  if (frag->fr_next)
    return (frag->fr_next->fr_address - frag->fr_address);
  else
    return 0;
}

#endif /* I386COFF  */

#endif /* !BFD_ASSEMBLER  */
d5502 3
a5504 2
		ret = i386_displacement (s, s + strlen (s))
		      && i386_index_check (s);
d6222 52
@


1.9
log
@Correctly compute pc-relative relocation addend for amd64.
ok deraadt@@
@
text
@d3 1
a3 1
   2000, 2001
a28 2
#include <ctype.h>

d30 1
d51 17
a67 2
#define true 1
#define false 0
d69 7
a75 7
static unsigned int mode_from_disp_size PARAMS ((unsigned int));
static int fits_in_signed_byte PARAMS ((offsetT));
static int fits_in_unsigned_byte PARAMS ((offsetT));
static int fits_in_unsigned_word PARAMS ((offsetT));
static int fits_in_signed_word PARAMS ((offsetT));
static int fits_in_unsigned_long PARAMS ((offsetT));
static int fits_in_signed_long PARAMS ((offsetT));
d83 30
a112 7

#ifdef BFD_ASSEMBLER
static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, int, bfd_reloc_code_real_type));
#define RELOC_ENUM enum bfd_reloc_code_real
#else
#define RELOC_ENUM int
d115 1
a115 4
#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "i386"
#endif
static char *default_arch = DEFAULT_ARCH;
d187 1
a187 1
const char extra_symbol_chars[] = "*%-(@@";
d189 1
a189 1
const char extra_symbol_chars[] = "*%-(";
d192 6
a199 3
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD) && !defined(__OpenBSD__))
/* Putting '/' here makes it impossible to use the divide operator.
   However, we need it for compatibility with SVR4 systems.  */
a201 4
#else
const char comment_chars[] = "#";
#define PREFIX_SEPARATOR '/'
#endif
d211 2
a212 2
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD) && !defined(__OpenBSD__))
const char line_comment_chars[] = "";
d214 6
a219 1
const char line_comment_chars[] = "/";
d313 1
a313 1
static unsigned int cpu_arch_flags = CpuUnknownFlags|CpuNo64;
d319 3
d335 1
a335 1
#define SMALL16 (SMALL|CODE16)
d337 1
a337 1
#define BIG16	(BIG|CODE16)
d418 37
d527 5
a531 2
  /* ??? We can't use these fillers for x86_64, since they often kills the
     upper halves.  Solve later.  */
d533 6
a538 1
    count = 1;
d540 7
a546 3
  if (count > 0 && count <= 15)
    {
      if (flag_code == CODE_16BIT)
d548 3
a550 5
	  memcpy (fragP->fr_literal + fragP->fr_fix,
		  f16_patt[count - 1], count);
	  if (count > 8)
	    /* Adjust jump offset.  */
	    fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
d552 4
a555 1
      else
d557 9
a565 3
		f32_patt[count - 1], count);
      fragP->fr_var = count;
    }
a567 12
static char *output_invalid PARAMS ((int c));
static int i386_operand PARAMS ((char *operand_string));
static int i386_intel_operand PARAMS ((char *operand_string, int got_a_float));
static const reg_entry *parse_register PARAMS ((char *reg_string,
						char **end_op));

#ifndef I386COFF
static void s_bss PARAMS ((int));
#endif

symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */

d628 1
a628 2
  if (cpu_arch_flags != (Cpu086 | Cpu186 | Cpu286 | Cpu386 | Cpu486 | CpuNo64)
      && !(cpu_arch_flags & (CpuUnknown)))
d695 2
a696 1
  if (prefix >= 0x40 && prefix < 0x50 && flag_code == CODE_64BIT)
d734 1
a734 1
  if (i.prefix[q])
d781 1
a781 1
  if (! is_end_of_line[(unsigned char) *input_line_pointer])
d818 1
a818 1
  if (! is_end_of_line[(unsigned char) *input_line_pointer])
d844 1
a844 1
      && ! is_end_of_line[(unsigned char) input_line_pointer[1]])
a861 37
const pseudo_typeS md_pseudo_table[] =
{
#if !defined(OBJ_AOUT) && !defined(USE_ALIGN_PTWO)
  {"align", s_align_bytes, 0},
#else
  {"align", s_align_ptwo, 0},
#endif
  {"arch", set_cpu_arch, 0},
#ifndef I386COFF
  {"bss", s_bss, 0},
#endif
  {"ffloat", float_cons, 'f'},
  {"dfloat", float_cons, 'd'},
  {"tfloat", float_cons, 'x'},
  {"value", cons, 2},
  {"noopt", s_ignore, 0},
  {"optim", s_ignore, 0},
  {"code16gcc", set_16bit_gcc_code_flag, CODE_16BIT},
  {"code16", set_code_flag, CODE_16BIT},
  {"code32", set_code_flag, CODE_32BIT},
  {"code64", set_code_flag, CODE_64BIT},
  {"intel_syntax", set_intel_syntax, 1},
  {"att_syntax", set_intel_syntax, 0},
  {"file", dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
  {0, 0, 0}
};

/* For interface with expression ().  */
extern char *input_line_pointer;

/* Hash table for instruction mnemonic lookup.  */
static struct hash_control *op_hash;

/* Hash table for register lookup.  */
static struct hash_control *reg_hash;

d884 2
a885 2
    register const template *optab;
    register templates *core_optab;
d921 1
a921 1
    register const reg_entry *regtab;
d937 2
a938 2
    register int c;
    register char *p;
d942 1
a942 1
	if (isdigit (c))
d949 1
a949 1
	else if (islower (c))
d955 1
a955 1
	else if (isupper (c))
d957 1
a957 1
	    mnemonic_chars[c] = tolower (c);
d962 1
a962 1
	if (isalpha (c) || isdigit (c))
d1028 4
a1031 1
	   x->rex.mode64, x->rex.extX, x->rex.extY, x->rex.extZ);
d1106 1
a1106 1
type_names[] =
d1146 1
a1146 1
  register struct type_name *ty;
a1155 15
int
tc_i386_force_relocation (fixp)
     struct fix *fixp;
{
#ifdef BFD_ASSEMBLER
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;
  return 0;
#else
  /* For COFF.  */
  return fixp->fx_r_type == 7;
#endif
}

d1157 2
d1212 1
a1212 1
     fixS *fixP;
d1215 8
a1222 4
  /* Prevent all adjustments to global symbols, or else dynamic
     linking will not work correctly.  */
  if (S_IS_EXTERNAL (fixP->fx_addsy)
      || S_IS_WEAK (fixP->fx_addsy))
d1224 1
a1224 1
#endif
d1229 8
d1240 5
d1248 1
d1253 1
d1256 1
d1262 8
d1273 5
d1280 1
a1280 1
static int intel_float_operand PARAMS ((char *mnemonic));
d1284 1
a1284 1
     char *mnemonic;
a1302 3
  /* Points to template once we've found it.  */
  const template *t;

a1303 1

a1316 4
  {
    char *l = line;
    char *token_start = l;
    char *mnem_p;
d1318 7
a1324 2
    /* Non-zero if we found a prefix only acceptable with string insns.  */
    const char *expecting_string_instruction = NULL;
d1326 2
a1327 29
    while (1)
      {
	mnem_p = mnemonic;
	while ((*mnem_p = mnemonic_chars[(unsigned char) *l]) != 0)
	  {
	    mnem_p++;
	    if (mnem_p >= mnemonic + sizeof (mnemonic))
	      {
		as_bad (_("no such instruction: `%s'"), token_start);
		return;
	      }
	    l++;
	  }
	if (!is_space_char (*l)
	    && *l != END_OF_INSN
	    && *l != PREFIX_SEPARATOR)
	  {
	    as_bad (_("invalid character %s in mnemonic"),
		    output_invalid (*l));
	    return;
	  }
	if (token_start == l)
	  {
	    if (*l == PREFIX_SEPARATOR)
	      as_bad (_("expecting prefix; got nothing"));
	    else
	      as_bad (_("expecting mnemonic; got nothing"));
	    return;
	  }
d1329 10
a1338 2
	/* Look up instruction (or prefix) via hash table.  */
	current_templates = hash_find (op_hash, mnemonic);
d1340 2
a1341 30
	if (*l != END_OF_INSN
	    && (! is_space_char (*l) || l[1] != END_OF_INSN)
	    && current_templates
	    && (current_templates->start->opcode_modifier & IsPrefix))
	  {
	    /* If we are in 16-bit mode, do not allow addr16 or data16.
	       Similarly, in 32-bit mode, do not allow addr32 or data32.  */
	    if ((current_templates->start->opcode_modifier & (Size16 | Size32))
		&& (((current_templates->start->opcode_modifier & Size32) != 0)
		    ^ (flag_code == CODE_16BIT)))
	      {
		as_bad (_("redundant %s prefix"),
			current_templates->start->name);
		return;
	      }
	    /* Add prefix, checking for repeated prefixes.  */
	    switch (add_prefix (current_templates->start->base_opcode))
	      {
	      case 0:
		return;
	      case 2:
		expecting_string_instruction = current_templates->start->name;
		break;
	      }
	    /* Skip past PREFIX_SEPARATOR and reset token_start.  */
	    token_start = ++l;
	  }
	else
	  break;
      }
d1343 2
a1344 21
    if (!current_templates)
      {
	/* See if we can get a match by trimming off a suffix.  */
	switch (mnem_p[-1])
	  {
	  case WORD_MNEM_SUFFIX:
	  case BYTE_MNEM_SUFFIX:
	  case QWORD_MNEM_SUFFIX:
	    i.suffix = mnem_p[-1];
	    mnem_p[-1] = '\0';
	    current_templates = hash_find (op_hash, mnemonic);
	    break;
	  case SHORT_MNEM_SUFFIX:
	  case LONG_MNEM_SUFFIX:
	    if (!intel_syntax)
	      {
		i.suffix = mnem_p[-1];
		mnem_p[-1] = '\0';
		current_templates = hash_find (op_hash, mnemonic);
	      }
	    break;
d1346 3
a1348 19
	  /* Intel Syntax.  */
	  case 'd':
	    if (intel_syntax)
	      {
		if (intel_float_operand (mnemonic))
		  i.suffix = SHORT_MNEM_SUFFIX;
		else
		  i.suffix = LONG_MNEM_SUFFIX;
		mnem_p[-1] = '\0';
		current_templates = hash_find (op_hash, mnemonic);
	      }
	    break;
	  }
	if (!current_templates)
	  {
	    as_bad (_("no such instruction: `%s'"), token_start);
	    return;
	  }
      }
d1350 2
a1351 14
    /* Check if instruction is supported on specified architecture.  */
    if (cpu_arch_flags != 0)
      {
	if ((current_templates->start->cpu_flags & ~(Cpu64 | CpuNo64))
	    & ~(cpu_arch_flags & ~(Cpu64 | CpuNo64)))
	  {
	    as_warn (_("`%s' is not supported on `%s'"),
		     current_templates->start->name, cpu_arch_name);
	  }
	else if ((Cpu386 & ~cpu_arch_flags) && (flag_code != CODE_16BIT))
	  {
	    as_warn (_("use .code16 to ensure correct addressing mode"));
	  }
      }
d1353 6
a1358 8
    /* Check for rep/repne without a string instruction.  */
    if (expecting_string_instruction
	&& !(current_templates->start->opcode_modifier & IsString))
      {
	as_bad (_("expecting string instruction after `%s'"),
		expecting_string_instruction);
	return;
      }
d1360 6
a1365 5
    /* There may be operands to parse.  */
    if (*l != END_OF_INSN)
      {
	/* 1 if operand is pending after ','.  */
	unsigned int expecting_operand = 0;
d1367 3
a1369 2
	/* Non-zero if operand parens not balanced.  */
	unsigned int paren_not_balanced;
d1371 6
a1376 92
	do
	  {
	    /* Skip optional white space before operand.  */
	    if (is_space_char (*l))
	      ++l;
	    if (!is_operand_char (*l) && *l != END_OF_INSN)
	      {
		as_bad (_("invalid character %s before operand %d"),
			output_invalid (*l),
			i.operands + 1);
		return;
	      }
	    token_start = l;	/* after white space */
	    paren_not_balanced = 0;
	    while (paren_not_balanced || *l != ',')
	      {
		if (*l == END_OF_INSN)
		  {
		    if (paren_not_balanced)
		      {
			if (!intel_syntax)
			  as_bad (_("unbalanced parenthesis in operand %d."),
				  i.operands + 1);
			else
			  as_bad (_("unbalanced brackets in operand %d."),
				  i.operands + 1);
			return;
		      }
		    else
		      break;	/* we are done */
		  }
		else if (!is_operand_char (*l) && !is_space_char (*l))
		  {
		    as_bad (_("invalid character %s in operand %d"),
			    output_invalid (*l),
			    i.operands + 1);
		    return;
		  }
		if (!intel_syntax)
		  {
		    if (*l == '(')
		      ++paren_not_balanced;
		    if (*l == ')')
		      --paren_not_balanced;
		  }
		else
		  {
		    if (*l == '[')
		      ++paren_not_balanced;
		    if (*l == ']')
		      --paren_not_balanced;
		  }
		l++;
	      }
	    if (l != token_start)
	      {			/* Yes, we've read in another operand.  */
		unsigned int operand_ok;
		this_operand = i.operands++;
		if (i.operands > MAX_OPERANDS)
		  {
		    as_bad (_("spurious operands; (%d operands/instruction max)"),
			    MAX_OPERANDS);
		    return;
		  }
		/* Now parse operand adding info to 'i' as we go along.  */
		END_STRING_AND_SAVE (l);

		if (intel_syntax)
		  operand_ok =
		    i386_intel_operand (token_start,
					intel_float_operand (mnemonic));
		else
		  operand_ok = i386_operand (token_start);

		RESTORE_END_STRING (l);
		if (!operand_ok)
		  return;
	      }
	    else
	      {
		if (expecting_operand)
		  {
		  expecting_operand_after_comma:
		    as_bad (_("expecting operand after ','; got nothing"));
		    return;
		  }
		if (*l == ',')
		  {
		    as_bad (_("expecting operand before ','; got nothing"));
		    return;
		  }
	      }
d1378 2
a1379 14
	    /* Now *l must be either ',' or END_OF_INSN.  */
	    if (*l == ',')
	      {
		if (*++l == END_OF_INSN)
		  {
		    /* Just skip it, if it's \n complain.  */
		    goto expecting_operand_after_comma;
		  }
		expecting_operand = 1;
	      }
	  }
	while (*l != END_OF_INSN);
      }
  }
d1381 32
a1412 2
  /* Now we've parsed the mnemonic into a set of templates, and have the
     operands at hand.
d1414 11
a1424 3
     Next, we find a template that matches the given insn,
     making sure the overlap of the given operands types is consistent
     with the template operand types.  */
d1426 6
a1431 3
#define MATCH(overlap, given, template) \
  ((overlap & ~JumpAbsolute) \
   && ((given) & (BaseIndex|JumpAbsolute)) == ((overlap) & (BaseIndex|JumpAbsolute)))
d1433 53
a1485 7
  /* If given types r0 and r1 are registers they must be of the same type
     unless the expected operand type register overlap is null.
     Note that Acc in a template matches every size of reg.  */
#define CONSISTENT_REGISTER_MATCH(m0, g0, t0, m1, g1, t1) \
  ( ((g0) & Reg) == 0 || ((g1) & Reg) == 0 || \
    ((g0) & Reg) == ((g1) & Reg) || \
    ((((m0) & Acc) ? Reg : (t0)) & (((m1) & Acc) ? Reg : (t1)) & Reg) == 0 )
d1487 8
a1494 21
  {
    register unsigned int overlap0, overlap1;
    unsigned int overlap2;
    unsigned int found_reverse_match;
    int suffix_check;

    /* All intel opcodes have reversed operands except for "bound" and
       "enter".  We also don't reverse intersegment "jmp" and "call"
       instructions with 2 immediate operands so that the immediate segment
       precedes the offset, as it does when in AT&T mode.  "enter" and the
       intersegment "jmp" and "call" instructions are the only ones that
       have two immediate operands.  */
    if (intel_syntax && i.operands > 1
	&& (strcmp (mnemonic, "bound") != 0)
	&& !((i.types[0] & Imm) && (i.types[1] & Imm)))
      {
	union i386_op temp_op;
	unsigned int temp_type;
	RELOC_ENUM temp_reloc;
	int xchg1 = 0;
	int xchg2 = 0;
d1496 2
a1497 19
	if (i.operands == 2)
	  {
	    xchg1 = 0;
	    xchg2 = 1;
	  }
	else if (i.operands == 3)
	  {
	    xchg1 = 0;
	    xchg2 = 2;
	  }
	temp_type = i.types[xchg2];
	i.types[xchg2] = i.types[xchg1];
	i.types[xchg1] = temp_type;
	temp_op = i.op[xchg2];
	i.op[xchg2] = i.op[xchg1];
	i.op[xchg1] = temp_op;
	temp_reloc = i.reloc[xchg2];
	i.reloc[xchg2] = i.reloc[xchg1];
	i.reloc[xchg1] = temp_reloc;
d1499 30
a1528 8
	if (i.mem_operands == 2)
	  {
	    const seg_entry *temp_seg;
	    temp_seg = i.seg[0];
	    i.seg[0] = i.seg[1];
	    i.seg[1] = temp_seg;
	  }
      }
d1530 2
a1531 31
    if (i.imm_operands)
      {
	/* Try to ensure constant immediates are represented in the smallest
	   opcode possible.  */
	char guess_suffix = 0;
	int op;

	if (i.suffix)
	  guess_suffix = i.suffix;
	else if (i.reg_operands)
	  {
	    /* Figure out a suffix from the last register operand specified.
	       We can't do this properly yet, ie. excluding InOutPortReg,
	       but the following works for instructions with immediates.
	       In any case, we can't set i.suffix yet.  */
	    for (op = i.operands; --op >= 0;)
	      if (i.types[op] & Reg)
		{
		  if (i.types[op] & Reg8)
		    guess_suffix = BYTE_MNEM_SUFFIX;
		  else if (i.types[op] & Reg16)
		    guess_suffix = WORD_MNEM_SUFFIX;
		  else if (i.types[op] & Reg32)
		    guess_suffix = LONG_MNEM_SUFFIX;
		  else if (i.types[op] & Reg64)
		    guess_suffix = QWORD_MNEM_SUFFIX;
		  break;
		}
	  }
	else if ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0))
	  guess_suffix = WORD_MNEM_SUFFIX;
d1533 11
a1543 2
	for (op = i.operands; --op >= 0;)
	  if (i.types[op] & Imm)
d1545 19
a1563 16
	      switch (i.op[op].imms->X_op)
		{
		  case O_constant:
		    /* If a suffix is given, this operand may be shortened.  */
		    switch (guess_suffix)
		      {
		      case LONG_MNEM_SUFFIX:
			i.types[op] |= Imm32 | Imm64;
			break;
		      case WORD_MNEM_SUFFIX:
			i.types[op] |= Imm16 | Imm32S | Imm32 | Imm64;
			break;
		      case BYTE_MNEM_SUFFIX:
			i.types[op] |= Imm16 | Imm8 | Imm8S | Imm32S | Imm32 | Imm64;
			break;
		      }
d1565 19
a1583 47
		    /* If this operand is at most 16 bits, convert it
		       to a signed 16 bit number before trying to see
		       whether it will fit in an even smaller size.
		       This allows a 16-bit operand such as $0xffe0 to
		       be recognised as within Imm8S range.  */
		    if ((i.types[op] & Imm16)
			&& (i.op[op].imms->X_add_number & ~(offsetT) 0xffff) == 0)
		      {
			i.op[op].imms->X_add_number =
			  (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
		      }
		    if ((i.types[op] & Imm32)
			&& (i.op[op].imms->X_add_number & ~(((offsetT) 2 << 31) - 1)) == 0)
		      {
			i.op[op].imms->X_add_number =
			  (i.op[op].imms->X_add_number ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
		      }
		    i.types[op] |= smallest_imm_type (i.op[op].imms->X_add_number);
		    /* We must avoid matching of Imm32 templates when 64bit only immediate is available.  */
		    if (guess_suffix == QWORD_MNEM_SUFFIX)
		      i.types[op] &= ~Imm32;
		    break;
		  case O_absent:
		  case O_register:
		    abort ();
		  /* Symbols and expressions.  */
		  default:
		    /* Convert symbolic operand to proper sizes for matching.  */
		    switch (guess_suffix)
		      {
		        case QWORD_MNEM_SUFFIX:
			  i.types[op] = Imm64 | Imm32S;
			  break;
		        case LONG_MNEM_SUFFIX:
			  i.types[op] = Imm32 | Imm64;
			  break;
		        case WORD_MNEM_SUFFIX:
			  i.types[op] = Imm16 | Imm32 | Imm64;
			  break;
			  break;
		        case BYTE_MNEM_SUFFIX:
			  i.types[op] = Imm8 | Imm8S | Imm16 | Imm32S | Imm32;
				break;
			  break;
		      }
		    break;
		}
d1585 1
a1585 1
      }
d1587 19
a1605 4
    if (i.disp_operands)
      {
	/* Try to use the smallest displacement type too.  */
	int op;
d1607 17
a1623 3
	for (op = i.operands; --op >= 0;)
	  if ((i.types[op] & Disp)
	      && i.op[op].disps->X_op == O_constant)
d1625 44
a1668 1
	      offsetT disp = i.op[op].disps->X_add_number;
d1670 5
a1674 6
	      if (i.types[op] & Disp16)
		{
		  /* We know this operand is at most 16 bits, so
		     convert to a signed 16 bit number before trying
		     to see whether it will fit in an even smaller
		     size.  */
d1676 19
a1694 3
		  disp = (((disp & 0xffff) ^ 0x8000) - 0x8000);
		}
	      else if (i.types[op] & Disp32)
d1696 7
a1702 5
		  /* We know this operand is at most 32 bits, so convert to a
		     signed 32 bit number before trying to see whether it will
		     fit in an even smaller size.  */
		  disp &= (((offsetT) 2 << 31) - 1);
		  disp = (disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
d1704 72
a1775 10
	      if (flag_code == CODE_64BIT)
		{
		  if (fits_in_signed_long (disp))
		    i.types[op] |= Disp32S;
		  if (fits_in_unsigned_long (disp))
		    i.types[op] |= Disp32;
		}
	      if ((i.types[op] & (Disp32 | Disp32S | Disp16))
		  && fits_in_signed_byte (disp))
		i.types[op] |= Disp8;
d1777 34
a1810 1
      }
d1812 8
a1819 23
    overlap0 = 0;
    overlap1 = 0;
    overlap2 = 0;
    found_reverse_match = 0;
    suffix_check = (i.suffix == BYTE_MNEM_SUFFIX
		    ? No_bSuf
		    : (i.suffix == WORD_MNEM_SUFFIX
		       ? No_wSuf
		       : (i.suffix == SHORT_MNEM_SUFFIX
			  ? No_sSuf
			  : (i.suffix == LONG_MNEM_SUFFIX
			     ? No_lSuf
			     : (i.suffix == QWORD_MNEM_SUFFIX
				? No_qSuf
				: (i.suffix == LONG_DOUBLE_MNEM_SUFFIX ? No_xSuf : 0))))));

    for (t = current_templates->start;
	 t < current_templates->end;
	 t++)
      {
	/* Must have right number of operands.  */
	if (i.operands != t->operands)
	  continue;
d1821 7
a1827 9
	/* Check the suffix, except for some instructions in intel mode.  */
	if ((t->opcode_modifier & suffix_check)
	    && !(intel_syntax
		 && (t->opcode_modifier & IgnoreSize))
	    && !(intel_syntax
		 && t->base_opcode == 0xd9
		 && (t->extension_opcode == 5	     /* 0xd9,5 "fldcw"  */
		     || t->extension_opcode == 7)))  /* 0xd9,7 "f{n}stcw"  */
	  continue;
d1829 19
a1847 6
	/* Do not verify operands when there are none.  */
	else if (!t->operands)
	  {
	    if (t->cpu_flags & ~cpu_arch_flags)
	      continue;
	    /* We've found a match; break out of loop.  */
d1850 3
d1854 4
a1857 2
	overlap0 = i.types[0] & t->operand_types[0];
	switch (t->operands)
d1859 3
a1861 13
	  case 1:
	    if (!MATCH (overlap0, i.types[0], t->operand_types[0]))
	      continue;
	    break;
	  case 2:
	  case 3:
	    overlap1 = i.types[1] & t->operand_types[1];
	    if (!MATCH (overlap0, i.types[0], t->operand_types[0])
		|| !MATCH (overlap1, i.types[1], t->operand_types[1])
		|| !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
					       t->operand_types[0],
					       overlap1, i.types[1],
					       t->operand_types[1]))
d1863 10
a1872 3
		/* Check if other direction is valid ...  */
		if ((t->opcode_modifier & (D|FloatD)) == 0)
		  continue;
d1874 10
a1883 16
		/* Try reversing direction of operands.  */
		overlap0 = i.types[0] & t->operand_types[1];
		overlap1 = i.types[1] & t->operand_types[0];
		if (!MATCH (overlap0, i.types[0], t->operand_types[1])
		    || !MATCH (overlap1, i.types[1], t->operand_types[0])
		    || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
						   t->operand_types[1],
						   overlap1, i.types[1],
						   t->operand_types[0]))
		  {
		    /* Does not match either direction.  */
		    continue;
		  }
		/* found_reverse_match holds which of D or FloatDR
		   we've found.  */
		found_reverse_match = t->opcode_modifier & (D|FloatDR);
d1885 3
a1887 2
	    /* Found a forward 2 operand match here.  */
	    else if (t->operands == 3)
d1889 5
a1893 10
		/* Here we make use of the fact that there are no
		   reverse match 3 operand instructions, and all 3
		   operand instructions only need to be checked for
		   register consistency between operands 2 and 3.  */
		overlap2 = i.types[2] & t->operand_types[2];
		if (!MATCH (overlap2, i.types[2], t->operand_types[2])
		    || !CONSISTENT_REGISTER_MATCH (overlap1, i.types[1],
						   t->operand_types[1],
						   overlap2, i.types[2],
						   t->operand_types[2]))
d1895 29
a1923 1
		  continue;
d1925 1
a1925 7
	    /* Found either forward/reverse 2 or 3 operand match here:
	       slip through to break.  */
	  }
	if (t->cpu_flags & ~cpu_arch_flags)
	  {
	    found_reverse_match = 0;
	    continue;
a1926 2
	/* We've found a match; break out of loop.  */
	break;
d1928 10
a1937 1
    if (t == current_templates->end)
d1939 1
a1939 5
	/* We found no match.  */
	as_bad (_("suffix or operands invalid for `%s'"),
		current_templates->start->name);
	return;
      }
d1941 1
a1941 5
    if (!quiet_warnings)
      {
	if (!intel_syntax
	    && ((i.types[0] & JumpAbsolute)
		!= (t->operand_types[0] & JumpAbsolute)))
d1943 6
a1948 1
	    as_warn (_("indirect %s without `*'"), t->name);
d1950 1
a1950 3

	if ((t->opcode_modifier & (IsPrefix|IgnoreSize))
	    == (IsPrefix|IgnoreSize))
d1952 5
a1956 3
	    /* Warn them that a data or address size prefix doesn't
	       affect assembly of the next line of code.  */
	    as_warn (_("stand-alone `%s' prefix"), t->name);
d1958 10
d1969 1
d1971 13
a1983 7
    /* Copy the template we found.  */
    i.tm = *t;
    if (found_reverse_match)
      {
	/* If we found a reverse match we must alter the opcode
	   direction bit.  found_reverse_match holds bits to change
	   (different for int & float insns).  */
d1985 42
a2026 1
	i.tm.base_opcode ^= found_reverse_match;
d2028 8
a2035 3
	i.tm.operand_types[0] = t->operand_types[1];
	i.tm.operand_types[1] = t->operand_types[0];
      }
d2037 51
a2087 5
    /* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
    if (SYSV386_COMPAT
	&& intel_syntax
	&& (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
      i.tm.base_opcode ^= FloatR;
d2089 13
a2101 3
    if (i.tm.opcode_modifier & FWait)
      if (! add_prefix (FWAIT_OPCODE))
	return;
d2103 102
a2204 7
    /* Check string instruction segment overrides.  */
    if ((i.tm.opcode_modifier & IsString) != 0 && i.mem_operands != 0)
      {
	int mem_op = (i.types[0] & AnyMem) ? 0 : 1;
	if ((i.tm.operand_types[mem_op] & EsSeg) != 0)
	  {
	    if (i.seg[0] != NULL && i.seg[0] != &es)
d2206 5
a2210 4
		as_bad (_("`%s' operand %d must use `%%es' segment"),
			i.tm.name,
			mem_op + 1);
		return;
d2212 106
a2317 17
	    /* There's only ever one segment override allowed per instruction.
	       This instruction possibly has a legal segment override on the
	       second operand, so copy the segment to where non-string
	       instructions store it, allowing common code.  */
	    i.seg[0] = i.seg[1];
	  }
	else if ((i.tm.operand_types[mem_op + 1] & EsSeg) != 0)
	  {
	    if (i.seg[1] != NULL && i.seg[1] != &es)
	      {
		as_bad (_("`%s' operand %d must use `%%es' segment"),
			i.tm.name,
			mem_op + 2);
		return;
	      }
	  }
      }
d2319 18
a2336 10
    if (i.reg_operands && flag_code < CODE_64BIT)
      {
	int op;
	for (op = i.operands; --op >= 0;)
	  if ((i.types[op] & Reg)
	      && (i.op[op].regs->reg_flags & (RegRex64|RegRex)))
	    {
	      as_bad (_("Extended register `%%%s' available only in 64bit mode."),
		      i.op[op].regs->reg_name);
	      return;
d2338 32
a2369 1
      }
d2371 5
a2375 3
    /* If matched instruction specifies an explicit instruction mnemonic
       suffix, use it.  */
    if (i.tm.opcode_modifier & (Size16 | Size32 | Size64))
d2377 5
a2381 6
	if (i.tm.opcode_modifier & Size16)
	  i.suffix = WORD_MNEM_SUFFIX;
	else if (i.tm.opcode_modifier & Size64)
	  i.suffix = QWORD_MNEM_SUFFIX;
	else
	  i.suffix = LONG_MNEM_SUFFIX;
d2383 4
a2386 1
    else if (i.reg_operands)
d2388 3
a2390 3
	/* If there's no instruction mnemonic suffix we try to invent one
	   based on register operands.  */
	if (!i.suffix)
d2392 4
a2395 14
	    /* We take i.suffix from the last register operand specified,
	       Destination register type is more significant than source
	       register type.  */
	    int op;
	    for (op = i.operands; --op >= 0;)
	      if ((i.types[op] & Reg)
		  && !(i.tm.operand_types[op] & InOutPortReg))
		{
		  i.suffix = ((i.types[op] & Reg8) ? BYTE_MNEM_SUFFIX :
			      (i.types[op] & Reg16) ? WORD_MNEM_SUFFIX :
			      (i.types[op] & Reg64) ? QWORD_MNEM_SUFFIX :
			      LONG_MNEM_SUFFIX);
		  break;
		}
a2396 36
	else if (i.suffix == BYTE_MNEM_SUFFIX)
	  {
	    int op;
	    for (op = i.operands; --op >= 0;)
	      {
		/* If this is an eight bit register, it's OK.  If it's
		   the 16 or 32 bit version of an eight bit register,
		   we will just use the low portion, and that's OK too.  */
		if (i.types[op] & Reg8)
		  continue;

		/* movzx and movsx should not generate this warning.  */
		if (intel_syntax
		    && (i.tm.base_opcode == 0xfb7
			|| i.tm.base_opcode == 0xfb6
			|| i.tm.base_opcode == 0x63
			|| i.tm.base_opcode == 0xfbe
			|| i.tm.base_opcode == 0xfbf))
		  continue;

		if ((i.types[op] & WordReg) && i.op[op].regs->reg_num < 4
#if 0
		    /* Check that the template allows eight bit regs
		       This kills insns such as `orb $1,%edx', which
		       maybe should be allowed.  */
		    && (i.tm.operand_types[op] & (Reg8|InOutPortReg))
#endif
		    )
		  {
		    /* Prohibit these changes in the 64bit mode, since
		       the lowering is more complicated.  */
		    if (flag_code == CODE_64BIT
			&& (i.tm.operand_types[op] & InOutPortReg) == 0)
		      as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			      i.op[op].regs->reg_name,
			      i.suffix);
d2398 18
a2415 29
		    if (!quiet_warnings
			&& (i.tm.operand_types[op] & InOutPortReg) == 0)
		      as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			       (i.op[op].regs
				+ (i.types[op] & Reg16
				   ? REGNAM_AL - REGNAM_AX
				   : REGNAM_AL - REGNAM_EAX))->reg_name,
			       i.op[op].regs->reg_name,
			       i.suffix);
#endif
		    continue;
		  }
		/* Any other register is bad.  */
		if (i.types[op] & (Reg | RegMMX | RegXMM
				   | SReg2 | SReg3
				   | Control | Debug | Test
				   | FloatReg | FloatAcc))
		  {
		    as_bad (_("`%%%s' not allowed with `%s%c'"),
			    i.op[op].regs->reg_name,
			    i.tm.name,
			    i.suffix);
		    return;
		  }
	      }
	  }
	else if (i.suffix == LONG_MNEM_SUFFIX)
	  {
	    int op;
d2417 4
a2420 43
	    for (op = i.operands; --op >= 0;)
	      /* Reject eight bit registers, except where the template
		 requires them. (eg. movzb)  */
	      if ((i.types[op] & Reg8) != 0
		  && (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
		{
		  as_bad (_("`%%%s' not allowed with `%s%c'"),
			  i.op[op].regs->reg_name,
			  i.tm.name,
			  i.suffix);
		  return;
		}
	      /* Warn if the e prefix on a general reg is missing.  */
	      else if ((!quiet_warnings || flag_code == CODE_64BIT)
		       && (i.types[op] & Reg16) != 0
		       && (i.tm.operand_types[op] & (Reg32|Acc)) != 0)
		{
		  /* Prohibit these changes in the 64bit mode, since
		     the lowering is more complicated.  */
		  if (flag_code == CODE_64BIT)
		    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			    i.op[op].regs->reg_name,
			    i.suffix);
#if REGISTER_WARNINGS
		  else
		    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			     (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
			     i.op[op].regs->reg_name,
			     i.suffix);
#endif
		}
	      /* Warn if the r prefix on a general reg is missing.  */
	      else if ((i.types[op] & Reg64) != 0
		       && (i.tm.operand_types[op] & (Reg32|Acc)) != 0)
		{
		  as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			  i.op[op].regs->reg_name,
			  i.suffix);
		}
	  }
	else if (i.suffix == QWORD_MNEM_SUFFIX)
	  {
	    int op;
d2422 11
a2432 64
	    for (op = i.operands; --op >= 0; )
	      /* Reject eight bit registers, except where the template
		 requires them. (eg. movzb)  */
	      if ((i.types[op] & Reg8) != 0
		  && (i.tm.operand_types[op] & (Reg16|Reg32|Acc)) != 0)
		{
		  as_bad (_("`%%%s' not allowed with `%s%c'"),
			  i.op[op].regs->reg_name,
			  i.tm.name,
			  i.suffix);
		  return;
		}
	      /* Warn if the e prefix on a general reg is missing.  */
	      else if (((i.types[op] & Reg16) != 0
		        || (i.types[op] & Reg32) != 0)
		       && (i.tm.operand_types[op] & (Reg32|Acc)) != 0)
		{
		  /* Prohibit these changes in the 64bit mode, since
		     the lowering is more complicated.  */
		  as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			  i.op[op].regs->reg_name,
			  i.suffix);
		}
	  }
	else if (i.suffix == WORD_MNEM_SUFFIX)
	  {
	    int op;
	    for (op = i.operands; --op >= 0;)
	      /* Reject eight bit registers, except where the template
		 requires them. (eg. movzb)  */
	      if ((i.types[op] & Reg8) != 0
		  && (i.tm.operand_types[op] & (Reg16|Reg32|Acc)) != 0)
		{
		  as_bad (_("`%%%s' not allowed with `%s%c'"),
			  i.op[op].regs->reg_name,
			  i.tm.name,
			  i.suffix);
		  return;
		}
	      /* Warn if the e prefix on a general reg is present.  */
	      else if ((!quiet_warnings || flag_code == CODE_64BIT)
		       && (i.types[op] & Reg32) != 0
		       && (i.tm.operand_types[op] & (Reg16|Acc)) != 0)
		{
		  /* Prohibit these changes in the 64bit mode, since
		     the lowering is more complicated.  */
		  if (flag_code == CODE_64BIT)
		    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			    i.op[op].regs->reg_name,
			    i.suffix);
		  else
#if REGISTER_WARNINGS
		    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			     (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
			     i.op[op].regs->reg_name,
			     i.suffix);
#endif
		}
	  }
	else if (intel_syntax && (i.tm.opcode_modifier & IgnoreSize))
	  /* Do nothing if the instruction is going to ignore the prefix.  */
	  ;
	else
	  abort ();
d2434 4
a2437 1
    else if ((i.tm.opcode_modifier & DefaultSize) && !i.suffix)
d2439 6
a2444 1
	i.suffix = stackop_size;
d2446 12
a2457 6
    /* Make still unresolved immediate matches conform to size of immediate
       given in i.suffix.  Note: overlap2 cannot be an immediate!  */
    if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S))
	&& overlap0 != Imm8 && overlap0 != Imm8S
	&& overlap0 != Imm16 && overlap0 != Imm32S
	&& overlap0 != Imm32 && overlap0 != Imm64)
d2459 5
a2463 20
	if (i.suffix)
	  {
	    overlap0 &= (i.suffix == BYTE_MNEM_SUFFIX ? (Imm8 | Imm8S) :
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 :
			(i.suffix == QWORD_MNEM_SUFFIX ? Imm64 | Imm32S : Imm32)));
	  }
	else if (overlap0 == (Imm16 | Imm32S | Imm32)
		 || overlap0 == (Imm16 | Imm32)
		 || overlap0 == (Imm16 | Imm32S))
	  {
	    overlap0 =
	      ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32S;
	  }
	if (overlap0 != Imm8 && overlap0 != Imm8S
	    && overlap0 != Imm16 && overlap0 != Imm32S
	    && overlap0 != Imm32 && overlap0 != Imm64)
	  {
	    as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
	    return;
	  }
d2465 4
a2468 4
    if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32S | Imm32))
	&& overlap1 != Imm8 && overlap1 != Imm8S
	&& overlap1 != Imm16 && overlap1 != Imm32S
	&& overlap1 != Imm32 && overlap1 != Imm64)
d2470 3
a2472 1
	if (i.suffix)
d2474 4
a2477 17
	    overlap1 &= (i.suffix == BYTE_MNEM_SUFFIX ? (Imm8 | Imm8S) :
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 :
			(i.suffix == QWORD_MNEM_SUFFIX ? Imm64 | Imm32S : Imm32)));
	  }
	else if (overlap1 == (Imm16 | Imm32 | Imm32S)
		 || overlap1 == (Imm16 | Imm32)
		 || overlap1 == (Imm16 | Imm32S))
	  {
	    overlap1 =
	      ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32S;
	  }
	if (overlap1 != Imm8 && overlap1 != Imm8S
	    && overlap1 != Imm16 && overlap1 != Imm32S
	    && overlap1 != Imm32 && overlap1 != Imm64)
	  {
	    as_bad (_("no instruction mnemonic suffix given; can't determine immediate size %x %c"),overlap1, i.suffix);
	    return;
d2479 7
d2487 2
a2488 1
    assert ((overlap2 & Imm) == 0);
d2490 4
a2493 13
    i.types[0] = overlap0;
    if (overlap0 & ImplicitRegister)
      i.reg_operands--;
    if (overlap0 & Imm1)
      i.imm_operands = 0;	/* kludge for shift insns.  */

    i.types[1] = overlap1;
    if (overlap1 & ImplicitRegister)
      i.reg_operands--;

    i.types[2] = overlap2;
    if (overlap2 & ImplicitRegister)
      i.reg_operands--;
d2495 32
a2526 2
    /* Finalize opcode.  First, we change the opcode based on the operand
       size given by i.suffix:  We need not change things for byte insns.  */
d2528 26
a2553 10
    if (!i.suffix && (i.tm.opcode_modifier & W))
      {
	as_bad (_("no instruction mnemonic suffix given and no register operands; can't size instruction"));
	return;
      }

    /* For movzx and movsx, need to check the register type.  */
    if (intel_syntax
	&& (i.tm.base_opcode == 0xfb6 || i.tm.base_opcode == 0xfbe))
      if (i.suffix && i.suffix == BYTE_MNEM_SUFFIX)
d2555 5
a2559 1
	  unsigned int prefix = DATA_PREFIX_OPCODE;
d2561 3
a2563 4
	  if ((i.op[1].regs->reg_type & Reg16) != 0)
	    if (!add_prefix (prefix))
	      return;
	}
d2565 2
a2566 20
    if (i.suffix && i.suffix != BYTE_MNEM_SUFFIX)
      {
	/* It's not a byte, select word/dword operation.  */
	if (i.tm.opcode_modifier & W)
	  {
	    if (i.tm.opcode_modifier & ShortForm)
	      i.tm.base_opcode |= 8;
	    else
	      i.tm.base_opcode |= 1;
	  }
	/* Now select between word & dword operations via the operand
	   size prefix, except for instructions that will ignore this
	   prefix anyway.  */
	if (i.suffix != QWORD_MNEM_SUFFIX
	    && (i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
	    && !(i.tm.opcode_modifier & IgnoreSize))
	  {
	    unsigned int prefix = DATA_PREFIX_OPCODE;
	    if (i.tm.opcode_modifier & JumpByte) /* jcxz, loop */
	      prefix = ADDR_PREFIX_OPCODE;
d2568 53
a2620 3
	    if (! add_prefix (prefix))
	      return;
	  }
d2622 24
a2645 11
	/* Set mode64 for an operand.  */
	if (i.suffix == QWORD_MNEM_SUFFIX
	    && !(i.tm.opcode_modifier & NoRex64))
	  {
	    i.rex.mode64 = 1;
	    if (flag_code < CODE_64BIT)
	      {
		as_bad (_("64bit operations available only in 64bit modes."));
		return;
	      }
	  }
d2647 2
a2648 7
	/* Size floating point instruction.  */
	if (i.suffix == LONG_MNEM_SUFFIX)
	  {
	    if (i.tm.opcode_modifier & FloatMF)
	      i.tm.base_opcode ^= 4;
	  }
      }
d2650 12
a2661 18
    if (i.tm.opcode_modifier & ImmExt)
      {
	/* These AMD 3DNow! and Intel Katmai New Instructions have an
	   opcode suffix which is coded in the same place as an 8-bit
	   immediate field would be.  Here we fake an 8-bit immediate
	   operand from the opcode suffix stored in tm.extension_opcode.  */

	expressionS *exp;

	assert (i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);

	exp = &im_expressions[i.imm_operands++];
	i.op[i.operands].imms = exp;
	i.types[i.operands++] = Imm8;
	exp->X_op = O_constant;
	exp->X_add_number = i.tm.extension_opcode;
	i.tm.extension_opcode = None;
      }
d2663 4
a2666 20
    /* For insns with operands there are more diddles to do to the opcode.  */
    if (i.operands)
      {
	/* Default segment register this instruction will use
	   for memory accesses.  0 means unknown.
	   This is only for optimizing out unnecessary segment overrides.  */
	const seg_entry *default_seg = 0;

	/* The imul $imm, %reg instruction is converted into
	   imul $imm, %reg, %reg, and the clr %reg instruction
	   is converted into xor %reg, %reg.  */
	if (i.tm.opcode_modifier & regKludge)
	  {
	    unsigned int first_reg_op = (i.types[0] & Reg) ? 0 : 1;
	    /* Pretend we saw the extra register operand.  */
	    assert (i.op[first_reg_op + 1].regs == 0);
	    i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
	    i.types[first_reg_op + 1] = i.types[first_reg_op];
	    i.reg_operands = 2;
	  }
d2668 46
a2713 81
	if (i.tm.opcode_modifier & ShortForm)
	  {
	    /* The register or float register operand is in operand 0 or 1.  */
	    unsigned int op = (i.types[0] & (Reg | FloatReg)) ? 0 : 1;
	    /* Register goes in low 3 bits of opcode.  */
	    i.tm.base_opcode |= i.op[op].regs->reg_num;
	    if (i.op[op].regs->reg_flags & RegRex)
	      i.rex.extZ = 1;
	    if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
	      {
		/* Warn about some common errors, but press on regardless.
		   The first case can be generated by gcc (<= 2.8.1).  */
		if (i.operands == 2)
		  {
		    /* Reversed arguments on faddp, fsubp, etc.  */
		    as_warn (_("translating to `%s %%%s,%%%s'"), i.tm.name,
			     i.op[1].regs->reg_name,
			     i.op[0].regs->reg_name);
		  }
		else
		  {
		    /* Extraneous `l' suffix on fp insn.  */
		    as_warn (_("translating to `%s %%%s'"), i.tm.name,
			     i.op[0].regs->reg_name);
		  }
	      }
	  }
	else if (i.tm.opcode_modifier & Modrm)
	  {
	    /* The opcode is completed (modulo i.tm.extension_opcode which
	       must be put into the modrm byte).
	       Now, we make the modrm & index base bytes based on all the
	       info we've collected.  */

	    /* i.reg_operands MUST be the number of real register operands;
	       implicit registers do not count.  */
	    if (i.reg_operands == 2)
	      {
		unsigned int source, dest;
		source = ((i.types[0]
			   & (Reg | RegMMX | RegXMM
			      | SReg2 | SReg3
			      | Control | Debug | Test))
			  ? 0 : 1);
		dest = source + 1;

		i.rm.mode = 3;
		/* One of the register operands will be encoded in the
		   i.tm.reg field, the other in the combined i.tm.mode
		   and i.tm.regmem fields.  If no form of this
		   instruction supports a memory destination operand,
		   then we assume the source operand may sometimes be
		   a memory operand and so we need to store the
		   destination in the i.rm.reg field.  */
		if ((i.tm.operand_types[dest] & AnyMem) == 0)
		  {
		    i.rm.reg = i.op[dest].regs->reg_num;
		    i.rm.regmem = i.op[source].regs->reg_num;
		    if (i.op[dest].regs->reg_flags & RegRex)
		      i.rex.extX = 1;
		    if (i.op[source].regs->reg_flags & RegRex)
		      i.rex.extZ = 1;
		  }
		else
		  {
		    i.rm.reg = i.op[source].regs->reg_num;
		    i.rm.regmem = i.op[dest].regs->reg_num;
		    if (i.op[dest].regs->reg_flags & RegRex)
		      i.rex.extZ = 1;
		    if (i.op[source].regs->reg_flags & RegRex)
		      i.rex.extX = 1;
		  }
	      }
	    else
	      {			/* If it's not 2 reg operands...  */
		if (i.mem_operands)
		  {
		    unsigned int fake_zero_displacement = 0;
		    unsigned int op = ((i.types[0] & AnyMem)
				       ? 0
				       : (i.types[1] & AnyMem) ? 1 : 2);
d2715 1
a2715 1
		    default_seg = &ds;
d2717 77
a2793 4
		    if (! i.base_reg)
		      {
			i.rm.mode = 0;
			if (! i.disp_operands)
d2795 52
a2846 127
			if (! i.index_reg)
			  {
			    /* Operand is just <disp>  */
			    if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
			      {
				i.rm.regmem = NO_BASE_REGISTER_16;
				i.types[op] &= ~Disp;
				i.types[op] |= Disp16;
			      }
			    else if (flag_code != CODE_64BIT)
			      {
				i.rm.regmem = NO_BASE_REGISTER;
				i.types[op] &= ~Disp;
				i.types[op] |= Disp32;
			      }
			    else
			      {
			        /* 64bit mode overwrites the 32bit
				   absolute addressing by RIP relative
				   addressing and absolute addressing
				   is encoded by one of the redundant
				   SIB forms.  */

				i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
				i.sib.base = NO_BASE_REGISTER;
				i.sib.index = NO_INDEX_REGISTER;
				i.types[op] &= ~Disp;
				i.types[op] |= Disp32S;
			      }
			  }
			else /* ! i.base_reg && i.index_reg  */
			  {
			    i.sib.index = i.index_reg->reg_num;
			    i.sib.base = NO_BASE_REGISTER;
			    i.sib.scale = i.log2_scale_factor;
			    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
			    i.types[op] &= ~Disp;
			    if (flag_code != CODE_64BIT)
			      i.types[op] |= Disp32;	/* Must be 32 bit */
			    else
			      i.types[op] |= Disp32S;
			    if (i.index_reg->reg_flags & RegRex)
			      i.rex.extY = 1;
			  }
		      }
		    /* RIP addressing for 64bit mode.  */
		    else if (i.base_reg->reg_type == BaseIndex)
		      {
			i.rm.regmem = NO_BASE_REGISTER;
			i.types[op] &= ~Disp;
			i.types[op] |= Disp32S;
			i.flags[op] = Operand_PCrel;
		      }
		    else if (i.base_reg->reg_type & Reg16)
		      {
			switch (i.base_reg->reg_num)
			  {
			  case 3: /* (%bx)  */
			    if (! i.index_reg)
			      i.rm.regmem = 7;
			    else /* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
			      i.rm.regmem = i.index_reg->reg_num - 6;
			    break;
			  case 5: /* (%bp)  */
			    default_seg = &ss;
			    if (! i.index_reg)
			      {
				i.rm.regmem = 6;
				if ((i.types[op] & Disp) == 0)
				  {
				    /* fake (%bp) into 0(%bp)  */
				    i.types[op] |= Disp8;
				    fake_zero_displacement = 1;
				  }
			      }
			    else /* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
			      i.rm.regmem = i.index_reg->reg_num - 6 + 2;
			    break;
			  default: /* (%si) -> 4 or (%di) -> 5  */
			    i.rm.regmem = i.base_reg->reg_num - 6 + 4;
			  }
			i.rm.mode = mode_from_disp_size (i.types[op]);
		      }
		    else /* i.base_reg and 32/64 bit mode  */
		      {
			if (flag_code == CODE_64BIT
			    && (i.types[op] & Disp))
			  {
			    if (i.types[op] & Disp8)
			      i.types[op] = Disp8 | Disp32S;
			    else
			      i.types[op] = Disp32S;
			  }
			i.rm.regmem = i.base_reg->reg_num;
			if (i.base_reg->reg_flags & RegRex)
			  i.rex.extZ = 1;
			i.sib.base = i.base_reg->reg_num;
			/* x86-64 ignores REX prefix bit here to avoid
			   decoder complications.  */
			if ((i.base_reg->reg_num & 7) == EBP_REG_NUM)
			  {
			    default_seg = &ss;
			    if (i.disp_operands == 0)
			      {
				fake_zero_displacement = 1;
				i.types[op] |= Disp8;
			      }
			  }
			else if (i.base_reg->reg_num == ESP_REG_NUM)
			  {
			    default_seg = &ss;
			  }
			i.sib.scale = i.log2_scale_factor;
			if (! i.index_reg)
			  {
			    /* <disp>(%esp) becomes two byte modrm
			       with no index register.  We've already
			       stored the code for esp in i.rm.regmem
			       ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.  Any
			       base register besides %esp will not use
			       the extra modrm byte.  */
			    i.sib.index = NO_INDEX_REGISTER;
#if ! SCALE1_WHEN_NO_INDEX
			    /* Another case where we force the second
			       modrm byte.  */
			    if (i.log2_scale_factor)
			      i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
d2848 59
a2906 10
			  }
			else
			  {
			    i.sib.index = i.index_reg->reg_num;
			    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
			    if (i.index_reg->reg_flags & RegRex)
			      i.rex.extY = 1;
			  }
			i.rm.mode = mode_from_disp_size (i.types[op]);
		      }
d2908 6
a2913 15
		    if (fake_zero_displacement)
		      {
			/* Fakes a zero displacement assuming that i.types[op]
			   holds the correct displacement size.  */
			expressionS *exp;

			assert (i.op[op].disps == 0);
			exp = &disp_expressions[i.disp_operands++];
			i.op[op].disps = exp;
			exp->X_op = O_constant;
			exp->X_add_number = 0;
			exp->X_add_symbol = (symbolS *) 0;
			exp->X_op_symbol = (symbolS *) 0;
		      }
		  }
d2915 6
a2920 33
		/* Fill in i.rm.reg or i.rm.regmem field with register
		   operand (if any) based on i.tm.extension_opcode.
		   Again, we must be careful to make sure that
		   segment/control/debug/test/MMX registers are coded
		   into the i.rm.reg field.  */
		if (i.reg_operands)
		  {
		    unsigned int op =
		      ((i.types[0]
			& (Reg | RegMMX | RegXMM
			   | SReg2 | SReg3
			   | Control | Debug | Test))
		       ? 0
		       : ((i.types[1]
			   & (Reg | RegMMX | RegXMM
			      | SReg2 | SReg3
			      | Control | Debug | Test))
			  ? 1
			  : 2));
		    /* If there is an extension opcode to put here, the
		       register number must be put into the regmem field.  */
		    if (i.tm.extension_opcode != None)
		      {
			i.rm.regmem = i.op[op].regs->reg_num;
			if (i.op[op].regs->reg_flags & RegRex)
			  i.rex.extZ = 1;
		      }
		    else
		      {
			i.rm.reg = i.op[op].regs->reg_num;
			if (i.op[op].regs->reg_flags & RegRex)
			  i.rex.extX = 1;
		      }
d2922 61
a2982 34
		    /* Now, if no memory operand has set i.rm.mode = 0, 1, 2
		       we must set it to 3 to indicate this is a register
		       operand in the regmem field.  */
		    if (!i.mem_operands)
		      i.rm.mode = 3;
		  }

		/* Fill in i.rm.reg field with extension opcode (if any).  */
		if (i.tm.extension_opcode != None)
		  i.rm.reg = i.tm.extension_opcode;
	      }
	  }
	else if (i.tm.opcode_modifier & (Seg2ShortForm | Seg3ShortForm))
	  {
	    if (i.tm.base_opcode == POP_SEG_SHORT
		&& i.op[0].regs->reg_num == 1)
	      {
		as_bad (_("you can't `pop %%cs'"));
		return;
	      }
	    i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);
	    if (i.op[0].regs->reg_flags & RegRex)
	      i.rex.extZ = 1;
	  }
	else if ((i.tm.base_opcode & ~(D|W)) == MOV_AX_DISP32)
	  {
	    default_seg = &ds;
	  }
	else if ((i.tm.opcode_modifier & IsString) != 0)
	  {
	    /* For the string instructions that allow a segment override
	       on one of their operands, the default segment is ds.  */
	    default_seg = &ds;
	  }
d2984 2
a2985 18
	/* If a segment was explicitly specified,
	   and the specified segment is not the default,
	   use an opcode prefix to select it.
	   If we never figured out what the default segment is,
	   then default_seg will be zero at this point,
	   and the specified segment prefix will always be used.  */
	if ((i.seg[0]) && (i.seg[0] != default_seg))
	  {
	    if (! add_prefix (i.seg[0]->seg_prefix))
	      return;
	  }
      }
    else if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
      {
	/* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
	as_warn (_("translating to `%sp'"), i.tm.name);
      }
  }
d2987 2
a2988 2
  /* Handle conversion of 'int $3' --> special int3 insn.  */
  if (i.tm.base_opcode == INT_OPCODE && i.op[0].imms->X_add_number == 3)
d2990 3
a2992 2
      i.tm.base_opcode = INT3_OPCODE;
      i.imm_operands = 0;
d2995 4
a2998 9
  if ((i.tm.opcode_modifier & (Jump | JumpByte | JumpDword))
      && i.op[0].disps->X_op == O_constant)
    {
      /* Convert "jmp constant" (and "call constant") to a jump (call) to
	 the absolute address given by the constant.  Since ix86 jumps and
	 calls are pc relative, we need to generate a reloc.  */
      i.op[0].disps->X_add_symbol = &abs_symbol;
      i.op[0].disps->X_op = O_symbol;
    }
d3000 6
a3005 2
  if (i.tm.opcode_modifier & Rex64)
    i.rex.mode64 = 1;
d3007 1
a3007 8
  /* For 8bit registers we would need an empty rex prefix.
     Also in the case instruction is already having prefix,
     we need to convert old registers to new ones.  */

  if (((i.types[0] & Reg8) && (i.op[0].regs->reg_flags & RegRex64))
      || ((i.types[1] & Reg8) && (i.op[1].regs->reg_flags & RegRex64))
      || ((i.rex.mode64 || i.rex.extX || i.rex.extY || i.rex.extZ || i.rex.empty)
	  && ((i.types[0] & Reg8) || (i.types[1] & Reg8))))
d3009 10
a3018 3
      int x;
      i.rex.empty = 1;
      for (x = 0; x < 2; x++)
d3020 7
a3026 8
	  /* Look for 8bit operand that does use old registers.  */
	  if (i.types[x] & Reg8
	      && !(i.op[x].regs->reg_flags & RegRex64))
	    {
	      /* In case it is "hi" register, give up.  */
	      if (i.op[x].regs->reg_num > 3)
		as_bad (_("Can't encode registers '%%%s' in the instruction requiring REX prefix.\n"),
			i.op[x].regs->reg_name);
d3028 3
a3030 3
	      /* Otherwise it is equivalent to the extended register.
	         Since the encoding don't change this is merely cosmetical
	         cleanup for debug output.  */
d3032 5
a3036 2
	      i.op[x].regs = i.op[x].regs + 8;
	    }
d3038 4
d3044 5
a3048 6
  if (i.rex.mode64 || i.rex.extX || i.rex.extY || i.rex.extZ || i.rex.empty)
    add_prefix (0x40
		| (i.rex.mode64 ? 8 : 0)
		| (i.rex.extX ? 4 : 0)
		| (i.rex.extY ? 2 : 0)
		| (i.rex.extZ ? 1 : 0));
d3050 2
a3051 3
  /* We are ready to output the insn.  */
  {
    register char *p;
d3053 2
a3054 4
    /* Tie dwarf2 debug info to the address at the start of the insn.
       We can't do this after the insn has been output as the current
       frag may have been closed off.  eg. by frag_var.  */
    dwarf2_emit_insn (0);
d3056 2
a3057 5
    /* Output jumps.  */
    if (i.tm.opcode_modifier & Jump)
      {
	int code16;
	int prefix;
d3059 6
a3064 3
	code16 = 0;
	if (flag_code == CODE_16BIT)
	  code16 = CODE16;
d3066 7
a3072 19
	prefix = 0;
	if (i.prefix[DATA_PREFIX])
	  {
	    prefix = 1;
	    i.prefixes -= 1;
	    code16 ^= CODE16;
	  }
	/* Pentium4 branch hints.  */
	if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
	    || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	  {
	    prefix++;
	    i.prefixes--;
	  }
	if (i.prefix[REX_PREFIX])
	  {
	    prefix++;
	    i.prefixes--;
	  }
d3074 3
a3076 2
	if (i.prefixes != 0 && !intel_syntax)
	  as_warn (_("skipping prefixes on this instruction"));
d3078 12
a3089 33
	/* It's always a symbol;  End frag & setup for relax.
	   Make sure there is enough room in this frag for the largest
	   instruction we may generate in md_convert_frag.  This is 2
	   bytes for the opcode and room for the prefix and largest
	   displacement.  */
	frag_grow (prefix + 2 + 4);
	/* Prefix and 1 opcode byte go in fr_fix.  */
	p = frag_more (prefix + 1);
	if (i.prefix[DATA_PREFIX])
	  *p++ = DATA_PREFIX_OPCODE;
	if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE
	    || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE)
	  *p++ = i.prefix[SEG_PREFIX];
	if (i.prefix[REX_PREFIX])
	  *p++ = i.prefix[REX_PREFIX];
	*p = i.tm.base_opcode;
	/* 1 possible extra opcode + displacement go in var part.
	   Pass reloc in fr_var.  */
	frag_var (rs_machine_dependent,
		  1 + 4,
		  i.reloc[0],
		  ((unsigned char) *p == JUMP_PC_RELATIVE
		   ? ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL) | code16
		   : ((cpu_arch_flags & Cpu386) != 0
		      ? ENCODE_RELAX_STATE (COND_JUMP, SMALL) | code16
		      : ENCODE_RELAX_STATE (COND_JUMP86, SMALL) | code16)),
		  i.op[0].disps->X_add_symbol,
		  i.op[0].disps->X_add_number,
		  p);
      }
    else if (i.tm.opcode_modifier & (JumpByte | JumpDword))
      {
	int size;
d3091 3
a3093 20
	if (i.tm.opcode_modifier & JumpByte)
	  {
	    /* This is a loop or jecxz type instruction.  */
	    size = 1;
	    if (i.prefix[ADDR_PREFIX])
	      {
		FRAG_APPEND_1_CHAR (ADDR_PREFIX_OPCODE);
		i.prefixes -= 1;
	      }
	    /* Pentium4 branch hints.  */
	    if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
		|| i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	      {
		FRAG_APPEND_1_CHAR (i.prefix[SEG_PREFIX]);
		i.prefixes--;
	      }
	  }
	else
	  {
	    int code16;
d3095 2
a3096 3
	    code16 = 0;
	    if (flag_code == CODE_16BIT)
	      code16 = CODE16;
d3098 2
a3099 6
	    if (i.prefix[DATA_PREFIX])
	      {
		FRAG_APPEND_1_CHAR (DATA_PREFIX_OPCODE);
		i.prefixes -= 1;
		code16 ^= CODE16;
	      }
d3101 2
a3102 4
	    size = 4;
	    if (code16)
	      size = 2;
	  }
d3104 2
a3105 5
	if (i.prefix[REX_PREFIX])
	  {
	    FRAG_APPEND_1_CHAR (i.prefix[REX_PREFIX]);
	    i.prefixes -= 1;
	  }
d3107 4
a3110 2
	if (i.prefixes != 0 && !intel_syntax)
	  as_warn (_("skipping prefixes on this instruction"));
d3112 17
a3128 2
	p = frag_more (1 + size);
	*p++ = i.tm.base_opcode;
a3129 12
	fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		     i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
      }
    else if (i.tm.opcode_modifier & JumpInterSegment)
      {
	int size;
	int prefix;
	int code16;

	code16 = 0;
	if (flag_code == CODE_16BIT)
	  code16 = CODE16;
d3131 5
a3135 12
	prefix = 0;
	if (i.prefix[DATA_PREFIX])
	  {
	    prefix = 1;
	    i.prefixes -= 1;
	    code16 ^= CODE16;
	  }
	if (i.prefix[REX_PREFIX])
	  {
	    prefix++;
	    i.prefixes -= 1;
	  }
d3137 37
a3173 3
	size = 4;
	if (code16)
	  size = 2;
d3175 12
a3186 2
	if (i.prefixes != 0 && !intel_syntax)
	  as_warn (_("skipping prefixes on this instruction"));
d3188 25
a3212 2
	/* 1 opcode; 2 segment; offset  */
	p = frag_more (prefix + 1 + 2 + size);
d3214 2
a3215 2
	if (i.prefix[DATA_PREFIX])
	  *p++ = DATA_PREFIX_OPCODE;
d3217 3
a3219 2
	if (i.prefix[REX_PREFIX])
	  *p++ = i.prefix[REX_PREFIX];
d3221 7
a3227 4
	*p++ = i.tm.base_opcode;
	if (i.op[1].imms->X_op == O_constant)
	  {
	    offsetT n = i.op[1].imms->X_add_number;
d3229 7
a3235 21
	    if (size == 2
		&& !fits_in_unsigned_word (n)
		&& !fits_in_signed_word (n))
	      {
		as_bad (_("16-bit jump out of range"));
		return;
	      }
	    md_number_to_chars (p, n, size);
	  }
	else
	  fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		       i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
	if (i.op[0].imms->X_op != O_constant)
	  as_bad (_("can't handle non absolute segment in `%s'"),
		  i.tm.name);
	md_number_to_chars (p + size, (valueT) i.op[0].imms->X_add_number, 2);
      }
    else
      {
	/* Output normal instructions here.  */
	unsigned char *q;
d3237 8
a3244 16
	/* All opcodes on i386 have eighter 1 or 2 bytes.  We may use third
	   byte for the SSE instructions to specify prefix they require.  */
	if (i.tm.base_opcode & 0xff0000)
	  add_prefix ((i.tm.base_opcode >> 16) & 0xff);

	/* The prefix bytes.  */
	for (q = i.prefix;
	     q < i.prefix + sizeof (i.prefix) / sizeof (i.prefix[0]);
	     q++)
	  {
	    if (*q)
	      {
		p = frag_more (1);
		md_number_to_chars (p, (valueT) *q, 1);
	      }
	  }
d3246 28
a3273 42
	/* Now the opcode; be careful about word order here!  */
	if (fits_in_unsigned_byte (i.tm.base_opcode))
	  {
	    FRAG_APPEND_1_CHAR (i.tm.base_opcode);
	  }
	else
	  {
	    p = frag_more (2);
	    /* Put out high byte first: can't use md_number_to_chars!  */
	    *p++ = (i.tm.base_opcode >> 8) & 0xff;
	    *p = i.tm.base_opcode & 0xff;
	  }

	/* Now the modrm byte and sib byte (if present).  */
	if (i.tm.opcode_modifier & Modrm)
	  {
	    p = frag_more (1);
	    md_number_to_chars (p,
				(valueT) (i.rm.regmem << 0
					  | i.rm.reg << 3
					  | i.rm.mode << 6),
				1);
	    /* If i.rm.regmem == ESP (4)
	       && i.rm.mode != (Register mode)
	       && not 16 bit
	       ==> need second modrm byte.  */
	    if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING
		&& i.rm.mode != 3
		&& !(i.base_reg && (i.base_reg->reg_type & Reg16) != 0))
	      {
		p = frag_more (1);
		md_number_to_chars (p,
				    (valueT) (i.sib.base << 0
					      | i.sib.index << 3
					      | i.sib.scale << 6),
				    1);
	      }
	  }

	if (i.disp_operands)
	  {
	    register unsigned int n;
d3275 2
a3276 5
	    for (n = 0; n < i.operands; n++)
	      {
		if (i.types[n] & Disp)
		  {
		    if (i.op[n].disps->X_op == O_constant)
d3278 1
a3278 5
			int size;
			offsetT val;

			size = 4;
			if (i.types[n] & (Disp8 | Disp16 | Disp64))
d3280 5
a3284 5
			    size = 2;
			    if (i.types[n] & Disp8)
			      size = 1;
			    if (i.types[n] & Disp64)
			      size = 8;
d3286 1
a3286 4
			val = offset_in_range (i.op[n].disps->X_add_number,
					       size);
			p = frag_more (size);
			md_number_to_chars (p, val, size);
d3288 15
a3302 13
		    else
		      {
			int size = 4;
			int sign = 0;
			int pcrel = (i.flags[n] & Operand_PCrel) != 0;

			/* The PC relative address is computed relative
			   to the instruction boundary, so in case immediate
			   fields follows, we need to adjust the value.  */
			if (pcrel && i.imm_operands)
			  {
			    int imm_size = 4;
			    register unsigned int n1;
d3304 13
a3316 18
			    for (n1 = 0; n1 < i.operands; n1++)
			      if (i.types[n1] & Imm)
				{
				  if (i.types[n1] & (Imm8 | Imm8S | Imm16 | Imm64))
				    {
				      imm_size = 2;
				      if (i.types[n1] & (Imm8 | Imm8S))
					imm_size = 1;
				      if (i.types[n1] & Imm64)
					imm_size = 8;
				    }
				  break;
				}
			    /* We should find the immediate.  */
			    if (n1 == i.operands)
			      abort ();
			    i.op[n].disps->X_add_number -= imm_size;
			  }
d3318 5
a3322 2
			if (i.types[n] & Disp32S)
			  sign = 1;
d3324 6
a3329 6
			if (i.types[n] & (Disp16 | Disp64))
			  {
			    size = 2;
			    if (i.types[n] & Disp64)
			      size = 8;
			  }
d3331 13
a3343 8
			p = frag_more (size);
			fix_new_exp (frag_now, p - frag_now->fr_literal, size,
				     i.op[n].disps, pcrel,
				     reloc (size, pcrel, sign, i.reloc[n]));
		      }
		  }
	      }
	  }
d3345 7
a3351 4
	/* Output immediate.  */
	if (i.imm_operands)
	  {
	    register unsigned int n;
d3353 8
a3360 8
	    for (n = 0; n < i.operands; n++)
	      {
		if (i.types[n] & Imm)
		  {
		    if (i.op[n].imms->X_op == O_constant)
		      {
			int size;
			offsetT val;
d3362 35
a3396 35
			size = 4;
			if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
			  {
			    size = 2;
			    if (i.types[n] & (Imm8 | Imm8S))
			      size = 1;
			    else if (i.types[n] & Imm64)
			      size = 8;
			  }
			val = offset_in_range (i.op[n].imms->X_add_number,
					       size);
			p = frag_more (size);
			md_number_to_chars (p, val, size);
		      }
		    else
		      {
			/* Not absolute_section.
			   Need a 32-bit fixup (don't support 8bit
			   non-absolute imms).  Try to support other
			   sizes ...  */
			RELOC_ENUM reloc_type;
			int size = 4;
			int sign = 0;

			if ((i.types[n] & (Imm32S))
			    && i.suffix == QWORD_MNEM_SUFFIX)
			  sign = 1;
			if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
			  {
			    size = 2;
			    if (i.types[n] & (Imm8 | Imm8S))
			      size = 1;
			    if (i.types[n] & Imm64)
			      size = 8;
			  }
d3398 2
a3399 2
			p = frag_more (size);
			reloc_type = reloc (size, 0, sign, i.reloc[n]);
d3401 72
a3472 15
			if (reloc_type == BFD_RELOC_32
			    && GOT_symbol
			    && GOT_symbol == i.op[n].imms->X_add_symbol
			    && (i.op[n].imms->X_op == O_symbol
				|| (i.op[n].imms->X_op == O_add
				    && ((symbol_get_value_expression
					 (i.op[n].imms->X_op_symbol)->X_op)
					== O_subtract))))
			  {
			    /* We don't support dynamic linking on x86-64 yet.  */
			    if (flag_code == CODE_64BIT)
			      abort ();
			    reloc_type = BFD_RELOC_386_GOTPC;
			    i.op[n].imms->X_add_number += 3;
			  }
d3474 5
a3478 15
			fix_new_exp (frag_now, p - frag_now->fr_literal, size,
				     i.op[n].imms, 0, reloc_type);
		      }
		  }
	      }
	  }
      }

#ifdef DEBUG386
    if (flag_debug)
      {
	pi (line, &i);
      }
#endif /* DEBUG386  */
  }
d3503 13
a3515 4
    { "PLT",      { BFD_RELOC_386_PLT32,  0, BFD_RELOC_X86_64_PLT32    } },
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF, 0, 0                         } },
    { "GOTPCREL", { 0,                    0, BFD_RELOC_X86_64_GOTPCREL } },
    { "GOT",      { BFD_RELOC_386_GOT32,  0, BFD_RELOC_X86_64_GOT32    } }
d3529 1
a3529 1
      if (strncmp (cp + 1, gotrel[j].str, len) == 0)
d3533 2
a3534 2
	      int first;
	      char *tmpbuf;
d3537 2
d3545 2
d3548 12
a3559 1
	      tmpbuf = xmalloc (strlen (input_line_pointer));
d3562 2
a3563 3
	      strcpy (tmpbuf + first + 1, cp + 1 + len);
	      if (adjust)
		*adjust = len;
d3698 1
d3760 1
a3760 1
  if (i.log2_scale_factor != 0 && ! i.index_reg)
d3780 1
a3780 1
  register expressionS *exp;
d3788 6
a3793 1
  if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
a3794 2
  if (flag_code == CODE_64BIT)
    bigdisp = Disp64;
d3891 1
a3891 1
        i.reloc[this_operand] = BFD_RELOC_32_PCREL;
d3893 1
a3893 1
        i.reloc[this_operand] = BFD_RELOC_32;
d3913 1
d3917 5
a3921 1
      && exp_seg != undefined_section)
d3954 22
a3975 9
      /* 64bit checks.  */
      if ((i.base_reg
	   && ((i.base_reg->reg_type & Reg64) == 0)
	       && (i.base_reg->reg_type != BaseIndex
		   || i.index_reg))
	  || (i.index_reg
	      && ((i.index_reg->reg_type & (Reg64|BaseIndex))
		  != (Reg64|BaseIndex))))
	ok = 0;
d3983 2
a3984 2
	       && ((i.base_reg->reg_type & (Reg16|BaseIndex|RegRex))
		   != (Reg16|BaseIndex)))
d3986 6
a3991 6
		  && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		       != (Reg16|BaseIndex))
		      || ! (i.base_reg
			    && i.base_reg->reg_num < 6
			    && i.index_reg->reg_num >= 6
			    && i.log2_scale_factor == 0))))
d4000 2
a4001 2
		  && ((i.index_reg->reg_type & (Reg32|BaseIndex|RegRex))
		      != (Reg32|BaseIndex))))
d4018 2
a4019 2
	  if (i.types[this_operand] & (Disp16|Disp32))
	     i.types[this_operand] ^= (Disp16|Disp32);
d4338 2
a4339 2
     register fragS *fragP;
     register segT segment;
d4347 3
a4349 2
      || S_IS_EXTERNAL (fragP->fr_symbol)
      || S_IS_WEAK (fragP->fr_symbol)
d4383 2
a4384 4
	  if (no_cond_jump_promotion)
	    goto relax_guess;

	  if (size == 2)
d4404 12
a4415 2
	  if (no_cond_jump_promotion)
	    goto relax_guess;
a4436 1
 relax_guess:
d4460 1
a4460 1
     register fragS *fragP;
d4466 1
a4466 1
     register fragS *fragP;
d4469 1
a4469 1
  register unsigned char *opcode;
a4479 9
#ifdef BFD_ASSEMBLER
  /* Not needed otherwise?  */
  {
    /* Local symbols which have already been resolved have a NULL frag.  */
    fragS *sym_frag = symbol_get_frag (fragP->fr_symbol);
    if (sym_frag)
      target_address += sym_frag->fr_address;
  }
#endif
d4594 2
a4595 2
int
md_apply_fix3 (fixP, valp, seg)
a4597 1

d4599 1
a4599 2
     valueT *valp;

d4603 2
a4604 2
  register char *p = fixP->fx_where + fixP->fx_frag->fr_literal;
  valueT value = *valp;
d4626 10
a4635 9
  /* This is a hack.  There should be a better way to handle this.
     This covers for the fact that bfd_install_relocation will
     subtract the current location (for partial_inplace, PC relative
     relocations); see more below.  */
  if ((fixP->fx_r_type == BFD_RELOC_32_PCREL
       || fixP->fx_r_type == BFD_RELOC_16_PCREL
       || fixP->fx_r_type == BFD_RELOC_8_PCREL)
      && fixP->fx_addsy && !use_rela_relocations)
    {
d4647 1
a4647 1
	  segT fseg = S_GET_SEGMENT (fixP->fx_addsy);
d4649 1
a4649 1
	  if ((fseg == seg
d4651 2
a4652 5
		   && fseg != absolute_section))
	      && ! S_IS_EXTERNAL (fixP->fx_addsy)
	      && ! S_IS_WEAK (fixP->fx_addsy)
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && ! S_IS_COMMON (fixP->fx_addsy))
d4655 2
a4656 2
		 bfd_perform_relocation subtracts them out again.  I think
		 bfd_perform_relocation is broken, but I don't dare change
a4682 1
      case BFD_RELOC_386_GOTPC:
d4684 17
a4700 37
/*   This is tough to explain.  We end up with this one if we have
 * operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal
 * here is to obtain the absolute address of the GOT, and it is strongly
 * preferable from a performance point of view to avoid using a runtime
 * relocation for this.  The actual sequence of instructions often look
 * something like:
 *
 *	call	.L66
 * .L66:
 *	popl	%ebx
 *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
 *
 *   The call and pop essentially return the absolute address of
 * the label .L66 and store it in %ebx.  The linker itself will
 * ultimately change the first operand of the addl so that %ebx points to
 * the GOT, but to keep things simple, the .o file must have this operand
 * set so that it generates not the absolute address of .L66, but the
 * absolute address of itself.  This allows the linker itself simply
 * treat a GOTPC relocation as asking for a pcrel offset to the GOT to be
 * added in, and the addend of the relocation is stored in the operand
 * field for the instruction itself.
 *
 *   Our job here is to fix the operand so that it would add the correct
 * offset so that %ebx would point to itself.  The thing that is tricky is
 * that .-.L66 will point to the beginning of the instruction, so we need
 * to further modify the operand so that it will point to itself.
 * There are other cases where you have something like:
 *
 *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
 *
 * and here no correction would be required.  Internally in the assembler
 * we treat operands of this form as not being pcrel since the '.' is
 * explicitly mentioned, and I wonder whether it would simplify matters
 * to do it this way.  Who knows.  In earlier versions of the PIC patches,
 * the pcrel_adjust field was used to store the correction, but since the
 * expression is not pcrel, I felt it would be confusing to do it this
 * way.  */
a4701 2
	value -= 1;
	break;
a4705 3
      case BFD_RELOC_386_GOTOFF:
      case BFD_RELOC_X86_64_GOTPCREL:
	break;
d4710 1
a4710 1
	return 1;
d4716 1
a4716 1
  *valp = value;
a4718 3
#ifndef BFD_ASSEMBLER
  md_number_to_chars (p, value, fixP->fx_size);
#else
d4720 1
a4720 1
  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
d4722 1
d4730 1
a4731 3
#endif

  return 1;
d4794 1
a4794 1
  if (isprint (c))
d4865 7
d4920 1
a4920 1
         .stab instead of .stab.excl.  We always use .stab anyhow.  */
d4998 1
a4998 1
	return flag_code == CODE_64BIT ? "elf64-x86-64" : "elf32-i386";
d5008 42
d5117 1
a5117 1
  register int temp;
d5168 8
d5177 5
d5193 3
a5195 2
	      as_bad (_("can not do %d byte pc-relative relocation"),
		      fixp->fx_size);
d5208 3
a5210 1
	      as_bad (_("can not do %d byte relocation"), fixp->fx_size);
d5216 1
d5218 1
d5246 1
a5246 4
      if (fixp->fx_pcrel)
	rel->addend = fixp->fx_addnumber;
      else
	rel->addend = 0;
d5259 3
d5287 1
a5287 1
#else /* ! BFD_ASSEMBLER  */
d5353 1
a5353 1
#endif /* ! BFD_ASSEMBLER  */
@


1.8
log
@Permit '-' in a mnemonic.  This is needed for the new VIA C3 xmove-rng
and xcrypt-{ecb,cbc,cfb,ofb} instructions.  This chagne is placed into
the public domain, so someone get it back to FSF
@
text
@d4346 2
d4809 17
a4825 3
      rel->addend = fixp->fx_offset;
      if (fixp->fx_pcrel)
	rel->addend -= fixp->fx_size;
@


1.7
log
@Switch i386 to new binutils, i386 tools now do ELF.
RODATA_* align macros to preserve current behavior on other
archs and allow for 1G sep between beginning of exe and beginning of data
DARPA funded work.
@
text
@d927 1
@


1.6
log
@resolve conflicts.
@
text
@d160 1
a160 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD))
d178 1
a178 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD))
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 3
a4 2
   Copyright (C) 1989, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation.
d23 5
a27 6
/*
  Intel 80386 machine specific gas.
  Written by Eliot Dresselhaus (eliot@@mgm.mit.edu).
  Bugs & suggestions are completely welcome.  This is free software.
  Please help us make it better.
  */
d33 1
d56 8
a63 5
static int fits_in_signed_byte PARAMS ((long));
static int fits_in_unsigned_byte PARAMS ((long));
static int fits_in_unsigned_word PARAMS ((long));
static int fits_in_signed_word PARAMS ((long));
static int smallest_imm_type PARAMS ((long));
d65 2
a66 2
static void set_16bit_code_flag PARAMS ((int));
static void set_16bit_gcc_code_flag PARAMS((int));
d68 1
d72 8
a79 1
  PARAMS ((int, int, bfd_reloc_code_real_type));
d81 1
d84 1
a84 1
   i386_insn. */
d95 1
a95 1
    /* TM holds the template for the insn were currently assembling. */
d102 1
a102 1
    /* OPERANDS gives the number of given operands. */
d107 1
a107 1
       operands. */
d118 4
d123 1
a123 5
#ifdef BFD_ASSEMBLER
    enum bfd_reloc_code_real disp_reloc[MAX_OPERANDS];
#else
    int disp_reloc[MAX_OPERANDS];
#endif
d132 2
a133 2
       explicit segment overrides are given. */
    const seg_entry *seg[2];	/* segments for memory operands (if given) */
d144 1
d159 2
a160 2
   pre-processor is disabled, these aren't very useful */
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (TE_LINUX) && !defined(TE_FreeBSD))
d172 2
a173 2
   .line and .file directives will appear in the pre-processed output */
/* Note that input_file.c hand checks for '#' at the beginning of the
d175 2
a176 2
   #NO_APP at the beginning of its output. */
/* Also note that comments started like this one will always work if
d178 1
a178 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (TE_LINUX) && !defined(TE_FreeBSD))
d184 1
a184 1
const char line_separator_chars[] = "";
d186 2
a187 1
/* Chars that can be used to separate mant from exp in floating point nums */
d190 3
a192 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d195 1
a195 1
/* tables for lexical analysis */
d202 1
a202 1
/* lexical macros */
d210 1
a210 1
/* put here all non-digit non-letter charcters that may occur in an operand */
d216 1
a216 1
   assembler instruction). */
d218 1
a218 1
static char *save_stack_p;	/* stack pointer */
d224 1
a224 1
/* The instruction we're assembling. */
d230 1
a230 1
/* Per instruction expressionS buffers: 2 displacements & 2 immediate max. */
d233 2
a234 1
static int this_operand;	/* current operand we are working on */
d236 2
a237 1
static int flag_do_long_jump;	/* FIXME what does this do? */
d239 5
a243 1
static int flag_16bit_code;	/* 1 if we're writing 16-bit code, 0 if 32-bit */
d245 2
a246 1
static int intel_syntax = 0;	/* 1 for intel syntax, 0 if att syntax */
d248 7
a254 1
static int allow_naked_reg = 0;  /* 1 if register prefix % not required */
d256 24
a279 4
static char stackop_size = '\0';  /* Used in 16 bit gcc mode to add an l
				     suffix to call, ret, enter, leave, push,
				     and pop instructions so that gcc has the
				     same stack frame as in 32 bit mode.  */
d282 10
a291 9
   There are 2 relax states for 386 jump insns: one for conditional &
   one for unconditional jumps.  This is because these two types of
   jumps add different sizes to frags when we're figuring out what
   sort of jump to choose to reach a given label.  */

/* types */
#define COND_JUMP 1		/* conditional jump */
#define UNCOND_JUMP 2		/* unconditional jump */
/* sizes */
d306 6
a311 4
#define ENCODE_RELAX_STATE(type,size) \
  ((relax_substateT)((type<<2) | (size)))
#define SIZE_FROM_RELAX_STATE(s) \
    ( (((s) & 0x3) == BIG ? 4 : (((s) & 0x3) == BIG16 ? 2 : 1)) )
d326 8
a333 12
     3) how many bytes this mode will add to the size of the current frag
     4) which index into the table to try if we can't fit into this one.
  */
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (COND_JUMP, BIG)},
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (COND_JUMP, BIG16)},
  /* dword conditionals adds 4 bytes to frag:
     1 extra opcode byte, 3 extra displacement bytes.  */
d335 2
a336 2
  /* word conditionals add 2 bytes to frag:
     1 extra opcode byte, 1 extra displacement byte.  */
d339 8
a346 4
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG)},
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16)},
  /* dword jmp adds 3 bytes to frag:
     0 extra opcode bytes, 3 extra displacement bytes.  */
a347 3
  /* word jmp adds 1 byte to frag:
     0 extra opcode bytes, 1 extra displacement byte.  */
  {0, 0, 1, 0}
d349 9
d360 16
d382 3
a384 3
  /* Various efficient no-op patterns for aligning code labels.  */
  /* Note: Don't try to assemble the instructions in the comments. */
  /*       0L and 0w are not legal */
d449 5
d456 1
a456 1
      if (flag_16bit_code)
d458 4
a461 3
	  memcpy(fragP->fr_literal + fragP->fr_fix,
		 f16_patt[count - 1], count);
	  if (count > 8) /* adjust jump offset */
d465 2
a466 2
	memcpy(fragP->fr_literal + fragP->fr_fix,
	       f32_patt[count - 1], count);
d481 1
a481 1
symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
d487 1
a487 1
  return (t & Disp8) ? 1 : (t & (Disp16|Disp32)) ? 2 : 0;
d492 1
a492 1
     long num;
d495 1
a495 1
}				/* fits_in_signed_byte() */
d499 1
a499 1
     long num;
d502 1
a502 1
}				/* fits_in_unsigned_byte() */
d506 1
a506 1
     long num;
d509 1
a509 1
}				/* fits_in_unsigned_word() */
d513 1
a513 1
     long num;
d516 22
a537 1
}				/* fits_in_signed_word() */
d541 1
a541 1
     long num;
d543 11
a553 10
#if 0
  /* This code is disabled because all the Imm1 forms in the opcode table
     are slower on the i486, and they're the versions with the implicitly
     specified single-position displacement, which has another syntax if
     you really want to use that form.  If you really prefer to have the
     one-byte-shorter Imm1 form despite these problems, re-enable this
     code.  */
  if (num == 1)
    return Imm1 | Imm8 | Imm8S | Imm16 | Imm32;
#endif
d555 1
a555 1
	  ? (Imm8S | Imm8 | Imm16 | Imm32)
d557 1
a557 1
	  ? (Imm8 | Imm16 | Imm32)
d559 41
a599 3
	  ? (Imm16 | Imm32)
	  : (Imm32));
}				/* smallest_imm_type() */
d611 7
a617 4
  switch (prefix)
    {
    default:
      abort ();
d619 29
a647 29
    case CS_PREFIX_OPCODE:
    case DS_PREFIX_OPCODE:
    case ES_PREFIX_OPCODE:
    case FS_PREFIX_OPCODE:
    case GS_PREFIX_OPCODE:
    case SS_PREFIX_OPCODE:
      q = SEG_PREFIX;
      break;

    case REPNE_PREFIX_OPCODE:
    case REPE_PREFIX_OPCODE:
      ret = 2;
      /* fall thru */
    case LOCK_PREFIX_OPCODE:
      q = LOCKREP_PREFIX;
      break;

    case FWAIT_OPCODE:
      q = WAIT_PREFIX;
      break;

    case ADDR_PREFIX_OPCODE:
      q = ADDR_PREFIX;
      break;

    case DATA_PREFIX_OPCODE:
      q = DATA_PREFIX;
      break;
    }
d661 2
a662 2
set_16bit_code_flag (new_16bit_code_flag)
     int new_16bit_code_flag;
d664 11
a674 1
  flag_16bit_code = new_16bit_code_flag;
d679 2
a680 2
set_16bit_gcc_code_flag (new_16bit_code_flag)
     int new_16bit_code_flag;
d682 4
a685 2
  flag_16bit_code = new_16bit_code_flag;
  stackop_size = new_16bit_code_flag ? 'l' : '\0';
d701 1
a701 1
      if (strcmp(string, "prefix") == 0)
d703 1
a703 1
      else if (strcmp(string, "noprefix") == 0)
d719 2
a720 1
      allow_naked_reg = 0; /* conservative default */
d727 50
a778 3
#ifndef I386COFF
  {"bss", s_bss, 0},
#endif
d784 4
d794 4
a797 3
  {"code16gcc", set_16bit_gcc_code_flag, 1},
  {"code16", set_16bit_code_flag, 1},
  {"code32", set_16bit_code_flag, 0},
d800 2
d805 1
a805 1
/* for interface with expression () */
d808 1
a808 1
/* hash table for instruction mnemonic lookup */
d810 2
a811 1
/* hash table for register lookup */
d814 13
a826 1

d832 1
a832 1
  /* initialize op_hash hash table */
d839 2
a840 1
    optab = i386_optab;		/* setup for loop */
d851 1
a851 1
	       add to hash table; & begin anew */
a857 1
	      hash_error:
d870 1
a870 1
  /* initialize reg_hash hash table */
d881 3
a883 1
	  goto hash_error;
d887 1
a887 1
  /* fill in lexical tables:  mnemonic_chars, operand_chars.  */
a951 1

d954 1
a954 1
/* debugging routines for md_assemble */
d966 1
a966 2
  register template *p;
  int i;
d970 5
a974 1
  fprintf (stdout, "  modrm:  mode %x  reg %x  reg/mem %x",
d976 4
a979 2
  fprintf (stdout, " base %x  index %x  scale %x\n",
	   x->bi.base, x->bi.index, x->bi.scale);
d999 1
a999 1
  int i;
d1001 1
a1001 2
  fprintf (stdout, "opcode %x ",
	   t->base_opcode);
d1059 1
d1064 2
d1071 2
d1096 3
a1098 10
  if (t == Unknown)
    {
      fprintf (stdout, _("Unknown"));
    }
  else
    {
      for (ty = type_names; ty->mask; ty++)
	if (t & ty->mask)
	  fprintf (stdout, "%s, ", ty->tname);
    }
d1114 1
a1114 1
  /* For COFF */
a1119 2
static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, bfd_reloc_code_real_type));
d1122 1
a1122 1
reloc (size, pcrel, other)
d1125 1
d1128 2
a1129 1
  if (other != NO_RELOC) return other;
d1133 2
d1145 15
a1159 7
      switch (size)
	{
	case 1: return BFD_RELOC_8;
	case 2: return BFD_RELOC_16;
	case 4: return BFD_RELOC_32;
	}
      as_bad (_("can not do %d byte relocation"), size);
d1162 1
d1166 5
a1170 6
/*
 * Here we decide which fixups can be adjusted to make them relative to
 * the beginning of the section instead of the symbol.  Basically we need
 * to make sure that the dynamic relocations are done correctly, so in
 * some cases we force the original symbol to be used.
 */
d1175 1
a1175 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
d1182 1
a1182 1
  /* adjust_reloc_syms doesn't know about the GOT */
d1186 3
a1188 1
      || fixP->fx_r_type == BFD_RELOC_RVA
d1195 11
a1205 8
#define reloc(SIZE,PCREL,OTHER)	0
#define BFD_RELOC_16		0
#define BFD_RELOC_32		0
#define BFD_RELOC_16_PCREL	0
#define BFD_RELOC_32_PCREL	0
#define BFD_RELOC_386_PLT32	0
#define BFD_RELOC_386_GOT32	0
#define BFD_RELOC_386_GOTOFF	0
d1208 1
a1208 2
static int
intel_float_operand PARAMS ((char *mnemonic));
d1214 1
a1214 1
  if (mnemonic[0] == 'f' && mnemonic[1] =='i')
d1231 1
a1231 1
  /* Points to template once we've found it. */
a1233 3
  /* Count the size of the instruction generated.  */
  int insn_size = 0;

d1238 1
a1238 1
  /* Initialize globals. */
d1241 1
a1241 1
    i.disp_reloc[j] = NO_RELOC;
d1244 1
a1244 1
  save_stack_p = save_stack;	/* reset stack pointer */
d1248 1
a1248 1
     start of a (possibly prefixed) mnemonic. */
d1254 1
a1254 1
    /* Non-zero if we found a prefix only acceptable with string insns. */
d1265 1
a1265 1
		as_bad (_("no such 386 instruction: `%s'"), token_start);
d1299 1
a1299 1
		    ^ flag_16bit_code))
d1311 1
a1311 2
		expecting_string_instruction =
		  current_templates->start->name;
d1328 1
a1328 2
	  case SHORT_MNEM_SUFFIX:
	  case LONG_MNEM_SUFFIX:
d1333 9
d1343 2
a1344 2
	  /* Intel Syntax */
	  case DWORD_MNEM_SUFFIX:
d1347 4
a1350 1
		i.suffix = mnem_p[-1];
a1352 1
		break;
d1354 1
d1358 1
a1358 1
	    as_bad (_("no such 386 instruction: `%s'"), token_start);
d1363 16
a1378 1
    /* check for rep/repne without a string instruction */
d1387 1
a1387 1
    /* There may be operands to parse. */
d1390 1
a1390 3
	/* parse operands */

	/* 1 if operand is pending after ','. */
d1393 1
a1393 1
	/* Non-zero if operand parens not balanced. */
d1398 1
a1398 1
	    /* skip optional white space before operand */
d1451 1
a1451 1
	      {			/* yes, we've read in another operand */
d1460 1
a1460 1
		/* now parse operand adding info to 'i' as we go along */
d1464 3
a1466 1
		  operand_ok = i386_intel_operand (token_start, intel_float_operand (mnemonic));
d1470 1
a1470 1
		RESTORE_END_STRING (l);	/* restore old contents */
d1489 1
a1489 1
	    /* now *l must be either ',' or END_OF_INSN */
d1493 2
a1494 1
		  {		/* just skip it, if it's \n complain */
d1500 1
a1500 1
	while (*l != END_OF_INSN);	/* until we get end of insn */
d1509 1
a1509 1
     with the template operand types. */
d1541 1
d1561 3
d1589 1
a1589 1
	    for (op = i.operands; --op >= 0; )
d1596 4
d1603 1
a1603 1
	else if (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0))
d1606 2
a1607 3
	for (op = i.operands; --op >= 0; )
	  if ((i.types[op] & Imm)
	      && i.op[op].imms->X_op == O_constant)
d1609 1
a1609 2
	      /* If a suffix is given, this operand may be shortened.  */
	      switch (guess_suffix)
d1611 61
a1671 6
		case WORD_MNEM_SUFFIX:
		  i.types[op] |= Imm16;
		  break;
		case BYTE_MNEM_SUFFIX:
		  i.types[op] |= Imm16 | Imm8 | Imm8S;
		  break;
d1673 7
d1681 24
a1704 6
	      /* If this operand is at most 16 bits, convert it to a
		 signed 16 bit number before trying to see whether it will
		 fit in an even smaller size.  This allows a 16-bit operand
		 such as $0xffe0 to be recognised as within Imm8S range.  */
	      if ((i.types[op] & Imm16)
		  && (i.op[op].imms->X_add_number & ~(offsetT)0xffff) == 0)
d1706 4
a1709 2
		  i.op[op].imms->X_add_number =
		    (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
d1711 3
a1713 1
	      i.types[op] |= smallest_imm_type ((long) i.op[op].imms->X_add_number);
d1729 2
a1730 2
			     : (i.suffix == DWORD_MNEM_SUFFIX
				? No_dSuf
d1737 1
a1737 1
	/* Must have right number of operands. */
d1744 2
d1747 2
a1748 2
		 && (t->extension_opcode == 5	/* 0xd9,5 "fldcw"  */
		     || t->extension_opcode == 7))) /* 0xd9,7 "f{n}stcw"  */
d1751 1
d1753 6
a1758 1
	  break;		/* 0 operands always matches */
d1777 1
a1777 2

		/* check if other direction is valid ... */
d1781 1
a1781 1
		/* try reversing direction of operands */
d1791 1
a1791 1
		    /* does not match either direction */
a1796 1
		break;
d1798 2
a1799 2
	    /* found a forward 2 operand match here */
	    if (t->operands == 3)
d1814 7
a1820 2
	    /* found either forward/reverse 2 or 3 operand match here:
	       slip through to break */
d1822 3
a1824 2
	break;			/* we've found a match; break out of loop */
      }				/* for (t = ... */
d1826 2
a1827 1
      {				/* we found no match */
d1833 1
a1833 2
    if (!intel_syntax
	&& (i.types[0] & JumpAbsolute) != (t->operand_types[0] & JumpAbsolute))
d1835 6
a1840 2
	as_warn (_("indirect %s without `*'"), t->name);
      }
d1842 7
a1848 5
    if ((t->opcode_modifier & (IsPrefix|IgnoreSize)) == (IsPrefix|IgnoreSize))
      {
	/* Warn them that a data or address size prefix doesn't affect
	   assembly of the next line of code.  */
	as_warn (_("stand-alone `%s' prefix"), t->name);
d1866 4
a1869 4
     if (SYSV386_COMPAT
	 && intel_syntax
	 && (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
       i.tm.base_opcode ^= FloatR;
d1875 1
a1875 1
    /* Check string instruction segment overrides */
d1906 13
d1921 1
a1921 1
    if (i.tm.opcode_modifier & (Size16 | Size32))
d1925 2
d1933 1
a1933 1
	   based on register operands. */
d1940 1
a1940 1
	    for (op = i.operands; --op >= 0; )
d1946 1
d1954 1
a1954 1
	    for (op = i.operands; --op >= 0; )
d1958 1
a1958 1
		   we will just use the low portion, and that's OK too. */
d1962 1
a1962 1
		/* movzx and movsx should not generate this warning. */
d1966 1
d1980 7
d1988 2
a1989 1
		    if ((i.tm.operand_types[op] & InOutPortReg) == 0)
d1991 4
a1994 1
			       (i.op[op].regs - (i.types[op] & Reg16 ? 8 : 16))->reg_name,
d2000 1
a2000 1
		/* Any other register is bad */
d2017 45
a2073 1
#if REGISTER_WARNINGS
d2075 2
a2076 1
	      else if ((i.types[op] & Reg16) != 0
d2079 5
a2083 4
		  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			   (i.op[op].regs + 8)->reg_name,
			   i.op[op].regs->reg_name,
			   i.suffix);
a2084 1
#endif
d2089 1
a2089 1
	    for (op = i.operands; --op >= 0; )
a2100 1
#if REGISTER_WARNINGS
d2102 2
a2103 1
	      else if ((i.types[op] & Reg32) != 0
d2106 13
a2118 4
		  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			   (i.op[op].regs - 8)->reg_name,
			   i.op[op].regs->reg_name,
			   i.suffix);
a2119 1
#endif
d2121 3
d2125 1
a2125 1
	  abort();
a2130 1

d2133 1
a2133 1
    if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32))
d2135 2
a2136 1
	&& overlap0 != Imm16 && overlap0 != Imm32)
d2141 2
a2142 1
			 (i.suffix == WORD_MNEM_SUFFIX ? Imm16 : Imm32));
d2144 3
a2146 1
	else if (overlap0 == (Imm16 | Imm32))
d2149 1
a2149 1
	      (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32;
d2151 3
a2153 1
	else
d2159 1
a2159 1
    if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32))
d2161 2
a2162 1
	&& overlap1 != Imm16 && overlap1 != Imm32)
d2167 2
a2168 1
			 (i.suffix == WORD_MNEM_SUFFIX ? Imm16 : Imm32));
d2170 3
a2172 1
	else if (overlap1 == (Imm16 | Imm32))
d2175 1
a2175 1
	      (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32;
d2177 3
a2179 1
	else
d2181 1
a2181 1
	    as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
d2191 1
a2191 1
      i.imm_operands = 0;	/* kludge for shift insns */
d2210 1
a2210 1
    /* For movzx and movsx, need to check the register type */
d2235 2
a2236 2
	if (((intel_syntax && (i.suffix == DWORD_MNEM_SUFFIX))
	     || i.suffix == LONG_MNEM_SUFFIX) == flag_16bit_code
d2246 13
d2260 1
a2260 2
	if (i.suffix == LONG_MNEM_SUFFIX
	    || (intel_syntax && i.suffix == DWORD_MNEM_SUFFIX))
d2276 1
a2276 1
	assert(i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);
d2286 1
a2286 1
    /* For insns with operands there are more diddles to do to the opcode. */
d2300 4
a2303 4
	    /* Pretend we saw the extra register operand. */
	    assert (i.op[first_reg_op+1].regs == 0);
	    i.op[first_reg_op+1].regs = i.op[first_reg_op].regs;
	    i.types[first_reg_op+1] = i.types[first_reg_op];
d2309 1
a2309 1
	    /* The register or float register operand is in operand 0 or 1. */
d2311 1
a2311 1
	    /* Register goes in low 3 bits of opcode. */
d2313 3
a2315 1
	    if ((i.tm.opcode_modifier & Ugh) != 0)
d2321 1
a2321 1
		    /* reversed arguments on faddp, fsubp, etc. */
d2328 1
a2328 1
		    /* extraneous `l' suffix on fp insn */
d2339 1
a2339 1
	       info we've collected. */
d2342 1
a2342 1
	       implicit registers do not count. */
d2365 4
d2374 4
d2381 1
a2381 1
	      {			/* if it's not 2 reg operands... */
d2398 2
a2399 2
			    /* Operand is just <disp> */
			    if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0))
d2405 1
a2405 1
			    else
d2411 14
d2426 1
a2426 1
			else /* ! i.base_reg && i.index_reg */
d2433 6
a2438 1
			    i.types[op] |= Disp32;	/* Must be 32 bit */
d2441 8
d2453 1
a2453 1
			  case 3: /* (%bx) */
d2456 1
a2456 1
			    else /* (%bx,%si) -> 0, or (%bx,%di) -> 1 */
d2459 1
a2459 1
			  case 5: /* (%bp) */
d2466 1
a2466 1
				    /* fake (%bp) into 0(%bp) */
d2471 1
a2471 1
			    else /* (%bp,%si) -> 2, or (%bp,%di) -> 3 */
d2474 1
a2474 1
			  default: /* (%si) -> 4 or (%di) -> 5 */
d2479 1
a2479 1
		    else /* i.base_reg and 32 bit mode */
d2481 8
d2490 2
d2493 3
a2495 1
			if (i.base_reg->reg_num == EBP_REG_NUM)
d2529 2
d2538 1
a2538 1
			   holds the correct displacement size. */
d2555 1
a2555 1
		   into the i.rm.reg field. */
d2571 1
a2571 1
		       register number must be put into the regmem field. */
d2573 5
a2577 1
		      i.rm.regmem = i.op[op].regs->reg_num;
d2579 5
a2583 1
		      i.rm.reg = i.op[op].regs->reg_num;
d2592 1
a2592 1
		/* Fill in i.rm.reg field with extension opcode (if any). */
d2599 2
a2600 1
	    if (i.tm.base_opcode == POP_SEG_SHORT && i.op[0].regs->reg_num == 1)
d2606 2
d2632 1
a2632 1
    else if ((i.tm.opcode_modifier & Ugh) != 0)
d2639 1
a2639 1
  /* Handle conversion of 'int $3' --> special int3 insn. */
d2656 42
a2697 1
  /* We are ready to output the insn. */
d2701 6
a2706 1
    /* Output jumps. */
a2708 1
	int size;
d2713 1
a2713 1
	if (flag_16bit_code)
d2723 12
a2734 4

	size = 4;
	if (code16)
	  size = 2;
d2744 1
a2744 2
	frag_grow (prefix + 2 + size);
	insn_size += prefix + 1;
d2747 1
a2747 1
	if (prefix)
d2749 5
d2758 2
a2759 2
		  1 + size,
		  i.disp_reloc[0],
d2762 3
a2764 1
		   : ENCODE_RELAX_STATE (COND_JUMP, SMALL) | code16),
a2778 1
		insn_size += 1;
d2782 7
d2795 1
a2795 1
	    if (flag_16bit_code)
a2799 1
		insn_size += 1;
d2810 6
d2819 2
a2820 13
	if (fits_in_unsigned_byte (i.tm.base_opcode))
	  {
	    insn_size += 1 + size;
	    p = frag_more (1 + size);
	  }
	else
	  {
	    /* opcode can be at most two bytes */
	    insn_size += 2 + size;
	    p = frag_more (2 + size);
	    *p++ = (i.tm.base_opcode >> 8) & 0xff;
	  }
	*p++ = i.tm.base_opcode & 0xff;
d2823 1
a2823 1
		     i.op[0].disps, 1, reloc (size, 1, i.disp_reloc[0]));
d2832 1
a2832 1
	if (flag_16bit_code)
d2842 5
d2855 1
a2855 1
	insn_size += prefix + 1 + 2 + size;  /* 1 opcode; 2 segment; offset */
d2857 2
a2858 1
	if (prefix)
d2860 4
d2867 1
a2867 1
	    long n = (long) i.op[1].imms->X_add_number;
d2876 1
a2876 1
	    md_number_to_chars (p, (valueT) n, size);
d2880 1
a2880 1
		       i.op[1].imms, 0, reloc (size, 0, i.disp_reloc[0]));
d2888 1
a2888 1
	/* Output normal instructions here. */
d2891 6
a2896 1
	/* The prefix bytes. */
a2902 1
		insn_size += 1;
d2908 1
a2908 1
	/* Now the opcode; be careful about word order here! */
a2910 1
	    insn_size += 1;
d2913 1
a2913 1
	else if (fits_in_unsigned_word (i.tm.base_opcode))
a2914 1
	    insn_size += 2;
d2916 1
a2916 1
	    /* put out high byte first: can't use md_number_to_chars! */
a2919 17
	else
	  {			/* opcode is either 3 or 4 bytes */
	    if (i.tm.base_opcode & 0xff000000)
	      {
		insn_size += 4;
		p = frag_more (4);
		*p++ = (i.tm.base_opcode >> 24) & 0xff;
	      }
	    else
	      {
		insn_size += 3;
		p = frag_more (3);
	      }
	    *p++ = (i.tm.base_opcode >> 16) & 0xff;
	    *p++ = (i.tm.base_opcode >> 8) & 0xff;
	    *p = (i.tm.base_opcode) & 0xff;
	  }
a2923 1
	    insn_size += 1;
a2937 1
		insn_size += 1;
d2957 2
a2958 2
			int size = 4;
			long val = (long) i.op[n].disps->X_add_number;
d2960 2
a2961 1
			if (i.types[n] & (Disp8 | Disp16))
a2962 2
			    long mask;

a2963 1
			    mask = ~ (long) 0xffff;
d2965 3
a2967 8
			      {
				size = 1;
				mask = ~ (long) 0xff;
			      }

			    if ((val & mask) != 0 && (val & mask) != mask)
			      as_warn (_("%ld shortened to %ld"),
				       val, val & ~mask);
d2969 2
a2970 1
			insn_size += size;
d2972 1
a2972 1
			md_number_to_chars (p, (valueT) val, size);
d2977 10
d2988 28
a3015 2
			if (i.types[n] & Disp16)
			  size = 2;
a3016 1
			insn_size += size;
d3019 2
a3020 2
				     i.op[n].disps, 0,
				     reloc (size, 0, i.disp_reloc[n]));
d3024 1
a3024 1
	  }			/* end displacement output */
d3026 1
a3026 1
	/* output immediate */
d3037 2
a3038 2
			int size = 4;
			long val = (long) i.op[n].imms->X_add_number;
d3040 2
a3041 1
			if (i.types[n] & (Imm8 | Imm8S | Imm16))
a3042 2
			    long mask;

a3043 1
			    mask = ~ (long) 0xffff;
d3045 3
a3047 7
			      {
				size = 1;
				mask = ~ (long) 0xff;
			      }
			    if ((val & mask) != 0 && (val & mask) != mask)
			      as_warn (_("%ld shortened to %ld"),
				       val, val & ~mask);
d3049 2
a3050 1
			insn_size += size;
d3052 1
a3052 1
			md_number_to_chars (p, (valueT) val, size);
d3055 3
a3057 2
		      {		/* not absolute_section */
			/* Need a 32-bit fixup (don't support 8bit
d3059 2
a3060 6
			   sizes ... */
#ifdef BFD_ASSEMBLER
			enum bfd_reloc_code_real reloc_type;
#else
			int reloc_type;
#endif
d3062 1
d3064 11
a3074 4
			if (i.types[n] & Imm16)
			  size = 2;
			else if (i.types[n] & (Imm8 | Imm8S))
			  size = 1;
a3075 1
			insn_size += size;
d3077 1
a3077 1
			reloc_type = reloc (size, 0, i.disp_reloc[0]);
d3088 3
d3100 1
a3100 1
	  }			/* end immediate output */
d3108 1
a3108 1
#endif /* DEBUG386 */
d3112 124
d3243 3
d3247 1
a3247 1
  expressionS * exp;
d3265 3
a3267 51
  {
    /*
     * We can have operands of the form
     *   <symbol>@@GOTOFF+<nnn>
     * Take the easy way out here and copy everything
     * into a temporary buffer...
     */
    register char *cp;

    cp = strchr (input_line_pointer, '@@');
    if (cp != NULL)
      {
	char *tmpbuf;
	int len = 0;
	int first;

	/* GOT relocations are not supported in 16 bit mode */
	if (flag_16bit_code)
	  as_bad (_("GOT relocations not supported in 16 bit mode"));

	if (GOT_symbol == NULL)
	  GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	if (strncmp (cp + 1, "PLT", 3) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
	    len = 3;
	  }
	else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
	    len = 6;
	  }
	else if (strncmp (cp + 1, "GOT", 3) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
	    len = 3;
	  }
	else
	  as_bad (_("bad reloc specifier in expression"));

	/* Replace the relocation token with ' ', so that errors like
	   foo@@GOTOFF1 will be detected.  */
	first = cp - input_line_pointer;
	tmpbuf = (char *) alloca (strlen(input_line_pointer));
	memcpy (tmpbuf, input_line_pointer, first);
	tmpbuf[first] = ' ';
	strcpy (tmpbuf + first + 1, cp + 1 + len);
	input_line_pointer = tmpbuf;
      }
  }
d3274 1
a3274 1
    as_bad (_("ignoring junk `%s' after expression"), input_line_pointer);
d3277 4
d3284 1
a3284 1
      /* missing or bad expr becomes absolute 0 */
d3292 1
a3292 2

  if (exp->X_op == O_constant)
d3294 6
a3299 1
      i.types[this_operand] |= Imm32;	/* Size it properly later.  */
d3302 1
a3302 1
  else if (
d3304 1
a3304 1
	   OUTPUT_FLAVOR == bfd_target_aout_flavour &&
d3306 1
a3306 1
	   exp_seg != text_section
d3327 2
a3328 4
	 suffix, or the default for the section.  We exclude
	 Imm8S here so that `push $foo' and other instructions
	 with an Imm8S form will use Imm16 or Imm32.  */
      i.types[this_operand] |= (Imm8 | Imm16 | Imm32);
d3334 1
a3334 1
static int i386_scale PARAMS ((char *));
d3336 1
a3336 1
static int
d3340 2
a3341 2
  if (!isdigit (*scale))
    goto bad_scale;
d3343 4
a3346 1
  switch (*scale)
d3348 2
a3349 2
    case '0':
    case '1':
d3352 1
a3352 1
    case '2':
d3355 1
a3355 1
    case '4':
d3358 1
a3358 1
    case '8':
a3361 1
    bad_scale:
d3364 2
a3365 1
      return 0;
d3375 3
a3377 1
  return 1;
d3390 3
d3395 1
a3395 1
  if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0))
d3397 2
d3447 1
a3447 2
	 So here we provide the missing zero.
      */
d3453 4
a3456 8
  {
    /*
     * We can have operands of the form
     *   <symbol>@@GOTOFF+<nnn>
     * Take the easy way out here and copy everything
     * into a temporary buffer...
     */
    register char *cp;
d3458 1
a3458 6
    cp = strchr (input_line_pointer, '@@');
    if (cp != NULL)
      {
	char *tmpbuf;
	int len = 0;
	int first;
d3460 11
a3470 35
	/* GOT relocations are not supported in 16 bit mode */
	if (flag_16bit_code)
	  as_bad (_("GOT relocations not supported in 16 bit mode"));

	if (GOT_symbol == NULL)
	  GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	if (strncmp (cp + 1, "PLT", 3) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
	    len = 3;
	  }
	else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
	    len = 6;
	  }
	else if (strncmp (cp + 1, "GOT", 3) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
	    len = 3;
	  }
	else
	  as_bad (_("bad reloc specifier in expression"));

	/* Replace the relocation token with ' ', so that errors like
	   foo@@GOTOFF1 will be detected.  */
	first = cp - input_line_pointer;
	tmpbuf = (char *) alloca (strlen(input_line_pointer));
	memcpy (tmpbuf, input_line_pointer, first);
	tmpbuf[first] = ' ';
	strcpy (tmpbuf + first + 1, cp + 1 + len);
	input_line_pointer = tmpbuf;
      }
  }
a3472 2
  exp_seg = expression (exp);

d3476 3
a3478 2
     to be relative to the beginning of the section */
  if (i.disp_reloc[this_operand] == BFD_RELOC_386_GOTOFF)
d3480 10
a3489 1
      if (S_IS_LOCAL(exp->X_add_symbol)
a3491 1
      assert (exp->X_op == O_symbol);
d3494 4
a3497 1
      i.disp_reloc[this_operand] = BFD_RELOC_32;
a3500 10
  SKIP_WHITESPACE ();
  if (*input_line_pointer)
    as_bad (_("ignoring junk `%s' after expression"),
	    input_line_pointer);
#if GCC_ASM_O_HACK
  RESTORE_END_STRING (disp_end + 1);
#endif
  RESTORE_END_STRING (disp_end);
  input_line_pointer = save_input_line_pointer;

d3503 1
a3503 1
      /* missing or bad expr becomes absolute 0 */
a3511 13
  if (exp->X_op == O_constant)
    {
      if (i.types[this_operand] & Disp16)
	{
	  /* We know this operand is at most 16 bits, so convert to a
	     signed 16 bit number before trying to see whether it will
	     fit in an even smaller size.  */
	  exp->X_add_number =
	    (((exp->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
	}
      if (fits_in_signed_byte (exp->X_add_number))
	i.types[this_operand] |= Disp8;
    }
d3513 1
a3513 1
  else if (
d3515 1
a3515 1
	   OUTPUT_FLAVOR == bfd_target_aout_flavour &&
d3517 4
a3520 4
	   exp_seg != text_section
	   && exp_seg != data_section
	   && exp_seg != bss_section
	   && exp_seg != undefined_section)
d3530 2
d3535 4
a3538 1
static int i386_operand_modifier PARAMS ((char **, int));
d3541 2
a3542 3
i386_operand_modifier (op_string, got_a_float)
     char **op_string;
     int got_a_float;
d3544 8
a3551 1
  if (!strncasecmp (*op_string, "BYTE PTR", 8))
d3553 9
a3561 4
      i.suffix = BYTE_MNEM_SUFFIX;
      *op_string += 8;
      return BYTE_PTR;

d3563 1
a3563 1
  else if (!strncasecmp (*op_string, "WORD PTR", 8))
d3565 15
a3579 2
      if (got_a_float == 2)	/* "fi..." */
	i.suffix = SHORT_MNEM_SUFFIX;
d3581 9
a3589 3
	i.suffix = WORD_MNEM_SUFFIX;
      *op_string += 8;
      return WORD_PTR;
d3591 1
a3591 2

  else if (!strncasecmp (*op_string, "DWORD PTR", 9))
d3593 19
a3611 2
      if (got_a_float == 1)	/* "f..." */
	i.suffix = SHORT_MNEM_SUFFIX;
d3613 5
a3617 3
	i.suffix = LONG_MNEM_SUFFIX;
      *op_string += 9;
      return DWORD_PTR;
d3619 2
d3622 2
a3623 6
  else if (!strncasecmp (*op_string, "QWORD PTR", 9))
    {
      i.suffix = DWORD_MNEM_SUFFIX;
      *op_string += 9;
      return QWORD_PTR;
    }
d3625 7
a3631 6
  else if (!strncasecmp (*op_string, "XWORD PTR", 9))
    {
      i.suffix = LONG_DOUBLE_MNEM_SUFFIX;
      *op_string += 9;
      return XWORD_PTR;
    }
d3633 2
a3634 5
  else if (!strncasecmp (*op_string, "SHORT", 5))
    {
      *op_string += 5;
      return SHORT;
    }
d3636 3
a3638 1
  else if (!strncasecmp (*op_string, "OFFSET FLAT:", 12))
d3640 4
a3643 2
      *op_string += 12;
      return OFFSET_FLAT;
d3646 3
a3648 1
  else if (!strncasecmp (*op_string, "FLAT", 4))
d3650 6
a3655 51
      *op_string += 4;
      return FLAT;
    }

  else return NONE_FOUND;
}

static char * build_displacement_string PARAMS ((int, char *));

static char *
build_displacement_string (initial_disp, op_string)
     int initial_disp;
     char *op_string;
{
  char *temp_string = (char *) malloc (strlen (op_string) + 1);
  char *end_of_operand_string;
  char *tc;
  char *temp_disp;

  temp_string[0] = '\0';
  tc = end_of_operand_string = strchr (op_string, '[');
  if (initial_disp && !end_of_operand_string)
    {
      strcpy (temp_string, op_string);
      return temp_string;
    }

  /* Build the whole displacement string */
  if (initial_disp)
    {
      strncpy (temp_string, op_string, end_of_operand_string - op_string);
      temp_string[end_of_operand_string - op_string] = '\0';
      temp_disp = tc;
    }
  else
    temp_disp = op_string;

  while (*temp_disp != '\0')
    {
      char *end_op;
      int add_minus = (*temp_disp == '-');

      if (*temp_disp == '+' || *temp_disp == '-' || *temp_disp == '[')
	temp_disp++;

      if (is_space_char (*temp_disp))
	temp_disp++;

      /* Don't consider registers */
      if ( !((*temp_disp == REGISTER_PREFIX || allow_naked_reg)
	     && parse_register (temp_disp, &end_op)) )
d3657 21
a3677 1
	  char *string_start = temp_disp;
d3679 4
a3682 5
	  while (*temp_disp != ']'
		 && *temp_disp != '+'
		 && *temp_disp != '-'
		 && *temp_disp != '*')
	    ++temp_disp;
d3684 17
a3700 8
	  if (add_minus)
	    strcat (temp_string, "-");
	  else
	    strcat (temp_string, "+");

	  strncat (temp_string, string_start, temp_disp - string_start);
	  if (*temp_disp == '+' || *temp_disp == '-')
	    --temp_disp;
d3702 1
a3702 99

      while (*temp_disp != '\0'
	     && *temp_disp != '+'
	     && *temp_disp != '-')
	++temp_disp;
    }

  return temp_string;
}

static int i386_parse_seg PARAMS ((char *));

static int
i386_parse_seg (op_string)
     char *op_string;
{
  if (is_space_char (*op_string))
    ++op_string;

  /* Should be one of es, cs, ss, ds fs or gs */
  switch (*op_string++)
    {
    case 'e':
      i.seg[i.mem_operands] = &es;
      break;
    case 'c':
      i.seg[i.mem_operands] = &cs;
      break;
    case 's':
      i.seg[i.mem_operands] = &ss;
      break;
    case 'd':
      i.seg[i.mem_operands] = &ds;
      break;
    case 'f':
      i.seg[i.mem_operands] = &fs;
      break;
    case 'g':
      i.seg[i.mem_operands] = &gs;
      break;
    default:
      as_bad (_("bad segment name `%s'"), op_string);
      return 0;
    }

  if (*op_string++ != 's')
    {
      as_bad (_("bad segment name `%s'"), op_string);
      return 0;
    }

  if (is_space_char (*op_string))
    ++op_string;

  if (*op_string != ':')
    {
      as_bad (_("bad segment name `%s'"), op_string);
      return 0;
    }

  return 1;

}

static int i386_index_check PARAMS((const char *));

/* Make sure the memory operand we've been dealt is valid.
   Returns 1 on success, 0 on a failure.
*/
static int
i386_index_check (operand_string)
     const char *operand_string;
{
#if INFER_ADDR_PREFIX
  int fudged = 0;

 tryprefix:
#endif
  if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0)
      /* 16 bit mode checks */
      ? ((i.base_reg
	  && ((i.base_reg->reg_type & (Reg16|BaseIndex))
	      != (Reg16|BaseIndex)))
	 || (i.index_reg
	     && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		  != (Reg16|BaseIndex))
		 || ! (i.base_reg
		       && i.base_reg->reg_num < 6
		       && i.index_reg->reg_num >= 6
		       && i.log2_scale_factor == 0))))
      /* 32 bit mode checks */
      : ((i.base_reg
	  && (i.base_reg->reg_type & Reg32) == 0)
	 || (i.index_reg
	     && ((i.index_reg->reg_type & (Reg32|BaseIndex))
		 != (Reg32|BaseIndex)))))
    {
#if INFER_ADDR_PREFIX
      if (i.prefix[ADDR_PREFIX] == 0 && stackop_size != '\0')
d3704 2
a3705 12
	  i.prefix[ADDR_PREFIX] = ADDR_PREFIX_OPCODE;
	  i.prefixes += 1;
	  /* Change the size of any displacement too.  At most one of
	     Disp16 or Disp32 is set.
	     FIXME.  There doesn't seem to be any real need for separate
	     Disp16 and Disp32 flags.  The same goes for Imm16 and Imm32.
	     Removing them would probably clean up the code quite a lot.
	  */
	  if (i.types[this_operand] & (Disp16|Disp32))
	     i.types[this_operand] ^= (Disp16|Disp32);
	  fudged = 1;
	  goto tryprefix;
d3707 3
a3709 9
      if (fudged)
	as_bad (_("`%s' is not a valid base/index expression"),
		operand_string);
      else
#endif
	as_bad (_("`%s' is not a valid %s bit base/index expression"),
		operand_string,
		flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0) ? "16" : "32");
      return 0;
d3711 1
a3711 15
  return 1;
}

static int i386_intel_memory_operand PARAMS ((char *));

static int
i386_intel_memory_operand (operand_string)
     char *operand_string;
{
  char *op_string = operand_string;
  char *end_of_operand_string;

  if ((i.mem_operands == 1
       && (current_templates->start->opcode_modifier & IsString) == 0)
      || i.mem_operands == 2)
d3713 1
a3713 2
      as_bad (_("too many memory references for `%s'"),
	      current_templates->start->name);
d3716 1
a3716 3

  /* First check for a segment override.  */
  if (*op_string != '[')
d3718 2
a3719 4
      char *end_seg;

      end_seg = strchr (op_string, ':');
      if (end_seg)
d3721 2
a3722 3
	  if (!i386_parse_seg (op_string))
	    return 0;
	  op_string = end_seg + 1;
d3724 2
d3727 3
a3729 3

  /* Look for displacement preceding open bracket */
  if (*op_string != '[')
d3731 2
a3732 1
      char *temp_string;
d3734 3
a3736 2
      if (i.disp_operands)
	return 0;
d3738 4
a3741 3
      temp_string = build_displacement_string (true, op_string);

      if (!i386_displacement (temp_string, temp_string + strlen (temp_string)))
d3743 2
a3744 1
	  free (temp_string);
a3746 1
      free (temp_string);
d3748 5
a3752 3
      end_of_operand_string = strchr (op_string, '[');
      if (!end_of_operand_string)
	end_of_operand_string = op_string + strlen (op_string);
d3754 3
a3756 2
      if (is_space_char (*end_of_operand_string))
	--end_of_operand_string;
d3758 3
a3760 2
      op_string = end_of_operand_string;
    }
d3762 1
a3762 9
  if (*op_string == '[')
    {
      ++op_string;

      /* Pick off each component and figure out where it belongs */

      end_of_operand_string = op_string;

      while (*op_string != ']')
a3763 2
	  const reg_entry *temp_reg;
	  char *end_op;
d3765 12
d3778 1
a3778 5
	  while (*end_of_operand_string != '+'
		 && *end_of_operand_string != '-'
		 && *end_of_operand_string != '*'
		 && *end_of_operand_string != ']')
	    end_of_operand_string++;
d3780 4
a3783 7
	  temp_string = op_string;
	  if (*temp_string == '+')
	    {
	      ++temp_string;
	      if (is_space_char (*temp_string))
		++temp_string;
	    }
d3785 3
a3787 2
	  if ((*temp_string == REGISTER_PREFIX || allow_naked_reg)
	      && (temp_reg = parse_register (temp_string, &end_op)) != NULL)
d3789 1
a3789 4
	      if (i.base_reg == NULL)
		i.base_reg = temp_reg;
	      else
		i.index_reg = temp_reg;
a3791 10
	    }
	  else if (*temp_string == REGISTER_PREFIX)
	    {
	      as_bad (_("bad register name `%s'"), temp_string);
	      return 0;
	    }
	  else if (is_digit_char (*op_string)
		   || *op_string == '+' || *op_string == '-')
	    {
	      char *temp_str;
d3793 1
a3793 10
	      if (i.disp_operands != 0)
		return 0;

	      temp_string = build_displacement_string (false, op_string);

	      temp_str = temp_string;
	      if (*temp_str == '+')
		++temp_str;

	      if (!i386_displacement (temp_str, temp_str + strlen (temp_str)))
d3795 3
a3797 2
		  free (temp_string);
		  return 0;
a3798 1
	      free (temp_string);
d3800 2
a3801 13
	      ++op_string;
	      end_of_operand_string = op_string;
	      while (*end_of_operand_string != ']'
		     && *end_of_operand_string != '+'
		     && *end_of_operand_string != '-'
		     && *end_of_operand_string != '*')
		++end_of_operand_string;
	    }
	  else if (*op_string == '*')
	    {
	      ++op_string;

	      if (i.base_reg && !i.index_reg)
d3803 3
a3805 3
		  i.index_reg = i.base_reg;
		  i.base_reg = 0;
		}
d3807 1
a3807 291
	      if (!i386_scale (op_string))
		return 0;
	    }
	  op_string = end_of_operand_string;
	  ++end_of_operand_string;
	}
    }

  if (i386_index_check (operand_string) == 0)
    return 0;

  i.mem_operands++;
  return 1;
}

static int
i386_intel_operand (operand_string, got_a_float)
     char *operand_string;
     int got_a_float;
{
  const reg_entry * r;
  char *end_op;
  char *op_string = operand_string;

  int operand_modifier = i386_operand_modifier (&op_string, got_a_float);
  if (is_space_char (*op_string))
    ++op_string;

  switch (operand_modifier)
    {
    case BYTE_PTR:
    case WORD_PTR:
    case DWORD_PTR:
    case QWORD_PTR:
    case XWORD_PTR:
      if (!i386_intel_memory_operand (op_string))
	return 0;
      break;

    case FLAT:
    case OFFSET_FLAT:
      if (!i386_immediate (op_string))
	return 0;
      break;

    case SHORT:
    case NONE_FOUND:
      /* Should be register or immediate */
      if (is_digit_char (*op_string)
	  && strchr (op_string, '[') == 0)
	{
	  if (!i386_immediate (op_string))
	    return 0;
	}
      else if ((*op_string == REGISTER_PREFIX || allow_naked_reg)
	       && (r = parse_register (op_string, &end_op)) != NULL)
	{
	  /* Check for a segment override by searching for ':' after a
	     segment register.  */
	  op_string = end_op;
	  if (is_space_char (*op_string))
	    ++op_string;
	  if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
	    {
	      switch (r->reg_num)
		{
		case 0:
		  i.seg[i.mem_operands] = &es;
		  break;
		case 1:
		  i.seg[i.mem_operands] = &cs;
		  break;
		case 2:
		  i.seg[i.mem_operands] = &ss;
		  break;
		case 3:
		  i.seg[i.mem_operands] = &ds;
		  break;
		case 4:
		  i.seg[i.mem_operands] = &fs;
		  break;
		case 5:
		  i.seg[i.mem_operands] = &gs;
		  break;
		}

	    }
	  i.types[this_operand] |= r->reg_type & ~BaseIndex;
	  i.op[this_operand].regs = r;
	  i.reg_operands++;
	}
      else if (*op_string == REGISTER_PREFIX)
	{
	  as_bad (_("bad register name `%s'"), op_string);
	  return 0;
	}
      else if (!i386_intel_memory_operand (op_string))
	return 0;

      break;
    }  /* end switch */

  return 1;
}

/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero
   on error. */

static int
i386_operand (operand_string)
     char *operand_string;
{
  const reg_entry *r;
  char *end_op;
  char *op_string = operand_string;

  if (is_space_char (*op_string))
    ++op_string;

  /* We check for an absolute prefix (differentiating,
     for example, 'jmp pc_relative_label' from 'jmp *absolute_label'. */
  if (*op_string == ABSOLUTE_PREFIX)
    {
      ++op_string;
      if (is_space_char (*op_string))
	++op_string;
      i.types[this_operand] |= JumpAbsolute;
    }

  /* Check if operand is a register. */
  if ((*op_string == REGISTER_PREFIX || allow_naked_reg)
      && (r = parse_register (op_string, &end_op)) != NULL)
    {
      /* Check for a segment override by searching for ':' after a
	 segment register.  */
      op_string = end_op;
      if (is_space_char (*op_string))
	++op_string;
      if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
	{
	  switch (r->reg_num)
	    {
	    case 0:
	      i.seg[i.mem_operands] = &es;
	      break;
	    case 1:
	      i.seg[i.mem_operands] = &cs;
	      break;
	    case 2:
	      i.seg[i.mem_operands] = &ss;
	      break;
	    case 3:
	      i.seg[i.mem_operands] = &ds;
	      break;
	    case 4:
	      i.seg[i.mem_operands] = &fs;
	      break;
	    case 5:
	      i.seg[i.mem_operands] = &gs;
	      break;
	    }

	  /* Skip the ':' and whitespace.  */
	  ++op_string;
	  if (is_space_char (*op_string))
	    ++op_string;

	  if (!is_digit_char (*op_string)
	      && !is_identifier_char (*op_string)
	      && *op_string != '('
	      && *op_string != ABSOLUTE_PREFIX)
	    {
	      as_bad (_("bad memory operand `%s'"), op_string);
	      return 0;
	    }
	  /* Handle case of %es:*foo. */
	  if (*op_string == ABSOLUTE_PREFIX)
	    {
	      ++op_string;
	      if (is_space_char (*op_string))
		++op_string;
	      i.types[this_operand] |= JumpAbsolute;
	    }
	  goto do_memory_reference;
	}
      if (*op_string)
	{
	  as_bad (_("junk `%s' after register"), op_string);
	  return 0;
	}
      i.types[this_operand] |= r->reg_type & ~BaseIndex;
      i.op[this_operand].regs = r;
      i.reg_operands++;
    }
  else if (*op_string == REGISTER_PREFIX)
    {
      as_bad (_("bad register name `%s'"), op_string);
      return 0;
    }
  else if (*op_string == IMMEDIATE_PREFIX)
    {				/* ... or an immediate */
      ++op_string;
      if (i.types[this_operand] & JumpAbsolute)
	{
	  as_bad (_("immediate operand illegal with absolute jump"));
	  return 0;
	}
      if (!i386_immediate (op_string))
	return 0;
    }
  else if (is_digit_char (*op_string)
	   || is_identifier_char (*op_string)
	   || *op_string == '(' )
    {
      /* This is a memory reference of some sort. */
      char *base_string;

      /* Start and end of displacement string expression (if found). */
      char *displacement_string_start;
      char *displacement_string_end;

    do_memory_reference:
      if ((i.mem_operands == 1
	   && (current_templates->start->opcode_modifier & IsString) == 0)
	  || i.mem_operands == 2)
	{
	  as_bad (_("too many memory references for `%s'"),
		  current_templates->start->name);
	  return 0;
	}

      /* Check for base index form.  We detect the base index form by
	 looking for an ')' at the end of the operand, searching
	 for the '(' matching it, and finding a REGISTER_PREFIX or ','
	 after the '('.  */
      base_string = op_string + strlen (op_string);

      --base_string;
      if (is_space_char (*base_string))
	--base_string;

      /* If we only have a displacement, set-up for it to be parsed later. */
      displacement_string_start = op_string;
      displacement_string_end = base_string + 1;

      if (*base_string == ')')
	{
	  char *temp_string;
	  unsigned int parens_balanced = 1;
	  /* We've already checked that the number of left & right ()'s are
	     equal, so this loop will not be infinite. */
	  do
	    {
	      base_string--;
	      if (*base_string == ')')
		parens_balanced++;
	      if (*base_string == '(')
		parens_balanced--;
	    }
	  while (parens_balanced);

	  temp_string = base_string;

	  /* Skip past '(' and whitespace.  */
	  ++base_string;
	  if (is_space_char (*base_string))
	    ++base_string;

	  if (*base_string == ','
	      || ((*base_string == REGISTER_PREFIX || allow_naked_reg)
		  && (i.base_reg = parse_register (base_string, &end_op)) != NULL))
	    {
	      displacement_string_end = temp_string;

	      i.types[this_operand] |= BaseIndex;

	      if (i.base_reg)
		{
		  base_string = end_op;
		  if (is_space_char (*base_string))
		    ++base_string;
		}

	      /* There may be an index reg or scale factor here.  */
	      if (*base_string == ',')
		{
		  ++base_string;
		  if (is_space_char (*base_string))
		    ++base_string;

		  if ((*base_string == REGISTER_PREFIX || allow_naked_reg)
d3819 1
a3819 1
		      else if (*base_string != ')' )
d3832 2
a3833 2
		  /* Check for scale factor. */
		  if (isdigit ((unsigned char) *base_string))
d3835 3
a3837 1
		      if (!i386_scale (base_string))
d3840 1
a3840 1
		      ++base_string;
d3898 2
a3899 1
    {				/* it's not a memory operand; argh! */
d3906 1
a3906 1
  return 1;			/* normal return */
d3932 1
a3932 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
d3941 1
a3941 5
#ifdef BFD_ASSEMBLER
      enum bfd_reloc_code_real reloc_type;
#else
      int reloc_type;
#endif
d3943 1043
a4985 1
      int old_fr_fix;
d4987 2
a4988 6
      if (fragP->fr_var != NO_RELOC)
	reloc_type = fragP->fr_var;
      else if (size == 2)
	reloc_type = BFD_RELOC_16_PCREL;
      else
	reloc_type = BFD_RELOC_32_PCREL;
d4990 2
a4991 2
      old_fr_fix = fragP->fr_fix;
      opcode = (unsigned char *) fragP->fr_opcode;
d4993 3
a4995 10
      switch (opcode[0])
	{
	case JUMP_PC_RELATIVE:	/* make jmp (0xeb) a dword displacement jump */
	  opcode[0] = 0xe9;	/* dword disp jmp */
	  fragP->fr_fix += size;
	  fix_new (fragP, old_fr_fix, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
	  break;
d4997 1
a4997 17
	default:
	  /* This changes the byte-displacement jump 0x7N
	     to the dword-displacement jump 0x0f,0x8N.  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  fragP->fr_fix += 1 + size;	/* we've added an opcode byte */
	  fix_new (fragP, old_fr_fix + 1, size,
		   fragP->fr_symbol,
		   fragP->fr_offset, 1,
		   reloc_type);
	  break;
	}
      frag_wane (fragP);
      return fragP->fr_fix - old_fr_fix;
    }
  return 1; /* Guess a short jump.  */
}
d4999 2
a5000 31
/*
 *			md_convert_frag();
 *
 * Called after relax() is finished.
 * In:	Address of frag.
 *	fr_type == rs_machine_dependent.
 *	fr_subtype is what the address relaxed to.
 *
 * Out:	Any fixSs and constants are set up.
 *	Caller will turn frag into a ".space 0".
 */
#ifndef BFD_ASSEMBLER
void
md_convert_frag (headers, sec, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     register fragS *fragP;
#else
void
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     register fragS *fragP;
#endif
{
  register unsigned char *opcode;
  unsigned char *where_to_put_displacement = NULL;
  unsigned int target_address;
  unsigned int opcode_address;
  unsigned int extension = 0;
  int displacement_from_opcode_start;
d5002 12
a5013 1
  opcode = (unsigned char *) fragP->fr_opcode;
d5015 11
a5025 5
  /* Address we want to reach in file space. */
  target_address = S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset;
#ifdef BFD_ASSEMBLER /* not needed otherwise? */
  target_address += symbol_get_frag (fragP->fr_symbol)->fr_address;
#endif
d5027 1
a5027 2
  /* Address opcode resides at in file space. */
  opcode_address = fragP->fr_address + fragP->fr_fix;
d5029 7
a5035 2
  /* Displacement from opcode start to fill into instruction. */
  displacement_from_opcode_start = target_address - opcode_address;
d5037 1
a5037 10
  switch (fragP->fr_subtype)
    {
    case ENCODE_RELAX_STATE (COND_JUMP, SMALL):
    case ENCODE_RELAX_STATE (COND_JUMP, SMALL16):
    case ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL):
    case ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL16):
      /* don't have to change opcode */
      extension = 1;		/* 1 opcode + 1 displacement */
      where_to_put_displacement = &opcode[1];
      break;
d5039 30
a5068 6
    case ENCODE_RELAX_STATE (COND_JUMP, BIG):
      extension = 5;		/* 2 opcode + 4 displacement */
      opcode[1] = opcode[0] + 0x10;
      opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
      where_to_put_displacement = &opcode[2];
      break;
d5070 7
a5076 5
    case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG):
      extension = 4;		/* 1 opcode + 4 displacement */
      opcode[0] = 0xe9;
      where_to_put_displacement = &opcode[1];
      break;
d5078 41
a5118 6
    case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
      extension = 3;		/* 2 opcode + 2 displacement */
      opcode[1] = opcode[0] + 0x10;
      opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
      where_to_put_displacement = &opcode[2];
      break;
d5120 6
a5125 5
    case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16):
      extension = 2;		/* 1 opcode + 2 displacement */
      opcode[0] = 0xe9;
      where_to_put_displacement = &opcode[1];
      break;
d5127 4
a5130 3
    default:
      BAD_CASE (fragP->fr_subtype);
      break;
d5132 5
a5136 5
  /* now put displacement after opcode */
  md_number_to_chars ((char *) where_to_put_displacement,
		      (valueT) (displacement_from_opcode_start - extension),
		      SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
  fragP->fr_fix += extension;
a5137 1

d5139 10
a5148 3
int md_short_jump_size = 2;	/* size of byte displacement jmp */
int md_long_jump_size = 5;	/* size of dword displacement jmp */
const int md_reloc_size = 8;	/* Size of relocation record */
d5150 2
a5151 8
void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
{
  long offset;
d5153 3
a5155 3
  offset = to_addr - (from_addr + 2);
  md_number_to_chars (ptr, (valueT) 0xeb, 1);	/* opcode for byte-disp jump */
  md_number_to_chars (ptr + 1, (valueT) offset, 1);
d5158 6
a5163 6
void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
d5165 2
a5166 1
  long offset;
d5168 5
a5172 1
  if (flag_do_long_jump)
d5174 4
a5177 5
      offset = to_addr - S_GET_VALUE (to_symbol);
      md_number_to_chars (ptr, (valueT) 0xe9, 1);/* opcode for long jmp */
      md_number_to_chars (ptr + 1, (valueT) offset, 4);
      fix_new (frag, (ptr + 1) - frag->fr_literal, 4,
	       to_symbol, (offsetT) 0, 0, BFD_RELOC_32);
d5179 2
d5182 18
d5201 4
a5204 3
      offset = to_addr - (from_addr + 5);
      md_number_to_chars (ptr, (valueT) 0xe9, 1);
      md_number_to_chars (ptr + 1, (valueT) offset, 4);
d5206 4
a5210 3

/* Apply a fixup (fixS) to segment data, once it has been determined
   by our caller that we have all the info we need to fix it up.
d5212 2
a5213 3
   On the 386, immediates, displacements, and data pointers are all in
   the same (little-endian) format, so we don't need to care about which
   we are handling.  */
d5215 5
a5219 5
int
md_apply_fix3 (fixP, valp, seg)
     fixS *fixP;		/* The fix we're to put in.  */
     valueT *valp;		/* Pointer to the value of the bits.  */
     segT seg ATTRIBUTE_UNUSED;	/* Segment fix is from.  */
d5221 2
a5222 5
  register char *p = fixP->fx_where + fixP->fx_frag->fr_literal;
  valueT value = *valp;

#if defined (BFD_ASSEMBLER) && !defined (TE_Mach)
  if (fixP->fx_pcrel)
d5224 3
a5226 4
      switch (fixP->fx_r_type)
	{
	default:
	  break;
d5228 1
a5228 10
	case BFD_RELOC_32:
	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  break;
	case BFD_RELOC_16:
	  fixP->fx_r_type = BFD_RELOC_16_PCREL;
	  break;
	case BFD_RELOC_8:
	  fixP->fx_r_type = BFD_RELOC_8_PCREL;
	  break;
	}
d5231 10
a5240 8
  /* This is a hack.  There should be a better way to handle this.
     This covers for the fact that bfd_install_relocation will
     subtract the current location (for partial_inplace, PC relative
     relocations); see more below.  */
  if ((fixP->fx_r_type == BFD_RELOC_32_PCREL
       || fixP->fx_r_type == BFD_RELOC_16_PCREL
       || fixP->fx_r_type == BFD_RELOC_8_PCREL)
      && fixP->fx_addsy)
d5242 4
a5245 10
#ifndef OBJ_AOUT
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour
#ifdef TE_PE
	  || OUTPUT_FLAVOR == bfd_target_coff_flavour
#endif
	  )
	value += fixP->fx_where + fixP->fx_frag->fr_address;
#endif
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d5247 5
a5251 1
	  segT fseg = S_GET_SEGMENT (fixP->fx_addsy);
d5253 6
a5258 14
	  if ((fseg == seg
	       || (symbol_section_p (fixP->fx_addsy)
		   && fseg != absolute_section))
	      && ! S_IS_EXTERNAL (fixP->fx_addsy)
	      && ! S_IS_WEAK (fixP->fx_addsy)
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && ! S_IS_COMMON (fixP->fx_addsy))
	    {
	      /* Yes, we add the values in twice.  This is because
		 bfd_perform_relocation subtracts them out again.  I think
		 bfd_perform_relocation is broken, but I don't dare change
		 it.  FIXME.  */
	      value += fixP->fx_where + fixP->fx_frag->fr_address;
	    }
d5260 2
a5261 8
#endif
#if defined (OBJ_COFF) && defined (TE_PE)
      /* For some reason, the PE format does not store a section
	 address offset for a PC relative symbol.  */
      if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
      else if (S_IS_EXTERNAL (fixP->fx_addsy)
	       || S_IS_WEAK (fixP->fx_addsy))
d5263 4
a5266 9
	  /* We are generating an external relocation for this defined
             symbol.  We add the address, because
             bfd_install_relocation will subtract it.  VALUE already
             holds the symbol value, because fixup_segment added it
             in.  We subtract it out, and then we subtract it out
             again because bfd_install_relocation will add it in
             again.  */
	  value += md_pcrel_from (fixP);
	  value -= 2 * S_GET_VALUE (fixP->fx_addsy);
a5267 15
#endif
    }
#ifdef TE_PE
  else if (fixP->fx_addsy != NULL
	   && S_IS_DEFINED (fixP->fx_addsy)
	   && (S_IS_EXTERNAL (fixP->fx_addsy)
	       || S_IS_WEAK (fixP->fx_addsy)))
    {
      /* We are generating an external relocation for this defined
         symbol.  VALUE already holds the symbol value, and
         bfd_install_relocation will add it in again.  We don't want
         either addition.  */
      value -= 2 * S_GET_VALUE (fixP->fx_addsy);
    }
#endif
d5269 8
a5276 57
  /* Fix a few things - the dynamic linker expects certain values here,
     and we must not dissappoint it. */
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
      && fixP->fx_addsy)
    switch (fixP->fx_r_type) {
    case BFD_RELOC_386_PLT32:
      /* Make the jump instruction point to the address of the operand.  At
	 runtime we merely add the offset to the actual PLT entry. */
      value = 0xfffffffc;
      break;
    case BFD_RELOC_386_GOTPC:
/*
 *   This is tough to explain.  We end up with this one if we have
 * operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal
 * here is to obtain the absolute address of the GOT, and it is strongly
 * preferable from a performance point of view to avoid using a runtime
 * relocation for this.  The actual sequence of instructions often look
 * something like:
 *
 *	call	.L66
 * .L66:
 *	popl	%ebx
 *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
 *
 *   The call and pop essentially return the absolute address of
 * the label .L66 and store it in %ebx.  The linker itself will
 * ultimately change the first operand of the addl so that %ebx points to
 * the GOT, but to keep things simple, the .o file must have this operand
 * set so that it generates not the absolute address of .L66, but the
 * absolute address of itself.  This allows the linker itself simply
 * treat a GOTPC relocation as asking for a pcrel offset to the GOT to be
 * added in, and the addend of the relocation is stored in the operand
 * field for the instruction itself.
 *
 *   Our job here is to fix the operand so that it would add the correct
 * offset so that %ebx would point to itself.  The thing that is tricky is
 * that .-.L66 will point to the beginning of the instruction, so we need
 * to further modify the operand so that it will point to itself.
 * There are other cases where you have something like:
 *
 *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
 *
 * and here no correction would be required.  Internally in the assembler
 * we treat operands of this form as not being pcrel since the '.' is
 * explicitly mentioned, and I wonder whether it would simplify matters
 * to do it this way.  Who knows.  In earlier versions of the PIC patches,
 * the pcrel_adjust field was used to store the correction, but since the
 * expression is not pcrel, I felt it would be confusing to do it this way.
 */
      value -= 1;
      break;
    case BFD_RELOC_386_GOT32:
      value = 0; /* Fully resolved at runtime.  No addend.  */
      break;
    case BFD_RELOC_386_GOTOFF:
      break;
d5278 1
a5278 4
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return 1;
d5280 1
a5280 2
    default:
      break;
a5281 4
#endif /* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) */
  *valp = value;
#endif /* defined (BFD_ASSEMBLER) && !defined (TE_Mach) */
  md_number_to_chars (p, value, fixP->fx_size);
d5283 7
a5289 2
  return 1;
}
d5291 1
a5291 12
#if 0
/* This is never used.  */
long				/* Knows about the byte order in a word. */
md_chars_to_number (con, nbytes)
     unsigned char con[];	/* Low order byte 1st. */
     int nbytes;		/* Number of bytes in the input. */
{
  long retval;
  for (retval = 0, con += nbytes - 1; nbytes--; con--)
    {
      retval <<= BITS_PER_CHAR;
      retval |= *con;
d5293 4
a5296 1
  return retval;
a5297 2
#endif /* 0 */

d5299 1
a5299 1
#define MAX_LITTLENUMS 6
d5301 4
a5304 8
/* Turn the string pointed to by litP into a floating point constant of type
   type, and emit the appropriate bytes.  The number of LITTLENUMS emitted
   is stored in *sizeP .  An error message is returned, or NULL on OK.  */
char *
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d5306 2
a5307 4
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;
d5309 5
a5313 1
  switch (type)
d5315 9
a5323 4
    case 'f':
    case 'F':
      prec = 2;
      break;
d5325 4
a5328 4
    case 'd':
    case 'D':
      prec = 4;
      break;
d5330 5
a5334 4
    case 'x':
    case 'X':
      prec = 5;
      break;
d5336 4
a5339 3
    default:
      *sizeP = 0;
      return _("Bad call to md_atof ()");
a5340 3
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
d5342 3
a5344 9
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  /* This loops outputs the LITTLENUMs in REVERSE order; in accord with
     the bigendian 386.  */
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
a5345 2

char output_invalid_buf[8];
d5347 20
a5366 1
static char * output_invalid PARAMS ((int));
d5368 8
a5375 10
static char *
output_invalid (c)
     int c;
{
  if (isprint (c))
    sprintf (output_invalid_buf, "'%c'", c);
  else
    sprintf (output_invalid_buf, "(0x%x)", (unsigned) c);
  return output_invalid_buf;
}
d5377 4
d5382 7
a5388 1
/* REG_STRING starts *before* REGISTER_PREFIX.  */
d5390 11
a5400 9
static const reg_entry *
parse_register (reg_string, end_op)
     char *reg_string;
     char **end_op;
{
  char *s = reg_string;
  char *p;
  char reg_name_given[MAX_REG_NAME_SIZE + 1];
  const reg_entry *r;
d5402 5
a5406 3
  /* Skip possible REGISTER_PREFIX and possible whitespace.  */
  if (*s == REGISTER_PREFIX)
    ++s;
d5408 5
a5412 2
  if (is_space_char (*s))
    ++s;
d5414 10
a5423 2
  p = reg_name_given;
  while ((*p++ = register_chars[(unsigned char) *s]) != '\0')
d5425 3
a5427 3
      if (p >= reg_name_given + MAX_REG_NAME_SIZE)
	return (const reg_entry *) NULL;
      s++;
d5430 11
a5440 1
  *end_op = s;
d5442 2
a5443 1
  r = (const reg_entry *) hash_find (reg_hash, reg_name_given);
d5445 2
a5446 2
  /* Handle floating point regs, allowing spaces in the (i) part.  */
  if (r == i386_regtab /* %st is first entry of table */)
d5448 6
a5453 3
      if (is_space_char (*s))
	++s;
      if (*s == '(')
d5455 1
a5455 4
	  ++s;
	  if (is_space_char (*s))
	    ++s;
	  if (*s >= '0' && *s <= '7')
d5457 1
a5457 5
	      r = &i386_float_regtab[*s - '0'];
	      ++s;
	      if (is_space_char (*s))
		++s;
	      if (*s == ')')
d5459 18
a5476 2
		  *end_op = s + 1;
		  return r;
d5479 78
a5556 2
	  /* We have "%st(" then garbage */
	  return (const reg_entry *) NULL;
d5558 2
d5562 14
a5575 12
  return r;
}

#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
CONST char *md_shortopts = "kmVQ:sq";
#else
CONST char *md_shortopts = "m";
#endif
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);
d5577 4
a5580 6
int
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
{
  switch (c)
d5582 56
a5637 3
    case 'm':
      flag_do_long_jump = 1;
      break;
d5639 1
a5639 4
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      /* -k: Ignore for FreeBSD compatibility.  */
    case 'k':
      break;
d5641 5
a5645 4
      /* -V: SVR4 argument to print version ID.  */
    case 'V':
      print_version_id ();
      break;
d5647 6
a5652 9
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

    case 's':
      /* -s: On i386 Solaris, this tells the native assembler to use
         .stab instead of .stab.excl.  We always use .stab anyhow.  */
      break;
d5654 3
a5656 5
    case 'q':
      /* -q: On i386 Solaris, this tells the native assembler does
         fewer checks.  */
      break;
#endif
d5658 1
a5658 2
    default:
      return 0;
a5659 2
  return 1;
}
d5661 2
a5662 14
void
md_show_usage (stream)
     FILE *stream;
{
  fprintf (stream, _("\
  -m			  do long jump\n"));
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  fprintf (stream, _("\
  -V			  print assembler version number\n\
  -k			  ignored\n\
  -Qy, -Qn		  ignored\n\
  -q			  ignored\n\
  -s			  ignored\n"));
#endif
d5665 5
a5669 9
#ifdef BFD_ASSEMBLER
#if ((defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_COFF)) \
     || (defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_AOUT)) \
     || (defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)))

/* Pick the target format to use.  */

const char  *
i386_target_format ()
d5671 1
a5671 1
  switch (OUTPUT_FLAVOR)
d5673 2
a5674 15
#ifdef OBJ_MAYBE_AOUT
    case bfd_target_aout_flavour:
     return AOUT_TARGET_FORMAT;
#endif
#ifdef OBJ_MAYBE_COFF
    case bfd_target_coff_flavour:
      return "coff-i386";
#endif
#ifdef OBJ_MAYBE_ELF
    case bfd_target_elf_flavour:
      return "elf32-i386";
#endif
    default:
      abort ();
      return NULL;
d5676 1
a5676 13
}

#endif /* OBJ_MAYBE_ more than one */
#endif /* BFD_ASSEMBLER */

symbolS *
md_undefined_symbol (name)
     char *name;
{
  if (name[0] == GLOBAL_OFFSET_TABLE_NAME[0]
      && name[1] == GLOBAL_OFFSET_TABLE_NAME[1]
      && name[2] == GLOBAL_OFFSET_TABLE_NAME[2]
      && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
d5678 2
a5679 8
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad (_("GOT already in symbol table"));
	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, &zero_address_frag);
	};
      return GOT_symbol;
a5680 1
  return 0;
d5683 3
a5685 5
/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d5687 3
a5689 10
#ifdef BFD_ASSEMBLER
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
    {
      /* For a.out, force the section size to be aligned.  If we don't do
	 this, BFD will align it for us, but it will not write out the
	 final bytes of the section.  This may be a bug in BFD, but it is
	 easier to fix it here since that is how the other a.out targets
	 work.  */
      int align;
d5691 3
a5693 5
      align = bfd_get_section_alignment (stdoutput, segment);
      size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
    }
#endif
#endif
d5695 4
a5698 2
  return size;
}
d5700 1
a5700 3
/* On the i386, PC-relative offsets are relative to the start of the
   next instruction.  That is, the address of the offset, plus its
   size, since the offset is always the last part of the insn.  */
d5702 3
a5704 6
long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}
d5706 6
a5711 1
#ifndef I386COFF
d5713 6
a5718 5
static void
s_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  register int temp;
d5720 5
a5724 4
  temp = get_absolute_expression ();
  subseg_set (bss_section, (subsegT) temp);
  demand_empty_rest_of_line ();
}
d5726 5
a5730 1
#endif
d5732 6
d5739 6
a5744 1
#ifdef BFD_ASSEMBLER
d5746 2
a5747 5
void
i386_validate_fix (fixp)
     fixS *fixp;
{
  if (fixp->fx_subsy && fixp->fx_subsy == GOT_symbol)
d5749 10
a5758 2
      fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
      fixp->fx_subsy = 0;
a5759 1
}
d5761 4
a5764 7
arelent *
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *rel;
  bfd_reloc_code_real_type code;
d5766 3
a5768 13
  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_386_PLT32:
    case BFD_RELOC_386_GOT32:
    case BFD_RELOC_386_GOTOFF:
    case BFD_RELOC_386_GOTPC:
    case BFD_RELOC_RVA:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      code = fixp->fx_r_type;
      break;
    default:
      if (fixp->fx_pcrel)
d5770 3
a5772 11
	  switch (fixp->fx_size)
	    {
	    default:
	      as_bad (_("can not do %d byte pc-relative relocation"),
		      fixp->fx_size);
	      code = BFD_RELOC_32_PCREL;
	      break;
	    case 1: code = BFD_RELOC_8_PCREL;  break;
	    case 2: code = BFD_RELOC_16_PCREL; break;
	    case 4: code = BFD_RELOC_32_PCREL; break;
	    }
d5776 3
a5778 28
	  switch (fixp->fx_size)
	    {
	    default:
	      as_bad (_("can not do %d byte relocation"), fixp->fx_size);
	      code = BFD_RELOC_32;
	      break;
	    case 1: code = BFD_RELOC_8;  break;
	    case 2: code = BFD_RELOC_16; break;
	    case 4: code = BFD_RELOC_32; break;
	    }
	}
      break;
    }

  if (code == BFD_RELOC_32
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    code = BFD_RELOC_386_GOTPC;

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);

  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  /* HACK: Since i386 ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    rel->address = fixp->fx_offset;
d5780 2
a5781 15
  if (fixp->fx_pcrel)
    rel->addend = fixp->fx_addnumber;
  else
    rel->addend = 0;

  rel->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (code));
      /* Set howto to a garbage value so that we can keep going.  */
      rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
      assert (rel->howto != NULL);
    }
d5783 2
a5784 2
  return rel;
}
d5786 2
a5787 1
#else /* ! BFD_ASSEMBLER */
d5789 2
a5790 11
#if (defined(OBJ_AOUT) | defined(OBJ_BOUT))
void
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  /*
   * In: length of relocation (or of address) in chars: 1, 2 or 4.
   * Out: GNU LD relocation length code: 0, 1, or 2.
   */
d5792 2
a5793 2
  static const unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
  long r_symbolnum;
d5795 2
a5796 1
  know (fixP->fx_addsy != NULL);
d5798 2
a5799 4
  md_number_to_chars (where,
		      (valueT) (fixP->fx_frag->fr_address
				+ fixP->fx_where - segment_address_in_file),
		      4);
d5801 3
a5803 3
  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);
d5805 6
a5810 7
  where[6] = (r_symbolnum >> 16) & 0x0ff;
  where[5] = (r_symbolnum >> 8) & 0x0ff;
  where[4] = r_symbolnum & 0x0ff;
  where[7] = ((((!S_IS_DEFINED (fixP->fx_addsy)) << 3) & 0x08)
	      | ((nbytes_r_length[fixP->fx_size] << 1) & 0x06)
	      | (((fixP->fx_pcrel << 0) & 0x01) & 0x0f));
}
d5812 3
a5814 1
#endif /* OBJ_AOUT or OBJ_BOUT */
d5816 4
a5819 1
#if defined (I386COFF)
d5821 2
a5822 6
short
tc_coff_fix2rtype (fixP)
     fixS *fixP;
{
  if (fixP->fx_r_type == R_IMAGEBASE)
    return R_IMAGEBASE;
d5824 2
a5825 7
  return (fixP->fx_pcrel ?
	  (fixP->fx_size == 1 ? R_PCRBYTE :
	   fixP->fx_size == 2 ? R_PCRWORD :
	   R_PCRLONG) :
	  (fixP->fx_size == 1 ? R_RELBYTE :
	   fixP->fx_size == 2 ? R_RELWORD :
	   R_DIR32));
d5828 4
a5831 3
int
tc_coff_sizemachdep (frag)
     fragS *frag;
d5833 8
a5840 4
  if (frag->fr_next)
    return (frag->fr_next->fr_address - frag->fr_address);
  else
    return 0;
a5841 6

#endif /* I386COFF */

#endif /* ! BFD_ASSEMBLER */

/* end of tc-i386.c */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1989, 91, 92, 93, 94, 95, 1996 Free Software Foundation.
d33 20
d54 10
a63 2
#include "obstack.h"
#include "opcode/i386.h"
d65 3
a67 2
#ifndef TC_RELOC
#define TC_RELOC(X,Y) (Y)
d73 7
d84 3
a86 1
    /* SUFFIX holds the opcode suffix (e.g. 'l' for 'movl') if given. */
a87 1
    /* Operands are coded with OPERANDS, TYPES, DISPS, IMMS, and REGS. */
d98 1
a98 2
       search through DISPS [i] & IMMS [i] & REGS [i] for the required
       operand.  */
d101 3
a103 2
    /* Displacements (if given) for each operand. */
    expressionS *disps[MAX_OPERANDS];
a111 6
    /* Immediate operands (if given) for each operand. */
    expressionS *imms[MAX_OPERANDS];

    /* Register operands (if given) for each operand. */
    reg_entry *regs[MAX_OPERANDS];

d114 2
a115 2
    reg_entry *base_reg;
    reg_entry *index_reg;
d118 3
a120 3
    /* SEG gives the seg_entry of this insn.  It is equal to zero unless
       an explicit segment override is given. */
    const seg_entry *seg;	/* segment for memory operands (if given) */
d123 2
a124 2
       PREFIXES is the size of PREFIX. */
    /* richfix: really unsigned? */
a125 1
    unsigned int prefixes;
d127 2
a128 2
    /* RM and IB are the modrm byte and the base index byte where the
       addressing modes of this insn are encoded. */
d131 1
a131 1
    base_index_byte bi;
d136 8
d146 3
a148 1
#if defined (TE_I386AIX) || defined (OBJ_ELF)
d150 1
d153 1
d164 1
a164 1
#if defined (TE_I386AIX) || defined (OBJ_ELF)
d169 1
d181 1
a181 1
static char opcode_chars[256];
a183 1
static char space_chars[256];
d188 1
a188 1
#define is_opcode_char(x) (opcode_chars[(unsigned char) x])
d191 1
a191 1
#define is_space_char(x) (space_chars[(unsigned char) x])
a197 2
static char *ordinal_names[] = {"first", "second", "third"}; /* for printfs */

d204 4
a207 2
#define END_STRING_AND_SAVE(s)      *save_stack_p++ = *s; *s = '\0'
#define RESTORE_END_STRING(s)       *s = *--save_stack_p
d212 3
a217 3
/* pointers to ebp & esp entries in reg_hash hash table */
static reg_entry *ebp, *esp;

d224 9
d235 2
a236 2
   one for unconditional jumps.  This is because the these two types
   of jumps add different sizes to frags when we're figuring out what
d243 5
a247 4
#define BYTE 0
#define WORD 1
#define DWORD 2
#define UNKNOWN_SIZE 3
d260 9
a268 1
    ( (((s) & 0x3) == BYTE ? 1 : (((s) & 0x3) == WORD ? 2 : 4)) )
d272 6
a277 6
/* The fields are:
   1) most positive reach of this state,
   2) most negative reach of this state,
   3) how many bytes this mode will add to the size of the current frag
   4) which index into the table to try if we can't fit into this one.
   */
d283 2
a284 6
  /* For now we don't use word displacement jumps; they may be
     untrustworthy. */
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (COND_JUMP, DWORD)},
  /* word conditionals add 3 bytes to frag:
     2 opcode prefix; 1 displacement bytes */
  {32767 + 2, -32768 + 2, 3, ENCODE_RELAX_STATE (COND_JUMP, DWORD)},
d286 1
a286 1
     1 opcode prefix; 3 displacement bytes */
d288 3
a290 1
  {1, 1, 0, 0},
d292 2
a293 4
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (UNCOND_JUMP, DWORD)},
  /* word jmp adds 2 bytes to frag:
     1 opcode prefix; 1 displacement bytes */
  {32767 + 2, -32768 + 2, 2, ENCODE_RELAX_STATE (UNCOND_JUMP, DWORD)},
d295 1
a295 1
     0 opcode prefix; 3 displacement bytes */
d297 3
a299 1
  {1, 1, 0, 0},
d310 57
a366 33
  static const char f32_1[] = {0x90};
  static const char f32_2[] = {0x8d,0x36};
  static const char f32_3[] = {0x8d,0x76,0x00};
  static const char f32_4[] = {0x8d,0x74,0x26,0x00};
  static const char f32_5[] = {0x90,
			       0x8d,0x74,0x26,0x00};
  static const char f32_6[] = {0x8d,0xb6,0x00,0x00,0x00,0x00};
  static const char f32_7[] = {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};
  static const char f32_8[] = {0x90,
			       0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};
  static const char f32_9[] = {0x8d,0x36,
			       0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};
  static const char f32_10[] = {0x8d,0x76,0x00,
				0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};
  static const char f32_11[] = {0x8d,0x74,0x26,0x00,
				0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};
  static const char f32_12[] = {0x8d,0xb6,0x00,0x00,0x00,0x00,
				0x8d,0xb6,0x00,0x00,0x00,0x00};
  static const char f32_13[] = {0x8d,0xb6,0x00,0x00,0x00,0x00,
				0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};
  static const char f32_14[] = {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00,
				0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};
  static const char f32_15[] = {0xeb,0x0d,0x90,0x90,0x90,0x90,0x90,
				0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};
  static const char f16_4[] = {0x8d,0xb6,0x00,0x00};
  static const char f16_5[] = {0x90,
			       0x8d,0xb6,0x00,0x00};
  static const char f16_6[] = {0x8d,0x36,
			       0x8d,0xb6,0x00,0x00};
  static const char f16_7[] = {0x8d,0x76,0x00,
			       0x8d,0xb6,0x00,0x00};
  static const char f16_8[] = {0x8d,0xb6,0x00,0x00,
			       0x8d,0xb6,0x00,0x00};
d372 1
a372 1
    f32_1, f32_2, f32_3, f16_4, f16_5, f16_6, f16_7, f16_8,
d394 4
a397 1
static reg_entry *parse_register PARAMS ((char *reg_string));
d402 1
a402 1
symbolS *GOT_symbol;		/* Pre-defined "__GLOBAL_OFFSET_TABLE" */
d404 1
a404 1
static INLINE unsigned long
d406 1
a406 1
     unsigned long t;
d408 1
a408 1
  return (t & Disp8) ? 1 : (t & Disp32) ? 2 : 0;
a410 14
#if 0
/* Not used.  */
/* convert opcode suffix ('b' 'w' 'l' typically) into type specifier */

static INLINE unsigned long
opcode_suffix_to_type (s)
     unsigned long s;
{
  return (s == BYTE_OPCODE_SUFFIX
	  ? Byte : (s == WORD_OPCODE_SUFFIX
		    ? Word : DWord));
}				/* opcode_suffix_to_type() */
#endif

d462 67
a528 2
void set_16bit_code_flag(new_16bit_code_flag)
	int new_16bit_code_flag;
d531 39
d577 1
a577 1
#ifndef OBJ_AOUT
d588 1
d591 2
d599 1
a599 4
/* obstack for constructing various things in md_begin */
struct obstack o;

/* hash table for opcode lookup */
a602 2
/* hash table for prefix lookup */
static struct hash_control *prefix_hash;
a609 2
  obstack_begin (&o, 4096);

a615 1
    char *prev_name;
a617 2
    prev_name = optab->name;
    obstack_grow (&o, optab, sizeof (template));
d619 1
d621 1
a621 1
    for (optab++; optab < i386_optab_end; optab++)
d623 3
a625 6
	if (!strcmp (optab->name, prev_name))
	  {
	    /* same name as before --> append to current template list */
	    obstack_grow (&o, optab, sizeof (template));
	  }
	else
d629 4
a632 5
	    /* Note: end must be set before start! since obstack_next_free
	       changes upon opstack_finish */
	    core_optab->end = (template *) obstack_next_free (&o);
	    core_optab->start = (template *) obstack_finish (&o);
	    hash_err = hash_insert (op_hash, prev_name, (char *) core_optab);
d636 2
a637 1
		as_fatal ("Internal Error:  Can't hash %s: %s", prev_name,
d640 2
a641 1
	    prev_name = optab->name;
d643 1
a643 1
	    obstack_grow (&o, optab, sizeof (template));
d653 3
a655 1
    for (regtab = i386_regtab; regtab < i386_regtab_end; regtab++)
d663 1
a663 19
  esp = (reg_entry *) hash_find (reg_hash, "esp");
  ebp = (reg_entry *) hash_find (reg_hash, "ebp");

  /* initialize reg_hash hash table */
  prefix_hash = hash_new ();
  {
    register const prefix_entry *prefixtab;

    for (prefixtab = i386_prefixtab;
	 prefixtab < i386_prefixtab_end; prefixtab++)
      {
	hash_err = hash_insert (prefix_hash, prefixtab->prefix_name,
				(PTR) prefixtab);
	if (hash_err)
	  goto hash_error;
      }
  }

  /* fill in lexical tables:  opcode_chars, operand_chars, space_chars */
d670 1
a670 1
	if (islower (c) || isdigit (c))
d672 2
a673 1
	    opcode_chars[c] = c;
d675 1
d677 1
a677 1
	else if (isupper (c))
d679 3
a681 2
	    opcode_chars[c] = tolower (c);
	    register_chars[c] = opcode_chars[c];
d683 1
a683 1
	else if (c == PREFIX_SEPERATOR)
d685 3
a687 1
	    opcode_chars[c] = c;
d689 4
a692 1
	else if (c == ')' || c == '(')
d694 2
a695 1
	    register_chars[c] = c;
d697 1
a697 9

	if (isupper (c) || islower (c) || isdigit (c))
	  operand_chars[c] = c;

	if (isdigit (c) || c == '-')
	  digit_chars[c] = c;

	if (isalpha (c) || c == '_' || c == '.' || isdigit (c))
	  identifier_chars[c] = c;
d700 1
a700 1
	identifier_chars['@@'] = '@@';
d702 3
a704 4

	if (c == ' ' || c == '\t')
	  space_chars[c] = c;
      }
d710 7
a716 4
#ifdef OBJ_ELF
  record_alignment (text_section, 2);
  record_alignment (data_section, 2);
  record_alignment (bss_section, 2);
a725 1
  hash_print_statistics (file, "i386 prefix", prefix_hash);
d757 3
a759 2
      if (x->types[i] & Reg)
	fprintf (stdout, "%s\n", x->regs[i]->reg_name);
d761 3
a763 3
	pe (x->imms[i]);
      if (x->types[i] & (Disp | Abs))
	pe (x->disps[i]);
d794 3
a796 3
  fprintf (stdout, "    operation       %d\n", e->X_op);
  fprintf (stdout, "    add_number    %d (%x)\n",
	   e->X_add_number, e->X_add_number);
d836 1
a836 3
  { Mem8, "Mem8" },
  { Mem16, "Mem16" },
  { Mem32, "Mem32" },
a837 3
  { Abs8, "Abs8" },
  { Abs16, "Abs16" },
  { Abs32, "Abs32" },
a840 3
  { SReg2, "SReg2" },
  { SReg3, "SReg3" },
  { Acc, "Acc" },
a842 1
  { Imm1, "i1" },
d845 1
d848 3
d852 3
d866 1
a866 1
      fprintf (stdout, "Unknown");
d879 15
d895 3
d907 9
a915 6
    switch (size)
      {
      case 1: return BFD_RELOC_8_PCREL;
      case 2: return BFD_RELOC_16_PCREL;
      case 4: return BFD_RELOC_32_PCREL;
      }
d917 9
a925 6
    switch (size)
      {
      case 1: return BFD_RELOC_8;
      case 2: return BFD_RELOC_16;
      case 4: return BFD_RELOC_32;
      }
a926 2
  as_bad ("Can not do %d byte %srelocation", size,
	  pcrel ? "pc-relative " : "");
a928 8
#else
#define reloc(SIZE,PCREL,OTHER)	0
#define BFD_RELOC_32		0
#define BFD_RELOC_32_PCREL	0
#define BFD_RELOC_386_PLT32	0
#define BFD_RELOC_386_GOT32	0
#define BFD_RELOC_386_GOTOFF	0
#endif
d937 2
a938 2
tc_i386_fix_adjustable(fixP)
     fixS * fixP;
d940 5
a944 3
#ifndef OBJ_AOUT
  /* Prevent all adjustments to global symbols. */
  if (S_IS_EXTERN (fixP->fx_addsy))
d946 1
a946 6
#ifdef BFD_ASSEMBLER
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;
#endif /* BFD_ASSEMBLER */
#endif /* ! defined (OBJ_AOUT) */
#ifdef BFD_ASSEMBLER
d950 4
a953 1
      || fixP->fx_r_type == BFD_RELOC_386_GOT32)
d955 11
d967 15
a981 1
  return 1;
d992 2
a993 2
  /* Holds template once we've found it. */
  template *t;
d998 1
a998 2
  /* Possible templates for current insn */
  templates *current_templates = (templates *) 0;
d1000 1
a1000 1
  int j;
d1010 1
a1010 1
  /* Fist parse an opcode & call i386_operand for the operands.
d1012 1
a1012 1
     start of a (possibly prefixed) opcode. */
d1015 2
d1018 2
a1019 7
    /* 1 if operand is pending after ','. */
    unsigned int expecting_operand = 0;
    /* 1 if we found a prefix only acceptable with string insns. */
    unsigned int expecting_string_instruction = 0;
    /* Non-zero if operand parens not balenced. */
    unsigned int paren_not_balenced;
    char *token_start = l;
d1021 1
a1021 1
    while (!is_space_char (*l) && *l != END_OF_INSN)
d1023 14
a1036 1
	if (!is_opcode_char (*l))
d1038 2
a1039 1
	    as_bad ("invalid character %s in opcode", output_invalid (*l));
d1042 1
a1042 1
	else if (*l != PREFIX_SEPERATOR)
d1044 5
a1048 2
	    *l = opcode_chars[(unsigned char) *l];	/* fold case of opcodes */
	    l++;
a1049 5
	else
	  {
	    /* This opcode's got a prefix.  */
	    unsigned int q;
	    prefix_entry *prefix;
d1051 13
a1063 1
	    if (l == token_start)
d1065 2
a1066 1
		as_bad ("expecting prefix; got nothing");
d1069 2
a1070 3
	    END_STRING_AND_SAVE (l);
	    prefix = (prefix_entry *) hash_find (prefix_hash, token_start);
	    if (!prefix)
d1072 1
a1072 1
		as_bad ("no such opcode prefix ('%s')", token_start);
d1074 4
d1079 1
a1079 17
	    RESTORE_END_STRING (l);
	    /* check for repeated prefix */
	    for (q = 0; q < i.prefixes; q++)
	      if (i.prefix[q] == prefix->prefix_code)
		{
		  as_bad ("same prefix used twice; you don't really want this!");
		  return;
		}
	    if (i.prefixes == MAX_PREFIXES)
	      {
		as_bad ("too many opcode prefixes");
		return;
	      }
	    i.prefix[i.prefixes++] = prefix->prefix_code;
	    if (prefix->prefix_code == REPE || prefix->prefix_code == REPNE)
	      expecting_string_instruction = 1;
	    /* skip past PREFIX_SEPERATOR and reset token_start */
d1082 2
a1083 6
      }
    END_STRING_AND_SAVE (l);
    if (token_start == l)
      {
	as_bad ("expecting opcode; got nothing");
	return;
a1085 3
    /* Lookup insn in hash; try intel & att naming conventions if appropriate;
       that is:  we only use the opcode suffix 'b' 'w' or 'l' if we need to. */
    current_templates = (templates *) hash_find (op_hash, token_start);
d1088 21
a1108 11
	int last_index = strlen (token_start) - 1;
	char last_char = token_start[last_index];
	switch (last_char)
	  {
	  case DWORD_OPCODE_SUFFIX:
	  case WORD_OPCODE_SUFFIX:
	  case BYTE_OPCODE_SUFFIX:
	    token_start[last_index] = '\0';
	    current_templates = (templates *) hash_find (op_hash, token_start);
	    token_start[last_index] = last_char;
	    i.suffix = last_char;
d1112 1
a1112 1
	    as_bad ("no such 386 instruction: `%s'", token_start);
a1115 1
    RESTORE_END_STRING (l);
d1118 2
a1119 3
    if (expecting_string_instruction &&
	!IS_STRING_INSTRUCTION (current_templates->
				start->base_opcode))
d1121 2
a1122 1
	as_bad ("expecting string instruction after rep/repne");
d1127 1
a1127 7
    if (*l != END_OF_INSN &&
	/* For string instructions, we ignore any operands if given.  This
	   kludges, for example, 'rep/movsb %ds:(%esi), %es:(%edi)' where
	   the operands are always going to be the same, and are not really
	   encoded in machine code. */
	!IS_STRING_INSTRUCTION (current_templates->
				start->base_opcode))
d1130 7
d1140 3
a1142 1
	    while (!is_operand_char (*l) && *l != END_OF_INSN)
d1144 4
a1147 8
		if (!is_space_char (*l))
		  {
		    as_bad ("invalid character %s before %s operand",
			    output_invalid (*l),
			    ordinal_names[i.operands]);
		    return;
		  }
		l++;
d1150 2
a1151 2
	    paren_not_balenced = 0;
	    while (paren_not_balenced || *l != ',')
d1155 1
a1155 1
		    if (paren_not_balenced)
d1157 6
a1162 2
			as_bad ("unbalenced parenthesis in %s operand.",
				ordinal_names[i.operands]);
d1170 1
a1170 1
		    as_bad ("invalid character %s in %s operand",
d1172 1
a1172 1
			    ordinal_names[i.operands]);
d1175 14
a1188 4
		if (*l == '(')
		  ++paren_not_balenced;
		if (*l == ')')
		  --paren_not_balenced;
d1197 1
a1197 1
		    as_bad ("spurious operands; (%d operands/instruction max)",
d1203 6
a1208 1
		operand_ok = i386_operand (token_start);
d1218 1
a1218 1
		    as_bad ("expecting operand after ','; got nothing");
d1223 1
a1223 1
		    as_bad ("expecting operand before ','; got nothing");
d1242 1
a1242 1
  /* Now we've parsed the opcode into a set of templates, and have the
d1249 12
a1260 25
#define MATCH(overlap,given_type) \
	(overlap && \
	 (((overlap & (JumpAbsolute|BaseIndex|Mem8)) \
	   == (given_type & (JumpAbsolute|BaseIndex|Mem8))) \
	  || (overlap == InOutPortReg)))


  /* If m0 and m1 are register matches they must be consistent
     with the expected operand types t0 and t1.
     That is, if both m0 & m1 are register matches
     i.e. ( ((m0 & (Reg)) && (m1 & (Reg)) ) ?
     then, either 1. or 2. must be true:
     1. the expected operand type register overlap is null:
     (t0 & t1 & Reg) == 0
     AND
     the given register overlap is null:
     (m0 & m1 & Reg) == 0
     2. the expected operand type register overlap == the given
     operand type overlap:  (t0 & t1 & m0 & m1 & Reg).
     */
#define CONSISTENT_REGISTER_MATCH(m0, m1, t0, t1) \
	    ( ((m0 & (Reg)) && (m1 & (Reg))) ? \
	     ( ((t0 & t1 & (Reg)) == 0 && (m0 & m1 & (Reg)) == 0) || \
	      ((t0 & t1) & (m0 & m1) & (Reg)) \
	      ) : 1)
a1262 1
    expressionS *exp;
d1265 42
d1308 1
a1308 4
    overlap0 = overlap1 = overlap2 = found_reverse_match = 0;
    for (t = current_templates->start;
	 t < current_templates->end;
	 t++)
d1310 4
a1313 5
	/* must have right number of operands */
	if (i.operands != t->operands)
	  continue;
	else if (!t->operands)
	  break;		/* 0 operands always matches */
d1315 87
a1401 2
	overlap0 = i.types[0] & t->operand_types[0];
	switch (t->operands)
d1404 1
a1404 1
	    if (!MATCH (overlap0, i.types[0]))
d1410 6
a1415 5
	    if (!MATCH (overlap0, i.types[0]) ||
		!MATCH (overlap1, i.types[1]) ||
		!CONSISTENT_REGISTER_MATCH (overlap0, overlap1,
					    t->operand_types[0],
					    t->operand_types[1]))
d1419 1
a1419 1
		if (!(t->opcode_modifier & COMES_IN_BOTH_DIRECTIONS))
d1425 6
a1430 5
		if (!MATCH (overlap0, i.types[0]) ||
		    !MATCH (overlap1, i.types[1]) ||
		    !CONSISTENT_REGISTER_MATCH (overlap0, overlap1,
						t->operand_types[0],
						t->operand_types[1]))
d1435 6
a1440 5
		/* found a reverse match here -- slip through */
		/* found_reverse_match holds which of D or FloatD we've found */
		found_reverse_match = t->opcode_modifier & COMES_IN_BOTH_DIRECTIONS;
	      }			/* endif: not forward match */
	    /* found either forward/reverse 2 operand match here */
d1443 4
d1448 6
a1453 7
		if (!MATCH (overlap2, i.types[2]) ||
		    !CONSISTENT_REGISTER_MATCH (overlap0, overlap2,
						t->operand_types[0],
						t->operand_types[2]) ||
		    !CONSISTENT_REGISTER_MATCH (overlap1, overlap2,
						t->operand_types[1],
						t->operand_types[2]))
d1463 2
a1464 1
	as_bad ("operands given don't match any known 386 instruction");
d1468 14
a1481 1
    /* Copy the template we found (we may change it!). */
d1483 7
a1489 1
    t = &i.tm;			/* alter new copy of template */
d1491 16
a1506 3
    /* If the matched instruction specifies an explicit opcode suffix,
       use it - and make sure none has already been specified.  */
    if (t->opcode_modifier & (Data16|Data32))
d1508 17
a1524 1
	if (i.suffix)
d1526 7
a1532 2
	    as_bad ("extraneous opcode suffix given");
	    return;
a1533 4
	if (t->opcode_modifier & Data16)
	  i.suffix = WORD_OPCODE_SUFFIX;
	else
	  i.suffix = DWORD_OPCODE_SUFFIX;
d1536 3
a1538 3
    /* If there's no opcode suffix we try to invent one based on register
       operands. */
    if (!i.suffix && i.reg_operands)
d1540 4
a1543 11
	/* We take i.suffix from the LAST register operand specified.  This
	   assumes that the last register operands is the destination register
	   operand. */
	int op;
	for (op = 0; op < MAX_OPERANDS; op++)
	  if (i.types[op] & Reg)
	    {
	      i.suffix = ((i.types[op] & Reg8) ? BYTE_OPCODE_SUFFIX :
			  (i.types[op] & Reg16) ? WORD_OPCODE_SUFFIX :
			  DWORD_OPCODE_SUFFIX);
	    }
d1545 124
a1668 29
    else if (i.suffix != 0
	     && i.reg_operands != 0
	     && (i.types[i.operands - 1] & Reg) != 0)
      {
	int bad;

	/* If the last operand is a register, make sure it is
           compatible with the suffix.  */

	bad = 0;
	switch (i.suffix)
	  {
	  default:
	    abort ();
	  case BYTE_OPCODE_SUFFIX:
	    /* If this is an eight bit register, it's OK.  If it's the
               16 or 32 bit version of an eight bit register, we will
               just use the low portion, and that's OK too.  */
	    if ((i.types[i.operands - 1] & Reg8) == 0
		&& i.regs[i.operands - 1]->reg_num >= 4)
	      bad = 1;
	    break;
	  case WORD_OPCODE_SUFFIX:
	  case DWORD_OPCODE_SUFFIX:
	    /* We don't insist on the presence or absence of the e
               prefix on the register, but we reject eight bit
               registers.  */
	    if ((i.types[i.operands - 1] & Reg8) != 0)
	      bad = 1;
d1670 6
a1675 2
	if (bad)
	  as_bad ("register does not match opcode suffix");
d1679 1
a1679 2
       given in i.suffix. Note:  overlap2 cannot be an immediate!
       We assume this. */
d1684 11
a1694 1
	if (!i.suffix)
d1696 1
a1696 1
	    as_bad ("no opcode suffix given; can't determine immediate size");
a1698 2
	overlap0 &= (i.suffix == BYTE_OPCODE_SUFFIX ? (Imm8 | Imm8S) :
		     (i.suffix == WORD_OPCODE_SUFFIX ? Imm16 : Imm32));
d1704 11
a1714 1
	if (!i.suffix)
d1716 1
a1716 1
	    as_bad ("no opcode suffix given; can't determine immediate size");
a1718 2
	overlap1 &= (i.suffix == BYTE_OPCODE_SUFFIX ? (Imm8 | Imm8S) :
		     (i.suffix == WORD_OPCODE_SUFFIX ? Imm16 : Imm32));
d1720 1
a1722 3
    i.types[1] = overlap1;
    i.types[2] = overlap2;

d1725 4
d1731 2
a1734 10
    if (overlap0 & Imm1)
      i.imm_operands = 0;	/* kludge for shift insns */

    if (found_reverse_match)
      {
	unsigned int save;
	save = t->operand_types[0];
	t->operand_types[0] = t->operand_types[1];
	t->operand_types[1] = save;
      }
d1737 1
a1737 2
       size given by i.suffix: we never have to change things for byte insns,
       or when no opcode suffix is need to size the operands. */
d1739 1
a1739 1
    if (!i.suffix && (t->opcode_modifier & W))
d1741 1
a1741 1
	as_bad ("no opcode suffix given and no register operands; can't size instruction");
d1745 13
a1757 1
    if (i.suffix && i.suffix != BYTE_OPCODE_SUFFIX)
d1759 25
a1783 6
	/* Select between byte and word/dword operations. */
	if (t->opcode_modifier & W)
	  t->base_opcode |= W;
	/* Now select between word & dword operations via the
				   operand size prefix. */
	if ((i.suffix == WORD_OPCODE_SUFFIX) ^ flag_16bit_code)
d1785 2
a1786 7
	    if (i.prefixes == MAX_PREFIXES)
	      {
		as_bad ("%d prefixes given and 'w' opcode suffix gives too many prefixes",
			MAX_PREFIXES);
		return;
	      }
	    i.prefix[i.prefixes++] = WORD_PREFIX_OPCODE;
d1790 19
d1812 1
a1812 1
        /* Default segment register this instruction will use
a1816 14
	/* True if this instruction uses a memory addressing mode,
	   and therefore may need an address-size prefix.  */
	int uses_mem_addrmode = 0;


	/* If we found a reverse match we must alter the opcode direction bit
	   found_reverse_match holds bit to set (different for int &
	   float insns). */

	if (found_reverse_match)
	  {
	    t->base_opcode |= found_reverse_match;
	  }

d1818 9
a1826 5
	   imul $imm, %reg, %reg. */
	if (t->opcode_modifier & imulKludge)
	  {
	    /* Pretend we saw the 3 operand case. */
	    i.regs[2] = i.regs[1];
d1830 1
a1830 15
	/* Certain instructions expect the destination to be in the i.rm.reg
	   field.  This is by far the exceptional case.  For these
	   instructions, if the source operand is a register, we must reverse
	   the i.rm.reg and i.rm.regmem fields.  We accomplish this by faking
	   that the two register operands were given in the reverse order. */
	if ((t->opcode_modifier & ReverseRegRegmem) && i.reg_operands == 2)
	  {
	    unsigned int first_reg_operand = (i.types[0] & Reg) ? 0 : 1;
	    unsigned int second_reg_operand = first_reg_operand + 1;
	    reg_entry *tmp = i.regs[first_reg_operand];
	    i.regs[first_reg_operand] = i.regs[second_reg_operand];
	    i.regs[second_reg_operand] = tmp;
	  }

	if (t->opcode_modifier & ShortForm)
d1835 2
a1836 13
	    t->base_opcode |= i.regs[op]->reg_num;
	  }
	else if (t->opcode_modifier & ShortFormW)
	  {
	    /* Short form with 0x8 width bit.  Register is always dest. operand */
	    t->base_opcode |= i.regs[1]->reg_num;
	    if (i.suffix == WORD_OPCODE_SUFFIX ||
		i.suffix == DWORD_OPCODE_SUFFIX)
	      t->base_opcode |= 0x8;
	  }
	else if (t->opcode_modifier & Seg2ShortForm)
	  {
	    if (t->base_opcode == POP_SEG_SHORT && i.regs[0]->reg_num == 1)
d1838 15
a1852 2
		as_bad ("you can't 'pop cs' on the 386.");
		return;
a1853 18
	    t->base_opcode |= (i.regs[0]->reg_num << 3);
	  }
	else if (t->opcode_modifier & Seg3ShortForm)
	  {
	    /* 'push %fs' is 0x0fa0; 'pop %fs' is 0x0fa1.
	       'push %gs' is 0x0fa8; 'pop %fs' is 0x0fa9.
	       So, only if i.regs[0]->reg_num == 5 (%gs) do we need
	       to change the opcode. */
	    if (i.regs[0]->reg_num == 5)
	      t->base_opcode |= 0x08;
	  }
	else if ((t->base_opcode & ~DW) == MOV_AX_DISP32)
	  {
	    /* This is a special non-modrm instruction
	       that addresses memory with a 32-bit displacement mode anyway,
	       and thus requires an address-size prefix if in 16-bit mode.  */
	    uses_mem_addrmode = 1;
	    default_seg = &ds;
d1855 1
a1855 1
	else if (t->opcode_modifier & Modrm)
d1857 4
a1860 4
	    /* The opcode is completed (modulo t->extension_opcode which must
	       be put into the modrm byte.
	       Now, we make the modrm & index base bytes based on all the info
	       we've collected. */
d1867 5
a1871 1
		source = (i.types[0] & (Reg | SReg2 | SReg3 | Control | Debug | Test)) ? 0 : 1;
d1873 1
d1875 8
a1882 5
		/* We must be careful to make sure that all
		   segment/control/test/debug registers go into the i.rm.reg
		   field (despite the whether they are source or destination
		   operands). */
		if (i.regs[dest]->reg_type & (SReg2 | SReg3 | Control | Debug | Test))
d1884 2
a1885 2
		    i.rm.reg = i.regs[dest]->reg_num;
		    i.rm.regmem = i.regs[source]->reg_num;
d1889 2
a1890 2
		    i.rm.reg = i.regs[source]->reg_num;
		    i.rm.regmem = i.regs[dest]->reg_num;
d1898 3
a1900 1
		    unsigned int op = (i.types[0] & Mem) ? 0 : ((i.types[1] & Mem) ? 1 : 2);
d1902 1
a1902 2
		    /* Encode memory operand into modrm byte and base index
		       byte. */
d1904 1
a1904 1
		    if (i.base_reg == esp && !i.index_reg)
d1906 28
a1933 7
			/* <disp>(%esp) becomes two byte modrm with no index
			   register. */
			i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
			i.rm.mode = mode_from_disp_size (i.types[op]);
			i.bi.base = ESP_REG_NUM;
			i.bi.index = NO_INDEX_REGISTER;
			i.bi.scale = 0;	/* Must be zero! */
d1935 1
a1935 1
		    else if (i.base_reg == ebp && !i.index_reg)
d1937 1
a1937 1
			if (!(i.types[op] & Disp))
d1939 23
a1961 5
			    /* Must fake a zero byte displacement.  There is
			       no direct way to code '(%ebp)' directly. */
			    fake_zero_displacement = 1;
			    /* fake_zero_displacement code does not set this. */
			    i.types[op] |= Disp8;
a1963 1
			i.rm.regmem = EBP_REG_NUM;
d1965 1
a1965 1
		    else if (!i.base_reg && (i.types[op] & BaseIndex))
d1967 5
a1971 15
			/* There are three cases here.
			   Case 1:  '<32bit disp>(,1)' -- indirect absolute.
			   (Same as cases 2 & 3 with NO index register)
			   Case 2:  <32bit disp> (,<index>) -- no base register with disp
			   Case 3:  (, <index>)       --- no base register;
			   no disp (must add 32bit 0 disp). */
			i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
			i.rm.mode = 0;	/* 32bit mode */
			i.bi.base = NO_BASE_REGISTER;
			i.types[op] &= ~Disp;
			i.types[op] |= Disp32;	/* Must be 32bit! */
			if (i.index_reg)
			  {	/* case 2 or case 3 */
			    i.bi.index = i.index_reg->reg_num;
			    i.bi.scale = i.log2_scale_factor;
d1973 4
a1976 1
			      fake_zero_displacement = 1;	/* case 3 */
d1978 6
a1983 1
			else
d1985 13
a1997 2
			    i.bi.index = NO_INDEX_REGISTER;
			    i.bi.scale = 0;
d1999 1
a1999 15
		      }
		    else if (i.disp_operands && !i.base_reg && !i.index_reg)
		      {
			/* Operand is just <32bit disp> */
			i.rm.regmem = EBP_REG_NUM;
			i.rm.mode = 0;
			i.types[op] &= ~Disp;
			i.types[op] |= Disp32;
		      }
		    else
		      {
			/* It's not a special case; rev'em up. */
			i.rm.regmem = i.base_reg->reg_num;
			i.rm.mode = mode_from_disp_size (i.types[op]);
			if (i.index_reg)
d2001 1
a2002 9
			    i.bi.base = i.base_reg->reg_num;
			    i.bi.index = i.index_reg->reg_num;
			    i.bi.scale = i.log2_scale_factor;
			    if (i.base_reg == ebp && i.disp_operands == 0)
			      {	/* pace */
				fake_zero_displacement = 1;
				i.types[op] |= Disp8;
				i.rm.mode = mode_from_disp_size (i.types[op]);
			      }
d2004 1
d2006 1
d2011 3
d2015 1
a2015 1
			i.disps[op] = exp;
a2020 18

		    /* Find the default segment for the memory operand.
		       Used to optimize out explicit segment specifications.  */
		    if (i.seg)
		      {
			unsigned int seg_index;

			if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING)
			  {
			    seg_index = (i.rm.mode << 3) | i.bi.base;
			    default_seg = two_byte_segment_defaults[seg_index];
			  }
			else
			  {
			    seg_index = (i.rm.mode << 3) | i.rm.regmem;
			    default_seg = one_byte_segment_defaults[seg_index];
			  }
		      }
d2023 5
a2027 4
		/* Fill in i.rm.reg or i.rm.regmem field with register operand
		   (if any) based on t->extension_opcode. Again, we must be
		   careful to make sure that segment/control/debug/test
		   registers are coded into the i.rm.reg field. */
d2031 11
a2041 2
		    (i.types[0] & (Reg | SReg2 | SReg3 | Control | Debug | Test)) ? 0 :
		    (i.types[1] & (Reg | SReg2 | SReg3 | Control | Debug | Test)) ? 1 : 2;
d2044 2
a2045 2
		    if (t->extension_opcode != None)
		      i.rm.regmem = i.regs[op]->reg_num;
d2047 1
a2047 1
		      i.rm.reg = i.regs[op]->reg_num;
d2051 1
a2051 1
		       operand int the regmem field */
d2057 2
a2058 2
		if (t->extension_opcode != None)
		  i.rm.reg = t->extension_opcode;
a2059 3

	    if (i.rm.mode != 3)
	      uses_mem_addrmode = 1;
d2061 1
a2061 5

	/* GAS currently doesn't support 16-bit memory addressing modes at all,
	   so if we're writing 16-bit code and using a memory addressing mode,
	   always spew out an address size prefix.  */
	if (uses_mem_addrmode && flag_16bit_code)
d2063 1
a2063 1
	    if (i.prefixes == MAX_PREFIXES)
d2065 2
a2066 3
	        as_bad ("%d prefixes given and address size override gives too many prefixes",
	        	MAX_PREFIXES);
	        return;
d2068 11
a2078 1
	    i.prefix[i.prefixes++] = ADDR_PREFIX_OPCODE;
d2087 1
a2087 1
	if ((i.seg) && (i.seg != default_seg))
d2089 2
a2090 7
	    if (i.prefixes == MAX_PREFIXES)
	      {
	        as_bad ("%d prefixes given and %s segment override gives too many prefixes",
	    	    MAX_PREFIXES, i.seg->seg_name);
	        return;
	      }
	    i.prefix[i.prefixes++] = i.seg->seg_prefix;
d2093 5
d2101 1
a2101 1
  if (t->base_opcode == INT_OPCODE && i.imms[0]->X_add_number == 3)
d2103 1
a2103 1
      t->base_opcode = INT3_OPCODE;
d2107 10
d2122 50
a2171 1
    if (t->opcode_modifier & Jump)
d2173 1
a2173 1
	unsigned long n = i.disps[0]->X_add_number;
d2175 1
a2175 1
	if (i.disps[0]->X_op == O_constant)
d2177 3
a2179 1
	    if (fits_in_signed_byte (n))
d2181 3
a2183 36
		p = frag_more (2);
		insn_size += 2;
		p[0] = t->base_opcode;
		p[1] = n;
	      }
	    else
	      {	/* It's an absolute word/dword displacement. */

	        /* Use only 16-bit jumps for 16-bit code,
		   because text segments are limited to 64K anyway;
	           use only 32-bit jumps for 32-bit code,
		   because they're faster.  */
		int jmp_size = flag_16bit_code ? 2 : 4;
	      	if (flag_16bit_code && !fits_in_signed_word (n))
		  {
		    as_bad ("16-bit jump out of range");
		    return;
		  }

		if (t->base_opcode == JUMP_PC_RELATIVE)
		  {		/* pace */
		    /* unconditional jump */
		    p = frag_more (1 + jmp_size);
		    insn_size += 1 + jmp_size;
		    p[0] = (char) 0xe9;
		    md_number_to_chars (&p[1], (valueT) n, jmp_size);
		  }
		else
		  {
		    /* conditional jump */
		    p = frag_more (2 + jmp_size);
		    insn_size += 2 + jmp_size;
		    p[0] = TWO_BYTE_OPCODE_ESCAPE;
		    p[1] = t->base_opcode + 0x10;
		    md_number_to_chars (&p[2], (valueT) n, jmp_size);
		  }
d2188 3
d2192 3
a2195 1
	        FRAG_APPEND_1_CHAR (WORD_PREFIX_OPCODE);
d2197 3
d2202 3
a2204 15
	    /* It's a symbol; end frag & setup for relax.
	       Make sure there are more than 6 chars left in the current frag;
	       if not we'll have to start a new one. */
	    frag_grow (7);
	    p = frag_more (1);
	    insn_size += 1;
	    p[0] = t->base_opcode;
	    frag_var (rs_machine_dependent,
		      6,	/* 2 opcode/prefix + 4 displacement */
		      1,
		      ((unsigned char) *p == JUMP_PC_RELATIVE
		       ? ENCODE_RELAX_STATE (UNCOND_JUMP, BYTE)
		       : ENCODE_RELAX_STATE (COND_JUMP, BYTE)),
		      i.disps[0]->X_add_symbol,
		      (long) n, p);
a2205 6
      }
    else if (t->opcode_modifier & (JumpByte | JumpDword))
      {
	int size = (t->opcode_modifier & JumpByte) ? 1 : 4;
	unsigned long n = i.disps[0]->X_add_number;
	unsigned char *q;
d2207 4
a2210 2
	/* The jcx/jecx instruction might need a data size prefix.  */
	for (q = i.prefix; q < i.prefix + i.prefixes; q++)
d2212 9
a2220 6
	    if (*q == WORD_PREFIX_OPCODE)
	      {
	        FRAG_APPEND_1_CHAR (WORD_PREFIX_OPCODE);
	        insn_size += 1;
		break;
	      }
d2222 10
d2233 6
a2238 1
	if ((size == 4) && (flag_16bit_code))
d2240 3
a2242 2
	    FRAG_APPEND_1_CHAR (WORD_PREFIX_OPCODE);
	    insn_size += 1;
d2245 13
a2257 1
	if (fits_in_unsigned_byte (t->base_opcode))
d2259 1
a2259 11
	    FRAG_APPEND_1_CHAR (t->base_opcode);
	    insn_size += 1;
	  }
	else
	  {
	    p = frag_more (2);	/* opcode can be at most two bytes */
	    insn_size += 2;
	    /* put out high byte first: can't use md_number_to_chars! */
	    *p++ = (t->base_opcode >> 8) & 0xff;
	    *p = t->base_opcode & 0xff;
	  }
d2261 3
a2263 6
	p = frag_more (size);
	insn_size += size;
	if (i.disps[0]->X_op == O_constant)
	  {
	    md_number_to_chars (p, (valueT) n, size);
	    if (size == 1 && !fits_in_signed_byte (n))
d2265 2
a2266 2
		as_bad ("loop/jecx only takes byte displacement; %lu shortened to %d",
			n, *p);
d2268 1
d2271 6
a2276 25
	  {
	    fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			 i.disps[0], 1, reloc (size, 1, i.disp_reloc[0]));

	  }
      }
    else if (t->opcode_modifier & JumpInterSegment)
      {
	if (flag_16bit_code)
	  {
	    FRAG_APPEND_1_CHAR (WORD_PREFIX_OPCODE);
	    insn_size += 1;
	  }

	p = frag_more (1 + 2 + 4);	/* 1 opcode; 2 segment; 4 offset */
	insn_size += 1 + 2 + 4;
	p[0] = t->base_opcode;
	if (i.imms[1]->X_op == O_constant)
	  md_number_to_chars (p + 1, (valueT) i.imms[1]->X_add_number, 4);
	else
	  fix_new_exp (frag_now, p + 1 - frag_now->fr_literal, 4,
		       i.imms[1], 0, BFD_RELOC_32);
	if (i.imms[0]->X_op != O_constant)
	  as_bad ("can't handle non absolute segment in long call/jmp");
	md_number_to_chars (p + 5, (valueT) i.imms[0]->X_add_number, 2);
d2283 4
a2286 2
	/* First the prefix bytes. */
	for (q = i.prefix; q < i.prefix + i.prefixes; q++)
d2288 6
a2293 3
	    p = frag_more (1);
	    insn_size += 1;
	    md_number_to_chars (p, (valueT) *q, 1);
d2297 1
a2297 1
	if (fits_in_unsigned_byte (t->base_opcode))
a2298 1
	    FRAG_APPEND_1_CHAR (t->base_opcode);
d2300 1
d2302 1
a2302 1
	else if (fits_in_unsigned_word (t->base_opcode))
d2304 1
a2305 1
	    insn_size += 2;
d2307 2
a2308 2
	    *p++ = (t->base_opcode >> 8) & 0xff;
	    *p = t->base_opcode & 0xff;
d2312 1
a2312 1
	    if (t->base_opcode & 0xff000000)
d2314 1
d2316 1
a2316 2
		insn_size += 4;
		*p++ = (t->base_opcode >> 24) & 0xff;
d2320 1
a2321 1
		insn_size += 3;
d2323 3
a2325 3
	    *p++ = (t->base_opcode >> 16) & 0xff;
	    *p++ = (t->base_opcode >> 8) & 0xff;
	    *p = (t->base_opcode) & 0xff;
d2328 2
a2329 2
	/* Now the modrm byte and base index byte (if present). */
	if (t->opcode_modifier & Modrm)
d2331 1
a2332 2
	    insn_size += 1;
	    /* md_number_to_chars (p, i.rm, 1); */
d2338 7
a2344 3
	    /* If i.rm.regmem == ESP (4) && i.rm.mode != Mode 3 (Register mode)
				   ==> need second modrm byte. */
	    if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING && i.rm.mode != 3)
d2346 1
d2348 4
a2351 5
		insn_size += 1;
		/* md_number_to_chars (p, i.bi, 1); */
		md_number_to_chars (p, (valueT) (i.bi.base << 0
						 | i.bi.index << 3
						 | i.bi.scale << 6),
d2362 1
a2362 1
		if (i.disps[n])
d2364 1
a2364 1
		    if (i.disps[n]->X_op == O_constant)
d2366 4
a2369 1
			if (i.types[n] & (Disp8 | Abs8))
d2371 13
a2383 21
			    p = frag_more (1);
			    insn_size += 1;
			    md_number_to_chars (p,
						(valueT) i.disps[n]->X_add_number,
						1);
			  }
			else if (i.types[n] & (Disp16 | Abs16))
			  {
			    p = frag_more (2);
			    insn_size += 2;
			    md_number_to_chars (p,
						(valueT) i.disps[n]->X_add_number,
						2);
			  }
			else
			  {	/* Disp32|Abs32 */
			    p = frag_more (4);
			    insn_size += 4;
			    md_number_to_chars (p,
						(valueT) i.disps[n]->X_add_number,
						4);
d2385 3
d2390 11
a2400 7
		      {		/* not absolute_section */
			/* need a 32-bit fixup (don't support 8bit non-absolute disps) */
			p = frag_more (4);
			insn_size += 4;
			fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
					    i.disps[n], 0, 
					    TC_RELOC(i.disp_reloc[n], BFD_RELOC_32));
d2413 1
a2413 1
		if (i.imms[n])
d2415 1
a2415 1
		    if (i.imms[n]->X_op == O_constant)
d2417 4
a2420 1
			if (i.types[n] & (Imm8 | Imm8S))
d2422 12
a2433 21
			    p = frag_more (1);
			    insn_size += 1;
			    md_number_to_chars (p,
						(valueT) i.imms[n]->X_add_number,
						1);
			  }
			else if (i.types[n] & Imm16)
			  {
			    p = frag_more (2);
			    insn_size += 2;
			    md_number_to_chars (p,
						(valueT) i.imms[n]->X_add_number,
						2);
			  }
			else
			  {
			    p = frag_more (4);
			    insn_size += 4;
			    md_number_to_chars (p,
						(valueT) i.imms[n]->X_add_number,
						4);
d2435 3
d2442 1
a2442 1
			   non-absolute ims).  Try to support other
d2444 6
a2449 3
			int r_type;
			int size;
			int pcrel = 0;
d2451 3
a2453 1
			if (i.types[n] & (Imm8 | Imm8S))
d2455 2
a2456 5
			else if (i.types[n] & Imm16)
			  size = 2;
			else
			  size = 4;
			r_type = reloc (size, 0, i.disp_reloc[0]);
d2458 1
a2458 1
			insn_size += size;
d2460 1
a2460 1
			if (r_type == BFD_RELOC_32
d2462 5
a2466 4
			    && GOT_symbol == i.imms[n]->X_add_symbol
			    && (i.imms[n]->X_op == O_symbol
				|| (i.imms[n]->X_op == O_add
				    && (i.imms[n]->X_op_symbol->sy_value.X_op
d2469 2
a2470 2
			    r_type = BFD_RELOC_386_GOTPC;
			    i.imms[n]->X_add_number += 3;
d2474 1
a2474 1
				     i.imms[n], pcrel, r_type);
d2487 877
a3363 1
  }
d3365 1
a3365 1

d3373 3
a3375 4
  register char *op_string = operand_string;

  /* Address of '\0' at end of operand_string. */
  char *end_of_operand_string = operand_string + strlen (operand_string);
d3377 2
a3378 3
  /* Start and end of displacement string expression (if found). */
  char *displacement_string_start = NULL;
  char *displacement_string_end = NULL;
d3384 3
a3386 1
      op_string++;
d3391 2
a3392 1
  if (*op_string == REGISTER_PREFIX)
d3394 6
a3399 9
      register reg_entry *r;
      if (!(r = parse_register (op_string)))
	{
	  as_bad ("bad register name ('%s')", op_string);
	  return 0;
	}
      /* Check for segment override, rather than segment register by
	 searching for ':' after %<x>s where <x> = s, c, d, e, f, g. */
      if ((r->reg_type & (SReg2 | SReg3)) && op_string[3] == ':')
d3404 1
a3404 1
	      i.seg = (seg_entry *) & es;
d3407 1
a3407 1
	      i.seg = (seg_entry *) & cs;
d3410 1
a3410 1
	      i.seg = (seg_entry *) & ss;
d3413 1
a3413 1
	      i.seg = (seg_entry *) & ds;
d3416 1
a3416 1
	      i.seg = (seg_entry *) & fs;
d3419 1
a3419 1
	      i.seg = (seg_entry *) & gs;
d3422 10
a3431 4
	  op_string += 4;	/* skip % <x> s : */
	  operand_string = op_string;	/* Pretend given string starts here. */
	  if (!is_digit_char (*op_string) && !is_identifier_char (*op_string)
	      && *op_string != '(' && *op_string != ABSOLUTE_PREFIX)
d3433 1
a3433 1
	      as_bad ("bad memory operand after segment override");
d3439 3
a3441 1
	      op_string++;
d3446 7
a3452 2
      i.types[this_operand] |= r->reg_type;
      i.regs[this_operand] = r;
d3455 5
d3462 2
a3463 43
      char *save_input_line_pointer;
      segT exp_seg = 0;
      expressionS *exp;

      if (i.imm_operands == MAX_IMMEDIATE_OPERANDS)
	{
	  as_bad ("only 1 or 2 immediate operands are allowed");
	  return 0;
	}

      exp = &im_expressions[i.imm_operands++];
      i.imms[this_operand] = exp;
      save_input_line_pointer = input_line_pointer;
      input_line_pointer = ++op_string;	/* must advance op_string! */
      SKIP_WHITESPACE ();
      exp_seg = expression (exp);
      input_line_pointer = save_input_line_pointer;

      if (exp->X_op == O_absent)
	{
	  /* missing or bad expr becomes absolute 0 */
	  as_bad ("missing or invalid immediate expression '%s' taken as 0",
		  operand_string);
	  exp->X_op = O_constant;
	  exp->X_add_number = 0;
	  exp->X_add_symbol = (symbolS *) 0;
	  exp->X_op_symbol = (symbolS *) 0;
	  i.types[this_operand] |= Imm;
	}
      else if (exp->X_op == O_constant)
	{
	  i.types[this_operand] |=
	    smallest_imm_type ((unsigned long) exp->X_add_number);
	}
#ifdef OBJ_AOUT
      else if (exp_seg != text_section
	       && exp_seg != data_section
	       && exp_seg != bss_section
	       && exp_seg != undefined_section
#ifdef BFD_ASSEMBLER
	       && ! bfd_is_com_section (exp_seg)
#endif
	       )
d3465 1
a3465 2
	seg_unimplemented:
	  as_bad ("Unimplemented segment type %d in parse_operand", exp_seg);
d3468 2
a3469 20
#endif
      else
	{
	  /* this is an address ==> 32bit */
	  i.types[this_operand] |= Imm32;
	}
      /* shorten this type of this operand if the instruction wants
       * fewer bits than are present in the immediate.  The bit field
       * code can put out 'andb $0xffffff, %al', for example.   pace
       * also 'movw $foo,(%eax)'
       */
      switch (i.suffix)
	{
	case WORD_OPCODE_SUFFIX:
	  i.types[this_operand] |= Imm16;
	  break;
	case BYTE_OPCODE_SUFFIX:
	  i.types[this_operand] |= Imm16 | Imm8 | Imm8S;
	  break;
	}
d3471 3
a3473 2
  else if (is_digit_char (*op_string) || is_identifier_char (*op_string)
	   || *op_string == '(')
d3476 5
a3480 2
      register char *base_string;
      unsigned int found_base_index_form;
d3483 3
a3485 1
      if (i.mem_operands == MAX_MEMORY_OPERANDS)
d3487 2
a3488 1
	  as_bad ("more than 1 memory reference in instruction");
a3490 16
      i.mem_operands++;

      /* Determine type of memory operand from opcode_suffix;
		   no opcode suffix implies general memory references. */
      switch (i.suffix)
	{
	case BYTE_OPCODE_SUFFIX:
	  i.types[this_operand] |= Mem8;
	  break;
	case WORD_OPCODE_SUFFIX:
	  i.types[this_operand] |= Mem16;
	  break;
	case DWORD_OPCODE_SUFFIX:
	default:
	  i.types[this_operand] |= Mem32;
	}
d3495 11
a3505 3
	 after it. */
      base_string = end_of_operand_string - 1;
      found_base_index_form = 0;
d3508 2
a3509 1
	  unsigned int parens_balenced = 1;
d3516 1
a3516 1
		parens_balenced++;
d3518 1
a3518 1
		parens_balenced--;
d3520 1
a3520 5
	  while (parens_balenced);
	  base_string++;	/* Skip past '('. */
	  if (*base_string == REGISTER_PREFIX || *base_string == ',')
	    found_base_index_form = 1;
	}
d3522 1
a3522 21
      /* If we can't parse a base index register expression, we've found
	 a pure displacement expression.  We set up displacement_string_start
	 and displacement_string_end for the code below. */
      if (!found_base_index_form)
	{
	  displacement_string_start = op_string;
	  displacement_string_end = end_of_operand_string;
	}
      else
	{
	  char *base_reg_name, *index_reg_name, *num_string;
	  int num;

	  i.types[this_operand] |= BaseIndex;

	  /* If there is a displacement set-up for it to be parsed later. */
	  if (base_string != op_string + 1)
	    {
	      displacement_string_start = op_string;
	      displacement_string_end = base_string - 1;
	    }
d3524 8
a3531 2
	  /* Find base register (if any). */
	  if (*base_string != ',')
d3533 1
a3533 18
	      base_reg_name = base_string++;
	      /* skip past register name & parse it */
	      while (isalpha (*base_string))
		base_string++;
	      if (base_string == base_reg_name + 1)
		{
		  as_bad ("can't find base register name after '(%c'",
			  REGISTER_PREFIX);
		  return 0;
		}
	      END_STRING_AND_SAVE (base_string);
	      if (!(i.base_reg = parse_register (base_reg_name)))
		{
		  as_bad ("bad base register name ('%s')", base_reg_name);
		  return 0;
		}
	      RESTORE_END_STRING (base_string);
	    }
d3535 1
a3535 9
	  /* Now check seperator; must be ',' ==> index reg
			   OR num ==> no index reg. just scale factor
			   OR ')' ==> end. (scale factor = 1) */
	  if (*base_string != ',' && *base_string != ')')
	    {
	      as_bad ("expecting ',' or ')' after base register in `%s'",
		      operand_string);
	      return 0;
	    }
d3537 1
a3537 7
	  /* There may index reg here; and there may be a scale factor. */
	  if (*base_string == ',' && *(base_string + 1) == REGISTER_PREFIX)
	    {
	      index_reg_name = ++base_string;
	      while (isalpha (*++base_string));
	      END_STRING_AND_SAVE (base_string);
	      if (!(i.index_reg = parse_register (index_reg_name)))
d3539 3
a3541 2
		  as_bad ("bad index register name ('%s')", index_reg_name);
		  return 0;
a3542 2
	      RESTORE_END_STRING (base_string);
	    }
d3544 2
a3545 14
	  /* Check for scale factor. */
	  if (*base_string == ',' && isdigit (*(base_string + 1)))
	    {
	      num_string = ++base_string;
	      while (is_digit_char (*base_string))
		base_string++;
	      if (base_string == num_string)
		{
		  as_bad ("can't find a scale factor after ','");
		  return 0;
		}
	      END_STRING_AND_SAVE (base_string);
	      /* We've got a scale factor. */
	      if (!sscanf (num_string, "%d", &num))
d3547 51
a3597 21
		  as_bad ("can't parse scale factor from '%s'", num_string);
		  return 0;
		}
	      RESTORE_END_STRING (base_string);
	      switch (num)
		{		/* must be 1 digit scale */
		case 1:
		  i.log2_scale_factor = 0;
		  break;
		case 2:
		  i.log2_scale_factor = 1;
		  break;
		case 4:
		  i.log2_scale_factor = 2;
		  break;
		case 8:
		  i.log2_scale_factor = 3;
		  break;
		default:
		  as_bad ("expecting scale factor of 1, 2, 4, 8; got %d", num);
		  return 0;
d3599 1
a3599 4
	    }
	  else
	    {
	      if (!i.index_reg && *base_string == ',')
d3601 2
a3602 2
		  as_bad ("expecting index register or scale factor after ','; got '%c'",
			  *(base_string + 1));
d3606 1
a3606 63
	}

      /* If there's an expression begining the operand, parse it,
	 assuming displacement_string_start and displacement_string_end
	 are meaningful. */
      if (displacement_string_start)
	{
	  register expressionS *exp;
	  segT exp_seg = 0;
	  char *save_input_line_pointer;
	  exp = &disp_expressions[i.disp_operands];
	  i.disps[this_operand] = exp;
	  i.disp_reloc[this_operand] = NO_RELOC;
	  i.disp_operands++;
	  save_input_line_pointer = input_line_pointer;
	  input_line_pointer = displacement_string_start;
	  END_STRING_AND_SAVE (displacement_string_end);
#ifndef LEX_AT
	  {
	    /*
	     * We can have operands of the form
	     *   <symbol>@@GOTOFF+<nnn>
	     * Take the easy way out here and copy everything
	     * into a temporary buffer...
	     */
	    register char *cp;
	    if ((cp = strchr (input_line_pointer,'@@')) != NULL) {
	      char tmpbuf[BUFSIZ];
	      
	      if(!GOT_symbol)
		GOT_symbol = symbol_find_or_make(GLOBAL_OFFSET_TABLE_NAME);

	      if (strncmp(cp+1, "PLT", 3) == 0) {
		i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
		*cp = '\0';
		strcpy(tmpbuf, input_line_pointer);
		strcat(tmpbuf, cp+1+3);
		*cp = '@@';
	      } else if (strncmp(cp+1, "GOTOFF", 6) == 0) {
		i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
		*cp = '\0';
		strcpy(tmpbuf, input_line_pointer);
		strcat(tmpbuf, cp+1+6);
		*cp = '@@';
	      } else if (strncmp(cp+1, "GOT", 3) == 0) {
		i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
		*cp = '\0';
		strcpy(tmpbuf, input_line_pointer);
		strcat(tmpbuf, cp+1+3);
		*cp = '@@';
	      } else
		as_bad("Bad reloc specifier '%s' in expression", cp+1);
	      input_line_pointer = tmpbuf;
	    }
	  }
#endif
	  exp_seg = expression (exp);

#ifdef BFD_ASSEMBLER
	  /* We do this to make sure that the section symbol is in
	     the symbol table.  We will ultimately change the relocation
	     to be relative to the beginning of the section */
	  if (i.disp_reloc[this_operand] == BFD_RELOC_386_GOTOFF)
d3608 2
a3609 43
	      if (S_IS_LOCAL(exp->X_add_symbol)
		  && S_GET_SEGMENT (exp->X_add_symbol) != undefined_section)
		section_symbol(exp->X_add_symbol->bsym->section);
	      assert (exp->X_op == O_symbol);
	      exp->X_op = O_subtract;
	      exp->X_op_symbol = GOT_symbol;
	      i.disp_reloc[this_operand] = BFD_RELOC_32;
	    }
#endif

	  if (*input_line_pointer)
	    as_bad ("Ignoring junk '%s' after expression", input_line_pointer);
	  RESTORE_END_STRING (displacement_string_end);
	  input_line_pointer = save_input_line_pointer;
	  if (exp->X_op == O_absent)
	    {
	      /* missing expr becomes absolute 0 */
	      as_bad ("missing or invalid displacement '%s' taken as 0",
		      operand_string);
	      i.types[this_operand] |= (Disp | Abs);
	      exp->X_op = O_constant;
	      exp->X_add_number = 0;
	      exp->X_add_symbol = (symbolS *) 0;
	      exp->X_op_symbol = (symbolS *) 0;
	    }
	  else if (exp->X_op == O_constant)
	    {
	      i.types[this_operand] |= SMALLEST_DISP_TYPE (exp->X_add_number);
	    }
	  else if (exp_seg == text_section
		   || exp_seg == data_section
		   || exp_seg == bss_section
		   || exp_seg == undefined_section)
	    {
	      i.types[this_operand] |= Disp32;
	    }
	  else
	    {
#ifndef OBJ_AOUT
	      i.types[this_operand] |= Disp32;
#else
	      goto seg_unimplemented;
#endif
d3613 4
a3616 3
      /* Make sure the memory operand we've been dealt is valid. */
      if (i.base_reg && i.index_reg &&
	  !(i.base_reg->reg_type & i.index_reg->reg_type & Reg))
d3618 3
a3620 2
	  as_bad ("register size mismatch in (base,index,scale) expression");
	  return 0;
d3622 8
a3629 6
      /*
       * special case for (%dx) while doing input/output op
       */
      if ((i.base_reg &&
	   (i.base_reg->reg_type == (Reg16 | InOutPortReg)) &&
	   (i.index_reg == 0)))
d3631 1
a3631 1
	  i.types[this_operand] |= InOutPortReg;
d3634 4
a3637 11
      if ((i.base_reg && (i.base_reg->reg_type & Reg32) == 0) ||
	  (i.index_reg && (i.index_reg->reg_type & Reg32) == 0))
	{
	  as_bad ("base/index register must be 32 bit register");
	  return 0;
	}
      if (i.index_reg && i.index_reg == esp)
	{
	  as_bad ("%s may not be used as an index register", esp->reg_name);
	  return 0;
	}
d3641 3
a3643 2
      as_bad ("invalid char %s begining %s operand '%s'",
	      output_invalid (*op_string), ordinal_names[this_operand],
d3650 13
a3662 12
/*
 *			md_estimate_size_before_relax()
 *
 * Called just before relax().
 * Any symbol that is now undefined will not become defined.
 * Return the correct fr_subtype in the frag.
 * Return the initial "guess for fr_var" to caller.
 * The guess for fr_var is ACTUALLY the growth beyond fr_fix.
 * Whatever we do to grow fr_fix or fr_var contributes to our returned value.
 * Although it may not be explicit in the frag, pretend fr_var starts with a
 * 0 value.
 */
d3668 31
a3698 2
  register unsigned char *opcode;
  register int old_fr_fix;
a3699 7
  old_fr_fix = fragP->fr_fix;
  opcode = (unsigned char *) fragP->fr_opcode;
  /* We've already got fragP->fr_subtype right;  all we have to do is check
	   for un-relaxable symbols. */
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
    {
      /* symbol is undefined in this segment */
d3704 3
a3706 3
	  fragP->fr_fix += 4;
	  fix_new (fragP, old_fr_fix, 4,
				 fragP->fr_symbol,
d3708 1
a3708 9
		   (GOT_symbol && /* Not quite right - we should switch on
				     presence of @@PLT, but I cannot see how
				     to get to that from here.  We should have
				     done this in md_assemble to really
				     get it right all of the time, but I
				     think it does not matter that much, as
				     this will be right most of the time. ERY*/
		    S_GET_SEGMENT(fragP->fr_symbol) == undefined_section)?
		   BFD_RELOC_386_PLT32 : BFD_RELOC_32_PCREL);
d3712 2
a3713 2
	  /* This changes the byte-displacement jump 0x7N -->
			   the dword-displacement jump 0x0f8N */
d3715 3
a3717 3
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;	/* two-byte escape */
	  fragP->fr_fix += 1 + 4;	/* we've added an opcode byte */
	  fix_new (fragP, old_fr_fix + 1, 4,
d3719 2
a3720 6
		   fragP->fr_offset, 1, 
		   (GOT_symbol &&  /* Not quite right - we should switch on
				     presence of @@PLT, but I cannot see how
				     to get to that from here.  ERY */
		    S_GET_SEGMENT(fragP->fr_symbol) == undefined_section)?
		   BFD_RELOC_386_PLT32 : BFD_RELOC_32_PCREL);
d3724 1
d3726 3
a3728 3
  return (fragP->fr_var + fragP->fr_fix - old_fr_fix);
}				/* md_estimate_size_before_relax() */

d3743 2
a3744 2
     object_headers *headers;
     segT sec;
d3749 2
a3750 2
     bfd *abfd;
     segT sec;
d3766 1
a3766 1
  target_address += fragP->fr_symbol->sy_frag->fr_address;
d3777 4
a3780 2
    case ENCODE_RELAX_STATE (COND_JUMP, BYTE):
    case ENCODE_RELAX_STATE (UNCOND_JUMP, BYTE):
d3786 5
a3790 6
    case ENCODE_RELAX_STATE (COND_JUMP, WORD):
      opcode[1] = TWO_BYTE_OPCODE_ESCAPE;
      opcode[2] = opcode[0] + 0x10;
      opcode[0] = WORD_PREFIX_OPCODE;
      extension = 4;		/* 3 opcode + 2 displacement */
      where_to_put_displacement = &opcode[3];
d3793 4
a3796 5
    case ENCODE_RELAX_STATE (UNCOND_JUMP, WORD):
      opcode[1] = 0xe9;
      opcode[0] = WORD_PREFIX_OPCODE;
      extension = 3;		/* 2 opcode + 2 displacement */
      where_to_put_displacement = &opcode[2];
d3799 2
a3800 1
    case ENCODE_RELAX_STATE (COND_JUMP, DWORD):
a3802 1
      extension = 5;		/* 2 opcode + 4 displacement */
d3806 2
a3807 1
    case ENCODE_RELAX_STATE (UNCOND_JUMP, DWORD):
a3808 1
      extension = 4;		/* 1 opcode + 4 displacement */
d3832 2
a3833 2
     fragS *frag;
     symbolS *to_symbol;
d3878 1
a3878 1
     segT seg;			/* Segment fix is from.  */
d3884 27
a3910 5
  /*
   * This is a hack.  There should be a better way to
   * handle this.
   */
  if (fixP->fx_r_type == BFD_RELOC_32_PCREL && fixP->fx_addsy)
d3913 3
a3915 1
      value += fixP->fx_where + fixP->fx_frag->fr_address;
d3917 41
a3957 9
#ifdef OBJ_ELF
      if (S_GET_SEGMENT (fixP->fx_addsy) == seg
	  || (fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0)
	{
	  /* Yes, we add the values in twice.  This is because
	     bfd_perform_relocation subtracts them out again.  I think
	     bfd_perform_relocation is broken, but I don't dare change
	     it.  FIXME.  */
	  value += fixP->fx_where + fixP->fx_frag->fr_address;
d3961 13
d3977 4
a3980 3
#ifdef OBJ_ELF
  if (fixP->fx_addsy)
    switch(fixP->fx_r_type) {
d3988 1
a3988 1
 *  This is tough to explain.  We end up with this one if we have
d3992 1
a3992 1
 * relocation for this.  The actual sequence of instructions often look 
d3994 2
a3995 2
 * 
 * 	call	.L66
d3997 4
a4000 4
 * 	popl	%ebx
 * 	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
 * 
 * 	The call and pop essentially return the absolute address of
d4009 2
a4010 2
 * 
 * 	Our job here is to fix the operand so that it would add the correct
d4015 3
a4017 3
 * 
 * 	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
 * 
d4019 1
a4019 1
 * we treat operands of this form as not being pcrel since the '.' is 
d4028 1
a4028 1
      value = 0; /* Fully resolved at runtime.  No addend. */
d4033 5
d4041 3
a4043 3
#endif

#endif
d4074 1
a4074 1
     char type;
d4102 1
a4102 1
      return "Bad call to md_atof ()";
d4121 2
d4125 1
a4125 1
     char c;
d4134 5
a4138 3
/* reg_string starts *before* REGISTER_PREFIX */
static reg_entry *
parse_register (reg_string)
d4140 1
d4142 8
a4149 3
  register char *s = reg_string;
  register char *p;
  char reg_name_given[MAX_REG_NAME_SIZE];
d4151 5
a4155 2
  s++;				/* skip REGISTER_PREFIX */
  for (p = reg_name_given; is_register_char (*s); p++, s++)
a4156 1
      *p = register_chars[(unsigned char) *s];
d4158 33
a4190 1
	return (reg_entry *) 0;
d4192 2
a4193 2
  *p = '\0';
  return (reg_entry *) hash_find (reg_hash, reg_name_given);
d4196 2
a4197 2
#ifdef OBJ_ELF
CONST char *md_shortopts = "kmVQ:";
d4204 1
a4204 1
size_t md_longopts_size = sizeof(md_longopts);
d4209 1
a4209 1
     char *arg;
d4217 1
a4217 1
#ifdef OBJ_ELF
d4231 10
d4253 40
a4292 2
  fprintf (stream, "\
-m			do long jump\n");
d4294 3
a4297 3
/* We have no need to default values of symbols.  */

/* ARGSUSED */
d4302 14
a4315 12
	if (*name == '_' && *(name+1) == 'G'
	    && strcmp(name, GLOBAL_OFFSET_TABLE_NAME) == 0)
	  {
	    if(!GOT_symbol)
	      {
		if(symbol_find(name)) 
		  as_bad("GOT already in symbol table");
		GOT_symbol = symbol_new (name, undefined_section, 
					 (valueT) 0, &zero_address_frag);
	      };
	    return GOT_symbol;
	  }
d4322 1
a4322 1
     segT segment;
d4325 18
a4342 1
  return size;			/* Byte alignment is fine */
d4345 4
a4348 3
/* Exactly what point is a PC-relative offset relative TO?  On the
   i386, they're relative to the address of the offset, plus its
   size. (??? Is this right?  FIXME-SOON!) */
d4360 1
a4360 1
     int ignore;
a4384 3
#define F(SZ,PCREL)		(((SZ) << 1) + (PCREL))
#define MAP(SZ,PCREL,TYPE)	case F(SZ,PCREL): code = (TYPE); break

d4387 1
a4387 1
     asection *section;
d4393 1
a4393 1
  switch(fixp->fx_r_type)
d4399 3
d4405 15
a4419 1
      switch (F (fixp->fx_size, fixp->fx_pcrel))
d4421 10
a4430 9
	  MAP (1, 0, BFD_RELOC_8);
	  MAP (2, 0, BFD_RELOC_16);
	  MAP (4, 0, BFD_RELOC_32);
	  MAP (1, 1, BFD_RELOC_8_PCREL);
	  MAP (2, 1, BFD_RELOC_16_PCREL);
	  MAP (4, 1, BFD_RELOC_32_PCREL);
	default:
	  as_bad ("Can not do %d byte %srelocation", fixp->fx_size,
		  fixp->fx_pcrel ? "pc-relative " : "");
d4432 1
a4433 2
#undef MAP
#undef F
d4440 4
a4443 4
  rel = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  if (rel == NULL)
    as_fatal ("Out of memory");
  rel->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d4445 5
d4459 1
a4459 1
		    "Cannot represent relocation type %s",
d4537 1
a4537 1
#endif /* BFD_ASSEMBLER? */
a4538 95
#ifdef SCO_ELF

/* Heavily plagarized from obj_elf_version.  The idea is to emit the
   SCO specific identifier in the .notes section to satisfy the SCO
   linker.

   This looks more complicated than it really is.  As opposed to the
   "obvious" solution, this should handle the cross dev cases
   correctly.  (i.e, hosting on a 64 bit big endian processor, but
   generating SCO Elf code) Efficiency isn't a concern, as there
   should be exactly one of these sections per object module.

   SCO OpenServer 5 identifies it's ELF modules with a standard ELF
   .note section.

   int_32 namesz  = 4 ;  Name size 
   int_32 descsz  = 12 ; Descriptive information 
   int_32 type    = 1 ;  
   char   name[4] = "SCO" ; Originator name ALWAYS SCO + NULL 
   int_32 version = (major ver # << 16)  | version of tools ;
   int_32 source  = (tool_id << 16 ) | 1 ;
   int_32 info    = 0 ;    These are set by the SCO tools, but we
                           don't know enough about the source 
			   environment to set them.  SCO ld currently
			   ignores them, and recommends we set them
			   to zero.  */

#define SCO_MAJOR_VERSION 0x1
#define SCO_MINOR_VERSION 0x1

void
sco_id ()
{
  char *name;
  unsigned int c;
  char ch;
  char *p;
  asection *seg = now_seg;
  subsegT subseg = now_subseg;
  Elf_Internal_Note i_note;
  Elf_External_Note e_note;
  asection *note_secp = (asection *) NULL;
  int i, len;

  /* create the .note section */

  note_secp = subseg_new (".note", 0);
  bfd_set_section_flags (stdoutput,
			 note_secp,
			 SEC_HAS_CONTENTS | SEC_READONLY);

  /* process the version string */

  i_note.namesz = 4; 
  i_note.descsz = 12;		/* 12 descriptive bytes */
  i_note.type = NT_VERSION;	/* Contains a version string */

  p = frag_more (sizeof (i_note.namesz));
  md_number_to_chars (p, (valueT) i_note.namesz, 4);

  p = frag_more (sizeof (i_note.descsz));
  md_number_to_chars (p, (valueT) i_note.descsz, 4);

  p = frag_more (sizeof (i_note.type));
  md_number_to_chars (p, (valueT) i_note.type, 4);

  p = frag_more (4);
  strcpy (p, "SCO"); 

  /* Note: this is the version number of the ELF we're representing */
  p = frag_more (4);
  md_number_to_chars (p, (SCO_MAJOR_VERSION << 16) | (SCO_MINOR_VERSION), 4);

  /* Here, we pick a magic number for ourselves (yes, I "registered"
     it with SCO.  The bottom bit shows that we are compat with the
     SCO ABI.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x4c520000 | 0x0001, 4);

  /* If we knew (or cared) what the source language options were, we'd
     fill them in here.  SCO has given us permission to ignore these
     and just set them to zero.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x0000, 4);
 
  frag_align (2, 0); 

  /* We probably can't restore the current segment, for there likely
     isn't one yet...  */
  if (seg && subseg)
    subseg_set (seg, subseg);
}

#endif /* SCO_ELF */

@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2633 1
d2635 1
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1989, 1991, 1992, 1993 Free Software Foundation.
d17 3
a19 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d777 5
a781 1
#endif
d1162 2
a1163 2
	      i.suffix = ((i.types[op] == Reg8) ? BYTE_OPCODE_SUFFIX :
			  (i.types[op] == Reg16) ? WORD_OPCODE_SUFFIX :
a2609 10
void				/* Knows about order of bytes in address. */
md_number_to_chars (con, value, nbytes)
     char con[];		/* Return 'nbytes' of chars here. */
     valueT value;		/* The value of the bits. */
     int nbytes;		/* Number of bytes in the output. */
{
  number_to_chars_littleendian (con, value, nbytes);
}


a2960 1
#ifndef OBJ_ELF
a2962 1
#endif
a2963 1
#ifndef OBJ_ELF
a2965 1
#endif
d2981 2
a2982 1
  assert (rel != 0);
d2991 1
a2991 1
  if (!rel->howto)
d2993 6
a2998 7
      const char *name;

      name = S_GET_NAME (fixp->fx_addsy);
      if (name == NULL)
	name = "<unknown>";
      as_fatal ("Cannot generate relocation type for symbol %s, code %s",
		name, bfd_get_reloc_code_name (code));
@


1.1
log
@Initial revision
@
text
@d563 9
d1162 33
d2824 1
a2824 1
CONST char *md_shortopts = "mVQ:";
d2845 4
d2978 1
a2978 1
		  fixp->fx_pcrel ? "pc-relative" : "");
d3082 95
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@a562 9

void
i386_print_statistics (file)
     FILE *file;
{
  hash_print_statistics (file, "i386 opcode", op_hash);
  hash_print_statistics (file, "i386 register", reg_hash);
  hash_print_statistics (file, "i386 prefix", prefix_hash);
}
a1152 33
    else if (i.suffix != 0
	     && i.reg_operands != 0
	     && (i.types[i.operands - 1] & Reg) != 0)
      {
	int bad;

	/* If the last operand is a register, make sure it is
           compatible with the suffix.  */

	bad = 0;
	switch (i.suffix)
	  {
	  default:
	    abort ();
	  case BYTE_OPCODE_SUFFIX:
	    /* If this is an eight bit register, it's OK.  If it's the
               16 or 32 bit version of an eight bit register, we will
               just use the low portion, and that's OK too.  */
	    if ((i.types[i.operands - 1] & Reg8) == 0
		&& i.regs[i.operands - 1]->reg_num >= 4)
	      bad = 1;
	    break;
	  case WORD_OPCODE_SUFFIX:
	  case DWORD_OPCODE_SUFFIX:
	    /* We don't insist on the presence or absence of the e
               prefix on the register, but we reject eight bit
               registers.  */
	    if ((i.types[i.operands - 1] & Reg8) != 0)
	      bad = 1;
	  }
	if (bad)
	  as_bad ("register does not match opcode suffix");
      }
d2782 1
a2782 1
CONST char *md_shortopts = "kmVQ:";
a2802 4
      /* -k: Ignore for FreeBSD compatibility.  */
    case 'k':
      break;

d2932 1
a2932 1
		  fixp->fx_pcrel ? "pc-relative " : "");
a3035 95

#ifdef SCO_ELF

/* Heavily plagarized from obj_elf_version.  The idea is to emit the
   SCO specific identifier in the .notes section to satisfy the SCO
   linker.

   This looks more complicated than it really is.  As opposed to the
   "obvious" solution, this should handle the cross dev cases
   correctly.  (i.e, hosting on a 64 bit big endian processor, but
   generating SCO Elf code) Efficiency isn't a concern, as there
   should be exactly one of these sections per object module.

   SCO OpenServer 5 identifies it's ELF modules with a standard ELF
   .note section.

   int_32 namesz  = 4 ;  Name size 
   int_32 descsz  = 12 ; Descriptive information 
   int_32 type    = 1 ;  
   char   name[4] = "SCO" ; Originator name ALWAYS SCO + NULL 
   int_32 version = (major ver # << 16)  | version of tools ;
   int_32 source  = (tool_id << 16 ) | 1 ;
   int_32 info    = 0 ;    These are set by the SCO tools, but we
                           don't know enough about the source 
			   environment to set them.  SCO ld currently
			   ignores them, and recommends we set them
			   to zero.  */

#define SCO_MAJOR_VERSION 0x1
#define SCO_MINOR_VERSION 0x1

void
sco_id ()
{
  char *name;
  unsigned int c;
  char ch;
  char *p;
  asection *seg = now_seg;
  subsegT subseg = now_subseg;
  Elf_Internal_Note i_note;
  Elf_External_Note e_note;
  asection *note_secp = (asection *) NULL;
  int i, len;

  /* create the .note section */

  note_secp = subseg_new (".note", 0);
  bfd_set_section_flags (stdoutput,
			 note_secp,
			 SEC_HAS_CONTENTS | SEC_READONLY);

  /* process the version string */

  i_note.namesz = 4; 
  i_note.descsz = 12;		/* 12 descriptive bytes */
  i_note.type = NT_VERSION;	/* Contains a version string */

  p = frag_more (sizeof (i_note.namesz));
  md_number_to_chars (p, (valueT) i_note.namesz, 4);

  p = frag_more (sizeof (i_note.descsz));
  md_number_to_chars (p, (valueT) i_note.descsz, 4);

  p = frag_more (sizeof (i_note.type));
  md_number_to_chars (p, (valueT) i_note.type, 4);

  p = frag_more (4);
  strcpy (p, "SCO"); 

  /* Note: this is the version number of the ELF we're representing */
  p = frag_more (4);
  md_number_to_chars (p, (SCO_MAJOR_VERSION << 16) | (SCO_MINOR_VERSION), 4);

  /* Here, we pick a magic number for ourselves (yes, I "registered"
     it with SCO.  The bottom bit shows that we are compat with the
     SCO ABI.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x4c520000 | 0x0001, 4);

  /* If we knew (or cared) what the source language options were, we'd
     fill them in here.  SCO has given us permission to ignore these
     and just set them to zero.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x0000, 4);
 
  frag_align (2, 0); 

  /* We probably can't restore the current segment, for there likely
     isn't one yet...  */
  if (seg && subseg)
    subseg_set (seg, subseg);
}

#endif /* SCO_ELF */
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 1
   Copyright (C) 1989, 91, 92, 93, 94, 95, 1996 Free Software Foundation.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d776 1
a776 5
#ifdef BFD_ASSEMBLER
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;
#endif /* BFD_ASSEMBLER */
#endif /* ! defined (OBJ_AOUT) */
d1157 2
a1158 2
	      i.suffix = ((i.types[op] & Reg8) ? BYTE_OPCODE_SUFFIX :
			  (i.types[op] & Reg16) ? WORD_OPCODE_SUFFIX :
d2605 10
d2966 1
d2969 1
d2971 1
d2974 1
d2990 1
a2990 2
  if (rel == NULL)
    as_fatal ("Out of memory");
d2999 1
a2999 1
  if (rel->howto == NULL)
d3001 7
a3007 6
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    "Cannot represent relocation type %s",
		    bfd_get_reloc_code_name (code));
      /* Set howto to a garbage value so that we can keep going.  */
      rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
      assert (rel->howto != NULL);
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a2632 1
#ifndef OBJ_AOUT
a2633 1
#endif
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1989, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation.
a39 12
static unsigned long mode_from_disp_size PARAMS ((unsigned long));
static int fits_in_signed_byte PARAMS ((long));
static int fits_in_unsigned_byte PARAMS ((long));
static int fits_in_unsigned_word PARAMS ((long));
static int fits_in_signed_word PARAMS ((long));
static int smallest_imm_type PARAMS ((long));
static void set_16bit_code_flag PARAMS ((int));
#ifdef BFD_ASSEMBLER
static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, bfd_reloc_code_real_type));
#endif

d107 1
a107 1
#if defined (TE_I386AIX) || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
d121 1
a121 1
#if defined (TE_I386AIX) || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
d251 33
a283 55
  /* Note: Don't try to assemble the instructions in the comments. */
  /*       0L and 0w are not legal */
  static const char f32_1[] =
    {0x90};					/* nop			*/
  static const char f32_2[] =
    {0x89,0xf6};				/* movl %esi,%esi	*/
  static const char f32_3[] =
    {0x8d,0x76,0x00};				/* leal 0(%esi),%esi	*/
  static const char f32_4[] =
    {0x8d,0x74,0x26,0x00};			/* leal 0(%esi,1),%esi	*/
  static const char f32_5[] =
    {0x90,					/* nop			*/
     0x8d,0x74,0x26,0x00};			/* leal 0(%esi,1),%esi	*/
  static const char f32_6[] =
    {0x8d,0xb6,0x00,0x00,0x00,0x00};		/* leal 0L(%esi),%esi	*/
  static const char f32_7[] =
    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};	/* leal 0L(%esi,1),%esi */
  static const char f32_8[] =
    {0x90,					/* nop			*/
     0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};	/* leal 0L(%esi,1),%esi */
  static const char f32_9[] =
    {0x89,0xf6,					/* movl %esi,%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_10[] =
    {0x8d,0x76,0x00,				/* leal 0(%esi),%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_11[] =
    {0x8d,0x74,0x26,0x00,			/* leal 0(%esi,1),%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_12[] =
    {0x8d,0xb6,0x00,0x00,0x00,0x00,		/* leal 0L(%esi),%esi	*/
     0x8d,0xbf,0x00,0x00,0x00,0x00};		/* leal 0L(%edi),%edi	*/
  static const char f32_13[] =
    {0x8d,0xb6,0x00,0x00,0x00,0x00,		/* leal 0L(%esi),%esi	*/
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_14[] =
    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00,	/* leal 0L(%esi,1),%esi */
     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};	/* leal 0L(%edi,1),%edi */
  static const char f32_15[] =
    {0xeb,0x0d,0x90,0x90,0x90,0x90,0x90,	/* jmp .+15; lotsa nops	*/
     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};
  static const char f16_4[] =
    {0x8d,0xb6,0x00,0x00};			/* lea 0w(%si),%si	*/
  static const char f16_5[] =
    {0x90,					/* nop			*/
     0x8d,0xb6,0x00,0x00};			/* lea 0w(%si),%si	*/
  static const char f16_6[] =
    {0x89,0xf6,					/* mov %si,%si		*/
     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
  static const char f16_7[] =
    {0x8d,0x76,0x00,				/* lea 0(%si),%si	*/
     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
  static const char f16_8[] =
    {0x8d,0xb6,0x00,0x00,			/* lea 0w(%si),%si	*/
     0x8d,0xbd,0x00,0x00};			/* lea 0w(%di),%di	*/
d390 1
a390 2
static void
set_16bit_code_flag (new_16bit_code_flag)
d558 4
a561 7
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
    {
      record_alignment (text_section, 2);
      record_alignment (data_section, 2);
      record_alignment (bss_section, 2);
    }
d603 1
a603 2
      if (x->types[i]
	  & (Reg | SReg2 | SReg3 | Control | Debug | Test | RegMMX))
a701 1
  { RegMMX, "rMMX" },
d754 8
d777 1
d780 1
d782 1
d788 1
a790 8
#else
#define reloc(SIZE,PCREL,OTHER)	0
#define BFD_RELOC_32		0
#define BFD_RELOC_32_PCREL	0
#define BFD_RELOC_386_PLT32	0
#define BFD_RELOC_386_GOT32	0
#define BFD_RELOC_386_GOTOFF	0
#endif
d829 2
a830 2
    /* Non-zero if operand parens not balanced. */
    unsigned int paren_not_balanced;
d949 2
a950 2
	    paren_not_balanced = 0;
	    while (paren_not_balanced || *l != ',')
d954 1
a954 1
		    if (paren_not_balanced)
d956 1
a956 1
			as_bad ("unbalanced parenthesis in %s operand.",
d971 1
a971 1
		  ++paren_not_balanced;
d973 1
a973 1
		  --paren_not_balanced;
a1309 7
	/* The clr %reg instruction is converted into xor %reg, %reg.  */
	if (t->opcode_modifier & iclrKludge)
	  {
	    i.regs[1] = i.regs[0];
	    i.reg_operands = 2;
	  }

d1377 1
a1377 9
		source = ((i.types[0]
			   & (Reg
			      | SReg2
			      | SReg3
			      | Control
			      | Debug
			      | Test
			      | RegMMX))
			  ? 0 : 1);
d1381 4
a1384 5
		   segment/control/test/debug/MMX registers go into
		   the i.rm.reg field (despite the whether they are
		   source or destination operands). */
		if (i.regs[dest]->reg_type
		    & (SReg2 | SReg3 | Control | Debug | Test | RegMMX))
d1512 3
a1514 4
		/* Fill in i.rm.reg or i.rm.regmem field with register
		   operand (if any) based on
		   t->extension_opcode. Again, we must be careful to
		   make sure that segment/control/debug/test/MMX
d1519 2
a1520 9
		      ((i.types[0]
			& (Reg | SReg2 | SReg3 | Control | Debug
			   | Test | RegMMX))
		       ? 0
		       : ((i.types[1]
			   & (Reg | SReg2 | SReg3 | Control | Debug
			      | Test | RegMMX))
			  ? 1
			  : 2));
d1657 1
a1657 1
		      (offsetT) n, p);
d2124 1
a2124 1
	  unsigned int parens_balanced = 1;
d2131 1
a2131 1
		parens_balanced++;
d2133 1
a2133 1
		parens_balanced--;
d2135 1
a2135 1
	  while (parens_balanced);
d2634 1
a2634 2
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
	value += fixP->fx_where + fixP->fx_frag->fr_address;
d2636 3
a2638 4
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour
	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg
	      || (fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0))
d2651 2
a2652 3
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
      && fixP->fx_addsy)
d2841 1
a2841 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
d2870 2
a2872 25
#ifdef BFD_ASSEMBLER
#ifdef OBJ_MAYBE_ELF
#ifdef OBJ_MAYBE_COFF

/* Pick the target format to use.  */

const char  *
i386_target_format ()
{
  switch (OUTPUT_FLAVOR)
    {
    case bfd_target_coff_flavour:
      return "coff-i386";
    case bfd_target_elf_flavour:
      return "elf32-i386";
    default:
      abort ();
      return NULL;
    }
}

#endif /* OBJ_MAYBE_COFF */
#endif /* OBJ_MAYBE_ELF */
#endif /* BFD_ASSEMBLER */

d2899 1
a2899 15
#ifdef OBJ_AOUT
#ifdef BFD_ASSEMBLER
  /* For a.out, force the section size to be aligned.  If we don't do
     this, BFD will align it for us, but it will not write out the
     final bytes of the section.  This may be a bug in BFD, but it is
     easier to fix it here since that is how the other a.out targets
     work.  */
  int align;

  align = bfd_get_section_alignment (stdoutput, segment);
  size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
#endif
#endif

  return size;
d2982 3
a2984 1
  rel = (arelent *) xmalloc (sizeof (arelent));
d3076 95
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1989, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation.
d32 2
d36 2
a37 14
#ifndef REGISTER_WARNINGS
#define REGISTER_WARNINGS 1
#endif

#ifndef INFER_ADDR_PREFIX
#define INFER_ADDR_PREFIX 1
#endif

#ifndef SCALE1_WHEN_NO_INDEX
/* Specifying a scale factor besides 1 when there is no index is
   futile.  eg. `mov (%ebx,2),%al' does exactly the same as
   `mov (%ebx),%al'.  To slavishly follow what the programmer
   specified, set SCALE1_WHEN_NO_INDEX to 0.  */
#define SCALE1_WHEN_NO_INDEX 1
d40 1
a40 4
#define true 1
#define false 0

static unsigned int mode_from_disp_size PARAMS ((unsigned int));
a45 1
static int add_prefix PARAMS ((unsigned int));
a46 3
static void set_16bit_gcc_code_flag PARAMS((int));
static void set_intel_syntax PARAMS ((int));

a54 7
union i386_op
  {
    expressionS *disps;
    expressionS *imms;
    const reg_entry *regs;
  };

d59 1
a59 3

    /* SUFFIX holds the instruction mnemonic suffix if given.
       (e.g. 'l' for 'movl')  */
d61 1
d72 2
a73 1
       use OP[i] for the corresponding operand.  */
d76 2
a77 3
    /* Displacement expression, immediate expression, or register for each
       operand.  */
    union i386_op op[MAX_OPERANDS];
d86 6
d94 2
a95 2
    const reg_entry *base_reg;
    const reg_entry *index_reg;
d98 3
a100 3
    /* SEG gives the seg_entries of this insn.  They are zero unless
       explicit segment overrides are given. */
    const seg_entry *seg[2];	/* segments for memory operands (if given) */
d103 3
a105 1
       PREFIXES is the number of prefix opcodes.  */
a106 1
    unsigned char prefix[MAX_PREFIXES];
d108 2
a109 2
    /* RM and SIB are the modrm byte and the sib byte where the
       addressing modes of this insn are encoded.  */
d112 1
a112 1
    sib_byte sib;
a116 8
/* List of chars besides those in app.c:symbol_chars that can start an
   operand.  Used to prevent the scrubber eating vital white-space.  */
#ifdef LEX_AT
const char extra_symbol_chars[] = "*%-(@@";
#else
const char extra_symbol_chars[] = "*%-(";
#endif

d119 1
a119 3
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (TE_LINUX) && !defined(TE_FreeBSD))
/* Putting '/' here makes it impossible to use the divide operator.
   However, we need it for compatibility with SVR4 systems.  */
a120 1
#define PREFIX_SEPARATOR '\\'
a122 1
#define PREFIX_SEPARATOR '/'
d133 1
a133 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && !defined (TE_LINUX) && !defined(TE_FreeBSD))
a137 1

d149 1
a149 1
static char mnemonic_chars[256];
d152 1
d157 1
a157 1
#define is_mnemonic_char(x) (mnemonic_chars[(unsigned char) x])
d160 1
a160 1
#define is_space_char(x) ((x) == ' ')
d167 2
d175 2
a176 4
#define END_STRING_AND_SAVE(s) \
	do { *save_stack_p++ = *(s); *(s) = '\0'; } while (0)
#define RESTORE_END_STRING(s) \
	do { *(s) = *--save_stack_p; } while (0)
a180 3
/* Possible templates for current insn.  */
static const templates *current_templates;

d184 3
a192 9
static int intel_syntax = 0;	/* 1 for intel syntax, 0 if att syntax */

static int allow_naked_reg = 0;  /* 1 if register prefix % not required */

static char stackop_size = '\0';  /* Used in 16 bit gcc mode to add an l
				     suffix to call, ret, enter, leave, push,
				     and pop instructions so that gcc has the
				     same stack frame as in 32 bit mode.  */

d195 2
a196 2
   one for unconditional jumps.  This is because these two types of
   jumps add different sizes to frags when we're figuring out what
d203 4
a206 5
#define CODE16	1
#define SMALL	0
#define SMALL16 (SMALL|CODE16)
#define BIG	2
#define BIG16	(BIG|CODE16)
d219 1
a219 9
    ( (((s) & 0x3) == BIG ? 4 : (((s) & 0x3) == BIG16 ? 2 : 1)) )

/* This table is used by relax_frag to promote short jumps to long
   ones where necessary.  SMALL (short) jumps may be promoted to BIG
   (32 bit long) ones, and SMALL16 jumps to BIG16 (16 bit long).  We
   don't allow a short jump in a 32 bit code segment to be promoted to
   a 16 bit offset jump because it's slower (requires data size
   prefix), and doesn't work, unless the destination is in the bottom
   64k of the code segment (The top 16 bits of eip are zeroed).  */
d223 6
a228 6
  /* The fields are:
     1) most positive reach of this state,
     2) most negative reach of this state,
     3) how many bytes this mode will add to the size of the current frag
     4) which index into the table to try if we can't fit into this one.
  */
d234 6
a239 2
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (COND_JUMP, BIG)},
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (COND_JUMP, BIG16)},
d241 1
a241 1
     1 extra opcode byte, 3 extra displacement bytes.  */
d243 1
a243 3
  /* word conditionals add 2 bytes to frag:
     1 extra opcode byte, 1 extra displacement byte.  */
  {0, 0, 2, 0},
d245 4
a248 2
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG)},
  {127 + 1, -128 + 1, 0, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16)},
d250 1
a250 1
     0 extra opcode bytes, 3 extra displacement bytes.  */
d252 1
a252 3
  /* word jmp adds 1 byte to frag:
     0 extra opcode bytes, 1 extra displacement byte.  */
  {0, 0, 1, 0}
a303 2
  static const char f16_3[] =
    {0x8d,0x74,0x00};				/* lea 0(%esi),%esi	*/
d305 1
a305 1
    {0x8d,0xb4,0x00,0x00};			/* lea 0w(%si),%si	*/
d308 1
a308 1
     0x8d,0xb4,0x00,0x00};			/* lea 0w(%si),%si	*/
d313 1
a313 1
    {0x8d,0x74,0x00,				/* lea 0(%si),%si	*/
d316 1
a316 1
    {0x8d,0xb4,0x00,0x00,			/* lea 0w(%si),%si	*/
d323 1
a323 1
    f32_1, f32_2, f16_3, f16_4, f16_5, f16_6, f16_7, f16_8,
d345 1
a345 4
static int i386_intel_operand PARAMS ((char *operand_string, int got_a_float));
static const reg_entry *parse_register PARAMS ((char *reg_string,
						char **end_op));

d350 1
a350 1
symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
d352 1
a352 1
static INLINE unsigned int
d354 1
a354 1
     unsigned int t;
d356 1
a356 1
  return (t & Disp8) ? 1 : (t & (Disp16|Disp32)) ? 2 : 0;
d359 14
a423 56
/* Returns 0 if attempting to add a prefix where one from the same
   class already exists, 1 if non rep/repne added, 2 if rep/repne
   added.  */
static int
add_prefix (prefix)
     unsigned int prefix;
{
  int ret = 1;
  int q;

  switch (prefix)
    {
    default:
      abort ();

    case CS_PREFIX_OPCODE:
    case DS_PREFIX_OPCODE:
    case ES_PREFIX_OPCODE:
    case FS_PREFIX_OPCODE:
    case GS_PREFIX_OPCODE:
    case SS_PREFIX_OPCODE:
      q = SEG_PREFIX;
      break;

    case REPNE_PREFIX_OPCODE:
    case REPE_PREFIX_OPCODE:
      ret = 2;
      /* fall thru */
    case LOCK_PREFIX_OPCODE:
      q = LOCKREP_PREFIX;
      break;

    case FWAIT_OPCODE:
      q = WAIT_PREFIX;
      break;

    case ADDR_PREFIX_OPCODE:
      q = ADDR_PREFIX;
      break;

    case DATA_PREFIX_OPCODE:
      q = DATA_PREFIX;
      break;
    }

  if (i.prefix[q])
    {
      as_bad (_("same type of prefix used twice"));
      return 0;
    }

  i.prefixes += 1;
  i.prefix[q] = prefix;
  return ret;
}

d426 1
a426 9
     int new_16bit_code_flag;
{
  flag_16bit_code = new_16bit_code_flag;
  stackop_size = '\0';
}

static void
set_16bit_gcc_code_flag (new_16bit_code_flag)
     int new_16bit_code_flag;
a428 39
  stackop_size = new_16bit_code_flag ? 'l' : '\0';
}

static void
set_intel_syntax (syntax_flag)
     int syntax_flag;
{
  /* Find out if register prefixing is specified.  */
  int ask_naked_reg = 0;

  SKIP_WHITESPACE ();
  if (! is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *string = input_line_pointer;
      int e = get_symbol_end ();

      if (strcmp(string, "prefix") == 0)
	ask_naked_reg = 1;
      else if (strcmp(string, "noprefix") == 0)
	ask_naked_reg = -1;
      else
	as_bad (_("bad argument to syntax directive."));
      *input_line_pointer = e;
    }
  demand_empty_rest_of_line ();

  intel_syntax = syntax_flag;

  if (ask_naked_reg == 0)
    {
#ifdef BFD_ASSEMBLER
      allow_naked_reg = (intel_syntax
			 && (bfd_get_symbol_leading_char (stdoutput) != '\0'));
#else
      allow_naked_reg = 0; /* conservative default */
#endif
    }
  else
    allow_naked_reg = (ask_naked_reg < 0);
d436 1
a436 1
#if !defined(OBJ_AOUT) && !defined(USE_ALIGN_PTWO)
a446 1
  {"code16gcc", set_16bit_gcc_code_flag, 1},
a448 2
  {"intel_syntax", set_intel_syntax, 1},
  {"att_syntax", set_intel_syntax, 0},
d455 4
a458 1
/* hash table for instruction mnemonic lookup */
d462 2
d471 2
d479 1
d482 2
a484 1
    core_optab->start = optab;
d486 1
a486 1
    while (1)
d488 6
a493 3
	++optab;
	if (optab->name == NULL
	    || strcmp (optab->name, (optab - 1)->name) != 0)
d497 5
a501 4
	    core_optab->end = optab;
	    hash_err = hash_insert (op_hash,
				    (optab - 1)->name,
				    (PTR) core_optab);
d505 1
a505 2
		as_fatal (_("Internal Error:  Can't hash %s: %s"),
			  (optab - 1)->name,
d508 1
a508 2
	    if (optab->name == NULL)
	      break;
d510 1
a510 1
	    core_optab->start = optab;
d520 1
a520 3
    for (regtab = i386_regtab;
	 regtab < i386_regtab + sizeof (i386_regtab) / sizeof (i386_regtab[0]);
	 regtab++)
d528 19
a546 1
  /* fill in lexical tables:  mnemonic_chars, operand_chars.  */
d553 1
a553 1
	if (isdigit (c))
d555 1
a555 2
	    digit_chars[c] = c;
	    mnemonic_chars[c] = c;
a556 1
	    operand_chars[c] = c;
d558 6
a563 1
	else if (islower (c))
d565 1
a565 3
	    mnemonic_chars[c] = c;
	    register_chars[c] = c;
	    operand_chars[c] = c;
d567 1
a567 1
	else if (isupper (c))
d569 1
a569 3
	    mnemonic_chars[c] = tolower (c);
	    register_chars[c] = mnemonic_chars[c];
	    operand_chars[c] = c;
d572 7
a578 1
	if (isalpha (c) || isdigit (c))
a579 6
	else if (c >= 128)
	  {
	    identifier_chars[c] = c;
	    operand_chars[c] = c;
	  }
      }
d582 1
a582 1
    identifier_chars['@@'] = '@@';
d584 4
a587 3
    digit_chars['-'] = '-';
    identifier_chars['_'] = '_';
    identifier_chars['.'] = '.';
d609 1
d642 2
a643 2
	  & (Reg | SReg2 | SReg3 | Control | Debug | Test | RegMMX | RegXMM))
	fprintf (stdout, "%s\n", x->op[i].regs->reg_name);
d645 3
a647 3
	pe (x->op[i].imms);
      if (x->types[i] & Disp)
	pe (x->op[i].disps);
d678 3
a680 3
  fprintf (stdout, "    operation     %d\n", e->X_op);
  fprintf (stdout, "    add_number    %ld (%lx)\n",
	   (long) e->X_add_number, (long) e->X_add_number);
d720 3
a722 1
  { Imm1, "i1" },
d724 3
d730 3
d735 1
a737 1
  { Debug, "debug reg" },
a739 3
  { SReg2, "SReg2" },
  { SReg3, "SReg3" },
  { Acc, "Acc" },
a741 2
  { RegXMM, "rXMM" },
  { EsSeg, "es" },
d753 1
a753 1
      fprintf (stdout, _("Unknown"));
a765 15
int
tc_i386_force_relocation (fixp)
     struct fix *fixp;
{
#ifdef BFD_ASSEMBLER
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;
  return 0;
#else
  /* For COFF */
  return fixp->fx_r_type == 7;
#endif
}

a766 3
static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, bfd_reloc_code_real_type));

d776 6
a781 9
    {
      switch (size)
	{
	case 1: return BFD_RELOC_8_PCREL;
	case 2: return BFD_RELOC_16_PCREL;
	case 4: return BFD_RELOC_32_PCREL;
	}
      as_bad (_("can not do %d byte pc-relative relocation"), size);
    }
d783 6
a788 9
    {
      switch (size)
	{
	case 1: return BFD_RELOC_8;
	case 2: return BFD_RELOC_16;
	case 4: return BFD_RELOC_32;
	}
      as_bad (_("can not do %d byte relocation"), size);
    }
d790 2
d802 2
a803 2
tc_i386_fix_adjustable (fixP)
     fixS *fixP;
d805 5
a809 5
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
  /* Prevent all adjustments to global symbols, or else dynamic
     linking will not work correctly.  */
  if (S_IS_EXTERNAL (fixP->fx_addsy)
      || S_IS_WEAK (fixP->fx_addsy))
d811 1
a811 1
#endif
d815 1
a815 4
      || fixP->fx_r_type == BFD_RELOC_386_GOT32
      || fixP->fx_r_type == BFD_RELOC_RVA
      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
a820 1
#define BFD_RELOC_16		0
a821 1
#define BFD_RELOC_16_PCREL	0
a827 16
static int
intel_float_operand PARAMS ((char *mnemonic));

static int
intel_float_operand (mnemonic)
     char *mnemonic;
{
  if (mnemonic[0] == 'f' && mnemonic[1] =='i')
    return 2;

  if (mnemonic[0] == 'f')
    return 1;

  return 0;
}

d836 2
a837 2
  /* Points to template once we've found it. */
  const template *t;
d842 3
a846 2
  char mnemonic[MAX_MNEM_SIZE];

d855 1
a855 1
  /* First parse an instruction mnemonic & call i386_operand for the operands.
d857 1
a857 1
     start of a (possibly prefixed) mnemonic. */
d860 7
a867 4
    char *mnem_p;

    /* Non-zero if we found a prefix only acceptable with string insns. */
    const char *expecting_string_instruction = NULL;
d869 1
a869 1
    while (1)
d871 1
a871 2
	mnem_p = mnemonic;
	while ((*mnem_p = mnemonic_chars[(unsigned char) *l]) != 0)
d873 2
a874 7
	    mnem_p++;
	    if (mnem_p >= mnemonic + sizeof (mnemonic))
	      {
		as_bad (_("no such 386 instruction: `%s'"), token_start);
		return;
	      }
	    l++;
d876 1
a876 3
	if (!is_space_char (*l)
	    && *l != END_OF_INSN
	    && *l != PREFIX_SEPARATOR)
d878 2
a879 3
	    as_bad (_("invalid character %s in mnemonic"),
		    output_invalid (*l));
	    return;
d881 1
a881 1
	if (token_start == l)
d883 3
a885 6
	    if (*l == PREFIX_SEPARATOR)
	      as_bad (_("expecting prefix; got nothing"));
	    else
	      as_bad (_("expecting mnemonic; got nothing"));
	    return;
	  }
d887 8
a894 13
	/* Look up instruction (or prefix) via hash table.  */
	current_templates = hash_find (op_hash, mnemonic);

	if (*l != END_OF_INSN
	    && (! is_space_char (*l) || l[1] != END_OF_INSN)
	    && current_templates
	    && (current_templates->start->opcode_modifier & IsPrefix))
	  {
	    /* If we are in 16-bit mode, do not allow addr16 or data16.
	       Similarly, in 32-bit mode, do not allow addr32 or data32.  */
	    if ((current_templates->start->opcode_modifier & (Size16 | Size32))
		&& (((current_templates->start->opcode_modifier & Size32) != 0)
		    ^ flag_16bit_code))
d896 1
a896 2
		as_bad (_("redundant %s prefix"),
			current_templates->start->name);
d899 9
a907 2
	    /* Add prefix, checking for repeated prefixes.  */
	    switch (add_prefix (current_templates->start->base_opcode))
d909 1
a909 1
	      case 0:
a910 4
	      case 2:
		expecting_string_instruction =
		  current_templates->start->name;
		break;
d912 4
a915 1
	    /* Skip past PREFIX_SEPARATOR and reset token_start.  */
d918 6
a923 2
	else
	  break;
d926 3
d931 11
a941 21
	/* See if we can get a match by trimming off a suffix.  */
	switch (mnem_p[-1])
	  {
	  case WORD_MNEM_SUFFIX:
	  case BYTE_MNEM_SUFFIX:
	  case SHORT_MNEM_SUFFIX:
	  case LONG_MNEM_SUFFIX:
	    i.suffix = mnem_p[-1];
	    mnem_p[-1] = '\0';
	    current_templates = hash_find (op_hash, mnemonic);
	    break;

	  /* Intel Syntax */
	  case DWORD_MNEM_SUFFIX:
	    if (intel_syntax)
	      {
		i.suffix = mnem_p[-1];
		mnem_p[-1] = '\0';
		current_templates = hash_find (op_hash, mnemonic);
		break;
	      }
d945 1
a945 1
	    as_bad (_("no such 386 instruction: `%s'"), token_start);
d949 1
d952 3
a954 2
    if (expecting_string_instruction
	&& !(current_templates->start->opcode_modifier & IsString))
d956 1
a956 2
	as_bad (_("expecting string instruction after `%s'"),
		expecting_string_instruction);
d961 7
a967 1
    if (*l != END_OF_INSN)
a969 7

	/* 1 if operand is pending after ','. */
	unsigned int expecting_operand = 0;

	/* Non-zero if operand parens not balanced. */
	unsigned int paren_not_balanced;

d973 1
a973 3
	    if (is_space_char (*l))
	      ++l;
	    if (!is_operand_char (*l) && *l != END_OF_INSN)
d975 8
a982 4
		as_bad (_("invalid character %s before operand %d"),
			output_invalid (*l),
			i.operands + 1);
		return;
d992 2
a993 6
			if (!intel_syntax)
			  as_bad (_("unbalanced parenthesis in operand %d."),
				  i.operands + 1);
			else
			  as_bad (_("unbalanced brackets in operand %d."),
				  i.operands + 1);
d1001 1
a1001 1
		    as_bad (_("invalid character %s in operand %d"),
d1003 1
a1003 1
			    i.operands + 1);
d1006 4
a1009 14
		if (!intel_syntax)
		  {
		    if (*l == '(')
		      ++paren_not_balanced;
		    if (*l == ')')
		      --paren_not_balanced;
		  }
		else
		  {
		    if (*l == '[')
		      ++paren_not_balanced;
		    if (*l == ']')
		      --paren_not_balanced;
		  }
d1018 1
a1018 1
		    as_bad (_("spurious operands; (%d operands/instruction max)"),
d1024 1
a1024 6

		if (intel_syntax)
		  operand_ok = i386_intel_operand (token_start, intel_float_operand (mnemonic));
		else
		  operand_ok = i386_operand (token_start);

d1034 1
a1034 1
		    as_bad (_("expecting operand after ','; got nothing"));
d1039 1
a1039 1
		    as_bad (_("expecting operand before ','; got nothing"));
d1058 1
a1058 1
  /* Now we've parsed the mnemonic into a set of templates, and have the
d1065 25
a1089 12
#define MATCH(overlap, given, template) \
  ((overlap & ~JumpAbsolute) \
   && ((given) & (BaseIndex|JumpAbsolute)) == ((overlap) & (BaseIndex|JumpAbsolute)))

  /* If given types r0 and r1 are registers they must be of the same type
     unless the expected operand type register overlap is null.
     Note that Acc in a template matches every size of reg.  */
#define CONSISTENT_REGISTER_MATCH(m0, g0, t0, m1, g1, t1) \
  ( ((g0) & Reg) == 0 || ((g1) & Reg) == 0 || \
    ((g0) & Reg) == ((g1) & Reg) || \
    ((((m0) & Acc) ? Reg : (t0)) & (((m1) & Acc) ? Reg : (t1)) & Reg) == 0 )

d1092 1
a1094 115
    int suffix_check;

    /* All intel opcodes have reversed operands except for "bound" and
       "enter".  We also don't reverse intersegment "jmp" and "call"
       instructions with 2 immediate operands so that the immediate segment
       precedes the offset, as it does when in AT&T mode.  "enter" and the
       intersegment "jmp" and "call" instructions are the only ones that
       have two immediate operands.  */
    if (intel_syntax && i.operands > 1
	&& (strcmp (mnemonic, "bound") != 0)
	&& !((i.types[0] & Imm) && (i.types[1] & Imm)))
      {
	union i386_op temp_op;
	unsigned int temp_type;
	int xchg1 = 0;
	int xchg2 = 0;

	if (i.operands == 2)
	  {
	    xchg1 = 0;
	    xchg2 = 1;
	  }
	else if (i.operands == 3)
	  {
	    xchg1 = 0;
	    xchg2 = 2;
	  }
	temp_type = i.types[xchg2];
	i.types[xchg2] = i.types[xchg1];
	i.types[xchg1] = temp_type;
	temp_op = i.op[xchg2];
	i.op[xchg2] = i.op[xchg1];
	i.op[xchg1] = temp_op;

	if (i.mem_operands == 2)
	  {
	    const seg_entry *temp_seg;
	    temp_seg = i.seg[0];
	    i.seg[0] = i.seg[1];
	    i.seg[1] = temp_seg;
	  }
      }

    if (i.imm_operands)
      {
	/* Try to ensure constant immediates are represented in the smallest
	   opcode possible.  */
	char guess_suffix = 0;
	int op;

	if (i.suffix)
	  guess_suffix = i.suffix;
	else if (i.reg_operands)
	  {
	    /* Figure out a suffix from the last register operand specified.
	       We can't do this properly yet, ie. excluding InOutPortReg,
	       but the following works for instructions with immediates.
	       In any case, we can't set i.suffix yet.  */
	    for (op = i.operands; --op >= 0; )
	      if (i.types[op] & Reg)
		{
		  if (i.types[op] & Reg8)
		    guess_suffix = BYTE_MNEM_SUFFIX;
		  else if (i.types[op] & Reg16)
		    guess_suffix = WORD_MNEM_SUFFIX;
		  break;
		}
	  }
	else if (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0))
	  guess_suffix = WORD_MNEM_SUFFIX;

	for (op = i.operands; --op >= 0; )
	  if ((i.types[op] & Imm)
	      && i.op[op].imms->X_op == O_constant)
	    {
	      /* If a suffix is given, this operand may be shortened.  */
	      switch (guess_suffix)
		{
		case WORD_MNEM_SUFFIX:
		  i.types[op] |= Imm16;
		  break;
		case BYTE_MNEM_SUFFIX:
		  i.types[op] |= Imm16 | Imm8 | Imm8S;
		  break;
		}

	      /* If this operand is at most 16 bits, convert it to a
		 signed 16 bit number before trying to see whether it will
		 fit in an even smaller size.  This allows a 16-bit operand
		 such as $0xffe0 to be recognised as within Imm8S range.  */
	      if ((i.types[op] & Imm16)
		  && (i.op[op].imms->X_add_number & ~(offsetT)0xffff) == 0)
		{
		  i.op[op].imms->X_add_number =
		    (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
		}
	      i.types[op] |= smallest_imm_type ((long) i.op[op].imms->X_add_number);
	    }
      }

    overlap0 = 0;
    overlap1 = 0;
    overlap2 = 0;
    found_reverse_match = 0;
    suffix_check = (i.suffix == BYTE_MNEM_SUFFIX
		    ? No_bSuf
		    : (i.suffix == WORD_MNEM_SUFFIX
		       ? No_wSuf
		       : (i.suffix == SHORT_MNEM_SUFFIX
			  ? No_sSuf
			  : (i.suffix == LONG_MNEM_SUFFIX
			     ? No_lSuf
			     : (i.suffix == DWORD_MNEM_SUFFIX
				? No_dSuf
				: (i.suffix == LONG_DOUBLE_MNEM_SUFFIX ? No_xSuf : 0))))));
d1096 1
d1101 1
a1101 1
	/* Must have right number of operands. */
a1103 9

	/* Check the suffix, except for some instructions in intel mode.  */
	if ((t->opcode_modifier & suffix_check)
	    && !(intel_syntax
		 && t->base_opcode == 0xd9
		 && (t->extension_opcode == 5	/* 0xd9,5 "fldcw"  */
		     || t->extension_opcode == 7))) /* 0xd9,7 "f{n}stcw"  */
	  continue;

d1111 1
a1111 1
	    if (!MATCH (overlap0, i.types[0], t->operand_types[0]))
d1117 5
a1121 6
	    if (!MATCH (overlap0, i.types[0], t->operand_types[0])
		|| !MATCH (overlap1, i.types[1], t->operand_types[1])
		|| !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
					       t->operand_types[0],
					       overlap1, i.types[1],
					       t->operand_types[1]))
d1125 1
a1125 1
		if ((t->opcode_modifier & (D|FloatD)) == 0)
d1131 5
a1135 6
		if (!MATCH (overlap0, i.types[0], t->operand_types[1])
		    || !MATCH (overlap1, i.types[1], t->operand_types[0])
		    || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
						   t->operand_types[1],
						   overlap1, i.types[1],
						   t->operand_types[0]))
d1140 5
a1144 6
		/* found_reverse_match holds which of D or FloatDR
		   we've found.  */
		found_reverse_match = t->opcode_modifier & (D|FloatDR);
		break;
	      }
	    /* found a forward 2 operand match here */
a1146 4
		/* Here we make use of the fact that there are no
		   reverse match 3 operand instructions, and all 3
		   operand instructions only need to be checked for
		   register consistency between operands 2 and 3.  */
d1148 7
a1154 6
		if (!MATCH (overlap2, i.types[2], t->operand_types[2])
		    || !CONSISTENT_REGISTER_MATCH (overlap1, i.types[1],
						   t->operand_types[1],
						   overlap2, i.types[2],
						   t->operand_types[2]))

d1164 1
a1164 2
	as_bad (_("suffix or operands invalid for `%s'"),
		current_templates->start->name);
d1168 7
a1174 2
    if (!intel_syntax
	&& (i.types[0] & JumpAbsolute) != (t->operand_types[0] & JumpAbsolute))
d1176 9
a1184 1
	as_warn (_("indirect %s without `*'"), t->name);
d1187 3
a1189 1
    if ((t->opcode_modifier & (IsPrefix|IgnoreSize)) == (IsPrefix|IgnoreSize))
d1191 11
a1201 3
	/* Warn them that a data or address size prefix doesn't affect
	   assembly of the next line of code.  */
	as_warn (_("stand-alone `%s' prefix"), t->name);
d1203 29
a1231 189

    /* Copy the template we found.  */
    i.tm = *t;
    if (found_reverse_match)
      {
	/* If we found a reverse match we must alter the opcode
	   direction bit.  found_reverse_match holds bits to change
	   (different for int & float insns).  */

	i.tm.base_opcode ^= found_reverse_match;

	i.tm.operand_types[0] = t->operand_types[1];
	i.tm.operand_types[1] = t->operand_types[0];
      }

    /* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
     if (SYSV386_COMPAT
	 && intel_syntax
	 && (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
       i.tm.base_opcode ^= FloatR;

    if (i.tm.opcode_modifier & FWait)
      if (! add_prefix (FWAIT_OPCODE))
	return;

    /* Check string instruction segment overrides */
    if ((i.tm.opcode_modifier & IsString) != 0 && i.mem_operands != 0)
      {
	int mem_op = (i.types[0] & AnyMem) ? 0 : 1;
	if ((i.tm.operand_types[mem_op] & EsSeg) != 0)
	  {
	    if (i.seg[0] != NULL && i.seg[0] != &es)
	      {
		as_bad (_("`%s' operand %d must use `%%es' segment"),
			i.tm.name,
			mem_op + 1);
		return;
	      }
	    /* There's only ever one segment override allowed per instruction.
	       This instruction possibly has a legal segment override on the
	       second operand, so copy the segment to where non-string
	       instructions store it, allowing common code.  */
	    i.seg[0] = i.seg[1];
	  }
	else if ((i.tm.operand_types[mem_op + 1] & EsSeg) != 0)
	  {
	    if (i.seg[1] != NULL && i.seg[1] != &es)
	      {
		as_bad (_("`%s' operand %d must use `%%es' segment"),
			i.tm.name,
			mem_op + 2);
		return;
	      }
	  }
      }

    /* If matched instruction specifies an explicit instruction mnemonic
       suffix, use it.  */
    if (i.tm.opcode_modifier & (Size16 | Size32))
      {
	if (i.tm.opcode_modifier & Size16)
	  i.suffix = WORD_MNEM_SUFFIX;
	else
	  i.suffix = LONG_MNEM_SUFFIX;
      }
    else if (i.reg_operands)
      {
	/* If there's no instruction mnemonic suffix we try to invent one
	   based on register operands. */
	if (!i.suffix)
	  {
	    /* We take i.suffix from the last register operand specified,
	       Destination register type is more significant than source
	       register type.  */
	    int op;
	    for (op = i.operands; --op >= 0; )
	      if ((i.types[op] & Reg)
		  && !(i.tm.operand_types[op] & InOutPortReg))
		{
		  i.suffix = ((i.types[op] & Reg8) ? BYTE_MNEM_SUFFIX :
			      (i.types[op] & Reg16) ? WORD_MNEM_SUFFIX :
			      LONG_MNEM_SUFFIX);
		  break;
		}
	  }
	else if (i.suffix == BYTE_MNEM_SUFFIX)
	  {
	    int op;
	    for (op = i.operands; --op >= 0; )
	      {
		/* If this is an eight bit register, it's OK.  If it's
		   the 16 or 32 bit version of an eight bit register,
		   we will just use the low portion, and that's OK too. */
		if (i.types[op] & Reg8)
		  continue;

		/* movzx and movsx should not generate this warning. */
		if (intel_syntax
		    && (i.tm.base_opcode == 0xfb7
			|| i.tm.base_opcode == 0xfb6
			|| i.tm.base_opcode == 0xfbe
			|| i.tm.base_opcode == 0xfbf))
		  continue;

		if ((i.types[op] & WordReg) && i.op[op].regs->reg_num < 4
#if 0
		    /* Check that the template allows eight bit regs
		       This kills insns such as `orb $1,%edx', which
		       maybe should be allowed.  */
		    && (i.tm.operand_types[op] & (Reg8|InOutPortReg))
#endif
		    )
		  {
#if REGISTER_WARNINGS
		    if ((i.tm.operand_types[op] & InOutPortReg) == 0)
		      as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			       (i.op[op].regs - (i.types[op] & Reg16 ? 8 : 16))->reg_name,
			       i.op[op].regs->reg_name,
			       i.suffix);
#endif
		    continue;
		  }
		/* Any other register is bad */
		if (i.types[op] & (Reg | RegMMX | RegXMM
				   | SReg2 | SReg3
				   | Control | Debug | Test
				   | FloatReg | FloatAcc))
		  {
		    as_bad (_("`%%%s' not allowed with `%s%c'"),
			    i.op[op].regs->reg_name,
			    i.tm.name,
			    i.suffix);
		    return;
		  }
	      }
	  }
	else if (i.suffix == LONG_MNEM_SUFFIX)
	  {
	    int op;
	    for (op = i.operands; --op >= 0; )
	      /* Reject eight bit registers, except where the template
		 requires them. (eg. movzb)  */
	      if ((i.types[op] & Reg8) != 0
		  && (i.tm.operand_types[op] & (Reg16|Reg32|Acc)) != 0)
		{
		  as_bad (_("`%%%s' not allowed with `%s%c'"),
			  i.op[op].regs->reg_name,
			  i.tm.name,
			  i.suffix);
		  return;
		}
#if REGISTER_WARNINGS
	      /* Warn if the e prefix on a general reg is missing.  */
	      else if ((i.types[op] & Reg16) != 0
		       && (i.tm.operand_types[op] & (Reg32|Acc)) != 0)
		{
		  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			   (i.op[op].regs + 8)->reg_name,
			   i.op[op].regs->reg_name,
			   i.suffix);
		}
#endif
	  }
	else if (i.suffix == WORD_MNEM_SUFFIX)
	  {
	    int op;
	    for (op = i.operands; --op >= 0; )
	      /* Reject eight bit registers, except where the template
		 requires them. (eg. movzb)  */
	      if ((i.types[op] & Reg8) != 0
		  && (i.tm.operand_types[op] & (Reg16|Reg32|Acc)) != 0)
		{
		  as_bad (_("`%%%s' not allowed with `%s%c'"),
			  i.op[op].regs->reg_name,
			  i.tm.name,
			  i.suffix);
		  return;
		}
#if REGISTER_WARNINGS
	      /* Warn if the e prefix on a general reg is present.  */
	      else if ((i.types[op] & Reg32) != 0
		       && (i.tm.operand_types[op] & (Reg16|Acc)) != 0)
		{
		  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			   (i.op[op].regs - 8)->reg_name,
			   i.op[op].regs->reg_name,
			   i.suffix);
		}
#endif
d1233 2
a1234 6
	else
	  abort();
      }
    else if ((i.tm.opcode_modifier & DefaultSize) && !i.suffix)
      {
	i.suffix = stackop_size;
d1238 2
a1239 1
       given in i.suffix.  Note: overlap2 cannot be an immediate!  */
d1244 1
a1244 11
	if (i.suffix)
	  {
	    overlap0 &= (i.suffix == BYTE_MNEM_SUFFIX ? (Imm8 | Imm8S) :
			 (i.suffix == WORD_MNEM_SUFFIX ? Imm16 : Imm32));
	  }
	else if (overlap0 == (Imm16 | Imm32))
	  {
	    overlap0 =
	      (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32;
	  }
	else
d1246 1
a1246 1
	    as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
d1249 2
d1256 1
a1256 1
	if (i.suffix)
d1258 1
a1258 11
	    overlap1 &= (i.suffix == BYTE_MNEM_SUFFIX ? (Imm8 | Imm8S) :
			 (i.suffix == WORD_MNEM_SUFFIX ? Imm16 : Imm32));
	  }
	else if (overlap1 == (Imm16 | Imm32))
	  {
	    overlap1 =
	      (flag_16bit_code ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32;
	  }
	else
	  {
	    as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
d1261 2
a1263 1
    assert ((overlap2 & Imm) == 0);
d1266 3
a1270 4
    if (overlap0 & Imm1)
      i.imm_operands = 0;	/* kludge for shift insns */

    i.types[1] = overlap1;
a1272 2

    i.types[2] = overlap2;
d1275 10
d1287 2
a1288 1
       size given by i.suffix:  We need not change things for byte insns.  */
d1290 1
a1290 1
    if (!i.suffix && (i.tm.opcode_modifier & W))
d1292 1
a1292 1
	as_bad (_("no instruction mnemonic suffix given and no register operands; can't size instruction"));
d1296 1
a1296 13
    /* For movzx and movsx, need to check the register type */
    if (intel_syntax
	&& (i.tm.base_opcode == 0xfb6 || i.tm.base_opcode == 0xfbe))
      if (i.suffix && i.suffix == BYTE_MNEM_SUFFIX)
	{
	  unsigned int prefix = DATA_PREFIX_OPCODE;

	  if ((i.op[1].regs->reg_type & Reg16) != 0)
	    if (!add_prefix (prefix))
	      return;
	}

    if (i.suffix && i.suffix != BYTE_MNEM_SUFFIX)
d1298 6
a1303 2
	/* It's not a byte, select word/dword operation.  */
	if (i.tm.opcode_modifier & W)
d1305 7
a1311 4
	    if (i.tm.opcode_modifier & ShortForm)
	      i.tm.base_opcode |= 8;
	    else
	      i.tm.base_opcode |= 1;
a1312 40
	/* Now select between word & dword operations via the operand
	   size prefix, except for instructions that will ignore this
	   prefix anyway.  */
	if (((intel_syntax && (i.suffix == DWORD_MNEM_SUFFIX))
	     || i.suffix == LONG_MNEM_SUFFIX) == flag_16bit_code
	    && !(i.tm.opcode_modifier & IgnoreSize))
	  {
	    unsigned int prefix = DATA_PREFIX_OPCODE;
	    if (i.tm.opcode_modifier & JumpByte) /* jcxz, loop */
	      prefix = ADDR_PREFIX_OPCODE;

	    if (! add_prefix (prefix))
	      return;
	  }
	/* Size floating point instruction.  */
	if (i.suffix == LONG_MNEM_SUFFIX
	    || (intel_syntax && i.suffix == DWORD_MNEM_SUFFIX))
	  {
	    if (i.tm.opcode_modifier & FloatMF)
	      i.tm.base_opcode ^= 4;
	  }
      }

    if (i.tm.opcode_modifier & ImmExt)
      {
	/* These AMD 3DNow! and Intel Katmai New Instructions have an
	   opcode suffix which is coded in the same place as an 8-bit
	   immediate field would be.  Here we fake an 8-bit immediate
	   operand from the opcode suffix stored in tm.extension_opcode.  */

	expressionS *exp;

	assert(i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);

	exp = &im_expressions[i.imm_operands++];
	i.op[i.operands].imms = exp;
	i.types[i.operands++] = Imm8;
	exp->X_op = O_constant;
	exp->X_add_number = i.tm.extension_opcode;
	i.tm.extension_opcode = None;
d1318 1
a1318 1
	/* Default segment register this instruction will use
d1323 14
d1338 5
a1342 9
	   imul $imm, %reg, %reg, and the clr %reg instruction
	   is converted into xor %reg, %reg.  */
	if (i.tm.opcode_modifier & regKludge)
	  {
	    unsigned int first_reg_op = (i.types[0] & Reg) ? 0 : 1;
	    /* Pretend we saw the extra register operand. */
	    assert (i.op[first_reg_op+1].regs == 0);
	    i.op[first_reg_op+1].regs = i.op[first_reg_op].regs;
	    i.types[first_reg_op+1] = i.types[first_reg_op];
d1346 22
a1367 1
	if (i.tm.opcode_modifier & ShortForm)
d1372 13
a1384 2
	    i.tm.base_opcode |= i.op[op].regs->reg_num;
	    if ((i.tm.opcode_modifier & Ugh) != 0)
d1386 2
a1387 15
		/* Warn about some common errors, but press on regardless.
		   The first case can be generated by gcc (<= 2.8.1).  */
		if (i.operands == 2)
		  {
		    /* reversed arguments on faddp, fsubp, etc. */
		    as_warn (_("translating to `%s %%%s,%%%s'"), i.tm.name,
			     i.op[1].regs->reg_name,
			     i.op[0].regs->reg_name);
		  }
		else
		  {
		    /* extraneous `l' suffix on fp insn */
		    as_warn (_("translating to `%s %%%s'"), i.tm.name,
			     i.op[0].regs->reg_name);
		  }
d1389 1
d1391 1
a1391 1
	else if (i.tm.opcode_modifier & Modrm)
d1393 21
a1413 4
	    /* The opcode is completed (modulo i.tm.extension_opcode which
	       must be put into the modrm byte).
	       Now, we make the modrm & index base bytes based on all the
	       info we've collected. */
d1421 7
a1427 3
			   & (Reg | RegMMX | RegXMM
			      | SReg2 | SReg3
			      | Control | Debug | Test))
a1429 1

d1431 6
a1436 8
		/* One of the register operands will be encoded in the
		   i.tm.reg field, the other in the combined i.tm.mode
		   and i.tm.regmem fields.  If no form of this
		   instruction supports a memory destination operand,
		   then we assume the source operand may sometimes be
		   a memory operand and so we need to store the
		   destination in the i.rm.reg field.  */
		if ((i.tm.operand_types[dest] & AnyMem) == 0)
d1438 2
a1439 2
		    i.rm.reg = i.op[dest].regs->reg_num;
		    i.rm.regmem = i.op[source].regs->reg_num;
d1443 2
a1444 2
		    i.rm.reg = i.op[source].regs->reg_num;
		    i.rm.regmem = i.op[dest].regs->reg_num;
d1452 1
a1452 3
		    unsigned int op = ((i.types[0] & AnyMem)
				       ? 0
				       : (i.types[1] & AnyMem) ? 1 : 2);
d1454 2
a1455 1
		    default_seg = &ds;
d1457 1
a1457 1
		    if (! i.base_reg)
d1459 11
a1469 4
			i.rm.mode = 0;
			if (! i.disp_operands)
			  fake_zero_displacement = 1;
			if (! i.index_reg)
d1471 28
a1498 13
			    /* Operand is just <disp> */
			    if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0))
			      {
				i.rm.regmem = NO_BASE_REGISTER_16;
				i.types[op] &= ~Disp;
				i.types[op] |= Disp16;
			      }
			    else
			      {
				i.rm.regmem = NO_BASE_REGISTER;
				i.types[op] &= ~Disp;
				i.types[op] |= Disp32;
			      }
d1500 1
a1500 1
			else /* ! i.base_reg && i.index_reg */
d1502 2
a1503 6
			    i.sib.index = i.index_reg->reg_num;
			    i.sib.base = NO_BASE_REGISTER;
			    i.sib.scale = i.log2_scale_factor;
			    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
			    i.types[op] &= ~Disp;
			    i.types[op] |= Disp32;	/* Must be 32 bit */
d1506 1
a1506 1
		    else if (i.base_reg->reg_type & Reg16)
d1508 5
a1512 27
			switch (i.base_reg->reg_num)
			  {
			  case 3: /* (%bx) */
			    if (! i.index_reg)
			      i.rm.regmem = 7;
			    else /* (%bx,%si) -> 0, or (%bx,%di) -> 1 */
			      i.rm.regmem = i.index_reg->reg_num - 6;
			    break;
			  case 5: /* (%bp) */
			    default_seg = &ss;
			    if (! i.index_reg)
			      {
				i.rm.regmem = 6;
				if ((i.types[op] & Disp) == 0)
				  {
				    /* fake (%bp) into 0(%bp) */
				    i.types[op] |= Disp8;
				    fake_zero_displacement = 1;
				  }
			      }
			    else /* (%bp,%si) -> 2, or (%bp,%di) -> 3 */
			      i.rm.regmem = i.index_reg->reg_num - 6 + 2;
			    break;
			  default: /* (%si) -> 4 or (%di) -> 5 */
			    i.rm.regmem = i.base_reg->reg_num - 6 + 4;
			  }
			i.rm.mode = mode_from_disp_size (i.types[op]);
d1514 1
a1514 1
		    else /* i.base_reg and 32 bit mode */
d1516 1
d1518 2
a1519 2
			i.sib.base = i.base_reg->reg_num;
			if (i.base_reg->reg_num == EBP_REG_NUM)
d1521 6
a1526 3
			    default_seg = &ss;
			    if (i.disp_operands == 0)
			      {
d1529 1
a1531 27
			else if (i.base_reg->reg_num == ESP_REG_NUM)
			  {
			    default_seg = &ss;
			  }
			i.sib.scale = i.log2_scale_factor;
			if (! i.index_reg)
			  {
			    /* <disp>(%esp) becomes two byte modrm
			       with no index register.  We've already
			       stored the code for esp in i.rm.regmem
			       ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.  Any
			       base register besides %esp will not use
			       the extra modrm byte.  */
			    i.sib.index = NO_INDEX_REGISTER;
#if ! SCALE1_WHEN_NO_INDEX
			    /* Another case where we force the second
			       modrm byte.  */
			    if (i.log2_scale_factor)
			      i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
#endif
			  }
			else
			  {
			    i.sib.index = i.index_reg->reg_num;
			    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
			  }
			i.rm.mode = mode_from_disp_size (i.types[op]);
a1532 1

a1536 3
			expressionS *exp;

			assert (i.op[op].disps == 0);
d1538 1
a1538 1
			i.op[op].disps = exp;
d1544 18
d1565 4
a1568 4
		   operand (if any) based on i.tm.extension_opcode.
		   Again, we must be careful to make sure that
		   segment/control/debug/test/MMX registers are coded
		   into the i.rm.reg field. */
d1573 2
a1574 3
			& (Reg | RegMMX | RegXMM
			   | SReg2 | SReg3
			   | Control | Debug | Test))
d1577 2
a1578 3
			   & (Reg | RegMMX | RegXMM
			      | SReg2 | SReg3
			      | Control | Debug | Test))
d1583 2
a1584 2
		    if (i.tm.extension_opcode != None)
		      i.rm.regmem = i.op[op].regs->reg_num;
d1586 1
a1586 1
		      i.rm.reg = i.op[op].regs->reg_num;
d1590 1
a1590 1
		       operand in the regmem field.  */
d1596 2
a1597 2
		if (i.tm.extension_opcode != None)
		  i.rm.reg = i.tm.extension_opcode;
d1599 3
d1603 5
a1607 1
	else if (i.tm.opcode_modifier & (Seg2ShortForm | Seg3ShortForm))
d1609 1
a1609 1
	    if (i.tm.base_opcode == POP_SEG_SHORT && i.op[0].regs->reg_num == 1)
d1611 3
a1613 2
		as_bad (_("you can't `pop %%cs'"));
		return;
d1615 1
a1615 11
	    i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);
	  }
	else if ((i.tm.base_opcode & ~(D|W)) == MOV_AX_DISP32)
	  {
	    default_seg = &ds;
	  }
	else if ((i.tm.opcode_modifier & IsString) != 0)
	  {
	    /* For the string instructions that allow a segment override
	       on one of their operands, the default segment is ds.  */
	    default_seg = &ds;
d1624 1
a1624 1
	if ((i.seg[0]) && (i.seg[0] != default_seg))
d1626 7
a1632 2
	    if (! add_prefix (i.seg[0]->seg_prefix))
	      return;
a1634 5
    else if ((i.tm.opcode_modifier & Ugh) != 0)
      {
	/* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
	as_warn (_("translating to `%sp'"), i.tm.name);
      }
d1638 1
a1638 1
  if (i.tm.base_opcode == INT_OPCODE && i.op[0].imms->X_add_number == 3)
d1640 1
a1640 1
      i.tm.base_opcode = INT3_OPCODE;
a1643 10
  if ((i.tm.opcode_modifier & (Jump | JumpByte | JumpDword))
      && i.op[0].disps->X_op == O_constant)
    {
      /* Convert "jmp constant" (and "call constant") to a jump (call) to
	 the absolute address given by the constant.  Since ix86 jumps and
	 calls are pc relative, we need to generate a reloc.  */
      i.op[0].disps->X_add_symbol = &abs_symbol;
      i.op[0].disps->X_op = O_symbol;
    }

d1649 1
a1649 1
    if (i.tm.opcode_modifier & Jump)
d1651 1
a1651 3
	int size;
	int code16;
	int prefix;
d1653 11
a1663 3
	code16 = 0;
	if (flag_16bit_code)
	  code16 = CODE16;
d1665 10
a1674 42
	prefix = 0;
	if (i.prefix[DATA_PREFIX])
	  {
	    prefix = 1;
	    i.prefixes -= 1;
	    code16 ^= CODE16;
	  }

	size = 4;
	if (code16)
	  size = 2;

	if (i.prefixes != 0 && !intel_syntax)
	  as_warn (_("skipping prefixes on this instruction"));

	/* It's always a symbol;  End frag & setup for relax.
	   Make sure there is enough room in this frag for the largest
	   instruction we may generate in md_convert_frag.  This is 2
	   bytes for the opcode and room for the prefix and largest
	   displacement.  */
	frag_grow (prefix + 2 + size);
	insn_size += prefix + 1;
	/* Prefix and 1 opcode byte go in fr_fix.  */
	p = frag_more (prefix + 1);
	if (prefix)
	  *p++ = DATA_PREFIX_OPCODE;
	*p = i.tm.base_opcode;
	/* 1 possible extra opcode + displacement go in var part.
	   Pass reloc in fr_var.  */
	frag_var (rs_machine_dependent,
		  1 + size,
		  i.disp_reloc[0],
		  ((unsigned char) *p == JUMP_PC_RELATIVE
		   ? ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL) | code16
		   : ENCODE_RELAX_STATE (COND_JUMP, SMALL) | code16),
		  i.op[0].disps->X_add_symbol,
		  i.op[0].disps->X_add_number,
		  p);
      }
    else if (i.tm.opcode_modifier & (JumpByte | JumpDword))
      {
	int size;
d1676 17
a1692 9
	if (i.tm.opcode_modifier & JumpByte)
	  {
	    /* This is a loop or jecxz type instruction.  */
	    size = 1;
	    if (i.prefix[ADDR_PREFIX])
	      {
		insn_size += 1;
		FRAG_APPEND_1_CHAR (ADDR_PREFIX_OPCODE);
		i.prefixes -= 1;
a1696 3
	    int code16;

	    code16 = 0;
a1697 3
	      code16 = CODE16;

	    if (i.prefix[DATA_PREFIX])
d1699 1
a1700 3
		FRAG_APPEND_1_CHAR (DATA_PREFIX_OPCODE);
		i.prefixes -= 1;
		code16 ^= CODE16;
d1703 15
a1717 19
	    size = 4;
	    if (code16)
	      size = 2;
	  }

	if (i.prefixes != 0 && !intel_syntax)
	  as_warn (_("skipping prefixes on this instruction"));

	if (fits_in_unsigned_byte (i.tm.base_opcode))
	  {
	    insn_size += 1 + size;
	    p = frag_more (1 + size);
	  }
	else
	  {
	    /* opcode can be at most two bytes */
	    insn_size += 2 + size;
	    p = frag_more (2 + size);
	    *p++ = (i.tm.base_opcode >> 8) & 0xff;
a1718 4
	*p++ = i.tm.base_opcode & 0xff;

	fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		     i.op[0].disps, 1, reloc (size, 1, i.disp_reloc[0]));
d1720 1
a1720 1
    else if (i.tm.opcode_modifier & JumpInterSegment)
d1722 3
a1724 7
	int size;
	int prefix;
	int code16;

	code16 = 0;
	if (flag_16bit_code)
	  code16 = CODE16;
d1726 2
a1727 2
	prefix = 0;
	if (i.prefix[DATA_PREFIX])
d1729 1
a1729 24
	    prefix = 1;
	    i.prefixes -= 1;
	    code16 ^= CODE16;
	  }

	size = 4;
	if (code16)
	  size = 2;

	if (i.prefixes != 0 && !intel_syntax)
	  as_warn (_("skipping prefixes on this instruction"));

	insn_size += prefix + 1 + 2 + size;  /* 1 opcode; 2 segment; offset */
	p = frag_more (prefix + 1 + 2 + size);
	if (prefix)
	  *p++ = DATA_PREFIX_OPCODE;
	*p++ = i.tm.base_opcode;
	if (i.op[1].imms->X_op == O_constant)
	  {
	    long n = (long) i.op[1].imms->X_add_number;

	    if (size == 2
		&& !fits_in_unsigned_word (n)
		&& !fits_in_signed_word (n))
d1731 3
a1733 2
		as_bad (_("16-bit jump out of range"));
		return;
a1734 1
	    md_number_to_chars (p, (valueT) n, size);
a1735 12
	else
	  fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		       i.op[1].imms, 0, reloc (size, 0, i.disp_reloc[0]));
	if (i.op[0].imms->X_op != O_constant)
	  as_bad (_("can't handle non absolute segment in `%s'"),
		  i.tm.name);
	md_number_to_chars (p + size, (valueT) i.op[0].imms->X_add_number, 2);
      }
    else
      {
	/* Output normal instructions here. */
	unsigned char *q;
d1737 1
a1737 4
	/* The prefix bytes. */
	for (q = i.prefix;
	     q < i.prefix + sizeof (i.prefix) / sizeof (i.prefix[0]);
	     q++)
d1739 2
a1740 6
	    if (*q)
	      {
		insn_size += 1;
		p = frag_more (1);
		md_number_to_chars (p, (valueT) *q, 1);
	      }
d1743 1
a1743 2
	/* Now the opcode; be careful about word order here! */
	if (fits_in_unsigned_byte (i.tm.base_opcode))
d1745 1
a1746 1
	    FRAG_APPEND_1_CHAR (i.tm.base_opcode);
d1748 1
a1748 1
	else if (fits_in_unsigned_word (i.tm.base_opcode))
d1750 1
a1751 1
	    p = frag_more (2);
d1753 68
a1820 2
	    *p++ = (i.tm.base_opcode >> 8) & 0xff;
	    *p = i.tm.base_opcode & 0xff;
d1824 1
a1824 1
	    if (i.tm.base_opcode & 0xff000000)
d1826 1
d1828 1
a1828 2
		p = frag_more (4);
		*p++ = (i.tm.base_opcode >> 24) & 0xff;
d1832 1
a1833 1
		p = frag_more (3);
d1835 3
a1837 3
	    *p++ = (i.tm.base_opcode >> 16) & 0xff;
	    *p++ = (i.tm.base_opcode >> 8) & 0xff;
	    *p = (i.tm.base_opcode) & 0xff;
d1840 2
a1841 2
	/* Now the modrm byte and sib byte (if present).  */
	if (i.tm.opcode_modifier & Modrm)
d1843 1
d1845 1
a1845 1
	    p = frag_more (1);
d1851 3
a1853 7
	    /* If i.rm.regmem == ESP (4)
	       && i.rm.mode != (Register mode)
	       && not 16 bit
	       ==> need second modrm byte.  */
	    if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING
		&& i.rm.mode != 3
		&& !(i.base_reg && (i.base_reg->reg_type & Reg16) != 0))
d1855 1
d1857 4
a1860 5
		p = frag_more (1);
		md_number_to_chars (p,
				    (valueT) (i.sib.base << 0
					      | i.sib.index << 3
					      | i.sib.scale << 6),
d1871 1
a1871 1
		if (i.types[n] & Disp)
d1873 1
a1873 1
		    if (i.op[n].disps->X_op == O_constant)
d1875 9
a1883 4
			int size = 4;
			long val = (long) i.op[n].disps->X_add_number;

			if (i.types[n] & (Disp8 | Disp16))
d1885 13
a1897 13
			    long mask;

			    size = 2;
			    mask = ~ (long) 0xffff;
			    if (i.types[n] & Disp8)
			      {
				size = 1;
				mask = ~ (long) 0xff;
			      }

			    if ((val & mask) != 0 && (val & mask) != mask)
			      as_warn (_("%ld shortened to %ld"),
				       val, val & ~mask);
a1898 3
			insn_size += size;
			p = frag_more (size);
			md_number_to_chars (p, (valueT) val, size);
d1901 7
a1907 11
		      {
			int size = 4;

			if (i.types[n] & Disp16)
			  size = 2;

			insn_size += size;
			p = frag_more (size);
			fix_new_exp (frag_now, p - frag_now->fr_literal, size,
				     i.op[n].disps, 0,
				     reloc (size, 0, i.disp_reloc[n]));
d1920 1
a1920 1
		if (i.types[n] & Imm)
d1922 1
a1922 1
		    if (i.op[n].imms->X_op == O_constant)
d1924 17
a1940 4
			int size = 4;
			long val = (long) i.op[n].imms->X_add_number;

			if (i.types[n] & (Imm8 | Imm8S | Imm16))
d1942 5
a1946 12
			    long mask;

			    size = 2;
			    mask = ~ (long) 0xffff;
			    if (i.types[n] & (Imm8 | Imm8S))
			      {
				size = 1;
				mask = ~ (long) 0xff;
			      }
			    if ((val & mask) != 0 && (val & mask) != mask)
			      as_warn (_("%ld shortened to %ld"),
				       val, val & ~mask);
a1947 3
			insn_size += size;
			p = frag_more (size);
			md_number_to_chars (p, (valueT) val, size);
d1952 1
a1952 1
			   non-absolute imms).  Try to support other
d1954 3
a1956 6
#ifdef BFD_ASSEMBLER
			enum bfd_reloc_code_real reloc_type;
#else
			int reloc_type;
#endif
			int size = 4;
d1958 3
a1960 1
			if (i.types[n] & Imm16)
d1962 4
a1965 3
			else if (i.types[n] & (Imm8 | Imm8S))
			  size = 1;

a1966 2
			p = frag_more (size);
			reloc_type = reloc (size, 0, i.disp_reloc[0]);
d1968 1
a1968 1
			if (reloc_type == BFD_RELOC_32
d1970 4
a1973 5
			    && GOT_symbol == i.op[n].imms->X_add_symbol
			    && (i.op[n].imms->X_op == O_symbol
				|| (i.op[n].imms->X_op == O_add
				    && ((symbol_get_value_expression
					 (i.op[n].imms->X_op_symbol)->X_op)
d1976 2
a1977 2
			    reloc_type = BFD_RELOC_386_GOTPC;
			    i.op[n].imms->X_add_number += 3;
d1981 1
a1981 1
				     i.op[n].imms, 0, reloc_type);
d1988 7
a1994 883
#ifdef DEBUG386
    if (flag_debug)
      {
	pi (line, &i);
      }
#endif /* DEBUG386 */
  }
}

static int i386_immediate PARAMS ((char *));

static int
i386_immediate (imm_start)
     char *imm_start;
{
  char *save_input_line_pointer;
  segT exp_seg = 0;
  expressionS * exp;

  if (i.imm_operands == MAX_IMMEDIATE_OPERANDS)
    {
      as_bad (_("only 1 or 2 immediate operands are allowed"));
      return 0;
    }

  exp = &im_expressions[i.imm_operands++];
  i.op[this_operand].imms = exp;

  if (is_space_char (*imm_start))
    ++imm_start;

  save_input_line_pointer = input_line_pointer;
  input_line_pointer = imm_start;

#ifndef LEX_AT
  {
    /*
     * We can have operands of the form
     *   <symbol>@@GOTOFF+<nnn>
     * Take the easy way out here and copy everything
     * into a temporary buffer...
     */
    register char *cp;

    cp = strchr (input_line_pointer, '@@');
    if (cp != NULL)
      {
	char *tmpbuf;
	int len = 0;
	int first;

	/* GOT relocations are not supported in 16 bit mode */
	if (flag_16bit_code)
	  as_bad (_("GOT relocations not supported in 16 bit mode"));

	if (GOT_symbol == NULL)
	  GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	if (strncmp (cp + 1, "PLT", 3) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
	    len = 3;
	  }
	else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
	    len = 6;
	  }
	else if (strncmp (cp + 1, "GOT", 3) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
	    len = 3;
	  }
	else
	  as_bad (_("bad reloc specifier in expression"));

	/* Replace the relocation token with ' ', so that errors like
	   foo@@GOTOFF1 will be detected.  */
	first = cp - input_line_pointer;
	tmpbuf = (char *) alloca (strlen(input_line_pointer));
	memcpy (tmpbuf, input_line_pointer, first);
	tmpbuf[first] = ' ';
	strcpy (tmpbuf + first + 1, cp + 1 + len);
	input_line_pointer = tmpbuf;
      }
  }
#endif

  exp_seg = expression (exp);

  SKIP_WHITESPACE ();
  if (*input_line_pointer)
    as_bad (_("ignoring junk `%s' after expression"), input_line_pointer);

  input_line_pointer = save_input_line_pointer;

  if (exp->X_op == O_absent || exp->X_op == O_big)
    {
      /* missing or bad expr becomes absolute 0 */
      as_bad (_("missing or invalid immediate expression `%s' taken as 0"),
	      imm_start);
      exp->X_op = O_constant;
      exp->X_add_number = 0;
      exp->X_add_symbol = (symbolS *) 0;
      exp->X_op_symbol = (symbolS *) 0;
    }

  if (exp->X_op == O_constant)
    {
      i.types[this_operand] |= Imm32;	/* Size it properly later.  */
    }
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  else if (
#ifdef BFD_ASSEMBLER
	   OUTPUT_FLAVOR == bfd_target_aout_flavour &&
#endif
	   exp_seg != text_section
	   && exp_seg != data_section
	   && exp_seg != bss_section
	   && exp_seg != undefined_section
#ifdef BFD_ASSEMBLER
	   && !bfd_is_com_section (exp_seg)
#endif
	   )
    {
#ifdef BFD_ASSEMBLER
      as_bad (_("unimplemented segment %s in operand"), exp_seg->name);
#else
      as_bad (_("unimplemented segment type %d in operand"), exp_seg);
#endif
      return 0;
    }
#endif
  else
    {
      /* This is an address.  The size of the address will be
	 determined later, depending on destination register,
	 suffix, or the default for the section.  We exclude
	 Imm8S here so that `push $foo' and other instructions
	 with an Imm8S form will use Imm16 or Imm32.  */
      i.types[this_operand] |= (Imm8 | Imm16 | Imm32);
    }

  return 1;
}

static int i386_scale PARAMS ((char *));

static int
i386_scale (scale)
     char *scale;
{
  if (!isdigit (*scale))
    goto bad_scale;

  switch (*scale)
    {
    case '0':
    case '1':
      i.log2_scale_factor = 0;
      break;
    case '2':
      i.log2_scale_factor = 1;
      break;
    case '4':
      i.log2_scale_factor = 2;
      break;
    case '8':
      i.log2_scale_factor = 3;
      break;
    default:
    bad_scale:
      as_bad (_("expecting scale factor of 1, 2, 4, or 8: got `%s'"),
	      scale);
      return 0;
    }
  if (i.log2_scale_factor != 0 && ! i.index_reg)
    {
      as_warn (_("scale factor of %d without an index register"),
	       1 << i.log2_scale_factor);
#if SCALE1_WHEN_NO_INDEX
      i.log2_scale_factor = 0;
#endif
    }
  return 1;
}

static int i386_displacement PARAMS ((char *, char *));

static int
i386_displacement (disp_start, disp_end)
     char *disp_start;
     char *disp_end;
{
  register expressionS *exp;
  segT exp_seg = 0;
  char *save_input_line_pointer;
  int bigdisp = Disp32;

  if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0))
    bigdisp = Disp16;
  i.types[this_operand] |= bigdisp;

  exp = &disp_expressions[i.disp_operands];
  i.op[this_operand].disps = exp;
  i.disp_operands++;
  save_input_line_pointer = input_line_pointer;
  input_line_pointer = disp_start;
  END_STRING_AND_SAVE (disp_end);

#ifndef GCC_ASM_O_HACK
#define GCC_ASM_O_HACK 0
#endif
#if GCC_ASM_O_HACK
  END_STRING_AND_SAVE (disp_end + 1);
  if ((i.types[this_operand] & BaseIndex) != 0
      && displacement_string_end[-1] == '+')
    {
      /* This hack is to avoid a warning when using the "o"
	 constraint within gcc asm statements.
	 For instance:

	 #define _set_tssldt_desc(n,addr,limit,type) \
	 __asm__ __volatile__ ( \
	 "movw %w2,%0\n\t" \
	 "movw %w1,2+%0\n\t" \
	 "rorl $16,%1\n\t" \
	 "movb %b1,4+%0\n\t" \
	 "movb %4,5+%0\n\t" \
	 "movb $0,6+%0\n\t" \
	 "movb %h1,7+%0\n\t" \
	 "rorl $16,%1" \
	 : "=o"(*(n)) : "q" (addr), "ri"(limit), "i"(type))

	 This works great except that the output assembler ends
	 up looking a bit weird if it turns out that there is
	 no offset.  You end up producing code that looks like:

	 #APP
	 movw $235,(%eax)
	 movw %dx,2+(%eax)
	 rorl $16,%edx
	 movb %dl,4+(%eax)
	 movb $137,5+(%eax)
	 movb $0,6+(%eax)
	 movb %dh,7+(%eax)
	 rorl $16,%edx
	 #NO_APP

	 So here we provide the missing zero.
      */

      *displacement_string_end = '0';
    }
#endif
#ifndef LEX_AT
  {
    /*
     * We can have operands of the form
     *   <symbol>@@GOTOFF+<nnn>
     * Take the easy way out here and copy everything
     * into a temporary buffer...
     */
    register char *cp;

    cp = strchr (input_line_pointer, '@@');
    if (cp != NULL)
      {
	char *tmpbuf;
	int len = 0;
	int first;

	/* GOT relocations are not supported in 16 bit mode */
	if (flag_16bit_code)
	  as_bad (_("GOT relocations not supported in 16 bit mode"));

	if (GOT_symbol == NULL)
	  GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	if (strncmp (cp + 1, "PLT", 3) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
	    len = 3;
	  }
	else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
	    len = 6;
	  }
	else if (strncmp (cp + 1, "GOT", 3) == 0)
	  {
	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
	    len = 3;
	  }
	else
	  as_bad (_("bad reloc specifier in expression"));

	/* Replace the relocation token with ' ', so that errors like
	   foo@@GOTOFF1 will be detected.  */
	first = cp - input_line_pointer;
	tmpbuf = (char *) alloca (strlen(input_line_pointer));
	memcpy (tmpbuf, input_line_pointer, first);
	tmpbuf[first] = ' ';
	strcpy (tmpbuf + first + 1, cp + 1 + len);
	input_line_pointer = tmpbuf;
      }
  }
#endif

  exp_seg = expression (exp);

#ifdef BFD_ASSEMBLER
  /* We do this to make sure that the section symbol is in
     the symbol table.  We will ultimately change the relocation
     to be relative to the beginning of the section */
  if (i.disp_reloc[this_operand] == BFD_RELOC_386_GOTOFF)
    {
      if (S_IS_LOCAL(exp->X_add_symbol)
	  && S_GET_SEGMENT (exp->X_add_symbol) != undefined_section)
	section_symbol (S_GET_SEGMENT (exp->X_add_symbol));
      assert (exp->X_op == O_symbol);
      exp->X_op = O_subtract;
      exp->X_op_symbol = GOT_symbol;
      i.disp_reloc[this_operand] = BFD_RELOC_32;
    }
#endif

  SKIP_WHITESPACE ();
  if (*input_line_pointer)
    as_bad (_("ignoring junk `%s' after expression"),
	    input_line_pointer);
#if GCC_ASM_O_HACK
  RESTORE_END_STRING (disp_end + 1);
#endif
  RESTORE_END_STRING (disp_end);
  input_line_pointer = save_input_line_pointer;

  if (exp->X_op == O_absent || exp->X_op == O_big)
    {
      /* missing or bad expr becomes absolute 0 */
      as_bad (_("missing or invalid displacement expression `%s' taken as 0"),
	      disp_start);
      exp->X_op = O_constant;
      exp->X_add_number = 0;
      exp->X_add_symbol = (symbolS *) 0;
      exp->X_op_symbol = (symbolS *) 0;
    }

  if (exp->X_op == O_constant)
    {
      if (i.types[this_operand] & Disp16)
	{
	  /* We know this operand is at most 16 bits, so convert to a
	     signed 16 bit number before trying to see whether it will
	     fit in an even smaller size.  */
	  exp->X_add_number =
	    (((exp->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
	}
      if (fits_in_signed_byte (exp->X_add_number))
	i.types[this_operand] |= Disp8;
    }
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  else if (
#ifdef BFD_ASSEMBLER
	   OUTPUT_FLAVOR == bfd_target_aout_flavour &&
#endif
	   exp_seg != text_section
	   && exp_seg != data_section
	   && exp_seg != bss_section
	   && exp_seg != undefined_section)
    {
#ifdef BFD_ASSEMBLER
      as_bad (_("unimplemented segment %s in operand"), exp_seg->name);
#else
      as_bad (_("unimplemented segment type %d in operand"), exp_seg);
#endif
      return 0;
    }
#endif
  return 1;
}

static int i386_operand_modifier PARAMS ((char **, int));

static int
i386_operand_modifier (op_string, got_a_float)
     char **op_string;
     int got_a_float;
{
  if (!strncasecmp (*op_string, "BYTE PTR", 8))
    {
      i.suffix = BYTE_MNEM_SUFFIX;
      *op_string += 8;
      return BYTE_PTR;

    }
  else if (!strncasecmp (*op_string, "WORD PTR", 8))
    {
      if (got_a_float == 2)	/* "fi..." */
	i.suffix = SHORT_MNEM_SUFFIX;
      else
	i.suffix = WORD_MNEM_SUFFIX;
      *op_string += 8;
      return WORD_PTR;
    }

  else if (!strncasecmp (*op_string, "DWORD PTR", 9))
    {
      if (got_a_float == 1)	/* "f..." */
	i.suffix = SHORT_MNEM_SUFFIX;
      else
	i.suffix = LONG_MNEM_SUFFIX;
      *op_string += 9;
      return DWORD_PTR;
    }

  else if (!strncasecmp (*op_string, "QWORD PTR", 9))
    {
      i.suffix = DWORD_MNEM_SUFFIX;
      *op_string += 9;
      return QWORD_PTR;
    }

  else if (!strncasecmp (*op_string, "XWORD PTR", 9))
    {
      i.suffix = LONG_DOUBLE_MNEM_SUFFIX;
      *op_string += 9;
      return XWORD_PTR;
    }

  else if (!strncasecmp (*op_string, "SHORT", 5))
    {
      *op_string += 5;
      return SHORT;
    }

  else if (!strncasecmp (*op_string, "OFFSET FLAT:", 12))
    {
      *op_string += 12;
      return OFFSET_FLAT;
    }

  else if (!strncasecmp (*op_string, "FLAT", 4))
    {
      *op_string += 4;
      return FLAT;
    }

  else return NONE_FOUND;
}

static char * build_displacement_string PARAMS ((int, char *));

static char *
build_displacement_string (initial_disp, op_string)
     int initial_disp;
     char *op_string;
{
  char *temp_string = (char *) malloc (strlen (op_string) + 1);
  char *end_of_operand_string;
  char *tc;
  char *temp_disp;

  temp_string[0] = '\0';
  tc = end_of_operand_string = strchr (op_string, '[');
  if (initial_disp && !end_of_operand_string)
    {
      strcpy (temp_string, op_string);
      return temp_string;
    }

  /* Build the whole displacement string */
  if (initial_disp)
    {
      strncpy (temp_string, op_string, end_of_operand_string - op_string);
      temp_string[end_of_operand_string - op_string] = '\0';
      temp_disp = tc;
    }
  else
    temp_disp = op_string;

  while (*temp_disp != '\0')
    {
      char *end_op;
      int add_minus = (*temp_disp == '-');

      if (*temp_disp == '+' || *temp_disp == '-' || *temp_disp == '[')
	temp_disp++;

      if (is_space_char (*temp_disp))
	temp_disp++;

      /* Don't consider registers */
      if ( !((*temp_disp == REGISTER_PREFIX || allow_naked_reg)
	     && parse_register (temp_disp, &end_op)) )
	{
	  char *string_start = temp_disp;

	  while (*temp_disp != ']'
		 && *temp_disp != '+'
		 && *temp_disp != '-'
		 && *temp_disp != '*')
	    ++temp_disp;

	  if (add_minus)
	    strcat (temp_string, "-");
	  else
	    strcat (temp_string, "+");

	  strncat (temp_string, string_start, temp_disp - string_start);
	  if (*temp_disp == '+' || *temp_disp == '-')
	    --temp_disp;
	}

      while (*temp_disp != '\0'
	     && *temp_disp != '+'
	     && *temp_disp != '-')
	++temp_disp;
    }

  return temp_string;
}

static int i386_parse_seg PARAMS ((char *));

static int
i386_parse_seg (op_string)
     char *op_string;
{
  if (is_space_char (*op_string))
    ++op_string;

  /* Should be one of es, cs, ss, ds fs or gs */
  switch (*op_string++)
    {
    case 'e':
      i.seg[i.mem_operands] = &es;
      break;
    case 'c':
      i.seg[i.mem_operands] = &cs;
      break;
    case 's':
      i.seg[i.mem_operands] = &ss;
      break;
    case 'd':
      i.seg[i.mem_operands] = &ds;
      break;
    case 'f':
      i.seg[i.mem_operands] = &fs;
      break;
    case 'g':
      i.seg[i.mem_operands] = &gs;
      break;
    default:
      as_bad (_("bad segment name `%s'"), op_string);
      return 0;
    }

  if (*op_string++ != 's')
    {
      as_bad (_("bad segment name `%s'"), op_string);
      return 0;
    }

  if (is_space_char (*op_string))
    ++op_string;

  if (*op_string != ':')
    {
      as_bad (_("bad segment name `%s'"), op_string);
      return 0;
    }

  return 1;

}

static int i386_index_check PARAMS((const char *));

/* Make sure the memory operand we've been dealt is valid.
   Returns 1 on success, 0 on a failure.
*/
static int
i386_index_check (operand_string)
     const char *operand_string;
{
#if INFER_ADDR_PREFIX
  int fudged = 0;

 tryprefix:
#endif
  if (flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0)
      /* 16 bit mode checks */
      ? ((i.base_reg
	  && ((i.base_reg->reg_type & (Reg16|BaseIndex))
	      != (Reg16|BaseIndex)))
	 || (i.index_reg
	     && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		  != (Reg16|BaseIndex))
		 || ! (i.base_reg
		       && i.base_reg->reg_num < 6
		       && i.index_reg->reg_num >= 6
		       && i.log2_scale_factor == 0))))
      /* 32 bit mode checks */
      : ((i.base_reg
	  && (i.base_reg->reg_type & Reg32) == 0)
	 || (i.index_reg
	     && ((i.index_reg->reg_type & (Reg32|BaseIndex))
		 != (Reg32|BaseIndex)))))
    {
#if INFER_ADDR_PREFIX
      if (i.prefix[ADDR_PREFIX] == 0 && stackop_size != '\0')
	{
	  i.prefix[ADDR_PREFIX] = ADDR_PREFIX_OPCODE;
	  i.prefixes += 1;
	  /* Change the size of any displacement too.  At most one of
	     Disp16 or Disp32 is set.
	     FIXME.  There doesn't seem to be any real need for separate
	     Disp16 and Disp32 flags.  The same goes for Imm16 and Imm32.
	     Removing them would probably clean up the code quite a lot.
	  */
	  if (i.types[this_operand] & (Disp16|Disp32))
	     i.types[this_operand] ^= (Disp16|Disp32);
	  fudged = 1;
	  goto tryprefix;
	}
      if (fudged)
	as_bad (_("`%s' is not a valid base/index expression"),
		operand_string);
      else
#endif
	as_bad (_("`%s' is not a valid %s bit base/index expression"),
		operand_string,
		flag_16bit_code ^ (i.prefix[ADDR_PREFIX] != 0) ? "16" : "32");
      return 0;
    }
  return 1;
}

static int i386_intel_memory_operand PARAMS ((char *));

static int
i386_intel_memory_operand (operand_string)
     char *operand_string;
{
  char *op_string = operand_string;
  char *end_of_operand_string;

  if ((i.mem_operands == 1
       && (current_templates->start->opcode_modifier & IsString) == 0)
      || i.mem_operands == 2)
    {
      as_bad (_("too many memory references for `%s'"),
	      current_templates->start->name);
      return 0;
    }

  /* First check for a segment override.  */
  if (*op_string != '[')
    {
      char *end_seg;

      end_seg = strchr (op_string, ':');
      if (end_seg)
	{
	  if (!i386_parse_seg (op_string))
	    return 0;
	  op_string = end_seg + 1;
	}
    }

  /* Look for displacement preceding open bracket */
  if (*op_string != '[')
    {
      char *temp_string;

      if (i.disp_operands)
	return 0;

      temp_string = build_displacement_string (true, op_string);

      if (!i386_displacement (temp_string, temp_string + strlen (temp_string)))
	{
	  free (temp_string);
	  return 0;
	}
      free (temp_string);

      end_of_operand_string = strchr (op_string, '[');
      if (!end_of_operand_string)
	end_of_operand_string = op_string + strlen (op_string);

      if (is_space_char (*end_of_operand_string))
	--end_of_operand_string;

      op_string = end_of_operand_string;
    }

  if (*op_string == '[')
    {
      ++op_string;

      /* Pick off each component and figure out where it belongs */

      end_of_operand_string = op_string;

      while (*op_string != ']')
	{
	  const reg_entry *temp_reg;
	  char *end_op;
	  char *temp_string;

	  while (*end_of_operand_string != '+'
		 && *end_of_operand_string != '-'
		 && *end_of_operand_string != '*'
		 && *end_of_operand_string != ']')
	    end_of_operand_string++;

	  temp_string = op_string;
	  if (*temp_string == '+')
	    {
	      ++temp_string;
	      if (is_space_char (*temp_string))
		++temp_string;
	    }

	  if ((*temp_string == REGISTER_PREFIX || allow_naked_reg)
	      && (temp_reg = parse_register (temp_string, &end_op)) != NULL)
	    {
	      if (i.base_reg == NULL)
		i.base_reg = temp_reg;
	      else
		i.index_reg = temp_reg;

	      i.types[this_operand] |= BaseIndex;
	    }
	  else if (*temp_string == REGISTER_PREFIX)
	    {
	      as_bad (_("bad register name `%s'"), temp_string);
	      return 0;
	    }
	  else if (is_digit_char (*op_string)
		   || *op_string == '+' || *op_string == '-')
	    {
	      char *temp_str;

	      if (i.disp_operands != 0)
		return 0;

	      temp_string = build_displacement_string (false, op_string);

	      temp_str = temp_string;
	      if (*temp_str == '+')
		++temp_str;

	      if (!i386_displacement (temp_str, temp_str + strlen (temp_str)))
		{
		  free (temp_string);
		  return 0;
		}
	      free (temp_string);

	      ++op_string;
	      end_of_operand_string = op_string;
	      while (*end_of_operand_string != ']'
		     && *end_of_operand_string != '+'
		     && *end_of_operand_string != '-'
		     && *end_of_operand_string != '*')
		++end_of_operand_string;
	    }
	  else if (*op_string == '*')
	    {
	      ++op_string;

	      if (i.base_reg && !i.index_reg)
		{
		  i.index_reg = i.base_reg;
		  i.base_reg = 0;
		}

	      if (!i386_scale (op_string))
		return 0;
	    }
	  op_string = end_of_operand_string;
	  ++end_of_operand_string;
	}
    }

  if (i386_index_check (operand_string) == 0)
    return 0;

  i.mem_operands++;
  return 1;
}

static int
i386_intel_operand (operand_string, got_a_float)
     char *operand_string;
     int got_a_float;
{
  const reg_entry * r;
  char *end_op;
  char *op_string = operand_string;

  int operand_modifier = i386_operand_modifier (&op_string, got_a_float);
  if (is_space_char (*op_string))
    ++op_string;

  switch (operand_modifier)
    {
    case BYTE_PTR:
    case WORD_PTR:
    case DWORD_PTR:
    case QWORD_PTR:
    case XWORD_PTR:
      if (!i386_intel_memory_operand (op_string))
	return 0;
      break;

    case FLAT:
    case OFFSET_FLAT:
      if (!i386_immediate (op_string))
	return 0;
      break;

    case SHORT:
    case NONE_FOUND:
      /* Should be register or immediate */
      if (is_digit_char (*op_string)
	  && strchr (op_string, '[') == 0)
	{
	  if (!i386_immediate (op_string))
	    return 0;
	}
      else if ((*op_string == REGISTER_PREFIX || allow_naked_reg)
	       && (r = parse_register (op_string, &end_op)) != NULL)
	{
	  /* Check for a segment override by searching for ':' after a
	     segment register.  */
	  op_string = end_op;
	  if (is_space_char (*op_string))
	    ++op_string;
	  if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
	    {
	      switch (r->reg_num)
		{
		case 0:
		  i.seg[i.mem_operands] = &es;
		  break;
		case 1:
		  i.seg[i.mem_operands] = &cs;
		  break;
		case 2:
		  i.seg[i.mem_operands] = &ss;
		  break;
		case 3:
		  i.seg[i.mem_operands] = &ds;
		  break;
		case 4:
		  i.seg[i.mem_operands] = &fs;
		  break;
		case 5:
		  i.seg[i.mem_operands] = &gs;
		  break;
		}

	    }
	  i.types[this_operand] |= r->reg_type & ~BaseIndex;
	  i.op[this_operand].regs = r;
	  i.reg_operands++;
	}
      else if (*op_string == REGISTER_PREFIX)
	{
	  as_bad (_("bad register name `%s'"), op_string);
	  return 0;
	}
      else if (!i386_intel_memory_operand (op_string))
	return 0;

      break;
    }  /* end switch */

  return 1;
d1996 1
a1996 1

d2004 4
a2007 3
  const reg_entry *r;
  char *end_op;
  char *op_string = operand_string;
d2009 3
a2011 2
  if (is_space_char (*op_string))
    ++op_string;
d2017 1
a2017 3
      ++op_string;
      if (is_space_char (*op_string))
	++op_string;
d2022 1
a2022 2
  if ((*op_string == REGISTER_PREFIX || allow_naked_reg)
      && (r = parse_register (op_string, &end_op)) != NULL)
d2024 9
a2032 6
      /* Check for a segment override by searching for ':' after a
	 segment register.  */
      op_string = end_op;
      if (is_space_char (*op_string))
	++op_string;
      if (*op_string == ':' && (r->reg_type & (SReg2 | SReg3)))
d2037 1
a2037 1
	      i.seg[i.mem_operands] = &es;
d2040 1
a2040 1
	      i.seg[i.mem_operands] = &cs;
d2043 1
a2043 1
	      i.seg[i.mem_operands] = &ss;
d2046 1
a2046 1
	      i.seg[i.mem_operands] = &ds;
d2049 1
a2049 1
	      i.seg[i.mem_operands] = &fs;
d2052 1
a2052 1
	      i.seg[i.mem_operands] = &gs;
d2055 4
a2058 10

	  /* Skip the ':' and whitespace.  */
	  ++op_string;
	  if (is_space_char (*op_string))
	    ++op_string;

	  if (!is_digit_char (*op_string)
	      && !is_identifier_char (*op_string)
	      && *op_string != '('
	      && *op_string != ABSOLUTE_PREFIX)
d2060 1
a2060 1
	      as_bad (_("bad memory operand `%s'"), op_string);
d2066 1
a2066 3
	      ++op_string;
	      if (is_space_char (*op_string))
		++op_string;
d2071 2
a2072 7
      if (*op_string)
	{
	  as_bad (_("junk `%s' after register"), op_string);
	  return 0;
	}
      i.types[this_operand] |= r->reg_type & ~BaseIndex;
      i.op[this_operand].regs = r;
a2074 5
  else if (*op_string == REGISTER_PREFIX)
    {
      as_bad (_("bad register name `%s'"), op_string);
      return 0;
    }
d2077 43
a2119 2
      ++op_string;
      if (i.types[this_operand] & JumpAbsolute)
d2121 2
a2122 1
	  as_bad (_("immediate operand illegal with absolute jump"));
d2125 20
a2144 2
      if (!i386_immediate (op_string))
	return 0;
d2146 2
a2147 3
  else if (is_digit_char (*op_string)
	   || is_identifier_char (*op_string)
	   || *op_string == '(' )
d2150 2
a2151 5
      char *base_string;

      /* Start and end of displacement string expression (if found). */
      char *displacement_string_start;
      char *displacement_string_end;
d2154 1
a2154 3
      if ((i.mem_operands == 1
	   && (current_templates->start->opcode_modifier & IsString) == 0)
	  || i.mem_operands == 2)
d2156 1
a2156 2
	  as_bad (_("too many memory references for `%s'"),
		  current_templates->start->name);
d2159 16
d2179 3
a2181 11
	 after the '('.  */
      base_string = op_string + strlen (op_string);

      --base_string;
      if (is_space_char (*base_string))
	--base_string;

      /* If we only have a displacement, set-up for it to be parsed later. */
      displacement_string_start = op_string;
      displacement_string_end = base_string + 1;

a2183 1
	  char *temp_string;
d2196 19
d2216 6
a2221 1
	  temp_string = base_string;
d2223 2
a2224 8
	  /* Skip past '(' and whitespace.  */
	  ++base_string;
	  if (is_space_char (*base_string))
	    ++base_string;

	  if (*base_string == ','
	      || ((*base_string == REGISTER_PREFIX || allow_naked_reg)
		  && (i.base_reg = parse_register (base_string, &end_op)) != NULL))
d2226 18
a2243 1
	      displacement_string_end = temp_string;
d2245 9
a2253 1
	      i.types[this_operand] |= BaseIndex;
d2255 7
a2261 1
	      if (i.base_reg)
d2263 2
a2264 3
		  base_string = end_op;
		  if (is_space_char (*base_string))
		    ++base_string;
d2266 2
d2269 7
a2275 2
	      /* There may be an index reg or scale factor here.  */
	      if (*base_string == ',')
d2277 28
a2304 51
		  ++base_string;
		  if (is_space_char (*base_string))
		    ++base_string;

		  if ((*base_string == REGISTER_PREFIX || allow_naked_reg)
		      && (i.index_reg = parse_register (base_string, &end_op)) != NULL)
		    {
		      base_string = end_op;
		      if (is_space_char (*base_string))
			++base_string;
		      if (*base_string == ',')
			{
			  ++base_string;
			  if (is_space_char (*base_string))
			    ++base_string;
			}
		      else if (*base_string != ')' )
			{
			  as_bad (_("expecting `,' or `)' after index register in `%s'"),
				  operand_string);
			  return 0;
			}
		    }
		  else if (*base_string == REGISTER_PREFIX)
		    {
		      as_bad (_("bad register name `%s'"), base_string);
		      return 0;
		    }

		  /* Check for scale factor. */
		  if (isdigit ((unsigned char) *base_string))
		    {
		      if (!i386_scale (base_string))
			return 0;

		      ++base_string;
		      if (is_space_char (*base_string))
			++base_string;
		      if (*base_string != ')')
			{
			  as_bad (_("expecting `)' after scale factor in `%s'"),
				  operand_string);
			  return 0;
			}
		    }
		  else if (!i.index_reg)
		    {
		      as_bad (_("expecting index register or scale factor after `,'; got '%c'"),
			      *base_string);
		      return 0;
		    }
d2306 4
a2309 1
	      else if (*base_string != ')')
d2311 2
a2312 2
		  as_bad (_("expecting `,' or `)' after base register in `%s'"),
			  operand_string);
d2316 101
a2416 1
	  else if (*base_string == REGISTER_PREFIX)
d2418 5
a2422 2
	      as_bad (_("bad register name `%s'"), base_string);
	      return 0;
d2426 3
a2428 4
      /* If there's an expression beginning the operand, parse it,
	 assuming displacement_string_start and
	 displacement_string_end are meaningful.  */
      if (displacement_string_start != displacement_string_end)
d2430 2
a2431 3
	  if (!i386_displacement (displacement_string_start,
				  displacement_string_end))
	    return 0;
d2433 6
a2438 8

      /* Special case for (%dx) while doing input/output op.  */
      if (i.base_reg
	  && i.base_reg->reg_type == (Reg16 | InOutPortReg)
	  && i.index_reg == 0
	  && i.log2_scale_factor == 0
	  && i.seg[i.mem_operands] == 0
	  && (i.types[this_operand] & Disp) == 0)
d2440 1
a2440 1
	  i.types[this_operand] = InOutPortReg;
d2443 11
a2453 4

      if (i386_index_check (operand_string) == 0)
	return 0;
      i.mem_operands++;
d2457 2
a2458 3
      as_bad (_("invalid char %s beginning operand %d `%s'"),
	      output_invalid (*op_string),
	      this_operand + 1,
d2465 12
a2476 13
/* md_estimate_size_before_relax()

   Called just before relax() for rs_machine_dependent frags.  The x86
   assembler uses these frags to handle variable size jump
   instructions.

   Any symbol that is now undefined will not become defined.
   Return the correct fr_subtype in the frag.
   Return the initial "guess for variable size of frag" to caller.
   The guess is actually the growth beyond the fixed part.  Whatever
   we do to grow the fixed or variable part contributes to our
   returned value.  */

d2482 8
a2489 10
  /* We've already got fragP->fr_subtype right;  all we have to do is
     check for un-relaxable symbols.  On an ELF system, we can't relax
     an externally visible symbol, because it may be overridden by a
     shared library.  */
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE)
      || S_IS_EXTERNAL (fragP->fr_symbol)
      || S_IS_WEAK (fragP->fr_symbol)
#endif
      )
d2491 1
a2491 21
      /* Symbol is undefined in this segment, or we need to keep a
	 reloc so that weak symbols can be overridden.  */
      int size = (fragP->fr_subtype & CODE16) ? 2 : 4;
#ifdef BFD_ASSEMBLER
      enum bfd_reloc_code_real reloc_type;
#else
      int reloc_type;
#endif
      unsigned char *opcode;
      int old_fr_fix;

      if (fragP->fr_var != NO_RELOC)
	reloc_type = fragP->fr_var;
      else if (size == 2)
	reloc_type = BFD_RELOC_16_PCREL;
      else
	reloc_type = BFD_RELOC_32_PCREL;

      old_fr_fix = fragP->fr_fix;
      opcode = (unsigned char *) fragP->fr_opcode;

d2496 3
a2498 3
	  fragP->fr_fix += size;
	  fix_new (fragP, old_fr_fix, size,
		   fragP->fr_symbol,
d2500 9
a2508 1
		   reloc_type);
d2512 2
a2513 2
	  /* This changes the byte-displacement jump 0x7N
	     to the dword-displacement jump 0x0f,0x8N.  */
d2515 3
a2517 3
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  fragP->fr_fix += 1 + size;	/* we've added an opcode byte */
	  fix_new (fragP, old_fr_fix + 1, size,
d2519 6
a2524 2
		   fragP->fr_offset, 1,
		   reloc_type);
a2527 1
      return fragP->fr_fix - old_fr_fix;
d2529 3
a2531 3
  return 1; /* Guess a short jump.  */
}

d2546 2
a2547 2
     object_headers *headers ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
d2552 2
a2553 2
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
d2569 1
a2569 1
  target_address += symbol_get_frag (fragP->fr_symbol)->fr_address;
d2580 2
a2581 4
    case ENCODE_RELAX_STATE (COND_JUMP, SMALL):
    case ENCODE_RELAX_STATE (COND_JUMP, SMALL16):
    case ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL):
    case ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL16):
d2587 6
a2592 5
    case ENCODE_RELAX_STATE (COND_JUMP, BIG):
      extension = 5;		/* 2 opcode + 4 displacement */
      opcode[1] = opcode[0] + 0x10;
      opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
      where_to_put_displacement = &opcode[2];
d2595 5
a2599 4
    case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG):
      extension = 4;		/* 1 opcode + 4 displacement */
      opcode[0] = 0xe9;
      where_to_put_displacement = &opcode[1];
d2602 1
a2602 2
    case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
      extension = 3;		/* 2 opcode + 2 displacement */
d2605 1
d2609 1
a2609 2
    case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16):
      extension = 2;		/* 1 opcode + 2 displacement */
d2611 1
d2635 2
a2636 2
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d2681 1
a2681 1
     segT seg ATTRIBUTE_UNUSED;	/* Segment fix is from.  */
d2687 5
a2691 27
  if (fixP->fx_pcrel)
    {
      switch (fixP->fx_r_type)
	{
	default:
	  break;

	case BFD_RELOC_32:
	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  break;
	case BFD_RELOC_16:
	  fixP->fx_r_type = BFD_RELOC_16_PCREL;
	  break;
	case BFD_RELOC_8:
	  fixP->fx_r_type = BFD_RELOC_8_PCREL;
	  break;
	}
    }

  /* This is a hack.  There should be a better way to handle this.
     This covers for the fact that bfd_install_relocation will
     subtract the current location (for partial_inplace, PC relative
     relocations); see more below.  */
  if ((fixP->fx_r_type == BFD_RELOC_32_PCREL
       || fixP->fx_r_type == BFD_RELOC_16_PCREL
       || fixP->fx_r_type == BFD_RELOC_8_PCREL)
      && fixP->fx_addsy)
d2694 1
a2694 5
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour
#ifdef TE_PE
	  || OUTPUT_FLAVOR == bfd_target_coff_flavour
#endif
	  )
d2698 3
a2700 1
      if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d2702 5
a2706 35
	  segT fseg = S_GET_SEGMENT (fixP->fx_addsy);

	  if ((fseg == seg
	       || (symbol_section_p (fixP->fx_addsy)
		   && fseg != absolute_section))
	      && ! S_IS_EXTERNAL (fixP->fx_addsy)
	      && ! S_IS_WEAK (fixP->fx_addsy)
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && ! S_IS_COMMON (fixP->fx_addsy))
	    {
	      /* Yes, we add the values in twice.  This is because
		 bfd_perform_relocation subtracts them out again.  I think
		 bfd_perform_relocation is broken, but I don't dare change
		 it.  FIXME.  */
	      value += fixP->fx_where + fixP->fx_frag->fr_address;
	    }
	}
#endif
#if defined (OBJ_COFF) && defined (TE_PE)
      /* For some reason, the PE format does not store a section
	 address offset for a PC relative symbol.  */
      if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
      else if (S_IS_EXTERNAL (fixP->fx_addsy)
	       || S_IS_WEAK (fixP->fx_addsy))
	{
	  /* We are generating an external relocation for this defined
             symbol.  We add the address, because
             bfd_install_relocation will subtract it.  VALUE already
             holds the symbol value, because fixup_segment added it
             in.  We subtract it out, and then we subtract it out
             again because bfd_install_relocation will add it in
             again.  */
	  value += md_pcrel_from (fixP);
	  value -= 2 * S_GET_VALUE (fixP->fx_addsy);
a2709 13
#ifdef TE_PE
  else if (fixP->fx_addsy != NULL
	   && S_IS_DEFINED (fixP->fx_addsy)
	   && (S_IS_EXTERNAL (fixP->fx_addsy)
	       || S_IS_WEAK (fixP->fx_addsy)))
    {
      /* We are generating an external relocation for this defined
         symbol.  VALUE already holds the symbol value, and
         bfd_install_relocation will add it in again.  We don't want
         either addition.  */
      value -= 2 * S_GET_VALUE (fixP->fx_addsy);
    }
#endif
d2716 1
a2716 1
    switch (fixP->fx_r_type) {
d2724 1
a2724 1
 *   This is tough to explain.  We end up with this one if we have
d2728 1
a2728 1
 * relocation for this.  The actual sequence of instructions often look
d2730 2
a2731 2
 *
 *	call	.L66
d2733 4
a2736 4
 *	popl	%ebx
 *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
 *
 *   The call and pop essentially return the absolute address of
d2745 2
a2746 2
 *
 *   Our job here is to fix the operand so that it would add the correct
d2751 3
a2753 3
 *
 *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
 *
d2755 1
a2755 1
 * we treat operands of this form as not being pcrel since the '.' is
d2764 1
a2764 1
      value = 0; /* Fully resolved at runtime.  No addend.  */
a2768 5
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return 1;

d2772 3
a2774 3
#endif /* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) */
  *valp = value;
#endif /* defined (BFD_ASSEMBLER) && !defined (TE_Mach) */
d2805 1
a2805 1
     int type;
d2833 1
a2833 1
      return _("Bad call to md_atof ()");
a2851 2
static char * output_invalid PARAMS ((int));

d2854 1
a2854 1
     int c;
d2863 3
a2865 5

/* REG_STRING starts *before* REGISTER_PREFIX.  */

static const reg_entry *
parse_register (reg_string, end_op)
a2866 1
     char **end_op;
d2868 3
a2870 8
  char *s = reg_string;
  char *p;
  char reg_name_given[MAX_REG_NAME_SIZE + 1];
  const reg_entry *r;

  /* Skip possible REGISTER_PREFIX and possible whitespace.  */
  if (*s == REGISTER_PREFIX)
    ++s;
d2872 2
a2873 5
  if (is_space_char (*s))
    ++s;

  p = reg_name_given;
  while ((*p++ = register_chars[(unsigned char) *s]) != '\0')
d2875 1
d2877 1
a2877 33
	return (const reg_entry *) NULL;
      s++;
    }

  *end_op = s;

  r = (const reg_entry *) hash_find (reg_hash, reg_name_given);

  /* Handle floating point regs, allowing spaces in the (i) part.  */
  if (r == i386_regtab /* %st is first entry of table */)
    {
      if (is_space_char (*s))
	++s;
      if (*s == '(')
	{
	  ++s;
	  if (is_space_char (*s))
	    ++s;
	  if (*s >= '0' && *s <= '7')
	    {
	      r = &i386_float_regtab[*s - '0'];
	      ++s;
	      if (is_space_char (*s))
		++s;
	      if (*s == ')')
		{
		  *end_op = s + 1;
		  return r;
		}
	    }
	  /* We have "%st(" then garbage */
	  return (const reg_entry *) NULL;
	}
d2879 2
a2880 2

  return r;
d2883 2
a2884 2
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
CONST char *md_shortopts = "kmVQ:sq";
d2891 1
a2891 1
size_t md_longopts_size = sizeof (md_longopts);
d2896 1
a2896 1
     char *arg ATTRIBUTE_UNUSED;
a2917 10

    case 's':
      /* -s: On i386 Solaris, this tells the native assembler to use
         .stab instead of .stab.excl.  We always use .stab anyhow.  */
      break;

    case 'q':
      /* -q: On i386 Solaris, this tells the native assembler does
         fewer checks.  */
      break;
d2930 2
a2931 10
  fprintf (stream, _("\
  -m			  do long jump\n"));
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  fprintf (stream, _("\
  -V			  print assembler version number\n\
  -k			  ignored\n\
  -Qy, -Qn		  ignored\n\
  -q			  ignored\n\
  -s			  ignored\n"));
#endif
d2935 2
a2936 3
#if ((defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_COFF)) \
     || (defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_AOUT)) \
     || (defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)))
a2944 5
#ifdef OBJ_MAYBE_AOUT
    case bfd_target_aout_flavour:
     return AOUT_TARGET_FORMAT;
#endif
#ifdef OBJ_MAYBE_COFF
a2946 2
#endif
#ifdef OBJ_MAYBE_ELF
a2948 1
#endif
d2955 2
a2956 1
#endif /* OBJ_MAYBE_ more than one */
d2959 1
d2964 12
a2975 14
  if (name[0] == GLOBAL_OFFSET_TABLE_NAME[0]
      && name[1] == GLOBAL_OFFSET_TABLE_NAME[1]
      && name[2] == GLOBAL_OFFSET_TABLE_NAME[2]
      && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad (_("GOT already in symbol table"));
	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, &zero_address_frag);
	};
      return GOT_symbol;
    }
d2982 1
a2982 1
     segT segment ATTRIBUTE_UNUSED;
d2985 1
d2987 6
a2992 9
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
    {
      /* For a.out, force the section size to be aligned.  If we don't do
	 this, BFD will align it for us, but it will not write out the
	 final bytes of the section.  This may be a bug in BFD, but it is
	 easier to fix it here since that is how the other a.out targets
	 work.  */
      int align;
d2994 2
a2995 3
      align = bfd_get_section_alignment (stdoutput, segment);
      size = ((size + (1 << align) - 1) & ((valueT) -1 << align));
    }
d3002 3
a3004 4
/* On the i386, PC-relative offsets are relative to the start of the
   next instruction.  That is, the address of the offset, plus its
   size, since the offset is always the last part of the insn.  */

d3016 1
a3016 1
     int ignore ATTRIBUTE_UNUSED;
d3041 3
d3046 1
a3046 1
     asection *section ATTRIBUTE_UNUSED;
d3052 1
a3052 1
  switch (fixp->fx_r_type)
a3057 3
    case BFD_RELOC_RVA:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
d3061 1
a3061 1
      if (fixp->fx_pcrel)
d3063 9
a3071 24
	  switch (fixp->fx_size)
	    {
	    default:
	      as_bad (_("can not do %d byte pc-relative relocation"),
		      fixp->fx_size);
	      code = BFD_RELOC_32_PCREL;
	      break;
	    case 1: code = BFD_RELOC_8_PCREL;  break;
	    case 2: code = BFD_RELOC_16_PCREL; break;
	    case 4: code = BFD_RELOC_32_PCREL; break;
	    }
	}
      else
	{
	  switch (fixp->fx_size)
	    {
	    default:
	      as_bad (_("can not do %d byte relocation"), fixp->fx_size);
	      code = BFD_RELOC_32;
	      break;
	    case 1: code = BFD_RELOC_8;  break;
	    case 2: code = BFD_RELOC_16; break;
	    case 4: code = BFD_RELOC_32; break;
	    }
a3072 1
      break;
d3074 2
d3083 1
a3083 3
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);

a3084 5
  /* HACK: Since i386 ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    rel->address = fixp->fx_offset;

d3094 1
a3094 1
		    _("cannot represent relocation type %s"),
d3172 1
a3172 1
#endif /* ! BFD_ASSEMBLER */
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 3
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
   Free Software Foundation, Inc.
d22 6
a27 5
/* Intel 80386 machine specific gas.
   Written by Eliot Dresselhaus (eliot@@mgm.mit.edu).
   x86_64 support by Jan Hubicka (jh@@suse.cz)
   Bugs & suggestions are completely welcome.  This is free software.
   Please help us make it better.  */
a32 1
#include "dwarf2dbg.h"
d55 5
a59 8
static int fits_in_signed_byte PARAMS ((offsetT));
static int fits_in_unsigned_byte PARAMS ((offsetT));
static int fits_in_unsigned_word PARAMS ((offsetT));
static int fits_in_signed_word PARAMS ((offsetT));
static int fits_in_unsigned_long PARAMS ((offsetT));
static int fits_in_signed_long PARAMS ((offsetT));
static int smallest_imm_type PARAMS ((offsetT));
static offsetT offset_in_range PARAMS ((offsetT, int));
d61 2
a62 2
static void set_code_flag PARAMS ((int));
static void set_16bit_gcc_code_flag PARAMS ((int));
a63 1
static void set_cpu_arch PARAMS ((int));
d67 1
a67 8
  PARAMS ((int, int, int, bfd_reloc_code_real_type));
#define RELOC_ENUM enum bfd_reloc_code_real
#else
#define RELOC_ENUM int
#endif

#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "i386"
a68 1
static char *default_arch = DEFAULT_ARCH;
d71 1
a71 1
   i386_insn.  */
d82 1
a82 1
    /* TM holds the template for the insn were currently assembling.  */
d89 1
a89 1
    /* OPERANDS gives the number of given operands.  */
d94 1
a94 1
       operands.  */
a104 4
    /* Flags for operands.  */
    unsigned int flags[MAX_OPERANDS];
#define Operand_PCrel 1

d106 5
a110 1
    RELOC_ENUM reloc[MAX_OPERANDS];
d119 2
a120 2
       explicit segment overrides are given.  */
    const seg_entry *seg[2];
a130 1
    rex_byte rex;
d145 2
a146 2
   pre-processor is disabled, these aren't very useful.  */
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD))
d158 2
a159 2
   .line and .file directives will appear in the pre-processed output.
   Note that input_file.c hand checks for '#' at the beginning of the
d161 2
a162 2
   #NO_APP at the beginning of its output.
   Also note that comments started like this one will always work if
d164 1
a164 1
#if defined (TE_I386AIX) || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)) && ! defined (TE_LINUX) && !defined(TE_FreeBSD))
d170 1
a170 1
const char line_separator_chars[] = ";";
d172 1
a172 2
/* Chars that can be used to separate mant from exp in floating point
   nums.  */
d175 3
a177 3
/* Chars that mean this number is a floating point constant
   As in 0f12.456
   or    0d1.2345e12.  */
d180 1
a180 1
/* Tables for lexical analysis.  */
d187 1
a187 1
/* Lexical macros.  */
d195 1
a195 1
/* All non-digit non-letter charcters that may occur in an operand.  */
d201 1
a201 1
   assembler instruction).  */
d203 1
a203 1
static char *save_stack_p;
d209 1
a209 1
/* The instruction we're assembling.  */
d215 1
a215 1
/* Per instruction expressionS buffers: 2 displacements & 2 immediate max.  */
d218 1
a218 2
/* Current operand we are working on.  */
static int this_operand;
d220 1
a220 2
/* We support four different modes.  FLAG_CODE variable is used to distinguish
   these.  */
d222 1
a222 5
enum flag_code {
	CODE_32BIT,
	CODE_16BIT,
	CODE_64BIT };
#define NUM_FLAG_CODE ((int) CODE_64BIT + 1)
d224 1
a224 2
static enum flag_code flag_code;
static int use_rela_relocations = 0;
d226 1
a226 7
/* The names used to print error messages.  */
static const char *flag_code_names[] =
  {
    "32",
    "16",
    "64"
  };
d228 4
a231 24
/* 1 for intel syntax,
   0 if att syntax.  */
static int intel_syntax = 0;

/* 1 if register prefix % not required.  */
static int allow_naked_reg = 0;

/* Used in 16 bit gcc mode to add an l suffix to call, ret, enter,
   leave, push, and pop instructions so that gcc has the same stack
   frame as in 32 bit mode.  */
static char stackop_size = '\0';

/* Non-zero to quieten some warnings.  */
static int quiet_warnings = 0;

/* CPU name.  */
static const char *cpu_arch_name = NULL;

/* CPU feature flags.  */
static unsigned int cpu_arch_flags = CpuUnknownFlags|CpuNo64;

/* If set, conditional jumps are not automatically promoted to handle
   larger than a byte offset.  */
static unsigned int no_cond_jump_promotion = 0;
d234 9
a242 10
   There are 3 major relax states for 386 jump insns because the
   different types of jumps add different sizes to frags when we're
   figuring out what sort of jump to choose to reach a given label.  */

/* Types.  */
#define UNCOND_JUMP 0
#define COND_JUMP 1
#define COND_JUMP86 2

/* Sizes.  */
d257 4
a260 6
#define ENCODE_RELAX_STATE(type, size) \
  ((relax_substateT) (((type) << 2) | (size)))
#define TYPE_FROM_RELAX_STATE(s) \
  ((s) >> 2)
#define DISP_SIZE_FROM_RELAX_STATE(s) \
    ((((s) & 3) == BIG ? 4 : (((s) & 3) == BIG16 ? 2 : 1)))
d275 12
a286 8
     3) how many bytes this mode will have in the variable part of the frag
     4) which index into the table to try if we can't fit into this one.  */

  /* UNCOND_JUMP states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16)},
  /* dword jmp adds 4 bytes to frag:
     0 extra opcode bytes, 4 displacement bytes.  */
d288 2
a289 2
  /* word jmp adds 2 byte2 to frag:
     0 extra opcode bytes, 2 displacement bytes.  */
d292 4
a295 8
  /* COND_JUMP states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP, BIG16)},
  /* dword conditionals adds 5 bytes to frag:
     1 extra opcode byte, 4 displacement bytes.  */
  {0, 0, 5, 0},
  /* word conditionals add 3 bytes to frag:
     1 extra opcode byte, 2 displacement bytes.  */
d297 3
a300 9
  /* COND_JUMP86 states.  */
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG)},
  {127 + 1, -128 + 1, 1, ENCODE_RELAX_STATE (COND_JUMP86, BIG16)},
  /* dword conditionals adds 5 bytes to frag:
     1 extra opcode byte, 4 displacement bytes.  */
  {0, 0, 5, 0},
  /* word conditionals add 4 bytes to frag:
     1 displacement byte and a 3 byte long branch insn.  */
  {0, 0, 4, 0}
a302 16
static const arch_entry cpu_arch[] = {
  {"i8086",	Cpu086 },
  {"i186",	Cpu086|Cpu186 },
  {"i286",	Cpu086|Cpu186|Cpu286 },
  {"i386",	Cpu086|Cpu186|Cpu286|Cpu386 },
  {"i486",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486 },
  {"i586",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuMMX },
  {"i686",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuSSE },
  {"pentium",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuMMX },
  {"pentiumpro",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuMMX|CpuSSE },
  {"pentium4",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuMMX|CpuSSE|CpuSSE2 },
  {"k6",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|CpuK6|CpuMMX|Cpu3dnow },
  {"athlon",	Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuMMX|Cpu3dnow },
  {"sledgehammer",Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuK6|CpuAthlon|CpuSledgehammer|CpuMMX|Cpu3dnow|CpuSSE|CpuSSE2 },
  {NULL, 0 }
};
d309 3
a311 3
  /* Various efficient no-op patterns for aligning code labels.
     Note: Don't try to assemble the instructions in the comments.
     0L and 0w are not legal.  */
a375 5
  /* ??? We can't use these fillers for x86_64, since they often kills the
     upper halves.  Solve later.  */
  if (flag_code == CODE_64BIT)
    count = 1;

d378 1
a378 1
      if (flag_code == CODE_16BIT)
d380 3
a382 4
	  memcpy (fragP->fr_literal + fragP->fr_fix,
		  f16_patt[count - 1], count);
	  if (count > 8)
	    /* Adjust jump offset.  */
d386 2
a387 2
	memcpy (fragP->fr_literal + fragP->fr_fix,
		f32_patt[count - 1], count);
d402 1
a402 1
symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
d408 1
a408 1
  return (t & Disp8) ? 1 : (t & (Disp16 | Disp32 | Disp32S)) ? 2 : 0;
d413 1
a413 1
     offsetT num;
d416 1
a416 1
}
d420 1
a420 1
     offsetT num;
d423 1
a423 1
}
d427 1
a427 1
     offsetT num;
d430 1
a430 1
}
d434 1
a434 1
     offsetT num;
d437 1
a437 22
}
static INLINE int
fits_in_signed_long (num)
     offsetT num ATTRIBUTE_UNUSED;
{
#ifndef BFD64
  return 1;
#else
  return (!(((offsetT) -1 << 31) & num)
	  || (((offsetT) -1 << 31) & num) == ((offsetT) -1 << 31));
#endif
}				/* fits_in_signed_long() */
static INLINE int
fits_in_unsigned_long (num)
     offsetT num ATTRIBUTE_UNUSED;
{
#ifndef BFD64
  return 1;
#else
  return (num & (((offsetT) 2 << 31) - 1)) == num;
#endif
}				/* fits_in_unsigned_long() */
d441 1
a441 1
     offsetT num;
d443 10
a452 11
  if (cpu_arch_flags != (Cpu086 | Cpu186 | Cpu286 | Cpu386 | Cpu486 | CpuNo64)
      && !(cpu_arch_flags & (CpuUnknown)))
    {
      /* This code is disabled on the 486 because all the Imm1 forms
	 in the opcode table are slower on the i486.  They're the
	 versions with the implicitly specified single-position
	 displacement, which has another syntax if you really want to
	 use that form.  */
      if (num == 1)
	return Imm1 | Imm8 | Imm8S | Imm16 | Imm32 | Imm32S | Imm64;
    }
d454 1
a454 1
	  ? (Imm8S | Imm8 | Imm16 | Imm32 | Imm32S | Imm64)
d456 1
a456 1
	  ? (Imm8 | Imm16 | Imm32 | Imm32S | Imm64)
d458 3
a460 41
	  ? (Imm16 | Imm32 | Imm32S | Imm64)
	  : fits_in_signed_long (num)
	  ? (Imm32 | Imm32S | Imm64)
	  : fits_in_unsigned_long (num)
	  ? (Imm32 | Imm64)
	  : Imm64);
}

static offsetT
offset_in_range (val, size)
     offsetT val;
     int size;
{
  addressT mask;

  switch (size)
    {
    case 1: mask = ((addressT) 1 <<  8) - 1; break;
    case 2: mask = ((addressT) 1 << 16) - 1; break;
    case 4: mask = ((addressT) 2 << 31) - 1; break;
#ifdef BFD64
    case 8: mask = ((addressT) 2 << 63) - 1; break;
#endif
    default: abort ();
    }

  /* If BFD64, sign extend val.  */
  if (!use_rela_relocations)
    if ((val & ~(((addressT) 2 << 31) - 1)) == 0)
      val = (val ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);

  if ((val & ~mask) != 0 && (val & ~mask) != ~mask)
    {
      char buf1[40], buf2[40];

      sprint_value (buf1, val);
      sprint_value (buf2, val & mask);
      as_warn (_("%s shortened to %s"), buf1, buf2);
    }
  return val & mask;
}
d472 29
a500 7
  if (prefix >= 0x40 && prefix < 0x50 && flag_code == CODE_64BIT)
    q = REX_PREFIX;
  else
    switch (prefix)
      {
      default:
	abort ();
d502 4
a505 29
      case CS_PREFIX_OPCODE:
      case DS_PREFIX_OPCODE:
      case ES_PREFIX_OPCODE:
      case FS_PREFIX_OPCODE:
      case GS_PREFIX_OPCODE:
      case SS_PREFIX_OPCODE:
	q = SEG_PREFIX;
	break;

      case REPNE_PREFIX_OPCODE:
      case REPE_PREFIX_OPCODE:
	ret = 2;
	/* fall thru */
      case LOCK_PREFIX_OPCODE:
	q = LOCKREP_PREFIX;
	break;

      case FWAIT_OPCODE:
	q = WAIT_PREFIX;
	break;

      case ADDR_PREFIX_OPCODE:
	q = ADDR_PREFIX;
	break;

      case DATA_PREFIX_OPCODE:
	q = DATA_PREFIX;
	break;
      }
d519 2
a520 2
set_code_flag (value)
     int value;
d522 1
a522 11
  flag_code = value;
  cpu_arch_flags &= ~(Cpu64 | CpuNo64);
  cpu_arch_flags |= (flag_code == CODE_64BIT ? Cpu64 : CpuNo64);
  if (value == CODE_64BIT && !(cpu_arch_flags & CpuSledgehammer))
    {
      as_bad (_("64bit mode not supported on this CPU."));
    }
  if (value == CODE_32BIT && !(cpu_arch_flags & Cpu386))
    {
      as_bad (_("32bit mode not supported on this CPU."));
    }
d527 2
a528 2
set_16bit_gcc_code_flag (new_code_flag)
     int new_code_flag;
d530 2
a531 4
  flag_code = new_code_flag;
  cpu_arch_flags &= ~(Cpu64 | CpuNo64);
  cpu_arch_flags |= (flag_code == CODE_64BIT ? Cpu64 : CpuNo64);
  stackop_size = 'l';
d547 1
a547 1
      if (strcmp (string, "prefix") == 0)
d549 1
a549 1
      else if (strcmp (string, "noprefix") == 0)
d565 1
a565 2
      /* Conservative default.  */
      allow_naked_reg = 0;
a571 50
static void
set_cpu_arch (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  SKIP_WHITESPACE ();

  if (! is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *string = input_line_pointer;
      int e = get_symbol_end ();
      int i;

      for (i = 0; cpu_arch[i].name; i++)
	{
	  if (strcmp (string, cpu_arch[i].name) == 0)
	    {
	      cpu_arch_name = cpu_arch[i].name;
	      cpu_arch_flags = (cpu_arch[i].flags
				| (flag_code == CODE_64BIT ? Cpu64 : CpuNo64));
	      break;
	    }
	}
      if (!cpu_arch[i].name)
	as_bad (_("no such architecture: `%s'"), string);

      *input_line_pointer = e;
    }
  else
    as_bad (_("missing cpu architecture"));

  no_cond_jump_promotion = 0;
  if (*input_line_pointer == ','
      && ! is_end_of_line[(unsigned char) input_line_pointer[1]])
    {
      char *string = ++input_line_pointer;
      int e = get_symbol_end ();

      if (strcmp (string, "nojumps") == 0)
	no_cond_jump_promotion = 1;
      else if (strcmp (string, "jumps") == 0)
	;
      else
	as_bad (_("no such architecture modifier: `%s'"), string);

      *input_line_pointer = e;
    }

  demand_empty_rest_of_line ();
}

d574 3
a581 4
  {"arch", set_cpu_arch, 0},
#ifndef I386COFF
  {"bss", s_bss, 0},
#endif
d588 3
a590 4
  {"code16gcc", set_16bit_gcc_code_flag, CODE_16BIT},
  {"code16", set_code_flag, CODE_16BIT},
  {"code32", set_code_flag, CODE_32BIT},
  {"code64", set_code_flag, CODE_64BIT},
a592 2
  {"file", dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
d596 1
a596 1
/* For interface with expression ().  */
d599 1
a599 1
/* Hash table for instruction mnemonic lookup.  */
d601 1
a601 2

/* Hash table for register lookup.  */
d604 1
a604 13
#ifdef BFD_ASSEMBLER
unsigned long
i386_mach ()
{
  if (!strcmp (default_arch, "x86_64"))
    return bfd_mach_x86_64;
  else if (!strcmp (default_arch, "i386"))
    return bfd_mach_i386_i386;
  else
    as_fatal (_("Unknown architecture"));
}
#endif

d610 1
a610 1
  /* Initialize op_hash hash table.  */
d617 1
a617 2
    /* Setup for loop.  */
    optab = i386_optab;
d628 1
a628 1
	       add to hash table; & begin anew.  */
d635 1
d648 1
a648 1
  /* Initialize reg_hash hash table.  */
d659 1
a659 3
	  as_fatal (_("Internal Error:  Can't hash %s: %s"),
		    regtab->reg_name,
		    hash_err);
d663 1
a663 1
  /* Fill in lexical tables:  mnemonic_chars, operand_chars.  */
d728 1
d731 1
a731 1
/* Debugging routines for md_assemble.  */
d743 2
a744 1
  unsigned int i;
d748 1
a748 5
  fprintf (stdout, "  address: base %s  index %s  scale %x\n",
	   x->base_reg ? x->base_reg->reg_name : "none",
	   x->index_reg ? x->index_reg->reg_name : "none",
	   x->log2_scale_factor);
  fprintf (stdout, "  modrm:  mode %x  reg %x  reg/mem %x\n",
d750 2
a751 4
  fprintf (stdout, "  sib:  base %x  index %x  scale %x\n",
	   x->sib.base, x->sib.index, x->sib.scale);
  fprintf (stdout, "  rex: 64bit %x  extX %x  extY %x  extZ %x\n",
	   x->rex.mode64, x->rex.extX, x->rex.extY, x->rex.extZ);
d771 1
a771 1
  unsigned int i;
d773 2
a774 1
  fprintf (stdout, "opcode %x ", t->base_opcode);
a831 1
  { Reg64, "r64" },
a835 2
  { Imm32S, "i32s" },
  { Imm64, "i64" },
a840 2
  { Disp32S, "d32s" },
  { Disp64, "d64" },
d864 10
a873 3
  for (ty = type_names; ty->mask; ty++)
    if (t & ty->mask)
      fprintf (stdout, "%s, ", ty->tname);
d889 1
a889 1
  /* For COFF.  */
d895 2
d899 1
a899 1
reloc (size, pcrel, sign, other)
a901 1
     int sign;
d904 1
a904 2
  if (other != NO_RELOC)
    return other;
a907 2
      if (!sign)
	as_bad (_("There are no unsigned pc-relative relocations"));
d918 7
a924 15
      if (sign)
	switch (size)
	  {
	  case 4: return BFD_RELOC_X86_64_32S;
	  }
      else
	switch (size)
	  {
	  case 1: return BFD_RELOC_8;
	  case 2: return BFD_RELOC_16;
	  case 4: return BFD_RELOC_32;
	  case 8: return BFD_RELOC_64;
	  }
      as_bad (_("can not do %s %d byte relocation"),
	      sign ? "signed" : "unsigned", size);
a926 1
  abort ();
d930 6
a935 5
/* Here we decide which fixups can be adjusted to make them relative to
   the beginning of the section instead of the symbol.  Basically we need
   to make sure that the dynamic relocations are done correctly, so in
   some cases we force the original symbol to be used.  */

d940 1
a940 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
d947 1
a947 1
  /* adjust_reloc_syms doesn't know about the GOT.  */
d951 1
a951 3
      || fixP->fx_r_type == BFD_RELOC_X86_64_PLT32
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOT32
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTPCREL
d958 8
a965 11
#define reloc(SIZE,PCREL,SIGN,OTHER)	0
#define BFD_RELOC_16			0
#define BFD_RELOC_32			0
#define BFD_RELOC_16_PCREL		0
#define BFD_RELOC_32_PCREL		0
#define BFD_RELOC_386_PLT32		0
#define BFD_RELOC_386_GOT32		0
#define BFD_RELOC_386_GOTOFF		0
#define BFD_RELOC_X86_64_PLT32		0
#define BFD_RELOC_X86_64_GOT32		0
#define BFD_RELOC_X86_64_GOTPCREL	0
d968 2
a969 1
static int intel_float_operand PARAMS ((char *mnemonic));
d975 1
a975 1
  if (mnemonic[0] == 'f' && mnemonic[1] == 'i')
d992 1
a992 1
  /* Points to template once we've found it.  */
d995 3
d1002 1
a1002 1
  /* Initialize globals.  */
d1005 1
a1005 1
    i.reloc[j] = NO_RELOC;
d1008 1
a1008 1
  save_stack_p = save_stack;
d1012 1
a1012 1
     start of a (possibly prefixed) mnemonic.  */
d1018 1
a1018 1
    /* Non-zero if we found a prefix only acceptable with string insns.  */
d1029 1
a1029 1
		as_bad (_("no such instruction: `%s'"), token_start);
d1063 1
a1063 1
		    ^ (flag_code == CODE_16BIT)))
d1075 2
a1076 1
		expecting_string_instruction = current_templates->start->name;
d1093 2
a1094 1
	  case QWORD_MNEM_SUFFIX:
a1098 9
	  case SHORT_MNEM_SUFFIX:
	  case LONG_MNEM_SUFFIX:
	    if (!intel_syntax)
	      {
		i.suffix = mnem_p[-1];
		mnem_p[-1] = '\0';
		current_templates = hash_find (op_hash, mnemonic);
	      }
	    break;
d1100 2
a1101 2
	  /* Intel Syntax.  */
	  case 'd':
d1104 1
a1104 4
		if (intel_float_operand (mnemonic))
		  i.suffix = SHORT_MNEM_SUFFIX;
		else
		  i.suffix = LONG_MNEM_SUFFIX;
d1107 1
a1108 1
	    break;
d1112 1
a1112 1
	    as_bad (_("no such instruction: `%s'"), token_start);
d1117 1
a1117 16
    /* Check if instruction is supported on specified architecture.  */
    if (cpu_arch_flags != 0)
      {
	if ((current_templates->start->cpu_flags & ~(Cpu64 | CpuNo64))
	    & ~(cpu_arch_flags & ~(Cpu64 | CpuNo64)))
	  {
	    as_warn (_("`%s' is not supported on `%s'"),
		     current_templates->start->name, cpu_arch_name);
	  }
	else if ((Cpu386 & ~cpu_arch_flags) && (flag_code != CODE_16BIT))
	  {
	    as_warn (_("use .code16 to ensure correct addressing mode"));
	  }
      }

    /* Check for rep/repne without a string instruction.  */
d1126 1
a1126 1
    /* There may be operands to parse.  */
d1129 3
a1131 1
	/* 1 if operand is pending after ','.  */
d1134 1
a1134 1
	/* Non-zero if operand parens not balanced.  */
d1139 1
a1139 1
	    /* Skip optional white space before operand.  */
d1192 1
a1192 1
	      {			/* Yes, we've read in another operand.  */
d1201 1
a1201 1
		/* Now parse operand adding info to 'i' as we go along.  */
d1205 1
a1205 3
		  operand_ok =
		    i386_intel_operand (token_start,
					intel_float_operand (mnemonic));
d1209 1
a1209 1
		RESTORE_END_STRING (l);
d1228 1
a1228 1
	    /* Now *l must be either ',' or END_OF_INSN.  */
d1232 1
a1232 2
		  {
		    /* Just skip it, if it's \n complain.  */
d1238 1
a1238 1
	while (*l != END_OF_INSN);
d1247 1
a1247 1
     with the template operand types.  */
a1278 1
	RELOC_ENUM temp_reloc;
a1297 3
	temp_reloc = i.reloc[xchg2];
	i.reloc[xchg2] = i.reloc[xchg1];
	i.reloc[xchg1] = temp_reloc;
d1323 1
a1323 1
	    for (op = i.operands; --op >= 0;)
a1329 4
		  else if (i.types[op] & Reg32)
		    guess_suffix = LONG_MNEM_SUFFIX;
		  else if (i.types[op] & Reg64)
		    guess_suffix = QWORD_MNEM_SUFFIX;
d1333 1
a1333 1
	else if ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0))
d1336 3
a1338 2
	for (op = i.operands; --op >= 0;)
	  if (i.types[op] & Imm)
d1340 2
a1341 1
	      switch (i.op[op].imms->X_op)
d1343 6
a1348 61
		  case O_constant:
		    /* If a suffix is given, this operand may be shortened.  */
		    switch (guess_suffix)
		      {
		      case LONG_MNEM_SUFFIX:
			i.types[op] |= Imm32 | Imm64;
			break;
		      case WORD_MNEM_SUFFIX:
			i.types[op] |= Imm16 | Imm32S | Imm32 | Imm64;
			break;
		      case BYTE_MNEM_SUFFIX:
			i.types[op] |= Imm16 | Imm8 | Imm8S | Imm32S | Imm32 | Imm64;
			break;
		      }

		    /* If this operand is at most 16 bits, convert it
		       to a signed 16 bit number before trying to see
		       whether it will fit in an even smaller size.
		       This allows a 16-bit operand such as $0xffe0 to
		       be recognised as within Imm8S range.  */
		    if ((i.types[op] & Imm16)
			&& (i.op[op].imms->X_add_number & ~(offsetT) 0xffff) == 0)
		      {
			i.op[op].imms->X_add_number =
			  (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
		      }
		    if ((i.types[op] & Imm32)
			&& (i.op[op].imms->X_add_number & ~(((offsetT) 2 << 31) - 1)) == 0)
		      {
			i.op[op].imms->X_add_number =
			  (i.op[op].imms->X_add_number ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
		      }
		    i.types[op] |= smallest_imm_type (i.op[op].imms->X_add_number);
		    /* We must avoid matching of Imm32 templates when 64bit only immediate is available.  */
		    if (guess_suffix == QWORD_MNEM_SUFFIX)
		      i.types[op] &= ~Imm32;
		    break;
		  case O_absent:
		  case O_register:
		    abort ();
		  /* Symbols and expressions.  */
		  default:
		    /* Convert symbolic operand to proper sizes for matching.  */
		    switch (guess_suffix)
		      {
		        case QWORD_MNEM_SUFFIX:
			  i.types[op] = Imm64 | Imm32S;
			  break;
		        case LONG_MNEM_SUFFIX:
			  i.types[op] = Imm32 | Imm64;
			  break;
		        case WORD_MNEM_SUFFIX:
			  i.types[op] = Imm16 | Imm32 | Imm64;
			  break;
			  break;
		        case BYTE_MNEM_SUFFIX:
			  i.types[op] = Imm8 | Imm8S | Imm16 | Imm32S | Imm32;
				break;
			  break;
		      }
		    break;
a1349 7
	    }
      }

    if (i.disp_operands)
      {
	/* Try to use the smallest displacement type too.  */
	int op;
d1351 6
a1356 24
	for (op = i.operands; --op >= 0;)
	  if ((i.types[op] & Disp)
	      && i.op[op].disps->X_op == O_constant)
	    {
	      offsetT disp = i.op[op].disps->X_add_number;

	      if (i.types[op] & Disp16)
		{
		  /* We know this operand is at most 16 bits, so
		     convert to a signed 16 bit number before trying
		     to see whether it will fit in an even smaller
		     size.  */

		  disp = (((disp & 0xffff) ^ 0x8000) - 0x8000);
		}
	      else if (i.types[op] & Disp32)
		{
		  /* We know this operand is at most 32 bits, so convert to a
		     signed 32 bit number before trying to see whether it will
		     fit in an even smaller size.  */
		  disp &= (((offsetT) 2 << 31) - 1);
		  disp = (disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
		}
	      if (flag_code == CODE_64BIT)
d1358 2
a1359 4
		  if (fits_in_signed_long (disp))
		    i.types[op] |= Disp32S;
		  if (fits_in_unsigned_long (disp))
		    i.types[op] |= Disp32;
d1361 1
a1361 3
	      if ((i.types[op] & (Disp32 | Disp32S | Disp16))
		  && fits_in_signed_byte (disp))
		i.types[op] |= Disp8;
d1377 2
a1378 2
			     : (i.suffix == QWORD_MNEM_SUFFIX
				? No_qSuf
d1385 1
a1385 1
	/* Must have right number of operands.  */
a1391 2
		 && (t->opcode_modifier & IgnoreSize))
	    && !(intel_syntax
d1393 2
a1394 2
		 && (t->extension_opcode == 5	     /* 0xd9,5 "fldcw"  */
		     || t->extension_opcode == 7)))  /* 0xd9,7 "f{n}stcw"  */
a1396 1
	/* Do not verify operands when there are none.  */
d1398 1
a1398 6
	  {
	    if (t->cpu_flags & ~cpu_arch_flags)
	      continue;
	    /* We've found a match; break out of loop.  */
	    break;
	  }
d1417 2
a1418 1
		/* Check if other direction is valid ...  */
d1422 1
a1422 1
		/* Try reversing direction of operands.  */
d1432 1
a1432 1
		    /* Does not match either direction.  */
d1438 1
d1440 2
a1441 2
	    /* Found a forward 2 operand match here.  */
	    else if (t->operands == 3)
d1456 2
a1457 7
	    /* Found either forward/reverse 2 or 3 operand match here:
	       slip through to break.  */
	  }
	if (t->cpu_flags & ~cpu_arch_flags)
	  {
	    found_reverse_match = 0;
	    continue;
d1459 2
a1460 3
	/* We've found a match; break out of loop.  */
	break;
      }
d1462 1
a1462 2
      {
	/* We found no match.  */
d1468 2
a1469 1
    if (!quiet_warnings)
d1471 2
a1472 6
	if (!intel_syntax
	    && ((i.types[0] & JumpAbsolute)
		!= (t->operand_types[0] & JumpAbsolute)))
	  {
	    as_warn (_("indirect %s without `*'"), t->name);
	  }
d1474 5
a1478 7
	if ((t->opcode_modifier & (IsPrefix|IgnoreSize))
	    == (IsPrefix|IgnoreSize))
	  {
	    /* Warn them that a data or address size prefix doesn't
	       affect assembly of the next line of code.  */
	    as_warn (_("stand-alone `%s' prefix"), t->name);
	  }
d1496 4
a1499 4
    if (SYSV386_COMPAT
	&& intel_syntax
	&& (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
      i.tm.base_opcode ^= FloatR;
d1505 1
a1505 1
    /* Check string instruction segment overrides.  */
a1535 13
    if (i.reg_operands && flag_code < CODE_64BIT)
      {
	int op;
	for (op = i.operands; --op >= 0;)
	  if ((i.types[op] & Reg)
	      && (i.op[op].regs->reg_flags & (RegRex64|RegRex)))
	    {
	      as_bad (_("Extended register `%%%s' available only in 64bit mode."),
		      i.op[op].regs->reg_name);
	      return;
	    }
      }

d1538 1
a1538 1
    if (i.tm.opcode_modifier & (Size16 | Size32 | Size64))
a1541 2
	else if (i.tm.opcode_modifier & Size64)
	  i.suffix = QWORD_MNEM_SUFFIX;
d1548 1
a1548 1
	   based on register operands.  */
d1555 1
a1555 1
	    for (op = i.operands; --op >= 0;)
a1560 1
			      (i.types[op] & Reg64) ? QWORD_MNEM_SUFFIX :
d1568 1
a1568 1
	    for (op = i.operands; --op >= 0;)
d1572 1
a1572 1
		   we will just use the low portion, and that's OK too.  */
d1576 1
a1576 1
		/* movzx and movsx should not generate this warning.  */
a1579 1
			|| i.tm.base_opcode == 0x63
a1592 7
		    /* Prohibit these changes in the 64bit mode, since
		       the lowering is more complicated.  */
		    if (flag_code == CODE_64BIT
			&& (i.tm.operand_types[op] & InOutPortReg) == 0)
		      as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			      i.op[op].regs->reg_name,
			      i.suffix);
d1594 1
a1594 2
		    if (!quiet_warnings
			&& (i.tm.operand_types[op] & InOutPortReg) == 0)
d1596 1
a1596 4
			       (i.op[op].regs
				+ (i.types[op] & Reg16
				   ? REGNAM_AL - REGNAM_AX
				   : REGNAM_AL - REGNAM_EAX))->reg_name,
d1602 1
a1602 1
		/* Any other register is bad.  */
a1618 45

	    for (op = i.operands; --op >= 0;)
	      /* Reject eight bit registers, except where the template
		 requires them. (eg. movzb)  */
	      if ((i.types[op] & Reg8) != 0
		  && (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
		{
		  as_bad (_("`%%%s' not allowed with `%s%c'"),
			  i.op[op].regs->reg_name,
			  i.tm.name,
			  i.suffix);
		  return;
		}
	      /* Warn if the e prefix on a general reg is missing.  */
	      else if ((!quiet_warnings || flag_code == CODE_64BIT)
		       && (i.types[op] & Reg16) != 0
		       && (i.tm.operand_types[op] & (Reg32|Acc)) != 0)
		{
		  /* Prohibit these changes in the 64bit mode, since
		     the lowering is more complicated.  */
		  if (flag_code == CODE_64BIT)
		    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			    i.op[op].regs->reg_name,
			    i.suffix);
#if REGISTER_WARNINGS
		  else
		    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			     (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
			     i.op[op].regs->reg_name,
			     i.suffix);
#endif
		}
	      /* Warn if the r prefix on a general reg is missing.  */
	      else if ((i.types[op] & Reg64) != 0
		       && (i.tm.operand_types[op] & (Reg32|Acc)) != 0)
		{
		  as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			  i.op[op].regs->reg_name,
			  i.suffix);
		}
	  }
	else if (i.suffix == QWORD_MNEM_SUFFIX)
	  {
	    int op;

d1631 1
d1633 1
a1633 2
	      else if (((i.types[op] & Reg16) != 0
		        || (i.types[op] & Reg32) != 0)
d1636 4
a1639 5
		  /* Prohibit these changes in the 64bit mode, since
		     the lowering is more complicated.  */
		  as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			  i.op[op].regs->reg_name,
			  i.suffix);
d1641 1
d1646 1
a1646 1
	    for (op = i.operands; --op >= 0;)
d1658 1
d1660 1
a1660 2
	      else if ((!quiet_warnings || flag_code == CODE_64BIT)
		       && (i.types[op] & Reg32) != 0
d1663 5
a1667 12
		  /* Prohibit these changes in the 64bit mode, since
		     the lowering is more complicated.  */
		  if (flag_code == CODE_64BIT)
		    as_bad (_("Incorrect register `%%%s' used with`%c' suffix"),
			    i.op[op].regs->reg_name,
			    i.suffix);
		  else
#if REGISTER_WARNINGS
		    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
			     (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
			     i.op[op].regs->reg_name,
			     i.suffix);
a1668 1
		}
a1669 3
	else if (intel_syntax && (i.tm.opcode_modifier & IgnoreSize))
	  /* Do nothing if the instruction is going to ignore the prefix.  */
	  ;
d1671 1
a1671 1
	  abort ();
d1677 1
d1680 1
a1680 1
    if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S))
d1682 1
a1682 2
	&& overlap0 != Imm16 && overlap0 != Imm32S
	&& overlap0 != Imm32 && overlap0 != Imm64)
d1687 1
a1687 2
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 :
			(i.suffix == QWORD_MNEM_SUFFIX ? Imm64 | Imm32S : Imm32)));
d1689 1
a1689 3
	else if (overlap0 == (Imm16 | Imm32S | Imm32)
		 || overlap0 == (Imm16 | Imm32)
		 || overlap0 == (Imm16 | Imm32S))
d1692 1
a1692 1
	      ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32S;
d1694 1
a1694 3
	if (overlap0 != Imm8 && overlap0 != Imm8S
	    && overlap0 != Imm16 && overlap0 != Imm32S
	    && overlap0 != Imm32 && overlap0 != Imm64)
d1700 1
a1700 1
    if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32S | Imm32))
d1702 1
a1702 2
	&& overlap1 != Imm16 && overlap1 != Imm32S
	&& overlap1 != Imm32 && overlap1 != Imm64)
d1707 1
a1707 2
			(i.suffix == WORD_MNEM_SUFFIX ? Imm16 :
			(i.suffix == QWORD_MNEM_SUFFIX ? Imm64 | Imm32S : Imm32)));
d1709 1
a1709 3
	else if (overlap1 == (Imm16 | Imm32 | Imm32S)
		 || overlap1 == (Imm16 | Imm32)
		 || overlap1 == (Imm16 | Imm32S))
d1712 1
a1712 1
	      ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)) ? Imm16 : Imm32S;
d1714 1
a1714 3
	if (overlap1 != Imm8 && overlap1 != Imm8S
	    && overlap1 != Imm16 && overlap1 != Imm32S
	    && overlap1 != Imm32 && overlap1 != Imm64)
d1716 1
a1716 1
	    as_bad (_("no instruction mnemonic suffix given; can't determine immediate size %x %c"),overlap1, i.suffix);
d1726 1
a1726 1
      i.imm_operands = 0;	/* kludge for shift insns.  */
d1745 1
a1745 1
    /* For movzx and movsx, need to check the register type.  */
d1770 2
a1771 2
	if (i.suffix != QWORD_MNEM_SUFFIX
	    && (i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
a1780 13

	/* Set mode64 for an operand.  */
	if (i.suffix == QWORD_MNEM_SUFFIX
	    && !(i.tm.opcode_modifier & NoRex64))
	  {
	    i.rex.mode64 = 1;
	    if (flag_code < CODE_64BIT)
	      {
		as_bad (_("64bit operations available only in 64bit modes."));
		return;
	      }
	  }

d1782 2
a1783 1
	if (i.suffix == LONG_MNEM_SUFFIX)
d1799 1
a1799 1
	assert (i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);
d1809 1
a1809 1
    /* For insns with operands there are more diddles to do to the opcode.  */
d1823 4
a1826 4
	    /* Pretend we saw the extra register operand.  */
	    assert (i.op[first_reg_op + 1].regs == 0);
	    i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
	    i.types[first_reg_op + 1] = i.types[first_reg_op];
d1832 1
a1832 1
	    /* The register or float register operand is in operand 0 or 1.  */
d1834 1
a1834 1
	    /* Register goes in low 3 bits of opcode.  */
d1836 1
a1836 3
	    if (i.op[op].regs->reg_flags & RegRex)
	      i.rex.extZ = 1;
	    if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
d1842 1
a1842 1
		    /* Reversed arguments on faddp, fsubp, etc.  */
d1849 1
a1849 1
		    /* Extraneous `l' suffix on fp insn.  */
d1860 1
a1860 1
	       info we've collected.  */
d1863 1
a1863 1
	       implicit registers do not count.  */
a1885 4
		    if (i.op[dest].regs->reg_flags & RegRex)
		      i.rex.extX = 1;
		    if (i.op[source].regs->reg_flags & RegRex)
		      i.rex.extZ = 1;
a1890 4
		    if (i.op[dest].regs->reg_flags & RegRex)
		      i.rex.extZ = 1;
		    if (i.op[source].regs->reg_flags & RegRex)
		      i.rex.extX = 1;
d1894 1
a1894 1
	      {			/* If it's not 2 reg operands...  */
d1911 2
a1912 2
			    /* Operand is just <disp>  */
			    if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
d1918 1
a1918 1
			    else if (flag_code != CODE_64BIT)
a1923 14
			    else
			      {
			        /* 64bit mode overwrites the 32bit
				   absolute addressing by RIP relative
				   addressing and absolute addressing
				   is encoded by one of the redundant
				   SIB forms.  */

				i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
				i.sib.base = NO_BASE_REGISTER;
				i.sib.index = NO_INDEX_REGISTER;
				i.types[op] &= ~Disp;
				i.types[op] |= Disp32S;
			      }
d1925 1
a1925 1
			else /* ! i.base_reg && i.index_reg  */
d1932 1
a1932 6
			    if (flag_code != CODE_64BIT)
			      i.types[op] |= Disp32;	/* Must be 32 bit */
			    else
			      i.types[op] |= Disp32S;
			    if (i.index_reg->reg_flags & RegRex)
			      i.rex.extY = 1;
a1934 8
		    /* RIP addressing for 64bit mode.  */
		    else if (i.base_reg->reg_type == BaseIndex)
		      {
			i.rm.regmem = NO_BASE_REGISTER;
			i.types[op] &= ~Disp;
			i.types[op] |= Disp32S;
			i.flags[op] = Operand_PCrel;
		      }
d1939 1
a1939 1
			  case 3: /* (%bx)  */
d1942 1
a1942 1
			    else /* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
d1945 1
a1945 1
			  case 5: /* (%bp)  */
d1952 1
a1952 1
				    /* fake (%bp) into 0(%bp)  */
d1957 1
a1957 1
			    else /* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
d1960 1
a1960 1
			  default: /* (%si) -> 4 or (%di) -> 5  */
d1965 1
a1965 1
		    else /* i.base_reg and 32/64 bit mode  */
a1966 8
			if (flag_code == CODE_64BIT
			    && (i.types[op] & Disp))
			  {
			    if (i.types[op] & Disp8)
			      i.types[op] = Disp8 | Disp32S;
			    else
			      i.types[op] = Disp32S;
			  }
a1967 2
			if (i.base_reg->reg_flags & RegRex)
			  i.rex.extZ = 1;
d1969 1
a1969 3
			/* x86-64 ignores REX prefix bit here to avoid
			   decoder complications.  */
			if ((i.base_reg->reg_num & 7) == EBP_REG_NUM)
a2002 2
			    if (i.index_reg->reg_flags & RegRex)
			      i.rex.extY = 1;
d2010 1
a2010 1
			   holds the correct displacement size.  */
d2027 1
a2027 1
		   into the i.rm.reg field.  */
d2043 1
a2043 1
		       register number must be put into the regmem field.  */
d2045 1
a2045 5
		      {
			i.rm.regmem = i.op[op].regs->reg_num;
			if (i.op[op].regs->reg_flags & RegRex)
			  i.rex.extZ = 1;
		      }
d2047 1
a2047 5
		      {
			i.rm.reg = i.op[op].regs->reg_num;
			if (i.op[op].regs->reg_flags & RegRex)
			  i.rex.extX = 1;
		      }
d2056 1
a2056 1
		/* Fill in i.rm.reg field with extension opcode (if any).  */
d2063 1
a2063 2
	    if (i.tm.base_opcode == POP_SEG_SHORT
		&& i.op[0].regs->reg_num == 1)
a2068 2
	    if (i.op[0].regs->reg_flags & RegRex)
	      i.rex.extZ = 1;
d2093 1
a2093 1
    else if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
d2100 1
a2100 1
  /* Handle conversion of 'int $3' --> special int3 insn.  */
d2117 1
a2117 42
  if (i.tm.opcode_modifier & Rex64)
    i.rex.mode64 = 1;

  /* For 8bit registers we would need an empty rex prefix.
     Also in the case instruction is already having prefix,
     we need to convert old registers to new ones.  */

  if (((i.types[0] & Reg8) && (i.op[0].regs->reg_flags & RegRex64))
      || ((i.types[1] & Reg8) && (i.op[1].regs->reg_flags & RegRex64))
      || ((i.rex.mode64 || i.rex.extX || i.rex.extY || i.rex.extZ || i.rex.empty)
	  && ((i.types[0] & Reg8) || (i.types[1] & Reg8))))
    {
      int x;
      i.rex.empty = 1;
      for (x = 0; x < 2; x++)
	{
	  /* Look for 8bit operand that does use old registers.  */
	  if (i.types[x] & Reg8
	      && !(i.op[x].regs->reg_flags & RegRex64))
	    {
	      /* In case it is "hi" register, give up.  */
	      if (i.op[x].regs->reg_num > 3)
		as_bad (_("Can't encode registers '%%%s' in the instruction requiring REX prefix.\n"),
			i.op[x].regs->reg_name);

	      /* Otherwise it is equivalent to the extended register.
	         Since the encoding don't change this is merely cosmetical
	         cleanup for debug output.  */

	      i.op[x].regs = i.op[x].regs + 8;
	    }
	}
    }

  if (i.rex.mode64 || i.rex.extX || i.rex.extY || i.rex.extZ || i.rex.empty)
    add_prefix (0x40
		| (i.rex.mode64 ? 8 : 0)
		| (i.rex.extX ? 4 : 0)
		| (i.rex.extY ? 2 : 0)
		| (i.rex.extZ ? 1 : 0));

  /* We are ready to output the insn.  */
d2121 1
a2121 6
    /* Tie dwarf2 debug info to the address at the start of the insn.
       We can't do this after the insn has been output as the current
       frag may have been closed off.  eg. by frag_var.  */
    dwarf2_emit_insn (0);

    /* Output jumps.  */
d2124 1
d2129 1
a2129 1
	if (flag_code == CODE_16BIT)
d2139 4
a2142 12
	/* Pentium4 branch hints.  */
	if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
	    || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	  {
	    prefix++;
	    i.prefixes--;
	  }
	if (i.prefix[REX_PREFIX])
	  {
	    prefix++;
	    i.prefixes--;
	  }
d2152 2
a2153 1
	frag_grow (prefix + 2 + 4);
d2156 1
a2156 1
	if (i.prefix[DATA_PREFIX])
a2157 5
	if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE
	    || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE)
	  *p++ = i.prefix[SEG_PREFIX];
	if (i.prefix[REX_PREFIX])
	  *p++ = i.prefix[REX_PREFIX];
d2162 2
a2163 2
		  1 + 4,
		  i.reloc[0],
d2166 1
a2166 3
		   : ((cpu_arch_flags & Cpu386) != 0
		      ? ENCODE_RELAX_STATE (COND_JUMP, SMALL) | code16
		      : ENCODE_RELAX_STATE (COND_JUMP86, SMALL) | code16)),
d2181 1
a2184 7
	    /* Pentium4 branch hints.  */
	    if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
		|| i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	      {
		FRAG_APPEND_1_CHAR (i.prefix[SEG_PREFIX]);
		i.prefixes--;
	      }
d2191 1
a2191 1
	    if (flag_code == CODE_16BIT)
d2196 1
a2206 6
	if (i.prefix[REX_PREFIX])
	  {
	    FRAG_APPEND_1_CHAR (i.prefix[REX_PREFIX]);
	    i.prefixes -= 1;
	  }

d2210 13
a2222 2
	p = frag_more (1 + size);
	*p++ = i.tm.base_opcode;
d2225 1
a2225 1
		     i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
d2234 1
a2234 1
	if (flag_code == CODE_16BIT)
a2243 5
	if (i.prefix[REX_PREFIX])
	  {
	    prefix++;
	    i.prefixes -= 1;
	  }
d2252 1
a2252 1
	/* 1 opcode; 2 segment; offset  */
d2254 1
a2254 2

	if (i.prefix[DATA_PREFIX])
a2255 4

	if (i.prefix[REX_PREFIX])
	  *p++ = i.prefix[REX_PREFIX];

d2259 1
a2259 1
	    offsetT n = i.op[1].imms->X_add_number;
d2268 1
a2268 1
	    md_number_to_chars (p, n, size);
d2272 1
a2272 1
		       i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
d2280 1
a2280 1
	/* Output normal instructions here.  */
d2283 1
a2283 6
	/* All opcodes on i386 have eighter 1 or 2 bytes.  We may use third
	   byte for the SSE instructions to specify prefix they require.  */
	if (i.tm.base_opcode & 0xff0000)
	  add_prefix ((i.tm.base_opcode >> 16) & 0xff);

	/* The prefix bytes.  */
d2290 1
d2296 1
a2296 1
	/* Now the opcode; be careful about word order here!  */
d2299 1
d2302 1
a2302 1
	else
d2304 1
d2306 1
a2306 1
	    /* Put out high byte first: can't use md_number_to_chars!  */
d2310 17
d2331 1
d2346 1
d2366 2
a2367 2
			int size;
			offsetT val;
d2369 1
a2369 2
			size = 4;
			if (i.types[n] & (Disp8 | Disp16 | Disp64))
d2371 2
d2374 1
d2376 8
a2383 3
			      size = 1;
			    if (i.types[n] & Disp64)
			      size = 8;
d2385 1
a2385 2
			val = offset_in_range (i.op[n].disps->X_add_number,
					       size);
d2387 1
a2387 1
			md_number_to_chars (p, val, size);
a2391 10
			int sign = 0;
			int pcrel = (i.flags[n] & Operand_PCrel) != 0;

			/* The PC relative address is computed relative
			   to the instruction boundary, so in case immediate
			   fields follows, we need to adjust the value.  */
			if (pcrel && i.imm_operands)
			  {
			    int imm_size = 4;
			    register unsigned int n1;
d2393 2
a2394 28
			    for (n1 = 0; n1 < i.operands; n1++)
			      if (i.types[n1] & Imm)
				{
				  if (i.types[n1] & (Imm8 | Imm8S | Imm16 | Imm64))
				    {
				      imm_size = 2;
				      if (i.types[n1] & (Imm8 | Imm8S))
					imm_size = 1;
				      if (i.types[n1] & Imm64)
					imm_size = 8;
				    }
				  break;
				}
			    /* We should find the immediate.  */
			    if (n1 == i.operands)
			      abort ();
			    i.op[n].disps->X_add_number -= imm_size;
			  }

			if (i.types[n] & Disp32S)
			  sign = 1;

			if (i.types[n] & (Disp16 | Disp64))
			  {
			    size = 2;
			    if (i.types[n] & Disp64)
			      size = 8;
			  }
d2396 1
d2399 2
a2400 2
				     i.op[n].disps, pcrel,
				     reloc (size, pcrel, sign, i.reloc[n]));
d2404 1
a2404 1
	  }
d2406 1
a2406 1
	/* Output immediate.  */
d2417 2
a2418 2
			int size;
			offsetT val;
d2420 1
a2420 2
			size = 4;
			if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
d2422 2
d2425 1
d2427 7
a2433 3
			      size = 1;
			    else if (i.types[n] & Imm64)
			      size = 8;
d2435 1
a2435 2
			val = offset_in_range (i.op[n].imms->X_add_number,
					       size);
d2437 1
a2437 1
			md_number_to_chars (p, val, size);
d2440 2
a2441 3
		      {
			/* Not absolute_section.
			   Need a 32-bit fixup (don't support 8bit
d2443 6
a2448 2
			   sizes ...  */
			RELOC_ENUM reloc_type;
a2449 1
			int sign = 0;
d2451 4
a2454 11
			if ((i.types[n] & (Imm32S))
			    && i.suffix == QWORD_MNEM_SUFFIX)
			  sign = 1;
			if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
			  {
			    size = 2;
			    if (i.types[n] & (Imm8 | Imm8S))
			      size = 1;
			    if (i.types[n] & Imm64)
			      size = 8;
			  }
d2456 1
d2458 1
a2458 1
			reloc_type = reloc (size, 0, sign, i.reloc[n]);
a2468 3
			    /* We don't support dynamic linking on x86-64 yet.  */
			    if (flag_code == CODE_64BIT)
			      abort ();
d2478 1
a2478 1
	  }
d2486 1
a2486 1
#endif /* DEBUG386  */
a2489 124
#ifndef LEX_AT
static char *lex_got PARAMS ((RELOC_ENUM *, int *));

/* Parse operands of the form
   <symbol>@@GOTOFF+<nnn>
   and similar .plt or .got references.

   If we find one, set up the correct relocation in RELOC and copy the
   input string, minus the `@@GOTOFF' into a malloc'd buffer for
   parsing by the calling routine.  Return this buffer, and if ADJUST
   is non-null set it to the length of the string we removed from the
   input line.  Otherwise return NULL.  */
static char *
lex_got (reloc, adjust)
     RELOC_ENUM *reloc;
     int *adjust;
{
  static const char * const mode_name[NUM_FLAG_CODE] = { "32", "16", "64" };
  static const struct {
    const char *str;
    const RELOC_ENUM rel[NUM_FLAG_CODE];
  } gotrel[] = {
    { "PLT",      { BFD_RELOC_386_PLT32,  0, BFD_RELOC_X86_64_PLT32    } },
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF, 0, 0                         } },
    { "GOTPCREL", { 0,                    0, BFD_RELOC_X86_64_GOTPCREL } },
    { "GOT",      { BFD_RELOC_386_GOT32,  0, BFD_RELOC_X86_64_GOT32    } }
  };
  char *cp;
  unsigned int j;

  for (cp = input_line_pointer; *cp != '@@'; cp++)
    if (is_end_of_line[(unsigned char) *cp])
      return NULL;

  for (j = 0; j < sizeof (gotrel) / sizeof (gotrel[0]); j++)
    {
      int len;

      len = strlen (gotrel[j].str);
      if (strncmp (cp + 1, gotrel[j].str, len) == 0)
	{
	  if (gotrel[j].rel[(unsigned int) flag_code] != 0)
	    {
	      int first;
	      char *tmpbuf;

	      *reloc = gotrel[j].rel[(unsigned int) flag_code];

	      if (GOT_symbol == NULL)
		GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	      /* Replace the relocation token with ' ', so that
		 errors like foo@@GOTOFF1 will be detected.  */
	      first = cp - input_line_pointer;
	      tmpbuf = xmalloc (strlen (input_line_pointer));
	      memcpy (tmpbuf, input_line_pointer, first);
	      tmpbuf[first] = ' ';
	      strcpy (tmpbuf + first + 1, cp + 1 + len);
	      if (adjust)
		*adjust = len;
	      return tmpbuf;
	    }

	  as_bad (_("@@%s reloc is not supported in %s bit mode"),
		  gotrel[j].str, mode_name[(unsigned int) flag_code]);
	  return NULL;
	}
    }

  /* Might be a symbol version string.  Don't as_bad here.  */
  return NULL;
}

/* x86_cons_fix_new is called via the expression parsing code when a
   reloc is needed.  We use this hook to get the correct .got reloc.  */
static RELOC_ENUM got_reloc = NO_RELOC;

void
x86_cons_fix_new (frag, off, len, exp)
     fragS *frag;
     unsigned int off;
     unsigned int len;
     expressionS *exp;
{
  RELOC_ENUM r = reloc (len, 0, 0, got_reloc);
  got_reloc = NO_RELOC;
  fix_new_exp (frag, off, len, exp, 0, r);
}

void
x86_cons (exp, size)
     expressionS *exp;
     int size;
{
  if (size == 4)
    {
      /* Handle @@GOTOFF and the like in an expression.  */
      char *save;
      char *gotfree_input_line;
      int adjust;

      save = input_line_pointer;
      gotfree_input_line = lex_got (&got_reloc, &adjust);
      if (gotfree_input_line)
	input_line_pointer = gotfree_input_line;

      expression (exp);

      if (gotfree_input_line)
	{
	  /* expression () has merrily parsed up to the end of line,
	     or a comma - in the wrong buffer.  Transfer how far
	     input_line_pointer has moved to the right buffer.  */
	  input_line_pointer = (save
				+ (input_line_pointer - gotfree_input_line)
				+ adjust);
	  free (gotfree_input_line);
	}
    }
  else
    expression (exp);
}
#endif

a2496 3
#ifndef LEX_AT
  char *gotfree_input_line;
#endif
d2498 1
a2498 1
  expressionS *exp;
d2516 51
a2566 3
  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL);
  if (gotfree_input_line)
    input_line_pointer = gotfree_input_line;
d2573 1
a2573 1
    as_bad (_("junk `%s' after expression"), input_line_pointer);
a2575 4
#ifndef LEX_AT
  if (gotfree_input_line)
    free (gotfree_input_line);
#endif
d2579 1
a2579 1
      /* Missing or bad expr becomes absolute 0.  */
d2587 2
a2588 1
  else if (exp->X_op == O_constant)
d2590 1
a2590 6
      /* Size it properly later.  */
      i.types[this_operand] |= Imm64;
      /* If BFD64, sign extend val.  */
      if (!use_rela_relocations)
	if ((exp->X_add_number & ~(((addressT) 2 << 31) - 1)) == 0)
	  exp->X_add_number = (exp->X_add_number ^ ((addressT) 1 << 31)) - ((addressT) 1 << 31);
d2593 1
a2593 1
  else if (1
d2595 1
a2595 1
	   && OUTPUT_FLAVOR == bfd_target_aout_flavour
d2597 1
a2597 1
	   && exp_seg != text_section
d2618 4
a2621 2
	 suffix, or the default for the section.  */
      i.types[this_operand] |= Imm8 | Imm16 | Imm32 | Imm32S | Imm64;
d2627 1
a2627 1
static char *i386_scale PARAMS ((char *));
d2629 1
a2629 1
static char *
d2633 2
a2634 2
  offsetT val;
  char *save = input_line_pointer;
d2636 1
a2636 4
  input_line_pointer = scale;
  val = get_absolute_expression ();

  switch (val)
d2638 2
a2639 2
    case 0:
    case 1:
d2642 1
a2642 1
    case 2:
d2645 1
a2645 1
    case 4:
d2648 1
a2648 1
    case 8:
d2652 1
d2655 1
a2655 2
      input_line_pointer = save;
      return NULL;
d2665 1
a2665 3
  scale = input_line_pointer;
  input_line_pointer = save;
  return scale;
a2677 3
#ifndef LEX_AT
  char *gotfree_input_line;
#endif
d2680 1
a2680 1
  if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
a2681 2
  if (flag_code == CODE_64BIT)
    bigdisp = Disp64;
d2730 2
a2731 1
	 So here we provide the missing zero.  */
d2737 51
a2787 3
  gotfree_input_line = lex_got (&i.reloc[this_operand], NULL);
  if (gotfree_input_line)
    input_line_pointer = gotfree_input_line;
a2791 13
  SKIP_WHITESPACE ();
  if (*input_line_pointer)
    as_bad (_("junk `%s' after expression"), input_line_pointer);
#if GCC_ASM_O_HACK
  RESTORE_END_STRING (disp_end + 1);
#endif
  RESTORE_END_STRING (disp_end);
  input_line_pointer = save_input_line_pointer;
#ifndef LEX_AT
  if (gotfree_input_line)
    free (gotfree_input_line);
#endif

d2795 2
a2796 3
     to be relative to the beginning of the section.  */
  if (i.reloc[this_operand] == BFD_RELOC_386_GOTOFF
      || i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
d2798 1
a2798 10
      if (exp->X_op != O_symbol)
	{
	  as_bad (_("bad expression used with @@%s"),
		  (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL
		   ? "GOTPCREL"
		   : "GOTOFF"));
	  return 0;
	}

      if (S_IS_LOCAL (exp->X_add_symbol)
d2801 1
d2804 1
a2804 4
      if (i.reloc[this_operand] == BFD_RELOC_X86_64_GOTPCREL)
        i.reloc[this_operand] = BFD_RELOC_32_PCREL;
      else
        i.reloc[this_operand] = BFD_RELOC_32;
d2808 10
d2820 1
a2820 1
      /* Missing or bad expr becomes absolute 0.  */
d2829 13
d2843 1
a2843 1
  if (exp->X_op != O_constant
d2845 1
a2845 1
      && OUTPUT_FLAVOR == bfd_target_aout_flavour
d2847 4
a2850 4
      && exp_seg != text_section
      && exp_seg != data_section
      && exp_seg != bss_section
      && exp_seg != undefined_section)
a2859 2
  else if (flag_code == CODE_64BIT)
    i.types[this_operand] |= Disp32S | Disp32;
d2863 1
a2863 4
static int i386_index_check PARAMS ((const char *));

/* Make sure the memory operand we've been dealt is valid.
   Return 1 on success, 0 on a failure.  */
d2866 3
a2868 2
i386_index_check (operand_string)
     const char *operand_string;
d2870 5
a2874 3
  int ok;
#if INFER_ADDR_PREFIX
  int fudged = 0;
a2875 14
 tryprefix:
#endif
  ok = 1;
  if (flag_code == CODE_64BIT)
    {
      /* 64bit checks.  */
      if ((i.base_reg
	   && ((i.base_reg->reg_type & Reg64) == 0)
	       && (i.base_reg->reg_type != BaseIndex
		   || i.index_reg))
	  || (i.index_reg
	      && ((i.index_reg->reg_type & (Reg64|BaseIndex))
		  != (Reg64|BaseIndex))))
	ok = 0;
d2877 1
a2877 1
  else
d2879 2
a2880 15
      if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
	{
	  /* 16bit checks.  */
	  if ((i.base_reg
	       && ((i.base_reg->reg_type & (Reg16|BaseIndex|RegRex))
		   != (Reg16|BaseIndex)))
	      || (i.index_reg
		  && (((i.index_reg->reg_type & (Reg16|BaseIndex))
		       != (Reg16|BaseIndex))
		      || ! (i.base_reg
			    && i.base_reg->reg_num < 6
			    && i.index_reg->reg_num >= 6
			    && i.log2_scale_factor == 0))))
	    ok = 0;
	}
d2882 3
a2884 9
	{
	  /* 32bit checks.  */
	  if ((i.base_reg
	       && (i.base_reg->reg_type & (Reg32 | RegRex)) != Reg32)
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg32|BaseIndex|RegRex))
		      != (Reg32|BaseIndex))))
	    ok = 0;
	}
d2886 2
a2887 1
  if (!ok)
d2889 2
a2890 19
#if INFER_ADDR_PREFIX
      if (flag_code != CODE_64BIT
	  && i.prefix[ADDR_PREFIX] == 0 && stackop_size != '\0')
	{
	  i.prefix[ADDR_PREFIX] = ADDR_PREFIX_OPCODE;
	  i.prefixes += 1;
	  /* Change the size of any displacement too.  At most one of
	     Disp16 or Disp32 is set.
	     FIXME.  There doesn't seem to be any real need for separate
	     Disp16 and Disp32 flags.  The same goes for Imm16 and Imm32.
	     Removing them would probably clean up the code quite a lot.  */
	  if (i.types[this_operand] & (Disp16|Disp32))
	     i.types[this_operand] ^= (Disp16|Disp32);
	  fudged = 1;
	  goto tryprefix;
	}
      if (fudged)
	as_bad (_("`%s' is not a valid base/index expression"),
		operand_string);
d2892 3
a2894 5
#endif
	as_bad (_("`%s' is not a valid %s bit base/index expression"),
		operand_string,
		flag_code_names[flag_code]);
      return 0;
a2895 2
  return 1;
}
d2897 6
a2902 2
/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero
   on error.  */
d2904 472
a3375 7
static int
i386_operand (operand_string)
     char *operand_string;
{
  const reg_entry *r;
  char *end_op;
  char *op_string = operand_string;
d3381 1
a3381 1
     for example, 'jmp pc_relative_label' from 'jmp *absolute_label'.  */
d3390 1
a3390 1
  /* Check if operand is a register.  */
d3436 1
a3436 1
	  /* Handle case of %es:*foo.  */
d3461 1
a3461 1
    {
d3473 1
a3473 1
	   || *op_string == '(')
d3475 1
a3475 1
      /* This is a memory reference of some sort.  */
d3478 1
a3478 1
      /* Start and end of displacement string expression (if found).  */
d3502 1
a3502 1
      /* If we only have a displacement, set-up for it to be parsed later.  */
d3511 1
a3511 1
	     equal, so this loop will not be infinite.  */
d3563 1
a3563 1
		      else if (*base_string != ')')
d3576 2
a3577 2
		  /* Check for scale factor.  */
		  if (*base_string != ')')
d3579 1
a3579 3
		      char *end_scale = i386_scale (base_string);

		      if (!end_scale)
d3582 1
a3582 1
		      base_string = end_scale;
d3640 1
a3640 2
    {
      /* It's not a memory operand; argh!  */
d3647 1
a3647 1
  return 1;			/* Normal return.  */
d3673 1
a3673 1
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
d3682 5
a3686 1
      RELOC_ENUM reloc_type;
d3700 1
a3700 1
      switch (TYPE_FROM_RELAX_STATE (fragP->fr_subtype))
d3702 2
a3703 3
	case UNCOND_JUMP:
	  /* Make jmp (0xeb) a (d)word displacement jump.  */
	  opcode[0] = 0xe9;
d3711 1
a3711 27
	case COND_JUMP86:
	  if (no_cond_jump_promotion)
	    goto relax_guess;

	  if (size == 2)
	    {
	      /* Negate the condition, and branch past an
		 unconditional jump.  */
	      opcode[0] ^= 1;
	      opcode[1] = 3;
	      /* Insert an unconditional jump.  */
	      opcode[2] = 0xe9;
	      /* We added two extra opcode bytes, and have a two byte
		 offset.  */
	      fragP->fr_fix += 2 + 2;
	      fix_new (fragP, old_fr_fix + 2, 2,
		       fragP->fr_symbol,
		       fragP->fr_offset, 1,
		       reloc_type);
	      break;
	    }
	  /* Fall through.  */

	case COND_JUMP:
	  if (no_cond_jump_promotion)
	    goto relax_guess;

d3713 1
a3713 1
	     to the (d)word-displacement jump 0x0f,0x8N.  */
d3716 1
a3716 2
	  /* We've added an opcode byte.  */
	  fragP->fr_fix += 1 + size;
a3721 4

	default:
	  BAD_CASE (fragP->fr_subtype);
	  break;
d3726 2
d3729 11
a3739 19
 relax_guess:
  /* Guess size depending on current relax state.  Initially the relax
     state will correspond to a short jump and we return 1, because
     the variable part of the frag (the branch offset) is one byte
     long.  However, we can relax a section more than once and in that
     case we must either set fr_subtype back to the unrelaxed state,
     or return the value for the appropriate branch.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* Called after relax() is finished.

   In:	Address of frag.
	fr_type == rs_machine_dependent.
	fr_subtype is what the address relaxed to.

   Out:	Any fixSs and constants are set up.
	Caller will turn frag into a ".space 0".  */

d3756 2
a3757 2
  offsetT target_address;
  offsetT opcode_address;
d3759 1
a3759 1
  offsetT displacement_from_opcode_start;
d3763 1
a3763 1
  /* Address we want to reach in file space.  */
d3765 2
a3766 8
#ifdef BFD_ASSEMBLER
  /* Not needed otherwise?  */
  {
    /* Local symbols which have already been resolved have a NULL frag.  */
    fragS *sym_frag = symbol_get_frag (fragP->fr_symbol);
    if (sym_frag)
      target_address += sym_frag->fr_address;
  }
d3769 1
a3769 1
  /* Address opcode resides at in file space.  */
d3772 1
a3772 1
  /* Displacement from opcode start to fill into instruction.  */
d3775 1
a3775 1
  if ((fragP->fr_subtype & BIG) == 0)
d3777 6
a3782 2
      /* Don't have to change opcode.  */
      extension = 1;		/* 1 opcode + 1 displacement  */
d3784 1
a3784 6
    }
  else
    {
      if (no_cond_jump_promotion
	  && TYPE_FROM_RELAX_STATE (fragP->fr_subtype) != UNCOND_JUMP)
	as_warn_where (fragP->fr_file, fragP->fr_line, _("long jump required"));
d3786 6
a3791 7
      switch (fragP->fr_subtype)
	{
	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG):
	  extension = 4;		/* 1 opcode + 4 displacement  */
	  opcode[0] = 0xe9;
	  where_to_put_displacement = &opcode[1];
	  break;
d3793 5
a3797 5
	case ENCODE_RELAX_STATE (UNCOND_JUMP, BIG16):
	  extension = 2;		/* 1 opcode + 2 displacement  */
	  opcode[0] = 0xe9;
	  where_to_put_displacement = &opcode[1];
	  break;
d3799 6
a3804 7
	case ENCODE_RELAX_STATE (COND_JUMP, BIG):
	case ENCODE_RELAX_STATE (COND_JUMP86, BIG):
	  extension = 5;		/* 2 opcode + 4 displacement  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  where_to_put_displacement = &opcode[2];
	  break;
d3806 5
a3810 6
	case ENCODE_RELAX_STATE (COND_JUMP, BIG16):
	  extension = 3;		/* 2 opcode + 2 displacement  */
	  opcode[1] = opcode[0] + 0x10;
	  opcode[0] = TWO_BYTE_OPCODE_ESCAPE;
	  where_to_put_displacement = &opcode[2];
	  break;
d3812 3
a3814 12
	case ENCODE_RELAX_STATE (COND_JUMP86, BIG16):
	  extension = 4;
	  opcode[0] ^= 1;
	  opcode[1] = 3;
	  opcode[2] = 0xe9;
	  where_to_put_displacement = &opcode[3];
	  break;

	default:
	  BAD_CASE (fragP->fr_subtype);
	  break;
	}
d3816 1
a3816 2

  /* Now put displacement after opcode.  */
d3819 1
a3819 1
		      DISP_SIZE_FROM_RELAX_STATE (fragP->fr_subtype));
a3822 5
/* Size of byte displacement jmp.  */
int md_short_jump_size = 2;

/* Size of dword displacement jmp.  */
int md_long_jump_size = 5;
d3824 3
a3826 2
/* Size of relocation record.  */
const int md_reloc_size = 8;
d3835 1
a3835 1
  offsetT offset;
d3838 1
a3838 2
  /* Opcode for byte-disp jump.  */
  md_number_to_chars (ptr, (valueT) 0xeb, 1);
d3846 2
a3847 2
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d3849 1
a3849 1
  offsetT offset;
d3851 14
a3864 3
  offset = to_addr - (from_addr + 5);
  md_number_to_chars (ptr, (valueT) 0xe9, 1);
  md_number_to_chars (ptr + 1, (valueT) offset, 4);
d3876 3
a3878 8
     /* The fix we're to put in.  */
     fixS *fixP;

     /* Pointer to the value of the bits.  */
     valueT *valp;

     /* Segment fix is from.  */
     segT seg ATTRIBUTE_UNUSED;
d3910 1
a3910 1
      && fixP->fx_addsy && !use_rela_relocations)
d3946 13
d3961 13
d3976 1
a3976 1
     and we must not dissappoint it.  */
d3980 9
a3988 11
    switch (fixP->fx_r_type)
      {
      case BFD_RELOC_386_PLT32:
      case BFD_RELOC_X86_64_PLT32:
	/* Make the jump instruction point to the address of the operand.  At
	   runtime we merely add the offset to the actual PLT entry.  */
	value = -4;
	break;
      case BFD_RELOC_386_GOTPC:

/*   This is tough to explain.  We end up with this one if we have
d4023 9
a4031 2
 * expression is not pcrel, I felt it would be confusing to do it this
 * way.  */
d4033 4
a4036 14
	value -= 1;
	break;
      case BFD_RELOC_386_GOT32:
      case BFD_RELOC_X86_64_GOT32:
	value = 0; /* Fully resolved at runtime.  No addend.  */
	break;
      case BFD_RELOC_386_GOTOFF:
      case BFD_RELOC_X86_64_GOTPCREL:
	break;

      case BFD_RELOC_VTABLE_INHERIT:
      case BFD_RELOC_VTABLE_ENTRY:
	fixP->fx_done = 0;
	return 1;
d4038 4
a4041 4
      default:
	break;
      }
#endif /* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)  */
d4043 5
a4047 1
#endif /* defined (BFD_ASSEMBLER) && !defined (TE_Mach)  */
d4049 9
a4057 7
#ifndef BFD_ASSEMBLER
  md_number_to_chars (p, value, fixP->fx_size);
#else
  /* Are we finished with this relocation now?  */
  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
  else if (use_rela_relocations)
d4059 2
a4060 2
      fixP->fx_no_overflow = 1;
      value = 0;
d4062 1
a4062 4
  md_number_to_chars (p, value, fixP->fx_size);
#endif

  return 1;
d4064 1
d4066 1
d4069 3
a4071 5
/* Turn the string pointed to by litP into a floating point constant
   of type TYPE, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d4121 2
d4134 1
a4161 6
  /* For naked regs, make sure that we are not dealing with an identifier.
     This prevents confusing an identifier like `eax_var' with register
     `eax'.  */
  if (allow_naked_reg && identifier_chars[(unsigned char) *s])
    return (const reg_entry *) NULL;

d4167 1
a4167 1
  if (r == i386_regtab /* %st is first entry of table  */)
d4188 1
a4188 1
	  /* We have "%st(" then garbage.  */
d4197 1
a4197 1
const char *md_shortopts = "kVQ:sq";
d4199 1
a4199 1
const char *md_shortopts = "q";
a4200 1

a4201 6
#define OPTION_32 (OPTION_MD_BASE + 0)
  {"32", no_argument, NULL, OPTION_32},
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
#define OPTION_64 (OPTION_MD_BASE + 1)
  {"64", no_argument, NULL, OPTION_64},
#endif
d4213 2
a4214 2
    case 'q':
      quiet_warnings = 1;
d4218 2
a4219 3
      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
d4227 3
a4229 2
      /* -k: Ignore for FreeBSD compatibility.  */
    case 'k':
d4237 3
a4239 15
    case OPTION_64:
      {
	const char **list, **l;

	list = bfd_target_list ();
	for (l = list; *l != NULL; l++)
	  if (strcmp (*l, "elf64-x86-64") == 0)
	    {
	      default_arch = "x86_64";
	      break;
	    }
	if (*l == NULL)
	  as_fatal (_("No compiled in support for x86_64"));
	free (list);
      }
a4242 4
    case OPTION_32:
      default_arch = "i386";
      break;

d4253 2
d4257 5
a4261 8
  -Q                      ignored\n\
  -V                      print assembler version number\n\
  -k                      ignored\n\
  -q                      quieten some warnings\n\
  -s                      ignored\n"));
#else
  fprintf (stream, _("\
  -q                      quieten some warnings\n"));
d4266 3
a4268 2
#if ((defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)) \
     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))
d4272 1
a4272 1
const char *
a4274 6
  if (!strcmp (default_arch, "x86_64"))
    set_code_flag (CODE_64BIT);
  else if (!strcmp (default_arch, "i386"))
    set_code_flag (CODE_32BIT);
  else
    as_fatal (_("Unknown architecture"));
d4279 1
a4279 1
      return AOUT_TARGET_FORMAT;
d4285 1
a4285 1
#if defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF)
d4287 1
a4287 5
      {
	if (flag_code == CODE_64BIT)
	  use_rela_relocations = 1;
	return flag_code == CODE_64BIT ? "elf64-x86-64" : "elf32-i386";
      }
d4295 2
a4296 2
#endif /* OBJ_MAYBE_ more than one  */
#endif /* BFD_ASSEMBLER  */
a4319 1

d4371 1
d4380 1
a4380 13
      /* GOTOFF relocation are nonsense in 64bit mode.  */
      if (fixp->fx_r_type == BFD_RELOC_32_PCREL)
	{
	  if (flag_code != CODE_64BIT)
	    abort ();
	  fixp->fx_r_type = BFD_RELOC_X86_64_GOTPCREL;
	}
      else
	{
	  if (flag_code == CODE_64BIT)
	    abort ();
	  fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
	}
a4394 3
    case BFD_RELOC_X86_64_PLT32:
    case BFD_RELOC_X86_64_GOT32:
    case BFD_RELOC_X86_64_GOTPCREL:
a4398 1
    case BFD_RELOC_X86_64_32S:
a4429 1
	    case 8: code = BFD_RELOC_64; break;
d4438 1
a4438 6
    {
      /* We don't support GOTPC on 64bit targets.  */
      if (flag_code == CODE_64BIT)
	abort ();
      code = BFD_RELOC_386_GOTPC;
    }
d4445 4
a4448 6
  if (!use_rela_relocations)
    {
      /* HACK: Since i386 ELF uses Rel instead of Rela, encode the
	 vtable entry to be used in the relocation's section offset.  */
      if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
	rel->address = fixp->fx_offset;
d4450 2
a4451 6
      if (fixp->fx_pcrel)
	rel->addend = fixp->fx_addnumber;
      else
	rel->addend = 0;
    }
  /* Use the rela in 64bit mode.  */
d4453 1
a4453 5
    {
      rel->addend = fixp->fx_offset;
      if (fixp->fx_pcrel)
	rel->addend -= fixp->fx_size;
    }
d4469 1
a4469 1
#else /* ! BFD_ASSEMBLER  */
d4478 4
a4481 2
  /* In:  length of relocation (or of address) in chars: 1, 2 or 4.
     Out: GNU LD relocation length code: 0, 1, or 2.  */
d4483 1
a4483 1
  static const unsigned char nbytes_r_length[] = { 42, 0, 1, 42, 2 };
d4505 1
a4505 1
#endif /* OBJ_AOUT or OBJ_BOUT.  */
d4535 1
a4535 1
#endif /* I386COFF  */
d4537 1
a4537 1
#endif /* ! BFD_ASSEMBLER  */
d4539 1
a4539 949
/* Parse operands using Intel syntax. This implements a recursive descent
   parser based on the BNF grammar published in Appendix B of the MASM 6.1
   Programmer's Guide.

   FIXME: We do not recognize the full operand grammar defined in the MASM
	  documentation.  In particular, all the structure/union and
	  high-level macro operands are missing.

   Uppercase words are terminals, lower case words are non-terminals.
   Objects surrounded by double brackets '[[' ']]' are optional. Vertical
   bars '|' denote choices. Most grammar productions are implemented in
   functions called 'intel_<production>'.

   Initial production is 'expr'.

    addOp		+ | -

    alpha		[a-zA-Z]

    byteRegister	AL | AH | BL | BH | CL | CH | DL | DH

    constant		digits [[ radixOverride ]]

    dataType		BYTE | WORD | DWORD | QWORD | XWORD

    digits		decdigit
			| digits decdigit
			| digits hexdigit

    decdigit		[0-9]

    e05			e05 addOp e06
			| e06

    e06			e06 mulOp e09
			| e09

    e09			OFFSET e10
			| e09 PTR e10
			| e09 : e10
			| e10

    e10			e10 [ expr ]
			| e11

    e11			( expr )
			| [ expr ]
			| constant
			| dataType
			| id
			| $
			| register

 => expr		SHORT e05
			| e05

    gpRegister		AX | EAX | BX | EBX | CX | ECX | DX | EDX
			| BP | EBP | SP | ESP | DI | EDI | SI | ESI

    hexdigit		a | b | c | d | e | f
			| A | B | C | D | E | F

    id			alpha
			| id alpha
			| id decdigit

    mulOp		* | / | MOD

    quote		" | '

    register		specialRegister
			| gpRegister
			| byteRegister

    segmentRegister	CS | DS | ES | FS | GS | SS

    specialRegister	CR0 | CR2 | CR3
			| DR0 | DR1 | DR2 | DR3 | DR6 | DR7
			| TR3 | TR4 | TR5 | TR6 | TR7

    We simplify the grammar in obvious places (e.g., register parsing is
    done by calling parse_register) and eliminate immediate left recursion
    to implement a recursive-descent parser.

    expr	SHORT e05
		| e05

    e05		e06 e05'

    e05'	addOp e06 e05'
		| Empty

    e06		e09 e06'

    e06'	mulOp e09 e06'
		| Empty

    e09		OFFSET e10 e09'
		| e10 e09'

    e09'	PTR e10 e09'
		| : e10 e09'
		| Empty

    e10		e11 e10'

    e10'	[ expr ] e10'
		| Empty

    e11		( expr )
		| [ expr ]
		| BYTE
		| WORD
		| DWORD
		| QWORD
		| XWORD
		| .
		| $
		| register
		| id
		| constant  */

/* Parsing structure for the intel syntax parser. Used to implement the
   semantic actions for the operand grammar.  */
struct intel_parser_s
  {
    char *op_string;		/* The string being parsed.  */
    int got_a_float;		/* Whether the operand is a float.  */
    int op_modifier;		/* Operand modifier.  */
    int is_mem;			/* 1 if operand is memory reference.  */
    const reg_entry *reg;	/* Last register reference found.  */
    char *disp;			/* Displacement string being built.  */
  };

static struct intel_parser_s intel_parser;

/* Token structure for parsing intel syntax.  */
struct intel_token
  {
    int code;			/* Token code.  */
    const reg_entry *reg;	/* Register entry for register tokens.  */
    char *str;			/* String representation.  */
  };

static struct intel_token cur_token, prev_token;

/* Token codes for the intel parser. Since T_SHORT is already used
   by COFF, undefine it first to prevent a warning.  */
#define T_NIL		-1
#define T_CONST		1
#define T_REG		2
#define T_BYTE		3
#define T_WORD		4
#define	T_DWORD		5
#define T_QWORD		6
#define T_XWORD		7
#undef  T_SHORT
#define T_SHORT		8
#define T_OFFSET	9
#define T_PTR		10
#define T_ID		11

/* Prototypes for intel parser functions.  */
static int intel_match_token	PARAMS ((int code));
static void intel_get_token	PARAMS ((void));
static void intel_putback_token	PARAMS ((void));
static int intel_expr		PARAMS ((void));
static int intel_e05		PARAMS ((void));
static int intel_e05_1		PARAMS ((void));
static int intel_e06		PARAMS ((void));
static int intel_e06_1		PARAMS ((void));
static int intel_e09		PARAMS ((void));
static int intel_e09_1		PARAMS ((void));
static int intel_e10		PARAMS ((void));
static int intel_e10_1		PARAMS ((void));
static int intel_e11		PARAMS ((void));

static int
i386_intel_operand (operand_string, got_a_float)
     char *operand_string;
     int got_a_float;
{
  int ret;
  char *p;

  /* Initialize token holders.  */
  cur_token.code = prev_token.code = T_NIL;
  cur_token.reg = prev_token.reg = NULL;
  cur_token.str = prev_token.str = NULL;

  /* Initialize parser structure.  */
  p = intel_parser.op_string = (char *) malloc (strlen (operand_string) + 1);
  if (p == NULL)
    abort ();
  strcpy (intel_parser.op_string, operand_string);
  intel_parser.got_a_float = got_a_float;
  intel_parser.op_modifier = -1;
  intel_parser.is_mem = 0;
  intel_parser.reg = NULL;
  intel_parser.disp = (char *) malloc (strlen (operand_string) + 1);
  if (intel_parser.disp == NULL)
    abort ();
  intel_parser.disp[0] = '\0';

  /* Read the first token and start the parser.  */
  intel_get_token ();
  ret = intel_expr ();

  if (ret)
    {
      /* If we found a memory reference, hand it over to i386_displacement
	 to fill in the rest of the operand fields.  */
      if (intel_parser.is_mem)
	{
	  if ((i.mem_operands == 1
	       && (current_templates->start->opcode_modifier & IsString) == 0)
	      || i.mem_operands == 2)
	    {
	      as_bad (_("too many memory references for '%s'"),
		      current_templates->start->name);
	      ret = 0;
	    }
	  else
	    {
	      char *s = intel_parser.disp;
	      i.mem_operands++;

	      /* Add the displacement expression.  */
	      if (*s != '\0')
		ret = i386_displacement (s, s + strlen (s))
		      && i386_index_check (s);
	    }
	}

      /* Constant and OFFSET expressions are handled by i386_immediate.  */
      else if (intel_parser.op_modifier == OFFSET_FLAT
	       || intel_parser.reg == NULL)
	ret = i386_immediate (intel_parser.disp);
    }

  free (p);
  free (intel_parser.disp);

  return ret;
}

/* expr	SHORT e05
	| e05  */
static int
intel_expr ()
{
  /* expr  SHORT e05  */
  if (cur_token.code == T_SHORT)
    {
      intel_parser.op_modifier = SHORT;
      intel_match_token (T_SHORT);

      return (intel_e05 ());
    }

  /* expr  e05  */
  else
    return intel_e05 ();
}

/* e05	e06 e05'

   e05'	addOp e06 e05'
	| Empty  */
static int
intel_e05 ()
{
  return (intel_e06 () && intel_e05_1 ());
}

static int
intel_e05_1 ()
{
  /* e05'  addOp e06 e05'  */
  if (cur_token.code == '+' || cur_token.code == '-')
    {
      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (cur_token.code);

      return (intel_e06 () && intel_e05_1 ());
    }

  /* e05'  Empty  */
  else
    return 1;
}

/* e06	e09 e06'

   e06'	mulOp e09 e06'
	| Empty  */
static int
intel_e06 ()
{
  return (intel_e09 () && intel_e06_1 ());
}

static int
intel_e06_1 ()
{
  /* e06'  mulOp e09 e06'  */
  if (cur_token.code == '*' || cur_token.code == '/')
    {
      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (cur_token.code);

      return (intel_e09 () && intel_e06_1 ());
    }

  /* e06'  Empty  */
  else
    return 1;
}

/* e09	OFFSET e10 e09'
	| e10 e09'

   e09'	PTR e10 e09'
	| : e10 e09'
	| Empty */
static int
intel_e09 ()
{
  /* e09  OFFSET e10 e09'  */
  if (cur_token.code == T_OFFSET)
    {
      intel_parser.is_mem = 0;
      intel_parser.op_modifier = OFFSET_FLAT;
      intel_match_token (T_OFFSET);

      return (intel_e10 () && intel_e09_1 ());
    }

  /* e09  e10 e09'  */
  else
    return (intel_e10 () && intel_e09_1 ());
}

static int
intel_e09_1 ()
{
  /* e09'  PTR e10 e09' */
  if (cur_token.code == T_PTR)
    {
      if (prev_token.code == T_BYTE)
	i.suffix = BYTE_MNEM_SUFFIX;

      else if (prev_token.code == T_WORD)
	{
	  if (intel_parser.got_a_float == 2)	/* "fi..." */
	    i.suffix = SHORT_MNEM_SUFFIX;
	  else
	    i.suffix = WORD_MNEM_SUFFIX;
	}

      else if (prev_token.code == T_DWORD)
	{
	  if (intel_parser.got_a_float == 1)	/* "f..." */
	    i.suffix = SHORT_MNEM_SUFFIX;
	  else
	    i.suffix = LONG_MNEM_SUFFIX;
	}

      else if (prev_token.code == T_QWORD)
	{
	  if (intel_parser.got_a_float == 1)	/* "f..." */
	    i.suffix = LONG_MNEM_SUFFIX;
	  else
	    i.suffix = QWORD_MNEM_SUFFIX;
	}

      else if (prev_token.code == T_XWORD)
	i.suffix = LONG_DOUBLE_MNEM_SUFFIX;

      else
	{
	  as_bad (_("Unknown operand modifier `%s'\n"), prev_token.str);
	  return 0;
	}

      intel_match_token (T_PTR);

      return (intel_e10 () && intel_e09_1 ());
    }

  /* e09  : e10 e09'  */
  else if (cur_token.code == ':')
    {
      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;

      return (intel_match_token (':') && intel_e10 () && intel_e09_1 ());
    }

  /* e09'  Empty  */
  else
    return 1;
}

/* e10	e11 e10'

   e10'	[ expr ] e10'
	| Empty  */
static int
intel_e10 ()
{
  return (intel_e11 () && intel_e10_1 ());
}

static int
intel_e10_1 ()
{
  /* e10'  [ expr ]  e10'  */
  if (cur_token.code == '[')
    {
      intel_match_token ('[');

      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  If it's an offset expression, we need to keep
	 the brace in.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;
      else
	strcat (intel_parser.disp, "[");

      /* Add a '+' to the displacement string if necessary.  */
      if (*intel_parser.disp != '\0'
	  && *(intel_parser.disp + strlen (intel_parser.disp) - 1) != '+')
	strcat (intel_parser.disp, "+");

      if (intel_expr () && intel_match_token (']'))
	{
	  /* Preserve brackets when the operand is an offset expression.  */
	  if (intel_parser.op_modifier == OFFSET_FLAT)
	    strcat (intel_parser.disp, "]");

	  return intel_e10_1 ();
	}
      else
	return 0;
    }

  /* e10'  Empty  */
  else
    return 1;
}

/* e11	( expr )
	| [ expr ]
	| BYTE
	| WORD
	| DWORD
	| QWORD
	| XWORD
	| $
	| .
	| register
	| id
	| constant  */
static int
intel_e11 ()
{
  /* e11  ( expr ) */
  if (cur_token.code == '(')
    {
      intel_match_token ('(');
      strcat (intel_parser.disp, "(");

      if (intel_expr () && intel_match_token (')'))
	{
	  strcat (intel_parser.disp, ")");
	  return 1;
	}
      else
	return 0;
    }

  /* e11  [ expr ] */
  else if (cur_token.code == '[')
    {
      intel_match_token ('[');

      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  If it's an offset expression, we need to keep
	 the brace in.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;
      else
	strcat (intel_parser.disp, "[");

      /* Operands for jump/call inside brackets denote absolute addresses.  */
      if (current_templates->start->opcode_modifier & Jump
	  || current_templates->start->opcode_modifier & JumpDword
	  || current_templates->start->opcode_modifier & JumpByte
	  || current_templates->start->opcode_modifier & JumpInterSegment)
	i.types[this_operand] |= JumpAbsolute;

      /* Add a '+' to the displacement string if necessary.  */
      if (*intel_parser.disp != '\0'
	  && *(intel_parser.disp + strlen (intel_parser.disp) - 1) != '+')
	strcat (intel_parser.disp, "+");

      if (intel_expr () && intel_match_token (']'))
	{
	  /* Preserve brackets when the operand is an offset expression.  */
	  if (intel_parser.op_modifier == OFFSET_FLAT)
	    strcat (intel_parser.disp, "]");

	  return 1;
	}
      else
	return 0;
    }

  /* e11  BYTE
	  | WORD
	  | DWORD
	  | QWORD
	  | XWORD  */
  else if (cur_token.code == T_BYTE
	   || cur_token.code == T_WORD
	   || cur_token.code == T_DWORD
	   || cur_token.code == T_QWORD
	   || cur_token.code == T_XWORD)
    {
      intel_match_token (cur_token.code);

      return 1;
    }

  /* e11  $
	  | .  */
  else if (cur_token.code == '$' || cur_token.code == '.')
    {
      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (cur_token.code);

      /* Mark as a memory operand only if it's not already known to be an
	 offset expression.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;

      return 1;
    }

  /* e11  register  */
  else if (cur_token.code == T_REG)
    {
      const reg_entry *reg = intel_parser.reg = cur_token.reg;

      intel_match_token (T_REG);

      /* Check for segment change.  */
      if (cur_token.code == ':')
	{
	  if (reg->reg_type & (SReg2 | SReg3))
	    {
	      switch (reg->reg_num)
		{
		case 0:
		  i.seg[i.mem_operands] = &es;
		  break;
		case 1:
		  i.seg[i.mem_operands] = &cs;
		  break;
		case 2:
		  i.seg[i.mem_operands] = &ss;
		  break;
		case 3:
		  i.seg[i.mem_operands] = &ds;
		  break;
		case 4:
		  i.seg[i.mem_operands] = &fs;
		  break;
		case 5:
		  i.seg[i.mem_operands] = &gs;
		  break;
		}
	    }
	  else
	    {
	      as_bad (_("`%s' is not a valid segment register"), reg->reg_name);
	      return 0;
	    }
	}

      /* Not a segment register. Check for register scaling.  */
      else if (cur_token.code == '*')
	{
	  if (!intel_parser.is_mem)
	    {
	      as_bad (_("Register scaling only allowed in memory operands."));
	      return 0;
	    }

	  /* What follows must be a valid scale.  */
	  if (intel_match_token ('*')
	      && strchr ("01248", *cur_token.str))
	    {
	      i.index_reg = reg;
	      i.types[this_operand] |= BaseIndex;

	      /* Set the scale after setting the register (otherwise,
		 i386_scale will complain)  */
	      i386_scale (cur_token.str);
	      intel_match_token (T_CONST);
	    }
	  else
	    {
	      as_bad (_("expecting scale factor of 1, 2, 4, or 8: got `%s'"),
		      cur_token.str);
	      return 0;
	    }
	}

      /* No scaling. If this is a memory operand, the register is either a
	 base register (first occurrence) or an index register (second
	 occurrence).  */
      else if (intel_parser.is_mem && !(reg->reg_type & (SReg2 | SReg3)))
	{
	  if (i.base_reg && i.index_reg)
	    {
	      as_bad (_("Too many register references in memory operand.\n"));
	      return 0;
	    }

	  if (i.base_reg == NULL)
	    i.base_reg = reg;
	  else
	    i.index_reg = reg;

	  i.types[this_operand] |= BaseIndex;
	}

      /* Offset modifier. Add the register to the displacement string to be
	 parsed as an immediate expression after we're done.  */
      else if (intel_parser.op_modifier == OFFSET_FLAT)
	strcat (intel_parser.disp, reg->reg_name);

      /* It's neither base nor index nor offset.  */
      else
	{
	  i.types[this_operand] |= reg->reg_type & ~BaseIndex;
	  i.op[this_operand].regs = reg;
	  i.reg_operands++;
	}

      /* Since registers are not part of the displacement string (except
	 when we're parsing offset operands), we may need to remove any
	 preceding '+' from the displacement string.  */
      if (*intel_parser.disp != '\0'
	  && intel_parser.op_modifier != OFFSET_FLAT)
	{
	  char *s = intel_parser.disp;
	  s += strlen (s) - 1;
	  if (*s == '+')
	    *s = '\0';
	}

      return 1;
    }

  /* e11  id  */
  else if (cur_token.code == T_ID)
    {
      /* Add the identifier to the displacement string.  */
      strcat (intel_parser.disp, cur_token.str);
      intel_match_token (T_ID);

      /* The identifier represents a memory reference only if it's not
	 preceded by an offset modifier.  */
      if (intel_parser.op_modifier != OFFSET_FLAT)
	intel_parser.is_mem = 1;

      return 1;
    }

  /* e11  constant  */
  else if (cur_token.code == T_CONST
	   || cur_token.code == '-'
	   || cur_token.code == '+')
    {
      char *save_str;

      /* Allow constants that start with `+' or `-'.  */
      if (cur_token.code == '-' || cur_token.code == '+')
	{
	  strcat (intel_parser.disp, cur_token.str);
	  intel_match_token (cur_token.code);
	  if (cur_token.code != T_CONST)
	    {
	      as_bad (_("Syntax error. Expecting a constant. Got `%s'.\n"),
		      cur_token.str);
	      return 0;
	    }
	}

      save_str = (char *) malloc (strlen (cur_token.str) + 1);
      if (save_str == NULL)
	abort ();
      strcpy (save_str, cur_token.str);

      /* Get the next token to check for register scaling.  */
      intel_match_token (cur_token.code);

      /* Check if this constant is a scaling factor for an index register.  */
      if (cur_token.code == '*')
	{
	  if (intel_match_token ('*') && cur_token.code == T_REG)
	    {
	      if (!intel_parser.is_mem)
		{
		  as_bad (_("Register scaling only allowed in memory operands."));
		  return 0;
		}

	      /* The constant is followed by `* reg', so it must be
		 a valid scale.  */
	      if (strchr ("01248", *save_str))
		{
		  i.index_reg = cur_token.reg;
		  i.types[this_operand] |= BaseIndex;

		  /* Set the scale after setting the register (otherwise,
		     i386_scale will complain)  */
		  i386_scale (save_str);
		  intel_match_token (T_REG);

		  /* Since registers are not part of the displacement
		     string, we may need to remove any preceding '+' from
		     the displacement string.  */
		  if (*intel_parser.disp != '\0')
		    {
		      char *s = intel_parser.disp;
		      s += strlen (s) - 1;
		      if (*s == '+')
			*s = '\0';
		    }

		  free (save_str);

		  return 1;
		}
	      else
		return 0;
	    }

	  /* The constant was not used for register scaling. Since we have
	     already consumed the token following `*' we now need to put it
	     back in the stream.  */
	  else
	    intel_putback_token ();
	}

      /* Add the constant to the displacement string.  */
      strcat (intel_parser.disp, save_str);
      free (save_str);

      return 1;
    }

  as_bad (_("Unrecognized token '%s'"), cur_token.str);
  return 0;
}

/* Match the given token against cur_token. If they match, read the next
   token from the operand string.  */
static int
intel_match_token (code)
     int code;
{
  if (cur_token.code == code)
    {
      intel_get_token ();
      return 1;
    }
  else
    {
      as_bad (_("Unexpected token `%s'\n"), cur_token.str);
      return 0;
    }
}

/* Read a new token from intel_parser.op_string and store it in cur_token.  */
static void
intel_get_token ()
{
  char *end_op;
  const reg_entry *reg;
  struct intel_token new_token;

  new_token.code = T_NIL;
  new_token.reg = NULL;
  new_token.str = NULL;

  /* Free the memory allocated to the previous token and move
     cur_token to prev_token.  */
  if (prev_token.str)
    free (prev_token.str);

  prev_token = cur_token;

  /* Skip whitespace.  */
  while (is_space_char (*intel_parser.op_string))
    intel_parser.op_string++;

  /* Return an empty token if we find nothing else on the line.  */
  if (*intel_parser.op_string == '\0')
    {
      cur_token = new_token;
      return;
    }

  /* The new token cannot be larger than the remainder of the operand
     string.  */
  new_token.str = (char *) malloc (strlen (intel_parser.op_string) + 1);
  if (new_token.str == NULL)
    abort ();
  new_token.str[0] = '\0';

  if (strchr ("0123456789", *intel_parser.op_string))
    {
      char *p = new_token.str;
      char *q = intel_parser.op_string;
      new_token.code = T_CONST;

      /* Allow any kind of identifier char to encompass floating point and
	 hexadecimal numbers.  */
      while (is_identifier_char (*q))
	*p++ = *q++;
      *p = '\0';

      /* Recognize special symbol names [0-9][bf].  */
      if (strlen (intel_parser.op_string) == 2
	  && (intel_parser.op_string[1] == 'b'
	      || intel_parser.op_string[1] == 'f'))
	new_token.code = T_ID;
    }

  else if (strchr ("+-/*:[]()", *intel_parser.op_string))
    {
      new_token.code = *intel_parser.op_string;
      new_token.str[0] = *intel_parser.op_string;
      new_token.str[1] = '\0';
    }

  else if ((*intel_parser.op_string == REGISTER_PREFIX || allow_naked_reg)
	   && ((reg = parse_register (intel_parser.op_string, &end_op)) != NULL))
    {
      new_token.code = T_REG;
      new_token.reg = reg;

      if (*intel_parser.op_string == REGISTER_PREFIX)
	{
	  new_token.str[0] = REGISTER_PREFIX;
	  new_token.str[1] = '\0';
	}

      strcat (new_token.str, reg->reg_name);
    }

  else if (is_identifier_char (*intel_parser.op_string))
    {
      char *p = new_token.str;
      char *q = intel_parser.op_string;

      /* A '.' or '$' followed by an identifier char is an identifier.
	 Otherwise, it's operator '.' followed by an expression.  */
      if ((*q == '.' || *q == '$') && !is_identifier_char (*(q + 1)))
	{
	  new_token.code = *q;
	  new_token.str[0] = *q;
	  new_token.str[1] = '\0';
	}
      else
	{
	  while (is_identifier_char (*q) || *q == '@@')
	    *p++ = *q++;
	  *p = '\0';

	  if (strcasecmp (new_token.str, "BYTE") == 0)
	    new_token.code = T_BYTE;

	  else if (strcasecmp (new_token.str, "WORD") == 0)
	    new_token.code = T_WORD;

	  else if (strcasecmp (new_token.str, "DWORD") == 0)
	    new_token.code = T_DWORD;

	  else if (strcasecmp (new_token.str, "QWORD") == 0)
	    new_token.code = T_QWORD;

	  else if (strcasecmp (new_token.str, "XWORD") == 0)
	    new_token.code = T_XWORD;

	  else if (strcasecmp (new_token.str, "PTR") == 0)
	    new_token.code = T_PTR;

	  else if (strcasecmp (new_token.str, "SHORT") == 0)
	    new_token.code = T_SHORT;

	  else if (strcasecmp (new_token.str, "OFFSET") == 0)
	    {
	      new_token.code = T_OFFSET;

	      /* ??? This is not mentioned in the MASM grammar but gcc
		     makes use of it with -mintel-syntax.  OFFSET may be
		     followed by FLAT:  */
	      if (strncasecmp (q, " FLAT:", 6) == 0)
		strcat (new_token.str, " FLAT:");
	    }

	  /* ??? This is not mentioned in the MASM grammar.  */
	  else if (strcasecmp (new_token.str, "FLAT") == 0)
	    new_token.code = T_OFFSET;

	  else
	    new_token.code = T_ID;
	}
    }

  else
    as_bad (_("Unrecognized token `%s'\n"), intel_parser.op_string);

  intel_parser.op_string += strlen (new_token.str);
  cur_token = new_token;
}

/* Put cur_token back into the token stream and make cur_token point to
   prev_token.  */
static void
intel_putback_token ()
{
  intel_parser.op_string -= strlen (cur_token.str);
  free (cur_token.str);
  cur_token = prev_token;

  /* Forget prev_token.  */
  prev_token.code = T_NIL;
  prev_token.reg = NULL;
  prev_token.str = NULL;
}
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d29 2
a31 1
#include "safe-ctype.h"
d52 2
a53 17
#ifdef BFD_ASSEMBLER
#define RELOC_ENUM enum bfd_reloc_code_real
#else
#define RELOC_ENUM int
#endif

#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "i386"
#endif

#ifndef INLINE
#if __GNUC__ >= 2
#define INLINE __inline__
#else
#define INLINE
#endif
#endif
d55 7
a61 7
static INLINE unsigned int mode_from_disp_size PARAMS ((unsigned int));
static INLINE int fits_in_signed_byte PARAMS ((offsetT));
static INLINE int fits_in_unsigned_byte PARAMS ((offsetT));
static INLINE int fits_in_unsigned_word PARAMS ((offsetT));
static INLINE int fits_in_signed_word PARAMS ((offsetT));
static INLINE int fits_in_unsigned_long PARAMS ((offsetT));
static INLINE int fits_in_signed_long PARAMS ((offsetT));
d69 7
a75 30
static char *output_invalid PARAMS ((int c));
static int i386_operand PARAMS ((char *operand_string));
static int i386_intel_operand PARAMS ((char *operand_string, int got_a_float));
static const reg_entry *parse_register PARAMS ((char *reg_string,
						char **end_op));
static char *parse_insn PARAMS ((char *, char *));
static char *parse_operands PARAMS ((char *, const char *));
static void swap_operands PARAMS ((void));
static void optimize_imm PARAMS ((void));
static void optimize_disp PARAMS ((void));
static int match_template PARAMS ((void));
static int check_string PARAMS ((void));
static int process_suffix PARAMS ((void));
static int check_byte_reg PARAMS ((void));
static int check_long_reg PARAMS ((void));
static int check_qword_reg PARAMS ((void));
static int check_word_reg PARAMS ((void));
static int finalize_imm PARAMS ((void));
static int process_operands PARAMS ((void));
static const seg_entry *build_modrm_byte PARAMS ((void));
static void output_insn PARAMS ((void));
static void output_branch PARAMS ((void));
static void output_jump PARAMS ((void));
static void output_interseg_jump PARAMS ((void));
static void output_imm PARAMS ((fragS *insn_start_frag,
				offsetT insn_start_off));
static void output_disp PARAMS ((fragS *insn_start_frag,
				 offsetT insn_start_off));
#ifndef I386COFF
static void s_bss PARAMS ((int));
d78 4
a81 1
static const char *default_arch = DEFAULT_ARCH;
d153 1
a153 1
const char extra_symbol_chars[] = "*%-(@@[";
d155 1
a155 1
const char extra_symbol_chars[] = "*%-([";
a157 5
#if (defined (TE_I386AIX)				\
     || ((defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))	\
	 && !defined (TE_LINUX)				\
	 && !defined (TE_FreeBSD)			\
	 && !defined (TE_NetBSD)))
d160 3
d165 4
d178 2
a179 2
const char line_comment_chars[] = "#";

d181 1
a181 6
/* Putting '/' here makes it impossible to use the divide operator.
   However, we need it for compatibility with SVR4 systems.  */
const char comment_chars[] = "#";
#define PREFIX_SEPARATOR '/'

const char line_comment_chars[] = "/#";
d275 1
a275 1
static unsigned int cpu_arch_flags = CpuUnknownFlags | CpuNo64;
a280 3
/* Pre-defined "_GLOBAL_OFFSET_TABLE_".  */
symbolS *GOT_symbol;

d294 1
a294 1
#define SMALL16 (SMALL | CODE16)
d296 1
a296 1
#define BIG16	(BIG | CODE16)
a376 37
const pseudo_typeS md_pseudo_table[] =
{
#if !defined(OBJ_AOUT) && !defined(USE_ALIGN_PTWO)
  {"align", s_align_bytes, 0},
#else
  {"align", s_align_ptwo, 0},
#endif
  {"arch", set_cpu_arch, 0},
#ifndef I386COFF
  {"bss", s_bss, 0},
#endif
  {"ffloat", float_cons, 'f'},
  {"dfloat", float_cons, 'd'},
  {"tfloat", float_cons, 'x'},
  {"value", cons, 2},
  {"noopt", s_ignore, 0},
  {"optim", s_ignore, 0},
  {"code16gcc", set_16bit_gcc_code_flag, CODE_16BIT},
  {"code16", set_code_flag, CODE_16BIT},
  {"code32", set_code_flag, CODE_32BIT},
  {"code64", set_code_flag, CODE_64BIT},
  {"intel_syntax", set_intel_syntax, 1},
  {"att_syntax", set_intel_syntax, 0},
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
  {0, 0, 0}
};

/* For interface with expression ().  */
extern char *input_line_pointer;

/* Hash table for instruction mnemonic lookup.  */
static struct hash_control *op_hash;

/* Hash table for register lookup.  */
static struct hash_control *reg_hash;

d449 4
a452 2
  if (count <= 0 || count > 15)
    return;
d454 1
a454 3
  /* The recommended way to pad 64bit code is to use NOPs preceded by
     maximally four 0x66 prefixes.  Balance the size of nops.  */
  if (flag_code == CODE_64BIT)
d456 1
a456 7
      int i;
      int nnops = (count + 3) / 4;
      int len = count / nnops;
      int remains = count - nnops * len;
      int pos = 0;

      for (i = 0; i < remains; i++)
d458 5
a462 9
	  memset (fragP->fr_literal + fragP->fr_fix + pos, 0x66, len);
	  fragP->fr_literal[fragP->fr_fix + pos + len] = 0x90;
	  pos += len + 1;
	}
      for (; i < nnops; i++)
	{
	  memset (fragP->fr_literal + fragP->fr_fix + pos, 0x66, len - 1);
	  fragP->fr_literal[fragP->fr_fix + pos + len - 1] = 0x90;
	  pos += len;
d464 4
a468 13
  else
    if (flag_code == CODE_16BIT)
      {
	memcpy (fragP->fr_literal + fragP->fr_fix,
		f16_patt[count - 1], count);
	if (count > 8)
	  /* Adjust jump offset.  */
	  fragP->fr_literal[fragP->fr_fix + 1] = count - 2;
      }
    else
      memcpy (fragP->fr_literal + fragP->fr_fix,
	      f32_patt[count - 1], count);
  fragP->fr_var = count;
d471 12
d543 2
a544 1
  if (cpu_arch_flags != (Cpu086 | Cpu186 | Cpu286 | Cpu386 | Cpu486 | CpuNo64))
d611 1
a611 2
  if (prefix >= REX_OPCODE && prefix < REX_OPCODE + 16
      && flag_code == CODE_64BIT)
d649 1
a649 1
  if (i.prefix[q] != 0)
d696 1
a696 1
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
d733 1
a733 1
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
d759 1
a759 1
      && !is_end_of_line[(unsigned char) input_line_pointer[1]])
d777 37
d836 2
a837 2
    const template *optab;
    templates *core_optab;
d873 1
a873 1
    const reg_entry *regtab;
d889 2
a890 2
    int c;
    char *p;
d894 1
a894 1
	if (ISDIGIT (c))
d901 1
a901 1
	else if (ISLOWER (c))
d907 1
a907 1
	else if (ISUPPER (c))
d909 1
a909 1
	    mnemonic_chars[c] = TOLOWER (c);
d914 1
a914 1
	if (ISALPHA (c) || ISDIGIT (c))
d979 1
a979 4
	   (x->rex & REX_MODE64) != 0,
	   (x->rex & REX_EXTX) != 0,
	   (x->rex & REX_EXTY) != 0,
	   (x->rex & REX_EXTZ) != 0);
d1054 1
a1054 1
static const type_names[] =
d1094 1
a1094 1
  const struct type_name *ty;
d1104 15
a1119 2
static bfd_reloc_code_real_type reloc
  PARAMS ((int, int, int, bfd_reloc_code_real_type));
d1173 1
a1173 1
     fixS *fixP ATTRIBUTE_UNUSED;
d1176 4
a1179 8
  if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
    return 1;

  /* Don't adjust pc-relative references to merge sections in 64-bit
     mode.  */
  if (use_rela_relocations
      && (S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0
      && fixP->fx_pcrel)
d1181 1
a1181 1

a1185 8
      || fixP->fx_r_type == BFD_RELOC_386_TLS_GD
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LDM
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LDO_32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_IE_32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_IE
      || fixP->fx_r_type == BFD_RELOC_386_TLS_GOTIE
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LE_32
      || fixP->fx_r_type == BFD_RELOC_386_TLS_LE
a1188 5
      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSGD
      || fixP->fx_r_type == BFD_RELOC_X86_64_TLSLD
      || fixP->fx_r_type == BFD_RELOC_X86_64_DTPOFF32
      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTTPOFF
      || fixP->fx_r_type == BFD_RELOC_X86_64_TPOFF32
a1191 1
#endif
a1195 1
#define BFD_RELOC_8			0
a1197 1
#define BFD_RELOC_8_PCREL		0
a1202 8
#define BFD_RELOC_386_TLS_GD		0
#define BFD_RELOC_386_TLS_LDM		0
#define BFD_RELOC_386_TLS_LDO_32	0
#define BFD_RELOC_386_TLS_IE_32		0
#define BFD_RELOC_386_TLS_IE		0
#define BFD_RELOC_386_TLS_GOTIE		0
#define BFD_RELOC_386_TLS_LE_32		0
#define BFD_RELOC_386_TLS_LE		0
a1205 5
#define BFD_RELOC_X86_64_TLSGD		0
#define BFD_RELOC_X86_64_TLSLD		0
#define BFD_RELOC_X86_64_DTPOFF32	0
#define BFD_RELOC_X86_64_GOTTPOFF	0
#define BFD_RELOC_X86_64_TPOFF32	0
d1208 1
a1208 1
static int intel_float_operand PARAMS ((const char *mnemonic));
d1212 1
a1212 1
     const char *mnemonic;
d1231 3
d1235 1
d1249 7
d1257 29
a1285 7
  line = parse_insn (line, mnemonic);
  if (line == NULL)
    return;

  line = parse_operands (line, mnemonic);
  if (line == NULL)
    return;
d1287 2
a1288 2
  /* Now we've parsed the mnemonic into a set of templates, and have the
     operands at hand.  */
d1290 30
a1319 10
  /* All intel opcodes have reversed operands except for "bound" and
     "enter".  We also don't reverse intersegment "jmp" and "call"
     instructions with 2 immediate operands so that the immediate segment
     precedes the offset, as it does when in AT&T mode.  "enter" and the
     intersegment "jmp" and "call" instructions are the only ones that
     have two immediate operands.  */
  if (intel_syntax && i.operands > 1
      && (strcmp (mnemonic, "bound") != 0)
      && !((i.types[0] & Imm) && (i.types[1] & Imm)))
    swap_operands ();
d1321 21
a1341 2
  if (i.imm_operands)
    optimize_imm ();
d1343 19
a1361 2
  if (i.disp_operands)
    optimize_disp ();
d1363 14
a1376 3
  /* Next, we find a template that matches the given insn,
     making sure the overlap of the given operands types is consistent
     with the template operand types.  */
d1378 8
a1385 2
  if (!match_template ())
    return;
d1387 5
a1391 6
  if (intel_syntax)
    {
      /* Undo SYSV386_COMPAT brokenness when in Intel mode.  See i386.h  */
      if (SYSV386_COMPAT
	  && (i.tm.base_opcode & 0xfffffde0) == 0xdce0)
	i.tm.base_opcode ^= FloatR;
d1393 2
a1394 6
      /* Zap movzx and movsx suffix.  The suffix may have been set from
	 "word ptr" or "byte ptr" on the source operand, but we'll use
	 the suffix later to choose the destination register.  */
      if ((i.tm.base_opcode & ~9) == 0x0fb6)
	i.suffix = 0;
    }
d1396 92
a1487 3
  if (i.tm.opcode_modifier & FWait)
    if (!add_prefix (FWAIT_OPCODE))
      return;
d1489 14
a1502 6
  /* Check string instruction segment overrides.  */
  if ((i.tm.opcode_modifier & IsString) != 0 && i.mem_operands != 0)
    {
      if (!check_string ())
	return;
    }
d1504 2
a1505 2
  if (!process_suffix ())
    return;
d1507 3
a1509 32
  /* Make still unresolved immediate matches conform to size of immediate
     given in i.suffix.  */
  if (!finalize_imm ())
    return;

  if (i.types[0] & Imm1)
    i.imm_operands = 0;	/* kludge for shift insns.  */
  if (i.types[0] & ImplicitRegister)
    i.reg_operands--;
  if (i.types[1] & ImplicitRegister)
    i.reg_operands--;
  if (i.types[2] & ImplicitRegister)
    i.reg_operands--;

  if (i.tm.opcode_modifier & ImmExt)
    {
      /* These AMD 3DNow! and Intel Katmai New Instructions have an
	 opcode suffix which is coded in the same place as an 8-bit
	 immediate field would be.  Here we fake an 8-bit immediate
	 operand from the opcode suffix stored in tm.extension_opcode.  */

      expressionS *exp;

      assert (i.imm_operands == 0 && i.operands <= 2 && 2 < MAX_OPERANDS);

      exp = &im_expressions[i.imm_operands++];
      i.op[i.operands].imms = exp;
      i.types[i.operands++] = Imm8;
      exp->X_op = O_constant;
      exp->X_add_number = i.tm.extension_opcode;
      i.tm.extension_opcode = None;
    }
d1511 3
a1513 11
  /* For insns with operands there are more diddles to do to the opcode.  */
  if (i.operands)
    {
      if (!process_operands ())
	return;
    }
  else if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
    {
      /* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */
      as_warn (_("translating to `%sp'"), i.tm.name);
    }
d1515 7
a1521 6
  /* Handle conversion of 'int $3' --> special int3 insn.  */
  if (i.tm.base_opcode == INT_OPCODE && i.op[0].imms->X_add_number == 3)
    {
      i.tm.base_opcode = INT3_OPCODE;
      i.imm_operands = 0;
    }
d1523 21
a1543 9
  if ((i.tm.opcode_modifier & (Jump | JumpByte | JumpDword))
      && i.op[0].disps->X_op == O_constant)
    {
      /* Convert "jmp constant" (and "call constant") to a jump (call) to
	 the absolute address given by the constant.  Since ix86 jumps and
	 calls are pc relative, we need to generate a reloc.  */
      i.op[0].disps->X_add_symbol = &abs_symbol;
      i.op[0].disps->X_op = O_symbol;
    }
d1545 19
a1563 2
  if ((i.tm.opcode_modifier & Rex64) != 0)
    i.rex |= REX_MODE64;
d1565 8
a1572 12
  /* For 8 bit registers we need an empty rex prefix.  Also if the
     instruction already has a prefix, we need to convert old
     registers to new ones.  */

  if (((i.types[0] & Reg8) != 0
       && (i.op[0].regs->reg_flags & RegRex64) != 0)
      || ((i.types[1] & Reg8) != 0
	  && (i.op[1].regs->reg_flags & RegRex64) != 0)
      || (((i.types[0] & Reg8) != 0 || (i.types[1] & Reg8) != 0)
	  && i.rex != 0))
    {
      int x;
d1574 31
a1604 27
      i.rex |= REX_OPCODE;
      for (x = 0; x < 2; x++)
	{
	  /* Look for 8 bit operand that uses old registers.  */
	  if ((i.types[x] & Reg8) != 0
	      && (i.op[x].regs->reg_flags & RegRex64) == 0)
	    {
	      /* In case it is "hi" register, give up.  */
	      if (i.op[x].regs->reg_num > 3)
		as_bad (_("can't encode register '%%%s' in an instruction requiring REX prefix.\n"),
			i.op[x].regs->reg_name);

	      /* Otherwise it is equivalent to the extended register.
		 Since the encoding doesn't change this is merely
		 cosmetic cleanup for debug output.  */

	      i.op[x].regs = i.op[x].regs + 8;
	    }
	}
    }

  if (i.rex != 0)
    add_prefix (REX_OPCODE | i.rex);

  /* We are ready to output the insn.  */
  output_insn ();
}
d1606 2
a1607 19
static char *
parse_insn (line, mnemonic)
     char *line;
     char *mnemonic;
{
  char *l = line;
  char *token_start = l;
  char *mnem_p;

  /* Non-zero if we found a prefix only acceptable with string insns.  */
  const char *expecting_string_instruction = NULL;

  while (1)
    {
      mnem_p = mnemonic;
      while ((*mnem_p = mnemonic_chars[(unsigned char) *l]) != 0)
	{
	  mnem_p++;
	  if (mnem_p >= mnemonic + MAX_MNEM_SIZE)
d1609 16
a1624 22
	      as_bad (_("no such instruction: `%s'"), token_start);
	      return NULL;
	    }
	  l++;
	}
      if (!is_space_char (*l)
	  && *l != END_OF_INSN
	  && *l != PREFIX_SEPARATOR
	  && *l != ',')
	{
	  as_bad (_("invalid character %s in mnemonic"),
		  output_invalid (*l));
	  return NULL;
	}
      if (token_start == l)
	{
	  if (*l == PREFIX_SEPARATOR)
	    as_bad (_("expecting prefix; got nothing"));
	  else
	    as_bad (_("expecting mnemonic; got nothing"));
	  return NULL;
	}
d1626 47
a1672 18
      /* Look up instruction (or prefix) via hash table.  */
      current_templates = hash_find (op_hash, mnemonic);

      if (*l != END_OF_INSN
	  && (!is_space_char (*l) || l[1] != END_OF_INSN)
	  && current_templates
	  && (current_templates->start->opcode_modifier & IsPrefix))
	{
	  /* If we are in 16-bit mode, do not allow addr16 or data16.
	     Similarly, in 32-bit mode, do not allow addr32 or data32.  */
	  if ((current_templates->start->opcode_modifier & (Size16 | Size32))
	      && flag_code != CODE_64BIT
	      && (((current_templates->start->opcode_modifier & Size32) != 0)
		  ^ (flag_code == CODE_16BIT)))
	    {
	      as_bad (_("redundant %s prefix"),
		      current_templates->start->name);
	      return NULL;
d1674 1
a1674 15
	  /* Add prefix, checking for repeated prefixes.  */
	  switch (add_prefix (current_templates->start->base_opcode))
	    {
	    case 0:
	      return NULL;
	    case 2:
	      expecting_string_instruction = current_templates->start->name;
	      break;
	    }
	  /* Skip past PREFIX_SEPARATOR and reset token_start.  */
	  token_start = ++l;
	}
      else
	break;
    }
d1676 4
a1679 21
  if (!current_templates)
    {
      /* See if we can get a match by trimming off a suffix.  */
      switch (mnem_p[-1])
	{
	case WORD_MNEM_SUFFIX:
	case BYTE_MNEM_SUFFIX:
	case QWORD_MNEM_SUFFIX:
	  i.suffix = mnem_p[-1];
	  mnem_p[-1] = '\0';
	  current_templates = hash_find (op_hash, mnemonic);
	  break;
	case SHORT_MNEM_SUFFIX:
	case LONG_MNEM_SUFFIX:
	  if (!intel_syntax)
	    {
	      i.suffix = mnem_p[-1];
	      mnem_p[-1] = '\0';
	      current_templates = hash_find (op_hash, mnemonic);
	    }
	  break;
d1681 3
a1683 3
	  /* Intel Syntax.  */
	case 'd':
	  if (intel_syntax)
d1685 1
a1685 15
	      if (intel_float_operand (mnemonic))
		i.suffix = SHORT_MNEM_SUFFIX;
	      else
		i.suffix = LONG_MNEM_SUFFIX;
	      mnem_p[-1] = '\0';
	      current_templates = hash_find (op_hash, mnemonic);
	    }
	  break;
	}
      if (!current_templates)
	{
	  as_bad (_("no such instruction: `%s'"), token_start);
	  return NULL;
	}
    }
d1687 6
a1692 31
  if (current_templates->start->opcode_modifier & (Jump | JumpByte))
    {
      /* Check for a branch hint.  We allow ",pt" and ",pn" for
	 predict taken and predict not taken respectively.
	 I'm not sure that branch hints actually do anything on loop
	 and jcxz insns (JumpByte) for current Pentium4 chips.  They
	 may work in the future and it doesn't hurt to accept them
	 now.  */
      if (l[0] == ',' && l[1] == 'p')
	{
	  if (l[2] == 't')
	    {
	      if (!add_prefix (DS_PREFIX_OPCODE))
		return NULL;
	      l += 3;
	    }
	  else if (l[2] == 'n')
	    {
	      if (!add_prefix (CS_PREFIX_OPCODE))
		return NULL;
	      l += 3;
	    }
	}
    }
  /* Any other comma loses.  */
  if (*l == ',')
    {
      as_bad (_("invalid character %s in mnemonic"),
	      output_invalid (*l));
      return NULL;
    }
d1694 11
a1704 56
  /* Check if instruction is supported on specified architecture.  */
  if ((current_templates->start->cpu_flags & ~(Cpu64 | CpuNo64))
      & ~(cpu_arch_flags & ~(Cpu64 | CpuNo64)))
    {
      as_warn (_("`%s' is not supported on `%s'"),
	       current_templates->start->name, cpu_arch_name);
    }
  else if ((Cpu386 & ~cpu_arch_flags) && (flag_code != CODE_16BIT))
    {
      as_warn (_("use .code16 to ensure correct addressing mode"));
    }

  /* Check for rep/repne without a string instruction.  */
  if (expecting_string_instruction
      && !(current_templates->start->opcode_modifier & IsString))
    {
      as_bad (_("expecting string instruction after `%s'"),
	      expecting_string_instruction);
      return NULL;
    }

  return l;
}

static char *
parse_operands (l, mnemonic)
     char *l;
     const char *mnemonic;
{
  char *token_start;

  /* 1 if operand is pending after ','.  */
  unsigned int expecting_operand = 0;

  /* Non-zero if operand parens not balanced.  */
  unsigned int paren_not_balanced;

  while (*l != END_OF_INSN)
    {
      /* Skip optional white space before operand.  */
      if (is_space_char (*l))
	++l;
      if (!is_operand_char (*l) && *l != END_OF_INSN)
	{
	  as_bad (_("invalid character %s before operand %d"),
		  output_invalid (*l),
		  i.operands + 1);
	  return NULL;
	}
      token_start = l;	/* after white space */
      paren_not_balanced = 0;
      while (paren_not_balanced || *l != ',')
	{
	  if (*l == END_OF_INSN)
	    {
	      if (paren_not_balanced)
d1706 4
a1709 7
		  if (!intel_syntax)
		    as_bad (_("unbalanced parenthesis in operand %d."),
			    i.operands + 1);
		  else
		    as_bad (_("unbalanced brackets in operand %d."),
			    i.operands + 1);
		  return NULL;
d1711 3
a1713 2
	      else
		break;	/* we are done */
d1715 1
a1715 35
	  else if (!is_operand_char (*l) && !is_space_char (*l))
	    {
	      as_bad (_("invalid character %s in operand %d"),
		      output_invalid (*l),
		      i.operands + 1);
	      return NULL;
	    }
	  if (!intel_syntax)
	    {
	      if (*l == '(')
		++paren_not_balanced;
	      if (*l == ')')
		--paren_not_balanced;
	    }
	  else
	    {
	      if (*l == '[')
		++paren_not_balanced;
	      if (*l == ']')
		--paren_not_balanced;
	    }
	  l++;
	}
      if (l != token_start)
	{			/* Yes, we've read in another operand.  */
	  unsigned int operand_ok;
	  this_operand = i.operands++;
	  if (i.operands > MAX_OPERANDS)
	    {
	      as_bad (_("spurious operands; (%d operands/instruction max)"),
		      MAX_OPERANDS);
	      return NULL;
	    }
	  /* Now parse operand adding info to 'i' as we go along.  */
	  END_STRING_AND_SAVE (l);
d1717 23
a1739 25
	  if (intel_syntax)
	    operand_ok =
	      i386_intel_operand (token_start,
				  intel_float_operand (mnemonic));
	  else
	    operand_ok = i386_operand (token_start);

	  RESTORE_END_STRING (l);
	  if (!operand_ok)
	    return NULL;
	}
      else
	{
	  if (expecting_operand)
	    {
	    expecting_operand_after_comma:
	      as_bad (_("expecting operand after ','; got nothing"));
	      return NULL;
	    }
	  if (*l == ',')
	    {
	      as_bad (_("expecting operand before ','; got nothing"));
	      return NULL;
	    }
	}
d1741 9
a1749 13
      /* Now *l must be either ',' or END_OF_INSN.  */
      if (*l == ',')
	{
	  if (*++l == END_OF_INSN)
	    {
	      /* Just skip it, if it's \n complain.  */
	      goto expecting_operand_after_comma;
	    }
	  expecting_operand = 1;
	}
    }
  return l;
}
d1751 6
a1756 65
static void
swap_operands ()
{
  union i386_op temp_op;
  unsigned int temp_type;
  RELOC_ENUM temp_reloc;
  int xchg1 = 0;
  int xchg2 = 0;

  if (i.operands == 2)
    {
      xchg1 = 0;
      xchg2 = 1;
    }
  else if (i.operands == 3)
    {
      xchg1 = 0;
      xchg2 = 2;
    }
  temp_type = i.types[xchg2];
  i.types[xchg2] = i.types[xchg1];
  i.types[xchg1] = temp_type;
  temp_op = i.op[xchg2];
  i.op[xchg2] = i.op[xchg1];
  i.op[xchg1] = temp_op;
  temp_reloc = i.reloc[xchg2];
  i.reloc[xchg2] = i.reloc[xchg1];
  i.reloc[xchg1] = temp_reloc;

  if (i.mem_operands == 2)
    {
      const seg_entry *temp_seg;
      temp_seg = i.seg[0];
      i.seg[0] = i.seg[1];
      i.seg[1] = temp_seg;
    }
}

/* Try to ensure constant immediates are represented in the smallest
   opcode possible.  */
static void
optimize_imm ()
{
  char guess_suffix = 0;
  int op;

  if (i.suffix)
    guess_suffix = i.suffix;
  else if (i.reg_operands)
    {
      /* Figure out a suffix from the last register operand specified.
	 We can't do this properly yet, ie. excluding InOutPortReg,
	 but the following works for instructions with immediates.
	 In any case, we can't set i.suffix yet.  */
      for (op = i.operands; --op >= 0;)
	if (i.types[op] & Reg)
	  {
	    if (i.types[op] & Reg8)
	      guess_suffix = BYTE_MNEM_SUFFIX;
	    else if (i.types[op] & Reg16)
	      guess_suffix = WORD_MNEM_SUFFIX;
	    else if (i.types[op] & Reg32)
	      guess_suffix = LONG_MNEM_SUFFIX;
	    else if (i.types[op] & Reg64)
	      guess_suffix = QWORD_MNEM_SUFFIX;
a1758 3
    }
  else if ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0))
    guess_suffix = WORD_MNEM_SUFFIX;
d1760 2
a1761 4
  for (op = i.operands; --op >= 0;)
    if (i.types[op] & Imm)
      {
	switch (i.op[op].imms->X_op)
d1763 13
a1775 3
	  case O_constant:
	    /* If a suffix is given, this operand may be shortened.  */
	    switch (guess_suffix)
d1777 3
a1779 10
	      case LONG_MNEM_SUFFIX:
		i.types[op] |= Imm32 | Imm64;
		break;
	      case WORD_MNEM_SUFFIX:
		i.types[op] |= Imm16 | Imm32S | Imm32 | Imm64;
		break;
	      case BYTE_MNEM_SUFFIX:
		i.types[op] |= Imm16 | Imm8 | Imm8S | Imm32S | Imm32 | Imm64;
		break;
	      }
d1781 16
a1796 10
	    /* If this operand is at most 16 bits, convert it
	       to a signed 16 bit number before trying to see
	       whether it will fit in an even smaller size.
	       This allows a 16-bit operand such as $0xffe0 to
	       be recognised as within Imm8S range.  */
	    if ((i.types[op] & Imm16)
		&& (i.op[op].imms->X_add_number & ~(offsetT) 0xffff) == 0)
	      {
		i.op[op].imms->X_add_number =
		  (((i.op[op].imms->X_add_number & 0xffff) ^ 0x8000) - 0x8000);
d1798 2
a1799 3
	    if ((i.types[op] & Imm32)
		&& ((i.op[op].imms->X_add_number & ~(((offsetT) 2 << 31) - 1))
		    == 0))
d1801 10
a1810 5
		i.op[op].imms->X_add_number = ((i.op[op].imms->X_add_number
						^ ((offsetT) 1 << 31))
					       - ((offsetT) 1 << 31));
	      }
	    i.types[op] |= smallest_imm_type (i.op[op].imms->X_add_number);
d1812 1
a1812 29
	    /* We must avoid matching of Imm32 templates when 64bit
	       only immediate is available.  */
	    if (guess_suffix == QWORD_MNEM_SUFFIX)
	      i.types[op] &= ~Imm32;
	    break;

	  case O_absent:
	  case O_register:
	    abort ();

	    /* Symbols and expressions.  */
	  default:
	    /* Convert symbolic operand to proper sizes for matching.  */
	    switch (guess_suffix)
	      {
	      case QWORD_MNEM_SUFFIX:
		i.types[op] = Imm64 | Imm32S;
		break;
	      case LONG_MNEM_SUFFIX:
		i.types[op] = Imm32 | Imm64;
		break;
	      case WORD_MNEM_SUFFIX:
		i.types[op] = Imm16 | Imm32 | Imm64;
		break;
		break;
	      case BYTE_MNEM_SUFFIX:
		i.types[op] = Imm8 | Imm8S | Imm16 | Imm32S | Imm32;
		break;
		break;
d1814 2
a1815 1
	    break;
d1817 1
a1817 15
      }
}

/* Try to use the smallest displacement type too.  */
static void
optimize_disp ()
{
  int op;

  for (op = i.operands; --op >= 0;)
    if ((i.types[op] & Disp) && i.op[op].disps->X_op == O_constant)
      {
	offsetT disp = i.op[op].disps->X_add_number;

	if (i.types[op] & Disp16)
d1819 2
a1820 6
	    /* We know this operand is at most 16 bits, so
	       convert to a signed 16 bit number before trying
	       to see whether it will fit in an even smaller
	       size.  */

	    disp = (((disp & 0xffff) ^ 0x8000) - 0x8000);
d1822 2
a1823 18
	else if (i.types[op] & Disp32)
	  {
	    /* We know this operand is at most 32 bits, so convert to a
	       signed 32 bit number before trying to see whether it will
	       fit in an even smaller size.  */
	    disp &= (((offsetT) 2 << 31) - 1);
	    disp = (disp ^ ((offsetT) 1 << 31)) - ((addressT) 1 << 31);
	  }
	if (flag_code == CODE_64BIT)
	  {
	    if (fits_in_signed_long (disp))
	      i.types[op] |= Disp32S;
	    if (fits_in_unsigned_long (disp))
	      i.types[op] |= Disp32;
	  }
	if ((i.types[op] & (Disp32 | Disp32S | Disp16))
	    && fits_in_signed_byte (disp))
	  i.types[op] |= Disp8;
d1825 1
a1825 407
}

static int
match_template ()
{
  /* Points to template once we've found it.  */
  const template *t;
  unsigned int overlap0, overlap1, overlap2;
  unsigned int found_reverse_match;
  int suffix_check;

#define MATCH(overlap, given, template)				\
  ((overlap & ~JumpAbsolute)					\
   && (((given) & (BaseIndex | JumpAbsolute))			\
       == ((overlap) & (BaseIndex | JumpAbsolute))))

  /* If given types r0 and r1 are registers they must be of the same type
     unless the expected operand type register overlap is null.
     Note that Acc in a template matches every size of reg.  */
#define CONSISTENT_REGISTER_MATCH(m0, g0, t0, m1, g1, t1)	\
  (((g0) & Reg) == 0 || ((g1) & Reg) == 0			\
   || ((g0) & Reg) == ((g1) & Reg)				\
   || ((((m0) & Acc) ? Reg : (t0)) & (((m1) & Acc) ? Reg : (t1)) & Reg) == 0 )

  overlap0 = 0;
  overlap1 = 0;
  overlap2 = 0;
  found_reverse_match = 0;
  suffix_check = (i.suffix == BYTE_MNEM_SUFFIX
		  ? No_bSuf
		  : (i.suffix == WORD_MNEM_SUFFIX
		     ? No_wSuf
		     : (i.suffix == SHORT_MNEM_SUFFIX
			? No_sSuf
			: (i.suffix == LONG_MNEM_SUFFIX
			   ? No_lSuf
			   : (i.suffix == QWORD_MNEM_SUFFIX
			      ? No_qSuf
			      : (i.suffix == LONG_DOUBLE_MNEM_SUFFIX
				 ? No_xSuf : 0))))));

  for (t = current_templates->start;
       t < current_templates->end;
       t++)
    {
      /* Must have right number of operands.  */
      if (i.operands != t->operands)
	continue;

      /* Check the suffix, except for some instructions in intel mode.  */
      if ((t->opcode_modifier & suffix_check)
	  && !(intel_syntax
	       && (t->opcode_modifier & IgnoreSize))
	  && !(intel_syntax
	       && t->base_opcode == 0xd9
	       && (t->extension_opcode == 5	     /* 0xd9,5 "fldcw"  */
		   || t->extension_opcode == 7)))  /* 0xd9,7 "f{n}stcw"  */
	continue;

      /* Do not verify operands when there are none.  */
      else if (!t->operands)
	{
	  if (t->cpu_flags & ~cpu_arch_flags)
	    continue;
	  /* We've found a match; break out of loop.  */
	  break;
	}

      overlap0 = i.types[0] & t->operand_types[0];
      switch (t->operands)
	{
	case 1:
	  if (!MATCH (overlap0, i.types[0], t->operand_types[0]))
	    continue;
	  break;
	case 2:
	case 3:
	  overlap1 = i.types[1] & t->operand_types[1];
	  if (!MATCH (overlap0, i.types[0], t->operand_types[0])
	      || !MATCH (overlap1, i.types[1], t->operand_types[1])
	      || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
					     t->operand_types[0],
					     overlap1, i.types[1],
					     t->operand_types[1]))
	    {
	      /* Check if other direction is valid ...  */
	      if ((t->opcode_modifier & (D | FloatD)) == 0)
		continue;

	      /* Try reversing direction of operands.  */
	      overlap0 = i.types[0] & t->operand_types[1];
	      overlap1 = i.types[1] & t->operand_types[0];
	      if (!MATCH (overlap0, i.types[0], t->operand_types[1])
		  || !MATCH (overlap1, i.types[1], t->operand_types[0])
		  || !CONSISTENT_REGISTER_MATCH (overlap0, i.types[0],
						 t->operand_types[1],
						 overlap1, i.types[1],
						 t->operand_types[0]))
		{
		  /* Does not match either direction.  */
		  continue;
		}
	      /* found_reverse_match holds which of D or FloatDR
		 we've found.  */
	      found_reverse_match = t->opcode_modifier & (D | FloatDR);
	    }
	  /* Found a forward 2 operand match here.  */
	  else if (t->operands == 3)
	    {
	      /* Here we make use of the fact that there are no
		 reverse match 3 operand instructions, and all 3
		 operand instructions only need to be checked for
		 register consistency between operands 2 and 3.  */
	      overlap2 = i.types[2] & t->operand_types[2];
	      if (!MATCH (overlap2, i.types[2], t->operand_types[2])
		  || !CONSISTENT_REGISTER_MATCH (overlap1, i.types[1],
						 t->operand_types[1],
						 overlap2, i.types[2],
						 t->operand_types[2]))

		continue;
	    }
	  /* Found either forward/reverse 2 or 3 operand match here:
	     slip through to break.  */
	}
      if (t->cpu_flags & ~cpu_arch_flags)
	{
	  found_reverse_match = 0;
	  continue;
	}
      /* We've found a match; break out of loop.  */
      break;
    }

  if (t == current_templates->end)
    {
      /* We found no match.  */
      as_bad (_("suffix or operands invalid for `%s'"),
	      current_templates->start->name);
      return 0;
    }

  if (!quiet_warnings)
    {
      if (!intel_syntax
	  && ((i.types[0] & JumpAbsolute)
	      != (t->operand_types[0] & JumpAbsolute)))
	{
	  as_warn (_("indirect %s without `*'"), t->name);
	}

      if ((t->opcode_modifier & (IsPrefix | IgnoreSize))
	  == (IsPrefix | IgnoreSize))
	{
	  /* Warn them that a data or address size prefix doesn't
	     affect assembly of the next line of code.  */
	  as_warn (_("stand-alone `%s' prefix"), t->name);
	}
    }

  /* Copy the template we found.  */
  i.tm = *t;
  if (found_reverse_match)
    {
      /* If we found a reverse match we must alter the opcode
	 direction bit.  found_reverse_match holds bits to change
	 (different for int & float insns).  */

      i.tm.base_opcode ^= found_reverse_match;

      i.tm.operand_types[0] = t->operand_types[1];
      i.tm.operand_types[1] = t->operand_types[0];
    }

  return 1;
}

static int
check_string ()
{
  int mem_op = (i.types[0] & AnyMem) ? 0 : 1;
  if ((i.tm.operand_types[mem_op] & EsSeg) != 0)
    {
      if (i.seg[0] != NULL && i.seg[0] != &es)
	{
	  as_bad (_("`%s' operand %d must use `%%es' segment"),
		  i.tm.name,
		  mem_op + 1);
	  return 0;
	}
      /* There's only ever one segment override allowed per instruction.
	 This instruction possibly has a legal segment override on the
	 second operand, so copy the segment to where non-string
	 instructions store it, allowing common code.  */
      i.seg[0] = i.seg[1];
    }
  else if ((i.tm.operand_types[mem_op + 1] & EsSeg) != 0)
    {
      if (i.seg[1] != NULL && i.seg[1] != &es)
	{
	  as_bad (_("`%s' operand %d must use `%%es' segment"),
		  i.tm.name,
		  mem_op + 2);
	  return 0;
	}
    }
  return 1;
}

static int
process_suffix ()
{
  /* If matched instruction specifies an explicit instruction mnemonic
     suffix, use it.  */
  if (i.tm.opcode_modifier & (Size16 | Size32 | Size64))
    {
      if (i.tm.opcode_modifier & Size16)
	i.suffix = WORD_MNEM_SUFFIX;
      else if (i.tm.opcode_modifier & Size64)
	i.suffix = QWORD_MNEM_SUFFIX;
      else
	i.suffix = LONG_MNEM_SUFFIX;
    }
  else if (i.reg_operands)
    {
      /* If there's no instruction mnemonic suffix we try to invent one
	 based on register operands.  */
      if (!i.suffix)
	{
	  /* We take i.suffix from the last register operand specified,
	     Destination register type is more significant than source
	     register type.  */
	  int op;
	  for (op = i.operands; --op >= 0;)
	    if ((i.types[op] & Reg)
		&& !(i.tm.operand_types[op] & InOutPortReg))
	      {
		i.suffix = ((i.types[op] & Reg8) ? BYTE_MNEM_SUFFIX :
			    (i.types[op] & Reg16) ? WORD_MNEM_SUFFIX :
			    (i.types[op] & Reg64) ? QWORD_MNEM_SUFFIX :
			    LONG_MNEM_SUFFIX);
		break;
	      }
	}
      else if (i.suffix == BYTE_MNEM_SUFFIX)
	{
	  if (!check_byte_reg ())
	    return 0;
	}
      else if (i.suffix == LONG_MNEM_SUFFIX)
	{
	  if (!check_long_reg ())
	    return 0;
	}
      else if (i.suffix == QWORD_MNEM_SUFFIX)
	{
	  if (!check_qword_reg ())
	    return 0;
	}
      else if (i.suffix == WORD_MNEM_SUFFIX)
	{
	  if (!check_word_reg ())
	    return 0;
	}
      else if (intel_syntax && (i.tm.opcode_modifier & IgnoreSize))
	/* Do nothing if the instruction is going to ignore the prefix.  */
	;
      else
	abort ();
    }
  else if ((i.tm.opcode_modifier & DefaultSize) && !i.suffix)
    {
      i.suffix = stackop_size;
    }

  /* Change the opcode based on the operand size given by i.suffix;
     We need not change things for byte insns.  */

  if (!i.suffix && (i.tm.opcode_modifier & W))
    {
      as_bad (_("no instruction mnemonic suffix given and no register operands; can't size instruction"));
      return 0;
    }

  if (i.suffix && i.suffix != BYTE_MNEM_SUFFIX)
    {
      /* It's not a byte, select word/dword operation.  */
      if (i.tm.opcode_modifier & W)
	{
	  if (i.tm.opcode_modifier & ShortForm)
	    i.tm.base_opcode |= 8;
	  else
	    i.tm.base_opcode |= 1;
	}

      /* Now select between word & dword operations via the operand
	 size prefix, except for instructions that will ignore this
	 prefix anyway.  */
      if (i.suffix != QWORD_MNEM_SUFFIX
	  && !(i.tm.opcode_modifier & IgnoreSize)
	  && ((i.suffix == LONG_MNEM_SUFFIX) == (flag_code == CODE_16BIT)
	      || (flag_code == CODE_64BIT
		  && (i.tm.opcode_modifier & JumpByte))))
	{
	  unsigned int prefix = DATA_PREFIX_OPCODE;
	  if (i.tm.opcode_modifier & JumpByte) /* jcxz, loop */
	    prefix = ADDR_PREFIX_OPCODE;

	  if (!add_prefix (prefix))
	    return 0;
	}

      /* Set mode64 for an operand.  */
      if (i.suffix == QWORD_MNEM_SUFFIX
	  && flag_code == CODE_64BIT
	  && (i.tm.opcode_modifier & NoRex64) == 0)
	i.rex |= REX_MODE64;

      /* Size floating point instruction.  */
      if (i.suffix == LONG_MNEM_SUFFIX)
	{
	  if (i.tm.opcode_modifier & FloatMF)
	    i.tm.base_opcode ^= 4;
	}
    }

  return 1;
}

static int
check_byte_reg ()
{
  int op;
  for (op = i.operands; --op >= 0;)
    {
      /* If this is an eight bit register, it's OK.  If it's the 16 or
	 32 bit version of an eight bit register, we will just use the
	 low portion, and that's OK too.  */
      if (i.types[op] & Reg8)
	continue;

      /* movzx and movsx should not generate this warning.  */
      if (intel_syntax
	  && (i.tm.base_opcode == 0xfb7
	      || i.tm.base_opcode == 0xfb6
	      || i.tm.base_opcode == 0x63
	      || i.tm.base_opcode == 0xfbe
	      || i.tm.base_opcode == 0xfbf))
	continue;

      if ((i.types[op] & WordReg) && i.op[op].regs->reg_num < 4
#if 0
	  /* Check that the template allows eight bit regs.  This
	     kills insns such as `orb $1,%edx', which maybe should be
	     allowed.  */
	  && (i.tm.operand_types[op] & (Reg8 | InOutPortReg))
#endif
	  )
	{
	  /* Prohibit these changes in the 64bit mode, since the
	     lowering is more complicated.  */
	  if (flag_code == CODE_64BIT
	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
	    {
	      as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		      i.op[op].regs->reg_name,
		      i.suffix);
	      return 0;
	    }
#if REGISTER_WARNINGS
	  if (!quiet_warnings
	      && (i.tm.operand_types[op] & InOutPortReg) == 0)
	    as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
		     (i.op[op].regs + (i.types[op] & Reg16
				       ? REGNAM_AL - REGNAM_AX
				       : REGNAM_AL - REGNAM_EAX))->reg_name,
		     i.op[op].regs->reg_name,
		     i.suffix);
#endif
	  continue;
	}
      /* Any other register is bad.  */
      if (i.types[op] & (Reg | RegMMX | RegXMM
			 | SReg2 | SReg3
			 | Control | Debug | Test
			 | FloatReg | FloatAcc))
	{
	  as_bad (_("`%%%s' not allowed with `%s%c'"),
		  i.op[op].regs->reg_name,
		  i.tm.name,
		  i.suffix);
	  return 0;
	}
    }
  return 1;
}

static int
check_long_reg ()
{
  int op;

  for (op = i.operands; --op >= 0;)
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
d1827 4
a1830 5
	as_bad (_("`%%%s' not allowed with `%s%c'"),
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
d1832 2
a1833 4
  /* Warn if the e prefix on a general reg is missing.  */
    else if ((!quiet_warnings || flag_code == CODE_64BIT)
	     && (i.types[op] & Reg16) != 0
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
d1835 3
a1837 3
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	if (flag_code == CODE_64BIT)
d1839 1
a1839 4
	    as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		    i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
a1840 51
#if REGISTER_WARNINGS
	else
	  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
		   (i.op[op].regs + REGNAM_EAX - REGNAM_AX)->reg_name,
		   i.op[op].regs->reg_name,
		   i.suffix);
#endif
      }
  /* Warn if the r prefix on a general reg is missing.  */
    else if ((i.types[op] & Reg64) != 0
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
      {
	as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		i.op[op].regs->reg_name,
		i.suffix);
	return 0;
      }
  return 1;
}

static int
check_qword_reg ()
{
  int op;

  for (op = i.operands; --op >= 0; )
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
      {
	as_bad (_("`%%%s' not allowed with `%s%c'"),
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is missing.  */
    else if (((i.types[op] & Reg16) != 0
	      || (i.types[op] & Reg32) != 0)
	     && (i.tm.operand_types[op] & (Reg32 | Acc)) != 0)
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		i.op[op].regs->reg_name,
		i.suffix);
	return 0;
      }
  return 1;
}
d1842 2
a1843 24
static int
check_word_reg ()
{
  int op;
  for (op = i.operands; --op >= 0;)
    /* Reject eight bit registers, except where the template requires
       them. (eg. movzb)  */
    if ((i.types[op] & Reg8) != 0
	&& (i.tm.operand_types[op] & (Reg16 | Reg32 | Acc)) != 0)
      {
	as_bad (_("`%%%s' not allowed with `%s%c'"),
		i.op[op].regs->reg_name,
		i.tm.name,
		i.suffix);
	return 0;
      }
  /* Warn if the e prefix on a general reg is present.  */
    else if ((!quiet_warnings || flag_code == CODE_64BIT)
	     && (i.types[op] & Reg32) != 0
	     && (i.tm.operand_types[op] & (Reg16 | Acc)) != 0)
      {
	/* Prohibit these changes in the 64bit mode, since the
	   lowering is more complicated.  */
	if (flag_code == CODE_64BIT)
d1845 3
a1847 4
	    as_bad (_("Incorrect register `%%%s' used with `%c' suffix"),
		    i.op[op].regs->reg_name,
		    i.suffix);
	    return 0;
a1848 7
	else
#if REGISTER_WARNINGS
	  as_warn (_("using `%%%s' instead of `%%%s' due to `%c' suffix"),
		   (i.op[op].regs + REGNAM_AX - REGNAM_EAX)->reg_name,
		   i.op[op].regs->reg_name,
		   i.suffix);
#endif
a1849 2
  return 1;
}
d1851 7
a1857 4
static int
finalize_imm ()
{
  unsigned int overlap0, overlap1, overlap2;
d1859 1
a1859 32
  overlap0 = i.types[0] & i.tm.operand_types[0];
  if ((overlap0 & (Imm8 | Imm8S | Imm16 | Imm32 | Imm32S))
      && overlap0 != Imm8 && overlap0 != Imm8S
      && overlap0 != Imm16 && overlap0 != Imm32S
      && overlap0 != Imm32 && overlap0 != Imm64)
    {
      if (i.suffix)
	{
	  overlap0 &= (i.suffix == BYTE_MNEM_SUFFIX
		       ? Imm8 | Imm8S
		       : (i.suffix == WORD_MNEM_SUFFIX
			  ? Imm16
			  : (i.suffix == QWORD_MNEM_SUFFIX
			     ? Imm64 | Imm32S
			     : Imm32)));
	}
      else if (overlap0 == (Imm16 | Imm32S | Imm32)
	       || overlap0 == (Imm16 | Imm32)
	       || overlap0 == (Imm16 | Imm32S))
	{
	  overlap0 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
		      ? Imm16 : Imm32S);
	}
      if (overlap0 != Imm8 && overlap0 != Imm8S
	  && overlap0 != Imm16 && overlap0 != Imm32S
	  && overlap0 != Imm32 && overlap0 != Imm64)
	{
	  as_bad (_("no instruction mnemonic suffix given; can't determine immediate size"));
	  return 0;
	}
    }
  i.types[0] = overlap0;
d1861 3
a1863 32
  overlap1 = i.types[1] & i.tm.operand_types[1];
  if ((overlap1 & (Imm8 | Imm8S | Imm16 | Imm32S | Imm32))
      && overlap1 != Imm8 && overlap1 != Imm8S
      && overlap1 != Imm16 && overlap1 != Imm32S
      && overlap1 != Imm32 && overlap1 != Imm64)
    {
      if (i.suffix)
	{
	  overlap1 &= (i.suffix == BYTE_MNEM_SUFFIX
		       ? Imm8 | Imm8S
		       : (i.suffix == WORD_MNEM_SUFFIX
			  ? Imm16
			  : (i.suffix == QWORD_MNEM_SUFFIX
			     ? Imm64 | Imm32S
			     : Imm32)));
	}
      else if (overlap1 == (Imm16 | Imm32 | Imm32S)
	       || overlap1 == (Imm16 | Imm32)
	       || overlap1 == (Imm16 | Imm32S))
	{
	  overlap1 = ((flag_code == CODE_16BIT) ^ (i.prefix[DATA_PREFIX] != 0)
		      ? Imm16 : Imm32S);
	}
      if (overlap1 != Imm8 && overlap1 != Imm8S
	  && overlap1 != Imm16 && overlap1 != Imm32S
	  && overlap1 != Imm32 && overlap1 != Imm64)
	{
	  as_bad (_("no instruction mnemonic suffix given; can't determine immediate size %x %c"),overlap1, i.suffix);
	  return 0;
	}
    }
  i.types[1] = overlap1;
d1865 5
a1869 3
  overlap2 = i.types[2] & i.tm.operand_types[2];
  assert ((overlap2 & Imm) == 0);
  i.types[2] = overlap2;
d1871 3
a1873 81
  return 1;
}

static int
process_operands ()
{
  /* Default segment register this instruction will use for memory
     accesses.  0 means unknown.  This is only for optimizing out
     unnecessary segment overrides.  */
  const seg_entry *default_seg = 0;

  /* The imul $imm, %reg instruction is converted into
     imul $imm, %reg, %reg, and the clr %reg instruction
     is converted into xor %reg, %reg.  */
  if (i.tm.opcode_modifier & regKludge)
    {
      unsigned int first_reg_op = (i.types[0] & Reg) ? 0 : 1;
      /* Pretend we saw the extra register operand.  */
      assert (i.op[first_reg_op + 1].regs == 0);
      i.op[first_reg_op + 1].regs = i.op[first_reg_op].regs;
      i.types[first_reg_op + 1] = i.types[first_reg_op];
      i.reg_operands = 2;
    }

  if (i.tm.opcode_modifier & ShortForm)
    {
      /* The register or float register operand is in operand 0 or 1.  */
      unsigned int op = (i.types[0] & (Reg | FloatReg)) ? 0 : 1;
      /* Register goes in low 3 bits of opcode.  */
      i.tm.base_opcode |= i.op[op].regs->reg_num;
      if ((i.op[op].regs->reg_flags & RegRex) != 0)
	i.rex |= REX_EXTZ;
      if (!quiet_warnings && (i.tm.opcode_modifier & Ugh) != 0)
	{
	  /* Warn about some common errors, but press on regardless.
	     The first case can be generated by gcc (<= 2.8.1).  */
	  if (i.operands == 2)
	    {
	      /* Reversed arguments on faddp, fsubp, etc.  */
	      as_warn (_("translating to `%s %%%s,%%%s'"), i.tm.name,
		       i.op[1].regs->reg_name,
		       i.op[0].regs->reg_name);
	    }
	  else
	    {
	      /* Extraneous `l' suffix on fp insn.  */
	      as_warn (_("translating to `%s %%%s'"), i.tm.name,
		       i.op[0].regs->reg_name);
	    }
	}
    }
  else if (i.tm.opcode_modifier & Modrm)
    {
      /* The opcode is completed (modulo i.tm.extension_opcode which
	 must be put into the modrm byte).  Now, we make the modrm and
	 index base bytes based on all the info we've collected.  */

      default_seg = build_modrm_byte ();
    }
  else if (i.tm.opcode_modifier & (Seg2ShortForm | Seg3ShortForm))
    {
      if (i.tm.base_opcode == POP_SEG_SHORT
	  && i.op[0].regs->reg_num == 1)
	{
	  as_bad (_("you can't `pop %%cs'"));
	  return 0;
	}
      i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);
      if ((i.op[0].regs->reg_flags & RegRex) != 0)
	i.rex |= REX_EXTZ;
    }
  else if ((i.tm.base_opcode & ~(D | W)) == MOV_AX_DISP32)
    {
      default_seg = &ds;
    }
  else if ((i.tm.opcode_modifier & IsString) != 0)
    {
      /* For the string instructions that allow a segment override
	 on one of their operands, the default segment is ds.  */
      default_seg = &ds;
    }
d1875 30
a1904 2
  if (i.tm.base_opcode == 0x8d /* lea */ && i.seg[0] && !quiet_warnings)
    as_warn (_("segment override on `lea' is ineffectual"));
d1906 12
a1917 12
  /* If a segment was explicitly specified, and the specified segment
     is not the default, use an opcode prefix to select it.  If we
     never figured out what the default segment is, then default_seg
     will be zero at this point, and the specified segment prefix will
     always be used.  */
  if ((i.seg[0]) && (i.seg[0] != default_seg))
    {
      if (!add_prefix (i.seg[0]->seg_prefix))
	return 0;
    }
  return 1;
}
d1919 42
a1960 4
static const seg_entry *
build_modrm_byte ()
{
  const seg_entry *default_seg = 0;
d1962 8
a1969 46
  /* i.reg_operands MUST be the number of real register operands;
     implicit registers do not count.  */
  if (i.reg_operands == 2)
    {
      unsigned int source, dest;
      source = ((i.types[0]
		 & (Reg | RegMMX | RegXMM
		    | SReg2 | SReg3
		    | Control | Debug | Test))
		? 0 : 1);
      dest = source + 1;

      i.rm.mode = 3;
      /* One of the register operands will be encoded in the i.tm.reg
	 field, the other in the combined i.tm.mode and i.tm.regmem
	 fields.  If no form of this instruction supports a memory
	 destination operand, then we assume the source operand may
	 sometimes be a memory operand and so we need to store the
	 destination in the i.rm.reg field.  */
      if ((i.tm.operand_types[dest] & AnyMem) == 0)
	{
	  i.rm.reg = i.op[dest].regs->reg_num;
	  i.rm.regmem = i.op[source].regs->reg_num;
	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTX;
	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTZ;
	}
      else
	{
	  i.rm.reg = i.op[source].regs->reg_num;
	  i.rm.regmem = i.op[dest].regs->reg_num;
	  if ((i.op[dest].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTZ;
	  if ((i.op[source].regs->reg_flags & RegRex) != 0)
	    i.rex |= REX_EXTX;
	}
    }
  else
    {			/* If it's not 2 reg operands...  */
      if (i.mem_operands)
	{
	  unsigned int fake_zero_displacement = 0;
	  unsigned int op = ((i.types[0] & AnyMem)
			     ? 0
			     : (i.types[1] & AnyMem) ? 1 : 2);
d1971 46
a2016 1
	  default_seg = &ds;
d2018 5
a2022 6
	  if (i.base_reg == 0)
	    {
	      i.rm.mode = 0;
	      if (!i.disp_operands)
		fake_zero_displacement = 1;
	      if (i.index_reg == 0)
d2024 5
a2028 27
		  /* Operand is just <disp>  */
		  if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0)
		      && (flag_code != CODE_64BIT))
		    {
		      i.rm.regmem = NO_BASE_REGISTER_16;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp16;
		    }
		  else if (flag_code != CODE_64BIT
			   || (i.prefix[ADDR_PREFIX] != 0))
		    {
		      i.rm.regmem = NO_BASE_REGISTER;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp32;
		    }
		  else
		    {
		      /* 64bit mode overwrites the 32bit absolute
			 addressing by RIP relative addressing and
			 absolute addressing is encoded by one of the
			 redundant SIB forms.  */
		      i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		      i.sib.base = NO_BASE_REGISTER;
		      i.sib.index = NO_INDEX_REGISTER;
		      i.types[op] &= ~Disp;
		      i.types[op] |= Disp32S;
		    }
d2030 4
a2033 1
	      else /* !i.base_reg && i.index_reg  */
d2035 7
a2041 7
		  i.sib.index = i.index_reg->reg_num;
		  i.sib.base = NO_BASE_REGISTER;
		  i.sib.scale = i.log2_scale_factor;
		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		  i.types[op] &= ~Disp;
		  if (flag_code != CODE_64BIT)
		    i.types[op] |= Disp32;	/* Must be 32 bit */
d2043 5
a2047 3
		    i.types[op] |= Disp32S;
		  if ((i.index_reg->reg_flags & RegRex) != 0)
		    i.rex |= REX_EXTY;
d2049 3
a2051 12
	    }
	  /* RIP addressing for 64bit mode.  */
	  else if (i.base_reg->reg_type == BaseIndex)
	    {
	      i.rm.regmem = NO_BASE_REGISTER;
	      i.types[op] &= ~Disp;
	      i.types[op] |= Disp32S;
	      i.flags[op] = Operand_PCrel;
	    }
	  else if (i.base_reg->reg_type & Reg16)
	    {
	      switch (i.base_reg->reg_num)
d2053 3
a2055 23
		case 3: /* (%bx)  */
		  if (i.index_reg == 0)
		    i.rm.regmem = 7;
		  else /* (%bx,%si) -> 0, or (%bx,%di) -> 1  */
		    i.rm.regmem = i.index_reg->reg_num - 6;
		  break;
		case 5: /* (%bp)  */
		  default_seg = &ss;
		  if (i.index_reg == 0)
		    {
		      i.rm.regmem = 6;
		      if ((i.types[op] & Disp) == 0)
			{
			  /* fake (%bp) into 0(%bp)  */
			  i.types[op] |= Disp8;
			  fake_zero_displacement = 1;
			}
		    }
		  else /* (%bp,%si) -> 2, or (%bp,%di) -> 3  */
		    i.rm.regmem = i.index_reg->reg_num - 6 + 2;
		  break;
		default: /* (%si) -> 4 or (%di) -> 5  */
		  i.rm.regmem = i.base_reg->reg_num - 6 + 4;
d2057 10
a2066 6
	      i.rm.mode = mode_from_disp_size (i.types[op]);
	    }
	  else /* i.base_reg and 32/64 bit mode  */
	    {
	      if (flag_code == CODE_64BIT
		  && (i.types[op] & Disp))
d2068 5
a2072 4
		  if (i.types[op] & Disp8)
		    i.types[op] = Disp8 | Disp32S;
		  else
		    i.types[op] = Disp32S;
d2074 4
a2077 7
	      i.rm.regmem = i.base_reg->reg_num;
	      if ((i.base_reg->reg_flags & RegRex) != 0)
		i.rex |= REX_EXTZ;
	      i.sib.base = i.base_reg->reg_num;
	      /* x86-64 ignores REX prefix bit here to avoid decoder
		 complications.  */
	      if ((i.base_reg->reg_num & 7) == EBP_REG_NUM)
d2079 5
a2083 6
		  default_seg = &ss;
		  if (i.disp_operands == 0)
		    {
		      fake_zero_displacement = 1;
		      i.types[op] |= Disp8;
		    }
d2085 9
a2093 1
	      else if (i.base_reg->reg_num == ESP_REG_NUM)
d2095 5
a2099 1
		  default_seg = &ss;
d2101 4
a2104 2
	      i.sib.scale = i.log2_scale_factor;
	      if (i.index_reg == 0)
d2106 12
a2117 10
		  /* <disp>(%esp) becomes two byte modrm with no index
		     register.  We've already stored the code for esp
		     in i.rm.regmem ie. ESCAPE_TO_TWO_BYTE_ADDRESSING.
		     Any base register besides %esp will not use the
		     extra modrm byte.  */
		  i.sib.index = NO_INDEX_REGISTER;
#if !SCALE1_WHEN_NO_INDEX
		  /* Another case where we force the second modrm byte.  */
		  if (i.log2_scale_factor)
		    i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
d2120 83
a2202 9
	      else
		{
		  i.sib.index = i.index_reg->reg_num;
		  i.rm.regmem = ESCAPE_TO_TWO_BYTE_ADDRESSING;
		  if ((i.index_reg->reg_flags & RegRex) != 0)
		    i.rex |= REX_EXTY;
		}
	      i.rm.mode = mode_from_disp_size (i.types[op]);
	    }
d2204 5
a2208 15
	  if (fake_zero_displacement)
	    {
	      /* Fakes a zero displacement assuming that i.types[op]
		 holds the correct displacement size.  */
	      expressionS *exp;

	      assert (i.op[op].disps == 0);
	      exp = &disp_expressions[i.disp_operands++];
	      i.op[op].disps = exp;
	      exp->X_op = O_constant;
	      exp->X_add_number = 0;
	      exp->X_add_symbol = (symbolS *) 0;
	      exp->X_op_symbol = (symbolS *) 0;
	    }
	}
d2210 4
a2213 5
      /* Fill in i.rm.reg or i.rm.regmem field with register operand
	 (if any) based on i.tm.extension_opcode.  Again, we must be
	 careful to make sure that segment/control/debug/test/MMX
	 registers are coded into the i.rm.reg field.  */
      if (i.reg_operands)
d2215 1
a2215 26
	  unsigned int op =
	    ((i.types[0]
	      & (Reg | RegMMX | RegXMM
		 | SReg2 | SReg3
		 | Control | Debug | Test))
	     ? 0
	     : ((i.types[1]
		 & (Reg | RegMMX | RegXMM
		    | SReg2 | SReg3
		    | Control | Debug | Test))
		? 1
		: 2));
	  /* If there is an extension opcode to put here, the register
	     number must be put into the regmem field.  */
	  if (i.tm.extension_opcode != None)
	    {
	      i.rm.regmem = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_EXTZ;
	    }
	  else
	    {
	      i.rm.reg = i.op[op].regs->reg_num;
	      if ((i.op[op].regs->reg_flags & RegRex) != 0)
		i.rex |= REX_EXTX;
	    }
d2217 3
a2219 5
	  /* Now, if no memory operand has set i.rm.mode = 0, 1, 2 we
	     must set it to 3 to indicate this is a register operand
	     in the regmem field.  */
	  if (!i.mem_operands)
	    i.rm.mode = 3;
d2222 362
a2583 6
      /* Fill in i.rm.reg field with extension opcode (if any).  */
      if (i.tm.extension_opcode != None)
	i.rm.reg = i.tm.extension_opcode;
    }
  return default_seg;
}
d2585 34
a2618 61
static void
output_branch ()
{
  char *p;
  int code16;
  int prefix;
  relax_substateT subtype;
  symbolS *sym;
  offsetT off;

  code16 = 0;
  if (flag_code == CODE_16BIT)
    code16 = CODE16;

  prefix = 0;
  if (i.prefix[DATA_PREFIX] != 0)
    {
      prefix = 1;
      i.prefixes -= 1;
      code16 ^= CODE16;
    }
  /* Pentium4 branch hints.  */
  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
    {
      prefix++;
      i.prefixes--;
    }
  if (i.prefix[REX_PREFIX] != 0)
    {
      prefix++;
      i.prefixes--;
    }

  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));

  /* It's always a symbol;  End frag & setup for relax.
     Make sure there is enough room in this frag for the largest
     instruction we may generate in md_convert_frag.  This is 2
     bytes for the opcode and room for the prefix and largest
     displacement.  */
  frag_grow (prefix + 2 + 4);
  /* Prefix and 1 opcode byte go in fr_fix.  */
  p = frag_more (prefix + 1);
  if (i.prefix[DATA_PREFIX] != 0)
    *p++ = DATA_PREFIX_OPCODE;
  if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE
      || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE)
    *p++ = i.prefix[SEG_PREFIX];
  if (i.prefix[REX_PREFIX] != 0)
    *p++ = i.prefix[REX_PREFIX];
  *p = i.tm.base_opcode;

  if ((unsigned char) *p == JUMP_PC_RELATIVE)
    subtype = ENCODE_RELAX_STATE (UNCOND_JUMP, SMALL);
  else if ((cpu_arch_flags & Cpu386) != 0)
    subtype = ENCODE_RELAX_STATE (COND_JUMP, SMALL);
  else
    subtype = ENCODE_RELAX_STATE (COND_JUMP86, SMALL);
  subtype |= code16;
d2620 18
a2637 2
  sym = i.op[0].disps->X_add_symbol;
  off = i.op[0].disps->X_add_number;
d2639 2
a2640 2
  if (i.op[0].disps->X_op != O_constant
      && i.op[0].disps->X_op != O_symbol)
d2642 2
a2643 3
      /* Handle complex expressions.  */
      sym = make_expr_symbol (i.op[0].disps);
      off = 0;
d2646 9
a2654 4
  /* 1 possible extra opcode + 4 byte displacement go in var part.
     Pass reloc in fr_var.  */
  frag_var (rs_machine_dependent, 5, i.reloc[0], subtype, sym, off, p);
}
d2656 2
a2657 6
static void
output_jump ()
{
  char *p;
  int size;
  fixS *fixP;
d2659 8
a2666 1
  if (i.tm.opcode_modifier & JumpByte)
d2668 3
a2670 3
      /* This is a loop or jecxz type instruction.  */
      size = 1;
      if (i.prefix[ADDR_PREFIX] != 0)
d2672 15
a2686 9
	  FRAG_APPEND_1_CHAR (ADDR_PREFIX_OPCODE);
	  i.prefixes -= 1;
	}
      /* Pentium4 branch hints.  */
      if (i.prefix[SEG_PREFIX] == CS_PREFIX_OPCODE /* not taken */
	  || i.prefix[SEG_PREFIX] == DS_PREFIX_OPCODE /* taken */)
	{
	  FRAG_APPEND_1_CHAR (i.prefix[SEG_PREFIX]);
	  i.prefixes--;
a2688 3
  else
    {
      int code16;
d2690 6
a2695 3
      code16 = 0;
      if (flag_code == CODE_16BIT)
	code16 = CODE16;
d2697 3
a2699 11
      if (i.prefix[DATA_PREFIX] != 0)
	{
	  FRAG_APPEND_1_CHAR (DATA_PREFIX_OPCODE);
	  i.prefixes -= 1;
	  code16 ^= CODE16;
	}

      size = 4;
      if (code16)
	size = 2;
    }
d2701 4
a2704 5
  if (i.prefix[REX_PREFIX] != 0)
    {
      FRAG_APPEND_1_CHAR (i.prefix[REX_PREFIX]);
      i.prefixes -= 1;
    }
d2706 5
a2710 2
  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));
d2712 3
a2714 2
  p = frag_more (1 + size);
  *p++ = i.tm.base_opcode;
d2716 19
a2734 2
  fixP = fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		      i.op[0].disps, 1, reloc (size, 1, 1, i.reloc[0]));
d2736 2
a2737 6
  /* All jumps handled here are signed, but don't use a signed limit
     check for 32 and 16 bit jumps as we want to allow wrap around at
     4G and 64k respectively.  */
  if (size == 1)
    fixP->fx_signed = 1;
}
d2739 33
a2771 7
static void
output_interseg_jump ()
{
  char *p;
  int size;
  int prefix;
  int code16;
d2773 20
a2792 3
  code16 = 0;
  if (flag_code == CODE_16BIT)
    code16 = CODE16;
d2794 3
a2796 12
  prefix = 0;
  if (i.prefix[DATA_PREFIX] != 0)
    {
      prefix = 1;
      i.prefixes -= 1;
      code16 ^= CODE16;
    }
  if (i.prefix[REX_PREFIX] != 0)
    {
      prefix++;
      i.prefixes -= 1;
    }
d2798 6
a2803 3
  size = 4;
  if (code16)
    size = 2;
d2805 4
a2808 2
  if (i.prefixes != 0 && !intel_syntax)
    as_warn (_("skipping prefixes on this instruction"));
d2810 5
a2814 2
  /* 1 opcode; 2 segment; offset  */
  p = frag_more (prefix + 1 + 2 + size);
d2816 2
a2817 2
  if (i.prefix[DATA_PREFIX] != 0)
    *p++ = DATA_PREFIX_OPCODE;
d2819 2
a2820 2
  if (i.prefix[REX_PREFIX] != 0)
    *p++ = i.prefix[REX_PREFIX];
d2822 12
a2833 4
  *p++ = i.tm.base_opcode;
  if (i.op[1].imms->X_op == O_constant)
    {
      offsetT n = i.op[1].imms->X_add_number;
d2835 12
a2846 17
      if (size == 2
	  && !fits_in_unsigned_word (n)
	  && !fits_in_signed_word (n))
	{
	  as_bad (_("16-bit jump out of range"));
	  return;
	}
      md_number_to_chars (p, n, size);
    }
  else
    fix_new_exp (frag_now, p - frag_now->fr_literal, size,
		 i.op[1].imms, 0, reloc (size, 0, 0, i.reloc[1]));
  if (i.op[0].imms->X_op != O_constant)
    as_bad (_("can't handle non absolute segment in `%s'"),
	    i.tm.name);
  md_number_to_chars (p + size, (valueT) i.op[0].imms->X_add_number, 2);
}
d2848 3
d2852 2
a2853 5
static void
output_insn ()
{
  fragS *insn_start_frag;
  offsetT insn_start_off;
d2855 2
a2856 37
  /* Tie dwarf2 debug info to the address at the start of the insn.
     We can't do this after the insn has been output as the current
     frag may have been closed off.  eg. by frag_var.  */
  dwarf2_emit_insn (0);

  insn_start_frag = frag_now;
  insn_start_off = frag_now_fix ();

  /* Output jumps.  */
  if (i.tm.opcode_modifier & Jump)
    output_branch ();
  else if (i.tm.opcode_modifier & (JumpByte | JumpDword))
    output_jump ();
  else if (i.tm.opcode_modifier & JumpInterSegment)
    output_interseg_jump ();
  else
    {
      /* Output normal instructions here.  */
      char *p;
      unsigned char *q;

      /* All opcodes on i386 have either 1 or 2 bytes.  We may use third
	 byte for the SSE instructions to specify a prefix they require.  */
      if (i.tm.base_opcode & 0xff0000)
	add_prefix ((i.tm.base_opcode >> 16) & 0xff);

      /* The prefix bytes.  */
      for (q = i.prefix;
	   q < i.prefix + sizeof (i.prefix) / sizeof (i.prefix[0]);
	   q++)
	{
	  if (*q)
	    {
	      p = frag_more (1);
	      md_number_to_chars (p, (valueT) *q, 1);
	    }
	}
d2858 2
a2859 12
      /* Now the opcode; be careful about word order here!  */
      if (fits_in_unsigned_byte (i.tm.base_opcode))
	{
	  FRAG_APPEND_1_CHAR (i.tm.base_opcode);
	}
      else
	{
	  p = frag_more (2);
	  /* Put out high byte first: can't use md_number_to_chars!  */
	  *p++ = (i.tm.base_opcode >> 8) & 0xff;
	  *p = i.tm.base_opcode & 0xff;
	}
d2861 2
a2862 25
      /* Now the modrm byte and sib byte (if present).  */
      if (i.tm.opcode_modifier & Modrm)
	{
	  p = frag_more (1);
	  md_number_to_chars (p,
			      (valueT) (i.rm.regmem << 0
					| i.rm.reg << 3
					| i.rm.mode << 6),
			      1);
	  /* If i.rm.regmem == ESP (4)
	     && i.rm.mode != (Register mode)
	     && not 16 bit
	     ==> need second modrm byte.  */
	  if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING
	      && i.rm.mode != 3
	      && !(i.base_reg && (i.base_reg->reg_type & Reg16) != 0))
	    {
	      p = frag_more (1);
	      md_number_to_chars (p,
				  (valueT) (i.sib.base << 0
					    | i.sib.index << 3
					    | i.sib.scale << 6),
				  1);
	    }
	}
d2864 4
a2867 2
      if (i.disp_operands)
	output_disp (insn_start_frag, insn_start_off);
d2869 21
a2889 3
      if (i.imm_operands)
	output_imm (insn_start_frag, insn_start_off);
    }
d2891 16
a2906 7
#ifdef DEBUG386
  if (flag_debug)
    {
      pi (line, &i);
    }
#endif /* DEBUG386  */
}
d2908 12
a2919 7
static void
output_disp (insn_start_frag, insn_start_off)
    fragS *insn_start_frag;
    offsetT insn_start_off;
{
  char *p;
  unsigned int n;
d2921 25
a2945 8
  for (n = 0; n < i.operands; n++)
    {
      if (i.types[n] & Disp)
	{
	  if (i.op[n].disps->X_op == O_constant)
	    {
	      int size;
	      offsetT val;
d2947 3
a2949 28
	      size = 4;
	      if (i.types[n] & (Disp8 | Disp16 | Disp64))
		{
		  size = 2;
		  if (i.types[n] & Disp8)
		    size = 1;
		  if (i.types[n] & Disp64)
		    size = 8;
		}
	      val = offset_in_range (i.op[n].disps->X_add_number,
				     size);
	      p = frag_more (size);
	      md_number_to_chars (p, val, size);
	    }
	  else
	    {
	      RELOC_ENUM reloc_type;
	      int size = 4;
	      int sign = 0;
	      int pcrel = (i.flags[n] & Operand_PCrel) != 0;

	      /* The PC relative address is computed relative
		 to the instruction boundary, so in case immediate
		 fields follows, we need to adjust the value.  */
	      if (pcrel && i.imm_operands)
		{
		  int imm_size = 4;
		  unsigned int n1;
d2951 5
a2955 2
		  for (n1 = 0; n1 < i.operands; n1++)
		    if (i.types[n1] & Imm)
d2957 5
a2961 1
			if (i.types[n1] & (Imm8 | Imm8S | Imm16 | Imm64))
d2963 5
a2967 5
			    imm_size = 2;
			    if (i.types[n1] & (Imm8 | Imm8S))
			      imm_size = 1;
			    if (i.types[n1] & Imm64)
			      imm_size = 8;
d2969 4
a2972 1
			break;
d2974 13
a2986 5
		  /* We should find the immediate.  */
		  if (n1 == i.operands)
		    abort ();
		  i.op[n].disps->X_add_number -= imm_size;
		}
d2988 18
a3005 2
	      if (i.types[n] & Disp32S)
		sign = 1;
d3007 2
a3008 6
	      if (i.types[n] & (Disp16 | Disp64))
		{
		  size = 2;
		  if (i.types[n] & Disp64)
		    size = 8;
		}
d3010 6
a3015 13
	      p = frag_more (size);
	      reloc_type = reloc (size, pcrel, sign, i.reloc[n]);
#ifdef BFD_ASSEMBLER
	      if (reloc_type == BFD_RELOC_32
		  && GOT_symbol
		  && GOT_symbol == i.op[n].disps->X_add_symbol
		  && (i.op[n].disps->X_op == O_symbol
		      || (i.op[n].disps->X_op == O_add
			  && ((symbol_get_value_expression
			       (i.op[n].disps->X_op_symbol)->X_op)
			      == O_subtract))))
		{
		  offsetT add;
d3017 8
a3024 5
		  if (insn_start_frag == frag_now)
		    add = (p - frag_now->fr_literal) - insn_start_off;
		  else
		    {
		      fragS *fr;
d3026 4
a3029 6
		      add = insn_start_frag->fr_fix - insn_start_off;
		      for (fr = insn_start_frag->fr_next;
			   fr && fr != frag_now; fr = fr->fr_next)
			add += fr->fr_fix;
		      add += p - frag_now->fr_literal;
		    }
d3031 8
a3038 13
		  /* We don't support dynamic linking on x86-64 yet.  */
		  if (flag_code == CODE_64BIT)
		    abort ();
		  reloc_type = BFD_RELOC_386_GOTPC;
		  i.op[n].disps->X_add_number += add;
		}
#endif
	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			   i.op[n].disps, pcrel, reloc_type);
	    }
	}
    }
}
d3040 35
a3074 52
static void
output_imm (insn_start_frag, insn_start_off)
    fragS *insn_start_frag;
    offsetT insn_start_off;
{
  char *p;
  unsigned int n;

  for (n = 0; n < i.operands; n++)
    {
      if (i.types[n] & Imm)
	{
	  if (i.op[n].imms->X_op == O_constant)
	    {
	      int size;
	      offsetT val;

	      size = 4;
	      if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
		{
		  size = 2;
		  if (i.types[n] & (Imm8 | Imm8S))
		    size = 1;
		  else if (i.types[n] & Imm64)
		    size = 8;
		}
	      val = offset_in_range (i.op[n].imms->X_add_number,
				     size);
	      p = frag_more (size);
	      md_number_to_chars (p, val, size);
	    }
	  else
	    {
	      /* Not absolute_section.
		 Need a 32-bit fixup (don't support 8bit
		 non-absolute imms).  Try to support other
		 sizes ...  */
	      RELOC_ENUM reloc_type;
	      int size = 4;
	      int sign = 0;

	      if ((i.types[n] & (Imm32S))
		  && i.suffix == QWORD_MNEM_SUFFIX)
		sign = 1;
	      if (i.types[n] & (Imm8 | Imm8S | Imm16 | Imm64))
		{
		  size = 2;
		  if (i.types[n] & (Imm8 | Imm8S))
		    size = 1;
		  if (i.types[n] & Imm64)
		    size = 8;
		}
d3076 2
a3077 2
	      p = frag_more (size);
	      reloc_type = reloc (size, 0, sign, i.reloc[n]);
d3079 23
a3101 52
	      /*   This is tough to explain.  We end up with this one if we
	       * have operands that look like
	       * "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal here is to
	       * obtain the absolute address of the GOT, and it is strongly
	       * preferable from a performance point of view to avoid using
	       * a runtime relocation for this.  The actual sequence of
	       * instructions often look something like:
	       *
	       *	call	.L66
	       * .L66:
	       *	popl	%ebx
	       *	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
	       *
	       *   The call and pop essentially return the absolute address
	       * of the label .L66 and store it in %ebx.  The linker itself
	       * will ultimately change the first operand of the addl so
	       * that %ebx points to the GOT, but to keep things simple, the
	       * .o file must have this operand set so that it generates not
	       * the absolute address of .L66, but the absolute address of
	       * itself.  This allows the linker itself simply treat a GOTPC
	       * relocation as asking for a pcrel offset to the GOT to be
	       * added in, and the addend of the relocation is stored in the
	       * operand field for the instruction itself.
	       *
	       *   Our job here is to fix the operand so that it would add
	       * the correct offset so that %ebx would point to itself.  The
	       * thing that is tricky is that .-.L66 will point to the
	       * beginning of the instruction, so we need to further modify
	       * the operand so that it will point to itself.  There are
	       * other cases where you have something like:
	       *
	       *	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
	       *
	       * and here no correction would be required.  Internally in
	       * the assembler we treat operands of this form as not being
	       * pcrel since the '.' is explicitly mentioned, and I wonder
	       * whether it would simplify matters to do it this way.  Who
	       * knows.  In earlier versions of the PIC patches, the
	       * pcrel_adjust field was used to store the correction, but
	       * since the expression is not pcrel, I felt it would be
	       * confusing to do it this way.  */

	      if (reloc_type == BFD_RELOC_32
		  && GOT_symbol
		  && GOT_symbol == i.op[n].imms->X_add_symbol
		  && (i.op[n].imms->X_op == O_symbol
		      || (i.op[n].imms->X_op == O_add
			  && ((symbol_get_value_expression
			       (i.op[n].imms->X_op_symbol)->X_op)
			      == O_subtract))))
		{
		  offsetT add;
d3103 7
a3109 25
		  if (insn_start_frag == frag_now)
		    add = (p - frag_now->fr_literal) - insn_start_off;
		  else
		    {
		      fragS *fr;

		      add = insn_start_frag->fr_fix - insn_start_off;
		      for (fr = insn_start_frag->fr_next;
			   fr && fr != frag_now; fr = fr->fr_next)
			add += fr->fr_fix;
		      add += p - frag_now->fr_literal;
		    }

		  /* We don't support dynamic linking on x86-64 yet.  */
		  if (flag_code == CODE_64BIT)
		    abort ();
		  reloc_type = BFD_RELOC_386_GOTPC;
		  i.op[n].imms->X_add_number += add;
		}
#endif
	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
			   i.op[n].imms, 0, reloc_type);
	    }
	}
    }
d3134 4
a3137 13
    { "PLT",      { BFD_RELOC_386_PLT32,      0, BFD_RELOC_X86_64_PLT32    } },
    { "GOTOFF",   { BFD_RELOC_386_GOTOFF,     0, 0                         } },
    { "GOTPCREL", { 0,                        0, BFD_RELOC_X86_64_GOTPCREL } },
    { "TLSGD",    { BFD_RELOC_386_TLS_GD,     0, BFD_RELOC_X86_64_TLSGD    } },
    { "TLSLDM",   { BFD_RELOC_386_TLS_LDM,    0, 0                         } },
    { "TLSLD",    { 0,                        0, BFD_RELOC_X86_64_TLSLD    } },
    { "GOTTPOFF", { BFD_RELOC_386_TLS_IE_32,  0, BFD_RELOC_X86_64_GOTTPOFF } },
    { "TPOFF",    { BFD_RELOC_386_TLS_LE_32,  0, BFD_RELOC_X86_64_TPOFF32  } },
    { "NTPOFF",   { BFD_RELOC_386_TLS_LE,     0, 0                         } },
    { "DTPOFF",   { BFD_RELOC_386_TLS_LDO_32, 0, BFD_RELOC_X86_64_DTPOFF32 } },
    { "GOTNTPOFF",{ BFD_RELOC_386_TLS_GOTIE,  0, 0                         } },
    { "INDNTPOFF",{ BFD_RELOC_386_TLS_IE,     0, 0                         } },
    { "GOT",      { BFD_RELOC_386_GOT32,      0, BFD_RELOC_X86_64_GOT32    } }
d3151 1
a3151 1
      if (strncasecmp (cp + 1, gotrel[j].str, len) == 0)
d3155 2
a3156 2
	      int first, second;
	      char *tmpbuf, *past_reloc;
a3158 2
	      if (adjust)
		*adjust = len;
a3164 2

	      /* The length of the first part of our input line.  */
d3166 1
a3166 12

	      /* The second part goes from after the reloc token until
		 (and including) an end_of_line char.  Don't use strlen
		 here as the end_of_line char may not be a NUL.  */
	      past_reloc = cp + 1 + len;
	      for (cp = past_reloc; !is_end_of_line[(unsigned char) *cp++]; )
		;
	      second = cp - past_reloc;

	      /* Allocate and copy string.  The trailing NUL shouldn't
		 be necessary, but be safe.  */
	      tmpbuf = xmalloc (first + second + 2);
d3169 3
a3171 2
	      memcpy (tmpbuf + first + 1, past_reloc, second);
	      tmpbuf[first + second + 1] = '\0';
a3305 1
	   && exp_seg != absolute_section
d3367 1
a3367 1
  if (i.log2_scale_factor != 0 && i.index_reg == 0)
d3387 1
a3387 1
  expressionS *exp;
d3395 2
d3398 1
a3398 6
    {
      if (i.prefix[ADDR_PREFIX] == 0)
	bigdisp = Disp64;
    }
  else if ((flag_code == CODE_16BIT) ^ (i.prefix[ADDR_PREFIX] != 0))
    bigdisp = Disp16;
d3495 1
a3495 1
	i.reloc[this_operand] = BFD_RELOC_32_PCREL;
d3497 1
a3497 1
	i.reloc[this_operand] = BFD_RELOC_32;
a3516 1
      && exp_seg != absolute_section
d3520 1
a3520 5
      && exp_seg != undefined_section
#ifdef BFD_ASSEMBLER
      && !bfd_is_com_section (exp_seg)
#endif
      )
d3553 9
a3561 22
      if (i.prefix[ADDR_PREFIX] == 0)
	{
	  /* 64bit checks.  */
	  if ((i.base_reg
	       && ((i.base_reg->reg_type & Reg64) == 0)
		   && (i.base_reg->reg_type != BaseIndex
		       || i.index_reg))
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg64 | BaseIndex))
		      != (Reg64 | BaseIndex))))
	    ok = 0;
	}
      else
	{
	  /* 32bit checks.  */
	  if ((i.base_reg
	       && (i.base_reg->reg_type & (Reg32 | RegRex)) != Reg32)
	      || (i.index_reg
		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex | RegRex))
		      != (Reg32 | BaseIndex))))
	    ok = 0;
	}
d3569 2
a3570 2
	       && ((i.base_reg->reg_type & (Reg16 | BaseIndex | RegRex))
		   != (Reg16 | BaseIndex)))
d3572 6
a3577 6
		  && (((i.index_reg->reg_type & (Reg16 | BaseIndex))
		       != (Reg16 | BaseIndex))
		      || !(i.base_reg
			   && i.base_reg->reg_num < 6
			   && i.index_reg->reg_num >= 6
			   && i.log2_scale_factor == 0))))
d3586 2
a3587 2
		  && ((i.index_reg->reg_type & (Reg32 | BaseIndex | RegRex))
		      != (Reg32 | BaseIndex))))
d3604 2
a3605 2
	  if (i.types[this_operand] & (Disp16 | Disp32))
	     i.types[this_operand] ^= (Disp16 | Disp32);
d3924 2
a3925 2
     fragS *fragP;
     segT segment;
d3933 2
a3934 3
      || (OUTPUT_FLAVOR == bfd_target_elf_flavour
	  && (S_IS_EXTERNAL (fragP->fr_symbol)
	      || S_IS_WEAK (fragP->fr_symbol)))
d3968 4
a3971 2
	  if (size == 2
	      && (!no_cond_jump_promotion || fragP->fr_var != NO_RELOC))
d3991 2
a3992 12
	  if (no_cond_jump_promotion && fragP->fr_var == NO_RELOC)
	    {
	      fixS *fixP;

	      fragP->fr_fix += 1;
	      fixP = fix_new (fragP, old_fr_fix, 1,
			      fragP->fr_symbol,
			      fragP->fr_offset, 1,
			      BFD_RELOC_8_PCREL);
	      fixP->fx_signed = 1;
	      break;
	    }
d4014 1
d4038 1
a4038 1
     fragS *fragP;
d4044 1
a4044 1
     fragS *fragP;
d4047 1
a4047 1
  unsigned char *opcode;
d4058 9
d4181 2
a4182 2
void
md_apply_fix3 (fixP, valP, seg)
d4185 1
d4187 2
a4188 1
     valueT *valP;
d4192 2
a4193 2
  char *p = fixP->fx_where + fixP->fx_frag->fr_literal;
  valueT value = *valP;
d4215 9
a4223 10
  if (fixP->fx_addsy != NULL
      && (fixP->fx_r_type == BFD_RELOC_32_PCREL
	  || fixP->fx_r_type == BFD_RELOC_16_PCREL
	  || fixP->fx_r_type == BFD_RELOC_8_PCREL)
      && !use_rela_relocations)
    {
      /* This is a hack.  There should be a better way to handle this.
	 This covers for the fact that bfd_install_relocation will
	 subtract the current location (for partial_inplace, PC relative
	 relocations); see more below.  */
d4235 1
a4235 1
	  segT sym_seg = S_GET_SEGMENT (fixP->fx_addsy);
d4237 1
a4237 1
	  if ((sym_seg == seg
d4239 5
a4243 2
		   && sym_seg != absolute_section))
	      && !generic_force_reloc (fixP))
d4246 2
a4247 2
		 bfd_install_relocation subtracts them out again.  I think
		 bfd_install_relocation is broken, but I don't dare change
d4274 39
d4314 1
a4314 16
      case BFD_RELOC_386_TLS_GD:
      case BFD_RELOC_386_TLS_LDM:
      case BFD_RELOC_386_TLS_IE_32:
      case BFD_RELOC_386_TLS_IE:
      case BFD_RELOC_386_TLS_GOTIE:
      case BFD_RELOC_X86_64_TLSGD:
      case BFD_RELOC_X86_64_TLSLD:
      case BFD_RELOC_X86_64_GOTTPOFF:
	value = 0; /* Fully resolved at runtime.  No addend.  */
	/* Fallthrough */
      case BFD_RELOC_386_TLS_LE:
      case BFD_RELOC_386_TLS_LDO_32:
      case BFD_RELOC_386_TLS_LE_32:
      case BFD_RELOC_X86_64_DTPOFF32:
      case BFD_RELOC_X86_64_TPOFF32:
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
a4315 1

d4320 3
d4327 1
a4327 1
	return;
d4333 1
a4333 1
  *valP = value;
d4336 3
d4340 1
a4340 1
  if (fixP->fx_addsy == NULL)
a4341 1
#ifdef BFD_ASSEMBLER
a4344 2
      /* Remember value for tc_gen_reloc.  */
      fixP->fx_addnumber = value;
d4347 1
d4349 2
a4350 1
  md_number_to_chars (p, value, fixP->fx_size);
d4413 1
a4413 1
  if (ISPRINT (c))
a4483 7
  if (r != NULL
      && (r->reg_flags & (RegRex64 | RegRex)) != 0
      && flag_code != CODE_64BIT)
    {
      return (const reg_entry *) NULL;
    }

d4532 1
a4532 1
	 .stab instead of .stab.excl.  We always use .stab anyhow.  */
d4610 1
a4610 1
	return flag_code == CODE_64BIT ? "elf64-x86-64" : ELF_TARGET_FORMAT;
a4619 42

#if (defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))
void i386_elf_emit_arch_note ()
{
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
      && cpu_arch_name != NULL)
    {
      char *p;
      asection *seg = now_seg;
      subsegT subseg = now_subseg;
      Elf_Internal_Note i_note;
      Elf_External_Note e_note;
      asection *note_secp;
      int len;

      /* Create the .note section.  */
      note_secp = subseg_new (".note", 0);
      bfd_set_section_flags (stdoutput,
			     note_secp,
			     SEC_HAS_CONTENTS | SEC_READONLY);

      /* Process the arch string.  */
      len = strlen (cpu_arch_name);

      i_note.namesz = len + 1;
      i_note.descsz = 0;
      i_note.type = NT_ARCH;
      p = frag_more (sizeof (e_note.namesz));
      md_number_to_chars (p, (valueT) i_note.namesz, sizeof (e_note.namesz));
      p = frag_more (sizeof (e_note.descsz));
      md_number_to_chars (p, (valueT) i_note.descsz, sizeof (e_note.descsz));
      p = frag_more (sizeof (e_note.type));
      md_number_to_chars (p, (valueT) i_note.type, sizeof (e_note.type));
      p = frag_more (len + 1);
      strcpy (p, cpu_arch_name);

      frag_align (2, 0, 0);

      subseg_set (seg, subseg);
    }
}
#endif
d4687 1
a4687 1
  int temp;
a4737 8
    case BFD_RELOC_386_TLS_GD:
    case BFD_RELOC_386_TLS_LDM:
    case BFD_RELOC_386_TLS_LDO_32:
    case BFD_RELOC_386_TLS_IE_32:
    case BFD_RELOC_386_TLS_IE:
    case BFD_RELOC_386_TLS_GOTIE:
    case BFD_RELOC_386_TLS_LE_32:
    case BFD_RELOC_386_TLS_LE:
a4738 5
    case BFD_RELOC_X86_64_TLSGD:
    case BFD_RELOC_X86_64_TLSLD:
    case BFD_RELOC_X86_64_DTPOFF32:
    case BFD_RELOC_X86_64_GOTTPOFF:
    case BFD_RELOC_X86_64_TPOFF32:
d4750 2
a4751 3
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("can not do %d byte pc-relative relocation"),
			    fixp->fx_size);
d4764 1
a4764 3
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("can not do %d byte relocation"),
			    fixp->fx_size);
a4769 1
#ifdef BFD64
a4770 1
#endif
d4798 4
a4801 1
      rel->addend = 0;
d4806 3
a4808 20
      if (!fixp->fx_pcrel)
	rel->addend = fixp->fx_offset;
      else
	switch (code)
	  {
	  case BFD_RELOC_X86_64_PLT32:
	  case BFD_RELOC_X86_64_GOT32:
	  case BFD_RELOC_X86_64_GOTPCREL:
	  case BFD_RELOC_X86_64_TLSGD:
	  case BFD_RELOC_X86_64_TLSLD:
	  case BFD_RELOC_X86_64_GOTTPOFF:
	    rel->addend = fixp->fx_offset - fixp->fx_size;
	    break;
	  default:
	    rel->addend = (section->vma
			   - fixp->fx_size
			   + fixp->fx_addnumber
			   + md_pcrel_from (fixp));
	    break;
	  }
d4825 1
a4825 1
#else /* !BFD_ASSEMBLER  */
d4891 1
a4891 1
#endif /* !BFD_ASSEMBLER  */
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
a25 1
   VIA PadLock support by Michal Ludvig (mludvig@@suse.cz)
a32 1
#include "dw2gencfi.h"
d51 6
d157 1
a157 1
    enum bfd_reloc_code_real reloc[MAX_OPERANDS];
d247 1
a247 1
/* All non-digit non-letter characters that may occur in an operand.  */
a304 3
/* Non-zero to optimize code alignment.  */
int optimize_align_code = 1;

a320 6
/* The dwarf2 return column, adjusted for 32 or 64 bit.  */
unsigned int x86_dwarf2_return_column;

/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
int x86_cie_data_alignment;

d798 9
a806 2
    allow_naked_reg = (intel_syntax
		       && (bfd_get_symbol_leading_char (stdoutput) != '\0'));
d861 1
d872 1
a988 11

  if (flag_code == CODE_64BIT)
    {
      x86_dwarf2_return_column = 16;
      x86_cie_data_alignment = -8;
    }
  else
    {
      x86_dwarf2_return_column = 8;
      x86_cie_data_alignment = -4;
    }
d1154 1
a1222 6
  /* The x86_64 GOTPCREL are represented as 32bit PCrel relocations
     and changed later by validate_fix.  */
  if (GOT_symbol && fixP->fx_subsy == GOT_symbol
      && fixP->fx_r_type == BFD_RELOC_32_PCREL)
    return 0;

d1249 28
a1394 17
      expressionS *exp;

      if ((i.tm.cpu_flags & CpuPNI) && i.operands > 0)
	{
	  /* These Intel Prescott New Instructions have the fixed
	     operands with an opcode suffix which is coded in the same
	     place as an 8-bit immediate field would be. Here we check
	     those operands and remove them afterwards.  */
	  unsigned int x;

	  for (x = 0; x < i.operands; x++)
	    if (i.op[x].regs->reg_num != x)
	      as_bad (_("can't use register '%%%s' as operand %d in '%s'."),
			i.op[x].regs->reg_name, x + 1, i.tm.name);
	  i.operands = 0;
 	}

d1400 2
d1786 1
a1786 1
  enum bfd_reloc_code_real temp_reloc;
d3128 1
d3156 4
a3159 17
      /* All opcodes on i386 have either 1 or 2 bytes, PadLock instructions
	 have 3 bytes.  We may use one more higher byte to specify a prefix
	 the instruction requires.  */
      if ((i.tm.cpu_flags & CpuPadLock) != 0
	  && (i.tm.base_opcode & 0xff000000) != 0)
        {
	  unsigned int prefix;
	  prefix = (i.tm.base_opcode >> 24) & 0xff;

	  if (prefix != REPE_PREFIX_OPCODE
	      || i.prefix[LOCKREP_PREFIX] != REPE_PREFIX_OPCODE)
	    add_prefix (prefix);
	}
      else
	if ((i.tm.cpu_flags & CpuPadLock) == 0
	    && (i.tm.base_opcode & 0xff0000) != 0)
	  add_prefix ((i.tm.base_opcode >> 16) & 0xff);
d3180 1
a3180 8
	  if ((i.tm.cpu_flags & CpuPadLock) != 0)
	    {
	      p = frag_more (3);
	      *p++ = (i.tm.base_opcode >> 16) & 0xff;
	    }
	  else
	    p = frag_more (2);

d3260 1
a3260 1
	      enum bfd_reloc_code_real reloc_type;
d3304 1
d3335 1
d3380 1
a3380 1
	      enum bfd_reloc_code_real reloc_type;
d3398 1
a3398 1

d3471 1
d3480 1
a3480 1
static char *lex_got PARAMS ((enum bfd_reloc_code_real *, int *));
d3493 1
a3493 1
     enum bfd_reloc_code_real *reloc;
d3499 1
a3499 1
    const enum bfd_reloc_code_real rel[NUM_FLAG_CODE];
d3577 1
a3577 1
static enum bfd_reloc_code_real got_reloc = NO_RELOC;
d3586 1
a3586 1
  enum bfd_reloc_code_real r = reloc (len, 0, 0, got_reloc);
d3692 4
a3695 1
  else if (OUTPUT_FLAVOR == bfd_target_aout_flavour
d3701 4
a3704 1
	   && !bfd_is_com_section (exp_seg))
d3706 1
d3708 3
d3867 1
d3893 1
d3908 1
d3910 1
d3916 4
a3919 1
      && !bfd_is_com_section (exp_seg))
d3921 1
d3923 3
d4354 1
a4354 1
      enum bfd_reloc_code_real reloc_type;
d4453 7
d4465 1
d4604 1
a4604 1
#if !defined (TE_Mach)
d4669 1
a4669 1
     and we must not disappoint it.  */
d4715 1
a4715 1
#endif /* !defined (TE_Mach)  */
d4720 1
d4728 1
a4728 1

d4874 1
a4874 1
const char *md_shortopts = "kVQ:sqn";
d4876 1
a4876 1
const char *md_shortopts = "qn";
a4896 4
    case 'n':
      optimize_align_code = 0;
      break;

a4957 1
  -n                      Do not optimize code alignment\n\
a4961 1
  -n                      Do not optimize code alignment\n\
d4966 1
d5048 1
d5078 1
d5093 1
d5124 2
d5285 67
d5582 2
a5583 3
		ret = i386_displacement (s, s + strlen (s));
	      if (ret)
		ret = i386_index_check (operand_string);
a6300 52
}

int
tc_x86_regname_to_dw2regnum (const char *regname)
{
  unsigned int regnum;
  unsigned int regnames_count;
  char *regnames_32[] =
    {
      "eax", "ecx", "edx", "ebx",
      "esp", "ebp", "esi", "edi",
      "eip"
    };
  char *regnames_64[] =
    {
      "rax", "rbx", "rcx", "rdx",
      "rdi", "rsi", "rbp", "rsp",
      "r8", "r9", "r10", "r11",
      "r12", "r13", "r14", "r15",
      "rip"
    };
  char **regnames;

  if (flag_code == CODE_64BIT)
    {
      regnames = regnames_64;
      regnames_count = ARRAY_SIZE (regnames_64);
    }
  else
    {
      regnames = regnames_32;
      regnames_count = ARRAY_SIZE (regnames_32);
    }

  for (regnum = 0; regnum < regnames_count; regnum++)
    if (strcmp (regname, regnames[regnum]) == 0)
      return regnum;

  return -1;
}

void
tc_x86_frame_initial_instructions (void)
{
  static unsigned int sp_regno;

  if (!sp_regno)
    sp_regno = tc_x86_regname_to_dw2regnum (flag_code == CODE_64BIT
					    ? "rsp" : "esp");

  cfi_add_CFA_def_cfa (sp_regno, -x86_cie_data_alignment);
  cfi_add_CFA_offset (x86_dwarf2_return_column, x86_cie_data_alignment);
@


