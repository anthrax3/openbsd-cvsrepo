head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.54
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.27;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.30;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.09.22.29.33;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.48;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.05.32;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.14;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.02;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.02;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.30;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.44.36;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.22.54;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.46.22;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2001.06.09.22.07.16;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.34.02;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.29;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.49;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-arm.c -- Assemble for the ARM
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Contributed by Richard Earnshaw (rwe@@pegasus.esprit.ec.org)
	Modified by David Taylor (dtaylor@@armltd.co.uk)
	Cirrus coprocessor mods by Aldy Hernandez (aldyh@@redhat.com)
	Cirrus coprocessor fixes by Petko Manolov (petkan@@nucleusys.com)
	Cirrus coprocessor fixes by Vladimir Ivanov (vladitx@@nucleusys.com)

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include <string.h>
#define  NO_RELOC 0
#include "as.h"
#include "safe-ctype.h"

/* Need TARGET_CPU.  */
#include "config.h"
#include "subsegs.h"
#include "obstack.h"
#include "symbols.h"
#include "listing.h"

#ifdef OBJ_ELF
#include "elf/arm.h"
#include "dwarf2dbg.h"
#endif

/* XXX Set this to 1 after the next binutils release */
#define WARN_DEPRECATED 0

/* The following bitmasks control CPU extensions:  */
#define ARM_EXT_V1	 0x00000001	/* All processors (core set).  */
#define ARM_EXT_V2	 0x00000002	/* Multiply instructions.  */
#define ARM_EXT_V2S	 0x00000004	/* SWP instructions.       */
#define ARM_EXT_V3	 0x00000008	/* MSR MRS.                */
#define ARM_EXT_V3M	 0x00000010	/* Allow long multiplies.  */
#define ARM_EXT_V4	 0x00000020	/* Allow half word loads.  */
#define ARM_EXT_V4T	 0x00000040	/* Thumb v1.               */
#define ARM_EXT_V5	 0x00000080	/* Allow CLZ, etc.         */
#define ARM_EXT_V5T	 0x00000100	/* Thumb v2.               */
#define ARM_EXT_V5ExP	 0x00000200	/* DSP core set.           */
#define ARM_EXT_V5E	 0x00000400	/* DSP Double transfers.   */
#define ARM_EXT_V5J	 0x00000800	/* Jazelle extension.	   */
#define ARM_EXT_V6       0x00001000     /* ARM V6.                 */

/* Co-processor space extensions.  */
#define ARM_CEXT_XSCALE   0x00800000	/* Allow MIA etc.          */
#define ARM_CEXT_MAVERICK 0x00400000	/* Use Cirrus/DSP coprocessor.  */
#define ARM_CEXT_IWMMXT   0x00200000    /* Intel Wireless MMX technology coprocessor.   */

/* Architectures are the sum of the base and extensions.  The ARM ARM (rev E)
   defines the following: ARMv3, ARMv3M, ARMv4xM, ARMv4, ARMv4TxM, ARMv4T,
   ARMv5xM, ARMv5, ARMv5TxM, ARMv5T, ARMv5TExP, ARMv5TE.  To these we add
   three more to cover cores prior to ARM6.  Finally, there are cores which
   implement further extensions in the co-processor space.  */
#define ARM_ARCH_V1			  ARM_EXT_V1
#define ARM_ARCH_V2	(ARM_ARCH_V1	| ARM_EXT_V2)
#define ARM_ARCH_V2S	(ARM_ARCH_V2	| ARM_EXT_V2S)
#define ARM_ARCH_V3	(ARM_ARCH_V2S	| ARM_EXT_V3)
#define ARM_ARCH_V3M	(ARM_ARCH_V3	| ARM_EXT_V3M)
#define ARM_ARCH_V4xM	(ARM_ARCH_V3	| ARM_EXT_V4)
#define ARM_ARCH_V4	(ARM_ARCH_V3M	| ARM_EXT_V4)
#define ARM_ARCH_V4TxM	(ARM_ARCH_V4xM	| ARM_EXT_V4T)
#define ARM_ARCH_V4T	(ARM_ARCH_V4	| ARM_EXT_V4T)
#define ARM_ARCH_V5xM	(ARM_ARCH_V4xM	| ARM_EXT_V5)
#define ARM_ARCH_V5	(ARM_ARCH_V4	| ARM_EXT_V5)
#define ARM_ARCH_V5TxM	(ARM_ARCH_V5xM	| ARM_EXT_V4T | ARM_EXT_V5T)
#define ARM_ARCH_V5T	(ARM_ARCH_V5	| ARM_EXT_V4T | ARM_EXT_V5T)
#define ARM_ARCH_V5TExP	(ARM_ARCH_V5T	| ARM_EXT_V5ExP)
#define ARM_ARCH_V5TE	(ARM_ARCH_V5TExP | ARM_EXT_V5E)
#define ARM_ARCH_V5TEJ	(ARM_ARCH_V5TE	| ARM_EXT_V5J)
#define ARM_ARCH_V6     (ARM_ARCH_V5TEJ | ARM_EXT_V6)

/* Processors with specific extensions in the co-processor space.  */
#define ARM_ARCH_XSCALE	(ARM_ARCH_V5TE	| ARM_CEXT_XSCALE)
#define ARM_ARCH_IWMMXT	(ARM_ARCH_XSCALE | ARM_CEXT_IWMMXT)

/* Some useful combinations:  */
#define ARM_ANY		0x0000ffff	/* Any basic core.  */
#define ARM_ALL		0x00ffffff	/* Any core + co-processor */
#define CPROC_ANY	0x00ff0000	/* Any co-processor */
#define FPU_ANY		0xff000000	/* Note this is ~ARM_ALL.  */


#define FPU_FPA_EXT_V1	 0x80000000	/* Base FPA instruction set.  */
#define FPU_FPA_EXT_V2	 0x40000000	/* LFM/SFM.		      */
#define FPU_VFP_EXT_NONE 0x20000000	/* Use VFP word-ordering.     */
#define FPU_VFP_EXT_V1xD 0x10000000	/* Base VFP instruction set.  */
#define FPU_VFP_EXT_V1	 0x08000000	/* Double-precision insns.    */
#define FPU_VFP_EXT_V2	 0x04000000	/* ARM10E VFPr1.	      */
#define FPU_MAVERICK	 0x02000000	/* Cirrus Maverick.	      */
#define FPU_NONE	 0

#define FPU_ARCH_FPE	 FPU_FPA_EXT_V1
#define FPU_ARCH_FPA	(FPU_ARCH_FPE | FPU_FPA_EXT_V2)

#define FPU_ARCH_VFP       FPU_VFP_EXT_NONE
#define FPU_ARCH_VFP_V1xD (FPU_VFP_EXT_V1xD | FPU_VFP_EXT_NONE)
#define FPU_ARCH_VFP_V1   (FPU_ARCH_VFP_V1xD | FPU_VFP_EXT_V1)
#define FPU_ARCH_VFP_V2	  (FPU_ARCH_VFP_V1 | FPU_VFP_EXT_V2)

#define FPU_ARCH_MAVERICK  FPU_MAVERICK

enum arm_float_abi
{
  ARM_FLOAT_ABI_HARD,
  ARM_FLOAT_ABI_SOFTFP,
  ARM_FLOAT_ABI_SOFT
};

/* Types of processor to assemble for.  */
#define ARM_1		ARM_ARCH_V1
#define ARM_2		ARM_ARCH_V2
#define ARM_3		ARM_ARCH_V2S
#define ARM_250		ARM_ARCH_V2S
#define ARM_6		ARM_ARCH_V3
#define ARM_7		ARM_ARCH_V3
#define ARM_8		ARM_ARCH_V4
#define ARM_9		ARM_ARCH_V4T
#define ARM_STRONG	ARM_ARCH_V4
#define ARM_CPU_MASK	0x0000000f              /* XXX? */

#ifndef CPU_DEFAULT
#if defined __XSCALE__
#define CPU_DEFAULT	(ARM_ARCH_XSCALE)
#else
#if defined __thumb__
#define CPU_DEFAULT 	(ARM_ARCH_V5T)
#else
#define CPU_DEFAULT 	ARM_ANY
#endif
#endif
#endif

#ifdef TE_LINUX
#define FPU_DEFAULT FPU_ARCH_FPA
#endif

#if defined(TE_NetBSD) || defined(TE_OpenBSD)
#ifdef OBJ_ELF
#define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, but VFP order.  */
#else
/* Legacy a.out format.  */
#define FPU_DEFAULT FPU_ARCH_FPA	/* Soft-float, but FPA order.  */
#endif
#endif

/* For backwards compatibility we default to the FPA.  */
#ifndef FPU_DEFAULT
#define FPU_DEFAULT FPU_ARCH_FPA
#endif

#define streq(a, b)           (strcmp (a, b) == 0)
#define skip_whitespace(str)  while (*(str) == ' ') ++(str)

static unsigned long cpu_variant;
static int target_oabi = 0;

/* Flags stored in private area of BFD structure.  */
static int uses_apcs_26      = FALSE;
static int atpcs             = FALSE;
static int support_interwork = FALSE;
static int uses_apcs_float   = FALSE;
static int pic_code          = FALSE;

/* Variables that we set while parsing command-line options.  Once all
   options have been read we re-process these values to set the real
   assembly flags.  */
static int legacy_cpu = -1;
static int legacy_fpu = -1;

static int mcpu_cpu_opt = -1;
static int mcpu_fpu_opt = -1;
static int march_cpu_opt = -1;
static int march_fpu_opt = -1;
static int mfpu_opt = -1;
static int mfloat_abi_opt = -1;

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "@@";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.  */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant
   from exp in floating point numbers.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456  */
/* or    0d1.2345e12  */

const char FLT_CHARS[] = "rRsSfFdDxXeEpP";

/* Prefix characters that indicate the start of an immediate
   value.  */
#define is_immediate_prefix(C) ((C) == '#' || (C) == '$')

#ifdef OBJ_ELF
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"  */
symbolS * GOT_symbol;
#endif

/* Size of relocation record.  */
const int md_reloc_size = 8;

/* 0: assemble for ARM,
   1: assemble for Thumb,
   2: assemble for Thumb even though target CPU does not support thumb
      instructions.  */
static int thumb_mode = 0;

typedef struct arm_fix
{
  int thumb_mode;
} arm_fix_data;

struct arm_it
{
  const char *  error;
  unsigned long instruction;
  int           size;
  struct
  {
    bfd_reloc_code_real_type type;
    expressionS              exp;
    int                      pc_rel;
  } reloc;
};

struct arm_it inst;

enum asm_shift_index
{
  SHIFT_LSL = 0,
  SHIFT_LSR,
  SHIFT_ASR,
  SHIFT_ROR,
  SHIFT_RRX
};

struct asm_shift_properties
{
  enum asm_shift_index index;
  unsigned long        bit_field;
  unsigned int         allows_0  : 1;
  unsigned int         allows_32 : 1;
};

static const struct asm_shift_properties shift_properties [] =
{
  { SHIFT_LSL, 0,    1, 0},
  { SHIFT_LSR, 0x20, 0, 1},
  { SHIFT_ASR, 0x40, 0, 1},
  { SHIFT_ROR, 0x60, 0, 0},
  { SHIFT_RRX, 0x60, 0, 0}
};

struct asm_shift_name
{
  const char *                        name;
  const struct asm_shift_properties * properties;
};

static const struct asm_shift_name shift_names [] =
{
  { "asl", shift_properties + SHIFT_LSL },
  { "lsl", shift_properties + SHIFT_LSL },
  { "lsr", shift_properties + SHIFT_LSR },
  { "asr", shift_properties + SHIFT_ASR },
  { "ror", shift_properties + SHIFT_ROR },
  { "rrx", shift_properties + SHIFT_RRX },
  { "ASL", shift_properties + SHIFT_LSL },
  { "LSL", shift_properties + SHIFT_LSL },
  { "LSR", shift_properties + SHIFT_LSR },
  { "ASR", shift_properties + SHIFT_ASR },
  { "ROR", shift_properties + SHIFT_ROR },
  { "RRX", shift_properties + SHIFT_RRX }
};

/* Any kind of shift is accepted.  */
#define NO_SHIFT_RESTRICT 1
/* The shift operand must be an immediate value, not a register.  */
#define SHIFT_IMMEDIATE	  0
/* The shift must be LSL or ASR and the operand must be an immediate.  */
#define SHIFT_LSL_OR_ASR_IMMEDIATE 2
/* The shift must be ASR and the operand must be an immediate.  */
#define SHIFT_ASR_IMMEDIATE 3
/* The shift must be LSL and the operand must be an immediate.  */
#define SHIFT_LSL_IMMEDIATE 4

#define NUM_FLOAT_VALS 8

const char * fp_const[] =
{
  "0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0", 0
};

/* Number of littlenums required to hold an extended precision number.  */
#define MAX_LITTLENUMS 6

LITTLENUM_TYPE fp_values[NUM_FLOAT_VALS][MAX_LITTLENUMS];

#define FAIL	(-1)
#define SUCCESS (0)

/* Whether a Co-processor load/store operation accepts write-back forms.  */
#define CP_WB_OK 1
#define CP_NO_WB 0

#define SUFF_S 1
#define SUFF_D 2
#define SUFF_E 3
#define SUFF_P 4

#define CP_T_X   0x00008000
#define CP_T_Y   0x00400000
#define CP_T_Pre 0x01000000
#define CP_T_UD  0x00800000
#define CP_T_WB  0x00200000

#define CONDS_BIT        0x00100000
#define LOAD_BIT         0x00100000

#define DOUBLE_LOAD_FLAG 0x00000001

struct asm_cond
{
  const char *  template;
  unsigned long value;
};

#define COND_ALWAYS 0xe0000000
#define COND_MASK   0xf0000000

static const struct asm_cond conds[] =
{
  {"eq", 0x00000000},
  {"ne", 0x10000000},
  {"cs", 0x20000000}, {"hs", 0x20000000},
  {"cc", 0x30000000}, {"ul", 0x30000000}, {"lo", 0x30000000},
  {"mi", 0x40000000},
  {"pl", 0x50000000},
  {"vs", 0x60000000},
  {"vc", 0x70000000},
  {"hi", 0x80000000},
  {"ls", 0x90000000},
  {"ge", 0xa0000000},
  {"lt", 0xb0000000},
  {"gt", 0xc0000000},
  {"le", 0xd0000000},
  {"al", 0xe0000000},
  {"nv", 0xf0000000}
};

struct asm_psr
{
  const char *template;
  bfd_boolean cpsr;
  unsigned long field;
};

/* The bit that distinguishes CPSR and SPSR.  */
#define SPSR_BIT   (1 << 22)

/* How many bits to shift the PSR_xxx bits up by.  */
#define PSR_SHIFT  16

#define PSR_c   (1 << 0)
#define PSR_x   (1 << 1)
#define PSR_s   (1 << 2)
#define PSR_f   (1 << 3)

static const struct asm_psr psrs[] =
{
  {"CPSR",	TRUE,  PSR_c | PSR_f},
  {"CPSR_all",	TRUE,  PSR_c | PSR_f},
  {"SPSR",	FALSE, PSR_c | PSR_f},
  {"SPSR_all",	FALSE, PSR_c | PSR_f},
  {"CPSR_flg",	TRUE,  PSR_f},
  {"CPSR_f",    TRUE,  PSR_f},
  {"SPSR_flg",	FALSE, PSR_f},
  {"SPSR_f",    FALSE, PSR_f},
  {"CPSR_c",	TRUE,  PSR_c},
  {"CPSR_ctl",	TRUE,  PSR_c},
  {"SPSR_c",	FALSE, PSR_c},
  {"SPSR_ctl",	FALSE, PSR_c},
  {"CPSR_x",    TRUE,  PSR_x},
  {"CPSR_s",    TRUE,  PSR_s},
  {"SPSR_x",    FALSE, PSR_x},
  {"SPSR_s",    FALSE, PSR_s},
  /* Combinations of flags.  */
  {"CPSR_fs",	TRUE, PSR_f | PSR_s},
  {"CPSR_fx",	TRUE, PSR_f | PSR_x},
  {"CPSR_fc",	TRUE, PSR_f | PSR_c},
  {"CPSR_sf",	TRUE, PSR_s | PSR_f},
  {"CPSR_sx",	TRUE, PSR_s | PSR_x},
  {"CPSR_sc",	TRUE, PSR_s | PSR_c},
  {"CPSR_xf",	TRUE, PSR_x | PSR_f},
  {"CPSR_xs",	TRUE, PSR_x | PSR_s},
  {"CPSR_xc",	TRUE, PSR_x | PSR_c},
  {"CPSR_cf",	TRUE, PSR_c | PSR_f},
  {"CPSR_cs",	TRUE, PSR_c | PSR_s},
  {"CPSR_cx",	TRUE, PSR_c | PSR_x},
  {"CPSR_fsx",	TRUE, PSR_f | PSR_s | PSR_x},
  {"CPSR_fsc",	TRUE, PSR_f | PSR_s | PSR_c},
  {"CPSR_fxs",	TRUE, PSR_f | PSR_x | PSR_s},
  {"CPSR_fxc",	TRUE, PSR_f | PSR_x | PSR_c},
  {"CPSR_fcs",	TRUE, PSR_f | PSR_c | PSR_s},
  {"CPSR_fcx",	TRUE, PSR_f | PSR_c | PSR_x},
  {"CPSR_sfx",	TRUE, PSR_s | PSR_f | PSR_x},
  {"CPSR_sfc",	TRUE, PSR_s | PSR_f | PSR_c},
  {"CPSR_sxf",	TRUE, PSR_s | PSR_x | PSR_f},
  {"CPSR_sxc",	TRUE, PSR_s | PSR_x | PSR_c},
  {"CPSR_scf",	TRUE, PSR_s | PSR_c | PSR_f},
  {"CPSR_scx",	TRUE, PSR_s | PSR_c | PSR_x},
  {"CPSR_xfs",	TRUE, PSR_x | PSR_f | PSR_s},
  {"CPSR_xfc",	TRUE, PSR_x | PSR_f | PSR_c},
  {"CPSR_xsf",	TRUE, PSR_x | PSR_s | PSR_f},
  {"CPSR_xsc",	TRUE, PSR_x | PSR_s | PSR_c},
  {"CPSR_xcf",	TRUE, PSR_x | PSR_c | PSR_f},
  {"CPSR_xcs",	TRUE, PSR_x | PSR_c | PSR_s},
  {"CPSR_cfs",	TRUE, PSR_c | PSR_f | PSR_s},
  {"CPSR_cfx",	TRUE, PSR_c | PSR_f | PSR_x},
  {"CPSR_csf",	TRUE, PSR_c | PSR_s | PSR_f},
  {"CPSR_csx",	TRUE, PSR_c | PSR_s | PSR_x},
  {"CPSR_cxf",	TRUE, PSR_c | PSR_x | PSR_f},
  {"CPSR_cxs",	TRUE, PSR_c | PSR_x | PSR_s},
  {"CPSR_fsxc",	TRUE, PSR_f | PSR_s | PSR_x | PSR_c},
  {"CPSR_fscx",	TRUE, PSR_f | PSR_s | PSR_c | PSR_x},
  {"CPSR_fxsc",	TRUE, PSR_f | PSR_x | PSR_s | PSR_c},
  {"CPSR_fxcs",	TRUE, PSR_f | PSR_x | PSR_c | PSR_s},
  {"CPSR_fcsx",	TRUE, PSR_f | PSR_c | PSR_s | PSR_x},
  {"CPSR_fcxs",	TRUE, PSR_f | PSR_c | PSR_x | PSR_s},
  {"CPSR_sfxc",	TRUE, PSR_s | PSR_f | PSR_x | PSR_c},
  {"CPSR_sfcx",	TRUE, PSR_s | PSR_f | PSR_c | PSR_x},
  {"CPSR_sxfc",	TRUE, PSR_s | PSR_x | PSR_f | PSR_c},
  {"CPSR_sxcf",	TRUE, PSR_s | PSR_x | PSR_c | PSR_f},
  {"CPSR_scfx",	TRUE, PSR_s | PSR_c | PSR_f | PSR_x},
  {"CPSR_scxf",	TRUE, PSR_s | PSR_c | PSR_x | PSR_f},
  {"CPSR_xfsc",	TRUE, PSR_x | PSR_f | PSR_s | PSR_c},
  {"CPSR_xfcs",	TRUE, PSR_x | PSR_f | PSR_c | PSR_s},
  {"CPSR_xsfc",	TRUE, PSR_x | PSR_s | PSR_f | PSR_c},
  {"CPSR_xscf",	TRUE, PSR_x | PSR_s | PSR_c | PSR_f},
  {"CPSR_xcfs",	TRUE, PSR_x | PSR_c | PSR_f | PSR_s},
  {"CPSR_xcsf",	TRUE, PSR_x | PSR_c | PSR_s | PSR_f},
  {"CPSR_cfsx",	TRUE, PSR_c | PSR_f | PSR_s | PSR_x},
  {"CPSR_cfxs",	TRUE, PSR_c | PSR_f | PSR_x | PSR_s},
  {"CPSR_csfx",	TRUE, PSR_c | PSR_s | PSR_f | PSR_x},
  {"CPSR_csxf",	TRUE, PSR_c | PSR_s | PSR_x | PSR_f},
  {"CPSR_cxfs",	TRUE, PSR_c | PSR_x | PSR_f | PSR_s},
  {"CPSR_cxsf",	TRUE, PSR_c | PSR_x | PSR_s | PSR_f},
  {"SPSR_fs",	FALSE, PSR_f | PSR_s},
  {"SPSR_fx",	FALSE, PSR_f | PSR_x},
  {"SPSR_fc",	FALSE, PSR_f | PSR_c},
  {"SPSR_sf",	FALSE, PSR_s | PSR_f},
  {"SPSR_sx",	FALSE, PSR_s | PSR_x},
  {"SPSR_sc",	FALSE, PSR_s | PSR_c},
  {"SPSR_xf",	FALSE, PSR_x | PSR_f},
  {"SPSR_xs",	FALSE, PSR_x | PSR_s},
  {"SPSR_xc",	FALSE, PSR_x | PSR_c},
  {"SPSR_cf",	FALSE, PSR_c | PSR_f},
  {"SPSR_cs",	FALSE, PSR_c | PSR_s},
  {"SPSR_cx",	FALSE, PSR_c | PSR_x},
  {"SPSR_fsx",	FALSE, PSR_f | PSR_s | PSR_x},
  {"SPSR_fsc",	FALSE, PSR_f | PSR_s | PSR_c},
  {"SPSR_fxs",	FALSE, PSR_f | PSR_x | PSR_s},
  {"SPSR_fxc",	FALSE, PSR_f | PSR_x | PSR_c},
  {"SPSR_fcs",	FALSE, PSR_f | PSR_c | PSR_s},
  {"SPSR_fcx",	FALSE, PSR_f | PSR_c | PSR_x},
  {"SPSR_sfx",	FALSE, PSR_s | PSR_f | PSR_x},
  {"SPSR_sfc",	FALSE, PSR_s | PSR_f | PSR_c},
  {"SPSR_sxf",	FALSE, PSR_s | PSR_x | PSR_f},
  {"SPSR_sxc",	FALSE, PSR_s | PSR_x | PSR_c},
  {"SPSR_scf",	FALSE, PSR_s | PSR_c | PSR_f},
  {"SPSR_scx",	FALSE, PSR_s | PSR_c | PSR_x},
  {"SPSR_xfs",	FALSE, PSR_x | PSR_f | PSR_s},
  {"SPSR_xfc",	FALSE, PSR_x | PSR_f | PSR_c},
  {"SPSR_xsf",	FALSE, PSR_x | PSR_s | PSR_f},
  {"SPSR_xsc",	FALSE, PSR_x | PSR_s | PSR_c},
  {"SPSR_xcf",	FALSE, PSR_x | PSR_c | PSR_f},
  {"SPSR_xcs",	FALSE, PSR_x | PSR_c | PSR_s},
  {"SPSR_cfs",	FALSE, PSR_c | PSR_f | PSR_s},
  {"SPSR_cfx",	FALSE, PSR_c | PSR_f | PSR_x},
  {"SPSR_csf",	FALSE, PSR_c | PSR_s | PSR_f},
  {"SPSR_csx",	FALSE, PSR_c | PSR_s | PSR_x},
  {"SPSR_cxf",	FALSE, PSR_c | PSR_x | PSR_f},
  {"SPSR_cxs",	FALSE, PSR_c | PSR_x | PSR_s},
  {"SPSR_fsxc",	FALSE, PSR_f | PSR_s | PSR_x | PSR_c},
  {"SPSR_fscx",	FALSE, PSR_f | PSR_s | PSR_c | PSR_x},
  {"SPSR_fxsc",	FALSE, PSR_f | PSR_x | PSR_s | PSR_c},
  {"SPSR_fxcs",	FALSE, PSR_f | PSR_x | PSR_c | PSR_s},
  {"SPSR_fcsx",	FALSE, PSR_f | PSR_c | PSR_s | PSR_x},
  {"SPSR_fcxs",	FALSE, PSR_f | PSR_c | PSR_x | PSR_s},
  {"SPSR_sfxc",	FALSE, PSR_s | PSR_f | PSR_x | PSR_c},
  {"SPSR_sfcx",	FALSE, PSR_s | PSR_f | PSR_c | PSR_x},
  {"SPSR_sxfc",	FALSE, PSR_s | PSR_x | PSR_f | PSR_c},
  {"SPSR_sxcf",	FALSE, PSR_s | PSR_x | PSR_c | PSR_f},
  {"SPSR_scfx",	FALSE, PSR_s | PSR_c | PSR_f | PSR_x},
  {"SPSR_scxf",	FALSE, PSR_s | PSR_c | PSR_x | PSR_f},
  {"SPSR_xfsc",	FALSE, PSR_x | PSR_f | PSR_s | PSR_c},
  {"SPSR_xfcs",	FALSE, PSR_x | PSR_f | PSR_c | PSR_s},
  {"SPSR_xsfc",	FALSE, PSR_x | PSR_s | PSR_f | PSR_c},
  {"SPSR_xscf",	FALSE, PSR_x | PSR_s | PSR_c | PSR_f},
  {"SPSR_xcfs",	FALSE, PSR_x | PSR_c | PSR_f | PSR_s},
  {"SPSR_xcsf",	FALSE, PSR_x | PSR_c | PSR_s | PSR_f},
  {"SPSR_cfsx",	FALSE, PSR_c | PSR_f | PSR_s | PSR_x},
  {"SPSR_cfxs",	FALSE, PSR_c | PSR_f | PSR_x | PSR_s},
  {"SPSR_csfx",	FALSE, PSR_c | PSR_s | PSR_f | PSR_x},
  {"SPSR_csxf",	FALSE, PSR_c | PSR_s | PSR_x | PSR_f},
  {"SPSR_cxfs",	FALSE, PSR_c | PSR_x | PSR_f | PSR_s},
  {"SPSR_cxsf",	FALSE, PSR_c | PSR_x | PSR_s | PSR_f},
};

enum wreg_type
  {
    IWMMXT_REG_WR = 0,
    IWMMXT_REG_WC = 1,
    IWMMXT_REG_WR_OR_WC = 2,
    IWMMXT_REG_WCG
  };

enum iwmmxt_insn_type
{
  check_rd,
  check_wr,
  check_wrwr,
  check_wrwrwr,
  check_wrwrwcg,
  check_tbcst,
  check_tmovmsk,
  check_tmia,
  check_tmcrr,
  check_tmrrc,
  check_tmcr,
  check_tmrc,
  check_tinsr,
  check_textrc,
  check_waligni,
  check_textrm,
  check_wshufh
};

enum vfp_dp_reg_pos
{
  VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
};

enum vfp_sp_reg_pos
{
  VFP_REG_Sd, VFP_REG_Sm, VFP_REG_Sn
};

enum vfp_ldstm_type
{
  VFP_LDSTMIA, VFP_LDSTMDB, VFP_LDSTMIAX, VFP_LDSTMDBX
};

/* VFP system registers.  */
struct vfp_reg
{
  const char *name;
  unsigned long regno;
};

static const struct vfp_reg vfp_regs[] =
{
  {"fpsid", 0x00000000},
  {"FPSID", 0x00000000},
  {"fpscr", 0x00010000},
  {"FPSCR", 0x00010000},
  {"fpexc", 0x00080000},
  {"FPEXC", 0x00080000}
};

/* Structure for a hash table entry for a register.  */
struct reg_entry
{
  const char * name;
  int          number;
  bfd_boolean  builtin;
};

/* Some well known registers that we refer to directly elsewhere.  */
#define REG_SP  13
#define REG_LR  14
#define REG_PC	15

#define wr_register(reg)  ((reg ^ WR_PREFIX) >= 0 && (reg ^ WR_PREFIX) <= 15)
#define wc_register(reg)  ((reg ^ WC_PREFIX) >= 0 && (reg ^ WC_PREFIX) <= 15)
#define wcg_register(reg) ((reg ^ WC_PREFIX) >= 8 && (reg ^ WC_PREFIX) <= 11)

/* These are the standard names.  Users can add aliases with .req.
   and delete them with .unreq.  */

/* Integer Register Numbers.  */
static const struct reg_entry rn_table[] =
{
  {"r0",  0, TRUE},  {"r1",  1, TRUE},      {"r2",  2, TRUE},      {"r3",  3, TRUE},
  {"r4",  4, TRUE},  {"r5",  5, TRUE},      {"r6",  6, TRUE},      {"r7",  7, TRUE},
  {"r8",  8, TRUE},  {"r9",  9, TRUE},      {"r10", 10, TRUE},     {"r11", 11, TRUE},
  {"r12", 12, TRUE}, {"r13", REG_SP, TRUE}, {"r14", REG_LR, TRUE}, {"r15", REG_PC, TRUE},
  /* ATPCS Synonyms.  */
  {"a1",  0, TRUE},  {"a2",  1, TRUE},      {"a3",  2, TRUE},      {"a4",  3, TRUE},
  {"v1",  4, TRUE},  {"v2",  5, TRUE},      {"v3",  6, TRUE},      {"v4",  7, TRUE},
  {"v5",  8, TRUE},  {"v6",  9, TRUE},      {"v7",  10, TRUE},     {"v8",  11, TRUE},
  /* Well-known aliases.  */
  {"wr",  7, TRUE},  {"sb",  9, TRUE},      {"sl",  10, TRUE},     {"fp",  11, TRUE},
  {"ip",  12, TRUE}, {"sp",  REG_SP, TRUE}, {"lr",  REG_LR, TRUE}, {"pc",  REG_PC, TRUE},
  {NULL, 0, TRUE}
};

#define WR_PREFIX 0x200
#define WC_PREFIX 0x400

static const struct reg_entry iwmmxt_table[] =
{
  /* Intel Wireless MMX technology register names.  */
  {  "wr0", 0x0 | WR_PREFIX, TRUE},   {"wr1", 0x1 | WR_PREFIX, TRUE},
  {  "wr2", 0x2 | WR_PREFIX, TRUE},   {"wr3", 0x3 | WR_PREFIX, TRUE},
  {  "wr4", 0x4 | WR_PREFIX, TRUE},   {"wr5", 0x5 | WR_PREFIX, TRUE},
  {  "wr6", 0x6 | WR_PREFIX, TRUE},   {"wr7", 0x7 | WR_PREFIX, TRUE},
  {  "wr8", 0x8 | WR_PREFIX, TRUE},   {"wr9", 0x9 | WR_PREFIX, TRUE},
  { "wr10", 0xa | WR_PREFIX, TRUE},  {"wr11", 0xb | WR_PREFIX, TRUE},
  { "wr12", 0xc | WR_PREFIX, TRUE},  {"wr13", 0xd | WR_PREFIX, TRUE},
  { "wr14", 0xe | WR_PREFIX, TRUE},  {"wr15", 0xf | WR_PREFIX, TRUE},
  { "wcid", 0x0 | WC_PREFIX, TRUE},  {"wcon", 0x1 | WC_PREFIX, TRUE},
  {"wcssf", 0x2 | WC_PREFIX, TRUE}, {"wcasf", 0x3 | WC_PREFIX, TRUE},
  {"wcgr0", 0x8 | WC_PREFIX, TRUE}, {"wcgr1", 0x9 | WC_PREFIX, TRUE},
  {"wcgr2", 0xa | WC_PREFIX, TRUE}, {"wcgr3", 0xb | WC_PREFIX, TRUE},

  {  "wR0", 0x0 | WR_PREFIX, TRUE},   {"wR1", 0x1 | WR_PREFIX, TRUE},
  {  "wR2", 0x2 | WR_PREFIX, TRUE},   {"wR3", 0x3 | WR_PREFIX, TRUE},
  {  "wR4", 0x4 | WR_PREFIX, TRUE},   {"wR5", 0x5 | WR_PREFIX, TRUE},
  {  "wR6", 0x6 | WR_PREFIX, TRUE},   {"wR7", 0x7 | WR_PREFIX, TRUE},
  {  "wR8", 0x8 | WR_PREFIX, TRUE},   {"wR9", 0x9 | WR_PREFIX, TRUE},
  { "wR10", 0xa | WR_PREFIX, TRUE},  {"wR11", 0xb | WR_PREFIX, TRUE},
  { "wR12", 0xc | WR_PREFIX, TRUE},  {"wR13", 0xd | WR_PREFIX, TRUE},
  { "wR14", 0xe | WR_PREFIX, TRUE},  {"wR15", 0xf | WR_PREFIX, TRUE},
  { "wCID", 0x0 | WC_PREFIX, TRUE},  {"wCon", 0x1 | WC_PREFIX, TRUE},
  {"wCSSF", 0x2 | WC_PREFIX, TRUE}, {"wCASF", 0x3 | WC_PREFIX, TRUE},
  {"wCGR0", 0x8 | WC_PREFIX, TRUE}, {"wCGR1", 0x9 | WC_PREFIX, TRUE},
  {"wCGR2", 0xa | WC_PREFIX, TRUE}, {"wCGR3", 0xb | WC_PREFIX, TRUE},
  {NULL, 0, TRUE}
};

/* Co-processor Numbers.  */
static const struct reg_entry cp_table[] =
{
  {"p0",  0, TRUE},  {"p1",  1, TRUE},  {"p2",  2, TRUE},  {"p3", 3, TRUE},
  {"p4",  4, TRUE},  {"p5",  5, TRUE},  {"p6",  6, TRUE},  {"p7", 7, TRUE},
  {"p8",  8, TRUE},  {"p9",  9, TRUE},  {"p10", 10, TRUE}, {"p11", 11, TRUE},
  {"p12", 12, TRUE}, {"p13", 13, TRUE}, {"p14", 14, TRUE}, {"p15", 15, TRUE},
  {NULL, 0, TRUE}
};

/* Co-processor Register Numbers.  */
static const struct reg_entry cn_table[] =
{
  {"c0",   0, TRUE},  {"c1",   1, TRUE},  {"c2",   2, TRUE},  {"c3",   3, TRUE},
  {"c4",   4, TRUE},  {"c5",   5, TRUE},  {"c6",   6, TRUE},  {"c7",   7, TRUE},
  {"c8",   8, TRUE},  {"c9",   9, TRUE},  {"c10",  10, TRUE}, {"c11",  11, TRUE},
  {"c12",  12, TRUE}, {"c13",  13, TRUE}, {"c14",  14, TRUE}, {"c15",  15, TRUE},
  /* Not really valid, but kept for back-wards compatibility.  */
  {"cr0",  0, TRUE},  {"cr1",  1, TRUE},  {"cr2",  2, TRUE},  {"cr3",  3, TRUE},
  {"cr4",  4, TRUE},  {"cr5",  5, TRUE},  {"cr6",  6, TRUE},  {"cr7",  7, TRUE},
  {"cr8",  8, TRUE},  {"cr9",  9, TRUE},  {"cr10", 10, TRUE}, {"cr11", 11, TRUE},
  {"cr12", 12, TRUE}, {"cr13", 13, TRUE}, {"cr14", 14, TRUE}, {"cr15", 15, TRUE},
  {NULL, 0, TRUE}
};

/* FPA Registers.  */
static const struct reg_entry fn_table[] =
{
  {"f0", 0, TRUE},   {"f1", 1, TRUE},   {"f2", 2, TRUE},   {"f3", 3, TRUE},
  {"f4", 4, TRUE},   {"f5", 5, TRUE},   {"f6", 6, TRUE},   {"f7", 7, TRUE},
  {NULL, 0, TRUE}
};

/* VFP SP Registers.  */
static const struct reg_entry sn_table[] =
{
  {"s0",  0, TRUE},  {"s1",  1, TRUE},  {"s2",  2, TRUE},  {"s3", 3, TRUE},
  {"s4",  4, TRUE},  {"s5",  5, TRUE},  {"s6",  6, TRUE},  {"s7", 7, TRUE},
  {"s8",  8, TRUE},  {"s9",  9, TRUE},  {"s10", 10, TRUE}, {"s11", 11, TRUE},
  {"s12", 12, TRUE}, {"s13", 13, TRUE}, {"s14", 14, TRUE}, {"s15", 15, TRUE},
  {"s16", 16, TRUE}, {"s17", 17, TRUE}, {"s18", 18, TRUE}, {"s19", 19, TRUE},
  {"s20", 20, TRUE}, {"s21", 21, TRUE}, {"s22", 22, TRUE}, {"s23", 23, TRUE},
  {"s24", 24, TRUE}, {"s25", 25, TRUE}, {"s26", 26, TRUE}, {"s27", 27, TRUE},
  {"s28", 28, TRUE}, {"s29", 29, TRUE}, {"s30", 30, TRUE}, {"s31", 31, TRUE},
  {NULL, 0, TRUE}
};

/* VFP DP Registers.  */
static const struct reg_entry dn_table[] =
{
  {"d0",  0, TRUE},  {"d1",  1, TRUE},  {"d2",  2, TRUE},  {"d3", 3, TRUE},
  {"d4",  4, TRUE},  {"d5",  5, TRUE},  {"d6",  6, TRUE},  {"d7", 7, TRUE},
  {"d8",  8, TRUE},  {"d9",  9, TRUE},  {"d10", 10, TRUE}, {"d11", 11, TRUE},
  {"d12", 12, TRUE}, {"d13", 13, TRUE}, {"d14", 14, TRUE}, {"d15", 15, TRUE},
  {NULL, 0, TRUE}
};

/* Maverick DSP coprocessor registers.  */
static const struct reg_entry mav_mvf_table[] =
{
  {"mvf0",  0, TRUE},  {"mvf1",  1, TRUE},  {"mvf2",  2, TRUE},  {"mvf3",  3, TRUE},
  {"mvf4",  4, TRUE},  {"mvf5",  5, TRUE},  {"mvf6",  6, TRUE},  {"mvf7",  7, TRUE},
  {"mvf8",  8, TRUE},  {"mvf9",  9, TRUE},  {"mvf10", 10, TRUE}, {"mvf11", 11, TRUE},
  {"mvf12", 12, TRUE}, {"mvf13", 13, TRUE}, {"mvf14", 14, TRUE}, {"mvf15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvd_table[] =
{
  {"mvd0",  0, TRUE},  {"mvd1",  1, TRUE},  {"mvd2",  2, TRUE},  {"mvd3",  3, TRUE},
  {"mvd4",  4, TRUE},  {"mvd5",  5, TRUE},  {"mvd6",  6, TRUE},  {"mvd7",  7, TRUE},
  {"mvd8",  8, TRUE},  {"mvd9",  9, TRUE},  {"mvd10", 10, TRUE}, {"mvd11", 11, TRUE},
  {"mvd12", 12, TRUE}, {"mvd13", 13, TRUE}, {"mvd14", 14, TRUE}, {"mvd15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvfx_table[] =
{
  {"mvfx0",  0, TRUE},  {"mvfx1",  1, TRUE},  {"mvfx2",  2, TRUE},  {"mvfx3",  3, TRUE},
  {"mvfx4",  4, TRUE},  {"mvfx5",  5, TRUE},  {"mvfx6",  6, TRUE},  {"mvfx7",  7, TRUE},
  {"mvfx8",  8, TRUE},  {"mvfx9",  9, TRUE},  {"mvfx10", 10, TRUE}, {"mvfx11", 11, TRUE},
  {"mvfx12", 12, TRUE}, {"mvfx13", 13, TRUE}, {"mvfx14", 14, TRUE}, {"mvfx15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvdx_table[] =
{
  {"mvdx0",  0, TRUE},  {"mvdx1",  1, TRUE},  {"mvdx2",  2, TRUE},  {"mvdx3",  3, TRUE},
  {"mvdx4",  4, TRUE},  {"mvdx5",  5, TRUE},  {"mvdx6",  6, TRUE},  {"mvdx7",  7, TRUE},
  {"mvdx8",  8, TRUE},  {"mvdx9",  9, TRUE},  {"mvdx10", 10, TRUE}, {"mvdx11", 11, TRUE},
  {"mvdx12", 12, TRUE}, {"mvdx13", 13, TRUE}, {"mvdx14", 14, TRUE}, {"mvdx15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvax_table[] =
{
  {"mvax0", 0, TRUE}, {"mvax1", 1, TRUE}, {"mvax2", 2, TRUE}, {"mvax3", 3, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_dspsc_table[] =
{
  {"dspsc", 0, TRUE},
  {NULL, 0, TRUE}
};

struct reg_map
{
  const struct reg_entry *names;
  int max_regno;
  struct hash_control *htab;
  const char *expected;
};

struct reg_map all_reg_maps[] =
{
  {rn_table,        15, NULL, N_("ARM register expected")},
  {cp_table,        15, NULL, N_("bad or missing co-processor number")},
  {cn_table,        15, NULL, N_("co-processor register expected")},
  {fn_table,         7, NULL, N_("FPA register expected")},
  {sn_table,	    31, NULL, N_("VFP single precision register expected")},
  {dn_table,	    15, NULL, N_("VFP double precision register expected")},
  {mav_mvf_table,   15, NULL, N_("Maverick MVF register expected")},
  {mav_mvd_table,   15, NULL, N_("Maverick MVD register expected")},
  {mav_mvfx_table,  15, NULL, N_("Maverick MVFX register expected")},
  {mav_mvdx_table,  15, NULL, N_("Maverick MVDX register expected")},
  {mav_mvax_table,   3, NULL, N_("Maverick MVAX register expected")},
  {mav_dspsc_table,  0, NULL, N_("Maverick DSPSC register expected")},
  {iwmmxt_table,    23, NULL, N_("Intel Wireless MMX technology register expected")},
};

/* Enumeration matching entries in table above.  */
enum arm_reg_type
{
  REG_TYPE_RN = 0,
#define REG_TYPE_FIRST REG_TYPE_RN
  REG_TYPE_CP = 1,
  REG_TYPE_CN = 2,
  REG_TYPE_FN = 3,
  REG_TYPE_SN = 4,
  REG_TYPE_DN = 5,
  REG_TYPE_MVF = 6,
  REG_TYPE_MVD = 7,
  REG_TYPE_MVFX = 8,
  REG_TYPE_MVDX = 9,
  REG_TYPE_MVAX = 10,
  REG_TYPE_DSPSC = 11,
  REG_TYPE_IWMMXT = 12,

  REG_TYPE_MAX = 13
};

/* Functions called by parser.  */
/* ARM instructions.  */
static void do_arit		PARAMS ((char *));
static void do_cmp		PARAMS ((char *));
static void do_mov		PARAMS ((char *));
static void do_ldst		PARAMS ((char *));
static void do_ldstt		PARAMS ((char *));
static void do_ldmstm		PARAMS ((char *));
static void do_branch		PARAMS ((char *));
static void do_swi		PARAMS ((char *));

/* Pseudo Op codes.  */
static void do_adr		PARAMS ((char *));
static void do_adrl		PARAMS ((char *));
static void do_empty		PARAMS ((char *));

/* ARM v2.  */
static void do_mul		PARAMS ((char *));
static void do_mla		PARAMS ((char *));

/* ARM v2S.  */
static void do_swap		PARAMS ((char *));

/* ARM v3.  */
static void do_msr		PARAMS ((char *));
static void do_mrs		PARAMS ((char *));

/* ARM v3M.  */
static void do_mull		PARAMS ((char *));

/* ARM v4.  */
static void do_ldstv4		PARAMS ((char *));

/* ARM v4T.  */
static void do_bx               PARAMS ((char *));

/* ARM v5T.  */
static void do_blx		PARAMS ((char *));
static void do_bkpt		PARAMS ((char *));
static void do_clz		PARAMS ((char *));
static void do_lstc2		PARAMS ((char *));
static void do_cdp2		PARAMS ((char *));
static void do_co_reg2		PARAMS ((char *));

/* ARM v5TExP.  */
static void do_smla		PARAMS ((char *));
static void do_smlal		PARAMS ((char *));
static void do_smul		PARAMS ((char *));
static void do_qadd		PARAMS ((char *));

/* ARM v5TE.  */
static void do_pld		PARAMS ((char *));
static void do_ldrd		PARAMS ((char *));
static void do_co_reg2c		PARAMS ((char *));

/* ARM v5TEJ.  */
static void do_bxj		PARAMS ((char *));

/* ARM V6. */
static void do_cps              PARAMS ((char *));
static void do_cpsi             PARAMS ((char *));
static void do_ldrex            PARAMS ((char *));
static void do_pkhbt            PARAMS ((char *));
static void do_pkhtb            PARAMS ((char *));
static void do_qadd16           PARAMS ((char *));
static void do_rev              PARAMS ((char *));
static void do_rfe              PARAMS ((char *));
static void do_sxtah            PARAMS ((char *));
static void do_sxth             PARAMS ((char *));
static void do_setend           PARAMS ((char *));
static void do_smlad            PARAMS ((char *));
static void do_smlald           PARAMS ((char *));
static void do_smmul            PARAMS ((char *));
static void do_ssat             PARAMS ((char *));
static void do_usat             PARAMS ((char *));
static void do_srs              PARAMS ((char *));
static void do_ssat16           PARAMS ((char *));
static void do_usat16           PARAMS ((char *));
static void do_strex            PARAMS ((char *));
static void do_umaal            PARAMS ((char *));

static void do_cps_mode         PARAMS ((char **));
static void do_cps_flags        PARAMS ((char **, int));
static int do_endian_specifier  PARAMS ((char *));
static void do_pkh_core         PARAMS ((char *, int));
static void do_sat              PARAMS ((char **, int));
static void do_sat16            PARAMS ((char **, int));

/* Coprocessor Instructions.  */
static void do_cdp		PARAMS ((char *));
static void do_lstc		PARAMS ((char *));
static void do_co_reg		PARAMS ((char *));

/* FPA instructions.  */
static void do_fpa_ctrl		PARAMS ((char *));
static void do_fpa_ldst		PARAMS ((char *));
static void do_fpa_ldmstm	PARAMS ((char *));
static void do_fpa_dyadic	PARAMS ((char *));
static void do_fpa_monadic	PARAMS ((char *));
static void do_fpa_cmp		PARAMS ((char *));
static void do_fpa_from_reg	PARAMS ((char *));
static void do_fpa_to_reg	PARAMS ((char *));

/* VFP instructions.  */
static void do_vfp_sp_monadic	PARAMS ((char *));
static void do_vfp_dp_monadic	PARAMS ((char *));
static void do_vfp_sp_dyadic	PARAMS ((char *));
static void do_vfp_dp_dyadic	PARAMS ((char *));
static void do_vfp_reg_from_sp  PARAMS ((char *));
static void do_vfp_sp_from_reg  PARAMS ((char *));
static void do_vfp_reg2_from_sp2 PARAMS ((char *));
static void do_vfp_sp2_from_reg2 PARAMS ((char *));
static void do_vfp_reg_from_dp  PARAMS ((char *));
static void do_vfp_reg2_from_dp PARAMS ((char *));
static void do_vfp_dp_from_reg  PARAMS ((char *));
static void do_vfp_dp_from_reg2 PARAMS ((char *));
static void do_vfp_reg_from_ctrl PARAMS ((char *));
static void do_vfp_ctrl_from_reg PARAMS ((char *));
static void do_vfp_sp_ldst	PARAMS ((char *));
static void do_vfp_dp_ldst	PARAMS ((char *));
static void do_vfp_sp_ldstmia	PARAMS ((char *));
static void do_vfp_sp_ldstmdb	PARAMS ((char *));
static void do_vfp_dp_ldstmia	PARAMS ((char *));
static void do_vfp_dp_ldstmdb	PARAMS ((char *));
static void do_vfp_xp_ldstmia	PARAMS ((char *));
static void do_vfp_xp_ldstmdb	PARAMS ((char *));
static void do_vfp_sp_compare_z	PARAMS ((char *));
static void do_vfp_dp_compare_z	PARAMS ((char *));
static void do_vfp_dp_sp_cvt	PARAMS ((char *));
static void do_vfp_sp_dp_cvt	PARAMS ((char *));

/* XScale.  */
static void do_xsc_mia		PARAMS ((char *));
static void do_xsc_mar		PARAMS ((char *));
static void do_xsc_mra		PARAMS ((char *));

/* Maverick.  */
static void do_mav_binops	PARAMS ((char *, int, enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_binops_1a	PARAMS ((char *));
static void do_mav_binops_1b	PARAMS ((char *));
static void do_mav_binops_1c	PARAMS ((char *));
static void do_mav_binops_1d	PARAMS ((char *));
static void do_mav_binops_1e	PARAMS ((char *));
static void do_mav_binops_1f	PARAMS ((char *));
static void do_mav_binops_1g	PARAMS ((char *));
static void do_mav_binops_1h	PARAMS ((char *));
static void do_mav_binops_1i	PARAMS ((char *));
static void do_mav_binops_1j	PARAMS ((char *));
static void do_mav_binops_1k	PARAMS ((char *));
static void do_mav_binops_1l	PARAMS ((char *));
static void do_mav_binops_1m	PARAMS ((char *));
static void do_mav_binops_1n	PARAMS ((char *));
static void do_mav_binops_1o	PARAMS ((char *));
static void do_mav_binops_2a	PARAMS ((char *));
static void do_mav_binops_2b	PARAMS ((char *));
static void do_mav_binops_2c	PARAMS ((char *));
static void do_mav_binops_3a	PARAMS ((char *));
static void do_mav_binops_3b	PARAMS ((char *));
static void do_mav_binops_3c	PARAMS ((char *));
static void do_mav_binops_3d	PARAMS ((char *));
static void do_mav_triple	PARAMS ((char *, int, enum arm_reg_type,
					 enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_triple_4a	PARAMS ((char *));
static void do_mav_triple_4b	PARAMS ((char *));
static void do_mav_triple_5a	PARAMS ((char *));
static void do_mav_triple_5b	PARAMS ((char *));
static void do_mav_triple_5c	PARAMS ((char *));
static void do_mav_triple_5d	PARAMS ((char *));
static void do_mav_triple_5e	PARAMS ((char *));
static void do_mav_triple_5f	PARAMS ((char *));
static void do_mav_triple_5g	PARAMS ((char *));
static void do_mav_triple_5h	PARAMS ((char *));
static void do_mav_quad		PARAMS ((char *, int, enum arm_reg_type,
					 enum arm_reg_type,
					 enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_quad_6a	PARAMS ((char *));
static void do_mav_quad_6b	PARAMS ((char *));
static void do_mav_dspsc_1	PARAMS ((char *));
static void do_mav_dspsc_2	PARAMS ((char *));
static void do_mav_shift	PARAMS ((char *, enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_shift_1	PARAMS ((char *));
static void do_mav_shift_2	PARAMS ((char *));
static void do_mav_ldst		PARAMS ((char *, enum arm_reg_type));
static void do_mav_ldst_1	PARAMS ((char *));
static void do_mav_ldst_2	PARAMS ((char *));
static void do_mav_ldst_3	PARAMS ((char *));
static void do_mav_ldst_4	PARAMS ((char *));

static int mav_reg_required_here	PARAMS ((char **, int,
						 enum arm_reg_type));
static int mav_parse_offset	PARAMS ((char **, int *));

static void fix_new_arm		PARAMS ((fragS *, int, short, expressionS *,
					 int, int));
static int arm_reg_parse	PARAMS ((char **, struct hash_control *));
static enum arm_reg_type arm_reg_parse_any PARAMS ((char *));
static const struct asm_psr * arm_psr_parse PARAMS ((char **));
static void symbol_locate	PARAMS ((symbolS *, const char *, segT, valueT,
					 fragS *));
static int add_to_lit_pool	PARAMS ((void));
static unsigned validate_immediate PARAMS ((unsigned));
static unsigned validate_immediate_twopart PARAMS ((unsigned int,
						    unsigned int *));
static int validate_offset_imm	PARAMS ((unsigned int, int));
static void opcode_select	PARAMS ((int));
static void end_of_line		PARAMS ((char *));
static int reg_required_here	PARAMS ((char **, int));
static int psr_required_here	PARAMS ((char **));
static int co_proc_number	PARAMS ((char **));
static int cp_opc_expr		PARAMS ((char **, int, int));
static int cp_reg_required_here	PARAMS ((char **, int));
static int fp_reg_required_here	PARAMS ((char **, int));
static int vfp_sp_reg_required_here PARAMS ((char **, enum vfp_sp_reg_pos));
static int vfp_dp_reg_required_here PARAMS ((char **, enum vfp_dp_reg_pos));
static void vfp_sp_ldstm	PARAMS ((char *, enum vfp_ldstm_type));
static void vfp_dp_ldstm	PARAMS ((char *, enum vfp_ldstm_type));
static long vfp_sp_reg_list	PARAMS ((char **, enum vfp_sp_reg_pos));
static long vfp_dp_reg_list	PARAMS ((char **));
static int vfp_psr_required_here PARAMS ((char **str));
static const struct vfp_reg *vfp_psr_parse PARAMS ((char **str));
static int cp_address_offset	PARAMS ((char **));
static int cp_address_required_here	PARAMS ((char **, int));
static int my_get_float_expression	PARAMS ((char **));
static int skip_past_comma	PARAMS ((char **));
static int walk_no_bignums	PARAMS ((symbolS *));
static int negate_data_op	PARAMS ((unsigned long *, unsigned long));
static int data_op2		PARAMS ((char **));
static int fp_op2		PARAMS ((char **));
static long reg_list		PARAMS ((char **));
static void thumb_load_store	PARAMS ((char *, int, int));
static int decode_shift		PARAMS ((char **, int));
static int ldst_extend		PARAMS ((char **));
static int ldst_extend_v4		PARAMS ((char **));
static void thumb_add_sub	PARAMS ((char *, int));
static void insert_reg		PARAMS ((const struct reg_entry *,
					 struct hash_control *));
static void thumb_shift		PARAMS ((char *, int));
static void thumb_mov_compare	PARAMS ((char *, int));
static void build_arm_ops_hsh	PARAMS ((void));
static void set_constant_flonums	PARAMS ((void));
static valueT md_chars_to_number	PARAMS ((char *, int));
static void build_reg_hsh	PARAMS ((struct reg_map *));
static void insert_reg_alias	PARAMS ((char *, int, struct hash_control *));
static int create_register_alias	PARAMS ((char *, char *));
static void output_inst		PARAMS ((const char *));
static int accum0_required_here PARAMS ((char **));
static int ld_mode_required_here PARAMS ((char **));
static void do_branch25         PARAMS ((char *));
static symbolS * find_real_start PARAMS ((symbolS *));
#ifdef OBJ_ELF
static bfd_reloc_code_real_type	arm_parse_reloc PARAMS ((void));
#endif

static int wreg_required_here   PARAMS ((char **, int, enum wreg_type));
static void do_iwmmxt_byte_addr PARAMS ((char *));
static void do_iwmmxt_tandc     PARAMS ((char *));
static void do_iwmmxt_tbcst     PARAMS ((char *));
static void do_iwmmxt_textrc    PARAMS ((char *));
static void do_iwmmxt_textrm    PARAMS ((char *));
static void do_iwmmxt_tinsr     PARAMS ((char *));
static void do_iwmmxt_tmcr      PARAMS ((char *));
static void do_iwmmxt_tmcrr     PARAMS ((char *));
static void do_iwmmxt_tmia      PARAMS ((char *));
static void do_iwmmxt_tmovmsk   PARAMS ((char *));
static void do_iwmmxt_tmrc      PARAMS ((char *));
static void do_iwmmxt_tmrrc     PARAMS ((char *));
static void do_iwmmxt_torc      PARAMS ((char *));
static void do_iwmmxt_waligni   PARAMS ((char *));
static void do_iwmmxt_wmov      PARAMS ((char *));
static void do_iwmmxt_word_addr PARAMS ((char *));
static void do_iwmmxt_wrwr      PARAMS ((char *));
static void do_iwmmxt_wrwrwcg   PARAMS ((char *));
static void do_iwmmxt_wrwrwr    PARAMS ((char *));
static void do_iwmmxt_wshufh    PARAMS ((char *));
static void do_iwmmxt_wzero     PARAMS ((char *));
static int cp_byte_address_offset         PARAMS ((char **));
static int cp_byte_address_required_here  PARAMS ((char **));

/* ARM instructions take 4bytes in the object file, Thumb instructions
   take 2:  */
#define INSN_SIZE       4

/* "INSN<cond> X,Y" where X:bit12, Y:bit16.  */
#define MAV_MODE1	0x100c

/* "INSN<cond> X,Y" where X:bit16, Y:bit12.  */
#define MAV_MODE2	0x0c10

/* "INSN<cond> X,Y" where X:bit12, Y:bit16.  */
#define MAV_MODE3	0x100c

/* "INSN<cond> X,Y,Z" where X:16, Y:0, Z:12.  */
#define MAV_MODE4	0x0c0010

/* "INSN<cond> X,Y,Z" where X:12, Y:16, Z:0.  */
#define MAV_MODE5	0x00100c

/* "INSN<cond> W,X,Y,Z" where W:5, X:12, Y:16, Z:0.  */
#define MAV_MODE6	0x00100c05

struct asm_opcode
{
  /* Basic string to match.  */
  const char * template;

  /* Basic instruction code.  */
  unsigned long value;

  /* Offset into the template where the condition code (if any) will be.
     If zero, then the instruction is never conditional.  */
  unsigned cond_offset;

  /* Which architecture variant provides this instruction.  */
  unsigned long variant;

  /* Function to call to parse args.  */
  void (* parms) PARAMS ((char *));
};

static const struct asm_opcode insns[] =
{
  /* Core ARM Instructions.  */
  {"and",        0xe0000000, 3,  ARM_EXT_V1,       do_arit},
  {"ands",       0xe0100000, 3,  ARM_EXT_V1,       do_arit},
  {"eor",        0xe0200000, 3,  ARM_EXT_V1,       do_arit},
  {"eors",       0xe0300000, 3,  ARM_EXT_V1,       do_arit},
  {"sub",        0xe0400000, 3,  ARM_EXT_V1,       do_arit},
  {"subs",       0xe0500000, 3,  ARM_EXT_V1,       do_arit},
  {"rsb",        0xe0600000, 3,  ARM_EXT_V1,       do_arit},
  {"rsbs",       0xe0700000, 3,  ARM_EXT_V1,       do_arit},
  {"add",        0xe0800000, 3,  ARM_EXT_V1,       do_arit},
  {"adds",       0xe0900000, 3,  ARM_EXT_V1,       do_arit},
  {"adc",        0xe0a00000, 3,  ARM_EXT_V1,       do_arit},
  {"adcs",       0xe0b00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbc",        0xe0c00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbcs",       0xe0d00000, 3,  ARM_EXT_V1,       do_arit},
  {"rsc",        0xe0e00000, 3,  ARM_EXT_V1,       do_arit},
  {"rscs",       0xe0f00000, 3,  ARM_EXT_V1,       do_arit},
  {"orr",        0xe1800000, 3,  ARM_EXT_V1,       do_arit},
  {"orrs",       0xe1900000, 3,  ARM_EXT_V1,       do_arit},
  {"bic",        0xe1c00000, 3,  ARM_EXT_V1,       do_arit},
  {"bics",       0xe1d00000, 3,  ARM_EXT_V1,       do_arit},

  {"tst",        0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tsts",       0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tstp",       0xe110f000, 3,  ARM_EXT_V1,       do_cmp},
  {"teq",        0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqs",       0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqp",       0xe130f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmp",        0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmps",       0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmpp",       0xe150f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmn",        0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmns",       0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmnp",       0xe170f000, 3,  ARM_EXT_V1,       do_cmp},

  {"mov",        0xe1a00000, 3,  ARM_EXT_V1,       do_mov},
  {"movs",       0xe1b00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvn",        0xe1e00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvns",       0xe1f00000, 3,  ARM_EXT_V1,       do_mov},

  {"ldr",        0xe4100000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrb",       0xe4500000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrt",       0xe4300000, 3,  ARM_EXT_V1,       do_ldstt},
  {"ldrbt",      0xe4700000, 3,  ARM_EXT_V1,       do_ldstt},
  {"str",        0xe4000000, 3,  ARM_EXT_V1,       do_ldst},
  {"strb",       0xe4400000, 3,  ARM_EXT_V1,       do_ldst},
  {"strt",       0xe4200000, 3,  ARM_EXT_V1,       do_ldstt},
  {"strbt",      0xe4600000, 3,  ARM_EXT_V1,       do_ldstt},

  {"stmia",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmib",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmda",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmdb",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfd",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfa",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmea",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmed",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},

  {"ldmia",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmib",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmda",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmdb",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfd",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfa",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmea",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmed",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},

  {"swi",        0xef000000, 3,  ARM_EXT_V1,       do_swi},
#ifdef TE_WINCE
  /* XXX This is the wrong place to do this.  Think multi-arch.  */
  {"bl",         0xeb000000, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xea000000, 1,  ARM_EXT_V1,       do_branch},
#else
  {"bl",         0xebfffffe, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xeafffffe, 1,  ARM_EXT_V1,       do_branch},
#endif

  /* Pseudo ops.  */
  {"adr",        0xe28f0000, 3,  ARM_EXT_V1,       do_adr},
  {"adrl",       0xe28f0000, 3,  ARM_EXT_V1,       do_adrl},
  {"nop",        0xe1a00000, 3,  ARM_EXT_V1,       do_empty},

  /* ARM 2 multiplies.  */
  {"mul",        0xe0000090, 3,  ARM_EXT_V2,       do_mul},
  {"muls",       0xe0100090, 3,  ARM_EXT_V2,       do_mul},
  {"mla",        0xe0200090, 3,  ARM_EXT_V2,       do_mla},
  {"mlas",       0xe0300090, 3,  ARM_EXT_V2,       do_mla},

  /* Generic coprocessor instructions.  */
  {"cdp",        0xee000000, 3,  ARM_EXT_V2,       do_cdp},
  {"ldc",        0xec100000, 3,  ARM_EXT_V2,       do_lstc},
  {"ldcl",       0xec500000, 3,  ARM_EXT_V2,       do_lstc},
  {"stc",        0xec000000, 3,  ARM_EXT_V2,       do_lstc},
  {"stcl",       0xec400000, 3,  ARM_EXT_V2,       do_lstc},
  {"mcr",        0xee000010, 3,  ARM_EXT_V2,       do_co_reg},
  {"mrc",        0xee100010, 3,  ARM_EXT_V2,       do_co_reg},

  /* ARM 3 - swp instructions.  */
  {"swp",        0xe1000090, 3,  ARM_EXT_V2S,      do_swap},
  {"swpb",       0xe1400090, 3,  ARM_EXT_V2S,      do_swap},

  /* ARM 6 Status register instructions.  */
  {"mrs",        0xe10f0000, 3,  ARM_EXT_V3,       do_mrs},
  {"msr",        0xe120f000, 3,  ARM_EXT_V3,       do_msr},
  /* ScottB: our code uses     0xe128f000 for msr.
     NickC:  but this is wrong because the bits 16 through 19 are
             handled by the PSR_xxx defines above.  */

  /* ARM 7M long multiplies.  */
  {"smull",      0xe0c00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smulls",     0xe0d00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umull",      0xe0800090, 5,  ARM_EXT_V3M,      do_mull},
  {"umulls",     0xe0900090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlal",      0xe0e00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlals",     0xe0f00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlal",      0xe0a00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlals",     0xe0b00090, 5,  ARM_EXT_V3M,      do_mull},

  /* ARM Architecture 4.  */
  {"ldrh",       0xe01000b0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsh",      0xe01000f0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsb",      0xe01000d0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"strh",       0xe00000b0, 3,  ARM_EXT_V4,       do_ldstv4},

  /* ARM Architecture 4T.  */
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.  */
  {"bx",         0xe12fff10, 2,  ARM_EXT_V4T | ARM_EXT_V5, do_bx},

  /*  ARM Architecture 5T.  */
  /* Note: blx has 2 variants, so the .value is set dynamically.
     Only one of the variants has conditional execution.  */
  {"blx",        0xe0000000, 3,  ARM_EXT_V5,       do_blx},
  {"clz",        0xe16f0f10, 3,  ARM_EXT_V5,       do_clz},
  {"bkpt",       0xe1200070, 0,  ARM_EXT_V5,       do_bkpt},
  {"ldc2",       0xfc100000, 0,  ARM_EXT_V5,       do_lstc2},
  {"ldc2l",      0xfc500000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2",       0xfc000000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2l",      0xfc400000, 0,  ARM_EXT_V5,       do_lstc2},
  {"cdp2",       0xfe000000, 0,  ARM_EXT_V5,       do_cdp2},
  {"mcr2",       0xfe000010, 0,  ARM_EXT_V5,       do_co_reg2},
  {"mrc2",       0xfe100010, 0,  ARM_EXT_V5,       do_co_reg2},

  /*  ARM Architecture 5TExP.  */
  {"smlabb",     0xe1000080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatb",     0xe10000a0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlabt",     0xe10000c0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatt",     0xe10000e0, 6,  ARM_EXT_V5ExP,    do_smla},

  {"smlawb",     0xe1200080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlawt",     0xe12000c0, 6,  ARM_EXT_V5ExP,    do_smla},

  {"smlalbb",    0xe1400080, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltb",    0xe14000a0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlalbt",    0xe14000c0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltt",    0xe14000e0, 7,  ARM_EXT_V5ExP,    do_smlal},

  {"smulbb",     0xe1600080, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultb",     0xe16000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulbt",     0xe16000c0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultt",     0xe16000e0, 6,  ARM_EXT_V5ExP,    do_smul},

  {"smulwb",     0xe12000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulwt",     0xe12000e0, 6,  ARM_EXT_V5ExP,    do_smul},

  {"qadd",       0xe1000050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdadd",      0xe1400050, 5,  ARM_EXT_V5ExP,    do_qadd},
  {"qsub",       0xe1200050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdsub",      0xe1600050, 5,  ARM_EXT_V5ExP,    do_qadd},

  /*  ARM Architecture 5TE.  */
  {"pld",        0xf450f000, 0,  ARM_EXT_V5E,      do_pld},
  {"ldrd",       0xe00000d0, 3,  ARM_EXT_V5E,      do_ldrd},
  {"strd",       0xe00000f0, 3,  ARM_EXT_V5E,      do_ldrd},

  {"mcrr",       0xec400000, 4,  ARM_EXT_V5E,      do_co_reg2c},
  {"mrrc",       0xec500000, 4,  ARM_EXT_V5E,      do_co_reg2c},

  /*  ARM Architecture 5TEJ.  */
  {"bxj",	 0xe12fff20, 3,  ARM_EXT_V5J,	   do_bxj},

  /*  ARM V6.  */
  { "cps",       0xf1020000, 0,  ARM_EXT_V6,       do_cps},
  { "cpsie",     0xf1080000, 0,  ARM_EXT_V6,       do_cpsi},
  { "cpsid",     0xf10C0000, 0,  ARM_EXT_V6,       do_cpsi},
  { "ldrex",     0xe1900f9f, 5,  ARM_EXT_V6,       do_ldrex},
  { "mcrr2",     0xfc400000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "mrrc2",     0xfc500000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "pkhbt",     0xe6800010, 5,  ARM_EXT_V6,       do_pkhbt},
  { "pkhtb",     0xe6800050, 5,  ARM_EXT_V6,       do_pkhtb},
  { "qadd16",    0xe6200f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "qadd8",     0xe6200f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "qaddsubx",  0xe6200f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "qsub16",    0xe6200f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "qsub8",     0xe6200ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "qsubaddx",  0xe6200f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "sadd16",    0xe6100f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "sadd8",     0xe6100f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "saddsubx",  0xe6100f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "shadd16",   0xe6300f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "shadd8",    0xe6300f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "shaddsubx", 0xe6300f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "shsub16",   0xe6300f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "shsub8",    0xe6300ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "shsubaddx", 0xe6300f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "ssub16",    0xe6100f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "ssub8",     0xe6100ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "ssubaddx",  0xe6100f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "uadd16",    0xe6500f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "uadd8",     0xe6500f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "uaddsubx",  0xe6500f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "uhadd16",   0xe6700f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhadd8",    0xe6700f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhaddsubx", 0xe6700f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uhsub16",   0xe6700f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhsub8",    0xe6700ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhsubaddx", 0xe6700f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqadd16",   0xe6600f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqadd8",    0xe6600f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqaddsubx", 0xe6600f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqsub16",   0xe6600f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqsub8",    0xe6600ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqsubaddx", 0xe6600f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "usub16",    0xe6500f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "usub8",     0xe6500ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "usubaddx",  0xe6500f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "rev",       0xe6bf0f30, 3,  ARM_EXT_V6,       do_rev},
  { "rev16",     0xe6bf0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "revsh",     0xe6ff0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "rfeia",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeib",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeda",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfedb",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefd",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefa",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeea",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeed",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "sxtah",     0xe6b00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxtab16",   0xe6800070, 7,  ARM_EXT_V6,       do_sxtah},
  { "sxtab",     0xe6a00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxth",      0xe6bf0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sxtb16",    0xe68f0070, 6,  ARM_EXT_V6,       do_sxth},
  { "sxtb",      0xe6af0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtah",     0xe6f00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxtab16",   0xe6c00070, 7,  ARM_EXT_V6,       do_sxtah},
  { "uxtab",     0xe6e00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxth",      0xe6ff0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtb16",    0xe6cf0070, 6,  ARM_EXT_V6,       do_sxth},
  { "uxtb",      0xe6ef0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sel",       0xe68000b0, 3,  ARM_EXT_V6,       do_qadd16},
  { "setend",    0xf1010000, 0,  ARM_EXT_V6,       do_setend},
  { "smlad",     0xe7000010, 5,  ARM_EXT_V6,       do_smlad},
  { "smladx",    0xe7000030, 6,  ARM_EXT_V6,       do_smlad},
  { "smlald",    0xe7400010, 6,  ARM_EXT_V6,       do_smlald},
  { "smlaldx",   0xe7400030, 7,  ARM_EXT_V6,       do_smlald},
  { "smlsd",     0xe7000050, 5,  ARM_EXT_V6,       do_smlad},
  { "smlsdx",    0xe7000070, 6,  ARM_EXT_V6,       do_smlad},
  { "smlsld",    0xe7400050, 6,  ARM_EXT_V6,       do_smlald},
  { "smlsldx",   0xe7400070, 7,  ARM_EXT_V6,       do_smlald},
  { "smmla",     0xe7500010, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlar",    0xe7500030, 6,  ARM_EXT_V6,       do_smlad},
  { "smmls",     0xe75000d0, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlsr",    0xe75000f0, 6,  ARM_EXT_V6,       do_smlad},
  { "smmul",     0xe750f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smmulr",    0xe750f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smuad",     0xe700f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smuadx",    0xe700f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smusd",     0xe700f050, 5,  ARM_EXT_V6,       do_smmul},
  { "smusdx",    0xe700f070, 6,  ARM_EXT_V6,       do_smmul},
  { "srsia",     0xf8cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsib",     0xf9cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsda",     0xf84d0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsdb",     0xf94d0500, 0,  ARM_EXT_V6,       do_srs},
  { "ssat",      0xe6a00010, 4,  ARM_EXT_V6,       do_ssat},
  { "ssat16",    0xe6a00f30, 6,  ARM_EXT_V6,       do_ssat16},
  { "strex",     0xe1800f90, 5,  ARM_EXT_V6,       do_strex},
  { "umaal",     0xe0400090, 5,  ARM_EXT_V6,       do_umaal},
  { "usad8",     0xe780f010, 5,  ARM_EXT_V6,       do_smmul},
  { "usada8",    0xe7800010, 6,  ARM_EXT_V6,       do_smlad},
  { "usat",      0xe6e00010, 4,  ARM_EXT_V6,       do_usat},
  { "usat16",    0xe6e00f30, 6,  ARM_EXT_V6,       do_usat16},

  /* Core FPA instruction set (V1).  */
  {"wfs",        0xee200110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfs",        0xee300110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"wfc",        0xee400110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfc",        0xee500110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},

  {"ldfs",       0xec100100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfd",       0xec108100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfe",       0xec500100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfp",       0xec508100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},

  {"stfs",       0xec000100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfd",       0xec008100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfe",       0xec400100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfp",       0xec408100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},

  {"mvfs",       0xee008100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsp",      0xee008120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsm",      0xee008140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsz",      0xee008160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfd",       0xee008180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdp",      0xee0081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdm",      0xee0081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdz",      0xee0081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfe",       0xee088100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfep",      0xee088120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfem",      0xee088140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfez",      0xee088160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"mnfs",       0xee108100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsp",      0xee108120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsm",      0xee108140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsz",      0xee108160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfd",       0xee108180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdp",      0xee1081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdm",      0xee1081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdz",      0xee1081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfe",       0xee188100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfep",      0xee188120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfem",      0xee188140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfez",      0xee188160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"abss",       0xee208100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssp",      0xee208120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssm",      0xee208140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssz",      0xee208160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absd",       0xee208180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdp",      0xee2081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdm",      0xee2081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdz",      0xee2081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abse",       0xee288100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absep",      0xee288120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absem",      0xee288140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absez",      0xee288160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"rnds",       0xee308100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsp",      0xee308120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsm",      0xee308140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsz",      0xee308160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndd",       0xee308180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddp",      0xee3081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddm",      0xee3081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddz",      0xee3081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnde",       0xee388100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndep",      0xee388120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndem",      0xee388140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndez",      0xee388160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"sqts",       0xee408100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsp",      0xee408120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsm",      0xee408140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsz",      0xee408160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtd",       0xee408180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdp",      0xee4081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdm",      0xee4081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdz",      0xee4081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqte",       0xee488100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtep",      0xee488120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtem",      0xee488140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtez",      0xee488160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"logs",       0xee508100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsp",      0xee508120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsm",      0xee508140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsz",      0xee508160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logd",       0xee508180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdp",      0xee5081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdm",      0xee5081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdz",      0xee5081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"loge",       0xee588100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logep",      0xee588120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logem",      0xee588140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logez",      0xee588160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"lgns",       0xee608100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsp",      0xee608120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsm",      0xee608140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsz",      0xee608160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnd",       0xee608180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndp",      0xee6081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndm",      0xee6081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndz",      0xee6081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgne",       0xee688100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnep",      0xee688120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnem",      0xee688140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnez",      0xee688160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"exps",       0xee708100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsp",      0xee708120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsm",      0xee708140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsz",      0xee708160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expd",       0xee708180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdp",      0xee7081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdm",      0xee7081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee7081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expe",       0xee788100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expep",      0xee788120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expem",      0xee788140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee788160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"sins",       0xee808100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsp",      0xee808120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsm",      0xee808140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsz",      0xee808160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sind",       0xee808180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindp",      0xee8081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindm",      0xee8081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindz",      0xee8081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sine",       0xee888100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinep",      0xee888120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinem",      0xee888140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinez",      0xee888160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"coss",       0xee908100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossp",      0xee908120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossm",      0xee908140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossz",      0xee908160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosd",       0xee908180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdp",      0xee9081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdm",      0xee9081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdz",      0xee9081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cose",       0xee988100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosep",      0xee988120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosem",      0xee988140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosez",      0xee988160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"tans",       0xeea08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansp",      0xeea08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansm",      0xeea08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansz",      0xeea08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tand",       0xeea08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandp",      0xeea081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandm",      0xeea081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandz",      0xeea081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tane",       0xeea88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanep",      0xeea88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanem",      0xeea88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanez",      0xeea88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"asns",       0xeeb08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsp",      0xeeb08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsm",      0xeeb08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsz",      0xeeb08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnd",       0xeeb08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndp",      0xeeb081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndm",      0xeeb081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndz",      0xeeb081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asne",       0xeeb88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnep",      0xeeb88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnem",      0xeeb88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnez",      0xeeb88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"acss",       0xeec08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssp",      0xeec08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssm",      0xeec08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssz",      0xeec08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsd",       0xeec08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdp",      0xeec081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdm",      0xeec081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdz",      0xeec081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acse",       0xeec88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsep",      0xeec88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsem",      0xeec88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsez",      0xeec88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"atns",       0xeed08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsp",      0xeed08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsm",      0xeed08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsz",      0xeed08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnd",       0xeed08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndp",      0xeed081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndm",      0xeed081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndz",      0xeed081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atne",       0xeed88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnep",      0xeed88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnem",      0xeed88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnez",      0xeed88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"urds",       0xeee08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsp",      0xeee08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsm",      0xeee08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsz",      0xeee08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdd",       0xeee08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddp",      0xeee081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddm",      0xeee081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddz",      0xeee081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urde",       0xeee88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdep",      0xeee88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdem",      0xeee88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdez",      0xeee88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"nrms",       0xeef08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsp",      0xeef08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsm",      0xeef08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsz",      0xeef08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmd",       0xeef08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdp",      0xeef081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdm",      0xeef081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdz",      0xeef081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrme",       0xeef88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmep",      0xeef88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmem",      0xeef88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmez",      0xeef88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"adfs",       0xee000100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsp",      0xee000120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsm",      0xee000140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsz",      0xee000160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfd",       0xee000180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdp",      0xee0001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdm",      0xee0001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdz",      0xee0001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfe",       0xee080100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfep",      0xee080120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfem",      0xee080140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfez",      0xee080160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"sufs",       0xee200100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsp",      0xee200120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsm",      0xee200140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsz",      0xee200160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufd",       0xee200180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdp",      0xee2001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdm",      0xee2001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdz",      0xee2001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufe",       0xee280100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufep",      0xee280120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufem",      0xee280140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufez",      0xee280160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rsfs",       0xee300100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsp",      0xee300120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsm",      0xee300140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsz",      0xee300160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfd",       0xee300180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdp",      0xee3001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdm",      0xee3001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdz",      0xee3001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfe",       0xee380100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfep",      0xee380120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfem",      0xee380140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfez",      0xee380160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"mufs",       0xee100100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsp",      0xee100120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsm",      0xee100140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsz",      0xee100160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufd",       0xee100180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdp",      0xee1001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdm",      0xee1001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdz",      0xee1001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufe",       0xee180100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufep",      0xee180120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufem",      0xee180140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufez",      0xee180160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"dvfs",       0xee400100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsp",      0xee400120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsm",      0xee400140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsz",      0xee400160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfd",       0xee400180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdp",      0xee4001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdm",      0xee4001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdz",      0xee4001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfe",       0xee480100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfep",      0xee480120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfem",      0xee480140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfez",      0xee480160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rdfs",       0xee500100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsp",      0xee500120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsm",      0xee500140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsz",      0xee500160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfd",       0xee500180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdp",      0xee5001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdm",      0xee5001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdz",      0xee5001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfe",       0xee580100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfep",      0xee580120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfem",      0xee580140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfez",      0xee580160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"pows",       0xee600100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsp",      0xee600120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsm",      0xee600140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsz",      0xee600160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powd",       0xee600180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdp",      0xee6001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdm",      0xee6001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdz",      0xee6001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powe",       0xee680100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powep",      0xee680120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powem",      0xee680140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powez",      0xee680160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rpws",       0xee700100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsp",      0xee700120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsm",      0xee700140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsz",      0xee700160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwd",       0xee700180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdp",      0xee7001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdm",      0xee7001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdz",      0xee7001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwe",       0xee780100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwep",      0xee780120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwem",      0xee780140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwez",      0xee780160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rmfs",       0xee800100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsp",      0xee800120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsm",      0xee800140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsz",      0xee800160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfd",       0xee800180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdp",      0xee8001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdm",      0xee8001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdz",      0xee8001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfe",       0xee880100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfep",      0xee880120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfem",      0xee880140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfez",      0xee880160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"fmls",       0xee900100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsp",      0xee900120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsm",      0xee900140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsz",      0xee900160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmld",       0xee900180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldp",      0xee9001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldm",      0xee9001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldz",      0xee9001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmle",       0xee980100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlep",      0xee980120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlem",      0xee980140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlez",      0xee980160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"fdvs",       0xeea00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsp",      0xeea00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsm",      0xeea00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsz",      0xeea00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvd",       0xeea00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdp",      0xeea001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdm",      0xeea001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdz",      0xeea001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdve",       0xeea80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvep",      0xeea80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvem",      0xeea80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvez",      0xeea80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"frds",       0xeeb00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsp",      0xeeb00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsm",      0xeeb00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsz",      0xeeb00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdd",       0xeeb00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddp",      0xeeb001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddm",      0xeeb001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddz",      0xeeb001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frde",       0xeeb80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdep",      0xeeb80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdem",      0xeeb80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdez",      0xeeb80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"pols",       0xeec00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsp",      0xeec00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsm",      0xeec00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsz",      0xeec00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pold",       0xeec00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldp",      0xeec001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldm",      0xeec001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldz",      0xeec001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pole",       0xeec80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polep",      0xeec80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polem",      0xeec80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polez",      0xeec80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"cmf",        0xee90f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cmfe",       0xeed0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnf",        0xeeb0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  /* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should
     not be an optional suffix, but part of the instruction.  To be
     compatible, we accept either.  */
  {"cmfe",       0xeed0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},

  {"flts",       0xee000110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsp",      0xee000130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsm",      0xee000150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsz",      0xee000170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltd",       0xee000190, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdp",      0xee0001b0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdm",      0xee0001d0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdz",      0xee0001f0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"flte",       0xee080110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltep",      0xee080130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltem",      0xee080150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltez",      0xee080170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},

  /* The implementation of the FIX instruction is broken on some
     assemblers, in that it accepts a precision specifier as well as a
     rounding specifier, despite the fact that this is meaningless.
     To be more compatible, we accept it as well, though of course it
     does not set any bits.  */
  {"fix",        0xee100110, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixp",       0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixm",       0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixz",       0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixep",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixem",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixez",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},

  /* Instructions that were new with the real FPA, call them V2.  */
  {"lfm",        0xec100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmfd",      0xec900200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmea",      0xed100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfm",        0xec000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmfd",      0xed000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmea",      0xec800200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},

  /* VFP V1xD (single precision).  */
  /* Moves and type conversions.  */
  {"fcpys",   0xeeb00a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrs",    0xee100a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_sp},
  {"fmsr",    0xee000a10, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_from_reg},
  {"fmstat",  0xeef1fa10, 6, FPU_VFP_EXT_V1xD, do_empty},
  {"fsitos",  0xeeb80ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fuitos",  0xeeb80a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosis",  0xeebd0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosizs", 0xeebd0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouis",  0xeebc0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouizs", 0xeebc0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrx",    0xeef00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_ctrl},
  {"fmxr",    0xeee00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_ctrl_from_reg},

  /* Memory operations.  */
  {"flds",    0xed100a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fsts",    0xed000a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fldmias", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmfds", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmdbs", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmeas", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmiax", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmfdx", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmdbx", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fldmeax", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmias", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmeas", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmdbs", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmfds", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmiax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmeax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmdbx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmfdx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},

  /* Monadic operations.  */
  {"fabss",   0xeeb00ac0, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fnegs",   0xeeb10a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fsqrts",  0xeeb10ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},

  /* Dyadic operations.  */
  {"fadds",   0xee300a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fsubs",   0xee300a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmuls",   0xee200a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fdivs",   0xee800a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmacs",   0xee000a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmscs",   0xee100a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmuls",  0xee200a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmacs",  0xee000a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmscs",  0xee100a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},

  /* Comparisons.  */
  {"fcmps",   0xeeb40a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpzs",  0xeeb50a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},
  {"fcmpes",  0xeeb40ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpezs", 0xeeb50ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},

  /* VFP V1 (Double precision).  */
  /* Moves and type conversions.  */
  {"fcpyd",   0xeeb00b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcvtds",  0xeeb70ac0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fcvtsd",  0xeeb70bc0, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"fmdhr",   0xee200b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmdlr",   0xee000b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmrdh",   0xee300b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fmrdl",   0xee100b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fsitod",  0xeeb80bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fuitod",  0xeeb80b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"ftosid",  0xeebd0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftosizd", 0xeebd0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouid",  0xeebc0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouizd", 0xeebc0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},

  /* Memory operations.  */
  {"fldd",    0xed100b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fstd",    0xed000b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fldmiad", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmfdd", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmdbd", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fldmead", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmiad", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmead", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmdbd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmfdd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},

  /* Monadic operations.  */
  {"fabsd",   0xeeb00bc0, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fnegd",   0xeeb10b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fsqrtd",  0xeeb10bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},

  /* Dyadic operations.  */
  {"faddd",   0xee300b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fsubd",   0xee300b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmuld",   0xee200b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fdivd",   0xee800b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmacd",   0xee000b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmscd",   0xee100b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmuld",  0xee200b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmacd",  0xee000b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmscd",  0xee100b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},

  /* Comparisons.  */
  {"fcmpd",   0xeeb40b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpzd",  0xeeb50b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},
  {"fcmped",  0xeeb40bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpezd", 0xeeb50bc0, 7, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},

  /* VFP V2.  */
  {"fmsrr",   0xec400a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp2_from_reg2},
  {"fmrrs",   0xec500a10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_sp2},
  {"fmdrr",   0xec400b10, 5, FPU_VFP_EXT_V2,   do_vfp_dp_from_reg2},
  {"fmrrd",   0xec500b10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_dp},

  /* Intel XScale extensions to ARM V5 ISA.  (All use CP0).  */
  {"mia",        0xee200010, 3,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miaph",      0xee280010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabb",      0xee2c0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabt",      0xee2d0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatb",      0xee2e0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatt",      0xee2f0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"mar",        0xec400000, 3,  ARM_CEXT_XSCALE,   do_xsc_mar},
  {"mra",        0xec500000, 3,  ARM_CEXT_XSCALE,   do_xsc_mra},

  /* Intel Wireless MMX technology instructions.  */
  {"tandcb",     0xee130130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandch",     0xee530130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandcw",     0xee930130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tbcstb",     0xee400010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcsth",     0xee400050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcstw",     0xee400090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"textrcb",    0xee130170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrch",    0xee530170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrcw",    0xee930170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrmub",   0xee100070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuh",   0xee500070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuw",   0xee900070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsb",   0xee100078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsh",   0xee500078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsw",   0xee900078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"tinsrb",     0xee600010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrh",     0xee600050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrw",     0xee600090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tmcr",       0xee000110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmcr},
  {"tmcrr",      0xec400000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmcrr},
  {"tmia",       0xee200010, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiaph",     0xee280010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabb",     0xee2c0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabt",     0xee2d0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatb",     0xee2e0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatt",     0xee2f0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmovmskb",   0xee100030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskh",   0xee500030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskw",   0xee900030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmrc",       0xee100110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmrc},
  {"tmrrc",      0xec500000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmrrc},
  {"torcb",      0xee130150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torch",      0xee530150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torcw",      0xee930150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"waccb",      0xee0001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wacch",      0xee4001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waccw",      0xee8001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waddbss",    0xee300180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddb",      0xee000180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddbus",    0xee100180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhss",    0xee700180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddh",      0xee400180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhus",    0xee500180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwss",    0xeeb00180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddw",      0xee800180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwus",    0xee900180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waligni",    0xee000020, 7, ARM_CEXT_IWMMXT, do_iwmmxt_waligni},
  {"walignr0",   0xee800020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr1",   0xee900020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr2",   0xeea00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr3",   0xeeb00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wand",       0xee200000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wandn",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2b",     0xee800000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2br",    0xee900000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2h",     0xeec00000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2hr",    0xeed00000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqb",    0xee000060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqh",    0xee400060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqw",    0xee800060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtub",   0xee100060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuh",   0xee500060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuw",   0xee900060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsb",   0xee300060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsh",   0xee700060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsw",   0xeeb00060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wldrb",      0xec100000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrh",      0xec100100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrw",      0xec100200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wldrd",      0xec100300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wmacs",      0xee600100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacsz",     0xee700100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacu",      0xee400100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacuz",     0xee500100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmadds",     0xeea00100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaddu",     0xee800100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsb",     0xee200160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsh",     0xee600160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsw",     0xeea00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxub",     0xee000160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuh",     0xee400160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuw",     0xee800160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsb",     0xee300160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsh",     0xee700160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsw",     0xeeb00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminub",     0xee100160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuh",     0xee500160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuw",     0xee900160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmov",       0xee000000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wmov},
  {"wmulsm",     0xee300100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulsl",     0xee200100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulum",     0xee100100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulul",     0xee000100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wor",        0xee000000, 3, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhss",   0xee700080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhus",   0xee500080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwss",   0xeeb00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwus",   0xee900080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdss",   0xeef00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdus",   0xeed00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorh",      0xee700040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorhg",     0xee700148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrorw",      0xeeb00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorwg",     0xeeb00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrord",      0xeef00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrordg",     0xeef00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsadb",      0xee000120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadbz",     0xee100120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadh",      0xee400120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadhz",     0xee500120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wshufh",     0xee0001e0, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wshufh},
  {"wsllh",      0xee500040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllhg",     0xee500148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsllw",      0xee900040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllwg",     0xee900148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wslld",      0xeed00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wslldg",     0xeed00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrah",      0xee400040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrahg",     0xee400148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsraw",      0xee800040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrawg",     0xee800148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrad",      0xeec00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsradg",     0xeec00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlh",      0xee600040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlhg",     0xee600148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlw",      0xeea00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlwg",     0xeea00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrld",      0xeee00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrldg",     0xeee00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wstrb",      0xec000000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrh",      0xec000100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrw",      0xec000200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wstrd",      0xec000300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wsubbss",    0xee3001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubb",      0xee0001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubbus",    0xee1001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhss",    0xee7001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubh",      0xee4001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhus",    0xee5001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwss",    0xeeb001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubw",      0xee8001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwus",    0xee9001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckehub", 0xee0000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuh", 0xee4000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuw", 0xee8000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsb", 0xee2000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsh", 0xee6000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsw", 0xeea000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckihb",  0xee1000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihh",  0xee5000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihw",  0xee9000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckelub", 0xee0000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluh", 0xee4000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluw", 0xee8000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsb", 0xee2000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsh", 0xee6000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsw", 0xeea000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckilb",  0xee1000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilh",  0xee5000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilw",  0xee9000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wxor",       0xee100000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wzero",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wzero},

  /* Cirrus Maverick instructions.  */
  {"cfldrs",     0xec100400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfldrd",     0xec500400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfldr32",    0xec100500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfldr64",    0xec500500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfstrs",     0xec000400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfstrd",     0xec400400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfstr32",    0xec000500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfstr64",    0xec400500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfmvsr",     0xee000450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_2a},
  {"cfmvrs",     0xee100450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1a},
  {"cfmvdlr",    0xee000410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdl",    0xee100410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmvdhr",    0xee000430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdh",    0xee100430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmv64lr",   0xee000510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64l",   0xee100510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmv64hr",   0xee000530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64h",   0xee100530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmval32",   0xee200440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32al",   0xee100440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvam32",   0xee200460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32am",   0xee100460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvah32",   0xee200480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32ah",   0xee100480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva32",    0xee2004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32a",    0xee1004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva64",    0xee2004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3c},
  {"cfmv64a",    0xee1004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3d},
  {"cfmvsc32",   0xee2004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_1},
  {"cfmv32sc",   0xee1004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_2},
  {"cfcpys",     0xee000400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfcpyd",     0xee000420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfcvtsd",    0xee000460, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1f},
  {"cfcvtds",    0xee000440, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1g},
  {"cfcvt32s",   0xee000480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1h},
  {"cfcvt32d",   0xee0004a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1i},
  {"cfcvt64s",   0xee0004c0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1j},
  {"cfcvt64d",   0xee0004e0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1k},
  {"cfcvts32",   0xee100580, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cfcvtd32",   0xee1005a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cftruncs32", 0xee1005c0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cftruncd32", 0xee1005e0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cfrshl32",   0xee000550, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4a},
  {"cfrshl64",   0xee000570, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4b},
  {"cfsh32",     0xee000500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_1},
  {"cfsh64",     0xee200500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_2},
  {"cfcmps",     0xee100490, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5a},
  {"cfcmpd",     0xee1004b0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5b},
  {"cfcmp32",    0xee100590, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5c},
  {"cfcmp64",    0xee1005b0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5d},
  {"cfabss",     0xee300400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfabsd",     0xee300420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfnegs",     0xee300440, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfnegd",     0xee300460, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfadds",     0xee300480, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfaddd",     0xee3004a0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfsubs",     0xee3004c0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfsubd",     0xee3004e0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfmuls",     0xee100400, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfmuld",     0xee100420, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfabs32",    0xee300500, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfabs64",    0xee300520, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfneg32",    0xee300540, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfneg64",    0xee300560, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfadd32",    0xee300580, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfadd64",    0xee3005a0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfsub32",    0xee3005c0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfsub64",    0xee3005e0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmul32",    0xee100500, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmul64",    0xee100520, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmac32",    0xee100540, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmsc32",    0xee100560, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmadd32",   0xee000600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmsub32",   0xee100600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmadda32",  0xee200600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
  {"cfmsuba32",  0xee300600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
};

/* Defines for various bits that we will want to toggle.  */
#define INST_IMMEDIATE	0x02000000
#define OFFSET_REG	0x02000000
#define HWOFFSET_IMM    0x00400000
#define SHIFT_BY_REG	0x00000010
#define PRE_INDEX	0x01000000
#define INDEX_UP	0x00800000
#define WRITE_BACK	0x00200000
#define LDM_TYPE_2_OR_3	0x00400000

#define LITERAL_MASK	0xf000f000
#define OPCODE_MASK	0xfe1fffff
#define V4_STR_BIT	0x00000020

#define DATA_OP_SHIFT	21

/* Codes to distinguish the arithmetic instructions.  */
#define OPCODE_AND	0
#define OPCODE_EOR	1
#define OPCODE_SUB	2
#define OPCODE_RSB	3
#define OPCODE_ADD	4
#define OPCODE_ADC	5
#define OPCODE_SBC	6
#define OPCODE_RSC	7
#define OPCODE_TST	8
#define OPCODE_TEQ	9
#define OPCODE_CMP	10
#define OPCODE_CMN	11
#define OPCODE_ORR	12
#define OPCODE_MOV	13
#define OPCODE_BIC	14
#define OPCODE_MVN	15

/* Thumb v1 (ARMv4T).  */
static void do_t_nop		PARAMS ((char *));
static void do_t_arit		PARAMS ((char *));
static void do_t_add		PARAMS ((char *));
static void do_t_asr		PARAMS ((char *));
static void do_t_branch9	PARAMS ((char *));
static void do_t_branch12	PARAMS ((char *));
static void do_t_branch23	PARAMS ((char *));
static void do_t_bx		PARAMS ((char *));
static void do_t_compare	PARAMS ((char *));
static void do_t_ldmstm		PARAMS ((char *));
static void do_t_ldr		PARAMS ((char *));
static void do_t_ldrb		PARAMS ((char *));
static void do_t_ldrh		PARAMS ((char *));
static void do_t_lds		PARAMS ((char *));
static void do_t_lsl		PARAMS ((char *));
static void do_t_lsr		PARAMS ((char *));
static void do_t_mov		PARAMS ((char *));
static void do_t_push_pop	PARAMS ((char *));
static void do_t_str		PARAMS ((char *));
static void do_t_strb		PARAMS ((char *));
static void do_t_strh		PARAMS ((char *));
static void do_t_sub		PARAMS ((char *));
static void do_t_swi		PARAMS ((char *));
static void do_t_adr		PARAMS ((char *));

/* Thumb v2 (ARMv5T).  */
static void do_t_blx		PARAMS ((char *));
static void do_t_bkpt		PARAMS ((char *));

/* ARM V6.  */
static void do_t_cps            PARAMS ((char *));
static void do_t_cpy            PARAMS ((char *));
static void do_t_setend         PARAMS ((char *));;

#define T_OPCODE_MUL 0x4340
#define T_OPCODE_TST 0x4200
#define T_OPCODE_CMN 0x42c0
#define T_OPCODE_NEG 0x4240
#define T_OPCODE_MVN 0x43c0

#define T_OPCODE_ADD_R3	0x1800
#define T_OPCODE_SUB_R3 0x1a00
#define T_OPCODE_ADD_HI 0x4400
#define T_OPCODE_ADD_ST 0xb000
#define T_OPCODE_SUB_ST 0xb080
#define T_OPCODE_ADD_SP 0xa800
#define T_OPCODE_ADD_PC 0xa000
#define T_OPCODE_ADD_I8 0x3000
#define T_OPCODE_SUB_I8 0x3800
#define T_OPCODE_ADD_I3 0x1c00
#define T_OPCODE_SUB_I3 0x1e00

#define T_OPCODE_ASR_R	0x4100
#define T_OPCODE_LSL_R	0x4080
#define T_OPCODE_LSR_R  0x40c0
#define T_OPCODE_ASR_I	0x1000
#define T_OPCODE_LSL_I	0x0000
#define T_OPCODE_LSR_I	0x0800

#define T_OPCODE_MOV_I8	0x2000
#define T_OPCODE_CMP_I8 0x2800
#define T_OPCODE_CMP_LR 0x4280
#define T_OPCODE_MOV_HR 0x4600
#define T_OPCODE_CMP_HR 0x4500

#define T_OPCODE_LDR_PC 0x4800
#define T_OPCODE_LDR_SP 0x9800
#define T_OPCODE_STR_SP 0x9000
#define T_OPCODE_LDR_IW 0x6800
#define T_OPCODE_STR_IW 0x6000
#define T_OPCODE_LDR_IH 0x8800
#define T_OPCODE_STR_IH 0x8000
#define T_OPCODE_LDR_IB 0x7800
#define T_OPCODE_STR_IB 0x7000
#define T_OPCODE_LDR_RW 0x5800
#define T_OPCODE_STR_RW 0x5000
#define T_OPCODE_LDR_RH 0x5a00
#define T_OPCODE_STR_RH 0x5200
#define T_OPCODE_LDR_RB 0x5c00
#define T_OPCODE_STR_RB 0x5400

#define T_OPCODE_PUSH	0xb400
#define T_OPCODE_POP	0xbc00

#define T_OPCODE_BRANCH 0xe7fe

static int thumb_reg		PARAMS ((char ** str, int hi_lo));

#define THUMB_SIZE	2	/* Size of thumb instruction.  */
#define THUMB_REG_LO	0x1
#define THUMB_REG_HI	0x2
#define THUMB_REG_ANY	0x3

#define THUMB_H1	0x0080
#define THUMB_H2	0x0040

#define THUMB_ASR 0
#define THUMB_LSL 1
#define THUMB_LSR 2

#define THUMB_MOVE 0
#define THUMB_COMPARE 1
#define THUMB_CPY 2

#define THUMB_LOAD 0
#define THUMB_STORE 1

#define THUMB_PP_PC_LR 0x0100

/* These three are used for immediate shifts, do not alter.  */
#define THUMB_WORD 2
#define THUMB_HALFWORD 1
#define THUMB_BYTE 0

struct thumb_opcode
{
  /* Basic string to match.  */
  const char * template;

  /* Basic instruction code.  */
  unsigned long value;

  int size;

  /* Which CPU variants this exists for.  */
  unsigned long variant;

  /* Function to call to parse args.  */
  void (* parms) PARAMS ((char *));
};

static const struct thumb_opcode tinsns[] =
{
  /* Thumb v1 (ARMv4T).  */
  {"adc",	0x4140,		2,	ARM_EXT_V4T, do_t_arit},
  {"add",	0x0000,		2,	ARM_EXT_V4T, do_t_add},
  {"and",	0x4000,		2,	ARM_EXT_V4T, do_t_arit},
  {"asr",	0x0000,		2,	ARM_EXT_V4T, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_EXT_V4T, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_EXT_V4T, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_EXT_V4T, do_t_branch23},
  {"bx",	0x4700,		2,	ARM_EXT_V4T, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_EXT_V4T, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_EXT_V4T, do_t_compare},
  {"eor",	0x4040,		2,	ARM_EXT_V4T, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_EXT_V4T, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_EXT_V4T, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_EXT_V4T, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_EXT_V4T, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_EXT_V4T, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_EXT_V4T, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_EXT_V4T, do_t_arit},
  {"orr",	0x4300,		2,	ARM_EXT_V4T, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_EXT_V4T, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_EXT_V4T, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_EXT_V4T, do_t_str},
  {"strb",	0x0000,		2,	ARM_EXT_V4T, do_t_strb},
  {"strh",	0x0000,		2,	ARM_EXT_V4T, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_EXT_V4T, do_t_swi},
  {"sub",	0x0000,		2,	ARM_EXT_V4T, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_EXT_V4T, do_t_arit},
  /* Pseudo ops:  */
  {"adr",       0x0000,         2,      ARM_EXT_V4T, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_EXT_V4T, do_t_nop},      /* mov r8,r8  */
  /* Thumb v2 (ARMv5T).  */
  {"blx",	0,		0,	ARM_EXT_V5T, do_t_blx},
  {"bkpt",	0xbe00,		2,	ARM_EXT_V5T, do_t_bkpt},

  /* ARM V6.  */
  {"cpsie",	0xb660,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpsid",     0xb670,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpy",	0x4600,		2,	ARM_EXT_V6,  do_t_cpy},
  {"rev",	0xba00,		2,	ARM_EXT_V6,  do_t_arit},
  {"rev16",	0xba40,		2,	ARM_EXT_V6,  do_t_arit},
  {"revsh",	0xbac0,		2,	ARM_EXT_V6,  do_t_arit},
  {"setend",	0xb650,		2,	ARM_EXT_V6,  do_t_setend},
  {"sxth",	0xb200,		2,	ARM_EXT_V6,  do_t_arit},
  {"sxtb",	0xb240,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxth",	0xb280,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxtb",	0xb2c0,		2,	ARM_EXT_V6,  do_t_arit},
};

#define BAD_ARGS 	_("bad arguments to instruction")
#define BAD_PC 		_("r15 not allowed here")
#define BAD_COND 	_("instruction is not conditional")
#define ERR_NO_ACCUM	_("acc0 expected")

static struct hash_control * arm_ops_hsh   = NULL;
static struct hash_control * arm_tops_hsh  = NULL;
static struct hash_control * arm_cond_hsh  = NULL;
static struct hash_control * arm_shift_hsh = NULL;
static struct hash_control * arm_psr_hsh   = NULL;

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     pseudo-op name without dot
     function to call to execute this pseudo-op
     Integer arg to pass to the function.  */

static void s_req PARAMS ((int));
static void s_unreq PARAMS ((int));
static void s_align PARAMS ((int));
static void s_bss PARAMS ((int));
static void s_even PARAMS ((int));
static void s_ltorg PARAMS ((int));
static void s_arm PARAMS ((int));
static void s_thumb PARAMS ((int));
static void s_code PARAMS ((int));
static void s_force_thumb PARAMS ((int));
static void s_thumb_func PARAMS ((int));
static void s_thumb_set PARAMS ((int));
#ifdef OBJ_ELF
static void s_arm_elf_cons PARAMS ((int));
#endif

static int my_get_expression PARAMS ((expressionS *, char **));

const pseudo_typeS md_pseudo_table[] =
{
  /* Never called because '.req' does not start a line.  */
  { "req",         s_req,         0 },
  { "unreq",       s_unreq,       0 },
  { "bss",         s_bss,         0 },
  { "align",       s_align,       0 },
  { "arm",         s_arm,         0 },
  { "thumb",       s_thumb,       0 },
  { "code",        s_code,        0 },
  { "force_thumb", s_force_thumb, 0 },
  { "thumb_func",  s_thumb_func,  0 },
  { "thumb_set",   s_thumb_set,   0 },
  { "even",        s_even,        0 },
  { "ltorg",       s_ltorg,       0 },
  { "pool",        s_ltorg,       0 },
#ifdef OBJ_ELF
  { "word",        s_arm_elf_cons, 4 },
  { "long",        s_arm_elf_cons, 4 },
#else
  { "word",        cons, 4},
#endif
  { "extend",      float_cons, 'x' },
  { "ldouble",     float_cons, 'x' },
  { "packed",      float_cons, 'p' },
  { 0, 0, 0 }
};

/* Other internal functions.  */
static int arm_parse_extension PARAMS ((char *, int *));
static int arm_parse_cpu PARAMS ((char *));
static int arm_parse_arch PARAMS ((char *));
static int arm_parse_fpu PARAMS ((char *));
static int arm_parse_float_abi PARAMS ((char *));
#if 0 /* Suppressed - for now.  */
#if defined OBJ_COFF || defined OBJ_ELF
static void arm_add_note PARAMS ((const char *, const char *, unsigned int));
#endif
#endif

/* Stuff needed to resolve the label ambiguity
   As:
     ...
     label:   <insn>
   may differ from:
     ...
     label:
              <insn>
*/

symbolS *  last_label_seen;
static int label_is_thumb_function_name = FALSE;

/* Literal Pool stuff.  */

#define MAX_LITERAL_POOL_SIZE 1024

/* Literal pool structure.  Held on a per-section
   and per-sub-section basis.  */
typedef struct literal_pool
{
  expressionS    literals [MAX_LITERAL_POOL_SIZE];
  unsigned int   next_free_entry;
  unsigned int   id;
  symbolS *      symbol;
  segT           section;
  subsegT        sub_section;
  struct literal_pool * next;
} literal_pool;

/* Pointer to a linked list of literal pools.  */
literal_pool * list_of_pools = NULL;

static literal_pool * find_literal_pool PARAMS ((void));
static literal_pool * find_or_make_literal_pool PARAMS ((void));

static literal_pool *
find_literal_pool ()
{
  literal_pool * pool;

  for (pool = list_of_pools; pool != NULL; pool = pool->next)
    {
      if (pool->section == now_seg
	  && pool->sub_section == now_subseg)
	break;
    }

  return pool;
}

static literal_pool *
find_or_make_literal_pool ()
{
  /* Next literal pool ID number.  */
  static unsigned int latest_pool_num = 1;
  literal_pool *      pool;

  pool = find_literal_pool ();

  if (pool == NULL)
    {
      /* Create a new pool.  */
      pool = (literal_pool *) xmalloc (sizeof (* pool));
      if (! pool)
	return NULL;

      pool->next_free_entry = 0;
      pool->section         = now_seg;
      pool->sub_section     = now_subseg;
      pool->next            = list_of_pools;
      pool->symbol          = NULL;

      /* Add it to the list.  */
      list_of_pools = pool;
    }

  /* New pools, and emptied pools, will have a NULL symbol.  */
  if (pool->symbol == NULL)
    {
      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
				    (valueT) 0, &zero_address_frag);
      pool->id = latest_pool_num ++;
    }

  /* Done.  */
  return pool;
}

/* Add the literal in the global 'inst'
   structure to the relevent literal pool.  */
static int
add_to_lit_pool ()
{
  literal_pool * pool;
  unsigned int entry;

  pool = find_or_make_literal_pool ();

  /* Check if this literal value is already in the pool.  */
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    {
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_constant)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_unsigned
	      == inst.reloc.exp.X_unsigned))
	break;

      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
          && (inst.reloc.exp.X_op == O_symbol)
          && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
          && (pool->literals[entry].X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
          && (pool->literals[entry].X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
        break;
    }

  /* Do we need to create a new entry?  */
  if (entry == pool->next_free_entry)
    {
      if (entry >= MAX_LITERAL_POOL_SIZE)
	{
	  inst.error = _("literal pool overflow");
	  return FAIL;
	}

      pool->literals[entry] = inst.reloc.exp;
      pool->next_free_entry += 1;
    }

  inst.reloc.exp.X_op         = O_symbol;
  inst.reloc.exp.X_add_number = ((int) entry) * 4 - 8;
  inst.reloc.exp.X_add_symbol = pool->symbol;

  return SUCCESS;
}

/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */

static void
symbol_locate (symbolP, name, segment, valu, frag)
     symbolS *    symbolP;
     const char * name;		/* It is copied, the caller can modify.  */
     segT         segment;	/* Segment identifier (SEG_<something>).  */
     valueT       valu;		/* Symbol value.  */
     fragS *      frag;		/* Associated fragment.  */
{
  unsigned int name_length;
  char * preserved_copy_of_name;

  name_length = strlen (name) + 1;   /* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  preserved_copy_of_name = obstack_finish (&notes);
#ifdef STRIP_UNDERSCORE
  if (preserved_copy_of_name[0] == '_')
    preserved_copy_of_name++;
#endif

#ifdef tc_canonicalize_symbol_name
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
#endif

  S_SET_NAME (symbolP, preserved_copy_of_name);

  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);

  symbol_set_frag (symbolP, frag);

  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;
    if (symbol_table_frozen)
      abort ();
  }

  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);

  obj_symbol_new_hook (symbolP);

#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif

#ifdef DEBUG_SYMS
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif /* DEBUG_SYMS  */
}

/* Check that an immediate is valid.
   If so, convert it to the right format.  */

static unsigned int
validate_immediate (val)
     unsigned int val;
{
  unsigned int a;
  unsigned int i;

#define rotate_left(v, n) (v << n | v >> (32 - n))

  for (i = 0; i < 32; i += 2)
    if ((a = rotate_left (val, i)) <= 0xff)
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */

  return FAIL;
}

/* Check to see if an immediate can be computed as two separate immediate
   values, added together.  We already know that this value cannot be
   computed by just one ARM instruction.  */

static unsigned int
validate_immediate_twopart (val, highpart)
     unsigned int   val;
     unsigned int * highpart;
{
  unsigned int a;
  unsigned int i;

  for (i = 0; i < 32; i += 2)
    if (((a = rotate_left (val, i)) & 0xff) != 0)
      {
	if (a & 0xff00)
	  {
	    if (a & ~ 0xffff)
	      continue;
	    * highpart = (a  >> 8) | ((i + 24) << 7);
	  }
	else if (a & 0xff0000)
	  {
	    if (a & 0xff000000)
	      continue;
	    * highpart = (a >> 16) | ((i + 16) << 7);
	  }
	else
	  {
	    assert (a & 0xff000000);
	    * highpart = (a >> 24) | ((i + 8) << 7);
	  }

	return (a & 0xff) | (i << 7);
      }

  return FAIL;
}

static int
validate_offset_imm (val, hwse)
     unsigned int val;
     int hwse;
{
  if ((hwse && val > 255) || val > 4095)
    return FAIL;
  return val;
}


#ifdef OBJ_ELF
/* This code is to handle mapping symbols as defined in the ARM ELF spec.
   (This text is taken from version B-02 of the spec):

      4.4.7 Mapping and tagging symbols

      A section of an ARM ELF file can contain a mixture of ARM code,
      Thumb code, and data.  There are inline transitions between code
      and data at literal pool boundaries. There can also be inline
      transitions between ARM code and Thumb code, for example in
      ARM-Thumb inter-working veneers.  Linkers, machine-level
      debuggers, profiling tools, and disassembly tools need to map
      images accurately. For example, setting an ARM breakpoint on a
      Thumb location, or in a literal pool, can crash the program
      being debugged, ruining the debugging session.

      ARM ELF entities are mapped (see section 4.4.7.1 below) and
      tagged (see section 4.4.7.2 below) using local symbols (with
      binding STB_LOCAL).  To assist consumers, mapping and tagging
      symbols should be collated first in the symbol table, before
      other symbols with binding STB_LOCAL.

      To allow properly collated mapping and tagging symbols to be
      skipped by consumers that have no interest in them, the first
      such symbol should have the name $m and its st_value field equal
      to the total number of mapping and tagging symbols (including
      the $m) in the symbol table.

      4.4.7.1 Mapping symbols

      $a    Labels the first byte of a sequence of ARM instructions.
            Its type is STT_FUNC.

      $d    Labels the first byte of a sequence of data items.
            Its type is STT_OBJECT.

      $t    Labels the first byte of a sequence of Thumb instructions.
            Its type is STT_FUNC.

      This list of mapping symbols may be extended in the future.

      Section-relative mapping symbols

      Mapping symbols defined in a section define a sequence of
      half-open address intervals that cover the address range of the
      section. Each interval starts at the address defined by a
      mapping symbol, and continues up to, but not including, the
      address defined by the next (in address order) mapping symbol or
      the end of the section. A corollary is that there must be a
      mapping symbol defined at the beginning of each section.
      Consumers can ignore the size of a section-relative mapping
      symbol. Producers can set it to 0.

      Absolute mapping symbols

      Because of the need to crystallize a Thumb address with the
      Thumb-bit set, absolute symbol of type STT_FUNC (symbols of type
      STT_FUNC defined in section SHN_ABS) need to be mapped with $a
      or $t.

      The extent of a mapping symbol defined in SHN_ABS is [st_value,
      st_value + st_size), or [st_value, st_value + 1) if st_size = 0,
      where [x, y) denotes the half-open address range from x,
      inclusive, to y, exclusive.

      In the absence of a mapping symbol, a consumer can interpret a
      function symbol with an odd value as the Thumb code address
      obtained by clearing the least significant bit of the
      value. This interpretation is deprecated, and it may not work in
      the future.

   Note - the Tagging symbols ($b, $f, $p $m) have been dropped from
   the EABI (which is still under development), so they are not
   implemented here.  */

static enum mstate mapstate = MAP_UNDEFINED;

static void
mapping_state (enum mstate state)
{
  symbolS * symbolP;
  const char * symname;
  int type;

  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;

  mapstate = state;

  switch (state)
    {
    case MAP_DATA:
      symname = "$d";
      type = BSF_OBJECT;
      break;
    case MAP_ARM:
      symname = "$a";
      type = BSF_FUNCTION;
      break;
    case MAP_THUMB:
      symname = "$t";
      type = BSF_FUNCTION;
      break;
    case MAP_UNDEFINED:
      return;     
    default:
      abort ();
    }

  seg_info (now_seg)->tc_segment_info_data = state;

  symbolP = symbol_new (symname, now_seg, (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (symbolP);
  symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;
  
  switch (state)
    {
    case MAP_ARM:
      THUMB_SET_FUNC (symbolP, 0);
      ARM_SET_THUMB (symbolP, 0);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
      
    case MAP_THUMB:
      THUMB_SET_FUNC (symbolP, 1);
      ARM_SET_THUMB (symbolP, 1);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
      
    case MAP_DATA:
    default:
      return;
    }
}

/* When we change sections we need to issue a new mapping symbol.  */

void
arm_elf_change_section (void)
{
  flagword flags;

  if (!SEG_NORMAL (now_seg))
    return;

  flags = bfd_get_section_flags (stdoutput, now_seg);

  /* We can ignore sections that only contain debug info.  */
  if ((flags & SEC_ALLOC) == 0)
    return;

  mapstate = seg_info (now_seg)->tc_segment_info_data;
}
#else
#define mapping_state(a)
#endif /* OBJ_ELF */


static void
s_req (a)
     int a ATTRIBUTE_UNUSED;
{
  as_bad (_("invalid syntax for .req directive"));
}

/* The .unreq directive deletes an alias which was previously defined
   by .req.  For example:

       my_alias .req r11
       .unreq my_alias    */

static void
s_unreq (int a ATTRIBUTE_UNUSED)
{
  char *name;
  char saved_char;

  skip_whitespace (input_line_pointer);
  name = input_line_pointer;

  while (*input_line_pointer != 0
	 && *input_line_pointer != ' '
	 && *input_line_pointer != '\n')
    ++input_line_pointer;

  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  if (*name)
    {
      enum arm_reg_type req_type = arm_reg_parse_any (name);

      if (req_type != REG_TYPE_MAX)
	{
	  char *temp_name = name;
	  int req_no = arm_reg_parse (&temp_name, all_reg_maps[req_type].htab);

	  if (req_no != FAIL)
	    {
	      struct reg_entry *req_entry;

	      /* Check to see if this alias is a builtin one.  */
	      req_entry = hash_delete (all_reg_maps[req_type].htab, name);

	      if (!req_entry)
		as_bad (_("unreq: missing hash entry for \"%s\""), name);
	      else if (req_entry->builtin)
		/* FIXME: We are deleting a built in register alias which
		   points to a const data structure, so we only need to
		   free up the memory used by the key in the hash table.
		   Unfortunately we have not recorded this value, so this
		   is a memory leak.  */
		  /* FIXME: Should we issue a warning message ?  */
		;
	      else
		{
		  /* Deleting a user defined alias.  We need to free the
		     key and the value, but fortunately the key is the same
		     as the value->name field.  */
		  free ((char *) req_entry->name);
		  free (req_entry);
		}
	    }
          else
            as_bad (_(".unreq: unrecognized symbol \"%s\""), name);
	}
      else
        as_bad (_(".unreq: unrecognized symbol \"%s\""), name);
    }
  else
    as_bad (_("invalid syntax for .unreq directive"));

  *input_line_pointer = saved_char;
  demand_empty_rest_of_line ();
}

static void
s_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* We don't support putting frags in the BSS segment, we fake it by
     marking in_bss, then looking at s_skip for clues.  */
  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();
  mapping_state (MAP_DATA);
}

static void
s_even (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* Never make frag if expect extra pass.  */
  if (!need_pass_2)
    frag_align (1, 0, 0);

  record_alignment (now_seg, 1);

  demand_empty_rest_of_line ();
}

static void
s_ltorg (ignored)
     int ignored ATTRIBUTE_UNUSED;
{
  unsigned int entry;
  literal_pool * pool;
  char sym_name[20];

  pool = find_literal_pool ();
  if (pool == NULL
      || pool->symbol == NULL
      || pool->next_free_entry == 0)
    return;

  mapping_state (MAP_DATA);

  /* Align pool as you have word accesses.
     Only make a frag if we have to.  */
  if (!need_pass_2)
    frag_align (2, 0, 0);

  record_alignment (now_seg, 2);

  sprintf (sym_name, "$$lit_\002%x", pool->id);

  symbol_locate (pool->symbol, sym_name, now_seg,
		 (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (pool->symbol);

  ARM_SET_THUMB (pool->symbol, thumb_mode);

#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (pool->symbol, support_interwork);
#endif

  for (entry = 0; entry < pool->next_free_entry; entry ++)
    /* First output the expression in the instruction to the pool.  */
    emit_expr (&(pool->literals[entry]), 4); /* .word  */

  /* Mark the pool as empty.  */
  pool->next_free_entry = 0;
  pool->symbol = NULL;
}

/* Same as s_align_ptwo but align 0 => align 2.  */

static void
s_align (unused)
     int unused ATTRIBUTE_UNUSED;
{
  register int temp;
  register long temp_fill;
  long max_alignment = 15;

  temp = get_absolute_expression ();
  if (temp > max_alignment)
    as_bad (_("alignment too large: %d assumed"), temp = max_alignment);
  else if (temp < 0)
    {
      as_bad (_("alignment negative. 0 assumed."));
      temp = 0;
    }

  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
    }
  else
    temp_fill = 0;

  if (!temp)
    temp = 2;

  /* Only make a frag if we HAVE to.  */
  if (temp && !need_pass_2)
    frag_align (temp, (int) temp_fill, 0);
  demand_empty_rest_of_line ();

  record_alignment (now_seg, temp);
}

static void
s_force_thumb (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* If we are not already in thumb mode go into it, EVEN if
     the target processor does not support thumb instructions.
     This is used by gcc/config/arm/lib1funcs.asm for example
     to compile interworking support functions even if the
     target processor should not support interworking.  */
  if (! thumb_mode)
    {
      thumb_mode = 2;

      record_alignment (now_seg, 1);
    }

  demand_empty_rest_of_line ();
}

static void
s_thumb_func (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (! thumb_mode)
    opcode_select (16);

  /* The following label is the name/address of the start of a Thumb function.
     We need to know this for the interworking support.  */
  label_is_thumb_function_name = TRUE;

  demand_empty_rest_of_line ();
}

/* Perform a .set directive, but also mark the alias as
   being a thumb function.  */

static void
s_thumb_set (equiv)
     int equiv;
{
  /* XXX the following is a duplicate of the code for s_set() in read.c
     We cannot just call that code as we need to get at the symbol that
     is created.  */
  register char *    name;
  register char      delim;
  register char *    end_name;
  register symbolS * symbolP;

  /* Especial apologies for the random logic:
     This just grew, and could be parsed much more simply!
     Dean - in haste.  */
  name      = input_line_pointer;
  delim     = get_symbol_end ();
  end_name  = input_line_pointer;
  *end_name = delim;

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      *end_name = 0;
      as_bad (_("expected comma after name \"%s\""), name);
      *end_name = delim;
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;
  *end_name = 0;

  if (name[0] == '.' && name[1] == '\0')
    {
      /* XXX - this should not happen to .thumb_set.  */
      abort ();
    }

  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
         for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct * listing_tail;
	  fragS * dummy_frag = (fragS *) xmalloc (sizeof (fragS));

	  memset (dummy_frag, 0, sizeof (fragS));
	  dummy_frag->fr_type = rs_fill;
	  dummy_frag->line = listing_tail;
	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
	  dummy_frag->fr_symbol = symbolP;
	}
      else
#endif
	symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);

#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF  */
    }				/* Make a new symbol.  */

  symbol_table_insert (symbolP);

  * end_name = delim;

  if (equiv
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));

  pseudo_set (symbolP);

  demand_empty_rest_of_line ();

  /* XXX Now we come to the Thumb specific bit of code.  */

  THUMB_SET_FUNC (symbolP, 1);
  ARM_SET_THUMB (symbolP, 1);
#if defined OBJ_ELF || defined OBJ_COFF
  ARM_SET_INTERWORK (symbolP, support_interwork);
#endif
}

static void
opcode_select (width)
     int width;
{
  switch (width)
    {
    case 16:
      if (! thumb_mode)
	{
	  if (! (cpu_variant & ARM_EXT_V4T))
	    as_bad (_("selected processor does not support THUMB opcodes"));

	  thumb_mode = 1;
	  /* No need to force the alignment, since we will have been
             coming from ARM mode, which is word-aligned.  */
	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_THUMB);
      break;

    case 32:
      if (thumb_mode)
	{
	  if ((cpu_variant & ARM_ALL) == ARM_EXT_V4T)
	    as_bad (_("selected processor does not support ARM opcodes"));

	  thumb_mode = 0;

	  if (!need_pass_2)
	    frag_align (2, 0, 0);

	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_ARM);
      break;

    default:
      as_bad (_("invalid instruction size selected (%d)"), width);
    }
}

static void
s_arm (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  opcode_select (32);
  demand_empty_rest_of_line ();
}

static void
s_thumb (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  opcode_select (16);
  demand_empty_rest_of_line ();
}

static void
s_code (unused)
     int unused ATTRIBUTE_UNUSED;
{
  register int temp;

  temp = get_absolute_expression ();
  switch (temp)
    {
    case 16:
    case 32:
      opcode_select (temp);
      break;

    default:
      as_bad (_("invalid operand to .code directive (%d) (expecting 16 or 32)"), temp);
    }
}

static void
end_of_line (str)
     char *str;
{
  skip_whitespace (str);

  if (*str != '\0' && !inst.error)
    inst.error = _("garbage following instruction");
}

static int
skip_past_comma (str)
     char ** str;
{
  char * p = * str, c;
  int comma = 0;

  while ((c = *p) == ' ' || c == ',')
    {
      p++;
      if (c == ',' && comma++)
	return FAIL;
    }

  if (c == '\0')
    return FAIL;

  *str = p;
  return comma ? SUCCESS : FAIL;
}

/* A standard register must be given at this point.
   SHIFT is the place to put it in inst.instruction.
   Restores input start point on error.
   Returns the reg#, or FAIL.  */

static int
reg_required_here (str, shift)
     char ** str;
     int     shift;
{
  static char buff [128]; /* XXX  */
  int         reg;
  char *      start = * str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_RN].htab)) != FAIL)
    {
      if (shift >= 0)
	inst.instruction |= reg << shift;
      return reg;
    }

  /* Restore the start point, we may have got a reg of the wrong class.  */
  *str = start;

  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  sprintf (buff, _("register expected, not '%.100s'"), start);
  inst.error = buff;

  return FAIL;
}

/* A Intel Wireless MMX technology register
   must be given at this point.
   Shift is the place to put it in inst.instruction.
   Restores input start point on err.
   Returns the reg#, or FAIL.  */

static int
wreg_required_here (str, shift, reg_type)
     char ** str;
     int     shift;
     enum wreg_type reg_type;
{
  static char buff [128];
  int    reg;
  char * start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_IWMMXT].htab)) != FAIL)
    {
      if (wr_register (reg)
	  && (reg_type == IWMMXT_REG_WR || reg_type == IWMMXT_REG_WR_OR_WC))
        {
          if (shift >= 0)
            inst.instruction |= (reg ^ WR_PREFIX) << shift;
          return reg;
        }
      else if (wc_register (reg)
	       && (reg_type == IWMMXT_REG_WC || reg_type == IWMMXT_REG_WR_OR_WC))
        {
          if (shift >= 0)
            inst.instruction |= (reg ^ WC_PREFIX) << shift;
          return reg;
        }
      else if ((wcg_register (reg) && reg_type == IWMMXT_REG_WCG))
        {
          if (shift >= 0)
            inst.instruction |= ((reg ^ WC_PREFIX) - 8) << shift;
          return reg;
        }
    }

  /* Restore the start point, we may have got a reg of the wrong class.  */
  *str = start;

  /* In the few cases where we might be able to accept
     something else this error can be overridden.  */
  sprintf (buff, _("Intel Wireless MMX technology register expected, not '%.100s'"), start);
  inst.error = buff;

  return FAIL;
}

static const struct asm_psr *
arm_psr_parse (ccp)
     register char ** ccp;
{
  char * start = * ccp;
  char   c;
  char * p;
  const struct asm_psr * psr;

  p = start;

  /* Skip to the end of the next word in the input stream.  */
  do
    {
      c = *p++;
    }
  while (ISALPHA (c) || c == '_');

  /* Terminate the word.  */
  *--p = 0;

  /* CPSR's and SPSR's can now be lowercase.  This is just a convenience
     feature for ease of use and backwards compatibility.  */
  if (!strncmp (start, "cpsr", 4))
    strncpy (start, "CPSR", 4);
  else if (!strncmp (start, "spsr", 4))
    strncpy (start, "SPSR", 4);

  /* Now locate the word in the psr hash table.  */
  psr = (const struct asm_psr *) hash_find (arm_psr_hsh, start);

  /* Restore the input stream.  */
  *p = c;

  /* If we found a valid match, advance the
     stream pointer past the end of the word.  */
  *ccp = p;

  return psr;
}

/* Parse the input looking for a PSR flag.  */

static int
psr_required_here (str)
     char ** str;
{
  char * start = * str;
  const struct asm_psr * psr;

  psr = arm_psr_parse (str);

  if (psr)
    {
      /* If this is the SPSR that is being modified, set the R bit.  */
      if (! psr->cpsr)
	inst.instruction |= SPSR_BIT;

      /* Set the psr flags in the MSR instruction.  */
      inst.instruction |= psr->field << PSR_SHIFT;

      return SUCCESS;
    }

  /* In the few cases where we might be able to accept
     something else this error can be overridden.  */
  inst.error = _("flag for {c}psr instruction expected");

  /* Restore the start point.  */
  *str = start;
  return FAIL;
}

static int
co_proc_number (str)
     char **str;
{
  int processor, pchar;
  char *start;

  skip_whitespace (*str);
  start = *str;

  /* The data sheet seems to imply that just a number on its own is valid
     here, but the RISC iX assembler seems to accept a prefix 'p'.  We will
     accept either.  */
  if ((processor = arm_reg_parse (str, all_reg_maps[REG_TYPE_CP].htab))
      == FAIL)
    {
      *str = start;

      pchar = *(*str)++;
      if (pchar >= '0' && pchar <= '9')
	{
	  processor = pchar - '0';
	  if (**str >= '0' && **str <= '9')
	    {
	      processor = processor * 10 + *(*str)++ - '0';
	      if (processor > 15)
		{
		  inst.error = _("illegal co-processor number");
		  return FAIL;
		}
	    }
	}
      else
	{
	  inst.error = _("bad or missing co-processor number");
	  return FAIL;
	}
    }

  inst.instruction |= processor << 8;
  return SUCCESS;
}

static int
cp_opc_expr (str, where, length)
     char ** str;
     int where;
     int length;
{
  expressionS expr;

  skip_whitespace (* str);

  memset (&expr, '\0', sizeof (expr));

  if (my_get_expression (&expr, str))
    return FAIL;
  if (expr.X_op != O_constant)
    {
      inst.error = _("bad or missing expression");
      return FAIL;
    }

  if ((expr.X_add_number & ((1 << length) - 1)) != expr.X_add_number)
    {
      inst.error = _("immediate co-processor expression too large");
      return FAIL;
    }

  inst.instruction |= expr.X_add_number << where;
  return SUCCESS;
}

static int
cp_reg_required_here (str, where)
     char ** str;
     int     where;
{
  int    reg;
  char * start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_CN].htab)) != FAIL)
    {
      inst.instruction |= reg << where;
      return reg;
    }

  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _("co-processor register expected");

  /* Restore the start point.  */
  *str = start;
  return FAIL;
}

static int
fp_reg_required_here (str, where)
     char ** str;
     int     where;
{
  int    reg;
  char * start = * str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_FN].htab)) != FAIL)
    {
      inst.instruction |= reg << where;
      return reg;
    }

  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _("floating point register expected");

  /* Restore the start point.  */
  *str = start;
  return FAIL;
}

static int
cp_address_offset (str)
     char ** str;
{
  int offset;

  skip_whitespace (* str);

  if (! is_immediate_prefix (**str))
    {
      inst.error = _("immediate expression expected");
      return FAIL;
    }

  (*str)++;

  if (my_get_expression (& inst.reloc.exp, str))
    return FAIL;

  if (inst.reloc.exp.X_op == O_constant)
    {
      offset = inst.reloc.exp.X_add_number;

      if (offset & 3)
	{
	  inst.error = _("co-processor address must be word aligned");
	  return FAIL;
	}

      if (offset > 1023 || offset < -1023)
	{
	  inst.error = _("offset too large");
	  return FAIL;
	}

      if (offset >= 0)
	inst.instruction |= INDEX_UP;
      else
	offset = -offset;

      inst.instruction |= offset >> 2;
    }
  else
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;

  return SUCCESS;
}

static int
cp_address_required_here (str, wb_ok)
     char ** str;
     int wb_ok;
{
  char * p = * str;
  int    pre_inc = 0;
  int    write_back = 0;

  if (*p == '[')
    {
      int reg;

      p++;
      skip_whitespace (p);

      if ((reg = reg_required_here (& p, 16)) == FAIL)
	return FAIL;

      skip_whitespace (p);

      if (*p == ']')
	{
	  p++;

	  skip_whitespace (p);

	  if (*p == '\0')
	    {
	      /* As an extension to the official ARM syntax we allow:
		 
		   [Rn]
		   
	         as a short hand for:

		   [Rn,#0]  */
	      inst.instruction |= PRE_INDEX | INDEX_UP;
	      *str = p;
	      return SUCCESS;
	    }
	  
	  if (skip_past_comma (& p) == FAIL)
	    {
	      inst.error = _("comma expected after closing square bracket");
	      return FAIL;
	    }

	  skip_whitespace (p);

	  if (*p == '#')
	    {
	      if (wb_ok)
		{
		  /* [Rn], #expr  */
		  write_back = WRITE_BACK;

		  if (reg == REG_PC)
		    {
		      inst.error = _("pc may not be used in post-increment");
		      return FAIL;
		    }

		  if (cp_address_offset (& p) == FAIL)
		    return FAIL;
		}
	      else
		pre_inc = PRE_INDEX | INDEX_UP;
	    }
	  else if (*p == '{')
	    {
	      int option;

	      /* [Rn], {<expr>}  */
	      p++;

	      skip_whitespace (p);

	      if (my_get_expression (& inst.reloc.exp, & p))
		return FAIL;

	      if (inst.reloc.exp.X_op == O_constant)
		{
		  option = inst.reloc.exp.X_add_number;

		  if (option > 255 || option < 0)
		    {
		      inst.error = _("'option' field too large");
		      return FAIL;
		    }

		  skip_whitespace (p);

		  if (*p != '}')
		    {
		      inst.error = _("'}' expected at end of 'option' field");
		      return FAIL;
		    }
		  else
		    {
		      p++;
		      inst.instruction |= option;
		      inst.instruction |= INDEX_UP;
		    }
		}
	      else
		{
		  inst.error = _("non-constant expressions for 'option' field not supported");
		  return FAIL;
		}
	    }
	  else
	    {
	      inst.error = _("# or { expected after comma");
	      return FAIL;	      
	    }
	}
      else
	{
	  /* '['Rn, #expr']'[!]  */

	  if (skip_past_comma (& p) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return FAIL;
	    }

	  pre_inc = PRE_INDEX;

	  if (cp_address_offset (& p) == FAIL)
	    return FAIL;

	  skip_whitespace (p);

	  if (*p++ != ']')
	    {
	      inst.error = _("missing ]");
	      return FAIL;
	    }

	  skip_whitespace (p);

	  if (wb_ok && *p == '!')
	    {
	      if (reg == REG_PC)
		{
		  inst.error = _("pc may not be used with write-back");
		  return FAIL;
		}

	      p++;
	      write_back = WRITE_BACK;
	    }
	}
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &p))
	return FAIL;

      inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust.  */
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = PRE_INDEX;
    }

  inst.instruction |= write_back | pre_inc;
  *str = p;
  return SUCCESS;
}

static int
cp_byte_address_offset (str)
     char ** str;
{
  int offset;

  skip_whitespace (* str);

  if (! is_immediate_prefix (**str))
    {
      inst.error = _("immediate expression expected");
      return FAIL;
    }

  (*str)++;
  
  if (my_get_expression (& inst.reloc.exp, str))
    return FAIL;
  
  if (inst.reloc.exp.X_op == O_constant)
    {
      offset = inst.reloc.exp.X_add_number;
      
      if (offset > 255 || offset < -255)
        {
          inst.error = _("offset too large");
          return FAIL;
        }

      if (offset >= 0)
        inst.instruction |= INDEX_UP;
      else
        offset = -offset;

      inst.instruction |= offset;
    }
  else
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM_S2;

  return SUCCESS;
}

static int
cp_byte_address_required_here (str)
     char ** str;
{
  char * p = * str;
  int    pre_inc = 0;
  int    write_back = 0;

  if (*p == '[')
    {
      int reg;

      p++;
      skip_whitespace (p);

      if ((reg = reg_required_here (& p, 16)) == FAIL)
        return FAIL;

      skip_whitespace (p);

      if (*p == ']')
        {
          p++;
          
          if (skip_past_comma (& p) == SUCCESS)
            {
              /* [Rn], #expr */
              write_back = WRITE_BACK;
              
              if (reg == REG_PC)
                {
                  inst.error = _("pc may not be used in post-increment");
                  return FAIL;
                }

              if (cp_byte_address_offset (& p) == FAIL)
                return FAIL;
            }
          else
            pre_inc = PRE_INDEX | INDEX_UP;
        }
      else
        {
          /* '['Rn, #expr']'[!] */

          if (skip_past_comma (& p) == FAIL)
            {
              inst.error = _("pre-indexed expression expected");
              return FAIL;
            }

          pre_inc = PRE_INDEX;
          
          if (cp_byte_address_offset (& p) == FAIL)
            return FAIL;

          skip_whitespace (p);

          if (*p++ != ']')
            {
              inst.error = _("missing ]");
              return FAIL;
            }

          skip_whitespace (p);

          if (*p == '!')
            {
              if (reg == REG_PC)
                {
                  inst.error = _("pc may not be used with write-back");
                  return FAIL;
                }

              p++;
              write_back = WRITE_BACK;
            }
        }
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &p))
        return FAIL;

      inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM_S2;
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust.  */
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = PRE_INDEX;
    }

  inst.instruction |= write_back | pre_inc;
  *str = p;
  return SUCCESS;
}

static void
do_empty (str)
     char * str;
{
  /* Do nothing really.  */
  end_of_line (str);
}

static void
do_mrs (str)
     char *str;
{
  int skip = 0;

  /* Only one syntax.  */
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = _("comma expected after register name");
      return;
    }

  skip_whitespace (str);

  if (   strcmp (str, "CPSR") == 0
      || strcmp (str, "SPSR") == 0
	 /* Lower case versions for backwards compatibility.  */
      || strcmp (str, "cpsr") == 0
      || strcmp (str, "spsr") == 0)
    skip = 4;

  /* This is for backwards compatibility with older toolchains.  */
  else if (   strcmp (str, "cpsr_all") == 0
	   || strcmp (str, "spsr_all") == 0)
    skip = 8;
  else
    {
      inst.error = _("CPSR or SPSR expected");
      return;
    }

  if (* str == 's' || * str == 'S')
    inst.instruction |= SPSR_BIT;
  str += skip;

  end_of_line (str);
}

/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */

static void
do_msr (str)
     char * str;
{
  skip_whitespace (str);

  if (psr_required_here (& str) == FAIL)
    return;

  if (skip_past_comma (& str) == FAIL)
    {
      inst.error = _("comma missing after psr flags");
      return;
    }

  skip_whitespace (str);

  if (reg_required_here (& str, 0) != FAIL)
    {
      inst.error = NULL;
      end_of_line (str);
      return;
    }

  if (! is_immediate_prefix (* str))
    {
      inst.error =
	_("only a register or immediate value can follow a psr flag");
      return;
    }

  str ++;
  inst.error = NULL;

  if (my_get_expression (& inst.reloc.exp, & str))
    {
      inst.error =
	_("only a register or immediate value can follow a psr flag");
      return;
    }

#if 0  /* The first edition of the ARM architecture manual stated that
	  writing anything other than the flags with an immediate operation
	  had UNPREDICTABLE effects.  This constraint was removed in the
	  second edition of the specification.  */
  if ((cpu_variant & ARM_EXT_V5) != ARM_EXT_V5
      && inst.instruction & ((PSR_c | PSR_x | PSR_s) << PSR_SHIFT))
    {
      inst.error = _("immediate value cannot be used to set this field");
      return;
    }
#endif

  inst.instruction |= INST_IMMEDIATE;

  if (inst.reloc.exp.X_add_symbol)
    {
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
    }
  else
    {
      unsigned value = validate_immediate (inst.reloc.exp.X_add_number);

      if (value == (unsigned) FAIL)
	{
	  inst.error = _("invalid constant");
	  return;
	}

      inst.instruction |= value;
    }

  inst.error = NULL;
  end_of_line (str);
}

/* Long Multiply Parser
   UMULL RdLo, RdHi, Rm, Rs
   SMULL RdLo, RdHi, Rm, Rs
   UMLAL RdLo, RdHi, Rm, Rs
   SMLAL RdLo, RdHi, Rm, Rs.  */

static void
do_mull (str)
     char * str;
{
  int rdlo, rdhi, rm, rs;

  /* Only one format "rdlo, rdhi, rm, rs".  */
  skip_whitespace (str);

  if ((rdlo = reg_required_here (&str, 12)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || (rdhi = reg_required_here (&str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* rdhi, rdlo and rm must all be different.  */
  if (rdlo == rdhi || rdlo == rm || rdhi == rm)
    as_tsktsk (_("rdhi, rdlo and rm must all be different"));

  if (skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rdhi == REG_PC || rdhi == REG_PC || rdhi == REG_PC || rdhi == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
}

static void
do_mul (str)
     char * str;
{
  int rd, rm;

  /* Only one format "rd, rm, rs".  */
  skip_whitespace (str);

  if ((rd = reg_required_here (&str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  if (rm == rd)
    as_tsktsk (_("rd and rm should be different in mul"));

  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
}

static void
do_mla (str)
     char * str;
{
  int rd, rm;

  /* Only one format "rd, rm, rs, rn".  */
  skip_whitespace (str);

  if ((rd = reg_required_here (&str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  if (rm == rd)
    as_tsktsk (_("rd and rm should be different in mla"));

  if (skip_past_comma (&str) == FAIL
      || (rd = reg_required_here (&str, 8)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 12)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rd == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
}

/* Expects *str -> the characters "acc0", possibly with leading blanks.
   Advances *str to the next non-alphanumeric.
   Returns 0, or else FAIL (in which case sets inst.error).

  (In a future XScale, there may be accumulators other than zero.
  At that time this routine and its callers can be upgraded to suit.)  */

static int
accum0_required_here (str)
     char ** str;
{
  static char buff [128];	/* Note the address is taken.  Hence, static.  */
  char * p = * str;
  char   c;
  int result = 0;		/* The accum number.  */

  skip_whitespace (p);

  *str = p;			/* Advance caller's string pointer too.  */
  c = *p++;
  while (ISALNUM (c))
    c = *p++;

  *--p = 0;			/* Aap nul into input buffer at non-alnum.  */

  if (! ( streq (*str, "acc0") || streq (*str, "ACC0")))
    {
      sprintf (buff, _("acc0 expected, not '%.100s'"), *str);
      inst.error = buff;
      result = FAIL;
    }

  *p = c;			/* Unzap.  */
  *str = p;			/* Caller's string pointer to after match.  */
  return result;
}

/* Expects **str -> after a comma. May be leading blanks.
   Advances *str, recognizing a load  mode, and setting inst.instruction.
   Returns rn, or else FAIL (in which case may set inst.error
   and not advance str)

   Note: doesn't know Rd, so no err checks that require such knowledge.  */

static int
ld_mode_required_here (string)
     char ** string;
{
  char * str = * string;
  int    rn;
  int    pre_inc = 0;

  skip_whitespace (str);

  if (* str == '[')
    {
      str++;

      skip_whitespace (str);

      if ((rn = reg_required_here (& str, 16)) == FAIL)
	return FAIL;

      skip_whitespace (str);

      if (* str == ']')
	{
	  str ++;

	  if (skip_past_comma (& str) == SUCCESS)
	    {
	      /* [Rn],... (post inc) */
	      if (ldst_extend_v4 (&str) == FAIL)
		return FAIL;
	    }
	  else 	      /* [Rn] */
	    {
	      skip_whitespace (str);

	      if (* str == '!')
		{
		  str ++;
		  inst.instruction |= WRITE_BACK;
		}

	      inst.instruction |= INDEX_UP | HWOFFSET_IMM;
	      pre_inc = 1;
	    }
	}
      else	  /* [Rn,...] */
	{
	  if (skip_past_comma (& str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return FAIL;
	    }

	  pre_inc = 1;

	  if (ldst_extend_v4 (&str) == FAIL)
	    return FAIL;

	  skip_whitespace (str);

	  if (* str ++ != ']')
	    {
	      inst.error = _("missing ]");
	      return FAIL;
	    }

	  skip_whitespace (str);

	  if (* str == '!')
	    {
	      str ++;
	      inst.instruction |= WRITE_BACK;
	    }
	}
    }
  else if (* str == '=')	/* ldr's "r,=label" syntax */
    /* We should never reach here, because <text> = <expression> is
       caught gas/read.c read_a_source_file() as a .set operation.  */
    return FAIL;
  else				/* PC +- 8 bit immediate offset.  */
    {
      if (my_get_expression (& inst.reloc.exp, & str))
	return FAIL;

      inst.instruction            |= HWOFFSET_IMM;	/* The I bit.  */
      inst.reloc.type              = BFD_RELOC_ARM_OFFSET_IMM8;
      inst.reloc.exp.X_add_number -= 8;  		/* PC rel adjust.  */
      inst.reloc.pc_rel            = 1;
      inst.instruction            |= (REG_PC << 16);

      rn = REG_PC;
      pre_inc = 1;
    }

  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  * string = str;

  return rn;
}

/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)
   SMLAxy{cond} Rd,Rm,Rs,Rn
   SMLAWy{cond} Rd,Rm,Rs,Rn
   Error if any register is R15.  */

static void
do_smla (str)
     char *        str;
{
  int rd, rm, rs, rn;

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC || rs == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)
   SMLALxy{cond} Rdlo,Rdhi,Rm,Rs
   Error if any register is R15.
   Warning if Rdlo == Rdhi.  */

static void
do_smlal (str)
     char *        str;
{
  int rdlo, rdhi, rm, rs;

  skip_whitespace (str);

  if ((rdlo = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rdhi = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rdlo == REG_PC || rdhi == REG_PC || rm == REG_PC || rs == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  if (rdlo == rdhi)
    as_tsktsk (_("rdhi and rdlo must be different"));

  end_of_line (str);
}

/* ARM V5E (El Segundo) signed-multiply (argument parse)
   SMULxy{cond} Rd,Rm,Rs
   Error if any register is R15.  */

static void
do_smul (str)
     char *        str;
{
  int rd, rm, rs;

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V5E (El Segundo) saturating-add/subtract (argument parse)
   Q[D]{ADD,SUB}{cond} Rd,Rm,Rn
   Error if any register is R15.  */

static void
do_qadd (str)
     char *        str;
{
  int rd, rm, rn;

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V5E (el Segundo)
   MCRRcc <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
   MRRCcc <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.

   These are equivalent to the XScale instructions MAR and MRA,
   respectively, when coproc == 0, opcode == 0, and CRm == 0.

   Result unpredicatable if Rd or Rn is R15.  */

static void
do_co_reg2c (str)
     char *        str;
{
  int rd, rn;

  skip_whitespace (str);

  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 4, 4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || (rd = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 16)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* Unpredictable result if rd or rn is R15.  */
  if (rd == REG_PC || rn == REG_PC)
    as_tsktsk
      (_("Warning: instruction unpredictable when using r15"));

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

/* ARM V5 count-leading-zeroes instruction (argument parse)
     CLZ{<cond>} <Rd>, <Rm>
     Condition defaults to COND_ALWAYS.
     Error if Rd or Rm are R15.  */

static void
do_clz (str)
     char *        str;
{
  int rd, rm;

  skip_whitespace (str);

  if (((rd = reg_required_here (& str, 12)) == FAIL)
      || (skip_past_comma (& str) == FAIL)
      || ((rm = reg_required_here (& str, 0)) == FAIL))
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC )
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V5 (argument parse)
     LDC2{L} <coproc>, <CRd>, <addressing mode>
     STC2{L} <coproc>, <CRd>, <addressing mode>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as LDC/STC.  */

static void
do_lstc2 (str)
     char *        str;
{
  skip_whitespace (str);

  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else if (skip_past_comma (& str) == FAIL
	   || cp_reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else if (skip_past_comma (& str) == FAIL
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}

/* ARM V5 (argument parse)
     CDP2 <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as CDP.  */

static void
do_cdp2 (str)
     char *        str;
{
  skip_whitespace (str);

  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 20,4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  end_of_line (str);
}

/* ARM V5 (argument parse)
     MCR2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     MRC2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as MCR/MRC.  */

static void
do_co_reg2 (str)
     char *        str;
{
  skip_whitespace (str);

  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 21, 3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  end_of_line (str);
}

/* ARM v5TEJ.  Jump to Jazelle code.  */
static void
do_bxj (str)
     char * str;
{
  int reg;

  skip_whitespace (str);

  if ((reg = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Note - it is not illegal to do a "bxj pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  end_of_line (str);
}

/* ARM V6 umaal (argument parse). */

static void
do_umaal (str)
     char *str;
{

  int rdlo, rdhi, rm, rs;

  skip_whitespace (str);
  if ((rdlo = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rdhi = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;      
    }

  if (rdlo == REG_PC || rdhi == REG_PC || rm == REG_PC || rs == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
}

/* ARM V6 strex (argument parse). */

static void 
do_strex (str)
     char *str;
{
  int rd, rm, rn;

  /* Parse Rd, Rm,. */
  skip_whitespace (str);
  if ((rd = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  if (rd == rm)
    {
      inst.error = _("Rd equal to Rm or Rn yields unpredictable results");
      return;
    }

  /* Skip past '['. */
  if ((strlen (str) >= 1) 
      && strncmp (str, "[", 1) == 0)
    str+=1;
  skip_whitespace (str);  

  /* Parse Rn. */
  if ((rn = reg_required_here (& str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  if (rd == rn)
    {
      inst.error = _("Rd equal to Rm or Rn yields unpredictable results");
      return;
    }
  skip_whitespace (str);  

  /* Skip past ']'. */
  if ((strlen (str) >= 1) 
      && strncmp (str, "]", 1) == 0)
    str+=1;
  
  end_of_line (str);
}

/* ARM V6 ssat (argument parse). */

static void
do_ssat (str)
     char* str;
{
  do_sat (&str, /*bias=*/-1);
  end_of_line (str);
}

/* ARM V6 usat (argument parse). */

static void
do_usat (str)
     char* str;
{
  do_sat (&str, /*bias=*/0);
  end_of_line (str);
}

static void
do_sat (str, bias)
     char **str;
     int    bias;
{
  int rd, rm;
  expressionS expr;

  skip_whitespace (*str);
  
  /* Parse <Rd>, field. */
  if ((rd = reg_required_here (str, 12)) == FAIL
      || skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Parse #<immed>,  field. */
  if (is_immediate_prefix (**str))
    (*str)++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number + bias < 0
      || expr.X_add_number + bias > 31)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  inst.instruction |= (expr.X_add_number + bias) << 16;
  if (skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Parse <Rm> field. */
  if ((rm = reg_required_here (str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  if (skip_past_comma (str) == SUCCESS)
    decode_shift (str, SHIFT_LSL_OR_ASR_IMMEDIATE);
}

/* ARM V6 ssat16 (argument parse). */

static void
do_ssat16 (str)
     char *str;
{
  do_sat16 (&str, /*bias=*/-1);
  end_of_line (str);
}

static void
do_usat16 (str)
     char *str;
{
  do_sat16 (&str, /*bias=*/0);
  end_of_line (str);
}

static void
do_sat16 (str, bias)
     char **str;
     int bias;
{
  int rd, rm;
  expressionS expr;

  skip_whitespace (*str);

  /* Parse the <Rd> field. */
  if ((rd = reg_required_here (str, 12)) == FAIL
      || skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Parse #<immed>, field. */
  if (is_immediate_prefix (**str))
    (*str)++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number + bias < 0
      || expr.X_add_number + bias > 15)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  inst.instruction |= (expr.X_add_number + bias) << 16;
  if (skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Parse <Rm> field. */
  if ((rm = reg_required_here (str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
}

/* ARM V6 srs (argument parse). */

static void
do_srs (str)
     char* str;
{
  char *exclam;
  skip_whitespace (str);
  exclam = strchr (str, '!');
  if (exclam)
    *exclam = '\0';
  do_cps_mode (&str);
  if (exclam)
    *exclam = '!';
  if (*str == '!') 
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  end_of_line (str);
}

/* ARM V6 SMMUL (argument parse). */

static void
do_smmul (str)
     char* str;
{
  int rd, rm, rs;
  
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rd == REG_PC 
      || rm == REG_PC
      || rs == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
  
}

/* ARM V6 SMLALD (argument parse). */

static void
do_smlald (str)
    char* str;
{
  int rdlo, rdhi, rm, rs;
  skip_whitespace (str);
  if ((rdlo = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rdhi = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rdlo == REG_PC 
      || rdhi == REG_PC 
      || rm == REG_PC
      || rs == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
}

/* ARM V6 SMLAD (argument parse).  Signed multiply accumulate dual. 
   smlad{x}{<cond>} Rd, Rm, Rs, Rn */

static void 
do_smlad (str)
     char *str;
{
  int rd, rm, rs, rn;
  
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 12)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  
  if (rd == REG_PC 
      || rn == REG_PC 
      || rs == REG_PC
      || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
} 

/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
   preserving the other bits.

   setend <endian_specifier>, where <endian_specifier> is either 
   BE or LE. */

static void 
do_setend (str)
     char *str;
{
  if (do_endian_specifier (str))
    inst.instruction |= 0x200;
}

/* Returns true if the endian-specifier indicates big-endianness.  */

static int
do_endian_specifier (str)
     char *str;
{
  int big_endian = 0;

  skip_whitespace (str);
  if (strlen (str) < 2)
    inst.error = _("missing endian specifier");
  else if (strncasecmp (str, "BE", 2) == 0)
    {
      str += 2;
      big_endian = 1;
    }
  else if (strncasecmp (str, "LE", 2) == 0)
    str += 2;
  else
    inst.error = _("valid endian specifiers are be or le");

  end_of_line (str);

  return big_endian;
}

/* ARM V6 SXTH.

   SXTH {<cond>} <Rd>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15. */

static void 
do_sxth (str)
     char *str;
{
  int rd, rm;
  expressionS expr;
  int rotation_clear_mask = 0xfffff3ff;
  int rotation_eight_mask = 0x00000400;
  int rotation_sixteen_mask = 0x00000800;
  int rotation_twenty_four_mask = 0x00000c00;
  
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  else if (rd == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  
  /* Zero out the rotation field. */
  inst.instruction &= rotation_clear_mask;
  
  /* Check for lack of optional rotation field. */
  if (skip_past_comma (&str) == FAIL)
    {
      end_of_line (str);
      return;
    }
  
  /* Move past 'ROR'. */
  skip_whitespace (str);
  if (strncasecmp (str, "ROR", 3) == 0)
    str+=3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return;
    }
  
  /* Get the immediate constant. */
  skip_whitespace (str);
  if (is_immediate_prefix (* str))
    str++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }

  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  
  switch (expr.X_add_number) 
    {
    case 0:
      /* Rotation field has already been zeroed. */
      break;
    case 8:
      inst.instruction |= rotation_eight_mask;
      break;

    case 16:
      inst.instruction |= rotation_sixteen_mask;
      break;
      
    case 24:
      inst.instruction |= rotation_twenty_four_mask;
      break;

    default:
      inst.error = _("rotation can be 8, 16, 24 or 0 when field is ommited");
      break;
    }

  end_of_line (str);
  
}

/* ARM V6 SXTAH extracts a 16-bit value from a register, sign
   extends it to 32-bits, and adds the result to a value in another
   register.  You can specify a rotation by 0, 8, 16, or 24 bits
   before extracting the 16-bit value.
   SXTAH{<cond>} <Rd>, <Rn>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15. */

static void 
do_sxtah (str)
     char *str;
{
  int rd, rn, rm;
  expressionS expr;
  int rotation_clear_mask = 0xfffff3ff;
  int rotation_eight_mask = 0x00000400;
  int rotation_sixteen_mask = 0x00000800;
  int rotation_twenty_four_mask = 0x00000c00;
  
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  else if (rd == REG_PC || rn == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  
  /* Zero out the rotation field. */
  inst.instruction &= rotation_clear_mask;
  
  /* Check for lack of optional rotation field. */
  if (skip_past_comma (&str) == FAIL)
    {
      end_of_line (str);
      return;
    }
  
  /* Move past 'ROR'. */
  skip_whitespace (str);
  if (strncasecmp (str, "ROR", 3) == 0)
    str+=3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return;
    }
  
  /* Get the immediate constant. */
  skip_whitespace (str);
  if (is_immediate_prefix (* str))
    str++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }

  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  
  switch (expr.X_add_number) 
    {
    case 0:
      /* Rotation field has already been zeroed. */
      break;

    case 8:
      inst.instruction |= rotation_eight_mask;
      break;

    case 16:
      inst.instruction |= rotation_sixteen_mask;
      break;
      
    case 24:
      inst.instruction |= rotation_twenty_four_mask;
      break;

    default:
      inst.error = _("rotation can be 8, 16, 24 or 0 when field is ommited");
      break;
    }

  end_of_line (str);
  
}
   

/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the
   word at the specified address and the following word
   respectively. 
   Unconditionally executed.
   Error if Rn is R15.   
*/

static void
do_rfe (str)
     char *str;
{
  int rn;

  skip_whitespace (str);
  
  if ((rn = reg_required_here (&str, 16)) == FAIL)
    return;

  if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  skip_whitespace (str);
  
  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  end_of_line (str);
}

/* ARM V6 REV (Byte Reverse Word) reverses the byte order in a 32-bit
   register (argument parse).
   REV{<cond>} Rd, Rm.
   Condition defaults to COND_ALWAYS.
   Error if Rd or Rm are R15. */ 

static void
do_rev (str)
     char* str;
{
  int rd, rm;

  skip_whitespace (str);

  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC)
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V6 Perform Two Sixteen Bit Integer Additions. (argument parse).
   QADD16{<cond>} <Rd>, <Rn>, <Rm>  
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */

static void
do_qadd16 (str) 
     char* str;
{
  int rd, rm, rn;

  skip_whitespace (str);

  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>} 
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */

static void 
do_pkhbt (str)
     char* str;
{
  do_pkh_core (str, SHIFT_LSL_IMMEDIATE);
}

/* ARM V6 PKHTB (Argument Parse). */

static void 
do_pkhtb (str)
     char* str;
{
  do_pkh_core (str, SHIFT_ASR_IMMEDIATE);
}

static void
do_pkh_core (str, shift)
     char* str;
     int shift;
{
  int rd, rn, rm;

  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL)
      || ((rn = reg_required_here (&str, 16)) == FAIL)
      || (skip_past_comma (&str) == FAIL)
      || ((rm = reg_required_here (&str, 0)) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }

  else if (rd == REG_PC || rn == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Check for optional shift immediate constant. */
  if (skip_past_comma (&str) == FAIL) 
    {
      if (shift == SHIFT_ASR_IMMEDIATE)
	{
	  /* If the shift specifier is ommited, turn the instruction
	     into pkhbt rd, rm, rn.  First, switch the instruction
	     code, and clear the rn and rm fields.  */
	  inst.instruction &= 0xfff0f010;
	  /* Now, re-encode the registers.  */
	  inst.instruction |= (rm << 16) | rn;
	}
      return;
    }

  decode_shift (&str, shift);
}

/* ARM V6 Load Register Exclusive instruction (argument parse).
   LDREX{<cond>} <Rd, [<Rn>]
   Condition defaults to COND_ALWAYS.
   Error if Rd or Rn are R15. 
   See ARMARMv6 A4.1.27: LDREX. */


static void
do_ldrex (str)
     char * str;
{
  int rd, rn;

  skip_whitespace (str);

  /* Parse Rd. */
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  skip_whitespace (str);  

  /* Skip past '['. */
  if ((strlen (str) >= 1) 
      &&strncmp (str, "[", 1) == 0)
    str+=1;
  skip_whitespace (str);  

  /* Parse Rn. */
  if ((rn = reg_required_here (&str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  skip_whitespace (str);  

  /* Skip past ']'. */
  if ((strlen (str) >= 1) 
      && strncmp (str, "]", 1) == 0)
    str+=1;
  
  end_of_line (str);
}

/* ARM V6 change processor state instruction (argument parse)
      CPS, CPSIE, CSPID . */

static void
do_cps (str)
     char * str;
{
  do_cps_mode (&str);
  end_of_line (str);
}

static void
do_cpsi (str)
     char * str;
{
  do_cps_flags (&str, /*thumb_p=*/0);

  if (skip_past_comma (&str) == SUCCESS)
    {
      skip_whitespace (str);
      do_cps_mode (&str);
    }
  end_of_line (str);
}

static void
do_cps_mode (str)
     char **str;
{
  expressionS expr;

  skip_whitespace (*str);

  if (! is_immediate_prefix (**str))
    {
      inst.error = _("immediate expression expected");
      return;
    }

  (*str)++; /* Strip off the immediate signifier. */
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }

  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  
  /* The mode is a 5 bit field.  Valid values are 0-31. */
  if (((unsigned) expr.X_add_number) > 31
      || (inst.reloc.exp.X_add_number) < 0)
    {
      inst.error = _("invalid constant");
      return;
    }
  
  inst.instruction |= expr.X_add_number;
}

static void
do_cps_flags (str, thumb_p)
     char **str;
     int    thumb_p;
{
  struct cps_flag { 
    char character;
    unsigned long arm_value;
    unsigned long thumb_value;
  };
  static struct cps_flag flag_table[] = {
    {'a', 0x100, 0x4 },
    {'i', 0x080, 0x2 },
    {'f', 0x040, 0x1 }
  };

  int saw_a_flag = 0;

  skip_whitespace (*str);

  /* Get the a, f and i flags. */
  while (**str && **str != ',')
    {
      struct cps_flag *p;
      struct cps_flag *q = flag_table + sizeof (flag_table)/sizeof (*p);
      for (p = flag_table; p < q; ++p)
	if (strncasecmp (*str, &p->character, 1) == 0)
	  {
	    inst.instruction |= (thumb_p ? p->thumb_value : p->arm_value);
	    saw_a_flag = 1;
	    break;
	  }
      if (p == q)
	{
	  inst.error = _("unrecognized flag");
	  return;
	}
      (*str)++;
    }
  if (!saw_a_flag) 
    inst.error = _("no 'a', 'i', or 'f' flags for 'cps'");
}

/* THUMB V5 breakpoint instruction (argument parse)
	BKPT <immed_8>.  */

static void
do_t_bkpt (str)
     char * str;
{
  expressionS expr;
  unsigned long number;

  skip_whitespace (str);

  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str ++;

  memset (& expr, '\0', sizeof (expr));
  if (my_get_expression (& expr, & str)
      || (expr.X_op != O_constant
	  /* As a convenience we allow 'bkpt' without an operand.  */
	  && expr.X_op != O_absent))
    {
      inst.error = _("bad expression");
      return;
    }

  number = expr.X_add_number;

  /* Check it fits an 8 bit unsigned.  */
  if (number != (number & 0xff))
    {
      inst.error = _("immediate value out of range");
      return;
    }

  inst.instruction |= number;

  end_of_line (str);
}

/* ARM V5 branch-link-exchange (argument parse) for BLX(1) only.
   Expects inst.instruction is set for BLX(1).
   Note: this is cloned from do_branch, and the reloc changed to be a
	new one that can cope with setting one extra bit (the H bit).  */

static void
do_branch25 (str)
     char *        str;
{
  if (my_get_expression (& inst.reloc.exp, & str))
    return;

#ifdef OBJ_ELF
  {
    char * save_in;

    /* ScottB: February 5, 1998 */
    /* Check to see of PLT32 reloc required for the instruction.  */

    /* arm_parse_reloc() works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;

    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BLX;
	inst.reloc.pc_rel = 1;
      }

    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BLX;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF */

  end_of_line (str);
}

/* ARM V5 branch-link-exchange instruction (argument parse)
     BLX <target_addr>		ie BLX(1)
     BLX{<condition>} <Rm>	ie BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
   Also, the <target_addr> can be 25 bits, hence has its own reloc.  */

static void
do_blx (str)
     char *        str;
{
  char * mystr = str;
  int rm;

  skip_whitespace (mystr);
  rm = reg_required_here (& mystr, 0);

  /* The above may set inst.error.  Ignore his opinion.  */
  inst.error = 0;

  if (rm != FAIL)
    {
      /* Arg is a register.
	 Use the condition code our caller put in inst.instruction.
	 Pass ourselves off as a BX with a funny opcode.  */
      inst.instruction |= 0x012fff30;
      do_bx (str);
    }
  else
    {
      /* This must be is BLX <target address>, no condition allowed.  */
      if (inst.instruction != COND_ALWAYS)
	{
	  inst.error = BAD_COND;
	  return;
	}

      inst.instruction = 0xfafffffe;

      /* Process like a B/BL, but with a different reloc.
	 Note that B/BL expecte fffffe, not 0, offset in the opcode table.  */
      do_branch25 (str);
    }
}

/* ARM V5 Thumb BLX (argument parse)
	BLX <target_addr>	which is BLX(1)
	BLX <Rm>		which is BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the tinsns[].value is not used, and the code here zaps values
	into inst.instruction.	*/

static void
do_t_blx (str)
     char * str;
{
  char * mystr = str;
  int rm;

  skip_whitespace (mystr);
  inst.instruction = 0x4780;

  /* Note that this call is to the ARM register recognizer.  BLX(2)
     uses the ARM register space, not the Thumb one, so a call to
     thumb_reg() would be wrong.  */
  rm = reg_required_here (& mystr, 3);
  inst.error = 0;

  if (rm != FAIL)
    {
      /* It's BLX(2).  The .instruction was zapped with rm & is final.  */
      inst.size = 2;
    }
  else
    {
      /* No ARM register.  This must be BLX(1).  Change the .instruction.  */
      inst.instruction = 0xf7ffeffe;
      inst.size = 4;

      if (my_get_expression (& inst.reloc.exp, & mystr))
	return;

      inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BLX;
      inst.reloc.pc_rel = 1;
    }

  end_of_line (mystr);
}

/* ARM V5 breakpoint instruction (argument parse)
     BKPT <16 bit unsigned immediate>
     Instruction is not conditional.
	The bit pattern given in insns[] has the COND_ALWAYS condition,
	and it is an error if the caller tried to override that.  */

static void
do_bkpt (str)
     char *        str;
{
  expressionS expr;
  unsigned long number;

  skip_whitespace (str);

  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (* str))
    str++;

  memset (& expr, '\0', sizeof (expr));

  if (my_get_expression (& expr, & str)
      || (expr.X_op != O_constant
	  /* As a convenience we allow 'bkpt' without an operand.  */
	  && expr.X_op != O_absent))
    {
      inst.error = _("bad expression");
      return;
    }

  number = expr.X_add_number;

  /* Check it fits a 16 bit unsigned.  */
  if (number != (number & 0xffff))
    {
      inst.error = _("immediate value out of range");
      return;
    }

  /* Top 12 of 16 bits to bits 19:8.  */
  inst.instruction |= (number & 0xfff0) << 4;

  /* Bottom 4 of 16 bits to bits 3:0.  */
  inst.instruction |= number & 0xf;

  end_of_line (str);
}

/* THUMB CPS instruction (argument parse).  */

static void
do_t_cps (str)
     char *str;
{
  do_cps_flags (&str, /*thumb_p=*/1);
  end_of_line (str);
}

/* THUMB CPY instruction (argument parse).  */

static void
do_t_cpy (str)
     char *str;
{
  thumb_mov_compare (str, THUMB_CPY);
}

/* THUMB SETEND instruction (argument parse).  */

static void
do_t_setend (str)
     char *str;
{
  if (do_endian_specifier (str))
    inst.instruction |= 0x8;
}

static unsigned long check_iwmmxt_insn PARAMS ((char *, enum iwmmxt_insn_type, int));

/* Parse INSN_TYPE insn STR having a possible IMMEDIATE_SIZE immediate.  */

static unsigned long
check_iwmmxt_insn (str, insn_type, immediate_size)
     char * str;
     enum iwmmxt_insn_type insn_type;
     int immediate_size;
{
  int reg = 0;
  const char *  inst_error;
  expressionS expr;
  unsigned long number;

  inst_error = inst.error;
  if (!inst.error)
    inst.error = BAD_ARGS;
  skip_whitespace (str);

  switch (insn_type)
    {
    case check_rd:
      if ((reg = reg_required_here (&str, 12)) == FAIL)
	return FAIL;
      break;
      
    case check_wr:
       if ((wreg_required_here (&str, 0, IWMMXT_REG_WR)) == FAIL)
	 return FAIL;
       break;
       
    case check_wrwr:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
      
    case check_wrwrwr:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
      
    case check_wrwrwcg:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WCG) == FAIL))
	return FAIL;
      break;
      
    case check_tbcst:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;
      
    case check_tmovmsk:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
      
    case check_tmia:
      if ((wreg_required_here (&str, 5, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 0) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;
      
    case check_tmcrr:
      if ((wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 16) == FAIL))
	return FAIL;
      break;
      
    case check_tmrrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 16) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
      
    case check_tmcr:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WC) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;
      
    case check_tmrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WC) == FAIL))
	return FAIL;
      break;
      
    case check_tinsr:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
      
    case check_textrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
      
    case check_waligni:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
      
    case check_textrm:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
      
    case check_wshufh:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
    }
  
  if (immediate_size == 0)
    {
      end_of_line (str);
      inst.error = inst_error;
      return reg;
    }
  else
    {
      skip_whitespace (str);      
  
      /* Allow optional leading '#'. */
      if (is_immediate_prefix (* str))
        str++;

      memset (& expr, '\0', sizeof (expr));
  
      if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
        {
          inst.error = _("bad or missing expression");
          return FAIL;
        }
  
      number = expr.X_add_number;
  
      if (number != (number & immediate_size))
        {
          inst.error = _("immediate value out of range");
          return FAIL;
        }
      end_of_line (str);
      inst.error = inst_error;
      return number;
    }
}

static void
do_iwmmxt_byte_addr (str)
     char * str;
{
  int op = (inst.instruction & 0x300) >> 8;
  int reg;

  inst.instruction &= ~0x300;
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;  

  skip_whitespace (str);

  if ((reg = wreg_required_here (&str, 12, IWMMXT_REG_WR_OR_WC)) == FAIL
      || skip_past_comma (& str) == FAIL
      || cp_byte_address_required_here (&str) == FAIL)
    {
      if (! inst.error)
        inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);

  if (wc_register (reg))
    {
      as_bad (_("non-word size not supported with control register"));
      inst.instruction |=  0xf0000100;
      inst.instruction &= ~0x00400000;
    }
}

static void
do_iwmmxt_tandc (str)
     char * str;
{
  int reg;

  reg = check_iwmmxt_insn (str, check_rd, 0);

  if (reg != REG_PC && !inst.error)
    inst.error = _("only r15 allowed here");
}

static void
do_iwmmxt_tbcst (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tbcst, 0);
}

static void
do_iwmmxt_textrc (str)
     char * str;
{
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_textrc, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= number & 0x7;
}

static void
do_iwmmxt_textrm (str)
     char * str;
{
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_textrm, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= number & 0x7;
}

static void
do_iwmmxt_tinsr (str)
     char * str;
{
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_tinsr, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= number & 0x7;
}

static void
do_iwmmxt_tmcr (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmcr, 0);
}

static void
do_iwmmxt_tmcrr (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmcrr, 0);
}

static void
do_iwmmxt_tmia (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmia, 0);
}

static void
do_iwmmxt_tmovmsk (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmovmsk, 0);
}

static void
do_iwmmxt_tmrc (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmrc, 0);
}

static void
do_iwmmxt_tmrrc (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmrrc, 0);
}

static void
do_iwmmxt_torc (str)
     char * str;
{
  check_iwmmxt_insn (str, check_rd, 0);
}

static void
do_iwmmxt_waligni (str)
     char * str;
{
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_waligni, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((number & 0x7) << 20);
}

static void
do_iwmmxt_wmov (str)
     char * str;
{
  if (check_iwmmxt_insn (str, check_wrwr, 0) == (unsigned long) FAIL)
    return;
  
  inst.instruction |= ((inst.instruction >> 16) & 0xf);
}

static void
do_iwmmxt_word_addr (str)
     char * str;
{
  int op = (inst.instruction & 0x300) >> 8;
  int reg;

  inst.instruction &= ~0x300;
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;  

  skip_whitespace (str);

  if ((reg = wreg_required_here (&str, 12, IWMMXT_REG_WR_OR_WC)) == FAIL
      || skip_past_comma (& str) == FAIL
      || cp_address_required_here (& str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
        inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);

  if (wc_register (reg))
    {
      if ((inst.instruction & COND_MASK) != COND_ALWAYS)
	as_bad (_("conditional execution not supported with control register"));
      if (op != 2)
	as_bad (_("non-word size not supported with control register"));
      inst.instruction |=  0xf0000100;
      inst.instruction &= ~0x00400000;
    }
}

static void
do_iwmmxt_wrwr (str)
     char * str;
{
  check_iwmmxt_insn (str, check_wrwr, 0);
}

static void
do_iwmmxt_wrwrwcg (str)
     char * str;
{
  check_iwmmxt_insn (str, check_wrwrwcg, 0);
}

static void
do_iwmmxt_wrwrwr (str)
     char * str;
{
  check_iwmmxt_insn (str, check_wrwrwr, 0);
}

static void
do_iwmmxt_wshufh (str)
     char * str;
{
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_wshufh, 0xff)) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((number & 0xf0) << 16) | (number & 0xf);
}

static void
do_iwmmxt_wzero (str)
     char * str;
{
  if (check_iwmmxt_insn (str, check_wr, 0) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((inst.instruction & 0xf) << 12) | ((inst.instruction & 0xf) << 16);
}

/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */

static void
do_xsc_mia (str)
     char * str;
{
  int rs;
  int rm;

  if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;

  else if (skip_past_comma (& str) == FAIL
	   || (rm = reg_required_here (& str, 0)) == FAIL)
    inst.error = BAD_ARGS;

  else if (skip_past_comma (& str) == FAIL
	   || (rs = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  /* inst.instruction has now been zapped with both rm and rs.  */
  else if (rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rm or rs is R15.  */

  else
    end_of_line (str);
}

/* Xscale move-accumulator-register (argument parse)

     MARcc   acc0,RdLo,RdHi.  */

static void
do_xsc_mar (str)
     char * str;
{
  int rdlo, rdhi;

  if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;

  else if (skip_past_comma (& str) == FAIL
	   || (rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;

  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */

  else
    end_of_line (str);
}

/* Xscale move-register-accumulator (argument parse)

     MRAcc   RdLo,RdHi,acc0.  */

static void
do_xsc_mra (str)
     char * str;
{
  int rdlo;
  int rdhi;

  skip_whitespace (str);

  if ((rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;

  else if  (skip_past_comma (& str) == FAIL
	    || accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;

  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == rdhi)
    inst.error = BAD_ARGS;	/* Undefined result if 2 writes to same reg.  */

  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */
  else
    end_of_line (str);
}

/* ARMv5TE: Preload-Cache

    PLD <addr_mode>

  Syntactically, like LDR with B=1, W=0, L=1.  */

static void
do_pld (str)
     char * str;
{
  int rd;

  skip_whitespace (str);

  if (* str != '[')
    {
      inst.error = _("'[' expected after PLD mnemonic");
      return;
    }

  ++str;
  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 16)) == FAIL)
    return;

  skip_whitespace (str);

  if (*str == ']')
    {
      /* [Rn], ... ?  */
      ++str;
      skip_whitespace (str);

      /* Post-indexed addressing is not allowed with PLD.  */
      if (skip_past_comma (&str) == SUCCESS)
	{
	  inst.error
	    = _("post-indexed expression used in preload instruction");
	  return;
	}
      else if (*str == '!') /* [Rn]! */
	{
	  inst.error = _("writeback used in preload instruction");
	  ++str;
	}
      else /* [Rn] */
	inst.instruction |= INDEX_UP | PRE_INDEX;
    }
  else /* [Rn, ...] */
    {
      if (skip_past_comma (& str) == FAIL)
	{
	  inst.error = _("pre-indexed expression expected");
	  return;
	}

      if (ldst_extend (&str) == FAIL)
	return;

      skip_whitespace (str);

      if (* str != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}

      ++ str;
      skip_whitespace (str);

      if (* str == '!') /* [Rn]! */
	{
	  inst.error = _("writeback used in preload instruction");
	  ++ str;
	}

      inst.instruction |= PRE_INDEX;
    }

  end_of_line (str);
}

/* ARMv5TE load-consecutive (argument parse)
   Mode is like LDRH.

     LDRccD R, mode
     STRccD R, mode.  */

static void
do_ldrd (str)
     char * str;
{
  int rd;
  int rn;

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 12)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || (rn = ld_mode_required_here (& str)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* inst.instruction has now been zapped with Rd and the addressing mode.  */
  if (rd & 1)		/* Unpredictable result if Rd is odd.  */
    {
      inst.error = _("destination register must be even");
      return;
    }

  if (rd == REG_LR)
    {
      inst.error = _("r14 not allowed here");
      return;
    }

  if (((rd == rn) || (rd + 1 == rn))
      && ((inst.instruction & WRITE_BACK)
	  || (!(inst.instruction & PRE_INDEX))))
    as_warn (_("pre/post-indexing used when modified address register is destination"));

  /* For an index-register load, the index register must not overlap the
     destination (even if not write-back).  */
  if ((inst.instruction & V4_STR_BIT) == 0
      && (inst.instruction & HWOFFSET_IMM) == 0)
    {
      int rm = inst.instruction & 0x0000000f;

      if (rm == rd || (rm == rd + 1))
	as_warn (_("ldrd destination registers must not overlap index register"));
    }

  end_of_line (str);
}

/* Returns the index into fp_values of a floating point number,
   or -1 if not in the table.  */

static int
my_get_float_expression (str)
     char ** str;
{
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *         save_in;
  expressionS    exp;
  int            i;
  int            j;

  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));

  /* Look for a raw floating point number.  */
  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
      && is_end_of_line[(unsigned char) *save_in])
    {
      for (i = 0; i < NUM_FLOAT_VALS; i++)
	{
	  for (j = 0; j < MAX_LITTLENUMS; j++)
	    {
	      if (words[j] != fp_values[i][j])
		break;
	    }

	  if (j == MAX_LITTLENUMS)
	    {
	      *str = save_in;
	      return i;
	    }
	}
    }

  /* Try and parse a more complex expression, this will probably fail
     unless the code uses a floating point prefix (eg "0f").  */
  save_in = input_line_pointer;
  input_line_pointer = *str;
  if (expression (&exp) == absolute_section
      && exp.X_op == O_big
      && exp.X_add_number < 0)
    {
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.  */
      if (gen_to_words (words, 5, (long) 15) == 0)
	{
	  for (i = 0; i < NUM_FLOAT_VALS; i++)
	    {
	      for (j = 0; j < MAX_LITTLENUMS; j++)
		{
		  if (words[j] != fp_values[i][j])
		    break;
		}

	      if (j == MAX_LITTLENUMS)
		{
		  *str = input_line_pointer;
		  input_line_pointer = save_in;
		  return i;
		}
	    }
	}
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  return -1;
}

/* Return TRUE if anything in the expression is a bignum.  */

static int
walk_no_bignums (sp)
     symbolS * sp;
{
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;

  if (symbol_get_value_expression (sp)->X_add_symbol)
    {
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
    }

  return 0;
}

static int in_my_get_expression = 0;

static int
my_get_expression (ep, str)
     expressionS * ep;
     char ** str;
{
  char * save_in;
  segT   seg;

  save_in = input_line_pointer;
  input_line_pointer = *str;
  in_my_get_expression = 1;
  seg = expression (ep);
  in_my_get_expression = 0;

  if (ep->X_op == O_illegal)
    {
      /* We found a bad expression in md_operand().  */
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }

#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad_segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
#endif

  /* Get rid of any bignums now, so that we don't generate an error for which
     we can't establish a line number later on.  Big numbers are never valid
     in instructions, which is where this routine is always called.  */
  if (ep->X_op == O_big
      || (ep->X_add_symbol
	  && (walk_no_bignums (ep->X_add_symbol)
	      || (ep->X_op_symbol
		  && walk_no_bignums (ep->X_op_symbol)))))
    {
      inst.error = _("invalid constant");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
}

/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expr)
     expressionS *expr;
{
  if (in_my_get_expression)
    {
      expr->X_op = O_illegal;
      if (inst.error == NULL)
	inst.error = _("bad expression");
    }
}

/* KIND indicates what kind of shifts are accepted.  */

static int
decode_shift (str, kind)
     char ** str;
     int     kind;
{
  const struct asm_shift_name * shift;
  char * p;
  char   c;

  skip_whitespace (* str);

  for (p = * str; ISALPHA (* p); p ++)
    ;

  if (p == * str)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }

  c = * p;
  * p = '\0';
  shift = (const struct asm_shift_name *) hash_find (arm_shift_hsh, * str);
  * p = c;

  if (shift == NULL)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }

  assert (shift->properties->index == shift_properties[shift->properties->index].index);

  if (kind == SHIFT_LSL_OR_ASR_IMMEDIATE
      && shift->properties->index != SHIFT_LSL
      && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'LSL' or 'ASR' required");
      return FAIL;
    }
  else if (kind == SHIFT_LSL_IMMEDIATE
	   && shift->properties->index != SHIFT_LSL)
    {
      inst.error = _("'LSL' required");
      return FAIL;
    }
  else if (kind == SHIFT_ASR_IMMEDIATE
	   && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'ASR' required");
      return FAIL;
    }
    
  if (shift->properties->index == SHIFT_RRX)
    {
      * str = p;
      inst.instruction |= shift->properties->bit_field;
      return SUCCESS;
    }

  skip_whitespace (p);

  if (kind == NO_SHIFT_RESTRICT && reg_required_here (& p, 8) != FAIL)
    {
      inst.instruction |= shift->properties->bit_field | SHIFT_BY_REG;
      * str = p;
      return SUCCESS;
    }
  else if (! is_immediate_prefix (* p))
    {
      inst.error = (NO_SHIFT_RESTRICT
		    ? _("shift requires register or #expression")
		    : _("shift requires #expression"));
      * str = p;
      return FAIL;
    }

  inst.error = NULL;
  p ++;

  if (my_get_expression (& inst.reloc.exp, & p))
    return FAIL;

  /* Validate some simple #expressions.  */
  if (inst.reloc.exp.X_op == O_constant)
    {
      unsigned num = inst.reloc.exp.X_add_number;

      /* Reject operations greater than 32.  */
      if (num > 32
	  /* Reject a shift of 0 unless the mode allows it.  */
	  || (num == 0 && shift->properties->allows_0 == 0)
	  /* Reject a shift of 32 unless the mode allows it.  */
	  || (num == 32 && shift->properties->allows_32 == 0)
	  )
	{
	  /* As a special case we allow a shift of zero for
	     modes that do not support it to be recoded as an
	     logical shift left of zero (ie nothing).  We warn
	     about this though.  */
	  if (num == 0)
	    {
	      as_warn (_("shift of 0 ignored."));
	      shift = & shift_names[0];
	      assert (shift->properties->index == SHIFT_LSL);
	    }
	  else
	    {
	      inst.error = _("invalid immediate shift");
	      return FAIL;
	    }
	}

      /* Shifts of 32 are encoded as 0, for those shifts that
	 support it.  */
      if (num == 32)
	num = 0;

      inst.instruction |= (num << 7) | shift->properties->bit_field;
    }
  else
    {
      inst.reloc.type   = BFD_RELOC_ARM_SHIFT_IMM;
      inst.reloc.pc_rel = 0;
      inst.instruction |= shift->properties->bit_field;
    }

  * str = p;
  return SUCCESS;
}

/* Do those data_ops which can take a negative immediate constant
   by altering the instruction.  A bit of a hack really.
        MOV <-> MVN
        AND <-> BIC
        ADC <-> SBC
        by inverting the second operand, and
        ADD <-> SUB
        CMP <-> CMN
        by negating the second operand.  */

static int
negate_data_op (instruction, value)
     unsigned long * instruction;
     unsigned long   value;
{
  int op, new_inst;
  unsigned long negated, inverted;

  negated = validate_immediate (-value);
  inverted = validate_immediate (~value);

  op = (*instruction >> DATA_OP_SHIFT) & 0xf;
  switch (op)
    {
      /* First negates.  */
    case OPCODE_SUB:             /* ADD <-> SUB  */
      new_inst = OPCODE_ADD;
      value = negated;
      break;

    case OPCODE_ADD:
      new_inst = OPCODE_SUB;
      value = negated;
      break;

    case OPCODE_CMP:             /* CMP <-> CMN  */
      new_inst = OPCODE_CMN;
      value = negated;
      break;

    case OPCODE_CMN:
      new_inst = OPCODE_CMP;
      value = negated;
      break;

      /* Now Inverted ops.  */
    case OPCODE_MOV:             /* MOV <-> MVN  */
      new_inst = OPCODE_MVN;
      value = inverted;
      break;

    case OPCODE_MVN:
      new_inst = OPCODE_MOV;
      value = inverted;
      break;

    case OPCODE_AND:             /* AND <-> BIC  */
      new_inst = OPCODE_BIC;
      value = inverted;
      break;

    case OPCODE_BIC:
      new_inst = OPCODE_AND;
      value = inverted;
      break;

    case OPCODE_ADC:              /* ADC <-> SBC  */
      new_inst = OPCODE_SBC;
      value = inverted;
      break;

    case OPCODE_SBC:
      new_inst = OPCODE_ADC;
      value = inverted;
      break;

      /* We cannot do anything.  */
    default:
      return FAIL;
    }

  if (value == (unsigned) FAIL)
    return FAIL;

  *instruction &= OPCODE_MASK;
  *instruction |= new_inst << DATA_OP_SHIFT;
  return value;
}

static int
data_op2 (str)
     char ** str;
{
  int value;
  expressionS expr;

  skip_whitespace (* str);

  if (reg_required_here (str, 0) != FAIL)
    {
      if (skip_past_comma (str) == SUCCESS)
	/* Shift operation on register.  */
	return decode_shift (str, NO_SHIFT_RESTRICT);

      return SUCCESS;
    }
  else
    {
      /* Immediate expression.  */
      if (is_immediate_prefix (**str))
	{
	  (*str)++;
	  inst.error = NULL;

	  if (my_get_expression (&inst.reloc.exp, str))
	    return FAIL;

	  if (inst.reloc.exp.X_add_symbol)
	    {
	      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
	      inst.reloc.pc_rel = 0;
	    }
	  else
	    {
	      if (skip_past_comma (str) == SUCCESS)
		{
		  /* #x, y -- ie explicit rotation by Y.  */
		  if (my_get_expression (&expr, str))
		    return FAIL;

		  if (expr.X_op != O_constant)
		    {
		      inst.error = _("constant expression expected");
		      return FAIL;
		    }

		  /* Rotate must be a multiple of 2.  */
		  if (((unsigned) expr.X_add_number) > 30
		      || (expr.X_add_number & 1) != 0
		      || ((unsigned) inst.reloc.exp.X_add_number) > 255)
		    {
		      inst.error = _("invalid constant");
		      return FAIL;
		    }
		  inst.instruction |= INST_IMMEDIATE;
		  inst.instruction |= inst.reloc.exp.X_add_number;
		  inst.instruction |= expr.X_add_number << 7;
		  return SUCCESS;
		}

	      /* Implicit rotation, select a suitable one.  */
	      value = validate_immediate (inst.reloc.exp.X_add_number);

	      if (value == FAIL)
		{
		  /* Can't be done.  Perhaps the code reads something like
		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be OK.  */
		  if ((value = negate_data_op (&inst.instruction,
					       inst.reloc.exp.X_add_number))
		      == FAIL)
		    {
		      inst.error = _("invalid constant");
		      return FAIL;
		    }
		}

	      inst.instruction |= value;
	    }

	  inst.instruction |= INST_IMMEDIATE;
	  return SUCCESS;
	}

      (*str)++;
      inst.error = _("register or shift expression expected");
      return FAIL;
    }
}

static int
fp_op2 (str)
     char ** str;
{
  skip_whitespace (* str);

  if (fp_reg_required_here (str, 0) != FAIL)
    return SUCCESS;
  else
    {
      /* Immediate expression.  */
      if (*((*str)++) == '#')
	{
	  int i;

	  inst.error = NULL;

	  skip_whitespace (* str);

	  /* First try and match exact strings, this is to guarantee
	     that some formats will work even for cross assembly.  */

	  for (i = 0; fp_const[i]; i++)
	    {
	      if (strncmp (*str, fp_const[i], strlen (fp_const[i])) == 0)
		{
		  char *start = *str;

		  *str += strlen (fp_const[i]);
		  if (is_end_of_line[(unsigned char) **str])
		    {
		      inst.instruction |= i + 8;
		      return SUCCESS;
		    }
		  *str = start;
		}
	    }

	  /* Just because we didn't get a match doesn't mean that the
	     constant isn't valid, just that it is in a format that we
	     don't automatically recognize.  Try parsing it with
	     the standard expression routines.  */
	  if ((i = my_get_float_expression (str)) >= 0)
	    {
	      inst.instruction |= i + 8;
	      return SUCCESS;
	    }

	  inst.error = _("invalid floating point immediate expression");
	  return FAIL;
	}
      inst.error =
	_("floating point register or immediate expression expected");
      return FAIL;
    }
}

static void
do_arit (str)
     char * str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_adr (str)
     char * str;
{
  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-8".  */
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
#endif
  inst.reloc.pc_rel = 1;

  end_of_line (str);
}

static void
do_adrl (str)
     char * str;
{
  /* This is a pseudo-op of the form "adrl rd, label" to be converted
     into a relative address of the form:
     add rd, pc, #low(label-.-8)"
     add rd, rd, #high(label-.-8)"  */

  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
    {
      if (!inst.error)
	inst.error = BAD_ARGS;

      return;
    }

  end_of_line (str);
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type              = BFD_RELOC_ARM_ADRL_IMMEDIATE;
#ifndef TE_WINCE  
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
#endif
  inst.reloc.pc_rel            = 1;
  inst.size                    = INSN_SIZE * 2;
}

static void
do_cmp (str)
     char * str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_mov (str)
     char * str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static int
ldst_extend (str)
     char ** str;
{
  int add = INDEX_UP;

  switch (**str)
    {
    case '#':
    case '$':
      (*str)++;
      if (my_get_expression (& inst.reloc.exp, str))
	return FAIL;

      if (inst.reloc.exp.X_op == O_constant)
	{
	  int value = inst.reloc.exp.X_add_number;

	  if (value < -4095 || value > 4095)
	    {
	      inst.error = _("address offset too large");
	      return FAIL;
	    }

	  if (value < 0)
	    {
	      value = -value;
	      add = 0;
	    }

	  inst.instruction |= add | value;
	}
      else
	{
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
	  inst.reloc.pc_rel = 0;
	}
      return SUCCESS;

    case '-':
      add = 0;
      /* Fall through.  */

    case '+':
      (*str)++;
      /* Fall through.  */

    default:
      if (reg_required_here (str, 0) == FAIL)
	return FAIL;

      inst.instruction |= add | OFFSET_REG;
      if (skip_past_comma (str) == SUCCESS)
	return decode_shift (str, SHIFT_IMMEDIATE);

      return SUCCESS;
    }
}

static void
do_ldst (str)
     char *        str;
{
  int pre_inc = 0;
  int conflict_reg;
  int value;

  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (&str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = _("address expected");
      return;
    }

  if (*str == '[')
    {
      int reg;

      str++;

      skip_whitespace (str);

      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;

      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);

      skip_whitespace (str);

      if (*str == ']')
	{
	  str ++;

	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend (&str) == FAIL)
		return;
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	    }
	  else
	    {
	      /* [Rn]  */
	      skip_whitespace (str);

	      if (*str == '!')
		{
		  if (conflict_reg)
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		  str++;
		  inst.instruction |= WRITE_BACK;
		}

	      inst.instruction |= INDEX_UP;
	      pre_inc = 1;
	    }
	}
      else
	{
	  /* [Rn,...]  */
	  if (skip_past_comma (&str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return;
	    }

	  pre_inc = 1;
	  if (ldst_extend (&str) == FAIL)
	    return;

	  skip_whitespace (str);

	  if (*str++ != ']')
	    {
	      inst.error = _("missing ]");
	      return;
	    }

	  skip_whitespace (str);

	  if (*str == '!')
	    {
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	      str++;
	      inst.instruction |= WRITE_BACK;
	    }
	}
    }
  else if (*str == '=')
    {
      if ((inst.instruction & LOAD_BIT) == 0)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}

      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;

      skip_whitespace (str);

      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      if (inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = _("constant expression expected");
	  return;
	}

      if (inst.reloc.exp.X_op == O_constant)
	{
	  value = validate_immediate (inst.reloc.exp.X_add_number);

	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MOV << DATA_OP_SHIFT));
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }

	  value = validate_immediate (~inst.reloc.exp.X_add_number);

	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MVN << DATA_OP_SHIFT));
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
	}

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = _("literal pool insertion failed");
	  return;
	}

      /* Change the instruction exp to point to the pool.  */
      inst.reloc.type = BFD_RELOC_ARM_LITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
#ifndef TE_WINCE
      /* PC rel adjust.  */
      inst.reloc.exp.X_add_number -= 8;
#endif
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }

  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  end_of_line (str);
}

static void
do_ldstt (str)
     char *        str;
{
  int conflict_reg;

  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL)
    {
      inst.error = _("address expected");
      return;
    }

  if (*str == '[')
    {
      int reg;

      str++;

      skip_whitespace (str);

      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;

      /* ldrt/strt always use post-indexed addressing, so if the base is
	 the same as Rd, we warn.  */
      if (conflict_reg == reg)
	as_warn (_("%s register same as write-back base"),
		 ((inst.instruction & LOAD_BIT)
		  ? _("destination") : _("source")));

      skip_whitespace (str);

      if (*str == ']')
	{
	  str ++;

	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend (&str) == FAIL)
		return;
	    }
	  else
	    {
	      /* [Rn]  */
	      skip_whitespace (str);

	      /* Skip a write-back '!'.  */
	      if (*str == '!')
		str++;

	      inst.instruction |= INDEX_UP;
	    }
	}
      else
	{
	  inst.error = _("post-indexed expression expected");
	  return;
	}
    }
  else
    {
      inst.error = _("post-indexed expression expected");
      return;
    }

  end_of_line (str);
}

static int
ldst_extend_v4 (str)
     char ** str;
{
  int add = INDEX_UP;

  switch (**str)
    {
    case '#':
    case '$':
      (*str)++;
      if (my_get_expression (& inst.reloc.exp, str))
	return FAIL;

      if (inst.reloc.exp.X_op == O_constant)
	{
	  int value = inst.reloc.exp.X_add_number;

	  if (value < -255 || value > 255)
	    {
	      inst.error = _("address offset too large");
	      return FAIL;
	    }

	  if (value < 0)
	    {
	      value = -value;
	      add = 0;
	    }

	  /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0.  */
	  inst.instruction |= (add | HWOFFSET_IMM
			       | ((value >> 4) << 8) | (value & 0xF));
	}
      else
	{
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	  inst.reloc.pc_rel = 0;
	}
      return SUCCESS;

    case '-':
      add = 0;
      /* Fall through.  */

    case '+':
      (*str)++;
      /* Fall through.  */

    default:
      if (reg_required_here (str, 0) == FAIL)
	return FAIL;

      inst.instruction |= add;
      return SUCCESS;
    }
}

/* Halfword and signed-byte load/store operations.  */
static void
do_ldstv4 (str)
     char *        str;
{
  int pre_inc = 0;
  int conflict_reg;
  int value;

  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL)
    {
      inst.error = _("address expected");
      return;
    }

  if (*str == '[')
    {
      int reg;

      str++;

      skip_whitespace (str);

      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;

      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);

      skip_whitespace (str);

      if (*str == ']')
	{
	  str ++;

	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend_v4 (&str) == FAIL)
		return;
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	    }
	  else
	    {
	      /* [Rn]  */
	      inst.instruction |= HWOFFSET_IMM;

	      skip_whitespace (str);

	      if (*str == '!')
		{
		  if (conflict_reg)
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		  str++;
		  inst.instruction |= WRITE_BACK;
		}

	      inst.instruction |= INDEX_UP;
	      pre_inc = 1;
	    }
	}
      else
	{
	  /* [Rn,...]  */
	  if (skip_past_comma (&str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return;
	    }

	  pre_inc = 1;
	  if (ldst_extend_v4 (&str) == FAIL)
	    return;

	  skip_whitespace (str);

	  if (*str++ != ']')
	    {
	      inst.error = _("missing ]");
	      return;
	    }

	  skip_whitespace (str);

	  if (*str == '!')
	    {
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	      str++;
	      inst.instruction |= WRITE_BACK;
	    }
	}
    }
  else if (*str == '=')
    {
      if ((inst.instruction & LOAD_BIT) == 0)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}

      /* XXX Does this work correctly for half-word/byte ops?  */
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;

      skip_whitespace (str);

      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      if (inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = _("constant expression expected");
	  return;
	}

      if (inst.reloc.exp.X_op == O_constant)
	{
	  value = validate_immediate (inst.reloc.exp.X_add_number);

	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }

	  value = validate_immediate (~ inst.reloc.exp.X_add_number);

	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
	}

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = _("literal pool insertion failed");
	  return;
	}

      /* Change the instruction exp to point to the pool.  */
      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
#ifndef TE_WINCE
      /* PC rel adjust.  */
      inst.reloc.exp.X_add_number -= 8;
#endif
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }

  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  end_of_line (str);
}

static long
reg_list (strp)
     char ** strp;
{
  char * str = * strp;
  long   range = 0;
  int    another_range;

  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
    {
      another_range = 0;

      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;

	  str++;
	  do
	    {
	      int reg;

	      skip_whitespace (str);

	      if ((reg = reg_required_here (& str, -1)) == FAIL)
		return FAIL;

	      if (in_range)
		{
		  int i;

		  if (reg <= cur_reg)
		    {
		      inst.error = _("bad range in register list");
		      return FAIL;
		    }

		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}

	      if (range & (1 << reg))
		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: register range not in ascending order"));

	      range |= 1 << reg;
	      cur_reg = reg;
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;
	  skip_whitespace (str);

	  if (*str++ != '}')
	    {
	      inst.error = _("missing `}'");
	      return FAIL;
	    }
	}
      else
	{
	  expressionS expr;

	  if (my_get_expression (&expr, &str))
	    return FAIL;

	  if (expr.X_op == O_constant)
	    {
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}

	      if ((range & expr.X_add_number) != 0)
		{
		  int regno = range & expr.X_add_number;

		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: duplicated register (r%d) in register list"),
		     regno);
		}

	      range |= expr.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}

	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
	}

      skip_whitespace (str);

      if (*str == '|' || *str == '+')
	{
	  str++;
	  another_range = 1;
	}
    }
  while (another_range);

  *strp = str;
  return range;
}

static void
do_ldmstm (str)
     char * str;
{
  int base_reg;
  long range;

  skip_whitespace (str);

  if ((base_reg = reg_required_here (&str, 16)) == FAIL)
    return;

  if (base_reg == REG_PC)
    {
      inst.error = _("r15 not allowed as base register");
      return;
    }

  skip_whitespace (str);

  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }

  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (*str == '^')
    {
      str++;
      inst.instruction |= LDM_TYPE_2_OR_3;
    }

  if (inst.instruction & WRITE_BACK)
    {
      /* Check for unpredictable uses of writeback.  */
      if (inst.instruction & LOAD_BIT)
	{
	  /* Not allowed in LDM type 2.  */
	  if ((inst.instruction & LDM_TYPE_2_OR_3)
	      && ((range & (1 << REG_PC)) == 0))
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list for other types.  */
	  else if (range & (1 << base_reg))
	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
	}
      else /* STM.  */
	{
	  /* Not allowed for type 2.  */
	  if (inst.instruction & LDM_TYPE_2_OR_3)
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list, or first in list.  */
	  else if ((range & (1 << base_reg))
		   && (range & ((1 << base_reg) - 1)))
	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
	}
    }

  inst.instruction |= range;
  end_of_line (str);
}

static void
do_swi (str)
     char * str;
{
  skip_whitespace (str);

  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str++;

  if (my_get_expression (& inst.reloc.exp, & str))
    return;

  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
  end_of_line (str);
}

static void
do_swap (str)
     char * str;
{
  int reg;

  skip_whitespace (str);

  if ((reg = reg_required_here (&str, 12)) == FAIL)
    return;

  if (reg == REG_PC)
    {
      inst.error = _("r15 not allowed in swap");
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || (reg = reg_required_here (&str, 0)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (reg == REG_PC)
    {
      inst.error = _("r15 not allowed in swap");
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || *str++ != '[')
    {
      inst.error = BAD_ARGS;
      return;
    }

  skip_whitespace (str);

  if ((reg = reg_required_here (&str, 16)) == FAIL)
    return;

  if (reg == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  skip_whitespace (str);

  if (*str++ != ']')
    {
      inst.error = _("missing ]");
      return;
    }

  end_of_line (str);
}

static void
do_branch (str)
     char * str;
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;

#ifdef OBJ_ELF
  {
    char * save_in;

    /* ScottB: February 5, 1998 - Check to see of PLT32 reloc
       required for the instruction.  */

    /* arm_parse_reloc () works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;
    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
	inst.reloc.pc_rel = 1;
      }
    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF  */

  end_of_line (str);
}

static void
do_bx (str)
     char * str;
{
  int reg;

  skip_whitespace (str);

  if ((reg = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Note - it is not illegal to do a "bx pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));

  end_of_line (str);
}

static void
do_cdp (str)
     char * str;
{
  /* Co-processor data operation.
     Format: CDP{cond} CP#,<expr>,CRd,CRn,CRm{,<expr>}  */
  skip_whitespace (str);

  if (co_proc_number (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_opc_expr (&str, 20,4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == SUCCESS)
    {
      if (cp_opc_expr (&str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  end_of_line (str);
}

static void
do_lstc (str)
     char * str;
{
  /* Co-processor register load/store.
     Format: <LDC|STC{cond}[L] CP#,CRd,<address>  */

  skip_whitespace (str);

  if (co_proc_number (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_co_reg (str)
     char * str;
{
  /* Co-processor register transfer.
     Format: <MCR|MRC>{cond} CP#,<expr1>,Rd,CRn,CRm{,<expr2>}  */

  skip_whitespace (str);

  if (co_proc_number (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_opc_expr (&str, 21, 3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == SUCCESS)
    {
      if (cp_opc_expr (&str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  end_of_line (str);
}

static void
do_fpa_ctrl (str)
     char * str;
{
  /* FP control registers.
     Format: <WFS|RFS|WFC|RFC>{cond} Rn  */

  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_fpa_ldst (str)
     char * str;
{
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_fpa_ldmstm (str)
     char * str;
{
  int num_regs;

  skip_whitespace (str);

  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
    {
      if (! inst.error)
	inst.error = _("constant expression expected");
      return;
    }

  if (inst.reloc.exp.X_op != O_constant)
    {
      inst.error = _("constant value required for number of registers");
      return;
    }

  num_regs = inst.reloc.exp.X_add_number;

  if (num_regs < 1 || num_regs > 4)
    {
      inst.error = _("number of registers must be in the range [1:4]");
      return;
    }

  switch (num_regs)
    {
    case 1:
      inst.instruction |= CP_T_X;
      break;
    case 2:
      inst.instruction |= CP_T_Y;
      break;
    case 3:
      inst.instruction |= CP_T_Y | CP_T_X;
      break;
    case 4:
      break;
    default:
      abort ();
    }

  if (inst.instruction & (CP_T_Pre | CP_T_UD)) /* ea/fd format.  */
    {
      int reg;
      int write_back;
      int offset;

      /* The instruction specified "ea" or "fd", so we can only accept
	 [Rn]{!}.  The instruction does not really support stacking or
	 unstacking, so we have to emulate these by setting appropriate
	 bits and offsets.  */
      if (skip_past_comma (&str) == FAIL
	  || *str != '[')
	{
	  if (! inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}

      str++;
      skip_whitespace (str);

      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;

      skip_whitespace (str);

      if (*str != ']')
	{
	  inst.error = BAD_ARGS;
	  return;
	}

      str++;
      if (*str == '!')
	{
	  write_back = 1;
	  str++;
	  if (reg == REG_PC)
	    {
	      inst.error =
		_("r15 not allowed as base register with write-back");
	      return;
	    }
	}
      else
	write_back = 0;

      if (inst.instruction & CP_T_Pre)
	{
	  /* Pre-decrement.  */
	  offset = 3 * num_regs;
	  if (write_back)
	    inst.instruction |= CP_T_WB;
	}
      else
	{
	  /* Post-increment.  */
	  if (write_back)
	    {
	      inst.instruction |= CP_T_WB;
	      offset = 3 * num_regs;
	    }
	  else
	    {
	      /* No write-back, so convert this into a standard pre-increment
		 instruction -- aesthetically more pleasing.  */
	      inst.instruction |= CP_T_Pre | CP_T_UD;
	      offset = 0;
	    }
	}

      inst.instruction |= offset;
    }
  else if (skip_past_comma (&str) == FAIL
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_fpa_dyadic (str)
     char * str;
{
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || fp_reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_fpa_monadic (str)
     char * str;
{
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_fpa_cmp (str)
     char * str;
{
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_fpa_from_reg (str)
     char * str;
{
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_fpa_to_reg (str)
     char * str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || fp_reg_required_here (&str, 0) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static int
vfp_sp_reg_required_here (str, pos)
     char **str;
     enum vfp_sp_reg_pos pos;
{
  int    reg;
  char *start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_SN].htab)) != FAIL)
    {
      switch (pos)
	{
	case VFP_REG_Sd:
	  inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
	  break;

	case VFP_REG_Sn:
	  inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
	  break;

	case VFP_REG_Sm:
	  inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
	  break;

	default:
	  abort ();
	}
      return reg;
    }

  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_SN].expected);

  /* Restore the start point.  */
  *str = start;
  return FAIL;
}

static int
vfp_dp_reg_required_here (str, pos)
     char **str;
     enum vfp_dp_reg_pos pos;
{
  int   reg;
  char *start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_DN].htab)) != FAIL)
    {
      switch (pos)
	{
	case VFP_REG_Dd:
	  inst.instruction |= reg << 12;
	  break;

	case VFP_REG_Dn:
	  inst.instruction |= reg << 16;
	  break;

	case VFP_REG_Dm:
	  inst.instruction |= reg << 0;
	  break;

	default:
	  abort ();
	}
      return reg;
    }

  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_DN].expected);

  /* Restore the start point.  */
  *str = start;
  return FAIL;
}

static void
do_vfp_sp_monadic (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_dp_monadic (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_sp_dyadic (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_dp_dyadic (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_reg_from_sp (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_reg2_from_sp2 (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* We require exactly two consecutive SP registers.  */
  if (vfp_sp_reg_list (&str, VFP_REG_Sm) != 2)
    {
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
    }

  end_of_line (str);
}

static void
do_vfp_sp_from_reg (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_sp2_from_reg2 (str)
     char *str;
{
  skip_whitespace (str);

  /* We require exactly two consecutive SP registers.  */
  if (vfp_sp_reg_list (&str, VFP_REG_Sm) != 2)
    {
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
    }

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_reg_from_dp (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_reg2_from_dp (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_dp_from_reg (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_dp_from_reg2 (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static const struct vfp_reg *
vfp_psr_parse (str)
     char **str;
{
  char *start = *str;
  char  c;
  char *p;
  const struct vfp_reg *vreg;

  p = start;

  /* Find the end of the current token.  */
  do
    {
      c = *p++;
    }
  while (ISALPHA (c));

  /* Mark it.  */
  *--p = 0;

  for (vreg = vfp_regs + 0;
       vreg < vfp_regs + sizeof (vfp_regs) / sizeof (struct vfp_reg);
       vreg++)
    {
      if (strcmp (start, vreg->name) == 0)
	{
	  *p = c;
	  *str = p;
	  return vreg;
	}
    }

  *p = c;
  return NULL;
}

static int
vfp_psr_required_here (str)
     char **str;
{
  char *start = *str;
  const struct vfp_reg *vreg;

  vreg = vfp_psr_parse (str);

  if (vreg)
    {
      inst.instruction |= vreg->regno;
      return SUCCESS;
    }

  inst.error = _("VFP system register expected");

  *str = start;
  return FAIL;
}

static void
do_vfp_reg_from_ctrl (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_psr_required_here (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_ctrl_from_reg (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_psr_required_here (&str) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_sp_ldst (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_dp_ldst (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

/* Parse and encode a VFP SP register list, storing the initial
   register in position POS and returning the range as the result.  If
   the string is invalid return FAIL (an invalid range).  */
static long
vfp_sp_reg_list (str, pos)
     char **str;
     enum vfp_sp_reg_pos pos;
{
  long range = 0;
  int base_reg = 0;
  int new_base;
  long base_bits = 0;
  int count = 0;
  long tempinst;
  unsigned long mask = 0;
  int warned = 0;

  if (**str != '{')
    return FAIL;

  (*str)++;
  skip_whitespace (*str);

  tempinst = inst.instruction;

  do
    {
      inst.instruction = 0;

      if ((new_base = vfp_sp_reg_required_here (str, pos)) == FAIL)
	return FAIL;

      if (count == 0 || base_reg > new_base)
	{
	  base_reg = new_base;
	  base_bits = inst.instruction;
	}

      if (mask & (1 << new_base))
	{
	  inst.error = _("invalid register list");
	  return FAIL;
	}

      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}

      mask |= 1 << new_base;
      count++;

      skip_whitespace (*str);

      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;

	  (*str)++;

	  if ((high_range
	       = arm_reg_parse (str, all_reg_maps[REG_TYPE_SN].htab))
	      == FAIL)
	    {
	      inst.error = _(all_reg_maps[REG_TYPE_SN].expected);
	      return FAIL;
	    }

	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }

	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}

	      mask |= 1 << new_base;
	      count++;
	    }
	}
    }
  while (skip_past_comma (str) != FAIL);

  if (**str != '}')
    {
      inst.error = _("invalid register list");
      return FAIL;
    }

  (*str)++;

  range = count;

  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > 32)
    abort ();

  /* Final test -- the registers must be consecutive.  */
  while (count--)
    {
      if ((mask & (1 << base_reg++)) == 0)
	{
	  inst.error = _("non-contiguous register range");
	  return FAIL;
	}
    }

  inst.instruction = tempinst | base_bits;
  return range;
}

static long
vfp_dp_reg_list (str)
     char **str;
{
  long range = 0;
  int base_reg = 0;
  int new_base;
  int count = 0;
  long tempinst;
  unsigned long mask = 0;
  int warned = 0;

  if (**str != '{')
    return FAIL;

  (*str)++;
  skip_whitespace (*str);

  tempinst = inst.instruction;

  do
    {
      inst.instruction = 0;

      if ((new_base = vfp_dp_reg_required_here (str, VFP_REG_Dd)) == FAIL)
	return FAIL;

      if (count == 0 || base_reg > new_base)
	{
	  base_reg = new_base;
	  range = inst.instruction;
	}

      if (mask & (1 << new_base))
	{
	  inst.error = _("invalid register list");
	  return FAIL;
	}

      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}

      mask |= 1 << new_base;
      count++;

      skip_whitespace (*str);

      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;

	  (*str)++;

	  if ((high_range
	       = arm_reg_parse (str, all_reg_maps[REG_TYPE_DN].htab))
	      == FAIL)
	    {
	      inst.error = _(all_reg_maps[REG_TYPE_DN].expected);
	      return FAIL;
	    }

	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }

	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}

	      mask |= 1 << new_base;
	      count++;
	    }
	}
    }
  while (skip_past_comma (str) != FAIL);

  if (**str != '}')
    {
      inst.error = _("invalid register list");
      return FAIL;
    }

  (*str)++;

  range |= 2 * count;

  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > 16)
    abort ();

  /* Final test -- the registers must be consecutive.  */
  while (count--)
    {
      if ((mask & (1 << base_reg++)) == 0)
	{
	  inst.error = _("non-contiguous register range");
	  return FAIL;
	}
    }

  inst.instruction = tempinst;
  return range;
}

static void
vfp_sp_ldstm (str, ldstm_type)
     char *str;
     enum vfp_ldstm_type ldstm_type;
{
  long range;

  skip_whitespace (str);

  if (reg_required_here (&str, 16) == FAIL)
    return;

  skip_whitespace (str);

  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  else if (ldstm_type != VFP_LDSTMIA)
    {
      inst.error = _("this addressing mode requires base-register writeback");
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || (range = vfp_sp_reg_list (&str, VFP_REG_Sd)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  inst.instruction |= range;
  end_of_line (str);
}

static void
vfp_dp_ldstm (str, ldstm_type)
     char *str;
     enum vfp_ldstm_type ldstm_type;
{
  long range;

  skip_whitespace (str);

  if (reg_required_here (&str, 16) == FAIL)
    return;

  skip_whitespace (str);

  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  else if (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX)
    {
      inst.error = _("this addressing mode requires base-register writeback");
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || (range = vfp_dp_reg_list (&str)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
    range += 1;

  inst.instruction |= range;
  end_of_line (str);
}

static void
do_vfp_sp_ldstmia (str)
     char *str;
{
  vfp_sp_ldstm (str, VFP_LDSTMIA);
}

static void
do_vfp_sp_ldstmdb (str)
     char *str;
{
  vfp_sp_ldstm (str, VFP_LDSTMDB);
}

static void
do_vfp_dp_ldstmia (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMIA);
}

static void
do_vfp_dp_ldstmdb (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMDB);
}

static void
do_vfp_xp_ldstmia (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMIAX);
}

static void
do_vfp_xp_ldstmdb (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMDBX);
}

static void
do_vfp_sp_compare_z (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_dp_compare_z (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_dp_sp_cvt (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

static void
do_vfp_sp_dp_cvt (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

/* Thumb specific routines.  */

/* Parse and validate that a register is of the right form, this saves
   repeated checking of this information in many similar cases.
   Unlike the 32-bit case we do not insert the register into the opcode
   here, since the position is often unknown until the full instruction
   has been parsed.  */

static int
thumb_reg (strp, hi_lo)
     char ** strp;
     int     hi_lo;
{
  int reg;

  if ((reg = reg_required_here (strp, -1)) == FAIL)
    return FAIL;

  switch (hi_lo)
    {
    case THUMB_REG_LO:
      if (reg > 7)
	{
	  inst.error = _("lo register required");
	  return FAIL;
	}
      break;

    case THUMB_REG_HI:
      if (reg < 8)
	{
	  inst.error = _("hi register required");
	  return FAIL;
	}
      break;

    default:
      break;
    }

  return reg;
}

/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode
   was SUB.  */

static void
thumb_add_sub (str, subtract)
     char * str;
     int    subtract;
{
  int Rd, Rs, Rn = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (is_immediate_prefix (*str))
    {
      Rs = Rd;
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;

      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
    }

  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
  if (Rn != FAIL)
    {
      /* All register format.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
	{
	  if (Rs != Rd)
	    {
	      inst.error = _("dest and source1 must be the same register");
	      return;
	    }

	  /* Can't do this for SUB.  */
	  if (subtract)
	    {
	      inst.error = _("subtract valid only on lo regs");
	      return;
	    }

	  inst.instruction = (T_OPCODE_ADD_HI
			      | (Rd > 7 ? THUMB_H1 : 0)
			      | (Rn > 7 ? THUMB_H2 : 0));
	  inst.instruction |= (Rd & 7) | ((Rn & 7) << 3);
	}
      else
	{
	  inst.instruction = subtract ? T_OPCODE_SUB_R3 : T_OPCODE_ADD_R3;
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
	}
    }
  else
    {
      /* Immediate expression, now things start to get nasty.  */

      /* First deal with HI regs, only very restricted cases allowed:
	 Adjusting SP, and using PC or SP to get an address.  */
      if ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
	  || (Rs > 7 && Rs != REG_SP && Rs != REG_PC))
	{
	  inst.error = _("invalid Hi register with immediate");
	  return;
	}

      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, all we can do is store all the fragments
	     we know about in the instruction and let the reloc hacking
	     work it all out.  */
	  inst.instruction = (subtract ? 0x8000 : 0) | (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
	}
      else
	{
	  int offset = inst.reloc.exp.X_add_number;

	  if (subtract)
	    offset = - offset;

	  if (offset < 0)
	    {
	      offset = - offset;
	      subtract = 1;

	      /* Quick check, in case offset is MIN_INT.  */
	      if (offset < 0)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	    }
	  /* Note - you cannot convert a subtract of 0 into an
	     add of 0 because the carry flag is set differently.  */
	  else if (offset > 0)
	    subtract = 0;

	  if (Rd == REG_SP)
	    {
	      if (offset & ~0x1fc)
		{
		  inst.error = _("invalid immediate value for stack adjust");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	      inst.instruction |= offset >> 2;
	    }
	  else if (Rs == REG_PC || Rs == REG_SP)
	    {
	      if (subtract
		  || (offset & ~0x3fc))
		{
		  inst.error = _("invalid immediate for address calculation");
		  return;
		}
	      inst.instruction = (Rs == REG_PC ? T_OPCODE_ADD_PC
				  : T_OPCODE_ADD_SP);
	      inst.instruction |= (Rd << 8) | (offset >> 2);
	    }
	  else if (Rs == Rd)
	    {
	      if (offset & ~0xff)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	      inst.instruction |= (Rd << 8) | offset;
	    }
	  else
	    {
	      if (offset & ~0x7)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	      inst.instruction |= Rd | (Rs << 3) | (offset << 6);
	    }
	}
    }

  end_of_line (str);
}

static void
thumb_shift (str, shift)
     char * str;
     int    shift;
{
  int Rd, Rs, Rn = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (is_immediate_prefix (*str))
    {
      /* Two operand immediate format, set Rs to Rd.  */
      Rs = Rd;
      str ++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;

      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
    }

  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */

  if (Rn != FAIL)
    {
      if (Rs != Rd)
	{
	  inst.error = _("source1 and dest must be same register");
	  return;
	}

      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_R; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_R; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_R; break;
	}

      inst.instruction |= Rd | (Rn << 3);
    }
  else
    {
      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_I; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_I; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_I; break;
	}

      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, create a dummy reloc and let reloc
	     hacking fix it up.  */
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	}
      else
	{
	  unsigned shift_value = inst.reloc.exp.X_add_number;

	  if (shift_value > 32 || (shift_value == 32 && shift == THUMB_LSL))
	    {
	      inst.error = _("invalid immediate for shift");
	      return;
	    }

	  /* Shifts of zero are handled by converting to LSL.  */
	  if (shift_value == 0)
	    inst.instruction = T_OPCODE_LSL_I;

	  /* Shifts of 32 are encoded as a shift of zero.  */
	  if (shift_value == 32)
	    shift_value = 0;

	  inst.instruction |= shift_value << 6;
	}

      inst.instruction |= Rd | (Rs << 3);
    }

  end_of_line (str);
}

static void
thumb_mov_compare (str, move)
     char * str;
     int    move;
{
  int Rd, Rs = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (move != THUMB_CPY && is_immediate_prefix (*str))
    {
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;

  if (Rs != FAIL)
    {
      if (move != THUMB_CPY && Rs < 8 && Rd < 8)
	{
	  if (move == THUMB_MOVE)
	    /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	       since a MOV instruction produces unpredictable results.  */
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;
	  inst.instruction |= Rd | (Rs << 3);
	}
      else
	{
	  if (move == THUMB_MOVE)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else if (move != THUMB_CPY)
	    inst.instruction = T_OPCODE_CMP_HR;

	  if (Rd > 7)
	    inst.instruction |= THUMB_H1;

	  if (Rs > 7)
	    inst.instruction |= THUMB_H2;

	  inst.instruction |= (Rd & 7) | ((Rs & 7) << 3);
	}
    }
  else
    {
      if (Rd > 7)
	{
	  inst.error = _("only lo regs allowed with immediate");
	  return;
	}

      if (move == THUMB_MOVE)
	inst.instruction = T_OPCODE_MOV_I8;
      else
	inst.instruction = T_OPCODE_CMP_I8;

      inst.instruction |= Rd << 8;

      if (inst.reloc.exp.X_op != O_constant)
	inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
      else
	{
	  unsigned value = inst.reloc.exp.X_add_number;

	  if (value > 255)
	    {
	      inst.error = _("invalid immediate");
	      return;
	    }

	  inst.instruction |= value;
	}
    }

  end_of_line (str);
}

static void
thumb_load_store (str, load_store, size)
     char * str;
     int    load_store;
     int    size;
{
  int Rd, Rb, Ro = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (*str == '[')
    {
      str++;
      if ((Rb = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;

      if (skip_past_comma (&str) != FAIL)
	{
	  if (is_immediate_prefix (*str))
	    {
	      str++;
	      if (my_get_expression (&inst.reloc.exp, &str))
		return;
	    }
	  else if ((Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	    return;
	}
      else
	{
	  inst.reloc.exp.X_op = O_constant;
	  inst.reloc.exp.X_add_number = 0;
	}

      if (*str != ']')
	{
	  inst.error = _("expected ']'");
	  return;
	}
      str++;
    }
  else if (*str == '=')
    {
      if (load_store != THUMB_LOAD)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}

      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;

      skip_whitespace (str);

      if (my_get_expression (& inst.reloc.exp, & str))
	return;

      end_of_line (str);

      if (   inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = "Constant expression expected";
	  return;
	}

      if (inst.reloc.exp.X_op == O_constant
	  && ((inst.reloc.exp.X_add_number & ~0xFF) == 0))
	{
	  /* This can be done with a mov instruction.  */

	  inst.instruction  = T_OPCODE_MOV_I8 | (Rd << 8);
	  inst.instruction |= inst.reloc.exp.X_add_number;
	  return;
	}

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = "literal pool insertion failed";
	  return;
	}

      inst.reloc.type   = BFD_RELOC_ARM_THUMB_OFFSET;
      inst.reloc.pc_rel = 1;
      inst.instruction  = T_OPCODE_LDR_PC | (Rd << 8);
      /* Adjust ARM pipeline offset to Thumb.  */
      inst.reloc.exp.X_add_number += 4;

      return;
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      inst.instruction = T_OPCODE_LDR_PC | (Rd << 8);
      inst.reloc.pc_rel = 1;
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset.  */
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      end_of_line (str);
      return;
    }

  if (Rb == REG_PC || Rb == REG_SP)
    {
      if (size != THUMB_WORD)
	{
	  inst.error = _("byte or halfword not valid for base register");
	  return;
	}
      else if (Rb == REG_PC && load_store != THUMB_LOAD)
	{
	  inst.error = _("r15 based store not allowed");
	  return;
	}
      else if (Ro != FAIL)
	{
	  inst.error = _("invalid base register for register offset");
	  return;
	}

      if (Rb == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (load_store == THUMB_LOAD)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;

      inst.instruction |= Rd << 8;
      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;

	  if (offset & ~0x3fc)
	    {
	      inst.error = _("invalid offset");
	      return;
	    }

	  inst.instruction |= offset >> 2;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
    }
  else if (Rb > 7)
    {
      inst.error = _("invalid base register in load/store");
      return;
    }
  else if (Ro == FAIL)
    {
      /* Immediate offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IW : T_OPCODE_STR_IW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IH : T_OPCODE_STR_IH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IB : T_OPCODE_STR_IB);

      inst.instruction |= Rd | (Rb << 3);

      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;

	  if (offset & ~(0x1f << size))
	    {
	      inst.error = _("invalid offset");
	      return;
	    }
	  inst.instruction |= (offset >> size) << 6;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
    }
  else
    {
      /* Register offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RW : T_OPCODE_STR_RW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RH : T_OPCODE_STR_RH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RB : T_OPCODE_STR_RB);

      inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
    }

  end_of_line (str);
}

/* A register must be given at this point.

   Shift is the place to put it in inst.instruction.

   Restores input start point on err.
   Returns the reg#, or FAIL.  */

static int
mav_reg_required_here (str, shift, regtype)
     char ** str;
     int shift;
     enum arm_reg_type regtype;
{
  int   reg;
  char *start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[regtype].htab)) != FAIL)
    {
      if (shift >= 0)
	inst.instruction |= reg << shift;

      return reg;
    }

  /* Restore the start point.  */
  *str = start;

  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[regtype].expected);

  return FAIL;
}

/* Cirrus Maverick Instructions.  */

/* Wrapper functions.  */

static void
do_mav_binops_1a (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVF);
}

static void
do_mav_binops_1b (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVD);
}

static void
do_mav_binops_1c (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVDX);
}

static void
do_mav_binops_1d (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVF);
}

static void
do_mav_binops_1e (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVD);
}

static void
do_mav_binops_1f (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVF);
}

static void
do_mav_binops_1g (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVD);
}

static void
do_mav_binops_1h (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVFX);
}

static void
do_mav_binops_1i (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVFX);
}

static void
do_mav_binops_1j (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVDX);
}

static void
do_mav_binops_1k (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVDX);
}

static void
do_mav_binops_1l (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVF);
}

static void
do_mav_binops_1m (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVD);
}

static void
do_mav_binops_1n (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_binops_1o (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static void
do_mav_binops_2a (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVF, REG_TYPE_RN);
}

static void
do_mav_binops_2b (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVD, REG_TYPE_RN);
}

static void
do_mav_binops_2c (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVDX, REG_TYPE_RN);
}

static void
do_mav_binops_3a (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVFX);
}

static void
do_mav_binops_3b (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVFX, REG_TYPE_MVAX);
}

static void
do_mav_binops_3c (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVDX);
}

static void
do_mav_binops_3d (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVDX, REG_TYPE_MVAX);
}

static void
do_mav_triple_4a (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_RN);
}

static void
do_mav_triple_4b (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_RN);
}

static void
do_mav_triple_5a (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVF, REG_TYPE_MVF);
}

static void
do_mav_triple_5b (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVD, REG_TYPE_MVD);
}

static void
do_mav_triple_5c (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_triple_5d (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static void
do_mav_triple_5e (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVF, REG_TYPE_MVF, REG_TYPE_MVF);
}

static void
do_mav_triple_5f (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVD, REG_TYPE_MVD, REG_TYPE_MVD);
}

static void
do_mav_triple_5g (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_triple_5h (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static void
do_mav_quad_6a (str)
     char * str;
{
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVFX, REG_TYPE_MVFX,
	     REG_TYPE_MVFX);
}

static void
do_mav_quad_6b (str)
     char * str;
{
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVAX, REG_TYPE_MVFX,
	     REG_TYPE_MVFX);
}

/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
static void
do_mav_dspsc_1 (str)
     char * str;
{
  skip_whitespace (str);

  /* cfmvsc32.  */
  if (mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;

      return;
    }

  end_of_line (str);
}

/* cfmv32sc<cond> MVDX[15:0],DSPSC.  */
static void
do_mav_dspsc_2 (str)
     char * str;
{
  skip_whitespace (str);

  /* cfmv32sc.  */
  if (mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;

      return;
    }

  end_of_line (str);
}

static void
do_mav_shift_1 (str)
     char * str;
{
  do_mav_shift (str, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_shift_2 (str)
     char * str;
{
  do_mav_shift (str, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static void
do_mav_ldst_1 (str)
     char * str;
{
  do_mav_ldst (str, REG_TYPE_MVF);
}

static void
do_mav_ldst_2 (str)
     char * str;
{
  do_mav_ldst (str, REG_TYPE_MVD);
}

static void
do_mav_ldst_3 (str)
     char * str;
{
  do_mav_ldst (str, REG_TYPE_MVFX);
}

static void
do_mav_ldst_4 (str)
     char * str;
{
  do_mav_ldst (str, REG_TYPE_MVDX);
}

/* Isnsn like "foo X,Y".  */

static void
do_mav_binops (str, mode, reg0, reg1)
     char * str;
     int mode;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
{
  int shift0, shift1;

  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}

/* Isnsn like "foo X,Y,Z".  */

static void
do_mav_triple (str, mode, reg0, reg1, reg2)
     char * str;
     int mode;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
     enum arm_reg_type reg2;
{
  int shift0, shift1, shift2;

  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}

/* Isnsn like "foo W,X,Y,Z".
    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */

static void
do_mav_quad (str, mode, reg0, reg1, reg2, reg3)
     char * str;
     int mode;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
     enum arm_reg_type reg2;
     enum arm_reg_type reg3;
{
  int shift0, shift1, shift2, shift3;

  shift0= mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;
  shift3 = (mode >> 24) & 0xff;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift3, reg3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}

/* Maverick shift immediate instructions.
   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */

static void
do_mav_shift (str, reg0, reg1)
     char * str;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
{
  int error;
  int imm, neg = 0;

  skip_whitespace (str);

  error = 0;

  if (mav_reg_required_here (&str, 12, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, 16, reg1) == FAIL
      || skip_past_comma  (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* Calculate the immediate operand.
     The operand is a 7bit signed number.  */
  skip_whitespace (str);

  if (*str == '#')
    ++str;

  if (!ISDIGIT (*str) && *str != '-')
    {
      inst.error = _("expecting immediate, 7bit operand");
      return;
    }

  if (*str == '-')
    {
      neg = 1;
      ++str;
    }

  for (imm = 0; *str && ISDIGIT (*str); ++str)
    imm = imm * 10 + *str - '0';

  if (imm > 64)
    {
      inst.error = _("immediate out of range");
      return;
    }

  /* Make negative imm's into 7bit signed numbers.  */
  if (neg)
    {
      imm = -imm;
      imm &= 0x0000007f;
    }

  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
     Bits 5-7 of the insn should have bits 4-6 of the immediate.
     Bit 4 should be 0.  */
  imm = (imm & 0xf) | ((imm & 0x70) << 1);

  inst.instruction |= imm;
  end_of_line (str);
}

static int
mav_parse_offset (str, negative)
     char ** str;
     int *negative;
{
  char * p = *str;
  int offset;

  *negative = 0;

  skip_whitespace (p);

  if (*p == '#')
    ++p;

  if (*p == '-')
    {
      *negative = 1;
      ++p;
    }

  if (!ISDIGIT (*p))
    {
      inst.error = _("offset expected");
      return 0;
    }

  for (offset = 0; *p && ISDIGIT (*p); ++p)
    offset = offset * 10 + *p - '0';

  if (offset > 0xff)
    {
      inst.error = _("offset out of range");
      return 0;
    }

  *str = p;

  return *negative ? -offset : offset;
}

/* Maverick load/store instructions.
  <insn><cond> CRd,[Rn,<offset>]{!}.
  <insn><cond> CRd,[Rn],<offset>.  */

static void
do_mav_ldst (str, reg0)
     char * str;
     enum arm_reg_type reg0;
{
  int offset, negative;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, 12, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || reg_required_here (&str, 16) == FAIL)
    goto fail_ldst;

  if (skip_past_comma (&str) == SUCCESS)
    {
      /* You are here: "<offset>]{!}".  */
      inst.instruction |= PRE_INDEX;

      offset = mav_parse_offset (&str, &negative);

      if (inst.error)
	return;

      if (*str++ != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}

      if (*str == '!')
	{
	  inst.instruction |= WRITE_BACK;
	  ++str;
	}
    }
  else
    {
      /* You are here: "], <offset>".  */
      if (*str++ != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}

      if (skip_past_comma (&str) == FAIL
	  || (offset = mav_parse_offset (&str, &negative), inst.error))
	goto fail_ldst;

      inst.instruction |= CP_T_WB; /* Post indexed, set bit W.  */
    }

  if (negative)
    offset = -offset;
  else
    inst.instruction |= CP_T_UD; /* Positive, so set bit U.  */

  inst.instruction |= offset >> 2;
  end_of_line (str);
  return;

fail_ldst:
  if (!inst.error)
     inst.error = BAD_ARGS;
}

static void
do_t_nop (str)
     char * str;
{
  /* Do nothing.  */
  end_of_line (str);
}

/* Handle the Format 4 instructions that do not have equivalents in other
   formats.  That is, ADC, AND, EOR, SBC, ROR, TST, NEG, CMN, ORR, MUL,
   BIC and MVN.  */

static void
do_t_arit (str)
     char * str;
{
  int Rd, Rs, Rn;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) != FAIL)
    {
      /* Three operand format not allowed for TST, CMN, NEG and MVN.
	 (It isn't allowed for CMP either, but that isn't handled by this
	 function.)  */
      if (inst.instruction == T_OPCODE_TST
	  || inst.instruction == T_OPCODE_CMN
	  || inst.instruction == T_OPCODE_NEG
	  || inst.instruction == T_OPCODE_MVN)
	{
	  inst.error = BAD_ARGS;
	  return;
	}

      if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;

      if (Rs != Rd)
	{
	  inst.error = _("dest and source1 must be the same register");
	  return;
	}
      Rs = Rn;
    }

  if (inst.instruction == T_OPCODE_MUL
      && Rs == Rd)
    as_tsktsk (_("Rs and Rd must be different in MUL"));

  inst.instruction |= Rd | (Rs << 3);
  end_of_line (str);
}

static void
do_t_add (str)
     char * str;
{
  thumb_add_sub (str, 0);
}

static void
do_t_asr (str)
     char * str;
{
  thumb_shift (str, THUMB_ASR);
}

static void
do_t_branch9 (str)
     char * str;
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH9;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}

static void
do_t_branch12 (str)
     char * str;
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH12;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}

/* Find the real, Thumb encoded start of a Thumb function.  */

static symbolS *
find_real_start (symbolP)
     symbolS * symbolP;
{
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;

  /* This definition must agree with the one in gcc/config/arm/thumb.c.  */
#define STUB_NAME ".real_start_of"

  if (name == NULL)
    abort ();

  /* Names that start with '.' are local labels, not function entry points.
     The compiler may generate BL instructions to these labels because it
     needs to perform a branch to a far away location.  */
  if (name[0] == '.')
    return symbolP;

  real_start = malloc (strlen (name) + strlen (STUB_NAME) + 1);
  sprintf (real_start, "%s%s", STUB_NAME, name);

  new_target = symbol_find (real_start);

  if (new_target == NULL)
    {
      as_warn ("Failed to find real start of function: %s\n", name);
      new_target = symbolP;
    }

  free (real_start);

  return new_target;
}

static void
do_t_branch23 (str)
     char * str;
{
  if (my_get_expression (& inst.reloc.exp, & str))
    return;

  inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
  inst.reloc.pc_rel = 1;
  end_of_line (str);

  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.  */
  if (   inst.reloc.exp.X_op == O_symbol
      && inst.reloc.exp.X_add_symbol != NULL
      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
    inst.reloc.exp.X_add_symbol =
      find_real_start (inst.reloc.exp.X_add_symbol);
}

static void
do_t_bx (str)
     char * str;
{
  int reg;

  skip_whitespace (str);

  if ((reg = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;

  /* This sets THUMB_H2 from the top bit of reg.  */
  inst.instruction |= reg << 3;

  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.  The reloc
     should cause the alignment to be checked once it is known.  This is
     because BX PC only works if the instruction is word aligned.  */

  end_of_line (str);
}

static void
do_t_compare (str)
     char * str;
{
  thumb_mov_compare (str, THUMB_COMPARE);
}

static void
do_t_ldmstm (str)
     char * str;
{
  int Rb;
  long range;

  skip_whitespace (str);

  if ((Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    return;

  if (*str != '!')
    as_warn (_("inserted missing '!': load/store multiple always writes back base register"));
  else
    str++;

  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (inst.reloc.type != BFD_RELOC_NONE)
    {
      /* This really doesn't seem worth it.  */
      inst.reloc.type = BFD_RELOC_NONE;
      inst.error = _("expression too complex");
      return;
    }

  if (range & ~0xff)
    {
      inst.error = _("only lo-regs valid in load/store multiple");
      return;
    }

  inst.instruction |= (Rb << 8) | range;
  end_of_line (str);
}

static void
do_t_ldr (str)
     char * str;
{
  thumb_load_store (str, THUMB_LOAD, THUMB_WORD);
}

static void
do_t_ldrb (str)
     char * str;
{
  thumb_load_store (str, THUMB_LOAD, THUMB_BYTE);
}

static void
do_t_ldrh (str)
     char * str;
{
  thumb_load_store (str, THUMB_LOAD, THUMB_HALFWORD);
}

static void
do_t_lds (str)
     char * str;
{
  int Rd, Rb, Ro;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || (Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || *str++ != ']')
    {
      if (! inst.error)
	inst.error = _("syntax: ldrs[b] Rd, [Rb, Ro]");
      return;
    }

  inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
  end_of_line (str);
}

static void
do_t_lsl (str)
     char * str;
{
  thumb_shift (str, THUMB_LSL);
}

static void
do_t_lsr (str)
     char * str;
{
  thumb_shift (str, THUMB_LSR);
}

static void
do_t_mov (str)
     char * str;
{
  thumb_mov_compare (str, THUMB_MOVE);
}

static void
do_t_push_pop (str)
     char * str;
{
  long range;

  skip_whitespace (str);

  if ((range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (inst.reloc.type != BFD_RELOC_NONE)
    {
      /* This really doesn't seem worth it.  */
      inst.reloc.type = BFD_RELOC_NONE;
      inst.error = _("expression too complex");
      return;
    }

  if (range & ~0xff)
    {
      if ((inst.instruction == T_OPCODE_PUSH
	   && (range & ~0xff) == 1 << REG_LR)
	  || (inst.instruction == T_OPCODE_POP
	      && (range & ~0xff) == 1 << REG_PC))
	{
	  inst.instruction |= THUMB_PP_PC_LR;
	  range &= 0xff;
	}
      else
	{
	  inst.error = _("invalid register list to push/pop instruction");
	  return;
	}
    }

  inst.instruction |= range;
  end_of_line (str);
}

static void
do_t_str (str)
     char * str;
{
  thumb_load_store (str, THUMB_STORE, THUMB_WORD);
}

static void
do_t_strb (str)
     char * str;
{
  thumb_load_store (str, THUMB_STORE, THUMB_BYTE);
}

static void
do_t_strh (str)
     char * str;
{
  thumb_load_store (str, THUMB_STORE, THUMB_HALFWORD);
}

static void
do_t_sub (str)
     char * str;
{
  thumb_add_sub (str, 1);
}

static void
do_t_swi (str)
     char * str;
{
  skip_whitespace (str);

  if (my_get_expression (&inst.reloc.exp, &str))
    return;

  inst.reloc.type = BFD_RELOC_ARM_SWI;
  end_of_line (str);
}

static void
do_t_adr (str)
     char * str;
{
  int reg;

  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-4".  */
  skip_whitespace (str);

  /* Store Rd in temporary location inside instruction.  */
  if ((reg = reg_required_here (&str, 4)) == FAIL
      || (reg > 7)  /* For Thumb reg must be r0..r7.  */
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
  inst.reloc.pc_rel = 1;
  inst.instruction |= REG_PC; /* Rd is already placed into the instruction.  */

  end_of_line (str);
}

static void
insert_reg (r, htab)
     const struct reg_entry *r;
     struct hash_control *htab;
{
  int    len  = strlen (r->name) + 2;
  char * buf  = (char *) xmalloc (len);
  char * buf2 = (char *) xmalloc (len);
  int    i    = 0;

#ifdef REGISTER_PREFIX
  buf[i++] = REGISTER_PREFIX;
#endif

  strcpy (buf + i, r->name);

  for (i = 0; buf[i]; i++)
    buf2[i] = TOUPPER (buf[i]);

  buf2[i] = '\0';

  hash_insert (htab, buf,  (PTR) r);
  hash_insert (htab, buf2, (PTR) r);
}

static void
build_reg_hsh (map)
     struct reg_map *map;
{
  const struct reg_entry *r;

  if ((map->htab = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  for (r = map->names; r->name != NULL; r++)
    insert_reg (r, map->htab);
}

static void
insert_reg_alias (str, regnum, htab)
     char *str;
     int regnum;
     struct hash_control *htab;
{
  const char *error;
  struct reg_entry *new = xmalloc (sizeof (struct reg_entry));
  const char *name = xmalloc (strlen (str) + 1);
  
  strcpy ((char *) name, str);
  
  new->name = name;
  new->number = regnum;
  new->builtin = FALSE;

  error = hash_insert (htab, name, (PTR) new);
  if (error)
    {
      as_bad (_("failed to create an alias for %s, reason: %s"),
	    str, error);
      free ((char *) name);
      free (new);
    }
}

/* Look for the .req directive.  This is of the form:

   	new_register_name .req existing_register_name

   If we find one, or if it looks sufficiently like one that we want to
   handle any error here, return non-zero.  Otherwise return zero.  */
static int
create_register_alias (newname, p)
     char *newname;
     char *p;
{
  char *q;
  char c;

  q = p;
  skip_whitespace (q);

  c = *p;
  *p = '\0';

  if (*q && !strncmp (q, ".req ", 5))
    {
      char *copy_of_str;
      char *r;

#ifdef IGNORE_OPCODE_CASE
      newname = original_case_string;
#endif
      copy_of_str = newname;

      q += 4;
      skip_whitespace (q);

      for (r = q; *r != '\0'; r++)
	if (*r == ' ')
	  break;

      if (r != q)
	{
	  enum arm_reg_type new_type, old_type;
	  int old_regno;
	  char d = *r;

	  *r = '\0';
	  old_type = arm_reg_parse_any (q);
	  *r = d;

	  new_type = arm_reg_parse_any (newname);

	  if (new_type == REG_TYPE_MAX)
	    {
	      if (old_type != REG_TYPE_MAX)
		{
		  old_regno = arm_reg_parse (&q, all_reg_maps[old_type].htab);
		  insert_reg_alias (newname, old_regno,
				    all_reg_maps[old_type].htab);
		}
	      else
		as_warn (_("register '%s' does not exist\n"), q);
	    }
	  else if (old_type == REG_TYPE_MAX)
	    {
	      as_warn (_("ignoring redefinition of register alias '%s' to non-existant register '%s'"),
		       copy_of_str, q);
	    }
	  else
	    {
	      /* Do not warn about redefinitions to the same alias.  */
	      if (new_type != old_type
		  || (arm_reg_parse (&q, all_reg_maps[old_type].htab)
		      != arm_reg_parse (&q, all_reg_maps[new_type].htab)))
		as_warn (_("ignoring redefinition of register alias '%s'"),
			 copy_of_str);

	    }
	}
      else
	as_warn (_("ignoring incomplete .req pseuso op"));

      *p = c;
      return 1;
    }
  
  *p = c;
  return 0;
}

static void
set_constant_flonums ()
{
  int i;

  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
}

/* Iterate over the base tables to create the instruction patterns.  */
static void
build_arm_ops_hsh ()
{
  unsigned int i;
  unsigned int j;
  static struct obstack insn_obstack;

  obstack_begin (&insn_obstack, 4000);

  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    {
      const struct asm_opcode *insn = insns + i;

      if (insn->cond_offset != 0)
	{
	  /* Insn supports conditional execution.  Build the varaints
	     and insert them in the hash table.  */
	  for (j = 0; j < sizeof (conds) / sizeof (struct asm_cond); j++)
	    {
	      unsigned len = strlen (insn->template);
	      struct asm_opcode *new;
	      char *template;

	      new = obstack_alloc (&insn_obstack, sizeof (struct asm_opcode));
	      /* All condition codes are two characters.  */
	      template = obstack_alloc (&insn_obstack, len + 3);

	      strncpy (template, insn->template, insn->cond_offset);
	      strcpy (template + insn->cond_offset, conds[j].template);
	      if (len > insn->cond_offset)
		strcpy (template + insn->cond_offset + 2,
			insn->template + insn->cond_offset);
	      new->template = template;
	      new->cond_offset = 0;
	      new->variant = insn->variant;
	      new->parms = insn->parms;
	      new->value = (insn->value & ~COND_MASK) | conds[j].value;

	      hash_insert (arm_ops_hsh, new->template, (PTR) new);
	    }
	}
      /* Finally, insert the unconditional insn in the table directly;
	 no need to build a copy.  */
      hash_insert (arm_ops_hsh, insn->template, (PTR) insn);
    }
}

#if 0 /* Suppressed - for now.  */
#if defined OBJ_ELF || defined OBJ_COFF

#ifdef OBJ_ELF
#define arm_Note Elf_External_Note
#else
typedef struct
{
  unsigned char	namesz[4];	/* Size of entry's owner string.  */
  unsigned char	descsz[4];	/* Size of the note descriptor.  */
  unsigned char	type[4];	/* Interpretation of the descriptor.  */
  char		name[1];	/* Start of the name+desc data.  */
} arm_Note;
#endif

/* The description is kept to a fix sized in order to make updating
   it and merging it easier.  */
#define ARM_NOTE_DESCRIPTION_LENGTH	8

static void
arm_add_note (name, description, type)
     const char * name;
     const char * description;
     unsigned int type;
{
  arm_Note     note ATTRIBUTE_UNUSED;
  char *       p;
  unsigned int name_len;

  name_len = (strlen (name) + 1 + 3) & ~3;
  
  p = frag_more (sizeof (note.namesz));
  md_number_to_chars (p, (valueT) name_len, sizeof (note.namesz));

  p = frag_more (sizeof (note.descsz));
  md_number_to_chars (p, (valueT) ARM_NOTE_DESCRIPTION_LENGTH, sizeof (note.descsz));

  p = frag_more (sizeof (note.type));
  md_number_to_chars (p, (valueT) type, sizeof (note.type));

  p = frag_more (name_len);
  strcpy (p, name);

  p = frag_more (ARM_NOTE_DESCRIPTION_LENGTH);
  strncpy (p, description, ARM_NOTE_DESCRIPTION_LENGTH);
  frag_align (2, 0, 0);
}
#endif
#endif

void
md_begin ()
{
  unsigned mach;
  unsigned int i;

  if (   (arm_ops_hsh = hash_new ()) == NULL
      || (arm_tops_hsh = hash_new ()) == NULL
      || (arm_cond_hsh = hash_new ()) == NULL
      || (arm_shift_hsh = hash_new ()) == NULL
      || (arm_psr_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  build_arm_ops_hsh ();
  for (i = 0; i < sizeof (tinsns) / sizeof (struct thumb_opcode); i++)
    hash_insert (arm_tops_hsh, tinsns[i].template, (PTR) (tinsns + i));
  for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)
    hash_insert (arm_cond_hsh, conds[i].template, (PTR) (conds + i));
  for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
    hash_insert (arm_shift_hsh, shift_names[i].name, (PTR) (shift_names + i));
  for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)
    hash_insert (arm_psr_hsh, psrs[i].template, (PTR) (psrs + i));

  for (i = (int) REG_TYPE_FIRST; i < (int) REG_TYPE_MAX; i++)
    build_reg_hsh (all_reg_maps + i);

  set_constant_flonums ();

  /* Set the cpu variant based on the command-line options.  We prefer
     -mcpu= over -march= if both are set (as for GCC); and we prefer
     -mfpu= over any other way of setting the floating point unit.
     Use of legacy options with new options are faulted.  */
  if (legacy_cpu != -1)
    {
      if (mcpu_cpu_opt != -1 || march_cpu_opt != -1)
	as_bad (_("use of old and new-style options to set CPU type"));

      mcpu_cpu_opt = legacy_cpu;
    }
  else if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = march_cpu_opt;

  if (legacy_fpu != -1)
    {
      if (mfpu_opt != -1)
	as_bad (_("use of old and new-style options to set FPU type"));

      mfpu_opt = legacy_fpu;
    }
  else if (mfpu_opt == -1)
    {
#if !(defined (TE_LINUX) || defined (TE_NetBSD) || defined(TE_OpenBSD))
      /* Some environments specify a default FPU.  If they don't, infer it
	 from the processor.  */
      if (mcpu_fpu_opt != -1)
	mfpu_opt = mcpu_fpu_opt;
      else
	mfpu_opt = march_fpu_opt;
#else
      mfpu_opt = FPU_DEFAULT;
#endif
    }

  if (mfpu_opt == -1)
    {
      if (mcpu_cpu_opt == -1)
	mfpu_opt = FPU_DEFAULT;
      else if (mcpu_cpu_opt & ARM_EXT_V5)
	mfpu_opt = FPU_ARCH_VFP_V2;
      else
	mfpu_opt = FPU_ARCH_FPA;
    }

  if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = CPU_DEFAULT;

  cpu_variant = mcpu_cpu_opt | mfpu_opt;

#if defined OBJ_COFF || defined OBJ_ELF
  {
    unsigned int flags = 0;

    /* Set the flags in the private structure.  */
    if (uses_apcs_26)      flags |= F_APCS26;
    if (support_interwork) flags |= F_INTERWORK;
    if (uses_apcs_float)   flags |= F_APCS_FLOAT;
    if (pic_code)          flags |= F_PIC;
    if ((cpu_variant & FPU_ANY) == FPU_NONE
	 || (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
      {
	flags |= F_SOFT_FLOAT;
      }
    switch (mfloat_abi_opt)
      {
      case ARM_FLOAT_ABI_SOFT:
      case ARM_FLOAT_ABI_SOFTFP:
	flags |= F_SOFT_FLOAT;
	break;

      case ARM_FLOAT_ABI_HARD:
	if (flags & F_SOFT_FLOAT)
	  as_bad (_("hard-float conflicts with specified fpu"));
	break;
      }
    /* Using VFP conventions (even if soft-float).  */
    if (cpu_variant & FPU_VFP_EXT_NONE) flags |= F_VFP_FLOAT;

#if defined OBJ_ELF
    if (cpu_variant & FPU_ARCH_MAVERICK)
	flags |= EF_ARM_MAVERICK_FLOAT;
#endif

    bfd_set_private_flags (stdoutput, flags);

    /* We have run out flags in the COFF header to encode the
       status of ATPCS support, so instead we create a dummy,
       empty, debug section called .arm.atpcs.  */
    if (atpcs)
      {
	asection * sec;

	sec = bfd_make_section (stdoutput, ".arm.atpcs");

	if (sec != NULL)
	  {
	    bfd_set_section_flags
	      (stdoutput, sec, SEC_READONLY | SEC_DEBUGGING /* | SEC_HAS_CONTENTS */);
	    bfd_set_section_size (stdoutput, sec, 0);
	    bfd_set_section_contents (stdoutput, sec, NULL, 0, 0);
	  }
      }
  }
#endif

  /* Record the CPU type as well.  */
  switch (cpu_variant & ARM_CPU_MASK)
    {
    case ARM_2:
      mach = bfd_mach_arm_2;
      break;

    case ARM_3: 		/* Also ARM_250.  */
      mach = bfd_mach_arm_2a;
      break;

    case ARM_6:			/* Also ARM_7.  */
      mach = bfd_mach_arm_3;
      break;

    default:
      mach = bfd_mach_arm_unknown;
      break;
    }

  /* Catch special cases.  */
  if (cpu_variant & ARM_CEXT_IWMMXT)
    mach = bfd_mach_arm_iWMMXt;
  else if (cpu_variant & ARM_CEXT_XSCALE)
    mach = bfd_mach_arm_XScale;
  else if (cpu_variant & ARM_CEXT_MAVERICK)
    mach = bfd_mach_arm_ep9312;
  else if (cpu_variant & ARM_EXT_V5E)
    mach = bfd_mach_arm_5TE;
  else if (cpu_variant & ARM_EXT_V5)
    {
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_5T;
      else
	mach = bfd_mach_arm_5;
    }
  else if (cpu_variant & ARM_EXT_V4)
    {
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_4T;
      else
	mach = bfd_mach_arm_4;
    }
  else if (cpu_variant & ARM_EXT_V3M)
    mach = bfd_mach_arm_3M;

#if 0 /* Suppressed - for now.  */
#if defined (OBJ_ELF) || defined (OBJ_COFF)

  /* Create a .note section to fully identify this arm binary.  */

#define NOTE_ARCH_STRING 	"arch: "

#if defined OBJ_COFF && ! defined NT_VERSION
#define NT_VERSION  1
#define NT_ARCH     2
#endif
  
  {
    segT current_seg = now_seg;
    subsegT current_subseg = now_subseg;
    asection * arm_arch;
    const char * arch_string;

    arm_arch = bfd_make_section_old_way (stdoutput, ARM_NOTE_SECTION);

#ifdef OBJ_COFF
    bfd_set_section_flags (stdoutput, arm_arch,
			   SEC_DATA | SEC_ALLOC | SEC_LOAD | SEC_LINK_ONCE \
			   | SEC_HAS_CONTENTS);
#else
    bfd_set_section_flags (stdoutput, arm_arch,
			   SEC_READONLY | SEC_HAS_CONTENTS);
#endif
    arm_arch->output_section = arm_arch;
    subseg_set (arm_arch, 0);

    switch (mach)
      {
      default:
      case bfd_mach_arm_unknown: arch_string = "unknown"; break;
      case bfd_mach_arm_2:       arch_string = "armv2"; break;
      case bfd_mach_arm_2a:      arch_string = "armv2a"; break;
      case bfd_mach_arm_3:       arch_string = "armv3"; break;
      case bfd_mach_arm_3M:      arch_string = "armv3M"; break;
      case bfd_mach_arm_4:       arch_string = "armv4"; break;
      case bfd_mach_arm_4T:      arch_string = "armv4t"; break;
      case bfd_mach_arm_5:       arch_string = "armv5"; break;
      case bfd_mach_arm_5T:      arch_string = "armv5t"; break;
      case bfd_mach_arm_5TE:     arch_string = "armv5te"; break;
      case bfd_mach_arm_XScale:  arch_string = "XScale"; break;
      case bfd_mach_arm_ep9312:  arch_string = "ep9312"; break;
      case bfd_mach_arm_iWMMXt:  arch_string = "iWMMXt"; break;	
      }

    arm_add_note (NOTE_ARCH_STRING, arch_string, NT_ARCH);

    subseg_set (current_seg, current_subseg);
  }
#endif
#endif /* Suppressed code.  */
  
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach);
}

/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least).  */

void
md_number_to_chars (buf, val, n)
     char * buf;
     valueT val;
     int    n;
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

static valueT
md_chars_to_number (buf, n)
     char * buf;
     int    n;
{
  valueT result = 0;
  unsigned char * where = (unsigned char *) buf;

  if (target_big_endian)
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (*where++ & 255);
	}
    }
  else
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (where[n] & 255);
	}
    }

  return result;
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.

   Note that fp constants aren't represent in the normal way on the ARM.
   In big endian mode, things are as expected.  However, in little endian
   mode fp constants are big-endian word-wise, and little-endian byte-wise
   within the words.  For example, (double) 1.1 in big endian mode is
   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
   the byte sequence 99 99 f1 3f 9a 99 99 99.

   ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */

char *
md_atof (type, litP, sizeP)
     char   type;
     char * litP;
     int *  sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * 2;

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      if (cpu_variant & FPU_ARCH_VFP)
	for (i = prec - 1; i >= 0; i--)
	  {
	    md_number_to_chars (litP, (valueT) words[i], 2);
	    litP += 2;
	  }
      else
	/* For a 4 byte float the order of elements in `words' is 1 0.
	   For an 8 byte float the order is 1 0 3 2.  */
	for (i = 0; i < prec; i += 2)
	  {
	    md_number_to_chars (litP, (valueT) words[i + 1], 2);
	    md_number_to_chars (litP + 2, (valueT) words[i], 2);
	    litP += 4;
	  }
    }

  return 0;
}

/* The knowledge of the PC's pipeline offset is built into the insns
   themselves.  */

long
md_pcrel_from (fixP)
     fixS * fixP;
{
  if (fixP->fx_addsy
      && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section
      && fixP->fx_subsy == NULL)
    return 0;

  if (fixP->fx_pcrel && (fixP->fx_r_type == BFD_RELOC_ARM_THUMB_ADD))
    {
      /* PC relative addressing on the Thumb is slightly odd
	 as the bottom two bits of the PC are forced to zero
	 for the calculation.  */
      return (fixP->fx_where + fixP->fx_frag->fr_address) & ~3;
    }

#ifdef TE_WINCE
  /* The pattern was adjusted to accommodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accommodation.  */
  return fixP->fx_where + fixP->fx_frag->fr_address + 8;
#else
  return fixP->fx_where + fixP->fx_frag->fr_address;
#endif
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segment, size)
     segT   segment ATTRIBUTE_UNUSED;
     valueT size;
{
#ifdef OBJ_ELF
  return size;
#else
  /* Round all sects to multiple of 4.  */
  return (size + 3) & ~3;
#endif
}

/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
   Otherwise we have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (name)
     char * name ATTRIBUTE_UNUSED;
{
#ifdef OBJ_ELF
  if (name[0] == '_' && name[1] == 'G'
      && streq (name, GLOBAL_OFFSET_TABLE_NAME))
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");

	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, & zero_address_frag);
	}

      return GOT_symbol;
    }
#endif

  return 0;
}

/* arm_reg_parse () := if it looks like a register, return its token and
   advance the pointer.  */

static int
arm_reg_parse (ccp, htab)
     register char ** ccp;
     struct hash_control *htab;
{
  char * start = * ccp;
  char   c;
  char * p;
  struct reg_entry * reg;

#ifdef REGISTER_PREFIX
  if (*start != REGISTER_PREFIX)
    return FAIL;
  p = start + 1;
#else
  p = start;
#ifdef OPTIONAL_REGISTER_PREFIX
  if (*p == OPTIONAL_REGISTER_PREFIX)
    p++, start++;
#endif
#endif
  if (!ISALPHA (*p) || !is_name_beginner (*p))
    return FAIL;

  c = *p++;
  while (ISALPHA (c) || ISDIGIT (c) || c == '_')
    c = *p++;

  *--p = 0;
  reg = (struct reg_entry *) hash_find (htab, start);
  *p = c;

  if (reg)
    {
      *ccp = p;
      return reg->number;
    }

  return FAIL;
}

/* Search for the following register name in each of the possible reg name
   tables.  Return the classification if found, or REG_TYPE_MAX if not
   present.  */
static enum arm_reg_type
arm_reg_parse_any (cp)
     char *cp;
{
  int i;

  for (i = (int) REG_TYPE_FIRST; i < (int) REG_TYPE_MAX; i++)
    if (arm_reg_parse (&cp, all_reg_maps[i].htab) != FAIL)
      return (enum arm_reg_type) i;

  return REG_TYPE_MAX;
}

void
md_apply_fix3 (fixP, valP, seg)
     fixS *   fixP;
     valueT * valP;
     segT     seg;
{
  offsetT        value = * valP;
  offsetT        newval;
  unsigned int   newimm;
  unsigned long  temp;
  int            sign;
  char *         buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  arm_fix_data * arm_data = (arm_fix_data *) fixP->tc_fix_data;

  assert (fixP->fx_r_type < BFD_RELOC_UNUSED);

  /* Note whether this will delete the relocation.  */
#if 0
  /* Patch from REarnshaw to JDavis (disabled for the moment, since it
     doesn't work fully.)  */
  if ((fixP->fx_addsy == 0 || symbol_constant_p (fixP->fx_addsy))
      && !fixP->fx_pcrel)
#else
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
#endif
    fixP->fx_done = 1;

  /* If this symbol is in a different section then we need to leave it for
     the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
     so we have to undo it's effects here.  */
  if (fixP->fx_pcrel)
    {
      if (fixP->fx_addsy != NULL
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	{
	  if (target_oabi
	      && (fixP->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
		  || fixP->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
		  ))
	    value = 0;
	  else
	    value += md_pcrel_from (fixP);
	}
    }

  /* Remember value for emit_reloc.  */
  fixP->fx_addnumber = value;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_ARM_IMMEDIATE:
      newimm = validate_immediate (value);
      temp = md_chars_to_number (buf, INSN_SIZE);

      /* If the instruction will fail, see if we can fix things up by
	 changing the opcode.  */
      if (newimm == (unsigned int) FAIL
	  && (newimm = negate_data_op (&temp, value)) == (unsigned int) FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
	}

      newimm |= (temp & 0xfffff000);
      md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
      fixP->fx_done = 1;
      break;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      {
	unsigned int highpart = 0;
	unsigned int newinsn  = 0xe1a00000; /* nop.  */

	newimm = validate_immediate (value);
	temp = md_chars_to_number (buf, INSN_SIZE);

	/* If the instruction will fail, see if we can fix things up by
	   changing the opcode.  */
	if (newimm == (unsigned int) FAIL
	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
	  {
	    /* No ?  OK - try using two ADD instructions to generate
               the value.  */
	    newimm = validate_immediate_twopart (value, & highpart);

	    /* Yes - then make sure that the second instruction is
               also an add.  */
	    if (newimm != (unsigned int) FAIL)
	      newinsn = temp;
	    /* Still No ?  Try using a negated value.  */
	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
	      temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
	    /* Otherwise - give up.  */
	    else
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("unable to compute ADRL instructions for PC offset of 0x%lx"),
			      (long) value);
		break;
	      }

	    /* Replace the first operand in the 2nd instruction (which
	       is the PC) with the destination register.  We have
	       already added in the PC in the first instruction and we
	       do not want to do it again.  */
	    newinsn &= ~ 0xf0000;
	    newinsn |= ((newinsn & 0x0f000) << 4);
	  }

	newimm |= (temp & 0xfffff000);
	md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);

	highpart |= (newinsn & 0xfffff000);
	md_number_to_chars (buf + INSN_SIZE, (valueT) highpart, INSN_SIZE);
      }
      break;

    case BFD_RELOC_ARM_OFFSET_IMM:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 0) == FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("bad immediate value for offset (%ld)"),
			(long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 1) == FAIL)
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad (_("bad immediate value for half-word offset (%ld)"),
		    (long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff0f0;
      newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_LITERAL:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 0) == FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid literal constant: pool needs to be closer"));
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SHIFT_IMM:
      newval = md_chars_to_number (buf, INSN_SIZE);
      if (((unsigned long) value) > 32
	  || (value == 32
	      && (((newval & 0x60) == 0) || (newval & 0x60) == 0x60)))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("shift expression is too large"));
	  break;
	}

      if (value == 0)
	/* Shifts of zero must be done as lsl.  */
	newval &= ~0x60;
      else if (value == 32)
	value = 0;
      newval &= 0xfffff07f;
      newval |= (value & 0x1f) << 7;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SWI:
      if (arm_data->thumb_mode)
	{
	  if (((unsigned long) value) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, THUMB_SIZE) & 0xff00;
	  newval |= value;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      else
	{
	  if (((unsigned long) value) > 0x00ffffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, INSN_SIZE) & 0xff000000;
	  newval |= value;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;

    case BFD_RELOC_ARM_MULTI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid expression in load/store multiple"));
      newval = value | md_chars_to_number (buf, INSN_SIZE);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_PCREL_BRANCH:
      newval = md_chars_to_number (buf, INSN_SIZE);

      /* Sign-extend a 24-bit number.  */
#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)

#ifdef OBJ_ELF
      if (! target_oabi)
	value = fixP->fx_offset;
#endif

      /* We are going to store value (shifted right by two) in the
	 instruction, in a 24 bit, signed field.  Thus we need to check
	 that none of the top 8 bits of the shifted value (top 7 bits of
         the unshifted, unsigned value) are set, or that they are all set.  */
      if ((value & ~ ((offsetT) 0x1ffffff)) != 0
	  && ((value & ~ ((offsetT) 0x1ffffff)) != ~ ((offsetT) 0x1ffffff)))
	{
#ifdef OBJ_ELF
	  /* Normally we would be stuck at this point, since we cannot store
	     the absolute address that is the destination of the branch in the
	     24 bits of the branch instruction.  If however, we happen to know
	     that the destination of the branch is in the same section as the
	     branch instruction itself, then we can compute the relocation for
	     ourselves and not have to bother the linker with it.

	     FIXME: The tests for OBJ_ELF and ! target_oabi are only here
	     because I have not worked out how to do this for OBJ_COFF or
	     target_oabi.  */
	  if (! target_oabi
	      && fixP->fx_addsy != NULL
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && S_GET_SEGMENT (fixP->fx_addsy) == seg)
	    {
	      /* Get pc relative value to go into the branch.  */
	      value = * valP;

	      /* Permit a backward branch provided that enough bits
		 are set.  Allow a forwards branch, provided that
		 enough bits are clear.  */
	      if (   (value & ~ ((offsetT) 0x1ffffff)) == ~ ((offsetT) 0x1ffffff)
		  || (value & ~ ((offsetT) 0x1ffffff)) == 0)
		fixP->fx_done = 1;
	    }

	  if (! fixP->fx_done)
#endif
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("GAS can't handle same-section branch dest >= 0x04000000"));
	}

      value >>= 2;
      value += SEXT24 (newval);

      if (    (value & ~ ((offsetT) 0xffffff)) != 0
	  && ((value & ~ ((offsetT) 0xffffff)) != ~ ((offsetT) 0xffffff)))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("out of range branch"));

      newval = (value & 0x00ffffff) | (newval & 0xff000000);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_PCREL_BLX:
      {
	offsetT hbit;
	newval = md_chars_to_number (buf, INSN_SIZE);

#ifdef OBJ_ELF
	if (! target_oabi)
	  value = fixP->fx_offset;
#endif
	hbit   = (value >> 1) & 1;
	value  = (value >> 2) & 0x00ffffff;
	value  = (value + (newval & 0x00ffffff)) & 0x00ffffff;
	newval = value | (newval & 0xfe000000) | (hbit << 24);
	md_number_to_chars (buf, newval, INSN_SIZE);
      }
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* Conditional branch.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0xff) << 1;
	if (diff & 0x100)
	  diff |= ~0xff;

	value += diff;
	if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* Unconditional branch.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0x7ff) << 1;
	if (diff & 0x800)
	  diff |= ~0x7ff;

	value += diff;
	if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      {
	offsetT newval2;
	addressT diff;

	newval  = md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
	if (diff & 0x400000)
	  diff |= ~0x3fffff;
#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
	value += diff;

	if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch with link out of range"));

	newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
	newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
	if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  newval2 = (newval2 + 1) & ~ 1;
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
      break;

    case BFD_RELOC_8:
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 1);
#ifdef OBJ_ELF
      else if (!target_oabi)
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 1);
	}
#endif
      break;

    case BFD_RELOC_16:
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 2);
#ifdef OBJ_ELF
      else if (!target_oabi)
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 2);
	}
#endif
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
      md_number_to_chars (buf, 0, 4);
      break;
#endif

    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 4);
#ifdef OBJ_ELF
      else if (!target_oabi)
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 4);
	}
#endif
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PLT32:
      /* It appears the instruction is fully prepared at this point.  */
      break;
#endif

    case BFD_RELOC_ARM_CP_OFF_IMM:
      sign = value >= 0;
      if (value < -1023 || value > 1023 || (value & 3))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("illegal value for co-processor offset"));
      if (value < 0)
	value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= (value >> 2) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_CP_OFF_IMM_S2:
      sign = value >= 0;
      if (value < -255 || value > 255)
        as_bad_where (fixP->fx_file, fixP->fx_line,
                      _("Illegal value for co-processor offset"));
      if (value < 0)
        value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= value | (sign ?  INDEX_UP : 0);
      md_number_to_chars (buf, newval , INSN_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_OFFSET:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      /* Exactly what ranges, and where the offset is inserted depends
	 on the type of instruction, we can establish this from the
	 top 4 bits.  */
      switch (newval >> 12)
	{
	case 4: /* PC load.  */
	  /* Thumb PC loads are somewhat odd, bit 1 of the PC is
	     forced to zero for these loads, so we will need to round
	     up the offset if the instruction address is not word
	     aligned (since the final address produced must be, and
	     we can only describe word-aligned immediate offsets).  */

	  if ((fixP->fx_frag->fr_address + fixP->fx_where + value) & 3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, target not word aligned (0x%08X)"),
			  (unsigned int) (fixP->fx_frag->fr_address
					  + fixP->fx_where + value));

	  if ((value + 2) & ~0x3fe)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);

	  /* Round up, since pc will be rounded down.  */
	  newval |= (value + 2) >> 2;
	  break;

	case 9: /* SP load/store.  */
	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value >> 2;
	  break;

	case 6: /* Word load/store.  */
	  if (value & ~0x7c)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 4; /* 6 - 2.  */
	  break;

	case 7: /* Byte load/store.  */
	  if (value & ~0x1f)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 6;
	  break;

	case 8: /* Halfword load/store.  */
	  if (value & ~0x3e)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 5; /* 6 - 1.  */
	  break;

	default:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"Unable to process relocation for thumb opcode: %lx",
			(unsigned long) newval);
	  break;
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_ADD:
      /* This is a complicated relocation, since we use it for all of
         the following immediate relocations:

	    3bit ADD/SUB
	    8bit ADD/SUB
	    9bit ADD/SUB SP word-aligned
	   10bit ADD PC/SP word-aligned

         The type of instruction being processed is encoded in the
         instruction field:

	   0x8000  SUB
	   0x00F0  Rd
	   0x000F  Rs
      */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	int rd = (newval >> 4) & 0xf;
	int rs = newval & 0xf;
	int subtract = newval & 0x8000;

	if (rd == REG_SP)
	  {
	    if (value & ~0x1fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for stack address calculation"));
	    newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	    newval |= value >> 2;
	  }
	else if (rs == REG_PC || rs == REG_SP)
	  {
	    if (subtract ||
		value & ~0x3fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for address calculation (value = 0x%08lX)"),
			    (unsigned long) value);
	    newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
	    newval |= rd << 8;
	    newval |= value >> 2;
	  }
	else if (rs == rd)
	  {
	    if (value & ~0xff)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid 8bit immediate"));
	    newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	    newval |= (rd << 8) | value;
	  }
	else
	  {
	    if (value & ~0x7)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid 3bit immediate"));
	    newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	    newval |= rd | (rs << 3) | (value << 6);
	  }
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_IMM:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      switch (newval >> 11)
	{
	case 0x04: /* 8bit immediate MOV.  */
	case 0x05: /* 8bit immediate CMP.  */
	  if (value < 0 || value > 255)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid immediate: %ld is too large"),
			  (long) value);
	  newval |= value;
	  break;

	default:
	  abort ();
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_SHIFT:
      /* 5bit shift value (0..31).  */
      if (value < 0 || value > 31)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("illegal Thumb shift value: %ld"), (long) value);
      newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf03f;
      newval |= value << 6;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

    case BFD_RELOC_NONE:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("bad relocation fixup type (%d)"), fixP->fx_r_type);
    }
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent *
tc_gen_reloc (section, fixp)
     asection * section ATTRIBUTE_UNUSED;
     fixS * fixp;
{
  arelent * reloc;
  bfd_reloc_code_real_type code;

  reloc = (arelent *) xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* @@@@ Why fx_addnumber sometimes and fx_offset other times?  */
#ifndef OBJ_ELF
  if (fixp->fx_pcrel == 0)
    reloc->addend = fixp->fx_offset;
  else
    reloc->addend = fixp->fx_offset = reloc->address;
#else  /* OBJ_ELF */
  reloc->addend = fixp->fx_offset;
#endif

  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_8:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_8_PCREL;
	  break;
	}

    case BFD_RELOC_16:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_16_PCREL;
	  break;
	}

    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_32_PCREL;
	  break;
	}

    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_RVA:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_HWLITERAL:
      /* If this is called then the a literal has
	 been referenced across a section boundary.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("literal referenced across section boundary"));
      return NULL;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_PLT32:
      code = fixp->fx_r_type;
      break;
#endif

    case BFD_RELOC_ARM_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal relocation (type: IMMEDIATE) not fixed up"));
      return NULL;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("ADRL used for a symbol not defined in the same file"));
      return NULL;

    case BFD_RELOC_ARM_OFFSET_IMM:
      if (fixp->fx_addsy != NULL
	  && !S_IS_DEFINED (fixp->fx_addsy)
	  && S_IS_LOCAL (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("undefined local label `%s'"),
			S_GET_NAME (fixp->fx_addsy));
	  return NULL;
	}

      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal_relocation (type: OFFSET_IMM) not fixed up"));
      return NULL;

    default:
      {
	char * type;

	switch (fixp->fx_r_type)
	  {
	  case BFD_RELOC_ARM_OFFSET_IMM8:  type = "OFFSET_IMM8";  break;
	  case BFD_RELOC_ARM_SHIFT_IMM:    type = "SHIFT_IMM";    break;
	  case BFD_RELOC_ARM_SWI:          type = "SWI";          break;
	  case BFD_RELOC_ARM_MULTI:        type = "MULTI";        break;
	  case BFD_RELOC_ARM_CP_OFF_IMM:   type = "CP_OFF_IMM";   break;
	  case BFD_RELOC_ARM_THUMB_ADD:    type = "THUMB_ADD";    break;
	  case BFD_RELOC_ARM_THUMB_SHIFT:  type = "THUMB_SHIFT";  break;
	  case BFD_RELOC_ARM_THUMB_IMM:    type = "THUMB_IMM";    break;
	  case BFD_RELOC_ARM_THUMB_OFFSET: type = "THUMB_OFFSET"; break;
	  default:                         type = _("<unknown>"); break;
	  }
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("cannot represent %s relocation in this object file format"),
		      type);
	return NULL;
      }
    }

#ifdef OBJ_ELF
  if ((code == BFD_RELOC_32_PCREL || code == BFD_RELOC_32)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      code = BFD_RELOC_ARM_GOTPC;
      reloc->addend = fixp->fx_offset = reloc->address;
    }
#endif

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);

  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent %s relocation in this object file format"),
		    bfd_get_reloc_code_name (code));
      return NULL;
    }

  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  return reloc;
}

int
md_estimate_size_before_relax (fragP, segtype)
     fragS * fragP ATTRIBUTE_UNUSED;
     segT    segtype ATTRIBUTE_UNUSED;
{
  as_fatal (_("md_estimate_size_before_relax\n"));
  return 1;
}

static void
output_inst (str)
     const char *str;
{
  char * to = NULL;

  if (inst.error)
    {
      as_bad ("%s -- `%s'", inst.error, str);
      return;
    }

  to = frag_more (inst.size);

  if (thumb_mode && (inst.size > THUMB_SIZE))
    {
      assert (inst.size == (2 * THUMB_SIZE));
      md_number_to_chars (to, inst.instruction >> 16, THUMB_SIZE);
      md_number_to_chars (to + THUMB_SIZE, inst.instruction, THUMB_SIZE);
    }
  else if (inst.size > INSN_SIZE)
    {
      assert (inst.size == (2 * INSN_SIZE));
      md_number_to_chars (to, inst.instruction, INSN_SIZE);
      md_number_to_chars (to + INSN_SIZE, inst.instruction, INSN_SIZE);
    }
  else
    md_number_to_chars (to, inst.instruction, inst.size);

  if (inst.reloc.type != BFD_RELOC_NONE)
    fix_new_arm (frag_now, to - frag_now->fr_literal,
		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
		 inst.reloc.type);

#ifdef OBJ_ELF
  dwarf2_emit_insn (inst.size);
#endif
}

void
md_assemble (str)
     char * str;
{
  char  c;
  char *p;
  char *start;

  /* Align the instruction.
     This may not be the right thing to do but ...  */
#if 0
  arm_align (2, 0);
#endif

  /* Align the previous label if needed.  */
  if (last_label_seen != NULL)
    {
      symbol_set_frag (last_label_seen, frag_now);
      S_SET_VALUE (last_label_seen, (valueT) frag_now_fix ());
      S_SET_SEGMENT (last_label_seen, now_seg);
    }

  memset (&inst, '\0', sizeof (inst));
  inst.reloc.type = BFD_RELOC_NONE;

  skip_whitespace (str);

  /* Scan up to the end of the op-code, which must end in white space or
     end of string.  */
  for (start = p = str; *p != '\0'; p++)
    if (*p == ' ')
      break;

  if (p == str)
    {
      as_bad (_("no operator -- statement `%s'\n"), str);
      return;
    }

  if (thumb_mode)
    {
      const struct thumb_opcode * opcode;

      c = *p;
      *p = '\0';
      opcode = (const struct thumb_opcode *) hash_find (arm_tops_hsh, str);
      *p = c;

      if (opcode)
	{
	  /* Check that this instruction is supported for this CPU.  */
	  if (thumb_mode == 1 && (opcode->variant & cpu_variant) == 0)
	    {
	      as_bad (_("selected processor does not support `%s'"), str);
	      return;
	    }

	  mapping_state (MAP_THUMB);
	  inst.instruction = opcode->value;
	  inst.size = opcode->size;
	  (*opcode->parms) (p);
	  output_inst (str);
	  return;
	}
    }
  else
    {
      const struct asm_opcode * opcode;

      c = *p;
      *p = '\0';
      opcode = (const struct asm_opcode *) hash_find (arm_ops_hsh, str);
      *p = c;

      if (opcode)
	{
	  /* Check that this instruction is supported for this CPU.  */
	  if ((opcode->variant & cpu_variant) == 0)
	    {
	      as_bad (_("selected processor does not support `%s'"), str);
	      return;
	    }

          mapping_state (MAP_ARM);
	  inst.instruction = opcode->value;
	  inst.size = INSN_SIZE;
	  (*opcode->parms) (p);
	  output_inst (str);
	  return;
	}
    }

  /* It wasn't an instruction, but it might be a register alias of the form
     alias .req reg.  */
  if (create_register_alias (str, p))
    return;

  as_bad (_("bad instruction `%s'"), start);
}

/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.

      This routine is somewhat complicated by the need for backwards
      compatibility (since older releases of gcc can't be changed).
      The new options try to make the interface as compatible as
      possible with GCC.

      New options (supported) are:

	      -mcpu=<cpu name>		 Assemble for selected processor
	      -march=<architecture name> Assemble for selected architecture
	      -mfpu=<fpu architecture>	 Assemble for selected FPU.
	      -EB/-mbig-endian		 Big-endian
	      -EL/-mlittle-endian	 Little-endian
	      -k			 Generate PIC code
	      -mthumb			 Start in Thumb mode
	      -mthumb-interwork		 Code supports ARM/Thumb interworking

      For now we will also provide support for:

	      -mapcs-32			 32-bit Program counter
	      -mapcs-26			 26-bit Program counter
	      -macps-float		 Floats passed in FP registers
	      -mapcs-reentrant		 Reentrant code
	      -matpcs
      (sometime these will probably be replaced with -mapcs=<list of options>
      and -matpcs=<list of options>)

      The remaining options are only supported for back-wards compatibility.
      Cpu variants, the arm part is optional:
              -m[arm]1                Currently not supported.
              -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
              -m[arm]3                Arm 3 processor
              -m[arm]6[xx],           Arm 6 processors
              -m[arm]7[xx][t][[d]m]   Arm 7 processors
              -m[arm]8[10]            Arm 8 processors
              -m[arm]9[20][tdmi]      Arm 9 processors
              -mstrongarm[110[0]]     StrongARM processors
              -mxscale                XScale processors
              -m[arm]v[2345[t[e]]]    Arm architectures
              -mall                   All (except the ARM1)
      FP variants:
              -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions
              -mfpe-old               (No float load/store multiples)
	      -mvfpxd		      VFP Single precision
	      -mvfp		      All VFP
              -mno-fpu                Disable all floating point instructions

      The following CPU names are recognized:
	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620,
	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700,
	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c,
	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9,
	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e,
	      arm10t arm10e, arm1020t, arm1020e, arm10200e,
	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.

      */

const char * md_shortopts = "m:k";

#ifdef ARM_BI_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#define OPTION_EL (OPTION_MD_BASE + 1)
#else
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#else
#define OPTION_EL (OPTION_MD_BASE + 1)
#endif
#endif

struct option md_longopts[] =
{
#ifdef OPTION_EB
  {"EB", no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL", no_argument, NULL, OPTION_EL},
#endif
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

struct arm_option_table
{
  char *option;		/* Option name to match.  */
  char *help;		/* Help information.  */
  int  *var;		/* Variable to change.  */
  int   value;		/* What to change it to.  */
  char *deprecated;	/* If non-null, print this message.  */
};

struct arm_option_table arm_opts[] =
{
  {"k",      N_("generate PIC code"),      &pic_code,    1, NULL},
  {"mthumb", N_("assemble Thumb code"),    &thumb_mode,  1, NULL},
  {"mthumb-interwork", N_("support ARM/Thumb interworking"),
   &support_interwork, 1, NULL},
  {"moabi",  N_("use old ABI (ELF only)"), &target_oabi, 1, NULL},
  {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
  {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
  {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
   1, NULL},
  {"mapcs-reentrant", N_("re-entrant code"), &pic_code, 1, NULL},
  {"matpcs", N_("code is ATPCS conformant"), &atpcs, 1, NULL},
  {"mbig-endian", N_("assemble for big-endian"), &target_big_endian, 1, NULL},
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 1,
   NULL},

  /* These are recognized by the assembler, but have no affect on code.  */
  {"mapcs-frame", N_("use frame pointer"), NULL, 0, NULL},
  {"mapcs-stack-check", N_("use stack size checking"), NULL, 0, NULL},

  /* DON'T add any new processors to this list -- we want the whole list
     to go away...  Add them to the processors table instead.  */
  {"marm1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"m1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"marm2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"m2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"marm250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"m250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"marm3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"m3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"marm6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"m6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"marm600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"m600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"marm610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"m610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"marm620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"m620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"marm7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"m7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"marm70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"m70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"marm700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"m700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"marm700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"m700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"marm710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"m710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"marm710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"m710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"marm720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"m720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"marm7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"m7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"marm7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"m7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"marm7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"m7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"marm7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"m7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"marm7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"m7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"marm7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"m7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"marm7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"m7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"marm7500fe", NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"m7500fe",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"marm7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"m710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"marm720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"m720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"marm740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"m740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"marm8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"m8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"marm810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"m810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"marm9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"m9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"marm9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"m9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"marm920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"m920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"marm940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"m940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"mstrongarm", NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
  {"mstrongarm110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm110")},
  {"mstrongarm1100", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1100")},
  {"mstrongarm1110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1110")},
  {"mxscale",	 NULL, &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
  {"miwmmxt",	 NULL, &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
  {"mall",	 NULL, &legacy_cpu, ARM_ANY,      N_("use -mcpu=all")},

  /* Architecture variants -- don't add any more to this list either.  */
  {"mv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"marmv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"mv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"marmv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"mv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"marmv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"mv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"marmv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"mv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"marmv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"mv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"marmv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"mv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"marmv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"mv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"marmv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"mv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
  {"marmv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},

  /* Floating point variants -- don't add any more to this list either.  */
  {"mfpe-old", NULL, &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
  {"mfpa10",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
  {"mfpa11",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
  {"mno-fpu",  NULL, &legacy_fpu, 0,
   N_("use either -mfpu=softfpa or -mfpu=softvfp")},

  {NULL, NULL, NULL, 0, NULL}
};

struct arm_cpu_option_table
{
  char *name;
  int   value;
  /* For some CPUs we assume an FPU unless the user explicitly sets
     -mfpu=...  */
  int   default_fpu;
};

/* This list should, at a minimum, contain all the cpu names
   recognized by GCC.  */
static struct arm_cpu_option_table arm_cpus[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"arm250",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm600",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm610",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm620",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dm",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7di",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dmi",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700i",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm720",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm720t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm740t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm710c",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7100",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500fe",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm810",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm922t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm940t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm9tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  /* For V5 or later processors we default to using VFP; but the user
     should really set the FPU type explicitly.  */
  {"arm9e-r0",		ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm9e",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2},
  {"arm926ej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ejs",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm946e",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2},
  {"arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm966e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm10t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm10e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm1020e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1026ejs",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1136js",		ARM_ARCH_V6,     FPU_NONE},
  {"arm1136jfs",	ARM_ARCH_V6,     FPU_ARCH_VFP_V2},
  /* ??? XSCALE is really an architecture.  */
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* ??? iwmmxt is not a processor.  */
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2},
  {"i80200",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* Maverick */
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_ARCH_MAVERICK},
  {NULL, 0, 0}
};

struct arm_arch_option_table
{
  char *name;
  int   value;
  int   default_fpu;
};

/* This list should, at a minimum, contain all the architecture names
   recognized by GCC.  */
static struct arm_arch_option_table arm_archs[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"armv1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"armv2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"armv2a",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv2s",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv3",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"armv3m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"armv4",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"armv4xm",		ARM_ARCH_V4xM,	 FPU_ARCH_FPA},
  {"armv4t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"armv4txm",		ARM_ARCH_V4TxM,	 FPU_ARCH_FPA},
  {"armv5",		ARM_ARCH_V5,	 FPU_ARCH_VFP},
  {"armv5t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP},
  {"armv5txm",		ARM_ARCH_V5TxM,	 FPU_ARCH_VFP},
  {"armv5te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP},
  {"armv5texp",		ARM_ARCH_V5TExP, FPU_ARCH_VFP},
  {"armv5tej",		ARM_ARCH_V5TEJ,  FPU_ARCH_VFP},
  {"armv6",             ARM_ARCH_V6,     FPU_ARCH_VFP},
  {"armv6j",            ARM_ARCH_V6,     FPU_ARCH_VFP},
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP},
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP},
  {NULL, 0, 0}
};

/* ISA extensions in the co-processor space.  */
struct arm_arch_extension_table
{
  char *name;
  int value;
};

static struct arm_arch_extension_table arm_extensions[] =
{
  {"maverick",		ARM_CEXT_MAVERICK},
  {"xscale",		ARM_CEXT_XSCALE},
  {"iwmmxt",		ARM_CEXT_IWMMXT},
  {NULL,		0}
};

struct arm_fpu_option_table
{
  char *name;
  int   value;
};

/* This list should, at a minimum, contain all the fpu names
   recognized by GCC.  */
static struct arm_fpu_option_table arm_fpus[] =
{
  {"softfpa",		FPU_NONE},
  {"fpe",		FPU_ARCH_FPE},
  {"fpe2",		FPU_ARCH_FPE},
  {"fpe3",		FPU_ARCH_FPA},	/* Third release supports LFM/SFM.  */
  {"fpa",		FPU_ARCH_FPA},
  {"fpa10",		FPU_ARCH_FPA},
  {"fpa11",		FPU_ARCH_FPA},
  {"arm7500fe",		FPU_ARCH_FPA},
  {"softvfp",		FPU_ARCH_VFP},
  {"softvfp+vfp",	FPU_ARCH_VFP_V2},
  {"vfp",		FPU_ARCH_VFP_V2},
  {"vfp9",		FPU_ARCH_VFP_V2},
  {"vfp10",		FPU_ARCH_VFP_V2},
  {"vfp10-r0",		FPU_ARCH_VFP_V1},
  {"vfpxd",		FPU_ARCH_VFP_V1xD},
  {"arm1020t",		FPU_ARCH_VFP_V1},
  {"arm1020e",		FPU_ARCH_VFP_V2},
  {"arm1136jfs",	FPU_ARCH_VFP_V2},
  {"maverick",		FPU_ARCH_MAVERICK},
  {NULL, 0}
};

struct arm_float_abi_option_table
{
  char *name;
  int value;
};

static struct arm_float_abi_option_table arm_float_abis[] =
{
  {"hard",	ARM_FLOAT_ABI_HARD},
  {"softfp",	ARM_FLOAT_ABI_SOFTFP},
  {"soft",	ARM_FLOAT_ABI_SOFT},
  {NULL, 0}
};

struct arm_long_option_table
{
  char *option;		/* Substring to match.  */
  char *help;		/* Help information.  */
  int (*func) PARAMS ((char *subopt));	/* Function to decode sub-option.  */
  char *deprecated;	/* If non-null, print this message.  */
};

static int
arm_parse_extension (str, opt_p)
     char *str;
     int *opt_p;
{
  while (str != NULL && *str != 0)
    {
      struct arm_arch_extension_table *opt;
      char *ext;
      int optlen;

      if (*str != '+')
	{
	  as_bad (_("invalid architectural extension"));
	  return 0;
	}

      str++;
      ext = strchr (str, '+');

      if (ext != NULL)
	optlen = ext - str;
      else
	optlen = strlen (str);

      if (optlen == 0)
	{
	  as_bad (_("missing architectural extension"));
	  return 0;
	}

      for (opt = arm_extensions; opt->name != NULL; opt++)
	if (strncmp (opt->name, str, optlen) == 0)
	  {
	    *opt_p |= opt->value;
	    break;
	  }

      if (opt->name == NULL)
	{
	  as_bad (_("unknown architectural extnsion `%s'"), str);
	  return 0;
	}

      str = ext;
    };

  return 1;
}

static int
arm_parse_cpu (str)
     char *str;
{
  struct arm_cpu_option_table *opt;
  char *ext = strchr (str, '+');
  int optlen;

  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);

  if (optlen == 0)
    {
      as_bad (_("missing cpu name `%s'"), str);
      return 0;
    }

  for (opt = arm_cpus; opt->name != NULL; opt++)
    if (strncmp (opt->name, str, optlen) == 0)
      {
	mcpu_cpu_opt = opt->value;
	mcpu_fpu_opt = opt->default_fpu;

	if (ext != NULL)
	  return arm_parse_extension (ext, &mcpu_cpu_opt);

	return 1;
      }

  as_bad (_("unknown cpu `%s'"), str);
  return 0;
}

static int
arm_parse_arch (str)
     char *str;
{
  struct arm_arch_option_table *opt;
  char *ext = strchr (str, '+');
  int optlen;

  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);

  if (optlen == 0)
    {
      as_bad (_("missing architecture name `%s'"), str);
      return 0;
    }


  for (opt = arm_archs; opt->name != NULL; opt++)
    if (strcmp (opt->name, str) == 0)
      {
	march_cpu_opt = opt->value;
	march_fpu_opt = opt->default_fpu;

	if (ext != NULL)
	  return arm_parse_extension (ext, &march_cpu_opt);

	return 1;
      }

  as_bad (_("unknown architecture `%s'\n"), str);
  return 0;
}

static int
arm_parse_fpu (str)
     char *str;
{
  struct arm_fpu_option_table *opt;

  for (opt = arm_fpus; opt->name != NULL; opt++)
    if (strcmp (opt->name, str) == 0)
      {
	mfpu_opt = opt->value;
	return 1;
      }

  as_bad (_("unknown floating point format `%s'\n"), str);
  return 0;
}

static int
arm_parse_float_abi (str)
     char * str;
{
  struct arm_float_abi_option_table *opt;

  for (opt = arm_float_abis; opt->name != NULL; opt++)
    if (strcmp (opt->name, str) == 0)
      {
	mfloat_abi_opt = opt->value;
	return 1;
      }

  as_bad (_("unknown floating point abi `%s'\n"), str);
  return 0;
}

struct arm_long_option_table arm_long_opts[] =
{
  {"mcpu=", N_("<cpu name>\t  assemble for CPU <cpu name>"),
   arm_parse_cpu, NULL},
  {"march=", N_("<arch name>\t  assemble for architecture <arch name>"),
   arm_parse_arch, NULL},
  {"mfpu=", N_("<fpu name>\t  assemble for FPU architecture <fpu name>"),
   arm_parse_fpu, NULL},
  {"mfloat-abi=", N_("<abi>\t  assemble for floating point ABI <abi>"),
   arm_parse_float_abi, NULL},
  {NULL, NULL, 0, NULL}
};

int
md_parse_option (c, arg)
     int    c;
     char * arg;
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  switch (c)
    {
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif

#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif

    case 'a':
      /* Listing option.  Just ignore these, we don't support additional
	 ones.  */
      return 0;

    default:
      for (opt = arm_opts; opt->option != NULL; opt++)
	{
	  if (c == opt->option[0]
	      && ((arg == NULL && opt->option[1] == 0)
		  || strcmp (arg, opt->option + 1) == 0))
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (opt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
			   arg ? arg : "", _(opt->deprecated));
#endif

	      if (opt->var != NULL)
		*opt->var = opt->value;

	      return 1;
	    }
	}

      for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
	{
	  /* These options are expected to have an argument.  */
	  if (c == lopt->option[0]
	      && arg != NULL
	      && strncmp (arg, lopt->option + 1,
			  strlen (lopt->option + 1)) == 0)
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (lopt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c, arg,
			   _(lopt->deprecated));
#endif

	      /* Call the sup-option parser.  */
	      return (*lopt->func)(arg + strlen (lopt->option) - 1);
	    }
	}

      as_bad (_("unrecognized option `-%c%s'"), c, arg ? arg : "");
      return 0;
    }

  return 1;
}

void
md_show_usage (fp)
     FILE * fp;
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  fprintf (fp, _(" ARM-specific assembler options:\n"));

  for (opt = arm_opts; opt->option != NULL; opt++)
    if (opt->help != NULL)
      fprintf (fp, "  -%-23s%s\n", opt->option, _(opt->help));

  for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
    if (lopt->help != NULL)
      fprintf (fp, "  -%s%s\n", lopt->option, _(lopt->help));

#ifdef OPTION_EB
  fprintf (fp, _("\
  -EB                     assemble code for a big-endian cpu\n"));
#endif

#ifdef OPTION_EL
  fprintf (fp, _("\
  -EL                     assemble code for a little-endian cpu\n"));
#endif
}

/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.  We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */

static void
fix_new_arm (frag, where, size, exp, pc_rel, reloc)
     fragS *       frag;
     int           where;
     short int     size;
     expressionS * exp;
     int           pc_rel;
     int           reloc;
{
  fixS *           new_fix;
  arm_fix_data *   arm_data;

  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;

    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
      break;
    }

  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  arm_data = (arm_fix_data *) obstack_alloc (& notes, sizeof (arm_fix_data));
  new_fix->tc_fix_data = (PTR) arm_data;
  arm_data->thumb_mode = thumb_mode;
}

/* This fix_new is called by cons via TC_CONS_FIX_NEW.  */

void
cons_fix_new_arm (frag, where, size, exp)
     fragS *       frag;
     int           where;
     int           size;
     expressionS * exp;
{
  bfd_reloc_code_real_type type;
  int pcrel = 0;

  /* Pick a reloc.
     FIXME: @@@@ Should look at CPU word size.  */
  switch (size)
    {
    case 1:
      type = BFD_RELOC_8;
      break;
    case 2:
      type = BFD_RELOC_16;
      break;
    case 4:
    default:
      type = BFD_RELOC_32;
      break;
    case 8:
      type = BFD_RELOC_64;
      break;
    }

  fix_new_exp (frag, where, (int) size, exp, pcrel, type);
}

/* A good place to do this, although this was probably not intended
   for this kind of use.  We need to dump the literal pool before
   references are made to a null symbol pointer.  */

void
arm_cleanup ()
{
  literal_pool * pool;

  for (pool = list_of_pools; pool; pool = pool->next)
    {
      /* Put it at the end of the relevent section.  */
      subseg_set (pool->section, pool->sub_section);
#ifdef OBJ_ELF
      arm_elf_change_section ();
#endif
      s_ltorg (0);
    }
}

void
arm_start_line_hook ()
{
  last_label_seen = NULL;
}

void
arm_frob_label (sym)
     symbolS * sym;
{
  last_label_seen = sym;

  ARM_SET_THUMB (sym, thumb_mode);

#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (sym, support_interwork);
#endif

  /* Note - do not allow local symbols (.Lxxx) to be labeled
     as Thumb functions.  This is because these labels, whilst
     they exist inside Thumb code, are not the entry points for
     possible ARM->Thumb calls.  Also, these labels can be used
     as part of a computed goto or switch statement.  eg gcc
     can generate code that looks like this:

                ldr  r2, [pc, .Laaa]
                lsl  r3, r3, #2
                ldr  r2, [r3, r2]
                mov  pc, r2

       .Lbbb:  .word .Lxxx
       .Lccc:  .word .Lyyy
       ..etc...
       .Laaa:   .word Lbbb

     The first instruction loads the address of the jump table.
     The second instruction converts a table index into a byte offset.
     The third instruction gets the jump address out of the table.
     The fourth instruction performs the jump.

     If the address stored at .Laaa is that of a symbol which has the
     Thumb_Func bit set, then the linker will arrange for this address
     to have the bottom bit set, which in turn would mean that the
     address computation performed by the third instruction would end
     up with the bottom bit set.  Since the ARM is capable of unaligned
     word loads, the instruction would then load the incorrect address
     out of the jump table, and chaos would ensue.  */
  if (label_is_thumb_function_name
      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    {
      /* When the address of a Thumb function is taken the bottom
	 bit of that address should be set.  This will allow
	 interworking between Arm and Thumb functions to work
	 correctly.  */

      THUMB_SET_FUNC (sym, 1);

      label_is_thumb_function_name = FALSE;
    }
}

/* Adjust the symbol table.  This marks Thumb symbols as distinct from
   ARM ones.  */

void
arm_adjust_symtab ()
{
#ifdef OBJ_COFF
  symbolS * sym;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  if (THUMB_IS_FUNC (sym))
	    {
	      /* Mark the symbol as a Thumb function.  */
	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)  /* This can happen!  */
		S_SET_STORAGE_CLASS (sym, C_THUMBSTATFUNC);

	      else if (S_GET_STORAGE_CLASS (sym) == C_EXT)
		S_SET_STORAGE_CLASS (sym, C_THUMBEXTFUNC);
	      else
		as_bad (_("%s: unexpected function type: %d"),
			S_GET_NAME (sym), S_GET_STORAGE_CLASS (sym));
	    }
	  else switch (S_GET_STORAGE_CLASS (sym))
	    {
	    case C_EXT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
	      break;
	    case C_STAT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
	      break;
	    case C_LABEL:
	      S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
	      break;
	    default:
	      /* Do nothing.  */
	      break;
	    }
	}

      if (ARM_IS_INTERWORK (sym))
	coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_flags = 0xFF;
    }
#endif
#ifdef OBJ_ELF
  symbolS * sym;
  char      bind;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  elf_symbol_type * elf_sym;

	  elf_sym = elf_symbol (symbol_get_bfdsym (sym));
	  bind = ELF_ST_BIND (elf_sym);

	  /* If it's a .thumb_func, declare it as so,
	     otherwise tag label as .code 16.  */
	  if (THUMB_IS_FUNC (sym))
	    elf_sym->internal_elf_sym.st_info =
	      ELF_ST_INFO (bind, STT_ARM_TFUNC);
	  else
	    elf_sym->internal_elf_sym.st_info =
	      ELF_ST_INFO (bind, STT_ARM_16BIT);
	}
    }
#endif
}

int
arm_data_in_code ()
{
  if (thumb_mode && ! strncmp (input_line_pointer + 1, "data:", 5))
    {
      *input_line_pointer = '/';
      input_line_pointer += 5;
      *input_line_pointer = 0;
      return 1;
    }

  return 0;
}

char *
arm_canonicalize_symbol_name (name)
     char * name;
{
  int len;

  if (thumb_mode && (len = strlen (name)) > 5
      && streq (name + len - 5, "/data"))
    *(name + len - 5) = 0;

  return name;
}

#if defined OBJ_COFF || defined OBJ_ELF
void
arm_validate_fix (fixP)
     fixS * fixP;
{
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.  */
  if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
      && fixP->fx_addsy != NULL
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! THUMB_IS_FUNC (fixP->fx_addsy))
    {
      fixP->fx_addsy = find_real_start (fixP->fx_addsy);
    }
}
#endif

int
arm_force_relocation (fixp)
     struct fix * fixp;
{
#if defined (OBJ_COFF) && defined (TE_PE)
  if (fixp->fx_r_type == BFD_RELOC_RVA)
    return 1;
#endif
#ifdef OBJ_ELF
  if (fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;
#endif

  /* Resolve these relocations even if the symbol is extern or weak.  */
  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 0;

  return generic_force_reloc (fixp);
}

#ifdef OBJ_COFF
/* This is a little hack to help the gas/arm/adrl.s test.  It prevents
   local labels from being added to the output symbol table when they
   are used with the ADRL pseudo op.  The ADRL relocation should always
   be resolved before the binbary is emitted, so it is safe to say that
   it is adjustable.  */

bfd_boolean
arm_fix_adjustable (fixP)
   fixS * fixP;
{
  if (fixP->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 1;
  return 0;
}
#endif

#ifdef OBJ_ELF
/* Relocations against Thumb function names must be left unadjusted,
   so that the linker can use this information to correctly set the
   bottom bit of their addresses.  The MIPS version of this function
   also prevents relocations that are mips-16 specific, but I do not
   know why it does this.

   FIXME:
   There is one other problem that ought to be addressed here, but
   which currently is not:  Taking the address of a label (rather
   than a function) and then later jumping to that address.  Such
   addresses also ought to have their bottom bit set (assuming that
   they reside in Thumb code), but at the moment they will not.  */

bfd_boolean
arm_fix_adjustable (fixP)
   fixS * fixP;
{
  if (fixP->fx_addsy == NULL)
    return 1;

  if (THUMB_IS_FUNC (fixP->fx_addsy)
      && fixP->fx_subsy == NULL)
    return 0;

  /* We need the symbol name for the VTABLE entries.  */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  /* Don't allow symbols to be discarded on GOT related relocs.  */
  if (fixP->fx_r_type == BFD_RELOC_ARM_PLT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF)
    return 0;

  return 1;
}

const char *
elf32_arm_target_format ()
{
  if (target_big_endian)
    {
      if (target_oabi)
	return "elf32-bigarm-oabi";
      else
	return "elf32-bigarm";
    }
  else
    {
      if (target_oabi)
	return "elf32-littlearm-oabi";
      else
	return "elf32-littlearm";
    }
}

void
armelf_frob_symbol (symp, puntp)
     symbolS * symp;
     int *     puntp;
{
  elf_frob_symbol (symp, puntp);
}

static bfd_reloc_code_real_type
arm_parse_reloc ()
{
  char         id [16];
  char *       ip;
  unsigned int i;
  static struct
  {
    char * str;
    int    len;
    bfd_reloc_code_real_type reloc;
  }
  reloc_map[] =
  {
#define MAP(str,reloc) { str, sizeof (str) - 1, reloc }
    MAP ("(got)",    BFD_RELOC_ARM_GOT32),
    MAP ("(gotoff)", BFD_RELOC_ARM_GOTOFF),
    /* ScottB: Jan 30, 1998 - Added support for parsing "var(PLT)"
       branch instructions generated by GCC for PLT relocs.  */
    MAP ("(plt)",    BFD_RELOC_ARM_PLT32),
    { NULL, 0,         BFD_RELOC_UNUSED }
#undef MAP
  };

  for (i = 0, ip = input_line_pointer;
       i < sizeof (id) && (ISALNUM (*ip) || ISPUNCT (*ip));
       i++, ip++)
    id[i] = TOLOWER (*ip);

  for (i = 0; reloc_map[i].str; i++)
    if (strncmp (id, reloc_map[i].str, reloc_map[i].len) == 0)
      break;

  input_line_pointer += reloc_map[i].len;

  return reloc_map[i].reloc;
}

static void
s_arm_elf_cons (nbytes)
     int nbytes;
{
  expressionS exp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  mapping_state (MAP_DATA);
  do
    {
      bfd_reloc_code_real_type reloc;

      expression (& exp);

      if (exp.X_op == O_symbol
	  && * input_line_pointer == '('
	  && (reloc = arm_parse_reloc ()) != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  int size = bfd_get_reloc_size (howto);

	  if (size > nbytes)
	    as_bad ("%s relocations do not fit in %d bytes",
		    howto->name, nbytes);
	  else
	    {
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;

	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  input_line_pointer --;
  demand_empty_rest_of_line ();
}

#endif /* OBJ_ELF */

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
arm_handle_align (fragP)
     fragS *fragP;
{
  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
  static char const thumb_noop[2] = { 0xc0, 0x46 };
  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };

  int bytes, fix, noop_size;
  char * p;
  const char * noop;

  if (fragP->fr_type != rs_align_code)
    return;

  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
  p = fragP->fr_literal + fragP->fr_fix;
  fix = 0;

  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;

  if (fragP->tc_frag_data)
    {
      if (target_big_endian)
	noop = thumb_bigend_noop;
      else
	noop = thumb_noop;
      noop_size = sizeof (thumb_noop);
    }
  else
    {
      if (target_big_endian)
	noop = arm_bigend_noop;
      else
	noop = arm_noop;
      noop_size = sizeof (arm_noop);
    }

  if (bytes & (noop_size - 1))
    {
      fix = bytes & (noop_size - 1);
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }

  while (bytes >= noop_size)
    {
      memcpy (p, noop, noop_size);
      p += noop_size;
      bytes -= noop_size;
      fix += noop_size;
    }

  fragP->fr_fix += fix;
  fragP->fr_var = noop_size;
}

/* Called from md_do_align.  Used to create an alignment
   frag in a code section.  */

void
arm_frag_align_code (n, max)
     int n;
     int max;
{
  char * p;

  /* We assume that there will never be a requirement
     to support alignments greater than 32 bytes.  */
  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));

  p = frag_var (rs_align_code,
		MAX_MEM_FOR_RS_ALIGN_CODE,
		1,
		(relax_substateT) max,
		(symbolS *) NULL,
		(offsetT) n,
		(char *) NULL);
  *p = 0;

}

/* Perform target specific initialisation of a frag.  */

void
arm_init_frag (fragP)
     fragS *fragP;
{
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data = thumb_mode;
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d7 2
d60 1
d88 1
d107 1
d118 9
d157 1
a157 1
#define FPU_DEFAULT FPU_ARCH_VFP  /* Soft-float, but VFP order. */
d159 2
a160 1
#define FPU_DEFAULT FPU_ARCH_FPA  /* Soft-float, but FPA order. */
d193 1
d306 1
d308 8
a315 1
#define SHIFT_RESTRICT	  0
d388 1
a388 1
/* The bit that distnguishes CPSR and SPSR.  */
d606 1
d618 3
a620 1
/* These are the standard names.  Users can add aliases with .req.  */
d624 4
a627 4
  {"r0",  0},  {"r1",  1},      {"r2",  2},      {"r3",  3},
  {"r4",  4},  {"r5",  5},      {"r6",  6},      {"r7",  7},
  {"r8",  8},  {"r9",  9},      {"r10", 10},     {"r11", 11},
  {"r12", 12}, {"r13", REG_SP}, {"r14", REG_LR}, {"r15", REG_PC},
d629 3
a631 3
  {"a1",  0},  {"a2",  1},      {"a3",  2},      {"a4",  3},
  {"v1",  4},  {"v2",  5},      {"v3",  6},      {"v4",  7},
  {"v5",  8},  {"v6",  9},      {"v7",  10},     {"v8",  11},
d633 3
a635 4
						 {"wr",  7},
	       {"sb",  9},      {"sl",  10},     {"fp",  11},
  {"ip",  12}, {"sp",  REG_SP}, {"lr",  REG_LR}, {"pc",  REG_PC},
  {NULL, 0}
d644 26
a669 26
  {  "wr0", 0x0 | WR_PREFIX},   {"wr1", 0x1 | WR_PREFIX},
  {  "wr2", 0x2 | WR_PREFIX},   {"wr3", 0x3 | WR_PREFIX},
  {  "wr4", 0x4 | WR_PREFIX},   {"wr5", 0x5 | WR_PREFIX},
  {  "wr6", 0x6 | WR_PREFIX},   {"wr7", 0x7 | WR_PREFIX},
  {  "wr8", 0x8 | WR_PREFIX},   {"wr9", 0x9 | WR_PREFIX},
  { "wr10", 0xa | WR_PREFIX},  {"wr11", 0xb | WR_PREFIX},
  { "wr12", 0xc | WR_PREFIX},  {"wr13", 0xd | WR_PREFIX},
  { "wr14", 0xe | WR_PREFIX},  {"wr15", 0xf | WR_PREFIX},
  { "wcid", 0x0 | WC_PREFIX},  {"wcon", 0x1 | WC_PREFIX},
  {"wcssf", 0x2 | WC_PREFIX}, {"wcasf", 0x3 | WC_PREFIX},
  {"wcgr0", 0x8 | WC_PREFIX}, {"wcgr1", 0x9 | WC_PREFIX},
  {"wcgr2", 0xa | WC_PREFIX}, {"wcgr3", 0xb | WC_PREFIX},

  {  "wR0", 0x0 | WR_PREFIX},   {"wR1", 0x1 | WR_PREFIX},
  {  "wR2", 0x2 | WR_PREFIX},   {"wR3", 0x3 | WR_PREFIX},
  {  "wR4", 0x4 | WR_PREFIX},   {"wR5", 0x5 | WR_PREFIX},
  {  "wR6", 0x6 | WR_PREFIX},   {"wR7", 0x7 | WR_PREFIX},
  {  "wR8", 0x8 | WR_PREFIX},   {"wR9", 0x9 | WR_PREFIX},
  { "wR10", 0xa | WR_PREFIX},  {"wR11", 0xb | WR_PREFIX},
  { "wR12", 0xc | WR_PREFIX},  {"wR13", 0xd | WR_PREFIX},
  { "wR14", 0xe | WR_PREFIX},  {"wR15", 0xf | WR_PREFIX},
  { "wCID", 0x0 | WC_PREFIX},  {"wCon", 0x1 | WC_PREFIX},
  {"wCSSF", 0x2 | WC_PREFIX}, {"wCASF", 0x3 | WC_PREFIX},
  {"wCGR0", 0x8 | WC_PREFIX}, {"wCGR1", 0x9 | WC_PREFIX},
  {"wCGR2", 0xa | WC_PREFIX}, {"wCGR3", 0xb | WC_PREFIX},
  {NULL, 0}
d675 5
a679 5
  {"p0",  0},  {"p1",  1},  {"p2",  2},  {"p3", 3},
  {"p4",  4},  {"p5",  5},  {"p6",  6},  {"p7", 7},
  {"p8",  8},  {"p9",  9},  {"p10", 10}, {"p11", 11},
  {"p12", 12}, {"p13", 13}, {"p14", 14}, {"p15", 15},
  {NULL, 0}
d685 4
a688 4
  {"c0",   0},  {"c1",   1},  {"c2",   2},  {"c3",   3},
  {"c4",   4},  {"c5",   5},  {"c6",   6},  {"c7",   7},
  {"c8",   8},  {"c9",   9},  {"c10",  10}, {"c11",  11},
  {"c12",  12}, {"c13",  13}, {"c14",  14}, {"c15",  15},
d690 5
a694 5
  {"cr0",  0},  {"cr1",  1},  {"cr2",  2},  {"cr3",  3},
  {"cr4",  4},  {"cr5",  5},  {"cr6",  6},  {"cr7",  7},
  {"cr8",  8},  {"cr9",  9},  {"cr10", 10}, {"cr11", 11},
  {"cr12", 12}, {"cr13", 13}, {"cr14", 14}, {"cr15", 15},
  {NULL, 0}
d700 3
a702 3
  {"f0", 0},   {"f1", 1},   {"f2", 2},   {"f3", 3},
  {"f4", 4},   {"f5", 5},   {"f6", 6},   {"f7", 7},
  {NULL, 0}
d708 9
a716 9
  {"s0",  0},  {"s1",  1},  {"s2",  2},	 {"s3", 3},
  {"s4",  4},  {"s5",  5},  {"s6",  6},	 {"s7", 7},
  {"s8",  8},  {"s9",  9},  {"s10", 10}, {"s11", 11},
  {"s12", 12}, {"s13", 13}, {"s14", 14}, {"s15", 15},
  {"s16", 16}, {"s17", 17}, {"s18", 18}, {"s19", 19},
  {"s20", 20}, {"s21", 21}, {"s22", 22}, {"s23", 23},
  {"s24", 24}, {"s25", 25}, {"s26", 26}, {"s27", 27},
  {"s28", 28}, {"s29", 29}, {"s30", 30}, {"s31", 31},
  {NULL, 0}
d722 5
a726 5
  {"d0",  0},  {"d1",  1},  {"d2",  2},	 {"d3", 3},
  {"d4",  4},  {"d5",  5},  {"d6",  6},	 {"d7", 7},
  {"d8",  8},  {"d9",  9},  {"d10", 10}, {"d11", 11},
  {"d12", 12}, {"d13", 13}, {"d14", 14}, {"d15", 15},
  {NULL, 0}
d732 5
a736 5
  {"mvf0",  0},  {"mvf1",  1},  {"mvf2",  2},  {"mvf3",  3},
  {"mvf4",  4},  {"mvf5",  5},  {"mvf6",  6},  {"mvf7",  7},
  {"mvf8",  8},  {"mvf9",  9},  {"mvf10", 10}, {"mvf11", 11},
  {"mvf12", 12}, {"mvf13", 13}, {"mvf14", 14}, {"mvf15", 15},
  {NULL, 0}
d741 5
a745 5
  {"mvd0",  0},  {"mvd1",  1},  {"mvd2",  2},  {"mvd3",  3},
  {"mvd4",  4},  {"mvd5",  5},  {"mvd6",  6},  {"mvd7",  7},
  {"mvd8",  8},  {"mvd9",  9},  {"mvd10", 10}, {"mvd11", 11},
  {"mvd12", 12}, {"mvd13", 13}, {"mvd14", 14}, {"mvd15", 15},
  {NULL, 0}
d750 5
a754 5
  {"mvfx0",  0},  {"mvfx1",  1},  {"mvfx2",  2},  {"mvfx3",  3},
  {"mvfx4",  4},  {"mvfx5",  5},  {"mvfx6",  6},  {"mvfx7",  7},
  {"mvfx8",  8},  {"mvfx9",  9},  {"mvfx10", 10}, {"mvfx11", 11},
  {"mvfx12", 12}, {"mvfx13", 13}, {"mvfx14", 14}, {"mvfx15", 15},
  {NULL, 0}
d759 5
a763 5
  {"mvdx0",  0},  {"mvdx1",  1},  {"mvdx2",  2},  {"mvdx3",  3},
  {"mvdx4",  4},  {"mvdx5",  5},  {"mvdx6",  6},  {"mvdx7",  7},
  {"mvdx8",  8},  {"mvdx9",  9},  {"mvdx10", 10}, {"mvdx11", 11},
  {"mvdx12", 12}, {"mvdx13", 13}, {"mvdx14", 14}, {"mvdx15", 15},
  {NULL, 0}
d768 2
a769 2
  {"mvax0", 0}, {"mvax1", 1}, {"mvax2", 2}, {"mvax3", 3},
  {NULL, 0}
d774 2
a775 2
  {"dspsc", 0},
  {NULL, 0}
d797 1
a797 1
  {mav_mvdx_table,  15, NULL, N_("Maverick MVFX register expected")},
d882 30
d934 2
a935 1
static void do_vfp_sp_reg2	PARAMS ((char *));
d1116 2
a1117 2
/* "INSN<cond> X,Y" where X:0, Y:bit16.  */
#define MAV_MODE3	0x1000
d1237 1
a1237 1
  /* Generic copressor instructions.  */
d1330 101
d1982 2
a1983 2
  {"fmsrr",   0xec400a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp_reg2},
  {"fmrrs",   0xec500a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp_reg2},
d2180 12
a2191 12
  {"cfmval32",   0xee100610, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32al",   0xee000610, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvam32",   0xee100630, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32am",   0xee000630, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvah32",   0xee100650, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32ah",   0xee000650, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva32",    0xee100670, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32a",    0xee000670, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva64",    0xee100690, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3c},
  {"cfmv64a",    0xee000690, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3d},
  {"cfmvsc32",   0xee1006b0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_1},
  {"cfmv32sc",   0xee0006b0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_2},
d2304 5
d2377 1
d2470 13
d2503 1
d2522 1
a2522 1
  /* Never called becasue '.req' does not start line.  */
d2524 1
a2538 2
  { "file",        (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  { "loc",         dwarf2_directive_loc,  0 },
d2553 2
d2558 1
d2775 1
a2775 1
/* Check to see if an immediate can be computed as two seperate immediate
d2824 161
d2992 71
d3071 1
d3101 2
d3312 1
d3328 1
d3750 17
a3766 1
	  if (wb_ok && skip_past_comma (& p) == SUCCESS)
d3768 5
a3772 2
	      /* [Rn], #expr  */
	      write_back = WRITE_BACK;
d3774 3
a3776 1
	      if (reg == REG_PC)
d3778 11
a3788 2
		  inst.error = _("pc may not be used in post-increment");
		  return FAIL;
d3790 11
d3802 1
a3802 1
	      if (cp_address_offset (& p) == FAIL)
d3804 30
d3836 4
a3839 1
	    pre_inc = PRE_INDEX | INDEX_UP;
a4039 1
  return;
d4067 1
a4067 1
	 /* Lower case versions for backwards compatability.  */
d4072 1
a4072 1
  /* This is for backwards compatability with older toolchains.  */
a4222 1
  return;
a4275 1
  return;
a4330 1
  return;
d4687 1
a4687 1
     Instruction is not conditional, and has 0xf in the codition field.
d4788 944
a5731 1
     char *        str;
d5733 1
a5733 1
  skip_whitespace (str);
d5735 1
a5735 6
  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d5737 1
a5737 2
  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 21, 3) == FAIL)
d5739 1
a5739 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5743 2
a5744 2
  if (skip_past_comma (& str) == FAIL
      || reg_required_here (& str, 12) == FAIL)
d5746 1
a5746 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5750 1
a5750 2
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
d5752 1
a5752 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5755 4
a5758 3

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
d5760 1
a5760 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d5763 2
a5764 12

  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  end_of_line (str);
a5766 1
/* ARM v5TEJ.  Jump to Jazelle code.  */
d5768 3
a5770 2
do_bxj (str)
     char * str;
d5772 12
a5783 1
  int reg;
d5785 1
a5785 1
  skip_whitespace (str);
d5787 2
a5788 1
  if ((reg = reg_required_here (&str, 0)) == FAIL)
d5790 15
a5804 2
      inst.error = BAD_ARGS;
      return;
d5806 2
a5807 6

  /* Note - it is not illegal to do a "bxj pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  end_of_line (str);
d6039 29
d6280 1
a6295 1
  return;
a6302 2

  return;
a6314 1
  return;
a6338 1
  return;
a6345 2

  return;
a6352 2

  return;
a6359 2

  return;
a6366 2

  return;
a6373 2

  return;
a6380 2

  return;
a6387 1
  return;
a6399 1
  return;
a6409 1
  return;
d6436 4
a6449 2
  
  return;
a6456 2

  return;
a6463 2

  return;
a6475 1
  return;
a6485 1
  return;
d6887 1
a6887 2
/* UNRESTRICT should be one if <shift> <register> is permitted for this
   instruction.  */
d6890 1
a6890 1
decode_shift (str, unrestrict)
d6892 1
a6892 1
     int     unrestrict;
d6922 20
d6951 1
a6951 1
  if (unrestrict && reg_required_here (& p, 8) != FAIL)
d6959 1
a6959 1
      inst.error = (unrestrict
d7021 1
a7021 1
   by altering the instuction.  A bit of a hack really.
a7273 1
  return;
d7296 1
d7298 1
d7329 1
d7331 1
a7333 2

  return;
a7357 1
  return;
a7381 1
  return;
d7437 1
a7437 1
	return decode_shift (str, SHIFT_RESTRICT);
a7631 1
  return;
a7709 1
  return;
a7964 1
  return;
a8160 1
  return;
a8178 2

  return;
a8238 1
  return;
a8282 1
  return;
a8363 1
  return;
a8398 1
  return;
a8459 1
  return;
a8478 1
  return;
a8673 1
  return;
a8697 1
  return;
a8721 1
  return;
a8745 1
  return;
a8765 1
  return;
a8863 1
  return;
a8883 1
  return;
a8905 1
  return;
a8927 1
  return;
a8947 1
  return;
d8951 1
a8951 1
do_vfp_sp_reg2 (str)
d8956 2
a8957 4
  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
a8973 1
  return;
d8994 26
a9019 1
  return;
a9039 1
  return;
a9061 1
  return;
a9081 1
  return;
d9096 1
a9096 1
      || reg_required_here (&str, 16))
a9103 1
  return;
a9181 1
  return;
a9201 1
  return;
a9225 1
  return;
a9249 1
  return;
a9615 1
  return;
a9631 1
  return;
a9651 1
  return;
a9671 1
  return;
d10016 1
a10016 1
  if (is_immediate_prefix (*str))
d10027 1
a10027 1
      if (Rs < 8 && Rd < 8)
d10041 1
a10041 1
	  else
d10571 1
a10571 1
/* cfmvsc32<cond> DSPSC,MVFX[15:0].  */
d10581 1
a10581 1
      || mav_reg_required_here (&str, 16, REG_TYPE_MVFX) == FAIL)
d10592 1
a10592 1
/* cfmv32sc<cond> MVFX[15:0],DSPSC.  */
d10600 1
a10600 1
  if (mav_reg_required_here (&str, 0, REG_TYPE_MVFX) == FAIL
d10921 1
a10921 1
    inst.instruction |= CP_T_UD; /* Postive, so set bit U.  */
a10929 1
  return;
a10937 1
  return;
d11039 1
a11039 1
  /* This definiton must agree with the one in gcc/config/arm/thumb.c.  */
a11310 1
  return;
d11386 6
a11391 5
  struct reg_entry *new =
    (struct reg_entry *) xmalloc (sizeof (struct reg_entry));
  char *name = xmalloc (strlen (str) + 1);
  strcpy (name, str);

d11394 1
d11396 8
a11403 1
  hash_insert (htab, name, (PTR) new);
d11408 1
a11408 1
   	newname .req existing_name
d11488 1
d11551 1
d11599 1
d11652 3
a11654 3
#if !(defined (TE_LINUX) || defined(TE_NetBSD) || defined(TE_OpenBSD))
      /* Some environments specify a default FPU.  If they don't, infer
	 it from the processor.  */
d11689 16
a11704 2
	|| (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
      flags |= F_SOFT_FLOAT;
d11709 1
a11709 3
    if (cpu_variant & ARM_CEXT_MAVERICK)
      {
	flags ^= F_SOFT_FLOAT;
a11710 1
      }
d11805 3
d11999 2
a12000 2
  /* The pattern was adjusted to accomodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accomodation.  */
d12365 1
a12365 1
	     branch instruciton itself, then we can compute the relocation for
d12822 10
d12993 1
d13019 1
d13325 1
d13335 3
d13344 1
a13344 1
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_NONE},
d13376 2
d13379 1
d13425 16
d13590 17
d13615 2
a13761 2

  return;
d13811 3
d14165 1
d14276 1
a14276 1
  /* We assume that there will never be a requirment
@


1.6
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d6 1
a24 1
#include <ctype.h>
d28 1
d42 47
a88 27
/* Types of processor to assemble for.  */
#define ARM_1		0x00000001
#define ARM_2		0x00000002
#define ARM_3		0x00000004
#define ARM_250		ARM_3
#define ARM_6		0x00000008
#define ARM_7		ARM_6           /* Same core instruction set.  */
#define ARM_8		ARM_6           /* Same core instruction set.  */
#define ARM_9		ARM_6           /* Same core instruction set.  */
#define ARM_CPU_MASK	0x0000000f

/* The following bitmasks control CPU extensions (ARM7 onwards):   */
#define ARM_EXT_LONGMUL	0x00000010	/* Allow long multiplies.  */
#define ARM_EXT_HALFWORD 0x00000020	/* Allow half word loads.  */
#define ARM_EXT_THUMB	0x00000040	/* Allow BX instruction.   */
#define ARM_EXT_V5	0x00000080	/* Allow CLZ, etc.         */
#define ARM_EXT_V5E	0x00000100	/* "El Segundo". 	   */
#define ARM_EXT_XSCALE	0x00000200	/* Allow MIA etc.  	   */

/* Architectures are the sum of the base and extensions.  */
#define ARM_ARCH_V3M     ARM_EXT_LONGMUL
#define ARM_ARCH_V4     (ARM_ARCH_V3M | ARM_EXT_HALFWORD)
#define ARM_ARCH_V4T	(ARM_ARCH_V4 | ARM_EXT_THUMB)
#define ARM_ARCH_V5	(ARM_ARCH_V4 | ARM_EXT_V5)
#define ARM_ARCH_V5T	(ARM_ARCH_V5 | ARM_EXT_THUMB)
#define ARM_ARCH_V5TE	(ARM_ARCH_V5T | ARM_EXT_V5E)
#define ARM_ARCH_XSCALE (ARM_ARCH_V5TE | ARM_EXT_XSCALE)
d91 33
a123 14
#define ARM_ANY		0x00ffffff
#define ARM_2UP		(ARM_ANY - ARM_1)
#define ARM_ALL		ARM_2UP		/* Not arm1 only.  */
#define ARM_3UP		0x00fffffc
#define ARM_6UP		0x00fffff8      /* Includes ARM7.  */

#define FPU_CORE	0x80000000
#define FPU_FPA10	0x40000000
#define FPU_FPA11	0x40000000
#define FPU_NONE	0

/* Some useful combinations.  */
#define FPU_ALL		0xff000000	/* Note this is ~ARM_ANY.  */
#define FPU_MEMMULTI	0x7f000000	/* Not fpu_core.  */
d127 1
a127 1
#define CPU_DEFAULT	(ARM_9 | ARM_ARCH_XSCALE)
d130 1
a130 1
#define CPU_DEFAULT 	(ARM_7 | ARM_ARCH_V4T)
d132 7
a138 1
#define CPU_DEFAULT 	ARM_ALL
d140 6
d149 1
d151 1
a151 1
#define FPU_DEFAULT FPU_ALL
d157 1
a157 1
static unsigned long cpu_variant = CPU_DEFAULT | FPU_DEFAULT;
a159 1
#if defined OBJ_COFF || defined OBJ_ELF
d161 17
a177 6
static boolean uses_apcs_26      = false;
static boolean atpcs             = false;
static boolean support_interwork = false;
static boolean uses_apcs_float   = false;
static boolean pic_code          = false;
#endif
d181 1
a181 1
CONST char comment_chars[] = "@@";
d190 1
a190 1
CONST char line_comment_chars[] = "#";
d192 1
a192 1
CONST char line_separator_chars[] = ";";
d196 1
a196 1
CONST char EXP_CHARS[] = "eE";
d202 1
a202 1
CONST char FLT_CHARS[] = "rRsSfFdDxXeEpP";
d214 1
a214 1
CONST int md_reloc_size = 8;
d229 1
a229 1
  CONST char *  error;
a230 1
  int           suffix;
d295 1
a295 1
CONST char * fp_const[] =
d308 4
a324 1
#define TRANS_BIT	 0x00200000
d330 1
a330 1
  CONST char *  template;
a333 1
/* This is to save a hash look-up in the common case.  */
d335 1
d337 1
a337 1
static CONST struct asm_cond conds[] =
d357 222
a578 4
/* Warning: If the top bit of the set_bits is set, then the standard
   instruction bitmask is ignored, and the new bitmask is taken from
   the set_bits:  */
struct asm_flg
d580 2
a581 2
  CONST char *  template;	/* Basic flag string.  */
  unsigned long set_bits;	/* Bits to set.  */
d584 12
a595 1
static CONST struct asm_flg s_flag[] =
d597 12
a608 1
  {"s", CONDS_BIT},
d612 4
a615 1
static CONST struct asm_flg ldr_flags[] =
d617 26
a642 7
  {"d",  DOUBLE_LOAD_FLAG},
  {"b",  0x00400000},
  {"t",  TRANS_BIT},
  {"bt", 0x00400000 | TRANS_BIT},
  {"h",  0x801000b0},
  {"sh", 0x801000f0},
  {"sb", 0x801000d0},
d646 2
a647 1
static CONST struct asm_flg str_flags[] =
d649 4
a652 5
  {"d",  DOUBLE_LOAD_FLAG},
  {"b",  0x00400000},
  {"t",  TRANS_BIT},
  {"bt", 0x00400000 | TRANS_BIT},
  {"h",  0x800000b0},
d656 2
a657 1
static CONST struct asm_flg byte_flag[] =
d659 9
a667 1
  {"b", 0x00400000},
d671 2
a672 1
static CONST struct asm_flg cmp_flags[] =
d674 2
a675 2
  {"s", CONDS_BIT},
  {"p", 0x0010f000},
d679 2
a680 1
static CONST struct asm_flg ldm_flags[] =
d682 8
a689 8
  {"ed", 0x01800000},
  {"fd", 0x00800000},
  {"ea", 0x01000000},
  {"fa", 0x00000000},
  {"ib", 0x01800000},
  {"ia", 0x00800000},
  {"db", 0x01000000},
  {"da", 0x00000000},
d693 2
a694 1
static CONST struct asm_flg stm_flags[] =
d696 4
a699 8
  {"ed", 0x00000000},
  {"fd", 0x01000000},
  {"ea", 0x00800000},
  {"fa", 0x01800000},
  {"ib", 0x01800000},
  {"ia", 0x00800000},
  {"db", 0x01000000},
  {"da", 0x00000000},
d703 2
a704 1
static CONST struct asm_flg lfm_flags[] =
d706 4
a709 2
  {"fd", 0x00800000},
  {"ea", 0x01000000},
d713 1
a713 1
static CONST struct asm_flg sfm_flags[] =
d715 4
a718 2
  {"fd", 0x01000000},
  {"ea", 0x00800000},
d722 1
a722 1
static CONST struct asm_flg round_flags[] =
d724 4
a727 3
  {"p", 0x00000020},
  {"m", 0x00000040},
  {"z", 0x00000060},
d731 6
a736 18
/* The implementation of the FIX instruction is broken on some assemblers,
   in that it accepts a precision specifier as well as a rounding specifier,
   despite the fact that this is meaningless.  To be more compatible, we
   accept it as well, though of course it does not set any bits.  */
static CONST struct asm_flg fix_flags[] =
{
  {"p", 0x00000020},
  {"m", 0x00000040},
  {"z", 0x00000060},
  {"sp", 0x00000020},
  {"sm", 0x00000040},
  {"sz", 0x00000060},
  {"dp", 0x00000020},
  {"dm", 0x00000040},
  {"dz", 0x00000060},
  {"ep", 0x00000020},
  {"em", 0x00000040},
  {"ez", 0x00000060},
d740 1
a740 1
static CONST struct asm_flg except_flag[] =
d742 1
a742 1
  {"e", 0x00400000},
d746 1
a746 1
static CONST struct asm_flg cplong_flag[] =
d748 1
a748 1
  {"l", 0x00400000},
d752 1
a752 1
struct asm_psr
d754 4
a757 3
  CONST char *  template;
  boolean       cpsr;
  unsigned long field;
d760 16
a775 2
/* The bit that distnguishes CPSR and SPSR.  */
#define SPSR_BIT   (1 << 22)
d777 17
a793 7
/* How many bits to shift the PSR_xxx bits up by.  */
#define PSR_SHIFT  16

#define PSR_c   (1 << 0)
#define PSR_x   (1 << 1)
#define PSR_s   (1 << 2)
#define PSR_f   (1 << 3)
d795 1
a795 139
static CONST struct asm_psr psrs[] =
{
  {"CPSR",	true,  PSR_c | PSR_f},
  {"CPSR_all",	true,  PSR_c | PSR_f},
  {"SPSR",	false, PSR_c | PSR_f},
  {"SPSR_all",	false, PSR_c | PSR_f},
  {"CPSR_flg",	true,  PSR_f},
  {"CPSR_f",    true,  PSR_f},
  {"SPSR_flg",	false, PSR_f},
  {"SPSR_f",    false, PSR_f},
  {"CPSR_c",	true,  PSR_c},
  {"CPSR_ctl",	true,  PSR_c},
  {"SPSR_c",	false, PSR_c},
  {"SPSR_ctl",	false, PSR_c},
  {"CPSR_x",    true,  PSR_x},
  {"CPSR_s",    true,  PSR_s},
  {"SPSR_x",    false, PSR_x},
  {"SPSR_s",    false, PSR_s},
  /* Combinations of flags.  */
  {"CPSR_fs",	true, PSR_f | PSR_s},
  {"CPSR_fx",	true, PSR_f | PSR_x},
  {"CPSR_fc",	true, PSR_f | PSR_c},
  {"CPSR_sf",	true, PSR_s | PSR_f},
  {"CPSR_sx",	true, PSR_s | PSR_x},
  {"CPSR_sc",	true, PSR_s | PSR_c},
  {"CPSR_xf",	true, PSR_x | PSR_f},
  {"CPSR_xs",	true, PSR_x | PSR_s},
  {"CPSR_xc",	true, PSR_x | PSR_c},
  {"CPSR_cf",	true, PSR_c | PSR_f},
  {"CPSR_cs",	true, PSR_c | PSR_s},
  {"CPSR_cx",	true, PSR_c | PSR_x},
  {"CPSR_fsx",	true, PSR_f | PSR_s | PSR_x},
  {"CPSR_fsc",	true, PSR_f | PSR_s | PSR_c},
  {"CPSR_fxs",	true, PSR_f | PSR_x | PSR_s},
  {"CPSR_fxc",	true, PSR_f | PSR_x | PSR_c},
  {"CPSR_fcs",	true, PSR_f | PSR_c | PSR_s},
  {"CPSR_fcx",	true, PSR_f | PSR_c | PSR_x},
  {"CPSR_sfx",	true, PSR_s | PSR_f | PSR_x},
  {"CPSR_sfc",	true, PSR_s | PSR_f | PSR_c},
  {"CPSR_sxf",	true, PSR_s | PSR_x | PSR_f},
  {"CPSR_sxc",	true, PSR_s | PSR_x | PSR_c},
  {"CPSR_scf",	true, PSR_s | PSR_c | PSR_f},
  {"CPSR_scx",	true, PSR_s | PSR_c | PSR_x},
  {"CPSR_xfs",	true, PSR_x | PSR_f | PSR_s},
  {"CPSR_xfc",	true, PSR_x | PSR_f | PSR_c},
  {"CPSR_xsf",	true, PSR_x | PSR_s | PSR_f},
  {"CPSR_xsc",	true, PSR_x | PSR_s | PSR_c},
  {"CPSR_xcf",	true, PSR_x | PSR_c | PSR_f},
  {"CPSR_xcs",	true, PSR_x | PSR_c | PSR_s},
  {"CPSR_cfs",	true, PSR_c | PSR_f | PSR_s},
  {"CPSR_cfx",	true, PSR_c | PSR_f | PSR_x},
  {"CPSR_csf",	true, PSR_c | PSR_s | PSR_f},
  {"CPSR_csx",	true, PSR_c | PSR_s | PSR_x},
  {"CPSR_cxf",	true, PSR_c | PSR_x | PSR_f},
  {"CPSR_cxs",	true, PSR_c | PSR_x | PSR_s},
  {"CPSR_fsxc",	true, PSR_f | PSR_s | PSR_x | PSR_c},
  {"CPSR_fscx",	true, PSR_f | PSR_s | PSR_c | PSR_x},
  {"CPSR_fxsc",	true, PSR_f | PSR_x | PSR_s | PSR_c},
  {"CPSR_fxcs",	true, PSR_f | PSR_x | PSR_c | PSR_s},
  {"CPSR_fcsx",	true, PSR_f | PSR_c | PSR_s | PSR_x},
  {"CPSR_fcxs",	true, PSR_f | PSR_c | PSR_x | PSR_s},
  {"CPSR_sfxc",	true, PSR_s | PSR_f | PSR_x | PSR_c},
  {"CPSR_sfcx",	true, PSR_s | PSR_f | PSR_c | PSR_x},
  {"CPSR_sxfc",	true, PSR_s | PSR_x | PSR_f | PSR_c},
  {"CPSR_sxcf",	true, PSR_s | PSR_x | PSR_c | PSR_f},
  {"CPSR_scfx",	true, PSR_s | PSR_c | PSR_f | PSR_x},
  {"CPSR_scxf",	true, PSR_s | PSR_c | PSR_x | PSR_f},
  {"CPSR_xfsc",	true, PSR_x | PSR_f | PSR_s | PSR_c},
  {"CPSR_xfcs",	true, PSR_x | PSR_f | PSR_c | PSR_s},
  {"CPSR_xsfc",	true, PSR_x | PSR_s | PSR_f | PSR_c},
  {"CPSR_xscf",	true, PSR_x | PSR_s | PSR_c | PSR_f},
  {"CPSR_xcfs",	true, PSR_x | PSR_c | PSR_f | PSR_s},
  {"CPSR_xcsf",	true, PSR_x | PSR_c | PSR_s | PSR_f},
  {"CPSR_cfsx",	true, PSR_c | PSR_f | PSR_s | PSR_x},
  {"CPSR_cfxs",	true, PSR_c | PSR_f | PSR_x | PSR_s},
  {"CPSR_csfx",	true, PSR_c | PSR_s | PSR_f | PSR_x},
  {"CPSR_csxf",	true, PSR_c | PSR_s | PSR_x | PSR_f},
  {"CPSR_cxfs",	true, PSR_c | PSR_x | PSR_f | PSR_s},
  {"CPSR_cxsf",	true, PSR_c | PSR_x | PSR_s | PSR_f},
  {"SPSR_fs",	false, PSR_f | PSR_s},
  {"SPSR_fx",	false, PSR_f | PSR_x},
  {"SPSR_fc",	false, PSR_f | PSR_c},
  {"SPSR_sf",	false, PSR_s | PSR_f},
  {"SPSR_sx",	false, PSR_s | PSR_x},
  {"SPSR_sc",	false, PSR_s | PSR_c},
  {"SPSR_xf",	false, PSR_x | PSR_f},
  {"SPSR_xs",	false, PSR_x | PSR_s},
  {"SPSR_xc",	false, PSR_x | PSR_c},
  {"SPSR_cf",	false, PSR_c | PSR_f},
  {"SPSR_cs",	false, PSR_c | PSR_s},
  {"SPSR_cx",	false, PSR_c | PSR_x},
  {"SPSR_fsx",	false, PSR_f | PSR_s | PSR_x},
  {"SPSR_fsc",	false, PSR_f | PSR_s | PSR_c},
  {"SPSR_fxs",	false, PSR_f | PSR_x | PSR_s},
  {"SPSR_fxc",	false, PSR_f | PSR_x | PSR_c},
  {"SPSR_fcs",	false, PSR_f | PSR_c | PSR_s},
  {"SPSR_fcx",	false, PSR_f | PSR_c | PSR_x},
  {"SPSR_sfx",	false, PSR_s | PSR_f | PSR_x},
  {"SPSR_sfc",	false, PSR_s | PSR_f | PSR_c},
  {"SPSR_sxf",	false, PSR_s | PSR_x | PSR_f},
  {"SPSR_sxc",	false, PSR_s | PSR_x | PSR_c},
  {"SPSR_scf",	false, PSR_s | PSR_c | PSR_f},
  {"SPSR_scx",	false, PSR_s | PSR_c | PSR_x},
  {"SPSR_xfs",	false, PSR_x | PSR_f | PSR_s},
  {"SPSR_xfc",	false, PSR_x | PSR_f | PSR_c},
  {"SPSR_xsf",	false, PSR_x | PSR_s | PSR_f},
  {"SPSR_xsc",	false, PSR_x | PSR_s | PSR_c},
  {"SPSR_xcf",	false, PSR_x | PSR_c | PSR_f},
  {"SPSR_xcs",	false, PSR_x | PSR_c | PSR_s},
  {"SPSR_cfs",	false, PSR_c | PSR_f | PSR_s},
  {"SPSR_cfx",	false, PSR_c | PSR_f | PSR_x},
  {"SPSR_csf",	false, PSR_c | PSR_s | PSR_f},
  {"SPSR_csx",	false, PSR_c | PSR_s | PSR_x},
  {"SPSR_cxf",	false, PSR_c | PSR_x | PSR_f},
  {"SPSR_cxs",	false, PSR_c | PSR_x | PSR_s},
  {"SPSR_fsxc",	false, PSR_f | PSR_s | PSR_x | PSR_c},
  {"SPSR_fscx",	false, PSR_f | PSR_s | PSR_c | PSR_x},
  {"SPSR_fxsc",	false, PSR_f | PSR_x | PSR_s | PSR_c},
  {"SPSR_fxcs",	false, PSR_f | PSR_x | PSR_c | PSR_s},
  {"SPSR_fcsx",	false, PSR_f | PSR_c | PSR_s | PSR_x},
  {"SPSR_fcxs",	false, PSR_f | PSR_c | PSR_x | PSR_s},
  {"SPSR_sfxc",	false, PSR_s | PSR_f | PSR_x | PSR_c},
  {"SPSR_sfcx",	false, PSR_s | PSR_f | PSR_c | PSR_x},
  {"SPSR_sxfc",	false, PSR_s | PSR_x | PSR_f | PSR_c},
  {"SPSR_sxcf",	false, PSR_s | PSR_x | PSR_c | PSR_f},
  {"SPSR_scfx",	false, PSR_s | PSR_c | PSR_f | PSR_x},
  {"SPSR_scxf",	false, PSR_s | PSR_c | PSR_x | PSR_f},
  {"SPSR_xfsc",	false, PSR_x | PSR_f | PSR_s | PSR_c},
  {"SPSR_xfcs",	false, PSR_x | PSR_f | PSR_c | PSR_s},
  {"SPSR_xsfc",	false, PSR_x | PSR_s | PSR_f | PSR_c},
  {"SPSR_xscf",	false, PSR_x | PSR_s | PSR_c | PSR_f},
  {"SPSR_xcfs",	false, PSR_x | PSR_c | PSR_f | PSR_s},
  {"SPSR_xcsf",	false, PSR_x | PSR_c | PSR_s | PSR_f},
  {"SPSR_cfsx",	false, PSR_c | PSR_f | PSR_s | PSR_x},
  {"SPSR_cfxs",	false, PSR_c | PSR_f | PSR_x | PSR_s},
  {"SPSR_csfx",	false, PSR_c | PSR_s | PSR_f | PSR_x},
  {"SPSR_csxf",	false, PSR_c | PSR_s | PSR_x | PSR_f},
  {"SPSR_cxfs",	false, PSR_c | PSR_x | PSR_f | PSR_s},
  {"SPSR_cxsf",	false, PSR_c | PSR_x | PSR_s | PSR_f},
d800 9
a808 7
static void do_arit		PARAMS ((char *, unsigned long));
static void do_cmp		PARAMS ((char *, unsigned long));
static void do_mov		PARAMS ((char *, unsigned long));
static void do_ldst		PARAMS ((char *, unsigned long));
static void do_ldmstm		PARAMS ((char *, unsigned long));
static void do_branch		PARAMS ((char *, unsigned long));
static void do_swi		PARAMS ((char *, unsigned long));
d810 42
a851 33
static void do_adr		PARAMS ((char *, unsigned long));
static void do_adrl		PARAMS ((char *, unsigned long));
static void do_nop		PARAMS ((char *, unsigned long));
/* ARM 2.  */
static void do_mul		PARAMS ((char *, unsigned long));
static void do_mla		PARAMS ((char *, unsigned long));
/* ARM 3.  */
static void do_swap		PARAMS ((char *, unsigned long));
/* ARM 6.  */
static void do_msr		PARAMS ((char *, unsigned long));
static void do_mrs		PARAMS ((char *, unsigned long));
/* ARM 7M.  */
static void do_mull		PARAMS ((char *, unsigned long));
/* ARM THUMB.  */
static void do_bx               PARAMS ((char *, unsigned long));

/* ARM_EXT_XScale.  */
static void do_mia		PARAMS ((char *, unsigned long));
static void do_mar		PARAMS ((char *, unsigned long));
static void do_mra		PARAMS ((char *, unsigned long));
static void do_pld		PARAMS ((char *, unsigned long));
static void do_ldrd		PARAMS ((char *, unsigned long));

/* ARM_EXT_V5.  */
static void do_blx		PARAMS ((char *, unsigned long));
static void do_bkpt		PARAMS ((char *, unsigned long));
static void do_clz		PARAMS ((char *, unsigned long));
static void do_lstc2		PARAMS ((char *, unsigned long));
static void do_cdp2		PARAMS ((char *, unsigned long));
static void do_co_reg2		PARAMS ((char *, unsigned long));

static void do_t_blx		PARAMS ((char *));
static void do_t_bkpt		PARAMS ((char *));
d853 2
a854 6
/* ARM_EXT_V5E.  */
static void do_smla		PARAMS ((char *, unsigned long));
static void do_smlal		PARAMS ((char *, unsigned long));
static void do_smul		PARAMS ((char *, unsigned long));
static void do_qadd		PARAMS ((char *, unsigned long));
static void do_co_reg2c		PARAMS ((char *, unsigned long));
d857 113
a969 16
static void do_cdp		PARAMS ((char *, unsigned long));
static void do_lstc		PARAMS ((char *, unsigned long));
static void do_co_reg		PARAMS ((char *, unsigned long));
static void do_fp_ctrl		PARAMS ((char *, unsigned long));
static void do_fp_ldst		PARAMS ((char *, unsigned long));
static void do_fp_ldmstm	PARAMS ((char *, unsigned long));
static void do_fp_dyadic	PARAMS ((char *, unsigned long));
static void do_fp_monadic	PARAMS ((char *, unsigned long));
static void do_fp_cmp		PARAMS ((char *, unsigned long));
static void do_fp_from_reg	PARAMS ((char *, unsigned long));
static void do_fp_to_reg	PARAMS ((char *, unsigned long));

static void fix_new_arm		PARAMS ((fragS *, int, short, expressionS *, int, int));
static int arm_reg_parse	PARAMS ((char **));
static CONST struct asm_psr * arm_psr_parse PARAMS ((char **));
static void symbol_locate	PARAMS ((symbolS *, CONST char *, segT, valueT, fragS *));
d972 2
a973 1
static unsigned validate_immediate_twopart PARAMS ((unsigned int, unsigned int *));
d983 8
d992 1
a992 1
static int cp_address_required_here	PARAMS ((char **));
d1002 2
a1003 1
static int ldst_extend		PARAMS ((char **, int));
d1005 2
a1006 1
static void insert_reg		PARAMS ((int));
d1009 1
d1012 8
a1019 2
static void insert_reg_alias	PARAMS ((char *, int));
static void output_inst		PARAMS ((void));
d1024 25
d1053 17
a1069 4
/* LONGEST_INST is the longest basic instruction name without
   conditions or flags.  ARM7M has 4 of length 5.  El Segundo
   has one basic instruction name of length 7 (SMLALxy).  */
#define LONGEST_INST 7
d1074 1
a1074 1
  CONST char * template;
d1079 3
a1081 6
  /* Compulsory suffix that must follow conds.  If "", then the
     instruction is not conditional and must have no suffix.  */
  CONST char * comp_suffix;

  /* Bits to toggle if flag 'n' set.  */
  CONST struct asm_flg * flags;
d1083 2
a1084 2
  /* Which CPU variants this exists for.  */
  unsigned long variants;
d1087 1
a1087 1
  void (* parms) PARAMS ((char *, unsigned long));
d1090 1
a1090 1
static CONST struct asm_opcode insns[] =
d1092 68
a1159 35
/* Intel XScale extensions to ARM V5 ISA.  */
  {"mia",   0x0e200010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miaph", 0x0e280010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miabb", 0x0e2c0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miabt", 0x0e2d0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miatb", 0x0e2e0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miatt", 0x0e2f0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"mar",   0x0c400000, NULL,   NULL,        ARM_EXT_XSCALE, do_mar},
  {"mra",   0x0c500000, NULL,   NULL,        ARM_EXT_XSCALE, do_mra},
  {"pld",   0xf450f000, "",     NULL,        ARM_EXT_XSCALE, do_pld},
  {"ldr",   0x000000d0, NULL,   ldr_flags,   ARM_ANY,        do_ldrd},
  {"str",   0x000000f0, NULL,   str_flags,   ARM_ANY,        do_ldrd},

/* ARM Instructions.  */
  {"and",   0x00000000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"eor",   0x00200000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"sub",   0x00400000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"rsb",   0x00600000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"add",   0x00800000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"adc",   0x00a00000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"sbc",   0x00c00000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"rsc",   0x00e00000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"orr",   0x01800000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"bic",   0x01c00000, NULL,   s_flag,      ARM_ANY,      do_arit},
  {"tst",   0x01000000, NULL,   cmp_flags,   ARM_ANY,      do_cmp},
  {"teq",   0x01200000, NULL,   cmp_flags,   ARM_ANY,      do_cmp},
  {"cmp",   0x01400000, NULL,   cmp_flags,   ARM_ANY,      do_cmp},
  {"cmn",   0x01600000, NULL,   cmp_flags,   ARM_ANY,      do_cmp},
  {"mov",   0x01a00000, NULL,   s_flag,      ARM_ANY,      do_mov},
  {"mvn",   0x01e00000, NULL,   s_flag,      ARM_ANY,      do_mov},
  {"str",   0x04000000, NULL,   str_flags,   ARM_ANY,      do_ldst},
  {"ldr",   0x04100000, NULL,   ldr_flags,   ARM_ANY,      do_ldst},
  {"stm",   0x08000000, NULL,   stm_flags,   ARM_ANY,      do_ldmstm},
  {"ldm",   0x08100000, NULL,   ldm_flags,   ARM_ANY,      do_ldmstm},
  {"swi",   0x0f000000, NULL,   NULL,        ARM_ANY,      do_swi},
d1161 3
a1163 2
  {"bl",    0x0b000000, NULL,   NULL,        ARM_ANY,      do_branch},
  {"b",     0x0a000000, NULL,   NULL,        ARM_ANY,      do_branch},
d1165 2
a1166 2
  {"bl",    0x0bfffffe, NULL,   NULL,        ARM_ANY,      do_branch},
  {"b",     0x0afffffe, NULL,   NULL,        ARM_ANY,      do_branch},
d1169 911
a2079 124
/* Pseudo ops.  */
  {"adr",   0x028f0000, NULL,   NULL,        ARM_ANY,      do_adr},
  {"adrl",  0x028f0000, NULL,   NULL,        ARM_ANY,      do_adrl},
  {"nop",   0x01a00000, NULL,   NULL,        ARM_ANY,      do_nop},

/* ARM 2 multiplies.  */
  {"mul",   0x00000090, NULL,   s_flag,      ARM_2UP,      do_mul},
  {"mla",   0x00200090, NULL,   s_flag,      ARM_2UP,      do_mla},

/* ARM 3 - swp instructions.  */
  {"swp",   0x01000090, NULL,   byte_flag,   ARM_3UP,      do_swap},

/* ARM 6 Coprocessor instructions.  */
  {"mrs",   0x010f0000, NULL,   NULL,        ARM_6UP,      do_mrs},
  {"msr",   0x0120f000, NULL,   NULL,        ARM_6UP,      do_msr},
/* ScottB: our code uses 0x0128f000 for msr.
   NickC:  but this is wrong because the bits 16 through 19 are
           handled by the PSR_xxx defines above.  */

/* ARM 7M long multiplies - need signed/unsigned flags!  */
  {"smull", 0x00c00090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
  {"umull", 0x00800090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
  {"smlal", 0x00e00090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
  {"umlal", 0x00a00090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},

/* ARM THUMB interworking.  */
  {"bx",    0x012fff10, NULL,   NULL,        ARM_EXT_THUMB,    do_bx},

/* Floating point instructions.  */
  {"wfs",   0x0e200110, NULL,   NULL,        FPU_ALL,      do_fp_ctrl},
  {"rfs",   0x0e300110, NULL,   NULL,        FPU_ALL,      do_fp_ctrl},
  {"wfc",   0x0e400110, NULL,   NULL,        FPU_ALL,      do_fp_ctrl},
  {"rfc",   0x0e500110, NULL,   NULL,        FPU_ALL,      do_fp_ctrl},
  {"ldf",   0x0c100100, "sdep", NULL,        FPU_ALL,      do_fp_ldst},
  {"stf",   0x0c000100, "sdep", NULL,        FPU_ALL,      do_fp_ldst},
  {"lfm",   0x0c100200, NULL,   lfm_flags,   FPU_MEMMULTI, do_fp_ldmstm},
  {"sfm",   0x0c000200, NULL,   sfm_flags,   FPU_MEMMULTI, do_fp_ldmstm},
  {"mvf",   0x0e008100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"mnf",   0x0e108100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"abs",   0x0e208100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"rnd",   0x0e308100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"sqt",   0x0e408100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"log",   0x0e508100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"lgn",   0x0e608100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"exp",   0x0e708100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"sin",   0x0e808100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"cos",   0x0e908100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"tan",   0x0ea08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"asn",   0x0eb08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"acs",   0x0ec08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"atn",   0x0ed08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"urd",   0x0ee08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"nrm",   0x0ef08100, "sde",  round_flags, FPU_ALL,      do_fp_monadic},
  {"adf",   0x0e000100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"suf",   0x0e200100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"rsf",   0x0e300100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"muf",   0x0e100100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"dvf",   0x0e400100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"rdf",   0x0e500100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"pow",   0x0e600100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"rpw",   0x0e700100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"rmf",   0x0e800100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"fml",   0x0e900100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"fdv",   0x0ea00100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"frd",   0x0eb00100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"pol",   0x0ec00100, "sde",  round_flags, FPU_ALL,      do_fp_dyadic},
  {"cmf",   0x0e90f110, NULL,   except_flag, FPU_ALL,      do_fp_cmp},
  {"cnf",   0x0eb0f110, NULL,   except_flag, FPU_ALL,      do_fp_cmp},
/* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should not
   be an optional suffix, but part of the instruction.  To be compatible,
   we accept either.  */
  {"cmfe",  0x0ed0f110, NULL,   NULL,        FPU_ALL,      do_fp_cmp},
  {"cnfe",  0x0ef0f110, NULL,   NULL,        FPU_ALL,      do_fp_cmp},
  {"flt",   0x0e000110, "sde",  round_flags, FPU_ALL,      do_fp_from_reg},
  {"fix",   0x0e100110, NULL,   fix_flags,   FPU_ALL,      do_fp_to_reg},

/* Generic copressor instructions.  */
  {"cdp",   0x0e000000, NULL,  NULL,         ARM_2UP,      do_cdp},
  {"ldc",   0x0c100000, NULL,  cplong_flag,  ARM_2UP,      do_lstc},
  {"stc",   0x0c000000, NULL,  cplong_flag,  ARM_2UP,      do_lstc},
  {"mcr",   0x0e000010, NULL,  NULL,         ARM_2UP,      do_co_reg},
  {"mrc",   0x0e100010, NULL,  NULL,         ARM_2UP,      do_co_reg},

/*  ARM ISA extension 5.  */
/* Note: blx is actually 2 opcodes, so the .value is set dynamically.
   And it's sometimes conditional and sometimes not.  */
  {"blx",            0, NULL,   NULL,        ARM_EXT_V5, do_blx},
  {"clz",   0x016f0f10, NULL,   NULL,        ARM_EXT_V5, do_clz},
  {"bkpt",  0xe1200070, "",   	NULL,        ARM_EXT_V5, do_bkpt},
  {"ldc2",  0xfc100000, "",  	cplong_flag, ARM_EXT_V5, do_lstc2},
  {"stc2",  0xfc000000, "",  	cplong_flag, ARM_EXT_V5, do_lstc2},
  {"cdp2",  0xfe000000, "",  	NULL,        ARM_EXT_V5, do_cdp2},
  {"mcr2",  0xfe000010, "",  	NULL,        ARM_EXT_V5, do_co_reg2},
  {"mrc2",  0xfe100010, "",  	NULL,        ARM_EXT_V5, do_co_reg2},

/*  ARM ISA extension 5E, El Segundo.  */
  {"smlabb", 0x01000080, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlatb", 0x010000a0, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlabt", 0x010000c0, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlatt", 0x010000e0, NULL,   NULL,        ARM_EXT_V5E, do_smla},

  {"smlawb", 0x01200080, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlawt", 0x012000c0, NULL,   NULL,        ARM_EXT_V5E, do_smla},

  {"smlalbb",0x01400080, NULL,   NULL,        ARM_EXT_V5E, do_smlal},
  {"smlaltb",0x014000a0, NULL,   NULL,        ARM_EXT_V5E, do_smlal},
  {"smlalbt",0x014000c0, NULL,   NULL,        ARM_EXT_V5E, do_smlal},
  {"smlaltt",0x014000e0, NULL,   NULL,        ARM_EXT_V5E, do_smlal},

  {"smulbb", 0x01600080, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smultb", 0x016000a0, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smulbt", 0x016000c0, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smultt", 0x016000e0, NULL,   NULL,        ARM_EXT_V5E, do_smul},

  {"smulwb", 0x012000a0, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smulwt", 0x012000e0, NULL,   NULL,        ARM_EXT_V5E, do_smul},

  {"qadd",   0x01000050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},
  {"qdadd",  0x01400050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},
  {"qsub",   0x01200050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},
  {"qdsub",  0x01600050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},

  {"mcrr",  0x0c400000, NULL,   NULL,         ARM_EXT_V5E, do_co_reg2c},
  {"mrrc",  0x0c500000, NULL,   NULL,         ARM_EXT_V5E, do_co_reg2c},
a2092 1
#define COND_MASK	0xf0000000
d2094 2
d2116 1
d2142 4
d2228 1
a2228 1
  CONST char * template;
d2236 1
a2236 1
  unsigned long variants;
d2242 1
a2242 1
static CONST struct thumb_opcode tinsns[] =
d2244 56
a2299 57
  {"adc",	0x4140,		2,	ARM_EXT_THUMB, do_t_arit},
  {"add",	0x0000,		2,	ARM_EXT_THUMB, do_t_add},
  {"and",	0x4000,		2,	ARM_EXT_THUMB, do_t_arit},
  {"asr",	0x0000,		2,	ARM_EXT_THUMB, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_EXT_THUMB, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_EXT_THUMB, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_EXT_THUMB, do_t_branch23},
  {"blx",	0,		0,	ARM_EXT_V5, do_t_blx},
  {"bkpt",	0xbe00,		2,	ARM_EXT_V5, do_t_bkpt},
  {"bx",	0x4700,		2,	ARM_EXT_THUMB, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_EXT_THUMB, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_EXT_THUMB, do_t_compare},
  {"eor",	0x4040,		2,	ARM_EXT_THUMB, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_EXT_THUMB, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_EXT_THUMB, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_EXT_THUMB, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_EXT_THUMB, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_EXT_THUMB, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_EXT_THUMB, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_EXT_THUMB, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_EXT_THUMB, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_EXT_THUMB, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_EXT_THUMB, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_EXT_THUMB, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_EXT_THUMB, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_EXT_THUMB, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_EXT_THUMB, do_t_arit},
  {"orr",	0x4300,		2,	ARM_EXT_THUMB, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_EXT_THUMB, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_EXT_THUMB, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_EXT_THUMB, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_EXT_THUMB, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_EXT_THUMB, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_EXT_THUMB, do_t_str},
  {"strb",	0x0000,		2,	ARM_EXT_THUMB, do_t_strb},
  {"strh",	0x0000,		2,	ARM_EXT_THUMB, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_EXT_THUMB, do_t_swi},
  {"sub",	0x0000,		2,	ARM_EXT_THUMB, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_EXT_THUMB, do_t_arit},
d2301 5
a2305 52
  {"adr",       0x0000,         2,      ARM_EXT_THUMB, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_EXT_THUMB, do_t_nop},      /* mov r8,r8  */
};

struct reg_entry
{
  CONST char * name;
  int          number;
};

#define int_register(reg) ((reg) >= 0 && (reg) <= 15)
#define cp_register(reg) ((reg) >= 32 && (reg) <= 47)
#define fp_register(reg) ((reg) >= 16 && (reg) <= 23)

#define REG_PC	15
#define REG_LR  14
#define REG_SP  13

/* These are the standard names.  Users can add aliases with .req.  */
static CONST struct reg_entry reg_table[] =
{
  /* Processor Register Numbers.  */
  {"r0", 0},    {"r1", 1},      {"r2", 2},      {"r3", 3},
  {"r4", 4},    {"r5", 5},      {"r6", 6},      {"r7", 7},
  {"r8", 8},    {"r9", 9},      {"r10", 10},    {"r11", 11},
  {"r12", 12},  {"r13", REG_SP},{"r14", REG_LR},{"r15", REG_PC},
  /* APCS conventions.  */
  {"a1", 0},	{"a2", 1},    {"a3", 2},     {"a4", 3},
  {"v1", 4},	{"v2", 5},    {"v3", 6},     {"v4", 7},     {"v5", 8},
  {"v6", 9},	{"sb", 9},    {"v7", 10},    {"sl", 10},
  {"fp", 11},	{"ip", 12},   {"sp", REG_SP},{"lr", REG_LR},{"pc", REG_PC},
  /* ATPCS additions to APCS conventions.  */
  {"wr", 7},    {"v8", 11},
  /* FP Registers.  */
  {"f0", 16},   {"f1", 17},   {"f2", 18},   {"f3", 19},
  {"f4", 20},   {"f5", 21},   {"f6", 22},   {"f7", 23},
  {"c0", 32},   {"c1", 33},   {"c2", 34},   {"c3", 35},
  {"c4", 36},   {"c5", 37},   {"c6", 38},   {"c7", 39},
  {"c8", 40},   {"c9", 41},   {"c10", 42},  {"c11", 43},
  {"c12", 44},  {"c13", 45},  {"c14", 46},  {"c15", 47},
  {"cr0", 32},  {"cr1", 33},  {"cr2", 34},  {"cr3", 35},
  {"cr4", 36},  {"cr5", 37},  {"cr6", 38},  {"cr7", 39},
  {"cr8", 40},  {"cr9", 41},  {"cr10", 42}, {"cr11", 43},
  {"cr12", 44}, {"cr13", 45}, {"cr14", 46}, {"cr15", 47},
  /* ATPCS additions to float register names.  */
  {"s0",16},	{"s1",17},	{"s2",18},	{"s3",19},
  {"s4",20},	{"s5",21},	{"s6",22},	{"s7",23},
  {"d0",16},	{"d1",17},	{"d2",18},	{"d3",19},
  {"d4",20},	{"d5",21},	{"d6",22},	{"d7",23},
  /* FIXME: At some point we need to add VFP register names.  */
  /* Array terminator.  */
  {NULL, 0}
d2308 1
a2308 1
#define BAD_ARGS 	_("Bad arguments to instruction")
d2310 1
a2310 2
#define BAD_FLAGS 	_("Instruction should not have flags")
#define BAD_COND 	_("Instruction is not conditional")
a2316 1
static struct hash_control * arm_reg_hsh   = NULL;
a2335 2
static void arm_s_text PARAMS ((int));
static void arm_s_data PARAMS ((int));
a2336 1
static void arm_s_section PARAMS ((int));
d2342 1
a2342 1
CONST pseudo_typeS md_pseudo_table[] =
a2356 3
  /* Allow for the effect of section changes.  */
  { "text",        arm_s_text,    0 },
  { "data",        arm_s_data,    0 },
a2357 4
  { "section",     arm_s_section, 0 },
  { "section.s",   arm_s_section, 0 },
  { "sect",        arm_s_section, 0 },
  { "sect.s",      arm_s_section, 0 },
d2360 1
a2360 1
  { "file",        dwarf2_directive_file, 0 },
d2371 9
d2391 1
a2391 1
static int label_is_thumb_function_name = false;
d2393 1
a2393 1
/* Literal stuff.  */
d2397 36
a2432 1
typedef struct literalS
d2434 12
a2445 3
  struct expressionS exp;
  struct arm_it *    inst;
} literalT;
d2447 5
a2451 1
literalT literals[MAX_LITERAL_POOL_SIZE];
d2453 3
a2455 2
/* Next free entry in the pool.  */
int next_literal_pool_place = 0;
d2457 7
a2463 2
/* Next literal pool number.  */
int lit_pool_num = 1;
d2465 3
a2467 1
symbolS * current_poolP = NULL;
d2469 2
d2474 2
a2475 1
  int lit_count = 0;
d2477 8
a2484 10
  if (current_poolP == NULL)
    current_poolP = symbol_create (FAKE_LABEL_NAME, undefined_section,
				   (valueT) 0, &zero_address_frag);

  /* Check if this literal value is already in the pool:  */
  while (lit_count < next_literal_pool_place)
    {
      if (literals[lit_count].exp.X_op == inst.reloc.exp.X_op
	  && inst.reloc.exp.X_op == O_constant
	  && (literals[lit_count].exp.X_add_number
d2486 2
a2487 1
	  && literals[lit_count].exp.X_unsigned == inst.reloc.exp.X_unsigned)
d2490 3
a2492 3
      if (literals[lit_count].exp.X_op == inst.reloc.exp.X_op
          && inst.reloc.exp.X_op == O_symbol
          && (literals[lit_count].exp.X_add_number
d2494 1
a2494 1
          && (literals[lit_count].exp.X_add_symbol
d2496 1
a2496 1
          && (literals[lit_count].exp.X_op_symbol
a2498 2

      lit_count++;
d2501 2
a2502 1
  if (lit_count == next_literal_pool_place) /* New entry.  */
d2504 1
a2504 1
      if (next_literal_pool_place >= MAX_LITERAL_POOL_SIZE)
d2506 1
a2506 1
	  inst.error = _("Literal Pool Overflow");
d2510 2
a2511 2
      literals[next_literal_pool_place].exp = inst.reloc.exp;
      lit_count = next_literal_pool_place++;
d2514 3
a2516 3
  inst.reloc.exp.X_op = O_symbol;
  inst.reloc.exp.X_add_number = (lit_count) * 4 - 8;
  inst.reloc.exp.X_add_symbol = current_poolP;
d2527 1
a2527 1
     CONST char * name;		/* It is copied, the caller can modify.  */
d2552 1
a2552 1
  symbol_clear_list_pointers(symbolP);
d2648 1
a2648 1
  as_bad (_("Invalid syntax for .req directive."));
d2678 2
a2679 1
  int lit_count = 0;
d2682 4
a2685 1
  if (current_poolP == NULL)
d2695 1
a2695 1
  sprintf (sym_name, "$$lit_\002%x", lit_pool_num++);
d2697 1
a2697 1
  symbol_locate (current_poolP, sym_name, now_seg,
d2699 1
a2699 1
  symbol_table_insert (current_poolP);
d2701 1
a2701 1
  ARM_SET_THUMB (current_poolP, thumb_mode);
d2704 1
a2704 1
  ARM_SET_INTERWORK (current_poolP, support_interwork);
d2707 1
a2707 1
  while (lit_count < next_literal_pool_place)
d2709 1
a2709 1
    emit_expr (&(literals[lit_count++].exp), 4); /* .word  */
d2711 3
a2713 2
  next_literal_pool_place = 0;
  current_poolP = NULL;
d2728 1
a2728 1
    as_bad (_("Alignment too large: %d. assumed."), temp = max_alignment);
d2731 1
a2731 1
      as_bad (_("Alignment negative. 0 assumed."));
d2782 1
a2782 1
  label_is_thumb_function_name = true;
d2815 1
a2815 1
      as_bad (_("Expected comma after name \"%s\""), name);
a2879 46
/* If we change section we must dump the literal pool first.  */

static void
arm_s_text (ignore)
     int ignore;
{
  if (now_seg != text_section)
    s_ltorg (0);

#ifdef OBJ_ELF
  obj_elf_text (ignore);
#else
  s_text (ignore);
#endif
}

static void
arm_s_data (ignore)
     int ignore;
{
  if (flag_readonly_data_in_text)
    {
      if (now_seg != text_section)
	s_ltorg (0);
    }
  else if (now_seg != data_section)
    s_ltorg (0);

#ifdef OBJ_ELF
  obj_elf_data (ignore);
#else
  s_data (ignore);
#endif
}

#ifdef OBJ_ELF
static void
arm_s_section (ignore)
     int ignore;
{
  s_ltorg (0);

  obj_elf_section (ignore);
}
#endif

d2889 1
a2889 1
	  if (! (cpu_variant & ARM_EXT_THUMB))
d2902 1
a2902 1
	  if ((cpu_variant & ARM_ANY) == ARM_EXT_THUMB)
d2908 1
a2908 1
            frag_align (2, 0, 0);
d2910 1
a2910 1
          record_alignment (now_seg, 1);
d2956 1
a2956 1
     char * str;
d2960 2
a2961 2
  if (* str != '\0')
    inst.error = _("Garbage following instruction");
d2999 1
a2999 1
  if ((reg = arm_reg_parse (str)) != FAIL && int_register (reg))
d3011 52
a3062 1
  sprintf (buff, _("Register expected, not '%.100s'"), start);
d3068 1
a3068 1
static CONST struct asm_psr *
d3075 1
a3075 1
  CONST struct asm_psr * psr;
d3084 1
a3084 1
  while (isalpha (c) || c == '_');
d3097 1
a3097 1
  psr = (CONST struct asm_psr *) hash_find (arm_psr_hsh, start);
d3116 1
a3116 1
  CONST struct asm_psr * psr;
d3143 1
a3143 1
     char ** str;
d3146 1
d3148 2
a3149 1
  skip_whitespace (* str);
d3154 4
a3157 2
  if (**str == 'p' || **str == 'P')
    (*str)++;
d3159 2
a3160 5
  pchar = *(*str)++;
  if (pchar >= '0' && pchar <= '9')
    {
      processor = pchar - '0';
      if (**str >= '0' && **str <= '9')
d3162 2
a3163 2
	  processor = processor * 10 + *(*str)++ - '0';
	  if (processor > 15)
d3165 6
a3170 2
	      inst.error = _("Illegal co-processor number");
	      return FAIL;
d3173 5
a3177 5
    }
  else
    {
      inst.error = _("Bad or missing co-processor number");
      return FAIL;
d3222 1
a3222 1
  if ((reg = arm_reg_parse (str)) != FAIL && cp_register (reg))
a3223 1
      reg &= 15;
d3230 1
a3230 1
  inst.error = _("Co-processor register expected");
d3245 1
a3245 1
  if ((reg = arm_reg_parse (str)) != FAIL && fp_register (reg))
a3246 1
      reg &= 7;
d3253 1
a3253 1
  inst.error = _("Floating point register expected");
d3309 1
a3309 1
cp_address_required_here (str)
d3311 1
d3333 1
a3333 1
	  if (skip_past_comma (& p) == SUCCESS)
d3375 1
a3375 1
	  if (*p == '!')
d3405 3
a3407 4
static void
do_nop (str, flags)
     char * str;
     unsigned long flags;
d3409 1
a3409 5
  /* Do nothing really.  */
  inst.instruction |= flags; /* This is pointless.  */
  end_of_line (str);
  return;
}
d3411 1
a3411 6
static void
do_mrs (str, flags)
     char *str;
     unsigned long flags;
{
  int skip = 0;
d3413 1
a3413 4
  /* Only one syntax.  */
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
d3415 2
a3416 2
      inst.error = BAD_ARGS;
      return;
d3419 6
a3424 1
  if (skip_past_comma (&str) == FAIL)
d3426 7
a3432 3
      inst.error = _("comma expected after register name");
      return;
    }
d3434 4
a3437 1
  skip_whitespace (str);
d3439 2
a3440 11
  if (   strcmp (str, "CPSR") == 0
      || strcmp (str, "SPSR") == 0
	 /* Lower case versions for backwards compatability.  */
      || strcmp (str, "cpsr") == 0
      || strcmp (str, "spsr") == 0)
    skip = 4;

  /* This is for backwards compatability with older toolchains.  */
  else if (   strcmp (str, "cpsr_all") == 0
	   || strcmp (str, "spsr_all") == 0)
    skip = 8;
d3442 149
a3590 4
    {
      inst.error = _("{C|S}PSR expected");
      return;
    }
a3595 1
  inst.instruction |= flags;
d3604 1
a3604 1
do_msr (str, flags)
a3605 1
     unsigned long flags;
a3622 1
      inst.instruction |= flags;
d3656 1
a3656 1
  flags |= INST_IMMEDIATE;
d3669 1
a3669 1
	  inst.error = _("Invalid constant");
a3676 1
  inst.instruction |= flags;
d3687 1
a3687 1
do_mull (str, flags)
a3688 1
     unsigned long flags;
a3731 1
  inst.instruction |= flags;
d3737 1
a3737 1
do_mul (str, flags)
a3738 1
     unsigned long flags;
a3785 1
  inst.instruction |= flags;
d3791 1
a3791 1
do_mla (str, flags)
a3792 1
     unsigned long flags;
a3841 1
  inst.instruction |= flags;
d3866 1
a3866 1
  while (isalnum (c))
d3918 1
a3918 1
	      if (ldst_extend (& str, 1) == FAIL)
d3923 1
a3923 1
              skip_whitespace (str);
d3925 5
a3929 5
              if (* str == '!')
               {
                 str ++;
                 inst.instruction |= WRITE_BACK;
               }
d3945 1
a3945 1
	  if (ldst_extend (& str, 1) == FAIL)
d3996 1
a3996 1
do_smla (str, flags)
a3997 1
     unsigned long flags;
a4014 3
  else if (flags)
    inst.error = BAD_FLAGS;

d4025 1
a4025 1
do_smlal (str, flags)
a4026 1
     unsigned long flags;
d4053 1
a4053 4
  if (flags)
    inst.error = BAD_FLAGS;
  else
    end_of_line (str);
d4061 1
a4061 1
do_smul (str, flags)
a4062 1
     unsigned long flags;
a4077 3
  else if (flags)
    inst.error = BAD_FLAGS;

d4087 1
a4087 1
do_qadd (str, flags)
a4088 1
     unsigned long flags;
a4103 3
  else if (flags)
    inst.error = BAD_FLAGS;

d4118 1
a4118 1
do_co_reg2c (str, flags)
a4119 1
     unsigned long flags;
d4159 1
a4159 1
      (_("Warning: Instruction unpredictable when using r15"));
a4168 3
  if (flags)
    inst.error = BAD_COND;

d4178 1
a4178 1
do_clz (str, flags)
a4179 1
     unsigned long flags;
a4182 6
  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

d4204 1
a4204 1
do_lstc2 (str, flags)
a4205 1
     unsigned long flags;
a4206 3
  if (flags)
    inst.error = BAD_COND;

d4221 1
a4221 1
	   || cp_address_required_here (& str) == FAIL)
d4236 1
a4236 1
do_cdp2 (str, flags)
a4237 1
     unsigned long flags;
a4289 3
  if (flags)
    inst.error = BAD_FLAGS;

d4300 1
a4300 1
do_co_reg2 (str, flags)
a4301 1
     unsigned long flags;
d4354 21
a4374 2
  if (flags)
    inst.error = BAD_COND;
d4396 4
a4399 1
  if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
d4401 1
a4401 1
      inst.error = _("bad or missing expression");
d4425 1
a4425 1
do_branch25 (str, flags)
a4426 1
     unsigned long flags ATTRIBUTE_UNUSED;
d4479 1
a4479 1
do_blx (str, flags)
a4480 1
     unsigned long flags;
a4484 6
  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

d4497 1
a4497 1
      do_bx (str, flags);
d4503 2
a4504 2
    	{
      	  inst.error = BAD_COND;
d4506 1
a4506 1
    	}
d4512 1
a4512 1
      do_branch25 (str, flags);
d4564 1
a4564 2
	and it is an error if the caller tried to override that.
     Note "flags" is nonzero if a flag was supplied (which is an error).  */
d4567 1
a4567 1
do_bkpt (str, flags)
a4568 1
     unsigned long flags;
d4581 4
a4584 1
  if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
d4586 1
a4586 1
      inst.error = _("bad or missing expression");
d4606 1
d4608 1
a4608 3
  if (flags)
    inst.error = BAD_FLAGS;
}
d4610 1
a4610 4
/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */
d4612 2
a4613 2
static void
do_mia (str, flags)
d4615 2
a4616 1
     unsigned long flags;
d4618 9
a4626 2
  int rs;
  int rm;
d4628 146
a4773 2
  if (flags)
    as_bad (BAD_FLAGS);
d4775 20
a4794 2
  else if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;
d4796 6
a4801 3
  else if (skip_past_comma (& str) == FAIL
	   || (rm = reg_required_here (& str, 0)) == FAIL)
    inst.error = BAD_ARGS;
d4803 2
a4804 3
  else if (skip_past_comma (& str) == FAIL
	   || (rs = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d4806 1
a4806 3
  /* inst.instruction has now been zapped with both rm and rs.  */
  else if (rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rm or rs is R15.  */
d4808 7
d4817 6
d4825 7
a4831 1
/* Xscale move-accumulator-register (argument parse)
d4833 4
a4836 1
     MARcc   acc0,RdLo,RdHi.  */
d4839 1
a4839 1
do_mar (str, flags)
a4840 1
     unsigned long flags;
d4842 4
a4845 1
  int rdlo, rdhi;
d4847 5
a4851 2
  if (flags)
    as_bad (BAD_FLAGS);
d4853 2
a4854 2
  else if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;
d4856 3
a4858 3
  else if (skip_past_comma (& str) == FAIL
	   || (rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d4860 5
a4864 3
  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;
d4866 2
a4867 3
  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */
d4869 1
a4869 2
  else
    end_of_line (str);
a4871 4
/* Xscale move-register-accumulator (argument parse)

     MRAcc   RdLo,RdHi,acc0.  */

d4873 1
a4873 1
do_mra (str, flags)
a4874 1
     unsigned long flags;
d4876 116
a4991 2
  int rdlo;
  int rdhi;
d4993 1
a4993 1
  if (flags)
d4995 2
a4996 2
      as_bad (BAD_FLAGS);
      return;
d4998 123
d5145 1
a5145 1
/* Xscale: Preload-Cache
d5152 1
a5152 1
do_pld (str, flags)
a5153 1
     unsigned long flags;
a5156 6
  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

d5165 1
a5165 1
  ++ str;
d5173 1
a5173 1
  if (* str == ']')
d5176 1
a5176 1
      ++ str;
d5179 2
a5180 1
      if (skip_past_comma (& str) == SUCCESS)
d5182 3
a5184 2
	  if (ldst_extend (& str, 0) == FAIL)
	    return;
d5186 1
a5186 1
      else if (* str == '!') /* [Rn]! */
d5189 1
a5189 1
	  ++ str;
d5202 1
a5202 1
      if (ldst_extend (& str, 0) == FAIL)
d5228 1
a5228 1
/* Xscale load-consecutive (argument parse)
d5235 1
a5235 1
do_ldrd (str, flags)
a5236 1
     unsigned long flags;
a5240 29
  if (flags != DOUBLE_LOAD_FLAG)
    {
      /* Change instruction pattern to normal ldr/str.  */
      if (inst.instruction & 0x20)
	inst.instruction = (inst.instruction & COND_MASK) | 0x04000000; /* str */
      else
	inst.instruction = (inst.instruction & COND_MASK) | 0x04100000; /* ldr */

      /* Perform a normal load/store instruction parse.  */
      do_ldst (str, flags);

      return;
    }

  if ((cpu_variant & ARM_EXT_XSCALE) != ARM_EXT_XSCALE)
    {
      static char buff[128];

      --str;
      while (isspace (*str))
	--str;
      str -= 4;

      /* Deny all knowledge.  */
      sprintf (buff, _("bad instruction '%.100s'"), str);
      inst.error = buff;
      return;
    }

d5253 1
a5253 1
        inst.error = BAD_ARGS;
d5260 1
a5260 1
      inst.error = _("Destination register must be even");
d5264 1
a5264 1
  if (rd == REG_LR || rd == 12)
d5266 1
a5266 1
      inst.error = _("r12 or r14 not allowed here");
d5271 2
a5272 3
      &&
      ((inst.instruction & WRITE_BACK)
       || (!(inst.instruction & PRE_INDEX))))
d5275 11
d5359 1
a5359 1
/* Return true if anything in the expression is a bignum.  */
d5378 2
d5390 1
d5392 9
d5425 1
a5425 1
      inst.error = _("Invalid constant");
d5436 14
d5464 1
a5464 1
  for (p = * str; isalpha (* p); p ++)
d5469 1
a5469 1
      inst.error = _("Shift expression expected");
d5480 1
a5480 1
      inst.error = _("Shift expression expected");
d5535 1
a5535 1
	      as_warn (_("Shift of 0 ignored."));
d5541 1
a5541 1
	      inst.error = _("Invalid immediate shift");
d5696 1
a5696 1
		      inst.error = _("Constant expression expected");
d5705 1
a5705 1
		      inst.error = _("Invalid constant");
d5725 1
a5725 1
		      inst.error = _("Invalid constant");
d5738 1
a5738 1
      inst.error = _("Register or shift expression expected");
d5791 1
a5791 1
	  inst.error = _("Invalid floating point immediate expression");
d5795 1
a5795 1
	_("Floating point register or immediate expression expected");
d5801 1
a5801 1
do_arit (str, flags)
a5802 1
     unsigned long flags;
a5816 1
  inst.instruction |= flags;
d5822 1
a5822 1
do_adr (str, flags)
a5823 1
     unsigned long flags;
a5842 1
  inst.instruction |= flags;
d5848 1
a5848 1
do_adrl (str, flags)
a5849 1
     unsigned long flags;
d5853 2
a5854 2
     	add rd, pc, #low(label-.-8)"
     	add rd, rd, #high(label-.-8)"  */
d5858 3
a5860 3
  if (reg_required_here (& str, 12) == FAIL
      || skip_past_comma (& str) == FAIL
      || my_get_expression (& inst.reloc.exp, & str))
d5864 1
a5868 1

a5873 1
  inst.instruction            |= flags;
d5880 1
a5880 1
do_cmp (str, flags)
a5881 1
     unsigned long flags;
a5899 4
  inst.instruction |= flags;
  if ((flags & 0x0000f000) == 0)
    inst.instruction |= CONDS_BIT;

d5905 1
a5905 1
do_mov (str, flags)
a5906 1
     unsigned long flags;
a5924 1
  inst.instruction |= flags;
d5930 1
a5930 1
ldst_extend (str, hwse)
a5931 1
     int     hwse;
d5947 1
a5947 2
	  if ((hwse && (value < -255 || value > 255))
	      || (value < -4095 || value > 4095))
d5959 1
a5959 7
	  /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0.  */
	  if (hwse)
	    inst.instruction |= (add | HWOFFSET_IMM
				 | ((value >> 4) << 8) | (value & 0xF));
	  else
	    inst.instruction |= add | value;
d5963 1
a5963 7
	  if (hwse)
	    {
	      inst.instruction |= HWOFFSET_IMM;
	      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	    }
	  else
	    inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d5980 3
a5982 8
      if (hwse)
	inst.instruction |= add;
      else
	{
	  inst.instruction |= add | OFFSET_REG;
	  if (skip_past_comma (str) == SUCCESS)
	    return decode_shift (str, SHIFT_RESTRICT);
	}
d5989 1
a5989 1
do_ldst (str, flags)
a5990 1
     unsigned long flags;
a5991 1
  int halfword = 0;
d5996 1
a5996 22
  /* This is not ideal, but it is the simplest way of dealing with the
     ARM7T halfword instructions (since they use a different
     encoding, but the same mnemonic):  */
  halfword = (flags & 0x80000000) != 0;
  if (halfword)
    {
      /* This is actually a load/store of a halfword, or a
         signed-extension load.  */
      if ((cpu_variant & ARM_EXT_HALFWORD) == 0)
	{
	  inst.error
	    = _("Processor does not support halfwords or signed bytes");
	  return;
	}

      inst.instruction = ((inst.instruction & COND_MASK)
			  | (flags & ~COND_MASK));

      flags = 0;
    }

  skip_whitespace (str);
d5998 1
a5998 1
  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
d6005 1
a6005 1
  if (skip_past_comma (& str) == FAIL)
d6007 1
a6007 1
      inst.error = _("Address expected");
d6034 1
a6034 1
	      if (ldst_extend (&str, halfword) == FAIL)
d6037 3
a6039 10
		{
		  if (flags & TRANS_BIT)
		    as_warn (_("Rn and Rd must be different in %s"),
			     ((inst.instruction & LOAD_BIT)
			      ? "LDRT" : "STRT"));
		  else
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		}
a6043 3
	      if (halfword)
		inst.instruction |= HWOFFSET_IMM;

d6056 2
a6057 10
	      flags |= INDEX_UP;
	      if (flags & TRANS_BIT)
		{
		  if (conflict_reg)
		    as_warn (_("Rn and Rd must be different in %s"),
			     ((inst.instruction & LOAD_BIT)
			      ? "LDRT" : "STRT"));
		}
		else
		  pre_inc = 1;
d6070 1
a6070 1
	  if (ldst_extend (&str, halfword) == FAIL)
d6096 6
d6113 1
a6113 1
	  inst.error = _("Constant expression expected");
d6117 1
a6117 2
      if (inst.reloc.exp.X_op == O_constant
	  && (value = validate_immediate (inst.reloc.exp.X_add_number)) != FAIL)
d6119 3
a6121 11
	  /* This can be done with a mov instruction.  */
	  inst.instruction &= LITERAL_MASK;
	  inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	  inst.instruction |= (flags & COND_MASK) | (value & 0xfff);
	  end_of_line (str);
	  return;
	}
      else
	{
	  /* Insert into literal pool.  */
	  if (add_to_lit_pool () == FAIL)
d6123 6
a6128 2
	      if (!inst.error)
		inst.error = _("literal pool insertion failed");
d6132 3
a6134 2
	  /* Change the instruction exp to point to the pool.  */
	  if (halfword)
d6136 7
a6142 2
	      inst.instruction |= HWOFFSET_IMM;
	      inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
a6143 5
	  else
	    inst.reloc.type = BFD_RELOC_ARM_LITERAL;
	  inst.reloc.pc_rel = 1;
	  inst.instruction |= (REG_PC << 16);
	  pre_inc = 1;
d6145 14
d6165 1
a6165 7
      if (halfword)
	{
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d6175 1
a6175 4
  if (pre_inc && (flags & TRANS_BIT))
    inst.error = _("Pre-increment instruction with translate");

  inst.instruction |= flags | (pre_inc ? PRE_INDEX : 0);
d6180 3
a6182 3
static long
reg_list (strp)
     char ** strp;
d6184 3
a6186 3
  char * str = * strp;
  long   range = 0;
  int    another_range;
d6188 1
a6188 2
  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
d6190 4
a6193 1
      another_range = 0;
d6195 5
a6199 4
      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;
d6201 3
a6203 4
	  str++;
	  do
	    {
	      int reg;
d6205 1
a6205 1
	      skip_whitespace (str);
d6207 1
a6207 2
	      if ((reg = reg_required_here (& str, -1)) == FAIL)
		return FAIL;
d6209 2
a6210 3
	      if (in_range)
		{
		  int i;
d6212 6
a6217 5
		  if (reg <= cur_reg)
		    {
		      inst.error = _("Bad range in register list");
		      return FAIL;
		    }
d6219 1
a6219 11
		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: Duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}
d6221 3
a6223 5
	      if (range & (1 << reg))
		as_tsktsk (_("Warning: Duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: Register range not in ascending order"));
d6225 5
a6229 2
	      range |= 1 << reg;
	      cur_reg = reg;
d6231 8
a6238 4
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;
	  skip_whitespace (str);
d6240 1
a6240 4
	  if (*str++ != '}')
	    {
	      inst.error = _("Missing `}'");
	      return FAIL;
d6245 9
a6253 1
	  expressionS expr;
d6255 3
a6257 2
	  if (my_get_expression (&expr, &str))
	    return FAIL;
d6259 5
a6263 8
	  if (expr.X_op == O_constant)
	    {
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}
d6265 7
a6271 3
	      if ((range & expr.X_add_number) != 0)
		{
		  int regno = range & expr.X_add_number;
d6273 3
a6275 6
		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: Duplicated register (r%d) in register list"),
		     regno);
		}
d6277 4
a6280 1
	      range |= expr.X_add_number;
d6282 2
a6283 1
	  else
d6285 3
a6287 5
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}
d6289 10
a6298 4
	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
d6300 9
d6310 3
a6312 1
      skip_whitespace (str);
d6314 2
a6315 5
      if (*str == '|' || *str == '+')
	{
	  str++;
	  another_range = 1;
	}
a6316 4
  while (another_range);

  *strp = str;
  return range;
d6319 1
d6321 2
a6322 3
do_ldmstm (str, flags)
     char * str;
     unsigned long flags;
d6324 3
a6326 2
  int base_reg;
  long range;
d6330 1
a6330 4
  if ((base_reg = reg_required_here (&str, 16)) == FAIL)
    return;

  if (base_reg == REG_PC)
d6332 2
a6333 1
      inst.error = _("r15 not allowed as base register");
d6337 5
a6341 1
  skip_whitespace (str);
d6343 1
a6343 1
  if (*str == '!')
d6345 2
a6346 1
      flags |= WRITE_BACK;
a6347 1
    }
d6349 1
a6349 7
  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6351 2
a6352 5
  if (*str == '^')
    {
      str++;
      flags |= LDM_TYPE_2_OR_3;
    }
d6354 2
a6355 4
  inst.instruction |= flags | range;
  end_of_line (str);
  return;
}
d6357 1
a6357 6
static void
do_swi (str, flags)
     char * str;
     unsigned long flags;
{
  skip_whitespace (str);
d6359 3
a6361 3
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str++;
d6363 14
a6376 2
  if (my_get_expression (& inst.reloc.exp, & str))
    return;
d6378 1
a6378 3
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
  inst.instruction |= flags;
d6380 9
a6388 1
  end_of_line (str);
d6390 12
a6401 2
  return;
}
d6403 3
a6405 6
static void
do_swap (str, flags)
     char * str;
     unsigned long flags;
{
  int reg;
d6407 1
a6407 1
  skip_whitespace (str);
d6409 5
a6413 2
  if ((reg = reg_required_here (&str, 12)) == FAIL)
    return;
d6415 1
a6415 5
  if (reg == REG_PC)
    {
      inst.error = _("r15 not allowed in swap");
      return;
    }
d6417 10
a6426 6
  if (skip_past_comma (&str) == FAIL
      || (reg = reg_required_here (&str, 0)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6428 1
a6428 2

  if (reg == REG_PC)
d6430 5
a6434 3
      inst.error = _("r15 not allowed in swap");
      return;
    }
d6436 3
a6438 6
  if (skip_past_comma (&str) == FAIL
      || *str++ != '[')
    {
      inst.error = BAD_ARGS;
      return;
    }
d6440 1
a6440 1
  skip_whitespace (str);
d6442 2
a6443 2
  if ((reg = reg_required_here (&str, 16)) == FAIL)
    return;
d6445 6
a6450 5
  if (reg == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d6452 3
a6454 1
  skip_whitespace (str);
d6456 9
a6464 5
  if (*str++ != ']')
    {
      inst.error = _("missing ]");
      return;
    }
d6466 1
a6466 4
  inst.instruction |= flags;
  end_of_line (str);
  return;
}
d6468 10
a6477 7
static void
do_branch (str, flags)
     char * str;
     unsigned long flags ATTRIBUTE_UNUSED;
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
d6479 7
a6485 3
#ifdef OBJ_ELF
  {
    char * save_in;
d6487 11
a6497 2
    /* ScottB: February 5, 1998 - Check to see of PLT32 reloc
       required for the instruction.  */
d6499 10
a6508 26
    /* arm_parse_reloc () works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;
    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
	inst.reloc.pc_rel = 1;
      }
    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF  */
d6510 1
d6515 3
a6517 4
static void
do_bx (str, flags)
     char * str;
     unsigned long flags ATTRIBUTE_UNUSED;
d6519 3
a6521 1
  int reg;
d6523 2
a6524 3
  skip_whitespace (str);

  if ((reg = reg_required_here (&str, 0)) == FAIL)
d6526 1
a6526 3
      inst.error = BAD_ARGS;
      return;
    }
d6528 4
a6531 3
  /* Note - it is not illegal to do a "bx pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("Use of r15 in bx in ARM mode is not really useful"));
d6533 108
a6640 2
  end_of_line (str);
}
d6643 1
a6643 1
do_cdp (str, flags)
a6644 1
     unsigned long flags ATTRIBUTE_UNUSED;
d6646 3
a6648 2
  /* Co-processor data operation.
     Format: CDP{cond} CP#,<expr>,CRd,CRn,CRm{,<expr>}  */
d6651 4
a6654 1
  if (co_proc_number (&str) == FAIL)
d6656 1
a6656 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d6660 1
a6660 7
  if (skip_past_comma (&str) == FAIL
      || cp_opc_expr (&str, 20,4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6662 1
a6662 2
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
d6664 2
a6665 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6669 1
a6669 1
      || cp_reg_required_here (&str, 16) == FAIL)
d6671 1
a6671 1
      if (!inst.error)
d6676 1
a6676 2
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
d6678 2
a6679 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6682 1
a6682 1
  if (skip_past_comma (&str) == SUCCESS)
d6684 2
a6685 1
      if (cp_opc_expr (&str, 5, 3) == FAIL)
d6687 17
a6703 3
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
d6707 1
d6713 1
a6713 1
do_lstc (str, flags)
a6714 1
     unsigned long flags;
a6715 3
  /* Co-processor register load/store.
     Format: <LDC|STC{cond}[L] CP#,CRd,<address>  */

d6718 3
a6720 6
  if (co_proc_number (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6722 2
a6723 7
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6725 3
a6727 7
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
a6728 2
  inst.instruction |= flags;
  end_of_line (str);
d6733 1
a6733 1
do_co_reg (str, flags)
a6734 1
     unsigned long flags;
d6736 1
a6736 2
  /* Co-processor register transfer.
     Format: <MCR|MRC>{cond} CP#,<expr1>,Rd,CRn,CRm{,<expr2>}  */
d6740 4
a6743 1
  if (co_proc_number (&str) == FAIL)
d6745 1
a6745 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d6750 1
a6750 1
      || cp_opc_expr (&str, 21, 3) == FAIL)
d6757 1
a6757 2
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
d6759 1
a6759 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d6764 1
a6764 1
      || cp_reg_required_here (&str, 16) == FAIL)
d6766 1
a6766 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d6770 6
a6775 2
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
d6777 1
a6777 2
      if (!inst.error)
	inst.error = BAD_ARGS;
a6780 26
  if (skip_past_comma (&str) == SUCCESS)
    {
      if (cp_opc_expr (&str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }
  if (flags)
    {
      inst.error = BAD_COND;
    }

  end_of_line (str);
  return;
}

static void
do_fp_ctrl (str, flags)
     char * str;
     unsigned long flags ATTRIBUTE_UNUSED;
{
  /* FP control registers.
     Format: <WFS|RFS|WFC|RFC>{cond} Rn  */

d6783 1
a6783 1
  if (reg_required_here (&str, 12) == FAIL)
d6785 1
a6785 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d6794 1
a6794 1
do_fp_ldst (str, flags)
a6795 1
     unsigned long flags ATTRIBUTE_UNUSED;
d6797 6
a6802 1
  skip_whitespace (str);
d6804 239
a7042 16
  switch (inst.suffix)
    {
    case SUFF_S:
      break;
    case SUFF_D:
      inst.instruction |= CP_T_X;
      break;
    case SUFF_E:
      inst.instruction |= CP_T_Y;
      break;
    case SUFF_P:
      inst.instruction |= CP_T_X | CP_T_Y;
      break;
    default:
      abort ();
    }
d7052 1
a7052 1
      || cp_address_required_here (&str) == FAIL)
d7063 1
a7063 1
do_fp_ldmstm (str, flags)
a7064 1
     unsigned long flags;
d7088 1
a7088 1
      inst.error = _("Constant value required for number of registers");
d7117 1
a7117 1
  if (flags)
d7157 1
a7157 1
		_("R15 not allowed as base register with write-back");
d7164 1
a7164 1
      if (flags & CP_T_Pre)
d7169 1
a7169 1
	    flags |= CP_T_WB;
d7176 1
a7176 1
	      flags |= CP_T_WB;
d7183 1
a7183 1
	      flags = CP_T_Pre | CP_T_UD;
d7188 1
a7188 1
      inst.instruction |= flags | offset;
d7191 1
a7191 1
	   || cp_address_required_here (&str) == FAIL)
d7202 1
a7202 1
do_fp_dyadic (str, flags)
a7203 1
     unsigned long flags;
a7206 14
  switch (inst.suffix)
    {
    case SUFF_S:
      break;
    case SUFF_D:
      inst.instruction |= 0x00000080;
      break;
    case SUFF_E:
      inst.instruction |= 0x00080000;
      break;
    default:
      abort ();
    }

a7229 1
  inst.instruction |= flags;
d7235 1
a7235 1
do_fp_monadic (str, flags)
a7236 1
     unsigned long flags;
a7239 14
  switch (inst.suffix)
    {
    case SUFF_S:
      break;
    case SUFF_D:
      inst.instruction |= 0x00000080;
      break;
    case SUFF_E:
      inst.instruction |= 0x00080000;
      break;
    default:
      abort ();
    }

a7254 1
  inst.instruction |= flags;
d7260 1
a7260 1
do_fp_cmp (str, flags)
a7261 1
     unsigned long flags;
a7279 1
  inst.instruction |= flags;
d7285 1
a7285 1
do_fp_from_reg (str, flags)
a7286 1
     unsigned long flags;
a7289 14
  switch (inst.suffix)
    {
    case SUFF_S:
      break;
    case SUFF_D:
      inst.instruction |= 0x00000080;
      break;
    case SUFF_E:
      inst.instruction |= 0x00080000;
      break;
    default:
      abort ();
    }

a7304 1
  inst.instruction |= flags;
d7310 1
a7310 1
do_fp_to_reg (str, flags)
a7311 1
     unsigned long flags;
a7325 1
  inst.instruction |= flags;
d7330 7
a7336 1
/* Thumb specific routines.  */
d7338 30
a7367 5
/* Parse and validate that a register is of the right form, this saves
   repeated checking of this information in many similar cases.
   Unlike the 32-bit case we do not insert the register into the opcode
   here, since the position is often unknown until the full instruction
   has been parsed.  */
d7370 3
a7372 3
thumb_reg (strp, hi_lo)
     char ** strp;
     int     hi_lo;
d7374 2
a7375 4
  int reg;

  if ((reg = reg_required_here (strp, -1)) == FAIL)
    return FAIL;
d7377 1
a7377 1
  switch (hi_lo)
d7379 1
a7379 2
    case THUMB_REG_LO:
      if (reg > 7)
d7381 11
a7391 4
	  inst.error = _("lo register required");
	  return FAIL;
	}
      break;
d7393 2
a7394 5
    case THUMB_REG_HI:
      if (reg < 8)
	{
	  inst.error = _("hi register required");
	  return FAIL;
d7396 2
a7397 1
      break;
d7399 3
a7401 3
    default:
      break;
    }
d7403 3
a7405 1
  return reg;
a7407 3
/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode
   was SUB.  */

d7409 2
a7410 3
thumb_add_sub (str, subtract)
     char * str;
     int    subtract;
d7412 1
a7412 1
  int Rd, Rs, Rn = FAIL;
d7414 2
a7415 1
  skip_whitespace (str);
d7417 2
a7418 2
  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
d7425 9
a7433 11
  if (is_immediate_prefix (*str))
    {
      Rs = Rd;
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
d7435 2
a7436 16
      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
    }
d7438 2
a7439 3
  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
  if (Rn != FAIL)
d7441 3
a7443 26
      /* All register format.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
	{
	  if (Rs != Rd)
	    {
	      inst.error = _("dest and source1 must be the same register");
	      return;
	    }

	  /* Can't do this for SUB.  */
	  if (subtract)
	    {
	      inst.error = _("subtract valid only on lo regs");
	      return;
	    }

	  inst.instruction = (T_OPCODE_ADD_HI
			      | (Rd > 7 ? THUMB_H1 : 0)
			      | (Rn > 7 ? THUMB_H2 : 0));
	  inst.instruction |= (Rd & 7) | ((Rn & 7) << 3);
	}
      else
	{
	  inst.instruction = subtract ? T_OPCODE_SUB_R3 : T_OPCODE_ADD_R3;
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
	}
a7444 3
  else
    {
      /* Immediate expression, now things start to get nasty.  */
d7446 3
a7448 8
      /* First deal with HI regs, only very restricted cases allowed:
	 Adjusting SP, and using PC or SP to get an address.  */
      if ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
	  || (Rs > 7 && Rs != REG_SP && Rs != REG_PC))
	{
	  inst.error = _("invalid Hi register with immediate");
	  return;
	}
d7450 5
a7454 11
      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, all we can do is store all the fragments
	     we know about in the instruction and let the reloc hacking
	     work it all out.  */
	  inst.instruction = (subtract ? 0x8000 : 0) | (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
	}
      else
	{
	  int offset = inst.reloc.exp.X_add_number;
d7456 2
a7457 2
	  if (subtract)
	    offset = -offset;
d7459 8
a7466 58
	  if (offset < 0)
	    {
	      offset = -offset;
	      subtract = 1;

	      /* Quick check, in case offset is MIN_INT.  */
	      if (offset < 0)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	    }
	  else
	    subtract = 0;

	  if (Rd == REG_SP)
	    {
	      if (offset & ~0x1fc)
		{
		  inst.error = _("invalid immediate value for stack adjust");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	      inst.instruction |= offset >> 2;
	    }
	  else if (Rs == REG_PC || Rs == REG_SP)
	    {
	      if (subtract
		  || (offset & ~0x3fc))
		{
		  inst.error = _("invalid immediate for address calculation");
		  return;
		}
	      inst.instruction = (Rs == REG_PC ? T_OPCODE_ADD_PC
				  : T_OPCODE_ADD_SP);
	      inst.instruction |= (Rd << 8) | (offset >> 2);
	    }
	  else if (Rs == Rd)
	    {
	      if (offset & ~0xff)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	      inst.instruction |= (Rd << 8) | offset;
	    }
	  else
	    {
	      if (offset & ~0x7)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	      inst.instruction |= Rd | (Rs << 3) | (offset << 6);
	    }
	}
d7470 1
d7474 2
a7475 3
thumb_shift (str, shift)
     char * str;
     int    shift;
d7477 1
a7477 1
  int Rd, Rs, Rn = FAIL;
d7479 2
a7480 1
  skip_whitespace (str);
d7482 1085
a8566 2
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
d8575 226
a8800 5
      /* Two operand immediate format, set Rs to Rd.  */
      Rs = Rd;
      str ++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d8802 1
a8802 1
  else
d8804 12
a8815 2
      if ((Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
d8817 1
a8817 1
      if (skip_past_comma (&str) == FAIL)
d8819 8
a8826 4
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
d8828 17
a8844 8
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
d8847 18
a8864 2
  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
d8866 1
a8866 1
  if (Rn != FAIL)
d8868 222
a9089 5
      if (Rs != Rd)
	{
	  inst.error = _("source1 and dest must be same register");
	  return;
	}
d9091 6
a9096 6
      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_R; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_R; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_R; break;
	}
d9098 6
a9103 10
      inst.instruction |= Rd | (Rn << 3);
    }
  else
    {
      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_I; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_I; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_I; break;
	}
d9105 6
a9110 9
      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, create a dummy reloc and let reloc
	     hacking fix it up.  */
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	}
      else
	{
	  unsigned shift_value = inst.reloc.exp.X_add_number;
d9112 7
a9118 5
	  if (shift_value > 32 || (shift_value == 32 && shift == THUMB_LSL))
	    {
	      inst.error = _("Invalid immediate for shift");
	      return;
	    }
d9120 7
a9126 3
	  /* Shifts of zero are handled by converting to LSL.  */
	  if (shift_value == 0)
	    inst.instruction = T_OPCODE_LSL_I;
d9128 6
a9133 3
	  /* Shifts of 32 are encoded as a shift of zero.  */
	  if (shift_value == 32)
	    shift_value = 0;
d9135 7
a9141 2
	  inst.instruction |= shift_value << 6;
	}
d9143 1
a9143 1
      inst.instruction |= Rd | (Rs << 3);
d9149 1
d9151 1
a9151 1
thumb_mov_compare (str, move)
a9152 1
     int    move;
a9153 2
  int Rd, Rs = FAIL;

d9156 4
a9159 2
  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
d9161 1
a9161 1
      if (! inst.error)
d9163 1
d9167 16
a9182 8
  if (is_immediate_prefix (*str))
    {
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;
d9184 6
a9189 18
  if (Rs != FAIL)
    {
      if (Rs < 8 && Rd < 8)
	{
	  if (move == THUMB_MOVE)
	    /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	       since a MOV instruction produces unpredictable results.  */
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;
	  inst.instruction |= Rd | (Rs << 3);
	}
      else
	{
	  if (move == THUMB_MOVE)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else
	    inst.instruction = T_OPCODE_CMP_HR;
d9191 6
a9196 2
	  if (Rd > 7)
	    inst.instruction |= THUMB_H1;
d9198 6
a9203 2
	  if (Rs > 7)
	    inst.instruction |= THUMB_H2;
d9205 6
a9210 10
	  inst.instruction |= (Rd & 7) | ((Rs & 7) << 3);
	}
    }
  else
    {
      if (Rd > 7)
	{
	  inst.error = _("only lo regs allowed with immediate");
	  return;
	}
d9212 1
a9212 4
      if (move == THUMB_MOVE)
	inst.instruction = T_OPCODE_MOV_I8;
      else
	inst.instruction = T_OPCODE_CMP_I8;
d9214 8
a9221 1
      inst.instruction |= Rd << 8;
d9223 2
a9224 5
      if (inst.reloc.exp.X_op != O_constant)
	inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
      else
	{
	  unsigned value = inst.reloc.exp.X_add_number;
d9226 1
a9226 5
	  if (value > 255)
	    {
	      inst.error = _("invalid immediate");
	      return;
	    }
d9228 6
a9233 2
	  inst.instruction |= value;
	}
d9235 3
d9239 1
a9239 2
  end_of_line (str);
}
d9242 1
a9242 1
thumb_load_store (str, load_store, size)
d9244 4
a9247 2
     int    load_store;
     int    size;
d9249 5
a9253 1
  int Rd, Rb, Ro = FAIL;
d9257 5
a9261 2
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
d9263 1
a9263 1
      if (! inst.error)
a9264 1
      return;
d9266 6
d9273 15
a9287 5
  if (*str == '[')
    {
      str++;
      if ((Rb = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
d9289 1
a9289 16
      if (skip_past_comma (&str) != FAIL)
	{
	  if (is_immediate_prefix (*str))
	    {
	      str++;
	      if (my_get_expression (&inst.reloc.exp, &str))
		return;
	    }
	  else if ((Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	    return;
	}
      else
	{
	  inst.reloc.exp.X_op = O_constant;
	  inst.reloc.exp.X_add_number = 0;
	}
d9291 10
a9300 6
      if (*str != ']')
	{
	  inst.error = _("expected ']'");
	  return;
	}
      str++;
d9302 3
a9304 4
  else if (*str == '=')
    {
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;
d9306 3
a9308 1
      skip_whitespace (str);
d9310 8
a9317 2
      if (my_get_expression (& inst.reloc.exp, & str))
	return;
d9319 1
a9319 1
      end_of_line (str);
d9321 1
a9321 6
      if (   inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = "Constant expression expected";
	  return;
	}
d9323 9
a9331 4
      if (inst.reloc.exp.X_op == O_constant
	  && ((inst.reloc.exp.X_add_number & ~0xFF) == 0))
	{
	  /* This can be done with a mov instruction.  */
d9333 3
a9335 12
	  inst.instruction  = T_OPCODE_MOV_I8 | (Rd << 8);
	  inst.instruction |= inst.reloc.exp.X_add_number;
	  return;
	}

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = "literal pool insertion failed";
	  return;
	}
d9337 2
a9338 5
      inst.reloc.type   = BFD_RELOC_ARM_THUMB_OFFSET;
      inst.reloc.pc_rel = 1;
      inst.instruction  = T_OPCODE_LDR_PC | (Rd << 8);
      /* Adjust ARM pipeline offset to Thumb.  */
      inst.reloc.exp.X_add_number += 4;
d9340 3
d9345 2
a9346 1
  else
d9348 6
a9353 2
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d9355 3
a9357 5
      inst.instruction = T_OPCODE_LDR_PC | (Rd << 8);
      inst.reloc.pc_rel = 1;
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset.  */
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      end_of_line (str);
d9361 2
a9362 1
  if (Rb == REG_PC || Rb == REG_SP)
d9364 22
a9385 15
      if (size != THUMB_WORD)
	{
	  inst.error = _("byte or halfword not valid for base register");
	  return;
	}
      else if (Rb == REG_PC && load_store != THUMB_LOAD)
	{
	  inst.error = _("R15 based store not allowed");
	  return;
	}
      else if (Ro != FAIL)
	{
	  inst.error = _("Invalid base register for register offset");
	  return;
	}
d9387 1
a9387 6
      if (Rb == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (load_store == THUMB_LOAD)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;
d9389 2
a9390 4
      inst.instruction |= Rd << 8;
      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;
d9392 5
a9396 5
	  if (offset & ~0x3fc)
	    {
	      inst.error = _("invalid offset");
	      return;
	    }
d9398 4
a9401 4
	  inst.instruction |= offset >> 2;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
d9403 5
a9407 1
  else if (Rb > 7)
d9409 2
a9410 2
      inst.error = _("invalid base register in load/store");
      return;
d9412 26
a9437 1
  else if (Ro == FAIL)
d9439 4
a9442 10
      /* Immediate offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IW : T_OPCODE_STR_IW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IH : T_OPCODE_STR_IH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IB : T_OPCODE_STR_IB);
d9444 2
a9445 1
      inst.instruction |= Rd | (Rb << 3);
d9447 1
a9447 1
      if (inst.reloc.exp.X_op == O_constant)
d9449 3
a9451 1
	  unsigned offset = inst.reloc.exp.X_add_number;
d9453 4
a9456 6
	  if (offset & ~(0x1f << size))
	    {
	      inst.error = _("Invalid offset");
	      return;
	    }
	  inst.instruction |= (offset >> size) << 6;
a9457 2
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
d9461 10
a9470 10
      /* Register offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RW : T_OPCODE_STR_RW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RH : T_OPCODE_STR_RH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RB : T_OPCODE_STR_RB);
d9472 1
a9472 1
      inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
d9475 6
d9482 6
d9690 1
a9690 1
    as_warn (_("Inserted missing '!': load/store multiple always writes back base register"));
d9706 1
a9706 1
      inst.error = _("Expression too complex");
d9758 1
a9758 1
	inst.error = _("Syntax: ldrs[b] Rd, [Rb, Ro]");
d9806 1
a9806 1
      inst.error = _("Expression too complex");
d9903 3
a9905 2
insert_reg (entry)
     int entry;
d9907 1
a9907 1
  int    len  = strlen (reg_table[entry].name) + 2;
d9913 200
a10112 1
  buf[i++] = REGISTER_PREFIX;
d10115 3
a10117 10
  strcpy (buf + i, reg_table[entry].name);

  for (i = 0; buf[i]; i++)
    buf2[i] = islower (buf[i]) ? toupper (buf[i]) : buf[i];

  buf2[i] = '\0';

  hash_insert (arm_reg_hsh, buf,  (PTR) & reg_table[entry]);
  hash_insert (arm_reg_hsh, buf2, (PTR) & reg_table[entry]);
}
d10120 4
a10123 3
insert_reg_alias (str, regnum)
     char *str;
     int regnum;
d10125 8
a10132 4
  struct reg_entry *new =
    (struct reg_entry *) xmalloc (sizeof (struct reg_entry));
  char *name = xmalloc (strlen (str) + 1);
  strcpy (name, str);
d10134 2
a10135 2
  new->name = name;
  new->number = regnum;
d10137 2
a10138 2
  hash_insert (arm_reg_hsh, name, (PTR) new);
}
d10140 2
a10141 4
static void
set_constant_flonums ()
{
  int i;
d10143 3
a10145 3
  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
d10147 1
a10158 1
      || (arm_reg_hsh = hash_new ()) == NULL
d10160 1
a10160 1
    as_fatal (_("Virtual memory exhausted"));
d10162 1
a10162 2
  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    hash_insert (arm_ops_hsh, insns[i].template, (PTR) (insns + i));
d10172 2
a10173 2
  for (i = 0; reg_table[i].name; i++)
    insert_reg (i);
d10177 50
d10236 13
a10248 1
    if ((cpu_variant & FPU_ALL) == FPU_NONE) flags |= F_SOFT_FLOAT;
d10283 2
a10284 3
    default:
    case ARM_6 | ARM_3 | ARM_2:	/* Actually no CPU type defined.  */
      mach = bfd_mach_arm_4;
d10287 2
a10288 2
    case ARM_7: 		/* Also ARM_6.  */
      mach = bfd_mach_arm_3;
d10293 3
a10295 1
  if (cpu_variant & ARM_EXT_XSCALE)
d10297 2
d10303 1
a10303 1
      if (cpu_variant & ARM_EXT_THUMB)
d10308 1
a10308 1
  else if (cpu_variant & ARM_EXT_HALFWORD)
d10310 1
a10310 1
      if (cpu_variant & ARM_EXT_THUMB)
d10315 1
a10315 1
  else if (cpu_variant & ARM_EXT_LONGMUL)
d10318 53
d10474 1
a10474 1
      return _("Bad call to MD_ATOF()");
d10492 15
a10506 8
      /* For a 4 byte float the order of elements in `words' is 1 0.  For an
	 8 byte float the order is 1 0 3 2.  */
      for (i = 0; i < prec; i += 2)
	{
	  md_number_to_chars (litP, (valueT) words[i + 1], 2);
	  md_number_to_chars (litP + 2, (valueT) words[i], 2);
	  litP += 4;
	}
d10587 1
a10587 1
arm_reg_parse (ccp)
d10589 1
d10607 1
a10607 1
  if (!isalpha (*p) || !is_name_beginner (*p))
d10611 1
a10611 1
  while (isalpha (c) || isdigit (c) || c == '_')
d10615 1
a10615 1
  reg = (struct reg_entry *) hash_find (arm_reg_hsh, start);
d10627 18
a10644 2
int
md_apply_fix3 (fixP, val, seg)
d10646 1
a10646 1
     valueT * val;
d10649 1
a10649 1
  offsetT        value = * val;
d10711 1
d10718 1
d10742 2
a10743 2
			      _("Unable to compute ADRL instructions for PC offset of 0x%lx"),
			      value);
d10852 1
a10852 1
			  _("Invalid swi expression"));
d10861 1
a10861 1
			  _("Invalid swi expression"));
d10871 1
a10871 1
		      _("Invalid expression in load/store multiple"));
d10911 1
a10911 1
	      value = * val;
d10924 1
a10924 1
			  _("gas can't handle same-section branch dest >= 0x04000000"));
d10966 1
a10966 1
			_("Branch out of range"));
d10982 1
a10982 1
			_("Branch out of range"));
d11003 1
d11006 1
a11006 1
			_("Branch with link out of range"));
d11011 5
a11015 8
	  /* Remove bit zero of the adjusted offset.  Bit zero can only be
	     set if the upper insn is at a half-word boundary, since the
	     destination address, an ARM instruction, must always be on a
	     word boundary.  The semantics of the BLX (1) instruction, however,
	     are that bit zero in the offset must always be zero, and the
	     corresponding bit one in the target address will be set from bit
	     one of the source address.  */
	  newval2 &= ~1;
a11070 4
    case BFD_RELOC_ARM_GOTPC:
      md_number_to_chars (buf, value, 4);
      break;

d11075 1
a11075 1
		      _("Illegal value for co-processor offset"));
d11083 12
d11111 1
a11111 1
			  _("Invalid offset, target not word aligned (0x%08X)"),
d11117 2
a11118 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d11127 2
a11128 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d11135 2
a11136 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d11143 2
a11144 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d11151 2
a11152 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d11191 1
a11191 1
			    _("Invalid immediate for stack address calculation"));
d11200 1
a11200 1
			    _("Invalid immediate for address calculation (value = 0x%08lX)"),
d11210 1
a11210 1
			    _("Invalid 8bit immediate"));
d11218 1
a11218 1
			    _("Invalid 3bit immediate"));
d11234 1
a11234 1
			  _("Invalid immediate: %ld is too large"),
d11249 1
a11249 1
		      _("Illegal Thumb shift value: %ld"), (long) value);
d11258 1
a11258 1
      return 1;
d11263 1
a11263 1
		    _("Bad relocation fixup type (%d)"), fixP->fx_r_type);
a11264 2

  return 1;
d11331 2
a11332 2
      /* If this is called then the a literal has been referenced across
	 a section boundary - possibly due to an implicit dump.  */
d11334 1
a11334 1
		    _("Literal referenced across section boundary (Implicit dump?)"));
d11347 1
a11347 2
		    _("Internal_relocation (type %d) not fixed up (IMMEDIATE)"),
		    fixp->fx_r_type);
d11357 1
a11357 2
		    _("Internal_relocation (type %d) not fixed up (OFFSET_IMM)"),
		    fixp->fx_r_type);
a11365 2
	  case BFD_RELOC_ARM_IMMEDIATE:    type = "IMMEDIATE";    break;
	  case BFD_RELOC_ARM_OFFSET_IMM:   type = "OFFSET_IMM";   break;
d11378 1
a11378 1
		      _("Cannot represent %s relocation in this object file format"),
d11385 1
a11385 1
  if (code == BFD_RELOC_32_PCREL
d11399 1
a11399 1
		    _("Can not represent %s relocation in this object file format"),
d11422 2
a11423 1
output_inst PARAMS ((void))
d11429 1
a11429 1
      as_bad (inst.error);
d11464 3
a11466 4
  char   c;
  char * p;
  char * q;
  char * start;
a11472 1
  listing_prev_line (); /* Defined in listing.h.  */
d11495 1
a11495 1
      as_bad (_("No operator -- statement `%s'\n"), str);
d11501 1
a11501 1
      CONST struct thumb_opcode * opcode;
d11505 1
a11505 1
      opcode = (CONST struct thumb_opcode *) hash_find (arm_tops_hsh, str);
d11511 1
a11511 1
	  if (thumb_mode == 1 && (opcode->variants & cpu_variant) == 0)
d11513 1
a11513 1
	      as_bad (_("selected processor does not support this opcode"));
d11520 1
a11520 1
	  output_inst ();
d11526 1
a11526 2
      CONST struct asm_opcode * opcode;
      unsigned long cond_code;
d11528 4
a11531 6
      inst.size = INSN_SIZE;
      /* P now points to the end of the opcode, probably white space, but we
	 have to break the opcode up in case it contains condionals and flags;
	 keep trying with progressively smaller basic instructions until one
	 matches, or we run out of opcode.  */
      q = (p - str > LONGEST_INST) ? str + LONGEST_INST : p;
d11533 1
a11533 1
      for (; q != str; q--)
d11535 118
a11652 2
	  c = *q;
	  *q = '\0';
d11654 128
a11781 2
	  opcode = (CONST struct asm_opcode *) hash_find (arm_ops_hsh, str);
	  *q = c;
d11783 2
a11784 4
	  if (opcode && opcode->template)
	    {
	      unsigned long flag_bits = 0;
	      char * r;
d11786 8
a11793 3
	      /* Check that this instruction is supported for this CPU.  */
	      if ((opcode->variants & cpu_variant) == 0)
		goto try_shorter;
d11795 70
a11864 21
	      inst.instruction = opcode->value;
	      if (q == p)		/* Just a simple opcode.  */
		{
		  if (opcode->comp_suffix)
		    {
		      if (*opcode->comp_suffix != '\0')
			as_bad (_("Opcode `%s' must have suffix from list: <%s>"),
				str, opcode->comp_suffix);
		      else
			/* Not a conditional instruction.  */
			(*opcode->parms) (q, 0);
		    }
		  else
		    {
		      /* A conditional instruction with default condition.  */
		      inst.instruction |= COND_ALWAYS;
		      (*opcode->parms) (q, 0);
		    }
		  output_inst ();
		  return;
		}
d11866 6
a11871 7
	      /* Not just a simple opcode.  Check if extra is a
                 conditional.  */
	      r = q;
	      if (p - r >= 2)
		{
		  CONST struct asm_cond *cond;
		  char d = *(r + 2);
d11873 24
a11896 8
		  *(r + 2) = '\0';
		  cond = (CONST struct asm_cond *) hash_find (arm_cond_hsh, r);
		  *(r + 2) = d;
		  if (cond)
		    {
		      if (cond->value == 0xf0000000)
			as_tsktsk (
_("Warning: Use of the 'nv' conditional is deprecated\n"));
d11898 6
a11903 8
		      cond_code = cond->value;
		      r += 2;
		    }
		  else
		    cond_code = COND_ALWAYS;
		}
	      else
		cond_code = COND_ALWAYS;
d11905 7
a11911 13
	      /* Apply the conditional, or complain it's not allowed.  */
	      if (opcode->comp_suffix && *opcode->comp_suffix == '\0')
		{
		  /* Instruction isn't conditional.  */
		  if (cond_code != COND_ALWAYS)
		    {
		      as_bad (_("Opcode `%s' is unconditional\n"), str);
		      return;
		    }
		}
	      else
		/* Instruction is conditional: set the condition into it.  */
		inst.instruction |= cond_code;
d11913 5
a11917 5
	      /* If there is a compulsory suffix, it should come here
		 before any optional flags.  */
	      if (opcode->comp_suffix && *opcode->comp_suffix != '\0')
		{
		  CONST char *s = opcode->comp_suffix;
d11919 23
a11941 7
		  while (*s)
		    {
		      inst.suffix++;
		      if (*r == *s)
			break;
		      s++;
		    }
d11943 7
a11949 6
		  if (*s == '\0')
		    {
		      as_bad (_("Opcode `%s' must have suffix from <%s>\n"),
			      str, opcode->comp_suffix);
		      return;
		    }
d11951 10
a11960 2
		  r++;
		}
d11962 5
a11966 6
	      /* The remainder, if any should now be flags for the instruction;
		 Scan these checking each one found with the opcode.  */
	      if (r != p)
		{
		  char d;
		  CONST struct asm_flg *flag = opcode->flags;
d11968 2
a11969 3
		  if (flag)
		    {
		      int flagno;
d11971 4
a11974 2
		      d = *p;
		      *p = '\0';
d11976 5
a11980 16
		      for (flagno = 0; flag[flagno].template; flagno++)
			{
			  if (streq (r, flag[flagno].template))
			    {
			      flag_bits |= flag[flagno].set_bits;
			      break;
			    }
			}

		      *p = d;
		      if (! flag[flagno].template)
			goto try_shorter;
		    }
		  else
		    goto try_shorter;
		}
d11982 6
a11987 4
	      (*opcode->parms) (p, flag_bits);
	      output_inst ();
	      return;
	    }
d11989 4
a11992 2
	try_shorter:
	  ;
d11994 24
d12020 5
a12024 7
  /* It wasn't an instruction, but it might be a register alias of the form
     alias .req reg.  */
  q = p;
  skip_whitespace (q);

  c = *p;
  *p = '\0';
d12026 2
a12027 5
  if (*q && !strncmp (q, ".req ", 4))
    {
      int    reg;
      char * copy_of_str;
      char * r;
d12029 2
a12030 4
#ifdef IGNORE_OPCODE_CASE
      str = original_case_string;
#endif
      copy_of_str = str;
d12032 3
a12034 2
      q += 4;
      skip_whitespace (q);
d12036 7
a12042 3
      for (r = q; *r != '\0'; r++)
	if (*r == ' ')
	  break;
d12044 4
a12047 4
      if (r != q)
	{
	  int regnum;
	  char d = *r;
d12049 5
a12053 3
	  *r = '\0';
	  regnum = arm_reg_parse (& q);
	  *r = d;
a12054 1
	  reg = arm_reg_parse (& str);
d12056 5
a12060 12
	  if (reg == FAIL)
	    {
	      if (regnum != FAIL)
		insert_reg_alias (str, regnum);
	      else
		as_warn (_("register '%s' does not exist\n"), q);
	    }
	  else if (regnum != FAIL)
	    {
	      if (reg != regnum)
		as_warn (_("ignoring redefinition of register alias '%s'"),
			 copy_of_str);
d12062 2
a12063 8
	      /* Do not warn about redefinitions to the same alias.  */
	    }
	  else
	    as_warn (_("ignoring redefinition of register alias '%s' to non-existant register '%s'"),
		     copy_of_str, q);
	}
      else
	as_warn (_("ignoring incomplete .req pseuso op"));
d12065 2
a12066 3
      *p = c;
      return;
    }
d12068 2
a12069 2
  *p = c;
  as_bad (_("bad instruction `%s'"), start);
d12072 12
a12083 30
/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.  These are:
      Cpu variants, the arm part is optional:
              -m[arm]1                Currently not supported.
              -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
              -m[arm]3                Arm 3 processor
              -m[arm]6[xx],           Arm 6 processors
              -m[arm]7[xx][t][[d]m]   Arm 7 processors
              -m[arm]8[10]            Arm 8 processors
              -m[arm]9[20][tdmi]      Arm 9 processors
              -mstrongarm[110[0]]     StrongARM processors
              -mxscale                XScale processors
              -m[arm]v[2345[t[e]]]    Arm architectures
              -mall                   All (except the ARM1)
      FP variants:
              -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions
              -mfpe-old               (No float load/store multiples)
              -mno-fpu                Disable all floating point instructions
      Run-time endian selection:
              -EB                     big endian cpu
              -EL                     little endian cpu
      ARM Procedure Calling Standard:
  	      -mapcs-32		      32 bit APCS
  	      -mapcs-26		      26 bit APCS
  	      -mapcs-float	      Pass floats in float regs
  	      -mapcs-reentrant        Position independent code
              -mthumb-interwork       Code supports Arm/Thumb interworking
              -matpcs                 ARM/Thumb Procedure Call Standard
              -moabi                  Old ELF ABI  */
d12085 3
a12087 1
CONST char * md_shortopts = "m:k";
d12089 1
a12089 1
struct option md_longopts[] =
d12091 7
a12097 11
#ifdef ARM_BI_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
  {"EB", no_argument, NULL, OPTION_EB},
#define OPTION_EL (OPTION_MD_BASE + 1)
  {"EL", no_argument, NULL, OPTION_EL},
#ifdef OBJ_ELF
#define OPTION_OABI (OPTION_MD_BASE +2)
  {"oabi", no_argument, NULL, OPTION_OABI},
#endif
#endif
  {NULL, no_argument, NULL, 0}
a12099 2
size_t md_longopts_size = sizeof (md_longopts);

d12105 2
a12106 1
  char * str = arg;
d12110 1
a12110 1
#ifdef ARM_BI_ENDIAN
d12114 3
d12122 7
a12128 2
    case 'm':
      switch (*str)
d12130 9
a12138 21
	case 'f':
	  if (streq (str, "fpa10"))
	    cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_FPA10;
	  else if (streq (str, "fpa11"))
	    cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_FPA11;
	  else if (streq (str, "fpe-old"))
	    cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_CORE;
	  else
	    goto bad;
	  break;

	case 'n':
	  if (streq (str, "no-fpu"))
	    cpu_variant &= ~FPU_ALL;
	  break;

#ifdef OBJ_ELF
	case 'o':
	  if (streq (str, "oabi"))
	    target_oabi = true;
	  break;
d12141 2
a12142 19
	case 't':
	  /* Limit assembler to generating only Thumb instructions:  */
	  if (streq (str, "thumb"))
	    {
	      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_EXT_THUMB;
	      cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_NONE;
	      thumb_mode = 1;
	    }
	  else if (streq (str, "thumb-interwork"))
	    {
	      if ((cpu_variant & ARM_EXT_THUMB) == 0)
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V4T;
#if defined OBJ_COFF || defined OBJ_ELF
	      support_interwork = true;
#endif
	    }
	  else
	    goto bad;
	  break;
a12143 4
	default:
	  if (streq (str, "all"))
	    {
	      cpu_variant = ARM_ALL | FPU_ALL;
d12146 1
a12146 5
#if defined OBJ_COFF || defined OBJ_ELF
	  if (! strncmp (str, "apcs-", 5))
	    {
	      /* GCC passes on all command line options starting "-mapcs-..."
		 to us, so we must parse them here.  */
d12148 7
a12154 51
	      str += 5;

	      if (streq (str, "32"))
		{
		  uses_apcs_26 = false;
		  return 1;
		}
	      else if (streq (str, "26"))
		{
		  uses_apcs_26 = true;
		  return 1;
		}
	      else if (streq (str, "frame"))
		{
		  /* Stack frames are being generated - does not affect
		     linkage of code.  */
		  return 1;
		}
	      else if (streq (str, "stack-check"))
		{
		  /* Stack checking is being performed - does not affect
		     linkage, but does require that the functions
		     __rt_stkovf_split_small and __rt_stkovf_split_big be
		     present in the final link.  */

		  return 1;
		}
	      else if (streq (str, "float"))
		{
		  /* Floating point arguments are being passed in the floating
		     point registers.  This does affect linking, since this
		     version of the APCS is incompatible with the version that
		     passes floating points in the integer registers.  */

		  uses_apcs_float = true;
		  return 1;
		}
	      else if (streq (str, "reentrant"))
		{
		  /* Reentrant code has been generated.  This does affect
		     linking, since there is no point in linking reentrant/
		     position independent code with absolute position code.  */
		  pic_code = true;
		  return 1;
		}

	      as_bad (_("Unrecognised APCS switch -m%s"), arg);
	      return 0;
	    }

	  if (! strcmp (str, "atpcs"))
d12156 5
a12160 3
	      atpcs = true;
	      return 1;
	    }
a12161 190
	  /* Strip off optional "arm".  */
	  if (! strncmp (str, "arm", 3))
	    str += 3;

	  switch (*str)
	    {
	    case '1':
	      if (streq (str, "1"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_1;
	      else
		goto bad;
	      break;

	    case '2':
	      if (streq (str, "2"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_2;
	      else if (streq (str, "250"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_250;
	      else
		goto bad;
	      break;

	    case '3':
	      if (streq (str, "3"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_3;
	      else
		goto bad;
	      break;

	    case '6':
	      switch (strtol (str, NULL, 10))
		{
		case 6:
		case 60:
		case 600:
		case 610:
		case 620:
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_6;
		  break;
		default:
		  goto bad;
		}
	      break;

	    case '7':
	      /* Eat the processor name.  */
	      switch (strtol (str, & str, 10))
		{
		case 7:
		case 70:
		case 700:
		case 710:
		case 720:
		case 7100:
		case 7500:
		  break;
		default:
		  goto bad;
		}
	      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
	      for (; *str; str++)
		{
		  switch (*str)
		    {
		    case 't':
		      cpu_variant |= ARM_ARCH_V4T;
		      break;

		    case 'm':
		      cpu_variant |= ARM_EXT_LONGMUL;
		      break;

		    case 'f': /* fe => fp enabled cpu.  */
		      if (str[1] == 'e')
			++ str;
		      else
			goto bad;

		    case 'c': /* Left over from 710c processor name.  */
		    case 'd': /* Debug.  */
		    case 'i': /* Embedded ICE.  */
		      /* Included for completeness in ARM processor naming.  */
		      break;

		    default:
		      goto bad;
		    }
		}
	      break;

	    case '8':
	      if (streq (str, "8") || streq (str, "810"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_8 | ARM_ARCH_V4;
	      else
		goto bad;
	      break;

	    case '9':
	      if (streq (str, "9"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4T;
	      else if (streq (str, "920"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4;
	      else if (streq (str, "920t"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4T;
	      else if (streq (str, "9tdmi"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4T;
	      else
		goto bad;
	      break;

	    case 's':
	      if (streq (str, "strongarm")
		  || streq (str, "strongarm110")
		  || streq (str, "strongarm1100"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_8 | ARM_ARCH_V4;
	      else
		goto bad;
	      break;

            case 'x':
 	      if (streq (str, "xscale"))
 		cpu_variant = ARM_9 | ARM_ARCH_XSCALE;
 	      else
 		goto bad;
      	      break;

	    case 'v':
	      /* Select variant based on architecture rather than
                 processor.  */
	      switch (*++str)
		{
		case '2':
		  switch (*++str)
		    {
		    case 'a':
		      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_3;
		      break;
		    case 0:
		      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_2;
		      break;
		    default:
		      as_bad (_("Invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;

		case '3':
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;

		  switch (*++str)
		    {
		    case 'm': cpu_variant |= ARM_EXT_LONGMUL; break;
		    case 0:   break;
		    default:
		      as_bad (_("Invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;

		case '4':
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7 | ARM_ARCH_V4;

		  switch (*++str)
		    {
		    case 't': cpu_variant |= ARM_EXT_THUMB; break;
		    case 0:   break;
		    default:
		      as_bad (_("Invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;

		case '5':
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCH_V5;
		  switch (*++str)
		    {
		    case 't': cpu_variant |= ARM_EXT_THUMB; break;
		    case 'e': cpu_variant |= ARM_EXT_V5E; break;
		    case 0:   break;
		    default:
		      as_bad (_("Invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;
d12163 2
a12164 10
		default:
		  as_bad (_("Invalid architecture variant -m%s"), arg);
		  break;
		}
	      break;

	    default:
	    bad:
	      as_bad (_("Invalid processor variant -m%s"), arg);
	      return 0;
a12166 7
      break;

#if defined OBJ_ELF || defined OBJ_COFF
    case 'k':
      pic_code = 1;
      break;
#endif
d12168 1
a12168 1
    default:
d12179 14
d12194 1
a12194 16
 ARM Specific Assembler Options:\n\
  -m[arm][<processor name>] select processor variant\n\
  -m[arm]v[2|2a|3|3m|4|4t|5[t][e]] select architecture variant\n\
  -mthumb                   only allow Thumb instructions\n\
  -mthumb-interwork         mark the assembled code as supporting interworking\n\
  -mall                     allow any instruction\n\
  -mfpa10, -mfpa11          select floating point architecture\n\
  -mfpe-old                 don't allow floating-point multiple instructions\n\
  -mno-fpu                  don't allow any floating-point instructions.\n\
  -k                        generate PIC code.\n"));
#if defined OBJ_COFF || defined OBJ_ELF
  fprintf (fp, _("\
  -mapcs-32, -mapcs-26      specify which ARM Procedure Calling Standard to use\n\
  -matpcs                   use ARM/Thumb Procedure Calling Standard\n\
  -mapcs-float              floating point args are passed in FP regs\n\
  -mapcs-reentrant          the code is position independent/reentrant\n"));
d12196 2
a12197 5
#ifdef OBJ_ELF
  fprintf (fp, _("\
  -moabi                    support the old ELF ABI\n"));
#endif
#ifdef ARM_BI_ENDIAN
d12199 1
a12199 2
  -EB                       assemble code for a big endian cpu\n\
  -EL                       assemble code for a little endian cpu\n"));
d12287 1
a12287 2
  if (current_poolP == NULL)
    return;
d12289 6
a12294 4
  /* Put it at the end of text section.  */
  subseg_set (text_section, 0);
  s_ltorg (0);
  listing_prev_line ();
d12326 1
a12326 1
		
d12336 1
a12336 1
     
d12355 1
a12355 1
      label_is_thumb_function_name = false;
d12385 1
a12385 1
          else switch (S_GET_STORAGE_CLASS (sym))
d12459 2
a12460 1
boolean
a12473 1
      return true;
d12475 24
d12500 1
a12500 1
  return false;
d12510 1
a12510 1
boolean
d12519 1
d12534 1
a12534 1
boolean
a12540 7
  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;

  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;

d12550 6
a12585 15
int
arm_force_relocation (fixp)
     struct fix * fixp;
{
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;

  return 0;
}

d12611 1
a12611 1
       i < sizeof (id) && (isalnum (*ip) || ispunct (*ip));
d12613 1
a12613 1
    id[i] = tolower (*ip);
d12696 1
a12696 1
  
d12703 1
a12703 1
  
d12706 1
a12706 1
  
d12723 1
a12723 1
  
d12739 1
a12739 1
  
d12758 1
a12758 1
  
@


1.5
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999, 2000 Free Software Foundation, Inc.
d29 1
a29 1
/* need TARGET_CPU */
d38 1
d47 3
a49 3
#define ARM_7		ARM_6           /* same core instruction set */
#define ARM_8		ARM_6           /* same core instruction set */
#define ARM_9		ARM_6           /* same core instruction set */
d52 7
a58 6
/* The following bitmasks control CPU extensions (ARM7 onwards): */
#define ARM_LONGMUL	0x00000010	/* allow long multiplies */
#define ARM_HALFWORD    0x00000020	/* allow half word loads */
#define ARM_THUMB       0x00000040	/* allow BX instruction  */
#define ARM_EXT_V5	0x00000080	/* allow CLZ etc	 */
#define ARM_EXT_V5E     0x00000200	/* "El Segundo" 	 */
d61 3
a63 2
#define ARM_ARCH_V4	(ARM_7 | ARM_LONGMUL | ARM_HALFWORD)
#define ARM_ARCH_V4T	(ARM_ARCH_V4 | ARM_THUMB)
d65 3
a67 1
#define ARM_ARCH_V5T	(ARM_ARCH_V5 | ARM_THUMB)
d72 1
a72 1
#define ARM_ALL		ARM_2UP		/* Not arm1 only */
d74 1
a74 1
#define ARM_6UP		0x00fffff8      /* Includes ARM7 */
d81 3
a83 3
/* Some useful combinations  */
#define FPU_ALL		0xff000000	/* Note this is ~ARM_ANY */
#define FPU_MEMMULTI	0x7f000000	/* Not fpu_core */
a84 1
     
d86 3
d90 1
a90 1
#define CPU_DEFAULT (ARM_ARCH_V4 | ARM_THUMB)
d92 2
a93 1
#define CPU_DEFAULT ARM_ALL
d102 1
a102 1
#define skip_whitespace(str)  while (* (str) == ' ') ++ (str)
d104 1
a104 1
static unsigned long	cpu_variant = CPU_DEFAULT | FPU_DEFAULT;
d108 6
a113 5
/* Flags stored in private area of BFD structure */
static boolean		uses_apcs_26 = false;
static boolean		support_interwork = false;
static boolean		uses_apcs_float = false;
static boolean		pic_code = false;
a128 1
#ifdef TE_LINUX
a129 3
#else
CONST char line_separator_chars[] = "";
#endif
d135 3
a137 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d146 2
a147 1
symbolS * GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
d150 8
a157 1
CONST int md_reloc_size = 8;	/* Size of relocation record */
a158 3
static int thumb_mode = 0;      /* 0: assemble for ARM, 1: assemble for Thumb,
				   2: assemble for Thumb even though target cpu
				   does not support thumb instructions.  */
d171 5
a175 5
    {
      bfd_reloc_code_real_type type;
      expressionS              exp;
      int                      pc_rel;
    } reloc;
d180 27
a206 1
struct asm_shift
d208 2
a209 2
  CONST char *  template;
  unsigned long value;
d212 1
a212 1
static CONST struct asm_shift shift[] =
d214 12
a225 12
  {"asl", 0},
  {"lsl", 0},
  {"lsr", 0x00000020},
  {"asr", 0x00000040},
  {"ror", 0x00000060},
  {"rrx", 0x00000060},
  {"ASL", 0},
  {"LSL", 0},
  {"LSR", 0x00000020},
  {"ASR", 0x00000040},
  {"ROR", 0x00000060},
  {"RRX", 0x00000060}
d233 1
a233 1
CONST char * fp_const[] = 
d257 5
a261 3
#define CONDS_BIT       (0x00100000)
#define LOAD_BIT        (0x00100000)
#define TRANS_BIT	(0x00200000)
d272 1
a272 1
static CONST struct asm_cond conds[] = 
d297 2
a298 2
  CONST char *  template;	/* Basic flag string */
  unsigned long set_bits;	/* Bits to set */
d309 1
d321 1
d347 1
a347 1
  {"fa", 0x08000000},
d351 1
a351 1
  {"da", 0x08000000},
d357 1
a357 1
  {"ed", 0x08000000},
d364 1
a364 1
  {"da", 0x08000000},
d430 5
a434 2
#define SPSR_BIT   (1 << 22)  /* The bit that distnguishes CPSR and SPSR.  */
#define PSR_SHIFT  16  /* How many bits to shift the PSR_xxx bits up by.  */
d450 1
a450 1
  {"SPSR_f",    false, PSR_f}, 
d459 121
a579 14
  /* For backwards compatability with older toolchain we also
     support lower case versions of some of these flags.  */
  {"cpsr",	true,  PSR_c | PSR_f},
  {"cpsr_all",	true,  PSR_c | PSR_f},
  {"spsr",	false, PSR_c | PSR_f},
  {"spsr_all",	false, PSR_c | PSR_f},
  {"cpsr_flg",	true,  PSR_f},
  {"cpsr_f",    true,  PSR_f},
  {"spsr_flg",	false, PSR_f},
  {"spsr_f",    false, PSR_f}, 
  {"cpsr_c",	true,  PSR_c},
  {"cpsr_ctl",	true,  PSR_c},
  {"spsr_c",	false, PSR_c},
  {"spsr_ctl",	false, PSR_c}
d583 1
a583 1
/* ARM instructions */
d591 1
a591 1
/* Pseudo Op codes */			       		      
d595 1
a595 1
/* ARM 2 */				       		      
d598 1
a598 1
/* ARM 3 */				       		      
d600 1
a600 1
/* ARM 6 */				       		      
d603 1
a603 1
/* ARM 7M */				       		      
d605 1
a605 1
/* ARM THUMB */				       		      
d608 26
a633 2
					       		      
/* Coprocessor Instructions */		       		      
d690 9
a698 2
/* LONGEST_INST is the longest basic instruction name without conditions or 
   flags.  ARM7M has 4 of length 5.  */
d700 2
a701 1
#define LONGEST_INST 5
d703 3
d707 2
a708 4
struct asm_opcode 
{
  CONST char *           template;	/* Basic string to match */
  unsigned long          value;		/* Basic instruction code */
d710 2
a711 3
  /* Compulsory suffix that must follow conds. If "", then the
     instruction is not conditional and must have no suffix. */
  CONST char *           comp_suffix;	
d713 2
a714 4
  CONST struct asm_flg * flags;	        /* Bits to toggle if flag 'n' set */
  unsigned long          variants;	/* Which CPU variants this exists for */
  /* Function to call to parse args */
  void (*                parms) PARAMS ((char *, unsigned long));
d717 1
a717 1
static CONST struct asm_opcode insns[] = 
d719 14
a732 1
/* ARM Instructions */
d761 2
a762 2
  
/* Pseudo ops */
d767 1
a767 1
/* ARM 2 multiplies */
d771 1
a771 1
/* ARM 3 - swp instructions */
d774 1
a774 1
/* ARM 6 Coprocessor instructions */
d781 5
a785 5
/* ARM 7M long multiplies - need signed/unsigned flags! */
  {"smull", 0x00c00090, NULL,   s_flag,      ARM_LONGMUL,  do_mull},
  {"umull", 0x00800090, NULL,   s_flag,      ARM_LONGMUL,  do_mull},
  {"smlal", 0x00e00090, NULL,   s_flag,      ARM_LONGMUL,  do_mull},
  {"umlal", 0x00a00090, NULL,   s_flag,      ARM_LONGMUL,  do_mull},
d787 2
a788 2
/* ARM THUMB interworking */
  {"bx",    0x012fff10, NULL,   NULL,        ARM_THUMB,    do_bx},
d790 1
a790 1
/* Floating point instructions */
d844 42
d1025 1
a1025 1
struct thumb_opcode 
d1027 13
a1039 5
  CONST char *  template;	/* Basic string to match */
  unsigned long value;		/* Basic instruction code */
  int           size;
  unsigned long          variants;    /* Which CPU variants this exists for */
  void (*       parms) PARAMS ((char *));  /* Function to call to parse args */
d1044 60
a1103 58
  {"adc",	0x4140,		2,	ARM_THUMB, do_t_arit},
  {"add",	0x0000,		2,	ARM_THUMB, do_t_add},
  {"and",	0x4000,		2,	ARM_THUMB, do_t_arit},
  {"asr",	0x0000,		2,	ARM_THUMB, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_THUMB, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_THUMB, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_THUMB, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_THUMB, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_THUMB, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_THUMB, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_THUMB, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_THUMB, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_THUMB, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_THUMB, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_THUMB, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_THUMB, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_THUMB, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_THUMB, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_THUMB, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_THUMB, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_THUMB, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_THUMB, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_THUMB, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_THUMB, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_THUMB, do_t_branch23},
  {"bx",	0x4700,		2,	ARM_THUMB, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_THUMB, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_THUMB, do_t_compare},
  {"eor",	0x4040,		2,	ARM_THUMB, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_THUMB, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_THUMB, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_THUMB, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_THUMB, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_THUMB, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_THUMB, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_THUMB, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_THUMB, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_THUMB, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_THUMB, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_THUMB, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_THUMB, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_THUMB, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_THUMB, do_t_arit},
  {"orr",	0x4300,		2,	ARM_THUMB, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_THUMB, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_THUMB, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_THUMB, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_THUMB, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_THUMB, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_THUMB, do_t_str},
  {"strb",	0x0000,		2,	ARM_THUMB, do_t_strb},
  {"strh",	0x0000,		2,	ARM_THUMB, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_THUMB, do_t_swi},
  {"sub",	0x0000,		2,	ARM_THUMB, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_THUMB, do_t_arit},
  /* Pseudo ops: */
  {"adr",       0x0000,         2,      ARM_THUMB, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_THUMB, do_t_nop},      /* mov r8,r8 */
d1120 1
a1120 1
/* These are the standard names.  Users can add aliases with .req  */
d1160 1
d1162 3
a1164 3
static struct hash_control * arm_ops_hsh = NULL;
static struct hash_control * arm_tops_hsh = NULL;
static struct hash_control * arm_cond_hsh = NULL;
d1166 2
a1167 2
static struct hash_control * arm_reg_hsh = NULL;
static struct hash_control * arm_psr_hsh = NULL;
d1197 2
a1198 1
  { "req",         s_req,         0 },	/* Never called becasue '.req' does not start line */
d1213 1
a1213 1
#ifdef OBJ_ELF  
d1220 2
d1244 1
a1244 1
/* Literal stuff */
d1250 2
a1251 2
  struct expressionS  exp;
  struct arm_it *     inst;
d1254 8
a1261 3
literalT  literals[MAX_LITERAL_POOL_SIZE];
int       next_literal_pool_place = 0; /* Next free entry in the pool */
int       lit_pool_num = 1; /* Next literal pool number */
d1277 14
a1290 4
          && inst.reloc.exp.X_op == O_constant
          && literals[lit_count].exp.X_add_number
	     == inst.reloc.exp.X_add_number
          && literals[lit_count].exp.X_unsigned == inst.reloc.exp.X_unsigned)
d1292 1
d1296 1
a1296 1
  if (lit_count == next_literal_pool_place) /* new entry */
d1298 5
a1302 5
      if (next_literal_pool_place > MAX_LITERAL_POOL_SIZE)
        {
          inst.error = _("Literal Pool Overflow");
          return FAIL;
        }
d1314 1
a1314 1
 
d1317 1
d1320 5
a1324 5
     symbolS *    symbolP; 
     CONST char * name;		/* It is copied, the caller can modify */
     segT         segment;	/* Segment identifier (SEG_<something>) */
     valueT       valu;		/* Symbol value */
     fragS *      frag;		/* Associated fragment */
d1329 1
a1329 1
  name_length = strlen (name) + 1;      /* +1 for \0 */
d1364 1
a1364 1
 
d1367 1
a1367 1
#endif /* DEBUG_SYMS */
d1370 3
a1372 2
/* Check that an immediate is valid, and if so,
   convert it to the right format.  */
d1379 1
a1379 1
  
d1381 1
a1381 1
  
d1384 2
a1385 2
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const] */
  
d1392 1
d1395 1
a1395 1
     unsigned int val;
d1400 1
a1400 1
  
a1413 1

a1418 1

d1424 1
a1424 1
  
d1434 1
a1434 1
     return FAIL;
a1437 1
    
d1450 1
a1450 1
     marking in_bss, then looking at s_skip for clues?.. */
d1459 2
a1460 1
  if (!need_pass_2)		/* Never make frag if expect extra pass. */
d1462 1
a1462 1
  
d1464 1
a1464 1
  
d1478 2
a1479 2
  /* Align pool as you have word accesses */
  /* Only make a frag if we have to ... */
d1492 1
a1492 1
  
d1496 1
a1496 1
  
d1499 1
a1499 1
    emit_expr (&(literals[lit_count++].exp), 4); /* .word */
d1505 2
d1508 1
a1508 1
s_align (unused)	/* Same as s_align_ptwo but align 0 => align 2 */
d1535 1
a1535 1
  /* Only make a frag if we HAVE to. . . */
a1551 1
     
d1555 1
a1555 1
      
d1558 1
a1558 1
  
d1566 3
d1571 1
a1572 2
  label_is_thumb_function_name = true;
  
d1591 3
a1593 5
  /*
   * Especial apologies for the random logic:
   * this just grew, and could be parsed much more simply!
   * Dean in haste.
   */
d1598 1
a1598 1
  
d1615 1
a1615 1
      /* XXX - this should not happen to .thumb_set  */
d1629 3
a1631 2
	  fragS * dummy_frag = (fragS *) xmalloc (sizeof(fragS));
	  memset (dummy_frag, 0, sizeof(fragS));
d1639 2
a1640 2
        symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
			    
d1642 1
a1642 1
      /* "set" symbols are local unless otherwise specified. */
d1644 2
a1645 2
#endif /* OBJ_COFF */
    }				/* make a new symbol */
d1657 1
a1657 1
  
d1661 1
a1661 1
  
d1670 1
d1677 1
a1677 1
  
d1696 1
a1696 1
  
d1724 1
a1724 1
	  if (! (cpu_variant & ARM_THUMB))
d1726 1
d1728 3
a1730 3
          /* No need to force the alignment, since we will have been
             coming from ARM mode, which is word-aligned. */
          record_alignment (now_seg, 1);
d1737 1
a1737 1
          if ((cpu_variant & ARM_ANY) == ARM_THUMB)
d1739 1
d1741 2
a1742 1
          if (!need_pass_2)
d1744 1
d1803 1
a1803 1
  char *p = *str, c;
d1805 1
a1805 1
    
d1821 2
a1822 2
   Shift is the place to put it in inst.instruction.
   Restores input start point on err.
d1824 1
d1830 3
a1832 3
  static char buff [128]; /* XXX */
  int    reg;
  char * start = *str;
d1843 1
a1843 1
  
d1873 7
d1894 1
d1899 1
a1899 1
  char * start = *str;
d1901 1
a1901 1
  
d1912 1
a1912 1
      
d2022 2
a2023 2
  int reg;
  char * start = *str;
d2056 1
a2056 1
  
d2059 1
a2059 1
  
d2063 1
a2063 1
      
d2112 1
a2112 1
	  
d2115 1
a2115 1
	      /* [Rn], #expr */
d2117 1
a2117 1
	      
d2132 1
a2132 1
	  /* '['Rn, #expr']'[!] */
d2141 1
a2141 1
	  
d2174 1
a2174 1
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust */
d2202 1
a2202 1
  
d2226 1
d2228 1
a2228 1
  else if (strcmp (str, "cpsr_all") == 0
d2240 1
a2240 1
  
d2248 1
d2258 1
a2258 1
    
d2269 1
a2269 1
      inst.error = NULL; 
d2277 2
a2278 1
      inst.error = _("only a register or immediate value can follow a psr flag");
d2284 1
a2284 1
  
d2287 2
a2288 1
      inst.error = _("only a register or immediate value can follow a psr flag");
d2291 7
a2297 2
  
  if (inst.instruction & ((PSR_c | PSR_x | PSR_s) << PSR_SHIFT))
d2299 1
a2299 1
      inst.error = _("only flag field of psr can be set with immediate value");
d2302 2
a2303 1
  
d2305 1
a2305 1
	  
d2314 1
a2314 1
      
d2320 1
a2320 1
      
d2324 1
a2324 1
  inst.error = NULL; 
d2333 2
a2334 2
   SMLAL RdLo, RdHi, Rm, Rs
*/   
d2342 1
a2342 1
  /* Only one format "rdlo, rdhi, rm, rs" */
d2365 1
a2365 1
  /* rdhi, rdlo and rm must all be different */
d2381 1
a2381 1
   
d2389 1
a2389 1
     char *        str;
d2393 2
a2394 2
  
  /* Only one format "rd, rm, rs" */
d2445 1
a2445 1
     char *        str;
d2450 1
a2450 1
  /* Only one format "rd, rm, rs, rn" */
d2501 7
a2507 2
/* Returns the index into fp_values of a floating point number, or -1 if
   not in the table.  */
d2509 1
a2509 1
my_get_float_expression (str)
d2512 6
a2517 5
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *         save_in;
  expressionS    exp;
  int            i;
  int            j;
d2519 4
a2522 12
  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));
  /* Look for a raw floating point number */
  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
      && (is_end_of_line [(int)(*save_in)] || *save_in == '\0'))
    {
      for (i = 0; i < NUM_FLOAT_VALS; i++)
	{
	  for (j = 0; j < MAX_LITTLENUMS; j++)
	    {
	      if (words[j] != fp_values[i][j])
		break;
	    }
d2524 1
a2524 7
	  if (j == MAX_LITTLENUMS)
	    {
	      *str = save_in;
	      return i;
	    }
	}
    }
d2526 1
a2526 7
  /* Try and parse a more complex expression, this will probably fail
     unless the code uses a floating point prefix (eg "0f") */
  save_in = input_line_pointer;
  input_line_pointer = *str;
  if (expression (&exp) == absolute_section
      && exp.X_op == O_big
      && exp.X_add_number < 0)
d2528 3
a2530 20
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.  */
      if (gen_to_words (words, 5, (long)15) == 0)
	{
	  for (i = 0; i < NUM_FLOAT_VALS; i++)
	    {
	      for (j = 0; j < MAX_LITTLENUMS; j++)
		{
		  if (words[j] != fp_values[i][j])
		    break;
		}

	      if (j == MAX_LITTLENUMS)
		{
		  *str = input_line_pointer;
		  input_line_pointer = save_in;
		  return i;
		}
	    }
	}
d2533 3
a2535 3
  *str = input_line_pointer;
  input_line_pointer = save_in;
  return -1;
d2538 7
a2544 1
/* Return true if anything in the expression is a bignum */
d2546 2
a2547 2
walk_no_bignums (sp)
     symbolS * sp;
d2549 5
a2553 2
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;
d2555 1
a2555 1
  if (symbol_get_value_expression (sp)->X_add_symbol)
d2557 1
a2557 4
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
    }
d2559 1
a2559 2
  return 0;
}
d2561 2
a2562 11
static int
my_get_expression (ep, str)
     expressionS * ep;
     char ** str;
{
  char * save_in;
  segT   seg;
  
  save_in = input_line_pointer;
  input_line_pointer = *str;
  seg = expression (ep);
d2564 1115
a3678 13
#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad_segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
#endif
d3700 2
a3701 2
/* unrestrict should be one if <shift> <register> is permitted for this
   instruction */
d3708 1
a3708 1
  struct asm_shift * shft;
d3711 1
a3711 1
    
d3713 2
a3714 2
    
  for (p = *str; isalpha (*p); p++)
d3717 1
a3717 1
  if (p == *str)
d3723 14
a3736 5
  c = *p;
  *p = '\0';
  shft = (struct asm_shift *) hash_find (arm_shift_hsh, *str);
  *p = c;
  if (shft)
d3738 4
a3741 7
      if (!strncmp (*str, "rrx", 3)
          || !strncmp (*str, "RRX", 3))
	{
	  *str = p;
	  inst.instruction |= shft->value;
	  return SUCCESS;
	}
d3743 1
a3743 14
      skip_whitespace (p);
      
      if (unrestrict && reg_required_here (&p, 8) != FAIL)
	{
	  inst.instruction |= shft->value | SHIFT_BY_REG;
	  *str = p;
	  return SUCCESS;
	}
      else if (is_immediate_prefix (* p))
	{
	  inst.error = NULL;
	  p++;
	  if (my_get_expression (&inst.reloc.exp, &p))
	    return FAIL;
d3745 14
a3758 4
	  /* Validate some simple #expressions */
	  if (inst.reloc.exp.X_op == O_constant)
	    {
	      unsigned num = inst.reloc.exp.X_add_number;
d3760 2
a3761 6
	      /* Reject operations greater than 32, or lsl #32 */
	      if (num > 32 || (num == 32 && shft->value == 0))
		{
		  inst.error = _("Invalid immediate shift");
		  return FAIL;
		}
d3763 2
a3764 6
	      /* Shifts of zero should be converted to lsl (which is zero)*/
	      if (num == 0)
		{
		  *str = p;
		  return SUCCESS;
		}
d3766 4
a3769 4
	      /* Shifts of 32 are encoded as 0, for those shifts that
		 support it.  */
	      if (num == 32)
		num = 0;
d3771 22
a3792 3
	      inst.instruction |= (num << 7) | shft->value;
	      *str = p;
	      return SUCCESS;
d3794 1
d3796 12
a3807 13
	  inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
	  inst.reloc.pc_rel = 0;
	  inst.instruction |= shft->value;
	  *str = p;
	  return SUCCESS;
	}
      else
	{
	  inst.error = unrestrict ? _("shift requires register or #expression")
	    : _("shift requires #expression");
	  *str = p;
	  return FAIL;
	}
d3810 2
a3811 2
  inst.error = _("Shift expression expected");
  return FAIL;
d3814 3
a3816 3
/* Do those data_ops which can take a negative immediate constant */
/* by altering the instuction. A bit of a hack really */
/*      MOV <-> MVN
d3822 2
a3823 2
        by negating the second operand.
*/
d3838 2
a3839 2
      /* First negates */
    case OPCODE_SUB:             /* ADD <-> SUB */
d3844 2
a3845 2
    case OPCODE_ADD: 
      new_inst = OPCODE_SUB;               
d3849 1
a3849 1
    case OPCODE_CMP:             /* CMP <-> CMN */
d3854 2
a3855 2
    case OPCODE_CMN: 
      new_inst = OPCODE_CMP;               
d3859 3
a3861 3
      /* Now Inverted ops */
    case OPCODE_MOV:             /* MOV <-> MVN */
      new_inst = OPCODE_MVN;               
d3865 1
a3865 1
    case OPCODE_MVN: 
d3870 2
a3871 2
    case OPCODE_AND:             /* AND <-> BIC */ 
      new_inst = OPCODE_BIC;               
d3875 1
a3875 1
    case OPCODE_BIC: 
d3880 2
a3881 2
    case OPCODE_ADC:              /* ADC <-> SBC */
      new_inst = OPCODE_SBC;               
d3885 1
a3885 1
    case OPCODE_SBC: 
d3890 2
a3891 2
      /* We cannot do anything */
    default:  
d3900 1
a3900 1
  return value; 
d3911 1
a3911 1
    
d3922 1
a3922 1
      /* Immediate expression */
d3927 1
a3927 1
	  
d3940 1
a3940 1
		  /* #x, y -- ie explicit rotation by Y  */
d3949 2
a3950 2
 
		  /* Rotate must be a multiple of 2 */
d3964 1
a3964 1
	      /* Implicit rotation, select a suitable one  */
d3969 2
a3970 2
		  /* Can't be done, perhaps the code reads something like
		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be ok */
d4003 1
a4003 1
      /* Immediate expression */
d4012 2
a4013 2
	  /* First try and match exact strings, this is to guarantee that
	     some formats will work even for cross assembly */
d4022 1
a4022 1
		  if (is_end_of_line[(int)**str] || **str == '\0')
d4044 2
a4045 1
      inst.error = _("Floating point register or immediate expression expected");
d4052 1
a4052 1
     char *        str;
d4075 1
a4075 1
     char *        str;
d4090 1
a4090 1
  
d4097 1
a4098 1
  return;
d4103 1
a4103 1
     char *        str;
d4109 1
a4109 1
     	add rd, rd, #high(label-.-8)"   */
d4121 1
a4121 1
  
d4123 1
a4123 1
  
d4127 1
a4127 1
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust */
d4131 1
a4131 1
  
d4137 1
a4137 1
     char *        str;
d4167 1
a4167 1
     char *        str;
d4211 2
a4212 2
          if ((hwse && (value < -255 || value > 255))
               || (value < -4095 || value > 4095))
d4224 7
a4230 6
          /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0 */
          if (hwse)
            inst.instruction |= add | HWOFFSET_IMM | ((value >> 4) << 8) | (value & 0xF);
          else
            inst.instruction |= add | value;
d4234 7
a4240 7
          if (hwse)
            {
              inst.instruction |= HWOFFSET_IMM;
              inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
            }
          else
            inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d4246 3
a4248 1
      add = 0;	/* and fall through */
d4250 3
a4252 1
      (*str)++;	/* and fall through */
d4258 1
a4258 1
        inst.instruction |= add;
d4260 5
a4264 5
        {
          inst.instruction |= add | OFFSET_REG;
          if (skip_past_comma (str) == SUCCESS)
            return decode_shift (str, SHIFT_RESTRICT);
        }
d4282 1
a4282 1
     encoding, but the same mnemonic): */
d4287 4
a4290 4
         signed-extension load */
      if ((cpu_variant & ARM_HALFWORD) == 0)
        {
          inst.error
d4292 2
a4293 2
          return;
        }
d4295 2
a4296 2
      inst.instruction = (inst.instruction & COND_MASK)
                         | (flags & ~COND_MASK);
d4302 1
a4302 1
    
d4335 1
a4335 1
	  
d4338 1
a4338 1
	      /* [Rn],... (post inc) */
d4342 10
a4351 2
		as_warn (_("%s register same as write-back base"),
			 (inst.instruction & LOAD_BIT) ? _("destination") : _("source") );
d4355 3
a4357 3
	      /* [Rn] */
              if (halfword)
                inst.instruction |= HWOFFSET_IMM;
d4359 1
a4359 1
              skip_whitespace (str);
d4361 9
a4369 8
              if (*str == '!')
               {
                 if (conflict_reg)
		   as_warn (_("%s register same as write-back base"),
			    (inst.instruction & LOAD_BIT) ? _("destination") : _("source") );
                 str++;
                 inst.instruction |= WRITE_BACK;
               }
d4372 9
a4380 2
	      if (! (flags & TRANS_BIT))
		pre_inc = 1;
d4385 1
a4385 1
	  /* [Rn,...] */
d4410 2
a4411 1
			 (inst.instruction & LOAD_BIT) ? _("destination") : _("source") );
d4419 1
a4419 1
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op */
d4435 1
a4435 1
	  && (value = validate_immediate(inst.reloc.exp.X_add_number)) != FAIL)
d4437 1
a4437 1
	  /* This can be done with a mov instruction */
d4441 2
a4442 2
	  end_of_line(str);
	  return; 
d4446 1
a4446 1
	  /* Insert into literal pool */     
d4450 1
a4450 1
		inst.error = _("literal pool insertion failed"); 
d4454 7
a4460 7
	  /* Change the instruction exp to point to the pool */
          if (halfword)
            {
              inst.instruction |= HWOFFSET_IMM;
              inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
            }
          else
d4464 1
a4464 1
	  pre_inc = 1; 
d4473 4
a4476 4
        {
          inst.instruction |= HWOFFSET_IMM;
          inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
        }
d4478 1
a4478 1
        inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d4480 2
a4481 1
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust */
d4487 1
a4487 1
    
d4500 1
a4500 1
  char * str = *strp;
d4504 1
a4504 1
  /* We come back here if we get ranges concatenated by '+' or '|' */
d4513 1
a4513 1
      
d4518 1
a4518 1
	    
d4523 1
a4523 1
	      
d4527 1
a4527 1
	      
d4537 1
a4537 1
			as_tsktsk 
d4554 3
a4556 2
	    } while (skip_past_comma (&str) != FAIL
		     || (in_range = 1, *str++ == '-'));
d4575 1
a4575 1
	      if (expr.X_add_number 
d4588 1
a4588 1
		  as_tsktsk 
d4616 2
a4617 1
    } while (another_range);
d4625 1
a4625 1
     char *        str;
d4671 1
a4671 1
     char *        str;
d4675 1
a4675 1
  
d4686 1
a4686 1
  
d4688 1
a4688 1
  
d4694 1
a4694 1
     char *        str;
d4698 1
a4698 1
  
d4757 1
a4757 1
     char *        str;
d4762 1
a4762 1
  
d4766 5
a4770 5
  
    /* ScottB: February 5, 1998 */
    /* Check to see of PLT32 reloc required for the instruction.  */
    
    /* arm_parse_reloc() works on input_line_pointer.
d4795 2
a4796 2
#endif /* OBJ_ELF */
  
d4803 1
a4803 1
     char *        str;
d4816 1
d4818 1
a4818 1
    inst.error = BAD_PC;
d4825 1
a4825 1
     char *        str;
d4887 1
a4887 1
     char *        str;
d4925 1
a4925 1
     char *        str;
d4992 1
a4992 1
     char *        str;
d5013 1
a5013 1
     char *        str;
d5055 1
a5055 1
     char *        str;
d5069 1
a5069 1
  /* Get Number of registers to transfer */
d5148 2
a5149 1
	      inst.error = _("R15 not allowed as base register with write-back");
d5158 1
a5158 1
	  /* Pre-decrement */
d5165 1
a5165 1
	  /* Post-increment */
d5195 1
a5195 1
     char *        str;
d5244 1
a5244 1
     char *        str;
d5285 1
a5285 1
     char *        str;
d5312 1
a5312 1
     char *        str;
d5353 1
a5353 1
     char *        str;
d5374 1
a5374 1
/* Thumb specific routines */
d5377 3
a5379 3
   repeated checking of this information in many similar cases. 
   Unlike the 32-bit case we do not insert the register into the opcode 
   here, since the position is often unknown until the full instruction 
d5381 1
d5419 1
d5451 2
a5452 2
	  /* Two operand format, shuffle the registers and pretend there 
	     are 3 */
d5467 1
a5467 1
     for the latter case, EXPR contains the immediate that was found. */
d5479 1
a5479 1
	  /* Can't do this for SUB */
d5513 1
a5513 1
	     we know about in the instruction and let the reloc hacking 
d5530 1
a5530 1
	      /* Quick check, in case offset is MIN_INT */
d5584 1
a5584 1
  
d5615 1
a5615 1
      if ((Rs =  thumb_reg (&str, THUMB_REG_LO)) == FAIL)
d5620 2
a5621 2
	  /* Two operand format, shuffle the registers and pretend there
	     are 3 */
d5636 1
a5636 1
     for the latter case, EXPR contains the immediate that was found. */
d5667 1
a5667 2
	     hacking fix it up */

d5680 1
a5680 1
	  /* Shifts of zero are handled by converting to LSL */
d5684 1
a5684 1
	  /* Shifts of 32 are encoded as a shift of zero */
d5693 1
a5693 1
  
d5729 1
a5729 1
	       since a MOV instruction produces unpredictable results */
d5835 1
a5835 1
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op */
d5844 1
a5844 1
      
d5855 1
a5855 1
	  /* This can be done with a mov instruction */
d5859 1
a5859 1
	  return; 
d5862 1
a5862 1
      /* Insert into literal pool */     
d5866 1
a5866 1
	    inst.error = "literal pool insertion failed"; 
d5873 2
a5874 1
      inst.reloc.exp.X_add_number += 4; /* Adjust ARM pipeline offset to Thumb */
d5885 1
a5885 1
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset */
d5939 1
a5939 1
      /* Immediate offset */
d5955 1
a5955 1
	  
d5968 1
a5968 1
      /* Register offset */
d5989 1
a5989 1
  /* Do nothing */
d5994 1
a5994 1
/* Handle the Format 4 instructions that do not have equivalents in other 
d5997 1
d6010 2
a6011 2
    	inst.error = BAD_ARGS;
      	return;
d6022 1
a6022 1
 	  || inst.instruction == T_OPCODE_MVN)
d6033 1
a6033 1
	  inst.error = _("dest and source1 one must be the same register");
d6093 1
a6093 1
  /* This definiton must agree with the one in gcc/config/arm/thumb.c */
d6097 1
a6097 1
    abort();
d6104 1
a6104 1
  
d6109 1
a6109 1
  
a6120 1

d6127 1
a6127 1
  
d6140 2
a6141 1
    inst.reloc.exp.X_add_symbol = find_real_start (inst.reloc.exp.X_add_symbol);
d6199 1
a6199 1
      /* This really doesn't seem worth it. */
d6299 1
a6299 1
      /* This really doesn't seem worth it. */
d6393 1
a6393 1
  
d6401 2
a6402 2
  int    len = strlen (reg_table[entry].name) + 2;
  char * buf = (char *) xmalloc (len);
d6404 1
a6404 1
  int    i = 0;
d6417 2
a6418 2
  hash_insert (arm_reg_hsh, buf, (PTR) &reg_table[entry]);
  hash_insert (arm_reg_hsh, buf2, (PTR) &reg_table[entry]);
d6427 1
a6427 1
    (struct reg_entry *)xmalloc (sizeof (struct reg_entry));
d6443 1
a6443 1
    if (atof_ieee ((char *)fp_const[i], 'x', fp_values[i]) == NULL)
d6452 1
a6452 1
  
d6460 1
a6460 1
    
d6467 2
a6468 2
  for (i = 0; i < sizeof (shift) / sizeof (struct asm_shift); i++)
    hash_insert (arm_shift_hsh, shift[i].template, (PTR) (shift + i));
d6480 1
a6480 1
    
d6489 18
d6509 1
a6509 1
  
d6516 1
a6516 1
      
d6520 1
a6520 1
      
d6525 1
a6525 1
      
d6530 1
a6530 1
  
d6532 5
a6536 1
  if (cpu_variant != (FPU_DEFAULT | CPU_DEFAULT))
d6538 1
a6538 1
      if (cpu_variant & (ARM_EXT_V5 & ARM_THUMB))
d6540 1
a6540 1
      else if (cpu_variant & ARM_EXT_V5)
d6542 4
a6545 1
      else if (cpu_variant & ARM_THUMB)
d6547 1
a6547 1
      else if ((cpu_variant & ARM_ARCH_V4) == ARM_ARCH_V4)
a6548 2
      else if (cpu_variant & ARM_LONGMUL)
	mach = bfd_mach_arm_3M;
d6550 3
a6552 1
  
d6562 1
d6575 1
a6575 1
static valueT 
d6578 1
a6578 1
     int n;
d6604 2
a6605 2
   of type TYPE, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP .  An error message is
d6687 3
a6689 1
/* The knowledge of the PC's pipeline offset is built into the insns themselves.  */ 
d6694 1
a6694 1
  if (   fixP->fx_addsy
d6698 1
a6698 1
  
d6716 2
a6717 1
/* Round up a section size to the appropriate boundary. */
d6726 1
a6726 1
  /* Round all sects to multiple of 4 */
d6731 2
a6732 2
/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.  Otherwise 
   we have no need to default values of symbols.  */
a6733 1
/* ARGSUSED */
d6746 1
a6746 1
	  
d6748 1
a6748 1
				   (valueT)0, & zero_address_frag);
d6750 1
a6750 1
      
d6754 1
a6754 1
  
d6758 2
a6759 2
/* arm_reg_parse () := if it looks like a register, return its token and 
   advance the pointer. */
d6791 1
a6791 1
  
d6803 3
a6805 3
     fixS *      fixP;
     valueT *    val;
     segT        seg;
d6818 3
a6820 1
#if 0 /* patch from REarnshaw to JDavis (disabled for the moment, since it doesn't work fully) */
d6839 2
a6840 1
		))
d6847 2
a6848 1
  fixP->fx_addnumber = value;	/* Remember value for emit_reloc.  */
d6874 1
a6874 1
	unsigned int newinsn  = 0xe1a00000; /* nop */
d6883 2
a6884 1
	    /* No ?  OK - try using two ADD instructions to generate the value.  */
d6887 2
a6888 1
	    /* Yes - then make sure that the second instruction is also an add.  */
d6893 1
a6893 1
		temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
d6898 2
a6899 1
			      _("Unable to compute ADRL instructions for PC offset of 0x%x"), value);
d6903 4
a6906 3
	    /* Replace the first operand in the 2nd instruction (which is the PC)
	       with the destination register.  We have already added in the PC in the
	       first instruction and we do not want to do it again.  */
d6921 1
a6921 1
      
d6924 1
a6924 1
      
d6926 6
a6931 5
        {
	  as_bad_where (fixP->fx_file, fixP->fx_line, 
                        _("bad immediate value for offset (%ld)"), (long) value);
          break;
        }
d6939 4
a6942 4
     case BFD_RELOC_ARM_OFFSET_IMM8:
     case BFD_RELOC_ARM_HWLITERAL:
      sign = value >= 0;
      
d6947 6
a6952 6
        {
          if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line, 
			_("invalid literal constant: pool needs to be closer"));
          else
            as_bad (_("bad immediate value for half-word offset (%ld)"),
d6954 2
a6955 2
          break;
        }
d6965 1
a6965 1
      
d6971 1
a6971 1
	  as_bad_where (fixP->fx_file, fixP->fx_line, 
d6985 1
a6985 1
	  || (value == 32 
d6994 2
a6995 1
	newval &= ~0x60;	/* Shifts of zero must be done as lsl */
d7000 1
a7000 1
      md_number_to_chars (buf, newval , INSN_SIZE);
d7016 1
a7016 1
	    as_bad_where (fixP->fx_file, fixP->fx_line, 
d7020 1
a7020 1
	  md_number_to_chars (buf, newval , INSN_SIZE);
d7047 2
a7048 2
      if ((value & 0xfe000000UL) != 0
	  && ((value & 0xfe000000UL) != 0xfe000000UL))
d7057 1
a7057 1
	     
d7069 5
a7073 4
	      /* Permit a backward branch provided that enough bits are set.
		 Allow a forwards branch, provided that enough bits are clear.  */
	      if ((value & 0xfe000000UL) == 0xfe000000UL
		  || (value & 0xfe000000UL) == 0)
d7076 1
a7076 1
	  
d7085 3
a7087 3
      
      if ((value & 0xff000000UL) != 0
	  && ((value & 0xff000000UL) != 0xff000000UL))
d7090 1
a7090 1
      
d7095 16
d7112 1
a7112 1
    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* conditional branch */
d7115 9
a7123 9
        addressT diff = (newval & 0xff) << 1;
        if (diff & 0x100)
         diff |= ~0xff;

        value += diff;
        if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
         as_bad_where (fixP->fx_file, fixP->fx_line,
                       _("Branch out of range"));
        newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
d7128 1
a7128 1
    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* unconditional branch */
d7131 9
a7139 9
        addressT diff = (newval & 0x7ff) << 1;
        if (diff & 0x800)
         diff |= ~0x7ff;

        value += diff;
        if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
         as_bad_where (fixP->fx_file, fixP->fx_line,
                       _("Branch out of range"));
        newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
d7144 1
d7147 2
a7148 2
        offsetT newval2;
        addressT diff;
d7151 3
a7153 3
        newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
        diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
        if (diff & 0x400000)
d7158 2
a7159 2
        value += diff;
        if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
d7163 13
a7175 4
        newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
        newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
        md_number_to_chars (buf, newval, THUMB_SIZE);
        md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
d7184 4
a7187 4
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 1);
        }
d7196 4
a7199 4
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 2);
        }
d7206 2
a7207 2
	md_number_to_chars (buf, 0, 4);
	break;
d7216 4
a7219 4
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 4);
        }
d7225 1
a7225 1
      /* It appears the instruction is fully prepared at this point. */
d7232 1
a7232 1
      
d7241 2
a7242 2
      newval |= (value >> 2) | (sign ?  INDEX_UP : 0);
      md_number_to_chars (buf, newval , INSN_SIZE);
d7247 3
a7249 2
      /* Exactly what ranges, and where the offset is inserted depends on
	 the type of instruction, we can establish this from the top 4 bits */
d7252 1
a7252 1
	case 4: /* PC load */
d7262 2
a7263 1
                          (unsigned int)(fixP->fx_frag->fr_address + fixP->fx_where + value));
d7267 1
a7267 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d7269 1
a7269 1
          /* Round up, since pc will be rounded down.  */
d7273 1
a7273 1
	case 9: /* SP load/store */
d7276 1
a7276 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d7280 1
a7280 1
	case 6: /* Word load/store */
d7283 2
a7284 2
			  _("Invalid offset, value too big (0x%08X)"), value);
	  newval |= value << 4; /* 6 - 2 */
d7287 1
a7287 1
	case 7: /* Byte load/store */
d7290 1
a7290 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d7294 1
a7294 1
	case 8: /* Halfword load/store */
d7297 2
a7298 2
			  _("Invalid offset, value too big (0x%08X)"), value);
	  newval |= value << 5; /* 6 - 1 */
d7313 5
a7317 4
            3bit ADD/SUB
            8bit ADD/SUB
            9bit ADD/SUB SP word-aligned
           10bit ADD PC/SP word-aligned
d7321 4
a7324 3
           0x8000  SUB
           0x00F0  Rd
           0x000F  Rs
d7328 18
a7345 18
        int rd = (newval >> 4) & 0xf;
        int rs = newval & 0xf;
        int subtract = newval & 0x8000;

        if (rd == REG_SP)
          {
            if (value & ~0x1fc)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _("Invalid immediate for stack address calculation"));
            newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
            newval |= value >> 2;
          }
        else if (rs == REG_PC || rs == REG_SP)
          {
            if (subtract ||
                value & ~0x3fc)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _("Invalid immediate for address calculation (value = 0x%08lX)"),
d7347 20
a7366 20
            newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
            newval |= rd << 8;
            newval |= value >> 2;
          }
        else if (rs == rd)
          {
            if (value & ~0xff)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _("Invalid 8bit immediate"));
            newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
            newval |= (rd << 8) | value;
          }
        else
          {
            if (value & ~0x7)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            _("Invalid 3bit immediate"));
            newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
            newval |= rd | (rs << 3) | (value << 6);
          }
d7368 1
a7368 1
      md_number_to_chars (buf, newval , THUMB_SIZE);
d7374 6
a7379 6
        {
        case 0x04: /* 8bit immediate MOV */
        case 0x05: /* 8bit immediate CMP */
          if (value < 0 || value > 255)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          _("Invalid immediate: %ld is too large"),
d7381 2
a7382 2
          newval |= value;
          break;
d7384 4
a7387 4
        default:
          abort ();
        }
      md_number_to_chars (buf, newval , THUMB_SIZE);
d7391 1
a7391 1
      /* 5bit shift value (0..31) */
d7397 1
a7397 1
      md_number_to_chars (buf, newval , THUMB_SIZE);
d7416 1
d7465 2
a7466 1
    case BFD_RELOC_RVA:      
d7470 1
d7479 1
a7479 1
	 a section boundary - possibly due to an implicit dump */
d7488 2
a7489 2
       code = fixp->fx_r_type;
    break;
d7500 1
a7500 2
		    _("ADRL used for a symbol not defined in the same file"),
		    fixp->fx_r_type);
d7512 1
d7529 2
a7530 2
		      _("Can not represent %s relocation in this object file format (%d)"),
		      type, fixp->fx_pcrel);
d7536 7
a7542 7
 if (code == BFD_RELOC_32_PCREL
     && GOT_symbol
     && fixp->fx_addsy == GOT_symbol)
   {
     code = BFD_RELOC_ARM_GOTPC;
     reloc->addend = fixp->fx_offset = reloc->address;
   }
d7544 1
a7544 1
   
d7555 4
a7558 4
   /* HACK: Since arm ELF uses Rel instead of Rela, encode the
      vtable entry to be used in the relocation's section offset.  */
   if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
     reloc->address = fixp->fx_offset;
d7576 1
a7576 1
    
d7584 1
a7584 1
  
d7605 3
a7607 1
  return;
d7620 5
a7624 3
     This may not be the right thing to do but ... */
  /* arm_align (2, 0); */
  listing_prev_line (); /* Defined in listing.h */
d7638 1
a7638 1
  
d7644 1
a7644 1
    
d7659 1
a7659 1
      
d7664 4
a7667 4
	     {
	    	as_bad (_("selected processor does not support this opcode"));
		return;
	     }
d7671 1
a7671 1
	  (*opcode->parms)(p);
d7682 1
a7682 1
      /* p now points to the end of the opcode, probably white space, but we
d7687 1
d7692 1
d7695 1
a7695 1
	  
d7710 6
a7715 6
		       if (*opcode->comp_suffix != '\0')
		    	 as_bad (_("Opcode `%s' must have suffix from list: <%s>"),
			     str, opcode->comp_suffix);
		       else
			 /* Not a conditional instruction. */
		         (*opcode->parms)(q, 0);
d7719 1
a7719 1
		      /* A conditional instruction with default condition. */
d7721 1
a7721 1
		      (*opcode->parms)(q, 0);
d7727 2
a7728 1
	      /* Not just a simple opcode.  Check if extra is a conditional. */
d7753 1
a7753 1
	      /* Apply the conditional, or complain it's not allowed. */
d7756 6
a7761 6
		   /* Instruction isn't conditional */
		   if (cond_code != COND_ALWAYS)
		     {
		       as_bad (_("Opcode `%s' is unconditional\n"), str);
		       return;
		     }
d7764 2
a7765 3
		/* Instruction is conditional: set the condition into it. */
		inst.instruction |= cond_code;	     

d7767 2
a7768 2
	      /* If there is a compulsory suffix, it should come here, before
		 any optional flags.  */
d7783 2
a7784 2
		      as_bad (_("Opcode `%s' must have suffix from <%s>\n"), str,
			      opcode->comp_suffix);
d7833 1
a7833 1
     alias .req reg */
d7839 1
a7839 1
    
d7843 1
a7843 1
      char * copy_of_str = str;
d7845 6
a7850 1
      
d7857 1
a7857 1
      
d7868 1
a7868 1
	  
d7880 2
a7881 2
			 copy_of_str );
	      
d7890 1
a7890 1
      
d7899 30
a7928 30
/*
 * md_parse_option
 *    Invocation line includes a switch not recognized by the base assembler.
 *    See if it's a processor-specific option.  These are:
 *    Cpu variants, the arm part is optional:
 *            -m[arm]1                Currently not supported.
 *            -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
 *            -m[arm]3                Arm 3 processor
 *            -m[arm]6[xx],           Arm 6 processors
 *            -m[arm]7[xx][t][[d]m]   Arm 7 processors
 *            -m[arm]8[10]            Arm 8 processors
 *            -m[arm]9[20][tdmi]      Arm 9 processors
 *            -mstrongarm[110[0]]     StrongARM processors
 *            -m[arm]v[2345[t]]       Arm architectures
 *            -mall                   All (except the ARM1)
 *    FP variants:
 *            -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions
 *            -mfpe-old               (No float load/store multiples)
 *            -mno-fpu                Disable all floating point instructions
 *    Run-time endian selection:
 *            -EB                     big endian cpu
 *            -EL                     little endian cpu
 *    ARM Procedure Calling Standard:
 *	      -mapcs-32		      32 bit APCS
 *	      -mapcs-26		      26 bit APCS
 *	      -mapcs-float	      Pass floats in float regs
 *	      -mapcs-reentrant        Position independent code
 *            -mthumb-interwork       Code supports Arm/Thumb interworking
 *            -moabi                  Old ELF ABI
 */
d7931 1
d7946 1
d7987 17
a8003 17
        case 'o':
          if (streq (str, "oabi"))
            target_oabi = true;
          break;
#endif
	  
        case 't':
          /* Limit assembler to generating only Thumb instructions: */
          if (streq (str, "thumb"))
            {
              cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_THUMB;
              cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_NONE;
              thumb_mode = 1;
            }
          else if (streq (str, "thumb-interwork"))
            {
	      if ((cpu_variant & ARM_THUMB) == 0)
d8006 1
a8006 1
              support_interwork = true;
d8008 2
a8009 2
            }
          else
d8011 1
a8011 1
          break;
d8026 1
a8026 1
	      
d8066 1
a8066 1
		     position independent code with absolute position code. */
d8070 1
a8070 1
	      
d8073 7
a8079 1
  	    }
d8081 1
a8081 1
	  /* Strip off optional "arm" */
d8126 2
a8127 1
	      switch (strtol (str, & str, 10))	/* Eat the processor name */
d8140 26
a8165 17
              cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
              for (; *str; str++)
                {
                switch (* str)
                  {
                  case 't':
                    cpu_variant |= (ARM_THUMB | ARM_ARCH_V4);
                    break;

                  case 'm':
                    cpu_variant |= ARM_LONGMUL;
                    break;

		  case 'f': /* fe => fp enabled cpu.  */
		    if (str[1] == 'e')
		      ++ str;
		    else
d8167 2
a8168 11
		    
		  case 'c': /* Left over from 710c processor name.  */
                  case 'd': /* Debug */
                  case 'i': /* Embedded ICE */
                    /* Included for completeness in ARM processor naming. */
                    break;

                  default:
                    goto bad;
                  }
                }
d8174 1
a8174 1
		  | ARM_8 | ARM_ARCH_V4 | ARM_LONGMUL;
d8178 1
a8178 1
	      
d8182 1
a8182 1
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
d8185 1
a8185 1
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL;
d8188 1
a8188 1
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
d8191 1
a8191 1
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
a8195 1
	      
d8201 1
a8201 1
		  | ARM_8 | ARM_ARCH_V4 | ARM_LONGMUL;
d8205 8
a8212 1
		
d8214 2
a8215 1
	      /* Select variant based on architecture rather than processor.  */
d8232 1
a8232 1
		  
d8234 2
a8235 2
		    cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
                    
d8238 1
a8238 1
		    case 'm': cpu_variant |= ARM_LONGMUL; break;
d8245 1
a8245 1
		  
d8247 2
a8248 2
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V4;
		  
d8251 1
a8251 1
		    case 't': cpu_variant |= ARM_THUMB; break;
d8260 1
a8260 1
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V5;
d8263 1
a8263 1
		    case 't': cpu_variant |= ARM_THUMB; break;
d8271 1
a8271 1
		  
d8277 1
a8277 1
	      
d8291 1
a8291 1
      
d8296 1
a8296 1
   return 1;
d8317 1
d8320 1
a8320 1
  #endif
d8348 2
a8349 2
  fixS *         new_fix;
  arm_fix_data * arm_data;
d8366 2
a8367 1
  /* Mark whether the fix is to a THUMB instruction, or an ARM instruction */
d8375 1
a8376 1
/* This fix_new is called by cons via TC_CONS_FIX_NEW.  */
d8386 1
a8386 1
  
d8389 1
a8389 1
  switch (size) 
d8405 1
a8405 1
  
d8412 1
d8418 3
a8420 2
  
  subseg_set (text_section, 0); /* Put it at the end of text section.  */
d8436 1
a8436 1
  
d8438 1
a8438 1
  
d8442 33
a8474 2
  
  if (label_is_thumb_function_name)
d8482 1
a8482 1
      
d8499 1
a8499 1
        {
d8504 1
a8504 1
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL) /* This can happen! */
d8514 15
a8528 14
            {
              case C_EXT:
                S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
                break;
              case C_STAT:
                S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
                break;
              case C_LABEL:
                S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
                break;
              default: /* do nothing */ 
                break;
            }
        }
d8535 2
a8536 2
  symbolS *         sym;
  char              bind;
d8541 1
a8541 1
        {
d8543 1
a8543 1
	  
d8546 1
a8546 1
	  
d8555 2
a8556 2
         }
     }
d8570 1
a8570 1
  
d8595 1
a8595 1
  if (   fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
d8607 16
d8636 1
a8636 1
   
d8643 2
a8644 2
  
  /* Prevent all adjustments to global symbols. */
d8647 1
a8647 1
  
d8654 2
a8655 2
  
  /* We need the symbol name for the VTABLE entries */
d8667 6
a8672 4
    if (target_oabi)
      return "elf32-bigarm-oabi";
    else
      return "elf32-bigarm";
d8674 6
a8679 4
    if (target_oabi)
      return "elf32-littlearm-oabi";
    else
      return "elf32-littlearm";
d8685 1
a8685 1
     int * puntp;
d8688 1
a8688 1
} 
d8697 3
a8699 1
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)    
d8701 1
a8701 1
  
d8708 2
a8709 2
  char   id[16];
  char * ip;
d8719 1
a8719 1
#define MAP(str,reloc) { str, sizeof (str)-1, reloc }
d8722 2
a8723 3
    /* ScottB: Jan 30, 1998 */
    /* Added support for parsing "var(PLT)" branch instructions */
    /* generated by GCC for PLT relocs */
d8726 1
a8726 1
#undef MAP    
d8733 1
a8733 1
  
d8737 1
a8737 1
  
d8739 1
a8739 1
  
d8766 1
a8766 1
      
d8770 5
a8774 5
          && * input_line_pointer == '('
          && (reloc = arm_parse_reloc()) != BFD_RELOC_UNUSED)
        {
          reloc_howto_type * howto = bfd_reloc_type_lookup (stdoutput, reloc);
          int size = bfd_get_reloc_size (howto);
d8776 2
a8777 2
          if (size > nbytes)
            as_bad ("%s relocations do not fit in %d bytes",
d8779 9
a8787 9
          else
            {
              register char * p = frag_more ((int) nbytes);
              int offset = nbytes - size;

              fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   & exp, 0, reloc);
            }
        }
d8789 1
a8789 1
        emit_expr (& exp, (unsigned int) nbytes);
d8793 2
a8794 1
  input_line_pointer--;		/* Put terminator back into stream.  */
d8799 99
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1946 1
a1946 1
    skip = 7;
d2007 1
a2007 1
      inst.error = _("can only set flag field with immediate value");
d5453 1
a5453 1
	    else if (validate_immediate_twopart (- value, & highpart) != (unsigned int) FAIL)
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d1 2
a2 2
/* tc-arm.c  All the arm specific stuff in one convenient, huge,
   slow to compile, easy to find file.
a5 2
   Copyright (C) 1994, 1995 Free Software Foundation, Inc.

d19 3
a21 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d35 2
a36 6
/* ??? This is currently unused.  */
#ifdef __STDC__
#define internalError() \
  as_fatal ("ARM Internal Error, line %d, %s", __LINE__, __FILE__)
#else
#define internalError() as_fatal ("ARM Internal Error")
d46 3
d52 10
a61 2
#define ARM_ARCH4       0x00000020
#define ARM_THUMB       ARM_ARCH4
d65 1
a65 1
#define ARM_2UP		0x00fffffe
d79 1
d81 3
d86 1
d92 13
a104 1
unsigned long cpu_variant = CPU_DEFAULT | FPU_DEFAULT;
d107 1
a107 1
   pre-processor is disabled, these aren't very useful */
d112 1
a112 1
   .line and .file directives will appear in the pre-processed output */
d115 2
a116 2
   #NO_APP at the beginning of its output. */
/* Also note that comments like this one will always work. */
d119 3
d123 1
d125 2
a126 1
/* Chars that can be used to separate mant from exp in floating point nums */
d135 7
a141 1
CONST int md_reloc_size = 8;		/* Size of relocation record */
d143 1
a143 1
static int thumb_mode = 0;      /* non-zero if assembling thumb instructions */
d145 3
d155 1
a155 1
  CONST char *error;
d157 2
a158 2
  int suffix;
  int size;
d162 2
a163 2
      expressionS exp;
      int pc_rel;
d171 1
a171 1
  CONST char *template;
d196 1
a196 1
CONST char *fp_const[] = 
d201 1
a201 1
/* Number of littlenums required to hold an extended precision number */
d226 1
a226 1
  CONST char *template;
d230 1
a230 1
/* This is to save a hash look-up in the common case */
d255 1
a255 1
   the set_bits: */
d258 1
a258 1
  CONST char *template;		/* Basic flag string */
d384 3
a386 2
  CONST char *template;
  unsigned long number;
d389 7
a395 1
#define PSR_ALL		0x00010000
d399 30
a428 9
  /* Valid <psr>'s */
  {"cpsr",	0},
  {"cpsr_all",	0},
  {"spsr",	1},
  {"spsr_all",	1},

  /* Valid <psrf>'s */
  {"cpsr_flg",	2},
  {"spsr_flg",	3}
d431 1
a431 1
/* Functions called by parser */
d433 77
a509 41
static void do_arit		PARAMS ((char *operands, unsigned long flags));
static void do_cmp		PARAMS ((char *operands, unsigned long flags));
static void do_mov		PARAMS ((char *operands, unsigned long flags));
static void do_ldst		PARAMS ((char *operands, unsigned long flags));
static void do_ldmstm		PARAMS ((char *operands, unsigned long flags));
static void do_branch		PARAMS ((char *operands, unsigned long flags));
static void do_swi		PARAMS ((char *operands, unsigned long flags));
/* Pseudo Op codes */
static void do_adr		PARAMS ((char *operands, unsigned long flags));
static void do_nop		PARAMS ((char *operands, unsigned long flags));
/* ARM 2 */
static void do_mul		PARAMS ((char *operands, unsigned long flags));
static void do_mla		PARAMS ((char *operands, unsigned long flags));
/* ARM 3 */
static void do_swap		PARAMS ((char *operands, unsigned long flags));
/* ARM 6 */
static void do_msr		PARAMS ((char *operands, unsigned long flags));
static void do_mrs		PARAMS ((char *operands, unsigned long flags));
/* ARM 7M */
static void do_mull		PARAMS ((char *operands, unsigned long flags));
/* ARM THUMB */
static void do_bx               PARAMS ((char *operands, unsigned long flags));

/* Coprocessor Instructions */
static void do_cdp		PARAMS ((char *operands, unsigned long flags));
static void do_lstc		PARAMS ((char *operands, unsigned long flags));
static void do_co_reg		PARAMS ((char *operands, unsigned long flags));
static void do_fp_ctrl		PARAMS ((char *operands, unsigned long flags));
static void do_fp_ldst		PARAMS ((char *operands, unsigned long flags));
static void do_fp_ldmstm	PARAMS ((char *operands, unsigned long flags));
static void do_fp_dyadic	PARAMS ((char *operands, unsigned long flags));
static void do_fp_monadic	PARAMS ((char *operands, unsigned long flags));
static void do_fp_cmp		PARAMS ((char *operands, unsigned long flags));
static void do_fp_from_reg	PARAMS ((char *operands, unsigned long flags));
static void do_fp_to_reg	PARAMS ((char *operands, unsigned long flags));

static void fix_new_arm		PARAMS ((fragS *frag, int where, 
					 short int size, expressionS *exp,
					 int pc_rel, int reloc));
static int arm_reg_parse	PARAMS ((char **ccp));
static int arm_psr_parse	PARAMS ((char **ccp));
d512 1
a512 1
   take 2: */
d516 1
a516 3
 * flags.
 * ARM7M has 4 of length 5
 */
d520 1
d523 11
a533 6
  CONST char *template;		/* Basic string to match */
  unsigned long value;		/* Basic instruction code */
  CONST char *comp_suffix;	/* Compulsory suffix that must follow conds */
  CONST struct asm_flg *flags;	/* Bits to toggle if flag 'n' set */
  unsigned long variants;	/* Which CPU variants this exists for */
  void (*parms)();		/* Function to call to parse args */
d560 4
d566 2
a567 1

d570 1
d582 4
a585 1
  {"msr",   0x0128f000, NULL,   NULL,        ARM_6UP,      do_msr},
d644 1
a644 1
/* Generic copressor instructions */
d652 1
a652 2
/* defines for various bits that we will want to toggle */

d660 1
a660 1
#define MULTI_SET_PSR	0x00400000
d667 1
a667 2
/* Codes to distinguish the arithmetic instructions */

d685 24
a708 21
static void do_t_arit		PARAMS ((char *operands));
static void do_t_add		PARAMS ((char *operands));
static void do_t_asr		PARAMS ((char *operands));
static void do_t_branch		PARAMS ((char *operands));
static void do_t_bx		PARAMS ((char *operands));
static void do_t_compare	PARAMS ((char *operands));
static void do_t_ldmstm		PARAMS ((char *operands));
static void do_t_ldr		PARAMS ((char *operands));
static void do_t_ldrb		PARAMS ((char *operands));
static void do_t_ldrh		PARAMS ((char *operands));
static void do_t_lds		PARAMS ((char *operands));
static void do_t_lsl		PARAMS ((char *operands));
static void do_t_lsr		PARAMS ((char *operands));
static void do_t_mov		PARAMS ((char *operands));
static void do_t_push_pop	PARAMS ((char *operands));
static void do_t_str		PARAMS ((char *operands));
static void do_t_strb		PARAMS ((char *operands));
static void do_t_strh		PARAMS ((char *operands));
static void do_t_sub		PARAMS ((char *operands));
static void do_t_swi		PARAMS ((char *operands));
static void do_t_adr		PARAMS ((char *operands));
d762 1
a762 1
static int thumb_reg		PARAMS ((char **str, int hi_lo));
d764 1
a764 1
#define THUMB_SIZE	2	/* Size of thumb instruction */
d784 1
a784 1
/* These three are used for immediate shifts, do not alter */
d791 1
a791 1
  CONST char *template;		/* Basic string to match */
d793 3
a795 2
  int size;
  void (*parms)();		/* Function to call to parse args */
d800 55
a854 54
  {"adc",	0x4140,		2,	do_t_arit},
  {"add",	0x0000,		2,	do_t_add},
  {"and",	0x4000,		2,	do_t_arit},
  {"asr",	0x0000,		2,	do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	do_t_branch},
  {"beq",	0xd0fe,		2,	do_t_branch},
  {"bne",	0xd1fe,		2,	do_t_branch},
  {"bcs",	0xd2fe,		2,	do_t_branch},
  {"bhs",	0xd2fe,		2,	do_t_branch},
  {"bcc",	0xd3fe,		2,	do_t_branch},
  {"bul",	0xd3fe,		2,	do_t_branch},
  {"blo",	0xd3fe,		2,	do_t_branch},
  {"bmi",	0xd4fe,		2,	do_t_branch},
  {"bpl",	0xd5fe,		2,	do_t_branch},
  {"bvs",	0xd6fe,		2,	do_t_branch},
  {"bvc",	0xd7fe,		2,	do_t_branch},
  {"bhi",	0xd8fe,		2,	do_t_branch},
  {"bls",	0xd9fe,		2,	do_t_branch},
  {"bge",	0xdafe,		2,	do_t_branch},
  {"blt",	0xdbfe,		2,	do_t_branch},
  {"bgt",	0xdcfe,		2,	do_t_branch},
  {"ble",	0xddfe,		2,	do_t_branch},
  {"bic",	0x4380,		2,	do_t_arit},
  {"bl",	0xf7fffffe,	4,	do_t_branch},
  {"bx",	0x4700,		2,	do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	do_t_arit},
  {"cmp",	0x0000,		2,	do_t_compare},
  {"eor",	0x4040,		2,	do_t_arit},
  {"ldmia",	0xc800,		2,	do_t_ldmstm},
  {"ldr",	0x0000,		2,	do_t_ldr},
  {"ldrb",	0x0000,		2,	do_t_ldrb},
  {"ldrh",	0x0000,		2,	do_t_ldrh},
  {"ldrsb",	0x5600,		2,	do_t_lds},
  {"ldrsh",	0x5e00,		2,	do_t_lds},
  {"ldsb",	0x5600,		2,	do_t_lds},
  {"ldsh",	0x5e00,		2,	do_t_lds},
  {"lsl",	0x0000,		2,	do_t_lsl},
  {"lsr",	0x0000,		2,	do_t_lsr},
  {"mov",	0x0000,		2,	do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	do_t_arit},
  {"orr",	0x4300,		2,	do_t_arit},
  {"pop",	0xbc00,		2,	do_t_push_pop},
  {"push",	0xb400,		2,	do_t_push_pop},
  {"ror",	0x41c0,		2,	do_t_arit},
  {"sbc",	0x4180,		2,	do_t_arit},
  {"stmia",	0xc000,		2,	do_t_ldmstm},
  {"str",	0x0000,		2,	do_t_str},
  {"strb",	0x0000,		2,	do_t_strb},
  {"strh",	0x0000,		2,	do_t_strh},
  {"swi",	0xdf00,		2,	do_t_swi},
  {"sub",	0x0000,		2,	do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	do_t_arit},
d856 2
a857 2
  {"adr",       0x0000,         2,      do_t_adr},
  {"nop",       0x0000,         2,      do_nop},
d862 2
a863 2
  CONST char *name;
  int number;
d874 1
a874 1
/* These are the standard names;  Users can add aliases with .req */
d877 1
a877 1
  /* Processor Register Numbers */
d882 1
a882 1
  /* APCS conventions */
d887 3
a889 1
  /* FP Registers */
d900 7
d910 11
a920 9
static CONST char *bad_args = "Bad arguments to instruction";
static CONST char *bad_pc = "r15 not allowed here";

static struct hash_control *arm_ops_hsh = NULL;
static struct hash_control *arm_tops_hsh = NULL;
static struct hash_control *arm_cond_hsh = NULL;
static struct hash_control *arm_shift_hsh = NULL;
static struct hash_control *arm_reg_hsh = NULL;
static struct hash_control *arm_psr_hsh = NULL;
d924 3
a926 4
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */
d936 9
d950 29
a978 14
  {"req", s_req, 0},	/* Never called becasue '.req' does not start line */
  {"bss", s_bss, 0},
  {"align", s_align, 0},
  {"arm", s_arm, 0},
  {"thumb", s_thumb, 0},
  {"code", s_code, 0},
  {"even", s_even, 0},
  {"ltorg", s_ltorg, 0},
  {"pool", s_ltorg, 0},
  {"word", cons, 4},
  {"extend", float_cons, 'x'},
  {"ldouble", float_cons, 'x'},
  {"packed", float_cons, 'p'},
  {0, 0, 0}
d991 2
a992 1
symbolS *last_label_seen;
d1001 1
a1001 1
  struct arm_it      *inst;
d1004 4
a1007 5
literalT literals[MAX_LITERAL_POOL_SIZE];
int next_literal_pool_place = 0; /* Next free entry in the pool */
int lit_pool_num = 1; /* Next literal pool number */
symbolS *current_poolP = NULL;
symbolS *symbol_make_empty (); 
d1015 2
a1016 1
    current_poolP = symbol_make_empty();
d1018 1
a1018 1
  /* Check if this literal value is already in the pool: */
d1023 2
a1024 1
          && literals[lit_count].exp.X_add_number == inst.reloc.exp.X_add_number
d1034 1
a1034 1
          inst.error = "Literal Pool Overflow\n";
d1043 1
a1043 1
  inst.reloc.exp.X_add_number = (lit_count)*4-8;
d1049 2
a1050 2
/* Can't use symbol_new here, so have to create a symbol and them at
   a later date assign it a value. Thats what these functions do */
d1053 5
a1057 5
     symbolS *symbolP; 
     CONST char *name;		/* It is copied, the caller can modify */
     segT segment;		/* Segment identifier (SEG_<something>) */
     valueT valu;		/* Symbol value */
     fragS *frag;		/* Associated fragment */
d1060 1
a1060 1
  char *preserved_copy_of_name;
d1081 1
a1081 1
  symbolP->sy_frag = frag;
d1083 1
a1083 3
  /*
   * Link to end of symbol chain.
   */
d1090 1
a1090 1
  symbol_append (symbolP, symbol_lastP, &symbol_rootP, &symbol_lastP);
d1099 1
a1099 1
  verify_symbol_chain(symbol_rootP, symbol_lastP);
d1103 5
a1107 2
symbolS *
symbol_make_empty () 
d1109 10
a1118 14
  symbolS *symbolP; 

  symbolP = (symbolS *) obstack_alloc (&notes, sizeof (symbolS));

  /* symbol must be born in some fixed state.  This seems as good as any. */
  memset (symbolP, 0, sizeof (symbolS));

#ifdef BFD_ASSEMBLER
  symbolP->bsym = bfd_make_empty_symbol (stdoutput);
  assert (symbolP->bsym != 0);
  symbolP->bsym->udata.p = (PTR) symbolP;
#endif

  return symbolP;
a1119 3
 
/* Check that an immediate is valid, and if so, convert it to the right format
 */
d1121 7
a1127 5
/* OH, for a rotate instruction in C! */

static int
validate_immediate (val)
     int val;
d1129 2
a1130 2
  unsigned int a = (unsigned int) val;
  int i;
d1132 22
a1153 6
  /* Do the easy (and most common ones) quickly */
  for (i = 0; i <= 24; i += 2)
    {
      if ((a & (0xff << i)) == a)
	return (int) (((32 - i) & 0x1e) << 7) | ((a >> i) & 0xff);
    }
d1155 3
a1157 9
  /* Now do the harder ones */
  for (; i < 32; i += 2)
    {
      if ((a & ((0xff << i) | (0xff >> (32 - i)))) == a)
	{
	  a = ((a >> i) & 0xff) | ((a << (32 - i)) & 0xff);
	  return (int) a | (((32 - i) >> 1) << 8);
	}
    }
d1163 1
a1163 1
     int val;
d1166 1
a1166 2
  if ((hwse && (val < -255 || val > 255))
      || (val < -4095 || val > 4095))
d1174 1
a1174 1
     int a;
d1176 1
a1176 1
  as_bad ("Invalid syntax for .req directive.");
d1181 1
a1181 1
     int ignore;
d1191 1
a1191 1
     int ignore;
d1194 2
a1195 1
    frag_align (1, 0);
d1197 1
d1202 2
a1203 2
s_ltorg (internal)
     int internal;
d1209 1
a1209 6
    {
      /* Nothing to do */
      if (!internal)
	as_tsktsk ("Nothing to put in the pool\n");
      return;
    }
d1214 1
a1214 1
    frag_align (2, 0);
a1217 3
  if (internal)
    as_tsktsk ("Inserting implicit pool at change of section");

d1224 6
d1231 1
a1231 1
    /* First output the expression in the instruction to the pool */
a1237 14
#if 0 /* not used */
static void
arm_align (power, fill)
     int power;
     int fill;
{
  /* Only make a frag if we HAVE to ... */
  if (power && !need_pass_2)
    frag_align (power, fill);

  record_alignment (now_seg, power);
}
#endif

d1240 1
a1240 1
     int unused;
d1248 1
a1248 1
    as_bad ("Alignment too large: %d. assumed.", temp = max_alignment);
d1251 1
a1251 1
      as_bad ("Alignment negative. 0 assumed.");
d1268 1
a1268 1
    frag_align (temp, (int) temp_fill);
d1275 171
d1455 1
a1455 1
	    as_bad ("selected processor does not support THUMB opcodes");
d1467 1
a1467 1
	    as_bad ("selected processor does not support ARM opcodes");
d1470 1
a1470 1
            frag_align (2, 0);
d1476 1
a1476 1
      as_bad ("invalid instruction size selected (%d)", width);
d1482 1
a1482 1
     int ignore;
d1490 1
a1490 1
     int ignore;
d1498 1
a1498 1
     int unused;
d1507 1
a1507 1
      opcode_select(temp);
d1511 1
a1511 1
      as_bad ("invalid operand to .code directive (%d)", temp);
d1517 1
a1517 1
     char *str;
d1519 1
a1519 2
  while (*str == ' ')
    str++;
d1521 2
a1522 2
  if (*str != '\0')
    inst.error = "Garbage following instruction";
d1527 1
a1527 1
     char **str;
d1546 4
a1549 3
/* A standard register must be given at this point.  Shift is the place to
   put it in the instruction. */

d1552 2
a1553 2
     char **str;
     int shift;
d1555 3
a1557 2
  int reg;
  char *start = *str;
d1561 2
a1562 1
      inst.instruction |= reg << shift;
d1566 3
d1570 3
a1572 2
     this error can be overridden */
  inst.error = "Register expected";
a1573 2
  /* Restore the start point, we may have got a reg of the wrong class.  */
  *str = start;
d1577 15
a1591 13
static int
psr_required_here (str, shift)
     char **str;
     int shift;
{
  int psr;
  char *start = *str;

  if  ((psr = arm_psr_parse (str)) != FAIL && psr < 2)
    {
      if (psr == 1)
	inst.instruction |= 1 << shift; /* Should be bit 22 */
      return psr;
d1593 4
d1598 9
a1606 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden */
  inst.error = "<psr> expected";
d1608 1
a1608 3
  /* Restore the start point.  */
  *str = start;
  return FAIL;
d1611 1
d1613 18
a1630 12
psrf_required_here (str, shift)
     char **str;
     int shift;
{
  int psrf;
  char *start = *str;

  if  ((psrf = arm_psr_parse (str)) != FAIL && psrf > 1)
    {
      if (psrf == 1 || psrf == 3)
	inst.instruction |= 1 << shift; /* Should be bit 22 */
      return psrf;
d1633 3
a1635 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden */
  inst.error = "<psrf> expected";
d1644 1
a1644 1
     char **str;
d1648 1
a1648 2
  while (**str == ' ')
    (*str)++;
d1665 1
a1665 1
	      inst.error = "Illegal co-processor number";
d1672 1
a1672 1
      inst.error = "Bad or missing co-processor number";
d1682 1
a1682 1
     char **str;
d1688 1
a1688 2
  while (**str == ' ')
    (*str)++;
d1696 1
a1696 1
      inst.error = "bad or missing expression";
d1702 1
a1702 1
      inst.error = "immediate co-processor expression too large";
d1712 2
a1713 2
     char **str;
     int where;
d1715 2
a1716 2
  int reg;
  char *start = *str;
d1726 2
a1727 2
     this error can be overridden */
  inst.error = "Co-processor register expected";
d1729 1
a1729 1
  /* Restore the start point */
d1736 2
a1737 2
     char **str;
     int where;
d1740 1
a1740 1
  char *start = *str;
d1750 2
a1751 2
     this error can be overridden */
  inst.error = "Floating point register expected";
d1753 1
a1753 1
  /* Restore the start point */
d1760 1
a1760 1
     char **str;
d1764 1
a1764 2
  while (**str == ' ')
    (*str)++;
d1766 1
a1766 1
  if (**str != '#')
d1768 1
a1768 1
      inst.error = "immediate expression expected";
d1773 2
a1774 1
  if (my_get_expression (&inst.reloc.exp, str))
d1776 1
d1780 1
d1783 1
a1783 1
	  inst.error = "co-processor address must be word aligned";
d1789 1
a1789 1
	  inst.error = "offset too large";
d1808 1
a1808 1
     char **str;
d1810 3
a1812 3
  char *p = *str;
  int pre_inc = 0;
  int write_back = 0;
d1819 1
a1819 2
      while (*p == ' ')
	p++;
d1821 2
a1822 5
      if ((reg = reg_required_here (&p, 16)) == FAIL)
	{
	  inst.error = "Register required";
	  return FAIL;
	}
d1824 1
a1824 2
      while (*p == ' ')
	p++;
d1829 2
a1830 1
	  if (skip_past_comma (&p) == SUCCESS)
d1834 1
d1837 1
a1837 1
		  inst.error = "pc may not be used in post-increment";
d1841 1
a1841 1
	      if (cp_address_offset (&p) == FAIL)
d1851 1
a1851 1
	  if (skip_past_comma (&p) == FAIL)
d1853 1
a1853 1
	      inst.error = "pre-indexed expression expected";
d1858 2
a1859 1
	  if (cp_address_offset (&p) == FAIL)
d1862 1
a1862 2
	  while (*p == ' ')
	    p++;
d1866 1
a1866 1
	      inst.error = "missing ]";
d1870 1
a1870 2
	  while (*p == ' ')
	    p++;
d1876 1
a1876 1
		  inst.error = "pc may not be used with write-back";
d1904 1
a1904 1
     char *str;
d1907 2
a1908 2
  /* Do nothing really */
  inst.instruction |= flags; /* This is pointless */
d1918 4
a1921 3
  /* Only one syntax */
  while (*str == ' ')
    str++;
d1925 7
a1931 1
      inst.error = bad_args;
d1935 13
a1947 2
  if (skip_past_comma (&str) == FAIL
      || psr_required_here (&str, 22) == FAIL)
d1949 1
a1949 1
      inst.error = "<psr> expected";
d1953 4
a1958 1
  return;
d1961 3
d1966 1
a1966 1
     char *str;
d1969 10
a1978 2
  int psr, psrf, reg;
  /* Three possible forms: "<psr>, Rm", "<psrf>, Rm", "<psrf>, #expression" */
d1980 15
a1994 2
  while (*str == ' ')
    str++;
d1996 18
a2013 1
  if ((psr = psr_required_here (&str, 22)) != FAIL)
d2015 2
a2016 8
      inst.instruction |= PSR_ALL;
      /* Sytax should be "<psr>, Rm" */
      if (skip_past_comma (&str) == FAIL
	  || (reg = reg_required_here (&str, 0)) == FAIL)
	{
	  inst.error = bad_args;
	  return;
	}
d2018 1
a2018 2
  else if ((psrf = psrf_required_here (&str, 22)) != FAIL)
    /* Syntax could be "<psrf>, rm", "<psrf>, #expression" */
d2020 3
a2022 1
      if (skip_past_comma (&str) == FAIL)
d2024 1
a2024 1
	  inst.error = bad_args;
d2027 6
a2032 45
      if ((reg = reg_required_here (&str, 0)) != FAIL)
	;
      /* Immediate expression */
      else if (*(str++) == '#')
	{
	  inst.error = NULL;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    {
	      inst.error = "Register or shift expression expected";
	      return;
	    }

	  if (inst.reloc.exp.X_add_symbol)
	    {
	      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
	      inst.reloc.pc_rel = 0;
	    }
	  else
	    {
	      int value = validate_immediate (inst.reloc.exp.X_add_number);
	      if (value == FAIL)
		{
		  inst.error = "Invalid constant";
		  return;
		}

	      inst.instruction |= value;
	    }

	  flags |= INST_IMMEDIATE;
	}
      else
	{
	  inst.error = "Error: the other";
	  return;
	}
    }
  else
    {
      inst.error = bad_args;
      return;
    }
     
  inst.error = NULL; 
  inst.instruction |= flags;
a2033 1
  return;
d2044 1
a2044 1
     char *str;
d2049 2
a2050 3
  /* only one format "rdlo, rdhi, rm, rs" */
  while (*str == ' ')
    str++;
d2054 1
a2054 1
      inst.error = bad_args;
d2061 1
a2061 1
      inst.error = bad_args;
d2068 1
a2068 1
      inst.error = bad_args;
d2074 1
a2074 1
    as_tsktsk ("rdhi, rdlo and rm must all be different");
d2079 1
a2079 1
      inst.error = bad_args;
d2085 1
a2085 1
      inst.error = bad_pc;
d2096 1
a2096 1
     char *str;
d2101 2
a2102 3
  /* only one format "rd, rm, rs" */
  while (*str == ' ')
    str++;
d2106 1
a2106 1
      inst.error = bad_args;
d2112 1
a2112 1
      inst.error = bad_pc;
d2119 1
a2119 1
      inst.error = bad_args;
d2125 1
a2125 1
      inst.error = bad_pc;
d2130 1
a2130 1
    as_tsktsk ("rd and rm should be different in mul");
d2135 1
a2135 1
      inst.error = bad_args;
d2141 1
a2141 1
      inst.error = bad_pc;
d2152 1
a2152 1
     char *str;
d2157 2
a2158 3
  /* only one format "rd, rm, rs, rn" */
  while (*str == ' ')
    str++;
d2162 1
a2162 1
      inst.error = bad_args;
d2168 1
a2168 1
      inst.error = bad_pc;
d2175 1
a2175 1
      inst.error = bad_args;
d2181 1
a2181 1
      inst.error = bad_pc;
d2186 1
a2186 1
    as_tsktsk ("rd and rm should be different in mla");
d2193 1
a2193 1
      inst.error = bad_args;
d2199 1
a2199 1
      inst.error = bad_pc;
d2212 1
a2212 1
     char **str;
d2215 4
a2218 3
  char *save_in;
  expressionS exp;
  int i, j;
d2279 1
a2279 1
     symbolS *sp;
d2281 1
a2281 1
  if (sp->sy_value.X_op == O_big)
d2284 1
a2284 1
  if (sp->sy_value.X_add_symbol)
d2286 3
a2288 3
      return (walk_no_bignums (sp->sy_value.X_add_symbol)
	      || (sp->sy_value.X_op_symbol
		  && walk_no_bignums (sp->sy_value.X_op_symbol)));
d2296 2
a2297 2
     expressionS *ep;
     char **str;
d2299 2
a2300 2
  char *save_in;
  segT seg;
d2313 1
a2313 1
      inst.error = "bad_segment";
d2329 1
a2329 1
      inst.error = "Invalid constant";
d2345 2
a2346 2
     char **str;
     int unrestrict;
d2348 3
a2350 3
  struct asm_shift *shft;
  char *p;
  char c;
d2352 1
a2352 2
  while (**str == ' ')
    (*str)++;
d2359 1
a2359 1
      inst.error = "Shift expression expected";
d2369 2
a2370 2
      if (!strcmp (*str, "rrx")
          || !strcmp (*str, "RRX"))
d2377 2
a2378 3
      while (*p == ' ')
	p++;

d2385 1
a2385 1
      else if (*p == '#')
d2400 1
a2400 1
		  inst.error = "Invalid immediate shift";
d2429 2
a2430 2
	  inst.error = unrestrict ? "shift requires register or #expression"
	    : "shift requires #expression";
d2436 1
a2436 1
  inst.error = "Shift expression expected";
d2452 2
a2453 2
     unsigned long *instruction;
     unsigned long value;
d2521 1
a2521 1
  if (value == FAIL)
d2531 1
a2531 1
     char **str;
d2536 1
a2536 2
  while (**str == ' ')
    (*str)++;
d2541 3
a2543 4
	{
	  /* Shift operation on register */
	  return decode_shift (str, NO_SHIFT_RESTRICT);
	}
d2549 1
a2549 1
      if (*((*str)++) == '#')
d2551 1
d2553 1
d2572 1
a2572 1
		      inst.error = "Constant expression expected";
d2581 1
a2581 1
		      inst.error = "Invalid constant";
d2601 1
a2601 1
		      inst.error = "Invalid constant";
d2613 2
a2614 1
      inst.error = "Register or shift expression expected";
d2620 2
a2621 3
fp_op2 (str, flags)
     char **str;
     unsigned long flags;
d2623 1
a2623 2
  while (**str == ' ')
    (*str)++;
d2635 2
a2636 2
	  while (**str == ' ')
	    (*str)++;
d2667 1
a2667 1
	  inst.error = "Invalid floating point immediate expression";
d2670 1
a2670 1
      inst.error = "Floating point register or immediate expression expected";
d2677 1
a2677 1
     char *str;
d2680 1
a2680 2
  while (*str == ' ')
    str++;
d2689 1
a2689 1
	inst.error = bad_args;
d2700 1
a2700 1
     char *str;
d2704 2
a2705 4
     into a relative address of the form "add rd, pc, #label-.-8" */

  while (*str == ' ')
    str++;
d2712 1
a2712 1
	inst.error = bad_args;
d2715 1
d2719 1
a2719 1
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust */
d2727 34
d2762 1
a2762 1
     char *str;
d2765 1
a2765 2
  while (*str == ' ')
    str++;
d2770 1
a2770 1
	inst.error = bad_args;
d2778 1
a2778 1
	inst.error = bad_args;
d2792 1
a2792 1
     char *str;
d2795 1
a2795 2
  while (*str == ' ')
    str++;
d2800 1
a2800 1
	inst.error = bad_args;
d2808 1
a2808 1
	inst.error = bad_args;
d2819 2
a2820 2
     char **str;
     int hwse;
d2827 1
d2829 1
a2829 1
      if (my_get_expression (&inst.reloc.exp, str))
d2839 1
a2839 1
	      inst.error = "address offset too large";
d2852 1
a2852 1
            inst.instruction |= add | HWOFFSET_IMM | (value >> 4) << 8 | value & 0xF;
d2875 1
a2875 4
	{
	  inst.error = "Register expected";
	  return FAIL;
	}
d2892 1
a2892 1
     char *str;
d2903 2
a2904 1
  if (halfword = ((flags & 0x80000000) != 0))
d2908 1
a2908 1
      if ((cpu_variant & ARM_ARCH4) == 0)
d2911 1
a2911 1
           = "Processor does not support halfwords or signed bytes\n";
d2921 1
a2921 2
  while (*str == ' ')
    str++;
d2923 1
a2923 1
  if ((conflict_reg = reg_required_here (&str, 12)) == FAIL)
d2926 1
a2926 1
	inst.error = bad_args;
d2930 1
a2930 1
  if (skip_past_comma (&str) == FAIL)
d2932 1
a2932 1
      inst.error = "Address expected";
d2941 2
a2942 2
      while (*str == ' ')
	str++;
d2945 1
a2945 4
	{
	  inst.error = "Register required";
	  return;
	}
d2947 2
a2948 3
      conflict_reg = (((conflict_reg == reg)
		       && (inst.instruction & LOAD_BIT))
		      ? 1 : 0);
d2950 1
a2950 2
      while (*str == ' ')
	str++;
d2954 2
a2955 1
	  str++;
d2962 2
a2963 1
		as_warn ("destination register same as write-back base\n");
d2971 1
a2971 2
              while (*str == ' ')
               str++;
d2976 2
a2977 1
                  as_warn ("destination register same as write-back base\n");
d2992 1
a2992 1
	      inst.error = "pre-indexed expression expected";
d3000 1
a3000 2
	  while (*str == ' ')
	    str++;
d3004 1
a3004 1
	      inst.error = "missing ]";
d3008 1
a3008 2
	  while (*str == ' ')
	    str++;
d3013 2
a3014 1
		as_tsktsk ("destination register same as write-back base\n");
d3025 1
a3025 2
      while (*str == ' ')
	str++;
d3033 1
a3033 1
	  inst.error = "Constant expression expected";
d3053 1
a3053 1
		inst.error = "literal pool insertion failed\n"; 
d3082 1
d3084 1
d3091 1
a3091 1
    inst.error = "Pre-increment instruction with translate";
d3100 1
a3100 1
     char **strp;
d3102 3
a3104 3
  char *str = *strp;
  long range = 0;
  int another_range;
d3121 1
a3121 8
	      while (*str == ' ')
		str++;

	      if ((reg = arm_reg_parse (&str)) == FAIL || !int_register (reg))
		{
		  inst.error = "Register expected";
		  return FAIL;
		}
d3123 3
d3132 1
a3132 1
		      inst.error = "Bad range in register list";
d3140 1
a3140 1
			  ("Warning: Duplicated register (r%d) in register list",
d3149 1
a3149 1
		as_tsktsk ("Warning: Duplicated register (r%d) in register list",
d3152 1
a3152 1
		as_tsktsk ("Warning: Register range not in ascending order");
d3159 1
a3159 2
	  while (*str == ' ')
	    str++;
d3163 1
a3163 1
	      inst.error = "Missing `}'";
d3179 1
a3179 1
		  inst.error = "invalid register mask";
d3190 1
a3190 1
		    ("Warning: Duplicated register (r%d) in register list",
d3200 1
a3200 1
		  inst.error = "expression too complex";
d3210 1
a3210 2
      while (*str == ' ')
	str++;
d3225 1
a3225 1
     char *str;
d3231 1
a3231 2
  while (*str == ' ')
    str++;
d3234 1
a3234 5
    {
      if (!inst.error)
	inst.error = bad_args;
      return;
    }
d3238 1
a3238 1
      inst.error = "r15 not allowed as base register";
d3242 2
a3243 2
  while (*str == ' ')
    str++;
d3254 1
a3254 1
	inst.error = bad_args;
d3261 1
a3261 1
      flags |= MULTI_SET_PSR;
d3271 1
a3271 1
     char *str;
d3274 2
d3277 1
a3277 3
  while (*str == ' ')
    str++;
  if (*str == '#')
d3280 1
a3280 1
  if (my_get_expression (&inst.reloc.exp, &str))
d3286 1
d3288 1
d3294 1
a3294 1
     char *str;
d3299 1
a3299 2
  while (*str == ' ')
    str++;
d3306 1
a3306 1
      inst.error = "r15 not allowed in swap";
d3314 1
a3314 1
	inst.error = bad_args;
d3320 1
a3320 1
      inst.error = "r15 not allowed in swap";
d3327 1
a3327 1
      inst.error = bad_args;
d3331 1
a3331 2
  while (*str == ' ')
    str++;
d3338 1
a3338 1
      inst.error = bad_pc;
d3342 1
a3342 2
  while (*str == ' ')
    str++;
d3346 1
a3346 1
      inst.error = "missing ]";
d3357 2
a3358 2
     char *str;
     unsigned long flags;
d3362 32
a3393 1
  inst.reloc.type = BFD_RELOC_ARM_PCREL_BRANCH;
d3395 2
d3403 2
a3404 2
     char *str;
     unsigned long flags;
d3408 1
a3408 2
  while (*str == ' ')
    str++;
d3411 4
a3414 1
    return;
d3417 1
a3417 1
    as_tsktsk ("Use of r15 in bx has undefined behaviour");
a3419 1
  return;
d3424 2
a3425 2
     char *str;
     unsigned long flags;
d3429 1
a3429 2
  while (*str == ' ')
    str++;
d3434 1
a3434 1
	inst.error = bad_args;
d3442 1
a3442 1
	inst.error = bad_args;
d3450 1
a3450 1
	inst.error = bad_args;
d3458 1
a3458 1
	inst.error = bad_args;
d3466 1
a3466 1
	inst.error = bad_args;
d3475 1
a3475 1
	    inst.error = bad_args;
d3486 1
a3486 1
     char *str;
d3492 1
a3492 2
  while (*str == ' ')
    str++;
d3497 1
a3497 1
	inst.error = bad_args;
d3505 1
a3505 1
	inst.error = bad_args;
d3513 1
a3513 1
	inst.error = bad_args;
d3524 1
a3524 1
     char *str;
d3530 1
a3530 2
  while (*str == ' ')
    str++;
d3535 1
a3535 1
	inst.error = bad_args;
d3543 1
a3543 1
	inst.error = bad_args;
d3551 1
a3551 1
	inst.error = bad_args;
d3559 1
a3559 1
	inst.error = bad_args;
d3567 1
a3567 1
	inst.error = bad_args;
d3576 1
a3576 1
	    inst.error = bad_args;
d3580 4
d3591 2
a3592 2
     char *str;
     unsigned long flags;
d3597 1
a3597 2
  while (*str == ' ')
    str++;
d3602 1
a3602 1
	inst.error = bad_args;
d3612 2
a3613 2
     char *str;
     unsigned long flags;
d3615 1
a3615 2
  while (*str == ' ')
    str++;
d3637 1
a3637 1
	inst.error = bad_args;
d3645 1
a3645 1
	inst.error = bad_args;
d3654 1
a3654 1
     char *str;
d3659 1
a3659 2
  while (*str == ' ')
    str++;
d3664 1
a3664 1
	inst.error = bad_args;
d3673 1
a3673 1
	inst.error = "constant expression expected";
d3679 1
a3679 1
      inst.error = "Constant value required for number of registers";
d3687 1
a3687 1
      inst.error = "number of registers must be in the range [1:4]";
d3722 1
a3722 1
	    inst.error = bad_args;
d3727 1
a3727 2
      while (*str == ' ')
	str++;
d3730 1
a3730 4
	{
	  inst.error = "Register required";
	  return;
	}
d3732 1
a3732 2
      while (*str == ' ')
	str++;
d3736 1
a3736 1
	  inst.error = bad_args;
d3747 1
a3747 1
	      inst.error = "R15 not allowed as base register with write-back";
d3784 1
a3784 1
	inst.error = bad_args;
d3793 1
a3793 1
     char *str;
d3796 1
a3796 2
  while (*str == ' ')
    str++;
d3815 1
a3815 1
	inst.error = bad_args;
d3823 1
a3823 1
	inst.error = bad_args;
d3831 1
a3831 1
	inst.error = bad_args;
d3842 1
a3842 1
     char *str;
d3845 1
a3845 2
  while (*str == ' ')
    str++;
d3864 1
a3864 1
	inst.error = bad_args;
d3872 1
a3872 1
	inst.error = bad_args;
d3883 1
a3883 1
     char *str;
d3886 1
a3886 2
  while (*str == ' ')
    str++;
d3891 1
a3891 1
	inst.error = bad_args;
d3899 1
a3899 1
	inst.error = bad_args;
d3910 1
a3910 1
     char *str;
d3913 1
a3913 2
  while (*str == ' ')
    str++;
d3932 1
a3932 1
	inst.error = bad_args;
d3940 1
a3940 1
	inst.error = bad_args;
d3951 1
a3951 1
     char *str;
d3954 1
a3954 2
  while (*str == ' ')
    str++;
d3957 1
a3957 5
    {
      if (! inst.error)
	inst.error = bad_args;
      return;
    }
d3963 1
a3963 1
	inst.error = bad_args;
d3981 2
a3982 2
     char **strp;
     int hi_lo;
d3986 2
a3987 5
  if ((reg = arm_reg_parse (strp)) == FAIL || ! int_register (reg))
    {
      inst.error = "Register expected";
      return FAIL;
    }
d3994 1
a3994 1
	  inst.error = "lo register required";
d4002 1
a4002 1
	  inst.error = "hi register required";
d4018 2
a4019 2
     char *str;
     int subtract;
d4023 1
a4023 2
  while (*str == ' ')
    str++;
d4029 1
a4029 1
	inst.error = bad_args;
d4033 1
a4033 1
  if (*str == '#')
d4052 1
a4052 1
      else if (*str == '#')
d4067 1
a4067 1
      if (Rd > 7 || Rs > 7 || Rd > 7)
d4071 1
a4071 1
	      inst.error = "dest and source1 must be the same register";
d4078 1
a4078 1
	      inst.error = "subtract valid only on lo regs";
d4102 1
a4102 1
	  inst.error = "invalid Hi register with immediate";
d4129 1
a4129 1
		  inst.error = "immediate value out of range";
d4140 1
a4140 1
		  inst.error = "invalid immediate value for stack adjust";
d4151 1
a4151 1
		  inst.error = "invalid immediate for address calculation";
d4162 1
a4162 1
		  inst.error = "immediate value out of range";
d4172 1
a4172 1
		  inst.error = "immediate value out of range";
d4180 1
d4186 2
a4187 2
     char *str;
     int shift;
d4191 1
a4191 2
  while (*str == ' ')
    str++;
d4197 1
a4197 1
	inst.error = bad_args;
d4201 1
a4201 1
  if (*str == '#')
d4205 1
a4205 1
      str++;
d4221 1
a4221 1
      else if (*str == '#')
d4238 1
a4238 1
	  inst.error = "source1 and dest must be same register";
d4273 1
a4273 1
	      inst.error = "Invalid immediate for shift";
d4290 1
d4296 2
a4297 2
     char *str;
     int move;
d4301 1
a4301 2
  while (*str == ' ')
    str++;
d4307 1
a4307 1
	inst.error = bad_args;
d4311 1
a4311 1
  if (*str == '#')
d4325 2
a4326 2
	    /* A move of two lowregs is, by convention, encoded as
	       ADD Rd, Rs, #0 */
d4352 1
a4352 1
	  inst.error = "only lo regs allowed with immediate";
d4371 1
a4371 1
	      inst.error = "invalid immediate";
d4384 3
a4386 3
     char *str;
     int load_store;
     int size;
d4390 1
a4390 2
  while (*str == ' ')
    str++;
d4396 1
a4396 1
	inst.error = bad_args;
d4408 1
a4408 1
	  if (*str == '#')
d4425 1
a4425 1
	  inst.error = "expected ']'";
d4432 41
a4472 1
      abort ();
d4491 1
a4491 1
	  inst.error = "byte or halfword not valid for base register";
d4496 1
a4496 1
	  inst.error = "R15 based store not allowed";
d4501 1
a4501 1
	  inst.error = "Invalid base register for register offset";
d4519 1
a4519 1
	      inst.error = "invalid offset";
d4530 1
a4530 1
      inst.error = "invalid base register in load/store";
d4554 1
a4554 1
	      inst.error = "Invalid offset";
d4557 1
a4557 1
	  inst.instruction |= offset << 6;
d4581 9
d4595 1
a4595 1
     char *str;
d4599 1
a4599 2
  while (*str == ' ')
    str++;
d4601 2
a4602 4
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
d4605 2
a4606 3
      if (! inst.error)
	inst.error = bad_args;
      return;
d4619 1
a4619 1
	  inst.error = bad_args;
d4628 1
a4628 1
	  inst.error = "dest and source1 one must be the same register";
d4636 1
a4636 1
    as_tsktsk ("Rs and Rd must be different in MUL");
d4644 1
a4644 1
     char *str;
d4651 1
a4651 1
     char *str;
d4657 2
a4658 2
do_t_branch (str)
     char *str;
d4662 1
a4662 1
  inst.reloc.type = BFD_RELOC_ARM_PCREL_BRANCH;
d4668 2
a4669 2
do_t_bx (str)
     char *str;
d4671 6
a4676 1
  int reg;
d4678 68
a4745 2
  while (*str == ' ')
    str++;
d4762 1
a4762 1
     char *str;
d4769 1
a4769 1
     char *str;
d4774 1
a4774 2
  while (*str == ' ')
    str++;
d4780 1
a4780 1
    as_warn ("Inserted missing '!': load/store multiple always writes back base register");
d4788 1
a4788 1
	inst.error = bad_args;
d4796 1
a4796 1
      inst.error = "Expression too complex";
d4802 1
a4802 1
      inst.error = "only lo-regs valid in load/store multiple";
d4812 1
a4812 1
     char *str;
d4819 1
a4819 1
     char *str;
d4826 1
a4826 1
     char *str;
d4833 1
a4833 1
     char *str;
d4837 1
a4837 2
  while (*str == ' ')
    str++;
d4848 1
a4848 1
	inst.error = "Syntax: ldrs[b] Rd, [Rb, Ro]";
d4858 1
a4858 1
     char *str;
d4865 1
a4865 1
     char *str;
d4872 1
a4872 1
     char *str;
d4879 1
a4879 1
     char *str;
d4883 1
a4883 2
  while (*str == ' ')
    str++;
d4888 1
a4888 1
	inst.error = bad_args;
d4896 1
a4896 1
      inst.error = "Expression too complex";
d4912 1
a4912 1
	  inst.error = "invalid register list to push/pop instruction";
d4923 1
a4923 1
     char *str;
d4930 1
a4930 1
     char *str;
d4937 1
a4937 1
     char *str;
d4944 1
a4944 1
     char *str;
d4951 1
a4951 1
     char *str;
d4953 1
a4953 2
  while (*str == ' ')
    str++;
d4965 1
a4965 1
     char *str;
d4967 2
d4970 2
a4971 3
     into a relative address of the form "add rd, pc, #label-.-8" */
  while (*str == ' ')
    str++;
d4973 3
a4975 1
  if (reg_required_here (&str, 8) == FAIL
d4980 1
a4980 1
	inst.error = bad_args;
d4985 1
a4985 1
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust */
d4987 2
a4988 1
  inst.instruction |= REG_PC; /* Rd is already placed into the instruction */
d4996 4
a4999 4
  int len = strlen (reg_table[entry].name) + 2;
  char *buf = (char *) xmalloc (len);
  char *buf2 = (char *) xmalloc (len);
  int i = 0;
d5045 4
a5048 3
  int i;

  if ((arm_ops_hsh = hash_new ()) == NULL
d5054 1
a5054 1
    as_fatal ("Virtual memory exhausted");
d5071 53
d5131 1
a5131 2
   LITTLENUMS (shorts, here at least)
   */
d5134 1
a5134 1
     char *buf;
d5136 1
a5136 1
     int n;
d5146 1
a5146 1
     char *buf;
d5150 1
a5150 1
  unsigned char *where = (unsigned char *) buf;
d5188 3
a5190 3
     char type;
     char *litP;
     int *sizeP;
d5225 1
a5225 1
      return "Bad call to MD_ATOF()";
d5256 1
a5256 2
/* We have already put the pipeline compensation in the instruction */

d5259 1
a5259 1
     fixS *fixP;
d5261 2
a5262 1
  if (fixP->fx_addsy && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section
d5264 9
a5272 1
    return 0;	/* HACK */
d5274 5
d5280 1
d5286 1
a5286 1
     segT segment;
d5289 3
d5294 1
d5297 2
a5298 1
/* We have no need to default values of symbols.  */
d5303 1
a5303 1
     char *name;
d5305 17
d5330 1
a5330 1
     register char **ccp;
d5332 4
a5335 4
  char *start = *ccp;
  char c;
  char *p;
  struct reg_entry *reg;
a5367 26
static int
arm_psr_parse (ccp)
     register char **ccp;
{
  char *start = *ccp;
  char c, *p;
  CONST struct asm_psr *psr;

  p = start;
  c = *p++;
  while (isalpha (c) || c == '_')
    c = *p++;

  *--p = 0;  
  psr = (CONST struct asm_psr *) hash_find (arm_psr_hsh, start);
  *p = c;

  if (psr)
    {
      *ccp = p;
      return psr->number;
    }

  return FAIL;
}

d5370 11
a5380 9
     fixS *fixP;
     valueT *val;
     segT seg;
{
  offsetT value = *val;
  offsetT newval, temp;
  int sign;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  arm_fix_data *arm_data = (arm_fix_data *) fixP->tc_fix_data;
d5385 4
d5390 1
d5398 2
a5399 1
      if (S_IS_DEFINED (fixP->fx_addsy)
d5401 8
a5408 1
	value += md_pcrel_from (fixP);
d5411 1
a5411 1
  fixP->fx_addnumber = value;	/* Remember value for emit_reloc */
d5416 1
a5416 1
      newval = validate_immediate (value);
d5421 2
a5422 2
      if (newval == FAIL
	  && (newval = negate_data_op (&temp, value)) == FAIL)
d5425 2
a5426 1
			"invalid constant after fixup\n");
d5430 46
a5475 2
      newval |= (temp & 0xfffff000);
      md_number_to_chars (buf, newval, INSN_SIZE);
d5478 1
a5478 1
     case BFD_RELOC_ARM_OFFSET_IMM:
d5480 5
a5484 1
      if ((value = validate_offset_imm (value, 0)) == FAIL)
d5486 2
a5487 1
          as_bad ("bad immediate value for offset (%d)", val);
a5489 2
      if (value < 0)
	value = -value;
d5500 5
a5504 1
      if ((value = validate_offset_imm (value, 1)) == FAIL)
d5508 1
a5508 1
			"invalid literal constant: pool needs to be closer\n");
d5510 2
a5511 1
            as_bad ("bad immediate value for offset (%d)", value);
a5514 3
      if (value < 0)
	value = -value;

d5517 1
a5517 1
      newval |= ((value >> 4) << 8) | value & 0xf | (sign ? INDEX_UP : 0);
d5523 1
d5525 1
a5525 1
	value = -value;
d5527 1
a5527 1
      if ((value = validate_offset_imm (value, 0)) == FAIL)
d5530 1
a5530 1
			"invalid literal constant: pool needs to be closer\n");
d5547 1
a5547 1
			"shift expression is too large");
d5565 1
a5565 1
			  "Invalid swi expression");
d5574 1
a5574 1
			  "Invalid swi expression");
d5584 1
a5584 1
		      "Invalid expression in load/store multiple");
d5590 9
a5598 16
      if (arm_data->thumb_mode)
	{
	  unsigned long newval2;
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  if (fixP->fx_size == 4)
	    {
	      unsigned long diff;

	      newval2 = md_chars_to_number (buf, THUMB_SIZE);
	      diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
	      if (diff & 0x400000)
		diff |= ~0x3fffff;
	      value += diff;
	      if ((value & 0x400000) && ((value & ~0x3fffff) != ~0x3fffff))
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      "Branch with link out of range");
d5600 31
a5630 32
	      newval = (newval & 0xf800) | ((value & 0x7fffff) >> 12);
	      newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
	      md_number_to_chars (buf, newval, THUMB_SIZE);
	      md_number_to_chars (buf, newval2, THUMB_SIZE);
	    }
	  else
	    {
	      if (newval == T_OPCODE_BRANCH)
		{
		  unsigned long diff = (newval & 0x7ff) << 1;
		  if (diff & 0x800)
		    diff |= ~0x7ff;

		  value += diff;
		  if ((value & 0x800) && ((value & ~0x7ff) != ~0x7ff))
		    as_bad_where (fixP->fx_file, fixP->fx_line,
				  "Branch out of range");
		  newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
		}
	      else
		{
		  unsigned long diff = (newval & 0xff) << 1;
		  if (diff & 0x100)
		    diff |= ~0xff;

		  value += diff;
		  if ((value & 0x100) && ((value & ~0xff) != ~0xff))
		    as_bad_where (fixP->fx_file, fixP->fx_line,
				  "Branch out of range");
		  newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
		}
	      md_number_to_chars (buf, newval, THUMB_SIZE);
d5632 5
d5638 69
a5706 8
      else
	{
	  value = (value >> 2) & 0x00ffffff;
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  value = (value + (newval & 0x00ffffff)) & 0x00ffffff;
	  newval = value | (newval & 0xff000000);
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
d5712 7
d5724 7
d5733 7
d5744 12
d5757 1
d5759 4
d5767 1
a5767 1
		      "Illegal value for co-processor offset");
d5782 5
a5786 4
	  /* PC loads are somewhat odd, bit 2 of the PC is forced to zero
	     for these loads, so we may need to round up the offset if the
	     instruction is not word aligned since the final address must
	     be.   */
d5790 2
a5791 1
			  "Invalid offset, target not word aligned");
d5795 3
a5797 2
			  "Invalid offset");
	   /* Round up, since pc will be rounded down.  */
d5804 1
a5804 1
			  "Invalid offset");
d5811 1
a5811 1
			  "Invalid offset");
d5818 1
a5818 1
			  "Invalid offset");
d5825 1
a5825 1
			  "Invalid offset");
d5830 4
a5833 1
	  abort ();
d5862 1
a5862 1
                            "Invalid immediate for stack address calculation");
d5871 2
a5872 1
                            "Invalid immediate for address calculation (value = 0x%08X)", value);
d5874 1
d5881 1
a5881 1
                            "Invalid 8bit immediate");
d5889 1
a5889 1
                            "Invalid 3bit immediate");
d5905 2
a5906 1
                          "Invalid immediate: %d is too large", value);
d5920 1
a5920 1
		      "Illegal Thumb shift value: %d", value);
d5926 5
d5934 1
a5934 1
		    "Bad relocation fixup type (%d)\n", fixP->fx_r_type);
d5944 2
a5945 2
     asection *section;
     fixS *fixp;
d5947 1
a5947 1
  arelent *reloc;
d5950 1
a5950 2
  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  assert (reloc != 0);
d5952 2
a5953 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d5957 1
d5962 3
d5991 5
d6002 3
a6004 2
	 a section boundry - possibly due to an implicit dump */
      as_bad ("Literal referenced across section boundry (Implicit dump?)");
d6007 8
d6016 3
a6018 2
      as_bad ("Internal_relocation (type %d) not fixed up (IMMEDIATE)"
	      , fixp->fx_r_type);
d6021 4
a6024 3
    case BFD_RELOC_ARM_OFFSET_IMM:
      as_bad ("Internal_relocation (type %d) not fixed up (OFFSET_IMM)"
	      , fixp->fx_r_type);
d6027 4
a6030 3
    case BFD_RELOC_ARM_OFFSET_IMM8:
      as_bad ("Internal_relocation (type %d) not fixed up (OFFSET_IMM8)"
	      , fixp->fx_r_type);
d6033 24
a6056 4
    case BFD_RELOC_ARM_SHIFT_IMM:
      as_bad ("Internal_relocation (type %d) not fixed up (SHIFT_IMM)"
	      , fixp->fx_r_type);
      return NULL;
d6058 11
a6068 4
    case BFD_RELOC_ARM_SWI:
      as_bad ("Internal_relocation (type %d) not fixed up (SWI)"
	      , fixp->fx_r_type);
      return NULL;
d6070 5
a6074 8
    case BFD_RELOC_ARM_MULTI:
      as_bad ("Internal_relocation (type %d) not fixed up (MULTI)"
	      , fixp->fx_r_type);
      return NULL;

    case BFD_RELOC_ARM_CP_OFF_IMM:
      as_bad ("Internal_relocation (type %d) not fixed up (CP_OFF_IMM)"
	      , fixp->fx_r_type);
a6075 8

    case BFD_RELOC_ARM_THUMB_OFFSET:
      as_bad ("Internal_relocation (type %d) not fixed up (THUMB_OFFSET)"
	      , fixp->fx_r_type);
      return NULL;

    default:
      abort ();
d6078 4
a6081 2
  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  assert (reloc->howto != 0);
a6085 24
CONST int md_short_jump_size = 4;
CONST int md_long_jump_size = 4;

/* These should never be called on the arm */
void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("md_create_long_jump\n");
}

void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("md_create_short_jump\n");
}

d6088 2
a6089 2
     fragS *fragP;
     segT segtype;
d6091 2
a6092 2
  as_fatal ("md_estimate_size_before_relax\n");
  return (1);
d6095 2
a6096 3
void
output_inst (str)
     char *str;
d6098 1
a6098 1
  char *to = NULL;
d6102 1
a6102 1
      as_bad ("%s -- statement `%s'\n", inst.error, str);
d6107 2
a6108 1
  if (thumb_mode && (inst.size > 2))
d6110 3
a6112 3
      md_number_to_chars (to, inst.instruction >> 16, 2);
      to += 2;
      inst.size = 2;
d6114 8
a6121 2

  md_number_to_chars (to, inst.instruction, inst.size);
d6125 1
a6125 1
		 inst.size, &inst.reloc.exp, inst.reloc.pc_rel,
d6133 1
a6133 1
     char *str;
d6135 4
a6138 2
  char c;
  char *p, *q, *start;
d6140 2
a6141 2
  /* Align the instruction */
  /* this may not be the right thing to do but ... */
d6145 1
a6145 1
  /* Align the previous label if needed */
d6148 1
a6148 1
      last_label_seen->sy_frag = frag_now;
d6156 4
a6159 5
  if (*str == ' ')
    str++;			/* Skip leading white space */
    
  /* scan up to the end of the op-code, which must end in white space or
     end of string */
d6166 1
a6166 1
      as_bad ("No operator -- statement `%s'\n", str);
d6172 1
a6172 1
      CONST struct thumb_opcode *opcode;
d6178 1
d6181 7
d6191 1
a6191 1
	  output_inst (start);
d6197 2
a6198 1
      CONST struct asm_opcode *opcode;
d6204 1
a6204 1
	 matches, or we run out of opcode. */
d6212 1
d6216 1
a6216 1
	      char *r;
d6218 1
a6218 1
	      /* Check that this instruction is supported for this CPU */
d6223 1
a6223 1
	      if (q == p)		/* Just a simple opcode */
d6225 9
a6233 3
		  if (opcode->comp_suffix != 0)
		    as_bad ("Opcode `%s' must have suffix from <%s>\n", str,
			    opcode->comp_suffix);
d6236 1
d6240 1
a6240 1
		  output_inst (start);
d6244 1
a6244 1
	      /* Now check for a conditional */
d6258 1
a6258 1
"Warning: Use of the 'nv' conditional is deprecated\n");
d6260 1
a6260 1
		      inst.instruction |= cond->value;
d6264 1
a6264 1
		    inst.instruction |= COND_ALWAYS;
d6267 16
a6282 1
		inst.instruction |= COND_ALWAYS;
d6284 3
a6286 3
	      /* if there is a compulsory suffix, it should come here, before
		 any optional flags. */
	      if (opcode->comp_suffix)
d6300 1
a6300 1
		      as_bad ("Opcode `%s' must have suffix from <%s>\n", str,
d6324 1
a6324 1
			  if (! strcmp (r, flag[flagno].template))
d6340 1
a6340 1
	      output_inst (start);
d6350 1
a6350 2
     alias .req reg
     */
d6352 1
a6352 2
  while (*q == ' ')
    q++;
d6359 12
a6370 2
      int reg;
      if ((reg = arm_reg_parse (&str)) == FAIL)
d6372 2
a6373 5
	  char *r;
      
	  q += 4;
	  while (*q == ' ')
	    q++;
d6375 3
a6377 3
	  for (r = q; *r != '\0'; r++)
	    if (*r == ' ')
	      break;
d6379 3
a6381 1
	  if (r != q)
a6382 6
	      int regnum;
	      char d = *r;

	      *r = '\0';
	      regnum = arm_reg_parse (&q);
	      *r = d;
d6384 11
a6394 5
		{
		  insert_reg_alias (str, regnum);
		  *p = c;
		  return;
		}
d6396 3
d6401 4
a6404 4
	{
	  *p = c;
	  return;
	}
d6408 1
a6408 1
  as_bad ("bad instruction `%s'", start);
d6419 6
a6424 2
 *            -m[arm]6,               Arm 6 processors
 *            -m[arm]7[t][[d]m]       Arm 7 processors
d6433 7
d6442 3
a6444 2
CONST char *md_shortopts = "m:";
struct option md_longopts[] = {
d6450 4
d6461 2
a6462 2
     int c;
     char *arg;
d6464 1
a6464 1
  char *str = arg;
d6481 1
a6481 1
	  if (! strcmp (str, "fpa10"))
d6483 1
a6483 1
	  else if (! strcmp (str, "fpa11"))
d6485 1
a6485 1
	  else if (! strcmp (str, "fpe-old"))
d6492 1
a6492 1
	  if (! strcmp (str, "no-fpu"))
d6496 7
d6505 1
a6505 1
          if (! strcmp (str, "thumb"))
d6511 8
d6524 1
a6524 1
	  if (! strcmp (str, "all"))
d6529 5
d6535 50
d6592 1
a6592 1
	      if (! strcmp (str, "1"))
d6599 1
a6599 1
	      if (! strcmp (str, "2"))
d6601 1
a6601 1
	      else if (! strcmp (str, "250"))
d6608 1
a6608 1
	      if (! strcmp (str, "3"))
d6615 12
a6626 4
	      if (! strcmp (str, "6"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_6;
	      else
		goto bad;
d6630 13
a6642 1
              str++; /* eat the '7' */
d6646 1
a6646 1
                switch (*str)
d6649 1
a6649 1
                    cpu_variant |= ARM_THUMB;
d6656 10
a6665 4
                  case 'd': /* debug */
                  case 'i': /* embedded ice */
                    /* Included for completeness in ARM processor
                       naming. */
d6674 100
d6776 1
a6776 1
	      as_bad ("Invalid architecture -m%s", arg);
d6782 6
d6797 1
a6797 1
     FILE *fp;
d6799 21
a6819 7
  fprintf (fp,
"-m[arm]1, -m[arm]2, -m[arm]250,\n-m[arm]3, -m[arm]6, -m[arm]7[t][[d]m]\n\
-mthumb\t\t\tselect processor architecture\n\
-mall\t\t\tallow any instruction\n\
-mfpa10, -mfpa11\tselect floating point architecture\n\
-mfpe-old\t\tdon't allow floating-point multiple instructions\n\
-mno-fpu\t\tdon't allow any floating-point instructions.\n");
d6821 3
a6823 3
  fprintf (fp,
"-EB\t\t\tassemble code for a big endian cpu\n\
-EL\t\t\tassemble code for a little endian cpu\n");
d6836 6
a6841 6
     fragS *frag;
     int where;
     short int size;
     expressionS *exp;
     int pc_rel;
     int reloc;
d6843 2
a6844 2
  fixS *new_fix;
  arm_fix_data *arm_data;
d6856 2
a6857 16
      {
	const char *fake;
	symbolS *symbolP;
	
	/* FIXME: This should be something which decode_local_label_name
	   will handle.  */
	fake = FAKE_LABEL_NAME;

	/* Putting constant symbols in absolute_section rather than
	   expr_section is convenient for the old a.out code, for which
	   S_GET_SEGMENT does not always retrieve the value put in by
	   S_SET_SEGMENT.  */
	symbolP = symbol_new (fake, expr_section, 0, &zero_address_frag);
	symbolP->sy_value = *exp;
	new_fix = fix_new (frag, where, size, symbolP, 0, pc_rel, reloc);
      }
d6862 1
a6862 1
  arm_data = (arm_fix_data *) obstack_alloc (&notes, sizeof (arm_fix_data));
d6869 2
a6870 3
/* A good place to do this, although this was probably not intended
 * for this kind of use.  We need to dump the literal pool before
 * references are made to a null symbol pointer.  */
d6872 5
a6876 2
arm_after_pass_hook (ignore)
     asection *ignore;
d6878 6
a6883 1
  if (current_poolP != NULL)
d6885 13
a6897 3
      subseg_set (text_section, 0); /* Put it at the end of text section */
      s_ltorg (0);
      listing_prev_line ();
d6899 16
d6925 1
a6925 1
     symbolS *sym;
d6928 90
d7030 1
d7036 1
a7036 1
     char *name;
d7041 152
a7192 1
      && ! strcmp (name + len - 5, "/data"))
d7194 2
a7195 1
      *(name + len - 5) = 0;
d7198 36
a7233 1
  return name;
d7235 2
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@a46 1
#define ARM_250		0x00000002	/* Checkme, should this be = ARM_3?  */
d48 1
d50 6
a55 2
#define ARM_7		0x00000008
#define ARM_7DM		0x00000010
d62 1
a62 2
#define ARM_6UP		0x00fffff8
#define ARM_LONGMUL	0x00000010	/* Don't know which will have this.  */
d107 8
a114 1
const int md_reloc_size = 8;		/* Size of relocation record */
d121 1
d183 2
d216 3
a218 1

d227 12
a238 1
  {"s", 0x00100000},
d242 1
a242 1
static CONST struct asm_flg ldst_flags[] =
d247 1
d259 1
a259 1
  {"s", 0x00100000},
d312 21
d386 1
a386 1
/* ARM 7DM */
d388 3
d410 3
a412 3
/* All instructions take 4 bytes in the object file */

#define INSN_SIZE	4
d416 1
a416 1
 * ARM7DM has 4 of length 5
d450 2
a451 2
  {"str",   0x04000000, NULL,   ldst_flags,  ARM_ANY,      do_ldst},
  {"ldr",   0x04100000, NULL,   ldst_flags,  ARM_ANY,      do_ldst},
d455 2
a456 2
  {"bl",    0x0b000000, NULL,   NULL,        ARM_ANY,      do_branch},
  {"b",     0x0a000000, NULL,   NULL,        ARM_ANY,      do_branch},
d473 1
a473 1
/* ARM 7DM long multiplies - need signed/unsigned flags! */
d479 3
d528 1
a528 1
  {"fix",   0x0e100110, NULL,   round_flags, FPU_ALL,      do_fp_to_reg},
d531 5
a535 5
  {"cdp",   0x0e000000, NULL,  NULL,         ARM_ANY,      do_cdp},
  {"ldc",   0x0c100000, NULL,  cplong_flag,  ARM_ANY,      do_lstc},
  {"stc",   0x0c000000, NULL,  cplong_flag,  ARM_ANY,      do_lstc},
  {"mcr",   0x0e000010, NULL,  NULL,         ARM_ANY,      do_co_reg},
  {"mrc",   0x0e100010, NULL,  NULL,         ARM_ANY,      do_co_reg},
d542 1
d573 170
d754 2
d761 4
a764 4
  {"r0", 0},    {"r1", 1},    {"r2", 2},    {"r3", 3},
  {"r4", 4},    {"r5", 5},    {"r6", 6},    {"r7", 7},
  {"r8", 8},    {"r9", 9},    {"r10", 10},  {"r11", 11},
  {"r12", 12},  {"r13", 13},  {"r14", 14},  {"r15", REG_PC},
d766 4
a769 4
  {"a1", 0},	{"a2", 1},    {"a3", 2},    {"a4", 3},
  {"v1", 4},	{"v2", 5},    {"v3", 6},    {"v4", 7},     {"v5", 8},
  {"v6", 9},	{"sb", 9},    {"v7", 10},   {"sl", 10},
  {"fp", 11},	{"ip", 12},   {"sp", 13},   {"lr", 14},    {"pc", REG_PC},
d788 1
d806 3
d817 3
d861 2
d866 2
a867 1
  if (next_literal_pool_place > MAX_LITERAL_POOL_SIZE)
d869 18
a886 2
      inst.error = "Literal Pool Overflow\n";
      return FAIL;
a888 1
  literals[next_literal_pool_place].exp = inst.reloc.exp;
d890 1
a890 1
  inst.reloc.exp.X_add_number = (next_literal_pool_place++)*4-8;
d897 1
a897 1
   a later datete assign iot a value. Thats what these functions do */
d1003 1
a1003 1
validate_offset_imm (val)
d1005 1
d1007 3
a1009 2
  if (val < -4095 || val > 4095)
    as_bad ("bad immediate value for offset (%d)", val);
d1080 1
d1092 1
d1131 70
d2023 2
a2024 1
      if (!strcmp (*str, "rrx"))
d2048 1
a2048 1
	  if (! inst.reloc.exp.X_add_symbol)
d2050 4
a2053 4
	      int num = inst.reloc.exp.X_add_number;
	      if (num < 0 || num > 32
		  || (num == 32 
		      && (shft->value == 0 || shft->value == 0x60)))
d2360 2
a2361 2
  /* This is a pseudo-op of the form "adr rd, label" to be converted into
     a relative address of the form add rd, pc, #label-.-8 */
d2409 1
a2409 1
    inst.instruction |= 0x00100000;
d2444 1
a2444 1
ldst_extend (str)
d2446 1
d2461 2
a2462 1
	  if (value < -4095 || value > 4095)
d2474 6
a2479 1
	  inst.instruction |= add | value;
d2483 7
a2489 1
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d2504 10
a2513 3
      inst.instruction |= add | OFFSET_REG;
      if (skip_past_comma (str) == SUCCESS)
	return decode_shift (str, SHIFT_RESTRICT);
d2523 1
d2528 20
d2579 1
a2579 1
		       && (inst.instruction & 0x00100000))
d2591 1
a2591 1
	      if (ldst_extend (&str) == FAIL)
d2599 14
d2628 1
a2628 1
	  if (ldst_extend (&str) == FAIL)
d2646 1
a2646 1
		as_warn ("destination register same as write-back base\n");
d2691 7
a2697 1
	  inst.reloc.type = BFD_RELOC_ARM_LITERAL;
d2708 7
a2714 1
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d2729 7
a2735 9
static void
do_ldmstm (str, flags)
     char *str;
     unsigned long flags;
{
  int base_reg;

  while (*str == ' ')
    str++;
d2737 2
a2738 1
  if ((base_reg = reg_required_here (&str, 16)) == FAIL)
d2740 14
a2753 4
      if (!inst.error)
	inst.error = bad_args;
      return;
    }
d2755 5
a2759 5
  if (base_reg == REG_PC)
    {
      inst.error = "r15 not allowed as base register";
      return;
    }
d2761 9
a2769 7
  while (*str == ' ')
    str++;
  if (*str == '!')
    {
      flags |= WRITE_BACK;
      str++;
    }
d2771 11
a2781 5
  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = bad_args;
      return;
    }
d2783 11
a2793 12
  /* We come back here if we get ranges concatenated by '+' or '|' */
 another_range:
  if (*str == '{')
    {
      int in_range = 0;
      int cur_reg = -1;
      
      str++;
      do
	{
	  int reg;
	    
d2797 1
a2797 1
	  if ((reg = arm_reg_parse (&str)) == FAIL || !int_register (reg))
d2799 2
a2800 2
	      inst.error = "Register expected";
	      return;
d2802 4
d2807 4
a2810 1
	  if (in_range)
d2812 8
a2819 3
	      int i;
	      
	      if (reg <= cur_reg)
d2821 7
a2827 2
		  inst.error = "Bad range in register list";
		  return;
d2830 5
a2834 1
	      for (i = cur_reg + 1; i < reg; i++)
d2836 2
a2837 6
		  if (flags & (1 << i))
		    as_tsktsk 
		      ("Warning: Duplicated register (r%d) in register list",
		       i);
		  else
		    flags |= 1 << i;
d2839 4
a2842 1
	      in_range = 0;
d2844 1
a2845 11
	  if (flags & (1 << reg))
	    as_tsktsk ("Warning: Duplicated register (r%d) in register list",
		       reg);
	  else if (reg <= cur_reg)
	    as_tsktsk ("Warning: Register range not in ascending order");

	  flags |= 1 << reg;
	  cur_reg = reg;
	} while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
      str--;
d2849 1
a2849 1
      if (*str++ != '}')
d2851 2
a2852 2
	  inst.error = "Missing `}'";
	  return;
d2854 1
a2854 4
    }
  else
    {
      expressionS expr;
d2856 3
a2858 2
      if (my_get_expression (&expr, &str))
	return;
d2860 7
a2866 8
      if (expr.X_op == O_constant)
	{
	  if (expr.X_add_number 
	      != (expr.X_add_number & 0x0000ffff))
	    {
	      inst.error = "invalid register mask";
	      return;
	    }
d2868 2
a2869 3
	  if ((flags & expr.X_add_number) != 0)
	    {
	      int regno = flags & expr.X_add_number;
d2871 6
a2876 5
	      regno &= -regno;
	      regno = (1 << regno) - 1;
	      as_tsktsk ("Warning: Duplicated register (r%d) in register list",
			 regno);
	    }
d2878 4
a2881 14
	  flags |= expr.X_add_number;
	}
      else
	{
	  if (inst.reloc.type != 0)
	    {
	      inst.error = "expression too complex";
	      return;
	    }

	  memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	  inst.reloc.type = BFD_RELOC_ARM_MULTI;
	  inst.reloc.pc_rel = 0;
	}
d2886 5
d2892 2
a2893 1
  if (*str == '|' || *str == '+')
d2895 3
a2897 2
      str++;
      goto another_range;
d2905 2
a2906 1
  inst.instruction |= flags;
d3007 20
a3026 1
  inst.instruction |= flags | 0x00fffffe;	/* PC-rel adjust */
d3597 11
a3607 3
static void
insert_reg (entry)
     int entry;
d3609 1
a3609 4
  int len = strlen (reg_table[entry].name) + 2;
  char *buf = (char *) xmalloc (len);
  char *buf2 = (char *) xmalloc (len);
  int i = 0;
d3611 907
a4517 3
#ifdef REGISTER_PREFIX
  buf[i++] = REGISTER_PREFIX;
#endif
d4562 1
d4571 2
d4829 1
d4869 1
a4869 1
    case BFD_RELOC_ARM_OFFSET_IMM:
d4871 5
a4875 1
      value = validate_offset_imm (value); /* Should be OK ... but .... */
d4881 23
a4903 1
      newval |= value | (sign ? 0x00800000 : 0);
d4912 1
a4912 1
      if ((value = validate_immediate (value)) == FAIL)
d4921 1
a4921 1
      newval |= value | (sign ? 0x00800000 : 0);
d4946 18
a4963 5
      if (((unsigned long) value) > 0x00ffffff)
	as_bad_where (fixP->fx_file, fixP->fx_line, "Invalid swi expression");
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff000000;
      newval |= value;
      md_number_to_chars (buf, newval , INSN_SIZE);
d4975 59
a5033 5
      value = (value >> 2) & 0x00ffffff;
      newval = md_chars_to_number (buf, INSN_SIZE);
      value = (value + (newval & 0x00ffffff)) & 0x00ffffff;
      newval = value | (newval & 0xff000000);
      md_number_to_chars (buf, newval, INSN_SIZE);
d5060 1
a5060 1
      newval |= (value >> 2) | (sign ?  0x00800000 : 0);
d5064 142
d5266 1
d5282 5
d5307 5
d5367 9
a5375 2
  to = frag_more (INSN_SIZE);
  md_number_to_chars (to, inst.instruction, INSN_SIZE);
d5379 1
a5379 1
		 4, &inst.reloc.exp, inst.reloc.pc_rel,
a5389 1
  CONST struct asm_opcode *opcode;
d5423 9
a5431 12
  /* p now points to the end of the opcode, probably white space, but we have
     to break the opcode up in case it contains condionals and flags;
     keep trying with progressively smaller basic instructions until one
     matches, or we run out of opcode. */
  q = (p - str > LONGEST_INST) ? str + LONGEST_INST : p;
  for (; q != str; q--)
    {
      c = *q;
      *q = '\0';
      opcode = (CONST struct asm_opcode *) hash_find (arm_ops_hsh, str);
      *q = c;
      if (opcode && opcode->template)
d5433 27
a5459 2
	  unsigned long flag_bits = 0;
	  char *r;
d5461 3
a5463 3
	  /* Check that this instruction is supported for this CPU */
	  if ((opcode->variants & cpu_variant) == 0)
	    goto try_shorter;
d5465 2
a5466 7
	  inst.instruction = opcode->value;
	  if (q == p)		/* Just a simple opcode */
	    {
	      if (opcode->comp_suffix != 0)
		as_bad ("Opcode `%s' must have suffix from <%s>\n", str,
			opcode->comp_suffix);
	      else
d5468 10
a5477 2
		  inst.instruction |= COND_ALWAYS;
		  (*opcode->parms)(q, 0);
a5478 3
	      output_inst (start);
	      return;
	    }
d5480 3
a5482 11
	  /* Now check for a conditional */
	  r = q;
	  if (p - r >= 2)
	    {
	      CONST struct asm_cond *cond;
	      char d = *(r + 2);
	      
	      *(r + 2) = '\0';
	      cond = (CONST struct asm_cond *) hash_find (arm_cond_hsh, r);
	      *(r + 2) = d;
	      if (cond)
d5484 11
a5494 3
		  if (cond->value == 0xf0000000)
		    as_tsktsk
		      ("Warning: Use of the 'nv' conditional is deprecated\n");
d5496 5
a5500 2
		  inst.instruction |= cond->value;
		  r += 2;
a5503 3
	    }
	  else
	    inst.instruction |= COND_ALWAYS;
d5505 20
a5524 5
	  /* if there is a compulsory suffix, it should come here, before
	     any optional flags. */
	  if (opcode->comp_suffix)
	    {
	      CONST char *s = opcode->comp_suffix;
d5526 1
a5526 6
	      while (*s)
		{
		  inst.suffix++;
		  if (*r == *s)
		    break;
		  s++;
d5528 4
a5531 2
	      
	      if (*s == '\0')
d5533 2
a5534 7
		  as_bad ("Opcode `%s' must have suffix from <%s>\n", str,
			  opcode->comp_suffix);
		  return;
		}
		
	      r++;
	    }
d5536 3
a5538 10
	  /* The remainder, if any should now be flags for the instruction;
	     Scan these checking each one found with the opcode.  */
	  if (r != p)
	    {
	      char d;
	      CONST struct asm_flg *flag = opcode->flags;

	      if (flag)
		{
		  int flagno;
d5540 2
a5541 2
		  d = *p;
		  *p = '\0';
d5543 1
a5543 3
		  for (flagno = 0; flag[flagno].template; flagno++)
		    {
		      if (! strcmp (r, flag[flagno].template))
d5545 5
a5549 2
			  flag_bits |= flag[flagno].set_bits;
			  break;
d5551 4
d5556 1
a5556 3

		  *p = d;
		  if (! flag[flagno].template)
d5559 4
a5562 2
	      else
		goto try_shorter;
d5565 2
a5566 3
	  (*opcode->parms) (p, flag_bits);
	  output_inst (start);
	  return;
d5568 1
a5569 3
    try_shorter:
	;
    }
d5630 2
a5631 2
 *            -m[arm]6, -m[arm]7      Arm 6 and 7 processors
 *            -m[arm]7dm              Arm 7dm processors
d5652 1
a5652 1
size_t md_longopts_size = sizeof(md_longopts);
d5691 12
d5747 24
a5770 6
	      if (! strcmp (str, "7"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
	      else if (! strcmp (str, "7dm"))
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7DM;
	      else
		goto bad;
d5793 2
a5794 2
"-m[arm]1, -m[arm]2, -m[arm]250,\n-m[arm]3, -m[arm]6, -m[arm]7, -m[arm]7dm\n\
\t\t\tselect processor architecture\n\
d5823 1
d5854 5
d5888 28
@


1.1
log
@Initial revision
@
text
@d1236 1
d1576 3
a1578 1
      if (gen_to_words (words, 6, (long)15) == 0)
d1632 2
d1645 1
d1649 1
a1649 1
     in instructions, which is where is routine is always called.  */
d3474 1
a3474 1
md_apply_fix (fixP, val)
d3477 1
a3485 2
  fixP->fx_addnumber = value;	/* Remember value for emit_reloc */

d3489 12
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@a1235 1
      pre_inc = PRE_INDEX;
d1575 1
a1575 3
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.  */
      if (gen_to_words (words, 5, (long)15) == 0)
a1628 2

#ifdef OBJ_AOUT
a1639 1
#endif
d1643 1
a1643 1
     in instructions, which is where this routine is always called.  */
d3468 1
a3468 1
md_apply_fix3 (fixP, val, seg)
a3470 1
     segT seg;
d3479 2
a3483 12

  /* If this symbol is in a different section then we need to leave it for
     the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
     so we have to undo it's effects here.  */
  if (fixP->fx_pcrel)
    {
      if (S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
    }

  fixP->fx_addnumber = value;	/* Remember value for emit_reloc */
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d47 1
a48 1
#define ARM_250		ARM_3
d50 2
a51 6
#define ARM_7		ARM_6           /* same core instruction set */

/* The following bitmasks control CPU extensions (ARM7 onwards): */
#define ARM_LONGMUL	0x00000010	/* allow long multiplies */
#define ARM_ARCH4       0x00000020
#define ARM_THUMB       ARM_ARCH4
d58 2
a59 1
#define ARM_6UP		0x00fffff8      /* Includes ARM7 */
d104 1
a104 8
CONST int md_reloc_size = 8;		/* Size of relocation record */

static int thumb_mode = 0;      /* non-zero if assembling thumb instructions */

typedef struct arm_fix
{
  int thumb_mode;
} arm_fix_data;
a110 1
  int size;
a171 2
#define CONDS_BIT       (0x00100000)
#define LOAD_BIT        (0x00100000)
d203 1
a203 3
/* Warning: If the top bit of the set_bits is set, then the standard
   instruction bitmask is ignored, and the new bitmask is taken from
   the set_bits: */
d212 1
a212 12
  {"s", CONDS_BIT},
  {NULL, 0}
};

static CONST struct asm_flg ldr_flags[] =
{
  {"b",  0x00400000},
  {"t",  TRANS_BIT},
  {"bt", 0x00400000 | TRANS_BIT},
  {"h",  0x801000b0},
  {"sh", 0x801000f0},
  {"sb", 0x801000d0},
d216 1
a216 1
static CONST struct asm_flg str_flags[] =
a220 1
  {"h",  0x800000b0},
d232 1
a232 1
  {"s", CONDS_BIT},
a284 21
/* The implementation of the FIX instruction is broken on some assemblers,
   in that it accepts a precision specifier as well as a rounding specifier,
   despite the fact that this is meaningless.  To be more compatible, we
   accept it as well, though of course it does not set any bits.  */
static CONST struct asm_flg fix_flags[] =
{
  {"p", 0x00000020},
  {"m", 0x00000040},
  {"z", 0x00000060},
  {"sp", 0x00000020},
  {"sm", 0x00000040},
  {"sz", 0x00000060},
  {"dp", 0x00000020},
  {"dm", 0x00000040},
  {"dz", 0x00000060},
  {"ep", 0x00000020},
  {"em", 0x00000040},
  {"ez", 0x00000060},
  {NULL, 0}
};

d338 1
a338 1
/* ARM 7M */
a339 3
/* ARM THUMB */
static void do_bx               PARAMS ((char *operands, unsigned long flags));

d359 3
a361 3
/* ARM instructions take 4bytes in the object file, Thumb instructions
   take 2: */
#define INSN_SIZE       4
d365 1
a365 1
 * ARM7M has 4 of length 5
d399 2
a400 2
  {"str",   0x04000000, NULL,   str_flags,   ARM_ANY,      do_ldst},
  {"ldr",   0x04100000, NULL,   ldr_flags,   ARM_ANY,      do_ldst},
d404 2
a405 2
  {"bl",    0x0bfffffe, NULL,   NULL,        ARM_ANY,      do_branch},
  {"b",     0x0afffffe, NULL,   NULL,        ARM_ANY,      do_branch},
d422 1
a422 1
/* ARM 7M long multiplies - need signed/unsigned flags! */
a427 3
/* ARM THUMB interworking */
  {"bx",    0x012fff10, NULL,   NULL,        ARM_THUMB,    do_bx},

d474 1
a474 1
  {"fix",   0x0e100110, NULL,   fix_flags,   FPU_ALL,      do_fp_to_reg},
d477 5
a481 5
  {"cdp",   0x0e000000, NULL,  NULL,         ARM_2UP,      do_cdp},
  {"ldc",   0x0c100000, NULL,  cplong_flag,  ARM_2UP,      do_lstc},
  {"stc",   0x0c000000, NULL,  cplong_flag,  ARM_2UP,      do_lstc},
  {"mcr",   0x0e000010, NULL,  NULL,         ARM_2UP,      do_co_reg},
  {"mrc",   0x0e100010, NULL,  NULL,         ARM_2UP,      do_co_reg},
a487 1
#define HWOFFSET_IMM    0x00400000
a517 170
static void do_t_arit		PARAMS ((char *operands));
static void do_t_add		PARAMS ((char *operands));
static void do_t_asr		PARAMS ((char *operands));
static void do_t_branch		PARAMS ((char *operands));
static void do_t_bx		PARAMS ((char *operands));
static void do_t_compare	PARAMS ((char *operands));
static void do_t_ldmstm		PARAMS ((char *operands));
static void do_t_ldr		PARAMS ((char *operands));
static void do_t_ldrb		PARAMS ((char *operands));
static void do_t_ldrh		PARAMS ((char *operands));
static void do_t_lds		PARAMS ((char *operands));
static void do_t_lsl		PARAMS ((char *operands));
static void do_t_lsr		PARAMS ((char *operands));
static void do_t_mov		PARAMS ((char *operands));
static void do_t_push_pop	PARAMS ((char *operands));
static void do_t_str		PARAMS ((char *operands));
static void do_t_strb		PARAMS ((char *operands));
static void do_t_strh		PARAMS ((char *operands));
static void do_t_sub		PARAMS ((char *operands));
static void do_t_swi		PARAMS ((char *operands));
static void do_t_adr		PARAMS ((char *operands));

#define T_OPCODE_MUL 0x4340
#define T_OPCODE_TST 0x4200
#define T_OPCODE_CMN 0x42c0
#define T_OPCODE_NEG 0x4240
#define T_OPCODE_MVN 0x43c0

#define T_OPCODE_ADD_R3	0x1800
#define T_OPCODE_SUB_R3 0x1a00
#define T_OPCODE_ADD_HI 0x4400
#define T_OPCODE_ADD_ST 0xb000
#define T_OPCODE_SUB_ST 0xb080
#define T_OPCODE_ADD_SP 0xa800
#define T_OPCODE_ADD_PC 0xa000
#define T_OPCODE_ADD_I8 0x3000
#define T_OPCODE_SUB_I8 0x3800
#define T_OPCODE_ADD_I3 0x1c00
#define T_OPCODE_SUB_I3 0x1e00

#define T_OPCODE_ASR_R	0x4100
#define T_OPCODE_LSL_R	0x4080
#define T_OPCODE_LSR_R  0x40c0
#define T_OPCODE_ASR_I	0x1000
#define T_OPCODE_LSL_I	0x0000
#define T_OPCODE_LSR_I	0x0800

#define T_OPCODE_MOV_I8	0x2000
#define T_OPCODE_CMP_I8 0x2800
#define T_OPCODE_CMP_LR 0x4280
#define T_OPCODE_MOV_HR 0x4600
#define T_OPCODE_CMP_HR 0x4500

#define T_OPCODE_LDR_PC 0x4800
#define T_OPCODE_LDR_SP 0x9800
#define T_OPCODE_STR_SP 0x9000
#define T_OPCODE_LDR_IW 0x6800
#define T_OPCODE_STR_IW 0x6000
#define T_OPCODE_LDR_IH 0x8800
#define T_OPCODE_STR_IH 0x8000
#define T_OPCODE_LDR_IB 0x7800
#define T_OPCODE_STR_IB 0x7000
#define T_OPCODE_LDR_RW 0x5800
#define T_OPCODE_STR_RW 0x5000
#define T_OPCODE_LDR_RH 0x5a00
#define T_OPCODE_STR_RH 0x5200
#define T_OPCODE_LDR_RB 0x5c00
#define T_OPCODE_STR_RB 0x5400

#define T_OPCODE_PUSH	0xb400
#define T_OPCODE_POP	0xbc00

#define T_OPCODE_BRANCH 0xe7fe

static int thumb_reg		PARAMS ((char **str, int hi_lo));

#define THUMB_SIZE	2	/* Size of thumb instruction */
#define THUMB_REG_LO	0x1
#define THUMB_REG_HI	0x2
#define THUMB_REG_ANY	0x3

#define THUMB_H1	0x0080
#define THUMB_H2	0x0040

#define THUMB_ASR 0
#define THUMB_LSL 1
#define THUMB_LSR 2

#define THUMB_MOVE 0
#define THUMB_COMPARE 1

#define THUMB_LOAD 0
#define THUMB_STORE 1

#define THUMB_PP_PC_LR 0x0100

/* These three are used for immediate shifts, do not alter */
#define THUMB_WORD 2
#define THUMB_HALFWORD 1
#define THUMB_BYTE 0

struct thumb_opcode 
{
  CONST char *template;		/* Basic string to match */
  unsigned long value;		/* Basic instruction code */
  int size;
  void (*parms)();		/* Function to call to parse args */
};

static CONST struct thumb_opcode tinsns[] =
{
  {"adc",	0x4140,		2,	do_t_arit},
  {"add",	0x0000,		2,	do_t_add},
  {"and",	0x4000,		2,	do_t_arit},
  {"asr",	0x0000,		2,	do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	do_t_branch},
  {"beq",	0xd0fe,		2,	do_t_branch},
  {"bne",	0xd1fe,		2,	do_t_branch},
  {"bcs",	0xd2fe,		2,	do_t_branch},
  {"bhs",	0xd2fe,		2,	do_t_branch},
  {"bcc",	0xd3fe,		2,	do_t_branch},
  {"bul",	0xd3fe,		2,	do_t_branch},
  {"blo",	0xd3fe,		2,	do_t_branch},
  {"bmi",	0xd4fe,		2,	do_t_branch},
  {"bpl",	0xd5fe,		2,	do_t_branch},
  {"bvs",	0xd6fe,		2,	do_t_branch},
  {"bvc",	0xd7fe,		2,	do_t_branch},
  {"bhi",	0xd8fe,		2,	do_t_branch},
  {"bls",	0xd9fe,		2,	do_t_branch},
  {"bge",	0xdafe,		2,	do_t_branch},
  {"blt",	0xdbfe,		2,	do_t_branch},
  {"bgt",	0xdcfe,		2,	do_t_branch},
  {"ble",	0xddfe,		2,	do_t_branch},
  {"bic",	0x4380,		2,	do_t_arit},
  {"bl",	0xf7fffffe,	4,	do_t_branch},
  {"bx",	0x4700,		2,	do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	do_t_arit},
  {"cmp",	0x0000,		2,	do_t_compare},
  {"eor",	0x4040,		2,	do_t_arit},
  {"ldmia",	0xc800,		2,	do_t_ldmstm},
  {"ldr",	0x0000,		2,	do_t_ldr},
  {"ldrb",	0x0000,		2,	do_t_ldrb},
  {"ldrh",	0x0000,		2,	do_t_ldrh},
  {"ldrsb",	0x5600,		2,	do_t_lds},
  {"ldrsh",	0x5e00,		2,	do_t_lds},
  {"ldsb",	0x5600,		2,	do_t_lds},
  {"ldsh",	0x5e00,		2,	do_t_lds},
  {"lsl",	0x0000,		2,	do_t_lsl},
  {"lsr",	0x0000,		2,	do_t_lsr},
  {"mov",	0x0000,		2,	do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	do_t_arit},
  {"orr",	0x4300,		2,	do_t_arit},
  {"pop",	0xbc00,		2,	do_t_push_pop},
  {"push",	0xb400,		2,	do_t_push_pop},
  {"ror",	0x41c0,		2,	do_t_arit},
  {"sbc",	0x4180,		2,	do_t_arit},
  {"stmia",	0xc000,		2,	do_t_ldmstm},
  {"str",	0x0000,		2,	do_t_str},
  {"strb",	0x0000,		2,	do_t_strb},
  {"strh",	0x0000,		2,	do_t_strh},
  {"swi",	0xdf00,		2,	do_t_swi},
  {"sub",	0x0000,		2,	do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	do_t_arit},
  /* Pseudo ops: */
  {"adr",       0x0000,         2,      do_t_adr},
  {"nop",       0x0000,         2,      do_nop},
};

a528 2
#define REG_LR  14
#define REG_SP  13
d534 4
a537 4
  {"r0", 0},    {"r1", 1},      {"r2", 2},      {"r3", 3},
  {"r4", 4},    {"r5", 5},      {"r6", 6},      {"r7", 7},
  {"r8", 8},    {"r9", 9},      {"r10", 10},    {"r11", 11},
  {"r12", 12},  {"r13", REG_SP},{"r14", REG_LR},{"r15", REG_PC},
d539 4
a542 4
  {"a1", 0},	{"a2", 1},    {"a3", 2},     {"a4", 3},
  {"v1", 4},	{"v2", 5},    {"v3", 6},     {"v4", 7},     {"v5", 8},
  {"v6", 9},	{"sb", 9},    {"v7", 10},    {"sl", 10},
  {"fp", 11},	{"ip", 12},   {"sp", REG_SP},{"lr", REG_LR},{"pc", REG_PC},
a560 1
static struct hash_control *arm_tops_hsh = NULL;
a577 3
static void s_arm PARAMS ((int));
static void s_thumb PARAMS ((int));
static void s_code PARAMS ((int));
a585 3
  {"arm", s_arm, 0},
  {"thumb", s_thumb, 0},
  {"code", s_code, 0},
a626 2
  int lit_count = 0;

d630 1
a630 2
  /* Check if this literal value is already in the pool: */
  while (lit_count < next_literal_pool_place)
d632 2
a633 18
      if (literals[lit_count].exp.X_op == inst.reloc.exp.X_op
          && inst.reloc.exp.X_op == O_constant
          && literals[lit_count].exp.X_add_number == inst.reloc.exp.X_add_number
          && literals[lit_count].exp.X_unsigned == inst.reloc.exp.X_unsigned)
        break;
      lit_count++;
    }

  if (lit_count == next_literal_pool_place) /* new entry */
    {
      if (next_literal_pool_place > MAX_LITERAL_POOL_SIZE)
        {
          inst.error = "Literal Pool Overflow\n";
          return FAIL;
        }

      literals[next_literal_pool_place].exp = inst.reloc.exp;
      lit_count = next_literal_pool_place++;
d636 1
d638 1
a638 1
  inst.reloc.exp.X_add_number = (lit_count)*4-8;
d645 1
a645 1
   a later date assign it a value. Thats what these functions do */
d751 1
a751 1
validate_offset_imm (val, hwse)
a752 1
     int hwse;
d754 2
a755 3
  if ((hwse && (val < -255 || val > 255))
      || (val < -4095 || val > 4095))
     return FAIL;
a825 1
#if 0 /* not used */
a836 1
#endif
a874 70
opcode_select (width)
     int width;
{
  switch (width)
    {
    case 16:
      if (! thumb_mode)
	{
	  if (! (cpu_variant & ARM_THUMB))
	    as_bad ("selected processor does not support THUMB opcodes");
	  thumb_mode = 1;
          /* No need to force the alignment, since we will have been
             coming from ARM mode, which is word-aligned. */
          record_alignment (now_seg, 1);
	}
      break;

    case 32:
      if (thumb_mode)
	{
          if ((cpu_variant & ARM_ANY) == ARM_THUMB)
	    as_bad ("selected processor does not support ARM opcodes");
	  thumb_mode = 0;
          if (!need_pass_2)
            frag_align (2, 0);
          record_alignment (now_seg, 1);
	}
      break;

    default:
      as_bad ("invalid instruction size selected (%d)", width);
    }
}

static void
s_arm (ignore)
     int ignore;
{
  opcode_select (32);
  demand_empty_rest_of_line ();
}

static void
s_thumb (ignore)
     int ignore;
{
  opcode_select (16);
  demand_empty_rest_of_line ();
}

static void
s_code (unused)
     int unused;
{
  register int temp;

  temp = get_absolute_expression ();
  switch (temp)
    {
    case 16:
    case 32:
      opcode_select(temp);
      break;

    default:
      as_bad ("invalid operand to .code directive (%d)", temp);
    }
}

static void
d1697 1
a1697 2
      if (!strcmp (*str, "rrx")
          || !strcmp (*str, "RRX"))
d1721 1
a1721 1
	  if (inst.reloc.exp.X_op == O_constant)
d1723 4
a1726 4
	      unsigned num = inst.reloc.exp.X_add_number;

	      /* Reject operations greater than 32, or lsl #32 */
	      if (num > 32 || (num == 32 && shft->value == 0))
d2033 2
a2034 2
  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-8" */
d2082 1
a2082 1
    inst.instruction |= CONDS_BIT;
d2117 1
a2117 1
ldst_extend (str, hwse)
a2118 1
     int hwse;
d2133 1
a2133 2
          if ((hwse && (value < -255 || value > 255))
               || (value < -4095 || value > 4095))
d2145 1
a2145 6
          /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0 */
          if (hwse)
            inst.instruction |= add | HWOFFSET_IMM | (value >> 4) << 8 | value & 0xF;
          else
            inst.instruction |= add | value;
d2149 1
a2149 7
          if (hwse)
            {
              inst.instruction |= HWOFFSET_IMM;
              inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
            }
          else
            inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d2164 3
a2166 10

      if (hwse)
        inst.instruction |= add;
      else
        {
          inst.instruction |= add | OFFSET_REG;
          if (skip_past_comma (str) == SUCCESS)
            return decode_shift (str, SHIFT_RESTRICT);
        }

a2175 1
  int halfword = 0;
a2179 20
  /* This is not ideal, but it is the simplest way of dealing with the
     ARM7T halfword instructions (since they use a different
     encoding, but the same mnemonic): */
  if (halfword = ((flags & 0x80000000) != 0))
    {
      /* This is actually a load/store of a halfword, or a
         signed-extension load */
      if ((cpu_variant & ARM_ARCH4) == 0)
        {
          inst.error
           = "Processor does not support halfwords or signed bytes\n";
          return;
        }

      inst.instruction = (inst.instruction & COND_MASK)
                         | (flags & ~COND_MASK);

      flags = 0;
    }

d2211 1
a2211 1
		       && (inst.instruction & LOAD_BIT))
d2223 1
a2223 1
	      if (ldst_extend (&str, halfword) == FAIL)
a2230 14
              if (halfword)
                inst.instruction |= HWOFFSET_IMM;

              while (*str == ' ')
               str++;

              if (*str == '!')
               {
                 if (conflict_reg)
                  as_warn ("destination register same as write-back base\n");
                 str++;
                 inst.instruction |= WRITE_BACK;
               }

d2246 1
a2246 1
	  if (ldst_extend (&str, halfword) == FAIL)
d2264 1
a2264 1
		as_tsktsk ("destination register same as write-back base\n");
d2309 1
a2309 7
          if (halfword)
            {
              inst.instruction |= HWOFFSET_IMM;
              inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
            }
          else
	    inst.reloc.type = BFD_RELOC_ARM_LITERAL;
d2320 1
a2320 7
      if (halfword)
        {
          inst.instruction |= HWOFFSET_IMM;
          inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
        }
      else
        inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d2335 9
a2343 7
static long
reg_list (strp)
     char **strp;
{
  char *str = *strp;
  long range = 0;
  int another_range;
d2345 1
a2345 2
  /* We come back here if we get ranges concatenated by '+' or '|' */
  do
d2347 4
a2350 1
      another_range = 0;
d2352 5
a2356 12
      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;
      
	  str++;
	  do
	    {
	      int reg;
	    
	      while (*str == ' ')
		str++;
d2358 7
a2364 5
	      if ((reg = arm_reg_parse (&str)) == FAIL || !int_register (reg))
		{
		  inst.error = "Register expected";
		  return FAIL;
		}
d2366 5
a2370 9
	      if (in_range)
		{
		  int i;
	      
		  if (reg <= cur_reg)
		    {
		      inst.error = "Bad range in register list";
		      return FAIL;
		    }
d2372 12
a2383 23
		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk 
			  ("Warning: Duplicated register (r%d) in register list",
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}

	      if (range & (1 << reg))
		as_tsktsk ("Warning: Duplicated register (r%d) in register list",
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk ("Warning: Register range not in ascending order");

	      range |= 1 << reg;
	      cur_reg = reg;
	    } while (skip_past_comma (&str) != FAIL
		     || (in_range = 1, *str++ == '-'));
	  str--;
d2387 1
a2387 1
	  if (*str++ != '}')
d2389 2
a2390 2
	      inst.error = "Missing `}'";
	      return FAIL;
a2391 4
	}
      else
	{
	  expressionS expr;
d2393 1
a2393 4
	  if (my_get_expression (&expr, &str))
	    return FAIL;

	  if (expr.X_op == O_constant)
d2395 3
a2397 2
	      if (expr.X_add_number 
		  != (expr.X_add_number & 0x0000ffff))
d2399 2
a2400 2
		  inst.error = "invalid register mask";
		  return FAIL;
d2403 1
a2403 1
	      if ((range & expr.X_add_number) != 0)
d2405 6
a2410 17
		  int regno = range & expr.X_add_number;

		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk 
		    ("Warning: Duplicated register (r%d) in register list",
		     regno);
		}

	      range |= expr.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = "expression too complex";
		  return FAIL;
d2412 1
a2412 4

	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
a2413 1
	}
d2415 11
d2429 1
a2429 1
      if (*str == '|' || *str == '+')
d2431 2
a2432 2
	  str++;
	  another_range = 1;
d2434 7
a2440 1
    } while (another_range);
d2442 8
a2449 3
  *strp = str;
  return range;
}
d2451 3
a2453 7
static void
do_ldmstm (str, flags)
     char *str;
     unsigned long flags;
{
  int base_reg;
  long range;
d2455 5
a2459 2
  while (*str == ' ')
    str++;
d2461 9
a2469 6
  if ((base_reg = reg_required_here (&str, 16)) == FAIL)
    {
      if (!inst.error)
	inst.error = bad_args;
      return;
    }
d2471 4
a2474 4
  if (base_reg == REG_PC)
    {
      inst.error = "r15 not allowed as base register";
      return;
d2479 2
a2480 1
  if (*str == '!')
a2481 1
      flags |= WRITE_BACK;
d2483 1
a2483 8
    }

  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = bad_args;
      return;
d2491 1
a2491 2

  inst.instruction |= flags | range;
d2592 1
a2592 20
  end_of_line (str);
  return;
}

static void
do_bx (str, flags)
     char *str;
     unsigned long flags;
{
  int reg;

  while (*str == ' ')
    str++;

  if ((reg = reg_required_here (&str, 0)) == FAIL)
    return;

  if (reg == REG_PC)
    as_tsktsk ("Use of r15 in bx has undefined behaviour");

d3163 8
a3170 1
/* Thumb specific routines */
d3172 3
a3174 11
/* Parse and validate that a register is of the right form, this saves
   repeated checking of this information in many similar cases. 
   Unlike the 32-bit case we do not insert the register into the opcode 
   here, since the position is often unknown until the full instruction 
   has been parsed.  */
static int
thumb_reg (strp, hi_lo)
     char **strp;
     int hi_lo;
{
  int reg;
d3176 1
a3176 909
  if ((reg = arm_reg_parse (strp)) == FAIL || ! int_register (reg))
    {
      inst.error = "Register expected";
      return FAIL;
    }

  switch (hi_lo)
    {
    case THUMB_REG_LO:
      if (reg > 7)
	{
	  inst.error = "lo register required";
	  return FAIL;
	}
      break;

    case THUMB_REG_HI:
      if (reg < 8)
	{
	  inst.error = "hi register required";
	  return FAIL;
	}
      break;

    default:
      break;
    }

  return reg;
}

/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode
   was SUB.  */
static void
thumb_add_sub (str, subtract)
     char *str;
     int subtract;
{
  int Rd, Rs, Rn = FAIL;

  while (*str == ' ')
    str++;

  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = bad_args;
      return;
    }

  if (*str == '#')
    {
      Rs = Rd;
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;

      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers and pretend there 
	     are 3 */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (*str == '#')
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
    }

  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found. */
  if (Rn != FAIL)
    {
      /* All register format.  */
      if (Rd > 7 || Rs > 7 || Rd > 7)
	{
	  if (Rs != Rd)
	    {
	      inst.error = "dest and source1 must be the same register";
	      return;
	    }

	  /* Can't do this for SUB */
	  if (subtract)
	    {
	      inst.error = "subtract valid only on lo regs";
	      return;
	    }

	  inst.instruction = (T_OPCODE_ADD_HI
			      | (Rd > 7 ? THUMB_H1 : 0)
			      | (Rn > 7 ? THUMB_H2 : 0));
	  inst.instruction |= (Rd & 7) | ((Rn & 7) << 3);
	}
      else
	{
	  inst.instruction = subtract ? T_OPCODE_SUB_R3 : T_OPCODE_ADD_R3;
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
	}
    }
  else
    {
      /* Immediate expression, now things start to get nasty.  */

      /* First deal with HI regs, only very restricted cases allowed:
	 Adjusting SP, and using PC or SP to get an address.  */
      if ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
	  || (Rs > 7 && Rs != REG_SP && Rs != REG_PC))
	{
	  inst.error = "invalid Hi register with immediate";
	  return;
	}

      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, all we can do is store all the fragments
	     we know about in the instruction and let the reloc hacking 
	     work it all out.  */
	  inst.instruction = (subtract ? 0x8000 : 0) | (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
	}
      else
	{
	  int offset = inst.reloc.exp.X_add_number;

	  if (subtract)
	    offset = -offset;

	  if (offset < 0)
	    {
	      offset = -offset;
	      subtract = 1;

	      /* Quick check, in case offset is MIN_INT */
	      if (offset < 0)
		{
		  inst.error = "immediate value out of range";
		  return;
		}
	    }
	  else
	    subtract = 0;

	  if (Rd == REG_SP)
	    {
	      if (offset & ~0x1fc)
		{
		  inst.error = "invalid immediate value for stack adjust";
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	      inst.instruction |= offset >> 2;
	    }
	  else if (Rs == REG_PC || Rs == REG_SP)
	    {
	      if (subtract
		  || (offset & ~0x3fc))
		{
		  inst.error = "invalid immediate for address calculation";
		  return;
		}
	      inst.instruction = (Rs == REG_PC ? T_OPCODE_ADD_PC
				  : T_OPCODE_ADD_SP);
	      inst.instruction |= (Rd << 8) | (offset >> 2);
	    }
	  else if (Rs == Rd)
	    {
	      if (offset & ~0xff)
		{
		  inst.error = "immediate value out of range";
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	      inst.instruction |= (Rd << 8) | offset;
	    }
	  else
	    {
	      if (offset & ~0x7)
		{
		  inst.error = "immediate value out of range";
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	      inst.instruction |= Rd | (Rs << 3) | (offset << 6);
	    }
	}
    }
  end_of_line (str);
}

static void
thumb_shift (str, shift)
     char *str;
     int shift;
{
  int Rd, Rs, Rn = FAIL;

  while (*str == ' ')
    str++;

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = bad_args;
      return;
    }

  if (*str == '#')
    {
      /* Two operand immediate format, set Rs to Rd.  */
      Rs = Rd;
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else
    {
      if ((Rs =  thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;

      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers and pretend there
	     are 3 */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (*str == '#')
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
    }

  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found. */

  if (Rn != FAIL)
    {
      if (Rs != Rd)
	{
	  inst.error = "source1 and dest must be same register";
	  return;
	}

      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_R; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_R; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_R; break;
	}

      inst.instruction |= Rd | (Rn << 3);
    }
  else
    {
      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_I; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_I; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_I; break;
	}

      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, create a dummy reloc and let reloc
	     hacking fix it up */

	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	}
      else
	{
	  unsigned shift_value = inst.reloc.exp.X_add_number;

	  if (shift_value > 32 || (shift_value == 32 && shift == THUMB_LSL))
	    {
	      inst.error = "Invalid immediate for shift";
	      return;
	    }

	  /* Shifts of zero are handled by converting to LSL */
	  if (shift_value == 0)
	    inst.instruction = T_OPCODE_LSL_I;

	  /* Shifts of 32 are encoded as a shift of zero */
	  if (shift_value == 32)
	    shift_value = 0;

	  inst.instruction |= shift_value << 6;
	}

      inst.instruction |= Rd | (Rs << 3);
    }
  end_of_line (str);
}

static void
thumb_mov_compare (str, move)
     char *str;
     int move;
{
  int Rd, Rs = FAIL;

  while (*str == ' ')
    str++;

  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = bad_args;
      return;
    }

  if (*str == '#')
    {
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;

  if (Rs != FAIL)
    {
      if (Rs < 8 && Rd < 8)
	{
	  if (move == THUMB_MOVE)
	    /* A move of two lowregs is, by convention, encoded as
	       ADD Rd, Rs, #0 */
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;
	  inst.instruction |= Rd | (Rs << 3);
	}
      else
	{
	  if (move == THUMB_MOVE)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else
	    inst.instruction = T_OPCODE_CMP_HR;

	  if (Rd > 7)
	    inst.instruction |= THUMB_H1;

	  if (Rs > 7)
	    inst.instruction |= THUMB_H2;

	  inst.instruction |= (Rd & 7) | ((Rs & 7) << 3);
	}
    }
  else
    {
      if (Rd > 7)
	{
	  inst.error = "only lo regs allowed with immediate";
	  return;
	}

      if (move == THUMB_MOVE)
	inst.instruction = T_OPCODE_MOV_I8;
      else
	inst.instruction = T_OPCODE_CMP_I8;

      inst.instruction |= Rd << 8;

      if (inst.reloc.exp.X_op != O_constant)
	inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
      else
	{
	  unsigned value = inst.reloc.exp.X_add_number;

	  if (value > 255)
	    {
	      inst.error = "invalid immediate";
	      return;
	    }

	  inst.instruction |= value;
	}
    }

  end_of_line (str);
}

static void
thumb_load_store (str, load_store, size)
     char *str;
     int load_store;
     int size;
{
  int Rd, Rb, Ro = FAIL;

  while (*str == ' ')
    str++;

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = bad_args;
      return;
    }

  if (*str == '[')
    {
      str++;
      if ((Rb = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;

      if (skip_past_comma (&str) != FAIL)
	{
	  if (*str == '#')
	    {
	      str++;
	      if (my_get_expression (&inst.reloc.exp, &str))
		return;
	    }
	  else if ((Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	    return;
	}
      else
	{
	  inst.reloc.exp.X_op = O_constant;
	  inst.reloc.exp.X_add_number = 0;
	}

      if (*str != ']')
	{
	  inst.error = "expected ']'";
	  return;
	}
      str++;
    }
  else if (*str == '=')
    {
      abort ();
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      inst.instruction = T_OPCODE_LDR_PC | (Rd << 8);
      inst.reloc.pc_rel = 1;
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset */
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      end_of_line (str);
      return;
    }

  if (Rb == REG_PC || Rb == REG_SP)
    {
      if (size != THUMB_WORD)
	{
	  inst.error = "byte or halfword not valid for base register";
	  return;
	}
      else if (Rb == REG_PC && load_store != THUMB_LOAD)
	{
	  inst.error = "R15 based store not allowed";
	  return;
	}
      else if (Ro != FAIL)
	{
	  inst.error = "Invalid base register for register offset";
	  return;
	}

      if (Rb == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (load_store == THUMB_LOAD)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;

      inst.instruction |= Rd << 8;
      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;

	  if (offset & ~0x3fc)
	    {
	      inst.error = "invalid offset";
	      return;
	    }

	  inst.instruction |= offset >> 2;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
    }
  else if (Rb > 7)
    {
      inst.error = "invalid base register in load/store";
      return;
    }
  else if (Ro == FAIL)
    {
      /* Immediate offset */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IW : T_OPCODE_STR_IW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IH : T_OPCODE_STR_IH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IB : T_OPCODE_STR_IB);

      inst.instruction |= Rd | (Rb << 3);

      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;
	  
	  if (offset & ~(0x1f << size))
	    {
	      inst.error = "Invalid offset";
	      return;
	    }
	  inst.instruction |= offset << 6;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
    }
  else
    {
      /* Register offset */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RW : T_OPCODE_STR_RW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RH : T_OPCODE_STR_RH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RB : T_OPCODE_STR_RB);

      inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
    }

  end_of_line (str);
}

/* Handle the Format 4 instructions that do not have equivalents in other 
   formats.  That is, ADC, AND, EOR, SBC, ROR, TST, NEG, CMN, ORR, MUL,
   BIC and MVN.  */
static void
do_t_arit (str)
     char *str;
{
  int Rd, Rs, Rn;

  while (*str == ' ')
    str++;

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || (Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    {
      if (! inst.error)
	inst.error = bad_args;
      return;
    }

  if (skip_past_comma (&str) != FAIL)
    {
      /* Three operand format not allowed for TST, CMN, NEG and MVN.
	 (It isn't allowed for CMP either, but that isn't handled by this
	 function.)  */
      if (inst.instruction == T_OPCODE_TST
	  || inst.instruction == T_OPCODE_CMN
	  || inst.instruction == T_OPCODE_NEG
 	  || inst.instruction == T_OPCODE_MVN)
	{
	  inst.error = bad_args;
	  return;
	}

      if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;

      if (Rs != Rd)
	{
	  inst.error = "dest and source1 one must be the same register";
	  return;
	}
      Rs = Rn;
    }

  if (inst.instruction == T_OPCODE_MUL
      && Rs == Rd)
    as_tsktsk ("Rs and Rd must be different in MUL");

  inst.instruction |= Rd | (Rs << 3);
  end_of_line (str);
}

static void
do_t_add (str)
     char *str;
{
  thumb_add_sub (str, 0);
}

static void
do_t_asr (str)
     char *str;
{
  thumb_shift (str, THUMB_ASR);
}

static void
do_t_branch (str)
     char *str;
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
  inst.reloc.type = BFD_RELOC_ARM_PCREL_BRANCH;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}

static void
do_t_bx (str)
     char *str;
{
  int reg;

  while (*str == ' ')
    str++;

  if ((reg = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;

  /* This sets THUMB_H2 from the top bit of reg.  */
  inst.instruction |= reg << 3;

  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.  The reloc
     should cause the alignment to be checked once it is known.  This is
     because BX PC only works if the instruction is word aligned.  */

  end_of_line (str);
}

static void
do_t_compare (str)
     char *str;
{
  thumb_mov_compare (str, THUMB_COMPARE);
}

static void
do_t_ldmstm (str)
     char *str;
{
  int Rb;
  long range;

  while (*str == ' ')
    str++;

  if ((Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    return;

  if (*str != '!')
    as_warn ("Inserted missing '!': load/store multiple always writes back base register");
  else
    str++;

  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = bad_args;
      return;
    }

  if (inst.reloc.type != BFD_RELOC_NONE)
    {
      /* This really doesn't seem worth it. */
      inst.reloc.type = BFD_RELOC_NONE;
      inst.error = "Expression too complex";
      return;
    }

  if (range & ~0xff)
    {
      inst.error = "only lo-regs valid in load/store multiple";
      return;
    }

  inst.instruction |= (Rb << 8) | range;
  end_of_line (str);
}

static void
do_t_ldr (str)
     char *str;
{
  thumb_load_store (str, THUMB_LOAD, THUMB_WORD);
}

static void
do_t_ldrb (str)
     char *str;
{
  thumb_load_store (str, THUMB_LOAD, THUMB_BYTE);
}

static void
do_t_ldrh (str)
     char *str;
{
  thumb_load_store (str, THUMB_LOAD, THUMB_HALFWORD);
}

static void
do_t_lds (str)
     char *str;
{
  int Rd, Rb, Ro;

  while (*str == ' ')
    str++;

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || (Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || *str++ != ']')
    {
      if (! inst.error)
	inst.error = "Syntax: ldrs[b] Rd, [Rb, Ro]";
      return;
    }

  inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
  end_of_line (str);
}

static void
do_t_lsl (str)
     char *str;
{
  thumb_shift (str, THUMB_LSL);
}

static void
do_t_lsr (str)
     char *str;
{
  thumb_shift (str, THUMB_LSR);
}

static void
do_t_mov (str)
     char *str;
{
  thumb_mov_compare (str, THUMB_MOVE);
}

static void
do_t_push_pop (str)
     char *str;
{
  long range;

  while (*str == ' ')
    str++;

  if ((range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = bad_args;
      return;
    }

  if (inst.reloc.type != BFD_RELOC_NONE)
    {
      /* This really doesn't seem worth it. */
      inst.reloc.type = BFD_RELOC_NONE;
      inst.error = "Expression too complex";
      return;
    }

  if (range & ~0xff)
    {
      if ((inst.instruction == T_OPCODE_PUSH
	   && (range & ~0xff) == 1 << REG_LR)
	  || (inst.instruction == T_OPCODE_POP
	      && (range & ~0xff) == 1 << REG_PC))
	{
	  inst.instruction |= THUMB_PP_PC_LR;
	  range &= 0xff;
	}
      else
	{
	  inst.error = "invalid register list to push/pop instruction";
	  return;
	}
    }

  inst.instruction |= range;
  end_of_line (str);
}

static void
do_t_str (str)
     char *str;
{
  thumb_load_store (str, THUMB_STORE, THUMB_WORD);
}

static void
do_t_strb (str)
     char *str;
{
  thumb_load_store (str, THUMB_STORE, THUMB_BYTE);
}

static void
do_t_strh (str)
     char *str;
{
  thumb_load_store (str, THUMB_STORE, THUMB_HALFWORD);
}

static void
do_t_sub (str)
     char *str;
{
  thumb_add_sub (str, 1);
}

static void
do_t_swi (str)
     char *str;
{
  while (*str == ' ')
    str++;

  if (my_get_expression (&inst.reloc.exp, &str))
    return;

  inst.reloc.type = BFD_RELOC_ARM_SWI;
  end_of_line (str);
  return;
}

static void
do_t_adr (str)
     char *str;
{
  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-8" */
  while (*str == ' ')
    str++;

  if (reg_required_here (&str, 8) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
    {
      if (!inst.error)
	inst.error = bad_args;
      return;
    }

  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust */
  inst.reloc.pc_rel = 1;
  inst.instruction |= REG_PC; /* Rd is already placed into the instruction */
  end_of_line (str);
}

static void
insert_reg (entry)
     int entry;
{
  int len = strlen (reg_table[entry].name) + 2;
  char *buf = (char *) xmalloc (len);
  char *buf2 = (char *) xmalloc (len);
  int i = 0;

#ifdef REGISTER_PREFIX
  buf[i++] = REGISTER_PREFIX;
#endif

  strcpy (buf + i, reg_table[entry].name);
a3218 1
      || (arm_tops_hsh = hash_new ()) == NULL
a3226 2
  for (i = 0; i < sizeof (tinsns) / sizeof (struct thumb_opcode); i++)
    hash_insert (arm_tops_hsh, tinsns[i].template, (PTR) (tinsns + i));
a3482 1
  arm_fix_data *arm_data = (arm_fix_data *) fixP->tc_fix_data;
d3522 1
a3522 1
     case BFD_RELOC_ARM_OFFSET_IMM:
d3524 1
a3524 5
      if ((value = validate_offset_imm (value, 0)) == FAIL)
        {
          as_bad ("bad immediate value for offset (%d)", val);
          break;
        }
d3530 1
a3530 23
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

     case BFD_RELOC_ARM_OFFSET_IMM8:
     case BFD_RELOC_ARM_HWLITERAL:
      sign = value >= 0;
      if ((value = validate_offset_imm (value, 1)) == FAIL)
        {
          if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line, 
			"invalid literal constant: pool needs to be closer\n");
          else
            as_bad ("bad immediate value for offset (%d)", value);
          break;
        }

      if (value < 0)
	value = -value;

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff0f0;
      newval |= ((value >> 4) << 8) | value & 0xf | (sign ? INDEX_UP : 0);
d3539 1
a3539 1
      if ((value = validate_offset_imm (value, 0)) == FAIL)
d3548 1
a3548 1
      newval |= value | (sign ? INDEX_UP : 0);
d3573 5
a3577 18
      if (arm_data->thumb_mode)
	{
	  if (((unsigned long) value) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  "Invalid swi expression");
	  newval = md_chars_to_number (buf, THUMB_SIZE) & 0xff00;
	  newval |= value;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      else
	{
	  if (((unsigned long) value) > 0x00ffffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line, 
			  "Invalid swi expression");
	  newval = md_chars_to_number (buf, INSN_SIZE) & 0xff000000;
	  newval |= value;
	  md_number_to_chars (buf, newval , INSN_SIZE);
	}
d3589 5
a3593 59
      if (arm_data->thumb_mode)
	{
	  unsigned long newval2;
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  if (fixP->fx_size == 4)
	    {
	      unsigned long diff;

	      newval2 = md_chars_to_number (buf, THUMB_SIZE);
	      diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
	      if (diff & 0x400000)
		diff |= ~0x3fffff;
	      value += diff;
	      if ((value & 0x400000) && ((value & ~0x3fffff) != ~0x3fffff))
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      "Branch with link out of range");

	      newval = (newval & 0xf800) | ((value & 0x7fffff) >> 12);
	      newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
	      md_number_to_chars (buf, newval, THUMB_SIZE);
	      md_number_to_chars (buf, newval2, THUMB_SIZE);
	    }
	  else
	    {
	      if (newval == T_OPCODE_BRANCH)
		{
		  unsigned long diff = (newval & 0x7ff) << 1;
		  if (diff & 0x800)
		    diff |= ~0x7ff;

		  value += diff;
		  if ((value & 0x800) && ((value & ~0x7ff) != ~0x7ff))
		    as_bad_where (fixP->fx_file, fixP->fx_line,
				  "Branch out of range");
		  newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
		}
	      else
		{
		  unsigned long diff = (newval & 0xff) << 1;
		  if (diff & 0x100)
		    diff |= ~0xff;

		  value += diff;
		  if ((value & 0x100) && ((value & ~0xff) != ~0xff))
		    as_bad_where (fixP->fx_file, fixP->fx_line,
				  "Branch out of range");
		  newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
		}
	      md_number_to_chars (buf, newval, THUMB_SIZE);
	    }
	}
      else
	{
	  value = (value >> 2) & 0x00ffffff;
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  value = (value + (newval & 0x00ffffff)) & 0x00ffffff;
	  newval = value | (newval & 0xff000000);
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
d3620 1
a3620 1
      newval |= (value >> 2) | (sign ?  INDEX_UP : 0);
a3623 142
    case BFD_RELOC_ARM_THUMB_OFFSET:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      /* Exactly what ranges, and where the offset is inserted depends on
	 the type of instruction, we can establish this from the top 4 bits */
      switch (newval >> 12)
	{
	case 4: /* PC load */
	  /* PC loads are somewhat odd, bit 2 of the PC is forced to zero
	     for these loads, so we may need to round up the offset if the
	     instruction is not word aligned since the final address must
	     be.   */

	  if ((fixP->fx_frag->fr_address + fixP->fx_where + value) & 3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  "Invalid offset, target not word aligned");

	  if ((value + 2) & ~0x3fe)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  "Invalid offset");
	   /* Round up, since pc will be rounded down.  */
	  newval |= (value + 2) >> 2;
	  break;

	case 9: /* SP load/store */
	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  "Invalid offset");
	  newval |= value >> 2;
	  break;

	case 6: /* Word load/store */
	  if (value & ~0x7c)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  "Invalid offset");
	  newval |= value << 4; /* 6 - 2 */
	  break;

	case 7: /* Byte load/store */
	  if (value & ~0x1f)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  "Invalid offset");
	  newval |= value << 6;
	  break;

	case 8: /* Halfword load/store */
	  if (value & ~0x3e)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  "Invalid offset");
	  newval |= value << 5; /* 6 - 1 */
	  break;

	default:
	  abort ();
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_ADD:
      /* This is a complicated relocation, since we use it for all of
         the following immediate relocations:
            3bit ADD/SUB
            8bit ADD/SUB
            9bit ADD/SUB SP word-aligned
           10bit ADD PC/SP word-aligned

         The type of instruction being processed is encoded in the
         instruction field:
           0x8000  SUB
           0x00F0  Rd
           0x000F  Rs
      */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
        int rd = (newval >> 4) & 0xf;
        int rs = newval & 0xf;
        int subtract = newval & 0x8000;

        if (rd == REG_SP)
          {
            if (value & ~0x1fc)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            "Invalid immediate for stack address calculation");
            newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
            newval |= value >> 2;
          }
        else if (rs == REG_PC || rs == REG_SP)
          {
            if (subtract ||
                value & ~0x3fc)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            "Invalid immediate for address calculation (value = 0x%08X)", value);
            newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
            newval |= value >> 2;
          }
        else if (rs == rd)
          {
            if (value & ~0xff)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            "Invalid 8bit immediate");
            newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
            newval |= (rd << 8) | value;
          }
        else
          {
            if (value & ~0x7)
              as_bad_where (fixP->fx_file, fixP->fx_line,
                            "Invalid 3bit immediate");
            newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
            newval |= rd | (rs << 3) | (value << 6);
          }
      }
      md_number_to_chars (buf, newval , THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_IMM:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      switch (newval >> 11)
        {
        case 0x04: /* 8bit immediate MOV */
        case 0x05: /* 8bit immediate CMP */
          if (value < 0 || value > 255)
            as_bad_where (fixP->fx_file, fixP->fx_line,
                          "Invalid immediate: %d is too large", value);
          newval |= value;
          break;

        default:
          abort ();
        }
      md_number_to_chars (buf, newval , THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_SHIFT:
      /* 5bit shift value (0..31) */
      if (value < 0 || value > 31)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      "Illegal Thumb shift value: %d", value);
      newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf03f;
      newval |= value << 6;
      md_number_to_chars (buf, newval , THUMB_SIZE);
      break;

a3683 1
    case BFD_RELOC_ARM_HWLITERAL:
a3698 5
    case BFD_RELOC_ARM_OFFSET_IMM8:
      as_bad ("Internal_relocation (type %d) not fixed up (OFFSET_IMM8)"
	      , fixp->fx_r_type);
      return NULL;

a3718 5
    case BFD_RELOC_ARM_THUMB_OFFSET:
      as_bad ("Internal_relocation (type %d) not fixed up (THUMB_OFFSET)"
	      , fixp->fx_r_type);
      return NULL;

d3774 2
a3775 9
  to = frag_more (inst.size);
  if (thumb_mode && (inst.size > 2))
    {
      md_number_to_chars (to, inst.instruction >> 16, 2);
      to += 2;
      inst.size = 2;
    }

  md_number_to_chars (to, inst.instruction, inst.size);
d3779 1
a3779 1
		 inst.size, &inst.reloc.exp, inst.reloc.pc_rel,
d3790 1
d3824 19
a3842 3
  if (thumb_mode)
    {
      CONST struct thumb_opcode *opcode;
a3843 6
      c = *p;
      *p = '\0';
      opcode = (CONST struct thumb_opcode *) hash_find (arm_tops_hsh, str);
      *p = c;
      if (opcode)
	{
d3845 1
a3845 23
	  inst.size = opcode->size;
	  (*opcode->parms)(p);
	  output_inst (start);
	  return;
	}
    }
  else
    {
      CONST struct asm_opcode *opcode;

      inst.size = INSN_SIZE;
      /* p now points to the end of the opcode, probably white space, but we
	 have to break the opcode up in case it contains condionals and flags;
	 keep trying with progressively smaller basic instructions until one
	 matches, or we run out of opcode. */
      q = (p - str > LONGEST_INST) ? str + LONGEST_INST : p;
      for (; q != str; q--)
	{
	  c = *q;
	  *q = '\0';
	  opcode = (CONST struct asm_opcode *) hash_find (arm_ops_hsh, str);
	  *q = c;
	  if (opcode && opcode->template)
d3847 4
a3850 9
	      unsigned long flag_bits = 0;
	      char *r;

	      /* Check that this instruction is supported for this CPU */
	      if ((opcode->variants & cpu_variant) == 0)
		goto try_shorter;

	      inst.instruction = opcode->value;
	      if (q == p)		/* Just a simple opcode */
d3852 2
a3853 10
		  if (opcode->comp_suffix != 0)
		    as_bad ("Opcode `%s' must have suffix from <%s>\n", str,
			    opcode->comp_suffix);
		  else
		    {
		      inst.instruction |= COND_ALWAYS;
		      (*opcode->parms)(q, 0);
		    }
		  output_inst (start);
		  return;
d3855 3
d3859 11
a3869 3
	      /* Now check for a conditional */
	      r = q;
	      if (p - r >= 2)
d3871 3
a3873 11
		  CONST struct asm_cond *cond;
		  char d = *(r + 2);

		  *(r + 2) = '\0';
		  cond = (CONST struct asm_cond *) hash_find (arm_cond_hsh, r);
		  *(r + 2) = d;
		  if (cond)
		    {
		      if (cond->value == 0xf0000000)
			as_tsktsk (
"Warning: Use of the 'nv' conditional is deprecated\n");
d3875 2
a3876 5
		      inst.instruction |= cond->value;
		      r += 2;
		    }
		  else
		    inst.instruction |= COND_ALWAYS;
d3880 9
d3890 9
a3898 3
	      /* if there is a compulsory suffix, it should come here, before
		 any optional flags. */
	      if (opcode->comp_suffix)
d3900 7
a3906 1
		  CONST char *s = opcode->comp_suffix;
d3908 6
a3913 7
		  while (*s)
		    {
		      inst.suffix++;
		      if (*r == *s)
			break;
		      s++;
		    }
d3915 3
a3917 6
		  if (*s == '\0')
		    {
		      as_bad ("Opcode `%s' must have suffix from <%s>\n", str,
			      opcode->comp_suffix);
		      return;
		    }
d3919 2
a3920 9
		  r++;
		}

	      /* The remainder, if any should now be flags for the instruction;
		 Scan these checking each one found with the opcode.  */
	      if (r != p)
		{
		  char d;
		  CONST struct asm_flg *flag = opcode->flags;
d3922 1
a3922 1
		  if (flag)
d3924 1
a3924 6
		      int flagno;

		      d = *p;
		      *p = '\0';

		      for (flagno = 0; flag[flagno].template; flagno++)
d3926 2
a3927 5
			  if (! strcmp (r, flag[flagno].template))
			    {
			      flag_bits |= flag[flagno].set_bits;
			      break;
			    }
d3929 1
d3931 2
a3932 5
		      *p = d;
		      if (! flag[flagno].template)
			goto try_shorter;
		    }
		  else
d3935 2
a3936 4

	      (*opcode->parms) (p, flag_bits);
	      output_inst (start);
	      return;
d3939 3
a3941 2
	try_shorter:
	  ;
d3943 3
a3946 1

d4007 2
a4008 2
 *            -m[arm]6,               Arm 6 processors
 *            -m[arm]7[t][[d]m]       Arm 7 processors
d4029 1
a4029 1
size_t md_longopts_size = sizeof (md_longopts);
a4067 12
        case 't':
          /* Limit assembler to generating only Thumb instructions: */
          if (! strcmp (str, "thumb"))
            {
              cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_THUMB;
              cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_NONE;
              thumb_mode = 1;
            }
          else
	    goto bad;
          break;

d4112 6
a4117 24
              str++; /* eat the '7' */
              cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
              for (; *str; str++)
                {
                switch (*str)
                  {
                  case 't':
                    cpu_variant |= ARM_THUMB;
                    break;

                  case 'm':
                    cpu_variant |= ARM_LONGMUL;
                    break;

                  case 'd': /* debug */
                  case 'i': /* embedded ice */
                    /* Included for completeness in ARM processor
                       naming. */
                    break;

                  default:
                    goto bad;
                  }
                }
d4140 2
a4141 2
"-m[arm]1, -m[arm]2, -m[arm]250,\n-m[arm]3, -m[arm]6, -m[arm]7[t][[d]m]\n\
-mthumb\t\t\tselect processor architecture\n\
a4169 1
  arm_fix_data *arm_data;
a4199 5
  /* Mark whether the fix is to a THUMB instruction, or an ARM instruction */
  arm_data = (arm_fix_data *) obstack_alloc (&notes, sizeof (arm_fix_data));
  new_fix->tc_fix_data = (PTR) arm_data;
  arm_data->thumb_mode = thumb_mode;

a4228 28
}

int
arm_data_in_code ()
{
  if (thumb_mode && ! strncmp (input_line_pointer + 1, "data:", 5))
    {
      *input_line_pointer = '/';
      input_line_pointer += 5;
      *input_line_pointer = 0;
      return 1;
    }
  return 0;
}

char *
arm_canonicalize_symbol_name (name)
     char *name;
{
  int len;

  if (thumb_mode && (len = strlen (name)) > 5
      && ! strcmp (name + len - 5, "/data"))
    {
      *(name + len - 5) = 0;
    }

  return name;
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d1 2
a2 2
/* tc-arm.c -- Assemble for the ARM
   Copyright (C) 1994, 95, 96, 1997 Free Software Foundation, Inc.
d6 2
d21 2
a22 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d1036 1
a1036 1
    frag_align (1, 0, 0);
d1059 1
a1059 1
    frag_align (2, 0, 0);
d1088 1
a1088 1
    frag_align (power, fill, 0);
d1124 1
a1124 1
    frag_align (temp, (int) temp_fill, 0);
d1155 1
a1155 1
            frag_align (2, 0, 0);
d5225 2
a5226 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d5835 16
a5850 2
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999, 2000 Free Software Foundation, Inc.
d35 6
a40 2
#ifdef OBJ_ELF
#include "elf/arm.h"
a49 3
#define ARM_8		ARM_6           /* same core instruction set */
#define ARM_9		ARM_6           /* same core instruction set */
#define ARM_CPU_MASK	0x0000000f
d53 2
a54 10
#define ARM_HALFWORD    0x00000020	/* allow half word loads */
#define ARM_THUMB       0x00000040	/* allow BX instruction  */
#define ARM_EXT_V5	0x00000080	/* allow CLZ etc	 */
#define ARM_EXT_V5E     0x00000200	/* "El Segundo" 	 */

/* Architectures are the sum of the base and extensions.  */
#define ARM_ARCH_V4	(ARM_7 | ARM_LONGMUL | ARM_HALFWORD)
#define ARM_ARCH_V4T	(ARM_ARCH_V4 | ARM_THUMB)
#define ARM_ARCH_V5	(ARM_ARCH_V4 | ARM_EXT_V5)
#define ARM_ARCH_V5T	(ARM_ARCH_V5 | ARM_THUMB)
d58 1
a58 1
#define ARM_2UP		(ARM_ANY - ARM_1)
a71 1
     
a72 3
#if defined __thumb__
#define CPU_DEFAULT (ARM_ARCH_V4 | ARM_THUMB)
#else
a74 1
#endif
d80 1
a80 13
#define streq(a, b)           (strcmp (a, b) == 0)
#define skip_whitespace(str)  while (* (str) == ' ') ++ (str)

static unsigned long	cpu_variant = CPU_DEFAULT | FPU_DEFAULT;
static int target_oabi = 0;

#if defined OBJ_COFF || defined OBJ_ELF
/* Flags stored in private area of BFD structure */
static boolean		uses_apcs_26 = false;
static boolean		support_interwork = false;
static boolean		uses_apcs_float = false;
static boolean		pic_code = false;
#endif
d83 1
a83 1
   pre-processor is disabled, these aren't very useful.  */
d88 1
a88 1
   .line and .file directives will appear in the pre-processed output.  */
d91 2
a92 2
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
a94 3
#ifdef TE_LINUX
CONST char line_separator_chars[] = ";";
#else
a95 1
#endif
d97 1
a97 2
/* Chars that can be used to separate mant
   from exp in floating point numbers.  */
d106 1
a106 7
/* Prefix characters that indicate the start of an immediate
   value.  */
#define is_immediate_prefix(C) ((C) == '#' || (C) == '$')

#ifdef OBJ_ELF
symbolS * GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
#endif
d108 1
a108 1
CONST int md_reloc_size = 8;	/* Size of relocation record */
a109 3
static int thumb_mode = 0;      /* 0: assemble for ARM, 1: assemble for Thumb,
				   2: assemble for Thumb even though target cpu
				   does not support thumb instructions.  */
d117 1
a117 1
  CONST char *  error;
d119 2
a120 2
  int           suffix;
  int           size;
d124 2
a125 2
      expressionS              exp;
      int                      pc_rel;
d133 1
a133 1
  CONST char *  template;
d158 1
a158 1
CONST char * fp_const[] = 
d163 1
a163 1
/* Number of littlenums required to hold an extended precision number.  */
d188 1
a188 1
  CONST char *  template;
d192 1
a192 1
/* This is to save a hash look-up in the common case.  */
d217 1
a217 1
   the set_bits:  */
d220 1
a220 1
  CONST char *  template;	/* Basic flag string */
d346 2
a347 3
  CONST char *  template;
  boolean       cpsr;
  unsigned long field;
d350 1
a350 7
#define SPSR_BIT   (1 << 22)  /* The bit that distnguishes CPSR and SPSR.  */
#define PSR_SHIFT  16  /* How many bits to shift the PSR_xxx bits up by.  */

#define PSR_c   (1 << 0)
#define PSR_x   (1 << 1)
#define PSR_s   (1 << 2)
#define PSR_f   (1 << 3)
d354 9
a362 30
  {"CPSR",	true,  PSR_c | PSR_f},
  {"CPSR_all",	true,  PSR_c | PSR_f},
  {"SPSR",	false, PSR_c | PSR_f},
  {"SPSR_all",	false, PSR_c | PSR_f},
  {"CPSR_flg",	true,  PSR_f},
  {"CPSR_f",    true,  PSR_f},
  {"SPSR_flg",	false, PSR_f},
  {"SPSR_f",    false, PSR_f}, 
  {"CPSR_c",	true,  PSR_c},
  {"CPSR_ctl",	true,  PSR_c},
  {"SPSR_c",	false, PSR_c},
  {"SPSR_ctl",	false, PSR_c},
  {"CPSR_x",    true,  PSR_x},
  {"CPSR_s",    true,  PSR_s},
  {"SPSR_x",    false, PSR_x},
  {"SPSR_s",    false, PSR_s},
  /* For backwards compatability with older toolchain we also
     support lower case versions of some of these flags.  */
  {"cpsr",	true,  PSR_c | PSR_f},
  {"cpsr_all",	true,  PSR_c | PSR_f},
  {"spsr",	false, PSR_c | PSR_f},
  {"spsr_all",	false, PSR_c | PSR_f},
  {"cpsr_flg",	true,  PSR_f},
  {"cpsr_f",    true,  PSR_f},
  {"spsr_flg",	false, PSR_f},
  {"spsr_f",    false, PSR_f}, 
  {"cpsr_c",	true,  PSR_c},
  {"cpsr_ctl",	true,  PSR_c},
  {"spsr_c",	false, PSR_c},
  {"spsr_ctl",	false, PSR_c}
d365 1
a365 1
/* Functions called by parser.  */
d367 41
a407 77
static void do_arit		PARAMS ((char *, unsigned long));
static void do_cmp		PARAMS ((char *, unsigned long));
static void do_mov		PARAMS ((char *, unsigned long));
static void do_ldst		PARAMS ((char *, unsigned long));
static void do_ldmstm		PARAMS ((char *, unsigned long));
static void do_branch		PARAMS ((char *, unsigned long));
static void do_swi		PARAMS ((char *, unsigned long));
/* Pseudo Op codes */			       		      
static void do_adr		PARAMS ((char *, unsigned long));
static void do_adrl		PARAMS ((char *, unsigned long));
static void do_nop		PARAMS ((char *, unsigned long));
/* ARM 2 */				       		      
static void do_mul		PARAMS ((char *, unsigned long));
static void do_mla		PARAMS ((char *, unsigned long));
/* ARM 3 */				       		      
static void do_swap		PARAMS ((char *, unsigned long));
/* ARM 6 */				       		      
static void do_msr		PARAMS ((char *, unsigned long));
static void do_mrs		PARAMS ((char *, unsigned long));
/* ARM 7M */				       		      
static void do_mull		PARAMS ((char *, unsigned long));
/* ARM THUMB */				       		      
static void do_bx               PARAMS ((char *, unsigned long));

					       		      
/* Coprocessor Instructions */		       		      
static void do_cdp		PARAMS ((char *, unsigned long));
static void do_lstc		PARAMS ((char *, unsigned long));
static void do_co_reg		PARAMS ((char *, unsigned long));
static void do_fp_ctrl		PARAMS ((char *, unsigned long));
static void do_fp_ldst		PARAMS ((char *, unsigned long));
static void do_fp_ldmstm	PARAMS ((char *, unsigned long));
static void do_fp_dyadic	PARAMS ((char *, unsigned long));
static void do_fp_monadic	PARAMS ((char *, unsigned long));
static void do_fp_cmp		PARAMS ((char *, unsigned long));
static void do_fp_from_reg	PARAMS ((char *, unsigned long));
static void do_fp_to_reg	PARAMS ((char *, unsigned long));

static void fix_new_arm		PARAMS ((fragS *, int, short, expressionS *, int, int));
static int arm_reg_parse	PARAMS ((char **));
static CONST struct asm_psr * arm_psr_parse PARAMS ((char **));
static void symbol_locate	PARAMS ((symbolS *, CONST char *, segT, valueT, fragS *));
static int add_to_lit_pool	PARAMS ((void));
static unsigned validate_immediate PARAMS ((unsigned));
static unsigned validate_immediate_twopart PARAMS ((unsigned int, unsigned int *));
static int validate_offset_imm	PARAMS ((unsigned int, int));
static void opcode_select	PARAMS ((int));
static void end_of_line		PARAMS ((char *));
static int reg_required_here	PARAMS ((char **, int));
static int psr_required_here	PARAMS ((char **));
static int co_proc_number	PARAMS ((char **));
static int cp_opc_expr		PARAMS ((char **, int, int));
static int cp_reg_required_here	PARAMS ((char **, int));
static int fp_reg_required_here	PARAMS ((char **, int));
static int cp_address_offset	PARAMS ((char **));
static int cp_address_required_here	PARAMS ((char **));
static int my_get_float_expression	PARAMS ((char **));
static int skip_past_comma	PARAMS ((char **));
static int walk_no_bignums	PARAMS ((symbolS *));
static int negate_data_op	PARAMS ((unsigned long *, unsigned long));
static int data_op2		PARAMS ((char **));
static int fp_op2		PARAMS ((char **));
static long reg_list		PARAMS ((char **));
static void thumb_load_store	PARAMS ((char *, int, int));
static int decode_shift		PARAMS ((char **, int));
static int ldst_extend		PARAMS ((char **, int));
static void thumb_add_sub	PARAMS ((char *, int));
static void insert_reg		PARAMS ((int));
static void thumb_shift		PARAMS ((char *, int));
static void thumb_mov_compare	PARAMS ((char *, int));
static void set_constant_flonums	PARAMS ((void));
static valueT md_chars_to_number	PARAMS ((char *, int));
static void insert_reg_alias	PARAMS ((char *, int));
static void output_inst		PARAMS ((void));
#ifdef OBJ_ELF
static bfd_reloc_code_real_type	arm_parse_reloc PARAMS ((void));
#endif
d410 1
a410 1
   take 2:  */
d414 3
a416 1
   flags.  ARM7M has 4 of length 5.  */
a419 1

d422 6
a427 11
  CONST char *           template;	/* Basic string to match */
  unsigned long          value;		/* Basic instruction code */

  /* Compulsory suffix that must follow conds. If "", then the
     instruction is not conditional and must have no suffix. */
  CONST char *           comp_suffix;	

  CONST struct asm_flg * flags;	        /* Bits to toggle if flag 'n' set */
  unsigned long          variants;	/* Which CPU variants this exists for */
  /* Function to call to parse args */
  void (*                parms) PARAMS ((char *, unsigned long));
a453 4
#ifdef TE_WINCE
  {"bl",    0x0b000000, NULL,   NULL,        ARM_ANY,      do_branch},
  {"b",     0x0a000000, NULL,   NULL,        ARM_ANY,      do_branch},
#else
d456 1
a456 2
#endif
  
a458 1
  {"adrl",  0x028f0000, NULL,   NULL,        ARM_ANY,      do_adrl},
d470 1
a470 4
  {"msr",   0x0120f000, NULL,   NULL,        ARM_6UP,      do_msr},
/* ScottB: our code uses 0x0128f000 for msr.
   NickC:  but this is wrong because the bits 16 through 19 are
           handled by the PSR_xxx defines above.  */
d529 1
a529 1
/* Generic copressor instructions.  */
d537 2
a538 1
/* Defines for various bits that we will want to toggle.  */
d546 1
a546 1
#define LDM_TYPE_2_OR_3	0x00400000
d553 2
a554 1
/* Codes to distinguish the arithmetic instructions.  */
d572 21
a592 24
static void do_t_nop		PARAMS ((char *));
static void do_t_arit		PARAMS ((char *));
static void do_t_add		PARAMS ((char *));
static void do_t_asr		PARAMS ((char *));
static void do_t_branch9	PARAMS ((char *));
static void do_t_branch12	PARAMS ((char *));
static void do_t_branch23	PARAMS ((char *));
static void do_t_bx		PARAMS ((char *));
static void do_t_compare	PARAMS ((char *));
static void do_t_ldmstm		PARAMS ((char *));
static void do_t_ldr		PARAMS ((char *));
static void do_t_ldrb		PARAMS ((char *));
static void do_t_ldrh		PARAMS ((char *));
static void do_t_lds		PARAMS ((char *));
static void do_t_lsl		PARAMS ((char *));
static void do_t_lsr		PARAMS ((char *));
static void do_t_mov		PARAMS ((char *));
static void do_t_push_pop	PARAMS ((char *));
static void do_t_str		PARAMS ((char *));
static void do_t_strb		PARAMS ((char *));
static void do_t_strh		PARAMS ((char *));
static void do_t_sub		PARAMS ((char *));
static void do_t_swi		PARAMS ((char *));
static void do_t_adr		PARAMS ((char *));
d646 1
a646 1
static int thumb_reg		PARAMS ((char ** str, int hi_lo));
d648 1
a648 1
#define THUMB_SIZE	2	/* Size of thumb instruction.  */
d668 1
a668 1
/* These three are used for immediate shifts, do not alter.  */
d675 1
a675 1
  CONST char *  template;	/* Basic string to match */
d677 2
a678 3
  int           size;
  unsigned long          variants;    /* Which CPU variants this exists for */
  void (*       parms) PARAMS ((char *));  /* Function to call to parse args */
d683 54
a736 55
  {"adc",	0x4140,		2,	ARM_THUMB, do_t_arit},
  {"add",	0x0000,		2,	ARM_THUMB, do_t_add},
  {"and",	0x4000,		2,	ARM_THUMB, do_t_arit},
  {"asr",	0x0000,		2,	ARM_THUMB, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_THUMB, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_THUMB, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_THUMB, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_THUMB, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_THUMB, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_THUMB, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_THUMB, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_THUMB, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_THUMB, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_THUMB, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_THUMB, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_THUMB, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_THUMB, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_THUMB, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_THUMB, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_THUMB, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_THUMB, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_THUMB, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_THUMB, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_THUMB, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_THUMB, do_t_branch23},
  {"bx",	0x4700,		2,	ARM_THUMB, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_THUMB, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_THUMB, do_t_compare},
  {"eor",	0x4040,		2,	ARM_THUMB, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_THUMB, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_THUMB, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_THUMB, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_THUMB, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_THUMB, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_THUMB, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_THUMB, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_THUMB, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_THUMB, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_THUMB, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_THUMB, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_THUMB, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_THUMB, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_THUMB, do_t_arit},
  {"orr",	0x4300,		2,	ARM_THUMB, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_THUMB, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_THUMB, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_THUMB, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_THUMB, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_THUMB, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_THUMB, do_t_str},
  {"strb",	0x0000,		2,	ARM_THUMB, do_t_strb},
  {"strh",	0x0000,		2,	ARM_THUMB, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_THUMB, do_t_swi},
  {"sub",	0x0000,		2,	ARM_THUMB, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_THUMB, do_t_arit},
d738 2
a739 2
  {"adr",       0x0000,         2,      ARM_THUMB, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_THUMB, do_t_nop},      /* mov r8,r8 */
d744 2
a745 2
  CONST char * name;
  int          number;
d756 1
a756 1
/* These are the standard names.  Users can add aliases with .req  */
d759 1
a759 1
  /* Processor Register Numbers.  */
d764 1
a764 1
  /* APCS conventions.  */
d769 1
a769 3
  /* ATPCS additions to APCS conventions.  */
  {"wr", 7},    {"v8", 11},
  /* FP Registers.  */
a779 7
  /* ATPCS additions to float register names.  */
  {"s0",16},	{"s1",17},	{"s2",18},	{"s3",19},
  {"s4",20},	{"s5",21},	{"s6",22},	{"s7",23},
  {"d0",16},	{"d1",17},	{"d2",18},	{"d3",19},
  {"d4",20},	{"d5",21},	{"d6",22},	{"d7",23},
  /* FIXME: At some point we need to add VFP register names.  */
  /* Array terminator.  */
d783 9
a791 11
#define BAD_ARGS 	_("Bad arguments to instruction")
#define BAD_PC 		_("r15 not allowed here")
#define BAD_FLAGS 	_("Instruction should not have flags")
#define BAD_COND 	_("Instruction is not conditional")

static struct hash_control * arm_ops_hsh = NULL;
static struct hash_control * arm_tops_hsh = NULL;
static struct hash_control * arm_cond_hsh = NULL;
static struct hash_control * arm_shift_hsh = NULL;
static struct hash_control * arm_reg_hsh = NULL;
static struct hash_control * arm_psr_hsh = NULL;
d795 4
a798 3
     pseudo-op name without dot
     function to call to execute this pseudo-op
     Integer arg to pass to the function.  */
a807 9
static void s_force_thumb PARAMS ((int));
static void s_thumb_func PARAMS ((int));
static void s_thumb_set PARAMS ((int));
static void arm_s_text PARAMS ((int));
static void arm_s_data PARAMS ((int));
#ifdef OBJ_ELF
static void arm_s_section PARAMS ((int));
static void s_arm_elf_cons PARAMS ((int));
#endif
d813 14
a826 29
  { "req",         s_req,         0 },	/* Never called becasue '.req' does not start line */
  { "bss",         s_bss,         0 },
  { "align",       s_align,       0 },
  { "arm",         s_arm,         0 },
  { "thumb",       s_thumb,       0 },
  { "code",        s_code,        0 },
  { "force_thumb", s_force_thumb, 0 },
  { "thumb_func",  s_thumb_func,  0 },
  { "thumb_set",   s_thumb_set,   0 },
  { "even",        s_even,        0 },
  { "ltorg",       s_ltorg,       0 },
  { "pool",        s_ltorg,       0 },
  /* Allow for the effect of section changes.  */
  { "text",        arm_s_text,    0 },
  { "data",        arm_s_data,    0 },
#ifdef OBJ_ELF  
  { "section",     arm_s_section, 0 },
  { "section.s",   arm_s_section, 0 },
  { "sect",        arm_s_section, 0 },
  { "sect.s",      arm_s_section, 0 },
  { "word",        s_arm_elf_cons, 4 },
  { "long",        s_arm_elf_cons, 4 },
#else
  { "word",        cons, 4},
#endif
  { "extend",      float_cons, 'x' },
  { "ldouble",     float_cons, 'x' },
  { "packed",      float_cons, 'p' },
  { 0, 0, 0 }
d839 1
a839 2
symbolS *  last_label_seen;
static int label_is_thumb_function_name = false;
d848 1
a848 1
  struct arm_it *     inst;
d851 5
a855 4
literalT  literals[MAX_LITERAL_POOL_SIZE];
int       next_literal_pool_place = 0; /* Next free entry in the pool */
int       lit_pool_num = 1; /* Next literal pool number */
symbolS * current_poolP = NULL;
d863 1
a863 2
    current_poolP = symbol_create (FAKE_LABEL_NAME, undefined_section,
				   (valueT) 0, &zero_address_frag);
d865 1
a865 1
  /* Check if this literal value is already in the pool:  */
d870 1
a870 2
          && literals[lit_count].exp.X_add_number
	     == inst.reloc.exp.X_add_number
d880 1
a880 1
          inst.error = _("Literal Pool Overflow");
d889 1
a889 1
  inst.reloc.exp.X_add_number = (lit_count) * 4 - 8;
d895 2
a896 2
/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */
d899 5
a903 5
     symbolS *    symbolP; 
     CONST char * name;		/* It is copied, the caller can modify */
     segT         segment;	/* Segment identifier (SEG_<something>) */
     valueT       valu;		/* Symbol value */
     fragS *      frag;		/* Associated fragment */
d906 1
a906 1
  char * preserved_copy_of_name;
d927 1
a927 1
  symbol_set_frag (symbolP, frag);
d929 3
a931 1
  /* Link to end of symbol chain.  */
d938 1
a938 1
  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);
d947 1
a947 1
  verify_symbol_chain (symbol_rootP, symbol_lastP);
d951 2
a952 5
/* Check that an immediate is valid, and if so,
   convert it to the right format.  */
static unsigned int
validate_immediate (val)
     unsigned int val;
d954 14
a967 10
  unsigned int a;
  unsigned int i;
  
#define rotate_left(v, n) (v << n | v >> (32 - n))
  
  for (i = 0; i < 32; i += 2)
    if ((a = rotate_left (val, i)) <= 0xff)
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const] */
  
  return FAIL;
d969 5
d975 3
a977 7
/* Check to see if an immediate can be computed as two seperate immediate
   values, added together.  We already know that this value cannot be
   computed by just one ARM instruction.  */
static unsigned int
validate_immediate_twopart (val, highpart)
     unsigned int val;
     unsigned int * highpart;
d979 2
a980 2
  unsigned int a;
  unsigned int i;
d982 6
a987 19
  for (i = 0; i < 32; i += 2)
    if (((a = rotate_left (val, i)) & 0xff) != 0)
      {
	if (a & 0xff00)
	  {
	    if (a & ~ 0xffff)
	      continue;
	    * highpart = (a  >> 8) | ((i + 24) << 7);
	  }
	else if (a & 0xff0000)
	  {
	    if (a & 0xff000000)
	      continue;

	    * highpart = (a >> 16) | ((i + 16) << 7);
	  }
	else
	  {
	    assert (a & 0xff000000);
d989 9
a997 6
	    * highpart = (a >> 24) | ((i + 8) << 7);
	  }

	return (a & 0xff) | (i << 7);
      }
  
d1003 1
a1003 1
     unsigned int val;
d1006 2
a1007 1
  if ((hwse && val > 255) || val > 4095)
d1015 1
a1015 1
     int a ATTRIBUTE_UNUSED;
d1017 1
a1017 1
  as_bad (_("Invalid syntax for .req directive."));
d1022 1
a1022 1
     int ignore ATTRIBUTE_UNUSED;
d1032 1
a1032 1
     int ignore ATTRIBUTE_UNUSED;
a1035 1
  
a1036 1
  
d1041 2
a1042 2
s_ltorg (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1048 6
a1053 1
    return;
d1062 3
a1070 6
  ARM_SET_THUMB (current_poolP, thumb_mode);
  
#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (current_poolP, support_interwork);
#endif
  
d1072 1
a1072 1
    /* First output the expression in the instruction to the pool.  */
d1079 14
d1095 1
a1095 1
     int unused ATTRIBUTE_UNUSED;
d1103 1
a1103 1
    as_bad (_("Alignment too large: %d. assumed."), temp = max_alignment);
d1106 1
a1106 1
      as_bad (_("Alignment negative. 0 assumed."));
a1129 171
s_force_thumb (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* If we are not already in thumb mode go into it, EVEN if
     the target processor does not support thumb instructions.
     This is used by gcc/config/arm/lib1funcs.asm for example
     to compile interworking support functions even if the
     target processor should not support interworking.  */
     
  if (! thumb_mode)
    {
      thumb_mode = 2;
      
      record_alignment (now_seg, 1);
    }
  
  demand_empty_rest_of_line ();
}

static void
s_thumb_func (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* The following label is the name/address of the start of a Thumb function.
     We need to know this for the interworking support.  */

  label_is_thumb_function_name = true;
  
  demand_empty_rest_of_line ();
}

/* Perform a .set directive, but also mark the alias as
   being a thumb function.  */

static void
s_thumb_set (equiv)
     int equiv;
{
  /* XXX the following is a duplicate of the code for s_set() in read.c
     We cannot just call that code as we need to get at the symbol that
     is created.  */
  register char *    name;
  register char      delim;
  register char *    end_name;
  register symbolS * symbolP;

  /*
   * Especial apologies for the random logic:
   * this just grew, and could be parsed much more simply!
   * Dean in haste.
   */
  name      = input_line_pointer;
  delim     = get_symbol_end ();
  end_name  = input_line_pointer;
  *end_name = delim;
  
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      *end_name = 0;
      as_bad (_("Expected comma after name \"%s\""), name);
      *end_name = delim;
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;
  *end_name = 0;

  if (name[0] == '.' && name[1] == '\0')
    {
      /* XXX - this should not happen to .thumb_set  */
      abort ();
    }

  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
         for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct * listing_tail;
	  fragS * dummy_frag = (fragS *) xmalloc (sizeof(fragS));
	  memset (dummy_frag, 0, sizeof(fragS));
	  dummy_frag->fr_type = rs_fill;
	  dummy_frag->line = listing_tail;
	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
	  dummy_frag->fr_symbol = symbolP;
	}
      else
#endif
        symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
			    
#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified. */
      SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF */
    }				/* make a new symbol */

  symbol_table_insert (symbolP);

  * end_name = delim;

  if (equiv
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));

  pseudo_set (symbolP);
  
  demand_empty_rest_of_line ();

  /* XXX Now we come to the Thumb specific bit of code.  */
  
  THUMB_SET_FUNC (symbolP, 1);
  ARM_SET_THUMB (symbolP, 1);
#if defined OBJ_ELF || defined OBJ_COFF
  ARM_SET_INTERWORK (symbolP, support_interwork);
#endif
}

/* If we change section we must dump the literal pool first.  */
static void
arm_s_text (ignore)
     int ignore;
{
  if (now_seg != text_section)
    s_ltorg (0);
  
#ifdef OBJ_ELF
  obj_elf_text (ignore);
#else
  s_text (ignore);
#endif
}

static void
arm_s_data (ignore)
     int ignore;
{
  if (flag_readonly_data_in_text)
    {
      if (now_seg != text_section)
	s_ltorg (0);
    }
  else if (now_seg != data_section)
    s_ltorg (0);
  
#ifdef OBJ_ELF
  obj_elf_data (ignore);
#else
  s_data (ignore);
#endif
}

#ifdef OBJ_ELF
static void
arm_s_section (ignore)
     int ignore;
{
  s_ltorg (0);

  obj_elf_section (ignore);
}
#endif

static void
d1139 1
a1139 1
	    as_bad (_("selected processor does not support THUMB opcodes"));
d1151 1
a1151 1
	    as_bad (_("selected processor does not support ARM opcodes"));
d1160 1
a1160 1
      as_bad (_("invalid instruction size selected (%d)"), width);
d1166 1
a1166 1
     int ignore ATTRIBUTE_UNUSED;
d1174 1
a1174 1
     int ignore ATTRIBUTE_UNUSED;
d1182 1
a1182 1
     int unused ATTRIBUTE_UNUSED;
d1191 1
a1191 1
      opcode_select (temp);
d1195 1
a1195 1
      as_bad (_("invalid operand to .code directive (%d) (expecting 16 or 32)"), temp);
d1201 1
a1201 1
     char * str;
d1203 2
a1204 1
  skip_whitespace (str);
d1206 2
a1207 2
  if (* str != '\0')
    inst.error = _("Garbage following instruction");
d1212 1
a1212 1
     char ** str;
d1231 3
a1233 4
/* A standard register must be given at this point.
   Shift is the place to put it in inst.instruction.
   Restores input start point on err.
   Returns the reg#, or FAIL.  */
d1236 2
a1237 2
     char ** str;
     int     shift;
d1239 2
a1240 3
  static char buff [128]; /* XXX */
  int    reg;
  char * start = *str;
d1244 1
a1244 2
      if (shift >= 0)
	inst.instruction |= reg << shift;
d1248 4
a1253 6
  
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  sprintf (buff, _("Register expected, not '%.100s'"), start);
  inst.error = buff;

d1257 13
a1269 15
static CONST struct asm_psr *
arm_psr_parse (ccp)
     register char ** ccp;
{
  char * start = * ccp;
  char   c;
  char * p;
  CONST struct asm_psr * psr;

  p = start;

  /* Skip to the end of the next word in the input stream.  */
  do
    {
      c = *p++;
a1270 1
  while (isalpha (c) || c == '_');
d1272 3
a1274 2
  /* Terminate the word.  */
  *--p = 0;
d1276 3
a1278 11
  /* Now locate the word in the psr hash table.  */
  psr = (CONST struct asm_psr *) hash_find (arm_psr_hsh, start);

  /* Restore the input stream.  */
  *p = c;

  /* If we found a valid match, advance the
     stream pointer past the end of the word.  */
  *ccp = p;

  return psr;
a1280 1
/* Parse the input looking for a PSR flag.  */
d1282 12
a1293 18
psr_required_here (str)
     char ** str;
{
  char * start = *str;
  CONST struct asm_psr * psr;
  
  psr = arm_psr_parse (str);

  if (psr)
    {
      /* If this is the SPSR that is being modified, set the R bit.  */
      if (! psr->cpsr)
	inst.instruction |= SPSR_BIT;

      /* Set the psr flags in the MSR instruction.  */
      inst.instruction |= psr->field << PSR_SHIFT;
      
      return SUCCESS;
d1296 3
a1298 3
  /* In the few cases where we might be able to accept
     something else this error can be overridden.  */
  inst.error = _("flag for {c}psr instruction expected");
d1307 1
a1307 1
     char ** str;
d1311 2
a1312 1
  skip_whitespace (* str);
d1329 1
a1329 1
	      inst.error = _("Illegal co-processor number");
d1336 1
a1336 1
      inst.error = _("Bad or missing co-processor number");
d1346 1
a1346 1
     char ** str;
d1352 2
a1353 1
  skip_whitespace (* str);
d1361 1
a1361 1
      inst.error = _("bad or missing expression");
d1367 1
a1367 1
      inst.error = _("immediate co-processor expression too large");
d1377 2
a1378 2
     char ** str;
     int     where;
d1380 2
a1381 2
  int    reg;
  char * start = *str;
d1391 2
a1392 2
     this error can be overridden.  */
  inst.error = _("Co-processor register expected");
d1394 1
a1394 1
  /* Restore the start point.  */
d1401 2
a1402 2
     char ** str;
     int     where;
d1405 1
a1405 1
  char * start = *str;
d1415 2
a1416 2
     this error can be overridden.  */
  inst.error = _("Floating point register expected");
d1418 1
a1418 1
  /* Restore the start point.  */
d1425 1
a1425 1
     char ** str;
d1429 2
a1430 1
  skip_whitespace (* str);
d1432 1
a1432 1
  if (! is_immediate_prefix (**str))
d1434 1
a1434 1
      inst.error = _("immediate expression expected");
d1439 1
a1439 2
  
  if (my_get_expression (& inst.reloc.exp, str))
a1440 1
  
a1443 1
      
d1446 1
a1446 1
	  inst.error = _("co-processor address must be word aligned");
d1452 1
a1452 1
	  inst.error = _("offset too large");
d1471 1
a1471 1
     char ** str;
d1473 3
a1475 3
  char * p = * str;
  int    pre_inc = 0;
  int    write_back = 0;
d1482 2
a1483 1
      skip_whitespace (p);
d1485 5
a1489 2
      if ((reg = reg_required_here (& p, 16)) == FAIL)
	return FAIL;
d1491 2
a1492 1
      skip_whitespace (p);
d1497 1
a1497 2
	  
	  if (skip_past_comma (& p) == SUCCESS)
a1500 1
	      
d1503 1
a1503 1
		  inst.error = _("pc may not be used in post-increment");
d1507 1
a1507 1
	      if (cp_address_offset (& p) == FAIL)
d1517 1
a1517 1
	  if (skip_past_comma (& p) == FAIL)
d1519 1
a1519 1
	      inst.error = _("pre-indexed expression expected");
d1524 1
a1524 2
	  
	  if (cp_address_offset (& p) == FAIL)
d1527 2
a1528 1
	  skip_whitespace (p);
d1532 1
a1532 1
	      inst.error = _("missing ]");
d1536 2
a1537 1
	  skip_whitespace (p);
d1543 1
a1543 1
		  inst.error = _("pc may not be used with write-back");
d1571 1
a1571 1
     char * str;
d1574 2
a1575 2
  /* Do nothing really.  */
  inst.instruction |= flags; /* This is pointless.  */
d1585 3
a1587 4
  int skip = 0;
  
  /* Only one syntax.  */
  skip_whitespace (str);
d1591 1
a1591 1
      inst.error = BAD_ARGS;
d1595 2
a1596 1
  if (skip_past_comma (&str) == FAIL)
d1598 1
a1598 1
      inst.error = _("comma expected after register name");
a1601 22
  skip_whitespace (str);

  if (   strcmp (str, "CPSR") == 0
      || strcmp (str, "SPSR") == 0
	 /* Lower case versions for backwards compatability.  */
      || strcmp (str, "cpsr") == 0
      || strcmp (str, "spsr") == 0)
    skip = 4;
  /* This is for backwards compatability with older toolchains.  */
  else if (strcmp (str, "cpsr_all") == 0
	   || strcmp (str, "spsr_all") == 0)
    skip = 7;
  else
    {
      inst.error = _("{C|S}PSR expected");
      return;
    }

  if (* str == 's' || * str == 'S')
    inst.instruction |= SPSR_BIT;
  str += skip;
  
d1604 1
a1606 3
/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */
d1609 1
a1609 1
     char * str;
d1612 2
a1613 1
  skip_whitespace (str);
d1615 2
a1616 10
  if (psr_required_here (& str) == FAIL)
    return;
    
  if (skip_past_comma (& str) == FAIL)
    {
      inst.error = _("comma missing after psr flags");
      return;
    }

  skip_whitespace (str);
d1618 1
a1618 1
  if (reg_required_here (& str, 0) != FAIL)
d1620 8
a1627 4
      inst.error = NULL; 
      inst.instruction |= flags;
      end_of_line (str);
      return;
d1629 2
a1630 2

  if (! is_immediate_prefix (* str))
d1632 1
a1632 31
      inst.error = _("only a register or immediate value can follow a psr flag");
      return;
    }

  str ++;
  inst.error = NULL;
  
  if (my_get_expression (& inst.reloc.exp, & str))
    {
      inst.error = _("only a register or immediate value can follow a psr flag");
      return;
    }
  
  if (inst.instruction & ((PSR_c | PSR_x | PSR_s) << PSR_SHIFT))
    {
      inst.error = _("can only set flag field with immediate value");
      return;
    }
  
  flags |= INST_IMMEDIATE;
	  
  if (inst.reloc.exp.X_add_symbol)
    {
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
    }
  else
    {
      unsigned value = validate_immediate (inst.reloc.exp.X_add_number);
      
      if (value == (unsigned) FAIL)
d1634 1
a1634 1
	  inst.error = _("Invalid constant");
d1637 41
a1677 2
      
      inst.instruction |= value;
d1679 1
a1679 1

d1683 1
d1694 1
a1694 1
     char * str;
d1699 3
a1701 2
  /* Only one format "rdlo, rdhi, rm, rs" */
  skip_whitespace (str);
d1705 1
a1705 1
      inst.error = BAD_ARGS;
d1712 1
a1712 1
      inst.error = BAD_ARGS;
d1719 1
a1719 1
      inst.error = BAD_ARGS;
d1725 1
a1725 1
    as_tsktsk (_("rdhi, rdlo and rm must all be different"));
d1730 1
a1730 1
      inst.error = BAD_ARGS;
d1736 1
a1736 1
      inst.error = BAD_PC;
d1747 1
a1747 1
     char *        str;
d1752 3
a1754 2
  /* Only one format "rd, rm, rs" */
  skip_whitespace (str);
d1758 1
a1758 1
      inst.error = BAD_ARGS;
d1764 1
a1764 1
      inst.error = BAD_PC;
d1771 1
a1771 1
      inst.error = BAD_ARGS;
d1777 1
a1777 1
      inst.error = BAD_PC;
d1782 1
a1782 1
    as_tsktsk (_("rd and rm should be different in mul"));
d1787 1
a1787 1
      inst.error = BAD_ARGS;
d1793 1
a1793 1
      inst.error = BAD_PC;
d1804 1
a1804 1
     char *        str;
d1809 3
a1811 2
  /* Only one format "rd, rm, rs, rn" */
  skip_whitespace (str);
d1815 1
a1815 1
      inst.error = BAD_ARGS;
d1821 1
a1821 1
      inst.error = BAD_PC;
d1828 1
a1828 1
      inst.error = BAD_ARGS;
d1834 1
a1834 1
      inst.error = BAD_PC;
d1839 1
a1839 1
    as_tsktsk (_("rd and rm should be different in mla"));
d1846 1
a1846 1
      inst.error = BAD_ARGS;
d1852 1
a1852 1
      inst.error = BAD_PC;
d1865 1
a1865 1
     char ** str;
d1868 3
a1870 4
  char *         save_in;
  expressionS    exp;
  int            i;
  int            j;
d1931 1
a1931 1
     symbolS * sp;
d1933 1
a1933 1
  if (symbol_get_value_expression (sp)->X_op == O_big)
d1936 1
a1936 1
  if (symbol_get_value_expression (sp)->X_add_symbol)
d1938 3
a1940 3
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
d1948 2
a1949 2
     expressionS * ep;
     char ** str;
d1951 2
a1952 2
  char * save_in;
  segT   seg;
d1965 1
a1965 1
      inst.error = _("bad_segment");
d1981 1
a1981 1
      inst.error = _("Invalid constant");
d1997 2
a1998 2
     char ** str;
     int     unrestrict;
d2000 3
a2002 3
  struct asm_shift * shft;
  char * p;
  char   c;
d2004 2
a2005 1
  skip_whitespace (* str);
d2012 1
a2012 1
      inst.error = _("Shift expression expected");
d2022 2
a2023 2
      if (!strncmp (*str, "rrx", 3)
          || !strncmp (*str, "RRX", 3))
d2030 3
a2032 2
      skip_whitespace (p);
      
d2039 1
a2039 1
      else if (is_immediate_prefix (* p))
d2054 1
a2054 1
		  inst.error = _("Invalid immediate shift");
d2083 2
a2084 2
	  inst.error = unrestrict ? _("shift requires register or #expression")
	    : _("shift requires #expression");
d2090 1
a2090 1
  inst.error = _("Shift expression expected");
d2106 2
a2107 2
     unsigned long * instruction;
     unsigned long   value;
d2175 1
a2175 1
  if (value == (unsigned) FAIL)
d2185 1
a2185 1
     char ** str;
d2190 2
a2191 1
  skip_whitespace (* str);
d2196 4
a2199 3
	/* Shift operation on register.  */
	return decode_shift (str, NO_SHIFT_RESTRICT);

d2205 1
a2205 1
      if (is_immediate_prefix (**str))
a2206 1
	  (*str)++;
a2207 1
	  
d2226 1
a2226 1
		      inst.error = _("Constant expression expected");
d2235 1
a2235 1
		      inst.error = _("Invalid constant");
d2255 1
a2255 1
		      inst.error = _("Invalid constant");
d2267 1
a2267 2
      (*str)++;
      inst.error = _("Register or shift expression expected");
d2273 3
a2275 2
fp_op2 (str)
     char ** str;
d2277 2
a2278 1
  skip_whitespace (* str);
d2290 2
a2291 2

	  skip_whitespace (* str);
d2322 1
a2322 1
	  inst.error = _("Invalid floating point immediate expression");
d2325 1
a2325 1
      inst.error = _("Floating point register or immediate expression expected");
d2332 1
a2332 1
     char *        str;
d2335 2
a2336 1
  skip_whitespace (str);
d2345 1
a2345 1
	inst.error = BAD_ARGS;
d2356 1
a2356 1
     char *        str;
d2360 4
a2363 2
     into a relative address of the form "add rd, pc, #label-.-8".  */
  skip_whitespace (str);
d2370 1
a2370 1
	inst.error = BAD_ARGS;
a2372 1
  
d2376 1
a2376 1
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
a2383 34
do_adrl (str, flags)
     char *        str;
     unsigned long flags;
{
  /* This is a pseudo-op of the form "adrl rd, label" to be converted
     into a relative address of the form:
     	add rd, pc, #low(label-.-8)"
     	add rd, rd, #high(label-.-8)"   */

  skip_whitespace (str);

  if (reg_required_here (& str, 12) == FAIL
      || skip_past_comma (& str) == FAIL
      || my_get_expression (& inst.reloc.exp, & str))
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
  
  end_of_line (str);
  
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type              = BFD_RELOC_ARM_ADRL_IMMEDIATE;
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust */
  inst.reloc.pc_rel            = 1;
  inst.instruction            |= flags;
  inst.size                    = INSN_SIZE * 2;
  
  return;
}

static void
d2385 1
a2385 1
     char *        str;
d2388 2
a2389 1
  skip_whitespace (str);
d2394 1
a2394 1
	inst.error = BAD_ARGS;
d2402 1
a2402 1
	inst.error = BAD_ARGS;
d2416 1
a2416 1
     char *        str;
d2419 2
a2420 1
  skip_whitespace (str);
d2425 1
a2425 1
	inst.error = BAD_ARGS;
d2433 1
a2433 1
	inst.error = BAD_ARGS;
d2444 2
a2445 2
     char ** str;
     int     hwse;
a2451 1
    case '$':
d2453 1
a2453 1
      if (my_get_expression (& inst.reloc.exp, str))
d2463 1
a2463 1
	      inst.error = _("address offset too large");
d2476 1
a2476 1
            inst.instruction |= add | HWOFFSET_IMM | ((value >> 4) << 8) | (value & 0xF);
d2499 4
a2502 1
	return FAIL;
d2519 1
a2519 1
     char *        str;
d2530 1
a2530 2
  halfword = (flags & 0x80000000) != 0;
  if (halfword)
d2534 1
a2534 1
      if ((cpu_variant & ARM_HALFWORD) == 0)
d2537 1
a2537 1
	    = _("Processor does not support halfwords or signed bytes");
d2547 2
a2548 1
  skip_whitespace (str);
d2550 1
a2550 1
  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
d2553 1
a2553 1
	inst.error = BAD_ARGS;
d2557 1
a2557 1
  if (skip_past_comma (& str) == FAIL)
d2559 1
a2559 1
      inst.error = _("Address expected");
d2568 2
a2569 2

      skip_whitespace (str);
d2572 4
a2575 1
	return;
d2577 3
a2579 2
      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);
d2581 2
a2582 1
      skip_whitespace (str);
d2586 1
a2586 2
	  str ++;
	  
d2593 1
a2593 2
		as_warn (_("%s register same as write-back base"),
			 (inst.instruction & LOAD_BIT) ? _("destination") : _("source") );
d2601 2
a2602 1
              skip_whitespace (str);
d2607 1
a2607 2
		   as_warn (_("%s register same as write-back base"),
			    (inst.instruction & LOAD_BIT) ? _("destination") : _("source") );
d2622 1
a2622 1
	      inst.error = _("pre-indexed expression expected");
d2630 2
a2631 1
	  skip_whitespace (str);
d2635 1
a2635 1
	      inst.error = _("missing ]");
d2639 2
a2640 1
	  skip_whitespace (str);
d2645 1
a2645 2
		as_warn (_("%s register same as write-back base"),
			 (inst.instruction & LOAD_BIT) ? _("destination") : _("source") );
d2656 2
a2657 1
      skip_whitespace (str);
d2665 1
a2665 1
	  inst.error = _("Constant expression expected");
d2685 1
a2685 1
		inst.error = _("literal pool insertion failed"); 
a2713 1
#ifndef TE_WINCE
a2714 1
#endif
d2721 1
a2721 1
    inst.error = _("Pre-increment instruction with translate");
d2730 1
a2730 1
     char ** strp;
d2732 3
a2734 3
  char * str = *strp;
  long   range = 0;
  int    another_range;
d2751 8
a2758 1
	      skip_whitespace (str);
a2759 3
	      if ((reg = reg_required_here (& str, -1)) == FAIL)
		return FAIL;
	      
d2766 1
a2766 1
		      inst.error = _("Bad range in register list");
d2774 1
a2774 1
			  (_("Warning: Duplicated register (r%d) in register list"),
d2783 1
a2783 1
		as_tsktsk (_("Warning: Duplicated register (r%d) in register list"),
d2786 1
a2786 1
		as_tsktsk (_("Warning: Register range not in ascending order"));
d2793 2
a2794 1
	  skip_whitespace (str);
d2798 1
a2798 1
	      inst.error = _("Missing `}'");
d2814 1
a2814 1
		  inst.error = _("invalid register mask");
d2825 1
a2825 1
		    (_("Warning: Duplicated register (r%d) in register list"),
d2835 1
a2835 1
		  inst.error = _("expression too complex");
d2845 2
a2846 1
      skip_whitespace (str);
d2861 1
a2861 1
     char *        str;
d2867 2
a2868 1
  skip_whitespace (str);
d2871 5
a2875 1
    return;
d2879 1
a2879 1
      inst.error = _("r15 not allowed as base register");
d2883 2
a2884 2
  skip_whitespace (str);

d2895 1
a2895 1
	inst.error = BAD_ARGS;
d2902 1
a2902 1
      flags |= LDM_TYPE_2_OR_3;
d2912 1
a2912 1
     char *        str;
a2914 2
  skip_whitespace (str);
  
d2916 3
a2918 1
  if (is_immediate_prefix (*str))
d2921 1
a2921 1
  if (my_get_expression (& inst.reloc.exp, & str))
a2926 1
  
a2927 1
  
d2933 1
a2933 1
     char *        str;
d2938 2
a2939 1
  skip_whitespace (str);
d2946 1
a2946 1
      inst.error = _("r15 not allowed in swap");
d2954 1
a2954 1
	inst.error = BAD_ARGS;
d2960 1
a2960 1
      inst.error = _("r15 not allowed in swap");
d2967 1
a2967 1
      inst.error = BAD_ARGS;
d2971 2
a2972 1
  skip_whitespace (str);
d2979 1
a2979 1
      inst.error = BAD_PC;
d2983 2
a2984 1
  skip_whitespace (str);
d2988 1
a2988 1
      inst.error = _("missing ]");
d2999 2
a3000 2
     char *        str;
     unsigned long flags ATTRIBUTE_UNUSED;
d3004 1
a3004 32
  
#ifdef OBJ_ELF
  {
    char * save_in;
  
    /* ScottB: February 5, 1998 */
    /* Check to see of PLT32 reloc required for the instruction.  */
    
    /* arm_parse_reloc() works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;
    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
	inst.reloc.pc_rel = 1;
      }
    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
a3005 2
#endif /* OBJ_ELF */
  
d3012 2
a3013 2
     char *        str;
     unsigned long flags ATTRIBUTE_UNUSED;
d3017 2
a3018 1
  skip_whitespace (str);
d3021 1
a3021 4
    {
      inst.error = BAD_ARGS;
      return;
    }
d3024 1
a3024 1
    inst.error = BAD_PC;
d3027 1
d3032 2
a3033 2
     char *        str;
     unsigned long flags ATTRIBUTE_UNUSED;
d3037 2
a3038 1
  skip_whitespace (str);
d3043 1
a3043 1
	inst.error = BAD_ARGS;
d3051 1
a3051 1
	inst.error = BAD_ARGS;
d3059 1
a3059 1
	inst.error = BAD_ARGS;
d3067 1
a3067 1
	inst.error = BAD_ARGS;
d3075 1
a3075 1
	inst.error = BAD_ARGS;
d3084 1
a3084 1
	    inst.error = BAD_ARGS;
d3095 1
a3095 1
     char *        str;
d3101 2
a3102 1
  skip_whitespace (str);
d3107 1
a3107 1
	inst.error = BAD_ARGS;
d3115 1
a3115 1
	inst.error = BAD_ARGS;
d3123 1
a3123 1
	inst.error = BAD_ARGS;
d3134 1
a3134 1
     char *        str;
d3140 2
a3141 1
  skip_whitespace (str);
d3146 1
a3146 1
	inst.error = BAD_ARGS;
d3154 1
a3154 1
	inst.error = BAD_ARGS;
d3162 1
a3162 1
	inst.error = BAD_ARGS;
d3170 1
a3170 1
	inst.error = BAD_ARGS;
d3178 1
a3178 1
	inst.error = BAD_ARGS;
d3187 1
a3187 1
	    inst.error = BAD_ARGS;
a3190 4
  if (flags)
    {
      inst.error = BAD_COND;
    }
d3198 2
a3199 2
     char *        str;
     unsigned long flags ATTRIBUTE_UNUSED;
d3204 2
a3205 1
  skip_whitespace (str);
d3210 1
a3210 1
	inst.error = BAD_ARGS;
d3220 2
a3221 2
     char *        str;
     unsigned long flags ATTRIBUTE_UNUSED;
d3223 2
a3224 1
  skip_whitespace (str);
d3246 1
a3246 1
	inst.error = BAD_ARGS;
d3254 1
a3254 1
	inst.error = BAD_ARGS;
d3263 1
a3263 1
     char *        str;
d3268 2
a3269 1
  skip_whitespace (str);
d3274 1
a3274 1
	inst.error = BAD_ARGS;
d3283 1
a3283 1
	inst.error = _("constant expression expected");
d3289 1
a3289 1
      inst.error = _("Constant value required for number of registers");
d3297 1
a3297 1
      inst.error = _("number of registers must be in the range [1:4]");
d3332 1
a3332 1
	    inst.error = BAD_ARGS;
d3337 2
a3338 1
      skip_whitespace (str);
d3341 4
a3344 1
	return;
d3346 2
a3347 1
      skip_whitespace (str);
d3351 1
a3351 1
	  inst.error = BAD_ARGS;
d3362 1
a3362 1
	      inst.error = _("R15 not allowed as base register with write-back");
d3399 1
a3399 1
	inst.error = BAD_ARGS;
d3408 1
a3408 1
     char *        str;
d3411 2
a3412 1
  skip_whitespace (str);
d3431 1
a3431 1
	inst.error = BAD_ARGS;
d3439 1
a3439 1
	inst.error = BAD_ARGS;
d3447 1
a3447 1
	inst.error = BAD_ARGS;
d3458 1
a3458 1
     char *        str;
d3461 2
a3462 1
  skip_whitespace (str);
d3481 1
a3481 1
	inst.error = BAD_ARGS;
d3489 1
a3489 1
	inst.error = BAD_ARGS;
d3500 1
a3500 1
     char *        str;
d3503 2
a3504 1
  skip_whitespace (str);
d3509 1
a3509 1
	inst.error = BAD_ARGS;
d3517 1
a3517 1
	inst.error = BAD_ARGS;
d3528 1
a3528 1
     char *        str;
d3531 2
a3532 1
  skip_whitespace (str);
d3551 1
a3551 1
	inst.error = BAD_ARGS;
d3559 1
a3559 1
	inst.error = BAD_ARGS;
d3570 1
a3570 1
     char *        str;
d3573 2
a3574 1
  skip_whitespace (str);
d3577 5
a3581 1
    return;
d3587 1
a3587 1
	inst.error = BAD_ARGS;
d3605 2
a3606 2
     char ** strp;
     int     hi_lo;
d3610 5
a3614 2
  if ((reg = reg_required_here (strp, -1)) == FAIL)
    return FAIL;
d3621 1
a3621 1
	  inst.error = _("lo register required");
d3629 1
a3629 1
	  inst.error = _("hi register required");
d3645 2
a3646 2
     char * str;
     int    subtract;
d3650 2
a3651 1
  skip_whitespace (str);
d3657 1
a3657 1
	inst.error = BAD_ARGS;
d3661 1
a3661 1
  if (is_immediate_prefix (*str))
d3680 1
a3680 1
      else if (is_immediate_prefix (*str))
d3695 1
a3695 1
      if (Rd > 7 || Rs > 7 || Rn > 7)
d3699 1
a3699 1
	      inst.error = _("dest and source1 must be the same register");
d3706 1
a3706 1
	      inst.error = _("subtract valid only on lo regs");
d3730 1
a3730 1
	  inst.error = _("invalid Hi register with immediate");
d3757 1
a3757 1
		  inst.error = _("immediate value out of range");
d3768 1
a3768 1
		  inst.error = _("invalid immediate value for stack adjust");
d3779 1
a3779 1
		  inst.error = _("invalid immediate for address calculation");
d3790 1
a3790 1
		  inst.error = _("immediate value out of range");
d3800 1
a3800 1
		  inst.error = _("immediate value out of range");
a3807 1
  
d3813 2
a3814 2
     char * str;
     int    shift;
d3818 2
a3819 1
  skip_whitespace (str);
d3825 1
a3825 1
	inst.error = BAD_ARGS;
d3829 1
a3829 1
  if (is_immediate_prefix (*str))
d3833 1
a3833 1
      str ++;
d3849 1
a3849 1
      else if (is_immediate_prefix (*str))
d3866 1
a3866 1
	  inst.error = _("source1 and dest must be same register");
d3901 1
a3901 1
	      inst.error = _("Invalid immediate for shift");
a3917 1
  
d3923 2
a3924 2
     char * str;
     int    move;
d3928 2
a3929 1
  skip_whitespace (str);
d3935 1
a3935 1
	inst.error = BAD_ARGS;
d3939 1
a3939 1
  if (is_immediate_prefix (*str))
d3953 2
a3954 2
	    /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	       since a MOV instruction produces unpredictable results */
d3980 1
a3980 1
	  inst.error = _("only lo regs allowed with immediate");
d3999 1
a3999 1
	      inst.error = _("invalid immediate");
d4012 3
a4014 3
     char * str;
     int    load_store;
     int    size;
d4018 2
a4019 1
  skip_whitespace (str);
d4025 1
a4025 1
	inst.error = BAD_ARGS;
d4037 1
a4037 1
	  if (is_immediate_prefix (*str))
d4054 1
a4054 1
	  inst.error = _("expected ']'");
d4061 1
a4061 41
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op */
      str++;

      skip_whitespace (str);

      if (my_get_expression (& inst.reloc.exp, & str))
	return;

      end_of_line (str);
      
      if (   inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = "Constant expression expected";
	  return;
	}

      if (inst.reloc.exp.X_op == O_constant
	  && ((inst.reloc.exp.X_add_number & ~0xFF) == 0))
	{
	  /* This can be done with a mov instruction */

	  inst.instruction  = T_OPCODE_MOV_I8 | (Rd << 8);
	  inst.instruction |= inst.reloc.exp.X_add_number;
	  return; 
	}

      /* Insert into literal pool */     
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = "literal pool insertion failed"; 
	  return;
	}

      inst.reloc.type   = BFD_RELOC_ARM_THUMB_OFFSET;
      inst.reloc.pc_rel = 1;
      inst.instruction  = T_OPCODE_LDR_PC | (Rd << 8);
      inst.reloc.exp.X_add_number += 4; /* Adjust ARM pipeline offset to Thumb */

      return;
d4080 1
a4080 1
	  inst.error = _("byte or halfword not valid for base register");
d4085 1
a4085 1
	  inst.error = _("R15 based store not allowed");
d4090 1
a4090 1
	  inst.error = _("Invalid base register for register offset");
d4108 1
a4108 1
	      inst.error = _("invalid offset");
d4119 1
a4119 1
      inst.error = _("invalid base register in load/store");
d4143 1
a4143 1
	      inst.error = _("Invalid offset");
d4146 1
a4146 1
	  inst.instruction |= (offset >> size) << 6;
a4169 9
static void
do_t_nop (str)
     char * str;
{
  /* Do nothing */
  end_of_line (str);
  return;
}

d4175 1
a4175 1
     char * str;
d4179 5
a4183 1
  skip_whitespace (str);
d4185 1
a4185 2
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
d4188 3
a4190 2
    	inst.error = BAD_ARGS;
      	return;
d4203 1
a4203 1
	  inst.error = BAD_ARGS;
d4212 1
a4212 1
	  inst.error = _("dest and source1 one must be the same register");
d4220 1
a4220 1
    as_tsktsk (_("Rs and Rd must be different in MUL"));
d4228 1
a4228 1
     char * str;
d4235 1
a4235 1
     char * str;
d4241 2
a4242 2
do_t_branch9 (str)
     char * str;
d4246 1
a4246 1
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH9;
d4252 2
a4253 2
do_t_branch12 (str)
     char * str;
d4255 6
a4260 1
  if (my_get_expression (&inst.reloc.exp, &str))
a4261 4
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH12;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}
d4263 2
a4264 1
/* Find the real, Thumb encoded start of a Thumb function.  */
d4266 2
a4267 75
static symbolS *
find_real_start (symbolP)
     symbolS * symbolP;
{
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;

  /* This definiton must agree with the one in gcc/config/arm/thumb.c */
#define STUB_NAME ".real_start_of"

  if (name == NULL)
    abort();

  /* Names that start with '.' are local labels, not function entry points.
     The compiler may generate BL instructions to these labels because it
     needs to perform a branch to a far away location.  */
  if (name[0] == '.')
    return symbolP;
  
  real_start = malloc (strlen (name) + strlen (STUB_NAME) + 1);
  sprintf (real_start, "%s%s", STUB_NAME, name);

  new_target = symbol_find (real_start);
  
  if (new_target == NULL)
    {
      as_warn ("Failed to find real start of function: %s\n", name);
      new_target = symbolP;
    }

  free (real_start);

  return new_target;
}


static void
do_t_branch23 (str)
     char * str;
{
  if (my_get_expression (& inst.reloc.exp, & str))
    return;
  
  inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
  inst.reloc.pc_rel = 1;
  end_of_line (str);

  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.  */
  if (   inst.reloc.exp.X_op == O_symbol
      && inst.reloc.exp.X_add_symbol != NULL
      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
    inst.reloc.exp.X_add_symbol = find_real_start (inst.reloc.exp.X_add_symbol);
}

static void
do_t_bx (str)
     char * str;
{
  int reg;

  skip_whitespace (str);

  if ((reg = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;

  /* This sets THUMB_H2 from the top bit of reg.  */
  inst.instruction |= reg << 3;

  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.  The reloc
     should cause the alignment to be checked once it is known.  This is
d4275 1
a4275 1
     char * str;
d4282 1
a4282 1
     char * str;
d4287 2
a4288 1
  skip_whitespace (str);
d4294 1
a4294 1
    as_warn (_("Inserted missing '!': load/store multiple always writes back base register"));
d4302 1
a4302 1
	inst.error = BAD_ARGS;
d4310 1
a4310 1
      inst.error = _("Expression too complex");
d4316 1
a4316 1
      inst.error = _("only lo-regs valid in load/store multiple");
d4326 1
a4326 1
     char * str;
d4333 1
a4333 1
     char * str;
d4340 1
a4340 1
     char * str;
d4347 1
a4347 1
     char * str;
d4351 2
a4352 1
  skip_whitespace (str);
d4363 1
a4363 1
	inst.error = _("Syntax: ldrs[b] Rd, [Rb, Ro]");
d4373 1
a4373 1
     char * str;
d4380 1
a4380 1
     char * str;
d4387 1
a4387 1
     char * str;
d4394 1
a4394 1
     char * str;
d4398 2
a4399 1
  skip_whitespace (str);
d4404 1
a4404 1
	inst.error = BAD_ARGS;
d4412 1
a4412 1
      inst.error = _("Expression too complex");
d4428 1
a4428 1
	  inst.error = _("invalid register list to push/pop instruction");
d4439 1
a4439 1
     char * str;
d4446 1
a4446 1
     char * str;
d4453 1
a4453 1
     char * str;
d4460 1
a4460 1
     char * str;
d4467 1
a4467 1
     char * str;
d4469 2
a4470 1
  skip_whitespace (str);
d4482 1
a4482 1
     char * str;
a4483 2
  int reg;

d4485 3
a4487 2
     into a relative address of the form "add rd, pc, #label-.-4".  */
  skip_whitespace (str);
d4489 1
a4489 3
  /* Store Rd in temporary location inside instruction.  */
  if ((reg = reg_required_here (&str, 4)) == FAIL
      || (reg > 7)  /* For Thumb reg must be r0..r7.  */
d4494 1
a4494 1
	inst.error = BAD_ARGS;
d4499 1
a4499 1
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
d4501 1
a4501 2
  inst.instruction |= REG_PC; /* Rd is already placed into the instruction.  */
  
d4509 4
a4512 4
  int    len = strlen (reg_table[entry].name) + 2;
  char * buf = (char *) xmalloc (len);
  char * buf2 = (char *) xmalloc (len);
  int    i = 0;
d4558 3
a4560 4
  unsigned mach;
  unsigned int i;
  
  if (   (arm_ops_hsh = hash_new ()) == NULL
d4566 1
a4566 1
    as_fatal (_("Virtual memory exhausted"));
a4582 53

#if defined OBJ_COFF || defined OBJ_ELF
  {
    unsigned int flags = 0;
    
    /* Set the flags in the private structure.  */
    if (uses_apcs_26)      flags |= F_APCS26;
    if (support_interwork) flags |= F_INTERWORK;
    if (uses_apcs_float)   flags |= F_APCS_FLOAT;
    if (pic_code)          flags |= F_PIC;
    if ((cpu_variant & FPU_ALL) == FPU_NONE) flags |= F_SOFT_FLOAT;

    bfd_set_private_flags (stdoutput, flags);
  }
#endif
  
  /* Record the CPU type as well.  */
  switch (cpu_variant & ARM_CPU_MASK)
    {
    case ARM_2:
      mach = bfd_mach_arm_2;
      break;
      
    case ARM_3: 		/* Also ARM_250.  */
      mach = bfd_mach_arm_2a;
      break;
      
    default:
    case ARM_6 | ARM_3 | ARM_2:	/* Actually no CPU type defined.  */
      mach = bfd_mach_arm_4;
      break;
      
    case ARM_7: 		/* Also ARM_6.  */
      mach = bfd_mach_arm_3;
      break;
    }
  
  /* Catch special cases.  */
  if (cpu_variant != (FPU_DEFAULT | CPU_DEFAULT))
    {
      if (cpu_variant & (ARM_EXT_V5 & ARM_THUMB))
	mach = bfd_mach_arm_5T;
      else if (cpu_variant & ARM_EXT_V5)
	mach = bfd_mach_arm_5;
      else if (cpu_variant & ARM_THUMB)
	mach = bfd_mach_arm_4T;
      else if ((cpu_variant & ARM_ARCH_V4) == ARM_ARCH_V4)
	mach = bfd_mach_arm_4;
      else if (cpu_variant & ARM_LONGMUL)
	mach = bfd_mach_arm_3M;
    }
  
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach);
d4590 2
a4591 1
   LITTLENUMS (shorts, here at least).  */
d4594 1
a4594 1
     char * buf;
d4596 1
a4596 1
     int    n;
d4606 1
a4606 1
     char * buf;
d4610 1
a4610 1
  unsigned char * where = (unsigned char *) buf;
d4648 3
a4650 3
     char   type;
     char * litP;
     int *  sizeP;
d4685 1
a4685 1
      return _("Bad call to MD_ATOF()");
d4716 2
a4717 1
/* The knowledge of the PC's pipeline offset is built into the insns themselves.  */ 
d4720 1
a4720 1
     fixS * fixP;
d4722 1
a4722 2
  if (   fixP->fx_addsy
      && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section
d4724 1
a4724 9
    return 0;
  
  if (fixP->fx_pcrel && (fixP->fx_r_type == BFD_RELOC_ARM_THUMB_ADD))
    {
      /* PC relative addressing on the Thumb is slightly odd
	 as the bottom two bits of the PC are forced to zero
	 for the calculation.  */
      return (fixP->fx_where + fixP->fx_frag->fr_address) & ~3;
    }
a4725 5
#ifdef TE_WINCE
  /* The pattern was adjusted to accomodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accomodation.  */
  return fixP->fx_where + fixP->fx_frag->fr_address + 8;
#else
a4726 1
#endif
d4732 1
a4732 1
     segT   segment ATTRIBUTE_UNUSED;
a4734 3
#ifdef OBJ_ELF
  return size;
#else
a4736 1
#endif
d4739 1
a4739 2
/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.  Otherwise 
   we have no need to default values of symbols.  */
d4744 1
a4744 1
     char * name ATTRIBUTE_UNUSED;
a4745 17
#ifdef OBJ_ELF
  if (name[0] == '_' && name[1] == 'G'
      && streq (name, GLOBAL_OFFSET_TABLE_NAME))
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");
	  
	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT)0, & zero_address_frag);
	}
      
      return GOT_symbol;
    }
#endif
  
d4754 1
a4754 1
     register char ** ccp;
d4756 4
a4759 4
  char * start = * ccp;
  char   c;
  char * p;
  struct reg_entry * reg;
d4792 26
d4820 9
a4828 11
     fixS *      fixP;
     valueT *    val;
     segT        seg;
{
  offsetT        value = * val;
  offsetT        newval;
  unsigned int   newimm;
  unsigned long  temp;
  int            sign;
  char *         buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  arm_fix_data * arm_data = (arm_fix_data *) fixP->tc_fix_data;
a4832 4
#if 0 /* patch from REarnshaw to JDavis (disabled for the moment, since it doesn't work fully) */
  if ((fixP->fx_addsy == 0 || symbol_constant_p (fixP->fx_addsy))
      && !fixP->fx_pcrel)
#else
a4833 1
#endif
d4841 1
a4841 2
      if (fixP->fx_addsy != NULL
	  && S_IS_DEFINED (fixP->fx_addsy)
d4843 1
a4843 8
	{
	  if (target_oabi
	      && (fixP->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
		))
	    value = 0;
	  else
	    value += md_pcrel_from (fixP);
	}
d4846 1
a4846 1
  fixP->fx_addnumber = value;	/* Remember value for emit_reloc.  */
d4851 1
a4851 1
      newimm = validate_immediate (value);
d4856 2
a4857 2
      if (newimm == (unsigned int) FAIL
	  && (newimm = negate_data_op (&temp, value)) == (unsigned int) FAIL)
d4860 1
a4860 2
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
d4864 2
a4865 46
      newimm |= (temp & 0xfffff000);
      md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      {
	unsigned int highpart = 0;
	unsigned int newinsn  = 0xe1a00000; /* nop */
	newimm = validate_immediate (value);
	temp = md_chars_to_number (buf, INSN_SIZE);

	/* If the instruction will fail, see if we can fix things up by
	   changing the opcode.  */
	if (newimm == (unsigned int) FAIL
	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
	  {
	    /* No ?  OK - try using two ADD instructions to generate the value.  */
	    newimm = validate_immediate_twopart (value, & highpart);

	    /* Yes - then make sure that the second instruction is also an add.  */
	    if (newimm != (unsigned int) FAIL)
	      newinsn = temp;
	    /* Still No ?  Try using a negated value.  */
	    else if (validate_immediate_twopart (- value, & highpart) != (unsigned int) FAIL)
		temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
	    /* Otherwise - give up.  */
	    else
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("Unable to compute ADRL instructions for PC offset of 0x%x"), value);
		break;
	      }

	    /* Replace the first operand in the 2nd instruction (which is the PC)
	       with the destination register.  We have already added in the PC in the
	       first instruction and we do not want to do it again.  */
	    newinsn &= ~ 0xf0000;
	    newinsn |= ((newinsn & 0x0f000) << 4);
	  }

	newimm |= (temp & 0xfffff000);
	md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);

	highpart |= (newinsn & 0xfffff000);
	md_number_to_chars (buf + INSN_SIZE, (valueT) highpart, INSN_SIZE);
      }
d4868 1
a4868 1
    case BFD_RELOC_ARM_OFFSET_IMM:
d4870 1
a4870 5
      
      if (value < 0)
	value = - value;
      
      if (validate_offset_imm (value, 0) == FAIL)
d4872 1
a4872 2
	  as_bad_where (fixP->fx_file, fixP->fx_line, 
                        _("bad immediate value for offset (%ld)"), (long) value);
d4875 2
d4887 1
a4887 5
      
      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 1) == FAIL)
d4891 1
a4891 1
			_("invalid literal constant: pool needs to be closer"));
d4893 1
a4893 2
            as_bad (_("bad immediate value for half-word offset (%ld)"),
		    (long) value);
d4897 3
d4902 1
a4902 1
      newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
a4907 1
      
d4909 1
a4909 1
	value = - value;
d4911 1
a4911 1
      if (validate_offset_imm (value, 0) == FAIL)
d4914 1
a4914 1
			_("invalid literal constant: pool needs to be closer"));
d4931 1
a4931 1
			_("shift expression is too large"));
d4949 1
a4949 1
			  _("Invalid swi expression"));
d4958 1
a4958 1
			  _("Invalid swi expression"));
d4968 1
a4968 1
		      _("Invalid expression in load/store multiple"));
d4974 16
a4989 1
      newval = md_chars_to_number (buf, INSN_SIZE);
d4991 32
a5022 39
      /* Sign-extend a 24-bit number.  */
#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)

#ifdef OBJ_ELF
      if (! target_oabi)
	value = fixP->fx_offset;
#endif

      /* We are going to store value (shifted right by two) in the
	 instruction, in a 24 bit, signed field.  Thus we need to check
	 that none of the top 8 bits of the shifted value (top 7 bits of
         the unshifted, unsigned value) are set, or that they are all set.  */
      if ((value & 0xfe000000UL) != 0
	  && ((value & 0xfe000000UL) != 0xfe000000UL))
	{
#ifdef OBJ_ELF
	  /* Normally we would be stuck at this point, since we cannot store
	     the absolute address that is the destination of the branch in the
	     24 bits of the branch instruction.  If however, we happen to know
	     that the destination of the branch is in the same section as the
	     branch instruciton itself, then we can compute the relocation for
	     ourselves and not have to bother the linker with it.
	     
	     FIXME: The tests for OBJ_ELF and ! target_oabi are only here
	     because I have not worked out how to do this for OBJ_COFF or
	     target_oabi.  */
	  if (! target_oabi
	      && fixP->fx_addsy != NULL
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && S_GET_SEGMENT (fixP->fx_addsy) == seg)
	    {
	      /* Get pc relative value to go into the branch.  */
	      value = * val;

	      /* Permit a backward branch provided that enough bits are set.
		 Allow a forwards branch, provided that enough bits are clear.  */
	      if ((value & 0xfe000000UL) == 0xfe000000UL
		  || (value & 0xfe000000UL) == 0)
		fixP->fx_done = 1;
a5023 5
	  
	  if (! fixP->fx_done)
#endif
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("gas can't handle same-section branch dest >= 0x04000000"));
d5025 8
a5032 69

      value >>= 2;
      value += SEXT24 (newval);
      
      if ((value & 0xff000000UL) != 0
	  && ((value & 0xff000000UL) != 0xff000000UL))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("out of range branch"));
      
      newval = (value & 0x00ffffff) | (newval & 0xff000000);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;


    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* conditional branch */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
        addressT diff = (newval & 0xff) << 1;
        if (diff & 0x100)
         diff |= ~0xff;

        value += diff;
        if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
         as_bad_where (fixP->fx_file, fixP->fx_line,
                       _("Branch out of range"));
        newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* unconditional branch */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
        addressT diff = (newval & 0x7ff) << 1;
        if (diff & 0x800)
         diff |= ~0x7ff;

        value += diff;
        if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
         as_bad_where (fixP->fx_file, fixP->fx_line,
                       _("Branch out of range"));
        newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      {
        offsetT newval2;
        addressT diff;

	newval  = md_chars_to_number (buf, THUMB_SIZE);
        newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
        diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
        if (diff & 0x400000)
	  diff |= ~0x3fffff;
#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
        value += diff;
        if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("Branch with link out of range"));

        newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
        newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
        md_number_to_chars (buf, newval, THUMB_SIZE);
        md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
a5037 7
#ifdef OBJ_ELF
      else if (!target_oabi)
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 1);
        }
#endif
a5042 7
#ifdef OBJ_ELF
      else if (!target_oabi)
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 2);
        }
#endif
a5044 7
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
	md_number_to_chars (buf, 0, 4);
	break;
#endif

a5048 7
#ifdef OBJ_ELF
      else if (!target_oabi)
        {
          value = fixP->fx_offset;
          md_number_to_chars (buf, value, 4);
        }
#endif
a5050 10
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PLT32:
      /* It appears the instruction is fully prepared at this point. */
      break;
#endif

    case BFD_RELOC_ARM_GOTPC:
      md_number_to_chars (buf, value, 4);
      break;
      
d5055 1
a5055 1
		      _("Illegal value for co-processor offset"));
d5070 4
a5073 5
	  /* Thumb PC loads are somewhat odd, bit 1 of the PC is
	     forced to zero for these loads, so we will need to round
	     up the offset if the instruction address is not word
	     aligned (since the final address produced must be, and
	     we can only describe word-aligned immediate offsets).  */
d5077 1
a5077 2
			  _("Invalid offset, target not word aligned (0x%08X)"),
                          (unsigned int)(fixP->fx_frag->fr_address + fixP->fx_where + value));
d5081 2
a5082 3
			  _("Invalid offset, value too big (0x%08X)"), value);

          /* Round up, since pc will be rounded down.  */
d5089 1
a5089 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d5096 1
a5096 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d5103 1
a5103 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d5110 1
a5110 1
			  _("Invalid offset, value too big (0x%08X)"), value);
d5115 1
a5115 4
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"Unable to process relocation for thumb opcode: %lx",
			(unsigned long) newval);
	  break;
d5144 1
a5144 1
                            _("Invalid immediate for stack address calculation"));
d5153 1
a5153 2
                            _("Invalid immediate for address calculation (value = 0x%08lX)"),
			    (unsigned long) value);
a5154 1
            newval |= rd << 8;
d5161 1
a5161 1
                            _("Invalid 8bit immediate"));
d5169 1
a5169 1
                            _("Invalid 3bit immediate"));
d5185 1
a5185 2
                          _("Invalid immediate: %ld is too large"),
			  (long) value);
d5199 1
a5199 1
		      _("Illegal Thumb shift value: %ld"), (long) value);
a5204 5
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return 1;

d5208 1
a5208 1
		    _("Bad relocation fixup type (%d)"), fixP->fx_r_type);
d5218 2
a5219 2
     asection * section ATTRIBUTE_UNUSED;
     fixS * fixp;
d5221 1
a5221 1
  arelent * reloc;
d5226 1
a5226 2
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
a5229 1
#ifndef OBJ_ELF
a5233 3
#else  /* OBJ_ELF */
  reloc->addend = fixp->fx_offset;
#endif
a5259 5
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
d5266 22
a5287 3
	 a section boundary - possibly due to an implicit dump */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Literal referenced across section boundary (Implicit dump?)"));
d5290 4
a5293 7
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_PLT32:
       code = fixp->fx_r_type;
    break;
#endif
d5295 3
a5297 4
    case BFD_RELOC_ARM_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Internal_relocation (type %d) not fixed up (IMMEDIATE)"),
		    fixp->fx_r_type);
d5300 3
a5302 4
    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("ADRL used for a symbol not defined in the same file"),
		    fixp->fx_r_type);
d5305 3
a5307 4
    case BFD_RELOC_ARM_OFFSET_IMM:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Internal_relocation (type %d) not fixed up (OFFSET_IMM)"),
		    fixp->fx_r_type);
d5311 1
a5311 22
      {
	char * type;
	switch (fixp->fx_r_type)
	  {
	  case BFD_RELOC_ARM_IMMEDIATE:    type = "IMMEDIATE";    break;
	  case BFD_RELOC_ARM_OFFSET_IMM:   type = "OFFSET_IMM";   break;
	  case BFD_RELOC_ARM_OFFSET_IMM8:  type = "OFFSET_IMM8";  break;
	  case BFD_RELOC_ARM_SHIFT_IMM:    type = "SHIFT_IMM";    break;
	  case BFD_RELOC_ARM_SWI:          type = "SWI";          break;
	  case BFD_RELOC_ARM_MULTI:        type = "MULTI";        break;
	  case BFD_RELOC_ARM_CP_OFF_IMM:   type = "CP_OFF_IMM";   break;
	  case BFD_RELOC_ARM_THUMB_ADD:    type = "THUMB_ADD";    break;
	  case BFD_RELOC_ARM_THUMB_SHIFT:  type = "THUMB_SHIFT";  break;
	  case BFD_RELOC_ARM_THUMB_IMM:    type = "THUMB_IMM";    break;
	  case BFD_RELOC_ARM_THUMB_OFFSET: type = "THUMB_OFFSET"; break;
	  default:                         type = _("<unknown>"); break;
	  }
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("Can not represent %s relocation in this object file format (%d)"),
		      type, fixp->fx_pcrel);
	return NULL;
      }
a5313 10
#ifdef OBJ_ELF
 if (code == BFD_RELOC_32_PCREL
     && GOT_symbol
     && fixp->fx_addsy == GOT_symbol)
   {
     code = BFD_RELOC_ARM_GOTPC;
     reloc->addend = fixp->fx_offset = reloc->address;
   }
#endif
   
d5315 1
d5317 5
a5321 7
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Can not represent %s relocation in this object file format"),
		    bfd_get_reloc_code_name (code));
      return NULL;
    }
d5323 10
a5332 4
   /* HACK: Since arm ELF uses Rel instead of Rela, encode the
      vtable entry to be used in the relocation's section offset.  */
   if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
     reloc->address = fixp->fx_offset;
d5334 8
a5341 1
  return reloc;
d5346 2
a5347 2
     fragS * fragP ATTRIBUTE_UNUSED;
     segT    segtype ATTRIBUTE_UNUSED;
d5349 2
a5350 2
  as_fatal (_("md_estimate_size_before_relax\n"));
  return 1;
d5353 3
a5355 2
static void
output_inst PARAMS ((void))
d5357 1
a5357 1
  char * to = NULL;
d5361 1
a5361 1
      as_bad (inst.error);
d5366 1
a5366 2
  
  if (thumb_mode && (inst.size > THUMB_SIZE))
d5368 3
a5370 3
      assert (inst.size == (2 * THUMB_SIZE));
      md_number_to_chars (to, inst.instruction >> 16, THUMB_SIZE);
      md_number_to_chars (to + THUMB_SIZE, inst.instruction, THUMB_SIZE);
d5372 2
a5373 8
  else if (inst.size > INSN_SIZE)
    {
      assert (inst.size == (2 * INSN_SIZE));
      md_number_to_chars (to, inst.instruction, INSN_SIZE);
      md_number_to_chars (to + INSN_SIZE, inst.instruction, INSN_SIZE);
    }
  else
    md_number_to_chars (to, inst.instruction, inst.size);
d5377 1
a5377 1
		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
d5385 1
a5385 1
     char * str;
d5387 2
a5388 4
  char   c;
  char * p;
  char * q;
  char * start;
d5390 2
a5391 2
  /* Align the instruction.
     This may not be the right thing to do but ... */
d5395 1
a5395 1
  /* Align the previous label if needed.  */
d5398 1
a5398 1
      symbol_set_frag (last_label_seen, frag_now);
d5406 5
a5410 4
  skip_whitespace (str);
  
  /* Scan up to the end of the op-code, which must end in white space or
     end of string.  */
d5417 1
a5417 1
      as_bad (_("No operator -- statement `%s'\n"), str);
d5423 1
a5423 1
      CONST struct thumb_opcode * opcode;
a5428 1
      
a5430 7
	  /* Check that this instruction is supported for this CPU.  */
	  if (thumb_mode == 1 && (opcode->variants & cpu_variant) == 0)
	     {
	    	as_bad (_("selected processor does not support this opcode"));
		return;
	     }

d5434 1
a5434 1
	  output_inst ();
d5440 1
a5440 2
      CONST struct asm_opcode * opcode;
      unsigned long cond_code;
d5446 1
a5446 1
	 matches, or we run out of opcode.  */
a5453 1
	  
d5457 1
a5457 1
	      char * r;
d5459 1
a5459 1
	      /* Check that this instruction is supported for this CPU.  */
d5464 1
a5464 1
	      if (q == p)		/* Just a simple opcode.  */
d5466 3
a5468 9
		  if (opcode->comp_suffix)
		    {
		       if (*opcode->comp_suffix != '\0')
		    	 as_bad (_("Opcode `%s' must have suffix from list: <%s>"),
			     str, opcode->comp_suffix);
		       else
			 /* Not a conditional instruction. */
		         (*opcode->parms)(q, 0);
		    }
a5470 1
		      /* A conditional instruction with default condition. */
d5474 1
a5474 1
		  output_inst ();
d5478 1
a5478 1
	      /* Not just a simple opcode.  Check if extra is a conditional. */
d5492 1
a5492 1
_("Warning: Use of the 'nv' conditional is deprecated\n"));
d5494 1
a5494 1
		      cond_code = cond->value;
d5498 1
a5498 1
		    cond_code = COND_ALWAYS;
d5501 1
a5501 1
		cond_code = COND_ALWAYS;
d5503 3
a5505 18
	      /* Apply the conditional, or complain it's not allowed. */
	      if (opcode->comp_suffix && *opcode->comp_suffix == '\0')
		{
		   /* Instruction isn't conditional */
		   if (cond_code != COND_ALWAYS)
		     {
		       as_bad (_("Opcode `%s' is unconditional\n"), str);
		       return;
		     }
		}
	      else
		/* Instruction is conditional: set the condition into it. */
		inst.instruction |= cond_code;	     


	      /* If there is a compulsory suffix, it should come here, before
		 any optional flags.  */
	      if (opcode->comp_suffix && *opcode->comp_suffix != '\0')
d5519 1
a5519 1
		      as_bad (_("Opcode `%s' must have suffix from <%s>\n"), str,
d5543 1
a5543 1
			  if (streq (r, flag[flagno].template))
d5559 1
a5559 1
	      output_inst ();
d5569 2
a5570 1
     alias .req reg */
d5572 2
a5573 1
  skip_whitespace (q);
d5580 4
a5583 3
      int    reg;
      char * copy_of_str = str;
      char * r;
d5585 3
a5587 2
      q += 4;
      skip_whitespace (q);
d5589 3
a5591 8
      for (r = q; *r != '\0'; r++)
	if (*r == ' ')
	  break;
      
      if (r != q)
	{
	  int regnum;
	  char d = *r;
d5593 4
a5596 3
	  *r = '\0';
	  regnum = arm_reg_parse (& q);
	  *r = d;
d5598 3
a5600 4
	  reg = arm_reg_parse (& str);
	  
	  if (reg == FAIL)
	    {
d5602 5
a5606 11
		insert_reg_alias (str, regnum);
	      else
		as_warn (_("register '%s' does not exist\n"), q);
	    }
	  else if (regnum != FAIL)
	    {
	      if (reg != regnum)
		as_warn (_("ignoring redefinition of register alias '%s'"),
			 copy_of_str );
	      
	      /* Do not warn about redefinitions to the same alias.  */
a5607 3
	  else
	    as_warn (_("ignoring redefinition of register alias '%s' to non-existant register '%s'"),
		     copy_of_str, q);
d5610 4
a5613 4
	as_warn (_("ignoring incomplete .req pseuso op"));
      
      *p = c;
      return;
d5617 1
a5617 1
  as_bad (_("bad instruction `%s'"), start);
d5628 2
a5629 6
 *            -m[arm]6[xx],           Arm 6 processors
 *            -m[arm]7[xx][t][[d]m]   Arm 7 processors
 *            -m[arm]8[10]            Arm 8 processors
 *            -m[arm]9[20][tdmi]      Arm 9 processors
 *            -mstrongarm[110[0]]     StrongARM processors
 *            -m[arm]v[2345[t]]       Arm architectures
a5637 7
 *    ARM Procedure Calling Standard:
 *	      -mapcs-32		      32 bit APCS
 *	      -mapcs-26		      26 bit APCS
 *	      -mapcs-float	      Pass floats in float regs
 *	      -mapcs-reentrant        Position independent code
 *            -mthumb-interwork       Code supports Arm/Thumb interworking
 *            -moabi                  Old ELF ABI
d5640 2
a5641 3
CONST char * md_shortopts = "m:k";
struct option md_longopts[] =
{
a5646 4
#ifdef OBJ_ELF
#define OPTION_OABI (OPTION_MD_BASE +2)
  {"oabi", no_argument, NULL, OPTION_OABI},
#endif
d5654 2
a5655 2
     int    c;
     char * arg;
d5657 1
a5657 1
  char * str = arg;
d5674 1
a5674 1
	  if (streq (str, "fpa10"))
d5676 1
a5676 1
	  else if (streq (str, "fpa11"))
d5678 1
a5678 1
	  else if (streq (str, "fpe-old"))
d5685 1
a5685 1
	  if (streq (str, "no-fpu"))
a5688 7
#ifdef OBJ_ELF
        case 'o':
          if (streq (str, "oabi"))
            target_oabi = true;
          break;
#endif
	  
d5691 1
a5691 1
          if (streq (str, "thumb"))
a5696 8
          else if (streq (str, "thumb-interwork"))
            {
	      if ((cpu_variant & ARM_THUMB) == 0)
		cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V4T;
#if defined OBJ_COFF || defined OBJ_ELF
              support_interwork = true;
#endif
            }
d5702 1
a5702 1
	  if (streq (str, "all"))
a5706 30
#if defined OBJ_COFF || defined OBJ_ELF
	  if (! strncmp (str, "apcs-", 5))
	    {
	      /* GCC passes on all command line options starting "-mapcs-..."
		 to us, so we must parse them here.  */

	      str += 5;
	      
	      if (streq (str, "32"))
		{
		  uses_apcs_26 = false;
		  return 1;
		}
	      else if (streq (str, "26"))
		{
		  uses_apcs_26 = true;
		  return 1;
		}
	      else if (streq (str, "frame"))
		{
		  /* Stack frames are being generated - does not affect
		     linkage of code.  */
		  return 1;
		}
	      else if (streq (str, "stack-check"))
		{
		  /* Stack checking is being performed - does not affect
		     linkage, but does require that the functions
		     __rt_stkovf_split_small and __rt_stkovf_split_big be
		     present in the final link.  */
a5707 25
		  return 1;
		}
	      else if (streq (str, "float"))
		{
		  /* Floating point arguments are being passed in the floating
		     point registers.  This does affect linking, since this
		     version of the APCS is incompatible with the version that
		     passes floating points in the integer registers.  */

		  uses_apcs_float = true;
		  return 1;
		}
	      else if (streq (str, "reentrant"))
		{
		  /* Reentrant code has been generated.  This does affect
		     linking, since there is no point in linking reentrant/
		     position independent code with absolute position code. */
		  pic_code = true;
		  return 1;
		}
	      
	      as_bad (_("Unrecognised APCS switch -m%s"), arg);
	      return 0;
  	    }
#endif
d5715 1
a5715 1
	      if (streq (str, "1"))
d5722 1
a5722 1
	      if (streq (str, "2"))
d5724 1
a5724 1
	      else if (streq (str, "250"))
d5731 1
a5731 1
	      if (streq (str, "3"))
d5738 4
a5741 12
	      switch (strtol (str, NULL, 10))
		{
		case 6:
		case 60:
		case 600:
		case 610:
		case 620:
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_6;
		  break;
		default:
		  goto bad;
		}
d5745 1
a5745 13
	      switch (strtol (str, & str, 10))	/* Eat the processor name */
		{
		case 7:
		case 70:
		case 700:
		case 710:
		case 720:
		case 7100:
		case 7500:
		  break;
		default:
		  goto bad;
		}
d5749 1
a5749 1
                switch (* str)
d5752 1
a5752 1
                    cpu_variant |= (ARM_THUMB | ARM_ARCH_V4);
d5759 4
a5762 10
		  case 'f': /* fe => fp enabled cpu.  */
		    if (str[1] == 'e')
		      ++ str;
		    else
		      goto bad;
		    
		  case 'c': /* Left over from 710c processor name.  */
                  case 'd': /* Debug */
                  case 'i': /* Embedded ICE */
                    /* Included for completeness in ARM processor naming. */
a5770 100
	    case '8':
	      if (streq (str, "8") || streq (str, "810"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_8 | ARM_ARCH_V4 | ARM_LONGMUL;
	      else
		goto bad;
	      break;
	      
	    case '9':
	      if (streq (str, "9"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
	      else if (streq (str, "920"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL;
	      else if (streq (str, "920t"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
	      else if (streq (str, "9tdmi"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_9 | ARM_ARCH_V4 | ARM_LONGMUL | ARM_THUMB;
	      else
		goto bad;
	      break;

	      
	    case 's':
	      if (streq (str, "strongarm")
		  || streq (str, "strongarm110")
		  || streq (str, "strongarm1100"))
		cpu_variant = (cpu_variant & ~ARM_ANY)
		  | ARM_8 | ARM_ARCH_V4 | ARM_LONGMUL;
	      else
		goto bad;
	      break;
		
	    case 'v':
	      /* Select variant based on architecture rather than processor.  */
	      switch (*++str)
		{
		case '2':
		  switch (*++str)
		    {
		    case 'a':
		      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_3;
		      break;
		    case 0:
		      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_2;
		      break;
		    default:
		      as_bad (_("Invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;
		  
		case '3':
		    cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
                    
		  switch (*++str)
		    {
		    case 'm': cpu_variant |= ARM_LONGMUL; break;
		    case 0:   break;
		    default:
		      as_bad (_("Invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;
		  
		case '4':
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V4;
		  
		  switch (*++str)
		    {
		    case 't': cpu_variant |= ARM_THUMB; break;
		    case 0:   break;
		    default:
		      as_bad (_("Invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;

		case '5':
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_ARCH_V5;
		  switch (*++str)
		    {
		    case 't': cpu_variant |= ARM_THUMB; break;
		    case 'e': cpu_variant |= ARM_EXT_V5E; break;
		    case 0:   break;
		    default:
		      as_bad (_("Invalid architecture variant -m%s"), arg);
		      break;
		    }
		  break;
		  
		default:
		  as_bad (_("Invalid architecture variant -m%s"), arg);
		  break;
		}
	      break;
	      
d5773 1
a5773 1
	      as_bad (_("Invalid processor variant -m%s"), arg);
a5778 6
#if defined OBJ_ELF || defined OBJ_COFF
    case 'k':
      pic_code = 1;
      break;
#endif
      
d5788 1
a5788 1
     FILE * fp;
d5790 7
a5796 21
  fprintf (fp, _("\
 ARM Specific Assembler Options:\n\
  -m[arm][<processor name>] select processor variant\n\
  -m[arm]v[2|2a|3|3m|4|4t|5[t][e]] select architecture variant\n\
  -mthumb                   only allow Thumb instructions\n\
  -mthumb-interwork         mark the assembled code as supporting interworking\n\
  -mall                     allow any instruction\n\
  -mfpa10, -mfpa11          select floating point architecture\n\
  -mfpe-old                 don't allow floating-point multiple instructions\n\
  -mno-fpu                  don't allow any floating-point instructions.\n\
  -k                        generate PIC code.\n"));
#if defined OBJ_COFF || defined OBJ_ELF
  fprintf (fp, _("\
  -mapcs-32, -mapcs-26      specify which ARM Procedure Calling Standard to use\n\
  -mapcs-float              floating point args are passed in FP regs\n\
  -mapcs-reentrant          the code is position independent/reentrant\n"));
  #endif
#ifdef OBJ_ELF
  fprintf (fp, _("\
  -moabi                    support the old ELF ABI\n"));
#endif
d5798 3
a5800 3
  fprintf (fp, _("\
  -EB                       assemble code for a big endian cpu\n\
  -EL                       assemble code for a little endian cpu\n"));
d5813 6
a5818 6
     fragS *       frag;
     int           where;
     short int     size;
     expressionS * exp;
     int           pc_rel;
     int           reloc;
d5820 2
a5821 2
  fixS *         new_fix;
  arm_fix_data * arm_data;
d5839 1
a5839 1
  arm_data = (arm_fix_data *) obstack_alloc (& notes, sizeof (arm_fix_data));
d5846 3
a5848 2

/* This fix_new is called by cons via TC_CONS_FIX_NEW.  */
d5850 2
a5851 5
cons_fix_new_arm (frag, where, size, exp)
     fragS *       frag;
     int           where;
     int           size;
     expressionS * exp;
d5853 1
a5853 6
  bfd_reloc_code_real_type type;
  int pcrel = 0;
  
  /* Pick a reloc.
     FIXME: @@@@ Should look at CPU word size.  */
  switch (size) 
d5855 3
a5857 13
    case 1:
      type = BFD_RELOC_8;
      break;
    case 2:
      type = BFD_RELOC_16;
      break;
    case 4:
    default:
      type = BFD_RELOC_32;
      break;
    case 8:
      type = BFD_RELOC_64;
      break;
a5858 16
  
  fix_new_exp (frag, where, (int) size, exp, pcrel, type);
}

/* A good place to do this, although this was probably not intended
   for this kind of use.  We need to dump the literal pool before
   references are made to a null symbol pointer.  */
void
arm_cleanup ()
{
  if (current_poolP == NULL)
    return;
  
  subseg_set (text_section, 0); /* Put it at the end of text section.  */
  s_ltorg (0);
  listing_prev_line ();
d5869 1
a5869 1
     symbolS * sym;
a5871 90
  
  ARM_SET_THUMB (sym, thumb_mode);
  
#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (sym, support_interwork);
#endif
  
  if (label_is_thumb_function_name)
    {
      /* When the address of a Thumb function is taken the bottom
	 bit of that address should be set.  This will allow
	 interworking between Arm and Thumb functions to work
	 correctly.  */

      THUMB_SET_FUNC (sym, 1);
      
      label_is_thumb_function_name = false;
    }
}

/* Adjust the symbol table.  This marks Thumb symbols as distinct from
   ARM ones.  */

void
arm_adjust_symtab ()
{
#ifdef OBJ_COFF
  symbolS * sym;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
        {
	  if (THUMB_IS_FUNC (sym))
	    {
	      /* Mark the symbol as a Thumb function.  */
	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL) /* This can happen! */
		S_SET_STORAGE_CLASS (sym, C_THUMBSTATFUNC);

	      else if (S_GET_STORAGE_CLASS (sym) == C_EXT)
		S_SET_STORAGE_CLASS (sym, C_THUMBEXTFUNC);
	      else
		as_bad (_("%s: unexpected function type: %d"),
			S_GET_NAME (sym), S_GET_STORAGE_CLASS (sym));
	    }
          else switch (S_GET_STORAGE_CLASS (sym))
            {
              case C_EXT:
                S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
                break;
              case C_STAT:
                S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
                break;
              case C_LABEL:
                S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
                break;
              default: /* do nothing */ 
                break;
            }
        }

      if (ARM_IS_INTERWORK (sym))
	coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_flags = 0xFF;
    }
#endif
#ifdef OBJ_ELF
  symbolS *         sym;
  char              bind;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
        {
	  elf_symbol_type * elf_sym;
	  
	  elf_sym = elf_symbol (symbol_get_bfdsym (sym));
	  bind = ELF_ST_BIND (elf_sym);
	  
	  /* If it's a .thumb_func, declare it as so,
	     otherwise tag label as .code 16.  */
	  if (THUMB_IS_FUNC (sym))
	    elf_sym->internal_elf_sym.st_info =
	      ELF_ST_INFO (bind, STT_ARM_TFUNC);
	  else
	    elf_sym->internal_elf_sym.st_info =
	      ELF_ST_INFO (bind, STT_ARM_16BIT);
         }
     }
#endif
a5883 1
  
d5889 1
a5889 1
     char * name;
d5894 1
a5894 152
      && streq (name + len - 5, "/data"))
    *(name + len - 5) = 0;

  return name;
}

boolean
arm_validate_fix (fixP)
     fixS * fixP;
{
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.  */
  if (   fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
      && fixP->fx_addsy != NULL
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! THUMB_IS_FUNC (fixP->fx_addsy))
    {
      fixP->fx_addsy = find_real_start (fixP->fx_addsy);
      return true;
    }

  return false;
}

#ifdef OBJ_ELF
/* Relocations against Thumb function names must be left unadjusted,
   so that the linker can use this information to correctly set the
   bottom bit of their addresses.  The MIPS version of this function
   also prevents relocations that are mips-16 specific, but I do not
   know why it does this.

   FIXME:
   There is one other problem that ought to be addressed here, but
   which currently is not:  Taking the address of a label (rather
   than a function) and then later jumping to that address.  Such
   addresses also ought to have their bottom bit set (assuming that
   they reside in Thumb code), but at the moment they will not.  */
   
boolean
arm_fix_adjustable (fixP)
   fixS * fixP;
{
  if (fixP->fx_addsy == NULL)
    return 1;
  
  /* Prevent all adjustments to global symbols. */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;
  
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;

  if (THUMB_IS_FUNC (fixP->fx_addsy)
      && fixP->fx_subsy == NULL)
    return 0;
  
  /* We need the symbol name for the VTABLE entries */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}

const char *
elf32_arm_target_format ()
{
  if (target_big_endian)
    if (target_oabi)
      return "elf32-bigarm-oabi";
    else
      return "elf32-bigarm";
  else
    if (target_oabi)
      return "elf32-littlearm-oabi";
    else
      return "elf32-littlearm";
}

void
armelf_frob_symbol (symp, puntp)
     symbolS * symp;
     int * puntp;
{
  elf_frob_symbol (symp, puntp);
} 

int
arm_force_relocation (fixp)
     struct fix * fixp;
{
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)    
    return 1;
  
  return 0;
}

static bfd_reloc_code_real_type
arm_parse_reloc ()
{
  char   id[16];
  char * ip;
  unsigned int i;
  static struct
  {
    char * str;
    int    len;
    bfd_reloc_code_real_type reloc;
  }
  reloc_map[] =
  {
#define MAP(str,reloc) { str, sizeof (str)-1, reloc }
    MAP ("(got)",    BFD_RELOC_ARM_GOT32),
    MAP ("(gotoff)", BFD_RELOC_ARM_GOTOFF),
    /* ScottB: Jan 30, 1998 */
    /* Added support for parsing "var(PLT)" branch instructions */
    /* generated by GCC for PLT relocs */
    MAP ("(plt)",    BFD_RELOC_ARM_PLT32),
    { NULL, 0,         BFD_RELOC_UNUSED }
#undef MAP    
  };

  for (i = 0, ip = input_line_pointer;
       i < sizeof (id) && (isalnum (*ip) || ispunct (*ip));
       i++, ip++)
    id[i] = tolower (*ip);
  
  for (i = 0; reloc_map[i].str; i++)
    if (strncmp (id, reloc_map[i].str, reloc_map[i].len) == 0)
      break;
  
  input_line_pointer += reloc_map[i].len;
  
  return reloc_map[i].reloc;
}

static void
s_arm_elf_cons (nbytes)
     int nbytes;
{
  expressionS exp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
d5896 1
a5896 2
      demand_empty_rest_of_line ();
      return;
d5899 1
a5899 36
#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  do
    {
      bfd_reloc_code_real_type reloc;
      
      expression (& exp);

      if (exp.X_op == O_symbol
          && * input_line_pointer == '('
          && (reloc = arm_parse_reloc()) != BFD_RELOC_UNUSED)
        {
          reloc_howto_type * howto = bfd_reloc_type_lookup (stdoutput, reloc);
          int size = bfd_get_reloc_size (howto);

          if (size > nbytes)
            as_bad ("%s relocations do not fit in %d bytes",
		    howto->name, nbytes);
          else
            {
              register char * p = frag_more ((int) nbytes);
              int offset = nbytes - size;

              fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   & exp, 0, reloc);
            }
        }
      else
        emit_expr (& exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
a5900 2

#endif /* OBJ_ELF */
@


1.1.1.6
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d1946 1
a1946 1
    skip = 8;
d2007 1
a2007 1
      inst.error = _("only flag field of psr can be set with immediate value");
d5453 1
a5453 1
	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d28 1
a28 1
/* Need TARGET_CPU.  */
a36 1
#include "dwarf2dbg.h"
d45 3
a47 3
#define ARM_7		ARM_6           /* Same core instruction set.  */
#define ARM_8		ARM_6           /* Same core instruction set.  */
#define ARM_9		ARM_6           /* Same core instruction set.  */
d50 6
a55 7
/* The following bitmasks control CPU extensions (ARM7 onwards):   */
#define ARM_EXT_LONGMUL	0x00000010	/* Allow long multiplies.  */
#define ARM_EXT_HALFWORD 0x00000020	/* Allow half word loads.  */
#define ARM_EXT_THUMB	0x00000040	/* Allow BX instruction.   */
#define ARM_EXT_V5	0x00000080	/* Allow CLZ, etc.         */
#define ARM_EXT_V5E	0x00000100	/* "El Segundo". 	   */
#define ARM_EXT_XSCALE	0x00000200	/* Allow MIA etc.  	   */
d58 2
a59 3
#define ARM_ARCH_V3M     ARM_EXT_LONGMUL
#define ARM_ARCH_V4     (ARM_ARCH_V3M | ARM_EXT_HALFWORD)
#define ARM_ARCH_V4T	(ARM_ARCH_V4 | ARM_EXT_THUMB)
d61 1
a61 3
#define ARM_ARCH_V5T	(ARM_ARCH_V5 | ARM_EXT_THUMB)
#define ARM_ARCH_V5TE	(ARM_ARCH_V5T | ARM_EXT_V5E)
#define ARM_ARCH_XSCALE (ARM_ARCH_V5TE | ARM_EXT_XSCALE)
d66 1
a66 1
#define ARM_ALL		ARM_2UP		/* Not arm1 only.  */
d68 1
a68 1
#define ARM_6UP		0x00fffff8      /* Includes ARM7.  */
d75 3
a77 3
/* Some useful combinations.  */
#define FPU_ALL		0xff000000	/* Note this is ~ARM_ANY.  */
#define FPU_MEMMULTI	0x7f000000	/* Not fpu_core.  */
d79 1
a80 3
#if defined __XSCALE__
#define CPU_DEFAULT	(ARM_9 | ARM_ARCH_XSCALE)
#else
d82 1
a82 1
#define CPU_DEFAULT 	(ARM_7 | ARM_ARCH_V4T)
d84 1
a84 2
#define CPU_DEFAULT 	ARM_ALL
#endif
d93 1
a93 1
#define skip_whitespace(str)  while (*(str) == ' ') ++(str)
d95 1
a95 1
static unsigned long cpu_variant = CPU_DEFAULT | FPU_DEFAULT;
d99 5
a103 6
/* Flags stored in private area of BFD structure.  */
static boolean uses_apcs_26      = false;
static boolean atpcs             = false;
static boolean support_interwork = false;
static boolean uses_apcs_float   = false;
static boolean pic_code          = false;
d119 1
d121 3
d129 3
a131 3
/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456  */
/* or    0d1.2345e12  */
d140 1
a140 2
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"  */
symbolS * GOT_symbol;
d143 1
a143 8
/* Size of relocation record.  */
CONST int md_reloc_size = 8;

/* 0: assemble for ARM,
   1: assemble for Thumb,
   2: assemble for Thumb even though target CPU does not support thumb
      instructions.  */
static int thumb_mode = 0;
d145 3
d160 5
a164 5
  {
    bfd_reloc_code_real_type type;
    expressionS              exp;
    int                      pc_rel;
  } reloc;
d169 1
a169 1
enum asm_shift_index
d171 2
a172 22
  SHIFT_LSL = 0,
  SHIFT_LSR,
  SHIFT_ASR,
  SHIFT_ROR,
  SHIFT_RRX
};

struct asm_shift_properties
{
  enum asm_shift_index index;
  unsigned long        bit_field;
  unsigned int         allows_0  : 1;
  unsigned int         allows_32 : 1;
};

static const struct asm_shift_properties shift_properties [] =
{
  { SHIFT_LSL, 0,    1, 0},
  { SHIFT_LSR, 0x20, 0, 1},
  { SHIFT_ASR, 0x40, 0, 1},
  { SHIFT_ROR, 0x60, 0, 0},
  { SHIFT_RRX, 0x60, 0, 0}
d175 1
a175 1
struct asm_shift_name
d177 12
a188 18
  const char *                        name;
  const struct asm_shift_properties * properties;
};

static const struct asm_shift_name shift_names [] =
{
  { "asl", shift_properties + SHIFT_LSL },
  { "lsl", shift_properties + SHIFT_LSL },
  { "lsr", shift_properties + SHIFT_LSR },
  { "asr", shift_properties + SHIFT_ASR },
  { "ror", shift_properties + SHIFT_ROR },
  { "rrx", shift_properties + SHIFT_RRX },
  { "ASL", shift_properties + SHIFT_LSL },
  { "LSL", shift_properties + SHIFT_LSL },
  { "LSR", shift_properties + SHIFT_LSR },
  { "ASR", shift_properties + SHIFT_ASR },
  { "ROR", shift_properties + SHIFT_ROR },
  { "RRX", shift_properties + SHIFT_RRX }
d196 1
a196 1
CONST char * fp_const[] =
d220 3
a222 5
#define CONDS_BIT        0x00100000
#define LOAD_BIT         0x00100000
#define TRANS_BIT	 0x00200000

#define DOUBLE_LOAD_FLAG 0x00000001
d233 1
a233 1
static CONST struct asm_cond conds[] =
d258 2
a259 2
  CONST char *  template;	/* Basic flag string.  */
  unsigned long set_bits;	/* Bits to set.  */
a269 1
  {"d",  DOUBLE_LOAD_FLAG},
a280 1
  {"d",  DOUBLE_LOAD_FLAG},
d306 1
a306 1
  {"fa", 0x00000000},
d310 1
a310 1
  {"da", 0x00000000},
d316 1
a316 1
  {"ed", 0x00000000},
d323 1
a323 1
  {"da", 0x00000000},
d389 2
a390 5
/* The bit that distnguishes CPSR and SPSR.  */
#define SPSR_BIT   (1 << 22)

/* How many bits to shift the PSR_xxx bits up by.  */
#define PSR_SHIFT  16
d406 1
a406 1
  {"SPSR_f",    false, PSR_f},
d415 14
a428 121
  /* Combinations of flags.  */
  {"CPSR_fs",	true, PSR_f | PSR_s},
  {"CPSR_fx",	true, PSR_f | PSR_x},
  {"CPSR_fc",	true, PSR_f | PSR_c},
  {"CPSR_sf",	true, PSR_s | PSR_f},
  {"CPSR_sx",	true, PSR_s | PSR_x},
  {"CPSR_sc",	true, PSR_s | PSR_c},
  {"CPSR_xf",	true, PSR_x | PSR_f},
  {"CPSR_xs",	true, PSR_x | PSR_s},
  {"CPSR_xc",	true, PSR_x | PSR_c},
  {"CPSR_cf",	true, PSR_c | PSR_f},
  {"CPSR_cs",	true, PSR_c | PSR_s},
  {"CPSR_cx",	true, PSR_c | PSR_x},
  {"CPSR_fsx",	true, PSR_f | PSR_s | PSR_x},
  {"CPSR_fsc",	true, PSR_f | PSR_s | PSR_c},
  {"CPSR_fxs",	true, PSR_f | PSR_x | PSR_s},
  {"CPSR_fxc",	true, PSR_f | PSR_x | PSR_c},
  {"CPSR_fcs",	true, PSR_f | PSR_c | PSR_s},
  {"CPSR_fcx",	true, PSR_f | PSR_c | PSR_x},
  {"CPSR_sfx",	true, PSR_s | PSR_f | PSR_x},
  {"CPSR_sfc",	true, PSR_s | PSR_f | PSR_c},
  {"CPSR_sxf",	true, PSR_s | PSR_x | PSR_f},
  {"CPSR_sxc",	true, PSR_s | PSR_x | PSR_c},
  {"CPSR_scf",	true, PSR_s | PSR_c | PSR_f},
  {"CPSR_scx",	true, PSR_s | PSR_c | PSR_x},
  {"CPSR_xfs",	true, PSR_x | PSR_f | PSR_s},
  {"CPSR_xfc",	true, PSR_x | PSR_f | PSR_c},
  {"CPSR_xsf",	true, PSR_x | PSR_s | PSR_f},
  {"CPSR_xsc",	true, PSR_x | PSR_s | PSR_c},
  {"CPSR_xcf",	true, PSR_x | PSR_c | PSR_f},
  {"CPSR_xcs",	true, PSR_x | PSR_c | PSR_s},
  {"CPSR_cfs",	true, PSR_c | PSR_f | PSR_s},
  {"CPSR_cfx",	true, PSR_c | PSR_f | PSR_x},
  {"CPSR_csf",	true, PSR_c | PSR_s | PSR_f},
  {"CPSR_csx",	true, PSR_c | PSR_s | PSR_x},
  {"CPSR_cxf",	true, PSR_c | PSR_x | PSR_f},
  {"CPSR_cxs",	true, PSR_c | PSR_x | PSR_s},
  {"CPSR_fsxc",	true, PSR_f | PSR_s | PSR_x | PSR_c},
  {"CPSR_fscx",	true, PSR_f | PSR_s | PSR_c | PSR_x},
  {"CPSR_fxsc",	true, PSR_f | PSR_x | PSR_s | PSR_c},
  {"CPSR_fxcs",	true, PSR_f | PSR_x | PSR_c | PSR_s},
  {"CPSR_fcsx",	true, PSR_f | PSR_c | PSR_s | PSR_x},
  {"CPSR_fcxs",	true, PSR_f | PSR_c | PSR_x | PSR_s},
  {"CPSR_sfxc",	true, PSR_s | PSR_f | PSR_x | PSR_c},
  {"CPSR_sfcx",	true, PSR_s | PSR_f | PSR_c | PSR_x},
  {"CPSR_sxfc",	true, PSR_s | PSR_x | PSR_f | PSR_c},
  {"CPSR_sxcf",	true, PSR_s | PSR_x | PSR_c | PSR_f},
  {"CPSR_scfx",	true, PSR_s | PSR_c | PSR_f | PSR_x},
  {"CPSR_scxf",	true, PSR_s | PSR_c | PSR_x | PSR_f},
  {"CPSR_xfsc",	true, PSR_x | PSR_f | PSR_s | PSR_c},
  {"CPSR_xfcs",	true, PSR_x | PSR_f | PSR_c | PSR_s},
  {"CPSR_xsfc",	true, PSR_x | PSR_s | PSR_f | PSR_c},
  {"CPSR_xscf",	true, PSR_x | PSR_s | PSR_c | PSR_f},
  {"CPSR_xcfs",	true, PSR_x | PSR_c | PSR_f | PSR_s},
  {"CPSR_xcsf",	true, PSR_x | PSR_c | PSR_s | PSR_f},
  {"CPSR_cfsx",	true, PSR_c | PSR_f | PSR_s | PSR_x},
  {"CPSR_cfxs",	true, PSR_c | PSR_f | PSR_x | PSR_s},
  {"CPSR_csfx",	true, PSR_c | PSR_s | PSR_f | PSR_x},
  {"CPSR_csxf",	true, PSR_c | PSR_s | PSR_x | PSR_f},
  {"CPSR_cxfs",	true, PSR_c | PSR_x | PSR_f | PSR_s},
  {"CPSR_cxsf",	true, PSR_c | PSR_x | PSR_s | PSR_f},
  {"SPSR_fs",	false, PSR_f | PSR_s},
  {"SPSR_fx",	false, PSR_f | PSR_x},
  {"SPSR_fc",	false, PSR_f | PSR_c},
  {"SPSR_sf",	false, PSR_s | PSR_f},
  {"SPSR_sx",	false, PSR_s | PSR_x},
  {"SPSR_sc",	false, PSR_s | PSR_c},
  {"SPSR_xf",	false, PSR_x | PSR_f},
  {"SPSR_xs",	false, PSR_x | PSR_s},
  {"SPSR_xc",	false, PSR_x | PSR_c},
  {"SPSR_cf",	false, PSR_c | PSR_f},
  {"SPSR_cs",	false, PSR_c | PSR_s},
  {"SPSR_cx",	false, PSR_c | PSR_x},
  {"SPSR_fsx",	false, PSR_f | PSR_s | PSR_x},
  {"SPSR_fsc",	false, PSR_f | PSR_s | PSR_c},
  {"SPSR_fxs",	false, PSR_f | PSR_x | PSR_s},
  {"SPSR_fxc",	false, PSR_f | PSR_x | PSR_c},
  {"SPSR_fcs",	false, PSR_f | PSR_c | PSR_s},
  {"SPSR_fcx",	false, PSR_f | PSR_c | PSR_x},
  {"SPSR_sfx",	false, PSR_s | PSR_f | PSR_x},
  {"SPSR_sfc",	false, PSR_s | PSR_f | PSR_c},
  {"SPSR_sxf",	false, PSR_s | PSR_x | PSR_f},
  {"SPSR_sxc",	false, PSR_s | PSR_x | PSR_c},
  {"SPSR_scf",	false, PSR_s | PSR_c | PSR_f},
  {"SPSR_scx",	false, PSR_s | PSR_c | PSR_x},
  {"SPSR_xfs",	false, PSR_x | PSR_f | PSR_s},
  {"SPSR_xfc",	false, PSR_x | PSR_f | PSR_c},
  {"SPSR_xsf",	false, PSR_x | PSR_s | PSR_f},
  {"SPSR_xsc",	false, PSR_x | PSR_s | PSR_c},
  {"SPSR_xcf",	false, PSR_x | PSR_c | PSR_f},
  {"SPSR_xcs",	false, PSR_x | PSR_c | PSR_s},
  {"SPSR_cfs",	false, PSR_c | PSR_f | PSR_s},
  {"SPSR_cfx",	false, PSR_c | PSR_f | PSR_x},
  {"SPSR_csf",	false, PSR_c | PSR_s | PSR_f},
  {"SPSR_csx",	false, PSR_c | PSR_s | PSR_x},
  {"SPSR_cxf",	false, PSR_c | PSR_x | PSR_f},
  {"SPSR_cxs",	false, PSR_c | PSR_x | PSR_s},
  {"SPSR_fsxc",	false, PSR_f | PSR_s | PSR_x | PSR_c},
  {"SPSR_fscx",	false, PSR_f | PSR_s | PSR_c | PSR_x},
  {"SPSR_fxsc",	false, PSR_f | PSR_x | PSR_s | PSR_c},
  {"SPSR_fxcs",	false, PSR_f | PSR_x | PSR_c | PSR_s},
  {"SPSR_fcsx",	false, PSR_f | PSR_c | PSR_s | PSR_x},
  {"SPSR_fcxs",	false, PSR_f | PSR_c | PSR_x | PSR_s},
  {"SPSR_sfxc",	false, PSR_s | PSR_f | PSR_x | PSR_c},
  {"SPSR_sfcx",	false, PSR_s | PSR_f | PSR_c | PSR_x},
  {"SPSR_sxfc",	false, PSR_s | PSR_x | PSR_f | PSR_c},
  {"SPSR_sxcf",	false, PSR_s | PSR_x | PSR_c | PSR_f},
  {"SPSR_scfx",	false, PSR_s | PSR_c | PSR_f | PSR_x},
  {"SPSR_scxf",	false, PSR_s | PSR_c | PSR_x | PSR_f},
  {"SPSR_xfsc",	false, PSR_x | PSR_f | PSR_s | PSR_c},
  {"SPSR_xfcs",	false, PSR_x | PSR_f | PSR_c | PSR_s},
  {"SPSR_xsfc",	false, PSR_x | PSR_s | PSR_f | PSR_c},
  {"SPSR_xscf",	false, PSR_x | PSR_s | PSR_c | PSR_f},
  {"SPSR_xcfs",	false, PSR_x | PSR_c | PSR_f | PSR_s},
  {"SPSR_xcsf",	false, PSR_x | PSR_c | PSR_s | PSR_f},
  {"SPSR_cfsx",	false, PSR_c | PSR_f | PSR_s | PSR_x},
  {"SPSR_cfxs",	false, PSR_c | PSR_f | PSR_x | PSR_s},
  {"SPSR_csfx",	false, PSR_c | PSR_s | PSR_f | PSR_x},
  {"SPSR_csxf",	false, PSR_c | PSR_s | PSR_x | PSR_f},
  {"SPSR_cxfs",	false, PSR_c | PSR_x | PSR_f | PSR_s},
  {"SPSR_cxsf",	false, PSR_c | PSR_x | PSR_s | PSR_f},
d432 1
a432 1
/* ARM instructions.  */
d440 1
a440 1
/* Pseudo Op codes.  */
d444 1
a444 1
/* ARM 2.  */
d447 1
a447 1
/* ARM 3.  */
d449 1
a449 1
/* ARM 6.  */
d452 1
a452 1
/* ARM 7M.  */
d454 1
a454 1
/* ARM THUMB.  */
d457 2
a458 26
/* ARM_EXT_XScale.  */
static void do_mia		PARAMS ((char *, unsigned long));
static void do_mar		PARAMS ((char *, unsigned long));
static void do_mra		PARAMS ((char *, unsigned long));
static void do_pld		PARAMS ((char *, unsigned long));
static void do_ldrd		PARAMS ((char *, unsigned long));

/* ARM_EXT_V5.  */
static void do_blx		PARAMS ((char *, unsigned long));
static void do_bkpt		PARAMS ((char *, unsigned long));
static void do_clz		PARAMS ((char *, unsigned long));
static void do_lstc2		PARAMS ((char *, unsigned long));
static void do_cdp2		PARAMS ((char *, unsigned long));
static void do_co_reg2		PARAMS ((char *, unsigned long));

static void do_t_blx		PARAMS ((char *));
static void do_t_bkpt		PARAMS ((char *));

/* ARM_EXT_V5E.  */
static void do_smla		PARAMS ((char *, unsigned long));
static void do_smlal		PARAMS ((char *, unsigned long));
static void do_smul		PARAMS ((char *, unsigned long));
static void do_qadd		PARAMS ((char *, unsigned long));
static void do_co_reg2c		PARAMS ((char *, unsigned long));

/* Coprocessor Instructions.  */
d515 2
a516 9
/* LONGEST_INST is the longest basic instruction name without
   conditions or flags.  ARM7M has 4 of length 5.  El Segundo
   has one basic instruction name of length 7 (SMLALxy).  */
#define LONGEST_INST 7

struct asm_opcode
{
  /* Basic string to match.  */
  CONST char * template;
d518 1
a518 2
  /* Basic instruction code.  */
  unsigned long value;
a519 3
  /* Compulsory suffix that must follow conds.  If "", then the
     instruction is not conditional and must have no suffix.  */
  CONST char * comp_suffix;
d521 4
a524 2
  /* Bits to toggle if flag 'n' set.  */
  CONST struct asm_flg * flags;
d526 3
a528 2
  /* Which CPU variants this exists for.  */
  unsigned long variants;
d530 4
a533 2
  /* Function to call to parse args.  */
  void (* parms) PARAMS ((char *, unsigned long));
d536 1
a536 1
static CONST struct asm_opcode insns[] =
d538 1
a538 14
/* Intel XScale extensions to ARM V5 ISA.  */
  {"mia",   0x0e200010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miaph", 0x0e280010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miabb", 0x0e2c0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miabt", 0x0e2d0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miatb", 0x0e2e0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"miatt", 0x0e2f0010, NULL,   NULL,        ARM_EXT_XSCALE, do_mia},
  {"mar",   0x0c400000, NULL,   NULL,        ARM_EXT_XSCALE, do_mar},
  {"mra",   0x0c500000, NULL,   NULL,        ARM_EXT_XSCALE, do_mra},
  {"pld",   0xf450f000, "",     NULL,        ARM_EXT_XSCALE, do_pld},
  {"ldr",   0x000000d0, NULL,   ldr_flags,   ARM_ANY,        do_ldrd},
  {"str",   0x000000f0, NULL,   str_flags,   ARM_ANY,        do_ldrd},

/* ARM Instructions.  */
d567 2
a568 2

/* Pseudo ops.  */
d573 1
a573 1
/* ARM 2 multiplies.  */
d577 1
a577 1
/* ARM 3 - swp instructions.  */
d580 1
a580 1
/* ARM 6 Coprocessor instructions.  */
d587 5
a591 5
/* ARM 7M long multiplies - need signed/unsigned flags!  */
  {"smull", 0x00c00090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
  {"umull", 0x00800090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
  {"smlal", 0x00e00090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
  {"umlal", 0x00a00090, NULL,   s_flag,      ARM_EXT_LONGMUL,  do_mull},
d593 2
a594 2
/* ARM THUMB interworking.  */
  {"bx",    0x012fff10, NULL,   NULL,        ARM_EXT_THUMB,    do_bx},
d596 1
a596 1
/* Floating point instructions.  */
a649 42

/*  ARM ISA extension 5.  */
/* Note: blx is actually 2 opcodes, so the .value is set dynamically.
   And it's sometimes conditional and sometimes not.  */
  {"blx",            0, NULL,   NULL,        ARM_EXT_V5, do_blx},
  {"clz",   0x016f0f10, NULL,   NULL,        ARM_EXT_V5, do_clz},
  {"bkpt",  0xe1200070, "",   	NULL,        ARM_EXT_V5, do_bkpt},
  {"ldc2",  0xfc100000, "",  	cplong_flag, ARM_EXT_V5, do_lstc2},
  {"stc2",  0xfc000000, "",  	cplong_flag, ARM_EXT_V5, do_lstc2},
  {"cdp2",  0xfe000000, "",  	NULL,        ARM_EXT_V5, do_cdp2},
  {"mcr2",  0xfe000010, "",  	NULL,        ARM_EXT_V5, do_co_reg2},
  {"mrc2",  0xfe100010, "",  	NULL,        ARM_EXT_V5, do_co_reg2},

/*  ARM ISA extension 5E, El Segundo.  */
  {"smlabb", 0x01000080, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlatb", 0x010000a0, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlabt", 0x010000c0, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlatt", 0x010000e0, NULL,   NULL,        ARM_EXT_V5E, do_smla},

  {"smlawb", 0x01200080, NULL,   NULL,        ARM_EXT_V5E, do_smla},
  {"smlawt", 0x012000c0, NULL,   NULL,        ARM_EXT_V5E, do_smla},

  {"smlalbb",0x01400080, NULL,   NULL,        ARM_EXT_V5E, do_smlal},
  {"smlaltb",0x014000a0, NULL,   NULL,        ARM_EXT_V5E, do_smlal},
  {"smlalbt",0x014000c0, NULL,   NULL,        ARM_EXT_V5E, do_smlal},
  {"smlaltt",0x014000e0, NULL,   NULL,        ARM_EXT_V5E, do_smlal},

  {"smulbb", 0x01600080, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smultb", 0x016000a0, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smulbt", 0x016000c0, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smultt", 0x016000e0, NULL,   NULL,        ARM_EXT_V5E, do_smul},

  {"smulwb", 0x012000a0, NULL,   NULL,        ARM_EXT_V5E, do_smul},
  {"smulwt", 0x012000e0, NULL,   NULL,        ARM_EXT_V5E, do_smul},

  {"qadd",   0x01000050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},
  {"qdadd",  0x01400050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},
  {"qsub",   0x01200050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},
  {"qdsub",  0x01600050, NULL,   NULL,        ARM_EXT_V5E, do_qadd},

  {"mcrr",  0x0c400000, NULL,   NULL,         ARM_EXT_V5E, do_co_reg2c},
  {"mrrc",  0x0c500000, NULL,   NULL,         ARM_EXT_V5E, do_co_reg2c},
d789 1
a789 1
struct thumb_opcode
d791 5
a795 13
  /* Basic string to match.  */
  CONST char * template;

  /* Basic instruction code.  */
  unsigned long value;

  int size;

  /* Which CPU variants this exists for.  */
  unsigned long variants;

  /* Function to call to parse args.  */
  void (* parms) PARAMS ((char *));
d800 58
a857 60
  {"adc",	0x4140,		2,	ARM_EXT_THUMB, do_t_arit},
  {"add",	0x0000,		2,	ARM_EXT_THUMB, do_t_add},
  {"and",	0x4000,		2,	ARM_EXT_THUMB, do_t_arit},
  {"asr",	0x0000,		2,	ARM_EXT_THUMB, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_EXT_THUMB, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_EXT_THUMB, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_EXT_THUMB, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_EXT_THUMB, do_t_branch23},
  {"blx",	0,		0,	ARM_EXT_V5, do_t_blx},
  {"bkpt",	0xbe00,		2,	ARM_EXT_V5, do_t_bkpt},
  {"bx",	0x4700,		2,	ARM_EXT_THUMB, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_EXT_THUMB, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_EXT_THUMB, do_t_compare},
  {"eor",	0x4040,		2,	ARM_EXT_THUMB, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_EXT_THUMB, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_EXT_THUMB, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_EXT_THUMB, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_EXT_THUMB, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_EXT_THUMB, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_EXT_THUMB, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_EXT_THUMB, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_EXT_THUMB, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_EXT_THUMB, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_EXT_THUMB, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_EXT_THUMB, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_EXT_THUMB, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_EXT_THUMB, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_EXT_THUMB, do_t_arit},
  {"orr",	0x4300,		2,	ARM_EXT_THUMB, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_EXT_THUMB, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_EXT_THUMB, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_EXT_THUMB, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_EXT_THUMB, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_EXT_THUMB, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_EXT_THUMB, do_t_str},
  {"strb",	0x0000,		2,	ARM_EXT_THUMB, do_t_strb},
  {"strh",	0x0000,		2,	ARM_EXT_THUMB, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_EXT_THUMB, do_t_swi},
  {"sub",	0x0000,		2,	ARM_EXT_THUMB, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_EXT_THUMB, do_t_arit},
  /* Pseudo ops:  */
  {"adr",       0x0000,         2,      ARM_EXT_THUMB, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_EXT_THUMB, do_t_nop},      /* mov r8,r8  */
d874 1
a874 1
/* These are the standard names.  Users can add aliases with .req.  */
a913 1
#define ERR_NO_ACCUM	_("acc0 expected")
d915 3
a917 3
static struct hash_control * arm_ops_hsh   = NULL;
static struct hash_control * arm_tops_hsh  = NULL;
static struct hash_control * arm_cond_hsh  = NULL;
d919 2
a920 2
static struct hash_control * arm_reg_hsh   = NULL;
static struct hash_control * arm_psr_hsh   = NULL;
d950 1
a950 2
  /* Never called becasue '.req' does not start line.  */
  { "req",         s_req,         0 },
d965 1
a965 1
#ifdef OBJ_ELF
a971 2
  { "file",        dwarf2_directive_file, 0 },
  { "loc",         dwarf2_directive_loc,  0 },
d994 1
a994 1
/* Literal stuff.  */
d1000 2
a1001 2
  struct expressionS exp;
  struct arm_it *    inst;
d1004 3
a1006 8
literalT literals[MAX_LITERAL_POOL_SIZE];

/* Next free entry in the pool.  */
int next_literal_pool_place = 0;

/* Next literal pool number.  */
int lit_pool_num = 1;

d1022 4
a1025 14
	  && inst.reloc.exp.X_op == O_constant
	  && (literals[lit_count].exp.X_add_number
	      == inst.reloc.exp.X_add_number)
	  && literals[lit_count].exp.X_unsigned == inst.reloc.exp.X_unsigned)
	break;

      if (literals[lit_count].exp.X_op == inst.reloc.exp.X_op
          && inst.reloc.exp.X_op == O_symbol
          && (literals[lit_count].exp.X_add_number
	      == inst.reloc.exp.X_add_number)
          && (literals[lit_count].exp.X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
          && (literals[lit_count].exp.X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
a1026 1

d1030 1
a1030 1
  if (lit_count == next_literal_pool_place) /* New entry.  */
d1032 5
a1036 5
      if (next_literal_pool_place >= MAX_LITERAL_POOL_SIZE)
	{
	  inst.error = _("Literal Pool Overflow");
	  return FAIL;
	}
d1048 1
a1048 1

a1050 1

d1053 5
a1057 5
     symbolS *    symbolP;
     CONST char * name;		/* It is copied, the caller can modify.  */
     segT         segment;	/* Segment identifier (SEG_<something>).  */
     valueT       valu;		/* Symbol value.  */
     fragS *      frag;		/* Associated fragment.  */
d1062 1
a1062 1
  name_length = strlen (name) + 1;   /* +1 for \0.  */
d1097 1
a1097 1

d1100 1
a1100 1
#endif /* DEBUG_SYMS  */
d1103 2
a1104 3
/* Check that an immediate is valid.
   If so, convert it to the right format.  */

d1111 1
a1111 1

d1113 1
a1113 1

d1116 2
a1117 2
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */

a1123 1

d1126 1
a1126 1
     unsigned int   val;
d1131 1
a1131 1

d1145 1
d1151 1
d1157 1
a1157 1

d1167 1
a1167 1
    return FAIL;
d1171 1
d1184 1
a1184 1
     marking in_bss, then looking at s_skip for clues.  */
d1193 1
a1193 2
  /* Never make frag if expect extra pass.  */
  if (!need_pass_2)
d1195 1
a1195 1

d1197 1
a1197 1

d1211 2
a1212 2
  /* Align pool as you have word accesses.
     Only make a frag if we have to.  */
d1225 1
a1225 1

d1229 1
a1229 1

d1232 1
a1232 1
    emit_expr (&(literals[lit_count++].exp), 4); /* .word  */
a1237 2
/* Same as s_align_ptwo but align 0 => align 2.  */

d1239 1
a1239 1
s_align (unused)
d1266 1
a1266 1
  /* Only make a frag if we HAVE to.  */
d1283 1
d1287 1
a1287 1

d1290 1
a1290 1

a1297 3
  if (! thumb_mode)
    opcode_select (16);

d1300 1
d1302 1
a1302 1

d1321 5
a1325 3
  /* Especial apologies for the random logic:
     This just grew, and could be parsed much more simply!
     Dean - in haste.  */
d1330 1
a1330 1

d1347 1
a1347 1
      /* XXX - this should not happen to .thumb_set.  */
d1361 2
a1362 3
	  fragS * dummy_frag = (fragS *) xmalloc (sizeof (fragS));

	  memset (dummy_frag, 0, sizeof (fragS));
d1370 2
a1371 2
	symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);

d1373 1
a1373 1
      /* "set" symbols are local unless otherwise specified.  */
d1375 2
a1376 2
#endif /* OBJ_COFF  */
    }				/* Make a new symbol.  */
d1388 1
a1388 1

d1392 1
a1392 1

a1400 1

d1407 1
a1407 1

d1426 1
a1426 1

d1454 1
a1454 1
	  if (! (cpu_variant & ARM_EXT_THUMB))
a1455 1

d1457 3
a1459 3
	  /* No need to force the alignment, since we will have been
             coming from ARM mode, which is word-aligned.  */
	  record_alignment (now_seg, 1);
d1466 1
a1466 1
	  if ((cpu_variant & ARM_ANY) == ARM_EXT_THUMB)
a1467 1

d1469 1
a1469 2

	  if (!need_pass_2)
a1470 1

d1529 1
a1529 1
  char * p = * str, c;
d1531 1
a1531 1

d1547 2
a1548 2
   SHIFT is the place to put it in inst.instruction.
   Restores input start point on error.
a1549 1

d1555 3
a1557 3
  static char buff [128]; /* XXX  */
  int         reg;
  char *      start = * str;
d1568 1
a1568 1

a1597 7
  /* CPSR's and SPSR's can now be lowercase.  This is just a convenience
     feature for ease of use and backwards compatibility.  */
  if (!strncmp (start, "cpsr", 4))
    strncpy (start, "CPSR", 4);
  else if (!strncmp (start, "spsr", 4))
    strncpy (start, "SPSR", 4);

a1611 1

d1616 1
a1616 1
  char * start = * str;
d1618 1
a1618 1

d1629 1
a1629 1

d1739 2
a1740 2
  int    reg;
  char * start = * str;
d1773 1
a1773 1

d1776 1
a1776 1

d1780 1
a1780 1

d1829 1
a1829 1

d1832 1
a1832 1
	      /* [Rn], #expr  */
d1834 1
a1834 1

d1849 1
a1849 1
	  /* '['Rn, #expr']'[!]  */
d1858 1
a1858 1

d1891 1
a1891 1
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust.  */
d1919 1
a1919 1

a1942 1

d1944 1
a1944 1
  else if (   strcmp (str, "cpsr_all") == 0
d1956 1
a1956 1

a1963 1

d1973 1
a1973 1

d1984 1
a1984 1
      inst.error = NULL;
d1992 1
a1992 2
      inst.error =
	_("only a register or immediate value can follow a psr flag");
d1998 1
a1998 1

d2001 1
a2001 2
      inst.error =
	_("only a register or immediate value can follow a psr flag");
d2004 2
a2005 7

#if 0  /* The first edition of the ARM architecture manual stated that
	  writing anything other than the flags with an immediate operation
	  had UNPREDICTABLE effects.  This constraint was removed in the
	  second edition of the specification.  */
  if ((cpu_variant & ARM_EXT_V5) != ARM_EXT_V5
      && inst.instruction & ((PSR_c | PSR_x | PSR_s) << PSR_SHIFT))
d2007 1
a2007 1
      inst.error = _("immediate value cannot be used to set this field");
d2010 1
a2010 2
#endif

d2012 1
a2012 1

d2021 1
a2021 1

d2027 1
a2027 1

d2031 1
a2031 1
  inst.error = NULL;
d2040 2
a2041 2
   SMLAL RdLo, RdHi, Rm, Rs.  */

d2049 1
a2049 1
  /* Only one format "rdlo, rdhi, rm, rs".  */
d2072 1
a2072 1
  /* rdhi, rdlo and rm must all be different.  */
d2088 1
a2088 1

d2096 1
a2096 1
     char * str;
d2100 2
a2101 2

  /* Only one format "rd, rm, rs".  */
d2152 1
a2152 1
     char * str;
d2157 1
a2157 1
  /* Only one format "rd, rm, rs, rn".  */
d2208 2
a2209 7
/* Expects *str -> the characters "acc0", possibly with leading blanks.
   Advances *str to the next non-alphanumeric.
   Returns 0, or else FAIL (in which case sets inst.error).

  (In a future XScale, there may be accumulators other than zero.
  At that time this routine and its callers can be upgraded to suit.)  */

d2211 1
a2211 1
accum0_required_here (str)
d2214 5
a2218 4
  static char buff [128];	/* Note the address is taken.  Hence, static.  */
  char * p = * str;
  char   c;
  int result = 0;		/* The accum number.  */
d2220 12
a2231 1
  skip_whitespace (p);
d2233 7
a2239 4
  *str = p;			/* Advance caller's string pointer too.  */
  c = *p++;
  while (isalnum (c))
    c = *p++;
d2241 19
a2259 1
  *--p = 0;			/* Aap nul into input buffer at non-alnum.  */
d2261 8
a2268 5
  if (! ( streq (*str, "acc0") || streq (*str, "ACC0")))
    {
      sprintf (buff, _("acc0 expected, not '%.100s'"), *str);
      inst.error = buff;
      result = FAIL;
d2271 3
a2273 3
  *p = c;			/* Unzap.  */
  *str = p;			/* Caller's string pointer to after match.  */
  return result;
d2276 1
a2276 7
/* Expects **str -> after a comma. May be leading blanks.
   Advances *str, recognizing a load  mode, and setting inst.instruction.
   Returns rn, or else FAIL (in which case may set inst.error
   and not advance str)

   Note: doesn't know Rd, so no err checks that require such knowledge.  */

d2278 2
a2279 2
ld_mode_required_here (string)
     char ** string;
d2281 2
a2282 3
  char * str = * string;
  int    rn;
  int    pre_inc = 0;
d2284 1
a2284 3
  skip_whitespace (str);

  if (* str == '[')
d2286 4
a2289 1
      str++;
d2291 2
a2292 1
      skip_whitespace (str);
d2294 11
a2304 2
      if ((rn = reg_required_here (& str, 16)) == FAIL)
	return FAIL;
d2306 13
a2318 1115
      skip_whitespace (str);

      if (* str == ']')
	{
	  str ++;

	  if (skip_past_comma (& str) == SUCCESS)
	    {
	      /* [Rn],... (post inc) */
	      if (ldst_extend (& str, 1) == FAIL)
		return FAIL;
	    }
	  else 	      /* [Rn] */
	    {
              skip_whitespace (str);

              if (* str == '!')
               {
                 str ++;
                 inst.instruction |= WRITE_BACK;
               }

	      inst.instruction |= INDEX_UP | HWOFFSET_IMM;
	      pre_inc = 1;
	    }
	}
      else	  /* [Rn,...] */
	{
	  if (skip_past_comma (& str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return FAIL;
	    }

	  pre_inc = 1;

	  if (ldst_extend (& str, 1) == FAIL)
	    return FAIL;

	  skip_whitespace (str);

	  if (* str ++ != ']')
	    {
	      inst.error = _("missing ]");
	      return FAIL;
	    }

	  skip_whitespace (str);

	  if (* str == '!')
	    {
	      str ++;
	      inst.instruction |= WRITE_BACK;
	    }
	}
    }
  else if (* str == '=')	/* ldr's "r,=label" syntax */
    /* We should never reach here, because <text> = <expression> is
       caught gas/read.c read_a_source_file() as a .set operation.  */
    return FAIL;
  else				/* PC +- 8 bit immediate offset.  */
    {
      if (my_get_expression (& inst.reloc.exp, & str))
	return FAIL;

      inst.instruction            |= HWOFFSET_IMM;	/* The I bit.  */
      inst.reloc.type              = BFD_RELOC_ARM_OFFSET_IMM8;
      inst.reloc.exp.X_add_number -= 8;  		/* PC rel adjust.  */
      inst.reloc.pc_rel            = 1;
      inst.instruction            |= (REG_PC << 16);

      rn = REG_PC;
      pre_inc = 1;
    }

  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  * string = str;

  return rn;
}

/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)
   SMLAxy{cond} Rd,Rm,Rs,Rn
   SMLAWy{cond} Rd,Rm,Rs,Rn
   Error if any register is R15.  */

static void
do_smla (str, flags)
     char *        str;
     unsigned long flags;
{
  int rd, rm, rs, rn;

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC || rs == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;

  else if (flags)
    inst.error = BAD_FLAGS;

  else
    end_of_line (str);
}

/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)
   SMLALxy{cond} Rdlo,Rdhi,Rm,Rs
   Error if any register is R15.
   Warning if Rdlo == Rdhi.  */

static void
do_smlal (str, flags)
     char *        str;
     unsigned long flags;
{
  int rdlo, rdhi, rm, rs;

  skip_whitespace (str);

  if ((rdlo = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rdhi = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rdlo == REG_PC || rdhi == REG_PC || rm == REG_PC || rs == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  if (rdlo == rdhi)
    as_tsktsk (_("rdhi and rdlo must be different"));

  if (flags)
    inst.error = BAD_FLAGS;
  else
    end_of_line (str);
}

/* ARM V5E (El Segundo) signed-multiply (argument parse)
   SMULxy{cond} Rd,Rm,Rs
   Error if any register is R15.  */

static void
do_smul (str, flags)
     char *        str;
     unsigned long flags;
{
  int rd, rm, rs;

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;

  else if (flags)
    inst.error = BAD_FLAGS;

  else
    end_of_line (str);
}

/* ARM V5E (El Segundo) saturating-add/subtract (argument parse)
   Q[D]{ADD,SUB}{cond} Rd,Rm,Rn
   Error if any register is R15.  */

static void
do_qadd (str, flags)
     char *        str;
     unsigned long flags;
{
  int rd, rm, rn;

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;

  else if (flags)
    inst.error = BAD_FLAGS;

  else
    end_of_line (str);
}

/* ARM V5E (el Segundo)
   MCRRcc <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
   MRRCcc <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.

   These are equivalent to the XScale instructions MAR and MRA,
   respectively, when coproc == 0, opcode == 0, and CRm == 0.

   Result unpredicatable if Rd or Rn is R15.  */

static void
do_co_reg2c (str, flags)
     char *        str;
     unsigned long flags;
{
  int rd, rn;

  skip_whitespace (str);

  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 4, 4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || (rd = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 16)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* Unpredictable result if rd or rn is R15.  */
  if (rd == REG_PC || rn == REG_PC)
    as_tsktsk
      (_("Warning: Instruction unpredictable when using r15"));

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (flags)
    inst.error = BAD_COND;

  end_of_line (str);
}

/* ARM V5 count-leading-zeroes instruction (argument parse)
     CLZ{<cond>} <Rd>, <Rm>
     Condition defaults to COND_ALWAYS.
     Error if Rd or Rm are R15.  */

static void
do_clz (str, flags)
     char *        str;
     unsigned long flags;
{
  int rd, rm;

  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

  skip_whitespace (str);

  if (((rd = reg_required_here (& str, 12)) == FAIL)
      || (skip_past_comma (& str) == FAIL)
      || ((rm = reg_required_here (& str, 0)) == FAIL))
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC )
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V5 (argument parse)
     LDC2{L} <coproc>, <CRd>, <addressing mode>
     STC2{L} <coproc>, <CRd>, <addressing mode>
     Instruction is not conditional, and has 0xf in the codition field.
     Otherwise, it's the same as LDC/STC.  */

static void
do_lstc2 (str, flags)
     char *        str;
     unsigned long flags;
{
  if (flags)
    inst.error = BAD_COND;

  skip_whitespace (str);

  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else if (skip_past_comma (& str) == FAIL
	   || cp_reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else if (skip_past_comma (& str) == FAIL
	   || cp_address_required_here (& str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}

/* ARM V5 (argument parse)
     CDP2 <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as CDP.  */

static void
do_cdp2 (str, flags)
     char *        str;
     unsigned long flags;
{
  skip_whitespace (str);

  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 20,4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  if (flags)
    inst.error = BAD_FLAGS;

  end_of_line (str);
}

/* ARM V5 (argument parse)
     MCR2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     MRC2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as MCR/MRC.  */

static void
do_co_reg2 (str, flags)
     char *        str;
     unsigned long flags;
{
  skip_whitespace (str);

  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 21, 3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  if (flags)
    inst.error = BAD_COND;

  end_of_line (str);
}

/* THUMB V5 breakpoint instruction (argument parse)
	BKPT <immed_8>.  */

static void
do_t_bkpt (str)
     char * str;
{
  expressionS expr;
  unsigned long number;

  skip_whitespace (str);

  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str ++;

  memset (& expr, '\0', sizeof (expr));
  if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
    {
      inst.error = _("bad or missing expression");
      return;
    }

  number = expr.X_add_number;

  /* Check it fits an 8 bit unsigned.  */
  if (number != (number & 0xff))
    {
      inst.error = _("immediate value out of range");
      return;
    }

  inst.instruction |= number;

  end_of_line (str);
}

/* ARM V5 branch-link-exchange (argument parse) for BLX(1) only.
   Expects inst.instruction is set for BLX(1).
   Note: this is cloned from do_branch, and the reloc changed to be a
	new one that can cope with setting one extra bit (the H bit).  */

static void
do_branch25 (str, flags)
     char *        str;
     unsigned long flags ATTRIBUTE_UNUSED;
{
  if (my_get_expression (& inst.reloc.exp, & str))
    return;

#ifdef OBJ_ELF
  {
    char * save_in;

    /* ScottB: February 5, 1998 */
    /* Check to see of PLT32 reloc required for the instruction.  */

    /* arm_parse_reloc() works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;

    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BLX;
	inst.reloc.pc_rel = 1;
      }

    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BLX;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF */

  end_of_line (str);
}

/* ARM V5 branch-link-exchange instruction (argument parse)
     BLX <target_addr>		ie BLX(1)
     BLX{<condition>} <Rm>	ie BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
   Also, the <target_addr> can be 25 bits, hence has its own reloc.  */

static void
do_blx (str, flags)
     char *        str;
     unsigned long flags;
{
  char * mystr = str;
  int rm;

  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

  skip_whitespace (mystr);
  rm = reg_required_here (& mystr, 0);

  /* The above may set inst.error.  Ignore his opinion.  */
  inst.error = 0;

  if (rm != FAIL)
    {
      /* Arg is a register.
	 Use the condition code our caller put in inst.instruction.
	 Pass ourselves off as a BX with a funny opcode.  */
      inst.instruction |= 0x012fff30;
      do_bx (str, flags);
    }
  else
    {
      /* This must be is BLX <target address>, no condition allowed.  */
      if (inst.instruction != COND_ALWAYS)
    	{
      	  inst.error = BAD_COND;
	  return;
    	}

      inst.instruction = 0xfafffffe;

      /* Process like a B/BL, but with a different reloc.
	 Note that B/BL expecte fffffe, not 0, offset in the opcode table.  */
      do_branch25 (str, flags);
    }
}

/* ARM V5 Thumb BLX (argument parse)
	BLX <target_addr>	which is BLX(1)
	BLX <Rm>		which is BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the tinsns[].value is not used, and the code here zaps values
	into inst.instruction.	*/

static void
do_t_blx (str)
     char * str;
{
  char * mystr = str;
  int rm;

  skip_whitespace (mystr);
  inst.instruction = 0x4780;

  /* Note that this call is to the ARM register recognizer.  BLX(2)
     uses the ARM register space, not the Thumb one, so a call to
     thumb_reg() would be wrong.  */
  rm = reg_required_here (& mystr, 3);
  inst.error = 0;

  if (rm != FAIL)
    {
      /* It's BLX(2).  The .instruction was zapped with rm & is final.  */
      inst.size = 2;
    }
  else
    {
      /* No ARM register.  This must be BLX(1).  Change the .instruction.  */
      inst.instruction = 0xf7ffeffe;
      inst.size = 4;

      if (my_get_expression (& inst.reloc.exp, & mystr))
	return;

      inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BLX;
      inst.reloc.pc_rel = 1;
    }

  end_of_line (mystr);
}

/* ARM V5 breakpoint instruction (argument parse)
     BKPT <16 bit unsigned immediate>
     Instruction is not conditional.
	The bit pattern given in insns[] has the COND_ALWAYS condition,
	and it is an error if the caller tried to override that.
     Note "flags" is nonzero if a flag was supplied (which is an error).  */

static void
do_bkpt (str, flags)
     char *        str;
     unsigned long flags;
{
  expressionS expr;
  unsigned long number;

  skip_whitespace (str);

  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (* str))
    str++;

  memset (& expr, '\0', sizeof (expr));

  if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
    {
      inst.error = _("bad or missing expression");
      return;
    }

  number = expr.X_add_number;

  /* Check it fits a 16 bit unsigned.  */
  if (number != (number & 0xffff))
    {
      inst.error = _("immediate value out of range");
      return;
    }

  /* Top 12 of 16 bits to bits 19:8.  */
  inst.instruction |= (number & 0xfff0) << 4;

  /* Bottom 4 of 16 bits to bits 3:0.  */
  inst.instruction |= number & 0xf;

  end_of_line (str);

  if (flags)
    inst.error = BAD_FLAGS;
}

/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */

static void
do_mia (str, flags)
     char * str;
     unsigned long flags;
{
  int rs;
  int rm;

  if (flags)
    as_bad (BAD_FLAGS);

  else if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;

  else if (skip_past_comma (& str) == FAIL
	   || (rm = reg_required_here (& str, 0)) == FAIL)
    inst.error = BAD_ARGS;

  else if (skip_past_comma (& str) == FAIL
	   || (rs = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  /* inst.instruction has now been zapped with both rm and rs.  */
  else if (rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rm or rs is R15.  */

  else
    end_of_line (str);
}

/* Xscale move-accumulator-register (argument parse)

     MARcc   acc0,RdLo,RdHi.  */

static void
do_mar (str, flags)
     char * str;
     unsigned long flags;
{
  int rdlo, rdhi;

  if (flags)
    as_bad (BAD_FLAGS);

  else if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;

  else if (skip_past_comma (& str) == FAIL
	   || (rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;

  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */

  else
    end_of_line (str);
}

/* Xscale move-register-accumulator (argument parse)

     MRAcc   RdLo,RdHi,acc0.  */

static void
do_mra (str, flags)
     char * str;
     unsigned long flags;
{
  int rdlo;
  int rdhi;

  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

  skip_whitespace (str);

  if ((rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;

  else if  (skip_past_comma (& str) == FAIL
	    || accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;

  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == rdhi)
    inst.error = BAD_ARGS;	/* Undefined result if 2 writes to same reg.  */

  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */
  else
    end_of_line (str);
}

/* Xscale: Preload-Cache

    PLD <addr_mode>

  Syntactically, like LDR with B=1, W=0, L=1.  */

static void
do_pld (str, flags)
     char * str;
     unsigned long flags;
{
  int rd;

  if (flags)
    {
      as_bad (BAD_FLAGS);
      return;
    }

  skip_whitespace (str);

  if (* str != '[')
    {
      inst.error = _("'[' expected after PLD mnemonic");
      return;
    }

  ++ str;
  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 16)) == FAIL)
    return;

  skip_whitespace (str);

  if (* str == ']')
    {
      /* [Rn], ... ?  */
      ++ str;
      skip_whitespace (str);

      if (skip_past_comma (& str) == SUCCESS)
	{
	  if (ldst_extend (& str, 0) == FAIL)
	    return;
	}
      else if (* str == '!') /* [Rn]! */
	{
	  inst.error = _("writeback used in preload instruction");
	  ++ str;
	}
      else /* [Rn] */
	inst.instruction |= INDEX_UP | PRE_INDEX;
    }
  else /* [Rn, ...] */
    {
      if (skip_past_comma (& str) == FAIL)
	{
	  inst.error = _("pre-indexed expression expected");
	  return;
	}

      if (ldst_extend (& str, 0) == FAIL)
	return;

      skip_whitespace (str);

      if (* str != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}

      ++ str;
      skip_whitespace (str);

      if (* str == '!') /* [Rn]! */
	{
	  inst.error = _("writeback used in preload instruction");
	  ++ str;
	}

      inst.instruction |= PRE_INDEX;
    }

  end_of_line (str);
}

/* Xscale load-consecutive (argument parse)
   Mode is like LDRH.

     LDRccD R, mode
     STRccD R, mode.  */

static void
do_ldrd (str, flags)
     char * str;
     unsigned long flags;
{
  int rd;
  int rn;

  if (flags != DOUBLE_LOAD_FLAG)
    {
      /* Change instruction pattern to normal ldr/str.  */
      if (inst.instruction & 0x20)
	inst.instruction = (inst.instruction & COND_MASK) | 0x04000000; /* str */
      else
	inst.instruction = (inst.instruction & COND_MASK) | 0x04100000; /* ldr */

      /* Perform a normal load/store instruction parse.  */
      do_ldst (str, flags);

      return;
    }

  if ((cpu_variant & ARM_EXT_XSCALE) != ARM_EXT_XSCALE)
    {
      static char buff[128];

      --str;
      while (isspace (*str))
	--str;
      str -= 4;

      /* Deny all knowledge.  */
      sprintf (buff, _("bad instruction '%.100s'"), str);
      inst.error = buff;
      return;
    }

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 12)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || (rn = ld_mode_required_here (& str)) == FAIL)
    {
      if (!inst.error)
        inst.error = BAD_ARGS;
      return;
    }

  /* inst.instruction has now been zapped with Rd and the addressing mode.  */
  if (rd & 1)		/* Unpredictable result if Rd is odd.  */
    {
      inst.error = _("Destination register must be even");
      return;
    }

  if (rd == REG_LR || rd == 12)
    {
      inst.error = _("r12 or r14 not allowed here");
      return;
    }

  if (((rd == rn) || (rd + 1 == rn))
      &&
      ((inst.instruction & WRITE_BACK)
       || (!(inst.instruction & PRE_INDEX))))
    as_warn (_("pre/post-indexing used when modified address register is destination"));

  end_of_line (str);
}

/* Returns the index into fp_values of a floating point number,
   or -1 if not in the table.  */

static int
my_get_float_expression (str)
     char ** str;
{
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *         save_in;
  expressionS    exp;
  int            i;
  int            j;

  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));

  /* Look for a raw floating point number.  */
  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
      && is_end_of_line[(unsigned char) *save_in])
    {
      for (i = 0; i < NUM_FLOAT_VALS; i++)
	{
	  for (j = 0; j < MAX_LITTLENUMS; j++)
	    {
	      if (words[j] != fp_values[i][j])
		break;
	    }

	  if (j == MAX_LITTLENUMS)
	    {
	      *str = save_in;
	      return i;
	    }
	}
    }

  /* Try and parse a more complex expression, this will probably fail
     unless the code uses a floating point prefix (eg "0f").  */
  save_in = input_line_pointer;
  input_line_pointer = *str;
  if (expression (&exp) == absolute_section
      && exp.X_op == O_big
      && exp.X_add_number < 0)
    {
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.  */
      if (gen_to_words (words, 5, (long) 15) == 0)
	{
	  for (i = 0; i < NUM_FLOAT_VALS; i++)
	    {
	      for (j = 0; j < MAX_LITTLENUMS; j++)
		{
		  if (words[j] != fp_values[i][j])
		    break;
		}

	      if (j == MAX_LITTLENUMS)
		{
		  *str = input_line_pointer;
		  input_line_pointer = save_in;
		  return i;
		}
	    }
	}
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  return -1;
}

/* Return true if anything in the expression is a bignum.  */

static int
walk_no_bignums (sp)
     symbolS * sp;
{
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;

  if (symbol_get_value_expression (sp)->X_add_symbol)
    {
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
    }

  return 0;
}

static int
my_get_expression (ep, str)
     expressionS * ep;
     char ** str;
{
  char * save_in;
  segT   seg;

  save_in = input_line_pointer;
  input_line_pointer = *str;
  seg = expression (ep);

#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad_segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
#endif
d2340 2
a2341 2
/* UNRESTRICT should be one if <shift> <register> is permitted for this
   instruction.  */
d2348 1
a2348 1
  const struct asm_shift_name * shift;
d2351 1
a2351 1

d2353 2
a2354 2

  for (p = * str; isalpha (* p); p ++)
d2357 1
a2357 1
  if (p == * str)
d2363 5
a2367 6
  c = * p;
  * p = '\0';
  shift = (const struct asm_shift_name *) hash_find (arm_shift_hsh, * str);
  * p = c;

  if (shift == NULL)
d2369 7
a2375 3
      inst.error = _("Shift expression expected");
      return FAIL;
    }
d2377 14
a2390 1
  assert (shift->properties->index == shift_properties[shift->properties->index].index);
d2392 4
a2395 6
  if (shift->properties->index == SHIFT_RRX)
    {
      * str = p;
      inst.instruction |= shift->properties->bit_field;
      return SUCCESS;
    }
d2397 6
a2402 1
  skip_whitespace (p);
d2404 6
a2409 14
  if (unrestrict && reg_required_here (& p, 8) != FAIL)
    {
      inst.instruction |= shift->properties->bit_field | SHIFT_BY_REG;
      * str = p;
      return SUCCESS;
    }
  else if (! is_immediate_prefix (* p))
    {
      inst.error = (unrestrict
		    ? _("shift requires register or #expression")
		    : _("shift requires #expression"));
      * str = p;
      return FAIL;
    }
d2411 4
a2414 2
  inst.error = NULL;
  p ++;
d2416 4
a2419 2
  if (my_get_expression (& inst.reloc.exp, & p))
    return FAIL;
d2421 12
a2432 28
  /* Validate some simple #expressions.  */
  if (inst.reloc.exp.X_op == O_constant)
    {
      unsigned num = inst.reloc.exp.X_add_number;

      /* Reject operations greater than 32.  */
      if (num > 32
	  /* Reject a shift of 0 unless the mode allows it.  */
	  || (num == 0 && shift->properties->allows_0 == 0)
	  /* Reject a shift of 32 unless the mode allows it.  */
	  || (num == 32 && shift->properties->allows_32 == 0)
	  )
	{
	  /* As a special case we allow a shift of zero for
	     modes that do not support it to be recoded as an
	     logical shift left of zero (ie nothing).  We warn
	     about this though.  */
	  if (num == 0)
	    {
	      as_warn (_("Shift of 0 ignored."));
	      shift = & shift_names[0];
	      assert (shift->properties->index == SHIFT_LSL);
	    }
	  else
	    {
	      inst.error = _("Invalid immediate shift");
	      return FAIL;
	    }
a2433 13

      /* Shifts of 32 are encoded as 0, for those shifts that
	 support it.  */
      if (num == 32)
	num = 0;

      inst.instruction |= (num << 7) | shift->properties->bit_field;
    }
  else
    {
      inst.reloc.type   = BFD_RELOC_ARM_SHIFT_IMM;
      inst.reloc.pc_rel = 0;
      inst.instruction |= shift->properties->bit_field;
d2436 2
a2437 2
  * str = p;
  return SUCCESS;
d2440 3
a2442 3
/* Do those data_ops which can take a negative immediate constant
   by altering the instuction.  A bit of a hack really.
        MOV <-> MVN
d2448 2
a2449 2
        by negating the second operand.  */

d2464 2
a2465 2
      /* First negates.  */
    case OPCODE_SUB:             /* ADD <-> SUB  */
d2470 2
a2471 2
    case OPCODE_ADD:
      new_inst = OPCODE_SUB;
d2475 1
a2475 1
    case OPCODE_CMP:             /* CMP <-> CMN  */
d2480 2
a2481 2
    case OPCODE_CMN:
      new_inst = OPCODE_CMP;
d2485 3
a2487 3
      /* Now Inverted ops.  */
    case OPCODE_MOV:             /* MOV <-> MVN  */
      new_inst = OPCODE_MVN;
d2491 1
a2491 1
    case OPCODE_MVN:
d2496 2
a2497 2
    case OPCODE_AND:             /* AND <-> BIC  */
      new_inst = OPCODE_BIC;
d2501 1
a2501 1
    case OPCODE_BIC:
d2506 2
a2507 2
    case OPCODE_ADC:              /* ADC <-> SBC  */
      new_inst = OPCODE_SBC;
d2511 1
a2511 1
    case OPCODE_SBC:
d2516 2
a2517 2
      /* We cannot do anything.  */
    default:
d2526 1
a2526 1
  return value;
d2537 1
a2537 1

d2548 1
a2548 1
      /* Immediate expression.  */
d2553 1
a2553 1

d2566 1
a2566 1
		  /* #x, y -- ie explicit rotation by Y.  */
d2575 2
a2576 2

		  /* Rotate must be a multiple of 2.  */
d2590 1
a2590 1
	      /* Implicit rotation, select a suitable one.  */
d2595 2
a2596 2
		  /* Can't be done.  Perhaps the code reads something like
		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be OK.  */
d2629 1
a2629 1
      /* Immediate expression.  */
d2638 2
a2639 2
	  /* First try and match exact strings, this is to guarantee
	     that some formats will work even for cross assembly.  */
d2648 1
a2648 1
		  if (is_end_of_line[(unsigned char) **str])
d2670 1
a2670 2
      inst.error =
	_("Floating point register or immediate expression expected");
d2677 1
a2677 1
     char * str;
d2700 1
a2700 1
     char * str;
d2715 1
a2715 1

a2721 1

d2723 1
d2728 1
a2728 1
     char * str;
d2734 1
a2734 1
     	add rd, rd, #high(label-.-8)"  */
d2746 1
a2746 1

d2748 1
a2748 1

d2752 1
a2752 1
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
d2756 1
a2756 1

d2762 1
a2762 1
     char * str;
d2792 1
a2792 1
     char * str;
d2836 2
a2837 2
	  if ((hwse && (value < -255 || value > 255))
	      || (value < -4095 || value > 4095))
d2849 6
a2854 7
	  /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0.  */
	  if (hwse)
	    inst.instruction |= (add | HWOFFSET_IMM
				 | ((value >> 4) << 8) | (value & 0xF));
	  else
	    inst.instruction |= add | value;
d2858 7
a2864 7
	  if (hwse)
	    {
	      inst.instruction |= HWOFFSET_IMM;
	      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	    }
	  else
	    inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d2870 1
a2870 3
      add = 0;
      /* Fall through.  */

d2872 1
a2872 3
      (*str)++;
      /* Fall through.  */

d2878 1
a2878 1
	inst.instruction |= add;
d2880 5
a2884 5
	{
	  inst.instruction |= add | OFFSET_REG;
	  if (skip_past_comma (str) == SUCCESS)
	    return decode_shift (str, SHIFT_RESTRICT);
	}
d2902 1
a2902 1
     encoding, but the same mnemonic):  */
d2907 4
a2910 4
         signed-extension load.  */
      if ((cpu_variant & ARM_EXT_HALFWORD) == 0)
	{
	  inst.error
d2912 2
a2913 2
	  return;
	}
d2915 2
a2916 2
      inst.instruction = ((inst.instruction & COND_MASK)
			  | (flags & ~COND_MASK));
d2922 1
a2922 1

d2955 1
a2955 1

d2958 1
a2958 1
	      /* [Rn],... (post inc)  */
d2962 2
a2963 10
		{
		  if (flags & TRANS_BIT)
		    as_warn (_("Rn and Rd must be different in %s"),
			     ((inst.instruction & LOAD_BIT)
			      ? "LDRT" : "STRT"));
		  else
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		}
d2967 3
a2969 3
	      /* [Rn]  */
	      if (halfword)
		inst.instruction |= HWOFFSET_IMM;
d2971 1
a2971 1
	      skip_whitespace (str);
d2973 8
a2980 9
	      if (*str == '!')
		{
		  if (conflict_reg)
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		  str++;
		  inst.instruction |= WRITE_BACK;
		}
d2983 2
a2984 9
	      if (flags & TRANS_BIT)
		{
		  if (conflict_reg)
		    as_warn (_("Rn and Rd must be different in %s"),
			     ((inst.instruction & LOAD_BIT)
			      ? "LDRT" : "STRT"));
		}
		else
		  pre_inc = 1;
d2989 1
a2989 1
	  /* [Rn,...]  */
d3014 1
a3014 2
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
d3022 1
a3022 1
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
d3038 1
a3038 1
	  && (value = validate_immediate (inst.reloc.exp.X_add_number)) != FAIL)
d3040 1
a3040 1
	  /* This can be done with a mov instruction.  */
d3044 2
a3045 2
	  end_of_line (str);
	  return;
d3049 1
a3049 1
	  /* Insert into literal pool.  */
d3053 1
a3053 1
		inst.error = _("literal pool insertion failed");
d3057 7
a3063 7
	  /* Change the instruction exp to point to the pool.  */
	  if (halfword)
	    {
	      inst.instruction |= HWOFFSET_IMM;
	      inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
	    }
	  else
d3067 1
a3067 1
	  pre_inc = 1;
d3076 4
a3079 4
	{
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	}
d3081 1
a3081 1
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d3083 1
a3083 2
      /* PC rel adjust.  */
      inst.reloc.exp.X_add_number -= 8;
d3089 1
a3089 1

d3102 1
a3102 1
  char * str = * strp;
d3106 1
a3106 1
  /* We come back here if we get ranges concatenated by '+' or '|'.  */
d3115 1
a3115 1

d3120 1
a3120 1

d3125 1
a3125 1

d3129 1
a3129 1

d3139 1
a3139 1
			as_tsktsk
d3156 2
a3157 3
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
d3176 1
a3176 1
	      if (expr.X_add_number
d3189 1
a3189 1
		  as_tsktsk
d3217 1
a3217 2
    }
  while (another_range);
d3225 1
a3225 1
     char * str;
d3271 1
a3271 1
     char * str;
d3275 1
a3275 1

d3286 1
a3286 1

d3288 1
a3288 1

d3294 1
a3294 1
     char * str;
d3298 1
a3298 1

d3357 1
a3357 1
     char * str;
d3362 1
a3362 1

d3366 5
a3370 5

    /* ScottB: February 5, 1998 - Check to see of PLT32 reloc
       required for the instruction.  */

    /* arm_parse_reloc () works on input_line_pointer.
d3395 2
a3396 2
#endif /* OBJ_ELF  */

d3403 1
a3403 1
     char * str;
a3415 1
  /* Note - it is not illegal to do a "bx pc".  Useless, but not illegal.  */
d3417 1
a3417 1
    as_tsktsk (_("Use of r15 in bx in ARM mode is not really useful"));
d3424 1
a3424 1
     char * str;
d3486 1
a3486 1
     char * str;
d3524 1
a3524 1
     char * str;
d3591 1
a3591 1
     char * str;
d3612 1
a3612 1
     char * str;
d3654 1
a3654 1
     char * str;
d3668 1
a3668 1
  /* Get Number of registers to transfer.  */
d3747 1
a3747 2
	      inst.error =
		_("R15 not allowed as base register with write-back");
d3756 1
a3756 1
	  /* Pre-decrement.  */
d3763 1
a3763 1
	  /* Post-increment.  */
d3793 1
a3793 1
     char * str;
d3842 1
a3842 1
     char * str;
d3883 1
a3883 1
     char * str;
d3910 1
a3910 1
     char * str;
d3951 1
a3951 1
     char * str;
d3972 1
a3972 1
/* Thumb specific routines.  */
d3975 3
a3977 3
   repeated checking of this information in many similar cases.
   Unlike the 32-bit case we do not insert the register into the opcode
   here, since the position is often unknown until the full instruction
a3978 1

a4015 1

d4047 2
a4048 2
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
d4063 1
a4063 1
     for the latter case, EXPR contains the immediate that was found.  */
d4075 1
a4075 1
	  /* Can't do this for SUB.  */
d4109 1
a4109 1
	     we know about in the instruction and let the reloc hacking
d4126 1
a4126 1
	      /* Quick check, in case offset is MIN_INT.  */
d4180 1
a4180 1

d4211 1
a4211 1
      if ((Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
d4216 2
a4217 2
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
d4232 1
a4232 1
     for the latter case, EXPR contains the immediate that was found.  */
d4263 2
a4264 1
	     hacking fix it up.  */
d4277 1
a4277 1
	  /* Shifts of zero are handled by converting to LSL.  */
d4281 1
a4281 1
	  /* Shifts of 32 are encoded as a shift of zero.  */
d4290 1
a4290 1

d4326 1
a4326 1
	       since a MOV instruction produces unpredictable results.  */
d4432 1
a4432 1
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
d4441 1
a4441 1

d4452 1
a4452 1
	  /* This can be done with a mov instruction.  */
d4456 1
a4456 1
	  return;
d4459 1
a4459 1
      /* Insert into literal pool.  */
d4463 1
a4463 1
	    inst.error = "literal pool insertion failed";
d4470 1
a4470 2
      /* Adjust ARM pipeline offset to Thumb.  */
      inst.reloc.exp.X_add_number += 4;
d4481 1
a4481 1
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset.  */
d4535 1
a4535 1
      /* Immediate offset.  */
d4551 1
a4551 1

d4564 1
a4564 1
      /* Register offset.  */
d4585 1
a4585 1
  /* Do nothing.  */
d4590 1
a4590 1
/* Handle the Format 4 instructions that do not have equivalents in other
a4592 1

d4605 2
a4606 2
      inst.error = BAD_ARGS;
      return;
d4617 1
a4617 1
	  || inst.instruction == T_OPCODE_MVN)
d4628 1
a4628 1
	  inst.error = _("dest and source1 must be the same register");
d4688 1
a4688 1
  /* This definiton must agree with the one in gcc/config/arm/thumb.c.  */
d4692 1
a4692 1
    abort ();
d4699 1
a4699 1

d4704 1
a4704 1

d4716 1
d4723 1
a4723 1

d4736 1
a4736 2
    inst.reloc.exp.X_add_symbol =
      find_real_start (inst.reloc.exp.X_add_symbol);
d4794 1
a4794 1
      /* This really doesn't seem worth it.  */
d4894 1
a4894 1
      /* This really doesn't seem worth it.  */
d4988 1
a4988 1

d4996 2
a4997 2
  int    len  = strlen (reg_table[entry].name) + 2;
  char * buf  = (char *) xmalloc (len);
d4999 1
a4999 1
  int    i    = 0;
d5012 2
a5013 2
  hash_insert (arm_reg_hsh, buf,  (PTR) & reg_table[entry]);
  hash_insert (arm_reg_hsh, buf2, (PTR) & reg_table[entry]);
d5022 1
a5022 1
    (struct reg_entry *) xmalloc (sizeof (struct reg_entry));
d5038 1
a5038 1
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
d5047 1
a5047 1

d5055 1
a5055 1

d5062 2
a5063 2
  for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
    hash_insert (arm_shift_hsh, shift_names[i].name, (PTR) (shift_names + i));
d5075 1
a5075 1

a5083 18

    /* We have run out flags in the COFF header to encode the
       status of ATPCS support, so instead we create a dummy,
       empty, debug section called .arm.atpcs.  */
    if (atpcs)
      {
	asection * sec;

	sec = bfd_make_section (stdoutput, ".arm.atpcs");

	if (sec != NULL)
	  {
	    bfd_set_section_flags
	      (stdoutput, sec, SEC_READONLY | SEC_DEBUGGING /* | SEC_HAS_CONTENTS */);
	    bfd_set_section_size (stdoutput, sec, 0);
	    bfd_set_section_contents (stdoutput, sec, NULL, 0, 0);
	  }
      }
d5086 1
a5086 1

d5093 1
a5093 1

d5097 1
a5097 1

d5102 1
a5102 1

d5107 1
a5107 1

d5109 1
a5109 5
  if (cpu_variant & ARM_EXT_XSCALE)
    mach = bfd_mach_arm_XScale;
  else if (cpu_variant & ARM_EXT_V5E)
    mach = bfd_mach_arm_5TE;
  else if (cpu_variant & ARM_EXT_V5)
d5111 1
a5111 1
      if (cpu_variant & ARM_EXT_THUMB)
d5113 1
a5113 1
      else
d5115 1
a5115 4
    }
  else if (cpu_variant & ARM_EXT_HALFWORD)
    {
      if (cpu_variant & ARM_EXT_THUMB)
d5117 1
a5117 1
      else
d5119 2
d5122 1
a5122 3
  else if (cpu_variant & ARM_EXT_LONGMUL)
    mach = bfd_mach_arm_3M;

a5131 1

d5144 1
a5144 1
static valueT
d5147 1
a5147 1
     int    n;
d5173 2
a5174 2
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
d5256 1
a5256 3
/* The knowledge of the PC's pipeline offset is built into the insns
   themselves.  */

d5261 1
a5261 1
  if (fixP->fx_addsy
d5265 1
a5265 1

d5283 1
a5283 2
/* Round up a section size to the appropriate boundary.  */

d5292 1
a5292 1
  /* Round all sects to multiple of 4.  */
d5297 2
a5298 2
/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
   Otherwise we have no need to default values of symbols.  */
d5300 1
d5313 1
a5313 1

d5315 1
a5315 1
				   (valueT) 0, & zero_address_frag);
d5317 1
a5317 1

d5321 1
a5321 1

d5325 2
a5326 2
/* arm_reg_parse () := if it looks like a register, return its token and
   advance the pointer.  */
d5358 1
a5358 1

d5370 3
a5372 3
     fixS *   fixP;
     valueT * val;
     segT     seg;
d5385 1
a5385 3
#if 0
  /* Patch from REarnshaw to JDavis (disabled for the moment, since it
     doesn't work fully.)  */
d5404 1
a5404 2
		  || fixP->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
		  ))
d5411 1
a5411 2
  /* Remember value for emit_reloc.  */
  fixP->fx_addnumber = value;
d5437 1
a5437 1
	unsigned int newinsn  = 0xe1a00000; /* nop.  */
d5446 1
a5446 2
	    /* No ?  OK - try using two ADD instructions to generate
               the value.  */
d5449 1
a5449 2
	    /* Yes - then make sure that the second instruction is
               also an add.  */
d5454 1
a5454 1
	      temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
d5459 1
a5459 2
			      _("Unable to compute ADRL instructions for PC offset of 0x%lx"),
			      value);
d5463 3
a5465 4
	    /* Replace the first operand in the 2nd instruction (which
	       is the PC) with the destination register.  We have
	       already added in the PC in the first instruction and we
	       do not want to do it again.  */
d5480 1
a5480 1

d5483 1
a5483 1

d5485 5
a5489 6
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("bad immediate value for offset (%ld)"),
			(long) value);
	  break;
	}
d5497 2
a5498 2
    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
d5500 1
a5500 1

d5505 6
a5510 6
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad (_("bad immediate value for half-word offset (%ld)"),
d5512 2
a5513 2
	  break;
	}
d5523 1
a5523 1

d5529 1
a5529 1
	  as_bad_where (fixP->fx_file, fixP->fx_line,
d5543 1
a5543 1
	  || (value == 32
d5552 1
a5552 2
	/* Shifts of zero must be done as lsl.  */
	newval &= ~0x60;
d5557 1
a5557 1
      md_number_to_chars (buf, newval, INSN_SIZE);
d5573 1
a5573 1
	    as_bad_where (fixP->fx_file, fixP->fx_line,
d5577 1
a5577 1
	  md_number_to_chars (buf, newval, INSN_SIZE);
d5604 2
a5605 2
      if ((value & ~ ((offsetT) 0x1ffffff)) != 0
	  && ((value & ~ ((offsetT) 0x1ffffff)) != ~ ((offsetT) 0x1ffffff)))
d5614 1
a5614 1

d5626 4
a5629 5
	      /* Permit a backward branch provided that enough bits
		 are set.  Allow a forwards branch, provided that
		 enough bits are clear.  */
	      if (   (value & ~ ((offsetT) 0x1ffffff)) == ~ ((offsetT) 0x1ffffff)
		  || (value & ~ ((offsetT) 0x1ffffff)) == 0)
d5632 1
a5632 1

d5641 3
a5643 3

      if (    (value & ~ ((offsetT) 0xffffff)) != 0
	  && ((value & ~ ((offsetT) 0xffffff)) != ~ ((offsetT) 0xffffff)))
d5646 1
a5646 1

a5650 16
    case BFD_RELOC_ARM_PCREL_BLX:
      {
	offsetT hbit;
	newval = md_chars_to_number (buf, INSN_SIZE);

#ifdef OBJ_ELF
	if (! target_oabi)
	  value = fixP->fx_offset;
#endif
	hbit   = (value >> 1) & 1;
	value  = (value >> 2) & 0x00ffffff;
	value  = (value + (newval & 0x00ffffff)) & 0x00ffffff;
	newval = value | (newval & 0xfe000000) | (hbit << 24);
	md_number_to_chars (buf, newval, INSN_SIZE);
      }
      break;
d5652 1
a5652 1
    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* Conditional branch.  */
d5655 9
a5663 9
	addressT diff = (newval & 0xff) << 1;
	if (diff & 0x100)
	  diff |= ~0xff;

	value += diff;
	if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("Branch out of range"));
	newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
d5668 1
a5668 1
    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* Unconditional branch.  */
d5671 9
a5679 9
	addressT diff = (newval & 0x7ff) << 1;
	if (diff & 0x800)
	  diff |= ~0x7ff;

	value += diff;
	if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("Branch out of range"));
	newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
a5683 1
    case BFD_RELOC_THUMB_PCREL_BLX:
d5686 2
a5687 2
	offsetT newval2;
	addressT diff;
d5690 3
a5692 3
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
	if (diff & 0x400000)
d5697 2
a5698 2
	value += diff;
	if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
d5702 4
a5705 13
	newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
	newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
	if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	  /* Remove bit zero of the adjusted offset.  Bit zero can only be
	     set if the upper insn is at a half-word boundary, since the
	     destination address, an ARM instruction, must always be on a
	     word boundary.  The semantics of the BLX (1) instruction, however,
	     are that bit zero in the offset must always be zero, and the
	     corresponding bit one in the target address will be set from bit
	     one of the source address.  */
	  newval2 &= ~1;
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
d5714 4
a5717 4
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 1);
	}
d5726 4
a5729 4
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 2);
	}
d5736 2
a5737 2
      md_number_to_chars (buf, 0, 4);
      break;
d5746 4
a5749 4
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 4);
	}
d5755 1
a5755 1
      /* It appears the instruction is fully prepared at this point.  */
d5762 1
a5762 1

d5771 2
a5772 2
      newval |= (value >> 2) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
d5777 2
a5778 3
      /* Exactly what ranges, and where the offset is inserted depends
	 on the type of instruction, we can establish this from the
	 top 4 bits.  */
d5781 1
a5781 1
	case 4: /* PC load.  */
d5791 1
a5791 2
			  (unsigned int) (fixP->fx_frag->fr_address
					  + fixP->fx_where + value));
d5795 1
a5795 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d5797 1
a5797 1
	  /* Round up, since pc will be rounded down.  */
d5801 1
a5801 1
	case 9: /* SP load/store.  */
d5804 1
a5804 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d5808 1
a5808 1
	case 6: /* Word load/store.  */
d5811 2
a5812 2
			  _("Invalid offset, value too big (0x%08lX)"), value);
	  newval |= value << 4; /* 6 - 2.  */
d5815 1
a5815 1
	case 7: /* Byte load/store.  */
d5818 1
a5818 1
			  _("Invalid offset, value too big (0x%08lX)"), value);
d5822 1
a5822 1
	case 8: /* Halfword load/store.  */
d5825 2
a5826 2
			  _("Invalid offset, value too big (0x%08lX)"), value);
	  newval |= value << 5; /* 6 - 1.  */
d5841 4
a5844 5

	    3bit ADD/SUB
	    8bit ADD/SUB
	    9bit ADD/SUB SP word-aligned
	   10bit ADD PC/SP word-aligned
d5848 3
a5850 4

	   0x8000  SUB
	   0x00F0  Rd
	   0x000F  Rs
d5854 18
a5871 18
	int rd = (newval >> 4) & 0xf;
	int rs = newval & 0xf;
	int subtract = newval & 0x8000;

	if (rd == REG_SP)
	  {
	    if (value & ~0x1fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("Invalid immediate for stack address calculation"));
	    newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	    newval |= value >> 2;
	  }
	else if (rs == REG_PC || rs == REG_SP)
	  {
	    if (subtract ||
		value & ~0x3fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("Invalid immediate for address calculation (value = 0x%08lX)"),
d5873 20
a5892 20
	    newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
	    newval |= rd << 8;
	    newval |= value >> 2;
	  }
	else if (rs == rd)
	  {
	    if (value & ~0xff)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("Invalid 8bit immediate"));
	    newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	    newval |= (rd << 8) | value;
	  }
	else
	  {
	    if (value & ~0x7)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("Invalid 3bit immediate"));
	    newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	    newval |= rd | (rs << 3) | (value << 6);
	  }
d5894 1
a5894 1
      md_number_to_chars (buf, newval, THUMB_SIZE);
d5900 6
a5905 6
	{
	case 0x04: /* 8bit immediate MOV.  */
	case 0x05: /* 8bit immediate CMP.  */
	  if (value < 0 || value > 255)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("Invalid immediate: %ld is too large"),
d5907 2
a5908 2
	  newval |= value;
	  break;
d5910 4
a5913 4
	default:
	  abort ();
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
d5917 1
a5917 1
      /* 5bit shift value (0..31).  */
d5923 1
a5923 1
      md_number_to_chars (buf, newval, THUMB_SIZE);
a5941 1

d5990 1
a5990 2
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_RVA:
a5993 1
    case BFD_RELOC_THUMB_PCREL_BLX:
d6002 1
a6002 1
	 a section boundary - possibly due to an implicit dump.  */
d6011 2
a6012 2
      code = fixp->fx_r_type;
      break;
d6023 2
a6024 1
		    _("ADRL used for a symbol not defined in the same file"));
a6035 1

d6052 2
a6053 2
		      _("Cannot represent %s relocation in this object file format"),
		      type);
d6059 7
a6065 7
  if (code == BFD_RELOC_32_PCREL
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      code = BFD_RELOC_ARM_GOTPC;
      reloc->addend = fixp->fx_offset = reloc->address;
    }
d6067 1
a6067 1

d6078 4
a6081 4
  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;
d6099 1
a6099 1

d6107 1
a6107 1

d6128 1
a6128 3
#ifdef OBJ_ELF
  dwarf2_emit_insn (inst.size);
#endif
d6141 3
a6143 5
     This may not be the right thing to do but ...  */
#if 0
  arm_align (2, 0);
#endif
  listing_prev_line (); /* Defined in listing.h.  */
d6157 1
a6157 1

d6163 1
a6163 1

d6178 1
a6178 1

d6183 4
a6186 4
	    {
	      as_bad (_("selected processor does not support this opcode"));
	      return;
	    }
d6190 1
a6190 1
	  (*opcode->parms) (p);
d6201 1
a6201 1
      /* P now points to the end of the opcode, probably white space, but we
a6205 1

a6209 1

d6212 1
a6212 1

d6227 6
a6232 6
		      if (*opcode->comp_suffix != '\0')
			as_bad (_("Opcode `%s' must have suffix from list: <%s>"),
				str, opcode->comp_suffix);
		      else
			/* Not a conditional instruction.  */
			(*opcode->parms) (q, 0);
d6236 1
a6236 1
		      /* A conditional instruction with default condition.  */
d6238 1
a6238 1
		      (*opcode->parms) (q, 0);
d6244 1
a6244 2
	      /* Not just a simple opcode.  Check if extra is a
                 conditional.  */
d6269 1
a6269 1
	      /* Apply the conditional, or complain it's not allowed.  */
d6272 6
a6277 6
		  /* Instruction isn't conditional.  */
		  if (cond_code != COND_ALWAYS)
		    {
		      as_bad (_("Opcode `%s' is unconditional\n"), str);
		      return;
		    }
d6280 3
a6282 2
		/* Instruction is conditional: set the condition into it.  */
		inst.instruction |= cond_code;
d6284 2
a6285 2
	      /* If there is a compulsory suffix, it should come here
		 before any optional flags.  */
d6300 2
a6301 2
		      as_bad (_("Opcode `%s' must have suffix from <%s>\n"),
			      str, opcode->comp_suffix);
d6350 1
a6350 1
     alias .req reg.  */
d6356 1
a6356 1

d6360 1
a6360 1
      char * copy_of_str;
d6362 1
a6362 6

#ifdef IGNORE_OPCODE_CASE
      str = original_case_string;
#endif
      copy_of_str = str;

d6369 1
a6369 1

d6380 1
a6380 1

d6392 2
a6393 2
			 copy_of_str);

d6402 1
a6402 1

d6411 30
a6440 30
/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.  These are:
      Cpu variants, the arm part is optional:
              -m[arm]1                Currently not supported.
              -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
              -m[arm]3                Arm 3 processor
              -m[arm]6[xx],           Arm 6 processors
              -m[arm]7[xx][t][[d]m]   Arm 7 processors
              -m[arm]8[10]            Arm 8 processors
              -m[arm]9[20][tdmi]      Arm 9 processors
              -mstrongarm[110[0]]     StrongARM processors
              -mxscale                XScale processors
              -m[arm]v[2345[t[e]]]    Arm architectures
              -mall                   All (except the ARM1)
      FP variants:
              -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions
              -mfpe-old               (No float load/store multiples)
              -mno-fpu                Disable all floating point instructions
      Run-time endian selection:
              -EB                     big endian cpu
              -EL                     little endian cpu
      ARM Procedure Calling Standard:
  	      -mapcs-32		      32 bit APCS
  	      -mapcs-26		      26 bit APCS
  	      -mapcs-float	      Pass floats in float regs
  	      -mapcs-reentrant        Position independent code
              -mthumb-interwork       Code supports Arm/Thumb interworking
              -matpcs                 ARM/Thumb Procedure Call Standard
              -moabi                  Old ELF ABI  */
a6442 1

a6456 1

d6497 17
a6513 17
	case 'o':
	  if (streq (str, "oabi"))
	    target_oabi = true;
	  break;
#endif

	case 't':
	  /* Limit assembler to generating only Thumb instructions:  */
	  if (streq (str, "thumb"))
	    {
	      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_EXT_THUMB;
	      cpu_variant = (cpu_variant & ~FPU_ALL) | FPU_NONE;
	      thumb_mode = 1;
	    }
	  else if (streq (str, "thumb-interwork"))
	    {
	      if ((cpu_variant & ARM_EXT_THUMB) == 0)
d6516 1
a6516 1
	      support_interwork = true;
d6518 2
a6519 2
	    }
	  else
d6521 1
a6521 1
	  break;
d6536 1
a6536 1

d6576 1
a6576 1
		     position independent code with absolute position code.  */
d6580 1
a6580 1

d6583 1
a6583 7
	    }

	  if (! strcmp (str, "atpcs"))
	    {
	      atpcs = true;
	      return 1;
	    }
d6585 1
a6585 1
	  /* Strip off optional "arm".  */
d6630 1
a6630 2
	      /* Eat the processor name.  */
	      switch (strtol (str, & str, 10))
d6643 17
a6659 26
	      cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;
	      for (; *str; str++)
		{
		  switch (*str)
		    {
		    case 't':
		      cpu_variant |= ARM_ARCH_V4T;
		      break;

		    case 'm':
		      cpu_variant |= ARM_EXT_LONGMUL;
		      break;

		    case 'f': /* fe => fp enabled cpu.  */
		      if (str[1] == 'e')
			++ str;
		      else
			goto bad;

		    case 'c': /* Left over from 710c processor name.  */
		    case 'd': /* Debug.  */
		    case 'i': /* Embedded ICE.  */
		      /* Included for completeness in ARM processor naming.  */
		      break;

		    default:
d6661 11
a6671 2
		    }
		}
d6677 1
a6677 1
		  | ARM_8 | ARM_ARCH_V4;
d6681 1
a6681 1

d6685 1
a6685 1
		  | ARM_9 | ARM_ARCH_V4T;
d6688 1
a6688 1
		  | ARM_9 | ARM_ARCH_V4;
d6691 1
a6691 1
		  | ARM_9 | ARM_ARCH_V4T;
d6694 1
a6694 1
		  | ARM_9 | ARM_ARCH_V4T;
d6699 1
d6705 1
a6705 1
		  | ARM_8 | ARM_ARCH_V4;
d6709 1
a6709 8

            case 'x':
 	      if (streq (str, "xscale"))
 		cpu_variant = ARM_9 | ARM_ARCH_XSCALE;
 	      else
 		goto bad;
      	      break;

d6711 1
a6711 2
	      /* Select variant based on architecture rather than
                 processor.  */
d6728 1
a6728 1

d6730 2
a6731 2
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7;

d6734 1
a6734 1
		    case 'm': cpu_variant |= ARM_EXT_LONGMUL; break;
d6741 1
a6741 1

d6743 2
a6744 2
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_7 | ARM_ARCH_V4;

d6747 1
a6747 1
		    case 't': cpu_variant |= ARM_EXT_THUMB; break;
d6756 1
a6756 1
		  cpu_variant = (cpu_variant & ~ARM_ANY) | ARM_9 | ARM_ARCH_V5;
d6759 1
a6759 1
		    case 't': cpu_variant |= ARM_EXT_THUMB; break;
d6767 1
a6767 1

d6773 1
a6773 1

d6787 1
a6787 1

d6792 1
a6792 1
  return 1;
a6812 1
  -matpcs                   use ARM/Thumb Procedure Calling Standard\n\
d6815 1
a6815 1
#endif
d6843 2
a6844 2
  fixS *           new_fix;
  arm_fix_data *   arm_data;
d6861 1
a6861 2
  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
d6869 1
a6870 1

d6880 1
a6880 1

d6883 1
a6883 1
  switch (size)
d6899 1
a6899 1

a6905 1

d6911 2
a6912 3

  /* Put it at the end of text section.  */
  subseg_set (text_section, 0);
d6928 1
a6928 1

d6930 1
a6930 1

d6934 2
a6935 33

  /* Note - do not allow local symbols (.Lxxx) to be labeled
     as Thumb functions.  This is because these labels, whilst
     they exist inside Thumb code, are not the entry points for
     possible ARM->Thumb calls.  Also, these labels can be used
     as part of a computed goto or switch statement.  eg gcc
     can generate code that looks like this:

                ldr  r2, [pc, .Laaa]
                lsl  r3, r3, #2
                ldr  r2, [r3, r2]
                mov  pc, r2
		
       .Lbbb:  .word .Lxxx
       .Lccc:  .word .Lyyy
       ..etc...
       .Laaa:   .word Lbbb

     The first instruction loads the address of the jump table.
     The second instruction converts a table index into a byte offset.
     The third instruction gets the jump address out of the table.
     The fourth instruction performs the jump.
     
     If the address stored at .Laaa is that of a symbol which has the
     Thumb_Func bit set, then the linker will arrange for this address
     to have the bottom bit set, which in turn would mean that the
     address computation performed by the third instruction would end
     up with the bottom bit set.  Since the ARM is capable of unaligned
     word loads, the instruction would then load the incorrect address
     out of the jump table, and chaos would ensue.  */
  if (label_is_thumb_function_name
      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
d6943 1
a6943 1

d6960 1
a6960 1
	{
d6965 1
a6965 1
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)  /* This can happen!  */
d6975 14
a6988 15
	    {
	    case C_EXT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
	      break;
	    case C_STAT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
	      break;
	    case C_LABEL:
	      S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
	      break;
	    default:
	      /* Do nothing.  */
	      break;
	    }
	}
d6995 2
a6996 2
  symbolS * sym;
  char      bind;
d7001 1
a7001 1
	{
d7003 1
a7003 1

d7006 1
a7006 1

d7015 2
a7016 2
	}
    }
d7030 1
a7030 1

d7055 1
a7055 1
  if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
a7066 16
#ifdef OBJ_COFF
/* This is a little hack to help the gas/arm/adrl.s test.  It prevents
   local labels from being added to the output symbol table when they
   are used with the ADRL pseudo op.  The ADRL relocation should always
   be resolved before the binbary is emitted, so it is safe to say that
   it is adjustable.  */

boolean
arm_fix_adjustable (fixP)
   fixS * fixP;
{
  if (fixP->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 1;
  return 0;
}
#endif
d7080 1
a7080 1

d7087 2
a7088 2

  /* Prevent all adjustments to global symbols.  */
d7091 1
a7091 1

d7098 2
a7099 2

  /* We need the symbol name for the VTABLE entries.  */
d7111 4
a7114 6
    {
      if (target_oabi)
	return "elf32-bigarm-oabi";
      else
	return "elf32-bigarm";
    }
d7116 4
a7119 6
    {
      if (target_oabi)
	return "elf32-littlearm-oabi";
      else
	return "elf32-littlearm";
    }
d7125 1
a7125 1
     int *     puntp;
d7128 1
a7128 1
}
d7137 1
a7137 3
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
d7139 1
a7139 1

d7146 2
a7147 2
  char         id [16];
  char *       ip;
d7157 1
a7157 1
#define MAP(str,reloc) { str, sizeof (str) - 1, reloc }
d7160 3
a7162 2
    /* ScottB: Jan 30, 1998 - Added support for parsing "var(PLT)"
       branch instructions generated by GCC for PLT relocs.  */
d7165 1
a7165 1
#undef MAP
d7172 1
a7172 1

d7176 1
a7176 1

d7178 1
a7178 1

d7205 1
a7205 1

d7209 5
a7213 5
	  && * input_line_pointer == '('
	  && (reloc = arm_parse_reloc ()) != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  int size = bfd_get_reloc_size (howto);
d7215 2
a7216 2
	  if (size > nbytes)
	    as_bad ("%s relocations do not fit in %d bytes",
d7218 9
a7226 9
	  else
	    {
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;

	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	    }
	}
d7228 1
a7228 1
	emit_expr (&exp, (unsigned int) nbytes);
d7232 1
a7232 2
  /* Put terminator back into stream.  */
  input_line_pointer --;
a7236 99

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
arm_handle_align (fragP)
     fragS *fragP;
{
  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
  static char const thumb_noop[2] = { 0xc0, 0x46 };
  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };

  int bytes, fix, noop_size;
  char * p;
  const char * noop;
  
  if (fragP->fr_type != rs_align_code)
    return;

  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
  p = fragP->fr_literal + fragP->fr_fix;
  fix = 0;
  
  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;
  
  if (fragP->tc_frag_data)
    {
      if (target_big_endian)
	noop = thumb_bigend_noop;
      else
	noop = thumb_noop;
      noop_size = sizeof (thumb_noop);
    }
  else
    {
      if (target_big_endian)
	noop = arm_bigend_noop;
      else
	noop = arm_noop;
      noop_size = sizeof (arm_noop);
    }
  
  if (bytes & (noop_size - 1))
    {
      fix = bytes & (noop_size - 1);
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }

  while (bytes >= noop_size)
    {
      memcpy (p, noop, noop_size);
      p += noop_size;
      bytes -= noop_size;
      fix += noop_size;
    }
  
  fragP->fr_fix += fix;
  fragP->fr_var = noop_size;
}

/* Called from md_do_align.  Used to create an alignment
   frag in a code section.  */

void
arm_frag_align_code (n, max)
     int n;
     int max;
{
  char * p;

  /* We assume that there will never be a requirment
     to support alignments greater than 32 bytes.  */
  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));
  
  p = frag_var (rs_align_code,
		MAX_MEM_FOR_RS_ALIGN_CODE,
		1,
		(relax_substateT) max,
		(symbolS *) NULL,
		(offsetT) n,
		(char *) NULL);
  *p = 0;

}

/* Perform target specific initialisation of a frag.  */

void
arm_init_frag (fragP)
     fragS *fragP;
{
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data = thumb_mode;
}
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a5 1
	Cirrus coprocessor mods by Aldy Hernandez (aldyh@@redhat.com)
d24 1
a27 1
#include "safe-ctype.h"
d41 27
a67 47
/* XXX Set this to 1 after the next binutils release */
#define WARN_DEPRECATED 0

/* The following bitmasks control CPU extensions:  */
#define ARM_EXT_V1	 0x00000001	/* All processors (core set).  */
#define ARM_EXT_V2	 0x00000002	/* Multiply instructions.  */
#define ARM_EXT_V2S	 0x00000004	/* SWP instructions.       */
#define ARM_EXT_V3	 0x00000008	/* MSR MRS.                */
#define ARM_EXT_V3M	 0x00000010	/* Allow long multiplies.  */
#define ARM_EXT_V4	 0x00000020	/* Allow half word loads.  */
#define ARM_EXT_V4T	 0x00000040	/* Thumb v1.               */
#define ARM_EXT_V5	 0x00000080	/* Allow CLZ, etc.         */
#define ARM_EXT_V5T	 0x00000100	/* Thumb v2.               */
#define ARM_EXT_V5ExP	 0x00000200	/* DSP core set.           */
#define ARM_EXT_V5E	 0x00000400	/* DSP Double transfers.   */
#define ARM_EXT_V5J	 0x00000800	/* Jazelle extension.	   */

/* Co-processor space extensions.  */
#define ARM_CEXT_XSCALE   0x00800000	/* Allow MIA etc.          */
#define ARM_CEXT_MAVERICK 0x00400000	/* Use Cirrus/DSP coprocessor.  */
#define ARM_CEXT_IWMMXT   0x00200000    /* Intel Wireless MMX technology coprocessor.   */

/* Architectures are the sum of the base and extensions.  The ARM ARM (rev E)
   defines the following: ARMv3, ARMv3M, ARMv4xM, ARMv4, ARMv4TxM, ARMv4T,
   ARMv5xM, ARMv5, ARMv5TxM, ARMv5T, ARMv5TExP, ARMv5TE.  To these we add
   three more to cover cores prior to ARM6.  Finally, there are cores which
   implement further extensions in the co-processor space.  */
#define ARM_ARCH_V1			  ARM_EXT_V1
#define ARM_ARCH_V2	(ARM_ARCH_V1	| ARM_EXT_V2)
#define ARM_ARCH_V2S	(ARM_ARCH_V2	| ARM_EXT_V2S)
#define ARM_ARCH_V3	(ARM_ARCH_V2S	| ARM_EXT_V3)
#define ARM_ARCH_V3M	(ARM_ARCH_V3	| ARM_EXT_V3M)
#define ARM_ARCH_V4xM	(ARM_ARCH_V3	| ARM_EXT_V4)
#define ARM_ARCH_V4	(ARM_ARCH_V3M	| ARM_EXT_V4)
#define ARM_ARCH_V4TxM	(ARM_ARCH_V4xM	| ARM_EXT_V4T)
#define ARM_ARCH_V4T	(ARM_ARCH_V4	| ARM_EXT_V4T)
#define ARM_ARCH_V5xM	(ARM_ARCH_V4xM	| ARM_EXT_V5)
#define ARM_ARCH_V5	(ARM_ARCH_V4	| ARM_EXT_V5)
#define ARM_ARCH_V5TxM	(ARM_ARCH_V5xM	| ARM_EXT_V4T | ARM_EXT_V5T)
#define ARM_ARCH_V5T	(ARM_ARCH_V5	| ARM_EXT_V4T | ARM_EXT_V5T)
#define ARM_ARCH_V5TExP	(ARM_ARCH_V5T	| ARM_EXT_V5ExP)
#define ARM_ARCH_V5TE	(ARM_ARCH_V5TExP | ARM_EXT_V5E)
#define ARM_ARCH_V5TEJ	(ARM_ARCH_V5TE	| ARM_EXT_V5J)

/* Processors with specific extensions in the co-processor space.  */
#define ARM_ARCH_XSCALE	(ARM_ARCH_V5TE	| ARM_CEXT_XSCALE)
#define ARM_ARCH_IWMMXT	(ARM_ARCH_XSCALE | ARM_CEXT_IWMMXT)
d70 14
a83 33
#define ARM_ANY		0x0000ffff	/* Any basic core.  */
#define ARM_ALL		0x00ffffff	/* Any core + co-processor */
#define CPROC_ANY	0x00ff0000	/* Any co-processor */
#define FPU_ANY		0xff000000	/* Note this is ~ARM_ALL.  */


#define FPU_FPA_EXT_V1	 0x80000000	/* Base FPA instruction set.  */
#define FPU_FPA_EXT_V2	 0x40000000	/* LFM/SFM.		      */
#define FPU_VFP_EXT_NONE 0x20000000	/* Use VFP word-ordering.     */
#define FPU_VFP_EXT_V1xD 0x10000000	/* Base VFP instruction set.  */
#define FPU_VFP_EXT_V1	 0x08000000	/* Double-precision insns.    */
#define FPU_VFP_EXT_V2	 0x04000000	/* ARM10E VFPr1.	      */
#define FPU_NONE	 0

#define FPU_ARCH_FPE	 FPU_FPA_EXT_V1
#define FPU_ARCH_FPA	(FPU_ARCH_FPE | FPU_FPA_EXT_V2)

#define FPU_ARCH_VFP       FPU_VFP_EXT_NONE
#define FPU_ARCH_VFP_V1xD (FPU_VFP_EXT_V1xD | FPU_VFP_EXT_NONE)
#define FPU_ARCH_VFP_V1   (FPU_ARCH_VFP_V1xD | FPU_VFP_EXT_V1)
#define FPU_ARCH_VFP_V2	  (FPU_ARCH_VFP_V1 | FPU_VFP_EXT_V2)

/* Types of processor to assemble for.  */
#define ARM_1		ARM_ARCH_V1
#define ARM_2		ARM_ARCH_V2
#define ARM_3		ARM_ARCH_V2S
#define ARM_250		ARM_ARCH_V2S
#define ARM_6		ARM_ARCH_V3
#define ARM_7		ARM_ARCH_V3
#define ARM_8		ARM_ARCH_V4
#define ARM_9		ARM_ARCH_V4T
#define ARM_STRONG	ARM_ARCH_V4
#define ARM_CPU_MASK	0x0000000f              /* XXX? */
d87 1
a87 1
#define CPU_DEFAULT	(ARM_ARCH_XSCALE)
d90 1
a90 1
#define CPU_DEFAULT 	(ARM_ARCH_V5T)
d92 1
a92 1
#define CPU_DEFAULT 	ARM_ANY
a96 1
/* For backwards compatibility we default to the FPA.  */
d98 1
a98 1
#define FPU_DEFAULT FPU_ARCH_FPA
d104 1
a104 1
static unsigned long cpu_variant;
d107 1
d109 6
a114 17
static int uses_apcs_26      = FALSE;
static int atpcs             = FALSE;
static int support_interwork = FALSE;
static int uses_apcs_float   = FALSE;
static int pic_code          = FALSE;

/* Variables that we set while parsing command-line options.  Once all
   options have been read we re-process these values to set the real
   assembly flags.  */
static int legacy_cpu = -1;
static int legacy_fpu = -1;

static int mcpu_cpu_opt = -1;
static int mcpu_fpu_opt = -1;
static int march_cpu_opt = -1;
static int march_fpu_opt = -1;
static int mfpu_opt = -1;
d118 1
a118 1
const char comment_chars[] = "@@";
d127 1
a127 1
const char line_comment_chars[] = "#";
d129 1
a129 1
const char line_separator_chars[] = ";";
d133 1
a133 1
const char EXP_CHARS[] = "eE";
d139 1
a139 1
const char FLT_CHARS[] = "rRsSfFdDxXeEpP";
d151 1
a151 1
const int md_reloc_size = 8;
d166 1
a166 1
  const char *  error;
d168 1
d233 1
a233 1
const char * fp_const[] =
a245 4
/* Whether a Co-processor load/store operation accepts write-back forms.  */
#define CP_WB_OK 1
#define CP_NO_WB 0

d259 1
d265 1
a265 1
  const char *  template;
d269 1
a270 1
#define COND_MASK   0xf0000000
d272 1
a272 1
static const struct asm_cond conds[] =
d292 4
a295 168
struct asm_psr
{
  const char *template;
  bfd_boolean cpsr;
  unsigned long field;
};

/* The bit that distnguishes CPSR and SPSR.  */
#define SPSR_BIT   (1 << 22)

/* How many bits to shift the PSR_xxx bits up by.  */
#define PSR_SHIFT  16

#define PSR_c   (1 << 0)
#define PSR_x   (1 << 1)
#define PSR_s   (1 << 2)
#define PSR_f   (1 << 3)

static const struct asm_psr psrs[] =
{
  {"CPSR",	TRUE,  PSR_c | PSR_f},
  {"CPSR_all",	TRUE,  PSR_c | PSR_f},
  {"SPSR",	FALSE, PSR_c | PSR_f},
  {"SPSR_all",	FALSE, PSR_c | PSR_f},
  {"CPSR_flg",	TRUE,  PSR_f},
  {"CPSR_f",    TRUE,  PSR_f},
  {"SPSR_flg",	FALSE, PSR_f},
  {"SPSR_f",    FALSE, PSR_f},
  {"CPSR_c",	TRUE,  PSR_c},
  {"CPSR_ctl",	TRUE,  PSR_c},
  {"SPSR_c",	FALSE, PSR_c},
  {"SPSR_ctl",	FALSE, PSR_c},
  {"CPSR_x",    TRUE,  PSR_x},
  {"CPSR_s",    TRUE,  PSR_s},
  {"SPSR_x",    FALSE, PSR_x},
  {"SPSR_s",    FALSE, PSR_s},
  /* Combinations of flags.  */
  {"CPSR_fs",	TRUE, PSR_f | PSR_s},
  {"CPSR_fx",	TRUE, PSR_f | PSR_x},
  {"CPSR_fc",	TRUE, PSR_f | PSR_c},
  {"CPSR_sf",	TRUE, PSR_s | PSR_f},
  {"CPSR_sx",	TRUE, PSR_s | PSR_x},
  {"CPSR_sc",	TRUE, PSR_s | PSR_c},
  {"CPSR_xf",	TRUE, PSR_x | PSR_f},
  {"CPSR_xs",	TRUE, PSR_x | PSR_s},
  {"CPSR_xc",	TRUE, PSR_x | PSR_c},
  {"CPSR_cf",	TRUE, PSR_c | PSR_f},
  {"CPSR_cs",	TRUE, PSR_c | PSR_s},
  {"CPSR_cx",	TRUE, PSR_c | PSR_x},
  {"CPSR_fsx",	TRUE, PSR_f | PSR_s | PSR_x},
  {"CPSR_fsc",	TRUE, PSR_f | PSR_s | PSR_c},
  {"CPSR_fxs",	TRUE, PSR_f | PSR_x | PSR_s},
  {"CPSR_fxc",	TRUE, PSR_f | PSR_x | PSR_c},
  {"CPSR_fcs",	TRUE, PSR_f | PSR_c | PSR_s},
  {"CPSR_fcx",	TRUE, PSR_f | PSR_c | PSR_x},
  {"CPSR_sfx",	TRUE, PSR_s | PSR_f | PSR_x},
  {"CPSR_sfc",	TRUE, PSR_s | PSR_f | PSR_c},
  {"CPSR_sxf",	TRUE, PSR_s | PSR_x | PSR_f},
  {"CPSR_sxc",	TRUE, PSR_s | PSR_x | PSR_c},
  {"CPSR_scf",	TRUE, PSR_s | PSR_c | PSR_f},
  {"CPSR_scx",	TRUE, PSR_s | PSR_c | PSR_x},
  {"CPSR_xfs",	TRUE, PSR_x | PSR_f | PSR_s},
  {"CPSR_xfc",	TRUE, PSR_x | PSR_f | PSR_c},
  {"CPSR_xsf",	TRUE, PSR_x | PSR_s | PSR_f},
  {"CPSR_xsc",	TRUE, PSR_x | PSR_s | PSR_c},
  {"CPSR_xcf",	TRUE, PSR_x | PSR_c | PSR_f},
  {"CPSR_xcs",	TRUE, PSR_x | PSR_c | PSR_s},
  {"CPSR_cfs",	TRUE, PSR_c | PSR_f | PSR_s},
  {"CPSR_cfx",	TRUE, PSR_c | PSR_f | PSR_x},
  {"CPSR_csf",	TRUE, PSR_c | PSR_s | PSR_f},
  {"CPSR_csx",	TRUE, PSR_c | PSR_s | PSR_x},
  {"CPSR_cxf",	TRUE, PSR_c | PSR_x | PSR_f},
  {"CPSR_cxs",	TRUE, PSR_c | PSR_x | PSR_s},
  {"CPSR_fsxc",	TRUE, PSR_f | PSR_s | PSR_x | PSR_c},
  {"CPSR_fscx",	TRUE, PSR_f | PSR_s | PSR_c | PSR_x},
  {"CPSR_fxsc",	TRUE, PSR_f | PSR_x | PSR_s | PSR_c},
  {"CPSR_fxcs",	TRUE, PSR_f | PSR_x | PSR_c | PSR_s},
  {"CPSR_fcsx",	TRUE, PSR_f | PSR_c | PSR_s | PSR_x},
  {"CPSR_fcxs",	TRUE, PSR_f | PSR_c | PSR_x | PSR_s},
  {"CPSR_sfxc",	TRUE, PSR_s | PSR_f | PSR_x | PSR_c},
  {"CPSR_sfcx",	TRUE, PSR_s | PSR_f | PSR_c | PSR_x},
  {"CPSR_sxfc",	TRUE, PSR_s | PSR_x | PSR_f | PSR_c},
  {"CPSR_sxcf",	TRUE, PSR_s | PSR_x | PSR_c | PSR_f},
  {"CPSR_scfx",	TRUE, PSR_s | PSR_c | PSR_f | PSR_x},
  {"CPSR_scxf",	TRUE, PSR_s | PSR_c | PSR_x | PSR_f},
  {"CPSR_xfsc",	TRUE, PSR_x | PSR_f | PSR_s | PSR_c},
  {"CPSR_xfcs",	TRUE, PSR_x | PSR_f | PSR_c | PSR_s},
  {"CPSR_xsfc",	TRUE, PSR_x | PSR_s | PSR_f | PSR_c},
  {"CPSR_xscf",	TRUE, PSR_x | PSR_s | PSR_c | PSR_f},
  {"CPSR_xcfs",	TRUE, PSR_x | PSR_c | PSR_f | PSR_s},
  {"CPSR_xcsf",	TRUE, PSR_x | PSR_c | PSR_s | PSR_f},
  {"CPSR_cfsx",	TRUE, PSR_c | PSR_f | PSR_s | PSR_x},
  {"CPSR_cfxs",	TRUE, PSR_c | PSR_f | PSR_x | PSR_s},
  {"CPSR_csfx",	TRUE, PSR_c | PSR_s | PSR_f | PSR_x},
  {"CPSR_csxf",	TRUE, PSR_c | PSR_s | PSR_x | PSR_f},
  {"CPSR_cxfs",	TRUE, PSR_c | PSR_x | PSR_f | PSR_s},
  {"CPSR_cxsf",	TRUE, PSR_c | PSR_x | PSR_s | PSR_f},
  {"SPSR_fs",	FALSE, PSR_f | PSR_s},
  {"SPSR_fx",	FALSE, PSR_f | PSR_x},
  {"SPSR_fc",	FALSE, PSR_f | PSR_c},
  {"SPSR_sf",	FALSE, PSR_s | PSR_f},
  {"SPSR_sx",	FALSE, PSR_s | PSR_x},
  {"SPSR_sc",	FALSE, PSR_s | PSR_c},
  {"SPSR_xf",	FALSE, PSR_x | PSR_f},
  {"SPSR_xs",	FALSE, PSR_x | PSR_s},
  {"SPSR_xc",	FALSE, PSR_x | PSR_c},
  {"SPSR_cf",	FALSE, PSR_c | PSR_f},
  {"SPSR_cs",	FALSE, PSR_c | PSR_s},
  {"SPSR_cx",	FALSE, PSR_c | PSR_x},
  {"SPSR_fsx",	FALSE, PSR_f | PSR_s | PSR_x},
  {"SPSR_fsc",	FALSE, PSR_f | PSR_s | PSR_c},
  {"SPSR_fxs",	FALSE, PSR_f | PSR_x | PSR_s},
  {"SPSR_fxc",	FALSE, PSR_f | PSR_x | PSR_c},
  {"SPSR_fcs",	FALSE, PSR_f | PSR_c | PSR_s},
  {"SPSR_fcx",	FALSE, PSR_f | PSR_c | PSR_x},
  {"SPSR_sfx",	FALSE, PSR_s | PSR_f | PSR_x},
  {"SPSR_sfc",	FALSE, PSR_s | PSR_f | PSR_c},
  {"SPSR_sxf",	FALSE, PSR_s | PSR_x | PSR_f},
  {"SPSR_sxc",	FALSE, PSR_s | PSR_x | PSR_c},
  {"SPSR_scf",	FALSE, PSR_s | PSR_c | PSR_f},
  {"SPSR_scx",	FALSE, PSR_s | PSR_c | PSR_x},
  {"SPSR_xfs",	FALSE, PSR_x | PSR_f | PSR_s},
  {"SPSR_xfc",	FALSE, PSR_x | PSR_f | PSR_c},
  {"SPSR_xsf",	FALSE, PSR_x | PSR_s | PSR_f},
  {"SPSR_xsc",	FALSE, PSR_x | PSR_s | PSR_c},
  {"SPSR_xcf",	FALSE, PSR_x | PSR_c | PSR_f},
  {"SPSR_xcs",	FALSE, PSR_x | PSR_c | PSR_s},
  {"SPSR_cfs",	FALSE, PSR_c | PSR_f | PSR_s},
  {"SPSR_cfx",	FALSE, PSR_c | PSR_f | PSR_x},
  {"SPSR_csf",	FALSE, PSR_c | PSR_s | PSR_f},
  {"SPSR_csx",	FALSE, PSR_c | PSR_s | PSR_x},
  {"SPSR_cxf",	FALSE, PSR_c | PSR_x | PSR_f},
  {"SPSR_cxs",	FALSE, PSR_c | PSR_x | PSR_s},
  {"SPSR_fsxc",	FALSE, PSR_f | PSR_s | PSR_x | PSR_c},
  {"SPSR_fscx",	FALSE, PSR_f | PSR_s | PSR_c | PSR_x},
  {"SPSR_fxsc",	FALSE, PSR_f | PSR_x | PSR_s | PSR_c},
  {"SPSR_fxcs",	FALSE, PSR_f | PSR_x | PSR_c | PSR_s},
  {"SPSR_fcsx",	FALSE, PSR_f | PSR_c | PSR_s | PSR_x},
  {"SPSR_fcxs",	FALSE, PSR_f | PSR_c | PSR_x | PSR_s},
  {"SPSR_sfxc",	FALSE, PSR_s | PSR_f | PSR_x | PSR_c},
  {"SPSR_sfcx",	FALSE, PSR_s | PSR_f | PSR_c | PSR_x},
  {"SPSR_sxfc",	FALSE, PSR_s | PSR_x | PSR_f | PSR_c},
  {"SPSR_sxcf",	FALSE, PSR_s | PSR_x | PSR_c | PSR_f},
  {"SPSR_scfx",	FALSE, PSR_s | PSR_c | PSR_f | PSR_x},
  {"SPSR_scxf",	FALSE, PSR_s | PSR_c | PSR_x | PSR_f},
  {"SPSR_xfsc",	FALSE, PSR_x | PSR_f | PSR_s | PSR_c},
  {"SPSR_xfcs",	FALSE, PSR_x | PSR_f | PSR_c | PSR_s},
  {"SPSR_xsfc",	FALSE, PSR_x | PSR_s | PSR_f | PSR_c},
  {"SPSR_xscf",	FALSE, PSR_x | PSR_s | PSR_c | PSR_f},
  {"SPSR_xcfs",	FALSE, PSR_x | PSR_c | PSR_f | PSR_s},
  {"SPSR_xcsf",	FALSE, PSR_x | PSR_c | PSR_s | PSR_f},
  {"SPSR_cfsx",	FALSE, PSR_c | PSR_f | PSR_s | PSR_x},
  {"SPSR_cfxs",	FALSE, PSR_c | PSR_f | PSR_x | PSR_s},
  {"SPSR_csfx",	FALSE, PSR_c | PSR_s | PSR_f | PSR_x},
  {"SPSR_csxf",	FALSE, PSR_c | PSR_s | PSR_x | PSR_f},
  {"SPSR_cxfs",	FALSE, PSR_c | PSR_x | PSR_f | PSR_s},
  {"SPSR_cxsf",	FALSE, PSR_c | PSR_x | PSR_s | PSR_f},
};

enum wreg_type
  {
    IWMMXT_REG_WR = 0,
    IWMMXT_REG_WC = 1,
    IWMMXT_REG_WR_OR_WC = 2,
    IWMMXT_REG_WCG
  };

enum iwmmxt_insn_type
d297 2
a298 17
  check_rd,
  check_wr,
  check_wrwr,
  check_wrwrwr,
  check_wrwrwcg,
  check_tbcst,
  check_tmovmsk,
  check_tmia,
  check_tmcrr,
  check_tmrrc,
  check_tmcr,
  check_tmrc,
  check_tinsr,
  check_textrc,
  check_waligni,
  check_textrm,
  check_wshufh
d301 1
a301 1
enum vfp_dp_reg_pos
d303 2
a304 1
  VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
d307 1
a307 1
enum vfp_sp_reg_pos
d309 8
a316 1
  VFP_REG_Sd, VFP_REG_Sm, VFP_REG_Sn
d319 1
a319 1
enum vfp_ldstm_type
d321 5
a325 52
  VFP_LDSTMIA, VFP_LDSTMDB, VFP_LDSTMIAX, VFP_LDSTMDBX
};

/* VFP system registers.  */
struct vfp_reg
{
  const char *name;
  unsigned long regno;
};

static const struct vfp_reg vfp_regs[] =
{
  {"fpsid", 0x00000000},
  {"FPSID", 0x00000000},
  {"fpscr", 0x00010000},
  {"FPSCR", 0x00010000},
  {"fpexc", 0x00080000},
  {"FPEXC", 0x00080000}
};

/* Structure for a hash table entry for a register.  */
struct reg_entry
{
  const char * name;
  int          number;
};

/* Some well known registers that we refer to directly elsewhere.  */
#define REG_SP  13
#define REG_LR  14
#define REG_PC	15

#define wr_register(reg)  ((reg ^ WR_PREFIX) >= 0 && (reg ^ WR_PREFIX) <= 15)
#define wc_register(reg)  ((reg ^ WC_PREFIX) >= 0 && (reg ^ WC_PREFIX) <= 15)
#define wcg_register(reg) ((reg ^ WC_PREFIX) >= 8 && (reg ^ WC_PREFIX) <= 11)

/* These are the standard names.  Users can add aliases with .req.  */
/* Integer Register Numbers.  */
static const struct reg_entry rn_table[] =
{
  {"r0",  0},  {"r1",  1},      {"r2",  2},      {"r3",  3},
  {"r4",  4},  {"r5",  5},      {"r6",  6},      {"r7",  7},
  {"r8",  8},  {"r9",  9},      {"r10", 10},     {"r11", 11},
  {"r12", 12}, {"r13", REG_SP}, {"r14", REG_LR}, {"r15", REG_PC},
  /* ATPCS Synonyms.  */
  {"a1",  0},  {"a2",  1},      {"a3",  2},      {"a4",  3},
  {"v1",  4},  {"v2",  5},      {"v3",  6},      {"v4",  7},
  {"v5",  8},  {"v6",  9},      {"v7",  10},     {"v8",  11},
  /* Well-known aliases.  */
						 {"wr",  7},
	       {"sb",  9},      {"sl",  10},     {"fp",  11},
  {"ip",  12}, {"sp",  REG_SP}, {"lr",  REG_LR}, {"pc",  REG_PC},
d329 1
a329 4
#define WR_PREFIX 0x200
#define WC_PREFIX 0x400

static const struct reg_entry iwmmxt_table[] =
d331 1
a331 26
  /* Intel Wireless MMX technology register names.  */
  {  "wr0", 0x0 | WR_PREFIX},   {"wr1", 0x1 | WR_PREFIX},
  {  "wr2", 0x2 | WR_PREFIX},   {"wr3", 0x3 | WR_PREFIX},
  {  "wr4", 0x4 | WR_PREFIX},   {"wr5", 0x5 | WR_PREFIX},
  {  "wr6", 0x6 | WR_PREFIX},   {"wr7", 0x7 | WR_PREFIX},
  {  "wr8", 0x8 | WR_PREFIX},   {"wr9", 0x9 | WR_PREFIX},
  { "wr10", 0xa | WR_PREFIX},  {"wr11", 0xb | WR_PREFIX},
  { "wr12", 0xc | WR_PREFIX},  {"wr13", 0xd | WR_PREFIX},
  { "wr14", 0xe | WR_PREFIX},  {"wr15", 0xf | WR_PREFIX},
  { "wcid", 0x0 | WC_PREFIX},  {"wcon", 0x1 | WC_PREFIX},
  {"wcssf", 0x2 | WC_PREFIX}, {"wcasf", 0x3 | WC_PREFIX},
  {"wcgr0", 0x8 | WC_PREFIX}, {"wcgr1", 0x9 | WC_PREFIX},
  {"wcgr2", 0xa | WC_PREFIX}, {"wcgr3", 0xb | WC_PREFIX},

  {  "wR0", 0x0 | WR_PREFIX},   {"wR1", 0x1 | WR_PREFIX},
  {  "wR2", 0x2 | WR_PREFIX},   {"wR3", 0x3 | WR_PREFIX},
  {  "wR4", 0x4 | WR_PREFIX},   {"wR5", 0x5 | WR_PREFIX},
  {  "wR6", 0x6 | WR_PREFIX},   {"wR7", 0x7 | WR_PREFIX},
  {  "wR8", 0x8 | WR_PREFIX},   {"wR9", 0x9 | WR_PREFIX},
  { "wR10", 0xa | WR_PREFIX},  {"wR11", 0xb | WR_PREFIX},
  { "wR12", 0xc | WR_PREFIX},  {"wR13", 0xd | WR_PREFIX},
  { "wR14", 0xe | WR_PREFIX},  {"wR15", 0xf | WR_PREFIX},
  { "wCID", 0x0 | WC_PREFIX},  {"wCon", 0x1 | WC_PREFIX},
  {"wCSSF", 0x2 | WC_PREFIX}, {"wCASF", 0x3 | WC_PREFIX},
  {"wCGR0", 0x8 | WC_PREFIX}, {"wCGR1", 0x9 | WC_PREFIX},
  {"wCGR2", 0xa | WC_PREFIX}, {"wCGR3", 0xb | WC_PREFIX},
d335 1
a335 2
/* Co-processor Numbers.  */
static const struct reg_entry cp_table[] =
d337 2
a338 4
  {"p0",  0},  {"p1",  1},  {"p2",  2},  {"p3", 3},
  {"p4",  4},  {"p5",  5},  {"p6",  6},  {"p7", 7},
  {"p8",  8},  {"p9",  9},  {"p10", 10}, {"p11", 11},
  {"p12", 12}, {"p13", 13}, {"p14", 14}, {"p15", 15},
d342 1
a342 2
/* Co-processor Register Numbers.  */
static const struct reg_entry cn_table[] =
d344 8
a351 9
  {"c0",   0},  {"c1",   1},  {"c2",   2},  {"c3",   3},
  {"c4",   4},  {"c5",   5},  {"c6",   6},  {"c7",   7},
  {"c8",   8},  {"c9",   9},  {"c10",  10}, {"c11",  11},
  {"c12",  12}, {"c13",  13}, {"c14",  14}, {"c15",  15},
  /* Not really valid, but kept for back-wards compatibility.  */
  {"cr0",  0},  {"cr1",  1},  {"cr2",  2},  {"cr3",  3},
  {"cr4",  4},  {"cr5",  5},  {"cr6",  6},  {"cr7",  7},
  {"cr8",  8},  {"cr9",  9},  {"cr10", 10}, {"cr11", 11},
  {"cr12", 12}, {"cr13", 13}, {"cr14", 14}, {"cr15", 15},
d355 1
a355 2
/* FPA Registers.  */
static const struct reg_entry fn_table[] =
d357 8
a364 2
  {"f0", 0},   {"f1", 1},   {"f2", 2},   {"f3", 3},
  {"f4", 4},   {"f5", 5},   {"f6", 6},   {"f7", 7},
d368 1
a368 2
/* VFP SP Registers.  */
static const struct reg_entry sn_table[] =
d370 2
a371 8
  {"s0",  0},  {"s1",  1},  {"s2",  2},	 {"s3", 3},
  {"s4",  4},  {"s5",  5},  {"s6",  6},	 {"s7", 7},
  {"s8",  8},  {"s9",  9},  {"s10", 10}, {"s11", 11},
  {"s12", 12}, {"s13", 13}, {"s14", 14}, {"s15", 15},
  {"s16", 16}, {"s17", 17}, {"s18", 18}, {"s19", 19},
  {"s20", 20}, {"s21", 21}, {"s22", 22}, {"s23", 23},
  {"s24", 24}, {"s25", 25}, {"s26", 26}, {"s27", 27},
  {"s28", 28}, {"s29", 29}, {"s30", 30}, {"s31", 31},
d375 1
a375 2
/* VFP DP Registers.  */
static const struct reg_entry dn_table[] =
d377 2
a378 4
  {"d0",  0},  {"d1",  1},  {"d2",  2},	 {"d3", 3},
  {"d4",  4},  {"d5",  5},  {"d6",  6},	 {"d7", 7},
  {"d8",  8},  {"d9",  9},  {"d10", 10}, {"d11", 11},
  {"d12", 12}, {"d13", 13}, {"d14", 14}, {"d15", 15},
d382 1
a382 2
/* Maverick DSP coprocessor registers.  */
static const struct reg_entry mav_mvf_table[] =
d384 3
a386 4
  {"mvf0",  0},  {"mvf1",  1},  {"mvf2",  2},  {"mvf3",  3},
  {"mvf4",  4},  {"mvf5",  5},  {"mvf6",  6},  {"mvf7",  7},
  {"mvf8",  8},  {"mvf9",  9},  {"mvf10", 10}, {"mvf11", 11},
  {"mvf12", 12}, {"mvf13", 13}, {"mvf14", 14}, {"mvf15", 15},
d390 18
a407 6
static const struct reg_entry mav_mvd_table[] =
{
  {"mvd0",  0},  {"mvd1",  1},  {"mvd2",  2},  {"mvd3",  3},
  {"mvd4",  4},  {"mvd5",  5},  {"mvd6",  6},  {"mvd7",  7},
  {"mvd8",  8},  {"mvd9",  9},  {"mvd10", 10}, {"mvd11", 11},
  {"mvd12", 12}, {"mvd13", 13}, {"mvd14", 14}, {"mvd15", 15},
d411 1
a411 1
static const struct reg_entry mav_mvfx_table[] =
d413 1
a413 4
  {"mvfx0",  0},  {"mvfx1",  1},  {"mvfx2",  2},  {"mvfx3",  3},
  {"mvfx4",  4},  {"mvfx5",  5},  {"mvfx6",  6},  {"mvfx7",  7},
  {"mvfx8",  8},  {"mvfx9",  9},  {"mvfx10", 10}, {"mvfx11", 11},
  {"mvfx12", 12}, {"mvfx13", 13}, {"mvfx14", 14}, {"mvfx15", 15},
d417 1
a417 1
static const struct reg_entry mav_mvdx_table[] =
d419 1
a419 4
  {"mvdx0",  0},  {"mvdx1",  1},  {"mvdx2",  2},  {"mvdx3",  3},
  {"mvdx4",  4},  {"mvdx5",  5},  {"mvdx6",  6},  {"mvdx7",  7},
  {"mvdx8",  8},  {"mvdx9",  9},  {"mvdx10", 10}, {"mvdx11", 11},
  {"mvdx12", 12}, {"mvdx13", 13}, {"mvdx14", 14}, {"mvdx15", 15},
d423 1
a423 1
static const struct reg_entry mav_mvax_table[] =
d425 3
a427 2
  {"mvax0", 0}, {"mvax1", 1}, {"mvax2", 2}, {"mvax3", 3},
  {NULL, 0}
d430 2
a431 5
static const struct reg_entry mav_dspsc_table[] =
{
  {"dspsc", 0},
  {NULL, 0}
};
d433 2
a434 7
struct reg_map
{
  const struct reg_entry *names;
  int max_regno;
  struct hash_control *htab;
  const char *expected;
};
d436 4
a439 16
struct reg_map all_reg_maps[] =
{
  {rn_table,        15, NULL, N_("ARM register expected")},
  {cp_table,        15, NULL, N_("bad or missing co-processor number")},
  {cn_table,        15, NULL, N_("co-processor register expected")},
  {fn_table,         7, NULL, N_("FPA register expected")},
  {sn_table,	    31, NULL, N_("VFP single precision register expected")},
  {dn_table,	    15, NULL, N_("VFP double precision register expected")},
  {mav_mvf_table,   15, NULL, N_("Maverick MVF register expected")},
  {mav_mvd_table,   15, NULL, N_("Maverick MVD register expected")},
  {mav_mvfx_table,  15, NULL, N_("Maverick MVFX register expected")},
  {mav_mvdx_table,  15, NULL, N_("Maverick MVFX register expected")},
  {mav_mvax_table,   3, NULL, N_("Maverick MVAX register expected")},
  {mav_dspsc_table,  0, NULL, N_("Maverick DSPSC register expected")},
  {iwmmxt_table,    23, NULL, N_("Intel Wireless MMX technology register expected")},
};
d441 1
a441 2
/* Enumeration matching entries in table above.  */
enum arm_reg_type
d443 137
a579 16
  REG_TYPE_RN = 0,
#define REG_TYPE_FIRST REG_TYPE_RN
  REG_TYPE_CP = 1,
  REG_TYPE_CN = 2,
  REG_TYPE_FN = 3,
  REG_TYPE_SN = 4,
  REG_TYPE_DN = 5,
  REG_TYPE_MVF = 6,
  REG_TYPE_MVD = 7,
  REG_TYPE_MVFX = 8,
  REG_TYPE_MVDX = 9,
  REG_TYPE_MVAX = 10,
  REG_TYPE_DSPSC = 11,
  REG_TYPE_IWMMXT = 12,

  REG_TYPE_MAX = 13
d584 38
a621 8
static void do_arit		PARAMS ((char *));
static void do_cmp		PARAMS ((char *));
static void do_mov		PARAMS ((char *));
static void do_ldst		PARAMS ((char *));
static void do_ldstt		PARAMS ((char *));
static void do_ldmstm		PARAMS ((char *));
static void do_branch		PARAMS ((char *));
static void do_swi		PARAMS ((char *));
d623 2
a624 43
/* Pseudo Op codes.  */
static void do_adr		PARAMS ((char *));
static void do_adrl		PARAMS ((char *));
static void do_empty		PARAMS ((char *));

/* ARM v2.  */
static void do_mul		PARAMS ((char *));
static void do_mla		PARAMS ((char *));

/* ARM v2S.  */
static void do_swap		PARAMS ((char *));

/* ARM v3.  */
static void do_msr		PARAMS ((char *));
static void do_mrs		PARAMS ((char *));

/* ARM v3M.  */
static void do_mull		PARAMS ((char *));

/* ARM v4.  */
static void do_ldstv4		PARAMS ((char *));

/* ARM v4T.  */
static void do_bx               PARAMS ((char *));

/* ARM v5T.  */
static void do_blx		PARAMS ((char *));
static void do_bkpt		PARAMS ((char *));
static void do_clz		PARAMS ((char *));
static void do_lstc2		PARAMS ((char *));
static void do_cdp2		PARAMS ((char *));
static void do_co_reg2		PARAMS ((char *));

/* ARM v5TExP.  */
static void do_smla		PARAMS ((char *));
static void do_smlal		PARAMS ((char *));
static void do_smul		PARAMS ((char *));
static void do_qadd		PARAMS ((char *));

/* ARM v5TE.  */
static void do_pld		PARAMS ((char *));
static void do_ldrd		PARAMS ((char *));
static void do_co_reg2c		PARAMS ((char *));
d626 6
a631 2
/* ARM v5TEJ.  */
static void do_bxj		PARAMS ((char *));
d634 16
a649 113
static void do_cdp		PARAMS ((char *));
static void do_lstc		PARAMS ((char *));
static void do_co_reg		PARAMS ((char *));

/* FPA instructions.  */
static void do_fpa_ctrl		PARAMS ((char *));
static void do_fpa_ldst		PARAMS ((char *));
static void do_fpa_ldmstm	PARAMS ((char *));
static void do_fpa_dyadic	PARAMS ((char *));
static void do_fpa_monadic	PARAMS ((char *));
static void do_fpa_cmp		PARAMS ((char *));
static void do_fpa_from_reg	PARAMS ((char *));
static void do_fpa_to_reg	PARAMS ((char *));

/* VFP instructions.  */
static void do_vfp_sp_monadic	PARAMS ((char *));
static void do_vfp_dp_monadic	PARAMS ((char *));
static void do_vfp_sp_dyadic	PARAMS ((char *));
static void do_vfp_dp_dyadic	PARAMS ((char *));
static void do_vfp_reg_from_sp  PARAMS ((char *));
static void do_vfp_sp_from_reg  PARAMS ((char *));
static void do_vfp_sp_reg2	PARAMS ((char *));
static void do_vfp_reg_from_dp  PARAMS ((char *));
static void do_vfp_reg2_from_dp PARAMS ((char *));
static void do_vfp_dp_from_reg  PARAMS ((char *));
static void do_vfp_dp_from_reg2 PARAMS ((char *));
static void do_vfp_reg_from_ctrl PARAMS ((char *));
static void do_vfp_ctrl_from_reg PARAMS ((char *));
static void do_vfp_sp_ldst	PARAMS ((char *));
static void do_vfp_dp_ldst	PARAMS ((char *));
static void do_vfp_sp_ldstmia	PARAMS ((char *));
static void do_vfp_sp_ldstmdb	PARAMS ((char *));
static void do_vfp_dp_ldstmia	PARAMS ((char *));
static void do_vfp_dp_ldstmdb	PARAMS ((char *));
static void do_vfp_xp_ldstmia	PARAMS ((char *));
static void do_vfp_xp_ldstmdb	PARAMS ((char *));
static void do_vfp_sp_compare_z	PARAMS ((char *));
static void do_vfp_dp_compare_z	PARAMS ((char *));
static void do_vfp_dp_sp_cvt	PARAMS ((char *));
static void do_vfp_sp_dp_cvt	PARAMS ((char *));

/* XScale.  */
static void do_xsc_mia		PARAMS ((char *));
static void do_xsc_mar		PARAMS ((char *));
static void do_xsc_mra		PARAMS ((char *));

/* Maverick.  */
static void do_mav_binops	PARAMS ((char *, int, enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_binops_1a	PARAMS ((char *));
static void do_mav_binops_1b	PARAMS ((char *));
static void do_mav_binops_1c	PARAMS ((char *));
static void do_mav_binops_1d	PARAMS ((char *));
static void do_mav_binops_1e	PARAMS ((char *));
static void do_mav_binops_1f	PARAMS ((char *));
static void do_mav_binops_1g	PARAMS ((char *));
static void do_mav_binops_1h	PARAMS ((char *));
static void do_mav_binops_1i	PARAMS ((char *));
static void do_mav_binops_1j	PARAMS ((char *));
static void do_mav_binops_1k	PARAMS ((char *));
static void do_mav_binops_1l	PARAMS ((char *));
static void do_mav_binops_1m	PARAMS ((char *));
static void do_mav_binops_1n	PARAMS ((char *));
static void do_mav_binops_1o	PARAMS ((char *));
static void do_mav_binops_2a	PARAMS ((char *));
static void do_mav_binops_2b	PARAMS ((char *));
static void do_mav_binops_2c	PARAMS ((char *));
static void do_mav_binops_3a	PARAMS ((char *));
static void do_mav_binops_3b	PARAMS ((char *));
static void do_mav_binops_3c	PARAMS ((char *));
static void do_mav_binops_3d	PARAMS ((char *));
static void do_mav_triple	PARAMS ((char *, int, enum arm_reg_type,
					 enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_triple_4a	PARAMS ((char *));
static void do_mav_triple_4b	PARAMS ((char *));
static void do_mav_triple_5a	PARAMS ((char *));
static void do_mav_triple_5b	PARAMS ((char *));
static void do_mav_triple_5c	PARAMS ((char *));
static void do_mav_triple_5d	PARAMS ((char *));
static void do_mav_triple_5e	PARAMS ((char *));
static void do_mav_triple_5f	PARAMS ((char *));
static void do_mav_triple_5g	PARAMS ((char *));
static void do_mav_triple_5h	PARAMS ((char *));
static void do_mav_quad		PARAMS ((char *, int, enum arm_reg_type,
					 enum arm_reg_type,
					 enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_quad_6a	PARAMS ((char *));
static void do_mav_quad_6b	PARAMS ((char *));
static void do_mav_dspsc_1	PARAMS ((char *));
static void do_mav_dspsc_2	PARAMS ((char *));
static void do_mav_shift	PARAMS ((char *, enum arm_reg_type,
					 enum arm_reg_type));
static void do_mav_shift_1	PARAMS ((char *));
static void do_mav_shift_2	PARAMS ((char *));
static void do_mav_ldst		PARAMS ((char *, enum arm_reg_type));
static void do_mav_ldst_1	PARAMS ((char *));
static void do_mav_ldst_2	PARAMS ((char *));
static void do_mav_ldst_3	PARAMS ((char *));
static void do_mav_ldst_4	PARAMS ((char *));

static int mav_reg_required_here	PARAMS ((char **, int,
						 enum arm_reg_type));
static int mav_parse_offset	PARAMS ((char **, int *));

static void fix_new_arm		PARAMS ((fragS *, int, short, expressionS *,
					 int, int));
static int arm_reg_parse	PARAMS ((char **, struct hash_control *));
static enum arm_reg_type arm_reg_parse_any PARAMS ((char *));
static const struct asm_psr * arm_psr_parse PARAMS ((char **));
static void symbol_locate	PARAMS ((symbolS *, const char *, segT, valueT,
					 fragS *));
d652 1
a652 2
static unsigned validate_immediate_twopart PARAMS ((unsigned int,
						    unsigned int *));
a661 8
static int vfp_sp_reg_required_here PARAMS ((char **, enum vfp_sp_reg_pos));
static int vfp_dp_reg_required_here PARAMS ((char **, enum vfp_dp_reg_pos));
static void vfp_sp_ldstm	PARAMS ((char *, enum vfp_ldstm_type));
static void vfp_dp_ldstm	PARAMS ((char *, enum vfp_ldstm_type));
static long vfp_sp_reg_list	PARAMS ((char **, enum vfp_sp_reg_pos));
static long vfp_dp_reg_list	PARAMS ((char **));
static int vfp_psr_required_here PARAMS ((char **str));
static const struct vfp_reg *vfp_psr_parse PARAMS ((char **str));
d663 1
a663 1
static int cp_address_required_here	PARAMS ((char **, int));
d673 1
a673 2
static int ldst_extend		PARAMS ((char **));
static int ldst_extend_v4		PARAMS ((char **));
d675 1
a675 2
static void insert_reg		PARAMS ((const struct reg_entry *,
					 struct hash_control *));
a677 1
static void build_arm_ops_hsh	PARAMS ((void));
d680 2
a681 8
static void build_reg_hsh	PARAMS ((struct reg_map *));
static void insert_reg_alias	PARAMS ((char *, int, struct hash_control *));
static int create_register_alias	PARAMS ((char *, char *));
static void output_inst		PARAMS ((const char *));
static int accum0_required_here PARAMS ((char **));
static int ld_mode_required_here PARAMS ((char **));
static void do_branch25         PARAMS ((char *));
static symbolS * find_real_start PARAMS ((symbolS *));
a685 25
static int wreg_required_here   PARAMS ((char **, int, enum wreg_type));
static void do_iwmmxt_byte_addr PARAMS ((char *));
static void do_iwmmxt_tandc     PARAMS ((char *));
static void do_iwmmxt_tbcst     PARAMS ((char *));
static void do_iwmmxt_textrc    PARAMS ((char *));
static void do_iwmmxt_textrm    PARAMS ((char *));
static void do_iwmmxt_tinsr     PARAMS ((char *));
static void do_iwmmxt_tmcr      PARAMS ((char *));
static void do_iwmmxt_tmcrr     PARAMS ((char *));
static void do_iwmmxt_tmia      PARAMS ((char *));
static void do_iwmmxt_tmovmsk   PARAMS ((char *));
static void do_iwmmxt_tmrc      PARAMS ((char *));
static void do_iwmmxt_tmrrc     PARAMS ((char *));
static void do_iwmmxt_torc      PARAMS ((char *));
static void do_iwmmxt_waligni   PARAMS ((char *));
static void do_iwmmxt_wmov      PARAMS ((char *));
static void do_iwmmxt_word_addr PARAMS ((char *));
static void do_iwmmxt_wrwr      PARAMS ((char *));
static void do_iwmmxt_wrwrwcg   PARAMS ((char *));
static void do_iwmmxt_wrwrwr    PARAMS ((char *));
static void do_iwmmxt_wshufh    PARAMS ((char *));
static void do_iwmmxt_wzero     PARAMS ((char *));
static int cp_byte_address_offset         PARAMS ((char **));
static int cp_byte_address_required_here  PARAMS ((char **));

d690 4
a693 17
/* "INSN<cond> X,Y" where X:bit12, Y:bit16.  */
#define MAV_MODE1	0x100c

/* "INSN<cond> X,Y" where X:bit16, Y:bit12.  */
#define MAV_MODE2	0x0c10

/* "INSN<cond> X,Y" where X:0, Y:bit16.  */
#define MAV_MODE3	0x1000

/* "INSN<cond> X,Y,Z" where X:16, Y:0, Z:12.  */
#define MAV_MODE4	0x0c0010

/* "INSN<cond> X,Y,Z" where X:12, Y:16, Z:0.  */
#define MAV_MODE5	0x00100c

/* "INSN<cond> W,X,Y,Z" where W:5, X:12, Y:16, Z:0.  */
#define MAV_MODE6	0x00100c05
d698 1
a698 1
  const char * template;
d703 3
a705 3
  /* Offset into the template where the condition code (if any) will be.
     If zero, then the instruction is never conditional.  */
  unsigned cond_offset;
d707 5
a711 2
  /* Which architecture variant provides this instruction.  */
  unsigned long variant;
d714 1
a714 1
  void (* parms) PARAMS ((char *));
d717 1
a717 1
static const struct asm_opcode insns[] =
d719 35
a753 68
  /* Core ARM Instructions.  */
  {"and",        0xe0000000, 3,  ARM_EXT_V1,       do_arit},
  {"ands",       0xe0100000, 3,  ARM_EXT_V1,       do_arit},
  {"eor",        0xe0200000, 3,  ARM_EXT_V1,       do_arit},
  {"eors",       0xe0300000, 3,  ARM_EXT_V1,       do_arit},
  {"sub",        0xe0400000, 3,  ARM_EXT_V1,       do_arit},
  {"subs",       0xe0500000, 3,  ARM_EXT_V1,       do_arit},
  {"rsb",        0xe0600000, 3,  ARM_EXT_V1,       do_arit},
  {"rsbs",       0xe0700000, 3,  ARM_EXT_V1,       do_arit},
  {"add",        0xe0800000, 3,  ARM_EXT_V1,       do_arit},
  {"adds",       0xe0900000, 3,  ARM_EXT_V1,       do_arit},
  {"adc",        0xe0a00000, 3,  ARM_EXT_V1,       do_arit},
  {"adcs",       0xe0b00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbc",        0xe0c00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbcs",       0xe0d00000, 3,  ARM_EXT_V1,       do_arit},
  {"rsc",        0xe0e00000, 3,  ARM_EXT_V1,       do_arit},
  {"rscs",       0xe0f00000, 3,  ARM_EXT_V1,       do_arit},
  {"orr",        0xe1800000, 3,  ARM_EXT_V1,       do_arit},
  {"orrs",       0xe1900000, 3,  ARM_EXT_V1,       do_arit},
  {"bic",        0xe1c00000, 3,  ARM_EXT_V1,       do_arit},
  {"bics",       0xe1d00000, 3,  ARM_EXT_V1,       do_arit},

  {"tst",        0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tsts",       0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tstp",       0xe110f000, 3,  ARM_EXT_V1,       do_cmp},
  {"teq",        0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqs",       0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqp",       0xe130f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmp",        0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmps",       0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmpp",       0xe150f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmn",        0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmns",       0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmnp",       0xe170f000, 3,  ARM_EXT_V1,       do_cmp},

  {"mov",        0xe1a00000, 3,  ARM_EXT_V1,       do_mov},
  {"movs",       0xe1b00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvn",        0xe1e00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvns",       0xe1f00000, 3,  ARM_EXT_V1,       do_mov},

  {"ldr",        0xe4100000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrb",       0xe4500000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrt",       0xe4300000, 3,  ARM_EXT_V1,       do_ldstt},
  {"ldrbt",      0xe4700000, 3,  ARM_EXT_V1,       do_ldstt},
  {"str",        0xe4000000, 3,  ARM_EXT_V1,       do_ldst},
  {"strb",       0xe4400000, 3,  ARM_EXT_V1,       do_ldst},
  {"strt",       0xe4200000, 3,  ARM_EXT_V1,       do_ldstt},
  {"strbt",      0xe4600000, 3,  ARM_EXT_V1,       do_ldstt},

  {"stmia",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmib",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmda",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmdb",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfd",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfa",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmea",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmed",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},

  {"ldmia",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmib",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmda",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmdb",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfd",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfa",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmea",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmed",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},

  {"swi",        0xef000000, 3,  ARM_EXT_V1,       do_swi},
d755 2
a756 3
  /* XXX This is the wrong place to do this.  Think multi-arch.  */
  {"bl",         0xeb000000, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xea000000, 1,  ARM_EXT_V1,       do_branch},
d758 2
a759 2
  {"bl",         0xebfffffe, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xeafffffe, 1,  ARM_EXT_V1,       do_branch},
d762 124
a885 911
  /* Pseudo ops.  */
  {"adr",        0xe28f0000, 3,  ARM_EXT_V1,       do_adr},
  {"adrl",       0xe28f0000, 3,  ARM_EXT_V1,       do_adrl},
  {"nop",        0xe1a00000, 3,  ARM_EXT_V1,       do_empty},

  /* ARM 2 multiplies.  */
  {"mul",        0xe0000090, 3,  ARM_EXT_V2,       do_mul},
  {"muls",       0xe0100090, 3,  ARM_EXT_V2,       do_mul},
  {"mla",        0xe0200090, 3,  ARM_EXT_V2,       do_mla},
  {"mlas",       0xe0300090, 3,  ARM_EXT_V2,       do_mla},

  /* Generic copressor instructions.  */
  {"cdp",        0xee000000, 3,  ARM_EXT_V2,       do_cdp},
  {"ldc",        0xec100000, 3,  ARM_EXT_V2,       do_lstc},
  {"ldcl",       0xec500000, 3,  ARM_EXT_V2,       do_lstc},
  {"stc",        0xec000000, 3,  ARM_EXT_V2,       do_lstc},
  {"stcl",       0xec400000, 3,  ARM_EXT_V2,       do_lstc},
  {"mcr",        0xee000010, 3,  ARM_EXT_V2,       do_co_reg},
  {"mrc",        0xee100010, 3,  ARM_EXT_V2,       do_co_reg},

  /* ARM 3 - swp instructions.  */
  {"swp",        0xe1000090, 3,  ARM_EXT_V2S,      do_swap},
  {"swpb",       0xe1400090, 3,  ARM_EXT_V2S,      do_swap},

  /* ARM 6 Status register instructions.  */
  {"mrs",        0xe10f0000, 3,  ARM_EXT_V3,       do_mrs},
  {"msr",        0xe120f000, 3,  ARM_EXT_V3,       do_msr},
  /* ScottB: our code uses     0xe128f000 for msr.
     NickC:  but this is wrong because the bits 16 through 19 are
             handled by the PSR_xxx defines above.  */

  /* ARM 7M long multiplies.  */
  {"smull",      0xe0c00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smulls",     0xe0d00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umull",      0xe0800090, 5,  ARM_EXT_V3M,      do_mull},
  {"umulls",     0xe0900090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlal",      0xe0e00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlals",     0xe0f00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlal",      0xe0a00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlals",     0xe0b00090, 5,  ARM_EXT_V3M,      do_mull},

  /* ARM Architecture 4.  */
  {"ldrh",       0xe01000b0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsh",      0xe01000f0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsb",      0xe01000d0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"strh",       0xe00000b0, 3,  ARM_EXT_V4,       do_ldstv4},

  /* ARM Architecture 4T.  */
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.  */
  {"bx",         0xe12fff10, 2,  ARM_EXT_V4T | ARM_EXT_V5, do_bx},

  /*  ARM Architecture 5T.  */
  /* Note: blx has 2 variants, so the .value is set dynamically.
     Only one of the variants has conditional execution.  */
  {"blx",        0xe0000000, 3,  ARM_EXT_V5,       do_blx},
  {"clz",        0xe16f0f10, 3,  ARM_EXT_V5,       do_clz},
  {"bkpt",       0xe1200070, 0,  ARM_EXT_V5,       do_bkpt},
  {"ldc2",       0xfc100000, 0,  ARM_EXT_V5,       do_lstc2},
  {"ldc2l",      0xfc500000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2",       0xfc000000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2l",      0xfc400000, 0,  ARM_EXT_V5,       do_lstc2},
  {"cdp2",       0xfe000000, 0,  ARM_EXT_V5,       do_cdp2},
  {"mcr2",       0xfe000010, 0,  ARM_EXT_V5,       do_co_reg2},
  {"mrc2",       0xfe100010, 0,  ARM_EXT_V5,       do_co_reg2},

  /*  ARM Architecture 5TExP.  */
  {"smlabb",     0xe1000080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatb",     0xe10000a0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlabt",     0xe10000c0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatt",     0xe10000e0, 6,  ARM_EXT_V5ExP,    do_smla},

  {"smlawb",     0xe1200080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlawt",     0xe12000c0, 6,  ARM_EXT_V5ExP,    do_smla},

  {"smlalbb",    0xe1400080, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltb",    0xe14000a0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlalbt",    0xe14000c0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltt",    0xe14000e0, 7,  ARM_EXT_V5ExP,    do_smlal},

  {"smulbb",     0xe1600080, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultb",     0xe16000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulbt",     0xe16000c0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultt",     0xe16000e0, 6,  ARM_EXT_V5ExP,    do_smul},

  {"smulwb",     0xe12000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulwt",     0xe12000e0, 6,  ARM_EXT_V5ExP,    do_smul},

  {"qadd",       0xe1000050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdadd",      0xe1400050, 5,  ARM_EXT_V5ExP,    do_qadd},
  {"qsub",       0xe1200050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdsub",      0xe1600050, 5,  ARM_EXT_V5ExP,    do_qadd},

  /*  ARM Architecture 5TE.  */
  {"pld",        0xf450f000, 0,  ARM_EXT_V5E,      do_pld},
  {"ldrd",       0xe00000d0, 3,  ARM_EXT_V5E,      do_ldrd},
  {"strd",       0xe00000f0, 3,  ARM_EXT_V5E,      do_ldrd},

  {"mcrr",       0xec400000, 4,  ARM_EXT_V5E,      do_co_reg2c},
  {"mrrc",       0xec500000, 4,  ARM_EXT_V5E,      do_co_reg2c},

  /*  ARM Architecture 5TEJ.  */
  {"bxj",	 0xe12fff20, 3,  ARM_EXT_V5J,	   do_bxj},

  /* Core FPA instruction set (V1).  */
  {"wfs",        0xee200110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfs",        0xee300110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"wfc",        0xee400110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfc",        0xee500110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},

  {"ldfs",       0xec100100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfd",       0xec108100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfe",       0xec500100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfp",       0xec508100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},

  {"stfs",       0xec000100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfd",       0xec008100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfe",       0xec400100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfp",       0xec408100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},

  {"mvfs",       0xee008100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsp",      0xee008120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsm",      0xee008140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsz",      0xee008160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfd",       0xee008180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdp",      0xee0081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdm",      0xee0081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdz",      0xee0081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfe",       0xee088100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfep",      0xee088120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfem",      0xee088140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfez",      0xee088160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"mnfs",       0xee108100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsp",      0xee108120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsm",      0xee108140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsz",      0xee108160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfd",       0xee108180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdp",      0xee1081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdm",      0xee1081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdz",      0xee1081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfe",       0xee188100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfep",      0xee188120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfem",      0xee188140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfez",      0xee188160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"abss",       0xee208100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssp",      0xee208120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssm",      0xee208140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssz",      0xee208160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absd",       0xee208180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdp",      0xee2081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdm",      0xee2081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdz",      0xee2081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abse",       0xee288100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absep",      0xee288120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absem",      0xee288140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absez",      0xee288160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"rnds",       0xee308100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsp",      0xee308120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsm",      0xee308140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsz",      0xee308160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndd",       0xee308180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddp",      0xee3081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddm",      0xee3081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddz",      0xee3081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnde",       0xee388100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndep",      0xee388120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndem",      0xee388140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndez",      0xee388160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"sqts",       0xee408100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsp",      0xee408120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsm",      0xee408140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsz",      0xee408160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtd",       0xee408180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdp",      0xee4081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdm",      0xee4081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdz",      0xee4081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqte",       0xee488100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtep",      0xee488120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtem",      0xee488140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtez",      0xee488160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"logs",       0xee508100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsp",      0xee508120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsm",      0xee508140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsz",      0xee508160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logd",       0xee508180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdp",      0xee5081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdm",      0xee5081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdz",      0xee5081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"loge",       0xee588100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logep",      0xee588120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logem",      0xee588140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logez",      0xee588160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"lgns",       0xee608100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsp",      0xee608120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsm",      0xee608140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsz",      0xee608160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnd",       0xee608180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndp",      0xee6081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndm",      0xee6081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndz",      0xee6081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgne",       0xee688100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnep",      0xee688120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnem",      0xee688140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnez",      0xee688160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"exps",       0xee708100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsp",      0xee708120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsm",      0xee708140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsz",      0xee708160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expd",       0xee708180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdp",      0xee7081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdm",      0xee7081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee7081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expe",       0xee788100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expep",      0xee788120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expem",      0xee788140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee788160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"sins",       0xee808100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsp",      0xee808120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsm",      0xee808140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsz",      0xee808160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sind",       0xee808180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindp",      0xee8081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindm",      0xee8081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindz",      0xee8081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sine",       0xee888100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinep",      0xee888120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinem",      0xee888140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinez",      0xee888160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"coss",       0xee908100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossp",      0xee908120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossm",      0xee908140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossz",      0xee908160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosd",       0xee908180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdp",      0xee9081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdm",      0xee9081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdz",      0xee9081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cose",       0xee988100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosep",      0xee988120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosem",      0xee988140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosez",      0xee988160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"tans",       0xeea08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansp",      0xeea08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansm",      0xeea08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansz",      0xeea08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tand",       0xeea08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandp",      0xeea081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandm",      0xeea081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandz",      0xeea081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tane",       0xeea88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanep",      0xeea88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanem",      0xeea88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanez",      0xeea88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"asns",       0xeeb08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsp",      0xeeb08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsm",      0xeeb08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsz",      0xeeb08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnd",       0xeeb08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndp",      0xeeb081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndm",      0xeeb081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndz",      0xeeb081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asne",       0xeeb88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnep",      0xeeb88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnem",      0xeeb88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnez",      0xeeb88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"acss",       0xeec08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssp",      0xeec08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssm",      0xeec08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssz",      0xeec08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsd",       0xeec08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdp",      0xeec081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdm",      0xeec081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdz",      0xeec081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acse",       0xeec88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsep",      0xeec88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsem",      0xeec88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsez",      0xeec88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"atns",       0xeed08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsp",      0xeed08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsm",      0xeed08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsz",      0xeed08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnd",       0xeed08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndp",      0xeed081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndm",      0xeed081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndz",      0xeed081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atne",       0xeed88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnep",      0xeed88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnem",      0xeed88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnez",      0xeed88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"urds",       0xeee08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsp",      0xeee08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsm",      0xeee08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsz",      0xeee08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdd",       0xeee08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddp",      0xeee081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddm",      0xeee081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddz",      0xeee081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urde",       0xeee88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdep",      0xeee88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdem",      0xeee88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdez",      0xeee88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"nrms",       0xeef08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsp",      0xeef08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsm",      0xeef08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsz",      0xeef08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmd",       0xeef08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdp",      0xeef081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdm",      0xeef081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdz",      0xeef081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrme",       0xeef88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmep",      0xeef88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmem",      0xeef88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmez",      0xeef88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"adfs",       0xee000100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsp",      0xee000120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsm",      0xee000140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsz",      0xee000160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfd",       0xee000180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdp",      0xee0001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdm",      0xee0001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdz",      0xee0001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfe",       0xee080100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfep",      0xee080120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfem",      0xee080140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfez",      0xee080160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"sufs",       0xee200100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsp",      0xee200120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsm",      0xee200140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsz",      0xee200160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufd",       0xee200180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdp",      0xee2001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdm",      0xee2001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdz",      0xee2001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufe",       0xee280100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufep",      0xee280120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufem",      0xee280140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufez",      0xee280160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rsfs",       0xee300100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsp",      0xee300120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsm",      0xee300140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsz",      0xee300160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfd",       0xee300180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdp",      0xee3001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdm",      0xee3001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdz",      0xee3001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfe",       0xee380100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfep",      0xee380120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfem",      0xee380140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfez",      0xee380160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"mufs",       0xee100100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsp",      0xee100120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsm",      0xee100140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsz",      0xee100160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufd",       0xee100180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdp",      0xee1001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdm",      0xee1001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdz",      0xee1001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufe",       0xee180100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufep",      0xee180120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufem",      0xee180140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufez",      0xee180160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"dvfs",       0xee400100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsp",      0xee400120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsm",      0xee400140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsz",      0xee400160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfd",       0xee400180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdp",      0xee4001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdm",      0xee4001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdz",      0xee4001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfe",       0xee480100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfep",      0xee480120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfem",      0xee480140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfez",      0xee480160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rdfs",       0xee500100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsp",      0xee500120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsm",      0xee500140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsz",      0xee500160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfd",       0xee500180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdp",      0xee5001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdm",      0xee5001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdz",      0xee5001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfe",       0xee580100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfep",      0xee580120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfem",      0xee580140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfez",      0xee580160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"pows",       0xee600100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsp",      0xee600120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsm",      0xee600140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsz",      0xee600160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powd",       0xee600180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdp",      0xee6001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdm",      0xee6001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdz",      0xee6001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powe",       0xee680100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powep",      0xee680120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powem",      0xee680140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powez",      0xee680160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rpws",       0xee700100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsp",      0xee700120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsm",      0xee700140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsz",      0xee700160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwd",       0xee700180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdp",      0xee7001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdm",      0xee7001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdz",      0xee7001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwe",       0xee780100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwep",      0xee780120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwem",      0xee780140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwez",      0xee780160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rmfs",       0xee800100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsp",      0xee800120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsm",      0xee800140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsz",      0xee800160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfd",       0xee800180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdp",      0xee8001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdm",      0xee8001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdz",      0xee8001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfe",       0xee880100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfep",      0xee880120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfem",      0xee880140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfez",      0xee880160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"fmls",       0xee900100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsp",      0xee900120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsm",      0xee900140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsz",      0xee900160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmld",       0xee900180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldp",      0xee9001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldm",      0xee9001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldz",      0xee9001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmle",       0xee980100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlep",      0xee980120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlem",      0xee980140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlez",      0xee980160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"fdvs",       0xeea00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsp",      0xeea00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsm",      0xeea00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsz",      0xeea00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvd",       0xeea00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdp",      0xeea001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdm",      0xeea001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdz",      0xeea001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdve",       0xeea80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvep",      0xeea80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvem",      0xeea80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvez",      0xeea80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"frds",       0xeeb00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsp",      0xeeb00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsm",      0xeeb00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsz",      0xeeb00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdd",       0xeeb00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddp",      0xeeb001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddm",      0xeeb001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddz",      0xeeb001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frde",       0xeeb80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdep",      0xeeb80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdem",      0xeeb80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdez",      0xeeb80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"pols",       0xeec00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsp",      0xeec00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsm",      0xeec00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsz",      0xeec00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pold",       0xeec00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldp",      0xeec001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldm",      0xeec001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldz",      0xeec001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pole",       0xeec80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polep",      0xeec80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polem",      0xeec80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polez",      0xeec80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"cmf",        0xee90f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cmfe",       0xeed0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnf",        0xeeb0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  /* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should
     not be an optional suffix, but part of the instruction.  To be
     compatible, we accept either.  */
  {"cmfe",       0xeed0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},

  {"flts",       0xee000110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsp",      0xee000130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsm",      0xee000150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsz",      0xee000170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltd",       0xee000190, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdp",      0xee0001b0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdm",      0xee0001d0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdz",      0xee0001f0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"flte",       0xee080110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltep",      0xee080130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltem",      0xee080150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltez",      0xee080170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},

  /* The implementation of the FIX instruction is broken on some
     assemblers, in that it accepts a precision specifier as well as a
     rounding specifier, despite the fact that this is meaningless.
     To be more compatible, we accept it as well, though of course it
     does not set any bits.  */
  {"fix",        0xee100110, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixp",       0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixm",       0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixz",       0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixep",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixem",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixez",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},

  /* Instructions that were new with the real FPA, call them V2.  */
  {"lfm",        0xec100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmfd",      0xec900200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmea",      0xed100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfm",        0xec000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmfd",      0xed000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmea",      0xec800200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},

  /* VFP V1xD (single precision).  */
  /* Moves and type conversions.  */
  {"fcpys",   0xeeb00a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrs",    0xee100a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_sp},
  {"fmsr",    0xee000a10, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_from_reg},
  {"fmstat",  0xeef1fa10, 6, FPU_VFP_EXT_V1xD, do_empty},
  {"fsitos",  0xeeb80ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fuitos",  0xeeb80a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosis",  0xeebd0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosizs", 0xeebd0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouis",  0xeebc0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouizs", 0xeebc0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrx",    0xeef00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_ctrl},
  {"fmxr",    0xeee00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_ctrl_from_reg},

  /* Memory operations.  */
  {"flds",    0xed100a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fsts",    0xed000a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fldmias", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmfds", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmdbs", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmeas", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmiax", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmfdx", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmdbx", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fldmeax", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmias", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmeas", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmdbs", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmfds", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmiax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmeax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmdbx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmfdx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},

  /* Monadic operations.  */
  {"fabss",   0xeeb00ac0, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fnegs",   0xeeb10a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fsqrts",  0xeeb10ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},

  /* Dyadic operations.  */
  {"fadds",   0xee300a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fsubs",   0xee300a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmuls",   0xee200a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fdivs",   0xee800a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmacs",   0xee000a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmscs",   0xee100a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmuls",  0xee200a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmacs",  0xee000a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmscs",  0xee100a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},

  /* Comparisons.  */
  {"fcmps",   0xeeb40a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpzs",  0xeeb50a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},
  {"fcmpes",  0xeeb40ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpezs", 0xeeb50ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},

  /* VFP V1 (Double precision).  */
  /* Moves and type conversions.  */
  {"fcpyd",   0xeeb00b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcvtds",  0xeeb70ac0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fcvtsd",  0xeeb70bc0, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"fmdhr",   0xee200b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmdlr",   0xee000b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmrdh",   0xee300b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fmrdl",   0xee100b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fsitod",  0xeeb80bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fuitod",  0xeeb80b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"ftosid",  0xeebd0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftosizd", 0xeebd0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouid",  0xeebc0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouizd", 0xeebc0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},

  /* Memory operations.  */
  {"fldd",    0xed100b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fstd",    0xed000b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fldmiad", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmfdd", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmdbd", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fldmead", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmiad", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmead", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmdbd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmfdd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},

  /* Monadic operations.  */
  {"fabsd",   0xeeb00bc0, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fnegd",   0xeeb10b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fsqrtd",  0xeeb10bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},

  /* Dyadic operations.  */
  {"faddd",   0xee300b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fsubd",   0xee300b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmuld",   0xee200b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fdivd",   0xee800b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmacd",   0xee000b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmscd",   0xee100b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmuld",  0xee200b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmacd",  0xee000b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmscd",  0xee100b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},

  /* Comparisons.  */
  {"fcmpd",   0xeeb40b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpzd",  0xeeb50b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},
  {"fcmped",  0xeeb40bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpezd", 0xeeb50bc0, 7, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},

  /* VFP V2.  */
  {"fmsrr",   0xec400a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp_reg2},
  {"fmrrs",   0xec500a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp_reg2},
  {"fmdrr",   0xec400b10, 5, FPU_VFP_EXT_V2,   do_vfp_dp_from_reg2},
  {"fmrrd",   0xec500b10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_dp},

  /* Intel XScale extensions to ARM V5 ISA.  (All use CP0).  */
  {"mia",        0xee200010, 3,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miaph",      0xee280010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabb",      0xee2c0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabt",      0xee2d0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatb",      0xee2e0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatt",      0xee2f0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"mar",        0xec400000, 3,  ARM_CEXT_XSCALE,   do_xsc_mar},
  {"mra",        0xec500000, 3,  ARM_CEXT_XSCALE,   do_xsc_mra},

  /* Intel Wireless MMX technology instructions.  */
  {"tandcb",     0xee130130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandch",     0xee530130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandcw",     0xee930130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tbcstb",     0xee400010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcsth",     0xee400050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcstw",     0xee400090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"textrcb",    0xee130170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrch",    0xee530170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrcw",    0xee930170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrmub",   0xee100070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuh",   0xee500070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuw",   0xee900070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsb",   0xee100078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsh",   0xee500078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsw",   0xee900078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"tinsrb",     0xee600010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrh",     0xee600050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrw",     0xee600090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tmcr",       0xee000110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmcr},
  {"tmcrr",      0xec400000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmcrr},
  {"tmia",       0xee200010, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiaph",     0xee280010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabb",     0xee2c0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabt",     0xee2d0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatb",     0xee2e0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatt",     0xee2f0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmovmskb",   0xee100030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskh",   0xee500030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskw",   0xee900030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmrc",       0xee100110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmrc},
  {"tmrrc",      0xec500000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmrrc},
  {"torcb",      0xee130150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torch",      0xee530150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torcw",      0xee930150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"waccb",      0xee0001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wacch",      0xee4001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waccw",      0xee8001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waddbss",    0xee300180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddb",      0xee000180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddbus",    0xee100180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhss",    0xee700180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddh",      0xee400180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhus",    0xee500180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwss",    0xeeb00180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddw",      0xee800180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwus",    0xee900180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waligni",    0xee000020, 7, ARM_CEXT_IWMMXT, do_iwmmxt_waligni},
  {"walignr0",   0xee800020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr1",   0xee900020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr2",   0xeea00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr3",   0xeeb00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wand",       0xee200000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wandn",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2b",     0xee800000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2br",    0xee900000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2h",     0xeec00000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2hr",    0xeed00000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqb",    0xee000060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqh",    0xee400060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqw",    0xee800060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtub",   0xee100060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuh",   0xee500060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuw",   0xee900060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsb",   0xee300060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsh",   0xee700060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsw",   0xeeb00060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wldrb",      0xec100000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrh",      0xec100100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrw",      0xec100200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wldrd",      0xec100300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wmacs",      0xee600100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacsz",     0xee700100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacu",      0xee400100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacuz",     0xee500100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmadds",     0xeea00100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaddu",     0xee800100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsb",     0xee200160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsh",     0xee600160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsw",     0xeea00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxub",     0xee000160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuh",     0xee400160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuw",     0xee800160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsb",     0xee300160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsh",     0xee700160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsw",     0xeeb00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminub",     0xee100160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuh",     0xee500160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuw",     0xee900160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmov",       0xee000000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wmov},
  {"wmulsm",     0xee300100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulsl",     0xee200100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulum",     0xee100100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulul",     0xee000100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wor",        0xee000000, 3, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhss",   0xee700080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhus",   0xee500080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwss",   0xeeb00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwus",   0xee900080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdss",   0xeef00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdus",   0xeed00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorh",      0xee700040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorhg",     0xee700148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrorw",      0xeeb00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorwg",     0xeeb00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrord",      0xeef00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrordg",     0xeef00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsadb",      0xee000120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadbz",     0xee100120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadh",      0xee400120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadhz",     0xee500120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wshufh",     0xee0001e0, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wshufh},
  {"wsllh",      0xee500040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllhg",     0xee500148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsllw",      0xee900040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllwg",     0xee900148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wslld",      0xeed00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wslldg",     0xeed00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrah",      0xee400040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrahg",     0xee400148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsraw",      0xee800040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrawg",     0xee800148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrad",      0xeec00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsradg",     0xeec00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlh",      0xee600040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlhg",     0xee600148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlw",      0xeea00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlwg",     0xeea00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrld",      0xeee00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrldg",     0xeee00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wstrb",      0xec000000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrh",      0xec000100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrw",      0xec000200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wstrd",      0xec000300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wsubbss",    0xee3001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubb",      0xee0001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubbus",    0xee1001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhss",    0xee7001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubh",      0xee4001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhus",    0xee5001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwss",    0xeeb001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubw",      0xee8001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwus",    0xee9001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckehub", 0xee0000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuh", 0xee4000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuw", 0xee8000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsb", 0xee2000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsh", 0xee6000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsw", 0xeea000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckihb",  0xee1000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihh",  0xee5000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihw",  0xee9000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckelub", 0xee0000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluh", 0xee4000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluw", 0xee8000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsb", 0xee2000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsh", 0xee6000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsw", 0xeea000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckilb",  0xee1000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilh",  0xee5000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilw",  0xee9000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wxor",       0xee100000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wzero",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wzero},

  /* Cirrus Maverick instructions.  */
  {"cfldrs",     0xec100400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfldrd",     0xec500400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfldr32",    0xec100500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfldr64",    0xec500500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfstrs",     0xec000400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfstrd",     0xec400400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfstr32",    0xec000500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfstr64",    0xec400500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfmvsr",     0xee000450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_2a},
  {"cfmvrs",     0xee100450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1a},
  {"cfmvdlr",    0xee000410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdl",    0xee100410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmvdhr",    0xee000430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdh",    0xee100430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmv64lr",   0xee000510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64l",   0xee100510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmv64hr",   0xee000530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64h",   0xee100530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmval32",   0xee100610, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32al",   0xee000610, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvam32",   0xee100630, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32am",   0xee000630, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvah32",   0xee100650, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32ah",   0xee000650, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva32",    0xee100670, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32a",    0xee000670, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva64",    0xee100690, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3c},
  {"cfmv64a",    0xee000690, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3d},
  {"cfmvsc32",   0xee1006b0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_1},
  {"cfmv32sc",   0xee0006b0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_2},
  {"cfcpys",     0xee000400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfcpyd",     0xee000420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfcvtsd",    0xee000460, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1f},
  {"cfcvtds",    0xee000440, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1g},
  {"cfcvt32s",   0xee000480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1h},
  {"cfcvt32d",   0xee0004a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1i},
  {"cfcvt64s",   0xee0004c0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1j},
  {"cfcvt64d",   0xee0004e0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1k},
  {"cfcvts32",   0xee100580, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cfcvtd32",   0xee1005a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cftruncs32", 0xee1005c0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cftruncd32", 0xee1005e0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cfrshl32",   0xee000550, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4a},
  {"cfrshl64",   0xee000570, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4b},
  {"cfsh32",     0xee000500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_1},
  {"cfsh64",     0xee200500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_2},
  {"cfcmps",     0xee100490, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5a},
  {"cfcmpd",     0xee1004b0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5b},
  {"cfcmp32",    0xee100590, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5c},
  {"cfcmp64",    0xee1005b0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5d},
  {"cfabss",     0xee300400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfabsd",     0xee300420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfnegs",     0xee300440, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfnegd",     0xee300460, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfadds",     0xee300480, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfaddd",     0xee3004a0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfsubs",     0xee3004c0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfsubd",     0xee3004e0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfmuls",     0xee100400, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfmuld",     0xee100420, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfabs32",    0xee300500, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfabs64",    0xee300520, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfneg32",    0xee300540, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfneg64",    0xee300560, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfadd32",    0xee300580, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfadd64",    0xee3005a0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfsub32",    0xee3005c0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfsub64",    0xee3005e0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmul32",    0xee100500, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmul64",    0xee100520, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmac32",    0xee100540, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmsc32",    0xee100560, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmadd32",   0xee000600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmsub32",   0xee100600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmadda32",  0xee200600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
  {"cfmsuba32",  0xee300600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
d899 1
a900 2
#define V4_STR_BIT	0x00000020

a920 1
/* Thumb v1 (ARMv4T).  */
a945 4
/* Thumb v2 (ARMv5T).  */
static void do_t_blx		PARAMS ((char *));
static void do_t_bkpt		PARAMS ((char *));

d1028 1
a1028 1
  const char * template;
d1036 1
a1036 1
  unsigned long variant;
d1042 1
a1042 1
static const struct thumb_opcode tinsns[] =
d1044 57
a1100 56
  /* Thumb v1 (ARMv4T).  */
  {"adc",	0x4140,		2,	ARM_EXT_V4T, do_t_arit},
  {"add",	0x0000,		2,	ARM_EXT_V4T, do_t_add},
  {"and",	0x4000,		2,	ARM_EXT_V4T, do_t_arit},
  {"asr",	0x0000,		2,	ARM_EXT_V4T, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_EXT_V4T, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_EXT_V4T, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_EXT_V4T, do_t_branch23},
  {"bx",	0x4700,		2,	ARM_EXT_V4T, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_EXT_V4T, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_EXT_V4T, do_t_compare},
  {"eor",	0x4040,		2,	ARM_EXT_V4T, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_EXT_V4T, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_EXT_V4T, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_EXT_V4T, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_EXT_V4T, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_EXT_V4T, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_EXT_V4T, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_EXT_V4T, do_t_arit},
  {"orr",	0x4300,		2,	ARM_EXT_V4T, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_EXT_V4T, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_EXT_V4T, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_EXT_V4T, do_t_str},
  {"strb",	0x0000,		2,	ARM_EXT_V4T, do_t_strb},
  {"strh",	0x0000,		2,	ARM_EXT_V4T, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_EXT_V4T, do_t_swi},
  {"sub",	0x0000,		2,	ARM_EXT_V4T, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_EXT_V4T, do_t_arit},
d1102 52
a1153 5
  {"adr",       0x0000,         2,      ARM_EXT_V4T, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_EXT_V4T, do_t_nop},      /* mov r8,r8  */
  /* Thumb v2 (ARMv5T).  */
  {"blx",	0,		0,	ARM_EXT_V5T, do_t_blx},
  {"bkpt",	0xbe00,		2,	ARM_EXT_V5T, do_t_bkpt},
d1156 1
a1156 1
#define BAD_ARGS 	_("bad arguments to instruction")
d1158 2
a1159 1
#define BAD_COND 	_("instruction is not conditional")
d1166 1
d1186 2
d1189 1
d1195 1
a1195 1
const pseudo_typeS md_pseudo_table[] =
d1210 3
d1214 4
d1220 1
a1220 1
  { "file",        (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
a1230 9
/* Other internal functions.  */
static int arm_parse_extension PARAMS ((char *, int *));
static int arm_parse_cpu PARAMS ((char *));
static int arm_parse_arch PARAMS ((char *));
static int arm_parse_fpu PARAMS ((char *));
#if defined OBJ_COFF || defined OBJ_ELF
static void arm_add_note PARAMS ((const char *, const char *, unsigned int));
#endif

d1242 1
a1242 1
static int label_is_thumb_function_name = FALSE;
d1244 1
a1244 1
/* Literal Pool stuff.  */
d1248 1
a1248 36
/* Literal pool structure.  Held on a per-section
   and per-sub-section basis.  */
typedef struct literal_pool
{
  expressionS    literals [MAX_LITERAL_POOL_SIZE];
  unsigned int   next_free_entry;
  unsigned int   id;
  symbolS *      symbol;
  segT           section;
  subsegT        sub_section;
  struct literal_pool * next;
} literal_pool;

/* Pointer to a linked list of literal pools.  */
literal_pool * list_of_pools = NULL;

static literal_pool * find_literal_pool PARAMS ((void));
static literal_pool * find_or_make_literal_pool PARAMS ((void));

static literal_pool *
find_literal_pool ()
{
  literal_pool * pool;

  for (pool = list_of_pools; pool != NULL; pool = pool->next)
    {
      if (pool->section == now_seg
	  && pool->sub_section == now_subseg)
	break;
    }

  return pool;
}

static literal_pool *
find_or_make_literal_pool ()
d1250 3
a1252 5
  /* Next literal pool ID number.  */
  static unsigned int latest_pool_num = 1;
  literal_pool *      pool;

  pool = find_literal_pool ();
d1254 1
a1254 6
  if (pool == NULL)
    {
      /* Create a new pool.  */
      pool = (literal_pool *) xmalloc (sizeof (* pool));
      if (! pool)
	return NULL;
d1256 2
a1257 9
      pool->next_free_entry = 0;
      pool->section         = now_seg;
      pool->sub_section     = now_subseg;
      pool->next            = list_of_pools;
      pool->symbol          = NULL;

      /* Add it to the list.  */
      list_of_pools = pool;
    }
d1259 2
a1260 7
  /* New pools, and emptied pools, will have a NULL symbol.  */
  if (pool->symbol == NULL)
    {
      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
				    (valueT) 0, &zero_address_frag);
      pool->id = latest_pool_num ++;
    }
d1262 1
a1262 3
  /* Done.  */
  return pool;
}
a1263 2
/* Add the literal in the global 'inst'
   structure to the relevent literal pool.  */
d1267 1
a1267 4
  literal_pool * pool;
  unsigned int entry;

  pool = find_or_make_literal_pool ();
d1269 10
a1278 6
  /* Check if this literal value is already in the pool.  */
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    {
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_constant)
	  && (pool->literals[entry].X_add_number
d1280 1
a1280 2
	  && (pool->literals[entry].X_unsigned
	      == inst.reloc.exp.X_unsigned))
d1283 3
a1285 3
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
          && (inst.reloc.exp.X_op == O_symbol)
          && (pool->literals[entry].X_add_number
d1287 1
a1287 1
          && (pool->literals[entry].X_add_symbol
d1289 1
a1289 1
          && (pool->literals[entry].X_op_symbol
d1292 2
d1296 1
a1296 2
  /* Do we need to create a new entry?  */
  if (entry == pool->next_free_entry)
d1298 1
a1298 1
      if (entry >= MAX_LITERAL_POOL_SIZE)
d1300 1
a1300 1
	  inst.error = _("literal pool overflow");
d1304 2
a1305 2
      pool->literals[entry] = inst.reloc.exp;
      pool->next_free_entry += 1;
d1308 3
a1310 3
  inst.reloc.exp.X_op         = O_symbol;
  inst.reloc.exp.X_add_number = ((int) entry) * 4 - 8;
  inst.reloc.exp.X_add_symbol = pool->symbol;
d1321 1
a1321 1
     const char * name;		/* It is copied, the caller can modify.  */
d1346 1
a1346 1
  symbol_clear_list_pointers (symbolP);
d1442 1
a1442 1
  as_bad (_("invalid syntax for .req directive"));
d1472 1
a1472 2
  unsigned int entry;
  literal_pool * pool;
d1475 1
a1475 4
  pool = find_literal_pool ();
  if (pool == NULL
      || pool->symbol == NULL
      || pool->next_free_entry == 0)
d1485 1
a1485 1
  sprintf (sym_name, "$$lit_\002%x", pool->id);
d1487 1
a1487 1
  symbol_locate (pool->symbol, sym_name, now_seg,
d1489 1
a1489 1
  symbol_table_insert (pool->symbol);
d1491 1
a1491 1
  ARM_SET_THUMB (pool->symbol, thumb_mode);
d1494 1
a1494 1
  ARM_SET_INTERWORK (pool->symbol, support_interwork);
d1497 1
a1497 1
  for (entry = 0; entry < pool->next_free_entry; entry ++)
d1499 1
a1499 1
    emit_expr (&(pool->literals[entry]), 4); /* .word  */
d1501 2
a1502 3
  /* Mark the pool as empty.  */
  pool->next_free_entry = 0;
  pool->symbol = NULL;
d1517 1
a1517 1
    as_bad (_("alignment too large: %d assumed"), temp = max_alignment);
d1520 1
a1520 1
      as_bad (_("alignment negative. 0 assumed."));
d1571 1
a1571 1
  label_is_thumb_function_name = TRUE;
d1604 1
a1604 1
      as_bad (_("expected comma after name \"%s\""), name);
d1669 46
d1724 1
a1724 1
	  if (! (cpu_variant & ARM_EXT_V4T))
d1737 1
a1737 1
	  if ((cpu_variant & ARM_ALL) == ARM_EXT_V4T)
d1743 1
a1743 1
	    frag_align (2, 0, 0);
d1745 1
a1745 1
	  record_alignment (now_seg, 1);
d1791 1
a1791 1
     char *str;
d1795 2
a1796 2
  if (*str != '\0' && !inst.error)
    inst.error = _("garbage following instruction");
d1834 1
a1834 1
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_RN].htab)) != FAIL)
d1846 1
a1846 52
  sprintf (buff, _("register expected, not '%.100s'"), start);
  inst.error = buff;

  return FAIL;
}

/* A Intel Wireless MMX technology register
   must be given at this point.
   Shift is the place to put it in inst.instruction.
   Restores input start point on err.
   Returns the reg#, or FAIL.  */

static int
wreg_required_here (str, shift, reg_type)
     char ** str;
     int     shift;
     enum wreg_type reg_type;
{
  static char buff [128];
  int    reg;
  char * start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_IWMMXT].htab)) != FAIL)
    {
      if (wr_register (reg)
	  && (reg_type == IWMMXT_REG_WR || reg_type == IWMMXT_REG_WR_OR_WC))
        {
          if (shift >= 0)
            inst.instruction |= (reg ^ WR_PREFIX) << shift;
          return reg;
        }
      else if (wc_register (reg)
	       && (reg_type == IWMMXT_REG_WC || reg_type == IWMMXT_REG_WR_OR_WC))
        {
          if (shift >= 0)
            inst.instruction |= (reg ^ WC_PREFIX) << shift;
          return reg;
        }
      else if ((wcg_register (reg) && reg_type == IWMMXT_REG_WCG))
        {
          if (shift >= 0)
            inst.instruction |= ((reg ^ WC_PREFIX) - 8) << shift;
          return reg;
        }
    }

  /* Restore the start point, we may have got a reg of the wrong class.  */
  *str = start;

  /* In the few cases where we might be able to accept
     something else this error can be overridden.  */
  sprintf (buff, _("Intel Wireless MMX technology register expected, not '%.100s'"), start);
d1852 1
a1852 1
static const struct asm_psr *
d1859 1
a1859 1
  const struct asm_psr * psr;
d1868 1
a1868 1
  while (ISALPHA (c) || c == '_');
d1881 1
a1881 1
  psr = (const struct asm_psr *) hash_find (arm_psr_hsh, start);
d1900 1
a1900 1
  const struct asm_psr * psr;
d1927 1
a1927 1
     char **str;
a1929 1
  char *start;
d1931 1
a1931 2
  skip_whitespace (*str);
  start = *str;
d1936 5
a1940 2
  if ((processor = arm_reg_parse (str, all_reg_maps[REG_TYPE_CP].htab))
      == FAIL)
d1942 2
a1943 4
      *str = start;

      pchar = *(*str)++;
      if (pchar >= '0' && pchar <= '9')
d1945 2
a1946 2
	  processor = pchar - '0';
	  if (**str >= '0' && **str <= '9')
d1948 2
a1949 6
	      processor = processor * 10 + *(*str)++ - '0';
	      if (processor > 15)
		{
		  inst.error = _("illegal co-processor number");
		  return FAIL;
		}
d1952 5
a1956 5
      else
	{
	  inst.error = _("bad or missing co-processor number");
	  return FAIL;
	}
d2001 1
a2001 1
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_CN].htab)) != FAIL)
d2003 1
d2010 1
a2010 1
  inst.error = _("co-processor register expected");
d2025 1
a2025 1
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_FN].htab)) != FAIL)
d2027 1
d2034 1
a2034 1
  inst.error = _("floating point register expected");
d2090 1
a2090 1
cp_address_required_here (str, wb_ok)
a2091 1
     int wb_ok;
d2113 1
a2113 1
	  if (wb_ok && skip_past_comma (& p) == SUCCESS)
d2155 1
a2155 1
	  if (wb_ok && *p == '!')
d2185 15
a2199 3
static int
cp_byte_address_offset (str)
     char ** str;
d2201 1
a2201 1
  int offset;
d2203 2
a2204 1
  skip_whitespace (* str);
d2206 1
a2206 1
  if (! is_immediate_prefix (**str))
d2208 2
a2209 2
      inst.error = _("immediate expression expected");
      return FAIL;
d2212 1
a2212 6
  (*str)++;
  
  if (my_get_expression (& inst.reloc.exp, str))
    return FAIL;
  
  if (inst.reloc.exp.X_op == O_constant)
d2214 5
a2218 7
      offset = inst.reloc.exp.X_add_number;
      
      if (offset > 255 || offset < -255)
        {
          inst.error = _("offset too large");
          return FAIL;
        }
d2220 6
a2225 4
      if (offset >= 0)
        inst.instruction |= INDEX_UP;
      else
        offset = -offset;
d2227 8
a2234 1
      inst.instruction |= offset;
a2235 2
  else
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM_S2;
d2237 6
a2242 1
  return SUCCESS;
d2245 1
a2245 153
static int
cp_byte_address_required_here (str)
     char ** str;
{
  char * p = * str;
  int    pre_inc = 0;
  int    write_back = 0;

  if (*p == '[')
    {
      int reg;

      p++;
      skip_whitespace (p);

      if ((reg = reg_required_here (& p, 16)) == FAIL)
        return FAIL;

      skip_whitespace (p);

      if (*p == ']')
        {
          p++;
          
          if (skip_past_comma (& p) == SUCCESS)
            {
              /* [Rn], #expr */
              write_back = WRITE_BACK;
              
              if (reg == REG_PC)
                {
                  inst.error = _("pc may not be used in post-increment");
                  return FAIL;
                }

              if (cp_byte_address_offset (& p) == FAIL)
                return FAIL;
            }
          else
            pre_inc = PRE_INDEX | INDEX_UP;
        }
      else
        {
          /* '['Rn, #expr']'[!] */

          if (skip_past_comma (& p) == FAIL)
            {
              inst.error = _("pre-indexed expression expected");
              return FAIL;
            }

          pre_inc = PRE_INDEX;
          
          if (cp_byte_address_offset (& p) == FAIL)
            return FAIL;

          skip_whitespace (p);

          if (*p++ != ']')
            {
              inst.error = _("missing ]");
              return FAIL;
            }

          skip_whitespace (p);

          if (*p == '!')
            {
              if (reg == REG_PC)
                {
                  inst.error = _("pc may not be used with write-back");
                  return FAIL;
                }

              p++;
              write_back = WRITE_BACK;
            }
        }
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &p))
        return FAIL;

      inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM_S2;
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust.  */
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = PRE_INDEX;
    }

  inst.instruction |= write_back | pre_inc;
  *str = p;
  return SUCCESS;
}

static void
do_empty (str)
     char * str;
{
  /* Do nothing really.  */
  end_of_line (str);
  return;
}

static void
do_mrs (str)
     char *str;
{
  int skip = 0;

  /* Only one syntax.  */
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = _("comma expected after register name");
      return;
    }

  skip_whitespace (str);

  if (   strcmp (str, "CPSR") == 0
      || strcmp (str, "SPSR") == 0
	 /* Lower case versions for backwards compatability.  */
      || strcmp (str, "cpsr") == 0
      || strcmp (str, "spsr") == 0)
    skip = 4;

  /* This is for backwards compatability with older toolchains.  */
  else if (   strcmp (str, "cpsr_all") == 0
	   || strcmp (str, "spsr_all") == 0)
    skip = 8;
  else
    {
      inst.error = _("CPSR or SPSR expected");
      return;
    }

  if (* str == 's' || * str == 'S')
    inst.instruction |= SPSR_BIT;
  str += skip;

  end_of_line (str);
}

/* Two possible forms:
d2250 1
a2250 1
do_msr (str)
d2252 1
d2270 1
d2304 1
a2304 1
  inst.instruction |= INST_IMMEDIATE;
d2317 1
a2317 1
	  inst.error = _("invalid constant");
d2325 1
d2336 1
a2336 1
do_mull (str)
d2338 1
d2382 1
d2388 1
a2388 1
do_mul (str)
d2390 1
d2438 1
d2444 1
a2444 1
do_mla (str)
d2446 1
d2496 1
d2521 1
a2521 1
  while (ISALNUM (c))
d2573 1
a2573 1
	      if (ldst_extend_v4 (&str) == FAIL)
d2578 1
a2578 1
	      skip_whitespace (str);
d2580 5
a2584 5
	      if (* str == '!')
		{
		  str ++;
		  inst.instruction |= WRITE_BACK;
		}
d2600 1
a2600 1
	  if (ldst_extend_v4 (&str) == FAIL)
d2651 1
a2651 1
do_smla (str)
d2653 1
d2671 3
d2684 1
a2684 1
do_smlal (str)
d2686 1
d2713 4
a2716 1
  end_of_line (str);
d2724 1
a2724 1
do_smul (str)
d2726 1
d2742 3
d2754 1
a2754 1
do_qadd (str)
d2756 1
d2772 3
d2789 1
a2789 1
do_co_reg2c (str)
d2791 1
d2831 1
a2831 1
      (_("Warning: instruction unpredictable when using r15"));
d2841 3
d2853 1
a2853 1
do_clz (str)
d2855 1
d2859 6
d2886 1
a2886 1
do_lstc2 (str)
d2888 1
d2890 3
d2907 1
a2907 1
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
d2922 1
a2922 1
do_cdp2 (str)
d2924 1
d2977 3
d2990 1
a2990 1
do_co_reg2 (str)
d2992 1
d3045 2
a3046 21
  end_of_line (str);
}

/* ARM v5TEJ.  Jump to Jazelle code.  */
static void
do_bxj (str)
     char * str;
{
  int reg;

  skip_whitespace (str);

  if ((reg = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Note - it is not illegal to do a "bxj pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));
d3068 1
a3068 4
  if (my_get_expression (& expr, & str)
      || (expr.X_op != O_constant
	  /* As a convenience we allow 'bkpt' without an operand.  */
	  && expr.X_op != O_absent))
d3070 1
a3070 1
      inst.error = _("bad expression");
d3094 1
a3094 1
do_branch25 (str)
d3096 1
d3149 1
a3149 1
do_blx (str)
d3151 1
d3156 6
d3174 1
a3174 1
      do_bx (str);
d3180 2
a3181 2
	{
	  inst.error = BAD_COND;
d3183 1
a3183 1
	}
d3189 1
a3189 1
      do_branch25 (str);
d3241 2
a3242 1
	and it is an error if the caller tried to override that.  */
d3245 1
a3245 1
do_bkpt (str)
d3247 1
d3260 1
a3260 4
  if (my_get_expression (& expr, & str)
      || (expr.X_op != O_constant
	  /* As a convenience we allow 'bkpt' without an operand.  */
	  && expr.X_op != O_absent))
d3262 1
a3262 1
      inst.error = _("bad expression");
d3282 3
d3287 4
a3290 1
static unsigned long check_iwmmxt_insn PARAMS ((char *, enum iwmmxt_insn_type, int));
d3292 2
a3293 4
/* Parse INSN_TYPE insn STR having a possible IMMEDIATE_SIZE immediate.  */

static unsigned long
check_iwmmxt_insn (str, insn_type, immediate_size)
d3295 1
a3295 2
     enum iwmmxt_insn_type insn_type;
     int immediate_size;
d3297 12
a3308 4
  int reg = 0;
  const char *  inst_error;
  expressionS expr;
  unsigned long number;
d3310 2
a3311 2
  inst_error = inst.error;
  if (!inst.error)
a3312 1
  skip_whitespace (str);
d3314 4
a3317 139
  switch (insn_type)
    {
    case check_rd:
      if ((reg = reg_required_here (&str, 12)) == FAIL)
	return FAIL;
      break;
      
    case check_wr:
       if ((wreg_required_here (&str, 0, IWMMXT_REG_WR)) == FAIL)
	 return FAIL;
       break;
       
    case check_wrwr:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
      
    case check_wrwrwr:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
      
    case check_wrwrwcg:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WCG) == FAIL))
	return FAIL;
      break;
      
    case check_tbcst:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;
      
    case check_tmovmsk:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
      
    case check_tmia:
      if ((wreg_required_here (&str, 5, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 0) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;
      
    case check_tmcrr:
      if ((wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 16) == FAIL))
	return FAIL;
      break;
      
    case check_tmrrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 16) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
      
    case check_tmcr:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WC) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;
      
    case check_tmrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WC) == FAIL))
	return FAIL;
      break;
      
    case check_tinsr:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
      
    case check_textrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
      
    case check_waligni:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
      
    case check_textrm:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
      
    case check_wshufh:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
    }
  
  if (immediate_size == 0)
    {
      end_of_line (str);
      inst.error = inst_error;
      return reg;
    }
d3319 4
a3322 6
    {
      skip_whitespace (str);      
  
      /* Allow optional leading '#'. */
      if (is_immediate_prefix (* str))
        str++;
d3324 1
a3324 20
      memset (& expr, '\0', sizeof (expr));
  
      if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
        {
          inst.error = _("bad or missing expression");
          return FAIL;
        }
  
      number = expr.X_add_number;
  
      if (number != (number & immediate_size))
        {
          inst.error = _("immediate value out of range");
          return FAIL;
        }
      end_of_line (str);
      inst.error = inst_error;
      return number;
    }
}
d3327 1
a3327 1
do_iwmmxt_byte_addr (str)
d3329 1
d3331 11
a3341 2
  int op = (inst.instruction & 0x300) >> 8;
  int reg;
d3343 3
a3345 2
  inst.instruction &= ~0x300;
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;  
d3347 3
a3349 1
  skip_whitespace (str);
a3350 7
  if ((reg = wreg_required_here (&str, 12, IWMMXT_REG_WR_OR_WC)) == FAIL
      || skip_past_comma (& str) == FAIL
      || cp_byte_address_required_here (&str) == FAIL)
    {
      if (! inst.error)
        inst.error = BAD_ARGS;
    }
a3352 6

  if (wc_register (reg))
    {
      inst.instruction |=  0xf0000100;
      inst.instruction &= ~0x00400000;
    }
d3355 1
a3355 5
static void
do_iwmmxt_tandc (str)
     char * str;
{
  int reg;
d3357 1
a3357 6
  reg = check_iwmmxt_insn (str, check_rd, 0);

  if (reg != REG_PC && !inst.error)
    inst.error = _("only r15 allowed here");
  return;
}
d3360 1
a3360 1
do_iwmmxt_tbcst (str)
d3362 1
d3364 2
a3365 1
  check_iwmmxt_insn (str, check_tbcst, 0);
d3367 5
a3371 2
  return;
}
d3373 1
a3373 5
static void
do_iwmmxt_textrc (str)
     char * str;
{
  unsigned long number;
d3375 1
a3375 272
  if ((number = check_iwmmxt_insn (str, check_textrc, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= number & 0x7;
  return;
}

static void
do_iwmmxt_textrm (str)
     char * str;
{
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_textrm, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= number & 0x7;
}

static void
do_iwmmxt_tinsr (str)
     char * str;
{
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_tinsr, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= number & 0x7;
  return;
}

static void
do_iwmmxt_tmcr (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmcr, 0);

  return;
}

static void
do_iwmmxt_tmcrr (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmcrr, 0);

  return;
}

static void
do_iwmmxt_tmia (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmia, 0);

  return;
}

static void
do_iwmmxt_tmovmsk (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmovmsk, 0);

  return;
}

static void
do_iwmmxt_tmrc (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmrc, 0);

  return;
}

static void
do_iwmmxt_tmrrc (str)
     char * str;
{
  check_iwmmxt_insn (str, check_tmrrc, 0);

  return;
}

static void
do_iwmmxt_torc (str)
     char * str;
{
  check_iwmmxt_insn (str, check_rd, 0);
  return;
}

static void
do_iwmmxt_waligni (str)
     char * str;
{
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_waligni, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((number & 0x7) << 20);
  return;
}

static void
do_iwmmxt_wmov (str)
     char * str;
{
  if (check_iwmmxt_insn (str, check_wrwr, 0) == (unsigned long) FAIL)
    return;
  
  inst.instruction |= ((inst.instruction >> 16) & 0xf);
  return;
}

static void
do_iwmmxt_word_addr (str)
     char * str;
{
  int op = (inst.instruction & 0x300) >> 8;
  int reg;

  inst.instruction &= ~0x300;
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;  

  skip_whitespace (str);

  if ((reg = wreg_required_here (&str, 12, IWMMXT_REG_WR_OR_WC)) == FAIL
      || skip_past_comma (& str) == FAIL
      || cp_address_required_here (& str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
        inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);

  if (wc_register (reg))
    {
      inst.instruction |=  0xf0000100;
      inst.instruction &= ~0x00400000;
    }
}

static void
do_iwmmxt_wrwr (str)
     char * str;
{
  check_iwmmxt_insn (str, check_wrwr, 0);
  
  return;
}

static void
do_iwmmxt_wrwrwcg (str)
     char * str;
{
  check_iwmmxt_insn (str, check_wrwrwcg, 0);

  return;
}

static void
do_iwmmxt_wrwrwr (str)
     char * str;
{
  check_iwmmxt_insn (str, check_wrwrwr, 0);

  return;
}

static void
do_iwmmxt_wshufh (str)
     char * str;
{
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_wshufh, 0xff)) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((number & 0xf0) << 16) | (number & 0xf);
  return;
}

static void
do_iwmmxt_wzero (str)
     char * str;
{
  if (check_iwmmxt_insn (str, check_wr, 0) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((inst.instruction & 0xf) << 12) | ((inst.instruction & 0xf) << 16);
  return;
}

/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */

static void
do_xsc_mia (str)
     char * str;
{
  int rs;
  int rm;

  if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;

  else if (skip_past_comma (& str) == FAIL
	   || (rm = reg_required_here (& str, 0)) == FAIL)
    inst.error = BAD_ARGS;

  else if (skip_past_comma (& str) == FAIL
	   || (rs = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  /* inst.instruction has now been zapped with both rm and rs.  */
  else if (rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rm or rs is R15.  */

  else
    end_of_line (str);
}

/* Xscale move-accumulator-register (argument parse)

     MARcc   acc0,RdLo,RdHi.  */

static void
do_xsc_mar (str)
     char * str;
{
  int rdlo, rdhi;

  if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;

  else if (skip_past_comma (& str) == FAIL
	   || (rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;

  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;

  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */

  else
    end_of_line (str);
}

/* Xscale move-register-accumulator (argument parse)

     MRAcc   RdLo,RdHi,acc0.  */

static void
do_xsc_mra (str)
     char * str;
{
  int rdlo;
  int rdhi;

  skip_whitespace (str);

  if ((rdlo = reg_required_here (& str, 12)) == FAIL)
d3396 1
a3396 1
/* ARMv5TE: Preload-Cache
d3403 1
a3403 1
do_pld (str)
d3405 1
d3409 6
d3423 1
a3423 1
  ++str;
d3431 1
a3431 1
  if (*str == ']')
d3434 1
a3434 1
      ++str;
d3437 1
a3437 2
      /* Post-indexed addressing is not allowed with PLD.  */
      if (skip_past_comma (&str) == SUCCESS)
d3439 2
a3440 3
	  inst.error
	    = _("post-indexed expression used in preload instruction");
	  return;
d3442 1
a3442 1
      else if (*str == '!') /* [Rn]! */
d3445 1
a3445 1
	  ++str;
d3458 1
a3458 1
      if (ldst_extend (&str) == FAIL)
d3484 1
a3484 1
/* ARMv5TE load-consecutive (argument parse)
d3491 1
a3491 1
do_ldrd (str)
d3493 1
d3498 29
d3539 1
a3539 1
	inst.error = BAD_ARGS;
d3546 1
a3546 1
      inst.error = _("destination register must be even");
d3550 1
a3550 1
  if (rd == REG_LR)
d3552 1
a3552 1
      inst.error = _("r14 not allowed here");
d3557 3
a3559 2
      && ((inst.instruction & WRITE_BACK)
	  || (!(inst.instruction & PRE_INDEX))))
a3561 11
  /* For an index-register load, the index register must not overlap the
     destination (even if not write-back).  */
  if ((inst.instruction & V4_STR_BIT) == 0
      && (inst.instruction & HWOFFSET_IMM) == 0)
    {
      int rm = inst.instruction & 0x0000000f;

      if (rm == rd || (rm == rd + 1))
	as_warn (_("ldrd destination registers must not overlap index register"));
    }

d3635 1
a3635 1
/* Return TRUE if anything in the expression is a bignum.  */
a3653 2
static int in_my_get_expression = 0;

a3663 1
  in_my_get_expression = 1;
a3664 9
  in_my_get_expression = 0;

  if (ep->X_op == O_illegal)
    {
      /* We found a bad expression in md_operand().  */
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
d3689 1
a3689 1
      inst.error = _("invalid constant");
d3700 2
a3701 16
/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expr)
     expressionS *expr;
{
  if (in_my_get_expression)
    {
      expr->X_op = O_illegal;
      if (inst.error == NULL)
	inst.error = _("bad expression");
    }
}

/* UNRESTRICT should be one if <shift> <register> is permitted for this
   instruction.  */
d3714 1
a3714 1
  for (p = * str; ISALPHA (* p); p ++)
d3719 1
a3719 1
      inst.error = _("shift expression expected");
d3730 1
a3730 1
      inst.error = _("shift expression expected");
d3785 1
a3785 1
	      as_warn (_("shift of 0 ignored."));
d3791 1
a3791 1
	      inst.error = _("invalid immediate shift");
d3946 1
a3946 1
		      inst.error = _("constant expression expected");
d3955 1
a3955 1
		      inst.error = _("invalid constant");
d3975 1
a3975 1
		      inst.error = _("invalid constant");
d3988 1
a3988 1
      inst.error = _("register or shift expression expected");
d4041 1
a4041 1
	  inst.error = _("invalid floating point immediate expression");
d4045 1
a4045 1
	_("floating point register or immediate expression expected");
d4051 1
a4051 1
do_arit (str)
d4053 1
d4068 1
d4074 1
a4074 1
do_adr (str)
d4076 1
d4096 1
d4102 1
a4102 1
do_adrl (str)
d4104 1
d4108 2
a4109 2
     add rd, pc, #low(label-.-8)"
     add rd, rd, #high(label-.-8)"  */
d4113 3
a4115 3
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
a4118 1

d4123 1
d4129 1
d4136 1
a4136 1
do_cmp (str)
d4138 1
d4157 4
d4166 1
a4166 1
do_mov (str)
d4168 1
d4187 1
d4193 1
a4193 1
ldst_extend (str)
d4195 1
d4211 2
a4212 1
	  if (value < -4095 || value > 4095)
d4224 7
a4230 1
	  inst.instruction |= add | value;
d4234 7
a4240 1
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d4257 8
a4264 3
      inst.instruction |= add | OFFSET_REG;
      if (skip_past_comma (str) == SUCCESS)
	return decode_shift (str, SHIFT_RESTRICT);
d4271 1
a4271 1
do_ldst (str)
d4273 1
d4275 1
d4280 21
d4303 1
a4303 1
  if ((conflict_reg = reg_required_here (&str, 12)) == FAIL)
d4310 1
a4310 1
  if (skip_past_comma (&str) == FAIL)
d4312 1
a4312 1
      inst.error = _("address expected");
d4339 1
a4339 1
	      if (ldst_extend (&str) == FAIL)
d4342 10
a4351 3
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
d4356 3
d4371 10
a4380 2
	      inst.instruction |= INDEX_UP;
	      pre_inc = 1;
d4393 1
a4393 1
	  if (ldst_extend (&str) == FAIL)
a4418 6
      if ((inst.instruction & LOAD_BIT) == 0)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}

d4430 1
a4430 1
	  inst.error = _("constant expression expected");
d4434 11
a4444 1
      if (inst.reloc.exp.X_op == O_constant)
d4446 2
a4447 3
	  value = validate_immediate (inst.reloc.exp.X_add_number);

	  if (value != FAIL)
d4449 2
a4450 6
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MOV << DATA_OP_SHIFT));
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
d4454 2
a4455 3
	  value = validate_immediate (~inst.reloc.exp.X_add_number);

	  if (value != FAIL)
d4457 2
a4458 7
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MVN << DATA_OP_SHIFT));
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
d4460 5
a4465 14

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = _("literal pool insertion failed");
	  return;
	}

      /* Change the instruction exp to point to the pool.  */
      inst.reloc.type = BFD_RELOC_ARM_LITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
d4472 7
a4478 1
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
d4488 4
a4491 1
  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
d4496 3
a4498 3
static void
do_ldstt (str)
     char *        str;
d4500 8
a4507 1
  int conflict_reg;
d4509 4
a4512 1
  skip_whitespace (str);
d4514 4
a4517 6
  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d4519 1
a4519 5
  if (skip_past_comma (& str) == FAIL)
    {
      inst.error = _("address expected");
      return;
    }
d4521 2
a4522 3
  if (*str == '[')
    {
      int reg;
d4524 3
a4526 1
      str++;
d4528 5
a4532 1
      skip_whitespace (str);
d4534 11
a4544 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d4546 5
a4550 6
      /* ldrt/strt always use post-indexed addressing, so if the base is
	 the same as Rd, we warn.  */
      if (conflict_reg == reg)
	as_warn (_("%s register same as write-back base"),
		 ((inst.instruction & LOAD_BIT)
		  ? _("destination") : _("source")));
d4552 7
a4558 1
      skip_whitespace (str);
d4560 7
a4566 1
      if (*str == ']')
d4568 4
a4571 1
	  str ++;
d4573 1
a4573 1
	  if (skip_past_comma (&str) == SUCCESS)
d4575 19
a4593 3
	      /* [Rn],... (post inc)  */
	      if (ldst_extend (&str) == FAIL)
		return;
d4597 5
a4601 2
	      /* [Rn]  */
	      skip_whitespace (str);
d4603 3
a4605 5
	      /* Skip a write-back '!'.  */
	      if (*str == '!')
		str++;

	      inst.instruction |= INDEX_UP;
d4608 4
a4611 1
      else
d4613 2
a4614 2
	  inst.error = _("post-indexed expression expected");
	  return;
d4617 35
a4651 1
  else
d4653 2
a4654 1
      inst.error = _("post-indexed expression expected");
d4658 7
d4669 4
a4672 3
static int
ldst_extend_v4 (str)
     char ** str;
d4674 1
a4674 1
  int add = INDEX_UP;
d4676 3
a4678 7
  switch (**str)
    {
    case '#':
    case '$':
      (*str)++;
      if (my_get_expression (& inst.reloc.exp, str))
	return FAIL;
d4680 2
a4681 3
      if (inst.reloc.exp.X_op == O_constant)
	{
	  int value = inst.reloc.exp.X_add_number;
d4683 3
a4685 5
	  if (value < -255 || value > 255)
	    {
	      inst.error = _("address offset too large");
	      return FAIL;
	    }
d4687 1
a4687 5
	  if (value < 0)
	    {
	      value = -value;
	      add = 0;
	    }
d4689 1
a4689 28
	  /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0.  */
	  inst.instruction |= (add | HWOFFSET_IMM
			       | ((value >> 4) << 8) | (value & 0xF));
	}
      else
	{
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	  inst.reloc.pc_rel = 0;
	}
      return SUCCESS;

    case '-':
      add = 0;
      /* Fall through.  */

    case '+':
      (*str)++;
      /* Fall through.  */

    default:
      if (reg_required_here (str, 0) == FAIL)
	return FAIL;

      inst.instruction |= add;
      return SUCCESS;
    }
a4691 1
/* Halfword and signed-byte load/store operations.  */
d4693 3
a4695 2
do_ldstv4 (str)
     char *        str;
d4697 1
a4697 3
  int pre_inc = 0;
  int conflict_reg;
  int value;
d4701 11
a4711 1
  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
d4718 1
a4718 1
  if (skip_past_comma (& str) == FAIL)
d4720 1
a4720 1
      inst.error = _("address expected");
d4724 2
a4725 1
  if (*str == '[')
d4727 3
a4729 1
      int reg;
d4731 1
a4731 1
      str++;
d4733 2
a4734 1
      skip_whitespace (str);
d4736 5
a4740 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d4742 1
a4742 2
      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);
d4744 5
a4748 1
      skip_whitespace (str);
d4750 4
a4753 3
      if (*str == ']')
	{
	  str ++;
d4755 7
a4761 14
	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend_v4 (&str) == FAIL)
		return;
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	    }
	  else
	    {
	      /* [Rn]  */
	      inst.instruction |= HWOFFSET_IMM;
d4763 3
a4765 1
	      skip_whitespace (str);
d4767 2
a4768 9
	      if (*str == '!')
		{
		  if (conflict_reg)
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		  str++;
		  inst.instruction |= WRITE_BACK;
		}
d4770 26
a4795 12
	      inst.instruction |= INDEX_UP;
	      pre_inc = 1;
	    }
	}
      else
	{
	  /* [Rn,...]  */
	  if (skip_past_comma (&str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return;
	    }
d4797 3
a4799 3
	  pre_inc = 1;
	  if (ldst_extend_v4 (&str) == FAIL)
	    return;
d4801 6
a4806 1
	  skip_whitespace (str);
d4808 1
a4808 5
	  if (*str++ != ']')
	    {
	      inst.error = _("missing ]");
	      return;
	    }
d4810 4
a4813 12
	  skip_whitespace (str);

	  if (*str == '!')
	    {
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	      str++;
	      inst.instruction |= WRITE_BACK;
	    }
	}
a4814 7
  else if (*str == '=')
    {
      if ((inst.instruction & LOAD_BIT) == 0)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}
d4816 3
a4818 3
      /* XXX Does this work correctly for half-word/byte ops?  */
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;
d4820 2
a4821 1
      skip_whitespace (str);
d4823 8
a4830 2
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d4832 6
a4837 6
      if (inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = _("constant expression expected");
	  return;
	}
d4839 7
a4845 3
      if (inst.reloc.exp.X_op == O_constant)
	{
	  value = validate_immediate (inst.reloc.exp.X_add_number);
d4847 7
a4853 9
	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
d4855 7
a4861 1
	  value = validate_immediate (~ inst.reloc.exp.X_add_number);
d4863 7
a4869 10
	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
	}
d4871 3
a4873 2
      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
d4876 1
a4876 1
	    inst.error = _("literal pool insertion failed");
a4878 22

      /* Change the instruction exp to point to the pool.  */
      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
#ifndef TE_WINCE
      /* PC rel adjust.  */
      inst.reloc.exp.X_add_number -= 8;
#endif
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
a4880 1
  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
d4885 4
a4888 3
static long
reg_list (strp)
     char ** strp;
d4890 4
a4893 3
  char * str = * strp;
  long   range = 0;
  int    another_range;
d4895 1
a4895 2
  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
d4897 4
a4900 1
      another_range = 0;
d4902 7
a4908 4
      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;
d4910 6
a4915 102
	  str++;
	  do
	    {
	      int reg;

	      skip_whitespace (str);

	      if ((reg = reg_required_here (& str, -1)) == FAIL)
		return FAIL;

	      if (in_range)
		{
		  int i;

		  if (reg <= cur_reg)
		    {
		      inst.error = _("bad range in register list");
		      return FAIL;
		    }

		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}

	      if (range & (1 << reg))
		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: register range not in ascending order"));

	      range |= 1 << reg;
	      cur_reg = reg;
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;
	  skip_whitespace (str);

	  if (*str++ != '}')
	    {
	      inst.error = _("missing `}'");
	      return FAIL;
	    }
	}
      else
	{
	  expressionS expr;

	  if (my_get_expression (&expr, &str))
	    return FAIL;

	  if (expr.X_op == O_constant)
	    {
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}

	      if ((range & expr.X_add_number) != 0)
		{
		  int regno = range & expr.X_add_number;

		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: duplicated register (r%d) in register list"),
		     regno);
		}

	      range |= expr.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}

	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
	}

      skip_whitespace (str);

      if (*str == '|' || *str == '+')
	{
	  str++;
	  another_range = 1;
	}
a4916 1
  while (another_range);
d4918 3
a4920 2
  *strp = str;
  return range;
d4924 1
a4924 1
do_ldmstm (str)
d4926 1
d4928 2
a4929 2
  int base_reg;
  long range;
d4933 6
a4938 2
  if ((base_reg = reg_required_here (&str, 16)) == FAIL)
    return;
d4940 2
a4941 1
  if (base_reg == REG_PC)
d4943 2
a4944 1
      inst.error = _("r15 not allowed as base register");
d4948 2
a4949 3
  skip_whitespace (str);

  if (*str == '!')
d4951 3
a4953 2
      inst.instruction |= WRITE_BACK;
      str++;
d4957 1
a4957 1
      || (range = reg_list (&str)) == FAIL)
d4959 1
a4959 1
      if (! inst.error)
d4964 2
a4965 1
  if (*str == '^')
d4967 3
a4969 2
      str++;
      inst.instruction |= LDM_TYPE_2_OR_3;
d4972 1
a4972 1
  if (inst.instruction & WRITE_BACK)
d4974 1
a4974 2
      /* Check for unpredictable uses of writeback.  */
      if (inst.instruction & LOAD_BIT)
d4976 3
a4978 17
	  /* Not allowed in LDM type 2.  */
	  if ((inst.instruction & LDM_TYPE_2_OR_3)
	      && ((range & (1 << REG_PC)) == 0))
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list for other types.  */
	  else if (range & (1 << base_reg))
	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
	}
      else /* STM.  */
	{
	  /* Not allowed for type 2.  */
	  if (inst.instruction & LDM_TYPE_2_OR_3)
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list, or first in list.  */
	  else if ((range & (1 << base_reg))
		   && (range & ((1 << base_reg) - 1)))
	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
d4981 4
a4985 1
  inst.instruction |= range;
d4991 1
a4991 1
do_swi (str)
d4993 1
d4995 3
d5000 6
a5005 6
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str++;

  if (my_get_expression (& inst.reloc.exp, & str))
    return;
a5006 2
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
a5007 1

d5012 1
a5012 1
do_swap (str)
d5014 1
a5015 2
  int reg;

d5018 1
a5018 4
  if ((reg = reg_required_here (&str, 12)) == FAIL)
    return;

  if (reg == REG_PC)
d5020 19
a5038 1
      inst.error = _("r15 not allowed in swap");
d5043 1
a5043 1
      || (reg = reg_required_here (&str, 0)) == FAIL)
d5050 13
a5062 1
  if (reg == REG_PC)
d5064 2
a5065 1
      inst.error = _("r15 not allowed in swap");
d5069 1
d5071 1
a5071 1
      || *str++ != '[')
d5073 2
a5074 1
      inst.error = BAD_ARGS;
d5078 5
a5082 1
  skip_whitespace (str);
d5084 1
a5084 2
  if ((reg = reg_required_here (&str, 16)) == FAIL)
    return;
d5086 1
a5086 1
  if (reg == REG_PC)
d5088 1
a5088 1
      inst.error = BAD_PC;
d5092 1
a5092 3
  skip_whitespace (str);

  if (*str++ != ']')
d5094 13
a5106 2
      inst.error = _("missing ]");
      return;
d5109 5
a5113 3
  end_of_line (str);
  return;
}
d5115 11
a5125 6
static void
do_branch (str)
     char * str;
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
d5127 2
a5128 3
#ifdef OBJ_ELF
  {
    char * save_in;
d5130 2
a5131 2
    /* ScottB: February 5, 1998 - Check to see of PLT32 reloc
       required for the instruction.  */
d5133 1
a5133 26
    /* arm_parse_reloc () works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;
    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
	inst.reloc.pc_rel = 1;
      }
    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF  */
d5135 5
a5139 3
  end_of_line (str);
  return;
}
d5141 14
a5154 5
static void
do_bx (str)
     char * str;
{
  int reg;
d5156 23
a5178 1
  skip_whitespace (str);
d5180 4
a5183 1
  if ((reg = reg_required_here (&str, 0)) == FAIL)
d5185 2
a5186 1
      inst.error = BAD_ARGS;
a5189 4
  /* Note - it is not illegal to do a "bx pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));

d5194 1
a5194 1
do_cdp (str)
d5196 1
a5197 2
  /* Co-processor data operation.
     Format: CDP{cond} CP#,<expr>,CRd,CRn,CRm{,<expr>}  */
d5200 1
a5200 1
  if (co_proc_number (&str) == FAIL)
d5202 10
a5211 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d5214 1
a5214 2
  if (skip_past_comma (&str) == FAIL
      || cp_opc_expr (&str, 20,4) == FAIL)
d5216 1
a5216 1
      if (!inst.error)
d5222 1
a5222 1
      || cp_reg_required_here (&str, 12) == FAIL)
d5224 1
a5224 1
      if (!inst.error)
d5230 1
a5230 1
      || cp_reg_required_here (&str, 16) == FAIL)
d5232 1
a5232 9
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
    {
      if (!inst.error)
d5237 1
a5237 10
  if (skip_past_comma (&str) == SUCCESS)
    {
      if (cp_opc_expr (&str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

d5243 1
a5243 1
do_lstc (str)
d5245 1
a5246 3
  /* Co-processor register load/store.
     Format: <LDC|STC{cond}[L] CP#,CRd,<address>  */

d5249 1
a5249 1
  if (co_proc_number (&str) == FAIL)
d5251 10
a5260 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d5263 1
a5263 2
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
d5265 1
a5265 1
      if (!inst.error)
d5271 1
a5271 1
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
d5278 1
d5284 1
a5284 1
do_co_reg (str)
d5286 1
a5287 3
  /* Co-processor register transfer.
     Format: <MCR|MRC>{cond} CP#,<expr1>,Rd,CRn,CRm{,<expr2>}  */

d5290 1
a5290 1
  if (co_proc_number (&str) == FAIL)
d5292 1
a5292 1
      if (!inst.error)
d5298 1
a5298 1
      || cp_opc_expr (&str, 21, 3) == FAIL)
d5300 1
a5300 1
      if (!inst.error)
d5305 13
a5317 2
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
d5319 10
a5328 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d5331 1
a5331 2
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 16) == FAIL)
d5333 1
a5333 1
      if (!inst.error)
d5339 1
a5339 1
      || cp_reg_required_here (&str, 0) == FAIL)
d5341 1
a5341 1
      if (!inst.error)
d5346 1
a5346 10
  if (skip_past_comma (&str) == SUCCESS)
    {
      if (cp_opc_expr (&str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

d5352 1
a5352 1
do_fpa_ctrl (str)
d5354 1
a5355 3
  /* FP control registers.
     Format: <WFS|RFS|WFC|RFC>{cond} Rn  */

d5359 4
d5364 1
a5364 1
      if (!inst.error)
d5369 1
d5374 12
a5385 3
static void
do_fpa_ldst (str)
     char * str;
d5387 4
a5390 1
  skip_whitespace (str);
d5392 1
a5392 1
  if (fp_reg_required_here (&str, 12) == FAIL)
d5394 15
a5408 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d5410 2
a5411 6
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d5414 1
a5414 1
  end_of_line (str);
d5417 3
d5421 1
a5421 1
do_fpa_ldmstm (str)
d5423 1
d5425 1
a5425 1
  int num_regs;
d5429 2
a5430 1
  if (fp_reg_required_here (&str, 12) == FAIL)
d5437 1
a5437 3
  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d5439 4
a5442 3
      if (! inst.error)
	inst.error = _("constant expression expected");
      return;
d5444 1
a5444 2

  if (inst.reloc.exp.X_op != O_constant)
d5446 2
a5447 3
      inst.error = _("constant value required for number of registers");
      return;
    }
d5449 15
a5463 6
  num_regs = inst.reloc.exp.X_add_number;

  if (num_regs < 1 || num_regs > 4)
    {
      inst.error = _("number of registers must be in the range [1:4]");
      return;
d5466 3
a5468 1
  switch (num_regs)
d5470 8
a5477 14
    case 1:
      inst.instruction |= CP_T_X;
      break;
    case 2:
      inst.instruction |= CP_T_Y;
      break;
    case 3:
      inst.instruction |= CP_T_Y | CP_T_X;
      break;
    case 4:
      break;
    default:
      abort ();
    }
d5479 6
a5484 5
  if (inst.instruction & (CP_T_Pre | CP_T_UD)) /* ea/fd format.  */
    {
      int reg;
      int write_back;
      int offset;
d5486 6
a5491 6
      /* The instruction specified "ea" or "fd", so we can only accept
	 [Rn]{!}.  The instruction does not really support stacking or
	 unstacking, so we have to emulate these by setting appropriate
	 bits and offsets.  */
      if (skip_past_comma (&str) == FAIL
	  || *str != '[')
d5493 2
a5494 3
	  if (! inst.error)
	    inst.error = BAD_ARGS;
	  return;
d5496 4
d5501 4
a5504 9
      str++;
      skip_whitespace (str);

      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;

      skip_whitespace (str);

      if (*str != ']')
d5506 1
a5506 1
	  inst.error = BAD_ARGS;
d5510 1
a5510 2
      str++;
      if (*str == '!')
d5512 5
a5516 8
	  write_back = 1;
	  str++;
	  if (reg == REG_PC)
	    {
	      inst.error =
		_("r15 not allowed as base register with write-back");
	      return;
	    }
d5519 5
a5523 1
	write_back = 0;
d5525 1
a5525 11
      if (inst.instruction & CP_T_Pre)
	{
	  /* Pre-decrement.  */
	  offset = 3 * num_regs;
	  if (write_back)
	    inst.instruction |= CP_T_WB;
	}
      else
	{
	  /* Post-increment.  */
	  if (write_back)
d5527 9
a5535 2
	      inst.instruction |= CP_T_WB;
	      offset = 3 * num_regs;
d5538 3
d5542 39
a5580 4
	      /* No write-back, so convert this into a standard pre-increment
		 instruction -- aesthetically more pleasing.  */
	      inst.instruction |= CP_T_Pre | CP_T_UD;
	      offset = 0;
a5582 9

      inst.instruction |= offset;
    }
  else if (skip_past_comma (&str) == FAIL
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d5589 1
a5589 1
do_fpa_dyadic (str)
d5591 1
d5593 1
a5593 28
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || fp_reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}
a5594 4
static void
do_fpa_monadic (str)
     char * str;
{
d5597 2
a5598 1
  if (fp_reg_required_here (&str, 12) == FAIL)
d5605 1
a5605 2
  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
d5607 5
a5611 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d5613 1
a5613 12

  end_of_line (str);
  return;
}

static void
do_fpa_cmp (str)
     char * str;
{
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 16) == FAIL)
d5615 2
a5616 4
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d5618 15
a5632 6
  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d5635 2
a5636 3
  end_of_line (str);
  return;
}
d5638 1
a5638 7
static void
do_fpa_from_reg (str)
     char * str;
{
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 16) == FAIL)
d5640 1
a5640 49
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_fpa_to_reg (str)
     char * str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || fp_reg_required_here (&str, 0) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static int
vfp_sp_reg_required_here (str, pos)
     char **str;
     enum vfp_sp_reg_pos pos;
{
  int    reg;
  char *start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_SN].htab)) != FAIL)
    {
      switch (pos)
d5642 2
a5643 14
	case VFP_REG_Sd:
	  inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
	  break;

	case VFP_REG_Sn:
	  inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
	  break;

	case VFP_REG_Sm:
	  inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
	  break;

	default:
	  abort ();
a5644 2
      return reg;
    }
d5646 1
a5646 20
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_SN].expected);

  /* Restore the start point.  */
  *str = start;
  return FAIL;
}

static int
vfp_dp_reg_required_here (str, pos)
     char **str;
     enum vfp_dp_reg_pos pos;
{
  int   reg;
  char *start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_DN].htab)) != FAIL)
    {
      switch (pos)
d5648 3
a5650 14
	case VFP_REG_Dd:
	  inst.instruction |= reg << 12;
	  break;

	case VFP_REG_Dn:
	  inst.instruction |= reg << 16;
	  break;

	case VFP_REG_Dm:
	  inst.instruction |= reg << 0;
	  break;

	default:
	  abort ();
a5651 1694
      return reg;
    }

  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_DN].expected);

  /* Restore the start point.  */
  *str = start;
  return FAIL;
}

static void
do_vfp_sp_monadic (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_dp_monadic (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_sp_dyadic (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_dp_dyadic (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_reg_from_sp (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_sp_reg2 (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* We require exactly two consecutive SP registers.  */
  if (vfp_sp_reg_list (&str, VFP_REG_Sm) != 2)
    {
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
    }

  end_of_line (str);
  return;
}

static void
do_vfp_sp_from_reg (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_reg_from_dp (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_reg2_from_dp (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_dp_from_reg (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_dp_from_reg2 (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16))
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static const struct vfp_reg *
vfp_psr_parse (str)
     char **str;
{
  char *start = *str;
  char  c;
  char *p;
  const struct vfp_reg *vreg;

  p = start;

  /* Find the end of the current token.  */
  do
    {
      c = *p++;
    }
  while (ISALPHA (c));

  /* Mark it.  */
  *--p = 0;

  for (vreg = vfp_regs + 0;
       vreg < vfp_regs + sizeof (vfp_regs) / sizeof (struct vfp_reg);
       vreg++)
    {
      if (strcmp (start, vreg->name) == 0)
	{
	  *p = c;
	  *str = p;
	  return vreg;
	}
    }

  *p = c;
  return NULL;
}

static int
vfp_psr_required_here (str)
     char **str;
{
  char *start = *str;
  const struct vfp_reg *vreg;

  vreg = vfp_psr_parse (str);

  if (vreg)
    {
      inst.instruction |= vreg->regno;
      return SUCCESS;
    }

  inst.error = _("VFP system register expected");

  *str = start;
  return FAIL;
}

static void
do_vfp_reg_from_ctrl (str)
     char *str;
{
  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_psr_required_here (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_ctrl_from_reg (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_psr_required_here (&str) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_sp_ldst (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_dp_ldst (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

/* Parse and encode a VFP SP register list, storing the initial
   register in position POS and returning the range as the result.  If
   the string is invalid return FAIL (an invalid range).  */
static long
vfp_sp_reg_list (str, pos)
     char **str;
     enum vfp_sp_reg_pos pos;
{
  long range = 0;
  int base_reg = 0;
  int new_base;
  long base_bits = 0;
  int count = 0;
  long tempinst;
  unsigned long mask = 0;
  int warned = 0;

  if (**str != '{')
    return FAIL;

  (*str)++;
  skip_whitespace (*str);

  tempinst = inst.instruction;

  do
    {
      inst.instruction = 0;

      if ((new_base = vfp_sp_reg_required_here (str, pos)) == FAIL)
	return FAIL;

      if (count == 0 || base_reg > new_base)
	{
	  base_reg = new_base;
	  base_bits = inst.instruction;
	}

      if (mask & (1 << new_base))
	{
	  inst.error = _("invalid register list");
	  return FAIL;
	}

      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}

      mask |= 1 << new_base;
      count++;

      skip_whitespace (*str);

      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;

	  (*str)++;

	  if ((high_range
	       = arm_reg_parse (str, all_reg_maps[REG_TYPE_SN].htab))
	      == FAIL)
	    {
	      inst.error = _(all_reg_maps[REG_TYPE_SN].expected);
	      return FAIL;
	    }

	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }

	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}

	      mask |= 1 << new_base;
	      count++;
	    }
	}
    }
  while (skip_past_comma (str) != FAIL);

  if (**str != '}')
    {
      inst.error = _("invalid register list");
      return FAIL;
    }

  (*str)++;

  range = count;

  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > 32)
    abort ();

  /* Final test -- the registers must be consecutive.  */
  while (count--)
    {
      if ((mask & (1 << base_reg++)) == 0)
	{
	  inst.error = _("non-contiguous register range");
	  return FAIL;
	}
    }

  inst.instruction = tempinst | base_bits;
  return range;
}

static long
vfp_dp_reg_list (str)
     char **str;
{
  long range = 0;
  int base_reg = 0;
  int new_base;
  int count = 0;
  long tempinst;
  unsigned long mask = 0;
  int warned = 0;

  if (**str != '{')
    return FAIL;

  (*str)++;
  skip_whitespace (*str);

  tempinst = inst.instruction;

  do
    {
      inst.instruction = 0;

      if ((new_base = vfp_dp_reg_required_here (str, VFP_REG_Dd)) == FAIL)
	return FAIL;

      if (count == 0 || base_reg > new_base)
	{
	  base_reg = new_base;
	  range = inst.instruction;
	}

      if (mask & (1 << new_base))
	{
	  inst.error = _("invalid register list");
	  return FAIL;
	}

      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}

      mask |= 1 << new_base;
      count++;

      skip_whitespace (*str);

      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;

	  (*str)++;

	  if ((high_range
	       = arm_reg_parse (str, all_reg_maps[REG_TYPE_DN].htab))
	      == FAIL)
	    {
	      inst.error = _(all_reg_maps[REG_TYPE_DN].expected);
	      return FAIL;
	    }

	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }

	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}

	      mask |= 1 << new_base;
	      count++;
	    }
	}
    }
  while (skip_past_comma (str) != FAIL);

  if (**str != '}')
    {
      inst.error = _("invalid register list");
      return FAIL;
    }

  (*str)++;

  range |= 2 * count;

  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > 16)
    abort ();

  /* Final test -- the registers must be consecutive.  */
  while (count--)
    {
      if ((mask & (1 << base_reg++)) == 0)
	{
	  inst.error = _("non-contiguous register range");
	  return FAIL;
	}
    }

  inst.instruction = tempinst;
  return range;
}

static void
vfp_sp_ldstm (str, ldstm_type)
     char *str;
     enum vfp_ldstm_type ldstm_type;
{
  long range;

  skip_whitespace (str);

  if (reg_required_here (&str, 16) == FAIL)
    return;

  skip_whitespace (str);

  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  else if (ldstm_type != VFP_LDSTMIA)
    {
      inst.error = _("this addressing mode requires base-register writeback");
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || (range = vfp_sp_reg_list (&str, VFP_REG_Sd)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  inst.instruction |= range;
  end_of_line (str);
}

static void
vfp_dp_ldstm (str, ldstm_type)
     char *str;
     enum vfp_ldstm_type ldstm_type;
{
  long range;

  skip_whitespace (str);

  if (reg_required_here (&str, 16) == FAIL)
    return;

  skip_whitespace (str);

  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  else if (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX)
    {
      inst.error = _("this addressing mode requires base-register writeback");
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || (range = vfp_dp_reg_list (&str)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
    range += 1;

  inst.instruction |= range;
  end_of_line (str);
}

static void
do_vfp_sp_ldstmia (str)
     char *str;
{
  vfp_sp_ldstm (str, VFP_LDSTMIA);
}

static void
do_vfp_sp_ldstmdb (str)
     char *str;
{
  vfp_sp_ldstm (str, VFP_LDSTMDB);
}

static void
do_vfp_dp_ldstmia (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMIA);
}

static void
do_vfp_dp_ldstmdb (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMDB);
}

static void
do_vfp_xp_ldstmia (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMIAX);
}

static void
do_vfp_xp_ldstmdb (str)
     char *str;
{
  vfp_dp_ldstm (str, VFP_LDSTMDBX);
}

static void
do_vfp_sp_compare_z (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_dp_compare_z (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_dp_sp_cvt (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

static void
do_vfp_sp_dp_cvt (str)
     char *str;
{
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
  return;
}

/* Thumb specific routines.  */

/* Parse and validate that a register is of the right form, this saves
   repeated checking of this information in many similar cases.
   Unlike the 32-bit case we do not insert the register into the opcode
   here, since the position is often unknown until the full instruction
   has been parsed.  */

static int
thumb_reg (strp, hi_lo)
     char ** strp;
     int     hi_lo;
{
  int reg;

  if ((reg = reg_required_here (strp, -1)) == FAIL)
    return FAIL;

  switch (hi_lo)
    {
    case THUMB_REG_LO:
      if (reg > 7)
	{
	  inst.error = _("lo register required");
	  return FAIL;
	}
      break;

    case THUMB_REG_HI:
      if (reg < 8)
	{
	  inst.error = _("hi register required");
	  return FAIL;
	}
      break;

    default:
      break;
    }

  return reg;
}

/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode
   was SUB.  */

static void
thumb_add_sub (str, subtract)
     char * str;
     int    subtract;
{
  int Rd, Rs, Rn = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (is_immediate_prefix (*str))
    {
      Rs = Rd;
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;

      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
    }

  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
  if (Rn != FAIL)
    {
      /* All register format.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
	{
	  if (Rs != Rd)
	    {
	      inst.error = _("dest and source1 must be the same register");
	      return;
	    }

	  /* Can't do this for SUB.  */
	  if (subtract)
	    {
	      inst.error = _("subtract valid only on lo regs");
	      return;
	    }

	  inst.instruction = (T_OPCODE_ADD_HI
			      | (Rd > 7 ? THUMB_H1 : 0)
			      | (Rn > 7 ? THUMB_H2 : 0));
	  inst.instruction |= (Rd & 7) | ((Rn & 7) << 3);
	}
      else
	{
	  inst.instruction = subtract ? T_OPCODE_SUB_R3 : T_OPCODE_ADD_R3;
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
	}
    }
  else
    {
      /* Immediate expression, now things start to get nasty.  */

      /* First deal with HI regs, only very restricted cases allowed:
	 Adjusting SP, and using PC or SP to get an address.  */
      if ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
	  || (Rs > 7 && Rs != REG_SP && Rs != REG_PC))
	{
	  inst.error = _("invalid Hi register with immediate");
	  return;
	}

      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, all we can do is store all the fragments
	     we know about in the instruction and let the reloc hacking
	     work it all out.  */
	  inst.instruction = (subtract ? 0x8000 : 0) | (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
	}
      else
	{
	  int offset = inst.reloc.exp.X_add_number;

	  if (subtract)
	    offset = - offset;

	  if (offset < 0)
	    {
	      offset = - offset;
	      subtract = 1;

	      /* Quick check, in case offset is MIN_INT.  */
	      if (offset < 0)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	    }
	  /* Note - you cannot convert a subtract of 0 into an
	     add of 0 because the carry flag is set differently.  */
	  else if (offset > 0)
	    subtract = 0;

	  if (Rd == REG_SP)
	    {
	      if (offset & ~0x1fc)
		{
		  inst.error = _("invalid immediate value for stack adjust");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	      inst.instruction |= offset >> 2;
	    }
	  else if (Rs == REG_PC || Rs == REG_SP)
	    {
	      if (subtract
		  || (offset & ~0x3fc))
		{
		  inst.error = _("invalid immediate for address calculation");
		  return;
		}
	      inst.instruction = (Rs == REG_PC ? T_OPCODE_ADD_PC
				  : T_OPCODE_ADD_SP);
	      inst.instruction |= (Rd << 8) | (offset >> 2);
	    }
	  else if (Rs == Rd)
	    {
	      if (offset & ~0xff)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	      inst.instruction |= (Rd << 8) | offset;
	    }
	  else
	    {
	      if (offset & ~0x7)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	      inst.instruction |= Rd | (Rs << 3) | (offset << 6);
	    }
	}
    }

  end_of_line (str);
}

static void
thumb_shift (str, shift)
     char * str;
     int    shift;
{
  int Rd, Rs, Rn = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (is_immediate_prefix (*str))
    {
      /* Two operand immediate format, set Rs to Rd.  */
      Rs = Rd;
      str ++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;

      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
    }

  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */

  if (Rn != FAIL)
    {
      if (Rs != Rd)
	{
	  inst.error = _("source1 and dest must be same register");
	  return;
	}

      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_R; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_R; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_R; break;
	}

      inst.instruction |= Rd | (Rn << 3);
    }
  else
    {
      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_I; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_I; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_I; break;
	}

      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, create a dummy reloc and let reloc
	     hacking fix it up.  */
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	}
      else
	{
	  unsigned shift_value = inst.reloc.exp.X_add_number;

	  if (shift_value > 32 || (shift_value == 32 && shift == THUMB_LSL))
	    {
	      inst.error = _("invalid immediate for shift");
	      return;
	    }

	  /* Shifts of zero are handled by converting to LSL.  */
	  if (shift_value == 0)
	    inst.instruction = T_OPCODE_LSL_I;

	  /* Shifts of 32 are encoded as a shift of zero.  */
	  if (shift_value == 32)
	    shift_value = 0;

	  inst.instruction |= shift_value << 6;
	}

      inst.instruction |= Rd | (Rs << 3);
    }

  end_of_line (str);
}

static void
thumb_mov_compare (str, move)
     char * str;
     int    move;
{
  int Rd, Rs = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (is_immediate_prefix (*str))
    {
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;

  if (Rs != FAIL)
    {
      if (Rs < 8 && Rd < 8)
	{
	  if (move == THUMB_MOVE)
	    /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	       since a MOV instruction produces unpredictable results.  */
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;
	  inst.instruction |= Rd | (Rs << 3);
	}
      else
	{
	  if (move == THUMB_MOVE)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else
	    inst.instruction = T_OPCODE_CMP_HR;

	  if (Rd > 7)
	    inst.instruction |= THUMB_H1;

	  if (Rs > 7)
	    inst.instruction |= THUMB_H2;

	  inst.instruction |= (Rd & 7) | ((Rs & 7) << 3);
	}
    }
  else
    {
      if (Rd > 7)
	{
	  inst.error = _("only lo regs allowed with immediate");
	  return;
	}

      if (move == THUMB_MOVE)
	inst.instruction = T_OPCODE_MOV_I8;
      else
	inst.instruction = T_OPCODE_CMP_I8;

      inst.instruction |= Rd << 8;

      if (inst.reloc.exp.X_op != O_constant)
	inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
      else
	{
	  unsigned value = inst.reloc.exp.X_add_number;

	  if (value > 255)
	    {
	      inst.error = _("invalid immediate");
	      return;
	    }

	  inst.instruction |= value;
	}
    }

  end_of_line (str);
}

static void
thumb_load_store (str, load_store, size)
     char * str;
     int    load_store;
     int    size;
{
  int Rd, Rb, Ro = FAIL;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (*str == '[')
    {
      str++;
      if ((Rb = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;

      if (skip_past_comma (&str) != FAIL)
	{
	  if (is_immediate_prefix (*str))
	    {
	      str++;
	      if (my_get_expression (&inst.reloc.exp, &str))
		return;
	    }
	  else if ((Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	    return;
	}
      else
	{
	  inst.reloc.exp.X_op = O_constant;
	  inst.reloc.exp.X_add_number = 0;
	}

      if (*str != ']')
	{
	  inst.error = _("expected ']'");
	  return;
	}
      str++;
    }
  else if (*str == '=')
    {
      if (load_store != THUMB_LOAD)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}

      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;

      skip_whitespace (str);

      if (my_get_expression (& inst.reloc.exp, & str))
	return;

      end_of_line (str);

      if (   inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = "Constant expression expected";
	  return;
	}

      if (inst.reloc.exp.X_op == O_constant
	  && ((inst.reloc.exp.X_add_number & ~0xFF) == 0))
	{
	  /* This can be done with a mov instruction.  */

	  inst.instruction  = T_OPCODE_MOV_I8 | (Rd << 8);
	  inst.instruction |= inst.reloc.exp.X_add_number;
	  return;
	}

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = "literal pool insertion failed";
	  return;
	}

      inst.reloc.type   = BFD_RELOC_ARM_THUMB_OFFSET;
      inst.reloc.pc_rel = 1;
      inst.instruction  = T_OPCODE_LDR_PC | (Rd << 8);
      /* Adjust ARM pipeline offset to Thumb.  */
      inst.reloc.exp.X_add_number += 4;

      return;
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;

      inst.instruction = T_OPCODE_LDR_PC | (Rd << 8);
      inst.reloc.pc_rel = 1;
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset.  */
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      end_of_line (str);
      return;
    }

  if (Rb == REG_PC || Rb == REG_SP)
    {
      if (size != THUMB_WORD)
	{
	  inst.error = _("byte or halfword not valid for base register");
	  return;
	}
      else if (Rb == REG_PC && load_store != THUMB_LOAD)
	{
	  inst.error = _("r15 based store not allowed");
	  return;
	}
      else if (Ro != FAIL)
	{
	  inst.error = _("invalid base register for register offset");
	  return;
	}

      if (Rb == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (load_store == THUMB_LOAD)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;

      inst.instruction |= Rd << 8;
      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;

	  if (offset & ~0x3fc)
	    {
	      inst.error = _("invalid offset");
	      return;
	    }

	  inst.instruction |= offset >> 2;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
    }
  else if (Rb > 7)
    {
      inst.error = _("invalid base register in load/store");
      return;
    }
  else if (Ro == FAIL)
    {
      /* Immediate offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IW : T_OPCODE_STR_IW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IH : T_OPCODE_STR_IH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IB : T_OPCODE_STR_IB);

      inst.instruction |= Rd | (Rb << 3);

      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;

	  if (offset & ~(0x1f << size))
	    {
	      inst.error = _("invalid offset");
	      return;
	    }
	  inst.instruction |= (offset >> size) << 6;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
    }
  else
    {
      /* Register offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RW : T_OPCODE_STR_RW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RH : T_OPCODE_STR_RH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RB : T_OPCODE_STR_RB);

      inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
    }

  end_of_line (str);
}

/* A register must be given at this point.

   Shift is the place to put it in inst.instruction.

   Restores input start point on err.
   Returns the reg#, or FAIL.  */

static int
mav_reg_required_here (str, shift, regtype)
     char ** str;
     int shift;
     enum arm_reg_type regtype;
{
  int   reg;
  char *start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[regtype].htab)) != FAIL)
    {
      if (shift >= 0)
	inst.instruction |= reg << shift;

      return reg;
    }

  /* Restore the start point.  */
  *str = start;

  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[regtype].expected);

  return FAIL;
}

/* Cirrus Maverick Instructions.  */

/* Wrapper functions.  */

static void
do_mav_binops_1a (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVF);
}

static void
do_mav_binops_1b (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVD);
}

static void
do_mav_binops_1c (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVDX);
}

static void
do_mav_binops_1d (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVF);
}

static void
do_mav_binops_1e (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVD);
}

static void
do_mav_binops_1f (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVF);
}

static void
do_mav_binops_1g (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVD);
}

static void
do_mav_binops_1h (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVFX);
}

static void
do_mav_binops_1i (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVFX);
}

static void
do_mav_binops_1j (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVDX);
}

static void
do_mav_binops_1k (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVDX);
}

static void
do_mav_binops_1l (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVF);
}

static void
do_mav_binops_1m (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVD);
}

static void
do_mav_binops_1n (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_binops_1o (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static void
do_mav_binops_2a (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVF, REG_TYPE_RN);
}

static void
do_mav_binops_2b (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVD, REG_TYPE_RN);
}

static void
do_mav_binops_2c (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVDX, REG_TYPE_RN);
}

static void
do_mav_binops_3a (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVFX);
}

static void
do_mav_binops_3b (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVFX, REG_TYPE_MVAX);
}

static void
do_mav_binops_3c (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVDX);
}

static void
do_mav_binops_3d (str)
     char * str;
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVDX, REG_TYPE_MVAX);
}

static void
do_mav_triple_4a (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_RN);
}

static void
do_mav_triple_4b (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_RN);
}

static void
do_mav_triple_5a (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVF, REG_TYPE_MVF);
}

static void
do_mav_triple_5b (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVD, REG_TYPE_MVD);
}

static void
do_mav_triple_5c (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_triple_5d (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static void
do_mav_triple_5e (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVF, REG_TYPE_MVF, REG_TYPE_MVF);
}
d5653 10
a5662 6
static void
do_mav_triple_5f (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVD, REG_TYPE_MVD, REG_TYPE_MVD);
}
d5664 9
a5672 6
static void
do_mav_triple_5g (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_MVFX);
}
d5674 5
a5678 6
static void
do_mav_triple_5h (str)
     char * str;
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_MVDX);
}
d5680 3
a5682 7
static void
do_mav_quad_6a (str)
     char * str;
{
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVFX, REG_TYPE_MVFX,
	     REG_TYPE_MVFX);
}
d5684 3
a5686 7
static void
do_mav_quad_6b (str)
     char * str;
{
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVAX, REG_TYPE_MVFX,
	     REG_TYPE_MVFX);
}
d5688 2
a5689 6
/* cfmvsc32<cond> DSPSC,MVFX[15:0].  */
static void
do_mav_dspsc_1 (str)
     char * str;
{
  skip_whitespace (str);
d5691 1
a5691 9
  /* cfmvsc32.  */
  if (mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, 16, REG_TYPE_MVFX) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;

      return;
a5696 1
/* cfmv32sc<cond> MVFX[15:0],DSPSC.  */
d5698 1
a5698 1
do_mav_dspsc_2 (str)
d5700 1
d5702 2
d5706 2
a5707 4
  /* cfmv32sc.  */
  if (mav_reg_required_here (&str, 0, REG_TYPE_MVFX) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL)
d5709 1
a5709 1
      if (!inst.error)
a5710 1

d5714 8
a5721 2
  end_of_line (str);
}
d5723 18
a5740 6
static void
do_mav_shift_1 (str)
     char * str;
{
  do_mav_shift (str, REG_TYPE_MVFX, REG_TYPE_MVFX);
}
d5742 2
a5743 6
static void
do_mav_shift_2 (str)
     char * str;
{
  do_mav_shift (str, REG_TYPE_MVDX, REG_TYPE_MVDX);
}
d5745 2
a5746 6
static void
do_mav_ldst_1 (str)
     char * str;
{
  do_mav_ldst (str, REG_TYPE_MVF);
}
d5748 10
a5757 6
static void
do_mav_ldst_2 (str)
     char * str;
{
  do_mav_ldst (str, REG_TYPE_MVD);
}
d5759 4
a5762 6
static void
do_mav_ldst_3 (str)
     char * str;
{
  do_mav_ldst (str, REG_TYPE_MVFX);
}
d5764 1
a5764 6
static void
do_mav_ldst_4 (str)
     char * str;
{
  do_mav_ldst (str, REG_TYPE_MVDX);
}
d5766 5
a5770 1
/* Isnsn like "foo X,Y".  */
d5772 5
a5776 8
static void
do_mav_binops (str, mode, reg0, reg1)
     char * str;
     int mode;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
{
  int shift0, shift1;
d5778 3
a5780 2
  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
d5782 1
a5782 11
  skip_whitespace (str);

  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
a5784 2
/* Isnsn like "foo X,Y,Z".  */

d5786 1
a5786 1
do_mav_triple (str, mode, reg0, reg1, reg2)
d5788 2
a5789 4
     int mode;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
     enum arm_reg_type reg2;
d5791 1
a5791 5
  int shift0, shift1, shift2;

  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;
d5795 2
a5796 5
  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL)
d5798 1
a5798 1
      if (!inst.error)
d5800 1
a5801 3
  else
    end_of_line (str);
}
d5803 5
a5807 2
/* Isnsn like "foo W,X,Y,Z".
    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */
d5809 16
a5824 10
static void
do_mav_quad (str, mode, reg0, reg1, reg2, reg3)
     char * str;
     int mode;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
     enum arm_reg_type reg2;
     enum arm_reg_type reg3;
{
  int shift0, shift1, shift2, shift3;
d5826 11
a5836 4
  shift0= mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;
  shift3 = (mode >> 24) & 0xff;
d5838 1
a5838 1
  skip_whitespace (str);
d5840 2
a5841 14
  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift3, reg3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}
d5843 1
a5843 3
/* Maverick shift immediate instructions.
   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */
d5845 6
a5850 8
static void
do_mav_shift (str, reg0, reg1)
     char * str;
     enum arm_reg_type reg0;
     enum arm_reg_type reg1;
{
  int error;
  int imm, neg = 0;
d5852 4
a5855 1
  skip_whitespace (str);
d5857 4
a5860 11
  error = 0;

  if (mav_reg_required_here (&str, 12, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, 16, reg1) == FAIL
      || skip_past_comma  (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d5862 7
a5868 3
  /* Calculate the immediate operand.
     The operand is a 7bit signed number.  */
  skip_whitespace (str);
d5870 5
a5874 2
  if (*str == '#')
    ++str;
a5875 3
  if (!ISDIGIT (*str) && *str != '-')
    {
      inst.error = _("expecting immediate, 7bit operand");
d5878 1
a5878 2

  if (*str == '-')
d5880 2
a5881 3
      neg = 1;
      ++str;
    }
d5883 5
a5887 6
  for (imm = 0; *str && ISDIGIT (*str); ++str)
    imm = imm * 10 + *str - '0';

  if (imm > 64)
    {
      inst.error = _("immediate out of range");
d5891 1
a5891 2
  /* Make negative imm's into 7bit signed numbers.  */
  if (neg)
d5893 15
a5907 3
      imm = -imm;
      imm &= 0x0000007f;
    }
d5909 6
a5914 4
  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
     Bits 5-7 of the insn should have bits 4-6 of the immediate.
     Bit 4 should be 0.  */
  imm = (imm & 0xf) | ((imm & 0x70) << 1);
d5916 4
a5919 3
  inst.instruction |= imm;
  end_of_line (str);
}
d5921 5
a5925 7
static int
mav_parse_offset (str, negative)
     char ** str;
     int *negative;
{
  char * p = *str;
  int offset;
d5927 4
a5930 11
  *negative = 0;

  skip_whitespace (p);

  if (*p == '#')
    ++p;

  if (*p == '-')
    {
      *negative = 1;
      ++p;
d5932 1
a5932 2

  if (!ISDIGIT (*p))
d5934 2
a5935 2
      inst.error = _("offset expected");
      return 0;
d5937 1
a5937 5

  for (offset = 0; *p && ISDIGIT (*p); ++p)
    offset = offset * 10 + *p - '0';

  if (offset > 0xff)
d5939 10
a5948 3
      inst.error = _("offset out of range");
      return 0;
    }
d5950 1
a5950 1
  *str = p;
d5952 1
a5952 33
  return *negative ? -offset : offset;
}

/* Maverick load/store instructions.
  <insn><cond> CRd,[Rn,<offset>]{!}.
  <insn><cond> CRd,[Rn],<offset>.  */

static void
do_mav_ldst (str, reg0)
     char * str;
     enum arm_reg_type reg0;
{
  int offset, negative;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, 12, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || reg_required_here (&str, 16) == FAIL)
    goto fail_ldst;

  if (skip_past_comma (&str) == SUCCESS)
    {
      /* You are here: "<offset>]{!}".  */
      inst.instruction |= PRE_INDEX;

      offset = mav_parse_offset (&str, &negative);

      if (inst.error)
	return;

      if (*str++ != ']')
d5954 1
a5954 3
	  inst.error = _("missing ]");
	  return;
	}
d5956 6
a5961 4
      if (*str == '!')
	{
	  inst.instruction |= WRITE_BACK;
	  ++str;
d5963 2
d5968 10
a5977 6
      /* You are here: "], <offset>".  */
      if (*str++ != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}
d5979 1
a5979 5
      if (skip_past_comma (&str) == FAIL
	  || (offset = mav_parse_offset (&str, &negative), inst.error))
	goto fail_ldst;

      inst.instruction |= CP_T_WB; /* Post indexed, set bit W.  */
a5981 6
  if (negative)
    offset = -offset;
  else
    inst.instruction |= CP_T_UD; /* Postive, so set bit U.  */

  inst.instruction |= offset >> 2;
a5982 6
  return;

fail_ldst:
  if (!inst.error)
     inst.error = BAD_ARGS;
  return;
d6185 1
a6185 1
    as_warn (_("inserted missing '!': load/store multiple always writes back base register"));
d6201 1
a6201 1
      inst.error = _("expression too complex");
d6253 1
a6253 1
	inst.error = _("syntax: ldrs[b] Rd, [Rb, Ro]");
d6301 1
a6301 1
      inst.error = _("expression too complex");
d6398 2
a6399 3
insert_reg (r, htab)
     const struct reg_entry *r;
     struct hash_control *htab;
d6401 1
a6401 1
  int    len  = strlen (r->name) + 2;
d6410 1
a6410 184
  strcpy (buf + i, r->name);

  for (i = 0; buf[i]; i++)
    buf2[i] = TOUPPER (buf[i]);

  buf2[i] = '\0';

  hash_insert (htab, buf,  (PTR) r);
  hash_insert (htab, buf2, (PTR) r);
}

static void
build_reg_hsh (map)
     struct reg_map *map;
{
  const struct reg_entry *r;

  if ((map->htab = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  for (r = map->names; r->name != NULL; r++)
    insert_reg (r, map->htab);
}

static void
insert_reg_alias (str, regnum, htab)
     char *str;
     int regnum;
     struct hash_control *htab;
{
  struct reg_entry *new =
    (struct reg_entry *) xmalloc (sizeof (struct reg_entry));
  char *name = xmalloc (strlen (str) + 1);
  strcpy (name, str);

  new->name = name;
  new->number = regnum;

  hash_insert (htab, name, (PTR) new);
}

/* Look for the .req directive.  This is of the form:

   	newname .req existing_name

   If we find one, or if it looks sufficiently like one that we want to
   handle any error here, return non-zero.  Otherwise return zero.  */
static int
create_register_alias (newname, p)
     char *newname;
     char *p;
{
  char *q;
  char c;

  q = p;
  skip_whitespace (q);

  c = *p;
  *p = '\0';

  if (*q && !strncmp (q, ".req ", 5))
    {
      char *copy_of_str;
      char *r;

#ifdef IGNORE_OPCODE_CASE
      newname = original_case_string;
#endif
      copy_of_str = newname;

      q += 4;
      skip_whitespace (q);

      for (r = q; *r != '\0'; r++)
	if (*r == ' ')
	  break;

      if (r != q)
	{
	  enum arm_reg_type new_type, old_type;
	  int old_regno;
	  char d = *r;

	  *r = '\0';
	  old_type = arm_reg_parse_any (q);
	  *r = d;

	  new_type = arm_reg_parse_any (newname);

	  if (new_type == REG_TYPE_MAX)
	    {
	      if (old_type != REG_TYPE_MAX)
		{
		  old_regno = arm_reg_parse (&q, all_reg_maps[old_type].htab);
		  insert_reg_alias (newname, old_regno,
				    all_reg_maps[old_type].htab);
		}
	      else
		as_warn (_("register '%s' does not exist\n"), q);
	    }
	  else if (old_type == REG_TYPE_MAX)
	    {
	      as_warn (_("ignoring redefinition of register alias '%s' to non-existant register '%s'"),
		       copy_of_str, q);
	    }
	  else
	    {
	      /* Do not warn about redefinitions to the same alias.  */
	      if (new_type != old_type
		  || (arm_reg_parse (&q, all_reg_maps[old_type].htab)
		      != arm_reg_parse (&q, all_reg_maps[new_type].htab)))
		as_warn (_("ignoring redefinition of register alias '%s'"),
			 copy_of_str);

	    }
	}
      else
	as_warn (_("ignoring incomplete .req pseuso op"));

      *p = c;
      return 1;
    }
  *p = c;
  return 0;
}

static void
set_constant_flonums ()
{
  int i;

  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
}

/* Iterate over the base tables to create the instruction patterns.  */
static void
build_arm_ops_hsh ()
{
  unsigned int i;
  unsigned int j;
  static struct obstack insn_obstack;

  obstack_begin (&insn_obstack, 4000);

  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    {
      const struct asm_opcode *insn = insns + i;

      if (insn->cond_offset != 0)
	{
	  /* Insn supports conditional execution.  Build the varaints
	     and insert them in the hash table.  */
	  for (j = 0; j < sizeof (conds) / sizeof (struct asm_cond); j++)
	    {
	      unsigned len = strlen (insn->template);
	      struct asm_opcode *new;
	      char *template;

	      new = obstack_alloc (&insn_obstack, sizeof (struct asm_opcode));
	      /* All condition codes are two characters.  */
	      template = obstack_alloc (&insn_obstack, len + 3);

	      strncpy (template, insn->template, insn->cond_offset);
	      strcpy (template + insn->cond_offset, conds[j].template);
	      if (len > insn->cond_offset)
		strcpy (template + insn->cond_offset + 2,
			insn->template + insn->cond_offset);
	      new->template = template;
	      new->cond_offset = 0;
	      new->variant = insn->variant;
	      new->parms = insn->parms;
	      new->value = (insn->value & ~COND_MASK) | conds[j].value;

	      hash_insert (arm_ops_hsh, new->template, (PTR) new);
	    }
	}
      /* Finally, insert the unconditional insn in the table directly;
	 no need to build a copy.  */
      hash_insert (arm_ops_hsh, insn->template, (PTR) insn);
    }
}
d6412 2
a6413 1
#if defined OBJ_ELF || defined OBJ_COFF
d6415 1
a6415 11
#ifdef OBJ_ELF
#define arm_Note Elf_External_Note
#else
typedef struct
{
  unsigned char	namesz[4];	/* Size of entry's owner string.  */
  unsigned char	descsz[4];	/* Size of the note descriptor.  */
  unsigned char	type[4];	/* Interpretation of the descriptor.  */
  char		name[1];	/* Start of the name+desc data.  */
} arm_Note;
#endif
d6417 3
a6419 3
/* The description is kept to a fix sized in order to make updating
   it and merging it easier.  */
#define ARM_NOTE_DESCRIPTION_LENGTH	8
d6422 3
a6424 4
arm_add_note (name, description, type)
     const char * name;
     const char * description;
     unsigned int type;
d6426 4
a6429 3
  arm_Note     note ATTRIBUTE_UNUSED;
  char *       p;
  unsigned int name_len;
d6431 2
a6432 4
  name_len = (strlen (name) + 1 + 3) & ~3;
  
  p = frag_more (sizeof (note.namesz));
  md_number_to_chars (p, (valueT) name_len, sizeof (note.namesz));
d6434 2
a6435 2
  p = frag_more (sizeof (note.descsz));
  md_number_to_chars (p, (valueT) ARM_NOTE_DESCRIPTION_LENGTH, sizeof (note.descsz));
d6437 4
a6440 2
  p = frag_more (sizeof (note.type));
  md_number_to_chars (p, (valueT) type, sizeof (note.type));
d6442 3
a6444 6
  p = frag_more (name_len);
  strcpy (p, name);

  p = frag_more (ARM_NOTE_DESCRIPTION_LENGTH);
  strncpy (p, description, ARM_NOTE_DESCRIPTION_LENGTH);
  frag_align (2, 0, 0);
a6445 1
#endif
d6457 1
d6459 1
a6459 1
    as_fatal (_("virtual memory exhausted"));
d6461 2
a6462 1
  build_arm_ops_hsh ();
d6472 2
a6473 2
  for (i = (int) REG_TYPE_FIRST; i < (int) REG_TYPE_MAX; i++)
    build_reg_hsh (all_reg_maps + i);
a6476 44
  /* Set the cpu variant based on the command-line options.  We prefer
     -mcpu= over -march= if both are set (as for GCC); and we prefer
     -mfpu= over any other way of setting the floating point unit.
     Use of legacy options with new options are faulted.  */
  if (legacy_cpu != -1)
    {
      if (mcpu_cpu_opt != -1 || march_cpu_opt != -1)
	as_bad (_("use of old and new-style options to set CPU type"));

      mcpu_cpu_opt = legacy_cpu;
    }
  else if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = march_cpu_opt;

  if (legacy_fpu != -1)
    {
      if (mfpu_opt != -1)
	as_bad (_("use of old and new-style options to set FPU type"));

      mfpu_opt = legacy_fpu;
    }
  else if (mfpu_opt == -1)
    {
      if (mcpu_fpu_opt != -1)
	mfpu_opt = mcpu_fpu_opt;
      else
	mfpu_opt = march_fpu_opt;
    }

  if (mfpu_opt == -1)
    {
      if (mcpu_cpu_opt == -1)
	mfpu_opt = FPU_DEFAULT;
      else if (mcpu_cpu_opt & ARM_EXT_V5)
	mfpu_opt = FPU_ARCH_VFP_V2;
      else
	mfpu_opt = FPU_ARCH_FPA;
    }

  if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = CPU_DEFAULT;

  cpu_variant = mcpu_cpu_opt | mfpu_opt;

d6486 1
a6486 13
    if ((cpu_variant & FPU_ANY) == FPU_NONE
	|| (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
      flags |= F_SOFT_FLOAT;
    /* Using VFP conventions (even if soft-float).  */
    if (cpu_variant & FPU_VFP_EXT_NONE) flags |= F_VFP_FLOAT;

#if defined OBJ_ELF
    if (cpu_variant & ARM_CEXT_MAVERICK)
      {
	flags ^= F_SOFT_FLOAT;
	flags |= EF_ARM_MAVERICK_FLOAT;
      }
#endif
d6521 3
a6523 2
    case ARM_6:			/* Also ARM_7.  */
      mach = bfd_mach_arm_3;
d6526 2
a6527 2
    default:
      mach = bfd_mach_arm_unknown;
d6532 1
a6532 3
  if (cpu_variant & ARM_CEXT_IWMMXT)
    mach = bfd_mach_arm_iWMMXt;
  else if (cpu_variant & ARM_CEXT_XSCALE)
a6533 2
  else if (cpu_variant & ARM_CEXT_MAVERICK)
    mach = bfd_mach_arm_ep9312;
d6538 1
a6538 1
      if (cpu_variant & ARM_EXT_V4T)
d6543 1
a6543 1
  else if (cpu_variant & ARM_EXT_V4)
d6545 1
a6545 1
      if (cpu_variant & ARM_EXT_V4T)
d6550 1
a6550 1
  else if (cpu_variant & ARM_EXT_V3M)
a6552 53
#if 0 /* Suppressed - for now.  */
#if defined (OBJ_ELF) || defined (OBJ_COFF)

  /* Create a .note section to fully identify this arm binary.  */

#define NOTE_ARCH_STRING 	"arch: "

#if defined OBJ_COFF && ! defined NT_VERSION
#define NT_VERSION  1
#define NT_ARCH     2
#endif
  
  {
    segT current_seg = now_seg;
    subsegT current_subseg = now_subseg;
    asection * arm_arch;
    const char * arch_string;

    arm_arch = bfd_make_section_old_way (stdoutput, ARM_NOTE_SECTION);

#ifdef OBJ_COFF
    bfd_set_section_flags (stdoutput, arm_arch,
			   SEC_DATA | SEC_ALLOC | SEC_LOAD | SEC_LINK_ONCE \
			   | SEC_HAS_CONTENTS);
#endif
    arm_arch->output_section = arm_arch;
    subseg_set (arm_arch, 0);

    switch (mach)
      {
      default:
      case bfd_mach_arm_unknown: arch_string = "unknown"; break;
      case bfd_mach_arm_2:       arch_string = "armv2"; break;
      case bfd_mach_arm_2a:      arch_string = "armv2a"; break;
      case bfd_mach_arm_3:       arch_string = "armv3"; break;
      case bfd_mach_arm_3M:      arch_string = "armv3M"; break;
      case bfd_mach_arm_4:       arch_string = "armv4"; break;
      case bfd_mach_arm_4T:      arch_string = "armv4t"; break;
      case bfd_mach_arm_5:       arch_string = "armv5"; break;
      case bfd_mach_arm_5T:      arch_string = "armv5t"; break;
      case bfd_mach_arm_5TE:     arch_string = "armv5te"; break;
      case bfd_mach_arm_XScale:  arch_string = "XScale"; break;
      case bfd_mach_arm_ep9312:  arch_string = "ep9312"; break;
      case bfd_mach_arm_iWMMXt:  arch_string = "iWMMXt"; break;	
      }

    arm_add_note (NOTE_ARCH_STRING, arch_string, NT_ARCH);

    subseg_set (current_seg, current_subseg);
  }
#endif
#endif /* Suppressed code.  */
  
d6656 1
a6656 1
      return _("bad call to MD_ATOF()");
d6674 8
a6681 15
      if (cpu_variant & FPU_ARCH_VFP)
	for (i = prec - 1; i >= 0; i--)
	  {
	    md_number_to_chars (litP, (valueT) words[i], 2);
	    litP += 2;
	  }
      else
	/* For a 4 byte float the order of elements in `words' is 1 0.
	   For an 8 byte float the order is 1 0 3 2.  */
	for (i = 0; i < prec; i += 2)
	  {
	    md_number_to_chars (litP, (valueT) words[i + 1], 2);
	    md_number_to_chars (litP + 2, (valueT) words[i], 2);
	    litP += 4;
	  }
d6762 1
a6762 1
arm_reg_parse (ccp, htab)
a6763 1
     struct hash_control *htab;
d6781 1
a6781 1
  if (!ISALPHA (*p) || !is_name_beginner (*p))
d6785 1
a6785 1
  while (ISALPHA (c) || ISDIGIT (c) || c == '_')
d6789 1
a6789 1
  reg = (struct reg_entry *) hash_find (htab, start);
d6801 2
a6802 18
/* Search for the following register name in each of the possible reg name
   tables.  Return the classification if found, or REG_TYPE_MAX if not
   present.  */
static enum arm_reg_type
arm_reg_parse_any (cp)
     char *cp;
{
  int i;

  for (i = (int) REG_TYPE_FIRST; i < (int) REG_TYPE_MAX; i++)
    if (arm_reg_parse (&cp, all_reg_maps[i].htab) != FAIL)
      return (enum arm_reg_type) i;

  return REG_TYPE_MAX;
}

void
md_apply_fix3 (fixP, valP, seg)
d6804 1
a6804 1
     valueT * valP;
d6807 1
a6807 1
  offsetT        value = * valP;
a6868 1
      fixP->fx_done = 1;
a6874 1

d6898 2
a6899 2
			      _("unable to compute ADRL instructions for PC offset of 0x%lx"),
			      (long) value);
d7008 1
a7008 1
			  _("invalid swi expression"));
d7017 1
a7017 1
			  _("invalid swi expression"));
d7027 1
a7027 1
		      _("invalid expression in load/store multiple"));
d7067 1
a7067 1
	      value = * valP;
d7080 1
a7080 1
			  _("GAS can't handle same-section branch dest >= 0x04000000"));
d7122 1
a7122 1
			_("branch out of range"));
d7138 1
a7138 1
			_("branch out of range"));
a7158 1

d7161 1
a7161 1
			_("branch with link out of range"));
d7166 8
a7173 5
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  newval2 = (newval2 + 1) & ~ 1;
d7229 4
d7237 1
a7237 1
		      _("illegal value for co-processor offset"));
a7244 12
    case BFD_RELOC_ARM_CP_OFF_IMM_S2:
      sign = value >= 0;
      if (value < -255 || value > 255)
        as_bad_where (fixP->fx_file, fixP->fx_line,
                      _("Illegal value for co-processor offset"));
      if (value < 0)
        value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= value | (sign ?  INDEX_UP : 0);
      md_number_to_chars (buf, newval , INSN_SIZE);
      break;

d7261 1
a7261 1
			  _("invalid offset, target not word aligned (0x%08X)"),
d7267 1
a7267 2
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
d7276 1
a7276 2
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
d7283 1
a7283 2
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
d7290 1
a7290 2
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
d7297 1
a7297 2
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
d7336 1
a7336 1
			    _("invalid immediate for stack address calculation"));
d7345 1
a7345 1
			    _("invalid immediate for address calculation (value = 0x%08lX)"),
d7355 1
a7355 1
			    _("invalid 8bit immediate"));
d7363 1
a7363 1
			    _("invalid 3bit immediate"));
d7379 1
a7379 1
			  _("invalid immediate: %ld is too large"),
d7394 1
a7394 1
		      _("illegal Thumb shift value: %ld"), (long) value);
d7403 1
a7403 1
      return;
d7408 1
a7408 1
		    _("bad relocation fixup type (%d)"), fixP->fx_r_type);
d7410 2
d7478 2
a7479 2
      /* If this is called then the a literal has
	 been referenced across a section boundary.  */
d7481 1
a7481 1
		    _("literal referenced across section boundary"));
d7494 2
a7495 1
		    _("internal relocation (type: IMMEDIATE) not fixed up"));
d7505 2
a7506 1
		    _("internal_relocation (type: OFFSET_IMM) not fixed up"));
d7515 2
d7529 1
a7529 1
		      _("cannot represent %s relocation in this object file format"),
d7536 1
a7536 1
  if ((code == BFD_RELOC_32_PCREL || code == BFD_RELOC_32)
d7550 1
a7550 1
		    _("cannot represent %s relocation in this object file format"),
d7573 1
a7573 2
output_inst (str)
     const char *str;
d7579 1
a7579 1
      as_bad ("%s -- `%s'", inst.error, str);
d7614 4
a7617 3
  char  c;
  char *p;
  char *start;
d7624 1
d7647 1
a7647 1
      as_bad (_("no operator -- statement `%s'\n"), str);
d7653 1
a7653 1
      const struct thumb_opcode * opcode;
d7657 1
a7657 1
      opcode = (const struct thumb_opcode *) hash_find (arm_tops_hsh, str);
d7663 1
a7663 1
	  if (thumb_mode == 1 && (opcode->variant & cpu_variant) == 0)
d7665 1
a7665 1
	      as_bad (_("selected processor does not support `%s'"), str);
d7672 1
a7672 1
	  output_inst (str);
d7678 2
a7679 1
      const struct asm_opcode * opcode;
d7681 6
a7686 4
      c = *p;
      *p = '\0';
      opcode = (const struct asm_opcode *) hash_find (arm_ops_hsh, str);
      *p = c;
d7688 1
a7688 1
      if (opcode)
d7690 2
a7691 6
	  /* Check that this instruction is supported for this CPU.  */
	  if ((opcode->variant & cpu_variant) == 0)
	    {
	      as_bad (_("selected processor does not support `%s'"), str);
	      return;
	    }
d7693 2
a7694 7
	  inst.instruction = opcode->value;
	  inst.size = INSN_SIZE;
	  (*opcode->parms) (p);
	  output_inst (str);
	  return;
	}
    }
d7696 4
a7699 4
  /* It wasn't an instruction, but it might be a register alias of the form
     alias .req reg.  */
  if (create_register_alias (str, p))
    return;
d7701 3
a7703 2
  as_bad (_("bad instruction `%s'"), start);
}
d7705 21
a7725 3
/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.
d7727 7
a7733 25
      This routine is somewhat complicated by the need for backwards
      compatibility (since older releases of gcc can't be changed).
      The new options try to make the interface as compatible as
      possible with GCC.

      New options (supported) are:

	      -mcpu=<cpu name>		 Assemble for selected processor
	      -march=<architecture name> Assemble for selected architecture
	      -mfpu=<fpu architecture>	 Assemble for selected FPU.
	      -EB/-mbig-endian		 Big-endian
	      -EL/-mlittle-endian	 Little-endian
	      -k			 Generate PIC code
	      -mthumb			 Start in Thumb mode
	      -mthumb-interwork		 Code supports ARM/Thumb interworking

      For now we will also provide support for:

	      -mapcs-32			 32-bit Program counter
	      -mapcs-26			 26-bit Program counter
	      -macps-float		 Floats passed in FP registers
	      -mapcs-reentrant		 Reentrant code
	      -matpcs
      (sometime these will probably be replaced with -mapcs=<list of options>
      and -matpcs=<list of options>)
d7735 8
a7742 19
      The remaining options are only supported for back-wards compatibility.
      Cpu variants, the arm part is optional:
              -m[arm]1                Currently not supported.
              -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
              -m[arm]3                Arm 3 processor
              -m[arm]6[xx],           Arm 6 processors
              -m[arm]7[xx][t][[d]m]   Arm 7 processors
              -m[arm]8[10]            Arm 8 processors
              -m[arm]9[20][tdmi]      Arm 9 processors
              -mstrongarm[110[0]]     StrongARM processors
              -mxscale                XScale processors
              -m[arm]v[2345[t[e]]]    Arm architectures
              -mall                   All (except the ARM1)
      FP variants:
              -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions
              -mfpe-old               (No float load/store multiples)
	      -mvfpxd		      VFP Single precision
	      -mvfp		      All VFP
              -mno-fpu                Disable all floating point instructions
d7744 8
a7751 8
      The following CPU names are recognized:
	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620,
	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700,
	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c,
	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9,
	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e,
	      arm10t arm10e, arm1020t, arm1020e, arm10200e,
	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.
d7753 13
a7765 1
      */
d7767 5
a7771 1
const char * md_shortopts = "m:k";
d7773 7
a7779 10
#ifdef ARM_BI_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#define OPTION_EL (OPTION_MD_BASE + 1)
#else
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#else
#define OPTION_EL (OPTION_MD_BASE + 1)
#endif
#endif
d7781 6
a7786 10
struct option md_longopts[] =
{
#ifdef OPTION_EB
  {"EB", no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL", no_argument, NULL, OPTION_EL},
#endif
  {NULL, no_argument, NULL, 0}
};
d7788 2
a7789 1
size_t md_longopts_size = sizeof (md_longopts);
d7791 6
a7796 8
struct arm_option_table
{
  char *option;		/* Option name to match.  */
  char *help;		/* Help information.  */
  int  *var;		/* Variable to change.  */
  int   value;		/* What to change it to.  */
  char *deprecated;	/* If non-null, print this message.  */
};
d7798 3
a7800 128
struct arm_option_table arm_opts[] =
{
  {"k",      N_("generate PIC code"),      &pic_code,    1, NULL},
  {"mthumb", N_("assemble Thumb code"),    &thumb_mode,  1, NULL},
  {"mthumb-interwork", N_("support ARM/Thumb interworking"),
   &support_interwork, 1, NULL},
  {"moabi",  N_("use old ABI (ELF only)"), &target_oabi, 1, NULL},
  {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
  {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
  {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
   1, NULL},
  {"mapcs-reentrant", N_("re-entrant code"), &pic_code, 1, NULL},
  {"matpcs", N_("code is ATPCS conformant"), &atpcs, 1, NULL},
  {"mbig-endian", N_("assemble for big-endian"), &target_big_endian, 1, NULL},
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 1,
   NULL},

  /* These are recognized by the assembler, but have no affect on code.  */
  {"mapcs-frame", N_("use frame pointer"), NULL, 0, NULL},
  {"mapcs-stack-check", N_("use stack size checking"), NULL, 0, NULL},

  /* DON'T add any new processors to this list -- we want the whole list
     to go away...  Add them to the processors table instead.  */
  {"marm1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"m1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"marm2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"m2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"marm250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"m250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"marm3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"m3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"marm6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"m6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"marm600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"m600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"marm610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"m610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"marm620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"m620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"marm7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"m7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"marm70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"m70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"marm700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"m700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"marm700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"m700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"marm710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"m710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"marm710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"m710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"marm720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"m720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"marm7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"m7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"marm7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"m7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"marm7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"m7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"marm7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"m7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"marm7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"m7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"marm7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"m7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"marm7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"m7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"marm7500fe", NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"m7500fe",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"marm7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"m710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"marm720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"m720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"marm740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"m740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"marm8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"m8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"marm810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"m810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"marm9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"m9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"marm9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"m9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"marm920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"m920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"marm940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"m940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"mstrongarm", NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
  {"mstrongarm110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm110")},
  {"mstrongarm1100", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1100")},
  {"mstrongarm1110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1110")},
  {"mxscale",	 NULL, &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
  {"miwmmxt",	 NULL, &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
  {"mall",	 NULL, &legacy_cpu, ARM_ANY,      N_("use -mcpu=all")},

  /* Architecture variants -- don't add any more to this list either.  */
  {"mv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"marmv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"mv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"marmv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"mv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"marmv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"mv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"marmv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"mv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"marmv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"mv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"marmv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"mv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"marmv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"mv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"marmv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"mv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
  {"marmv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},

  /* Floating point variants -- don't add any more to this list either.  */
  {"mfpe-old", NULL, &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
  {"mfpa10",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
  {"mfpa11",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
  {"mno-fpu",  NULL, &legacy_fpu, 0,
   N_("use either -mfpu=softfpa or -mfpu=softvfp")},
d7802 2
a7803 2
  {NULL, NULL, NULL, 0, NULL}
};
d7805 16
a7820 8
struct arm_cpu_option_table
{
  char *name;
  int   value;
  /* For some CPUs we assume an FPU unless the user explicitly sets
     -mfpu=...  */
  int   default_fpu;
};
d7822 4
a7825 166
/* This list should, at a minimum, contain all the cpu names
   recognized by GCC.  */
static struct arm_cpu_option_table arm_cpus[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"arm250",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm600",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm610",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm620",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dm",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7di",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dmi",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700i",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm720",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm720t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm740t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm710c",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7100",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500fe",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm810",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm922t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm940t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm9tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  /* For V5 or later processors we default to using VFP; but the user
     should really set the FPU type explicitly.  */
  {"arm9e-r0",		ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm9e",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2},
  {"arm926ej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm946e",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2},
  {"arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm966e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm10t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm10e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm1020e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  /* ??? XSCALE is really an architecture.  */
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* ??? iwmmxt is not a processor.  */
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2},
  {"i80200",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* Maverick */
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_NONE},
  {NULL, 0, 0}
};

struct arm_arch_option_table
{
  char *name;
  int   value;
  int   default_fpu;
};

/* This list should, at a minimum, contain all the architecture names
   recognized by GCC.  */
static struct arm_arch_option_table arm_archs[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"armv1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"armv2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"armv2a",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv2s",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv3",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"armv3m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"armv4",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"armv4xm",		ARM_ARCH_V4xM,	 FPU_ARCH_FPA},
  {"armv4t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"armv4txm",		ARM_ARCH_V4TxM,	 FPU_ARCH_FPA},
  {"armv5",		ARM_ARCH_V5,	 FPU_ARCH_VFP},
  {"armv5t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP},
  {"armv5txm",		ARM_ARCH_V5TxM,	 FPU_ARCH_VFP},
  {"armv5te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP},
  {"armv5texp",		ARM_ARCH_V5TExP, FPU_ARCH_VFP},
  {"armv5tej",		ARM_ARCH_V5TEJ,  FPU_ARCH_VFP},
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP},
  {NULL, 0, 0}
};

/* ISA extensions in the co-processor space.  */
struct arm_arch_extension_table
{
  char *name;
  int value;
};

static struct arm_arch_extension_table arm_extensions[] =
{
  {"maverick",		ARM_CEXT_MAVERICK},
  {"xscale",		ARM_CEXT_XSCALE},
  {"iwmmxt",		ARM_CEXT_IWMMXT},
  {NULL,		0}
};

struct arm_fpu_option_table
{
  char *name;
  int   value;
};

/* This list should, at a minimum, contain all the fpu names
   recognized by GCC.  */
static struct arm_fpu_option_table arm_fpus[] =
{
  {"softfpa",		FPU_NONE},
  {"fpe",		FPU_ARCH_FPE},
  {"fpe2",		FPU_ARCH_FPE},
  {"fpe3",		FPU_ARCH_FPA},	/* Third release supports LFM/SFM.  */
  {"fpa",		FPU_ARCH_FPA},
  {"fpa10",		FPU_ARCH_FPA},
  {"fpa11",		FPU_ARCH_FPA},
  {"arm7500fe",		FPU_ARCH_FPA},
  {"softvfp",		FPU_ARCH_VFP},
  {"softvfp+vfp",	FPU_ARCH_VFP_V2},
  {"vfp",		FPU_ARCH_VFP_V2},
  {"vfp9",		FPU_ARCH_VFP_V2},
  {"vfp10",		FPU_ARCH_VFP_V2},
  {"vfp10-r0",		FPU_ARCH_VFP_V1},
  {"vfpxd",		FPU_ARCH_VFP_V1xD},
  {"arm1020t",		FPU_ARCH_VFP_V1},
  {"arm1020e",		FPU_ARCH_VFP_V2},
  {NULL, 0}
};

struct arm_long_option_table
{
  char *option;		/* Substring to match.  */
  char *help;		/* Help information.  */
  int (*func) PARAMS ((char *subopt));	/* Function to decode sub-option.  */
  char *deprecated;	/* If non-null, print this message.  */
};

static int
arm_parse_extension (str, opt_p)
     char *str;
     int *opt_p;
{
  while (str != NULL && *str != 0)
    {
      struct arm_arch_extension_table *opt;
      char *ext;
      int optlen;
d7827 2
a7828 4
      if (*str != '+')
	{
	  as_bad (_("invalid architectural extension"));
	  return 0;
d7830 1
d7832 4
a7835 2
      str++;
      ext = strchr (str, '+');
d7837 2
a7838 42
      if (ext != NULL)
	optlen = ext - str;
      else
	optlen = strlen (str);

      if (optlen == 0)
	{
	  as_bad (_("missing architectural extension"));
	  return 0;
	}

      for (opt = arm_extensions; opt->name != NULL; opt++)
	if (strncmp (opt->name, str, optlen) == 0)
	  {
	    *opt_p |= opt->value;
	    break;
	  }

      if (opt->name == NULL)
	{
	  as_bad (_("unknown architectural extnsion `%s'"), str);
	  return 0;
	}

      str = ext;
    };

  return 1;
}

static int
arm_parse_cpu (str)
     char *str;
{
  struct arm_cpu_option_table *opt;
  char *ext = strchr (str, '+');
  int optlen;

  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);
d7840 1
a7840 1
  if (optlen == 0)
d7842 3
a7844 3
      as_bad (_("missing cpu name `%s'"), str);
      return 0;
    }
d7846 4
a7849 5
  for (opt = arm_cpus; opt->name != NULL; opt++)
    if (strncmp (opt->name, str, optlen) == 0)
      {
	mcpu_cpu_opt = opt->value;
	mcpu_fpu_opt = opt->default_fpu;
d7851 2
a7852 2
	if (ext != NULL)
	  return arm_parse_extension (ext, &mcpu_cpu_opt);
d7854 3
a7856 2
	return 1;
      }
d7858 4
a7861 3
  as_bad (_("unknown cpu `%s'"), str);
  return 0;
}
d7863 3
a7865 7
static int
arm_parse_arch (str)
     char *str;
{
  struct arm_arch_option_table *opt;
  char *ext = strchr (str, '+');
  int optlen;
d7867 1
a7867 4
  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);
d7869 12
a7880 5
  if (optlen == 0)
    {
      as_bad (_("missing architecture name `%s'"), str);
      return 0;
    }
d7882 8
d7891 3
a7893 5
  for (opt = arm_archs; opt->name != NULL; opt++)
    if (strcmp (opt->name, str) == 0)
      {
	march_cpu_opt = opt->value;
	march_fpu_opt = opt->default_fpu;
d7895 2
a7896 8
	if (ext != NULL)
	  return arm_parse_extension (ext, &march_cpu_opt);

	return 1;
      }

  as_bad (_("unknown architecture `%s'\n"), str);
  return 0;
d7899 30
a7928 5
static int
arm_parse_fpu (str)
     char *str;
{
  struct arm_fpu_option_table *opt;
d7930 1
a7930 6
  for (opt = arm_fpus; opt->name != NULL; opt++)
    if (strcmp (opt->name, str) == 0)
      {
	mfpu_opt = opt->value;
	return 1;
      }
d7932 1
a7932 5
  as_bad (_("unknown floating point format `%s'\n"), str);
  return 0;
}

struct arm_long_option_table arm_long_opts[] =
d7934 11
a7944 7
  {"mcpu=", N_("<cpu name>\t  assemble for CPU <cpu name>"),
   arm_parse_cpu, NULL},
  {"march=", N_("<arch name>\t  assemble for architecture <arch name>"),
   arm_parse_arch, NULL},
  {"mfpu=", N_("<fpu name>\t  assemble for FPU architecture <fpu name>"),
   arm_parse_fpu, NULL},
  {NULL, NULL, 0, NULL}
d7947 2
d7954 1
a7954 2
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;
d7958 1
a7958 1
#ifdef OPTION_EB
a7961 3
#endif

#ifdef OPTION_EL
d7967 25
a7991 4
    case 'a':
      /* Listing option.  Just ignore these, we don't support additional
	 ones.  */
      return 0;
d7993 9
a8001 6
    default:
      for (opt = arm_opts; opt->option != NULL; opt++)
	{
	  if (c == opt->option[0]
	      && ((arg == NULL && opt->option[1] == 0)
		  || strcmp (arg, opt->option + 1) == 0))
d8003 4
a8006 5
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (opt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
			   arg ? arg : "", _(opt->deprecated));
d8008 50
d8059 11
a8069 2
	      if (opt->var != NULL)
		*opt->var = opt->value;
d8071 2
a8072 1
	      return 1;
a8073 1
	}
d8075 1
a8075 7
      for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
	{
	  /* These options are expected to have an argument.  */
	  if (c == lopt->option[0]
	      && arg != NULL
	      && strncmp (arg, lopt->option + 1,
			  strlen (lopt->option + 1)) == 0)
d8077 3
a8079 5
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (lopt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c, arg,
			   _(lopt->deprecated));
d8081 190
d8272 10
a8281 2
	      /* Call the sup-option parser.  */
	      return (*lopt->func)(arg + strlen (lopt->option) - 1);
d8284 7
d8292 1
a8292 1
      as_bad (_("unrecognized option `-%c%s'"), c, arg ? arg : "");
a8302 14
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  fprintf (fp, _(" ARM-specific assembler options:\n"));

  for (opt = arm_opts; opt->option != NULL; opt++)
    if (opt->help != NULL)
      fprintf (fp, "  -%-23s%s\n", opt->option, _(opt->help));

  for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
    if (lopt->help != NULL)
      fprintf (fp, "  -%s%s\n", lopt->option, _(lopt->help));

#ifdef OPTION_EB
d8304 20
a8323 1
  -EB                     assemble code for a big-endian cpu\n"));
d8325 1
a8325 2

#ifdef OPTION_EL
d8327 2
a8328 1
  -EL                     assemble code for a little-endian cpu\n"));
d8416 2
a8417 1
  literal_pool * pool;
d8419 4
a8422 6
  for (pool = list_of_pools; pool; pool = pool->next)
    {
      /* Put it at the end of the relevent section.  */
      subseg_set (pool->section, pool->sub_section);
      s_ltorg (0);
    }
d8454 1
a8454 1

d8464 1
a8464 1

d8483 1
a8483 1
      label_is_thumb_function_name = FALSE;
d8513 1
a8513 1
	  else switch (S_GET_STORAGE_CLASS (sym))
d8587 1
a8587 2
#if defined OBJ_COFF || defined OBJ_ELF
void
d8601 1
a8602 24
}
#endif

int
arm_force_relocation (fixp)
     struct fix * fixp;
{
#if defined (OBJ_COFF) && defined (TE_PE)
  if (fixp->fx_r_type == BFD_RELOC_RVA)
    return 1;
#endif
#ifdef OBJ_ELF
  if (fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;
#endif

  /* Resolve these relocations even if the symbol is extern or weak.  */
  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 0;
d8604 1
a8604 1
  return generic_force_reloc (fixp);
d8614 1
a8614 1
bfd_boolean
a8622 1

d8637 1
a8637 1
bfd_boolean
d8644 7
a8659 6
  /* Don't allow symbols to be discarded on GOT related relocs.  */
  if (fixP->fx_r_type == BFD_RELOC_ARM_PLT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF)
    return 0;

d8690 15
d8730 1
a8730 1
       i < sizeof (id) && (ISALNUM (*ip) || ISPUNCT (*ip));
d8732 1
a8732 1
    id[i] = TOLOWER (*ip);
d8815 1
a8815 1

d8822 1
a8822 1

d8825 1
a8825 1

d8842 1
a8842 1

d8858 1
a8858 1

d8877 1
a8877 1

@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a6 2
	Cirrus coprocessor fixes by Petko Manolov (petkan@@nucleusys.com)
	Cirrus coprocessor fixes by Vladimir Ivanov (vladitx@@nucleusys.com)
a57 1
#define ARM_EXT_V6       0x00001000     /* ARM V6.                 */
a84 1
#define ARM_ARCH_V6     (ARM_ARCH_V5TEJ | ARM_EXT_V6)
a102 1
#define FPU_MAVERICK	 0x02000000	/* Cirrus Maverick.	      */
a112 9
#define FPU_ARCH_MAVERICK  FPU_MAVERICK

enum arm_float_abi
{
  ARM_FLOAT_ABI_HARD,
  ARM_FLOAT_ABI_SOFTFP,
  ARM_FLOAT_ABI_SOFT
};

a136 13
#ifdef TE_LINUX
#define FPU_DEFAULT FPU_ARCH_FPA
#endif

#ifdef TE_NetBSD
#ifdef OBJ_ELF
#define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, but VFP order.  */
#else
/* Legacy a.out format.  */
#define FPU_DEFAULT FPU_ARCH_FPA	/* Soft-float, but FPA order.  */
#endif
#endif

a165 1
static int mfloat_abi_opt = -1;
a277 1
/* Any kind of shift is accepted.  */
d279 1
a279 8
/* The shift operand must be an immediate value, not a register.  */
#define SHIFT_IMMEDIATE	  0
/* The shift must be LSL or ASR and the operand must be an immediate.  */
#define SHIFT_LSL_OR_ASR_IMMEDIATE 2
/* The shift must be ASR and the operand must be an immediate.  */
#define SHIFT_ASR_IMMEDIATE 3
/* The shift must be LSL and the operand must be an immediate.  */
#define SHIFT_LSL_IMMEDIATE 4
d352 1
a352 1
/* The bit that distinguishes CPSR and SPSR.  */
a569 1
  bfd_boolean  builtin;
d581 1
a581 3
/* These are the standard names.  Users can add aliases with .req.
   and delete them with .unreq.  */

d585 4
a588 4
  {"r0",  0, TRUE},  {"r1",  1, TRUE},      {"r2",  2, TRUE},      {"r3",  3, TRUE},
  {"r4",  4, TRUE},  {"r5",  5, TRUE},      {"r6",  6, TRUE},      {"r7",  7, TRUE},
  {"r8",  8, TRUE},  {"r9",  9, TRUE},      {"r10", 10, TRUE},     {"r11", 11, TRUE},
  {"r12", 12, TRUE}, {"r13", REG_SP, TRUE}, {"r14", REG_LR, TRUE}, {"r15", REG_PC, TRUE},
d590 3
a592 3
  {"a1",  0, TRUE},  {"a2",  1, TRUE},      {"a3",  2, TRUE},      {"a4",  3, TRUE},
  {"v1",  4, TRUE},  {"v2",  5, TRUE},      {"v3",  6, TRUE},      {"v4",  7, TRUE},
  {"v5",  8, TRUE},  {"v6",  9, TRUE},      {"v7",  10, TRUE},     {"v8",  11, TRUE},
d594 4
a597 3
  {"wr",  7, TRUE},  {"sb",  9, TRUE},      {"sl",  10, TRUE},     {"fp",  11, TRUE},
  {"ip",  12, TRUE}, {"sp",  REG_SP, TRUE}, {"lr",  REG_LR, TRUE}, {"pc",  REG_PC, TRUE},
  {NULL, 0, TRUE}
d606 26
a631 26
  {  "wr0", 0x0 | WR_PREFIX, TRUE},   {"wr1", 0x1 | WR_PREFIX, TRUE},
  {  "wr2", 0x2 | WR_PREFIX, TRUE},   {"wr3", 0x3 | WR_PREFIX, TRUE},
  {  "wr4", 0x4 | WR_PREFIX, TRUE},   {"wr5", 0x5 | WR_PREFIX, TRUE},
  {  "wr6", 0x6 | WR_PREFIX, TRUE},   {"wr7", 0x7 | WR_PREFIX, TRUE},
  {  "wr8", 0x8 | WR_PREFIX, TRUE},   {"wr9", 0x9 | WR_PREFIX, TRUE},
  { "wr10", 0xa | WR_PREFIX, TRUE},  {"wr11", 0xb | WR_PREFIX, TRUE},
  { "wr12", 0xc | WR_PREFIX, TRUE},  {"wr13", 0xd | WR_PREFIX, TRUE},
  { "wr14", 0xe | WR_PREFIX, TRUE},  {"wr15", 0xf | WR_PREFIX, TRUE},
  { "wcid", 0x0 | WC_PREFIX, TRUE},  {"wcon", 0x1 | WC_PREFIX, TRUE},
  {"wcssf", 0x2 | WC_PREFIX, TRUE}, {"wcasf", 0x3 | WC_PREFIX, TRUE},
  {"wcgr0", 0x8 | WC_PREFIX, TRUE}, {"wcgr1", 0x9 | WC_PREFIX, TRUE},
  {"wcgr2", 0xa | WC_PREFIX, TRUE}, {"wcgr3", 0xb | WC_PREFIX, TRUE},

  {  "wR0", 0x0 | WR_PREFIX, TRUE},   {"wR1", 0x1 | WR_PREFIX, TRUE},
  {  "wR2", 0x2 | WR_PREFIX, TRUE},   {"wR3", 0x3 | WR_PREFIX, TRUE},
  {  "wR4", 0x4 | WR_PREFIX, TRUE},   {"wR5", 0x5 | WR_PREFIX, TRUE},
  {  "wR6", 0x6 | WR_PREFIX, TRUE},   {"wR7", 0x7 | WR_PREFIX, TRUE},
  {  "wR8", 0x8 | WR_PREFIX, TRUE},   {"wR9", 0x9 | WR_PREFIX, TRUE},
  { "wR10", 0xa | WR_PREFIX, TRUE},  {"wR11", 0xb | WR_PREFIX, TRUE},
  { "wR12", 0xc | WR_PREFIX, TRUE},  {"wR13", 0xd | WR_PREFIX, TRUE},
  { "wR14", 0xe | WR_PREFIX, TRUE},  {"wR15", 0xf | WR_PREFIX, TRUE},
  { "wCID", 0x0 | WC_PREFIX, TRUE},  {"wCon", 0x1 | WC_PREFIX, TRUE},
  {"wCSSF", 0x2 | WC_PREFIX, TRUE}, {"wCASF", 0x3 | WC_PREFIX, TRUE},
  {"wCGR0", 0x8 | WC_PREFIX, TRUE}, {"wCGR1", 0x9 | WC_PREFIX, TRUE},
  {"wCGR2", 0xa | WC_PREFIX, TRUE}, {"wCGR3", 0xb | WC_PREFIX, TRUE},
  {NULL, 0, TRUE}
d637 5
a641 5
  {"p0",  0, TRUE},  {"p1",  1, TRUE},  {"p2",  2, TRUE},  {"p3", 3, TRUE},
  {"p4",  4, TRUE},  {"p5",  5, TRUE},  {"p6",  6, TRUE},  {"p7", 7, TRUE},
  {"p8",  8, TRUE},  {"p9",  9, TRUE},  {"p10", 10, TRUE}, {"p11", 11, TRUE},
  {"p12", 12, TRUE}, {"p13", 13, TRUE}, {"p14", 14, TRUE}, {"p15", 15, TRUE},
  {NULL, 0, TRUE}
d647 4
a650 4
  {"c0",   0, TRUE},  {"c1",   1, TRUE},  {"c2",   2, TRUE},  {"c3",   3, TRUE},
  {"c4",   4, TRUE},  {"c5",   5, TRUE},  {"c6",   6, TRUE},  {"c7",   7, TRUE},
  {"c8",   8, TRUE},  {"c9",   9, TRUE},  {"c10",  10, TRUE}, {"c11",  11, TRUE},
  {"c12",  12, TRUE}, {"c13",  13, TRUE}, {"c14",  14, TRUE}, {"c15",  15, TRUE},
d652 5
a656 5
  {"cr0",  0, TRUE},  {"cr1",  1, TRUE},  {"cr2",  2, TRUE},  {"cr3",  3, TRUE},
  {"cr4",  4, TRUE},  {"cr5",  5, TRUE},  {"cr6",  6, TRUE},  {"cr7",  7, TRUE},
  {"cr8",  8, TRUE},  {"cr9",  9, TRUE},  {"cr10", 10, TRUE}, {"cr11", 11, TRUE},
  {"cr12", 12, TRUE}, {"cr13", 13, TRUE}, {"cr14", 14, TRUE}, {"cr15", 15, TRUE},
  {NULL, 0, TRUE}
d662 3
a664 3
  {"f0", 0, TRUE},   {"f1", 1, TRUE},   {"f2", 2, TRUE},   {"f3", 3, TRUE},
  {"f4", 4, TRUE},   {"f5", 5, TRUE},   {"f6", 6, TRUE},   {"f7", 7, TRUE},
  {NULL, 0, TRUE}
d670 9
a678 9
  {"s0",  0, TRUE},  {"s1",  1, TRUE},  {"s2",  2, TRUE},  {"s3", 3, TRUE},
  {"s4",  4, TRUE},  {"s5",  5, TRUE},  {"s6",  6, TRUE},  {"s7", 7, TRUE},
  {"s8",  8, TRUE},  {"s9",  9, TRUE},  {"s10", 10, TRUE}, {"s11", 11, TRUE},
  {"s12", 12, TRUE}, {"s13", 13, TRUE}, {"s14", 14, TRUE}, {"s15", 15, TRUE},
  {"s16", 16, TRUE}, {"s17", 17, TRUE}, {"s18", 18, TRUE}, {"s19", 19, TRUE},
  {"s20", 20, TRUE}, {"s21", 21, TRUE}, {"s22", 22, TRUE}, {"s23", 23, TRUE},
  {"s24", 24, TRUE}, {"s25", 25, TRUE}, {"s26", 26, TRUE}, {"s27", 27, TRUE},
  {"s28", 28, TRUE}, {"s29", 29, TRUE}, {"s30", 30, TRUE}, {"s31", 31, TRUE},
  {NULL, 0, TRUE}
d684 5
a688 5
  {"d0",  0, TRUE},  {"d1",  1, TRUE},  {"d2",  2, TRUE},  {"d3", 3, TRUE},
  {"d4",  4, TRUE},  {"d5",  5, TRUE},  {"d6",  6, TRUE},  {"d7", 7, TRUE},
  {"d8",  8, TRUE},  {"d9",  9, TRUE},  {"d10", 10, TRUE}, {"d11", 11, TRUE},
  {"d12", 12, TRUE}, {"d13", 13, TRUE}, {"d14", 14, TRUE}, {"d15", 15, TRUE},
  {NULL, 0, TRUE}
d694 5
a698 5
  {"mvf0",  0, TRUE},  {"mvf1",  1, TRUE},  {"mvf2",  2, TRUE},  {"mvf3",  3, TRUE},
  {"mvf4",  4, TRUE},  {"mvf5",  5, TRUE},  {"mvf6",  6, TRUE},  {"mvf7",  7, TRUE},
  {"mvf8",  8, TRUE},  {"mvf9",  9, TRUE},  {"mvf10", 10, TRUE}, {"mvf11", 11, TRUE},
  {"mvf12", 12, TRUE}, {"mvf13", 13, TRUE}, {"mvf14", 14, TRUE}, {"mvf15", 15, TRUE},
  {NULL, 0, TRUE}
d703 5
a707 5
  {"mvd0",  0, TRUE},  {"mvd1",  1, TRUE},  {"mvd2",  2, TRUE},  {"mvd3",  3, TRUE},
  {"mvd4",  4, TRUE},  {"mvd5",  5, TRUE},  {"mvd6",  6, TRUE},  {"mvd7",  7, TRUE},
  {"mvd8",  8, TRUE},  {"mvd9",  9, TRUE},  {"mvd10", 10, TRUE}, {"mvd11", 11, TRUE},
  {"mvd12", 12, TRUE}, {"mvd13", 13, TRUE}, {"mvd14", 14, TRUE}, {"mvd15", 15, TRUE},
  {NULL, 0, TRUE}
d712 5
a716 5
  {"mvfx0",  0, TRUE},  {"mvfx1",  1, TRUE},  {"mvfx2",  2, TRUE},  {"mvfx3",  3, TRUE},
  {"mvfx4",  4, TRUE},  {"mvfx5",  5, TRUE},  {"mvfx6",  6, TRUE},  {"mvfx7",  7, TRUE},
  {"mvfx8",  8, TRUE},  {"mvfx9",  9, TRUE},  {"mvfx10", 10, TRUE}, {"mvfx11", 11, TRUE},
  {"mvfx12", 12, TRUE}, {"mvfx13", 13, TRUE}, {"mvfx14", 14, TRUE}, {"mvfx15", 15, TRUE},
  {NULL, 0, TRUE}
d721 5
a725 5
  {"mvdx0",  0, TRUE},  {"mvdx1",  1, TRUE},  {"mvdx2",  2, TRUE},  {"mvdx3",  3, TRUE},
  {"mvdx4",  4, TRUE},  {"mvdx5",  5, TRUE},  {"mvdx6",  6, TRUE},  {"mvdx7",  7, TRUE},
  {"mvdx8",  8, TRUE},  {"mvdx9",  9, TRUE},  {"mvdx10", 10, TRUE}, {"mvdx11", 11, TRUE},
  {"mvdx12", 12, TRUE}, {"mvdx13", 13, TRUE}, {"mvdx14", 14, TRUE}, {"mvdx15", 15, TRUE},
  {NULL, 0, TRUE}
d730 2
a731 2
  {"mvax0", 0, TRUE}, {"mvax1", 1, TRUE}, {"mvax2", 2, TRUE}, {"mvax3", 3, TRUE},
  {NULL, 0, TRUE}
d736 2
a737 2
  {"dspsc", 0, TRUE},
  {NULL, 0, TRUE}
d759 1
a759 1
  {mav_mvdx_table,  15, NULL, N_("Maverick MVDX register expected")},
a843 30
/* ARM V6. */
static void do_cps              PARAMS ((char *));
static void do_cpsi             PARAMS ((char *));
static void do_ldrex            PARAMS ((char *));
static void do_pkhbt            PARAMS ((char *));
static void do_pkhtb            PARAMS ((char *));
static void do_qadd16           PARAMS ((char *));
static void do_rev              PARAMS ((char *));
static void do_rfe              PARAMS ((char *));
static void do_sxtah            PARAMS ((char *));
static void do_sxth             PARAMS ((char *));
static void do_setend           PARAMS ((char *));
static void do_smlad            PARAMS ((char *));
static void do_smlald           PARAMS ((char *));
static void do_smmul            PARAMS ((char *));
static void do_ssat             PARAMS ((char *));
static void do_usat             PARAMS ((char *));
static void do_srs              PARAMS ((char *));
static void do_ssat16           PARAMS ((char *));
static void do_usat16           PARAMS ((char *));
static void do_strex            PARAMS ((char *));
static void do_umaal            PARAMS ((char *));

static void do_cps_mode         PARAMS ((char **));
static void do_cps_flags        PARAMS ((char **, int));
static int do_endian_specifier  PARAMS ((char *));
static void do_pkh_core         PARAMS ((char *, int));
static void do_sat              PARAMS ((char **, int));
static void do_sat16            PARAMS ((char **, int));

d866 1
a866 2
static void do_vfp_reg2_from_sp2 PARAMS ((char *));
static void do_vfp_sp2_from_reg2 PARAMS ((char *));
d1047 2
a1048 2
/* "INSN<cond> X,Y" where X:bit12, Y:bit16.  */
#define MAV_MODE3	0x100c
d1168 1
a1168 1
  /* Generic coprocessor instructions.  */
a1260 101
  /*  ARM V6.  */
  { "cps",       0xf1020000, 0,  ARM_EXT_V6,       do_cps},
  { "cpsie",     0xf1080000, 0,  ARM_EXT_V6,       do_cpsi},
  { "cpsid",     0xf10C0000, 0,  ARM_EXT_V6,       do_cpsi},
  { "ldrex",     0xe1900f9f, 5,  ARM_EXT_V6,       do_ldrex},
  { "mcrr2",     0xfc400000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "mrrc2",     0xfc500000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "pkhbt",     0xe6800010, 5,  ARM_EXT_V6,       do_pkhbt},
  { "pkhtb",     0xe6800050, 5,  ARM_EXT_V6,       do_pkhtb},
  { "qadd16",    0xe6200f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "qadd8",     0xe6200f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "qaddsubx",  0xe6200f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "qsub16",    0xe6200f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "qsub8",     0xe6200ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "qsubaddx",  0xe6200f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "sadd16",    0xe6100f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "sadd8",     0xe6100f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "saddsubx",  0xe6100f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "shadd16",   0xe6300f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "shadd8",    0xe6300f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "shaddsubx", 0xe6300f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "shsub16",   0xe6300f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "shsub8",    0xe6300ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "shsubaddx", 0xe6300f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "ssub16",    0xe6100f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "ssub8",     0xe6100ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "ssubaddx",  0xe6100f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "uadd16",    0xe6500f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "uadd8",     0xe6500f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "uaddsubx",  0xe6500f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "uhadd16",   0xe6700f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhadd8",    0xe6700f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhaddsubx", 0xe6700f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uhsub16",   0xe6700f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhsub8",    0xe6700ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhsubaddx", 0xe6700f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqadd16",   0xe6600f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqadd8",    0xe6600f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqaddsubx", 0xe6600f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqsub16",   0xe6600f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqsub8",    0xe6600ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqsubaddx", 0xe6600f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "usub16",    0xe6500f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "usub8",     0xe6500ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "usubaddx",  0xe6500f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "rev",       0xe6bf0f30, 3,  ARM_EXT_V6,       do_rev},
  { "rev16",     0xe6bf0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "revsh",     0xe6ff0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "rfeia",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeib",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeda",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfedb",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefd",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefa",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeea",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeed",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "sxtah",     0xe6b00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxtab16",   0xe6800070, 7,  ARM_EXT_V6,       do_sxtah},
  { "sxtab",     0xe6a00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxth",      0xe6bf0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sxtb16",    0xe68f0070, 6,  ARM_EXT_V6,       do_sxth},
  { "sxtb",      0xe6af0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtah",     0xe6f00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxtab16",   0xe6c00070, 7,  ARM_EXT_V6,       do_sxtah},
  { "uxtab",     0xe6e00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxth",      0xe6ff0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtb16",    0xe6cf0070, 6,  ARM_EXT_V6,       do_sxth},
  { "uxtb",      0xe6ef0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sel",       0xe68000b0, 3,  ARM_EXT_V6,       do_qadd16},
  { "setend",    0xf1010000, 0,  ARM_EXT_V6,       do_setend},
  { "smlad",     0xe7000010, 5,  ARM_EXT_V6,       do_smlad},
  { "smladx",    0xe7000030, 6,  ARM_EXT_V6,       do_smlad},
  { "smlald",    0xe7400010, 6,  ARM_EXT_V6,       do_smlald},
  { "smlaldx",   0xe7400030, 7,  ARM_EXT_V6,       do_smlald},
  { "smlsd",     0xe7000050, 5,  ARM_EXT_V6,       do_smlad},
  { "smlsdx",    0xe7000070, 6,  ARM_EXT_V6,       do_smlad},
  { "smlsld",    0xe7400050, 6,  ARM_EXT_V6,       do_smlald},
  { "smlsldx",   0xe7400070, 7,  ARM_EXT_V6,       do_smlald},
  { "smmla",     0xe7500010, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlar",    0xe7500030, 6,  ARM_EXT_V6,       do_smlad},
  { "smmls",     0xe75000d0, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlsr",    0xe75000f0, 6,  ARM_EXT_V6,       do_smlad},
  { "smmul",     0xe750f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smmulr",    0xe750f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smuad",     0xe700f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smuadx",    0xe700f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smusd",     0xe700f050, 5,  ARM_EXT_V6,       do_smmul},
  { "smusdx",    0xe700f070, 6,  ARM_EXT_V6,       do_smmul},
  { "srsia",     0xf8cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsib",     0xf9cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsda",     0xf84d0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsdb",     0xf94d0500, 0,  ARM_EXT_V6,       do_srs},
  { "ssat",      0xe6a00010, 4,  ARM_EXT_V6,       do_ssat},
  { "ssat16",    0xe6a00f30, 6,  ARM_EXT_V6,       do_ssat16},
  { "strex",     0xe1800f90, 5,  ARM_EXT_V6,       do_strex},
  { "umaal",     0xe0400090, 5,  ARM_EXT_V6,       do_umaal},
  { "usad8",     0xe780f010, 5,  ARM_EXT_V6,       do_smmul},
  { "usada8",    0xe7800010, 6,  ARM_EXT_V6,       do_smlad},
  { "usat",      0xe6e00010, 4,  ARM_EXT_V6,       do_usat},
  { "usat16",    0xe6e00f30, 6,  ARM_EXT_V6,       do_usat16},

d1812 2
a1813 2
  {"fmsrr",   0xec400a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp2_from_reg2},
  {"fmrrs",   0xec500a10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_sp2},
d2010 12
a2021 12
  {"cfmval32",   0xee200440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32al",   0xee100440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvam32",   0xee200460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32am",   0xee100460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvah32",   0xee200480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32ah",   0xee100480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva32",    0xee2004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32a",    0xee1004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva64",    0xee2004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3c},
  {"cfmv64a",    0xee1004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3d},
  {"cfmvsc32",   0xee2004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_1},
  {"cfmv32sc",   0xee1004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_2},
a2133 5
/* ARM V6.  */
static void do_t_cps            PARAMS ((char *));
static void do_t_cpy            PARAMS ((char *));
static void do_t_setend         PARAMS ((char *));;

a2201 1
#define THUMB_CPY 2
a2293 13

  /* ARM V6.  */
  {"cpsie",	0xb660,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpsid",     0xb670,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpy",	0x4600,		2,	ARM_EXT_V6,  do_t_cpy},
  {"rev",	0xba00,		2,	ARM_EXT_V6,  do_t_arit},
  {"rev16",	0xba40,		2,	ARM_EXT_V6,  do_t_arit},
  {"revsh",	0xbac0,		2,	ARM_EXT_V6,  do_t_arit},
  {"setend",	0xb650,		2,	ARM_EXT_V6,  do_t_setend},
  {"sxth",	0xb200,		2,	ARM_EXT_V6,  do_t_arit},
  {"sxtb",	0xb240,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxth",	0xb280,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxtb",	0xb2c0,		2,	ARM_EXT_V6,  do_t_arit},
a2313 1
static void s_unreq PARAMS ((int));
d2332 1
a2332 1
  /* Never called because '.req' does not start a line.  */
a2333 1
  { "unreq",       s_unreq,       0 },
d2348 2
a2363 2
static int arm_parse_float_abi PARAMS ((char *));
#if 0 /* Suppressed - for now.  */
a2366 1
#endif
d2583 1
a2583 1
/* Check to see if an immediate can be computed as two separate immediate
a2631 161

#ifdef OBJ_ELF
/* This code is to handle mapping symbols as defined in the ARM ELF spec.
   (This text is taken from version B-02 of the spec):

      4.4.7 Mapping and tagging symbols

      A section of an ARM ELF file can contain a mixture of ARM code,
      Thumb code, and data.  There are inline transitions between code
      and data at literal pool boundaries. There can also be inline
      transitions between ARM code and Thumb code, for example in
      ARM-Thumb inter-working veneers.  Linkers, machine-level
      debuggers, profiling tools, and disassembly tools need to map
      images accurately. For example, setting an ARM breakpoint on a
      Thumb location, or in a literal pool, can crash the program
      being debugged, ruining the debugging session.

      ARM ELF entities are mapped (see section 4.4.7.1 below) and
      tagged (see section 4.4.7.2 below) using local symbols (with
      binding STB_LOCAL).  To assist consumers, mapping and tagging
      symbols should be collated first in the symbol table, before
      other symbols with binding STB_LOCAL.

      To allow properly collated mapping and tagging symbols to be
      skipped by consumers that have no interest in them, the first
      such symbol should have the name $m and its st_value field equal
      to the total number of mapping and tagging symbols (including
      the $m) in the symbol table.

      4.4.7.1 Mapping symbols

      $a    Labels the first byte of a sequence of ARM instructions.
            Its type is STT_FUNC.

      $d    Labels the first byte of a sequence of data items.
            Its type is STT_OBJECT.

      $t    Labels the first byte of a sequence of Thumb instructions.
            Its type is STT_FUNC.

      This list of mapping symbols may be extended in the future.

      Section-relative mapping symbols

      Mapping symbols defined in a section define a sequence of
      half-open address intervals that cover the address range of the
      section. Each interval starts at the address defined by a
      mapping symbol, and continues up to, but not including, the
      address defined by the next (in address order) mapping symbol or
      the end of the section. A corollary is that there must be a
      mapping symbol defined at the beginning of each section.
      Consumers can ignore the size of a section-relative mapping
      symbol. Producers can set it to 0.

      Absolute mapping symbols

      Because of the need to crystallize a Thumb address with the
      Thumb-bit set, absolute symbol of type STT_FUNC (symbols of type
      STT_FUNC defined in section SHN_ABS) need to be mapped with $a
      or $t.

      The extent of a mapping symbol defined in SHN_ABS is [st_value,
      st_value + st_size), or [st_value, st_value + 1) if st_size = 0,
      where [x, y) denotes the half-open address range from x,
      inclusive, to y, exclusive.

      In the absence of a mapping symbol, a consumer can interpret a
      function symbol with an odd value as the Thumb code address
      obtained by clearing the least significant bit of the
      value. This interpretation is deprecated, and it may not work in
      the future.

   Note - the Tagging symbols ($b, $f, $p $m) have been dropped from
   the EABI (which is still under development), so they are not
   implemented here.  */

static enum mstate mapstate = MAP_UNDEFINED;

static void
mapping_state (enum mstate state)
{
  symbolS * symbolP;
  const char * symname;
  int type;

  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;

  mapstate = state;

  switch (state)
    {
    case MAP_DATA:
      symname = "$d";
      type = BSF_OBJECT;
      break;
    case MAP_ARM:
      symname = "$a";
      type = BSF_FUNCTION;
      break;
    case MAP_THUMB:
      symname = "$t";
      type = BSF_FUNCTION;
      break;
    case MAP_UNDEFINED:
      return;     
    default:
      abort ();
    }

  seg_info (now_seg)->tc_segment_info_data = state;

  symbolP = symbol_new (symname, now_seg, (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (symbolP);
  symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;
  
  switch (state)
    {
    case MAP_ARM:
      THUMB_SET_FUNC (symbolP, 0);
      ARM_SET_THUMB (symbolP, 0);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
      
    case MAP_THUMB:
      THUMB_SET_FUNC (symbolP, 1);
      ARM_SET_THUMB (symbolP, 1);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
      
    case MAP_DATA:
    default:
      return;
    }
}

/* When we change sections we need to issue a new mapping symbol.  */

void
arm_elf_change_section (void)
{
  flagword flags;

  if (!SEG_NORMAL (now_seg))
    return;

  flags = bfd_get_section_flags (stdoutput, now_seg);

  /* We can ignore sections that only contain debug info.  */
  if ((flags & SEC_ALLOC) == 0)
    return;

  mapstate = seg_info (now_seg)->tc_segment_info_data;
}
#else
#define mapping_state(a)
#endif /* OBJ_ELF */


a2638 71
/* The .unreq directive deletes an alias which was previously defined
   by .req.  For example:

       my_alias .req r11
       .unreq my_alias    */

static void
s_unreq (int a ATTRIBUTE_UNUSED)
{
  char *name;
  char saved_char;

  skip_whitespace (input_line_pointer);
  name = input_line_pointer;

  while (*input_line_pointer != 0
	 && *input_line_pointer != ' '
	 && *input_line_pointer != '\n')
    ++input_line_pointer;

  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  if (*name)
    {
      enum arm_reg_type req_type = arm_reg_parse_any (name);

      if (req_type != REG_TYPE_MAX)
	{
	  char *temp_name = name;
	  int req_no = arm_reg_parse (&temp_name, all_reg_maps[req_type].htab);

	  if (req_no != FAIL)
	    {
	      struct reg_entry *req_entry;

	      /* Check to see if this alias is a builtin one.  */
	      req_entry = hash_delete (all_reg_maps[req_type].htab, name);

	      if (!req_entry)
		as_bad (_("unreq: missing hash entry for \"%s\""), name);
	      else if (req_entry->builtin)
		/* FIXME: We are deleting a built in register alias which
		   points to a const data structure, so we only need to
		   free up the memory used by the key in the hash table.
		   Unfortunately we have not recorded this value, so this
		   is a memory leak.  */
		  /* FIXME: Should we issue a warning message ?  */
		;
	      else
		{
		  /* Deleting a user defined alias.  We need to free the
		     key and the value, but fortunately the key is the same
		     as the value->name field.  */
		  free ((char *) req_entry->name);
		  free (req_entry);
		}
	    }
          else
            as_bad (_(".unreq: unrecognized symbol \"%s\""), name);
	}
      else
        as_bad (_(".unreq: unrecognized symbol \"%s\""), name);
    }
  else
    as_bad (_("invalid syntax for .unreq directive"));

  *input_line_pointer = saved_char;
  demand_empty_rest_of_line ();
}

a2646 1
  mapping_state (MAP_DATA);
a2675 2
  mapping_state (MAP_DATA);

a2884 1
      mapping_state (MAP_THUMB);
a2899 1
      mapping_state (MAP_ARM);
d3321 1
a3321 3
	  skip_whitespace (p);

	  if (*p == '\0')
d3323 2
a3324 17
	      /* As an extension to the official ARM syntax we allow:
		 
		   [Rn]
		   
	         as a short hand for:

		   [Rn,#0]  */
	      inst.instruction |= PRE_INDEX | INDEX_UP;
	      *str = p;
	      return SUCCESS;
	    }
	  
	  if (skip_past_comma (& p) == FAIL)
	    {
	      inst.error = _("comma expected after closing square bracket");
	      return FAIL;
	    }
d3326 1
a3326 5
	  skip_whitespace (p);

	  if (*p == '#')
	    {
	      if (wb_ok)
d3328 2
a3329 11
		  /* [Rn], #expr  */
		  write_back = WRITE_BACK;

		  if (reg == REG_PC)
		    {
		      inst.error = _("pc may not be used in post-increment");
		      return FAIL;
		    }

		  if (cp_address_offset (& p) == FAIL)
		    return FAIL;
a3330 11
	      else
		pre_inc = PRE_INDEX | INDEX_UP;
	    }
	  else if (*p == '{')
	    {
	      int option;

	      /* [Rn], {<expr>}  */
	      p++;

	      skip_whitespace (p);
d3332 1
a3332 1
	      if (my_get_expression (& inst.reloc.exp, & p))
a3333 30

	      if (inst.reloc.exp.X_op == O_constant)
		{
		  option = inst.reloc.exp.X_add_number;

		  if (option > 255 || option < 0)
		    {
		      inst.error = _("'option' field too large");
		      return FAIL;
		    }

		  skip_whitespace (p);

		  if (*p != '}')
		    {
		      inst.error = _("'}' expected at end of 'option' field");
		      return FAIL;
		    }
		  else
		    {
		      p++;
		      inst.instruction |= option;
		      inst.instruction |= INDEX_UP;
		    }
		}
	      else
		{
		  inst.error = _("non-constant expressions for 'option' field not supported");
		  return FAIL;
		}
d3336 1
a3336 4
	    {
	      inst.error = _("# or { expected after comma");
	      return FAIL;	      
	    }
d3537 1
d3565 1
a3565 1
	 /* Lower case versions for backwards compatibility.  */
d3570 1
a3570 1
  /* This is for backwards compatibility with older toolchains.  */
d3721 1
d3775 1
d3831 1
d4188 1
a4188 1
     Instruction is not conditional, and has 0xf in the condition field.
d4303 3
a4305 923
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  end_of_line (str);
}

/* ARM v5TEJ.  Jump to Jazelle code.  */
static void
do_bxj (str)
     char * str;
{
  int reg;

  skip_whitespace (str);

  if ((reg = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Note - it is not illegal to do a "bxj pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  end_of_line (str);
}

/* ARM V6 umaal (argument parse). */

static void
do_umaal (str)
     char *str;
{

  int rdlo, rdhi, rm, rs;

  skip_whitespace (str);
  if ((rdlo = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rdhi = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;      
    }

  if (rdlo == REG_PC || rdhi == REG_PC || rm == REG_PC || rs == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
}

/* ARM V6 strex (argument parse). */

static void 
do_strex (str)
     char *str;
{
  int rd, rm, rn;

  /* Parse Rd, Rm,. */
  skip_whitespace (str);
  if ((rd = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  if (rd == rm)
    {
      inst.error = _("Rd equal to Rm or Rn yields unpredictable results");
      return;
    }

  /* Skip past '['. */
  if ((strlen (str) >= 1) 
      && strncmp (str, "[", 1) == 0)
    str+=1;
  skip_whitespace (str);  

  /* Parse Rn. */
  if ((rn = reg_required_here (& str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  if (rd == rn)
    {
      inst.error = _("Rd equal to Rm or Rn yields unpredictable results");
      return;
    }
  skip_whitespace (str);  

  /* Skip past ']'. */
  if ((strlen (str) >= 1) 
      && strncmp (str, "]", 1) == 0)
    str+=1;
  
  end_of_line (str);
}

/* ARM V6 ssat (argument parse). */

static void
do_ssat (str)
     char* str;
{
  do_sat (&str, /*bias=*/-1);
  end_of_line (str);
}

/* ARM V6 usat (argument parse). */

static void
do_usat (str)
     char* str;
{
  do_sat (&str, /*bias=*/0);
  end_of_line (str);
}

static void
do_sat (str, bias)
     char **str;
     int    bias;
{
  int rd, rm;
  expressionS expr;

  skip_whitespace (*str);
  
  /* Parse <Rd>, field. */
  if ((rd = reg_required_here (str, 12)) == FAIL
      || skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Parse #<immed>,  field. */
  if (is_immediate_prefix (**str))
    (*str)++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number + bias < 0
      || expr.X_add_number + bias > 31)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  inst.instruction |= (expr.X_add_number + bias) << 16;
  if (skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Parse <Rm> field. */
  if ((rm = reg_required_here (str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  if (skip_past_comma (str) == SUCCESS)
    decode_shift (str, SHIFT_LSL_OR_ASR_IMMEDIATE);
}

/* ARM V6 ssat16 (argument parse). */

static void
do_ssat16 (str)
     char *str;
{
  do_sat16 (&str, /*bias=*/-1);
  end_of_line (str);
}

static void
do_usat16 (str)
     char *str;
{
  do_sat16 (&str, /*bias=*/0);
  end_of_line (str);
}

static void
do_sat16 (str, bias)
     char **str;
     int bias;
{
  int rd, rm;
  expressionS expr;

  skip_whitespace (*str);

  /* Parse the <Rd> field. */
  if ((rd = reg_required_here (str, 12)) == FAIL
      || skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Parse #<immed>, field. */
  if (is_immediate_prefix (**str))
    (*str)++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number + bias < 0
      || expr.X_add_number + bias > 15)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  inst.instruction |= (expr.X_add_number + bias) << 16;
  if (skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Parse <Rm> field. */
  if ((rm = reg_required_here (str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
}

/* ARM V6 srs (argument parse). */

static void
do_srs (str)
     char* str;
{
  char *exclam;
  skip_whitespace (str);
  exclam = strchr (str, '!');
  if (exclam)
    *exclam = '\0';
  do_cps_mode (&str);
  if (exclam)
    *exclam = '!';
  if (*str == '!') 
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  end_of_line (str);
}

/* ARM V6 SMMUL (argument parse). */

static void
do_smmul (str)
     char* str;
{
  int rd, rm, rs;
  
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rd == REG_PC 
      || rm == REG_PC
      || rs == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
  
}

/* ARM V6 SMLALD (argument parse). */

static void
do_smlald (str)
    char* str;
{
  int rdlo, rdhi, rm, rs;
  skip_whitespace (str);
  if ((rdlo = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rdhi = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (rdlo == REG_PC 
      || rdhi == REG_PC 
      || rm == REG_PC
      || rs == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
}

/* ARM V6 SMLAD (argument parse).  Signed multiply accumulate dual. 
   smlad{x}{<cond>} Rd, Rm, Rs, Rn */

static void 
do_smlad (str)
     char *str;
{
  int rd, rm, rs, rn;
  
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 12)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  
  if (rd == REG_PC 
      || rn == REG_PC 
      || rs == REG_PC
      || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  end_of_line (str);
} 

/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
   preserving the other bits.

   setend <endian_specifier>, where <endian_specifier> is either 
   BE or LE. */

static void 
do_setend (str)
     char *str;
{
  if (do_endian_specifier (str))
    inst.instruction |= 0x200;
}

/* Returns true if the endian-specifier indicates big-endianness.  */

static int
do_endian_specifier (str)
     char *str;
{
  int big_endian = 0;

  skip_whitespace (str);
  if (strlen (str) < 2)
    inst.error = _("missing endian specifier");
  else if (strncasecmp (str, "BE", 2) == 0)
    {
      str += 2;
      big_endian = 1;
    }
  else if (strncasecmp (str, "LE", 2) == 0)
    str += 2;
  else
    inst.error = _("valid endian specifiers are be or le");

  end_of_line (str);

  return big_endian;
}

/* ARM V6 SXTH.

   SXTH {<cond>} <Rd>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15. */

static void 
do_sxth (str)
     char *str;
{
  int rd, rm;
  expressionS expr;
  int rotation_clear_mask = 0xfffff3ff;
  int rotation_eight_mask = 0x00000400;
  int rotation_sixteen_mask = 0x00000800;
  int rotation_twenty_four_mask = 0x00000c00;
  
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  else if (rd == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  
  /* Zero out the rotation field. */
  inst.instruction &= rotation_clear_mask;
  
  /* Check for lack of optional rotation field. */
  if (skip_past_comma (&str) == FAIL)
    {
      end_of_line (str);
      return;
    }
  
  /* Move past 'ROR'. */
  skip_whitespace (str);
  if (strncasecmp (str, "ROR", 3) == 0)
    str+=3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return;
    }
  
  /* Get the immediate constant. */
  skip_whitespace (str);
  if (is_immediate_prefix (* str))
    str++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }

  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  
  switch (expr.X_add_number) 
    {
    case 0:
      /* Rotation field has already been zeroed. */
      break;
    case 8:
      inst.instruction |= rotation_eight_mask;
      break;

    case 16:
      inst.instruction |= rotation_sixteen_mask;
      break;
      
    case 24:
      inst.instruction |= rotation_twenty_four_mask;
      break;

    default:
      inst.error = _("rotation can be 8, 16, 24 or 0 when field is ommited");
      break;
    }

  end_of_line (str);
  
}

/* ARM V6 SXTAH extracts a 16-bit value from a register, sign
   extends it to 32-bits, and adds the result to a value in another
   register.  You can specify a rotation by 0, 8, 16, or 24 bits
   before extracting the 16-bit value.
   SXTAH{<cond>} <Rd>, <Rn>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15. */

static void 
do_sxtah (str)
     char *str;
{
  int rd, rn, rm;
  expressionS expr;
  int rotation_clear_mask = 0xfffff3ff;
  int rotation_eight_mask = 0x00000400;
  int rotation_sixteen_mask = 0x00000800;
  int rotation_twenty_four_mask = 0x00000c00;
  
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  else if (rd == REG_PC || rn == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  
  /* Zero out the rotation field. */
  inst.instruction &= rotation_clear_mask;
  
  /* Check for lack of optional rotation field. */
  if (skip_past_comma (&str) == FAIL)
    {
      end_of_line (str);
      return;
    }
  
  /* Move past 'ROR'. */
  skip_whitespace (str);
  if (strncasecmp (str, "ROR", 3) == 0)
    str+=3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return;
    }
  
  /* Get the immediate constant. */
  skip_whitespace (str);
  if (is_immediate_prefix (* str))
    str++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }

  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  
  switch (expr.X_add_number) 
    {
    case 0:
      /* Rotation field has already been zeroed. */
      break;

    case 8:
      inst.instruction |= rotation_eight_mask;
      break;

    case 16:
      inst.instruction |= rotation_sixteen_mask;
      break;
      
    case 24:
      inst.instruction |= rotation_twenty_four_mask;
      break;

    default:
      inst.error = _("rotation can be 8, 16, 24 or 0 when field is ommited");
      break;
    }

  end_of_line (str);
  
}
   

/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the
   word at the specified address and the following word
   respectively. 
   Unconditionally executed.
   Error if Rn is R15.   
*/

static void
do_rfe (str)
     char *str;
{
  int rn;

  skip_whitespace (str);
  
  if ((rn = reg_required_here (&str, 16)) == FAIL)
    return;

  if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  skip_whitespace (str);
  
  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  end_of_line (str);
}

/* ARM V6 REV (Byte Reverse Word) reverses the byte order in a 32-bit
   register (argument parse).
   REV{<cond>} Rd, Rm.
   Condition defaults to COND_ALWAYS.
   Error if Rd or Rm are R15. */ 

static void
do_rev (str)
     char* str;
{
  int rd, rm;

  skip_whitespace (str);

  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC)
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V6 Perform Two Sixteen Bit Integer Additions. (argument parse).
   QADD16{<cond>} <Rd>, <Rn>, <Rm>  
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */

static void
do_qadd16 (str) 
     char* str;
{
  int rd, rm, rn;

  skip_whitespace (str);

  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;

  else
    end_of_line (str);
}

/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>} 
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */

static void 
do_pkhbt (str)
     char* str;
{
  do_pkh_core (str, SHIFT_LSL_IMMEDIATE);
}

/* ARM V6 PKHTB (Argument Parse). */

static void 
do_pkhtb (str)
     char* str;
{
  do_pkh_core (str, SHIFT_ASR_IMMEDIATE);
}

static void
do_pkh_core (str, shift)
     char* str;
     int shift;
{
  int rd, rn, rm;

  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL)
      || ((rn = reg_required_here (&str, 16)) == FAIL)
      || (skip_past_comma (&str) == FAIL)
      || ((rm = reg_required_here (&str, 0)) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }

  else if (rd == REG_PC || rn == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Check for optional shift immediate constant. */
  if (skip_past_comma (&str) == FAIL) 
    {
      if (shift == SHIFT_ASR_IMMEDIATE)
	{
	  /* If the shift specifier is ommited, turn the instruction
	     into pkhbt rd, rm, rn.  First, switch the instruction
	     code, and clear the rn and rm fields.  */
	  inst.instruction &= 0xfff0f010;
	  /* Now, re-encode the registers.  */
	  inst.instruction |= (rm << 16) | rn;
	}
      return;
    }

  decode_shift (&str, shift);
}

/* ARM V6 Load Register Exclusive instruction (argument parse).
   LDREX{<cond>} <Rd, [<Rn>]
   Condition defaults to COND_ALWAYS.
   Error if Rd or Rn are R15. 
   See ARMARMv6 A4.1.27: LDREX. */


static void
do_ldrex (str)
     char * str;
{
  int rd, rn;

  skip_whitespace (str);

  /* Parse Rd. */
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  skip_whitespace (str);  

  /* Skip past '['. */
  if ((strlen (str) >= 1) 
      &&strncmp (str, "[", 1) == 0)
    str+=1;
  skip_whitespace (str);  

  /* Parse Rn. */
  if ((rn = reg_required_here (&str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  skip_whitespace (str);  

  /* Skip past ']'. */
  if ((strlen (str) >= 1) 
      && strncmp (str, "]", 1) == 0)
    str+=1;
  
  end_of_line (str);
}

/* ARM V6 change processor state instruction (argument parse)
      CPS, CPSIE, CSPID . */

static void
do_cps (str)
     char * str;
{
  do_cps_mode (&str);
  end_of_line (str);
}

static void
do_cpsi (str)
     char * str;
{
  do_cps_flags (&str, /*thumb_p=*/0);

  if (skip_past_comma (&str) == SUCCESS)
    {
      skip_whitespace (str);
      do_cps_mode (&str);
a4306 2
  end_of_line (str);
}
d4308 2
a4309 9
static void
do_cps_mode (str)
     char **str;
{
  expressionS expr;

  skip_whitespace (*str);

  if (! is_immediate_prefix (**str))
d4311 2
a4312 1
      inst.error = _("immediate expression expected");
d4316 2
a4317 2
  (*str)++; /* Strip off the immediate signifier. */
  if (my_get_expression (&expr, str))
d4319 2
a4320 1
      inst.error = _("bad expression");
d4324 2
a4325 1
  if (expr.X_op != O_constant)
d4327 2
a4328 1
      inst.error = _("constant expression expected");
d4331 2
a4332 4
  
  /* The mode is a 5 bit field.  Valid values are 0-31. */
  if (((unsigned) expr.X_add_number) > 31
      || (inst.reloc.exp.X_add_number) < 0)
d4334 6
a4339 2
      inst.error = _("invalid constant");
      return;
d4341 2
a4342 2
  
  inst.instruction |= expr.X_add_number;
d4345 1
d4347 2
a4348 3
do_cps_flags (str, thumb_p)
     char **str;
     int    thumb_p;
d4350 1
a4350 10
  struct cps_flag { 
    char character;
    unsigned long arm_value;
    unsigned long thumb_value;
  };
  static struct cps_flag flag_table[] = {
    {'a', 0x100, 0x4 },
    {'i', 0x080, 0x2 },
    {'f', 0x040, 0x1 }
  };
d4352 1
a4352 1
  int saw_a_flag = 0;
d4354 1
a4354 4
  skip_whitespace (*str);

  /* Get the a, f and i flags. */
  while (**str && **str != ',')
d4356 2
a4357 15
      struct cps_flag *p;
      struct cps_flag *q = flag_table + sizeof (flag_table)/sizeof (*p);
      for (p = flag_table; p < q; ++p)
	if (strncasecmp (*str, &p->character, 1) == 0)
	  {
	    inst.instruction |= (thumb_p ? p->thumb_value : p->arm_value);
	    saw_a_flag = 1;
	    break;
	  }
      if (p == q)
	{
	  inst.error = _("unrecognized flag");
	  return;
	}
      (*str)++;
d4359 6
a4364 2
  if (!saw_a_flag) 
    inst.error = _("no 'a', 'i', or 'f' flags for 'cps'");
a4595 29
/* THUMB CPS instruction (argument parse).  */

static void
do_t_cps (str)
     char *str;
{
  do_cps_flags (&str, /*thumb_p=*/1);
  end_of_line (str);
}

/* THUMB CPY instruction (argument parse).  */

static void
do_t_cpy (str)
     char *str;
{
  thumb_mov_compare (str, THUMB_CPY);
}

/* THUMB SETEND instruction (argument parse).  */

static void
do_t_setend (str)
     char *str;
{
  if (do_endian_specifier (str))
    inst.instruction |= 0x8;
}

a4807 1
      as_bad (_("non-word size not supported with control register"));
d4823 1
d4831 2
d4845 1
d4870 1
d4878 2
d4887 2
d4896 2
d4905 2
d4914 2
d4923 2
d4932 1
d4945 1
d4956 1
a4982 4
      if ((inst.instruction & COND_MASK) != COND_ALWAYS)
	as_bad (_("conditional execution not supported with control register"));
      if (op != 2)
	as_bad (_("non-word size not supported with control register"));
d4993 2
d5002 2
d5011 2
d5025 1
d5036 1
d5438 2
a5439 1
/* KIND indicates what kind of shifts are accepted.  */
d5442 1
a5442 1
decode_shift (str, kind)
d5444 1
a5444 1
     int     kind;
a5473 20
  if (kind == SHIFT_LSL_OR_ASR_IMMEDIATE
      && shift->properties->index != SHIFT_LSL
      && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'LSL' or 'ASR' required");
      return FAIL;
    }
  else if (kind == SHIFT_LSL_IMMEDIATE
	   && shift->properties->index != SHIFT_LSL)
    {
      inst.error = _("'LSL' required");
      return FAIL;
    }
  else if (kind == SHIFT_ASR_IMMEDIATE
	   && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'ASR' required");
      return FAIL;
    }
    
d5483 1
a5483 1
  if (kind == NO_SHIFT_RESTRICT && reg_required_here (& p, 8) != FAIL)
d5491 1
a5491 1
      inst.error = (NO_SHIFT_RESTRICT
d5553 1
a5553 1
   by altering the instruction.  A bit of a hack really.
d5806 1
a5828 1
#ifndef TE_WINCE
a5829 1
#endif
a5859 1
#ifndef TE_WINCE  
a5860 1
#endif
d5863 2
d5889 1
d5914 1
d5970 1
a5970 1
	return decode_shift (str, SHIFT_IMMEDIATE);
d6165 1
d6244 1
d6500 1
d6697 1
d6716 2
d6778 1
d6823 1
d6905 1
d6941 1
d7003 1
d7023 1
d7219 1
d7244 1
d7269 1
d7294 1
d7315 1
d7414 1
d7435 1
d7458 1
d7481 1
d7502 1
d7506 1
a7506 1
do_vfp_reg2_from_sp2 (str)
d7511 4
a7514 2
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
d7531 1
d7552 1
a7552 26
}

static void
do_vfp_sp2_from_reg2 (str)
     char *str;
{
  skip_whitespace (str);

  /* We require exactly two consecutive SP registers.  */
  if (vfp_sp_reg_list (&str, VFP_REG_Sm) != 2)
    {
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
    }

  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
d7573 1
d7596 1
d7617 1
d7632 1
a7632 1
      || reg_required_here (&str, 16) == FAIL)
d7640 1
d7719 1
d7740 1
d7765 1
d7790 1
d8157 1
d8174 1
d8195 1
d8216 1
d8561 1
a8561 1
  if (move != THUMB_CPY && is_immediate_prefix (*str))
d8572 1
a8572 1
      if (move != THUMB_CPY && Rs < 8 && Rd < 8)
d8586 1
a8586 1
	  else if (move != THUMB_CPY)
d9116 1
a9116 1
/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
d9126 1
a9126 1
      || mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL)
d9137 1
a9137 1
/* cfmv32sc<cond> MVDX[15:0],DSPSC.  */
d9145 1
a9145 1
  if (mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL
d9466 1
a9466 1
    inst.instruction |= CP_T_UD; /* Positive, so set bit U.  */
d9475 1
d9484 1
d9586 1
a9586 1
  /* This definition must agree with the one in gcc/config/arm/thumb.c.  */
d9858 1
d9934 5
a9938 6
  const char *error;
  struct reg_entry *new = xmalloc (sizeof (struct reg_entry));
  const char *name = xmalloc (strlen (str) + 1);
  
  strcpy ((char *) name, str);
  
a9940 1
  new->builtin = FALSE;
d9942 1
a9942 8
  error = hash_insert (htab, name, (PTR) new);
  if (error)
    {
      as_bad (_("failed to create an alias for %s, reason: %s"),
	    str, error);
      free ((char *) name);
      free (new);
    }
d9947 1
a9947 1
   	new_register_name .req existing_register_name
a10026 1
  
a10088 1
#if 0 /* Suppressed - for now.  */
a10135 1
#endif
a10187 3
#if !(defined (TE_LINUX) || defined (TE_NetBSD))
      /* Some environments specify a default FPU.  If they don't, infer it
	 from the processor.  */
a10191 3
#else
      mfpu_opt = FPU_DEFAULT;
#endif
d10219 2
a10220 16
	 || (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
      {
	flags |= F_SOFT_FLOAT;
      }
    switch (mfloat_abi_opt)
      {
      case ARM_FLOAT_ABI_SOFT:
      case ARM_FLOAT_ABI_SOFTFP:
	flags |= F_SOFT_FLOAT;
	break;

      case ARM_FLOAT_ABI_HARD:
	if (flags & F_SOFT_FLOAT)
	  as_bad (_("hard-float conflicts with specified fpu"));
	break;
      }
d10225 3
a10227 1
    if (cpu_variant & FPU_ARCH_MAVERICK)
d10229 1
a10323 3
#else
    bfd_set_section_flags (stdoutput, arm_arch,
			   SEC_READONLY | SEC_HAS_CONTENTS);
d10515 2
a10516 2
  /* The pattern was adjusted to accommodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accommodation.  */
d10881 1
a10881 1
	     branch instruction itself, then we can compute the relocation for
a11337 10
      if (fixp->fx_addsy != NULL
	  && !S_IS_DEFINED (fixp->fx_addsy)
	  && S_IS_LOCAL (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("undefined local label `%s'"),
			S_GET_NAME (fixp->fx_addsy));
	  return NULL;
	}

a11498 1
	  mapping_state (MAP_THUMB);
a11523 1
          mapping_state (MAP_ARM);
a11828 1
  {"arm926ejs",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
a11837 3
  {"arm1026ejs",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1136js",		ARM_ARCH_V6,     FPU_NONE},
  {"arm1136jfs",	ARM_ARCH_V6,     FPU_ARCH_VFP_V2},
d11844 1
a11844 1
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_ARCH_MAVERICK},
a11875 2
  {"armv6",             ARM_ARCH_V6,     FPU_ARCH_VFP},
  {"armv6j",            ARM_ARCH_V6,     FPU_ARCH_VFP},
a11876 1
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP},
a11921 16
  {"arm1136jfs",	FPU_ARCH_VFP_V2},
  {"maverick",		FPU_ARCH_MAVERICK},
  {NULL, 0}
};

struct arm_float_abi_option_table
{
  char *name;
  int value;
};

static struct arm_float_abi_option_table arm_float_abis[] =
{
  {"hard",	ARM_FLOAT_ABI_HARD},
  {"softfp",	ARM_FLOAT_ABI_SOFTFP},
  {"soft",	ARM_FLOAT_ABI_SOFT},
a12070 17
static int
arm_parse_float_abi (str)
     char * str;
{
  struct arm_float_abi_option_table *opt;

  for (opt = arm_float_abis; opt->name != NULL; opt++)
    if (strcmp (opt->name, str) == 0)
      {
	mfloat_abi_opt = opt->value;
	return 1;
      }

  as_bad (_("unknown floating point abi `%s'\n"), str);
  return 0;
}

a12078 2
  {"mfloat-abi=", N_("<abi>\t  assemble for floating point ABI <abi>"),
   arm_parse_float_abi, NULL},
d12224 2
a12274 3
#ifdef OBJ_ELF
      arm_elf_change_section ();
#endif
a12625 1
  mapping_state (MAP_DATA);
d12736 1
a12736 1
  /* We assume that there will never be a requirement
@


