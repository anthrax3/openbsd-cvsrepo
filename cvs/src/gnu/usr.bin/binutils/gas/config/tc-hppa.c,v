head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.54
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.52
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.4.0.10
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.8
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.27;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.30;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.49;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	98.07.04.07.47.34;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.05.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.17;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.05;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.05;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.34;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.44.45;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.23.01;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.46.24;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.34.43;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.30;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.51;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-hppa.c -- Assemble for the PA
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* HP PA-RISC support was contributed by the Center for Software Science
   at the University of Utah.  */

#include <stdio.h>

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"

#include "bfd/libhppa.h"

/* Be careful, this file includes data *declarations*.  */
#include "opcode/hppa.h"

#if defined (OBJ_ELF) && defined (OBJ_SOM)
error only one of OBJ_ELF and OBJ_SOM can be defined
#endif

/* If we are using ELF, then we probably can support dwarf2 debug
   records.  Furthermore, if we are supporting dwarf2 debug records,
   then we want to use the assembler support for compact line numbers.  */
#ifdef OBJ_ELF
#include "dwarf2dbg.h"

/* A "convenient" place to put object file dependencies which do
   not need to be seen outside of tc-hppa.c.  */

/* Object file formats specify relocation types.  */
typedef enum elf_hppa_reloc_type reloc_type;

/* Object file formats specify BFD symbol types.  */
typedef elf_symbol_type obj_symbol_type;
#define symbol_arg_reloc_info(sym)\
  (((obj_symbol_type *) symbol_get_bfdsym (sym))->tc_data.hppa_arg_reloc)

#if TARGET_ARCH_SIZE == 64
/* How to generate a relocation.  */
#define hppa_gen_reloc_type _bfd_elf64_hppa_gen_reloc_type
#define elf_hppa_reloc_final_type elf64_hppa_reloc_final_type
#else
#define hppa_gen_reloc_type _bfd_elf32_hppa_gen_reloc_type
#define elf_hppa_reloc_final_type elf32_hppa_reloc_final_type
#endif

/* ELF objects can have versions, but apparently do not have anywhere
   to store a copyright string.  */
#define obj_version obj_elf_version
#define obj_copyright obj_elf_version

#define UNWIND_SECTION_NAME ".PARISC.unwind"
#endif /* OBJ_ELF */

#ifdef OBJ_SOM
/* Names of various debugging spaces/subspaces.  */
#define GDB_DEBUG_SPACE_NAME "$GDB_DEBUG$"
#define GDB_STRINGS_SUBSPACE_NAME "$GDB_STRINGS$"
#define GDB_SYMBOLS_SUBSPACE_NAME "$GDB_SYMBOLS$"
#define UNWIND_SECTION_NAME "$UNWIND$"

/* Object file formats specify relocation types.  */
typedef int reloc_type;

/* SOM objects can have both a version string and a copyright string.  */
#define obj_version obj_som_version
#define obj_copyright obj_som_copyright

/* How to generate a relocation.  */
#define hppa_gen_reloc_type hppa_som_gen_reloc_type

/* Object file formats specify BFD symbol types.  */
typedef som_symbol_type obj_symbol_type;
#define symbol_arg_reloc_info(sym)\
  (((obj_symbol_type *) symbol_get_bfdsym (sym))->tc_data.ap.hppa_arg_reloc)

/* This apparently isn't in older versions of hpux reloc.h.  */
#ifndef R_DLT_REL
#define R_DLT_REL 0x78
#endif

#ifndef R_N0SEL
#define R_N0SEL 0xd8
#endif

#ifndef R_N1SEL
#define R_N1SEL 0xd9
#endif
#endif /* OBJ_SOM */

#if TARGET_ARCH_SIZE == 64
#define DEFAULT_LEVEL 25
#else
#define DEFAULT_LEVEL 10
#endif

/* Various structures and types used internally in tc-hppa.c.  */

/* Unwind table and descriptor.  FIXME: Sync this with GDB version.  */

struct unwind_desc
  {
    unsigned int cannot_unwind:1;
    unsigned int millicode:1;
    unsigned int millicode_save_rest:1;
    unsigned int region_desc:2;
    unsigned int save_sr:2;
    unsigned int entry_fr:4;
    unsigned int entry_gr:5;
    unsigned int args_stored:1;
    unsigned int call_fr:5;
    unsigned int call_gr:5;
    unsigned int save_sp:1;
    unsigned int save_rp:1;
    unsigned int save_rp_in_frame:1;
    unsigned int extn_ptr_defined:1;
    unsigned int cleanup_defined:1;

    unsigned int hpe_interrupt_marker:1;
    unsigned int hpux_interrupt_marker:1;
    unsigned int reserved:3;
    unsigned int frame_size:27;
  };

/* We can't rely on compilers placing bitfields in any particular
   place, so use these macros when dumping unwind descriptors to
   object files.  */
#define UNWIND_LOW32(U) \
  (((U)->cannot_unwind << 31)		\
   | ((U)->millicode << 30)		\
   | ((U)->millicode_save_rest << 29)	\
   | ((U)->region_desc << 27)		\
   | ((U)->save_sr << 25)		\
   | ((U)->entry_fr << 21)		\
   | ((U)->entry_gr << 16)		\
   | ((U)->args_stored << 15)		\
   | ((U)->call_fr << 10)		\
   | ((U)->call_gr << 5)		\
   | ((U)->save_sp << 4)		\
   | ((U)->save_rp << 3)		\
   | ((U)->save_rp_in_frame << 2)	\
   | ((U)->extn_ptr_defined << 1)	\
   | ((U)->cleanup_defined << 0))

#define UNWIND_HIGH32(U) \
  (((U)->hpe_interrupt_marker << 31)	\
   | ((U)->hpux_interrupt_marker << 30)	\
   | ((U)->frame_size << 0))

struct unwind_table
  {
    /* Starting and ending offsets of the region described by
       descriptor.  */
    unsigned int start_offset;
    unsigned int end_offset;
    struct unwind_desc descriptor;
  };

/* This structure is used by the .callinfo, .enter, .leave pseudo-ops to
   control the entry and exit code they generate. It is also used in
   creation of the correct stack unwind descriptors.

   NOTE:  GAS does not support .enter and .leave for the generation of
   prologues and epilogues.  FIXME.

   The fields in structure roughly correspond to the arguments available on the
   .callinfo pseudo-op.  */

struct call_info
  {
    /* The unwind descriptor being built.  */
    struct unwind_table ci_unwind;

    /* Name of this function.  */
    symbolS *start_symbol;

    /* (temporary) symbol used to mark the end of this function.  */
    symbolS *end_symbol;

    /* Next entry in the chain.  */
    struct call_info *ci_next;
  };

/* Operand formats for FP instructions.   Note not all FP instructions
   allow all four formats to be used (for example fmpysub only allows
   SGL and DBL).  */
typedef enum
  {
    SGL, DBL, ILLEGAL_FMT, QUAD, W, UW, DW, UDW, QW, UQW
  }
fp_operand_format;

/* This fully describes the symbol types which may be attached to
   an EXPORT or IMPORT directive.  Only SOM uses this formation
   (ELF has no need for it).  */
typedef enum
  {
    SYMBOL_TYPE_UNKNOWN,
    SYMBOL_TYPE_ABSOLUTE,
    SYMBOL_TYPE_CODE,
    SYMBOL_TYPE_DATA,
    SYMBOL_TYPE_ENTRY,
    SYMBOL_TYPE_MILLICODE,
    SYMBOL_TYPE_PLABEL,
    SYMBOL_TYPE_PRI_PROG,
    SYMBOL_TYPE_SEC_PROG,
  }
pa_symbol_type;

/* This structure contains information needed to assemble
   individual instructions.  */
struct pa_it
  {
    /* Holds the opcode after parsing by pa_ip.  */
    unsigned long opcode;

    /* Holds an expression associated with the current instruction.  */
    expressionS exp;

    /* Does this instruction use PC-relative addressing.  */
    int pcrel;

    /* Floating point formats for operand1 and operand2.  */
    fp_operand_format fpof1;
    fp_operand_format fpof2;

    /* Whether or not we saw a truncation request on an fcnv insn.  */
    int trunc;

    /* Holds the field selector for this instruction
       (for example L%, LR%, etc).  */
    long field_selector;

    /* Holds any argument relocation bits associated with this
       instruction.  (instruction should be some sort of call).  */
    unsigned int arg_reloc;

    /* The format specification for this instruction.  */
    int format;

    /* The relocation (if any) associated with this instruction.  */
    reloc_type reloc;
  };

/* PA-89 floating point registers are arranged like this:

   +--------------+--------------+
   |   0 or 16L   |  16 or 16R   |
   +--------------+--------------+
   |   1 or 17L   |  17 or 17R   |
   +--------------+--------------+
   |              |              |

   .              .              .
   .              .              .
   .              .              .

   |              |              |
   +--------------+--------------+
   |  14 or 30L   |  30 or 30R   |
   +--------------+--------------+
   |  15 or 31L   |  31 or 31R   |
   +--------------+--------------+  */

/* Additional information needed to build argument relocation stubs.  */
struct call_desc
  {
    /* The argument relocation specification.  */
    unsigned int arg_reloc;

    /* Number of arguments.  */
    unsigned int arg_count;
  };

#ifdef OBJ_SOM
/* This structure defines an entry in the subspace dictionary
   chain.  */

struct subspace_dictionary_chain
  {
    /* Nonzero if this space has been defined by the user code.  */
    unsigned int ssd_defined;

    /* Name of this subspace.  */
    char *ssd_name;

    /* GAS segment and subsegment associated with this subspace.  */
    asection *ssd_seg;
    int ssd_subseg;

    /* Next space in the subspace dictionary chain.  */
    struct subspace_dictionary_chain *ssd_next;
  };

typedef struct subspace_dictionary_chain ssd_chain_struct;

/* This structure defines an entry in the subspace dictionary
   chain.  */

struct space_dictionary_chain
  {
    /* Nonzero if this space has been defined by the user code or
       as a default space.  */
    unsigned int sd_defined;

    /* Nonzero if this spaces has been defined by the user code.  */
    unsigned int sd_user_defined;

    /* The space number (or index).  */
    unsigned int sd_spnum;

    /* The name of this subspace.  */
    char *sd_name;

    /* GAS segment to which this subspace corresponds.  */
    asection *sd_seg;

    /* Current subsegment number being used.  */
    int sd_last_subseg;

    /* The chain of subspaces contained within this space.  */
    ssd_chain_struct *sd_subspaces;

    /* The next entry in the space dictionary chain.  */
    struct space_dictionary_chain *sd_next;
  };

typedef struct space_dictionary_chain sd_chain_struct;

/* This structure defines attributes of the default subspace
   dictionary entries.  */

struct default_subspace_dict
  {
    /* Name of the subspace.  */
    char *name;

    /* FIXME.  Is this still needed?  */
    char defined;

    /* Nonzero if this subspace is loadable.  */
    char loadable;

    /* Nonzero if this subspace contains only code.  */
    char code_only;

    /* Nonzero if this is a common subspace.  */
    char common;

    /* Nonzero if this is a common subspace which allows symbols
       to be multiply defined.  */
    char dup_common;

    /* Nonzero if this subspace should be zero filled.  */
    char zero;

    /* Sort key for this subspace.  */
    unsigned char sort;

    /* Access control bits for this subspace.  Can represent RWX access
       as well as privilege level changes for gateways.  */
    int access;

    /* Index of containing space.  */
    int space_index;

    /* Alignment (in bytes) of this subspace.  */
    int alignment;

    /* Quadrant within space where this subspace should be loaded.  */
    int quadrant;

    /* An index into the default spaces array.  */
    int def_space_index;

    /* Subsegment associated with this subspace.  */
    subsegT subsegment;
  };

/* This structure defines attributes of the default space
   dictionary entries.  */

struct default_space_dict
  {
    /* Name of the space.  */
    char *name;

    /* Space number.  It is possible to identify spaces within
       assembly code numerically!  */
    int spnum;

    /* Nonzero if this space is loadable.  */
    char loadable;

    /* Nonzero if this space is "defined".  FIXME is still needed */
    char defined;

    /* Nonzero if this space can not be shared.  */
    char private;

    /* Sort key for this space.  */
    unsigned char sort;

    /* Segment associated with this space.  */
    asection *segment;
  };
#endif

/* Structure for previous label tracking.  Needed so that alignments,
   callinfo declarations, etc can be easily attached to a particular
   label.  */
typedef struct label_symbol_struct
  {
    struct symbol *lss_label;
#ifdef OBJ_SOM
    sd_chain_struct *lss_space;
#endif
#ifdef OBJ_ELF
    segT lss_segment;
#endif
    struct label_symbol_struct *lss_next;
  }
label_symbol_struct;

/* Extra information needed to perform fixups (relocations) on the PA.  */
struct hppa_fix_struct
  {
    /* The field selector.  */
    enum hppa_reloc_field_selector_type_alt fx_r_field;

    /* Type of fixup.  */
    int fx_r_type;

    /* Format of fixup.  */
    int fx_r_format;

    /* Argument relocation bits.  */
    unsigned int fx_arg_reloc;

    /* The segment this fixup appears in.  */
    segT segment;
  };

/* Structure to hold information about predefined registers.  */

struct pd_reg
  {
    char *name;
    int value;
  };

/* This structure defines the mapping from a FP condition string
   to a condition number which can be recorded in an instruction.  */
struct fp_cond_map
  {
    char *string;
    int cond;
  };

/* This structure defines a mapping from a field selector
   string to a field selector type.  */
struct selector_entry
  {
    char *prefix;
    int field_selector;
  };

/* Prototypes for functions local to tc-hppa.c.  */

#ifdef OBJ_SOM
static void pa_check_current_space_and_subspace PARAMS ((void));
#endif

#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
static void pa_text PARAMS ((int));
static void pa_data PARAMS ((int));
static void pa_comm PARAMS ((int));
#endif
static fp_operand_format pa_parse_fp_format PARAMS ((char **s));
static void pa_cons PARAMS ((int));
static void pa_float_cons PARAMS ((int));
static void pa_fill PARAMS ((int));
static void pa_lcomm PARAMS ((int));
static void pa_lsym PARAMS ((int));
static void pa_stringer PARAMS ((int));
static void pa_version PARAMS ((int));
static int pa_parse_fp_cmp_cond PARAMS ((char **));
static int get_expression PARAMS ((char *));
static int pa_get_absolute_expression PARAMS ((struct pa_it *, char **));
static int evaluate_absolute PARAMS ((struct pa_it *));
static unsigned int pa_build_arg_reloc PARAMS ((char *));
static unsigned int pa_align_arg_reloc PARAMS ((unsigned int, unsigned int));
static int pa_parse_nullif PARAMS ((char **));
static int pa_parse_nonneg_cmpsub_cmpltr PARAMS ((char **));
static int pa_parse_neg_cmpsub_cmpltr PARAMS ((char **));
static int pa_parse_neg_add_cmpltr PARAMS ((char **));
static int pa_parse_nonneg_add_cmpltr PARAMS ((char **));
static int pa_parse_cmpb_64_cmpltr PARAMS ((char **));
static int pa_parse_cmpib_64_cmpltr PARAMS ((char **));
static int pa_parse_addb_64_cmpltr PARAMS ((char **));
static void pa_block PARAMS ((int));
static void pa_brtab PARAMS ((int));
static void pa_try PARAMS ((int));
static void pa_call PARAMS ((int));
static void pa_call_args PARAMS ((struct call_desc *));
static void pa_callinfo PARAMS ((int));
static void pa_copyright PARAMS ((int));
static void pa_end PARAMS ((int));
static void pa_enter PARAMS ((int));
static void pa_entry PARAMS ((int));
static void pa_equ PARAMS ((int));
static void pa_exit PARAMS ((int));
static void pa_export PARAMS ((int));
static void pa_type_args PARAMS ((symbolS *, int));
static void pa_import PARAMS ((int));
static void pa_label PARAMS ((int));
static void pa_leave PARAMS ((int));
static void pa_level PARAMS ((int));
static void pa_origin PARAMS ((int));
static void pa_proc PARAMS ((int));
static void pa_procend PARAMS ((int));
static void pa_param PARAMS ((int));
static void pa_undefine_label PARAMS ((void));
static int need_pa11_opcode PARAMS ((void));
static int pa_parse_number PARAMS ((char **, int));
static label_symbol_struct *pa_get_label PARAMS ((void));
#ifdef OBJ_SOM
static int log2 PARAMS ((int));
static void pa_compiler PARAMS ((int));
static void pa_align PARAMS ((int));
static void pa_space PARAMS ((int));
static void pa_spnum PARAMS ((int));
static void pa_subspace PARAMS ((int));
static sd_chain_struct *create_new_space PARAMS ((char *, int, int,
						  int, int, int,
						  asection *, int));
static ssd_chain_struct *create_new_subspace PARAMS ((sd_chain_struct *,
						      char *, int, int,
						      int, int, int,
						      int, int, int, int,
						      int, asection *));
static ssd_chain_struct *update_subspace PARAMS ((sd_chain_struct *,
						  char *, int, int, int,
						  int, int, int, int,
						  int, int, int,
						  asection *));
static sd_chain_struct *is_defined_space PARAMS ((char *));
static ssd_chain_struct *is_defined_subspace PARAMS ((char *));
static sd_chain_struct *pa_segment_to_space PARAMS ((asection *));
static ssd_chain_struct *pa_subsegment_to_subspace PARAMS ((asection *,
							    subsegT));
static sd_chain_struct *pa_find_space_by_number PARAMS ((int));
static unsigned int pa_subspace_start PARAMS ((sd_chain_struct *, int));
static sd_chain_struct *pa_parse_space_stmt PARAMS ((char *, int));
static int pa_next_subseg PARAMS ((sd_chain_struct *));
static void pa_spaces_begin PARAMS ((void));
#endif
static void pa_ip PARAMS ((char *));
static void fix_new_hppa PARAMS ((fragS *, int, int, symbolS *,
				  offsetT, expressionS *, int,
				  bfd_reloc_code_real_type,
				  enum hppa_reloc_field_selector_type_alt,
				  int, unsigned int, int));
static int is_end_of_statement PARAMS ((void));
static int reg_name_search PARAMS ((char *));
static int pa_chk_field_selector PARAMS ((char **));
static int is_same_frag PARAMS ((fragS *, fragS *));
static void process_exit PARAMS ((void));
static unsigned int pa_stringer_aux PARAMS ((char *));
static fp_operand_format pa_parse_fp_cnv_format PARAMS ((char **s));
static int pa_parse_ftest_gfx_completer PARAMS ((char **));

#ifdef OBJ_ELF
static void hppa_elf_mark_end_of_function PARAMS ((void));
static void pa_build_unwind_subspace PARAMS ((struct call_info *));
static void pa_vtable_entry PARAMS ((int));
static void pa_vtable_inherit  PARAMS ((int));
#endif

/* File and globally scoped variable declarations.  */

#ifdef OBJ_SOM
/* Root and final entry in the space chain.  */
static sd_chain_struct *space_dict_root;
static sd_chain_struct *space_dict_last;

/* The current space and subspace.  */
static sd_chain_struct *current_space;
static ssd_chain_struct *current_subspace;
#endif

/* Root of the call_info chain.  */
static struct call_info *call_info_root;

/* The last call_info (for functions) structure
   seen so it can be associated with fixups and
   function labels.  */
static struct call_info *last_call_info;

/* The last call description (for actual calls).  */
static struct call_desc last_call_desc;

/* handle of the OPCODE hash table */
static struct hash_control *op_hash = NULL;

/* These characters can be suffixes of opcode names and they may be
   followed by meaningful whitespace.  We don't include `,' and `!'
   as they never appear followed by meaningful whitespace.  */
const char hppa_symbol_chars[] = "*?=<>";

/* Table of pseudo ops for the PA.  FIXME -- how many of these
   are now redundant with the overall GAS and the object file
   dependent tables?  */
const pseudo_typeS md_pseudo_table[] =
{
  /* align pseudo-ops on the PA specify the actual alignment requested,
     not the log2 of the requested alignment.  */
#ifdef OBJ_SOM
  {"align", pa_align, 8},
#endif
#ifdef OBJ_ELF
  {"align", s_align_bytes, 8},
#endif
  {"begin_brtab", pa_brtab, 1},
  {"begin_try", pa_try, 1},
  {"block", pa_block, 1},
  {"blockz", pa_block, 0},
  {"byte", pa_cons, 1},
  {"call", pa_call, 0},
  {"callinfo", pa_callinfo, 0},
#if defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD))
  {"code", obj_elf_text, 0},
#else
  {"code", pa_text, 0},
  {"comm", pa_comm, 0},
#endif
#ifdef OBJ_SOM
  {"compiler", pa_compiler, 0},
#endif
  {"copyright", pa_copyright, 0},
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
  {"data", pa_data, 0},
#endif
  {"double", pa_float_cons, 'd'},
  {"dword", pa_cons, 8},
  {"end", pa_end, 0},
  {"end_brtab", pa_brtab, 0},
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
  {"end_try", pa_try, 0},
#endif
  {"enter", pa_enter, 0},
  {"entry", pa_entry, 0},
  {"equ", pa_equ, 0},
  {"exit", pa_exit, 0},
  {"export", pa_export, 0},
  {"fill", pa_fill, 0},
  {"float", pa_float_cons, 'f'},
  {"half", pa_cons, 2},
  {"import", pa_import, 0},
  {"int", pa_cons, 4},
  {"label", pa_label, 0},
  {"lcomm", pa_lcomm, 0},
  {"leave", pa_leave, 0},
  {"level", pa_level, 0},
  {"long", pa_cons, 4},
  {"lsym", pa_lsym, 0},
#ifdef OBJ_SOM
  {"nsubspa", pa_subspace, 1},
#endif
  {"octa", pa_cons, 16},
  {"org", pa_origin, 0},
  {"origin", pa_origin, 0},
  {"param", pa_param, 0},
  {"proc", pa_proc, 0},
  {"procend", pa_procend, 0},
  {"quad", pa_cons, 8},
  {"reg", pa_equ, 1},
  {"short", pa_cons, 2},
  {"single", pa_float_cons, 'f'},
#ifdef OBJ_SOM
  {"space", pa_space, 0},
  {"spnum", pa_spnum, 0},
#endif
  {"string", pa_stringer, 0},
  {"stringz", pa_stringer, 1},
#ifdef OBJ_SOM
  {"subspa", pa_subspace, 0},
#endif
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
  {"text", pa_text, 0},
#endif
  {"version", pa_version, 0},
#ifdef OBJ_ELF
  {"vtable_entry", pa_vtable_entry, 0},
  {"vtable_inherit", pa_vtable_inherit, 0},
#endif
  {"word", pa_cons, 4},
  {NULL, 0, 0}
};

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.

   Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.

   Also note that C style comments will always work.  */
const char line_comment_chars[] = "#";

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = ";";

/* This array holds the characters which act as line separators.  */
const char line_separator_chars[] = "!";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   As in 0f12.456 or 0d1.2345e12.

   Be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c.  Ideally it shouldn't hae to know abou it at
   all, but nothing is ideal around here.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

static struct pa_it the_insn;

/* Points to the end of an expression just parsed by get_expression
   and friends.  FIXME.  This shouldn't be handled with a file-global
   variable.  */
static char *expr_end;

/* Nonzero if a .callinfo appeared within the current procedure.  */
static int callinfo_found;

/* Nonzero if the assembler is currently within a .entry/.exit pair.  */
static int within_entry_exit;

/* Nonzero if the assembler is currently within a procedure definition.  */
static int within_procedure;

/* Handle on structure which keep track of the last symbol
   seen in each subspace.  */
static label_symbol_struct *label_symbols_rootp = NULL;

/* Holds the last field selector.  */
static int hppa_field_selector;

/* Nonzero when strict syntax checking is enabled.  Zero otherwise.

   Each opcode in the table has a flag which indicates whether or not
   strict syntax checking should be enabled for that instruction.  */
static int strict = 0;

/* pa_parse_number returns values in `pa_number'.  Mostly
   pa_parse_number is used to return a register number, with floating
   point registers being numbered from FP_REG_BASE upwards.
   The bit specified with FP_REG_RSEL is set if the floating point
   register has a `r' suffix.  */
#define FP_REG_BASE 64
#define FP_REG_RSEL 128
static int pa_number;

#ifdef OBJ_SOM
/* A dummy bfd symbol so that all relocations have symbols of some kind.  */
static symbolS *dummy_symbol;
#endif

/* Nonzero if errors are to be printed.  */
static int print_errors = 1;

/* List of registers that are pre-defined:

   Each general register has one predefined name of the form
   %r<REGNUM> which has the value <REGNUM>.

   Space and control registers are handled in a similar manner,
   but use %sr<REGNUM> and %cr<REGNUM> as their predefined names.

   Likewise for the floating point registers, but of the form
   %fr<REGNUM>.  Floating point registers have additional predefined
   names with 'L' and 'R' suffixes (e.g. %fr19L, %fr19R) which
   again have the value <REGNUM>.

   Many registers also have synonyms:

   %r26 - %r23 have %arg0 - %arg3 as synonyms
   %r28 - %r29 have %ret0 - %ret1 as synonyms
   %r30 has %sp as a synonym
   %r27 has %dp as a synonym
   %r2  has %rp as a synonym

   Almost every control register has a synonym; they are not listed
   here for brevity.

   The table is sorted. Suitable for searching by a binary search.  */

static const struct pd_reg pre_defined_registers[] =
{
  {"%arg0",  26},
  {"%arg1",  25},
  {"%arg2",  24},
  {"%arg3",  23},
  {"%cr0",    0},
  {"%cr10",  10},
  {"%cr11",  11},
  {"%cr12",  12},
  {"%cr13",  13},
  {"%cr14",  14},
  {"%cr15",  15},
  {"%cr16",  16},
  {"%cr17",  17},
  {"%cr18",  18},
  {"%cr19",  19},
  {"%cr20",  20},
  {"%cr21",  21},
  {"%cr22",  22},
  {"%cr23",  23},
  {"%cr24",  24},
  {"%cr25",  25},
  {"%cr26",  26},
  {"%cr27",  27},
  {"%cr28",  28},
  {"%cr29",  29},
  {"%cr30",  30},
  {"%cr31",  31},
  {"%cr8",    8},
  {"%cr9",    9},
  {"%dp",    27},
  {"%eiem",  15},
  {"%eirr",  23},
  {"%farg0",  5},
  {"%farg1",  6},
  {"%farg2",  7},
  {"%farg3",  8},
  {"%fr0",    0 + FP_REG_BASE},
  {"%fr0l",   0 + FP_REG_BASE},
  {"%fr0r",   0 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr1",    1 + FP_REG_BASE},
  {"%fr10",  10 + FP_REG_BASE},
  {"%fr10l", 10 + FP_REG_BASE},
  {"%fr10r", 10 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr11",  11 + FP_REG_BASE},
  {"%fr11l", 11 + FP_REG_BASE},
  {"%fr11r", 11 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr12",  12 + FP_REG_BASE},
  {"%fr12l", 12 + FP_REG_BASE},
  {"%fr12r", 12 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr13",  13 + FP_REG_BASE},
  {"%fr13l", 13 + FP_REG_BASE},
  {"%fr13r", 13 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr14",  14 + FP_REG_BASE},
  {"%fr14l", 14 + FP_REG_BASE},
  {"%fr14r", 14 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr15",  15 + FP_REG_BASE},
  {"%fr15l", 15 + FP_REG_BASE},
  {"%fr15r", 15 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr16",  16 + FP_REG_BASE},
  {"%fr16l", 16 + FP_REG_BASE},
  {"%fr16r", 16 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr17",  17 + FP_REG_BASE},
  {"%fr17l", 17 + FP_REG_BASE},
  {"%fr17r", 17 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr18",  18 + FP_REG_BASE},
  {"%fr18l", 18 + FP_REG_BASE},
  {"%fr18r", 18 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr19",  19 + FP_REG_BASE},
  {"%fr19l", 19 + FP_REG_BASE},
  {"%fr19r", 19 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr1l",   1 + FP_REG_BASE},
  {"%fr1r",   1 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr2",    2 + FP_REG_BASE},
  {"%fr20",  20 + FP_REG_BASE},
  {"%fr20l", 20 + FP_REG_BASE},
  {"%fr20r", 20 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr21",  21 + FP_REG_BASE},
  {"%fr21l", 21 + FP_REG_BASE},
  {"%fr21r", 21 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr22",  22 + FP_REG_BASE},
  {"%fr22l", 22 + FP_REG_BASE},
  {"%fr22r", 22 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr23",  23 + FP_REG_BASE},
  {"%fr23l", 23 + FP_REG_BASE},
  {"%fr23r", 23 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr24",  24 + FP_REG_BASE},
  {"%fr24l", 24 + FP_REG_BASE},
  {"%fr24r", 24 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr25",  25 + FP_REG_BASE},
  {"%fr25l", 25 + FP_REG_BASE},
  {"%fr25r", 25 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr26",  26 + FP_REG_BASE},
  {"%fr26l", 26 + FP_REG_BASE},
  {"%fr26r", 26 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr27",  27 + FP_REG_BASE},
  {"%fr27l", 27 + FP_REG_BASE},
  {"%fr27r", 27 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr28",  28 + FP_REG_BASE},
  {"%fr28l", 28 + FP_REG_BASE},
  {"%fr28r", 28 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr29",  29 + FP_REG_BASE},
  {"%fr29l", 29 + FP_REG_BASE},
  {"%fr29r", 29 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr2l",   2 + FP_REG_BASE},
  {"%fr2r",   2 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr3",    3 + FP_REG_BASE},
  {"%fr30",  30 + FP_REG_BASE},
  {"%fr30l", 30 + FP_REG_BASE},
  {"%fr30r", 30 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr31",  31 + FP_REG_BASE},
  {"%fr31l", 31 + FP_REG_BASE},
  {"%fr31r", 31 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr3l",   3 + FP_REG_BASE},
  {"%fr3r",   3 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr4",    4 + FP_REG_BASE},
  {"%fr4l",   4 + FP_REG_BASE},
  {"%fr4r",   4 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr5",    5 + FP_REG_BASE},
  {"%fr5l",   5 + FP_REG_BASE},
  {"%fr5r",   5 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr6",    6 + FP_REG_BASE},
  {"%fr6l",   6 + FP_REG_BASE},
  {"%fr6r",   6 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr7",    7 + FP_REG_BASE},
  {"%fr7l",   7 + FP_REG_BASE},
  {"%fr7r",   7 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr8",    8 + FP_REG_BASE},
  {"%fr8l",   8 + FP_REG_BASE},
  {"%fr8r",   8 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr9",    9 + FP_REG_BASE},
  {"%fr9l",   9 + FP_REG_BASE},
  {"%fr9r",   9 + FP_REG_BASE + FP_REG_RSEL},
  {"%fret",   4},
  {"%hta",   25},
  {"%iir",   19},
  {"%ior",   21},
  {"%ipsw",  22},
  {"%isr",   20},
  {"%itmr",  16},
  {"%iva",   14},
#if TARGET_ARCH_SIZE == 64
  {"%mrp",    2},
#else
  {"%mrp",   31},
#endif
  {"%pcoq",  18},
  {"%pcsq",  17},
  {"%pidr1",  8},
  {"%pidr2",  9},
  {"%pidr3", 12},
  {"%pidr4", 13},
  {"%ppda",  24},
  {"%r0",     0},
  {"%r1",     1},
  {"%r10",   10},
  {"%r11",   11},
  {"%r12",   12},
  {"%r13",   13},
  {"%r14",   14},
  {"%r15",   15},
  {"%r16",   16},
  {"%r17",   17},
  {"%r18",   18},
  {"%r19",   19},
  {"%r2",     2},
  {"%r20",   20},
  {"%r21",   21},
  {"%r22",   22},
  {"%r23",   23},
  {"%r24",   24},
  {"%r25",   25},
  {"%r26",   26},
  {"%r27",   27},
  {"%r28",   28},
  {"%r29",   29},
  {"%r3",     3},
  {"%r30",   30},
  {"%r31",   31},
  {"%r4",     4},
  {"%r5",     5},
  {"%r6",     6},
  {"%r7",     7},
  {"%r8",     8},
  {"%r9",     9},
  {"%rctr",   0},
  {"%ret0",  28},
  {"%ret1",  29},
  {"%rp",     2},
  {"%sar",   11},
  {"%sp",    30},
  {"%sr0",    0},
  {"%sr1",    1},
  {"%sr2",    2},
  {"%sr3",    3},
  {"%sr4",    4},
  {"%sr5",    5},
  {"%sr6",    6},
  {"%sr7",    7},
  {"%t1",    22},
  {"%t2",    21},
  {"%t3",    20},
  {"%t4",    19},
  {"%tf1",   11},
  {"%tf2",   10},
  {"%tf3",    9},
  {"%tf4",    8},
  {"%tr0",   24},
  {"%tr1",   25},
  {"%tr2",   26},
  {"%tr3",   27},
  {"%tr4",   28},
  {"%tr5",   29},
  {"%tr6",   30},
  {"%tr7",   31}
};

/* This table is sorted by order of the length of the string. This is
   so we check for <> before we check for <. If we had a <> and checked
   for < first, we would get a false match.  */
static const struct fp_cond_map fp_cond_map[] =
{
  {"false?", 0},
  {"false", 1},
  {"true?", 30},
  {"true", 31},
  {"!<=>", 3},
  {"!?>=", 8},
  {"!?<=", 16},
  {"!<>", 7},
  {"!>=", 11},
  {"!?>", 12},
  {"?<=", 14},
  {"!<=", 19},
  {"!?<", 20},
  {"?>=", 22},
  {"!?=", 24},
  {"!=t", 27},
  {"<=>", 29},
  {"=t", 5},
  {"?=", 6},
  {"?<", 10},
  {"<=", 13},
  {"!>", 15},
  {"?>", 18},
  {">=", 21},
  {"!<", 23},
  {"<>", 25},
  {"!=", 26},
  {"!?", 28},
  {"?", 2},
  {"=", 4},
  {"<", 9},
  {">", 17}
};

static const struct selector_entry selector_table[] =
{
  {"f", e_fsel},
  {"l", e_lsel},
  {"ld", e_ldsel},
  {"lp", e_lpsel},
  {"lr", e_lrsel},
  {"ls", e_lssel},
  {"lt", e_ltsel},
  {"ltp", e_ltpsel},
  {"n", e_nsel},
  {"nl", e_nlsel},
  {"nlr", e_nlrsel},
  {"p", e_psel},
  {"r", e_rsel},
  {"rd", e_rdsel},
  {"rp", e_rpsel},
  {"rr", e_rrsel},
  {"rs", e_rssel},
  {"rt", e_rtsel},
  {"rtp", e_rtpsel},
  {"t", e_tsel},
};

#ifdef OBJ_SOM
/* default space and subspace dictionaries */

#define GDB_SYMBOLS          GDB_SYMBOLS_SUBSPACE_NAME
#define GDB_STRINGS          GDB_STRINGS_SUBSPACE_NAME

/* pre-defined subsegments (subspaces) for the HPPA.  */
#define SUBSEG_CODE   0
#define SUBSEG_LIT    1
#define SUBSEG_MILLI  2
#define SUBSEG_DATA   0
#define SUBSEG_BSS    2
#define SUBSEG_UNWIND 3
#define SUBSEG_GDB_STRINGS 0
#define SUBSEG_GDB_SYMBOLS 1

static struct default_subspace_dict pa_def_subspaces[] =
{
  {"$CODE$", 1, 1, 1, 0, 0, 0, 24, 0x2c, 0, 8, 0, 0, SUBSEG_CODE},
  {"$DATA$", 1, 1, 0, 0, 0, 0, 24, 0x1f, 1, 8, 1, 1, SUBSEG_DATA},
  {"$LIT$", 1, 1, 0, 0, 0, 0, 16, 0x2c, 0, 8, 0, 0, SUBSEG_LIT},
  {"$MILLICODE$", 1, 1, 0, 0, 0, 0, 8, 0x2c, 0, 8, 0, 0, SUBSEG_MILLI},
  {"$BSS$", 1, 1, 0, 0, 0, 1, 80, 0x1f, 1, 8, 1, 1, SUBSEG_BSS},
  {NULL, 0, 1, 0, 0, 0, 0, 255, 0x1f, 0, 4, 0, 0, 0}
};

static struct default_space_dict pa_def_spaces[] =
{
  {"$TEXT$", 0, 1, 1, 0, 8, ASEC_NULL},
  {"$PRIVATE$", 1, 1, 1, 1, 16, ASEC_NULL},
  {NULL, 0, 0, 0, 0, 0, ASEC_NULL}
};

/* Misc local definitions used by the assembler.  */

/* These macros are used to maintain spaces/subspaces.  */
#define SPACE_DEFINED(space_chain)	(space_chain)->sd_defined
#define SPACE_USER_DEFINED(space_chain) (space_chain)->sd_user_defined
#define SPACE_SPNUM(space_chain)	(space_chain)->sd_spnum
#define SPACE_NAME(space_chain)		(space_chain)->sd_name

#define SUBSPACE_DEFINED(ss_chain)	(ss_chain)->ssd_defined
#define SUBSPACE_NAME(ss_chain)		(ss_chain)->ssd_name
#endif

/* Return nonzero if the string pointed to by S potentially represents
   a right or left half of a FP register  */
#define IS_R_SELECT(S)   (*(S) == 'R' || *(S) == 'r')
#define IS_L_SELECT(S)   (*(S) == 'L' || *(S) == 'l')

/* Insert FIELD into OPCODE starting at bit START.  Continue pa_ip
   main loop after insertion.  */

#define INSERT_FIELD_AND_CONTINUE(OPCODE, FIELD, START) \
  { \
    ((OPCODE) |= (FIELD) << (START)); \
    continue; \
  }

/* Simple range checking for FIELD against HIGH and LOW bounds.
   IGNORE is used to suppress the error message.  */

#define CHECK_FIELD(FIELD, HIGH, LOW, IGNORE) \
  { \
    if ((FIELD) > (HIGH) || (FIELD) < (LOW)) \
      { \
	if (! IGNORE) \
          as_bad (_("Field out of range [%d..%d] (%d)."), (LOW), (HIGH), \
		  (int) (FIELD));\
        break; \
      } \
  }

/* Variant of CHECK_FIELD for use in md_apply_fix3 and other places where
   the current file and line number are not valid.  */

#define CHECK_FIELD_WHERE(FIELD, HIGH, LOW, FILENAME, LINE) \
  { \
    if ((FIELD) > (HIGH) || (FIELD) < (LOW)) \
      { \
        as_bad_where ((FILENAME), (LINE), \
		      _("Field out of range [%d..%d] (%d)."), (LOW), (HIGH), \
		      (int) (FIELD));\
        break; \
      } \
  }

/* Simple alignment checking for FIELD against ALIGN (a power of two).
   IGNORE is used to suppress the error message.  */

#define CHECK_ALIGN(FIELD, ALIGN, IGNORE) \
  { \
    if ((FIELD) & ((ALIGN) - 1)) \
      { \
	if (! IGNORE) \
          as_bad (_("Field not properly aligned [%d] (%d)."), (ALIGN), \
		  (int) (FIELD));\
        break; \
      } \
  }

#define is_DP_relative(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$global$") == 0)

#define is_PC_relative(exp)			\
  ((exp).X_op == O_subtract			\
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$PIC_pcrel$0") == 0)

/* We need some complex handling for stabs (sym1 - sym2).  Luckily, we'll
   always be able to reduce the expression to a constant, so we don't
   need real complex handling yet.  */
#define is_complex(exp)				\
  ((exp).X_op != O_constant && (exp).X_op != O_symbol)

/* Actual functions to implement the PA specific code for the assembler.  */

/* Called before writing the object file.  Make sure entry/exit and
   proc/procend pairs match.  */

void
pa_check_eof ()
{
  if (within_entry_exit)
    as_fatal (_("Missing .exit\n"));

  if (within_procedure)
    as_fatal (_("Missing .procend\n"));
}

/* Returns a pointer to the label_symbol_struct for the current space.
   or NULL if no label_symbol_struct exists for the current space.  */

static label_symbol_struct *
pa_get_label ()
{
  label_symbol_struct *label_chain;

  for (label_chain = label_symbols_rootp;
       label_chain;
       label_chain = label_chain->lss_next)
    {
#ifdef OBJ_SOM
    if (current_space == label_chain->lss_space && label_chain->lss_label)
      return label_chain;
#endif
#ifdef OBJ_ELF
    if (now_seg == label_chain->lss_segment && label_chain->lss_label)
      return label_chain;
#endif
    }

  return NULL;
}

/* Defines a label for the current space.  If one is already defined,
   this function will replace it with the new label.  */

void
pa_define_label (symbol)
     symbolS *symbol;
{
  label_symbol_struct *label_chain = pa_get_label ();

  if (label_chain)
    label_chain->lss_label = symbol;
  else
    {
      /* Create a new label entry and add it to the head of the chain.  */
      label_chain
	= (label_symbol_struct *) xmalloc (sizeof (label_symbol_struct));
      label_chain->lss_label = symbol;
#ifdef OBJ_SOM
      label_chain->lss_space = current_space;
#endif
#ifdef OBJ_ELF
      label_chain->lss_segment = now_seg;
#endif
      label_chain->lss_next = NULL;

      if (label_symbols_rootp)
	label_chain->lss_next = label_symbols_rootp;

      label_symbols_rootp = label_chain;
    }
}

/* Removes a label definition for the current space.
   If there is no label_symbol_struct entry, then no action is taken.  */

static void
pa_undefine_label ()
{
  label_symbol_struct *label_chain;
  label_symbol_struct *prev_label_chain = NULL;

  for (label_chain = label_symbols_rootp;
       label_chain;
       label_chain = label_chain->lss_next)
    {
      if (1
#ifdef OBJ_SOM
	  && current_space == label_chain->lss_space && label_chain->lss_label
#endif
#ifdef OBJ_ELF
	  && now_seg == label_chain->lss_segment && label_chain->lss_label
#endif
	  )
	{
	  /* Remove the label from the chain and free its memory.  */
	  if (prev_label_chain)
	    prev_label_chain->lss_next = label_chain->lss_next;
	  else
	    label_symbols_rootp = label_chain->lss_next;

	  free (label_chain);
	  break;
	}
      prev_label_chain = label_chain;
    }
}

/* An HPPA-specific version of fix_new.  This is required because the HPPA
   code needs to keep track of some extra stuff.  Each call to fix_new_hppa
   results in the creation of an instance of an hppa_fix_struct.  An
   hppa_fix_struct stores the extra information along with a pointer to the
   original fixS.  This is attached to the original fixup via the
   tc_fix_data field.  */

static void
fix_new_hppa (frag, where, size, add_symbol, offset, exp, pcrel,
	      r_type, r_field, r_format, arg_reloc, unwind_bits)
     fragS *frag;
     int where;
     int size;
     symbolS *add_symbol;
     offsetT offset;
     expressionS *exp;
     int pcrel;
     bfd_reloc_code_real_type r_type;
     enum hppa_reloc_field_selector_type_alt r_field;
     int r_format;
     unsigned int arg_reloc;
     int unwind_bits ATTRIBUTE_UNUSED;
{
  fixS *new_fix;

  struct hppa_fix_struct *hppa_fix = (struct hppa_fix_struct *)
  obstack_alloc (&notes, sizeof (struct hppa_fix_struct));

  if (exp != NULL)
    new_fix = fix_new_exp (frag, where, size, exp, pcrel, r_type);
  else
    new_fix = fix_new (frag, where, size, add_symbol, offset, pcrel, r_type);
  new_fix->tc_fix_data = (void *) hppa_fix;
  hppa_fix->fx_r_type = r_type;
  hppa_fix->fx_r_field = r_field;
  hppa_fix->fx_r_format = r_format;
  hppa_fix->fx_arg_reloc = arg_reloc;
  hppa_fix->segment = now_seg;
#ifdef OBJ_SOM
  if (r_type == R_ENTRY || r_type == R_EXIT)
    new_fix->fx_offset = unwind_bits;
#endif

  /* foo-$global$ is used to access non-automatic storage.  $global$
     is really just a marker and has served its purpose, so eliminate
     it now so as not to confuse write.c.  Ditto for $PIC_pcrel$0.  */
  if (new_fix->fx_subsy
      && (strcmp (S_GET_NAME (new_fix->fx_subsy), "$global$") == 0
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$PIC_pcrel$0") == 0))
    new_fix->fx_subsy = NULL;
}

/* Parse a .byte, .word, .long expression for the HPPA.  Called by
   cons via the TC_PARSE_CONS_EXPRESSION macro.  */

void
parse_cons_expression_hppa (exp)
     expressionS *exp;
{
  hppa_field_selector = pa_chk_field_selector (&input_line_pointer);
  expression (exp);
}

/* This fix_new is called by cons via TC_CONS_FIX_NEW.
   hppa_field_selector is set by the parse_cons_expression_hppa.  */

void
cons_fix_new_hppa (frag, where, size, exp)
     fragS *frag;
     int where;
     int size;
     expressionS *exp;
{
  unsigned int rel_type;

  /* Get a base relocation type.  */
  if (is_DP_relative (*exp))
    rel_type = R_HPPA_GOTOFF;
  else if (is_PC_relative (*exp))
    rel_type = R_HPPA_PCREL_CALL;
  else if (is_complex (*exp))
    rel_type = R_HPPA_COMPLEX;
  else
    rel_type = R_HPPA;

  if (hppa_field_selector != e_psel && hppa_field_selector != e_fsel)
    {
      as_warn (_("Invalid field selector.  Assuming F%%."));
      hppa_field_selector = e_fsel;
    }

  fix_new_hppa (frag, where, size,
		(symbolS *) NULL, (offsetT) 0, exp, 0, rel_type,
		hppa_field_selector, size * 8, 0, 0);

  /* Reset field selector to its default state.  */
  hppa_field_selector = 0;
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will need.  */

void
md_begin ()
{
  const char *retval = NULL;
  int lose = 0;
  unsigned int i = 0;

  last_call_info = NULL;
  call_info_root = NULL;

  /* Set the default machine type.  */
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, DEFAULT_LEVEL))
    as_warn (_("could not set architecture and machine"));

  /* Folding of text and data segments fails miserably on the PA.
     Warn user and disable "-R" option.  */
  if (flag_readonly_data_in_text)
    {
      as_warn (_("-R option not supported on this target."));
      flag_readonly_data_in_text = 0;
    }

#ifdef OBJ_SOM
  pa_spaces_begin ();
#endif

  op_hash = hash_new ();

  while (i < NUMOPCODES)
    {
      const char *name = pa_opcodes[i].name;
      retval = hash_insert (op_hash, name, (struct pa_opcode *) &pa_opcodes[i]);
      if (retval != NULL && *retval != '\0')
	{
	  as_fatal (_("Internal error: can't hash `%s': %s\n"), name, retval);
	  lose = 1;
	}
      do
	{
	  if ((pa_opcodes[i].match & pa_opcodes[i].mask)
	      != pa_opcodes[i].match)
	    {
	      fprintf (stderr, _("internal error: losing opcode: `%s' \"%s\"\n"),
		       pa_opcodes[i].name, pa_opcodes[i].args);
	      lose = 1;
	    }
	  ++i;
	}
      while (i < NUMOPCODES && !strcmp (pa_opcodes[i].name, name));
    }

  if (lose)
    as_fatal (_("Broken assembler.  No assembly attempted."));

#ifdef OBJ_SOM
  /* SOM will change text_section.  To make sure we never put
     anything into the old one switch to the new one now.  */
  subseg_set (text_section, 0);
#endif

#ifdef OBJ_SOM
  dummy_symbol = symbol_find_or_make ("L$dummy");
  S_SET_SEGMENT (dummy_symbol, text_section);
  /* Force the symbol to be converted to a real symbol.  */
  (void) symbol_get_bfdsym (dummy_symbol);
#endif
}

/* Assemble a single instruction storing it into a frag.  */
void
md_assemble (str)
     char *str;
{
  char *to;

  /* The had better be something to assemble.  */
  assert (str);

  /* If we are within a procedure definition, make sure we've
     defined a label for the procedure; handle case where the
     label was defined after the .PROC directive.

     Note there's not need to diddle with the segment or fragment
     for the label symbol in this case.  We have already switched
     into the new $CODE$ subspace at this point.  */
  if (within_procedure && last_call_info->start_symbol == NULL)
    {
      label_symbol_struct *label_symbol = pa_get_label ();

      if (label_symbol)
	{
	  if (label_symbol->lss_label)
	    {
	      last_call_info->start_symbol = label_symbol->lss_label;
	      symbol_get_bfdsym (label_symbol->lss_label)->flags
		|= BSF_FUNCTION;
#ifdef OBJ_SOM
	      /* Also handle allocation of a fixup to hold the unwind
		 information when the label appears after the proc/procend.  */
	      if (within_entry_exit)
		{
		  char *where;
		  unsigned int u;

		  where = frag_more (0);
		  u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
		  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
				NULL, (offsetT) 0, NULL,
				0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
		}
#endif
	    }
	  else
	    as_bad (_("Missing function name for .PROC (corrupted label chain)"));
	}
      else
	as_bad (_("Missing function name for .PROC"));
    }

  /* Assemble the instruction.  Results are saved into "the_insn".  */
  pa_ip (str);

  /* Get somewhere to put the assembled instruction.  */
  to = frag_more (4);

  /* Output the opcode.  */
  md_number_to_chars (to, the_insn.opcode, 4);

  /* If necessary output more stuff.  */
  if (the_insn.reloc != R_HPPA_NONE)
    fix_new_hppa (frag_now, (to - frag_now->fr_literal), 4, NULL,
		  (offsetT) 0, &the_insn.exp, the_insn.pcrel,
		  the_insn.reloc, the_insn.field_selector,
		  the_insn.format, the_insn.arg_reloc, 0);

#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif
}

/* Do the real work for assembling a single instruction.  Store results
   into the global "the_insn" variable.  */

static void
pa_ip (str)
     char *str;
{
  char *error_message = "";
  char *s, c, *argstart, *name, *save_s;
  const char *args;
  int match = FALSE;
  int comma = 0;
  int cmpltr, nullif, flag, cond, num;
  unsigned long opcode;
  struct pa_opcode *insn;

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  /* Convert everything up to the first whitespace character into lower
     case.  */
  for (s = str; *s != ' ' && *s != '\t' && *s != '\n' && *s != '\0'; s++)
    *s = TOLOWER (*s);

  /* Skip to something interesting.  */
  for (s = str;
       ISUPPER (*s) || ISLOWER (*s) || (*s >= '0' && *s <= '3');
       ++s)
    ;

  switch (*s)
    {

    case '\0':
      break;

    case ',':
      comma = 1;

      /*FALLTHROUGH */

    case ' ':
      *s++ = '\0';
      break;

    default:
      as_fatal (_("Unknown opcode: `%s'"), str);
    }

  /* Look up the opcode in the has table.  */
  if ((insn = (struct pa_opcode *) hash_find (op_hash, str)) == NULL)
    {
      as_bad ("Unknown opcode: `%s'", str);
      return;
    }

  if (comma)
    {
      *--s = ',';
    }

  /* Mark the location where arguments for the instruction start, then
     start processing them.  */
  argstart = s;
  for (;;)
    {
      /* Do some initialization.  */
      opcode = insn->match;
      strict = (insn->flags & FLAG_STRICT);
      memset (&the_insn, 0, sizeof (the_insn));

      the_insn.reloc = R_HPPA_NONE;

      /* If this instruction is specific to a particular architecture,
	 then set a new architecture.  */
      /* But do not automatically promote to pa2.0.  The automatic promotion
	 crud is for compatibility with HP's old assemblers only.  */
      if (insn->arch < 20
	  && bfd_get_mach (stdoutput) < insn->arch)
	{
	  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, insn->arch))
	    as_warn (_("could not update architecture and machine"));
	}
      else if (bfd_get_mach (stdoutput) < insn->arch)
	{
	  match = FALSE;
	  goto failed;
	}

      /* Build the opcode, checking as we go to make
         sure that the operands match.  */
      for (args = insn->args;; ++args)
	{
	  /* Absorb white space in instruction.  */
	  while (*s == ' ' || *s == '\t')
	    s++;

	  switch (*args)
	    {

	    /* End of arguments.  */
	    case '\0':
	      if (*s == '\0')
		match = TRUE;
	      break;

	    case '+':
	      if (*s == '+')
		{
		  ++s;
		  continue;
		}
	      if (*s == '-')
		continue;
	      break;

	    /* These must match exactly.  */
	    case '(':
	    case ')':
	    case ',':
	    case ' ':
	      if (*s++ == *args)
		continue;
	      break;

	    /* Handle a 5 bit register or control register field at 10.  */
	    case 'b':
	    case '^':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);

	    /* Handle %sar or %cr11.  No bits get set, we just verify that it
	       is there.  */
	    case '!':
	      /* Skip whitespace before register.  */
	      while (*s == ' ' || *s == '\t')
		s = s + 1;

	      if (!strncasecmp (s, "%sar", 4))
	        {
		  s += 4;
		  continue;
		}
	      else if (!strncasecmp (s, "%cr11", 5))
	        {
		  s += 5;
		  continue;
		}
	      break;

	    /* Handle a 5 bit register field at 15.  */
	    case 'x':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

	    /* Handle a 5 bit register field at 31.  */
	    case 't':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 5 bit register field at 10 and 15.  */
	    case 'a':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 31, 0, 0);
	      opcode |= num << 16;
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);

	    /* Handle a 5 bit field length at 31.  */
	    case 'T':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 32, 1, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, 32 - num, 0);

	    /* Handle a 5 bit immediate at 15.  */
	    case '5':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      /* When in strict mode, we want to just reject this
		 match instead of giving an out of range error.  */
	      CHECK_FIELD (num, 15, -16, strict);
	      num = low_sign_unext (num, 5);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

	    /* Handle a 5 bit immediate at 31.  */
	    case 'V':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      /* When in strict mode, we want to just reject this
		 match instead of giving an out of range error.  */
	      CHECK_FIELD (num, 15, -16, strict);
	      num = low_sign_unext (num, 5);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle an unsigned 5 bit immediate at 31.  */
	    case 'r':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle an unsigned 5 bit immediate at 15.  */
	    case 'R':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

	    /* Handle an unsigned 10 bit immediate at 15.  */
	    case 'U':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1023, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

	    /* Handle a 2 bit space identifier at 17.  */
	    case 's':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 3, 0, 1);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 14);

	    /* Handle a 3 bit space identifier at 18.  */
	    case 'S':
	      if (!pa_parse_number (&s, 0))
		break;
	      num = pa_number;
	      CHECK_FIELD (num, 7, 0, 1);
	      opcode |= re_assemble_3 (num);
	      continue;

	    /* Handle all completers.  */
	    case 'c':
	      switch (*++args)
		{

		/* Handle a completer for an indexing load or store.  */
		case 'X':
		case 'x':
		  {
		    int uu = 0;
		    int m = 0;
		    int i = 0;
		    while (*s == ',' && i < 2)
		      {
			s++;
			if (strncasecmp (s, "sm", 2) == 0)
			  {
			    uu = 1;
			    m = 1;
			    s++;
			    i++;
			  }
			else if (strncasecmp (s, "m", 1) == 0)
			  m = 1;
			else if ((strncasecmp (s, "s ", 2) == 0)
				 || (strncasecmp (s, "s,", 2) == 0))
			  uu = 1;
			/* When in strict mode this is a match failure.  */
			else if (strict)
			  {
			    s--;
			    break;
			  }
			else
			  as_bad (_("Invalid Indexed Load Completer."));
			s++;
			i++;
		      }
		    if (i > 2)
		      as_bad (_("Invalid Indexed Load Completer Syntax."));
		    opcode |= m << 5;
		    INSERT_FIELD_AND_CONTINUE (opcode, uu, 13);
		  }

		/* Handle a short load/store completer.  */
		case 'M':
		case 'm':
		case 'q':
		case 'J':
		case 'e':
		  {
		    int a = 0;
		    int m = 0;
		    if (*s == ',')
		      {
			int found = 0;
			s++;
			if (strncasecmp (s, "ma", 2) == 0)
			  {
			    a = 0;
			    m = 1;
			    found = 1;
			  }
			else if (strncasecmp (s, "mb", 2) == 0)
			  {
			    a = 1;
			    m = 1;
			    found = 1;
			  }

			/* When in strict mode, pass through for cache op.  */
			if (!found && strict)
			  s--;
			else
			  {
			    if (!found)
			      as_bad (_("Invalid Short Load/Store Completer."));
			    s += 2;
			  }
		      }
		    /* If we did not get a ma/mb completer, then we do not
		       consider this a positive match for 'ce'.  */
		    else if (*args == 'e')
		      break;

		   /* 'J', 'm', 'M' and 'q' are the same, except for where they
		       encode the before/after field.  */
		   if (*args == 'm' || *args == 'M')
		      {
			opcode |= m << 5;
			INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
		      }
		    else if (*args == 'q')
		      {
			opcode |= m << 3;
			INSERT_FIELD_AND_CONTINUE (opcode, a, 2);
		      }
		    else if (*args == 'J')
		      {
		        /* M bit is explicit in the major opcode.  */
			INSERT_FIELD_AND_CONTINUE (opcode, a, 2);
		      }
		    else if (*args == 'e')
		      {
			/* Stash the ma/mb flag temporarily in the
			   instruction.  We will use (and remove it)
			   later when handling 'J', 'K', '<' & '>'.  */
			opcode |= a;
			continue;
		      }
		  }

		/* Handle a stbys completer.  */
		case 'A':
		case 's':
		  {
		    int a = 0;
		    int m = 0;
		    int i = 0;
		    while (*s == ',' && i < 2)
		      {
			s++;
			if (strncasecmp (s, "m", 1) == 0)
			  m = 1;
			else if ((strncasecmp (s, "b ", 2) == 0)
				 || (strncasecmp (s, "b,", 2) == 0))
			  a = 0;
			else if (strncasecmp (s, "e", 1) == 0)
			  a = 1;
			/* When in strict mode this is a match failure.  */
			else if (strict)
			  {
			    s--;
			    break;
			  }
			else
			  as_bad (_("Invalid Store Bytes Short Completer"));
			s++;
			i++;
		      }
		    if (i > 2)
		      as_bad (_("Invalid Store Bytes Short Completer"));
		    opcode |= m << 5;
		    INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
		  }

		/* Handle load cache hint completer.  */
		case 'c':
		  cmpltr = 0;
		  if (!strncmp (s, ",sl", 3))
		    {
		      s += 3;
		      cmpltr = 2;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);

		/* Handle store cache hint completer.  */
		case 'C':
		  cmpltr = 0;
		  if (!strncmp (s, ",sl", 3))
		    {
		      s += 3;
		      cmpltr = 2;
		    }
		  else if (!strncmp (s, ",bc", 3))
		    {
		      s += 3;
		      cmpltr = 1;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);

		/* Handle load and clear cache hint completer.  */
		case 'd':
		  cmpltr = 0;
		  if (!strncmp (s, ",co", 3))
		    {
		      s += 3;
		      cmpltr = 1;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);

		/* Handle load ordering completer.  */
		case 'o':
		  if (strncmp (s, ",o", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle a branch gate completer.  */
		case 'g':
		  if (strncasecmp (s, ",gate", 5) != 0)
		    break;
		  s += 5;
		  continue;

		/* Handle a branch link and push completer.  */
		case 'p':
		  if (strncasecmp (s, ",l,push", 7) != 0)
		    break;
		  s += 7;
		  continue;

		/* Handle a branch link completer.  */
		case 'l':
		  if (strncasecmp (s, ",l", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle a branch pop completer.  */
		case 'P':
		  if (strncasecmp (s, ",pop", 4) != 0)
		    break;
		  s += 4;
		  continue;

		/* Handle a local processor completer.  */
		case 'L':
		  if (strncasecmp (s, ",l", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle a PROBE read/write completer.  */
		case 'w':
		  flag = 0;
		  if (!strncasecmp (s, ",w", 2))
		    {
		      flag = 1;
		      s += 2;
		    }
		  else if (!strncasecmp (s, ",r", 2))
		    {
		      flag = 0;
		      s += 2;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);

		/* Handle MFCTL wide completer.  */
		case 'W':
		  if (strncasecmp (s, ",w", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle an RFI restore completer.  */
		case 'r':
		  flag = 0;
		  if (!strncasecmp (s, ",r", 2))
		    {
		      flag = 5;
		      s += 2;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);

		/* Handle a system control completer.  */
		case 'Z':
		  if (*s == ',' && (*(s + 1) == 'm' || *(s + 1) == 'M'))
		    {
		      flag = 1;
		      s += 2;
		    }
		  else
		    flag = 0;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);

		/* Handle intermediate/final completer for DCOR.  */
		case 'i':
		  flag = 0;
		  if (!strncasecmp (s, ",i", 2))
		    {
		      flag = 1;
		      s += 2;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);

		/* Handle zero/sign extension completer.  */
		case 'z':
		  flag = 1;
		  if (!strncasecmp (s, ",z", 2))
		    {
		      flag = 0;
		      s += 2;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 10);

		/* Handle add completer.  */
		case 'a':
		  flag = 1;
		  if (!strncasecmp (s, ",l", 2))
		    {
		      flag = 2;
		      s += 2;
		    }
		  else if (!strncasecmp (s, ",tsv", 4))
		    {
		      flag = 3;
		      s += 4;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 10);

		/* Handle 64 bit carry for ADD.  */
		case 'Y':
		  flag = 0;
		  if (!strncasecmp (s, ",dc,tsv", 7) ||
		      !strncasecmp (s, ",tsv,dc", 7))
		    {
		      flag = 1;
		      s += 7;
		    }
		  else if (!strncasecmp (s, ",dc", 3))
		    {
		      flag = 0;
		      s += 3;
		    }
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle 32 bit carry for ADD.  */
		case 'y':
		  flag = 0;
		  if (!strncasecmp (s, ",c,tsv", 6) ||
		      !strncasecmp (s, ",tsv,c", 6))
		    {
		      flag = 1;
		      s += 6;
		    }
		  else if (!strncasecmp (s, ",c", 2))
		    {
		      flag = 0;
		      s += 2;
		    }
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle trap on signed overflow.  */
		case 'v':
		  flag = 0;
		  if (!strncasecmp (s, ",tsv", 4))
		    {
		      flag = 1;
		      s += 4;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle trap on condition and overflow.  */
		case 't':
		  flag = 0;
		  if (!strncasecmp (s, ",tc,tsv", 7) ||
		      !strncasecmp (s, ",tsv,tc", 7))
		    {
		      flag = 1;
		      s += 7;
		    }
		  else if (!strncasecmp (s, ",tc", 3))
		    {
		      flag = 0;
		      s += 3;
		    }
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle 64 bit borrow for SUB.  */
		case 'B':
		  flag = 0;
		  if (!strncasecmp (s, ",db,tsv", 7) ||
		      !strncasecmp (s, ",tsv,db", 7))
		    {
		      flag = 1;
		      s += 7;
		    }
		  else if (!strncasecmp (s, ",db", 3))
		    {
		      flag = 0;
		      s += 3;
		    }
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle 32 bit borrow for SUB.  */
		case 'b':
		  flag = 0;
		  if (!strncasecmp (s, ",b,tsv", 6) ||
		      !strncasecmp (s, ",tsv,b", 6))
		    {
		      flag = 1;
		      s += 6;
		    }
		  else if (!strncasecmp (s, ",b", 2))
		    {
		      flag = 0;
		      s += 2;
		    }
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle trap condition completer for UADDCM.  */
		case 'T':
		  flag = 0;
		  if (!strncasecmp (s, ",tc", 3))
		    {
		      flag = 1;
		      s += 3;
		    }

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);

		/* Handle signed/unsigned at 21.  */
		case 'S':
		  {
		    int sign = 1;
		    if (strncasecmp (s, ",s", 2) == 0)
		      {
			sign = 1;
			s += 2;
		      }
		    else if (strncasecmp (s, ",u", 2) == 0)
		      {
			sign = 0;
			s += 2;
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, sign, 10);
		  }

		/* Handle left/right combination at 17:18.  */
		case 'h':
		  if (*s++ == ',')
		    {
		      int lr = 0;
		      if (*s == 'r')
			lr = 2;
		      else if (*s == 'l')
			lr = 0;
		      else
			as_bad (_("Invalid left/right combination completer"));

		      s++;
		      INSERT_FIELD_AND_CONTINUE (opcode, lr, 13);
		    }
		  else
		    as_bad (_("Invalid left/right combination completer"));
		  break;

		/* Handle saturation at 24:25.  */
		case 'H':
		  {
		    int sat = 3;
		    if (strncasecmp (s, ",ss", 3) == 0)
		      {
			sat = 1;
			s += 3;
		      }
		    else if (strncasecmp (s, ",us", 3) == 0)
		      {
			sat = 0;
			s += 3;
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, sat, 6);
		  }

		/* Handle permutation completer.  */
		case '*':
		  if (*s++ == ',')
		    {
		      int permloc[4];
		      int perm = 0;
		      int i = 0;
		      permloc[0] = 13;
		      permloc[1] = 10;
		      permloc[2] = 8;
		      permloc[3] = 6;
		      for (; i < 4; i++)
		        {
			  switch (*s++)
			    {
			    case '0':
			      perm = 0;
			      break;
			    case '1':
			      perm = 1;
			      break;
			    case '2':
			      perm = 2;
			      break;
			    case '3':
			      perm = 3;
			      break;
			    default:
			      as_bad (_("Invalid permutation completer"));
			    }
			  opcode |= perm << permloc[i];
			}
		      continue;
		    }
		  else
		    as_bad (_("Invalid permutation completer"));
		  break;

		default:
		  abort ();
		}
	      break;

	    /* Handle all conditions.  */
	    case '?':
	      {
		args++;
		switch (*args)
		  {
		  /* Handle FP compare conditions.  */
		  case 'f':
		    cond = pa_parse_fp_cmp_cond (&s);
		    INSERT_FIELD_AND_CONTINUE (opcode, cond, 0);

		  /* Handle an add condition.  */
		  case 'A':
		  case 'a':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'A')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "nuv") == 0)
			  cmpltr = 4;
			else if (strcasecmp (name, "znv") == 0)
			  cmpltr = 5;
			else if (strcasecmp (name, "sv") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, "uv") == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			  }
			else if (strcasecmp (name, "vnz") == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			  }
			else if (strcasecmp (name, "nsv") == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args == 'a' || *name)
			  as_bad (_("Invalid Add Condition: %s"), name);
			*s = c;
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  /* Handle non-negated add and branch condition.  */
		  case 'd':
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Add and Branch Condition"));
			cmpltr = 0;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle 64 bit wide-mode add and branch condition.  */
		  case 'W':
		    cmpltr = pa_parse_addb_64_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Add and Branch Condition"));
			cmpltr = 0;
		      }
		    else
		      {
			/* Negated condition requires an opcode change.  */
			opcode |= (cmpltr & 8) << 24;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr & 7, 13);

		  /* Handle a negated or non-negated add and branch
		     condition.  */
		  case '@@':
		    save_s = s;
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			s = save_s;
			cmpltr = pa_parse_neg_add_cmpltr (&s);
			if (cmpltr < 0)
			  {
			    as_bad (_("Invalid Compare/Subtract Condition"));
			    cmpltr = 0;
			  }
			else
			  {
			    /* Negated condition requires an opcode change.  */
			    opcode |= 1 << 27;
			  }
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle branch on bit conditions.  */
		  case 'B':
		  case 'b':
		    cmpltr = 0;
		    if (*s == ',')
		      {
			s++;

			if (*args == 'B')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			if (strncmp (s, "<", 1) == 0)
			  {
			    cmpltr = 0;
			    s++;
			  }
			else if (strncmp (s, ">=", 2) == 0)
			  {
			    cmpltr = 1;
			    s += 2;
			  }
			else
			  as_bad (_("Invalid Bit Branch Condition: %c"), *s);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 15);

		  /* Handle a compare/subtract condition.  */
		  case 'S':
		  case 's':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'S')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "<<") == 0)
			  cmpltr = 4;
			else if (strcasecmp (name, "<<=") == 0)
			  cmpltr = 5;
			else if (strcasecmp (name, "sv") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, ">>=") == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			  }
			else if (strcasecmp (name, ">>") == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			  }
			else if (strcasecmp (name, "nsv") == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'S' || *name)
			  as_bad (_("Invalid Compare/Subtract Condition: %s"),
				  name);
			*s = c;
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  /* Handle a non-negated compare condition.  */
		  case 't':
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Compare/Subtract Condition"));
			cmpltr = 0;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a 32 bit compare and branch condition.  */
		  case 'n':
		    save_s = s;
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			s = save_s;
			cmpltr = pa_parse_neg_cmpsub_cmpltr (&s);
			if (cmpltr < 0)
			  {
			    as_bad (_("Invalid Compare and Branch Condition"));
			    cmpltr = 0;
			  }
			else
			  {
			    /* Negated condition requires an opcode change.  */
			    opcode |= 1 << 27;
			  }
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a 64 bit compare and branch condition.  */
		  case 'N':
		    cmpltr = pa_parse_cmpb_64_cmpltr (&s);
		    if (cmpltr >= 0)
		      {
			/* Negated condition requires an opcode change.  */
			opcode |= (cmpltr & 8) << 26;
		      }
		    else
		      /* Not a 64 bit cond.  Give 32 bit a chance.  */
		      break;

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr & 7, 13);

		  /* Handle a 64 bit cmpib condition.  */
		  case 'Q':
		    cmpltr = pa_parse_cmpib_64_cmpltr (&s);
		    if (cmpltr < 0)
		      /* Not a 64 bit cond.  Give 32 bit a chance.  */
		      break;

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		    /* Handle a logical instruction condition.  */
		  case 'L':
		  case 'l':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'L')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;

			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'L' || *name)
			  as_bad (_("Invalid Logical Instruction Condition."));
			*s = c;
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  /* Handle a shift/extract/deposit condition.  */
		  case 'X':
		  case 'x':
		  case 'y':
		    cmpltr = 0;
		    if (*s == ',')
		      {
			save_s = s++;

			/* 64 bit conditions.  */
			if (*args == 'X')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "tr") == 0)
			  cmpltr = 4;
			else if (strcmp (name, "<>") == 0)
			  cmpltr = 5;
			else if (strcmp (name, ">=") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "ev") == 0)
			  cmpltr = 7;
			/* Handle movb,n.  Put things back the way they were.
			   This includes moving s back to where it started.  */
			else if (strcasecmp (name, "n") == 0 && *args == 'y')
			  {
			    *s = c;
			    s = save_s;
			    continue;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'X' || *name)
			  as_bad (_("Invalid Shift/Extract/Deposit Condition."));
			*s = c;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a unit instruction condition.  */
		  case 'U':
		  case 'u':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'U')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			if (strncasecmp (s, "sbz", 3) == 0)
			  {
			    cmpltr = 2;
			    s += 3;
			  }
			else if (strncasecmp (s, "shz", 3) == 0)
			  {
			    cmpltr = 3;
			    s += 3;
			  }
			else if (strncasecmp (s, "sdc", 3) == 0)
			  {
			    cmpltr = 4;
			    s += 3;
			  }
			else if (strncasecmp (s, "sbc", 3) == 0)
			  {
			    cmpltr = 6;
			    s += 3;
			  }
			else if (strncasecmp (s, "shc", 3) == 0)
			  {
			    cmpltr = 7;
			    s += 3;
			  }
			else if (strncasecmp (s, "tr", 2) == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			    s += 2;
			  }
			else if (strncasecmp (s, "nbz", 3) == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nhz", 3) == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "ndc", 3) == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nbc", 3) == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nhc", 3) == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "swz", 3) == 0)
			  {
			    cmpltr = 1;
			    flag = 0;
			    s += 3;
			  }
			else if (strncasecmp (s, "swc", 3) == 0)
			  {
			    cmpltr = 5;
			    flag = 0;
			    s += 3;
			  }
			else if (strncasecmp (s, "nwz", 3) == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nwc", 3) == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			    s += 3;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'U' || (*s != ' ' && *s != '\t'))
			  as_bad (_("Invalid Unit Instruction Condition."));
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  default:
		    abort ();
		  }
		break;
	      }

	    /* Handle a nullification completer for branch instructions.  */
	    case 'n':
	      nullif = pa_parse_nullif (&s);
	      INSERT_FIELD_AND_CONTINUE (opcode, nullif, 1);

	    /* Handle a nullification completer for copr and spop insns.  */
	    case 'N':
	      nullif = pa_parse_nullif (&s);
	      INSERT_FIELD_AND_CONTINUE (opcode, nullif, 5);

	    /* Handle ,%r2 completer for new syntax branches.  */
	    case 'L':
	      if (*s == ',' && strncasecmp (s + 1, "%r2", 3) == 0)
		s += 4;
	      else if (*s == ',' && strncasecmp (s + 1, "%rp", 3) == 0)
		s += 4;
	      else
		break;
	      continue;

	    /* Handle 3 bit entry into the fp compare array.   Valid values
	       are 0..6 inclusive.  */
	    case 'h':
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 6, 0, 0);
		  num++;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
		}
	      else
		break;

	    /* Handle 3 bit entry into the fp compare array.   Valid values
	       are 0..6 inclusive.  */
	    case 'm':
	      get_expression (s);
	      if (the_insn.exp.X_op == O_constant)
		{
		  s = expr_end;
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 6, 0, 0);
		  num = (num + 1) ^ 1;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
		}
	      else
		break;

	    /* Handle graphics test completers for ftest */
	    case '=':
	      {
		num = pa_parse_ftest_gfx_completer (&s);
		INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
	      }

	    /* Handle a 11 bit immediate at 31.  */
	    case 'i':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 1023, -1024, 0);
		  num = low_sign_unext (num, 11);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 11;
		  continue;
		}

	    /* Handle a 14 bit immediate at 31.  */
	    case 'J':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;

		  /* XXX the completer stored away tidbits of information
		     for us to extract.  We need a cleaner way to do this.
		     Now that we have lots of letters again, it would be
		     good to rethink this.  */
		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb != (num < 0))
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;

	    /* Handle a 14 bit immediate at 31.  */
	    case 'K':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;

		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb == (num < 0))
		    break;
		  if (num % 4)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;

	    /* Handle a 16 bit immediate at 31.  */
	    case '<':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;

		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb != (num < 0))
		    break;
		  CHECK_FIELD (num, 32767, -32768, 0);
		  num = re_assemble_16 (num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;

	    /* Handle a 16 bit immediate at 31.  */
	    case '>':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;

		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb == (num < 0))
		    break;
		  if (num % 4)
		    break;
		  CHECK_FIELD (num, 32767, -32768, 0);
		  num = re_assemble_16 (num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;

	    /* Handle 14 bit immediate, shifted left three times.  */
	    case '#':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  if (num & 0x7)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  if (num < 0)
		    opcode |= 1;
		  num &= 0x1fff;
		  num >>= 3;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 4);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}
	      break;

	    /* Handle 14 bit immediate, shifted left twice.  */
	    case 'd':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  if (num & 0x3)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  if (num < 0)
		    opcode |= 1;
		  num &= 0x1fff;
		  num >>= 2;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 3);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a 14 bit immediate at 31.  */
	    case 'j':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 8191, -8192, 0);
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a 21 bit immediate at 31.  */
	    case 'k':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num >> 11, 1048575, -1048576, 0);
		  opcode |= re_assemble_21 (num);
		  continue;
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 21;
		  continue;
		}

	    /* Handle a 16 bit immediate at 31 (PA 2.0 wide mode only).  */
	    case 'l':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a word-aligned 16-bit imm. at 31 (PA2.0 wide).  */
	    case 'y':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  CHECK_ALIGN (num, 4, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a dword-aligned 16-bit imm. at 31 (PA2.0 wide).  */
	    case '&':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  CHECK_ALIGN (num, 8, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a 12 bit branch displacement.  */
	    case 'w':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  opcode |= re_assemble_12 (num >> 2);
		  continue;
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 12;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  s = expr_end;
		  continue;
		}

	    /* Handle a 17 bit branch displacement.  */
	    case 'W':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 262143, -262144, 0);
		  opcode |= re_assemble_17 (num >> 2);
		  continue;
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 17;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}

	    /* Handle a 22 bit branch displacement.  */
	    case 'X':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 8388607, -8388608, 0);
		  opcode |= re_assemble_22 (num >> 2);
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 22;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}

	    /* Handle an absolute 17 bit branch target.  */
	    case 'z':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 0;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      FAKE_LABEL_NAME))
		{
		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 262143, -262144, 0);
		  opcode |= re_assemble_17 (num >> 2);
		  continue;
		}
	      else
		{
		  the_insn.reloc = R_HPPA_ABS_CALL;
		  the_insn.format = 17;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}

	    /* Handle '%r1' implicit operand of addil instruction.  */
	    case 'Z':
	      if (*s == ',' && *(s + 1) == '%' && *(s + 3) == '1'
		  && (*(s + 2) == 'r' || *(s + 2) == 'R'))
		{
		  s += 4;
		  continue;
		}
	      else
	        break;

	    /* Handle '%sr0,%r31' implicit operand of be,l instruction.  */
	    case 'Y':
	      if (strncasecmp (s, "%sr0,%r31", 9) != 0)
		break;
	      s += 9;
	      continue;

	    /* Handle immediate value of 0 for ordered load/store instructions.  */
	    case '@@':
	      if (*s != '0')
		break;
	      s++;
	      continue;

	    /* Handle a 2 bit shift count at 25.  */
	    case '.':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 3, 1, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);

	    /* Handle a 4 bit shift count at 25.  */
	    case '*':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 15, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);

	    /* Handle a 5 bit shift count at 26.  */
	    case 'p':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, 31 - num, 5);

	    /* Handle a 6 bit shift count at 20,22:26.  */
	    case '~':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      num = 63 - num;
	      opcode |= (num & 0x20) << 6;
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 5);

	    /* Handle a 6 bit field length at 23,27:31.  */
	    case '%':
	      flag = 0;
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 64, 1, strict);
	      num--;
	      opcode |= (num & 0x20) << 3;
	      num = 31 - (num & 0x1f);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 6 bit field length at 19,27:31.  */
	    case '|':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 64, 1, strict);
	      num--;
	      opcode |= (num & 0x20) << 7;
	      num = 31 - (num & 0x1f);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 5 bit bit position at 26.  */
	    case 'P':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 5);

	    /* Handle a 6 bit bit position at 20,22:26.  */
	    case 'q':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      opcode |= (num & 0x20) << 6;
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 5);

	    /* Handle a 5 bit immediate at 10 with 'd' as the complement
	       of the high bit of the immediate.  */
	    case 'B':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      if (num & 0x20)
		;
	      else
		opcode |= (1 << 13);
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 21);

	    /* Handle a 5 bit immediate at 10.  */
	    case 'Q':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);

	    /* Handle a 9 bit immediate at 28.  */
	    case '$':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 511, 1, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 3);

	    /* Handle a 13 bit immediate at 18.  */
	    case 'A':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 8191, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 13);

	    /* Handle a 26 bit immediate at 31.  */
	    case 'D':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 67108863, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 3 bit SFU identifier at 25.  */
	    case 'v':
	      if (*s++ != ',')
		as_bad (_("Invalid SFU identifier"));
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 7, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);

	    /* Handle a 20 bit SOP field for spop0.  */
	    case 'O':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1048575, 0, strict);
	      num = (num & 0x1f) | ((num & 0x000fffe0) << 6);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 15bit SOP field for spop1.  */
	    case 'o':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 32767, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 11);

	    /* Handle a 10bit SOP field for spop3.  */
	    case '0':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1023, 0, strict);
	      num = (num & 0x1f) | ((num & 0x000003e0) << 6);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 15 bit SOP field for spop2.  */
	    case '1':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 32767, 0, strict);
	      num = (num & 0x1f) | ((num & 0x00007fe0) << 6);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 3-bit co-processor ID field.  */
	    case 'u':
	      if (*s++ != ',')
		as_bad (_("Invalid COPR identifier"));
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 7, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);

	    /* Handle a 22bit SOP field for copr.  */
	    case '2':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 4194303, 0, strict);
	      num = (num & 0x1f) | ((num & 0x003fffe0) << 4);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a source FP operand format completer.  */
	    case '{':
	      if (*s == ',' && *(s+1) == 't')
		{
		  the_insn.trunc = 1;
		  s += 2;
		}
	      else
		the_insn.trunc = 0;
	      flag = pa_parse_fp_cnv_format (&s);
	      the_insn.fpof1 = flag;
	      if (flag == W || flag == UW)
		flag = SGL;
	      if (flag == DW || flag == UDW)
		flag = DBL;
	      if (flag == QW || flag == UQW)
		flag = QUAD;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

	    /* Handle a destination FP operand format completer.  */
	    case '_':
	      /* pa_parse_format needs the ',' prefix.  */
	      s--;
	      flag = pa_parse_fp_cnv_format (&s);
	      the_insn.fpof2 = flag;
	      if (flag == W || flag == UW)
		flag = SGL;
	      if (flag == DW || flag == UDW)
		flag = DBL;
	      if (flag == QW || flag == UQW)
		flag = QUAD;
	      opcode |= flag << 13;
	      if (the_insn.fpof1 == SGL
		  || the_insn.fpof1 == DBL
		  || the_insn.fpof1 == QUAD)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 0;
		  else if (the_insn.fpof2 == W
		      || the_insn.fpof2 == DW
		      || the_insn.fpof2 == QW)
		    flag = 2;
		  else if (the_insn.fpof2 == UW
		      || the_insn.fpof2 == UDW
		      || the_insn.fpof2 == UQW)
		    flag = 6;
		  else
		    abort ();
		}
	      else if (the_insn.fpof1 == W
		       || the_insn.fpof1 == DW
		       || the_insn.fpof1 == QW)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 1;
		  else
		    abort ();
		}
	      else if (the_insn.fpof1 == UW
		       || the_insn.fpof1 == UDW
		       || the_insn.fpof1 == UQW)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 5;
		  else
		    abort ();
		}
	      flag |= the_insn.trunc;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 15);

	    /* Handle a source FP operand format completer.  */
	    case 'F':
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof1 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

	    /* Handle a destination FP operand format completer.  */
	    case 'G':
	      /* pa_parse_format needs the ',' prefix.  */
	      s--;
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof2 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 13);

	    /* Handle a source FP operand format completer at 20.  */
	    case 'I':
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof1 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

	    /* Handle a floating point operand format at 26.
	       Only allows single and double precision.  */
	    case 'H':
	      flag = pa_parse_fp_format (&s);
	      switch (flag)
		{
		case SGL:
		  opcode |= 0x20;
		case DBL:
		  the_insn.fpof1 = flag;
		  continue;

		case QUAD:
		case ILLEGAL_FMT:
		default:
		  as_bad (_("Invalid Floating Point Operand Format."));
		}
	      break;

	    /* Handle all floating point registers.  */
	    case 'f':
	      switch (*++args)
	        {
		/* Float target register.  */
		case 't':
		  if (!pa_parse_number (&s, 3))
		    break;
		  num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		  CHECK_FIELD (num, 31, 0, 0);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

		/* Float target register with L/R selection.  */
		case 'T':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num;

		    /* 0x30 opcodes are FP arithmetic operation opcodes
		       and need to be turned into 0x38 opcodes.  This
		       is not necessary for loads/stores.  */
		    if (need_pa11_opcode ()
			&& ((opcode & 0xfc000000) == 0x30000000))
		      opcode |= 1 << 27;

		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 6 : 0);
		    continue;
		  }

		/* Float operand 1.  */
		case 'a':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 21;
		    if (need_pa11_opcode ())
		      {
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 7 : 0);
			opcode |= 1 << 27;
		      }
		    continue;
		  }

		/* Float operand 1 with L/R selection.  */
		case 'X':
		case 'A':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 21;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 7 : 0);
		    continue;
		  }

		/* Float operand 2.  */
		case 'b':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    if (need_pa11_opcode ())
		      {
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 12 : 0);
			opcode |= 1 << 27;
		      }
		    continue;
		  }

		/* Float operand 2 with L/R selection.  */
		case 'B':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 12 : 0);
		    continue;
		  }

		/* Float operand 3 for fmpyfadd, fmpynfadd.  */
		case 'C':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= (num & 0x1c) << 11;
		    opcode |= (num & 0x03) << 9;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 8 : 0);
		    continue;
		  }

		/* Float mult operand 1 for fmpyadd, fmpysub */
		case 'i':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
			if (num < 16)
			  {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
			  }
			num &= 0xF;
			num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 21);
		  }

		/* Float mult operand 2 for fmpyadd, fmpysub */
		case 'j':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
		        if (num < 16)
		          {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 16);
		  }

		/* Float mult target for fmpyadd, fmpysub */
		case 'k':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
		        if (num < 16)
		          {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		  }

		/* Float add operand 1 for fmpyadd, fmpysub */
		case 'l':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
		        if (num < 16)
		          {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 6);
		  }

		/* Float add target for fmpyadd, fmpysub */
		case 'm':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
		      {
		        if (num < 16)
		          {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
		          }
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 11);
		  }

		/* Handle L/R register halves like 'x'.  */
		case 'E':
		case 'e':
		  {
		    if (!pa_parse_number (&s, 1))
		      break;
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    if (need_pa11_opcode ())
		      {
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 1 : 0);
		      }
		    continue;
		  }

		/* Float target register (PA 2.0 wide).  */
		case 'x':
		  if (!pa_parse_number (&s, 3))
		    break;
		  num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		  CHECK_FIELD (num, 31, 0, 0);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

		default:
		  abort ();
		}
	      break;

	    default:
	      abort ();
	    }
	  break;
	}

 failed:
      /* Check if the args matched.  */
      if (!match)
	{
	  if (&insn[1] - pa_opcodes < (int) NUMOPCODES
	      && !strcmp (insn->name, insn[1].name))
	    {
	      ++insn;
	      s = argstart;
	      continue;
	    }
	  else
	    {
	      as_bad (_("Invalid operands %s"), error_message);
	      return;
	    }
	}
      break;
    }

  the_insn.opcode = opcode;
}

/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message or NULL is returned.  */

#define MAX_LITTLENUMS 6

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {

    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return NULL;
}

/* Write out big-endian.  */

void
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
{
  number_to_chars_bigendian (buf, val, n);
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent **
tc_gen_reloc (section, fixp)
     asection *section;
     fixS *fixp;
{
  arelent *reloc;
  struct hppa_fix_struct *hppa_fixp;
  static arelent *no_relocs = NULL;
  arelent **relocs;
  reloc_type **codes;
  reloc_type code;
  int n_relocs;
  int i;

  hppa_fixp = (struct hppa_fix_struct *) fixp->tc_fix_data;
  if (fixp->fx_addsy == 0)
    return &no_relocs;

  assert (hppa_fixp != 0);
  assert (section != 0);

  reloc = (arelent *) xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  codes = hppa_gen_reloc_type (stdoutput,
			       fixp->fx_r_type,
			       hppa_fixp->fx_r_format,
			       hppa_fixp->fx_r_field,
			       fixp->fx_subsy != NULL,
			       symbol_get_bfdsym (fixp->fx_addsy));

  if (codes == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line, _("Cannot handle fixup"));
      abort ();
    }

  for (n_relocs = 0; codes[n_relocs]; n_relocs++)
    ;

  relocs = (arelent **) xmalloc (sizeof (arelent *) * n_relocs + 1);
  reloc = (arelent *) xmalloc (sizeof (arelent) * n_relocs);
  for (i = 0; i < n_relocs; i++)
    relocs[i] = &reloc[i];

  relocs[n_relocs] = NULL;

#ifdef OBJ_ELF
  switch (fixp->fx_r_type)
    {
    default:
      assert (n_relocs == 1);

      code = *codes[0];

      /* Now, do any processing that is dependent on the relocation type.  */
      switch (code)
	{
	case R_PARISC_DLTREL21L:
	case R_PARISC_DLTREL14R:
	case R_PARISC_DLTREL14F:
	case R_PARISC_PLABEL32:
	case R_PARISC_PLABEL21L:
	case R_PARISC_PLABEL14R:
	  /* For plabel relocations, the addend of the
	     relocation should be either 0 (no static link) or 2
	     (static link required).  This adjustment is done in
	     bfd/elf32-hppa.c:elf32_hppa_relocate_section.

	     We also slam a zero addend into the DLT relative relocs;
	     it doesn't make a lot of sense to use any addend since
	     it gets you a different (eg unknown) DLT entry.  */
	  reloc->addend = 0;
	  break;

#ifdef ELF_ARG_RELOC
	case R_PARISC_PCREL17R:
	case R_PARISC_PCREL17F:
	case R_PARISC_PCREL17C:
	case R_PARISC_DIR17R:
	case R_PARISC_DIR17F:
	case R_PARISC_PCREL21L:
	case R_PARISC_DIR21L:
	  reloc->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc,
					 fixp->fx_offset);
	  break;
#endif

	case R_PARISC_DIR32:
	  /* Facilitate hand-crafted unwind info.  */
	  if (strcmp (section->name, UNWIND_SECTION_NAME) == 0)
	    code = R_PARISC_SEGREL32;
	  /* Fall thru */

	default:
	  reloc->addend = fixp->fx_offset;
	  break;
	}

      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->howto = bfd_reloc_type_lookup (stdoutput,
					    (bfd_reloc_code_real_type) code);
      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

      assert (reloc->howto && (unsigned int) code == reloc->howto->type);
      break;
    }
#else /* OBJ_SOM */

  /* Walk over reach relocation returned by the BFD backend.  */
  for (i = 0; i < n_relocs; i++)
    {
      code = *codes[i];

      relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      relocs[i]->howto =
	bfd_reloc_type_lookup (stdoutput,
			       (bfd_reloc_code_real_type) code);
      relocs[i]->address = fixp->fx_frag->fr_address + fixp->fx_where;

      switch (code)
	{
	case R_COMP2:
	  /* The only time we ever use a R_COMP2 fixup is for the difference
	     of two symbols.  With that in mind we fill in all four
	     relocs now and break out of the loop.  */
	  assert (i == 1);
	  relocs[0]->sym_ptr_ptr = (asymbol **) &(bfd_abs_symbol);
	  relocs[0]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[0]);
	  relocs[0]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[0]->addend = 0;
	  relocs[1]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[1]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
	  relocs[1]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[1]);
	  relocs[1]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[1]->addend = 0;
	  relocs[2]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[2]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_subsy);
	  relocs[2]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[2]);
	  relocs[2]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[2]->addend = 0;
	  relocs[3]->sym_ptr_ptr = (asymbol **) &(bfd_abs_symbol);
	  relocs[3]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[3]);
	  relocs[3]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[3]->addend = 0;
	  relocs[4]->sym_ptr_ptr = (asymbol **) &(bfd_abs_symbol);
	  relocs[4]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[4]);
	  relocs[4]->address = fixp->fx_frag->fr_address + fixp->fx_where;
	  relocs[4]->addend = 0;
	  goto done;
	case R_PCREL_CALL:
	case R_ABS_CALL:
	  relocs[i]->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc, 0);
	  break;

	case R_DLT_REL:
	case R_DATA_PLABEL:
	case R_CODE_PLABEL:
	  /* For plabel relocations, the addend of the
	     relocation should be either 0 (no static link) or 2
	     (static link required).

	     FIXME: We always assume no static link!

	     We also slam a zero addend into the DLT relative relocs;
	     it doesn't make a lot of sense to use any addend since
	     it gets you a different (eg unknown) DLT entry.  */
	  relocs[i]->addend = 0;
	  break;

	case R_N_MODE:
	case R_S_MODE:
	case R_D_MODE:
	case R_R_MODE:
	case R_FSEL:
	case R_LSEL:
	case R_RSEL:
	case R_BEGIN_BRTAB:
	case R_END_BRTAB:
	case R_BEGIN_TRY:
	case R_N0SEL:
	case R_N1SEL:
	  /* There is no symbol or addend associated with these fixups.  */
	  relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
	  relocs[i]->addend = 0;
	  break;

	case R_END_TRY:
	case R_ENTRY:
	case R_EXIT:
	  /* There is no symbol associated with these fixups.  */
	  relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
	  relocs[i]->addend = fixp->fx_offset;
	  break;

	default:
	  relocs[i]->addend = fixp->fx_offset;
	}
    }

 done:
#endif

  return relocs;
}

/* Process any machine dependent frag types.  */

void
md_convert_frag (abfd, sec, fragP)
     register bfd *abfd ATTRIBUTE_UNUSED;
     register asection *sec ATTRIBUTE_UNUSED;
     register fragS *fragP;
{
  unsigned int address;

  if (fragP->fr_type == rs_machine_dependent)
    {
      switch ((int) fragP->fr_subtype)
	{
	case 0:
	  fragP->fr_type = rs_fill;
	  know (fragP->fr_var == 1);
	  know (fragP->fr_next);
	  address = fragP->fr_address + fragP->fr_fix;
	  if (address % fragP->fr_offset)
	    {
	      fragP->fr_offset =
		fragP->fr_next->fr_address
		- fragP->fr_address
		- fragP->fr_fix;
	    }
	  else
	    fragP->fr_offset = 0;
	  break;
	}
    }
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segment, size)
     asection *segment;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  int align2 = (1 << align) - 1;

  return (size + align2) & ~align2;
}

/* Return the approximate size of a frag before relaxation has occurred.  */
int
md_estimate_size_before_relax (fragP, segment)
     register fragS *fragP;
     asection *segment ATTRIBUTE_UNUSED;
{
  int size;

  size = 0;

  while ((fragP->fr_fix + size) % fragP->fr_offset)
    size++;

  return size;
}

#ifdef OBJ_ELF
# ifdef WARN_COMMENTS
const char *md_shortopts = "Vc";
# else
const char *md_shortopts = "V";
# endif
#else
# ifdef WARN_COMMENTS
const char *md_shortopts = "c";
# else
const char *md_shortopts = "";
# endif
#endif

struct option md_longopts[] = {
#ifdef WARN_COMMENTS
  {"warn-comment", no_argument, NULL, 'c'},
#endif
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
{
  switch (c)
    {
    default:
      return 0;

#ifdef OBJ_ELF
    case 'V':
      print_version_id ();
      break;
#endif
#ifdef WARN_COMMENTS
    case 'c':
      warn_comment = 1;
      break;
#endif
    }

  return 1;
}

void
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
{
#ifdef OBJ_ELF
  fprintf (stream, _("\
  -Q                      ignored\n"));
#endif
#ifdef WARN_COMMENTS
  fprintf (stream, _("\
  -c                      print a warning if a comment is found\n"));
#endif
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
#define nonzero_dibits(x) \
  ((x) | (((x) & 0x55555555) << 1) | (((x) & 0xAAAAAAAA) >> 1))
#define arg_reloc_stub_needed(CALLER, CALLEE) \
  (((CALLER) ^ (CALLEE)) & nonzero_dibits (CALLER) & nonzero_dibits (CALLEE))
#else
#define arg_reloc_stub_needed(CALLER, CALLEE) 0
#endif

/* Apply a fixup to an instruction.  */

void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
{
  unsigned char *buf;
  struct hppa_fix_struct *hppa_fixP;
  offsetT new_val;
  int insn, val, fmt;

  /* SOM uses R_HPPA_ENTRY and R_HPPA_EXIT relocations which can
     never be "applied" (they are just markers).  Likewise for
     R_HPPA_BEGIN_BRTAB and R_HPPA_END_BRTAB.  */
#ifdef OBJ_SOM
  if (fixP->fx_r_type == R_HPPA_ENTRY
      || fixP->fx_r_type == R_HPPA_EXIT
      || fixP->fx_r_type == R_HPPA_BEGIN_BRTAB
      || fixP->fx_r_type == R_HPPA_END_BRTAB
      || fixP->fx_r_type == R_HPPA_BEGIN_TRY)
    return;

  /* Disgusting.  We must set fx_offset ourselves -- R_HPPA_END_TRY
     fixups are considered not adjustable, which in turn causes
     adjust_reloc_syms to not set fx_offset.  Ugh.  */
  if (fixP->fx_r_type == R_HPPA_END_TRY)
    {
      fixP->fx_offset = * valP;
      return;
    }
#endif
#ifdef OBJ_ELF
  if (fixP->fx_r_type == (int) R_PARISC_GNU_VTENTRY
      || fixP->fx_r_type == (int) R_PARISC_GNU_VTINHERIT)
    return;
#endif

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;

  /* There should have been an HPPA specific fixup associated
     with the GAS fixup.  */
  hppa_fixP = (struct hppa_fix_struct *) fixP->tc_fix_data;
  if (hppa_fixP == NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("no hppa_fixup entry for fixup type 0x%x"),
		    fixP->fx_r_type);
      return;
    }

  buf = (unsigned char *) (fixP->fx_frag->fr_literal + fixP->fx_where);
  insn = bfd_get_32 (stdoutput, buf);
  fmt = bfd_hppa_insn2fmt (stdoutput, insn);

  /* If there is a symbol associated with this fixup, then it's something
     which will need a SOM relocation (except for some PC-relative relocs).
     In such cases we should treat the "val" or "addend" as zero since it
     will be added in as needed from fx_offset in tc_gen_reloc.  */
  if ((fixP->fx_addsy != NULL
       || fixP->fx_r_type == (int) R_HPPA_NONE)
#ifdef OBJ_SOM
      && fmt != 32
#endif
      )
    new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
#ifdef OBJ_SOM
  /* These field selectors imply that we do not want an addend.  */
  else if (hppa_fixP->fx_r_field == e_psel
	   || hppa_fixP->fx_r_field == e_rpsel
	   || hppa_fixP->fx_r_field == e_lpsel
	   || hppa_fixP->fx_r_field == e_tsel
	   || hppa_fixP->fx_r_field == e_rtsel
	   || hppa_fixP->fx_r_field == e_ltsel)
    new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
#endif
  else
    new_val = hppa_field_adjust (* valP, 0, hppa_fixP->fx_r_field);

  /* Handle pc-relative exceptions from above.  */
  if ((fmt == 12 || fmt == 17 || fmt == 22)
      && fixP->fx_addsy
      && fixP->fx_pcrel
      && !arg_reloc_stub_needed (symbol_arg_reloc_info (fixP->fx_addsy),
				 hppa_fixP->fx_arg_reloc)
#ifdef OBJ_ELF
      && (* valP - 8 + 8192 < 16384
	  || (fmt == 17 && * valP - 8 + 262144 < 524288)
	  || (fmt == 22 && * valP - 8 + 8388608 < 16777216))
#endif
#ifdef OBJ_SOM
      && (* valP - 8 + 262144 < 524288
	  || (fmt == 22 && * valP - 8 + 8388608 < 16777216))
#endif
      && !S_IS_EXTERNAL (fixP->fx_addsy)
      && !S_IS_WEAK (fixP->fx_addsy)
      && S_GET_SEGMENT (fixP->fx_addsy) == hppa_fixP->segment
      && !(fixP->fx_subsy
	   && S_GET_SEGMENT (fixP->fx_subsy) != hppa_fixP->segment))
    {
      new_val = hppa_field_adjust (* valP, 0, hppa_fixP->fx_r_field);
    }

  switch (fmt)
    {
    case 10:
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = (insn & ~ 0x3ff1) | (((val & 0x1ff8) << 1)
				  | ((val & 0x2000) >> 13));
      break;
    case -11:
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = (insn & ~ 0x3ff9) | (((val & 0x1ffc) << 1)
				  | ((val & 0x2000) >> 13));
      break;
      /* Handle all opcodes with the 'j' operand type.  */
    case 14:
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = ((insn & ~ 0x3fff) | low_sign_unext (val, 14));
      break;

      /* Handle all opcodes with the 'k' operand type.  */
    case 21:
      CHECK_FIELD_WHERE (new_val, 1048575, -1048576,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = (insn & ~ 0x1fffff) | re_assemble_21 (val);
      break;

      /* Handle all the opcodes with the 'i' operand type.  */
    case 11:
      CHECK_FIELD_WHERE (new_val, 1023, -1024,
			 fixP->fx_file, fixP->fx_line);
      val = new_val;

      insn = (insn & ~ 0x7ff) | low_sign_unext (val, 11);
      break;

      /* Handle all the opcodes with the 'w' operand type.  */
    case 12:
      CHECK_FIELD_WHERE (new_val - 8, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
      val = new_val - 8;

      insn = (insn & ~ 0x1ffd) | re_assemble_12 (val >> 2);
      break;

      /* Handle some of the opcodes with the 'W' operand type.  */
    case 17:
      {
	offsetT distance = * valP;

	/* If this is an absolute branch (ie no link) with an out of
	   range target, then we want to complain.  */
	if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
	    && (insn & 0xffe00000) == 0xe8000000)
	  CHECK_FIELD_WHERE (distance - 8, 262143, -262144,
			     fixP->fx_file, fixP->fx_line);

	CHECK_FIELD_WHERE (new_val - 8, 262143, -262144,
			   fixP->fx_file, fixP->fx_line);
	val = new_val - 8;

	insn = (insn & ~ 0x1f1ffd) | re_assemble_17 (val >> 2);
	break;
      }

    case 22:
      {
	offsetT distance = * valP;

	/* If this is an absolute branch (ie no link) with an out of
	   range target, then we want to complain.  */
	if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
	    && (insn & 0xffe00000) == 0xe8000000)
	  CHECK_FIELD_WHERE (distance - 8, 8388607, -8388608,
			     fixP->fx_file, fixP->fx_line);

	CHECK_FIELD_WHERE (new_val - 8, 8388607, -8388608,
			   fixP->fx_file, fixP->fx_line);
	val = new_val - 8;

	insn = (insn & ~ 0x3ff1ffd) | re_assemble_22 (val >> 2);
	break;
      }

    case -10:
      val = new_val;
      insn = (insn & ~ 0xfff1) | re_assemble_16 (val & -8);
      break;

    case -16:
      val = new_val;
      insn = (insn & ~ 0xfff9) | re_assemble_16 (val & -4);
      break;

    case 16:
      val = new_val;
      insn = (insn & ~ 0xffff) | re_assemble_16 (val);
      break;

    case 32:
      insn = new_val;
      break;

    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("Unknown relocation encountered in md_apply_fix."));
      return;
    }

  /* Insert the relocation.  */
  bfd_put_32 (stdoutput, insn, buf);
}

/* Exactly what point is a PC-relative offset relative TO?
   On the PA, they're relative to the address of the offset.  */

long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_where + fixP->fx_frag->fr_address;
}

/* Return nonzero if the input line pointer is at the end of
   a statement.  */

static int
is_end_of_statement ()
{
  return ((*input_line_pointer == '\n')
	  || (*input_line_pointer == ';')
	  || (*input_line_pointer == '!'));
}

/* Read a number from S.  The number might come in one of many forms,
   the most common will be a hex or decimal constant, but it could be
   a pre-defined register (Yuk!), or an absolute symbol.

   Return 1 on success or 0 on failure.  If STRICT, then a missing
   register prefix will cause a failure.  The number itself is
   returned in `pa_number'.

   IS_FLOAT indicates that a PA-89 FP register number should be
   parsed;  A `l' or `r' suffix is checked for if but 2 of IS_FLOAT is
   not set.

   pa_parse_number can not handle negative constants and will fail
   horribly if it is passed such a constant.  */

static int
pa_parse_number (s, is_float)
     char **s;
     int is_float;
{
  int num;
  char *name;
  char c;
  symbolS *sym;
  int status;
  char *p = *s;
  bfd_boolean have_prefix;

  /* Skip whitespace before the number.  */
  while (*p == ' ' || *p == '\t')
    p = p + 1;

  pa_number = -1;
  have_prefix = 0;
  num = 0;
  if (!strict && ISDIGIT (*p))
    {
      /* Looks like a number.  */

      if (*p == '0' && (*(p + 1) == 'x' || *(p + 1) == 'X'))
	{
	  /* The number is specified in hex.  */
	  p += 2;
	  while (ISDIGIT (*p) || ((*p >= 'a') && (*p <= 'f'))
		 || ((*p >= 'A') && (*p <= 'F')))
	    {
	      if (ISDIGIT (*p))
		num = num * 16 + *p - '0';
	      else if (*p >= 'a' && *p <= 'f')
		num = num * 16 + *p - 'a' + 10;
	      else
		num = num * 16 + *p - 'A' + 10;
	      ++p;
	    }
	}
      else
	{
	  /* The number is specified in decimal.  */
	  while (ISDIGIT (*p))
	    {
	      num = num * 10 + *p - '0';
	      ++p;
	    }
	}

      pa_number = num;

      /* Check for a `l' or `r' suffix.  */
      if (is_float)
	{
	  pa_number += FP_REG_BASE;
	  if (! (is_float & 2))
	    {
	      if (IS_R_SELECT (p))
		{
		  pa_number += FP_REG_RSEL;
		  ++p;
		}
	      else if (IS_L_SELECT (p))
		{
		  ++p;
		}
	    }
	}
    }
  else if (*p == '%')
    {
      /* The number might be a predefined register.  */
      have_prefix = 1;
      name = p;
      p++;
      c = *p;
      /* Tege hack: Special case for general registers as the general
         code makes a binary search with case translation, and is VERY
         slow.  */
      if (c == 'r')
	{
	  p++;
	  if (*p == 'e' && *(p + 1) == 't'
	      && (*(p + 2) == '0' || *(p + 2) == '1'))
	    {
	      p += 2;
	      num = *p - '0' + 28;
	      p++;
	    }
	  else if (*p == 'p')
	    {
	      num = 2;
	      p++;
	    }
	  else if (!ISDIGIT (*p))
	    {
	      if (print_errors)
		as_bad (_("Undefined register: '%s'."), name);
	      num = -1;
	    }
	  else
	    {
	      do
		num = num * 10 + *p++ - '0';
	      while (ISDIGIT (*p));
	    }
	}
      else
	{
	  /* Do a normal register search.  */
	  while (is_part_of_name (c))
	    {
	      p = p + 1;
	      c = *p;
	    }
	  *p = 0;
	  status = reg_name_search (name);
	  if (status >= 0)
	    num = status;
	  else
	    {
	      if (print_errors)
		as_bad (_("Undefined register: '%s'."), name);
	      num = -1;
	    }
	  *p = c;
	}

      pa_number = num;
    }
  else
    {
      /* And finally, it could be a symbol in the absolute section which
         is effectively a constant, or a register alias symbol.  */
      name = p;
      c = *p;
      while (is_part_of_name (c))
	{
	  p = p + 1;
	  c = *p;
	}
      *p = 0;
      if ((sym = symbol_find (name)) != NULL)
	{
	  if (S_GET_SEGMENT (sym) == reg_section)
	    {
	      num = S_GET_VALUE (sym);
	      /* Well, we don't really have one, but we do have a
		 register, so...  */
	      have_prefix = TRUE;
	    }
	  else if (S_GET_SEGMENT (sym) == &bfd_abs_section)
	    num = S_GET_VALUE (sym);
	  else if (!strict)
	    {
	      if (print_errors)
		as_bad (_("Non-absolute symbol: '%s'."), name);
	      num = -1;
	    }
	}
      else if (!strict)
	{
	  /* There is where we'd come for an undefined symbol
	     or for an empty string.  For an empty string we
	     will return zero.  That's a concession made for
	     compatibility with the braindamaged HP assemblers.  */
	  if (*name == 0)
	    num = 0;
	  else
	    {
	      if (print_errors)
		as_bad (_("Undefined absolute constant: '%s'."), name);
	      num = -1;
	    }
	}
      *p = c;

      pa_number = num;
    }

  if (!strict || have_prefix)
    {
      *s = p;
      return 1;
    }
  return 0;
}

#define REG_NAME_CNT	(sizeof (pre_defined_registers) / sizeof (struct pd_reg))

/* Given NAME, find the register number associated with that name, return
   the integer value associated with the given name or -1 on failure.  */

static int
reg_name_search (name)
     char *name;
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = REG_NAME_CNT - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, pre_defined_registers[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return pre_defined_registers[middle].value;
    }
  while (low <= high);

  return -1;
}

/* Return nonzero if the given INSN and L/R information will require
   a new PA-1.1 opcode.  */

static int
need_pa11_opcode ()
{
  if ((pa_number & FP_REG_RSEL) != 0
      && !(the_insn.fpof1 == DBL && the_insn.fpof2 == DBL))
    {
      /* If this instruction is specific to a particular architecture,
	 then set a new architecture.  */
      if (bfd_get_mach (stdoutput) < pa11)
	{
	  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, pa11))
	    as_warn (_("could not update architecture and machine"));
	}
      return TRUE;
    }
  else
    return FALSE;
}

/* Parse a condition for a fcmp instruction.  Return the numerical
   code associated with the condition.  */

static int
pa_parse_fp_cmp_cond (s)
     char **s;
{
  int cond, i;

  cond = 0;

  for (i = 0; i < 32; i++)
    {
      if (strncasecmp (*s, fp_cond_map[i].string,
		       strlen (fp_cond_map[i].string)) == 0)
	{
	  cond = fp_cond_map[i].cond;
	  *s += strlen (fp_cond_map[i].string);
	  /* If not a complete match, back up the input string and
	     report an error.  */
	  if (**s != ' ' && **s != '\t')
	    {
	      *s -= strlen (fp_cond_map[i].string);
	      break;
	    }
	  while (**s == ' ' || **s == '\t')
	    *s = *s + 1;
	  return cond;
	}
    }

  as_bad (_("Invalid FP Compare Condition: %s"), *s);

  /* Advance over the bogus completer.  */
  while (**s != ',' && **s != ' ' && **s != '\t')
    *s += 1;

  return 0;
}

/* Parse a graphics test complete for ftest.  */

static int
pa_parse_ftest_gfx_completer (s)
     char **s;
{
  int value;

  value = 0;
  if (strncasecmp (*s, "acc8", 4) == 0)
    {
      value = 5;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc6", 4) == 0)
    {
      value = 9;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc4", 4) == 0)
    {
      value = 13;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc2", 4) == 0)
    {
      value = 17;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc", 3) == 0)
    {
      value = 1;
      *s += 3;
    }
  else if (strncasecmp (*s, "rej8", 4) == 0)
    {
      value = 6;
      *s += 4;
    }
  else if (strncasecmp (*s, "rej", 3) == 0)
    {
      value = 2;
      *s += 3;
    }
  else
    {
      value = 0;
      as_bad (_("Invalid FTEST completer: %s"), *s);
    }

  return value;
}

/* Parse an FP operand format completer returning the completer
   type.  */

static fp_operand_format
pa_parse_fp_cnv_format (s)
     char **s;
{
  int format;

  format = SGL;
  if (**s == ',')
    {
      *s += 1;
      if (strncasecmp (*s, "sgl", 3) == 0)
	{
	  format = SGL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "dbl", 3) == 0)
	{
	  format = DBL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "quad", 4) == 0)
	{
	  format = QUAD;
	  *s += 5;
	}
      else if (strncasecmp (*s, "w", 1) == 0)
	{
	  format = W;
	  *s += 2;
	}
      else if (strncasecmp (*s, "uw", 2) == 0)
	{
	  format = UW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "dw", 2) == 0)
	{
	  format = DW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "udw", 3) == 0)
	{
	  format = UDW;
	  *s += 4;
	}
      else if (strncasecmp (*s, "qw", 2) == 0)
	{
	  format = QW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "uqw", 3) == 0)
	{
	  format = UQW;
	  *s += 4;
	}
      else
	{
	  format = ILLEGAL_FMT;
	  as_bad (_("Invalid FP Operand Format: %3s"), *s);
	}
    }

  return format;
}

/* Parse an FP operand format completer returning the completer
   type.  */

static fp_operand_format
pa_parse_fp_format (s)
     char **s;
{
  int format;

  format = SGL;
  if (**s == ',')
    {
      *s += 1;
      if (strncasecmp (*s, "sgl", 3) == 0)
	{
	  format = SGL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "dbl", 3) == 0)
	{
	  format = DBL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "quad", 4) == 0)
	{
	  format = QUAD;
	  *s += 5;
	}
      else
	{
	  format = ILLEGAL_FMT;
	  as_bad (_("Invalid FP Operand Format: %3s"), *s);
	}
    }

  return format;
}

/* Convert from a selector string into a selector type.  */

static int
pa_chk_field_selector (str)
     char **str;
{
  int middle, low, high;
  int cmp;
  char name[4];

  /* Read past any whitespace.  */
  /* FIXME: should we read past newlines and formfeeds??? */
  while (**str == ' ' || **str == '\t' || **str == '\n' || **str == '\f')
    *str = *str + 1;

  if ((*str)[1] == '\'' || (*str)[1] == '%')
    name[0] = TOLOWER ((*str)[0]),
    name[1] = 0;
  else if ((*str)[2] == '\'' || (*str)[2] == '%')
    name[0] = TOLOWER ((*str)[0]),
    name[1] = TOLOWER ((*str)[1]),
    name[2] = 0;
  else if ((*str)[3] == '\'' || (*str)[3] == '%')
    name[0] = TOLOWER ((*str)[0]),
    name[1] = TOLOWER ((*str)[1]),
    name[2] = TOLOWER ((*str)[2]),
    name[3] = 0;
  else
    return e_fsel;

  low = 0;
  high = sizeof (selector_table) / sizeof (struct selector_entry) - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcmp (name, selector_table[middle].prefix);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	{
	  *str += strlen (name) + 1;
#ifndef OBJ_SOM
	  if (selector_table[middle].field_selector == e_nsel)
	    return e_fsel;
#endif
	  return selector_table[middle].field_selector;
	}
    }
  while (low <= high);

  return e_fsel;
}

/* Mark (via expr_end) the end of an expression (I think).  FIXME.  */

static int
get_expression (str)
     char *str;
{
  char *save_in;
  asection *seg;

  save_in = input_line_pointer;
  input_line_pointer = str;
  seg = expression (&the_insn.exp);
  if (!(seg == absolute_section
	|| seg == undefined_section
	|| SEG_NORMAL (seg)))
    {
      as_warn (_("Bad segment in expression."));
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
}

/* Mark (via expr_end) the end of an absolute expression.  FIXME.  */
static int
pa_get_absolute_expression (insn, strp)
     struct pa_it *insn;
     char **strp;
{
  char *save_in;

  insn->field_selector = pa_chk_field_selector (strp);
  save_in = input_line_pointer;
  input_line_pointer = *strp;
  expression (&insn->exp);
  /* This is not perfect, but is a huge improvement over doing nothing.

     The PA assembly syntax is ambiguous in a variety of ways.  Consider
     this string "4 %r5"  Is that the number 4 followed by the register
     r5, or is that 4 MOD r5?

     If we get a modulo expression when looking for an absolute, we try
     again cutting off the input string at the first whitespace character.  */
  if (insn->exp.X_op == O_modulus)
    {
      char *s, c;
      int retval;

      input_line_pointer = *strp;
      s = *strp;
      while (*s != ',' && *s != ' ' && *s != '\t')
	s++;

      c = *s;
      *s = 0;

      retval = pa_get_absolute_expression (insn, strp);

      input_line_pointer = save_in;
      *s = c;
      return evaluate_absolute (insn);
    }
  /* When in strict mode we have a non-match, fix up the pointers
     and return to our caller.  */
  if (insn->exp.X_op != O_constant && strict)
    {
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 0;
    }
  if (insn->exp.X_op != O_constant)
    {
      as_bad (_("Bad segment (should be absolute)."));
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 0;
    }
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
  return evaluate_absolute (insn);
}

/* Evaluate an absolute expression EXP which may be modified by
   the selector FIELD_SELECTOR.  Return the value of the expression.  */
static int
evaluate_absolute (insn)
     struct pa_it *insn;
{
  offsetT value;
  expressionS exp;
  int field_selector = insn->field_selector;

  exp = insn->exp;
  value = exp.X_add_number;

  return hppa_field_adjust (0, value, field_selector);
}

/* Given an argument location specification return the associated
   argument location number.  */

static unsigned int
pa_build_arg_reloc (type_name)
     char *type_name;
{

  if (strncasecmp (type_name, "no", 2) == 0)
    return 0;
  if (strncasecmp (type_name, "gr", 2) == 0)
    return 1;
  else if (strncasecmp (type_name, "fr", 2) == 0)
    return 2;
  else if (strncasecmp (type_name, "fu", 2) == 0)
    return 3;
  else
    as_bad (_("Invalid argument location: %s\n"), type_name);

  return 0;
}

/* Encode and return an argument relocation specification for
   the given register in the location specified by arg_reloc.  */

static unsigned int
pa_align_arg_reloc (reg, arg_reloc)
     unsigned int reg;
     unsigned int arg_reloc;
{
  unsigned int new_reloc;

  new_reloc = arg_reloc;
  switch (reg)
    {
    case 0:
      new_reloc <<= 8;
      break;
    case 1:
      new_reloc <<= 6;
      break;
    case 2:
      new_reloc <<= 4;
      break;
    case 3:
      new_reloc <<= 2;
      break;
    default:
      as_bad (_("Invalid argument description: %d"), reg);
    }

  return new_reloc;
}

/* Parse a PA nullification completer (,n).  Return nonzero if the
   completer was found; return zero if no completer was found.  */

static int
pa_parse_nullif (s)
     char **s;
{
  int nullif;

  nullif = 0;
  if (**s == ',')
    {
      *s = *s + 1;
      if (strncasecmp (*s, "n", 1) == 0)
	nullif = 1;
      else
	{
	  as_bad (_("Invalid Nullification: (%c)"), **s);
	  nullif = 0;
	}
      *s = *s + 1;
    }

  return nullif;
}

/* Parse a non-negated compare/subtract completer returning the
   number (for encoding in instructions) of the given completer.  */

static int
pa_parse_nonneg_cmpsub_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "<<") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "<<=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "od") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a negated compare/subtract completer returning the
   number (for encoding in instructions) of the given completer.  */

static int
pa_parse_neg_cmpsub_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, ">>=") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, ">>") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "nsv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "ev") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a 64 bit compare and branch completer returning the number (for
   encoding in instructions) of the given completer.

   Nonnegated comparisons are returned as 0-7, negated comparisons are
   returned as 8-15.  */

static int
pa_parse_cmpb_64_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;

  cmpltr = -1;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "*") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "*=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "*<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "*<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "*<<") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "*<<=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*od") == 0)
	{
	  cmpltr = 7;
	}
      else if (strcasecmp (name, "*tr") == 0)
	{
	  cmpltr = 8;
	}
      else if (strcmp (name, "*<>") == 0)
	{
	  cmpltr = 9;
	}
      else if (strcmp (name, "*>=") == 0)
	{
	  cmpltr = 10;
	}
      else if (strcmp (name, "*>") == 0)
	{
	  cmpltr = 11;
	}
      else if (strcmp (name, "*>>=") == 0)
	{
	  cmpltr = 12;
	}
      else if (strcmp (name, "*>>") == 0)
	{
	  cmpltr = 13;
	}
      else if (strcasecmp (name, "*nsv") == 0)
	{
	  cmpltr = 14;
	}
      else if (strcasecmp (name, "*ev") == 0)
	{
	  cmpltr = 15;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  return cmpltr;
}

/* Parse a 64 bit compare immediate and branch completer returning the number
   (for encoding in instructions) of the given completer.  */

static int
pa_parse_cmpib_64_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;

  cmpltr = -1;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "*<<") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "*=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "*<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "*<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "*>>=") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "*<>") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*>=") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*>") == 0)
	{
	  cmpltr = 7;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  return cmpltr;
}

/* Parse a non-negated addition completer returning the number
   (for encoding in instructions) of the given completer.  */

static int
pa_parse_nonneg_add_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;
      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcasecmp (name, "nuv") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcasecmp (name, "znv") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "od") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a negated addition completer returning the number
   (for encoding in instructions) of the given completer.  */

static int
pa_parse_neg_add_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;
      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcasecmp (name, "uv") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcasecmp (name, "vnz") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "nsv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "ev") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

/* Parse a 64 bit wide mode add and branch completer returning the number (for
   encoding in instructions) of the given completer.  */

static int
pa_parse_addb_64_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;
      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcasecmp (name, "nuv") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcasecmp (name, "*=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*<") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*<=") == 0)
	{
	  cmpltr = 7;
	}
      else if (strcmp (name, "tr") == 0)
	{
	  cmpltr = 8;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 9;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 10;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 11;
	}
      else if (strcasecmp (name, "uv") == 0)
	{
	  cmpltr = 12;
	}
      else if (strcasecmp (name, "*<>") == 0)
	{
	  cmpltr = 13;
	}
      else if (strcasecmp (name, "*>=") == 0)
	{
	  cmpltr = 14;
	}
      else if (strcasecmp (name, "*>") == 0)
	{
	  cmpltr = 15;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;

  return cmpltr;
}

#ifdef OBJ_SOM
/* Handle an alignment directive.  Special so that we can update the
   alignment of the subspace if necessary.  */
static void
pa_align (bytes)
     int bytes;
{
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();

  /* Let the generic gas code do most of the work.  */
  s_align_bytes (bytes);

  /* If bytes is a power of 2, then update the current subspace's
     alignment if necessary.  */
  if (log2 (bytes) != -1)
    record_alignment (current_subspace->ssd_seg, log2 (bytes));
}
#endif

/* Handle a .BLOCK type pseudo-op.  */

static void
pa_block (z)
     int z ATTRIBUTE_UNUSED;
{
  char *p;
  long int temp_fill;
  unsigned int temp_size;
  unsigned int i;

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  temp_size = get_absolute_expression ();

  /* Always fill with zeros, that's what the HP assembler does.  */
  temp_fill = 0;

  p = frag_var (rs_fill, (int) temp_size, (int) temp_size,
		(relax_substateT) 0, (symbolS *) 0, (offsetT) 1, NULL);
  memset (p, 0, temp_size);

  /* Convert 2 bytes at a time.  */

  for (i = 0; i < temp_size; i += 2)
    {
      md_number_to_chars (p + i,
			  (valueT) temp_fill,
			  (int) ((temp_size - i) > 2 ? 2 : (temp_size - i)));
    }

  pa_undefine_label ();
  demand_empty_rest_of_line ();
}

/* Handle a .begin_brtab and .end_brtab pseudo-op.  */

static void
pa_brtab (begin)
     int begin ATTRIBUTE_UNUSED;
{

#ifdef OBJ_SOM
  /* The BRTAB relocations are only available in SOM (to denote
     the beginning and end of branch tables).  */
  char *where = frag_more (0);

  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
		NULL, (offsetT) 0, NULL,
		0, begin ? R_HPPA_BEGIN_BRTAB : R_HPPA_END_BRTAB,
		e_fsel, 0, 0, 0);
#endif

  demand_empty_rest_of_line ();
}

/* Handle a .begin_try and .end_try pseudo-op.  */

static void
pa_try (begin)
     int begin ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  expressionS exp;
  char *where = frag_more (0);

  if (! begin)
    expression (&exp);

  /* The TRY relocations are only available in SOM (to denote
     the beginning and end of exception handling regions).  */

  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
		NULL, (offsetT) 0, begin ? NULL : &exp,
		0, begin ? R_HPPA_BEGIN_TRY : R_HPPA_END_TRY,
		e_fsel, 0, 0, 0);
#endif

  demand_empty_rest_of_line ();
}

/* Handle a .CALL pseudo-op.  This involves storing away information
   about where arguments are to be found so the linker can detect
   (and correct) argument location mismatches between caller and callee.  */

static void
pa_call (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  pa_call_args (&last_call_desc);
  demand_empty_rest_of_line ();
}

/* Do the dirty work of building a call descriptor which describes
   where the caller placed arguments to a function call.  */

static void
pa_call_args (call_desc)
     struct call_desc *call_desc;
{
  char *name, c, *p;
  unsigned int temp, arg_reloc;

  while (!is_end_of_statement ())
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      /* Process a source argument.  */
      if ((strncasecmp (name, "argw", 4) == 0))
	{
	  temp = atoi (name + 4);
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  name = input_line_pointer;
	  c = get_symbol_end ();
	  arg_reloc = pa_build_arg_reloc (name);
	  call_desc->arg_reloc |= pa_align_arg_reloc (temp, arg_reloc);
	}
      /* Process a return value.  */
      else if ((strncasecmp (name, "rtnval", 6) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  name = input_line_pointer;
	  c = get_symbol_end ();
	  arg_reloc = pa_build_arg_reloc (name);
	  call_desc->arg_reloc |= (arg_reloc & 0x3);
	}
      else
	{
	  as_bad (_("Invalid .CALL argument: %s"), name);
	}
      p = input_line_pointer;
      *p = c;
      if (!is_end_of_statement ())
	input_line_pointer++;
    }
}

/* Return TRUE if FRAG1 and FRAG2 are the same.  */

static int
is_same_frag (frag1, frag2)
     fragS *frag1;
     fragS *frag2;
{

  if (frag1 == NULL)
    return (FALSE);
  else if (frag2 == NULL)
    return (FALSE);
  else if (frag1 == frag2)
    return (TRUE);
  else if (frag2->fr_type == rs_fill && frag2->fr_fix == 0)
    return (is_same_frag (frag1, frag2->fr_next));
  else
    return (FALSE);
}

#ifdef OBJ_ELF
/* Build an entry in the UNWIND subspace from the given function
   attributes in CALL_INFO.  This is not needed for SOM as using
   R_ENTRY and R_EXIT relocations allow the linker to handle building
   of the unwind spaces.  */

static void
pa_build_unwind_subspace (call_info)
     struct call_info *call_info;
{
  asection *seg, *save_seg;
  subsegT save_subseg;
  unsigned int unwind;
  int reloc;
  char *p;

  if ((bfd_get_section_flags (stdoutput, now_seg)
       & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
      != (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
    return;

  reloc = R_PARISC_SEGREL32;
  save_seg = now_seg;
  save_subseg = now_subseg;
  /* Get into the right seg/subseg.  This may involve creating
     the seg the first time through.  Make sure to have the
     old seg/subseg so that we can reset things when we are done.  */
  seg = bfd_get_section_by_name (stdoutput, UNWIND_SECTION_NAME);
  if (seg == ASEC_NULL)
    {
      seg = subseg_new (UNWIND_SECTION_NAME, 0);
      bfd_set_section_flags (stdoutput, seg,
			     SEC_READONLY | SEC_HAS_CONTENTS
			     | SEC_LOAD | SEC_RELOC | SEC_ALLOC | SEC_DATA);
      bfd_set_section_alignment (stdoutput, seg, 2);
    }

  subseg_set (seg, 0);

  /* Get some space to hold relocation information for the unwind
     descriptor.  */
  p = frag_more (16);

  /* Relocation info. for start offset of the function.  */
  md_number_to_chars (p, 0, 4);
  fix_new_hppa (frag_now, p - frag_now->fr_literal, 4,
		call_info->start_symbol, (offsetT) 0,
		(expressionS *) NULL, 0, reloc,
		e_fsel, 32, 0, 0);

  /* Relocation info. for end offset of the function.

     Because we allow reductions of 32bit relocations for ELF, this will be
     reduced to section_sym + offset which avoids putting the temporary
     symbol into the symbol table.  It (should) end up giving the same
     value as call_info->start_symbol + function size once the linker is
     finished with its work.  */
  md_number_to_chars (p + 4, 0, 4);
  fix_new_hppa (frag_now, p + 4 - frag_now->fr_literal, 4,
		call_info->end_symbol, (offsetT) 0,
		(expressionS *) NULL, 0, reloc,
		e_fsel, 32, 0, 0);

  /* Dump the descriptor.  */
  unwind = UNWIND_LOW32 (&call_info->ci_unwind.descriptor);
  md_number_to_chars (p + 8, unwind, 4);

  unwind = UNWIND_HIGH32 (&call_info->ci_unwind.descriptor);
  md_number_to_chars (p + 12, unwind, 4);

  /* Return back to the original segment/subsegment.  */
  subseg_set (save_seg, save_subseg);
}
#endif

/* Process a .CALLINFO pseudo-op.  This information is used later
   to build unwind descriptors and maybe one day to support
   .ENTER and .LEAVE.  */

static void
pa_callinfo (unused)
     int unused ATTRIBUTE_UNUSED;
{
  char *name, c, *p;
  int temp;

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  /* .CALLINFO must appear within a procedure definition.  */
  if (!within_procedure)
    as_bad (_(".callinfo is not within a procedure definition"));

  /* Mark the fact that we found the .CALLINFO for the
     current procedure.  */
  callinfo_found = TRUE;

  /* Iterate over the .CALLINFO arguments.  */
  while (!is_end_of_statement ())
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      /* Frame size specification.  */
      if ((strncasecmp (name, "frame", 5) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = get_absolute_expression ();
	  if ((temp & 0x3) != 0)
	    {
	      as_bad (_("FRAME parameter must be a multiple of 8: %d\n"), temp);
	      temp = 0;
	    }

	  /* callinfo is in bytes and unwind_desc is in 8 byte units.  */
	  last_call_info->ci_unwind.descriptor.frame_size = temp / 8;

	}
      /* Entry register (GR, GR and SR) specifications.  */
      else if ((strncasecmp (name, "entry_gr", 8) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = get_absolute_expression ();
	  /* The HP assembler accepts 19 as the high bound for ENTRY_GR
	     even though %r19 is caller saved.  I think this is a bug in
	     the HP assembler, and we are not going to emulate it.  */
	  if (temp < 3 || temp > 18)
	    as_bad (_("Value for ENTRY_GR must be in the range 3..18\n"));
	  last_call_info->ci_unwind.descriptor.entry_gr = temp - 2;
	}
      else if ((strncasecmp (name, "entry_fr", 8) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = get_absolute_expression ();
	  /* Similarly the HP assembler takes 31 as the high bound even
	     though %fr21 is the last callee saved floating point register.  */
	  if (temp < 12 || temp > 21)
	    as_bad (_("Value for ENTRY_FR must be in the range 12..21\n"));
	  last_call_info->ci_unwind.descriptor.entry_fr = temp - 11;
	}
      else if ((strncasecmp (name, "entry_sr", 8) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = get_absolute_expression ();
	  if (temp != 3)
	    as_bad (_("Value for ENTRY_SR must be 3\n"));
	}
      /* Note whether or not this function performs any calls.  */
      else if ((strncasecmp (name, "calls", 5) == 0) ||
	       (strncasecmp (name, "caller", 6) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	}
      else if ((strncasecmp (name, "no_calls", 8) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	}
      /* Should RP be saved into the stack.  */
      else if ((strncasecmp (name, "save_rp", 7) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.save_rp = 1;
	}
      /* Likewise for SP.  */
      else if ((strncasecmp (name, "save_sp", 7) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.save_sp = 1;
	}
      /* Is this an unwindable procedure.  If so mark it so
         in the unwind descriptor.  */
      else if ((strncasecmp (name, "no_unwind", 9) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.cannot_unwind = 1;
	}
      /* Is this an interrupt routine.  If so mark it in the
         unwind descriptor.  */
      else if ((strncasecmp (name, "hpux_int", 7) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.hpux_interrupt_marker = 1;
	}
      /* Is this a millicode routine.  "millicode" isn't in my
	 assembler manual, but my copy is old.  The HP assembler
	 accepts it, and there's a place in the unwind descriptor
	 to drop the information, so we'll accept it too.  */
      else if ((strncasecmp (name, "millicode", 9) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  last_call_info->ci_unwind.descriptor.millicode = 1;
	}
      else
	{
	  as_bad (_("Invalid .CALLINFO argument: %s"), name);
	  *input_line_pointer = c;
	}
      if (!is_end_of_statement ())
	input_line_pointer++;
    }

  demand_empty_rest_of_line ();
}

#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
/* Switch to the text space.  Like s_text, but delete our
   label when finished.  */
static void
pa_text (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  current_space = is_defined_space ("$TEXT$");
  current_subspace
    = pa_subsegment_to_subspace (current_space->sd_seg, 0);
#endif

  s_text (0);
  pa_undefine_label ();
}

/* Switch to the data space.  As usual delete our label.  */
static void
pa_data (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  current_space = is_defined_space ("$PRIVATE$");
  current_subspace
    = pa_subsegment_to_subspace (current_space->sd_seg, 0);
#endif
  s_data (0);
  pa_undefine_label ();
}

/* This is different than the standard GAS s_comm(). On HP9000/800 machines,
   the .comm pseudo-op has the following symtax:

   <label> .comm <length>

   where <label> is optional and is a symbol whose address will be the start of
   a block of memory <length> bytes long. <length> must be an absolute
   expression.  <length> bytes will be allocated in the current space
   and subspace.

   Also note the label may not even be on the same line as the .comm.

   This difference in syntax means the colon function will be called
   on the symbol before we arrive in pa_comm.  colon will set a number
   of attributes of the symbol that need to be fixed here.  In particular
   the value, section pointer, fragment pointer, flags, etc.  What
   a pain.

   This also makes error detection all but impossible.  */

static void
pa_comm (unused)
     int unused ATTRIBUTE_UNUSED;
{
  unsigned int size;
  symbolS *symbol;
  label_symbol_struct *label_symbol = pa_get_label ();

  if (label_symbol)
    symbol = label_symbol->lss_label;
  else
    symbol = NULL;

  SKIP_WHITESPACE ();
  size = get_absolute_expression ();

  if (symbol)
    {
      symbol_get_bfdsym (symbol)->flags |= BSF_OBJECT;
      S_SET_VALUE (symbol, size);
      S_SET_SEGMENT (symbol, bfd_und_section_ptr);
      S_SET_EXTERNAL (symbol);

      /* colon() has already set the frag to the current location in the
         current subspace; we need to reset the fragment to the zero address
         fragment.  We also need to reset the segment pointer.  */
      symbol_set_frag (symbol, &zero_address_frag);
    }
  demand_empty_rest_of_line ();
}
#endif /* !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD))) */

/* Process a .END pseudo-op.  */

static void
pa_end (unused)
     int unused ATTRIBUTE_UNUSED;
{
  demand_empty_rest_of_line ();
}

/* Process a .ENTER pseudo-op.  This is not supported.  */
static void
pa_enter (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  as_bad (_("The .ENTER pseudo-op is not supported"));
  demand_empty_rest_of_line ();
}

/* Process a .ENTRY pseudo-op.  .ENTRY marks the beginning of the
   procedure.  */
static void
pa_entry (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  if (!within_procedure)
    as_bad (_("Misplaced .entry. Ignored."));
  else
    {
      if (!callinfo_found)
	as_bad (_("Missing .callinfo."));
    }
  demand_empty_rest_of_line ();
  within_entry_exit = TRUE;

#ifdef OBJ_SOM
  /* SOM defers building of unwind descriptors until the link phase.
     The assembler is responsible for creating an R_ENTRY relocation
     to mark the beginning of a region and hold the unwind bits, and
     for creating an R_EXIT relocation to mark the end of the region.

     FIXME.  ELF should be using the same conventions!  The problem
     is an unwind requires too much relocation space.  Hmmm.  Maybe
     if we split the unwind bits up between the relocations which
     denote the entry and exit points.  */
  if (last_call_info->start_symbol != NULL)
    {
      char *where;
      unsigned int u;

      where = frag_more (0);
      u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
      fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
		    NULL, (offsetT) 0, NULL,
		    0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
    }
#endif
}

/* Silly nonsense for pa_equ.  The only half-sensible use for this is
   being able to subtract two register symbols that specify a range of
   registers, to get the size of the range.  */
static int fudge_reg_expressions;

int
hppa_force_reg_syms_absolute (resultP, op, rightP)
     expressionS *resultP;
     operatorT op ATTRIBUTE_UNUSED;
     expressionS *rightP;
{
  if (fudge_reg_expressions
      && rightP->X_op == O_register
      && resultP->X_op == O_register)
    {
      rightP->X_op = O_constant;
      resultP->X_op = O_constant;
    }
  return 0;  /* Continue normal expr handling.  */
}

/* Handle a .EQU pseudo-op.  */

static void
pa_equ (reg)
     int reg;
{
  label_symbol_struct *label_symbol = pa_get_label ();
  symbolS *symbol;

  if (label_symbol)
    {
      symbol = label_symbol->lss_label;
      if (reg)
	{
	  strict = 1;
	  if (!pa_parse_number (&input_line_pointer, 0))
	    as_bad (_(".REG expression must be a register"));
	  S_SET_VALUE (symbol, pa_number);
	  S_SET_SEGMENT (symbol, reg_section);
	}
      else
	{
	  expressionS exp;
	  segT seg;

	  fudge_reg_expressions = 1;
	  seg = expression (&exp);
	  fudge_reg_expressions = 0;
	  if (exp.X_op != O_constant
	      && exp.X_op != O_register)
	    {
	      if (exp.X_op != O_absent)
		as_bad (_("bad or irreducible absolute expression; zero assumed"));
	      exp.X_add_number = 0;
	      seg = absolute_section;
	    }
	  S_SET_VALUE (symbol, (unsigned int) exp.X_add_number);
	  S_SET_SEGMENT (symbol, seg);
	}
    }
  else
    {
      if (reg)
	as_bad (_(".REG must use a label"));
      else
	as_bad (_(".EQU must use a label"));
    }

  pa_undefine_label ();
  demand_empty_rest_of_line ();
}

/* Helper function.  Does processing for the end of a function.  This
   usually involves creating some relocations or building special
   symbols to mark the end of the function.  */

static void
process_exit ()
{
  char *where;

  where = frag_more (0);

#ifdef OBJ_ELF
  /* Mark the end of the function, stuff away the location of the frag
     for the end of the function, and finally call pa_build_unwind_subspace
     to add an entry in the unwind table.  */
  hppa_elf_mark_end_of_function ();
  pa_build_unwind_subspace (last_call_info);
#else
  /* SOM defers building of unwind descriptors until the link phase.
     The assembler is responsible for creating an R_ENTRY relocation
     to mark the beginning of a region and hold the unwind bits, and
     for creating an R_EXIT relocation to mark the end of the region.

     FIXME.  ELF should be using the same conventions!  The problem
     is an unwind requires too much relocation space.  Hmmm.  Maybe
     if we split the unwind bits up between the relocations which
     denote the entry and exit points.  */
  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
		NULL, (offsetT) 0,
		NULL, 0, R_HPPA_EXIT, e_fsel, 0, 0,
		UNWIND_HIGH32 (&last_call_info->ci_unwind.descriptor));
#endif
}

/* Process a .EXIT pseudo-op.  */

static void
pa_exit (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  if (!within_procedure)
    as_bad (_(".EXIT must appear within a procedure"));
  else
    {
      if (!callinfo_found)
	as_bad (_("Missing .callinfo"));
      else
	{
	  if (!within_entry_exit)
	    as_bad (_("No .ENTRY for this .EXIT"));
	  else
	    {
	      within_entry_exit = FALSE;
	      process_exit ();
	    }
	}
    }
  demand_empty_rest_of_line ();
}

/* Process a .EXPORT directive.  This makes functions external
   and provides information such as argument relocation entries
   to callers.  */

static void
pa_export (unused)
     int unused ATTRIBUTE_UNUSED;
{
  char *name, c, *p;
  symbolS *symbol;

  name = input_line_pointer;
  c = get_symbol_end ();
  /* Make sure the given symbol exists.  */
  if ((symbol = symbol_find_or_make (name)) == NULL)
    {
      as_bad (_("Cannot define export symbol: %s\n"), name);
      p = input_line_pointer;
      *p = c;
      input_line_pointer++;
    }
  else
    {
      /* OK.  Set the external bits and process argument relocations.
         For the HP, weak and global are not mutually exclusive.
         S_SET_EXTERNAL will not set BSF_GLOBAL if WEAK is set.
         Call S_SET_EXTERNAL to get the other processing.  Manually
         set BSF_GLOBAL when we get back.  */
      S_SET_EXTERNAL (symbol);
      symbol_get_bfdsym (symbol)->flags |= BSF_GLOBAL;
      p = input_line_pointer;
      *p = c;
      if (!is_end_of_statement ())
	{
	  input_line_pointer++;
	  pa_type_args (symbol, 1);
	}
    }

  demand_empty_rest_of_line ();
}

/* Helper function to process arguments to a .EXPORT pseudo-op.  */

static void
pa_type_args (symbolP, is_export)
     symbolS *symbolP;
     int is_export;
{
  char *name, c, *p;
  unsigned int temp, arg_reloc;
  pa_symbol_type type = SYMBOL_TYPE_UNKNOWN;
  asymbol *bfdsym = symbol_get_bfdsym (symbolP);

  if (strncasecmp (input_line_pointer, "absolute", 8) == 0)

    {
      input_line_pointer += 8;
      bfdsym->flags &= ~BSF_FUNCTION;
      S_SET_SEGMENT (symbolP, bfd_abs_section_ptr);
      type = SYMBOL_TYPE_ABSOLUTE;
    }
  else if (strncasecmp (input_line_pointer, "code", 4) == 0)
    {
      input_line_pointer += 4;
      /* IMPORTing/EXPORTing CODE types for functions is meaningless for SOM,
         instead one should be IMPORTing/EXPORTing ENTRY types.

         Complain if one tries to EXPORT a CODE type since that's never
         done.  Both GCC and HP C still try to IMPORT CODE types, so
         silently fix them to be ENTRY types.  */
      if (S_IS_FUNCTION (symbolP))
	{
	  if (is_export)
	    as_tsktsk (_("Using ENTRY rather than CODE in export directive for %s"),
		       S_GET_NAME (symbolP));

	  bfdsym->flags |= BSF_FUNCTION;
	  type = SYMBOL_TYPE_ENTRY;
	}
      else
	{
	  bfdsym->flags &= ~BSF_FUNCTION;
	  type = SYMBOL_TYPE_CODE;
	}
    }
  else if (strncasecmp (input_line_pointer, "data", 4) == 0)
    {
      input_line_pointer += 4;
      bfdsym->flags &= ~BSF_FUNCTION;
      bfdsym->flags |= BSF_OBJECT;
      type = SYMBOL_TYPE_DATA;
    }
  else if ((strncasecmp (input_line_pointer, "entry", 5) == 0))
    {
      input_line_pointer += 5;
      bfdsym->flags |= BSF_FUNCTION;
      type = SYMBOL_TYPE_ENTRY;
    }
  else if (strncasecmp (input_line_pointer, "millicode", 9) == 0)
    {
      input_line_pointer += 9;
      bfdsym->flags |= BSF_FUNCTION;
#ifdef OBJ_ELF
      {
	elf_symbol_type *elfsym = (elf_symbol_type *) bfdsym;
	elfsym->internal_elf_sym.st_info =
	  ELF_ST_INFO (ELF_ST_BIND (elfsym->internal_elf_sym.st_info),
		       STT_PARISC_MILLI);
      }
#endif
      type = SYMBOL_TYPE_MILLICODE;
    }
  else if (strncasecmp (input_line_pointer, "plabel", 6) == 0)
    {
      input_line_pointer += 6;
      bfdsym->flags &= ~BSF_FUNCTION;
      type = SYMBOL_TYPE_PLABEL;
    }
  else if (strncasecmp (input_line_pointer, "pri_prog", 8) == 0)
    {
      input_line_pointer += 8;
      bfdsym->flags |= BSF_FUNCTION;
      type = SYMBOL_TYPE_PRI_PROG;
    }
  else if (strncasecmp (input_line_pointer, "sec_prog", 8) == 0)
    {
      input_line_pointer += 8;
      bfdsym->flags |= BSF_FUNCTION;
      type = SYMBOL_TYPE_SEC_PROG;
    }

  /* SOM requires much more information about symbol types
     than BFD understands.  This is how we get this information
     to the SOM BFD backend.  */
#ifdef obj_set_symbol_type
  obj_set_symbol_type (bfdsym, (int) type);
#endif

  /* Now that the type of the exported symbol has been handled,
     handle any argument relocation information.  */
  while (!is_end_of_statement ())
    {
      if (*input_line_pointer == ',')
	input_line_pointer++;
      name = input_line_pointer;
      c = get_symbol_end ();
      /* Argument sources.  */
      if ((strncasecmp (name, "argw", 4) == 0))
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = atoi (name + 4);
	  name = input_line_pointer;
	  c = get_symbol_end ();
	  arg_reloc = pa_align_arg_reloc (temp, pa_build_arg_reloc (name));
#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
	  symbol_arg_reloc_info (symbolP) |= arg_reloc;
#endif
	  *input_line_pointer = c;
	}
      /* The return value.  */
      else if ((strncasecmp (name, "rtnval", 6)) == 0)
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  name = input_line_pointer;
	  c = get_symbol_end ();
	  arg_reloc = pa_build_arg_reloc (name);
#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
	  symbol_arg_reloc_info (symbolP) |= arg_reloc;
#endif
	  *input_line_pointer = c;
	}
      /* Privilege level.  */
      else if ((strncasecmp (name, "priv_lev", 8)) == 0)
	{
	  p = input_line_pointer;
	  *p = c;
	  input_line_pointer++;
	  temp = atoi (input_line_pointer);
#ifdef OBJ_SOM
	  ((obj_symbol_type *) bfdsym)->tc_data.ap.hppa_priv_level = temp;
#endif
	  c = get_symbol_end ();
	  *input_line_pointer = c;
	}
      else
	{
	  as_bad (_("Undefined .EXPORT/.IMPORT argument (ignored): %s"), name);
	  p = input_line_pointer;
	  *p = c;
	}
      if (!is_end_of_statement ())
	input_line_pointer++;
    }
}

/* Handle an .IMPORT pseudo-op.  Any symbol referenced in a given
   assembly file must either be defined in the assembly file, or
   explicitly IMPORTED from another.  */

static void
pa_import (unused)
     int unused ATTRIBUTE_UNUSED;
{
  char *name, c, *p;
  symbolS *symbol;

  name = input_line_pointer;
  c = get_symbol_end ();

  symbol = symbol_find (name);
  /* Ugh.  We might be importing a symbol defined earlier in the file,
     in which case all the code below will really screw things up
     (set the wrong segment, symbol flags & type, etc).  */
  if (symbol == NULL || !S_IS_DEFINED (symbol))
    {
      symbol = symbol_find_or_make (name);
      p = input_line_pointer;
      *p = c;

      if (!is_end_of_statement ())
	{
	  input_line_pointer++;
	  pa_type_args (symbol, 0);
	}
      else
	{
	  /* Sigh.  To be compatible with the HP assembler and to help
	     poorly written assembly code, we assign a type based on
	     the current segment.  Note only BSF_FUNCTION really
	     matters, we do not need to set the full SYMBOL_TYPE_* info.  */
	  if (now_seg == text_section)
	    symbol_get_bfdsym (symbol)->flags |= BSF_FUNCTION;

	  /* If the section is undefined, then the symbol is undefined
	     Since this is an import, leave the section undefined.  */
	  S_SET_SEGMENT (symbol, bfd_und_section_ptr);
	}
    }
  else
    {
      /* The symbol was already defined.  Just eat everything up to
	 the end of the current statement.  */
      while (!is_end_of_statement ())
	input_line_pointer++;
    }

  demand_empty_rest_of_line ();
}

/* Handle a .LABEL pseudo-op.  */

static void
pa_label (unused)
     int unused ATTRIBUTE_UNUSED;
{
  char *name, c, *p;

  name = input_line_pointer;
  c = get_symbol_end ();

  if (strlen (name) > 0)
    {
      colon (name);
      p = input_line_pointer;
      *p = c;
    }
  else
    {
      as_warn (_("Missing label name on .LABEL"));
    }

  if (!is_end_of_statement ())
    {
      as_warn (_("extra .LABEL arguments ignored."));
      ignore_rest_of_line ();
    }
  demand_empty_rest_of_line ();
}

/* Handle a .LEAVE pseudo-op.  This is not supported yet.  */

static void
pa_leave (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  as_bad (_("The .LEAVE pseudo-op is not supported"));
  demand_empty_rest_of_line ();
}

/* Handle a .LEVEL pseudo-op.  */

static void
pa_level (unused)
     int unused ATTRIBUTE_UNUSED;
{
  char *level;

  level = input_line_pointer;
  if (strncmp (level, "1.0", 3) == 0)
    {
      input_line_pointer += 3;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 10))
	as_warn (_("could not set architecture and machine"));
    }
  else if (strncmp (level, "1.1", 3) == 0)
    {
      input_line_pointer += 3;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 11))
	as_warn (_("could not set architecture and machine"));
    }
  else if (strncmp (level, "2.0w", 4) == 0)
    {
      input_line_pointer += 4;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 25))
	as_warn (_("could not set architecture and machine"));
    }
  else if (strncmp (level, "2.0", 3) == 0)
    {
      input_line_pointer += 3;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 20))
	as_warn (_("could not set architecture and machine"));
    }
  else
    {
      as_bad (_("Unrecognized .LEVEL argument\n"));
      ignore_rest_of_line ();
    }
  demand_empty_rest_of_line ();
}

/* Handle a .ORIGIN pseudo-op.  */

static void
pa_origin (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  s_org (0);
  pa_undefine_label ();
}

/* Handle a .PARAM pseudo-op.  This is much like a .EXPORT, except it
   is for static functions.  FIXME.  Should share more code with .EXPORT.  */

static void
pa_param (unused)
     int unused ATTRIBUTE_UNUSED;
{
  char *name, c, *p;
  symbolS *symbol;

  name = input_line_pointer;
  c = get_symbol_end ();

  if ((symbol = symbol_find_or_make (name)) == NULL)
    {
      as_bad (_("Cannot define static symbol: %s\n"), name);
      p = input_line_pointer;
      *p = c;
      input_line_pointer++;
    }
  else
    {
      S_CLEAR_EXTERNAL (symbol);
      p = input_line_pointer;
      *p = c;
      if (!is_end_of_statement ())
	{
	  input_line_pointer++;
	  pa_type_args (symbol, 0);
	}
    }

  demand_empty_rest_of_line ();
}

/* Handle a .PROC pseudo-op.  It is used to mark the beginning
   of a procedure from a syntactical point of view.  */

static void
pa_proc (unused)
     int unused ATTRIBUTE_UNUSED;
{
  struct call_info *call_info;

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  if (within_procedure)
    as_fatal (_("Nested procedures"));

  /* Reset global variables for new procedure.  */
  callinfo_found = FALSE;
  within_procedure = TRUE;

  /* Create another call_info structure.  */
  call_info = (struct call_info *) xmalloc (sizeof (struct call_info));

  if (!call_info)
    as_fatal (_("Cannot allocate unwind descriptor\n"));

  memset (call_info, 0, sizeof (struct call_info));

  call_info->ci_next = NULL;

  if (call_info_root == NULL)
    {
      call_info_root = call_info;
      last_call_info = call_info;
    }
  else
    {
      last_call_info->ci_next = call_info;
      last_call_info = call_info;
    }

  /* set up defaults on call_info structure */

  call_info->ci_unwind.descriptor.cannot_unwind = 0;
  call_info->ci_unwind.descriptor.region_desc = 1;
  call_info->ci_unwind.descriptor.hpux_interrupt_marker = 0;

  /* If we got a .PROC pseudo-op, we know that the function is defined
     locally.  Make sure it gets into the symbol table.  */
  {
    label_symbol_struct *label_symbol = pa_get_label ();

    if (label_symbol)
      {
	if (label_symbol->lss_label)
	  {
	    last_call_info->start_symbol = label_symbol->lss_label;
	    symbol_get_bfdsym (label_symbol->lss_label)->flags |= BSF_FUNCTION;
	  }
	else
	  as_bad (_("Missing function name for .PROC (corrupted label chain)"));
      }
    else
      last_call_info->start_symbol = NULL;
  }

  demand_empty_rest_of_line ();
}

/* Process the syntactical end of a procedure.  Make sure all the
   appropriate pseudo-ops were found within the procedure.  */

static void
pa_procend (unused)
     int unused ATTRIBUTE_UNUSED;
{

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  /* If we are within a procedure definition, make sure we've
     defined a label for the procedure; handle case where the
     label was defined after the .PROC directive.

     Note there's not need to diddle with the segment or fragment
     for the label symbol in this case.  We have already switched
     into the new $CODE$ subspace at this point.  */
  if (within_procedure && last_call_info->start_symbol == NULL)
    {
      label_symbol_struct *label_symbol = pa_get_label ();

      if (label_symbol)
	{
	  if (label_symbol->lss_label)
	    {
	      last_call_info->start_symbol = label_symbol->lss_label;
	      symbol_get_bfdsym (label_symbol->lss_label)->flags
		|= BSF_FUNCTION;
#ifdef OBJ_SOM
	      /* Also handle allocation of a fixup to hold the unwind
		 information when the label appears after the proc/procend.  */
	      if (within_entry_exit)
		{
		  char *where;
		  unsigned int u;

		  where = frag_more (0);
		  u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
		  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
				NULL, (offsetT) 0, NULL,
				0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
		}
#endif
	    }
	  else
	    as_bad (_("Missing function name for .PROC (corrupted label chain)"));
	}
      else
	as_bad (_("Missing function name for .PROC"));
    }

  if (!within_procedure)
    as_bad (_("misplaced .procend"));

  if (!callinfo_found)
    as_bad (_("Missing .callinfo for this procedure"));

  if (within_entry_exit)
    as_bad (_("Missing .EXIT for a .ENTRY"));

#ifdef OBJ_ELF
  /* ELF needs to mark the end of each function so that it can compute
     the size of the function (apparently its needed in the symbol table).  */
  hppa_elf_mark_end_of_function ();
#endif

  within_procedure = FALSE;
  demand_empty_rest_of_line ();
  pa_undefine_label ();
}

#ifdef OBJ_SOM
/* If VALUE is an exact power of two between zero and 2^31, then
   return log2 (VALUE).  Else return -1.  */

static int
log2 (value)
     int value;
{
  int shift = 0;

  while ((1 << shift) != value && shift < 32)
    shift++;

  if (shift >= 32)
    return -1;
  else
    return shift;
}

/* Check to make sure we have a valid space and subspace.  */

static void
pa_check_current_space_and_subspace ()
{
  if (current_space == NULL)
    as_fatal (_("Not in a space.\n"));

  if (current_subspace == NULL)
    as_fatal (_("Not in a subspace.\n"));
}

/* Parse the parameters to a .SPACE directive; if CREATE_FLAG is nonzero,
   then create a new space entry to hold the information specified
   by the parameters to the .SPACE directive.  */

static sd_chain_struct *
pa_parse_space_stmt (space_name, create_flag)
     char *space_name;
     int create_flag;
{
  char *name, *ptemp, c;
  char loadable, defined, private, sort;
  int spnum;
  asection *seg = NULL;
  sd_chain_struct *space;

  /* load default values */
  spnum = 0;
  sort = 0;
  loadable = TRUE;
  defined = TRUE;
  private = FALSE;
  if (strcmp (space_name, "$TEXT$") == 0)
    {
      seg = pa_def_spaces[0].segment;
      defined = pa_def_spaces[0].defined;
      private = pa_def_spaces[0].private;
      sort = pa_def_spaces[0].sort;
      spnum = pa_def_spaces[0].spnum;
    }
  else if (strcmp (space_name, "$PRIVATE$") == 0)
    {
      seg = pa_def_spaces[1].segment;
      defined = pa_def_spaces[1].defined;
      private = pa_def_spaces[1].private;
      sort = pa_def_spaces[1].sort;
      spnum = pa_def_spaces[1].spnum;
    }

  if (!is_end_of_statement ())
    {
      print_errors = FALSE;
      ptemp = input_line_pointer + 1;
      /* First see if the space was specified as a number rather than
         as a name.  According to the PA assembly manual the rest of
         the line should be ignored.  */
      strict = 0;
      pa_parse_number (&ptemp, 0);
      if (pa_number >= 0)
	{
	  spnum = pa_number;
	  input_line_pointer = ptemp;
	}
      else
	{
	  while (!is_end_of_statement ())
	    {
	      input_line_pointer++;
	      name = input_line_pointer;
	      c = get_symbol_end ();
	      if ((strncasecmp (name, "spnum", 5) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  spnum = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "sort", 4) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  sort = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "unloadable", 10) == 0))
		{
		  *input_line_pointer = c;
		  loadable = FALSE;
		}
	      else if ((strncasecmp (name, "notdefined", 10) == 0))
		{
		  *input_line_pointer = c;
		  defined = FALSE;
		}
	      else if ((strncasecmp (name, "private", 7) == 0))
		{
		  *input_line_pointer = c;
		  private = TRUE;
		}
	      else
		{
		  as_bad (_("Invalid .SPACE argument"));
		  *input_line_pointer = c;
		  if (!is_end_of_statement ())
		    input_line_pointer++;
		}
	    }
	}
      print_errors = TRUE;
    }

  if (create_flag && seg == NULL)
    seg = subseg_new (space_name, 0);

  /* If create_flag is nonzero, then create the new space with
     the attributes computed above.  Else set the values in
     an already existing space -- this can only happen for
     the first occurrence of a built-in space.  */
  if (create_flag)
    space = create_new_space (space_name, spnum, loadable, defined,
			      private, sort, seg, 1);
  else
    {
      space = is_defined_space (space_name);
      SPACE_SPNUM (space) = spnum;
      SPACE_DEFINED (space) = defined & 1;
      SPACE_USER_DEFINED (space) = 1;
    }

#ifdef obj_set_section_attributes
  obj_set_section_attributes (seg, defined, private, sort, spnum);
#endif

  return space;
}

/* Handle a .SPACE pseudo-op; this switches the current space to the
   given space, creating the new space if necessary.  */

static void
pa_space (unused)
     int unused ATTRIBUTE_UNUSED;
{
  char *name, c, *space_name, *save_s;
  sd_chain_struct *sd_chain;

  if (within_procedure)
    {
      as_bad (_("Can\'t change spaces within a procedure definition. Ignored"));
      ignore_rest_of_line ();
    }
  else
    {
      /* Check for some of the predefined spaces.   FIXME: most of the code
         below is repeated several times, can we extract the common parts
         and place them into a subroutine or something similar?  */
      /* FIXME Is this (and the next IF stmt) really right?
	 What if INPUT_LINE_POINTER points to "$TEXT$FOO"?  */
      if (strncmp (input_line_pointer, "$TEXT$", 6) == 0)
	{
	  input_line_pointer += 6;
	  sd_chain = is_defined_space ("$TEXT$");
	  if (sd_chain == NULL)
	    sd_chain = pa_parse_space_stmt ("$TEXT$", 1);
	  else if (SPACE_USER_DEFINED (sd_chain) == 0)
	    sd_chain = pa_parse_space_stmt ("$TEXT$", 0);

	  current_space = sd_chain;
	  subseg_set (text_section, sd_chain->sd_last_subseg);
	  current_subspace
	    = pa_subsegment_to_subspace (text_section,
					 sd_chain->sd_last_subseg);
	  demand_empty_rest_of_line ();
	  return;
	}
      if (strncmp (input_line_pointer, "$PRIVATE$", 9) == 0)
	{
	  input_line_pointer += 9;
	  sd_chain = is_defined_space ("$PRIVATE$");
	  if (sd_chain == NULL)
	    sd_chain = pa_parse_space_stmt ("$PRIVATE$", 1);
	  else if (SPACE_USER_DEFINED (sd_chain) == 0)
	    sd_chain = pa_parse_space_stmt ("$PRIVATE$", 0);

	  current_space = sd_chain;
	  subseg_set (data_section, sd_chain->sd_last_subseg);
	  current_subspace
	    = pa_subsegment_to_subspace (data_section,
					 sd_chain->sd_last_subseg);
	  demand_empty_rest_of_line ();
	  return;
	}
      if (!strncasecmp (input_line_pointer,
			GDB_DEBUG_SPACE_NAME,
			strlen (GDB_DEBUG_SPACE_NAME)))
	{
	  input_line_pointer += strlen (GDB_DEBUG_SPACE_NAME);
	  sd_chain = is_defined_space (GDB_DEBUG_SPACE_NAME);
	  if (sd_chain == NULL)
	    sd_chain = pa_parse_space_stmt (GDB_DEBUG_SPACE_NAME, 1);
	  else if (SPACE_USER_DEFINED (sd_chain) == 0)
	    sd_chain = pa_parse_space_stmt (GDB_DEBUG_SPACE_NAME, 0);

	  current_space = sd_chain;

	  {
	    asection *gdb_section
	    = bfd_make_section_old_way (stdoutput, GDB_DEBUG_SPACE_NAME);

	    subseg_set (gdb_section, sd_chain->sd_last_subseg);
	    current_subspace
	      = pa_subsegment_to_subspace (gdb_section,
					   sd_chain->sd_last_subseg);
	  }
	  demand_empty_rest_of_line ();
	  return;
	}

      /* It could be a space specified by number.  */
      print_errors = 0;
      save_s = input_line_pointer;
      strict = 0;
      pa_parse_number (&input_line_pointer, 0);
      if (pa_number >= 0)
	{
	  if ((sd_chain = pa_find_space_by_number (pa_number)))
	    {
	      current_space = sd_chain;

	      subseg_set (sd_chain->sd_seg, sd_chain->sd_last_subseg);
	      current_subspace
		= pa_subsegment_to_subspace (sd_chain->sd_seg,
					     sd_chain->sd_last_subseg);
	      demand_empty_rest_of_line ();
	      return;
	    }
	}

      /* Not a number, attempt to create a new space.  */
      print_errors = 1;
      input_line_pointer = save_s;
      name = input_line_pointer;
      c = get_symbol_end ();
      space_name = xmalloc (strlen (name) + 1);
      strcpy (space_name, name);
      *input_line_pointer = c;

      sd_chain = pa_parse_space_stmt (space_name, 1);
      current_space = sd_chain;

      subseg_set (sd_chain->sd_seg, sd_chain->sd_last_subseg);
      current_subspace = pa_subsegment_to_subspace (sd_chain->sd_seg,
						  sd_chain->sd_last_subseg);
      demand_empty_rest_of_line ();
    }
}

/* Switch to a new space.  (I think).  FIXME.  */

static void
pa_spnum (unused)
     int unused ATTRIBUTE_UNUSED;
{
  char *name;
  char c;
  char *p;
  sd_chain_struct *space;

  name = input_line_pointer;
  c = get_symbol_end ();
  space = is_defined_space (name);
  if (space)
    {
      p = frag_more (4);
      md_number_to_chars (p, SPACE_SPNUM (space), 4);
    }
  else
    as_warn (_("Undefined space: '%s' Assuming space number = 0."), name);

  *input_line_pointer = c;
  demand_empty_rest_of_line ();
}

/* Handle a .SUBSPACE pseudo-op; this switches the current subspace to the
   given subspace, creating the new subspace if necessary.

   FIXME.  Should mirror pa_space more closely, in particular how
   they're broken up into subroutines.  */

static void
pa_subspace (create_new)
     int create_new;
{
  char *name, *ss_name, c;
  char loadable, code_only, common, dup_common, zero, sort;
  int i, access, space_index, alignment, quadrant, applicable, flags;
  sd_chain_struct *space;
  ssd_chain_struct *ssd;
  asection *section;

  if (current_space == NULL)
    as_fatal (_("Must be in a space before changing or declaring subspaces.\n"));

  if (within_procedure)
    {
      as_bad (_("Can\'t change subspaces within a procedure definition. Ignored"));
      ignore_rest_of_line ();
    }
  else
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      ss_name = xmalloc (strlen (name) + 1);
      strcpy (ss_name, name);
      *input_line_pointer = c;

      /* Load default values.  */
      sort = 0;
      access = 0x7f;
      loadable = 1;
      common = 0;
      dup_common = 0;
      code_only = 0;
      zero = 0;
      space_index = ~0;
      alignment = 1;
      quadrant = 0;

      space = current_space;
      if (create_new)
	ssd = NULL;
      else
	ssd = is_defined_subspace (ss_name);
      /* Allow user to override the builtin attributes of subspaces.  But
         only allow the attributes to be changed once!  */
      if (ssd && SUBSPACE_DEFINED (ssd))
	{
	  subseg_set (ssd->ssd_seg, ssd->ssd_subseg);
	  current_subspace = ssd;
	  if (!is_end_of_statement ())
	    as_warn (_("Parameters of an existing subspace can\'t be modified"));
	  demand_empty_rest_of_line ();
	  return;
	}
      else
	{
	  /* A new subspace.  Load default values if it matches one of
	     the builtin subspaces.  */
	  i = 0;
	  while (pa_def_subspaces[i].name)
	    {
	      if (strcasecmp (pa_def_subspaces[i].name, ss_name) == 0)
		{
		  loadable = pa_def_subspaces[i].loadable;
		  common = pa_def_subspaces[i].common;
		  dup_common = pa_def_subspaces[i].dup_common;
		  code_only = pa_def_subspaces[i].code_only;
		  zero = pa_def_subspaces[i].zero;
		  space_index = pa_def_subspaces[i].space_index;
		  alignment = pa_def_subspaces[i].alignment;
		  quadrant = pa_def_subspaces[i].quadrant;
		  access = pa_def_subspaces[i].access;
		  sort = pa_def_subspaces[i].sort;
		  break;
		}
	      i++;
	    }
	}

      /* We should be working with a new subspace now.  Fill in
         any information as specified by the user.  */
      if (!is_end_of_statement ())
	{
	  input_line_pointer++;
	  while (!is_end_of_statement ())
	    {
	      name = input_line_pointer;
	      c = get_symbol_end ();
	      if ((strncasecmp (name, "quad", 4) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  quadrant = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "align", 5) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  alignment = get_absolute_expression ();
		  if (log2 (alignment) == -1)
		    {
		      as_bad (_("Alignment must be a power of 2"));
		      alignment = 1;
		    }
		}
	      else if ((strncasecmp (name, "access", 6) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  access = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "sort", 4) == 0))
		{
		  *input_line_pointer = c;
		  input_line_pointer++;
		  sort = get_absolute_expression ();
		}
	      else if ((strncasecmp (name, "code_only", 9) == 0))
		{
		  *input_line_pointer = c;
		  code_only = 1;
		}
	      else if ((strncasecmp (name, "unloadable", 10) == 0))
		{
		  *input_line_pointer = c;
		  loadable = 0;
		}
	      else if ((strncasecmp (name, "common", 6) == 0))
		{
		  *input_line_pointer = c;
		  common = 1;
		}
	      else if ((strncasecmp (name, "dup_comm", 8) == 0))
		{
		  *input_line_pointer = c;
		  dup_common = 1;
		}
	      else if ((strncasecmp (name, "zero", 4) == 0))
		{
		  *input_line_pointer = c;
		  zero = 1;
		}
	      else if ((strncasecmp (name, "first", 5) == 0))
		as_bad (_("FIRST not supported as a .SUBSPACE argument"));
	      else
		as_bad (_("Invalid .SUBSPACE argument"));
	      if (!is_end_of_statement ())
		input_line_pointer++;
	    }
	}

      /* Compute a reasonable set of BFD flags based on the information
         in the .subspace directive.  */
      applicable = bfd_applicable_section_flags (stdoutput);
      flags = 0;
      if (loadable)
	flags |= (SEC_ALLOC | SEC_LOAD);
      if (code_only)
	flags |= SEC_CODE;
      if (common || dup_common)
	flags |= SEC_IS_COMMON;

      flags |= SEC_RELOC | SEC_HAS_CONTENTS;

      /* This is a zero-filled subspace (eg BSS).  */
      if (zero)
	flags &= ~(SEC_LOAD | SEC_HAS_CONTENTS);

      applicable &= flags;

      /* If this is an existing subspace, then we want to use the
         segment already associated with the subspace.

         FIXME NOW!  ELF BFD doesn't appear to be ready to deal with
         lots of sections.  It might be a problem in the PA ELF
         code, I do not know yet.  For now avoid creating anything
         but the "standard" sections for ELF.  */
      if (create_new)
	section = subseg_force_new (ss_name, 0);
      else if (ssd)
	section = ssd->ssd_seg;
      else
	section = subseg_new (ss_name, 0);

      if (zero)
	seg_info (section)->bss = 1;

      /* Now set the flags.  */
      bfd_set_section_flags (stdoutput, section, applicable);

      /* Record any alignment request for this section.  */
      record_alignment (section, log2 (alignment));

      /* Set the starting offset for this section.  */
      bfd_set_section_vma (stdoutput, section,
			   pa_subspace_start (space, quadrant));

      /* Now that all the flags are set, update an existing subspace,
         or create a new one.  */
      if (ssd)

	current_subspace = update_subspace (space, ss_name, loadable,
					    code_only, common, dup_common,
					    sort, zero, access, space_index,
					    alignment, quadrant,
					    section);
      else
	current_subspace = create_new_subspace (space, ss_name, loadable,
						code_only, common,
						dup_common, zero, sort,
						access, space_index,
					      alignment, quadrant, section);

      demand_empty_rest_of_line ();
      current_subspace->ssd_seg = section;
      subseg_set (current_subspace->ssd_seg, current_subspace->ssd_subseg);
    }
  SUBSPACE_DEFINED (current_subspace) = 1;
}

/* Create default space and subspace dictionaries.  */

static void
pa_spaces_begin ()
{
  int i;

  space_dict_root = NULL;
  space_dict_last = NULL;

  i = 0;
  while (pa_def_spaces[i].name)
    {
      char *name;

      /* Pick the right name to use for the new section.  */
      name = pa_def_spaces[i].name;

      pa_def_spaces[i].segment = subseg_new (name, 0);
      create_new_space (pa_def_spaces[i].name, pa_def_spaces[i].spnum,
			pa_def_spaces[i].loadable, pa_def_spaces[i].defined,
			pa_def_spaces[i].private, pa_def_spaces[i].sort,
			pa_def_spaces[i].segment, 0);
      i++;
    }

  i = 0;
  while (pa_def_subspaces[i].name)
    {
      char *name;
      int applicable, subsegment;
      asection *segment = NULL;
      sd_chain_struct *space;

      /* Pick the right name for the new section and pick the right
         subsegment number.  */
      name = pa_def_subspaces[i].name;
      subsegment = 0;

      /* Create the new section.  */
      segment = subseg_new (name, subsegment);

      /* For SOM we want to replace the standard .text, .data, and .bss
         sections with our own.   We also want to set BFD flags for
	 all the built-in subspaces.  */
      if (!strcmp (pa_def_subspaces[i].name, "$CODE$"))
	{
	  text_section = segment;
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC | SEC_CODE
					       | SEC_READONLY
					       | SEC_HAS_CONTENTS));
	}
      else if (!strcmp (pa_def_subspaces[i].name, "$DATA$"))
	{
	  data_section = segment;
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC
					       | SEC_HAS_CONTENTS));

	}
      else if (!strcmp (pa_def_subspaces[i].name, "$BSS$"))
	{
	  bss_section = segment;
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & SEC_ALLOC);
	}
      else if (!strcmp (pa_def_subspaces[i].name, "$LIT$"))
	{
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC
					       | SEC_READONLY
					       | SEC_HAS_CONTENTS));
	}
      else if (!strcmp (pa_def_subspaces[i].name, "$MILLICODE$"))
	{
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC
					       | SEC_READONLY
					       | SEC_HAS_CONTENTS));
	}
      else if (!strcmp (pa_def_subspaces[i].name, "$UNWIND$"))
	{
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC
					       | SEC_READONLY
					       | SEC_HAS_CONTENTS));
	}

      /* Find the space associated with this subspace.  */
      space = pa_segment_to_space (pa_def_spaces[pa_def_subspaces[i].
						 def_space_index].segment);
      if (space == NULL)
	{
	  as_fatal (_("Internal error: Unable to find containing space for %s."),
		    pa_def_subspaces[i].name);
	}

      create_new_subspace (space, name,
			   pa_def_subspaces[i].loadable,
			   pa_def_subspaces[i].code_only,
			   pa_def_subspaces[i].common,
			   pa_def_subspaces[i].dup_common,
			   pa_def_subspaces[i].zero,
			   pa_def_subspaces[i].sort,
			   pa_def_subspaces[i].access,
			   pa_def_subspaces[i].space_index,
			   pa_def_subspaces[i].alignment,
			   pa_def_subspaces[i].quadrant,
			   segment);
      i++;
    }
}

/* Create a new space NAME, with the appropriate flags as defined
   by the given parameters.  */

static sd_chain_struct *
create_new_space (name, spnum, loadable, defined, private,
		  sort, seg, user_defined)
     char *name;
     int spnum;
     int loadable;
     int defined;
     int private;
     int sort;
     asection *seg;
     int user_defined;
{
  sd_chain_struct *chain_entry;

  chain_entry = (sd_chain_struct *) xmalloc (sizeof (sd_chain_struct));
  if (!chain_entry)
    as_fatal (_("Out of memory: could not allocate new space chain entry: %s\n"),
	      name);

  SPACE_NAME (chain_entry) = (char *) xmalloc (strlen (name) + 1);
  strcpy (SPACE_NAME (chain_entry), name);
  SPACE_DEFINED (chain_entry) = defined;
  SPACE_USER_DEFINED (chain_entry) = user_defined;
  SPACE_SPNUM (chain_entry) = spnum;

  chain_entry->sd_seg = seg;
  chain_entry->sd_last_subseg = -1;
  chain_entry->sd_subspaces = NULL;
  chain_entry->sd_next = NULL;

  /* Find spot for the new space based on its sort key.  */
  if (!space_dict_last)
    space_dict_last = chain_entry;

  if (space_dict_root == NULL)
    space_dict_root = chain_entry;
  else
    {
      sd_chain_struct *chain_pointer;
      sd_chain_struct *prev_chain_pointer;

      chain_pointer = space_dict_root;
      prev_chain_pointer = NULL;

      while (chain_pointer)
	{
	  prev_chain_pointer = chain_pointer;
	  chain_pointer = chain_pointer->sd_next;
	}

      /* At this point we've found the correct place to add the new
         entry.  So add it and update the linked lists as appropriate.  */
      if (prev_chain_pointer)
	{
	  chain_entry->sd_next = chain_pointer;
	  prev_chain_pointer->sd_next = chain_entry;
	}
      else
	{
	  space_dict_root = chain_entry;
	  chain_entry->sd_next = chain_pointer;
	}

      if (chain_entry->sd_next == NULL)
	space_dict_last = chain_entry;
    }

  /* This is here to catch predefined spaces which do not get
     modified by the user's input.  Another call is found at
     the bottom of pa_parse_space_stmt to handle cases where
     the user modifies a predefined space.  */
#ifdef obj_set_section_attributes
  obj_set_section_attributes (seg, defined, private, sort, spnum);
#endif

  return chain_entry;
}

/* Create a new subspace NAME, with the appropriate flags as defined
   by the given parameters.

   Add the new subspace to the subspace dictionary chain in numerical
   order as defined by the SORT entries.  */

static ssd_chain_struct *
create_new_subspace (space, name, loadable, code_only, common,
		     dup_common, is_zero, sort, access, space_index,
		     alignment, quadrant, seg)
     sd_chain_struct *space;
     char *name;
     int loadable, code_only, common, dup_common, is_zero;
     int sort;
     int access;
     int space_index;
     int alignment;
     int quadrant;
     asection *seg;
{
  ssd_chain_struct *chain_entry;

  chain_entry = (ssd_chain_struct *) xmalloc (sizeof (ssd_chain_struct));
  if (!chain_entry)
    as_fatal (_("Out of memory: could not allocate new subspace chain entry: %s\n"), name);

  SUBSPACE_NAME (chain_entry) = (char *) xmalloc (strlen (name) + 1);
  strcpy (SUBSPACE_NAME (chain_entry), name);

  /* Initialize subspace_defined.  When we hit a .subspace directive
     we'll set it to 1 which "locks-in" the subspace attributes.  */
  SUBSPACE_DEFINED (chain_entry) = 0;

  chain_entry->ssd_subseg = 0;
  chain_entry->ssd_seg = seg;
  chain_entry->ssd_next = NULL;

  /* Find spot for the new subspace based on its sort key.  */
  if (space->sd_subspaces == NULL)
    space->sd_subspaces = chain_entry;
  else
    {
      ssd_chain_struct *chain_pointer;
      ssd_chain_struct *prev_chain_pointer;

      chain_pointer = space->sd_subspaces;
      prev_chain_pointer = NULL;

      while (chain_pointer)
	{
	  prev_chain_pointer = chain_pointer;
	  chain_pointer = chain_pointer->ssd_next;
	}

      /* Now we have somewhere to put the new entry.  Insert it and update
         the links.  */
      if (prev_chain_pointer)
	{
	  chain_entry->ssd_next = chain_pointer;
	  prev_chain_pointer->ssd_next = chain_entry;
	}
      else
	{
	  space->sd_subspaces = chain_entry;
	  chain_entry->ssd_next = chain_pointer;
	}
    }

#ifdef obj_set_subsection_attributes
  obj_set_subsection_attributes (seg, space->sd_seg, access,
				 sort, quadrant);
#endif

  return chain_entry;
}

/* Update the information for the given subspace based upon the
   various arguments.   Return the modified subspace chain entry.  */

static ssd_chain_struct *
update_subspace (space, name, loadable, code_only, common, dup_common, sort,
		 zero, access, space_index, alignment, quadrant, section)
     sd_chain_struct *space;
     char *name;
     int loadable;
     int code_only;
     int common;
     int dup_common;
     int zero;
     int sort;
     int access;
     int space_index;
     int alignment;
     int quadrant;
     asection *section;
{
  ssd_chain_struct *chain_entry;

  chain_entry = is_defined_subspace (name);

#ifdef obj_set_subsection_attributes
  obj_set_subsection_attributes (section, space->sd_seg, access,
				 sort, quadrant);
#endif

  return chain_entry;
}

/* Return the space chain entry for the space with the name NAME or
   NULL if no such space exists.  */

static sd_chain_struct *
is_defined_space (name)
     char *name;
{
  sd_chain_struct *chain_pointer;

  for (chain_pointer = space_dict_root;
       chain_pointer;
       chain_pointer = chain_pointer->sd_next)
    {
      if (strcmp (SPACE_NAME (chain_pointer), name) == 0)
	return chain_pointer;
    }

  /* No mapping from segment to space was found.  Return NULL.  */
  return NULL;
}

/* Find and return the space associated with the given seg.  If no mapping
   from the given seg to a space is found, then return NULL.

   Unlike subspaces, the number of spaces is not expected to grow much,
   so a linear exhaustive search is OK here.  */

static sd_chain_struct *
pa_segment_to_space (seg)
     asection *seg;
{
  sd_chain_struct *space_chain;

  /* Walk through each space looking for the correct mapping.  */
  for (space_chain = space_dict_root;
       space_chain;
       space_chain = space_chain->sd_next)
    {
      if (space_chain->sd_seg == seg)
	return space_chain;
    }

  /* Mapping was not found.  Return NULL.  */
  return NULL;
}

/* Return the space chain entry for the subspace with the name NAME or
   NULL if no such subspace exists.

   Uses a linear search through all the spaces and subspaces, this may
   not be appropriate if we ever being placing each function in its
   own subspace.  */

static ssd_chain_struct *
is_defined_subspace (name)
     char *name;
{
  sd_chain_struct *space_chain;
  ssd_chain_struct *subspace_chain;

  /* Walk through each space.  */
  for (space_chain = space_dict_root;
       space_chain;
       space_chain = space_chain->sd_next)
    {
      /* Walk through each subspace looking for a name which matches.  */
      for (subspace_chain = space_chain->sd_subspaces;
	   subspace_chain;
	   subspace_chain = subspace_chain->ssd_next)
	if (strcmp (SUBSPACE_NAME (subspace_chain), name) == 0)
	  return subspace_chain;
    }

  /* Subspace wasn't found.  Return NULL.  */
  return NULL;
}

/* Find and return the subspace associated with the given seg.  If no
   mapping from the given seg to a subspace is found, then return NULL.

   If we ever put each procedure/function within its own subspace
   (to make life easier on the compiler and linker), then this will have
   to become more efficient.  */

static ssd_chain_struct *
pa_subsegment_to_subspace (seg, subseg)
     asection *seg;
     subsegT subseg;
{
  sd_chain_struct *space_chain;
  ssd_chain_struct *subspace_chain;

  /* Walk through each space.  */
  for (space_chain = space_dict_root;
       space_chain;
       space_chain = space_chain->sd_next)
    {
      if (space_chain->sd_seg == seg)
	{
	  /* Walk through each subspace within each space looking for
	     the correct mapping.  */
	  for (subspace_chain = space_chain->sd_subspaces;
	       subspace_chain;
	       subspace_chain = subspace_chain->ssd_next)
	    if (subspace_chain->ssd_subseg == (int) subseg)
	      return subspace_chain;
	}
    }

  /* No mapping from subsegment to subspace found.  Return NULL.  */
  return NULL;
}

/* Given a number, try and find a space with the name number.

   Return a pointer to a space dictionary chain entry for the space
   that was found or NULL on failure.  */

static sd_chain_struct *
pa_find_space_by_number (number)
     int number;
{
  sd_chain_struct *space_chain;

  for (space_chain = space_dict_root;
       space_chain;
       space_chain = space_chain->sd_next)
    {
      if (SPACE_SPNUM (space_chain) == (unsigned int) number)
	return space_chain;
    }

  /* No appropriate space found.  Return NULL.  */
  return NULL;
}

/* Return the starting address for the given subspace.  If the starting
   address is unknown then return zero.  */

static unsigned int
pa_subspace_start (space, quadrant)
     sd_chain_struct *space;
     int quadrant;
{
  /* FIXME.  Assumes everyone puts read/write data at 0x4000000, this
     is not correct for the PA OSF1 port.  */
  if ((strcmp (SPACE_NAME (space), "$PRIVATE$") == 0) && quadrant == 1)
    return 0x40000000;
  else if (space->sd_seg == data_section && quadrant == 1)
    return 0x40000000;
  else
    return 0;
  return 0;
}

/* FIXME.  Needs documentation.  */
static int
pa_next_subseg (space)
     sd_chain_struct *space;
{

  space->sd_last_subseg++;
  return space->sd_last_subseg;
}
#endif

/* Helper function for pa_stringer.  Used to find the end of
   a string.  */

static unsigned int
pa_stringer_aux (s)
     char *s;
{
  unsigned int c = *s & CHAR_MASK;

  switch (c)
    {
    case '\"':
      c = NOT_A_CHAR;
      break;
    default:
      break;
    }
  return c;
}

/* Handle a .STRING type pseudo-op.  */

static void
pa_stringer (append_zero)
     int append_zero;
{
  char *s, num_buf[4];
  unsigned int c;
  int i;

  /* Preprocess the string to handle PA-specific escape sequences.
     For example, \xDD where DD is a hexadecimal number should be
     changed to \OOO where OOO is an octal number.  */

#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  /* Skip the opening quote.  */
  s = input_line_pointer + 1;

  while (is_a_char (c = pa_stringer_aux (s++)))
    {
      if (c == '\\')
	{
	  c = *s;
	  switch (c)
	    {
	      /* Handle \x<num>.  */
	    case 'x':
	      {
		unsigned int number;
		int num_digit;
		char dg;
		char *s_start = s;

		/* Get past the 'x'.  */
		s++;
		for (num_digit = 0, number = 0, dg = *s;
		     num_digit < 2
		     && (ISDIGIT (dg) || (dg >= 'a' && dg <= 'f')
			 || (dg >= 'A' && dg <= 'F'));
		     num_digit++)
		  {
		    if (ISDIGIT (dg))
		      number = number * 16 + dg - '0';
		    else if (dg >= 'a' && dg <= 'f')
		      number = number * 16 + dg - 'a' + 10;
		    else
		      number = number * 16 + dg - 'A' + 10;

		    s++;
		    dg = *s;
		  }
		if (num_digit > 0)
		  {
		    switch (num_digit)
		      {
		      case 1:
			sprintf (num_buf, "%02o", number);
			break;
		      case 2:
			sprintf (num_buf, "%03o", number);
			break;
		      }
		    for (i = 0; i <= num_digit; i++)
		      s_start[i] = num_buf[i];
		  }
		break;
	      }
	    /* This might be a "\"", skip over the escaped char.  */
	    default:
	      s++;
	      break;
	    }
	}
    }
  stringer (append_zero);
  pa_undefine_label ();
}

/* Handle a .VERSION pseudo-op.  */

static void
pa_version (unused)
     int unused ATTRIBUTE_UNUSED;
{
  obj_version (0);
  pa_undefine_label ();
}

#ifdef OBJ_SOM

/* Handle a .COMPILER pseudo-op.  */

static void
pa_compiler (unused)
     int unused ATTRIBUTE_UNUSED;
{
  obj_som_compiler (0);
  pa_undefine_label ();
}

#endif

/* Handle a .COPYRIGHT pseudo-op.  */

static void
pa_copyright (unused)
     int unused ATTRIBUTE_UNUSED;
{
  obj_copyright (0);
  pa_undefine_label ();
}

/* Just like a normal cons, but when finished we have to undefine
   the latest space label.  */

static void
pa_cons (nbytes)
     int nbytes;
{
  cons (nbytes);
  pa_undefine_label ();
}

/* Like float_cons, but we need to undefine our label.  */

static void
pa_float_cons (float_type)
     int float_type;
{
  float_cons (float_type);
  pa_undefine_label ();
}

/* Like s_fill, but delete our label when finished.  */

static void
pa_fill (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  s_fill (0);
  pa_undefine_label ();
}

/* Like lcomm, but delete our label when finished.  */

static void
pa_lcomm (needs_align)
     int needs_align;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  s_lcomm (needs_align);
  pa_undefine_label ();
}

/* Like lsym, but delete our label when finished.  */

static void
pa_lsym (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

  s_lsym (0);
  pa_undefine_label ();
}

/* On the PA relocations which involve function symbols must not be
   adjusted.  This so that the linker can know when/how to create argument
   relocation stubs for indirect calls and calls to static functions.

   "T" field selectors create DLT relative fixups for accessing
   globals and statics in PIC code; each DLT relative fixup creates
   an entry in the DLT table.  The entries contain the address of
   the final target (eg accessing "foo" would create a DLT entry
   with the address of "foo").

   Unfortunately, the HP linker doesn't take into account any addend
   when generating the DLT; so accessing $LIT$+8 puts the address of
   $LIT$ into the DLT rather than the address of $LIT$+8.

   The end result is we can't perform relocation symbol reductions for
   any fixup which creates entries in the DLT (eg they use "T" field
   selectors).

   Reject reductions involving symbols with external scope; such
   reductions make life a living hell for object file editors.

   FIXME.  Also reject R_HPPA relocations which are 32bits wide in
   the code space.  The SOM BFD backend doesn't know how to pull the
   right bits out of an instruction.  */

int
hppa_fix_adjustable (fixp)
     fixS *fixp;
{
  reloc_type code;
  struct hppa_fix_struct *hppa_fix;

  hppa_fix = (struct hppa_fix_struct *) fixp->tc_fix_data;

#ifdef OBJ_SOM
  /* Reject reductions of symbols in 32bit relocs.  */
  if (fixp->fx_r_type == R_HPPA && hppa_fix->fx_r_format == 32)
    return 0;
#endif

#ifdef OBJ_ELF
  /* LR/RR selectors are implicitly used for a number of different relocation
     types.  We must ensure that none of these types are adjusted (see below)
     even if they occur with a different selector.  */
  code = elf_hppa_reloc_final_type (stdoutput, fixp->fx_r_type,
		  		    hppa_fix->fx_r_format,
				    hppa_fix->fx_r_field);

  switch (code)
    {
    /* Relocation types which use e_lrsel.  */
    case R_PARISC_DIR21L:
    case R_PARISC_DLTREL21L:
    case R_PARISC_DPREL21L:
    case R_PARISC_PLTOFF21L:

    /* Relocation types which use e_rrsel.  */
    case R_PARISC_DIR14R:
    case R_PARISC_DIR14DR:
    case R_PARISC_DIR14WR:
    case R_PARISC_DIR17R:
    case R_PARISC_DLTREL14R:
    case R_PARISC_DLTREL14DR:
    case R_PARISC_DLTREL14WR:
    case R_PARISC_DPREL14R:
    case R_PARISC_DPREL14DR:
    case R_PARISC_DPREL14WR:
    case R_PARISC_PLTOFF14R:
    case R_PARISC_PLTOFF14DR:
    case R_PARISC_PLTOFF14WR:

    /* Other types that we reject for reduction.  */
    case R_PARISC_GNU_VTENTRY:
    case R_PARISC_GNU_VTINHERIT:
      return 0;
    default:
      break;
    }
#endif

  /* Reject reductions of symbols in sym1-sym2 expressions when
     the fixup will occur in a CODE subspace.

     XXX FIXME: Long term we probably want to reject all of these;
     for example reducing in the debug section would lose if we ever
     supported using the optimizing hp linker.  */
  if (fixp->fx_addsy
      && fixp->fx_subsy
      && (hppa_fix->segment->flags & SEC_CODE))
    return 0;

  /* We can't adjust any relocs that use LR% and RR% field selectors.

     If a symbol is reduced to a section symbol, the assembler will
     adjust the addend unless the symbol happens to reside right at
     the start of the section.  Additionally, the linker has no choice
     but to manipulate the addends when coalescing input sections for
     "ld -r".  Since an LR% field selector is defined to round the
     addend, we can't change the addend without risking that a LR% and
     it's corresponding (possible multiple) RR% field will no longer
     sum to the right value.

     eg. Suppose we have
     .		ldil	LR%foo+0,%r21
     .		ldw	RR%foo+0(%r21),%r26
     .		ldw	RR%foo+4(%r21),%r25

     If foo is at address 4092 (decimal) in section `sect', then after
     reducing to the section symbol we get
     .			LR%sect+4092 == (L%sect)+0
     .			RR%sect+4092 == (R%sect)+4092
     .			RR%sect+4096 == (R%sect)-4096
     and the last address loses because rounding the addend to 8k
     multiples takes us up to 8192 with an offset of -4096.

     In cases where the LR% expression is identical to the RR% one we
     will never have a problem, but is so happens that gcc rounds
     addends involved in LR% field selectors to work around a HP
     linker bug.  ie. We often have addresses like the last case
     above where the LR% expression is offset from the RR% one.  */

  if (hppa_fix->fx_r_field == e_lrsel
      || hppa_fix->fx_r_field == e_rrsel
      || hppa_fix->fx_r_field == e_nlrsel)
    return 0;

  /* Reject reductions of symbols in DLT relative relocs,
     relocations with plabels.  */
  if (hppa_fix->fx_r_field == e_tsel
      || hppa_fix->fx_r_field == e_ltsel
      || hppa_fix->fx_r_field == e_rtsel
      || hppa_fix->fx_r_field == e_psel
      || hppa_fix->fx_r_field == e_rpsel
      || hppa_fix->fx_r_field == e_lpsel)
    return 0;

  /* Reject absolute calls (jumps).  */
  if (hppa_fix->fx_r_type == R_HPPA_ABS_CALL)
    return 0;

  /* Reject reductions of function symbols.  */
  if (fixp->fx_addsy != 0 && S_IS_FUNCTION (fixp->fx_addsy))
    return 0;

  return 1;
}

/* Return nonzero if the fixup in FIXP will require a relocation,
   even it if appears that the fixup could be completely handled
   within GAS.  */

int
hppa_force_relocation (fixp)
     struct fix *fixp;
{
  struct hppa_fix_struct *hppa_fixp;

  hppa_fixp = (struct hppa_fix_struct *) fixp->tc_fix_data;
#ifdef OBJ_SOM
  if (fixp->fx_r_type == (int) R_HPPA_ENTRY
      || fixp->fx_r_type == (int) R_HPPA_EXIT
      || fixp->fx_r_type == (int) R_HPPA_BEGIN_BRTAB
      || fixp->fx_r_type == (int) R_HPPA_END_BRTAB
      || fixp->fx_r_type == (int) R_HPPA_BEGIN_TRY
      || fixp->fx_r_type == (int) R_HPPA_END_TRY
      || (fixp->fx_addsy != NULL && fixp->fx_subsy != NULL
	  && (hppa_fixp->segment->flags & SEC_CODE) != 0))
    return 1;
#endif
#ifdef OBJ_ELF
  if (fixp->fx_r_type == (int) R_PARISC_GNU_VTINHERIT
      || fixp->fx_r_type == (int) R_PARISC_GNU_VTENTRY)
    return 1;
#endif

  assert (fixp->fx_addsy != NULL);

  /* Ensure we emit a relocation for global symbols so that dynamic
     linking works.  */
  if (S_FORCE_RELOC (fixp->fx_addsy, 1))
    return 1;

  /* It is necessary to force PC-relative calls/jumps to have a relocation
     entry if they're going to need either an argument relocation or long
     call stub.  */
  if (fixp->fx_pcrel
      && arg_reloc_stub_needed (symbol_arg_reloc_info (fixp->fx_addsy),
				hppa_fixp->fx_arg_reloc))
    return 1;

  /* Now check to see if we're going to need a long-branch stub.  */
  if (fixp->fx_r_type == (int) R_HPPA_PCREL_CALL)
    {
      long pc = md_pcrel_from (fixp);
      valueT distance, min_stub_distance;

      distance = fixp->fx_offset + S_GET_VALUE (fixp->fx_addsy) - pc - 8;

      /* Distance to the closest possible stub.  This will detect most
	 but not all circumstances where a stub will not work.  */
      min_stub_distance = pc + 16;
#ifdef OBJ_SOM
      if (last_call_info != NULL)
	min_stub_distance -= S_GET_VALUE (last_call_info->start_symbol);
#endif

      if ((distance + 8388608 >= 16777216
	   && min_stub_distance <= 8388608)
	  || (hppa_fixp->fx_r_format == 17
	      && distance + 262144 >= 524288
	      && min_stub_distance <= 262144)
	  || (hppa_fixp->fx_r_format == 12
	      && distance + 8192 >= 16384
	      && min_stub_distance <= 8192)
	  )
	return 1;
    }

  if (fixp->fx_r_type == (int) R_HPPA_ABS_CALL)
    return 1;

  /* No need (yet) to force another relocations to be emitted.  */
  return 0;
}

/* Now for some ELF specific code.  FIXME.  */
#ifdef OBJ_ELF
/* Mark the end of a function so that it's possible to compute
   the size of the function in elf_hppa_final_processing.  */

static void
hppa_elf_mark_end_of_function ()
{
  /* ELF does not have EXIT relocations.  All we do is create a
     temporary symbol marking the end of the function.  */
  char *name;

  if (last_call_info == NULL || last_call_info->start_symbol == NULL)
    {
      /* We have already warned about a missing label,
	 or other problems.  */
      return;
    }

  name = (char *) xmalloc (strlen ("L$\001end_")
			   + strlen (S_GET_NAME (last_call_info->start_symbol))
			   + 1);
  if (name)
    {
      symbolS *symbolP;

      strcpy (name, "L$\001end_");
      strcat (name, S_GET_NAME (last_call_info->start_symbol));

      /* If we have a .exit followed by a .procend, then the
	 symbol will have already been defined.  */
      symbolP = symbol_find (name);
      if (symbolP)
	{
	  /* The symbol has already been defined!  This can
	     happen if we have a .exit followed by a .procend.

	     This is *not* an error.  All we want to do is free
	     the memory we just allocated for the name and continue.  */
	  xfree (name);
	}
      else
	{
	  /* symbol value should be the offset of the
	     last instruction of the function */
	  symbolP = symbol_new (name, now_seg, (valueT) (frag_now_fix () - 4),
				frag_now);

	  assert (symbolP);
	  S_CLEAR_EXTERNAL (symbolP);
	  symbol_table_insert (symbolP);
	}

      if (symbolP)
	last_call_info->end_symbol = symbolP;
      else
	as_bad (_("Symbol '%s' could not be created."), name);

    }
  else
    as_bad (_("No memory for symbol name."));

}

/* For ELF, this function serves one purpose:  to setup the st_size
   field of STT_FUNC symbols.  To do this, we need to scan the
   call_info structure list, determining st_size in by taking the
   difference in the address of the beginning/end marker symbols.  */

void
elf_hppa_final_processing ()
{
  struct call_info *call_info_pointer;

  for (call_info_pointer = call_info_root;
       call_info_pointer;
       call_info_pointer = call_info_pointer->ci_next)
    {
      elf_symbol_type *esym
	= ((elf_symbol_type *)
	   symbol_get_bfdsym (call_info_pointer->start_symbol));
      esym->internal_elf_sym.st_size =
	S_GET_VALUE (call_info_pointer->end_symbol)
	- S_GET_VALUE (call_info_pointer->start_symbol) + 4;
    }
}

static void
pa_vtable_entry (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  struct fix *new_fix;

  new_fix = obj_elf_vtable_entry (0);

  if (new_fix)
    {
      struct hppa_fix_struct *hppa_fix = (struct hppa_fix_struct *)
	obstack_alloc (&notes, sizeof (struct hppa_fix_struct));
      hppa_fix->fx_r_type = R_HPPA;
      hppa_fix->fx_r_field = e_fsel;
      hppa_fix->fx_r_format = 32;
      hppa_fix->fx_arg_reloc = 0;
      hppa_fix->segment = now_seg;
      new_fix->tc_fix_data = (void *) hppa_fix;
      new_fix->fx_r_type = (int) R_PARISC_GNU_VTENTRY;
    }
}

static void
pa_vtable_inherit (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  struct fix *new_fix;

  new_fix = obj_elf_vtable_inherit (0);

  if (new_fix)
    {
      struct hppa_fix_struct *hppa_fix = (struct hppa_fix_struct *)
	obstack_alloc (&notes, sizeof (struct hppa_fix_struct));
      hppa_fix->fx_r_type = R_HPPA;
      hppa_fix->fx_r_field = e_fsel;
      hppa_fix->fx_r_format = 32;
      hppa_fix->fx_arg_reloc = 0;
      hppa_fix->segment = now_seg;
      new_fix->tc_fix_data = (void *) hppa_fix;
      new_fix->fx_r_type = (int) R_PARISC_GNU_VTINHERIT;
    }
}
#endif
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d46 1
a46 1
/* A "convient" place to put object file dependencies which do
d493 1
a493 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
d599 1
a599 1
/* File and gloally scoped variable declarations.  */
d625 5
d650 1
a650 1
#if defined (OBJ_ELF) && defined (TE_LINUX)
d660 1
a660 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
d667 1
a667 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
a674 3
#ifdef OBJ_ELF
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
#endif
a683 3
#ifdef OBJ_ELF
  {"loc", dwarf2_directive_loc, 0 },
#endif
d708 1
a708 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
d751 1
a751 1
/* Points to the end of an expression just parsed by get_expressoin
d855 4
d955 1
d1021 8
d1161 1
a1161 1
/* Simple range checking for FIELD againt HIGH and LOW bounds.
d1189 1
a1189 1
/* Simple alignment checking for FIELD againt ALIGN (a power of two).
d1402 2
d1548 1
a1548 1
  /* Get somewhere to put the assembled instrution.  */
d1644 1
a1644 1
	 crud is for compatability with HP's old assemblers only.  */
a2374 1
			name = s;
d2436 1
a2436 1
			else if (*args == 'a')
a2541 1
			name = s;
d2603 1
a2603 1
			else if (*args != 'S')
d2726 1
a2726 1
			else if (*args != 'L')
d2781 1
a2781 1
			else if (*args != 'X')
d2893 1
a2893 1
			else if (*args != 'U')
d4850 1
a4850 1
	     compatability with the braindamaged HP assemblers.  */
d5221 1
a5221 1
     The PA assembly syntax is ambigious in a variety of ways.  Consider
d5225 1
a5225 1
     If we get a modulo expresion When looking for an absolute, we try
d5363 1
a5363 1
   number (for encoding in instrutions) of the given completer.  */
d5434 1
a5434 1
   number (for encoding in instrutions) of the given completer.  */
d5509 1
a5509 1
   encoding in instrutions) of the given completer.
d5606 1
a5606 1
   (for encoding in instrutions) of the given completer.  */
d5668 1
a5668 1
   (for encoding in instrutions) of the given completer.  */
d5738 1
a5738 1
   (for encoding in instrutions) of the given completer.  */
d5812 1
a5812 1
   encoding in instrutions) of the given completer.  */
d5979 1
a5979 1
  /* The BRTAB relocations are only availble in SOM (to denote
d6005 1
a6005 1
  /* The TRY relocations are only availble in SOM (to denote
d6322 1
a6322 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
d6391 1
d6403 1
a6403 1
#endif /* !(defined (OBJ_ELF) && defined (TE_LINUX)) */
d6429 1
a6429 1
   procesure.  */
d6787 1
a6787 1
      /* Privelege level.  */
d6842 1
a6842 1
	  /* Sigh.  To be compatable with the HP assembler and to help
d7071 1
a7071 1
/* Process the syntatical end of a procedure.  Make sure all the
d7280 1
a7280 1
     the first occurence of a built-in space.  */
d8468 1
a8468 1
     mutiples takes us up to 8192 with an offset of -4096.
@


1.6
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a25 1
#include <ctype.h>
d28 1
d60 1
d63 1
d513 4
a516 4
static int pa_parse_nonneg_cmpsub_cmpltr PARAMS ((char **, int));
static int pa_parse_neg_cmpsub_cmpltr PARAMS ((char **, int));
static int pa_parse_neg_add_cmpltr PARAMS ((char **, int));
static int pa_parse_nonneg_add_cmpltr PARAMS ((char **, int));
d671 1
a671 1
  {"file", dwarf2_directive_file, 0 },
d959 5
d1163 14
d1292 1
a1292 1
 	  && current_space == label_chain->lss_space && label_chain->lss_label
d1295 1
a1295 1
 	  && now_seg == label_chain->lss_segment && label_chain->lss_label
d1576 1
a1576 2
    if (isupper (*s))
      *s = tolower (*s);
d1579 3
a1581 1
  for (s = str; isupper (*s) || islower (*s) || (*s >= '0' && *s <= '3'); ++s)
a1602 2
  save_s = str;

d1695 1
a1695 1
	      if (!strncasecmp(s, "%sar", 4))
d1700 1
a1700 1
	      else if (!strncasecmp(s, "%cr11", 5))
d1815 1
d1854 1
d1894 1
a1894 1
		   /* 'J', 'm' and 'q' are the same, except for where they
d1896 1
a1896 1
		   if (*args == 'm')
d1922 1
d1958 1
a1958 1
		  if (!strncmp(s, ",sl", 3))
d1968 1
a1968 1
		  if (!strncmp(s, ",sl", 3))
d1973 1
a1973 1
		  else if (!strncmp(s, ",bc", 3))
d1983 1
a1983 1
		  if (!strncmp(s, ",co", 3))
d1992 1
a1992 1
		  if (strncmp(s, ",o", 2) != 0)
d2261 1
a2261 1
			as_bad(_("Invalid left/right combination completer"));
d2267 1
a2267 1
		    as_bad(_("Invalid left/right combination completer"));
d2316 1
a2316 1
			      as_bad(_("Invalid permutation completer"));
d2323 1
a2323 1
		    as_bad(_("Invalid permutation completer"));
d2337 4
a2340 4
 		  /* Handle FP compare conditions.  */
 		  case 'f':
 		    cond = pa_parse_fp_cmp_cond (&s);
 		    INSERT_FIELD_AND_CONTINUE (opcode, cond, 0);
d2345 2
a2346 2
 		    cmpltr = 0;
 		    flag = 0;
d2432 1
a2432 1
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
d2435 1
a2435 1
			as_bad (_("Invalid Add and Branch Condition: %c"), *s);
d2445 1
a2445 1
			as_bad (_("Invalid Add and Branch Condition: %c"), *s);
d2459 1
a2459 1
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
d2463 1
a2463 1
			cmpltr = pa_parse_neg_add_cmpltr (&s, 1);
d2601 1
a2601 1
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
d2604 1
a2604 1
			as_bad (_("Invalid Compare/Subtract Condition: %c"), *s);
d2612 1
a2612 1
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
d2616 1
a2616 1
			cmpltr = pa_parse_neg_cmpsub_cmpltr (&s, 1);
d2619 1
a2619 1
			    as_bad (_("Invalid Compare and Branch Condition."));
d3254 1
a3254 1
			      "L$0\001"))
d3286 1
a3286 1
			      "L$0\001"))
d3317 1
a3317 1
			      "L$0\001"))
d3347 1
a3347 1
			      "L$0\001"))
d3952 1
a3952 1
      if (match == FALSE)
d4081 1
a4081 1
      as_bad (_("Cannot handle fixup at %s:%d"), fixp->fx_file, fixp->fx_line);
d4243 2
a4244 2
          relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
          *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
d4252 2
a4253 2
          relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
          *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
d4411 2
a4412 2
int
md_apply_fix (fixP, valp)
d4414 2
a4415 1
     valueT *valp;
d4431 1
a4431 1
    return 1;
d4438 2
a4439 2
      fixP->fx_offset = *valp;
      return 1;
d4445 1
a4445 1
    return 1;
d4448 3
d4456 4
a4459 3
      printf (_("no hppa_fixup entry for fixup type 0x%x at %s:%d"),
	      fixP->fx_r_type, fixP->fx_file, fixP->fx_line);
      return 0;
d4462 1
a4462 1
  buf = fixP->fx_frag->fr_literal + fixP->fx_where;
a4485 7
  /* This is truly disgusting.  The machine independent code blindly
     adds in the value of the symbol being relocated against.  Damn!  */
  else if (fmt == 32
	   && fixP->fx_addsy != NULL
	   && S_GET_SEGMENT (fixP->fx_addsy) != bfd_com_section_ptr)
    new_val = hppa_field_adjust (*valp - S_GET_VALUE (fixP->fx_addsy),
				 0, hppa_fixP->fx_r_field);
d4488 1
a4488 1
    new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);
d4497 3
a4499 3
      && (*valp - 8 + 8192 < 16384
	  || (fmt == 17 && *valp - 8 + 262144 < 524288)
	  || (fmt == 22 && *valp - 8 + 8388608 < 16777216))
d4502 2
a4503 2
      && (*valp - 8 + 262144 < 524288
	  || (fmt == 22 && *valp - 8 + 8388608 < 16777216))
d4511 1
a4511 1
      new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);
d4517 2
a4518 1
      CHECK_FIELD (new_val, 8191, -8192, 0);
d4525 2
a4526 1
      CHECK_FIELD (new_val, 8191, -8192, 0);
d4534 2
a4535 1
      CHECK_FIELD (new_val, 8191, -8192, 0);
d4543 2
a4544 1
      CHECK_FIELD (new_val, 1048575, -1048576, 0);
d4552 2
a4553 1
      CHECK_FIELD (new_val, 1023, -1024, 0);
d4561 2
a4562 1
      CHECK_FIELD (new_val - 8, 8191, -8192, 0);
d4571 1
a4571 1
	offsetT distance = *valp;
d4577 2
a4578 1
	  CHECK_FIELD (distance - 8, 262143, -262144, 0);
d4580 2
a4581 1
	CHECK_FIELD (new_val - 8, 262143, -262144, 0);
d4590 1
a4590 1
	offsetT distance = *valp;
d4596 2
a4597 1
	  CHECK_FIELD (distance - 8, 8388607, -8388608, 0);
d4599 2
a4600 1
	CHECK_FIELD (new_val - 8, 8388607, -8388608, 0);
d4627 3
a4629 2
      as_bad (_("Unknown relocation encountered in md_apply_fix."));
      return 0;
a4633 1
  return 1;
d4683 1
a4683 1
  boolean have_prefix;
d4692 1
a4692 1
  if (!strict && isdigit (*p))
d4700 1
a4700 1
	  while (isdigit (*p) || ((*p >= 'a') && (*p <= 'f'))
d4703 1
a4703 1
	      if (isdigit (*p))
d4715 1
a4715 1
	  while (isdigit (*p))
d4767 1
a4767 1
	  else if (!isdigit (*p))
d4777 1
a4777 1
	      while (isdigit (*p));
d4822 1
a4822 1
	      have_prefix = true;
d5129 1
a5129 1
    name[0] = tolower ((*str)[0]),
d5132 2
a5133 2
    name[0] = tolower ((*str)[0]),
    name[1] = tolower ((*str)[1]),
d5136 3
a5138 3
    name[0] = tolower ((*str)[0]),
    name[1] = tolower ((*str)[1]),
    name[2] = tolower ((*str)[2]),
d5223 1
a5223 1
        s++;
d5351 1
a5351 5
   number (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction.  */
d5354 1
a5354 1
pa_parse_nonneg_cmpsub_cmpltr (s, isbranch)
a5355 1
     int isbranch;
d5402 1
a5402 1
      else if (strcasecmp (name, "n") == 0 && isbranch)
d5422 1
a5422 5
   number (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction.  */
d5425 1
a5425 1
pa_parse_neg_cmpsub_cmpltr (s, isbranch)
a5426 1
     int isbranch;
d5477 1
a5477 1
      else if (strcasecmp (name, "n") == 0 && isbranch)
d5656 1
a5656 5
   (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction.  */
d5659 1
a5659 1
pa_parse_nonneg_add_cmpltr (s, isbranch)
a5660 1
     int isbranch;
d5666 1
d5706 1
a5706 1
      else if (strcasecmp (name, "n") == 0 && isbranch)
d5709 1
d5719 1
a5719 1
  if (cmpltr == 0 && *name == 'n' && isbranch)
d5726 1
a5726 5
   (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction).  */
d5729 1
a5729 1
pa_parse_neg_add_cmpltr (s, isbranch)
a5730 1
     int isbranch;
d5736 1
d5780 1
a5780 1
      else if (strcasecmp (name, "n") == 0 && isbranch)
d5783 1
d5793 1
a5793 1
  if (cmpltr == 0 && *name == 'n' && isbranch)
d6831 1
a6831 1
	     the the current segment.  Note only BSF_FUNCTION really
d8201 1
a8201 1
		     && (isdigit (dg) || (dg >= 'a' && dg <= 'f')
d8205 1
a8205 1
		    if (isdigit (dg))
d8371 1
d8383 37
a8419 3
  if (fixp->fx_r_type == (int) R_PARISC_GNU_VTINHERIT
      || fixp->fx_r_type ==  (int) R_PARISC_GNU_VTENTRY)
    return 0;
a8421 4
  if (fixp->fx_addsy && (S_IS_EXTERNAL (fixp->fx_addsy)
			 || S_IS_WEAK (fixp->fx_addsy)))
    return 0;

d8431 1
a8431 5
    {
      /* Apparently sy_used_in_reloc never gets set for sub symbols.  */
      symbol_mark_used_in_reloc (fixp->fx_subsy);
      return 0;
    }
d8521 1
a8521 1
  if (S_IS_EXTERNAL (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
d8525 1
a8525 1
     entry if they're going to need either a argument relocation or long
d8535 2
a8536 1
      valueT distance;
d8538 18
a8555 7
      distance = (fixp->fx_offset + S_GET_VALUE (fixp->fx_addsy)
		  - md_pcrel_from (fixp) - 8);
      if (distance + 8388608 >= 16777216
	  || (hppa_fixp->fx_r_format == 17 && distance + 262144 >= 524288)
#ifdef OBJ_ELF
	  || (hppa_fixp->fx_r_format == 12 && distance + 8192 >= 16384)
#endif
d8570 1
a8570 1
   the size of the function in hppa_elf_final_processing.  */
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 93, 94, 95, 96, 97, 98, 1999
a21 1

a31 1
#include "bfd/libbfd.h"
a44 2
struct dwarf2_line_info debug_line;
#endif
d48 1
a48 1
#ifdef OBJ_ELF
d50 1
a50 1
typedef elf_hppa_reloc_type reloc_type;
d54 2
d57 1
a57 1
#ifdef BFD64
d70 1
a70 1
#endif
d91 2
a97 1
#endif
d106 7
d142 25
d253 1
a253 1
    long arg_reloc;
a263 1

d280 1
a280 17
   +--------------+--------------+


   The following is a version of pa_parse_number that
   handles the L/R notation and returns the correct
   value to put into the instruction register field.
   The correct value to put into the instruction is
   encoded in the structure 'pa_11_fp_reg_struct'.  */

struct pa_11_fp_reg_struct
  {
    /* The register number.  */
    char number_part;

    /* L/R selector.  */
    char l_r_select;
  };
d455 1
a455 1
    long fx_arg_reloc;
d491 5
a497 1
static void pa_data PARAMS ((int));
a502 1
static void pa_text PARAMS ((int));
a523 2
static void pa_code PARAMS ((int));
static void pa_comm PARAMS ((int));
d541 2
a542 3
static int need_pa11_opcode PARAMS ((struct pa_it *,
				     struct pa_11_fp_reg_struct *));
static int pa_parse_number PARAMS ((char **, struct pa_11_fp_reg_struct *));
d545 1
d577 1
a577 1
				  long, expressionS *, int,
d580 1
a580 1
				  int, long, int *));
a585 1
static int log2 PARAMS ((int));
d593 2
a622 4
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = ";";

d643 4
a646 1
  {"code", pa_code, 0},
d648 1
d653 1
d655 1
d660 1
d662 1
d669 1
a669 1
  { "file", dwarf2_directive_file },
d681 1
a681 1
  { "loc", dwarf2_directive_loc },
d707 1
d709 1
d711 4
d727 1
a727 1
   Also note that C style comments will always work. */
d730 4
d764 1
a764 1
/* Handle on strucutre which keep track of the last symbol
d777 9
d818 1
a818 1
   The table is sorted. Suitable for searching by a binary search. */
d822 139
a960 139
  {"%arg0", 26},
  {"%arg1", 25},
  {"%arg2", 24},
  {"%arg3", 23},
  {"%cr0", 0},
  {"%cr10", 10},
  {"%cr11", 11},
  {"%cr12", 12},
  {"%cr13", 13},
  {"%cr14", 14},
  {"%cr15", 15},
  {"%cr16", 16},
  {"%cr17", 17},
  {"%cr18", 18},
  {"%cr19", 19},
  {"%cr20", 20},
  {"%cr21", 21},
  {"%cr22", 22},
  {"%cr23", 23},
  {"%cr24", 24},
  {"%cr25", 25},
  {"%cr26", 26},
  {"%cr27", 27},
  {"%cr28", 28},
  {"%cr29", 29},
  {"%cr30", 30},
  {"%cr31", 31},
  {"%cr8", 8},
  {"%cr9", 9},
  {"%dp", 27},
  {"%eiem", 15},
  {"%eirr", 23},
  {"%fr0", 0},
  {"%fr0l", 0},
  {"%fr0r", 0},
  {"%fr1", 1},
  {"%fr10", 10},
  {"%fr10l", 10},
  {"%fr10r", 10},
  {"%fr11", 11},
  {"%fr11l", 11},
  {"%fr11r", 11},
  {"%fr12", 12},
  {"%fr12l", 12},
  {"%fr12r", 12},
  {"%fr13", 13},
  {"%fr13l", 13},
  {"%fr13r", 13},
  {"%fr14", 14},
  {"%fr14l", 14},
  {"%fr14r", 14},
  {"%fr15", 15},
  {"%fr15l", 15},
  {"%fr15r", 15},
  {"%fr16", 16},
  {"%fr16l", 16},
  {"%fr16r", 16},
  {"%fr17", 17},
  {"%fr17l", 17},
  {"%fr17r", 17},
  {"%fr18", 18},
  {"%fr18l", 18},
  {"%fr18r", 18},
  {"%fr19", 19},
  {"%fr19l", 19},
  {"%fr19r", 19},
  {"%fr1l", 1},
  {"%fr1r", 1},
  {"%fr2", 2},
  {"%fr20", 20},
  {"%fr20l", 20},
  {"%fr20r", 20},
  {"%fr21", 21},
  {"%fr21l", 21},
  {"%fr21r", 21},
  {"%fr22", 22},
  {"%fr22l", 22},
  {"%fr22r", 22},
  {"%fr23", 23},
  {"%fr23l", 23},
  {"%fr23r", 23},
  {"%fr24", 24},
  {"%fr24l", 24},
  {"%fr24r", 24},
  {"%fr25", 25},
  {"%fr25l", 25},
  {"%fr25r", 25},
  {"%fr26", 26},
  {"%fr26l", 26},
  {"%fr26r", 26},
  {"%fr27", 27},
  {"%fr27l", 27},
  {"%fr27r", 27},
  {"%fr28", 28},
  {"%fr28l", 28},
  {"%fr28r", 28},
  {"%fr29", 29},
  {"%fr29l", 29},
  {"%fr29r", 29},
  {"%fr2l", 2},
  {"%fr2r", 2},
  {"%fr3", 3},
  {"%fr30", 30},
  {"%fr30l", 30},
  {"%fr30r", 30},
  {"%fr31", 31},
  {"%fr31l", 31},
  {"%fr31r", 31},
  {"%fr3l", 3},
  {"%fr3r", 3},
  {"%fr4", 4},
  {"%fr4l", 4},
  {"%fr4r", 4},
  {"%fr5", 5},
  {"%fr5l", 5},
  {"%fr5r", 5},
  {"%fr6", 6},
  {"%fr6l", 6},
  {"%fr6r", 6},
  {"%fr7", 7},
  {"%fr7l", 7},
  {"%fr7r", 7},
  {"%fr8", 8},
  {"%fr8l", 8},
  {"%fr8r", 8},
  {"%fr9", 9},
  {"%fr9l", 9},
  {"%fr9r", 9},
  {"%hta", 25},
  {"%iir", 19},
  {"%ior", 21},
  {"%ipsw", 22},
  {"%isr", 20},
  {"%itmr", 16},
  {"%iva", 14},
  {"%pcoq", 18},
  {"%pcsq", 17},
  {"%pidr1", 8},
  {"%pidr2", 9},
d963 55
a1017 55
  {"%ppda", 24},
  {"%r0", 0},
  {"%r1", 1},
  {"%r10", 10},
  {"%r11", 11},
  {"%r12", 12},
  {"%r13", 13},
  {"%r14", 14},
  {"%r15", 15},
  {"%r16", 16},
  {"%r17", 17},
  {"%r18", 18},
  {"%r19", 19},
  {"%r2", 2},
  {"%r20", 20},
  {"%r21", 21},
  {"%r22", 22},
  {"%r23", 23},
  {"%r24", 24},
  {"%r25", 25},
  {"%r26", 26},
  {"%r27", 27},
  {"%r28", 28},
  {"%r29", 29},
  {"%r3", 3},
  {"%r30", 30},
  {"%r31", 31},
  {"%r4", 4},
  {"%r5", 5},
  {"%r6", 6},
  {"%r7", 7},
  {"%r8", 8},
  {"%r9", 9},
  {"%rctr", 0},
  {"%ret0", 28},
  {"%ret1", 29},
  {"%rp", 2},
  {"%sar", 11},
  {"%sp", 30},
  {"%sr0", 0},
  {"%sr1", 1},
  {"%sr2", 2},
  {"%sr3", 3},
  {"%sr4", 4},
  {"%sr5", 5},
  {"%sr6", 6},
  {"%sr7", 7},
  {"%tr0", 24},
  {"%tr1", 25},
  {"%tr2", 26},
  {"%tr3", 27},
  {"%tr4", 28},
  {"%tr5", 29},
  {"%tr6", 30},
  {"%tr7", 31}
d1156 14
a1290 1

d1305 1
a1305 1
     long offset;
d1311 2
a1312 2
     long arg_reloc;
     int* unwind_bits;
d1331 1
a1331 1
    new_fix->fx_offset = *unwind_bits;
d1336 1
a1336 1
     it now so as not to confuse write.c.  */
d1338 2
a1339 1
      && !strcmp (S_GET_NAME (new_fix->fx_subsy), "$global$"))
d1375 4
a1378 1
    as_warn (_("Invalid field selector.  Assuming F%%."));
d1382 1
a1382 1
		hppa_field_selector, size * 8, 0, NULL);
d1402 1
a1402 1
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 10))
d1454 1
a1454 1
  /* Force the symbol to be converted to a real symbol. */
d1492 2
a1493 1
		  char *where = frag_more (0);
d1495 2
d1499 1
a1499 2
				0, R_HPPA_ENTRY, e_fsel, 0, 0,
				(int *)&last_call_info->ci_unwind.descriptor);
d1516 1
a1516 1
  /* Output the opcode. */
d1524 1
a1524 1
		  the_insn.format, the_insn.arg_reloc, NULL);
d1527 1
a1527 14
  if (debug_type == DEBUG_DWARF2)
    {
      bfd_vma addr;

      /* First update the notion of the current source line.  */
      dwarf2_where (&debug_line);

      /* We want the offset of the start of this instruction within the
	 the current frag.  */
      addr = frag_now->fr_address + frag_now_fix () - 4;

      /* And record the information.  */
      dwarf2_gen_line_info (addr, &debug_line);
    }
d1662 1
a1662 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1664 1
a1664 1
	      num = pa_parse_number (&s, 0);
d1689 1
a1689 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1691 1
a1691 1
	      num = pa_parse_number (&s, 0);
d1697 1
a1697 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1699 1
a1699 1
	      num = pa_parse_number (&s, 0);
d1705 1
a1705 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1707 1
a1707 1
	      num = pa_parse_number (&s, 0);
d1730 1
a1730 1
	      low_sign_unext (num, 5, &num);
d1741 2
a1742 2
	      CHECK_FIELD (num, 15, -16, strict)
	      low_sign_unext (num, 5, &num);
d1751 2
a1752 2
	      CHECK_FIELD (num, 31, 0, 0);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, strict);
d1774 1
a1774 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1776 1
a1776 1
	      num = pa_parse_number (&s, 0);
d1782 1
a1782 2
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
d1784 1
a1784 1
	      num = pa_parse_number (&s, 0);
d1786 2
a1787 2
	      dis_assemble_3 (num, &num);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
d1891 4
a1894 4
			/* Gross!  Hide these values in the immediate field
			   of the instruction, then pull them out later.  */
			opcode |= m << 8;
			opcode |= a << 9;
d1967 1
a1967 1
		/* Handle load ordering completer. */
d2427 1
a2427 1
			/* Negated condition requires an opcode change. */
d2448 1
a2448 1
			    /* Negated condition requires an opcode change. */
d2601 1
a2601 1
			    /* Negated condition requires an opcode change. */
d2613 1
a2613 1
			/* Negated condition requires an opcode change. */
d2617 1
a2617 1
		      /* Not a 64 bit cond.  Give 32 bit a chance. */
d2626 1
a2626 1
		      /* Not a 64 bit cond.  Give 32 bit a chance. */
a2649 1
			name = s;
a2656 1

a2716 1
			name = s;
d2936 1
a2936 1
		  low_sign_unext (num, 11, &num);
d2958 1
a2958 1
		  int a, m;
d2960 1
a2960 1
		  /* XXX the completer stored away tibits of information
d2964 2
a2965 3
		  m = (opcode & (1 << 8)) != 0;
		  a = (opcode & (1 << 9)) != 0;
		  opcode &= ~ (3 << 8);
d2967 1
a2967 1
		  if ((a == 1 && num >= 0) || (a == 0 && num < 0))
d2970 1
a2970 1
		  low_sign_unext (num, 14, &num);
d2973 1
a2973 4
	      else
		{
		  break;
		}
d2982 1
a2982 1
		  int a, m;
d2984 2
a2985 7
		  /* XXX the completer stored away tibits of information
		     for us to extract.  We need a cleaner way to do this.
		     Now that we have lots of letters again, it would be
		     good to rethink this.  */
		  m = (opcode & (1 << 8)) != 0;
		  a = (opcode & (1 << 9)) != 0;
		  opcode &= ~ (3 << 8);
d2987 1
a2987 1
		  if ((a == 1 && num < 0) || (a == 0 && num > 0))
d2992 22
a3013 5
		  if (num < 0)
		    opcode |= 1;
                  num &= 0x1fff;
                  num >>= 2;
                  INSERT_FIELD_AND_CONTINUE (opcode, num, 3);
d3015 8
a3022 1
	      else
d3024 12
a3035 1
		  break;
d3037 1
d3039 1
a3039 1
	    /* Handle 14 bit immediated, shifted left three times.  */
d3107 1
a3107 1
		  low_sign_unext (num, 14, &num);
d3131 2
a3132 2
		  dis_assemble_21 (num, &num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d3146 77
d3229 3
a3231 1
	      if (!strcmp (S_GET_NAME (the_insn.exp.X_add_symbol), "L$0\001"))
a3232 2
		  unsigned int w1, w, result;

d3239 5
a3243 4
		  CHECK_FIELD (num, 8199, -8184, 0);
		  sign_unext ((num - 8) >> 2, 12, &result);
		  dis_assemble_12 (result, &w1, &w);
		  INSERT_FIELD_AND_CONTINUE (opcode, ((w1 << 2) | w), 0);
a3264 2
		  unsigned int w2, w1, w, result;

a3270 2
		  CHECK_FIELD (num, 262143, -262144, 0);

d3273 3
a3275 5

		  sign_unext (num >> 2, 17, &result);
		  dis_assemble_17 (result, &w1, &w2, &w);
		  INSERT_FIELD_AND_CONTINUE (opcode,
					   ((w2 << 2) | (w1 << 16) | w), 0);
a3295 2
		  unsigned int w3, w2, w1, w, result;

a3301 2
		  CHECK_FIELD (num, 8388607, -8388608, 0);

d3304 2
a3305 7

		  sign_unext (num >> 2, 22, &result);
		  dis_assemble_22 (result, &w3, &w1, &w2, &w);
		  INSERT_FIELD_AND_CONTINUE (opcode,
					     ((w3 << 21) | (w2 << 2)
					      | (w1 << 16) | w),
					     0);
a3325 2
		  unsigned int w2, w1, w, result;

a3331 2
		  CHECK_FIELD (num, 262143, -262144, 0);

d3334 3
a3336 5

		  sign_unext (num >> 2, 17, &result);
		  dis_assemble_17 (result, &w1, &w2, &w);
		  INSERT_FIELD_AND_CONTINUE (opcode,
					   ((w2 << 2) | (w1 << 16) | w), 0);
a3472 2
	      if (the_insn.exp.X_op != O_constant)
		break;
d3501 1
a3501 1
	      CHECK_FIELD (num, 671108864, 0, strict);
d3696 1
a3696 2
		  /* This should be more strict.  Small steps.  */
		  if (strict && *s != '%')
d3698 1
a3698 1
		  num = pa_parse_number (&s, 0);
d3705 1
a3705 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3707 3
a3709 3
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= result.number_part;
d3714 1
a3714 1
		    if (need_pa11_opcode (&the_insn, &result)
d3718 2
a3719 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.l_r_select & 1, 6);
d3725 1
a3725 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3727 4
a3730 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= result.number_part << 21;
		    if (need_pa11_opcode (&the_insn, &result))
d3732 1
a3732 1
			opcode |= (result.l_r_select & 1) << 7;
d3742 1
a3742 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3744 4
a3747 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= result.number_part << 21;
		    opcode |= (result.l_r_select & 1) << 7;
d3754 1
a3754 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3756 4
a3759 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1f) << 16;
		    if (need_pa11_opcode (&the_insn, &result))
d3761 1
a3761 1
			opcode |= (result.l_r_select & 1) << 12;
d3770 1
a3770 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3772 4
a3775 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1f) << 16;
		    opcode |= (result.l_r_select & 1) << 12;
d3782 1
a3782 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3784 5
a3788 5
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1c) << 11;
		    opcode |= (result.number_part & 0x3) << 9;
		    opcode |= (result.l_r_select & 1) << 8;
d3795 1
a3795 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3797 2
a3798 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3801 1
a3801 1
			if (result.number_part < 16)
d3806 2
a3807 3

			result.number_part &= 0xF;
			result.number_part |= (result.l_r_select & 1) << 4;
d3809 1
a3809 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 21);
d3815 1
a3815 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3817 2
a3818 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3821 1
a3821 1
		        if (result.number_part < 16)
d3823 2
a3824 2
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
d3826 2
a3827 2
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d3829 1
a3829 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 16);
d3835 1
a3835 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3837 2
a3838 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3841 1
a3841 1
		        if (result.number_part < 16)
d3843 2
a3844 2
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
d3846 2
a3847 2
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d3849 1
a3849 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 0);
d3855 1
a3855 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3857 2
a3858 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3861 1
a3861 1
		        if (result.number_part < 16)
d3863 2
a3864 2
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
d3866 2
a3867 2
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d3869 1
a3869 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 6);
d3875 1
a3875 4
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
d3877 2
a3878 2
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
d3881 1
a3881 1
		        if (result.number_part < 16)
d3883 2
a3884 2
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
d3886 2
a3887 2
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d3889 1
a3889 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 11);
d3893 1
d3896 1
a3896 3
		    struct pa_11_fp_reg_struct result;

		    if (strict && *s != '%')
d3898 4
a3901 4
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1f) << 16;
		    if (need_pa11_opcode (&the_insn, &result))
d3903 1
a3903 1
			opcode |= (result.l_r_select & 1) << 1;
d3907 9
a4030 1
  bfd_reloc_code_real_type code;
d4033 2
a4034 1
  bfd_reloc_code_real_type **codes;
d4041 1
d4049 1
a4049 1
  codes = (bfd_reloc_code_real_type **) hppa_gen_reloc_type (stdoutput,
d4057 4
a4060 1
    abort ();
a4079 8
      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
      reloc->addend = 0;	/* default */

      assert (reloc->howto && code == reloc->howto->type);

d4091 2
a4092 3
	     (static link required).

	     FIXME: We always assume no static link!
d4100 1
a4100 1
	case R_PARISC_PCREL21L:
d4104 6
a4109 4
	case R_PARISC_PCREL14R:
	case R_PARISC_PCREL14F:
	  /* The constant is stored in the instruction.  */
	  reloc->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc, 0);
d4111 8
d4123 8
d4142 3
a4144 1
      relocs[i]->howto = bfd_reloc_type_lookup (stdoutput, code);
d4155 3
a4157 1
	  relocs[0]->howto = bfd_reloc_type_lookup (stdoutput, *codes[0]);
d4162 3
a4164 1
	  relocs[1]->howto = bfd_reloc_type_lookup (stdoutput, *codes[1]);
d4169 3
a4171 1
	  relocs[2]->howto = bfd_reloc_type_lookup (stdoutput, *codes[2]);
d4175 3
a4177 1
	  relocs[3]->howto = bfd_reloc_type_lookup (stdoutput, *codes[3]);
d4181 3
a4183 1
	  relocs[4]->howto = bfd_reloc_type_lookup (stdoutput, *codes[4]);
d4249 2
a4250 2
     register bfd *abfd;
     register asection *sec;
d4278 1
a4278 1
/* Round up a section size to the appropriate boundary. */
d4295 1
a4295 1
     asection *segment;
d4307 14
a4320 1
CONST char *md_shortopts = "";
d4322 3
d4327 1
a4327 1
size_t md_longopts_size = sizeof(md_longopts);
d4331 2
a4332 2
     int c;
     char *arg;
d4334 18
a4351 1
  return 0;
d4356 1
a4356 1
     FILE *stream;
d4358 8
d4372 1
a4372 1
     char *name;
d4377 9
d4393 1
a4393 1
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
d4395 2
a4396 2
  long new_val, result = 0;
  unsigned int w1, w2, w, resulti;
a4397 1
  hppa_fixP = (struct hppa_fix_struct *) fixP->tc_fix_data;
d4414 115
a4528 4
      fixP->fx_offset = *valp;
      return 1;
    }
#endif
d4530 2
a4531 6
  /* There should have been an HPPA specific fixup associated
     with the GAS fixup.  */
  if (hppa_fixP)
    {
      unsigned long buf_wd = bfd_get_32 (stdoutput, buf);
      int fmt = bfd_hppa_insn2fmt (buf_wd);
d4533 4
a4536 30
      /* If there is a symbol associated with this fixup, then it's something
	 which will need a SOM relocation (except for some PC-relative relocs).
	 In such cases we should treat the "val" or "addend" as zero since it
	 will be added in as needed from fx_offset in tc_gen_reloc.  */
      if ((fixP->fx_addsy != NULL
	   || fixP->fx_r_type == R_HPPA_NONE)
#ifdef OBJ_SOM
	  && fmt != 32
#endif
	  )
	new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
#ifdef OBJ_SOM
      /* These field selectors imply that we do not want an addend.  */
      else if (hppa_fixP->fx_r_field == e_psel
	       || hppa_fixP->fx_r_field == e_rpsel
	       || hppa_fixP->fx_r_field == e_lpsel
	       || hppa_fixP->fx_r_field == e_tsel
	       || hppa_fixP->fx_r_field == e_rtsel
	       || hppa_fixP->fx_r_field == e_ltsel)
	new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
      /* This is truely disgusting.  The machine independent code blindly
	 adds in the value of the symbol being relocated against.  Damn!  */
      else if (fmt == 32
	       && fixP->fx_addsy != NULL
	       && S_GET_SEGMENT (fixP->fx_addsy) != bfd_com_section_ptr)
	new_val = hppa_field_adjust (*valp - S_GET_VALUE (fixP->fx_addsy),
				     0, hppa_fixP->fx_r_field);
#endif
      else
	new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);
d4538 2
a4539 32
      /* Handle pc-relative exceptions from above.  */
#define arg_reloc_stub_needed(CALLER, CALLEE) \
  ((CALLEE) && (CALLER) && ((CALLEE) != (CALLER)))
      if ((fmt == 12 || fmt == 17 || fmt == 22)
	  && fixP->fx_addsy
	  && fixP->fx_pcrel
#ifdef OBJ_SOM
	  && !arg_reloc_stub_needed ((long) ((obj_symbol_type *)
		symbol_get_bfdsym (fixP->fx_addsy))->tc_data.ap.hppa_arg_reloc,
		hppa_fixP->fx_arg_reloc)
#endif
	  && (((int)(*valp) > -262144 && (int)(*valp) < 262143) && fmt != 22)
	  && S_GET_SEGMENT (fixP->fx_addsy) == hppa_fixP->segment
	  && !(fixP->fx_subsy
	       && S_GET_SEGMENT (fixP->fx_subsy) != hppa_fixP->segment))

	new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);
#undef arg_reloc_stub_needed

      switch (fmt)
	{
	/* Handle all opcodes with the 'j' operand type.  */
	case 14:
	  CHECK_FIELD (new_val, 8191, -8192, 0);

	  /* Mask off 14 bits to be changed.  */
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffffc000,
		      buf);
	  low_sign_unext (new_val, 14, &resulti);
	  result = resulti;
	  break;
d4541 4
a4544 11
	/* Handle all opcodes with the 'k' operand type.  */
	case 21:
	  CHECK_FIELD (new_val, 2097152, 0, 0);

	  /* Mask off 21 bits to be changed.  */
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffe00000,
		      buf);
	  dis_assemble_21 (new_val, &resulti);
	  result = resulti;
	  break;
d4546 5
a4550 11
	/* Handle all the opcodes with the 'i' operand type.  */
	case 11:
	  CHECK_FIELD (new_val, 1023, -1023, 0);

	  /* Mask off 11 bits to be changed.  */
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffff800,
		      buf);
	  low_sign_unext (new_val, 11, &resulti);
	  result = resulti;
	  break;
d4552 2
a4553 9
	/* Handle all the opcodes with the 'w' operand type.  */
	case 12:
	  CHECK_FIELD (new_val, 8199, -8184, 0);

	  /* Mask off 11 bits to be changed.  */
	  sign_unext ((new_val - 8) >> 2, 12, &resulti);
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffffe002,
		      buf);
d4555 3
a4557 3
	  dis_assemble_12 (resulti, &w1, &w);
	  result = ((w1 << 2) | w);
	  break;
d4559 3
a4561 4
	/* Handle some of the opcodes with the 'W' operand type.  */
	case 17:
	  {
	    int distance = *valp;
d4563 5
a4567 1
	    CHECK_FIELD (new_val, 262143, -262144, 0);
d4569 2
a4570 16
	    /* If this is an absolute branch (ie no link) with an out of
	       range target, then we want to complain.  */
	    if (fixP->fx_r_type == R_HPPA_PCREL_CALL
		&& (distance > 262143 || distance < -262144)
		&& (bfd_get_32 (stdoutput, buf) & 0xffe00000) == 0xe8000000)
	      CHECK_FIELD (distance, 262143, -262144, 0);

	    /* Mask off 17 bits to be changed.  */
	    bfd_put_32 (stdoutput,
			bfd_get_32 (stdoutput, buf) & 0xffe0e002,
			buf);
	    sign_unext ((new_val - 8) >> 2, 17, &resulti);
	    dis_assemble_17 (resulti, &w1, &w2, &w);
	    result = ((w2 << 2) | (w1 << 16) | w);
	    break;
	  }
d4572 3
a4574 3
	case 22:
	  {
	    int distance = *valp, w3;
d4576 4
a4579 1
	    CHECK_FIELD (new_val, 8388607, -8388608, 0);
d4581 4
a4584 16
	    /* If this is an absolute branch (ie no link) with an out of
	       range target, then we want to complain.  */
	    if (fixP->fx_r_type == R_HPPA_PCREL_CALL
		&& (distance > 8388607 || distance < -8388608)
		&& (bfd_get_32 (stdoutput, buf) & 0xffe00000) == 0xe8000000)
	      CHECK_FIELD (distance, 8388607, -8388608, 0);

	    /* Mask off 22 bits to be changed.  */
	    bfd_put_32 (stdoutput,
			bfd_get_32 (stdoutput, buf) & 0xfc00e002,
			buf);
	    sign_unext ((new_val - 8) >> 2, 22, &resulti);
	    dis_assemble_22 (resulti, &w3, &w1, &w2, &w);
	    result = ((w3 << 21) | (w2 << 2) | (w1 << 16) | w);
	    break;
	  }
d4586 4
a4589 4
	case 32:
	  result = 0;
	  bfd_put_32 (stdoutput, new_val, buf);
	  break;
d4591 3
a4593 4
	default:
	  as_bad (_("Unknown relocation encountered in md_apply_fix."));
	  return 0;
	}
d4595 2
a4596 8
      /* Insert the relocation.  */
      bfd_put_32 (stdoutput, bfd_get_32 (stdoutput, buf) | result, buf);
      return 1;
    }
  else
    {
      printf (_("no hppa_fixup entry for this fixup (fixP = 0x%x, type = 0x%x)\n"),
	      (unsigned int) fixP, fixP->fx_r_type);
d4599 4
d4630 7
a4636 5
   Return a number or -1 for failure.

   When parsing PA-89 FP register numbers RESULT will be
   the address of a structure to return information about
   L/R half of FP registers, store results there as appropriate.
d4642 1
a4642 1
pa_parse_number (s, result)
d4644 1
a4644 1
     struct pa_11_fp_reg_struct *result;
d4652 1
d4658 4
a4661 9
  /* Store info in RESULT if requested by caller.  */
  if (result)
    {
      result->number_part = -1;
      result->l_r_select = -1;
    }
  num = -1;

  if (isdigit (*p))
a4663 1
      num = 0;
d4691 4
a4694 2
      /* Store info in RESULT if requested by the caller.  */
      if (result)
d4696 2
a4697 3
	  result->number_part = num;

	  if (IS_R_SELECT (p))
d4699 9
a4707 2
	      result->l_r_select = 1;
	      ++p;
a4708 7
	  else if (IS_L_SELECT (p))
	    {
	      result->l_r_select = 0;
	      ++p;
	    }
	  else
	    result->l_r_select = 0;
d4714 1
a4714 1
      num = 0;
d4720 1
a4720 1
         slow. */
d4770 1
a4770 11
      /* Store info in RESULT if requested by caller.  */
      if (result)
	{
	  result->number_part = num;
	  if (IS_R_SELECT (p - 1))
	    result->l_r_select = 1;
	  else if (IS_L_SELECT (p - 1))
	    result->l_r_select = 0;
	  else
	    result->l_r_select = 0;
	}
d4775 1
a4775 2
         is effectively a constant.  */
      num = 0;
d4786 8
a4793 1
	  if (S_GET_SEGMENT (sym) == &bfd_abs_section)
d4795 1
a4795 1
	  else
d4802 1
a4802 1
      else
d4819 1
a4819 11
      /* Store info in RESULT if requested by caller.  */
      if (result)
	{
	  result->number_part = num;
	  if (IS_R_SELECT (p - 1))
	    result->l_r_select = 1;
	  else if (IS_L_SELECT (p - 1))
	    result->l_r_select = 0;
	  else
	    result->l_r_select = 0;
	}
d4822 6
a4827 2
  *s = p;
  return num;
d4830 1
a4830 1
#define REG_NAME_CNT	(sizeof(pre_defined_registers) / sizeof(struct pd_reg))
a4860 1

d4865 1
a4865 3
need_pa11_opcode (insn, result)
     struct pa_it *insn;
     struct pa_11_fp_reg_struct *result;
d4867 2
a4868 1
  if (result->l_r_select == 1 && !(insn->fpof1 == DBL && insn->fpof2 == DBL))
d5164 1
a5164 1
/* Mark (via expr_end) the end of an absolute expression.  FIXME. */
d5180 1
a5180 1
     r5, or is that 4 MOD 5?
d5229 1
a5229 1
  int value;
d5236 1
a5236 57
  switch (field_selector)
    {
    /* No change.  */
    case e_fsel:
      break;

    /* If bit 21 is on then add 0x800 and arithmetic shift right 11 bits.  */
    case e_lssel:
      if (value & 0x00000400)
	value += 0x800;
      value = (value & 0xfffff800) >> 11;
      break;

    /* Sign extend from bit 21.  */
    case e_rssel:
      if (value & 0x00000400)
	value |= 0xfffff800;
      else
	value &= 0x7ff;
      break;

    /* Arithmetic shift right 11 bits.  */
    case e_lsel:
      value = (value & 0xfffff800) >> 11;
      break;

    /* Set bits 0-20 to zero.  */
    case e_rsel:
      value = value & 0x7ff;
      break;

    /* Add 0x800 and arithmetic shift right 11 bits.  */
    case e_ldsel:
      value += 0x800;
      value = (value & 0xfffff800) >> 11;
      break;

    /* Set bitgs 0-21 to one.  */
    case e_rdsel:
      value |= 0xfffff800;
      break;

#define RSEL_ROUND(c)  (((c) + 0x1000) & ~0x1fff)
    case e_rrsel:
      value = (RSEL_ROUND (value) & 0x7ff) + (value - RSEL_ROUND (value));
      break;

    case e_lrsel:
      value = (RSEL_ROUND (value) >> 11) & 0x1fffff;
      break;
#undef RSEL_ROUND

    default:
      BAD_CASE (field_selector);
      break;
    }
  return value;
a5345 1

a5391 1

a5421 1

a5471 1

a5474 1

a5487 1
  char *save_s = *s;
a5568 1

a5581 1
  char *save_s = *s;
a5630 1

d5891 1
d5910 1
a5910 1
     int z;
d5948 1
a5948 1
     int begin;
d5959 1
a5959 1
		e_fsel, 0, 0, NULL);
d5969 1
a5969 1
     int begin;
d5984 1
a5984 1
		e_fsel, 0, 0, NULL);
d5996 1
a5996 1
     int unused;
a6084 1
  char *unwind;
d6086 4
a6089 4
  asymbol *sym;
  subsegT subseg, save_subseg;
  int i, reloc;
  char c, *p;
d6091 3
a6093 1
  if (now_seg != text_section)
d6096 1
a6096 5
  if (bfd_get_arch_info (stdoutput)->bits_per_address == 32)
    reloc = R_PARISC_DIR32;
  else
    reloc = R_PARISC_SEGREL32;

a6113 1

d6116 1
a6116 2
  p = frag_more (4);
  md_number_to_chars (p, 0, 4);
d6119 1
d6123 1
a6123 4
		e_fsel, 32, 0, NULL);

  p = frag_more (4);
  md_number_to_chars (p, 0, 4);
d6132 2
a6133 2

  fix_new_hppa (frag_now, p - frag_now->fr_literal, 4,
d6136 1
a6136 1
		e_fsel, 32, 0, NULL);
d6138 6
a6143 9
  /* Dump it. */
  unwind = (char *) &call_info->ci_unwind;
  for (i = 8; i < sizeof (struct unwind_table); i++)
    {
      c = *(unwind + i);
      {
	FRAG_APPEND_1_CHAR (c);
      }
    }
d6156 1
a6156 1
     int unused;
d6295 3
a6297 2
/* Switch into the code subspace.  */

d6299 2
a6300 2
pa_code (unused)
     int unused;
d6307 1
d6312 14
d6348 1
a6348 1
     int unused;
d6375 1
d6381 1
a6381 1
     int unused;
d6389 1
a6389 1
     int unused;
d6404 1
a6404 1
     int unused;
d6433 2
a6434 1
      char *where = frag_more (0);
d6436 2
d6440 1
a6440 2
		    0, R_HPPA_ENTRY, e_fsel, 0, 0,
		    (int *) &last_call_info->ci_unwind.descriptor);
d6445 21
d6479 7
a6485 1
	S_SET_VALUE (symbol, pa_parse_number (&input_line_pointer, 0));
d6487 18
a6504 2
	S_SET_VALUE (symbol, (unsigned int) get_absolute_expression ());
      S_SET_SEGMENT (symbol, bfd_abs_section_ptr);
d6548 1
a6548 1
		(int *) &last_call_info->ci_unwind.descriptor + 1);
d6556 1
a6556 1
     int unused;
d6589 1
a6589 1
     int unused;
d6606 5
a6610 1
      /* OK.  Set the external bits and process argument relocations.  */
d6612 1
d6635 1
a6635 1
  obj_symbol_type *symbol = (obj_symbol_type *) symbol_get_bfdsym (symbolP);
d6641 1
a6641 1
      symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
d6660 1
a6660 1
	  symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6665 1
a6665 1
	  symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
d6672 2
a6673 2
      symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
      symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
d6679 1
a6679 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6685 9
a6693 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6699 1
a6699 1
      symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
d6705 1
a6705 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6711 1
a6711 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d6719 1
a6719 1
  obj_set_symbol_type (symbol_get_bfdsym (symbolP), (int) type);
d6740 2
a6741 2
#ifdef OBJ_SOM
	  symbol->tc_data.ap.hppa_arg_reloc |= arg_reloc;
d6754 2
a6755 2
#ifdef OBJ_SOM
	  symbol->tc_data.ap.hppa_arg_reloc |= arg_reloc;
d6767 1
a6767 1
	  symbol->tc_data.ap.hppa_priv_level = temp;
d6789 1
a6789 1
     int unused;
d6841 1
a6841 1
     int unused;
d6871 1
a6871 1
     int unused;
d6886 1
a6886 1
     int unused;
d6927 1
a6927 1
     int unused;
d6943 1
a6943 1
     int unused;
d6974 1
a6974 1
   of a procedure from a syntatical point of view.  */
d6978 1
a6978 1
     int unused;
d7048 1
a7048 1
     int unused;
d7079 2
a7080 1
		  char *where = frag_more (0);
d7082 2
d7086 1
a7086 2
				0, R_HPPA_ENTRY, e_fsel, 0, 0,
				(int *) &last_call_info->ci_unwind.descriptor);
d7117 1
a7135 2

#ifdef OBJ_SOM
d7159 1
a7159 1
  int spnum, temp;
d7193 3
a7195 2
      temp = pa_parse_number (&ptemp, 0);
      if (temp >= 0)
d7197 1
a7197 1
	  spnum = temp;
d7276 1
a7276 1
     int unused;
a7278 1
  int temp;
d7356 3
a7358 1
      if ((temp = pa_parse_number (&input_line_pointer, 0)) >= 0)
d7360 1
a7360 1
	  if ((sd_chain = pa_find_space_by_number (temp)))
d7396 1
a7396 1
     int unused;
a7644 1

a7686 1

a7708 1

a7769 2


a8133 5
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

d8156 1
a8156 1
     For example, \xDD where DD is a hexidecimal number should be
d8159 5
d8182 1
a8182 1
		/* Get pas the 'x'.  */
d8231 1
a8231 1
     int unused;
d8243 1
a8243 1
     int unused;
d8255 1
a8255 1
     int unused;
a8271 15
/* Switch to the data space.  As usual delete our label.  */

static void
pa_data (unused)
     int unused;
{
#ifdef OBJ_SOM
  current_space = is_defined_space ("$PRIVATE$");
  current_subspace
    = pa_subsegment_to_subspace (current_space->sd_seg, 0);
#endif
  s_data (0);
  pa_undefine_label ();
}

d8286 1
a8286 1
     int unused;
d8316 1
a8316 1
     int unused;
a8326 16
/* Switch to the text space.  Like s_text, but delete our
   label when finished.  */
static void
pa_text (unused)
     int unused;
{
#ifdef OBJ_SOM
  current_space = is_defined_space ("$TEXT$");
  current_subspace
    = pa_subsegment_to_subspace (current_space->sd_seg, 0);
#endif

  s_text (0);
  pa_undefine_label ();
}

d8364 11
d8392 29
a8420 1
     That confuses the HP linker.  */
a8424 1
#endif
a8435 3
  if (fixp->fx_addsy && S_IS_EXTERNAL (fixp->fx_addsy))
    return 0;

d8441 2
a8442 2
  if (fixp->fx_addsy == 0 || ! S_IS_FUNCTION (fixp->fx_addsy))
    return 1;
d8444 1
a8444 1
  return 0;
d8453 1
a8453 1
     fixS *fixp;
a8455 1
  int distance;
d8459 6
a8464 5
  if (fixp->fx_r_type == R_HPPA_ENTRY || fixp->fx_r_type == R_HPPA_EXIT
      || fixp->fx_r_type == R_HPPA_BEGIN_BRTAB
      || fixp->fx_r_type == R_HPPA_END_BRTAB
      || fixp->fx_r_type == R_HPPA_BEGIN_TRY
      || fixp->fx_r_type == R_HPPA_END_TRY
d8469 7
d8477 4
a8480 2
#define arg_reloc_stub_needed(CALLER, CALLEE) \
  ((CALLEE) && (CALLER) && ((CALLEE) != (CALLER)))
a8481 1
#ifdef OBJ_SOM
d8484 4
a8487 5
     call stub.  FIXME.  Can't we need the same for absolute calls?  */
  if (fixp->fx_pcrel && fixp->fx_addsy
      && (arg_reloc_stub_needed ((long) ((obj_symbol_type *)
	symbol_get_bfdsym (fixp->fx_addsy))->tc_data.ap.hppa_arg_reloc,
	hppa_fixp->fx_arg_reloc)))
d8489 12
d8502 3
a8504 6
  distance = (fixp->fx_offset + S_GET_VALUE (fixp->fx_addsy)
	      - md_pcrel_from (fixp));
  /* Now check and see if we're going to need a long-branch stub.  */
  if (fixp->fx_r_type == R_HPPA_PCREL_CALL
      && (distance > 262143 || distance < -262144))
    return 1;
d8506 1
a8506 1
  if (fixp->fx_r_type == R_HPPA_ABS_CALL)
a8507 1
#undef arg_reloc_stub_needed
d8523 8
a8530 3
  char *name = (char *)
    xmalloc (strlen ("L$\001end_") +
	     strlen (S_GET_NAME (last_call_info->start_symbol)) + 1);
d8532 3
a8598 1
#endif
d8600 25
a8624 2
#ifdef OBJ_ELF
pa_end_of_source ()
d8626 16
a8641 2
  if (debug_type == DEBUG_DWARF2)
    dwarf2_finish ();
@


1.4
log
@fid the reloc bug
@
text
@d2 2
a3 1
   Copyright (C) 1989, 1996 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 1, or (at your option)
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d38 12
a52 7
/* Names of various debugging spaces/subspaces.  */
#define GDB_DEBUG_SPACE_NAME ".stab"
#define GDB_STRINGS_SUBSPACE_NAME ".stabstr"
#define GDB_SYMBOLS_SUBSPACE_NAME ".stab"
#define UNWIND_SECTION_NAME ".PARISC.unwind"
/* Nonzero if CODE is a fixup code needing further processing.  */

d54 1
a54 1
typedef elf32_hppa_reloc_type reloc_type;
d59 1
d61 4
a64 1
#define hppa_gen_reloc_type hppa_elf_gen_reloc_type
d71 1
a71 2
/* Use space aliases.  */
#define USE_ALIASES 1
a87 3
/* Do not use space aliases.  */
#define USE_ALIASES 0

d175 1
a175 1
    SGL, DBL, ILLEGAL_FMT, QUAD
d213 3
d278 1
a332 11
/* Structure for previous label tracking.  Needed so that alignments,
   callinfo declarations, etc can be easily attached to a particular
   label.  */
typedef struct label_symbol_struct
  {
    struct symbol *lss_label;
    sd_chain_struct *lss_space;
    struct label_symbol_struct *lss_next;
  }
label_symbol_struct;

a378 3
    /* An alias for this section (or NULL if no alias exists).  */
    char *alias;

d409 2
d412 15
a426 3
    /* An alias for this section (or NULL if no alias exists).  */
    char *alias;
  };
d432 1
a432 1
    enum hppa_reloc_field_selector_type fx_r_field;
d473 1
d475 2
d498 3
a500 1
static void pa_align PARAMS ((int));
a523 3
static void pa_space PARAMS ((int));
static void pa_spnum PARAMS ((int));
static void pa_subspace PARAMS ((int));
d530 6
d556 4
d564 1
a564 1
				  enum hppa_reloc_field_selector_type,
a569 1
static void pa_build_unwind_subspace PARAMS ((struct call_info *));
a570 1
static sd_chain_struct *pa_parse_space_stmt PARAMS ((char *, int));
a571 1
static int pa_next_subseg PARAMS ((sd_chain_struct *));
d573 4
a576 1
static void pa_spaces_begin PARAMS ((void));
d578 2
d583 1
d591 1
a603 4
/* Jumps are always the same size -- one instruction.  */
int md_short_jump_size = 4;
int md_long_jump_size = 4;

d618 1
d620 4
d633 3
d639 1
d648 3
d660 3
d665 1
d667 1
d678 1
d681 1
d684 1
d686 1
d741 7
d750 1
d1029 1
d1040 1
d1044 1
d1062 5
a1066 8
  {"$CODE$", 1, 1, 1, 0, 0, 0, 24, 0x2c, 0, 8, 0, 0, ".text", SUBSEG_CODE},
  {"$DATA$", 1, 1, 0, 0, 0, 0, 24, 0x1f, 1, 8, 1, 1, ".data", SUBSEG_DATA},
  {"$LIT$", 1, 1, 0, 0, 0, 0, 16, 0x2c, 0, 8, 0, 0, ".text", SUBSEG_LIT},
  {"$MILLICODE$", 1, 1, 0, 0, 0, 0, 8, 0x2c, 0, 8, 0, 0, ".text", SUBSEG_MILLI},
  {"$BSS$", 1, 1, 0, 0, 0, 1, 80, 0x1f, 1, 8, 1, 1, ".bss", SUBSEG_BSS},
#ifdef OBJ_ELF
  {"$UNWIND$", 1, 1, 0, 0, 0, 0, 64, 0x2c, 0, 4, 0, 0, ".PARISC.unwind", SUBSEG_UNWIND},
#endif
d1072 3
a1074 3
  {"$TEXT$", 0, 1, 1, 0, 8, ASEC_NULL, ".text"},
  {"$PRIVATE$", 1, 1, 1, 1, 16, ASEC_NULL, ".data"},
  {NULL, 0, 0, 0, 0, 0, ASEC_NULL, NULL}
a1078 5
/* Return nonzero if the string pointed to by S potentially represents
   a right or left half of a FP register  */
#define IS_R_SELECT(S)   (*(S) == 'R' || *(S) == 'r')
#define IS_L_SELECT(S)   (*(S) == 'L' || *(S) == 'l')

d1087 6
d1111 1
a1111 1
          as_bad ("Field out of range [%d..%d] (%d).", (LOW), (HIGH), \
d1119 1
a1119 1
   && strcmp((exp).X_op_symbol->bsym->name, "$global$") == 0)
d1123 1
a1123 1
   && strcmp((exp).X_op_symbol->bsym->name, "$PIC_pcrel$0") == 0)
d1140 1
a1140 1
    as_fatal ("Missing .exit\n");
d1143 1
a1143 13
    as_fatal ("Missing .procend\n");
}

/* Check to make sure we have a valid space and subspace.  */

static void
pa_check_current_space_and_subspace ()
{
  if (current_space == NULL)
    as_fatal ("Not in a space.\n");

  if (current_subspace == NULL)
    as_fatal ("Not in a subspace.\n");
a1152 1
  sd_chain_struct *space_chain = current_space;
d1157 3
a1159 1
    if (space_chain == label_chain->lss_space && label_chain->lss_label)
d1161 6
a1178 1
  sd_chain_struct *space_chain = current_space;
d1188 6
a1193 1
      label_chain->lss_space = space_chain;
a1210 1
  sd_chain_struct *space_chain = current_space;
d1216 8
a1223 1
      if (space_chain == label_chain->lss_space && label_chain->lss_label)
d1257 1
a1257 1
     enum hppa_reloc_field_selector_type r_field;
d1322 1
a1322 1
    as_warn ("Invalid field selector.  Assuming F%%.");
d1326 1
a1326 1
		hppa_field_selector, 32, 0, NULL);
d1347 1
a1347 1
    as_warn ("could not set architecture and machine");
d1353 1
a1353 1
      as_warn ("-R option not supported on this target.");
d1357 1
d1359 1
d1369 1
a1369 1
	  as_fatal ("Internal error: can't hash `%s': %s\n", name, retval);
d1377 1
a1377 1
	      fprintf (stderr, "internal error: losing opcode: `%s' \"%s\"\n",
d1387 1
a1387 1
    as_fatal ("Broken assembler.  No assembly attempted.");
d1389 1
d1393 1
d1395 1
d1398 3
d1429 2
a1430 1
	      label_symbol->lss_label->bsym->flags |= BSF_FUNCTION;
d1446 1
a1446 1
	    as_bad ("Missing function name for .PROC (corrupted label chain)");
d1449 1
a1449 1
	as_bad ("Missing function name for .PROC");
d1467 17
d1502 1
d1505 7
d1533 1
a1533 1
      as_fatal ("Unknown opcode: `%s'", str);
a1537 8
  /* Convert everything into lower case.  */
  while (*save_s)
    {
      if (isupper (*save_s))
	*save_s = tolower (*save_s);
      save_s++;
    }

d1557 2
a1558 1
      bzero (&the_insn, sizeof (the_insn));
d1564 4
a1567 1
      if (bfd_get_mach (stdoutput) < insn->arch)
d1570 6
a1575 1
	    as_warn ("could not update architecture and machine");
d1582 4
d1617 3
d1624 19
d1645 3
a1652 1
	    case 'y':
d1654 3
d1661 10
d1674 2
d1683 2
d1686 3
a1688 1
	      CHECK_FIELD (num, 15, -16, 0);
d1695 2
d1698 4
a1701 2
	      CHECK_FIELD (num, 15, -16, 0)
		low_sign_unext (num, 5, &num);
d1707 2
d1711 1
a1711 1
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d1716 11
d1728 1
a1728 1
	      CHECK_FIELD (num, 31, 0, 0);
d1733 3
d1742 3
d1750 1
a1750 1
	    /* Handle a completer for an indexing load or store.  */
d1752 5
a1756 5
	      {
		int uu = 0;
		int m = 0;
		int i = 0;
		while (*s == ',' && i < 2)
d1758 4
a1761 2
		    s++;
		    if (strncasecmp (s, "sm", 2) == 0)
d1763 21
a1783 2
			uu = 1;
			m = 1;
d1787 4
a1790 8
		    else if (strncasecmp (s, "m", 1) == 0)
		      m = 1;
		    else if (strncasecmp (s, "s", 1) == 0)
		      uu = 1;
		    else
		      as_bad ("Invalid Indexed Load Completer.");
		    s++;
		    i++;
a1791 5
		if (i > 2)
		  as_bad ("Invalid Indexed Load Completer Syntax.");
		opcode |= m << 5;
		INSERT_FIELD_AND_CONTINUE (opcode, uu, 13);
	      }
d1793 5
a1797 6
	    /* Handle a short load/store completer.  */
	    case 'C':
	      {
		int a = 0;
		int m = 0;
		if (*s == ',')
d1799 47
a1845 2
		    s++;
		    if (strncasecmp (s, "ma", 2) == 0)
d1847 2
a1848 2
			a = 0;
			m = 1;
d1850 1
a1850 1
		    else if (strncasecmp (s, "mb", 2) == 0)
d1852 5
a1856 2
			a = 1;
			m = 1;
a1857 3
		    else
		      as_bad ("Invalid Short Load/Store Completer.");
		    s += 2;
a1858 3
		opcode |= m << 5;
		INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
	      }
d1860 2
a1861 7
	    /* Handle a stbys completer.  */
	    case 'Y':
	      {
		int a = 0;
		int m = 0;
		int i = 0;
		while (*s == ',' && i < 2)
d1863 28
a1890 11
		    s++;
		    if (strncasecmp (s, "m", 1) == 0)
		      m = 1;
		    else if (strncasecmp (s, "b", 1) == 0)
		      a = 0;
		    else if (strncasecmp (s, "e", 1) == 0)
		      a = 1;
		    else
		      as_bad ("Invalid Store Bytes Short Completer");
		    s++;
		    i++;
a1891 5
		if (i > 2)
		  as_bad ("Invalid Store Bytes Short Completer");
		opcode |= m << 5;
		INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
	      }
d1893 2
a1894 6
	    /* Handle a non-negated compare/stubtract condition.  */
	    case '<':
	      cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
	      if (cmpltr < 0)
		{
		  as_bad ("Invalid Compare/Subtract Condition: %c", *s);
d1896 1
a1896 12
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

	    /* Handle a negated or non-negated compare/subtract condition.  */
	    case '?':
	      save_s = s;
	      cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
	      if (cmpltr < 0)
		{
		  s = save_s;
		  cmpltr = pa_parse_neg_cmpsub_cmpltr (&s, 1);
		  if (cmpltr < 0)
d1898 2
a1899 7
		      as_bad ("Invalid Compare/Subtract Condition.");
		      cmpltr = 0;
		    }
		  else
		    {
		      /* Negated condition requires an opcode change.  */
		      opcode |= 1 << 27;
d1901 1
a1901 2
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d1903 2
a1904 6
	    /* Handle non-negated add condition.  */
	    case '!':
	      cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
	      if (cmpltr < 0)
		{
		  as_bad ("Invalid Compare/Subtract Condition: %c", *s);
d1906 1
a1906 12
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

	    /* Handle a negated or non-negated add condition.  */
	    case '@@':
	      save_s = s;
	      cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
	      if (cmpltr < 0)
		{
		  s = save_s;
		  cmpltr = pa_parse_neg_add_cmpltr (&s, 1);
		  if (cmpltr < 0)
d1908 2
a1909 2
		      as_bad ("Invalid Compare/Subtract Condition");
		      cmpltr = 0;
d1911 1
a1911 1
		  else
d1913 2
a1914 2
		      /* Negated condition requires an opcode change.  */
		      opcode |= 1 << 27;
d1916 1
a1916 2
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d1918 4
a1921 9
	    /* Handle a compare/subtract condition.  */
	    case 'a':
	      cmpltr = 0;
	      flag = 0;
	      save_s = s;
	      if (*s == ',')
		{
		  cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 0);
		  if (cmpltr < 0)
d1923 2
a1924 7
		      flag = 1;
		      s = save_s;
		      cmpltr = pa_parse_neg_cmpsub_cmpltr (&s, 0);
		      if (cmpltr < 0)
			{
			  as_bad ("Invalid Compare/Subtract Condition");
			}
d1926 22
a1947 3
		}
	      opcode |= cmpltr << 13;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);
d1949 25
a1973 30
	    /* Handle a non-negated add condition.  */
	    case 'd':
	      cmpltr = 0;
	      nullif = 0;
	      flag = 0;
	      if (*s == ',')
		{
		  s++;
		  name = s;
		  while (*s != ',' && *s != ' ' && *s != '\t')
		    s += 1;
		  c = *s;
		  *s = 0x00;
		  if (strcmp (name, "=") == 0)
		    cmpltr = 1;
		  else if (strcmp (name, "<") == 0)
		    cmpltr = 2;
		  else if (strcmp (name, "<=") == 0)
		    cmpltr = 3;
		  else if (strcasecmp (name, "nuv") == 0)
		    cmpltr = 4;
		  else if (strcasecmp (name, "znv") == 0)
		    cmpltr = 5;
		  else if (strcasecmp (name, "sv") == 0)
		    cmpltr = 6;
		  else if (strcasecmp (name, "od") == 0)
		    cmpltr = 7;
		  else if (strcasecmp (name, "n") == 0)
		    nullif = 1;
		  else if (strcasecmp (name, "tr") == 0)
a1974 1
		      cmpltr = 0;
d1976 1
d1978 1
a1978 1
		  else if (strcmp (name, "<>") == 0)
d1980 2
a1981 2
		      cmpltr = 1;
		      flag = 1;
d1983 14
a1996 1
		  else if (strcmp (name, ">=") == 0)
d1998 2
a1999 2
		      cmpltr = 2;
		      flag = 1;
d2001 6
a2006 1
		  else if (strcmp (name, ">") == 0)
a2007 1
		      cmpltr = 3;
d2009 1
d2011 9
a2019 1
		  else if (strcasecmp (name, "uv") == 0)
a2020 1
		      cmpltr = 4;
d2022 1
d2024 7
a2030 1
		  else if (strcasecmp (name, "vnz") == 0)
d2032 2
a2033 2
		      cmpltr = 5;
		      flag = 1;
d2035 7
a2041 1
		  else if (strcasecmp (name, "nsv") == 0)
d2043 2
a2044 2
		      cmpltr = 6;
		      flag = 1;
d2046 1
a2046 1
		  else if (strcasecmp (name, "ev") == 0)
d2048 2
a2049 2
		      cmpltr = 7;
		      flag = 1;
d2051 8
a2058 30
		  else
		    as_bad ("Invalid Add Condition: %s", name);
		  *s = c;
		}
	      nullif = pa_parse_nullif (&s);
	      opcode |= nullif << 1;
	      opcode |= cmpltr << 13;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

	    /* HANDLE a logical instruction condition.  */
	    case '&':
	      cmpltr = 0;
	      flag = 0;
	      if (*s == ',')
		{
		  s++;
		  name = s;
		  while (*s != ',' && *s != ' ' && *s != '\t')
		    s += 1;
		  c = *s;
		  *s = 0x00;
		  if (strcmp (name, "=") == 0)
		    cmpltr = 1;
		  else if (strcmp (name, "<") == 0)
		    cmpltr = 2;
		  else if (strcmp (name, "<=") == 0)
		    cmpltr = 3;
		  else if (strcasecmp (name, "od") == 0)
		    cmpltr = 7;
		  else if (strcasecmp (name, "tr") == 0)
a2059 1
		      cmpltr = 0;
d2061 1
d2063 1
a2063 1
		  else if (strcmp (name, "<>") == 0)
d2065 2
a2066 2
		      cmpltr = 1;
		      flag = 1;
d2068 10
a2077 1
		  else if (strcmp (name, ">=") == 0)
a2078 1
		      cmpltr = 2;
d2080 1
d2082 1
a2082 1
		  else if (strcmp (name, ">") == 0)
d2084 2
a2085 2
		      cmpltr = 3;
		      flag = 1;
d2087 9
a2095 1
		  else if (strcasecmp (name, "ev") == 0)
a2096 1
		      cmpltr = 7;
d2098 1
a2099 6
		  else
		    as_bad ("Invalid Logical Instruction Condition.");
		  *s = c;
		}
	      opcode |= cmpltr << 13;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);
d2101 7
a2107 8
	    /* Handle a unit instruction condition.  */
	    case 'U':
	      cmpltr = 0;
	      flag = 0;
	      if (*s == ',')
		{
		  s++;
		  if (strncasecmp (s, "sbz", 3) == 0)
d2109 2
a2110 2
		      cmpltr = 2;
		      s += 3;
d2112 1
a2112 1
		  else if (strncasecmp (s, "shz", 3) == 0)
d2114 1
a2114 1
		      cmpltr = 3;
d2117 10
a2126 6
		  else if (strncasecmp (s, "sdc", 3) == 0)
		    {
		      cmpltr = 4;
		      s += 3;
		    }
		  else if (strncasecmp (s, "sbc", 3) == 0)
a2127 11
		      cmpltr = 6;
		      s += 3;
		    }
		  else if (strncasecmp (s, "shc", 3) == 0)
		    {
		      cmpltr = 7;
		      s += 3;
		    }
		  else if (strncasecmp (s, "tr", 2) == 0)
		    {
		      cmpltr = 0;
d2129 1
a2129 1
		      s += 2;
d2131 1
a2131 1
		  else if (strncasecmp (s, "nbz", 3) == 0)
d2133 1
a2133 2
		      cmpltr = 2;
		      flag = 1;
d2136 10
a2145 1
		  else if (strncasecmp (s, "nhz", 3) == 0)
a2146 1
		      cmpltr = 3;
d2148 1
a2148 1
		      s += 3;
d2150 1
a2150 1
		  else if (strncasecmp (s, "ndc", 3) == 0)
d2152 2
a2153 3
		      cmpltr = 4;
		      flag = 1;
		      s += 3;
d2155 9
a2163 1
		  else if (strncasecmp (s, "nbc", 3) == 0)
a2164 1
		      cmpltr = 6;
d2168 24
a2191 1
		  else if (strncasecmp (s, "nhc", 3) == 0)
d2193 10
a2202 3
		      cmpltr = 7;
		      flag = 1;
		      s += 3;
d2205 20
a2224 4
		    as_bad ("Invalid Logical Instruction Condition.");
		}
	      opcode |= cmpltr << 13;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);
d2226 3
a2228 29
	    /* Handle a shift/extract/deposit condition.  */
	    case '|':
	    case '>':
	      cmpltr = 0;
	      if (*s == ',')
		{
		  save_s = s++;
		  name = s;
		  while (*s != ',' && *s != ' ' && *s != '\t')
		    s += 1;
		  c = *s;
		  *s = 0x00;
		  if (strcmp (name, "=") == 0)
		    cmpltr = 1;
		  else if (strcmp (name, "<") == 0)
		    cmpltr = 2;
		  else if (strcasecmp (name, "od") == 0)
		    cmpltr = 3;
		  else if (strcasecmp (name, "tr") == 0)
		    cmpltr = 4;
		  else if (strcmp (name, "<>") == 0)
		    cmpltr = 5;
		  else if (strcmp (name, ">=") == 0)
		    cmpltr = 6;
		  else if (strcasecmp (name, "ev") == 0)
		    cmpltr = 7;
		  /* Handle movb,n.  Put things back the way they were.
		     This includes moving s back to where it started.  */
		  else if (strcasecmp (name, "n") == 0 && *args == '|')
d2230 28
a2257 2
		      *s = c;
		      s = save_s;
d2261 5
a2265 2
		    as_bad ("Invalid Shift/Extract/Deposit Condition.");
		  *s = c;
d2267 180
a2446 1
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d2448 276
a2723 20
	    /* Handle bvb and bb conditions.  */
	    case '~':
	      cmpltr = 0;
	      if (*s == ',')
		{
		  s++;
		  if (strncmp (s, "<", 1) == 0)
		    {
		      cmpltr = 2;
		      s++;
		    }
		  else if (strncmp (s, ">=", 2) == 0)
		    {
		      cmpltr = 6;
		      s += 2;
		    }
		  else
		    as_bad ("Invalid Bit Branch Condition: %c", *s);
		}
	      INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);
d2725 102
a2826 9
	    /* Handle a system control completer.  */
	    case 'Z':
	      if (*s == ',' && (*(s + 1) == 'm' || *(s + 1) == 'M'))
		{
		  flag = 1;
		  s += 2;
		}
	      else
		flag = 0;
d2828 5
a2832 1
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);
d2844 47
d2916 120
d3096 1
a3096 1
		      as_bad ("Branch to unaligned address");
d3109 1
a3109 1
		  bzero (&last_call_desc, sizeof (struct call_desc));
d3129 1
a3129 1
		      as_bad ("Branch to unaligned address");
d3147 40
a3186 1
		  bzero (&last_call_desc, sizeof (struct call_desc));
d3205 1
a3205 1
		      as_bad ("Branch to unaligned address");
d3223 1
a3223 1
		  bzero (&last_call_desc, sizeof (struct call_desc));
d3227 43
d3273 2
d3276 1
a3276 1
	      CHECK_FIELD (num, 31, 0, 0);
d3279 36
d3318 2
d3321 1
a3321 1
	      CHECK_FIELD (num, 31, 0, 0);
d3324 24
d3351 4
d3356 1
a3356 1
	      CHECK_FIELD (num, 31, 0, 0);
d3359 9
d3371 2
d3374 1
a3374 1
	      CHECK_FIELD (num, 8191, 0, 0);
d3380 2
d3383 1
a3383 1
	      CHECK_FIELD (num, 671108864, 0, 0);
d3387 1
a3387 1
	    case 'f':
d3389 1
a3389 1
		as_bad ("Invalid SFU identifier");
d3391 2
d3394 1
a3394 1
	      CHECK_FIELD (num, 7, 0, 0);
d3400 2
d3403 1
a3403 1
	      CHECK_FIELD (num, 1048575, 0, 0);
d3410 2
d3413 1
a3413 1
	      CHECK_FIELD (num, 32767, 0, 0);
d3419 2
d3422 1
a3422 1
	      CHECK_FIELD (num, 1023, 0, 0);
d3429 2
d3432 1
a3432 1
	      CHECK_FIELD (num, 32767, 0, 0);
d3439 1
a3439 1
		as_bad ("Invalid COPR identifier");
d3441 2
d3444 1
a3444 1
	      CHECK_FIELD (num, 7, 0, 0);
d3450 2
d3453 1
a3453 1
	      CHECK_FIELD (num, 4194303, 0, 0);
d3458 76
d3547 42
a3588 4
	    /* Handle FP compare conditions.  */
	    case 'M':
	      cond = pa_parse_fp_cmp_cond (&s);
	      INSERT_FIELD_AND_CONTINUE (opcode, cond, 0);
d3590 13
a3602 4
	    /* Handle L/R register halves like 't'.  */
	    case 'v':
	      {
		struct pa_11_fp_reg_struct result;
d3604 2
a3605 10
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= result.number_part;

		/* 0x30 opcodes are FP arithmetic operation opcodes
		   and need to be turned into 0x38 opcodes.  This
		   is not necessary for loads/stores.  */
		if (need_pa11_opcode (&the_insn, &result)
		    && ((opcode & 0xfc000000) == 0x30000000))
		  opcode |= 1 << 27;
d3607 4
a3610 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.l_r_select & 1, 6);
	      }
d3612 13
a3624 4
	    /* Handle L/R register halves like 'b'.  */
	    case 'E':
	      {
		struct pa_11_fp_reg_struct result;
d3626 3
a3628 4
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= result.number_part << 21;
		if (need_pa11_opcode (&the_insn, &result))
d3630 8
d3639 1
a3639 1
		    opcode |= 1 << 27;
a3640 2
		continue;
	      }
d3642 18
a3659 4
	    /* Handle L/R register halves like 'x'.  */
	    case 'X':
	      {
		struct pa_11_fp_reg_struct result;
d3661 2
a3662 4
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		opcode |= (result.number_part & 0x1f) << 16;
		if (need_pa11_opcode (&the_insn, &result))
d3664 8
d3673 1
a3673 1
		    opcode |= 1 << 27;
a3674 2
		continue;
	      }
d3676 15
a3690 4
	    /* Handle a 5 bit register field at 10.  */
	    case '4':
	      {
		struct pa_11_fp_reg_struct result;
d3692 2
a3693 3
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		if (the_insn.fpof1 == SGL)
d3695 8
a3702 1
		    if (result.number_part < 16)
d3704 8
a3711 2
			as_bad  ("Invalid register for single precision fmpyadd or fmpysub");
			break;
d3713 1
a3713 3

		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
a3714 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 21);
	      }
d3716 4
a3719 4
	    /* Handle a 5 bit register field at 15.  */
	    case '6':
	      {
		struct pa_11_fp_reg_struct result;
d3721 6
a3726 5
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		if (the_insn.fpof1 == SGL)
		  {
		    if (result.number_part < 16)
d3728 7
a3734 2
			as_bad  ("Invalid register for single precision fmpyadd or fmpysub");
			break;
d3736 1
a3736 2
		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
a3737 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 16);
	      }
d3739 4
a3742 4
	    /* Handle a 5 bit register field at 31.  */
	    case '7':
	      {
		struct pa_11_fp_reg_struct result;
d3744 6
a3749 5
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		if (the_insn.fpof1 == SGL)
		  {
		    if (result.number_part < 16)
d3751 7
a3757 2
			as_bad  ("Invalid register for single precision fmpyadd or fmpysub");
			break;
d3759 1
a3759 2
		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
a3760 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 0);
	      }
d3762 4
a3765 4
	    /* Handle a 5 bit register field at 20.  */
	    case '8':
	      {
		struct pa_11_fp_reg_struct result;
d3767 6
a3772 5
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		if (the_insn.fpof1 == SGL)
		  {
		    if (result.number_part < 16)
d3774 7
a3780 2
			as_bad  ("Invalid register for single precision fmpyadd or fmpysub");
			break;
d3782 1
a3782 2
		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
a3783 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 11);
	      }
d3785 4
a3788 4
	    /* Handle a 5 bit register field at 25.  */
	    case '9':
	      {
		struct pa_11_fp_reg_struct result;
d3790 6
a3795 5
		pa_parse_number (&s, &result);
		CHECK_FIELD (result.number_part, 31, 0, 0);
		if (the_insn.fpof1 == SGL)
		  {
		    if (result.number_part < 16)
d3797 7
a3803 2
			as_bad  ("Invalid register for single precision fmpyadd or fmpysub");
			break;
d3805 1
a3805 2
		    result.number_part &= 0xF;
		    result.number_part |= (result.l_r_select & 1) << 4;
a3806 2
		INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 6);
	      }
d3808 4
a3811 11
	    /* Handle a floating point operand format at 26.
	       Only allows single and double precision.  */
	    case 'H':
	      flag = pa_parse_fp_format (&s);
	      switch (flag)
		{
		case SGL:
		  opcode |= 0x20;
		case DBL:
		  the_insn.fpof1 = flag;
		  continue;
d3813 11
a3823 2
		case QUAD:
		case ILLEGAL_FMT:
d3825 1
a3825 1
		  as_bad ("Invalid Floating Point Operand Format.");
d3835 1
d3839 1
a3839 1
	  if (&insn[1] - pa_opcodes < NUMOPCODES
d3848 1
a3848 1
	      as_bad ("Invalid operands %s", error_message);
d3904 1
a3904 1
      return "Bad call to MD_ATOF()";
d3952 1
a3952 2
  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  assert (reloc != 0);
d3954 2
a3955 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d3961 1
a3961 1
			       fixp->fx_addsy->bsym);
d3963 2
a3964 1
  /* assert (codes != 0); */
d3966 1
a3966 1
  for (n_relocs = 0; codes && codes[n_relocs]; n_relocs++)
d3969 2
a3970 9
  relocs = (arelent **)
    bfd_alloc_by_size_t (stdoutput, sizeof (arelent *) * n_relocs + 1);
  assert (relocs != 0);

  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput,
					   sizeof (arelent) * n_relocs);
  if (n_relocs > 0)
    assert (reloc != 0);

a3975 1
  if (n_relocs)
d3984 2
a3985 1
      reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d4030 1
a4030 1
  /* Walk over each relocation returned by the BFD backend.  */
d4035 2
a4036 1
      relocs[i]->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d4047 1
a4047 1
	  relocs[0]->sym_ptr_ptr = &bfd_abs_symbol;
d4051 2
a4052 1
	  relocs[1]->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d4056 2
a4057 1
	  relocs[2]->sym_ptr_ptr = &fixp->fx_subsy->bsym;
d4061 1
a4061 1
	  relocs[3]->sym_ptr_ptr = &bfd_abs_symbol;
d4065 1
a4065 1
	  relocs[4]->sym_ptr_ptr = &bfd_abs_symbol;
d4103 2
a4104 1
	  relocs[i]->sym_ptr_ptr = &dummy_symbol->bsym;
d4112 2
a4113 1
	  relocs[i]->sym_ptr_ptr = &dummy_symbol->bsym;
a4173 24
/* Create a short jump from FROM_ADDR to TO_ADDR.  Not used on the PA.  */
void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  fprintf (stderr, "pa_create_short_jmp\n");
  abort ();
}

/* Create a long jump from FROM_ADDR to TO_ADDR.  Not used on the PA.  */
void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  fprintf (stderr, "pa_create_long_jump\n");
  abort ();
}

d4228 1
a4228 1
  long new_val, result;
d4258 1
a4258 1
      unsigned char fmt = bfd_hppa_insn2fmt (buf_wd);
a4267 6
	  || hppa_fixP->fx_r_field == e_psel
	  || hppa_fixP->fx_r_field == e_rpsel
	  || hppa_fixP->fx_r_field == e_lpsel
	  || hppa_fixP->fx_r_field == e_tsel
	  || hppa_fixP->fx_r_field == e_rtsel
	  || hppa_fixP->fx_r_field == e_ltsel
d4270 1
a4270 1
	new_val = ((fmt == 12 || fmt == 17) ? 8 : 0);
d4272 8
d4294 1
a4294 1
      if ((fmt == 12 || fmt == 17)
d4297 6
a4302 4
	  && !arg_reloc_stub_needed (((obj_symbol_type *)
				fixP->fx_addsy->bsym)->tc_data.hppa_arg_reloc,
				    hppa_fixP->fx_arg_reloc)
	  && ((int)(*valp) > -262144 && (int)(*valp) < 262143)
d4306 1
a4306 1
	      
d4309 1
a4309 1
	
d4364 27
a4390 1
	  CHECK_FIELD (new_val, 262143, -262144, 0);
d4392 16
a4407 8
	  /* Mask off 17 bits to be changed.  */
	  bfd_put_32 (stdoutput,
		      bfd_get_32 (stdoutput, buf) & 0xffe0e002,
		      buf);
	  sign_unext ((new_val - 8) >> 2, 17, &resulti);
	  dis_assemble_17 (resulti, &w1, &w2, &w);
	  result = ((w2 << 2) | (w1 << 16) | w);
	  break;
d4415 1
a4415 1
	  as_bad ("Unknown relocation encountered in md_apply_fix.");
d4425 1
a4425 1
      printf ("no hppa_fixup entry for this fixup (fixP = 0x%x, type = 0x%x)\n",
d4567 1
a4567 1
		as_bad ("Undefined register: '%s'.", name);
d4592 1
a4592 1
		as_bad ("Undefined register: '%s'.", name);
d4630 1
a4630 1
		as_bad ("Non-absolute symbol: '%s'.", name);
d4645 1
a4645 1
		as_bad ("Undefined absolute constant: '%s'.", name);
d4715 1
a4715 1
	    as_warn ("could not update architecture and machine");
d4735 140
a4874 3
    {
      if (strncasecmp (*s, fp_cond_map[i].string,
		       strlen (fp_cond_map[i].string)) == 0)
d4876 2
a4877 12
	  cond = fp_cond_map[i].cond;
	  *s += strlen (fp_cond_map[i].string);
	  /* If not a complete match, back up the input string and
	     report an error.  */
	  if (**s != ' ' && **s != '\t')
	    {
	      *s -= strlen (fp_cond_map[i].string);
	      break;
	    }
	  while (**s == ' ' || **s == '\t')
	    *s = *s + 1;
	  return cond;
d4881 1
a4881 7
  as_bad ("Invalid FP Compare Condition: %s", *s);

  /* Advance over the bogus completer.  */
  while (**s != ',' && **s != ' ' && **s != '\t')
    *s += 1;

  return 0;
d4915 1
a4915 1
	  as_bad ("Invalid FP Operand Format: %3s", *s);
a4943 1
#ifdef OBJ_SOM
a4948 1
#endif
d4994 1
a4994 1
      as_warn ("Bad segment in expression.");
d5016 35
d5053 1
a5053 1
      as_bad ("Bad segment (should be absolute).");
d5152 1
a5152 1
    as_bad ("Invalid argument location: %s\n", type_name);
d5183 1
a5183 1
      as_bad ("Invalid argument description: %d", reg);
d5206 1
a5206 1
	  as_bad ("Invalid Nullification: (%c)", **s);
d5225 256
a5480 1
     int isbranch;
d5487 1
a5487 1
  cmpltr = 0;
d5495 6
a5500 1
      if (strcmp (name, "=") == 0)
d5504 1
a5504 1
      else if (strcmp (name, "<") == 0)
d5508 1
a5508 1
      else if (strcmp (name, "<=") == 0)
d5512 1
a5512 1
      else if (strcmp (name, "<<") == 0)
d5516 1
a5516 1
      else if (strcmp (name, "<<=") == 0)
d5520 1
a5520 1
      else if (strcasecmp (name, "sv") == 0)
d5524 1
a5524 1
      else if (strcasecmp (name, "od") == 0)
a5527 6
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0 && isbranch)
	{
	  cmpltr = 0;
	}
a5534 3
  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (cmpltr == 0 && *name == 'n' && isbranch)
    *s = save_s;
d5539 2
a5540 2
/* Parse a negated compare/subtract completer returning the
   number (for encoding in instrutions) of the given completer.
d5547 1
a5547 1
pa_parse_neg_cmpsub_cmpltr (s, isbranch)
d5564 1
a5564 5
      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
d5568 1
a5568 1
      else if (strcmp (name, ">=") == 0)
d5572 1
a5572 1
      else if (strcmp (name, ">") == 0)
d5576 1
a5576 1
      else if (strcmp (name, ">>=") == 0)
d5580 1
a5580 1
      else if (strcmp (name, ">>") == 0)
d5584 1
a5584 1
      else if (strcasecmp (name, "nsv") == 0)
d5588 1
a5588 1
      else if (strcasecmp (name, "ev") == 0)
d5612 1
a5612 1
/* Parse a non-negated addition completer returning the number
d5617 1
a5617 1
   computational instruction.  */
d5620 1
a5620 1
pa_parse_nonneg_add_cmpltr (s, isbranch)
d5637 5
a5641 1
      if (strcmp (name, "=") == 0)
d5645 1
a5645 1
      else if (strcmp (name, "<") == 0)
d5649 1
a5649 1
      else if (strcmp (name, "<=") == 0)
d5653 1
a5653 1
      else if (strcasecmp (name, "nuv") == 0)
d5657 1
a5657 1
      else if (strcasecmp (name, "znv") == 0)
d5661 1
a5661 1
      else if (strcasecmp (name, "sv") == 0)
d5665 1
a5665 1
      else if (strcasecmp (name, "od") == 0)
d5689 2
a5690 6
/* Parse a negated addition completer returning the number
   (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction).  */
d5693 1
a5693 1
pa_parse_neg_add_cmpltr (s, isbranch)
a5694 1
     int isbranch;
d5700 1
d5710 1
a5710 5
      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
d5714 1
a5714 1
      else if (strcmp (name, ">=") == 0)
d5718 1
a5718 1
      else if (strcmp (name, ">") == 0)
d5722 1
a5722 1
      else if (strcasecmp (name, "uv") == 0)
d5726 1
a5726 1
      else if (strcasecmp (name, "vnz") == 0)
d5730 1
a5730 1
      else if (strcasecmp (name, "nsv") == 0)
d5734 1
a5734 1
      else if (strcasecmp (name, "ev") == 0)
d5738 32
d5772 1
a5772 1
      else if (strcasecmp (name, "n") == 0 && isbranch)
d5775 1
d5785 1
a5785 1
  if (cmpltr == 0 && *name == 'n' && isbranch)
d5791 1
d5808 1
d5819 1
a5819 1
  int i;
d5821 1
d5824 1
d5832 2
a5833 2
		(relax_substateT) 0, (symbolS *) 0, 1, NULL);
  bzero (p, temp_size);
d5902 1
d5905 1
d5950 1
a5950 1
	  as_bad ("Invalid .CALL argument: %s", name);
d5991 1
d5993 1
a5993 1
  int i;
d5996 10
a6008 1
  subseg = SUBSEG_UNWIND;
d6012 1
a6012 1
      seg = bfd_make_section_old_way (stdoutput, UNWIND_SECTION_NAME);
d6015 2
a6016 1
			     | SEC_LOAD | SEC_RELOC);
d6019 1
a6019 3
  save_seg = now_seg;
  save_subseg = now_subseg;
  subseg_set (seg, subseg);
d6030 2
a6031 1
		(expressionS *) NULL, 0, R_PARISC_DIR32, e_fsel, 32, 0, NULL);
d6046 2
a6047 1
		(expressionS *) NULL, 0, R_PARISC_DIR32, e_fsel, 32, 0, NULL);
d6075 1
d6078 1
d6082 1
a6082 1
    as_bad (".callinfo is not within a procedure definition");
d6102 1
a6102 1
	      as_bad ("FRAME parameter must be a multiple of 8: %d\n", temp);
d6121 1
a6121 1
	    as_bad ("Value for ENTRY_GR must be in the range 3..18\n");
d6133 1
a6133 1
	    as_bad ("Value for ENTRY_FR must be in the range 12..21\n");
d6143 1
a6143 1
	    as_bad ("Value for ENTRY_SR must be 3\n");
d6199 1
a6199 1
	  as_bad ("Invalid .CALLINFO argument: %s", name);
d6215 1
d6219 1
d6269 1
a6269 1
      symbol->sy_frag = &zero_address_frag;
d6288 1
d6291 1
d6293 2
a6294 1
  abort ();
d6303 1
d6306 1
d6309 1
a6309 1
    as_bad ("Misplaced .entry. Ignored.");
d6313 1
a6313 1
	as_bad ("Missing .callinfo.");
d6361 1
a6361 1
	as_bad (".REG must use a label");
d6363 1
a6363 1
	as_bad (".EQU must use a label");
d6410 1
d6413 1
d6416 1
a6416 1
    as_bad (".EXIT must appear within a procedure");
d6420 1
a6420 1
	as_bad ("Missing .callinfo");
d6424 1
a6424 1
	    as_bad ("No .ENTRY for this .EXIT");
d6451 1
a6451 1
      as_bad ("Cannot define export symbol: %s\n", name);
d6482 1
a6482 1
  obj_symbol_type *symbol = (obj_symbol_type *) symbolP->bsym;
d6488 1
a6488 1
      symbolP->bsym->flags &= ~BSF_FUNCTION;
d6501 1
a6501 1
      if (symbolP->bsym->flags & BSF_FUNCTION)
d6504 2
a6505 1
	    as_tsktsk ("Using ENTRY rather than CODE in export directive for %s", symbolP->bsym->name);
d6507 1
a6507 1
	  symbolP->bsym->flags |= BSF_FUNCTION;
d6512 1
a6512 1
	  symbolP->bsym->flags &= ~BSF_FUNCTION;
d6519 2
a6520 1
      symbolP->bsym->flags &= ~BSF_FUNCTION;
d6526 1
a6526 1
      symbolP->bsym->flags |= BSF_FUNCTION;
d6532 1
a6532 1
      symbolP->bsym->flags |= BSF_FUNCTION;
d6538 1
a6538 1
      symbolP->bsym->flags &= ~BSF_FUNCTION;
d6544 1
a6544 1
      symbolP->bsym->flags |= BSF_FUNCTION;
d6550 1
a6550 1
      symbolP->bsym->flags |= BSF_FUNCTION;
d6558 1
a6558 1
  obj_set_symbol_type (symbolP->bsym, (int) type);
d6579 3
a6581 1
	  symbol->tc_data.hppa_arg_reloc |= arg_reloc;
d6593 3
a6595 1
	  symbol->tc_data.hppa_arg_reloc |= arg_reloc;
d6605 3
d6613 1
a6613 1
	  as_bad ("Undefined .EXPORT/.IMPORT argument (ignored): %s", name);
d6658 1
a6658 1
	    symbol->bsym->flags |= BSF_FUNCTION;
d6695 1
a6695 1
      as_warn ("Missing label name on .LABEL");
d6700 1
a6700 1
      as_warn ("extra .LABEL arguments ignored.");
d6712 1
d6715 1
d6717 2
a6718 1
  abort ();
d6734 1
a6734 1
	as_warn ("could not set architecture and machine");
d6740 13
a6752 1
	as_warn ("could not set architecture and machine");
d6756 1
a6756 1
      as_bad ("Unrecognized .LEVEL argument\n");
d6768 1
d6771 1
d6792 1
a6792 1
      as_bad ("Cannot define static symbol: %s\n", name);
d6821 1
d6824 1
d6827 1
a6827 1
    as_fatal ("Nested procedures");
d6837 1
a6837 1
    as_fatal ("Cannot allocate unwind descriptor\n");
d6839 1
a6839 1
  bzero (call_info, sizeof (struct call_info));
d6870 1
a6870 1
	    label_symbol->lss_label->bsym->flags |= BSF_FUNCTION;
d6873 1
a6873 1
	  as_bad ("Missing function name for .PROC (corrupted label chain)");
d6890 1
d6893 1
d6911 2
a6912 1
	      label_symbol->lss_label->bsym->flags |= BSF_FUNCTION;
d6928 1
a6928 1
	    as_bad ("Missing function name for .PROC (corrupted label chain)");
d6931 1
a6931 1
	as_bad ("Missing function name for .PROC");
d6935 1
a6935 1
    as_bad ("misplaced .procend");
d6938 1
a6938 1
    as_bad ("Missing .callinfo for this procedure");
d6941 1
a6941 1
    as_bad ("Missing .EXIT for a .ENTRY");
d6954 32
d7073 1
a7073 1
		  as_bad ("Invalid .SPACE argument");
d7121 1
a7121 1
      as_bad ("Can\'t change spaces within a procedure definition. Ignored");
d7248 1
a7248 1
    as_warn ("Undefined space: '%s' Assuming space number = 0.", name);
a7253 18
/* If VALUE is an exact power of two between zero and 2^31, then
   return log2 (VALUE).  Else return -1.  */

static int
log2 (value)
     int value;
{
  int shift = 0;

  while ((1 << shift) != value && shift < 32)
    shift++;

  if (shift >= 32)
    return -1;
  else
    return shift;
}

d7264 1
a7264 1
  char *name, *ss_name, *alias, c;
d7272 1
a7272 1
    as_fatal ("Must be in a space before changing or declaring subspaces.\n");
d7276 1
a7276 1
      as_bad ("Can\'t change subspaces within a procedure definition. Ignored");
a7297 1
      alias = NULL;
d7311 1
a7311 1
	    as_warn ("Parameters of an existing subspace can\'t be modified");
a7333 2
		  if (USE_ALIASES && pa_def_subspaces[i].alias)
		    alias = pa_def_subspaces[i].alias;
d7362 1
a7362 1
		      as_bad ("Alignment must be a power of 2");
d7404 1
a7404 1
		as_bad ("FIRST not supported as a .SUBSPACE argument");
d7406 1
a7406 1
		as_bad ("Invalid .SUBSPACE argument");
a7441 8
      else if (alias)
	section = subseg_new (alias, 0);
      else if (!alias && USE_ALIASES)
	{
	  as_warn ("Ignoring subspace decl due to ELF BFD bugs.");
	  demand_empty_rest_of_line ();
	  return;
	}
d7498 1
a7498 4
      if (pa_def_spaces[i].alias && USE_ALIASES)
	name = pa_def_spaces[i].alias;
      else
	name = pa_def_spaces[i].name;
d7518 2
a7519 10
      if (pa_def_subspaces[i].alias && USE_ALIASES)
	{
	  name = pa_def_subspaces[i].alias;
	  subsegment = pa_def_subspaces[i].subsegment;
	}
      else
	{
	  name = pa_def_subspaces[i].name;
	  subsegment = 0;
	}
d7528 1
a7528 1
      if (!strcmp (pa_def_subspaces[i].name, "$CODE$") && !USE_ALIASES)
d7538 1
a7538 1
      else if (!strcmp (pa_def_subspaces[i].name, "$DATA$") && !USE_ALIASES)
d7549 1
a7549 1
      else if (!strcmp (pa_def_subspaces[i].name, "$BSS$") && !USE_ALIASES)
d7556 1
a7556 1
      else if (!strcmp (pa_def_subspaces[i].name, "$LIT$") && !USE_ALIASES)
d7565 1
a7565 2
      else if (!strcmp (pa_def_subspaces[i].name, "$MILLICODE$")
	       && !USE_ALIASES)
d7574 1
a7574 1
      else if (!strcmp (pa_def_subspaces[i].name, "$UNWIND$") && !USE_ALIASES)
d7589 1
a7589 1
	  as_fatal ("Internal error: Unable to find containing space for %s.",
d7630 1
a7630 1
    as_fatal ("Out of memory: could not allocate new space chain entry: %s\n",
d7716 1
a7716 1
    as_fatal ("Out of memory: could not allocate new subspace chain entry: %s\n", name);
d7725 1
a7725 1
  chain_entry->ssd_subseg = USE_ALIASES ? pa_next_subseg (space) : 0;
d7928 1
a7928 1
      if (SPACE_SPNUM (space_chain) == number)
d7952 1
d7964 1
d7975 1
d7978 1
d8078 14
d8119 1
d8123 1
d8144 1
d8147 1
d8159 1
d8162 1
d8174 1
d8177 1
d8189 1
d8193 1
d8218 1
a8218 1
   reductions make life a living hell for object file editors. 
d8238 1
a8238 1
     the fixup will occur in a CODE subspace. 
d8248 1
a8248 1
      fixp->fx_subsy->sy_used_in_reloc = 1;
d8270 5
a8274 1
  if (fixp->fx_addsy && fixp->fx_addsy->bsym->flags & BSF_GLOBAL)
d8278 1
a8278 2
  if (fixp->fx_addsy == 0
      || (fixp->fx_addsy->bsym->flags & BSF_FUNCTION) == 0)
d8310 1
d8315 3
a8317 4
      && (arg_reloc_stub_needed (((obj_symbol_type *)
				  fixp->fx_addsy->bsym)->tc_data.hppa_arg_reloc,

				 hppa_fixp->fx_arg_reloc)))
d8319 1
d8327 2
d8376 1
a8376 1
	  symbolP->bsym->flags = BSF_LOCAL;
d8383 1
a8383 1
	as_bad ("Symbol '%s' could not be created.", name);
d8387 1
a8387 1
    as_bad ("No memory for symbol name.");
d8406 2
a8407 1
      = (elf_symbol_type *) call_info_pointer->start_symbol->bsym;
d8412 8
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2633 3
a2635 1
  for (n_relocs = 0; codes[n_relocs]; n_relocs++)
d2652 1
d2706 1
a2706 1
  /* Walk over reach relocation returned by the BFD backend.  */
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d487 1
d504 1
d597 1
d610 1
d624 1
d2630 2
a2631 1
			       fixp->fx_subsy != NULL);
d2769 1
d2777 1
d2931 2
a2932 1
      || fixP->fx_r_type == R_HPPA_END_BRTAB)
d2934 9
d4089 25
d4905 29
d6443 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1989 Free Software Foundation, Inc.
d93 8
d652 1
a652 1
   Also note that '/*' will always start a comment.  */
d972 3
d992 2
a994 1
#define SUBSEG_LIT    1
d1005 1
d2717 1
a2717 1
	  relocs[0]->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d2763 2
d2781 2
a2784 1
done:
d2913 1
a2913 1
  unsigned int w1, w2, w;
d2924 1
a2924 1
    return;
d2990 2
a2991 1
	  low_sign_unext (new_val, 14, &result);
d3002 2
a3003 1
	  dis_assemble_21 (new_val, &result);
d3014 2
a3015 1
	  low_sign_unext (new_val, 11, &result);
d3020 1
a3020 1
	  CHECK_FIELD (new_val, 8199, -8184, 0)
d3023 1
a3023 1
	    sign_unext ((new_val - 8) >> 2, 12, &result);
d3028 1
a3028 1
	  dis_assemble_12 (result, &w1, &w);
d3040 2
a3041 2
	  sign_unext ((new_val - 8) >> 2, 17, &result);
	  dis_assemble_17 (result, &w1, &w2, &w);
d3052 1
a3052 1
	  return;
d3057 1
a3057 1
      return;
d3063 1
a3063 1
      return;
d3445 1
a3445 1
  char name[3];
d3459 7
d3483 4
d3925 1
a3925 1
   computational instruction.  */
d5666 10
d6326 5
a6330 5
  /* We can't adjust DP relative relocs that use LR% and RR% field
     selectors.  That confuses the optimization pass in HP linker.  */
  if (fixp->fx_r_type == R_DP_RELATIVE
      && (hppa_fix->fx_r_field == e_lrsel
	  || hppa_fix->fx_r_field == e_rrsel))
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1989, 1996 Free Software Foundation, Inc.
a92 8
#ifndef R_N0SEL
#define R_N0SEL 0xd8
#endif

#ifndef R_N1SEL
#define R_N1SEL 0xd9
#endif

d644 1
a644 1
   Also note that C style comments will always work. */
a963 3
  {"n", e_nsel},
  {"nl", e_nlsel},
  {"nlr", e_nlrsel},
d981 1
a982 2
#define SUBSEG_MILLI  2
#define SUBSEG_DATA   0
a992 1
  {"$MILLICODE$", 1, 1, 0, 0, 0, 0, 8, 0x2c, 0, 8, 0, 0, ".text", SUBSEG_MILLI},
d2704 1
a2704 1
	  relocs[1]->sym_ptr_ptr = &fixp->fx_addsy->bsym;
a2749 2
	case R_N0SEL:
	case R_N1SEL:
a2765 2

 done:
d2768 1
d2897 1
a2897 1
  unsigned int w1, w2, w, resulti;
d2908 1
a2908 1
    return 1;
d2974 1
a2974 2
	  low_sign_unext (new_val, 14, &resulti);
	  result = resulti;
d2985 1
a2985 2
	  dis_assemble_21 (new_val, &resulti);
	  result = resulti;
d2996 1
a2996 2
	  low_sign_unext (new_val, 11, &resulti);
	  result = resulti;
d3001 1
a3001 1
	  CHECK_FIELD (new_val, 8199, -8184, 0);
d3004 1
a3004 1
	  sign_unext ((new_val - 8) >> 2, 12, &resulti);
d3009 1
a3009 1
	  dis_assemble_12 (resulti, &w1, &w);
d3021 2
a3022 2
	  sign_unext ((new_val - 8) >> 2, 17, &resulti);
	  dis_assemble_17 (resulti, &w1, &w2, &w);
d3033 1
a3033 1
	  return 0;
d3038 1
a3038 1
      return 1;
d3044 1
a3044 1
      return 0;
d3426 1
a3426 1
  char name[4];
a3439 7
#ifdef OBJ_SOM
  else if ((*str)[3] == '\'' || (*str)[3] == '%')
    name[0] = tolower ((*str)[0]),
    name[1] = tolower ((*str)[1]),
    name[2] = tolower ((*str)[2]),
    name[3] = 0;
#endif
a3456 4
#ifndef OBJ_SOM
	  if (selector_table[middle].field_selector == e_nsel)
	    return e_fsel;
#endif
d3895 1
a3895 1
   computational instruction).  */
a5635 10
      else if (!strcmp (pa_def_subspaces[i].name, "$MILLICODE$")
	       && !USE_ALIASES)
	{
	  applicable = bfd_applicable_section_flags (stdoutput);
	  bfd_set_section_flags (stdoutput, segment,
				 applicable & (SEC_ALLOC | SEC_LOAD
					       | SEC_RELOC
					       | SEC_READONLY
					       | SEC_HAS_CONTENTS));
	}
d6286 5
a6290 5
  /* We can't adjust any relocs that use LR% and RR% field selectors.
     That confuses the HP linker.  */
  if (hppa_fix->fx_r_field == e_lrsel
      || hppa_fix->fx_r_field == e_rrsel
      || hppa_fix->fx_r_field == e_nlrsel)
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a486 1
static void pa_try PARAMS ((int));
a502 1
static void pa_level PARAMS ((int));
a594 1
  {"begin_try", pa_try, 1},
a606 1
  {"end_try", pa_try, 0},
a619 1
  {"level", pa_level, 0},
d2625 1
a2625 2
			       fixp->fx_subsy != NULL,
			       fixp->fx_addsy->bsym);
a2762 1
	case R_BEGIN_TRY:
a2769 1
	case R_END_TRY:
d2923 1
a2923 2
      || fixP->fx_r_type == R_HPPA_END_BRTAB
      || fixP->fx_r_type == R_HPPA_BEGIN_TRY)
a2924 9

  /* Disgusting.  We must set fx_offset ourselves -- R_HPPA_END_TRY
     fixups are considered not adjustable, which in turn causes
     adjust_reloc_syms to not set fx_offset.  Ugh.  */
  if (fixP->fx_r_type == R_HPPA_END_TRY)
    {
      fixP->fx_offset = *valp;
      return 1;
    }
a4070 25
/* Handle a .begin_try and .end_try pseudo-op.  */

static void
pa_try (begin)
     int begin;
{
#ifdef OBJ_SOM
  expressionS exp;
  char *where = frag_more (0);

  if (! begin)
    expression (&exp);

  /* The TRY relocations are only availble in SOM (to denote
     the beginning and end of exception handling regions).  */

  fix_new_hppa (frag_now, where - frag_now->fr_literal, 0,
		NULL, (offsetT) 0, begin ? NULL : &exp,
		0, begin ? R_HPPA_BEGIN_TRY : R_HPPA_END_TRY,
		e_fsel, 0, 0, NULL);
#endif

  demand_empty_rest_of_line ();
}

a4861 29
/* Handle a .LEVEL pseudo-op.  */

static void
pa_level (unused)
     int unused;
{
  char *level;

  level = input_line_pointer;
  if (strncmp (level, "1.0", 3) == 0)
    {
      input_line_pointer += 3;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 10))
	as_warn ("could not set architecture and machine");
    }
  else if (strncmp (level, "1.1", 3) == 0)
    {
      input_line_pointer += 3;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 11))
	as_warn ("could not set architecture and machine");
    }
  else
    {
      as_bad ("Unrecognized .LEVEL argument\n");
      ignore_rest_of_line ();
    }
  demand_empty_rest_of_line ();
}

a6370 2
      || fixp->fx_r_type == R_HPPA_BEGIN_TRY
      || fixp->fx_r_type == R_HPPA_END_TRY
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1989, 1996, 1997 Free Software Foundation, Inc.
d421 1
a421 1
    enum hppa_reloc_field_selector_type_alt fx_r_field;
d547 1
a553 2

#ifdef OBJ_ELF
a554 2
static void pa_build_unwind_subspace PARAMS ((struct call_info *));
#endif
d1199 1
a1199 1
     enum hppa_reloc_field_selector_type_alt r_field;
d2622 2
a2623 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d2636 9
a2644 2
  relocs = (arelent **) xmalloc (sizeof (arelent *) * n_relocs + 1);
  reloc = (arelent *) xmalloc (sizeof (arelent) * n_relocs);
d2920 1
a2920 1
  long new_val, result = 0;
d4052 1
a4052 1
		(relax_substateT) 0, (symbolS *) 0, (offsetT) 1, NULL);
a6117 1
#ifdef OBJ_SOM
a6125 2
#endif
  return 0;
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1989, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d8 1
a8 1
   the Free Software Foundation; either version 2, or (at your option)
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a35 12
#if defined (OBJ_ELF) && defined (OBJ_SOM)
error only one of OBJ_ELF and OBJ_SOM can be defined
#endif

/* If we are using ELF, then we probably can support dwarf2 debug
   records.  Furthermore, if we are supporting dwarf2 debug records,
   then we want to use the assembler support for compact line numbers.  */
#ifdef OBJ_ELF
#include "dwarf2dbg.h"
struct dwarf2_line_info debug_line;
#endif

d39 7
d47 1
a47 1
typedef elf_hppa_reloc_type reloc_type;
a51 1
#ifdef BFD64
d53 1
a53 4
#define hppa_gen_reloc_type _bfd_elf64_hppa_gen_reloc_type
#else
#define hppa_gen_reloc_type _bfd_elf32_hppa_gen_reloc_type
#endif
d60 2
a61 1
#define UNWIND_SECTION_NAME ".PARISC.unwind"
d78 3
d168 1
a168 1
    SGL, DBL, ILLEGAL_FMT, QUAD, W, UW, DW, UDW, QW, UQW
a205 3
    /* Whether or not we saw a truncation request on an fcnv insn.  */
    int trunc;

a267 1
#ifdef OBJ_SOM
d322 11
d379 3
d412 3
a415 17
#endif

/* Structure for previous label tracking.  Needed so that alignments,
   callinfo declarations, etc can be easily attached to a particular
   label.  */
typedef struct label_symbol_struct
  {
    struct symbol *lss_label;
#ifdef OBJ_SOM
    sd_chain_struct *lss_space;
#endif
#ifdef OBJ_ELF
    segT lss_segment;
#endif
    struct label_symbol_struct *lss_next;
  }
label_symbol_struct;
a461 1
#ifdef OBJ_SOM
a462 2
#endif

d484 1
a484 3
static int pa_parse_cmpb_64_cmpltr PARAMS ((char **));
static int pa_parse_cmpib_64_cmpltr PARAMS ((char **));
static int pa_parse_addb_64_cmpltr PARAMS ((char **));
d508 3
a516 6
#ifdef OBJ_SOM
static void pa_compiler PARAMS ((int));
static void pa_align PARAMS ((int));
static void pa_space PARAMS ((int));
static void pa_spnum PARAMS ((int));
static void pa_subspace PARAMS ((int));
a536 4
static sd_chain_struct *pa_parse_space_stmt PARAMS ((char *, int));
static int pa_next_subseg PARAMS ((sd_chain_struct *));
static void pa_spaces_begin PARAMS ((void));
#endif
d541 1
a541 1
				  enum hppa_reloc_field_selector_type_alt,
d548 1
d550 1
d552 1
a552 2
static fp_operand_format pa_parse_fp_cnv_format PARAMS ((char **s));
static int pa_parse_ftest_gfx_completer PARAMS ((char **));
a560 1
#ifdef OBJ_SOM
a567 1
#endif
d580 4
a597 1
#ifdef OBJ_SOM
a598 4
#endif
#ifdef OBJ_ELF
  {"align", s_align_bytes, 8},
#endif
a607 3
#ifdef OBJ_SOM
  {"compiler", pa_compiler, 0},
#endif
a610 1
  {"dword", pa_cons, 8},
a618 3
#ifdef OBJ_ELF
  { "file", dwarf2_directive_file },
#endif
a627 3
#ifdef OBJ_ELF
  { "loc", dwarf2_directive_loc },
#endif
a629 1
#ifdef OBJ_SOM
a630 1
#endif
a640 1
#ifdef OBJ_SOM
a642 1
#endif
a644 1
#ifdef OBJ_SOM
a645 1
#endif
a699 7
/* Nonzero when strict syntax checking is enabled.  Zero otherwise.

   Each opcode in the table has a flag which indicates whether or not
   strict syntax checking should be enabled for that instruction.  */
static int strict = 0;

#ifdef OBJ_SOM
a701 1
#endif
a979 1
  {"ltp", e_ltpsel},
a989 1
  {"rtp", e_rtpsel},
a992 1
#ifdef OBJ_SOM
d1010 8
a1017 5
  {"$CODE$", 1, 1, 1, 0, 0, 0, 24, 0x2c, 0, 8, 0, 0, SUBSEG_CODE},
  {"$DATA$", 1, 1, 0, 0, 0, 0, 24, 0x1f, 1, 8, 1, 1, SUBSEG_DATA},
  {"$LIT$", 1, 1, 0, 0, 0, 0, 16, 0x2c, 0, 8, 0, 0, SUBSEG_LIT},
  {"$MILLICODE$", 1, 1, 0, 0, 0, 0, 8, 0x2c, 0, 8, 0, 0, SUBSEG_MILLI},
  {"$BSS$", 1, 1, 0, 0, 0, 1, 80, 0x1f, 1, 8, 1, 1, SUBSEG_BSS},
d1023 3
a1025 3
  {"$TEXT$", 0, 1, 1, 0, 8, ASEC_NULL},
  {"$PRIVATE$", 1, 1, 1, 1, 16, ASEC_NULL},
  {NULL, 0, 0, 0, 0, 0, ASEC_NULL}
d1030 5
a1042 6
#endif

/* Return nonzero if the string pointed to by S potentially represents
   a right or left half of a FP register  */
#define IS_R_SELECT(S)   (*(S) == 'R' || *(S) == 'r')
#define IS_L_SELECT(S)   (*(S) == 'L' || *(S) == 'l')
d1061 1
a1061 1
          as_bad (_("Field out of range [%d..%d] (%d)."), (LOW), (HIGH), \
d1069 1
a1069 1
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$global$") == 0)
d1073 1
a1073 1
   && strcmp (S_GET_NAME ((exp).X_op_symbol), "$PIC_pcrel$0") == 0)
d1090 1
a1090 1
    as_fatal (_("Missing .exit\n"));
d1093 13
a1105 1
    as_fatal (_("Missing .procend\n"));
d1115 1
d1120 1
a1120 7
    {
#ifdef OBJ_SOM
    if (current_space == label_chain->lss_space && label_chain->lss_label)
      return label_chain;
#endif
#ifdef OBJ_ELF
    if (now_seg == label_chain->lss_segment && label_chain->lss_label)
a1121 2
#endif
    }
d1134 1
d1144 1
a1144 6
#ifdef OBJ_SOM
      label_chain->lss_space = current_space;
#endif
#ifdef OBJ_ELF
      label_chain->lss_segment = now_seg;
#endif
d1162 1
d1168 1
a1168 8
      if (1
#ifdef OBJ_SOM
 	  && current_space == label_chain->lss_space && label_chain->lss_label
#endif
#ifdef OBJ_ELF
 	  && now_seg == label_chain->lss_segment && label_chain->lss_label
#endif
	  )
d1267 1
a1267 1
    as_warn (_("Invalid field selector.  Assuming F%%."));
d1271 1
a1271 1
		hppa_field_selector, size * 8, 0, NULL);
d1292 1
a1292 1
    as_warn (_("could not set architecture and machine"));
d1298 1
a1298 1
      as_warn (_("-R option not supported on this target."));
a1301 1
#ifdef OBJ_SOM
a1302 1
#endif
d1312 1
a1312 1
	  as_fatal (_("Internal error: can't hash `%s': %s\n"), name, retval);
d1320 1
a1320 1
	      fprintf (stderr, _("internal error: losing opcode: `%s' \"%s\"\n"),
d1330 1
a1330 1
    as_fatal (_("Broken assembler.  No assembly attempted."));
a1331 1
#ifdef OBJ_SOM
a1334 1
#endif
a1335 1
#ifdef OBJ_SOM
a1337 3
  /* Force the symbol to be converted to a real symbol. */
  (void) symbol_get_bfdsym (dummy_symbol);
#endif
d1366 1
a1366 2
	      symbol_get_bfdsym (label_symbol->lss_label)->flags
		|= BSF_FUNCTION;
d1382 1
a1382 1
	    as_bad (_("Missing function name for .PROC (corrupted label chain)"));
d1385 1
a1385 1
	as_bad (_("Missing function name for .PROC"));
a1402 17

#ifdef OBJ_ELF
  if (debug_type == DEBUG_DWARF2)
    {
      bfd_vma addr;

      /* First update the notion of the current source line.  */
      dwarf2_where (&debug_line);

      /* We want the offset of the start of this instruction within the
	 the current frag.  */
      addr = frag_now->fr_address + frag_now_fix () - 4;

      /* And record the information.  */
      dwarf2_gen_line_info (addr, &debug_line);
    }
#endif
a1420 1
#ifdef OBJ_SOM
a1422 7
#endif

  /* Convert everything up to the first whitespace character into lower
     case.  */
  for (s = str; *s != ' ' && *s != '\t' && *s != '\n' && *s != '\0'; s++)
    if (isupper (*s))
      *s = tolower (*s);
d1444 1
a1444 1
      as_fatal (_("Unknown opcode: `%s'"), str);
d1449 8
d1476 1
a1476 2
      strict = (insn->flags & FLAG_STRICT);
      memset (&the_insn, 0, sizeof (the_insn));
d1482 1
a1482 4
      /* But do not automatically promote to pa2.0.  The automatic promotion
	 crud is for compatability with HP's old assemblers only.  */
      if (insn->arch < 20
	  && bfd_get_mach (stdoutput) < insn->arch)
d1485 1
a1485 6
	    as_warn (_("could not update architecture and machine"));
	}
      else if (bfd_get_mach (stdoutput) < insn->arch)
	{
	  match = FALSE;
	  goto failed;
a1491 4
	  /* Absorb white space in instruction.  */
	  while (*s == ' ' || *s == '\t')
	    s++;

a1522 3
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
		break;
a1526 19
	    /* Handle %sar or %cr11.  No bits get set, we just verify that it
	       is there.  */
	    case '!':
	      /* Skip whitespace before register.  */
	      while (*s == ' ' || *s == '\t')
		s = s + 1;

	      if (!strncasecmp(s, "%sar", 4))
	        {
		  s += 4;
		  continue;
		}
	      else if (!strncasecmp(s, "%cr11", 5))
	        {
		  s += 5;
		  continue;
		}
	      break;

a1528 3
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
		break;
d1534 1
a1535 3
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
		break;
a1539 10
	    /* Handle a 5 bit register field at 10 and 15.  */
	    case 'a':
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
		break;
	      num = pa_parse_number (&s, 0);
	      CHECK_FIELD (num, 31, 0, 0);
	      opcode |= num << 16;
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);

a1542 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
a1549 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d1551 1
a1551 3
	      /* When in strict mode, we want to just reject this
		 match instead of giving an out of range error.  */
	      CHECK_FIELD (num, 15, -16, strict);
a1557 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d1559 2
a1560 4
	      /* When in strict mode, we want to just reject this
		 match instead of giving an out of range error.  */
	      CHECK_FIELD (num, 15, -16, strict)
	      low_sign_unext (num, 5, &num);
a1565 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d1568 1
a1568 1
	      INSERT_FIELD_AND_CONTINUE (opcode, num, strict);
a1572 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d1574 1
a1574 10
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

	    /* Handle an unsigned 10 bit immediate at 15.  */
	    case 'U':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 1023, 0, strict);
a1578 3
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
		break;
a1584 3
	      /* This should be more strict.  Small steps.  */
	      if (strict && *s != '%')
		break;
d1590 1
a1590 1
	    /* Handle all completers.  */
d1592 5
a1596 5
	      switch (*++args)
		{

		/* Handle a completer for an indexing load or store.  */
		case 'x':
d1598 2
a1599 4
		    int uu = 0;
		    int m = 0;
		    int i = 0;
		    while (*s == ',' && i < 2)
d1601 2
a1602 21
			s++;
			if (strncasecmp (s, "sm", 2) == 0)
			  {
			    uu = 1;
			    m = 1;
			    s++;
			    i++;
			  }
			else if (strncasecmp (s, "m", 1) == 0)
			  m = 1;
			else if ((strncasecmp (s, "s ", 2) == 0)
				 || (strncasecmp (s, "s,", 2) == 0))
			  uu = 1;
			/* When in strict mode this is a match failure.  */
			else if (strict)
			  {
			    s--;
			    break;
			  }
			else
			  as_bad (_("Invalid Indexed Load Completer."));
d1606 8
a1613 4
		    if (i > 2)
		      as_bad (_("Invalid Indexed Load Completer Syntax."));
		    opcode |= m << 5;
		    INSERT_FIELD_AND_CONTINUE (opcode, uu, 13);
d1615 5
d1621 6
a1626 5
		/* Handle a short load/store completer.  */
		case 'm':
		case 'q':
		case 'J':
		case 'e':
d1628 2
a1629 37
		    int a = 0;
		    int m = 0;
		    if (*s == ',')
		      {
			int found = 0;
			s++;
			if (strncasecmp (s, "ma", 2) == 0)
			  {
			    a = 0;
			    m = 1;
			    found = 1;
			  }
			else if (strncasecmp (s, "mb", 2) == 0)
			  {
			    a = 1;
			    m = 1;
			    found = 1;
			  }

			/* When in strict mode, pass through for cache op.  */
			if (!found && strict)
			  s--;
			else
			  {
			    if (!found)
			      as_bad (_("Invalid Short Load/Store Completer."));
			    s += 2;
			  }
		      }
		    /* If we did not get a ma/mb completer, then we do not
		       consider this a positive match for 'ce'.  */
		    else if (*args == 'e')
		      break;

		   /* 'J', 'm' and 'q' are the same, except for where they
		       encode the before/after field.  */
		   if (*args == 'm')
d1631 2
a1632 2
			opcode |= m << 5;
			INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
d1634 1
a1634 1
		    else if (*args == 'q')
d1636 2
a1637 15
			opcode |= m << 3;
			INSERT_FIELD_AND_CONTINUE (opcode, a, 2);
		      }
		    else if (*args == 'J')
		      {
		        /* M bit is explicit in the major opcode.  */
			INSERT_FIELD_AND_CONTINUE (opcode, a, 2);
		      }
		    else if (*args == 'e')
		      {
			/* Gross!  Hide these values in the immediate field
			   of the instruction, then pull them out later.  */
			opcode |= m << 8;
			opcode |= a << 9;
			continue;
d1639 3
d1643 3
d1647 7
a1653 2
		/* Handle a stbys completer.  */
		case 's':
d1655 11
a1665 28
		    int a = 0;
		    int m = 0;
		    int i = 0;
		    while (*s == ',' && i < 2)
		      {
			s++;
			if (strncasecmp (s, "m", 1) == 0)
			  m = 1;
			else if ((strncasecmp (s, "b ", 2) == 0)
				 || (strncasecmp (s, "b,", 2) == 0))
			  a = 0;
			else if (strncasecmp (s, "e", 1) == 0)
			  a = 1;
			/* When in strict mode this is a match failure.  */
			else if (strict)
			  {
			    s--;
			    break;
			  }
			else
			  as_bad (_("Invalid Store Bytes Short Completer"));
			s++;
			i++;
		      }
		    if (i > 2)
		      as_bad (_("Invalid Store Bytes Short Completer"));
		    opcode |= m << 5;
		    INSERT_FIELD_AND_CONTINUE (opcode, a, 13);
d1667 5
d1673 6
a1678 2
		/* Handle load cache hint completer.  */
		case 'c':
d1680 2
a1681 6
		  if (!strncmp(s, ",sl", 3))
		    {
		      s += 3;
		      cmpltr = 2;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);
d1683 9
a1691 4
		/* Handle store cache hint completer.  */
		case 'C':
		  cmpltr = 0;
		  if (!strncmp(s, ",sl", 3))
d1693 2
a1694 2
		      s += 3;
		      cmpltr = 2;
d1696 1
a1696 1
		  else if (!strncmp(s, ",bc", 3))
d1698 2
a1699 2
		      s += 3;
		      cmpltr = 1;
d1701 2
a1702 1
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);
d1704 6
a1709 2
		/* Handle load and clear cache hint completer.  */
		case 'd':
d1711 2
a1712 6
		  if (!strncmp(s, ",co", 3))
		    {
		      s += 3;
		      cmpltr = 1;
		    }
		  INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 10);
d1714 9
a1722 46
		/* Handle load ordering completer. */
		case 'o':
		  if (strncmp(s, ",o", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle a branch gate completer.  */
		case 'g':
		  if (strncasecmp (s, ",gate", 5) != 0)
		    break;
		  s += 5;
		  continue;

		/* Handle a branch link and push completer.  */
		case 'p':
		  if (strncasecmp (s, ",l,push", 7) != 0)
		    break;
		  s += 7;
		  continue;

		/* Handle a branch link completer.  */
		case 'l':
		  if (strncasecmp (s, ",l", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle a branch pop completer.  */
		case 'P':
		  if (strncasecmp (s, ",pop", 4) != 0)
		    break;
		  s += 4;
		  continue;

		/* Handle a local processor completer.  */
		case 'L':
		  if (strncasecmp (s, ",l", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle a PROBE read/write completer.  */
		case 'w':
		  flag = 0;
		  if (!strncasecmp (s, ",w", 2))
d1724 2
a1725 2
		      flag = 1;
		      s += 2;
d1727 1
a1727 1
		  else if (!strncasecmp (s, ",r", 2))
d1729 2
a1730 2
		      flag = 0;
		      s += 2;
d1732 2
d1735 21
a1755 1
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);
d1757 30
a1786 11
		/* Handle MFCTL wide completer.  */
		case 'W':
		  if (strncasecmp (s, ",w", 2) != 0)
		    break;
		  s += 2;
		  continue;

		/* Handle an RFI restore completer.  */
		case 'r':
		  flag = 0;
		  if (!strncasecmp (s, ",r", 2))
d1788 2
a1789 2
		      flag = 5;
		      s += 2;
d1791 1
a1791 6

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);

		/* Handle a system control completer.  */
		case 'Z':
		  if (*s == ',' && (*(s + 1) == 'm' || *(s + 1) == 'M'))
d1793 1
a1794 1
		      s += 2;
d1796 1
a1796 9
		  else
		    flag = 0;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 5);

		/* Handle intermediate/final completer for DCOR.  */
		case 'i':
		  flag = 0;
		  if (!strncasecmp (s, ",i", 2))
d1798 1
a1799 1
		      s += 2;
d1801 1
a1801 7

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);

		/* Handle zero/sign extension completer.  */
		case 'z':
		  flag = 1;
		  if (!strncasecmp (s, ",z", 2))
d1803 2
a1804 2
		      flag = 0;
		      s += 2;
d1806 1
a1806 7

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 10);

		/* Handle add completer.  */
		case 'a':
		  flag = 1;
		  if (!strncasecmp (s, ",l", 2))
d1808 2
a1809 2
		      flag = 2;
		      s += 2;
d1811 1
a1811 1
		  else if (!strncasecmp (s, ",tsv", 4))
d1813 2
a1814 2
		      flag = 3;
		      s += 4;
d1816 1
a1816 8

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 10);

		/* Handle 64 bit carry for ADD.  */
		case 'Y':
		  flag = 0;
		  if (!strncasecmp (s, ",dc,tsv", 7) ||
		      !strncasecmp (s, ",tsv,dc", 7))
d1818 1
a1819 1
		      s += 7;
d1821 1
a1821 1
		  else if (!strncasecmp (s, ",dc", 3))
d1823 2
a1824 2
		      flag = 0;
		      s += 3;
d1827 29
a1855 9
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle 32 bit carry for ADD.  */
		case 'y':
		  flag = 0;
		  if (!strncasecmp (s, ",c,tsv", 6) ||
		      !strncasecmp (s, ",tsv,c", 6))
d1857 1
a1858 1
		      s += 6;
d1860 1
a1860 1
		  else if (!strncasecmp (s, ",c", 2))
d1862 2
a1863 2
		      flag = 0;
		      s += 2;
d1865 1
a1865 9
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle trap on signed overflow.  */
		case 'v':
		  flag = 0;
		  if (!strncasecmp (s, ",tsv", 4))
d1867 1
a1868 1
		      s += 4;
d1870 1
a1870 8

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle trap on condition and overflow.  */
		case 't':
		  flag = 0;
		  if (!strncasecmp (s, ",tc,tsv", 7) ||
		      !strncasecmp (s, ",tsv,tc", 7))
d1872 1
a1873 1
		      s += 7;
d1875 1
a1875 1
		  else if (!strncasecmp (s, ",tc", 3))
d1877 2
a1878 2
		      flag = 0;
		      s += 3;
d1881 5
a1885 1
		    break;
d1887 33
a1919 7
		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle 64 bit borrow for SUB.  */
		case 'B':
		  flag = 0;
		  if (!strncasecmp (s, ",db,tsv", 7) ||
		      !strncasecmp (s, ",tsv,db", 7))
d1921 1
d1923 1
a1923 1
		      s += 7;
d1925 1
a1925 1
		  else if (!strncasecmp (s, ",db", 3))
d1927 2
a1928 1
		      flag = 0;
d1931 1
a1931 10
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle 32 bit borrow for SUB.  */
		case 'b':
		  flag = 0;
		  if (!strncasecmp (s, ",b,tsv", 6) ||
		      !strncasecmp (s, ",tsv,b", 6))
d1933 1
d1935 1
a1935 1
		      s += 6;
d1937 1
a1937 1
		  else if (!strncasecmp (s, ",b", 2))
d1939 3
a1941 2
		      flag = 0;
		      s += 2;
d1943 1
a1943 9
		  else
		    break;

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

		/* Handle trap condition completer for UADDCM.  */
		case 'T':
		  flag = 0;
		  if (!strncasecmp (s, ",tc", 3))
d1945 1
d1949 1
a1949 24

		  INSERT_FIELD_AND_CONTINUE (opcode, flag, 6);

		/* Handle signed/unsigned at 21.  */
		case 'S':
		  {
		    int sign = 1;
		    if (strncasecmp (s, ",s", 2) == 0)
		      {
			sign = 1;
			s += 2;
		      }
		    else if (strncasecmp (s, ",u", 2) == 0)
		      {
			sign = 0;
			s += 2;
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, sign, 10);
		  }

		/* Handle left/right combination at 17:18.  */
		case 'h':
		  if (*s++ == ',')
d1951 3
a1953 10
		      int lr = 0;
		      if (*s == 'r')
			lr = 2;
		      else if (*s == 'l')
			lr = 0;
		      else
			as_bad(_("Invalid left/right combination completer"));

		      s++;
		      INSERT_FIELD_AND_CONTINUE (opcode, lr, 13);
d1956 4
a1959 2
		    as_bad(_("Invalid left/right combination completer"));
		  break;
d1961 29
a1989 21
		/* Handle saturation at 24:25.  */
		case 'H':
		  {
		    int sat = 3;
		    if (strncasecmp (s, ",ss", 3) == 0)
		      {
			sat = 1;
			s += 3;
		      }
		    else if (strncasecmp (s, ",us", 3) == 0)
		      {
			sat = 0;
			s += 3;
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, sat, 6);
		  }

		/* Handle permutation completer.  */
		case '*':
		  if (*s++ == ',')
d1991 2
a1992 28
		      int permloc[4];
		      int perm = 0;
		      int i = 0;
		      permloc[0] = 13;
		      permloc[1] = 10;
		      permloc[2] = 8;
		      permloc[3] = 6;
		      for (; i < 4; i++)
		        {
			  switch (*s++)
			    {
			    case '0':
			      perm = 0;
			      break;
			    case '1':
			      perm = 1;
			      break;
			    case '2':
			      perm = 2;
			      break;
			    case '3':
			      perm = 3;
			      break;
			    default:
			      as_bad(_("Invalid permutation completer"));
			    }
			  opcode |= perm << permloc[i];
			}
d1996 4
a1999 2
		    as_bad(_("Invalid permutation completer"));
		  break;
d2001 18
a2018 2
		default:
		  abort ();
d2020 1
a2020 1
	      break;
d2022 9
a2030 455
	    /* Handle all conditions.  */
	    case '?':
	      {
		args++;
		switch (*args)
		  {
 		  /* Handle FP compare conditions.  */
 		  case 'f':
 		    cond = pa_parse_fp_cmp_cond (&s);
 		    INSERT_FIELD_AND_CONTINUE (opcode, cond, 0);

		  /* Handle an add condition.  */
		  case 'A':
		  case 'a':
 		    cmpltr = 0;
 		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'A')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
			name = s;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "nuv") == 0)
			  cmpltr = 4;
			else if (strcasecmp (name, "znv") == 0)
			  cmpltr = 5;
			else if (strcasecmp (name, "sv") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, "uv") == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			  }
			else if (strcasecmp (name, "vnz") == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			  }
			else if (strcasecmp (name, "nsv") == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args == 'a')
			  as_bad (_("Invalid Add Condition: %s"), name);
			*s = c;
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  /* Handle non-negated add and branch condition.  */
		  case 'd':
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Add and Branch Condition: %c"), *s);
			cmpltr = 0;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle 64 bit wide-mode add and branch condition.  */
		  case 'W':
		    cmpltr = pa_parse_addb_64_cmpltr (&s);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Add and Branch Condition: %c"), *s);
			cmpltr = 0;
		      }
		    else
		      {
			/* Negated condition requires an opcode change. */
			opcode |= (cmpltr & 8) << 24;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr & 7, 13);

		  /* Handle a negated or non-negated add and branch
		     condition.  */
		  case '@@':
		    save_s = s;
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s, 1);
		    if (cmpltr < 0)
		      {
			s = save_s;
			cmpltr = pa_parse_neg_add_cmpltr (&s, 1);
			if (cmpltr < 0)
			  {
			    as_bad (_("Invalid Compare/Subtract Condition"));
			    cmpltr = 0;
			  }
			else
			  {
			    /* Negated condition requires an opcode change. */
			    opcode |= 1 << 27;
			  }
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle branch on bit conditions.  */
		  case 'B':
		  case 'b':
		    cmpltr = 0;
		    if (*s == ',')
		      {
			s++;

			if (*args == 'B')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			if (strncmp (s, "<", 1) == 0)
			  {
			    cmpltr = 0;
			    s++;
			  }
			else if (strncmp (s, ">=", 2) == 0)
			  {
			    cmpltr = 1;
			    s += 2;
			  }
			else
			  as_bad (_("Invalid Bit Branch Condition: %c"), *s);
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 15);

		  /* Handle a compare/subtract condition.  */
		  case 'S':
		  case 's':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'S')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
			name = s;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "<<") == 0)
			  cmpltr = 4;
			else if (strcasecmp (name, "<<=") == 0)
			  cmpltr = 5;
			else if (strcasecmp (name, "sv") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, ">>=") == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			  }
			else if (strcasecmp (name, ">>") == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			  }
			else if (strcasecmp (name, "nsv") == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'S')
			  as_bad (_("Invalid Compare/Subtract Condition: %s"),
				  name);
			*s = c;
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  /* Handle a non-negated compare condition.  */
		  case 't':
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
		    if (cmpltr < 0)
		      {
			as_bad (_("Invalid Compare/Subtract Condition: %c"), *s);
			cmpltr = 0;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a 32 bit compare and branch condition.  */
		  case 'n':
		    save_s = s;
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s, 1);
		    if (cmpltr < 0)
		      {
			s = save_s;
			cmpltr = pa_parse_neg_cmpsub_cmpltr (&s, 1);
			if (cmpltr < 0)
			  {
			    as_bad (_("Invalid Compare and Branch Condition."));
			    cmpltr = 0;
			  }
			else
			  {
			    /* Negated condition requires an opcode change. */
			    opcode |= 1 << 27;
			  }
		      }

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a 64 bit compare and branch condition.  */
		  case 'N':
		    cmpltr = pa_parse_cmpb_64_cmpltr (&s);
		    if (cmpltr >= 0)
		      {
			/* Negated condition requires an opcode change. */
			opcode |= (cmpltr & 8) << 26;
		      }
		    else
		      /* Not a 64 bit cond.  Give 32 bit a chance. */
		      break;

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr & 7, 13);

		  /* Handle a 64 bit cmpib condition.  */
		  case 'Q':
		    cmpltr = pa_parse_cmpib_64_cmpltr (&s);
		    if (cmpltr < 0)
		      /* Not a 64 bit cond.  Give 32 bit a chance. */
		      break;

		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		    /* Handle a logical instruction condition.  */
		  case 'L':
		  case 'l':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;

			/* 64 bit conditions.  */
			if (*args == 'L')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
			name = s;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;


			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcmp (name, "<=") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 7;
			else if (strcasecmp (name, "tr") == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			  }
			else if (strcmp (name, "<>") == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			  }
			else if (strcmp (name, ">=") == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			  }
			else if (strcmp (name, ">") == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			  }
			else if (strcasecmp (name, "ev") == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'L')
			  as_bad (_("Invalid Logical Instruction Condition."));
			*s = c;
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  /* Handle a shift/extract/deposit condition.  */
		  case 'X':
		  case 'x':
		  case 'y':
		    cmpltr = 0;
		    if (*s == ',')
		      {
			save_s = s++;

			/* 64 bit conditions.  */
			if (*args == 'X')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;
			name = s;

			name = s;
			while (*s != ',' && *s != ' ' && *s != '\t')
			  s += 1;
			c = *s;
			*s = 0x00;
			if (strcmp (name, "=") == 0)
			  cmpltr = 1;
			else if (strcmp (name, "<") == 0)
			  cmpltr = 2;
			else if (strcasecmp (name, "od") == 0)
			  cmpltr = 3;
			else if (strcasecmp (name, "tr") == 0)
			  cmpltr = 4;
			else if (strcmp (name, "<>") == 0)
			  cmpltr = 5;
			else if (strcmp (name, ">=") == 0)
			  cmpltr = 6;
			else if (strcasecmp (name, "ev") == 0)
			  cmpltr = 7;
			/* Handle movb,n.  Put things back the way they were.
			   This includes moving s back to where it started.  */
			else if (strcasecmp (name, "n") == 0 && *args == 'y')
			  {
			    *s = c;
			    s = save_s;
			    continue;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'X')
			  as_bad (_("Invalid Shift/Extract/Deposit Condition."));
			*s = c;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, cmpltr, 13);

		  /* Handle a unit instruction condition.  */
		  case 'U':
		  case 'u':
		    cmpltr = 0;
		    flag = 0;
		    if (*s == ',')
		      {
			s++;
d2032 1
a2032 108
			/* 64 bit conditions.  */
			if (*args == 'U')
			  {
			    if (*s == '*')
			      s++;
			    else
			      break;
			  }
			else if (*s == '*')
			  break;

			if (strncasecmp (s, "sbz", 3) == 0)
			  {
			    cmpltr = 2;
			    s += 3;
			  }
			else if (strncasecmp (s, "shz", 3) == 0)
			  {
			    cmpltr = 3;
			    s += 3;
			  }
			else if (strncasecmp (s, "sdc", 3) == 0)
			  {
			    cmpltr = 4;
			    s += 3;
			  }
			else if (strncasecmp (s, "sbc", 3) == 0)
			  {
			    cmpltr = 6;
			    s += 3;
			  }
			else if (strncasecmp (s, "shc", 3) == 0)
			  {
			    cmpltr = 7;
			    s += 3;
			  }
			else if (strncasecmp (s, "tr", 2) == 0)
			  {
			    cmpltr = 0;
			    flag = 1;
			    s += 2;
			  }
			else if (strncasecmp (s, "nbz", 3) == 0)
			  {
			    cmpltr = 2;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nhz", 3) == 0)
			  {
			    cmpltr = 3;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "ndc", 3) == 0)
			  {
			    cmpltr = 4;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nbc", 3) == 0)
			  {
			    cmpltr = 6;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nhc", 3) == 0)
			  {
			    cmpltr = 7;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "swz", 3) == 0)
			  {
			    cmpltr = 1;
			    flag = 0;
			    s += 3;
			  }
			else if (strncasecmp (s, "swc", 3) == 0)
			  {
			    cmpltr = 5;
			    flag = 0;
			    s += 3;
			  }
			else if (strncasecmp (s, "nwz", 3) == 0)
			  {
			    cmpltr = 1;
			    flag = 1;
			    s += 3;
			  }
			else if (strncasecmp (s, "nwc", 3) == 0)
			  {
			    cmpltr = 5;
			    flag = 1;
			    s += 3;
			  }
			/* ",*" is a valid condition.  */
			else if (*args != 'U')
			  as_bad (_("Invalid Unit Instruction Condition."));
		      }
		    opcode |= cmpltr << 13;
		    INSERT_FIELD_AND_CONTINUE (opcode, flag, 12);

		  default:
		    abort ();
		  }
		break;
	      }
a2043 47
	    /* Handle ,%r2 completer for new syntax branches.  */
	    case 'L':
	      if (*s == ',' && strncasecmp (s + 1, "%r2", 3) == 0)
		s += 4;
	      else if (*s == ',' && strncasecmp (s + 1, "%rp", 3) == 0)
		s += 4;
	      else
		break;
	      continue;

	    /* Handle 3 bit entry into the fp compare array.   Valid values
	       are 0..6 inclusive.  */
	    case 'h':
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 6, 0, 0);
		  num++;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
		}
	      else
		break;

	    /* Handle 3 bit entry into the fp compare array.   Valid values
	       are 0..6 inclusive.  */
	    case 'm':
	      get_expression (s);
	      if (the_insn.exp.X_op == O_constant)
		{
		  s = expr_end;
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 6, 0, 0);
		  num = (num + 1) ^ 1;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 13);
		}
	      else
		break;

	    /* Handle graphics test completers for ftest */
	    case '=':
	      {
		num = pa_parse_ftest_gfx_completer (&s);
		INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
	      }

a2068 120
	    case 'J':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int a, m;

		  /* XXX the completer stored away tibits of information
		     for us to extract.  We need a cleaner way to do this.
		     Now that we have lots of letters again, it would be
		     good to rethink this.  */
		  m = (opcode & (1 << 8)) != 0;
		  a = (opcode & (1 << 9)) != 0;
		  opcode &= ~ (3 << 8);
		  num = evaluate_absolute (&the_insn);
		  if ((a == 1 && num >= 0) || (a == 0 && num < 0))
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  low_sign_unext (num, 14, &num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      else
		{
		  break;
		}

	    /* Handle a 14 bit immediate at 31.  */
	    case 'K':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int a, m;

		  /* XXX the completer stored away tibits of information
		     for us to extract.  We need a cleaner way to do this.
		     Now that we have lots of letters again, it would be
		     good to rethink this.  */
		  m = (opcode & (1 << 8)) != 0;
		  a = (opcode & (1 << 9)) != 0;
		  opcode &= ~ (3 << 8);
		  num = evaluate_absolute (&the_insn);
		  if ((a == 1 && num < 0) || (a == 0 && num > 0))
		    break;
		  if (num % 4)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  if (num < 0)
		    opcode |= 1;
                  num &= 0x1fff;
                  num >>= 2;
                  INSERT_FIELD_AND_CONTINUE (opcode, num, 3);
		}
	      else
		{
		  break;
		}

	    /* Handle 14 bit immediated, shifted left three times.  */
	    case '#':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  if (num & 0x7)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  if (num < 0)
		    opcode |= 1;
		  num &= 0x1fff;
		  num >>= 3;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 4);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}
	      break;

	    /* Handle 14 bit immediate, shifted left twice.  */
	    case 'd':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  if (num & 0x3)
		    break;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  if (num < 0)
		    opcode |= 1;
		  num &= 0x1fff;
		  num >>= 2;
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 3);
		}
	      else
		{
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a 14 bit immediate at 31.  */
d2129 1
a2129 1
		      as_bad (_("Branch to unaligned address"));
d2142 1
a2142 1
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
d2162 1
a2162 1
		      as_bad (_("Branch to unaligned address"));
d2180 1
a2180 40
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}

	    /* Handle a 22 bit branch displacement.  */
	    case 'X':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      the_insn.pcrel = 1;
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      "L$0\001"))
		{
		  unsigned int w3, w2, w1, w, result;

		  num = evaluate_absolute (&the_insn);
		  if (num % 4)
		    {
		      as_bad (_("Branch to unaligned address"));
		      break;
		    }
		  CHECK_FIELD (num, 8388607, -8388608, 0);

		  if (the_insn.exp.X_add_symbol)
		    num -= 8;

		  sign_unext (num >> 2, 22, &result);
		  dis_assemble_22 (result, &w3, &w1, &w2, &w);
		  INSERT_FIELD_AND_CONTINUE (opcode,
					     ((w3 << 21) | (w2 << 2)
					      | (w1 << 16) | w),
					     0);
		}
	      else
		{
		  the_insn.reloc = R_HPPA_PCREL_CALL;
		  the_insn.format = 22;
		  the_insn.arg_reloc = last_call_desc.arg_reloc;
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
d2199 1
a2199 1
		      as_bad (_("Branch to unaligned address"));
d2217 1
a2217 10
		  memset (&last_call_desc, 0, sizeof (struct call_desc));
		  continue;
		}

	    /* Handle '%r1' implicit operand of addil instruction.  */
	    case 'Z':
	      if (*s == ',' && *(s + 1) == '%' && *(s + 3) == '1'
		  && (*(s + 2) == 'r' || *(s + 2) == 'R'))
		{
		  s += 4;
a2219 34
	      else
	        break;

	    /* Handle '%sr0,%r31' implicit operand of be,l instruction.  */
	    case 'Y':
	      if (strncasecmp (s, "%sr0,%r31", 9) != 0)
		break;
	      s += 9;
	      continue;

	    /* Handle immediate value of 0 for ordered load/store instructions.  */
	    case '@@':
	      if (*s != '0')
		break;
	      s++;
	      continue;

	    /* Handle a 2 bit shift count at 25.  */
	    case '.':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 3, 1, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);

	    /* Handle a 4 bit shift count at 25.  */
	    case '*':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 15, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 6);
a2223 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2225 1
a2225 1
	      CHECK_FIELD (num, 31, 0, strict);
a2227 36
	    /* Handle a 6 bit shift count at 20,22:26.  */
	    case '~':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      num = 63 - num;
	      opcode |= (num & 0x20) << 6;
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 5);

	    /* Handle a 6 bit field length at 23,27:31.  */
	    case '%':
	      flag = 0;
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 64, 1, strict);
	      num--;
	      opcode |= (num & 0x20) << 3;
	      num = 31 - (num & 0x1f);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

	    /* Handle a 6 bit field length at 19,27:31.  */
	    case '|':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 64, 1, strict);
	      num--;
	      opcode |= (num & 0x20) << 7;
	      num = 31 - (num & 0x1f);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);

a2230 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2232 1
a2232 1
	      CHECK_FIELD (num, 31, 0, strict);
a2234 24
	    /* Handle a 6 bit bit position at 20,22:26.  */
	    case 'q':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      opcode |= (num & 0x20) << 6;
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 5);

	    /* Handle a 5 bit immediate at 10 with 'd' as the complement
	       of the high bit of the immediate.  */
	    case 'B':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 63, 0, strict);
	      if (num & 0x20)
		;
	      else
		opcode |= (1 << 13);
	      INSERT_FIELD_AND_CONTINUE (opcode, num & 0x1f, 21);

a2237 13
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
	      if (the_insn.exp.X_op != O_constant)
		break;
	      s = expr_end;
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 21);

	    /* Handle a 9 bit immediate at 28.  */
	    case '$':
	      num = pa_get_absolute_expression (&the_insn, &s);
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2239 2
a2240 2
	      CHECK_FIELD (num, 511, 1, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 3);
a2244 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2246 1
a2246 1
	      CHECK_FIELD (num, 8191, 0, strict);
a2251 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2253 1
a2253 1
	      CHECK_FIELD (num, 671108864, 0, strict);
d2257 1
a2257 1
	    case 'v':
d2259 1
a2259 1
		as_bad (_("Invalid SFU identifier"));
a2260 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2262 1
a2262 1
	      CHECK_FIELD (num, 7, 0, strict);
a2267 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2269 1
a2269 1
	      CHECK_FIELD (num, 1048575, 0, strict);
a2275 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2277 1
a2277 1
	      CHECK_FIELD (num, 32767, 0, strict);
a2282 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2284 1
a2284 1
	      CHECK_FIELD (num, 1023, 0, strict);
a2290 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2292 1
a2292 1
	      CHECK_FIELD (num, 32767, 0, strict);
d2299 1
a2299 1
		as_bad (_("Invalid COPR identifier"));
a2300 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2302 1
a2302 1
	      CHECK_FIELD (num, 7, 0, strict);
a2307 2
	      if (strict && the_insn.exp.X_op != O_constant)
		break;
d2309 1
a2309 1
	      CHECK_FIELD (num, 4194303, 0, strict);
a2313 76
	    case '{':
	      if (*s == ',' && *(s+1) == 't')
		{
		  the_insn.trunc = 1;
		  s += 2;
		}
	      else
		the_insn.trunc = 0;
	      flag = pa_parse_fp_cnv_format (&s);
	      the_insn.fpof1 = flag;
	      if (flag == W || flag == UW)
		flag = SGL;
	      if (flag == DW || flag == UDW)
		flag = DBL;
	      if (flag == QW || flag == UQW)
		flag = QUAD;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);

	    /* Handle a destination FP operand format completer.  */
	    case '_':
	      /* pa_parse_format needs the ',' prefix.  */
	      s--;
	      flag = pa_parse_fp_cnv_format (&s);
	      the_insn.fpof2 = flag;
	      if (flag == W || flag == UW)
		flag = SGL;
	      if (flag == DW || flag == UDW)
		flag = DBL;
	      if (flag == QW || flag == UQW)
		flag = QUAD;
	      opcode |= flag << 13;
	      if (the_insn.fpof1 == SGL
		  || the_insn.fpof1 == DBL
		  || the_insn.fpof1 == QUAD)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 0;
		  else if (the_insn.fpof2 == W
		      || the_insn.fpof2 == DW
		      || the_insn.fpof2 == QW)
		    flag = 2;
		  else if (the_insn.fpof2 == UW
		      || the_insn.fpof2 == UDW
		      || the_insn.fpof2 == UQW)
		    flag = 6;
		  else
		    abort ();
		}
	      else if (the_insn.fpof1 == W
		       || the_insn.fpof1 == DW
		       || the_insn.fpof1 == QW)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 1;
		  else
		    abort ();
		}
	      else if (the_insn.fpof1 == UW
		       || the_insn.fpof1 == UDW
		       || the_insn.fpof1 == UQW)
		{
		  if (the_insn.fpof2 == SGL
		      || the_insn.fpof2 == DBL
		      || the_insn.fpof2 == QUAD)
		    flag = 5;
		  else
		    abort ();
		}
	      flag |= the_insn.trunc;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 15);

	    /* Handle a source FP operand format completer.  */
d2327 4
a2330 5
	    /* Handle a source FP operand format completer at 20.  */
	    case 'I':
	      flag = pa_parse_fp_format (&s);
	      the_insn.fpof1 = flag;
	      INSERT_FIELD_AND_CONTINUE (opcode, flag, 11);
d2332 4
a2335 11
	    /* Handle a floating point operand format at 26.
	       Only allows single and double precision.  */
	    case 'H':
	      flag = pa_parse_fp_format (&s);
	      switch (flag)
		{
		case SGL:
		  opcode |= 0x20;
		case DBL:
		  the_insn.fpof1 = flag;
		  continue;
d2337 10
a2346 6
		case QUAD:
		case ILLEGAL_FMT:
		default:
		  as_bad (_("Invalid Floating Point Operand Format."));
		}
	      break;
d2348 2
a2349 12
	    /* Handle all floating point registers.  */
	    case 'f':
	      switch (*++args)
	        {
		/* Float target register.  */
		case 't':
		  /* This should be more strict.  Small steps.  */
		  if (strict && *s != '%')
		    break;
		  num = pa_parse_number (&s, 0);
		  CHECK_FIELD (num, 31, 0, 0);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d2351 4
a2354 40
		/* Float target register with L/R selection.  */
		case 'T':
		  {
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= result.number_part;

		    /* 0x30 opcodes are FP arithmetic operation opcodes
		       and need to be turned into 0x38 opcodes.  This
		       is not necessary for loads/stores.  */
		    if (need_pa11_opcode (&the_insn, &result)
			&& ((opcode & 0xfc000000) == 0x30000000))
		      opcode |= 1 << 27;

		    INSERT_FIELD_AND_CONTINUE (opcode, result.l_r_select & 1, 6);
		  }

		/* Float operand 1.  */
		case 'a':
		  {
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= result.number_part << 21;
		    if (need_pa11_opcode (&the_insn, &result))
		      {
			opcode |= (result.l_r_select & 1) << 7;
			opcode |= 1 << 27;
		      }
		    continue;
		  }
d2356 4
a2359 3
		/* Float operand 1 with L/R selection.  */
		case 'X':
		case 'A':
a2360 8
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= result.number_part << 21;
d2362 1
a2362 1
		    continue;
d2364 2
d2367 4
a2370 18
		/* Float operand 2.  */
		case 'b':
		  {
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1f) << 16;
		    if (need_pa11_opcode (&the_insn, &result))
		      {
			opcode |= (result.l_r_select & 1) << 12;
			opcode |= 1 << 27;
		      }
		    continue;
		  }
d2372 4
a2375 2
		/* Float operand 2 with L/R selection.  */
		case 'B':
a2376 8
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1f) << 16;
d2378 1
a2378 1
		    continue;
d2380 2
d2383 4
a2386 4
		/* Float operand 3 for fmpyfadd, fmpynfadd.  */
		case 'C':
		  {
		    struct pa_11_fp_reg_struct result;
d2388 3
a2390 13
		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1c) << 11;
		    opcode |= (result.number_part & 0x3) << 9;
		    opcode |= (result.l_r_select & 1) << 8;
		    continue;
		  }

		/* Float mult operand 1 for fmpyadd, fmpysub */
		case 'i':
d2392 1
a2392 8
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
d2394 3
a2396 5
			if (result.number_part < 16)
			  {
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
			  }
d2398 2
a2399 4
			result.number_part &= 0xF;
			result.number_part |= (result.l_r_select & 1) << 4;
		      }
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 21);
d2401 7
d2409 3
a2411 2
		/* Float mult operand 2 for fmpyadd, fmpysub */
		case 'j':
d2413 1
a2413 8
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
d2415 2
a2416 7
		        if (result.number_part < 16)
		          {
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
		          }
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d2418 2
a2419 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 16);
d2421 2
d2424 8
a2431 2
		/* Float mult target for fmpyadd, fmpysub */
		case 'k':
d2433 1
a2433 8
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
d2435 2
a2436 7
		        if (result.number_part < 16)
		          {
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
		          }
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d2438 2
a2439 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 0);
d2441 7
d2449 3
a2451 2
		/* Float add operand 1 for fmpyadd, fmpysub */
		case 'l':
d2453 1
a2453 8
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
d2455 2
a2456 7
		        if (result.number_part < 16)
		          {
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
		          }
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d2458 2
a2459 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 6);
d2461 7
d2469 3
a2471 2
		/* Float add target for fmpyadd, fmpysub */
		case 'm':
d2473 1
a2473 8
		    struct pa_11_fp_reg_struct result;

		    /* This should be more strict.  Small steps.  */
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    if (the_insn.fpof1 == SGL)
d2475 2
a2476 7
		        if (result.number_part < 16)
		          {
		    	as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
		    	break;
		          }
		        result.number_part &= 0xF;
		        result.number_part |= (result.l_r_select & 1) << 4;
d2478 2
a2479 1
		    INSERT_FIELD_AND_CONTINUE (opcode, result.number_part, 11);
d2481 2
d2484 11
a2494 4
		/* Handle L/R register halves like 'x'.  */
		case 'e':
		  {
		    struct pa_11_fp_reg_struct result;
d2496 2
a2497 11
		    if (strict && *s != '%')
		      break;
		    pa_parse_number (&s, &result);
		    CHECK_FIELD (result.number_part, 31, 0, 0);
		    opcode |= (result.number_part & 0x1f) << 16;
		    if (need_pa11_opcode (&the_insn, &result))
		      {
			opcode |= (result.l_r_select & 1) << 1;
		      }
		    continue;
		  }
d2499 1
a2499 1
		  abort ();
a2508 1
 failed:
d2512 1
a2512 1
	  if (&insn[1] - pa_opcodes < (int) NUMOPCODES
d2521 1
a2521 1
	      as_bad (_("Invalid operands %s"), error_message);
d2577 1
a2577 1
      return _("Bad call to MD_ATOF()");
d2627 1
a2627 2
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2633 1
a2633 4
			       symbol_get_bfdsym (fixp->fx_addsy));

  if (codes == NULL)
    abort ();
d2653 1
a2653 2
      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2703 1
a2703 2
      relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2714 1
a2714 1
	  relocs[0]->sym_ptr_ptr = (asymbol **) &(bfd_abs_symbol);
d2718 1
a2718 2
	  relocs[1]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[1]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2722 1
a2722 2
	  relocs[2]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[2]->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_subsy);
d2726 1
a2726 1
	  relocs[3]->sym_ptr_ptr = (asymbol **) &(bfd_abs_symbol);
d2730 1
a2730 1
	  relocs[4]->sym_ptr_ptr = (asymbol **) &(bfd_abs_symbol);
d2768 1
a2768 2
          relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
          *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
d2776 1
a2776 2
          relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
          *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
d2837 24
d2945 1
a2945 1
      int fmt = bfd_hppa_insn2fmt (buf_wd);
d2955 6
d2963 1
a2963 1
	new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
a2964 8
      /* These field selectors imply that we do not want an addend.  */
      else if (hppa_fixP->fx_r_field == e_psel
	       || hppa_fixP->fx_r_field == e_rpsel
	       || hppa_fixP->fx_r_field == e_lpsel
	       || hppa_fixP->fx_r_field == e_tsel
	       || hppa_fixP->fx_r_field == e_rtsel
	       || hppa_fixP->fx_r_field == e_ltsel)
	new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
d2979 1
a2979 1
      if ((fmt == 12 || fmt == 17 || fmt == 22)
d2982 4
a2985 6
#ifdef OBJ_SOM
	  && !arg_reloc_stub_needed ((long) ((obj_symbol_type *)
		symbol_get_bfdsym (fixP->fx_addsy))->tc_data.ap.hppa_arg_reloc,
		hppa_fixP->fx_arg_reloc)
#endif
	  && (((int)(*valp) > -262144 && (int)(*valp) < 262143) && fmt != 22)
d2989 1
a2989 1

d2992 1
a2992 1

d3047 1
a3047 2
	  {
	    int distance = *valp;
d3049 8
a3056 41
	    CHECK_FIELD (new_val, 262143, -262144, 0);

	    /* If this is an absolute branch (ie no link) with an out of
	       range target, then we want to complain.  */
	    if (fixP->fx_r_type == R_HPPA_PCREL_CALL
		&& (distance > 262143 || distance < -262144)
		&& (bfd_get_32 (stdoutput, buf) & 0xffe00000) == 0xe8000000)
	      CHECK_FIELD (distance, 262143, -262144, 0);

	    /* Mask off 17 bits to be changed.  */
	    bfd_put_32 (stdoutput,
			bfd_get_32 (stdoutput, buf) & 0xffe0e002,
			buf);
	    sign_unext ((new_val - 8) >> 2, 17, &resulti);
	    dis_assemble_17 (resulti, &w1, &w2, &w);
	    result = ((w2 << 2) | (w1 << 16) | w);
	    break;
	  }

	case 22:
	  {
	    int distance = *valp, w3;

	    CHECK_FIELD (new_val, 8388607, -8388608, 0);

	    /* If this is an absolute branch (ie no link) with an out of
	       range target, then we want to complain.  */
	    if (fixP->fx_r_type == R_HPPA_PCREL_CALL
		&& (distance > 8388607 || distance < -8388608)
		&& (bfd_get_32 (stdoutput, buf) & 0xffe00000) == 0xe8000000)
	      CHECK_FIELD (distance, 8388607, -8388608, 0);

	    /* Mask off 22 bits to be changed.  */
	    bfd_put_32 (stdoutput,
			bfd_get_32 (stdoutput, buf) & 0xfc00e002,
			buf);
	    sign_unext ((new_val - 8) >> 2, 22, &resulti);
	    dis_assemble_22 (resulti, &w3, &w1, &w2, &w);
	    result = ((w3 << 21) | (w2 << 2) | (w1 << 16) | w);
	    break;
	  }
d3064 1
a3064 1
	  as_bad (_("Unknown relocation encountered in md_apply_fix."));
d3074 1
a3074 1
      printf (_("no hppa_fixup entry for this fixup (fixP = 0x%x, type = 0x%x)\n"),
d3216 1
a3216 1
		as_bad (_("Undefined register: '%s'."), name);
d3241 1
a3241 1
		as_bad (_("Undefined register: '%s'."), name);
d3279 1
a3279 1
		as_bad (_("Non-absolute symbol: '%s'."), name);
d3294 1
a3294 1
		as_bad (_("Undefined absolute constant: '%s'."), name);
d3364 1
a3364 1
	    as_warn (_("could not update architecture and machine"));
d3388 12
a3399 139
	  cond = fp_cond_map[i].cond;
	  *s += strlen (fp_cond_map[i].string);
	  /* If not a complete match, back up the input string and
	     report an error.  */
	  if (**s != ' ' && **s != '\t')
	    {
	      *s -= strlen (fp_cond_map[i].string);
	      break;
	    }
	  while (**s == ' ' || **s == '\t')
	    *s = *s + 1;
	  return cond;
	}
    }

  as_bad (_("Invalid FP Compare Condition: %s"), *s);

  /* Advance over the bogus completer.  */
  while (**s != ',' && **s != ' ' && **s != '\t')
    *s += 1;

  return 0;
}

/* Parse a graphics test complete for ftest.  */

static int
pa_parse_ftest_gfx_completer (s)
     char **s;
{
  int value;

  value = 0;
  if (strncasecmp (*s, "acc8", 4) == 0)
    {
      value = 5;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc6", 4) == 0)
    {
      value = 9;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc4", 4) == 0)
    {
      value = 13;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc2", 4) == 0)
    {
      value = 17;
      *s += 4;
    }
  else if (strncasecmp (*s, "acc", 3) == 0)
    {
      value = 1;
      *s += 3;
    }
  else if (strncasecmp (*s, "rej8", 4) == 0)
    {
      value = 6;
      *s += 4;
    }
  else if (strncasecmp (*s, "rej", 3) == 0)
    {
      value = 2;
      *s += 3;
    }
  else
    {
      value = 0;
      as_bad (_("Invalid FTEST completer: %s"), *s);
    }

  return value;
}

/* Parse an FP operand format completer returning the completer
   type.  */

static fp_operand_format
pa_parse_fp_cnv_format (s)
     char **s;
{
  int format;

  format = SGL;
  if (**s == ',')
    {
      *s += 1;
      if (strncasecmp (*s, "sgl", 3) == 0)
	{
	  format = SGL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "dbl", 3) == 0)
	{
	  format = DBL;
	  *s += 4;
	}
      else if (strncasecmp (*s, "quad", 4) == 0)
	{
	  format = QUAD;
	  *s += 5;
	}
      else if (strncasecmp (*s, "w", 1) == 0)
	{
	  format = W;
	  *s += 2;
	}
      else if (strncasecmp (*s, "uw", 2) == 0)
	{
	  format = UW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "dw", 2) == 0)
	{
	  format = DW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "udw", 3) == 0)
	{
	  format = UDW;
	  *s += 4;
	}
      else if (strncasecmp (*s, "qw", 2) == 0)
	{
	  format = QW;
	  *s += 3;
	}
      else if (strncasecmp (*s, "uqw", 3) == 0)
	{
	  format = UQW;
	  *s += 4;
	}
      else
	{
	  format = ILLEGAL_FMT;
	  as_bad (_("Invalid FP Operand Format: %3s"), *s);
d3403 7
a3409 1
  return format;
d3443 1
a3443 1
	  as_bad (_("Invalid FP Operand Format: %3s"), *s);
d3472 1
d3478 1
d3524 1
a3524 1
      as_warn (_("Bad segment in expression."));
a3545 35
  /* This is not perfect, but is a huge improvement over doing nothing.

     The PA assembly syntax is ambigious in a variety of ways.  Consider
     this string "4 %r5"  Is that the number 4 followed by the register
     r5, or is that 4 MOD 5?

     If we get a modulo expresion When looking for an absolute, we try
     again cutting off the input string at the first whitespace character.  */
  if (insn->exp.X_op == O_modulus)
    {
      char *s, c;
      int retval;

      input_line_pointer = *strp;
      s = *strp;
      while (*s != ',' && *s != ' ' && *s != '\t')
        s++;

      c = *s;
      *s = 0;

      retval = pa_get_absolute_expression (insn, strp);

      input_line_pointer = save_in;
      *s = c;
      return evaluate_absolute (insn);
    }
  /* When in strict mode we have a non-match, fix up the pointers
     and return to our caller.  */
  if (insn->exp.X_op != O_constant && strict)
    {
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 0;
    }
d3548 1
a3548 1
      as_bad (_("Bad segment (should be absolute)."));
d3647 1
a3647 1
    as_bad (_("Invalid argument location: %s\n"), type_name);
d3678 1
a3678 1
      as_bad (_("Invalid argument description: %d"), reg);
d3701 1
a3701 1
	  as_bad (_("Invalid Nullification: (%c)"), **s);
a3725 255
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;


      if (strcmp (name, "=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "<<") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "<<=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "od") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0 && isbranch)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;


  return cmpltr;
}

/* Parse a negated compare/subtract completer returning the
   number (for encoding in instrutions) of the given completer.

   ISBRANCH specifies whether or not this is parsing a condition
   completer for a branch (vs a nullification completer for a
   computational instruction.  */

static int
pa_parse_neg_cmpsub_cmpltr (s, isbranch)
     char **s;
     int isbranch;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
  int nullify = 0;

  cmpltr = 0;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;


      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, ">>=") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, ">>") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "nsv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "ev") == 0)
	{
	  cmpltr = 7;
	}
      /* If we have something like addb,n then there is no condition
         completer.  */
      else if (strcasecmp (name, "n") == 0 && isbranch)
	{
	  cmpltr = 0;
	  nullify = 1;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }

  /* Reset pointers if this was really a ,n for a branch instruction.  */
  if (nullify)
    *s = save_s;


  return cmpltr;
}


/* Parse a 64 bit compare and branch completer returning the number (for
   encoding in instrutions) of the given completer.

   Nonnegated comparisons are returned as 0-7, negated comparisons are
   returned as 8-15.  */

static int
pa_parse_cmpb_64_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;

  cmpltr = -1;
  if (**s == ',')
    {
      *s += 1;
      while (**s != ',' && **s != ' ' && **s != '\t')
	*s += 1;
      c = **s;
      **s = 0x00;

      if (strcmp (name, "*") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "*=") == 0)
	{
	  cmpltr = 1;
	}
      else if (strcmp (name, "*<") == 0)
	{
	  cmpltr = 2;
	}
      else if (strcmp (name, "*<=") == 0)
	{
	  cmpltr = 3;
	}
      else if (strcmp (name, "*<<") == 0)
	{
	  cmpltr = 4;
	}
      else if (strcmp (name, "*<<=") == 0)
	{
	  cmpltr = 5;
	}
      else if (strcasecmp (name, "*sv") == 0)
	{
	  cmpltr = 6;
	}
      else if (strcasecmp (name, "*od") == 0)
	{
	  cmpltr = 7;
	}
      else if (strcasecmp (name, "*tr") == 0)
	{
	  cmpltr = 8;
	}
      else if (strcmp (name, "*<>") == 0)
	{
	  cmpltr = 9;
	}
      else if (strcmp (name, "*>=") == 0)
	{
	  cmpltr = 10;
	}
      else if (strcmp (name, "*>") == 0)
	{
	  cmpltr = 11;
	}
      else if (strcmp (name, "*>>=") == 0)
	{
	  cmpltr = 12;
	}
      else if (strcmp (name, "*>>") == 0)
	{
	  cmpltr = 13;
	}
      else if (strcasecmp (name, "*nsv") == 0)
	{
	  cmpltr = 14;
	}
      else if (strcasecmp (name, "*ev") == 0)
	{
	  cmpltr = 15;
	}
      else
	{
	  cmpltr = -1;
	}
      **s = c;
    }


  return cmpltr;
}

/* Parse a 64 bit compare immediate and branch completer returning the number
   (for encoding in instrutions) of the given completer.  */

static int
pa_parse_cmpib_64_cmpltr (s)
     char **s;
{
  int cmpltr;
  char *name = *s + 1;
  char c;
  char *save_s = *s;
d3727 1
a3727 1
  cmpltr = -1;
d3735 1
a3735 6

      if (strcmp (name, "*<<") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "*=") == 0)
d3739 1
a3739 1
      else if (strcmp (name, "*<") == 0)
d3743 1
a3743 1
      else if (strcmp (name, "*<=") == 0)
d3747 1
a3747 1
      else if (strcmp (name, "*>>=") == 0)
d3751 1
a3751 1
      else if (strcmp (name, "*<>") == 0)
d3755 1
a3755 1
      else if (strcasecmp (name, "*>=") == 0)
d3759 1
a3759 1
      else if (strcasecmp (name, "*>") == 0)
d3763 6
d3776 3
d3783 2
a3784 2
/* Parse a non-negated addition completer returning the number
   (for encoding in instrutions) of the given completer.
d3791 1
a3791 1
pa_parse_nonneg_add_cmpltr (s, isbranch)
d3808 5
a3812 1
      if (strcmp (name, "=") == 0)
d3816 1
a3816 1
      else if (strcmp (name, "<") == 0)
d3820 1
a3820 1
      else if (strcmp (name, "<=") == 0)
d3824 1
a3824 1
      else if (strcasecmp (name, "nuv") == 0)
d3828 1
a3828 1
      else if (strcasecmp (name, "znv") == 0)
d3832 1
a3832 1
      else if (strcasecmp (name, "sv") == 0)
d3836 1
a3836 1
      else if (strcasecmp (name, "od") == 0)
d3860 1
a3860 1
/* Parse a negated addition completer returning the number
d3865 1
a3865 1
   computational instruction).  */
d3868 1
a3868 1
pa_parse_neg_add_cmpltr (s, isbranch)
d3885 1
a3885 5
      if (strcasecmp (name, "tr") == 0)
	{
	  cmpltr = 0;
	}
      else if (strcmp (name, "<>") == 0)
d3889 1
a3889 1
      else if (strcmp (name, ">=") == 0)
d3893 1
a3893 1
      else if (strcmp (name, ">") == 0)
d3897 1
a3897 1
      else if (strcasecmp (name, "uv") == 0)
d3901 1
a3901 1
      else if (strcasecmp (name, "vnz") == 0)
d3905 1
a3905 1
      else if (strcasecmp (name, "nsv") == 0)
d3909 1
a3909 1
      else if (strcasecmp (name, "ev") == 0)
d3933 6
a3938 2
/* Parse a 64 bit wide mode add and branch completer returning the number (for
   encoding in instrutions) of the given completer.  */
d3941 1
a3941 1
pa_parse_addb_64_cmpltr (s)
d3943 1
a3948 1
  int nullify = 0;
d3958 5
a3962 1
      if (strcmp (name, "=") == 0)
d3966 1
a3966 1
      else if (strcmp (name, "<") == 0)
d3970 1
a3970 1
      else if (strcmp (name, "<=") == 0)
d3974 1
a3974 1
      else if (strcasecmp (name, "nuv") == 0)
d3978 1
a3978 1
      else if (strcasecmp (name, "*=") == 0)
d3982 1
a3982 1
      else if (strcasecmp (name, "*<") == 0)
d3986 1
a3986 1
      else if (strcasecmp (name, "*<=") == 0)
a3989 32
      else if (strcmp (name, "tr") == 0)
	{
	  cmpltr = 8;
	}
      else if (strcmp (name, "<>") == 0)
	{
	  cmpltr = 9;
	}
      else if (strcmp (name, ">=") == 0)
	{
	  cmpltr = 10;
	}
      else if (strcmp (name, ">") == 0)
	{
	  cmpltr = 11;
	}
      else if (strcasecmp (name, "uv") == 0)
	{
	  cmpltr = 12;
	}
      else if (strcasecmp (name, "*<>") == 0)
	{
	  cmpltr = 13;
	}
      else if (strcasecmp (name, "*>=") == 0)
	{
	  cmpltr = 14;
	}
      else if (strcasecmp (name, "*>") == 0)
	{
	  cmpltr = 15;
	}
d3992 1
a3992 1
      else if (strcasecmp (name, "n") == 0)
a3994 1
	  nullify = 1;
d4004 1
a4004 1
  if (nullify)
a4009 1
#ifdef OBJ_SOM
a4025 1
#endif
d4036 1
a4036 1
  unsigned int i;
a4037 1
#ifdef OBJ_SOM
a4039 1
#endif
d4048 1
a4048 1
  memset (p, 0, temp_size);
a4116 1
#ifdef OBJ_SOM
a4118 1
#endif
d4163 1
a4163 1
	  as_bad (_("Invalid .CALL argument: %s"), name);
a4203 1
  asymbol *sym;
d4205 1
a4205 1
  int i, reloc;
a4207 10
  if (now_seg != text_section)
    return;

  if (bfd_get_arch_info (stdoutput)->bits_per_address == 32)
    reloc = R_PARISC_DIR32;
  else
    reloc = R_PARISC_SEGREL32;

  save_seg = now_seg;
  save_subseg = now_subseg;
d4211 1
d4215 1
a4215 1
      seg = subseg_new (UNWIND_SECTION_NAME, 0);
d4218 1
a4218 2
			     | SEC_LOAD | SEC_RELOC | SEC_ALLOC | SEC_DATA);
      bfd_set_section_alignment (stdoutput, seg, 2);
d4221 3
a4223 1
  subseg_set (seg, 0);
d4234 1
a4234 2
		(expressionS *) NULL, 0, reloc,
		e_fsel, 32, 0, NULL);
d4249 1
a4249 2
		(expressionS *) NULL, 0, reloc,
		e_fsel, 32, 0, NULL);
a4276 1
#ifdef OBJ_SOM
a4278 1
#endif
d4282 1
a4282 1
    as_bad (_(".callinfo is not within a procedure definition"));
d4302 1
a4302 1
	      as_bad (_("FRAME parameter must be a multiple of 8: %d\n"), temp);
d4321 1
a4321 1
	    as_bad (_("Value for ENTRY_GR must be in the range 3..18\n"));
d4333 1
a4333 1
	    as_bad (_("Value for ENTRY_FR must be in the range 12..21\n"));
d4343 1
a4343 1
	    as_bad (_("Value for ENTRY_SR must be 3\n"));
d4399 1
a4399 1
	  as_bad (_("Invalid .CALLINFO argument: %s"), name);
a4414 1
#ifdef OBJ_SOM
a4417 1
#endif
d4467 1
a4467 1
      symbol_set_frag (symbol, &zero_address_frag);
a4485 1
#ifdef OBJ_SOM
a4487 1
#endif
d4489 1
a4489 2
  as_bad (_("The .ENTER pseudo-op is not supported"));
  demand_empty_rest_of_line ();
a4497 1
#ifdef OBJ_SOM
a4499 1
#endif
d4502 1
a4502 1
    as_bad (_("Misplaced .entry. Ignored."));
d4506 1
a4506 1
	as_bad (_("Missing .callinfo."));
d4554 1
a4554 1
	as_bad (_(".REG must use a label"));
d4556 1
a4556 1
	as_bad (_(".EQU must use a label"));
a4602 1
#ifdef OBJ_SOM
a4604 1
#endif
d4607 1
a4607 1
    as_bad (_(".EXIT must appear within a procedure"));
d4611 1
a4611 1
	as_bad (_("Missing .callinfo"));
d4615 1
a4615 1
	    as_bad (_("No .ENTRY for this .EXIT"));
d4642 1
a4642 1
      as_bad (_("Cannot define export symbol: %s\n"), name);
d4673 1
a4673 1
  obj_symbol_type *symbol = (obj_symbol_type *) symbol_get_bfdsym (symbolP);
d4679 1
a4679 1
      symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
d4692 1
a4692 1
      if (S_IS_FUNCTION (symbolP))
d4695 1
a4695 2
	    as_tsktsk (_("Using ENTRY rather than CODE in export directive for %s"),
		       S_GET_NAME (symbolP));
d4697 1
a4697 1
	  symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d4702 1
a4702 1
	  symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
d4709 1
a4709 2
      symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
      symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
d4715 1
a4715 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d4721 1
a4721 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d4727 1
a4727 1
      symbol_get_bfdsym (symbolP)->flags &= ~BSF_FUNCTION;
d4733 1
a4733 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d4739 1
a4739 1
      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
d4747 1
a4747 1
  obj_set_symbol_type (symbol_get_bfdsym (symbolP), (int) type);
d4768 1
a4768 3
#ifdef OBJ_SOM
	  symbol->tc_data.ap.hppa_arg_reloc |= arg_reloc;
#endif
d4780 1
a4780 3
#ifdef OBJ_SOM
	  symbol->tc_data.ap.hppa_arg_reloc |= arg_reloc;
#endif
a4789 3
#ifdef OBJ_SOM
	  symbol->tc_data.ap.hppa_priv_level = temp;
#endif
d4795 1
a4795 1
	  as_bad (_("Undefined .EXPORT/.IMPORT argument (ignored): %s"), name);
d4840 1
a4840 1
	    symbol_get_bfdsym (symbol)->flags |= BSF_FUNCTION;
d4877 1
a4877 1
      as_warn (_("Missing label name on .LABEL"));
d4882 1
a4882 1
      as_warn (_("extra .LABEL arguments ignored."));
a4893 1
#ifdef OBJ_SOM
a4895 1
#endif
d4897 1
a4897 2
  as_bad (_("The .LEAVE pseudo-op is not supported"));
  demand_empty_rest_of_line ();
d4913 1
a4913 1
	as_warn (_("could not set architecture and machine"));
d4919 1
a4919 13
	as_warn (_("could not set architecture and machine"));
    }
  else if (strncmp (level, "2.0w", 4) == 0)
    {
      input_line_pointer += 4;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 25))
	as_warn (_("could not set architecture and machine"));
    }
  else if (strncmp (level, "2.0", 3) == 0)
    {
      input_line_pointer += 3;
      if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, 20))
	as_warn (_("could not set architecture and machine"));
d4923 1
a4923 1
      as_bad (_("Unrecognized .LEVEL argument\n"));
a4934 1
#ifdef OBJ_SOM
a4936 1
#endif
d4957 1
a4957 1
      as_bad (_("Cannot define static symbol: %s\n"), name);
a4985 1
#ifdef OBJ_SOM
a4987 1
#endif
d4990 1
a4990 1
    as_fatal (_("Nested procedures"));
d5000 1
a5000 1
    as_fatal (_("Cannot allocate unwind descriptor\n"));
d5002 1
a5002 1
  memset (call_info, 0, sizeof (struct call_info));
d5033 1
a5033 1
	    symbol_get_bfdsym (label_symbol->lss_label)->flags |= BSF_FUNCTION;
d5036 1
a5036 1
	  as_bad (_("Missing function name for .PROC (corrupted label chain)"));
a5052 1
#ifdef OBJ_SOM
a5054 1
#endif
d5072 1
a5072 2
	      symbol_get_bfdsym (label_symbol->lss_label)->flags
		|= BSF_FUNCTION;
d5088 1
a5088 1
	    as_bad (_("Missing function name for .PROC (corrupted label chain)"));
d5091 1
a5091 1
	as_bad (_("Missing function name for .PROC"));
d5095 1
a5095 1
    as_bad (_("misplaced .procend"));
d5098 1
a5098 1
    as_bad (_("Missing .callinfo for this procedure"));
d5101 1
a5101 1
    as_bad (_("Missing .EXIT for a .ENTRY"));
a5113 32
/* If VALUE is an exact power of two between zero and 2^31, then
   return log2 (VALUE).  Else return -1.  */

static int
log2 (value)
     int value;
{
  int shift = 0;

  while ((1 << shift) != value && shift < 32)
    shift++;

  if (shift >= 32)
    return -1;
  else
    return shift;
}


#ifdef OBJ_SOM
/* Check to make sure we have a valid space and subspace.  */

static void
pa_check_current_space_and_subspace ()
{
  if (current_space == NULL)
    as_fatal (_("Not in a space.\n"));

  if (current_subspace == NULL)
    as_fatal (_("Not in a subspace.\n"));
}

d5201 1
a5201 1
		  as_bad (_("Invalid .SPACE argument"));
d5249 1
a5249 1
      as_bad (_("Can\'t change spaces within a procedure definition. Ignored"));
d5376 1
a5376 1
    as_warn (_("Undefined space: '%s' Assuming space number = 0."), name);
d5382 18
d5410 1
a5410 1
  char *name, *ss_name, c;
d5418 1
a5418 1
    as_fatal (_("Must be in a space before changing or declaring subspaces.\n"));
d5422 1
a5422 1
      as_bad (_("Can\'t change subspaces within a procedure definition. Ignored"));
d5444 1
d5458 1
a5458 1
	    as_warn (_("Parameters of an existing subspace can\'t be modified"));
d5481 2
d5511 1
a5511 1
		      as_bad (_("Alignment must be a power of 2"));
d5553 1
a5553 1
		as_bad (_("FIRST not supported as a .SUBSPACE argument"));
d5555 1
a5555 1
		as_bad (_("Invalid .SUBSPACE argument"));
d5591 8
d5655 4
a5658 1
      name = pa_def_spaces[i].name;
d5678 10
a5687 2
      name = pa_def_subspaces[i].name;
      subsegment = 0;
d5696 1
a5696 1
      if (!strcmp (pa_def_subspaces[i].name, "$CODE$"))
d5706 1
a5706 1
      else if (!strcmp (pa_def_subspaces[i].name, "$DATA$"))
d5717 1
a5717 1
      else if (!strcmp (pa_def_subspaces[i].name, "$BSS$"))
d5724 1
a5724 1
      else if (!strcmp (pa_def_subspaces[i].name, "$LIT$"))
d5733 2
a5734 1
      else if (!strcmp (pa_def_subspaces[i].name, "$MILLICODE$"))
d5743 1
a5743 1
      else if (!strcmp (pa_def_subspaces[i].name, "$UNWIND$"))
d5758 1
a5758 1
	  as_fatal (_("Internal error: Unable to find containing space for %s."),
d5799 1
a5799 1
    as_fatal (_("Out of memory: could not allocate new space chain entry: %s\n"),
d5885 1
a5885 1
    as_fatal (_("Out of memory: could not allocate new subspace chain entry: %s\n"), name);
d5894 1
a5894 1
  chain_entry->ssd_subseg = 0;
d6097 1
a6097 1
      if (SPACE_SPNUM (space_chain) == (unsigned int) number)
d6113 1
d6122 1
a6134 1
#endif
a6144 1
#ifdef OBJ_SOM
a6146 1
#endif
a6245 14
#ifdef OBJ_SOM

/* Handle a .COMPILER pseudo-op.  */

static void
pa_compiler (unused)
     int unused;
{
  obj_som_compiler (0);
  pa_undefine_label ();
}

#endif

a6272 1
#ifdef OBJ_SOM
a6275 1
#endif
a6295 1
#ifdef OBJ_SOM
a6297 1
#endif
a6308 1
#ifdef OBJ_SOM
a6310 1
#endif
a6321 1
#ifdef OBJ_SOM
a6323 1
#endif
a6334 1
#ifdef OBJ_SOM
a6337 1
#endif
d6362 1
a6362 1
   reductions make life a living hell for object file editors.
d6382 1
a6382 1
     the fixup will occur in a CODE subspace.
d6392 1
a6392 1
      symbol_mark_used_in_reloc (fixp->fx_subsy);
d6414 1
a6414 5
  if (fixp->fx_addsy && S_IS_EXTERNAL (fixp->fx_addsy))
    return 0;

  /* Reject absolute calls (jumps).  */
  if (hppa_fix->fx_r_type == R_HPPA_ABS_CALL)
d6418 2
a6419 1
  if (fixp->fx_addsy == 0 || ! S_IS_FUNCTION (fixp->fx_addsy))
a6450 1
#ifdef OBJ_SOM
d6455 4
a6458 3
      && (arg_reloc_stub_needed ((long) ((obj_symbol_type *)
	symbol_get_bfdsym (fixp->fx_addsy))->tc_data.ap.hppa_arg_reloc,
	hppa_fixp->fx_arg_reloc)))
a6459 1
#endif
a6466 2
  if (fixp->fx_r_type == R_HPPA_ABS_CALL)
    return 1;
d6514 1
a6514 1
	  S_CLEAR_EXTERNAL (symbolP);
d6521 1
a6521 1
	as_bad (_("Symbol '%s' could not be created."), name);
d6525 1
a6525 1
    as_bad (_("No memory for symbol name."));
d6544 1
a6544 2
	= ((elf_symbol_type *)
	   symbol_get_bfdsym (call_info_pointer->start_symbol));
a6548 8
}
#endif

#ifdef OBJ_ELF
pa_end_of_source ()
{
  if (debug_type == DEBUG_DWARF2)
    dwarf2_finish ();
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d22 1
d33 1
d47 2
d52 1
a52 1

d54 1
a54 1
typedef enum elf_hppa_reloc_type reloc_type;
a57 2
#define symbol_arg_reloc_info(sym)\
  (((obj_symbol_type *) symbol_get_bfdsym (sym))->tc_data.hppa_arg_reloc)
d59 1
a59 1
#if TARGET_ARCH_SIZE == 64
d72 1
a72 1
#endif /* OBJ_ELF */
a92 2
#define symbol_arg_reloc_info(sym)\
  (((obj_symbol_type *) symbol_get_bfdsym (sym))->tc_data.ap.hppa_arg_reloc)
d98 1
a106 7
#endif /* OBJ_SOM */

#if TARGET_ARCH_SIZE == 64
#define DEFAULT_LEVEL 25
#else
#define DEFAULT_LEVEL 10
#endif
a135 25
/* We can't rely on compilers placing bitfields in any particular
   place, so use these macros when dumping unwind descriptors to
   object files.  */
#define UNWIND_LOW32(U) \
  (((U)->cannot_unwind << 31)		\
   | ((U)->millicode << 30)		\
   | ((U)->millicode_save_rest << 29)	\
   | ((U)->region_desc << 27)		\
   | ((U)->save_sr << 25)		\
   | ((U)->entry_fr << 21)		\
   | ((U)->entry_gr << 16)		\
   | ((U)->args_stored << 15)		\
   | ((U)->call_fr << 10)		\
   | ((U)->call_gr << 5)		\
   | ((U)->save_sp << 4)		\
   | ((U)->save_rp << 3)		\
   | ((U)->save_rp_in_frame << 2)	\
   | ((U)->extn_ptr_defined << 1)	\
   | ((U)->cleanup_defined << 0))

#define UNWIND_HIGH32(U) \
  (((U)->hpe_interrupt_marker << 31)	\
   | ((U)->hpux_interrupt_marker << 30)	\
   | ((U)->frame_size << 0))

d222 1
a222 1
    unsigned int arg_reloc;
d233 1
d250 17
a266 1
   +--------------+--------------+  */
d441 1
a441 1
    unsigned int fx_arg_reloc;
a476 5
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
static void pa_text PARAMS ((int));
static void pa_data PARAMS ((int));
static void pa_comm PARAMS ((int));
#endif
d479 1
d485 1
d507 2
d526 3
a528 2
static int need_pa11_opcode PARAMS ((void));
static int pa_parse_number PARAMS ((char **, int));
a530 1
static int log2 PARAMS ((int));
d562 1
a562 1
				  offsetT, expressionS *, int,
d565 1
a565 1
				  int, unsigned int, int));
d571 1
a578 2
static void pa_vtable_entry PARAMS ((int));
static void pa_vtable_inherit  PARAMS ((int));
d607 4
d631 1
a631 4
#if defined (OBJ_ELF) && defined (TE_LINUX)
  {"code", obj_elf_text, 0},
#else
  {"code", pa_text, 0},
a632 1
#endif
a636 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
a637 1
#endif
a641 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
a642 1
#endif
d649 1
a649 1
  {"file", dwarf2_directive_file, 0 },
d661 1
a661 1
  {"loc", dwarf2_directive_loc, 0 },
a686 1
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
a687 1
#endif
a688 4
#ifdef OBJ_ELF
  {"vtable_entry", pa_vtable_entry, 0},
  {"vtable_inherit", pa_vtable_inherit, 0},
#endif
d701 1
a701 1
   Also note that C style comments will always work.  */
a703 4
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = ";";

d734 1
a734 1
/* Handle on structure which keep track of the last symbol
a746 9
/* pa_parse_number returns values in `pa_number'.  Mostly
   pa_parse_number is used to return a register number, with floating
   point registers being numbered from FP_REG_BASE upwards.
   The bit specified with FP_REG_RSEL is set if the floating point
   register has a `r' suffix.  */
#define FP_REG_BASE 64
#define FP_REG_RSEL 128
static int pa_number;

d779 1
a779 1
   The table is sorted. Suitable for searching by a binary search.  */
d783 139
a921 139
  {"%arg0",  26},
  {"%arg1",  25},
  {"%arg2",  24},
  {"%arg3",  23},
  {"%cr0",    0},
  {"%cr10",  10},
  {"%cr11",  11},
  {"%cr12",  12},
  {"%cr13",  13},
  {"%cr14",  14},
  {"%cr15",  15},
  {"%cr16",  16},
  {"%cr17",  17},
  {"%cr18",  18},
  {"%cr19",  19},
  {"%cr20",  20},
  {"%cr21",  21},
  {"%cr22",  22},
  {"%cr23",  23},
  {"%cr24",  24},
  {"%cr25",  25},
  {"%cr26",  26},
  {"%cr27",  27},
  {"%cr28",  28},
  {"%cr29",  29},
  {"%cr30",  30},
  {"%cr31",  31},
  {"%cr8",    8},
  {"%cr9",    9},
  {"%dp",    27},
  {"%eiem",  15},
  {"%eirr",  23},
  {"%fr0",    0 + FP_REG_BASE},
  {"%fr0l",   0 + FP_REG_BASE},
  {"%fr0r",   0 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr1",    1 + FP_REG_BASE},
  {"%fr10",  10 + FP_REG_BASE},
  {"%fr10l", 10 + FP_REG_BASE},
  {"%fr10r", 10 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr11",  11 + FP_REG_BASE},
  {"%fr11l", 11 + FP_REG_BASE},
  {"%fr11r", 11 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr12",  12 + FP_REG_BASE},
  {"%fr12l", 12 + FP_REG_BASE},
  {"%fr12r", 12 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr13",  13 + FP_REG_BASE},
  {"%fr13l", 13 + FP_REG_BASE},
  {"%fr13r", 13 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr14",  14 + FP_REG_BASE},
  {"%fr14l", 14 + FP_REG_BASE},
  {"%fr14r", 14 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr15",  15 + FP_REG_BASE},
  {"%fr15l", 15 + FP_REG_BASE},
  {"%fr15r", 15 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr16",  16 + FP_REG_BASE},
  {"%fr16l", 16 + FP_REG_BASE},
  {"%fr16r", 16 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr17",  17 + FP_REG_BASE},
  {"%fr17l", 17 + FP_REG_BASE},
  {"%fr17r", 17 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr18",  18 + FP_REG_BASE},
  {"%fr18l", 18 + FP_REG_BASE},
  {"%fr18r", 18 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr19",  19 + FP_REG_BASE},
  {"%fr19l", 19 + FP_REG_BASE},
  {"%fr19r", 19 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr1l",   1 + FP_REG_BASE},
  {"%fr1r",   1 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr2",    2 + FP_REG_BASE},
  {"%fr20",  20 + FP_REG_BASE},
  {"%fr20l", 20 + FP_REG_BASE},
  {"%fr20r", 20 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr21",  21 + FP_REG_BASE},
  {"%fr21l", 21 + FP_REG_BASE},
  {"%fr21r", 21 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr22",  22 + FP_REG_BASE},
  {"%fr22l", 22 + FP_REG_BASE},
  {"%fr22r", 22 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr23",  23 + FP_REG_BASE},
  {"%fr23l", 23 + FP_REG_BASE},
  {"%fr23r", 23 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr24",  24 + FP_REG_BASE},
  {"%fr24l", 24 + FP_REG_BASE},
  {"%fr24r", 24 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr25",  25 + FP_REG_BASE},
  {"%fr25l", 25 + FP_REG_BASE},
  {"%fr25r", 25 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr26",  26 + FP_REG_BASE},
  {"%fr26l", 26 + FP_REG_BASE},
  {"%fr26r", 26 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr27",  27 + FP_REG_BASE},
  {"%fr27l", 27 + FP_REG_BASE},
  {"%fr27r", 27 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr28",  28 + FP_REG_BASE},
  {"%fr28l", 28 + FP_REG_BASE},
  {"%fr28r", 28 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr29",  29 + FP_REG_BASE},
  {"%fr29l", 29 + FP_REG_BASE},
  {"%fr29r", 29 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr2l",   2 + FP_REG_BASE},
  {"%fr2r",   2 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr3",    3 + FP_REG_BASE},
  {"%fr30",  30 + FP_REG_BASE},
  {"%fr30l", 30 + FP_REG_BASE},
  {"%fr30r", 30 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr31",  31 + FP_REG_BASE},
  {"%fr31l", 31 + FP_REG_BASE},
  {"%fr31r", 31 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr3l",   3 + FP_REG_BASE},
  {"%fr3r",   3 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr4",    4 + FP_REG_BASE},
  {"%fr4l",   4 + FP_REG_BASE},
  {"%fr4r",   4 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr5",    5 + FP_REG_BASE},
  {"%fr5l",   5 + FP_REG_BASE},
  {"%fr5r",   5 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr6",    6 + FP_REG_BASE},
  {"%fr6l",   6 + FP_REG_BASE},
  {"%fr6r",   6 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr7",    7 + FP_REG_BASE},
  {"%fr7l",   7 + FP_REG_BASE},
  {"%fr7r",   7 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr8",    8 + FP_REG_BASE},
  {"%fr8l",   8 + FP_REG_BASE},
  {"%fr8r",   8 + FP_REG_BASE + FP_REG_RSEL},
  {"%fr9",    9 + FP_REG_BASE},
  {"%fr9l",   9 + FP_REG_BASE},
  {"%fr9r",   9 + FP_REG_BASE + FP_REG_RSEL},
  {"%hta",   25},
  {"%iir",   19},
  {"%ior",   21},
  {"%ipsw",  22},
  {"%isr",   20},
  {"%itmr",  16},
  {"%iva",   14},
  {"%pcoq",  18},
  {"%pcsq",  17},
  {"%pidr1",  8},
  {"%pidr2",  9},
d924 55
a978 55
  {"%ppda",  24},
  {"%r0",     0},
  {"%r1",     1},
  {"%r10",   10},
  {"%r11",   11},
  {"%r12",   12},
  {"%r13",   13},
  {"%r14",   14},
  {"%r15",   15},
  {"%r16",   16},
  {"%r17",   17},
  {"%r18",   18},
  {"%r19",   19},
  {"%r2",     2},
  {"%r20",   20},
  {"%r21",   21},
  {"%r22",   22},
  {"%r23",   23},
  {"%r24",   24},
  {"%r25",   25},
  {"%r26",   26},
  {"%r27",   27},
  {"%r28",   28},
  {"%r29",   29},
  {"%r3",     3},
  {"%r30",   30},
  {"%r31",   31},
  {"%r4",     4},
  {"%r5",     5},
  {"%r6",     6},
  {"%r7",     7},
  {"%r8",     8},
  {"%r9",     9},
  {"%rctr",   0},
  {"%ret0",  28},
  {"%ret1",  29},
  {"%rp",     2},
  {"%sar",   11},
  {"%sp",    30},
  {"%sr0",    0},
  {"%sr1",    1},
  {"%sr2",    2},
  {"%sr3",    3},
  {"%sr4",    4},
  {"%sr5",    5},
  {"%sr6",    6},
  {"%sr7",    7},
  {"%tr0",   24},
  {"%tr1",   25},
  {"%tr2",   26},
  {"%tr3",   27},
  {"%tr4",   28},
  {"%tr5",   29},
  {"%tr6",   30},
  {"%tr7",   31}
a1116 14
/* Simple alignment checking for FIELD againt ALIGN (a power of two).
   IGNORE is used to suppress the error message.  */

#define CHECK_ALIGN(FIELD, ALIGN, IGNORE) \
  { \
    if ((FIELD) & ((ALIGN) - 1)) \
      { \
	if (! IGNORE) \
          as_bad (_("Field not properly aligned [%d] (%d)."), (ALIGN), \
		  (int) (FIELD));\
        break; \
      } \
  }

d1238 1
d1253 1
a1253 1
     offsetT offset;
d1259 2
a1260 2
     unsigned int arg_reloc;
     int unwind_bits ATTRIBUTE_UNUSED;
d1279 1
a1279 1
    new_fix->fx_offset = unwind_bits;
d1284 1
a1284 1
     it now so as not to confuse write.c.  Ditto for $PIC_pcrel$0.  */
d1286 1
a1286 2
      && (strcmp (S_GET_NAME (new_fix->fx_subsy), "$global$") == 0
	  || strcmp (S_GET_NAME (new_fix->fx_subsy), "$PIC_pcrel$0") == 0))
d1322 1
a1322 4
    {
      as_warn (_("Invalid field selector.  Assuming F%%."));
      hppa_field_selector = e_fsel;
    }
d1326 1
a1326 1
		hppa_field_selector, size * 8, 0, 0);
d1346 1
a1346 1
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_hppa, DEFAULT_LEVEL))
d1398 1
a1398 1
  /* Force the symbol to be converted to a real symbol.  */
d1436 1
a1436 2
		  char *where;
		  unsigned int u;
a1437 2
		  where = frag_more (0);
		  u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
d1440 2
a1441 1
				0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
d1458 1
a1458 1
  /* Output the opcode.  */
d1466 1
a1466 1
		  the_insn.format, the_insn.arg_reloc, 0);
d1469 14
a1482 1
  dwarf2_emit_insn (4);
d1617 2
a1618 1
	      if (!pa_parse_number (&s, 0))
d1620 1
a1620 1
	      num = pa_number;
d1645 2
a1646 1
	      if (!pa_parse_number (&s, 0))
d1648 1
a1648 1
	      num = pa_number;
d1654 2
a1655 1
	      if (!pa_parse_number (&s, 0))
d1657 1
a1657 1
	      num = pa_number;
d1663 2
a1664 1
	      if (!pa_parse_number (&s, 0))
d1666 1
a1666 1
	      num = pa_number;
d1689 1
a1689 1
	      num = low_sign_unext (num, 5);
d1700 2
a1701 2
	      CHECK_FIELD (num, 15, -16, strict);
	      num = low_sign_unext (num, 5);
d1710 2
a1711 2
	      CHECK_FIELD (num, 31, 0, strict);
	      INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d1733 2
a1734 1
	      if (!pa_parse_number (&s, 0))
d1736 1
a1736 1
	      num = pa_number;
d1742 2
a1743 1
	      if (!pa_parse_number (&s, 0))
d1745 1
a1745 1
	      num = pa_number;
d1747 2
a1748 2
	      opcode |= re_assemble_3 (num);
	      continue;
d1852 4
a1855 4
			/* Stash the ma/mb flag temporarily in the
			   instruction.  We will use (and remove it)
			   later when handling 'J', 'K', '<' & '>'.  */
			opcode |= a;
d1928 1
a1928 1
		/* Handle load ordering completer.  */
d2388 1
a2388 1
			/* Negated condition requires an opcode change.  */
d2409 1
a2409 1
			    /* Negated condition requires an opcode change.  */
d2562 1
a2562 1
			    /* Negated condition requires an opcode change.  */
d2574 1
a2574 1
			/* Negated condition requires an opcode change.  */
d2578 1
a2578 1
		      /* Not a 64 bit cond.  Give 32 bit a chance.  */
d2587 1
a2587 1
		      /* Not a 64 bit cond.  Give 32 bit a chance.  */
d2611 1
d2619 1
d2680 1
d2900 1
a2900 1
		  num = low_sign_unext (num, 11);
d2922 1
a2922 1
		  int mb;
d2924 1
a2924 1
		  /* XXX the completer stored away tidbits of information
d2928 3
a2930 2
		  mb = opcode & 1;
		  opcode -= mb;
d2932 1
a2932 1
		  if (mb != (num < 0))
d2935 1
a2935 1
		  num = low_sign_unext (num, 14);
d2938 4
a2941 1
	      break;
d2950 1
a2950 1
		  int mb;
d2952 7
a2958 2
		  mb = opcode & 1;
		  opcode -= mb;
d2960 1
a2960 1
		  if (mb == (num < 0))
d2965 5
a2969 2
		  num = low_sign_unext (num, 14);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d2971 1
a2971 8
	      break;

	    /* Handle a 16 bit immediate at 31.  */
	    case '<':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
d2973 1
a2973 10
		  int mb;

		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb != (num < 0))
		    break;
		  CHECK_FIELD (num, 32767, -32768, 0);
		  num = re_assemble_16 (num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
a2974 10
	      break;

	    /* Handle a 16 bit immediate at 31.  */
	    case '>':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  int mb;
d2976 1
a2976 14
		  mb = opcode & 1;
		  opcode -= mb;
		  num = evaluate_absolute (&the_insn);
		  if (mb == (num < 0))
		    break;
		  if (num % 4)
		    break;
		  CHECK_FIELD (num, 32767, -32768, 0);
		  num = re_assemble_16 (num);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
		}
	      break;

	    /* Handle 14 bit immediate, shifted left three times.  */
d3044 1
a3044 1
		  num = low_sign_unext (num, 14);
d3068 2
a3069 2
		  opcode |= re_assemble_21 (num);
		  continue;
a3082 77
	    /* Handle a 16 bit immediate at 31 (PA 2.0 wide mode only).  */
	    case 'l':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a word-aligned 16-bit imm. at 31 (PA2.0 wide).  */
	    case 'y':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  CHECK_ALIGN (num, 4, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

	    /* Handle a dword-aligned 16-bit imm. at 31 (PA2.0 wide).  */
	    case '&':
	      the_insn.field_selector = pa_chk_field_selector (&s);
	      get_expression (s);
	      s = expr_end;
	      if (the_insn.exp.X_op == O_constant)
		{
		  num = evaluate_absolute (&the_insn);
		  CHECK_FIELD (num, 32767, -32768, 0);
		  CHECK_ALIGN (num, 8, 0);
		  opcode |= re_assemble_16 (num);
		  continue;
		}
	      else
		{
		  /* ??? Is this valid for wide mode?  */
		  if (is_DP_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_GOTOFF;
		  else if (is_PC_relative (the_insn.exp))
		    the_insn.reloc = R_HPPA_PCREL_CALL;
		  else
		    the_insn.reloc = R_HPPA;
		  the_insn.format = 14;
		  continue;
		}

d3089 1
a3089 3
	      if (!the_insn.exp.X_add_symbol
		  || !strcmp (S_GET_NAME (the_insn.exp.X_add_symbol),
			      "L$0\001"))
d3091 2
d3099 4
a3102 5
		  if (the_insn.exp.X_add_symbol)
		    num -= 8;
		  CHECK_FIELD (num, 8191, -8192, 0);
		  opcode |= re_assemble_12 (num >> 2);
		  continue;
d3124 2
d3132 2
d3136 5
a3140 3
		  CHECK_FIELD (num, 262143, -262144, 0);
		  opcode |= re_assemble_17 (num >> 2);
		  continue;
d3161 2
d3169 2
d3173 7
a3179 2
		  CHECK_FIELD (num, 8388607, -8388608, 0);
		  opcode |= re_assemble_22 (num >> 2);
d3200 2
d3208 2
d3212 5
a3216 3
		  CHECK_FIELD (num, 262143, -262144, 0);
		  opcode |= re_assemble_17 (num >> 2);
		  continue;
d3353 2
d3383 1
a3383 1
	      CHECK_FIELD (num, 67108863, 0, strict);
d3578 2
a3579 1
		  if (!pa_parse_number (&s, 3))
d3581 1
a3581 1
		  num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
d3588 4
a3591 1
		    if (!pa_parse_number (&s, 1))
d3593 3
a3595 3
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num;
d3600 1
a3600 1
		    if (need_pa11_opcode ()
d3604 1
a3604 2
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 6 : 0);
		    continue;
d3610 4
a3613 1
		    if (!pa_parse_number (&s, 1))
d3615 4
a3618 4
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 21;
		    if (need_pa11_opcode ())
d3620 1
a3620 1
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 7 : 0);
d3630 4
a3633 1
		    if (!pa_parse_number (&s, 1))
d3635 4
a3638 4
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 21;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 7 : 0);
d3645 4
a3648 1
		    if (!pa_parse_number (&s, 1))
d3650 4
a3653 4
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    if (need_pa11_opcode ())
d3655 1
a3655 1
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 12 : 0);
d3664 4
a3667 1
		    if (!pa_parse_number (&s, 1))
d3669 4
a3672 4
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 12 : 0);
d3679 4
a3682 1
		    if (!pa_parse_number (&s, 1))
d3684 5
a3688 5
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= (num & 0x1c) << 11;
		    opcode |= (num & 0x03) << 9;
		    opcode |= (pa_number & FP_REG_RSEL ? 1 << 8 : 0);
d3695 4
a3698 1
		    if (!pa_parse_number (&s, 1))
d3700 2
a3701 2
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
d3704 1
a3704 1
			if (num < 16)
d3709 3
a3711 2
			num &= 0xF;
			num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
d3713 1
a3713 1
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 21);
d3719 4
a3722 1
		    if (!pa_parse_number (&s, 1))
d3724 2
a3725 2
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
d3728 1
a3728 1
		        if (num < 16)
d3730 2
a3731 2
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
d3733 2
a3734 2
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
d3736 1
a3736 1
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 16);
d3742 4
a3745 1
		    if (!pa_parse_number (&s, 1))
d3747 2
a3748 2
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
d3751 1
a3751 1
		        if (num < 16)
d3753 2
a3754 2
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
d3756 2
a3757 2
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
d3759 1
a3759 1
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 0);
d3765 4
a3768 1
		    if (!pa_parse_number (&s, 1))
d3770 2
a3771 2
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
d3774 1
a3774 1
		        if (num < 16)
d3776 2
a3777 2
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
d3779 2
a3780 2
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
d3782 1
a3782 1
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 6);
d3788 4
a3791 1
		    if (!pa_parse_number (&s, 1))
d3793 2
a3794 2
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
d3797 1
a3797 1
		        if (num < 16)
d3799 2
a3800 2
			    as_bad  (_("Invalid register for single precision fmpyadd or fmpysub"));
			    break;
d3802 2
a3803 2
		        num &= 0xF;
		        num |= (pa_number & FP_REG_RSEL ? 1 << 4 : 0);
d3805 1
a3805 1
		    INSERT_FIELD_AND_CONTINUE (opcode, num, 11);
a3808 1
		case 'E':
d3811 3
a3813 1
		    if (!pa_parse_number (&s, 1))
d3815 4
a3818 4
		    num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		    CHECK_FIELD (num, 31, 0, 0);
		    opcode |= num << 16;
		    if (need_pa11_opcode ())
d3820 1
a3820 1
			opcode |= (pa_number & FP_REG_RSEL ? 1 << 1 : 0);
a3823 9

		/* Float target register (PA 2.0 wide).  */
		case 'x':
		  if (!pa_parse_number (&s, 3))
		    break;
		  num = (pa_number & ~FP_REG_RSEL) - FP_REG_BASE;
		  CHECK_FIELD (num, 31, 0, 0);
		  INSERT_FIELD_AND_CONTINUE (opcode, num, 16);

d3939 1
d3942 1
a3942 2
  reloc_type **codes;
  reloc_type code;
a3948 1

d3956 1
a3956 1
  codes = hppa_gen_reloc_type (stdoutput,
d3964 1
a3964 4
    {
      as_bad (_("Cannot handle fixup at %s:%d"), fixp->fx_file, fixp->fx_line);
      abort ();
    }
d3984 8
d4003 3
a4005 2
	     (static link required).  This adjustment is done in
	     bfd/elf32-hppa.c:elf32_hppa_relocate_section.
d4013 1
a4013 1
#ifdef ELF_ARG_RELOC
d4017 4
a4020 6
	case R_PARISC_DIR17R:
	case R_PARISC_DIR17F:
	case R_PARISC_PCREL21L:
	case R_PARISC_DIR21L:
	  reloc->addend = HPPA_R_ADDEND (hppa_fixp->fx_arg_reloc,
					 fixp->fx_offset);
a4021 8
#endif

	case R_PARISC_DIR32:
	  /* Facilitate hand-crafted unwind info.  */
	  if (strcmp (section->name, UNWIND_SECTION_NAME) == 0)
	    code = R_PARISC_SEGREL32;
	  /* Fall thru */

a4025 8

      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->howto = bfd_reloc_type_lookup (stdoutput,
					    (bfd_reloc_code_real_type) code);
      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

      assert (reloc->howto && (unsigned int) code == reloc->howto->type);
d4037 1
a4037 3
      relocs[i]->howto =
	bfd_reloc_type_lookup (stdoutput,
			       (bfd_reloc_code_real_type) code);
d4048 1
a4048 3
	  relocs[0]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[0]);
d4053 1
a4053 3
	  relocs[1]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[1]);
d4058 1
a4058 3
	  relocs[2]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[2]);
d4062 1
a4062 3
	  relocs[3]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[3]);
d4066 1
a4066 3
	  relocs[4]->howto =
	    bfd_reloc_type_lookup (stdoutput,
				   (bfd_reloc_code_real_type) *codes[4]);
d4132 2
a4133 2
     register bfd *abfd ATTRIBUTE_UNUSED;
     register asection *sec ATTRIBUTE_UNUSED;
d4161 1
a4161 1
/* Round up a section size to the appropriate boundary.  */
d4178 1
a4178 1
     asection *segment ATTRIBUTE_UNUSED;
d4190 1
a4190 14
#ifdef OBJ_ELF
# ifdef WARN_COMMENTS
const char *md_shortopts = "Vc";
# else
const char *md_shortopts = "V";
# endif
#else
# ifdef WARN_COMMENTS
const char *md_shortopts = "c";
# else
const char *md_shortopts = "";
# endif
#endif

a4191 3
#ifdef WARN_COMMENTS
  {"warn-comment", no_argument, NULL, 'c'},
#endif
d4194 1
a4194 1
size_t md_longopts_size = sizeof (md_longopts);
d4198 2
a4199 2
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d4201 1
a4201 18
  switch (c)
    {
    default:
      return 0;

#ifdef OBJ_ELF
    case 'V':
      print_version_id ();
      break;
#endif
#ifdef WARN_COMMENTS
    case 'c':
      warn_comment = 1;
      break;
#endif
    }

  return 1;
d4206 1
a4206 1
     FILE *stream ATTRIBUTE_UNUSED;
a4207 8
#ifdef OBJ_ELF
  fprintf (stream, _("\
  -Q                      ignored\n"));
#endif
#ifdef WARN_COMMENTS
  fprintf (stream, _("\
  -c                      print a warning if a comment is found\n"));
#endif
d4214 1
a4214 1
     char *name ATTRIBUTE_UNUSED;
a4218 9
#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
#define nonzero_dibits(x) \
  ((x) | (((x) & 0x55555555) << 1) | (((x) & 0xAAAAAAAA) >> 1))
#define arg_reloc_stub_needed(CALLER, CALLEE) \
  (((CALLER) ^ (CALLEE)) & nonzero_dibits (CALLER) & nonzero_dibits (CALLEE))
#else
#define arg_reloc_stub_needed(CALLER, CALLEE) 0
#endif

d4226 1
a4226 1
  unsigned char *buf;
d4228 2
a4229 2
  offsetT new_val;
  int insn, val, fmt;
d4231 1
a4251 98
#ifdef OBJ_ELF
  if (fixP->fx_r_type == (int) R_PARISC_GNU_VTENTRY
      || fixP->fx_r_type == (int) R_PARISC_GNU_VTINHERIT)
    return 1;
#endif

  /* There should have been an HPPA specific fixup associated
     with the GAS fixup.  */
  hppa_fixP = (struct hppa_fix_struct *) fixP->tc_fix_data;
  if (hppa_fixP == NULL)
    {
      printf (_("no hppa_fixup entry for fixup type 0x%x at %s:%d"),
	      fixP->fx_r_type, fixP->fx_file, fixP->fx_line);
      return 0;
    }

  buf = fixP->fx_frag->fr_literal + fixP->fx_where;
  insn = bfd_get_32 (stdoutput, buf);
  fmt = bfd_hppa_insn2fmt (stdoutput, insn);

  /* If there is a symbol associated with this fixup, then it's something
     which will need a SOM relocation (except for some PC-relative relocs).
     In such cases we should treat the "val" or "addend" as zero since it
     will be added in as needed from fx_offset in tc_gen_reloc.  */
  if ((fixP->fx_addsy != NULL
       || fixP->fx_r_type == (int) R_HPPA_NONE)
#ifdef OBJ_SOM
      && fmt != 32
#endif
      )
    new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
#ifdef OBJ_SOM
  /* These field selectors imply that we do not want an addend.  */
  else if (hppa_fixP->fx_r_field == e_psel
	   || hppa_fixP->fx_r_field == e_rpsel
	   || hppa_fixP->fx_r_field == e_lpsel
	   || hppa_fixP->fx_r_field == e_tsel
	   || hppa_fixP->fx_r_field == e_rtsel
	   || hppa_fixP->fx_r_field == e_ltsel)
    new_val = ((fmt == 12 || fmt == 17 || fmt == 22) ? 8 : 0);
  /* This is truly disgusting.  The machine independent code blindly
     adds in the value of the symbol being relocated against.  Damn!  */
  else if (fmt == 32
	   && fixP->fx_addsy != NULL
	   && S_GET_SEGMENT (fixP->fx_addsy) != bfd_com_section_ptr)
    new_val = hppa_field_adjust (*valp - S_GET_VALUE (fixP->fx_addsy),
				 0, hppa_fixP->fx_r_field);
#endif
  else
    new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);

  /* Handle pc-relative exceptions from above.  */
  if ((fmt == 12 || fmt == 17 || fmt == 22)
      && fixP->fx_addsy
      && fixP->fx_pcrel
      && !arg_reloc_stub_needed (symbol_arg_reloc_info (fixP->fx_addsy),
				 hppa_fixP->fx_arg_reloc)
#ifdef OBJ_ELF
      && (*valp - 8 + 8192 < 16384
	  || (fmt == 17 && *valp - 8 + 262144 < 524288)
	  || (fmt == 22 && *valp - 8 + 8388608 < 16777216))
#endif
#ifdef OBJ_SOM
      && (*valp - 8 + 262144 < 524288
	  || (fmt == 22 && *valp - 8 + 8388608 < 16777216))
#endif
      && !S_IS_EXTERNAL (fixP->fx_addsy)
      && !S_IS_WEAK (fixP->fx_addsy)
      && S_GET_SEGMENT (fixP->fx_addsy) == hppa_fixP->segment
      && !(fixP->fx_subsy
	   && S_GET_SEGMENT (fixP->fx_subsy) != hppa_fixP->segment))
    {
      new_val = hppa_field_adjust (*valp, 0, hppa_fixP->fx_r_field);
    }

  switch (fmt)
    {
    case 10:
      CHECK_FIELD (new_val, 8191, -8192, 0);
      val = new_val;

      insn = (insn & ~ 0x3ff1) | (((val & 0x1ff8) << 1)
				  | ((val & 0x2000) >> 13));
      break;
    case -11:
      CHECK_FIELD (new_val, 8191, -8192, 0);
      val = new_val;

      insn = (insn & ~ 0x3ff9) | (((val & 0x1ffc) << 1)
				  | ((val & 0x2000) >> 13));
      break;
      /* Handle all opcodes with the 'j' operand type.  */
    case 14:
      CHECK_FIELD (new_val, 8191, -8192, 0);
      val = new_val;

      insn = ((insn & ~ 0x3fff) | low_sign_unext (val, 14));
      break;
d4253 6
a4258 4
      /* Handle all opcodes with the 'k' operand type.  */
    case 21:
      CHECK_FIELD (new_val, 1048575, -1048576, 0);
      val = new_val;
d4260 30
a4289 2
      insn = (insn & ~ 0x1fffff) | re_assemble_21 (val);
      break;
d4291 32
a4322 4
      /* Handle all the opcodes with the 'i' operand type.  */
    case 11:
      CHECK_FIELD (new_val, 1023, -1024, 0);
      val = new_val;
d4324 11
a4334 2
      insn = (insn & ~ 0x7ff) | low_sign_unext (val, 11);
      break;
d4336 11
a4346 4
      /* Handle all the opcodes with the 'w' operand type.  */
    case 12:
      CHECK_FIELD (new_val - 8, 8191, -8192, 0);
      val = new_val - 8;
d4348 9
a4356 2
      insn = (insn & ~ 0x1ffd) | re_assemble_12 (val >> 2);
      break;
d4358 3
a4360 4
      /* Handle some of the opcodes with the 'W' operand type.  */
    case 17:
      {
	offsetT distance = *valp;
d4362 4
a4365 5
	/* If this is an absolute branch (ie no link) with an out of
	   range target, then we want to complain.  */
	if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
	    && (insn & 0xffe00000) == 0xe8000000)
	  CHECK_FIELD (distance - 8, 262143, -262144, 0);
d4367 1
a4367 2
	CHECK_FIELD (new_val - 8, 262143, -262144, 0);
	val = new_val - 8;
d4369 16
a4384 3
	insn = (insn & ~ 0x1f1ffd) | re_assemble_17 (val >> 2);
	break;
      }
d4386 3
a4388 3
    case 22:
      {
	offsetT distance = *valp;
d4390 1
a4390 5
	/* If this is an absolute branch (ie no link) with an out of
	   range target, then we want to complain.  */
	if (fixP->fx_r_type == (int) R_HPPA_PCREL_CALL
	    && (insn & 0xffe00000) == 0xe8000000)
	  CHECK_FIELD (distance - 8, 8388607, -8388608, 0);
d4392 16
a4407 2
	CHECK_FIELD (new_val - 8, 8388607, -8388608, 0);
	val = new_val - 8;
d4409 4
a4412 3
	insn = (insn & ~ 0x3ff1ffd) | re_assemble_22 (val >> 2);
	break;
      }
d4414 4
a4417 4
    case -10:
      val = new_val;
      insn = (insn & ~ 0xfff1) | re_assemble_16 (val & -8);
      break;
d4419 8
a4426 16
    case -16:
      val = new_val;
      insn = (insn & ~ 0xfff9) | re_assemble_16 (val & -4);
      break;

    case 16:
      val = new_val;
      insn = (insn & ~ 0xffff) | re_assemble_16 (val);
      break;

    case 32:
      insn = new_val;
      break;

    default:
      as_bad (_("Unknown relocation encountered in md_apply_fix."));
a4428 4

  /* Insert the relocation.  */
  bfd_put_32 (stdoutput, insn, buf);
  return 1;
d4456 5
a4460 7
   Return 1 on success or 0 on failure.  If STRICT, then a missing
   register prefix will cause a failure.  The number itself is
   returned in `pa_number'.

   IS_FLOAT indicates that a PA-89 FP register number should be
   parsed;  A `l' or `r' suffix is checked for if but 2 of IS_FLOAT is
   not set.
d4466 1
a4466 1
pa_parse_number (s, is_float)
d4468 1
a4468 1
     int is_float;
a4475 1
  boolean have_prefix;
d4481 9
a4489 4
  pa_number = -1;
  have_prefix = 0;
  num = 0;
  if (!strict && isdigit (*p))
d4492 1
d4520 4
a4523 1
      pa_number = num;
d4525 6
a4530 5
      /* Check for a `l' or `r' suffix.  */
      if (is_float)
	{
	  pa_number += FP_REG_BASE;
	  if (! (is_float & 2))
d4532 2
a4533 9
	      if (IS_R_SELECT (p))
		{
		  pa_number += FP_REG_RSEL;
		  ++p;
		}
	      else if (IS_L_SELECT (p))
		{
		  ++p;
		}
d4535 2
d4542 1
a4542 1
      have_prefix = 1;
d4548 1
a4548 1
         slow.  */
d4598 11
a4608 1
      pa_number = num;
d4613 2
a4614 1
         is effectively a constant, or a register alias symbol.  */
d4625 1
a4625 8
	  if (S_GET_SEGMENT (sym) == reg_section)
	    {
	      num = S_GET_VALUE (sym);
	      /* Well, we don't really have one, but we do have a
		 register, so...  */
	      have_prefix = true;
	    }
	  else if (S_GET_SEGMENT (sym) == &bfd_abs_section)
d4627 1
a4627 1
	  else if (!strict)
d4634 1
a4634 1
      else if (!strict)
d4651 11
a4661 1
      pa_number = num;
d4664 2
a4665 6
  if (!strict || have_prefix)
    {
      *s = p;
      return 1;
    }
  return 0;
d4668 1
a4668 1
#define REG_NAME_CNT	(sizeof (pre_defined_registers) / sizeof (struct pd_reg))
d4699 1
d4704 3
a4706 1
need_pa11_opcode ()
d4708 1
a4708 2
  if ((pa_number & FP_REG_RSEL) != 0
      && !(the_insn.fpof1 == DBL && the_insn.fpof2 == DBL))
d5004 1
a5004 1
/* Mark (via expr_end) the end of an absolute expression.  FIXME.  */
d5020 1
a5020 1
     r5, or is that 4 MOD r5?
d5069 1
a5069 1
  offsetT value;
d5076 57
a5132 1
  return hppa_field_adjust (0, value, field_selector);
d5242 1
d5289 1
d5320 1
d5371 1
d5375 1
d5389 1
d5471 1
d5485 1
d5535 1
a5795 1
     int bytes;
d5814 1
a5814 1
     int z ATTRIBUTE_UNUSED;
d5852 1
a5852 1
     int begin ATTRIBUTE_UNUSED;
d5863 1
a5863 1
		e_fsel, 0, 0, 0);
d5873 1
a5873 1
     int begin ATTRIBUTE_UNUSED;
d5888 1
a5888 1
		e_fsel, 0, 0, 0);
d5900 1
a5900 1
     int unused ATTRIBUTE_UNUSED;
d5989 1
d5991 4
a5994 4
  subsegT save_subseg;
  unsigned int unwind;
  int reloc;
  char *p;
d5996 1
a5996 3
  if ((bfd_get_section_flags (stdoutput, now_seg)
       & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
      != (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
d5999 5
a6003 1
  reloc = R_PARISC_SEGREL32;
d6021 1
d6024 2
a6025 1
  p = frag_more (16);
a6027 1
  md_number_to_chars (p, 0, 4);
d6031 4
a6034 1
		e_fsel, 32, 0, 0);
d6043 2
a6044 2
  md_number_to_chars (p + 4, 0, 4);
  fix_new_hppa (frag_now, p + 4 - frag_now->fr_literal, 4,
d6047 1
a6047 1
		e_fsel, 32, 0, 0);
d6049 9
a6057 6
  /* Dump the descriptor.  */
  unwind = UNWIND_LOW32 (&call_info->ci_unwind.descriptor);
  md_number_to_chars (p + 8, unwind, 4);

  unwind = UNWIND_HIGH32 (&call_info->ci_unwind.descriptor);
  md_number_to_chars (p + 12, unwind, 4);
d6070 1
a6070 1
     int unused ATTRIBUTE_UNUSED;
d6209 2
a6210 3
#if !(defined (OBJ_ELF) && defined (TE_LINUX))
/* Switch to the text space.  Like s_text, but delete our
   label when finished.  */
d6212 2
a6213 2
pa_text (unused)
     int unused ATTRIBUTE_UNUSED;
a6219 1

a6223 14
/* Switch to the data space.  As usual delete our label.  */
static void
pa_data (unused)
     int unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_SOM
  current_space = is_defined_space ("$PRIVATE$");
  current_subspace
    = pa_subsegment_to_subspace (current_space->sd_seg, 0);
#endif
  s_data (0);
  pa_undefine_label ();
}

d6246 1
a6246 1
     int unused ATTRIBUTE_UNUSED;
a6272 1
#endif /* !(defined (OBJ_ELF) && defined (TE_LINUX)) */
d6278 1
a6278 1
     int unused ATTRIBUTE_UNUSED;
d6286 1
a6286 1
     int unused ATTRIBUTE_UNUSED;
d6301 1
a6301 1
     int unused ATTRIBUTE_UNUSED;
d6330 1
a6330 2
      char *where;
      unsigned int u;
a6331 2
      where = frag_more (0);
      u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
d6334 2
a6335 1
		    0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
a6339 21
/* Silly nonsense for pa_equ.  The only half-sensible use for this is
   being able to subtract two register symbols that specify a range of
   registers, to get the size of the range.  */
static int fudge_reg_expressions;

int
hppa_force_reg_syms_absolute (resultP, op, rightP)
     expressionS *resultP;
     operatorT op ATTRIBUTE_UNUSED;
     expressionS *rightP;
{
  if (fudge_reg_expressions
      && rightP->X_op == O_register
      && resultP->X_op == O_register)
    {
      rightP->X_op = O_constant;
      resultP->X_op = O_constant;
    }
  return 0;  /* Continue normal expr handling.  */
}

d6353 1
a6353 7
	{
	  strict = 1;
	  if (!pa_parse_number (&input_line_pointer, 0))
	    as_bad (_(".REG expression must be a register"));
	  S_SET_VALUE (symbol, pa_number);
	  S_SET_SEGMENT (symbol, reg_section);
	}
d6355 2
a6356 18
	{
	  expressionS exp;
	  segT seg;

	  fudge_reg_expressions = 1;
	  seg = expression (&exp);
	  fudge_reg_expressions = 0;
	  if (exp.X_op != O_constant
	      && exp.X_op != O_register)
	    {
	      if (exp.X_op != O_absent)
		as_bad (_("bad or irreducible absolute expression; zero assumed"));
	      exp.X_add_number = 0;
	      seg = absolute_section;
	    }
	  S_SET_VALUE (symbol, (unsigned int) exp.X_add_number);
	  S_SET_SEGMENT (symbol, seg);
	}
d6400 1
a6400 1
		UNWIND_HIGH32 (&last_call_info->ci_unwind.descriptor));
d6408 1
a6408 1
     int unused ATTRIBUTE_UNUSED;
d6441 1
a6441 1
     int unused ATTRIBUTE_UNUSED;
d6458 1
a6458 5
      /* OK.  Set the external bits and process argument relocations.
         For the HP, weak and global are not mutually exclusive.
         S_SET_EXTERNAL will not set BSF_GLOBAL if WEAK is set.
         Call S_SET_EXTERNAL to get the other processing.  Manually
         set BSF_GLOBAL when we get back.  */
a6459 1
      symbol_get_bfdsym (symbol)->flags |= BSF_GLOBAL;
d6482 1
a6482 1
  asymbol *bfdsym = symbol_get_bfdsym (symbolP);
d6488 1
a6488 1
      bfdsym->flags &= ~BSF_FUNCTION;
d6507 1
a6507 1
	  bfdsym->flags |= BSF_FUNCTION;
d6512 1
a6512 1
	  bfdsym->flags &= ~BSF_FUNCTION;
d6519 2
a6520 2
      bfdsym->flags &= ~BSF_FUNCTION;
      bfdsym->flags |= BSF_OBJECT;
d6526 1
a6526 1
      bfdsym->flags |= BSF_FUNCTION;
d6532 1
a6532 9
      bfdsym->flags |= BSF_FUNCTION;
#ifdef OBJ_ELF
      {
	elf_symbol_type *elfsym = (elf_symbol_type *) bfdsym;
	elfsym->internal_elf_sym.st_info =
	  ELF_ST_INFO (ELF_ST_BIND (elfsym->internal_elf_sym.st_info),
		       STT_PARISC_MILLI);
      }
#endif
d6538 1
a6538 1
      bfdsym->flags &= ~BSF_FUNCTION;
d6544 1
a6544 1
      bfdsym->flags |= BSF_FUNCTION;
d6550 1
a6550 1
      bfdsym->flags |= BSF_FUNCTION;
d6558 1
a6558 1
  obj_set_symbol_type (bfdsym, (int) type);
d6579 2
a6580 2
#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
	  symbol_arg_reloc_info (symbolP) |= arg_reloc;
d6593 2
a6594 2
#if defined (OBJ_SOM) || defined (ELF_ARG_RELOC)
	  symbol_arg_reloc_info (symbolP) |= arg_reloc;
d6606 1
a6606 1
	  ((obj_symbol_type *) bfdsym)->tc_data.ap.hppa_priv_level = temp;
d6628 1
a6628 1
     int unused ATTRIBUTE_UNUSED;
d6680 1
a6680 1
     int unused ATTRIBUTE_UNUSED;
d6710 1
a6710 1
     int unused ATTRIBUTE_UNUSED;
d6725 1
a6725 1
     int unused ATTRIBUTE_UNUSED;
d6766 1
a6766 1
     int unused ATTRIBUTE_UNUSED;
d6782 1
a6782 1
     int unused ATTRIBUTE_UNUSED;
d6813 1
a6813 1
   of a procedure from a syntactical point of view.  */
d6817 1
a6817 1
     int unused ATTRIBUTE_UNUSED;
d6887 1
a6887 1
     int unused ATTRIBUTE_UNUSED;
d6918 1
a6918 2
		  char *where;
		  unsigned int u;
a6919 2
		  where = frag_more (0);
		  u = UNWIND_LOW32 (&last_call_info->ci_unwind.descriptor);
d6922 2
a6923 1
				0, R_HPPA_ENTRY, e_fsel, 0, 0, u);
a6953 1
#ifdef OBJ_SOM
d6972 2
d6997 1
a6997 1
  int spnum;
d7031 2
a7032 3
      strict = 0;
      pa_parse_number (&ptemp, 0);
      if (pa_number >= 0)
d7034 1
a7034 1
	  spnum = pa_number;
d7113 1
a7113 1
     int unused ATTRIBUTE_UNUSED;
d7116 1
d7194 1
a7194 3
      strict = 0;
      pa_parse_number (&input_line_pointer, 0);
      if (pa_number >= 0)
d7196 1
a7196 1
	  if ((sd_chain = pa_find_space_by_number (pa_number)))
d7232 1
a7232 1
     int unused ATTRIBUTE_UNUSED;
d7481 1
d7524 1
d7547 1
d7609 2
d7975 5
d8002 1
a8002 1
     For example, \xDD where DD is a hexadecimal number should be
a8004 5
#ifdef OBJ_SOM
  /* We must have a valid space and subspace.  */
  pa_check_current_space_and_subspace ();
#endif

d8023 1
a8023 1
		/* Get past the 'x'.  */
d8072 1
a8072 1
     int unused ATTRIBUTE_UNUSED;
d8084 1
a8084 1
     int unused ATTRIBUTE_UNUSED;
d8096 1
a8096 1
     int unused ATTRIBUTE_UNUSED;
d8113 15
d8142 1
a8142 1
     int unused ATTRIBUTE_UNUSED;
d8172 1
a8172 1
     int unused ATTRIBUTE_UNUSED;
d8183 16
a8235 11
#endif

#ifdef OBJ_ELF
  if (fixp->fx_r_type == (int) R_PARISC_GNU_VTINHERIT
      || fixp->fx_r_type ==  (int) R_PARISC_GNU_VTENTRY)
    return 0;
#endif

  if (fixp->fx_addsy && (S_IS_EXTERNAL (fixp->fx_addsy)
			 || S_IS_WEAK (fixp->fx_addsy)))
    return 0;
d8253 1
a8253 29

     If a symbol is reduced to a section symbol, the assembler will
     adjust the addend unless the symbol happens to reside right at
     the start of the section.  Additionally, the linker has no choice
     but to manipulate the addends when coalescing input sections for
     "ld -r".  Since an LR% field selector is defined to round the
     addend, we can't change the addend without risking that a LR% and
     it's corresponding (possible multiple) RR% field will no longer
     sum to the right value.

     eg. Suppose we have
     .		ldil	LR%foo+0,%r21
     .		ldw	RR%foo+0(%r21),%r26
     .		ldw	RR%foo+4(%r21),%r25

     If foo is at address 4092 (decimal) in section `sect', then after
     reducing to the section symbol we get
     .			LR%sect+4092 == (L%sect)+0
     .			RR%sect+4092 == (R%sect)+4092
     .			RR%sect+4096 == (R%sect)-4096
     and the last address loses because rounding the addend to 8k
     mutiples takes us up to 8192 with an offset of -4096.

     In cases where the LR% expression is identical to the RR% one we
     will never have a problem, but is so happens that gcc rounds
     addends involved in LR% field selectors to work around a HP
     linker bug.  ie. We often have addresses like the last case
     above where the LR% expression is offset from the RR% one.  */

d8258 1
d8270 3
d8278 2
a8279 2
  if (fixp->fx_addsy != 0 && S_IS_FUNCTION (fixp->fx_addsy))
    return 0;
d8281 1
a8281 1
  return 1;
d8290 1
a8290 1
     struct fix *fixp;
d8293 1
d8297 5
a8301 6
  if (fixp->fx_r_type == (int) R_HPPA_ENTRY
      || fixp->fx_r_type == (int) R_HPPA_EXIT
      || fixp->fx_r_type == (int) R_HPPA_BEGIN_BRTAB
      || fixp->fx_r_type == (int) R_HPPA_END_BRTAB
      || fixp->fx_r_type == (int) R_HPPA_BEGIN_TRY
      || fixp->fx_r_type == (int) R_HPPA_END_TRY
a8305 5
#ifdef OBJ_ELF
  if (fixp->fx_r_type == (int) R_PARISC_GNU_VTINHERIT
      || fixp->fx_r_type == (int) R_PARISC_GNU_VTENTRY)
    return 1;
#endif
d8307 2
a8308 6
  assert (fixp->fx_addsy != NULL);

  /* Ensure we emit a relocation for global symbols so that dynamic
     linking works.  */
  if (S_IS_EXTERNAL (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
    return 1;
d8310 1
d8313 5
a8317 4
     call stub.  */
  if (fixp->fx_pcrel
      && arg_reloc_stub_needed (symbol_arg_reloc_info (fixp->fx_addsy),
				hppa_fixp->fx_arg_reloc))
a8318 12

  /* Now check to see if we're going to need a long-branch stub.  */
  if (fixp->fx_r_type == (int) R_HPPA_PCREL_CALL)
    {
      valueT distance;

      distance = (fixp->fx_offset + S_GET_VALUE (fixp->fx_addsy)
		  - md_pcrel_from (fixp) - 8);
      if (distance + 8388608 >= 16777216
	  || (hppa_fixp->fx_r_format == 17 && distance + 262144 >= 524288)
#ifdef OBJ_ELF
	  || (hppa_fixp->fx_r_format == 12 && distance + 8192 >= 16384)
d8320 6
a8325 3
	  )
	return 1;
    }
d8327 1
a8327 1
  if (fixp->fx_r_type == (int) R_HPPA_ABS_CALL)
d8329 1
d8345 3
a8347 8
  char *name;

  if (last_call_info == NULL || last_call_info->start_symbol == NULL)
    {
      /* We have already warned about a missing label,
	 or other problems.  */
      return;
    }
a8348 3
  name = (char *) xmalloc (strlen ("L$\001end_")
			   + strlen (S_GET_NAME (last_call_info->start_symbol))
			   + 1);
d8413 1
d8415 2
a8416 25
static void
pa_vtable_entry (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  struct fix *new_fix;

  new_fix = obj_elf_vtable_entry (0);

  if (new_fix)
    {
      struct hppa_fix_struct *hppa_fix = (struct hppa_fix_struct *)
	obstack_alloc (&notes, sizeof (struct hppa_fix_struct));
      hppa_fix->fx_r_type = R_HPPA;
      hppa_fix->fx_r_field = e_fsel;
      hppa_fix->fx_r_format = 32;
      hppa_fix->fx_arg_reloc = 0;
      hppa_fix->segment = now_seg;
      new_fix->tc_fix_data = (void *) hppa_fix;
      new_fix->fx_r_type = (int) R_PARISC_GNU_VTENTRY;
    }
}

static void
pa_vtable_inherit (ignore)
     int ignore ATTRIBUTE_UNUSED;
d8418 2
a8419 16
  struct fix *new_fix;

  new_fix = obj_elf_vtable_inherit (0);

  if (new_fix)
    {
      struct hppa_fix_struct *hppa_fix = (struct hppa_fix_struct *)
	obstack_alloc (&notes, sizeof (struct hppa_fix_struct));
      hppa_fix->fx_r_type = R_HPPA;
      hppa_fix->fx_r_field = e_fsel;
      hppa_fix->fx_r_format = 32;
      hppa_fix->fx_arg_reloc = 0;
      hppa_fix->segment = now_seg;
      new_fix->tc_fix_data = (void *) hppa_fix;
      new_fix->fx_r_type = (int) R_PARISC_GNU_VTINHERIT;
    }
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.
d26 1
a28 1
#include "safe-ctype.h"
a59 1
#define elf_hppa_reloc_final_type elf64_hppa_reloc_final_type
a61 1
#define elf_hppa_reloc_final_type elf32_hppa_reloc_final_type
d511 4
a514 4
static int pa_parse_nonneg_cmpsub_cmpltr PARAMS ((char **));
static int pa_parse_neg_cmpsub_cmpltr PARAMS ((char **));
static int pa_parse_neg_add_cmpltr PARAMS ((char **));
static int pa_parse_nonneg_add_cmpltr PARAMS ((char **));
d669 1
a669 1
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
a956 5
#if TARGET_ARCH_SIZE == 64
  {"%mrp",    2},
#else
  {"%mrp",   31},
#endif
a1155 14
/* Variant of CHECK_FIELD for use in md_apply_fix3 and other places where
   the current file and line number are not valid.  */

#define CHECK_FIELD_WHERE(FIELD, HIGH, LOW, FILENAME, LINE) \
  { \
    if ((FIELD) > (HIGH) || (FIELD) < (LOW)) \
      { \
        as_bad_where ((FILENAME), (LINE), \
		      _("Field out of range [%d..%d] (%d)."), (LOW), (HIGH), \
		      (int) (FIELD));\
        break; \
      } \
  }

d1271 1
a1271 1
	  && current_space == label_chain->lss_space && label_chain->lss_label
d1274 1
a1274 1
	  && now_seg == label_chain->lss_segment && label_chain->lss_label
d1555 2
a1556 1
    *s = TOLOWER (*s);
d1559 1
a1559 3
  for (s = str;
       ISUPPER (*s) || ISLOWER (*s) || (*s >= '0' && *s <= '3');
       ++s)
d1581 2
d1675 1
a1675 1
	      if (!strncasecmp (s, "%sar", 4))
d1680 1
a1680 1
	      else if (!strncasecmp (s, "%cr11", 5))
a1794 1
		case 'X':
a1832 1
		case 'M':
d1872 1
a1872 1
		   /* 'J', 'm', 'M' and 'q' are the same, except for where they
d1874 1
a1874 1
		   if (*args == 'm' || *args == 'M')
a1899 1
		case 'A':
d1935 1
a1935 1
		  if (!strncmp (s, ",sl", 3))
d1945 1
a1945 1
		  if (!strncmp (s, ",sl", 3))
d1950 1
a1950 1
		  else if (!strncmp (s, ",bc", 3))
d1960 1
a1960 1
		  if (!strncmp (s, ",co", 3))
d1969 1
a1969 1
		  if (strncmp (s, ",o", 2) != 0)
d2238 1
a2238 1
			as_bad (_("Invalid left/right combination completer"));
d2244 1
a2244 1
		    as_bad (_("Invalid left/right combination completer"));
d2293 1
a2293 1
			      as_bad (_("Invalid permutation completer"));
d2300 1
a2300 1
		    as_bad (_("Invalid permutation completer"));
d2314 4
a2317 4
		  /* Handle FP compare conditions.  */
		  case 'f':
		    cond = pa_parse_fp_cmp_cond (&s);
		    INSERT_FIELD_AND_CONTINUE (opcode, cond, 0);
d2322 2
a2323 2
		    cmpltr = 0;
		    flag = 0;
d2409 1
a2409 1
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s);
d2412 1
a2412 1
			as_bad (_("Invalid Add and Branch Condition"));
d2422 1
a2422 1
			as_bad (_("Invalid Add and Branch Condition"));
d2436 1
a2436 1
		    cmpltr = pa_parse_nonneg_add_cmpltr (&s);
d2440 1
a2440 1
			cmpltr = pa_parse_neg_add_cmpltr (&s);
d2578 1
a2578 1
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s);
d2581 1
a2581 1
			as_bad (_("Invalid Compare/Subtract Condition"));
d2589 1
a2589 1
		    cmpltr = pa_parse_nonneg_cmpsub_cmpltr (&s);
d2593 1
a2593 1
			cmpltr = pa_parse_neg_cmpsub_cmpltr (&s);
d2596 1
a2596 1
			    as_bad (_("Invalid Compare and Branch Condition"));
d3231 1
a3231 1
			      FAKE_LABEL_NAME))
d3263 1
a3263 1
			      FAKE_LABEL_NAME))
d3294 1
a3294 1
			      FAKE_LABEL_NAME))
d3324 1
a3324 1
			      FAKE_LABEL_NAME))
d3929 1
a3929 1
      if (!match)
d4058 1
a4058 1
      as_bad_where (fixp->fx_file, fixp->fx_line, _("Cannot handle fixup"));
d4220 2
a4221 2
	  relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
d4229 2
a4230 2
	  relocs[i]->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
	  *relocs[i]->sym_ptr_ptr = symbol_get_bfdsym (dummy_symbol);
d4388 2
a4389 2
void
md_apply_fix3 (fixP, valP, seg)
d4391 1
a4391 2
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d4407 1
a4407 1
    return;
d4414 2
a4415 2
      fixP->fx_offset = * valP;
      return;
d4421 1
a4421 1
    return;
a4423 3
  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;

d4429 3
a4431 4
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("no hppa_fixup entry for fixup type 0x%x"),
		    fixP->fx_r_type);
      return;
d4434 1
a4434 1
  buf = (unsigned char *) (fixP->fx_frag->fr_literal + fixP->fx_where);
d4458 7
d4467 1
a4467 1
    new_val = hppa_field_adjust (* valP, 0, hppa_fixP->fx_r_field);
d4476 3
a4478 3
      && (* valP - 8 + 8192 < 16384
	  || (fmt == 17 && * valP - 8 + 262144 < 524288)
	  || (fmt == 22 && * valP - 8 + 8388608 < 16777216))
d4481 2
a4482 2
      && (* valP - 8 + 262144 < 524288
	  || (fmt == 22 && * valP - 8 + 8388608 < 16777216))
d4490 1
a4490 1
      new_val = hppa_field_adjust (* valP, 0, hppa_fixP->fx_r_field);
d4496 1
a4496 2
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
d4503 1
a4503 2
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
d4511 1
a4511 2
      CHECK_FIELD_WHERE (new_val, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
d4519 1
a4519 2
      CHECK_FIELD_WHERE (new_val, 1048575, -1048576,
			 fixP->fx_file, fixP->fx_line);
d4527 1
a4527 2
      CHECK_FIELD_WHERE (new_val, 1023, -1024,
			 fixP->fx_file, fixP->fx_line);
d4535 1
a4535 2
      CHECK_FIELD_WHERE (new_val - 8, 8191, -8192,
			 fixP->fx_file, fixP->fx_line);
d4544 1
a4544 1
	offsetT distance = * valP;
d4550 1
a4550 2
	  CHECK_FIELD_WHERE (distance - 8, 262143, -262144,
			     fixP->fx_file, fixP->fx_line);
d4552 1
a4552 2
	CHECK_FIELD_WHERE (new_val - 8, 262143, -262144,
			   fixP->fx_file, fixP->fx_line);
d4561 1
a4561 1
	offsetT distance = * valP;
d4567 1
a4567 2
	  CHECK_FIELD_WHERE (distance - 8, 8388607, -8388608,
			     fixP->fx_file, fixP->fx_line);
d4569 1
a4569 2
	CHECK_FIELD_WHERE (new_val - 8, 8388607, -8388608,
			   fixP->fx_file, fixP->fx_line);
d4596 2
a4597 3
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("Unknown relocation encountered in md_apply_fix."));
      return;
d4602 1
d4652 1
a4652 1
  bfd_boolean have_prefix;
d4661 1
a4661 1
  if (!strict && ISDIGIT (*p))
d4669 1
a4669 1
	  while (ISDIGIT (*p) || ((*p >= 'a') && (*p <= 'f'))
d4672 1
a4672 1
	      if (ISDIGIT (*p))
d4684 1
a4684 1
	  while (ISDIGIT (*p))
d4736 1
a4736 1
	  else if (!ISDIGIT (*p))
d4746 1
a4746 1
	      while (ISDIGIT (*p));
d4791 1
a4791 1
	      have_prefix = TRUE;
d5098 1
a5098 1
    name[0] = TOLOWER ((*str)[0]),
d5101 2
a5102 2
    name[0] = TOLOWER ((*str)[0]),
    name[1] = TOLOWER ((*str)[1]),
d5105 3
a5107 3
    name[0] = TOLOWER ((*str)[0]),
    name[1] = TOLOWER ((*str)[1]),
    name[2] = TOLOWER ((*str)[2]),
d5192 1
a5192 1
	s++;
d5320 5
a5324 1
   number (for encoding in instrutions) of the given completer.  */
d5327 1
a5327 1
pa_parse_nonneg_cmpsub_cmpltr (s)
d5329 1
d5376 1
a5376 1
      else if (strcasecmp (name, "n") == 0)
d5396 5
a5400 1
   number (for encoding in instrutions) of the given completer.  */
d5403 1
a5403 1
pa_parse_neg_cmpsub_cmpltr (s)
d5405 1
d5456 1
a5456 1
      else if (strcasecmp (name, "n") == 0)
d5635 5
a5639 1
   (for encoding in instrutions) of the given completer.  */
d5642 1
a5642 1
pa_parse_nonneg_add_cmpltr (s)
d5644 1
a5649 1
  int nullify = 0;
d5689 1
a5689 1
      else if (strcasecmp (name, "n") == 0)
a5691 1
	  nullify = 1;
d5701 1
a5701 1
  if (nullify)
d5708 5
a5712 1
   (for encoding in instrutions) of the given completer.  */
d5715 1
a5715 1
pa_parse_neg_add_cmpltr (s)
d5717 1
a5722 1
  int nullify = 0;
d5766 1
a5766 1
      else if (strcasecmp (name, "n") == 0)
a5768 1
	  nullify = 1;
d5778 1
a5778 1
  if (nullify)
d6816 1
a6816 1
	     the current segment.  Note only BSF_FUNCTION really
d8186 1
a8186 1
		     && (ISDIGIT (dg) || (dg >= 'a' && dg <= 'f')
d8190 1
a8190 1
		    if (ISDIGIT (dg))
a8355 1
  reloc_type code;
d8367 3
a8369 37
  /* LR/RR selectors are implicitly used for a number of different relocation
     types.  We must ensure that none of these types are adjusted (see below)
     even if they occur with a different selector.  */
  code = elf_hppa_reloc_final_type (stdoutput, fixp->fx_r_type,
		  		    hppa_fix->fx_r_format,
				    hppa_fix->fx_r_field);

  switch (code)
    {
    /* Relocation types which use e_lrsel.  */
    case R_PARISC_DIR21L:
    case R_PARISC_DLTREL21L:
    case R_PARISC_DPREL21L:
    case R_PARISC_PLTOFF21L:

    /* Relocation types which use e_rrsel.  */
    case R_PARISC_DIR14R:
    case R_PARISC_DIR14DR:
    case R_PARISC_DIR14WR:
    case R_PARISC_DIR17R:
    case R_PARISC_DLTREL14R:
    case R_PARISC_DLTREL14DR:
    case R_PARISC_DLTREL14WR:
    case R_PARISC_DPREL14R:
    case R_PARISC_DPREL14DR:
    case R_PARISC_DPREL14WR:
    case R_PARISC_PLTOFF14R:
    case R_PARISC_PLTOFF14DR:
    case R_PARISC_PLTOFF14WR:

    /* Other types that we reject for reduction.  */
    case R_PARISC_GNU_VTENTRY:
    case R_PARISC_GNU_VTINHERIT:
      return 0;
    default:
      break;
    }
d8372 4
d8385 5
a8389 1
    return 0;
d8479 1
a8479 1
  if (S_FORCE_RELOC (fixp->fx_addsy, 1))
d8483 1
a8483 1
     entry if they're going to need either an argument relocation or long
d8493 1
a8493 2
      long pc = md_pcrel_from (fixp);
      valueT distance, min_stub_distance;
d8495 7
a8501 18
      distance = fixp->fx_offset + S_GET_VALUE (fixp->fx_addsy) - pc - 8;

      /* Distance to the closest possible stub.  This will detect most
	 but not all circumstances where a stub will not work.  */
      min_stub_distance = pc + 16;
#ifdef OBJ_SOM
      if (last_call_info != NULL)
	min_stub_distance -= S_GET_VALUE (last_call_info->start_symbol);
#endif

      if ((distance + 8388608 >= 16777216
	   && min_stub_distance <= 8388608)
	  || (hppa_fixp->fx_r_format == 17
	      && distance + 262144 >= 524288
	      && min_stub_distance <= 262144)
	  || (hppa_fixp->fx_r_format == 12
	      && distance + 8192 >= 16384
	      && min_stub_distance <= 8192)
d8516 1
a8516 1
   the size of the function in elf_hppa_final_processing.  */
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d46 1
a46 1
/* A "convenient" place to put object file dependencies which do
d493 1
a493 1
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
d599 1
a599 1
/* File and globally scoped variable declarations.  */
a624 5
/* These characters can be suffixes of opcode names and they may be
   followed by meaningful whitespace.  We don't include `,' and `!'
   as they never appear followed by meaningful whitespace.  */
const char hppa_symbol_chars[] = "*?=<>";

d645 1
a645 1
#if defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD))
d655 1
a655 1
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
d662 1
a662 1
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
d670 3
d682 3
d709 1
a709 1
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
d752 1
a752 1
/* Points to the end of an expression just parsed by get_expression
a855 4
  {"%farg0",  5},
  {"%farg1",  6},
  {"%farg2",  7},
  {"%farg3",  8},
a951 1
  {"%fret",   4},
a1016 8
  {"%t1",    22},
  {"%t2",    21},
  {"%t3",    20},
  {"%t4",    19},
  {"%tf1",   11},
  {"%tf2",   10},
  {"%tf3",    9},
  {"%tf4",    8},
d1149 1
a1149 1
/* Simple range checking for FIELD against HIGH and LOW bounds.
d1177 1
a1177 1
/* Simple alignment checking for FIELD against ALIGN (a power of two).
a1389 2
  else if (is_PC_relative (*exp))
    rel_type = R_HPPA_PCREL_CALL;
d1534 1
a1534 1
  /* Get somewhere to put the assembled instruction.  */
d1630 1
a1630 1
	 crud is for compatibility with HP's old assemblers only.  */
d2361 1
d2423 1
a2423 1
			else if (*args == 'a' || *name)
d2529 1
d2591 1
a2591 1
			else if (*args != 'S' || *name)
d2714 1
a2714 1
			else if (*args != 'L' || *name)
d2769 1
a2769 1
			else if (*args != 'X' || *name)
d2881 1
a2881 1
			else if (*args != 'U' || (*s != ' ' && *s != '\t'))
d4838 1
a4838 1
	     compatibility with the braindamaged HP assemblers.  */
d5209 1
a5209 1
     The PA assembly syntax is ambiguous in a variety of ways.  Consider
d5213 1
a5213 1
     If we get a modulo expression when looking for an absolute, we try
d5351 1
a5351 1
   number (for encoding in instructions) of the given completer.  */
d5422 1
a5422 1
   number (for encoding in instructions) of the given completer.  */
d5497 1
a5497 1
   encoding in instructions) of the given completer.
d5594 1
a5594 1
   (for encoding in instructions) of the given completer.  */
d5656 1
a5656 1
   (for encoding in instructions) of the given completer.  */
d5726 1
a5726 1
   (for encoding in instructions) of the given completer.  */
d5800 1
a5800 1
   encoding in instructions) of the given completer.  */
d5967 1
a5967 1
  /* The BRTAB relocations are only available in SOM (to denote
d5993 1
a5993 1
  /* The TRY relocations are only available in SOM (to denote
d6310 1
a6310 1
#if !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD)))
a6378 1
      symbol_get_bfdsym (symbol)->flags |= BSF_OBJECT;
d6390 1
a6390 1
#endif /* !(defined (OBJ_ELF) && (defined (TE_LINUX) || defined (TE_NetBSD))) */
d6416 1
a6416 1
   procedure.  */
d6774 1
a6774 1
      /* Privilege level.  */
d6829 1
a6829 1
	  /* Sigh.  To be compatible with the HP assembler and to help
d7058 1
a7058 1
/* Process the syntactical end of a procedure.  Make sure all the
d7267 1
a7267 1
     the first occurrence of a built-in space.  */
d8455 1
a8455 1
     multiples takes us up to 8192 with an offset of -4096.
@


