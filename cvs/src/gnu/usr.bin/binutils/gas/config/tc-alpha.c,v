head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.48
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.44
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.46
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.38
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.42
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.40
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.36
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.34
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.32
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.30
	OPENBSD_5_0:1.10.0.28
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.26
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.24
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.20
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.22
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.18
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.16
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.14
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.12
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.10
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.8
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2004.11.02.20.45.26;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.09.22.29.33;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.03.03.12.15;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.48;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.40;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.05.25;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.12;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.01;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.01;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.27;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.44.32;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.21;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.22.50;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.22;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.07.15;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.13.33.42;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.28;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.22.48;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-alpha.c - Processor-specific code for the DEC Alpha AXP CPU.
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.
   Contributed by Carnegie Mellon University, 1993.
   Written by Alessandro Forin, based on earlier gas-1.38 target CPU files.
   Modified by Ken Raeburn for gas-2.x and ECOFF support.
   Modified by Richard Henderson for ELF support.
   Modified by Klaus K"ampf for EVAX (OpenVMS/Alpha) support.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/*
 * Mach Operating System
 * Copyright (c) 1993 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "as.h"
#include "subsegs.h"
#include "struc-symbol.h"
#include "ecoff.h"

#include "opcode/alpha.h"

#ifdef OBJ_ELF
#include "elf/alpha.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"
#endif

#include "safe-ctype.h"

/* Local types.  */

#define TOKENIZE_ERROR -1
#define TOKENIZE_ERROR_REPORT -2

#define MAX_INSN_FIXUPS 2
#define MAX_INSN_ARGS 5

struct alpha_fixup
{
  expressionS exp;
  bfd_reloc_code_real_type reloc;
};

struct alpha_insn
{
  unsigned insn;
  int nfixups;
  struct alpha_fixup fixups[MAX_INSN_FIXUPS];
  long sequence;
};

enum alpha_macro_arg
  {
    MACRO_EOA = 1,
    MACRO_IR,
    MACRO_PIR,
    MACRO_OPIR,
    MACRO_CPIR,
    MACRO_FPR,
    MACRO_EXP,
  };

struct alpha_macro
{
  const char *name;
  void (*emit) PARAMS ((const expressionS *, int, const PTR));
  const PTR arg;
  enum alpha_macro_arg argsets[16];
};

/* Extra expression types.  */

#define O_pregister	O_md1	/* O_register, in parentheses */
#define O_cpregister	O_md2	/* + a leading comma */

/* The alpha_reloc_op table below depends on the ordering of these.  */
#define O_literal	O_md3	/* !literal relocation */
#define O_lituse_addr	O_md4	/* !lituse_addr relocation */
#define O_lituse_base	O_md5	/* !lituse_base relocation */
#define O_lituse_bytoff	O_md6	/* !lituse_bytoff relocation */
#define O_lituse_jsr	O_md7	/* !lituse_jsr relocation */
#define O_lituse_tlsgd	O_md8	/* !lituse_tlsgd relocation */
#define O_lituse_tlsldm	O_md9	/* !lituse_tlsldm relocation */
#define O_gpdisp	O_md10	/* !gpdisp relocation */
#define O_gprelhigh	O_md11	/* !gprelhigh relocation */
#define O_gprellow	O_md12	/* !gprellow relocation */
#define O_gprel		O_md13	/* !gprel relocation */
#define O_samegp	O_md14	/* !samegp relocation */
#define O_tlsgd		O_md15	/* !tlsgd relocation */
#define O_tlsldm	O_md16	/* !tlsldm relocation */
#define O_gotdtprel	O_md17	/* !gotdtprel relocation */
#define O_dtprelhi	O_md18	/* !dtprelhi relocation */
#define O_dtprello	O_md19	/* !dtprello relocation */
#define O_dtprel	O_md20	/* !dtprel relocation */
#define O_gottprel	O_md21	/* !gottprel relocation */
#define O_tprelhi	O_md22	/* !tprelhi relocation */
#define O_tprello	O_md23	/* !tprello relocation */
#define O_tprel		O_md24	/* !tprel relocation */

#define DUMMY_RELOC_LITUSE_ADDR		(BFD_RELOC_UNUSED + 1)
#define DUMMY_RELOC_LITUSE_BASE		(BFD_RELOC_UNUSED + 2)
#define DUMMY_RELOC_LITUSE_BYTOFF	(BFD_RELOC_UNUSED + 3)
#define DUMMY_RELOC_LITUSE_JSR		(BFD_RELOC_UNUSED + 4)
#define DUMMY_RELOC_LITUSE_TLSGD	(BFD_RELOC_UNUSED + 5)
#define DUMMY_RELOC_LITUSE_TLSLDM	(BFD_RELOC_UNUSED + 6)

#define USER_RELOC_P(R) ((R) >= O_literal && (R) <= O_tprel)

/* Macros for extracting the type and number of encoded register tokens.  */

#define is_ir_num(x)		(((x) & 32) == 0)
#define is_fpr_num(x)		(((x) & 32) != 0)
#define regno(x)		((x) & 31)

/* Something odd inherited from the old assembler.  */

#define note_gpreg(R)		(alpha_gprmask |= (1 << (R)))
#define note_fpreg(R)		(alpha_fprmask |= (1 << (R)))

/* Predicates for 16- and 32-bit ranges */
/* XXX: The non-shift version appears to trigger a compiler bug when
   cross-assembling from x86 w/ gcc 2.7.2.  */

#if 1
#define range_signed_16(x) \
	(((offsetT) (x) >> 15) == 0 || ((offsetT) (x) >> 15) == -1)
#define range_signed_32(x) \
	(((offsetT) (x) >> 31) == 0 || ((offsetT) (x) >> 31) == -1)
#else
#define range_signed_16(x)	((offsetT) (x) >= -(offsetT) 0x8000 &&	\
				 (offsetT) (x) <=  (offsetT) 0x7FFF)
#define range_signed_32(x)	((offsetT) (x) >= -(offsetT) 0x80000000 && \
				 (offsetT) (x) <=  (offsetT) 0x7FFFFFFF)
#endif

/* Macros for sign extending from 16- and 32-bits.  */
/* XXX: The cast macros will work on all the systems that I care about,
   but really a predicate should be found to use the non-cast forms.  */

#if 1
#define sign_extend_16(x)	((short) (x))
#define sign_extend_32(x)	((int) (x))
#else
#define sign_extend_16(x)	((offsetT) (((x) & 0xFFFF) ^ 0x8000) - 0x8000)
#define sign_extend_32(x)	((offsetT) (((x) & 0xFFFFFFFF) \
					   ^ 0x80000000) - 0x80000000)
#endif

/* Macros to build tokens.  */

#define set_tok_reg(t, r)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_register,			\
				 (t).X_add_number = (r))
#define set_tok_preg(t, r)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_pregister,		\
				 (t).X_add_number = (r))
#define set_tok_cpreg(t, r)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_cpregister,		\
				 (t).X_add_number = (r))
#define set_tok_freg(t, r)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_register,			\
				 (t).X_add_number = (r) + 32)
#define set_tok_sym(t, s, a)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_symbol,			\
				 (t).X_add_symbol = (s),		\
				 (t).X_add_number = (a))
#define set_tok_const(t, n)	(memset (&(t), 0, sizeof (t)),		\
				 (t).X_op = O_constant,			\
				 (t).X_add_number = (n))

/* Prototypes for all local functions.  */

static struct alpha_reloc_tag *get_alpha_reloc_tag PARAMS ((long));
static void alpha_adjust_relocs PARAMS ((bfd *, asection *, PTR));

static int tokenize_arguments PARAMS ((char *, expressionS *, int));
static const struct alpha_opcode *find_opcode_match
  PARAMS ((const struct alpha_opcode *, const expressionS *, int *, int *));
static const struct alpha_macro *find_macro_match
  PARAMS ((const struct alpha_macro *, const expressionS *, int *));
static unsigned insert_operand
  PARAMS ((unsigned, const struct alpha_operand *, offsetT, char *, unsigned));
static void assemble_insn
  PARAMS ((const struct alpha_opcode *, const expressionS *, int,
	   struct alpha_insn *, bfd_reloc_code_real_type));
static void emit_insn PARAMS ((struct alpha_insn *));
static void assemble_tokens_to_insn
  PARAMS ((const char *, const expressionS *, int, struct alpha_insn *));
static void assemble_tokens
  PARAMS ((const char *, const expressionS *, int, int));

static long load_expression
  PARAMS ((int, const expressionS *, int *, expressionS *));

static void emit_ldgp PARAMS ((const expressionS *, int, const PTR));
static void emit_division PARAMS ((const expressionS *, int, const PTR));
static void emit_lda PARAMS ((const expressionS *, int, const PTR));
static void emit_ldah PARAMS ((const expressionS *, int, const PTR));
static void emit_ir_load PARAMS ((const expressionS *, int, const PTR));
static void emit_loadstore PARAMS ((const expressionS *, int, const PTR));
static void emit_jsrjmp PARAMS ((const expressionS *, int, const PTR));
static void emit_ldX PARAMS ((const expressionS *, int, const PTR));
static void emit_ldXu PARAMS ((const expressionS *, int, const PTR));
static void emit_uldX PARAMS ((const expressionS *, int, const PTR));
static void emit_uldXu PARAMS ((const expressionS *, int, const PTR));
static void emit_ldil PARAMS ((const expressionS *, int, const PTR));
static void emit_stX PARAMS ((const expressionS *, int, const PTR));
static void emit_ustX PARAMS ((const expressionS *, int, const PTR));
static void emit_sextX PARAMS ((const expressionS *, int, const PTR));
static void emit_retjcr PARAMS ((const expressionS *, int, const PTR));

static void s_alpha_text PARAMS ((int));
static void s_alpha_data PARAMS ((int));
#ifndef OBJ_ELF
static void s_alpha_comm PARAMS ((int));
static void s_alpha_rdata PARAMS ((int));
#endif
#ifdef OBJ_ECOFF
static void s_alpha_sdata PARAMS ((int));
#endif
#ifdef OBJ_ELF
static void s_alpha_section PARAMS ((int));
static void s_alpha_ent PARAMS ((int));
static void s_alpha_end PARAMS ((int));
static void s_alpha_mask PARAMS ((int));
static void s_alpha_frame PARAMS ((int));
static void s_alpha_prologue PARAMS ((int));
static void s_alpha_file PARAMS ((int));
static void s_alpha_loc PARAMS ((int));
static void s_alpha_stab PARAMS ((int));
static void s_alpha_coff_wrapper PARAMS ((int));
static void s_alpha_usepv PARAMS ((int));
#endif
#ifdef OBJ_EVAX
static void s_alpha_section PARAMS ((int));
#endif
static void s_alpha_gprel32 PARAMS ((int));
static void s_alpha_float_cons PARAMS ((int));
static void s_alpha_proc PARAMS ((int));
static void s_alpha_set PARAMS ((int));
static void s_alpha_base PARAMS ((int));
static void s_alpha_align PARAMS ((int));
static void s_alpha_stringer PARAMS ((int));
static void s_alpha_space PARAMS ((int));
static void s_alpha_ucons PARAMS ((int));
static void s_alpha_arch PARAMS ((int));

static void create_literal_section PARAMS ((const char *, segT *, symbolS **));
#ifndef OBJ_ELF
static void select_gp_value PARAMS ((void));
#endif
static void alpha_align PARAMS ((int, char *, symbolS *, int));

/* Generic assembler global variables which must be defined by all
   targets.  */

/* Characters which always start a comment.  */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
#if 0
const char FLT_CHARS[] = "dD";
#else
/* XXX: Do all of these really get used on the alpha??  */
char FLT_CHARS[] = "rRsSfFdDxXpP";
#endif

#ifdef OBJ_EVAX
const char *md_shortopts = "Fm:g+1h:HG:";
#else
const char *md_shortopts = "Fm:gG:";
#endif

struct option md_longopts[] =
  {
#define OPTION_32ADDR (OPTION_MD_BASE)
    { "32addr", no_argument, NULL, OPTION_32ADDR },
#define OPTION_RELAX (OPTION_32ADDR + 1)
    { "relax", no_argument, NULL, OPTION_RELAX },
#ifdef OBJ_ELF
#define OPTION_MDEBUG (OPTION_RELAX + 1)
#define OPTION_NO_MDEBUG (OPTION_MDEBUG + 1)
    { "mdebug", no_argument, NULL, OPTION_MDEBUG },
    { "no-mdebug", no_argument, NULL, OPTION_NO_MDEBUG },
#endif
    { NULL, no_argument, NULL, 0 }
  };

size_t md_longopts_size = sizeof (md_longopts);

#ifdef OBJ_EVAX
#define AXP_REG_R0     0
#define AXP_REG_R16    16
#define AXP_REG_R17    17
#undef AXP_REG_T9
#define AXP_REG_T9     22
#undef AXP_REG_T10
#define AXP_REG_T10    23
#undef AXP_REG_T11
#define AXP_REG_T11    24
#undef AXP_REG_T12
#define AXP_REG_T12    25
#define AXP_REG_AI     25
#undef AXP_REG_FP
#define AXP_REG_FP     29

#undef AXP_REG_GP
#define AXP_REG_GP AXP_REG_PV
#endif /* OBJ_EVAX  */

/* The cpu for which we are generating code.  */
static unsigned alpha_target = AXP_OPCODE_BASE;
static const char *alpha_target_name = "<all>";

/* The hash table of instruction opcodes.  */
static struct hash_control *alpha_opcode_hash;

/* The hash table of macro opcodes.  */
static struct hash_control *alpha_macro_hash;

#ifdef OBJ_ECOFF
/* The $gp relocation symbol.  */
static symbolS *alpha_gp_symbol;

/* XXX: what is this, and why is it exported? */
valueT alpha_gp_value;
#endif

/* The current $gp register.  */
static int alpha_gp_register = AXP_REG_GP;

/* A table of the register symbols.  */
static symbolS *alpha_register_table[64];

/* Constant sections, or sections of constants.  */
#ifdef OBJ_ECOFF
static segT alpha_lita_section;
#endif
#ifdef OBJ_EVAX
static segT alpha_link_section;
static segT alpha_ctors_section;
static segT alpha_dtors_section;
#endif
static segT alpha_lit8_section;

/* Symbols referring to said sections.  */
#ifdef OBJ_ECOFF
static symbolS *alpha_lita_symbol;
#endif
#ifdef OBJ_EVAX
static symbolS *alpha_link_symbol;
static symbolS *alpha_ctors_symbol;
static symbolS *alpha_dtors_symbol;
#endif
static symbolS *alpha_lit8_symbol;

/* Literal for .litX+0x8000 within .lita.  */
#ifdef OBJ_ECOFF
static offsetT alpha_lit8_literal;
#endif

/* Is the assembler not allowed to use $at?  */
static int alpha_noat_on = 0;

/* Are macros enabled?  */
static int alpha_macros_on = 1;

/* Are floats disabled?  */
static int alpha_nofloats_on = 0;

/* Are addresses 32 bit?  */
static int alpha_addr32_on = 0;

/* Symbol labelling the current insn.  When the Alpha gas sees
     foo:
       .quad 0
   and the section happens to not be on an eight byte boundary, it
   will align both the symbol and the .quad to an eight byte boundary.  */
static symbolS *alpha_insn_label;

/* Whether we should automatically align data generation pseudo-ops.
   .align 0 will turn this off.  */
static int alpha_auto_align_on = 1;

/* The known current alignment of the current section.  */
static int alpha_current_align;

/* These are exported to ECOFF code.  */
unsigned long alpha_gprmask, alpha_fprmask;

/* Whether the debugging option was seen.  */
static int alpha_debug;

#ifdef OBJ_ELF
/* Whether we are emitting an mdebug section.  */
int alpha_flag_mdebug = -1;
#endif

/* Don't fully resolve relocations, allowing code movement in the linker.  */
static int alpha_flag_relax;

/* What value to give to bfd_set_gp_size.  */
static int g_switch_value = 8;

#ifdef OBJ_EVAX
/* Collect information about current procedure here.  */
static struct {
  symbolS *symbol;	/* proc pdesc symbol */
  int pdsckind;
  int framereg;		/* register for frame pointer */
  int framesize;	/* size of frame */
  int rsa_offset;
  int ra_save;
  int fp_save;
  long imask;
  long fmask;
  int type;
  int prologue;
} alpha_evax_proc;

static int alpha_flag_hash_long_names = 0;		/* -+ */
static int alpha_flag_show_after_trunc = 0;		/* -H */

/* If the -+ switch is given, then a hash is appended to any name that is
   longer than 64 characters, else longer symbol names are truncated.  */

#endif

#ifdef RELOC_OP_P
/* A table to map the spelling of a relocation operand into an appropriate
   bfd_reloc_code_real_type type.  The table is assumed to be ordered such
   that op-O_literal indexes into it.  */

#define ALPHA_RELOC_TABLE(op)						\
(&alpha_reloc_op[ ((!USER_RELOC_P (op))					\
		  ? (abort (), 0)					\
		  : (int) (op) - (int) O_literal) ])

#define DEF(NAME, RELOC, REQ, ALLOW) \
 { #NAME, sizeof(#NAME)-1, O_##NAME, RELOC, REQ, ALLOW}

static const struct alpha_reloc_op_tag
{
  const char *name;				/* string to lookup */
  size_t length;				/* size of the string */
  operatorT op;					/* which operator to use */
  bfd_reloc_code_real_type reloc;		/* relocation before frob */
  unsigned int require_seq : 1;			/* require a sequence number */
  unsigned int allow_seq : 1;			/* allow a sequence number */
}
alpha_reloc_op[] =
{
  DEF(literal, BFD_RELOC_ALPHA_ELF_LITERAL, 0, 1),
  DEF(lituse_addr, DUMMY_RELOC_LITUSE_ADDR, 1, 1),
  DEF(lituse_base, DUMMY_RELOC_LITUSE_BASE, 1, 1),
  DEF(lituse_bytoff, DUMMY_RELOC_LITUSE_BYTOFF, 1, 1),
  DEF(lituse_jsr, DUMMY_RELOC_LITUSE_JSR, 1, 1),
  DEF(lituse_tlsgd, DUMMY_RELOC_LITUSE_TLSGD, 1, 1),
  DEF(lituse_tlsldm, DUMMY_RELOC_LITUSE_TLSLDM, 1, 1),
  DEF(gpdisp, BFD_RELOC_ALPHA_GPDISP, 1, 1),
  DEF(gprelhigh, BFD_RELOC_ALPHA_GPREL_HI16, 0, 0),
  DEF(gprellow, BFD_RELOC_ALPHA_GPREL_LO16, 0, 0),
  DEF(gprel, BFD_RELOC_GPREL16, 0, 0),
  DEF(samegp, BFD_RELOC_ALPHA_BRSGP, 0, 0),
  DEF(tlsgd, BFD_RELOC_ALPHA_TLSGD, 0, 1),
  DEF(tlsldm, BFD_RELOC_ALPHA_TLSLDM, 0, 1),
  DEF(gotdtprel, BFD_RELOC_ALPHA_GOTDTPREL16, 0, 0),
  DEF(dtprelhi, BFD_RELOC_ALPHA_DTPREL_HI16, 0, 0),
  DEF(dtprello, BFD_RELOC_ALPHA_DTPREL_LO16, 0, 0),
  DEF(dtprel, BFD_RELOC_ALPHA_DTPREL16, 0, 0),
  DEF(gottprel, BFD_RELOC_ALPHA_GOTTPREL16, 0, 0),
  DEF(tprelhi, BFD_RELOC_ALPHA_TPREL_HI16, 0, 0),
  DEF(tprello, BFD_RELOC_ALPHA_TPREL_LO16, 0, 0),
  DEF(tprel, BFD_RELOC_ALPHA_TPREL16, 0, 0),
};

#undef DEF

static const int alpha_num_reloc_op
  = sizeof (alpha_reloc_op) / sizeof (*alpha_reloc_op);
#endif /* RELOC_OP_P */

/* Maximum # digits needed to hold the largest sequence # */
#define ALPHA_RELOC_DIGITS 25

/* Structure to hold explicit sequence information.  */
struct alpha_reloc_tag
{
  fixS *master;			/* the literal reloc */
  fixS *slaves;			/* head of linked list of lituses */
  segT segment;			/* segment relocs are in or undefined_section*/
  long sequence;		/* sequence # */
  unsigned n_master;		/* # of literals */
  unsigned n_slaves;		/* # of lituses */
  unsigned saw_tlsgd : 1;	/* true if ... */
  unsigned saw_tlsldm : 1;
  unsigned saw_lu_tlsgd : 1;
  unsigned saw_lu_tlsldm : 1;
  unsigned multi_section_p : 1;	/* true if more than one section was used */
  char string[1];		/* printable form of sequence to hash with */
};

/* Hash table to link up literals with the appropriate lituse */
static struct hash_control *alpha_literal_hash;

/* Sequence numbers for internal use by macros.  */
static long next_sequence_num = -1;

/* A table of CPU names and opcode sets.  */

static const struct cpu_type
{
  const char *name;
  unsigned flags;
}
cpu_types[] =
{
  /* Ad hoc convention: cpu number gets palcode, process code doesn't.
     This supports usage under DU 4.0b that does ".arch ev4", and
     usage in MILO that does -m21064.  Probably something more
     specific like -m21064-pal should be used, but oh well.  */

  { "21064", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21064a", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21066", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21068", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21164", AXP_OPCODE_BASE|AXP_OPCODE_EV5 },
  { "21164a", AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX },
  { "21164pc", (AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX
		|AXP_OPCODE_MAX) },
  { "21264", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },
  { "21264a", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },
  { "21264b", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },

  { "ev4", AXP_OPCODE_BASE },
  { "ev45", AXP_OPCODE_BASE },
  { "lca45", AXP_OPCODE_BASE },
  { "ev5", AXP_OPCODE_BASE },
  { "ev56", AXP_OPCODE_BASE|AXP_OPCODE_BWX },
  { "pca56", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX },
  { "ev6", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },
  { "ev67", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },
  { "ev68", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },

  { "all", AXP_OPCODE_BASE },
  { 0, 0 }
};

/* The macro table */

static const struct alpha_macro alpha_macros[] =
{
/* Load/Store macros */
  { "lda",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldah",	emit_ldah, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "ldl",	emit_ir_load, "ldl",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldl_l",	emit_ir_load, "ldl_l",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldq",	emit_ir_load, "ldq",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldq_l",	emit_ir_load, "ldq_l",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldq_u",	emit_ir_load, "ldq_u",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldf",	emit_loadstore, "ldf",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldg",	emit_loadstore, "ldg",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "lds",	emit_loadstore, "lds",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldt",	emit_loadstore, "ldt",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

  { "ldb",	emit_ldX, (PTR) 0,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldbu",	emit_ldXu, (PTR) 0,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldw",	emit_ldX, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ldwu",	emit_ldXu, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

  { "uldw",	emit_uldX, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldwu",	emit_uldXu, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldl",	emit_uldX, (PTR) 2,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldlu",	emit_uldXu, (PTR) 2,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "uldq",	emit_uldXu, (PTR) 3,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

  { "ldgp",	emit_ldgp, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA } },

  { "ldi",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldil",	emit_ldil, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldiq",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
#if 0
  { "ldif"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldid"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldig"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldis"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldit"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
#endif

  { "stl",	emit_loadstore, "stl",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stl_c",	emit_loadstore, "stl_c",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stq",	emit_loadstore, "stq",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stq_c",	emit_loadstore, "stq_c",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stq_u",	emit_loadstore, "stq_u",
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stf",	emit_loadstore, "stf",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stg",	emit_loadstore, "stg",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "sts",	emit_loadstore, "sts",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stt",	emit_loadstore, "stt",
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

  { "stb",	emit_stX, (PTR) 0,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "stw",	emit_stX, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ustw",	emit_ustX, (PTR) 1,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ustl",	emit_ustX, (PTR) 2,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
  { "ustq",	emit_ustX, (PTR) 3,
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },

/* Arithmetic macros */
#if 0
  { "absl"	emit_absl, 1, { IR } },
  { "absl"	emit_absl, 2, { IR, IR } },
  { "absl"	emit_absl, 2, { EXP, IR } },
  { "absq"	emit_absq, 1, { IR } },
  { "absq"	emit_absq, 2, { IR, IR } },
  { "absq"	emit_absq, 2, { EXP, IR } },
#endif

  { "sextb",	emit_sextX, (PTR) 0,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },
  { "sextw",	emit_sextX, (PTR) 1,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },

  { "divl",	emit_division, "__divl",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divlu",	emit_division, "__divlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divq",	emit_division, "__divq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divqu",	emit_division, "__divqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "reml",	emit_division, "__reml",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remlu",	emit_division, "__remlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remq",	emit_division, "__remq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remqu",	emit_division, "__remqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },

  { "jsr",	emit_jsrjmp, "jsr",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "jmp",	emit_jsrjmp, "jmp",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "ret",	emit_retjcr, "ret",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jcr",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jsr_coroutine",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
};

static const unsigned int alpha_num_macros
  = sizeof (alpha_macros) / sizeof (*alpha_macros);

/* Public interface functions */

/* This function is called once, at assembler startup time.  It sets
   up all the tables, etc. that the MD part of the assembler will
   need, that can be determined before arguments are parsed.  */

void
md_begin ()
{
  unsigned int i;

  /* Verify that X_op field is wide enough.  */
  {
    expressionS e;
    e.X_op = O_max;
    assert (e.X_op == O_max);
  }

  /* Create the opcode hash table.  */
  alpha_opcode_hash = hash_new ();
  for (i = 0; i < alpha_num_opcodes;)
    {
      const char *name, *retval, *slash;

      name = alpha_opcodes[i].name;
      retval = hash_insert (alpha_opcode_hash, name, (PTR) &alpha_opcodes[i]);
      if (retval)
	as_fatal (_("internal error: can't hash opcode `%s': %s"),
		  name, retval);

      /* Some opcodes include modifiers of various sorts with a "/mod"
	 syntax, like the architecture manual suggests.  However, for
	 use with gcc at least, we also need access to those same opcodes
	 without the "/".  */

      if ((slash = strchr (name, '/')) != NULL)
	{
	  char *p = xmalloc (strlen (name));
	  memcpy (p, name, slash - name);
	  strcpy (p + (slash - name), slash + 1);

	  (void) hash_insert (alpha_opcode_hash, p, (PTR) &alpha_opcodes[i]);
	  /* Ignore failures -- the opcode table does duplicate some
	     variants in different forms, like "hw_stq" and "hw_st/q".  */
	}

      while (++i < alpha_num_opcodes
	     && (alpha_opcodes[i].name == name
		 || !strcmp (alpha_opcodes[i].name, name)))
	continue;
    }

  /* Create the macro hash table.  */
  alpha_macro_hash = hash_new ();
  for (i = 0; i < alpha_num_macros;)
    {
      const char *name, *retval;

      name = alpha_macros[i].name;
      retval = hash_insert (alpha_macro_hash, name, (PTR) &alpha_macros[i]);
      if (retval)
	as_fatal (_("internal error: can't hash macro `%s': %s"),
		  name, retval);

      while (++i < alpha_num_macros
	     && (alpha_macros[i].name == name
		 || !strcmp (alpha_macros[i].name, name)))
	continue;
    }

  /* Construct symbols for each of the registers.  */
  for (i = 0; i < 32; ++i)
    {
      char name[4];

      sprintf (name, "$%d", i);
      alpha_register_table[i] = symbol_create (name, reg_section, i,
					       &zero_address_frag);
    }
  for (; i < 64; ++i)
    {
      char name[5];

      sprintf (name, "$f%d", i - 32);
      alpha_register_table[i] = symbol_create (name, reg_section, i,
					       &zero_address_frag);
    }

  /* Create the special symbols and sections we'll be using.  */

  /* So .sbss will get used for tiny objects.  */
  bfd_set_gp_size (stdoutput, g_switch_value);

#ifdef OBJ_ECOFF
  create_literal_section (".lita", &alpha_lita_section, &alpha_lita_symbol);

  /* For handling the GP, create a symbol that won't be output in the
     symbol table.  We'll edit it out of relocs later.  */
  alpha_gp_symbol = symbol_create ("<GP value>", alpha_lita_section, 0x8000,
				   &zero_address_frag);
#endif

#ifdef OBJ_EVAX
  create_literal_section (".link", &alpha_link_section, &alpha_link_symbol);
#endif

#ifdef OBJ_ELF
  if (ECOFF_DEBUGGING)
    {
      segT sec = subseg_new (".mdebug", (subsegT) 0);
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);
      bfd_set_section_alignment (stdoutput, sec, 3);
    }
#endif /* OBJ_ELF */

  /* Create literal lookup hash table.  */
  alpha_literal_hash = hash_new ();

  subseg_set (text_section, 0);
}

/* The public interface to the instruction assembler.  */

void
md_assemble (str)
     char *str;
{
  char opname[32];			/* Current maximum is 13.  */
  expressionS tok[MAX_INSN_ARGS];
  int ntok, trunclen;
  size_t opnamelen;

  /* Split off the opcode.  */
  opnamelen = strspn (str, "abcdefghijklmnopqrstuvwxyz_/46819");
  trunclen = (opnamelen < sizeof (opname) - 1
	      ? opnamelen
	      : sizeof (opname) - 1);
  memcpy (opname, str, trunclen);
  opname[trunclen] = '\0';

  /* Tokenize the rest of the line.  */
  if ((ntok = tokenize_arguments (str + opnamelen, tok, MAX_INSN_ARGS)) < 0)
    {
      if (ntok != TOKENIZE_ERROR_REPORT)
	as_bad (_("syntax error"));

      return;
    }

  /* Finish it off.  */
  assemble_tokens (opname, tok, ntok, alpha_macros_on);
}

/* Round up a section's size to the appropriate boundary.  */

valueT
md_section_align (seg, size)
     segT seg;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  valueT mask = ((valueT) 1 << align) - 1;

  return (size + mask) & ~mask;
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

extern char *vax_md_atof PARAMS ((int, char *, int *));

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
      /* VAX floats */
    case 'G':
      /* VAX md_atof doesn't like "G" for some reason.  */
      type = 'g';
    case 'F':
    case 'D':
      return vax_md_atof (type, litP, sizeP);

      /* IEEE floats */
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
}

/* Take care of the target-specific command-line options.  */

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
    {
    case 'F':
      alpha_nofloats_on = 1;
      break;

    case OPTION_32ADDR:
      alpha_addr32_on = 1;
      break;

    case 'g':
      alpha_debug = 1;
      break;

    case 'G':
      g_switch_value = atoi (arg);
      break;

    case 'm':
      {
	const struct cpu_type *p;
	for (p = cpu_types; p->name; ++p)
	  if (strcmp (arg, p->name) == 0)
	    {
	      alpha_target_name = p->name, alpha_target = p->flags;
	      goto found;
	    }
	as_warn (_("Unknown CPU identifier `%s'"), arg);
      found:;
      }
      break;

#ifdef OBJ_EVAX
    case '+':			/* For g++.  Hash any name > 63 chars long.  */
      alpha_flag_hash_long_names = 1;
      break;

    case 'H':			/* Show new symbol after hash truncation */
      alpha_flag_show_after_trunc = 1;
      break;

    case 'h':			/* for gnu-c/vax compatibility.  */
      break;
#endif

    case OPTION_RELAX:
      alpha_flag_relax = 1;
      break;

#ifdef OBJ_ELF
    case OPTION_MDEBUG:
      alpha_flag_mdebug = 1;
      break;
    case OPTION_NO_MDEBUG:
      alpha_flag_mdebug = 0;
      break;
#endif

    default:
      return 0;
    }

  return 1;
}

/* Print a description of the command-line options that we accept.  */

void
md_show_usage (stream)
     FILE *stream;
{
  fputs (_("\
Alpha options:\n\
-32addr			treat addresses as 32-bit values\n\
-F			lack floating point instructions support\n\
-mev4 | -mev45 | -mev5 | -mev56 | -mpca56 | -mev6 | -mev67 | -mev68 | -mall\n\
			specify variant of Alpha architecture\n\
-m21064 | -m21066 | -m21164 | -m21164a | -m21164pc | -m21264 | -m21264a | -m21264b\n\
			these variants include PALcode opcodes\n"),
	stream);
#ifdef OBJ_EVAX
  fputs (_("\
VMS options:\n\
-+			hash encode (don't truncate) names longer than 64 characters\n\
-H			show new symbol after hash truncation\n"),
	stream);
#endif
}

/* Decide from what point a pc-relative relocation is relative to,
   relative to the pc-relative fixup.  Er, relatively speaking.  */

long
md_pcrel_from (fixP)
     fixS *fixP;
{
  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_ALPHA_HINT:
    case BFD_RELOC_ALPHA_BRSGP:
      return addr + 4;
    default:
      return addr;
    }
}

/* Attempt to simplify or even eliminate a fixup.  The return value is
   ignored; perhaps it was once meaningful, but now it is historical.
   To indicate that a fixup has been eliminated, set fixP->fx_done.

   For ELF, here it is that we transform the GPDISP_HI16 reloc we used
   internally into the GPDISP reloc used externally.  We had to do
   this so that we'd have the GPDISP_LO16 reloc as a tag to compute
   the distance to the "lda" instruction for setting the addend to
   GPDISP.  */

void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg;
{
  char * const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;
  valueT value = * valP;
  unsigned image, size;

  switch (fixP->fx_r_type)
    {
      /* The GPDISP relocations are processed internally with a symbol
	 referring to the current function's section;  we need to drop
	 in a value which, when added to the address of the start of
	 the function, gives the desired GP.  */
    case BFD_RELOC_ALPHA_GPDISP_HI16:
      {
	fixS *next = fixP->fx_next;

	/* With user-specified !gpdisp relocations, we can be missing
	   the matching LO16 reloc.  We will have already issued an
	   error message.  */
	if (next)
	  fixP->fx_offset = (next->fx_frag->fr_address + next->fx_where
			     - fixP->fx_frag->fr_address - fixP->fx_where);

	value = (value - sign_extend_16 (value)) >> 16;
      }
#ifdef OBJ_ELF
      fixP->fx_r_type = BFD_RELOC_ALPHA_GPDISP;
#endif
      goto do_reloc_gp;

    case BFD_RELOC_ALPHA_GPDISP_LO16:
      value = sign_extend_16 (value);
      fixP->fx_offset = 0;
#ifdef OBJ_ELF
      fixP->fx_done = 1;
#endif

    do_reloc_gp:
      fixP->fx_addsy = section_symbol (seg);
      md_number_to_chars (fixpos, value, 2);
      break;

    case BFD_RELOC_16:
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_16_PCREL;
      size = 2;
      goto do_reloc_xx;
    case BFD_RELOC_32:
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_32_PCREL;
      size = 4;
      goto do_reloc_xx;
    case BFD_RELOC_64:
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_64_PCREL;
      size = 8;
    do_reloc_xx:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  md_number_to_chars (fixpos, value, size);
	  goto done;
	}
      return;

#ifdef OBJ_ECOFF
    case BFD_RELOC_GPREL32:
      assert (fixP->fx_subsy == alpha_gp_symbol);
      fixP->fx_subsy = 0;
      /* FIXME: inherited this obliviousness of `value' -- why? */
      md_number_to_chars (fixpos, -alpha_gp_value, 4);
      break;
#else
    case BFD_RELOC_GPREL32:
#endif
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
      return;

    case BFD_RELOC_23_PCREL_S2:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  image = bfd_getl32 (fixpos);
	  image = (image & ~0x1FFFFF) | ((value >> 2) & 0x1FFFFF);
	  goto write_done;
	}
      return;

    case BFD_RELOC_ALPHA_HINT:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  image = bfd_getl32 (fixpos);
	  image = (image & ~0x3FFF) | ((value >> 2) & 0x3FFF);
	  goto write_done;
	}
      return;

#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_BRSGP:
      return;

    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      if (fixP->fx_addsy)
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
      return;
#endif

#ifdef OBJ_ECOFF
    case BFD_RELOC_ALPHA_LITERAL:
      md_number_to_chars (fixpos, value, 2);
      return;
#endif
    case BFD_RELOC_ALPHA_ELF_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
      return;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return;

    default:
      {
	const struct alpha_operand *operand;

	if ((int) fixP->fx_r_type >= 0)
	  as_fatal (_("unhandled relocation type %s"),
		    bfd_get_reloc_code_name (fixP->fx_r_type));

	assert (-(int) fixP->fx_r_type < (int) alpha_num_operands);
	operand = &alpha_operands[-(int) fixP->fx_r_type];

	/* The rest of these fixups only exist internally during symbol
	   resolution and have no representation in the object file.
	   Therefore they must be completely resolved as constants.  */

	if (fixP->fx_addsy != 0
	    && S_GET_SEGMENT (fixP->fx_addsy) != absolute_section)
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("non-absolute expression in constant field"));

	image = bfd_getl32 (fixpos);
	image = insert_operand (image, operand, (offsetT) value,
				fixP->fx_file, fixP->fx_line);
      }
      goto write_done;
    }

  if (fixP->fx_addsy != 0 || fixP->fx_pcrel != 0)
    return;
  else
    {
      as_warn_where (fixP->fx_file, fixP->fx_line,
		     _("type %d reloc done?\n"), (int) fixP->fx_r_type);
      goto done;
    }

write_done:
  md_number_to_chars (fixpos, image, 4);

done:
  fixP->fx_done = 1;
}

/* Look for a register name in the given symbol.  */

symbolS *
md_undefined_symbol (name)
     char *name;
{
  if (*name == '$')
    {
      int is_float = 0, num;

      switch (*++name)
	{
	case 'f':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[AXP_REG_FP];
	  is_float = 32;
	  /* FALLTHRU */

	case 'r':
	  if (!ISDIGIT (*++name))
	    break;
	  /* FALLTHRU */

	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	  if (name[1] == '\0')
	    num = name[0] - '0';
	  else if (name[0] != '0' && ISDIGIT (name[1]) && name[2] == '\0')
	    {
	      num = (name[0] - '0') * 10 + name[1] - '0';
	      if (num >= 32)
		break;
	    }
	  else
	    break;

	  if (!alpha_noat_on && (num + is_float) == AXP_REG_AT)
	    as_warn (_("Used $at without \".set noat\""));
	  return alpha_register_table[num + is_float];

	case 'a':
	  if (name[1] == 't' && name[2] == '\0')
	    {
	      if (!alpha_noat_on)
		as_warn (_("Used $at without \".set noat\""));
	      return alpha_register_table[AXP_REG_AT];
	    }
	  break;

	case 'g':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[alpha_gp_register];
	  break;

	case 's':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[AXP_REG_SP];
	  break;
	}
    }
  return NULL;
}

#ifdef OBJ_ECOFF
/* @@@@@@ Magic ECOFF bits.  */

void
alpha_frob_ecoff_data ()
{
  select_gp_value ();
  /* $zero and $f31 are read-only */
  alpha_gprmask &= ~1;
  alpha_fprmask &= ~1;
}
#endif

/* Hook to remember a recently defined label so that the auto-align
   code can adjust the symbol after we know what alignment will be
   required.  */

void
alpha_define_label (sym)
     symbolS *sym;
{
  alpha_insn_label = sym;
}

/* Return true if we must always emit a reloc for a type and false if
   there is some hope of resolving it at assembly time.  */

int
alpha_force_relocation (f)
     fixS *f;
{
  if (alpha_flag_relax)
    return 1;

  switch (f->fx_r_type)
    {
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
    case BFD_RELOC_ALPHA_GPDISP:
    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_ELF_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_GPREL32:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
    case BFD_RELOC_ALPHA_BRSGP:
    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      return 1;

    default:
      break;
    }

  return generic_force_reloc (f);
}

/* Return true if we can partially resolve a relocation now.  */

int
alpha_fix_adjustable (f)
     fixS *f;
{
  /* Are there any relocation types for which we must generate a reloc
     but we can adjust the values contained within it?  */
  switch (f->fx_r_type)
    {
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
    case BFD_RELOC_ALPHA_GPDISP:
      return 0;

    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_ELF_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
      return 1;

    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      return 0;

    case BFD_RELOC_GPREL16:
    case BFD_RELOC_GPREL32:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_32:
    case BFD_RELOC_64:
    case BFD_RELOC_ALPHA_HINT:
      return 1;

    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      /* ??? No idea why we can't return a reference to .tbss+10, but
	 we're preventing this in the other assemblers.  Follow for now.  */
      return 0;

#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_BRSGP:
      /* If we have a BRSGP reloc to a local symbol, adjust it to BRADDR and
         let it get resolved at assembly time.  */
      {
	symbolS *sym = f->fx_addsy;
	const char *name;
	int offset = 0;

	if (generic_force_reloc (f))
	  return 0;

	switch (S_GET_OTHER (sym) & STO_ALPHA_STD_GPLOAD)
	  {
	  case STO_ALPHA_NOPV:
	    break;
	  case STO_ALPHA_STD_GPLOAD:
	    offset = 8;
	    break;
	  default:
	    if (S_IS_LOCAL (sym))
	      name = "<local>";
	    else
	      name = S_GET_NAME (sym);
	    as_bad_where (f->fx_file, f->fx_line,
		_("!samegp reloc against symbol without .prologue: %s"),
		name);
	    break;
	  }
	f->fx_r_type = BFD_RELOC_23_PCREL_S2;
	f->fx_offset += offset;
	return 1;
      }
#endif

    default:
      return 1;
    }
  /*NOTREACHED*/
}

/* Generate the BFD reloc to be stuck in the object file from the
   fixup used internally in the assembler.  */

arelent *
tc_gen_reloc (sec, fixp)
     asection *sec ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *reloc;

  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* Make sure none of our internal relocations make it this far.
     They'd better have been fully resolved by this point.  */
  assert ((int) fixp->fx_r_type > 0);

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent `%s' relocation in object file"),
		    bfd_get_reloc_code_name (fixp->fx_r_type));
      return NULL;
    }

  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
    {
      as_fatal (_("internal error? cannot generate `%s' relocation"),
		bfd_get_reloc_code_name (fixp->fx_r_type));
    }
  assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);

#ifdef OBJ_ECOFF
  if (fixp->fx_r_type == BFD_RELOC_ALPHA_LITERAL)
    {
      /* Fake out bfd_perform_relocation. sigh.  */
      reloc->addend = -alpha_gp_value;
    }
  else
#endif
    {
      reloc->addend = fixp->fx_offset;
#ifdef OBJ_ELF
      /* Ohhh, this is ugly.  The problem is that if this is a local global
         symbol, the relocation will entirely be performed at link time, not
         at assembly time.  bfd_perform_reloc doesn't know about this sort
         of thing, and as a result we need to fake it out here.  */
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_MERGE)
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_THREAD_LOCAL))
	  && !S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= symbol_get_bfdsym (fixp->fx_addsy)->value;
#endif
    }

  return reloc;
}

/* Parse a register name off of the input_line and return a register
   number.  Gets md_undefined_symbol above to do the register name
   matching for us.

   Only called as a part of processing the ECOFF .frame directive.  */

int
tc_get_register (frame)
     int frame ATTRIBUTE_UNUSED;
{
  int framereg = AXP_REG_SP;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
    {
      char *s = input_line_pointer;
      char c = get_symbol_end ();
      symbolS *sym = md_undefined_symbol (s);

      *strchr (s, '\0') = c;
      if (sym && (framereg = S_GET_VALUE (sym)) <= 31)
	goto found;
    }
  as_warn (_("frame reg expected, using $%d."), framereg);

found:
  note_gpreg (framereg);
  return framereg;
}

/* This is called before the symbol table is processed.  In order to
   work with gcc when using mips-tfile, we must keep all local labels.
   However, in other cases, we want to discard them.  If we were
   called with -g, but we didn't see any debugging information, it may
   mean that gcc is smuggling debugging information through to
   mips-tfile, in which case we must generate all local labels.  */

#ifdef OBJ_ECOFF

void
alpha_frob_file_before_adjust ()
{
  if (alpha_debug != 0
      && ! ecoff_debugging_seen)
    flag_keep_locals = 1;
}

#endif /* OBJ_ECOFF */

static struct alpha_reloc_tag *
get_alpha_reloc_tag (sequence)
     long sequence;
{
  char buffer[ALPHA_RELOC_DIGITS];
  struct alpha_reloc_tag *info;

  sprintf (buffer, "!%ld", sequence);

  info = (struct alpha_reloc_tag *) hash_find (alpha_literal_hash, buffer);
  if (! info)
    {
      size_t len = strlen (buffer);
      const char *errmsg;

      info = (struct alpha_reloc_tag *)
	xcalloc (sizeof (struct alpha_reloc_tag) + len, 1);

      info->segment = now_seg;
      info->sequence = sequence;
      strcpy (info->string, buffer);
      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR) info);
      if (errmsg)
	as_fatal (errmsg);
    }

  return info;
}

/* Before the relocations are written, reorder them, so that user
   supplied !lituse relocations follow the appropriate !literal
   relocations, and similarly for !gpdisp relocations.  */

void
alpha_before_fix ()
{
  if (alpha_literal_hash)
    bfd_map_over_sections (stdoutput, alpha_adjust_relocs, NULL);
}

static void
alpha_adjust_relocs (abfd, sec, ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR ptr ATTRIBUTE_UNUSED;
{
  segment_info_type *seginfo = seg_info (sec);
  fixS **prevP;
  fixS *fixp;
  fixS *next;
  fixS *slave;

  /* If seginfo is NULL, we did not create this section; don't do
     anything with it.  By using a pointer to a pointer, we can update
     the links in place.  */
  if (seginfo == NULL)
    return;

  /* If there are no relocations, skip the section.  */
  if (! seginfo->fix_root)
    return;

  /* First rebuild the fixup chain without the explicit lituse and
     gpdisp_lo16 relocs.  */
  prevP = &seginfo->fix_root;
  for (fixp = seginfo->fix_root; fixp; fixp = next)
    {
      next = fixp->fx_next;
      fixp->fx_next = (fixS *) 0;

      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_ALPHA_LITUSE:
	  if (fixp->tc_fix_data.info->n_master == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No !literal!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
#ifdef RELOC_OP_P
	  if (fixp->fx_offset == LITUSE_ALPHA_TLSGD)
	    {
	      if (! fixp->tc_fix_data.info->saw_tlsgd)
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("No !tlsgd!%ld was found"),
			      fixp->tc_fix_data.info->sequence);
	    }
	  else if (fixp->fx_offset == LITUSE_ALPHA_TLSLDM)
	    {
	      if (! fixp->tc_fix_data.info->saw_tlsldm)
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("No !tlsldm!%ld was found"),
			      fixp->tc_fix_data.info->sequence);
	    }
#endif
	  break;

	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  if (fixp->tc_fix_data.info->n_master == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No ldah !gpdisp!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
	  break;

	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  if (fixp->tc_fix_data.info
	      && (fixp->tc_fix_data.info->saw_tlsgd
	          || fixp->tc_fix_data.info->saw_tlsldm))
	    break;
	  /* FALLTHRU */

	default:
	  *prevP = fixp;
	  prevP = &fixp->fx_next;
	  break;
	}
    }

  /* Go back and re-chain dependent relocations.  They are currently
     linked through the next_reloc field in reverse order, so as we
     go through the next_reloc chain, we effectively reverse the chain
     once again.

     Except if there is more than one !literal for a given sequence
     number.  In that case, the programmer and/or compiler is not sure
     how control flows from literal to lituse, and we can't be sure to
     get the relaxation correct.

     ??? Well, actually we could, if there are enough lituses such that
     we can make each literal have at least one of each lituse type
     present.  Not implemented.

     Also suppress the optimization if the !literals/!lituses are spread
     in different segments.  This can happen with "intersting" uses of
     inline assembly; examples are present in the Linux kernel semaphores.  */

  for (fixp = seginfo->fix_root; fixp; fixp = next)
    {
      next = fixp->fx_next;
      switch (fixp->fx_r_type)
	{
	case BFD_RELOC_ALPHA_TLSGD:
	case BFD_RELOC_ALPHA_TLSLDM:
	  if (!fixp->tc_fix_data.info)
	    break;
	  if (fixp->tc_fix_data.info->n_master == 0)
	    break;
	  else if (fixp->tc_fix_data.info->n_master > 1)
	    {
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("too many !literal!%ld for %s"),
			    fixp->tc_fix_data.info->sequence,
			    (fixp->fx_r_type == BFD_RELOC_ALPHA_TLSGD
			     ? "!tlsgd" : "!tlsldm"));
	      break;
	    }

	  fixp->tc_fix_data.info->master->fx_next = fixp->fx_next;
	  fixp->fx_next = fixp->tc_fix_data.info->master;
	  fixp = fixp->fx_next;
	  /* FALLTHRU */

	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  if (fixp->tc_fix_data.info
	      && fixp->tc_fix_data.info->n_master == 1
	      && ! fixp->tc_fix_data.info->multi_section_p)
	    {
	      for (slave = fixp->tc_fix_data.info->slaves;
		   slave != (fixS *) 0;
		   slave = slave->tc_fix_data.next_reloc)
		{
		  slave->fx_next = fixp->fx_next;
		  fixp->fx_next = slave;
		}
	    }
	  break;

	case BFD_RELOC_ALPHA_GPDISP_HI16:
	  if (fixp->tc_fix_data.info->n_slaves == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No lda !gpdisp!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
	  else
	    {
	      slave = fixp->tc_fix_data.info->slaves;
	      slave->fx_next = next;
	      fixp->fx_next = slave;
	    }
	  break;

	default:
	  break;
	}
    }
}

#ifdef DEBUG_ALPHA
static void
debug_exp (tok, ntok)
     expressionS tok[];
     int ntok;
{
  int i;

  fprintf (stderr, "debug_exp: %d tokens", ntok);
  for (i = 0; i < ntok; i++)
    {
      expressionS *t = &tok[i];
      const char *name;

      switch (t->X_op)
	{
	default:			name = "unknown";		break;
	case O_illegal:			name = "O_illegal";		break;
	case O_absent:			name = "O_absent";		break;
	case O_constant:		name = "O_constant";		break;
	case O_symbol:			name = "O_symbol";		break;
	case O_symbol_rva:		name = "O_symbol_rva";		break;
	case O_register:		name = "O_register";		break;
	case O_big:			name = "O_big";			break;
	case O_uminus:			name = "O_uminus";		break;
	case O_bit_not:			name = "O_bit_not";		break;
	case O_logical_not:		name = "O_logical_not";		break;
	case O_multiply:		name = "O_multiply";		break;
	case O_divide:			name = "O_divide";		break;
	case O_modulus:			name = "O_modulus";		break;
	case O_left_shift:		name = "O_left_shift";		break;
	case O_right_shift:		name = "O_right_shift";		break;
	case O_bit_inclusive_or:	name = "O_bit_inclusive_or";	break;
	case O_bit_or_not:		name = "O_bit_or_not";		break;
	case O_bit_exclusive_or:	name = "O_bit_exclusive_or";	break;
	case O_bit_and:			name = "O_bit_and";		break;
	case O_add:			name = "O_add";			break;
	case O_subtract:		name = "O_subtract";		break;
	case O_eq:			name = "O_eq";			break;
	case O_ne:			name = "O_ne";			break;
	case O_lt:			name = "O_lt";			break;
	case O_le:			name = "O_le";			break;
	case O_ge:			name = "O_ge";			break;
	case O_gt:			name = "O_gt";			break;
	case O_logical_and:		name = "O_logical_and";		break;
	case O_logical_or:		name = "O_logical_or";		break;
	case O_index:			name = "O_index";		break;
	case O_pregister:		name = "O_pregister";		break;
	case O_cpregister:		name = "O_cpregister";		break;
	case O_literal:			name = "O_literal";		break;
	case O_lituse_addr:		name = "O_lituse_addr";		break;
	case O_lituse_base:		name = "O_lituse_base";		break;
	case O_lituse_bytoff:		name = "O_lituse_bytoff";	break;
	case O_lituse_jsr:		name = "O_lituse_jsr";		break;
	case O_lituse_tlsgd:		name = "O_lituse_tlsgd";	break;
	case O_lituse_tlsldm:		name = "O_lituse_tlsldm";	break;
	case O_gpdisp:			name = "O_gpdisp";		break;
	case O_gprelhigh:		name = "O_gprelhigh";		break;
	case O_gprellow:		name = "O_gprellow";		break;
	case O_gprel:			name = "O_gprel";		break;
	case O_samegp:			name = "O_samegp";		break;
	case O_tlsgd:			name = "O_tlsgd";		break;
	case O_tlsldm:			name = "O_tlsldm";		break;
	case O_gotdtprel:		name = "O_gotdtprel";		break;
	case O_dtprelhi:		name = "O_dtprelhi";		break;
	case O_dtprello:		name = "O_dtprello";		break;
	case O_dtprel:			name = "O_dtprel";		break;
	case O_gottprel:		name = "O_gottprel";		break;
	case O_tprelhi:			name = "O_tprelhi";		break;
	case O_tprello:			name = "O_tprello";		break;
	case O_tprel:			name = "O_tprel";		break;
	}

      fprintf (stderr, ", %s(%s, %s, %d)", name,
	       (t->X_add_symbol) ? S_GET_NAME (t->X_add_symbol) : "--",
	       (t->X_op_symbol) ? S_GET_NAME (t->X_op_symbol) : "--",
	       (int) t->X_add_number);
    }
  fprintf (stderr, "\n");
  fflush (stderr);
}
#endif

/* Parse the arguments to an opcode.  */

static int
tokenize_arguments (str, tok, ntok)
     char *str;
     expressionS tok[];
     int ntok;
{
  expressionS *end_tok = tok + ntok;
  char *old_input_line_pointer;
  int saw_comma = 0, saw_arg = 0;
#ifdef DEBUG_ALPHA
  expressionS *orig_tok = tok;
#endif
#ifdef RELOC_OP_P
  char *p;
  const struct alpha_reloc_op_tag *r;
  int c, i;
  size_t len;
  int reloc_found_p = 0;
#endif

  memset (tok, 0, sizeof (*tok) * ntok);

  /* Save and restore input_line_pointer around this function.  */
  old_input_line_pointer = input_line_pointer;
  input_line_pointer = str;

#ifdef RELOC_OP_P
  /* ??? Wrest control of ! away from the regular expression parser.  */
  is_end_of_line[(unsigned char) '!'] = 1;
#endif

  while (tok < end_tok && *input_line_pointer)
    {
      SKIP_WHITESPACE ();
      switch (*input_line_pointer)
	{
	case '\0':
	  goto fini;

#ifdef RELOC_OP_P
	case '!':
	  /* A relocation operand can be placed after the normal operand on an
	     assembly language statement, and has the following form:
		!relocation_type!sequence_number.  */
	  if (reloc_found_p)
	    {
	      /* Only support one relocation op per insn.  */
	      as_bad (_("More than one relocation op per insn"));
	      goto err_report;
	    }

	  if (!saw_arg)
	    goto err;

	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  p = input_line_pointer;
	  c = get_symbol_end ();

	  /* Parse !relocation_type.  */
	  len = input_line_pointer - p;
	  if (len == 0)
	    {
	      as_bad (_("No relocation operand"));
	      goto err_report;
	    }

	  r = &alpha_reloc_op[0];
	  for (i = alpha_num_reloc_op - 1; i >= 0; i--, r++)
	    if (len == r->length && memcmp (p, r->name, len) == 0)
	      break;
	  if (i < 0)
	    {
	      as_bad (_("Unknown relocation operand: !%s"), p);
	      goto err_report;
	    }

	  *input_line_pointer = c;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer != '!')
	    {
	      if (r->require_seq)
		{
		  as_bad (_("no sequence number after !%s"), p);
		  goto err_report;
		}

	      tok->X_add_number = 0;
	    }
	  else
	    {
	      if (! r->allow_seq)
		{
		  as_bad (_("!%s does not use a sequence number"), p);
		  goto err_report;
		}

	      input_line_pointer++;

	      /* Parse !sequence_number.  */
	      expression (tok);
	      if (tok->X_op != O_constant || tok->X_add_number <= 0)
		{
		  as_bad (_("Bad sequence number: !%s!%s"),
			  r->name, input_line_pointer);
		  goto err_report;
		}
	    }

	  tok->X_op = r->op;
	  reloc_found_p = 1;
	  ++tok;
	  break;
#endif /* RELOC_OP_P */

	case ',':
	  ++input_line_pointer;
	  if (saw_comma || !saw_arg)
	    goto err;
	  saw_comma = 1;
	  break;

	case '(':
	  {
	    char *hold = input_line_pointer++;

	    /* First try for parenthesized register ...  */
	    expression (tok);
	    if (*input_line_pointer == ')' && tok->X_op == O_register)
	      {
		tok->X_op = (saw_comma ? O_cpregister : O_pregister);
		saw_comma = 0;
		saw_arg = 1;
		++input_line_pointer;
		++tok;
		break;
	      }

	    /* ... then fall through to plain expression.  */
	    input_line_pointer = hold;
	  }

	default:
	  if (saw_arg && !saw_comma)
	    goto err;

	  expression (tok);
	  if (tok->X_op == O_illegal || tok->X_op == O_absent)
	    goto err;

	  saw_comma = 0;
	  saw_arg = 1;
	  ++tok;
	  break;
	}
    }

fini:
  if (saw_comma)
    goto err;
  input_line_pointer = old_input_line_pointer;

#ifdef DEBUG_ALPHA
  debug_exp (orig_tok, ntok - (end_tok - tok));
#endif
#ifdef RELOC_OP_P
  is_end_of_line[(unsigned char) '!'] = 0;
#endif

  return ntok - (end_tok - tok);

err:
#ifdef RELOC_OP_P
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
  input_line_pointer = old_input_line_pointer;
  return TOKENIZE_ERROR;

#ifdef RELOC_OP_P
err_report:
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
  input_line_pointer = old_input_line_pointer;
  return TOKENIZE_ERROR_REPORT;
}

/* Search forward through all variants of an opcode looking for a
   syntax match.  */

static const struct alpha_opcode *
find_opcode_match (first_opcode, tok, pntok, pcpumatch)
     const struct alpha_opcode *first_opcode;
     const expressionS *tok;
     int *pntok;
     int *pcpumatch;
{
  const struct alpha_opcode *opcode = first_opcode;
  int ntok = *pntok;
  int got_cpu_match = 0;

  do
    {
      const unsigned char *opidx;
      int tokidx = 0;

      /* Don't match opcodes that don't exist on this architecture.  */
      if (!(opcode->flags & alpha_target))
	goto match_failed;

      got_cpu_match = 1;

      for (opidx = opcode->operands; *opidx; ++opidx)
	{
	  const struct alpha_operand *operand = &alpha_operands[*opidx];

	  /* Only take input from real operands.  */
	  if (operand->flags & AXP_OPERAND_FAKE)
	    continue;

	  /* When we expect input, make sure we have it.  */
	  if (tokidx >= ntok)
	    {
	      if ((operand->flags & AXP_OPERAND_OPTIONAL_MASK) == 0)
		goto match_failed;
	      continue;
	    }

	  /* Match operand type with expression type.  */
	  switch (operand->flags & AXP_OPERAND_TYPECHECK_MASK)
	    {
	    case AXP_OPERAND_IR:
	      if (tok[tokidx].X_op != O_register
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_FPR:
	      if (tok[tokidx].X_op != O_register
		  || !is_fpr_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_IR | AXP_OPERAND_PARENS:
	      if (tok[tokidx].X_op != O_pregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_IR | AXP_OPERAND_PARENS | AXP_OPERAND_COMMA:
	      if (tok[tokidx].X_op != O_cpregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      break;

	    case AXP_OPERAND_RELATIVE:
	    case AXP_OPERAND_SIGNED:
	    case AXP_OPERAND_UNSIGNED:
	      switch (tok[tokidx].X_op)
		{
		case O_illegal:
		case O_absent:
		case O_register:
		case O_pregister:
		case O_cpregister:
		  goto match_failed;

		default:
		  break;
		}
	      break;

	    default:
	      /* Everything else should have been fake.  */
	      abort ();
	    }
	  ++tokidx;
	}

      /* Possible match -- did we use all of our input?  */
      if (tokidx == ntok)
	{
	  *pntok = ntok;
	  return opcode;
	}

    match_failed:;
    }
  while (++opcode - alpha_opcodes < (int) alpha_num_opcodes
	 && !strcmp (opcode->name, first_opcode->name));

  if (*pcpumatch)
    *pcpumatch = got_cpu_match;

  return NULL;
}

/* Search forward through all variants of a macro looking for a syntax
   match.  */

static const struct alpha_macro *
find_macro_match (first_macro, tok, pntok)
     const struct alpha_macro *first_macro;
     const expressionS *tok;
     int *pntok;
{
  const struct alpha_macro *macro = first_macro;
  int ntok = *pntok;

  do
    {
      const enum alpha_macro_arg *arg = macro->argsets;
      int tokidx = 0;

      while (*arg)
	{
	  switch (*arg)
	    {
	    case MACRO_EOA:
	      if (tokidx == ntok)
		return macro;
	      else
		tokidx = 0;
	      break;

	      /* Index register.  */
	    case MACRO_IR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_register
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;

	      /* Parenthesized index register.  */
	    case MACRO_PIR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_pregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;

	      /* Optional parenthesized index register.  */
	    case MACRO_OPIR:
	      if (tokidx < ntok && tok[tokidx].X_op == O_pregister
		  && is_ir_num (tok[tokidx].X_add_number))
		++tokidx;
	      break;

	      /* Leading comma with a parenthesized index register.  */
	    case MACRO_CPIR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_cpregister
		  || !is_ir_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;

	      /* Floating point register.  */
	    case MACRO_FPR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_register
		  || !is_fpr_num (tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;

	      /* Normal expression.  */
	    case MACRO_EXP:
	      if (tokidx >= ntok)
		goto match_failed;
	      switch (tok[tokidx].X_op)
		{
		case O_illegal:
		case O_absent:
		case O_register:
		case O_pregister:
		case O_cpregister:
		case O_literal:
		case O_lituse_base:
		case O_lituse_bytoff:
		case O_lituse_jsr:
		case O_gpdisp:
		case O_gprelhigh:
		case O_gprellow:
		case O_gprel:
		case O_samegp:
		  goto match_failed;

		default:
		  break;
		}
	      ++tokidx;
	      break;

	    match_failed:
	      while (*arg != MACRO_EOA)
		++arg;
	      tokidx = 0;
	      break;
	    }
	  ++arg;
	}
    }
  while (++macro - alpha_macros < (int) alpha_num_macros
	 && !strcmp (macro->name, first_macro->name));

  return NULL;
}

/* Insert an operand value into an instruction.  */

static unsigned
insert_operand (insn, operand, val, file, line)
     unsigned insn;
     const struct alpha_operand *operand;
     offsetT val;
     char *file;
     unsigned line;
{
  if (operand->bits != 32 && !(operand->flags & AXP_OPERAND_NOOVERFLOW))
    {
      offsetT min, max;

      if (operand->flags & AXP_OPERAND_SIGNED)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = -(1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      if (val < min || val > max)
	{
	  const char *err =
	    _("operand out of range (%s not between %d and %d)");
	  char buf[sizeof (val) * 3 + 2];

	  sprint_value (buf, val);
	  if (file)
	    as_warn_where (file, line, err, buf, min, max);
	  else
	    as_warn (err, buf, min, max);
	}
    }

  if (operand->insert)
    {
      const char *errmsg = NULL;

      insn = (*operand->insert) (insn, val, &errmsg);
      if (errmsg)
	as_warn ("%s", errmsg);
    }
  else
    insn |= ((val & ((1 << operand->bits) - 1)) << operand->shift);

  return insn;
}

/* Turn an opcode description and a set of arguments into
   an instruction and a fixup.  */

static void
assemble_insn (opcode, tok, ntok, insn, reloc)
     const struct alpha_opcode *opcode;
     const expressionS *tok;
     int ntok;
     struct alpha_insn *insn;
     bfd_reloc_code_real_type reloc;
{
  const struct alpha_operand *reloc_operand = NULL;
  const expressionS *reloc_exp = NULL;
  const unsigned char *argidx;
  unsigned image;
  int tokidx = 0;

  memset (insn, 0, sizeof (*insn));
  image = opcode->opcode;

  for (argidx = opcode->operands; *argidx; ++argidx)
    {
      const struct alpha_operand *operand = &alpha_operands[*argidx];
      const expressionS *t = (const expressionS *) 0;

      if (operand->flags & AXP_OPERAND_FAKE)
	{
	  /* fake operands take no value and generate no fixup */
	  image = insert_operand (image, operand, 0, NULL, 0);
	  continue;
	}

      if (tokidx >= ntok)
	{
	  switch (operand->flags & AXP_OPERAND_OPTIONAL_MASK)
	    {
	    case AXP_OPERAND_DEFAULT_FIRST:
	      t = &tok[0];
	      break;
	    case AXP_OPERAND_DEFAULT_SECOND:
	      t = &tok[1];
	      break;
	    case AXP_OPERAND_DEFAULT_ZERO:
	      {
		static expressionS zero_exp;
		t = &zero_exp;
		zero_exp.X_op = O_constant;
		zero_exp.X_unsigned = 1;
	      }
	      break;
	    default:
	      abort ();
	    }
	}
      else
	t = &tok[tokidx++];

      switch (t->X_op)
	{
	case O_register:
	case O_pregister:
	case O_cpregister:
	  image = insert_operand (image, operand, regno (t->X_add_number),
				  NULL, 0);
	  break;

	case O_constant:
	  image = insert_operand (image, operand, t->X_add_number, NULL, 0);
	  assert (reloc_operand == NULL);
	  reloc_operand = operand;
	  reloc_exp = t;
	  break;

	default:
	  /* This is only 0 for fields that should contain registers,
	     which means this pattern shouldn't have matched.  */
	  if (operand->default_reloc == 0)
	    abort ();

	  /* There is one special case for which an insn receives two
	     relocations, and thus the user-supplied reloc does not
	     override the operand reloc.  */
	  if (operand->default_reloc == BFD_RELOC_ALPHA_HINT)
	    {
	      struct alpha_fixup *fixup;

	      if (insn->nfixups >= MAX_INSN_FIXUPS)
		as_fatal (_("too many fixups"));

	      fixup = &insn->fixups[insn->nfixups++];
	      fixup->exp = *t;
	      fixup->reloc = BFD_RELOC_ALPHA_HINT;
	    }
	  else
	    {
	      if (reloc == BFD_RELOC_UNUSED)
		reloc = operand->default_reloc;

	      assert (reloc_operand == NULL);
	      reloc_operand = operand;
	      reloc_exp = t;
	    }
	  break;
	}
    }

  if (reloc != BFD_RELOC_UNUSED)
    {
      struct alpha_fixup *fixup;

      if (insn->nfixups >= MAX_INSN_FIXUPS)
	as_fatal (_("too many fixups"));

      /* ??? My but this is hacky.  But the OSF/1 assembler uses the same
	 relocation tag for both ldah and lda with gpdisp.  Choose the
	 correct internal relocation based on the opcode.  */
      if (reloc == BFD_RELOC_ALPHA_GPDISP)
	{
	  if (strcmp (opcode->name, "ldah") == 0)
	    reloc = BFD_RELOC_ALPHA_GPDISP_HI16;
	  else if (strcmp (opcode->name, "lda") == 0)
	    reloc = BFD_RELOC_ALPHA_GPDISP_LO16;
	  else
	    as_bad (_("invalid relocation for instruction"));
	}

      /* If this is a real relocation (as opposed to a lituse hint), then
	 the relocation width should match the operand width.  */
      else if (reloc < BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto
	    = bfd_reloc_type_lookup (stdoutput, reloc);
	  if (reloc_howto->bitsize != reloc_operand->bits)
	    {
	      as_bad (_("invalid relocation for field"));
	      return;
	    }
	}

      fixup = &insn->fixups[insn->nfixups++];
      if (reloc_exp)
	fixup->exp = *reloc_exp;
      else
	fixup->exp.X_op = O_absent;
      fixup->reloc = reloc;
    }

  insn->insn = image;
}

/* Actually output an instruction with its fixup.  */

static void
emit_insn (insn)
     struct alpha_insn *insn;
{
  char *f;
  int i;

  /* Take care of alignment duties.  */
  if (alpha_auto_align_on && alpha_current_align < 2)
    alpha_align (2, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > 2)
    alpha_current_align = 2;
  alpha_insn_label = NULL;

  /* Write out the instruction.  */
  f = frag_more (4);
  md_number_to_chars (f, insn->insn, 4);

#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif

  /* Apply the fixups in order.  */
  for (i = 0; i < insn->nfixups; ++i)
    {
      const struct alpha_operand *operand = (const struct alpha_operand *) 0;
      struct alpha_fixup *fixup = &insn->fixups[i];
      struct alpha_reloc_tag *info = NULL;
      int size, pcrel;
      fixS *fixP;

      /* Some fixups are only used internally and so have no howto.  */
      if ((int) fixup->reloc < 0)
	{
	  operand = &alpha_operands[-(int) fixup->reloc];
	  size = 4;
	  pcrel = ((operand->flags & AXP_OPERAND_RELATIVE) != 0);
	}
      else if (fixup->reloc > BFD_RELOC_UNUSED
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_HI16
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_LO16)
	{
	  size = 2;
	  pcrel = 0;
	}
      else
	{
	  reloc_howto_type *reloc_howto
	    = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	  assert (reloc_howto);

	  size = bfd_get_reloc_size (reloc_howto);
	  assert (size >= 1 && size <= 4);

	  pcrel = reloc_howto->pc_relative;
	}

      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal, size,
			  &fixup->exp, pcrel, fixup->reloc);

      /* Turn off complaints that the addend is too large for some fixups,
         and copy in the sequence number for the explicit relocations.  */
      switch (fixup->reloc)
	{
	case BFD_RELOC_ALPHA_HINT:
	case BFD_RELOC_GPREL32:
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_ALPHA_GPREL_HI16:
	case BFD_RELOC_ALPHA_GPREL_LO16:
	case BFD_RELOC_ALPHA_GOTDTPREL16:
	case BFD_RELOC_ALPHA_DTPREL_HI16:
	case BFD_RELOC_ALPHA_DTPREL_LO16:
	case BFD_RELOC_ALPHA_DTPREL16:
	case BFD_RELOC_ALPHA_GOTTPREL16:
	case BFD_RELOC_ALPHA_TPREL_HI16:
	case BFD_RELOC_ALPHA_TPREL_LO16:
	case BFD_RELOC_ALPHA_TPREL16:
	  fixP->fx_no_overflow = 1;
	  break;

	case BFD_RELOC_ALPHA_GPDISP_HI16:
	  fixP->fx_no_overflow = 1;
	  fixP->fx_addsy = section_symbol (now_seg);
	  fixP->fx_offset = 0;

	  info = get_alpha_reloc_tag (insn->sequence);
	  if (++info->n_master > 1)
	    as_bad (_("too many ldah insns for !gpdisp!%ld"), insn->sequence);
	  if (info->segment != now_seg)
	    as_bad (_("both insns for !gpdisp!%ld must be in the same section"),
		    insn->sequence);
	  fixP->tc_fix_data.info = info;
	  break;

	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  fixP->fx_no_overflow = 1;

	  info = get_alpha_reloc_tag (insn->sequence);
	  if (++info->n_slaves > 1)
	    as_bad (_("too many lda insns for !gpdisp!%ld"), insn->sequence);
	  if (info->segment != now_seg)
	    as_bad (_("both insns for !gpdisp!%ld must be in the same section"),
		    insn->sequence);
	  fixP->tc_fix_data.info = info;
	  info->slaves = fixP;
	  break;

	case BFD_RELOC_ALPHA_LITERAL:
	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  fixP->fx_no_overflow = 1;

	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  info->master = fixP;
	  info->n_master++;
	  if (info->segment != now_seg)
	    info->multi_section_p = 1;
	  fixP->tc_fix_data.info = info;
	  break;

#ifdef RELOC_OP_P
	case DUMMY_RELOC_LITUSE_ADDR:
	  fixP->fx_offset = LITUSE_ALPHA_ADDR;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_BASE:
	  fixP->fx_offset = LITUSE_ALPHA_BASE;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_BYTOFF:
	  fixP->fx_offset = LITUSE_ALPHA_BYTOFF;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_JSR:
	  fixP->fx_offset = LITUSE_ALPHA_JSR;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_TLSGD:
	  fixP->fx_offset = LITUSE_ALPHA_TLSGD;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_TLSLDM:
	  fixP->fx_offset = LITUSE_ALPHA_TLSLDM;
	  goto do_lituse;
	do_lituse:
	  fixP->fx_addsy = section_symbol (now_seg);
	  fixP->fx_r_type = BFD_RELOC_ALPHA_LITUSE;

	  info = get_alpha_reloc_tag (insn->sequence);
	  if (fixup->reloc == DUMMY_RELOC_LITUSE_TLSGD)
	    info->saw_lu_tlsgd = 1;
	  else if (fixup->reloc == DUMMY_RELOC_LITUSE_TLSLDM)
	    info->saw_lu_tlsldm = 1;
	  if (++info->n_slaves > 1)
	    {
	      if (info->saw_lu_tlsgd)
		as_bad (_("too many lituse insns for !lituse_tlsgd!%ld"),
		        insn->sequence);
	      else if (info->saw_lu_tlsldm)
		as_bad (_("too many lituse insns for !lituse_tlsldm!%ld"),
		        insn->sequence);
	    }
	  fixP->tc_fix_data.info = info;
	  fixP->tc_fix_data.next_reloc = info->slaves;
	  info->slaves = fixP;
	  if (info->segment != now_seg)
	    info->multi_section_p = 1;
	  break;

	case BFD_RELOC_ALPHA_TLSGD:
	  fixP->fx_no_overflow = 1;

	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (info->saw_tlsgd)
	    as_bad (_("duplicate !tlsgd!%ld"), insn->sequence);
	  else if (info->saw_tlsldm)
	    as_bad (_("sequence number in use for !tlsldm!%ld"),
		    insn->sequence);
	  else
	    info->saw_tlsgd = 1;
	  fixP->tc_fix_data.info = info;
	  break;

	case BFD_RELOC_ALPHA_TLSLDM:
	  fixP->fx_no_overflow = 1;

	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (info->saw_tlsldm)
	    as_bad (_("duplicate !tlsldm!%ld"), insn->sequence);
	  else if (info->saw_tlsgd)
	    as_bad (_("sequence number in use for !tlsgd!%ld"),
		    insn->sequence);
	  else
	    info->saw_tlsldm = 1;
	  fixP->tc_fix_data.info = info;
	  break;
#endif
	default:
	  if ((int) fixup->reloc < 0)
	    {
	      if (operand->flags & AXP_OPERAND_NOOVERFLOW)
		fixP->fx_no_overflow = 1;
	    }
	  break;
	}
    }
}

/* Given an opcode name and a pre-tokenized set of arguments, assemble
   the insn, but do not emit it.

   Note that this implies no macros allowed, since we can't store more
   than one insn in an insn structure.  */

static void
assemble_tokens_to_insn (opname, tok, ntok, insn)
     const char *opname;
     const expressionS *tok;
     int ntok;
     struct alpha_insn *insn;
{
  const struct alpha_opcode *opcode;

  /* search opcodes */
  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);
  if (opcode)
    {
      int cpumatch;
      opcode = find_opcode_match (opcode, tok, &ntok, &cpumatch);
      if (opcode)
	{
	  assemble_insn (opcode, tok, ntok, insn, BFD_RELOC_UNUSED);
	  return;
	}
      else if (cpumatch)
	as_bad (_("inappropriate arguments for opcode `%s'"), opname);
      else
	as_bad (_("opcode `%s' not supported for target %s"), opname,
		alpha_target_name);
    }
  else
    as_bad (_("unknown opcode `%s'"), opname);
}

/* Given an opcode name and a pre-tokenized set of arguments, take the
   opcode all the way through emission.  */

static void
assemble_tokens (opname, tok, ntok, local_macros_on)
     const char *opname;
     const expressionS *tok;
     int ntok;
     int local_macros_on;
{
  int found_something = 0;
  const struct alpha_opcode *opcode;
  const struct alpha_macro *macro;
  int cpumatch = 1;
  bfd_reloc_code_real_type reloc = BFD_RELOC_UNUSED;

#ifdef RELOC_OP_P
  /* If a user-specified relocation is present, this is not a macro.  */
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      reloc = ALPHA_RELOC_TABLE (tok[ntok - 1].X_op)->reloc;
      ntok--;
    }
  else
#endif
  if (local_macros_on)
    {
      macro = ((const struct alpha_macro *)
	       hash_find (alpha_macro_hash, opname));
      if (macro)
	{
	  found_something = 1;
	  macro = find_macro_match (macro, tok, &ntok);
	  if (macro)
	    {
	      (*macro->emit) (tok, ntok, macro->arg);
	      return;
	    }
	}
    }

  /* Search opcodes.  */
  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);
  if (opcode)
    {
      found_something = 1;
      opcode = find_opcode_match (opcode, tok, &ntok, &cpumatch);
      if (opcode)
	{
	  struct alpha_insn insn;
	  assemble_insn (opcode, tok, ntok, &insn, reloc);

	  /* Copy the sequence number for the reloc from the reloc token.  */
	  if (reloc != BFD_RELOC_UNUSED)
	    insn.sequence = tok[ntok].X_add_number;

	  emit_insn (&insn);
	  return;
	}
    }

  if (found_something)
    {
      if (cpumatch)
	as_bad (_("inappropriate arguments for opcode `%s'"), opname);
      else
	as_bad (_("opcode `%s' not supported for target %s"), opname,
		alpha_target_name);
    }
  else
    as_bad (_("unknown opcode `%s'"), opname);
}

/* Some instruction sets indexed by lg(size).  */
static const char * const sextX_op[] = { "sextb", "sextw", "sextl", NULL };
static const char * const insXl_op[] = { "insbl", "inswl", "insll", "insql" };
static const char * const insXh_op[] = { NULL,    "inswh", "inslh", "insqh" };
static const char * const extXl_op[] = { "extbl", "extwl", "extll", "extql" };
static const char * const extXh_op[] = { NULL,    "extwh", "extlh", "extqh" };
static const char * const mskXl_op[] = { "mskbl", "mskwl", "mskll", "mskql" };
static const char * const mskXh_op[] = { NULL,    "mskwh", "msklh", "mskqh" };
static const char * const stX_op[] = { "stb", "stw", "stl", "stq" };
static const char * const ldXu_op[] = { "ldbu", "ldwu", NULL, NULL };

/* Implement the ldgp macro.  */

static void
emit_ldgp (tok, ntok, unused)
     const expressionS *tok;
     int ntok ATTRIBUTE_UNUSED;
     const PTR unused ATTRIBUTE_UNUSED;
{
#ifdef OBJ_AOUT
FIXME
#endif
#if defined(OBJ_ECOFF) || defined(OBJ_ELF)
  /* from "ldgp r1,n(r2)", generate "ldah r1,X(R2); lda r1,Y(r1)"
     with appropriate constants and relocations.  */
  struct alpha_insn insn;
  expressionS newtok[3];
  expressionS addend;

#ifdef OBJ_ECOFF
  if (regno (tok[2].X_add_number) == AXP_REG_PV)
    ecoff_set_gp_prolog_size (0);
#endif

  newtok[0] = tok[0];
  set_tok_const (newtok[1], 0);
  newtok[2] = tok[2];

  assemble_tokens_to_insn ("ldah", newtok, 3, &insn);

  addend = tok[1];

#ifdef OBJ_ECOFF
  if (addend.X_op != O_constant)
    as_bad (_("can not resolve expression"));
  addend.X_op = O_symbol;
  addend.X_add_symbol = alpha_gp_symbol;
#endif

  insn.nfixups = 1;
  insn.fixups[0].exp = addend;
  insn.fixups[0].reloc = BFD_RELOC_ALPHA_GPDISP_HI16;
  insn.sequence = next_sequence_num;

  emit_insn (&insn);

  set_tok_preg (newtok[2], tok[0].X_add_number);

  assemble_tokens_to_insn ("lda", newtok, 3, &insn);

#ifdef OBJ_ECOFF
  addend.X_add_number += 4;
#endif

  insn.nfixups = 1;
  insn.fixups[0].exp = addend;
  insn.fixups[0].reloc = BFD_RELOC_ALPHA_GPDISP_LO16;
  insn.sequence = next_sequence_num--;

  emit_insn (&insn);
#endif /* OBJ_ECOFF || OBJ_ELF */
}

#ifdef OBJ_EVAX

/* Add symbol+addend to link pool.
   Return offset from basesym to entry in link pool.

   Add new fixup only if offset isn't 16bit.  */

valueT
add_to_link_pool (basesym, sym, addend)
     symbolS *basesym;
     symbolS *sym;
     offsetT addend;
{
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  valueT offset;
  bfd_reloc_code_real_type reloc_type;
  char *p;
  segment_info_type *seginfo = seg_info (alpha_link_section);
  fixS *fixp;

  offset = - *symbol_get_obj (basesym);

  /* @@@@ This assumes all entries in a given section will be of the same
     size...  Probably correct, but unwise to rely on.  */
  /* This must always be called with the same subsegment.  */

  if (seginfo->frchainP)
    for (fixp = seginfo->frchainP->fix_root;
	 fixp != (fixS *) NULL;
	 fixp = fixp->fx_next, offset += 8)
      {
	if (fixp->fx_addsy == sym && fixp->fx_offset == addend)
	  {
	    if (range_signed_16 (offset))
	      {
		return offset;
	      }
	  }
      }

  /* Not found in 16bit signed range.  */

  subseg_set (alpha_link_section, 0);
  p = frag_more (8);
  memset (p, 0, 8);

  fix_new (frag_now, p - frag_now->fr_literal, 8, sym, addend, 0,
	   BFD_RELOC_64);

  subseg_set (current_section, current_subsec);
  seginfo->literal_pool_size += 8;
  return offset;
}

#endif /* OBJ_EVAX */

/* Load a (partial) expression into a target register.

   If poffset is not null, after the call it will either contain
   O_constant 0, or a 16-bit offset appropriate for any MEM format
   instruction.  In addition, pbasereg will be modified to point to
   the base register to use in that MEM format instruction.

   In any case, *pbasereg should contain a base register to add to the
   expression.  This will normally be either AXP_REG_ZERO or
   alpha_gp_register.  Symbol addresses will always be loaded via $gp,
   so "foo($0)" is interpreted as adding the address of foo to $0;
   i.e. "ldq $targ, LIT($gp); addq $targ, $0, $targ".  Odd, perhaps,
   but this is what OSF/1 does.

   If explicit relocations of the form !literal!<number> are allowed,
   and used, then explicit_reloc with be an expression pointer.

   Finally, the return value is nonzero if the calling macro may emit
   a LITUSE reloc if otherwise appropriate; the return value is the
   sequence number to use.  */

static long
load_expression (targreg, exp, pbasereg, poffset)
     int targreg;
     const expressionS *exp;
     int *pbasereg;
     expressionS *poffset;
{
  long emit_lituse = 0;
  offsetT addend = exp->X_add_number;
  int basereg = *pbasereg;
  struct alpha_insn insn;
  expressionS newtok[3];

  switch (exp->X_op)
    {
    case O_symbol:
      {
#ifdef OBJ_ECOFF
	offsetT lit;

	/* Attempt to reduce .lit load by splitting the offset from
	   its symbol when possible, but don't create a situation in
	   which we'd fail.  */
	if (!range_signed_32 (addend) &&
	    (alpha_noat_on || targreg == AXP_REG_AT))
	  {
	    lit = add_to_literal_pool (exp->X_add_symbol, addend,
				       alpha_lita_section, 8);
	    addend = 0;
	  }
	else
	  {
	    lit = add_to_literal_pool (exp->X_add_symbol, 0,
				       alpha_lita_section, 8);
	  }

	if (lit >= 0x8000)
	  as_fatal (_("overflow in literal (.lita) table"));

	/* emit "ldq r, lit(gp)" */

	if (basereg != alpha_gp_register && targreg == basereg)
	  {
	    if (alpha_noat_on)
	      as_bad (_("macro requires $at register while noat in effect"));
	    if (targreg == AXP_REG_AT)
	      as_bad (_("macro requires $at while $at in use"));

	    set_tok_reg (newtok[0], AXP_REG_AT);
	  }
	else
	  set_tok_reg (newtok[0], targreg);
	set_tok_sym (newtok[1], alpha_lita_symbol, lit);
	set_tok_preg (newtok[2], alpha_gp_register);

	assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

	assert (insn.nfixups == 1);
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
	insn.sequence = emit_lituse = next_sequence_num--;
#endif /* OBJ_ECOFF */
#ifdef OBJ_ELF
	/* emit "ldq r, gotoff(gp)" */

	if (basereg != alpha_gp_register && targreg == basereg)
	  {
	    if (alpha_noat_on)
	      as_bad (_("macro requires $at register while noat in effect"));
	    if (targreg == AXP_REG_AT)
	      as_bad (_("macro requires $at while $at in use"));

	    set_tok_reg (newtok[0], AXP_REG_AT);
	  }
	else
	  set_tok_reg (newtok[0], targreg);

	/* XXX: Disable this .got minimizing optimization so that we can get
	   better instruction offset knowledge in the compiler.  This happens
	   very infrequently anyway.  */
	if (1
	    || (!range_signed_32 (addend)
		&& (alpha_noat_on || targreg == AXP_REG_AT)))
	  {
	    newtok[1] = *exp;
	    addend = 0;
	  }
	else
	  {
	    set_tok_sym (newtok[1], exp->X_add_symbol, 0);
	  }

	set_tok_preg (newtok[2], alpha_gp_register);

	assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

	assert (insn.nfixups == 1);
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
	insn.sequence = emit_lituse = next_sequence_num--;
#endif /* OBJ_ELF */
#ifdef OBJ_EVAX
	offsetT link;

	/* Find symbol or symbol pointer in link section.  */

	if (exp->X_add_symbol == alpha_evax_proc.symbol)
	  {
	    if (range_signed_16 (addend))
	      {
		set_tok_reg (newtok[0], targreg);
		set_tok_const (newtok[1], addend);
		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("lda", newtok, 3, &insn);
		addend = 0;
	      }
	    else
	      {
		set_tok_reg (newtok[0], targreg);
		set_tok_const (newtok[1], 0);
		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("lda", newtok, 3, &insn);
	      }
	  }
	else
	  {
	    if (!range_signed_32 (addend))
	      {
		link = add_to_link_pool (alpha_evax_proc.symbol,
					 exp->X_add_symbol, addend);
		addend = 0;
	      }
	    else
	      {
		link = add_to_link_pool (alpha_evax_proc.symbol,
					 exp->X_add_symbol, 0);
	      }
	    set_tok_reg (newtok[0], targreg);
	    set_tok_const (newtok[1], link);
	    set_tok_preg (newtok[2], basereg);
	    assemble_tokens_to_insn ("ldq", newtok, 3, &insn);
	  }
#endif /* OBJ_EVAX */

	emit_insn (&insn);

#ifndef OBJ_EVAX
	if (basereg != alpha_gp_register && basereg != AXP_REG_ZERO)
	  {
	    /* emit "addq r, base, r" */

	    set_tok_reg (newtok[1], basereg);
	    set_tok_reg (newtok[2], targreg);
	    assemble_tokens ("addq", newtok, 3, 0);
	  }
#endif

	basereg = targreg;
      }
      break;

    case O_constant:
      break;

    case O_subtract:
      /* Assume that this difference expression will be resolved to an
	 absolute value and that that value will fit in 16 bits.  */

      set_tok_reg (newtok[0], targreg);
      newtok[1] = *exp;
      set_tok_preg (newtok[2], basereg);
      assemble_tokens ("lda", newtok, 3, 0);

      if (poffset)
	set_tok_const (*poffset, 0);
      return 0;

    case O_big:
      if (exp->X_add_number > 0)
	as_bad (_("bignum invalid; zero assumed"));
      else
	as_bad (_("floating point number invalid; zero assumed"));
      addend = 0;
      break;

    default:
      as_bad (_("can't handle expression"));
      addend = 0;
      break;
    }

  if (!range_signed_32 (addend))
    {
      offsetT lit;
      long seq_num = next_sequence_num--;

      /* For 64-bit addends, just put it in the literal pool.  */

#ifdef OBJ_EVAX
      /* emit "ldq targreg, lit(basereg)"  */
      lit = add_to_link_pool (alpha_evax_proc.symbol,
			      section_symbol (absolute_section), addend);
      set_tok_reg (newtok[0], targreg);
      set_tok_const (newtok[1], lit);
      set_tok_preg (newtok[2], alpha_gp_register);
      assemble_tokens ("ldq", newtok, 3, 0);
#else

      if (alpha_lit8_section == NULL)
	{
	  create_literal_section (".lit8",
				  &alpha_lit8_section,
				  &alpha_lit8_symbol);

#ifdef OBJ_ECOFF
	  alpha_lit8_literal = add_to_literal_pool (alpha_lit8_symbol, 0x8000,
						    alpha_lita_section, 8);
	  if (alpha_lit8_literal >= 0x8000)
	    as_fatal (_("overflow in literal (.lita) table"));
#endif
	}

      lit = add_to_literal_pool (NULL, addend, alpha_lit8_section, 8) - 0x8000;
      if (lit >= 0x8000)
	as_fatal (_("overflow in literal (.lit8) table"));

      /* emit "lda litreg, .lit8+0x8000" */

      if (targreg == basereg)
	{
	  if (alpha_noat_on)
	    as_bad (_("macro requires $at register while noat in effect"));
	  if (targreg == AXP_REG_AT)
	    as_bad (_("macro requires $at while $at in use"));

	  set_tok_reg (newtok[0], AXP_REG_AT);
	}
      else
	set_tok_reg (newtok[0], targreg);
#ifdef OBJ_ECOFF
      set_tok_sym (newtok[1], alpha_lita_symbol, alpha_lit8_literal);
#endif
#ifdef OBJ_ELF
      set_tok_sym (newtok[1], alpha_lit8_symbol, 0x8000);
#endif
      set_tok_preg (newtok[2], alpha_gp_register);

      assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

      assert (insn.nfixups == 1);
#ifdef OBJ_ECOFF
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
#endif
#ifdef OBJ_ELF
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
#endif
      insn.sequence = seq_num;

      emit_insn (&insn);

      /* emit "ldq litreg, lit(litreg)" */

      set_tok_const (newtok[1], lit);
      set_tok_preg (newtok[2], newtok[0].X_add_number);

      assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

      assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = seq_num;
      emit_lituse = 0;

      emit_insn (&insn);

      /* emit "addq litreg, base, target" */

      if (basereg != AXP_REG_ZERO)
	{
	  set_tok_reg (newtok[1], basereg);
	  set_tok_reg (newtok[2], targreg);
	  assemble_tokens ("addq", newtok, 3, 0);
	}
#endif /* !OBJ_EVAX */

      if (poffset)
	set_tok_const (*poffset, 0);
      *pbasereg = targreg;
    }
  else
    {
      offsetT low, high, extra, tmp;

      /* for 32-bit operands, break up the addend */

      low = sign_extend_16 (addend);
      tmp = addend - low;
      high = sign_extend_16 (tmp >> 16);

      if (tmp - (high << 16))
	{
	  extra = 0x4000;
	  tmp -= 0x40000000;
	  high = sign_extend_16 (tmp >> 16);
	}
      else
	extra = 0;

      set_tok_reg (newtok[0], targreg);
      set_tok_preg (newtok[2], basereg);

      if (extra)
	{
	  /* emit "ldah r, extra(r) */
	  set_tok_const (newtok[1], extra);
	  assemble_tokens ("ldah", newtok, 3, 0);
	  set_tok_preg (newtok[2], basereg = targreg);
	}

      if (high)
	{
	  /* emit "ldah r, high(r) */
	  set_tok_const (newtok[1], high);
	  assemble_tokens ("ldah", newtok, 3, 0);
	  basereg = targreg;
	  set_tok_preg (newtok[2], basereg);
	}

      if ((low && !poffset) || (!poffset && basereg != targreg))
	{
	  /* emit "lda r, low(base)" */
	  set_tok_const (newtok[1], low);
	  assemble_tokens ("lda", newtok, 3, 0);
	  basereg = targreg;
	  low = 0;
	}

      if (poffset)
	set_tok_const (*poffset, low);
      *pbasereg = basereg;
    }

  return emit_lituse;
}

/* The lda macro differs from the lda instruction in that it handles
   most simple expressions, particularly symbol address loads and
   large constants.  */

static void
emit_lda (tok, ntok, unused)
     const expressionS *tok;
     int ntok;
     const PTR unused ATTRIBUTE_UNUSED;
{
  int basereg;

  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;

  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL);
}

/* The ldah macro differs from the ldah instruction in that it has $31
   as an implied base register.  */

static void
emit_ldah (tok, ntok, unused)
     const expressionS *tok;
     int ntok ATTRIBUTE_UNUSED;
     const PTR unused ATTRIBUTE_UNUSED;
{
  expressionS newtok[3];

  newtok[0] = tok[0];
  newtok[1] = tok[1];
  set_tok_preg (newtok[2], AXP_REG_ZERO);

  assemble_tokens ("ldah", newtok, 3, 0);
}

/* Handle all "simple" integer register loads -- ldq, ldq_l, ldq_u,
   etc.  They differ from the real instructions in that they do simple
   expressions like the lda macro.  */

static void
emit_ir_load (tok, ntok, opname)
     const expressionS *tok;
     int ntok;
     const PTR opname;
{
  int basereg;
  long lituse;
  expressionS newtok[3];
  struct alpha_insn insn;

  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;

  lituse = load_expression (tok[0].X_add_number, &tok[1], &basereg,
			    &newtok[1]);

  newtok[0] = tok[0];
  set_tok_preg (newtok[2], basereg);

  assemble_tokens_to_insn ((const char *) opname, newtok, 3, &insn);

  if (lituse)
    {
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = lituse;
    }

  emit_insn (&insn);
}

/* Handle fp register loads, and both integer and fp register stores.
   Again, we handle simple expressions.  */

static void
emit_loadstore (tok, ntok, opname)
     const expressionS *tok;
     int ntok;
     const PTR opname;
{
  int basereg;
  long lituse;
  expressionS newtok[3];
  struct alpha_insn insn;

  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;

  if (tok[1].X_op != O_constant || !range_signed_16 (tok[1].X_add_number))
    {
      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1]);
    }
  else
    {
      newtok[1] = tok[1];
      lituse = 0;
    }

  newtok[0] = tok[0];
  set_tok_preg (newtok[2], basereg);

  assemble_tokens_to_insn ((const char *) opname, newtok, 3, &insn);

  if (lituse)
    {
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = lituse;
    }

  emit_insn (&insn);
}

/* Load a half-word or byte as an unsigned value.  */

static void
emit_ldXu (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
{
  if (alpha_target & AXP_OPCODE_BWX)
    emit_ir_load (tok, ntok, ldXu_op[(long) vlgsize]);
  else
    {
      expressionS newtok[3];
      struct alpha_insn insn;
      int basereg;
      long lituse;

      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      if (ntok == 2)
	basereg = (tok[1].X_op == O_constant
		   ? AXP_REG_ZERO : alpha_gp_register);
      else
	basereg = tok[2].X_add_number;

      /* emit "lda $at, exp" */

      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL);

      /* emit "ldq_u targ, 0($at)" */

      newtok[0] = tok[0];
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], basereg);
      assemble_tokens_to_insn ("ldq_u", newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* emit "extXl targ, $at, targ" */

      set_tok_reg (newtok[1], basereg);
      newtok[2] = newtok[0];
      assemble_tokens_to_insn (extXl_op[(long) vlgsize], newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
    }
}

/* Load a half-word or byte as a signed value.  */

static void
emit_ldX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
{
  emit_ldXu (tok, ntok, vlgsize);
  assemble_tokens (sextX_op[(long) vlgsize], tok, 1, 1);
}

/* Load an integral value from an unaligned address as an unsigned
   value.  */

static void
emit_uldXu (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
{
  long lgsize = (long) vlgsize;
  expressionS newtok[3];

  if (alpha_noat_on)
    as_bad (_("macro requires $at register while noat in effect"));

  /* emit "lda $at, exp" */

  memcpy (newtok, tok, sizeof (expressionS) * ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);

  /* emit "ldq_u $t9, 0($at)" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "ldq_u $t10, size-1($at)" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "extXl $t9, $at, $t9" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T9);
  assemble_tokens (extXl_op[lgsize], newtok, 3, 1);

  /* emit "extXh $t10, $at, $t10" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_reg (newtok[2], AXP_REG_T10);
  assemble_tokens (extXh_op[lgsize], newtok, 3, 1);

  /* emit "or $t9, $t10, targ" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_T10);
  newtok[2] = tok[0];
  assemble_tokens ("or", newtok, 3, 1);
}

/* Load an integral value from an unaligned address as a signed value.
   Note that quads should get funneled to the unsigned load since we
   don't have to do the sign extension.  */

static void
emit_uldX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
{
  emit_uldXu (tok, ntok, vlgsize);
  assemble_tokens (sextX_op[(long) vlgsize], tok, 1, 1);
}

/* Implement the ldil macro.  */

static void
emit_ldil (tok, ntok, unused)
     const expressionS *tok;
     int ntok;
     const PTR unused ATTRIBUTE_UNUSED;
{
  expressionS newtok[2];

  memcpy (newtok, tok, sizeof (newtok));
  newtok[1].X_add_number = sign_extend_32 (tok[1].X_add_number);

  assemble_tokens ("lda", newtok, ntok, 1);
}

/* Store a half-word or byte.  */

static void
emit_stX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
{
  int lgsize = (int) (long) vlgsize;

  if (alpha_target & AXP_OPCODE_BWX)
    emit_loadstore (tok, ntok, stX_op[lgsize]);
  else
    {
      expressionS newtok[3];
      struct alpha_insn insn;
      int basereg;
      long lituse;

      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      if (ntok == 2)
	basereg = (tok[1].X_op == O_constant
		   ? AXP_REG_ZERO : alpha_gp_register);
      else
	basereg = tok[2].X_add_number;

      /* emit "lda $at, exp" */

      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL);

      /* emit "ldq_u $t9, 0($at)" */

      set_tok_reg (newtok[0], AXP_REG_T9);
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], basereg);
      assemble_tokens_to_insn ("ldq_u", newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* emit "insXl src, $at, $t10" */

      newtok[0] = tok[0];
      set_tok_reg (newtok[1], basereg);
      set_tok_reg (newtok[2], AXP_REG_T10);
      assemble_tokens_to_insn (insXl_op[lgsize], newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* emit "mskXl $t9, $at, $t9" */

      set_tok_reg (newtok[0], AXP_REG_T9);
      newtok[2] = newtok[0];
      assemble_tokens_to_insn (mskXl_op[lgsize], newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);

      /* emit "or $t9, $t10, $t9" */

      set_tok_reg (newtok[1], AXP_REG_T10);
      assemble_tokens ("or", newtok, 3, 1);

      /* emit "stq_u $t9, 0($at) */

      set_tok_const(newtok[1], 0);
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens_to_insn ("stq_u", newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
    }
}

/* Store an integer to an unaligned address.  */

static void
emit_ustX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
{
  int lgsize = (int) (long) vlgsize;
  expressionS newtok[3];

  /* emit "lda $at, exp" */

  memcpy (newtok, tok, sizeof (expressionS) * ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);

  /* emit "ldq_u $9, 0($at)" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "ldq_u $10, size-1($at)" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "insXl src, $at, $t11" */

  newtok[0] = tok[0];
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T11);
  assemble_tokens (insXl_op[lgsize], newtok, 3, 1);

  /* emit "insXh src, $at, $t12" */

  set_tok_reg (newtok[2], AXP_REG_T12);
  assemble_tokens (insXh_op[lgsize], newtok, 3, 1);

  /* emit "mskXl $t9, $at, $t9" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  newtok[2] = newtok[0];
  assemble_tokens (mskXl_op[lgsize], newtok, 3, 1);

  /* emit "mskXh $t10, $at, $t10" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  newtok[2] = newtok[0];
  assemble_tokens (mskXh_op[lgsize], newtok, 3, 1);

  /* emit "or $t9, $t11, $t9" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_T11);
  newtok[2] = newtok[0];
  assemble_tokens ("or", newtok, 3, 1);

  /* emit "or $t10, $t12, $t10" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_reg (newtok[1], AXP_REG_T12);
  newtok[2] = newtok[0];
  assemble_tokens ("or", newtok, 3, 1);

  /* emit "stq_u $t9, 0($at)" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("stq_u", newtok, 3, 1);

  /* emit "stq_u $t10, size-1($at)" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize) - 1);
  assemble_tokens ("stq_u", newtok, 3, 1);
}

/* Sign extend a half-word or byte.  The 32-bit sign extend is
   implemented as "addl $31, $r, $t" in the opcode table.  */

static void
emit_sextX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     const PTR vlgsize;
{
  long lgsize = (long) vlgsize;

  if (alpha_target & AXP_OPCODE_BWX)
    assemble_tokens (sextX_op[lgsize], tok, ntok, 0);
  else
    {
      int bitshift = 64 - 8 * (1 << lgsize);
      expressionS newtok[3];

      /* emit "sll src,bits,dst" */

      newtok[0] = tok[0];
      set_tok_const (newtok[1], bitshift);
      newtok[2] = tok[ntok - 1];
      assemble_tokens ("sll", newtok, 3, 1);

      /* emit "sra dst,bits,dst" */

      newtok[0] = newtok[2];
      assemble_tokens ("sra", newtok, 3, 1);
    }
}

/* Implement the division and modulus macros.  */

#ifdef OBJ_EVAX

/* Make register usage like in normal procedure call.
   Don't clobber PV and RA.  */

static void
emit_division (tok, ntok, symname)
     const expressionS *tok;
     int ntok;
     const PTR symname;
{
  /* DIVISION and MODULUS. Yech.
   
     Convert
        OP x,y,result
     to
        mov x,R16	# if x != R16
        mov y,R17	# if y != R17
        lda AT,__OP
        jsr AT,(AT),0
        mov R0,result
    
     with appropriate optimizations if R0,R16,R17 are the registers
     specified by the compiler.  */

  int xr, yr, rr;
  symbolS *sym;
  expressionS newtok[3];

  xr = regno (tok[0].X_add_number);
  yr = regno (tok[1].X_add_number);

  if (ntok < 3)
    rr = xr;
  else
    rr = regno (tok[2].X_add_number);

  /* Move the operands into the right place.  */
  if (yr == AXP_REG_R16 && xr == AXP_REG_R17)
    {
      /* They are in exactly the wrong order -- swap through AT.  */

      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      set_tok_reg (newtok[0], AXP_REG_R16);
      set_tok_reg (newtok[1], AXP_REG_AT);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_R17);
      set_tok_reg (newtok[1], AXP_REG_R16);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_AT);
      set_tok_reg (newtok[1], AXP_REG_R17);
      assemble_tokens ("mov", newtok, 2, 1);
    }
  else
    {
      if (yr == AXP_REG_R16)
	{
	  set_tok_reg (newtok[0], AXP_REG_R16);
	  set_tok_reg (newtok[1], AXP_REG_R17);
	  assemble_tokens ("mov", newtok, 2, 1);
	}

      if (xr != AXP_REG_R16)
	{
	  set_tok_reg (newtok[0], xr);
	  set_tok_reg (newtok[1], AXP_REG_R16);
	  assemble_tokens ("mov", newtok, 2, 1);
	}

      if (yr != AXP_REG_R16 && yr != AXP_REG_R17)
	{
	  set_tok_reg (newtok[0], yr);
	  set_tok_reg (newtok[1], AXP_REG_R17);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
    }

  sym = symbol_find_or_make ((const char *) symname);

  set_tok_reg (newtok[0], AXP_REG_AT);
  set_tok_sym (newtok[1], sym, 0);
  assemble_tokens ("lda", newtok, 2, 1);

  /* Call the division routine.  */
  set_tok_reg (newtok[0], AXP_REG_AT);
  set_tok_cpreg (newtok[1], AXP_REG_AT);
  set_tok_const (newtok[2], 0);
  assemble_tokens ("jsr", newtok, 3, 1);

  /* Move the result to the right place.  */
  if (rr != AXP_REG_R0)
    {
      set_tok_reg (newtok[0], AXP_REG_R0);
      set_tok_reg (newtok[1], rr);
      assemble_tokens ("mov", newtok, 2, 1);
    }
}

#else /* !OBJ_EVAX */

static void
emit_division (tok, ntok, symname)
     const expressionS *tok;
     int ntok;
     const PTR symname;
{
  /* DIVISION and MODULUS. Yech.
     Convert
        OP x,y,result
     to
        lda pv,__OP
        mov x,t10
        mov y,t11
        jsr t9,(pv),__OP
        mov t12,result
    
     with appropriate optimizations if t10,t11,t12 are the registers
     specified by the compiler.  */

  int xr, yr, rr;
  symbolS *sym;
  expressionS newtok[3];

  xr = regno (tok[0].X_add_number);
  yr = regno (tok[1].X_add_number);

  if (ntok < 3)
    rr = xr;
  else
    rr = regno (tok[2].X_add_number);

  sym = symbol_find_or_make ((const char *) symname);

  /* Move the operands into the right place.  */
  if (yr == AXP_REG_T10 && xr == AXP_REG_T11)
    {
      /* They are in exactly the wrong order -- swap through AT.  */
      if (alpha_noat_on)
	as_bad (_("macro requires $at register while noat in effect"));

      set_tok_reg (newtok[0], AXP_REG_T10);
      set_tok_reg (newtok[1], AXP_REG_AT);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_T11);
      set_tok_reg (newtok[1], AXP_REG_T10);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_AT);
      set_tok_reg (newtok[1], AXP_REG_T11);
      assemble_tokens ("mov", newtok, 2, 1);
    }
  else
    {
      if (yr == AXP_REG_T10)
	{
	  set_tok_reg (newtok[0], AXP_REG_T10);
	  set_tok_reg (newtok[1], AXP_REG_T11);
	  assemble_tokens ("mov", newtok, 2, 1);
	}

      if (xr != AXP_REG_T10)
	{
	  set_tok_reg (newtok[0], xr);
	  set_tok_reg (newtok[1], AXP_REG_T10);
	  assemble_tokens ("mov", newtok, 2, 1);
	}

      if (yr != AXP_REG_T10 && yr != AXP_REG_T11)
	{
	  set_tok_reg (newtok[0], yr);
	  set_tok_reg (newtok[1], AXP_REG_T11);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
    }

  /* Call the division routine.  */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_sym (newtok[1], sym, 0);
  assemble_tokens ("jsr", newtok, 2, 1);

  /* Reload the GP register.  */
#ifdef OBJ_AOUT
FIXME
#endif
#if defined(OBJ_ECOFF) || defined(OBJ_ELF)
  set_tok_reg (newtok[0], alpha_gp_register);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_T9);
  assemble_tokens ("ldgp", newtok, 3, 1);
#endif

  /* Move the result to the right place.  */
  if (rr != AXP_REG_T12)
    {
      set_tok_reg (newtok[0], AXP_REG_T12);
      set_tok_reg (newtok[1], rr);
      assemble_tokens ("mov", newtok, 2, 1);
    }
}

#endif /* !OBJ_EVAX */

/* The jsr and jmp macros differ from their instruction counterparts
   in that they can load the target address and default most
   everything.  */

static void
emit_jsrjmp (tok, ntok, vopname)
     const expressionS *tok;
     int ntok;
     const PTR vopname;
{
  const char *opname = (const char *) vopname;
  struct alpha_insn insn;
  expressionS newtok[3];
  int r, tokidx = 0;
  long lituse = 0;

  if (tokidx < ntok && tok[tokidx].X_op == O_register)
    r = regno (tok[tokidx++].X_add_number);
  else
    r = strcmp (opname, "jmp") == 0 ? AXP_REG_ZERO : AXP_REG_RA;

  set_tok_reg (newtok[0], r);

  if (tokidx < ntok &&
      (tok[tokidx].X_op == O_pregister || tok[tokidx].X_op == O_cpregister))
    r = regno (tok[tokidx++].X_add_number);
#ifdef OBJ_EVAX
  /* keep register if jsr $n.<sym>  */
#else
  else
    {
      int basereg = alpha_gp_register;
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL);
    }
#endif

  set_tok_cpreg (newtok[1], r);

#ifdef OBJ_EVAX
  /* FIXME: Add hint relocs to BFD for evax.  */
#else
  if (tokidx < ntok)
    newtok[2] = tok[tokidx];
  else
#endif
    set_tok_const (newtok[2], 0);

  assemble_tokens_to_insn (opname, newtok, 3, &insn);

  if (lituse)
    {
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_JSR;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
      insn.nfixups++;
      insn.sequence = lituse;
    }

  emit_insn (&insn);
}

/* The ret and jcr instructions differ from their instruction
   counterparts in that everything can be defaulted.  */

static void
emit_retjcr (tok, ntok, vopname)
     const expressionS *tok;
     int ntok;
     const PTR vopname;
{
  const char *opname = (const char *) vopname;
  expressionS newtok[3];
  int r, tokidx = 0;

  if (tokidx < ntok && tok[tokidx].X_op == O_register)
    r = regno (tok[tokidx++].X_add_number);
  else
    r = AXP_REG_ZERO;

  set_tok_reg (newtok[0], r);

  if (tokidx < ntok &&
      (tok[tokidx].X_op == O_pregister || tok[tokidx].X_op == O_cpregister))
    r = regno (tok[tokidx++].X_add_number);
  else
    r = AXP_REG_RA;

  set_tok_cpreg (newtok[1], r);

  if (tokidx < ntok)
    newtok[2] = tok[tokidx];
  else
    set_tok_const (newtok[2], strcmp (opname, "ret") == 0);

  assemble_tokens (opname, newtok, 3, 0);
}

/* Assembler directives.  */

/* Handle the .text pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_text (i)
     int i;

{
#ifdef OBJ_ELF
  obj_elf_text (i);
#else
  s_text (i);
#endif
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

/* Handle the .data pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_data (i)
     int i;
{
#ifdef OBJ_ELF
  obj_elf_data (i);
#else
  s_data (i);
#endif
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)

/* Handle the OSF/1 and openVMS .comm pseudo quirks.
   openVMS constructs a section for every common symbol.  */

static void
s_alpha_comm (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  register char *name;
  register char c;
  register char *p;
  offsetT temp;
  register symbolS *symbolP;

#ifdef OBJ_EVAX
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT new_seg;
#endif

  name = input_line_pointer;
  c = get_symbol_end ();

  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;

  SKIP_WHITESPACE ();

  /* Alpha OSF/1 compiler doesn't provide the comma, gcc does.  */
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      SKIP_WHITESPACE ();
    }
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
      ignore_rest_of_line ();
      return;
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);

#ifdef OBJ_EVAX
  /* Make a section for the common symbol.  */
  new_seg = subseg_new (xstrdup (name), 0);
#endif

  *p = c;

#ifdef OBJ_EVAX
  /* alignment might follow  */
  if (*input_line_pointer == ',')
    {
      offsetT align;

      input_line_pointer++;
      align = get_absolute_expression ();
      bfd_set_section_alignment (stdoutput, new_seg, align);
    }
#endif

  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
    }

#ifdef OBJ_EVAX
  if (bfd_section_size (stdoutput, new_seg) > 0)
    {
      if (bfd_section_size (stdoutput, new_seg) != temp)
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		S_GET_NAME (symbolP),
		(long) bfd_section_size (stdoutput, new_seg),
		(long) temp);
    }
#else
  if (S_GET_VALUE (symbolP))
    {
      if (S_GET_VALUE (symbolP) != (valueT) temp)
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		S_GET_NAME (symbolP),
		(long) S_GET_VALUE (symbolP),
		(long) temp);
    }
#endif
  else
    {
#ifdef OBJ_EVAX
      subseg_set (new_seg, 0);
      p = frag_more (temp);
      new_seg->flags |= SEC_IS_COMMON;
      if (! S_IS_DEFINED (symbolP))
	S_SET_SEGMENT (symbolP, new_seg);
#else
      S_SET_VALUE (symbolP, (valueT) temp);
#endif
      S_SET_EXTERNAL (symbolP);
    }

#ifdef OBJ_EVAX
  subseg_set (current_section, current_subsec);
#endif

  know (symbol_get_frag (symbolP) == &zero_address_frag);

  demand_empty_rest_of_line ();
}

#endif /* ! OBJ_ELF */

#ifdef OBJ_ECOFF

/* Handle the .rdata pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_rdata (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int temp;

  temp = get_absolute_expression ();
  subseg_new (".rdata", 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

#endif

#ifdef OBJ_ECOFF

/* Handle the .sdata pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_sdata (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int temp;

  temp = get_absolute_expression ();
  subseg_new (".sdata", 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}
#endif

#ifdef OBJ_ELF
struct alpha_elf_frame_data
{
  symbolS *func_sym;
  symbolS *func_end_sym;
  symbolS *prologue_sym;
  unsigned int mask;
  unsigned int fmask;
  int fp_regno;
  int ra_regno;
  offsetT frame_size;
  offsetT mask_offset;
  offsetT fmask_offset;

  struct alpha_elf_frame_data *next;
};

static struct alpha_elf_frame_data *all_frame_data;
static struct alpha_elf_frame_data **plast_frame_data = &all_frame_data;
static struct alpha_elf_frame_data *cur_frame_data;

/* Handle the .section pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void
s_alpha_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  obj_elf_section (ignore);

  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

static void
s_alpha_ent (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_ent (0);
  else
    {
      char *name, name_end;
      name = input_line_pointer;
      name_end = get_symbol_end ();

      if (! is_name_beginner (*name))
	{
	  as_warn (_(".ent directive has no name"));
	  *input_line_pointer = name_end;
	}
      else
	{
	  symbolS *sym;

	  if (cur_frame_data)
	    as_warn (_("nested .ent directives"));

	  sym = symbol_find_or_make (name);
	  symbol_get_bfdsym (sym)->flags |= BSF_FUNCTION;

	  cur_frame_data = calloc (1, sizeof (*cur_frame_data));
	  cur_frame_data->func_sym = sym;

	  /* Provide sensible defaults.  */
	  cur_frame_data->fp_regno = 30;	/* sp */
	  cur_frame_data->ra_regno = 26;	/* ra */

	  *plast_frame_data = cur_frame_data;
	  plast_frame_data = &cur_frame_data->next;

	  /* The .ent directive is sometimes followed by a number.  Not sure
	     what it really means, but ignore it.  */
	  *input_line_pointer = name_end;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      input_line_pointer++;
	      SKIP_WHITESPACE ();
	    }
	  if (ISDIGIT (*input_line_pointer) || *input_line_pointer == '-')
	    (void) get_absolute_expression ();
	}
      demand_empty_rest_of_line ();
    }
}

static void
s_alpha_end (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_end (0);
  else
    {
      char *name, name_end;
      name = input_line_pointer;
      name_end = get_symbol_end ();

      if (! is_name_beginner (*name))
	{
	  as_warn (_(".end directive has no name"));
	  *input_line_pointer = name_end;
	}
      else
	{
	  symbolS *sym;

	  sym = symbol_find (name);
	  if (!cur_frame_data)
	    as_warn (_(".end directive without matching .ent"));
	  else if (sym != cur_frame_data->func_sym)
	    as_warn (_(".end directive names different symbol than .ent"));

	  /* Create an expression to calculate the size of the function.  */
	  if (sym && cur_frame_data)
	    {
	      OBJ_SYMFIELD_TYPE *obj = symbol_get_obj (sym);
	      expressionS *exp = xmalloc (sizeof (expressionS));

	      obj->size = exp;
	      exp->X_op = O_subtract;
	      exp->X_add_symbol = symbol_temp_new_now ();
	      exp->X_op_symbol = sym;
	      exp->X_add_number = 0;

	      cur_frame_data->func_end_sym = exp->X_add_symbol;
	    }

	  cur_frame_data = NULL;

	  *input_line_pointer = name_end;
	}
      demand_empty_rest_of_line ();
    }
}

static void
s_alpha_mask (fp)
     int fp;
{
  if (ECOFF_DEBUGGING)
    {
      if (fp)
	ecoff_directive_fmask (0);
      else
	ecoff_directive_mask (0);
    }
  else
    {
      long val;
      offsetT offset;

      if (!cur_frame_data)
	{
	  if (fp)
	    as_warn (_(".fmask outside of .ent"));
	  else
	    as_warn (_(".mask outside of .ent"));
	  discard_rest_of_line ();
	  return;
	}

      if (get_absolute_expression_and_terminator (&val) != ',')
	{
	  if (fp)
	    as_warn (_("bad .fmask directive"));
	  else
	    as_warn (_("bad .mask directive"));
	  --input_line_pointer;
	  discard_rest_of_line ();
	  return;
	}

      offset = get_absolute_expression ();
      demand_empty_rest_of_line ();

      if (fp)
	{
	  cur_frame_data->fmask = val;
          cur_frame_data->fmask_offset = offset;
	}
      else
	{
	  cur_frame_data->mask = val;
	  cur_frame_data->mask_offset = offset;
	}
    }
}

static void
s_alpha_frame (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_frame (0);
  else
    {
      long val;

      if (!cur_frame_data)
	{
	  as_warn (_(".frame outside of .ent"));
	  discard_rest_of_line ();
	  return;
	}

      cur_frame_data->fp_regno = tc_get_register (1);

      SKIP_WHITESPACE ();
      if (*input_line_pointer++ != ','
	  || get_absolute_expression_and_terminator (&val) != ',')
	{
	  as_warn (_("bad .frame directive"));
	  --input_line_pointer;
	  discard_rest_of_line ();
	  return;
	}
      cur_frame_data->frame_size = val;

      cur_frame_data->ra_regno = tc_get_register (0);

      /* Next comes the "offset of saved $a0 from $sp".  In gcc terms
	 this is current_function_pretend_args_size.  There's no place
	 to put this value, so ignore it.  */
      s_ignore (42);
    }
}

static void
s_alpha_prologue (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *sym;
  int arg;

  arg = get_absolute_expression ();
  demand_empty_rest_of_line ();

  if (ECOFF_DEBUGGING)
    sym = ecoff_get_cur_proc_sym ();
  else
    sym = cur_frame_data ? cur_frame_data->func_sym : NULL;

  if (sym == NULL)
    {
      as_bad (_(".prologue directive without a preceding .ent directive"));
      return;
    }

  switch (arg)
    {
    case 0: /* No PV required.  */
      S_SET_OTHER (sym, STO_ALPHA_NOPV
		   | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
      break;
    case 1: /* Std GP load.  */
      S_SET_OTHER (sym, STO_ALPHA_STD_GPLOAD
		   | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
      break;
    case 2: /* Non-std use of PV.  */
      break;

    default:
      as_bad (_("Invalid argument %d to .prologue."), arg);
      break;
    }

  if (cur_frame_data)
    cur_frame_data->prologue_sym = symbol_temp_new_now ();
}

static char *first_file_directive;

static void
s_alpha_file (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* Save the first .file directive we see, so that we can change our
     minds about whether ecoff debugging should or shouldn't be enabled.  */
  if (alpha_flag_mdebug < 0 && ! first_file_directive)
    {
      char *start = input_line_pointer;
      size_t len;

      discard_rest_of_line ();

      len = input_line_pointer - start;
      first_file_directive = xmalloc (len + 1);
      memcpy (first_file_directive, start, len);
      first_file_directive[len] = '\0';

      input_line_pointer = start;
    }

  if (ECOFF_DEBUGGING)
    ecoff_directive_file (0);
  else
    dwarf2_directive_file (0);
}

static void
s_alpha_loc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_loc (0);
  else
    dwarf2_directive_loc (0);
}

static void
s_alpha_stab (n)
     int n;
{
  /* If we've been undecided about mdebug, make up our minds in favour.  */
  if (alpha_flag_mdebug < 0)
    {
      segT sec = subseg_new (".mdebug", 0);
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);
      bfd_set_section_alignment (stdoutput, sec, 3);

      ecoff_read_begin_hook ();

      if (first_file_directive)
	{
	  char *save_ilp = input_line_pointer;
	  input_line_pointer = first_file_directive;
	  ecoff_directive_file (0);
	  input_line_pointer = save_ilp;
	  free (first_file_directive);
	}

      alpha_flag_mdebug = 1;
    }
  s_stab (n);
}

static void
s_alpha_coff_wrapper (which)
     int which;
{
  static void (* const fns[]) PARAMS ((int)) = {
    ecoff_directive_begin,
    ecoff_directive_bend,
    ecoff_directive_def,
    ecoff_directive_dim,
    ecoff_directive_endef,
    ecoff_directive_scl,
    ecoff_directive_tag,
    ecoff_directive_val,
  };

  assert (which >= 0 && which < (int) (sizeof (fns)/sizeof (*fns)));

  if (ECOFF_DEBUGGING)
    (*fns[which]) (0);
  else
    {
      as_bad (_("ECOFF debugging is disabled."));
      ignore_rest_of_line ();
    }
}

/* Called at the end of assembly.  Here we emit unwind info for frames
   unless the compiler has done it for us.  */

void
alpha_elf_md_end (void)
{
  struct alpha_elf_frame_data *p;

  if (cur_frame_data)
    as_warn (_(".ent directive without matching .end"));

  /* If someone has generated the unwind info themselves, great.  */
  if (bfd_get_section_by_name (stdoutput, ".eh_frame") != NULL)
    return;

  /* Generate .eh_frame data for the unwind directives specified.  */
  for (p = all_frame_data; p ; p = p->next)
    if (p->prologue_sym)
      {
	/* Create a temporary symbol at the same location as our
	   function symbol.  This prevents problems with globals.  */
	cfi_new_fde (symbol_temp_new (S_GET_SEGMENT (p->func_sym),
				      S_GET_VALUE (p->func_sym),
				      symbol_get_frag (p->func_sym)));

	cfi_set_return_column (p->ra_regno);
	cfi_add_CFA_def_cfa_register (30);
	if (p->fp_regno != 30 || p->mask || p->fmask || p->frame_size)
	  {
	    unsigned int mask;
	    offsetT offset;

	    cfi_add_advance_loc (p->prologue_sym);

	    if (p->fp_regno != 30)
	      if (p->frame_size != 0)
		cfi_add_CFA_def_cfa (p->fp_regno, p->frame_size);
	      else
		cfi_add_CFA_def_cfa_register (p->fp_regno);
	    else if (p->frame_size != 0)
	      cfi_add_CFA_def_cfa_offset (p->frame_size);

	    mask = p->mask;
	    offset = p->mask_offset;

	    /* Recall that $26 is special-cased and stored first.  */
	    if ((mask >> 26) & 1)
	      {
	        cfi_add_CFA_offset (26, offset);
		offset += 8;
		mask &= ~(1 << 26);
	      }
	    while (mask)
	      {
		unsigned int i;
		i = mask & -mask;
		mask ^= i;
		i = ffs (i) - 1;

		cfi_add_CFA_offset (i, offset);
		offset += 8;
	      }

	    mask = p->fmask;
	    offset = p->fmask_offset;
	    while (mask)
	      {
		unsigned int i;
		i = mask & -mask;
		mask ^= i;
		i = ffs (i) - 1;

		cfi_add_CFA_offset (i + 32, offset);
		offset += 8;
	      }
	  }

	cfi_end_fde (p->func_end_sym);
      }
}

static void
s_alpha_usepv (int unused ATTRIBUTE_UNUSED)
{
  char *name, name_end;
  char *which, which_end;
  symbolS *sym;
  int other;

  name = input_line_pointer;
  name_end = get_symbol_end ();

  if (! is_name_beginner (*name))
    {
      as_bad (_(".usepv directive has no name"));
      *input_line_pointer = name_end;
      ignore_rest_of_line ();
      return;
    }

  sym = symbol_find_or_make (name);
  *input_line_pointer++ = name_end;

  if (name_end != ',')
    {
      as_bad (_(".usepv directive has no type"));
      ignore_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();
  which = input_line_pointer;
  which_end = get_symbol_end ();

  if (strcmp (which, "no") == 0)
    other = STO_ALPHA_NOPV;
  else if (strcmp (which, "std") == 0)
    other = STO_ALPHA_STD_GPLOAD;
  else
    {
      as_bad (_("unknown argument for .usepv"));
      other = 0;
    }
  
  *input_line_pointer = which_end;
  demand_empty_rest_of_line ();

  S_SET_OTHER (sym, other | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
}
#endif /* OBJ_ELF */

/* Standard calling conventions leaves the CFA at $30 on entry.  */

void
alpha_cfi_frame_initial_instructions ()
{
  cfi_add_CFA_def_cfa_register (30);
}

#ifdef OBJ_EVAX

/* Handle the section specific pseudo-op.  */

static void
s_alpha_section (secid)
     int secid;
{
  int temp;
#define EVAX_SECTION_COUNT 5
  static char *section_name[EVAX_SECTION_COUNT + 1] =
    { "NULL", ".rdata", ".comm", ".link", ".ctors", ".dtors" };

  if ((secid <= 0) || (secid > EVAX_SECTION_COUNT))
    {
      as_fatal (_("Unknown section directive"));
      demand_empty_rest_of_line ();
      return;
    }
  temp = get_absolute_expression ();
  subseg_new (section_name[secid], 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}

/* Parse .ent directives.  */

static void
s_alpha_ent (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *symbol;
  expressionS symexpr;

  alpha_evax_proc.pdsckind = 0;
  alpha_evax_proc.framereg = -1;
  alpha_evax_proc.framesize = 0;
  alpha_evax_proc.rsa_offset = 0;
  alpha_evax_proc.ra_save = AXP_REG_RA;
  alpha_evax_proc.fp_save = -1;
  alpha_evax_proc.imask = 0;
  alpha_evax_proc.fmask = 0;
  alpha_evax_proc.prologue = 0;
  alpha_evax_proc.type = 0;

  expression (&symexpr);

  if (symexpr.X_op != O_symbol)
    {
      as_fatal (_(".ent directive has no symbol"));
      demand_empty_rest_of_line ();
      return;
    }

  symbol = make_expr_symbol (&symexpr);
  symbol_get_bfdsym (symbol)->flags |= BSF_FUNCTION;
  alpha_evax_proc.symbol = symbol;

  demand_empty_rest_of_line ();
}

/* Parse .frame <framreg>,<framesize>,RA,<rsa_offset> directives.  */

static void
s_alpha_frame (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  long val;

  alpha_evax_proc.framereg = tc_get_register (1);

  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ','
      || get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn (_("Bad .frame directive 1./2. param"));
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }

  alpha_evax_proc.framesize = val;

  (void) tc_get_register (1);
  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ',')
    {
      as_warn (_("Bad .frame directive 3./4. param"));
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
  alpha_evax_proc.rsa_offset = get_absolute_expression ();
}

static void
s_alpha_pdesc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char name_end;
  long val;
  register char *p;
  expressionS exp;
  symbolS *entry_sym;
  fixS *fixp;
  segment_info_type *seginfo = seg_info (alpha_link_section);

  if (now_seg != alpha_link_section)
    {
      as_bad (_(".pdesc directive not in link (.link) section"));
      demand_empty_rest_of_line ();
      return;
    }

  if ((alpha_evax_proc.symbol == 0)
      || (!S_IS_DEFINED (alpha_evax_proc.symbol)))
    {
      as_fatal (_(".pdesc has no matching .ent"));
      demand_empty_rest_of_line ();
      return;
    }

  *symbol_get_obj (alpha_evax_proc.symbol) =
    (valueT) seginfo->literal_pool_size;

  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_warn (_(".pdesc directive has no entry symbol"));
      demand_empty_rest_of_line ();
      return;
    }

  entry_sym = make_expr_symbol (&exp);
  /* Save bfd symbol of proc desc in function symbol.  */
  symbol_get_bfdsym (alpha_evax_proc.symbol)->udata.p
    = symbol_get_bfdsym (entry_sym);

  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ',')
    {
      as_warn (_("No comma after .pdesc <entryname>"));
      demand_empty_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  name_end = get_symbol_end ();

  if (strncmp (name, "stack", 5) == 0)
    {
      alpha_evax_proc.pdsckind = PDSC_S_K_KIND_FP_STACK;
    }
  else if (strncmp (name, "reg", 3) == 0)
    {
      alpha_evax_proc.pdsckind = PDSC_S_K_KIND_FP_REGISTER;
    }
  else if (strncmp (name, "null", 4) == 0)
    {
      alpha_evax_proc.pdsckind = PDSC_S_K_KIND_NULL;
    }
  else
    {
      as_fatal (_("unknown procedure kind"));
      demand_empty_rest_of_line ();
      return;
    }

  *input_line_pointer = name_end;
  demand_empty_rest_of_line ();

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  frag_align (3, 0, 0);
  p = frag_more (16);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;
  seginfo->literal_pool_size += 16;

  *p = alpha_evax_proc.pdsckind
    | ((alpha_evax_proc.framereg == 29) ? PDSC_S_M_BASE_REG_IS_FP : 0);
  *(p + 1) = PDSC_S_M_NATIVE | PDSC_S_M_NO_JACKET;

  switch (alpha_evax_proc.pdsckind)
    {
    case PDSC_S_K_KIND_NULL:
      *(p + 2) = 0;
      *(p + 3) = 0;
      break;
    case PDSC_S_K_KIND_FP_REGISTER:
      *(p + 2) = alpha_evax_proc.fp_save;
      *(p + 3) = alpha_evax_proc.ra_save;
      break;
    case PDSC_S_K_KIND_FP_STACK:
      md_number_to_chars (p + 2, (valueT) alpha_evax_proc.rsa_offset, 2);
      break;
    default:		/* impossible */
      break;
    }

  *(p + 4) = 0;
  *(p + 5) = alpha_evax_proc.type & 0x0f;

  /* Signature offset.  */
  md_number_to_chars (p + 6, (valueT) 0, 2);

  fix_new_exp (frag_now, p - frag_now->fr_literal+8, 8, &exp, 0, BFD_RELOC_64);

  if (alpha_evax_proc.pdsckind == PDSC_S_K_KIND_NULL)
    return;

  /* Add dummy fix to make add_to_link_pool work.  */
  p = frag_more (8);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;
  seginfo->literal_pool_size += 8;

  /* pdesc+16: Size.  */
  md_number_to_chars (p, (valueT) alpha_evax_proc.framesize, 4);

  md_number_to_chars (p + 4, (valueT) 0, 2);

  /* Entry length.  */
  md_number_to_chars (p + 6, alpha_evax_proc.prologue, 2);

  if (alpha_evax_proc.pdsckind == PDSC_S_K_KIND_FP_REGISTER)
    return;

  /* Add dummy fix to make add_to_link_pool work.  */
  p = frag_more (8);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;
  seginfo->literal_pool_size += 8;

  /* pdesc+24: register masks.  */

  md_number_to_chars (p, alpha_evax_proc.imask, 4);
  md_number_to_chars (p + 4, alpha_evax_proc.fmask, 4);
}

/* Support for crash debug on vms.  */

static void
s_alpha_name (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  register char *p;
  expressionS exp;
  segment_info_type *seginfo = seg_info (alpha_link_section);

  if (now_seg != alpha_link_section)
    {
      as_bad (_(".name directive not in link (.link) section"));
      demand_empty_rest_of_line ();
      return;
    }

  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_warn (_(".name directive has no symbol"));
      demand_empty_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  frag_align (3, 0, 0);
  p = frag_more (8);
  seginfo->literal_pool_size += 8;

  fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &exp, 0, BFD_RELOC_64);
}

static void
s_alpha_linkage (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  expressionS exp;
  char *p;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_fatal (_("No symbol after .linkage"));
    }
  else
    {
      p = frag_more (LKP_S_K_SIZE);
      memset (p, 0, LKP_S_K_SIZE);
      fix_new_exp (frag_now, p - frag_now->fr_literal, LKP_S_K_SIZE, &exp, 0,\
		   BFD_RELOC_ALPHA_LINKAGE);
    }
  demand_empty_rest_of_line ();
}

static void
s_alpha_code_address (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  expressionS exp;
  char *p;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_fatal (_("No symbol after .code_address"));
    }
  else
    {
      p = frag_more (8);
      memset (p, 0, 8);
      fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &exp, 0,\
		   BFD_RELOC_ALPHA_CODEADDR);
    }
  demand_empty_rest_of_line ();
}

static void
s_alpha_fp_save (ignore)
     int ignore ATTRIBUTE_UNUSED;
{

  alpha_evax_proc.fp_save = tc_get_register (1);

  demand_empty_rest_of_line ();
}

static void
s_alpha_mask (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  long val;

  if (get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn (_("Bad .mask directive"));
      --input_line_pointer;
    }
  else
    {
      alpha_evax_proc.imask = val;
      (void) get_absolute_expression ();
    }
  demand_empty_rest_of_line ();
}

static void
s_alpha_fmask (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  long val;

  if (get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn (_("Bad .fmask directive"));
      --input_line_pointer;
    }
  else
    {
      alpha_evax_proc.fmask = val;
      (void) get_absolute_expression ();
    }
  demand_empty_rest_of_line ();
}

static void
s_alpha_end (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char c;

  c = get_symbol_end ();
  *input_line_pointer = c;
  demand_empty_rest_of_line ();
  alpha_evax_proc.symbol = 0;
}

static void
s_alpha_file (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *s;
  int length;
  static char case_hack[32];

  sprintf (case_hack, "<CASE:%01d%01d>",
	   alpha_flag_hash_long_names, alpha_flag_show_after_trunc);

  s = symbol_find_or_make (case_hack);
  symbol_get_bfdsym (s)->flags |= BSF_FILE;

  get_absolute_expression ();
  s = symbol_find_or_make (demand_copy_string (&length));
  symbol_get_bfdsym (s)->flags |= BSF_FILE;
  demand_empty_rest_of_line ();
}
#endif /* OBJ_EVAX  */

/* Handle the .gprel32 pseudo op.  */

static void
s_alpha_gprel32 (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  expressionS e;
  char *p;

  SKIP_WHITESPACE ();
  expression (&e);

#ifdef OBJ_ELF
  switch (e.X_op)
    {
    case O_constant:
      e.X_add_symbol = section_symbol (absolute_section);
      e.X_op = O_symbol;
      /* FALLTHRU */
    case O_symbol:
      break;
    default:
      abort ();
    }
#else
#ifdef OBJ_ECOFF
  switch (e.X_op)
    {
    case O_constant:
      e.X_add_symbol = section_symbol (absolute_section);
      /* fall through */
    case O_symbol:
      e.X_op = O_subtract;
      e.X_op_symbol = alpha_gp_symbol;
      break;
    default:
      abort ();
    }
#endif
#endif

  if (alpha_auto_align_on && alpha_current_align < 2)
    alpha_align (2, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > 2)
    alpha_current_align = 2;
  alpha_insn_label = NULL;

  p = frag_more (4);
  memset (p, 0, 4);
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
	       &e, 0, BFD_RELOC_GPREL32);
}

/* Handle floating point allocation pseudo-ops.  This is like the
   generic vresion, but it makes sure the current label, if any, is
   correctly aligned.  */

static void
s_alpha_float_cons (type)
     int type;
{
  int log_size;

  switch (type)
    {
    default:
    case 'f':
    case 'F':
      log_size = 2;
      break;

    case 'd':
    case 'D':
    case 'G':
      log_size = 3;
      break;

    case 'x':
    case 'X':
    case 'p':
    case 'P':
      log_size = 4;
      break;
    }

  if (alpha_auto_align_on && alpha_current_align < log_size)
    alpha_align (log_size, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > log_size)
    alpha_current_align = log_size;
  alpha_insn_label = NULL;

  float_cons (type);
}

/* Handle the .proc pseudo op.  We don't really do much with it except
   parse it.  */

static void
s_alpha_proc (is_static)
     int is_static ATTRIBUTE_UNUSED;
{
  char *name;
  char c;
  char *p;
  symbolS *symbolP;
  int temp;

  /* Takes ".proc name,nargs"  */
  SKIP_WHITESPACE ();
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  symbolP = symbol_find_or_make (name);
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      *p = 0;
      as_warn (_("Expected comma after name \"%s\""), name);
      *p = c;
      temp = 0;
      ignore_rest_of_line ();
    }
  else
    {
      input_line_pointer++;
      temp = get_absolute_expression ();
    }
  /*  *symbol_get_obj (symbolP) = (signed char) temp; */
  as_warn (_("unhandled: .proc %s,%d"), name, temp);
  demand_empty_rest_of_line ();
}

/* Handle the .set pseudo op.  This is used to turn on and off most of
   the assembler features.  */

static void
s_alpha_set (x)
     int x ATTRIBUTE_UNUSED;
{
  char *name, ch, *s;
  int yesno = 1;

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  ch = get_symbol_end ();

  s = name;
  if (s[0] == 'n' && s[1] == 'o')
    {
      yesno = 0;
      s += 2;
    }
  if (!strcmp ("reorder", s))
    /* ignore */ ;
  else if (!strcmp ("at", s))
    alpha_noat_on = !yesno;
  else if (!strcmp ("macro", s))
    alpha_macros_on = yesno;
  else if (!strcmp ("move", s))
    /* ignore */ ;
  else if (!strcmp ("volatile", s))
    /* ignore */ ;
  else
    as_warn (_("Tried to .set unrecognized mode `%s'"), name);

  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

/* Handle the .base pseudo op.  This changes the assembler's notion of
   the $gp register.  */

static void
s_alpha_base (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
#if 0
  if (first_32bit_quadrant)
    {
      /* not fatal, but it might not work in the end */
      as_warn (_("File overrides no-base-register option."));
      first_32bit_quadrant = 0;
    }
#endif

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
    {				/* $rNN form */
      input_line_pointer++;
      if (*input_line_pointer == 'r')
	input_line_pointer++;
    }

  alpha_gp_register = get_absolute_expression ();
  if (alpha_gp_register < 0 || alpha_gp_register > 31)
    {
      alpha_gp_register = AXP_REG_GP;
      as_warn (_("Bad base register, using $%d."), alpha_gp_register);
    }

  demand_empty_rest_of_line ();
}

/* Handle the .align pseudo-op.  This aligns to a power of two.  It
   also adjusts any current instruction label.  We treat this the same
   way the MIPS port does: .align 0 turns off auto alignment.  */

static void
s_alpha_align (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int align;
  char fill, *pfill;
  long max_alignment = 15;

  align = get_absolute_expression ();
  if (align > max_alignment)
    {
      align = max_alignment;
      as_bad (_("Alignment too large: %d. assumed"), align);
    }
  else if (align < 0)
    {
      as_warn (_("Alignment negative: 0 assumed"));
      align = 0;
    }

  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      fill = get_absolute_expression ();
      pfill = &fill;
    }
  else
    pfill = NULL;

  if (align != 0)
    {
      alpha_auto_align_on = 1;
      alpha_align (align, pfill, alpha_insn_label, 1);
    }
  else
    {
      alpha_auto_align_on = 0;
    }

  demand_empty_rest_of_line ();
}

/* Hook the normal string processor to reset known alignment.  */

static void
s_alpha_stringer (terminate)
     int terminate;
{
  alpha_current_align = 0;
  alpha_insn_label = NULL;
  stringer (terminate);
}

/* Hook the normal space processing to reset known alignment.  */

static void
s_alpha_space (ignore)
     int ignore;
{
  alpha_current_align = 0;
  alpha_insn_label = NULL;
  s_space (ignore);
}

/* Hook into cons for auto-alignment.  */

void
alpha_cons_align (size)
     int size;
{
  int log_size;

  log_size = 0;
  while ((size >>= 1) != 0)
    ++log_size;

  if (alpha_auto_align_on && alpha_current_align < log_size)
    alpha_align (log_size, (char *) NULL, alpha_insn_label, 0);
  if (alpha_current_align > log_size)
    alpha_current_align = log_size;
  alpha_insn_label = NULL;
}

/* Here come the .uword, .ulong, and .uquad explicitly unaligned
   pseudos.  We just turn off auto-alignment and call down to cons.  */

static void
s_alpha_ucons (bytes)
     int bytes;
{
  int hold = alpha_auto_align_on;
  alpha_auto_align_on = 0;
  cons (bytes);
  alpha_auto_align_on = hold;
}

/* Switch the working cpu type.  */

static void
s_alpha_arch (ignored)
     int ignored ATTRIBUTE_UNUSED;
{
  char *name, ch;
  const struct cpu_type *p;

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  ch = get_symbol_end ();

  for (p = cpu_types; p->name; ++p)
    if (strcmp (name, p->name) == 0)
      {
	alpha_target_name = p->name, alpha_target = p->flags;
	goto found;
      }
  as_warn ("Unknown CPU identifier `%s'", name);

found:
  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

#ifdef DEBUG1
/* print token expression with alpha specific extension.  */

static void
alpha_print_token (f, exp)
     FILE *f;
     const expressionS *exp;
{
  switch (exp->X_op)
    {
    case O_cpregister:
      putc (',', f);
      /* FALLTHRU */
    case O_pregister:
      putc ('(', f);
      {
	expressionS nexp = *exp;
	nexp.X_op = O_register;
	print_expr (f, &nexp);
      }
      putc (')', f);
      break;
    default:
      print_expr (f, exp);
      break;
    }
}
#endif

/* The target specific pseudo-ops which we support.  */

const pseudo_typeS md_pseudo_table[] = {
#ifdef OBJ_ECOFF
  {"comm", s_alpha_comm, 0},	/* osf1 compiler does this */
  {"rdata", s_alpha_rdata, 0},
#endif
  {"text", s_alpha_text, 0},
  {"data", s_alpha_data, 0},
#ifdef OBJ_ECOFF
  {"sdata", s_alpha_sdata, 0},
#endif
#ifdef OBJ_ELF
  {"section", s_alpha_section, 0},
  {"section.s", s_alpha_section, 0},
  {"sect", s_alpha_section, 0},
  {"sect.s", s_alpha_section, 0},
#endif
#ifdef OBJ_EVAX
  { "pdesc", s_alpha_pdesc, 0},
  { "name", s_alpha_name, 0},
  { "linkage", s_alpha_linkage, 0},
  { "code_address", s_alpha_code_address, 0},
  { "ent", s_alpha_ent, 0},
  { "frame", s_alpha_frame, 0},
  { "fp_save", s_alpha_fp_save, 0},
  { "mask", s_alpha_mask, 0},
  { "fmask", s_alpha_fmask, 0},
  { "end", s_alpha_end, 0},
  { "file", s_alpha_file, 0},
  { "rdata", s_alpha_section, 1},
  { "comm", s_alpha_comm, 0},
  { "link", s_alpha_section, 3},
  { "ctors", s_alpha_section, 4},
  { "dtors", s_alpha_section, 5},
#endif
#ifdef OBJ_ELF
  /* Frame related pseudos.  */
  {"ent", s_alpha_ent, 0},
  {"end", s_alpha_end, 0},
  {"mask", s_alpha_mask, 0},
  {"fmask", s_alpha_mask, 1},
  {"frame", s_alpha_frame, 0},
  {"prologue", s_alpha_prologue, 0},
  {"file", s_alpha_file, 5},
  {"loc", s_alpha_loc, 9},
  {"stabs", s_alpha_stab, 's'},
  {"stabn", s_alpha_stab, 'n'},
  {"usepv", s_alpha_usepv, 0},
  /* COFF debugging related pseudos.  */
  {"begin", s_alpha_coff_wrapper, 0},
  {"bend", s_alpha_coff_wrapper, 1},
  {"def", s_alpha_coff_wrapper, 2},
  {"dim", s_alpha_coff_wrapper, 3},
  {"endef", s_alpha_coff_wrapper, 4},
  {"scl", s_alpha_coff_wrapper, 5},
  {"tag", s_alpha_coff_wrapper, 6},
  {"val", s_alpha_coff_wrapper, 7},
#else
  {"prologue", s_ignore, 0},
#endif
  {"gprel32", s_alpha_gprel32, 0},
  {"t_floating", s_alpha_float_cons, 'd'},
  {"s_floating", s_alpha_float_cons, 'f'},
  {"f_floating", s_alpha_float_cons, 'F'},
  {"g_floating", s_alpha_float_cons, 'G'},
  {"d_floating", s_alpha_float_cons, 'D'},

  {"proc", s_alpha_proc, 0},
  {"aproc", s_alpha_proc, 1},
  {"set", s_alpha_set, 0},
  {"reguse", s_ignore, 0},
  {"livereg", s_ignore, 0},
  {"base", s_alpha_base, 0},		/*??*/
  {"option", s_ignore, 0},
  {"aent", s_ignore, 0},
  {"ugen", s_ignore, 0},
  {"eflag", s_ignore, 0},

  {"align", s_alpha_align, 0},
  {"double", s_alpha_float_cons, 'd'},
  {"float", s_alpha_float_cons, 'f'},
  {"single", s_alpha_float_cons, 'f'},
  {"ascii", s_alpha_stringer, 0},
  {"asciz", s_alpha_stringer, 1},
  {"string", s_alpha_stringer, 1},
  {"space", s_alpha_space, 0},
  {"skip", s_alpha_space, 0},
  {"zero", s_alpha_space, 0},

/* Unaligned data pseudos.  */
  {"uword", s_alpha_ucons, 2},
  {"ulong", s_alpha_ucons, 4},
  {"uquad", s_alpha_ucons, 8},

#ifdef OBJ_ELF
/* Dwarf wants these versions of unaligned.  */
  {"2byte", s_alpha_ucons, 2},
  {"4byte", s_alpha_ucons, 4},
  {"8byte", s_alpha_ucons, 8},
#endif

/* We don't do any optimizing, so we can safely ignore these.  */
  {"noalias", s_ignore, 0},
  {"alias", s_ignore, 0},

  {"arch", s_alpha_arch, 0},

  {NULL, 0, 0},
};

/* Build a BFD section with its flags set appropriately for the .lita,
   .lit8, or .lit4 sections.  */

static void
create_literal_section (name, secp, symp)
     const char *name;
     segT *secp;
     symbolS **symp;
{
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT new_sec;

  *secp = new_sec = subseg_new (name, 0);
  subseg_set (current_section, current_subsec);
  bfd_set_section_alignment (stdoutput, new_sec, 4);
  bfd_set_section_flags (stdoutput, new_sec,
			 SEC_RELOC | SEC_ALLOC | SEC_LOAD | SEC_READONLY
			 | SEC_DATA);

  S_CLEAR_EXTERNAL (*symp = section_symbol (new_sec));
}

#ifdef OBJ_ECOFF

/* @@@@@@ GP selection voodoo.  All of this seems overly complicated and
   unnecessary; which is the primary reason it's for ECOFF only.  */
static inline void maybe_set_gp PARAMS ((asection *));

static inline void
maybe_set_gp (sec)
     asection *sec;
{
  bfd_vma vma;
  if (!sec)
    return;
  vma = bfd_get_section_vma (foo, sec);
  if (vma && vma < alpha_gp_value)
    alpha_gp_value = vma;
}

static void
select_gp_value ()
{
  assert (alpha_gp_value == 0);

  /* Get minus-one in whatever width...  */
  alpha_gp_value = 0;
  alpha_gp_value--;

  /* Select the smallest VMA of these existing sections.  */
  maybe_set_gp (alpha_lita_section);
#if 0
  /* These were disabled before -- should we use them?  */
  maybe_set_gp (sdata);
  maybe_set_gp (lit8_sec);
  maybe_set_gp (lit4_sec);
#endif

/* @@@@ Will a simple 0x8000 work here?  If not, why not?  */
#define GP_ADJUSTMENT	(0x8000 - 0x10)

  alpha_gp_value += GP_ADJUSTMENT;

  S_SET_VALUE (alpha_gp_symbol, alpha_gp_value);

#ifdef DEBUG1
  printf (_("Chose GP value of %lx\n"), alpha_gp_value);
#endif
}
#endif /* OBJ_ECOFF */

#ifdef OBJ_ELF
/* Map 's' to SHF_ALPHA_GPREL.  */

int
alpha_elf_section_letter (letter, ptr_msg)
     int letter;
     char **ptr_msg;
{
  if (letter == 's')
    return SHF_ALPHA_GPREL;

  *ptr_msg = _("Bad .section directive: want a,s,w,x,M,S,G,T in string");
  return -1;
}

/* Map SHF_ALPHA_GPREL to SEC_SMALL_DATA.  */

flagword
alpha_elf_section_flags (flags, attr, type)
     flagword flags;
     int attr, type ATTRIBUTE_UNUSED;
{
  if (attr & SHF_ALPHA_GPREL)
    flags |= SEC_SMALL_DATA;
  return flags;
}
#endif /* OBJ_ELF */

/* Called internally to handle all alignment needs.  This takes care
   of eliding calls to frag_align if'n the cached current alignment
   says we've already got it, as well as taking care of the auto-align
   feature wrt labels.  */

static void
alpha_align (n, pfill, label, force)
     int n;
     char *pfill;
     symbolS *label;
     int force ATTRIBUTE_UNUSED;
{
  if (alpha_current_align >= n)
    return;

  if (pfill == NULL)
    {
      if (subseg_text_p (now_seg))
	frag_align_code (n, 0);
      else
	frag_align (n, 0, 0);
    }
  else
    frag_align (n, *pfill, 0);

  alpha_current_align = n;

  if (label != NULL && S_GET_SEGMENT (label) == now_seg)
    {
      symbol_set_frag (label, frag_now);
      S_SET_VALUE (label, (valueT) frag_now_fix ());
    }

  record_alignment (now_seg, n);

  /* ??? If alpha_flag_relax && force && elf, record the requested alignment
     in a reloc for the linker to see.  */
}

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
alpha_handle_align (fragp)
     fragS *fragp;
{
  static char const unop[4] = { 0x00, 0x00, 0xfe, 0x2f };
  static char const nopunop[8] = {
    0x1f, 0x04, 0xff, 0x47,
    0x00, 0x00, 0xfe, 0x2f
  };

  int bytes, fix;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;
  fix = 0;

  if (bytes & 3)
    {
      fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }

  if (bytes & 4)
    {
      memcpy (p, unop, 4);
      p += 4;
      bytes -= 4;
      fix += 4;
    }

  memcpy (p, nopunop, 8);

  fragp->fr_fix += fix;
  fragp->fr_var = 8;
}

/* The Alpha has support for some VAX floating point types, as well as for
   IEEE floating point.  We consider IEEE to be the primary floating point
   format, and sneak in the VAX floating point support here.  */
#define md_atof vax_md_atof
#include "config/atof-vax.c"
@


1.9
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d63 1
d270 1
a411 5
#ifdef OBJ_ELF
/* The active .ent symbol.  */
static symbolS *alpha_cur_ent_sym;
#endif

d536 1
a536 1
/* Structure to hold explict sequence information.  */
d1730 1
a1730 1
  /* First rebuild the fixup chain without the expicit lituse and
d3017 1
a3017 1
   and used, then explict_reloc with be an expression pointer.
d3368 1
a3368 1
   most simple expressions, particualrly symbol address loads and
d4382 19
d4437 1
a4437 1
	  if (alpha_cur_ent_sym)
d4442 10
a4451 1
	  alpha_cur_ent_sym = sym;
d4491 3
a4493 1
	  if (sym != alpha_cur_ent_sym)
d4497 1
a4497 1
	  if (sym)
d4499 10
a4508 7
	      symbol_get_obj (sym)->size =
		(expressionS *) xmalloc (sizeof (expressionS));
	      symbol_get_obj (sym)->size->X_op = O_subtract;
	      symbol_get_obj (sym)->size->X_add_symbol
		= symbol_new ("L0\001", now_seg, frag_now_fix (), frag_now);
	      symbol_get_obj (sym)->size->X_op_symbol = sym;
	      symbol_get_obj (sym)->size->X_add_number = 0;
d4511 1
a4511 1
	  alpha_cur_ent_sym = NULL;
d4531 39
a4569 1
    discard_rest_of_line ();
d4579 30
a4608 1
    discard_rest_of_line ();
d4624 1
a4624 1
    sym = alpha_cur_ent_sym;
d4649 3
d4745 130
d4877 8
a4945 1
  return;
a4979 2

  return;
a5128 2

  return;
a5166 2

  return;
a5192 2

  return;
a5218 2

  return;
a5228 1
  return;
a5247 2

  return;
a5266 2

  return;
a5278 2

  return;
a5288 2
  extern char *demand_copy_string PARAMS ((int *lenP));

a5298 2

  return;
a5657 1
  return;
d5709 1
d5856 1
a5856 1
  return 0;
@


1.8
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d65 1
a65 1
#include <ctype.h>
d67 1
a67 1
/* Local types */
d75 2
a76 1
struct alpha_fixup {
d81 2
a82 1
struct alpha_insn {
d86 1
a86 1
  unsigned sequence[MAX_INSN_FIXUPS];
d89 10
a98 13
enum alpha_macro_arg {
  MACRO_EOA = 1,
  MACRO_IR,
  MACRO_PIR,
  MACRO_OPIR,
  MACRO_CPIR,
  MACRO_FPR,
  MACRO_EXP,
  MACRO_LITERAL,
  MACRO_BASE,
  MACRO_BYTOFF,
  MACRO_JSR
};
d100 2
a101 1
struct alpha_macro {
d113 1
a113 3
#ifdef RELOC_OP_P
/* Note, the alpha_reloc_op table below depends on the ordering
   of O_literal .. O_gprelow.  */
d115 28
a142 6
#define O_lituse_base	O_md4	/* !lituse_base relocation */
#define O_lituse_bytoff	O_md5	/* !lituse_bytoff relocation */
#define O_lituse_jsr	O_md6	/* !lituse_jsr relocation */
#define O_gpdisp	O_md7	/* !gpdisp relocation */
#define O_gprelhigh	O_md8	/* !gprelhigh relocation */
#define O_gprellow	O_md9	/* !gprellow relocation */
d144 1
a144 2
#define USER_RELOC_P(R) ((R) >= O_literal && (R) <= O_gprellow)
#endif
d146 1
a146 1
/* Macros for extracting the type and number of encoded register tokens */
d152 1
a152 1
/* Something odd inherited from the old assembler */
d186 1
a186 1
/* Macros to build tokens */
d208 4
a211 1
/* Prototypes for all local functions */
d222 1
a222 1
	   struct alpha_insn *));
d229 2
a230 3
static int load_expression
  PARAMS ((int, const expressionS *, int *, expressionS *,
	   const expressionS *));
d281 2
a288 4

#ifdef RELOC_OP_P
static void alpha_adjust_symtab_relocs PARAMS ((bfd *, asection *, PTR));
#endif
d322 2
a323 1
struct option md_longopts[] = {
d325 1
a325 1
  { "32addr", no_argument, NULL, OPTION_32ADDR },
d327 1
a327 1
  { "relax", no_argument, NULL, OPTION_RELAX },
d331 2
a332 2
  { "mdebug", no_argument, NULL, OPTION_MDEBUG },
  { "no-mdebug", no_argument, NULL, OPTION_NO_MDEBUG },
d334 2
a335 2
  { NULL, no_argument, NULL, 0 }
};
d359 1
a359 1
/* The cpu for which we are generating code */
d363 1
a363 1
/* The hash table of instruction opcodes */
d366 1
a366 1
/* The hash table of macro opcodes */
d370 1
a370 1
/* The $gp relocation symbol */
d377 1
a377 1
/* The current $gp register */
d380 1
a380 1
/* A table of the register symbols */
d383 1
a383 1
/* Constant sections, or sections of constants */
a385 1
static segT alpha_lit4_section;
a396 1
static symbolS *alpha_lit4_symbol;
d405 1
a405 1
/* Literal for .litX+0x8000 within .lita */
a406 1
static offsetT alpha_lit4_literal;
d415 1
a415 1
/* Is the assembler not allowed to use $at? */
d418 1
a418 1
/* Are macros enabled? */
d421 1
a421 1
/* Are floats disabled? */
d424 1
a424 1
/* Are addresses 32 bit? */
d478 1
a478 2
 * longer than 64 characters, else longer symbol names are truncated.
 */
d488 1
a488 1
&alpha_reloc_op[ ((!USER_RELOC_P (op))					\
d490 1
a490 1
		  : (int) (op) - (int) O_literal) ]
d492 2
a493 3
#define LITUSE_BASE	1
#define LITUSE_BYTOFF	2
#define LITUSE_JSR	3
d495 2
a496 1
static const struct alpha_reloc_op_tag {
d499 1
d501 28
a528 3
  operatorT op;					/* which operator to use */
  int lituse;					/* addened to specify lituse */
} alpha_reloc_op[] = {
d530 1
a530 56
  {
    "literal",					/* name */
    sizeof ("literal")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITERAL,		/* reloc */
    O_literal,					/* op */
    0,						/* lituse */
  },

  {
    "lituse_base",				/* name */
    sizeof ("lituse_base")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITUSE_BASE,		/* reloc */
    O_lituse_base,				/* op */
    LITUSE_BASE,				/* lituse */
  },

  {
    "lituse_bytoff",				/* name */
    sizeof ("lituse_bytoff")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF,		/* reloc */
    O_lituse_bytoff,				/* op */
    LITUSE_BYTOFF,				/* lituse */
  },

  {
    "lituse_jsr",				/* name */
    sizeof ("lituse_jsr")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITUSE_JSR,		/* reloc */
    O_lituse_jsr,				/* op */
    LITUSE_JSR,					/* lituse */
  },

  {
    "gpdisp",					/* name */
    sizeof ("gpdisp")-1,			/* length */
    BFD_RELOC_ALPHA_USER_GPDISP,		/* reloc */
    O_gpdisp,					/* op */
    0,						/* lituse */
  },

  {
    "gprelhigh",				/* name */
    sizeof ("gprelhigh")-1,			/* length */
    BFD_RELOC_ALPHA_USER_GPRELHIGH,		/* reloc */
    O_gprelhigh,				/* op */
    0,						/* lituse */
  },

  {
    "gprellow",					/* name */
    sizeof ("gprellow")-1,			/* length */
    BFD_RELOC_ALPHA_USER_GPRELLOW,		/* reloc */
    O_gprellow,					/* op */
    0,						/* lituse */
  },
};
d534 1
a538 3
/* Whether a sequence number is valid.  */
#define ALPHA_RELOC_SEQUENCE_OK(X) ((X) > 0 && ((unsigned) (X)) == (X))

d540 1
a540 1
struct alpha_literal_tag
d542 2
a543 1
  fixS *lituse;			/* head of linked list of !literals */
d545 8
a552 4
  int multi_section_p;		/* True if more than one section was used */
  unsigned sequence;		/* sequence # */
  unsigned n_literals;		/* # of literals */
  unsigned n_lituses;		/* # of lituses */
d558 3
a560 1
#endif
d564 2
a565 1
static const struct cpu_type {
d568 3
a570 1
} cpu_types[] = {
d586 4
d598 2
d607 2
a608 1
static const struct alpha_macro alpha_macros[] = {
d611 1
a611 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_LITERAL, MACRO_BASE, MACRO_EOA } },
d616 1
a616 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d618 1
a618 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d620 1
a620 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_LITERAL, MACRO_EOA } },
d622 1
a622 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d624 1
a624 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d626 1
a626 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d628 1
a628 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d630 1
a630 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d632 1
a632 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d635 1
a635 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d637 1
a637 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d639 1
a639 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d641 1
a641 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d644 1
a644 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d646 1
a646 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d648 1
a648 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d650 1
a650 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d652 1
a652 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d677 1
a677 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d679 1
a679 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d681 1
a681 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d683 1
a683 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d685 1
a685 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d687 1
a687 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d689 1
a689 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d691 1
a691 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d693 1
a693 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d696 1
a696 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d698 1
a698 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d700 1
a700 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d702 1
a702 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d704 1
a704 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d767 4
a770 4
    { MACRO_PIR, MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_PIR, MACRO_JSR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_EXP, MACRO_JSR, MACRO_EOA } },
d772 4
a775 4
    { MACRO_PIR, MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_PIR, MACRO_JSR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_EXP, MACRO_JSR, MACRO_EOA } },
d820 1
a820 2
  /* Create the opcode hash table */

d829 2
a830 1
	as_fatal (_("internal error: can't hash opcode `%s': %s"), name, retval);
d854 1
a854 2
  /* Create the macro hash table */

d872 1
a872 2
  /* Construct symbols for each of the registers */

d876 1
d884 1
d890 1
a890 1
  /* Create the special symbols and sections we'll be using */
a916 3
  subseg_set (text_section, 0);

#ifdef RELOC_OP_P
d919 2
a920 1
#endif
d929 1
a929 1
  char opname[32];			/* current maximum is 13 */
d934 1
a934 1
  /* split off the opcode */
d942 1
a942 1
  /* tokenize the rest of the line */
d951 1
a951 1
  /* finish it off */
d973 1
a973 1
/* Equal to MAX_PRECISION in atof-ieee.c */
d1118 1
a1118 1
-mev4 | -mev45 | -mev5 | -mev56 | -mpca56 | -mev6 | -mall\n\
d1120 1
a1120 1
-m21064 | -m21066 | -m21164 | -m21164a | -m21164pc | -m21264\n\
d1142 5
a1146 3
    case BFD_RELOC_ALPHA_GPDISP:
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
a1147 2
    default:
      return fixP->fx_size + addr;
d1161 2
a1162 2
int
md_apply_fix (fixP, valueP)
d1164 2
a1165 1
     valueT *valueP;
d1168 1
a1168 1
  valueT value = *valueP;
d1174 3
a1176 3
	 referring to the current function; we need to drop in a value
	 which, when added to the address of the start of the function,
	 gives the desired GP.  */
a1179 1
	assert (next->fx_r_type == BFD_RELOC_ALPHA_GPDISP_LO16);
d1181 6
a1186 2
	fixP->fx_offset = (next->fx_frag->fr_address + next->fx_where
			   - fixP->fx_frag->fr_address - fixP->fx_where);
d1203 1
a1203 1
      fixP->fx_addsy = section_symbol (now_seg);
d1227 1
a1227 1
      return 1;
d1236 1
a1236 2
#endif
#ifdef OBJ_ELF
a1237 1
      return 1;
d1239 4
d1251 1
a1251 1
      return 1;
d1260 20
a1279 1
      return 1;
d1284 1
a1284 4
      return 1;

    case BFD_RELOC_ALPHA_LITUSE:
      return 1;
a1285 1
#ifdef OBJ_ELF
a1287 3
      return 1;
#endif
#ifdef OBJ_EVAX
d1290 1
a1290 15
      return 1;
#endif

#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITERAL:
    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
      return 1;

    case BFD_RELOC_ALPHA_USER_GPDISP:
    case BFD_RELOC_ALPHA_USER_GPRELHIGH:
    case BFD_RELOC_ALPHA_USER_GPRELLOW:
      abort ();
#endif
d1294 1
a1294 1
      return 1;
d1324 1
a1324 1
    return 1;
a1336 1
  return 0;
d1339 1
a1339 3
/*
 * Look for a register name in the given symbol.
 */
d1358 1
a1358 1
	  if (!isdigit (*++name))
d1366 1
a1366 1
	  else if (name[0] != '0' && isdigit (name[1]) && name[2] == '\0')
d1427 1
a1427 1
   there is some hope of resolving it a assembly time.  */
a1440 1
#ifdef OBJ_ECOFF
a1441 2
#endif
#ifdef OBJ_ELF
a1442 1
#endif
d1444 1
d1446 2
a1447 1
#ifdef OBJ_EVAX
d1450 11
a1460 12
#endif
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITERAL:
    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
    case BFD_RELOC_ALPHA_USER_GPDISP:
    case BFD_RELOC_ALPHA_USER_GPRELHIGH:
    case BFD_RELOC_ALPHA_USER_GPRELLOW:
#endif
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
a1462 6
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_32:
    case BFD_RELOC_64:
    case BFD_RELOC_ALPHA_HINT:
      return 0;

d1464 1
a1464 3
      assert ((int) f->fx_r_type < 0
	      && -(int) f->fx_r_type < (int) alpha_num_operands);
      return 0;
d1466 2
a1475 6
#ifdef OBJ_ELF
  /* Prevent all adjustments to global symbols */
  if (S_IS_EXTERN (f->fx_addsy) || S_IS_WEAK (f->fx_addsy))
    return 0;
#endif

a1484 1
#ifdef OBJ_ECOFF
a1485 2
#endif
#ifdef OBJ_ELF
d1487 1
a1487 5
#endif
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITERAL:
#endif
#ifdef OBJ_EVAX
a1489 1
#endif
a1491 9
    case BFD_RELOC_ALPHA_LITUSE:
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
    case BFD_RELOC_ALPHA_USER_GPDISP:
    case BFD_RELOC_ALPHA_USER_GPRELHIGH:
    case BFD_RELOC_ALPHA_USER_GPRELLOW:
#endif
d1496 1
d1498 2
d1506 49
a1555 2
      assert ((int) f->fx_r_type < 0
	      && - (int) f->fx_r_type < (int) alpha_num_operands);
d1599 1
a1599 1
      /* fake out bfd_perform_relocation. sigh */
d1607 7
a1613 7
      /*
       * Ohhh, this is ugly.  The problem is that if this is a local global
       * symbol, the relocation will entirely be performed at link time, not
       * at assembly time.  bfd_perform_reloc doesn't know about this sort
       * of thing, and as a result we need to fake it out here.
       */
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
d1671 28
a1698 1
#ifdef RELOC_OP_P
d1702 1
a1702 2
   relocations.  Also convert the gas-internal relocations to the
   appropriate linker relocations.  */
d1705 1
a1705 1
alpha_adjust_symtab ()
d1708 1
a1708 11
    {
#ifdef DEBUG2_ALPHA
      fprintf (stderr, "alpha_adjust_symtab called\n");
#endif

      /* Go over each section, reordering the relocations so that all
         of the explicit LITUSE's are adjacent to the explicit
         LITERAL's.  */
      bfd_map_over_sections (stdoutput, alpha_adjust_symtab_relocs,
			     (char *) 0);
    }
a1709 2

/* Inner function to move LITUSE's next to the LITERAL.  */
d1712 1
a1712 1
alpha_adjust_symtab_relocs (abfd, sec, ptr)
d1721 1
a1721 8
  fixS *lituse;
  int n_lituses = 0;

#ifdef DEBUG2_ALPHA
  int n = 0;
  int n_literals = 0;
  int n_dup_literals = 0;
#endif
d1733 3
a1735 2
  /* First rebuild the fixup chain without the expicit lituse's.  */
  prevP = &(seginfo->fix_root);
a1739 3
#ifdef DEBUG2_ALPHA
      n++;
#endif
d1743 20
a1762 8
	default:
	  *prevP = fixp;
	  prevP = &(fixp->fx_next);
#ifdef DEBUG2_ALPHA
	  fprintf (stderr,
		   "alpha_adjust_symtab_relocs: 0x%lx, other relocation %s\n",
		   (long) fixp,
		   bfd_get_reloc_code_name (fixp->fx_r_type));
d1766 5
a1770 14
	case BFD_RELOC_ALPHA_USER_LITERAL:
	  *prevP = fixp;
	  prevP = &(fixp->fx_next);
	  /* prevent assembler from trying to adjust the offset */
#ifdef DEBUG2_ALPHA
	  n_literals++;
	  if (fixp->tc_fix_data.info->n_literals != 1)
	    n_dup_literals++;
	  fprintf (stderr,
		   "alpha_adjust_symtab_relocs: 0x%lx, !literal!%.6d, # literals = %2d\n",
		   (long) fixp,
		   fixp->tc_fix_data.info->sequence,
		   fixp->tc_fix_data.info->n_literals);
#endif
d1773 10
a1782 17
	  /* do not link in lituse's */
	case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	  n_lituses++;
	  if (fixp->tc_fix_data.info->n_literals == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No !literal!%d was found"),
			  fixp->tc_fix_data.info->sequence);
#ifdef DEBUG2_ALPHA
	  fprintf (stderr,
		   "alpha_adjust_symtab_relocs: 0x%lx, !lituse !%.6d, # lituses  = %2d, next_lituse = 0x%lx\n",
		   (long) fixp,
		   fixp->tc_fix_data.info->sequence,
		   fixp->tc_fix_data.info->n_lituses,
		   (long) fixp->tc_fix_data.next_lituse);
#endif
d1787 19
a1805 9
  /* If there were any lituses, go and add them to the chain, unless there is
     more than one !literal for a given sequence number.  They are linked
     through the next_lituse field in reverse order, so as we go through the
     next_lituse chain, we effectively reverse the chain once again.  If there
     was more than one !literal, we fall back to loading up the address w/o
     optimization.  Also, if the !literals/!lituses are spread in different
     segments (happens in the Linux kernel semaphores), suppress the
     optimization.  */
  if (n_lituses)
d1807 2
a1808 1
      for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
d1810 7
a1816 1
	  switch (fixp->fx_r_type)
d1818 5
a1822 1
	    default:
d1824 6
d1831 8
a1838 8
	    case BFD_RELOC_ALPHA_USER_LITERAL:
#ifdef OBJ_ELF
	      fixp->fx_r_type = BFD_RELOC_ALPHA_ELF_LITERAL;
#else
	      fixp->fx_r_type = BFD_RELOC_ALPHA_LITERAL;	/* XXX check this */
#endif
	      if (fixp->tc_fix_data.info->n_literals == 1
		  && ! fixp->tc_fix_data.info->multi_section_p)
d1840 2
a1841 7
		  for (lituse = fixp->tc_fix_data.info->lituse;
		       lituse != (fixS *) 0;
		       lituse = lituse->tc_fix_data.next_lituse)
		    {
		      lituse->fx_next = fixp->fx_next;
		      fixp->fx_next = lituse;
		    }
d1843 2
a1844 1
	      break;
d1846 10
a1855 5
	    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	      fixp->fx_r_type = BFD_RELOC_ALPHA_LITUSE;
	      break;
d1857 4
a1862 8

#ifdef DEBUG2_ALPHA
  fprintf (stderr, "alpha_adjust_symtab_relocs: %s, %d literal%s, %d duplicate literal%s, %d lituse%s\n\n",
	   sec->name,
	   n_literals, (n_literals == 1) ? "" : "s",
	   n_dup_literals, (n_dup_literals == 1) ? "" : "s",
	   n_lituses, (n_lituses == 1) ? "" : "s");
#endif
a1863 2

#endif /* RELOC_OP_P */
d1878 1
d1915 1
d1919 2
d1924 12
a1935 7
	case O_md10:			name = "O_md10";		break;
	case O_md11:			name = "O_md11";		break;
	case O_md12:			name = "O_md12";		break;
	case O_md13:			name = "O_md13";		break;
	case O_md14:			name = "O_md14";		break;
	case O_md15:			name = "O_md15";		break;
	case O_md16:			name = "O_md16";		break;
d1972 1
a1972 1
  /* Save and restore input_line_pointer around this function */
d1976 5
d1995 2
a1996 1
	    {			/* only support one relocation op per insn */
d2004 4
a2007 5
	  for (p = ++input_line_pointer;
	       ((c = *p) != '!' && c != ';' && c != '#' && c != ','
		&& !is_end_of_line[c]);
	       p++)
	    ;
d2009 2
a2010 2
	  /* Parse !relocation_type */
	  len = p - input_line_pointer;
d2017 5
a2021 1
	  if (c != '!')
d2023 1
a2023 1
	      as_bad (_("No !sequence-number after !%s"), input_line_pointer);
d2027 3
a2029 2
	  r = &alpha_reloc_op[0];
	  for (i = alpha_num_reloc_op - 1; i >= 0; i--, r++)
d2031 7
a2037 3
	      if (len == r->length
		  && memcmp (input_line_pointer, r->name, len) == 0)
		break;
d2039 1
a2039 1
	  if (i < 0)
d2041 5
a2045 4
	      as_bad (_("Unknown relocation operand: !%s"),
		      input_line_pointer);
	      goto err_report;
	    }
d2047 1
a2047 1
	  input_line_pointer = ++p;
d2049 8
a2056 10
	  /* Parse !sequence_number */
	  memset (tok, '\0', sizeof (expressionS));
	  expression (tok);

	  if (tok->X_op != O_constant
	      || ! ALPHA_RELOC_SEQUENCE_OK (tok->X_add_number))
	    {
	      as_bad (_("Bad sequence number: !%s!%s"),
		      r->name, input_line_pointer);
	      goto err_report;
d2063 1
a2063 1
#endif
d2088 1
a2088 1
	    /* ... then fall through to plain expression */
d2115 3
d2122 3
d2130 2
a2133 1
#endif
d2155 1
a2155 1
      /* Don't match opcodes that don't exist on this architecture */
d2165 1
a2165 1
	  /* only take input from real operands */
d2169 1
a2169 1
	  /* when we expect input, make sure we have it */
d2177 1
a2177 1
	  /* match operand type with expression type */
d2219 1
a2219 1
	      /* everything else should have been fake */
d2225 1
a2225 1
      /* possible match -- did we use all of our input? */
d2234 1
a2234 1
  while (++opcode - alpha_opcodes < alpha_num_opcodes
d2271 1
a2271 1
	      /* index register */
d2279 1
a2279 1
	      /* parenthesized index register */
d2287 1
a2287 1
	      /* optional parenthesized index register */
d2294 1
a2294 1
	      /* leading comma with a parenthesized index register */
d2302 1
a2302 1
	      /* floating point register */
d2310 1
a2310 1
	      /* normal expression */
a2320 1
#ifdef RELOC_OP_P
d2328 2
a2329 1
#endif
a2337 32
	      /* optional !literal!<number> */
	    case MACRO_LITERAL:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_literal)
		tokidx++;
#endif
	      break;

	      /* optional !lituse_base!<number> */
	    case MACRO_BASE:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_lituse_base)
		tokidx++;
#endif
	      break;

	      /* optional !lituse_bytoff!<number> */
	    case MACRO_BYTOFF:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_lituse_bytoff)
		tokidx++;
#endif
	      break;

	      /* optional !lituse_jsr!<number> */
	    case MACRO_JSR:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_lituse_jsr)
		tokidx++;
#endif
	      break;

d2347 1
a2347 1
  while (++macro - alpha_macros < alpha_num_macros
d2406 2
a2407 4
/*
 * Turn an opcode description and a set of arguments into
 * an instruction and a fixup.
 */
d2410 1
a2410 1
assemble_insn (opcode, tok, ntok, insn)
d2415 1
d2417 2
d2474 3
d2480 4
a2483 2
	  {
	    struct alpha_fixup *fixup;
d2485 6
a2490 2
	    if (insn->nfixups >= MAX_INSN_FIXUPS)
	      as_fatal (_("too many fixups"));
d2492 2
a2493 1
	    fixup = &insn->fixups[insn->nfixups++];
d2495 13
a2507 3
	    fixup->exp = *t;
	    fixup->reloc = operand->default_reloc;
	  }
d2512 41
d2556 1
a2556 3
/*
 * Actually output an instruction with its fixup.
 */
d2580 1
a2580 1
  /* Apply the fixups in order */
d2585 1
a2587 4
#ifdef RELOC_OP_P
      char buffer[ALPHA_RELOC_DIGITS];
      struct alpha_literal_tag *info;
#endif
d2589 1
a2589 1
      /* Some fixups are only used internally and so have no howto */
d2596 7
d2604 4
a2607 23
	switch (fixup->reloc)
	  {
#ifdef OBJ_ELF
	    /* These relocation types are only used internally.  */
	  case BFD_RELOC_ALPHA_GPDISP_HI16:
	  case BFD_RELOC_ALPHA_GPDISP_LO16:
	    size = 2;
	    pcrel = 0;
	    break;
#endif
#ifdef RELOC_OP_P
	    /* and these also are internal only relocations */
	  case BFD_RELOC_ALPHA_USER_LITERAL:
	  case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	  case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	  case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	  case BFD_RELOC_ALPHA_USER_GPDISP:
	  case BFD_RELOC_ALPHA_USER_GPRELHIGH:
	  case BFD_RELOC_ALPHA_USER_GPRELLOW:
	    size = 2;
	    pcrel = 0;
	    break;
#endif
d2609 2
a2610 5
	  default:
	    {
	      reloc_howto_type *reloc_howto
		= bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	      assert (reloc_howto);
d2612 2
a2613 6
	      size = bfd_get_reloc_size (reloc_howto);
	      pcrel = reloc_howto->pc_relative;
	    }
	    assert (size >= 1 && size <= 4);
	    break;
	  }
d2622 1
a2622 7
	case BFD_RELOC_ALPHA_GPDISP_LO16:
#ifdef OBJ_ECOFF
	case BFD_RELOC_ALPHA_LITERAL:
#endif
#ifdef OBJ_ELF
	case BFD_RELOC_ALPHA_ELF_LITERAL:
#endif
d2624 11
d2638 1
a2638 2
#ifdef RELOC_OP_P
	case BFD_RELOC_ALPHA_USER_LITERAL:
d2640 2
a2641 3
	  sprintf (buffer, "!%u", insn->sequence[i]);
	  info = ((struct alpha_literal_tag *)
		  hash_find (alpha_literal_hash, buffer));
d2643 8
a2650 4
	  if (! info)
	    {
	      size_t len = strlen (buffer);
	      const char *errmsg;
d2652 2
a2653 2
	      info = ((struct alpha_literal_tag *)
		      xcalloc (sizeof (struct alpha_literal_tag) + len, 1));
d2655 9
a2663 7
	      info->segment = now_seg;
	      info->sequence = insn->sequence[i];
	      strcpy (info->string, buffer);
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR) info);
	      if (errmsg)
		as_bad (errmsg);
	    }
d2665 3
a2667 1
	  ++info->n_literals;
d2669 5
a2675 1

d2679 29
a2707 8
	case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	  sprintf (buffer, "!%u", insn->sequence[i]);
	  info = ((struct alpha_literal_tag *)
		  hash_find (alpha_literal_hash, buffer));

	  if (! info)
d2709 6
a2714 12
	      size_t len = strlen (buffer);
	      const char *errmsg;

	      info = ((struct alpha_literal_tag *)
		      xcalloc (sizeof (struct alpha_literal_tag) + len, 1));

	      info->segment = now_seg;
	      info->sequence = insn->sequence[i];
	      strcpy (info->string, buffer);
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR) info);
	      if (errmsg)
		as_bad (errmsg);
a2715 1
	  info->n_lituses++;
d2717 2
a2718 2
	  fixP->tc_fix_data.next_lituse = info->lituse;
	  info->lituse = fixP;
d2721 1
d2723 30
a2754 1

d2789 1
a2789 1
	  assemble_insn (opcode, tok, ntok, insn);
d2813 14
a2826 5
  const struct alpha_opcode *opcode;
  const struct alpha_macro *macro;
  int cpumatch = 1;

  /* search macros */
d2843 1
a2843 12
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, opname);
      ntok--;
    }
#endif

  /* search opcodes */
d2852 6
a2857 1
	  assemble_insn (opcode, tok, ntok, &insn);
d2864 7
a2870 5
    if (cpumatch)
      as_bad (_("inappropriate arguments for opcode `%s'"), opname);
    else
      as_bad (_("opcode `%s' not supported for target %s"), opname,
	      alpha_target_name);
d2875 1
a2875 1
/* Some instruction sets indexed by lg(size) */
a2883 1
static const char * const ldX_op[] = { "ldb", "ldw", "ldll", "ldq" };
a2903 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, "ldgp");
      ntok--;
    }
#endif

d2927 1
d2942 1
d3022 3
a3024 2
   Finally, the return value is true if the calling macro may emit a
   LITUSE reloc if otherwise appropriate.  */
d3026 2
a3027 2
static int
load_expression (targreg, exp, pbasereg, poffset, explicit_reloc)
a3031 1
     const expressionS *explicit_reloc;
d3033 1
a3033 1
  int emit_lituse = 0;
d3046 1
a3046 1
	/* attempt to reduce .lit load by splitting the offset from
a3082 1
	assert (explicit_reloc == (const expressionS *) 0);
d3085 1
d3122 2
a3123 12
	if (!explicit_reloc)
	  insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
	else
	  {
#ifdef RELOC_OP_P
	    insn.fixups[0].reloc
	      = (ALPHA_RELOC_TABLE (explicit_reloc->X_op))->reloc;
	    insn.sequence[0] = explicit_reloc->X_add_number;
#else
	    abort ();
#endif
	  }
a3129 1
	assert (explicit_reloc == (const expressionS *) 0);
a3170 2
	emit_lituse = 1;

a3185 1
      assert (explicit_reloc == (const expressionS *) 0);
a3191 1
      assert (explicit_reloc == (const expressionS *) 0);
d3218 1
d3220 1
a3220 1
      /* for 64-bit addends, just put it in the literal pool */
d3280 1
d3292 2
a3293 5
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof (struct alpha_fixup) * insn.nfixups);
	}
d3295 1
a3295 4
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_BASE;
d3375 1
a3375 1
emit_lda (tok, ntok, opname)
d3378 1
a3378 1
     const PTR opname;
a3380 47
  const expressionS *reloc = (const expressionS *) 0;

#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const struct alpha_reloc_op_tag *r;

      reloc = &tok[ntok - 1];
      r = ALPHA_RELOC_TABLE (reloc->X_op);
      switch (reloc->X_op)
	{
	default:
	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc->X_add_number, (const char *) opname);

	  reloc = (const expressionS *) 0;
	  ntok--;
	  break;

	case O_literal:
	  ntok--;
	  break;

	  /* For lda $x,0($x)!lituse_base!y, don't use load_expression, since
	     it is really too general for our needs.  Instead just generate the
	     lda directly.  */
	case O_lituse_base:
	  if (ntok != 4
	      || tok[0].X_op != O_register
	      || !is_ir_num (tok[0].X_add_number)
	      || tok[1].X_op != O_constant
	      || tok[2].X_op != O_pregister
	      || !is_ir_num (tok[2].X_add_number))
	    {
	      as_bad (_("bad instruction format for lda !%s!%ld"), r->name,
		      (long) reloc->X_add_number);

	      reloc = (const expressionS *) 0;
	      ntok--;
	      break;
	    }

	  emit_loadstore (tok, ntok, "lda");
	  return;
	}
    }
#endif
d3387 1
a3387 1
  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL, reloc);
a3400 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, "ldah");
      ntok--;
    }
#endif

d3418 2
a3419 1
  int basereg, lituse;
a3422 31
#ifdef RELOC_OP_P
  const expressionS *reloc = (const expressionS *) 0;

  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const struct alpha_reloc_op_tag *r;

      reloc = &tok[ntok - 1];
      switch (reloc->X_op)
	{
	case O_lituse_base:
	  ntok--;
	  break;

	case O_literal:
	  if (strcmp ((const char *) opname, "ldq") == 0)
	    {
	      emit_lda (tok, ntok, opname);
	      return;
	    }

	  /* fall through */
	default:
	  ntok--;
	  r = ALPHA_RELOC_TABLE (reloc->X_op);
	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc->X_add_number, (const char *) opname);
	}
    }
#endif

d3429 1
a3429 1
			    &newtok[1], (const expressionS *) 0);
a3435 16
#ifdef RELOC_OP_P
  if (reloc)
    {
      int nfixups = insn.nfixups;
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc->X_op);

      assert (nfixups < MAX_INSN_FIXUPS);
      insn.fixups[nfixups].reloc = r->reloc;
      insn.fixups[nfixups].exp.X_op = O_symbol;
      insn.fixups[nfixups].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[nfixups].exp.X_add_number = r->lituse;
      insn.sequence[nfixups] = reloc->X_add_number;
      insn.nfixups++;
    }
#endif

d3439 2
a3440 5
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof (struct alpha_fixup) * insn.nfixups);
	}
d3442 1
a3442 4
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_BASE;
d3457 2
a3458 1
  int basereg, lituse;
a3461 15
#ifdef RELOC_OP_P
  const expressionS *reloc = (const expressionS *) 0;

  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      reloc = &tok[--ntok];
      if (reloc->X_op != O_lituse_base)
	{
	  const struct alpha_reloc_op_tag *r = &alpha_reloc_op[reloc->X_md];
	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc->X_add_number, (const char *) opname);
	}
    }
#endif

d3472 1
a3472 2
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1],
				(const expressionS *) 0);
a3484 16
#ifdef RELOC_OP_P
  if (reloc)
    {
      int nfixups = insn.nfixups;
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc->X_op);

      assert (nfixups < MAX_INSN_FIXUPS);
      insn.fixups[nfixups].reloc = r->reloc;
      insn.fixups[nfixups].exp.X_op = O_symbol;
      insn.fixups[nfixups].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[nfixups].exp.X_add_number = r->lituse;
      insn.sequence[nfixups] = reloc->X_add_number;
      insn.nfixups++;
    }
#endif

d3488 2
a3489 5
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof (struct alpha_fixup) * insn.nfixups);
	}
d3491 1
a3491 4
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_BASE;
d3510 3
a3512 13

#ifdef RELOC_OP_P
      if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
	{
	  const expressionS *reloc_exp = &tok[ntok - 1];
	  const struct alpha_reloc_op_tag *r
	    = ALPHA_RELOC_TABLE (reloc_exp->X_op);

	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc_exp->X_add_number, "ldbu/ldwu");
	  ntok--;
	}
#endif
d3517 6
d3525 1
a3525 3
      memcpy (newtok, tok, sizeof (expressionS) * ntok);
      newtok[0].X_add_number = AXP_REG_AT;
      assemble_tokens ("lda", newtok, ntok, 1);
d3531 13
a3543 2
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens ("ldq_u", newtok, 3, 1);
d3547 1
a3547 1
      set_tok_reg (newtok[1], AXP_REG_AT);
d3549 12
a3560 1
      assemble_tokens (extXl_op[(long) vlgsize], newtok, 3, 1);
a3654 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, "ldil");
      ntok--;
    }
#endif

d3676 3
d3683 6
d3691 1
a3691 3
      memcpy (newtok, tok, sizeof (expressionS) * ntok);
      newtok[0].X_add_number = AXP_REG_AT;
      assemble_tokens ("lda", newtok, ntok, 1);
d3697 13
a3709 2
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens ("ldq_u", newtok, 3, 1);
d3714 1
a3714 1
      set_tok_reg (newtok[1], AXP_REG_AT);
d3716 12
a3727 1
      assemble_tokens (insXl_op[lgsize], newtok, 3, 1);
d3733 12
a3744 1
      assemble_tokens (mskXl_op[lgsize], newtok, 3, 1);
d3753 1
a3753 1
      set_tok_const (newtok[1], 0);
d3755 12
a3766 1
      assemble_tokens ("stq_u", newtok, 3, 1);
a3869 13
#ifdef RELOC_OP_P
      if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
	{
	  const expressionS *reloc_exp = &tok[ntok - 1];
	  const struct alpha_reloc_op_tag *r
	    = ALPHA_RELOC_TABLE (reloc_exp->X_op);

	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int) reloc_exp->X_add_number, "setxt");
	  ntok--;
	}
#endif

d3898 12
a3909 13
   *
   * Convert
   *    OP x,y,result
   * to
   *    mov x,R16	# if x != R16
   *    mov y,R17	# if y != R17
   *    lda AT,__OP
   *    jsr AT,(AT),0
   *    mov R0,result
   *
   * with appropriate optimizations if R0,R16,R17 are the registers
   * specified by the compiler.
   */
a3914 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, (char char *) symname);
      ntok--;
    }
#endif

d3923 1
a3923 1
  /* Move the operands into the right place */
d3926 1
a3926 1
      /* They are in exactly the wrong order -- swap through AT */
d3973 1
a3973 1
  /* Call the division routine */
d3979 1
a3979 1
  /* Move the result to the right place */
d3997 11
a4007 12
   * Convert
   *    OP x,y,result
   * to
   *    lda pv,__OP
   *    mov x,t10
   *    mov y,t11
   *    jsr t9,(pv),__OP
   *    mov t12,result
   *
   * with appropriate optimizations if t10,t11,t12 are the registers
   * specified by the compiler.
   */
a4012 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, (const char *) symname);
      ntok--;
    }
#endif

d4023 1
a4023 1
  /* Move the operands into the right place */
d4026 1
a4026 2
      /* They are in exactly the wrong order -- swap through AT */

d4066 1
a4066 1
  /* Call the division routine */
d4071 1
a4071 1
  /* Reload the GP register */
d4082 1
a4082 1
  /* Move the result to the right place */
d4106 2
a4107 12
  int r, tokidx = 0, lituse = 0;

#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, opname);
      ntok--;
    }
#endif
d4125 1
a4125 2
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL,
				(const expressionS *) 0);
a4141 1
  /* add the LITUSE fixup */
d4145 2
a4146 5
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof (struct alpha_fixup) * insn.nfixups);
	}
d4148 1
a4148 4
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_JSR;
a4166 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok - 1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int) reloc_exp->X_add_number, opname);
      ntok--;
    }
#endif

d4190 1
a4190 1
/* Assembler directives */
d4200 3
d4204 1
d4217 3
d4221 1
d4234 1
a4234 1
     int ignore;
d4350 1
a4350 1
     int ignore;
d4371 1
a4371 1
     int ignore;
d4391 1
a4391 1
     int ignore;
d4437 1
a4437 1
	  if (isdigit (*input_line_pointer) || *input_line_pointer == '-')
d4528 6
a4533 1
  know (sym != NULL);
d4678 1
a4678 1
     int ignore;
d4715 1
a4715 1
     int ignore;
d4749 1
a4749 1
     int ignore;
d4902 1
a4902 1
     int ignore;
d4940 1
a4940 1
     int ignore;
d4968 1
a4968 1
     int ignore;
d4996 1
a4996 1
     int ignore;
d5007 1
a5007 1
     int ignore;
d5028 1
a5028 1
     int ignore;
d5049 1
a5049 1
     int ignore;
d5063 1
a5063 1
     int ignore;
d5583 1
d5628 28
d5702 1
a5702 1
  static char const unop[4] = { 0x00, 0x00, 0xe0, 0x2f };
d5705 1
a5705 1
    0x00, 0x00, 0xe0, 0x2f
@


1.7
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright (C) 1989, 93-98, 1999 Free Software Foundation, Inc.
d62 1
a65 1

d75 1
a75 2
struct alpha_fixup
{
d80 1
a80 2
struct alpha_insn
{
d87 1
a87 2
enum alpha_macro_arg
{
d101 1
a101 2
struct alpha_macro
{
d108 1
a108 1
/* Extra expression types. */
a126 1

d144 1
a144 1
	(((offsetT)(x) >> 15) == 0 || ((offsetT)(x) >> 15) == -1)
d146 1
a146 1
	(((offsetT)(x) >> 31) == 0 || ((offsetT)(x) >> 31) == -1)
d148 4
a151 4
#define range_signed_16(x)	((offsetT)(x) >= -(offsetT)0x8000 &&	\
				 (offsetT)(x) <=  (offsetT)0x7FFF)
#define range_signed_32(x)	((offsetT)(x) >= -(offsetT)0x80000000 && \
				 (offsetT)(x) <=  (offsetT)0x7FFFFFFF)
d159 2
a160 2
#define sign_extend_16(x)	((short)(x))
#define sign_extend_32(x)	((int)(x))
d162 2
a163 2
#define sign_extend_16(x)	((offsetT)(((x) & 0xFFFF) ^ 0x8000) - 0x8000)
#define sign_extend_32(x)	((offsetT)(((x) & 0xFFFFFFFF) \
d169 1
a169 1
#define set_tok_reg(t, r)	(memset(&(t), 0, sizeof(t)),		\
d172 1
a172 1
#define set_tok_preg(t, r)	(memset(&(t), 0, sizeof(t)),		\
d175 1
a175 1
#define set_tok_cpreg(t, r)	(memset(&(t), 0, sizeof(t)),		\
d178 1
a178 1
#define set_tok_freg(t, r)	(memset(&(t), 0, sizeof(t)),		\
d180 2
a181 2
				 (t).X_add_number = (r)+32)
#define set_tok_sym(t, s, a)	(memset(&(t), 0, sizeof(t)),		\
d185 1
a185 1
#define set_tok_const(t, n)	(memset(&(t), 0, sizeof(t)),		\
a187 1

d244 3
a269 1

d306 1
a306 1
#define OPTION_RELAX (OPTION_32ADDR+1)
d309 2
a310 2
#define OPTION_MDEBUG (OPTION_RELAX+1)
#define OPTION_NO_MDEBUG (OPTION_MDEBUG+1)
d317 1
a317 2
size_t md_longopts_size = sizeof(md_longopts);

d375 1
a375 1
/* Symbols referring to said sections. */
d393 1
a394 1
#ifdef OBJ_ELF
d432 1
a432 1
int alpha_flag_mdebug = 1;
d474 1
a474 1
		  : (int)(op) - (int)O_literal) ]
d546 1
a546 1
  = sizeof(alpha_reloc_op) / sizeof(*alpha_reloc_op);
d552 1
a552 1
#define ALPHA_RELOC_SEQUENCE_OK(X) ((X) > 0 && ((unsigned)(X)) == (X))
d572 1
a572 2
static const struct cpu_type
{
d575 1
a575 2
} cpu_types[] =
{
d577 1
a577 1
     This supports usage under DU 4.0b that does ".arch ev4", and 
d632 1
a632 1
  { "ldb",	emit_ldX, (PTR)0,
d634 1
a634 1
  { "ldbu",	emit_ldXu, (PTR)0,
d636 1
a636 1
  { "ldw",	emit_ldX, (PTR)1,
d638 1
a638 1
  { "ldwu",	emit_ldXu, (PTR)1,
d641 1
a641 1
  { "uldw",	emit_uldX, (PTR)1,
d643 1
a643 1
  { "uldwu",	emit_uldXu, (PTR)1,
d645 1
a645 1
  { "uldl",	emit_uldX, (PTR)2,
d647 1
a647 1
  { "uldlu",	emit_uldXu, (PTR)2,
d649 1
a649 1
  { "uldq",	emit_uldXu, (PTR)3,
d693 1
a693 1
  { "stb",	emit_stX, (PTR)0,
d695 1
a695 1
  { "stw",	emit_stX, (PTR)1,
d697 1
a697 1
  { "ustw",	emit_ustX, (PTR)1,
d699 1
a699 1
  { "ustl",	emit_ustX, (PTR)2,
d701 1
a701 1
  { "ustq",	emit_ustX, (PTR)3,
d714 1
a714 1
  { "sextb",	emit_sextX, (PTR)0,
d718 1
a718 1
  { "sextw",	emit_sextX, (PTR)1,
d798 1
a798 1
  = sizeof(alpha_macros) / sizeof(*alpha_macros);
d821 1
a821 1
  for (i = 0; i < alpha_num_opcodes; )
d826 1
a826 1
      retval = hash_insert (alpha_opcode_hash, name, (PTR)&alpha_opcodes[i]);
d841 1
a841 1
	  (void)hash_insert(alpha_opcode_hash, p, (PTR)&alpha_opcodes[i]);
d855 1
a855 1
  for (i = 0; i < alpha_num_macros; )
d860 1
a860 1
      retval = hash_insert (alpha_macro_hash, name, (PTR)&alpha_macros[i]);
d862 2
a863 1
	as_fatal (_("internal error: can't hash macro `%s': %s"), name, retval);
d876 3
a878 3
      sprintf(name, "$%d", i);
      alpha_register_table[i] = symbol_create(name, reg_section, i,
					      &zero_address_frag);
d883 3
a885 3
      sprintf(name, "$f%d", i-32);
      alpha_register_table[i] = symbol_create(name, reg_section, i,
					      &zero_address_frag);
d909 3
a911 3
      segT sec = subseg_new(".mdebug", (subsegT)0);
      bfd_set_section_flags(stdoutput, sec, SEC_HAS_CONTENTS|SEC_READONLY);
      bfd_set_section_alignment(stdoutput, sec, 3);
d915 1
a915 1
  subseg_set(text_section, 0);
d919 1
a919 1
  alpha_literal_hash = hash_new();
d962 2
a963 2
  int align = bfd_get_section_alignment(stdoutput, seg);
  valueT mask = ((valueT)1 << align) - 1;
d969 2
a970 2
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP.  An error message is
d1058 1
a1058 1
      g_switch_value = atoi(arg);
d1065 1
a1065 1
	  if (strcmp(arg, p->name) == 0)
d1070 1
a1070 1
	as_warn(_("Unknown CPU identifier `%s'"), arg);
d1076 1
a1076 1
    case '+':			/* For g++.  Hash any name > 63 chars long. */
d1114 1
a1114 1
  fputs(_("\
d1241 1
a1241 1
	  image = bfd_getl32(fixpos);
d1250 1
a1250 1
	  image = bfd_getl32(fixpos);
d1288 4
d1296 1
a1296 1
	if ((int)fixP->fx_r_type >= 0)
d1300 2
a1301 2
	assert (-(int)fixP->fx_r_type < (int)alpha_num_operands);
	operand = &alpha_operands[-(int)fixP->fx_r_type];
d1312 3
a1314 3
	image = bfd_getl32(fixpos);
	image = insert_operand(image, operand, (offsetT)value,
			       fixP->fx_file, fixP->fx_line);
d1323 2
a1324 2
      as_warn_where(fixP->fx_file, fixP->fx_line,
		    _("type %d reloc done?\n"), (int)fixP->fx_r_type);
d1329 1
a1329 1
  md_number_to_chars(fixpos, image, 4);
d1341 1
a1341 1
md_undefined_symbol(name)
d1357 1
a1357 1
	  if (!isdigit(*++name))
d1365 1
a1365 1
	  else if (name[0] != '0' && isdigit(name[1]) && name[2] == '\0')
d1375 1
a1375 1
	    as_warn(_("Used $at without \".set noat\""));
d1382 1
a1382 1
		as_warn(_("Used $at without \".set noat\""));
d1461 2
d1472 2
a1473 1
      assert((int)f->fx_r_type < 0 && -(int)f->fx_r_type < (int)alpha_num_operands);
d1523 2
d1535 2
a1536 2
      assert ((int)f->fx_r_type < 0
	      && - (int)f->fx_r_type < (int)alpha_num_operands);
d1559 1
a1559 1
  assert ((int)fixp->fx_r_type > 0);
d1595 1
a1595 1
	  && !S_IS_COMMON(fixp->fx_addsy))
d1622 1
a1622 1
      *strchr(s, '\0') = c;
d1654 4
a1657 4
/* Before the relocations are written, reorder them, so that user supplied
   !lituse relocations follow the appropriate !literal relocations.  Also
   convert the gas-internal relocations to the appropriate linker relocations.
   */
d1668 5
a1672 3
      /* Go over each section, reordering the relocations so that all of the
         explicit LITUSE's are adjacent to the explicit LITERAL's */
      bfd_map_over_sections (stdoutput, alpha_adjust_symtab_relocs, (char *) 0);
a1674 1

d1680 1
a1680 1
     bfd *abfd;
d1682 1
a1682 1
     PTR ptr;
d1697 3
a1699 2
  /* If seginfo is NULL, we did not create this section; don't do anything with
     it.  By using a pointer to a pointer, we can update the links in place.  */
d1712 1
a1712 1
      fixp->fx_next = (fixS *)0;
d1725 1
a1725 1
		   (long)fixp,
d1740 1
a1740 1
		   (long)fixp,
d1758 1
a1758 1
		   (long)fixp,
d1761 1
a1761 1
		   (long)fixp->tc_fix_data.next_lituse);
d1794 1
a1794 1
		       lituse != (fixS *)0;
a1821 1

d1890 1
a1890 1
	       (int)t->X_add_number);
d1968 1
a1968 1
	  for (i = alpha_num_reloc_op-1; i >= 0; i--, r++)
d1976 2
a1977 1
	      as_bad (_("Unknown relocation operand: !%s"), input_line_pointer);
d1990 2
a1991 1
	      as_bad (_("Bad sequence number: !%s!%s"), r->name, input_line_pointer);
d2012 1
a2012 1
	    /* First try for parenthesized register ... */
d2069 1
a2069 1
find_opcode_match(first_opcode, tok, pntok, pcpumatch)
d2111 1
a2111 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2116 1
a2116 1
		  || !is_fpr_num(tok[tokidx].X_add_number))
d2119 1
a2119 1
	    case AXP_OPERAND_IR|AXP_OPERAND_PARENS:
d2121 1
a2121 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2124 1
a2124 1
	    case AXP_OPERAND_IR|AXP_OPERAND_PARENS|AXP_OPERAND_COMMA:
d2126 1
a2126 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2149 1
a2149 1
	      abort();
d2163 2
a2164 2
  while (++opcode-alpha_opcodes < alpha_num_opcodes
	 && !strcmp(opcode->name, first_opcode->name));
d2167 1
a2167 1
      *pcpumatch = got_cpu_match;
d2176 1
a2176 1
find_macro_match(first_macro, tok, pntok)
d2203 1
a2203 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2211 1
a2211 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2219 1
a2219 1
		  && is_ir_num(tok[tokidx].X_add_number))
d2226 1
a2226 1
		  || !is_ir_num(tok[tokidx].X_add_number))
d2234 1
a2234 1
		  || !is_fpr_num(tok[tokidx].X_add_number))
d2308 2
a2309 2
  while (++macro-alpha_macros < alpha_num_macros
	 && !strcmp(macro->name, first_macro->name));
d2317 1
a2317 1
insert_operand(insn, operand, val, file, line)
d2345 1
a2345 1
	  sprint_value(buf, val);
d2347 1
a2347 1
	    as_warn_where(file, line, err, buf, min, max);
d2349 1
a2349 1
	    as_warn(err, buf, min, max);
d2373 1
a2373 1
assemble_insn(opcode, tok, ntok, insn)
d2389 1
a2389 1
      const expressionS *t = (const expressionS *)0;
d2394 1
a2394 1
	  image = insert_operand(image, operand, 0, NULL, 0);
d2417 1
a2417 1
	      abort();
d2428 2
a2429 2
	  image = insert_operand(image, operand, regno(t->X_add_number),
				 NULL, 0);
d2433 1
a2433 1
	  image = insert_operand(image, operand, t->X_add_number, NULL, 0);
d2441 1
a2441 1
	      as_fatal(_("too many fixups"));
d2461 1
a2461 1
    struct alpha_insn *insn;
d2466 1
a2466 1
  /* Take care of alignment duties */
d2477 4
d2484 1
a2484 1
      const struct alpha_operand *operand = (const struct alpha_operand *)0;
d2494 1
a2494 1
      if ((int)fixup->reloc < 0)
d2496 1
a2496 1
	  operand = &alpha_operands[-(int)fixup->reloc];
d2500 3
a2502 2
      else switch (fixup->reloc)
	{
d2504 6
a2509 6
	  /* These relocation types are only used internally. */
	case BFD_RELOC_ALPHA_GPDISP_HI16:
	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  size = 2;
	  pcrel = 0;
	  break;
d2512 11
a2522 11
	  /* and these also are internal only relocations */
	case BFD_RELOC_ALPHA_USER_LITERAL:
	case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	case BFD_RELOC_ALPHA_USER_GPDISP:
	case BFD_RELOC_ALPHA_USER_GPRELHIGH:
	case BFD_RELOC_ALPHA_USER_GPRELLOW:
	  size = 2;
	  pcrel = 0;
	  break;
d2525 5
a2529 5
	default:
	  {
	    reloc_howto_type *reloc_howto
	      = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	    assert (reloc_howto);
d2531 5
a2535 2
	    size = bfd_get_reloc_size (reloc_howto);
	    pcrel = reloc_howto->pc_relative;
a2536 3
	  assert (size >= 1 && size <= 4);
	  break;
	}
d2574 1
a2574 1
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR)info);
d2605 1
a2605 1
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR)info);
d2620 1
a2620 1
	  if ((int)fixup->reloc < 0)
d2637 1
a2637 1
assemble_tokens_to_insn(opname, tok, ntok, insn)
d2660 1
a2660 1
	        alpha_target_name);
d2699 1
a2699 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d2701 1
a2701 1
      const expressionS *reloc_exp = &tok[ntok-1];
d2704 1
a2704 1
	      (int)reloc_exp->X_add_number, opname);
a2732 1

d2765 1
a2765 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d2767 1
a2767 1
      const expressionS *reloc_exp = &tok[ntok-1];
d2770 1
a2770 1
	      (int)reloc_exp->X_add_number, "ldgp");
d2853 1
a2853 1
	        return offset;
d2952 1
a2952 1
	assert (explicit_reloc == (const expressionS *)0);
d2974 3
a2976 2
	if (1 || (!range_signed_32 (addend)
	    && (alpha_noat_on || targreg == AXP_REG_AT)))
d3009 1
a3009 1
	assert (explicit_reloc == (const expressionS *)0);
d3048 1
a3048 1
	emit_insn(&insn);
d3068 1
a3068 1
      assert (explicit_reloc == (const expressionS *)0);
d3073 1
a3073 1
	 absolute value and that that value will fit in 16 bits. */
d3075 1
a3075 1
      assert (explicit_reloc == (const expressionS *)0);
d3177 1
a3177 1
		   sizeof(struct alpha_fixup) * insn.nfixups);
d3269 1
a3269 1
  const expressionS *reloc = (const expressionS *)0;
d3272 1
a3272 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3276 1
a3276 1
      reloc = &tok[ntok-1];
d3282 1
a3282 1
		  (int)reloc->X_add_number, (const char *)opname);
d3284 1
a3284 1
	  reloc = (const expressionS *)0;
d3298 1
a3298 1
	      || !is_ir_num(tok[0].X_add_number)
d3301 1
a3301 1
	      || !is_ir_num(tok[2].X_add_number))
d3303 2
a3304 2
	      as_bad (_("bad instruction format for lda !%s!%d"), r->name,
		      reloc->X_add_number);
d3306 1
a3306 1
	      reloc = (const expressionS *)0;
d3337 1
a3337 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3339 1
a3339 1
      const expressionS *reloc_exp = &tok[ntok-1];
d3342 1
a3342 1
	      (int)reloc_exp->X_add_number, "ldah");
d3369 1
a3369 1
  const expressionS *reloc = (const expressionS *)0;
d3371 1
a3371 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3375 1
a3375 1
      reloc = &tok[ntok-1];
d3383 1
a3383 1
	  if (strcmp ((const char *)opname, "ldq") == 0)
d3394 1
a3394 1
		  (int)reloc->X_add_number, (const char *)opname);
d3405 1
a3405 1
			    &newtok[1], (const expressionS *)0);
d3410 1
a3410 1
  assemble_tokens_to_insn ((const char *)opname, newtok, 3, &insn);
d3434 1
a3434 1
		   sizeof(struct alpha_fixup) * insn.nfixups);
d3460 1
a3460 1
  const expressionS *reloc = (const expressionS *)0;
d3462 1
a3462 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3467 1
a3467 1
	  const struct alpha_reloc_op_tag *r = &alpha_reloc_op[ reloc->X_md ];
d3469 1
a3469 1
		  (int)reloc->X_add_number, (const char *)opname);
d3479 1
a3479 1
  if (tok[1].X_op != O_constant || !range_signed_16(tok[1].X_add_number))
d3485 1
a3485 1
				(const expressionS *)0);
d3496 1
a3496 1
  assemble_tokens_to_insn ((const char *)opname, newtok, 3, &insn);
d3520 1
a3520 1
		   sizeof(struct alpha_fixup) * insn.nfixups);
d3541 1
a3541 1
    emit_ir_load (tok, ntok, ldXu_op[(long)vlgsize]);
d3547 1
a3547 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3549 1
a3549 1
	  const expressionS *reloc_exp = &tok[ntok-1];
d3554 1
a3554 1
		  (int)reloc_exp->X_add_number, "ldbu/ldwu");
d3579 1
a3579 1
      assemble_tokens (extXl_op[(long)vlgsize], newtok, 3, 1);
d3592 1
a3592 1
  assemble_tokens (sextX_op[(long)vlgsize], tok, 1, 1);
d3604 1
a3604 1
  long lgsize = (long)vlgsize;
d3626 1
a3626 1
  set_tok_const (newtok[1], (1<<lgsize)-1);
d3661 1
a3661 1
  assemble_tokens (sextX_op[(long)vlgsize], tok, 1, 1);
d3675 1
a3675 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3677 1
a3677 1
      const expressionS *reloc_exp = &tok[ntok-1];
d3680 1
a3680 1
	      (int)reloc_exp->X_add_number, "ldil");
d3685 1
a3685 1
  memcpy (newtok, tok, sizeof(newtok));
d3699 1
a3699 1
  int lgsize = (int)(long)vlgsize;
d3708 1
a3708 1
	as_bad(_("macro requires $at register while noat in effect"));
d3757 1
a3757 1
  int lgsize = (int)(long)vlgsize;
d3776 1
a3776 1
  set_tok_const (newtok[1], (1 << lgsize)-1);
d3827 1
a3827 1
  set_tok_const (newtok[1], (1 << lgsize)-1);
d3840 1
a3840 1
  long lgsize = (long)vlgsize;
d3850 1
a3850 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3852 1
a3852 1
	  const expressionS *reloc_exp = &tok[ntok-1];
d3857 1
a3857 1
		  (int)reloc_exp->X_add_number, "setxt");
d3909 1
a3909 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d3911 1
a3911 1
      const expressionS *reloc_exp = &tok[ntok-1];
d3914 1
a3914 1
	      (int)reloc_exp->X_add_number, (char char *)symname);
d3960 1
a3960 1
          assemble_tokens ("mov", newtok, 2, 1);
d3971 1
a3971 1
  sym = symbol_find_or_make ((const char *)symname);
d4019 1
a4019 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d4021 1
a4021 1
      const expressionS *reloc_exp = &tok[ntok-1];
d4024 1
a4024 1
	      (int)reloc_exp->X_add_number, (const char *)symname);
d4037 1
a4037 1
  sym = symbol_find_or_make ((const char *)symname);
d4072 1
a4072 1
          assemble_tokens ("mov", newtok, 2, 1);
d4126 1
a4126 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d4128 1
a4128 1
      const expressionS *reloc_exp = &tok[ntok-1];
d4131 1
a4131 1
	      (int)reloc_exp->X_add_number, opname);
d4153 1
a4153 1
				(const expressionS *)0);
d4177 1
a4177 1
		   sizeof(struct alpha_fixup) * insn.nfixups);
d4198 1
a4198 1
  const char *opname = (const char *)vopname;
d4203 1
a4203 1
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
d4205 1
a4205 1
      const expressionS *reloc_exp = &tok[ntok-1];
d4208 1
a4208 1
	      (int)reloc_exp->X_add_number, opname);
d4231 1
a4231 1
    set_tok_const (newtok[2], strcmp(opname, "ret") == 0);
d4324 1
a4324 1
      input_line_pointer++;      
d4339 1
a4339 1
    { 
d4358 1
a4358 1
#ifdef OBJ_EVAX 
d4514 1
a4514 1
	        = symbol_new ("L0\001", now_seg, frag_now_fix (), frag_now);
d4534 1
a4534 1
        ecoff_directive_fmask (0);
d4536 1
a4536 1
        ecoff_directive_mask (0);
d4570 81
a4650 13
      case 0: /* No PV required.  */
	S_SET_OTHER (sym, STO_ALPHA_NOPV);
	break;
      case 1: /* Std GP load.  */
	S_SET_OTHER (sym, STO_ALPHA_STD_GPLOAD);
	break;
      case 2: /* Non-std use of PV.  */
	break;

      default:
	as_bad (_("Invalid argument %d to .prologue."), arg);
	break;
    }  
a4662 1
    ecoff_directive_file,
a4665 1
    ecoff_directive_loc,
d4668 1
a4668 1
  assert (which >= 0 && which < (int)(sizeof(fns)/sizeof(*fns)));
d4671 1
a4671 1
    (*fns[which])(0);
d4681 1
a4681 1
  
d4683 1
a4683 1
  
d4690 1
a4690 1
  static char *section_name[EVAX_SECTION_COUNT+1] =
a4706 1

a4743 1

d4836 1
a4836 1
  if (strncmp(name, "stack", 5) == 0)
d4840 1
a4840 1
  else if (strncmp(name, "reg", 3) == 0)
d4844 1
a4844 1
  else if (strncmp(name, "null", 4) == 0)
d4869 2
a4870 3
       | ((alpha_evax_proc.framereg == 29) ? PDSC_S_M_BASE_REG_IS_FP : 0);
  *(p+1) = PDSC_S_M_NATIVE
	   | PDSC_S_M_NO_JACKET;
d4874 13
a4886 13
      case PDSC_S_K_KIND_NULL:
	*(p+2) = 0;
	*(p+3) = 0;
	break;
      case PDSC_S_K_KIND_FP_REGISTER:
	*(p+2) = alpha_evax_proc.fp_save;
	*(p+3) = alpha_evax_proc.ra_save;
	break;
      case PDSC_S_K_KIND_FP_STACK:
	md_number_to_chars (p+2, (valueT)alpha_evax_proc.rsa_offset, 2);
	break;
      default:		/* impossible */
	break;
d4889 2
a4890 2
  *(p+4) = 0;
  *(p+5) = alpha_evax_proc.type & 0x0f;
d4893 1
a4893 1
  md_number_to_chars (p+6, (valueT)0, 2);
d4895 1
a4895 1
  fix_new_exp (frag_now, p-frag_now->fr_literal+8, 8, &exp, 0, BFD_RELOC_64);
d4907 1
a4907 1
  md_number_to_chars (p, (valueT)alpha_evax_proc.framesize, 4);
d4909 1
a4909 1
  md_number_to_chars (p+4, (valueT)0, 2);
d4912 1
a4912 1
  md_number_to_chars (p+6, alpha_evax_proc.prologue, 2);
d4926 1
a4926 1
  md_number_to_chars (p+4, alpha_evax_proc.fmask, 4);
a4930 1

d4966 1
a4966 1
  fix_new_exp (frag_now, p-frag_now->fr_literal, 8, &exp, 0, BFD_RELOC_64);
a4970 1

a4998 1

a5026 1

a5037 1

d5052 1
a5052 1
      (void)get_absolute_expression ();
a5058 1

a5093 1

d5135 1
a5135 1
      e.X_add_symbol = section_symbol(absolute_section);
d5141 1
a5141 1
      abort();
d5168 1
a5168 1
  fix_new_exp (frag_now, p-frag_now->fr_literal, 4,
d5437 1
a5437 1
    if (strcmp(name, p->name) == 0)
d5439 1
a5439 1
        alpha_target_name = p->name, alpha_target = p->flags;
d5442 1
a5442 1
  as_warn("Unknown CPU identifier `%s'", name);
a5447 1

a5448 1

d5453 3
a5455 3
alpha_print_token(f, exp)
    FILE *f;
    const expressionS *exp;
d5459 15
a5473 15
      case O_cpregister:
	putc (',', f);
	/* FALLTHRU */
      case O_pregister:
	putc ('(', f);
	{
	  expressionS nexp = *exp;
	  nexp.X_op = O_register;
	  print_expr (f, &nexp);
	}
	putc (')', f);
	break;
      default:
	print_expr (f, exp);
	break;
d5481 1
a5481 2
const pseudo_typeS md_pseudo_table[] =
{
d5523 4
d5533 3
a5535 5
  {"file", s_alpha_coff_wrapper, 5},
  {"scl", s_alpha_coff_wrapper, 6},
  {"tag", s_alpha_coff_wrapper, 7},
  {"val", s_alpha_coff_wrapper, 8},
  {"loc", s_alpha_coff_wrapper, 9},
a5587 1

d5635 2
a5636 1
  alpha_gp_value = 0; alpha_gp_value--;
d5677 2
a5678 21
      if (n > 2
	  && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
	{
	  static char const unop[4] = { 0x00, 0x00, 0xe0, 0x2f };
	  static char const nopunop[8] = {
		0x1f, 0x04, 0xff, 0x47,
		0x00, 0x00, 0xe0, 0x2f
	  };

	  /* First, make sure we're on a four-byte boundary, in case
	     someone has been putting .byte values into the text
	     section.  The DEC assembler silently fills with unaligned
	     no-op instructions.  This will zero-fill, then nop-fill
	     with proper alignment.  */
	  if (alpha_current_align < 2)
	    frag_align (2, 0, 0);
	  if (alpha_current_align < 3)
	    frag_align_pattern (3, unop, sizeof unop, 0);
	  if (n > 3)
	    frag_align_pattern (n, nopunop, sizeof nopunop, 0);
	}
d5695 1
a5695 1
  /* ??? if alpha_flag_relax && force && elf, record the requested alignment
d5697 45
@


1.6
log
@More format string paranoia; deraadt@@ ok
@
text
@d1375 1
a1375 1
	  if (!alpha_noat_on && num == AXP_REG_AT)
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2352 1
a2352 1
	as_warn (errmsg);
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright (C) 1989, 93, 94, 95, 1996 Free Software Foundation, Inc.
d7 1
a7 1
   Modified by Klaus Kaempf for EVAX (openVMS/Alpha) support.
d54 2
d68 3
d85 1
d90 11
a100 1
  MACRO_EOA = 1, MACRO_IR, MACRO_PIR, MACRO_CPIR, MACRO_FPR, MACRO_EXP
d111 18
a128 2
/* Two extra symbols we want to see in our input.  This is a blatent
   misuse of the expressionS.X_op field.  */
a129 2
#define O_pregister	(O_max+1)	/* O_register, but in parentheses */
#define O_cpregister	(O_pregister+1)	/* + a leading comma */
d143 2
d146 6
d156 1
d213 2
a214 1
  PARAMS ((int, const expressionS *, int *, expressionS *));
a236 2
#endif
#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)
d244 9
d267 5
a271 1
static void alpha_align PARAMS ((int, char *, symbolS *));
a276 5
/* These are exported to relaxing code, even though we don't do any
   relaxing on this processor currently.  */
int md_short_jump_size = 4;
int md_long_jump_size = 4;

d301 1
a301 1
const char *md_shortopts = "Fm:g+1h:H";
d303 1
a303 1
const char *md_shortopts = "Fm:g";
d309 8
d374 2
d386 2
d397 5
d431 14
a462 1
static int alpha_flag_no_hash_mixed_case = 0;		/* -h NUM */
d464 90
a553 7
/* Flag that determines how we map names.  This takes several values, and
 * is set with the -h switch.  A value of zero implies names should be
 * upper case, and the presence of the -h switch inhibits the case hack.
 * No -h switch at all sets alpha_vms_name_mapping to 0, and allows case hacking.
 * A value of 2 (set with -h2) implies names should be
 * all lower case, with no case hack.  A value of 3 (set with -h3) implies
 * that case should be preserved.  */
d555 2
a556 3
/* If the -+ switch is given, then the hash is appended to any name that is
 * longer than 31 characters, regardless of the setting of the -h switch.
 */
d558 11
a568 1
static char alpha_vms_name_mapping = 0;
d570 2
a571 1
static int alpha_basereg_clobbered;
d574 36
d615 1
a615 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d620 1
a620 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d622 1
a622 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d624 1
a624 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d626 1
a626 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d628 1
a628 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d630 1
a630 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d632 1
a632 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d634 1
a634 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d636 1
a636 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d639 1
a639 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d641 1
a641 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d643 1
a643 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d645 1
a645 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d648 1
a648 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d650 1
a650 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d652 1
a652 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d654 1
a654 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d656 1
a656 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d681 1
a681 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d683 1
a683 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d685 1
a685 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d687 1
a687 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d689 1
a689 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d691 1
a691 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d693 1
a693 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d695 1
a695 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d697 1
a697 2
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
d700 1
a700 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d702 1
a702 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d704 1
a704 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d706 1
a706 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d708 1
a708 2
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
d771 4
a774 4
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
d776 4
a779 4
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
d803 1
a803 1
static const int alpha_num_macros
d815 8
a822 1
  unsigned int i = 0;
d829 1
a829 1
      const char *name, *retval;
d834 1
a834 1
	as_fatal ("internal error: can't hash opcode `%s': %s", name, retval);
d836 4
a839 5
      while (++i < alpha_num_opcodes
	     && (alpha_opcodes[i].name == name
		 || !strcmp (alpha_opcodes[i].name, name)))
	continue;
    }
d841 1
a841 8
  /* Some opcodes include modifiers of various sorts with a "/mod" syntax,
     like the architecture manual suggests.  However, for use with gcc at
     least, we also need access to those same opcodes without the "/".  */
  for (i = 0; i < alpha_num_opcodes; )
    {
      const char *name, *slash;
      name = alpha_opcodes[i].name;
      if ((slash = strchr(name, '/')) != NULL)
d844 2
a845 2
	  memcpy(p, name, slash-name);
	  strcpy(p+(slash-name), slash+1);
d868 1
a868 1
	as_fatal ("internal error: can't hash macro `%s': %s", name, retval);
d896 1
a896 1
  bfd_set_gp_size (stdoutput, 8);
d914 1
a914 3
      segT sec;

      sec = subseg_new(".mdebug", (subsegT)0);
a916 9

#ifdef ERIC_neverdef
      sec = subseg_new(".reginfo", (subsegT)0);
      /* The ABI says this section should be loaded so that the running
	 program can access it.  */
      bfd_set_section_flags(stdoutput, sec,
			    SEC_ALLOC|SEC_LOAD|SEC_READONLY|SEC_DATA);
      bfd_set_section_alignement(stdoutput, sec, 3);
#endif
d921 5
d936 2
a937 1
  int ntok, opnamelen, trunclen;
d940 1
a940 1
  opnamelen = strspn (str, "abcdefghijklmnopqrstuvwxyz_/48");
d950 3
a952 1
      as_bad ("syntax error");
d981 2
a992 1
  char *atof_ieee (), *vax_md_atof ();
d1025 1
a1025 1
      return "Bad call to MD_ATOF()";
d1059 5
a1063 3
      /* Ignore `-g' so gcc can provide this option to the Digital
	 UNIX assembler, which otherwise would throw away info that
	 mips-tfile needs.  */
d1068 2
a1069 35
	static const struct machine
	{
	  const char *name;
	  unsigned flags;
	} *p, m[] =
	{
	  { "21064", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "21064a", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "21066", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "21068", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "21164", AXP_OPCODE_BASE|AXP_OPCODE_EV5 },
	  /* Do we have CIX extension here? */
	  { "21164a", AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX },
	  /* Still same PALcodes? */
	  { "21164pc", (AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX
			|AXP_OPCODE_CIX|AXP_OPCODE_MAX) },
	  /* All new PALcodes?  Extras? */
	  { "21264", (AXP_OPCODE_BASE|AXP_OPCODE_BWX
		      |AXP_OPCODE_CIX|AXP_OPCODE_MAX) },

	  { "ev4", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "ev45", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "lca45", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "ev5", AXP_OPCODE_BASE|AXP_OPCODE_EV5 },
	  { "ev56", AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX },
	  { "pca56", (AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX
		      |AXP_OPCODE_CIX|AXP_OPCODE_MAX) },
	  { "ev6", (AXP_OPCODE_BASE|AXP_OPCODE_BWX
		    |AXP_OPCODE_CIX|AXP_OPCODE_MAX) },

	  { "all", AXP_OPCODE_BASE },
	  { 0 }
	};

	for (p = m; p->name; ++p)
d1075 1
a1075 1
	as_warn("Unknown CPU identifier `%s'", arg);
d1080 2
a1081 2
#if OBJ_EVAX
    case '+':			/* For g++.  Hash any name > 31 chars long. */
d1089 14
a1102 5
    case 'h':			/* No hashing of mixed-case names */
      {
	alpha_vms_name_mapping = atoi (arg);
	alpha_flag_no_hash_mixed_case = 1;
      }
d1119 1
a1119 1
  fputs("\
d1123 4
a1126 3
-m21064 | -m21066 | -m21164 | -m21164a\n\
-mev4 | -mev45 | -mev5 | -mev56 | -mall\n\
			specify variant of Alpha architecture\n",
d1129 1
a1129 1
  fputs ("\
d1131 2
a1132 4
-+			hash encode names longer than 31 characters\n\
-H			show new symbol after hash truncation\n\
-h NUM			don't hash mixed-case names, and adjust case:\n\
			0 = upper, 2 = lower, 3 = preserve case\n",
d1204 1
a1204 1
      fixP->fx_addsy = section_symbol (absolute_section);
d1209 2
d1214 2
d1219 2
d1276 9
d1286 5
d1297 2
a1298 2
	if ((int)fixP->fx_r_type <= 0)
	  as_fatal ("unhandled relocation type %s",
d1301 1
a1301 1
	assert (-(int)fixP->fx_r_type < alpha_num_operands);
d1309 1
a1309 1
	    && fixP->fx_addsy->bsym->section != absolute_section)
d1311 1
a1311 1
			"non-absolute expression in constant field");
d1325 1
a1325 1
		    "type %d reloc done?\n", fixP->fx_r_type);
d1376 1
a1376 1
	    as_warn("Used $at without \".set noat\"");
d1383 1
a1383 1
		as_warn("Used $at without \".set noat\"");
d1433 3
d1451 10
d1471 1
a1471 1
      assert((int)f->fx_r_type < 0 && -(int)f->fx_r_type < alpha_num_operands);
d1484 1
a1484 1
  if (S_IS_EXTERN (f->fx_addsy))
d1492 31
d1524 4
d1529 1
d1531 3
a1533 1
      return !alpha_force_relocation (f);
d1543 1
a1543 1
     asection *sec;
d1548 3
a1550 2
  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d1561 1
a1561 1
		    "cannot represent `%s' relocation in object file",
d1568 1
a1568 1
      as_fatal ("internal error? cannot generate `%s' relocation",
d1590 3
a1592 2
      if (S_IS_EXTERN (fixp->fx_addsy) && !S_IS_COMMON(fixp->fx_addsy))
	reloc->addend -= fixp->fx_addsy->bsym->value;
d1607 1
a1607 1
     int frame;
d1622 1
a1622 1
  as_warn ("frame reg expected, using $%d.", framereg);
d1629 188
d1818 74
d1903 10
d1928 66
d2024 1
d2040 5
d2049 7
a2055 1
  return -1;
d2134 3
d2193 1
d2200 2
d2208 9
d2223 2
d2232 1
d2243 9
d2253 3
d2260 32
d2335 1
a2335 1
	    "operand out of range (%s not between %d and %d)";
d2382 1
a2382 1
      const expressionS *t;
d2403 1
a2403 1
		static const expressionS zero_exp = { 0, 0, 0, O_constant, 1 };
d2405 2
d2434 1
a2434 1
	      as_fatal("too many fixups");
d2461 1
a2461 1
    alpha_align (2, (char *) NULL, alpha_insn_label);
d2473 1
d2477 4
d2483 1
a2483 6
      if (fixup->reloc < 0)
	size = 4, pcrel = 0;
#ifdef OBJ_ELF
      /* These relocation types are only used internally. */
      else if (fixup->reloc == BFD_RELOC_ALPHA_GPDISP_HI16
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_LO16)
d2485 3
a2487 1
	  size = 2, pcrel = 0;
d2489 9
d2499 19
a2517 5
      else
	{
	  reloc_howto_type *reloc_howto
	    = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	  assert (reloc_howto);
d2519 5
a2523 2
	  size = bfd_get_reloc_size (reloc_howto);
	  pcrel = reloc_howto->pc_relative;
a2524 1
      assert (size >= 1 && size <= 4);
d2529 2
a2530 1
      /* Turn off complaints that the addend is too large for some fixups */
d2543 64
d2608 5
d2645 1
a2645 1
	as_bad ("inappropriate arguments for opcode `%s'", opname);
d2647 2
a2648 2
	as_bad ("opcode `%s' not supported for target %s", opname,
	       alpha_target_name);
d2651 1
a2651 1
    as_bad ("unknown opcode `%s'", opname);
d2686 11
d2714 1
a2714 1
      as_bad ("inappropriate arguments for opcode `%s'", opname);
d2716 2
a2717 2
      as_bad ("opcode `%s' not supported for target %s", opname,
	     alpha_target_name);
d2719 1
a2719 1
    as_bad ("unknown opcode `%s'", opname);
d2740 2
a2741 2
     int ntok;
     const PTR unused;
d2753 10
a2762 2
  /* We're going to need this symbol in md_apply_fix().  */
  (void) section_symbol (absolute_section);
d2778 2
a2779 1
  assert (addend.X_op == O_constant);
d2827 1
a2827 1
  offset = -basesym->sy_obj;
d2877 3
d2884 1
a2884 1
load_expression (targreg, exp, pbasereg, poffset)
d2889 1
d2921 1
a2921 1
	  as_fatal ("overflow in literal (.lita) table");
d2928 1
a2928 1
	      as_bad ("macro requires $at register while noat in effect");
d2930 1
a2930 1
	      as_bad ("macro requires $at while $at in use");
d2941 1
d2951 1
a2951 1
	      as_bad ("macro requires $at register while noat in effect");
d2953 1
a2953 1
	      as_bad ("macro requires $at while $at in use");
d2960 5
a2964 2
	if (!range_signed_32 (addend)
	    && (alpha_noat_on || targreg == AXP_REG_AT))
d2979 12
a2990 1
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
a2994 10
	if (alpha_basereg_clobbered)
	  {
	    /* no basereg, reload basreg from 0(FP).  */
	    set_tok_reg (newtok[0], targreg);
	    set_tok_const (newtok[1], 0);
	    set_tok_preg (newtok[2], AXP_REG_FP);
	    basereg = targreg;
	    assemble_tokens ("ldq", newtok, 3, 0);
	  }

d2997 1
d3056 1
d3063 1
d3073 8
d3082 3
a3084 1
      abort();
d3113 1
a3113 1
	    as_fatal ("overflow in literal (.lita) table");
d3119 1
a3119 1
	as_fatal ("overflow in literal (.lit8) table");
d3126 1
a3126 1
	    as_bad ("macro requires $at register while noat in effect");
d3128 1
a3128 1
	    as_bad ("macro requires $at while $at in use");
d3169 3
a3171 2
      insn.fixups[0].exp.X_op = O_constant;
      insn.fixups[0].exp.X_add_number = 1;
d3251 1
a3251 1
emit_lda (tok, ntok, unused)
d3254 1
a3254 1
     const PTR unused;
d3257 47
d3310 1
a3310 1
  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL);
d3319 2
a3320 2
     int ntok;
     const PTR unused;
d3324 11
d3356 31
d3393 1
a3393 1
			    &newtok[1]);
d3400 16
d3426 3
a3428 2
      insn.fixups[0].exp.X_op = O_constant;
      insn.fixups[0].exp.X_add_number = 1;
a3431 9
#if OBJ_EVAX
    /* special hack. If the basereg is clobbered for a call
       all lda's before the call don't have a basereg.  */
  if ((tok[0].X_op == O_register)
     && (tok[0].X_add_number == alpha_gp_register))
    {
      alpha_basereg_clobbered = 1;
    }
#endif
d3447 15
d3470 1
a3470 1
	as_bad ("macro requires $at register while noat in effect");
d3472 2
a3473 1
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1]);
d3486 16
d3512 3
a3514 2
      insn.fixups[0].exp.X_op = O_constant;
      insn.fixups[0].exp.X_add_number = 1;
d3534 13
d3548 1
a3548 1
	as_bad ("macro requires $at register while noat in effect");
d3596 1
a3596 1
    as_bad ("macro requires $at register while noat in effect");
d3658 1
a3658 1
     const PTR unused;
d3662 11
d3696 1
a3696 1
	as_bad("macro requires $at register while noat in effect");
d3837 13
d3896 11
d3921 1
a3921 1
	as_bad ("macro requires $at register while noat in effect");
d4006 11
d4033 1
a4033 1
	as_bad ("macro requires $at register while noat in effect");
d4113 11
d4140 2
a4141 1
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL);
d4169 3
a4171 2
      insn.fixups[0].exp.X_op = O_constant;
      insn.fixups[0].exp.X_add_number = 3;
a4174 13

#if OBJ_EVAX
  alpha_basereg_clobbered = 0;

  /* reload PV from 0(FP) if it is our current base register.  */
  if (alpha_gp_register == AXP_REG_PV)
    {
      set_tok_reg (newtok[0], AXP_REG_PV);
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], AXP_REG_FP);
      assemble_tokens ("ldq", newtok, 3, 0);
    }
#endif
d4190 11
d4253 1
a4253 1
#ifndef OBJ_ELF
d4255 2
a4256 1
/* Handle the OSF/1 .comm pseudo quirks.  */
d4268 6
d4291 1
a4291 1
      as_warn (".COMMon length (%ld.) <0! Ignored.", (long) temp);
d4298 6
d4306 3
a4308 1
  if (S_IS_DEFINED (symbolP))
d4310 11
a4320 1
      as_bad ("Ignoring attempt to re-define symbol");
d4325 10
a4334 21
#if OBJ_EVAX
  {
    /* Fill common area with zeros.  */
    char *pfrag;
    segT current_seg = now_seg;
    subsegT current_subseg = now_subseg;

    subseg_set (bss_section, 1);
    frag_align (3, 0);

    symbolP->sy_frag = frag_now;
    pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
		      temp, (char *)0);

    *pfrag = 0;
    S_SET_SEGMENT (symbolP, bss_section);

    subseg_set (current_seg, current_subseg);
  }
#endif

d4338 1
a4338 1
	as_bad ("Length of .comm \"%s\" is already %ld. Not changed to %ld.",
d4343 1
d4346 7
d4354 1
d4358 2
a4359 2
#ifndef OBJ_EVAX
  know (symbolP->sy_frag == &zero_address_frag);
d4362 2
d4369 1
a4369 1
#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)
d4426 43
a4468 1
#endif
a4469 1
#ifdef OBJ_EVAX
d4471 2
a4472 2
s_alpha_link (ignore)
     int ignore;
d4474 34
a4507 1
  int temp;
d4509 4
a4512 6
  temp = get_absolute_expression ();
  subseg_new (".link", 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
d4515 14
d4530 9
a4538 1
/* .prologue */
d4542 1
a4542 1
     int ignore;
d4544 4
a4547 1
  alpha_basereg_clobbered = 0;
d4550 77
a4626 1
  return;
d4654 1
a4654 1
      as_fatal (".ent directive has no symbol");
d4660 1
a4660 1
  symbol->bsym->flags |= BSF_FUNCTION;
d4682 1
a4682 1
      as_warn ("Bad .frame directive 1./2. param");
d4694 1
a4694 1
      as_warn ("Bad .frame directive 3./4. param");
d4719 1
a4719 1
      as_bad (".pdesc directive not in link (.link) section");
d4727 1
a4727 1
      as_fatal (".pdesc has no matching .ent");
d4732 2
a4733 1
  alpha_evax_proc.symbol->sy_obj = (valueT)seginfo->literal_pool_size;
d4738 1
a4738 1
      as_warn (".pdesc directive has no entry symbol");
d4745 2
a4746 1
  alpha_evax_proc.symbol->bsym->udata.p = (PTR)entry_sym->bsym;
d4751 1
a4751 1
      as_warn ("No comma after .pdesc <entryname>");
d4774 1
a4774 1
      as_fatal ("unknown procedure kind");
d4786 1
a4786 1
  frag_align (3, 0);
d4857 41
d4912 1
a4912 1
      as_fatal ("No symbol after .linkage");
d4928 29
d4976 1
a4976 1
      as_warn ("Bad .mask directive");
d4998 1
a4998 1
      as_warn ("Bad .fmask directive");
a5020 1
  alpha_basereg_clobbered = 0;
d5036 2
a5037 5
  sprintf (case_hack, "<CASE:%01d%01d%01d%01d>",
	    alpha_flag_hash_long_names,
	    alpha_flag_show_after_trunc,
	    alpha_flag_no_hash_mixed_case,
	    alpha_vms_name_mapping);
d5040 1
a5040 1
  s->bsym->flags |= BSF_FILE;
d5044 1
a5044 1
  s->bsym->flags |= BSF_FILE;
d5055 1
a5055 1
     int ignore;
d5093 1
a5093 1
    alpha_align (2, (char *) NULL, alpha_insn_label);
d5137 1
a5137 1
    alpha_align (log_size, (char *) NULL, alpha_insn_label);
d5150 1
a5150 1
     int is_static;
d5159 1
d5169 1
a5169 1
      as_warn ("Expected comma after name \"%s\"", name);
d5179 2
a5180 2
  /*  symbolP->sy_other = (signed char) temp; */
  as_warn ("unhandled: .proc %s,%d", name, temp);
d5189 1
a5189 1
     int x;
d5191 1
a5191 1
  char *name = input_line_pointer, ch, *s;
d5194 3
a5196 4
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;
  ch = *input_line_pointer;
  *input_line_pointer = '\0';
d5215 1
a5215 1
    as_warn ("Tried to .set unrecognized mode `%s'", name);
d5226 1
a5226 1
     int ignore;
d5232 1
a5232 1
      as_warn ("File overrides no-base-register option.");
d5249 1
a5249 1
      as_warn ("Bad base register, using $%d.", alpha_gp_register);
d5261 1
a5261 1
     int ignore;
d5271 1
a5271 1
      as_bad ("Alignment too large: %d. assumed", align);
d5275 1
a5275 1
      as_warn ("Alignment negative: 0 assumed");
d5291 1
a5291 1
      alpha_align (align, pfill, alpha_insn_label);
d5336 1
a5336 1
    alpha_align (log_size, (char *) NULL, alpha_insn_label);
d5341 71
d5417 1
a5417 2
  {"common", s_comm, 0},	/* is this used? */
#ifndef OBJ_ELF
d5419 1
a5422 3
#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)
  {"rdata", s_alpha_rdata, 0},
#endif
d5434 1
d5436 1
a5441 1
  { "link", s_alpha_link, 0},
d5444 27
a5485 1
  {"prologue", s_ignore, 0},
d5501 12
d5517 2
d5588 1
a5588 1
  printf ("Chose GP value of %lx\n", alpha_gp_value);
d5599 1
a5599 1
alpha_align (n, pfill, label)
d5603 1
d5613 5
a5617 1
	  static char const nop[4] = { 0x1f, 0x04, 0xff, 0x47 };
d5625 5
a5629 2
	    frag_align (2, 0);
	  frag_align_pattern (n, nop, sizeof nop);
d5632 1
a5632 1
	frag_align (n, 0);
d5635 1
a5635 1
    frag_align (n, *pfill);
d5639 1
a5639 1
  if (label != NULL)
d5641 1
a5641 2
      assert (S_GET_SEGMENT (label) == now_seg);
      label->sy_frag = frag_now;
d5645 4
a5648 1
  record_alignment(now_seg, n);
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d90 2
a91 2
  void (*emit) PARAMS((const expressionS *, int, void *));
  void *arg;
d157 1
a157 1
static int tokenize_arguments PARAMS((char *, expressionS*, int));
d159 1
a159 1
	PARAMS((const struct alpha_opcode*, const expressionS*, int*, int*));
d161 31
a191 21
	PARAMS((const struct alpha_macro*, const expressionS*, int*));
static unsigned insert_operand PARAMS((unsigned, const struct alpha_operand*,
				      offsetT, char *, unsigned));
static void assemble_insn PARAMS((const struct alpha_opcode*,
				  const expressionS*, int,
				  struct alpha_insn*));
static void emit_insn PARAMS((struct alpha_insn *));
static void assemble_tokens_to_insn PARAMS((const char *, const expressionS*,
					    int, struct alpha_insn *));
static void assemble_tokens PARAMS((const char *, const expressionS*,
				    int, int));

static int load_expression PARAMS((int, const expressionS*, int *,
				   expressionS*));

static void emit_ldgp PARAMS((const expressionS*, int, void*));
static void emit_division PARAMS((const expressionS*, int, void*));
static void emit_lda PARAMS((const expressionS*, int, void*));
static void emit_ir_load PARAMS((const expressionS*, int, void*));
static void emit_loadstore PARAMS((const expressionS*, int, void*));
static void emit_jsrjmp PARAMS((const expressionS*, int, void*));
d193 2
a194 2
static void s_alpha_text PARAMS((int));
static void s_alpha_data PARAMS((int));
d196 1
a196 1
static void s_alpha_comm PARAMS((int));
d199 1
a199 1
static void s_alpha_rdata PARAMS((int));
d202 1
a202 1
static void s_alpha_sdata PARAMS((int));
d205 1
a205 1
static void s_alpha_section PARAMS((int));
d207 8
a214 8
static void s_alpha_gprel32 PARAMS((int));
static void s_alpha_float_cons PARAMS((int));
static void s_alpha_proc PARAMS((int));
static void s_alpha_set PARAMS((int));
static void s_alpha_base PARAMS((int));
static void s_alpha_align PARAMS((int));
static void s_alpha_stringer PARAMS((int));
static void s_alpha_space PARAMS((int));
d216 1
a216 1
static void create_literal_section PARAMS((const char *, segT*, symbolS**));
d218 1
a218 1
static void select_gp_value PARAMS((void));
d220 1
a220 1
static void alpha_align PARAMS((int, char *, symbolS *));
d254 3
d258 1
d269 20
d290 1
a290 1
static unsigned alpha_target = AXP_OPCODE_ALL;
a292 4
/* Forward declaration of the table of macros */
static const struct alpha_macro alpha_macros[];
static const int alpha_num_macros;

d333 6
d370 176
a545 1
static evaxProcT alpha_evax_proc;
d547 86
d753 1
a753 1
      bfd_set_section_flags(stdoutput, sec, 
d903 25
a927 9
	  { "21064", AXP_OPCODE_EV4|AXP_OPCODE_ALL },
	  { "21066", AXP_OPCODE_EV4|AXP_OPCODE_ALL },
	  { "21164", AXP_OPCODE_EV5|AXP_OPCODE_ALL },
	  { "21164a", AXP_OPCODE_EV56|AXP_OPCODE_ALL },
	  { "ev4", AXP_OPCODE_EV4|AXP_OPCODE_ALL },
	  { "ev45", AXP_OPCODE_EV4|AXP_OPCODE_ALL },
	  { "ev5", AXP_OPCODE_EV5|AXP_OPCODE_ALL },
	  { "ev56", AXP_OPCODE_EV56|AXP_OPCODE_ALL },
	  { "all", AXP_OPCODE_ALL },
d930 1
a930 1
	
d942 17
d980 9
d1040 1
a1040 1
	fixP->fx_offset = (next->fx_frag->fr_address + next->fx_where 
d1118 1
a1118 1
    case BFD_RELOC_ALPHA_LITERAL:
d1131 1
a1131 1
	if (fixP->fx_r_type <= BFD_RELOC_UNUSED)
d1135 2
a1136 2
	assert (fixP->fx_r_type < BFD_RELOC_UNUSED + alpha_num_operands);
	operand = &alpha_operands[fixP->fx_r_type - BFD_RELOC_UNUSED];
d1139 1
a1139 1
	   resolution and have no representation in the object file.  
d1162 1
a1162 1
      
d1171 1
a1171 1
/* 
d1202 1
a1202 1
	      num = (name[0] - '0')*10 + name[1] - '0';
d1272 1
d1274 4
d1292 1
a1292 2
      assert(f->fx_r_type > BFD_RELOC_UNUSED &&
	     f->fx_r_type < BFD_RELOC_UNUSED + alpha_num_operands);
d1337 1
a1337 1
  assert (fixp->fx_r_type < BFD_RELOC_UNUSED);
d1366 1
a1366 1
      /* 
d1423 1
a1423 1
  memset (tok, 0, sizeof(*tok)*ntok);
d1425 1
a1425 1
  /* Save and restore input_line_pointer around this function */ 
d1428 1
a1428 1
  
d1584 1
a1584 1
  while (++opcode-alpha_opcodes < alpha_num_opcodes 
d1660 1
a1660 1
		
d1670 1
a1670 1
  while (++macro-alpha_macros < alpha_num_macros 
d1703 1
a1703 1
	  const char *err = 
d1705 1
a1705 1
	  char buf[sizeof(val)*3+2];
d1719 1
a1719 1
      insn = (*operand->insert)(insn, val, &errmsg);
d1721 1
a1721 1
	as_warn(errmsg);
d1729 1
a1729 1
/* 
d1745 1
a1745 1
  memset(insn, 0, sizeof(*insn));
d1815 1
a1815 1
/* 
d1845 1
a1845 1
      if (fixup->reloc > BFD_RELOC_UNUSED)
d1857 1
a1857 1
	  reloc_howto_type *reloc_howto 
d1873 1
d1875 4
d1970 1
a1970 1
  
d1990 3
d1996 1
a1996 1
static void 
d2000 1
a2000 1
     void *unused;
d2041 1
a2041 1
  
d2177 1
a2177 1
	    
d2199 1
a2199 1
	    
d2221 1
a2221 1
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
d2226 10
d2277 1
d2290 1
a2321 1

a2328 1

d2336 7
d2349 1
a2349 1
      /* emit "ldq litreg, .lit8+lit" */
d2362 7
a2368 1
      set_tok_sym (newtok[1], alpha_lit8_symbol, lit);
d2370 32
a2401 1
      assemble_tokens ("ldq", newtok, 2, 1); /* note this does recurse */
d2481 1
a2481 1
     void *unused;
d2500 1
a2500 1
     void *unused;
d2519 1
a2519 1
     void *opname;
d2553 9
d2571 1
a2571 1
     void *opname;
d2576 1
a2576 1
  
d2619 1
a2619 1
static void 
d2623 1
a2623 1
     void *vlgsize;
d2625 8
a2632 1
  expressionS newtok[3];
d2634 1
a2634 4
  if (alpha_noat_on)
    as_bad ("macro requires $at register while noat in effect");
  
  /* emit "lda $at, exp" */
d2636 3
a2638 3
  memcpy (newtok, tok, sizeof(expressionS)*ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);
d2640 1
a2640 1
  /* emit "ldq_u targ, 0($at)" */
d2642 4
a2645 4
  newtok[0] = tok[0];
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);
d2647 1
a2647 1
  /* emit "extXl targ, $at, targ" */
d2649 4
a2652 3
  set_tok_reg (newtok[1], AXP_REG_AT);
  newtok[2] = newtok[0];
  assemble_tokens (extXl_op[(long)vlgsize], newtok, 3, 1);
d2657 1
a2657 1
static void 
d2661 1
a2661 1
     void *vlgsize;
d2674 1
a2674 1
     void *vlgsize;
d2684 1
a2684 1
  memcpy (newtok, tok, sizeof(expressionS)*ntok);
d2721 1
a2721 1
  
d2730 1
a2730 1
     void *vlgsize;
d2742 1
a2742 1
     void *unused;
d2757 2
a2758 1
     void *vlgsize;
a2760 1
  expressionS newtok[3];
d2762 8
a2769 2
  if (alpha_noat_on)
    as_bad("macro requires $at register while noat in effect");
d2771 1
a2771 1
  /* emit "lda $at, exp" */
d2773 3
a2775 3
  memcpy (newtok, tok, sizeof(expressionS)*ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);
d2777 1
a2777 1
  /* emit "ldq_u $t9, 0($at)" */
d2779 4
a2782 4
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);
d2784 1
a2784 1
  /* emit "insXl src, $at, $t10" */
d2786 4
a2789 4
  newtok[0] = tok[0];
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T10);
  assemble_tokens (insXl_op[lgsize], newtok, 3, 1);
d2791 1
a2791 1
  /* emit "mskXl $t9, $at, $t9" */
d2793 3
a2795 3
  set_tok_reg (newtok[0], AXP_REG_T9);
  newtok[2] = newtok[0];
  assemble_tokens (mskXl_op[lgsize], newtok, 3, 1);
d2797 1
a2797 1
  /* emit "or $t9, $t10, $t9" */
d2799 2
a2800 2
  set_tok_reg (newtok[1], AXP_REG_T10);
  assemble_tokens ("or", newtok, 3, 1);
d2802 1
a2802 1
  /* emit "stq_u $t9, 0($at) */
d2804 4
a2807 3
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("stq_u", newtok, 3, 1);
d2816 1
a2816 1
     void *vlgsize;
d2823 1
a2823 1
  memcpy (newtok, tok, sizeof(expressionS)*ntok);
d2899 1
a2899 1
     void *vlgsize;
d2901 8
a2908 2
  int bitshift = 64 - 8*(1 << (long)vlgsize);
  expressionS newtok[3];
d2910 1
a2910 1
  /* emit "sll src,bits,dst" */
d2912 4
a2915 4
  newtok[0] = tok[0];
  set_tok_const (newtok[1], bitshift);
  newtok[2] = tok[ntok - 1];
  assemble_tokens ("sll", newtok, 3, 1);
d2917 1
a2917 1
  /* emit "sra dst,bits,dst" */
d2919 3
a2921 2
  newtok[0] = newtok[2];
  assemble_tokens ("sra", newtok, 3, 1);
d2931 1
a2931 1
static void 
d2935 1
a2935 1
     void *symname;
d2949 1
a2949 1
   * specified by the compiler. 
d2958 1
a2958 1
    
d3031 1
a3031 1
static void 
d3035 1
a3035 1
     void *symname;
d3048 1
a3048 1
   * specified by the compiler. 
d3057 1
a3057 1
    
d3144 1
a3144 1
     void *vopname;
d3202 2
d3222 1
a3222 1
     void *vopname;
d3265 1
a3265 1
}  
d3278 1
a3278 1
}  
d3333 1
a3333 1
  
d3336 1
a3336 1
  
d3340 1
a3340 1
      
d3417 1
a3417 1
static void 
d3428 1
a3428 1
#endif  
d3452 1
d3778 1
d3788 1
a3788 1
  char* s;
d3790 2
d3794 9
d3804 2
a3805 1
  s = demand_copy_string (&length);
a4102 229
/* The macro table */

const struct alpha_macro alpha_macros[] = {
/* Load/Store macros */
  { "lda",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldah",	emit_ldah, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "ldl",	emit_ir_load, "ldl",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldl_l",	emit_ir_load, "ldl_l",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldq",	emit_ir_load, "ldq",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldq_l",	emit_ir_load, "ldq_l",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldq_u",	emit_ir_load, "ldq_u",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldf",	emit_loadstore, "ldf",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldg",	emit_loadstore, "ldg",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "lds",	emit_loadstore, "lds",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldt",	emit_loadstore, "ldt",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },

  { "ldb",	emit_ldX, (void *)0,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldbu",	emit_ldXu, (void *)0,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldw",	emit_ldX, (void *)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldwu",	emit_ldXu, (void *)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "uldw",	emit_uldX, (void*)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldwu",	emit_uldXu, (void*)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldl",	emit_uldX, (void*)2,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldlu",	emit_uldXu, (void*)2,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldq",	emit_uldXu, (void*)3,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "ldgp",	emit_ldgp, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA } },

  { "ldi",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldil",	emit_ldil, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldiq",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
#if 0
  { "ldif"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldid"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldig"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldis"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldit"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
#endif

  { "stl",	emit_loadstore, "stl",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stl_c",	emit_loadstore, "stl_c",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stq",	emit_loadstore, "stq",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stq_c",	emit_loadstore, "stq_c",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stq_u",	emit_loadstore, "stq_u",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stf",	emit_loadstore, "stf",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "stg",	emit_loadstore, "stg",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "sts",	emit_loadstore, "sts",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "stt",	emit_loadstore, "stt",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },

  { "stb",	emit_stX, (void*)0,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stw",	emit_stX, (void*)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ustw",	emit_ustX, (void*)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ustl",	emit_ustX, (void*)2,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ustq",	emit_ustX, (void*)3,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },

/* Arithmetic macros */
#if 0
  { "absl"	emit_absl, 1, { IR } },
  { "absl"	emit_absl, 2, { IR, IR } },
  { "absl"	emit_absl, 2, { EXP, IR } },
  { "absq"	emit_absq, 1, { IR } },
  { "absq"	emit_absq, 2, { IR, IR } },
  { "absq"	emit_absq, 2, { EXP, IR } },
#endif

  { "sextb",	emit_sextX, (void *)0,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },
  { "sextw",	emit_sextX, (void *)1,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },

  { "divl",	emit_division, "__divl",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divlu",	emit_division, "__divlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divq",	emit_division, "__divq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divqu",	emit_division, "__divqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "reml",	emit_division, "__reml",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remlu",	emit_division, "__remlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remq",	emit_division, "__remq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remqu",	emit_division, "__remqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },

  { "jsr",	emit_jsrjmp, "jsr",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "jmp",	emit_jsrjmp, "jmp",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "ret",	emit_retjcr, "ret",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jcr",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jsr_coroutine",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
};

static const int alpha_num_macros
  = sizeof(alpha_macros) / sizeof(*alpha_macros);

@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d1 2
a2 2
/* tc-alpha.c - Processor-specific code for the DEC Alpha CPU.
   Copyright (C) 1989, 1993, 1994 Free Software Foundation, Inc.
d6 2
d22 3
a24 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a50 10
/*
 * HISTORY
 *  5-Oct-93  Alessandro Forin (af) at Carnegie-Mellon University
 *	First Checkin
 *
 *    Author:	Alessandro Forin, Carnegie Mellon University
 *    Date:	Jan 1993
 */

#include <ctype.h>
a52 1
#include "alpha-opcode.h"
d55 4
a58 5
/* The OSF/1 V2.0 Alpha compiler can't compile this file with inline
   functions.  */
#ifndef __GNUC__
#undef inline
#define inline
d61 1
a61 2
/* @@@@ Will a simple 0x8000 work here?  If not, why not?  */
#define GP_ADJUSTMENT	(0x8000 - 0x10)
d63 2
a64 4
/* These are exported to relaxing code, even though we don't do any
   relaxing on this processor currently.  */
int md_short_jump_size = 4;
int md_long_jump_size = 4;
d66 2
a67 2
/* handle of the OPCODE hash table */
static struct hash_control *op_hash;
d69 5
a73 3
/* Sections and symbols we'll want to keep track of.  */
static segT lita_sec, rdata, sdata, lit8_sec, lit4_sec;
static symbolS *lit8_sym, *lit4_sym;
d75 6
a80 2
/* Setting for ".set [no]{at,macro}".  */
static int at_ok = 1, macro_ok = 1;
d82 4
a85 3
/* Keep track of global pointer.  */
valueT alpha_gp_value;
static symbolS *gp;
d87 7
a93 3
/* We'll probably be using this relocation frequently, and we
   will want to compare for it.  */
static reloc_howto_type *gpdisp_hi16_howto;
d95 2
a96 2
/* These are exported to ECOFF code.  */
unsigned long alpha_gprmask, alpha_fprmask;
d98 2
a99 2
/* Used for LITUSE relocations.  */
static expressionS lituse_basereg, lituse_byteoff, lituse_jsr;
d101 1
a101 5
/* Address size: In OSF/1 1.3, an undocumented "-32addr" option will
   cause all addresses to be treated as 32-bit values in memory.  (The
   in-register versions are all sign-extended to 64 bits, of course.)
   Some other systems may want this option too.  */
static int addr32;
d103 3
a105 6
/* Symbol labelling the current insn.  When the Alpha gas sees
     foo:
       .quad 0
   and the section happens to not be on an eight byte boundary, it
   will align both the symbol and the .quad to an eight byte boundary.  */
static symbolS *insn_label;
d107 1
a107 3
/* Whether we should automatically align data generation pseudo-ops.
   .align 0 will turn this off.  */
static int auto_align = 1;
d109 2
a110 34
/* Imported functions -- they should be defined in header files somewhere.  */
extern segT subseg_get ();
extern PTR bfd_alloc_by_size_t ();
extern void s_globl (), s_long (), s_short (), s_space (), cons (), s_text (),
  s_data (), float_cons ();

/* Static functions, needing forward declarations.  */
static void s_base (), s_proc (), s_alpha_set ();
static void s_gprel32 (), s_rdata (), s_sdata (), s_alpha_comm ();
static void s_alpha_text PARAMS ((int));
static void s_alpha_data PARAMS ((int));
static void s_alpha_align PARAMS ((int));
static void s_alpha_cons PARAMS ((int));
static void s_alpha_float_cons PARAMS ((int));
static int alpha_ip ();

static void emit_unaligned_io PARAMS ((char *, int, valueT, int));
static void emit_load_unal PARAMS ((int, valueT, int));
static void emit_store_unal PARAMS ((int, valueT, int));
static void emit_byte_manip_r PARAMS ((char *, int, int, int, int, int));
static void emit_extract_r PARAMS ((int, int, int, int, int));
static void emit_insert_r PARAMS ((int, int, int, int, int));
static void emit_mask_r PARAMS ((int, int, int, int, int));
static void emit_sign_extend PARAMS ((int, int));
static void emit_bis_r PARAMS ((int, int, int));
static int build_mem PARAMS ((int, int, int, bfd_signed_vma));
static int build_operate_n PARAMS ((int, int, int, int, int));
static void emit_sll_n PARAMS ((int, int, int));
static void emit_ldah_num PARAMS ((int, bfd_vma, int));
static void emit_addq_r PARAMS ((int, int, int));
static void emit_lda_n PARAMS ((int, bfd_vma, int));
static void emit_add64 PARAMS ((int, int, bfd_vma));
static int in_range_signed PARAMS ((bfd_vma, int));
static void alpha_align PARAMS ((int, int, symbolS *));
d112 1
a112 14
const pseudo_typeS md_pseudo_table[] =
{
  {"common", s_comm, 0},	/* is this used? */
  {"comm", s_alpha_comm, 0},	/* osf1 compiler does this */
  {"text", s_alpha_text, 0},
  {"data", s_alpha_data, 0},
  {"rdata", s_rdata, 0},
  {"sdata", s_sdata, 0},
  {"gprel32", s_gprel32, 0},
  {"t_floating", s_alpha_float_cons, 'd'},
  {"s_floating", s_alpha_float_cons, 'f'},
  {"f_floating", s_alpha_float_cons, 'F'},
  {"g_floating", s_alpha_float_cons, 'G'},
  {"d_floating", s_alpha_float_cons, 'D'},
d114 17
a130 10
  {"proc", s_proc, 0},
  {"aproc", s_proc, 1},
  {"set", s_alpha_set, 0},
  {"reguse", s_ignore, 0},
  {"livereg", s_ignore, 0},
  {"base", s_base, 0},		/*??*/
  {"option", s_ignore, 0},
  {"prologue", s_ignore, 0},
  {"aent", s_ignore, 0},
  {"ugen", s_ignore, 0},
d132 1
a132 12
  {"align", s_alpha_align, 0},
  {"byte", s_alpha_cons, 0},
  {"hword", s_alpha_cons, 1},
  {"int", s_alpha_cons, 2},
  {"long", s_alpha_cons, 2},
  {"octa", s_alpha_cons, 4},
  {"quad", s_alpha_cons, 3},
  {"short", s_alpha_cons, 1},
  {"word", s_alpha_cons, 1},
  {"double", s_alpha_float_cons, 'd'},
  {"float", s_alpha_float_cons, 'f'},
  {"single", s_alpha_float_cons, 'f'},
d134 19
a152 3
/* We don't do any optimizing, so we can safely ignore these.  */
  {"noalias", s_ignore, 0},
  {"alias", s_ignore, 0},
d154 2
a155 2
  {NULL, 0, 0},
};
d157 36
a192 21
#define	SA	21		/* shift for register Ra */
#define	SB	16		/* shift for register Rb */
#define	SC	0		/* shift for register Rc */
#define	SN	13		/* shift for 8 bit immediate # */

#define	T9	23
#define	T10	24
#define	T11	25
#define T12	26
#define RA	26		/* note: same as T12 */
#define	PV	27
#define	AT	28
#define	GP	29
#define	SP	30
#define	ZERO	31

#define OPCODE(X)	(((X) >> 26) & 0x3f)
#define OP_FCN(X)	(((X) >> 5) & 0x7f)

#ifndef FIRST_32BIT_QUADRANT
#define FIRST_32BIT_QUADRANT 0
d194 17
d212 3
a214 2
int first_32bit_quadrant = FIRST_32BIT_QUADRANT;
int base_register = FIRST_32BIT_QUADRANT ? ZERO : GP;
d216 4
a219 2
int no_mixed_code = 0;
int nofloats = 0;
d221 1
a221 2
/* This array holds the chars that always start a comment.  If the
    pre-processor is disabled, these aren't very useful */
d224 6
a229 8
/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output. */
/* Also note that C style comments are always recognized.  */
const char line_comment_chars[] = "#!";
d231 2
a232 1
/* Chars that can be used to separate mant from exp in floating point nums */
d235 6
a240 5
const char line_separator_chars[1];

/* Chars that mean this number is a floating point constant, as in
   "0f12.456" or "0d1.2345e12".  */
/* @@@@ Do all of these really get used on the alpha??  */
d242 1
d244 1
a244 3
/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c.  Ideally it shouldn't have to know about it at all,
   but nothing is ideal around here.  */
d246 4
a249 4
struct reloc_data {
  expressionS exp;
  int pcrel;
  bfd_reloc_code_real_type code;
d252 24
a275 9
/* Occasionally, two relocations will be desired for one address.
   Mainly only in cases like "jsr $r,foo" where we want both a LITUSE
   and a HINT reloc.  */
#define MAX_RELOCS 2

struct alpha_it {
  unsigned long opcode;	/* need at least 32 bits */
  struct reloc_data reloc[MAX_RELOCS];
};
d277 2
a278 2
static void getExpression (char *str, struct alpha_it *insn);
static char *expr_end;
d280 2
a281 2
#define note_gpreg(R)		(alpha_gprmask |= (1 << (R)))
#define note_fpreg(R)		(alpha_fprmask |= (1 << (R)))
d283 9
a291 5
int
tc_get_register (frame)
     int frame;
{
  int framereg = SP;
d293 9
a301 16
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
    {
      input_line_pointer++;
      if (input_line_pointer[0] == 's'
	  && input_line_pointer[1] == 'p')
	{
	  input_line_pointer += 2;
	  framereg = SP;
	}
      else
	framereg = get_absolute_expression ();
      framereg &= 31;		/* ? */
    }
  else
    as_warn ("frame reg expected, using $%d.", framereg);
d303 2
a304 3
  note_gpreg (framereg);
  return framereg;
}
d306 2
a307 2
/* Handle the .text pseudo-op.  This is like the usual one, but it
   clears insn_label and restores auto alignment.  */
d309 2
a310 8
static void
s_alpha_text (i)
     int i;
{
  s_text (i);
  insn_label = NULL;
  auto_align = 1;
}  
d312 2
a313 2
/* Handle the .data pseudo-op.  This is like the usual one, but it
   clears insn_label and restores auto alignment.  */
d315 6
a320 8
static void
s_alpha_data (i)
     int i;
{
  s_data (i);
  insn_label = NULL;
  auto_align = 1;
}  
d322 3
a324 5
static void
s_rdata (ignore)
     int ignore;
{
  int temp;
d326 2
a327 12
  temp = get_absolute_expression ();
#if 0
  if (!rdata)
    rdata = subseg_get (".rdata", 0);
  subseg_set (rdata, (subsegT) temp);
#else
  rdata = subseg_new (".rdata", 0);
#endif
  demand_empty_rest_of_line ();
  insn_label = NULL;
  auto_align = 1;
}
d329 2
a330 5
static void
s_sdata (ignore)
     int ignore;
{
  int temp;
d332 3
a334 7
  temp = get_absolute_expression ();
#if 0
  if (!sdata)
    sdata = subseg_get (".sdata", 0);
  subseg_set (sdata, (subsegT) temp);
#else
  sdata = subseg_new (".sdata", 0);
d336 6
a341 4
  demand_empty_rest_of_line ();
  insn_label = NULL;
  auto_align = 1;
}
d343 2
a344 3
static void
s_alpha_comm (ignore)
     int ignore;
d346 3
a348 5
  register char *name;
  register char c;
  register char *p;
  offsetT temp;
  register symbolS *symbolP;
d350 2
a351 8
  name = input_line_pointer;
  c = get_symbol_end ();
  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  /* Alpha OSF/1 compiler doesn't provide the comma, gcc does.  */
  if (*input_line_pointer == ',')
d353 11
a363 2
      input_line_pointer++;
      SKIP_WHITESPACE ();
d365 5
a369 1
  if ((temp = get_absolute_expression ()) < 0)
d371 17
a387 3
      as_warn (".COMMon length (%ld.) <0! Ignored.", (long) temp);
      ignore_rest_of_line ();
      return;
d389 5
a393 4
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  if (S_IS_DEFINED (symbolP))
d395 11
a405 3
      as_bad ("Ignoring attempt to re-define symbol");
      ignore_rest_of_line ();
      return;
d407 4
a410 1
  if (S_GET_VALUE (symbolP))
d412 4
a415 5
      if (S_GET_VALUE (symbolP) != (valueT) temp)
	as_bad ("Length of .comm \"%s\" is already %ld. Not changed to %ld.",
		S_GET_NAME (symbolP),
		(long) S_GET_VALUE (symbolP),
		(long) temp);
d417 1
a417 1
  else
d419 4
a422 2
      S_SET_VALUE (symbolP, (valueT) temp);
      S_SET_EXTERNAL (symbolP);
d425 4
a428 3
  know (symbolP->sy_frag == &zero_address_frag);
  demand_empty_rest_of_line ();
}
d430 2
a431 6
arelent *
tc_gen_reloc (sec, fixp)
     asection *sec;
     fixS *fixp;
{
  arelent *reloc;
d433 5
a437 3
  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
d439 3
a441 2
  if (fixp->fx_r_type > BFD_RELOC_UNUSED)
    abort ();
d443 2
a444 1
  if (fixp->fx_r_type == BFD_RELOC_ALPHA_GPDISP_HI16)
d446 14
a459 4
      if (!gpdisp_hi16_howto)
	gpdisp_hi16_howto = bfd_reloc_type_lookup (stdoutput,
						   fixp->fx_r_type);
      reloc->howto = gpdisp_hi16_howto;
d461 1
a461 9
  else
    reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  assert (reloc->howto != 0);
  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
    {
      as_fatal ("internal error? cannot generate `%s' relocation",
		bfd_get_reloc_code_name (fixp->fx_r_type));
    }
  assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);
d463 1490
a1952 1
  if (fixp->fx_r_type == BFD_RELOC_ALPHA_LITERAL)
d1954 57
a2010 2
      /* fake out bfd_perform_relocation. sigh */
      reloc->addend = -alpha_gp_value;
d2012 1
a2012 1
  else if (reloc->howto->pc_relative && reloc->howto->pcrel_offset)
d2014 49
a2062 1
      reloc->addend = fixp->fx_offset - reloc->address;
d2064 18
d2083 21
a2103 2
    reloc->addend = fixp->fx_offset;
  return reloc;
d2106 4
d2111 4
a2114 1
s_base ()
d2116 18
a2133 1
  if (first_32bit_quadrant)
d2135 10
a2144 3
      /* not fatal, but it might not work in the end */
      as_warn ("File overrides no-base-register option.");
      first_32bit_quadrant = 0;
d2147 20
a2166 7
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
    {				/* $rNN form */
      input_line_pointer++;
      if (*input_line_pointer == 'r')
	input_line_pointer++;
    }
d2168 1
a2168 2
  base_register = get_absolute_expression ();
  if (base_register < 0 || base_register > 31)
d2170 2
a2171 5
      base_register = GP;
      as_warn ("Bad base register, using $%d.", base_register);
    }
  demand_empty_rest_of_line ();
}
d2173 1
a2173 21
static int in_range_signed (val, nbits)
     bfd_vma val;
     int nbits;
{
  /* Look at top bit of value that would be stored, figure out how it
     would be extended by the hardware, and see if that matches the
     original supplied value.  */
  bfd_vma mask;
  bfd_vma one = 1;
  bfd_vma top_bit, stored_value, missing_bits;

  mask = (one << nbits) - 1;
  stored_value = val & mask;
  top_bit = stored_value & (one << (nbits - 1));
  missing_bits = val & ~mask;
  /* will sign-extend */
  if (top_bit)
    {
      /* all remaining bits beyond mask should be one */
      missing_bits |= mask;
      return missing_bits + 1 == 0;
d2177 2
a2178 2
      /* all other bits should be zero */
      return missing_bits == 0;
d2180 21
d2203 7
a2209 4
#if 0
static int in_range_unsigned (val, nbits)
     bfd_vma val;
     int nbits;
d2211 19
a2229 6
  /* Look at top bit of value that would be stored, figure out how it
     would be extended by the hardware, and see if that matches the
     original supplied value.  */
  bfd_vma mask;
  bfd_vma one = 1;
  bfd_vma top_bit, stored_value, missing_bits;
d2231 3
a2233 5
  mask = (one << nbits) - 1;
  stored_value = val & mask;
  top_bit = stored_value & (one << nbits - 1);
  missing_bits = val & ~mask;
  return missing_bits == 0;
a2234 1
#endif
d2236 7
a2242 2
static void
s_gprel32 ()
d2244 3
a2246 2
  expressionS e;
  char *p;
d2248 2
a2249 22
  SKIP_WHITESPACE ();
  expression (&e);
  switch (e.X_op)
    {
    case O_constant:
      e.X_add_symbol = section_symbol (absolute_section);
      /* fall through */
    case O_symbol:
      e.X_op = O_subtract;
      e.X_op_symbol = gp;
      break;
    default:
      abort ();
    }
  if (auto_align)
    alpha_align (2, 0, insn_label);
  p = frag_more (4);
  memset (p, 0, 4);
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &e, 0,
	       BFD_RELOC_GPREL32);
  insn_label = NULL;
}
d2252 4
a2255 3
create_literal_section (secp, name)
     segT *secp;
     const char *name;
d2257 39
a2295 3
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT new_sec;
d2297 4
a2300 6
  *secp = new_sec = subseg_new (name, 0);
  subseg_set (current_section, current_subsec);
  bfd_set_section_alignment (stdoutput, new_sec, 3);
  bfd_set_section_flags (stdoutput, new_sec,
			 SEC_RELOC | SEC_ALLOC | SEC_LOAD | SEC_READONLY
			 | SEC_DATA);
d2302 4
d2307 5
a2311 3
static valueT
get_lit8_offset (val)
     bfd_vma val;
d2313 2
a2314 10
  valueT retval;
  if (lit8_sec == 0)
    {
      create_literal_section (&lit8_sec, ".lit8");
      lit8_sym = section_symbol (lit8_sec);
    }
  retval = add_to_literal_pool ((symbolS *) 0, val, lit8_sec, 8);
  if (retval >= 0xfff0)
    as_fatal ("overflow in fp literal (.lit8) table");
  return retval;
d2317 7
a2323 3
static valueT
get_lit4_offset (val)
     bfd_vma val;
d2325 6
a2330 10
  valueT retval;
  if (lit4_sec == 0)
    {
      create_literal_section (&lit4_sec, ".lit4");
      lit4_sym = section_symbol (lit4_sec);
    }
  retval = add_to_literal_pool ((symbolS *) 0, val, lit4_sec, 4);
  if (retval >= 0xfff0)
    as_fatal ("overflow in fp literal (.lit4) table");
  return retval;
d2333 1
a2333 1
static struct alpha_it clear_insn;
d2335 4
a2338 5
/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will
   need, that can be determined before arguments are parsed.  */
void
md_begin ()
d2340 11
a2350 2
  const char *retval, *name;
  unsigned int i = 0;
d2352 1
a2352 1
  op_hash = hash_new ();
d2354 4
a2357 7
  for (i = 0; i < NUMOPCODES; )
    {
      const char *name = alpha_opcodes[i].name;
      retval = hash_insert (op_hash, name, (PTR) &alpha_opcodes[i]);
      if (retval)
	as_fatal ("internal error: can't hash opcode `%s': %s",
		  name, retval);
d2359 1
a2359 13
      do
	i++;
      while (i < NUMOPCODES
	     && (alpha_opcodes[i].name == name
		 || !strcmp (alpha_opcodes[i].name, name)));
    }
  /* Some opcodes include modifiers of various sorts with a "/mod"
     syntax, like the architecture documentation suggests.  However,
     for use with gcc at least, we also need to access those same
     opcodes without the "/".  */
  for (i = 0; i < NUMOPCODES; )
    {
      name = alpha_opcodes[i].name;
d2361 4
a2364 5
      if (strchr (name, '/'))
	{
	  char *p = xmalloc (strlen (name));
	  const char *q = name;
	  char *q2 = p;
d2366 1
a2366 3
	  for (; *q; q++)
	    if (*q != '/')
	      *q2++ = *q;
d2368 3
a2370 7
	  *q2++ = 0;
	  retval = hash_insert (op_hash, p, (PTR) &alpha_opcodes[i]);
	  /* Ignore failures -- the opcode table does duplicate some
	     variants in different forms, like "hw_stq" and "hw_st/q".
	     Maybe the variants can be eliminated, and this error
	     checking restored.  */
	}
d2372 1
a2372 6
      do
	i++;
      while (i < NUMOPCODES
	     && (alpha_opcodes[i].name == name
		 || !strcmp (alpha_opcodes[i].name, name)));
    }
d2374 2
a2375 6
  lituse_basereg.X_op = O_constant;
  lituse_basereg.X_add_number = 1;
  lituse_byteoff.X_op = O_constant;
  lituse_byteoff.X_add_number = 2;
  lituse_jsr.X_op = O_constant;
  lituse_jsr.X_add_number = 3;
d2377 1
a2377 6
  /* So .sbss will get used for tiny objects.  */
  bfd_set_gp_size (stdoutput, 8);
  create_literal_section (&lita_sec, ".lita");
  /* For handling the GP, create a symbol that won't be output in the
     symbol table.  We'll edit it out of relocs later.  */
  gp = symbol_create ("<GP value>", lita_sec, 0x8000, &zero_address_frag);
d2379 3
a2381 3
  memset (&clear_insn, 0, sizeof (clear_insn));
  for (i = 0; i < MAX_RELOCS; i++)
    clear_insn.reloc[i].code = BFD_RELOC_NONE;
d2384 1
a2384 1
int optnum = 1;
d2387 4
a2390 2
emit_insn (insn)
     struct alpha_it *insn;
d2392 8
a2399 2
  char *toP;
  int j;
d2401 1
a2401 1
  toP = frag_more (4);
d2403 4
a2406 2
  /* put out the opcode */
  md_number_to_chars (toP, insn->opcode, 4);
d2408 17
a2424 5
  /* put out the symbol-dependent stuff */
  for (j = 0; j < MAX_RELOCS; j++)
    {
      struct reloc_data *r = &insn->reloc[j];
      fixS *f;
d2426 1
a2426 17
      if (r->code != BFD_RELOC_NONE)
	{
	  if (r->exp.X_op == O_constant)
	    {
	      r->exp.X_add_symbol = section_symbol (absolute_section);
	      r->exp.X_op = O_symbol;
	    }
	  f = fix_new_exp (frag_now, (toP - frag_now->fr_literal), 4,
			   &r->exp, r->pcrel, r->code);
	  if (r->code == BFD_RELOC_ALPHA_GPDISP_LO16)
	    {
	      static bit_fixS cookie;
	      /* @@@@ This'll make the range checking in write.c shut up.  */
	      f->fx_bit_fixP = &cookie;
	    }
	}
    }
d2428 3
a2430 2
  insn_label = NULL;
}
d2432 1
a2432 7
void
md_assemble (str)
     char *str;
{
  int i, count;
#define	MAX_INSNS	5
  struct alpha_it insns[MAX_INSNS];
d2434 3
a2436 3
  count = alpha_ip (str, insns);
  if (count <= 0)
    return;
d2438 1
a2438 3
  for (i = 0; i < count; i++)
    emit_insn (&insns[i]);
}
d2440 4
a2443 11
static inline void
maybe_set_gp (sec)
     asection *sec;
{
  bfd_vma vma;
  if (!sec)
    return;
  vma = bfd_get_section_vma (foo, sec);
  if (vma && vma < alpha_gp_value)
    alpha_gp_value = vma;
}
d2445 1
a2445 5
static void
select_gp_value ()
{
  if (alpha_gp_value != 0)
    abort ();
d2447 4
a2450 2
  /* Get minus-one in whatever width...  */
  alpha_gp_value = 0; alpha_gp_value--;
d2452 1
a2452 7
  /* Select the smallest VMA of these existing sections.  */
  maybe_set_gp (lita_sec);
/* maybe_set_gp (sdata);   Was disabled before -- should we use it?  */
#if 0
  maybe_set_gp (lit8_sec);
  maybe_set_gp (lit4_sec);
#endif
d2454 4
a2457 1
  alpha_gp_value += GP_ADJUSTMENT;
d2459 1
a2459 1
  S_SET_VALUE (gp, alpha_gp_value);
d2461 3
a2463 3
#ifdef DEBUG1
  printf ("Chose GP value of %lx\n", alpha_gp_value);
#endif
d2466 8
a2473 3
int
alpha_force_relocation (f)
     fixS *f;
d2475 9
a2483 22
  switch (f->fx_r_type)
    {
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_GPREL32:
      return 1;
    case BFD_RELOC_ALPHA_HINT:
    case BFD_RELOC_64:
    case BFD_RELOC_32:
    case BFD_RELOC_16:
    case BFD_RELOC_8:
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_14:
    case BFD_RELOC_26:
      return 0;
    default:
      abort ();
      return 0;
    }
}
d2485 1
a2485 18
int
alpha_fix_adjustable (f)
     fixS *f;
{
  /* Are there any relocation types for which we must generate a reloc
     but we can adjust the values contained within it?  */
  switch (f->fx_r_type)
    {
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
      return 0;
    case BFD_RELOC_GPREL32:
      return 1;
    default:
      return !alpha_force_relocation (f);
    }
  /*NOTREACHED*/
}
d2487 2
a2488 13
valueT
md_section_align (seg, size)
     segT seg;
     valueT size;
{
#ifdef OBJ_ECOFF
  /* This should probably be handled within BFD, or by pulling the
     number from BFD at least.  */
#define MIN 15
  size += MIN;
  size &= ~MIN;
#endif
  return size;
d2491 1
a2491 2
/* Add this thing to the .lita section and produce a LITERAL reloc referring
   to it.  */
d2493 1
a2493 3
/* Are we currently eligible to emit a LITUSE reloc for the literal
   references just generated?  */
static int lituse_pending;
d2495 8
a2502 4
static void
load_symbol_address (reg, insn)
     int reg;
     struct alpha_it *insn;
d2504 14
a2517 1
  static symbolS *lita_sym;
d2519 11
a2529 2
  int x;
  valueT retval;
d2531 2
a2532 1
  if (!lita_sym)
d2534 4
a2537 3
      lita_sym = section_symbol (lita_sec);
      S_CLEAR_EXTERNAL (lita_sym);
    }
d2539 3
a2541 3
  retval = add_to_literal_pool (insn->reloc[0].exp.X_add_symbol,
				insn->reloc[0].exp.X_add_number,
				lita_sec, 8);
d2543 3
a2545 6
  /* Now emit a LITERAL relocation for the original section.  */
  insn->reloc[0].exp.X_op = O_symbol;
  insn->reloc[0].exp.X_add_symbol = lita_sym;
  insn->reloc[0].exp.X_add_number = retval;
  insn->reloc[0].code = BFD_RELOC_ALPHA_LITERAL;
  lituse_pending = 1;
d2547 4
a2550 9
  if (retval == 0x8000)
    /* Overflow? */
    as_fatal ("overflow in literal (.lita) table");
  x = retval;
  if (addr32)
    insn->opcode = (0xa0000000	/* ldl */
		    | (reg << SA)
		    | (base_register << SB)
		    | (x & 0xffff));
d2552 7
a2558 6
    insn->opcode = (0xa4000000	/* ldq */
		    | (reg << SA)
		    | (base_register << SB)
		    | (x & 0xffff));
  note_gpreg (base_register);
}
d2560 6
a2565 7
/* To load an address with a single instruction,
   emit a LITERAL reloc in this section, and a REFQUAD
   for the .lita section, so that we'll be able to access
   it via $gp:
		lda REG, xx	->	ldq REG, -32752(gp)
		lda REG, xx+4	->	ldq REG, -32752(gp)
					lda REG, 4(REG)
d2567 7
a2573 3
   The offsets need to start near -0x8000, and the generated LITERAL
   relocations should negate the offset.  I don't completely grok the
   scheme yet.  */
d2575 1
a2575 7
static int
load_expression (reg, insn)
     int reg;
     struct alpha_it *insn;
{
  valueT addend, addendhi, addendlo;
  int num_insns = 1;
d2577 16
a2592 3
  if (insn->reloc[0].exp.X_add_symbol->bsym->flags & BSF_SECTION_SYM)
    {
      addend = 0;
d2594 33
d2628 6
d2635 16
a2650 2
      addend = insn->reloc[0].exp.X_add_number;
      insn->reloc[0].exp.X_add_number = 0;
d2652 1
a2652 2
  load_symbol_address (reg, insn);
  if (addend)
d2654 1
a2654 2
      if ((addend & ~0x7fffffff) != 0
	  && (addend & ~0x7fffffff) + 0x80000000 != 0)
d2656 3
a2658 2
	  as_bad ("assembler not prepared to handle constants >32 bits yet");
	  addend = 0;
d2660 2
a2661 8
      addendlo = addend & 0xffff;
      addend -= addendlo;
      addendhi = addend >> 16;
      if (addendlo & 0x8000)
	addendhi++;
      /* It appears that the BASEREG LITUSE reloc should not be used on
	 an LDAH instruction.  */
      if (addendlo)
d2663 3
a2665 7
	  insn[1].opcode = (0x20000000	/* lda */
			    | (reg << SA)
			    | (reg << SB)
			    | (addendlo & 0xffff));
	  insn[1].reloc[0].code = BFD_RELOC_ALPHA_LITUSE;
	  insn[1].reloc[0].exp = lituse_basereg;
	  num_insns++;
d2667 2
a2668 1
      if (addendhi)
d2670 3
a2672 5
	  insn[num_insns].opcode = (0x24000000
				    | (reg << SA)
				    | (reg << SB)
				    | (addendhi & 0xffff));
	  num_insns++;
a2673 3
      if (num_insns == 1)
	abort ();
      lituse_pending = 0;
d2675 24
a2698 1
  return num_insns;
d2701 11
a2711 4
static inline void
getExpression (str, this_insn)
     char *str;
     struct alpha_it *this_insn;
d2713 37
a2749 2
  char *save_in;
  segT seg;
d2751 5
a2755 35
#if 0 /* Not converted to bfd yet, and I don't think we need them
	 for ECOFF.  Re-adding a.out support will probably require
	 them though.  */
  static const struct am {
    char *name;
    bfd_reloc_code_real_type reloc;
  } macro[] = {
    { "hi", RELOC_48_63 },
    { "lo", RELOC_0_15 },
    { "ml", RELOC_16_31 },
    { "mh", RELOC_32_47 },
    { "uhi", RELOC_U_48_63 },
    { "uml", RELOC_U_16_31 },
    { "umh", RELOC_U_32_47 },
    { 0, }
  };

  /* Handle macros: "%macroname(expr)" */
  if (*str == '%')
    {
      struct am *m;
      char *p, *q;

      str++;
      m = &macro[0];
      while (q = m->name)
	{
	  p = str;
	  while (*q && *p == *q)
	    p++, q++;
	  if (*q == 0)
	    break;
	  m++;
	}
      if (q)
d2757 2
a2758 2
	  str = p;		/* keep the '(' */
	  this_insn->reloc = m->reloc;
d2760 4
a2764 1
#endif
d2766 1
a2766 2
  save_in = input_line_pointer;
  input_line_pointer = str;
d2768 10
a2777 4
  seg = expression (&this_insn->reloc[0].exp);
  /* XXX validate seg and exp, make sure they're reasonable */
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
d2780 3
d2784 4
a2787 4
emit_unaligned_io (dir, addr_reg, addr_offset, reg)
     char *dir;
     int addr_reg, reg;
     valueT addr_offset;
d2789 25
a2813 3
  char buf[90];
  sprintf (buf, "%sq_u $%d,%ld($%d)", dir, reg, (long) addr_offset, addr_reg);
  md_assemble (buf);
d2815 5
d2822 3
a2824 3
emit_load_unal (addr_reg, addr_offset, reg)
     int addr_reg, reg;
     valueT addr_offset;
d2826 8
a2833 2
  emit_unaligned_io ("ld", addr_reg, addr_offset, reg);
}
d2836 2
a2837 3
emit_store_unal (addr_reg, addr_offset, reg)
     int addr_reg, reg;
     valueT addr_offset;
d2839 9
a2847 2
  emit_unaligned_io ("st", addr_reg, addr_offset, reg);
}
d2850 2
a2851 3
emit_byte_manip_r (op, in, mask, out, mode, which)
     char *op;
     int in, mask, out, mode, which;
d2853 79
a2931 3
  char buf[90];
  sprintf (buf, "%s%c%c $%d,$%d,$%d", op, mode, which, in, mask, out);
  md_assemble (buf);
d2934 7
d2942 2
a2943 2
emit_extract_r (in, mask, out, mode, which)
     int in, mask, out, mode, which;
d2945 8
a2952 1
  emit_byte_manip_r ("ext", in, mask, out, mode, which);
d2955 7
d2963 2
a2964 2
emit_insert_r (in, mask, out, mode, which)
     int in, mask, out, mode, which;
d2966 8
a2973 1
  emit_byte_manip_r ("ins", in, mask, out, mode, which);
d2975 3
d2979 6
a2984 3
static void
emit_mask_r (in, mask, out, mode, which)
     int in, mask, out, mode, which;
d2986 5
a2990 1
  emit_byte_manip_r ("msk", in, mask, out, mode, which);
d2993 3
d2997 2
a2998 2
emit_sign_extend (reg, size)
     int reg, size;
d3000 8
a3007 5
  char buf[90];
  sprintf (buf, "sll $%d,0x%x,$%d", reg, 64 - size, reg);
  md_assemble (buf);
  sprintf (buf, "sra $%d,0x%x,$%d", reg, 64 - size, reg);
  md_assemble (buf);
d3010 3
d3014 2
a3015 2
emit_bis_r (in1, in2, out)
     int in1, in2, out;
d3017 3
a3019 3
  char buf[90];
  sprintf (buf, "bis $%d,$%d,$%d", in1, in2, out);
  md_assemble (buf);
a3021 10
static int
build_mem (opc, ra, rb, disp)
     int opc, ra, rb;
     bfd_signed_vma disp;
{
  if ((disp >> 15) != 0
      && (disp >> 15) + 1 != 0)
    abort ();
  return ((opc << 26) | (ra << SA) | (rb << SB) | (disp & 0xffff));
}
d3023 1
a3023 9
static int
build_operate_n (opc, fn, ra, lit, rc)
     int opc, fn, ra, rc;
     int lit;
{
  if (lit & ~0xff)
    abort ();
  return ((opc << 26) | (fn << 5) | (ra << SA) | (lit << SN) | (1 << 12) | (rc << SC));
}
d3026 2
a3027 2
emit_sll_n (dest, disp, src)
     int dest, disp, src;
d3029 29
a3057 3
  struct alpha_it insn = clear_insn;
  insn.opcode = build_operate_n (0x12, 0x39, src, disp, dest);
  emit_insn (&insn);
d3060 3
d3064 2
a3065 3
emit_ldah_num (dest, addend, src)
     int dest, src;
     bfd_vma addend;
d3067 28
a3094 3
  struct alpha_it insn = clear_insn;
  insn.opcode = build_mem (0x09, dest, src, addend);
  emit_insn (&insn);
d3098 2
a3099 2
emit_addq_r (in1, in2, out)
     int in1, in2, out;
d3101 15
a3115 4
  struct alpha_it insn = clear_insn;
  insn.opcode = 0x40000400 | (in1 << SA) | (in2 << SB) | (out << SC);
  emit_insn (&insn);
}
d3117 7
a3123 9
static void
emit_lda_n (dest, addend, src)
     int dest, src;
     bfd_vma addend;
{
  struct alpha_it insn = clear_insn;
  insn.opcode = build_mem (0x08, dest, src, addend);
  emit_insn (&insn);
}
d3125 1
a3125 6
static void
emit_add64 (in, out, num)
     int in, out;
     bfd_vma num;
{
  bfd_signed_vma snum = num;
d3127 2
a3128 1
  if (in_range_signed (num, 16))
d3130 2
a3131 1
      emit_lda_n (out, num, in);
d3134 7
a3140 3
  if ((num & 0xffff) == 0
      && in == ZERO
      && in_range_signed (snum >> 16, 16))
d3142 2
a3143 1
      emit_ldah_num (out, snum >> 16, in);
d3146 10
a3155 2
  /* I'm not sure this one is getting invoked when it could.  */
  if ((num & 1) == 0 && in == ZERO)
d3157 1
a3157 13
      if (in_range_signed (snum >> 1, 16))
	{
	  emit_lda_n (out, snum >> 1, in);
	  emit_addq_r (out, out, out);
	  return;
	}
      else if (num & 0x1fffe == 0
	       && in_range_signed (snum >> 17, 16))
	{
	  emit_ldah_num (out, snum >> 17, in);
	  emit_addq_r (out, out, out);
	  return;
	}
d3159 1
a3159 1
  if (in_range_signed (num, 32))
d3161 1
a3161 8
      bfd_vma lo = num & 0xffff;
      if (lo & 0x8000)
	lo -= 0x10000;
      num -= lo;
      emit_ldah_num (out, snum >> 16, in);
      if (lo)
	emit_lda_n (out, lo, out);
      return;
d3163 1
a3163 2

  if (in != ZERO && in != AT && out != AT && at_ok)
d3165 2
a3166 2
      emit_add64 (ZERO, AT, num);
      emit_addq_r (AT, in, out);
d3170 2
a3171 2
  if (in != ZERO)
    as_bad ("load expression too complex to expand");
d3173 3
a3175 2
  /* Could check also for loading 16- or 32-bit value and shifting by
     arbitrary displacement.  */
d3177 30
a3206 11
  {
    bfd_vma lo = snum & 0xffffffff;
    if (lo & 0x80000000)
      lo -= ((bfd_vma)0x10000000 << 4);
    snum -= lo;
    emit_add64 (ZERO, out, snum >> 32);
    emit_sll_n (out, 32, out);
    if (lo != 0)
      emit_add64 (out, out, lo);
  }
}
d3208 2
a3209 24
static int
alpha_ip (str, insns)
     char *str;
     struct alpha_it insns[];
{
  char *s;
  const char *args;
  char c;
  unsigned long i;
  struct alpha_opcode *pattern;
  char *argsStart;
  unsigned int opcode;
  unsigned int mask = 0;
  int match = 0, num_gen = 1;
  int comma = 0;
  int do_add64, add64_in = 0, add64_out = 0;
  bfd_vma add64_addend = 0;

  for (s = str;
       islower (*s) || *s == '_' || *s == '/' || *s == '4' || *s == '8';
       ++s)
    ;
  switch (*s)
    {
d3211 1
a3211 2
    case '\0':
      break;
d3213 2
a3214 2
    case ',':
      comma = 1;
d3216 5
a3220 1
      /*FALLTHROUGH*/
d3222 2
a3223 3
    case ' ':
      *s++ = '\0';
      break;
d3225 1
a3225 10
    default:
      as_fatal ("Unknown opcode: `%s'", str);
    }
  if ((pattern = (struct alpha_opcode *) hash_find (op_hash, str)) == NULL)
    {
      as_bad ("Unknown opcode: `%s'", str);
      return -1;
    }
  if (comma)
    *--s = ',';
d3227 2
a3228 8
  argsStart = s;
  for (;;)
    {
      do_add64 = 0;
      opcode = pattern->match;
      num_gen = 1;
      for (i = 0; i < MAX_INSNS; i++)
	insns[i] = clear_insn;
d3230 2
a3231 6
      /* Build the opcode, checking as we go to make sure that the
	 operands match.  */
      for (args = pattern->args;; ++args)
	{
	  switch (*args)
	    {
d3233 5
a3237 6
	    case '\0':		/* end of args */
	      if (*s == '\0')
		{
		  match = 1;
		}
	      break;
d3239 1
a3239 11
	    case '+':
	      if (*s == '+')
		{
		  ++s;
		  continue;
		}
	      if (*s == '-')
		{
		  continue;
		}
	      break;
d3241 2
a3242 8
	    case '(':		/* these must match exactly */
	    case ')':
	    case ',':
	    case ' ':
	    case '0':
	      if (*s++ == *args)
		continue;
	      break;
d3244 2
a3245 9
	    case '1':		/* next operand must be a register */
	    case '2':
	    case '3':
	    case 'r':
	    case 'R':
	      if (*s++ == '$')
		{
		  switch (c = *s++)
		    {
a3246 91
		    case 'a':	/* $at: as temporary */
		      if (*s++ != 't')
			goto error;
		      mask = AT;
		      break;

		    case 'g':	/* $gp: base register */
		      if (*s++ != 'p')
			goto error;
		      mask = base_register;
		      break;

		    case 's':	/* $sp: stack pointer */
		      if (*s++ != 'p')
			goto error;
		      mask = SP;
		      break;


		    case 'r':	/* any register */
		      if (!isdigit (c = *s++))
			{
			  goto error;
			}
		      /* FALLTHROUGH */
		    case '0':
		    case '1':
		    case '2':
		    case '3':
		    case '4':
		    case '5':
		    case '6':
		    case '7':
		    case '8':
		    case '9':
		      if (isdigit (*s))
			{
			  if ((c = 10 * (c - '0') + (*s++ - '0')) >= 32)
			    {
			      goto error;
			    }
			}
		      else
			{
			  c -= '0';
			}
		      if ((c == GP) && first_32bit_quadrant)
			c = ZERO;

		      mask = c;
		      break;

		    default:
		      goto error;
		    }
		  note_gpreg (mask);
		  /* Got the register, now figure out where it goes in
		     the opcode.  */
		doregister:
		  switch (*args)
		    {

		    case '1':
		    case 'e':
		      opcode |= mask << SA;
		      continue;

		    case '2':
		    case 'f':
		      opcode |= mask << SB;
		      continue;

		    case '3':
		    case 'g':
		      opcode |= mask;
		      continue;

		    case 'r':
		      opcode |= (mask << SA) | mask;
		      continue;

		    case 'R':	/* ra and rb are the same */
		      opcode |= (mask << SA) | (mask << SB);
		      continue;

		    case 'E':
		      opcode |= (mask << SA) | (mask << SB) | (mask);
		      continue;
		    }
		}
	      break;
d3248 6
a3253 24
	    case 'e':		/* next operand is a floating point register */
	    case 'f':
	    case 'g':
	    case 'E':
	      if (*s++ == '$' && *s++ == 'f' && isdigit (*s))
		{
		  mask = *s++;
		  if (isdigit (*s))
		    {
		      mask = 10 * (mask - '0') + (*s++ - '0');
		      if (mask >= 32)
			{
			  break;
			}
		    }
		  else
		    {
		      mask -= '0';
		    }
		  note_fpreg (mask);
		  /* same encoding as gp registers */
		  goto doregister;
		}
	      break;
d3255 3
a3257 32
#if 0
	    case 'h':		/* bits 16..31 */
	      insns[0].reloc = RELOC_16_31;
	      goto immediate;
#endif

	    case 'l':		/* bits 0..15 */
	      insns[0].reloc[0].code = BFD_RELOC_16;
	      goto immediate;

	    case 'L':		/* 21 bit PC relative immediate */
	      insns[0].reloc[0].code = BFD_RELOC_23_PCREL_S2;
	      insns[0].reloc[0].pcrel = 1;
	      goto immediate;

	    case 'i':		/* 14 bit immediate */
	      if (OPCODE (opcode) != 0x1a)
		/* Not a jmp variant?? */
		abort ();
	      else if (opcode & 0x8000)
		/* ret or jsr_coroutine */
		{
		  insns[0].reloc[0].code = BFD_RELOC_14;
		  insns[0].reloc[0].pcrel = 0;
		}
	      else
		/* jmp or jsr */
		{
		  insns[0].reloc[0].code = BFD_RELOC_ALPHA_HINT;
		  insns[0].reloc[0].pcrel = 1;
		}
	      goto immediate;
d3259 13
a3271 103
	    case 'b':		/* 8 bit immediate */
	      insns[0].reloc[0].code = BFD_RELOC_8;
	      goto immediate;

	    case 'I':		/* 26 bit immediate, for PALcode */
	      insns[0].reloc[0].code = BFD_RELOC_26;
	      goto immediate;

	    case 't':		/* 12 bit displacement, for PALcode */
	      insns[0].reloc[0].code = BFD_RELOC_12_PCREL;
	      goto immediate;

	    case '8':		/* 8 bit 0...7 */
	      insns[0].reloc[0].code = BFD_RELOC_8;
	      goto immediate;

	    immediate:
	      if (*s == ' ')
		s++;
	      getExpression (s, &insns[0]);
	      s = expr_end;
	      /* Handle overflow in certain instructions by converting
		 to other instructions.  */
	      if (insns[0].reloc[0].code == BFD_RELOC_8
		  && insns[0].reloc[0].exp.X_op == O_constant
		  && (insns[0].reloc[0].exp.X_add_number < 0
		      || insns[0].reloc[0].exp.X_add_number > 0xff))
		{
		  if (OPCODE (opcode) == 0x10
		      && (OP_FCN (opcode) == 0x00	/* addl */
			  || OP_FCN (opcode) == 0x40	/* addl/v */
			  || OP_FCN (opcode) == 0x20	/* addq */
			  || OP_FCN (opcode) == 0x60	/* addq/v */
			  || OP_FCN (opcode) == 0x09	/* subl */
			  || OP_FCN (opcode) == 0x49	/* subl/v */
			  || OP_FCN (opcode) == 0x29	/* subq */
			  || OP_FCN (opcode) == 0x69	/* subq/v */
			  || OP_FCN (opcode) == 0x02	/* s4addl */
			  || OP_FCN (opcode) == 0x22	/* s4addq */
			  || OP_FCN (opcode) == 0x0b	/* s4subl */
			  || OP_FCN (opcode) == 0x2b	/* s4subq */
			  || OP_FCN (opcode) == 0x12	/* s8addl */
			  || OP_FCN (opcode) == 0x32	/* s8addq */
			  || OP_FCN (opcode) == 0x1b	/* s8subl */
			  || OP_FCN (opcode) == 0x3b	/* s8subq */
		      )
		      /* Can we make it fit by negating?  */
		      && -insns[0].reloc[0].exp.X_add_number < 0xff
		      && -insns[0].reloc[0].exp.X_add_number > 0)
		    {
		      opcode ^= 0x120;	/* convert add<=>sub */
		      insns[0].reloc[0].exp.X_add_number *= -1;
		    }
		  else if (at_ok && macro_ok)
		    {
		      /* Constant value supplied, but it's too large.  */
		      do_add64 = 1;
		      add64_in = ZERO;
		      add64_out = AT;
		      add64_addend = insns[0].reloc[0].exp.X_add_number;
		      opcode &= ~ 0x1000;
		      opcode |= (AT << SB);
		      insns[0].reloc[0].code = BFD_RELOC_NONE;
		    }
		  else
		    as_bad ("overflow in 8-bit literal field in `operate' format insn");
		}
	      else if (insns[0].reloc[0].code == BFD_RELOC_16
		       && insns[0].reloc[0].exp.X_op == O_constant
		       && !in_range_signed (insns[0].reloc[0].exp.X_add_number,
					    16))
		{
		  bfd_vma val = insns[0].reloc[0].exp.X_add_number;
		  if (OPCODE (opcode) == 0x08)
		    {
		      do_add64 = 1;
		      add64_in = ZERO;
		      add64_out = AT;
		      add64_addend = val;
		      opcode &= ~0x1000;
		      opcode |= (AT << SB);
		      insns[0].reloc[0].code = BFD_RELOC_NONE;
		    }
		  else if (OPCODE (opcode) == 0x09
			   && in_range_signed (val >> 16, 16))
		    {
		      /* ldah with high operand - convert to low */
		      insns[0].reloc[0].exp.X_add_number >>= 16;
		    }
		  else
		    as_bad ("I don't know how to handle 32+ bit constants here yet, sorry.");
		}
	      else if (insns[0].reloc[0].code == BFD_RELOC_32
		       && insns[0].reloc[0].exp.X_op == O_constant)
		{
		  bfd_vma val = insns[0].reloc[0].exp.X_add_number;
		  bfd_signed_vma sval = val;
		  if (val >> 32 != 0
		      && sval >> 32 != 0
		      && sval >> 32 != -1)
		    as_bad ("I don't know how to handle 64 bit constants here yet, sorry.");
		}
	      continue;
d3273 2
a3274 57
	    case 'F':
	      {
		int format, length, mode, i;
		char temp[20 /*MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT*/];
		char *err;
		static const char formats[4] = "FGfd";
		bfd_vma bits, offset;
		char *old_input_line_pointer = input_line_pointer;

		input_line_pointer = s;
		SKIP_WHITESPACE ();
		memset (temp, 0, sizeof (temp));
		mode = (opcode >> 26) & 3;
		format = formats[mode];
		err = md_atof (format, temp, &length);
		if (err)
		  {
		    as_bad ("Bad floating literal: %s", err);
		    bits = 0;
		  }
		else
		  {
		    /* Generate little-endian number from byte sequence.  */
		    bits = 0;
		    for (i = length - 1; i >= 0; i--)
		      bits += ((bfd_vma)(temp[i] & 0xff)) << (i * 8);
		  }
		switch (length)
		  {
		  case 8:
		    offset = get_lit8_offset (bits) - 0x8000;
		    insns[0].reloc[0].exp.X_add_symbol = lit8_sym;
		    insns[0].reloc[0].exp.X_add_number = 0x8000;
		    break;
		  case 4:
		    offset = get_lit4_offset (bits) - 0x8000;
		    insns[0].reloc[0].exp.X_add_symbol = lit4_sym;
		    insns[0].reloc[0].exp.X_add_number = 0x8000;
		    break;
		  default:
		    abort ();
		  }
		insns[0].reloc[0].exp.X_op = O_symbol;
		offset &= 0xffff;
		num_gen = load_expression (AT, &insns[0]);
		if (lituse_pending)
		  {
		    insns[num_gen].reloc[0].code = BFD_RELOC_ALPHA_LITUSE;
		    insns[num_gen].reloc[0].exp = lituse_basereg;
		    lituse_pending = 0;
		  }
		insns[num_gen++].opcode = opcode | (AT << SB) | offset;
		opcode = insns[0].opcode;
		s = input_line_pointer;
		input_line_pointer = old_input_line_pointer;
	      }
	      continue;
a3275 22
	      /* The following two.. take advantage of the fact that
	         opcode already contains most of what we need to know.
	         We just prepend to the instr an "ldah
	         $r,%ml(expr)($base)" and turn this one (done later
	         after we return) into something like "stq
	         $r,%lo(expr)(at)" or "ldq $r,%lo(expr)($r)".

		 NOTE: This can fail later on at link time if the
		 offset from $base actually turns out to be more than
		 2**31 or 2**47 if use_large_offsets is set.  */
	    case 'P':		/* Addressing macros: PUT */
	      mask = AT;	/* register 'at' */
	      /* fall through */

	    case 'G':		/* Addressing macros: GET */
	      /* All it is missing is the expression, which is what we
		 will get now */

	      if (*s == ' ')
		s++;
	      getExpression (s, &insns[0]);
	      s = expr_end;
d3277 4
a3280 10
	      /* Must check for "lda ..,number" too */
	      if (insns[0].reloc[0].exp.X_op == O_big)
		{
		  as_warn ("Sorry, not yet. Put bignums in .data section yourself.");
		  return -1;
		}
	      if (insns[0].reloc[0].exp.X_op == O_constant)
		{
		  bfd_vma val = insns[0].reloc[0].exp.X_add_number;
		  bfd_vma top, low;
d3282 1
a3282 2
		  insns[0].reloc[0].code = BFD_RELOC_NONE;
		  insns[1].reloc[0].code = BFD_RELOC_NONE;
d3284 3
a3286 21
		  low = val & 0xffff;
		  if (low & 0x8000)
		    low -= 0x10000;
		  top = val - low;
		  if (top)
		    {
		      do_add64 = 1;
		      add64_in = ZERO;
		      add64_out = AT;
		      add64_addend = top;
		      opcode |= AT << SB;
		    }
		  else
		    opcode |= ZERO << SB;
		  opcode &= ~0x1000;
		  opcode |= low & 0xffff;
		}
	      else if (insns[0].reloc[0].exp.X_op == O_symbol)
		{
		  unsigned long old_opcode = opcode;
		  int tmp_reg = -1;
a3287 34
		  if (!macro_ok)
		    as_bad ("insn requires expansion but `nomacro' specified");
		  else if (*args == 'G')
		    tmp_reg = mask;
		  else if (!at_ok)
		    as_bad ("insn expansion requires AT use, but `noat' specified");
		  else
		    tmp_reg = AT;
		  num_gen = load_expression (tmp_reg, insns);
		  opcode = insns[0].opcode;
		  /* lda is opcode 8, 0x20000000, and the macros that use
		     this code have an opcode field of 0.  The latter
		     require further processing, and we don't have the
		     true opcode here.  */
		  if (OPCODE (old_opcode) != 0
		      && OPCODE (old_opcode) != 0x08)
		    {
		      struct alpha_it *i;
		      i = &insns[num_gen++];
		      i->opcode = old_opcode | (tmp_reg << SB);

		      if (lituse_pending)
			{
			  i->reloc[0].code = BFD_RELOC_ALPHA_LITUSE;
			  i->reloc[0].exp = lituse_basereg;
			  lituse_pending = 0;
			}
		    }
		}
	      else
		{
		  /* Not a number */
		  num_gen = 2;
		  insns[1].reloc[0].exp = insns[0].reloc[0].exp;
d3289 5
a3293 1
		  /* Generate: ldah REG,x1(GP); OP ?,x0(REG) */
d3295 11
a3305 4
		  abort ();	/* relocs need fixing */
#if 0
		  insns[1].reloc = RELOC_0_15;
		  insns[1].opcode = opcode | mask << SB;
d3307 2
a3308 4
		  insns[0].reloc = RELOC_16_31;
		  opcode = 0x24000000 /*ldah*/  | mask << SA | (base_register << SB);
#endif
		}
a3309 1
	      continue;
d3311 5
a3315 6
	      /* Same failure modes as above, actually most of the
		 same code shared.  */
	    case 'B':		/* Builtins */
	      args++;
	      switch (*args)
		{
d3317 4
a3320 398
		case 'a':	/* ldgp */

		  if (first_32bit_quadrant || no_mixed_code)
		    return -1;
		  switch (OUTPUT_FLAVOR)
		    {
		    case bfd_target_aout_flavour:
		      /* this is cmu's a.out version */
		      insns[0].reloc[0].code = BFD_RELOC_NONE;
		      /* generate "zap %r,0xf,%r" to take high 32 bits */
		      opcode |= 0x48001600 /* zap ?,#,?*/  | (0xf << SN);
		      break;
		    case bfd_target_ecoff_flavour:
		      /* Given "ldgp R1,N(R2)", turn it into something
			 like "ldah R1,###(R2) ; lda R1,###(R1)" with
			 appropriate constants and relocations.  */
		      {
			unsigned long r1, r2;
			unsigned long addend = 0;

			num_gen = 2;
			r2 = mask;
			r1 = opcode & 0x3f;
			insns[0].reloc[0].code = BFD_RELOC_ALPHA_GPDISP_HI16;
			insns[0].reloc[0].pcrel = 1;
			insns[0].reloc[0].exp.X_op = O_symbol;
			insns[0].reloc[0].exp.X_add_symbol = gp;
			insns[0].reloc[0].exp.X_add_number = 0;
			insns[0].opcode = (0x24000000	/* ldah */
					   | (r1 << SA)
					   | (r2 << SB));
			insns[1].reloc[0].code = BFD_RELOC_ALPHA_GPDISP_LO16;
			insns[1].reloc[0].exp.X_op = O_symbol;
			insns[1].reloc[0].exp.X_add_symbol = gp;
			insns[1].reloc[0].exp.X_add_number = 4;
			insns[1].reloc[0].pcrel = 1;
			insns[1].opcode = 0x20000000 | (r1 << SA) | (r1 << SB);
			opcode = insns[0].opcode;
			/* merge in addend */
			insns[1].opcode |= addend & 0xffff;
			insns[0].opcode |= ((addend >> 16)
					    + (addend & 0x8000 ? 1 : 0));
			if (r2 == PV)
			  ecoff_set_gp_prolog_size (0);
		      }
		      break;
		    default:
		      abort ();
		    }
		  continue;


		case 'b':	/* setgp */
		  switch (OUTPUT_FLAVOR)
		    {
		    case bfd_target_aout_flavour:
		      /* generate "zap %r,0xf,$gp" to take high 32 bits */
		      opcode |= 0x48001600	/* zap ?,#,?*/
			| (0xf << SN) | (base_register);
		      break;
		    default:
		      abort ();
		    }
		  continue;

		case 'c':	/* jsr $r,foo  becomes
					lda $27,foo
					jsr $r,($27),foo
				   Register 27, t12, is used by convention
				   here.  */
		  {
		    struct alpha_it *jsr;
		    expressionS etmp;
		    struct reloc_data *r;

		    /* We still have to parse the function name */
		    if (*s == ' ')
		      s++;
		    getExpression (s, &insns[0]);
		    etmp = insns[0].reloc[0].exp;
		    s = expr_end;
		    num_gen = load_expression (PV, &insns[0]);
		    note_gpreg (PV);

		    jsr = &insns[num_gen++];
		    jsr->opcode = (pattern->match
				   | (mask << SA)
				   | (PV << SB)
				   | 0);
		    if (lituse_pending)
		      {
			/* LITUSE wasn't emitted yet */
			jsr->reloc[0].code = BFD_RELOC_ALPHA_LITUSE;
			jsr->reloc[0].exp = lituse_jsr;
			r = &jsr->reloc[1];
			lituse_pending = 0;
		      }
		    else
		      r = &jsr->reloc[0];
		    r->exp = etmp;
		    r->code = BFD_RELOC_ALPHA_HINT;
		    r->pcrel = 1;
		    opcode = insns[0].opcode;
		  }
		  continue;

		case 'd':
		  /* Sub-word loads and stores.  We load the address into
		     $at, which might involve using the `P' parameter
		     processing too, then emit a sequence to get the job
		     done, using unaligned memory accesses and byte
		     manipulation, with t9 and t10 as temporaries.  */
		  {
		    /* Characteristics of access.  */
		    int is_load = 99, is_unsigned = 0, is_unaligned = 0;
		    int mode_size, mode;
		    /* Register operand.  */
		    int reg = -1;
		    /* Addend for loads and stores.  */
		    valueT addend;
		    /* Which register do we use for the address?  */
		    int addr;

		    {
		      /* Pick apart name and set flags.  */
		      const char *s = pattern->name;

		      if (*s == 'u')
			{
			  is_unaligned = 1;
			  s++;
			}

		      if (s[0] == 'l' && s[1] == 'd')
			is_load = 1;
		      else if (s[0] == 's' && s[1] == 't')
			is_load = 0;
		      else
			as_fatal ("unrecognized sub-word access insn `%s'",
				  str);
		      s += 2;

		      mode = *s++;
		      if (mode == 'b') mode_size = 1;
		      else if (mode == 'w') mode_size = 2;
		      else if (mode == 'l') mode_size = 4;
		      else if (mode == 'q') mode_size = 8;
		      else abort ();

		      if (*s == 'u')
			{
			  is_unsigned = 1;
			  s++;
			}

		      assert (*s == 0);

		      /* Longwords are always kept sign-extended.  */
		      if (mode == 'l' && is_unsigned)
			abort ();
		      /* There's no special unaligned byte handling.  */
		      if (mode == 'b' && is_unaligned)
			abort ();
		      /* Stores don't care about signedness.  */
		      if (!is_load && is_unsigned)
			abort ();
		    }

		    if (args[-2] == 'P')
		      {
			addr = AT;
			addend = 0;
		      }
		    else
		      {
			/* foo r1,num(r2)
			   r2 -> mask
			   r1 -> (opcode >> SA) & 31
			   num -> insns->reloc[0].*

			   We want to emit "lda at,num(r2)", since these
			   operations require the use of a single register
			   with the starting address of the memory operand
			   we want to access.

			   We could probably get away without doing this
			   (and use r2 below, with the addend for the
			   actual reads and writes) in cases where the
			   addend is known to be a multiple of 8.  */
			int r2 = mask;
			int r1 = (opcode >> SA) & 31;

			if (insns[0].reloc[0].code == BFD_RELOC_NONE)
			  addend = 0;
			else if (insns[0].reloc[0].code == BFD_RELOC_16)
			  {
			    if (insns[0].reloc[0].exp.X_op != O_constant)
			      abort ();
			    addend = insns[0].reloc[0].exp.X_add_number;
			  }
			else
			  abort ();

			if (addend + mode_size - 1 < 0x7fff
			    && (addend % 8) == 0
			    && (r2 < T9 || r2 > T12))
			  {
			    addr = r2;
			    num_gen = 0;
			  }
			else
			  {
			    /* Let later relocation processing deal
			       with the addend field.  */
			    insns[num_gen-1].opcode = (0x20000000 /* lda */
						       | (AT << SA)
						       | (r2 << SB));
			    addr = AT;
			    addend = 0;
			  }
			reg = r1;
		      }

		    /* Because the emit_* routines append directly to
		       the current frag, we now need to flush any
		       pending insns.  */
		    {
		      int i;
		      for (i = 0; i < num_gen; i++)
			emit_insn (&insns[i]);
		      num_gen = 0;
		    }

		    if (is_load)
		      {
			int reg2, reg3 = -1;

			if (is_unaligned)
			  reg2 = T9, reg3 = T10;
			else
			  reg2 = reg;

			emit_load_unal (addr, addend, T9);
			if (is_unaligned)
			  emit_load_unal (addr, addend + mode_size - 1, T10);
			emit_extract_r (T9, addr, reg2, mode, 'l');
			if (is_unaligned)
			  {
			    emit_extract_r (T10, addr, reg3, mode, 'h');
			    emit_bis_r (T9, T10, reg);
			  }
			if (!is_unsigned)
			  emit_sign_extend (reg, mode_size * 8);
		      }
		    else
		      {
			/* The second word gets processed first
			   because if the address does turn out to be
			   aligned, the processing for the second word
			   will be pushing around all-zeros, and the
			   entire value will be handled as the `first'
			   word.  So we want to store the `first' word
			   last.  */
			/* Pair these up so that the memory loads get
			   separated from each other, as well as being
			   well in advance of the uses of the values
			   loaded.  */
			if (is_unaligned)
			  {
			    emit_load_unal (addr, addend + mode_size - 1, T11);
			    emit_insert_r (reg, addr, T12, mode, 'h');
			  }
			emit_load_unal (addr, addend, T9);
			emit_insert_r (reg, addr, T10, mode, 'l');
			if (is_unaligned)
			  emit_mask_r (T12, addr, T12, mode, 'h');
			emit_mask_r (T10, addr, T10, mode, 'l');
			if (is_unaligned)
			  emit_bis_r (T11, T12, T11);
			emit_bis_r (T9, T10, T9);
			if (is_unaligned)
			  emit_store_unal (addr, addend + mode_size - 1, T11);
			emit_store_unal (addr, addend, T9);
		      }
		  }
		  return 0;

		  /* DIVISION and MODULUS. Yech.
		       Convert	OP x,y,result
		       to	mov x,t10
				mov y,t11
				jsr t9, __OP
				mov t12,result

		       with appropriate optimizations if t10,t11,t12
		       are the registers specified by the compiler.
		       We are missing an obvious optimization
		       opportunity here; if the ldq generated by the
		       jsr assembly requires a cycle or two to make
		       the value available, initiating it before one
		       or two of the mov instructions would result in
		       faster execution.  */
		case '0':	/* reml */
		case '1':	/* divl */
		case '2':	/* remq */
		case '3':	/* divq */
		case '4':	/* remlu */
		case '5':	/* divlu */
		case '6':	/* remqu */
		case '7':	/* divqu */
		  {
		    static char func[8][6] = {
		      "reml", "divl", "remq", "divq",
		      "remlu", "divlu", "remqu", "divqu"
		    };
		    char expansion[64];
		    int reg;

		    /* All regs parsed, in opcode */

		    /* Do the expansions, one instr at a time */

		    reg = (opcode >> SA) & 31;
		    if (reg != T10)
		      {
			/* x->t10 */
			sprintf (expansion, "mov $%d,$%d", reg, T10);
			md_assemble (expansion);
		      }
		    reg = (opcode >> SB) & 31;
		    if (reg == T10)
		      /* we already overwrote it! */
		      abort ();
		    else if (reg != T11)
		      {
			/* y->t11 */
			sprintf (expansion, "mov $%d,$%d", reg, T11);
			md_assemble (expansion);
		      }
		    sprintf (expansion, "lda $%d,__%s", PV, func[*args - '0']);
		    md_assemble (expansion);
		    sprintf (expansion, "jsr $%d,($%d),__%s", T9, PV,
			     func[*args - '0']);
		    md_assemble (expansion);
#if 0 /* huh? */
		    if (!first_32bit_quadrant)
		      {
			sprintf (expansion,
				 "zap $%d,0xf,$%d",
				 T9, base_register);
			md_assemble (expansion);
		      }
#endif
		    sprintf (expansion, "ldgp $%d,0($%d)",
			     base_register, T9);
		    md_assemble (expansion);

		    /* Use insns[0] to get at the result */
		    if ((reg = (opcode & 31)) != PV)
		      opcode = (0x47e00400	/* or zero,zero,zero */
				| (PV << SB)
				| reg /* Rc */ );	/* pv->z */
		    else
		      num_gen = 0;
		  }
		  continue;
		}
	      /* fall through */

	    default:
	      abort ();
	    }
	  break;
	}
    error:
      if (match == 0)
	{
	  /* Args don't match.  */
	  if (&pattern[1] - alpha_opcodes < NUMOPCODES
	      && !strcmp (pattern->name, pattern[1].name))
	    {
	      ++pattern;
	      s = argsStart;
	      continue;
	    }
	  else
	    {
	      as_warn ("Illegal operands");
	      return -1;
	    }
	}
      else
	{
	  /* Args match, see if a float instructions and -nofloats */
	  if (nofloats && pattern->isa_float)
	    return -1;
	}
      break;
d3322 1
a3322 2

  if (do_add64)
d3324 2
a3325 17
      /* If opcode represents an addq instruction, and the addend we
         are using fits in a 16 bit range, we can change the addq
         directly into an lda rather than emitting an lda followed by
         an addq.  */
      if (OPCODE (opcode) == 0x10
	  && OP_FCN (opcode) == 0x20	/* addq */
	  && add64_in == ZERO
	  && add64_out == AT
	  && in_range_signed (add64_addend, 16))
	{
	  opcode = (0x20000000	/* lda */
		    | (((opcode >> SC) & 0x1f) << SA)
		    | (((opcode >> SA) & 0x1f) << SB)
		    | (add64_addend & 0xffff));
	}
      else
	emit_add64 (add64_in, add64_out, add64_addend);
d3327 1
d3329 1
a3329 2
  insns[0].opcode = opcode;
  return num_gen;
d3332 13
a3344 4
/* Turn a string in input_line_pointer into a floating point constant
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP.  An error message is
   returned, or NULL on OK.  */
a3345 2
/* Equal to MAX_PRECISION in atof-ieee.c */
#define MAX_LITTLENUMS 6
d3347 3
a3349 5
char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d3351 7
a3357 5
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;
  char *atof_ieee (), *vax_md_atof ();
d3359 3
a3361 9
  switch (type)
    {
      /* VAX floats */
    case 'G':
      /* VAX md_atof doesn't like "G" for some reason.  */
      type = 'g';
    case 'F':
    case 'D':
      return vax_md_atof (type, litP, sizeP);
d3363 1
a3363 4
      /* IEEE floats */
    case 'f':
      prec = 2;
      break;
d3365 6
a3370 3
    case 'd':
      prec = 4;
      break;
d3372 2
a3373 4
    case 'x':
    case 'X':
      prec = 6;
      break;
d3375 8
a3382 3
    case 'p':
    case 'P':
      prec = 6;
a3383 1

d3385 1
a3385 2
      *sizeP = 0;
      return "Bad call to MD_ATOF()";
d3387 3
a3389 6
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words + prec - 1; prec--;)
d3391 9
a3399 2
      md_number_to_chars (litP, (long) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
d3401 8
d3410 4
a3413 1
  return 0;
d3416 7
a3422 5
void
md_bignum_to_chars (buf, bignum, nchars)
     char *buf;
     LITTLENUM_TYPE *bignum;
     int nchars;
d3424 1
a3424 4
  while (nchars)
    {
      LITTLENUM_TYPE work = *bignum++;
      int nb = CHARS_PER_LITTLENUM;
d3426 1
a3426 25
      do
	{
	  *buf++ = work & ((1 << BITS_PER_CHAR) - 1);
	  if (--nchars == 0)
	    return;
	  work >>= BITS_PER_CHAR;
	}
      while (--nb);
    }
}

CONST char *md_shortopts = "Fm:g";
struct option md_longopts[] = {
#define OPTION_32ADDR (OPTION_MD_BASE)
  {"32addr", no_argument, NULL, OPTION_32ADDR},
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof(md_longopts);

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
d3428 2
d3431 1
a3431 1
      nofloats = 1;
d3434 4
a3437 8
    case OPTION_32ADDR:
      addr32 = 1;
      break;

    case 'g':
      /* Ignore `-g' so gcc can provide this option to the Digital
	 UNIX assembler, which otherwise would throw away info that
	 mips-tfile needs.  */
d3440 6
a3445 2
    default:
      return 0;
d3448 7
a3454 1
  return 1;
d3457 3
a3459 12
void
md_show_usage (stream)
     FILE *stream;
{
  fprintf(stream, "\
Alpha options:\n\
-32addr			treat addresses as 32-bit values\n\
-F			lack floating point instructions support\n\
-m21064 | -m21066 | -m21164\n\
			specify variant of Alpha architecture\n");
}

d3461 1
a3461 1
s_proc (is_static)
a3463 1
  /* XXXX Align to cache linesize XXXXX */
d3495 3
d3519 1
a3519 1
    at_ok = yesno;
d3521 1
a3521 1
    macro_ok = yesno;
d3528 1
d3533 6
a3538 4
/* @@@@ Is this right?? */
long
md_pcrel_from (fixP)
     fixS *fixP;
d3540 19
a3558 2
  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;
  switch (fixP->fx_r_type)
d3560 2
a3561 5
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
      return addr;
    default:
      return fixP->fx_size + addr;
d3563 2
d3575 2
a3576 2
  register int temp;
  register long temp_fill;
d3579 7
a3585 4
  temp = get_absolute_expression ();
  if (temp > max_alignment)
    as_bad ("Alignment too large: %d. assumed.", temp = max_alignment);
  else if (temp < 0)
d3587 2
a3588 2
      as_warn ("Alignment negative: 0 assumed.");
      temp = 0;
d3590 1
d3594 2
a3595 1
      temp_fill = get_absolute_expression ();
d3598 3
a3600 2
    temp_fill = 0;
  if (temp)
d3602 2
a3603 2
      auto_align = 1;
      alpha_align (temp, (int) temp_fill, insn_label);
d3607 1
a3607 1
      auto_align = 0;
d3613 2
d3616 2
a3617 4
alpha_align (n, fill, label)
     int n;
     int fill;
     symbolS *label;
d3619 6
a3624 17
  if (fill == 0
      && (now_seg == text_section
	  || !strcmp (now_seg->name, ".init")
	  || !strcmp (now_seg->name, ".fini"))
      && n > 2)
    {
      static const unsigned char nop_pattern[] = { 0x1f, 0x04, 0xff, 0x47 };
      /* First, make sure we're on a four-byte boundary, in case
	 someone has been putting .byte values into the text section.
	 The DEC assembler silently fills with unaligned no-op
	 instructions.  This will zero-fill, then nop-fill with proper
	 alignment.  */
      frag_align (2, fill);
      frag_align_pattern (n, nop_pattern, sizeof (nop_pattern));
    }
  else
    frag_align (n, fill);
d3626 7
a3632 6
  if (label != NULL)
    {
      assert (S_GET_SEGMENT (label) == now_seg);
      label->sy_frag = frag_now;
      S_SET_VALUE (label, (valueT) frag_now_fix ());
    }
d3635 1
a3635 2
/* This function is called just before the generic pseudo-ops output
   something.  It just clears insn_label.  */
d3638 2
a3639 1
alpha_flush_pending_output ()
d3641 11
a3651 1
  insn_label = NULL;
d3653 226
d3880 2
a3881 3
/* Handle data allocation pseudo-ops.  This is like the generic
   version, but it makes sure the current label, if any, is correctly
   aligned.  */
d3883 3
a3885 3
static void
s_alpha_cons (log_size)
     int log_size;
d3887 48
a3934 5
  if (log_size > 0 && auto_align)
    alpha_align (log_size, 0, insn_label);
  insn_label = NULL;
  cons (1 << log_size);
}
d3936 10
a3945 3
/* Handle floating point allocation pseudo-ops.  This is like the
   generic vresion, but it makes sure the current label, if any, is
   correctly aligned.  */
d3947 3
a3949 7
static void
s_alpha_float_cons (type)
     int type;
{
  if (auto_align)
    {
      int log_size;
d3951 2
a3952 7
      switch (type)
	{
	default:
	case 'f':
	case 'F':
	  log_size = 2;
	  break;
d3954 3
a3956 5
	case 'd':
	case 'D':
	case 'G':
	  log_size = 3;
	  break;
d3958 9
a3966 7
	case 'x':
	case 'X':
	case 'p':
	case 'P':
	  log_size = 4;
	  break;
	}
d3968 6
a3973 2
      alpha_align (log_size, 0, insn_label);
    }
d3975 1
a3975 2
  insn_label = NULL;
  float_cons (type);
d3978 4
a3981 2
/* This function is called whenever a label is defined.  It is used to
   adjust the label when an automatic alignment occurs.  */
d3983 3
a3985 3
void
alpha_define_label (sym)
     symbolS *sym;
d3987 6
a3992 1
  insn_label = sym;
d3995 2
a3996 4
int
md_apply_fix (fixP, valueP)
     fixS *fixP;
     valueT *valueP;
d3998 1
a3998 4
  valueT value;
  int size;
  valueT addend;
  char *p = fixP->fx_frag->fr_literal + fixP->fx_where;
d4000 2
a4001 1
  value = *valueP;
d4003 7
a4009 28
  switch (fixP->fx_r_type)
    {
      /* The GPDISP relocations are processed internally with a symbol
	 referring to the current function; we need to drop in a value
	 which, when added to the address of the start of the function,
	 gives the desired GP.  */
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
      addend = value;
      if (fixP->fx_r_type == BFD_RELOC_ALPHA_GPDISP_HI16)
	{
	  assert (fixP->fx_next->fx_r_type == BFD_RELOC_ALPHA_GPDISP_LO16);
#ifdef DEBUG1
	  printf ("hi16: ");
	  fprintf_vma (stdout, addend);
	  printf ("\n");
#endif
	  if (addend & 0x8000)
	    addend += 0x10000;
	  addend >>= 16;
	  fixP->fx_offset = 4;	/* @@@@ Compute this using fx_next.  */
	}
      else
	{
#ifdef DEBUG1
	  printf ("lo16: ");
	  fprintf_vma (stdout, addend);
	  printf ("\n");
a4010 8
	  addend &= 0xffff;
	  fixP->fx_offset = 0;
	}
      md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			  addend, 2);
      fixP->fx_addsy = section_symbol (absolute_section);
      fixP->fx_offset += fixP->fx_frag->fr_address + fixP->fx_where;
      break;
d4012 2
a4013 16
    case BFD_RELOC_8:
      /* Write 8 bits, shifted left 13 bit positions.  */
      value &= 0xff;
      p++;
      *p &= 0x1f;
      *p |= (value << 5) & 0xe0;
      value >>= 3;
      p++;
      *p &= 0xe0;
      *p |= value;
      value >>= 5;
      fixP->fx_done = 1;
      if (value != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      "overflow in type-%d reloc", (int) fixP->fx_r_type);
      return 3;
d4015 1
a4015 18
    case BFD_RELOC_32:
      size = 4;
      goto do_it;
    case BFD_RELOC_64:
      size = 8;
      goto do_it;
    case BFD_RELOC_16:
      /* Don't want overflow checking.  */
      size = 2;
    do_it:
      if (fixP->fx_pcrel == 0
	  && fixP->fx_addsy == 0)
	{
	  md_number_to_chars (p, value, size);
	  /* @@@@ Overflow checks??  */
	  goto done;
	}
      break;
d4017 1
a4017 21
    case BFD_RELOC_26:
      if (fixP->fx_addsy != 0
	  && fixP->fx_addsy->bsym->section != absolute_section)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      "PALcode instructions require immediate constant function code");
      else if (value >> 26 != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      "overflow in 26-bit PALcode function field");
      *p++ = value & 0xff;
      value >>= 8;
      *p++ = value & 0xff;
      value >>= 8;
      *p++ = value & 0xff;
      value >>= 8;
      {
	char x = *p;
	x &= ~3;
	x |= (value & 3);
	*p++ = x;
      }
      goto done;
d4019 5
a4023 12
    case BFD_RELOC_14:
      if (fixP->fx_addsy != 0
	  && fixP->fx_addsy->bsym->section != absolute_section)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		  "ret/jsr_coroutine requires constant in displacement field");
      else if (value >> 14 != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		  "overflow in 14-bit operand field of ret or jsr_coroutine");
      *p++ = value & 0xff;
      value >>= 8;
      *p = (*p & 0xc0) | (value & 0x3f);
      goto done;
d4025 4
a4028 10
    case BFD_RELOC_23_PCREL_S2:
      /* Write 21 bits only.  */
      value >>= 2;
      *p++ = value & 0xff;
      value >>= 8;
      *p++ = value & 0xff;
      value >>= 8;
      *p &= 0xe0;
      *p |= (value & 0x1f);
      goto done;
d4030 8
a4037 6
    case BFD_RELOC_12_PCREL:
      *p++ = value & 0xff;
      value >>= 8;
      *p &= 0xf0;
      *p |= (value & 0x0f);
      goto done;
d4039 6
a4044 10
    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
      return 2;

    case BFD_RELOC_GPREL32:
      assert (fixP->fx_subsy == gp);
      value = - alpha_gp_value;	/* huh?  this works... */
      fixP->fx_subsy = 0;
      md_number_to_chars (p, value, 4);
      break;
d4046 8
a4053 5
    case BFD_RELOC_ALPHA_HINT:
      if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
	{
	  size = 2;
	  goto do_it;
d4055 5
a4059 1
      return 2;
d4061 1
a4061 5
    default:
      as_fatal ("unhandled relocation type %s",
		bfd_get_reloc_code_name (fixP->fx_r_type));
      return 9;
    }
d4063 1
a4063 1
  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
d4065 3
a4067 4
      printf ("type %d reloc done?\n", fixP->fx_r_type);
    done:
      fixP->fx_done = 1;
      return 42;
d4070 1
a4070 10
  return 0x12345678;
}

void
alpha_frob_ecoff_data ()
{
  select_gp_value ();
  /* $zero and $f31 are read-only */
  alpha_gprmask &= ~1;
  alpha_fprmask &= ~1;
@


1.1
log
@Initial revision
@
text
@d2177 17
a2193 1
      emit_add64 (add64_in, add64_out, add64_addend);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2177 1
a2177 17
      /* If opcode represents an addq instruction, and the addend we
         are using fits in a 16 bit range, we can change the addq
         directly into an lda rather than emitting an lda followed by
         an addq.  */
      if (OPCODE (opcode) == 0x10
	  && OP_FCN (opcode) == 0x20	/* addq */
	  && add64_in == ZERO
	  && add64_out == AT
	  && in_range_signed (add64_addend, 16))
	{
	  opcode = (0x20000000	/* lda */
		    | (((opcode >> SC) & 0x1f) << SA)
		    | (((opcode >> SA) & 0x1f) << SB)
		    | (add64_addend & 0xffff));
	}
      else
	emit_add64 (add64_in, add64_out, add64_addend);
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d1 2
a2 2
/* tc-alpha.c - Processor-specific code for the DEC Alpha AXP CPU.
   Copyright (C) 1989, 93, 94, 95, 1996 Free Software Foundation, Inc.
a5 2
   Modified by Richard Henderson for ELF support.
   Modified by Klaus Kaempf for EVAX (openVMS/Alpha) support.
d20 2
a21 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d48 10
d60 1
d63 5
a67 4
#include "opcode/alpha.h"

#ifdef OBJ_ELF
#include "elf/alpha.h"
d70 2
a71 1
#include <ctype.h>
d73 4
a76 2

/* Local types */
d78 2
a79 2
#define MAX_INSN_FIXUPS 2
#define MAX_INSN_ARGS 5
d81 3
a83 5
struct alpha_fixup
{
  expressionS exp;
  bfd_reloc_code_real_type reloc;
};
d85 2
a86 6
struct alpha_insn
{
  unsigned insn;
  int nfixups;
  struct alpha_fixup fixups[MAX_INSN_FIXUPS];
};
d88 3
a90 4
enum alpha_macro_arg
{
  MACRO_EOA = 1, MACRO_IR, MACRO_PIR, MACRO_CPIR, MACRO_FPR, MACRO_EXP
};
d92 3
a94 7
struct alpha_macro
{
  const char *name;
  void (*emit) PARAMS((const expressionS *, int, void *));
  void *arg;
  enum alpha_macro_arg argsets[16];
};
d96 2
a97 2
/* Two extra symbols we want to see in our input.  This is a blatent
   misuse of the expressionS.X_op field.  */
d99 2
a100 2
#define O_pregister	(O_max+1)	/* O_register, but in parentheses */
#define O_cpregister	(O_pregister+1)	/* + a leading comma */
d102 5
a106 1
/* Macros for extracting the type and number of encoded register tokens */
d108 6
a113 3
#define is_ir_num(x)		(((x) & 32) == 0)
#define is_fpr_num(x)		(((x) & 32) != 0)
#define regno(x)		((x) & 31)
d115 3
a117 1
/* Something odd inherited from the old assembler */
d119 34
a152 2
#define note_gpreg(R)		(alpha_gprmask |= (1 << (R)))
#define note_fpreg(R)		(alpha_fprmask |= (1 << (R)))
d154 14
a167 1
/* Predicates for 16- and 32-bit ranges */
d169 10
a178 17
#define range_signed_16(x)	((offsetT)(x) >= -(offsetT)0x8000 &&	\
				 (offsetT)(x) <=  (offsetT)0x7FFF)
#define range_signed_32(x)	((offsetT)(x) >= -(offsetT)0x80000000 && \
				 (offsetT)(x) <=  (offsetT)0x7FFFFFFF)

/* Macros for sign extending from 16- and 32-bits.  */
/* XXX: The cast macros will work on all the systems that I care about,
   but really a predicate should be found to use the non-cast forms.  */

#if 1
#define sign_extend_16(x)	((short)(x))
#define sign_extend_32(x)	((int)(x))
#else
#define sign_extend_16(x)	((offsetT)(((x) & 0xFFFF) ^ 0x8000) - 0x8000)
#define sign_extend_32(x)	((offsetT)(((x) & 0xFFFFFFFF) \
					   ^ 0x80000000) - 0x80000000)
#endif
d180 12
a191 1
/* Macros to build tokens */
d193 3
a195 19
#define set_tok_reg(t, r)	(memset(&(t), 0, sizeof(t)),		\
				 (t).X_op = O_register,			\
				 (t).X_add_number = (r))
#define set_tok_preg(t, r)	(memset(&(t), 0, sizeof(t)),		\
				 (t).X_op = O_pregister,		\
				 (t).X_add_number = (r))
#define set_tok_cpreg(t, r)	(memset(&(t), 0, sizeof(t)),		\
				 (t).X_op = O_cpregister,		\
				 (t).X_add_number = (r))
#define set_tok_freg(t, r)	(memset(&(t), 0, sizeof(t)),		\
				 (t).X_op = O_register,			\
				 (t).X_add_number = (r)+32)
#define set_tok_sym(t, s, a)	(memset(&(t), 0, sizeof(t)),		\
				 (t).X_op = O_symbol,			\
				 (t).X_add_symbol = (s),		\
				 (t).X_add_number = (a))
#define set_tok_const(t, n)	(memset(&(t), 0, sizeof(t)),		\
				 (t).X_op = O_constant,			\
				 (t).X_add_number = (n))
d197 2
a198 2

/* Prototypes for all local functions */
d200 21
a220 36
static int tokenize_arguments PARAMS((char *, expressionS*, int));
static const struct alpha_opcode *find_opcode_match
	PARAMS((const struct alpha_opcode*, const expressionS*, int*, int*));
static const struct alpha_macro *find_macro_match
	PARAMS((const struct alpha_macro*, const expressionS*, int*));
static unsigned insert_operand PARAMS((unsigned, const struct alpha_operand*,
				      offsetT, char *, unsigned));
static void assemble_insn PARAMS((const struct alpha_opcode*,
				  const expressionS*, int,
				  struct alpha_insn*));
static void emit_insn PARAMS((struct alpha_insn *));
static void assemble_tokens_to_insn PARAMS((const char *, const expressionS*,
					    int, struct alpha_insn *));
static void assemble_tokens PARAMS((const char *, const expressionS*,
				    int, int));

static int load_expression PARAMS((int, const expressionS*, int *,
				   expressionS*));

static void emit_ldgp PARAMS((const expressionS*, int, void*));
static void emit_division PARAMS((const expressionS*, int, void*));
static void emit_lda PARAMS((const expressionS*, int, void*));
static void emit_ir_load PARAMS((const expressionS*, int, void*));
static void emit_loadstore PARAMS((const expressionS*, int, void*));
static void emit_jsrjmp PARAMS((const expressionS*, int, void*));

static void s_alpha_text PARAMS((int));
static void s_alpha_data PARAMS((int));
#ifndef OBJ_ELF
static void s_alpha_comm PARAMS((int));
#endif
#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)
static void s_alpha_rdata PARAMS((int));
#endif
#ifdef OBJ_ECOFF
static void s_alpha_sdata PARAMS((int));
a221 17
#ifdef OBJ_ELF
static void s_alpha_section PARAMS((int));
#endif
static void s_alpha_gprel32 PARAMS((int));
static void s_alpha_float_cons PARAMS((int));
static void s_alpha_proc PARAMS((int));
static void s_alpha_set PARAMS((int));
static void s_alpha_base PARAMS((int));
static void s_alpha_align PARAMS((int));
static void s_alpha_stringer PARAMS((int));
static void s_alpha_space PARAMS((int));

static void create_literal_section PARAMS((const char *, segT*, symbolS**));
#ifndef OBJ_ELF
static void select_gp_value PARAMS((void));
#endif
static void alpha_align PARAMS((int, char *, symbolS *));
d223 2
a224 3

/* Generic assembler global variables which must be defined by all
   targets.  */
d226 2
a227 4
/* These are exported to relaxing code, even though we don't do any
   relaxing on this processor currently.  */
int md_short_jump_size = 4;
int md_long_jump_size = 4;
d229 2
a230 1
/* Characters which always start a comment.  */
d233 8
a240 2
/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";
d242 2
a243 3
/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";
d245 1
a245 3
/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";
d247 3
a249 6
/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
#if 0
const char FLT_CHARS[] = "dD";
#else
/* XXX: Do all of these really get used on the alpha??  */
a250 1
#endif
d252 3
a254 1
const char *md_shortopts = "Fm:g";
d256 4
a259 4
struct option md_longopts[] = {
#define OPTION_32ADDR (OPTION_MD_BASE)
  { "32addr", no_argument, NULL, OPTION_32ADDR },
  { NULL, no_argument, NULL, 0 }
d262 9
a270 1
size_t md_longopts_size = sizeof(md_longopts);
d272 2
a273 8

/* The cpu for which we are generating code */
static unsigned alpha_target = AXP_OPCODE_ALL;
static const char *alpha_target_name = "<all>";

/* Forward declaration of the table of macros */
static const struct alpha_macro alpha_macros[];
static const int alpha_num_macros;
d275 2
a276 2
/* The hash table of instruction opcodes */
static struct hash_control *alpha_opcode_hash;
d278 5
a282 2
/* The hash table of macro opcodes */
static struct hash_control *alpha_macro_hash;
d284 16
a299 3
#ifdef OBJ_ECOFF
/* The $gp relocation symbol */
static symbolS *alpha_gp_symbol;
d301 3
a303 3
/* XXX: what is this, and why is it exported? */
valueT alpha_gp_value;
#endif
d305 2
a306 2
/* The current $gp register */
static int alpha_gp_register = AXP_REG_GP;
d308 8
a315 2
/* A table of the register symbols */
static symbolS *alpha_register_table[64];
d317 2
a318 9
/* Constant sections, or sections of constants */
#ifdef OBJ_ECOFF
static segT alpha_lita_section;
static segT alpha_lit4_section;
#endif
#ifdef OBJ_EVAX
static segT alpha_link_section;
#endif
static segT alpha_lit8_section;
d320 8
a327 9
/* Symbols referring to said sections. */
#ifdef OBJ_ECOFF
static symbolS *alpha_lita_symbol;
static symbolS *alpha_lit4_symbol;
#endif
#ifdef OBJ_EVAX
static symbolS *alpha_link_symbol;
#endif
static symbolS *alpha_lit8_symbol;
d329 5
a333 2
/* Is the assembler not allowed to use $at? */
static int alpha_noat_on = 0;
d335 12
a346 2
/* Are macros enabled? */
static int alpha_macros_on = 1;
d348 5
a352 2
/* Are floats disabled? */
static int alpha_nofloats_on = 0;
d354 7
a360 23
/* Are addresses 32 bit? */
static int alpha_addr32_on = 0;

/* Symbol labelling the current insn.  When the Alpha gas sees
     foo:
       .quad 0
   and the section happens to not be on an eight byte boundary, it
   will align both the symbol and the .quad to an eight byte boundary.  */
static symbolS *alpha_insn_label;

/* Whether we should automatically align data generation pseudo-ops.
   .align 0 will turn this off.  */
static int alpha_auto_align_on = 1;

/* The known current alignment of the current section.  */
static int alpha_current_align;

/* These are exported to ECOFF code.  */
unsigned long alpha_gprmask, alpha_fprmask;

#ifdef OBJ_EVAX
/* Collect information about current procedure here.  */
static evaxProcT alpha_evax_proc;
d362 4
a365 2

/* Public interface functions */
d367 3
a369 6
/* This function is called once, at assembler startup time.  It sets
   up all the tables, etc. that the MD part of the assembler will
   need, that can be determined before arguments are parsed.  */

void
md_begin ()
d371 5
a375 1
  unsigned int i = 0;
d377 8
a384 4
  /* Create the opcode hash table */

  alpha_opcode_hash = hash_new ();
  for (i = 0; i < alpha_num_opcodes; )
d386 2
a387 11
      const char *name, *retval;

      name = alpha_opcodes[i].name;
      retval = hash_insert (alpha_opcode_hash, name, (PTR)&alpha_opcodes[i]);
      if (retval)
	as_fatal ("internal error: can't hash opcode `%s': %s", name, retval);

      while (++i < alpha_num_opcodes
	     && (alpha_opcodes[i].name == name
		 || !strcmp (alpha_opcodes[i].name, name)))
	continue;
d389 1
a389 5

  /* Some opcodes include modifiers of various sorts with a "/mod" syntax,
     like the architecture manual suggests.  However, for use with gcc at
     least, we also need access to those same opcodes without the "/".  */
  for (i = 0; i < alpha_num_opcodes; )
d391 3
a393 17
      const char *name, *slash;
      name = alpha_opcodes[i].name;
      if ((slash = strchr(name, '/')) != NULL)
	{
	  char *p = xmalloc (strlen (name));
	  memcpy(p, name, slash-name);
	  strcpy(p+(slash-name), slash+1);

	  (void)hash_insert(alpha_opcode_hash, p, (PTR)&alpha_opcodes[i]);
	  /* Ignore failures -- the opcode table does duplicate some
	     variants in different forms, like "hw_stq" and "hw_st/q".  */
	}

      while (++i < alpha_num_opcodes
	     && (alpha_opcodes[i].name == name
		 || !strcmp (alpha_opcodes[i].name, name)))
	continue;
d395 4
a398 5

  /* Create the macro hash table */

  alpha_macro_hash = hash_new ();
  for (i = 0; i < alpha_num_macros; )
d400 3
a402 11
      const char *name, *retval;

      name = alpha_macros[i].name;
      retval = hash_insert (alpha_macro_hash, name, (PTR)&alpha_macros[i]);
      if (retval)
	as_fatal ("internal error: can't hash macro `%s': %s", name, retval);

      while (++i < alpha_num_macros
	     && (alpha_macros[i].name == name
		 || !strcmp (alpha_macros[i].name, name)))
	continue;
d404 1
a404 4

  /* Construct symbols for each of the registers */

  for (i = 0; i < 32; ++i)
d406 5
a410 4
      char name[4];
      sprintf(name, "$%d", i);
      alpha_register_table[i] = symbol_create(name, reg_section, i,
					      &zero_address_frag);
d412 1
a412 1
  for (; i < 64; ++i)
d414 2
a415 4
      char name[5];
      sprintf(name, "$f%d", i-32);
      alpha_register_table[i] = symbol_create(name, reg_section, i,
					      &zero_address_frag);
d418 3
a420 1
  /* Create the special symbols and sections we'll be using */
d422 6
a427 2
  /* So .sbss will get used for tiny objects.  */
  bfd_set_gp_size (stdoutput, 8);
d429 3
a431 2
#ifdef OBJ_ECOFF
  create_literal_section (".lita", &alpha_lita_section, &alpha_lita_symbol);
d433 2
a434 5
  /* For handling the GP, create a symbol that won't be output in the
     symbol table.  We'll edit it out of relocs later.  */
  alpha_gp_symbol = symbol_create ("<GP value>", alpha_lita_section, 0x8000,
				   &zero_address_frag);
#endif
d436 11
a446 6
#ifdef OBJ_EVAX
  create_literal_section (".link", &alpha_link_section, &alpha_link_symbol);
#endif

#ifdef OBJ_ELF
  if (ECOFF_DEBUGGING)
d448 2
a449 14
      segT sec;

      sec = subseg_new(".mdebug", (subsegT)0);
      bfd_set_section_flags(stdoutput, sec, SEC_HAS_CONTENTS|SEC_READONLY);
      bfd_set_section_alignment(stdoutput, sec, 3);

#ifdef ERIC_neverdef
      sec = subseg_new(".reginfo", (subsegT)0);
      /* The ABI says this section should be loaded so that the running
	 program can access it.  */
      bfd_set_section_flags(stdoutput, sec, 
			    SEC_ALLOC|SEC_LOAD|SEC_READONLY|SEC_DATA);
      bfd_set_section_alignement(stdoutput, sec, 3);
#endif
d451 1
a451 1
#endif /* OBJ_ELF */
d453 1
a453 800
  subseg_set(text_section, 0);
}

/* The public interface to the instruction assembler.  */

void
md_assemble (str)
     char *str;
{
  char opname[32];			/* current maximum is 13 */
  expressionS tok[MAX_INSN_ARGS];
  int ntok, opnamelen, trunclen;

  /* split off the opcode */
  opnamelen = strspn (str, "abcdefghijklmnopqrstuvwxyz_/48");
  trunclen = (opnamelen < sizeof (opname) - 1
	      ? opnamelen
	      : sizeof (opname) - 1);
  memcpy (opname, str, trunclen);
  opname[trunclen] = '\0';

  /* tokenize the rest of the line */
  if ((ntok = tokenize_arguments (str + opnamelen, tok, MAX_INSN_ARGS)) < 0)
    {
      as_bad ("syntax error");
      return;
    }

  /* finish it off */
  assemble_tokens (opname, tok, ntok, alpha_macros_on);
}

/* Round up a section's size to the appropriate boundary.  */

valueT
md_section_align (seg, size)
     segT seg;
     valueT size;
{
  int align = bfd_get_section_alignment(stdoutput, seg);
  valueT mask = ((valueT)1 << align) - 1;

  return (size + mask) & ~mask;
}

/* Turn a string in input_line_pointer into a floating point constant
   of type type, and store the appropriate bytes in *litP.  The number
   of LITTLENUMS emitted is stored in *sizeP.  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c */
#define MAX_LITTLENUMS 6

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;
  char *atof_ieee (), *vax_md_atof ();

  switch (type)
    {
      /* VAX floats */
    case 'G':
      /* VAX md_atof doesn't like "G" for some reason.  */
      type = 'g';
    case 'F':
    case 'D':
      return vax_md_atof (type, litP, sizeP);

      /* IEEE floats */
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return "Bad call to MD_ATOF()";
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
}

/* Take care of the target-specific command-line options.  */

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
    {
    case 'F':
      alpha_nofloats_on = 1;
      break;

    case OPTION_32ADDR:
      alpha_addr32_on = 1;
      break;

    case 'g':
      /* Ignore `-g' so gcc can provide this option to the Digital
	 UNIX assembler, which otherwise would throw away info that
	 mips-tfile needs.  */
      break;

    case 'm':
      {
	static const struct machine
	{
	  const char *name;
	  unsigned flags;
	} *p, m[] =
	{
	  { "21064", AXP_OPCODE_EV4|AXP_OPCODE_ALL },
	  { "21066", AXP_OPCODE_EV4|AXP_OPCODE_ALL },
	  { "21164", AXP_OPCODE_EV5|AXP_OPCODE_ALL },
	  { "21164a", AXP_OPCODE_EV56|AXP_OPCODE_ALL },
	  { "ev4", AXP_OPCODE_EV4|AXP_OPCODE_ALL },
	  { "ev45", AXP_OPCODE_EV4|AXP_OPCODE_ALL },
	  { "ev5", AXP_OPCODE_EV5|AXP_OPCODE_ALL },
	  { "ev56", AXP_OPCODE_EV56|AXP_OPCODE_ALL },
	  { "all", AXP_OPCODE_ALL },
	  { 0 }
	};
	
	for (p = m; p->name; ++p)
	  if (strcmp(arg, p->name) == 0)
	    {
	      alpha_target_name = p->name, alpha_target = p->flags;
	      goto found;
	    }
	as_warn("Unknown CPU identifier `%s'", arg);
      found:;
      }
      break;

    default:
      return 0;
    }

  return 1;
}

/* Print a description of the command-line options that we accept.  */

void
md_show_usage (stream)
     FILE *stream;
{
  fputs("\
Alpha options:\n\
-32addr			treat addresses as 32-bit values\n\
-F			lack floating point instructions support\n\
-m21064 | -m21066 | -m21164 | -m21164a\n\
-mev4 | -mev45 | -mev5 | -mev56 | -mall\n\
			specify variant of Alpha architecture\n",
	stream);
}

/* Decide from what point a pc-relative relocation is relative to,
   relative to the pc-relative fixup.  Er, relatively speaking.  */

long
md_pcrel_from (fixP)
     fixS *fixP;
{
  valueT addr = fixP->fx_where + fixP->fx_frag->fr_address;
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_ALPHA_GPDISP:
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
      return addr;
    default:
      return fixP->fx_size + addr;
    }
}

/* Attempt to simplify or even eliminate a fixup.  The return value is
   ignored; perhaps it was once meaningful, but now it is historical.
   To indicate that a fixup has been eliminated, set fixP->fx_done.

   For ELF, here it is that we transform the GPDISP_HI16 reloc we used
   internally into the GPDISP reloc used externally.  We had to do
   this so that we'd have the GPDISP_LO16 reloc as a tag to compute
   the distance to the "lda" instruction for setting the addend to
   GPDISP.  */

int
md_apply_fix (fixP, valueP)
     fixS *fixP;
     valueT *valueP;
{
  char * const fixpos = fixP->fx_frag->fr_literal + fixP->fx_where;
  valueT value = *valueP;
  unsigned image, size;

  switch (fixP->fx_r_type)
    {
      /* The GPDISP relocations are processed internally with a symbol
	 referring to the current function; we need to drop in a value
	 which, when added to the address of the start of the function,
	 gives the desired GP.  */
    case BFD_RELOC_ALPHA_GPDISP_HI16:
      {
	fixS *next = fixP->fx_next;
	assert (next->fx_r_type == BFD_RELOC_ALPHA_GPDISP_LO16);

	fixP->fx_offset = (next->fx_frag->fr_address + next->fx_where 
			   - fixP->fx_frag->fr_address - fixP->fx_where);

	value = (value - sign_extend_16 (value)) >> 16;
      }
#ifdef OBJ_ELF
      fixP->fx_r_type = BFD_RELOC_ALPHA_GPDISP;
#endif
      goto do_reloc_gp;

    case BFD_RELOC_ALPHA_GPDISP_LO16:
      value = sign_extend_16 (value);
      fixP->fx_offset = 0;
#ifdef OBJ_ELF
      fixP->fx_done = 1;
#endif

    do_reloc_gp:
      fixP->fx_addsy = section_symbol (absolute_section);
      md_number_to_chars (fixpos, value, 2);
      break;

    case BFD_RELOC_16:
      size = 2;
      goto do_reloc_xx;
    case BFD_RELOC_32:
      size = 4;
      goto do_reloc_xx;
    case BFD_RELOC_64:
      size = 8;
    do_reloc_xx:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  md_number_to_chars (fixpos, value, size);
	  goto done;
	}
      return 1;

#ifdef OBJ_ECOFF
    case BFD_RELOC_GPREL32:
      assert (fixP->fx_subsy == alpha_gp_symbol);
      fixP->fx_subsy = 0;
      /* FIXME: inherited this obliviousness of `value' -- why? */
      md_number_to_chars (fixpos, -alpha_gp_value, 4);
      break;
#endif
#ifdef OBJ_ELF
    case BFD_RELOC_GPREL32:
      return 1;
#endif

    case BFD_RELOC_23_PCREL_S2:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  image = bfd_getl32(fixpos);
	  image = (image & ~0x1FFFFF) | ((value >> 2) & 0x1FFFFF);
	  goto write_done;
	}
      return 1;

    case BFD_RELOC_ALPHA_HINT:
      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
	{
	  image = bfd_getl32(fixpos);
	  image = (image & ~0x3FFF) | ((value >> 2) & 0x3FFF);
	  goto write_done;
	}
      return 1;

#ifdef OBJ_ECOFF
    case BFD_RELOC_ALPHA_LITERAL:
      md_number_to_chars (fixpos, value, 2);
      return 1;

    case BFD_RELOC_ALPHA_LITUSE:
      return 1;
#endif
#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
      return 1;
#endif
#ifdef OBJ_EVAX
    case BFD_RELOC_ALPHA_LINKAGE:
      return 1;
#endif

    default:
      {
	const struct alpha_operand *operand;

	if (fixP->fx_r_type <= BFD_RELOC_UNUSED)
	  as_fatal ("unhandled relocation type %s",
		    bfd_get_reloc_code_name (fixP->fx_r_type));

	assert (fixP->fx_r_type < BFD_RELOC_UNUSED + alpha_num_operands);
	operand = &alpha_operands[fixP->fx_r_type - BFD_RELOC_UNUSED];

	/* The rest of these fixups only exist internally during symbol
	   resolution and have no representation in the object file.  
	   Therefore they must be completely resolved as constants.  */

	if (fixP->fx_addsy != 0
	    && fixP->fx_addsy->bsym->section != absolute_section)
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"non-absolute expression in constant field");

	image = bfd_getl32(fixpos);
	image = insert_operand(image, operand, (offsetT)value,
			       fixP->fx_file, fixP->fx_line);
      }
      goto write_done;
    }

  if (fixP->fx_addsy != 0 || fixP->fx_pcrel != 0)
    return 1;
  else
    {
      as_warn_where(fixP->fx_file, fixP->fx_line,
		    "type %d reloc done?\n", fixP->fx_r_type);
      goto done;
    }
      
write_done:
  md_number_to_chars(fixpos, image, 4);

done:
  fixP->fx_done = 1;
  return 0;
}

/* 
 * Look for a register name in the given symbol.
 */

symbolS *
md_undefined_symbol(name)
     char *name;
{
  if (*name == '$')
    {
      int is_float = 0, num;

      switch (*++name)
	{
	case 'f':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[AXP_REG_FP];
	  is_float = 32;
	  /* FALLTHRU */

	case 'r':
	  if (!isdigit(*++name))
	    break;
	  /* FALLTHRU */

	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	  if (name[1] == '\0')
	    num = name[0] - '0';
	  else if (name[0] != '0' && isdigit(name[1]) && name[2] == '\0')
	    {
	      num = (name[0] - '0')*10 + name[1] - '0';
	      if (num >= 32)
		break;
	    }
	  else
	    break;

	  if (!alpha_noat_on && num == AXP_REG_AT)
	    as_warn("Used $at without \".set noat\"");
	  return alpha_register_table[num + is_float];

	case 'a':
	  if (name[1] == 't' && name[2] == '\0')
	    {
	      if (!alpha_noat_on)
		as_warn("Used $at without \".set noat\"");
	      return alpha_register_table[AXP_REG_AT];
	    }
	  break;

	case 'g':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[alpha_gp_register];
	  break;

	case 's':
	  if (name[1] == 'p' && name[2] == '\0')
	    return alpha_register_table[AXP_REG_SP];
	  break;
	}
    }
  return NULL;
}

#ifdef OBJ_ECOFF
/* @@@@@@ Magic ECOFF bits.  */

void
alpha_frob_ecoff_data ()
{
  select_gp_value ();
  /* $zero and $f31 are read-only */
  alpha_gprmask &= ~1;
  alpha_fprmask &= ~1;
}
#endif

/* Hook to remember a recently defined label so that the auto-align
   code can adjust the symbol after we know what alignment will be
   required.  */

void
alpha_define_label (sym)
     symbolS *sym;
{
  alpha_insn_label = sym;
}

/* Return true if we must always emit a reloc for a type and false if
   there is some hope of resolving it a assembly time.  */

int
alpha_force_relocation (f)
     fixS *f;
{
  switch (f->fx_r_type)
    {
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
    case BFD_RELOC_ALPHA_GPDISP:
    case BFD_RELOC_ALPHA_LITERAL:
    case BFD_RELOC_ALPHA_LITUSE:
    case BFD_RELOC_GPREL32:
#ifdef OBJ_EVAX
    case BFD_RELOC_ALPHA_LINKAGE:
#endif
      return 1;

    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_32:
    case BFD_RELOC_64:
    case BFD_RELOC_ALPHA_HINT:
      return 0;

    default:
      assert(f->fx_r_type > BFD_RELOC_UNUSED &&
	     f->fx_r_type < BFD_RELOC_UNUSED + alpha_num_operands);
      return 0;
    }
}

/* Return true if we can partially resolve a relocation now.  */

int
alpha_fix_adjustable (f)
     fixS *f;
{
#ifdef OBJ_ELF
  /* Prevent all adjustments to global symbols */
  if (S_IS_EXTERN (f->fx_addsy))
    return 0;
#endif

  /* Are there any relocation types for which we must generate a reloc
     but we can adjust the values contained within it?  */
  switch (f->fx_r_type)
    {
    case BFD_RELOC_GPREL32:
      return 1;
    default:
      return !alpha_force_relocation (f);
    }
  /*NOTREACHED*/
}

/* Generate the BFD reloc to be stuck in the object file from the
   fixup used internally in the assembler.  */

arelent *
tc_gen_reloc (sec, fixp)
     asection *sec;
     fixS *fixp;
{
  arelent *reloc;

  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* Make sure none of our internal relocations make it this far.
     They'd better have been fully resolved by this point.  */
  assert (fixp->fx_r_type < BFD_RELOC_UNUSED);

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    "cannot represent `%s' relocation in object file",
		    bfd_get_reloc_code_name (fixp->fx_r_type));
      return NULL;
    }

  if (!fixp->fx_pcrel != !reloc->howto->pc_relative)
    {
      as_fatal ("internal error? cannot generate `%s' relocation",
		bfd_get_reloc_code_name (fixp->fx_r_type));
    }
  assert (!fixp->fx_pcrel == !reloc->howto->pc_relative);

#ifdef OBJ_ECOFF
  if (fixp->fx_r_type == BFD_RELOC_ALPHA_LITERAL)
    {
      /* fake out bfd_perform_relocation. sigh */
      reloc->addend = -alpha_gp_value;
    }
  else
#endif
    {
      reloc->addend = fixp->fx_offset;
#ifdef OBJ_ELF
      /* 
       * Ohhh, this is ugly.  The problem is that if this is a local global
       * symbol, the relocation will entirely be performed at link time, not
       * at assembly time.  bfd_perform_reloc doesn't know about this sort
       * of thing, and as a result we need to fake it out here.
       */
      if (S_IS_EXTERN (fixp->fx_addsy) && !S_IS_COMMON(fixp->fx_addsy))
	reloc->addend -= fixp->fx_addsy->bsym->value;
#endif
    }

  return reloc;
}

/* Parse a register name off of the input_line and return a register
   number.  Gets md_undefined_symbol above to do the register name
   matching for us.

   Only called as a part of processing the ECOFF .frame directive.  */

int
tc_get_register (frame)
     int frame;
{
  int framereg = AXP_REG_SP;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
    {
      char *s = input_line_pointer;
      char c = get_symbol_end ();
      symbolS *sym = md_undefined_symbol (s);

      *strchr(s, '\0') = c;
      if (sym && (framereg = S_GET_VALUE (sym)) <= 31)
	goto found;
    }
  as_warn ("frame reg expected, using $%d.", framereg);

found:
  note_gpreg (framereg);
  return framereg;
}


/* Parse the arguments to an opcode.  */

static int
tokenize_arguments (str, tok, ntok)
     char *str;
     expressionS tok[];
     int ntok;
{
  expressionS *end_tok = tok + ntok;
  char *old_input_line_pointer;
  int saw_comma = 0, saw_arg = 0;

  memset (tok, 0, sizeof(*tok)*ntok);

  /* Save and restore input_line_pointer around this function */ 
  old_input_line_pointer = input_line_pointer;
  input_line_pointer = str;
  
  while (tok < end_tok && *input_line_pointer)
    {
      SKIP_WHITESPACE ();
      switch (*input_line_pointer)
	{
	case '\0':
	  goto fini;

	case ',':
	  ++input_line_pointer;
	  if (saw_comma || !saw_arg)
	    goto err;
	  saw_comma = 1;
	  break;

	case '(':
	  {
	    char *hold = input_line_pointer++;

	    /* First try for parenthesized register ... */
	    expression (tok);
	    if (*input_line_pointer == ')' && tok->X_op == O_register)
	      {
		tok->X_op = (saw_comma ? O_cpregister : O_pregister);
		saw_comma = 0;
		saw_arg = 1;
		++input_line_pointer;
		++tok;
		break;
	      }

	    /* ... then fall through to plain expression */
	    input_line_pointer = hold;
	  }

	default:
	  if (saw_arg && !saw_comma)
	    goto err;
	  expression (tok);
	  if (tok->X_op == O_illegal || tok->X_op == O_absent)
	    goto err;

	  saw_comma = 0;
	  saw_arg = 1;
	  ++tok;
	  break;
	}
    }

fini:
  if (saw_comma)
    goto err;
  input_line_pointer = old_input_line_pointer;
  return ntok - (end_tok - tok);

err:
  input_line_pointer = old_input_line_pointer;
  return -1;
}

/* Search forward through all variants of an opcode looking for a
   syntax match.  */

static const struct alpha_opcode *
find_opcode_match(first_opcode, tok, pntok, pcpumatch)
     const struct alpha_opcode *first_opcode;
     const expressionS *tok;
     int *pntok;
     int *pcpumatch;
{
  const struct alpha_opcode *opcode = first_opcode;
  int ntok = *pntok;
  int got_cpu_match = 0;

  do
    {
      const unsigned char *opidx;
      int tokidx = 0;

      /* Don't match opcodes that don't exist on this architecture */
      if (!(opcode->flags & alpha_target))
	goto match_failed;

      got_cpu_match = 1;

      for (opidx = opcode->operands; *opidx; ++opidx)
	{
	  const struct alpha_operand *operand = &alpha_operands[*opidx];

	  /* only take input from real operands */
	  if (operand->flags & AXP_OPERAND_FAKE)
	    continue;

	  /* when we expect input, make sure we have it */
	  if (tokidx >= ntok)
	    {
	      if ((operand->flags & AXP_OPERAND_OPTIONAL_MASK) == 0)
		goto match_failed;
	      continue;
	    }

	  /* match operand type with expression type */
	  switch (operand->flags & AXP_OPERAND_TYPECHECK_MASK)
	    {
	    case AXP_OPERAND_IR:
	      if (tok[tokidx].X_op != O_register
		  || !is_ir_num(tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_FPR:
	      if (tok[tokidx].X_op != O_register
		  || !is_fpr_num(tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_IR|AXP_OPERAND_PARENS:
	      if (tok[tokidx].X_op != O_pregister
		  || !is_ir_num(tok[tokidx].X_add_number))
		goto match_failed;
	      break;
	    case AXP_OPERAND_IR|AXP_OPERAND_PARENS|AXP_OPERAND_COMMA:
	      if (tok[tokidx].X_op != O_cpregister
		  || !is_ir_num(tok[tokidx].X_add_number))
		goto match_failed;
	      break;

	    case AXP_OPERAND_RELATIVE:
	    case AXP_OPERAND_SIGNED:
	    case AXP_OPERAND_UNSIGNED:
	      switch (tok[tokidx].X_op)
		{
		case O_illegal:
		case O_absent:
		case O_register:
		case O_pregister:
		case O_cpregister:
		  goto match_failed;
		}
	      break;

	    default:
	      /* everything else should have been fake */
	      abort();
	    }
	  ++tokidx;
	}

      /* possible match -- did we use all of our input? */
      if (tokidx == ntok)
	{
	  *pntok = ntok;
	  return opcode;
	}

    match_failed:;
    }
  while (++opcode-alpha_opcodes < alpha_num_opcodes 
	 && !strcmp(opcode->name, first_opcode->name));

  if (*pcpumatch)
      *pcpumatch = got_cpu_match;

  return NULL;
}

/* Search forward through all variants of a macro looking for a syntax
   match.  */

static const struct alpha_macro *
find_macro_match(first_macro, tok, pntok)
     const struct alpha_macro *first_macro;
     const expressionS *tok;
     int *pntok;
{
  const struct alpha_macro *macro = first_macro;
  int ntok = *pntok;

  do
d455 2
a456 747
      const enum alpha_macro_arg *arg = macro->argsets;
      int tokidx = 0;

      while (*arg)
	{
	  switch (*arg)
	    {
	    case MACRO_EOA:
	      if (tokidx == ntok)
		return macro;
	      else
		tokidx = 0;
	      break;

	    case MACRO_IR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_register
		  || !is_ir_num(tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;
	    case MACRO_PIR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_pregister
		  || !is_ir_num(tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;
	    case MACRO_CPIR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_cpregister
		  || !is_ir_num(tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;
	    case MACRO_FPR:
	      if (tokidx >= ntok || tok[tokidx].X_op != O_register
		  || !is_fpr_num(tok[tokidx].X_add_number))
		goto match_failed;
	      ++tokidx;
	      break;

	    case MACRO_EXP:
	      if (tokidx >= ntok)
		goto match_failed;
	      switch (tok[tokidx].X_op)
		{
		case O_illegal:
		case O_absent:
		case O_register:
		case O_pregister:
		case O_cpregister:
		  goto match_failed;
		}
	      ++tokidx;
	      break;
		
	    match_failed:
	      while (*arg != MACRO_EOA)
		++arg;
	      tokidx = 0;
	      break;
	    }
	  ++arg;
	}
    }
  while (++macro-alpha_macros < alpha_num_macros 
	 && !strcmp(macro->name, first_macro->name));

  return NULL;
}

/* Insert an operand value into an instruction.  */

static unsigned
insert_operand(insn, operand, val, file, line)
     unsigned insn;
     const struct alpha_operand *operand;
     offsetT val;
     char *file;
     unsigned line;
{
  if (operand->bits != 32 && !(operand->flags & AXP_OPERAND_NOOVERFLOW))
    {
      offsetT min, max;

      if (operand->flags & AXP_OPERAND_SIGNED)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = -(1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      if (val < min || val > max)
	{
	  const char *err = 
	    "operand out of range (%s not between %d and %d)";
	  char buf[sizeof(val)*3+2];

	  sprint_value(buf, val);
	  if (file)
	    as_warn_where(file, line, err, buf, min, max);
	  else
	    as_warn(err, buf, min, max);
	}
    }

  if (operand->insert)
    {
      const char *errmsg = NULL;

      insn = (*operand->insert)(insn, val, &errmsg);
      if (errmsg)
	as_warn(errmsg);
    }
  else
    insn |= ((val & ((1 << operand->bits) - 1)) << operand->shift);

  return insn;
}

/* 
 * Turn an opcode description and a set of arguments into
 * an instruction and a fixup.
 */

static void
assemble_insn(opcode, tok, ntok, insn)
     const struct alpha_opcode *opcode;
     const expressionS *tok;
     int ntok;
     struct alpha_insn *insn;
{
  const unsigned char *argidx;
  unsigned image;
  int tokidx = 0;

  memset(insn, 0, sizeof(*insn));
  image = opcode->opcode;

  for (argidx = opcode->operands; *argidx; ++argidx)
    {
      const struct alpha_operand *operand = &alpha_operands[*argidx];
      const expressionS *t;

      if (operand->flags & AXP_OPERAND_FAKE)
	{
	  /* fake operands take no value and generate no fixup */
	  image = insert_operand(image, operand, 0, NULL, 0);
	  continue;
	}

      if (tokidx >= ntok)
	{
	  switch (operand->flags & AXP_OPERAND_OPTIONAL_MASK)
	    {
	    case AXP_OPERAND_DEFAULT_FIRST:
	      t = &tok[0];
	      break;
	    case AXP_OPERAND_DEFAULT_SECOND:
	      t = &tok[1];
	      break;
	    case AXP_OPERAND_DEFAULT_ZERO:
	      {
		static const expressionS zero_exp = { 0, 0, 0, O_constant, 1 };
		t = &zero_exp;
	      }
	      break;
	    default:
	      abort();
	    }
	}
      else
	t = &tok[tokidx++];

      switch (t->X_op)
	{
	case O_register:
	case O_pregister:
	case O_cpregister:
	  image = insert_operand(image, operand, regno(t->X_add_number),
				 NULL, 0);
	  break;

	case O_constant:
	  image = insert_operand(image, operand, t->X_add_number, NULL, 0);
	  break;

	default:
	  {
	    struct alpha_fixup *fixup;

	    if (insn->nfixups >= MAX_INSN_FIXUPS)
	      as_fatal("too many fixups");

	    fixup = &insn->fixups[insn->nfixups++];

	    fixup->exp = *t;
	    fixup->reloc = operand->default_reloc;
	  }
	  break;
	}
    }

  insn->insn = image;
}

/* 
 * Actually output an instruction with its fixup.
 */

static void
emit_insn (insn)
    struct alpha_insn *insn;
{
  char *f;
  int i;

  /* Take care of alignment duties */
  if (alpha_auto_align_on && alpha_current_align < 2)
    alpha_align (2, (char *) NULL, alpha_insn_label);
  if (alpha_current_align > 2)
    alpha_current_align = 2;
  alpha_insn_label = NULL;

  /* Write out the instruction.  */
  f = frag_more (4);
  md_number_to_chars (f, insn->insn, 4);

  /* Apply the fixups in order */
  for (i = 0; i < insn->nfixups; ++i)
    {
      struct alpha_fixup *fixup = &insn->fixups[i];
      int size, pcrel;
      fixS *fixP;

      /* Some fixups are only used internally and so have no howto */
      if (fixup->reloc > BFD_RELOC_UNUSED)
	size = 4, pcrel = 0;
#ifdef OBJ_ELF
      /* These relocation types are only used internally. */
      else if (fixup->reloc == BFD_RELOC_ALPHA_GPDISP_HI16
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_LO16)
	{
	  size = 2, pcrel = 0;
	}
#endif
      else
	{
	  reloc_howto_type *reloc_howto 
	    = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	  assert (reloc_howto);

	  size = bfd_get_reloc_size (reloc_howto);
	  pcrel = reloc_howto->pc_relative;
	}
      assert (size >= 1 && size <= 4);

      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal, size,
			  &fixup->exp, pcrel, fixup->reloc);

      /* Turn off complaints that the addend is too large for some fixups */
      switch (fixup->reloc)
	{
	case BFD_RELOC_ALPHA_GPDISP_LO16:
	case BFD_RELOC_ALPHA_LITERAL:
	case BFD_RELOC_GPREL32:
	  fixP->fx_no_overflow = 1;
	  break;
	default:
	  break;
	}
    }
}

/* Given an opcode name and a pre-tokenized set of arguments, assemble
   the insn, but do not emit it.

   Note that this implies no macros allowed, since we can't store more
   than one insn in an insn structure.  */

static void
assemble_tokens_to_insn(opname, tok, ntok, insn)
     const char *opname;
     const expressionS *tok;
     int ntok;
     struct alpha_insn *insn;
{
  const struct alpha_opcode *opcode;

  /* search opcodes */
  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);
  if (opcode)
    {
      int cpumatch;
      opcode = find_opcode_match (opcode, tok, &ntok, &cpumatch);
      if (opcode)
	{
	  assemble_insn (opcode, tok, ntok, insn);
	  return;
	}
      else if (cpumatch)
	as_bad ("inappropriate arguments for opcode `%s'", opname);
      else
	as_bad ("opcode `%s' not supported for target %s", opname,
	       alpha_target_name);
    }
  else
    as_bad ("unknown opcode `%s'", opname);
}

/* Given an opcode name and a pre-tokenized set of arguments, take the
   opcode all the way through emission.  */

static void
assemble_tokens (opname, tok, ntok, local_macros_on)
     const char *opname;
     const expressionS *tok;
     int ntok;
     int local_macros_on;
{
  int found_something = 0;
  const struct alpha_opcode *opcode;
  const struct alpha_macro *macro;
  int cpumatch = 1;

  /* search macros */
  if (local_macros_on)
    {
      macro = ((const struct alpha_macro *)
	       hash_find (alpha_macro_hash, opname));
      if (macro)
	{
	  found_something = 1;
	  macro = find_macro_match (macro, tok, &ntok);
	  if (macro)
	    {
	      (*macro->emit) (tok, ntok, macro->arg);
	      return;
	    }
	}
    }

  /* search opcodes */
  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);
  if (opcode)
    {
      found_something = 1;
      opcode = find_opcode_match (opcode, tok, &ntok, &cpumatch);
      if (opcode)
	{
	  struct alpha_insn insn;
	  assemble_insn (opcode, tok, ntok, &insn);
	  emit_insn (&insn);
	  return;
	}
    }
  
  if (found_something)
    if (cpumatch)
      as_bad ("inappropriate arguments for opcode `%s'", opname);
    else
      as_bad ("opcode `%s' not supported for target %s", opname,
	     alpha_target_name);
  else
    as_bad ("unknown opcode `%s'", opname);
}


/* Some instruction sets indexed by lg(size) */
static const char * const sextX_op[] = { "sextb", "sextw", "sextl", NULL };
static const char * const insXl_op[] = { "insbl", "inswl", "insll", "insql" };
static const char * const insXh_op[] = { NULL,    "inswh", "inslh", "insqh" };
static const char * const extXl_op[] = { "extbl", "extwl", "extll", "extql" };
static const char * const extXh_op[] = { NULL,    "extwh", "extlh", "extqh" };
static const char * const mskXl_op[] = { "mskbl", "mskwl", "mskll", "mskql" };
static const char * const mskXh_op[] = { NULL,    "mskwh", "msklh", "mskqh" };

/* Implement the ldgp macro.  */

static void 
emit_ldgp (tok, ntok, unused)
     const expressionS *tok;
     int ntok;
     void *unused;
{
#ifdef OBJ_AOUT
FIXME
#endif
#if defined(OBJ_ECOFF) || defined(OBJ_ELF)
  /* from "ldgp r1,n(r2)", generate "ldah r1,X(R2); lda r1,Y(r1)"
     with appropriate constants and relocations.  */
  struct alpha_insn insn;
  expressionS newtok[3];
  expressionS addend;

  /* We're going to need this symbol in md_apply_fix().  */
  (void) section_symbol (absolute_section);

#ifdef OBJ_ECOFF
  if (regno (tok[2].X_add_number) == AXP_REG_PV)
    ecoff_set_gp_prolog_size (0);
#endif

  newtok[0] = tok[0];
  set_tok_const (newtok[1], 0);
  newtok[2] = tok[2];

  assemble_tokens_to_insn ("ldah", newtok, 3, &insn);

  addend = tok[1];

#ifdef OBJ_ECOFF
  assert (addend.X_op == O_constant);
  addend.X_op = O_symbol;
  addend.X_add_symbol = alpha_gp_symbol;
#endif

  insn.nfixups = 1;
  insn.fixups[0].exp = addend;
  insn.fixups[0].reloc = BFD_RELOC_ALPHA_GPDISP_HI16;

  emit_insn (&insn);

  set_tok_preg (newtok[2], tok[0].X_add_number);
  
  assemble_tokens_to_insn ("lda", newtok, 3, &insn);

#ifdef OBJ_ECOFF
  addend.X_add_number += 4;
#endif

  insn.nfixups = 1;
  insn.fixups[0].exp = addend;
  insn.fixups[0].reloc = BFD_RELOC_ALPHA_GPDISP_LO16;

  emit_insn (&insn);
#endif /* OBJ_ECOFF || OBJ_ELF */
}

#ifdef OBJ_EVAX

/* Add symbol+addend to link pool.
   Return offset from basesym to entry in link pool.

   Add new fixup only if offset isn't 16bit.  */

valueT
add_to_link_pool (basesym, sym, addend)
     symbolS *basesym;
     symbolS *sym;
     offsetT addend;
{
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  valueT offset;
  bfd_reloc_code_real_type reloc_type;
  char *p;
  segment_info_type *seginfo = seg_info (alpha_link_section);
  fixS *fixp;

  offset = -basesym->sy_obj;

  /* @@@@ This assumes all entries in a given section will be of the same
     size...  Probably correct, but unwise to rely on.  */
  /* This must always be called with the same subsegment.  */

  if (seginfo->frchainP)
    for (fixp = seginfo->frchainP->fix_root;
	 fixp != (fixS *) NULL;
	 fixp = fixp->fx_next, offset += 8)
      {
	if (fixp->fx_addsy == sym && fixp->fx_offset == addend)
	  {
	    if (range_signed_16 (offset))
	      {
	        return offset;
	      }
	  }
      }

  /* Not found in 16bit signed range.  */

  subseg_set (alpha_link_section, 0);
  p = frag_more (8);
  memset (p, 0, 8);

  fix_new (frag_now, p - frag_now->fr_literal, 8, sym, addend, 0,
	   BFD_RELOC_64);

  subseg_set (current_section, current_subsec);
  seginfo->literal_pool_size += 8;
  return offset;
}

#endif /* OBJ_EVAX */

/* Load a (partial) expression into a target register.

   If poffset is not null, after the call it will either contain
   O_constant 0, or a 16-bit offset appropriate for any MEM format
   instruction.  In addition, pbasereg will be modified to point to
   the base register to use in that MEM format instruction.

   In any case, *pbasereg should contain a base register to add to the
   expression.  This will normally be either AXP_REG_ZERO or
   alpha_gp_register.  Symbol addresses will always be loaded via $gp,
   so "foo($0)" is interpreted as adding the address of foo to $0;
   i.e. "ldq $targ, LIT($gp); addq $targ, $0, $targ".  Odd, perhaps,
   but this is what OSF/1 does.

   Finally, the return value is true if the calling macro may emit a
   LITUSE reloc if otherwise appropriate.  */

static int
load_expression (targreg, exp, pbasereg, poffset)
     int targreg;
     const expressionS *exp;
     int *pbasereg;
     expressionS *poffset;
{
  int emit_lituse = 0;
  offsetT addend = exp->X_add_number;
  int basereg = *pbasereg;
  struct alpha_insn insn;
  expressionS newtok[3];

  switch (exp->X_op)
    {
    case O_symbol:
      {
#ifdef OBJ_ECOFF
	offsetT lit;

	/* attempt to reduce .lit load by splitting the offset from
	   its symbol when possible, but don't create a situation in
	   which we'd fail.  */
	if (!range_signed_32 (addend) &&
	    (alpha_noat_on || targreg == AXP_REG_AT))
	  {
	    lit = add_to_literal_pool (exp->X_add_symbol, addend,
				       alpha_lita_section, 8);
	    addend = 0;
	  }
	else
	  {
	    lit = add_to_literal_pool (exp->X_add_symbol, 0,
				       alpha_lita_section, 8);
	  }

	if (lit >= 0x8000)
	  as_fatal ("overflow in literal (.lita) table");

	/* emit "ldq r, lit(gp)" */

	if (basereg != alpha_gp_register && targreg == basereg)
	  {
	    if (alpha_noat_on)
	      as_bad ("macro requires $at register while noat in effect");
	    if (targreg == AXP_REG_AT)
	      as_bad ("macro requires $at while $at in use");
	    
	    set_tok_reg (newtok[0], AXP_REG_AT);
	  }
	else
	  set_tok_reg (newtok[0], targreg);
	set_tok_sym (newtok[1], alpha_lita_symbol, lit);
	set_tok_preg (newtok[2], alpha_gp_register);

	assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

	assert (insn.nfixups == 1);
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
#endif /* OBJ_ECOFF */
#ifdef OBJ_ELF
	/* emit "ldq r, gotoff(gp)" */

	if (basereg != alpha_gp_register && targreg == basereg)
	  {
	    if (alpha_noat_on)
	      as_bad ("macro requires $at register while noat in effect");
	    if (targreg == AXP_REG_AT)
	      as_bad ("macro requires $at while $at in use");
	    
	    set_tok_reg (newtok[0], AXP_REG_AT);
	  }
	else
	  set_tok_reg (newtok[0], targreg);

	if (!range_signed_32 (addend)
	    && (alpha_noat_on || targreg == AXP_REG_AT))
	  {
	    newtok[1] = *exp;
	    addend = 0;
	  }
	else
	  {
	    set_tok_sym (newtok[1], exp->X_add_symbol, 0);
	  }

	set_tok_preg (newtok[2], alpha_gp_register);

	assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

	assert (insn.nfixups == 1);
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
#endif /* OBJ_ELF */
#ifdef OBJ_EVAX
	offsetT link;

	/* Find symbol or symbol pointer in link section.  */

	if (exp->X_add_symbol == alpha_evax_proc.symbol)
	  {
	    if (range_signed_16 (addend))
	      {
		set_tok_reg (newtok[0], targreg);
		set_tok_const (newtok[1], addend);
		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("lda", newtok, 3, &insn);
		addend = 0;
	      }
	    else
	      {
		set_tok_reg (newtok[0], targreg);
		set_tok_const (newtok[1], 0);
		set_tok_preg (newtok[2], basereg);
		assemble_tokens_to_insn ("lda", newtok, 3, &insn);
	      }
	  }
	else
	  {
	    if (!range_signed_32 (addend))
	      {
		link = add_to_link_pool (alpha_evax_proc.symbol,
					 exp->X_add_symbol, addend);
		addend = 0;
	      }
	    else
	      {
		link = add_to_link_pool (alpha_evax_proc.symbol,
					 exp->X_add_symbol, 0);
	      }
	    set_tok_reg (newtok[0], targreg);
	    set_tok_const (newtok[1], link);
	    set_tok_preg (newtok[2], basereg);
	    assemble_tokens_to_insn ("ldq", newtok, 3, &insn);
	  }
#endif /* OBJ_EVAX */

	emit_insn(&insn);
#ifndef OBJ_EVAX
	emit_lituse = 1;

	if (basereg != alpha_gp_register && basereg != AXP_REG_ZERO)
	  {
	    /* emit "addq r, base, r" */

	    set_tok_reg (newtok[1], basereg);
	    set_tok_reg (newtok[2], targreg);
	    assemble_tokens ("addq", newtok, 3, 0);
	  }
#endif
	basereg = targreg;
      }
      break;

    case O_constant:
      break;

    case O_subtract:
      /* Assume that this difference expression will be resolved to an
	 absolute value and that that value will fit in 16 bits. */

      set_tok_reg (newtok[0], targreg);
      newtok[1] = *exp;
      set_tok_preg (newtok[2], basereg);
      assemble_tokens ("lda", newtok, 3, 0);

      if (poffset)
	set_tok_const (*poffset, 0);
      return 0;

    default:
      abort();
    }

  if (!range_signed_32 (addend))
    {
      offsetT lit;

      /* for 64-bit addends, just put it in the literal pool */

#ifdef OBJ_EVAX

      /* emit "ldq targreg, lit(basereg)"  */
      lit = add_to_link_pool (alpha_evax_proc.symbol,
			      section_symbol (absolute_section), addend);
      set_tok_reg (newtok[0], targreg);
      set_tok_const (newtok[1], lit);
      set_tok_preg (newtok[2], alpha_gp_register);
      assemble_tokens ("ldq", newtok, 3, 0);

#else

      if (alpha_lit8_section == NULL)
	{
	  create_literal_section (".lit8",
				  &alpha_lit8_section,
				  &alpha_lit8_symbol);
	}

      lit = add_to_literal_pool (NULL, addend, alpha_lit8_section, 8) - 0x8000;
      if (lit >= 0x8000)
	as_fatal ("overflow in literal (.lit8) table");

      /* emit "ldq litreg, .lit8+lit" */

      if (targreg == basereg)
	{
	  if (alpha_noat_on)
	    as_bad ("macro requires $at register while noat in effect");
	  if (targreg == AXP_REG_AT)
	    as_bad ("macro requires $at while $at in use");

	  set_tok_reg (newtok[0], AXP_REG_AT);
	}
      else
	set_tok_reg (newtok[0], targreg);
      set_tok_sym (newtok[1], alpha_lit8_symbol, lit);

      assemble_tokens ("ldq", newtok, 2, 1); /* note this does recurse */

      /* emit "addq litreg, base, target" */

      if (basereg != AXP_REG_ZERO)
	{
	  set_tok_reg (newtok[1], basereg);
	  set_tok_reg (newtok[2], targreg);
	  assemble_tokens ("addq", newtok, 3, 0);
	}
#endif /* !OBJ_EVAX */

      if (poffset)
	set_tok_const (*poffset, 0);
      *pbasereg = targreg;
d458 1
a458 1
  else
d460 1
a460 49
      offsetT low, high, extra, tmp;

      /* for 32-bit operands, break up the addend */

      low = sign_extend_16 (addend);
      tmp = addend - low;
      high = sign_extend_16 (tmp >> 16);

      if (tmp - (high << 16))
	{
	  extra = 0x4000;
	  tmp -= 0x40000000;
	  high = sign_extend_16 (tmp >> 16);
	}
      else
	extra = 0;

      set_tok_reg (newtok[0], targreg);
      set_tok_preg (newtok[2], basereg);

      if (extra)
	{
	  /* emit "ldah r, extra(r) */
	  set_tok_const (newtok[1], extra);
	  assemble_tokens ("ldah", newtok, 3, 0);
	  set_tok_preg (newtok[2], basereg = targreg);
	}

      if (high)
	{
	  /* emit "ldah r, high(r) */
	  set_tok_const (newtok[1], high);
	  assemble_tokens ("ldah", newtok, 3, 0);
	  basereg = targreg;
	  set_tok_preg (newtok[2], basereg);
	}

      if ((low && !poffset) || (!poffset && basereg != targreg))
	{
	  /* emit "lda r, low(base)" */
	  set_tok_const (newtok[1], low);
	  assemble_tokens ("lda", newtok, 3, 0);
	  basereg = targreg;
	  low = 0;
	}

      if (poffset)
	set_tok_const (*poffset, low);
      *pbasereg = basereg;
d462 3
a464 2

  return emit_lituse;
a466 4
/* The lda macro differs from the lda instruction in that it handles
   most simple expressions, particualrly symbol address loads and
   large constants.  */

d468 1
a468 4
emit_lda (tok, ntok, unused)
     const expressionS *tok;
     int ntok;
     void *unused;
d470 6
a475 1
  int basereg;
d477 7
a483 4
  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;
d485 7
a491 1
  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL);
d494 28
a521 2
/* The ldah macro differs from the ldah instruction in that it has $31
   as an implied base register.  */
d523 4
a526 5
static void
emit_ldah (tok, ntok, unused)
     const expressionS *tok;
     int ntok;
     void *unused;
d528 6
a533 5
  expressionS newtok[3];

  newtok[0] = tok[0];
  newtok[1] = tok[1];
  set_tok_preg (newtok[2], AXP_REG_ZERO);
d535 5
a539 1
  assemble_tokens ("ldah", newtok, 3, 0);
d541 1
a541 4

/* Handle all "simple" integer register loads -- ldq, ldq_l, ldq_u,
   etc.  They differ from the real instructions in that they do simple
   expressions like the lda macro.  */
d544 1
a544 4
emit_ir_load (tok, ntok, opname)
     const expressionS *tok;
     int ntok;
     void *opname;
d546 2
a547 3
  int basereg, lituse;
  expressionS newtok[3];
  struct alpha_insn insn;
d549 3
a551 14
  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;

  lituse = load_expression (tok[0].X_add_number, &tok[1], &basereg,
			    &newtok[1]);

  newtok[0] = tok[0];
  set_tok_preg (newtok[2], basereg);

  assemble_tokens_to_insn ((const char *)opname, newtok, 3, &insn);

  if (lituse)
d553 9
a561 10
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof(struct alpha_fixup) * insn.nfixups);
	}
      insn.nfixups++;
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_constant;
      insn.fixups[0].exp.X_add_number = 1;
d563 7
a569 2

  emit_insn (&insn);
a571 3
/* Handle fp register loads, and both integer and fp register stores.
   Again, we handle simple expressions.  */

d573 7
a579 13
emit_loadstore (tok, ntok, opname)
     const expressionS *tok;
     int ntok;
     void *opname;
{
  int basereg, lituse;
  expressionS newtok[3];
  struct alpha_insn insn;
  
  if (ntok == 2)
    basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
  else
    basereg = tok[2].X_add_number;
d581 7
a587 4
  if (tok[1].X_op != O_constant || !range_signed_16(tok[1].X_add_number))
    {
      if (alpha_noat_on)
	as_bad ("macro requires $at register while noat in effect");
d589 6
a594 3
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1]);
    }
  else
d596 2
a597 2
      newtok[1] = tok[1];
      lituse = 0;
d599 5
d605 6
a610 6
  newtok[0] = tok[0];
  set_tok_preg (newtok[2], basereg);

  assemble_tokens_to_insn ((const char *)opname, newtok, 3, &insn);

  if (lituse)
d612 2
a613 10
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof(struct alpha_fixup) * insn.nfixups);
	}
      insn.nfixups++;
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_constant;
      insn.fixups[0].exp.X_add_number = 1;
d615 4
a618 2

  emit_insn (&insn);
d621 1
a621 1
/* Load a half-word or byte as an unsigned value.  */
d623 5
a627 5
static void 
emit_ldXu (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     void *vlgsize;
d629 2
a630 1
  expressionS newtok[3];
d632 23
a654 4
  if (alpha_noat_on)
    as_bad ("macro requires $at register while noat in effect");
  
  /* emit "lda $at, exp" */
d656 5
a660 3
  memcpy (newtok, tok, sizeof(expressionS)*ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);
d662 3
a664 1
  /* emit "ldq_u targ, 0($at)" */
d666 7
a672 4
  newtok[0] = tok[0];
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);
d674 6
a679 1
  /* emit "extXl targ, $at, targ" */
d681 6
a686 4
  set_tok_reg (newtok[1], AXP_REG_AT);
  newtok[2] = newtok[0];
  assemble_tokens (extXl_op[(long)vlgsize], newtok, 3, 1);
}
d688 6
a693 1
/* Load a half-word or byte as a signed value.  */
d695 3
a697 8
static void 
emit_ldX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     void *vlgsize;
{
  emit_ldXu (tok, ntok, vlgsize);
  assemble_tokens (sextX_op[(long)vlgsize], tok, 1, 1);
d700 1
a700 2
/* Load an integral value from an unaligned address as an unsigned
   value.  */
d703 2
a704 4
emit_uldXu (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     void *vlgsize;
d706 2
a707 2
  long lgsize = (long)vlgsize;
  expressionS newtok[3];
d709 1
a709 2
  if (alpha_noat_on)
    as_bad ("macro requires $at register while noat in effect");
d711 2
a712 1
  /* emit "lda $at, exp" */
d714 5
a718 3
  memcpy (newtok, tok, sizeof(expressionS)*ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);
d720 17
a736 1
  /* emit "ldq_u $t9, 0($at)" */
d738 2
a739 4
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);
d741 7
a747 1
  /* emit "ldq_u $t10, size-1($at)" */
d749 3
a751 18
  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1<<lgsize)-1);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "extXl $t9, $at, $t9" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T9);
  assemble_tokens (extXl_op[lgsize], newtok, 3, 1);

  /* emit "extXh $t10, $at, $t10" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_reg (newtok[2], AXP_REG_T10);
  assemble_tokens (extXh_op[lgsize], newtok, 3, 1);

  /* emit "or $t9, $t10, targ" */
d753 2
a754 4
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_T10);
  newtok[2] = tok[0];
  assemble_tokens ("or", newtok, 3, 1);
a755 4
  
/* Load an integral value from an unaligned address as a signed value.
   Note that quads should get funneled to the unsigned load since we
   don't have to do the sign extension.  */
d757 3
a759 5
static void
emit_uldX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     void *vlgsize;
d761 6
a766 2
  emit_uldXu (tok, ntok, vlgsize);
  assemble_tokens (sextX_op[(long)vlgsize], tok, 1, 1);
a768 2
/* Implement the ldil macro.  */

d770 1
a770 4
emit_ldil (tok, ntok, unused)
     const expressionS *tok;
     int ntok;
     void *unused;
d772 2
a773 1
  expressionS newtok[2];
d775 2
a776 2
  memcpy (newtok, tok, sizeof(newtok));
  newtok[1].X_add_number = sign_extend_32 (tok[1].X_add_number);
d778 7
a784 2
  assemble_tokens ("lda", newtok, ntok, 1);
}
d786 1
a786 1
/* Store a half-word or byte.  */
d788 1
a788 7
static void
emit_stX (tok, ntok, vlgsize)
     const expressionS *tok;
     void *vlgsize;
{
  int lgsize = (int)(long)vlgsize;
  expressionS newtok[3];
d790 4
a793 2
  if (alpha_noat_on)
    as_bad("macro requires $at register while noat in effect");
d795 25
a819 36
  /* emit "lda $at, exp" */

  memcpy (newtok, tok, sizeof(expressionS)*ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);

  /* emit "ldq_u $t9, 0($at)" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "insXl src, $at, $t10" */

  newtok[0] = tok[0];
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T10);
  assemble_tokens (insXl_op[lgsize], newtok, 3, 1);

  /* emit "mskXl $t9, $at, $t9" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  newtok[2] = newtok[0];
  assemble_tokens (mskXl_op[lgsize], newtok, 3, 1);

  /* emit "or $t9, $t10, $t9" */

  set_tok_reg (newtok[1], AXP_REG_T10);
  assemble_tokens ("or", newtok, 3, 1);

  /* emit "stq_u $t9, 0($at) */

  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("stq_u", newtok, 3, 1);
d822 3
a824 7
/* Store an integer to an unaligned address.  */

static void
emit_ustX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     void *vlgsize;
d826 13
a838 72
  int lgsize = (int)(long)vlgsize;
  expressionS newtok[3];

  /* emit "lda $at, exp" */

  memcpy (newtok, tok, sizeof(expressionS)*ntok);
  newtok[0].X_add_number = AXP_REG_AT;
  assemble_tokens ("lda", newtok, ntok, 1);

  /* emit "ldq_u $9, 0($at)" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "ldq_u $10, size-1($at)" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize)-1);
  assemble_tokens ("ldq_u", newtok, 3, 1);

  /* emit "insXl src, $at, $t11" */

  newtok[0] = tok[0];
  set_tok_reg (newtok[1], AXP_REG_AT);
  set_tok_reg (newtok[2], AXP_REG_T11);
  assemble_tokens (insXl_op[lgsize], newtok, 3, 1);

  /* emit "insXh src, $at, $t12" */

  set_tok_reg (newtok[2], AXP_REG_T12);
  assemble_tokens (insXh_op[lgsize], newtok, 3, 1);

  /* emit "mskXl $t9, $at, $t9" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  newtok[2] = newtok[0];
  assemble_tokens (mskXl_op[lgsize], newtok, 3, 1);

  /* emit "mskXh $t10, $at, $t10" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  newtok[2] = newtok[0];
  assemble_tokens (mskXh_op[lgsize], newtok, 3, 1);

  /* emit "or $t9, $t11, $t9" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_reg (newtok[1], AXP_REG_T11);
  newtok[2] = newtok[0];
  assemble_tokens ("or", newtok, 3, 1);

  /* emit "or $t10, $t12, $t10" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_reg (newtok[1], AXP_REG_T12);
  newtok[2] = newtok[0];
  assemble_tokens ("or", newtok, 3, 1);

  /* emit "stq_u $t9, 0($at)" */

  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_AT);
  assemble_tokens ("stq_u", newtok, 3, 1);

  /* emit "stq_u $t10, size-1($at)" */

  set_tok_reg (newtok[0], AXP_REG_T10);
  set_tok_const (newtok[1], (1 << lgsize)-1);
  assemble_tokens ("stq_u", newtok, 3, 1);
d841 4
a844 8
/* Sign extend a half-word or byte.  The 32-bit sign extend is
   implemented as "addl $31, $r, $t" in the opcode table.  */

static void
emit_sextX (tok, ntok, vlgsize)
     const expressionS *tok;
     int ntok;
     void *vlgsize;
d846 8
a853 14
  int bitshift = 64 - 8*(1 << (long)vlgsize);
  expressionS newtok[3];

  /* emit "sll src,bits,dst" */

  newtok[0] = tok[0];
  set_tok_const (newtok[1], bitshift);
  newtok[2] = tok[ntok - 1];
  assemble_tokens ("sll", newtok, 3, 1);

  /* emit "sra dst,bits,dst" */

  newtok[0] = newtok[2];
  assemble_tokens ("sra", newtok, 3, 1);
d856 2
a857 1
/* Implement the division and modulus macros.  */
d859 3
a861 1
#ifdef OBJ_EVAX
d863 4
a866 8
/* Make register usage like in normal procedure call.
   Don't clobber PV and RA.  */

static void 
emit_division (tok, ntok, symname)
     const expressionS *tok;
     int ntok;
     void *symname;
d868 1
a868 14
  /* DIVISION and MODULUS. Yech.
   *
   * Convert
   *    OP x,y,result
   * to
   *    mov x,R16	# if x != R16
   *    mov y,R17	# if y != R17
   *    lda AT,__OP
   *    jsr AT,(AT),0
   *    mov R0,result
   *
   * with appropriate optimizations if R0,R16,R17 are the registers
   * specified by the compiler. 
   */
d870 2
a871 11
  int xr, yr, rr;
  symbolS *sym;
  expressionS newtok[3];

  xr = regno (tok[0].X_add_number);
  yr = regno (tok[1].X_add_number);
    
  if (ntok < 3)
    rr = xr;
  else
    rr = regno (tok[2].X_add_number);
d873 1
a873 2
  /* Move the operands into the right place */
  if (yr == AXP_REG_R16 && xr == AXP_REG_R17)
d875 3
a877 4
      /* They are in exactly the wrong order -- swap through AT */

      if (alpha_noat_on)
	as_bad ("macro requires $at register while noat in effect");
d879 3
a881 3
      set_tok_reg (newtok[0], AXP_REG_R16);
      set_tok_reg (newtok[1], AXP_REG_AT);
      assemble_tokens ("mov", newtok, 2, 1);
d883 6
a888 3
      set_tok_reg (newtok[0], AXP_REG_R17);
      set_tok_reg (newtok[1], AXP_REG_R16);
      assemble_tokens ("mov", newtok, 2, 1);
d890 9
a898 4
      set_tok_reg (newtok[0], AXP_REG_AT);
      set_tok_reg (newtok[1], AXP_REG_R17);
      assemble_tokens ("mov", newtok, 2, 1);
    }
d900 6
a905 7
    {
      if (yr == AXP_REG_R16)
	{
	  set_tok_reg (newtok[0], AXP_REG_R16);
	  set_tok_reg (newtok[1], AXP_REG_R17);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
d907 7
a913 6
      if (xr != AXP_REG_R16)
	{
	  set_tok_reg (newtok[0], xr);
	  set_tok_reg (newtok[1], AXP_REG_R16);
          assemble_tokens ("mov", newtok, 2, 1);
	}
d915 3
a917 7
      if (yr != AXP_REG_R16 && yr != AXP_REG_R17)
	{
	  set_tok_reg (newtok[0], yr);
	  set_tok_reg (newtok[1], AXP_REG_R17);
	  assemble_tokens ("mov", newtok, 2, 1);
	}
    }
d919 7
a925 1
  sym = symbol_find_or_make ((const char *)symname);
d927 3
a929 16
  set_tok_reg (newtok[0], AXP_REG_AT);
  set_tok_sym (newtok[1], sym, 0);
  assemble_tokens ("lda", newtok, 2, 1);

  /* Call the division routine */
  set_tok_reg (newtok[0], AXP_REG_AT);
  set_tok_cpreg (newtok[1], AXP_REG_AT);
  set_tok_const (newtok[2], 0);
  assemble_tokens ("jsr", newtok, 3, 1);

  /* Move the result to the right place */
  if (rr != AXP_REG_R0)
    {
      set_tok_reg (newtok[0], AXP_REG_R0);
      set_tok_reg (newtok[1], rr);
      assemble_tokens ("mov", newtok, 2, 1);
a930 33
}

#else /* !OBJ_EVAX */

static void 
emit_division (tok, ntok, symname)
     const expressionS *tok;
     int ntok;
     void *symname;
{
  /* DIVISION and MODULUS. Yech.
   * Convert
   *    OP x,y,result
   * to
   *    lda pv,__OP
   *    mov x,t10
   *    mov y,t11
   *    jsr t9,(pv),__OP
   *    mov t12,result
   *
   * with appropriate optimizations if t10,t11,t12 are the registers
   * specified by the compiler. 
   */

  int xr, yr, rr;
  symbolS *sym;
  expressionS newtok[3];

  xr = regno (tok[0].X_add_number);
  yr = regno (tok[1].X_add_number);
    
  if (ntok < 3)
    rr = xr;
a931 6
    rr = regno (tok[2].X_add_number);

  sym = symbol_find_or_make ((const char *)symname);

  /* Move the operands into the right place */
  if (yr == AXP_REG_T10 && xr == AXP_REG_T11)
d933 2
a934 16
      /* They are in exactly the wrong order -- swap through AT */

      if (alpha_noat_on)
	as_bad ("macro requires $at register while noat in effect");

      set_tok_reg (newtok[0], AXP_REG_T10);
      set_tok_reg (newtok[1], AXP_REG_AT);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_T11);
      set_tok_reg (newtok[1], AXP_REG_T10);
      assemble_tokens ("mov", newtok, 2, 1);

      set_tok_reg (newtok[0], AXP_REG_AT);
      set_tok_reg (newtok[1], AXP_REG_T11);
      assemble_tokens ("mov", newtok, 2, 1);
d936 2
a937 1
  else
d939 2
a940 1
      if (yr == AXP_REG_T10)
d942 2
a943 3
	  set_tok_reg (newtok[0], AXP_REG_T10);
	  set_tok_reg (newtok[1], AXP_REG_T11);
	  assemble_tokens ("mov", newtok, 2, 1);
d945 8
a952 2

      if (xr != AXP_REG_T10)
d954 7
a960 3
	  set_tok_reg (newtok[0], xr);
	  set_tok_reg (newtok[1], AXP_REG_T10);
          assemble_tokens ("mov", newtok, 2, 1);
d962 1
a962 2

      if (yr != AXP_REG_T10 && yr != AXP_REG_T11)
d964 5
a968 3
	  set_tok_reg (newtok[0], yr);
	  set_tok_reg (newtok[1], AXP_REG_T11);
	  assemble_tokens ("mov", newtok, 2, 1);
d970 3
d974 1
a974 24

  /* Call the division routine */
  set_tok_reg (newtok[0], AXP_REG_T9);
  set_tok_sym (newtok[1], sym, 0);
  assemble_tokens ("jsr", newtok, 2, 1);

  /* Reload the GP register */
#ifdef OBJ_AOUT
FIXME
#endif
#if defined(OBJ_ECOFF) || defined(OBJ_ELF)
  set_tok_reg (newtok[0], alpha_gp_register);
  set_tok_const (newtok[1], 0);
  set_tok_preg (newtok[2], AXP_REG_T9);
  assemble_tokens ("ldgp", newtok, 3, 1);
#endif

  /* Move the result to the right place */
  if (rr != AXP_REG_T12)
    {
      set_tok_reg (newtok[0], AXP_REG_T12);
      set_tok_reg (newtok[1], rr);
      assemble_tokens ("mov", newtok, 2, 1);
    }
d977 4
a980 11
#endif /* !OBJ_EVAX */

/* The jsr and jmp macros differ from their instruction counterparts
   in that they can load the target address and default most
   everything.  */

static void
emit_jsrjmp (tok, ntok, vopname)
     const expressionS *tok;
     int ntok;
     void *vopname;
d982 2
a983 4
  const char *opname = (const char *) vopname;
  struct alpha_insn insn;
  expressionS newtok[3];
  int r, tokidx = 0, lituse = 0;
d985 35
a1019 38
  if (tokidx < ntok && tok[tokidx].X_op == O_register)
    r = regno (tok[tokidx++].X_add_number);
  else
    r = strcmp (opname, "jmp") == 0 ? AXP_REG_ZERO : AXP_REG_RA;

  set_tok_reg (newtok[0], r);

  if (tokidx < ntok &&
      (tok[tokidx].X_op == O_pregister || tok[tokidx].X_op == O_cpregister))
    r = regno (tok[tokidx++].X_add_number);
#ifdef OBJ_EVAX
  /* keep register if jsr $n.<sym>  */
#else
  else
    {
      int basereg = alpha_gp_register;
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL);
    }
#endif

  set_tok_cpreg (newtok[1], r);

#ifdef OBJ_EVAX
  /* FIXME: Add hint relocs to BFD for evax.  */
#else
  if (tokidx < ntok)
    newtok[2] = tok[tokidx];
  else
#endif
    set_tok_const (newtok[2], 0);

  assemble_tokens_to_insn (opname, newtok, 3, &insn);

  /* add the LITUSE fixup */
  if (lituse)
    {
      assert (insn.nfixups < MAX_INSN_FIXUPS);
      if (insn.nfixups > 0)
d1021 2
a1022 2
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof(struct alpha_fixup) * insn.nfixups);
a1023 4
      insn.nfixups++;
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_constant;
      insn.fixups[0].exp.X_add_number = 3;
d1025 1
d1027 2
a1028 1
  emit_insn (&insn);
d1030 4
a1033 10
#if OBJ_EVAX
  /* reload PV from 0(FP) if it is our current base register.  */
  if (alpha_gp_register == AXP_REG_PV)
    {
      set_tok_reg (newtok[0], AXP_REG_PV);
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], AXP_REG_FP);
      assemble_tokens ("ldq", newtok, 3, 0);
    }
#endif
d1036 10
a1045 2
/* The ret and jcr instructions differ from their instruction
   counterparts in that everything can be defaulted.  */
d1048 3
a1050 4
emit_retjcr (tok, ntok, vopname)
     const expressionS *tok;
     int ntok;
     void *vopname;
d1052 2
a1053 3
  const char *opname = (const char *)vopname;
  expressionS newtok[3];
  int r, tokidx = 0;
d1055 7
a1061 4
  if (tokidx < ntok && tok[tokidx].X_op == O_register)
    r = regno (tok[tokidx++].X_add_number);
  else
    r = AXP_REG_ZERO;
d1063 8
a1070 16
  set_tok_reg (newtok[0], r);

  if (tokidx < ntok &&
      (tok[tokidx].X_op == O_pregister || tok[tokidx].X_op == O_cpregister))
    r = regno (tok[tokidx++].X_add_number);
  else
    r = AXP_REG_RA;

  set_tok_cpreg (newtok[1], r);

  if (tokidx < ntok)
    newtok[2] = tok[tokidx];
  else
    set_tok_const (newtok[2], strcmp(opname, "ret") == 0);

  assemble_tokens (opname, newtok, 3, 0);
a1071 5

/* Assembler directives */

/* Handle the .text pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */
d1074 2
a1075 3
s_alpha_text (i)
     int i;

d1077 2
a1078 8
  s_text (i);
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}  

/* Handle the .data pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */
d1081 2
a1082 2
s_alpha_data (i)
     int i;
d1084 2
a1085 9
  s_data (i);
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
}  

#ifndef OBJ_ELF

/* Handle the OSF/1 .comm pseudo quirks.  */
d1088 2
a1089 2
s_alpha_comm (ignore)
     int ignore;
d1091 1
a1091 79
  register char *name;
  register char c;
  register char *p;
  offsetT temp;
  register symbolS *symbolP;

  name = input_line_pointer;
  c = get_symbol_end ();

  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;

  SKIP_WHITESPACE ();

  /* Alpha OSF/1 compiler doesn't provide the comma, gcc does.  */
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      SKIP_WHITESPACE ();
    }
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (".COMMon length (%ld.) <0! Ignored.", (long) temp);
      ignore_rest_of_line ();
      return;
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (S_IS_DEFINED (symbolP))
    {
      as_bad ("Ignoring attempt to re-define symbol");
      ignore_rest_of_line ();
      return;
    }

#if OBJ_EVAX
  {
    /* Fill common area with zeros.  */
    char *pfrag;
    segT current_seg = now_seg;
    subsegT current_subseg = now_subseg;
  
    subseg_set (bss_section, 1);
    frag_align (3, 0);
  
    symbolP->sy_frag = frag_now;
    pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
		      temp, (char *)0);
      
    *pfrag = 0;
    S_SET_SEGMENT (symbolP, bss_section);

    subseg_set (current_seg, current_subseg);
  }
#endif

  if (S_GET_VALUE (symbolP))
    {
      if (S_GET_VALUE (symbolP) != (valueT) temp)
	as_bad ("Length of .comm \"%s\" is already %ld. Not changed to %ld.",
		S_GET_NAME (symbolP),
		(long) S_GET_VALUE (symbolP),
		(long) temp);
    }
  else
    {
      S_SET_VALUE (symbolP, (valueT) temp);
      S_SET_EXTERNAL (symbolP);
    }

#ifndef OBJ_EVAX
  know (symbolP->sy_frag == &zero_address_frag);
#endif

  demand_empty_rest_of_line ();
a1093 7
#endif /* ! OBJ_ELF */

#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)

/* Handle the .rdata pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

d1095 2
a1096 2
s_alpha_rdata (ignore)
     int ignore;
d1098 5
a1102 8
  int temp;

  temp = get_absolute_expression ();
  subseg_new (".rdata", 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
a1104 7
#endif

#ifdef OBJ_ECOFF

/* Handle the .sdata pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

d1106 2
a1107 2
s_alpha_sdata (ignore)
     int ignore;
d1109 4
a1112 1
  int temp;
d1114 9
a1122 6
  temp = get_absolute_expression ();
  subseg_new (".sdata", 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
a1123 1
#endif
d1125 4
a1128 8
#ifdef OBJ_ELF

/* Handle the .section pseudo-op.  This is like the usual one, but it
   clears alpha_insn_label and restores auto alignment.  */

static void 
s_alpha_section (ignore)
     int ignore;
d1130 3
a1132 5
  obj_elf_section (ignore);

  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
a1134 3
#endif  

#ifdef OBJ_EVAX
d1136 2
a1137 2
s_alpha_link (ignore)
     int ignore;
d1139 3
a1141 8
  int temp;

  temp = get_absolute_expression ();
  subseg_new (".link", 0);
  demand_empty_rest_of_line ();
  alpha_insn_label = NULL;
  alpha_auto_align_on = 1;
  alpha_current_align = 0;
a1143 3

/* .prologue */

d1145 3
a1147 2
s_alpha_prologue (ignore)
     int ignore;
d1149 3
a1151 3
  demand_empty_rest_of_line ();

  return;
a1153 3

/* Parse .ent directives.  */

d1155 2
a1156 2
s_alpha_ent (ignore)
     int ignore;
d1158 3
a1160 29
  symbolS *symbol;
  expressionS symexpr;

  alpha_evax_proc.pdsckind = 0;
  alpha_evax_proc.framereg = -1;
  alpha_evax_proc.framesize = 0;
  alpha_evax_proc.rsa_offset = 0;
  alpha_evax_proc.ra_save = AXP_REG_RA;
  alpha_evax_proc.fp_save = -1;
  alpha_evax_proc.imask = 0;
  alpha_evax_proc.fmask = 0;
  alpha_evax_proc.prologue = 0;
  alpha_evax_proc.type = 0;

  expression (&symexpr);

  if (symexpr.X_op != O_symbol)
    {
      as_fatal (".ent directive has no symbol");
      demand_empty_rest_of_line ();
      return;
    }

  symbol = make_expr_symbol (&symexpr);
  symbol->bsym->flags |= BSF_FUNCTION;
  alpha_evax_proc.symbol = symbol;

  demand_empty_rest_of_line ();
  return;
a1162 3

/* Parse .frame <framreg>,<framesize>,RA,<rsa_offset> directives.  */

d1164 3
a1166 2
s_alpha_frame (ignore)
     int ignore;
d1168 3
a1170 28
  long val;

  alpha_evax_proc.framereg = tc_get_register (1);

  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ','
      || get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn ("Bad .frame directive 1./2. param");
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }

  alpha_evax_proc.framesize = val;

  (void) tc_get_register (1);
  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ',')
    {
      as_warn ("Bad .frame directive 3./4. param");
      --input_line_pointer;
      demand_empty_rest_of_line ();
      return;
    }
  alpha_evax_proc.rsa_offset = get_absolute_expression ();

  return;
d1174 3
a1176 2
s_alpha_pdesc (ignore)
     int ignore;
d1178 1
a1178 8
  char *name;
  char name_end;
  long val;
  register char *p;
  expressionS exp;
  symbolS *entry_sym;
  fixS *fixp;
  segment_info_type *seginfo = seg_info (alpha_link_section);
d1180 1
a1180 1
  if (now_seg != alpha_link_section)
d1182 1
a1182 2
      as_bad (".pdesc directive not in link (.link) section");
      demand_empty_rest_of_line ();
d1185 3
a1187 3

  if ((alpha_evax_proc.symbol == 0)
      || (!S_IS_DEFINED (alpha_evax_proc.symbol)))
d1189 1
a1189 2
      as_fatal (".pdesc has no matching .ent");
      demand_empty_rest_of_line ();
d1192 2
a1193 5

  alpha_evax_proc.symbol->sy_obj = (valueT)seginfo->literal_pool_size;

  expression (&exp);
  if (exp.X_op != O_symbol)
d1195 13
a1207 24
      as_warn (".pdesc directive has no entry symbol");
      demand_empty_rest_of_line ();
      return;
    }

  entry_sym = make_expr_symbol (&exp);
  /* Save bfd symbol of proc desc in function symbol.  */
  alpha_evax_proc.symbol->bsym->udata.p = (PTR)entry_sym->bsym;

  SKIP_WHITESPACE ();
  if (*input_line_pointer++ != ',')
    {
      as_warn ("No comma after .pdesc <entryname>");
      demand_empty_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  name_end = get_symbol_end ();

  if (strncmp(name, "stack", 5) == 0)
    {
      alpha_evax_proc.pdsckind = PDSC_S_K_KIND_FP_STACK;
d1209 1
a1209 1
  else if (strncmp(name, "reg", 3) == 0)
d1211 8
a1218 1
      alpha_evax_proc.pdsckind = PDSC_S_K_KIND_FP_REGISTER;
d1220 2
a1221 5
  else if (strncmp(name, "null", 4) == 0)
    {
      alpha_evax_proc.pdsckind = PDSC_S_K_KIND_NULL;
    }
  else
d1223 2
a1224 2
      as_fatal ("unknown procedure kind");
      demand_empty_rest_of_line ();
d1228 17
a1244 2
  *input_line_pointer = name_end;
  demand_empty_rest_of_line ();
d1246 24
a1269 3
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
d1271 2
a1272 30
  frag_align (3, 0);
  p = frag_more (16);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;
  seginfo->literal_pool_size += 16;

  *p = alpha_evax_proc.pdsckind
       | ((alpha_evax_proc.framereg == 29) ? PDSC_S_M_BASE_REG_IS_FP : 0);
  *(p+1) = PDSC_S_M_NATIVE
	   | PDSC_S_M_NO_JACKET;

  switch (alpha_evax_proc.pdsckind)
    {
      case PDSC_S_K_KIND_NULL:
	*(p+2) = 0;
	*(p+3) = 0;
	break;
      case PDSC_S_K_KIND_FP_REGISTER:
	*(p+2) = alpha_evax_proc.fp_save;
	*(p+3) = alpha_evax_proc.ra_save;
	break;
      case PDSC_S_K_KIND_FP_STACK:
	md_number_to_chars (p+2, (valueT)alpha_evax_proc.rsa_offset, 2);
	break;
      default:		/* impossible */
	break;
    }

  *(p+4) = 0;
  *(p+5) = alpha_evax_proc.type & 0x0f;
d1274 2
a1275 2
  /* Signature offset.  */
  md_number_to_chars (p+6, (valueT)0, 2);
d1277 1
a1277 1
  fix_new_exp (frag_now, p-frag_now->fr_literal+8, 8, &exp, 0, BFD_RELOC_64);
d1279 3
a1281 2
  if (alpha_evax_proc.pdsckind == PDSC_S_K_KIND_NULL)
    return;
d1283 10
a1292 5
  /* Add dummy fix to make add_to_link_pool work.  */
  p = frag_more (8);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;
  seginfo->literal_pool_size += 8;
d1294 8
a1301 2
  /* pdesc+16: Size.  */
  md_number_to_chars (p, (valueT)alpha_evax_proc.framesize, 4);
d1303 6
a1308 1
  md_number_to_chars (p+4, (valueT)0, 2);
d1310 6
a1315 2
  /* Entry length.  */
  md_number_to_chars (p+6, alpha_evax_proc.prologue, 2);
d1317 11
a1327 2
  if (alpha_evax_proc.pdsckind == PDSC_S_K_KIND_FP_REGISTER)
    return;
d1329 8
a1336 5
  /* Add dummy fix to make add_to_link_pool work.  */
  p = frag_more (8);
  fixp = fix_new (frag_now, p - frag_now->fr_literal, 8, 0, 0, 0, 0);
  fixp->fx_done = 1;
  seginfo->literal_pool_size += 8;
d1338 9
a1346 1
  /* pdesc+24: register masks.  */
d1348 91
a1438 2
  md_number_to_chars (p, alpha_evax_proc.imask, 4);
  md_number_to_chars (p+4, alpha_evax_proc.fmask, 4);
d1440 24
a1463 2
  return;
}
d1465 32
d1498 103
a1600 6
static void
s_alpha_linkage (ignore)
     int ignore;
{
  expressionS exp;
  char *p;
d1602 57
a1658 3
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
d1660 22
a1681 13
  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_fatal ("No symbol after .linkage");
    }
  else
    {
      p = frag_more (LKP_S_K_SIZE);
      memset (p, 0, LKP_S_K_SIZE);
      fix_new_exp (frag_now, p - frag_now->fr_literal, LKP_S_K_SIZE, &exp, 0,\
		   BFD_RELOC_ALPHA_LINKAGE);
    }
  demand_empty_rest_of_line ();
d1683 10
a1692 2
  return;
}
d1694 2
d1697 21
a1717 4
static void
s_alpha_fp_save (ignore)
     int ignore;
{
d1719 34
a1752 1
  alpha_evax_proc.fp_save = tc_get_register (1);
d1754 1
a1754 3
  demand_empty_rest_of_line ();
  return;
}
d1756 4
d1761 4
a1764 5
static void
s_alpha_mask (ignore)
     int ignore;
{
  long val;
d1766 1
a1766 11
  if (get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn ("Bad .mask directive");
      --input_line_pointer;
    }
  else
    {
      alpha_evax_proc.imask = val;
      (void)get_absolute_expression ();
    }
  demand_empty_rest_of_line ();
d1768 6
a1773 2
  return;
}
d1775 1
d1777 366
a2142 5
static void
s_alpha_fmask (ignore)
     int ignore;
{
  long val;
d2144 29
a2172 4
  if (get_absolute_expression_and_terminator (&val) != ',')
    {
      as_warn ("Bad .fmask directive");
      --input_line_pointer;
d2174 2
a2175 1
  else
d2177 17
a2193 2
      alpha_evax_proc.fmask = val;
      (void) get_absolute_expression ();
a2194 1
  demand_empty_rest_of_line ();
d2196 2
a2197 1
  return;
d2200 4
a2203 5
static void
s_alpha_end (ignore)
     int ignore;
{
  char c;
d2205 2
a2206 4
  c = get_symbol_end ();
  *input_line_pointer = c;
  demand_empty_rest_of_line ();
  alpha_evax_proc.symbol = 0;
d2208 5
a2212 7
  return;
}


static void
s_alpha_file (ignore)
     int ignore;
d2214 5
a2218 3
  char* s;
  int length;
  extern char *demand_copy_string PARAMS ((int *lenP));
d2220 9
a2228 3
  get_absolute_expression ();
  s = demand_copy_string (&length);
  demand_empty_rest_of_line ();
d2230 4
a2233 3
  return;
}
#endif /* OBJ_EVAX  */
d2235 3
a2237 1
/* Handle the .gprel32 pseudo op.  */
d2239 4
a2242 6
static void
s_alpha_gprel32 (ignore)
     int ignore;
{
  expressionS e;
  char *p;
d2244 4
a2247 2
  SKIP_WHITESPACE ();
  expression (&e);
a2248 9
#ifdef OBJ_ELF
  switch (e.X_op)
    {
    case O_constant:
      e.X_add_symbol = section_symbol(absolute_section);
      e.X_op = O_symbol;
      /* FALLTHRU */
    case O_symbol:
      break;
d2250 2
a2251 1
      abort();
d2253 6
a2258 3
#else
#ifdef OBJ_ECOFF
  switch (e.X_op)
d2260 2
a2261 9
    case O_constant:
      e.X_add_symbol = section_symbol (absolute_section);
      /* fall through */
    case O_symbol:
      e.X_op = O_subtract;
      e.X_op_symbol = alpha_gp_symbol;
      break;
    default:
      abort ();
a2262 2
#endif
#endif
d2264 13
a2276 5
  if (alpha_auto_align_on && alpha_current_align < 2)
    alpha_align (2, (char *) NULL, alpha_insn_label);
  if (alpha_current_align > 2)
    alpha_current_align = 2;
  alpha_insn_label = NULL;
d2278 9
a2286 4
  p = frag_more (4);
  memset (p, 0, 4);
  fix_new_exp (frag_now, p-frag_now->fr_literal, 4,
	       &e, 0, BFD_RELOC_GPREL32);
d2288 8
d2297 4
a2300 7
/* Handle floating point allocation pseudo-ops.  This is like the
   generic vresion, but it makes sure the current label, if any, is
   correctly aligned.  */

static void
s_alpha_float_cons (type)
     int type;
d2302 1
a2302 3
  int log_size;

  switch (type)
a2303 2
    default:
    case 'f':
d2305 5
a2309 1
      log_size = 2;
d2312 4
a2315 4
    case 'd':
    case 'D':
    case 'G':
      log_size = 3;
d2318 2
a2319 6
    case 'x':
    case 'X':
    case 'p':
    case 'P':
      log_size = 4;
      break;
d2322 2
a2323 5
  if (alpha_auto_align_on && alpha_current_align < log_size)
    alpha_align (log_size, (char *) NULL, alpha_insn_label);
  if (alpha_current_align > log_size)
    alpha_current_align = log_size;
  alpha_insn_label = NULL;
d2325 10
a2334 1
  float_cons (type);
d2336 1
a2336 4

/* Handle the .proc pseudo op.  We don't really do much with it except
   parse it.  */

d2338 1
a2338 1
s_alpha_proc (is_static)
d2341 1
a2372 3
/* Handle the .set pseudo op.  This is used to turn on and off most of
   the assembler features.  */

d2394 1
a2394 1
    alpha_noat_on = !yesno;
d2396 1
a2396 1
    alpha_macros_on = yesno;
a2402 1

d2407 4
a2410 6
/* Handle the .base pseudo op.  This changes the assembler's notion of
   the $gp register.  */

static void
s_alpha_base (ignore)
     int ignore;
d2412 2
a2413 2
#if 0
  if (first_32bit_quadrant)
d2415 5
a2419 19
      /* not fatal, but it might not work in the end */
      as_warn ("File overrides no-base-register option.");
      first_32bit_quadrant = 0;
    }
#endif

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '$')
    {				/* $rNN form */
      input_line_pointer++;
      if (*input_line_pointer == 'r')
	input_line_pointer++;
    }

  alpha_gp_register = get_absolute_expression ();
  if (alpha_gp_register < 0 || alpha_gp_register > 31)
    {
      alpha_gp_register = AXP_REG_GP;
      as_warn ("Bad base register, using $%d.", alpha_gp_register);
a2420 2

  demand_empty_rest_of_line ();
d2431 2
a2432 2
  int align;
  char fill, *pfill;
d2435 4
a2438 2
  align = get_absolute_expression ();
  if (align > max_alignment)
d2440 2
a2441 7
      align = max_alignment;
      as_bad ("Alignment too large: %d. assumed", align);
    }
  else if (align < 0)
    {
      as_warn ("Alignment negative: 0 assumed");
      align = 0;
a2442 1

d2446 1
a2446 2
      fill = get_absolute_expression ();
      pfill = &fill;
d2449 2
a2450 3
    pfill = NULL;

  if (align != 0)
d2452 2
a2453 2
      alpha_auto_align_on = 1;
      alpha_align (align, pfill, alpha_insn_label);
d2457 1
a2457 1
      alpha_auto_align_on = 0;
a2462 2
/* Hook the normal string processor to reset known alignment.  */

d2464 4
a2467 2
s_alpha_stringer (terminate)
     int terminate;
d2469 24
a2492 3
  alpha_current_align = 0;
  alpha_insn_label = NULL;
  stringer (terminate);
d2495 2
a2496 1
/* Hook the normal space processing to reset known alignment.  */
d2498 2
a2499 3
static void
s_alpha_space (ignore)
     int ignore;
d2501 1
a2501 3
  alpha_current_align = 0;
  alpha_insn_label = NULL;
  s_space (ignore);
d2504 3
a2506 1
/* Hook into cons for auto-alignment.  */
d2508 3
a2510 3
void
alpha_cons_align (size)
     int size;
d2512 4
a2515 11
  int log_size;

  log_size = 0;
  while ((size >>= 1) != 0)
    ++log_size;

  if (alpha_auto_align_on && alpha_current_align < log_size)
    alpha_align (log_size, (char *) NULL, alpha_insn_label);
  if (alpha_current_align > log_size)
    alpha_current_align = log_size;
  alpha_insn_label = NULL;
a2516 2

/* The macro table */
d2518 3
a2520 86
const struct alpha_macro alpha_macros[] = {
/* Load/Store macros */
  { "lda",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldah",	emit_ldah, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "ldl",	emit_ir_load, "ldl",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldl_l",	emit_ir_load, "ldl_l",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldq",	emit_ir_load, "ldq",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldq_l",	emit_ir_load, "ldq_l",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldq_u",	emit_ir_load, "ldq_u",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldf",	emit_loadstore, "ldf",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldg",	emit_loadstore, "ldg",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "lds",	emit_loadstore, "lds",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldt",	emit_loadstore, "ldt",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },

  { "ldb",	emit_ldX, (void *)0,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldbu",	emit_ldXu, (void *)0,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldw",	emit_ldX, (void *)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldwu",	emit_ldXu, (void *)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "uldw",	emit_uldX, (void*)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldwu",	emit_uldXu, (void*)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldl",	emit_uldX, (void*)2,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldlu",	emit_uldXu, (void*)2,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldq",	emit_uldXu, (void*)3,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "ldgp",	emit_ldgp, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA } },

  { "ldi",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldil",	emit_ldil, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldiq",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
#if 0
  { "ldif"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldid"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldig"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldis"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldit"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
#endif
d2522 3
a2524 143
  { "stl",	emit_loadstore, "stl",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stl_c",	emit_loadstore, "stl_c",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stq",	emit_loadstore, "stq",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stq_c",	emit_loadstore, "stq_c",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stq_u",	emit_loadstore, "stq_u",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stf",	emit_loadstore, "stf",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "stg",	emit_loadstore, "stg",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "sts",	emit_loadstore, "sts",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "stt",	emit_loadstore, "stt",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },

  { "stb",	emit_stX, (void*)0,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stw",	emit_stX, (void*)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ustw",	emit_ustX, (void*)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ustl",	emit_ustX, (void*)2,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ustq",	emit_ustX, (void*)3,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },

/* Arithmetic macros */
#if 0
  { "absl"	emit_absl, 1, { IR } },
  { "absl"	emit_absl, 2, { IR, IR } },
  { "absl"	emit_absl, 2, { EXP, IR } },
  { "absq"	emit_absq, 1, { IR } },
  { "absq"	emit_absq, 2, { IR, IR } },
  { "absq"	emit_absq, 2, { EXP, IR } },
#endif

  { "sextb",	emit_sextX, (void *)0,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },
  { "sextw",	emit_sextX, (void *)1,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },

  { "divl",	emit_division, "__divl",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divlu",	emit_division, "__divlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divq",	emit_division, "__divq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divqu",	emit_division, "__divqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "reml",	emit_division, "__reml",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remlu",	emit_division, "__remlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remq",	emit_division, "__remq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remqu",	emit_division, "__remqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },

  { "jsr",	emit_jsrjmp, "jsr",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "jmp",	emit_jsrjmp, "jmp",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "ret",	emit_retjcr, "ret",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jcr",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jsr_coroutine",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
};

static const int alpha_num_macros
  = sizeof(alpha_macros) / sizeof(*alpha_macros);

/* The target specific pseudo-ops which we support.  */

const pseudo_typeS md_pseudo_table[] =
d2526 3
a2528 36
  {"common", s_comm, 0},	/* is this used? */
#ifndef OBJ_ELF
  {"comm", s_alpha_comm, 0},	/* osf1 compiler does this */
#endif
  {"text", s_alpha_text, 0},
  {"data", s_alpha_data, 0},
#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)
  {"rdata", s_alpha_rdata, 0},
#endif
#ifdef OBJ_ECOFF
  {"sdata", s_alpha_sdata, 0},
#endif
#ifdef OBJ_ELF
  {"section", s_alpha_section, 0},
  {"section.s", s_alpha_section, 0},
  {"sect", s_alpha_section, 0},
  {"sect.s", s_alpha_section, 0},
#endif
#ifdef OBJ_EVAX
  { "pdesc", s_alpha_pdesc, 0},
  { "linkage", s_alpha_linkage, 0},
  { "ent", s_alpha_ent, 0},
  { "frame", s_alpha_frame, 0},
  { "fp_save", s_alpha_fp_save, 0},
  { "mask", s_alpha_mask, 0},
  { "fmask", s_alpha_fmask, 0},
  { "link", s_alpha_link, 0},
  { "end", s_alpha_end, 0},
  { "file", s_alpha_file, 0},
#endif
  {"gprel32", s_alpha_gprel32, 0},
  {"t_floating", s_alpha_float_cons, 'd'},
  {"s_floating", s_alpha_float_cons, 'f'},
  {"f_floating", s_alpha_float_cons, 'F'},
  {"g_floating", s_alpha_float_cons, 'G'},
  {"d_floating", s_alpha_float_cons, 'D'},
d2530 7
a2536 11
  {"proc", s_alpha_proc, 0},
  {"aproc", s_alpha_proc, 1},
  {"set", s_alpha_set, 0},
  {"reguse", s_ignore, 0},
  {"livereg", s_ignore, 0},
  {"base", s_alpha_base, 0},		/*??*/
  {"option", s_ignore, 0},
  {"prologue", s_ignore, 0},
  {"aent", s_ignore, 0},
  {"ugen", s_ignore, 0},
  {"eflag", s_ignore, 0},
d2538 5
a2542 10
  {"align", s_alpha_align, 0},
  {"double", s_alpha_float_cons, 'd'},
  {"float", s_alpha_float_cons, 'f'},
  {"single", s_alpha_float_cons, 'f'},
  {"ascii", s_alpha_stringer, 0},
  {"asciz", s_alpha_stringer, 1},
  {"string", s_alpha_stringer, 1},
  {"space", s_alpha_space, 0},
  {"skip", s_alpha_space, 0},
  {"zero", s_alpha_space, 0},
d2544 7
a2550 3
/* We don't do any optimizing, so we can safely ignore these.  */
  {"noalias", s_ignore, 0},
  {"alias", s_ignore, 0},
d2552 2
a2553 2
  {NULL, 0, 0},
};
d2555 2
a2556 22

/* Build a BFD section with its flags set appropriately for the .lita,
   .lit8, or .lit4 sections.  */

static void
create_literal_section (name, secp, symp)
     const char *name;
     segT *secp;
     symbolS **symp;
{
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT new_sec;

  *secp = new_sec = subseg_new (name, 0);
  subseg_set (current_section, current_subsec);
  bfd_set_section_alignment (stdoutput, new_sec, 4);
  bfd_set_section_flags (stdoutput, new_sec,
			 SEC_RELOC | SEC_ALLOC | SEC_LOAD | SEC_READONLY
			 | SEC_DATA);

  S_CLEAR_EXTERNAL (*symp = section_symbol (new_sec));
d2559 2
a2560 1
#ifdef OBJ_ECOFF
d2562 3
a2564 6
/* @@@@@@ GP selection voodoo.  All of this seems overly complicated and
   unnecessary; which is the primary reason it's for ECOFF only.  */

static inline void
maybe_set_gp (sec)
     asection *sec;
d2566 1
a2566 6
  bfd_vma vma;
  if (!sec)
    return;
  vma = bfd_get_section_vma (foo, sec);
  if (vma && vma < alpha_gp_value)
    alpha_gp_value = vma;
d2569 4
a2572 2
static void
select_gp_value ()
d2574 4
a2577 1
  assert (alpha_gp_value == 0);
d2579 1
a2579 2
  /* Get minus-one in whatever width...  */
  alpha_gp_value = 0; alpha_gp_value--;
d2581 28
a2608 7
  /* Select the smallest VMA of these existing sections.  */
  maybe_set_gp (alpha_lita_section);
#if 0
  /* These were disabled before -- should we use them?  */
  maybe_set_gp (sdata);
  maybe_set_gp (lit8_sec);
  maybe_set_gp (lit4_sec);
d2610 44
d2655 21
a2675 2
/* @@@@ Will a simple 0x8000 work here?  If not, why not?  */
#define GP_ADJUSTMENT	(0x8000 - 0x10)
d2677 12
a2688 1
  alpha_gp_value += GP_ADJUSTMENT;
d2690 10
a2699 1
  S_SET_VALUE (alpha_gp_symbol, alpha_gp_value);
d2701 6
a2706 5
#ifdef DEBUG1
  printf ("Chose GP value of %lx\n", alpha_gp_value);
#endif
}
#endif /* OBJ_ECOFF */
d2708 3
a2710 4
/* Called internally to handle all alignment needs.  This takes care
   of eliding calls to frag_align if'n the cached current alignment
   says we've already got it, as well as taking care of the auto-align
   feature wrt labels.  */
d2712 6
a2717 8
static void
alpha_align (n, pfill, label)
     int n;
     char *pfill;
     symbolS *label;
{
  if (alpha_current_align >= n)
    return;
d2719 2
a2720 4
  if (pfill == NULL)
    {
      if (n > 2
	  && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
d2722 4
a2725 1
	  static char const nop[4] = { 0x1f, 0x04, 0xff, 0x47 };
d2727 4
a2730 11
	  /* First, make sure we're on a four-byte boundary, in case
	     someone has been putting .byte values into the text
	     section.  The DEC assembler silently fills with unaligned
	     no-op instructions.  This will zero-fill, then nop-fill
	     with proper alignment.  */
	  if (alpha_current_align < 2)
	    frag_align (2, 0);
	  frag_align_pattern (n, nop, sizeof nop);
	}
      else
	frag_align (n, 0);
a2731 4
  else
    frag_align (n, *pfill);

  alpha_current_align = n;
d2733 1
a2733 1
  if (label != NULL)
d2735 4
a2738 3
      assert (S_GET_SEGMENT (label) == now_seg);
      label->sy_frag = frag_now;
      S_SET_VALUE (label, (valueT) frag_now_fix ());
d2741 10
a2750 1
  record_alignment(now_seg, n);
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d90 2
a91 2
  void (*emit) PARAMS ((const expressionS *, int, const PTR));
  const PTR arg;
d157 1
a157 1
static int tokenize_arguments PARAMS ((char *, expressionS *, int));
d159 1
a159 1
  PARAMS ((const struct alpha_opcode *, const expressionS *, int *, int *));
d161 21
a181 31
  PARAMS ((const struct alpha_macro *, const expressionS *, int *));
static unsigned insert_operand
  PARAMS ((unsigned, const struct alpha_operand *, offsetT, char *, unsigned));
static void assemble_insn
  PARAMS ((const struct alpha_opcode *, const expressionS *, int,
	   struct alpha_insn *));
static void emit_insn PARAMS ((struct alpha_insn *));
static void assemble_tokens_to_insn
  PARAMS ((const char *, const expressionS *, int, struct alpha_insn *));
static void assemble_tokens
  PARAMS ((const char *, const expressionS *, int, int));

static int load_expression
  PARAMS ((int, const expressionS *, int *, expressionS *));

static void emit_ldgp PARAMS ((const expressionS *, int, const PTR));
static void emit_division PARAMS ((const expressionS *, int, const PTR));
static void emit_lda PARAMS ((const expressionS *, int, const PTR));
static void emit_ldah PARAMS ((const expressionS *, int, const PTR));
static void emit_ir_load PARAMS ((const expressionS *, int, const PTR));
static void emit_loadstore PARAMS ((const expressionS *, int, const PTR));
static void emit_jsrjmp PARAMS ((const expressionS *, int, const PTR));
static void emit_ldX PARAMS ((const expressionS *, int, const PTR));
static void emit_ldXu PARAMS ((const expressionS *, int, const PTR));
static void emit_uldX PARAMS ((const expressionS *, int, const PTR));
static void emit_uldXu PARAMS ((const expressionS *, int, const PTR));
static void emit_ldil PARAMS ((const expressionS *, int, const PTR));
static void emit_stX PARAMS ((const expressionS *, int, const PTR));
static void emit_ustX PARAMS ((const expressionS *, int, const PTR));
static void emit_sextX PARAMS ((const expressionS *, int, const PTR));
static void emit_retjcr PARAMS ((const expressionS *, int, const PTR));
d183 2
a184 2
static void s_alpha_text PARAMS ((int));
static void s_alpha_data PARAMS ((int));
d186 1
a186 1
static void s_alpha_comm PARAMS ((int));
d189 1
a189 1
static void s_alpha_rdata PARAMS ((int));
d192 1
a192 1
static void s_alpha_sdata PARAMS ((int));
d195 1
a195 1
static void s_alpha_section PARAMS ((int));
d197 8
a204 8
static void s_alpha_gprel32 PARAMS ((int));
static void s_alpha_float_cons PARAMS ((int));
static void s_alpha_proc PARAMS ((int));
static void s_alpha_set PARAMS ((int));
static void s_alpha_base PARAMS ((int));
static void s_alpha_align PARAMS ((int));
static void s_alpha_stringer PARAMS ((int));
static void s_alpha_space PARAMS ((int));
d206 1
a206 1
static void create_literal_section PARAMS ((const char *, segT *, symbolS **));
d208 1
a208 1
static void select_gp_value PARAMS ((void));
d210 1
a210 1
static void alpha_align PARAMS ((int, char *, symbolS *));
a243 3
#ifdef OBJ_EVAX
const char *md_shortopts = "Fm:g+1h:H";
#else
a244 1
#endif
a254 20
#ifdef OBJ_EVAX
#define AXP_REG_R0     0
#define AXP_REG_R16    16
#define AXP_REG_R17    17
#undef AXP_REG_T9
#define AXP_REG_T9     22
#undef AXP_REG_T10
#define AXP_REG_T10    23
#undef AXP_REG_T11
#define AXP_REG_T11    24
#undef AXP_REG_T12
#define AXP_REG_T12    25
#define AXP_REG_AI     25
#undef AXP_REG_FP
#define AXP_REG_FP     29

#undef AXP_REG_GP
#define AXP_REG_GP AXP_REG_PV
#endif /* OBJ_EVAX  */

d256 1
a256 1
static unsigned alpha_target = AXP_OPCODE_BASE;
d259 4
a302 6
/* Literal for .litX+0x8000 within .lita */
#ifdef OBJ_ECOFF
static offsetT alpha_lit4_literal;
static offsetT alpha_lit8_literal;
#endif

d334 1
a334 176
static struct {
  symbolS *symbol;	/* proc pdesc symbol */
  int pdsckind;
  int framereg;		/* register for frame pointer */
  int framesize;	/* size of frame */
  int rsa_offset;
  int ra_save;
  int fp_save;
  long imask;
  long fmask;
  int type;
  int prologue;
} alpha_evax_proc;

static int alpha_flag_hash_long_names = 0;		/* -+ */
static int alpha_flag_show_after_trunc = 0;		/* -H */
static int alpha_flag_no_hash_mixed_case = 0;		/* -h NUM */

/* Flag that determines how we map names.  This takes several values, and
 * is set with the -h switch.  A value of zero implies names should be
 * upper case, and the presence of the -h switch inhibits the case hack.
 * No -h switch at all sets alpha_vms_name_mapping to 0, and allows case hacking.
 * A value of 2 (set with -h2) implies names should be
 * all lower case, with no case hack.  A value of 3 (set with -h3) implies
 * that case should be preserved.  */

/* If the -+ switch is given, then the hash is appended to any name that is
 * longer than 31 characters, regardless of the setting of the -h switch.
 */

static char alpha_vms_name_mapping = 0;

static int alpha_basereg_clobbered;
#endif

/* The macro table */

static const struct alpha_macro alpha_macros[] = {
/* Load/Store macros */
  { "lda",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldah",	emit_ldah, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "ldl",	emit_ir_load, "ldl",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldl_l",	emit_ir_load, "ldl_l",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldq",	emit_ir_load, "ldq",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldq_l",	emit_ir_load, "ldq_l",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldq_u",	emit_ir_load, "ldq_u",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldf",	emit_loadstore, "ldf",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldg",	emit_loadstore, "ldg",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "lds",	emit_loadstore, "lds",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldt",	emit_loadstore, "ldt",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },

  { "ldb",	emit_ldX, (PTR)0,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldbu",	emit_ldXu, (PTR)0,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldw",	emit_ldX, (PTR)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldwu",	emit_ldXu, (PTR)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "uldw",	emit_uldX, (PTR)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldwu",	emit_uldXu, (PTR)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldl",	emit_uldX, (PTR)2,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldlu",	emit_uldXu, (PTR)2,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "uldq",	emit_uldXu, (PTR)3,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },

  { "ldgp",	emit_ldgp, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA } },

  { "ldi",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldil",	emit_ldil, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ldiq",	emit_lda, NULL,
    { MACRO_IR, MACRO_EXP, MACRO_EOA } },
#if 0
  { "ldif"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldid"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldig"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldis"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "ldit"	emit_ldiq, NULL,
    { MACRO_FPR, MACRO_EXP, MACRO_EOA } },
#endif

  { "stl",	emit_loadstore, "stl",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stl_c",	emit_loadstore, "stl_c",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stq",	emit_loadstore, "stq",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stq_c",	emit_loadstore, "stq_c",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stq_u",	emit_loadstore, "stq_u",
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stf",	emit_loadstore, "stf",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "stg",	emit_loadstore, "stg",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "sts",	emit_loadstore, "sts",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },
  { "stt",	emit_loadstore, "stt",
    { MACRO_FPR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_FPR, MACRO_EXP, MACRO_EOA } },

  { "stb",	emit_stX, (PTR)0,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "stw",	emit_stX, (PTR)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ustw",	emit_ustX, (PTR)1,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ustl",	emit_ustX, (PTR)2,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },
  { "ustq",	emit_ustX, (PTR)3,
    { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA } },

/* Arithmetic macros */
#if 0
  { "absl"	emit_absl, 1, { IR } },
  { "absl"	emit_absl, 2, { IR, IR } },
  { "absl"	emit_absl, 2, { EXP, IR } },
  { "absq"	emit_absq, 1, { IR } },
  { "absq"	emit_absq, 2, { IR, IR } },
  { "absq"	emit_absq, 2, { EXP, IR } },
a335 86

  { "sextb",	emit_sextX, (PTR)0,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },
  { "sextw",	emit_sextX, (PTR)1,
    { MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      /* MACRO_EXP, MACRO_IR, MACRO_EOA */ } },

  { "divl",	emit_division, "__divl",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divlu",	emit_division, "__divlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divq",	emit_division, "__divq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "divqu",	emit_division, "__divqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "reml",	emit_division, "__reml",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remlu",	emit_division, "__remlu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remq",	emit_division, "__remq",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },
  { "remqu",	emit_division, "__remqu",
    { MACRO_IR, MACRO_IR, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_IR, MACRO_EOA,
      /* MACRO_IR, MACRO_EXP, MACRO_IR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA */ } },

  { "jsr",	emit_jsrjmp, "jsr",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "jmp",	emit_jsrjmp, "jmp",
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
  { "ret",	emit_retjcr, "ret",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jcr",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
  { "jsr_coroutine",	emit_retjcr, "jcr",
    { MACRO_IR, MACRO_EXP, MACRO_EOA,
      MACRO_IR, MACRO_EOA,
      MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_EXP, MACRO_EOA,
      MACRO_EOA } },
};

static const int alpha_num_macros
  = sizeof(alpha_macros) / sizeof(*alpha_macros);
d456 1
a456 1
      bfd_set_section_flags(stdoutput, sec,
d606 9
a614 25
	  { "21064", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "21064a", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "21066", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "21068", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "21164", AXP_OPCODE_BASE|AXP_OPCODE_EV5 },
	  /* Do we have CIX extension here? */
	  { "21164a", AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX },
	  /* Still same PALcodes? */
	  { "21164pc", (AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX
			|AXP_OPCODE_CIX|AXP_OPCODE_MAX) },
	  /* All new PALcodes?  Extras? */
	  { "21264", (AXP_OPCODE_BASE|AXP_OPCODE_BWX
		      |AXP_OPCODE_CIX|AXP_OPCODE_MAX) },

	  { "ev4", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "ev45", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "lca45", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
	  { "ev5", AXP_OPCODE_BASE|AXP_OPCODE_EV5 },
	  { "ev56", AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX },
	  { "pca56", (AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX
		      |AXP_OPCODE_CIX|AXP_OPCODE_MAX) },
	  { "ev6", (AXP_OPCODE_BASE|AXP_OPCODE_BWX
		    |AXP_OPCODE_CIX|AXP_OPCODE_MAX) },

	  { "all", AXP_OPCODE_BASE },
d617 1
a617 1

a628 17
#if OBJ_EVAX
    case '+':			/* For g++.  Hash any name > 31 chars long. */
      alpha_flag_hash_long_names = 1;
      break;

    case 'H':			/* Show new symbol after hash truncation */
      alpha_flag_show_after_trunc = 1;
      break;

    case 'h':			/* No hashing of mixed-case names */
      {
	alpha_vms_name_mapping = atoi (arg);
	alpha_flag_no_hash_mixed_case = 1;
      }
      break;
#endif

a649 9
#ifdef OBJ_EVAX
  fputs ("\
VMS options:\n\
-+			hash encode names longer than 31 characters\n\
-H			show new symbol after hash truncation\n\
-h NUM			don't hash mixed-case names, and adjust case:\n\
			0 = upper, 2 = lower, 3 = preserve case\n",
	stream);
#endif
d701 1
a701 1
	fixP->fx_offset = (next->fx_frag->fr_address + next->fx_where
d779 1
a779 1
    case BFD_RELOC_ALPHA_ELF_LITERAL:
d792 1
a792 1
	if ((int)fixP->fx_r_type <= 0)
d796 2
a797 2
	assert (-(int)fixP->fx_r_type < alpha_num_operands);
	operand = &alpha_operands[-(int)fixP->fx_r_type];
d800 1
a800 1
	   resolution and have no representation in the object file.
d823 1
a823 1

d832 1
a832 1
/*
d863 1
a863 1
	      num = (name[0] - '0') * 10 + name[1] - '0';
a932 1
#ifdef OBJ_ECOFF
a933 4
#endif
#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_ELF_LITERAL:
#endif
d948 2
a949 1
      assert((int)f->fx_r_type < 0 && -(int)f->fx_r_type < alpha_num_operands);
d994 1
a994 1
  assert ((int)fixp->fx_r_type > 0);
d1023 1
a1023 1
      /*
d1080 1
a1080 1
  memset (tok, 0, sizeof (*tok) * ntok);
d1082 1
a1082 1
  /* Save and restore input_line_pointer around this function */
d1085 1
a1085 1

d1241 1
a1241 1
  while (++opcode-alpha_opcodes < alpha_num_opcodes
d1317 1
a1317 1

d1327 1
a1327 1
  while (++macro-alpha_macros < alpha_num_macros
d1360 1
a1360 1
	  const char *err =
d1362 1
a1362 1
	  char buf[sizeof (val) * 3 + 2];
d1376 1
a1376 1
      insn = (*operand->insert) (insn, val, &errmsg);
d1378 1
a1378 1
	as_warn (errmsg);
d1386 1
a1386 1
/*
d1402 1
a1402 1
  memset (insn, 0, sizeof (*insn));
d1472 1
a1472 1
/*
d1502 1
a1502 1
      if (fixup->reloc < 0)
d1514 1
a1514 1
	  reloc_howto_type *reloc_howto
a1529 1
#ifdef OBJ_ECOFF
a1530 4
#endif
#ifdef OBJ_ELF
	case BFD_RELOC_ALPHA_ELF_LITERAL:
#endif
d1622 1
a1622 1

a1641 3
static const char * const stX_op[] = { "stb", "stw", "stl", "stq" };
static const char * const ldX_op[] = { "ldb", "ldw", "ldll", "ldq" };
static const char * const ldXu_op[] = { "ldbu", "ldwu", NULL, NULL };
d1645 1
a1645 1
static void
d1649 1
a1649 1
     const PTR unused;
d1690 1
a1690 1

d1826 1
a1826 1

d1848 1
a1848 1

d1870 1
a1870 1
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
a1874 10
	if (alpha_basereg_clobbered)
	  {
	    /* no basereg, reload basreg from 0(FP).  */
	    set_tok_reg (newtok[0], targreg);
	    set_tok_const (newtok[1], 0);
	    set_tok_preg (newtok[2], AXP_REG_FP);
	    basereg = targreg;
	    assemble_tokens ("ldq", newtok, 3, 0);
	  }

a1915 1

a1927 1

d1959 1
d1967 1
a1974 7

#ifdef OBJ_ECOFF
	  alpha_lit8_literal = add_to_literal_pool (alpha_lit8_symbol, 0x8000,
						    alpha_lita_section, 8);
	  if (alpha_lit8_literal >= 0x8000)
	    as_fatal ("overflow in literal (.lita) table");
#endif
d1981 1
a1981 1
      /* emit "lda litreg, .lit8+0x8000" */
d1994 1
a1994 7
#ifdef OBJ_ECOFF
      set_tok_sym (newtok[1], alpha_lita_symbol, alpha_lit8_literal);
#endif
#ifdef OBJ_ELF
      set_tok_sym (newtok[1], alpha_lit8_symbol, 0x8000);
#endif
      set_tok_preg (newtok[2], alpha_gp_register);
d1996 1
a1996 32
      assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

      assert (insn.nfixups == 1);
#ifdef OBJ_ECOFF
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITERAL;
#endif
#ifdef OBJ_ELF
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
#endif

      emit_insn (&insn);

      /* emit "ldq litreg, lit(litreg)" */

      set_tok_const (newtok[1], lit);
      set_tok_preg (newtok[2], newtok[0].X_add_number);

      assemble_tokens_to_insn ("ldq", newtok, 3, &insn);

      assert (insn.nfixups < MAX_INSN_FIXUPS);
      if (insn.nfixups > 0)
	{
	  memmove (&insn.fixups[1], &insn.fixups[0],
		   sizeof(struct alpha_fixup) * insn.nfixups);
	}
      insn.nfixups++;
      insn.fixups[0].reloc = BFD_RELOC_ALPHA_LITUSE;
      insn.fixups[0].exp.X_op = O_constant;
      insn.fixups[0].exp.X_add_number = 1;
      emit_lituse = 0;

      emit_insn (&insn);
d2076 1
a2076 1
     const PTR unused;
d2095 1
a2095 1
     const PTR unused;
d2114 1
a2114 1
     const PTR opname;
a2147 9
#if OBJ_EVAX
    /* special hack. If the basereg is clobbered for a call
       all lda's before the call don't have a basereg.  */
  if ((tok[0].X_op == O_register)
     && (tok[0].X_add_number == alpha_gp_register))
    {
      alpha_basereg_clobbered = 1;
    }
#endif
d2157 1
a2157 1
     const PTR opname;
d2162 1
a2162 1

d2205 1
a2205 1
static void
d2209 1
a2209 1
     const PTR vlgsize;
d2211 1
a2211 5
  if (alpha_target & AXP_OPCODE_BWX)
    emit_ir_load (tok, ntok, ldXu_op[(long)vlgsize]);
  else
    {
      expressionS newtok[3];
d2213 4
a2216 2
      if (alpha_noat_on)
	as_bad ("macro requires $at register while noat in effect");
d2218 3
a2220 1
      /* emit "lda $at, exp" */
d2222 1
a2222 3
      memcpy (newtok, tok, sizeof (expressionS) * ntok);
      newtok[0].X_add_number = AXP_REG_AT;
      assemble_tokens ("lda", newtok, ntok, 1);
d2224 4
a2227 1
      /* emit "ldq_u targ, 0($at)" */
d2229 1
a2229 4
      newtok[0] = tok[0];
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens ("ldq_u", newtok, 3, 1);
d2231 3
a2233 6
      /* emit "extXl targ, $at, targ" */

      set_tok_reg (newtok[1], AXP_REG_AT);
      newtok[2] = newtok[0];
      assemble_tokens (extXl_op[(long)vlgsize], newtok, 3, 1);
    }
d2238 1
a2238 1
static void
d2242 1
a2242 1
     const PTR vlgsize;
d2255 1
a2255 1
     const PTR vlgsize;
d2265 1
a2265 1
  memcpy (newtok, tok, sizeof (expressionS) * ntok);
d2302 1
a2302 1

d2311 1
a2311 1
     const PTR vlgsize;
d2323 1
a2323 1
     const PTR unused;
d2338 1
a2338 2
     int ntok;
     const PTR vlgsize;
d2341 1
d2343 2
a2344 5
  if (alpha_target & AXP_OPCODE_BWX)
    emit_loadstore (tok, ntok, stX_op[lgsize]);
  else
    {
      expressionS newtok[3];
d2346 1
a2346 2
      if (alpha_noat_on)
	as_bad("macro requires $at register while noat in effect");
d2348 3
a2350 1
      /* emit "lda $at, exp" */
d2352 1
a2352 3
      memcpy (newtok, tok, sizeof (expressionS) * ntok);
      newtok[0].X_add_number = AXP_REG_AT;
      assemble_tokens ("lda", newtok, ntok, 1);
d2354 4
a2357 1
      /* emit "ldq_u $t9, 0($at)" */
d2359 1
a2359 4
      set_tok_reg (newtok[0], AXP_REG_T9);
      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens ("ldq_u", newtok, 3, 1);
d2361 4
a2364 1
      /* emit "insXl src, $at, $t10" */
d2366 1
a2366 4
      newtok[0] = tok[0];
      set_tok_reg (newtok[1], AXP_REG_AT);
      set_tok_reg (newtok[2], AXP_REG_T10);
      assemble_tokens (insXl_op[lgsize], newtok, 3, 1);
d2368 3
a2370 1
      /* emit "mskXl $t9, $at, $t9" */
d2372 1
a2372 3
      set_tok_reg (newtok[0], AXP_REG_T9);
      newtok[2] = newtok[0];
      assemble_tokens (mskXl_op[lgsize], newtok, 3, 1);
d2374 2
a2375 1
      /* emit "or $t9, $t10, $t9" */
d2377 1
a2377 2
      set_tok_reg (newtok[1], AXP_REG_T10);
      assemble_tokens ("or", newtok, 3, 1);
d2379 3
a2381 6
      /* emit "stq_u $t9, 0($at) */

      set_tok_const (newtok[1], 0);
      set_tok_preg (newtok[2], AXP_REG_AT);
      assemble_tokens ("stq_u", newtok, 3, 1);
    }
d2390 1
a2390 1
     const PTR vlgsize;
d2397 1
a2397 1
  memcpy (newtok, tok, sizeof (expressionS) * ntok);
d2473 1
a2473 1
     const PTR vlgsize;
d2475 2
a2476 8
  long lgsize = (long)vlgsize;

  if (alpha_target & AXP_OPCODE_BWX)
    assemble_tokens (sextX_op[lgsize], tok, ntok, 0);
  else
    {
      int bitshift = 64 - 8 * (1 << lgsize);
      expressionS newtok[3];
d2478 1
a2478 1
      /* emit "sll src,bits,dst" */
d2480 4
a2483 4
      newtok[0] = tok[0];
      set_tok_const (newtok[1], bitshift);
      newtok[2] = tok[ntok - 1];
      assemble_tokens ("sll", newtok, 3, 1);
d2485 1
a2485 1
      /* emit "sra dst,bits,dst" */
d2487 2
a2488 3
      newtok[0] = newtok[2];
      assemble_tokens ("sra", newtok, 3, 1);
    }
d2498 1
a2498 1
static void
d2502 1
a2502 1
     const PTR symname;
d2516 1
a2516 1
   * specified by the compiler.
d2525 1
a2525 1

d2598 1
a2598 1
static void
d2602 1
a2602 1
     const PTR symname;
d2615 1
a2615 1
   * specified by the compiler.
d2624 1
a2624 1

d2711 1
a2711 1
     const PTR vopname;
a2768 2
  alpha_basereg_clobbered = 0;

d2787 1
a2787 1
     const PTR vopname;
d2830 1
a2830 1
}
d2843 1
a2843 1
}
d2898 1
a2898 1

d2901 1
a2901 1

d2905 1
a2905 1

d2982 1
a2982 1
static void
d2993 1
a2993 1
#endif
a3016 1
  alpha_basereg_clobbered = 0;
a3341 1
  alpha_basereg_clobbered = 0;
d3351 1
a3351 1
  symbolS *s;
a3352 2
  static char case_hack[32];

a3354 9
  sprintf (case_hack, "<CASE:%01d%01d%01d%01d>",
	    alpha_flag_hash_long_names,
	    alpha_flag_show_after_trunc,
	    alpha_flag_no_hash_mixed_case,
	    alpha_vms_name_mapping);

  s = symbol_find_or_make (case_hack);
  s->bsym->flags |= BSF_FILE;

d3356 1
a3356 2
  s = symbol_find_or_make (demand_copy_string (&length));
  s->bsym->flags |= BSF_FILE;
d3654 229
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1989, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d7 1
a7 1
   Modified by Klaus K"ampf for EVAX (openVMS/Alpha) support.
a206 3
#ifdef OBJ_EVAX
static void s_alpha_section PARAMS ((int));
#endif
a319 2
static segT alpha_ctors_section;
static segT alpha_dtors_section;
a329 2
static symbolS *alpha_ctors_symbol;
static symbolS *alpha_dtors_symbol;
a367 3
/* Whether the debugging option was seen.  */
static int alpha_debug;

d386 9
d396 2
a397 2
/* If the -+ switch is given, then a hash is appended to any name that is
 * longer than 64 characters, else longer symbol names are truncated.
d400 2
a812 2
extern char *vax_md_atof PARAMS ((int, char *, int *));

d823 1
d890 3
a892 1
      alpha_debug = 1;
d942 2
a943 2
#ifdef OBJ_EVAX
    case '+':			/* For g++.  Hash any name > 63 chars long. */
d951 5
a955 1
    case 'h':			/* for gnu-c/vax compatibility.  */
d983 4
a986 2
-+			hash encode (don't truncate) names longer than 64 characters\n\
-H			show new symbol after hash truncation\n",
a1123 1
    case BFD_RELOC_ALPHA_CODEADDR:
d1131 1
a1131 1
	if ((int)fixP->fx_r_type >= 0)
d1159 1
a1159 1
		    "type %d reloc done?\n", (int)fixP->fx_r_type);
a1281 1
    case BFD_RELOC_ALPHA_CODEADDR:
a1312 20
    case BFD_RELOC_ALPHA_GPDISP_HI16:
    case BFD_RELOC_ALPHA_GPDISP_LO16:
    case BFD_RELOC_ALPHA_GPDISP:
      return 0;

#ifdef OBJ_ECOFF
    case BFD_RELOC_ALPHA_LITERAL:
#endif
#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_ELF_LITERAL:
#endif
#ifdef OBJ_EVAX
    case BFD_RELOC_ALPHA_LINKAGE:
    case BFD_RELOC_ALPHA_CODEADDR:
#endif
      return 1;

    case BFD_RELOC_ALPHA_LITUSE:
      return 0;

a1313 4
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_32:
    case BFD_RELOC_64:
    case BFD_RELOC_ALPHA_HINT:
a1314 1

d1316 1
a1316 3
      assert ((int)f->fx_r_type < 0
	      && - (int)f->fx_r_type < alpha_num_operands);
      return 1;
d1331 1
a1331 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
a1409 18
/* This is called before the symbol table is processed.  In order to
   work with gcc when using mips-tfile, we must keep all local labels.
   However, in other cases, we want to discard them.  If we were
   called with -g, but we didn't see any debugging information, it may
   mean that gcc is smuggling debugging information through to
   mips-tfile, in which case we must generate all local labels.  */

#ifdef OBJ_ECOFF

void
alpha_frob_file_before_adjust ()
{
  if (alpha_debug != 0
      && ! ecoff_debugging_seen)
    flag_keep_locals = 1;
}

#endif /* OBJ_ECOFF */
d1845 1
a1845 1
      if ((int)fixup->reloc < 0)
d2553 1
a2553 1
#ifdef OBJ_EVAX
d3201 1
a3201 1
#ifdef OBJ_EVAX
d3280 1
a3280 1
#ifdef OBJ_ECOFF
d3320 1
a3320 1
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d3327 21
d3362 1
d3364 1
d3371 1
a3371 1
#ifdef OBJ_ECOFF
a3430 3
  
/* Handle the section specific pseudo-op.  */
  
d3432 2
a3433 2
s_alpha_section (secid)
     int secid;
a3435 3
#define EVAX_SECTION_COUNT 6
  static char *section_name[EVAX_SECTION_COUNT+1] =
    { "NULL", ".rdata", ".comm", ".link", ".ctors", ".dtors", ".lcomm" };
a3436 6
  if ((secid <= 0) || (secid > EVAX_SECTION_COUNT))
    {
      as_fatal ("Unknown section directive");
      demand_empty_rest_of_line ();
      return;
    }
d3438 1
a3438 1
  subseg_new (section_name[secid], 0);
d3613 1
a3613 1
  frag_align (3, 0, 0);
a3683 41
/* Support for crash debug on vms.  */

static void
s_alpha_name (ignore)
     int ignore;
{
  register char *p;
  expressionS exp;
  segment_info_type *seginfo = seg_info (alpha_link_section);

  if (now_seg != alpha_link_section)
    {
      as_bad (".name directive not in link (.link) section");
      demand_empty_rest_of_line ();
      return;
    }

  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_warn (".name directive has no symbol");
      demand_empty_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  frag_align (3, 0, 0);
  p = frag_more (8);
  seginfo->literal_pool_size += 8;

  fix_new_exp (frag_now, p-frag_now->fr_literal, 8, &exp, 0, BFD_RELOC_64);

  return;
}


a3713 29
s_alpha_code_address (ignore)
     int ignore;
{
  expressionS exp;
  char *p;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  expression (&exp);
  if (exp.X_op != O_symbol)
    {
      as_fatal ("No symbol after .code_address");
    }
  else
    {
      p = frag_more (8);
      memset (p, 0, 8);
      fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &exp, 0,\
		   BFD_RELOC_ALPHA_CODEADDR);
    }
  demand_empty_rest_of_line ();

  return;
}


static void
d3794 5
a3798 2
  sprintf (case_hack, "<CASE:%01d%01d>",
	    alpha_flag_hash_long_names, alpha_flag_show_after_trunc);
a4102 31

#ifdef DEBUG1
/* print token expression with alpha specific extension.  */

static void
alpha_print_token(f, exp)
    FILE *f;
    const expressionS *exp;
{
  switch (exp->X_op)
    {
      case O_cpregister:
	putc (',', f);
	/* FALLTHRU */
      case O_pregister:
	putc ('(', f);
	{
	  expressionS nexp = *exp;
	  nexp.X_op = O_register;
	  print_expr (f, &nexp);
	}
	putc (')', f);
	break;
      default:
	print_expr (f, exp);
	break;
    }
  return;
}
#endif

d4108 1
a4108 1
#ifdef OBJ_ECOFF
a4109 1
  {"rdata", s_alpha_rdata, 0},
d4113 3
a4126 1
  { "name", s_alpha_name, 0},
a4127 1
  { "code_address", s_alpha_code_address, 0},
d4133 1
a4135 6
  { "rdata", s_alpha_section, 1},
  { "comm", s_alpha_section, 2},
  { "link", s_alpha_section, 3},
  { "ctors", s_alpha_section, 4},
  { "dtors", s_alpha_section, 5},
  { "lcomm", s_alpha_section, 6},
d4272 2
a4273 2
	    frag_align (2, 0, 0);
	  frag_align_pattern (n, nop, sizeof nop, 0);
d4276 1
a4276 1
	frag_align (n, 0, 0);
d4279 1
a4279 1
    frag_align (n, *pfill, 0);
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1989, 93-98, 1999 Free Software Foundation, Inc.
d7 1
a7 1
   Modified by Klaus K"ampf for EVAX (OpenVMS/Alpha) support.
a53 2
#include "struc-symbol.h"
#include "ecoff.h"
a65 3
#define TOKENIZE_ERROR -1
#define TOKENIZE_ERROR_REPORT -2

a79 1
  unsigned sequence[MAX_INSN_FIXUPS];
d84 1
a84 11
  MACRO_EOA = 1,
  MACRO_IR,
  MACRO_PIR,
  MACRO_OPIR,
  MACRO_CPIR,
  MACRO_FPR,
  MACRO_EXP,
  MACRO_LITERAL,
  MACRO_BASE,
  MACRO_BYTOFF,
  MACRO_JSR
d95 2
a96 18
/* Extra expression types. */

#define O_pregister	O_md1	/* O_register, in parentheses */
#define O_cpregister	O_md2	/* + a leading comma */

#ifdef RELOC_OP_P
/* Note, the alpha_reloc_op table below depends on the ordering
   of O_literal .. O_gprelow.  */
#define O_literal	O_md3	/* !literal relocation */
#define O_lituse_base	O_md4	/* !lituse_base relocation */
#define O_lituse_bytoff	O_md5	/* !lituse_bytoff relocation */
#define O_lituse_jsr	O_md6	/* !lituse_jsr relocation */
#define O_gpdisp	O_md7	/* !gpdisp relocation */
#define O_gprelhigh	O_md8	/* !gprelhigh relocation */
#define O_gprellow	O_md9	/* !gprellow relocation */

#define USER_RELOC_P(R) ((R) >= O_literal && (R) <= O_gprellow)
#endif
d98 2
a112 2
/* XXX: The non-shift version appears to trigger a compiler bug when
   cross-assembling from x86 w/ gcc 2.7.2.  */
a113 6
#if 1
#define range_signed_16(x) \
	(((offsetT)(x) >> 15) == 0 || ((offsetT)(x) >> 15) == -1)
#define range_signed_32(x) \
	(((offsetT)(x) >> 31) == 0 || ((offsetT)(x) >> 31) == -1)
#else
a117 1
#endif
d174 1
a174 2
  PARAMS ((int, const expressionS *, int *, expressionS *,
	   const expressionS *));
d197 2
a205 6
static void s_alpha_ent PARAMS ((int));
static void s_alpha_end PARAMS ((int));
static void s_alpha_mask PARAMS ((int));
static void s_alpha_frame PARAMS ((int));
static void s_alpha_prologue PARAMS ((int));
static void s_alpha_coff_wrapper PARAMS ((int));
d223 1
a223 5
static void alpha_align PARAMS ((int, char *, symbolS *, int));

#ifdef RELOC_OP_P
static void alpha_adjust_symtab_relocs PARAMS ((bfd *, asection *, PTR));
#endif
d229 5
d258 1
a258 1
const char *md_shortopts = "Fm:g+1h:HG:";
d260 1
a260 1
const char *md_shortopts = "Fm:gG:";
a265 8
#define OPTION_RELAX (OPTION_32ADDR+1)
  { "relax", no_argument, NULL, OPTION_RELAX },
#ifdef OBJ_ELF
#define OPTION_MDEBUG (OPTION_RELAX+1)
#define OPTION_NO_MDEBUG (OPTION_MDEBUG+1)
  { "mdebug", no_argument, NULL, OPTION_MDEBUG },
  { "no-mdebug", no_argument, NULL, OPTION_NO_MDEBUG },
#endif
a345 5
/* The active .ent symbol.  */
#ifdef OBJ_ELF
static symbolS *alpha_cur_ent_sym;
#endif

a377 11
#ifdef OBJ_ELF
/* Whether we are emitting an mdebug section.  */
int alpha_flag_mdebug = 1;
#endif

/* Don't fully resolve relocations, allowing code movement in the linker.  */
static int alpha_flag_relax;

/* What value to give to bfd_set_gp_size.  */
static int g_switch_value = 8;

d401 1
a403 140
#ifdef RELOC_OP_P
/* A table to map the spelling of a relocation operand into an appropriate
   bfd_reloc_code_real_type type.  The table is assumed to be ordered such
   that op-O_literal indexes into it.  */

#define ALPHA_RELOC_TABLE(op)						\
&alpha_reloc_op[ ((!USER_RELOC_P (op))					\
		  ? (abort (), 0)					\
		  : (int)(op) - (int)O_literal) ]

#define LITUSE_BASE	1
#define LITUSE_BYTOFF	2
#define LITUSE_JSR	3

static const struct alpha_reloc_op_tag {
  const char *name;				/* string to lookup */
  size_t length;				/* size of the string */
  bfd_reloc_code_real_type reloc;		/* relocation before frob */
  operatorT op;					/* which operator to use */
  int lituse;					/* addened to specify lituse */
} alpha_reloc_op[] = {

  {
    "literal",					/* name */
    sizeof ("literal")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITERAL,		/* reloc */
    O_literal,					/* op */
    0,						/* lituse */
  },

  {
    "lituse_base",				/* name */
    sizeof ("lituse_base")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITUSE_BASE,		/* reloc */
    O_lituse_base,				/* op */
    LITUSE_BASE,				/* lituse */
  },

  {
    "lituse_bytoff",				/* name */
    sizeof ("lituse_bytoff")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF,		/* reloc */
    O_lituse_bytoff,				/* op */
    LITUSE_BYTOFF,				/* lituse */
  },

  {
    "lituse_jsr",				/* name */
    sizeof ("lituse_jsr")-1,			/* length */
    BFD_RELOC_ALPHA_USER_LITUSE_JSR,		/* reloc */
    O_lituse_jsr,				/* op */
    LITUSE_JSR,					/* lituse */
  },

  {
    "gpdisp",					/* name */
    sizeof ("gpdisp")-1,			/* length */
    BFD_RELOC_ALPHA_USER_GPDISP,		/* reloc */
    O_gpdisp,					/* op */
    0,						/* lituse */
  },

  {
    "gprelhigh",				/* name */
    sizeof ("gprelhigh")-1,			/* length */
    BFD_RELOC_ALPHA_USER_GPRELHIGH,		/* reloc */
    O_gprelhigh,				/* op */
    0,						/* lituse */
  },

  {
    "gprellow",					/* name */
    sizeof ("gprellow")-1,			/* length */
    BFD_RELOC_ALPHA_USER_GPRELLOW,		/* reloc */
    O_gprellow,					/* op */
    0,						/* lituse */
  },
};

static const int alpha_num_reloc_op
  = sizeof(alpha_reloc_op) / sizeof(*alpha_reloc_op);

/* Maximum # digits needed to hold the largest sequence # */
#define ALPHA_RELOC_DIGITS 25

/* Whether a sequence number is valid.  */
#define ALPHA_RELOC_SEQUENCE_OK(X) ((X) > 0 && ((unsigned)(X)) == (X))

/* Structure to hold explict sequence information.  */
struct alpha_literal_tag
{
  fixS *lituse;			/* head of linked list of !literals */
  segT segment;			/* segment relocs are in or undefined_section*/
  int multi_section_p;		/* True if more than one section was used */
  unsigned sequence;		/* sequence # */
  unsigned n_literals;		/* # of literals */
  unsigned n_lituses;		/* # of lituses */
  char string[1];		/* printable form of sequence to hash with */
};

/* Hash table to link up literals with the appropriate lituse */
static struct hash_control *alpha_literal_hash;
#endif

/* A table of CPU names and opcode sets.  */

static const struct cpu_type
{
  const char *name;
  unsigned flags;
} cpu_types[] =
{
  /* Ad hoc convention: cpu number gets palcode, process code doesn't.
     This supports usage under DU 4.0b that does ".arch ev4", and 
     usage in MILO that does -m21064.  Probably something more
     specific like -m21064-pal should be used, but oh well.  */

  { "21064", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21064a", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21066", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21068", AXP_OPCODE_BASE|AXP_OPCODE_EV4 },
  { "21164", AXP_OPCODE_BASE|AXP_OPCODE_EV5 },
  { "21164a", AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX },
  { "21164pc", (AXP_OPCODE_BASE|AXP_OPCODE_EV5|AXP_OPCODE_BWX
		|AXP_OPCODE_MAX) },
  { "21264", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },

  { "ev4", AXP_OPCODE_BASE },
  { "ev45", AXP_OPCODE_BASE },
  { "lca45", AXP_OPCODE_BASE },
  { "ev5", AXP_OPCODE_BASE },
  { "ev56", AXP_OPCODE_BASE|AXP_OPCODE_BWX },
  { "pca56", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX },
  { "ev6", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },

  { "all", AXP_OPCODE_BASE },
  { 0, 0 }
};

d409 2
a410 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_LITERAL, MACRO_BASE, MACRO_EOA } },
d415 2
a416 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d418 2
a419 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d421 2
a422 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_LITERAL, MACRO_EOA } },
d424 2
a425 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d427 2
a428 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d430 2
a431 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d433 2
a434 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d436 2
a437 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d439 2
a440 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d443 2
a444 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d446 2
a447 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d449 2
a450 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d452 2
a453 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d456 2
a457 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d459 2
a460 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d462 2
a463 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d465 2
a466 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d468 2
a469 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d494 2
a495 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d497 2
a498 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d500 2
a501 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d503 2
a504 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d506 2
a507 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d509 2
a510 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d512 2
a513 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d515 2
a516 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d518 2
a519 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d522 2
a523 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d525 2
a526 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d528 2
a529 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d531 2
a532 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d534 2
a535 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_BASE, MACRO_EOA } },
d598 4
a601 4
    { MACRO_PIR, MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_PIR, MACRO_JSR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_EXP, MACRO_JSR, MACRO_EOA } },
d603 4
a606 4
    { MACRO_PIR, MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_PIR, MACRO_JSR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_JSR, MACRO_EOA,
      MACRO_EXP, MACRO_JSR, MACRO_EOA } },
d630 1
a630 1
static const unsigned int alpha_num_macros
d642 1
a642 8
  unsigned int i;

  /* Verify that X_op field is wide enough.  */
  {
    expressionS e;
    e.X_op = O_max;
    assert (e.X_op == O_max);
  }
d649 1
a649 1
      const char *name, *retval, *slash;
d654 1
a654 1
	as_fatal (_("internal error: can't hash opcode `%s': %s"), name, retval);
d656 5
a660 4
      /* Some opcodes include modifiers of various sorts with a "/mod"
	 syntax, like the architecture manual suggests.  However, for
	 use with gcc at least, we also need access to those same opcodes
	 without the "/".  */
d662 8
a669 1
      if ((slash = strchr (name, '/')) != NULL)
d672 2
a673 2
	  memcpy (p, name, slash - name);
	  strcpy (p + (slash - name), slash + 1);
d696 1
a696 1
	as_fatal (_("internal error: can't hash macro `%s': %s"), name, retval);
d724 1
a724 1
  bfd_set_gp_size (stdoutput, g_switch_value);
d742 3
a744 1
      segT sec = subseg_new(".mdebug", (subsegT)0);
d747 9
a759 5

#ifdef RELOC_OP_P
  /* Create literal lookup hash table.  */
  alpha_literal_hash = hash_new();
#endif
d770 1
a770 2
  int ntok, trunclen;
  size_t opnamelen;
d773 1
a773 1
  opnamelen = strspn (str, "abcdefghijklmnopqrstuvwxyz_/46819");
d783 1
a783 3
      if (ntok != TOKENIZE_ERROR_REPORT)
	as_bad (_("syntax error"));

d856 1
a856 1
      return _("Bad call to MD_ATOF()");
a892 4
    case 'G':
      g_switch_value = atoi(arg);
      break;

d895 35
a929 2
	const struct cpu_type *p;
	for (p = cpu_types; p->name; ++p)
d935 1
a935 1
	as_warn(_("Unknown CPU identifier `%s'"), arg);
a952 13
    case OPTION_RELAX:
      alpha_flag_relax = 1;
      break;

#ifdef OBJ_ELF
    case OPTION_MDEBUG:
      alpha_flag_mdebug = 1;
      break;
    case OPTION_NO_MDEBUG:
      alpha_flag_mdebug = 0;
      break;
#endif

d966 1
a966 1
  fputs(_("\
d970 3
a972 4
-mev4 | -mev45 | -mev5 | -mev56 | -mpca56 | -mev6 | -mall\n\
			specify variant of Alpha architecture\n\
-m21064 | -m21066 | -m21164 | -m21164a | -m21164pc | -m21264\n\
			these variants include PALcode opcodes\n"),
d975 1
a975 1
  fputs (_("\
d978 1
a978 1
-H			show new symbol after hash truncation\n"),
d1050 1
a1050 1
      fixP->fx_addsy = section_symbol (now_seg);
a1054 2
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_16_PCREL;
a1057 2
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_32_PCREL;
a1060 2
      if (fixP->fx_pcrel)
	fixP->fx_r_type = BFD_RELOC_64_PCREL;
a1119 13
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITERAL:
    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
      return 1;

    case BFD_RELOC_ALPHA_USER_GPDISP:
    case BFD_RELOC_ALPHA_USER_GPRELHIGH:
    case BFD_RELOC_ALPHA_USER_GPRELLOW:
      abort ();
#endif

d1125 1
a1125 1
	  as_fatal (_("unhandled relocation type %s"),
d1128 1
a1128 1
	assert (-(int)fixP->fx_r_type < (int)alpha_num_operands);
d1136 1
a1136 1
	    && S_GET_SEGMENT (fixP->fx_addsy) != absolute_section)
d1138 1
a1138 1
			_("non-absolute expression in constant field"));
d1152 1
a1152 1
		    _("type %d reloc done?\n"), (int)fixP->fx_r_type);
d1203 1
a1203 1
	    as_warn(_("Used $at without \".set noat\""));
d1210 1
a1210 1
		as_warn(_("Used $at without \".set noat\""));
a1259 3
  if (alpha_flag_relax)
    return 1;

a1276 9
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITERAL:
    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
    case BFD_RELOC_ALPHA_USER_GPDISP:
    case BFD_RELOC_ALPHA_USER_GPRELHIGH:
    case BFD_RELOC_ALPHA_USER_GPRELLOW:
#endif
d1286 1
a1286 1
      assert((int)f->fx_r_type < 0 && -(int)f->fx_r_type < (int)alpha_num_operands);
d1299 1
a1299 1
  if (S_IS_EXTERN (f->fx_addsy) || S_IS_WEAK (f->fx_addsy))
a1317 3
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITERAL:
#endif
a1324 8
#ifdef RELOC_OP_P
    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
    case BFD_RELOC_ALPHA_USER_GPDISP:
    case BFD_RELOC_ALPHA_USER_GPRELHIGH:
    case BFD_RELOC_ALPHA_USER_GPRELLOW:
#endif
d1336 1
a1336 1
	      && - (int)f->fx_r_type < (int)alpha_num_operands);
d1347 1
a1347 1
     asection *sec ATTRIBUTE_UNUSED;
d1353 1
a1353 2
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d1364 1
a1364 1
		    _("cannot represent `%s' relocation in object file"),
d1371 1
a1371 1
      as_fatal (_("internal error? cannot generate `%s' relocation"),
d1393 2
a1394 3
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
	  && !S_IS_COMMON(fixp->fx_addsy))
	reloc->addend -= symbol_get_bfdsym (fixp->fx_addsy)->value;
d1409 1
a1409 1
     int frame ATTRIBUTE_UNUSED;
d1424 1
a1424 1
  as_warn (_("frame reg expected, using $%d."), framereg);
a1449 244
#ifdef RELOC_OP_P

/* Before the relocations are written, reorder them, so that user supplied
   !lituse relocations follow the appropriate !literal relocations.  Also
   convert the gas-internal relocations to the appropriate linker relocations.
   */

void
alpha_adjust_symtab ()
{
  if (alpha_literal_hash)
    {
#ifdef DEBUG2_ALPHA
      fprintf (stderr, "alpha_adjust_symtab called\n");
#endif

      /* Go over each section, reordering the relocations so that all of the
         explicit LITUSE's are adjacent to the explicit LITERAL's */
      bfd_map_over_sections (stdoutput, alpha_adjust_symtab_relocs, (char *) 0);
    }
}


/* Inner function to move LITUSE's next to the LITERAL.  */

static void
alpha_adjust_symtab_relocs (abfd, sec, ptr)
     bfd *abfd;
     asection *sec;
     PTR ptr;
{
  segment_info_type *seginfo = seg_info (sec);
  fixS **prevP;
  fixS *fixp;
  fixS *next;
  fixS *lituse;
  int n_lituses = 0;

#ifdef DEBUG2_ALPHA
  int n = 0;
  int n_literals = 0;
  int n_dup_literals = 0;
#endif

  /* If seginfo is NULL, we did not create this section; don't do anything with
     it.  By using a pointer to a pointer, we can update the links in place.  */
  if (seginfo == NULL)
    return;

  /* If there are no relocations, skip the section.  */
  if (! seginfo->fix_root)
    return;

  /* First rebuild the fixup chain without the expicit lituse's.  */
  prevP = &(seginfo->fix_root);
  for (fixp = seginfo->fix_root; fixp; fixp = next)
    {
      next = fixp->fx_next;
      fixp->fx_next = (fixS *)0;
#ifdef DEBUG2_ALPHA
      n++;
#endif

      switch (fixp->fx_r_type)
	{
	default:
	  *prevP = fixp;
	  prevP = &(fixp->fx_next);
#ifdef DEBUG2_ALPHA
	  fprintf (stderr,
		   "alpha_adjust_symtab_relocs: 0x%lx, other relocation %s\n",
		   (long)fixp,
		   bfd_get_reloc_code_name (fixp->fx_r_type));
#endif
	  break;

	case BFD_RELOC_ALPHA_USER_LITERAL:
	  *prevP = fixp;
	  prevP = &(fixp->fx_next);
	  /* prevent assembler from trying to adjust the offset */
#ifdef DEBUG2_ALPHA
	  n_literals++;
	  if (fixp->tc_fix_data.info->n_literals != 1)
	    n_dup_literals++;
	  fprintf (stderr,
		   "alpha_adjust_symtab_relocs: 0x%lx, !literal!%.6d, # literals = %2d\n",
		   (long)fixp,
		   fixp->tc_fix_data.info->sequence,
		   fixp->tc_fix_data.info->n_literals);
#endif
	  break;

	  /* do not link in lituse's */
	case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	  n_lituses++;
	  if (fixp->tc_fix_data.info->n_literals == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No !literal!%d was found"),
			  fixp->tc_fix_data.info->sequence);
#ifdef DEBUG2_ALPHA
	  fprintf (stderr,
		   "alpha_adjust_symtab_relocs: 0x%lx, !lituse !%.6d, # lituses  = %2d, next_lituse = 0x%lx\n",
		   (long)fixp,
		   fixp->tc_fix_data.info->sequence,
		   fixp->tc_fix_data.info->n_lituses,
		   (long)fixp->tc_fix_data.next_lituse);
#endif
	  break;
	}
    }

  /* If there were any lituses, go and add them to the chain, unless there is
     more than one !literal for a given sequence number.  They are linked
     through the next_lituse field in reverse order, so as we go through the
     next_lituse chain, we effectively reverse the chain once again.  If there
     was more than one !literal, we fall back to loading up the address w/o
     optimization.  Also, if the !literals/!lituses are spread in different
     segments (happens in the Linux kernel semaphores), suppress the
     optimization.  */
  if (n_lituses)
    {
      for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
	{
	  switch (fixp->fx_r_type)
	    {
	    default:
	      break;

	    case BFD_RELOC_ALPHA_USER_LITERAL:
#ifdef OBJ_ELF
	      fixp->fx_r_type = BFD_RELOC_ALPHA_ELF_LITERAL;
#else
	      fixp->fx_r_type = BFD_RELOC_ALPHA_LITERAL;	/* XXX check this */
#endif
	      if (fixp->tc_fix_data.info->n_literals == 1
		  && ! fixp->tc_fix_data.info->multi_section_p)
		{
		  for (lituse = fixp->tc_fix_data.info->lituse;
		       lituse != (fixS *)0;
		       lituse = lituse->tc_fix_data.next_lituse)
		    {
		      lituse->fx_next = fixp->fx_next;
		      fixp->fx_next = lituse;
		    }
		}
	      break;

	    case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	    case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	    case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	      fixp->fx_r_type = BFD_RELOC_ALPHA_LITUSE;
	      break;
	    }
	}
    }

#ifdef DEBUG2_ALPHA
  fprintf (stderr, "alpha_adjust_symtab_relocs: %s, %d literal%s, %d duplicate literal%s, %d lituse%s\n\n",
	   sec->name,
	   n_literals, (n_literals == 1) ? "" : "s",
	   n_dup_literals, (n_dup_literals == 1) ? "" : "s",
	   n_lituses, (n_lituses == 1) ? "" : "s");
#endif
}

#endif /* RELOC_OP_P */


#ifdef DEBUG_ALPHA
static void
debug_exp (tok, ntok)
     expressionS tok[];
     int ntok;
{
  int i;

  fprintf (stderr, "debug_exp: %d tokens", ntok);
  for (i = 0; i < ntok; i++)
    {
      expressionS *t = &tok[i];
      const char *name;
      switch (t->X_op)
	{
	default:			name = "unknown";		break;
	case O_illegal:			name = "O_illegal";		break;
	case O_absent:			name = "O_absent";		break;
	case O_constant:		name = "O_constant";		break;
	case O_symbol:			name = "O_symbol";		break;
	case O_symbol_rva:		name = "O_symbol_rva";		break;
	case O_register:		name = "O_register";		break;
	case O_big:			name = "O_big";			break;
	case O_uminus:			name = "O_uminus";		break;
	case O_bit_not:			name = "O_bit_not";		break;
	case O_logical_not:		name = "O_logical_not";		break;
	case O_multiply:		name = "O_multiply";		break;
	case O_divide:			name = "O_divide";		break;
	case O_modulus:			name = "O_modulus";		break;
	case O_left_shift:		name = "O_left_shift";		break;
	case O_right_shift:		name = "O_right_shift";		break;
	case O_bit_inclusive_or:	name = "O_bit_inclusive_or";	break;
	case O_bit_or_not:		name = "O_bit_or_not";		break;
	case O_bit_exclusive_or:	name = "O_bit_exclusive_or";	break;
	case O_bit_and:			name = "O_bit_and";		break;
	case O_add:			name = "O_add";			break;
	case O_subtract:		name = "O_subtract";		break;
	case O_eq:			name = "O_eq";			break;
	case O_ne:			name = "O_ne";			break;
	case O_lt:			name = "O_lt";			break;
	case O_le:			name = "O_le";			break;
	case O_ge:			name = "O_ge";			break;
	case O_gt:			name = "O_gt";			break;
	case O_logical_and:		name = "O_logical_and";		break;
	case O_logical_or:		name = "O_logical_or";		break;
	case O_index:			name = "O_index";		break;
	case O_pregister:		name = "O_pregister";		break;
	case O_cpregister:		name = "O_cpregister";		break;
	case O_literal:			name = "O_literal";		break;
	case O_lituse_base:		name = "O_lituse_base";		break;
	case O_lituse_bytoff:		name = "O_lituse_bytoff";	break;
	case O_lituse_jsr:		name = "O_lituse_jsr";		break;
	case O_gpdisp:			name = "O_gpdisp";		break;
	case O_gprelhigh:		name = "O_gprelhigh";		break;
	case O_gprellow:		name = "O_gprellow";		break;
	case O_md10:			name = "O_md10";		break;
	case O_md11:			name = "O_md11";		break;
	case O_md12:			name = "O_md12";		break;
	case O_md13:			name = "O_md13";		break;
	case O_md14:			name = "O_md14";		break;
	case O_md15:			name = "O_md15";		break;
	case O_md16:			name = "O_md16";		break;
	}

      fprintf (stderr, ", %s(%s, %s, %d)", name,
	       (t->X_add_symbol) ? S_GET_NAME (t->X_add_symbol) : "--",
	       (t->X_op_symbol) ? S_GET_NAME (t->X_op_symbol) : "--",
	       (int)t->X_add_number);
    }
  fprintf (stderr, "\n");
  fflush (stderr);
}
#endif

a1460 10
#ifdef DEBUG_ALPHA
  expressionS *orig_tok = tok;
#endif
#ifdef RELOC_OP_P
  char *p;
  const struct alpha_reloc_op_tag *r;
  int c, i;
  size_t len;
  int reloc_found_p = 0;
#endif
a1475 66
#ifdef RELOC_OP_P
	case '!':
	  /* A relocation operand can be placed after the normal operand on an
	     assembly language statement, and has the following form:
		!relocation_type!sequence_number.  */
	  if (reloc_found_p)
	    {			/* only support one relocation op per insn */
	      as_bad (_("More than one relocation op per insn"));
	      goto err_report;
	    }

	  if (!saw_arg)
	    goto err;

	  for (p = ++input_line_pointer;
	       ((c = *p) != '!' && c != ';' && c != '#' && c != ','
		&& !is_end_of_line[c]);
	       p++)
	    ;

	  /* Parse !relocation_type */
	  len = p - input_line_pointer;
	  if (len == 0)
	    {
	      as_bad (_("No relocation operand"));
	      goto err_report;
	    }

	  if (c != '!')
	    {
	      as_bad (_("No !sequence-number after !%s"), input_line_pointer);
	      goto err_report;
	    }

	  r = &alpha_reloc_op[0];
	  for (i = alpha_num_reloc_op-1; i >= 0; i--, r++)
	    {
	      if (len == r->length
		  && memcmp (input_line_pointer, r->name, len) == 0)
		break;
	    }
	  if (i < 0)
	    {
	      as_bad (_("Unknown relocation operand: !%s"), input_line_pointer);
	      goto err_report;
	    }

	  input_line_pointer = ++p;

	  /* Parse !sequence_number */
	  memset (tok, '\0', sizeof (expressionS));
	  expression (tok);

	  if (tok->X_op != O_constant
	      || ! ALPHA_RELOC_SEQUENCE_OK (tok->X_add_number))
	    {
	      as_bad (_("Bad sequence number: !%s!%s"), r->name, input_line_pointer);
	      goto err_report;
	    }

	  tok->X_op = r->op;
	  reloc_found_p = 1;
	  ++tok;
	  break;
#endif

a1505 1

a1520 5

#ifdef DEBUG_ALPHA
  debug_exp (orig_tok, ntok - (end_tok - tok));
#endif

d1525 1
a1525 7
  return TOKENIZE_ERROR;

#ifdef RELOC_OP_P
err_report:
  input_line_pointer = old_input_line_pointer;
  return TOKENIZE_ERROR_REPORT;
#endif
a1603 3

		default:
		  break;
a1659 1
	      /* index register */
a1665 2

	      /* parenthesized index register */
a1671 9

	      /* optional parenthesized index register */
	    case MACRO_OPIR:
	      if (tokidx < ntok && tok[tokidx].X_op == O_pregister
		  && is_ir_num(tok[tokidx].X_add_number))
		++tokidx;
	      break;

	      /* leading comma with a parenthesized index register */
a1677 2

	      /* floating point register */
a1684 1
	      /* normal expression */
a1694 9
#ifdef RELOC_OP_P
		case O_literal:
		case O_lituse_base:
		case O_lituse_bytoff:
		case O_lituse_jsr:
		case O_gpdisp:
		case O_gprelhigh:
		case O_gprellow:
#endif
a1695 3

		default:
		  break;
a1699 32
	      /* optional !literal!<number> */
	    case MACRO_LITERAL:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_literal)
		tokidx++;
#endif
	      break;

	      /* optional !lituse_base!<number> */
	    case MACRO_BASE:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_lituse_base)
		tokidx++;
#endif
	      break;

	      /* optional !lituse_bytoff!<number> */
	    case MACRO_BYTOFF:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_lituse_bytoff)
		tokidx++;
#endif
	      break;

	      /* optional !lituse_jsr!<number> */
	    case MACRO_JSR:
#ifdef RELOC_OP_P
	      if (tokidx < ntok && tok[tokidx].X_op == O_lituse_jsr)
		tokidx++;
#endif
	      break;

d1743 1
a1743 1
	    _("operand out of range (%s not between %d and %d)");
d1790 1
a1790 1
      const expressionS *t = (const expressionS *)0;
d1811 1
a1811 1
		static expressionS zero_exp;
a1812 2
		zero_exp.X_op = O_constant;
		zero_exp.X_unsigned = 1;
d1840 1
a1840 1
	      as_fatal(_("too many fixups"));
d1867 1
a1867 1
    alpha_align (2, (char *) NULL, alpha_insn_label, 0);
a1878 1
      const struct alpha_operand *operand = (const struct alpha_operand *)0;
a1881 4
#ifdef RELOC_OP_P
      char buffer[ALPHA_RELOC_DIGITS];
      struct alpha_literal_tag *info;
#endif
d1885 5
d1891 1
a1891 3
	  operand = &alpha_operands[-(int)fixup->reloc];
	  size = 4;
	  pcrel = ((operand->flags & AXP_OPERAND_RELATIVE) != 0);
d1893 2
a1894 1
      else switch (fixup->reloc)
d1896 3
a1898 27
#ifdef OBJ_ELF
	  /* These relocation types are only used internally. */
	case BFD_RELOC_ALPHA_GPDISP_HI16:
	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  size = 2;
	  pcrel = 0;
	  break;
#endif
#ifdef RELOC_OP_P
	  /* and these also are internal only relocations */
	case BFD_RELOC_ALPHA_USER_LITERAL:
	case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	case BFD_RELOC_ALPHA_USER_GPDISP:
	case BFD_RELOC_ALPHA_USER_GPRELHIGH:
	case BFD_RELOC_ALPHA_USER_GPRELLOW:
	  size = 2;
	  pcrel = 0;
	  break;
#endif

	default:
	  {
	    reloc_howto_type *reloc_howto
	      = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	    assert (reloc_howto);
d1900 2
a1901 5
	    size = bfd_get_reloc_size (reloc_howto);
	    pcrel = reloc_howto->pc_relative;
	  }
	  assert (size >= 1 && size <= 4);
	  break;
d1903 1
d1908 1
a1908 2
      /* Turn off complaints that the addend is too large for some fixups,
         and copy in the sequence number for the explicit relocations.  */
a1920 64

#ifdef RELOC_OP_P
	case BFD_RELOC_ALPHA_USER_LITERAL:
	  fixP->fx_no_overflow = 1;
	  sprintf (buffer, "!%u", insn->sequence[i]);
	  info = ((struct alpha_literal_tag *)
		  hash_find (alpha_literal_hash, buffer));

	  if (! info)
	    {
	      size_t len = strlen (buffer);
	      const char *errmsg;

	      info = ((struct alpha_literal_tag *)
		      xcalloc (sizeof (struct alpha_literal_tag) + len, 1));

	      info->segment = now_seg;
	      info->sequence = insn->sequence[i];
	      strcpy (info->string, buffer);
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR)info);
	      if (errmsg)
		as_bad (errmsg);
	    }

	  ++info->n_literals;

	  if (info->segment != now_seg)
	    info->multi_section_p = 1;

	  fixP->tc_fix_data.info = info;
	  break;

	case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	  sprintf (buffer, "!%u", insn->sequence[i]);
	  info = ((struct alpha_literal_tag *)
		  hash_find (alpha_literal_hash, buffer));

	  if (! info)
	    {
	      size_t len = strlen (buffer);
	      const char *errmsg;

	      info = ((struct alpha_literal_tag *)
		      xcalloc (sizeof (struct alpha_literal_tag) + len, 1));

	      info->segment = now_seg;
	      info->sequence = insn->sequence[i];
	      strcpy (info->string, buffer);
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR)info);
	      if (errmsg)
		as_bad (errmsg);
	    }
	  info->n_lituses++;
	  fixP->tc_fix_data.info = info;
	  fixP->tc_fix_data.next_lituse = info->lituse;
	  info->lituse = fixP;
	  if (info->segment != now_seg)
	    info->multi_section_p = 1;

	  break;
#endif

a1921 5
	  if ((int)fixup->reloc < 0)
	    {
	      if (operand->flags & AXP_OPERAND_NOOVERFLOW)
		fixP->fx_no_overflow = 1;
	    }
d1954 1
a1954 1
	as_bad (_("inappropriate arguments for opcode `%s'"), opname);
d1956 2
a1957 2
	as_bad (_("opcode `%s' not supported for target %s"), opname,
	        alpha_target_name);
d1960 1
a1960 1
    as_bad (_("unknown opcode `%s'"), opname);
a1994 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok-1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int)reloc_exp->X_add_number, opname);
      ntok--;
    }
#endif

d2012 1
a2012 1
      as_bad (_("inappropriate arguments for opcode `%s'"), opname);
d2014 2
a2015 2
      as_bad (_("opcode `%s' not supported for target %s"), opname,
	      alpha_target_name);
d2017 1
a2017 1
    as_bad (_("unknown opcode `%s'"), opname);
d2038 2
a2039 2
     int ntok ATTRIBUTE_UNUSED;
     const PTR unused ATTRIBUTE_UNUSED;
d2051 2
a2052 10
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok-1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int)reloc_exp->X_add_number, "ldgp");
      ntok--;
    }
#endif
d2068 1
a2068 2
  if (addend.X_op != O_constant)
    as_bad (_("can not resolve expression"));
d2116 1
a2116 1
  offset = - *symbol_get_obj (basesym);
a2165 3
   If explicit relocations of the form !literal!<number> are allowed,
   and used, then explict_reloc with be an expression pointer.

d2170 1
a2170 1
load_expression (targreg, exp, pbasereg, poffset, explicit_reloc)
a2174 1
     const expressionS *explicit_reloc;
d2206 1
a2206 1
	  as_fatal (_("overflow in literal (.lita) table"));
d2213 1
a2213 1
	      as_bad (_("macro requires $at register while noat in effect"));
d2215 1
a2215 1
	      as_bad (_("macro requires $at while $at in use"));
a2225 1
	assert (explicit_reloc == (const expressionS *)0);
d2235 1
a2235 1
	      as_bad (_("macro requires $at register while noat in effect"));
d2237 1
a2237 1
	      as_bad (_("macro requires $at while $at in use"));
d2244 2
a2245 5
	/* XXX: Disable this .got minimizing optimization so that we can get
	   better instruction offset knowledge in the compiler.  This happens
	   very infrequently anyway.  */
	if (1 || (!range_signed_32 (addend)
	    && (alpha_noat_on || targreg == AXP_REG_AT)))
d2260 1
a2260 12
	if (!explicit_reloc)
	  insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
	else
	  {
#ifdef RELOC_OP_P
	    insn.fixups[0].reloc
	      = (ALPHA_RELOC_TABLE (explicit_reloc->X_op))->reloc;
	    insn.sequence[0] = explicit_reloc->X_add_number;
#else
	    abort ();
#endif
	  }
d2265 10
a2276 1
	assert (explicit_reloc == (const expressionS *)0);
a2334 1
      assert (explicit_reloc == (const expressionS *)0);
a2340 1
      assert (explicit_reloc == (const expressionS *)0);
a2349 8
    case O_big:
      if (exp->X_add_number > 0)
	as_bad (_("bignum invalid; zero assumed"));
      else
	as_bad (_("floating point number invalid; zero assumed"));
      addend = 0;
      break;

d2351 1
a2351 3
      as_bad (_("can't handle expression"));
      addend = 0;
      break;
d2380 1
a2380 1
	    as_fatal (_("overflow in literal (.lita) table"));
d2386 1
a2386 1
	as_fatal (_("overflow in literal (.lit8) table"));
d2393 1
a2393 1
	    as_bad (_("macro requires $at register while noat in effect"));
d2395 1
a2395 1
	    as_bad (_("macro requires $at while $at in use"));
d2436 2
a2437 3
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_BASE;
d2516 7
a2522 54
static void
emit_lda (tok, ntok, opname)
     const expressionS *tok;
     int ntok;
     const PTR opname;
{
  int basereg;
  const expressionS *reloc = (const expressionS *)0;

#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const struct alpha_reloc_op_tag *r;

      reloc = &tok[ntok-1];
      r = ALPHA_RELOC_TABLE (reloc->X_op);
      switch (reloc->X_op)
	{
	default:
	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int)reloc->X_add_number, (const char *)opname);

	  reloc = (const expressionS *)0;
	  ntok--;
	  break;

	case O_literal:
	  ntok--;
	  break;

	  /* For lda $x,0($x)!lituse_base!y, don't use load_expression, since
	     it is really too general for our needs.  Instead just generate the
	     lda directly.  */
	case O_lituse_base:
	  if (ntok != 4
	      || tok[0].X_op != O_register
	      || !is_ir_num(tok[0].X_add_number)
	      || tok[1].X_op != O_constant
	      || tok[2].X_op != O_pregister
	      || !is_ir_num(tok[2].X_add_number))
	    {
	      as_bad (_("bad instruction format for lda !%s!%d"), r->name,
		      reloc->X_add_number);

	      reloc = (const expressionS *)0;
	      ntok--;
	      break;
	    }

	  emit_loadstore (tok, ntok, "lda");
	  return;
	}
    }
#endif
d2529 1
a2529 1
  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL, reloc);
d2538 2
a2539 2
     int ntok ATTRIBUTE_UNUSED;
     const PTR unused ATTRIBUTE_UNUSED;
a2542 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok-1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int)reloc_exp->X_add_number, "ldah");
      ntok--;
    }
#endif

a2563 31
#ifdef RELOC_OP_P
  const expressionS *reloc = (const expressionS *)0;

  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const struct alpha_reloc_op_tag *r;

      reloc = &tok[ntok-1];
      switch (reloc->X_op)
	{
	case O_lituse_base:
	  ntok--;
	  break;

	case O_literal:
	  if (strcmp ((const char *)opname, "ldq") == 0)
	    {
	      emit_lda (tok, ntok, opname);
	      return;
	    }

	  /* fall through */
	default:
	  ntok--;
	  r = ALPHA_RELOC_TABLE (reloc->X_op);
	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int)reloc->X_add_number, (const char *)opname);
	}
    }
#endif

d2570 1
a2570 1
			    &newtok[1], (const expressionS *)0);
a2576 16
#ifdef RELOC_OP_P
  if (reloc)
    {
      int nfixups = insn.nfixups;
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc->X_op);

      assert (nfixups < MAX_INSN_FIXUPS);
      insn.fixups[nfixups].reloc = r->reloc;
      insn.fixups[nfixups].exp.X_op = O_symbol;
      insn.fixups[nfixups].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[nfixups].exp.X_add_number = r->lituse;
      insn.sequence[nfixups] = reloc->X_add_number;
      insn.nfixups++;
    }
#endif

d2587 2
a2588 3
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_BASE;
d2592 9
a2615 15
#ifdef RELOC_OP_P
  const expressionS *reloc = (const expressionS *)0;

  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      reloc = &tok[--ntok];
      if (reloc->X_op != O_lituse_base)
	{
	  const struct alpha_reloc_op_tag *r = &alpha_reloc_op[ reloc->X_md ];
	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int)reloc->X_add_number, (const char *)opname);
	}
    }
#endif

d2624 1
a2624 1
	as_bad (_("macro requires $at register while noat in effect"));
d2626 1
a2626 2
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1],
				(const expressionS *)0);
a2638 16
#ifdef RELOC_OP_P
  if (reloc)
    {
      int nfixups = insn.nfixups;
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc->X_op);

      assert (nfixups < MAX_INSN_FIXUPS);
      insn.fixups[nfixups].reloc = r->reloc;
      insn.fixups[nfixups].exp.X_op = O_symbol;
      insn.fixups[nfixups].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[nfixups].exp.X_add_number = r->lituse;
      insn.sequence[nfixups] = reloc->X_add_number;
      insn.nfixups++;
    }
#endif

d2649 2
a2650 3
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_BASE;
a2669 13
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
	{
	  const expressionS *reloc_exp = &tok[ntok-1];
	  const struct alpha_reloc_op_tag *r
	    = ALPHA_RELOC_TABLE (reloc_exp->X_op);

	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int)reloc_exp->X_add_number, "ldbu/ldwu");
	  ntok--;
	}
#endif

d2671 1
a2671 1
	as_bad (_("macro requires $at register while noat in effect"));
d2719 1
a2719 1
    as_bad (_("macro requires $at register while noat in effect"));
d2781 1
a2781 1
     const PTR unused ATTRIBUTE_UNUSED;
a2784 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok-1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int)reloc_exp->X_add_number, "ldil");
      ntok--;
    }
#endif

d2808 1
a2808 1
	as_bad(_("macro requires $at register while noat in effect"));
a2948 13
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
	{
	  const expressionS *reloc_exp = &tok[ntok-1];
	  const struct alpha_reloc_op_tag *r
	    = ALPHA_RELOC_TABLE (reloc_exp->X_op);

	  as_bad (_("Cannot use !%s!%d with %s"), r->name,
		  (int)reloc_exp->X_add_number, "setxt");
	  ntok--;
	}
#endif

a2994 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok-1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int)reloc_exp->X_add_number, (char char *)symname);
      ntok--;
    }
#endif

d3009 1
a3009 1
	as_bad (_("macro requires $at register while noat in effect"));
a3093 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok-1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int)reloc_exp->X_add_number, (const char *)symname);
      ntok--;
    }
#endif

d3110 1
a3110 1
	as_bad (_("macro requires $at register while noat in effect"));
a3189 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok-1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int)reloc_exp->X_add_number, opname);
      ntok--;
    }
#endif

d3206 1
a3206 2
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL,
				(const expressionS *)0);
d3234 2
a3235 3
      insn.fixups[0].exp.X_op = O_symbol;
      insn.fixups[0].exp.X_add_symbol = section_symbol (now_seg);
      insn.fixups[0].exp.X_add_number = LITUSE_JSR;
d3239 13
a3266 11
#ifdef RELOC_OP_P
  if (ntok && USER_RELOC_P (tok[ntok-1].X_op))
    {
      const expressionS *reloc_exp = &tok[ntok-1];
      const struct alpha_reloc_op_tag *r = ALPHA_RELOC_TABLE (reloc_exp->X_op);
      as_bad (_("Cannot use !%s!%d with %s"), r->name,
	      (int)reloc_exp->X_add_number, opname);
      ntok--;
    }
#endif

d3319 1
a3319 1
#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)
d3321 1
a3321 2
/* Handle the OSF/1 and openVMS .comm pseudo quirks.
   openVMS constructs a section for every common symbol.  */
a3332 6
#ifdef OBJ_EVAX
  segT current_section = now_seg;
  int current_subsec = now_subseg;
  segT new_seg;
#endif

d3350 1
a3350 1
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
a3356 6

#ifdef OBJ_EVAX
  /* Make a section for the common symbol.  */
  new_seg = subseg_new (xstrdup (name), 0);
#endif

a3358 12
#ifdef OBJ_EVAX
  /* alignment might follow  */
  if (*input_line_pointer == ',')
    {
      offsetT align;

      input_line_pointer++;      
      align = get_absolute_expression ();
      bfd_set_section_alignment (stdoutput, new_seg, align);
    }
#endif

d3361 1
a3361 1
      as_bad (_("Ignoring attempt to re-define symbol"));
a3365 10
#ifdef OBJ_EVAX
  if (bfd_section_size (stdoutput, new_seg) > 0)
    { 
      if (bfd_section_size (stdoutput, new_seg) != temp)
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		S_GET_NAME (symbolP),
		(long) bfd_section_size (stdoutput, new_seg),
		(long) temp);
    }
#else
d3369 1
a3369 1
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
a3373 1
#endif
a3375 7
#ifdef OBJ_EVAX 
      subseg_set (new_seg, 0);
      p = frag_more (temp);
      new_seg->flags |= SEC_IS_COMMON;
      if (! S_IS_DEFINED (symbolP))
	S_SET_SEGMENT (symbolP, new_seg);
#else
a3376 1
#endif
d3380 1
a3380 5
#ifdef OBJ_EVAX
  subseg_set (current_section, current_subsec);
#endif

  know (symbol_get_frag (symbolP) == &zero_address_frag);
d3444 1
a3444 175
static void
s_alpha_ent (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_ent (0);
  else
    {
      char *name, name_end;
      name = input_line_pointer;
      name_end = get_symbol_end ();

      if (! is_name_beginner (*name))
	{
	  as_warn (_(".ent directive has no name"));
	  *input_line_pointer = name_end;
	}
      else
	{
	  symbolS *sym;

	  if (alpha_cur_ent_sym)
	    as_warn (_("nested .ent directives"));

	  sym = symbol_find_or_make (name);
	  symbol_get_bfdsym (sym)->flags |= BSF_FUNCTION;
	  alpha_cur_ent_sym = sym;

	  /* The .ent directive is sometimes followed by a number.  Not sure
	     what it really means, but ignore it.  */
	  *input_line_pointer = name_end;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      input_line_pointer++;
	      SKIP_WHITESPACE ();
	    }
	  if (isdigit (*input_line_pointer) || *input_line_pointer == '-')
	    (void) get_absolute_expression ();
	}
      demand_empty_rest_of_line ();
    }
}

static void
s_alpha_end (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_end (0);
  else
    {
      char *name, name_end;
      name = input_line_pointer;
      name_end = get_symbol_end ();

      if (! is_name_beginner (*name))
	{
	  as_warn (_(".end directive has no name"));
	  *input_line_pointer = name_end;
	}
      else
	{
	  symbolS *sym;

	  sym = symbol_find (name);
	  if (sym != alpha_cur_ent_sym)
	    as_warn (_(".end directive names different symbol than .ent"));

	  /* Create an expression to calculate the size of the function.  */
	  if (sym)
	    {
	      symbol_get_obj (sym)->size =
		(expressionS *) xmalloc (sizeof (expressionS));
	      symbol_get_obj (sym)->size->X_op = O_subtract;
	      symbol_get_obj (sym)->size->X_add_symbol
	        = symbol_new ("L0\001", now_seg, frag_now_fix (), frag_now);
	      symbol_get_obj (sym)->size->X_op_symbol = sym;
	      symbol_get_obj (sym)->size->X_add_number = 0;
	    }

	  alpha_cur_ent_sym = NULL;

	  *input_line_pointer = name_end;
	}
      demand_empty_rest_of_line ();
    }
}

static void
s_alpha_mask (fp)
     int fp;
{
  if (ECOFF_DEBUGGING)
    {
      if (fp)
        ecoff_directive_fmask (0);
      else
        ecoff_directive_mask (0);
    }
  else
    discard_rest_of_line ();
}

static void
s_alpha_frame (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_frame (0);
  else
    discard_rest_of_line ();
}

static void
s_alpha_prologue (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *sym;
  int arg;

  arg = get_absolute_expression ();
  demand_empty_rest_of_line ();

  if (ECOFF_DEBUGGING)
    sym = ecoff_get_cur_proc_sym ();
  else
    sym = alpha_cur_ent_sym;
  know (sym != NULL);

  switch (arg)
    {
      case 0: /* No PV required.  */
	S_SET_OTHER (sym, STO_ALPHA_NOPV);
	break;
      case 1: /* Std GP load.  */
	S_SET_OTHER (sym, STO_ALPHA_STD_GPLOAD);
	break;
      case 2: /* Non-std use of PV.  */
	break;

      default:
	as_bad (_("Invalid argument %d to .prologue."), arg);
	break;
    }  
}

static void
s_alpha_coff_wrapper (which)
     int which;
{
  static void (* const fns[]) PARAMS ((int)) = {
    ecoff_directive_begin,
    ecoff_directive_bend,
    ecoff_directive_def,
    ecoff_directive_dim,
    ecoff_directive_endef,
    ecoff_directive_file,
    ecoff_directive_scl,
    ecoff_directive_tag,
    ecoff_directive_val,
    ecoff_directive_loc,
  };

  assert (which >= 0 && which < (int)(sizeof(fns)/sizeof(*fns)));

  if (ECOFF_DEBUGGING)
    (*fns[which])(0);
  else
    {
      as_bad (_("ECOFF debugging is disabled."));
      ignore_rest_of_line ();
    }
}
#endif /* OBJ_ELF */
d3455 1
a3455 1
#define EVAX_SECTION_COUNT 5
d3457 1
a3457 1
    { "NULL", ".rdata", ".comm", ".link", ".ctors", ".dtors" };
d3461 1
a3461 1
      as_fatal (_("Unknown section directive"));
d3474 13
d3511 1
a3511 1
      as_fatal (_(".ent directive has no symbol"));
d3517 1
a3517 1
  symbol_get_bfdsym (symbol)->flags |= BSF_FUNCTION;
d3539 1
a3539 1
      as_warn (_("Bad .frame directive 1./2. param"));
d3551 1
a3551 1
      as_warn (_("Bad .frame directive 3./4. param"));
d3576 1
a3576 1
      as_bad (_(".pdesc directive not in link (.link) section"));
d3584 1
a3584 1
      as_fatal (_(".pdesc has no matching .ent"));
d3589 1
a3589 2
  *symbol_get_obj (alpha_evax_proc.symbol) =
    (valueT) seginfo->literal_pool_size;
d3594 1
a3594 1
      as_warn (_(".pdesc directive has no entry symbol"));
d3601 1
a3601 2
  symbol_get_bfdsym (alpha_evax_proc.symbol)->udata.p
    = symbol_get_bfdsym (entry_sym);
d3606 1
a3606 1
      as_warn (_("No comma after .pdesc <entryname>"));
d3629 1
a3629 1
      as_fatal (_("unknown procedure kind"));
d3724 1
a3724 1
      as_bad (_(".name directive not in link (.link) section"));
d3732 1
a3732 1
      as_warn (_(".name directive has no symbol"));
d3767 1
a3767 1
      as_fatal (_("No symbol after .linkage"));
d3796 1
a3796 1
      as_fatal (_("No symbol after .code_address"));
d3831 1
a3831 1
      as_warn (_("Bad .mask directive"));
d3853 1
a3853 1
      as_warn (_("Bad .fmask directive"));
d3876 1
d3893 1
a3893 1
	   alpha_flag_hash_long_names, alpha_flag_show_after_trunc);
d3896 1
a3896 1
  symbol_get_bfdsym (s)->flags |= BSF_FILE;
d3900 1
a3900 1
  symbol_get_bfdsym (s)->flags |= BSF_FILE;
d3911 1
a3911 1
     int ignore ATTRIBUTE_UNUSED;
d3949 1
a3949 1
    alpha_align (2, (char *) NULL, alpha_insn_label, 0);
d3993 1
a3993 1
    alpha_align (log_size, (char *) NULL, alpha_insn_label, 0);
d4006 1
a4006 1
     int is_static ATTRIBUTE_UNUSED;
a4014 1
  SKIP_WHITESPACE ();
d4024 1
a4024 1
      as_warn (_("Expected comma after name \"%s\""), name);
d4034 2
a4035 2
  /*  *symbol_get_obj (symbolP) = (signed char) temp; */
  as_warn (_("unhandled: .proc %s,%d"), name, temp);
d4044 1
a4044 1
     int x ATTRIBUTE_UNUSED;
d4046 1
a4046 1
  char *name, ch, *s;
d4049 4
a4052 3
  SKIP_WHITESPACE ();
  name = input_line_pointer;
  ch = get_symbol_end ();
d4071 1
a4071 1
    as_warn (_("Tried to .set unrecognized mode `%s'"), name);
d4082 1
a4082 1
     int ignore ATTRIBUTE_UNUSED;
d4088 1
a4088 1
      as_warn (_("File overrides no-base-register option."));
d4105 1
a4105 1
      as_warn (_("Bad base register, using $%d."), alpha_gp_register);
d4117 1
a4117 1
     int ignore ATTRIBUTE_UNUSED;
d4127 1
a4127 1
      as_bad (_("Alignment too large: %d. assumed"), align);
d4131 1
a4131 1
      as_warn (_("Alignment negative: 0 assumed"));
d4147 1
a4147 1
      alpha_align (align, pfill, alpha_insn_label, 1);
d4192 1
a4192 1
    alpha_align (log_size, (char *) NULL, alpha_insn_label, 0);
a4196 40

/* Here come the .uword, .ulong, and .uquad explicitly unaligned
   pseudos.  We just turn off auto-alignment and call down to cons.  */

static void
s_alpha_ucons (bytes)
     int bytes;
{
  int hold = alpha_auto_align_on;
  alpha_auto_align_on = 0;
  cons (bytes);
  alpha_auto_align_on = hold;
}

/* Switch the working cpu type.  */

static void
s_alpha_arch (ignored)
     int ignored ATTRIBUTE_UNUSED;
{
  char *name, ch;
  const struct cpu_type *p;

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  ch = get_symbol_end ();

  for (p = cpu_types; p->name; ++p)
    if (strcmp(name, p->name) == 0)
      {
        alpha_target_name = p->name, alpha_target = p->flags;
	goto found;
      }
  as_warn("Unknown CPU identifier `%s'", name);

found:
  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

d4233 1
d4262 1
a4262 1
  { "comm", s_alpha_comm, 0},
d4266 1
a4266 22
#endif
#ifdef OBJ_ELF
  /* Frame related pseudos.  */
  {"ent", s_alpha_ent, 0},
  {"end", s_alpha_end, 0},
  {"mask", s_alpha_mask, 0},
  {"fmask", s_alpha_mask, 1},
  {"frame", s_alpha_frame, 0},
  {"prologue", s_alpha_prologue, 0},
  /* COFF debugging related pseudos.  */
  {"begin", s_alpha_coff_wrapper, 0},
  {"bend", s_alpha_coff_wrapper, 1},
  {"def", s_alpha_coff_wrapper, 2},
  {"dim", s_alpha_coff_wrapper, 3},
  {"endef", s_alpha_coff_wrapper, 4},
  {"file", s_alpha_coff_wrapper, 5},
  {"scl", s_alpha_coff_wrapper, 6},
  {"tag", s_alpha_coff_wrapper, 7},
  {"val", s_alpha_coff_wrapper, 8},
  {"loc", s_alpha_coff_wrapper, 9},
#else
  {"prologue", s_ignore, 0},
d4282 1
a4297 12
/* Unaligned data pseudos.  */
  {"uword", s_alpha_ucons, 2},
  {"ulong", s_alpha_ucons, 4},
  {"uquad", s_alpha_ucons, 8},

#ifdef OBJ_ELF
/* Dwarf wants these versions of unaligned.  */
  {"2byte", s_alpha_ucons, 2},
  {"4byte", s_alpha_ucons, 4},
  {"8byte", s_alpha_ucons, 8},
#endif

a4301 2
  {"arch", s_alpha_arch, 0},

d4371 1
a4371 1
  printf (_("Chose GP value of %lx\n"), alpha_gp_value);
d4382 1
a4382 1
alpha_align (n, pfill, label, force)
a4385 1
     int force ATTRIBUTE_UNUSED;
d4395 1
a4395 5
	  static char const unop[4] = { 0x00, 0x00, 0xe0, 0x2f };
	  static char const nopunop[8] = {
		0x1f, 0x04, 0xff, 0x47,
		0x00, 0x00, 0xe0, 0x2f
	  };
d4404 1
a4404 4
	  if (alpha_current_align < 3)
	    frag_align_pattern (3, unop, sizeof unop, 0);
	  if (n > 3)
	    frag_align_pattern (n, nopunop, sizeof nopunop, 0);
d4414 1
a4414 1
  if (label != NULL && S_GET_SEGMENT (label) == now_seg)
d4416 2
a4417 1
      symbol_set_frag (label, frag_now);
d4421 1
a4421 4
  record_alignment (now_seg, n);

  /* ??? if alpha_flag_relax && force && elf, record the requested alignment
     in a reloc for the linker to see.  */
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d1375 1
a1375 1
	  if (!alpha_noat_on && (num + is_float) == AXP_REG_AT)
@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
a60 1
#include "dwarf2dbg.h"
d64 1
d74 2
a75 1
struct alpha_fixup {
d80 2
a81 1
struct alpha_insn {
d88 2
a89 1
enum alpha_macro_arg {
d103 2
a104 1
struct alpha_macro {
d111 1
a111 1
/* Extra expression types.  */
d130 1
d148 1
a148 1
	(((offsetT) (x) >> 15) == 0 || ((offsetT) (x) >> 15) == -1)
d150 1
a150 1
	(((offsetT) (x) >> 31) == 0 || ((offsetT) (x) >> 31) == -1)
d152 4
a155 4
#define range_signed_16(x)	((offsetT) (x) >= -(offsetT) 0x8000 &&	\
				 (offsetT) (x) <=  (offsetT) 0x7FFF)
#define range_signed_32(x)	((offsetT) (x) >= -(offsetT) 0x80000000 && \
				 (offsetT) (x) <=  (offsetT) 0x7FFFFFFF)
d163 2
a164 2
#define sign_extend_16(x)	((short) (x))
#define sign_extend_32(x)	((int) (x))
d166 2
a167 2
#define sign_extend_16(x)	((offsetT) (((x) & 0xFFFF) ^ 0x8000) - 0x8000)
#define sign_extend_32(x)	((offsetT) (((x) & 0xFFFFFFFF) \
d173 1
a173 1
#define set_tok_reg(t, r)	(memset (&(t), 0, sizeof (t)),		\
d176 1
a176 1
#define set_tok_preg(t, r)	(memset (&(t), 0, sizeof (t)),		\
d179 1
a179 1
#define set_tok_cpreg(t, r)	(memset (&(t), 0, sizeof (t)),		\
d182 1
a182 1
#define set_tok_freg(t, r)	(memset (&(t), 0, sizeof (t)),		\
d184 2
a185 2
				 (t).X_add_number = (r) + 32)
#define set_tok_sym(t, s, a)	(memset (&(t), 0, sizeof (t)),		\
d189 1
a189 1
#define set_tok_const(t, n)	(memset (&(t), 0, sizeof (t)),		\
d192 1
a248 3
static void s_alpha_file PARAMS ((int));
static void s_alpha_loc PARAMS ((int));
static void s_alpha_stab PARAMS ((int));
d272 1
d309 1
a309 1
#define OPTION_RELAX (OPTION_32ADDR + 1)
d312 2
a313 2
#define OPTION_MDEBUG (OPTION_RELAX + 1)
#define OPTION_NO_MDEBUG (OPTION_MDEBUG + 1)
d320 2
a321 1
size_t md_longopts_size = sizeof (md_longopts);
d379 1
a379 1
/* Symbols referring to said sections.  */
d397 1
a398 1
/* The active .ent symbol.  */
d436 1
a436 1
int alpha_flag_mdebug = -1;
d478 1
a478 1
		  : (int) (op) - (int) O_literal) ]
d550 1
a550 1
  = sizeof (alpha_reloc_op) / sizeof (*alpha_reloc_op);
d556 1
a556 1
#define ALPHA_RELOC_SEQUENCE_OK(X) ((X) > 0 && ((unsigned) (X)) == (X))
d576 2
a577 1
static const struct cpu_type {
d580 2
a581 1
} cpu_types[] = {
d583 1
a583 1
     This supports usage under DU 4.0b that does ".arch ev4", and
d638 1
a638 1
  { "ldb",	emit_ldX, (PTR) 0,
d640 1
a640 1
  { "ldbu",	emit_ldXu, (PTR) 0,
d642 1
a642 1
  { "ldw",	emit_ldX, (PTR) 1,
d644 1
a644 1
  { "ldwu",	emit_ldXu, (PTR) 1,
d647 1
a647 1
  { "uldw",	emit_uldX, (PTR) 1,
d649 1
a649 1
  { "uldwu",	emit_uldXu, (PTR) 1,
d651 1
a651 1
  { "uldl",	emit_uldX, (PTR) 2,
d653 1
a653 1
  { "uldlu",	emit_uldXu, (PTR) 2,
d655 1
a655 1
  { "uldq",	emit_uldXu, (PTR) 3,
d699 1
a699 1
  { "stb",	emit_stX, (PTR) 0,
d701 1
a701 1
  { "stw",	emit_stX, (PTR) 1,
d703 1
a703 1
  { "ustw",	emit_ustX, (PTR) 1,
d705 1
a705 1
  { "ustl",	emit_ustX, (PTR) 2,
d707 1
a707 1
  { "ustq",	emit_ustX, (PTR) 3,
d720 1
a720 1
  { "sextb",	emit_sextX, (PTR) 0,
d724 1
a724 1
  { "sextw",	emit_sextX, (PTR) 1,
d804 1
a804 1
  = sizeof (alpha_macros) / sizeof (*alpha_macros);
d827 1
a827 1
  for (i = 0; i < alpha_num_opcodes;)
d832 1
a832 1
      retval = hash_insert (alpha_opcode_hash, name, (PTR) &alpha_opcodes[i]);
d847 1
a847 1
	  (void) hash_insert (alpha_opcode_hash, p, (PTR) &alpha_opcodes[i]);
d861 1
a861 1
  for (i = 0; i < alpha_num_macros;)
d866 1
a866 1
      retval = hash_insert (alpha_macro_hash, name, (PTR) &alpha_macros[i]);
d868 1
a868 2
	as_fatal (_("internal error: can't hash macro `%s': %s"),
		  name, retval);
d881 3
a883 3
      sprintf (name, "$%d", i);
      alpha_register_table[i] = symbol_create (name, reg_section, i,
					       &zero_address_frag);
d888 3
a890 3
      sprintf (name, "$f%d", i - 32);
      alpha_register_table[i] = symbol_create (name, reg_section, i,
					       &zero_address_frag);
d914 3
a916 3
      segT sec = subseg_new (".mdebug", (subsegT) 0);
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);
      bfd_set_section_alignment (stdoutput, sec, 3);
d920 1
a920 1
  subseg_set (text_section, 0);
d924 1
a924 1
  alpha_literal_hash = hash_new ();
d967 2
a968 2
  int align = bfd_get_section_alignment (stdoutput, seg);
  valueT mask = ((valueT) 1 << align) - 1;
d974 2
a975 2
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
d1063 1
a1063 1
      g_switch_value = atoi (arg);
d1070 1
a1070 1
	  if (strcmp (arg, p->name) == 0)
d1075 1
a1075 1
	as_warn (_("Unknown CPU identifier `%s'"), arg);
d1081 1
a1081 1
    case '+':			/* For g++.  Hash any name > 63 chars long.  */
d1119 1
a1119 1
  fputs (_("\
d1246 1
a1246 1
	  image = bfd_getl32 (fixpos);
d1255 1
a1255 1
	  image = bfd_getl32 (fixpos);
a1292 4
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return 1;

d1297 1
a1297 1
	if ((int) fixP->fx_r_type >= 0)
d1301 2
a1302 2
	assert (-(int) fixP->fx_r_type < (int) alpha_num_operands);
	operand = &alpha_operands[-(int) fixP->fx_r_type];
d1313 3
a1315 3
	image = bfd_getl32 (fixpos);
	image = insert_operand (image, operand, (offsetT) value,
				fixP->fx_file, fixP->fx_line);
d1324 2
a1325 2
      as_warn_where (fixP->fx_file, fixP->fx_line,
		     _("type %d reloc done?\n"), (int) fixP->fx_r_type);
d1330 1
a1330 1
  md_number_to_chars (fixpos, image, 4);
d1342 1
a1342 1
md_undefined_symbol (name)
d1358 1
a1358 1
	  if (!isdigit (*++name))
d1366 1
a1366 1
	  else if (name[0] != '0' && isdigit (name[1]) && name[2] == '\0')
d1376 1
a1376 1
	    as_warn (_("Used $at without \".set noat\""));
d1383 1
a1383 1
		as_warn (_("Used $at without \".set noat\""));
a1461 2
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
d1471 1
a1471 2
      assert ((int) f->fx_r_type < 0
	      && -(int) f->fx_r_type < (int) alpha_num_operands);
a1520 2
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
d1531 2
a1532 2
      assert ((int) f->fx_r_type < 0
	      && - (int) f->fx_r_type < (int) alpha_num_operands);
d1555 1
a1555 1
  assert ((int) fixp->fx_r_type > 0);
d1591 1
a1591 1
	  && !S_IS_COMMON (fixp->fx_addsy))
d1618 1
a1618 1
      *strchr (s, '\0') = c;
d1650 4
a1653 4
/* Before the relocations are written, reorder them, so that user
   supplied !lituse relocations follow the appropriate !literal
   relocations.  Also convert the gas-internal relocations to the
   appropriate linker relocations.  */
d1664 3
a1666 5
      /* Go over each section, reordering the relocations so that all
         of the explicit LITUSE's are adjacent to the explicit
         LITERAL's.  */
      bfd_map_over_sections (stdoutput, alpha_adjust_symtab_relocs,
			     (char *) 0);
d1669 1
d1675 1
a1675 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1677 1
a1677 1
     PTR ptr ATTRIBUTE_UNUSED;
d1692 2
a1693 3
  /* If seginfo is NULL, we did not create this section; don't do
     anything with it.  By using a pointer to a pointer, we can update
     the links in place.  */
d1706 1
a1706 1
      fixp->fx_next = (fixS *) 0;
d1719 1
a1719 1
		   (long) fixp,
d1734 1
a1734 1
		   (long) fixp,
d1752 1
a1752 1
		   (long) fixp,
d1755 1
a1755 1
		   (long) fixp->tc_fix_data.next_lituse);
d1788 1
a1788 1
		       lituse != (fixS *) 0;
d1816 1
d1885 1
a1885 1
	       (int) t->X_add_number);
d1963 1
a1963 1
	  for (i = alpha_num_reloc_op - 1; i >= 0; i--, r++)
d1971 1
a1971 2
	      as_bad (_("Unknown relocation operand: !%s"),
		      input_line_pointer);
d1984 1
a1984 2
	      as_bad (_("Bad sequence number: !%s!%s"),
		      r->name, input_line_pointer);
d2005 1
a2005 1
	    /* First try for parenthesized register ...  */
d2062 1
a2062 1
find_opcode_match (first_opcode, tok, pntok, pcpumatch)
d2104 1
a2104 1
		  || !is_ir_num (tok[tokidx].X_add_number))
d2109 1
a2109 1
		  || !is_fpr_num (tok[tokidx].X_add_number))
d2112 1
a2112 1
	    case AXP_OPERAND_IR | AXP_OPERAND_PARENS:
d2114 1
a2114 1
		  || !is_ir_num (tok[tokidx].X_add_number))
d2117 1
a2117 1
	    case AXP_OPERAND_IR | AXP_OPERAND_PARENS | AXP_OPERAND_COMMA:
d2119 1
a2119 1
		  || !is_ir_num (tok[tokidx].X_add_number))
d2142 1
a2142 1
	      abort ();
d2156 2
a2157 2
  while (++opcode - alpha_opcodes < alpha_num_opcodes
	 && !strcmp (opcode->name, first_opcode->name));
d2160 1
a2160 1
    *pcpumatch = got_cpu_match;
d2169 1
a2169 1
find_macro_match (first_macro, tok, pntok)
d2196 1
a2196 1
		  || !is_ir_num (tok[tokidx].X_add_number))
d2204 1
a2204 1
		  || !is_ir_num (tok[tokidx].X_add_number))
d2212 1
a2212 1
		  && is_ir_num (tok[tokidx].X_add_number))
d2219 1
a2219 1
		  || !is_ir_num (tok[tokidx].X_add_number))
d2227 1
a2227 1
		  || !is_fpr_num (tok[tokidx].X_add_number))
d2301 2
a2302 2
  while (++macro - alpha_macros < alpha_num_macros
	 && !strcmp (macro->name, first_macro->name));
d2310 1
a2310 1
insert_operand (insn, operand, val, file, line)
d2338 1
a2338 1
	  sprint_value (buf, val);
d2340 1
a2340 1
	    as_warn_where (file, line, err, buf, min, max);
d2342 1
a2342 1
	    as_warn (err, buf, min, max);
d2366 1
a2366 1
assemble_insn (opcode, tok, ntok, insn)
d2382 1
a2382 1
      const expressionS *t = (const expressionS *) 0;
d2387 1
a2387 1
	  image = insert_operand (image, operand, 0, NULL, 0);
d2410 1
a2410 1
	      abort ();
d2421 2
a2422 2
	  image = insert_operand (image, operand, regno (t->X_add_number),
				  NULL, 0);
d2426 1
a2426 1
	  image = insert_operand (image, operand, t->X_add_number, NULL, 0);
d2434 1
a2434 1
	      as_fatal (_("too many fixups"));
d2454 1
a2454 1
     struct alpha_insn *insn;
d2459 1
a2459 1
  /* Take care of alignment duties.  */
a2469 4
#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif

d2473 1
a2473 1
      const struct alpha_operand *operand = (const struct alpha_operand *) 0;
d2483 1
a2483 1
      if ((int) fixup->reloc < 0)
d2485 1
a2485 1
	  operand = &alpha_operands[-(int) fixup->reloc];
d2489 2
a2490 3
      else
	switch (fixup->reloc)
	  {
d2492 6
a2497 6
	    /* These relocation types are only used internally.  */
	  case BFD_RELOC_ALPHA_GPDISP_HI16:
	  case BFD_RELOC_ALPHA_GPDISP_LO16:
	    size = 2;
	    pcrel = 0;
	    break;
d2500 11
a2510 11
	    /* and these also are internal only relocations */
	  case BFD_RELOC_ALPHA_USER_LITERAL:
	  case BFD_RELOC_ALPHA_USER_LITUSE_BASE:
	  case BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF:
	  case BFD_RELOC_ALPHA_USER_LITUSE_JSR:
	  case BFD_RELOC_ALPHA_USER_GPDISP:
	  case BFD_RELOC_ALPHA_USER_GPRELHIGH:
	  case BFD_RELOC_ALPHA_USER_GPRELLOW:
	    size = 2;
	    pcrel = 0;
	    break;
d2513 5
a2517 5
	  default:
	    {
	      reloc_howto_type *reloc_howto
		= bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	      assert (reloc_howto);
d2519 2
a2520 5
	      size = bfd_get_reloc_size (reloc_howto);
	      pcrel = reloc_howto->pc_relative;
	    }
	    assert (size >= 1 && size <= 4);
	    break;
d2522 3
d2562 1
a2562 1
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR) info);
d2593 1
a2593 1
	      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR) info);
d2608 1
a2608 1
	  if ((int) fixup->reloc < 0)
d2625 1
a2625 1
assemble_tokens_to_insn (opname, tok, ntok, insn)
d2648 1
a2648 1
		alpha_target_name);
d2687 1
a2687 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d2689 1
a2689 1
      const expressionS *reloc_exp = &tok[ntok - 1];
d2692 1
a2692 1
	      (int) reloc_exp->X_add_number, opname);
d2721 1
d2754 1
a2754 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d2756 1
a2756 1
      const expressionS *reloc_exp = &tok[ntok - 1];
d2759 1
a2759 1
	      (int) reloc_exp->X_add_number, "ldgp");
d2842 1
a2842 1
		return offset;
d2941 1
a2941 1
	assert (explicit_reloc == (const expressionS *) 0);
d2963 2
a2964 3
	if (1
	    || (!range_signed_32 (addend)
		&& (alpha_noat_on || targreg == AXP_REG_AT)))
d2997 1
a2997 1
	assert (explicit_reloc == (const expressionS *) 0);
d3036 1
a3036 1
	emit_insn (&insn);
d3056 1
a3056 1
      assert (explicit_reloc == (const expressionS *) 0);
d3061 1
a3061 1
	 absolute value and that that value will fit in 16 bits.  */
d3063 1
a3063 1
      assert (explicit_reloc == (const expressionS *) 0);
d3165 1
a3165 1
		   sizeof (struct alpha_fixup) * insn.nfixups);
d3257 1
a3257 1
  const expressionS *reloc = (const expressionS *) 0;
d3260 1
a3260 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d3264 1
a3264 1
      reloc = &tok[ntok - 1];
d3270 1
a3270 1
		  (int) reloc->X_add_number, (const char *) opname);
d3272 1
a3272 1
	  reloc = (const expressionS *) 0;
d3286 1
a3286 1
	      || !is_ir_num (tok[0].X_add_number)
d3289 1
a3289 1
	      || !is_ir_num (tok[2].X_add_number))
d3291 2
a3292 2
	      as_bad (_("bad instruction format for lda !%s!%ld"), r->name,
		      (long) reloc->X_add_number);
d3294 1
a3294 1
	      reloc = (const expressionS *) 0;
d3325 1
a3325 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d3327 1
a3327 1
      const expressionS *reloc_exp = &tok[ntok - 1];
d3330 1
a3330 1
	      (int) reloc_exp->X_add_number, "ldah");
d3357 1
a3357 1
  const expressionS *reloc = (const expressionS *) 0;
d3359 1
a3359 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d3363 1
a3363 1
      reloc = &tok[ntok - 1];
d3371 1
a3371 1
	  if (strcmp ((const char *) opname, "ldq") == 0)
d3382 1
a3382 1
		  (int) reloc->X_add_number, (const char *) opname);
d3393 1
a3393 1
			    &newtok[1], (const expressionS *) 0);
d3398 1
a3398 1
  assemble_tokens_to_insn ((const char *) opname, newtok, 3, &insn);
d3422 1
a3422 1
		   sizeof (struct alpha_fixup) * insn.nfixups);
d3448 1
a3448 1
  const expressionS *reloc = (const expressionS *) 0;
d3450 1
a3450 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d3455 1
a3455 1
	  const struct alpha_reloc_op_tag *r = &alpha_reloc_op[reloc->X_md];
d3457 1
a3457 1
		  (int) reloc->X_add_number, (const char *) opname);
d3467 1
a3467 1
  if (tok[1].X_op != O_constant || !range_signed_16 (tok[1].X_add_number))
d3473 1
a3473 1
				(const expressionS *) 0);
d3484 1
a3484 1
  assemble_tokens_to_insn ((const char *) opname, newtok, 3, &insn);
d3508 1
a3508 1
		   sizeof (struct alpha_fixup) * insn.nfixups);
d3529 1
a3529 1
    emit_ir_load (tok, ntok, ldXu_op[(long) vlgsize]);
d3535 1
a3535 1
      if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d3537 1
a3537 1
	  const expressionS *reloc_exp = &tok[ntok - 1];
d3542 1
a3542 1
		  (int) reloc_exp->X_add_number, "ldbu/ldwu");
d3567 1
a3567 1
      assemble_tokens (extXl_op[(long) vlgsize], newtok, 3, 1);
d3580 1
a3580 1
  assemble_tokens (sextX_op[(long) vlgsize], tok, 1, 1);
d3592 1
a3592 1
  long lgsize = (long) vlgsize;
d3614 1
a3614 1
  set_tok_const (newtok[1], (1 << lgsize) - 1);
d3649 1
a3649 1
  assemble_tokens (sextX_op[(long) vlgsize], tok, 1, 1);
d3663 1
a3663 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d3665 1
a3665 1
      const expressionS *reloc_exp = &tok[ntok - 1];
d3668 1
a3668 1
	      (int) reloc_exp->X_add_number, "ldil");
d3673 1
a3673 1
  memcpy (newtok, tok, sizeof (newtok));
d3687 1
a3687 1
  int lgsize = (int) (long) vlgsize;
d3696 1
a3696 1
	as_bad (_("macro requires $at register while noat in effect"));
d3745 1
a3745 1
  int lgsize = (int) (long) vlgsize;
d3764 1
a3764 1
  set_tok_const (newtok[1], (1 << lgsize) - 1);
d3815 1
a3815 1
  set_tok_const (newtok[1], (1 << lgsize) - 1);
d3828 1
a3828 1
  long lgsize = (long) vlgsize;
d3838 1
a3838 1
      if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d3840 1
a3840 1
	  const expressionS *reloc_exp = &tok[ntok - 1];
d3845 1
a3845 1
		  (int) reloc_exp->X_add_number, "setxt");
d3897 1
a3897 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d3899 1
a3899 1
      const expressionS *reloc_exp = &tok[ntok - 1];
d3902 1
a3902 1
	      (int) reloc_exp->X_add_number, (char char *) symname);
d3948 1
a3948 1
	  assemble_tokens ("mov", newtok, 2, 1);
d3959 1
a3959 1
  sym = symbol_find_or_make ((const char *) symname);
d4007 1
a4007 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d4009 1
a4009 1
      const expressionS *reloc_exp = &tok[ntok - 1];
d4012 1
a4012 1
	      (int) reloc_exp->X_add_number, (const char *) symname);
d4025 1
a4025 1
  sym = symbol_find_or_make ((const char *) symname);
d4060 1
a4060 1
	  assemble_tokens ("mov", newtok, 2, 1);
d4114 1
a4114 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d4116 1
a4116 1
      const expressionS *reloc_exp = &tok[ntok - 1];
d4119 1
a4119 1
	      (int) reloc_exp->X_add_number, opname);
d4141 1
a4141 1
				(const expressionS *) 0);
d4165 1
a4165 1
		   sizeof (struct alpha_fixup) * insn.nfixups);
d4186 1
a4186 1
  const char *opname = (const char *) vopname;
d4191 1
a4191 1
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
d4193 1
a4193 1
      const expressionS *reloc_exp = &tok[ntok - 1];
d4196 1
a4196 1
	      (int) reloc_exp->X_add_number, opname);
d4219 1
a4219 1
    set_tok_const (newtok[2], strcmp (opname, "ret") == 0);
d4312 1
a4312 1
      input_line_pointer++;
d4327 1
a4327 1
    {
d4346 1
a4346 1
#ifdef OBJ_EVAX
d4502 1
a4502 1
		= symbol_new ("L0\001", now_seg, frag_now_fix (), frag_now);
d4522 1
a4522 1
	ecoff_directive_fmask (0);
d4524 1
a4524 1
	ecoff_directive_mask (0);
d4558 13
a4570 81
    case 0: /* No PV required.  */
      S_SET_OTHER (sym, STO_ALPHA_NOPV
		   | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
      break;
    case 1: /* Std GP load.  */
      S_SET_OTHER (sym, STO_ALPHA_STD_GPLOAD
		   | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
      break;
    case 2: /* Non-std use of PV.  */
      break;

    default:
      as_bad (_("Invalid argument %d to .prologue."), arg);
      break;
    }
}

static char *first_file_directive;

static void
s_alpha_file (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* Save the first .file directive we see, so that we can change our
     minds about whether ecoff debugging should or shouldn't be enabled.  */
  if (alpha_flag_mdebug < 0 && ! first_file_directive)
    {
      char *start = input_line_pointer;
      size_t len;

      discard_rest_of_line ();

      len = input_line_pointer - start;
      first_file_directive = xmalloc (len + 1);
      memcpy (first_file_directive, start, len);
      first_file_directive[len] = '\0';

      input_line_pointer = start;
    }

  if (ECOFF_DEBUGGING)
    ecoff_directive_file (0);
  else
    dwarf2_directive_file (0);
}

static void
s_alpha_loc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (ECOFF_DEBUGGING)
    ecoff_directive_loc (0);
  else
    dwarf2_directive_loc (0);
}

static void
s_alpha_stab (n)
     int n;
{
  /* If we've been undecided about mdebug, make up our minds in favour.  */
  if (alpha_flag_mdebug < 0)
    {
      segT sec = subseg_new (".mdebug", 0);
      bfd_set_section_flags (stdoutput, sec, SEC_HAS_CONTENTS | SEC_READONLY);
      bfd_set_section_alignment (stdoutput, sec, 3);

      ecoff_read_begin_hook ();

      if (first_file_directive)
	{
	  char *save_ilp = input_line_pointer;
	  input_line_pointer = first_file_directive;
	  ecoff_directive_file (0);
	  input_line_pointer = save_ilp;
	  free (first_file_directive);
	}

      alpha_flag_mdebug = 1;
    }
  s_stab (n);
d4583 1
d4587 1
d4590 1
a4590 1
  assert (which >= 0 && which < (int) (sizeof (fns)/sizeof (*fns)));
d4593 1
a4593 1
    (*fns[which]) (0);
d4603 1
a4603 1

d4605 1
a4605 1

d4612 1
a4612 1
  static char *section_name[EVAX_SECTION_COUNT + 1] =
d4629 1
d4667 1
d4760 1
a4760 1
  if (strncmp (name, "stack", 5) == 0)
d4764 1
a4764 1
  else if (strncmp (name, "reg", 3) == 0)
d4768 1
a4768 1
  else if (strncmp (name, "null", 4) == 0)
d4793 3
a4795 2
    | ((alpha_evax_proc.framereg == 29) ? PDSC_S_M_BASE_REG_IS_FP : 0);
  *(p + 1) = PDSC_S_M_NATIVE | PDSC_S_M_NO_JACKET;
d4799 13
a4811 13
    case PDSC_S_K_KIND_NULL:
      *(p + 2) = 0;
      *(p + 3) = 0;
      break;
    case PDSC_S_K_KIND_FP_REGISTER:
      *(p + 2) = alpha_evax_proc.fp_save;
      *(p + 3) = alpha_evax_proc.ra_save;
      break;
    case PDSC_S_K_KIND_FP_STACK:
      md_number_to_chars (p + 2, (valueT) alpha_evax_proc.rsa_offset, 2);
      break;
    default:		/* impossible */
      break;
d4814 2
a4815 2
  *(p + 4) = 0;
  *(p + 5) = alpha_evax_proc.type & 0x0f;
d4818 1
a4818 1
  md_number_to_chars (p + 6, (valueT) 0, 2);
d4820 1
a4820 1
  fix_new_exp (frag_now, p - frag_now->fr_literal+8, 8, &exp, 0, BFD_RELOC_64);
d4832 1
a4832 1
  md_number_to_chars (p, (valueT) alpha_evax_proc.framesize, 4);
d4834 1
a4834 1
  md_number_to_chars (p + 4, (valueT) 0, 2);
d4837 1
a4837 1
  md_number_to_chars (p + 6, alpha_evax_proc.prologue, 2);
d4851 1
a4851 1
  md_number_to_chars (p + 4, alpha_evax_proc.fmask, 4);
d4856 1
d4892 1
a4892 1
  fix_new_exp (frag_now, p - frag_now->fr_literal, 8, &exp, 0, BFD_RELOC_64);
d4897 1
d4926 1
d4955 1
d4967 1
d4982 1
a4982 1
      (void) get_absolute_expression ();
d4989 1
d5025 1
d5067 1
a5067 1
      e.X_add_symbol = section_symbol (absolute_section);
d5073 1
a5073 1
      abort ();
d5100 1
a5100 1
  fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
d5369 1
a5369 1
    if (strcmp (name, p->name) == 0)
d5371 1
a5371 1
	alpha_target_name = p->name, alpha_target = p->flags;
d5374 1
a5374 1
  as_warn ("Unknown CPU identifier `%s'", name);
d5380 1
d5382 1
d5387 3
a5389 3
alpha_print_token (f, exp)
     FILE *f;
     const expressionS *exp;
d5393 15
a5407 15
    case O_cpregister:
      putc (',', f);
      /* FALLTHRU */
    case O_pregister:
      putc ('(', f);
      {
	expressionS nexp = *exp;
	nexp.X_op = O_register;
	print_expr (f, &nexp);
      }
      putc (')', f);
      break;
    default:
      print_expr (f, exp);
      break;
d5415 2
a5416 1
const pseudo_typeS md_pseudo_table[] = {
a5457 4
  {"file", s_alpha_file, 5},
  {"loc", s_alpha_loc, 9},
  {"stabs", s_alpha_stab, 's'},
  {"stabn", s_alpha_stab, 'n'},
d5464 5
a5468 3
  {"scl", s_alpha_coff_wrapper, 5},
  {"tag", s_alpha_coff_wrapper, 6},
  {"val", s_alpha_coff_wrapper, 7},
d5521 1
d5569 1
a5569 2
  alpha_gp_value = 0;
  alpha_gp_value--;
d5610 21
a5630 2
      if (subseg_text_p (now_seg))
	frag_align_code (n, 0);
d5647 1
a5647 1
  /* ??? If alpha_flag_relax && force && elf, record the requested alignment
a5648 45
}

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
alpha_handle_align (fragp)
     fragS *fragp;
{
  static char const unop[4] = { 0x00, 0x00, 0xe0, 0x2f };
  static char const nopunop[8] = {
    0x1f, 0x04, 0xff, 0x47,
    0x00, 0x00, 0xe0, 0x2f
  };

  int bytes, fix;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;
  fix = 0;

  if (bytes & 3)
    {
      fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }

  if (bytes & 4)
    {
      memcpy (p, unop, 4);
      p += 4;
      bytes -= 4;
      fix += 4;
    }

  memcpy (p, nopunop, 8);

  fragp->fr_fix += fix;
  fragp->fr_var = 8;
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.
d65 1
a65 1
#include "safe-ctype.h"
d67 1
a67 1
/* Local types.  */
d75 1
a75 2
struct alpha_fixup
{
d80 1
a80 2
struct alpha_insn
{
d84 1
a84 1
  long sequence;
d87 13
a99 10
enum alpha_macro_arg
  {
    MACRO_EOA = 1,
    MACRO_IR,
    MACRO_PIR,
    MACRO_OPIR,
    MACRO_CPIR,
    MACRO_FPR,
    MACRO_EXP,
  };
d101 1
a101 2
struct alpha_macro
{
d113 3
a115 1
/* The alpha_reloc_op table below depends on the ordering of these.  */
d117 6
a122 28
#define O_lituse_addr	O_md4	/* !lituse_addr relocation */
#define O_lituse_base	O_md5	/* !lituse_base relocation */
#define O_lituse_bytoff	O_md6	/* !lituse_bytoff relocation */
#define O_lituse_jsr	O_md7	/* !lituse_jsr relocation */
#define O_lituse_tlsgd	O_md8	/* !lituse_tlsgd relocation */
#define O_lituse_tlsldm	O_md9	/* !lituse_tlsldm relocation */
#define O_gpdisp	O_md10	/* !gpdisp relocation */
#define O_gprelhigh	O_md11	/* !gprelhigh relocation */
#define O_gprellow	O_md12	/* !gprellow relocation */
#define O_gprel		O_md13	/* !gprel relocation */
#define O_samegp	O_md14	/* !samegp relocation */
#define O_tlsgd		O_md15	/* !tlsgd relocation */
#define O_tlsldm	O_md16	/* !tlsldm relocation */
#define O_gotdtprel	O_md17	/* !gotdtprel relocation */
#define O_dtprelhi	O_md18	/* !dtprelhi relocation */
#define O_dtprello	O_md19	/* !dtprello relocation */
#define O_dtprel	O_md20	/* !dtprel relocation */
#define O_gottprel	O_md21	/* !gottprel relocation */
#define O_tprelhi	O_md22	/* !tprelhi relocation */
#define O_tprello	O_md23	/* !tprello relocation */
#define O_tprel		O_md24	/* !tprel relocation */

#define DUMMY_RELOC_LITUSE_ADDR		(BFD_RELOC_UNUSED + 1)
#define DUMMY_RELOC_LITUSE_BASE		(BFD_RELOC_UNUSED + 2)
#define DUMMY_RELOC_LITUSE_BYTOFF	(BFD_RELOC_UNUSED + 3)
#define DUMMY_RELOC_LITUSE_JSR		(BFD_RELOC_UNUSED + 4)
#define DUMMY_RELOC_LITUSE_TLSGD	(BFD_RELOC_UNUSED + 5)
#define DUMMY_RELOC_LITUSE_TLSLDM	(BFD_RELOC_UNUSED + 6)
d124 2
a125 1
#define USER_RELOC_P(R) ((R) >= O_literal && (R) <= O_tprel)
d127 1
a127 1
/* Macros for extracting the type and number of encoded register tokens.  */
d133 1
a133 1
/* Something odd inherited from the old assembler.  */
d167 1
a167 1
/* Macros to build tokens.  */
d189 1
a189 4
/* Prototypes for all local functions.  */

static struct alpha_reloc_tag *get_alpha_reloc_tag PARAMS ((long));
static void alpha_adjust_relocs PARAMS ((bfd *, asection *, PTR));
d200 1
a200 1
	   struct alpha_insn *, bfd_reloc_code_real_type));
d207 3
a209 2
static long load_expression
  PARAMS ((int, const expressionS *, int *, expressionS *));
a259 2
static void s_alpha_ucons PARAMS ((int));
static void s_alpha_arch PARAMS ((int));
d266 4
d303 1
a303 2
struct option md_longopts[] =
  {
d305 1
a305 1
    { "32addr", no_argument, NULL, OPTION_32ADDR },
d307 1
a307 1
    { "relax", no_argument, NULL, OPTION_RELAX },
d311 2
a312 2
    { "mdebug", no_argument, NULL, OPTION_MDEBUG },
    { "no-mdebug", no_argument, NULL, OPTION_NO_MDEBUG },
d314 2
a315 2
    { NULL, no_argument, NULL, 0 }
  };
d339 1
a339 1
/* The cpu for which we are generating code.  */
d343 1
a343 1
/* The hash table of instruction opcodes.  */
d346 1
a346 1
/* The hash table of macro opcodes.  */
d350 1
a350 1
/* The $gp relocation symbol.  */
d357 1
a357 1
/* The current $gp register.  */
d360 1
a360 1
/* A table of the register symbols.  */
d363 1
a363 1
/* Constant sections, or sections of constants.  */
d366 1
d378 1
d387 1
a387 1
/* Literal for .litX+0x8000 within .lita.  */
d389 1
d398 1
a398 1
/* Is the assembler not allowed to use $at?  */
d401 1
a401 1
/* Are macros enabled?  */
d404 1
a404 1
/* Are floats disabled?  */
d407 1
a407 1
/* Are addresses 32 bit?  */
d461 2
a462 1
   longer than 64 characters, else longer symbol names are truncated.  */
d472 1
a472 1
(&alpha_reloc_op[ ((!USER_RELOC_P (op))					\
d474 1
a474 1
		  : (int) (op) - (int) O_literal) ])
d476 3
a478 2
#define DEF(NAME, RELOC, REQ, ALLOW) \
 { #NAME, sizeof(#NAME)-1, O_##NAME, RELOC, REQ, ALLOW}
d480 1
a480 2
static const struct alpha_reloc_op_tag
{
d483 1
d485 58
a542 28
  bfd_reloc_code_real_type reloc;		/* relocation before frob */
  unsigned int require_seq : 1;			/* require a sequence number */
  unsigned int allow_seq : 1;			/* allow a sequence number */
}
alpha_reloc_op[] =
{
  DEF(literal, BFD_RELOC_ALPHA_ELF_LITERAL, 0, 1),
  DEF(lituse_addr, DUMMY_RELOC_LITUSE_ADDR, 1, 1),
  DEF(lituse_base, DUMMY_RELOC_LITUSE_BASE, 1, 1),
  DEF(lituse_bytoff, DUMMY_RELOC_LITUSE_BYTOFF, 1, 1),
  DEF(lituse_jsr, DUMMY_RELOC_LITUSE_JSR, 1, 1),
  DEF(lituse_tlsgd, DUMMY_RELOC_LITUSE_TLSGD, 1, 1),
  DEF(lituse_tlsldm, DUMMY_RELOC_LITUSE_TLSLDM, 1, 1),
  DEF(gpdisp, BFD_RELOC_ALPHA_GPDISP, 1, 1),
  DEF(gprelhigh, BFD_RELOC_ALPHA_GPREL_HI16, 0, 0),
  DEF(gprellow, BFD_RELOC_ALPHA_GPREL_LO16, 0, 0),
  DEF(gprel, BFD_RELOC_GPREL16, 0, 0),
  DEF(samegp, BFD_RELOC_ALPHA_BRSGP, 0, 0),
  DEF(tlsgd, BFD_RELOC_ALPHA_TLSGD, 0, 1),
  DEF(tlsldm, BFD_RELOC_ALPHA_TLSLDM, 0, 1),
  DEF(gotdtprel, BFD_RELOC_ALPHA_GOTDTPREL16, 0, 0),
  DEF(dtprelhi, BFD_RELOC_ALPHA_DTPREL_HI16, 0, 0),
  DEF(dtprello, BFD_RELOC_ALPHA_DTPREL_LO16, 0, 0),
  DEF(dtprel, BFD_RELOC_ALPHA_DTPREL16, 0, 0),
  DEF(gottprel, BFD_RELOC_ALPHA_GOTTPREL16, 0, 0),
  DEF(tprelhi, BFD_RELOC_ALPHA_TPREL_HI16, 0, 0),
  DEF(tprello, BFD_RELOC_ALPHA_TPREL_LO16, 0, 0),
  DEF(tprel, BFD_RELOC_ALPHA_TPREL16, 0, 0),
a544 2
#undef DEF

a546 1
#endif /* RELOC_OP_P */
d551 3
d555 1
a555 1
struct alpha_reloc_tag
d557 1
a557 2
  fixS *master;			/* the literal reloc */
  fixS *slaves;			/* head of linked list of lituses */
d559 4
a562 8
  long sequence;		/* sequence # */
  unsigned n_master;		/* # of literals */
  unsigned n_slaves;		/* # of lituses */
  unsigned saw_tlsgd : 1;	/* true if ... */
  unsigned saw_tlsldm : 1;
  unsigned saw_lu_tlsgd : 1;
  unsigned saw_lu_tlsldm : 1;
  unsigned multi_section_p : 1;	/* true if more than one section was used */
d568 1
a568 3

/* Sequence numbers for internal use by macros.  */
static long next_sequence_num = -1;
d572 1
a572 2
static const struct cpu_type
{
d575 1
a575 3
}
cpu_types[] =
{
a590 4
  { "21264a", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },
  { "21264b", (AXP_OPCODE_BASE|AXP_OPCODE_EV6|AXP_OPCODE_BWX
	      |AXP_OPCODE_MAX|AXP_OPCODE_CIX) },
a598 2
  { "ev67", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },
  { "ev68", AXP_OPCODE_BASE|AXP_OPCODE_BWX|AXP_OPCODE_MAX|AXP_OPCODE_CIX },
d606 1
a606 2
static const struct alpha_macro alpha_macros[] =
{
d609 1
a609 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d614 1
a614 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d616 1
a616 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d618 1
a618 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d620 1
a620 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d622 1
a622 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d624 1
a624 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d626 1
a626 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d628 1
a628 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d630 1
a630 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d633 1
a633 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d635 1
a635 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d637 1
a637 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d639 1
a639 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d642 1
a642 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d644 1
a644 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d646 1
a646 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d648 1
a648 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d650 1
a650 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d675 1
a675 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d677 1
a677 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d679 1
a679 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d681 1
a681 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d683 1
a683 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d685 1
a685 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d687 1
a687 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d689 1
a689 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d691 1
a691 1
    { MACRO_FPR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d694 1
a694 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d696 1
a696 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d698 1
a698 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d700 1
a700 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d702 1
a702 1
    { MACRO_IR, MACRO_EXP, MACRO_OPIR, MACRO_EOA } },
d765 4
a768 4
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
d770 4
a773 4
    { MACRO_PIR, MACRO_EXP, MACRO_EOA,
      MACRO_PIR, MACRO_EOA,
      MACRO_IR,  MACRO_EXP, MACRO_EOA,
      MACRO_EXP, MACRO_EOA } },
d818 2
a819 1
  /* Create the opcode hash table.  */
d828 1
a828 2
	as_fatal (_("internal error: can't hash opcode `%s': %s"),
		  name, retval);
d852 2
a853 1
  /* Create the macro hash table.  */
d871 2
a872 1
  /* Construct symbols for each of the registers.  */
a875 1

a882 1

d888 1
a888 1
  /* Create the special symbols and sections we'll be using.  */
d915 3
d920 1
a920 2

  subseg_set (text_section, 0);
d929 1
a929 1
  char opname[32];			/* Current maximum is 13.  */
d934 1
a934 1
  /* Split off the opcode.  */
d942 1
a942 1
  /* Tokenize the rest of the line.  */
d951 1
a951 1
  /* Finish it off.  */
d973 1
a973 1
/* Equal to MAX_PRECISION in atof-ieee.c.  */
d1118 1
a1118 1
-mev4 | -mev45 | -mev5 | -mev56 | -mpca56 | -mev6 | -mev67 | -mev68 | -mall\n\
d1120 1
a1120 1
-m21064 | -m21066 | -m21164 | -m21164a | -m21164pc | -m21264 | -m21264a | -m21264b\n\
d1142 4
a1145 4
    case BFD_RELOC_23_PCREL_S2:
    case BFD_RELOC_ALPHA_HINT:
    case BFD_RELOC_ALPHA_BRSGP:
      return addr + 4;
d1147 1
a1147 1
      return addr;
d1161 2
a1162 2
void
md_apply_fix3 (fixP, valP, seg)
d1164 1
a1164 2
     valueT * valP;
     segT seg;
d1167 1
a1167 1
  valueT value = * valP;
d1173 3
a1175 3
	 referring to the current function's section;  we need to drop
	 in a value which, when added to the address of the start of
	 the function, gives the desired GP.  */
d1179 1
d1181 2
a1182 6
	/* With user-specified !gpdisp relocations, we can be missing
	   the matching LO16 reloc.  We will have already issued an
	   error message.  */
	if (next)
	  fixP->fx_offset = (next->fx_frag->fr_address + next->fx_where
			     - fixP->fx_frag->fr_address - fixP->fx_where);
d1199 1
a1199 1
      fixP->fx_addsy = section_symbol (seg);
d1223 1
a1223 1
      return;
d1232 2
a1233 1
#else
d1235 1
a1236 4
    case BFD_RELOC_GPREL16:
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
      return;
d1245 1
a1245 1
      return;
d1254 1
a1254 20
      return;

#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_BRSGP:
      return;

    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      if (fixP->fx_addsy)
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
      return;
#endif
d1259 4
a1262 1
      return;
d1264 1
d1267 3
d1272 15
a1286 1
      return;
d1290 1
a1290 1
      return;
d1320 1
a1320 1
    return;
d1333 1
d1336 3
a1338 1
/* Look for a register name in the given symbol.  */
d1357 1
a1357 1
	  if (!ISDIGIT (*++name))
d1365 1
a1365 1
	  else if (name[0] != '0' && ISDIGIT (name[1]) && name[2] == '\0')
d1426 1
a1426 1
   there is some hope of resolving it at assembly time.  */
d1440 1
d1442 2
d1445 1
a1446 1
    case BFD_RELOC_GPREL16:
d1448 1
a1448 2
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
d1451 12
a1462 11
    case BFD_RELOC_ALPHA_BRSGP:
    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
d1465 6
d1472 3
a1474 1
      break;
a1475 2

  return generic_force_reloc (f);
d1484 6
d1499 1
d1501 2
d1504 5
a1508 1
    case BFD_RELOC_ALPHA_LITUSE:
d1511 1
d1514 9
a1526 1
    case BFD_RELOC_GPREL16:
a1527 2
    case BFD_RELOC_ALPHA_GPREL_HI16:
    case BFD_RELOC_ALPHA_GPREL_LO16:
a1533 49
    case BFD_RELOC_ALPHA_TLSGD:
    case BFD_RELOC_ALPHA_TLSLDM:
    case BFD_RELOC_ALPHA_GOTDTPREL16:
    case BFD_RELOC_ALPHA_DTPREL_HI16:
    case BFD_RELOC_ALPHA_DTPREL_LO16:
    case BFD_RELOC_ALPHA_DTPREL16:
    case BFD_RELOC_ALPHA_GOTTPREL16:
    case BFD_RELOC_ALPHA_TPREL_HI16:
    case BFD_RELOC_ALPHA_TPREL_LO16:
    case BFD_RELOC_ALPHA_TPREL16:
      /* ??? No idea why we can't return a reference to .tbss+10, but
	 we're preventing this in the other assemblers.  Follow for now.  */
      return 0;

#ifdef OBJ_ELF
    case BFD_RELOC_ALPHA_BRSGP:
      /* If we have a BRSGP reloc to a local symbol, adjust it to BRADDR and
         let it get resolved at assembly time.  */
      {
	symbolS *sym = f->fx_addsy;
	const char *name;
	int offset = 0;

	if (generic_force_reloc (f))
	  return 0;

	switch (S_GET_OTHER (sym) & STO_ALPHA_STD_GPLOAD)
	  {
	  case STO_ALPHA_NOPV:
	    break;
	  case STO_ALPHA_STD_GPLOAD:
	    offset = 8;
	    break;
	  default:
	    if (S_IS_LOCAL (sym))
	      name = "<local>";
	    else
	      name = S_GET_NAME (sym);
	    as_bad_where (f->fx_file, f->fx_line,
		_("!samegp reloc against symbol without .prologue: %s"),
		name);
	    break;
	  }
	f->fx_r_type = BFD_RELOC_23_PCREL_S2;
	f->fx_offset += offset;
	return 1;
      }
#endif

d1535 2
d1580 1
a1580 1
      /* Fake out bfd_perform_relocation. sigh.  */
d1588 7
a1594 7
      /* Ohhh, this is ugly.  The problem is that if this is a local global
         symbol, the relocation will entirely be performed at link time, not
         at assembly time.  bfd_perform_reloc doesn't know about this sort
         of thing, and as a result we need to fake it out here.  */
      if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy)
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_MERGE)
	   || (S_GET_SEGMENT (fixp->fx_addsy)->flags & SEC_THREAD_LOCAL))
d1652 1
a1652 28
static struct alpha_reloc_tag *
get_alpha_reloc_tag (sequence)
     long sequence;
{
  char buffer[ALPHA_RELOC_DIGITS];
  struct alpha_reloc_tag *info;

  sprintf (buffer, "!%ld", sequence);

  info = (struct alpha_reloc_tag *) hash_find (alpha_literal_hash, buffer);
  if (! info)
    {
      size_t len = strlen (buffer);
      const char *errmsg;

      info = (struct alpha_reloc_tag *)
	xcalloc (sizeof (struct alpha_reloc_tag) + len, 1);

      info->segment = now_seg;
      info->sequence = sequence;
      strcpy (info->string, buffer);
      errmsg = hash_insert (alpha_literal_hash, info->string, (PTR) info);
      if (errmsg)
	as_fatal (errmsg);
    }

  return info;
}
d1656 2
a1657 1
   relocations, and similarly for !gpdisp relocations.  */
d1660 1
a1660 1
alpha_before_fix ()
d1663 11
a1673 1
    bfd_map_over_sections (stdoutput, alpha_adjust_relocs, NULL);
d1675 2
d1679 1
a1679 1
alpha_adjust_relocs (abfd, sec, ptr)
d1688 8
a1695 1
  fixS *slave;
d1707 2
a1708 3
  /* First rebuild the fixup chain without the expicit lituse and
     gpdisp_lo16 relocs.  */
  prevP = &seginfo->fix_root;
d1713 3
d1719 24
a1742 20
	case BFD_RELOC_ALPHA_LITUSE:
	  if (fixp->tc_fix_data.info->n_master == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No !literal!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
#ifdef RELOC_OP_P
	  if (fixp->fx_offset == LITUSE_ALPHA_TLSGD)
	    {
	      if (! fixp->tc_fix_data.info->saw_tlsgd)
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("No !tlsgd!%ld was found"),
			      fixp->tc_fix_data.info->sequence);
	    }
	  else if (fixp->fx_offset == LITUSE_ALPHA_TLSLDM)
	    {
	      if (! fixp->tc_fix_data.info->saw_tlsldm)
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("No !tlsldm!%ld was found"),
			      fixp->tc_fix_data.info->sequence);
	    }
d1746 6
a1751 2
	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  if (fixp->tc_fix_data.info->n_master == 0)
d1753 1
a1753 1
			  _("No ldah !gpdisp!%ld was found"),
d1755 8
a1762 12
	  break;

	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  if (fixp->tc_fix_data.info
	      && (fixp->tc_fix_data.info->saw_tlsgd
	          || fixp->tc_fix_data.info->saw_tlsldm))
	    break;
	  /* FALLTHRU */

	default:
	  *prevP = fixp;
	  prevP = &fixp->fx_next;
d1767 9
a1775 19
  /* Go back and re-chain dependent relocations.  They are currently
     linked through the next_reloc field in reverse order, so as we
     go through the next_reloc chain, we effectively reverse the chain
     once again.

     Except if there is more than one !literal for a given sequence
     number.  In that case, the programmer and/or compiler is not sure
     how control flows from literal to lituse, and we can't be sure to
     get the relaxation correct.

     ??? Well, actually we could, if there are enough lituses such that
     we can make each literal have at least one of each lituse type
     present.  Not implemented.

     Also suppress the optimization if the !literals/!lituses are spread
     in different segments.  This can happen with "intersting" uses of
     inline assembly; examples are present in the Linux kernel semaphores.  */

  for (fixp = seginfo->fix_root; fixp; fixp = next)
d1777 1
a1777 2
      next = fixp->fx_next;
      switch (fixp->fx_r_type)
d1779 1
a1779 7
	case BFD_RELOC_ALPHA_TLSGD:
	case BFD_RELOC_ALPHA_TLSLDM:
	  if (!fixp->tc_fix_data.info)
	    break;
	  if (fixp->tc_fix_data.info->n_master == 0)
	    break;
	  else if (fixp->tc_fix_data.info->n_master > 1)
d1781 1
a1781 5
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("too many !literal!%ld for %s"),
			    fixp->tc_fix_data.info->sequence,
			    (fixp->fx_r_type == BFD_RELOC_ALPHA_TLSGD
			     ? "!tlsgd" : "!tlsldm"));
a1782 1
	    }
d1784 8
a1791 13
	  fixp->tc_fix_data.info->master->fx_next = fixp->fx_next;
	  fixp->fx_next = fixp->tc_fix_data.info->master;
	  fixp = fixp->fx_next;
	  /* FALLTHRU */

	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  if (fixp->tc_fix_data.info
	      && fixp->tc_fix_data.info->n_master == 1
	      && ! fixp->tc_fix_data.info->multi_section_p)
	    {
	      for (slave = fixp->tc_fix_data.info->slaves;
		   slave != (fixS *) 0;
		   slave = slave->tc_fix_data.next_reloc)
d1793 7
a1799 2
		  slave->fx_next = fixp->fx_next;
		  fixp->fx_next = slave;
d1801 1
a1801 2
	    }
	  break;
d1803 5
a1807 10
	case BFD_RELOC_ALPHA_GPDISP_HI16:
	  if (fixp->tc_fix_data.info->n_slaves == 0)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("No lda !gpdisp!%ld was found"),
			  fixp->tc_fix_data.info->sequence);
	  else
	    {
	      slave = fixp->tc_fix_data.info->slaves;
	      slave->fx_next = next;
	      fixp->fx_next = slave;
a1808 4
	  break;

	default:
	  break;
d1811 8
d1820 2
a1835 1

a1871 1
	case O_lituse_addr:		name = "O_lituse_addr";		break;
a1874 2
	case O_lituse_tlsgd:		name = "O_lituse_tlsgd";	break;
	case O_lituse_tlsldm:		name = "O_lituse_tlsldm";	break;
d1878 7
a1884 12
	case O_gprel:			name = "O_gprel";		break;
	case O_samegp:			name = "O_samegp";		break;
	case O_tlsgd:			name = "O_tlsgd";		break;
	case O_tlsldm:			name = "O_tlsldm";		break;
	case O_gotdtprel:		name = "O_gotdtprel";		break;
	case O_dtprelhi:		name = "O_dtprelhi";		break;
	case O_dtprello:		name = "O_dtprello";		break;
	case O_dtprel:			name = "O_dtprel";		break;
	case O_gottprel:		name = "O_gottprel";		break;
	case O_tprelhi:			name = "O_tprelhi";		break;
	case O_tprello:			name = "O_tprello";		break;
	case O_tprel:			name = "O_tprel";		break;
d1921 1
a1921 1
  /* Save and restore input_line_pointer around this function.  */
a1924 5
#ifdef RELOC_OP_P
  /* ??? Wrest control of ! away from the regular expression parser.  */
  is_end_of_line[(unsigned char) '!'] = 1;
#endif

d1939 1
a1939 2
	    {
	      /* Only support one relocation op per insn.  */
d1947 5
a1951 4
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  p = input_line_pointer;
	  c = get_symbol_end ();
d1953 2
a1954 2
	  /* Parse !relocation_type.  */
	  len = input_line_pointer - p;
d1961 6
d1969 5
a1973 2
	    if (len == r->length && memcmp (p, r->name, len) == 0)
	      break;
d1976 2
a1977 1
	      as_bad (_("Unknown relocation operand: !%s"), p);
d1981 5
a1985 9
	  *input_line_pointer = c;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer != '!')
	    {
	      if (r->require_seq)
		{
		  as_bad (_("no sequence number after !%s"), p);
		  goto err_report;
		}
d1987 2
a1988 3
	      tok->X_add_number = 0;
	    }
	  else
d1990 3
a1992 16
	      if (! r->allow_seq)
		{
		  as_bad (_("!%s does not use a sequence number"), p);
		  goto err_report;
		}

	      input_line_pointer++;

	      /* Parse !sequence_number.  */
	      expression (tok);
	      if (tok->X_op != O_constant || tok->X_add_number <= 0)
		{
		  as_bad (_("Bad sequence number: !%s!%s"),
			  r->name, input_line_pointer);
		  goto err_report;
		}
d1999 1
a1999 1
#endif /* RELOC_OP_P */
d2024 1
a2024 1
	    /* ... then fall through to plain expression.  */
a2050 3
#ifdef RELOC_OP_P
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
a2054 3
#ifdef RELOC_OP_P
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
a2059 2
  is_end_of_line[(unsigned char) '!'] = 0;
#endif
d2062 1
d2084 1
a2084 1
      /* Don't match opcodes that don't exist on this architecture.  */
d2094 1
a2094 1
	  /* Only take input from real operands.  */
d2098 1
a2098 1
	  /* When we expect input, make sure we have it.  */
d2106 1
a2106 1
	  /* Match operand type with expression type.  */
d2148 1
a2148 1
	      /* Everything else should have been fake.  */
d2154 1
a2154 1
      /* Possible match -- did we use all of our input?  */
d2163 1
a2163 1
  while (++opcode - alpha_opcodes < (int) alpha_num_opcodes
d2200 1
a2200 1
	      /* Index register.  */
d2208 1
a2208 1
	      /* Parenthesized index register.  */
d2216 1
a2216 1
	      /* Optional parenthesized index register.  */
d2223 1
a2223 1
	      /* Leading comma with a parenthesized index register.  */
d2231 1
a2231 1
	      /* Floating point register.  */
d2239 1
a2239 1
	      /* Normal expression.  */
d2250 1
d2258 1
a2258 2
		case O_gprel:
		case O_samegp:
d2267 32
d2308 1
a2308 1
  while (++macro - alpha_macros < (int) alpha_num_macros
d2367 4
a2370 2
/* Turn an opcode description and a set of arguments into
   an instruction and a fixup.  */
d2373 1
a2373 1
assemble_insn (opcode, tok, ntok, insn, reloc)
a2377 1
     bfd_reloc_code_real_type reloc;
a2378 2
  const struct alpha_operand *reloc_operand = NULL;
  const expressionS *reloc_exp = NULL;
a2433 3
	  assert (reloc_operand == NULL);
	  reloc_operand = operand;
	  reloc_exp = t;
d2437 2
a2438 4
	  /* This is only 0 for fields that should contain registers,
	     which means this pattern shouldn't have matched.  */
	  if (operand->default_reloc == 0)
	    abort ();
d2440 2
a2441 6
	  /* There is one special case for which an insn receives two
	     relocations, and thus the user-supplied reloc does not
	     override the operand reloc.  */
	  if (operand->default_reloc == BFD_RELOC_ALPHA_HINT)
	    {
	      struct alpha_fixup *fixup;
d2443 1
a2443 2
	      if (insn->nfixups >= MAX_INSN_FIXUPS)
		as_fatal (_("too many fixups"));
d2445 3
a2447 13
	      fixup = &insn->fixups[insn->nfixups++];
	      fixup->exp = *t;
	      fixup->reloc = BFD_RELOC_ALPHA_HINT;
	    }
	  else
	    {
	      if (reloc == BFD_RELOC_UNUSED)
		reloc = operand->default_reloc;

	      assert (reloc_operand == NULL);
	      reloc_operand = operand;
	      reloc_exp = t;
	    }
a2451 41
  if (reloc != BFD_RELOC_UNUSED)
    {
      struct alpha_fixup *fixup;

      if (insn->nfixups >= MAX_INSN_FIXUPS)
	as_fatal (_("too many fixups"));

      /* ??? My but this is hacky.  But the OSF/1 assembler uses the same
	 relocation tag for both ldah and lda with gpdisp.  Choose the
	 correct internal relocation based on the opcode.  */
      if (reloc == BFD_RELOC_ALPHA_GPDISP)
	{
	  if (strcmp (opcode->name, "ldah") == 0)
	    reloc = BFD_RELOC_ALPHA_GPDISP_HI16;
	  else if (strcmp (opcode->name, "lda") == 0)
	    reloc = BFD_RELOC_ALPHA_GPDISP_LO16;
	  else
	    as_bad (_("invalid relocation for instruction"));
	}

      /* If this is a real relocation (as opposed to a lituse hint), then
	 the relocation width should match the operand width.  */
      else if (reloc < BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto
	    = bfd_reloc_type_lookup (stdoutput, reloc);
	  if (reloc_howto->bitsize != reloc_operand->bits)
	    {
	      as_bad (_("invalid relocation for field"));
	      return;
	    }
	}

      fixup = &insn->fixups[insn->nfixups++];
      if (reloc_exp)
	fixup->exp = *reloc_exp;
      else
	fixup->exp.X_op = O_absent;
      fixup->reloc = reloc;
    }

d2455 3
a2457 1
/* Actually output an instruction with its fixup.  */
d2481 1
a2481 1
  /* Apply the fixups in order.  */
a2485 1
      struct alpha_reloc_tag *info = NULL;
d2488 4
d2493 1
a2493 1
      /* Some fixups are only used internally and so have no howto.  */
a2499 7
      else if (fixup->reloc > BFD_RELOC_UNUSED
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_HI16
	       || fixup->reloc == BFD_RELOC_ALPHA_GPDISP_LO16)
	{
	  size = 2;
	  pcrel = 0;
	}
d2501 23
a2523 4
	{
	  reloc_howto_type *reloc_howto
	    = bfd_reloc_type_lookup (stdoutput, fixup->reloc);
	  assert (reloc_howto);
d2525 5
a2529 2
	  size = bfd_get_reloc_size (reloc_howto);
	  assert (size >= 1 && size <= 4);
d2531 6
a2536 2
	  pcrel = reloc_howto->pc_relative;
	}
d2545 7
a2551 1
	case BFD_RELOC_ALPHA_HINT:
a2552 11
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_ALPHA_GPREL_HI16:
	case BFD_RELOC_ALPHA_GPREL_LO16:
	case BFD_RELOC_ALPHA_GOTDTPREL16:
	case BFD_RELOC_ALPHA_DTPREL_HI16:
	case BFD_RELOC_ALPHA_DTPREL_LO16:
	case BFD_RELOC_ALPHA_DTPREL16:
	case BFD_RELOC_ALPHA_GOTTPREL16:
	case BFD_RELOC_ALPHA_TPREL_HI16:
	case BFD_RELOC_ALPHA_TPREL_LO16:
	case BFD_RELOC_ALPHA_TPREL16:
d2556 2
a2557 1
	case BFD_RELOC_ALPHA_GPDISP_HI16:
d2559 3
a2561 2
	  fixP->fx_addsy = section_symbol (now_seg);
	  fixP->fx_offset = 0;
d2563 4
a2566 8
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (++info->n_master > 1)
	    as_bad (_("too many ldah insns for !gpdisp!%ld"), insn->sequence);
	  if (info->segment != now_seg)
	    as_bad (_("both insns for !gpdisp!%ld must be in the same section"),
		    insn->sequence);
	  fixP->tc_fix_data.info = info;
	  break;
d2568 2
a2569 2
	case BFD_RELOC_ALPHA_GPDISP_LO16:
	  fixP->fx_no_overflow = 1;
d2571 7
a2577 9
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (++info->n_slaves > 1)
	    as_bad (_("too many lda insns for !gpdisp!%ld"), insn->sequence);
	  if (info->segment != now_seg)
	    as_bad (_("both insns for !gpdisp!%ld must be in the same section"),
		    insn->sequence);
	  fixP->tc_fix_data.info = info;
	  info->slaves = fixP;
	  break;
d2579 1
a2579 3
	case BFD_RELOC_ALPHA_LITERAL:
	case BFD_RELOC_ALPHA_ELF_LITERAL:
	  fixP->fx_no_overflow = 1;
a2580 5
	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  info->master = fixP;
	  info->n_master++;
d2583 1
d2587 8
a2594 29
#ifdef RELOC_OP_P
	case DUMMY_RELOC_LITUSE_ADDR:
	  fixP->fx_offset = LITUSE_ALPHA_ADDR;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_BASE:
	  fixP->fx_offset = LITUSE_ALPHA_BASE;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_BYTOFF:
	  fixP->fx_offset = LITUSE_ALPHA_BYTOFF;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_JSR:
	  fixP->fx_offset = LITUSE_ALPHA_JSR;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_TLSGD:
	  fixP->fx_offset = LITUSE_ALPHA_TLSGD;
	  goto do_lituse;
	case DUMMY_RELOC_LITUSE_TLSLDM:
	  fixP->fx_offset = LITUSE_ALPHA_TLSLDM;
	  goto do_lituse;
	do_lituse:
	  fixP->fx_addsy = section_symbol (now_seg);
	  fixP->fx_r_type = BFD_RELOC_ALPHA_LITUSE;

	  info = get_alpha_reloc_tag (insn->sequence);
	  if (fixup->reloc == DUMMY_RELOC_LITUSE_TLSGD)
	    info->saw_lu_tlsgd = 1;
	  else if (fixup->reloc == DUMMY_RELOC_LITUSE_TLSLDM)
	    info->saw_lu_tlsldm = 1;
	  if (++info->n_slaves > 1)
d2596 12
a2607 6
	      if (info->saw_lu_tlsgd)
		as_bad (_("too many lituse insns for !lituse_tlsgd!%ld"),
		        insn->sequence);
	      else if (info->saw_lu_tlsldm)
		as_bad (_("too many lituse insns for !lituse_tlsldm!%ld"),
		        insn->sequence);
d2609 1
d2611 2
a2612 2
	  fixP->tc_fix_data.next_reloc = info->slaves;
	  info->slaves = fixP;
a2614 4
	  break;

	case BFD_RELOC_ALPHA_TLSGD:
	  fixP->fx_no_overflow = 1;
a2615 11
	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (info->saw_tlsgd)
	    as_bad (_("duplicate !tlsgd!%ld"), insn->sequence);
	  else if (info->saw_tlsldm)
	    as_bad (_("sequence number in use for !tlsldm!%ld"),
		    insn->sequence);
	  else
	    info->saw_tlsgd = 1;
	  fixP->tc_fix_data.info = info;
d2617 1
a2618 16
	case BFD_RELOC_ALPHA_TLSLDM:
	  fixP->fx_no_overflow = 1;

	  if (insn->sequence == 0)
	    break;
	  info = get_alpha_reloc_tag (insn->sequence);
	  if (info->saw_tlsldm)
	    as_bad (_("duplicate !tlsldm!%ld"), insn->sequence);
	  else if (info->saw_tlsgd)
	    as_bad (_("sequence number in use for !tlsgd!%ld"),
		    insn->sequence);
	  else
	    info->saw_tlsldm = 1;
	  fixP->tc_fix_data.info = info;
	  break;
#endif
d2653 1
a2653 1
	  assemble_insn (opcode, tok, ntok, insn, BFD_RELOC_UNUSED);
a2679 1
  bfd_reloc_code_real_type reloc = BFD_RELOC_UNUSED;
d2681 1
a2681 9
#ifdef RELOC_OP_P
  /* If a user-specified relocation is present, this is not a macro.  */
  if (ntok && USER_RELOC_P (tok[ntok - 1].X_op))
    {
      reloc = ALPHA_RELOC_TABLE (tok[ntok - 1].X_op)->reloc;
      ntok--;
    }
  else
#endif
d2698 12
a2709 1
  /* Search opcodes.  */
d2718 1
a2718 6
	  assemble_insn (opcode, tok, ntok, &insn, reloc);

	  /* Copy the sequence number for the reloc from the reloc token.  */
	  if (reloc != BFD_RELOC_UNUSED)
	    insn.sequence = tok[ntok].X_add_number;

d2725 5
a2729 7
    {
      if (cpumatch)
	as_bad (_("inappropriate arguments for opcode `%s'"), opname);
      else
	as_bad (_("opcode `%s' not supported for target %s"), opname,
		alpha_target_name);
    }
d2734 1
a2734 1
/* Some instruction sets indexed by lg(size).  */
d2743 1
d2764 11
a2797 1
  insn.sequence = next_sequence_num;
a2811 1
  insn.sequence = next_sequence_num--;
d2891 2
a2892 3
   Finally, the return value is nonzero if the calling macro may emit
   a LITUSE reloc if otherwise appropriate; the return value is the
   sequence number to use.  */
d2894 2
a2895 2
static long
load_expression (targreg, exp, pbasereg, poffset)
d2900 1
d2902 1
a2902 1
  long emit_lituse = 0;
d2915 1
a2915 1
	/* Attempt to reduce .lit load by splitting the offset from
d2952 1
a2954 1
	insn.sequence = emit_lituse = next_sequence_num--;
d2991 12
a3002 2
	insn.fixups[0].reloc = BFD_RELOC_ALPHA_ELF_LITERAL;
	insn.sequence = emit_lituse = next_sequence_num--;
d3009 1
d3051 2
d3068 1
d3075 1
a3101 1
      long seq_num = next_sequence_num--;
d3103 1
a3103 1
      /* For 64-bit addends, just put it in the literal pool.  */
a3162 1
      insn.sequence = seq_num;
d3174 5
a3178 2
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
d3180 4
a3183 1
      insn.sequence = seq_num;
d3263 1
a3263 1
emit_lda (tok, ntok, unused)
d3266 1
a3266 1
     const PTR unused ATTRIBUTE_UNUSED;
d3269 47
d3322 1
a3322 1
  (void) load_expression (tok[0].X_add_number, &tok[1], &basereg, NULL);
d3336 11
d3364 1
a3364 2
  int basereg;
  long lituse;
d3368 31
d3405 1
a3405 1
			    &newtok[1]);
d3412 16
d3431 5
a3435 2
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
d3437 4
a3440 1
      insn.sequence = lituse;
d3455 1
a3455 2
  int basereg;
  long lituse;
d3459 15
d3484 2
a3485 1
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, &newtok[1]);
d3498 16
d3517 5
a3521 2
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
d3523 4
a3526 1
      insn.sequence = lituse;
d3545 13
a3557 3
      struct alpha_insn insn;
      int basereg;
      long lituse;
a3561 6
      if (ntok == 2)
	basereg = (tok[1].X_op == O_constant
		   ? AXP_REG_ZERO : alpha_gp_register);
      else
	basereg = tok[2].X_add_number;

d3564 3
a3566 1
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL);
d3572 2
a3573 13
      set_tok_preg (newtok[2], basereg);
      assemble_tokens_to_insn ("ldq_u", newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
d3577 1
a3577 1
      set_tok_reg (newtok[1], basereg);
d3579 1
a3579 12
      assemble_tokens_to_insn (extXl_op[(long) vlgsize], newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
d3674 11
a3705 3
      struct alpha_insn insn;
      int basereg;
      long lituse;
a3709 6
      if (ntok == 2)
	basereg = (tok[1].X_op == O_constant
		   ? AXP_REG_ZERO : alpha_gp_register);
      else
	basereg = tok[2].X_add_number;

d3712 3
a3714 1
      lituse = load_expression (AXP_REG_AT, &tok[1], &basereg, NULL);
d3720 2
a3721 13
      set_tok_preg (newtok[2], basereg);
      assemble_tokens_to_insn ("ldq_u", newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
d3726 1
a3726 1
      set_tok_reg (newtok[1], basereg);
d3728 1
a3728 12
      assemble_tokens_to_insn (insXl_op[lgsize], newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
d3734 1
a3734 12
      assemble_tokens_to_insn (mskXl_op[lgsize], newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BYTOFF;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
d3743 1
a3743 1
      set_tok_const(newtok[1], 0);
d3745 1
a3745 12
      assemble_tokens_to_insn ("stq_u", newtok, 3, &insn);

      if (lituse)
	{
	  assert (insn.nfixups < MAX_INSN_FIXUPS);
	  insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_BASE;
	  insn.fixups[insn.nfixups].exp.X_op = O_absent;
	  insn.nfixups++;
	  insn.sequence = lituse;
	}

      emit_insn (&insn);
d3849 13
d3890 13
a3902 12
   
     Convert
        OP x,y,result
     to
        mov x,R16	# if x != R16
        mov y,R17	# if y != R17
        lda AT,__OP
        jsr AT,(AT),0
        mov R0,result
    
     with appropriate optimizations if R0,R16,R17 are the registers
     specified by the compiler.  */
d3908 11
d3927 1
a3927 1
  /* Move the operands into the right place.  */
d3930 1
a3930 1
      /* They are in exactly the wrong order -- swap through AT.  */
d3977 1
a3977 1
  /* Call the division routine.  */
d3983 1
a3983 1
  /* Move the result to the right place.  */
d4001 12
a4012 11
     Convert
        OP x,y,result
     to
        lda pv,__OP
        mov x,t10
        mov y,t11
        jsr t9,(pv),__OP
        mov t12,result
    
     with appropriate optimizations if t10,t11,t12 are the registers
     specified by the compiler.  */
d4018 11
d4039 1
a4039 1
  /* Move the operands into the right place.  */
d4042 2
a4043 1
      /* They are in exactly the wrong order -- swap through AT.  */
d4083 1
a4083 1
  /* Call the division routine.  */
d4088 1
a4088 1
  /* Reload the GP register.  */
d4099 1
a4099 1
  /* Move the result to the right place.  */
d4123 12
a4134 2
  int r, tokidx = 0;
  long lituse = 0;
d4152 2
a4153 1
      lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL);
d4170 1
d4174 5
a4178 2
      insn.fixups[insn.nfixups].reloc = DUMMY_RELOC_LITUSE_JSR;
      insn.fixups[insn.nfixups].exp.X_op = O_absent;
d4180 4
a4183 1
      insn.sequence = lituse;
d4202 11
d4236 1
a4236 1
/* Assembler directives.  */
a4245 3
#ifdef OBJ_ELF
  obj_elf_text (i);
#else
a4246 1
#endif
a4258 3
#ifdef OBJ_ELF
  obj_elf_data (i);
#else
a4259 1
#endif
d4272 1
a4272 1
     int ignore ATTRIBUTE_UNUSED;
d4388 1
a4388 1
     int ignore ATTRIBUTE_UNUSED;
d4409 1
a4409 1
     int ignore ATTRIBUTE_UNUSED;
d4429 1
a4429 1
     int ignore ATTRIBUTE_UNUSED;
d4475 1
a4475 1
	  if (ISDIGIT (*input_line_pointer) || *input_line_pointer == '-')
d4566 1
a4566 6

  if (sym == NULL)
    {
      as_bad (_(".prologue directive without a preceding .ent directive"));
      return;
    }
d4711 1
a4711 1
     int ignore ATTRIBUTE_UNUSED;
d4748 1
a4748 1
     int ignore ATTRIBUTE_UNUSED;
d4782 1
a4782 1
     int ignore ATTRIBUTE_UNUSED;
d4935 1
a4935 1
     int ignore ATTRIBUTE_UNUSED;
d4973 1
a4973 1
     int ignore ATTRIBUTE_UNUSED;
d5001 1
a5001 1
     int ignore ATTRIBUTE_UNUSED;
d5029 1
a5029 1
     int ignore ATTRIBUTE_UNUSED;
d5040 1
a5040 1
     int ignore ATTRIBUTE_UNUSED;
d5061 1
a5061 1
     int ignore ATTRIBUTE_UNUSED;
d5082 1
a5082 1
     int ignore ATTRIBUTE_UNUSED;
d5096 1
a5096 1
     int ignore ATTRIBUTE_UNUSED;
a5615 1
static inline void maybe_set_gp PARAMS ((asection *));
a5659 28
#ifdef OBJ_ELF
/* Map 's' to SHF_ALPHA_GPREL.  */

int
alpha_elf_section_letter (letter, ptr_msg)
     int letter;
     char **ptr_msg;
{
  if (letter == 's')
    return SHF_ALPHA_GPREL;

  *ptr_msg = _("Bad .section directive: want a,s,w,x,M,S,G,T in string");
  return 0;
}

/* Map SHF_ALPHA_GPREL to SEC_SMALL_DATA.  */

flagword
alpha_elf_section_flags (flags, attr, type)
     flagword flags;
     int attr, type ATTRIBUTE_UNUSED;
{
  if (attr & SHF_ALPHA_GPREL)
    flags |= SEC_SMALL_DATA;
  return flags;
}
#endif /* OBJ_ELF */

d5706 1
a5706 1
  static char const unop[4] = { 0x00, 0x00, 0xfe, 0x2f };
d5709 1
a5709 1
    0x00, 0x00, 0xfe, 0x2f
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@a62 1
#include "dw2gencfi.h"
a268 1
static void s_alpha_usepv PARAMS ((int));
d410 5
d539 1
a539 1
/* Structure to hold explicit sequence information.  */
d1733 1
a1733 1
  /* First rebuild the fixup chain without the explicit lituse and
d3020 1
a3020 1
   and used, then explicit_reloc with be an expression pointer.
d3371 1
a3371 1
   most simple expressions, particularly symbol address loads and
a4384 19
struct alpha_elf_frame_data
{
  symbolS *func_sym;
  symbolS *func_end_sym;
  symbolS *prologue_sym;
  unsigned int mask;
  unsigned int fmask;
  int fp_regno;
  int ra_regno;
  offsetT frame_size;
  offsetT mask_offset;
  offsetT fmask_offset;

  struct alpha_elf_frame_data *next;
};

static struct alpha_elf_frame_data *all_frame_data;
static struct alpha_elf_frame_data **plast_frame_data = &all_frame_data;
static struct alpha_elf_frame_data *cur_frame_data;
d4421 1
a4421 1
	  if (cur_frame_data)
d4426 1
a4426 10

	  cur_frame_data = calloc (1, sizeof (*cur_frame_data));
	  cur_frame_data->func_sym = sym;

	  /* Provide sensible defaults.  */
	  cur_frame_data->fp_regno = 30;	/* sp */
	  cur_frame_data->ra_regno = 26;	/* ra */

	  *plast_frame_data = cur_frame_data;
	  plast_frame_data = &cur_frame_data->next;
d4466 1
a4466 3
	  if (!cur_frame_data)
	    as_warn (_(".end directive without matching .ent"));
	  else if (sym != cur_frame_data->func_sym)
d4470 1
a4470 1
	  if (sym && cur_frame_data)
d4472 7
a4478 10
	      OBJ_SYMFIELD_TYPE *obj = symbol_get_obj (sym);
	      expressionS *exp = xmalloc (sizeof (expressionS));

	      obj->size = exp;
	      exp->X_op = O_subtract;
	      exp->X_add_symbol = symbol_temp_new_now ();
	      exp->X_op_symbol = sym;
	      exp->X_add_number = 0;

	      cur_frame_data->func_end_sym = exp->X_add_symbol;
d4481 1
a4481 1
	  cur_frame_data = NULL;
d4501 1
a4501 39
    {
      long val;
      offsetT offset;

      if (!cur_frame_data)
	{
	  if (fp)
	    as_warn (_(".fmask outside of .ent"));
	  else
	    as_warn (_(".mask outside of .ent"));
	  discard_rest_of_line ();
	  return;
	}

      if (get_absolute_expression_and_terminator (&val) != ',')
	{
	  if (fp)
	    as_warn (_("bad .fmask directive"));
	  else
	    as_warn (_("bad .mask directive"));
	  --input_line_pointer;
	  discard_rest_of_line ();
	  return;
	}

      offset = get_absolute_expression ();
      demand_empty_rest_of_line ();

      if (fp)
	{
	  cur_frame_data->fmask = val;
          cur_frame_data->fmask_offset = offset;
	}
      else
	{
	  cur_frame_data->mask = val;
	  cur_frame_data->mask_offset = offset;
	}
    }
d4511 1
a4511 30
    {
      long val;

      if (!cur_frame_data)
	{
	  as_warn (_(".frame outside of .ent"));
	  discard_rest_of_line ();
	  return;
	}

      cur_frame_data->fp_regno = tc_get_register (1);

      SKIP_WHITESPACE ();
      if (*input_line_pointer++ != ','
	  || get_absolute_expression_and_terminator (&val) != ',')
	{
	  as_warn (_("bad .frame directive"));
	  --input_line_pointer;
	  discard_rest_of_line ();
	  return;
	}
      cur_frame_data->frame_size = val;

      cur_frame_data->ra_regno = tc_get_register (0);

      /* Next comes the "offset of saved $a0 from $sp".  In gcc terms
	 this is current_function_pretend_args_size.  There's no place
	 to put this value, so ignore it.  */
      s_ignore (42);
    }
d4527 1
a4527 1
    sym = cur_frame_data ? cur_frame_data->func_sym : NULL;
a4551 3

  if (cur_frame_data)
    cur_frame_data->prologue_sym = symbol_temp_new_now ();
a4644 130

/* Called at the end of assembly.  Here we emit unwind info for frames
   unless the compiler has done it for us.  */

void
alpha_elf_md_end (void)
{
  struct alpha_elf_frame_data *p;

  if (cur_frame_data)
    as_warn (_(".ent directive without matching .end"));

  /* If someone has generated the unwind info themselves, great.  */
  if (bfd_get_section_by_name (stdoutput, ".eh_frame") != NULL)
    return;

  /* Generate .eh_frame data for the unwind directives specified.  */
  for (p = all_frame_data; p ; p = p->next)
    if (p->prologue_sym)
      {
	/* Create a temporary symbol at the same location as our
	   function symbol.  This prevents problems with globals.  */
	cfi_new_fde (symbol_temp_new (S_GET_SEGMENT (p->func_sym),
				      S_GET_VALUE (p->func_sym),
				      symbol_get_frag (p->func_sym)));

	cfi_set_return_column (p->ra_regno);
	cfi_add_CFA_def_cfa_register (30);
	if (p->fp_regno != 30 || p->mask || p->fmask || p->frame_size)
	  {
	    unsigned int mask;
	    offsetT offset;

	    cfi_add_advance_loc (p->prologue_sym);

	    if (p->fp_regno != 30)
	      if (p->frame_size != 0)
		cfi_add_CFA_def_cfa (p->fp_regno, p->frame_size);
	      else
		cfi_add_CFA_def_cfa_register (p->fp_regno);
	    else if (p->frame_size != 0)
	      cfi_add_CFA_def_cfa_offset (p->frame_size);

	    mask = p->mask;
	    offset = p->mask_offset;

	    /* Recall that $26 is special-cased and stored first.  */
	    if ((mask >> 26) & 1)
	      {
	        cfi_add_CFA_offset (26, offset);
		offset += 8;
		mask &= ~(1 << 26);
	      }
	    while (mask)
	      {
		unsigned int i;
		i = mask & -mask;
		mask ^= i;
		i = ffs (i) - 1;

		cfi_add_CFA_offset (i, offset);
		offset += 8;
	      }

	    mask = p->fmask;
	    offset = p->fmask_offset;
	    while (mask)
	      {
		unsigned int i;
		i = mask & -mask;
		mask ^= i;
		i = ffs (i) - 1;

		cfi_add_CFA_offset (i + 32, offset);
		offset += 8;
	      }
	  }

	cfi_end_fde (p->func_end_sym);
      }
}

static void
s_alpha_usepv (int unused ATTRIBUTE_UNUSED)
{
  char *name, name_end;
  char *which, which_end;
  symbolS *sym;
  int other;

  name = input_line_pointer;
  name_end = get_symbol_end ();

  if (! is_name_beginner (*name))
    {
      as_bad (_(".usepv directive has no name"));
      *input_line_pointer = name_end;
      ignore_rest_of_line ();
      return;
    }

  sym = symbol_find_or_make (name);
  *input_line_pointer++ = name_end;

  if (name_end != ',')
    {
      as_bad (_(".usepv directive has no type"));
      ignore_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();
  which = input_line_pointer;
  which_end = get_symbol_end ();

  if (strcmp (which, "no") == 0)
    other = STO_ALPHA_NOPV;
  else if (strcmp (which, "std") == 0)
    other = STO_ALPHA_STD_GPLOAD;
  else
    {
      as_bad (_("unknown argument for .usepv"));
      other = 0;
    }
  
  *input_line_pointer = which_end;
  demand_empty_rest_of_line ();

  S_SET_OTHER (sym, other | (S_GET_OTHER (sym) & ~STO_ALPHA_STD_GPLOAD));
}
a4646 8
/* Standard calling conventions leaves the CFA at $30 on entry.  */

void
alpha_cfi_frame_initial_instructions ()
{
  cfi_add_CFA_def_cfa_register (30);
}

d4708 1
d4743 2
d4894 2
d4934 2
d4962 2
d4990 2
d5002 1
d5022 2
d5043 2
d5057 2
d5069 2
d5081 2
d5442 1
a5493 1
  {"usepv", s_alpha_usepv, 0},
d5640 1
a5640 1
  return -1;
@


