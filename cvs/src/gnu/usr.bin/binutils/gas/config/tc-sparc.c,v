head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.40
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.36
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.32
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.34
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.26
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.30
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.28
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.24
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.22
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.20
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.18
	OPENBSD_5_0:1.9.0.16
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.14
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.12
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.8
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2007.12.24.17.14.40;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.02.20.45.30;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.31;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.37;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.53;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.52;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.06.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.13;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.13;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.51;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.45.16;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.35;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.23.24;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.31;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.37.05;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.33;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Teach as(1) about %gl on sparc64.

ok miod@@
@
text
@/* tc-sparc.c -- Assemble for the SPARC
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with GAS; see the file COPYING.  If not, write
   to the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <stdio.h>

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"

#include "opcode/sparc.h"
#include "dw2gencfi.h"

#ifdef OBJ_ELF
#include "elf/sparc.h"
#include "dwarf2dbg.h"
#endif

/* Some ancient Sun C compilers would not take such hex constants as
   unsigned, and would end up sign-extending them to form an offsetT,
   so use these constants instead.  */
#define U0xffffffff ((((unsigned long) 1 << 16) << 16) - 1)
#define U0x80000000 ((((unsigned long) 1 << 16) << 15))

static struct sparc_arch *lookup_arch PARAMS ((char *));
static void init_default_arch PARAMS ((void));
static int sparc_ip PARAMS ((char *, const struct sparc_opcode **));
static int in_signed_range PARAMS ((bfd_signed_vma, bfd_signed_vma));
static int in_unsigned_range PARAMS ((bfd_vma, bfd_vma));
static int in_bitfield_range PARAMS ((bfd_signed_vma, bfd_signed_vma));
static int sparc_ffs PARAMS ((unsigned int));
static void synthetize_setuw PARAMS ((const struct sparc_opcode *));
static void synthetize_setsw PARAMS ((const struct sparc_opcode *));
static void synthetize_setx PARAMS ((const struct sparc_opcode *));
static bfd_vma BSR PARAMS ((bfd_vma, int));
static int cmp_reg_entry PARAMS ((const PTR, const PTR));
static int parse_keyword_arg PARAMS ((int (*) (const char *), char **, int *));
static int parse_const_expr_arg PARAMS ((char **, int *));
static int get_expression PARAMS ((char *str));

/* Default architecture.  */
/* ??? The default value should be V8, but sparclite support was added
   by making it the default.  GCC now passes -Asparclite, so maybe sometime in
   the future we can set this to V8.  */
#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "sparclite"
#endif
static char *default_arch = DEFAULT_ARCH;

/* Non-zero if the initial values of `max_architecture' and `sparc_arch_size'
   have been set.  */
static int default_init_p;

/* Current architecture.  We don't bump up unless necessary.  */
static enum sparc_opcode_arch_val current_architecture = SPARC_OPCODE_ARCH_V6;

/* The maximum architecture level we can bump up to.
   In a 32 bit environment, don't allow bumping up to v9 by default.
   The native assembler works this way.  The user is required to pass
   an explicit argument before we'll create v9 object files.  However, if
   we don't see any v9 insns, a v8plus object file is not created.  */
static enum sparc_opcode_arch_val max_architecture;

/* Either 32 or 64, selects file format.  */
static int sparc_arch_size;
/* Initial (default) value, recorded separately in case a user option
   changes the value before md_show_usage is called.  */
static int default_arch_size;

#ifdef OBJ_ELF
/* The currently selected v9 memory model.  Currently only used for
   ELF.  */
static enum { MM_TSO, MM_PSO, MM_RMO } sparc_memory_model = MM_RMO;
#endif

static int architecture_requested;
static int warn_on_bump;

/* If warn_on_bump and the needed architecture is higher than this
   architecture, issue a warning.  */
static enum sparc_opcode_arch_val warn_after_architecture;

/* Non-zero if as should generate error if an undeclared g[23] register
   has been used in -64.  */
static int no_undeclared_regs;

/* Non-zero if we should try to relax jumps and calls.  */
static int sparc_relax;

/* Non-zero if we are generating PIC code.  */
int sparc_pic_code;

/* Non-zero if we should give an error when misaligned data is seen.  */
static int enforce_aligned_data;

extern int target_big_endian;

static int target_little_endian_data;

/* Symbols for global registers on v9.  */
static symbolS *globals[8];

/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
int sparc_cie_data_alignment;

/* V9 and 86x have big and little endian data, but instructions are always big
   endian.  The sparclet has bi-endian support but both data and insns have
   the same endianness.  Global `target_big_endian' is used for data.
   The following macro is used for instructions.  */
#ifndef INSN_BIG_ENDIAN
#define INSN_BIG_ENDIAN (target_big_endian \
			 || default_arch_type == sparc86x \
			 || SPARC_OPCODE_ARCH_V9_P (max_architecture))
#endif

/* Handle of the OPCODE hash table.  */
static struct hash_control *op_hash;

static int log2 PARAMS ((int));
static void s_data1 PARAMS ((void));
static void s_seg PARAMS ((int));
static void s_proc PARAMS ((int));
static void s_reserve PARAMS ((int));
static void s_common PARAMS ((int));
static void s_empty PARAMS ((int));
static void s_uacons PARAMS ((int));
static void s_ncons PARAMS ((int));
#ifdef OBJ_ELF
static void s_register PARAMS ((int));
#endif

const pseudo_typeS md_pseudo_table[] =
{
  {"align", s_align_bytes, 0},	/* Defaulting is invalid (0).  */
  {"common", s_common, 0},
  {"empty", s_empty, 0},
  {"global", s_globl, 0},
  {"half", cons, 2},
  {"nword", s_ncons, 0},
  {"optim", s_ignore, 0},
  {"proc", s_proc, 0},
  {"reserve", s_reserve, 0},
  {"seg", s_seg, 0},
  {"skip", s_space, 0},
  {"word", cons, 4},
  {"xword", cons, 8},
  {"uahalf", s_uacons, 2},
  {"uaword", s_uacons, 4},
  {"uaxword", s_uacons, 8},
#ifdef OBJ_ELF
  /* These are specific to sparc/svr4.  */
  {"2byte", s_uacons, 2},
  {"4byte", s_uacons, 4},
  {"8byte", s_uacons, 8},
  {"register", s_register, 0},
#endif
  {NULL, 0, 0},
};

/* Size of relocation record.  */
const int md_reloc_size = 12;

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "!";	/* JF removed '|' from
                                           comment_chars.  */

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.  */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments started like this one will always
   work if '/' isn't otherwise defined.  */
const char line_comment_chars[] = "#";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point
   nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c.  Ideally it shouldn't have to know about it at all,
   but nothing is ideal around here.  */

#define isoctal(c)  ((unsigned) ((c) - '0') < '8')

struct sparc_it
  {
    char *error;
    unsigned long opcode;
    struct nlist *nlistp;
    expressionS exp;
    expressionS exp2;
    int pcrel;
    bfd_reloc_code_real_type reloc;
  };

struct sparc_it the_insn, set_insn;

static void output_insn
  PARAMS ((const struct sparc_opcode *, struct sparc_it *));

/* Table of arguments to -A.
   The sparc_opcode_arch table in sparc-opc.c is insufficient and incorrect
   for this use.  That table is for opcodes only.  This table is for opcodes
   and file formats.  */

enum sparc_arch_types {v6, v7, v8, sparclet, sparclite, sparc86x, v8plus,
		       v8plusa, v9, v9a, v9b, v9_64};

static struct sparc_arch {
  char *name;
  char *opcode_arch;
  enum sparc_arch_types arch_type;
  /* Default word size, as specified during configuration.
     A value of zero means can't be used to specify default architecture.  */
  int default_arch_size;
  /* Allowable arg to -A?  */
  int user_option_p;
} sparc_arch_table[] = {
  { "v6", "v6", v6, 0, 1 },
  { "v7", "v7", v7, 0, 1 },
  { "v8", "v8", v8, 32, 1 },
  { "sparclet", "sparclet", sparclet, 32, 1 },
  { "sparclite", "sparclite", sparclite, 32, 1 },
  { "sparc86x", "sparclite", sparc86x, 32, 1 },
  { "v8plus", "v9", v9, 0, 1 },
  { "v8plusa", "v9a", v9, 0, 1 },
  { "v8plusb", "v9b", v9, 0, 1 },
  { "v9", "v9", v9, 0, 1 },
  { "v9a", "v9a", v9, 0, 1 },
  { "v9b", "v9b", v9, 0, 1 },
  /* This exists to allow configure.in/Makefile.in to pass one
     value to specify both the default machine and default word size.  */
  { "v9-64", "v9", v9, 64, 0 },
  { NULL, NULL, v8, 0, 0 }
};

/* Variant of default_arch */
static enum sparc_arch_types default_arch_type;

static struct sparc_arch *
lookup_arch (name)
     char *name;
{
  struct sparc_arch *sa;

  for (sa = &sparc_arch_table[0]; sa->name != NULL; sa++)
    if (strcmp (sa->name, name) == 0)
      break;
  if (sa->name == NULL)
    return NULL;
  return sa;
}

/* Initialize the default opcode arch and word size from the default
   architecture name.  */

static void
init_default_arch ()
{
  struct sparc_arch *sa = lookup_arch (default_arch);

  if (sa == NULL
      || sa->default_arch_size == 0)
    as_fatal (_("Invalid default architecture, broken assembler."));

  max_architecture = sparc_opcode_lookup_arch (sa->opcode_arch);
  if (max_architecture == SPARC_OPCODE_ARCH_BAD)
    as_fatal (_("Bad opcode table, broken assembler."));
  default_arch_size = sparc_arch_size = sa->default_arch_size;
  default_init_p = 1;
  default_arch_type = sa->arch_type;
}

/* Called by TARGET_FORMAT.  */

const char *
sparc_target_format ()
{
  /* We don't get a chance to initialize anything before we're called,
     so handle that now.  */
  if (! default_init_p)
    init_default_arch ();

#ifdef OBJ_AOUT
#if defined(TE_NetBSD) || defined(TE_OpenBSD)
  return "a.out-sparc-netbsd";
#else
#ifdef TE_SPARCAOUT
  if (target_big_endian)
    return "a.out-sunos-big";
  else if (default_arch_type == sparc86x && target_little_endian_data)
    return "a.out-sunos-big";
  else
    return "a.out-sparc-little";
#else
  return "a.out-sunos-big";
#endif
#endif
#endif

#ifdef OBJ_BOUT
  return "b.out.big";
#endif

#ifdef OBJ_COFF
#ifdef TE_LYNX
  return "coff-sparc-lynx";
#else
  return "coff-sparc";
#endif
#endif

#ifdef OBJ_ELF
  return sparc_arch_size == 64 ? "elf64-sparc" : "elf32-sparc";
#endif

  abort ();
}

/* md_parse_option
 *	Invocation line includes a switch not recognized by the base assembler.
 *	See if it's a processor-specific option.  These are:
 *
 *	-bump
 *		Warn on architecture bumps.  See also -A.
 *
 *	-Av6, -Av7, -Av8, -Asparclite, -Asparclet
 *		Standard 32 bit architectures.
 *	-Av9, -Av9a, -Av9b
 *		Sparc64 in either a 32 or 64 bit world (-32/-64 says which).
 *		This used to only mean 64 bits, but properly specifying it
 *		complicated gcc's ASM_SPECs, so now opcode selection is
 *		specified orthogonally to word size (except when specifying
 *		the default, but that is an internal implementation detail).
 *	-Av8plus, -Av8plusa, -Av8plusb
 *		Same as -Av9{,a,b}.
 *	-xarch=v8plus, -xarch=v8plusa, -xarch=v8plusb
 *		Same as -Av8plus{,a,b} -32, for compatibility with Sun's
 *		assembler.
 *	-xarch=v9, -xarch=v9a, -xarch=v9b
 *		Same as -Av9{,a,b} -64, for compatibility with Sun's
 *		assembler.
 *
 *		Select the architecture and possibly the file format.
 *		Instructions or features not supported by the selected
 *		architecture cause fatal errors.
 *
 *		The default is to start at v6, and bump the architecture up
 *		whenever an instruction is seen at a higher level.  In 32 bit
 *		environments, v9 is not bumped up to, the user must pass
 * 		-Av8plus{,a,b}.
 *
 *		If -bump is specified, a warning is printing when bumping to
 *		higher levels.
 *
 *		If an architecture is specified, all instructions must match
 *		that architecture.  Any higher level instructions are flagged
 *		as errors.  Note that in the 32 bit environment specifying
 *		-Av8plus does not automatically create a v8plus object file, a
 *		v9 insn must be seen.
 *
 *		If both an architecture and -bump are specified, the
 *		architecture starts at the specified level, but bumps are
 *		warnings.  Note that we can't set `current_architecture' to
 *		the requested level in this case: in the 32 bit environment,
 *		we still must avoid creating v8plus object files unless v9
 * 		insns are seen.
 *
 * Note:
 *		Bumping between incompatible architectures is always an
 *		error.  For example, from sparclite to v9.
 */

#ifdef OBJ_ELF
const char *md_shortopts = "A:K:VQ:sq";
#else
#ifdef OBJ_AOUT
const char *md_shortopts = "A:k";
#else
const char *md_shortopts = "A:";
#endif
#endif
struct option md_longopts[] = {
#define OPTION_BUMP (OPTION_MD_BASE)
  {"bump", no_argument, NULL, OPTION_BUMP},
#define OPTION_SPARC (OPTION_MD_BASE + 1)
  {"sparc", no_argument, NULL, OPTION_SPARC},
#define OPTION_XARCH (OPTION_MD_BASE + 2)
  {"xarch", required_argument, NULL, OPTION_XARCH},
#ifdef OBJ_ELF
#define OPTION_32 (OPTION_MD_BASE + 3)
  {"32", no_argument, NULL, OPTION_32},
#define OPTION_64 (OPTION_MD_BASE + 4)
  {"64", no_argument, NULL, OPTION_64},
#define OPTION_TSO (OPTION_MD_BASE + 5)
  {"TSO", no_argument, NULL, OPTION_TSO},
#define OPTION_PSO (OPTION_MD_BASE + 6)
  {"PSO", no_argument, NULL, OPTION_PSO},
#define OPTION_RMO (OPTION_MD_BASE + 7)
  {"RMO", no_argument, NULL, OPTION_RMO},
#endif
#ifdef SPARC_BIENDIAN
#define OPTION_LITTLE_ENDIAN (OPTION_MD_BASE + 8)
  {"EL", no_argument, NULL, OPTION_LITTLE_ENDIAN},
#define OPTION_BIG_ENDIAN (OPTION_MD_BASE + 9)
  {"EB", no_argument, NULL, OPTION_BIG_ENDIAN},
#endif
#define OPTION_ENFORCE_ALIGNED_DATA (OPTION_MD_BASE + 10)
  {"enforce-aligned-data", no_argument, NULL, OPTION_ENFORCE_ALIGNED_DATA},
#define OPTION_LITTLE_ENDIAN_DATA (OPTION_MD_BASE + 11)
  {"little-endian-data", no_argument, NULL, OPTION_LITTLE_ENDIAN_DATA},
#ifdef OBJ_ELF
#define OPTION_NO_UNDECLARED_REGS (OPTION_MD_BASE + 12)
  {"no-undeclared-regs", no_argument, NULL, OPTION_NO_UNDECLARED_REGS},
#define OPTION_UNDECLARED_REGS (OPTION_MD_BASE + 13)
  {"undeclared-regs", no_argument, NULL, OPTION_UNDECLARED_REGS},
#endif
#define OPTION_RELAX (OPTION_MD_BASE + 14)
  {"relax", no_argument, NULL, OPTION_RELAX},
#define OPTION_NO_RELAX (OPTION_MD_BASE + 15)
  {"no-relax", no_argument, NULL, OPTION_NO_RELAX},
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  /* We don't get a chance to initialize anything before we're called,
     so handle that now.  */
  if (! default_init_p)
    init_default_arch ();

  switch (c)
    {
    case OPTION_BUMP:
      warn_on_bump = 1;
      warn_after_architecture = SPARC_OPCODE_ARCH_V6;
      break;

    case OPTION_XARCH:
#ifdef OBJ_ELF
      if (strncmp (arg, "v9", 2) != 0)
	md_parse_option (OPTION_32, NULL);
      else
	md_parse_option (OPTION_64, NULL);
#endif
      /* Fall through.  */

    case 'A':
      {
	struct sparc_arch *sa;
	enum sparc_opcode_arch_val opcode_arch;

	sa = lookup_arch (arg);
	if (sa == NULL
	    || ! sa->user_option_p)
	  {
	    if (c == OPTION_XARCH)
	      as_bad (_("invalid architecture -xarch=%s"), arg);
	    else
	      as_bad (_("invalid architecture -A%s"), arg);
	    return 0;
	  }

	opcode_arch = sparc_opcode_lookup_arch (sa->opcode_arch);
	if (opcode_arch == SPARC_OPCODE_ARCH_BAD)
	  as_fatal (_("Bad opcode table, broken assembler."));

	max_architecture = opcode_arch;
	architecture_requested = 1;
      }
      break;

    case OPTION_SPARC:
      /* Ignore -sparc, used by SunOS make default .s.o rule.  */
      break;

    case OPTION_ENFORCE_ALIGNED_DATA:
      enforce_aligned_data = 1;
      break;

#ifdef SPARC_BIENDIAN
    case OPTION_LITTLE_ENDIAN:
      target_big_endian = 0;
      if (default_arch_type != sparclet)
	as_fatal ("This target does not support -EL");
      break;
    case OPTION_LITTLE_ENDIAN_DATA:
      target_little_endian_data = 1;
      target_big_endian = 0;
      if (default_arch_type != sparc86x
	  && default_arch_type != v9)
	as_fatal ("This target does not support --little-endian-data");
      break;
    case OPTION_BIG_ENDIAN:
      target_big_endian = 1;
      break;
#endif

#ifdef OBJ_AOUT
    case 'k':
      sparc_pic_code = 1;
      break;
#endif

#ifdef OBJ_ELF
    case OPTION_32:
    case OPTION_64:
      {
	const char **list, **l;

	sparc_arch_size = c == OPTION_32 ? 32 : 64;
	list = bfd_target_list ();
	for (l = list; *l != NULL; l++)
	  {
	    if (sparc_arch_size == 32)
	      {
		if (strcmp (*l, "elf32-sparc") == 0)
		  break;
	      }
	    else
	      {
		if (strcmp (*l, "elf64-sparc") == 0)
		  break;
	      }
	  }
	if (*l == NULL)
	  as_fatal (_("No compiled in support for %d bit object file format"),
		    sparc_arch_size);
	free (list);
      }
      break;

    case OPTION_TSO:
      sparc_memory_model = MM_TSO;
      break;

    case OPTION_PSO:
      sparc_memory_model = MM_PSO;
      break;

    case OPTION_RMO:
      sparc_memory_model = MM_RMO;
      break;

    case 'V':
      print_version_id ();
      break;

    case 'Q':
      /* Qy - do emit .comment
	 Qn - do not emit .comment.  */
      break;

    case 's':
      /* Use .stab instead of .stab.excl.  */
      break;

    case 'q':
      /* quick -- Native assembler does fewer checks.  */
      break;

    case 'K':
      if (strcmp (arg, "PIC") != 0)
	as_warn (_("Unrecognized option following -K"));
      else
	sparc_pic_code = 1;
      break;

    case OPTION_NO_UNDECLARED_REGS:
      no_undeclared_regs = 1;
      break;

    case OPTION_UNDECLARED_REGS:
      no_undeclared_regs = 0;
      break;
#endif

    case OPTION_RELAX:
      sparc_relax = 1;
      break;

    case OPTION_NO_RELAX:
      sparc_relax = 0;
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (stream)
     FILE *stream;
{
  const struct sparc_arch *arch;
  int column;

  /* We don't get a chance to initialize anything before we're called,
     so handle that now.  */
  if (! default_init_p)
    init_default_arch ();

  fprintf (stream, _("SPARC options:\n"));
  column = 0;
  for (arch = &sparc_arch_table[0]; arch->name; arch++)
    {
      if (!arch->user_option_p)
	continue;
      if (arch != &sparc_arch_table[0])
	fprintf (stream, " | ");
      if (column + strlen (arch->name) > 70)
	{
	  column = 0;
	  fputc ('\n', stream);
	}
      column += 5 + 2 + strlen (arch->name);
      fprintf (stream, "-A%s", arch->name);
    }
  for (arch = &sparc_arch_table[0]; arch->name; arch++)
    {
      if (!arch->user_option_p)
	continue;
      fprintf (stream, " | ");
      if (column + strlen (arch->name) > 65)
	{
	  column = 0;
	  fputc ('\n', stream);
	}
      column += 5 + 7 + strlen (arch->name);
      fprintf (stream, "-xarch=%s", arch->name);
    }
  fprintf (stream, _("\n\
			specify variant of SPARC architecture\n\
-bump			warn when assembler switches architectures\n\
-sparc			ignored\n\
--enforce-aligned-data	force .long, etc., to be aligned correctly\n\
-relax			relax jumps and branches (default)\n\
-no-relax		avoid changing any jumps and branches\n"));
#ifdef OBJ_AOUT
  fprintf (stream, _("\
-k			generate PIC\n"));
#endif
#ifdef OBJ_ELF
  fprintf (stream, _("\
-32			create 32 bit object file\n\
-64			create 64 bit object file\n"));
  fprintf (stream, _("\
			[default is %d]\n"), default_arch_size);
  fprintf (stream, _("\
-TSO			use Total Store Ordering\n\
-PSO			use Partial Store Ordering\n\
-RMO			use Relaxed Memory Ordering\n"));
  fprintf (stream, _("\
			[default is %s]\n"), (default_arch_size == 64) ? "RMO" : "TSO");
  fprintf (stream, _("\
-KPIC			generate PIC\n\
-V			print assembler version number\n\
-undeclared-regs	ignore application global register usage without\n\
			appropriate .register directive (default)\n\
-no-undeclared-regs	force error on application global register usage\n\
			without appropriate .register directive\n\
-q			ignored\n\
-Qy, -Qn		ignored\n\
-s			ignored\n"));
#endif
#ifdef SPARC_BIENDIAN
  fprintf (stream, _("\
-EL			generate code for a little endian machine\n\
-EB			generate code for a big endian machine\n\
--little-endian-data	generate code for a machine having big endian\n\
                        instructions and little endian data.\n"));
#endif
}

/* Native operand size opcode translation.  */
struct
  {
    char *name;
    char *name32;
    char *name64;
  } native_op_table[] =
{
  {"ldn", "ld", "ldx"},
  {"ldna", "lda", "ldxa"},
  {"stn", "st", "stx"},
  {"stna", "sta", "stxa"},
  {"slln", "sll", "sllx"},
  {"srln", "srl", "srlx"},
  {"sran", "sra", "srax"},
  {"casn", "cas", "casx"},
  {"casna", "casa", "casxa"},
  {"clrn", "clr", "clrx"},
  {NULL, NULL, NULL},
};

/* sparc64 privileged registers.  */

struct priv_reg_entry
{
  char *name;
  int regnum;
};

struct priv_reg_entry priv_reg_table[] =
{
  {"tpc", 0},
  {"tnpc", 1},
  {"tstate", 2},
  {"tt", 3},
  {"tick", 4},
  {"tba", 5},
  {"pstate", 6},
  {"tl", 7},
  {"pil", 8},
  {"cwp", 9},
  {"cansave", 10},
  {"canrestore", 11},
  {"cleanwin", 12},
  {"otherwin", 13},
  {"wstate", 14},
  {"fq", 15},
  {"gl", 16},
  {"ver", 31},
  {"", -1},			/* End marker.  */
};

/* v9a specific asrs.  */

struct priv_reg_entry v9a_asr_table[] =
{
  {"tick_cmpr", 23},
  {"sys_tick_cmpr", 25},
  {"sys_tick", 24},
  {"softint", 22},
  {"set_softint", 20},
  {"pic", 17},
  {"pcr", 16},
  {"gsr", 19},
  {"dcr", 18},
  {"clear_softint", 21},
  {"", -1},			/* End marker.  */
};

static int
cmp_reg_entry (parg, qarg)
     const PTR parg;
     const PTR qarg;
{
  const struct priv_reg_entry *p = (const struct priv_reg_entry *) parg;
  const struct priv_reg_entry *q = (const struct priv_reg_entry *) qarg;

  return strcmp (q->name, p->name);
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will
   need.  */

void
md_begin ()
{
  register const char *retval = NULL;
  int lose = 0;
  register unsigned int i = 0;

  /* We don't get a chance to initialize anything before md_parse_option
     is called, and it may not be called, so handle default initialization
     now if not already done.  */
  if (! default_init_p)
    init_default_arch ();

  sparc_cie_data_alignment = sparc_arch_size == 64 ? -8 : -4;
  op_hash = hash_new ();

  while (i < (unsigned int) sparc_num_opcodes)
    {
      const char *name = sparc_opcodes[i].name;
      retval = hash_insert (op_hash, name, (PTR) &sparc_opcodes[i]);
      if (retval != NULL)
	{
	  as_bad (_("Internal error: can't hash `%s': %s\n"),
		  sparc_opcodes[i].name, retval);
	  lose = 1;
	}
      do
	{
	  if (sparc_opcodes[i].match & sparc_opcodes[i].lose)
	    {
	      as_bad (_("Internal error: losing opcode: `%s' \"%s\"\n"),
		      sparc_opcodes[i].name, sparc_opcodes[i].args);
	      lose = 1;
	    }
	  ++i;
	}
      while (i < (unsigned int) sparc_num_opcodes
	     && !strcmp (sparc_opcodes[i].name, name));
    }

  for (i = 0; native_op_table[i].name; i++)
    {
      const struct sparc_opcode *insn;
      char *name = ((sparc_arch_size == 32)
		    ? native_op_table[i].name32
		    : native_op_table[i].name64);
      insn = (struct sparc_opcode *) hash_find (op_hash, name);
      if (insn == NULL)
	{
	  as_bad (_("Internal error: can't find opcode `%s' for `%s'\n"),
		  name, native_op_table[i].name);
	  lose = 1;
	}
      else
	{
	  retval = hash_insert (op_hash, native_op_table[i].name, (PTR) insn);
	  if (retval != NULL)
	    {
	      as_bad (_("Internal error: can't hash `%s': %s\n"),
		      sparc_opcodes[i].name, retval);
	      lose = 1;
	    }
	}
    }

  if (lose)
    as_fatal (_("Broken assembler.  No assembly attempted."));

  qsort (priv_reg_table, sizeof (priv_reg_table) / sizeof (priv_reg_table[0]),
	 sizeof (priv_reg_table[0]), cmp_reg_entry);

  /* If -bump, record the architecture level at which we start issuing
     warnings.  The behaviour is different depending upon whether an
     architecture was explicitly specified.  If it wasn't, we issue warnings
     for all upwards bumps.  If it was, we don't start issuing warnings until
     we need to bump beyond the requested architecture or when we bump between
     conflicting architectures.  */

  if (warn_on_bump
      && architecture_requested)
    {
      /* `max_architecture' records the requested architecture.
	 Issue warnings if we go above it.  */
      warn_after_architecture = max_architecture;

      /* Find the highest architecture level that doesn't conflict with
	 the requested one.  */
      for (max_architecture = SPARC_OPCODE_ARCH_MAX;
	   max_architecture > warn_after_architecture;
	   --max_architecture)
	if (! SPARC_OPCODE_CONFLICT_P (max_architecture,
				       warn_after_architecture))
	  break;
    }
}

/* Called after all assembly has been done.  */

void
sparc_md_end ()
{
  unsigned long mach = bfd_mach_sparc;

  if (sparc_arch_size == 64)
    switch (current_architecture)
      {
      case SPARC_OPCODE_ARCH_V9A: mach = bfd_mach_sparc_v9a; break;
      case SPARC_OPCODE_ARCH_V9B: mach = bfd_mach_sparc_v9b; break;
      default: mach = bfd_mach_sparc_v9; break;
      }
  else
    switch (current_architecture)
      {
      case SPARC_OPCODE_ARCH_SPARCLET: mach = bfd_mach_sparc_sparclet; break;
      case SPARC_OPCODE_ARCH_V9: mach = bfd_mach_sparc_v8plus; break;
      case SPARC_OPCODE_ARCH_V9A: mach = bfd_mach_sparc_v8plusa; break;
      case SPARC_OPCODE_ARCH_V9B: mach = bfd_mach_sparc_v8plusb; break;
      /* The sparclite is treated like a normal sparc.  Perhaps it shouldn't
	 be but for now it is (since that's the way it's always been
	 treated).  */
      default: break;
      }
  bfd_set_arch_mach (stdoutput, bfd_arch_sparc, mach);
}

/* Return non-zero if VAL is in the range -(MAX+1) to MAX.  */

static INLINE int
in_signed_range (val, max)
     bfd_signed_vma val, max;
{
  if (max <= 0)
    abort ();
  /* Sign-extend the value from the architecture word size, so that
     0xffffffff is always considered -1 on sparc32.  */
  if (sparc_arch_size == 32)
    {
      bfd_signed_vma sign = (bfd_signed_vma) 1 << 31;
      val = ((val & U0xffffffff) ^ sign) - sign;
    }
  if (val > max)
    return 0;
  if (val < ~max)
    return 0;
  return 1;
}

/* Return non-zero if VAL is in the range 0 to MAX.  */

static INLINE int
in_unsigned_range (val, max)
     bfd_vma val, max;
{
  if (val > max)
    return 0;
  return 1;
}

/* Return non-zero if VAL is in the range -(MAX/2+1) to MAX.
   (e.g. -15 to +31).  */

static INLINE int
in_bitfield_range (val, max)
     bfd_signed_vma val, max;
{
  if (max <= 0)
    abort ();
  if (val > max)
    return 0;
  if (val < ~(max >> 1))
    return 0;
  return 1;
}

static int
sparc_ffs (mask)
     unsigned int mask;
{
  int i;

  if (mask == 0)
    return -1;

  for (i = 0; (mask & 1) == 0; ++i)
    mask >>= 1;
  return i;
}

/* Implement big shift right.  */
static bfd_vma
BSR (val, amount)
     bfd_vma val;
     int amount;
{
  if (sizeof (bfd_vma) <= 4 && amount >= 32)
    as_fatal (_("Support for 64-bit arithmetic not compiled in."));
  return val >> amount;
}

/* For communication between sparc_ip and get_expression.  */
static char *expr_end;

/* Values for `special_case'.
   Instructions that require wierd handling because they're longer than
   4 bytes.  */
#define SPECIAL_CASE_NONE	0
#define	SPECIAL_CASE_SET	1
#define SPECIAL_CASE_SETSW	2
#define SPECIAL_CASE_SETX	3
/* FIXME: sparc-opc.c doesn't have necessary "S" trigger to enable this.  */
#define	SPECIAL_CASE_FDIV	4

/* Bit masks of various insns.  */
#define NOP_INSN 0x01000000
#define OR_INSN 0x80100000
#define XOR_INSN 0x80180000
#define FMOVS_INSN 0x81A00020
#define SETHI_INSN 0x01000000
#define SLLX_INSN 0x81281000
#define SRA_INSN 0x81380000

/* The last instruction to be assembled.  */
static const struct sparc_opcode *last_insn;
/* The assembled opcode of `last_insn'.  */
static unsigned long last_opcode;

/* Handle the set and setuw synthetic instructions.  */

static void
synthetize_setuw (insn)
     const struct sparc_opcode *insn;
{
  int need_hi22_p = 0;
  int rd = (the_insn.opcode & RD (~0)) >> 25;

  if (the_insn.exp.X_op == O_constant)
    {
      if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
	{
	  if (sizeof (offsetT) > 4
	      && (the_insn.exp.X_add_number < 0
		  || the_insn.exp.X_add_number > (offsetT) U0xffffffff))
	    as_warn (_("set: number not in 0..4294967295 range"));
	}
      else
	{
	  if (sizeof (offsetT) > 4
	      && (the_insn.exp.X_add_number < -(offsetT) U0x80000000
		  || the_insn.exp.X_add_number > (offsetT) U0xffffffff))
	    as_warn (_("set: number not in -2147483648..4294967295 range"));
	  the_insn.exp.X_add_number = (int) the_insn.exp.X_add_number;
	}
    }

  /* See if operand is absolute and small; skip sethi if so.  */
  if (the_insn.exp.X_op != O_constant
      || the_insn.exp.X_add_number >= (1 << 12)
      || the_insn.exp.X_add_number < -(1 << 12))
    {
      the_insn.opcode = (SETHI_INSN | RD (rd)
			 | ((the_insn.exp.X_add_number >> 10)
			    & (the_insn.exp.X_op == O_constant
			       ? 0x3fffff : 0)));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_HI22 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
      need_hi22_p = 1;
    }

  /* See if operand has no low-order bits; skip OR if so.  */
  if (the_insn.exp.X_op != O_constant
      || (need_hi22_p && (the_insn.exp.X_add_number & 0x3FF) != 0)
      || ! need_hi22_p)
    {
      the_insn.opcode = (OR_INSN | (need_hi22_p ? RS1 (rd) : 0)
			 | RD (rd) | IMMED
			 | (the_insn.exp.X_add_number
			    & (the_insn.exp.X_op != O_constant
			       ? 0 : need_hi22_p ? 0x3ff : 0x1fff)));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_LO10 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
    }
}

/* Handle the setsw synthetic instruction.  */

static void
synthetize_setsw (insn)
     const struct sparc_opcode *insn;
{
  int low32, rd, opc;

  rd = (the_insn.opcode & RD (~0)) >> 25;

  if (the_insn.exp.X_op != O_constant)
    {
      synthetize_setuw (insn);

      /* Need to sign extend it.  */
      the_insn.opcode = (SRA_INSN | RS1 (rd) | RD (rd));
      the_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &the_insn);
      return;
    }

  if (sizeof (offsetT) > 4
      && (the_insn.exp.X_add_number < -(offsetT) U0x80000000
	  || the_insn.exp.X_add_number > (offsetT) U0xffffffff))
    as_warn (_("setsw: number not in -2147483648..4294967295 range"));

  low32 = the_insn.exp.X_add_number;

  if (low32 >= 0)
    {
      synthetize_setuw (insn);
      return;
    }

  opc = OR_INSN;

  the_insn.reloc = BFD_RELOC_NONE;
  /* See if operand is absolute and small; skip sethi if so.  */
  if (low32 < -(1 << 12))
    {
      the_insn.opcode = (SETHI_INSN | RD (rd)
			 | (((~the_insn.exp.X_add_number) >> 10) & 0x3fffff));
      output_insn (insn, &the_insn);
      low32 = 0x1c00 | (low32 & 0x3ff);
      opc = RS1 (rd) | XOR_INSN;
    }

  the_insn.opcode = (opc | RD (rd) | IMMED
		     | (low32 & 0x1fff));
  output_insn (insn, &the_insn);
}

/* Handle the setsw synthetic instruction.  */

static void
synthetize_setx (insn)
     const struct sparc_opcode *insn;
{
  int upper32, lower32;
  int tmpreg = (the_insn.opcode & RS1 (~0)) >> 14;
  int dstreg = (the_insn.opcode & RD (~0)) >> 25;
  int upper_dstreg;
  int need_hh22_p = 0, need_hm10_p = 0, need_hi22_p = 0, need_lo10_p = 0;
  int need_xor10_p = 0;

#define SIGNEXT32(x) ((((x) & U0xffffffff) ^ U0x80000000) - U0x80000000)
  lower32 = SIGNEXT32 (the_insn.exp.X_add_number);
  upper32 = SIGNEXT32 (BSR (the_insn.exp.X_add_number, 32));
#undef SIGNEXT32

  upper_dstreg = tmpreg;
  /* The tmp reg should not be the dst reg.  */
  if (tmpreg == dstreg)
    as_warn (_("setx: temporary register same as destination register"));

  /* ??? Obviously there are other optimizations we can do
     (e.g. sethi+shift for 0x1f0000000) and perhaps we shouldn't be
     doing some of these.  Later.  If you do change things, try to
     change all of this to be table driven as well.  */
  /* What to output depends on the number if it's constant.
     Compute that first, then output what we've decided upon.  */
  if (the_insn.exp.X_op != O_constant)
    {
      if (sparc_arch_size == 32)
	{
	  /* When arch size is 32, we want setx to be equivalent
	     to setuw for anything but constants.  */
	  the_insn.exp.X_add_number &= 0xffffffff;
	  synthetize_setuw (insn);
	  return;
	}
      need_hh22_p = need_hm10_p = need_hi22_p = need_lo10_p = 1;
      lower32 = 0;
      upper32 = 0;
    }
  else
    {
      /* Reset X_add_number, we've extracted it as upper32/lower32.
	 Otherwise fixup_segment will complain about not being able to
	 write an 8 byte number in a 4 byte field.  */
      the_insn.exp.X_add_number = 0;

      /* Only need hh22 if `or' insn can't handle constant.  */
      if (upper32 < -(1 << 12) || upper32 >= (1 << 12))
	need_hh22_p = 1;

      /* Does bottom part (after sethi) have bits?  */
      if ((need_hh22_p && (upper32 & 0x3ff) != 0)
	  /* No hh22, but does upper32 still have bits we can't set
	     from lower32?  */
	  || (! need_hh22_p && upper32 != 0 && upper32 != -1))
	need_hm10_p = 1;

      /* If the lower half is all zero, we build the upper half directly
	 into the dst reg.  */
      if (lower32 != 0
	  /* Need lower half if number is zero or 0xffffffff00000000.  */
	  || (! need_hh22_p && ! need_hm10_p))
	{
	  /* No need for sethi if `or' insn can handle constant.  */
	  if (lower32 < -(1 << 12) || lower32 >= (1 << 12)
	      /* Note that we can't use a negative constant in the `or'
		 insn unless the upper 32 bits are all ones.  */
	      || (lower32 < 0 && upper32 != -1)
	      || (lower32 >= 0 && upper32 == -1))
	    need_hi22_p = 1;

	  if (need_hi22_p && upper32 == -1)
	    need_xor10_p = 1;

	  /* Does bottom part (after sethi) have bits?  */
	  else if ((need_hi22_p && (lower32 & 0x3ff) != 0)
		   /* No sethi.  */
		   || (! need_hi22_p && (lower32 & 0x1fff) != 0)
		   /* Need `or' if we didn't set anything else.  */
		   || (! need_hi22_p && ! need_hh22_p && ! need_hm10_p))
	    need_lo10_p = 1;
	}
      else
	/* Output directly to dst reg if lower 32 bits are all zero.  */
	upper_dstreg = dstreg;
    }

  if (!upper_dstreg && dstreg)
    as_warn (_("setx: illegal temporary register g0"));

  if (need_hh22_p)
    {
      the_insn.opcode = (SETHI_INSN | RD (upper_dstreg)
			 | ((upper32 >> 10) & 0x3fffff));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_SPARC_HH22 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
    }

  if (need_hi22_p)
    {
      the_insn.opcode = (SETHI_INSN | RD (dstreg)
			 | (((need_xor10_p ? ~lower32 : lower32)
			     >> 10) & 0x3fffff));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_SPARC_LM22 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
    }

  if (need_hm10_p)
    {
      the_insn.opcode = (OR_INSN
			 | (need_hh22_p ? RS1 (upper_dstreg) : 0)
			 | RD (upper_dstreg)
			 | IMMED
			 | (upper32 & (need_hh22_p ? 0x3ff : 0x1fff)));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_SPARC_HM10 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
    }

  if (need_lo10_p)
    {
      /* FIXME: One nice optimization to do here is to OR the low part
	 with the highpart if hi22 isn't needed and the low part is
	 positive.  */
      the_insn.opcode = (OR_INSN | (need_hi22_p ? RS1 (dstreg) : 0)
			 | RD (dstreg)
			 | IMMED
			 | (lower32 & (need_hi22_p ? 0x3ff : 0x1fff)));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_LO10 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
    }

  /* If we needed to build the upper part, shift it into place.  */
  if (need_hh22_p || need_hm10_p)
    {
      the_insn.opcode = (SLLX_INSN | RS1 (upper_dstreg) | RD (upper_dstreg)
			 | IMMED | 32);
      the_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &the_insn);
    }

  /* To get -1 in upper32, we do sethi %hi(~x), r; xor r, -0x400 | x, r.  */
  if (need_xor10_p)
    {
      the_insn.opcode = (XOR_INSN | RS1 (dstreg) | RD (dstreg) | IMMED
			 | 0x1c00 | (lower32 & 0x3ff));
      the_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &the_insn);
    }

  /* If we needed to build both upper and lower parts, OR them together.  */
  else if ((need_hh22_p || need_hm10_p) && (need_hi22_p || need_lo10_p))
    {
      the_insn.opcode = (OR_INSN | RS1 (dstreg) | RS2 (upper_dstreg)
			 | RD (dstreg));
      the_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &the_insn);
    }
}

/* Main entry point to assemble one instruction.  */

void
md_assemble (str)
     char *str;
{
  const struct sparc_opcode *insn;
  int special_case;

  know (str);
  special_case = sparc_ip (str, &insn);

  /* We warn about attempts to put a floating point branch in a delay slot,
     unless the delay slot has been annulled.  */
  if (insn != NULL
      && last_insn != NULL
      && (insn->flags & F_FBR) != 0
      && (last_insn->flags & F_DELAYED) != 0
      /* ??? This test isn't completely accurate.  We assume anything with
	 F_{UNBR,CONDBR,FBR} set is annullable.  */
      && ((last_insn->flags & (F_UNBR | F_CONDBR | F_FBR)) == 0
	  || (last_opcode & ANNUL) == 0))
    as_warn (_("FP branch in delay slot"));

  /* SPARC before v9 requires a nop instruction between a floating
     point instruction and a floating point branch.  We insert one
     automatically, with a warning.  */
  if (max_architecture < SPARC_OPCODE_ARCH_V9
      && insn != NULL
      && last_insn != NULL
      && (insn->flags & F_FBR) != 0
      && (last_insn->flags & F_FLOAT) != 0)
    {
      struct sparc_it nop_insn;

      nop_insn.opcode = NOP_INSN;
      nop_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &nop_insn);
      as_warn (_("FP branch preceded by FP instruction; NOP inserted"));
    }

  switch (special_case)
    {
    case SPECIAL_CASE_NONE:
      /* Normal insn.  */
      output_insn (insn, &the_insn);
      break;

    case SPECIAL_CASE_SETSW:
      synthetize_setsw (insn);
      break;

    case SPECIAL_CASE_SET:
      synthetize_setuw (insn);
      break;

    case SPECIAL_CASE_SETX:
      synthetize_setx (insn);
      break;

    case SPECIAL_CASE_FDIV:
      {
	int rd = (the_insn.opcode >> 25) & 0x1f;

	output_insn (insn, &the_insn);

	/* According to information leaked from Sun, the "fdiv" instructions
	   on early SPARC machines would produce incorrect results sometimes.
	   The workaround is to add an fmovs of the destination register to
	   itself just after the instruction.  This was true on machines
	   with Weitek 1165 float chips, such as the Sun-4/260 and /280.  */
	assert (the_insn.reloc == BFD_RELOC_NONE);
	the_insn.opcode = FMOVS_INSN | rd | RD (rd);
	output_insn (insn, &the_insn);
	return;
      }

    default:
      as_fatal (_("failed special case insn sanity check"));
    }
}

/* Subroutine of md_assemble to do the actual parsing.  */

static int
sparc_ip (str, pinsn)
     char *str;
     const struct sparc_opcode **pinsn;
{
  char *error_message = "";
  char *s;
  const char *args;
  char c;
  const struct sparc_opcode *insn;
  char *argsStart;
  unsigned long opcode;
  unsigned int mask = 0;
  int match = 0;
  int comma = 0;
  int v9_arg_p;
  int special_case = SPECIAL_CASE_NONE;

  s = str;
  if (ISLOWER (*s))
    {
      do
	++s;
      while (ISLOWER (*s) || ISDIGIT (*s));
    }

  switch (*s)
    {
    case '\0':
      break;

    case ',':
      comma = 1;
      /* Fall through.  */

    case ' ':
      *s++ = '\0';
      break;

    default:
      as_fatal (_("Unknown opcode: `%s'"), str);
    }
  insn = (struct sparc_opcode *) hash_find (op_hash, str);
  *pinsn = insn;
  if (insn == NULL)
    {
      as_bad (_("Unknown opcode: `%s'"), str);
      return special_case;
    }
  if (comma)
    {
      *--s = ',';
    }

  argsStart = s;
  for (;;)
    {
      opcode = insn->match;
      memset (&the_insn, '\0', sizeof (the_insn));
      the_insn.reloc = BFD_RELOC_NONE;
      v9_arg_p = 0;

      /* Build the opcode, checking as we go to make sure that the
         operands match.  */
      for (args = insn->args;; ++args)
	{
	  switch (*args)
	    {
	    case 'K':
	      {
		int kmask = 0;

		/* Parse a series of masks.  */
		if (*s == '#')
		  {
		    while (*s == '#')
		      {
			int mask;

			if (! parse_keyword_arg (sparc_encode_membar, &s,
						 &mask))
			  {
			    error_message = _(": invalid membar mask name");
			    goto error;
			  }
			kmask |= mask;
			while (*s == ' ')
			  ++s;
			if (*s == '|' || *s == '+')
			  ++s;
			while (*s == ' ')
			  ++s;
		      }
		  }
		else
		  {
		    if (! parse_const_expr_arg (&s, &kmask))
		      {
			error_message = _(": invalid membar mask expression");
			goto error;
		      }
		    if (kmask < 0 || kmask > 127)
		      {
			error_message = _(": invalid membar mask number");
			goto error;
		      }
		  }

		opcode |= MEMBAR (kmask);
		continue;
	      }

	    case '3':
	      {
		int smask = 0;

		if (! parse_const_expr_arg (&s, &smask))
		  {
		    error_message = _(": invalid siam mode expression");
		    goto error;
		  }
		if (smask < 0 || smask > 7)
		  {
		    error_message = _(": invalid siam mode number");
		    goto error;
		  }
		opcode |= smask;
		continue;
	      }

	    case '*':
	      {
		int fcn = 0;

		/* Parse a prefetch function.  */
		if (*s == '#')
		  {
		    if (! parse_keyword_arg (sparc_encode_prefetch, &s, &fcn))
		      {
			error_message = _(": invalid prefetch function name");
			goto error;
		      }
		  }
		else
		  {
		    if (! parse_const_expr_arg (&s, &fcn))
		      {
			error_message = _(": invalid prefetch function expression");
			goto error;
		      }
		    if (fcn < 0 || fcn > 31)
		      {
			error_message = _(": invalid prefetch function number");
			goto error;
		      }
		  }
		opcode |= RD (fcn);
		continue;
	      }

	    case '!':
	    case '?':
	      /* Parse a sparc64 privileged register.  */
	      if (*s == '%')
		{
		  struct priv_reg_entry *p = priv_reg_table;
		  unsigned int len = 9999999; /* Init to make gcc happy.  */

		  s += 1;
		  while (p->name[0] > s[0])
		    p++;
		  while (p->name[0] == s[0])
		    {
		      len = strlen (p->name);
		      if (strncmp (p->name, s, len) == 0)
			break;
		      p++;
		    }
		  if (p->name[0] != s[0])
		    {
		      error_message = _(": unrecognizable privileged register");
		      goto error;
		    }
		  if (*args == '?')
		    opcode |= (p->regnum << 14);
		  else
		    opcode |= (p->regnum << 25);
		  s += len;
		  continue;
		}
	      else
		{
		  error_message = _(": unrecognizable privileged register");
		  goto error;
		}

	    case '_':
	    case '/':
	      /* Parse a v9a/v9b ancillary state register.  */
	      if (*s == '%')
		{
		  struct priv_reg_entry *p = v9a_asr_table;
		  unsigned int len = 9999999; /* Init to make gcc happy.  */

		  s += 1;
		  while (p->name[0] > s[0])
		    p++;
		  while (p->name[0] == s[0])
		    {
		      len = strlen (p->name);
		      if (strncmp (p->name, s, len) == 0)
			break;
		      p++;
		    }
		  if (p->name[0] != s[0])
		    {
		      error_message = _(": unrecognizable v9a or v9b ancillary state register");
		      goto error;
		    }
		  if (*args == '/' && (p->regnum == 20 || p->regnum == 21))
		    {
		      error_message = _(": rd on write only ancillary state register");
		      goto error;
		    }
		  if (p->regnum >= 24
		      && (insn->architecture
			  & SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9A)))
		    {
		      /* %sys_tick and %sys_tick_cmpr are v9bnotv9a */
		      error_message = _(": unrecognizable v9a ancillary state register");
		      goto error;
		    }
		  if (*args == '/')
		    opcode |= (p->regnum << 14);
		  else
		    opcode |= (p->regnum << 25);
		  s += len;
		  continue;
		}
	      else
		{
		  error_message = _(": unrecognizable v9a or v9b ancillary state register");
		  goto error;
		}

	    case 'M':
	    case 'm':
	      if (strncmp (s, "%asr", 4) == 0)
		{
		  s += 4;

		  if (ISDIGIT (*s))
		    {
		      long num = 0;

		      while (ISDIGIT (*s))
			{
			  num = num * 10 + *s - '0';
			  ++s;
			}

		      if (current_architecture >= SPARC_OPCODE_ARCH_V9)
			{
			  if (num < 16 || 31 < num)
			    {
			      error_message = _(": asr number must be between 16 and 31");
			      goto error;
			    }
			}
		      else
			{
			  if (num < 0 || 31 < num)
			    {
			      error_message = _(": asr number must be between 0 and 31");
			      goto error;
			    }
			}

		      opcode |= (*args == 'M' ? RS1 (num) : RD (num));
		      continue;
		    }
		  else
		    {
		      error_message = _(": expecting %asrN");
		      goto error;
		    }
		} /* if %asr  */
	      break;

	    case 'I':
	      the_insn.reloc = BFD_RELOC_SPARC_11;
	      goto immediate;

	    case 'j':
	      the_insn.reloc = BFD_RELOC_SPARC_10;
	      goto immediate;

	    case 'X':
	      /* V8 systems don't understand BFD_RELOC_SPARC_5.  */
	      if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
		the_insn.reloc = BFD_RELOC_SPARC_5;
	      else
		the_insn.reloc = BFD_RELOC_SPARC13;
	      /* These fields are unsigned, but for upward compatibility,
		 allow negative values as well.  */
	      goto immediate;

	    case 'Y':
	      /* V8 systems don't understand BFD_RELOC_SPARC_6.  */
	      if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
		the_insn.reloc = BFD_RELOC_SPARC_6;
	      else
		the_insn.reloc = BFD_RELOC_SPARC13;
	      /* These fields are unsigned, but for upward compatibility,
		 allow negative values as well.  */
	      goto immediate;

	    case 'k':
	      the_insn.reloc = /* RELOC_WDISP2_14 */ BFD_RELOC_SPARC_WDISP16;
	      the_insn.pcrel = 1;
	      goto immediate;

	    case 'G':
	      the_insn.reloc = BFD_RELOC_SPARC_WDISP19;
	      the_insn.pcrel = 1;
	      goto immediate;

	    case 'N':
	      if (*s == 'p' && s[1] == 'n')
		{
		  s += 2;
		  continue;
		}
	      break;

	    case 'T':
	      if (*s == 'p' && s[1] == 't')
		{
		  s += 2;
		  continue;
		}
	      break;

	    case 'z':
	      if (*s == ' ')
		{
		  ++s;
		}
	      if (strncmp (s, "%icc", 4) == 0)
		{
		  s += 4;
		  continue;
		}
	      break;

	    case 'Z':
	      if (*s == ' ')
		{
		  ++s;
		}
	      if (strncmp (s, "%xcc", 4) == 0)
		{
		  s += 4;
		  continue;
		}
	      break;

	    case '6':
	      if (*s == ' ')
		{
		  ++s;
		}
	      if (strncmp (s, "%fcc0", 5) == 0)
		{
		  s += 5;
		  continue;
		}
	      break;

	    case '7':
	      if (*s == ' ')
		{
		  ++s;
		}
	      if (strncmp (s, "%fcc1", 5) == 0)
		{
		  s += 5;
		  continue;
		}
	      break;

	    case '8':
	      if (*s == ' ')
		{
		  ++s;
		}
	      if (strncmp (s, "%fcc2", 5) == 0)
		{
		  s += 5;
		  continue;
		}
	      break;

	    case '9':
	      if (*s == ' ')
		{
		  ++s;
		}
	      if (strncmp (s, "%fcc3", 5) == 0)
		{
		  s += 5;
		  continue;
		}
	      break;

	    case 'P':
	      if (strncmp (s, "%pc", 3) == 0)
		{
		  s += 3;
		  continue;
		}
	      break;

	    case 'W':
	      if (strncmp (s, "%tick", 5) == 0)
		{
		  s += 5;
		  continue;
		}
	      break;

	    case '\0':		/* End of args.  */
	      if (s[0] == ',' && s[1] == '%')
		{
		  static const struct tls_ops {
		    /* The name as it appears in assembler.  */
		    char *name;
		    /* strlen (name), precomputed for speed */
		    int len;
		    /* The reloc this pseudo-op translates to.  */
		    int reloc;
		    /* 1 if call.  */
		    int call;
		  } tls_ops[] = {
		    { "tgd_add", 7, BFD_RELOC_SPARC_TLS_GD_ADD, 0 },
		    { "tgd_call", 8, BFD_RELOC_SPARC_TLS_GD_CALL, 1 },
		    { "tldm_add", 8, BFD_RELOC_SPARC_TLS_LDM_ADD, 0 },
		    { "tldm_call", 9, BFD_RELOC_SPARC_TLS_LDM_CALL, 1 },
		    { "tldo_add", 8, BFD_RELOC_SPARC_TLS_LDO_ADD, 0 },
		    { "tie_ldx", 7, BFD_RELOC_SPARC_TLS_IE_LDX, 0 },
		    { "tie_ld", 6, BFD_RELOC_SPARC_TLS_IE_LD, 0 },
		    { "tie_add", 7, BFD_RELOC_SPARC_TLS_IE_ADD, 0 }
		  };
		  const struct tls_ops *o;
		  char *s1;
		  int npar = 0;

		  for (o = tls_ops; o->name; o++)
		    if (strncmp (s + 2, o->name, o->len) == 0)
		      break;
		  if (o->name == NULL)
		    break;

		  if (s[o->len + 2] != '(')
		    {
		      as_bad (_("Illegal operands: %%%s requires arguments in ()"), o->name);
		      return special_case;
		    }

		  if (! o->call && the_insn.reloc != BFD_RELOC_NONE)
		    {
		      as_bad (_("Illegal operands: %%%s cannot be used together with other relocs in the insn ()"),
			      o->name);
		      return special_case;
		    }

		  if (o->call
		      && (the_insn.reloc != BFD_RELOC_32_PCREL_S2
			  || the_insn.exp.X_add_number != 0
			  || the_insn.exp.X_add_symbol
			     != symbol_find_or_make ("__tls_get_addr")))
		    {
		      as_bad (_("Illegal operands: %%%s can be only used with call __tls_get_addr"),
			      o->name);
		      return special_case;
		    }

		  the_insn.reloc = o->reloc;
		  memset (&the_insn.exp, 0, sizeof (the_insn.exp));
		  s += o->len + 3;

		  for (s1 = s; *s1 && *s1 != ',' && *s1 != ']'; s1++)
		    if (*s1 == '(')
		      npar++;
		    else if (*s1 == ')')
		      {
			if (!npar)
			  break;
			npar--;
		      }

		  if (*s1 != ')')
		    {
		      as_bad (_("Illegal operands: %%%s requires arguments in ()"), o->name);
		      return special_case;
		    }

		  *s1 = '\0';
		  (void) get_expression (s);
		  *s1 = ')';
		  s = s1 + 1;
		}
	      if (*s == '\0')
		match = 1;
	      break;

	    case '+':
	      if (*s == '+')
		{
		  ++s;
		  continue;
		}
	      if (*s == '-')
		{
		  continue;
		}
	      break;

	    case '[':		/* These must match exactly.  */
	    case ']':
	    case ',':
	    case ' ':
	      if (*s++ == *args)
		continue;
	      break;

	    case '#':		/* Must be at least one digit.  */
	      if (ISDIGIT (*s++))
		{
		  while (ISDIGIT (*s))
		    {
		      ++s;
		    }
		  continue;
		}
	      break;

	    case 'C':		/* Coprocessor state register.  */
	      if (strncmp (s, "%csr", 4) == 0)
		{
		  s += 4;
		  continue;
		}
	      break;

	    case 'b':		/* Next operand is a coprocessor register.  */
	    case 'c':
	    case 'D':
	      if (*s++ == '%' && *s++ == 'c' && ISDIGIT (*s))
		{
		  mask = *s++;
		  if (ISDIGIT (*s))
		    {
		      mask = 10 * (mask - '0') + (*s++ - '0');
		      if (mask >= 32)
			{
			  break;
			}
		    }
		  else
		    {
		      mask -= '0';
		    }
		  switch (*args)
		    {

		    case 'b':
		      opcode |= mask << 14;
		      continue;

		    case 'c':
		      opcode |= mask;
		      continue;

		    case 'D':
		      opcode |= mask << 25;
		      continue;
		    }
		}
	      break;

	    case 'r':		/* next operand must be a register */
	    case 'O':
	    case '1':
	    case '2':
	    case 'd':
	      if (*s++ == '%')
		{
		  switch (c = *s++)
		    {

		    case 'f':	/* frame pointer */
		      if (*s++ == 'p')
			{
			  mask = 0x1e;
			  break;
			}
		      goto error;

		    case 'g':	/* global register */
		      c = *s++;
		      if (isoctal (c))
			{
			  mask = c - '0';
			  break;
			}
		      goto error;

		    case 'i':	/* in register */
		      c = *s++;
		      if (isoctal (c))
			{
			  mask = c - '0' + 24;
			  break;
			}
		      goto error;

		    case 'l':	/* local register */
		      c = *s++;
		      if (isoctal (c))
			{
			  mask = (c - '0' + 16);
			  break;
			}
		      goto error;

		    case 'o':	/* out register */
		      c = *s++;
		      if (isoctal (c))
			{
			  mask = (c - '0' + 8);
			  break;
			}
		      goto error;

		    case 's':	/* stack pointer */
		      if (*s++ == 'p')
			{
			  mask = 0xe;
			  break;
			}
		      goto error;

		    case 'r':	/* any register */
		      if (!ISDIGIT ((c = *s++)))
			{
			  goto error;
			}
		      /* FALLTHROUGH */
		    case '0':
		    case '1':
		    case '2':
		    case '3':
		    case '4':
		    case '5':
		    case '6':
		    case '7':
		    case '8':
		    case '9':
		      if (ISDIGIT (*s))
			{
			  if ((c = 10 * (c - '0') + (*s++ - '0')) >= 32)
			    {
			      goto error;
			    }
			}
		      else
			{
			  c -= '0';
			}
		      mask = c;
		      break;

		    default:
		      goto error;
		    }

		  if ((mask & ~1) == 2 && sparc_arch_size == 64
		      && no_undeclared_regs && ! globals[mask])
		    as_bad (_("detected global register use not covered by .register pseudo-op"));

		  /* Got the register, now figure out where
		     it goes in the opcode.  */
		  switch (*args)
		    {
		    case '1':
		      opcode |= mask << 14;
		      continue;

		    case '2':
		      opcode |= mask;
		      continue;

		    case 'd':
		      opcode |= mask << 25;
		      continue;

		    case 'r':
		      opcode |= (mask << 25) | (mask << 14);
		      continue;

		    case 'O':
		      opcode |= (mask << 25) | (mask << 0);
		      continue;
		    }
		}
	      break;

	    case 'e':		/* next operand is a floating point register */
	    case 'v':
	    case 'V':

	    case 'f':
	    case 'B':
	    case 'R':

	    case 'g':
	    case 'H':
	    case 'J':
	      {
		char format;

		if (*s++ == '%'
		    && ((format = *s) == 'f')
		    && ISDIGIT (*++s))
		  {
		    for (mask = 0; ISDIGIT (*s); ++s)
		      {
			mask = 10 * mask + (*s - '0');
		      }		/* read the number */

		    if ((*args == 'v'
			 || *args == 'B'
			 || *args == 'H')
			&& (mask & 1))
		      {
			break;
		      }		/* register must be even numbered */

		    if ((*args == 'V'
			 || *args == 'R'
			 || *args == 'J')
			&& (mask & 3))
		      {
			break;
		      }		/* register must be multiple of 4 */

		    if (mask >= 64)
		      {
			if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
			  error_message = _(": There are only 64 f registers; [0-63]");
			else
			  error_message = _(": There are only 32 f registers; [0-31]");
			goto error;
		      }	/* on error */
		    else if (mask >= 32)
		      {
			if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
			  {
#if !defined(TE_OpenBSD)
			    if (*args == 'e' || *args == 'f' || *args == 'g')
			      {
				error_message
				  = _(": There are only 32 single precision f registers; [0-31]");
				goto error;
			      }
#endif
			    v9_arg_p = 1;
			    mask -= 31;	/* wrap high bit */
			  }
			else
			  {
			    error_message = _(": There are only 32 f registers; [0-31]");
			    goto error;
			  }
		      }
		  }
		else
		  {
		    break;
		  }	/* if not an 'f' register.  */

		switch (*args)
		  {
		  case 'v':
		  case 'V':
		  case 'e':
		    opcode |= RS1 (mask);
		    continue;

		  case 'f':
		  case 'B':
		  case 'R':
		    opcode |= RS2 (mask);
		    continue;

		  case 'g':
		  case 'H':
		  case 'J':
		    opcode |= RD (mask);
		    continue;
		  }		/* Pack it in.  */

		know (0);
		break;
	      }			/* float arg  */

	    case 'F':
	      if (strncmp (s, "%fsr", 4) == 0)
		{
		  s += 4;
		  continue;
		}
	      break;

	    case '0':		/* 64 bit immediate (set, setsw, setx insn)  */
	      the_insn.reloc = BFD_RELOC_NONE; /* reloc handled elsewhere  */
	      goto immediate;

	    case 'l':		/* 22 bit PC relative immediate  */
	      the_insn.reloc = BFD_RELOC_SPARC_WDISP22;
	      the_insn.pcrel = 1;
	      goto immediate;

	    case 'L':		/* 30 bit immediate  */
	      the_insn.reloc = BFD_RELOC_32_PCREL_S2;
	      the_insn.pcrel = 1;
	      goto immediate;

	    case 'h':
	    case 'n':		/* 22 bit immediate  */
	      the_insn.reloc = BFD_RELOC_SPARC22;
	      goto immediate;

	    case 'i':		/* 13 bit immediate  */
	      the_insn.reloc = BFD_RELOC_SPARC13;

	      /* fallthrough */

	    immediate:
	      if (*s == ' ')
		s++;

	      {
		char *s1;
		char *op_arg = NULL;
		expressionS op_exp;
		bfd_reloc_code_real_type old_reloc = the_insn.reloc;

		/* Check for %hi, etc.  */
		if (*s == '%')
		  {
		    static const struct ops {
		      /* The name as it appears in assembler.  */
		      char *name;
		      /* strlen (name), precomputed for speed */
		      int len;
		      /* The reloc this pseudo-op translates to.  */
		      int reloc;
		      /* Non-zero if for v9 only.  */
		      int v9_p;
		      /* Non-zero if can be used in pc-relative contexts.  */
		      int pcrel_p;/*FIXME:wip*/
		    } ops[] = {
		      /* hix/lox must appear before hi/lo so %hix won't be
			 mistaken for %hi.  */
		      { "hix", 3, BFD_RELOC_SPARC_HIX22, 1, 0 },
		      { "lox", 3, BFD_RELOC_SPARC_LOX10, 1, 0 },
		      { "hi", 2, BFD_RELOC_HI22, 0, 1 },
		      { "lo", 2, BFD_RELOC_LO10, 0, 1 },
		      { "hh", 2, BFD_RELOC_SPARC_HH22, 1, 1 },
		      { "hm", 2, BFD_RELOC_SPARC_HM10, 1, 1 },
		      { "lm", 2, BFD_RELOC_SPARC_LM22, 1, 1 },
		      { "h44", 3, BFD_RELOC_SPARC_H44, 1, 0 },
		      { "m44", 3, BFD_RELOC_SPARC_M44, 1, 0 },
		      { "l44", 3, BFD_RELOC_SPARC_L44, 1, 0 },
		      { "uhi", 3, BFD_RELOC_SPARC_HH22, 1, 0 },
		      { "ulo", 3, BFD_RELOC_SPARC_HM10, 1, 0 },
		      { "tgd_hi22", 8, BFD_RELOC_SPARC_TLS_GD_HI22, 0, 0 },
		      { "tgd_lo10", 8, BFD_RELOC_SPARC_TLS_GD_LO10, 0, 0 },
		      { "tldm_hi22", 9, BFD_RELOC_SPARC_TLS_LDM_HI22, 0, 0 },
		      { "tldm_lo10", 9, BFD_RELOC_SPARC_TLS_LDM_LO10, 0, 0 },
		      { "tldo_hix22", 10, BFD_RELOC_SPARC_TLS_LDO_HIX22, 0,
									 0 },
		      { "tldo_lox10", 10, BFD_RELOC_SPARC_TLS_LDO_LOX10, 0,
									 0 },
		      { "tie_hi22", 8, BFD_RELOC_SPARC_TLS_IE_HI22, 0, 0 },
		      { "tie_lo10", 8, BFD_RELOC_SPARC_TLS_IE_LO10, 0, 0 },
		      { "tle_hix22", 9, BFD_RELOC_SPARC_TLS_LE_HIX22, 0, 0 },
		      { "tle_lox10", 9, BFD_RELOC_SPARC_TLS_LE_LOX10, 0, 0 },
		      { NULL, 0, 0, 0, 0 }
		    };
		    const struct ops *o;

		    for (o = ops; o->name; o++)
		      if (strncmp (s + 1, o->name, o->len) == 0)
			break;
		    if (o->name == NULL)
		      break;

		    if (s[o->len + 1] != '(')
		      {
			as_bad (_("Illegal operands: %%%s requires arguments in ()"), o->name);
			return special_case;
		      }

		    op_arg = o->name;
		    the_insn.reloc = o->reloc;
		    s += o->len + 2;
		    v9_arg_p = o->v9_p;
		  }

		/* Note that if the get_expression() fails, we will still
		   have created U entries in the symbol table for the
		   'symbols' in the input string.  Try not to create U
		   symbols for registers, etc.  */

		/* This stuff checks to see if the expression ends in
		   +%reg.  If it does, it removes the register from
		   the expression, and re-sets 's' to point to the
		   right place.  */

		if (op_arg)
		  {
		    int npar = 0;

		    for (s1 = s; *s1 && *s1 != ',' && *s1 != ']'; s1++)
		      if (*s1 == '(')
			npar++;
		      else if (*s1 == ')')
			{
			  if (!npar)
			    break;
			  npar--;
			}

		    if (*s1 != ')')
		      {
			as_bad (_("Illegal operands: %%%s requires arguments in ()"), op_arg);
			return special_case;
		      }

		    *s1 = '\0';
		    (void) get_expression (s);
		    *s1 = ')';
		    s = s1 + 1;
		    if (*s == ',' || *s == ']' || !*s)
		      continue;
		    if (*s != '+' && *s != '-')
		      {
			as_bad (_("Illegal operands: Can't do arithmetics other than + and - involving %%%s()"), op_arg);
			return special_case;
		      }
		    *s1 = '0';
		    s = s1;
		    op_exp = the_insn.exp;
		    memset (&the_insn.exp, 0, sizeof (the_insn.exp));
		  }

		for (s1 = s; *s1 && *s1 != ',' && *s1 != ']'; s1++)
		  ;

		if (s1 != s && ISDIGIT (s1[-1]))
		  {
		    if (s1[-2] == '%' && s1[-3] == '+')
		      s1 -= 3;
		    else if (strchr ("goli0123456789", s1[-2]) && s1[-3] == '%' && s1[-4] == '+')
		      s1 -= 4;
		    else
		      s1 = NULL;
		    if (s1)
		      {
			*s1 = '\0';
			if (op_arg && s1 == s + 1)
			  the_insn.exp.X_op = O_absent;
			else
			  (void) get_expression (s);
			*s1 = '+';
			if (op_arg)
			  *s = ')';
			s = s1;
		      }
		  }
		else
		  s1 = NULL;

		if (!s1)
		  {
		    (void) get_expression (s);
		    if (op_arg)
		      *s = ')';
		    s = expr_end;
		  }

		if (op_arg)
		  {
		    the_insn.exp2 = the_insn.exp;
		    the_insn.exp = op_exp;
		    if (the_insn.exp2.X_op == O_absent)
		      the_insn.exp2.X_op = O_illegal;
		    else if (the_insn.exp.X_op == O_absent)
		      {
			the_insn.exp = the_insn.exp2;
			the_insn.exp2.X_op = O_illegal;
		      }
		    else if (the_insn.exp.X_op == O_constant)
		      {
			valueT val = the_insn.exp.X_add_number;
			switch (the_insn.reloc)
			  {
			  default:
			    break;

			  case BFD_RELOC_SPARC_HH22:
			    val = BSR (val, 32);
			    /* Fall through.  */

			  case BFD_RELOC_SPARC_LM22:
			  case BFD_RELOC_HI22:
			    val = (val >> 10) & 0x3fffff;
			    break;

			  case BFD_RELOC_SPARC_HM10:
			    val = BSR (val, 32);
			    /* Fall through.  */

			  case BFD_RELOC_LO10:
			    val &= 0x3ff;
			    break;

			  case BFD_RELOC_SPARC_H44:
			    val >>= 22;
			    val &= 0x3fffff;
			    break;

			  case BFD_RELOC_SPARC_M44:
			    val >>= 12;
			    val &= 0x3ff;
			    break;

			  case BFD_RELOC_SPARC_L44:
			    val &= 0xfff;
			    break;

			  case BFD_RELOC_SPARC_HIX22:
			    val = ~val;
			    val = (val >> 10) & 0x3fffff;
			    break;

			  case BFD_RELOC_SPARC_LOX10:
			    val = (val & 0x3ff) | 0x1c00;
			    break;
			  }
			the_insn.exp = the_insn.exp2;
			the_insn.exp.X_add_number += val;
			the_insn.exp2.X_op = O_illegal;
			the_insn.reloc = old_reloc;
		      }
		    else if (the_insn.exp2.X_op != O_constant)
		      {
			as_bad (_("Illegal operands: Can't add non-constant expression to %%%s()"), op_arg);
			return special_case;
		      }
		    else
		      {
			if (old_reloc != BFD_RELOC_SPARC13
			    || the_insn.reloc != BFD_RELOC_LO10
			    || sparc_arch_size != 64
			    || sparc_pic_code)
			  {
			    as_bad (_("Illegal operands: Can't do arithmetics involving %%%s() of a relocatable symbol"), op_arg);
			    return special_case;
			  }
			the_insn.reloc = BFD_RELOC_SPARC_OLO10;
		      }
		  }
	      }
	      /* Check for constants that don't require emitting a reloc.  */
	      if (the_insn.exp.X_op == O_constant
		  && the_insn.exp.X_add_symbol == 0
		  && the_insn.exp.X_op_symbol == 0)
		{
		  /* For pc-relative call instructions, we reject
		     constants to get better code.  */
		  if (the_insn.pcrel
		      && the_insn.reloc == BFD_RELOC_32_PCREL_S2
		      && in_signed_range (the_insn.exp.X_add_number, 0x3fff))
		    {
		      error_message = _(": PC-relative operand can't be a constant");
		      goto error;
		    }

		  if (the_insn.reloc >= BFD_RELOC_SPARC_TLS_GD_HI22
		      && the_insn.reloc <= BFD_RELOC_SPARC_TLS_TPOFF64)
		    {
		      error_message = _(": TLS operand can't be a constant");
		      goto error;
		    }

		  /* Constants that won't fit are checked in md_apply_fix3
		     and bfd_install_relocation.
		     ??? It would be preferable to install the constants
		     into the insn here and save having to create a fixS
		     for each one.  There already exists code to handle
		     all the various cases (e.g. in md_apply_fix3 and
		     bfd_install_relocation) so duplicating all that code
		     here isn't right.  */
		}

	      continue;

	    case 'a':
	      if (*s++ == 'a')
		{
		  opcode |= ANNUL;
		  continue;
		}
	      break;

	    case 'A':
	      {
		int asi = 0;

		/* Parse an asi.  */
		if (*s == '#')
		  {
		    if (! parse_keyword_arg (sparc_encode_asi, &s, &asi))
		      {
			error_message = _(": invalid ASI name");
			goto error;
		      }
		  }
		else
		  {
		    if (! parse_const_expr_arg (&s, &asi))
		      {
			error_message = _(": invalid ASI expression");
			goto error;
		      }
		    if (asi < 0 || asi > 255)
		      {
			error_message = _(": invalid ASI number");
			goto error;
		      }
		  }
		opcode |= ASI (asi);
		continue;
	      }			/* Alternate space.  */

	    case 'p':
	      if (strncmp (s, "%psr", 4) == 0)
		{
		  s += 4;
		  continue;
		}
	      break;

	    case 'q':		/* Floating point queue.  */
	      if (strncmp (s, "%fq", 3) == 0)
		{
		  s += 3;
		  continue;
		}
	      break;

	    case 'Q':		/* Coprocessor queue.  */
	      if (strncmp (s, "%cq", 3) == 0)
		{
		  s += 3;
		  continue;
		}
	      break;

	    case 'S':
	      if (strcmp (str, "set") == 0
		  || strcmp (str, "setuw") == 0)
		{
		  special_case = SPECIAL_CASE_SET;
		  continue;
		}
	      else if (strcmp (str, "setsw") == 0)
		{
		  special_case = SPECIAL_CASE_SETSW;
		  continue;
		}
	      else if (strcmp (str, "setx") == 0)
		{
		  special_case = SPECIAL_CASE_SETX;
		  continue;
		}
	      else if (strncmp (str, "fdiv", 4) == 0)
		{
		  special_case = SPECIAL_CASE_FDIV;
		  continue;
		}
	      break;

	    case 'o':
	      if (strncmp (s, "%asi", 4) != 0)
		break;
	      s += 4;
	      continue;

	    case 's':
	      if (strncmp (s, "%fprs", 5) != 0)
		break;
	      s += 5;
	      continue;

	    case 'E':
	      if (strncmp (s, "%ccr", 4) != 0)
		break;
	      s += 4;
	      continue;

	    case 't':
	      if (strncmp (s, "%tbr", 4) != 0)
		break;
	      s += 4;
	      continue;

	    case 'w':
	      if (strncmp (s, "%wim", 4) != 0)
		break;
	      s += 4;
	      continue;

	    case 'x':
	      {
		char *push = input_line_pointer;
		expressionS e;

		input_line_pointer = s;
		expression (&e);
		if (e.X_op == O_constant)
		  {
		    int n = e.X_add_number;
		    if (n != e.X_add_number || (n & ~0x1ff) != 0)
		      as_bad (_("OPF immediate operand out of range (0-0x1ff)"));
		    else
		      opcode |= e.X_add_number << 5;
		  }
		else
		  as_bad (_("non-immediate OPF operand, ignored"));
		s = input_line_pointer;
		input_line_pointer = push;
		continue;
	      }

	    case 'y':
	      if (strncmp (s, "%y", 2) != 0)
		break;
	      s += 2;
	      continue;

	    case 'u':
	    case 'U':
	      {
		/* Parse a sparclet cpreg.  */
		int cpreg;
		if (! parse_keyword_arg (sparc_encode_sparclet_cpreg, &s, &cpreg))
		  {
		    error_message = _(": invalid cpreg name");
		    goto error;
		  }
		opcode |= (*args == 'U' ? RS1 (cpreg) : RD (cpreg));
		continue;
	      }

	    default:
	      as_fatal (_("failed sanity check."));
	    }			/* switch on arg code.  */

	  /* Break out of for() loop.  */
	  break;
	}			/* For each arg that we expect.  */

    error:
      if (match == 0)
	{
	  /* Args don't match.  */
	  if (&insn[1] - sparc_opcodes < sparc_num_opcodes
	      && (insn->name == insn[1].name
		  || !strcmp (insn->name, insn[1].name)))
	    {
	      ++insn;
	      s = argsStart;
	      continue;
	    }
	  else
	    {
	      as_bad (_("Illegal operands%s"), error_message);
	      return special_case;
	    }
	}
      else
	{
	  /* We have a match.  Now see if the architecture is OK.  */
	  int needed_arch_mask = insn->architecture;

	  if (v9_arg_p)
	    {
	      needed_arch_mask &=
		~(SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9) - 1);
	      if (! needed_arch_mask)
		needed_arch_mask =
		  SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9);
	    }

	  if (needed_arch_mask
	      & SPARC_OPCODE_SUPPORTED (current_architecture))
	    /* OK.  */
	    ;
	  /* Can we bump up the architecture?  */
	  else if (needed_arch_mask
		   & SPARC_OPCODE_SUPPORTED (max_architecture))
	    {
	      enum sparc_opcode_arch_val needed_architecture =
		sparc_ffs (SPARC_OPCODE_SUPPORTED (max_architecture)
			   & needed_arch_mask);

	      assert (needed_architecture <= SPARC_OPCODE_ARCH_MAX);
	      if (warn_on_bump
		  && needed_architecture > warn_after_architecture)
		{
		  as_warn (_("architecture bumped from \"%s\" to \"%s\" on \"%s\""),
			   sparc_opcode_archs[current_architecture].name,
			   sparc_opcode_archs[needed_architecture].name,
			   str);
		  warn_after_architecture = needed_architecture;
		}
	      current_architecture = needed_architecture;
	    }
	  /* Conflict.  */
	  /* ??? This seems to be a bit fragile.  What if the next entry in
	     the opcode table is the one we want and it is supported?
	     It is possible to arrange the table today so that this can't
	     happen but what about tomorrow?  */
	  else
	    {
	      int arch, printed_one_p = 0;
	      char *p;
	      char required_archs[SPARC_OPCODE_ARCH_MAX * 16];

	      /* Create a list of the architectures that support the insn.  */
	      needed_arch_mask &= ~SPARC_OPCODE_SUPPORTED (max_architecture);
	      p = required_archs;
	      arch = sparc_ffs (needed_arch_mask);
	      while ((1 << arch) <= needed_arch_mask)
		{
		  if ((1 << arch) & needed_arch_mask)
		    {
		      if (printed_one_p)
			*p++ = '|';
		      strcpy (p, sparc_opcode_archs[arch].name);
		      p += strlen (p);
		      printed_one_p = 1;
		    }
		  ++arch;
		}

	      as_bad (_("Architecture mismatch on \"%s\"."), str);
	      as_tsktsk (_(" (Requires %s; requested architecture is %s.)"),
			 required_archs,
			 sparc_opcode_archs[max_architecture].name);
	      return special_case;
	    }
	} /* If no match.  */

      break;
    } /* Forever looking for a match.  */

  the_insn.opcode = opcode;
  return special_case;
}

/* Parse an argument that can be expressed as a keyword.
   (eg: #StoreStore or %ccfr).
   The result is a boolean indicating success.
   If successful, INPUT_POINTER is updated.  */

static int
parse_keyword_arg (lookup_fn, input_pointerP, valueP)
     int (*lookup_fn) PARAMS ((const char *));
     char **input_pointerP;
     int *valueP;
{
  int value;
  char c, *p, *q;

  p = *input_pointerP;
  for (q = p + (*p == '#' || *p == '%');
       ISALNUM (*q) || *q == '_';
       ++q)
    continue;
  c = *q;
  *q = 0;
  value = (*lookup_fn) (p);
  *q = c;
  if (value == -1)
    return 0;
  *valueP = value;
  *input_pointerP = q;
  return 1;
}

/* Parse an argument that is a constant expression.
   The result is a boolean indicating success.  */

static int
parse_const_expr_arg (input_pointerP, valueP)
     char **input_pointerP;
     int *valueP;
{
  char *save = input_line_pointer;
  expressionS exp;

  input_line_pointer = *input_pointerP;
  /* The next expression may be something other than a constant
     (say if we're not processing the right variant of the insn).
     Don't call expression unless we're sure it will succeed as it will
     signal an error (which we want to defer until later).  */
  /* FIXME: It might be better to define md_operand and have it recognize
     things like %asi, etc. but continuing that route through to the end
     is a lot of work.  */
  if (*input_line_pointer == '%')
    {
      input_line_pointer = save;
      return 0;
    }
  expression (&exp);
  *input_pointerP = input_line_pointer;
  input_line_pointer = save;
  if (exp.X_op != O_constant)
    return 0;
  *valueP = exp.X_add_number;
  return 1;
}

/* Subroutine of sparc_ip to parse an expression.  */

static int
get_expression (str)
     char *str;
{
  char *save_in;
  segT seg;

  save_in = input_line_pointer;
  input_line_pointer = str;
  seg = expression (&the_insn.exp);
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      the_insn.error = _("bad segment");
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
}

/* Subroutine of md_assemble to output one insn.  */

static void
output_insn (insn, the_insn)
     const struct sparc_opcode *insn;
     struct sparc_it *the_insn;
{
  char *toP = frag_more (4);

  /* Put out the opcode.  */
  if (INSN_BIG_ENDIAN)
    number_to_chars_bigendian (toP, (valueT) the_insn->opcode, 4);
  else
    number_to_chars_littleendian (toP, (valueT) the_insn->opcode, 4);

  /* Put out the symbol-dependent stuff.  */
  if (the_insn->reloc != BFD_RELOC_NONE)
    {
      fixS *fixP =  fix_new_exp (frag_now,	/* Which frag.  */
				 (toP - frag_now->fr_literal),	/* Where.  */
				 4,		/* Size.  */
				 &the_insn->exp,
				 the_insn->pcrel,
				 the_insn->reloc);
      /* Turn off overflow checking in fixup_segment.  We'll do our
	 own overflow checking in md_apply_fix3.  This is necessary because
	 the insn size is 4 and fixup_segment will signal an overflow for
	 large 8 byte quantities.  */
      fixP->fx_no_overflow = 1;
      if (the_insn->reloc == BFD_RELOC_SPARC_OLO10)
	fixP->tc_fix_data = the_insn->exp2.X_add_number;
    }

  last_insn = insn;
  last_opcode = the_insn->opcode;

#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif
}

/* This is identical to the md_atof in m68k.c.  I think this is right,
   but I'm not sure.

   Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int i, prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i],
			      sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
    }
  else
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litP, (valueT) words[i],
			      sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
    }

  return 0;
}

/* Write a value out to the object file, using the appropriate
   endianness.  */

void
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else if (target_little_endian_data
	   && ((n == 4 || n == 2) && ~now_seg->flags & SEC_ALLOC))
    /* Output debug words, which are not in allocated sections, as big
       endian.  */
    number_to_chars_bigendian (buf, val, n);
  else if (target_little_endian_data || ! target_big_endian)
    number_to_chars_littleendian (buf, val, n);
}

/* Apply a fixS to the frags, now that we know the value it ought to
   hold.  */

void
md_apply_fix3 (fixP, valP, segment)
     fixS *fixP;
     valueT *valP;
     segT segment ATTRIBUTE_UNUSED;
{
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  offsetT val = * (offsetT *) valP;
  long insn;

  assert (fixP->fx_r_type < BFD_RELOC_UNUSED);

  fixP->fx_addnumber = val;	/* Remember value for emit_reloc.  */

#ifdef OBJ_ELF
  /* SPARC ELF relocations don't use an addend in the data field.  */
  if (fixP->fx_addsy != NULL)
    return;
#endif

  /* This is a hack.  There should be a better way to
     handle this.  Probably in terms of howto fields, once
     we can look at these fixups in terms of howtos.  */
  if (fixP->fx_r_type == BFD_RELOC_32_PCREL_S2 && fixP->fx_addsy)
    val += fixP->fx_where + fixP->fx_frag->fr_address;

#ifdef OBJ_AOUT
  /* FIXME: More ridiculous gas reloc hacking.  If we are going to
     generate a reloc, then we just want to let the reloc addend set
     the value.  We do not want to also stuff the addend into the
     object file.  Including the addend in the object file works when
     doing a static link, because the linker will ignore the object
     file contents.  However, the dynamic linker does not ignore the
     object file contents.  */
  if (fixP->fx_addsy != NULL
      && fixP->fx_r_type != BFD_RELOC_32_PCREL_S2)
    val = 0;

  /* When generating PIC code, we do not want an addend for a reloc
     against a local symbol.  We adjust fx_addnumber to cancel out the
     value already included in val, and to also cancel out the
     adjustment which bfd_install_relocation will create.  */
  if (sparc_pic_code
      && fixP->fx_r_type != BFD_RELOC_32_PCREL_S2
      && fixP->fx_addsy != NULL
      && ! S_IS_COMMON (fixP->fx_addsy)
      && symbol_section_p (fixP->fx_addsy))
    fixP->fx_addnumber -= 2 * S_GET_VALUE (fixP->fx_addsy);

  /* When generating PIC code, we need to fiddle to get
     bfd_install_relocation to do the right thing for a PC relative
     reloc against a local symbol which we are going to keep.  */
  if (sparc_pic_code
      && fixP->fx_r_type == BFD_RELOC_32_PCREL_S2
      && fixP->fx_addsy != NULL
      && (S_IS_EXTERNAL (fixP->fx_addsy)
	  || S_IS_WEAK (fixP->fx_addsy))
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! S_IS_COMMON (fixP->fx_addsy))
    {
      val = 0;
      fixP->fx_addnumber -= 2 * S_GET_VALUE (fixP->fx_addsy);
    }
#endif

  /* If this is a data relocation, just output VAL.  */

  if (fixP->fx_r_type == BFD_RELOC_16
      || fixP->fx_r_type == BFD_RELOC_SPARC_UA16)
    {
      md_number_to_chars (buf, val, 2);
    }
  else if (fixP->fx_r_type == BFD_RELOC_32
	   || fixP->fx_r_type == BFD_RELOC_SPARC_UA32
	   || fixP->fx_r_type == BFD_RELOC_SPARC_REV32)
    {
      md_number_to_chars (buf, val, 4);
    }
  else if (fixP->fx_r_type == BFD_RELOC_64
	   || fixP->fx_r_type == BFD_RELOC_SPARC_UA64)
    {
      md_number_to_chars (buf, val, 8);
    }
  else if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
           || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    {
      fixP->fx_done = 0;
      return;
    }
  else
    {
      /* It's a relocation against an instruction.  */

      if (INSN_BIG_ENDIAN)
	insn = bfd_getb32 ((unsigned char *) buf);
      else
	insn = bfd_getl32 ((unsigned char *) buf);

      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_32_PCREL_S2:
	  val = val >> 2;
	  /* FIXME: This increment-by-one deserves a comment of why it's
	     being done!  */
	  if (! sparc_pic_code
	      || fixP->fx_addsy == NULL
	      || symbol_section_p (fixP->fx_addsy))
	    ++val;

	  insn |= val & 0x3fffffff;

	  /* See if we have a delay slot.  */
	  if (sparc_relax && fixP->fx_where + 8 <= fixP->fx_frag->fr_fix)
	    {
#define G0		0
#define O7		15
#define XCC		(2 << 20)
#define COND(x)		(((x)&0xf)<<25)
#define CONDA		COND(0x8)
#define INSN_BPA	(F2(0,1) | CONDA | BPRED | XCC)
#define INSN_BA		(F2(0,2) | CONDA)
#define INSN_OR		F3(2, 0x2, 0)
#define INSN_NOP	F2(0,4)

	      long delay;

	      /* If the instruction is a call with either:
		 restore
		 arithmetic instruction with rd == %o7
		 where rs1 != %o7 and rs2 if it is register != %o7
		 then we can optimize if the call destination is near
		 by changing the call into a branch always.  */
	      if (INSN_BIG_ENDIAN)
		delay = bfd_getb32 ((unsigned char *) buf + 4);
	      else
		delay = bfd_getl32 ((unsigned char *) buf + 4);
	      if ((insn & OP (~0)) != OP (1) || (delay & OP (~0)) != OP (2))
		break;
	      if ((delay & OP3 (~0)) != OP3 (0x3d) /* Restore.  */
		  && ((delay & OP3 (0x28)) != 0 /* Arithmetic.  */
		      || ((delay & RD (~0)) != RD (O7))))
		break;
	      if ((delay & RS1 (~0)) == RS1 (O7)
		  || ((delay & F3I (~0)) == 0
		      && (delay & RS2 (~0)) == RS2 (O7)))
		break;
	      /* Ensure the branch will fit into simm22.  */
	      if ((val & 0x3fe00000)
		  && (val & 0x3fe00000) != 0x3fe00000)
		break;
	      /* Check if the arch is v9 and branch will fit
		 into simm19.  */
	      if (((val & 0x3c0000) == 0
		   || (val & 0x3c0000) == 0x3c0000)
		  && (sparc_arch_size == 64
		      || current_architecture >= SPARC_OPCODE_ARCH_V9))
		/* ba,pt %xcc  */
		insn = INSN_BPA | (val & 0x7ffff);
	      else
		/* ba  */
		insn = INSN_BA | (val & 0x3fffff);
	      if (fixP->fx_where >= 4
		  && ((delay & (0xffffffff ^ RS1 (~0)))
		      == (INSN_OR | RD (O7) | RS2 (G0))))
		{
		  long setter;
		  int reg;

		  if (INSN_BIG_ENDIAN)
		    setter = bfd_getb32 ((unsigned char *) buf - 4);
		  else
		    setter = bfd_getl32 ((unsigned char *) buf - 4);
		  if ((setter & (0xffffffff ^ RD (~0)))
		      != (INSN_OR | RS1 (O7) | RS2 (G0)))
		    break;
		  /* The sequence was
		     or %o7, %g0, %rN
		     call foo
		     or %rN, %g0, %o7

		     If call foo was replaced with ba, replace
		     or %rN, %g0, %o7 with nop.  */
		  reg = (delay & RS1 (~0)) >> 14;
		  if (reg != ((setter & RD (~0)) >> 25)
		      || reg == G0 || reg == O7)
		    break;

		  if (INSN_BIG_ENDIAN)
		    bfd_putb32 (INSN_NOP, (unsigned char *) buf + 4);
		  else
		    bfd_putl32 (INSN_NOP, (unsigned char *) buf + 4);
		}
	    }
	  break;

	case BFD_RELOC_SPARC_11:
	  if (! in_signed_range (val, 0x7ff))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  insn |= val & 0x7ff;
	  break;

	case BFD_RELOC_SPARC_10:
	  if (! in_signed_range (val, 0x3ff))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  insn |= val & 0x3ff;
	  break;

	case BFD_RELOC_SPARC_7:
	  if (! in_bitfield_range (val, 0x7f))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  insn |= val & 0x7f;
	  break;

	case BFD_RELOC_SPARC_6:
	  if (! in_bitfield_range (val, 0x3f))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  insn |= val & 0x3f;
	  break;

	case BFD_RELOC_SPARC_5:
	  if (! in_bitfield_range (val, 0x1f))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  insn |= val & 0x1f;
	  break;

	case BFD_RELOC_SPARC_WDISP16:
	  /* FIXME: simplify.  */
	  if (((val > 0) && (val & ~0x3fffc))
	      || ((val < 0) && (~(val - 1) & ~0x3fffc)))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  /* FIXME: The +1 deserves a comment.  */
	  val = (val >> 2) + 1;
	  insn |= ((val & 0xc000) << 6) | (val & 0x3fff);
	  break;

	case BFD_RELOC_SPARC_WDISP19:
	  /* FIXME: simplify.  */
	  if (((val > 0) && (val & ~0x1ffffc))
	      || ((val < 0) && (~(val - 1) & ~0x1ffffc)))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  /* FIXME: The +1 deserves a comment.  */
	  val = (val >> 2) + 1;
	  insn |= val & 0x7ffff;
	  break;

	case BFD_RELOC_SPARC_HH22:
	  val = BSR (val, 32);
	  /* Fall through.  */

	case BFD_RELOC_SPARC_LM22:
	case BFD_RELOC_HI22:
	  if (!fixP->fx_addsy)
	    insn |= (val >> 10) & 0x3fffff;
	  else
	    /* FIXME: Need comment explaining why we do this.  */
	    insn &= ~0xffff;
	  break;

	case BFD_RELOC_SPARC22:
	  if (val & ~0x003fffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  insn |= (val & 0x3fffff);
	  break;

	case BFD_RELOC_SPARC_HM10:
	  val = BSR (val, 32);
	  /* Fall through.  */

	case BFD_RELOC_LO10:
	  if (!fixP->fx_addsy)
	    insn |= val & 0x3ff;
	  else
	    /* FIXME: Need comment explaining why we do this.  */
	    insn &= ~0xff;
	  break;

	case BFD_RELOC_SPARC_OLO10:
	  val &= 0x3ff;
	  val += fixP->tc_fix_data;
	  /* Fall through.  */

	case BFD_RELOC_SPARC13:
	  if (! in_signed_range (val, 0x1fff))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  insn |= val & 0x1fff;
	  break;

	case BFD_RELOC_SPARC_WDISP22:
	  val = (val >> 2) + 1;
	  /* Fall through.  */
	case BFD_RELOC_SPARC_BASE22:
	  insn |= val & 0x3fffff;
	  break;

	case BFD_RELOC_SPARC_H44:
	  if (!fixP->fx_addsy)
	    {
	      bfd_vma tval = val;
	      tval >>= 22;
	      insn |= tval & 0x3fffff;
	    }
	  break;

	case BFD_RELOC_SPARC_M44:
	  if (!fixP->fx_addsy)
	    insn |= (val >> 12) & 0x3ff;
	  break;

	case BFD_RELOC_SPARC_L44:
	  if (!fixP->fx_addsy)
	    insn |= val & 0xfff;
	  break;

	case BFD_RELOC_SPARC_HIX22:
	  if (!fixP->fx_addsy)
	    {
	      val ^= ~(offsetT) 0;
	      insn |= (val >> 10) & 0x3fffff;
	    }
	  break;

	case BFD_RELOC_SPARC_LOX10:
	  if (!fixP->fx_addsy)
	    insn |= 0x1c00 | (val & 0x3ff);
	  break;

	case BFD_RELOC_NONE:
	default:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("bad or unhandled relocation type: 0x%02x"),
			fixP->fx_r_type);
	  break;
	}

      if (INSN_BIG_ENDIAN)
	bfd_putb32 (insn, (unsigned char *) buf);
      else
	bfd_putl32 (insn, (unsigned char *) buf);
    }

  /* Are we finished with this relocation now?  */
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
    fixP->fx_done = 1;
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent **
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  static arelent *relocs[3];
  arelent *reloc;
  bfd_reloc_code_real_type code;

  relocs[0] = reloc = (arelent *) xmalloc (sizeof (arelent));
  relocs[1] = NULL;

  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_16:
    case BFD_RELOC_32:
    case BFD_RELOC_HI22:
    case BFD_RELOC_LO10:
    case BFD_RELOC_32_PCREL_S2:
    case BFD_RELOC_SPARC13:
    case BFD_RELOC_SPARC22:
    case BFD_RELOC_SPARC_BASE13:
    case BFD_RELOC_SPARC_WDISP16:
    case BFD_RELOC_SPARC_WDISP19:
    case BFD_RELOC_SPARC_WDISP22:
    case BFD_RELOC_64:
    case BFD_RELOC_SPARC_5:
    case BFD_RELOC_SPARC_6:
    case BFD_RELOC_SPARC_7:
    case BFD_RELOC_SPARC_10:
    case BFD_RELOC_SPARC_11:
    case BFD_RELOC_SPARC_HH22:
    case BFD_RELOC_SPARC_HM10:
    case BFD_RELOC_SPARC_LM22:
    case BFD_RELOC_SPARC_PC_HH22:
    case BFD_RELOC_SPARC_PC_HM10:
    case BFD_RELOC_SPARC_PC_LM22:
    case BFD_RELOC_SPARC_H44:
    case BFD_RELOC_SPARC_M44:
    case BFD_RELOC_SPARC_L44:
    case BFD_RELOC_SPARC_HIX22:
    case BFD_RELOC_SPARC_LOX10:
    case BFD_RELOC_SPARC_REV32:
    case BFD_RELOC_SPARC_OLO10:
    case BFD_RELOC_SPARC_UA16:
    case BFD_RELOC_SPARC_UA32:
    case BFD_RELOC_SPARC_UA64:
    case BFD_RELOC_8_PCREL:
    case BFD_RELOC_16_PCREL:
    case BFD_RELOC_32_PCREL:
    case BFD_RELOC_64_PCREL:
    case BFD_RELOC_SPARC_PLT32:
    case BFD_RELOC_SPARC_PLT64:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_SPARC_TLS_GD_HI22:
    case BFD_RELOC_SPARC_TLS_GD_LO10:
    case BFD_RELOC_SPARC_TLS_GD_ADD:
    case BFD_RELOC_SPARC_TLS_GD_CALL:
    case BFD_RELOC_SPARC_TLS_LDM_HI22:
    case BFD_RELOC_SPARC_TLS_LDM_LO10:
    case BFD_RELOC_SPARC_TLS_LDM_ADD:
    case BFD_RELOC_SPARC_TLS_LDM_CALL:
    case BFD_RELOC_SPARC_TLS_LDO_HIX22:
    case BFD_RELOC_SPARC_TLS_LDO_LOX10:
    case BFD_RELOC_SPARC_TLS_LDO_ADD:
    case BFD_RELOC_SPARC_TLS_IE_HI22:
    case BFD_RELOC_SPARC_TLS_IE_LO10:
    case BFD_RELOC_SPARC_TLS_IE_LD:
    case BFD_RELOC_SPARC_TLS_IE_LDX:
    case BFD_RELOC_SPARC_TLS_IE_ADD:
    case BFD_RELOC_SPARC_TLS_LE_HIX22:
    case BFD_RELOC_SPARC_TLS_LE_LOX10:
    case BFD_RELOC_SPARC_TLS_DTPOFF32:
    case BFD_RELOC_SPARC_TLS_DTPOFF64:
      code = fixp->fx_r_type;
      break;
    default:
      abort ();
      return NULL;
    }

#if defined (OBJ_ELF) || defined (OBJ_AOUT)
  /* If we are generating PIC code, we need to generate a different
     set of relocs.  */

#ifdef OBJ_ELF
#define GOT_NAME "_GLOBAL_OFFSET_TABLE_"
#else
#define GOT_NAME "__GLOBAL_OFFSET_TABLE_"
#endif

  /* This code must be parallel to the OBJ_ELF tc_fix_adjustable.  */

  if (sparc_pic_code)
    {
      switch (code)
	{
	case BFD_RELOC_32_PCREL_S2:
	  if (generic_force_reloc (fixp))
	    code = BFD_RELOC_SPARC_WPLT30;
	  break;
	case BFD_RELOC_HI22:
	  if (fixp->fx_addsy != NULL
	      && strcmp (S_GET_NAME (fixp->fx_addsy), GOT_NAME) == 0)
	    code = BFD_RELOC_SPARC_PC22;
	  else
	    code = BFD_RELOC_SPARC_GOT22;
	  break;
	case BFD_RELOC_LO10:
	  if (fixp->fx_addsy != NULL
	      && strcmp (S_GET_NAME (fixp->fx_addsy), GOT_NAME) == 0)
	    code = BFD_RELOC_SPARC_PC10;
	  else
	    code = BFD_RELOC_SPARC_GOT10;
	  break;
	case BFD_RELOC_SPARC13:
	  code = BFD_RELOC_SPARC_GOT13;
	  break;
	default:
	  break;
	}
    }
#endif /* defined (OBJ_ELF) || defined (OBJ_AOUT)  */

  if (code == BFD_RELOC_SPARC_OLO10)
    reloc->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_LO10);
  else
    reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (reloc->howto == 0)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal error: can't export reloc type %d (`%s')"),
		    fixp->fx_r_type, bfd_get_reloc_code_name (code));
      xfree (reloc);
      relocs[0] = NULL;
      return relocs;
    }

  /* @@@@ Why fx_addnumber sometimes and fx_offset other times?  */
#ifdef OBJ_AOUT

  if (reloc->howto->pc_relative == 0
      || code == BFD_RELOC_SPARC_PC10
      || code == BFD_RELOC_SPARC_PC22)
    reloc->addend = fixp->fx_addnumber;
  else if (sparc_pic_code
	   && fixp->fx_r_type == BFD_RELOC_32_PCREL_S2
	   && fixp->fx_addsy != NULL
	   && (S_IS_EXTERNAL (fixp->fx_addsy)
	       || S_IS_WEAK (fixp->fx_addsy))
	   && S_IS_DEFINED (fixp->fx_addsy)
	   && ! S_IS_COMMON (fixp->fx_addsy))
    reloc->addend = fixp->fx_addnumber;
  else
    reloc->addend = fixp->fx_offset - reloc->address;

#else /* elf or coff  */

  if (code != BFD_RELOC_32_PCREL_S2
      && code != BFD_RELOC_SPARC_WDISP22
      && code != BFD_RELOC_SPARC_WDISP16
      && code != BFD_RELOC_SPARC_WDISP19
      && code != BFD_RELOC_SPARC_WPLT30
      && code != BFD_RELOC_SPARC_TLS_GD_CALL
      && code != BFD_RELOC_SPARC_TLS_LDM_CALL)
    reloc->addend = fixp->fx_addnumber;
  else if (symbol_section_p (fixp->fx_addsy))
    reloc->addend = (section->vma
		     + fixp->fx_addnumber
		     + md_pcrel_from (fixp));
  else
    reloc->addend = fixp->fx_offset;
#endif

  /* We expand R_SPARC_OLO10 to R_SPARC_LO10 and R_SPARC_13
     on the same location.  */
  if (code == BFD_RELOC_SPARC_OLO10)
    {
      relocs[1] = reloc = (arelent *) xmalloc (sizeof (arelent));
      relocs[2] = NULL;

      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr
	= symbol_get_bfdsym (section_symbol (absolute_section));
      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
      reloc->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_SPARC13);
      reloc->addend = fixp->tc_fix_data;
    }

  return relocs;
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
{
#ifndef OBJ_ELF
  /* This is not right for ELF; a.out wants it, and COFF will force
     the alignment anyways.  */
  valueT align = ((valueT) 1
		  << (valueT) bfd_get_section_alignment (stdoutput, segment));
  valueT newsize;

  /* Turn alignment value into a mask.  */
  align--;
  newsize = (size + align) & ~align;
  return newsize;
#else
  return size;
#endif
}

/* Exactly what point is a PC-relative offset relative TO?
   On the sparc, they're relative to the address of the offset, plus
   its size.  This gets us to the following instruction.
   (??? Is this right?  FIXME-SOON)  */
long
md_pcrel_from (fixP)
     fixS *fixP;
{
  long ret;

  ret = fixP->fx_where + fixP->fx_frag->fr_address;
  if (! sparc_pic_code
      || fixP->fx_addsy == NULL
      || symbol_section_p (fixP->fx_addsy))
    ret += fixP->fx_size;
  return ret;
}

/* Return log2 (VALUE), or -1 if VALUE is not an exact positive power
   of two.  */

static int
log2 (value)
     int value;
{
  int shift;

  if (value <= 0)
    return -1;

  for (shift = 0; (value & 1) == 0; value >>= 1)
    ++shift;

  return (value == 1) ? shift : -1;
}

/* Sort of like s_lcomm.  */

#ifndef OBJ_ELF
static int max_alignment = 15;
#endif

static void
s_reserve (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char *p;
  char c;
  int align;
  int size;
  int temp;
  symbolS *symbolP;

  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after name"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;

  if ((size = get_absolute_expression ()) < 0)
    {
      as_bad (_("BSS length (%d.) <0! Ignored."), size);
      ignore_rest_of_line ();
      return;
    }				/* Bad length.  */

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (strncmp (input_line_pointer, ",\"bss\"", 6) != 0
      && strncmp (input_line_pointer, ",\".bss\"", 7) != 0)
    {
      as_bad (_("bad .reserve segment -- expected BSS segment"));
      return;
    }

  if (input_line_pointer[2] == '.')
    input_line_pointer += 7;
  else
    input_line_pointer += 6;
  SKIP_WHITESPACE ();

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;

      SKIP_WHITESPACE ();
      if (*input_line_pointer == '\n')
	{
	  as_bad (_("missing alignment"));
	  ignore_rest_of_line ();
	  return;
	}

      align = (int) get_absolute_expression ();

#ifndef OBJ_ELF
      if (align > max_alignment)
	{
	  align = max_alignment;
	  as_warn (_("alignment too large; assuming %d"), align);
	}
#endif

      if (align < 0)
	{
	  as_bad (_("negative alignment"));
	  ignore_rest_of_line ();
	  return;
	}

      if (align != 0)
	{
	  temp = log2 (align);
	  if (temp < 0)
	    {
	      as_bad (_("alignment not a power of 2"));
	      ignore_rest_of_line ();
	      return;
	    }

	  align = temp;
	}

      record_alignment (bss_section, align);
    }
  else
    align = 0;

  if (!S_IS_DEFINED (symbolP)
#ifdef OBJ_AOUT
      && S_GET_OTHER (symbolP) == 0
      && S_GET_DESC (symbolP) == 0
#endif
      )
    {
      if (! need_pass_2)
	{
	  char *pfrag;
	  segT current_seg = now_seg;
	  subsegT current_subseg = now_subseg;

	  /* Switch to bss.  */
	  subseg_set (bss_section, 1);

	  if (align)
	    /* Do alignment.  */
	    frag_align (align, 0, 0);

	  /* Detach from old frag.  */
	  if (S_GET_SEGMENT (symbolP) == bss_section)
	    symbol_get_frag (symbolP)->fr_symbol = NULL;

	  symbol_set_frag (symbolP, frag_now);
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			    (offsetT) size, (char *) 0);
	  *pfrag = 0;

	  S_SET_SEGMENT (symbolP, bss_section);

	  subseg_set (current_seg, current_subseg);

#ifdef OBJ_ELF
	  S_SET_SIZE (symbolP, size);
#endif
	}
    }
  else
    {
      as_warn ("Ignoring attempt to re-define symbol %s",
	       S_GET_NAME (symbolP));
    }				/* if not redefining.  */

  demand_empty_rest_of_line ();
}

static void
s_common (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char c;
  char *p;
  offsetT temp, size;
  symbolS *symbolP;

  name = input_line_pointer;
  c = get_symbol_end ();
  /* Just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after symbol-name"));
      ignore_rest_of_line ();
      return;
    }

  /* Skip ','.  */
  input_line_pointer++;

  if ((temp = get_absolute_expression ()) < 0)
    {
      as_bad (_(".COMMon length (%lu) out of range ignored"),
	      (unsigned long) temp);
      ignore_rest_of_line ();
      return;
    }
  size = temp;
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
    }
  if (S_GET_VALUE (symbolP) != 0)
    {
      if (S_GET_VALUE (symbolP) != (valueT) size)
	{
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), (long) size);
	}
    }
  else
    {
#ifndef OBJ_ELF
      S_SET_VALUE (symbolP, (valueT) size);
      S_SET_EXTERNAL (symbolP);
#endif
    }
  know (symbol_get_frag (symbolP) == &zero_address_frag);
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after common length"));
      ignore_rest_of_line ();
      return;
    }
  input_line_pointer++;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != '"')
    {
      temp = get_absolute_expression ();

#ifndef OBJ_ELF
      if (temp > max_alignment)
	{
	  temp = max_alignment;
	  as_warn (_("alignment too large; assuming %d"), temp);
	}
#endif

      if (temp < 0)
	{
	  as_bad (_("negative alignment"));
	  ignore_rest_of_line ();
	  return;
	}

#ifdef OBJ_ELF
      if (symbol_get_obj (symbolP)->local)
	{
	  segT old_sec;
	  int old_subsec;
	  char *p;
	  int align;

	  old_sec = now_seg;
	  old_subsec = now_subseg;

	  if (temp == 0)
	    align = 0;
	  else
	    align = log2 (temp);

	  if (align < 0)
	    {
	      as_bad (_("alignment not a power of 2"));
	      ignore_rest_of_line ();
	      return;
	    }

	  record_alignment (bss_section, align);
	  subseg_set (bss_section, 0);
	  if (align)
	    frag_align (align, 0, 0);
	  if (S_GET_SEGMENT (symbolP) == bss_section)
	    symbol_get_frag (symbolP)->fr_symbol = 0;
	  symbol_set_frag (symbolP, frag_now);
	  p = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			(offsetT) size, (char *) 0);
	  *p = 0;
	  S_SET_SEGMENT (symbolP, bss_section);
	  S_CLEAR_EXTERNAL (symbolP);
	  S_SET_SIZE (symbolP, size);
	  subseg_set (old_sec, old_subsec);
	}
      else
#endif /* OBJ_ELF  */
	{
	allocate_common:
	  S_SET_VALUE (symbolP, (valueT) size);
#ifdef OBJ_ELF
	  S_SET_ALIGN (symbolP, temp);
	  S_SET_SIZE (symbolP, size);
#endif
	  S_SET_EXTERNAL (symbolP);
	  S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
	}
    }
  else
    {
      input_line_pointer++;
      /* @@@@ Some use the dot, some don't.  Can we get some consistency??  */
      if (*input_line_pointer == '.')
	input_line_pointer++;
      /* @@@@ Some say data, some say bss.  */
      if (strncmp (input_line_pointer, "bss\"", 4)
	  && strncmp (input_line_pointer, "data\"", 5))
	{
	  while (*--input_line_pointer != '"')
	    ;
	  input_line_pointer--;
	  goto bad_common_segment;
	}
      while (*input_line_pointer++ != '"')
	;
      goto allocate_common;
    }

#ifdef BFD_ASSEMBLER
  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
#endif

  demand_empty_rest_of_line ();
  return;

  {
  bad_common_segment:
    p = input_line_pointer;
    while (*p && *p != '\n')
      p++;
    c = *p;
    *p = '\0';
    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
    *p = c;
    input_line_pointer = p;
    ignore_rest_of_line ();
    return;
  }
}

/* Handle the .empty pseudo-op.  This suppresses the warnings about
   invalid delay slot usage.  */

static void
s_empty (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* The easy way to implement is to just forget about the last
     instruction.  */
  last_insn = NULL;
}

static void
s_seg (ignore)
     int ignore ATTRIBUTE_UNUSED;
{

  if (strncmp (input_line_pointer, "\"text\"", 6) == 0)
    {
      input_line_pointer += 6;
      s_text (0);
      return;
    }
  if (strncmp (input_line_pointer, "\"data\"", 6) == 0)
    {
      input_line_pointer += 6;
      s_data (0);
      return;
    }
  if (strncmp (input_line_pointer, "\"data1\"", 7) == 0)
    {
      input_line_pointer += 7;
      s_data1 ();
      return;
    }
  if (strncmp (input_line_pointer, "\"bss\"", 5) == 0)
    {
      input_line_pointer += 5;
      /* We only support 2 segments -- text and data -- for now, so
	 things in the "bss segment" will have to go into data for now.
	 You can still allocate SEG_BSS stuff with .lcomm or .reserve.  */
      subseg_set (data_section, 255);	/* FIXME-SOMEDAY.  */
      return;
    }
  as_bad (_("Unknown segment type"));
  demand_empty_rest_of_line ();
}

static void
s_data1 ()
{
  subseg_set (data_section, 1);
  demand_empty_rest_of_line ();
}

static void
s_proc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      ++input_line_pointer;
    }
  ++input_line_pointer;
}

/* This static variable is set by s_uacons to tell sparc_cons_align
   that the expression does not need to be aligned.  */

static int sparc_no_align_cons = 0;

/* This static variable is set by sparc_cons to emit requested types
   of relocations in cons_fix_new_sparc.  */

static const char *sparc_cons_special_reloc;

/* This handles the unaligned space allocation pseudo-ops, such as
   .uaword.  .uaword is just like .word, but the value does not need
   to be aligned.  */

static void
s_uacons (bytes)
     int bytes;
{
  /* Tell sparc_cons_align not to align this value.  */
  sparc_no_align_cons = 1;
  cons (bytes);
  sparc_no_align_cons = 0;
}

/* This handles the native word allocation pseudo-op .nword.
   For sparc_arch_size 32 it is equivalent to .word,  for
   sparc_arch_size 64 it is equivalent to .xword.  */

static void
s_ncons (bytes)
     int bytes ATTRIBUTE_UNUSED;
{
  cons (sparc_arch_size == 32 ? 4 : 8);
}

#ifdef OBJ_ELF
/* Handle the SPARC ELF .register pseudo-op.  This sets the binding of a
   global register.
   The syntax is:

   .register %g[2367],{#scratch|symbolname|#ignore}
*/

static void
s_register (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char c;
  int reg;
  int flags;
  const char *regname;

  if (input_line_pointer[0] != '%'
      || input_line_pointer[1] != 'g'
      || ((input_line_pointer[2] & ~1) != '2'
	  && (input_line_pointer[2] & ~1) != '6')
      || input_line_pointer[3] != ',')
    as_bad (_("register syntax is .register %%g[2367],{#scratch|symbolname|#ignore}"));
  reg = input_line_pointer[2] - '0';
  input_line_pointer += 4;

  if (*input_line_pointer == '#')
    {
      ++input_line_pointer;
      regname = input_line_pointer;
      c = get_symbol_end ();
      if (strcmp (regname, "scratch") && strcmp (regname, "ignore"))
	as_bad (_("register syntax is .register %%g[2367],{#scratch|symbolname|#ignore}"));
      if (regname[0] == 'i')
	regname = NULL;
      else
	regname = "";
    }
  else
    {
      regname = input_line_pointer;
      c = get_symbol_end ();
    }
  if (sparc_arch_size == 64)
    {
      if (globals[reg])
	{
	  if ((regname && globals[reg] != (symbolS *) 1
	       && strcmp (S_GET_NAME (globals[reg]), regname))
	      || ((regname != NULL) ^ (globals[reg] != (symbolS *) 1)))
	    as_bad (_("redefinition of global register"));
	}
      else
	{
	  if (regname == NULL)
	    globals[reg] = (symbolS *) 1;
	  else
	    {
	      if (*regname)
		{
		  if (symbol_find (regname))
		    as_bad (_("Register symbol %s already defined."),
			    regname);
		}
	      globals[reg] = symbol_make (regname);
	      flags = symbol_get_bfdsym (globals[reg])->flags;
	      if (! *regname)
		flags = flags & ~(BSF_GLOBAL|BSF_LOCAL|BSF_WEAK);
	      if (! (flags & (BSF_GLOBAL|BSF_LOCAL|BSF_WEAK)))
		flags |= BSF_GLOBAL;
	      symbol_get_bfdsym (globals[reg])->flags = flags;
	      S_SET_VALUE (globals[reg], (valueT) reg);
	      S_SET_ALIGN (globals[reg], reg);
	      S_SET_SIZE (globals[reg], 0);
	      /* Although we actually want undefined_section here,
		 we have to use absolute_section, because otherwise
		 generic as code will make it a COM section.
		 We fix this up in sparc_adjust_symtab.  */
	      S_SET_SEGMENT (globals[reg], absolute_section);
	      S_SET_OTHER (globals[reg], 0);
	      elf_symbol (symbol_get_bfdsym (globals[reg]))
		->internal_elf_sym.st_info =
		  ELF_ST_INFO(STB_GLOBAL, STT_REGISTER);
	      elf_symbol (symbol_get_bfdsym (globals[reg]))
		->internal_elf_sym.st_shndx = SHN_UNDEF;
	    }
	}
    }

  *input_line_pointer = c;

  demand_empty_rest_of_line ();
}

/* Adjust the symbol table.  We set undefined sections for STT_REGISTER
   symbols which need it.  */

void
sparc_adjust_symtab ()
{
  symbolS *sym;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ELF_ST_TYPE (elf_symbol (symbol_get_bfdsym (sym))
		       ->internal_elf_sym.st_info) != STT_REGISTER)
	continue;

      if (ELF_ST_TYPE (elf_symbol (symbol_get_bfdsym (sym))
		       ->internal_elf_sym.st_shndx != SHN_UNDEF))
	continue;

      S_SET_SEGMENT (sym, undefined_section);
    }
}
#endif

/* If the --enforce-aligned-data option is used, we require .word,
   et. al., to be aligned correctly.  We do it by setting up an
   rs_align_code frag, and checking in HANDLE_ALIGN to make sure that
   no unexpected alignment was introduced.

   The SunOS and Solaris native assemblers enforce aligned data by
   default.  We don't want to do that, because gcc can deliberately
   generate misaligned data if the packed attribute is used.  Instead,
   we permit misaligned data by default, and permit the user to set an
   option to check for it.  */

void
sparc_cons_align (nbytes)
     int nbytes;
{
  int nalign;
  char *p;

  /* Only do this if we are enforcing aligned data.  */
  if (! enforce_aligned_data)
    return;

  /* Don't align if this is an unaligned pseudo-op.  */
  if (sparc_no_align_cons)
    return;

  nalign = log2 (nbytes);
  if (nalign == 0)
    return;

  assert (nalign > 0);

  if (now_seg == absolute_section)
    {
      if ((abs_section_offset & ((1 << nalign) - 1)) != 0)
	as_bad (_("misaligned data"));
      return;
    }

  p = frag_var (rs_align_test, 1, 1, (relax_substateT) 0,
		(symbolS *) NULL, (offsetT) nalign, (char *) NULL);

  record_alignment (now_seg, nalign);
}

/* This is called from HANDLE_ALIGN in tc-sparc.h.  */

void
sparc_handle_align (fragp)
     fragS *fragp;
{
  int count, fix;
  char *p;

  count = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;

  switch (fragp->fr_type)
    {
    case rs_align_test:
      if (count != 0)
	as_bad_where (fragp->fr_file, fragp->fr_line, _("misaligned data"));
      break;

    case rs_align_code:
      p = fragp->fr_literal + fragp->fr_fix;
      fix = 0;

      if (count & 3)
	{
	  fix = count & 3;
	  memset (p, 0, fix);
	  p += fix;
	  count -= fix;
	}

      if (SPARC_OPCODE_ARCH_V9_P (max_architecture) && count > 8)
	{
	  unsigned wval = (0x30680000 | count >> 2); /* ba,a,pt %xcc, 1f  */
	  if (INSN_BIG_ENDIAN)
	    number_to_chars_bigendian (p, wval, 4);
	  else
	    number_to_chars_littleendian (p, wval, 4);
	  p += 4;
	  count -= 4;
	  fix += 4;
	}

      if (INSN_BIG_ENDIAN)
	number_to_chars_bigendian (p, 0x01000000, 4);
      else
	number_to_chars_littleendian (p, 0x01000000, 4);

      fragp->fr_fix += fix;
      fragp->fr_var = 4;
      break;

    default:
      break;
    }
}

#ifdef OBJ_ELF
/* Some special processing for a Sparc ELF file.  */

void
sparc_elf_final_processing ()
{
  /* Set the Sparc ELF flag bits.  FIXME: There should probably be some
     sort of BFD interface for this.  */
  if (sparc_arch_size == 64)
    {
      switch (sparc_memory_model)
	{
	case MM_RMO:
	  elf_elfheader (stdoutput)->e_flags |= EF_SPARCV9_RMO;
	  break;
	case MM_PSO:
	  elf_elfheader (stdoutput)->e_flags |= EF_SPARCV9_PSO;
	  break;
	default:
	  break;
	}
    }
  else if (current_architecture >= SPARC_OPCODE_ARCH_V9)
    elf_elfheader (stdoutput)->e_flags |= EF_SPARC_32PLUS;
  if (current_architecture == SPARC_OPCODE_ARCH_V9A)
    elf_elfheader (stdoutput)->e_flags |= EF_SPARC_SUN_US1;
  else if (current_architecture == SPARC_OPCODE_ARCH_V9B)
    elf_elfheader (stdoutput)->e_flags |= EF_SPARC_SUN_US1|EF_SPARC_SUN_US3;
}

void
sparc_cons (exp, size)
     expressionS *exp;
     int size;
{
  char *save;

  SKIP_WHITESPACE ();
  sparc_cons_special_reloc = NULL;
  save = input_line_pointer;
  if (input_line_pointer[0] == '%'
      && input_line_pointer[1] == 'r'
      && input_line_pointer[2] == '_')
    {
      if (strncmp (input_line_pointer + 3, "disp", 4) == 0)
	{
	  input_line_pointer += 7;
	  sparc_cons_special_reloc = "disp";
	}
      else if (strncmp (input_line_pointer + 3, "plt", 3) == 0)
	{
	  if (size != 4 && size != 8)
	    as_bad (_("Illegal operands: %%r_plt in %d-byte data field"), size);
	  else
	    {
	      input_line_pointer += 6;
	      sparc_cons_special_reloc = "plt";
	    }
	}
      else if (strncmp (input_line_pointer + 3, "tls_dtpoff", 10) == 0)
	{
	  if (size != 4 && size != 8)
	    as_bad (_("Illegal operands: %%r_tls_dtpoff in %d-byte data field"), size);
	  else
	    {
	      input_line_pointer += 13;
	      sparc_cons_special_reloc = "tls_dtpoff";
	    }
	}
      if (sparc_cons_special_reloc)
	{
	  int bad = 0;

	  switch (size)
	    {
	    case 1:
	      if (*input_line_pointer != '8')
		bad = 1;
	      input_line_pointer--;
	      break;
	    case 2:
	      if (input_line_pointer[0] != '1' || input_line_pointer[1] != '6')
		bad = 1;
	      break;
	    case 4:
	      if (input_line_pointer[0] != '3' || input_line_pointer[1] != '2')
		bad = 1;
	      break;
	    case 8:
	      if (input_line_pointer[0] != '6' || input_line_pointer[1] != '4')
		bad = 1;
	      break;
	    default:
	      bad = 1;
	      break;
	    }

	  if (bad)
	    {
	      as_bad (_("Illegal operands: Only %%r_%s%d allowed in %d-byte data fields"),
		      sparc_cons_special_reloc, size * 8, size);
	    }
	  else
	    {
	      input_line_pointer += 2;
	      if (*input_line_pointer != '(')
		{
		  as_bad (_("Illegal operands: %%r_%s%d requires arguments in ()"),
			  sparc_cons_special_reloc, size * 8);
		  bad = 1;
		}
	    }

	  if (bad)
	    {
	      input_line_pointer = save;
	      sparc_cons_special_reloc = NULL;
	    }
	  else
	    {
	      int c;
	      char *end = ++input_line_pointer;
	      int npar = 0;

	      while (! is_end_of_line[(c = *end)])
		{
		  if (c == '(')
	  	    npar++;
		  else if (c == ')')
	  	    {
		      if (!npar)
	      		break;
		      npar--;
		    }
	    	  end++;
		}

	      if (c != ')')
		as_bad (_("Illegal operands: %%r_%s%d requires arguments in ()"),
			sparc_cons_special_reloc, size * 8);
	      else
		{
		  *end = '\0';
		  expression (exp);
		  *end = c;
		  if (input_line_pointer != end)
		    {
		      as_bad (_("Illegal operands: %%r_%s%d requires arguments in ()"),
			      sparc_cons_special_reloc, size * 8);
		    }
		  else
		    {
		      input_line_pointer++;
		      SKIP_WHITESPACE ();
		      c = *input_line_pointer;
		      if (! is_end_of_line[c] && c != ',')
			as_bad (_("Illegal operands: garbage after %%r_%s%d()"),
			        sparc_cons_special_reloc, size * 8);
		    }
		}
	    }
	}
    }
  if (sparc_cons_special_reloc == NULL)
    expression (exp);
}

#endif

/* This is called by emit_expr via TC_CONS_FIX_NEW when creating a
   reloc for a cons.  We could use the definition there, except that
   we want to handle little endian relocs specially.  */

void
cons_fix_new_sparc (frag, where, nbytes, exp)
     fragS *frag;
     int where;
     unsigned int nbytes;
     expressionS *exp;
{
  bfd_reloc_code_real_type r;

  r = (nbytes == 1 ? BFD_RELOC_8 :
       (nbytes == 2 ? BFD_RELOC_16 :
	(nbytes == 4 ? BFD_RELOC_32 : BFD_RELOC_64)));

  if (target_little_endian_data
      && nbytes == 4
      && now_seg->flags & SEC_ALLOC)
    r = BFD_RELOC_SPARC_REV32;

  if (sparc_cons_special_reloc)
    {
      if (*sparc_cons_special_reloc == 'd')
	switch (nbytes)
	  {
	  case 1: r = BFD_RELOC_8_PCREL; break;
	  case 2: r = BFD_RELOC_16_PCREL; break;
	  case 4: r = BFD_RELOC_32_PCREL; break;
	  case 8: r = BFD_RELOC_64_PCREL; break;
	  default: abort ();
	  }
      else if (*sparc_cons_special_reloc == 'p')
	switch (nbytes)
	  {
	  case 4: r = BFD_RELOC_SPARC_PLT32; break;
	  case 8: r = BFD_RELOC_SPARC_PLT64; break;
	  }
      else
	switch (nbytes)
	  {
	  case 4: r = BFD_RELOC_SPARC_TLS_DTPOFF32; break;
	  case 8: r = BFD_RELOC_SPARC_TLS_DTPOFF64; break;
	  }
    }
  else if (sparc_no_align_cons)
    {
      switch (nbytes)
	{
	case 2: r = BFD_RELOC_SPARC_UA16; break;
	case 4: r = BFD_RELOC_SPARC_UA32; break;
	case 8: r = BFD_RELOC_SPARC_UA64; break;
	default: abort ();
	}
   }

  fix_new_exp (frag, where, (int) nbytes, exp, 0, r);
  sparc_cons_special_reloc = NULL;
}

void
sparc_cfi_frame_initial_instructions ()
{
  cfi_add_CFA_def_cfa (14, sparc_arch_size == 64 ? 0x7ff : 0);
}

int
sparc_regname_to_dw2regnum (const char *regname)
{
  char *p, *q;

  if (!regname[0])
    return -1;

  q = "goli";
  p = strchr (q, regname[0]);
  if (p)
    {
      if (regname[1] < '0' || regname[1] > '8' || regname[2])
	return -1;
      return (p - q) * 8 + regname[1] - '0';
    }
  if (regname[0] == 's' && regname[1] == 'p' && !regname[2])
    return 14;
  if (regname[0] == 'f' && regname[1] == 'p' && !regname[2])
    return 30;
  if (regname[0] == 'f' || regname[0] == 'r')
    {
      unsigned int regnum;

      regnum = strtoul (regname + 1, &q, 10);
      if (p == q || *q)
        return -1;
      if (regnum >= ((regname[0] == 'f'
		      && SPARC_OPCODE_ARCH_V9_P (max_architecture))
		     ? 64 : 32))
	return -1;
      if (regname[0] == 'f')
	{
          regnum += 32;
          if (regnum >= 64 && (regnum & 1))
	    return -1;
        }
      return regnum;
    }
  return -1;
}

void
sparc_cfi_emit_pcrel_expr (expressionS *exp, unsigned int nbytes)
{
  sparc_cons_special_reloc = "disp";
  sparc_no_align_cons = 1;
  emit_expr (exp, nbytes);
  sparc_no_align_cons = 0;
  sparc_cons_special_reloc = NULL;
}
@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d756 1
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003
d29 1
d120 3
a167 2
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
d730 1
a730 1
/* sparc64 priviledged registers.  */
d805 1
d2149 8
d3780 1
a3780 1
  int temp, size;
d3801 2
a3802 1
      as_bad (_(".COMMon length (%d.) <0! Ignored."), temp);
d3820 2
a3821 2
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
d3952 1
a3952 1
/* Handle the .empty pseudo-op.  This supresses the warnings about
d4019 1
a4019 1
   that the expession does not need to be aligned.  */
d4498 59
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   1999, 2000, 2001
a22 1
#include <ctype.h>
d25 1
d35 6
d141 1
d143 1
d164 1
a164 1
  {"file", dwarf2_directive_file, 0},
d310 1
a310 1
#ifdef TE_NetBSD
d400 1
a400 1
CONST char *md_shortopts = "A:K:VQ:sq";
d403 1
a403 1
CONST char *md_shortopts = "A:k";
d405 1
a405 1
CONST char *md_shortopts = "A:";
d643 1
a643 1
      if (column + strlen(arch->name) > 70)
d648 1
a648 1
      column += 5 + 2 + strlen(arch->name);
d656 1
a656 1
      if (column + strlen(arch->name) > 65)
d661 1
a661 1
      column += 5 + 7 + strlen(arch->name);
d927 1
a927 1
      val = ((val & 0xffffffff) ^ sign) - sign;
d1030 1
a1030 1
		  || the_insn.exp.X_add_number > (offsetT) 0xffffffff))
d1036 2
a1037 2
	      && (the_insn.exp.X_add_number < -(offsetT) 0x80000000
		  || the_insn.exp.X_add_number > (offsetT) 0xffffffff))
d1096 2
a1097 2
      && (the_insn.exp.X_add_number < -(offsetT) 0x80000000
	  || the_insn.exp.X_add_number > (offsetT) 0xffffffff))
d1139 1
a1139 1
#define SIGNEXT32(x) ((((x) & 0xffffffff) ^ 0x80000000) - 0x80000000)
d1396 1
a1396 1
  if (islower ((unsigned char) *s))
d1400 1
a1400 1
      while (islower ((unsigned char) *s) || isdigit ((unsigned char) *s));
d1628 1
a1628 1
		  if (isdigit ((unsigned char) *s))
d1632 1
a1632 1
		      while (isdigit ((unsigned char) *s))
d1809 1
a1809 1
	      if (*s == '\0')
d1811 77
a1887 1
		  match = 1;
d1889 2
d1914 1
a1914 1
	      if (isdigit ((unsigned char) *s++))
d1916 1
a1916 1
		  while (isdigit ((unsigned char) *s))
d1935 1
a1935 1
	      if (*s++ == '%' && *s++ == 'c' && isdigit ((unsigned char) *s))
d1938 1
a1938 1
		  if (isdigit ((unsigned char) *s))
d2031 1
a2031 1
		      if (!isdigit ((unsigned char) (c = *s++)))
d2046 1
a2046 1
		      if (isdigit ((unsigned char) *s))
d2111 1
a2111 1
		    && isdigit ((unsigned char) *++s))
d2113 1
a2113 1
		    for (mask = 0; isdigit ((unsigned char) *s); ++s)
d2257 12
d2341 1
a2341 1
		if (s1 != s && isdigit ((unsigned char) s1[-1]))
d2471 7
d2771 1
a2771 1
       isalnum ((unsigned char) *q) || *q == '_';
d2989 2
a2990 2
int
md_apply_fix3 (fixP, value, segment)
d2992 2
a2993 2
     valueT *value;
     segT segment;
d2996 1
a2996 1
  offsetT val;
a2998 2
  val = *value;

d3004 1
a3004 5
  /* FIXME: SPARC ELF relocations don't use an addend in the data
     field itself.  This whole approach should be somehow combined
     with the calls to bfd_install_relocation.  Also, the value passed
     in by fixup_segment includes the value of a defined symbol.  We
     don't want to include the value of an externally visible symbol.  */
d3006 1
a3006 18
    {
      if (symbol_used_in_reloc_p (fixP->fx_addsy)
	  && (S_IS_EXTERNAL (fixP->fx_addsy)
	      || S_IS_WEAK (fixP->fx_addsy)
	      || (sparc_pic_code && ! fixP->fx_pcrel)
	      || (S_GET_SEGMENT (fixP->fx_addsy) != segment
		  && ((bfd_get_section_flags (stdoutput,
					      S_GET_SEGMENT (fixP->fx_addsy))
		       & SEC_LINK_ONCE) != 0
		      || strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
				  ".gnu.linkonce",
				  sizeof ".gnu.linkonce" - 1) == 0)))
	  && S_GET_SEGMENT (fixP->fx_addsy) != absolute_section
	  && S_GET_SEGMENT (fixP->fx_addsy) != undefined_section
	  && ! bfd_is_com_section (S_GET_SEGMENT (fixP->fx_addsy)))
	fixP->fx_addnumber -= S_GET_VALUE (fixP->fx_addsy);
      return 1;
    }
d3076 1
a3076 1
      return 1;
d3248 1
a3248 3
	    {
	      insn |= (val >> 10) & 0x3fffff;
	    }
d3250 2
a3251 4
	    {
	      /* FIXME: Need comment explaining why we do this.  */
	      insn &= ~0xffff;
	    }
d3267 1
a3267 3
	    {
	      insn |= val & 0x3ff;
	    }
d3269 2
a3270 4
	    {
	      /* FIXME: Need comment explaining why we do this.  */
	      insn &= ~0xff;
	    }
a3340 2

  return 1;
d3348 1
a3348 1
     asection *section;
d3397 6
d3405 20
d3449 1
a3449 4
	  if (! S_IS_DEFINED (fixp->fx_addsy)
	      || S_IS_COMMON (fixp->fx_addsy)
	      || S_IS_EXTERNAL (fixp->fx_addsy)
	      || S_IS_WEAK (fixp->fx_addsy))
d3509 7
a3515 3
  if (reloc->howto->pc_relative == 0
      || code == BFD_RELOC_SPARC_PC10
      || code == BFD_RELOC_SPARC_PC22)
d4011 5
d4027 1
d4288 138
d4450 25
a4474 1
  if (sparc_no_align_cons)
d4483 1
a4483 2
      sparc_no_align_cons = 0;
    }
a4486 13

#ifdef OBJ_ELF
int
elf32_sparc_force_relocation (fixp)
     struct fix *fixp;
{
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

  return 0;
}
#endif
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 3
a4 1
   Copyright (C) 1989, 90-96, 97, 98, 99, 2000 Free Software Foundation, Inc.
d20 1
a20 1
   Boston, MA 02111-1307, USA. */
d32 1
d97 3
d123 1
a123 1
/* handle of the OPCODE hash table */
d139 1
a139 1
  {"align", s_align_bytes, 0},	/* Defaulting is invalid (0) */
d156 3
a158 1
  /* these are specific to sparc/svr4 */
d167 2
a168 1
const int md_reloc_size = 12;	/* Size of relocation record */
d171 3
a173 2
   pre-processor is disabled, these aren't very useful */
const char comment_chars[] = "!";	/* JF removed '|' from comment_chars */
d177 1
a177 1
   .line and .file directives will appear in the pre-processed output */
d180 1
a180 1
   #NO_APP at the beginning of its output. */
d182 1
a182 1
   work if '/' isn't otherwise defined. */
d185 1
a185 1
const char line_separator_chars[] = "";
d187 2
a188 1
/* Chars that can be used to separate mant from exp in floating point nums */
d191 3
a193 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d200 1
a200 1
#define isoctal(c)  ((unsigned)((c) - '0') < '8')
d224 1
a224 1
		       v8plusa, v9, v9a, v9_64};
d244 1
d247 1
d310 2
a311 1
  else return "a.out-sparc-little";
d337 1
a337 2
/*
 * md_parse_option
d346 1
a346 3
 *	-Av8plus, -Av8plusa
 *		Sparc64 in a 32 bit world.
 *	-Av9, -Av9a
d352 8
a359 2
 *	-xarch=v8plus, -xarch=v8plusa
 *		Same as -Av8plus{,a}, for compatibility with Sun's assembler.
d368 1
a368 1
 * 		-Av8plus{,a}.
d435 4
d441 2
a442 1
size_t md_longopts_size = sizeof(md_longopts);
d462 7
a468 9
      /* This is for compatibility with Sun's assembler.  */
      if (strcmp (arg, "v8plus") != 0
	  && strcmp (arg, "v8plusa") != 0)
	{
	  as_bad (_("invalid architecture -xarch=%s"), arg);
	  return 0;
	}

      /* fall through */
d479 4
a482 1
	    as_bad (_("invalid architecture -A%s"), arg);
d573 1
a573 1
	 Qn - do not emit .comment */
d577 1
a577 1
      /* use .stab instead of .stab.excl */
d581 1
a581 1
      /* quick -- native assembler does fewer checks */
d600 8
d620 1
d627 2
a628 1
  fprintf(stream, _("SPARC options:\n"));
d631 2
d635 7
a641 2
      if (arch->user_option_p)
	fprintf (stream, "-A%s", arch->name);
d643 14
a656 2
  fprintf (stream, _("\n-xarch=v8plus | -xarch=v8plusa\n"));
  fprintf (stream, _("\
d660 3
a662 1
--enforce-aligned-data	force .long, etc., to be aligned correctly\n"));
d699 1
a699 1
/* native operand size opcode translation */
d720 1
a720 1
/* sparc64 priviledged registers */
d723 4
a726 4
  {
    char *name;
    int regnum;
  };
d747 1
a747 1
  {"", -1},			/* end marker */
d750 1
a750 1
/* v9a specific asrs */
d755 2
d764 1
a764 1
  {"", -1},			/* end marker */
d779 2
a780 1
   set up all the tables, etc. that the MD part of the assembler will need. */
d824 4
a827 3
      char *name = sparc_arch_size == 32 ? native_op_table[i].name32 :
			native_op_table[i].name64;
      insn = (struct sparc_opcode *)hash_find (op_hash, name);
d829 5
a833 5
        {
          as_bad (_("Internal error: can't find opcode `%s' for `%s'\n"),
          	  name, native_op_table[i].name);
          lose = 1;
        }
d882 2
d885 6
a890 6
    {
      if (current_architecture == SPARC_OPCODE_ARCH_V9A)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v9a);
      else
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v9);
    }
d892 12
a903 17
    {
      if (current_architecture == SPARC_OPCODE_ARCH_V9)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v8plus);
      else if (current_architecture == SPARC_OPCODE_ARCH_V9A)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v8plusa);
      else if (current_architecture == SPARC_OPCODE_ARCH_SPARCLET)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_sparclet);
      else if (default_arch_type == sparc86x && target_little_endian_data)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_sparclite_le);
      else
	{
	  /* The sparclite is treated like a normal sparc.  Perhaps it shouldn't
	     be but for now it is (since that's the way it's always been
	     treated).  */
	  bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc);
	}
    }
d918 1
a918 1
      bfd_signed_vma sign = (bfd_signed_vma)1 << 31;
d1008 1
d1020 1
a1020 1
	  if (sizeof(offsetT) > 4
d1027 1
a1027 1
	  if (sizeof(offsetT) > 4
d1031 1
a1031 1
	  the_insn.exp.X_add_number = (int)the_insn.exp.X_add_number;
d1042 2
a1043 1
			    & (the_insn.exp.X_op == O_constant ? 0x3fffff : 0)));
d1045 1
a1045 2
			? BFD_RELOC_HI22
			: BFD_RELOC_NONE);
d1058 2
a1059 2
			    & (the_insn.exp.X_op != O_constant ? 0 :
			       need_hi22_p ? 0x3ff : 0x1fff)));
d1061 1
a1061 2
			? BFD_RELOC_LO10
			: BFD_RELOC_NONE);
d1065 1
a1065 1
    
d1067 1
d1087 1
a1087 1
  if (sizeof(offsetT) > 4
d1092 2
a1093 2
  low32 = the_insn.exp.X_add_number;	
	      
d1101 1
a1101 1
    
d1119 1
d1130 1
a1130 1
    
d1158 2
a1159 1
      lower32 = 0; upper32 = 0;
d1167 1
a1167 1
    
d1171 1
a1171 1
    
d1178 1
a1178 1
    
d1192 1
a1192 1
		      
d1208 1
a1208 1
    
d1220 1
a1220 1
    
d1225 1
a1225 1
			    >> 10) & 0x3fffff));
d1242 1
a1242 1
    
d1256 1
a1256 1
    
d1265 1
a1265 1
    
d1329 1
a1329 1
      /* normal insn */
d1336 1
a1336 1
	  
d1344 1
a1344 1
      
d1348 1
a1348 1
    
d1350 1
a1350 1
    
d1355 1
a1355 1
	   with Weitek 1165 float chips, such as the Sun-4/260 and /280. */
d1361 1
a1361 1
    
d1402 1
a1402 2

      /*FALLTHROUGH */
d1431 2
a1432 4
      /*
       * Build the opcode, checking as we go to make
       * sure that the operands match
       */
d1455 2
a1456 1
			while (*s == ' ') { ++s; continue; }
d1459 2
a1460 1
			while (*s == ' ') { ++s; continue; }
d1481 18
d1535 1
a1535 1
		  unsigned int len = 9999999; /* init to make gcc happy */
d1567 1
a1567 1
	      /* Parse a v9a ancillary state register.  */
d1571 1
a1571 1
		  unsigned int len = 9999999; /* init to make gcc happy */
d1585 1
a1585 1
		      error_message = _(": unrecognizable v9a ancillary state register");
d1592 9
a1600 1
		    }		      
d1610 1
a1610 1
		  error_message = _(": unrecognizable v9a ancillary state register");
d1655 1
a1655 1
		} /* if %asr */
d1800 1
a1800 1
	    case '\0':		/* end of args */
d1819 1
a1819 1
	    case '[':		/* these must match exactly */
d1827 1
a1827 1
	    case '#':		/* must be at least one digit */
d1838 1
a1838 1
	    case 'C':		/* coprocessor state register */
d1846 1
a1846 1
	    case 'b':		/* next operand is a coprocessor register */
d1979 1
a1979 1
		      && no_undeclared_regs && ! globals [mask])
d2073 1
a2073 1
		  }	/* if not an 'f' register. */
a2082 1

d2094 1
a2094 1
		  }		/* pack it in. */
d2098 1
a2098 1
	      }			/* float arg */
d2108 2
a2109 2
	    case '0':		/* 64 bit immediate (set, setsw, setx insn) */
	      the_insn.reloc = BFD_RELOC_NONE; /* reloc handled elsewhere */
d2112 1
a2112 1
	    case 'l':		/* 22 bit PC relative immediate */
d2117 1
a2117 1
	    case 'L':		/* 30 bit immediate */
d2123 1
a2123 1
	    case 'n':		/* 22 bit immediate */
d2127 1
a2127 1
	    case 'i':		/* 13 bit immediate */
d2171 1
a2171 1
		      { NULL }
d2174 1
a2174 1
  
d2180 1
a2180 1
		      
d2222 1
a2222 1
		    
d2237 1
a2237 1
		    memset (&the_insn.exp, 0, sizeof(the_insn.exp));
d2240 2
a2241 1
		for (s1 = s; *s1 && *s1 != ',' && *s1 != ']'; s1++) ;
d2296 1
a2296 1
			    /* intentional fallthrough */
d2305 1
a2305 1
			    /* intentional fallthrough */
d2326 1
a2326 1
			    val = ~ val;
d2421 1
a2421 1
	      }			/* alternate space */
d2431 1
a2431 1
	    case 'q':		/* floating point queue */
d2439 1
a2439 1
	    case 'Q':		/* coprocessor queue */
d2545 1
a2545 1
	    }			/* switch on arg code */
d2549 1
a2549 1
	}			/* for each arg that we expect */
d2554 1
a2554 1
	  /* Args don't match. */
d2571 1
a2571 1
	  /* We have a match.  Now see if the architecture is ok.  */
d2576 5
a2580 3
	      needed_arch_mask &= ~ ((1 << SPARC_OPCODE_ARCH_V9)
				     | (1 << SPARC_OPCODE_ARCH_V9A));
	      needed_arch_mask |= (1 << SPARC_OPCODE_ARCH_V9);
d2583 4
a2586 2
	  if (needed_arch_mask & SPARC_OPCODE_SUPPORTED (current_architecture))
	    ; /* ok */
d2588 2
a2589 1
	  else if (needed_arch_mask & SPARC_OPCODE_SUPPORTED (max_architecture))
d2614 1
a2614 1
	      int arch,printed_one_p = 0;
d2619 1
a2619 1
	      needed_arch_mask &= ~ SPARC_OPCODE_SUPPORTED (max_architecture);
d2641 1
a2641 1
	} /* if no match */
d2644 1
a2644 1
    } /* forever looking for a match */
d2750 1
a2750 1
  /* put out the opcode */
d2756 1
a2756 1
  /* put out the symbol-dependent stuff */
d2759 3
a2761 3
      fixS *fixP =  fix_new_exp (frag_now,	/* which frag */
				 (toP - frag_now->fr_literal),	/* where */
				 4,		/* size */
d2776 4
d2782 7
a2788 8
/*
  This is identical to the md_atof in m68k.c.  I think this is right,
  but I'm not sure.

  Turn a string in input_line_pointer into a floating point constant of type
  type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
  emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
  */
d2790 1
a2790 1
/* Equal to MAX_PRECISION in atof-ieee.c */
d2799 1
a2799 1
  int i,prec;
d2843 2
a2844 1
	  md_number_to_chars (litP, (valueT) words[i], sizeof (LITTLENUM_TYPE));
d2852 2
a2853 1
	  md_number_to_chars (litP, (valueT) words[i], sizeof (LITTLENUM_TYPE));
d2857 1
a2857 1
     
d2874 2
a2875 1
    /* Output debug words, which are not in allocated sections, as big endian */
d2882 1
a2882 1
   hold. */
d2898 1
a2898 1
  fixP->fx_addnumber = val;	/* Remember value for emit_reloc */
d2974 2
a2975 1
  if (fixP->fx_r_type == BFD_RELOC_16)
d2980 1
d2985 2
a2986 1
  else if (fixP->fx_r_type == BFD_RELOC_64)
d2990 1
a2990 1
  else if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT 
d3004 1
a3004 1
    
d3015 1
d3017 83
d3138 1
a3138 1
	  /* FIXME: simplify */
d3149 1
a3149 1
	  /* FIXME: simplify */
d3161 1
a3161 1
	  /* intentional fallthrough */
d3185 1
a3185 1
	  /* intentional fallthrough */
d3202 1
a3202 1
	  /* intentional fallthrough */
d3213 1
a3213 1
	  /* FALLTHROUGH */
d3240 1
a3240 1
	      val ^= ~ (offsetT) 0;
d3273 1
d3322 3
d3378 1
a3378 1
#endif /* defined (OBJ_ELF) || defined (OBJ_AOUT) */
d3412 1
a3412 1
#else /* elf or coff */
d3434 2
a3435 1
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (section_symbol (absolute_section));
d3444 1
a3444 1
/* We have no need to default values of symbols. */
a3445 1
/* ARGSUSED */
d3448 1
a3448 1
     char *name;
d3451 3
a3453 1
}				/* md_undefined_symbol() */
a3454 1
/* Round up a section size to the appropriate boundary. */
d3457 1
a3457 1
     segT segment;
d3466 2
a3467 1
  /* turn alignment value into a mask */
d3479 2
a3480 2
   (??? Is this right?  FIXME-SOON) */
long 
d3512 1
a3512 3
/*
 * sort of like s_lcomm
 */
d3520 1
a3520 1
     int ignore;
d3550 1
a3550 1
    }				/* bad length */
d3629 2
a3630 1
	  subseg_set (bss_section, 1); /* switch to bss */
d3633 2
a3634 1
	    frag_align (align, 0, 0); /* do alignment */
d3636 2
a3637 2
	  /* detach from old frag */
	  if (S_GET_SEGMENT(symbolP) == bss_section)
d3641 2
a3642 2
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
			    (offsetT) size, (char *)0);
d3656 3
a3658 3
      as_warn("Ignoring attempt to re-define symbol %s",
	      S_GET_NAME (symbolP));
    }				/* if not redefining */
d3665 1
a3665 1
     int ignore;
d3675 1
a3675 1
  /* just after name is now '\0' */
d3685 4
a3688 1
  input_line_pointer++;		/* skip ',' */
d3787 1
a3787 1
#endif /* OBJ_ELF */
d3846 1
a3846 1
     int ignore;
d3855 1
a3855 1
     int ignore;
d3881 2
a3882 2
	 You can still allocate SEG_BSS stuff with .lcomm or .reserve. */
      subseg_set (data_section, 255);	/* FIXME-SOMEDAY */
d3898 1
a3898 1
     int ignore;
d3931 1
a3931 1
     int bytes;
d3940 1
a3940 1
   
d3942 1
a3942 1
   */
d3946 1
a3946 1
     int ignore;
d3969 1
a3969 1
      if (regname [0] == 'i')
d3981 1
a3981 1
      if (globals [reg])
d3983 3
a3985 3
	  if ((regname && globals [reg] != (symbolS *)1
	       && strcmp (S_GET_NAME (globals [reg]), regname))
	      || ((regname != NULL) ^ (globals [reg] != (symbolS *)1)))
d3991 1
a3991 1
	    globals [reg] = (symbolS *)1;
d4000 2
a4001 2
	      globals [reg] = symbol_make (regname);
	      flags = symbol_get_bfdsym (globals [reg])->flags;
d4006 4
a4009 4
	      symbol_get_bfdsym (globals [reg])->flags = flags;
	      S_SET_VALUE (globals [reg], (valueT)reg);
	      S_SET_ALIGN (globals [reg], reg);
	      S_SET_SIZE (globals [reg], 0);
d4014 3
a4016 3
	      S_SET_SEGMENT (globals [reg], absolute_section);
	      S_SET_OTHER (globals [reg], 0);
	      elf_symbol (symbol_get_bfdsym (globals [reg]))
d4019 1
a4019 1
	      elf_symbol (symbol_get_bfdsym (globals [reg]))
d4032 1
a4032 1
   
d4037 1
a4037 1
     
d4075 1
d4077 1
a4077 5
    {
      /* This is an unaligned pseudo-op.  */
      sparc_no_align_cons = 0;
      return;
    }
d4092 1
a4092 1
  p = frag_var (rs_align_code, 1, 1, (relax_substateT) 0,
d4098 1
a4098 2
/* This is where we do the unexpected alignment check.
   This is called from HANDLE_ALIGN in tc-sparc.h.  */
d4104 47
a4150 32
  if (fragp->fr_type == rs_align_code && !fragp->fr_subtype
      && fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix != 0)
    as_bad_where (fragp->fr_file, fragp->fr_line, _("misaligned data"));
  if (fragp->fr_type == rs_align_code && fragp->fr_subtype == 1024)
    {
      int count = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
      
      if (count >= 4
	  && !(count & 3)
	  && count <= 1024
	  && !((long)(fragp->fr_literal + fragp->fr_fix) & 3))
        {
          unsigned *p = (unsigned *)(fragp->fr_literal + fragp->fr_fix);
          int i;
          
          for (i = 0; i < count; i += 4, p++)
            if (INSN_BIG_ENDIAN)
              number_to_chars_bigendian ((char *)p, 0x01000000, 4); /* emit nops */
            else
              number_to_chars_littleendian ((char *)p, 0x10000000, 4);

          if (SPARC_OPCODE_ARCH_V9_P (max_architecture) && count > 8)
            {
	      char *waddr = &fragp->fr_literal[fragp->fr_fix];
	      unsigned wval = (0x30680000 | count >> 2); /* ba,a,pt %xcc, 1f */
	      if (INSN_BIG_ENDIAN)
		number_to_chars_bigendian (waddr, wval, 4);
	      else
		number_to_chars_littleendian (waddr, wval, 4);
            }
          fragp->fr_var = count;
        }
d4180 2
d4202 3
a4204 2
  if (target_little_endian_data && nbytes == 4
      && now_seg->flags & SEC_ALLOC)  
d4206 13
d4225 1
a4225 1
      struct fix *fixp;
d4230 1
a4230 1
 
a4233 1

@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 2
   Copyright (C) 1989, 90-95, 1996 Free Software Foundation, Inc.

a25 1
/* careful, this file includes data *declarations* */
d28 32
a59 1
static void sparc_ip PARAMS ((char *, const struct sparc_opcode **));
d68 13
a80 8
   we don't see any v9 insns, a v9 object file is not created.  */
#ifdef SPARC_ARCH64
static enum sparc_opcode_arch_val max_architecture = SPARC_OPCODE_ARCH_V9;
#else
/* ??? This should be V8, but sparclite support was added by making it the
   default.  GCC now passes -Asparclite, so maybe sometime in the future
   we can set this to V8.  */
static enum sparc_opcode_arch_val max_architecture = SPARC_OPCODE_ARCH_SPARCLITE;
d90 4
d97 3
d102 10
a111 4
/* V9 has big and little endian data, but instructions are always big endian.
   The sparclet has bi-endian support but both data and insns have the same
   endianness.  Global `target_big_endian' is used for data.  The following
   macro is used for instructions.  */
d113 1
d115 1
d120 1
d128 2
d138 1
a150 2
  {"pushsection", obj_elf_section, 0},
  {"popsection", obj_elf_previous, 0},
d154 1
d189 1
a189 3
static unsigned char octal[256];
#define isoctal(c)  octal[(unsigned char) (c)]
static unsigned char toHex[256];
d197 1
d204 10
a213 1
/* Return non-zero if VAL is in the range -(MAX+1) to MAX.  */
d215 25
a239 12
static INLINE int
in_signed_range (val, max)
     bfd_signed_vma val, max;
{
  if (max <= 0)
    abort ();
  if (val > max)
    return 0;
  if (val < ~max)
    return 0;
  return 1;
}
d241 2
a242 2
/* Return non-zero if VAL is in the range -(MAX/2+1) to MAX.
   (e.g. -15 to +31).  */
d244 3
a246 3
static INLINE int
in_bitfield_range (val, max)
     bfd_signed_vma val, max;
d248 8
a255 7
  if (max <= 0)
    abort ();
  if (val > max)
    return 0;
  if (val < ~(max >> 1))
    return 0;
  return 1;
d258 5
a262 3
static int
sparc_ffs (mask)
     unsigned int mask;
d264 1
a264 1
  int i;
d266 3
a268 2
  if (mask == 0)
    return -1;
d270 6
a275 3
  for (i = 0; (mask & 1) == 0; ++i)
    mask >>= 1;
  return i;
d278 4
a281 5
/* Implement big shift right.  */
static bfd_vma
BSR (val, amount)
     bfd_vma val;
     int amount;
d283 4
a286 4
  if (sizeof (bfd_vma) <= 4 && amount >= 32)
    as_fatal ("Support for 64-bit arithmetic not compiled in.");
  return val >> amount;
}
d288 14
a301 2
#if 0
static void print_insn PARAMS ((struct sparc_it *insn));
a302 1
static int getExpression PARAMS ((char *str));
d304 3
a306 2
static char *expr_end;
static int special_case;
d308 7
a314 9
/*
 * Instructions that require wierd handling because they're longer than
 * 4 bytes.
 */
#define	SPECIAL_CASE_SET	1
#define SPECIAL_CASE_SETSW	2
#define SPECIAL_CASE_SETX	3
/* FIXME: sparc-opc.c doesn't have necessary "S" trigger to enable this.  */
#define	SPECIAL_CASE_FDIV	4
d316 3
a318 10
/* Bit masks of various insns.  */
#define NOP_INSN 0x01000000
#define OR_INSN 0x80100000
#define FMOVS_INSN 0x81A00020
#define SETHI_INSN 0x01000000
#define SLLX_INSN 0x81281000
#define SRA_INSN 0x81380000

/* The last instruction to be assembled.  */
static const struct sparc_opcode *last_insn;
d320 3
d324 44
a367 1
 * sort of like s_lcomm
d369 3
d373 44
a416 2
#ifndef OBJ_ELF
static int max_alignment = 15;
d418 3
d422 4
a425 3
static void
s_reserve (ignore)
     int ignore;
d427 4
a430 7
  char *name;
  char *p;
  char c;
  int align;
  int size;
  int temp;
  symbolS *symbolP;
d432 6
a437 5
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
d439 8
a446 6
  if (*input_line_pointer != ',')
    {
      as_bad ("Expected comma after name");
      ignore_rest_of_line ();
      return;
    }
d448 1
a448 1
  ++input_line_pointer;
d450 4
a453 6
  if ((size = get_absolute_expression ()) < 0)
    {
      as_bad ("BSS length (%d.) <0! Ignored.", size);
      ignore_rest_of_line ();
      return;
    }				/* bad length */
d455 7
a461 3
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
d463 3
a465 6
  if (strncmp (input_line_pointer, ",\"bss\"", 6) != 0
      && strncmp (input_line_pointer, ",\".bss\"", 7) != 0)
    {
      as_bad ("bad .reserve segment -- expected BSS segment");
      return;
    }
d467 4
a470 5
  if (input_line_pointer[2] == '.')
    input_line_pointer += 7;
  else
    input_line_pointer += 6;
  SKIP_WHITESPACE ();
d472 3
a474 3
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
d476 3
a478 6
      SKIP_WHITESPACE ();
      if (*input_line_pointer == '\n')
	{
	  as_bad ("Missing alignment");
	  return;
	}
d480 16
a495 7
      align = get_absolute_expression ();
#ifndef OBJ_ELF
      if (align > max_alignment)
	{
	  align = max_alignment;
	  as_warn ("Alignment too large: %d. assumed.", align);
	}
a496 5
      if (align < 0)
	{
	  align = 0;
	  as_warn ("Alignment negative. 0 assumed.");
	}
d498 5
a502 1
      record_alignment (bss_section, align);
d504 5
a508 2
      /* convert to a power of 2 alignment */
      for (temp = 0; (align & 1) == 0; align >>= 1, ++temp);;
d510 33
a542 6
      if (align != 1)
	{
	  as_bad ("Alignment not a power of 2");
	  ignore_rest_of_line ();
	  return;
	}			/* not a power of two */
d544 3
a546 4
      align = temp;
    }				/* if has optional alignment */
  else
    align = 0;
d548 4
a551 12
  if (!S_IS_DEFINED (symbolP)
#ifdef OBJ_AOUT
      && S_GET_OTHER (symbolP) == 0
      && S_GET_DESC (symbolP) == 0
#endif
      )
    {
      if (! need_pass_2)
	{
	  char *pfrag;
	  segT current_seg = now_seg;
	  subsegT current_subseg = now_subseg;
d553 3
a555 1
	  subseg_set (bss_section, 1); /* switch to bss */
d557 3
a559 2
	  if (align)
	    frag_align (align, 0); /* do alignment */
d561 6
a566 3
	  /* detach from old frag */
	  if (S_GET_SEGMENT(symbolP) == bss_section)
	    symbolP->sy_frag->fr_symbol = NULL;
d568 3
a570 4
	  symbolP->sy_frag = frag_now;
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
			    size, (char *)0);
	  *pfrag = 0;
d572 4
a575 1
	  S_SET_SEGMENT (symbolP, bss_section);
d577 2
a578 2
	  subseg_set (current_seg, current_subseg);
	}
a579 5
  else
    {
      as_warn("Ignoring attempt to re-define symbol %s",
	      S_GET_NAME (symbolP));
    }				/* if not redefining */
d581 1
a581 1
  demand_empty_rest_of_line ();
d584 3
a586 3
static void
s_common (ignore)
     int ignore;
d588 6
a593 5
  char *name;
  char c;
  char *p;
  int temp, size;
  symbolS *symbolP;
d595 2
a596 7
  name = input_line_pointer;
  c = get_symbol_end ();
  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
d598 4
a601 3
      as_bad ("Expected comma after symbol-name");
      ignore_rest_of_line ();
      return;
d603 138
a740 2
  input_line_pointer++;		/* skip ',' */
  if ((temp = get_absolute_expression ()) < 0)
d742 20
a761 3
      as_bad (".COMMon length (%d.) <0! Ignored.", temp);
      ignore_rest_of_line ();
      return;
d763 2
a764 5
  size = temp;
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  if (S_IS_DEFINED (symbolP))
d766 11
a776 7
      as_bad ("Ignoring attempt to re-define symbol");
      ignore_rest_of_line ();
      return;
    }
  if (S_GET_VALUE (symbolP) != 0)
    {
      if (S_GET_VALUE (symbolP) != size)
d778 7
a784 2
	  as_warn ("Length of .comm \"%s\" is already %ld. Not changed to %d.",
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
d787 16
a802 1
  else
d804 12
a815 4
#ifndef OBJ_ELF
      S_SET_VALUE (symbolP, (valueT) size);
      S_SET_EXTERNAL (symbolP);
#endif
d817 8
a824 2
  know (symbolP->sy_frag == &zero_address_frag);
  if (*input_line_pointer != ',')
d826 4
a829 3
      as_bad ("Expected comma after common length");
      ignore_rest_of_line ();
      return;
d831 1
a831 3
  input_line_pointer++;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != '"')
d833 9
a841 3
      temp = get_absolute_expression ();
#ifndef OBJ_ELF
      if (temp > max_alignment)
d843 4
a846 2
	  temp = max_alignment;
	  as_warn ("Common alignment too large: %d. assumed", temp);
d848 14
a861 45
#endif
      if (temp < 0)
	{
	  temp = 0;
	  as_warn ("Common alignment negative; 0 assumed");
	}
#ifdef OBJ_ELF
      if (symbolP->local)
	{
	  segT old_sec;
	  int old_subsec;
	  char *p;
	  int align;

	  old_sec = now_seg;
	  old_subsec = now_subseg;
	  align = temp;
	  record_alignment (bss_section, align);
	  subseg_set (bss_section, 0);
	  if (align)
	    frag_align (align, 0);
	  if (S_GET_SEGMENT (symbolP) == bss_section)
	    symbolP->sy_frag->fr_symbol = 0;
	  symbolP->sy_frag = frag_now;
	  p = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP, size,
			(char *) 0);
	  *p = 0;
	  S_SET_SEGMENT (symbolP, bss_section);
	  S_CLEAR_EXTERNAL (symbolP);
	  subseg_set (old_sec, old_subsec);
	}
      else
#endif
	{
	allocate_common:
	  S_SET_VALUE (symbolP, (valueT) size);
#ifdef OBJ_ELF
	  S_SET_ALIGN (symbolP, temp);
#endif
	  S_SET_EXTERNAL (symbolP);
	  /* should be common, but this is how gas does it for now */
	  S_SET_SEGMENT (symbolP, bfd_und_section_ptr);
	}
    }
  else
d863 2
a864 16
      input_line_pointer++;
      /* @@@@ Some use the dot, some don't.  Can we get some consistency??  */
      if (*input_line_pointer == '.')
	input_line_pointer++;
      /* @@@@ Some say data, some say bss.  */
      if (strncmp (input_line_pointer, "bss\"", 4)
	  && strncmp (input_line_pointer, "data\"", 5))
	{
	  while (*--input_line_pointer != '"')
	    ;
	  input_line_pointer--;
	  goto bad_common_segment;
	}
      while (*input_line_pointer++ != '"')
	;
      goto allocate_common;
d866 8
a873 2
  demand_empty_rest_of_line ();
  return;
d875 7
a881 13
  {
  bad_common_segment:
    p = input_line_pointer;
    while (*p && *p != '\n')
      p++;
    c = *p;
    *p = '\0';
    as_bad ("bad .common segment %s", input_line_pointer + 1);
    *p = c;
    input_line_pointer = p;
    ignore_rest_of_line ();
    return;
  }
d884 2
a885 2
/* Handle the .empty pseudo-op.  This supresses the warnings about
   invalid delay slot usage.  */
d887 3
a889 3
static void
s_empty (ignore)
     int ignore;
d891 7
a897 3
  /* The easy way to implement is to just forget about the last
     instruction.  */
  last_insn = NULL;
d900 3
a902 3
static void
s_seg (ignore)
     int ignore;
d904 1
d906 6
a911 29
  if (strncmp (input_line_pointer, "\"text\"", 6) == 0)
    {
      input_line_pointer += 6;
      s_text (0);
      return;
    }
  if (strncmp (input_line_pointer, "\"data\"", 6) == 0)
    {
      input_line_pointer += 6;
      s_data (0);
      return;
    }
  if (strncmp (input_line_pointer, "\"data1\"", 7) == 0)
    {
      input_line_pointer += 7;
      s_data1 ();
      return;
    }
  if (strncmp (input_line_pointer, "\"bss\"", 5) == 0)
    {
      input_line_pointer += 5;
      /* We only support 2 segments -- text and data -- for now, so
	 things in the "bss segment" will have to go into data for now.
	 You can still allocate SEG_BSS stuff with .lcomm or .reserve. */
      subseg_set (data_section, 255);	/* FIXME-SOMEDAY */
      return;
    }
  as_bad ("Unknown segment type");
  demand_empty_rest_of_line ();
d914 5
a918 2
static void
s_data1 ()
d920 3
a922 2
  subseg_set (data_section, 1);
  demand_empty_rest_of_line ();
d924 22
d947 6
d954 2
a955 2
s_proc (ignore)
     int ignore;
d957 4
a960 1
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
d962 15
a976 1
      ++input_line_pointer;
a977 2
  ++input_line_pointer;
}
d979 14
a992 8
/* This static variable is set by s_uacons to tell sparc_cons_align
   that the expession does not need to be aligned.  */

static int sparc_no_align_cons = 0;

/* This handles the unaligned space allocation pseudo-ops, such as
   .uaword.  .uaword is just like .word, but the value does not need
   to be aligned.  */
d994 18
d1013 2
a1014 2
s_uacons (bytes)
     int bytes;
d1016 1
a1016 4
  /* Tell sparc_cons_align not to align this value.  */
  sparc_no_align_cons = 1;
  cons (bytes);
}
d1018 1
a1018 3
/* We require .word, et. al., to be aligned correctly.  We do it by
   setting up an rs_align_code frag, and checking in HANDLE_ALIGN to
   make sure that no unexpected alignment was introduced.  */
d1020 3
a1022 6
void
sparc_cons_align (nbytes)
     int nbytes;
{
  int nalign;
  char *p;
d1024 4
a1027 4
  if (sparc_no_align_cons)
    {
      /* This is an unaligned pseudo-op.  */
      sparc_no_align_cons = 0;
d1031 8
a1038 2
  nalign = 0;
  while ((nbytes & 1) == 0)
d1040 2
a1041 2
      ++nalign;
      nbytes >>= 1;
d1044 5
a1048 4
  if (nalign == 0)
    return;

  if (now_seg == absolute_section)
d1050 5
a1054 3
      if ((abs_section_offset & ((1 << nalign) - 1)) != 0)
	as_bad ("misaligned data");
      return;
d1057 3
a1059 4
  p = frag_var (rs_align_code, 1, 1, (relax_substateT) 0,
		(symbolS *) NULL, (long) nalign, (char *) NULL);

  record_alignment (now_seg, nalign);
d1062 4
a1065 5
/* This is where we do the unexpected alignment check.  */

void
sparc_handle_align (fragp)
     fragS *fragp;
d1067 11
a1077 4
  if (fragp->fr_type == rs_align_code
      && fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix != 0)
    as_bad_where (fragp->fr_file, fragp->fr_line, "misaligned data");
}
d1079 74
a1152 1
/* sparc64 priviledged registers */
d1154 18
a1171 5
struct priv_reg_entry
  {
    char *name;
    int regnum;
  };
d1173 13
a1185 42
struct priv_reg_entry priv_reg_table[] =
{
  {"tpc", 0},
  {"tnpc", 1},
  {"tstate", 2},
  {"tt", 3},
  {"tick", 4},
  {"tba", 5},
  {"pstate", 6},
  {"tl", 7},
  {"pil", 8},
  {"cwp", 9},
  {"cansave", 10},
  {"canrestore", 11},
  {"cleanwin", 12},
  {"otherwin", 13},
  {"wstate", 14},
  {"fq", 15},
  {"ver", 31},
  {"", -1},			/* end marker */
};

static int
cmp_reg_entry (p, q)
     struct priv_reg_entry *p, *q;
{
  return strcmp (q->name, p->name);
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will need. */

void
md_begin ()
{
  register const char *retval = NULL;
  int lose = 0;
  register unsigned int i = 0;

  op_hash = hash_new ();

  while (i < sparc_num_opcodes)
d1187 10
a1196 20
      const char *name = sparc_opcodes[i].name;
      retval = hash_insert (op_hash, name, &sparc_opcodes[i]);
      if (retval != NULL)
	{
	  fprintf (stderr, "internal error: can't hash `%s': %s\n",
		   sparc_opcodes[i].name, retval);
	  lose = 1;
	}
      do
	{
	  if (sparc_opcodes[i].match & sparc_opcodes[i].lose)
	    {
	      fprintf (stderr, "internal error: losing opcode: `%s' \"%s\"\n",
		       sparc_opcodes[i].name, sparc_opcodes[i].args);
	      lose = 1;
	    }
	  ++i;
	}
      while (i < sparc_num_opcodes
	     && !strcmp (sparc_opcodes[i].name, name));
d1198 3
a1200 25

  if (lose)
    as_fatal ("Broken assembler.  No assembly attempted.");

  for (i = '0'; i < '8'; ++i)
    octal[i] = 1;
  for (i = '0'; i <= '9'; ++i)
    toHex[i] = i - '0';
  for (i = 'a'; i <= 'f'; ++i)
    toHex[i] = i + 10 - 'a';
  for (i = 'A'; i <= 'F'; ++i)
    toHex[i] = i + 10 - 'A';

  qsort (priv_reg_table, sizeof (priv_reg_table) / sizeof (priv_reg_table[0]),
	 sizeof (priv_reg_table[0]), cmp_reg_entry);

  /* If -bump, record the architecture level at which we start issuing
     warnings.  The behaviour is different depending upon whether an
     architecture was explicitly specified.  If it wasn't, we issue warnings
     for all upwards bumps.  If it was, we don't start issuing warnings until
     we need to bump beyond the requested architecture or when we bump between
     conflicting architectures.  */

  if (warn_on_bump
      && architecture_requested)
d1202 4
a1205 12
      /* `max_architecture' records the requested architecture.
	 Issue warnings if we go above it.  */
      warn_after_architecture = max_architecture;

      /* Find the highest architecture level that doesn't conflict with
	 the requested one.  */
      for (max_architecture = SPARC_OPCODE_ARCH_MAX;
	   max_architecture > warn_after_architecture;
	   --max_architecture)
	if (! SPARC_OPCODE_CONFLICT_P (max_architecture,
				       warn_after_architecture))
	  break;
d1207 3
a1209 20
}

/* Called after all assembly has been done.  */

void
sparc_md_end ()
{
#ifdef SPARC_ARCH64
  if (current_architecture == SPARC_OPCODE_ARCH_V9A)
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v9a);
  else
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v9);
#else
  if (current_architecture == SPARC_OPCODE_ARCH_V9)
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v8plus);
  else if (current_architecture == SPARC_OPCODE_ARCH_V9A)
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v8plusa);
  else if (current_architecture == SPARC_OPCODE_ARCH_SPARCLET)
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_sparclet);
  else
d1211 4
a1214 4
      /* The sparclite is treated like a normal sparc.  Perhaps it shouldn't
	 be but for now it is (since that's the way it's always been
	 treated).  */
      bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc);
a1215 17
#endif
}

/* Utility to output one insn.  */

static void
output_insn (insn, the_insn)
     const struct sparc_opcode *insn;
     struct sparc_it *the_insn;
{
  char *toP = frag_more (4);

  /* put out the opcode */
  if (INSN_BIG_ENDIAN)
    number_to_chars_bigendian (toP, (valueT) the_insn->opcode, 4);
  else
    number_to_chars_littleendian (toP, (valueT) the_insn->opcode, 4);
d1217 2
a1218 2
  /* put out the symbol-dependent stuff */
  if (the_insn->reloc != BFD_RELOC_NONE)
d1220 4
a1223 6
      fix_new_exp (frag_now,	/* which frag */
		   (toP - frag_now->fr_literal),	/* where */
		   4,		/* size */
		   &the_insn->exp,
		   the_insn->pcrel,
		   the_insn->reloc);
a1224 2

  last_insn = insn;
d1226 2
d1234 1
d1237 1
a1237 2
  special_case = 0;
  sparc_ip (str, &insn);
d1239 2
a1240 1
  /* We warn about attempts to put a floating point branch in a delay slot.  */
d1244 6
a1249 2
      && (last_insn->flags & F_DELAYED) != 0)
    as_warn ("FP branch in delay slot");
d1265 1
a1265 1
      as_warn ("FP branch preceded by FP instruction; NOP inserted");
d1270 1
a1270 1
    case 0:
d1275 4
d1280 2
a1281 46
      {
	int need_hi22_p = 0;

	/* "set" is not defined for negative numbers in v9: it doesn't yield
	   what you expect it to.  */
	if (SPARC_OPCODE_ARCH_V9_P (max_architecture)
	    && the_insn.exp.X_op == O_constant)
	  {
	    if (the_insn.exp.X_add_number < 0)
	      as_warn ("set: used with negative number");
	    else if (the_insn.exp.X_add_number > 0xffffffff)
	      as_warn ("set: number larger than 4294967295");
	  }

	/* See if operand is absolute and small; skip sethi if so.  */
	if (the_insn.exp.X_op != O_constant
	    || the_insn.exp.X_add_number >= (1 << 12)
	    || the_insn.exp.X_add_number < -(1 << 12))
	  {
	    output_insn (insn, &the_insn);
	    need_hi22_p = 1;
	  }
	/* See if operand has no low-order bits; skip OR if so.  */
	if (the_insn.exp.X_op != O_constant
	    || (need_hi22_p && (the_insn.exp.X_add_number & 0x3FF) != 0)
	    || ! need_hi22_p)
	  {
	    int rd = (the_insn.opcode & RD (~0)) >> 25;
	    the_insn.opcode = (OR_INSN | (need_hi22_p ? RS1 (rd) : 0)
			       | RD (rd)
			       | IMMED
			       | (the_insn.exp.X_add_number
				  & (need_hi22_p ? 0x3ff : 0x1fff)));
	    the_insn.reloc = (the_insn.exp.X_op != O_constant
			      ? BFD_RELOC_LO10
			      : BFD_RELOC_NONE);
	    output_insn (insn, &the_insn);
	  }
	break;
      }

    case SPECIAL_CASE_SETSW:
      {
	/* FIXME: Not finished.  */
	break;
      }
d1284 3
a1286 141
      {
#define SIGNEXT32(x) ((((x) & 0xffffffff) ^ 0x80000000) - 0x80000000)
	int upper32 = SIGNEXT32 (BSR (the_insn.exp.X_add_number, 32));
	int lower32 = SIGNEXT32 (the_insn.exp.X_add_number);
#undef SIGNEXT32
	int tmpreg = (the_insn.opcode & RS1 (~0)) >> 14;
	int dstreg = (the_insn.opcode & RD (~0)) >> 25;
	/* Output directly to dst reg if lower 32 bits are all zero.  */
	int upper_dstreg = (the_insn.exp.X_op == O_constant
			    && lower32 == 0) ? dstreg : tmpreg;
	int need_hh22_p = 0, need_hm10_p = 0, need_hi22_p = 0, need_lo10_p = 0;

	/* The tmp reg should not be the dst reg.  */
	if (tmpreg == dstreg)
	  as_warn ("setx: temporary register same as destination register");

	/* Reset X_add_number, we've extracted it as upper32/lower32.
	   Otherwise fixup_segment will complain about not being able to
	   write an 8 byte number in a 4 byte field.  */
	the_insn.exp.X_add_number = 0;

	/* ??? Obviously there are other optimizations we can do
	   (e.g. sethi+shift for 0x1f0000000) and perhaps we shouldn't be
	   doing some of these.  Later.  If you do change things, try to
	   change all of this to be table driven as well.  */

	/* What to output depends on the number if it's constant.
	   Compute that first, then output what we've decided upon.  */
	if (the_insn.exp.X_op != O_constant)
	  need_hh22_p = need_hm10_p = need_hi22_p = need_lo10_p = 1;
	else
	  {
	    /* Only need hh22 if `or' insn can't handle constant.  */
	    if (upper32 < -(1 << 12) || upper32 >= (1 << 12))
	      need_hh22_p = 1;

	    /* Does bottom part (after sethi) have bits?  */
	    if ((need_hh22_p && (upper32 & 0x3ff) != 0)
		/* No hh22, but does upper32 still have bits we can't set
		   from lower32?  */
		|| (! need_hh22_p
		    && upper32 != 0
		    && (upper32 != -1 || lower32 >= 0)))
	      need_hm10_p = 1;

	    /* If the lower half is all zero, we build the upper half directly
	       into the dst reg.  */
	    if (lower32 != 0
		/* Need lower half if number is zero.  */
		|| (! need_hh22_p && ! need_hm10_p))
	      {
		/* No need for sethi if `or' insn can handle constant.  */
		if (lower32 < -(1 << 12) || lower32 >= (1 << 12)
		    /* Note that we can't use a negative constant in the `or'
		       insn unless the upper 32 bits are all ones.  */
		    || (lower32 < 0 && upper32 != -1))
		  need_hi22_p = 1;

		/* Does bottom part (after sethi) have bits?  */
		if ((need_hi22_p && (lower32 & 0x3ff) != 0)
		    /* No sethi.  */
		    || (! need_hi22_p && (lower32 & 0x1fff) != 0)
		    /* Need `or' if we didn't set anything else.  */
		    || (! need_hi22_p && ! need_hh22_p && ! need_hm10_p))
		  need_lo10_p = 1;
	      }
	  }

	if (need_hh22_p)
	  {
	    the_insn.opcode = (SETHI_INSN | RD (upper_dstreg)
			       | ((upper32 >> 10) & 0x3fffff));
	    the_insn.reloc = (the_insn.exp.X_op != O_constant
			      ? BFD_RELOC_SPARC_HH22 : BFD_RELOC_NONE);
	    output_insn (insn, &the_insn);
	  }

	if (need_hm10_p)
	  {
	    the_insn.opcode = (OR_INSN
			       | (need_hh22_p ? RS1 (upper_dstreg) : 0)
			       | RD (upper_dstreg)
			       | IMMED
			       | (upper32
				  & (need_hh22_p ? 0x3ff : 0x1fff)));
	    the_insn.reloc = (the_insn.exp.X_op != O_constant
			      ? BFD_RELOC_SPARC_HM10 : BFD_RELOC_NONE);
	    output_insn (insn, &the_insn);
	  }

	if (need_hi22_p)
	  {
	    the_insn.opcode = (SETHI_INSN | RD (dstreg)
			       | ((lower32 >> 10) & 0x3fffff));
	    the_insn.reloc = BFD_RELOC_HI22;
	    output_insn (insn, &the_insn);
	  }

	if (need_lo10_p)
	  {
	    /* FIXME: One nice optimization to do here is to OR the low part
	       with the highpart if hi22 isn't needed and the low part is
	       positive.  */
	    the_insn.opcode = (OR_INSN | (need_hi22_p ? RS1 (dstreg) : 0)
			       | RD (dstreg)
			       | IMMED
			       | (lower32
				  & (need_hi22_p ? 0x3ff : 0x1fff)));
	    the_insn.reloc = BFD_RELOC_LO10;
	    output_insn (insn, &the_insn);
	  }

	/* If we needed to build the upper part, shift it into place.  */
	if (need_hh22_p || need_hm10_p)
	  {
	    the_insn.opcode = (SLLX_INSN | RS1 (upper_dstreg) | RD (upper_dstreg)
			       | IMMED | 32);
	    the_insn.reloc = BFD_RELOC_NONE;
	    output_insn (insn, &the_insn);
	  }

	/* If we needed to build both upper and lower parts, OR them together.  */
	if ((need_hh22_p || need_hm10_p)
	    && (need_hi22_p || need_lo10_p))
	  {
	    the_insn.opcode = (OR_INSN | RS1 (dstreg) | RS2 (upper_dstreg)
			       | RD (dstreg));
	    the_insn.reloc = BFD_RELOC_NONE;
	    output_insn (insn, &the_insn);
	  }
	/* We didn't need both regs, but we may have to sign extend lower32.  */
	else if (need_hi22_p && upper32 == -1)
	  {
	    the_insn.opcode = (SRA_INSN | RS1 (dstreg) | RD (dstreg)
			       | IMMED | 0);
	    the_insn.reloc = BFD_RELOC_NONE;
	    output_insn (insn, &the_insn);
	  }
	break;
      }

d1290 1
a1290 1

d1292 1
a1292 1

d1301 1
a1301 1
	break;
d1303 1
a1303 1

d1305 1
a1305 1
      as_fatal ("failed special case insn sanity check");
d1309 1
a1309 30
/* Parse an argument that can be expressed as a keyword.
   (eg: #StoreStore or %ccfr).
   The result is a boolean indicating success.
   If successful, INPUT_POINTER is updated.  */

static int
parse_keyword_arg (lookup_fn, input_pointerP, valueP)
     int (*lookup_fn) ();
     char **input_pointerP;
     int *valueP;
{
  int value;
  char c, *p, *q;

  p = *input_pointerP;
  for (q = p + (*p == '#' || *p == '%'); isalpha (*q) || *q == '_'; ++q)
    continue;
  c = *q;
  *q = 0;
  value = (*lookup_fn) (p);
  *q = c;
  if (value == -1)
    return 0;
  *valueP = value;
  *input_pointerP = q;
  return 1;
}

/* Parse an argument that is a constant expression.
   The result is a boolean indicating success.  */
a1311 30
parse_const_expr_arg (input_pointerP, valueP)
     char **input_pointerP;
     int *valueP;
{
  char *save = input_line_pointer;
  expressionS exp;

  input_line_pointer = *input_pointerP;
  /* The next expression may be something other than a constant
     (say if we're not processing the right variant of the insn).
     Don't call expression unless we're sure it will succeed as it will
     signal an error (which we want to defer until later).  */
  /* FIXME: It might be better to define md_operand and have it recognize
     things like %asi, etc. but continuing that route through to the end
     is a lot of work.  */
  if (*input_line_pointer == '%')
    {
      input_line_pointer = save;
      return 0;
    }
  expression (&exp);
  *input_pointerP = input_line_pointer;
  input_line_pointer = save;
  if (exp.X_op != O_constant)
    return 0;
  *valueP = exp.X_add_number;
  return 1;
}

static void
a1325 1
  long immediate_max = 0;
d1327 1
d1329 7
a1335 2
  for (s = str; islower (*s) || (*s >= '0' && *s <= '3'); ++s)
    ;
d1352 1
a1352 1
      as_fatal ("Unknown opcode: `%s'", str);
d1358 2
a1359 2
      as_bad ("Unknown opcode: `%s'", str);
      return;
d1396 1
a1396 1
			    error_message = ": invalid membar mask name";
d1410 1
a1410 1
			error_message = ": invalid membar mask expression";
d1415 1
a1415 1
			error_message = ": invalid membar mask number";
d1433 1
a1433 1
			error_message = ": invalid prefetch function name";
d1441 1
a1441 1
			error_message = ": invalid prefetch function expression";
d1446 1
a1446 1
			error_message = ": invalid prefetch function number";
d1474 1
a1474 1
		      error_message = ": unrecognizable privileged register";
d1486 1
a1486 1
		  error_message = ": unrecognizable privileged register";
d1490 44
a1533 3
	    case 'M':
	    case 'm':
	      if (strncmp (s, "%asr", 4) == 0)
d1537 1
a1537 1
		  if (isdigit (*s))
d1541 1
a1541 1
		      while (isdigit (*s))
d1551 1
a1551 1
			      error_message = ": asr number must be between 16 and 31";
d1559 1
a1559 1
			      error_message = ": asr number must be between 0 and 31";
d1569 1
a1569 1
		      error_message = ": expecting %asrN";
a1576 1
	      immediate_max = 0x03FF;
a1580 1
	      immediate_max = 0x01FF;
a1590 1
	      immediate_max = 0x1f;
a1600 1
	      immediate_max = 0x3f;
d1745 1
a1745 1
	      if (isdigit (*s++))
d1747 1
a1747 1
		  while (isdigit (*s))
d1766 1
a1766 1
	      if (*s++ == '%' && *s++ == 'c' && isdigit (*s))
d1769 1
a1769 1
		  if (isdigit (*s))
d1818 2
a1819 1
		      if (isoctal (c = *s++))
d1827 2
a1828 1
		      if (isoctal (c = *s++))
d1836 2
a1837 1
		      if (isoctal (c = *s++))
d1845 2
a1846 1
		      if (isoctal (c = *s++))
d1862 1
a1862 1
		      if (!isdigit (c = *s++))
d1877 1
a1877 1
		      if (isdigit (*s))
d1895 4
d1942 1
a1942 1
		    && isdigit (*++s))
d1944 1
a1944 1
		    for (mask = 0; isdigit (*s); ++s)
d1968 1
a1968 1
			  error_message = ": There are only 64 f registers; [0-63]";
d1970 1
a1970 1
			  error_message = ": There are only 32 f registers; [0-31]";
d1982 1
a1982 1
			    error_message = ": There are only 32 f registers; [0-31]";
d2026 1
a2026 1
	    case '0':		/* 64 bit immediate (setx insn) */
a2029 4
	    case 'h':		/* high 22 bits */
	      the_insn.reloc = BFD_RELOC_HI22;
	      goto immediate;

d2040 1
a2046 1
	      immediate_max = 0x0FFF;
d2048 1
a2048 1
	      /*FALLTHROUGH */
d2053 1
a2053 35
	      if (*s == '%')
		{
		  if ((c = s[1]) == 'h' && s[2] == 'i')
		    {
		      the_insn.reloc = BFD_RELOC_HI22;
		      s += 3;
		    }
		  else if (c == 'l' && s[2] == 'o')
		    {
		      the_insn.reloc = BFD_RELOC_LO10;
		      s += 3;
		    }
		  else if (c == 'u'
			   && s[2] == 'h'
			   && s[3] == 'i')
		    {
		      the_insn.reloc = BFD_RELOC_SPARC_HH22;
		      s += 4;
		      v9_arg_p = 1;
		    }
		  else if (c == 'u'
			   && s[2] == 'l'
			   && s[3] == 'o')
		    {
		      the_insn.reloc = BFD_RELOC_SPARC_HM10;
		      s += 4;
		      v9_arg_p = 1;
		    }
		  else
		    break;
		}
	      /* Note that if the getExpression() fails, we will still
		 have created U entries in the symbol table for the
		 'symbols' in the input string.  Try not to create U
		 symbols for registers, etc.  */
d2055 61
d2121 36
a2156 1
		char *s1;
d2160 1
a2160 1
		if (s1 != s && isdigit (s1[-1]))
d2163 6
a2169 1
			s1 -= 3;
d2171 4
a2174 1
			(void) getExpression (s);
d2176 2
a2178 1
			continue;
d2180 82
a2261 1
		    else if (strchr ("goli0123456789", s1[-2]) && s1[-3] == '%' && s1[-4] == '+')
d2263 9
a2271 6
			s1 -= 4;
			*s1 = '\0';
			(void) getExpression (s);
			*s1 = '+';
			s = s1;
			continue;
d2275 1
a2275 3
	      (void) getExpression (s);
	      s = expr_end;

a2279 22
		  /* Handle %uhi/%ulo by moving the upper word to the lower
		     one and pretending it's %hi/%lo.  We also need to watch
		     for %hi/%lo: the top word needs to be zeroed otherwise
		     fixup_segment will complain the value is too big.  */
		  switch (the_insn.reloc)
		    {
		    case BFD_RELOC_SPARC_HH22:
		      the_insn.reloc = BFD_RELOC_HI22;
		      the_insn.exp.X_add_number = BSR (the_insn.exp.X_add_number, 32);
		      break;
		    case BFD_RELOC_SPARC_HM10:
		      the_insn.reloc = BFD_RELOC_LO10;
		      the_insn.exp.X_add_number = BSR (the_insn.exp.X_add_number, 32);
		      break;
		    case BFD_RELOC_HI22:
		    case BFD_RELOC_LO10:
		      the_insn.exp.X_add_number &= 0xffffffff;
		      break;
		    default:
		      break;
		    }

d2284 1
a2284 2
		      && in_signed_range (the_insn.exp.X_add_number, 0x3fff)
		      )
d2286 1
a2286 1
		      error_message = ": PC-relative operand can't be a constant";
d2289 9
a2297 24
		  /* Check for invalid constant values.  Don't warn if
		     constant was inside %hi or %lo, since these
		     truncate the constant to fit.  */
		  if (immediate_max != 0
		      && the_insn.reloc != BFD_RELOC_LO10
		      && the_insn.reloc != BFD_RELOC_HI22
		      && !in_signed_range (the_insn.exp.X_add_number,
					   immediate_max)
		      )
		    {
		      if (the_insn.pcrel)
			/* Who knows?  After relocation, we may be within
			   range.  Let the linker figure it out.  */
			{
			  the_insn.exp.X_op = O_symbol;
			  the_insn.exp.X_add_symbol = section_symbol (absolute_section);
			}
		      else
			/* Immediate value is non-pcrel, and out of
                           range.  */
			as_bad ("constant value %ld out of range (%ld .. %ld)",
				the_insn.exp.X_add_number,
				~immediate_max, immediate_max);
		    }
a2299 3
	      /* Reset to prevent extraneous range check.  */
	      immediate_max = 0;

d2319 1
a2319 1
			error_message = ": invalid ASI name";
d2327 1
a2327 1
			error_message = ": invalid ASI expression";
d2332 1
a2332 1
			error_message = ": invalid ASI number";
d2429 1
a2429 1
		      as_bad ("OPF immediate operand out of range (0-0x1ff)");
d2434 1
a2434 1
		  as_bad ("non-immediate OPF operand, ignored");
d2453 1
a2453 1
		    error_message = ": invalid cpreg name";
d2461 1
a2461 1
	      as_fatal ("failed sanity check.");
d2472 1
a2472 1
	  if (((unsigned) (&insn[1] - sparc_opcodes)) < sparc_num_opcodes
d2482 2
a2483 2
	      as_bad ("Illegal operands%s", error_message);
	      return;
d2511 1
a2511 1
		  as_warn ("architecture bumped from \"%s\" to \"%s\" on \"%s\"",
d2547 2
a2548 2
	      as_bad ("Architecture mismatch on \"%s\".", str);
	      as_tsktsk (" (Requires %s; requested architecture is %s.)",
d2551 1
a2551 1
	      return;
d2559 64
d2625 2
d2628 1
a2628 1
getExpression (str)
d2643 1
a2643 1
      the_insn.error = "bad segment";
d2651 16
a2666 1
}				/* getExpression() */
d2668 17
d2686 4
a2710 1
  char *atof_ieee ();
d2740 1
a2740 1
      return "Bad call to MD_ATOF()";
d2779 5
a2783 1
  else
d2786 1
a2786 1

d2791 1
a2791 1
md_apply_fix (fixP, value)
d2794 1
d2809 1
a2809 1
     with the calls to bfd_perform_relocation.  Also, the value passed
d2814 11
a2824 3
      if ((S_IS_EXTERNAL (fixP->fx_addsy)
	   || S_IS_WEAK (fixP->fx_addsy)
	   || (sparc_pic_code && ! fixP->fx_pcrel))
d2859 1
a2859 1
      && (fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) == 0)
d2861 15
d2884 2
a2885 1
  else if (fixP->fx_r_type == BFD_RELOC_32)
d2893 6
d2916 1
a2916 1
	      || (fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0)
d2923 2
a2924 1
	    as_bad ("relocation overflow.");
d2930 2
a2931 1
	    as_bad ("relocation overflow.");
d2935 7
d2944 2
a2945 1
	    as_bad ("relocation overflow.");
d2951 2
a2952 1
	    as_bad ("relocation overflow.");
d2960 2
a2961 1
	    as_bad ("relocation overflow.");
d2971 2
a2972 1
	    as_bad ("relocation overflow.");
d2997 2
a2998 1
	    as_bad ("relocation overflow");
d3018 5
d3025 2
a3026 1
	    as_bad ("relocation overflow");
d3037 32
d3071 3
a3073 1
	  as_bad ("bad or unhandled relocation type: 0x%02x", fixP->fx_r_type);
d3092 1
a3092 1
arelent *
d3097 1
d3101 2
a3102 2
  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  assert (reloc != 0);
d3104 2
a3105 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d3116 1
d3124 1
d3133 9
d3146 1
d3159 2
d3167 1
d3195 4
a3198 1
  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
d3202 1
a3202 1
		    "internal error: can't export reloc type %d (`%s')",
d3204 3
a3206 1
      return 0;
d3216 8
d3233 1
a3233 1
  else if ((fixp->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0)
d3237 488
a3724 3
  else
    reloc->addend = fixp->fx_offset;
#endif
d3726 7
a3732 1
  return reloc;
d3735 3
a3738 2
#if 0
/* for debugging only */
d3740 2
a3741 2
print_insn (insn)
     struct sparc_it *insn;
d3743 1
a3743 48
  const char *const Reloc[] = {
    "RELOC_8",
    "RELOC_16",
    "RELOC_32",
    "RELOC_DISP8",
    "RELOC_DISP16",
    "RELOC_DISP32",
    "RELOC_WDISP30",
    "RELOC_WDISP22",
    "RELOC_HI22",
    "RELOC_22",
    "RELOC_13",
    "RELOC_LO10",
    "RELOC_SFA_BASE",
    "RELOC_SFA_OFF13",
    "RELOC_BASE10",
    "RELOC_BASE13",
    "RELOC_BASE22",
    "RELOC_PC10",
    "RELOC_PC22",
    "RELOC_JMP_TBL",
    "RELOC_SEGOFF16",
    "RELOC_GLOB_DAT",
    "RELOC_JMP_SLOT",
    "RELOC_RELATIVE",
    "NO_RELOC"
  };

  if (insn->error)
    fprintf (stderr, "ERROR: %s\n");
  fprintf (stderr, "opcode=0x%08x\n", insn->opcode);
  fprintf (stderr, "reloc = %s\n", Reloc[insn->reloc]);
  fprintf (stderr, "exp = {\n");
  fprintf (stderr, "\t\tX_add_symbol = %s\n",
	   ((insn->exp.X_add_symbol != NULL)
	    ? ((S_GET_NAME (insn->exp.X_add_symbol) != NULL)
	       ? S_GET_NAME (insn->exp.X_add_symbol)
	       : "???")
	    : "0"));
  fprintf (stderr, "\t\tX_sub_symbol = %s\n",
	   ((insn->exp.X_op_symbol != NULL)
	    ? (S_GET_NAME (insn->exp.X_op_symbol)
	       ? S_GET_NAME (insn->exp.X_op_symbol)
	       : "???")
	    : "0"));
  fprintf (stderr, "\t\tX_add_number = %d\n",
	   insn->exp.X_add_number);
  fprintf (stderr, "}\n");
a3744 41
#endif

/*
 * md_parse_option
 *	Invocation line includes a switch not recognized by the base assembler.
 *	See if it's a processor-specific option.  These are:
 *
 *	-bump
 *		Warn on architecture bumps.  See also -A.
 *
 *	-Av6, -Av7, -Av8, -Av9, -Av9a, -Asparclite
 *	-xarch=v8plus, -xarch=v8plusa
 *		Select the architecture.  Instructions or features not
 *		supported by the selected architecture cause fatal errors.
 *
 *		The default is to start at v6, and bump the architecture up
 *		whenever an instruction is seen at a higher level.  If 32 bit
 *		environments, v9 is not bumped up to, the user must pass -Av9.
 *
 *		-xarch=v8plus{,a} is for compatibility with the Sun assembler.
 *
 *		If -bump is specified, a warning is printing when bumping to
 *		higher levels.
 *
 *		If an architecture is specified, all instructions must match
 *		that architecture.  Any higher level instructions are flagged
 *		as errors.  Note that in the 32 bit environment specifying
 *		-Av9 does not automatically create a v9 object file, a v9
 *		insn must be seen.
 *
 *		If both an architecture and -bump are specified, the
 *		architecture starts at the specified level, but bumps are
 *		warnings.  Note that we can't set `current_architecture' to
 *		the requested level in this case: in the 32 bit environment,
 *		we still must avoid creating v9 object files unless v9 insns
 *		are seen.
 *
 * Note:
 *		Bumping between incompatible architectures is always an
 *		error.  For example, from sparclite to v9.
 */
d3747 6
a3752 24
CONST char *md_shortopts = "A:K:VQ:sq";
#else
#ifdef OBJ_AOUT
CONST char *md_shortopts = "A:k";
#else
CONST char *md_shortopts = "A:";
#endif
#endif
struct option md_longopts[] = {
#define OPTION_BUMP (OPTION_MD_BASE)
  {"bump", no_argument, NULL, OPTION_BUMP},
#define OPTION_SPARC (OPTION_MD_BASE + 1)
  {"sparc", no_argument, NULL, OPTION_SPARC},
#define OPTION_XARCH (OPTION_MD_BASE + 2)
  {"xarch", required_argument, NULL, OPTION_XARCH},
#ifdef SPARC_BIENDIAN
#define OPTION_LITTLE_ENDIAN (OPTION_MD_BASE + 3)
  {"EL", no_argument, NULL, OPTION_LITTLE_ENDIAN},
#define OPTION_BIG_ENDIAN (OPTION_MD_BASE + 4)
  {"EB", no_argument, NULL, OPTION_BIG_ENDIAN},
#endif
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof(md_longopts);
d3754 3
a3756 4
int
md_parse_option (c, arg)
     int c;
     char *arg;
d3758 32
a3789 1
  switch (c)
d3791 7
a3797 14
    case OPTION_BUMP:
      warn_on_bump = 1;
      warn_after_architecture = SPARC_OPCODE_ARCH_V6;
      break;

    case OPTION_XARCH:
      /* ??? We could add v8plus and v8plusa to sparc_opcode_archs.
	 But we might want v8plus to mean something different than v9
	 someday, and we'd recognize more -xarch options than Sun's
	 assembler does (which may lead to a conflict someday).  */
      if (strcmp (arg, "v8plus") == 0)
	arg = "v9";
      else if (strcmp (arg, "v8plusa") == 0)
	arg = "v9a";
d3800 32
a3831 2
	  as_bad ("invalid architecture -xarch=%s", arg);
	  return 0;
d3833 1
d3835 1
a3835 1
      /* fall through */
d3837 2
a3838 3
    case 'A':
      {
	enum sparc_opcode_arch_val new_arch = sparc_opcode_lookup_arch (arg);
d3840 13
a3852 12
	if (new_arch == SPARC_OPCODE_ARCH_BAD)
	  {
	    as_bad ("invalid architecture -A%s", arg);
	    return 0;
	  }
	else
	  {
	    max_architecture = new_arch;
	    architecture_requested = 1;
	  }
      }
      break;
d3854 3
a3856 3
    case OPTION_SPARC:
      /* Ignore -sparc, used by SunOS make default .s.o rule.  */
      break;
d3858 3
a3860 7
#ifdef SPARC_BIENDIAN
    case OPTION_LITTLE_ENDIAN:
      target_big_endian = 0;
      break;
    case OPTION_BIG_ENDIAN:
      target_big_endian = 1;
      break;
d3863 10
a3872 5
#ifdef OBJ_AOUT
    case 'k':
      sparc_pic_code = 1;
      break;
#endif
d3874 6
a3879 4
#ifdef OBJ_ELF
    case 'V':
      print_version_id ();
      break;
d3881 3
a3883 4
    case 'Q':
      /* Qy - do emit .comment
	 Qn - do not emit .comment */
      break;
d3885 6
a3890 3
    case 's':
      /* use .stab instead of .stab.excl */
      break;
d3892 3
a3894 3
    case 'q':
      /* quick -- native assembler does fewer checks */
      break;
d3896 1
a3896 7
    case 'K':
      if (strcmp (arg, "PIC") != 0)
	as_warn ("Unrecognized option following -K");
      else
	sparc_pic_code = 1;
      break;
#endif
d3898 5
a3902 2
    default:
      return 0;
d3905 4
a3908 1
  return 1;
d3911 3
d3915 2
a3916 2
md_show_usage (stream)
     FILE *stream;
d3918 4
a3921 4
  const struct sparc_opcode_arch *arch;

  fprintf(stream, "SPARC options:\n");
  for (arch = &sparc_opcode_archs[0]; arch->name; arch++)
d3923 27
a3949 3
      if (arch != &sparc_opcode_archs[0])
	fprintf (stream, " | ");
      fprintf (stream, "-A%s", arch->name);
a3950 22
  fprintf (stream, "\n-xarch=v8plus | -xarch=v8plusa\n");
  fprintf (stream, "\
			specify variant of SPARC architecture\n\
-bump			warn when assembler switches architectures\n\
-sparc			ignored\n");
#ifdef OBJ_AOUT
  fprintf (stream, "\
-k			generate PIC\n");
#endif
#ifdef OBJ_ELF
  fprintf (stream, "\
-KPIC			generate PIC\n\
-V			print assembler version number\n\
-q			ignored\n\
-Qy, -Qn		ignored\n\
-s			ignored\n");
#endif
#ifdef SPARC_BIENDIAN
  fprintf (stream, "\
-EL			generate code for a little endian machine\n\
-EB			generate code for a big endian machine\n");
#endif
a3951 2

/* We have no need to default values of symbols. */
d3953 2
a3954 7
/* ARGSUSED */
symbolS *
md_undefined_symbol (name)
     char *name;
{
  return 0;
}				/* md_undefined_symbol() */
d3956 2
a3957 5
/* Round up a section size to the appropriate boundary. */
valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
d3959 21
a3979 12
#ifndef OBJ_ELF
  /* This is not right for ELF; a.out wants it, and COFF will force
     the alignment anyways.  */
  valueT align = ((valueT) 1
		  << (valueT) bfd_get_section_alignment (stdoutput, segment));
  valueT newsize;
  /* turn alignment value into a mask */
  align--;
  newsize = (size + align) & ~align;
  return newsize;
#else
  return size;
d3981 22
d4005 4
a4008 7
/* Exactly what point is a PC-relative offset relative TO?
   On the sparc, they're relative to the address of the offset, plus
   its size.  This gets us to the following instruction.
   (??? Is this right?  FIXME-SOON) */
long 
md_pcrel_from (fixP)
     fixS *fixP;
d4010 5
a4014 8
  long ret;

  ret = fixP->fx_where + fixP->fx_frag->fr_address;
  if (! sparc_pic_code
      || fixP->fx_addsy == NULL
      || (fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0)
    ret += fixP->fx_size;
  return ret;
d4016 1
a4017 1
/* end of tc-sparc.c */
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d37 1
a37 1
   The native assembler works this way. The user is required to pass
d61 7
d93 3
a99 3
  {"uahalf", s_uacons, 2},
  {"uaword", s_uacons, 4},
  {"uaxword", s_uacons, 8},
d198 11
d222 12
a233 1
#define	SPECIAL_CASE_FDIV	2
a756 2
  target_big_endian = 1;

d809 29
a842 2
  char *toP;
  int rsd;
d845 1
d848 1
a848 2
  /* We warn about attempts to put a floating point branch in a delay
     slot.  */
d864 5
a869 2
      toP = frag_more (4);
      md_number_to_chars (toP, (valueT) 0x01000000, 4);
d872 145
a1016 14
  /* See if "set" operand is absolute and small; skip sethi if so. */
  if (special_case == SPECIAL_CASE_SET
      && the_insn.exp.X_op == O_constant)
    {
      if (the_insn.exp.X_add_number >= -(1 << 12)
	  && the_insn.exp.X_add_number < (1 << 12))
	{
	  the_insn.opcode = 0x80102000	/* or %g0,imm,... */
	    | (the_insn.opcode & 0x3E000000)	/* dest reg */
	    | (the_insn.exp.X_add_number & 0x1FFF);	/* imm */
	  special_case = 0;	/* No longer special */
	  the_insn.reloc = BFD_RELOC_NONE;	/* No longer relocated */
	}
    }
d1018 7
a1024 3
  toP = frag_more (4);
  /* put out the opcode */
  md_number_to_chars (toP, (valueT) the_insn.opcode, 4);
d1026 13
a1038 10
  /* put out the symbol-dependent stuff */
  if (the_insn.reloc != BFD_RELOC_NONE)
    {
      fix_new_exp (frag_now,	/* which frag */
		   (toP - frag_now->fr_literal),	/* where */
		   4,		/* size */
		   &the_insn.exp,
		   the_insn.pcrel,
		   the_insn.reloc);
    }
d1040 8
a1047 1
  last_insn = insn;
d1049 19
a1067 20
  switch (special_case)
    {
    case SPECIAL_CASE_SET:
      special_case = 0;
      assert (the_insn.reloc == BFD_RELOC_HI22);
      /* See if "set" operand has no low-order bits; skip OR if so. */
      if (the_insn.exp.X_op == O_constant
	  && ((the_insn.exp.X_add_number & 0x3FF) == 0))
	return;
      toP = frag_more (4);
      rsd = (the_insn.opcode >> 25) & 0x1f;
      the_insn.opcode = 0x80102000 | (rsd << 25) | (rsd << 14);
      md_number_to_chars (toP, (valueT) the_insn.opcode, 4);
      fix_new_exp (frag_now,	/* which frag */
		   (toP - frag_now->fr_literal),	/* where */
		   4,		/* size */
		   &the_insn.exp,
		   the_insn.pcrel,
		   BFD_RELOC_LO10);
      return;
d1070 4
a1073 12
      /* According to information leaked from Sun, the "fdiv" instructions
	 on early SPARC machines would produce incorrect results sometimes.
	 The workaround is to add an fmovs of the destination register to
	 itself just after the instruction.  This was true on machines
	 with Weitek 1165 float chips, such as the Sun-4/260 and /280. */
      special_case = 0;
      assert (the_insn.reloc == BFD_RELOC_NONE);
      toP = frag_more (4);
      rsd = (the_insn.opcode >> 25) & 0x1f;
      the_insn.opcode = 0x81A00020 | (rsd << 25) | rsd;	/* fmovs dest,dest */
      md_number_to_chars (toP, (valueT) the_insn.opcode, 4);
      return;
d1075 10
a1084 2
    case 0:
      return;
d1087 1
a1087 1
      as_fatal ("failed sanity check.");
a1090 11
/* Implement big shift right.  */
static bfd_vma
BSR (val, amount)
     bfd_vma val;
     int amount;
{
  if (sizeof (bfd_vma) <= 4 && amount >= 32)
    as_fatal ("Support for 64-bit arithmetic not compiled in.");
  return val >> amount;
}

d1817 4
d1891 1
a1891 1
		for (s1 = s; *s1 && *s1 != ',' && *s1 != ']'; s1++);;
d2048 2
a2049 1
	      if (strcmp (str, "set") == 0)
d2054 10
d2289 1
a2289 1
  int prec;
a2290 1
  LITTLENUM_TYPE *wordP;
a2295 1

d2324 1
d2329 2
a2330 1
  for (wordP = words; prec--;)
d2332 5
a2336 2
      md_number_to_chars (litP, (valueT) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
d2338 9
d2350 3
a2352 3
/*
 * Write out big-endian.
 */
d2359 4
a2362 1
  number_to_chars_bigendian (buf, val, n);
d2375 1
d2432 11
a2442 1
  switch (fixP->fx_r_type)
d2444 5
a2448 4
    case BFD_RELOC_16:
      buf[0] = val >> 8;
      buf[1] = val;
      break;
d2450 17
a2466 6
    case BFD_RELOC_32:
      buf[0] = val >> 24;
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;
d2468 5
a2472 13
    case BFD_RELOC_32_PCREL_S2:
      val = val >> 2;
      /* FIXME: This increment-by-one deserves a comment of why it's
	 being done!  */
      if (! sparc_pic_code
	  || fixP->fx_addsy == NULL
	  || (fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0)
	++val;
      buf[0] |= (val >> 24) & 0x3f;
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;
d2474 5
a2478 13
    case BFD_RELOC_64:
      {
	bfd_vma valh = BSR (val, 32);
	buf[0] = valh >> 24;
	buf[1] = valh >> 16;
	buf[2] = valh >> 8;
	buf[3] = valh;
	buf[4] = val >> 24;
	buf[5] = val >> 16;
	buf[6] = val >> 8;
	buf[7] = val;
      }
      break;
d2480 5
a2484 3
    case BFD_RELOC_SPARC_11:
      if (! in_signed_range (val, 0x7ff))
	as_bad ("relocation overflow.");
d2486 5
a2490 3
      buf[2] |= (val >> 8) & 0x7;
      buf[3] = val;
      break;
d2492 9
a2500 3
    case BFD_RELOC_SPARC_10:
      if (! in_signed_range (val, 0x3ff))
	as_bad ("relocation overflow.");
d2502 9
a2510 3
      buf[2] |= (val >> 8) & 0x3;
      buf[3] = val;
      break;
d2512 3
a2514 3
    case BFD_RELOC_SPARC_6:
      if (! in_bitfield_range (val, 0x3f))
	as_bad ("relocation overflow.");
d2516 12
a2527 2
      buf[3] |= val & 0x3f;
      break;
d2529 5
a2533 3
    case BFD_RELOC_SPARC_5:
      if (! in_bitfield_range (val, 0x1f))
	as_bad ("relocation overflow.");
d2535 3
a2537 2
      buf[3] |= val & 0x1f;
      break;
d2539 11
a2549 7
    case BFD_RELOC_SPARC_WDISP16:
      /* FIXME: simplify */
      if (((val > 0) && (val & ~0x3fffc))
	  || ((val < 0) && (~(val - 1) & ~0x3fffc)))
	{
	  as_bad ("relocation overflow.");
	}
d2551 5
a2555 6
      /* FIXME: The +1 deserves a comment.  */
      val = (val >> 2) + 1;
      buf[1] |= ((val >> 14) & 0x3) << 4;
      buf[2] |= (val >> 8) & 0x3f;
      buf[3] = val;
      break;
d2557 6
a2562 7
    case BFD_RELOC_SPARC_WDISP19:
      /* FIXME: simplify */
      if (((val > 0) && (val & ~0x1ffffc))
	  || ((val < 0) && (~(val - 1) & ~0x1ffffc)))
	{
	  as_bad ("relocation overflow.");
	}
d2564 4
a2567 18
      /* FIXME: The +1 deserves a comment.  */
      val = (val >> 2) + 1;
      buf[1] |= (val >> 16) & 0x7;
      buf[2] = (val >> 8) & 0xff;
      buf[3] = val;
      break;

    case BFD_RELOC_SPARC_HH22:
      val = BSR (val, 32);
      /* intentional fallthrough */

    case BFD_RELOC_SPARC_LM22:
    case BFD_RELOC_HI22:
      if (!fixP->fx_addsy)
	{
	  buf[1] |= (val >> 26) & 0x3f;
	  buf[2] = val >> 18;
	  buf[3] = val >> 10;
a2568 20
      else
	{
	  buf[2] = 0;
	  buf[3] = 0;
	}
      break;

    case BFD_RELOC_SPARC22:
      if (val & ~0x003fffff)
	{
	  as_bad ("relocation overflow");
	}			/* on overflow */
      buf[1] |= (val >> 16) & 0x3f;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case BFD_RELOC_SPARC_HM10:
      val = BSR (val, 32);
      /* intentional fallthrough */
d2570 2
a2571 6
    case BFD_RELOC_LO10:
      if (!fixP->fx_addsy)
	{
	  buf[2] |= (val >> 8) & 0x03;
	  buf[3] = val;
	}
d2573 1
a2573 24
	buf[3] = 0;
      break;

    case BFD_RELOC_SPARC13:
      if (! in_signed_range (val, 0x1fff))
	as_bad ("relocation overflow");

      buf[2] |= (val >> 8) & 0x1f;
      buf[3] = val;
      break;

    case BFD_RELOC_SPARC_WDISP22:
      val = (val >> 2) + 1;
      /* FALLTHROUGH */
    case BFD_RELOC_SPARC_BASE22:
      buf[1] |= (val >> 16) & 0x3f;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case BFD_RELOC_NONE:
    default:
      as_bad ("bad or unhandled relocation type: 0x%02x", fixP->fx_r_type);
      break;
d2821 6
d2881 9
d2958 5
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d69 2
d76 1
a86 3
  {"uaxword", cons, 8},
#endif
#ifdef OBJ_ELF
d90 6
a95 2
  {"uaword", cons, 4},
  {"uahalf", cons, 2},
a436 1
	allocate_bss:
d504 12
d568 70
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
d16 4
a19 3
   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d30 1
a30 1
static void sparc_ip PARAMS ((char *));
d32 10
a41 2
#ifdef sparcv9
static enum sparc_architecture current_architecture = v9;
d43 4
a46 1
static enum sparc_architecture current_architecture = v6;
d48 1
d52 4
a81 1
#ifndef NO_V9
a85 1
#endif
d142 2
d157 30
d202 3
d555 1
a555 1
#ifndef NO_V9
a591 2
#endif

d594 1
d604 1
a604 1
  while (i < NUMOPCODES)
d624 1
a624 1
      while (i < NUMOPCODES
a639 1
#ifndef NO_V9
a641 1
#endif
d644 51
d701 1
d706 23
a728 1
  sparc_ip (str);
d760 2
d817 1
a817 1
   (eg: #StoreStore).
d831 1
a831 1
  for (q = p + (*p == '#'); isalpha (*q) || *q == '_'; ++q)
d878 1
a878 1
sparc_ip (str)
d880 1
d893 1
d916 1
d933 1
a942 1
#ifndef NO_V9
d1017 1
a1017 1
	      /* Parse a privileged register.  */
a1049 1
#endif
d1067 1
a1067 1
		      if (num < 16 || 31 < num)
d1069 14
a1082 3
			  error_message = ": asr number must be between 15 and 31";
			  goto error;
			}	/* out of range */
d1091 2
a1092 3
		    }		/* if %asr followed by a number. */

		}		/* if %asr */
a1094 1
#ifndef NO_V9
d1105 22
a1239 1
#endif /* NO_V9 */
d1324 1
a1418 1

d1434 4
a1480 1
#ifndef NO_V9
d1483 4
a1486 1
			error_message = ": There are only 64 f registers; [0-63]";
d1489 1
a1489 1
		    if (mask >= 32)
d1491 11
a1501 9
			mask -= 31;
		      }	/* wrap high bit */
#else
		    if (mask >= 32)
		      {
			error_message = ": There are only 32 f registers; [0-31]";
			goto error;
		      }	/* on error */
#endif
a1509 1

a1580 1
#ifndef NO_V9
d1587 1
d1595 1
a1596 1
#endif /* NO_V9 */
a1642 1
#ifndef NO_V9
a1656 2
		    default:
		      break;
d1661 2
d1664 1
a1664 1
#endif
a1780 1
#ifndef NO_V9
a1797 1
#endif /* NO_V9 */
a1810 1
#ifndef NO_V9
a1831 1
#endif
d1839 14
d1865 1
a1865 1
	  if (((unsigned) (&insn[1] - sparc_opcodes)) < NUMOPCODES
d1881 14
a1894 3
	  if (insn->architecture > current_architecture
	      || (insn->architecture != current_architecture
		  && current_architecture > v8))
d1896 32
a1927 5
	      if ((!architecture_requested || warn_on_bump)
		  && !ARCHITECTURES_CONFLICT_P (current_architecture,
						insn->architecture)
		  && !ARCHITECTURES_CONFLICT_P (insn->architecture,
						current_architecture))
d1929 1
a1929 1
		  if (warn_on_bump)
d1931 8
a1938 5
		      as_warn ("architecture bumped from \"%s\" to \"%s\" on \"%s\"",
			       architecture_pname[current_architecture],
			       architecture_pname[insn->architecture],
			       str);
		    }		/* if warning */
d1940 7
a1946 12
		  current_architecture = insn->architecture;
		}
	      else
		{
		  as_bad ("Architecture mismatch on \"%s\".", str);
		  as_tsktsk (" (Requires %s; current architecture is %s.)",
			     architecture_pname[insn->architecture],
			     architecture_pname[current_architecture]);
		  return;
		}		/* if bump ok else error */
	    }			/* if architecture higher */
	}			/* if no match */
d1949 1
a1949 1
    }				/* forever looking for a match */
d2085 2
a2086 1
      if ((S_IS_EXTERN (fixP->fx_addsy)
d2141 3
a2143 1
      val = (val >>= 2);
d2149 1
a2149 1
      buf[1] = (val >> 16);
a2153 1
#ifndef NO_V9
d2169 2
a2170 5
      if (((val > 0) && (val & ~0x7ff))
	  || ((val < 0) && (~(val - 1) & ~0x7ff)))
	{
	  as_bad ("relocation overflow.");
	}			/* on overflow */
d2173 1
a2173 1
      buf[3] = val & 0xff;
d2177 2
a2178 5
      if (((val > 0) && (val & ~0x3ff))
	  || ((val < 0) && (~(val - 1) & ~0x3ff)))
	{
	  as_bad ("relocation overflow.");
	}			/* on overflow */
d2181 15
a2195 1
      buf[3] = val & 0xff;
d2199 1
d2204 1
a2204 1
	}			/* on overflow */
d2206 2
a2207 1
      val = (val >>= 2) + 1;
d2210 1
a2210 1
      buf[3] = val & 0xff;
d2214 1
d2219 1
a2219 1
	}			/* on overflow */
d2221 2
a2222 1
      val = (val >>= 2) + 1;
d2225 1
a2225 1
      buf[3] = val & 0xff;
a2230 1
#endif /* NO_V9 */
a2231 1
#ifndef NO_V9
a2232 1
#endif
d2254 1
a2254 1
      buf[3] = val & 0xff;
a2256 1
#ifndef NO_V9
a2259 1
#endif /* NO_V9 */
d2330 2
d2362 2
a2363 1
	      || S_IS_EXTERNAL (fixp->fx_addsy))
d2491 2
a2492 1
 *	-Av6, -Av7, -Av8, -Av9, -Asparclite
d2497 4
a2500 1
 *		whenever an instruction is seen at a higher level.
d2507 3
a2509 1
 *		as errors.
d2511 1
a2511 1
 *		if both an architecture and -bump are specified, the
d2513 4
a2516 1
 *		warnings.
d2537 2
d2552 1
d2555 17
d2574 1
a2574 2
	char *p = arg;
	const char **arch;
d2576 1
a2576 1
	for (arch = architecture_pname; *arch != NULL; ++arch)
d2578 1
a2578 7
	    if (strcmp (p, *arch) == 0)
	      break;
	  }

	if (*arch == NULL)
	  {
	    as_bad ("invalid architecture -A%s", p);
d2583 1
a2583 9
	    enum sparc_architecture new_arch = arch - architecture_pname;
#ifdef NO_V9
	    if (new_arch == v9)
	      {
		as_error ("v9 support not compiled in");
		return 0;
	      }
#endif
	    current_architecture = new_arch;
d2629 1
a2629 1
 return 1;
d2636 2
a2637 1
  const char **arch;
d2639 1
a2639 1
  for (arch = architecture_pname; *arch; arch++)
d2641 1
a2641 1
      if (arch != architecture_pname)
d2643 1
a2643 1
      fprintf (stream, "-A%s", *arch);
d2645 2
a2646 1
  fprintf (stream, "\n\
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90-95, 1996 Free Software Foundation, Inc.
d16 3
a18 4
   You should have received a copy of the GNU General Public
   License along with GAS; see the file COPYING.  If not, write
   to the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA. */
d29 1
a29 1
static void sparc_ip PARAMS ((char *, const struct sparc_opcode **));
d31 2
a32 10
/* Current architecture.  We don't bump up unless necessary.  */
static enum sparc_opcode_arch_val current_architecture = SPARC_OPCODE_ARCH_V6;

/* The maximum architecture level we can bump up to.
   In a 32 bit environment, don't allow bumping up to v9 by default.
   The native assembler works this way. The user is required to pass
   an explicit argument before we'll create v9 object files.  However, if
   we don't see any v9 insns, a v9 object file is not created.  */
#ifdef SPARC_ARCH64
static enum sparc_opcode_arch_val max_architecture = SPARC_OPCODE_ARCH_V9;
d34 1
a34 4
/* ??? This should be V8, but sparclite support was added by making it the
   default.  GCC now passes -Asparclite, so maybe sometime in the future
   we can set this to V8.  */
static enum sparc_opcode_arch_val max_architecture = SPARC_OPCODE_ARCH_SPARCLITE;
a35 1

a38 4
/* If warn_on_bump and the needed architecture is higher than this
   architecture, issue a warning.  */
static enum sparc_opcode_arch_val warn_after_architecture;

d65 1
d70 1
a126 2
/* Return non-zero if VAL is in the range -(MAX+1) to MAX.  */

a139 30
/* Return non-zero if VAL is in the range -(MAX/2+1) to MAX.
   (e.g. -15 to +31).  */

static INLINE int
in_bitfield_range (val, max)
     bfd_signed_vma val, max;
{
  if (max <= 0)
    abort ();
  if (val > max)
    return 0;
  if (val < ~(max >> 1))
    return 0;
  return 1;
}

static int
sparc_ffs (mask)
     unsigned int mask;
{
  int i;

  if (mask == 0)
    return -1;

  for (i = 0; (mask & 1) == 0; ++i)
    mask >>= 1;
  return i;
}

a154 3
/* The last instruction to be assembled.  */
static const struct sparc_opcode *last_insn;

d505 1
a505 1
/* sparc64 priviledged registers */
d542 2
a545 1

d555 1
a555 1
  while (i < sparc_num_opcodes)
d575 1
a575 1
      while (i < sparc_num_opcodes
d591 1
d594 1
a596 51

  /* If -bump, record the architecture level at which we start issuing
     warnings.  The behaviour is different depending upon whether an
     architecture was explicitly specified.  If it wasn't, we issue warnings
     for all upwards bumps.  If it was, we don't start issuing warnings until
     we need to bump beyond the requested architecture or when we bump between
     conflicting architectures.  */

  if (warn_on_bump
      && architecture_requested)
    {
      /* `max_architecture' records the requested architecture.
	 Issue warnings if we go above it.  */
      warn_after_architecture = max_architecture;

      /* Find the highest architecture level that doesn't conflict with
	 the requested one.  */
      for (max_architecture = SPARC_OPCODE_ARCH_MAX;
	   max_architecture > warn_after_architecture;
	   --max_architecture)
	if (! SPARC_OPCODE_CONFLICT_P (max_architecture,
				       warn_after_architecture))
	  break;
    }
}

/* Called after all assembly has been done.  */

void
sparc_md_end ()
{
#ifdef SPARC_ARCH64
  if (current_architecture == SPARC_OPCODE_ARCH_V9A)
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v9a);
  else
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v9);
#else
  if (current_architecture == SPARC_OPCODE_ARCH_V9)
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v8plus);
  else if (current_architecture == SPARC_OPCODE_ARCH_V9A)
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v8plusa);
  else if (current_architecture == SPARC_OPCODE_ARCH_SPARCLET)
    bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_sparclet);
  else
    {
      /* The sparclite is treated like a normal sparc.  Perhaps it shouldn't
	 be but for now it is (since that's the way it's always been
	 treated).  */
      bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc);
    }
#endif
a602 1
  const struct sparc_opcode *insn;
d607 1
a607 23
  sparc_ip (str, &insn);

  /* We warn about attempts to put a floating point branch in a delay
     slot.  */
  if (insn != NULL
      && last_insn != NULL
      && (insn->flags & F_FBR) != 0
      && (last_insn->flags & F_DELAYED) != 0)
    as_warn ("FP branch in delay slot");

  /* SPARC before v9 requires a nop instruction between a floating
     point instruction and a floating point branch.  We insert one
     automatically, with a warning.  */
  if (max_architecture < SPARC_OPCODE_ARCH_V9
      && insn != NULL
      && last_insn != NULL
      && (insn->flags & F_FBR) != 0
      && (last_insn->flags & F_FLOAT) != 0)
    {
      as_warn ("FP branch preceded by FP instruction; NOP inserted");
      toP = frag_more (4);
      md_number_to_chars (toP, (valueT) 0x01000000, 4);
    }
a638 2
  last_insn = insn;

d694 1
a694 1
   (eg: #StoreStore or %ccfr).
d708 1
a708 1
  for (q = p + (*p == '#' || *p == '%'); isalpha (*q) || *q == '_'; ++q)
d755 1
a755 1
sparc_ip (str, pinsn)
a756 1
     const struct sparc_opcode **pinsn;
a768 1
  int v9_arg_p;
a790 1
  *pinsn = insn;
a806 1
      v9_arg_p = 0;
d816 1
d891 1
a891 1
	      /* Parse a sparc64 privileged register.  */
d924 1
d942 1
a942 1
		      if (current_architecture >= SPARC_OPCODE_ARCH_V9)
d944 3
a946 14
			  if (num < 16 || 31 < num)
			    {
			      error_message = ": asr number must be between 16 and 31";
			      goto error;
			    }
			}
		      else
			{
			  if (num < 0 || 31 < num)
			    {
			      error_message = ": asr number must be between 0 and 31";
			      goto error;
			    }
			}
d955 3
a957 2
		    }
		} /* if %asr */
d960 1
a970 22
	    case 'X':
	      /* V8 systems don't understand BFD_RELOC_SPARC_5.  */
	      if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
		the_insn.reloc = BFD_RELOC_SPARC_5;
	      else
		the_insn.reloc = BFD_RELOC_SPARC13;
	      /* These fields are unsigned, but for upward compatibility,
		 allow negative values as well.  */
	      immediate_max = 0x1f;
	      goto immediate;

	    case 'Y':
	      /* V8 systems don't understand BFD_RELOC_SPARC_6.  */
	      if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
		the_insn.reloc = BFD_RELOC_SPARC_6;
	      else
		the_insn.reloc = BFD_RELOC_SPARC13;
	      /* These fields are unsigned, but for upward compatibility,
		 allow negative values as well.  */
	      immediate_max = 0x3f;
	      goto immediate;

d1084 1
a1168 1
	    case 'O':
d1263 1
a1278 4

		    case 'O':
		      opcode |= (mask << 25) | (mask << 0);
		      continue;
d1322 1
d1325 1
a1325 4
			if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
			  error_message = ": There are only 64 f registers; [0-63]";
			else
			  error_message = ": There are only 32 f registers; [0-31]";
d1328 1
a1328 1
		    else if (mask >= 32)
d1330 9
a1338 11
			if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
			  {
			    v9_arg_p = 1;
			    mask -= 31;	/* wrap high bit */
			  }
			else
			  {
			    error_message = ": There are only 32 f registers; [0-31]";
			    goto error;
			  }
		      }
d1347 1
d1419 1
a1425 1
		      v9_arg_p = 1;
a1432 1
		      v9_arg_p = 1;
d1434 1
d1481 1
d1496 2
a1501 2
		    default:
		      break;
d1503 1
a1503 1

d1620 1
d1638 1
d1652 1
d1674 1
a1681 14
	    case 'u':
	    case 'U':
	      {
		/* Parse a sparclet cpreg.  */
		int cpreg;
		if (! parse_keyword_arg (sparc_encode_sparclet_cpreg, &s, &cpreg))
		  {
		    error_message = ": invalid cpreg name";
		    goto error;
		  }
		opcode |= (*args == 'U' ? RS1 (cpreg) : RD (cpreg));
		continue;
	      }

d1694 1
a1694 1
	  if (((unsigned) (&insn[1] - sparc_opcodes)) < sparc_num_opcodes
d1710 3
a1712 4
	  /* We have a match.  Now see if the architecture is ok.  */
	  int needed_arch_mask = insn->architecture;

	  if (v9_arg_p)
d1714 13
a1726 4
	      needed_arch_mask &= ~ ((1 << SPARC_OPCODE_ARCH_V9)
				     | (1 << SPARC_OPCODE_ARCH_V9A));
	      needed_arch_mask |= (1 << SPARC_OPCODE_ARCH_V9);
	    }
d1728 1
a1728 18
	  if (needed_arch_mask & SPARC_OPCODE_SUPPORTED (current_architecture))
	    ; /* ok */
	  /* Can we bump up the architecture?  */
	  else if (needed_arch_mask & SPARC_OPCODE_SUPPORTED (max_architecture))
	    {
	      enum sparc_opcode_arch_val needed_architecture =
		sparc_ffs (SPARC_OPCODE_SUPPORTED (max_architecture)
			   & needed_arch_mask);

	      assert (needed_architecture <= SPARC_OPCODE_ARCH_MAX);
	      if (warn_on_bump
		  && needed_architecture > warn_after_architecture)
		{
		  as_warn ("architecture bumped from \"%s\" to \"%s\" on \"%s\"",
			   sparc_opcode_archs[current_architecture].name,
			   sparc_opcode_archs[needed_architecture].name,
			   str);
		  warn_after_architecture = needed_architecture;
d1730 1
a1730 18
	      current_architecture = needed_architecture;
	    }
	  /* Conflict.  */
	  /* ??? This seems to be a bit fragile.  What if the next entry in
	     the opcode table is the one we want and it is supported?
	     It is possible to arrange the table today so that this can't
	     happen but what about tomorrow?  */
	  else
	    {
	      int arch,printed_one_p = 0;
	      char *p;
	      char required_archs[SPARC_OPCODE_ARCH_MAX * 16];

	      /* Create a list of the architectures that support the insn.  */
	      needed_arch_mask &= ~ SPARC_OPCODE_SUPPORTED (max_architecture);
	      p = required_archs;
	      arch = sparc_ffs (needed_arch_mask);
	      while ((1 << arch) <= needed_arch_mask)
d1732 8
a1739 18
		  if ((1 << arch) & needed_arch_mask)
		    {
		      if (printed_one_p)
			*p++ = '|';
		      strcpy (p, sparc_opcode_archs[arch].name);
		      p += strlen (p);
		      printed_one_p = 1;
		    }
		  ++arch;
		}

	      as_bad ("Architecture mismatch on \"%s\".", str);
	      as_tsktsk (" (Requires %s; requested architecture is %s.)",
			 required_archs,
			 sparc_opcode_archs[max_architecture].name);
	      return;
	    }
	} /* if no match */
d1742 1
a1742 1
    } /* forever looking for a match */
d1878 1
a1878 2
      if ((S_IS_EXTERNAL (fixP->fx_addsy)
	   || S_IS_WEAK (fixP->fx_addsy)
d1933 1
a1933 3
      val = val >> 2;
      /* FIXME: This increment-by-one deserves a comment of why it's
	 being done!  */
d1939 1
a1939 1
      buf[1] = val >> 16;
d1944 1
d1960 5
a1964 2
      if (! in_signed_range (val, 0x7ff))
	as_bad ("relocation overflow.");
d1967 1
a1967 1
      buf[3] = val;
d1971 5
a1975 2
      if (! in_signed_range (val, 0x3ff))
	as_bad ("relocation overflow.");
d1978 1
a1978 15
      buf[3] = val;
      break;

    case BFD_RELOC_SPARC_6:
      if (! in_bitfield_range (val, 0x3f))
	as_bad ("relocation overflow.");

      buf[3] |= val & 0x3f;
      break;

    case BFD_RELOC_SPARC_5:
      if (! in_bitfield_range (val, 0x1f))
	as_bad ("relocation overflow.");

      buf[3] |= val & 0x1f;
a1981 1
      /* FIXME: simplify */
d1986 1
a1986 1
	}
d1988 1
a1988 2
      /* FIXME: The +1 deserves a comment.  */
      val = (val >> 2) + 1;
d1991 1
a1991 1
      buf[3] = val;
a1994 1
      /* FIXME: simplify */
d1999 1
a1999 1
	}
d2001 1
a2001 2
      /* FIXME: The +1 deserves a comment.  */
      val = (val >> 2) + 1;
d2004 1
a2004 1
      buf[3] = val;
d2010 1
d2012 1
d2014 1
d2036 1
a2036 1
      buf[3] = val;
d2039 1
d2043 1
a2113 2
    case BFD_RELOC_SPARC_5:
    case BFD_RELOC_SPARC_6:
d2144 1
a2144 2
	      || S_IS_EXTERNAL (fixp->fx_addsy)
	      || S_IS_WEAK (fixp->fx_addsy))
d2272 1
a2272 2
 *	-Av6, -Av7, -Av8, -Av9, -Av9a, -Asparclite
 *	-xarch=v8plus, -xarch=v8plusa
d2277 1
a2277 4
 *		whenever an instruction is seen at a higher level.  If 32 bit
 *		environments, v9 is not bumped up to, the user must pass -Av9.
 *
 *		-xarch=v8plus{,a} is for compatibility with the Sun assembler.
d2284 1
a2284 3
 *		as errors.  Note that in the 32 bit environment specifying
 *		-Av9 does not automatically create a v9 object file, a v9
 *		insn must be seen.
d2286 1
a2286 1
 *		If both an architecture and -bump are specified, the
d2288 1
a2288 4
 *		warnings.  Note that we can't set `current_architecture' to
 *		the requested level in this case: in the 32 bit environment,
 *		we still must avoid creating v9 object files unless v9 insns
 *		are seen.
a2308 2
#define OPTION_XARCH (OPTION_MD_BASE + 2)
  {"xarch", required_argument, NULL, OPTION_XARCH},
a2321 1
      warn_after_architecture = SPARC_OPCODE_ARCH_V6;
a2323 17
    case OPTION_XARCH:
      /* ??? We could add v8plus and v8plusa to sparc_opcode_archs.
	 But we might want v8plus to mean something different than v9
	 someday, and we'd recognize more -xarch options than Sun's
	 assembler does (which may lead to a conflict someday).  */
      if (strcmp (arg, "v8plus") == 0)
	arg = "v9";
      else if (strcmp (arg, "v8plusa") == 0)
	arg = "v9a";
      else
	{
	  as_bad ("invalid architecture -xarch=%s", arg);
	  return 0;
	}

      /* fall through */

d2326 2
a2327 1
	enum sparc_opcode_arch_val new_arch = sparc_opcode_lookup_arch (arg);
d2329 1
a2329 1
	if (new_arch == SPARC_OPCODE_ARCH_BAD)
d2331 7
a2337 1
	    as_bad ("invalid architecture -A%s", arg);
d2342 9
a2350 1
	    max_architecture = new_arch;
d2396 1
a2396 1
  return 1;
d2403 1
a2403 2
  const struct sparc_opcode_arch *arch;

d2405 1
a2405 1
  for (arch = &sparc_opcode_archs[0]; arch->name; arch++)
d2407 1
a2407 1
      if (arch != &sparc_opcode_archs[0])
d2409 1
a2409 1
      fprintf (stream, "-A%s", arch->name);
d2411 1
a2411 2
  fprintf (stream, "\n-xarch=v8plus | -xarch=v8plusa\n");
  fprintf (stream, "\
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a68 2
static void s_empty PARAMS ((int));
static void s_uacons PARAMS ((int));
a73 1
  {"empty", s_empty, 0},
d84 3
d90 2
a91 6
  {"uahalf", s_uacons, 2},
  {"uaword", s_uacons, 4},
  {"uaxword", s_uacons, 8},
  {"2byte", s_uacons, 2},
  {"4byte", s_uacons, 4},
  {"8byte", s_uacons, 8},
d433 1
a500 12
/* Handle the .empty pseudo-op.  This supresses the warnings about
   invalid delay slot usage.  */

static void
s_empty (ignore)
     int ignore;
{
  /* The easy way to implement is to just forget about the last
     instruction.  */
  last_insn = NULL;
}

a552 70
}

/* This static variable is set by s_uacons to tell sparc_cons_align
   that the expession does not need to be aligned.  */

static int sparc_no_align_cons = 0;

/* This handles the unaligned space allocation pseudo-ops, such as
   .uaword.  .uaword is just like .word, but the value does not need
   to be aligned.  */

static void
s_uacons (bytes)
     int bytes;
{
  /* Tell sparc_cons_align not to align this value.  */
  sparc_no_align_cons = 1;
  cons (bytes);
}

/* We require .word, et. al., to be aligned correctly.  We do it by
   setting up an rs_align_code frag, and checking in HANDLE_ALIGN to
   make sure that no unexpected alignment was introduced.  */

void
sparc_cons_align (nbytes)
     int nbytes;
{
  int nalign;
  char *p;

  if (sparc_no_align_cons)
    {
      /* This is an unaligned pseudo-op.  */
      sparc_no_align_cons = 0;
      return;
    }

  nalign = 0;
  while ((nbytes & 1) == 0)
    {
      ++nalign;
      nbytes >>= 1;
    }

  if (nalign == 0)
    return;

  if (now_seg == absolute_section)
    {
      if ((abs_section_offset & ((1 << nalign) - 1)) != 0)
	as_bad ("misaligned data");
      return;
    }

  p = frag_var (rs_align_code, 1, 1, (relax_substateT) 0,
		(symbolS *) NULL, (long) nalign, (char *) NULL);

  record_alignment (now_seg, nalign);
}

/* This is where we do the unexpected alignment check.  */

void
sparc_handle_align (fragp)
     fragS *fragp;
{
  if (fragp->fr_type == rs_align_code
      && fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix != 0)
    as_bad_where (fragp->fr_file, fragp->fr_line, "misaligned data");
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d37 1
a37 1
   The native assembler works this way.  The user is required to pass
a60 7
/* V9 has big and little endian data, but instructions are always big endian.
   The sparclet has bi-endian support but both data and insns have the same
   endianness.  Global `target_big_endian' is used for data.  The following
   macro is used for instructions.  */
#define INSN_BIG_ENDIAN (target_big_endian \
			 || SPARC_OPCODE_ARCH_V9_P (max_architecture))

a85 3
  {"uahalf", s_uacons, 2},
  {"uaword", s_uacons, 4},
  {"uaxword", s_uacons, 8},
d90 3
a190 11
/* Implement big shift right.  */
static bfd_vma
BSR (val, amount)
     bfd_vma val;
     int amount;
{
  if (sizeof (bfd_vma) <= 4 && amount >= 32)
    as_fatal ("Support for 64-bit arithmetic not compiled in.");
  return val >> amount;
}

d204 1
a204 12
#define SPECIAL_CASE_SETSW	2
#define SPECIAL_CASE_SETX	3
/* FIXME: sparc-opc.c doesn't have necessary "S" trigger to enable this.  */
#define	SPECIAL_CASE_FDIV	4

/* Bit masks of various insns.  */
#define NOP_INSN 0x01000000
#define OR_INSN 0x80100000
#define FMOVS_INSN 0x81A00020
#define SETHI_INSN 0x01000000
#define SLLX_INSN 0x81281000
#define SRA_INSN 0x81380000
d728 2
a781 29
/* Utility to output one insn.  */

static void
output_insn (insn, the_insn)
     const struct sparc_opcode *insn;
     struct sparc_it *the_insn;
{
  char *toP = frag_more (4);

  /* put out the opcode */
  if (INSN_BIG_ENDIAN)
    number_to_chars_bigendian (toP, (valueT) the_insn->opcode, 4);
  else
    number_to_chars_littleendian (toP, (valueT) the_insn->opcode, 4);

  /* put out the symbol-dependent stuff */
  if (the_insn->reloc != BFD_RELOC_NONE)
    {
      fix_new_exp (frag_now,	/* which frag */
		   (toP - frag_now->fr_literal),	/* where */
		   4,		/* size */
		   &the_insn->exp,
		   the_insn->pcrel,
		   the_insn->reloc);
    }

  last_insn = insn;
}

d787 2
a790 1
  special_case = 0;
d793 2
a794 1
  /* We warn about attempts to put a floating point branch in a delay slot.  */
a809 5
      struct sparc_it nop_insn;

      nop_insn.opcode = NOP_INSN;
      nop_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &nop_insn);
d811 2
d815 14
a828 6
  switch (special_case)
    {
    case 0:
      /* normal insn */
      output_insn (insn, &the_insn);
      break;
d830 3
a832 3
    case SPECIAL_CASE_SET:
      {
	int need_hi22_p = 0;
d834 10
a843 10
	/* "set" is not defined for negative numbers in v9: it doesn't yield
	   what you expect it to.  */
	if (SPARC_OPCODE_ARCH_V9_P (max_architecture)
	    && the_insn.exp.X_op == O_constant)
	  {
	    if (the_insn.exp.X_add_number < 0)
	      as_warn ("set: used with negative number");
	    else if (the_insn.exp.X_add_number > 0xffffffff)
	      as_warn ("set: number larger than 4294967295");
	  }
d845 1
a845 26
	/* See if operand is absolute and small; skip sethi if so.  */
	if (the_insn.exp.X_op != O_constant
	    || the_insn.exp.X_add_number >= (1 << 12)
	    || the_insn.exp.X_add_number < -(1 << 12))
	  {
	    output_insn (insn, &the_insn);
	    need_hi22_p = 1;
	  }
	/* See if operand has no low-order bits; skip OR if so.  */
	if (the_insn.exp.X_op != O_constant
	    || (need_hi22_p && (the_insn.exp.X_add_number & 0x3FF) != 0)
	    || ! need_hi22_p)
	  {
	    int rd = (the_insn.opcode & RD (~0)) >> 25;
	    the_insn.opcode = (OR_INSN | (need_hi22_p ? RS1 (rd) : 0)
			       | RD (rd)
			       | IMMED
			       | (the_insn.exp.X_add_number
				  & (need_hi22_p ? 0x3ff : 0x1fff)));
	    the_insn.reloc = (the_insn.exp.X_op != O_constant
			      ? BFD_RELOC_LO10
			      : BFD_RELOC_NONE);
	    output_insn (insn, &the_insn);
	  }
	break;
      }
d847 20
a866 147
    case SPECIAL_CASE_SETSW:
      {
	/* FIXME: Not finished.  */
	break;
      }

    case SPECIAL_CASE_SETX:
      {
#define SIGNEXT32(x) ((((x) & 0xffffffff) ^ 0x80000000) - 0x80000000)
	int upper32 = SIGNEXT32 (BSR (the_insn.exp.X_add_number, 32));
	int lower32 = SIGNEXT32 (the_insn.exp.X_add_number);
#undef SIGNEXT32
	int tmpreg = (the_insn.opcode & RS1 (~0)) >> 14;
	int dstreg = (the_insn.opcode & RD (~0)) >> 25;
	/* Output directly to dst reg if lower 32 bits are all zero.  */
	int upper_dstreg = (the_insn.exp.X_op == O_constant
			    && lower32 == 0) ? dstreg : tmpreg;
	int need_hh22_p = 0, need_hm10_p = 0, need_hi22_p = 0, need_lo10_p = 0;

	/* The tmp reg should not be the dst reg.  */
	if (tmpreg == dstreg)
	  as_warn ("setx: temporary register same as destination register");

	/* Reset X_add_number, we've extracted it as upper32/lower32.
	   Otherwise fixup_segment will complain about not being able to
	   write an 8 byte number in a 4 byte field.  */
	the_insn.exp.X_add_number = 0;

	/* ??? Obviously there are other optimizations we can do
	   (e.g. sethi+shift for 0x1f0000000) and perhaps we shouldn't be
	   doing some of these.  Later.  If you do change things, try to
	   change all of this to be table driven as well.  */

	/* What to output depends on the number if it's constant.
	   Compute that first, then output what we've decided upon.  */
	if (the_insn.exp.X_op != O_constant)
	  need_hh22_p = need_hm10_p = need_hi22_p = need_lo10_p = 1;
	else
	  {
	    /* Only need hh22 if `or' insn can't handle constant.  */
	    if (upper32 < -(1 << 12) || upper32 >= (1 << 12))
	      need_hh22_p = 1;

	    /* Does bottom part (after sethi) have bits?  */
	    if ((need_hh22_p && (upper32 & 0x3ff) != 0)
		/* No hh22, but does upper32 still have bits we can't set
		   from lower32?  */
		|| (! need_hh22_p
		    && upper32 != 0
		    && (upper32 != -1 || lower32 >= 0)))
	      need_hm10_p = 1;

	    /* If the lower half is all zero, we build the upper half directly
	       into the dst reg.  */
	    if (lower32 != 0
		/* Need lower half if number is zero.  */
		|| (! need_hh22_p && ! need_hm10_p))
	      {
		/* No need for sethi if `or' insn can handle constant.  */
		if (lower32 < -(1 << 12) || lower32 >= (1 << 12)
		    /* Note that we can't use a negative constant in the `or'
		       insn unless the upper 32 bits are all ones.  */
		    || (lower32 < 0 && upper32 != -1))
		  need_hi22_p = 1;

		/* Does bottom part (after sethi) have bits?  */
		if ((need_hi22_p && (lower32 & 0x3ff) != 0)
		    /* No sethi.  */
		    || (! need_hi22_p && (lower32 & 0x1fff) != 0)
		    /* Need `or' if we didn't set anything else.  */
		    || (! need_hi22_p && ! need_hh22_p && ! need_hm10_p))
		  need_lo10_p = 1;
	      }
	  }

	if (need_hh22_p)
	  {
	    the_insn.opcode = (SETHI_INSN | RD (upper_dstreg)
			       | ((upper32 >> 10) & 0x3fffff));
	    the_insn.reloc = (the_insn.exp.X_op != O_constant
			      ? BFD_RELOC_SPARC_HH22 : BFD_RELOC_NONE);
	    output_insn (insn, &the_insn);
	  }

	if (need_hm10_p)
	  {
	    the_insn.opcode = (OR_INSN
			       | (need_hh22_p ? RS1 (upper_dstreg) : 0)
			       | RD (upper_dstreg)
			       | IMMED
			       | (upper32
				  & (need_hh22_p ? 0x3ff : 0x1fff)));
	    the_insn.reloc = (the_insn.exp.X_op != O_constant
			      ? BFD_RELOC_SPARC_HM10 : BFD_RELOC_NONE);
	    output_insn (insn, &the_insn);
	  }

	if (need_hi22_p)
	  {
	    the_insn.opcode = (SETHI_INSN | RD (dstreg)
			       | ((lower32 >> 10) & 0x3fffff));
	    the_insn.reloc = BFD_RELOC_HI22;
	    output_insn (insn, &the_insn);
	  }

	if (need_lo10_p)
	  {
	    /* FIXME: One nice optimization to do here is to OR the low part
	       with the highpart if hi22 isn't needed and the low part is
	       positive.  */
	    the_insn.opcode = (OR_INSN | (need_hi22_p ? RS1 (dstreg) : 0)
			       | RD (dstreg)
			       | IMMED
			       | (lower32
				  & (need_hi22_p ? 0x3ff : 0x1fff)));
	    the_insn.reloc = BFD_RELOC_LO10;
	    output_insn (insn, &the_insn);
	  }

	/* If we needed to build the upper part, shift it into place.  */
	if (need_hh22_p || need_hm10_p)
	  {
	    the_insn.opcode = (SLLX_INSN | RS1 (upper_dstreg) | RD (upper_dstreg)
			       | IMMED | 32);
	    the_insn.reloc = BFD_RELOC_NONE;
	    output_insn (insn, &the_insn);
	  }

	/* If we needed to build both upper and lower parts, OR them together.  */
	if ((need_hh22_p || need_hm10_p)
	    && (need_hi22_p || need_lo10_p))
	  {
	    the_insn.opcode = (OR_INSN | RS1 (dstreg) | RS2 (upper_dstreg)
			       | RD (dstreg));
	    the_insn.reloc = BFD_RELOC_NONE;
	    output_insn (insn, &the_insn);
	  }
	/* We didn't need both regs, but we may have to sign extend lower32.  */
	else if (need_hi22_p && upper32 == -1)
	  {
	    the_insn.opcode = (SRA_INSN | RS1 (dstreg) | RD (dstreg)
			       | IMMED | 0);
	    the_insn.reloc = BFD_RELOC_NONE;
	    output_insn (insn, &the_insn);
	  }
	break;
      }
d869 12
a880 2
      {
	int rd = (the_insn.opcode >> 25) & 0x1f;
d882 2
a883 12
	output_insn (insn, &the_insn);

	/* According to information leaked from Sun, the "fdiv" instructions
	   on early SPARC machines would produce incorrect results sometimes.
	   The workaround is to add an fmovs of the destination register to
	   itself just after the instruction.  This was true on machines
	   with Weitek 1165 float chips, such as the Sun-4/260 and /280. */
	assert (the_insn.reloc == BFD_RELOC_NONE);
	the_insn.opcode = FMOVS_INSN | rd | RD (rd);
	output_insn (insn, &the_insn);
	break;
      }
d886 1
a886 1
      as_fatal ("failed special case insn sanity check");
d890 11
a1626 4
	    case '0':		/* 64 bit immediate (setx insn) */
	      the_insn.reloc = BFD_RELOC_NONE; /* reloc handled elsewhere */
	      goto immediate;

d1697 1
a1697 1
		for (s1 = s; *s1 && *s1 != ',' && *s1 != ']'; s1++) ;
d1854 1
a1854 2
	      if (strcmp (str, "set") == 0
		  || strcmp (str, "setuw") == 0)
a1858 10
	      else if (strcmp (str, "setsw") == 0)
		{
		  special_case = SPECIAL_CASE_SETSW;
		  continue;
		}
	      else if (strcmp (str, "setx") == 0)
		{
		  special_case = SPECIAL_CASE_SETX;
		  continue;
		}
d2084 1
a2084 1
  int i,prec;
d2086 1
d2092 1
a2120 1

d2125 1
a2125 2

  if (target_big_endian)
d2127 2
a2128 5
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
a2129 9
  else
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litP, (valueT) words[i], sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
    }
     
d2133 3
a2135 3
/* Write a value out to the object file, using the appropriate
   endianness.  */

d2142 1
a2142 4
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
a2154 1
  long insn;
d2211 6
a2216 1
  /* If this is a data relocation, just output VAL.  */
d2218 20
a2237 15
  if (fixP->fx_r_type == BFD_RELOC_16)
    {
      md_number_to_chars (buf, val, 2);
    }
  else if (fixP->fx_r_type == BFD_RELOC_32)
    {
      md_number_to_chars (buf, val, 4);
    }
  else if (fixP->fx_r_type == BFD_RELOC_64)
    {
      md_number_to_chars (buf, val, 8);
    }
  else
    {
      /* It's a relocation against an instruction.  */
d2239 13
a2251 17
      if (INSN_BIG_ENDIAN)
	insn = bfd_getb32 ((unsigned char *) buf);
      else
	insn = bfd_getl32 ((unsigned char *) buf);
    
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_32_PCREL_S2:
	  val = val >> 2;
	  /* FIXME: This increment-by-one deserves a comment of why it's
	     being done!  */
	  if (! sparc_pic_code
	      || fixP->fx_addsy == NULL
	      || (fixP->fx_addsy->bsym->flags & BSF_SECTION_SYM) != 0)
	    ++val;
	  insn |= val & 0x3fffffff;
	  break;
d2253 3
a2255 5
	case BFD_RELOC_SPARC_11:
	  if (! in_signed_range (val, 0x7ff))
	    as_bad ("relocation overflow.");
	  insn |= val & 0x7ff;
	  break;
d2257 3
a2259 5
	case BFD_RELOC_SPARC_10:
	  if (! in_signed_range (val, 0x3ff))
	    as_bad ("relocation overflow.");
	  insn |= val & 0x3ff;
	  break;
d2261 3
a2263 5
	case BFD_RELOC_SPARC_6:
	  if (! in_bitfield_range (val, 0x3f))
	    as_bad ("relocation overflow.");
	  insn |= val & 0x3f;
	  break;
d2265 3
a2267 5
	case BFD_RELOC_SPARC_5:
	  if (! in_bitfield_range (val, 0x1f))
	    as_bad ("relocation overflow.");
	  insn |= val & 0x1f;
	  break;
d2269 3
a2271 9
	case BFD_RELOC_SPARC_WDISP16:
	  /* FIXME: simplify */
	  if (((val > 0) && (val & ~0x3fffc))
	      || ((val < 0) && (~(val - 1) & ~0x3fffc)))
	    as_bad ("relocation overflow.");
	  /* FIXME: The +1 deserves a comment.  */
	  val = (val >> 2) + 1;
	  insn |= ((val & 0xc000) << 6) | (val & 0x3fff);
	  break;
d2273 2
a2274 9
	case BFD_RELOC_SPARC_WDISP19:
	  /* FIXME: simplify */
	  if (((val > 0) && (val & ~0x1ffffc))
	      || ((val < 0) && (~(val - 1) & ~0x1ffffc)))
	    as_bad ("relocation overflow.");
	  /* FIXME: The +1 deserves a comment.  */
	  val = (val >> 2) + 1;
	  insn |= val & 0x7ffff;
	  break;
d2276 3
a2278 3
	case BFD_RELOC_SPARC_HH22:
	  val = BSR (val, 32);
	  /* intentional fallthrough */
d2280 2
a2281 12
	case BFD_RELOC_SPARC_LM22:
	case BFD_RELOC_HI22:
	  if (!fixP->fx_addsy)
	    {
	      insn |= (val >> 10) & 0x3fffff;
	    }
	  else
	    {
	      /* FIXME: Need comment explaining why we do this.  */
	      insn &= ~0xffff;
	    }
	  break;
d2283 7
a2289 5
	case BFD_RELOC_SPARC22:
	  if (val & ~0x003fffff)
	    as_bad ("relocation overflow");
	  insn |= (val & 0x3fffff);
	  break;
d2291 6
a2296 3
	case BFD_RELOC_SPARC_HM10:
	  val = BSR (val, 32);
	  /* intentional fallthrough */
d2298 7
a2304 11
	case BFD_RELOC_LO10:
	  if (!fixP->fx_addsy)
	    {
	      insn |= val & 0x3ff;
	    }
	  else
	    {
	      /* FIXME: Need comment explaining why we do this.  */
	      insn &= ~0xff;
	    }
	  break;
d2306 6
a2311 5
	case BFD_RELOC_SPARC13:
	  if (! in_signed_range (val, 0x1fff))
	    as_bad ("relocation overflow");
	  insn |= val & 0x1fff;
	  break;
d2313 3
a2315 6
	case BFD_RELOC_SPARC_WDISP22:
	  val = (val >> 2) + 1;
	  /* FALLTHROUGH */
	case BFD_RELOC_SPARC_BASE22:
	  insn |= val & 0x3fffff;
	  break;
d2317 12
a2328 4
	case BFD_RELOC_NONE:
	default:
	  as_bad ("bad or unhandled relocation type: 0x%02x", fixP->fx_r_type);
	  break;
d2330 15
d2346 6
a2351 2
      if (INSN_BIG_ENDIAN)
	bfd_putb32 (insn, (unsigned char *) buf);
d2353 24
a2376 1
	bfd_putl32 (insn, (unsigned char *) buf);
a2623 6
#ifdef SPARC_BIENDIAN
#define OPTION_LITTLE_ENDIAN (OPTION_MD_BASE + 3)
  {"EL", no_argument, NULL, OPTION_LITTLE_ENDIAN},
#define OPTION_BIG_ENDIAN (OPTION_MD_BASE + 4)
  {"EB", no_argument, NULL, OPTION_BIG_ENDIAN},
#endif
a2677 9
#ifdef SPARC_BIENDIAN
    case OPTION_LITTLE_ENDIAN:
      target_big_endian = 0;
      break;
    case OPTION_BIG_ENDIAN:
      target_big_endian = 1;
      break;
#endif

a2745 5
#endif
#ifdef SPARC_BIENDIAN
  fprintf (stream, "\
-EL			generate code for a little endian machine\n\
-EB			generate code for a big endian machine\n");
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90-96, 1997 Free Software Foundation, Inc.
a30 7
static int in_signed_range PARAMS ((bfd_signed_vma, bfd_signed_vma));
static int in_bitfield_range PARAMS ((bfd_signed_vma, bfd_signed_vma));
static int sparc_ffs PARAMS ((unsigned int));
static bfd_vma BSR PARAMS ((bfd_vma, int));
static int cmp_reg_entry PARAMS ((const PTR, const PTR));
static int parse_keyword_arg PARAMS ((int (*) (const char *), char **, int *));
static int parse_const_expr_arg PARAMS ((char **, int *));
a58 3
/* Non-zero if we should give an error when misaligned data is seen.  */
static int enforce_aligned_data;

a152 3
static void output_insn
  PARAMS ((const struct sparc_opcode *, struct sparc_it *));

d355 1
a355 1
	    frag_align (align, 0, 0); /* do alignment */
d363 1
a363 1
			    (offsetT) size, (char *)0);
d413 1
a413 1
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d472 1
a472 1
	    frag_align (align, 0, 0);
d476 2
a477 2
	  p = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			(offsetT) size, (char *) 0);
d492 2
a493 1
	  S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
a514 5

#ifdef BFD_ASSEMBLER
  symbolP->bsym->flags |= BSF_OBJECT;
#endif

d617 3
a619 10
/* If the --enforce-aligned-data option is used, we require .word,
   et. al., to be aligned correctly.  We do it by setting up an
   rs_align_code frag, and checking in HANDLE_ALIGN to make sure that
   no unexpected alignment was introduced.

   The SunOS and Solaris native assemblers enforce aligned data by
   default.  We don't want to do that, because gcc can deliberately
   generate misaligned data if the packed attribute is used.  Instead,
   we permit misaligned data by default, and permit the user to set an
   option to check for it.  */
a627 4
  /* Only do this if we are enforcing aligned data.  */
  if (! enforce_aligned_data)
    return;

d653 1
a653 1
		(symbolS *) NULL, (offsetT) nalign, (char *) NULL);
d700 2
a701 3
cmp_reg_entry (parg, qarg)
     const PTR parg;
     const PTR qarg;
a702 3
  const struct priv_reg_entry *p = (const struct priv_reg_entry *) parg;
  const struct priv_reg_entry *q = (const struct priv_reg_entry *) qarg;

d1098 1
a1098 1
     int (*lookup_fn) PARAMS ((const char *));
d2292 1
d2369 1
a2369 1
md_apply_fix3 (fixP, value, segment)
a2371 1
     segT segment;
d2386 1
a2386 1
     with the calls to bfd_install_relocation.  Also, the value passed
d2391 3
a2393 11
      if (fixP->fx_addsy->sy_used_in_reloc
	  && (S_IS_EXTERNAL (fixP->fx_addsy)
	      || S_IS_WEAK (fixP->fx_addsy)
	      || (sparc_pic_code && ! fixP->fx_pcrel)
	      || (S_GET_SEGMENT (fixP->fx_addsy) != segment
		  && ((bfd_get_section_flags (stdoutput,
					      S_GET_SEGMENT (fixP->fx_addsy))
		       & SEC_LINK_ONCE) != 0
		      || strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
				  ".gnu.linkonce",
				  sizeof ".gnu.linkonce" - 1) == 0)))
d2593 2
a2594 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
a2643 1
	      || S_IS_COMMON (fixp->fx_addsy)
a2826 2
#define OPTION_ENFORCE_ALIGNED_DATA (OPTION_MD_BASE + 5)
  {"enforce-aligned-data", no_argument, NULL, OPTION_ENFORCE_ALIGNED_DATA},
a2880 4
    case OPTION_ENFORCE_ALIGNED_DATA:
      enforce_aligned_data = 1;
      break;

d2946 1
a2946 2
-sparc			ignored\n\
--enforce-aligned-data	force .long, etc., to be aligned correctly\n");
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 1
   Copyright (C) 1989, 90-96, 97, 98, 99, 2000 Free Software Foundation, Inc.
d27 1
d30 1
a30 7
#ifdef OBJ_ELF
#include "elf/sparc.h"
#endif

static struct sparc_arch *lookup_arch PARAMS ((char *));
static void init_default_arch PARAMS ((void));
static int sparc_ip PARAMS ((char *, const struct sparc_opcode **));
a31 1
static int in_unsigned_range PARAMS ((bfd_vma, bfd_vma));
a33 3
static void synthetize_setuw PARAMS ((const struct sparc_opcode *));
static void synthetize_setsw PARAMS ((const struct sparc_opcode *));
static void synthetize_setx PARAMS ((const struct sparc_opcode *));
a37 14
static int get_expression PARAMS ((char *str));

/* Default architecture.  */
/* ??? The default value should be V8, but sparclite support was added
   by making it the default.  GCC now passes -Asparclite, so maybe sometime in
   the future we can set this to V8.  */
#ifndef DEFAULT_ARCH
#define DEFAULT_ARCH "sparclite"
#endif
static char *default_arch = DEFAULT_ARCH;

/* Non-zero if the initial values of `max_architecture' and `sparc_arch_size'
   have been set.  */
static int default_init_p;
d46 8
a53 13
   we don't see any v9 insns, a v8plus object file is not created.  */
static enum sparc_opcode_arch_val max_architecture;

/* Either 32 or 64, selects file format.  */
static int sparc_arch_size;
/* Initial (default) value, recorded separately in case a user option
   changes the value before md_show_usage is called.  */
static int default_arch_size;

#ifdef OBJ_ELF
/* The currently selected v9 memory model.  Currently only used for
   ELF.  */
static enum { MM_TSO, MM_PSO, MM_RMO } sparc_memory_model = MM_RMO;
a62 4
/* Non-zero if as should generate error if an undeclared g[23] register
   has been used in -64.  */
static int no_undeclared_regs;

d71 4
a74 10
static int target_little_endian_data;

/* Symbols for global registers on v9.  */
static symbolS *globals[8];

/* V9 and 86x have big and little endian data, but instructions are always big
   endian.  The sparclet has bi-endian support but both data and insns have
   the same endianness.  Global `target_big_endian' is used for data.
   The following macro is used for instructions.  */
#ifndef INSN_BIG_ENDIAN
a75 1
			 || default_arch_type == sparc86x \
a76 1
#endif
a80 1
static int log2 PARAMS ((int));
a87 2
static void s_ncons PARAMS ((int));
static void s_register PARAMS ((int));
a95 1
  {"nword", s_ncons, 0},
d108 2
a112 1
  {"register", s_register, 0},
d147 3
a149 1
#define isoctal(c)  ((unsigned)((c) - '0') < '8')
a156 1
    expressionS exp2;
a164 5

/* Table of arguments to -A.
   The sparc_opcode_arch table in sparc-opc.c is insufficient and incorrect
   for this use.  That table is for opcodes only.  This table is for opcodes
   and file formats.  */
d166 1
a166 2
enum sparc_arch_types {v6, v7, v8, sparclet, sparclite, sparc86x, v8plus,
		       v8plusa, v9, v9a, v9_64};
d168 12
a179 25
static struct sparc_arch {
  char *name;
  char *opcode_arch;
  enum sparc_arch_types arch_type;
  /* Default word size, as specified during configuration.
     A value of zero means can't be used to specify default architecture.  */
  int default_arch_size;
  /* Allowable arg to -A?  */
  int user_option_p;
} sparc_arch_table[] = {
  { "v6", "v6", v6, 0, 1 },
  { "v7", "v7", v7, 0, 1 },
  { "v8", "v8", v8, 32, 1 },
  { "sparclet", "sparclet", sparclet, 32, 1 },
  { "sparclite", "sparclite", sparclite, 32, 1 },
  { "sparc86x", "sparclite", sparc86x, 32, 1 },
  { "v8plus", "v9", v9, 0, 1 },
  { "v8plusa", "v9a", v9, 0, 1 },
  { "v9", "v9", v9, 0, 1 },
  { "v9a", "v9a", v9, 0, 1 },
  /* This exists to allow configure.in/Makefile.in to pass one
     value to specify both the default machine and default word size.  */
  { "v9-64", "v9", v9, 64, 0 },
  { NULL, NULL, v8, 0, 0 }
};
d181 2
a182 2
/* Variant of default_arch */
static enum sparc_arch_types default_arch_type;
d184 3
a186 3
static struct sparc_arch *
lookup_arch (name)
     char *name;
d188 7
a194 8
  struct sparc_arch *sa;

  for (sa = &sparc_arch_table[0]; sa->name != NULL; sa++)
    if (strcmp (sa->name, name) == 0)
      break;
  if (sa->name == NULL)
    return NULL;
  return sa;
d197 3
a199 5
/* Initialize the default opcode arch and word size from the default
   architecture name.  */

static void
init_default_arch ()
d201 1
a201 1
  struct sparc_arch *sa = lookup_arch (default_arch);
d203 2
a204 3
  if (sa == NULL
      || sa->default_arch_size == 0)
    as_fatal (_("Invalid default architecture, broken assembler."));
d206 3
a208 6
  max_architecture = sparc_opcode_lookup_arch (sa->opcode_arch);
  if (max_architecture == SPARC_OPCODE_ARCH_BAD)
    as_fatal (_("Bad opcode table, broken assembler."));
  default_arch_size = sparc_arch_size = sa->default_arch_size;
  default_init_p = 1;
  default_arch_type = sa->arch_type;
d211 5
a215 4
/* Called by TARGET_FORMAT.  */

const char *
sparc_target_format ()
d217 4
a220 4
  /* We don't get a chance to initialize anything before we're called,
     so handle that now.  */
  if (! default_init_p)
    init_default_arch ();
d222 2
a223 14
#ifdef OBJ_AOUT
#ifdef TE_NetBSD
  return "a.out-sparc-netbsd";
#else
#ifdef TE_SPARCAOUT
  if (target_big_endian)
    return "a.out-sunos-big";
  else if (default_arch_type == sparc86x && target_little_endian_data)
    return "a.out-sunos-big";
  else return "a.out-sparc-little";
#else
  return "a.out-sunos-big";
#endif
#endif
d225 4
d230 9
a238 3
#ifdef OBJ_BOUT
  return "b.out.big";
#endif
d240 7
a246 7
#ifdef OBJ_COFF
#ifdef TE_LYNX
  return "coff-sparc-lynx";
#else
  return "coff-sparc";
#endif
#endif
d248 2
a249 3
#ifdef OBJ_ELF
  return sparc_arch_size == 64 ? "elf64-sparc" : "elf32-sparc";
#endif
a250 3
  abort ();
}

d252 1
a252 44
 * md_parse_option
 *	Invocation line includes a switch not recognized by the base assembler.
 *	See if it's a processor-specific option.  These are:
 *
 *	-bump
 *		Warn on architecture bumps.  See also -A.
 *
 *	-Av6, -Av7, -Av8, -Asparclite, -Asparclet
 *		Standard 32 bit architectures.
 *	-Av8plus, -Av8plusa
 *		Sparc64 in a 32 bit world.
 *	-Av9, -Av9a
 *		Sparc64 in either a 32 or 64 bit world (-32/-64 says which).
 *		This used to only mean 64 bits, but properly specifying it
 *		complicated gcc's ASM_SPECs, so now opcode selection is
 *		specified orthogonally to word size (except when specifying
 *		the default, but that is an internal implementation detail).
 *	-xarch=v8plus, -xarch=v8plusa
 *		Same as -Av8plus{,a}, for compatibility with Sun's assembler.
 *
 *		Select the architecture and possibly the file format.
 *		Instructions or features not supported by the selected
 *		architecture cause fatal errors.
 *
 *		The default is to start at v6, and bump the architecture up
 *		whenever an instruction is seen at a higher level.  In 32 bit
 *		environments, v9 is not bumped up to, the user must pass
 * 		-Av8plus{,a}.
 *
 *		If -bump is specified, a warning is printing when bumping to
 *		higher levels.
 *
 *		If an architecture is specified, all instructions must match
 *		that architecture.  Any higher level instructions are flagged
 *		as errors.  Note that in the 32 bit environment specifying
 *		-Av8plus does not automatically create a v8plus object file, a
 *		v9 insn must be seen.
 *
 *		If both an architecture and -bump are specified, the
 *		architecture starts at the specified level, but bumps are
 *		warnings.  Note that we can't set `current_architecture' to
 *		the requested level in this case: in the 32 bit environment,
 *		we still must avoid creating v8plus object files unless v9
 * 		insns are seen.
a253 3
 * Note:
 *		Bumping between incompatible architectures is always an
 *		error.  For example, from sparclite to v9.
d255 2
a256 44

#ifdef OBJ_ELF
CONST char *md_shortopts = "A:K:VQ:sq";
#else
#ifdef OBJ_AOUT
CONST char *md_shortopts = "A:k";
#else
CONST char *md_shortopts = "A:";
#endif
#endif
struct option md_longopts[] = {
#define OPTION_BUMP (OPTION_MD_BASE)
  {"bump", no_argument, NULL, OPTION_BUMP},
#define OPTION_SPARC (OPTION_MD_BASE + 1)
  {"sparc", no_argument, NULL, OPTION_SPARC},
#define OPTION_XARCH (OPTION_MD_BASE + 2)
  {"xarch", required_argument, NULL, OPTION_XARCH},
#ifdef OBJ_ELF
#define OPTION_32 (OPTION_MD_BASE + 3)
  {"32", no_argument, NULL, OPTION_32},
#define OPTION_64 (OPTION_MD_BASE + 4)
  {"64", no_argument, NULL, OPTION_64},
#define OPTION_TSO (OPTION_MD_BASE + 5)
  {"TSO", no_argument, NULL, OPTION_TSO},
#define OPTION_PSO (OPTION_MD_BASE + 6)
  {"PSO", no_argument, NULL, OPTION_PSO},
#define OPTION_RMO (OPTION_MD_BASE + 7)
  {"RMO", no_argument, NULL, OPTION_RMO},
#endif
#ifdef SPARC_BIENDIAN
#define OPTION_LITTLE_ENDIAN (OPTION_MD_BASE + 8)
  {"EL", no_argument, NULL, OPTION_LITTLE_ENDIAN},
#define OPTION_BIG_ENDIAN (OPTION_MD_BASE + 9)
  {"EB", no_argument, NULL, OPTION_BIG_ENDIAN},
#endif
#define OPTION_ENFORCE_ALIGNED_DATA (OPTION_MD_BASE + 10)
  {"enforce-aligned-data", no_argument, NULL, OPTION_ENFORCE_ALIGNED_DATA},
#define OPTION_LITTLE_ENDIAN_DATA (OPTION_MD_BASE + 11)
  {"little-endian-data", no_argument, NULL, OPTION_LITTLE_ENDIAN_DATA},
#ifdef OBJ_ELF
#define OPTION_NO_UNDECLARED_REGS (OPTION_MD_BASE + 12)
  {"no-undeclared-regs", no_argument, NULL, OPTION_NO_UNDECLARED_REGS},
#define OPTION_UNDECLARED_REGS (OPTION_MD_BASE + 13)
  {"undeclared-regs", no_argument, NULL, OPTION_UNDECLARED_REGS},
a257 3
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof(md_longopts);
d259 3
a261 4
int
md_parse_option (c, arg)
     int c;
     char *arg;
d263 13
a275 4
  /* We don't get a chance to initialize anything before we're called,
     so handle that now.  */
  if (! default_init_p)
    init_default_arch ();
d277 1
a277 1
  switch (c)
d279 4
a282 4
    case OPTION_BUMP:
      warn_on_bump = 1;
      warn_after_architecture = SPARC_OPCODE_ARCH_V6;
      break;
d284 1
a284 8
    case OPTION_XARCH:
      /* This is for compatibility with Sun's assembler.  */
      if (strcmp (arg, "v8plus") != 0
	  && strcmp (arg, "v8plusa") != 0)
	{
	  as_bad (_("invalid architecture -xarch=%s"), arg);
	  return 0;
	}
d286 6
a291 1
      /* fall through */
d293 3
a295 4
    case 'A':
      {
	struct sparc_arch *sa;
	enum sparc_opcode_arch_val opcode_arch;
d297 6
a302 7
	sa = lookup_arch (arg);
	if (sa == NULL
	    || ! sa->user_option_p)
	  {
	    as_bad (_("invalid architecture -A%s"), arg);
	    return 0;
	  }
d304 5
a308 3
	opcode_arch = sparc_opcode_lookup_arch (sa->opcode_arch);
	if (opcode_arch == SPARC_OPCODE_ARCH_BAD)
	  as_fatal (_("Bad opcode table, broken assembler."));
d310 3
a312 4
	max_architecture = opcode_arch;
	architecture_requested = 1;
      }
      break;
d314 6
a319 3
    case OPTION_SPARC:
      /* Ignore -sparc, used by SunOS make default .s.o rule.  */
      break;
d321 7
a327 20
    case OPTION_ENFORCE_ALIGNED_DATA:
      enforce_aligned_data = 1;
      break;

#ifdef SPARC_BIENDIAN
    case OPTION_LITTLE_ENDIAN:
      target_big_endian = 0;
      if (default_arch_type != sparclet)
	as_fatal ("This target does not support -EL");
      break;
    case OPTION_LITTLE_ENDIAN_DATA:
      target_little_endian_data = 1;
      target_big_endian = 0;
      if (default_arch_type != sparc86x
	  && default_arch_type != v9)
	as_fatal ("This target does not support --little-endian-data");
      break;
    case OPTION_BIG_ENDIAN:
      target_big_endian = 1;
      break;
d329 5
d335 1
a335 5
#ifdef OBJ_AOUT
    case 'k':
      sparc_pic_code = 1;
      break;
#endif
d337 2
a338 5
#ifdef OBJ_ELF
    case OPTION_32:
    case OPTION_64:
      {
	const char **list, **l;
d340 6
a345 21
	sparc_arch_size = c == OPTION_32 ? 32 : 64;
	list = bfd_target_list ();
	for (l = list; *l != NULL; l++)
	  {
	    if (sparc_arch_size == 32)
	      {
		if (strcmp (*l, "elf32-sparc") == 0)
		  break;
	      }
	    else
	      {
		if (strcmp (*l, "elf64-sparc") == 0)
		  break;
	      }
	  }
	if (*l == NULL)
	  as_fatal (_("No compiled in support for %d bit object file format"),
		    sparc_arch_size);
	free (list);
      }
      break;
d347 4
a350 3
    case OPTION_TSO:
      sparc_memory_model = MM_TSO;
      break;
d352 12
a363 3
    case OPTION_PSO:
      sparc_memory_model = MM_PSO;
      break;
d365 1
a365 3
    case OPTION_RMO:
      sparc_memory_model = MM_RMO;
      break;
d367 2
a368 3
    case 'V':
      print_version_id ();
      break;
d370 3
a372 4
    case 'Q':
      /* Qy - do emit .comment
	 Qn - do not emit .comment */
      break;
d374 4
a377 3
    case 's':
      /* use .stab instead of .stab.excl */
      break;
d379 1
a379 3
    case 'q':
      /* quick -- native assembler does fewer checks */
      break;
d381 2
a382 18
    case 'K':
      if (strcmp (arg, "PIC") != 0)
	as_warn (_("Unrecognized option following -K"));
      else
	sparc_pic_code = 1;
      break;

    case OPTION_NO_UNDECLARED_REGS:
      no_undeclared_regs = 1;
      break;

    case OPTION_UNDECLARED_REGS:
      no_undeclared_regs = 0;
      break;
#endif

    default:
      return 0;
d384 5
d390 1
a390 1
  return 1;
d393 3
a395 3
void
md_show_usage (stream)
     FILE *stream;
d397 5
a401 1
  const struct sparc_arch *arch;
d403 14
a416 7
  /* We don't get a chance to initialize anything before we're called,
     so handle that now.  */
  if (! default_init_p)
    init_default_arch ();

  fprintf(stream, _("SPARC options:\n"));
  for (arch = &sparc_arch_table[0]; arch->name; arch++)
d418 3
a420 4
      if (arch != &sparc_arch_table[0])
	fprintf (stream, " | ");
      if (arch->user_option_p)
	fprintf (stream, "-A%s", arch->name);
d422 5
a426 138
  fprintf (stream, _("\n-xarch=v8plus | -xarch=v8plusa\n"));
  fprintf (stream, _("\
			specify variant of SPARC architecture\n\
-bump			warn when assembler switches architectures\n\
-sparc			ignored\n\
--enforce-aligned-data	force .long, etc., to be aligned correctly\n"));
#ifdef OBJ_AOUT
  fprintf (stream, _("\
-k			generate PIC\n"));
#endif
#ifdef OBJ_ELF
  fprintf (stream, _("\
-32			create 32 bit object file\n\
-64			create 64 bit object file\n"));
  fprintf (stream, _("\
			[default is %d]\n"), default_arch_size);
  fprintf (stream, _("\
-TSO			use Total Store Ordering\n\
-PSO			use Partial Store Ordering\n\
-RMO			use Relaxed Memory Ordering\n"));
  fprintf (stream, _("\
			[default is %s]\n"), (default_arch_size == 64) ? "RMO" : "TSO");
  fprintf (stream, _("\
-KPIC			generate PIC\n\
-V			print assembler version number\n\
-undeclared-regs	ignore application global register usage without\n\
			appropriate .register directive (default)\n\
-no-undeclared-regs	force error on application global register usage\n\
			without appropriate .register directive\n\
-q			ignored\n\
-Qy, -Qn		ignored\n\
-s			ignored\n"));
#endif
#ifdef SPARC_BIENDIAN
  fprintf (stream, _("\
-EL			generate code for a little endian machine\n\
-EB			generate code for a big endian machine\n\
--little-endian-data	generate code for a machine having big endian\n\
                        instructions and little endian data.\n"));
#endif
}

/* native operand size opcode translation */
struct
  {
    char *name;
    char *name32;
    char *name64;
  } native_op_table[] =
{
  {"ldn", "ld", "ldx"},
  {"ldna", "lda", "ldxa"},
  {"stn", "st", "stx"},
  {"stna", "sta", "stxa"},
  {"slln", "sll", "sllx"},
  {"srln", "srl", "srlx"},
  {"sran", "sra", "srax"},
  {"casn", "cas", "casx"},
  {"casna", "casa", "casxa"},
  {"clrn", "clr", "clrx"},
  {NULL, NULL, NULL},
};

/* sparc64 priviledged registers */

struct priv_reg_entry
  {
    char *name;
    int regnum;
  };

struct priv_reg_entry priv_reg_table[] =
{
  {"tpc", 0},
  {"tnpc", 1},
  {"tstate", 2},
  {"tt", 3},
  {"tick", 4},
  {"tba", 5},
  {"pstate", 6},
  {"tl", 7},
  {"pil", 8},
  {"cwp", 9},
  {"cansave", 10},
  {"canrestore", 11},
  {"cleanwin", 12},
  {"otherwin", 13},
  {"wstate", 14},
  {"fq", 15},
  {"ver", 31},
  {"", -1},			/* end marker */
};

/* v9a specific asrs */

struct priv_reg_entry v9a_asr_table[] =
{
  {"tick_cmpr", 23},
  {"softint", 22},
  {"set_softint", 20},
  {"pic", 17},
  {"pcr", 16},
  {"gsr", 19},
  {"dcr", 18},
  {"clear_softint", 21},
  {"", -1},			/* end marker */
};

static int
cmp_reg_entry (parg, qarg)
     const PTR parg;
     const PTR qarg;
{
  const struct priv_reg_entry *p = (const struct priv_reg_entry *) parg;
  const struct priv_reg_entry *q = (const struct priv_reg_entry *) qarg;

  return strcmp (q->name, p->name);
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables, etc. that the MD part of the assembler will need. */

void
md_begin ()
{
  register const char *retval = NULL;
  int lose = 0;
  register unsigned int i = 0;

  /* We don't get a chance to initialize anything before md_parse_option
     is called, and it may not be called, so handle default initialization
     now if not already done.  */
  if (! default_init_p)
    init_default_arch ();

  op_hash = hash_new ();

  while (i < (unsigned int) sparc_num_opcodes)
d428 3
a430 20
      const char *name = sparc_opcodes[i].name;
      retval = hash_insert (op_hash, name, (PTR) &sparc_opcodes[i]);
      if (retval != NULL)
	{
	  as_bad (_("Internal error: can't hash `%s': %s\n"),
		  sparc_opcodes[i].name, retval);
	  lose = 1;
	}
      do
	{
	  if (sparc_opcodes[i].match & sparc_opcodes[i].lose)
	    {
	      as_bad (_("Internal error: losing opcode: `%s' \"%s\"\n"),
		      sparc_opcodes[i].name, sparc_opcodes[i].args);
	      lose = 1;
	    }
	  ++i;
	}
      while (i < (unsigned int) sparc_num_opcodes
	     && !strcmp (sparc_opcodes[i].name, name));
d432 1
a432 2

  for (i = 0; native_op_table[i].name; i++)
d434 1
a434 11
      const struct sparc_opcode *insn;
      char *name = sparc_arch_size == 32 ? native_op_table[i].name32 :
			native_op_table[i].name64;
      insn = (struct sparc_opcode *)hash_find (op_hash, name);
      if (insn == NULL)
        {
          as_bad (_("Internal error: can't find opcode `%s' for `%s'\n"),
          	  name, native_op_table[i].name);
          lose = 1;
        }
      else
d436 2
a437 7
	  retval = hash_insert (op_hash, native_op_table[i].name, (PTR) insn);
	  if (retval != NULL)
	    {
	      as_bad (_("Internal error: can't hash `%s': %s\n"),
		      sparc_opcodes[i].name, retval);
	      lose = 1;
	    }
d440 1
a440 16

  if (lose)
    as_fatal (_("Broken assembler.  No assembly attempted."));

  qsort (priv_reg_table, sizeof (priv_reg_table) / sizeof (priv_reg_table[0]),
	 sizeof (priv_reg_table[0]), cmp_reg_entry);

  /* If -bump, record the architecture level at which we start issuing
     warnings.  The behaviour is different depending upon whether an
     architecture was explicitly specified.  If it wasn't, we issue warnings
     for all upwards bumps.  If it was, we don't start issuing warnings until
     we need to bump beyond the requested architecture or when we bump between
     conflicting architectures.  */

  if (warn_on_bump
      && architecture_requested)
d442 4
a445 12
      /* `max_architecture' records the requested architecture.
	 Issue warnings if we go above it.  */
      warn_after_architecture = max_architecture;

      /* Find the highest architecture level that doesn't conflict with
	 the requested one.  */
      for (max_architecture = SPARC_OPCODE_ARCH_MAX;
	   max_architecture > warn_after_architecture;
	   --max_architecture)
	if (! SPARC_OPCODE_CONFLICT_P (max_architecture,
				       warn_after_architecture))
	  break;
d447 2
a448 8
}

/* Called after all assembly has been done.  */

void
sparc_md_end ()
{
  if (sparc_arch_size == 64)
d450 3
a452 4
      if (current_architecture == SPARC_OPCODE_ARCH_V9A)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v9a);
      else
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v9);
d454 3
a456 1
  else
d458 3
a460 9
      if (current_architecture == SPARC_OPCODE_ARCH_V9)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v8plus);
      else if (current_architecture == SPARC_OPCODE_ARCH_V9A)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_v8plusa);
      else if (current_architecture == SPARC_OPCODE_ARCH_SPARCLET)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_sparclet);
      else if (default_arch_type == sparc86x && target_little_endian_data)
	bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc_sparclite_le);
      else
d462 44
a505 4
	  /* The sparclite is treated like a normal sparc.  Perhaps it shouldn't
	     be but for now it is (since that's the way it's always been
	     treated).  */
	  bfd_set_arch_mach (stdoutput, bfd_arch_sparc, bfd_mach_sparc);
d508 1
a508 13
}

/* Return non-zero if VAL is in the range -(MAX+1) to MAX.  */

static INLINE int
in_signed_range (val, max)
     bfd_signed_vma val, max;
{
  if (max <= 0)
    abort ();
  /* Sign-extend the value from the architecture word size, so that
     0xffffffff is always considered -1 on sparc32.  */
  if (sparc_arch_size == 32)
d510 16
a525 2
      bfd_signed_vma sign = (bfd_signed_vma)1 << 31;
      val = ((val & 0xffffffff) ^ sign) - sign;
a526 6
  if (val > max)
    return 0;
  if (val < ~max)
    return 0;
  return 1;
}
d528 6
a533 1
/* Return non-zero if VAL is in the range 0 to MAX.  */
d535 13
a547 7
static INLINE int
in_unsigned_range (val, max)
     bfd_vma val, max;
{
  if (val > max)
    return 0;
  return 1;
d550 2
a551 2
/* Return non-zero if VAL is in the range -(MAX/2+1) to MAX.
   (e.g. -15 to +31).  */
d553 3
a555 3
static INLINE int
in_bitfield_range (val, max)
     bfd_signed_vma val, max;
d557 3
a559 7
  if (max <= 0)
    abort ();
  if (val > max)
    return 0;
  if (val < ~(max >> 1))
    return 0;
  return 1;
d562 3
a564 3
static int
sparc_ffs (mask)
     unsigned int mask;
a565 1
  int i;
d567 30
a596 2
  if (mask == 0)
    return -1;
d598 5
a602 3
  for (i = 0; (mask & 1) == 0; ++i)
    mask >>= 1;
  return i;
d605 3
a607 5
/* Implement big shift right.  */
static bfd_vma
BSR (val, amount)
     bfd_vma val;
     int amount;
d609 5
a613 3
  if (sizeof (bfd_vma) <= 4 && amount >= 32)
    as_fatal (_("Support for 64-bit arithmetic not compiled in."));
  return val >> amount;
a614 3

/* For communication between sparc_ip and get_expression.  */
static char *expr_end;
d616 4
a619 9
/* Values for `special_case'.
   Instructions that require wierd handling because they're longer than
   4 bytes.  */
#define SPECIAL_CASE_NONE	0
#define	SPECIAL_CASE_SET	1
#define SPECIAL_CASE_SETSW	2
#define SPECIAL_CASE_SETX	3
/* FIXME: sparc-opc.c doesn't have necessary "S" trigger to enable this.  */
#define	SPECIAL_CASE_FDIV	4
d621 3
a623 8
/* Bit masks of various insns.  */
#define NOP_INSN 0x01000000
#define OR_INSN 0x80100000
#define XOR_INSN 0x80180000
#define FMOVS_INSN 0x81A00020
#define SETHI_INSN 0x01000000
#define SLLX_INSN 0x81281000
#define SRA_INSN 0x81380000
a624 6
/* The last instruction to be assembled.  */
static const struct sparc_opcode *last_insn;
/* The assembled opcode of `last_insn'.  */
static unsigned long last_opcode;

/* Handle the set and setuw synthetic instructions.  */
d626 2
a627 2
synthetize_setuw (insn)
     const struct sparc_opcode *insn;
d629 4
a632 2
  int need_hi22_p = 0;
  int rd = (the_insn.opcode & RD (~0)) >> 25;
d634 4
a637 18
  if (the_insn.exp.X_op == O_constant)
    {
      if (SPARC_OPCODE_ARCH_V9_P (max_architecture))
	{
	  if (sizeof(offsetT) > 4
	      && (the_insn.exp.X_add_number < 0
		  || the_insn.exp.X_add_number > (offsetT) 0xffffffff))
	    as_warn (_("set: number not in 0..4294967295 range"));
	}
      else
	{
	  if (sizeof(offsetT) > 4
	      && (the_insn.exp.X_add_number < -(offsetT) 0x80000000
		  || the_insn.exp.X_add_number > (offsetT) 0xffffffff))
	    as_warn (_("set: number not in -2147483648..4294967295 range"));
	  the_insn.exp.X_add_number = (int)the_insn.exp.X_add_number;
	}
    }
d639 5
a643 14
  /* See if operand is absolute and small; skip sethi if so.  */
  if (the_insn.exp.X_op != O_constant
      || the_insn.exp.X_add_number >= (1 << 12)
      || the_insn.exp.X_add_number < -(1 << 12))
    {
      the_insn.opcode = (SETHI_INSN | RD (rd)
			 | ((the_insn.exp.X_add_number >> 10)
			    & (the_insn.exp.X_op == O_constant ? 0x3fffff : 0)));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_HI22
			: BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
      need_hi22_p = 1;
    }
d645 3
a647 21
  /* See if operand has no low-order bits; skip OR if so.  */
  if (the_insn.exp.X_op != O_constant
      || (need_hi22_p && (the_insn.exp.X_add_number & 0x3FF) != 0)
      || ! need_hi22_p)
    {
      the_insn.opcode = (OR_INSN | (need_hi22_p ? RS1 (rd) : 0)
			 | RD (rd) | IMMED
			 | (the_insn.exp.X_add_number
			    & (the_insn.exp.X_op != O_constant ? 0 :
			       need_hi22_p ? 0x3ff : 0x1fff)));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_LO10
			: BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
    }
}
    
/* Handle the setsw synthetic instruction.  */
static void
synthetize_setsw (insn)
     const struct sparc_opcode *insn;
d649 2
a650 1
  int low32, rd, opc;
d652 3
a654 1
  rd = (the_insn.opcode & RD (~0)) >> 25;
d656 1
a656 1
  if (the_insn.exp.X_op != O_constant)
d658 2
a659 6
      synthetize_setuw (insn);

      /* Need to sign extend it.  */
      the_insn.opcode = (SRA_INSN | RS1 (rd) | RD (rd));
      the_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &the_insn);
d663 2
a664 8
  if (sizeof(offsetT) > 4
      && (the_insn.exp.X_add_number < -(offsetT) 0x80000000
	  || the_insn.exp.X_add_number > (offsetT) 0xffffffff))
    as_warn (_("setsw: number not in -2147483648..4294967295 range"));

  low32 = the_insn.exp.X_add_number;	
	      
  if (low32 >= 0)
d666 2
a667 2
      synthetize_setuw (insn);
      return;
d670 4
a673 5
  opc = OR_INSN;
    
  the_insn.reloc = BFD_RELOC_NONE;
  /* See if operand is absolute and small; skip sethi if so.  */
  if (low32 < -(1 << 12))
d675 3
a677 5
      the_insn.opcode = (SETHI_INSN | RD (rd)
			 | (((~the_insn.exp.X_add_number) >> 10) & 0x3fffff));
      output_insn (insn, &the_insn);
      low32 = 0x1c00 | (low32 & 0x3ff);
      opc = RS1 (rd) | XOR_INSN;
d680 4
a683 3
  the_insn.opcode = (opc | RD (rd) | IMMED
		     | (low32 & 0x1fff));
  output_insn (insn, &the_insn);
d686 57
a742 4
/* Handle the setsw synthetic instruction.  */
static void
synthetize_setx (insn)
     const struct sparc_opcode *insn;
d744 5
a748 11
  int upper32, lower32;
  int tmpreg = (the_insn.opcode & RS1 (~0)) >> 14;
  int dstreg = (the_insn.opcode & RD (~0)) >> 25;
  int upper_dstreg;
  int need_hh22_p = 0, need_hm10_p = 0, need_hi22_p = 0, need_lo10_p = 0;
  int need_xor10_p = 0;
    
#define SIGNEXT32(x) ((((x) & 0xffffffff) ^ 0x80000000) - 0x80000000)
  lower32 = SIGNEXT32 (the_insn.exp.X_add_number);
  upper32 = SIGNEXT32 (BSR (the_insn.exp.X_add_number, 32));
#undef SIGNEXT32
d750 9
a758 20
  upper_dstreg = tmpreg;
  /* The tmp reg should not be the dst reg.  */
  if (tmpreg == dstreg)
    as_warn (_("setx: temporary register same as destination register"));

  /* ??? Obviously there are other optimizations we can do
     (e.g. sethi+shift for 0x1f0000000) and perhaps we shouldn't be
     doing some of these.  Later.  If you do change things, try to
     change all of this to be table driven as well.  */
  /* What to output depends on the number if it's constant.
     Compute that first, then output what we've decided upon.  */
  if (the_insn.exp.X_op != O_constant)
    {
      if (sparc_arch_size == 32)
	{
	  /* When arch size is 32, we want setx to be equivalent
	     to setuw for anything but constants.  */
	  the_insn.exp.X_add_number &= 0xffffffff;
	  synthetize_setuw (insn);
	  return;
d760 9
a768 45
      need_hh22_p = need_hm10_p = need_hi22_p = need_lo10_p = 1;
      lower32 = 0; upper32 = 0;
    }
  else
    {
      /* Reset X_add_number, we've extracted it as upper32/lower32.
	 Otherwise fixup_segment will complain about not being able to
	 write an 8 byte number in a 4 byte field.  */
      the_insn.exp.X_add_number = 0;
    
      /* Only need hh22 if `or' insn can't handle constant.  */
      if (upper32 < -(1 << 12) || upper32 >= (1 << 12))
	need_hh22_p = 1;
    
      /* Does bottom part (after sethi) have bits?  */
      if ((need_hh22_p && (upper32 & 0x3ff) != 0)
	  /* No hh22, but does upper32 still have bits we can't set
	     from lower32?  */
	  || (! need_hh22_p && upper32 != 0 && upper32 != -1))
	need_hm10_p = 1;
    
      /* If the lower half is all zero, we build the upper half directly
	 into the dst reg.  */
      if (lower32 != 0
	  /* Need lower half if number is zero or 0xffffffff00000000.  */
	  || (! need_hh22_p && ! need_hm10_p))
	{
	  /* No need for sethi if `or' insn can handle constant.  */
	  if (lower32 < -(1 << 12) || lower32 >= (1 << 12)
	      /* Note that we can't use a negative constant in the `or'
		 insn unless the upper 32 bits are all ones.  */
	      || (lower32 < 0 && upper32 != -1)
	      || (lower32 >= 0 && upper32 == -1))
	    need_hi22_p = 1;
		      
	  if (need_hi22_p && upper32 == -1)
	    need_xor10_p = 1;

	  /* Does bottom part (after sethi) have bits?  */
	  else if ((need_hi22_p && (lower32 & 0x3ff) != 0)
		   /* No sethi.  */
		   || (! need_hi22_p && (lower32 & 0x1fff) != 0)
		   /* Need `or' if we didn't set anything else.  */
		   || (! need_hi22_p && ! need_hh22_p && ! need_hm10_p))
	    need_lo10_p = 1;
d770 2
a771 3
      else
	/* Output directly to dst reg if lower 32 bits are all zero.  */
	upper_dstreg = dstreg;
a772 3
    
  if (!upper_dstreg && dstreg)
    as_warn (_("setx: illegal temporary register g0"));
d774 24
a797 1
  if (need_hh22_p)
d799 12
a810 5
      the_insn.opcode = (SETHI_INSN | RD (upper_dstreg)
			 | ((upper32 >> 10) & 0x3fffff));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_SPARC_HH22 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
d812 20
a831 2
    
  if (need_hi22_p)
d833 4
a836 6
      the_insn.opcode = (SETHI_INSN | RD (dstreg)
			 | (((need_xor10_p ? ~lower32 : lower32)
			    >> 10) & 0x3fffff));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_SPARC_LM22 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
d838 17
d856 2
a857 37
  if (need_hm10_p)
    {
      the_insn.opcode = (OR_INSN
			 | (need_hh22_p ? RS1 (upper_dstreg) : 0)
			 | RD (upper_dstreg)
			 | IMMED
			 | (upper32 & (need_hh22_p ? 0x3ff : 0x1fff)));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_SPARC_HM10 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
    }
    
  if (need_lo10_p)
    {
      /* FIXME: One nice optimization to do here is to OR the low part
	 with the highpart if hi22 isn't needed and the low part is
	 positive.  */
      the_insn.opcode = (OR_INSN | (need_hi22_p ? RS1 (dstreg) : 0)
			 | RD (dstreg)
			 | IMMED
			 | (lower32 & (need_hi22_p ? 0x3ff : 0x1fff)));
      the_insn.reloc = (the_insn.exp.X_op != O_constant
			? BFD_RELOC_LO10 : BFD_RELOC_NONE);
      output_insn (insn, &the_insn);
    }
    
  /* If we needed to build the upper part, shift it into place.  */
  if (need_hh22_p || need_hm10_p)
    {
      the_insn.opcode = (SLLX_INSN | RS1 (upper_dstreg) | RD (upper_dstreg)
			 | IMMED | 32);
      the_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &the_insn);
    }
    
  /* To get -1 in upper32, we do sethi %hi(~x), r; xor r, -0x400 | x, r.  */
  if (need_xor10_p)
d859 6
a864 4
      the_insn.opcode = (XOR_INSN | RS1 (dstreg) | RD (dstreg) | IMMED
			 | 0x1c00 | (lower32 & 0x3ff));
      the_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &the_insn);
d867 1
a867 8
  /* If we needed to build both upper and lower parts, OR them together.  */
  else if ((need_hh22_p || need_hm10_p) && (need_hi22_p || need_lo10_p))
    {
      the_insn.opcode = (OR_INSN | RS1 (dstreg) | RS2 (upper_dstreg)
			 | RD (dstreg));
      the_insn.reloc = BFD_RELOC_NONE;
      output_insn (insn, &the_insn);
    }
a868 2

/* Main entry point to assemble one instruction.  */
a874 1
  int special_case;
d877 2
a878 1
  special_case = sparc_ip (str, &insn);
d880 1
a880 2
  /* We warn about attempts to put a floating point branch in a delay slot,
     unless the delay slot has been annulled.  */
d884 2
a885 6
      && (last_insn->flags & F_DELAYED) != 0
      /* ??? This test isn't completely accurate.  We assume anything with
	 F_{UNBR,CONDBR,FBR} set is annullable.  */
      && ((last_insn->flags & (F_UNBR | F_CONDBR | F_FBR)) == 0
	  || (last_opcode & ANNUL) == 0))
    as_warn (_("FP branch in delay slot"));
d901 1
a901 1
      as_warn (_("FP branch preceded by FP instruction; NOP inserted"));
d906 1
a906 1
    case SPECIAL_CASE_NONE:
d911 42
d954 4
a957 6
      synthetize_setsw (insn);
      break;
	  
    case SPECIAL_CASE_SET:
      synthetize_setuw (insn);
      break;
d960 141
a1100 3
      synthetize_setx (insn);
      break;
      
d1104 1
a1104 1
    
d1106 1
a1106 1
    
d1115 1
a1115 1
	return;
d1117 1
a1117 1
    
d1119 1
a1119 1
      as_fatal (_("failed special case insn sanity check"));
d1123 4
a1126 1
/* Subroutine of md_assemble to do the actual parsing.  */
d1129 4
a1132 3
sparc_ip (str, pinsn)
     char *str;
     const struct sparc_opcode **pinsn;
d1134 2
a1135 12
  char *error_message = "";
  char *s;
  const char *args;
  char c;
  const struct sparc_opcode *insn;
  char *argsStart;
  unsigned long opcode;
  unsigned int mask = 0;
  int match = 0;
  int comma = 0;
  int v9_arg_p;
  int special_case = SPECIAL_CASE_NONE;
d1137 34
a1170 2
  s = str;
  if (islower ((unsigned char) *s))
d1172 2
a1173 3
      do
	++s;
      while (islower ((unsigned char) *s) || isdigit ((unsigned char) *s));
d1175 29
d1220 1
a1220 1
      as_fatal (_("Unknown opcode: `%s'"), str);
d1226 2
a1227 2
      as_bad (_("Unknown opcode: `%s'"), str);
      return special_case;
d1264 1
a1264 1
			    error_message = _(": invalid membar mask name");
d1278 1
a1278 1
			error_message = _(": invalid membar mask expression");
d1283 1
a1283 1
			error_message = _(": invalid membar mask number");
d1301 1
a1301 1
			error_message = _(": invalid prefetch function name");
d1309 1
a1309 1
			error_message = _(": invalid prefetch function expression");
d1314 1
a1314 1
			error_message = _(": invalid prefetch function number");
d1342 1
a1342 1
		      error_message = _(": unrecognizable privileged register");
d1354 1
a1354 42
		  error_message = _(": unrecognizable privileged register");
		  goto error;
		}

	    case '_':
	    case '/':
	      /* Parse a v9a ancillary state register.  */
	      if (*s == '%')
		{
		  struct priv_reg_entry *p = v9a_asr_table;
		  unsigned int len = 9999999; /* init to make gcc happy */

		  s += 1;
		  while (p->name[0] > s[0])
		    p++;
		  while (p->name[0] == s[0])
		    {
		      len = strlen (p->name);
		      if (strncmp (p->name, s, len) == 0)
			break;
		      p++;
		    }
		  if (p->name[0] != s[0])
		    {
		      error_message = _(": unrecognizable v9a ancillary state register");
		      goto error;
		    }
		  if (*args == '/' && (p->regnum == 20 || p->regnum == 21))
		    {
		      error_message = _(": rd on write only ancillary state register");
		      goto error;
		    }		      
		  if (*args == '/')
		    opcode |= (p->regnum << 14);
		  else
		    opcode |= (p->regnum << 25);
		  s += len;
		  continue;
		}
	      else
		{
		  error_message = _(": unrecognizable v9a ancillary state register");
d1364 1
a1364 1
		  if (isdigit ((unsigned char) *s))
d1368 1
a1368 1
		      while (isdigit ((unsigned char) *s))
d1378 1
a1378 1
			      error_message = _(": asr number must be between 16 and 31");
d1386 1
a1386 1
			      error_message = _(": asr number must be between 0 and 31");
d1396 1
a1396 1
		      error_message = _(": expecting %asrN");
d1404 1
d1409 1
d1420 1
d1431 1
d1576 1
a1576 1
	      if (isdigit ((unsigned char) *s++))
d1578 1
a1578 1
		  while (isdigit ((unsigned char) *s))
d1597 1
a1597 1
	      if (*s++ == '%' && *s++ == 'c' && isdigit ((unsigned char) *s))
d1600 1
a1600 1
		  if (isdigit ((unsigned char) *s))
d1649 1
a1649 2
		      c = *s++;
		      if (isoctal (c))
d1657 1
a1657 2
		      c = *s++;
		      if (isoctal (c))
d1665 1
a1665 2
		      c = *s++;
		      if (isoctal (c))
d1673 1
a1673 2
		      c = *s++;
		      if (isoctal (c))
d1689 1
a1689 1
		      if (!isdigit ((unsigned char) (c = *s++)))
d1704 1
a1704 1
		      if (isdigit ((unsigned char) *s))
a1721 4
		  if ((mask & ~1) == 2 && sparc_arch_size == 64
		      && no_undeclared_regs && ! globals [mask])
		    as_bad (_("detected global register use not covered by .register pseudo-op"));

d1765 1
a1765 1
		    && isdigit ((unsigned char) *++s))
d1767 1
a1767 1
		    for (mask = 0; isdigit ((unsigned char) *s); ++s)
d1791 1
a1791 1
			  error_message = _(": There are only 64 f registers; [0-63]");
d1793 1
a1793 1
			  error_message = _(": There are only 32 f registers; [0-31]");
d1805 1
a1805 1
			    error_message = _(": There are only 32 f registers; [0-31]");
d1849 1
a1849 1
	    case '0':		/* 64 bit immediate (set, setsw, setx insn) */
d1853 4
a1866 1
	    case 'h':
d1873 1
d1875 1
a1875 1
	      /* fallthrough */
d1880 35
a1914 1

a1915 61
		char *s1;
		char *op_arg = NULL;
		expressionS op_exp;
		bfd_reloc_code_real_type old_reloc = the_insn.reloc;

		/* Check for %hi, etc.  */
		if (*s == '%')
		  {
		    static const struct ops {
		      /* The name as it appears in assembler.  */
		      char *name;
		      /* strlen (name), precomputed for speed */
		      int len;
		      /* The reloc this pseudo-op translates to.  */
		      int reloc;
		      /* Non-zero if for v9 only.  */
		      int v9_p;
		      /* Non-zero if can be used in pc-relative contexts.  */
		      int pcrel_p;/*FIXME:wip*/
		    } ops[] = {
		      /* hix/lox must appear before hi/lo so %hix won't be
			 mistaken for %hi.  */
		      { "hix", 3, BFD_RELOC_SPARC_HIX22, 1, 0 },
		      { "lox", 3, BFD_RELOC_SPARC_LOX10, 1, 0 },
		      { "hi", 2, BFD_RELOC_HI22, 0, 1 },
		      { "lo", 2, BFD_RELOC_LO10, 0, 1 },
		      { "hh", 2, BFD_RELOC_SPARC_HH22, 1, 1 },
		      { "hm", 2, BFD_RELOC_SPARC_HM10, 1, 1 },
		      { "lm", 2, BFD_RELOC_SPARC_LM22, 1, 1 },
		      { "h44", 3, BFD_RELOC_SPARC_H44, 1, 0 },
		      { "m44", 3, BFD_RELOC_SPARC_M44, 1, 0 },
		      { "l44", 3, BFD_RELOC_SPARC_L44, 1, 0 },
		      { "uhi", 3, BFD_RELOC_SPARC_HH22, 1, 0 },
		      { "ulo", 3, BFD_RELOC_SPARC_HM10, 1, 0 },
		      { NULL }
		    };
		    const struct ops *o;
  
		    for (o = ops; o->name; o++)
		      if (strncmp (s + 1, o->name, o->len) == 0)
			break;
		    if (o->name == NULL)
		      break;
		      
		    if (s[o->len + 1] != '(')
		      {
			as_bad (_("Illegal operands: %%%s requires arguments in ()"), o->name);
			return special_case;
		      }

		    op_arg = o->name;
		    the_insn.reloc = o->reloc;
		    s += o->len + 2;
		    v9_arg_p = o->v9_p;
		  }

		/* Note that if the get_expression() fails, we will still
		   have created U entries in the symbol table for the
		   'symbols' in the input string.  Try not to create U
		   symbols for registers, etc.  */

d1921 1
a1921 36
		if (op_arg)
		  {
		    int npar = 0;

		    for (s1 = s; *s1 && *s1 != ',' && *s1 != ']'; s1++)
		      if (*s1 == '(')
			npar++;
		      else if (*s1 == ')')
			{
			  if (!npar)
			    break;
			  npar--;
			}

		    if (*s1 != ')')
		      {
			as_bad (_("Illegal operands: %%%s requires arguments in ()"), op_arg);
			return special_case;
		      }
		    
		    *s1 = '\0';
		    (void) get_expression (s);
		    *s1 = ')';
		    s = s1 + 1;
		    if (*s == ',' || *s == ']' || !*s)
		      continue;
		    if (*s != '+' && *s != '-')
		      {
			as_bad (_("Illegal operands: Can't do arithmetics other than + and - involving %%%s()"), op_arg);
			return special_case;
		      }
		    *s1 = '0';
		    s = s1;
		    op_exp = the_insn.exp;
		    memset (&the_insn.exp, 0, sizeof(the_insn.exp));
		  }
d1925 1
a1925 1
		if (s1 != s && isdigit ((unsigned char) s1[-1]))
a1927 6
		      s1 -= 3;
		    else if (strchr ("goli0123456789", s1[-2]) && s1[-3] == '%' && s1[-4] == '+')
		      s1 -= 4;
		    else
		      s1 = NULL;
		    if (s1)
d1929 1
d1931 1
a1931 4
			if (op_arg && s1 == s + 1)
			  the_insn.exp.X_op = O_absent;
			else
			  (void) get_expression (s);
a1932 2
			if (op_arg)
			  *s = ')';
d1934 1
d1936 1
a1936 19
		  }
		else
		  s1 = NULL;

		if (!s1)
		  {
		    (void) get_expression (s);
		    if (op_arg)
		      *s = ')';
		    s = expr_end;
		  }

		if (op_arg)
		  {
		    the_insn.exp2 = the_insn.exp;
		    the_insn.exp = op_exp;
		    if (the_insn.exp2.X_op == O_absent)
		      the_insn.exp2.X_op = O_illegal;
		    else if (the_insn.exp.X_op == O_absent)
d1938 6
a1943 72
			the_insn.exp = the_insn.exp2;
			the_insn.exp2.X_op = O_illegal;
		      }
		    else if (the_insn.exp.X_op == O_constant)
		      {
			valueT val = the_insn.exp.X_add_number;
			switch (the_insn.reloc)
			  {
			  default:
			    break;

			  case BFD_RELOC_SPARC_HH22:
			    val = BSR (val, 32);
			    /* intentional fallthrough */

			  case BFD_RELOC_SPARC_LM22:
			  case BFD_RELOC_HI22:
			    val = (val >> 10) & 0x3fffff;
			    break;

			  case BFD_RELOC_SPARC_HM10:
			    val = BSR (val, 32);
			    /* intentional fallthrough */

			  case BFD_RELOC_LO10:
			    val &= 0x3ff;
			    break;

			  case BFD_RELOC_SPARC_H44:
			    val >>= 22;
			    val &= 0x3fffff;
			    break;

			  case BFD_RELOC_SPARC_M44:
			    val >>= 12;
			    val &= 0x3ff;
			    break;

			  case BFD_RELOC_SPARC_L44:
			    val &= 0xfff;
			    break;

			  case BFD_RELOC_SPARC_HIX22:
			    val = ~ val;
			    val = (val >> 10) & 0x3fffff;
			    break;

			  case BFD_RELOC_SPARC_LOX10:
			    val = (val & 0x3ff) | 0x1c00;
			    break;
			  }
			the_insn.exp = the_insn.exp2;
			the_insn.exp.X_add_number += val;
			the_insn.exp2.X_op = O_illegal;
			the_insn.reloc = old_reloc;
		      }
		    else if (the_insn.exp2.X_op != O_constant)
		      {
			as_bad (_("Illegal operands: Can't add non-constant expression to %%%s()"), op_arg);
			return special_case;
		      }
		    else
		      {
			if (old_reloc != BFD_RELOC_SPARC13
			    || the_insn.reloc != BFD_RELOC_LO10
			    || sparc_arch_size != 64
			    || sparc_pic_code)
			  {
			    as_bad (_("Illegal operands: Can't do arithmetics involving %%%s() of a relocatable symbol"), op_arg);
			    return special_case;
			  }
			the_insn.reloc = BFD_RELOC_SPARC_OLO10;
d1947 3
a1949 1
	      /* Check for constants that don't require emitting a reloc.  */
d1954 22
d1980 2
a1981 1
		      && in_signed_range (the_insn.exp.X_add_number, 0x3fff))
d1983 1
a1983 1
		      error_message = _(": PC-relative operand can't be a constant");
d1986 25
d2012 2
a2013 9
		  /* Constants that won't fit are checked in md_apply_fix3
		     and bfd_install_relocation.
		     ??? It would be preferable to install the constants
		     into the insn here and save having to create a fixS
		     for each one.  There already exists code to handle
		     all the various cases (e.g. in md_apply_fix3 and
		     bfd_install_relocation) so duplicating all that code
		     here isn't right.  */
		}
d2034 1
a2034 1
			error_message = _(": invalid ASI name");
d2042 1
a2042 1
			error_message = _(": invalid ASI expression");
d2047 1
a2047 1
			error_message = _(": invalid ASI number");
d2144 1
a2144 1
		      as_bad (_("OPF immediate operand out of range (0-0x1ff)"));
d2149 1
a2149 1
		  as_bad (_("non-immediate OPF operand, ignored"));
d2168 1
a2168 1
		    error_message = _(": invalid cpreg name");
d2176 1
a2176 1
	      as_fatal (_("failed sanity check."));
d2187 1
a2187 1
	  if (&insn[1] - sparc_opcodes < sparc_num_opcodes
d2197 2
a2198 2
	      as_bad (_("Illegal operands%s"), error_message);
	      return special_case;
d2226 1
a2226 1
		  as_warn (_("architecture bumped from \"%s\" to \"%s\" on \"%s\""),
d2262 2
a2263 2
	      as_bad (_("Architecture mismatch on \"%s\"."), str);
	      as_tsktsk (_(" (Requires %s; requested architecture is %s.)"),
d2266 1
a2266 1
	      return special_case;
a2273 64
  return special_case;
}

/* Parse an argument that can be expressed as a keyword.
   (eg: #StoreStore or %ccfr).
   The result is a boolean indicating success.
   If successful, INPUT_POINTER is updated.  */

static int
parse_keyword_arg (lookup_fn, input_pointerP, valueP)
     int (*lookup_fn) PARAMS ((const char *));
     char **input_pointerP;
     int *valueP;
{
  int value;
  char c, *p, *q;

  p = *input_pointerP;
  for (q = p + (*p == '#' || *p == '%');
       isalnum ((unsigned char) *q) || *q == '_';
       ++q)
    continue;
  c = *q;
  *q = 0;
  value = (*lookup_fn) (p);
  *q = c;
  if (value == -1)
    return 0;
  *valueP = value;
  *input_pointerP = q;
  return 1;
}

/* Parse an argument that is a constant expression.
   The result is a boolean indicating success.  */

static int
parse_const_expr_arg (input_pointerP, valueP)
     char **input_pointerP;
     int *valueP;
{
  char *save = input_line_pointer;
  expressionS exp;

  input_line_pointer = *input_pointerP;
  /* The next expression may be something other than a constant
     (say if we're not processing the right variant of the insn).
     Don't call expression unless we're sure it will succeed as it will
     signal an error (which we want to defer until later).  */
  /* FIXME: It might be better to define md_operand and have it recognize
     things like %asi, etc. but continuing that route through to the end
     is a lot of work.  */
  if (*input_line_pointer == '%')
    {
      input_line_pointer = save;
      return 0;
    }
  expression (&exp);
  *input_pointerP = input_line_pointer;
  input_line_pointer = save;
  if (exp.X_op != O_constant)
    return 0;
  *valueP = exp.X_add_number;
  return 1;
a2275 2
/* Subroutine of sparc_ip to parse an expression.  */

d2277 1
a2277 1
get_expression (str)
d2292 1
a2292 1
      the_insn.error = _("bad segment");
d2300 1
a2300 16
}

/* Subroutine of md_assemble to output one insn.  */

static void
output_insn (insn, the_insn)
     const struct sparc_opcode *insn;
     struct sparc_it *the_insn;
{
  char *toP = frag_more (4);

  /* put out the opcode */
  if (INSN_BIG_ENDIAN)
    number_to_chars_bigendian (toP, (valueT) the_insn->opcode, 4);
  else
    number_to_chars_littleendian (toP, (valueT) the_insn->opcode, 4);
a2301 17
  /* put out the symbol-dependent stuff */
  if (the_insn->reloc != BFD_RELOC_NONE)
    {
      fixS *fixP =  fix_new_exp (frag_now,	/* which frag */
				 (toP - frag_now->fr_literal),	/* where */
				 4,		/* size */
				 &the_insn->exp,
				 the_insn->pcrel,
				 the_insn->reloc);
      /* Turn off overflow checking in fixup_segment.  We'll do our
	 own overflow checking in md_apply_fix3.  This is necessary because
	 the insn size is 4 and fixup_segment will signal an overflow for
	 large 8 byte quantities.  */
      fixP->fx_no_overflow = 1;
      if (the_insn->reloc == BFD_RELOC_SPARC_OLO10)
	fixP->tc_fix_data = the_insn->exp2.X_add_number;
    }
a2302 4
  last_insn = insn;
  last_opcode = the_insn->opcode;
}

d2353 1
a2353 1
      return _("Bad call to MD_ATOF()");
d2392 1
a2392 5
  else if (target_little_endian_data
	   && ((n == 4 || n == 2) && ~now_seg->flags & SEC_ALLOC))
    /* Output debug words, which are not in allocated sections, as big endian */
    number_to_chars_bigendian (buf, val, n);
  else if (target_little_endian_data || ! target_big_endian)
d2395 1
a2395 1

d2423 1
a2423 1
      if (symbol_used_in_reloc_p (fixP->fx_addsy)
d2468 1
a2468 1
      && symbol_section_p (fixP->fx_addsy))
d2470 1
a2470 16

  /* When generating PIC code, we need to fiddle to get
     bfd_install_relocation to do the right thing for a PC relative
     reloc against a local symbol which we are going to keep.  */
  if (sparc_pic_code
      && fixP->fx_r_type == BFD_RELOC_32_PCREL_S2
      && fixP->fx_addsy != NULL
      && (S_IS_EXTERNAL (fixP->fx_addsy)
	  || S_IS_WEAK (fixP->fx_addsy))
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! S_IS_COMMON (fixP->fx_addsy))
    {
      val = 0;
      fixP->fx_addnumber -= 2 * S_GET_VALUE (fixP->fx_addsy);
    }
#endif
d2478 1
a2478 2
  else if (fixP->fx_r_type == BFD_RELOC_32
	   || fixP->fx_r_type == BFD_RELOC_SPARC_REV32)
a2485 6
  else if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT 
           || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    {
      fixP->fx_done = 0;
      return 1;
    }
d2503 1
a2503 1
	      || symbol_section_p (fixP->fx_addsy))
d2510 1
a2510 2
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
d2516 1
a2516 2
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
a2519 7
	case BFD_RELOC_SPARC_7:
	  if (! in_bitfield_range (val, 0x7f))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
	  insn |= val & 0x7f;
	  break;

d2522 1
a2522 2
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
d2528 1
a2528 2
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
d2536 1
a2536 2
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
d2546 1
a2546 2
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
d2571 1
a2571 2
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
a2590 5
	case BFD_RELOC_SPARC_OLO10:
	  val &= 0x3ff;
	  val += fixP->tc_fix_data;
	  /* intentional fallthrough */

d2593 1
a2593 2
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("relocation overflow"));
a2603 32
	case BFD_RELOC_SPARC_H44:
	  if (!fixP->fx_addsy)
	    {
	      bfd_vma tval = val;
	      tval >>= 22;
	      insn |= tval & 0x3fffff;
	    }
	  break;

	case BFD_RELOC_SPARC_M44:
	  if (!fixP->fx_addsy)
	    insn |= (val >> 12) & 0x3ff;
	  break;

	case BFD_RELOC_SPARC_L44:
	  if (!fixP->fx_addsy)
	    insn |= val & 0xfff;
	  break;

	case BFD_RELOC_SPARC_HIX22:
	  if (!fixP->fx_addsy)
	    {
	      val ^= ~ (offsetT) 0;
	      insn |= (val >> 10) & 0x3fffff;
	    }
	  break;

	case BFD_RELOC_SPARC_LOX10:
	  if (!fixP->fx_addsy)
	    insn |= 0x1c00 | (val & 0x3ff);
	  break;

d2606 1
a2606 3
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("bad or unhandled relocation type: 0x%02x"),
			fixP->fx_r_type);
d2625 1
a2625 1
arelent **
a2629 1
  static arelent *relocs[3];
d2633 1
a2633 2
  relocs[0] = reloc = (arelent *) xmalloc (sizeof (arelent));
  relocs[1] = NULL;
d2635 1
a2635 2
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
a2645 1
    case BFD_RELOC_SPARC22:
a2652 1
    case BFD_RELOC_SPARC_7:
a2660 9
    case BFD_RELOC_SPARC_H44:
    case BFD_RELOC_SPARC_M44:
    case BFD_RELOC_SPARC_L44:
    case BFD_RELOC_SPARC_HIX22:
    case BFD_RELOC_SPARC_LOX10:
    case BFD_RELOC_SPARC_REV32:
    case BFD_RELOC_SPARC_OLO10:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
a2664 1
      return NULL;
a2676 2
  /* This code must be parallel to the OBJ_ELF tc_fix_adjustable.  */

d2711 1
a2711 4
  if (code == BFD_RELOC_SPARC_OLO10)
    reloc->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_LO10);
  else
    reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
d2715 1
a2715 1
		    _("internal error: can't export reloc type %d (`%s')"),
d2717 1
a2717 3
      xfree (reloc);
      relocs[0] = NULL;
      return relocs;
a2726 8
  else if (sparc_pic_code
	   && fixp->fx_r_type == BFD_RELOC_32_PCREL_S2
	   && fixp->fx_addsy != NULL
	   && (S_IS_EXTERNAL (fixp->fx_addsy)
	       || S_IS_WEAK (fixp->fx_addsy))
	   && S_IS_DEFINED (fixp->fx_addsy)
	   && ! S_IS_COMMON (fixp->fx_addsy))
    reloc->addend = fixp->fx_addnumber;
d2736 1
a2736 1
  else if (symbol_section_p (fixp->fx_addsy))
d2744 1
a2744 15
  /* We expand R_SPARC_OLO10 to R_SPARC_LO10 and R_SPARC_13
     on the same location.  */
  if (code == BFD_RELOC_SPARC_OLO10)
    {
      relocs[1] = reloc = (arelent *) xmalloc (sizeof (arelent));
      relocs[2] = NULL;

      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (section_symbol (absolute_section));
      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
      reloc->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_SPARC13);
      reloc->addend = fixp->tc_fix_data;
    }

  return relocs;
a2745 2

/* We have no need to default values of symbols. */
a2746 7
/* ARGSUSED */
symbolS *
md_undefined_symbol (name)
     char *name;
{
  return 0;
}				/* md_undefined_symbol() */
d2748 5
a2752 5
/* Round up a section size to the appropriate boundary. */
valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
d2754 27
a2780 24
#ifndef OBJ_ELF
  /* This is not right for ELF; a.out wants it, and COFF will force
     the alignment anyways.  */
  valueT align = ((valueT) 1
		  << (valueT) bfd_get_section_alignment (stdoutput, segment));
  valueT newsize;
  /* turn alignment value into a mask */
  align--;
  newsize = (size + align) & ~align;
  return newsize;
#else
  return size;
#endif
}

/* Exactly what point is a PC-relative offset relative TO?
   On the sparc, they're relative to the address of the offset, plus
   its size.  This gets us to the following instruction.
   (??? Is this right?  FIXME-SOON) */
long 
md_pcrel_from (fixP)
     fixS *fixP;
{
  long ret;
d2782 20
a2801 6
  ret = fixP->fx_where + fixP->fx_frag->fr_address;
  if (! sparc_pic_code
      || fixP->fx_addsy == NULL
      || symbol_section_p (fixP->fx_addsy))
    ret += fixP->fx_size;
  return ret;
d2803 1
a2804 18
/* Return log2 (VALUE), or -1 if VALUE is not an exact positive power
   of two.  */

static int
log2 (value)
     int value;
{
  int shift;

  if (value <= 0)
    return -1;

  for (shift = 0; (value & 1) == 0; value >>= 1)
    ++shift;

  return (value == 1) ? shift : -1;
}

d2806 37
a2842 1
 * sort of like s_lcomm
a2844 417
#ifndef OBJ_ELF
static int max_alignment = 15;
#endif

static void
s_reserve (ignore)
     int ignore;
{
  char *name;
  char *p;
  char c;
  int align;
  int size;
  int temp;
  symbolS *symbolP;

  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after name"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;

  if ((size = get_absolute_expression ()) < 0)
    {
      as_bad (_("BSS length (%d.) <0! Ignored."), size);
      ignore_rest_of_line ();
      return;
    }				/* bad length */

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (strncmp (input_line_pointer, ",\"bss\"", 6) != 0
      && strncmp (input_line_pointer, ",\".bss\"", 7) != 0)
    {
      as_bad (_("bad .reserve segment -- expected BSS segment"));
      return;
    }

  if (input_line_pointer[2] == '.')
    input_line_pointer += 7;
  else
    input_line_pointer += 6;
  SKIP_WHITESPACE ();

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;

      SKIP_WHITESPACE ();
      if (*input_line_pointer == '\n')
	{
	  as_bad (_("missing alignment"));
	  ignore_rest_of_line ();
	  return;
	}

      align = (int) get_absolute_expression ();

#ifndef OBJ_ELF
      if (align > max_alignment)
	{
	  align = max_alignment;
	  as_warn (_("alignment too large; assuming %d"), align);
	}
#endif

      if (align < 0)
	{
	  as_bad (_("negative alignment"));
	  ignore_rest_of_line ();
	  return;
	}

      if (align != 0)
	{
	  temp = log2 (align);
	  if (temp < 0)
	    {
	      as_bad (_("alignment not a power of 2"));
	      ignore_rest_of_line ();
	      return;
	    }

	  align = temp;
	}

      record_alignment (bss_section, align);
    }
  else
    align = 0;

  if (!S_IS_DEFINED (symbolP)
#ifdef OBJ_AOUT
      && S_GET_OTHER (symbolP) == 0
      && S_GET_DESC (symbolP) == 0
#endif
      )
    {
      if (! need_pass_2)
	{
	  char *pfrag;
	  segT current_seg = now_seg;
	  subsegT current_subseg = now_subseg;

	  subseg_set (bss_section, 1); /* switch to bss */

	  if (align)
	    frag_align (align, 0, 0); /* do alignment */

	  /* detach from old frag */
	  if (S_GET_SEGMENT(symbolP) == bss_section)
	    symbol_get_frag (symbolP)->fr_symbol = NULL;

	  symbol_set_frag (symbolP, frag_now);
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
			    (offsetT) size, (char *)0);
	  *pfrag = 0;

	  S_SET_SEGMENT (symbolP, bss_section);

	  subseg_set (current_seg, current_subseg);

#ifdef OBJ_ELF
	  S_SET_SIZE (symbolP, size);
#endif
	}
    }
  else
    {
      as_warn("Ignoring attempt to re-define symbol %s",
	      S_GET_NAME (symbolP));
    }				/* if not redefining */

  demand_empty_rest_of_line ();
}

static void
s_common (ignore)
     int ignore;
{
  char *name;
  char c;
  char *p;
  int temp, size;
  symbolS *symbolP;

  name = input_line_pointer;
  c = get_symbol_end ();
  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after symbol-name"));
      ignore_rest_of_line ();
      return;
    }
  input_line_pointer++;		/* skip ',' */
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_bad (_(".COMMon length (%d.) <0! Ignored."), temp);
      ignore_rest_of_line ();
      return;
    }
  size = temp;
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
    }
  if (S_GET_VALUE (symbolP) != 0)
    {
      if (S_GET_VALUE (symbolP) != (valueT) size)
	{
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
	}
    }
  else
    {
#ifndef OBJ_ELF
      S_SET_VALUE (symbolP, (valueT) size);
      S_SET_EXTERNAL (symbolP);
#endif
    }
  know (symbol_get_frag (symbolP) == &zero_address_frag);
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after common length"));
      ignore_rest_of_line ();
      return;
    }
  input_line_pointer++;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != '"')
    {
      temp = get_absolute_expression ();

#ifndef OBJ_ELF
      if (temp > max_alignment)
	{
	  temp = max_alignment;
	  as_warn (_("alignment too large; assuming %d"), temp);
	}
#endif

      if (temp < 0)
	{
	  as_bad (_("negative alignment"));
	  ignore_rest_of_line ();
	  return;
	}

#ifdef OBJ_ELF
      if (symbol_get_obj (symbolP)->local)
	{
	  segT old_sec;
	  int old_subsec;
	  char *p;
	  int align;

	  old_sec = now_seg;
	  old_subsec = now_subseg;

	  if (temp == 0)
	    align = 0;
	  else
	    align = log2 (temp);

	  if (align < 0)
	    {
	      as_bad (_("alignment not a power of 2"));
	      ignore_rest_of_line ();
	      return;
	    }

	  record_alignment (bss_section, align);
	  subseg_set (bss_section, 0);
	  if (align)
	    frag_align (align, 0, 0);
	  if (S_GET_SEGMENT (symbolP) == bss_section)
	    symbol_get_frag (symbolP)->fr_symbol = 0;
	  symbol_set_frag (symbolP, frag_now);
	  p = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			(offsetT) size, (char *) 0);
	  *p = 0;
	  S_SET_SEGMENT (symbolP, bss_section);
	  S_CLEAR_EXTERNAL (symbolP);
	  S_SET_SIZE (symbolP, size);
	  subseg_set (old_sec, old_subsec);
	}
      else
#endif /* OBJ_ELF */
	{
	allocate_common:
	  S_SET_VALUE (symbolP, (valueT) size);
#ifdef OBJ_ELF
	  S_SET_ALIGN (symbolP, temp);
	  S_SET_SIZE (symbolP, size);
#endif
	  S_SET_EXTERNAL (symbolP);
	  S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
	}
    }
  else
    {
      input_line_pointer++;
      /* @@@@ Some use the dot, some don't.  Can we get some consistency??  */
      if (*input_line_pointer == '.')
	input_line_pointer++;
      /* @@@@ Some say data, some say bss.  */
      if (strncmp (input_line_pointer, "bss\"", 4)
	  && strncmp (input_line_pointer, "data\"", 5))
	{
	  while (*--input_line_pointer != '"')
	    ;
	  input_line_pointer--;
	  goto bad_common_segment;
	}
      while (*input_line_pointer++ != '"')
	;
      goto allocate_common;
    }

#ifdef BFD_ASSEMBLER
  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
#endif

  demand_empty_rest_of_line ();
  return;

  {
  bad_common_segment:
    p = input_line_pointer;
    while (*p && *p != '\n')
      p++;
    c = *p;
    *p = '\0';
    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
    *p = c;
    input_line_pointer = p;
    ignore_rest_of_line ();
    return;
  }
}

/* Handle the .empty pseudo-op.  This supresses the warnings about
   invalid delay slot usage.  */

static void
s_empty (ignore)
     int ignore;
{
  /* The easy way to implement is to just forget about the last
     instruction.  */
  last_insn = NULL;
}

static void
s_seg (ignore)
     int ignore;
{

  if (strncmp (input_line_pointer, "\"text\"", 6) == 0)
    {
      input_line_pointer += 6;
      s_text (0);
      return;
    }
  if (strncmp (input_line_pointer, "\"data\"", 6) == 0)
    {
      input_line_pointer += 6;
      s_data (0);
      return;
    }
  if (strncmp (input_line_pointer, "\"data1\"", 7) == 0)
    {
      input_line_pointer += 7;
      s_data1 ();
      return;
    }
  if (strncmp (input_line_pointer, "\"bss\"", 5) == 0)
    {
      input_line_pointer += 5;
      /* We only support 2 segments -- text and data -- for now, so
	 things in the "bss segment" will have to go into data for now.
	 You can still allocate SEG_BSS stuff with .lcomm or .reserve. */
      subseg_set (data_section, 255);	/* FIXME-SOMEDAY */
      return;
    }
  as_bad (_("Unknown segment type"));
  demand_empty_rest_of_line ();
}

static void
s_data1 ()
{
  subseg_set (data_section, 1);
  demand_empty_rest_of_line ();
}

static void
s_proc (ignore)
     int ignore;
{
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      ++input_line_pointer;
    }
  ++input_line_pointer;
}

/* This static variable is set by s_uacons to tell sparc_cons_align
   that the expession does not need to be aligned.  */

static int sparc_no_align_cons = 0;

/* This handles the unaligned space allocation pseudo-ops, such as
   .uaword.  .uaword is just like .word, but the value does not need
   to be aligned.  */

static void
s_uacons (bytes)
     int bytes;
{
  /* Tell sparc_cons_align not to align this value.  */
  sparc_no_align_cons = 1;
  cons (bytes);
}

/* This handles the native word allocation pseudo-op .nword.
   For sparc_arch_size 32 it is equivalent to .word,  for
   sparc_arch_size 64 it is equivalent to .xword.  */

static void
s_ncons (bytes)
     int bytes;
{
  cons (sparc_arch_size == 32 ? 4 : 8);
}

d2846 26
a2871 6
/* Handle the SPARC ELF .register pseudo-op.  This sets the binding of a
   global register.
   The syntax is:
   
   .register %g[2367],{#scratch|symbolname|#ignore}
   */
d2873 4
a2876 3
static void
s_register (ignore)
     int ignore;
d2878 6
a2883 13
  char c;
  int reg;
  int flags;
  const char *regname;

  if (input_line_pointer[0] != '%'
      || input_line_pointer[1] != 'g'
      || ((input_line_pointer[2] & ~1) != '2'
	  && (input_line_pointer[2] & ~1) != '6')
      || input_line_pointer[3] != ',')
    as_bad (_("register syntax is .register %%g[2367],{#scratch|symbolname|#ignore}"));
  reg = input_line_pointer[2] - '0';
  input_line_pointer += 4;
d2885 9
a2893 9
  if (*input_line_pointer == '#')
    {
      ++input_line_pointer;
      regname = input_line_pointer;
      c = get_symbol_end ();
      if (strcmp (regname, "scratch") && strcmp (regname, "ignore"))
	as_bad (_("register syntax is .register %%g[2367],{#scratch|symbolname|#ignore}"));
      if (regname [0] == 'i')
	regname = NULL;
a2894 10
	regname = "";
    }
  else
    {
      regname = input_line_pointer;
      c = get_symbol_end ();
    }
  if (sparc_arch_size == 64)
    {
      if (globals [reg])
d2896 2
a2897 4
	  if ((regname && globals [reg] != (symbolS *)1
	       && strcmp (S_GET_NAME (globals [reg]), regname))
	      || ((regname != NULL) ^ (globals [reg] != (symbolS *)1)))
	    as_bad (_("redefinition of global register"));
a2898 36
      else
	{
	  if (regname == NULL)
	    globals [reg] = (symbolS *)1;
	  else
	    {
	      if (*regname)
		{
		  if (symbol_find (regname))
		    as_bad (_("Register symbol %s already defined."),
			    regname);
		}
	      globals [reg] = symbol_make (regname);
	      flags = symbol_get_bfdsym (globals [reg])->flags;
	      if (! *regname)
		flags = flags & ~(BSF_GLOBAL|BSF_LOCAL|BSF_WEAK);
	      if (! (flags & (BSF_GLOBAL|BSF_LOCAL|BSF_WEAK)))
		flags |= BSF_GLOBAL;
	      symbol_get_bfdsym (globals [reg])->flags = flags;
	      S_SET_VALUE (globals [reg], (valueT)reg);
	      S_SET_ALIGN (globals [reg], reg);
	      S_SET_SIZE (globals [reg], 0);
	      /* Although we actually want undefined_section here,
		 we have to use absolute_section, because otherwise
		 generic as code will make it a COM section.
		 We fix this up in sparc_adjust_symtab.  */
	      S_SET_SEGMENT (globals [reg], absolute_section);
	      S_SET_OTHER (globals [reg], 0);
	      elf_symbol (symbol_get_bfdsym (globals [reg]))
		->internal_elf_sym.st_info =
		  ELF_ST_INFO(STB_GLOBAL, STT_REGISTER);
	      elf_symbol (symbol_get_bfdsym (globals [reg]))
		->internal_elf_sym.st_shndx = SHN_UNDEF;
	    }
	}
    }
d2900 5
a2904 1
  *input_line_pointer = c;
d2906 12
a2917 2
  demand_empty_rest_of_line ();
}
d2919 3
a2921 13
/* Adjust the symbol table.  We set undefined sections for STT_REGISTER
   symbols which need it.  */
   
void
sparc_adjust_symtab ()
{
  symbolS *sym;
     
  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ELF_ST_TYPE (elf_symbol (symbol_get_bfdsym (sym))
		       ->internal_elf_sym.st_info) != STT_REGISTER)
	continue;
d2923 3
a2925 3
      if (ELF_ST_TYPE (elf_symbol (symbol_get_bfdsym (sym))
		       ->internal_elf_sym.st_shndx != SHN_UNDEF))
	continue;
d2927 7
a2933 3
      S_SET_SEGMENT (sym, undefined_section);
    }
}
d2936 5
a2940 4
/* If the --enforce-aligned-data option is used, we require .word,
   et. al., to be aligned correctly.  We do it by setting up an
   rs_align_code frag, and checking in HANDLE_ALIGN to make sure that
   no unexpected alignment was introduced.
d2942 4
a2945 5
   The SunOS and Solaris native assemblers enforce aligned data by
   default.  We don't want to do that, because gcc can deliberately
   generate misaligned data if the packed attribute is used.  Instead,
   we permit misaligned data by default, and permit the user to set an
   option to check for it.  */
d2947 4
a2950 6
void
sparc_cons_align (nbytes)
     int nbytes;
{
  int nalign;
  char *p;
d2952 3
a2954 3
  /* Only do this if we are enforcing aligned data.  */
  if (! enforce_aligned_data)
    return;
d2956 3
a2958 6
  if (sparc_no_align_cons)
    {
      /* This is an unaligned pseudo-op.  */
      sparc_no_align_cons = 0;
      return;
    }
d2960 7
a2966 3
  nalign = log2 (nbytes);
  if (nalign == 0)
    return;
d2968 2
a2969 7
  assert (nalign > 0);

  if (now_seg == absolute_section)
    {
      if ((abs_section_offset & ((1 << nalign) - 1)) != 0)
	as_bad (_("misaligned data"));
      return;
d2972 1
a2972 4
  p = frag_var (rs_align_code, 1, 1, (relax_substateT) 0,
		(symbolS *) NULL, (offsetT) nalign, (char *) NULL);

  record_alignment (now_seg, nalign);
a2974 3
/* This is where we do the unexpected alignment check.
   This is called from HANDLE_ALIGN in tc-sparc.h.  */

d2976 2
a2977 2
sparc_handle_align (fragp)
     fragS *fragp;
d2979 4
a2982 4
  if (fragp->fr_type == rs_align_code && !fragp->fr_subtype
      && fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix != 0)
    as_bad_where (fragp->fr_file, fragp->fr_line, _("misaligned data"));
  if (fragp->fr_type == rs_align_code && fragp->fr_subtype == 1024)
d2984 3
a2986 27
      int count = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
      
      if (count >= 4
	  && !(count & 3)
	  && count <= 1024
	  && !((long)(fragp->fr_literal + fragp->fr_fix) & 3))
        {
          unsigned *p = (unsigned *)(fragp->fr_literal + fragp->fr_fix);
          int i;
          
          for (i = 0; i < count; i += 4, p++)
            if (INSN_BIG_ENDIAN)
              number_to_chars_bigendian ((char *)p, 0x01000000, 4); /* emit nops */
            else
              number_to_chars_littleendian ((char *)p, 0x10000000, 4);

          if (SPARC_OPCODE_ARCH_V9_P (max_architecture) && count > 8)
            {
	      char *waddr = &fragp->fr_literal[fragp->fr_fix];
	      unsigned wval = (0x30680000 | count >> 2); /* ba,a,pt %xcc, 1f */
	      if (INSN_BIG_ENDIAN)
		number_to_chars_bigendian (waddr, wval, 4);
	      else
		number_to_chars_littleendian (waddr, wval, 4);
            }
          fragp->fr_var = count;
        }
d2988 23
d3012 2
d3015 7
a3021 2
#ifdef OBJ_ELF
/* Some special processing for a Sparc ELF file.  */
d3023 5
a3027 2
void
sparc_elf_final_processing ()
d3029 12
a3040 21
  /* Set the Sparc ELF flag bits.  FIXME: There should probably be some
     sort of BFD interface for this.  */
  if (sparc_arch_size == 64)
    {
      switch (sparc_memory_model)
	{
	case MM_RMO:
	  elf_elfheader (stdoutput)->e_flags |= EF_SPARCV9_RMO;
	  break;
	case MM_PSO:
	  elf_elfheader (stdoutput)->e_flags |= EF_SPARCV9_PSO;
	  break;
	default:
	  break;
	}
    }
  else if (current_architecture >= SPARC_OPCODE_ARCH_V9)
    elf_elfheader (stdoutput)->e_flags |= EF_SPARC_32PLUS;
  if (current_architecture == SPARC_OPCODE_ARCH_V9A)
    elf_elfheader (stdoutput)->e_flags |= EF_SPARC_SUN_US1;
}
a3041 22

/* This is called by emit_expr via TC_CONS_FIX_NEW when creating a
   reloc for a cons.  We could use the definition there, except that
   we want to handle little endian relocs specially.  */

void
cons_fix_new_sparc (frag, where, nbytes, exp)
     fragS *frag;
     int where;
     unsigned int nbytes;
     expressionS *exp;
{
  bfd_reloc_code_real_type r;

  r = (nbytes == 1 ? BFD_RELOC_8 :
       (nbytes == 2 ? BFD_RELOC_16 :
	(nbytes == 4 ? BFD_RELOC_32 : BFD_RELOC_64)));

  if (target_little_endian_data && nbytes == 4
      && now_seg->flags & SEC_ALLOC)  
    r = BFD_RELOC_SPARC_REV32;
  fix_new_exp (frag, where, (int) nbytes, exp, 0, r);
d3044 7
a3050 4
#ifdef OBJ_ELF
int
elf32_sparc_force_relocation (fixp)
      struct fix *fixp;
d3052 8
a3059 5
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;
 
  return 0;
a3060 1
#endif
d3062 1
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 3
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001
   Free Software Foundation, Inc.
d18 1
a18 1
   Boston, MA 02111-1307, USA.  */
a29 1
#include "dwarf2dbg.h"
a93 3
/* Non-zero if we should try to relax jumps and calls.  */
static int sparc_relax;

d117 1
a117 1
/* Handle of the OPCODE hash table.  */
d133 1
a133 1
  {"align", s_align_bytes, 0},	/* Defaulting is invalid (0).  */
d150 1
a150 3
  {"file", dwarf2_directive_file, 0},
  {"loc", dwarf2_directive_loc, 0},
  /* These are specific to sparc/svr4.  */
d159 1
a159 2
/* Size of relocation record.  */
const int md_reloc_size = 12;
d162 2
a163 3
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "!";	/* JF removed '|' from
                                           comment_chars.  */
d167 1
a167 1
   .line and .file directives will appear in the pre-processed output.  */
d170 1
a170 1
   #NO_APP at the beginning of its output.  */
d172 1
a172 1
   work if '/' isn't otherwise defined.  */
d175 1
a175 1
const char line_separator_chars[] = ";";
d177 1
a177 2
/* Chars that can be used to separate mant from exp in floating point
   nums.  */
d180 3
a182 3
/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12  */
d189 1
a189 1
#define isoctal(c)  ((unsigned) ((c) - '0') < '8')
d213 1
a213 1
		       v8plusa, v9, v9a, v9b, v9_64};
a232 1
  { "v8plusb", "v9b", v9, 0, 1 },
a234 1
  { "v9b", "v9b", v9, 0, 1 },
d297 1
a297 2
  else
    return "a.out-sparc-little";
d323 2
a324 1
/* md_parse_option
d333 3
a335 1
 *	-Av9, -Av9a, -Av9b
d341 2
a342 8
 *	-Av8plus, -Av8plusa, -Av8plusb
 *		Same as -Av9{,a,b}.
 *	-xarch=v8plus, -xarch=v8plusa, -xarch=v8plusb
 *		Same as -Av8plus{,a,b} -32, for compatibility with Sun's
 *		assembler.
 *	-xarch=v9, -xarch=v9a, -xarch=v9b
 *		Same as -Av9{,a,b} -64, for compatibility with Sun's
 *		assembler.
d351 1
a351 1
 * 		-Av8plus{,a,b}.
a417 4
#define OPTION_RELAX (OPTION_MD_BASE + 14)
  {"relax", no_argument, NULL, OPTION_RELAX},
#define OPTION_NO_RELAX (OPTION_MD_BASE + 15)
  {"no-relax", no_argument, NULL, OPTION_NO_RELAX},
d420 1
a420 2

size_t md_longopts_size = sizeof (md_longopts);
d440 9
a448 7
#ifdef OBJ_ELF
      if (strncmp (arg, "v9", 2) != 0)
	md_parse_option (OPTION_32, NULL);
      else
	md_parse_option (OPTION_64, NULL);
#endif
      /* Fall through.  */
d459 1
a459 4
	    if (c == OPTION_XARCH)
	      as_bad (_("invalid architecture -xarch=%s"), arg);
	    else
	      as_bad (_("invalid architecture -A%s"), arg);
d550 1
a550 1
	 Qn - do not emit .comment.  */
d554 1
a554 1
      /* Use .stab instead of .stab.excl.  */
d558 1
a558 1
      /* quick -- Native assembler does fewer checks.  */
a576 8
    case OPTION_RELAX:
      sparc_relax = 1;
      break;

    case OPTION_NO_RELAX:
      sparc_relax = 0;
      break;

a588 1
  int column;
d595 1
a595 2
  fprintf (stream, _("SPARC options:\n"));
  column = 0;
a597 2
      if (!arch->user_option_p)
	continue;
d600 2
a601 7
      if (column + strlen(arch->name) > 70)
	{
	  column = 0;
	  fputc ('\n', stream);
	}
      column += 5 + 2 + strlen(arch->name);
      fprintf (stream, "-A%s", arch->name);
d603 2
a604 14
  for (arch = &sparc_arch_table[0]; arch->name; arch++)
    {
      if (!arch->user_option_p)
	continue;
      fprintf (stream, " | ");
      if (column + strlen(arch->name) > 65)
	{
	  column = 0;
	  fputc ('\n', stream);
	}
      column += 5 + 7 + strlen(arch->name);
      fprintf (stream, "-xarch=%s", arch->name);
    }
  fprintf (stream, _("\n\
d608 1
a608 3
--enforce-aligned-data	force .long, etc., to be aligned correctly\n\
-relax			relax jumps and branches (default)\n\
-no-relax		avoid changing any jumps and branches\n"));
d645 1
a645 1
/* Native operand size opcode translation.  */
d666 1
a666 1
/* sparc64 priviledged registers.  */
d669 4
a672 4
{
  char *name;
  int regnum;
};
d693 1
a693 1
  {"", -1},			/* End marker.  */
d696 1
a696 1
/* v9a specific asrs.  */
a700 2
  {"sys_tick_cmpr", 25},
  {"sys_tick", 24},
d708 1
a708 1
  {"", -1},			/* End marker.  */
d723 1
a723 2
   set up all the tables, etc. that the MD part of the assembler will
   need.  */
d767 3
a769 4
      char *name = ((sparc_arch_size == 32)
		    ? native_op_table[i].name32
		    : native_op_table[i].name64);
      insn = (struct sparc_opcode *) hash_find (op_hash, name);
d771 5
a775 5
	{
	  as_bad (_("Internal error: can't find opcode `%s' for `%s'\n"),
		  name, native_op_table[i].name);
	  lose = 1;
	}
a823 2
  unsigned long mach = bfd_mach_sparc;

d825 6
a830 6
    switch (current_architecture)
      {
      case SPARC_OPCODE_ARCH_V9A: mach = bfd_mach_sparc_v9a; break;
      case SPARC_OPCODE_ARCH_V9B: mach = bfd_mach_sparc_v9b; break;
      default: mach = bfd_mach_sparc_v9; break;
      }
d832 17
a848 12
    switch (current_architecture)
      {
      case SPARC_OPCODE_ARCH_SPARCLET: mach = bfd_mach_sparc_sparclet; break;
      case SPARC_OPCODE_ARCH_V9: mach = bfd_mach_sparc_v8plus; break;
      case SPARC_OPCODE_ARCH_V9A: mach = bfd_mach_sparc_v8plusa; break;
      case SPARC_OPCODE_ARCH_V9B: mach = bfd_mach_sparc_v8plusb; break;
      /* The sparclite is treated like a normal sparc.  Perhaps it shouldn't
	 be but for now it is (since that's the way it's always been
	 treated).  */
      default: break;
      }
  bfd_set_arch_mach (stdoutput, bfd_arch_sparc, mach);
d863 1
a863 1
      bfd_signed_vma sign = (bfd_signed_vma) 1 << 31;
a952 1

d964 1
a964 1
	  if (sizeof (offsetT) > 4
d971 1
a971 1
	  if (sizeof (offsetT) > 4
d975 1
a975 1
	  the_insn.exp.X_add_number = (int) the_insn.exp.X_add_number;
d986 1
a986 2
			    & (the_insn.exp.X_op == O_constant
			       ? 0x3fffff : 0)));
d988 2
a989 1
			? BFD_RELOC_HI22 : BFD_RELOC_NONE);
d1002 2
a1003 2
			    & (the_insn.exp.X_op != O_constant
			       ? 0 : need_hi22_p ? 0x3ff : 0x1fff)));
d1005 2
a1006 1
			? BFD_RELOC_LO10 : BFD_RELOC_NONE);
d1010 1
a1010 1

a1011 1

d1031 1
a1031 1
  if (sizeof (offsetT) > 4
d1036 2
a1037 2
  low32 = the_insn.exp.X_add_number;

d1045 1
a1045 1

a1062 1

d1073 1
a1073 1

d1101 1
a1101 2
      lower32 = 0;
      upper32 = 0;
d1109 1
a1109 1

d1113 1
a1113 1

d1120 1
a1120 1

d1134 1
a1134 1

d1150 1
a1150 1

d1162 1
a1162 1

d1167 1
a1167 1
			     >> 10) & 0x3fffff));
d1184 1
a1184 1

d1198 1
a1198 1

d1207 1
a1207 1

d1271 1
a1271 1
      /* Normal insn.  */
d1278 1
a1278 1

d1286 1
a1286 1

d1290 1
a1290 1

d1292 1
a1292 1

d1297 1
a1297 1
	   with Weitek 1165 float chips, such as the Sun-4/260 and /280.  */
d1303 1
a1303 1

d1344 2
a1345 1
      /* Fall through.  */
d1374 4
a1377 2
      /* Build the opcode, checking as we go to make sure that the
         operands match.  */
d1400 1
a1400 2
			while (*s == ' ')
			  ++s;
d1403 1
a1403 2
			while (*s == ' ')
			  ++s;
a1423 18
	    case '3':
	      {
		int smask = 0;

		if (! parse_const_expr_arg (&s, &smask))
		  {
		    error_message = _(": invalid siam mode expression");
		    goto error;
		  }
		if (smask < 0 || smask > 7)
		  {
		    error_message = _(": invalid siam mode number");
		    goto error;
		  }
		opcode |= smask;
		continue;
	      }

d1460 1
a1460 1
		  unsigned int len = 9999999; /* Init to make gcc happy.  */
d1492 1
a1492 1
	      /* Parse a v9a/v9b ancillary state register.  */
d1496 1
a1496 1
		  unsigned int len = 9999999; /* Init to make gcc happy.  */
d1510 1
a1510 1
		      error_message = _(": unrecognizable v9a or v9b ancillary state register");
d1517 1
a1517 9
		    }
		  if (p->regnum >= 24
		      && (insn->architecture
			  & SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9A)))
		    {
		      /* %sys_tick and %sys_tick_cmpr are v9bnotv9a */
		      error_message = _(": unrecognizable v9a ancillary state register");
		      goto error;
		    }
d1527 1
a1527 1
		  error_message = _(": unrecognizable v9a or v9b ancillary state register");
d1572 1
a1572 1
		} /* if %asr  */
d1717 1
a1717 1
	    case '\0':		/* End of args.  */
d1736 1
a1736 1
	    case '[':		/* These must match exactly.  */
d1744 1
a1744 1
	    case '#':		/* Must be at least one digit.  */
d1755 1
a1755 1
	    case 'C':		/* Coprocessor state register.  */
d1763 1
a1763 1
	    case 'b':		/* Next operand is a coprocessor register.  */
d1896 1
a1896 1
		      && no_undeclared_regs && ! globals[mask])
d1990 1
a1990 1
		  }	/* if not an 'f' register.  */
d2000 1
d2012 1
a2012 1
		  }		/* Pack it in.  */
d2016 1
a2016 1
	      }			/* float arg  */
d2026 2
a2027 2
	    case '0':		/* 64 bit immediate (set, setsw, setx insn)  */
	      the_insn.reloc = BFD_RELOC_NONE; /* reloc handled elsewhere  */
d2030 1
a2030 1
	    case 'l':		/* 22 bit PC relative immediate  */
d2035 1
a2035 1
	    case 'L':		/* 30 bit immediate  */
d2041 1
a2041 1
	    case 'n':		/* 22 bit immediate  */
d2045 1
a2045 1
	    case 'i':		/* 13 bit immediate  */
d2089 1
a2089 1
		      { NULL, 0, 0, 0, 0 }
d2092 1
a2092 1

d2098 1
a2098 1

d2140 1
a2140 1

d2155 1
a2155 1
		    memset (&the_insn.exp, 0, sizeof (the_insn.exp));
d2158 1
a2158 2
		for (s1 = s; *s1 && *s1 != ',' && *s1 != ']'; s1++)
		  ;
d2213 1
a2213 1
			    /* Fall through.  */
d2222 1
a2222 1
			    /* Fall through.  */
d2243 1
a2243 1
			    val = ~val;
d2338 1
a2338 1
	      }			/* Alternate space.  */
d2348 1
a2348 1
	    case 'q':		/* Floating point queue.  */
d2356 1
a2356 1
	    case 'Q':		/* Coprocessor queue.  */
d2462 1
a2462 1
	    }			/* switch on arg code.  */
d2466 1
a2466 1
	}			/* For each arg that we expect.  */
d2471 1
a2471 1
	  /* Args don't match.  */
d2488 1
a2488 1
	  /* We have a match.  Now see if the architecture is OK.  */
d2493 3
a2495 5
	      needed_arch_mask &=
		~(SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9) - 1);
	      if (! needed_arch_mask)
		needed_arch_mask =
		  SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9);
d2498 2
a2499 4
	  if (needed_arch_mask
	      & SPARC_OPCODE_SUPPORTED (current_architecture))
	    /* OK.  */
	    ;
d2501 1
a2501 2
	  else if (needed_arch_mask
		   & SPARC_OPCODE_SUPPORTED (max_architecture))
d2526 1
a2526 1
	      int arch, printed_one_p = 0;
d2531 1
a2531 1
	      needed_arch_mask &= ~SPARC_OPCODE_SUPPORTED (max_architecture);
d2553 1
a2553 1
	} /* If no match.  */
d2556 1
a2556 1
    } /* Forever looking for a match.  */
d2662 1
a2662 1
  /* Put out the opcode.  */
d2668 1
a2668 1
  /* Put out the symbol-dependent stuff.  */
d2671 3
a2673 3
      fixS *fixP =  fix_new_exp (frag_now,	/* Which frag.  */
				 (toP - frag_now->fr_literal),	/* Where.  */
				 4,		/* Size.  */
a2687 4

#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif
d2690 8
a2697 7
/* This is identical to the md_atof in m68k.c.  I think this is right,
   but I'm not sure.

   Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */
d2699 1
a2699 1
/* Equal to MAX_PRECISION in atof-ieee.c.  */
d2708 1
a2708 1
  int i, prec;
d2752 1
a2752 2
	  md_number_to_chars (litP, (valueT) words[i],
			      sizeof (LITTLENUM_TYPE));
d2760 1
a2760 2
	  md_number_to_chars (litP, (valueT) words[i],
			      sizeof (LITTLENUM_TYPE));
d2764 1
a2764 1

d2781 1
a2781 2
    /* Output debug words, which are not in allocated sections, as big
       endian.  */
d2788 1
a2788 1
   hold.  */
d2804 1
a2804 1
  fixP->fx_addnumber = val;	/* Remember value for emit_reloc.  */
d2880 1
a2880 2
  if (fixP->fx_r_type == BFD_RELOC_16
      || fixP->fx_r_type == BFD_RELOC_SPARC_UA16)
a2884 1
	   || fixP->fx_r_type == BFD_RELOC_SPARC_UA32
d2889 1
a2889 2
  else if (fixP->fx_r_type == BFD_RELOC_64
	   || fixP->fx_r_type == BFD_RELOC_SPARC_UA64)
d2893 1
a2893 1
  else if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d2907 1
a2907 1

a2917 1

a2918 83

	  /* See if we have a delay slot.  */
	  if (sparc_relax && fixP->fx_where + 8 <= fixP->fx_frag->fr_fix)
	    {
#define G0		0
#define O7		15
#define XCC		(2 << 20)
#define COND(x)		(((x)&0xf)<<25)
#define CONDA		COND(0x8)
#define INSN_BPA	(F2(0,1) | CONDA | BPRED | XCC)
#define INSN_BA		(F2(0,2) | CONDA)
#define INSN_OR		F3(2, 0x2, 0)
#define INSN_NOP	F2(0,4)

	      long delay;

	      /* If the instruction is a call with either:
		 restore
		 arithmetic instruction with rd == %o7
		 where rs1 != %o7 and rs2 if it is register != %o7
		 then we can optimize if the call destination is near
		 by changing the call into a branch always.  */
	      if (INSN_BIG_ENDIAN)
		delay = bfd_getb32 ((unsigned char *) buf + 4);
	      else
		delay = bfd_getl32 ((unsigned char *) buf + 4);
	      if ((insn & OP (~0)) != OP (1) || (delay & OP (~0)) != OP (2))
		break;
	      if ((delay & OP3 (~0)) != OP3 (0x3d) /* Restore.  */
		  && ((delay & OP3 (0x28)) != 0 /* Arithmetic.  */
		      || ((delay & RD (~0)) != RD (O7))))
		break;
	      if ((delay & RS1 (~0)) == RS1 (O7)
		  || ((delay & F3I (~0)) == 0
		      && (delay & RS2 (~0)) == RS2 (O7)))
		break;
	      /* Ensure the branch will fit into simm22.  */
	      if ((val & 0x3fe00000)
		  && (val & 0x3fe00000) != 0x3fe00000)
		break;
	      /* Check if the arch is v9 and branch will fit
		 into simm19.  */
	      if (((val & 0x3c0000) == 0
		   || (val & 0x3c0000) == 0x3c0000)
		  && (sparc_arch_size == 64
		      || current_architecture >= SPARC_OPCODE_ARCH_V9))
		/* ba,pt %xcc  */
		insn = INSN_BPA | (val & 0x7ffff);
	      else
		/* ba  */
		insn = INSN_BA | (val & 0x3fffff);
	      if (fixP->fx_where >= 4
		  && ((delay & (0xffffffff ^ RS1 (~0)))
		      == (INSN_OR | RD (O7) | RS2 (G0))))
		{
		  long setter;
		  int reg;

		  if (INSN_BIG_ENDIAN)
		    setter = bfd_getb32 ((unsigned char *) buf - 4);
		  else
		    setter = bfd_getl32 ((unsigned char *) buf - 4);
		  if ((setter & (0xffffffff ^ RD (~0)))
		      != (INSN_OR | RS1 (O7) | RS2 (G0)))
		    break;
		  /* The sequence was
		     or %o7, %g0, %rN
		     call foo
		     or %rN, %g0, %o7

		     If call foo was replaced with ba, replace
		     or %rN, %g0, %o7 with nop.  */
		  reg = (delay & RS1 (~0)) >> 14;
		  if (reg != ((setter & RD (~0)) >> 25)
		      || reg == G0 || reg == O7)
		    break;

		  if (INSN_BIG_ENDIAN)
		    bfd_putb32 (INSN_NOP, (unsigned char *) buf + 4);
		  else
		    bfd_putl32 (INSN_NOP, (unsigned char *) buf + 4);
		}
	    }
d2957 1
a2957 1
	  /* FIXME: simplify.  */
d2968 1
a2968 1
	  /* FIXME: simplify.  */
d2980 1
a2980 1
	  /* Fall through.  */
d3004 1
a3004 1
	  /* Fall through.  */
d3021 1
a3021 1
	  /* Fall through.  */
d3032 1
a3032 1
	  /* Fall through.  */
d3059 1
a3059 1
	      val ^= ~(offsetT) 0;
a3091 1

a3139 3
    case BFD_RELOC_SPARC_UA16:
    case BFD_RELOC_SPARC_UA32:
    case BFD_RELOC_SPARC_UA64:
d3193 1
a3193 1
#endif /* defined (OBJ_ELF) || defined (OBJ_AOUT)  */
d3227 1
a3227 1
#else /* elf or coff  */
d3249 1
a3249 2
      *reloc->sym_ptr_ptr
	= symbol_get_bfdsym (section_symbol (absolute_section));
d3258 1
a3258 1
/* We have no need to default values of symbols.  */
d3260 1
d3263 1
a3263 1
     char *name ATTRIBUTE_UNUSED;
d3266 1
a3266 3
}

/* Round up a section size to the appropriate boundary.  */
d3268 1
d3271 1
a3271 1
     segT segment ATTRIBUTE_UNUSED;
d3280 1
a3280 2

  /* Turn alignment value into a mask.  */
d3292 2
a3293 2
   (??? Is this right?  FIXME-SOON)  */
long
d3325 3
a3327 1
/* Sort of like s_lcomm.  */
d3335 1
a3335 1
     int ignore ATTRIBUTE_UNUSED;
d3365 1
a3365 1
    }				/* Bad length.  */
d3444 1
a3444 2
	  /* Switch to bss.  */
	  subseg_set (bss_section, 1);
d3447 1
a3447 2
	    /* Do alignment.  */
	    frag_align (align, 0, 0);
d3449 2
a3450 2
	  /* Detach from old frag.  */
	  if (S_GET_SEGMENT (symbolP) == bss_section)
d3454 2
a3455 2
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			    (offsetT) size, (char *) 0);
d3469 3
a3471 3
      as_warn ("Ignoring attempt to re-define symbol %s",
	       S_GET_NAME (symbolP));
    }				/* if not redefining.  */
d3478 1
a3478 1
     int ignore ATTRIBUTE_UNUSED;
d3488 1
a3488 1
  /* Just after name is now '\0'.  */
d3498 1
a3498 4

  /* Skip ','.  */
  input_line_pointer++;

d3597 1
a3597 1
#endif /* OBJ_ELF  */
d3656 1
a3656 1
     int ignore ATTRIBUTE_UNUSED;
d3665 1
a3665 1
     int ignore ATTRIBUTE_UNUSED;
d3691 2
a3692 2
	 You can still allocate SEG_BSS stuff with .lcomm or .reserve.  */
      subseg_set (data_section, 255);	/* FIXME-SOMEDAY.  */
d3708 1
a3708 1
     int ignore ATTRIBUTE_UNUSED;
d3741 1
a3741 1
     int bytes ATTRIBUTE_UNUSED;
d3750 1
a3750 1

d3752 1
a3752 1
*/
d3756 1
a3756 1
     int ignore ATTRIBUTE_UNUSED;
d3779 1
a3779 1
      if (regname[0] == 'i')
d3791 1
a3791 1
      if (globals[reg])
d3793 3
a3795 3
	  if ((regname && globals[reg] != (symbolS *) 1
	       && strcmp (S_GET_NAME (globals[reg]), regname))
	      || ((regname != NULL) ^ (globals[reg] != (symbolS *) 1)))
d3801 1
a3801 1
	    globals[reg] = (symbolS *) 1;
d3810 2
a3811 2
	      globals[reg] = symbol_make (regname);
	      flags = symbol_get_bfdsym (globals[reg])->flags;
d3816 4
a3819 4
	      symbol_get_bfdsym (globals[reg])->flags = flags;
	      S_SET_VALUE (globals[reg], (valueT) reg);
	      S_SET_ALIGN (globals[reg], reg);
	      S_SET_SIZE (globals[reg], 0);
d3824 3
a3826 3
	      S_SET_SEGMENT (globals[reg], absolute_section);
	      S_SET_OTHER (globals[reg], 0);
	      elf_symbol (symbol_get_bfdsym (globals[reg]))
d3829 1
a3829 1
	      elf_symbol (symbol_get_bfdsym (globals[reg]))
d3842 1
a3842 1

d3847 1
a3847 1

a3884 1
  /* Don't align if this is an unaligned pseudo-op.  */
d3886 5
a3890 1
    return;
d3905 1
a3905 1
  p = frag_var (rs_align_test, 1, 1, (relax_substateT) 0,
d3911 2
a3912 1
/* This is called from HANDLE_ALIGN in tc-sparc.h.  */
d3918 32
a3949 47
  int count, fix;
  char *p;

  count = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;

  switch (fragp->fr_type)
    {
    case rs_align_test:
      if (count != 0)
	as_bad_where (fragp->fr_file, fragp->fr_line, _("misaligned data"));
      break;

    case rs_align_code:
      p = fragp->fr_literal + fragp->fr_fix;
      fix = 0;

      if (count & 3)
	{
	  fix = count & 3;
	  memset (p, 0, fix);
	  p += fix;
	  count -= fix;
	}

      if (SPARC_OPCODE_ARCH_V9_P (max_architecture) && count > 8)
	{
	  unsigned wval = (0x30680000 | count >> 2); /* ba,a,pt %xcc, 1f  */
	  if (INSN_BIG_ENDIAN)
	    number_to_chars_bigendian (p, wval, 4);
	  else
	    number_to_chars_littleendian (p, wval, 4);
	  p += 4;
	  count -= 4;
	  fix += 4;
	}

      if (INSN_BIG_ENDIAN)
	number_to_chars_bigendian (p, 0x01000000, 4);
      else
	number_to_chars_littleendian (p, 0x01000000, 4);

      fragp->fr_fix += fix;
      fragp->fr_var = 4;
      break;

    default:
      break;
a3978 2
  else if (current_architecture == SPARC_OPCODE_ARCH_V9B)
    elf_elfheader (stdoutput)->e_flags |= EF_SPARC_SUN_US1|EF_SPARC_SUN_US3;
d3999 2
a4000 3
  if (target_little_endian_data
      && nbytes == 4
      && now_seg->flags & SEC_ALLOC)
a4001 13

  if (sparc_no_align_cons)
    {
      switch (nbytes)
	{
	case 2: r = BFD_RELOC_SPARC_UA16; break;
	case 4: r = BFD_RELOC_SPARC_UA32; break;
	case 8: r = BFD_RELOC_SPARC_UA64; break;
	default: abort ();
	}
      sparc_no_align_cons = 0;
    }

d4008 1
a4008 1
     struct fix *fixp;
d4013 1
a4013 1

d4017 1
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003
d23 1
a25 1
#include "safe-ctype.h"
a34 6
/* Some ancient Sun C compilers would not take such hex constants as
   unsigned, and would end up sign-extending them to form an offsetT,
   so use these constants instead.  */
#define U0xffffffff ((((unsigned long) 1 << 16) << 16) - 1)
#define U0x80000000 ((((unsigned long) 1 << 16) << 15))

a134 1
#ifdef OBJ_ELF
a135 1
#endif
d156 1
a156 1
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
d392 1
a392 1
const char *md_shortopts = "A:K:VQ:sq";
d395 1
a395 1
const char *md_shortopts = "A:k";
d397 1
a397 1
const char *md_shortopts = "A:";
d635 1
a635 1
      if (column + strlen (arch->name) > 70)
d640 1
a640 1
      column += 5 + 2 + strlen (arch->name);
d648 1
a648 1
      if (column + strlen (arch->name) > 65)
d653 1
a653 1
      column += 5 + 7 + strlen (arch->name);
d919 1
a919 1
      val = ((val & U0xffffffff) ^ sign) - sign;
d1022 1
a1022 1
		  || the_insn.exp.X_add_number > (offsetT) U0xffffffff))
d1028 2
a1029 2
	      && (the_insn.exp.X_add_number < -(offsetT) U0x80000000
		  || the_insn.exp.X_add_number > (offsetT) U0xffffffff))
d1088 2
a1089 2
      && (the_insn.exp.X_add_number < -(offsetT) U0x80000000
	  || the_insn.exp.X_add_number > (offsetT) U0xffffffff))
d1131 1
a1131 1
#define SIGNEXT32(x) ((((x) & U0xffffffff) ^ U0x80000000) - U0x80000000)
d1388 1
a1388 1
  if (ISLOWER (*s))
d1392 1
a1392 1
      while (ISLOWER (*s) || ISDIGIT (*s));
d1620 1
a1620 1
		  if (ISDIGIT (*s))
d1624 1
a1624 1
		      while (ISDIGIT (*s))
d1801 1
a1801 1
	      if (s[0] == ',' && s[1] == '%')
d1803 1
a1803 77
		  static const struct tls_ops {
		    /* The name as it appears in assembler.  */
		    char *name;
		    /* strlen (name), precomputed for speed */
		    int len;
		    /* The reloc this pseudo-op translates to.  */
		    int reloc;
		    /* 1 if call.  */
		    int call;
		  } tls_ops[] = {
		    { "tgd_add", 7, BFD_RELOC_SPARC_TLS_GD_ADD, 0 },
		    { "tgd_call", 8, BFD_RELOC_SPARC_TLS_GD_CALL, 1 },
		    { "tldm_add", 8, BFD_RELOC_SPARC_TLS_LDM_ADD, 0 },
		    { "tldm_call", 9, BFD_RELOC_SPARC_TLS_LDM_CALL, 1 },
		    { "tldo_add", 8, BFD_RELOC_SPARC_TLS_LDO_ADD, 0 },
		    { "tie_ldx", 7, BFD_RELOC_SPARC_TLS_IE_LDX, 0 },
		    { "tie_ld", 6, BFD_RELOC_SPARC_TLS_IE_LD, 0 },
		    { "tie_add", 7, BFD_RELOC_SPARC_TLS_IE_ADD, 0 }
		  };
		  const struct tls_ops *o;
		  char *s1;
		  int npar = 0;

		  for (o = tls_ops; o->name; o++)
		    if (strncmp (s + 2, o->name, o->len) == 0)
		      break;
		  if (o->name == NULL)
		    break;

		  if (s[o->len + 2] != '(')
		    {
		      as_bad (_("Illegal operands: %%%s requires arguments in ()"), o->name);
		      return special_case;
		    }

		  if (! o->call && the_insn.reloc != BFD_RELOC_NONE)
		    {
		      as_bad (_("Illegal operands: %%%s cannot be used together with other relocs in the insn ()"),
			      o->name);
		      return special_case;
		    }

		  if (o->call
		      && (the_insn.reloc != BFD_RELOC_32_PCREL_S2
			  || the_insn.exp.X_add_number != 0
			  || the_insn.exp.X_add_symbol
			     != symbol_find_or_make ("__tls_get_addr")))
		    {
		      as_bad (_("Illegal operands: %%%s can be only used with call __tls_get_addr"),
			      o->name);
		      return special_case;
		    }

		  the_insn.reloc = o->reloc;
		  memset (&the_insn.exp, 0, sizeof (the_insn.exp));
		  s += o->len + 3;

		  for (s1 = s; *s1 && *s1 != ',' && *s1 != ']'; s1++)
		    if (*s1 == '(')
		      npar++;
		    else if (*s1 == ')')
		      {
			if (!npar)
			  break;
			npar--;
		      }

		  if (*s1 != ')')
		    {
		      as_bad (_("Illegal operands: %%%s requires arguments in ()"), o->name);
		      return special_case;
		    }

		  *s1 = '\0';
		  (void) get_expression (s);
		  *s1 = ')';
		  s = s1 + 1;
a1804 2
	      if (*s == '\0')
		match = 1;
d1828 1
a1828 1
	      if (ISDIGIT (*s++))
d1830 1
a1830 1
		  while (ISDIGIT (*s))
d1849 1
a1849 1
	      if (*s++ == '%' && *s++ == 'c' && ISDIGIT (*s))
d1852 1
a1852 1
		  if (ISDIGIT (*s))
d1945 1
a1945 1
		      if (!ISDIGIT ((c = *s++)))
d1960 1
a1960 1
		      if (ISDIGIT (*s))
d2025 1
a2025 1
		    && ISDIGIT (*++s))
d2027 1
a2027 1
		    for (mask = 0; ISDIGIT (*s); ++s)
a2170 12
		      { "tgd_hi22", 8, BFD_RELOC_SPARC_TLS_GD_HI22, 0, 0 },
		      { "tgd_lo10", 8, BFD_RELOC_SPARC_TLS_GD_LO10, 0, 0 },
		      { "tldm_hi22", 9, BFD_RELOC_SPARC_TLS_LDM_HI22, 0, 0 },
		      { "tldm_lo10", 9, BFD_RELOC_SPARC_TLS_LDM_LO10, 0, 0 },
		      { "tldo_hix22", 10, BFD_RELOC_SPARC_TLS_LDO_HIX22, 0,
									 0 },
		      { "tldo_lox10", 10, BFD_RELOC_SPARC_TLS_LDO_LOX10, 0,
									 0 },
		      { "tie_hi22", 8, BFD_RELOC_SPARC_TLS_IE_HI22, 0, 0 },
		      { "tie_lo10", 8, BFD_RELOC_SPARC_TLS_IE_LO10, 0, 0 },
		      { "tle_hix22", 9, BFD_RELOC_SPARC_TLS_LE_HIX22, 0, 0 },
		      { "tle_lox10", 9, BFD_RELOC_SPARC_TLS_LE_LOX10, 0, 0 },
d2243 1
a2243 1
		if (s1 != s && ISDIGIT (s1[-1]))
a2372 7
		  if (the_insn.reloc >= BFD_RELOC_SPARC_TLS_GD_HI22
		      && the_insn.reloc <= BFD_RELOC_SPARC_TLS_TPOFF64)
		    {
		      error_message = _(": TLS operand can't be a constant");
		      goto error;
		    }

d2666 1
a2666 1
       ISALNUM (*q) || *q == '_';
d2884 2
a2885 2
void
md_apply_fix3 (fixP, valP, segment)
d2887 2
a2888 2
     valueT *valP;
     segT segment ATTRIBUTE_UNUSED;
d2891 1
a2891 1
  offsetT val = * (offsetT *) valP;
d2894 2
d2901 5
a2905 1
  /* SPARC ELF relocations don't use an addend in the data field.  */
d2907 18
a2924 1
    return;
d2994 1
a2994 1
      return;
d3166 3
a3168 1
	    insn |= (val >> 10) & 0x3fffff;
d3170 4
a3173 2
	    /* FIXME: Need comment explaining why we do this.  */
	    insn &= ~0xffff;
d3189 3
a3191 1
	    insn |= val & 0x3ff;
d3193 4
a3196 2
	    /* FIXME: Need comment explaining why we do this.  */
	    insn &= ~0xff;
d3267 2
d3276 1
a3276 1
     asection *section ATTRIBUTE_UNUSED;
a3324 6
    case BFD_RELOC_8_PCREL:
    case BFD_RELOC_16_PCREL:
    case BFD_RELOC_32_PCREL:
    case BFD_RELOC_64_PCREL:
    case BFD_RELOC_SPARC_PLT32:
    case BFD_RELOC_SPARC_PLT64:
a3326 20
    case BFD_RELOC_SPARC_TLS_GD_HI22:
    case BFD_RELOC_SPARC_TLS_GD_LO10:
    case BFD_RELOC_SPARC_TLS_GD_ADD:
    case BFD_RELOC_SPARC_TLS_GD_CALL:
    case BFD_RELOC_SPARC_TLS_LDM_HI22:
    case BFD_RELOC_SPARC_TLS_LDM_LO10:
    case BFD_RELOC_SPARC_TLS_LDM_ADD:
    case BFD_RELOC_SPARC_TLS_LDM_CALL:
    case BFD_RELOC_SPARC_TLS_LDO_HIX22:
    case BFD_RELOC_SPARC_TLS_LDO_LOX10:
    case BFD_RELOC_SPARC_TLS_LDO_ADD:
    case BFD_RELOC_SPARC_TLS_IE_HI22:
    case BFD_RELOC_SPARC_TLS_IE_LO10:
    case BFD_RELOC_SPARC_TLS_IE_LD:
    case BFD_RELOC_SPARC_TLS_IE_LDX:
    case BFD_RELOC_SPARC_TLS_IE_ADD:
    case BFD_RELOC_SPARC_TLS_LE_HIX22:
    case BFD_RELOC_SPARC_TLS_LE_LOX10:
    case BFD_RELOC_SPARC_TLS_DTPOFF32:
    case BFD_RELOC_SPARC_TLS_DTPOFF64:
d3351 4
a3354 1
	  if (generic_force_reloc (fixp))
d3414 3
a3416 7
  if (code != BFD_RELOC_32_PCREL_S2
      && code != BFD_RELOC_SPARC_WDISP22
      && code != BFD_RELOC_SPARC_WDISP16
      && code != BFD_RELOC_SPARC_WDISP19
      && code != BFD_RELOC_SPARC_WPLT30
      && code != BFD_RELOC_SPARC_TLS_GD_CALL
      && code != BFD_RELOC_SPARC_TLS_LDM_CALL)
a3911 5
/* This static variable is set by sparc_cons to emit requested types
   of relocations in cons_fix_new_sparc.  */

static const char *sparc_cons_special_reloc;

a3922 1
  sparc_no_align_cons = 0;
a4182 138

void
sparc_cons (exp, size)
     expressionS *exp;
     int size;
{
  char *save;

  SKIP_WHITESPACE ();
  sparc_cons_special_reloc = NULL;
  save = input_line_pointer;
  if (input_line_pointer[0] == '%'
      && input_line_pointer[1] == 'r'
      && input_line_pointer[2] == '_')
    {
      if (strncmp (input_line_pointer + 3, "disp", 4) == 0)
	{
	  input_line_pointer += 7;
	  sparc_cons_special_reloc = "disp";
	}
      else if (strncmp (input_line_pointer + 3, "plt", 3) == 0)
	{
	  if (size != 4 && size != 8)
	    as_bad (_("Illegal operands: %%r_plt in %d-byte data field"), size);
	  else
	    {
	      input_line_pointer += 6;
	      sparc_cons_special_reloc = "plt";
	    }
	}
      else if (strncmp (input_line_pointer + 3, "tls_dtpoff", 10) == 0)
	{
	  if (size != 4 && size != 8)
	    as_bad (_("Illegal operands: %%r_tls_dtpoff in %d-byte data field"), size);
	  else
	    {
	      input_line_pointer += 13;
	      sparc_cons_special_reloc = "tls_dtpoff";
	    }
	}
      if (sparc_cons_special_reloc)
	{
	  int bad = 0;

	  switch (size)
	    {
	    case 1:
	      if (*input_line_pointer != '8')
		bad = 1;
	      input_line_pointer--;
	      break;
	    case 2:
	      if (input_line_pointer[0] != '1' || input_line_pointer[1] != '6')
		bad = 1;
	      break;
	    case 4:
	      if (input_line_pointer[0] != '3' || input_line_pointer[1] != '2')
		bad = 1;
	      break;
	    case 8:
	      if (input_line_pointer[0] != '6' || input_line_pointer[1] != '4')
		bad = 1;
	      break;
	    default:
	      bad = 1;
	      break;
	    }

	  if (bad)
	    {
	      as_bad (_("Illegal operands: Only %%r_%s%d allowed in %d-byte data fields"),
		      sparc_cons_special_reloc, size * 8, size);
	    }
	  else
	    {
	      input_line_pointer += 2;
	      if (*input_line_pointer != '(')
		{
		  as_bad (_("Illegal operands: %%r_%s%d requires arguments in ()"),
			  sparc_cons_special_reloc, size * 8);
		  bad = 1;
		}
	    }

	  if (bad)
	    {
	      input_line_pointer = save;
	      sparc_cons_special_reloc = NULL;
	    }
	  else
	    {
	      int c;
	      char *end = ++input_line_pointer;
	      int npar = 0;

	      while (! is_end_of_line[(c = *end)])
		{
		  if (c == '(')
	  	    npar++;
		  else if (c == ')')
	  	    {
		      if (!npar)
	      		break;
		      npar--;
		    }
	    	  end++;
		}

	      if (c != ')')
		as_bad (_("Illegal operands: %%r_%s%d requires arguments in ()"),
			sparc_cons_special_reloc, size * 8);
	      else
		{
		  *end = '\0';
		  expression (exp);
		  *end = c;
		  if (input_line_pointer != end)
		    {
		      as_bad (_("Illegal operands: %%r_%s%d requires arguments in ()"),
			      sparc_cons_special_reloc, size * 8);
		    }
		  else
		    {
		      input_line_pointer++;
		      SKIP_WHITESPACE ();
		      c = *input_line_pointer;
		      if (! is_end_of_line[c] && c != ',')
			as_bad (_("Illegal operands: garbage after %%r_%s%d()"),
			        sparc_cons_special_reloc, size * 8);
		    }
		}
	    }
	}
    }
  if (sparc_cons_special_reloc == NULL)
    expression (exp);
}

d4207 1
a4207 25
  if (sparc_cons_special_reloc)
    {
      if (*sparc_cons_special_reloc == 'd')
	switch (nbytes)
	  {
	  case 1: r = BFD_RELOC_8_PCREL; break;
	  case 2: r = BFD_RELOC_16_PCREL; break;
	  case 4: r = BFD_RELOC_32_PCREL; break;
	  case 8: r = BFD_RELOC_64_PCREL; break;
	  default: abort ();
	  }
      else if (*sparc_cons_special_reloc == 'p')
	switch (nbytes)
	  {
	  case 4: r = BFD_RELOC_SPARC_PLT32; break;
	  case 8: r = BFD_RELOC_SPARC_PLT64; break;
	  }
      else
	switch (nbytes)
	  {
	  case 4: r = BFD_RELOC_SPARC_TLS_DTPOFF32; break;
	  case 8: r = BFD_RELOC_SPARC_TLS_DTPOFF64; break;
	  }
    }
  else if (sparc_no_align_cons)
d4216 2
a4217 1
   }
d4221 13
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004
a28 1
#include "dw2gencfi.h"
a118 3
/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
int sparc_cie_data_alignment;

d164 2
d728 1
a728 1
/* sparc64 privileged registers.  */
a802 1
  sparc_cie_data_alignment = sparc_arch_size == 64 ? -8 : -4;
a2145 6
			    if (*args == 'e' || *args == 'f' || *args == 'g')
			      {
				error_message
				  = _(": There are only 32 single precision f registers; [0-31]");
				goto error;
			      }
d3769 1
a3769 1
  offsetT temp, size;
d3790 1
a3790 2
      as_bad (_(".COMMon length (%lu) out of range ignored"),
	      (unsigned long) temp);
d3808 2
a3809 2
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), (long) size);
d3940 1
a3940 1
/* Handle the .empty pseudo-op.  This suppresses the warnings about
d4007 1
a4007 1
   that the expression does not need to be aligned.  */
a4485 59
  sparc_cons_special_reloc = NULL;
}

void
sparc_cfi_frame_initial_instructions ()
{
  cfi_add_CFA_def_cfa (14, sparc_arch_size == 64 ? 0x7ff : 0);
}

int
sparc_regname_to_dw2regnum (const char *regname)
{
  char *p, *q;

  if (!regname[0])
    return -1;

  q = "goli";
  p = strchr (q, regname[0]);
  if (p)
    {
      if (regname[1] < '0' || regname[1] > '8' || regname[2])
	return -1;
      return (p - q) * 8 + regname[1] - '0';
    }
  if (regname[0] == 's' && regname[1] == 'p' && !regname[2])
    return 14;
  if (regname[0] == 'f' && regname[1] == 'p' && !regname[2])
    return 30;
  if (regname[0] == 'f' || regname[0] == 'r')
    {
      unsigned int regnum;

      regnum = strtoul (regname + 1, &q, 10);
      if (p == q || *q)
        return -1;
      if (regnum >= ((regname[0] == 'f'
		      && SPARC_OPCODE_ARCH_V9_P (max_architecture))
		     ? 64 : 32))
	return -1;
      if (regname[0] == 'f')
	{
          regnum += 32;
          if (regnum >= 64 && (regnum & 1))
	    return -1;
        }
      return regnum;
    }
  return -1;
}

void
sparc_cfi_emit_pcrel_expr (expressionS *exp, unsigned int nbytes)
{
  sparc_cons_special_reloc = "disp";
  sparc_no_align_cons = 1;
  emit_expr (exp, nbytes);
  sparc_no_align_cons = 0;
  sparc_cons_special_reloc = NULL;
@


