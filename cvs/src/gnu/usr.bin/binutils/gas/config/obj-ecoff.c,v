head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.52
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.54
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.50
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.46
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.48
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.40
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.44
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.42
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.38
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.36
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.34
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.32
	OPENBSD_5_0:1.5.0.30
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.28
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.26
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.22
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.46;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.34.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.57;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.57;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.11.19.14.14.16;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.22.37;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.46.19;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.33.08;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.27;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* ECOFF object file format.
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
   Contributed by Cygnus Support.
   This file was put together by Ian Lance Taylor <ian@@cygnus.com>.

   This file is part of GAS.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#define OBJ_HEADER "obj-ecoff.h"
#include "as.h"
#include "coff/internal.h"
#include "bfd/libcoff.h"
#include "bfd/libecoff.h"

/* Almost all of the ECOFF support is actually in ecoff.c in the main
   gas directory.  This file mostly just arranges to call that one at
   the right times.  */

static int ecoff_sec_sym_ok_for_reloc PARAMS ((asection *));
static void obj_ecoff_frob_symbol PARAMS ((symbolS *, int *));
static void ecoff_pop_insert PARAMS ((void));
static int ecoff_separate_stab_sections PARAMS ((void));

/* These are the pseudo-ops we support in this file.  Only those
   relating to debugging information are supported here.

   The following pseudo-ops from the Kane and Heinrich MIPS book
   should be defined here, but are currently unsupported: .aent,
   .bgnb, .endb, .verstamp, .vreg.

   The following pseudo-ops from the Kane and Heinrich MIPS book are
   MIPS CPU specific, and should be defined by tc-mips.c: .alias,
   .extern, .galive, .gjaldef, .gjrlive, .livereg, .noalias, .option,
   .rdata, .sdata, .set.

   The following pseudo-ops from the Kane and Heinrich MIPS book are
   not MIPS CPU specific, but are also not ECOFF specific.  I have
   only listed the ones which are not already in read.c.  It's not
   completely clear where these should be defined, but tc-mips.c is
   probably the most reasonable place: .asciiz, .asm0, .endr, .err,
   .half, .lab, .repeat, .struct, .weakext.  */

const pseudo_typeS obj_pseudo_table[] =
{
  /* COFF style debugging information. .ln is not used; .loc is used
     instead.  */
  { "def",	ecoff_directive_def,	0 },
  { "dim",	ecoff_directive_dim,	0 },
  { "endef",	ecoff_directive_endef,	0 },
  { "file",	ecoff_directive_file,	0 },
  { "scl",	ecoff_directive_scl,	0 },
  { "size",	ecoff_directive_size,	0 },
  { "esize",	ecoff_directive_size,	0 },
  { "tag",	ecoff_directive_tag,	0 },
  { "type",	ecoff_directive_type,	0 },
  { "etype",	ecoff_directive_type,	0 },
  { "val",	ecoff_directive_val,	0 },

  /* ECOFF specific debugging information.  */
  { "begin",	ecoff_directive_begin,	0 },
  { "bend",	ecoff_directive_bend,	0 },
  { "end",	ecoff_directive_end,	0 },
  { "ent",	ecoff_directive_ent,	0 },
  { "fmask",	ecoff_directive_fmask,	0 },
  { "frame",	ecoff_directive_frame,	0 },
  { "loc",	ecoff_directive_loc,	0 },
  { "mask",	ecoff_directive_mask,	0 },

  /* Other ECOFF directives.  */
  { "extern",	ecoff_directive_extern,	0 },

#ifndef TC_MIPS
  /* For TC_MIPS, tc-mips.c adds this.  */
  { "weakext",	ecoff_directive_weakext, 0 },
#endif

  /* These are used on Irix.  I don't know how to implement them.  */
  { "bgnb",	s_ignore,		0 },
  { "endb",	s_ignore,		0 },
  { "verstamp",	s_ignore,		0 },

  /* Sentinel.  */
  { NULL,	s_ignore,		0 }
};

/* Set section VMAs and GP values before reloc processing.  */

void
ecoff_frob_file_before_fix ()
{
  bfd_vma addr;
  asection **sec;

  /* Set the section VMA values.  We force the .sdata and .sbss
     sections to the end to ensure that their VMA addresses are close
     together so that the GP register can address both of them.  We
     put the .bss section after the .sbss section.

     Also, for the Alpha, we must sort the sections, to make sure they
     appear in the output file in the correct order.  (Actually, maybe
     this is a job for BFD.  But the VMAs computed would be out of
     whack if we computed them given our initial, random ordering.
     It's possible that that wouldn't break things; I could do some
     experimenting sometime and find out.

     This output ordering of sections is magic, on the Alpha, at
     least.  The .lita section must come before .lit8 and .lit4,
     otherwise the OSF/1 linker may silently trash the .lit{4,8}
     section contents.  Also, .text must preceed .rdata.  These differ
     from the order described in some parts of the DEC OSF/1 Assembly
     Language Programmer's Guide, but that order doesn't seem to work
     with their linker.

     I don't know if section ordering on the MIPS is important.  */

  static const char *const names[] = {
    /* text segment */
    ".text", ".rdata", ".init", ".fini",
    /* data segment */
    ".data", ".lita", ".lit8", ".lit4", ".sdata", ".got",
    /* bss segment */
    ".sbss", ".bss",
  };
#define n_names ((int) (sizeof (names) / sizeof (names[0])))

  /* Sections that match names, order to be straightened out later.  */
  asection *secs[n_names];
  int i;

  addr = 0;
  for (i = 0; i < n_names; i++)
    secs[i] = 0;

  for (sec = &stdoutput->sections; *sec != (asection *) NULL; )
    {
      for (i = 0; i < n_names; i++)
	if (!strcmp ((*sec)->name, names[i]))
	  {
	    secs[i] = *sec;
	    bfd_section_list_remove (stdoutput, sec);
	    break;
	  }
      if (i == n_names)
	{
	  bfd_set_section_vma (stdoutput, *sec, addr);
	  addr += bfd_section_size (stdoutput, *sec);
	  sec = &(*sec)->next;
	}
    }
  for (i = 0; i < n_names; i++)
    if (secs[i])
      {
	bfd_set_section_vma (stdoutput, secs[i], addr);
	addr += bfd_section_size (stdoutput, secs[i]);
      }
  for (i = n_names - 1; i >= 0; i--)
    if (secs[i])
      bfd_section_list_insert (stdoutput, &stdoutput->sections, secs[i]);

  /* Fill in the register masks.  */
  {
    unsigned long gprmask = 0;
    unsigned long fprmask = 0;
    unsigned long *cprmask = NULL;

#ifdef TC_MIPS
    /* Fill in the MIPS register masks.  It's probably not worth
       setting up a generic interface for this.  */
    gprmask = mips_gprmask;
    cprmask = mips_cprmask;
#endif

#ifdef TC_ALPHA
    alpha_frob_ecoff_data ();

    if (! bfd_ecoff_set_gp_value (stdoutput, alpha_gp_value))
      as_fatal (_("Can't set GP value"));

    gprmask = alpha_gprmask;
    fprmask = alpha_fprmask;
#endif

    if (! bfd_ecoff_set_regmasks (stdoutput, gprmask, fprmask, cprmask))
      as_fatal (_("Can't set register masks"));
  }
}

/* Swap out the symbols and debugging information for BFD.  */

void
ecoff_frob_file ()
{
  const struct ecoff_debug_swap * const debug_swap
    = &ecoff_backend (stdoutput)->debug_swap;
  bfd_vma addr ATTRIBUTE_UNUSED;
  HDRR *hdr;
  char *buf;
  char *set;

  /* Build the ECOFF debugging information.  */
  assert (ecoff_data (stdoutput) != 0);
  hdr = &ecoff_data (stdoutput)->debug_info.symbolic_header;
  ecoff_build_debug (hdr, &buf, debug_swap);

  /* Finish up the ecoff_tdata structure.  */
  set = buf;
#define SET(ptr, count, type, size) \
  if (hdr->count == 0) \
    ecoff_data (stdoutput)->debug_info.ptr = (type) NULL; \
  else \
    { \
      ecoff_data (stdoutput)->debug_info.ptr = (type) set; \
      set += hdr->count * size; \
    }

  SET (line, cbLine, unsigned char *, sizeof (unsigned char));
  SET (external_dnr, idnMax, PTR, debug_swap->external_dnr_size);
  SET (external_pdr, ipdMax, PTR, debug_swap->external_pdr_size);
  SET (external_sym, isymMax, PTR, debug_swap->external_sym_size);
  SET (external_opt, ioptMax, PTR, debug_swap->external_opt_size);
  SET (external_aux, iauxMax, union aux_ext *, sizeof (union aux_ext));
  SET (ss, issMax, char *, sizeof (char));
  SET (ssext, issExtMax, char *, sizeof (char));
  SET (external_rfd, crfd, PTR, debug_swap->external_rfd_size);
  SET (external_fdr, ifdMax, PTR, debug_swap->external_fdr_size);
  SET (external_ext, iextMax, PTR, debug_swap->external_ext_size);
#undef SET
}

/* This is called by the ECOFF code to set the external information
   for a symbol.  We just pass it on to BFD, which expects the swapped
   information to be stored in the native field of the symbol.  */

void
obj_ecoff_set_ext (sym, ext)
     symbolS *sym;
     EXTR *ext;
{
  const struct ecoff_debug_swap * const debug_swap
    = &ecoff_backend (stdoutput)->debug_swap;
  ecoff_symbol_type *esym;

  know (bfd_asymbol_flavour (symbol_get_bfdsym (sym))
	== bfd_target_ecoff_flavour);
  esym = ecoffsymbol (symbol_get_bfdsym (sym));
  esym->local = FALSE;
  esym->native = xmalloc (debug_swap->external_ext_size);
  (*debug_swap->swap_ext_out) (stdoutput, ext, esym->native);
}

static int
ecoff_sec_sym_ok_for_reloc (sec)
     asection *sec ATTRIBUTE_UNUSED;
{
  return 1;
}

static void
obj_ecoff_frob_symbol (sym, puntp)
     symbolS *sym;
     int *puntp ATTRIBUTE_UNUSED;
{
  ecoff_frob_symbol (sym);
}

static void
ecoff_pop_insert ()
{
  pop_insert (obj_pseudo_table);
}

static int
ecoff_separate_stab_sections ()
{
  return 0;
}

const struct format_ops ecoff_format_ops =
{
  bfd_target_ecoff_flavour,
  0,	/* dfl_leading_underscore */

  /* FIXME: A comment why emit_section_symbols is different here (1) from
     the single-format definition (0) would be in order.  */
  1,	/* emit_section_symbols */
  0,	/* begin */
  ecoff_new_file,
  obj_ecoff_frob_symbol,
  ecoff_frob_file,
  0,	/* frob_file_before_adjust */
  ecoff_frob_file_before_fix,
  0,	/* frob_file_after_relocs */
  0,	/* s_get_size */
  0,	/* s_set_size */
  0,	/* s_get_align */
  0,	/* s_set_align */
  0,	/* s_get_other */
  0,	/* s_set_other */
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  0,	/* copy_symbol_attributes */
  ecoff_generate_asm_lineno,
  ecoff_stab,
  ecoff_separate_stab_sections,
  0,	/* init_stab_section */
  ecoff_sec_sym_ok_for_reloc,
  ecoff_pop_insert,
  ecoff_set_ext,
  ecoff_read_begin_hook,
  ecoff_symbol_new_hook
};
@


1.4
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
d101 1
a101 1
/* Swap out the symbols and debugging information for BFD.  */
d104 1
a104 1
ecoff_frob_file ()
a105 2
  const struct ecoff_debug_swap * const debug_swap
    = &ecoff_backend (stdoutput)->debug_swap;
d107 1
a107 4
  asection *sec;
  HDRR *hdr;
  char *buf;
  char *set;
d141 4
d146 7
a152 23
  {
    /* Sections that match names, order to be straightened out later.  */
    asection *secs[n_names];
    /* Linked list of sections with non-matching names.  Random ordering.  */
    asection *other_sections = 0;
    /* Pointer to next section, since we're destroying the original
       ordering.  */
    asection *next;

    int i;

    for (i = 0; i < n_names; i++)
      secs[i] = 0;
    for (sec = stdoutput->sections; sec != (asection *) NULL; sec = next)
      {
	next = sec->next;
	for (i = 0; i < n_names; i++)
	  if (!strcmp (sec->name, names[i]))
	    {
	      secs[i] = sec;
	      break;
	    }
	if (i == n_names)
d154 3
a156 4
	    bfd_set_section_vma (stdoutput, sec, addr);
	    addr += bfd_section_size (stdoutput, sec);
	    sec->next = other_sections;
	    other_sections = sec;
d158 1
a158 3
      }
    for (i = 0; i < n_names; i++)
      if (secs[i])
d160 3
a162 3
	  sec = secs[i];
	  bfd_set_section_vma (stdoutput, sec, addr);
	  addr += bfd_section_size (stdoutput, sec);
d164 36
a199 8
    for (i = n_names - 1; i >= 0; i--)
      if (secs[i])
	{
	  sec = secs[i];
	  sec->next = other_sections;
	  other_sections = sec;
	}
    stdoutput->sections = other_sections;
d201 13
a241 1

a242 27

  /* Fill in the register masks.  */
  {
    unsigned long gprmask = 0;
    unsigned long fprmask = 0;
    unsigned long *cprmask = NULL;

#ifdef TC_MIPS
    /* Fill in the MIPS register masks.  It's probably not worth
       setting up a generic interface for this.  */
    gprmask = mips_gprmask;
    cprmask = mips_cprmask;
#endif

#ifdef TC_ALPHA
    alpha_frob_ecoff_data ();

    if (! bfd_ecoff_set_gp_value (stdoutput, alpha_gp_value))
      as_fatal (_("Can't set GP value"));

    gprmask = alpha_gprmask;
    fprmask = alpha_fprmask;
#endif

    if (! bfd_ecoff_set_regmasks (stdoutput, gprmask, fprmask, cprmask))
      as_fatal (_("Can't set register masks"));
  }
d261 1
a261 1
  esym->local = false;
d306 1
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000
d37 1
d88 1
a88 1
  /* For TC_MIPS, tc-mips.c adds this. */
d98 1
a98 1
  { NULL }
d144 1
a144 1
#define n_names (sizeof (names) / sizeof (names[0]))
d275 1
a275 1
     asection *sec;
d283 1
a283 1
     int *puntp;
d294 6
d304 3
d308 2
d312 1
d319 1
d321 3
d327 2
d333 1
a333 1
  ecoff_symbol_new_hook,
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1993, 1994 Free Software Foundation, Inc.
d20 3
a22 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d34 4
d85 3
d89 1
d240 1
a240 1
      as_fatal ("Can't set GP value");
d247 1
a247 1
      as_fatal ("Can't set register masks");
d264 3
a266 2
  know (bfd_asymbol_flavour (sym->bsym) == bfd_target_ecoff_flavour);
  esym = ecoffsymbol (sym->bsym);
d296 2
a297 2
  0,
  1,
d300 8
a307 4
  0,
  0, 0,
  0, 0,
  0,
@


1.1
log
@Initial revision
@
text
@d289 1
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a288 1
  0,
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 1997 Free Software Foundation, Inc.
d19 2
a20 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a30 4

static int ecoff_sec_sym_ok_for_reloc PARAMS ((asection *));
static void obj_ecoff_frob_symbol PARAMS ((symbolS *, int *));
static void ecoff_pop_insert PARAMS ((void));
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
a83 3

#ifndef TC_MIPS
  /* For TC_MIPS, tc-mips.c adds this. */
a84 1
#endif
d235 1
a235 1
      as_fatal (_("Can't set GP value"));
d242 1
a242 1
      as_fatal (_("Can't set register masks"));
d259 2
a260 3
  know (bfd_asymbol_flavour (symbol_get_bfdsym (sym))
	== bfd_target_ecoff_flavour);
  esym = ecoffsymbol (symbol_get_bfdsym (sym));
d290 2
a291 2
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
d294 4
a297 8
  0,	/* frob_file_after_relocs */
  0,	/* s_get_size */
  0,	/* s_set_size */
  0,	/* s_get_align */
  0,	/* s_set_align */
  0,	/* s_get_other */
  0,	/* s_get_desc */
  0,	/* copy_symbol_attributes */
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
a36 1
static int ecoff_separate_stab_sections PARAMS ((void));
d87 1
a87 1
  /* For TC_MIPS, tc-mips.c adds this.  */
d97 1
a97 1
  { NULL,	s_ignore,		0 }
d143 1
a143 1
#define n_names ((int) (sizeof (names) / sizeof (names[0])))
d274 1
a274 1
     asection *sec ATTRIBUTE_UNUSED;
d282 1
a282 1
     int *puntp ATTRIBUTE_UNUSED;
a292 6
static int
ecoff_separate_stab_sections ()
{
  return 0;
}

a296 3

  /* FIXME: A comment why emit_section_symbols is different here (1) from
     the single-format definition (0) would be in order.  */
a297 2
  0,	/* begin */
  ecoff_new_file,
a299 1
  0,	/* frob_file_before_adjust */
a305 1
  0,	/* s_set_other */
a306 3
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
a309 2
  ecoff_separate_stab_sections,
  0,	/* init_stab_section */
d314 1
a314 1
  ecoff_symbol_new_hook
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
d101 1
a101 1
/* Set section VMAs and GP values before reloc processing.  */
d104 1
a104 1
ecoff_frob_file_before_fix ()
d106 2
d109 4
a112 1
  asection **sec;
a145 4
  /* Sections that match names, order to be straightened out later.  */
  asection *secs[n_names];
  int i;

d147 23
a169 7
  for (i = 0; i < n_names; i++)
    secs[i] = 0;

  for (sec = &stdoutput->sections; *sec != (asection *) NULL; )
    {
      for (i = 0; i < n_names; i++)
	if (!strcmp ((*sec)->name, names[i]))
d171 4
a174 3
	    secs[i] = *sec;
	    bfd_section_list_remove (stdoutput, sec);
	    break;
d176 10
a185 1
      if (i == n_names)
d187 3
a189 3
	  bfd_set_section_vma (stdoutput, *sec, addr);
	  addr += bfd_section_size (stdoutput, *sec);
	  sec = &(*sec)->next;
d191 1
a191 36
    }
  for (i = 0; i < n_names; i++)
    if (secs[i])
      {
	bfd_set_section_vma (stdoutput, secs[i], addr);
	addr += bfd_section_size (stdoutput, secs[i]);
      }
  for (i = n_names - 1; i >= 0; i--)
    if (secs[i])
      bfd_section_list_insert (stdoutput, &stdoutput->sections, secs[i]);

  /* Fill in the register masks.  */
  {
    unsigned long gprmask = 0;
    unsigned long fprmask = 0;
    unsigned long *cprmask = NULL;

#ifdef TC_MIPS
    /* Fill in the MIPS register masks.  It's probably not worth
       setting up a generic interface for this.  */
    gprmask = mips_gprmask;
    cprmask = mips_cprmask;
#endif

#ifdef TC_ALPHA
    alpha_frob_ecoff_data ();

    if (! bfd_ecoff_set_gp_value (stdoutput, alpha_gp_value))
      as_fatal (_("Can't set GP value"));

    gprmask = alpha_gprmask;
    fprmask = alpha_fprmask;
#endif

    if (! bfd_ecoff_set_regmasks (stdoutput, gprmask, fprmask, cprmask))
      as_fatal (_("Can't set register masks"));
a192 13
}

/* Swap out the symbols and debugging information for BFD.  */

void
ecoff_frob_file ()
{
  const struct ecoff_debug_swap * const debug_swap
    = &ecoff_backend (stdoutput)->debug_swap;
  bfd_vma addr ATTRIBUTE_UNUSED;
  HDRR *hdr;
  char *buf;
  char *set;
d221 1
d223 27
d268 1
a268 1
  esym->local = FALSE;
a312 1
  ecoff_frob_file_before_fix,
@


