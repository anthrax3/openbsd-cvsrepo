head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.50
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.46
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.48
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.40
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.44
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.42
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.38
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.36
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.34
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.32
	OPENBSD_5_0:1.4.0.30
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.28
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.26
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.22
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.24
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.05.17.21.54.31;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.37;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.54;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.46.32;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.37.42;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.34;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* tc-w65.c -- Assemble code for the W65816
   Copyright 1995, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

#include <stdio.h>
#include "as.h"
#include "bfd.h"
#include "subsegs.h"
#define DEFINE_TABLE
#include "../opcodes/w65-opc.h"

const char comment_chars[] = "!";
const char line_separator_chars[] = ";";
const char line_comment_chars[] = "!#";

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:

   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function  */

#define OP_BCC	0x90
#define OP_BCS	0xB0
#define OP_BEQ	0xF0
#define OP_BMI	0x30
#define OP_BNE	0xD0
#define OP_BPL	0x10
#define OP_BRA	0x80
#define OP_BRL	0x82
#define OP_BVC	0x50
#define OP_BVS	0x70

static void s_longa PARAMS ((int));
static char *parse_exp PARAMS ((char *));
static char *get_operands PARAMS ((const struct opinfo *, char *));
static const struct opinfo *get_specific PARAMS ((const struct opinfo *));
static void build_Mytes PARAMS ((const struct opinfo *));


const pseudo_typeS md_pseudo_table[] = {
  {"int", cons, 2},
  {"word", cons, 2},
  {"longa", s_longa, 0},
  {"longi", s_longa, 1},
  {0, 0, 0}
};

#if 0
int md_reloc_size;
#endif

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* Opcode mnemonics */
static struct hash_control *opcode_hash_control;

int M;				/* M flag */
int X;				/* X flag */

#define C(a,b) ENCODE_RELAX(a,b)
#define ENCODE_RELAX(what,length) (((what) << 2) + (length))

#define GET_WHAT(x) ((x>>2))

#define BYTE_DISP 1
#define WORD_DISP 2
#define UNDEF_BYTE_DISP 0
#define UNDEF_WORD_DISP 3

#define COND_BRANCH 	1
#define UNCOND_BRANCH   2
#define END 	3

#define BYTE_F 127		/* How far we can branch forwards */
#define BYTE_B -126		/* How far we can branch backwards */
#define WORD_F 32767
#define WORD_B 32768

relax_typeS md_relax_table[C (END, 0)] = {
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },

  /* COND_BRANCH */
  { 0,       0,       0,  0 },				/* UNDEF_BYTE_DISP */
  { BYTE_F,  BYTE_B,  2,  C (COND_BRANCH, WORD_DISP) },	/* BYTE_DISP */
  { WORD_F,  WORD_B,  5,  0 },				/* WORD_DISP */
  { 0,       0,       5,  0 },				/* UNDEF_WORD_DISP */

  /* UNCOND_BRANCH */
  { 0,       0,       0,  0 },				  /* UNDEF_BYTE_DISP */
  { BYTE_F,  BYTE_B,  2,  C (UNCOND_BRANCH, WORD_DISP) }, /* BYTE_DISP */
  { WORD_F,  WORD_B,  3,  0 },				  /* WORD_DISP */
  { 0,       0,       3,  0 }				  /* UNDEF_WORD_DISP */

};

/* This function is called once, at assembler startup time.  This
   should set up all the tables, etc that the MD part of the assembler
   needs.  */

static void
s_longa (xmode)
     int xmode;
{
  int *p = xmode ? &X : &M;
  while (*input_line_pointer == ' ')
    input_line_pointer++;
  if (strncmp (input_line_pointer, "on", 2) == 0)
    {
      input_line_pointer += 2;
      *p = 0;
    }
  else if (strncmp (input_line_pointer, "off", 3) == 0)
    {
      *p = 1;
      input_line_pointer += 3;
    }
  else
    as_bad (_("need on or off."));
  demand_empty_rest_of_line ();
}

void
md_begin ()
{
  const struct opinfo *opcode;
  char *prev_name = "";

  opcode_hash_control = hash_new ();

  /* Insert unique names into hash table.  */
  for (opcode = optable; opcode->name; opcode++)
    {
      if (strcmp (prev_name, opcode->name))
	{
	  prev_name = opcode->name;
	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
	}
    }

  flag_signed_overflow_ok = 1;
}

static expressionS immediate;	/* absolute expression */
static expressionS immediate1;	/* absolute expression */
int expr_size;
int expr_shift;
int tc_cons_reloc;

void
w65_expression (dest)
     expressionS *dest;
{
  expr_size = 0;
  expr_shift = 0;
  tc_cons_reloc = 0;
  while (*input_line_pointer == ' ')
    input_line_pointer++;

  if (*input_line_pointer == '<')
    {
      expr_size = 1;
      input_line_pointer++;
    }
  else if (*input_line_pointer == '>')
    {
      expr_shift = 1;
      input_line_pointer++;
    }
  else if (*input_line_pointer == '^')
    {
      expr_shift = 2;
      input_line_pointer++;
    }

  expr (0, dest);
}

int amode;

static char *
parse_exp (s)
     char *s;
{
  char *save;
  char *new;

  save = input_line_pointer;
  input_line_pointer = s;
  w65_expression (&immediate);
  if (immediate.X_op == O_absent)
    as_bad (_("missing operand"));
  new = input_line_pointer;
  input_line_pointer = save;
  return new;
}

static char *
get_operands (info, ptr)
     const struct opinfo *info;
     char *ptr;
{
  register int override_len = 0;
  register int bytes = 0;

  while (*ptr == ' ')
    ptr++;

  if (ptr[0] == '#')
    {
      ptr++;
      switch (info->amode)
	{
	case ADDR_IMMTOI:
	  bytes = X ? 1 : 2;
	  amode = ADDR_IMMTOI;
	  break;
	case ADDR_IMMTOA:
	  bytes = M ? 1 : 2;
	  amode = ADDR_IMMTOA;
	  break;
	case ADDR_IMMCOP:
	  bytes = 1;
	  amode = ADDR_IMMCOP;
	  break;
	case ADDR_DIR:
	  bytes = 2;
	  amode = ADDR_ABS;
	  break;
	default:
	  abort ();
	  break;
	}
      ptr = parse_exp (ptr);
    }
  else if (ptr[0] == '!')
    {
      ptr = parse_exp (ptr + 1);
      if (ptr[0] == ',')
	{
	  if (ptr[1] == 'y')
	    {
	      amode = ADDR_ABS_IDX_Y;
	      bytes = 2;
	      ptr += 2;
	    }
	  else if (ptr[1] == 'x')
	    {
	      amode = ADDR_ABS_IDX_X;
	      bytes = 2;
	      ptr += 2;
	    }
	  else
	    {
	      as_bad (_("syntax error after <exp"));
	    }
	}
      else
	{
	  amode = ADDR_ABS;
	  bytes = 2;
	}
    }
  else if (ptr[0] == '>')
    {
      ptr = parse_exp (ptr + 1);
      if (ptr[0] == ',' && ptr[1] == 'x')
	{
	  amode = ADDR_ABS_LONG_IDX_X;
	  bytes = 3;
	  ptr += 2;
	}
      else
	{
	  amode = ADDR_ABS_LONG;
	  bytes = 3;
	}
    }
  else if (ptr[0] == '<')
    {
      ptr = parse_exp (ptr + 1);
      if (ptr[0] == ',')
	{
	  if (ptr[1] == 'y')
	    {
	      amode = ADDR_DIR_IDX_Y;
	      ptr += 2;
	      bytes = 2;
	    }
	  else if (ptr[1] == 'x')
	    {
	      amode = ADDR_DIR_IDX_X;
	      ptr += 2;
	      bytes = 2;
	    }
	  else
	    {
	      as_bad (_("syntax error after <exp"));
	    }
	}
      else
	{
	  amode = ADDR_DIR;
	  bytes = 1;
	}
    }
  else if (ptr[0] == 'a')
    {
      amode = ADDR_ACC;
    }
  else if (ptr[0] == '(')
    {
      /* Look for (exp),y
	 (<exp),y
	 (exp,x)
	 (<exp,x)
	 (exp)
	 (!exp)
	 (exp)
	 (<exp)
	 (exp,x)
	 (!exp,x)
	 (exp,s)
	 (exp,s),y */

      ptr++;
      if (ptr[0] == '<')
	{
	  override_len = 1;
	  ptr++;
	}
      else if (ptr[0] == '!')
	{
	  override_len = 2;
	  ptr++;
	}
      else if (ptr[0] == '>')
	{
	  override_len = 3;
	  ptr++;
	}
      else
	{
	  override_len = 0;
	}
      ptr = parse_exp (ptr);

      if (ptr[0] == ',')
	{
	  ptr++;
	  if (ptr[0] == 'x' && ptr[1] == ')')
	    {
	      ptr += 2;

	      if (override_len == 1)
		{
		  amode = ADDR_DIR_IDX_IND_X;
		  bytes = 2;
		}
	      else
		{
		  amode = ADDR_ABS_IND_IDX;
		  bytes = 2;
		}
	    }
	  else if (ptr[0] == 's' && ptr[1] == ')'
		   && ptr[2] == ',' && ptr[3] == 'y')
	    {
	      amode = ADDR_STACK_REL_INDX_IDX;
	      bytes = 1;
	      ptr += 4;
	    }
	}
      else if (ptr[0] == ')')
	{
	  if (ptr[1] == ',' && ptr[2] == 'y')
	    {
	      amode = ADDR_DIR_IND_IDX_Y;
	      ptr += 3;
	      bytes = 2;
	    }
	  else
	    {
	      if (override_len == 1)
		{
		  amode = ADDR_DIR_IND;
		  bytes = 1;
		}
	      else
		{
		  amode = ADDR_ABS_IND;
		  bytes = 2;
		}
	      ptr++;

	    }
	}
    }
  else if (ptr[0] == '[')
    {
      ptr = parse_exp (ptr + 1);
      if (ptr[0] == ']')
	{
	  ptr++;
	  if (ptr[0] == ',' && ptr[1] == 'y')
	    {
	      bytes = 1;
	      amode = ADDR_DIR_IND_IDX_Y_LONG;
	      ptr += 2;
	    }
	  else
	    {
	      if (info->code == O_jmp)
		{
		  bytes = 2;
		  amode = ADDR_ABS_IND_LONG;
		}
	      else
		{
		  bytes = 1;
		  amode = ADDR_DIR_IND_LONG;
		}
	    }
	}
    }
  else
    {
      ptr = parse_exp (ptr);
      if (ptr[0] == ',')
	{
	  if (ptr[1] == 'y')
	    {
	      if (override_len == 1)
		{
		  bytes = 1;
		  amode = ADDR_DIR_IDX_Y;
		}
	      else
		{
		  amode = ADDR_ABS_IDX_Y;
		  bytes = 2;
		}
	      ptr += 2;
	    }
	  else if (ptr[1] == 'x')
	    {
	      if (override_len == 1)
		{
		  amode = ADDR_DIR_IDX_X;
		  bytes = 1;
		}
	      else
		{
		  amode = ADDR_ABS_IDX_X;
		  bytes = 2;
		}
	      ptr += 2;
	    }
	  else if (ptr[1] == 's')
	    {
	      bytes = 1;
	      amode = ADDR_STACK_REL;
	      ptr += 2;
	    }
	  else
	    {
	      bytes = 1;
	      immediate1 = immediate;
	      ptr = parse_exp (ptr + 1);
	      amode = ADDR_BLOCK_MOVE;
	    }
	}
      else
	{
	  switch (info->amode)
	    {
	    case ADDR_PC_REL:
	      amode = ADDR_PC_REL;
	      bytes = 1;
	      break;
	    case ADDR_PC_REL_LONG:
	      amode = ADDR_PC_REL_LONG;
	      bytes = 2;
	      break;
	    default:
	      if (override_len == 1)
		{
		  amode = ADDR_DIR;
		  bytes = 1;
		}
	      else if (override_len == 3)
		{
		  bytes = 3;
		  amode = ADDR_ABS_LONG;
		}
	      else
		{
		  amode = ADDR_ABS;
		  bytes = 2;
		}
	    }
	}
    }

  switch (bytes)
    {
    case 1:
      switch (expr_shift)
	{
	case 0:
	  if (amode == ADDR_DIR)
	    tc_cons_reloc = R_W65_DP;
	  else
	    tc_cons_reloc = R_W65_ABS8;
	  break;
	case 1:
	  tc_cons_reloc = R_W65_ABS8S8;
	  break;
	case 2:
	  tc_cons_reloc = R_W65_ABS8S16;
	  break;
	}
      break;
    case 2:
      switch (expr_shift)
	{
	case 0:
	  tc_cons_reloc = R_W65_ABS16;
	  break;
	case 1:
	  tc_cons_reloc = R_W65_ABS16S8;
	  break;
	case 2:
	  tc_cons_reloc = R_W65_ABS16S16;
	  break;
	}
    }
  return ptr;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes, return the opcode which matches the opcodes
   provided.  */

static const struct opinfo *
get_specific (opcode)
     const struct opinfo *opcode;
{
  int ocode = opcode->code;

  for (; opcode->code == ocode; opcode++)
    {
      if (opcode->amode == amode)
	return opcode;
    }
  return 0;
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static void
build_Mytes (opcode)
     const struct opinfo *opcode;
{
  int size;
  int type;
  int pcrel;
  char *output;

  if (opcode->amode == ADDR_IMPLIED)
    {
      output = frag_more (1);
    }
  else if (opcode->amode == ADDR_PC_REL)
    {
      int type;

      /* This is a relaxable insn, so we do some special handling.  */
      type = opcode->val == OP_BRA ? UNCOND_BRANCH : COND_BRANCH;
      output = frag_var (rs_machine_dependent,
			 md_relax_table[C (type, WORD_DISP)].rlx_length,
			 md_relax_table[C (type, BYTE_DISP)].rlx_length,
			 C (type, UNDEF_BYTE_DISP),
			 immediate.X_add_symbol,
			 immediate.X_add_number,
			 0);
    }
  else
    {
      switch (opcode->amode)
	{
	  GETINFO (size, type, pcrel);
	default:
	  abort ();
	}

      /* If something special was done in the expression modify the
	 reloc type.  */
      if (tc_cons_reloc)
	type = tc_cons_reloc;

      /* 1 byte for the opcode + the bytes for the addrmode.  */
      output = frag_more (size + 1);

      if (opcode->amode == ADDR_BLOCK_MOVE)
	{
	  /* Two relocs for this one.  */
	  fix_new_exp (frag_now,
		       output + 1 - frag_now->fr_literal,
		       1,
		       &immediate,
		       0,
		       R_W65_ABS8S16);

	  fix_new_exp (frag_now,
		       output + 2 - frag_now->fr_literal,
		       1,
		       &immediate1,
		       0,
		       R_W65_ABS8S16);
	}
      else if (type >= 0
	       && opcode->amode != ADDR_IMPLIED
	       && opcode->amode != ADDR_ACC
	       && opcode->amode != ADDR_STACK)
	{
	  fix_new_exp (frag_now,
		       output + 1 - frag_now->fr_literal,
		       size,
		       &immediate,
		       pcrel,
		       type);
	}
    }
  output[0] = opcode->val;
}

/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (str)
     char *str;
{
  const struct opinfo *opcode;
  char name[20];

  /* Drop leading whitespace */
  while (*str == ' ')
    str++;

  /* all opcodes are three letters */
  name[0] = str[0];
  name[1] = str[1];
  name[2] = str[2];
  name[3] = 0;

  tc_cons_reloc = 0;
  str += 3;
  opcode = (struct opinfo *) hash_find (opcode_hash_control, name);

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  if (opcode->amode != ADDR_IMPLIED
      && opcode->amode != ADDR_STACK)
    {
      get_operands (opcode, str);
      opcode = get_specific (opcode);
    }

  if (opcode == 0)
    {
      /* Couldn't find an opcode which matched the operands.  */

      char *where = frag_more (1);

      where[0] = 0x0;
      where[1] = 0x0;
      as_bad (_("invalid operands for opcode"));
      return;
    }

  build_Mytes (opcode);
}

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_NTOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

int
md_parse_option (c, a)
     int c ATTRIBUTE_UNUSED;
     char *a ATTRIBUTE_UNUSED;
{
  return 0;
}

/* Called after relaxing, change the frags so they know how big they
   are.  */

void
md_convert_frag (headers, seg, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP;
{
  int disp_size = 0;
  int inst_size = 0;
  unsigned char *buffer =
    (unsigned char *) (fragP->fr_fix + fragP->fr_literal);

  switch (fragP->fr_subtype)
    {
    case C (COND_BRANCH, BYTE_DISP):
    case C (UNCOND_BRANCH, BYTE_DISP):
      disp_size = 1;
      inst_size = 1;
      break;

      /* Conditional branches to a known 16 bit displacement.  */
    case C (COND_BRANCH, WORD_DISP):
      switch (buffer[0])
	{
	case OP_BCC:
	case OP_BCS:
	case OP_BEQ:
	case OP_BMI:
	case OP_BNE:
	case OP_BPL:
	case OP_BVS:
	case OP_BVC:
	  /* Invert the sense of the test */
	  buffer[0] ^= 0x20;
	  buffer[1] = 3;	/* Jump over following brl */
	  buffer[2] = OP_BRL;
	  buffer[3] = 0;
	  buffer[4] = 0;
	  disp_size = 2;
	  inst_size = 3;
	  break;
	default:
	  abort ();
	}
      break;
    case C (UNCOND_BRANCH, WORD_DISP):
      /* Unconditional branches to a known 16 bit displacement.  */

      switch (buffer[0])
	{
	case OP_BRA:
	  buffer[0] = OP_BRL;
	  disp_size = 2;
	  inst_size = 1;
	  break;
	default:
	  abort ();
	}
      break;
      /* Got to create a branch over a reloc here.  */
    case C (COND_BRANCH, UNDEF_WORD_DISP):
      buffer[0] ^= 0x20;	/* invert test */
      buffer[1] = 3;
      buffer[2] = OP_BRL;
      buffer[3] = 0;
      buffer[4] = 0;
      fix_new (fragP,
	       fragP->fr_fix + 3,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       R_W65_PCR16);

      fragP->fr_fix += disp_size + inst_size;
      fragP->fr_var = 0;
      break;
    case C (UNCOND_BRANCH, UNDEF_WORD_DISP):
      buffer[0] = OP_BRL;
      buffer[1] = 0;
      buffer[2] = 0;
      fix_new (fragP,
	       fragP->fr_fix + 1,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       R_W65_PCR16);

      fragP->fr_fix += disp_size + inst_size;
      fragP->fr_var = 0;
      break;
    default:
      abort ();
    }
  if (inst_size)
    {
      /* Get the address of the end of the instruction.  */
      int next_inst = (fragP->fr_fix + fragP->fr_address
		       + disp_size + inst_size);
      int targ_addr = (S_GET_VALUE (fragP->fr_symbol) +
		       fragP->fr_offset);
      int disp = targ_addr - next_inst;

      md_number_to_chars (buffer + inst_size, disp, disp_size);
      fragP->fr_fix += disp_size + inst_size;
      fragP->fr_var = 0;
    }
}

valueT
md_section_align (seg, size)
     segT seg;
     valueT size;
{
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
}

void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
{
  long val = * (long *) valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  int addr = fixP->fx_frag->fr_address + fixP->fx_where;

  if (fixP->fx_r_type == 0)
    {
      if (fixP->fx_size == 1)
	fixP->fx_r_type = R_W65_ABS8;
      else
	fixP->fx_r_type = R_W65_ABS16;
    }

  switch (fixP->fx_r_type)
    {
    case R_W65_ABS8S16:
      val >>= 8;
    case R_W65_ABS8S8:
      val >>= 8;
    case R_W65_ABS8:
      *buf++ = val;
      break;
    case R_W65_ABS16S16:
      val >>= 8;
    case R_W65_ABS16S8:
      val >>= 8;
    case R_W65_ABS16:
      *buf++ = val >> 0;
      *buf++ = val >> 8;
      break;
    case R_W65_ABS24:
      *buf++ = val >> 0;
      *buf++ = val >> 8;
      *buf++ = val >> 16;
      break;
    case R_W65_PCR8:
      *buf++ = val - addr - 1;
      break;
    case R_W65_PCR16:
      val = val - addr - 1;
      *buf++ = val;
      *buf++ = val >> 8;
      break;
    case R_W65_DP:
      *buf++ = val;
      break;

    default:
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Put number into target byte order.  */

void
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
{
  number_to_chars_littleendian (ptr, use, nbytes);
}

long
md_pcrel_from (fixP)
     fixS *fixP;
{
  int gap = fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address - 1;
  return gap;
}

void
tc_coff_symbol_emit_hook (x)
     symbolS *x ATTRIBUTE_UNUSED;
{
}

short
tc_coff_fix2rtype (fix_ptr)
     fixS *fix_ptr;
{
  return fix_ptr->fx_r_type;
}

void
tc_reloc_mangle (fix_ptr, intr, base)
     fixS *fix_ptr;
     struct internal_reloc *intr;
     bfd_vma base;

{
  symbolS *symbol_ptr;

  symbol_ptr = fix_ptr->fx_addsy;

  /* If this relocation is attached to a symbol then it's ok
     to output it */
  if (fix_ptr->fx_r_type == RELOC_32)
    {
      /* cons likes to create reloc32's whatever the size of the reloc..
       */
      switch (fix_ptr->fx_size)
	{
	case 2:
	  intr->r_type = R_IMM16;
	  break;
	case 1:
	  intr->r_type = R_IMM8;
	  break;
	default:
	  abort ();
	}
    }
  else
    {
      if (fix_ptr->fx_size == 4)
	intr->r_type = R_W65_ABS24;
      else
	intr->r_type = fix_ptr->fx_r_type;
    }

  intr->r_vaddr = fix_ptr->fx_frag->fr_address + fix_ptr->fx_where + base;
  intr->r_offset = fix_ptr->fx_offset;

  /* Turn the segment of the symbol into an offset.  */
  if (symbol_ptr)
    {
      symbolS *dot;

      dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
      if (dot)
	{
	  intr->r_offset += S_GET_VALUE (symbol_ptr);
	  intr->r_symndx = dot->sy_number;
	}
      else
	{
	  intr->r_symndx = symbol_ptr->sy_number;
	}
    }
  else
    {
      intr->r_symndx = -1;
    }
}

int
tc_coff_sizemachdep (frag)
     fragS *frag;
{
  return md_relax_table[frag->fr_subtype].rlx_length;
}

/* Called just before address relaxation, return the length by which a
   fragment must grow to reach it's destination.  */

int
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP;
     register segT segment_type;
{
  int what;

  switch (fragP->fr_subtype)
    {
    default:
      abort ();

    case C (COND_BRANCH, UNDEF_BYTE_DISP):
    case C (UNCOND_BRANCH, UNDEF_BYTE_DISP):
      what = GET_WHAT (fragP->fr_subtype);
      /* Used to be a branch to somewhere which was unknown.  */
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  /* Got a symbol and it's defined in this segment, become byte
	     sized - maybe it will fix up.  */
	  fragP->fr_subtype = C (what, BYTE_DISP);
	}
      else
	{
	  /* Its got a segment, but its not ours, so it will always be
             long.  */
	  fragP->fr_subtype = C (what, UNDEF_WORD_DISP);
	}
      break;

    case C (COND_BRANCH, BYTE_DISP):
    case C (COND_BRANCH, WORD_DISP):
    case C (COND_BRANCH, UNDEF_WORD_DISP):
    case C (UNCOND_BRANCH, BYTE_DISP):
    case C (UNCOND_BRANCH, WORD_DISP):
    case C (UNCOND_BRANCH, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
    }

  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
  return fragP->fr_var;
}

const char *md_shortopts = "";
struct option md_longopts[] = {
#define OPTION_RELAX (OPTION_MD_BASE)
  {NULL, no_argument, NULL, 0}
};

void
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
{
}

size_t md_longopts_size = sizeof (md_longopts);
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001 Free Software Foundation, Inc.
a28 1
#include <ctype.h>
d31 1
a31 1
CONST char line_separator_chars[] = ";";
d52 6
a57 1
void s_longa ();
a66 3
void cons ();
void s_align_bytes ();

a70 2
static int relax;		/* set if -relax seen */

d127 1
a127 1
void
d129 1
d152 1
a152 1
  struct opinfo *opcode;
a164 6
      else
	{
	  /* Make all the opcodes with the same name point to the same
	     string.  */
	  opcode->name = prev_name;
	}
a171 16

static symbolS *
dot ()
{
  const char *fake;

  /* JF: '.' is pseudo symbol with value of current location
     in current segment.  */
  fake = FAKE_LABEL_NAME;
  return symbol_new (fake,
		     now_seg,
		     (valueT) frag_now_fix (),
		     frag_now);

}

d177 1
a177 1
w65_expression (dest, bytes)
a178 1
     unsigned int bytes;
d208 1
a208 1
parse_exp (s, bytes)
a209 1
     int bytes;
d216 1
a216 1
  w65_expression (&immediate, bytes);
d226 1
a226 1
     struct opinfo *info;
d454 1
a454 1
      ptr = parse_exp (ptr, 2);
d571 1
a571 1
static struct opinfo *
d573 1
a573 1
     struct opinfo *opcode;
a584 17
int
check (operand, low, high)
     expressionS *operand;
     int low;
     int high;
{
  if (operand->X_op != O_constant
      || operand->X_add_number < low
      || operand->X_add_number > high)
    {
      as_bad ("operand must be absolute in range %d..%d", low, high);
    }
  return operand->X_add_number;
}

static int log2[] = { 0, 0, 1, 0, 2 };

d589 1
a589 1
     struct opinfo *opcode;
d619 2
d672 1
a672 3
  unsigned char *op_start;
  unsigned char *op_end;
  struct opinfo *opcode;
a673 2
  int nlen = 0;
  char *p;
a716 7
void
tc_crawl_symbol_chain (headers)
     object_headers *headers;
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}

d719 1
a719 1
     char *name;
a723 7
void
tc_headers_hook (headers)
     object_headers *headers;
{
  printf (_("call to tc_headers_hook \n"));
}

a742 1
  char *atof_ieee ();
d789 2
a790 2
     int c;
     char *a;
d792 1
a792 8
  return 1;
}

void
tc_Nout_fix_to_chars ()
{
  printf (_("call to tc_Nout_fix_to_chars \n"));
  abort ();
d800 2
a801 2
     object_headers *headers;
     segT seg;
d917 1
a917 1
md_apply_fix (fixP, val)
d919 2
a920 1
     long val;
d922 1
d971 3
d976 1
a976 1
/* Put number into target byte order */
d997 1
a997 1
     symbolS *x;
d1125 1
a1125 1
CONST char *md_shortopts = "";
d1133 1
a1133 1
     FILE *stream;
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1998 Free Software Foundation.
d21 1
a21 4
/*
   Written By Steve Chamberlain
   sac@@cygnus.com
 */
d37 1
d40 1
a40 2
   Integer arg to pass to the function
 */
d54 2
a55 2
const pseudo_typeS md_pseudo_table[] =
{
a62 1

d66 3
a68 2

/*int md_reloc_size; */
d74 1
a74 1
/* Chars that mean this number is a floating point constant */
d79 2
a80 3


static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
a84 3



d104 17
a120 1
relax_typeS md_relax_table[C (END, 0)];
d122 1
a122 4
/*
   This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs
 */
d124 3
d148 1
a151 1
  relax_typeS *table;
d157 1
a157 1
  /* Insert unique names into hash table */
d168 1
a168 1
	     string */
a172 24

  /* Initialize the relax table.  We use a local variable to avoid
     warnings about modifying a supposedly const data structure.  */
  table = (relax_typeS *) md_relax_table;
  table[C (COND_BRANCH, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (COND_BRANCH, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (COND_BRANCH, BYTE_DISP)].rlx_length = 2;
  table[C (COND_BRANCH, BYTE_DISP)].rlx_more = C (COND_BRANCH, WORD_DISP);

  table[C (COND_BRANCH, WORD_DISP)].rlx_forward = WORD_F;
  table[C (COND_BRANCH, WORD_DISP)].rlx_backward = WORD_B;
  table[C (COND_BRANCH, WORD_DISP)].rlx_length = 5;
  table[C (COND_BRANCH, WORD_DISP)].rlx_more = 0;

  table[C (UNCOND_BRANCH, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (UNCOND_BRANCH, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (UNCOND_BRANCH, BYTE_DISP)].rlx_length = 2;
  table[C (UNCOND_BRANCH, BYTE_DISP)].rlx_more = C (UNCOND_BRANCH, WORD_DISP);

  table[C (UNCOND_BRANCH, WORD_DISP)].rlx_forward = WORD_F;
  table[C (UNCOND_BRANCH, WORD_DISP)].rlx_backward = WORD_B;
  table[C (UNCOND_BRANCH, WORD_DISP)].rlx_length = 3;
  table[C (UNCOND_BRANCH, WORD_DISP)].rlx_more = 0;

a178 1

d197 1
d229 2
a230 2
static
char *
d248 1
a248 3

static
char *
d255 1
d416 2
a417 1
	  else if (ptr[0] == 's' && ptr[1] == ')' && ptr[2] == ',' && ptr[3] == 'y')
a447 1

d463 1
a463 1
	      if (info->code == O_jmp) 
d465 8
a472 9
		bytes = 2;
		amode = ADDR_ABS_IND_LONG;
	      } 
	      else 
{
		bytes = 1;
	      
		amode = ADDR_DIR_IND_LONG;
	      }
d562 1
a562 1
	tc_cons_reloc = R_W65_DP;
d564 1
a564 1
tc_cons_reloc = R_W65_ABS8;
d593 1
a593 2
   provided
 */
d595 1
a595 2
static
struct opinfo *
d624 1
d626 1
a626 2
static int log2[] =
{0, 0, 1, 0, 2};
a627 2
/* Now we know what sort of opcodes it is, lets build the bytes -
 */
d644 2
a645 1
      /* This is a relaxable insn, so we do some special handling */
d662 2
a663 2
      /* If something special was done in the
	 expression modify the reloc type */
d665 1
a665 4
	{
	  type = tc_cons_reloc;
	}

d667 1
a667 2

      /* 1 byte for the opcode + the bytes for the addrmode */
d672 1
a672 1
	  /* Two relocs for this one */
d703 3
a705 4
/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.
 */
d747 1
a747 2
      /* Couldn't find an opcode which matched the operands */

a759 1

d761 2
a762 2
DEFUN (tc_crawl_symbol_chain, (headers),
       object_headers * headers)
d768 2
a769 2
DEFUN (md_undefined_symbol, (name),
       char *name)
d775 2
a776 2
DEFUN (tc_headers_hook, (headers),
       object_headers * headers)
d781 2
a782 2
/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
d785 5
a789 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
d846 3
a848 4
md_parse_option (c,a)
    int c;
    char *a;

d860 3
a862 3
/*
called after relaxing, change the frags so they know how big they are
*/
d871 2
a872 1
  unsigned char *buffer = (unsigned char *) (fragP->fr_fix + fragP->fr_literal);
d882 1
a882 1
      /* cond branches to a known 16 bit displacement */
d908 1
a908 1
      /* Unconditional branches to a known 16 bit displacement */
d921 1
a921 1
      /* got to create a branch over a reloc here */
d959 3
a961 2
      /* Get the address of the end of the instruction */
      int next_inst = fragP->fr_fix + fragP->fr_address + disp_size + inst_size;
a971 1

d973 3
a975 3
DEFUN (md_section_align, (seg, size),
       segT seg AND
       valueT size)
a978 1

d1057 1
a1057 1
    symbolS *x;
d1137 2
a1139 7



/*
called just before address relaxation, return the length
by which a fragment must grow to reach it's destination
*/
d1145 1
a1145 1
  int what = GET_WHAT (fragP->fr_subtype);
d1151 1
d1154 2
a1155 1
      /* used to be a branch to somewhere which was unknown */
d1159 1
a1159 1
	 sized - maybe it will fix up */
a1160 1
	  fragP->fr_var = md_relax_table[C (what, BYTE_DISP)].rlx_length;
d1164 2
a1165 1
	  /* Its got a segment, but its not ours, so it will always be long */
a1166 2
	  fragP->fr_var = md_relax_table[C (what, WORD_DISP)].rlx_length;
	  return md_relax_table[C (what, WORD_DISP)].rlx_length;
d1168 11
d1180 2
a1184 2


a1194 1

d1197 1
a1197 1
size_t md_longopts_size = sizeof(md_longopts);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2

   Copyright (C) 1995 Free Software Foundation.
d17 3
a19 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d136 1
a136 1
    as_bad ("need on or off.");
d257 1
a257 1
    as_bad ("missing operand");
d321 1
a321 1
	      as_bad ("syntax error after <exp");
d364 1
a364 1
	      as_bad ("syntax error after <exp");
d759 1
a759 1
      as_bad ("unknown opcode");
d779 1
a779 1
      as_bad ("invalid operands for opcode");
d791 1
a791 1
  printf ("call to tc_crawl_symbol_chain \n");
d805 1
a805 1
  printf ("call to tc_headers_hook \n");
d856 1
a856 1
      return "Bad call to MD_NTOF()";
a879 2
int md_short_jump_size;

d883 1
a883 1
  printf ("call to tc_Nout_fix_to_chars \n");
a886 22
void
md_create_short_jump (ptr, from_Nddr, to_Nddr, frag, to_symbol)
     char *ptr;
     addressT from_Nddr;
     addressT to_Nddr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}

void
md_create_long_jump (ptr, from_Nddr, to_Nddr, frag, to_symbol)
     char *ptr;
     addressT from_Nddr, to_Nddr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}


a1062 2
int md_long_jump_size;

d1084 1
a1084 1
    struct symbol *x;
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 1
   Copyright (C) 1995, 1998 Free Software Foundation.
d18 2
a19 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d136 1
a136 1
    as_bad (_("need on or off."));
d257 1
a257 1
    as_bad (_("missing operand"));
d321 1
a321 1
	      as_bad (_("syntax error after <exp"));
d364 1
a364 1
	      as_bad (_("syntax error after <exp"));
d759 1
a759 1
      as_bad (_("unknown opcode"));
d779 1
a779 1
      as_bad (_("invalid operands for opcode"));
d791 1
a791 1
  printf (_("call to tc_crawl_symbol_chain \n"));
d805 1
a805 1
  printf (_("call to tc_headers_hook \n"));
d856 1
a856 1
      return _("Bad call to MD_NTOF()");
d880 2
d885 1
a885 1
  printf (_("call to tc_Nout_fix_to_chars \n"));
d889 22
d1087 2
d1110 1
a1110 1
    symbolS *x;
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001 Free Software Foundation, Inc.
d21 4
a24 1
/* Written By Steve Chamberlain <sac@@cygnus.com>.  */
a39 1

d42 2
a43 1
   Integer arg to pass to the function  */
d57 2
a58 2

const pseudo_typeS md_pseudo_table[] = {
d66 1
d70 2
a71 3
#if 0
int md_reloc_size;
#endif
d77 1
a77 1
/* Chars that mean this number is a floating point constant.  */
d82 3
a84 2
/* Opcode mnemonics */
static struct hash_control *opcode_hash_control;
d89 3
d111 1
a111 17
relax_typeS md_relax_table[C (END, 0)] = {
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },

  /* COND_BRANCH */
  { 0,       0,       0,  0 },				/* UNDEF_BYTE_DISP */
  { BYTE_F,  BYTE_B,  2,  C (COND_BRANCH, WORD_DISP) },	/* BYTE_DISP */
  { WORD_F,  WORD_B,  5,  0 },				/* WORD_DISP */
  { 0,       0,       5,  0 },				/* UNDEF_WORD_DISP */

  /* UNCOND_BRANCH */
  { 0,       0,       0,  0 },				  /* UNDEF_BYTE_DISP */
  { BYTE_F,  BYTE_B,  2,  C (UNCOND_BRANCH, WORD_DISP) }, /* BYTE_DISP */
  { WORD_F,  WORD_B,  3,  0 },				  /* WORD_DISP */
  { 0,       0,       3,  0 }				  /* UNDEF_WORD_DISP */
d113 4
a116 1
};
a117 3
/* This function is called once, at assembler startup time.  This
   should set up all the tables, etc that the MD part of the assembler
   needs.  */
a138 1

d142 1
d148 1
a148 1
  /* Insert unique names into hash table.  */
d159 1
a159 1
	     string.  */
d164 24
d194 1
a212 1

d244 2
a245 2

static char *
d263 3
a265 1
static char *
a271 1

d432 1
a432 2
	  else if (ptr[0] == 's' && ptr[1] == ')'
		   && ptr[2] == ',' && ptr[3] == 'y')
d463 1
d479 1
a479 1
	      if (info->code == O_jmp)
d481 9
a489 8
		  bytes = 2;
		  amode = ADDR_ABS_IND_LONG;
		}
	      else
		{
		  bytes = 1;
		  amode = ADDR_DIR_IND_LONG;
		}
d579 1
a579 1
	    tc_cons_reloc = R_W65_DP;
d581 1
a581 1
	    tc_cons_reloc = R_W65_ABS8;
d610 2
a611 1
   provided.  */
d613 2
a614 1
static struct opinfo *
a642 1
static int log2[] = { 0, 0, 1, 0, 2 };
d644 2
a645 1
/* Now we know what sort of opcodes it is, let's build the bytes.  */
d647 2
d665 1
a665 2

      /* This is a relaxable insn, so we do some special handling.  */
d682 2
a683 2
      /* If something special was done in the expression modify the
	 reloc type.  */
d685 4
a688 1
	type = tc_cons_reloc;
d690 2
a691 1
      /* 1 byte for the opcode + the bytes for the addrmode.  */
d696 1
a696 1
	  /* Two relocs for this one.  */
d727 4
a730 3
/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */
d772 2
a773 1
      /* Couldn't find an opcode which matched the operands.  */
d786 1
d788 2
a789 2
tc_crawl_symbol_chain (headers)
     object_headers *headers;
d795 2
a796 2
md_undefined_symbol (name)
     char *name;
d802 2
a803 2
tc_headers_hook (headers)
     object_headers *headers;
d808 2
a809 2
/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
d812 4
a815 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d872 4
a875 3
md_parse_option (c, a)
     int c;
     char *a;
d887 3
a889 3
/* Called after relaxing, change the frags so they know how big they
   are.  */

d898 1
a898 2
  unsigned char *buffer =
    (unsigned char *) (fragP->fr_fix + fragP->fr_literal);
d908 1
a908 1
      /* Conditional branches to a known 16 bit displacement.  */
d934 1
a934 1
      /* Unconditional branches to a known 16 bit displacement.  */
d947 1
a947 1
      /* Got to create a branch over a reloc here.  */
d985 2
a986 3
      /* Get the address of the end of the instruction.  */
      int next_inst = (fragP->fr_fix + fragP->fr_address
		       + disp_size + inst_size);
d997 1
d999 3
a1001 3
md_section_align (seg, size)
     segT seg;
     valueT size;
d1005 1
d1084 1
a1084 1
     symbolS *x;
a1163 2
/* Called just before address relaxation, return the length by which a
   fragment must grow to reach it's destination.  */
d1165 7
d1177 1
a1177 1
  int what;
a1182 1

d1185 1
a1185 2
      what = GET_WHAT (fragP->fr_subtype);
      /* Used to be a branch to somewhere which was unknown.  */
d1189 1
a1189 1
	     sized - maybe it will fix up.  */
d1191 1
d1195 1
a1195 2
	  /* Its got a segment, but its not ours, so it will always be
             long.  */
d1197 2
a1199 11
      break;

    case C (COND_BRANCH, BYTE_DISP):
    case C (COND_BRANCH, WORD_DISP):
    case C (COND_BRANCH, UNDEF_WORD_DISP):
    case C (UNCOND_BRANCH, BYTE_DISP):
    case C (UNCOND_BRANCH, WORD_DISP):
    case C (UNCOND_BRANCH, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
a1200 2

  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
d1204 2
d1216 1
d1219 1
a1219 1
size_t md_longopts_size = sizeof (md_longopts);
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
d29 1
d32 1
a32 1
const char line_separator_chars[] = ";";
d53 1
a53 6
static void s_longa PARAMS ((int));
static char *parse_exp PARAMS ((char *));
static char *get_operands PARAMS ((const struct opinfo *, char *));
static const struct opinfo *get_specific PARAMS ((const struct opinfo *));
static void build_Mytes PARAMS ((const struct opinfo *));

d63 3
d70 2
d128 1
a128 1
static void
a129 1
     int xmode;
d152 1
a152 1
  const struct opinfo *opcode;
d165 6
d178 16
d199 1
a199 1
w65_expression (dest)
d201 1
d231 1
a231 1
parse_exp (s)
d233 1
d240 1
a240 1
  w65_expression (&immediate);
d250 1
a250 1
     const struct opinfo *info;
d478 1
a478 1
      ptr = parse_exp (ptr);
d595 1
a595 1
static const struct opinfo *
d597 1
a597 1
     const struct opinfo *opcode;
d609 17
d630 1
a630 1
     const struct opinfo *opcode;
a659 2
	default:
	  abort ();
d711 3
a713 1
  const struct opinfo *opcode;
d715 2
d760 7
d769 1
a769 1
     char *name ATTRIBUTE_UNUSED;
d774 7
d800 1
d847 2
a848 2
     int c ATTRIBUTE_UNUSED;
     char *a ATTRIBUTE_UNUSED;
d850 8
a857 1
  return 0;
d865 2
a866 2
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
d982 1
a982 1
md_apply_fix3 (fixP, valP, seg)
d984 1
a984 2
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
a985 1
  long val = * (long *) valP;
a1033 3

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
d1036 1
a1036 1
/* Put number into target byte order.  */
d1057 1
a1057 1
     symbolS *x ATTRIBUTE_UNUSED;
d1185 1
a1185 1
const char *md_shortopts = "";
d1193 1
a1193 1
     FILE *stream ATTRIBUTE_UNUSED;
@


