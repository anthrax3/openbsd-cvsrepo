head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.6
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.10
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.20
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.22
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.18
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.16
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.14
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.12
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.10
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.8
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.7.0.8
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.6.0.16
	OPENBSD_2_7_BASE:1.6
	new-binutils:1.6.0.14
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.11.09.00.07.32;	author mlarkin;	state Exp;
branches;
next	1.15;
commitid	rosmMGDa8iHf9X7M;

1.15
date	2014.02.09.22.42.27;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2013.02.03.23.18.19;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.18.00.54.12;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2012.09.03.15.23.59;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.11.10.50.48;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.02.20.45.28;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.17.21.54.30;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.13.17.07.36;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.12.19.11.50;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	97.01.21.10.33.06;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.09.04.19.05.48;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.09.20.12.45;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.08.21.20.43;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.08.18.17.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.06;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.06;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.37;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.44.48;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.23.04;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.46.25;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.35.02;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.30;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.52;	author miod;	state Exp;
branches;
next	;


desc
@@


1.16
log
@
Start moving some vmm things into the tree. First up is binutils so we will
be able to use the virtualization instructions.

ok'ed a long time ago, I forgot who, but deraadt@@ ok'ed it again anyway.
@
text
@/* tc-i386.h -- Header file for tc-i386.c
   Copyright 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#ifndef TC_I386
#define TC_I386 1

#ifndef BFD_ASSEMBLER
#error So, do you know what you are doing?
#endif

#ifdef ANSI_PROTOTYPES
struct fix;
#endif

#define TARGET_BYTES_BIG_ENDIAN	0

#ifdef TE_LYNX
#define TARGET_FORMAT		"coff-i386-lynx"
#endif

#define TARGET_ARCH		bfd_arch_i386
#define TARGET_MACH		(i386_mach ())
extern unsigned long i386_mach PARAMS ((void));

#ifdef TE_FreeBSD
#define AOUT_TARGET_FORMAT	"a.out-i386-freebsd"
#endif
#if defined(TE_NetBSD) || defined(TE_OpenBSD)
#define AOUT_TARGET_FORMAT	"a.out-i386-netbsd"
#endif
#ifdef TE_386BSD
#define AOUT_TARGET_FORMAT	"a.out-i386-bsd"
#endif
#ifdef TE_LINUX
#define AOUT_TARGET_FORMAT	"a.out-i386-linux"
#endif
#ifdef TE_Mach
#define AOUT_TARGET_FORMAT	"a.out-mach3"
#endif
#ifdef TE_DYNIX
#define AOUT_TARGET_FORMAT	"a.out-i386-dynix"
#endif
#ifndef AOUT_TARGET_FORMAT
#define AOUT_TARGET_FORMAT	"a.out-i386"
#endif

#ifdef TE_FreeBSD
#define ELF_TARGET_FORMAT	"elf32-i386-freebsd"
#endif
#ifndef ELF_TARGET_FORMAT
#define ELF_TARGET_FORMAT	"elf32-i386"
#endif

#if ((defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)) \
     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))
extern const char *i386_target_format PARAMS ((void));
#define TARGET_FORMAT i386_target_format ()
#else
#ifdef OBJ_ELF
#define TARGET_FORMAT		ELF_TARGET_FORMAT
#endif
#ifdef OBJ_AOUT
#define TARGET_FORMAT		AOUT_TARGET_FORMAT
#endif
#endif

#if (defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF))
#define md_end i386_elf_emit_arch_note
extern void i386_elf_emit_arch_note PARAMS ((void));
#endif

#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 0

#define LOCAL_LABELS_FB 1

extern const char extra_symbol_chars[];
#define tc_symbol_chars extra_symbol_chars

#define MAX_OPERANDS 3		/* max operands per insn */
#define MAX_IMMEDIATE_OPERANDS 2/* max immediates per insn (lcall, ljmp) */
#define MAX_MEMORY_OPERANDS 2	/* max memory refs per insn (string ops) */

/* Prefixes will be emitted in the order defined below.
   WAIT_PREFIX must be the first prefix since FWAIT is really is an
   instruction, and so must come before any prefixes.  */
#define WAIT_PREFIX	0
#define LOCKREP_PREFIX	1
#define ADDR_PREFIX	2
#define DATA_PREFIX	3
#define SEG_PREFIX	4
#define REX_PREFIX	5       /* must come last.  */
#define MAX_PREFIXES	6	/* max prefixes per opcode */

/* we define the syntax here (modulo base,index,scale syntax) */
#define REGISTER_PREFIX '%'
#define IMMEDIATE_PREFIX '$'
#define ABSOLUTE_PREFIX '*'

#define TWO_BYTE_OPCODE_ESCAPE 0x0f
#define NOP_OPCODE (char) 0x90

/* register numbers */
#define EBP_REG_NUM 5
#define ESP_REG_NUM 4

/* modrm_byte.regmem for twobyte escape */
#define ESCAPE_TO_TWO_BYTE_ADDRESSING ESP_REG_NUM
/* index_base_byte.index for no index register addressing */
#define NO_INDEX_REGISTER ESP_REG_NUM
/* index_base_byte.base for no base register addressing */
#define NO_BASE_REGISTER EBP_REG_NUM
#define NO_BASE_REGISTER_16 6

/* these are the instruction mnemonic suffixes.  */
#define WORD_MNEM_SUFFIX  'w'
#define BYTE_MNEM_SUFFIX  'b'
#define SHORT_MNEM_SUFFIX 's'
#define LONG_MNEM_SUFFIX  'l'
#define QWORD_MNEM_SUFFIX  'q'
/* Intel Syntax */
#define LONG_DOUBLE_MNEM_SUFFIX 'x'

/* modrm.mode = REGMEM_FIELD_HAS_REG when a register is in there */
#define REGMEM_FIELD_HAS_REG 0x3/* always = 0x3 */
#define REGMEM_FIELD_HAS_MEM (~REGMEM_FIELD_HAS_REG)

#define END_OF_INSN '\0'

/* Intel Syntax */
/* Values 0-4 map onto scale factor */
#define BYTE_PTR     0
#define WORD_PTR     1
#define DWORD_PTR    2
#define QWORD_PTR    3
#define XWORD_PTR    4
#define SHORT        5
#define OFFSET_FLAT  6
#define FLAT         7
#define NONE_FOUND   8

typedef struct
{
  /* instruction name sans width suffix ("mov" for movl insns) */
  char *name;

  /* how many operands */
  unsigned int operands;

  /* base_opcode is the fundamental opcode byte without optional
     prefix(es).  */
  unsigned int base_opcode;

  /* extension_opcode is the 3 bit extension for group <n> insns.
     This field is also used to store the 8-bit opcode suffix for the
     AMD 3DNow! instructions.
     If this template has no extension opcode (the usual case) use None */
  unsigned int extension_opcode;
#define None 0xffff		/* If no extension_opcode is possible.  */

  /* cpu feature flags */
  unsigned int cpu_flags;
#define Cpu086		  0x1	/* Any old cpu will do, 0 does the same */
#define Cpu186		  0x2	/* i186 or better required */
#define Cpu286		  0x4	/* i286 or better required */
#define Cpu386		  0x8	/* i386 or better required */
#define Cpu486		 0x10	/* i486 or better required */
#define Cpu586		 0x20	/* i585 or better required */
#define Cpu686		 0x40	/* i686 or better required */
#define CpuP4		 0x80	/* Pentium4 or better required */
#define CpuK6		0x100	/* AMD K6 or better required*/
#define CpuAthlon	0x200	/* AMD Athlon or better required*/
#define CpuSledgehammer 0x400	/* Sledgehammer or better required */
#define CpuMMX		0x800	/* MMX support required */
#define CpuSSE	       0x1000	/* Streaming SIMD extensions required */
#define CpuSSE2	       0x2000	/* Streaming SIMD extensions 2 required */
#define Cpu3dnow       0x4000	/* 3dnow! support required */
#define CpuPNI	       0x8000	/* Prescott New Instructions required */
#define CpuPadLock    0x10000	/* VIA PadLock required */
#define CpuSSSE3      0x20000	/* Supplementary SSE3 required */
#define CpuXSAVE      0x40000	/* XSAVE extensions required */
#define CpuAES        0x80000	/* Intel AES extensions required */
#define CpuPCLMUL    0x100000	/* Intel Carry-less Multiplication extensions */
#define CpuRdRnd     0x200000	/* Intel Random Number Generator extensions */
#define CpuSMAP      0x400000	/* Intel Supervisor Mode Access Prevention */
#define CpuVMX       0x800000	/* VMX Virtualization instructions required */
#define CpuSVME	    0x1000000	/* SVM Virtualization instructions required */

  /* These flags are set by gas depending on the flag_code.  */
#define Cpu64	     0x4000000   /* 64bit support required  */
#define CpuNo64      0x8000000   /* Not supported in the 64bit mode  */

  /* The default value for unknown CPUs - enable all features to avoid problems.  */
#define CpuUnknownFlags (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuSledgehammer|CpuMMX|CpuSSE|CpuSSE2|CpuPNI|Cpu3dnow|CpuK6|CpuAthlon|CpuPadLock|CpuSSSE3|CpuXSAVE|CpuAES|CpuPCLMUL|CpuRdRnd|CpuSMAP|CpuVMX|CpuSVME)

  /* the bits in opcode_modifier are used to generate the final opcode from
     the base_opcode.  These bits also are used to detect alternate forms of
     the same instruction */
  unsigned int opcode_modifier;

  /* opcode_modifier bits: */
#define W		   0x1	/* set if operands can be words or dwords
				   encoded the canonical way */
#define D		   0x2	/* D = 0 if Reg --> Regmem;
				   D = 1 if Regmem --> Reg:    MUST BE 0x2 */
#define Modrm		   0x4
#define FloatR		   0x8	/* src/dest swap for floats:   MUST BE 0x8 */
#define ShortForm	  0x10	/* register is in low 3 bits of opcode */
#define FloatMF		  0x20	/* FP insn memory format bit, sized by 0x4 */
#define Jump		  0x40	/* special case for jump insns.  */
#define JumpDword	  0x80  /* call and jump */
#define JumpByte	 0x100  /* loop and jecxz */
#define JumpInterSegment 0x200	/* special case for intersegment leaps/calls */
#define FloatD		 0x400	/* direction for float insns:  MUST BE 0x400 */
#define Seg2ShortForm	 0x800	/* encoding of load segment reg insns */
#define Seg3ShortForm	0x1000	/* fs/gs segment register insns.  */
#define Size16		0x2000	/* needs size prefix if in 32-bit mode */
#define Size32		0x4000	/* needs size prefix if in 16-bit mode */
#define Size64		0x8000	/* needs size prefix if in 16-bit mode */
#define IgnoreSize     0x10000  /* instruction ignores operand size prefix */
#define DefaultSize    0x20000  /* default insn size depends on mode */
#define No_bSuf	       0x40000	/* b suffix on instruction illegal */
#define No_wSuf	       0x80000	/* w suffix on instruction illegal */
#define No_lSuf	      0x100000 	/* l suffix on instruction illegal */
#define No_sSuf	      0x200000	/* s suffix on instruction illegal */
#define No_qSuf       0x400000  /* q suffix on instruction illegal */
#define No_xSuf       0x800000  /* x suffix on instruction illegal */
#define FWait	     0x1000000	/* instruction needs FWAIT */
#define IsString     0x2000000	/* quick test for string instructions */
#define regKludge    0x4000000	/* fake an extra reg operand for clr, imul */
#define IsPrefix     0x8000000	/* opcode is a prefix */
#define ImmExt	    0x10000000	/* instruction has extension in 8 bit imm */
#define NoRex64	    0x20000000  /* instruction don't need Rex64 prefix.  */
#define Rex64	    0x40000000  /* instruction require Rex64 prefix.  */
#define Ugh	    0x80000000	/* deprecated fp insn, gets a warning */

  /* operand_types[i] describes the type of operand i.  This is made
     by OR'ing together all of the possible type masks.  (e.g.
     'operand_types[i] = Reg|Imm' specifies that operand i can be
     either a register or an immediate operand.  */
  unsigned int operand_types[3];

  /* operand_types[i] bits */
  /* register */
#define Reg8		   0x1	/* 8 bit reg */
#define Reg16		   0x2	/* 16 bit reg */
#define Reg32		   0x4	/* 32 bit reg */
#define Reg64		   0x8	/* 64 bit reg */
  /* immediate */
#define Imm8		  0x10	/* 8 bit immediate */
#define Imm8S		  0x20	/* 8 bit immediate sign extended */
#define Imm16		  0x40	/* 16 bit immediate */
#define Imm32		  0x80	/* 32 bit immediate */
#define Imm32S		 0x100	/* 32 bit immediate sign extended */
#define Imm64		 0x200	/* 64 bit immediate */
#define Imm1		 0x400	/* 1 bit immediate */
  /* memory */
#define BaseIndex	 0x800
  /* Disp8,16,32 are used in different ways, depending on the
     instruction.  For jumps, they specify the size of the PC relative
     displacement, for baseindex type instructions, they specify the
     size of the offset relative to the base register, and for memory
     offset instructions such as `mov 1234,%al' they specify the size of
     the offset relative to the segment base.  */
#define Disp8		0x1000	/* 8 bit displacement */
#define Disp16		0x2000	/* 16 bit displacement */
#define Disp32		0x4000	/* 32 bit displacement */
#define Disp32S	        0x8000	/* 32 bit signed displacement */
#define Disp64	       0x10000	/* 64 bit displacement */
  /* specials */
#define InOutPortReg   0x20000	/* register to hold in/out port addr = dx */
#define ShiftCount     0x40000	/* register to hold shift cound = cl */
#define Control	       0x80000	/* Control register */
#define Debug	      0x100000	/* Debug register */
#define Test	      0x200000	/* Test register */
#define FloatReg      0x400000	/* Float register */
#define FloatAcc      0x800000	/* Float stack top %st(0) */
#define SReg2	     0x1000000	/* 2 bit segment register */
#define SReg3	     0x2000000	/* 3 bit segment register */
#define Acc	     0x4000000	/* Accumulator %al or %ax or %eax */
#define JumpAbsolute 0x8000000
#define RegMMX	    0x10000000	/* MMX register */
#define RegXMM	    0x20000000	/* XMM registers in PIII */
#define EsSeg	    0x40000000	/* String insn operand with fixed es segment */

  /* InvMem is for instructions with a modrm byte that only allow a
     general register encoding in the i.tm.mode and i.tm.regmem fields,
     eg. control reg moves.  They really ought to support a memory form,
     but don't, so we add an InvMem flag to the register operand to
     indicate that it should be encoded in the i.tm.regmem field.  */
#define InvMem	    0x80000000

#define Reg	(Reg8|Reg16|Reg32|Reg64) /* gen'l register */
#define WordReg (Reg16|Reg32|Reg64)
#define ImplicitRegister (InOutPortReg|ShiftCount|Acc|FloatAcc)
#define Imm	(Imm8|Imm8S|Imm16|Imm32S|Imm32|Imm64) /* gen'l immediate */
#define EncImm	(Imm8|Imm16|Imm32|Imm32S) /* Encodable gen'l immediate */
#define Disp	(Disp8|Disp16|Disp32|Disp32S|Disp64) /* General displacement */
#define AnyMem	(Disp8|Disp16|Disp32|Disp32S|BaseIndex|InvMem)	/* General memory */
  /* The following aliases are defined because the opcode table
     carefully specifies the allowed memory types for each instruction.
     At the moment we can only tell a memory reference size by the
     instruction suffix, so there's not much point in defining Mem8,
     Mem16, Mem32 and Mem64 opcode modifiers - We might as well just use
     the suffix directly to check memory operands.  */
#define LLongMem AnyMem		/* 64 bits (or more) */
#define LongMem AnyMem		/* 32 bit memory ref */
#define ShortMem AnyMem		/* 16 bit memory ref */
#define WordMem AnyMem		/* 16 or 32 bit memory ref */
#define ByteMem AnyMem		/* 8 bit memory ref */
}
template;

/*
  'templates' is for grouping together 'template' structures for opcodes
  of the same name.  This is only used for storing the insns in the grand
  ole hash table of insns.
  The templates themselves start at START and range up to (but not including)
  END.
  */
typedef struct
{
  const template *start;
  const template *end;
}
templates;

/* these are for register name --> number & type hash lookup */
typedef struct
{
  char *reg_name;
  unsigned int reg_type;
  unsigned int reg_flags;
#define RegRex	    0x1  /* Extended register.  */
#define RegRex64    0x2  /* Extended 8 bit register.  */
  unsigned int reg_num;
}
reg_entry;

typedef struct
{
  char *seg_name;
  unsigned int seg_prefix;
}
seg_entry;

/* 386 operand encoding bytes:  see 386 book for details of this.  */
typedef struct
{
  unsigned int regmem;	/* codes register or memory operand */
  unsigned int reg;	/* codes register operand (or extended opcode) */
  unsigned int mode;	/* how to interpret regmem & reg */
}
modrm_byte;

/* x86-64 extension prefix.  */
typedef int rex_byte;
#define REX_OPCODE	0x40

/* Indicates 64 bit operand size.  */
#define REX_MODE64	8
/* High extension to reg field of modrm byte.  */
#define REX_EXTX	4
/* High extension to SIB index field.  */
#define REX_EXTY	2
/* High extension to base field of modrm or SIB, or reg field of opcode.  */
#define REX_EXTZ	1

/* 386 opcode byte to code indirect addressing.  */
typedef struct
{
  unsigned base;
  unsigned index;
  unsigned scale;
}
sib_byte;

/* x86 arch names and features */
typedef struct
{
  const char *name;	/* arch name */
  unsigned int flags;	/* cpu feature flags */
}
arch_entry;

/* The name of the global offset table generated by the compiler. Allow
   this to be overridden if need be.  */
#ifndef GLOBAL_OFFSET_TABLE_NAME
#ifdef OBJ_ELF
#define GLOBAL_OFFSET_TABLE_NAME "_GLOBAL_OFFSET_TABLE_"
#else
#define GLOBAL_OFFSET_TABLE_NAME "__GLOBAL_OFFSET_TABLE_"
#endif
#endif

#ifndef LEX_AT
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) x86_cons (EXP, NBYTES)
extern void x86_cons PARAMS ((expressionS *, int));

#define TC_CONS_FIX_NEW(FRAG,OFF,LEN,EXP) x86_cons_fix_new(FRAG, OFF, LEN, EXP)
extern void x86_cons_fix_new
  PARAMS ((fragS *, unsigned int, unsigned int, expressionS *));
#endif

#define DIFF_EXPR_OK    /* foo-. gets turned into PC relative relocs */

#define NO_RELOC BFD_RELOC_NONE

void i386_validate_fix PARAMS ((struct fix *));
#define TC_VALIDATE_FIX(FIX,SEGTYPE,SKIP) i386_validate_fix(FIX)

#define tc_fix_adjustable(X)  tc_i386_fix_adjustable(X)
extern int tc_i386_fix_adjustable PARAMS ((struct fix *));

/* Values passed to md_apply_fix3 don't include the symbol value.  */
#define MD_APPLY_SYM_VALUE(FIX) 0

/* ELF wants external syms kept, as does PE COFF.  */
#if defined (TE_PE) && defined (STRICT_PE_FORMAT)
#define EXTERN_FORCE_RELOC				\
  (OUTPUT_FLAVOR == bfd_target_elf_flavour		\
   || OUTPUT_FLAVOR == bfd_target_coff_flavour)
#else
#define EXTERN_FORCE_RELOC				\
  (OUTPUT_FLAVOR == bfd_target_elf_flavour)
#endif

/* This expression evaluates to true if the relocation is for a local
   object for which we still want to do the relocation at runtime.
   False if we are willing to perform this relocation while building
   the .o file.  GOTOFF does not need to be checked here because it is
   not pcrel.  I am not sure if some of the others are ever used with
   pcrel, but it is easier to be safe than sorry.  */

#define TC_FORCE_RELOCATION_LOCAL(FIX)			\
  (!(FIX)->fx_pcrel					\
   || (FIX)->fx_plt					\
   || (FIX)->fx_r_type == BFD_RELOC_386_PLT32		\
   || (FIX)->fx_r_type == BFD_RELOC_386_GOT32		\
   || (FIX)->fx_r_type == BFD_RELOC_386_GOTPC		\
   || (FIX)->fx_r_type == BFD_RELOC_X86_64_GOTPCREL	\
   || TC_FORCE_RELOCATION (FIX))

#define md_operand(x)

extern const struct relax_type md_relax_table[];
#define TC_GENERIC_RELAX_TABLE md_relax_table

extern int optimize_align_code;

#define md_do_align(n, fill, len, max, around)				\
if ((n)									\
    && !need_pass_2							\
    && optimize_align_code						\
    && (!(fill)								\
	|| ((char)*(fill) == (char)0x90 && (len) == 1))			\
    && subseg_text_p (now_seg))						\
  {									\
    frag_align_code ((n), (max));					\
    goto around;							\
  }

#define MAX_MEM_FOR_RS_ALIGN_CODE  15

extern void i386_align_code PARAMS ((fragS *, int));

#define HANDLE_ALIGN(fragP)						\
if (fragP->fr_type == rs_align_code) 					\
  i386_align_code (fragP, (fragP->fr_next->fr_address			\
			   - fragP->fr_address				\
			   - fragP->fr_fix));

void i386_print_statistics PARAMS ((FILE *));
#define tc_print_statistics i386_print_statistics

#define md_number_to_chars number_to_chars_littleendian

#ifdef SCO_ELF
#define tc_init_after_args() sco_id ()
extern void sco_id PARAMS ((void));
#endif

/* We want .cfi_* pseudo-ops for generating unwind info.  */
#define TARGET_USE_CFIPOP 1

extern unsigned int x86_dwarf2_return_column;
#define DWARF2_DEFAULT_RETURN_COLUMN x86_dwarf2_return_column

extern int x86_cie_data_alignment;
#define DWARF2_CIE_DATA_ALIGNMENT x86_cie_data_alignment

#define tc_regname_to_dw2regnum tc_x86_regname_to_dw2regnum
extern int tc_x86_regname_to_dw2regnum PARAMS ((const char *regname));

#define tc_cfi_frame_initial_instructions tc_x86_frame_initial_instructions
extern void tc_x86_frame_initial_instructions PARAMS ((void));

#endif /* TC_I386 */
@


1.15
log
@Add support for i386 XSAVE family of instructions: xgetbv, xsetbv, xsave,
xrstor, and xsaveopt.

based on kettenis's original that did xgetbv and xsetbv
ok kettenis@@
@
text
@d204 2
d212 1
a212 1
#define CpuUnknownFlags (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuSledgehammer|CpuMMX|CpuSSE|CpuSSE2|CpuPNI|Cpu3dnow|CpuK6|CpuAthlon|CpuPadLock|CpuSSSE3|CpuXSAVE|CpuAES|CpuPCLMUL|CpuRdRnd|CpuSMAP)
@


1.14
log
@Stop as(1) from optimizing away R_X86_64_GOTPCREL relocations.

ok miod@@
@
text
@d199 5
a203 4
#define CpuAES        0x40000	/* Intel AES extensions required */
#define CpuPCLMUL     0x80000	/* Intel Carry-less Multiplication extensions */
#define CpuRdRnd     0x100000	/* Intel Random Number Generator extensions */
#define CpuSMAP      0x200000	/* Intel Supervisor Mode Access Prevention */
d210 1
a210 1
#define CpuUnknownFlags (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuSledgehammer|CpuMMX|CpuSSE|CpuSSE2|CpuPNI|Cpu3dnow|CpuK6|CpuAthlon|CpuPadLock|CpuSSSE3|CpuAES|CpuPCLMUL|CpuRdRnd|CpuSMAP)
@


1.13
log
@Add support for stac/clac instructions to manipulate the flag
that controls the behaviour of Intel's Supervisor Mode Access Prevention
(SMAP) feature.

'looks correct' miod@@ ok deraadt@@
@
text
@d456 1
@


1.12
log
@Teach as(1) about rdrand on i386/amd64.

ok jsg@@
@
text
@d202 1
d209 1
a209 1
#define CpuUnknownFlags (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuSledgehammer|CpuMMX|CpuSSE|CpuSSE2|CpuPNI|Cpu3dnow|CpuK6|CpuAthlon|CpuPadLock|CpuSSSE3|CpuAES|CpuPCLMUL|CpuRdRnd)
@


1.11
log
@Add support for Intel AES-NI and the CLMUL_ instructions, plus a few others
that are needed to omplement accelerated AES (and AES-GCM mode) on newer
Intel cores.

Diff from Mike Belopuhov.

no objections/ok miod@@
@
text
@d201 1
d208 1
a208 1
#define CpuUnknownFlags (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuSledgehammer|CpuMMX|CpuSSE|CpuSSE2|CpuPNI|Cpu3dnow|CpuK6|CpuAthlon|CpuPadLock|CpuSSSE3|CpuAES|CpuPCLMUL)
@


1.10
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@d198 3
d207 1
a207 1
#define CpuUnknownFlags (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuSledgehammer|CpuMMX|CpuSSE|CpuSSE2|CpuPNI|Cpu3dnow|CpuK6|CpuAthlon|CpuPadLock)
@


1.9
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2001, 2002, 2003
d26 4
a39 1
#ifdef BFD_ASSEMBLER
a92 53
#else /* ! BFD_ASSEMBLER */

/* COFF STUFF */

#define COFF_MAGIC I386MAGIC
#define BFD_ARCH bfd_arch_i386
#define COFF_FLAGS F_AR32WR
#define TC_COUNT_RELOC(x) ((x)->fx_addsy || (x)->fx_r_type==7)
#define TC_COFF_FIX2RTYPE(FIX) tc_coff_fix2rtype(FIX)
extern short tc_coff_fix2rtype PARAMS ((struct fix *));
#define TC_COFF_SIZEMACHDEP(frag) tc_coff_sizemachdep (frag)
extern int tc_coff_sizemachdep PARAMS ((fragS *frag));

#ifdef TE_GO32
/* DJGPP now expects some sections to be 2**4 aligned.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  ((strcmp (obj_segment_name (SEG), ".text") == 0			\
    || strcmp (obj_segment_name (SEG), ".data") == 0			\
    || strcmp (obj_segment_name (SEG), ".bss") == 0			\
    || strncmp (obj_segment_name (SEG), ".gnu.linkonce.t", 15) == 0	\
    || strncmp (obj_segment_name (SEG), ".gnu.linkonce.d", 15) == 0	\
    || strncmp (obj_segment_name (SEG), ".gnu.linkonce.r", 15) == 0)	\
   ? 4									\
   : 2)
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 2
#endif

#ifdef TE_386BSD
/* The BSDI linker apparently rejects objects with a machine type of
   M_386 (100).  */
#define AOUT_MACHTYPE 0
#else
#define AOUT_MACHTYPE 100
#endif

#ifndef OBJ_AOUT
#ifndef TE_PE
#ifndef TE_GO32
/* Local labels starts with .L */
#define LOCAL_LABEL(name) (name[0] == '.' \
		 && (name[1] == 'L' || name[1] == 'X' || name[1] == '.'))
#endif
#endif
#endif

#define tc_aout_pre_write_hook(x)	{;}	/* not used */
#define tc_crawl_symbol_chain(a)	{;}	/* not used */
#define tc_headers_hook(a)		{;}	/* not used */
#define tc_coff_symbol_emit_hook(a)	{;}	/* not used */

#endif /* ! BFD_ASSEMBLER */

d196 2
d204 1
a204 1
#define CpuUnknownFlags (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuSledgehammer|CpuMMX|CpuSSE|CpuSSE2|Cpu3dnow|CpuK6|CpuAthlon)
a416 1
#ifdef BFD_ASSEMBLER
a452 16
#else /* ! BFD_ASSEMBLER */

#define NO_RELOC 0

#define TC_RVA_RELOC 7

/* Need this for PIC relocations */
#define NEED_FX_R_TYPE

#undef REVERSE_SORT_RELOCS

/* For COFF.  */
#define TC_FORCE_RELOCATION(FIX)			\
  ((FIX)->fx_r_type == 7 || generic_force_reloc (FIX))
#endif /* ! BFD_ASSEMBLER */

d458 2
d461 5
a465 2
if ((n) && !need_pass_2							\
    && (!(fill) || ((char)*(fill) == (char)0x90 && (len) == 1))		\
d491 15
@


1.8
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2001
a36 38
/* This is used to determine relocation types in tc-i386.c.  The first
   parameter is the current relocation type, the second one is the desired
   type.  The idea is that if the original type is already some kind of PIC
   relocation, we leave it alone, otherwise we give it the desired type */

#define tc_fix_adjustable(X)  tc_i386_fix_adjustable(X)
extern int tc_i386_fix_adjustable PARAMS ((struct fix *));

#if (defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF) || defined (OBJ_MAYBE_COFF) || defined (OBJ_COFF)) && !defined (TE_PE)
/* This arranges for gas/write.c to not apply a relocation if
   tc_fix_adjustable() says it is not adjustable.
   The "! symbol_used_in_reloc_p" test is there specifically to cover
   the case of non-global symbols in linkonce sections.  It's the
   generally correct thing to do though;  If a reloc is going to be
   emitted against a symbol then we don't want to adjust the fixup by
   applying the reloc during assembly.  The reloc will be applied by
   the linker during final link.  */
#define TC_FIX_ADJUSTABLE(fixP) \
  (! symbol_used_in_reloc_p ((fixP)->fx_addsy) && tc_fix_adjustable (fixP))
#endif

/* This expression evaluates to false if the relocation is for a local object
   for which we still want to do the relocation at runtime.  True if we
   are willing to perform this relocation while building the .o file.
   This is only used for pcrel relocations, so GOTOFF does not need to be
   checked here.  I am not sure if some of the others are ever used with
   pcrel, but it is easier to be safe than sorry.  */

#define TC_RELOC_RTSYM_LOC_FIXUP(FIX)				\
  ((FIX)->fx_r_type != BFD_RELOC_386_PLT32			\
   && (FIX)->fx_r_type != BFD_RELOC_386_GOT32			\
   && (FIX)->fx_r_type != BFD_RELOC_386_GOTPC			\
   && ((FIX)->fx_addsy == NULL					\
       || (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
	   && ! S_IS_WEAK ((FIX)->fx_addsy)			\
	   && S_IS_DEFINED ((FIX)->fx_addsy)			\
	   && ! S_IS_COMMON ((FIX)->fx_addsy))))

d44 1
a44 1
#ifdef TE_NetBSD
d63 7
d76 1
a76 1
#define TARGET_FORMAT		"elf32-i386"
d83 7
d98 1
a98 1
#define TC_COFF_FIX2RTYPE(fixP) tc_coff_fix2rtype(fixP)
d100 1
a100 1
#define TC_COFF_SIZEMACHDEP(frag) tc_coff_sizemachdep(frag)
d105 1
a105 1
#define SUB_SEGMENT_ALIGN(SEG)						\
d115 1
a115 1
#define SUB_SEGMENT_ALIGN(SEG) 2
a117 4
#define TC_RVA_RELOC 7
/* Need this for PIC relocations */
#define NEED_FX_R_TYPE

a125 24
#undef REVERSE_SORT_RELOCS

#endif /* ! BFD_ASSEMBLER */

#ifndef LEX_AT
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) x86_cons (EXP, NBYTES)
extern void x86_cons PARAMS ((expressionS *, int));

#define TC_CONS_FIX_NEW(FRAG,OFF,LEN,EXP) x86_cons_fix_new(FRAG, OFF, LEN, EXP)
extern void x86_cons_fix_new
  PARAMS ((fragS *, unsigned int, unsigned int, expressionS *));
#endif

#define TC_FORCE_RELOCATION(fixp) tc_i386_force_relocation(fixp)
extern int tc_i386_force_relocation PARAMS ((struct fix *));

#ifdef BFD_ASSEMBLER
#define NO_RELOC BFD_RELOC_NONE
#else
#define NO_RELOC 0
#endif
#define tc_coff_symbol_emit_hook(a)	;	/* not used */

#ifndef BFD_ASSEMBLER
a134 3
#endif

#define LOCAL_LABELS_FB 1
d139 5
a245 1
#define CpuUnknown     0x8000	/* The CPU is unknown,  be on the safe side.  */
d415 11
a425 9
typedef struct
  {
    unsigned int mode64;
    unsigned int extX;		/* Used to extend modrm reg field.  */
    unsigned int extY;		/* Used to extend SIB index field.  */
    unsigned int extZ;		/* Used to extend modrm reg/mem, SIB base, modrm base fields.  */
    unsigned int empty;		/* Used to old-style byte registers to new style.  */
  }
rex_byte;
d447 1
d449 12
d463 2
d466 2
d469 16
a484 1
#define TC_VALIDATE_FIX(FIXP,SEGTYPE,SKIP) i386_validate_fix(FIXP)
d487 30
a516 1
#endif /* TC_I386 */
a541 3
/* call md_apply_fix3 with segment instead of md_apply_fix */
#define MD_APPLY_FIX3

d552 1
a552 1
#define DIFF_EXPR_OK    /* foo-. gets turned into PC relative relocs */
@


1.7
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 3
a4 2
   Copyright (C) 1989, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation.
d45 12
a56 8
/* This is the relocation type for direct references to GLOBAL_OFFSET_TABLE.
 * It comes up in complicated expressions such as 
 * _GLOBAL_OFFSET_TABLE_+[.-.L284], which cannot be expressed normally with
 * the regular expressions.  The fixup specified here when used at runtime 
 * implies that we should add the address of the GOT to the specified location,
 * and as a result we have simplified the expression into something we can use.
 */
#define TC_RELOC_GLOBAL_OFFSET_TABLE BFD_RELOC_386_GOTPC
d63 1
a63 1
   pcrel, but it is easier to be safe than sorry. */
d76 2
d79 3
d101 2
a102 3
#if ((defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_COFF)) \
     || (defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_AOUT)) \
     || (defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)))
a145 1

d158 9
d204 1
a204 1
   instruction, and so must come before any prefixes. */
d210 2
a211 1
#define MAX_PREFIXES	5	/* max prefixes per opcode */
d238 1
a240 2
/* Intel Syntax */
#define DWORD_MNEM_SUFFIX 'd'
a258 71
/*
  When an operand is read in it is classified by its type.  This type includes
  all the possible ways an operand can be used.  Thus, '%eax' is both 'register
  # 0' and 'The Accumulator'.  In our language this is expressed by OR'ing
  'Reg32' (any 32 bit register) and 'Acc' (the accumulator).
  Operands are classified so that we can match given operand types with
  the opcode table in opcode/i386.h.
  */
/* register */
#define Reg8		   0x1	/* 8 bit reg */
#define Reg16		   0x2	/* 16 bit reg */
#define Reg32		   0x4	/* 32 bit reg */
/* immediate */
#define Imm8		   0x8	/* 8 bit immediate */
#define Imm8S		  0x10	/* 8 bit immediate sign extended */
#define Imm16		  0x20	/* 16 bit immediate */
#define Imm32		  0x40	/* 32 bit immediate */
#define Imm1		  0x80	/* 1 bit immediate */
/* memory */
#define BaseIndex	 0x100
/* Disp8,16,32 are used in different ways, depending on the
   instruction.  For jumps, they specify the size of the PC relative
   displacement, for baseindex type instructions, they specify the
   size of the offset relative to the base register, and for memory
   offset instructions such as `mov 1234,%al' they specify the size of
   the offset relative to the segment base.  */
#define Disp8		 0x200	/* 8 bit displacement */
#define Disp16		 0x400	/* 16 bit displacement */
#define Disp32		 0x800	/* 32 bit displacement */
/* specials */
#define InOutPortReg	0x1000	/* register to hold in/out port addr = dx */
#define ShiftCount	0x2000	/* register to hold shift cound = cl */
#define Control	        0x4000	/* Control register */
#define Debug	        0x8000	/* Debug register */
#define Test	       0x10000	/* Test register */
#define FloatReg       0x20000	/* Float register */
#define FloatAcc       0x40000	/* Float stack top %st(0) */
#define SReg2	       0x80000	/* 2 bit segment register */
#define SReg3	      0x100000	/* 3 bit segment register */
#define Acc	      0x200000	/* Accumulator %al or %ax or %eax */
#define JumpAbsolute  0x400000
#define RegMMX	      0x800000	/* MMX register */
#define RegXMM	     0x1000000	/* XMM registers in PIII */
#define EsSeg	     0x2000000	/* String insn operand with fixed es segment */
/* InvMem is for instructions with a modrm byte that only allow a
   general register encoding in the i.tm.mode and i.tm.regmem fields,
   eg. control reg moves.  They really ought to support a memory form,
   but don't, so we add an InvMem flag to the register operand to
   indicate that it should be encoded in the i.tm.regmem field.  */
#define InvMem	     0x4000000

#define Reg	(Reg8|Reg16|Reg32)	/* gen'l register */
#define WordReg (Reg16|Reg32)
#define ImplicitRegister (InOutPortReg|ShiftCount|Acc|FloatAcc)
#define Imm	(Imm8|Imm8S|Imm16|Imm32) /* gen'l immediate */
#define Disp	(Disp8|Disp16|Disp32)	/* General displacement */
#define AnyMem	(Disp|BaseIndex|InvMem)	/* General memory */
/* The following aliases are defined because the opcode table
   carefully specifies the allowed memory types for each instruction.
   At the moment we can only tell a memory reference size by the
   instruction suffix, so there's not much point in defining Mem8,
   Mem16, Mem32 and Mem64 opcode modifiers - We might as well just use
   the suffix directly to check memory operands.  */
#define LLongMem AnyMem		/* 64 bits (or more) */
#define LongMem AnyMem		/* 32 bit memory ref */
#define ShortMem AnyMem		/* 16 bit memory ref */
#define WordMem AnyMem		/* 16 or 32 bit memory ref */
#define ByteMem AnyMem		/* 8 bit memory ref */

#define SMALLEST_DISP_TYPE(num) \
    (fits_in_signed_byte(num) ? (Disp8|Disp32) : Disp32)
d277 27
a303 1
#define None 0xffff		/* If no extension_opcode is possible. */
d319 1
a319 1
#define Jump		  0x40	/* special case for jump insns. */
d325 1
a325 1
#define Seg3ShortForm	0x1000	/* fs/gs segment register insns. */
d328 16
a343 13
#define IgnoreSize	0x8000  /* instruction ignores operand size prefix */
#define DefaultSize    0x10000  /* default insn size depends on mode */
#define No_bSuf	       0x20000	/* b suffix on instruction illegal */
#define No_wSuf	       0x40000	/* w suffix on instruction illegal */
#define No_lSuf	       0x80000	/* l suffix on instruction illegal */
#define No_sSuf	      0x100000	/* s suffix on instruction illegal */
#define No_dSuf       0x200000  /* d suffix on instruction illegal */
#define No_xSuf       0x400000  /* x suffix on instruction illegal */
#define FWait	      0x800000	/* instruction needs FWAIT */
#define IsString     0x1000000	/* quick test for string instructions */
#define regKludge    0x2000000	/* fake an extra reg operand for clr, imul */
#define IsPrefix     0x4000000	/* opcode is a prefix */
#define ImmExt	     0x8000000	/* instruction has extension in 8 bit imm */
d349 1
a349 1
     either a register or an immediate operand */
d351 69
d431 5
a435 4
  {
    const template *start;
    const template *end;
  } templates;
d439 8
a446 5
  {
    char *reg_name;
    unsigned int reg_type;
    unsigned int reg_num;
  }
d450 4
a453 4
  {
    char *seg_name;
    unsigned int seg_prefix;
  }
d456 1
a456 1
/* 386 operand encoding bytes:  see 386 book for details of this. */
d458 5
a462 5
  {
    unsigned int regmem;	/* codes register or memory operand */
    unsigned int reg;		/* codes register operand (or extended opcode) */
    unsigned int mode;		/* how to interpret regmem & reg */
  }
d465 1
a465 1
/* 386 opcode byte to code indirect addressing. */
d468 5
a472 3
    unsigned base;
    unsigned index;
    unsigned scale;
d474 9
d485 8
d494 1
a494 1
   this to be overridden if need be. */
d516 1
a516 4
    char *p;								\
    p = frag_var (rs_align_code, 15, 1, (relax_substateT) max,		\
		  (symbolS *) 0, (offsetT) (n), (char *) 0);		\
    *p = 0x90;								\
d520 2
a543 2

/* end of tc-i386.h */
@


1.6
log
@Clone NetBSD config for us, add handling of temporary local labels
@
text
@d2 2
a3 1
   Copyright (C) 1989, 92, 93, 94, 95, 1996 Free Software Foundation.
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 6
a40 5
#define TC_RELOC(X,Y) (((X) != BFD_RELOC_386_PLT32 && \
	   (X) != BFD_RELOC_386_GOTOFF && \
	   (X) != BFD_RELOC_386_GOT32 && \
	   (X) != BFD_RELOC_386_GOTPC) ? Y : X)

d42 1
d60 9
a68 4
#define TC_RELOC_RTSYM_LOC_FIXUP(FIX)  \
  ((FIX)->fx_r_type != BFD_RELOC_386_PLT32 \
   && (FIX)->fx_r_type != BFD_RELOC_386_GOT32 \
   && (FIX)->fx_r_type != BFD_RELOC_386_GOTPC)
a70 1
#define TARGET_BYTES_BIG_ENDIAN	0
d72 2
a73 3
#ifdef OBJ_AOUT
#if defined(TE_NetBSD) || defined(TE_OpenBSD)
#define TARGET_FORMAT		"a.out-i386-netbsd"
d76 1
a76 1
#define TARGET_FORMAT		"a.out-i386-bsd"
d79 1
a79 1
#define TARGET_FORMAT		"a.out-i386-linux"
d82 1
a82 1
#define TARGET_FORMAT		"a.out-mach3"
d84 5
a88 2
#ifndef TARGET_FORMAT
#define TARGET_FORMAT		"a.out-i386"
a89 1
#endif /* OBJ_AOUT */
d91 6
d100 4
a112 1
#define TC_FORCE_RELOCATION(x) ((x)->fx_r_type==7)
d114 1
a114 1
extern short tc_coff_fix2rtype ();
d117 13
d131 2
d150 3
d160 1
d163 1
a166 1
#define FAKE_LABEL_NAME ".L0\001"
d169 3
d178 3
d182 12
a193 3
#define MAX_PREFIXES 5		/* max prefixes per opcode */
#define MAX_IMMEDIATE_OPERANDS 2/* max immediates per insn */
#define MAX_MEMORY_OPERANDS 2	/* max memory ref per insn (lcall uses 2) */
a198 1
#define PREFIX_SEPERATOR '/'
d213 1
d215 9
a223 4
/* these are the att as opcode suffixes, making movl --> mov, for example */
#define DWORD_OPCODE_SUFFIX 'l'
#define WORD_OPCODE_SUFFIX  'w'
#define BYTE_OPCODE_SUFFIX  'b'
d231 11
d248 1
a248 1
  the opcode table in i386-opcode.h.
a249 1
#define Unknown 0x0
d251 3
a253 5
#define Reg8    0x1		/* 8 bit reg */
#define Reg16   0x2		/* 16 bit reg */
#define Reg32   0x4		/* 32 bit reg */
#define Reg     (Reg8|Reg16|Reg32)	/* gen'l register */
#define WordReg (Reg16|Reg32)	/* for push/pop operands */
d255 5
a259 7
#define Imm8    0x8		/* 8 bit immediate */
#define Imm8S	0x10		/* 8 bit immediate sign extended */
#define Imm16   0x20		/* 16 bit immediate */
#define Imm32   0x40		/* 32 bit immediate */
#define Imm1    0x80		/* 1 bit immediate */
#define ImmUnknown Imm32	/* for unknown expressions */
#define Imm     (Imm8|Imm8S|Imm16|Imm32)	/* gen'l immediate */
d261 10
a270 12
#define Disp8   0x200		/* 8 bit displacement (for jumps) */
#define Disp16  0x400		/* 16 bit displacement */
#define Disp32  0x800		/* 32 bit displacement */
#define Disp    (Disp8|Disp16|Disp32)	/* General displacement */
#define DispUnknown Disp32	/* for unknown size displacements */
#define Mem8    0x1000
#define Mem16   0x2000
#define Mem32   0x4000
#define BaseIndex 0x8000
#define Mem     (Disp|Mem8|Mem16|Mem32|BaseIndex)	/* General memory */
#define WordMem   (Mem16|Mem32|Disp|BaseIndex)
#define ByteMem   (Mem8|Disp|BaseIndex)
d272 23
a294 10
#define InOutPortReg 0x10000	/* register to hold in/out port addr = dx */
#define ShiftCount 0x20000	/* register to hold shift cound = cl */
#define Control 0x40000		/* Control register */
#define Debug   0x80000		/* Debug register */
#define Test    0x100000	/* Test register */
#define FloatReg 0x200000	/* Float register */
#define FloatAcc 0x400000	/* Float stack top %st(0) */
#define SReg2   0x800000	/* 2 bit segment register */
#define SReg3   0x1000000	/* 3 bit segment register */
#define Acc     0x2000000	/* Accumulator %al or %ax or %eax */
d296 14
a309 9
#define JumpAbsolute 0x4000000
#define Abs8  0x08000000
#define Abs16 0x10000000
#define Abs32 0x20000000
#define Abs (Abs8|Abs16|Abs32)

#define Byte (Reg8|Imm8|Imm8S)
#define Word (Reg16|Imm16)
#define DWord (Reg32|Imm32)
d312 1
a312 1
    fits_in_signed_byte(num) ? (Disp8|Disp32|Abs8|Abs32) : (Disp32|Abs32)
d322 2
a323 1
  /* base_opcode is the fundamental opcode byte with a optional prefix(es). */
d327 2
d330 2
a331 2
  unsigned char extension_opcode;
#define None 0xff		/* If no extension_opcode is possible. */
d339 11
a349 11
#define W        0x1		/* set if operands are words or dwords */
#define D        0x2		/* D = 0 if Reg --> Regmem; D = 1 if Regmem --> Reg */
  /* direction flag for floating insns:  MUST BE 0x400 */
#define FloatD 0x400
  /* shorthand */
#define DW (D|W)
#define ShortForm 0x10		/* register is in low 3 bits of opcode */
#define ShortFormW 0x20		/* ShortForm and W bit is 0x8 */
#define Seg2ShortForm 0x40	/* encoding of load segment reg insns */
#define Seg3ShortForm 0x80	/* fs/gs segment register insns. */
#define Jump 0x100		/* special case for jump insns. */
d351 19
a369 21
  /* 0x400 CANNOT BE USED since it's already used by FloatD above */
#define DONT_USE 0x400
#define NoModrm 0x800
#define Modrm 0x1000
#define imulKludge 0x2000
#define JumpByte 0x4000
#define JumpDword 0x8000
#define ReverseRegRegmem 0x10000
#define Data16 0x20000		/* needs data prefix if in 32-bit mode */
#define Data32 0x40000		/* needs data prefix if in 16-bit mode */

  /* (opcode_modifier & COMES_IN_ALL_SIZES) is true if the
     instuction comes in byte, word, and dword sizes and is encoded into
     machine code in the canonical way. */
#define COMES_IN_ALL_SIZES (W)

  /* (opcode_modifier & COMES_IN_BOTH_DIRECTIONS) indicates that the
     source and destination operands can be reversed by setting either
     the D (for integer insns) or the FloatD (for floating insns) bit
     in base_opcode. */
#define COMES_IN_BOTH_DIRECTIONS (D|FloatD)
d388 2
a389 2
    template *start;
    template *end;
a398 1

a405 1

a407 9
/* these are for prefix name --> prefix code hash lookup */
typedef struct
  {
    char *prefix_name;
    unsigned char prefix_code;
  }

prefix_entry;

d411 3
a413 3
    unsigned regmem:3;		/* codes register or memory operand */
    unsigned reg:3;		/* codes register operand (or extended opcode) */
    unsigned mode:2;		/* how to interpret regmem & reg */
a414 1

d420 3
a422 3
    unsigned base:3;
    unsigned index:3;
    unsigned scale:2;
d424 1
a424 2

base_index_byte;
d433 1
a433 1
void i386_validate_fix ();
d444 1
a444 4

extern int flag_16bit_code;

#define md_do_align(n, fill, len, around)				\
d447 1
a447 1
    && now_seg != data_section && now_seg != bss_section)		\
d450 2
a451 2
    p = frag_var(rs_align_code, 15, 1, (relax_substateT) 0,		\
		 (symbolS *) 0, (long) (n), (char *) 0);		\
d476 2
@


1.5
log
@Merge the Cygnus 960904 sources
@
text
@d65 1
a65 1
#ifdef TE_NetBSD
@


1.4
log
@Resolve conflicts with 0609 Cygnus import
@
text
@d104 6
d111 2
d125 1
d131 1
d405 2
@


1.3
log
@As it is highly unlikely OpenBSD's object file format will divert from
NetBSD's, alias it instead of implementing a distinct but identical
configuration.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 1992, 1993, 1994, 1995 Free Software Foundation.
d370 4
a373 3
#define md_do_align(n, fill, around)					\
if ((n) && !need_pass_2 && (!(fill) || (char)*(fill) == (char)0x90) &&	\
    now_seg != data_section && now_seg != bss_section)			\
d392 8
@


1.2
log
@Support OpenBSD configuration, by cloning NetBSD config entries.
@
text
@a67 3
#ifdef TE_OpenBSD
#define TARGET_FORMAT		"a.out-i386-openbsd"
#endif
@


1.1
log
@Initial revision
@
text
@d68 3
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1989, 92, 93, 94, 95, 1996 Free Software Foundation.
d370 3
a372 4
#define md_do_align(n, fill, len, around)				\
if ((n) && !need_pass_2							\
    && (!(fill) || ((char)*(fill) == (char)0x90 && (len) == 1))		\
    && now_seg != data_section && now_seg != bss_section)		\
a390 8

void i386_print_statistics PARAMS ((FILE *));
#define tc_print_statistics i386_print_statistics

#ifdef SCO_ELF
#define tc_init_after_args() sco_id ()
extern void sco_id PARAMS ((void));
#endif
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a103 6

#ifdef TE_386BSD
/* The BSDI linker apparently rejects objects with a machine type of
   M_386 (100).  */
#define AOUT_MACHTYPE 0
#else
a104 2
#endif

a116 1
#ifndef TE_PE
a121 1
#endif
a394 2

#define md_number_to_chars number_to_chars_littleendian
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1989, 92, 93, 94, 95, 96, 1997 Free Software Foundation.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a22 6
#ifdef ANSI_PROTOTYPES
struct fix;
#endif

#define TARGET_BYTES_BIG_ENDIAN	0

a38 1
extern int tc_i386_fix_adjustable PARAMS ((struct fix *));
d62 1
a76 3
#ifdef TE_DYNIX
#define TARGET_FORMAT		"a.out-i386-dynix"
#endif
a85 7
#ifdef OBJ_MAYBE_ELF
#ifdef OBJ_MAYBE_COFF
extern const char *i386_target_format PARAMS ((void));
#define TARGET_FORMAT i386_target_format ()
#endif
#endif

d96 1
a96 1
extern short tc_coff_fix2rtype PARAMS ((struct fix *));
a123 1
#ifndef BFD_ASSEMBLER
d129 1
a131 2
#endif

a226 1
#define RegMMX 0x40000000	/* MMX register */
a278 1
#define iclrKludge 0x80000	/* used to convert clr to xor */
d366 1
a366 1
void i386_validate_fix PARAMS ((struct fix *));
d380 1
a380 1
#define md_do_align(n, fill, len, max, around)				\
d386 2
a387 2
    p = frag_var (rs_align_code, 15, 1, (relax_substateT) max,		\
		  (symbolS *) 0, (offsetT) (n), (char *) 0);		\
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1989, 92, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation.
d40 5
d64 4
a67 9
#define TC_RELOC_RTSYM_LOC_FIXUP(FIX)				\
  ((FIX)->fx_r_type != BFD_RELOC_386_PLT32			\
   && (FIX)->fx_r_type != BFD_RELOC_386_GOT32			\
   && (FIX)->fx_r_type != BFD_RELOC_386_GOTPC			\
   && ((FIX)->fx_addsy == NULL					\
       || (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
	   && ! S_IS_WEAK ((FIX)->fx_addsy)			\
	   && S_IS_DEFINED ((FIX)->fx_addsy)			\
	   && ! S_IS_COMMON ((FIX)->fx_addsy))))
d71 1
d73 1
a73 1
#define AOUT_TARGET_FORMAT	"a.out-i386-netbsd"
d76 1
a76 1
#define AOUT_TARGET_FORMAT	"a.out-i386-bsd"
d79 1
a79 1
#define AOUT_TARGET_FORMAT	"a.out-i386-linux"
d82 1
a82 1
#define AOUT_TARGET_FORMAT	"a.out-mach3"
d85 1
a85 1
#define AOUT_TARGET_FORMAT	"a.out-i386-dynix"
d87 2
a88 2
#ifndef AOUT_TARGET_FORMAT
#define AOUT_TARGET_FORMAT	"a.out-i386"
d90 1
a91 6
#if ((defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_COFF)) \
     || (defined (OBJ_MAYBE_ELF) && defined (OBJ_MAYBE_AOUT)) \
     || (defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)))
extern const char *i386_target_format PARAMS ((void));
#define TARGET_FORMAT i386_target_format ()
#else
d95 5
a99 2
#ifdef OBJ_AOUT
#define TARGET_FORMAT		AOUT_TARGET_FORMAT
d111 1
a115 13

#ifdef TE_GO32
/* DJGPP now expects some sections to be 2**4 aligned.  */
#define SUB_SEGMENT_ALIGN(SEG)						\
  ((strcmp (obj_segment_name (SEG), ".text") == 0			\
    || strcmp (obj_segment_name (SEG), ".data") == 0			\
    || strcmp (obj_segment_name (SEG), ".bss") == 0			\
    || strncmp (obj_segment_name (SEG), ".gnu.linkonce.t", 15) == 0	\
    || strncmp (obj_segment_name (SEG), ".gnu.linkonce.d", 15) == 0	\
    || strncmp (obj_segment_name (SEG), ".gnu.linkonce.r", 15) == 0)	\
   ? 4									\
   : 2)
#else
a116 2
#endif

a133 3
#define TC_FORCE_RELOCATION(fixp) tc_i386_force_relocation(fixp)
extern int tc_i386_force_relocation PARAMS ((struct fix *));

a143 1
#ifndef TE_GO32
a149 1
#endif
a156 3
extern const char extra_symbol_chars[];
#define tc_symbol_chars extra_symbol_chars

d158 3
a160 12
#define MAX_IMMEDIATE_OPERANDS 2/* max immediates per insn (lcall, ljmp) */
#define MAX_MEMORY_OPERANDS 2	/* max memory refs per insn (string ops) */

/* Prefixes will be emitted in the order defined below.
   WAIT_PREFIX must be the first prefix since FWAIT is really is an
   instruction, and so must come before any prefixes. */
#define WAIT_PREFIX	0
#define LOCKREP_PREFIX	1
#define ADDR_PREFIX	2
#define DATA_PREFIX	3
#define SEG_PREFIX	4
#define MAX_PREFIXES	5	/* max prefixes per opcode */
d166 1
a180 1
#define NO_BASE_REGISTER_16 6
d182 4
a185 9
/* these are the instruction mnemonic suffixes.  */
#define WORD_MNEM_SUFFIX  'w'
#define BYTE_MNEM_SUFFIX  'b'
#define SHORT_MNEM_SUFFIX 's'
#define LONG_MNEM_SUFFIX  'l'
/* Intel Syntax */
#define LONG_DOUBLE_MNEM_SUFFIX 'x'
/* Intel Syntax */
#define DWORD_MNEM_SUFFIX 'd'
a192 11
/* Intel Syntax */
/* Values 0-4 map onto scale factor */
#define BYTE_PTR     0
#define WORD_PTR     1
#define DWORD_PTR    2
#define QWORD_PTR    3
#define XWORD_PTR    4
#define SHORT        5
#define OFFSET_FLAT  6
#define FLAT         7
#define NONE_FOUND   8
d199 1
a199 1
  the opcode table in opcode/i386.h.
d201 1
d203 5
a207 3
#define Reg8		   0x1	/* 8 bit reg */
#define Reg16		   0x2	/* 16 bit reg */
#define Reg32		   0x4	/* 32 bit reg */
d209 7
a215 5
#define Imm8		   0x8	/* 8 bit immediate */
#define Imm8S		  0x10	/* 8 bit immediate sign extended */
#define Imm16		  0x20	/* 16 bit immediate */
#define Imm32		  0x40	/* 32 bit immediate */
#define Imm1		  0x80	/* 1 bit immediate */
d217 12
a228 10
#define BaseIndex	 0x100
/* Disp8,16,32 are used in different ways, depending on the
   instruction.  For jumps, they specify the size of the PC relative
   displacement, for baseindex type instructions, they specify the
   size of the offset relative to the base register, and for memory
   offset instructions such as `mov 1234,%al' they specify the size of
   the offset relative to the segment base.  */
#define Disp8		 0x200	/* 8 bit displacement */
#define Disp16		 0x400	/* 16 bit displacement */
#define Disp32		 0x800	/* 32 bit displacement */
d230 10
a239 23
#define InOutPortReg	0x1000	/* register to hold in/out port addr = dx */
#define ShiftCount	0x2000	/* register to hold shift cound = cl */
#define Control	        0x4000	/* Control register */
#define Debug	        0x8000	/* Debug register */
#define Test	       0x10000	/* Test register */
#define FloatReg       0x20000	/* Float register */
#define FloatAcc       0x40000	/* Float stack top %st(0) */
#define SReg2	       0x80000	/* 2 bit segment register */
#define SReg3	      0x100000	/* 3 bit segment register */
#define Acc	      0x200000	/* Accumulator %al or %ax or %eax */
#define JumpAbsolute  0x400000
#define RegMMX	      0x800000	/* MMX register */
#define RegXMM	     0x1000000	/* XMM registers in PIII */
#define EsSeg	     0x2000000	/* String insn operand with fixed es segment */
/* InvMem is for instructions with a modrm byte that only allow a
   general register encoding in the i.tm.mode and i.tm.regmem fields,
   eg. control reg moves.  They really ought to support a memory form,
   but don't, so we add an InvMem flag to the register operand to
   indicate that it should be encoded in the i.tm.regmem field.  */
#define InvMem	     0x4000000

#define Reg	(Reg8|Reg16|Reg32)	/* gen'l register */
#define WordReg (Reg16|Reg32)
d241 10
a250 14
#define Imm	(Imm8|Imm8S|Imm16|Imm32) /* gen'l immediate */
#define Disp	(Disp8|Disp16|Disp32)	/* General displacement */
#define AnyMem	(Disp|BaseIndex|InvMem)	/* General memory */
/* The following aliases are defined because the opcode table
   carefully specifies the allowed memory types for each instruction.
   At the moment we can only tell a memory reference size by the
   instruction suffix, so there's not much point in defining Mem8,
   Mem16, Mem32 and Mem64 opcode modifiers - We might as well just use
   the suffix directly to check memory operands.  */
#define LLongMem AnyMem		/* 64 bits (or more) */
#define LongMem AnyMem		/* 32 bit memory ref */
#define ShortMem AnyMem		/* 16 bit memory ref */
#define WordMem AnyMem		/* 16 or 32 bit memory ref */
#define ByteMem AnyMem		/* 8 bit memory ref */
d253 1
a253 1
    (fits_in_signed_byte(num) ? (Disp8|Disp32) : Disp32)
d263 1
a263 2
  /* base_opcode is the fundamental opcode byte without optional
     prefix(es).  */
a266 2
     This field is also used to store the 8-bit opcode suffix for the
     AMD 3DNow! instructions.
d268 2
a269 2
  unsigned int extension_opcode;
#define None 0xffff		/* If no extension_opcode is possible. */
d277 11
a287 11
#define W		   0x1	/* set if operands can be words or dwords
				   encoded the canonical way */
#define D		   0x2	/* D = 0 if Reg --> Regmem;
				   D = 1 if Regmem --> Reg:    MUST BE 0x2 */
#define Modrm		   0x4
#define FloatR		   0x8	/* src/dest swap for floats:   MUST BE 0x8 */
#define ShortForm	  0x10	/* register is in low 3 bits of opcode */
#define FloatMF		  0x20	/* FP insn memory format bit, sized by 0x4 */
#define Jump		  0x40	/* special case for jump insns. */
#define JumpDword	  0x80  /* call and jump */
#define JumpByte	 0x100  /* loop and jecxz */
d289 22
a310 19
#define FloatD		 0x400	/* direction for float insns:  MUST BE 0x400 */
#define Seg2ShortForm	 0x800	/* encoding of load segment reg insns */
#define Seg3ShortForm	0x1000	/* fs/gs segment register insns. */
#define Size16		0x2000	/* needs size prefix if in 32-bit mode */
#define Size32		0x4000	/* needs size prefix if in 16-bit mode */
#define IgnoreSize	0x8000  /* instruction ignores operand size prefix */
#define DefaultSize    0x10000  /* default insn size depends on mode */
#define No_bSuf	       0x20000	/* b suffix on instruction illegal */
#define No_wSuf	       0x40000	/* w suffix on instruction illegal */
#define No_lSuf	       0x80000	/* l suffix on instruction illegal */
#define No_sSuf	      0x100000	/* s suffix on instruction illegal */
#define No_dSuf       0x200000  /* d suffix on instruction illegal */
#define No_xSuf       0x400000  /* x suffix on instruction illegal */
#define FWait	      0x800000	/* instruction needs FWAIT */
#define IsString     0x1000000	/* quick test for string instructions */
#define regKludge    0x2000000	/* fake an extra reg operand for clr, imul */
#define IsPrefix     0x4000000	/* opcode is a prefix */
#define ImmExt	     0x8000000	/* instruction has extension in 8 bit imm */
#define Ugh	    0x80000000	/* deprecated fp insn, gets a warning */
d329 2
a330 2
    const template *start;
    const template *end;
d340 1
d348 1
d351 9
d363 3
a365 3
    unsigned int regmem;	/* codes register or memory operand */
    unsigned int reg;		/* codes register operand (or extended opcode) */
    unsigned int mode;		/* how to interpret regmem & reg */
d367 1
d373 3
a375 3
    unsigned base;
    unsigned index;
    unsigned scale;
d377 2
a378 1
sib_byte;
d398 3
d404 1
a404 1
    && subseg_text_p (now_seg))						\
a432 2

#define DIFF_EXPR_OK    /* foo-. gets turned into PC relative relocs */
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 3
   Copyright 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
   Free Software Foundation, Inc.
d44 8
a51 12
#if (defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF) || defined (OBJ_MAYBE_COFF) || defined (OBJ_COFF)) && !defined (TE_PE)
/* This arranges for gas/write.c to not apply a relocation if
   tc_fix_adjustable() says it is not adjustable.
   The "! symbol_used_in_reloc_p" test is there specifically to cover
   the case of non-global symbols in linkonce sections.  It's the
   generally correct thing to do though;  If a reloc is going to be
   emitted against a symbol then we don't want to adjust the fixup by
   applying the reloc during assembly.  The reloc will be applied by
   the linker during final link.  */
#define TC_FIX_ADJUSTABLE(fixP) \
  (! symbol_used_in_reloc_p ((fixP)->fx_addsy) && tc_fix_adjustable (fixP))
#endif
d58 1
a58 1
   pcrel, but it is easier to be safe than sorry.  */
a70 2
#define TARGET_MACH		(i386_mach ())
extern unsigned long i386_mach PARAMS ((void));
a71 3
#ifdef TE_FreeBSD
#define AOUT_TARGET_FORMAT	"a.out-i386-freebsd"
#endif
d91 3
a93 2
#if ((defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)) \
     || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF))
d137 1
a149 9
#ifndef LEX_AT
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) x86_cons (EXP, NBYTES)
extern void x86_cons PARAMS ((expressionS *, int));

#define TC_CONS_FIX_NEW(FRAG,OFF,LEN,EXP) x86_cons_fix_new(FRAG, OFF, LEN, EXP)
extern void x86_cons_fix_new
  PARAMS ((fragS *, unsigned int, unsigned int, expressionS *));
#endif

d187 1
a187 1
   instruction, and so must come before any prefixes.  */
d193 1
a193 2
#define REX_PREFIX	5       /* must come last.  */
#define MAX_PREFIXES	6	/* max prefixes per opcode */
a219 1
#define QWORD_MNEM_SUFFIX  'q'
d222 2
d242 71
d331 1
a331 27
#define None 0xffff		/* If no extension_opcode is possible.  */

  /* cpu feature flags */
  unsigned int cpu_flags;
#define Cpu086		  0x1	/* Any old cpu will do, 0 does the same */
#define Cpu186		  0x2	/* i186 or better required */
#define Cpu286		  0x4	/* i286 or better required */
#define Cpu386		  0x8	/* i386 or better required */
#define Cpu486		 0x10	/* i486 or better required */
#define Cpu586		 0x20	/* i585 or better required */
#define Cpu686		 0x40	/* i686 or better required */
#define CpuP4		 0x80	/* Pentium4 or better required */
#define CpuK6		0x100	/* AMD K6 or better required*/
#define CpuAthlon	0x200	/* AMD Athlon or better required*/
#define CpuSledgehammer 0x400	/* Sledgehammer or better required */
#define CpuMMX		0x800	/* MMX support required */
#define CpuSSE	       0x1000	/* Streaming SIMD extensions required */
#define CpuSSE2	       0x2000	/* Streaming SIMD extensions 2 required */
#define Cpu3dnow       0x4000	/* 3dnow! support required */
#define CpuUnknown     0x8000	/* The CPU is unknown,  be on the safe side.  */

  /* These flags are set by gas depending on the flag_code.  */
#define Cpu64	     0x4000000   /* 64bit support required  */
#define CpuNo64      0x8000000   /* Not supported in the 64bit mode  */

  /* The default value for unknown CPUs - enable all features to avoid problems.  */
#define CpuUnknownFlags (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuSledgehammer|CpuMMX|CpuSSE|CpuSSE2|Cpu3dnow|CpuK6|CpuAthlon)
d347 1
a347 1
#define Jump		  0x40	/* special case for jump insns.  */
d353 1
a353 1
#define Seg3ShortForm	0x1000	/* fs/gs segment register insns.  */
d356 13
a368 16
#define Size64		0x8000	/* needs size prefix if in 16-bit mode */
#define IgnoreSize     0x10000  /* instruction ignores operand size prefix */
#define DefaultSize    0x20000  /* default insn size depends on mode */
#define No_bSuf	       0x40000	/* b suffix on instruction illegal */
#define No_wSuf	       0x80000	/* w suffix on instruction illegal */
#define No_lSuf	      0x100000 	/* l suffix on instruction illegal */
#define No_sSuf	      0x200000	/* s suffix on instruction illegal */
#define No_qSuf       0x400000  /* q suffix on instruction illegal */
#define No_xSuf       0x800000  /* x suffix on instruction illegal */
#define FWait	     0x1000000	/* instruction needs FWAIT */
#define IsString     0x2000000	/* quick test for string instructions */
#define regKludge    0x4000000	/* fake an extra reg operand for clr, imul */
#define IsPrefix     0x8000000	/* opcode is a prefix */
#define ImmExt	    0x10000000	/* instruction has extension in 8 bit imm */
#define NoRex64	    0x20000000  /* instruction don't need Rex64 prefix.  */
#define Rex64	    0x40000000  /* instruction require Rex64 prefix.  */
d374 1
a374 1
     either a register or an immediate operand.  */
a375 69

  /* operand_types[i] bits */
  /* register */
#define Reg8		   0x1	/* 8 bit reg */
#define Reg16		   0x2	/* 16 bit reg */
#define Reg32		   0x4	/* 32 bit reg */
#define Reg64		   0x8	/* 64 bit reg */
  /* immediate */
#define Imm8		  0x10	/* 8 bit immediate */
#define Imm8S		  0x20	/* 8 bit immediate sign extended */
#define Imm16		  0x40	/* 16 bit immediate */
#define Imm32		  0x80	/* 32 bit immediate */
#define Imm32S		 0x100	/* 32 bit immediate sign extended */
#define Imm64		 0x200	/* 64 bit immediate */
#define Imm1		 0x400	/* 1 bit immediate */
  /* memory */
#define BaseIndex	 0x800
  /* Disp8,16,32 are used in different ways, depending on the
     instruction.  For jumps, they specify the size of the PC relative
     displacement, for baseindex type instructions, they specify the
     size of the offset relative to the base register, and for memory
     offset instructions such as `mov 1234,%al' they specify the size of
     the offset relative to the segment base.  */
#define Disp8		0x1000	/* 8 bit displacement */
#define Disp16		0x2000	/* 16 bit displacement */
#define Disp32		0x4000	/* 32 bit displacement */
#define Disp32S	        0x8000	/* 32 bit signed displacement */
#define Disp64	       0x10000	/* 64 bit displacement */
  /* specials */
#define InOutPortReg   0x20000	/* register to hold in/out port addr = dx */
#define ShiftCount     0x40000	/* register to hold shift cound = cl */
#define Control	       0x80000	/* Control register */
#define Debug	      0x100000	/* Debug register */
#define Test	      0x200000	/* Test register */
#define FloatReg      0x400000	/* Float register */
#define FloatAcc      0x800000	/* Float stack top %st(0) */
#define SReg2	     0x1000000	/* 2 bit segment register */
#define SReg3	     0x2000000	/* 3 bit segment register */
#define Acc	     0x4000000	/* Accumulator %al or %ax or %eax */
#define JumpAbsolute 0x8000000
#define RegMMX	    0x10000000	/* MMX register */
#define RegXMM	    0x20000000	/* XMM registers in PIII */
#define EsSeg	    0x40000000	/* String insn operand with fixed es segment */

  /* InvMem is for instructions with a modrm byte that only allow a
     general register encoding in the i.tm.mode and i.tm.regmem fields,
     eg. control reg moves.  They really ought to support a memory form,
     but don't, so we add an InvMem flag to the register operand to
     indicate that it should be encoded in the i.tm.regmem field.  */
#define InvMem	    0x80000000

#define Reg	(Reg8|Reg16|Reg32|Reg64) /* gen'l register */
#define WordReg (Reg16|Reg32|Reg64)
#define ImplicitRegister (InOutPortReg|ShiftCount|Acc|FloatAcc)
#define Imm	(Imm8|Imm8S|Imm16|Imm32S|Imm32|Imm64) /* gen'l immediate */
#define EncImm	(Imm8|Imm16|Imm32|Imm32S) /* Encodable gen'l immediate */
#define Disp	(Disp8|Disp16|Disp32|Disp32S|Disp64) /* General displacement */
#define AnyMem	(Disp8|Disp16|Disp32|Disp32S|BaseIndex|InvMem)	/* General memory */
  /* The following aliases are defined because the opcode table
     carefully specifies the allowed memory types for each instruction.
     At the moment we can only tell a memory reference size by the
     instruction suffix, so there's not much point in defining Mem8,
     Mem16, Mem32 and Mem64 opcode modifiers - We might as well just use
     the suffix directly to check memory operands.  */
#define LLongMem AnyMem		/* 64 bits (or more) */
#define LongMem AnyMem		/* 32 bit memory ref */
#define ShortMem AnyMem		/* 16 bit memory ref */
#define WordMem AnyMem		/* 16 or 32 bit memory ref */
#define ByteMem AnyMem		/* 8 bit memory ref */
d387 4
a390 5
{
  const template *start;
  const template *end;
}
templates;
d394 5
a398 8
{
  char *reg_name;
  unsigned int reg_type;
  unsigned int reg_flags;
#define RegRex	    0x1  /* Extended register.  */
#define RegRex64    0x2  /* Extended 8 bit register.  */
  unsigned int reg_num;
}
d402 4
a405 4
{
  char *seg_name;
  unsigned int seg_prefix;
}
d408 1
a408 1
/* 386 operand encoding bytes:  see 386 book for details of this.  */
d410 5
a414 5
{
  unsigned int regmem;	/* codes register or memory operand */
  unsigned int reg;	/* codes register operand (or extended opcode) */
  unsigned int mode;	/* how to interpret regmem & reg */
}
d417 1
a417 1
/* x86-64 extension prefix.  */
d420 3
a422 5
    unsigned int mode64;
    unsigned int extX;		/* Used to extend modrm reg field.  */
    unsigned int extY;		/* Used to extend SIB index field.  */
    unsigned int extZ;		/* Used to extend modrm reg/mem, SIB base, modrm base fields.  */
    unsigned int empty;		/* Used to old-style byte registers to new style.  */
a423 9
rex_byte;

/* 386 opcode byte to code indirect addressing.  */
typedef struct
{
  unsigned base;
  unsigned index;
  unsigned scale;
}
a425 8
/* x86 arch names and features */
typedef struct
{
  const char *name;	/* arch name */
  unsigned int flags;	/* cpu feature flags */
}
arch_entry;

d427 1
a427 1
   this to be overridden if need be.  */
d449 4
a452 1
    frag_align_code ((n), (max));					\
a455 2
#define MAX_MEM_FOR_RS_ALIGN_CODE  15

d478 2
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002, 2003
d37 38
a100 7
#ifdef TE_FreeBSD
#define ELF_TARGET_FORMAT	"elf32-i386-freebsd"
#endif
#ifndef ELF_TARGET_FORMAT
#define ELF_TARGET_FORMAT	"elf32-i386"
#endif

d107 1
a107 1
#define TARGET_FORMAT		ELF_TARGET_FORMAT
a113 7
#if (defined (OBJ_MAYBE_ELF) || defined (OBJ_ELF))
#define md_end i386_elf_emit_arch_note
extern void i386_elf_emit_arch_note PARAMS ((void));
#endif

#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 0

d122 1
a122 1
#define TC_COFF_FIX2RTYPE(FIX) tc_coff_fix2rtype(FIX)
d124 1
a124 1
#define TC_COFF_SIZEMACHDEP(frag) tc_coff_sizemachdep (frag)
d129 1
a129 1
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
d139 1
a139 1
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 2
d142 4
d154 24
d187 3
a193 5
#define tc_coff_symbol_emit_hook(a)	{;}	/* not used */

#endif /* ! BFD_ASSEMBLER */

#define LOCAL_LABELS_FB 1
d296 1
d466 9
a474 11
typedef int rex_byte;
#define REX_OPCODE	0x40

/* Indicates 64 bit operand size.  */
#define REX_MODE64	8
/* High extension to reg field of modrm byte.  */
#define REX_EXTX	4
/* High extension to SIB index field.  */
#define REX_EXTY	2
/* High extension to base field of modrm or SIB, or reg field of opcode.  */
#define REX_EXTZ	1
a498 11
#ifndef LEX_AT
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) x86_cons (EXP, NBYTES)
extern void x86_cons PARAMS ((expressionS *, int));

#define TC_CONS_FIX_NEW(FRAG,OFF,LEN,EXP) x86_cons_fix_new(FRAG, OFF, LEN, EXP)
extern void x86_cons_fix_new
  PARAMS ((fragS *, unsigned int, unsigned int, expressionS *));
#endif

#define DIFF_EXPR_OK    /* foo-. gets turned into PC relative relocs */

a499 2
#define NO_RELOC BFD_RELOC_NONE

d501 1
a501 16
#define TC_VALIDATE_FIX(FIX,SEGTYPE,SKIP) i386_validate_fix(FIX)

#define tc_fix_adjustable(X)  tc_i386_fix_adjustable(X)
extern int tc_i386_fix_adjustable PARAMS ((struct fix *));

/* Values passed to md_apply_fix3 don't include the symbol value.  */
#define MD_APPLY_SYM_VALUE(FIX) 0

/* ELF wants external syms kept, as does PE COFF.  */
#if defined (TE_PE) && defined (STRICT_PE_FORMAT)
#define EXTERN_FORCE_RELOC				\
  (OUTPUT_FLAVOR == bfd_target_elf_flavour		\
   || OUTPUT_FLAVOR == bfd_target_coff_flavour)
#else
#define EXTERN_FORCE_RELOC				\
  (OUTPUT_FLAVOR == bfd_target_elf_flavour)
d504 1
a504 30
/* This expression evaluates to true if the relocation is for a local
   object for which we still want to do the relocation at runtime.
   False if we are willing to perform this relocation while building
   the .o file.  GOTOFF does not need to be checked here because it is
   not pcrel.  I am not sure if some of the others are ever used with
   pcrel, but it is easier to be safe than sorry.  */

#define TC_FORCE_RELOCATION_LOCAL(FIX)			\
  (!(FIX)->fx_pcrel					\
   || (FIX)->fx_plt					\
   || (FIX)->fx_r_type == BFD_RELOC_386_PLT32		\
   || (FIX)->fx_r_type == BFD_RELOC_386_GOT32		\
   || (FIX)->fx_r_type == BFD_RELOC_386_GOTPC		\
   || TC_FORCE_RELOCATION (FIX))

#else /* ! BFD_ASSEMBLER */

#define NO_RELOC 0

#define TC_RVA_RELOC 7

/* Need this for PIC relocations */
#define NEED_FX_R_TYPE

#undef REVERSE_SORT_RELOCS

/* For COFF.  */
#define TC_FORCE_RELOCATION(FIX)			\
  ((FIX)->fx_r_type == 7 || generic_force_reloc (FIX))
#endif /* ! BFD_ASSEMBLER */
d530 3
d543 1
a543 1
#endif /* TC_I386 */
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
a25 4
#ifndef BFD_ASSEMBLER
#error So, do you know what you are doing?
#endif

d36 1
d90 53
a245 2
#define CpuPNI	       0x8000	/* Prescott New Instructions required */
#define CpuPadLock    0x10000	/* VIA PadLock required */
d252 1
a252 1
#define CpuUnknownFlags (Cpu086|Cpu186|Cpu286|Cpu386|Cpu486|Cpu586|Cpu686|CpuP4|CpuSledgehammer|CpuMMX|CpuSSE|CpuSSE2|CpuPNI|Cpu3dnow|CpuK6|CpuAthlon|CpuPadLock)
d461 1
d498 16
a518 2
extern int optimize_align_code;

d520 2
a521 5
if ((n)									\
    && !need_pass_2							\
    && optimize_align_code						\
    && (!(fill)								\
	|| ((char)*(fill) == (char)0x90 && (len) == 1))			\
a546 15

/* We want .cfi_* pseudo-ops for generating unwind info.  */
#define TARGET_USE_CFIPOP 1

extern unsigned int x86_dwarf2_return_column;
#define DWARF2_DEFAULT_RETURN_COLUMN x86_dwarf2_return_column

extern int x86_cie_data_alignment;
#define DWARF2_CIE_DATA_ALIGNMENT x86_cie_data_alignment

#define tc_regname_to_dw2regnum tc_x86_regname_to_dw2regnum
extern int tc_x86_regname_to_dw2regnum PARAMS ((const char *regname));

#define tc_cfi_frame_initial_instructions tc_x86_frame_initial_instructions
extern void tc_x86_frame_initial_instructions PARAMS ((void));
@


