head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.4.0.52
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.48
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.44
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.46
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.38
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.42
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.40
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.36
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.34
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.32
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.30
	OPENBSD_5_0:1.1.1.4.0.28
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.26
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.24
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.20
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.22
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.18
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.16
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.14
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.12
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.10
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.8
	OPENBSD_4_0_BASE:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.09.12.14.46.31;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.46.31;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.37.32;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.34;	author drahn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.11.02.20.22.56;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* tc-v850.c -- Assembler code for the NEC V850
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include <ctype.h>
#include "as.h"
#include "subsegs.h"     
#include "opcode/v850.h"

#define AREA_ZDA 0
#define AREA_SDA 1
#define AREA_TDA 2

/* sign-extend a 16-bit number */
#define SEXT16(x)	((((x) & 0xffff) ^ (~ 0x7fff)) + 0x8000)

/* Temporarily holds the reloc in a cons expression.  */
static bfd_reloc_code_real_type hold_cons_reloc;

/* Set to TRUE if we want to be pedantic about signed overflows.  */
static boolean warn_signed_overflows   = FALSE;
static boolean warn_unsigned_overflows = FALSE;

/* Indicates the target BFD machine number.  */
static int     machine = -1;

/* Indicates the target processor(s) for the assemble.  */
static unsigned int	processor_mask = -1;


/* Structure to hold information about predefined registers.  */
struct reg_name
{
  const char * name;
  int          value;
};

/* Generic assembler global variables which must be defined by all targets. */

/* Characters which always start a comment. */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = ";#";

/* Characters which may be used to separate multiple commands on a 
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating 
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant, 
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";


const relax_typeS md_relax_table[] =
{
  /* Conditional branches.  */
  {0xff,     -0x100,    2, 1},
  {0x1fffff, -0x200000, 6, 0},
  /* Unconditional branches.  */
  {0xff,     -0x100,    2, 3},
  {0x1fffff, -0x200000, 4, 0},
};


static segT sdata_section = NULL;
static segT tdata_section = NULL;
static segT zdata_section = NULL;
static segT sbss_section = NULL;
static segT tbss_section = NULL;
static segT zbss_section = NULL;
static segT rosdata_section = NULL;
static segT rozdata_section = NULL;
static segT scommon_section = NULL;
static segT tcommon_section = NULL;
static segT zcommon_section = NULL;
static segT call_table_data_section = NULL;
static segT call_table_text_section = NULL;

/* fixups */
#define MAX_INSN_FIXUPS (5)
struct v850_fixup
{
  expressionS              exp;
  int                      opindex;
  bfd_reloc_code_real_type reloc;
};

struct v850_fixup fixups [MAX_INSN_FIXUPS];
static int fc;


void
v850_sdata (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (sdata_section, (subsegT) get_absolute_expression ());

  demand_empty_rest_of_line ();
}

void
v850_tdata (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (tdata_section, (subsegT) get_absolute_expression ());
  
  demand_empty_rest_of_line ();
}

void
v850_zdata (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (zdata_section, (subsegT) get_absolute_expression ());
  
  demand_empty_rest_of_line ();
}

void
v850_sbss (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (sbss_section, (subsegT) get_absolute_expression ());
  
  demand_empty_rest_of_line ();
}

void
v850_tbss (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (tbss_section, (subsegT) get_absolute_expression ());
  
  demand_empty_rest_of_line ();
}

void
v850_zbss (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (zbss_section, (subsegT) get_absolute_expression ());
  
  demand_empty_rest_of_line ();
}

void
v850_rosdata (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (rosdata_section, (subsegT) get_absolute_expression ());
  
  demand_empty_rest_of_line ();
}

void
v850_rozdata (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (rozdata_section, (subsegT) get_absolute_expression ());
  
  demand_empty_rest_of_line ();
}

void
v850_call_table_data (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (call_table_data_section, (subsegT) get_absolute_expression ());
  
  demand_empty_rest_of_line ();
}

void
v850_call_table_text (int ignore)
{
  obj_elf_section_change_hook();
  
  subseg_set (call_table_text_section, (subsegT) get_absolute_expression ());
  
  demand_empty_rest_of_line ();
}

void
v850_bss (int ignore)
{
  register int temp = get_absolute_expression ();

  obj_elf_section_change_hook();
  
  subseg_set (bss_section, (subsegT) temp);
   
  demand_empty_rest_of_line ();
}

void
v850_offset (int ignore)
{
  int temp = get_absolute_expression ();
  
  temp -= frag_now_fix();
  
  if (temp > 0)
    (void) frag_more (temp);
  
  demand_empty_rest_of_line ();
}

/* Copied from obj_elf_common() in gas/config/obj-elf.c */
static void
v850_comm (area)
     int area;
{
  char *    name;
  char      c;
  char *    p;
  int       temp;
  int       size;
  symbolS * symbolP;
  int       have_align;

  name = input_line_pointer;
  c = get_symbol_end ();
  
  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;
  
  SKIP_WHITESPACE ();
  
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after symbol-name"));
      ignore_rest_of_line ();
      return;
    }
  
  input_line_pointer ++;		/* skip ',' */
  
  if ((temp = get_absolute_expression ()) < 0)
    {
      /* xgettext:c-format */
      as_bad (_(".COMMon length (%d.) < 0! Ignored."), temp);
      ignore_rest_of_line ();
      return;
    }
  
  size = temp;
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
    }
  
  if (S_GET_VALUE (symbolP) != 0)
    {
      if (S_GET_VALUE (symbolP) != size)
	{
	  /* xgettext:c-format */
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
	}
    }
  
  know (symbol_get_frag (symbolP) == & zero_address_frag);
  
  if (*input_line_pointer != ',')
    have_align = 0;
  else
    {
      have_align = 1;
      input_line_pointer++;
      SKIP_WHITESPACE ();
    }
  
  if (! have_align || *input_line_pointer != '"')
    {
      if (! have_align)
	temp = 0;
      else
	{
	  temp = get_absolute_expression ();
	  
	  if (temp < 0)
	    {
	      temp = 0;
	      as_warn (_("Common alignment negative; 0 assumed"));
	    }
	}
      
      if (symbol_get_obj (symbolP)->local)
	{
	  segT   old_sec;
	  int    old_subsec;
	  char * pfrag;
	  int    align;
	  flagword	applicable;

	  old_sec = now_seg;
	  old_subsec = now_subseg;
      
	  applicable = bfd_applicable_section_flags (stdoutput);
		  
	  applicable &= SEC_ALLOC;
	  
	  switch (area)
	    {
	    case AREA_SDA:
	      if (sbss_section == NULL)
		{
		  sbss_section = subseg_new (".sbss", 0);
	      
		  bfd_set_section_flags (stdoutput, sbss_section, applicable);
	      
		  seg_info (sbss_section)->bss = 1;
		}
	      break;
	  
	    case AREA_ZDA:
	      if (zbss_section == NULL)
		{
		  zbss_section = subseg_new (".zbss", 0);
		  
		  bfd_set_section_flags (stdoutput, sbss_section, applicable);
	      
		  seg_info (zbss_section)->bss = 1;
		}
	      break;
	  
	    case AREA_TDA:
	      if (tbss_section == NULL)
		{
		  tbss_section = subseg_new (".tbss", 0);
		  
		  bfd_set_section_flags (stdoutput, tbss_section, applicable);
		  
		  seg_info (tbss_section)->bss = 1;
		}
	      break;
	    }

	  if (temp)
	    {
	      /* convert to a power of 2 alignment */
	      for (align = 0; (temp & 1) == 0; temp >>= 1, ++align)
		;
	      
	      if (temp != 1)
		{
		  as_bad (_("Common alignment not a power of 2"));
		  ignore_rest_of_line ();
		  return;
		}
	    }
	  else
	    align = 0;
	  
	  switch (area)
	    {
	    case AREA_SDA:
	      record_alignment (sbss_section, align);
	      obj_elf_section_change_hook();
	      subseg_set (sbss_section, 0);
	      break;

	    case AREA_ZDA:
	      record_alignment (zbss_section, align);
	      obj_elf_section_change_hook();
	      subseg_set (zbss_section, 0);
	      break;

	    case AREA_TDA:
	      record_alignment (tbss_section, align);
	      obj_elf_section_change_hook();
	      subseg_set (tbss_section, 0);
	      break;

	    default:
	      abort();
	    }
	  
	  if (align)
	    frag_align (align, 0, 0);

	  switch (area)
	    {
	    case AREA_SDA:
	      if (S_GET_SEGMENT (symbolP) == sbss_section)
		symbol_get_frag (symbolP)->fr_symbol = 0;
	      break;

	    case AREA_ZDA:
	      if (S_GET_SEGMENT (symbolP) == zbss_section)
		symbol_get_frag (symbolP)->fr_symbol = 0;
	      break;

	    case AREA_TDA:
	      if (S_GET_SEGMENT (symbolP) == tbss_section)
		symbol_get_frag (symbolP)->fr_symbol = 0;
	      break;

	    default:
	      abort ();
	    }
	  
	  symbol_set_frag (symbolP, frag_now);
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			    (offsetT) size, (char *) 0);
	  *pfrag = 0;
	  S_SET_SIZE (symbolP, size);
	  
	  switch (area)
	    {
	    case AREA_SDA:
	      S_SET_SEGMENT (symbolP, sbss_section);
	      break;
	      
	    case AREA_ZDA:
	      S_SET_SEGMENT (symbolP, zbss_section);
	      break;
	      
	    case AREA_TDA:
	      S_SET_SEGMENT (symbolP, tbss_section);
	      break;
	      
	    default:
	      abort();
	    }
	    
	  S_CLEAR_EXTERNAL (symbolP);
	  obj_elf_section_change_hook();
	  subseg_set (old_sec, old_subsec);
	}
      else
	{
	allocate_common:
	  S_SET_VALUE (symbolP, (valueT) size);
	  S_SET_ALIGN (symbolP, temp);
	  S_SET_EXTERNAL (symbolP);
	  
	  switch (area)
	    {
	    case AREA_SDA:
	      if (scommon_section == NULL)
		{
		  flagword	applicable;
		  
		  applicable = bfd_applicable_section_flags (stdoutput);
		  
		  scommon_section = subseg_new (".scommon", 0);
		  
		  bfd_set_section_flags (stdoutput, scommon_section, applicable
		     & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
			| SEC_HAS_CONTENTS) | SEC_IS_COMMON);
		}
	      S_SET_SEGMENT (symbolP, scommon_section);
	      break;
	      
	    case AREA_ZDA:
	      if (zcommon_section == NULL)
		{
		  flagword	applicable;
		  
		  applicable = bfd_applicable_section_flags (stdoutput);
		  
		  zcommon_section = subseg_new (".zcommon", 0);
		  
		  bfd_set_section_flags (stdoutput, zcommon_section, applicable
		     & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
			| SEC_HAS_CONTENTS) | SEC_IS_COMMON);
		}
	      S_SET_SEGMENT (symbolP, zcommon_section);
	      break;
	      
	    case AREA_TDA:
	      if (tcommon_section == NULL)
		{
		  flagword	applicable;
		  
		  applicable = bfd_applicable_section_flags (stdoutput);
		  
		  tcommon_section = subseg_new (".tcommon", 0);
		  
		  bfd_set_section_flags (stdoutput, tcommon_section, applicable
		     & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
			| SEC_HAS_CONTENTS) | SEC_IS_COMMON);
		}
	      S_SET_SEGMENT (symbolP, tcommon_section);
	      break;
	      
	    default:
	      abort();
	    }
	}
    }
  else
    {
      input_line_pointer++;
      /* @@@@ Some use the dot, some don't.  Can we get some consistency??  */
      if (*input_line_pointer == '.')
	input_line_pointer++;
      /* @@@@ Some say data, some say bss.  */
      if (strncmp (input_line_pointer, "bss\"", 4)
	  && strncmp (input_line_pointer, "data\"", 5))
	{
	  while (*--input_line_pointer != '"')
	    ;
	  input_line_pointer--;
	  goto bad_common_segment;
	}
      while (*input_line_pointer++ != '"')
	;
      goto allocate_common;
    }

  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  demand_empty_rest_of_line ();
  return;

  {
  bad_common_segment:
    p = input_line_pointer;
    while (*p && *p != '\n')
      p++;
    c = *p;
    *p = '\0';
    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
    *p = c;
    input_line_pointer = p;
    ignore_rest_of_line ();
    return;
  }
}

void
set_machine (int number)
{
  machine = number;
  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);

  switch (machine)
    {
    case 0: processor_mask = PROCESSOR_V850; break;
    case bfd_mach_v850e:  processor_mask = PROCESSOR_V850E; break;
    case bfd_mach_v850ea: processor_mask = PROCESSOR_V850EA; break;
    }
}

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  {"sdata",   v850_sdata,   0},
  {"tdata",   v850_tdata,   0},
  {"zdata",   v850_zdata,   0},
  {"sbss",    v850_sbss,    0},
  {"tbss",    v850_tbss,    0},
  {"zbss",    v850_zbss,    0},
  {"rosdata", v850_rosdata, 0},
  {"rozdata", v850_rozdata, 0},
  {"bss",     v850_bss,     0},
  {"offset",  v850_offset,  0},
  {"word",    cons,         4},
  {"zcomm",   v850_comm,    AREA_ZDA},
  {"scomm",   v850_comm,    AREA_SDA},
  {"tcomm",   v850_comm,    AREA_TDA},
  {"v850",    set_machine,  0},
  {"call_table_data", v850_call_table_data, 0},
  {"call_table_text", v850_call_table_text, 0},
  {"v850e",           set_machine,          bfd_mach_v850e},
  {"v850ea",          set_machine,          bfd_mach_v850ea},
  { NULL,     NULL,         0}
};

/* Opcode hash table.  */
static struct hash_control *v850_hash;

/* This table is sorted. Suitable for searching by a binary search. */
static const struct reg_name pre_defined_registers[] =
{
  { "ep",  30 },		/* ep - element ptr */
  { "gp",   4 },		/* gp - global ptr */
  { "hp",   2 },		/* hp - handler stack ptr */
  { "lp",  31 },		/* lp - link ptr */
  { "r0",   0 },
  { "r1",   1 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "r16", 16 },
  { "r17", 17 },
  { "r18", 18 },
  { "r19", 19 },
  { "r2",   2 },
  { "r20", 20 },
  { "r21", 21 },
  { "r22", 22 },
  { "r23", 23 },
  { "r24", 24 },
  { "r25", 25 },
  { "r26", 26 },
  { "r27", 27 },
  { "r28", 28 },
  { "r29", 29 },
  { "r3",   3 },
  { "r30", 30 },
  { "r31", 31 },
  { "r4",   4 },
  { "r5",   5 },
  { "r6",   6 },
  { "r7",   7 },
  { "r8",   8 },
  { "r9",   9 },
  { "sp",   3 },		/* sp - stack ptr */
  { "tp",   5 },		/* tp - text ptr */
  { "zero", 0 },
};
#define REG_NAME_CNT	(sizeof (pre_defined_registers) / sizeof (struct reg_name))


static const struct reg_name system_registers[] = 
{
  { "ctbp",  20 },
  { "ctpc",  16 },
  { "ctpsw", 17 },
  { "dbpc",  18 },
  { "dbpsw", 19 },
  { "ecr",    4 },
  { "eipc",   0 },
  { "eipsw",  1 },
  { "fepc",   2 },
  { "fepsw",  3 },
  { "psw",    5 },
};
#define SYSREG_NAME_CNT	(sizeof (system_registers) / sizeof (struct reg_name))

static const struct reg_name system_list_registers[] =
{
  {"PS",      5 },
  {"SR",      0 + 1}
};
#define SYSREGLIST_NAME_CNT	(sizeof (system_list_registers) / sizeof (struct reg_name))

static const struct reg_name cc_names[] =
{
  { "c",  0x1 },
  { "e",  0x2 },
  { "ge", 0xe },
  { "gt", 0xf },
  { "h",  0xb },
  { "l",  0x1 },
  { "le", 0x7 },
  { "lt", 0x6 },
  { "n",  0x4 },
  { "nc", 0x9 },
  { "ne", 0xa },
  { "nh", 0x3 },
  { "nl", 0x9 },
  { "ns", 0xc },
  { "nv", 0x8 },
  { "nz", 0xa },
  { "p",  0xc },
  { "s",  0x4 },
  { "sa", 0xd },
  { "t",  0x5 },
  { "v",  0x0 },
  { "z",  0x2 },
};
#define CC_NAME_CNT	(sizeof (cc_names) / sizeof (struct reg_name))

/* reg_name_search does a binary search of the given register table
   to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure. */

static int
reg_name_search (regs, regcount, name, accept_numbers)
     const struct reg_name * regs;
     int                     regcount;
     const char *            name;
     boolean                 accept_numbers;
{
  int middle, low, high;
  int cmp;
  symbolS * symbolP;

  /* If the register name is a symbol, then evaluate it.  */
  if ((symbolP = symbol_find (name)) != NULL)
    {
      /* If the symbol is an alias for another name then use that.
	 If the symbol is an alias for a number, then return the number.  */
      if (symbol_equated_p (symbolP))
	{
	  name = S_GET_NAME (symbol_get_value_expression (symbolP)->X_add_symbol);
	}
      else if (accept_numbers)
	{
	  int reg = S_GET_VALUE (symbolP);
	  
	  if (reg >= 0 && reg <= 31)
	    return reg;
	}

      /* Otherwise drop through and try parsing name normally.  */
    }
  
  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return regs[middle].value;
    }
  while (low <= high);
  return -1;
}


/* Summary of register_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: A expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
static boolean
register_name (expressionP)
     expressionS * expressionP;
{
  int    reg_number;
  char * name;
  char * start;
  char   c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;

  c = get_symbol_end ();

  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT,
				name, FALSE);

  * input_line_pointer = c;	/* put back the delimiting char */
  
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op         = O_register;
      expressionP->X_add_number = reg_number;

      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol  = NULL;
      
      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      input_line_pointer = start;
      
      return false;
    }
}

/* Summary of system_register_name().
 *
 * in:  Input_line_pointer points to 1st char of operand.
 *      expressionP points to an expression structure to be filled in.
 *      accept_numbers is true iff numerical register names may be used.
 *      accept_list_names is true iff the special names PS and SR may be 
 *      accepted.
 *
 * out: A expressionS structure in expressionP.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
static boolean
system_register_name (expressionP, accept_numbers, accept_list_names)
     expressionS * expressionP;
     boolean       accept_numbers;
     boolean       accept_list_names;
{
  int    reg_number;
  char * name;
  char * start;
  char   c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
				accept_numbers);

  * input_line_pointer = c;   /* put back the delimiting char */
  
  if (reg_number < 0
      && accept_numbers)
    {
      input_line_pointer   = start; /* reset input_line pointer */

      if (isdigit (* input_line_pointer))
	{
	  reg_number = strtol (input_line_pointer, & input_line_pointer, 10);

	  /* Make sure that the register number is allowable. */
	  if (   reg_number < 0
		 || reg_number > 5
		 && reg_number < 16
		 || reg_number > 20
		 )
	    {
	      reg_number = -1;
	    }
	}
      else if (accept_list_names)
	{
	  c = get_symbol_end ();
	  reg_number = reg_name_search (system_list_registers,
					SYSREGLIST_NAME_CNT, name, FALSE);

	  * input_line_pointer = c;   /* put back the delimiting char */
	}
    }
  
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op         = O_register;
      expressionP->X_add_number = reg_number;

      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol  = NULL;

      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      input_line_pointer = start;
      
      return false;
    }
}

/* Summary of cc_name().
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: A expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
static boolean
cc_name (expressionP)
     expressionS * expressionP;
{
  int    reg_number;
  char * name;
  char * start;
  char   c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (cc_names, CC_NAME_CNT, name, FALSE);

  * input_line_pointer = c;   /* put back the delimiting char */
  
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op         = O_constant;
      expressionP->X_add_number = reg_number;

      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol  = NULL;

      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      input_line_pointer = start;
      
      return false;
    }
}

static void
skip_white_space (void)
{
  while (   * input_line_pointer == ' '
	 || * input_line_pointer == '\t')
    ++ input_line_pointer;
}

/* Summary of parse_register_list ().
 *
 * in: Input_line_pointer  points to 1st char of a list of registers.
 *     insn                is the partially constructed instruction.
 *     operand             is the operand being inserted.
 *
 * out: NULL if the parse completed successfully, otherwise a
 *      pointer to an error message is returned.  If the parse
 *      completes the correct bit fields in the instruction
 *      will be filled in.
 *
 * Parses register lists with the syntax:
 *
 *   { rX }
 *   { rX, rY }
 *   { rX - rY }
 *   { rX - rY, rZ }
 *   etc
 *
 * and also parses constant epxressions whoes bits indicate the
 * registers in the lists.  The LSB in the expression refers to
 * the lowest numbered permissable register in the register list,
 * and so on upwards.  System registers are considered to be very
 * high numbers.
 * 
 */
static char *
parse_register_list
(
  unsigned long *             insn,
  const struct v850_operand * operand
)
{
  static int  type1_regs[ 32 ] = { 30,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24 };
  static int  type2_regs[ 32 ] = { 19, 18, 17, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24 };
  static int  type3_regs[ 32 ] = {  3,  2,  1,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 15, 13, 12,  7,  6,  5,  4, 11, 10,  9,  8 };
  int *       regs;
  expressionS exp;


  /* Select a register array to parse. */
  switch (operand->shift)
    {
    case 0xffe00001: regs = type1_regs; break;
    case 0xfff8000f: regs = type2_regs; break;
    case 0xfff8001f: regs = type3_regs; break;
    default:
      as_bad (_("unknown operand shift: %x\n"), operand->shift);
      return _("internal failure in parse_register_list");
    }

  skip_white_space ();

  /* If the expression starts with a curly brace it is a register list.
     Otherwise it is a constant expression, whoes bits indicate which
     registers are to be included in the list.  */
  
  if (* input_line_pointer != '{')
    {
      int bits;
      int reg;
      int i;
		
      expression (& exp);
      
      if (exp.X_op != O_constant)
	return _("constant expression or register list expected");

      if (regs == type1_regs)
	{
	  if (exp.X_add_number & 0xFFFFF000)
	    return _("high bits set in register list expression");
	  
	  for (reg = 20; reg < 32; reg ++)
	    if (exp.X_add_number & (1 << (reg - 20)))
	      {
		for (i = 0; i < 32; i++)
		  if (regs[i] == reg)
		    * insn |= (1 << i);
	      }
	}
      else if (regs == type2_regs)
	{
	  if (exp.X_add_number & 0xFFFE0000)
	    return _("high bits set in register list expression");
	  
	  for (reg = 1; reg < 16; reg ++)
	    if (exp.X_add_number & (1 << (reg - 1)))
	      {
		for (i = 0; i < 32; i++)
		  if (regs[i] == reg)
		    * insn |= (1 << i);
	      }

	  if (exp.X_add_number & (1 << 15))
	    * insn |= (1 << 3);
	  
	  if (exp.X_add_number & (1 << 16))
	    * insn |= (1 << 19);
	}
      else /* regs == type3_regs */
	{
	  if (exp.X_add_number & 0xFFFE0000)
	    return _("high bits set in register list expression");
	  
	  for (reg = 16; reg < 32; reg ++)
	    if (exp.X_add_number & (1 << (reg - 16)))
	      {
		for (i = 0; i < 32; i++)
		  if (regs[i] == reg)
		    * insn |= (1 << i);
	      }

	  if (exp.X_add_number & (1 << 16))
	    * insn |= (1 << 19);
	}

      return NULL;
    }

  input_line_pointer ++;

  /* Parse the register list until a terminator (closing curly brace or
     new-line) is found.  */
  for (;;)
    {
      if (register_name (& exp))
	{
	  int  i;
	  
	  /* Locate the given register in the list, and if it is there,
	     insert the corresponding bit into the instruction.  */
	  for (i = 0; i < 32; i++)
	    {
	      if (regs[ i ] == exp.X_add_number)
		{
		  * insn |= (1 << i);
		  break;
		}
	    }

	  if (i == 32)
	    {
	      return _("illegal register included in list");
	    }
	}
      else if (system_register_name (& exp, true, true))
	{
	  if (regs == type1_regs)
	    {
	      return _("system registers cannot be included in list");
	    }
	  else if (exp.X_add_number == 5)
	    {
	      if (regs == type2_regs)
		return _("PSW cannot be included in list");
	      else
		* insn |= 0x8;
	    }
	  else if (exp.X_add_number < 4)
	    * insn |= 0x80000;
	  else
	    return _("High value system registers cannot be included in list");
	}
      else if (* input_line_pointer == '}')
	{
	  input_line_pointer ++;
	  break;
	}
      else if (* input_line_pointer == ',')
	{
	  input_line_pointer ++;
	  continue;
	}
      else if (* input_line_pointer == '-')
	{
	  /* We have encountered a range of registers: rX - rY */
	  int         j;
	  expressionS exp2;

	  /* Skip the dash.  */
	  ++ input_line_pointer;

	  /* Get the second register in the range.  */
	  if (! register_name (& exp2))
	    {
	      return _("second register should follow dash in register list");
	      exp2.X_add_number = exp.X_add_number;
	    }

	  /* Add the rest of the registers in the range.  */
	  for (j = exp.X_add_number + 1; j <= exp2.X_add_number; j++)
	    {
	      int  i;
	  
	      /* Locate the given register in the list, and if it is there,
		 insert the corresponding bit into the instruction.  */
	      for (i = 0; i < 32; i++)
		{
		  if (regs[ i ] == j)
		    {
		      * insn |= (1 << i);
		      break;
		    }
		}

	      if (i == 32)
		return _("illegal register included in list");
	    }
	}
      else
	{
	  break;
	}

      skip_white_space ();
    }

  return NULL;
}

CONST char * md_shortopts = "m:";

struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof md_longopts; 


void
md_show_usage (stream)
  FILE * stream;
{
  fprintf (stream, _(" V850 options:\n"));
  fprintf (stream, _("  -mwarn-signed-overflow    Warn if signed immediate values overflow\n"));
  fprintf (stream, _("  -mwarn-unsigned-overflow  Warn if unsigned immediate values overflow\n"));
  fprintf (stream, _("  -mv850                    The code is targeted at the v850\n"));
  fprintf (stream, _("  -mv850e                   The code is targeted at the v850e\n"));
  fprintf (stream, _("  -mv850ea                  The code is targeted at the v850ea\n"));
  fprintf (stream, _("  -mv850any                 The code is generic, despite any processor specific instructions\n"));
}

int
md_parse_option (c, arg)
     int    c;
     char * arg;
{
  if (c != 'm')
    {
      /* xgettext:c-format */
      fprintf (stderr, _("unknown command line option: -%c%s\n"), c, arg);
      return 0;
    }

  if (strcmp (arg, "warn-signed-overflow") == 0)
    {
      warn_signed_overflows = TRUE;
    }
  else if (strcmp (arg, "warn-unsigned-overflow") == 0)
    {
      warn_unsigned_overflows = TRUE;
    }
  else if (strcmp (arg, "v850") == 0)
    {
      machine = 0;
      processor_mask = PROCESSOR_V850;
    }
  else if (strcmp (arg, "v850e") == 0)
    {
      machine = bfd_mach_v850e;
      processor_mask = PROCESSOR_V850E;
    }
  else if (strcmp (arg, "v850ea") == 0)
    {
      machine = bfd_mach_v850ea;
      processor_mask = PROCESSOR_V850EA;
    }
  else if (strcmp (arg, "v850any") == 0)
    {
      machine = 0;                       /* Tell the world that this is for any v850 chip.  */
      processor_mask = PROCESSOR_V850EA; /* But support instructions for the extended versions.  */
    }
  else
    {
      /* xgettext:c-format */
      fprintf (stderr, _("unknown command line option: -%c%s\n"), c, arg);
      return 0;
    }
  
  return 1;
}

symbolS *
md_undefined_symbol (name)
  char * name;
{
  return 0;
}

char *
md_atof (type, litp, sizep)
  int    type;
  char * litp;
  int *  sizep;
{
  int            prec;
  LITTLENUM_TYPE words[4];
  char *         t;
  int            i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return _("bad call to md_atof");
    }
  
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  for (i = prec - 1; i >= 0; i--)
    {
      md_number_to_chars (litp, (valueT) words[i], 2);
      litp += 2;
    }

  return NULL;
}


/* Very gross.  */
void
md_convert_frag (abfd, sec, fragP)
  bfd *      abfd;
  asection * sec;
  fragS *    fragP;
{
  subseg_change (sec, 0);
  
  /* In range conditional or unconditional branch.  */
  if (fragP->fr_subtype == 0 || fragP->fr_subtype == 2)
    {
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_UNUSED + (int)fragP->fr_opcode);
      fragP->fr_var = 0;
      fragP->fr_fix += 2;
    }
  /* Out of range conditional branch.  Emit a branch around a jump.  */
  else if (fragP->fr_subtype == 1)
    {
      unsigned char *buffer = 
	(unsigned char *) (fragP->fr_fix + fragP->fr_literal);

      /* Reverse the condition of the first branch.  */
      buffer[0] ^= 0x08;
      /* Mask off all the displacement bits.  */
      buffer[0] &= 0x8f;
      buffer[1] &= 0x07;
      /* Now set the displacement bits so that we branch
	 around the unconditional branch.  */
      buffer[0] |= 0x30;

      /* Now create the unconditional branch + fixup to the final
	 target.  */
      md_number_to_chars (buffer + 2, 0x00000780, 4);
      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_UNUSED +
	       (int) fragP->fr_opcode + 1);
      fragP->fr_var = 0;
      fragP->fr_fix += 6;
    }
  /* Out of range unconditional branch.  Emit a jump.  */
  else if (fragP->fr_subtype == 3)
    {
      md_number_to_chars (fragP->fr_fix + fragP->fr_literal, 0x00000780, 4);
      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_UNUSED +
	       (int) fragP->fr_opcode + 1);
      fragP->fr_var = 0;
      fragP->fr_fix += 4;
    }
  else
    abort ();
}

valueT
md_section_align (seg, addr)
     asection * seg;
     valueT     addr;
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_begin ()
{
  char *                              prev_name = "";
  register const struct v850_opcode * op;
  flagword                            applicable;

  if (strncmp (TARGET_CPU, "v850ea", 6) == 0)
    {
      if (machine == -1)
	machine = bfd_mach_v850ea;
      
      if (processor_mask == -1)
	processor_mask = PROCESSOR_V850EA;
    }
  else if (strncmp (TARGET_CPU, "v850e", 5) == 0)
    {
      if (machine == -1)
	machine        = bfd_mach_v850e;
      
      if (processor_mask == -1)
	processor_mask = PROCESSOR_V850E;
    }
  else
  if (strncmp (TARGET_CPU, "v850", 4) == 0)
    {
      if (machine == -1)
	machine        = 0;
      
      if (processor_mask == -1)
	processor_mask = PROCESSOR_V850;
    }
  else
    /* xgettext:c-format */
    as_bad (_("Unable to determine default target processor from string: %s"), 
            TARGET_CPU);

  v850_hash = hash_new();

  /* Insert unique names into hash table.  The V850 instruction set
     has many identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */

  op = v850_opcodes;
  while (op->name)
    {
      if (strcmp (prev_name, op->name)) 
	{
	  prev_name = (char *) op->name;
	  hash_insert (v850_hash, op->name, (char *) op);
	}
      op++;
    }

  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);

  applicable = bfd_applicable_section_flags (stdoutput);
  
  call_table_data_section = subseg_new (".call_table_data", 0);
  bfd_set_section_flags (stdoutput, call_table_data_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_DATA | SEC_HAS_CONTENTS));
  
  call_table_text_section = subseg_new (".call_table_text", 0);
  bfd_set_section_flags (stdoutput, call_table_text_section,
			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_READONLY
				       | SEC_CODE));
  
  /* Restore text section as the current default.  */
  subseg_set (text_section, 0);
}


static bfd_reloc_code_real_type
handle_ctoff (const struct v850_operand * operand)
{
  if (operand == NULL)
    return BFD_RELOC_V850_CALLT_16_16_OFFSET;

  if (   operand->bits  != 6
      || operand->shift != 0)
    {
      as_bad (_("ctoff() relocation used on an instruction which does not support it"));
      return BFD_RELOC_64;  /* Used to indicate an error condition.  */
    }
      
  return BFD_RELOC_V850_CALLT_6_7_OFFSET;
}

static bfd_reloc_code_real_type
handle_sdaoff (const struct v850_operand * operand)
{
  if (operand == NULL)                             return BFD_RELOC_V850_SDA_16_16_OFFSET;
  if (operand->bits == 15 && operand->shift == 17) return BFD_RELOC_V850_SDA_15_16_OFFSET;
  if (operand->bits == -1)                         return BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET;
  
  if (   operand->bits  != 16
      || operand->shift != 16)
    {
      as_bad (_("sdaoff() relocation used on an instruction which does not support it"));
      return BFD_RELOC_64;  /* Used to indicate an error condition.  */
    }
  
  return BFD_RELOC_V850_SDA_16_16_OFFSET;
}

static bfd_reloc_code_real_type
handle_zdaoff (const struct v850_operand * operand)
{
  if (operand == NULL)                             return BFD_RELOC_V850_ZDA_16_16_OFFSET;
  if (operand->bits == 15 && operand->shift == 17) return BFD_RELOC_V850_ZDA_15_16_OFFSET;
  if (operand->bits == -1)                         return BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET;

  if (   operand->bits  != 16
      || operand->shift != 16)
    {
      as_bad (_("zdaoff() relocation used on an instruction which does not support it"));
      return BFD_RELOC_64;  /* Used to indicate an error condition.  */
    }
  
  return BFD_RELOC_V850_ZDA_16_16_OFFSET;
}

static bfd_reloc_code_real_type
handle_tdaoff (const struct v850_operand * operand)
{
  if (operand == NULL)                               return BFD_RELOC_V850_TDA_7_7_OFFSET;  /* data item, not an instruction.  */
  if (operand->bits == 6 && operand->shift == 1)     return BFD_RELOC_V850_TDA_6_8_OFFSET;  /* sld.w/sst.w, operand: D8_6  */
  if (operand->bits == 4 && operand->insert != NULL) return BFD_RELOC_V850_TDA_4_5_OFFSET;  /* sld.hu, operand: D5-4 */
  if (operand->bits == 4 && operand->insert == NULL) return BFD_RELOC_V850_TDA_4_4_OFFSET;  /* sld.bu, operand: D4   */
  if (operand->bits == 16 && operand->shift == 16)   return BFD_RELOC_V850_TDA_16_16_OFFSET; /* set1 & chums, operands: D16 */
  
  if (operand->bits != 7)
    {
      as_bad (_("tdaoff() relocation used on an instruction which does not support it"));
      return BFD_RELOC_64;  /* Used to indicate an error condition.  */
    }
  
  return  operand->insert != NULL
    ? BFD_RELOC_V850_TDA_7_8_OFFSET     /* sld.h/sst.h, operand: D8_7 */
    : BFD_RELOC_V850_TDA_7_7_OFFSET;    /* sld.b/sst.b, opreand: D7   */
}

/* Warning: The code in this function relies upon the definitions
   in the v850_operands[] array (defined in opcodes/v850-opc.c)
   matching the hard coded values contained herein.  */

static bfd_reloc_code_real_type
v850_reloc_prefix (const struct v850_operand * operand)
{
  boolean paren_skipped = false;


  /* Skip leading opening parenthesis.  */
  if (* input_line_pointer == '(')
    {
      ++ input_line_pointer;
      paren_skipped = true;
    }

#define CHECK_(name, reloc) 						\
  if (strncmp (input_line_pointer, name##"(", strlen (name) + 1) == 0)	\
    {									\
      input_line_pointer += strlen (name);				\
      return reloc;							\
    }
  
  CHECK_ ("hi0",    BFD_RELOC_HI16);
  CHECK_ ("hi",     BFD_RELOC_HI16_S);
  CHECK_ ("lo",     BFD_RELOC_LO16);
  CHECK_ ("sdaoff", handle_sdaoff (operand));
  CHECK_ ("zdaoff", handle_zdaoff (operand));
  CHECK_ ("tdaoff", handle_tdaoff (operand));
  CHECK_ ("hilo",   BFD_RELOC_32);
  CHECK_ ("ctoff",  handle_ctoff (operand));
  
  /* Restore skipped parenthesis.  */
  if (paren_skipped)
    -- input_line_pointer;
  
  return BFD_RELOC_UNUSED;
}

/* Insert an operand value into an instruction.  */

static unsigned long
v850_insert_operand (insn, operand, val, file, line, str)
     unsigned long               insn;
     const struct v850_operand * operand;
     offsetT                     val;
     char *                      file;
     unsigned int                line;
     char *                      str;
{
  if (operand->insert)
    {
      const char * message = NULL;
      
      insn = operand->insert (insn, val, & message);
      if (message != NULL)
	{
	  if ((operand->flags & V850_OPERAND_SIGNED)
	      && ! warn_signed_overflows
	      && strstr (message, "out of range") != NULL)
	    {
	      /* skip warning... */
	    }
	  else if ((operand->flags & V850_OPERAND_SIGNED) == 0
		   && ! warn_unsigned_overflows
		   && strstr (message, "out of range") != NULL)
	    {
	      /* skip warning... */
	    }
	  else if (str)
	    {
	      if (file == (char *) NULL)
		as_warn ("%s: %s", str, message);
	      else
		as_warn_where (file, line, "%s: %s", str, message);
	    }
	  else
	    {
	      if (file == (char *) NULL)
		as_warn (message);
	      else
		as_warn_where (file, line, message);
	    }
	}
    }
  else
    {
      if (operand->bits != 32)
	{
	  long    min, max;
	  offsetT test;

	  if ((operand->flags & V850_OPERAND_SIGNED) != 0)
	    {
	      if (! warn_signed_overflows)
		max = (1 << operand->bits) - 1;
	      else
		max = (1 << (operand->bits - 1)) - 1;
	      
	      min = - (1 << (operand->bits - 1));
	    }
	  else
	    {
	      max = (1 << operand->bits) - 1;
	      
	      if (! warn_unsigned_overflows)
		min = - (1 << (operand->bits - 1));
	      else
		min = 0;
	    }
	  
	  if (val < (offsetT) min || val > (offsetT) max)
	    {
	      /* xgettext:c-format */
	      const char * err = _("operand out of range (%s not between %ld and %ld)");
	      char         buf[100];
	      
	      /* Restore min and mix to expected values for decimal ranges.  */
	      if ((operand->flags & V850_OPERAND_SIGNED)
		  && ! warn_signed_overflows)
		max = (1 << (operand->bits - 1)) - 1;

	      if (! (operand->flags & V850_OPERAND_SIGNED)
		  && ! warn_unsigned_overflows)
		min = 0;

	      if (str)
		{
		  sprintf (buf, "%s: ", str);
		  
		  sprint_value (buf + strlen (buf), val);
		}
	      else
		sprint_value (buf, val);
	      
	      if (file == (char *) NULL)
		as_warn (err, buf, min, max);
	      else
		as_warn_where (file, line, err, buf, min, max);
	    }
	}

      insn |= (((long) val & ((1 << operand->bits) - 1)) << operand->shift);
    }
  
  return insn;
}


static char                 copy_of_instruction [128];

void
md_assemble (str) 
     char * str;
{
  char *                    s;
  char *                    start_of_operands;
  struct v850_opcode *      opcode;
  struct v850_opcode *      next_opcode;
  const unsigned char *     opindex_ptr;
  int                       next_opindex;
  int                       relaxable;
  unsigned long             insn;
  unsigned long             insn_size;
  char *                    f;
  int                       i;
  int                       match;
  boolean                   extra_data_after_insn = false;
  unsigned                  extra_data_len;
  unsigned long             extra_data;
  char *		    saved_input_line_pointer;

  
  strncpy (copy_of_instruction, str, sizeof (copy_of_instruction) - 1);
  
  /* Get the opcode.  */
  for (s = str; *s != '\0' && ! isspace (*s); s++)
    continue;
  
  if (*s != '\0')
    *s++ = '\0';

  /* find the first opcode with the proper name */
  opcode = (struct v850_opcode *) hash_find (v850_hash, str);
  if (opcode == NULL)
    {
      /* xgettext:c-format */
      as_bad (_("Unrecognized opcode: `%s'"), str);
      ignore_rest_of_line ();
      return;
    }

  str = s;
  while (isspace (* str))
    ++ str;

  start_of_operands = str;

  saved_input_line_pointer = input_line_pointer;
  
  for (;;)
    {
      const char * errmsg = NULL;

      match = 0;
      
      if ((opcode->processors & processor_mask) == 0)
	{
	  errmsg = _("Target processor does not support this instruction.");
	  goto error;
	}
      
      relaxable = 0;
      fc = 0;
      next_opindex = 0;
      insn = opcode->opcode;
      extra_data_after_insn = false;

      input_line_pointer = str = start_of_operands;

      for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr ++)
	{
	  const struct v850_operand * operand;
	  char *                      hold;
	  expressionS                 ex;
	  bfd_reloc_code_real_type    reloc;

	  if (next_opindex == 0)
	    {
	      operand = & v850_operands[ * opindex_ptr ];
	    }
	  else
	    {
	      operand      = & v850_operands[ next_opindex ];
	      next_opindex = 0;
	    }

	  errmsg = NULL;

	  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']')
	    ++ str;

	  if (operand->flags & V850_OPERAND_RELAX)
	    relaxable = 1;

	  /* Gather the operand. */
	  hold = input_line_pointer;
	  input_line_pointer = str;
	  
	  /* lo(), hi(), hi0(), etc... */
	  if ((reloc = v850_reloc_prefix (operand)) != BFD_RELOC_UNUSED)
	    {
	      /* This is a fake reloc, used to indicate an error condition.  */
	      if (reloc == BFD_RELOC_64)
		{
		  match = 1;
		  goto error;
		}
		 
	      expression (& ex);

	      if (ex.X_op == O_constant)
		{
		  switch (reloc)
		    {
		    case BFD_RELOC_V850_ZDA_16_16_OFFSET:
		      /* To cope with "not1 7, zdaoff(0xfffff006)[r0]"
			 and the like.  */
		      /* Fall through.  */
		      
		    case BFD_RELOC_LO16:
		      {
			/* Truncate, then sign extend the value.  */
			ex.X_add_number = SEXT16 (ex.X_add_number);
			break;
		      }

		    case BFD_RELOC_HI16:
		      {
			/* Truncate, then sign extend the value.  */
			ex.X_add_number = SEXT16 (ex.X_add_number >> 16);
			break;
		      }

		    case BFD_RELOC_HI16_S:
		      {
			/* Truncate, then sign extend the value.  */
		        int temp = (ex.X_add_number >> 16) & 0xffff;

			temp += (ex.X_add_number >> 15) & 1;

			ex.X_add_number = SEXT16 (temp);
			break;
		      }
		    
		    case BFD_RELOC_32:
		      if ((operand->flags & V850E_IMMEDIATE32) == 0)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}
		      
		      extra_data_after_insn = true;
		      extra_data_len        = 4;
		      extra_data            = ex.X_add_number;
		      ex.X_add_number       = 0;
		      break;
		      
		    default:
		      fprintf (stderr, "reloc: %d\n", reloc);
		      as_bad (_("AAARG -> unhandled constant reloc"));
		      break;
		    }

		  if (fc > MAX_INSN_FIXUPS)
		    as_fatal (_("too many fixups"));
		  
		  fixups[ fc ].exp     = ex;
		  fixups[ fc ].opindex = * opindex_ptr;
		  fixups[ fc ].reloc   = reloc;
		  fc++;
		}
	      else
		{
		  if (reloc == BFD_RELOC_32)
		    {
		      if ((operand->flags & V850E_IMMEDIATE32) == 0)
			{
			  errmsg = _("immediate operand is too large");
			  goto error;
			}
		      
		      extra_data_after_insn = true;
		      extra_data_len        = 4;
		      extra_data            = ex.X_add_number;
		    }
		      
		  if (fc > MAX_INSN_FIXUPS)
		    as_fatal (_("too many fixups"));

		  fixups[ fc ].exp     = ex;
		  fixups[ fc ].opindex = * opindex_ptr;
		  fixups[ fc ].reloc   = reloc;
		  fc++;
		}
	    }
	  else
	    {
	      errmsg = NULL;
	      
	      if ((operand->flags & V850_OPERAND_REG) != 0) 
		{
		  if (!register_name (& ex))
		    {
		      errmsg = _("invalid register name");
		    }
		  else if ((operand->flags & V850_NOT_R0)
		      && ex.X_add_number == 0)
		    {
		      errmsg = _("register r0 cannot be used here");
		      
		      /* Force an error message to be generated by
			 skipping over any following potential matches
			 for this opcode.  */
		      opcode += 3;
		    }
		}
	      else if ((operand->flags & V850_OPERAND_SRG) != 0) 
		{
		  if (!system_register_name (& ex, true, false))
		    {
		      errmsg = _("invalid system register name");
		    }
		}
	      else if ((operand->flags & V850_OPERAND_EP) != 0)
		{
		  char * start = input_line_pointer;
		  char   c     = get_symbol_end ();
		  
		  if (strcmp (start, "ep") != 0 && strcmp (start, "r30") != 0)
		    {
		      /* Put things back the way we found them.  */
		      *input_line_pointer = c;
		      input_line_pointer = start;
		      errmsg = _("expected EP register");
		      goto error;
		    }
		  
		  *input_line_pointer = c;
		  str = input_line_pointer;
		  input_line_pointer = hold;
	      
		  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']')
		    ++ str;
		  continue;
		}
	      else if ((operand->flags & V850_OPERAND_CC) != 0) 
		{
		  if (!cc_name (& ex))
		    {
		      errmsg = _("invalid condition code name");
		    }
		}
	      else if (operand->flags & V850E_PUSH_POP) 
		{
		  errmsg = parse_register_list (& insn, operand);
		  
		  /* The parse_register_list() function has already done
		     everything, so fake a dummy expression.  */
		  ex.X_op         = O_constant;
		  ex.X_add_number = 0;
		}
	      else if (operand->flags & V850E_IMMEDIATE16) 
		{
		  expression (& ex);

		  if (ex.X_op != O_constant)
		    errmsg = _("constant expression expected");
		  else if (ex.X_add_number & 0xffff0000)
		    {
		      if (ex.X_add_number & 0xffff)
			errmsg = _("constant too big to fit into instruction");
		      else if ((insn & 0x001fffc0) == 0x00130780)
			ex.X_add_number >>= 16;
		      else
			errmsg = _("constant too big to fit into instruction");
		    }
		  
		  extra_data_after_insn = true;
		  extra_data_len        = 2;
		  extra_data            = ex.X_add_number;
		  ex.X_add_number       = 0;
		}
	      else if (operand->flags & V850E_IMMEDIATE32) 
		{
		  expression (& ex);
		  
		  if (ex.X_op != O_constant)
		    errmsg = _("constant expression expected");
		  
		  extra_data_after_insn = true;
		  extra_data_len        = 4;
		  extra_data            = ex.X_add_number;
		  ex.X_add_number       = 0;
		}
	      else if (register_name (& ex)
		       && (operand->flags & V850_OPERAND_REG) == 0)
		{
		  char c;
		  int  exists = 0;
		  
		  /* It is possible that an alias has been defined that
		     matches a register name.  For example the code may
		     include a ".set ZERO, 0" directive, which matches
		     the register name "zero".  Attempt to reparse the
		     field as an expression, and only complain if we
		     cannot generate a constant.  */

		  input_line_pointer = str;

		  c = get_symbol_end ();
		  
		  if (symbol_find (str) != NULL)
		    exists = 1;
		  
		  * input_line_pointer = c;
		  input_line_pointer = str;
		  
		  expression (& ex);

		  if (ex.X_op != O_constant)
		    {
		      /* If this register is actually occuring too early on
			 the parsing of the instruction, (because another
			 field is missing) then report this.  */
		      if (opindex_ptr[1] != 0
			  && (v850_operands [opindex_ptr [1]].flags & V850_OPERAND_REG))
			errmsg = _("syntax error: value is missing before the register name");
		      else
			errmsg = _("syntax error: register not expected");

		      /* If we created a symbol in the process of this test then
			 delete it now, so that it will not be output with the real
			 symbols... */
		      if (exists == 0
			  && ex.X_op == O_symbol)
			symbol_remove (ex.X_add_symbol,
				       & symbol_rootP, & symbol_lastP);
		    }
		}
	      else if (system_register_name (& ex, false, false)
		       && (operand->flags & V850_OPERAND_SRG) == 0)
		{
		  errmsg = _("syntax error: system register not expected");
		}
	      else if (cc_name (&ex)
		       && (operand->flags & V850_OPERAND_CC) == 0)
		{
		  errmsg = _("syntax error: condition code not expected");
		}
	      else
		{
		  expression (& ex);
		  /* Special case:
		     If we are assembling a MOV instruction (or a CALLT.... :-)
		     and the immediate value does not fit into the bits
		     available then create a fake error so that the next MOV
		     instruction will be selected.  This one has a 32 bit
		     immediate field.  */

		  if (((insn & 0x07e0) == 0x0200)
		      && ex.X_op == O_constant
		      && (ex.X_add_number < (- (1 << (operand->bits - 1)))
			  || ex.X_add_number > ((1 << operand->bits) - 1)))
		    errmsg = _("immediate operand is too large");
		}

	      if (errmsg)
		goto error;
	      
/* fprintf (stderr, " insn: %x, operand %d, op: %d, add_number: %d\n",
   insn, opindex_ptr - opcode->operands, ex.X_op, ex.X_add_number); */

	      switch (ex.X_op) 
		{
		case O_illegal:
		  errmsg = _("illegal operand");
		  goto error;
		case O_absent:
		  errmsg = _("missing operand");
		  goto error;
		case O_register:
		  if ((operand->flags & (V850_OPERAND_REG | V850_OPERAND_SRG)) == 0)
		    {
		      errmsg = _("invalid operand");
		      goto error;
		    }
		  insn = v850_insert_operand (insn, operand, ex.X_add_number,
					      (char *) NULL, 0,
					      copy_of_instruction);
		  break;

		case O_constant:
		  insn = v850_insert_operand (insn, operand, ex.X_add_number,
					      (char *) NULL, 0,
					      copy_of_instruction);
		  break;

		default:
		  /* We need to generate a fixup for this expression.  */
		  if (fc >= MAX_INSN_FIXUPS)
		    as_fatal (_("too many fixups"));

		  fixups[ fc ].exp     = ex;
		  fixups[ fc ].opindex = * opindex_ptr;
		  fixups[ fc ].reloc   = BFD_RELOC_UNUSED;
		  ++fc;
		  break;
		}
	    }

	  str = input_line_pointer;
	  input_line_pointer = hold;

	  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']'
		 || *str == ')')
	    ++str;
	}
      match = 1;

    error:
      if (match == 0)
        {
	  next_opcode = opcode + 1;
	  if (next_opcode->name != NULL
	      && strcmp (next_opcode->name, opcode->name) == 0)
	    {
	      opcode = next_opcode;

	      /* Skip versions that are not supported by the target
		 processor.  */
	      if ((opcode->processors & processor_mask) == 0)
		goto error;
	      
	      continue;
	    }
	  
	  as_bad ("%s: %s", copy_of_instruction, errmsg);
	  
	  if (* input_line_pointer == ']')
	    ++ input_line_pointer;
	  
	  ignore_rest_of_line ();
	  input_line_pointer = saved_input_line_pointer;
	  return;
        }
      break;
    }
      
  while (isspace (*str))
    ++str;

  if (*str != '\0')
    /* xgettext:c-format */
    as_bad (_("junk at end of line: `%s'"), str);

  input_line_pointer = str;

  /* Write out the instruction. */
  
  if (relaxable && fc > 0)
    {
      insn_size = 2;
      fc = 0;

      if (!strcmp (opcode->name, "br"))
	{
	  f = frag_var (rs_machine_dependent, 4, 2, 2,
			fixups[0].exp.X_add_symbol,
			fixups[0].exp.X_add_number,
			(char *)fixups[0].opindex);
	  md_number_to_chars (f, insn, insn_size);
	  md_number_to_chars (f + 2, 0, 2);
	}
      else
	{
	  f = frag_var (rs_machine_dependent, 6, 4, 0,
			fixups[0].exp.X_add_symbol,
			fixups[0].exp.X_add_number,
			(char *)fixups[0].opindex);
	  md_number_to_chars (f, insn, insn_size);
	  md_number_to_chars (f + 2, 0, 4);
	}
    }
  else 
    {
      /* Four byte insns have an opcode with the two high bits on.  */
      if ((insn & 0x0600) == 0x0600)
	insn_size = 4;
      else
	insn_size = 2;

      /* Special case: 32 bit MOV */
      if ((insn & 0xffe0) == 0x0620)
	insn_size = 2;
      
      f = frag_more (insn_size);
      
      md_number_to_chars (f, insn, insn_size);

      if (extra_data_after_insn)
	{
	  f = frag_more (extra_data_len);
	  
	  md_number_to_chars (f, extra_data, extra_data_len);

	  extra_data_after_insn = false;
	}
    }

  /* Create any fixups.  At this point we do not use a
     bfd_reloc_code_real_type, but instead just use the
     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
     handle fixups for any operand type, although that is admittedly
     not a very exciting feature.  We pick a BFD reloc type in
     md_apply_fix.  */  
  for (i = 0; i < fc; i++)
    {
      const struct v850_operand * operand;
      bfd_reloc_code_real_type    reloc;
      
      operand = & v850_operands[ fixups[i].opindex ];

      reloc = fixups[i].reloc;
      
      if (reloc != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type * reloc_howto = bfd_reloc_type_lookup (stdoutput,
								  reloc);
	  int                size;
	  int                address;
	  fixS *             fixP;

	  if (!reloc_howto)
	    abort();
	  
	  size = bfd_get_reloc_size (reloc_howto);

	  /* XXX This will abort on an R_V850_8 reloc -
	     is this reloc actually used ? */
	  if (size != 2 && size != 4) 
	    abort ();

	  address = (f - frag_now->fr_literal) + insn_size - size;

	  if (reloc == BFD_RELOC_32)
	    {
	      address += 2;
	    }
	  
	  fixP = fix_new_exp (frag_now, address, size,
			      & fixups[i].exp, 
			      reloc_howto->pc_relative,
			      reloc);

	  switch (reloc)
	    {
	    case BFD_RELOC_LO16:
	    case BFD_RELOC_HI16:
	    case BFD_RELOC_HI16_S:
	      fixP->fx_no_overflow = 1;
	      break;
	    }
	}
      else
	{
	  fix_new_exp (
		       frag_now,
		       f - frag_now->fr_literal, 4,
		       & fixups[i].exp,
		       1 /* FIXME: V850_OPERAND_RELATIVE ??? */,
		       (bfd_reloc_code_real_type) (fixups[i].opindex
						   + (int) BFD_RELOC_UNUSED)
		       );
	}
    }

  input_line_pointer = saved_input_line_pointer;
}


/* If while processing a fixup, a reloc really needs to be created */
/* then it is done here.  */
                 
arelent *
tc_gen_reloc (seg, fixp)
     asection * seg;
     fixS *     fixp;
{
  arelent * reloc;
  
  reloc              = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr= symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address     = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto       = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    /* xgettext:c-format */
                    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);

      xfree (reloc);
      
      return NULL;
    }
  
  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT)
    reloc->addend = fixp->fx_offset;
  else
    reloc->addend = fixp->fx_addnumber;
  
  return reloc;
}

/* Assume everything will fit in two bytes, then expand as necessary.  */
int
md_estimate_size_before_relax (fragp, seg)
     fragS * fragp;
     asection * seg;
{
  if (fragp->fr_subtype == 0)
    fragp->fr_var = 4;
  else if (fragp->fr_subtype == 2)
    fragp->fr_var = 2;
  else
    abort ();
  return 2;
} 

long
v850_pcrel_from_section (fixp, section)
     fixS * fixp;
     segT   section;
{
  /* If the symbol is undefined, or in a section other than our own,
     or it is weak (in which case it may well be in another section,
     then let the linker figure it out.  */
  if (fixp->fx_addsy != (symbolS *) NULL
      && (! S_IS_DEFINED (fixp->fx_addsy)
	  || S_IS_WEAK (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != section)))
    return 0;
  
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

int
md_apply_fix3 (fixp, valuep, seg)
     fixS *   fixp;
     valueT * valuep;
     segT     seg;
{
  valueT value;
  char * where;

  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    {
      fixp->fx_done = 0;
      return 1;
    }

  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = * valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    value = * valuep;
  else
    {
      value = fixp->fx_offset;
      if (fixp->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixp->fx_subsy);
	  else
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("expression too complex"));
	    }
	}
    }

  if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int                         opindex;
      const struct v850_operand * operand;
      unsigned long               insn;

      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
      operand = & v850_operands[ opindex ];

      /* Fetch the instruction, insert the fully resolved operand
         value, and stuff the instruction back again.

	 Note the instruction has been stored in little endian
	 format!  */
      where = fixp->fx_frag->fr_literal + fixp->fx_where;

      insn = bfd_getl32 ((unsigned char *) where);
      insn = v850_insert_operand (insn, operand, (offsetT) value,
				  fixp->fx_file, fixp->fx_line, NULL);
      bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);

      if (fixp->fx_done)
	{
	  /* Nothing else to do here. */
	  return 1;
	}

      /* Determine a BFD reloc value based on the operand information.  
	 We are only prepared to turn a few of the operands into relocs. */

      if (operand->bits == 22)
	fixp->fx_r_type = BFD_RELOC_V850_22_PCREL;
      else if (operand->bits == 9)
	fixp->fx_r_type = BFD_RELOC_V850_9_PCREL;
      else
	{
	  /* fprintf (stderr, "bits: %d, insn: %x\n", operand->bits, insn); */
	  
	  as_bad_where (fixp->fx_file, fixp->fx_line,
		       _("unresolved expression that must be resolved"));
	  fixp->fx_done = 1;
	  return 1;
	}
    }
  else if (fixp->fx_done)
    {
      /* We still have to insert the value into memory!  */
      where = fixp->fx_frag->fr_literal + fixp->fx_where;

      if (fixp->fx_size == 1)
	* where = value & 0xff;
      else if (fixp->fx_size == 2)
	bfd_putl16 (value & 0xffff, (unsigned char *) where);
      else if (fixp->fx_size == 4)
	bfd_putl32 (value, (unsigned char *) where);
    }
  
  fixp->fx_addnumber = value;
  return 1;
}


/* Parse a cons expression.  We have to handle hi(), lo(), etc
   on the v850.  */
void
parse_cons_expression_v850 (exp)
  expressionS * exp;
{
  /* See if there's a reloc prefix like hi() we have to handle.  */
  hold_cons_reloc = v850_reloc_prefix (NULL);

  /* Do normal expression parsing.  */
  expression (exp);
}

/* Create a fixup for a cons expression.  If parse_cons_expression_v850
   found a reloc prefix, then we use that reloc, else we choose an
   appropriate one based on the size of the expression.  */
void
cons_fix_new_v850 (frag, where, size, exp)
     fragS * frag;
     int where;
     int size;
     expressionS *exp;
{
  if (hold_cons_reloc == BFD_RELOC_UNUSED)
    {
      if (size == 4)
	hold_cons_reloc = BFD_RELOC_32;
      if (size == 2)
	hold_cons_reloc = BFD_RELOC_16;
      if (size == 1)
	hold_cons_reloc = BFD_RELOC_8;
    }

  if (exp != NULL)
    fix_new_exp (frag, where, size, exp, 0, hold_cons_reloc);
  else
    fix_new (frag, where, size, NULL, 0, 0, hold_cons_reloc);
}

boolean
v850_fix_adjustable (fixP)
    fixS * fixP;
{
  if (fixP->fx_addsy == NULL)
    return 1;
 
  /* Prevent all adjustments to global symbols. */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;
  
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;
  
  /* Don't adjust function names */
  if (S_IS_FUNCTION (fixP->fx_addsy))
    return 0;

  /* We need the symbol name for the VTABLE entries */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;
  
  return 1;
}
 
int
v850_force_relocation (fixP)
      struct fix * fixP;
{
  if (fixP->fx_addsy && S_IS_WEAK (fixP->fx_addsy))
    return 1;
  
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;
 
  return 0;
}
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d24 1
a24 1
#include "subsegs.h"
a25 1
#include "dwarf2dbg.h"
d31 2
a32 2
/* Sign-extend a 16-bit number.  */
#define SEXT16(x)	((((x) & 0xffff) ^ (~0x7fff)) + 0x8000)
d35 1
a35 1
static bfd_reloc_code_real_type hold_cons_reloc = BFD_RELOC_UNUSED;
d42 1
a42 1
static int machine = -1;
d45 2
a46 1
static int processor_mask = -1;
d49 4
a52 3
struct reg_name {
  const char *name;
  int value;
d55 1
a55 2
/* Generic assembler global variables which must be defined by all
   targets.  */
d57 1
a57 1
/* Characters which always start a comment.  */
d63 1
a63 1
/* Characters which may be used to separate multiple commands on a
d67 1
a67 1
/* Characters which are used to indicate an exponent in a floating
d71 1
a71 1
/* Characters which mean that a number is a floating point constant,
d75 3
a77 1
const relax_typeS md_relax_table[] = {
d86 1
d101 1
a101 1
/* Fixups.  */
d103 4
a106 3
struct v850_fixup {
  expressionS exp;
  int opindex;
d110 1
a110 1
struct v850_fixup fixups[MAX_INSN_FIXUPS];
d112 1
d115 1
a115 1
v850_sdata (int ignore ATTRIBUTE_UNUSED)
d117 2
a118 2
  obj_elf_section_change_hook ();

d125 1
a125 1
v850_tdata (int ignore ATTRIBUTE_UNUSED)
d127 2
a128 2
  obj_elf_section_change_hook ();

d130 1
a130 1

d135 1
a135 1
v850_zdata (int ignore ATTRIBUTE_UNUSED)
d137 2
a138 2
  obj_elf_section_change_hook ();

d140 1
a140 1

d145 1
a145 1
v850_sbss (int ignore ATTRIBUTE_UNUSED)
d147 2
a148 2
  obj_elf_section_change_hook ();

d150 1
a150 1

d155 1
a155 1
v850_tbss (int ignore ATTRIBUTE_UNUSED)
d157 2
a158 2
  obj_elf_section_change_hook ();

d160 1
a160 1

d165 1
a165 1
v850_zbss (int ignore ATTRIBUTE_UNUSED)
d167 2
a168 2
  obj_elf_section_change_hook ();

d170 1
a170 1

d175 1
a175 1
v850_rosdata (int ignore ATTRIBUTE_UNUSED)
d177 2
a178 2
  obj_elf_section_change_hook ();

d180 1
a180 1

d185 1
a185 1
v850_rozdata (int ignore ATTRIBUTE_UNUSED)
d187 2
a188 2
  obj_elf_section_change_hook ();

d190 1
a190 1

d195 1
a195 1
v850_call_table_data (int ignore ATTRIBUTE_UNUSED)
d197 2
a198 2
  obj_elf_section_change_hook ();

d200 1
a200 1

d205 1
a205 1
v850_call_table_text (int ignore ATTRIBUTE_UNUSED)
d207 2
a208 2
  obj_elf_section_change_hook ();

d210 1
a210 1

d215 1
a215 1
v850_bss (int ignore ATTRIBUTE_UNUSED)
d219 2
a220 2
  obj_elf_section_change_hook ();

d222 1
a222 1

d227 1
a227 1
v850_offset (int ignore ATTRIBUTE_UNUSED)
d230 3
a232 3

  temp -= frag_now_fix ();

d235 1
a235 1

d239 1
a239 2
/* Copied from obj_elf_common() in gas/config/obj-elf.c.  */

d244 7
a250 7
  char *name;
  char c;
  char *p;
  int temp;
  unsigned int size;
  symbolS *symbolP;
  int have_align;
d254 2
a255 2

  /* Just after name is now '\0'.  */
d258 1
a258 1

d260 1
a260 1

d267 3
a269 4

  /* Skip ','.  */
  input_line_pointer++;

d272 1
a272 1
      /* xgettext:c-format  */
d277 1
a277 1

d282 1
a282 1

d289 1
a289 1

d294 1
a294 1
	  /* xgettext:c-format  */
d299 3
a301 3

  know (symbol_get_frag (symbolP) == &zero_address_frag);

d310 1
a310 1

d318 1
a318 1

d325 1
a325 1

d328 5
a332 5
	  segT old_sec;
	  int old_subsec;
	  char *pfrag;
	  int align;
	  flagword applicable;
d336 1
a336 1

d338 1
a338 1

d340 1
a340 1

d347 1
a347 1

d349 1
a349 1

d353 1
a353 1

d358 1
a358 1

d360 1
a360 1

d364 1
a364 1

d369 1
a369 1

d371 1
a371 1

d379 1
a379 1
	      /* Convert to a power of 2 alignment.  */
d382 1
a382 1

d392 1
a392 1

d397 1
a397 1
	      obj_elf_section_change_hook ();
d403 1
a403 1
	      obj_elf_section_change_hook ();
d409 1
a409 1
	      obj_elf_section_change_hook ();
d414 1
a414 1
	      abort ();
d416 1
a416 1

d440 1
a440 1

d446 1
a446 1

d452 1
a452 1

d456 1
a456 1

d460 1
a460 1

d462 1
a462 1
	      abort ();
d464 1
a464 1

d466 1
a466 1
	  obj_elf_section_change_hook ();
d475 1
a475 1

d481 4
a484 3
		  flagword applicable =
		    bfd_applicable_section_flags (stdoutput);

d486 2
a487 3

		  bfd_set_section_flags (stdoutput, scommon_section,
					 (applicable
d489 1
a489 1
			| SEC_HAS_CONTENTS)) | SEC_IS_COMMON);
d493 1
a493 1

d497 4
a500 3
		  flagword applicable =
		    bfd_applicable_section_flags (stdoutput);

d502 2
a503 3

		  bfd_set_section_flags (stdoutput, zcommon_section,
					 (applicable
d505 1
a505 1
			| SEC_HAS_CONTENTS)) | SEC_IS_COMMON);
d509 1
a509 1

d513 4
a516 3
		  flagword applicable =
		    bfd_applicable_section_flags (stdoutput);

d518 4
a521 7

		  bfd_set_section_flags (stdoutput, tcommon_section,
					 ((applicable
					   & (SEC_ALLOC | SEC_LOAD
					      | SEC_RELOC | SEC_DATA
					      | SEC_HAS_CONTENTS))
					  | SEC_IS_COMMON));
d525 1
a525 1

d527 1
a527 1
	      abort ();
a533 1

a536 1

d579 2
a580 2
    case 0:               processor_mask = PROCESSOR_V850;   break;
    case bfd_mach_v850e:  processor_mask = PROCESSOR_V850E;  break;
d586 2
a587 1
const pseudo_typeS md_pseudo_table[] = {
a606 2
  {"file",    dwarf2_directive_file, 0},
  {"loc",     dwarf2_directive_loc, 0},
d613 3
a615 2
/* This table is sorted.  Suitable for searching by a binary search.  */
static const struct reg_name pre_defined_registers[] = {
d617 3
a619 3
  { "gp",   4 },		/* gp - global ptr  */
  { "hp",   2 },		/* hp - handler stack ptr  */
  { "lp",  31 },		/* lp - link ptr  */
d652 2
a653 2
  { "sp",   3 },		/* sp - stack ptr  */
  { "tp",   5 },		/* tp - text ptr  */
d656 1
a657 2
#define REG_NAME_CNT						\
  (sizeof (pre_defined_registers) / sizeof (struct reg_name))
d659 2
a660 1
static const struct reg_name system_registers[] = {
d673 1
d675 2
a676 4
#define SYSREG_NAME_CNT						\
  (sizeof (system_registers) / sizeof (struct reg_name))

static const struct reg_name system_list_registers[] = {
d680 1
d682 2
a683 4
#define SYSREGLIST_NAME_CNT					\
  (sizeof (system_list_registers) / sizeof (struct reg_name))

static const struct reg_name cc_names[] = {
d707 1
d709 3
a711 6
#define CC_NAME_CNT					\
  (sizeof (cc_names) / sizeof (struct reg_name))

/* Do a binary search of the given register table to see if NAME is a
   valid regiter name.  Return the register number from the array on
   success, or -1 on failure.  */
d715 4
a718 4
     const struct reg_name *regs;
     int regcount;
     const char *name;
     boolean accept_numbers;
d722 1
a722 1
  symbolS *symbolP;
d731 1
a731 2
	  name
	    = S_GET_NAME (symbol_get_value_expression (symbolP)->X_add_symbol);
d736 1
a736 1

d743 1
a743 1

d762 1
d771 2
a772 2
 *	its original state.  */

d775 1
a775 1
     expressionS *expressionP;
d777 4
a780 4
  int reg_number;
  char *name;
  char *start;
  char c;
d782 1
a782 1
  /* Find the spelling of the operand.  */
d790 4
a793 5
  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
d798 1
a798 1
      /* Make the rest nice.  */
d801 1
a801 1

d806 1
a806 1
      /* Reset the line as if we had not done anything.  */
d808 1
a808 1

d815 4
a818 4
 * in:  INPUT_LINE_POINTER points to 1st char of operand.
 *      EXPRESSIONP points to an expression structure to be filled in.
 *      ACCEPT_NUMBERS is true iff numerical register names may be used.
 *      ACCEPT_LIST_NAMES is true iff the special names PS and SR may be
d825 2
a826 2
 *	its original state.  */

d829 8
a836 8
     expressionS *expressionP;
     boolean accept_numbers;
     boolean accept_list_names;
{
  int reg_number;
  char *name;
  char *start;
  char c;
d838 1
a838 1
  /* Find the spelling of the operand.  */
d845 2
a846 3
  /* Put back the delimiting char.  */
  *input_line_pointer = c;

d850 1
a850 2
      /* Reset input_line pointer.  */
      input_line_pointer = start;
d852 1
a852 1
      if (isdigit (*input_line_pointer))
d854 1
a854 1
	  reg_number = strtol (input_line_pointer, &input_line_pointer, 10);
d856 6
a861 4
	  /* Make sure that the register number is allowable.  */
	  if (reg_number < 0
	      || (reg_number > 5 && reg_number < 16)
	      || reg_number > 20)
d872 1
a872 2
	  /* Put back the delimiting char.  */
	  *input_line_pointer = c;
d875 3
a877 3

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
d882 1
a882 1
      /* Make the rest nice.  */
d890 1
a890 1
      /* Reset the line as if we had not done anything.  */
d892 1
a892 1

d899 1
a899 1
 * in: INPUT_LINE_POINTER points to 1st char of operand.
d905 2
a906 2
 *	its original state.  */

d909 1
a909 1
     expressionS *expressionP;
d911 4
a914 4
  int reg_number;
  char *name;
  char *start;
  char c;
d916 1
a916 1
  /* Find the spelling of the operand.  */
d922 4
a925 5
  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
d930 1
a930 1
      /* Make the rest nice.  */
d938 1
a938 1
      /* Reset the line as if we had not done anything.  */
d940 1
a940 1

d948 3
a950 3
  while (*input_line_pointer == ' '
	 || *input_line_pointer == '\t')
    ++input_line_pointer;
d955 3
a957 3
 * in: INPUT_LINE_POINTER  points to 1st char of a list of registers.
 *     INSN                is the partially constructed instruction.
 *     OPERAND             is the operand being inserted.
d976 3
a978 2
 * high numbers.  */

d980 10
a989 17
parse_register_list (insn, operand)
     unsigned long *insn;
     const struct v850_operand *operand;
{
  static int type1_regs[32] = {
    30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24
  };
  static int type2_regs[32] = {
    19, 18, 17, 16,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0, 30, 31, 29, 28, 23, 22, 21, 20, 27, 26, 25, 24
  };
  static int type3_regs[32] = {
     3,  2,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0, 14, 15, 13, 12,  7,  6,  5,  4, 11, 10,  9,  8
  };
  int *regs;
d992 2
a993 1
  /* Select a register array to parse.  */
d1009 2
a1010 2

  if (*input_line_pointer != '{')
d1012 1
d1015 3
a1017 3

      expression (&exp);

d1025 2
a1026 2

	  for (reg = 20; reg < 32; reg++)
d1031 1
a1031 1
		    *insn |= (1 << i);
d1038 2
a1039 2

	  for (reg = 1; reg < 16; reg++)
d1044 1
a1044 1
		    *insn |= (1 << i);
d1048 2
a1049 2
	    *insn |= (1 << 3);

d1051 1
a1051 1
	    *insn |= (1 << 19);
d1053 1
a1053 1
      else /* regs == type3_regs  */
d1057 2
a1058 2

	  for (reg = 16; reg < 32; reg++)
d1063 1
a1063 1
		    *insn |= (1 << i);
d1067 1
a1067 1
	    *insn |= (1 << 19);
d1073 1
a1073 1
  input_line_pointer++;
d1079 1
a1079 1
      if (register_name (&exp))
d1081 2
a1082 2
	  int i;

d1087 1
a1087 1
	      if (regs[i] == exp.X_add_number)
d1089 1
a1089 1
		  *insn |= (1 << i);
d1099 1
a1099 1
      else if (system_register_name (&exp, true, true))
d1110 1
a1110 1
		*insn |= 0x8;
d1113 1
a1113 1
	    *insn |= 0x80000;
d1117 1
a1117 1
      else if (*input_line_pointer == '}')
d1119 1
a1119 1
	  input_line_pointer++;
d1122 1
a1122 1
      else if (*input_line_pointer == ',')
d1124 1
a1124 1
	  input_line_pointer++;
d1127 1
a1127 1
      else if (*input_line_pointer == '-')
d1129 2
a1130 2
	  /* We have encountered a range of registers: rX - rY.  */
	  int j;
d1134 1
a1134 1
	  ++input_line_pointer;
d1137 1
a1137 1
	  if (! register_name (&exp2))
d1146 2
a1147 2
	      int i;

d1152 1
a1152 1
		  if (regs[i] == j)
d1154 1
a1154 1
		      *insn |= (1 << i);
d1174 1
a1174 1
CONST char *md_shortopts = "m:";
d1176 2
a1177 1
struct option md_longopts[] = {
d1180 1
a1181 1
size_t md_longopts_size = sizeof (md_longopts);
d1185 1
a1185 1
     FILE *stream;
d1198 2
a1199 2
     int c;
     char *arg;
d1203 2
a1204 3
      if (c != 'a')
	/* xgettext:c-format  */
	fprintf (stderr, _("unknown command line option: -%c%s\n"), c, arg);
d1233 2
a1234 5
      /* Tell the world that this is for any v850 chip.  */
      machine = 0;

      /* But support instructions for the extended versions.  */
      processor_mask = PROCESSOR_V850EA;
d1238 1
a1238 1
      /* xgettext:c-format  */
d1242 1
a1242 1

d1248 1
a1248 1
     char *name ATTRIBUTE_UNUSED;
d1255 3
a1257 3
     int type;
     char *litp;
     int *sizep;
d1259 1
a1259 1
  int prec;
d1261 2
a1262 2
  char *t;
  int i;
d1278 1
a1278 1

d1294 1
a1295 1

d1298 3
a1300 3
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     fragS *fragP;
d1303 1
a1303 1

d1309 1
d1315 1
a1315 1
      unsigned char *buffer =
d1333 1
d1343 1
d1352 2
a1353 2
     asection *seg;
     valueT addr;
d1362 3
a1364 3
  char *prev_name = "";
  register const struct v850_opcode *op;
  flagword applicable;
d1370 1
a1370 1

d1377 2
a1378 2
	machine = bfd_mach_v850e;

d1382 2
a1383 1
  else if (strncmp (TARGET_CPU, "v850", 4) == 0)
d1386 2
a1387 2
	machine = 0;

d1392 2
a1393 2
    /* xgettext:c-format  */
    as_bad (_("Unable to determine default target processor from string: %s"),
d1396 1
a1396 1
  v850_hash = hash_new ();
d1406 1
a1406 1
      if (strcmp (prev_name, op->name))
d1417 1
a1417 1

d1422 1
a1422 1

d1427 1
a1427 1

d1432 1
d1434 1
a1434 1
handle_ctoff (const struct v850_operand *operand)
d1439 1
a1439 1
  if (operand->bits != 6
d1445 1
a1445 1

d1450 1
a1450 1
handle_sdaoff (const struct v850_operand *operand)
d1452 5
a1456 10
  if (operand == NULL)
    return BFD_RELOC_V850_SDA_16_16_OFFSET;

  if (operand->bits == 15 && operand->shift == 17)
    return BFD_RELOC_V850_SDA_15_16_OFFSET;

  if (operand->bits == -1)
    return BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET;

  if (operand->bits != 16
d1462 1
a1462 1

d1467 1
a1467 1
handle_zdaoff (const struct v850_operand *operand)
d1469 3
a1471 5
  if (operand == NULL)
    return BFD_RELOC_V850_ZDA_16_16_OFFSET;

  if (operand->bits == 15 && operand->shift == 17)
    return BFD_RELOC_V850_ZDA_15_16_OFFSET;
d1473 1
a1473 4
  if (operand->bits == -1)
    return BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET;

  if (operand->bits != 16
d1477 1
a1477 2
      /* Used to indicate an error condition.  */
      return BFD_RELOC_64;
d1479 1
a1479 1

d1484 1
a1484 1
handle_tdaoff (const struct v850_operand *operand)
d1486 6
a1491 20
  if (operand == NULL)
    /* Data item, not an instruction.  */
    return BFD_RELOC_V850_TDA_7_7_OFFSET;

  if (operand->bits == 6 && operand->shift == 1)
    /* sld.w/sst.w, operand: D8_6  */
    return BFD_RELOC_V850_TDA_6_8_OFFSET;

  if (operand->bits == 4 && operand->insert != NULL)
    /* sld.hu, operand: D5-4  */
    return BFD_RELOC_V850_TDA_4_5_OFFSET;

  if (operand->bits == 4 && operand->insert == NULL)
    /* sld.bu, operand: D4   */
    return BFD_RELOC_V850_TDA_4_4_OFFSET;

  if (operand->bits == 16 && operand->shift == 16)
    /* set1 & chums, operands: D16  */
    return BFD_RELOC_V850_TDA_16_16_OFFSET;

d1495 1
a1495 2
      /* Used to indicate an error condition.  */
      return BFD_RELOC_64;
d1497 1
a1497 1

d1499 2
a1500 2
    ? BFD_RELOC_V850_TDA_7_8_OFFSET     /* sld.h/sst.h, operand: D8_7  */
    : BFD_RELOC_V850_TDA_7_7_OFFSET;    /* sld.b/sst.b, opreand: D7    */
d1508 1
a1508 1
v850_reloc_prefix (const struct v850_operand *operand)
d1512 1
d1514 1
a1514 1
  if (*input_line_pointer == '(')
d1516 1
a1516 1
      ++input_line_pointer;
d1526 4
a1529 4

  CHECK_ ("hi0",    BFD_RELOC_HI16         );
  CHECK_ ("hi",     BFD_RELOC_HI16_S       );
  CHECK_ ("lo",     BFD_RELOC_LO16         );
d1533 3
a1535 3
  CHECK_ ("hilo",   BFD_RELOC_32           );
  CHECK_ ("ctoff",  handle_ctoff (operand) );

d1538 2
a1539 2
    --input_line_pointer;

d1547 6
a1552 6
     unsigned long insn;
     const struct v850_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
     char *str;
d1556 3
a1558 3
      const char *message = NULL;

      insn = operand->insert (insn, val, &message);
d1565 1
a1565 1
	      /* Skip warning...  */
d1571 1
a1571 1
	      /* Skip warning...  */
d1593 2
a1594 1
	  long min, max;
d1602 2
a1603 2

	      min = -(1 << (operand->bits - 1));
d1608 1
a1608 1

d1610 1
a1610 1
		min = -(1 << (operand->bits - 1));
d1614 1
a1614 1

d1617 4
a1620 5
	      /* xgettext:c-format  */
	      const char *err =
		_("operand out of range (%s not between %ld and %ld)");
	      char buf[100];

d1633 1
a1633 1

d1638 1
a1638 1

d1648 1
a1648 1

d1651 1
d1653 1
a1653 1
static char copy_of_instruction[128];
d1656 2
a1657 2
md_assemble (str)
     char *str;
d1659 16
a1674 16
  char *s;
  char *start_of_operands;
  struct v850_opcode *opcode;
  struct v850_opcode *next_opcode;
  const unsigned char *opindex_ptr;
  int next_opindex;
  int relaxable = 0;
  unsigned long insn;
  unsigned long insn_size;
  char *f;
  int i;
  int match;
  boolean extra_data_after_insn = false;
  unsigned extra_data_len = 0;
  unsigned long extra_data = 0;
  char *saved_input_line_pointer;
d1676 1
d1678 1
a1678 1

d1682 1
a1682 1

d1686 1
a1686 1
  /* Find the first opcode with the proper name.  */
d1690 1
a1690 1
      /* xgettext:c-format  */
d1697 2
a1698 2
  while (isspace (*str))
    ++str;
d1703 1
a1703 1

d1706 1
a1706 1
      const char *errmsg = NULL;
d1709 1
a1709 1

d1715 1
a1715 1

d1724 1
a1724 1
      for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
d1726 4
a1729 4
	  const struct v850_operand *operand;
	  char *hold;
	  expressionS ex;
	  bfd_reloc_code_real_type reloc;
d1733 1
a1733 1
	      operand = &v850_operands[*opindex_ptr];
d1737 1
a1737 1
	      operand = &v850_operands[next_opindex];
d1744 1
a1744 1
	    ++str;
d1749 1
a1749 1
	  /* Gather the operand.  */
d1752 2
a1753 2

	  /* lo(), hi(), hi0(), etc...  */
d1762 2
a1763 2

	      expression (&ex);
d1773 1
a1773 1

d1791 1
a1791 1
			int temp = (ex.X_add_number >> 16) & 0xffff;
d1798 1
a1798 1

d1805 1
a1805 1

d1811 1
a1811 1

d1820 4
a1823 4

		  fixups[fc].exp     = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc   = reloc;
d1835 1
a1835 1

d1840 1
a1840 1

d1844 3
a1846 3
		  fixups[fc].exp     = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc   = reloc;
d1853 2
a1854 2

	      if ((operand->flags & V850_OPERAND_REG) != 0)
d1856 1
a1856 1
		  if (!register_name (&ex))
d1861 1
a1861 1
			   && ex.X_add_number == 0)
d1864 1
a1864 1

d1871 1
a1871 1
	      else if ((operand->flags & V850_OPERAND_SRG) != 0)
d1873 1
a1873 1
		  if (!system_register_name (&ex, true, false))
d1880 3
a1882 3
		  char *start = input_line_pointer;
		  char c = get_symbol_end ();

d1891 1
a1891 1

d1895 3
a1897 4

		  while (*str == ' ' || *str == ','
			 || *str == '[' || *str == ']')
		    ++str;
d1900 1
a1900 1
	      else if ((operand->flags & V850_OPERAND_CC) != 0)
d1902 1
a1902 1
		  if (!cc_name (&ex))
d1907 1
a1907 1
	      else if (operand->flags & V850E_PUSH_POP)
d1909 2
a1910 2
		  errmsg = parse_register_list (&insn, operand);

d1916 1
a1916 1
	      else if (operand->flags & V850E_IMMEDIATE16)
d1918 1
a1918 1
		  expression (&ex);
d1931 1
a1931 1

d1937 1
a1937 1
	      else if (operand->flags & V850E_IMMEDIATE32)
d1939 2
a1940 2
		  expression (&ex);

d1943 1
a1943 1

d1949 1
a1949 1
	      else if (register_name (&ex)
d1953 2
a1954 2
		  int exists = 0;

d1965 1
a1965 1

d1968 2
a1969 2

		  *input_line_pointer = c;
d1971 2
a1972 2

		  expression (&ex);
d1980 1
a1980 2
			  && (v850_operands[opindex_ptr[1]].flags
			      & V850_OPERAND_REG))
d1985 3
a1987 3
		      /* If we created a symbol in the process of this
			 test then delete it now, so that it will not
			 be output with the real symbols...  */
d1991 1
a1991 1
				       &symbol_rootP, &symbol_lastP);
d1994 1
a1994 1
	      else if (system_register_name (&ex, false, false)
d2006 1
a2006 1
		  expression (&ex);
d2016 1
a2016 1
		      && (ex.X_add_number < (-(1 << (operand->bits - 1)))
d2023 3
d2027 1
a2027 8
#if 0
	      fprintf (stderr,
		       " insn: %x, operand %d, op: %d, add_number: %d\n",
		       insn, opindex_ptr - opcode->operands,
		       ex.X_op, ex.X_add_number);
#endif

	      switch (ex.X_op)
d2036 1
a2036 2
		  if ((operand->flags
		       & (V850_OPERAND_REG | V850_OPERAND_SRG)) == 0)
d2057 3
a2059 3
		  fixups[fc].exp     = ex;
		  fixups[fc].opindex = *opindex_ptr;
		  fixups[fc].reloc   = BFD_RELOC_UNUSED;
d2076 1
a2076 1
	{
d2087 1
a2087 1

d2090 1
a2090 1

d2092 4
a2095 4

	  if (*input_line_pointer == ']')
	    ++input_line_pointer;

d2099 1
a2099 1
	}
d2102 1
a2102 1

d2107 1
a2107 1
    /* xgettext:c-format  */
d2112 2
a2113 7
  /* Tie dwarf2 debug info to the address at the start of the insn.
     We can't do this after the insn has been output as the current
     frag may have been closed off.  eg. by frag_var.  */
  dwarf2_emit_insn (0);

  /* Write out the instruction.  */

d2124 1
a2124 1
			(char *) fixups[0].opindex);
d2133 1
a2133 1
			(char *) fixups[0].opindex);
d2138 1
a2138 1
  else
d2146 1
a2146 1
      /* Special case: 32 bit MOV.  */
d2149 1
a2149 1

d2151 1
d2157 1
d2169 1
a2169 1
     md_apply_fix.  */
d2172 4
a2175 4
      const struct v850_operand *operand;
      bfd_reloc_code_real_type reloc;

      operand = &v850_operands[fixups[i].opindex];
d2178 1
a2178 1

d2181 5
a2185 5
	  reloc_howto_type *reloc_howto =
	    bfd_reloc_type_lookup (stdoutput, reloc);
	  int size;
	  int address;
	  fixS *fixP;
d2188 2
a2189 2
	    abort ();

d2193 2
a2194 2
	     is this reloc actually used?  */
	  if (size != 2 && size != 4)
d2200 4
a2203 2
	    address += 2;

d2205 1
a2205 1
			      &fixups[i].exp,
a2215 2
	    default:
	      break;
d2220 2
a2221 1
	  fix_new_exp (frag_now,
d2224 1
a2224 1
		       1 /* FIXME: V850_OPERAND_RELATIVE ???  */,
d2226 2
a2227 1
						   + (int) BFD_RELOC_UNUSED));
a2233 2
/* If while processing a fixup, a reloc really needs to be created
   then it is done here.  */
d2235 3
d2240 2
a2241 2
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d2243 7
a2249 7
  arelent *reloc;

  reloc               = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr  = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address      = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto        = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
d2254 2
a2255 2
		    /* xgettext:c-format  */
		    _("reloc %d not supported by object file format"),
d2259 1
a2259 1

d2262 2
a2263 2

  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
d2268 1
a2268 1

d2272 1
a2272 2
/* Return current size of variable part of frag.  */

d2275 2
a2276 2
     fragS *fragp;
     asection *seg ATTRIBUTE_UNUSED;
d2278 5
a2282 1
  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
d2284 2
a2285 3

  return md_relax_table[fragp->fr_subtype].rlx_length;
}
d2289 2
a2290 2
     fixS *fixp;
     segT section;
d2300 1
a2300 1

d2306 3
a2308 3
     fixS *fixp;
     valueT *valuep;
     segT seg ATTRIBUTE_UNUSED;
d2311 1
a2311 1
  char *where;
d2313 1
a2313 1
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d2322 1
a2322 1
      value = *valuep;
d2326 1
a2326 1
    value = *valuep;
d2345 3
a2347 3
      int opindex;
      const struct v850_operand *operand;
      unsigned long insn;
d2350 1
a2350 1
      operand = &v850_operands[opindex];
d2366 1
a2366 1
	  /* Nothing else to do here.  */
d2370 2
a2371 2
      /* Determine a BFD reloc value based on the operand information.
	 We are only prepared to turn a few of the operands into relocs.  */
d2379 2
a2380 4
#if 0
	  fprintf (stderr, "bits: %d, insn: %x\n", operand->bits, insn);
#endif

d2382 1
a2382 1
			_("unresolved expression that must be resolved"));
d2393 1
a2393 1
	*where = value & 0xff;
d2399 1
a2399 1

d2403 1
a2406 1

d2409 1
a2409 1
     expressionS *exp;
a2420 1

d2423 1
a2423 1
     fragS *frag;
a2441 2

  hold_cons_reloc = BFD_RELOC_UNUSED;
d2446 1
a2446 1
     fixS *fixP;
d2450 2
a2451 2

  /* Prevent all adjustments to global symbols.  */
d2454 1
a2454 2

  /* Similarly for weak symbols.  */
d2457 2
a2458 2

  /* Don't adjust function names.  */
d2462 2
a2463 2
  /* We need the symbol name for the VTABLE entries.  */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d2466 1
a2466 1

d2469 1
a2469 1

d2472 1
a2472 1
     struct fix *fixP;
d2476 2
a2477 2

  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
d2480 1
a2480 1

@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d23 1
a24 1
#include "safe-ctype.h"
d29 4
d40 2
a41 2
static bfd_boolean warn_signed_overflows   = FALSE;
static bfd_boolean warn_unsigned_overflows = FALSE;
d85 13
a97 1
static int  v850_relax = 0;
d109 20
d130 2
a131 1
struct v850_seg_entry
d133 16
a148 4
  segT s;
  const char *name;
  flagword flags;
};
d150 2
a151 1
struct v850_seg_entry v850_seg_table[] =
d153 6
a158 36
  { NULL, ".sdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
    | SEC_SMALL_DATA },
  { NULL, ".tdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS },
  { NULL, ".zdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS },
  { NULL, ".sbss",
    SEC_ALLOC | SEC_SMALL_DATA },
  { NULL, ".tbss",
    SEC_ALLOC },
  { NULL, ".zbss",
    SEC_ALLOC},
  { NULL, ".rosdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_DATA
    | SEC_HAS_CONTENTS | SEC_SMALL_DATA },
  { NULL, ".rozdata",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_DATA
    | SEC_HAS_CONTENTS },
  { NULL, ".scommon",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
    | SEC_SMALL_DATA | SEC_IS_COMMON },
  { NULL, ".tcommon",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
    | SEC_IS_COMMON },
  { NULL, ".zcommon",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
    | SEC_IS_COMMON },
  { NULL, ".call_table_data",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS },
  { NULL, ".call_table_text",
    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_CODE
    | SEC_HAS_CONTENTS},
  { NULL, ".bss",
    SEC_ALLOC }
};
d160 4
a163 14
#define SDATA_SECTION		0
#define TDATA_SECTION		1
#define ZDATA_SECTION		2
#define SBSS_SECTION		3
#define TBSS_SECTION		4
#define ZBSS_SECTION		5
#define ROSDATA_SECTION		6
#define ROZDATA_SECTION		7
#define SCOMMON_SECTION		8
#define TCOMMON_SECTION		9
#define ZCOMMON_SECTION		10
#define CALL_TABLE_DATA_SECTION	11
#define CALL_TABLE_TEXT_SECTION	12
#define BSS_SECTION		13
d165 1
a165 1
static void do_v850_seg PARAMS ((int, subsegT));
d167 5
a171 4
static void
do_v850_seg (i, sub)
     int i;
     subsegT sub;
d173 6
a178 1
  struct v850_seg_entry *seg = v850_seg_table + i;
d180 3
d184 4
a187 11
  if (seg->s != NULL)
    {
      subseg_set (seg->s, sub);
    }
  else
    {
      seg->s = subseg_new (seg->name, sub);
      bfd_set_section_flags (stdoutput, seg->s, seg->flags);
      if ((seg->flags & SEC_LOAD) == 0)
	seg_info (seg->s)->bss = 1;
    }
d190 6
a195 1
static void v850_seg PARAMS ((int i));
d197 5
a201 3
static void
v850_seg (i)
     int i;
d203 3
a205 1
  subsegT sub = get_absolute_expression ();
a206 1
  do_v850_seg (i, sub);
d210 11
a220 1
static void v850_offset PARAMS ((int));
d222 2
a223 3
static void
v850_offset (ignore)
     int ignore ATTRIBUTE_UNUSED;
a224 1
  char *pfrag;
d226 5
a230 4
   
  pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, (symbolS *)0,
                       (offsetT) temp, (char *) 0);
  *pfrag = 0;
a236 2
static void v850_comm PARAMS ((int));

d341 9
a349 2
	    case SCOMMON_SECTION:
	      do_v850_seg (SBSS_SECTION, 0);
d352 9
a360 2
	    case ZCOMMON_SECTION:
	      do_v850_seg (ZBSS_SECTION, 0);
d363 9
a371 2
	    case TCOMMON_SECTION:
	      do_v850_seg (TBSS_SECTION, 0);
d391 23
a413 1
	  record_alignment (now_seg, align);
d420 2
a421 2
	    case SCOMMON_SECTION:
	      if (S_GET_SEGMENT (symbolP) == v850_seg_table[SBSS_SECTION].s)
d425 2
a426 2
	    case ZCOMMON_SECTION:
	      if (S_GET_SEGMENT (symbolP) == v850_seg_table[ZBSS_SECTION].s)
d430 2
a431 2
	    case TCOMMON_SECTION:
	      if (S_GET_SEGMENT (symbolP) == v850_seg_table[TBSS_SECTION].s)
d447 2
a448 2
	    case SCOMMON_SECTION:
	      S_SET_SEGMENT (symbolP, v850_seg_table[SBSS_SECTION].s);
d451 2
a452 2
	    case ZCOMMON_SECTION:
	      S_SET_SEGMENT (symbolP, v850_seg_table[ZBSS_SECTION].s);
d455 2
a456 2
	    case TCOMMON_SECTION:
	      S_SET_SEGMENT (symbolP, v850_seg_table[TBSS_SECTION].s);
a468 3
          segT   old_sec;
          int    old_subsec;

a469 3
          old_sec = now_seg;
          old_subsec = now_subseg;

d476 48
a523 5
	    case SCOMMON_SECTION:
	    case ZCOMMON_SECTION:
	    case TCOMMON_SECTION:
	      do_v850_seg (area, 0);
	      S_SET_SEGMENT (symbolP, v850_seg_table[area].s);
a528 3

	  obj_elf_section_change_hook ();
	  subseg_set (old_sec, old_subsec);
d573 2
a574 5
static void set_machine PARAMS ((int));

static void
set_machine (number)
     int number;
d583 1
a586 36
static void v850_longcode PARAMS ((int));

static void
v850_longcode (type)
     int type;
{
  expressionS ex;

  if (! v850_relax)
    {
      if (type == 1)
	as_warn (".longcall pseudo-op seen when not relaxing");
      else
	as_warn (".longjump pseudo-op seen when not relaxing");	
    }

  expression (&ex);

  if (ex.X_op != O_symbol || ex.X_add_number != 0)
    {
      as_bad ("bad .longcall format");
      ignore_rest_of_line ();

      return;
    }

  if (type == 1) 
    fix_new_exp (frag_now, frag_now_fix (), 4, & ex, 1,
		 BFD_RELOC_V850_LONGCALL);
  else
    fix_new_exp (frag_now, frag_now_fix (), 4, & ex, 1,
		 BFD_RELOC_V850_LONGJUMP);

  demand_empty_rest_of_line ();
}

d588 23
a610 25
const pseudo_typeS md_pseudo_table[] =
{
  { "sdata",		v850_seg,		SDATA_SECTION		},
  { "tdata",		v850_seg,		TDATA_SECTION		},
  { "zdata",		v850_seg,		ZDATA_SECTION		},
  { "sbss",		v850_seg,		SBSS_SECTION		},
  { "tbss",		v850_seg,		TBSS_SECTION		},
  { "zbss",		v850_seg,		ZBSS_SECTION		},
  { "rosdata",		v850_seg,		ROSDATA_SECTION 	},
  { "rozdata",		v850_seg,		ROZDATA_SECTION 	},
  { "bss",		v850_seg,		BSS_SECTION		},
  { "offset",		v850_offset,		0			},
  { "word",		cons,			4			},
  { "zcomm",		v850_comm,		ZCOMMON_SECTION 	},
  { "scomm",		v850_comm,		SCOMMON_SECTION 	},
  { "tcomm",		v850_comm,		TCOMMON_SECTION 	},
  { "v850",		set_machine,		0			},
  { "call_table_data",	v850_seg,		CALL_TABLE_DATA_SECTION	},
  { "call_table_text",	v850_seg,		CALL_TABLE_TEXT_SECTION	},
  { "v850e",		set_machine,		bfd_mach_v850e		},
  { "file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  { "loc",		dwarf2_directive_loc,	0			},
  { "longcall",         v850_longcode,          1                       },
  { "longjump",         v850_longcode,          2                       },
  { NULL,		NULL,			0			}
d617 1
a617 2
static const struct reg_name pre_defined_registers[] =
{
d662 1
a662 8
static const struct reg_name system_registers[] =
{
  { "asid",  23 },
  { "bpc",   22 },
  { "bpav",  24 },
  { "bpam",  25 },
  { "bpdv",  26 },
  { "bpdm",  27 },
a667 1
  { "dir",   21 },
d679 1
a679 2
static const struct reg_name system_list_registers[] =
{
d687 1
a687 2
static const struct reg_name cc_names[] =
{
a718 3
static int reg_name_search
  PARAMS ((const struct reg_name *, int, const char *, bfd_boolean));

d724 1
a724 1
     bfd_boolean accept_numbers;
d770 8
a777 8
  
   in: Input_line_pointer points to 1st char of operand.
  
   out: An expressionS.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */
d779 1
a779 3
static bfd_boolean register_name PARAMS ((expressionS *));

static bfd_boolean
d809 1
a809 1
      return TRUE;
d816 1
a816 1
      return FALSE;
d821 12
a832 15
  
   in:  INPUT_LINE_POINTER points to 1st char of operand.
        EXPRESSIONP points to an expression structure to be filled in.
        ACCEPT_NUMBERS is true iff numerical register names may be used.
        ACCEPT_LIST_NAMES is true iff the special names PS and SR may be
        accepted.
  
   out: An expressionS structure in expressionP.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */

static bfd_boolean system_register_name
  PARAMS ((expressionS *, bfd_boolean, bfd_boolean));
d834 1
a834 1
static bfd_boolean
d837 2
a838 2
     bfd_boolean accept_numbers;
     bfd_boolean accept_list_names;
d861 1
a861 1
      if (ISDIGIT (*input_line_pointer))
d868 1
a868 1
	      || reg_number > 27)
d894 1
a894 1
      return TRUE;
d901 1
a901 1
      return FALSE;
d906 8
a913 8
  
   in: INPUT_LINE_POINTER points to 1st char of operand.
  
   out: An expressionS.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */
d915 1
a915 3
static bfd_boolean cc_name PARAMS ((expressionS *));

static bfd_boolean
d943 1
a943 1
      return TRUE;
d950 1
a950 1
      return FALSE;
a953 2
static void skip_white_space PARAMS ((void));

d955 1
a955 1
skip_white_space ()
d963 23
a985 26
  
   in: INPUT_LINE_POINTER  points to 1st char of a list of registers.
       INSN                is the partially constructed instruction.
       OPERAND             is the operand being inserted.
  
   out: NULL if the parse completed successfully, otherwise a
        pointer to an error message is returned.  If the parse
        completes the correct bit fields in the instruction
        will be filled in.
  
   Parses register lists with the syntax:
  
     { rX }
     { rX, rY }
     { rX - rY }
     { rX - rY, rZ }
     etc
  
   and also parses constant epxressions whoes bits indicate the
   registers in the lists.  The LSB in the expression refers to
   the lowest numbered permissable register in the register list,
   and so on upwards.  System registers are considered to be very
   high numbers.  */

static char *parse_register_list
  PARAMS ((unsigned long *, const struct v850_operand *));
d1023 1
d1108 3
a1110 1
	    return _("illegal register included in list");
d1112 1
a1112 1
      else if (system_register_name (&exp, TRUE, TRUE))
d1177 3
a1179 1
	break;
d1187 1
a1187 1
const char *md_shortopts = "m:";
d1204 1
a1205 2
  fprintf (stream, _("  -mrelax                   Enable relaxation\n"));
  
d1239 5
d1250 1
a1250 1
      processor_mask = PROCESSOR_V850E;
a1251 2
  else if (strcmp (arg, "relax") == 0)
    v850_relax = 1;
d1376 2
a1377 1
  const struct v850_opcode *op;
d1379 9
a1387 1
  if (strncmp (TARGET_CPU, "v850e", 5) == 0)
d1414 1
a1425 1
  v850_seg_table[BSS_SECTION].s = bss_section;
d1427 15
a1443 3
static bfd_reloc_code_real_type handle_ctoff
  PARAMS ((const struct v850_operand *));

d1445 1
a1445 2
handle_ctoff (operand)
     const struct v850_operand *operand;
a1459 3
static bfd_reloc_code_real_type handle_sdaoff
  PARAMS ((const struct v850_operand *));

d1461 1
a1461 2
handle_sdaoff (operand)
     const struct v850_operand *operand;
a1481 3
static bfd_reloc_code_real_type handle_zdaoff
  PARAMS ((const struct v850_operand *));

d1483 1
a1483 2
handle_zdaoff (operand)
     const struct v850_operand *operand;
a1504 3
static bfd_reloc_code_real_type handle_tdaoff
  PARAMS ((const struct v850_operand *));

d1506 1
a1506 2
handle_tdaoff (operand)
     const struct v850_operand *operand;
a1543 3
static bfd_reloc_code_real_type v850_reloc_prefix
  PARAMS ((const struct v850_operand *));

d1545 1
a1545 2
v850_reloc_prefix (operand)
     const struct v850_operand *operand;
d1547 1
a1547 1
  bfd_boolean paren_skipped = FALSE;
d1553 1
a1553 1
      paren_skipped = TRUE;
d1557 1
a1557 1
  if (strncmp (input_line_pointer, name "(", strlen (name) + 1) == 0)	\
a1580 4
static unsigned long v850_insert_operand
  PARAMS ((unsigned long, const struct v850_operand *, offsetT, char *,
	   unsigned int, char *));

d1706 1
a1706 1
  bfd_boolean extra_data_after_insn = FALSE;
d1714 1
a1714 1
  for (s = str; *s != '\0' && ! ISSPACE (*s); s++)
d1731 1
a1731 1
  while (ISSPACE (*str))
d1754 1
a1754 1
      extra_data_after_insn = FALSE;
d1840 1
a1840 1
		      extra_data_after_insn = TRUE;
d1842 2
a1843 1
		      extra_data            = 0;
d1870 1
a1870 1
		      extra_data_after_insn = TRUE;
d1907 1
a1907 1
		  if (!system_register_name (&ex, TRUE, FALSE))
d1967 1
a1967 1
		  extra_data_after_insn = TRUE;
d1979 1
a1979 1
		  extra_data_after_insn = TRUE;
d2030 1
a2030 1
	      else if (system_register_name (&ex, FALSE, FALSE)
d2044 5
a2048 4
		     If we are assembling a MOV instruction and the immediate
		     value does not fit into the bits available then create a
		     fake error so that the next MOV instruction will be
		     selected.  This one has a 32 bit immediate field.  */
a2050 1
		      && operand->bits == 5 /* Do not match the CALLT instruction.  */
d2053 1
a2053 1
			  || ex.X_add_number > ((1 << (operand->bits - 1)) - 1)))
d2144 1
a2144 1
  while (ISSPACE (*str))
d2204 1
a2204 1
	  extra_data_after_insn = FALSE;
d2213 1
a2213 1
     md_apply_fix3.  */
a2289 16

  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_V850_LONGCALL
      || fixp->fx_r_type == BFD_RELOC_V850_LONGJUMP
      || fixp->fx_r_type == BFD_RELOC_V850_ALIGN)
    reloc->addend = fixp->fx_offset;
  else
    {
      if (fixp->fx_r_type == BFD_RELOC_32
	  && fixp->fx_pcrel)
	fixp->fx_r_type = BFD_RELOC_32_PCREL;

      reloc->addend = fixp->fx_addnumber;
    }

d2304 6
a2312 16
void
v850_handle_align (frag)
     fragS * frag;
{
  if (v850_relax
      && frag->fr_type == rs_align
      && frag->fr_address + frag->fr_fix > 0
      && frag->fr_offset > 1
      && now_seg != bss_section
      && now_seg != v850_seg_table[SBSS_SECTION].s
      && now_seg != v850_seg_table[TBSS_SECTION].s
      && now_seg != v850_seg_table[ZBSS_SECTION].s)
    fix_new (frag, frag->fr_fix, 2, & abs_symbol, frag->fr_offset, 0,
           BFD_RELOC_V850_ALIGN);
}

d2343 4
a2346 4
void
md_apply_fix3 (fixP, valueP, seg)
     fixS *fixP;
     valueT *valueP;
d2349 1
a2349 1
  valueT value = * valueP;
d2352 2
a2353 4
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_V850_LONGCALL
      || fixP->fx_r_type == BFD_RELOC_V850_LONGJUMP
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
d2355 2
a2356 2
      fixP->fx_done = 0;
      return;
d2359 7
a2365 7
  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_addnumber = value,
    fixP->fx_done = 1;

  else if (fixP->fx_pcrel)
    fixP->fx_addnumber = fixP->fx_offset;

d2368 2
a2369 2
      value = fixP->fx_offset;
      if (fixP->fx_subsy != (symbolS *) NULL)
d2371 2
a2372 2
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
d2376 1
a2376 1
	      as_bad_where (fixP->fx_file, fixP->fx_line,
a2379 1
      fixP->fx_addnumber = value;
d2382 1
a2382 1
  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
d2388 1
a2388 1
      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
d2396 1
a2396 1
      where = fixP->fx_frag->fr_literal + fixP->fx_where;
d2400 1
a2400 1
				  fixP->fx_file, fixP->fx_line, NULL);
d2403 5
a2407 3
      if (fixP->fx_done)
	/* Nothing else to do here.  */
	return;
d2413 1
a2413 1
	fixP->fx_r_type = BFD_RELOC_V850_22_PCREL;
d2415 1
a2415 1
	fixP->fx_r_type = BFD_RELOC_V850_9_PCREL;
d2422 1
a2422 1
	  as_bad_where (fixP->fx_file, fixP->fx_line,
d2424 2
a2425 2
	  fixP->fx_done = 1;
	  return;
d2428 1
a2428 1
  else if (fixP->fx_done)
d2431 1
a2431 1
      where = fixP->fx_frag->fr_literal + fixP->fx_where;
d2433 1
a2433 1
      if (fixP->fx_size == 1)
d2435 1
a2435 1
      else if (fixP->fx_size == 2)
d2437 1
a2437 1
      else if (fixP->fx_size == 4)
d2440 3
d2488 1
a2488 1
bfd_boolean
d2495 8
d2519 1
a2519 2
  if (fixP->fx_r_type == BFD_RELOC_V850_LONGCALL
      || fixP->fx_r_type == BFD_RELOC_V850_LONGJUMP)
d2522 2
a2523 6
  if (v850_relax
      && (fixP->fx_pcrel
	  || fixP->fx_r_type == BFD_RELOC_V850_ALIGN
	  || fixP->fx_r_type == BFD_RELOC_V850_22_PCREL
	  || fixP->fx_r_type == BFD_RELOC_V850_9_PCREL
	  || fixP->fx_r_type >= BFD_RELOC_UNUSED))
d2526 1
a2526 1
  return generic_force_reloc (fixP);
@


1.1.1.4
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d198 1
a198 1

d200 1
a200 1
		    (offsetT) temp, (char *) 0);
d399 2
a400 2
	  segT   old_sec;
	  int    old_subsec;
d403 2
a404 2
	  old_sec = now_seg;
	  old_subsec = now_subseg;
d480 1
a480 1
    case 0:		  processor_mask = PROCESSOR_V850;   break;
a481 1
    case bfd_mach_v850e1: processor_mask = PROCESSOR_V850E;  break;
d498 1
a498 1
	as_warn (".longjump pseudo-op seen when not relaxing");
d511 1
a511 1
  if (type == 1)
d542 4
a545 3
  { "v850e1",		set_machine,		bfd_mach_v850e1 	},
  { "longcall",		v850_longcode,		1			},
  { "longjump",		v850_longcode,		2			},
d720 1
a720 1

d722 1
a722 1

d754 1
a754 1
      expressionP->X_op		= O_register;
d773 1
a773 1

d775 5
a779 5
	EXPRESSIONP points to an expression structure to be filled in.
	ACCEPT_NUMBERS is true iff numerical register names may be used.
	ACCEPT_LIST_NAMES is true iff the special names PS and SR may be
	accepted.

d842 1
a842 1
      expressionP->X_op		= O_register;
d861 1
a861 1

d863 1
a863 1

d893 1
a893 1
      expressionP->X_op		= O_constant;
d922 1
a922 1

d924 3
a926 3
       INSN		   is the partially constructed instruction.
       OPERAND		   is the operand being inserted.

d928 4
a931 4
	pointer to an error message is returned.  If the parse
	completes the correct bit fields in the instruction
	will be filled in.

d933 1
a933 1

d939 2
a940 2

   and also parses constant expressions whoes bits indicate the
d942 1
a942 1
   the lowest numbered permissible register in the register list,
a1160 1
  fprintf (stream, _("  -mv850e1                  The code is targeted at the v850e1\n"));
d1163 1
a1196 5
  else if (strcmp (arg, "v850e1") == 0)
    {
      machine = bfd_mach_v850e1;
      processor_mask = PROCESSOR_V850E1;
    }
a1203 1
      processor_mask |= PROCESSOR_V850E1;
d1333 1
a1333 9
  if (strncmp (TARGET_CPU, "v850e1", 6) == 0)
    {
      if (machine == -1)
	machine = bfd_mach_v850e1;

      if (processor_mask == -1)
	processor_mask = PROCESSOR_V850E1;
    }
  else if (strncmp (TARGET_CPU, "v850e", 5) == 0)
d1352 1
a1352 1
	    TARGET_CPU);
d1484 1
a1484 1
    : BFD_RELOC_V850_TDA_7_7_OFFSET;    /* sld.b/sst.b, operand: D7    */
d1514 3
a1516 3
  CHECK_ ("hi0",    BFD_RELOC_HI16	   );
  CHECK_ ("hi",	    BFD_RELOC_HI16_S	   );
  CHECK_ ("lo",	    BFD_RELOC_LO16	   );
d1520 1
a1520 1
  CHECK_ ("hilo",   BFD_RELOC_32	   );
d1796 2
a1797 2
		      extra_data_len	    = 4;
		      extra_data	    = 0;
d1825 2
a1826 2
		      extra_data_len	    = 4;
		      extra_data	    = ex.X_add_number;
d1902 1
a1902 1
		  ex.X_op	  = O_constant;
d1922 3
a1924 3
		  extra_data_len	= 2;
		  extra_data		= ex.X_add_number;
		  ex.X_add_number	= 0;
d1934 3
a1936 3
		  extra_data_len	= 4;
		  extra_data		= ex.X_add_number;
		  ex.X_add_number	= 0;
d1965 1
a1965 1
		      /* If this register is actually occurring too early on
d2221 1
a2221 1
		       (operand->flags & V850_OPERAND_DISP) != 0,
d2240 1
a2240 1
  reloc		      = (arelent *) xmalloc (sizeof (arelent));
d2260 1
a2260 1
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
d2290 1
a2290 1
	     BFD_RELOC_V850_ALIGN);
d2375 1
a2375 1
	 value, and stuff the instruction back again.
@


