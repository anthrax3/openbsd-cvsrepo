head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.50
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.31;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.32;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.16.13.48.36;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.16.13.40.29;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.37;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.54;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.40;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.55;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.23.28;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.46.32;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.37.44;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.34;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.57;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-z8k.c -- Assemble code for the Zilog Z800n
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

#define DEFINE_TABLE
#include <stdio.h>

#include "as.h"
#include "bfd.h"
#include "safe-ctype.h"
#include "opcodes/z8k-opc.h"

const char comment_chars[] = "!";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = ";";

extern int machine;
extern int coff_flags;
int segmented_mode;
const int md_reloc_size;

/* This is non-zero if target was set from the command line.  */
static int z8k_target_from_cmdline;

static void
s_segm (int segm)
{
  if (segm)
    {
      segmented_mode = 1;
      machine = bfd_mach_z8001;
      coff_flags = F_Z8001;
    }
  else
    {
      segmented_mode = 0;
      machine = bfd_mach_z8002;
      coff_flags = F_Z8002;
    }
}

static void
even (int ignore ATTRIBUTE_UNUSED)
{
  frag_align (1, 0, 0);
  record_alignment (now_seg, 1);
}

static int
tohex (int c)
{
  if (ISDIGIT (c))
    return c - '0';
  if (ISLOWER (c))
    return c - 'a' + 10;
  return c - 'A' + 10;
}

static void
sval (int ignore ATTRIBUTE_UNUSED)
{
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '\'')
    {
      int c;
      input_line_pointer++;
      c = *input_line_pointer++;
      while (c != '\'')
	{
	  if (c == '%')
	    {
	      c = (tohex (input_line_pointer[0]) << 4)
		| tohex (input_line_pointer[1]);
	      input_line_pointer += 2;
	    }
	  FRAG_APPEND_1_CHAR (c);
	  c = *input_line_pointer++;
	}
      demand_empty_rest_of_line ();
    }
}

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */

const pseudo_typeS md_pseudo_table[] = {
  {"int"    , cons            , 2},
  {"data.b" , cons            , 1},
  {"data.w" , cons            , 2},
  {"data.l" , cons            , 4},
  {"form"   , listing_psize   , 0},
  {"heading", listing_title   , 0},
  {"import" , s_ignore        , 0},
  {"page"   , listing_eject   , 0},
  {"program", s_ignore        , 0},
  {"z8001"  , s_segm          , 1},
  {"z8002"  , s_segm          , 0},

  {"segm"   , s_segm          , 1},
  {"unsegm" , s_segm          , 0},
  {"unseg"  , s_segm          , 0},
  {"name"   , s_app_file      , 0},
  {"global" , s_globl         , 0},
  {"wval"   , cons            , 2},
  {"lval"   , cons            , 4},
  {"bval"   , cons            , 1},
  {"sval"   , sval            , 0},
  {"rsect"  , obj_coff_section, 0},
  {"sect"   , obj_coff_section, 0},
  {"block"  , s_space         , 0},
  {"even"   , even            , 0},
  {0        , 0               , 0}
};

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* Opcode mnemonics.  */
static struct hash_control *opcode_hash_control;

void
md_begin (void)
{
  const opcode_entry_type *opcode;
  int idx = -1;

  opcode_hash_control = hash_new ();

  for (opcode = z8k_table; opcode->name; opcode++)
    {
      /* Only enter unique codes into the table.  */
      if (idx != opcode->idx)
	hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
      idx = opcode->idx;
    }

  /* Default to z8002.  */
  if (! z8k_target_from_cmdline)
    s_segm (0);

  /* Insert the pseudo ops, too.  */
  for (idx = 0; md_pseudo_table[idx].poc_name; idx++)
    {
      opcode_entry_type *fake_opcode;
      fake_opcode = (opcode_entry_type *) malloc (sizeof (opcode_entry_type));
      fake_opcode->name = md_pseudo_table[idx].poc_name;
      fake_opcode->func = (void *) (md_pseudo_table + idx);
      fake_opcode->opcode = 250;
      hash_insert (opcode_hash_control, fake_opcode->name, fake_opcode);
    }
}

typedef struct z8k_op {
  /* CLASS_REG_xxx.  */
  int regsize;

  /* 0 .. 15.  */
  unsigned int reg;

  int mode;

  /* Any other register associated with the mode.  */
  unsigned int x_reg;

  /* Any expression.  */
  expressionS exp;
} op_type;

static expressionS *da_operand;
static expressionS *imm_operand;

static int reg[16];
static int the_cc;
static int the_ctrl;
static int the_flags;
static int the_interrupt;

static char *
whatreg (int *reg, char *src)
{
  if (ISDIGIT (src[1]))
    {
      *reg = (src[0] - '0') * 10 + src[1] - '0';
      return src + 2;
    }
  else
    {
      *reg = (src[0] - '0');
      return src + 1;
    }
}

/* Parse operands

   rh0-rh7, rl0-rl7
   r0-r15
   rr0-rr14
   rq0--rq12
   WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp
   r0l,r0h,..r7l,r7h
   @@WREG
   @@WREG+
   @@-WREG
   #const
*/

/* Try to parse a reg name.  Return a pointer to the first character
   in SRC after the reg name.  */

static char *
parse_reg (char *src, int *mode, unsigned int *reg)
{
  char *res = 0;
  char regno;

  /* Check for stack pointer "sp" alias.  */
  if ((src[0] == 's' || src[0] == 'S')
      && (src[1] == 'p' || src[1] == 'P')
      && (src[2] == 0 || src[2] == ','))
    {
      if (segmented_mode)
	{
	  *mode = CLASS_REG_LONG;
	  *reg = 14;
	}
      else
	{
	  *mode = CLASS_REG_WORD;
	  *reg = 15;
	}
      return src + 2;
    }

  if (src[0] == 'r' || src[0] == 'R')
    {
      if (src[1] == 'r' || src[1] == 'R')
	{
	  if (src[2] < '0' || src[2] > '9')
	    return res;	 /* Assume no register name but a label starting with 'rr'.  */
	  *mode = CLASS_REG_LONG;
	  res = whatreg (reg, src + 2);
	  regno = *reg;
	  if (regno > 14)
	    as_bad (_("register rr%d out of range"), regno);
	  if (regno & 1)
	    as_bad (_("register rr%d does not exist"), regno);
	}
      else if (src[1] == 'h' || src[1] == 'H')
	{
	  if (src[2] < '0' || src[2] > '9')
	    return res;	 /* Assume no register name but a label starting with 'rh'.  */
	  *mode = CLASS_REG_BYTE;
	  res = whatreg (reg, src + 2);
	  regno = *reg;
	  if (regno > 7)
	    as_bad (_("register rh%d out of range"), regno);
	}
      else if (src[1] == 'l' || src[1] == 'L')
	{
	  if (src[2] < '0' || src[2] > '9')
	    return res;	 /* Assume no register name but a label starting with 'rl'.  */
	  *mode = CLASS_REG_BYTE;
	  res = whatreg (reg, src + 2);
	  regno = *reg;
	  if (regno > 7)
	    as_bad (_("register rl%d out of range"), regno);
	  *reg += 8;
	}
      else if (src[1] == 'q' || src[1] == 'Q')
	{
	  if (src[2] < '0' || src[2] > '9')
	    return res;	 /* Assume no register name but a label starting with 'rq'.  */
	  *mode = CLASS_REG_QUAD;
	  res = whatreg (reg, src + 2);
	  regno = *reg;
	  if (regno > 12)
	    as_bad (_("register rq%d out of range"), regno);
	  if (regno & 3)
	    as_bad (_("register rq%d does not exist"), regno);
	}
      else
	{
	  if (src[1] < '0' || src[1] > '9')
	    return res;	 /* Assume no register name but a label starting with 'r'.  */
	  *mode = CLASS_REG_WORD;
	  res = whatreg (reg, src + 1);
	  regno = *reg;
	  if (regno > 15)
	    as_bad (_("register r%d out of range"), regno);
	}
    }
  return res;
}

static char *
parse_exp (char *s, expressionS *op)
{
  char *save = input_line_pointer;
  char *new;

  input_line_pointer = s;
  expression (op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  new = input_line_pointer;
  input_line_pointer = save;
  return new;
}

/* The many forms of operand:

   <rb>
   <r>
   <rr>
   <rq>
   @@r
   #exp
   exp
   exp(r)
   r(#exp)
   r(r)
   */

static char *
checkfor (char *ptr, char what)
{
  if (*ptr == what)
    ptr++;
  else
    as_bad (_("expected %c"), what);

  return ptr;
}

/* Make sure the mode supplied is the size of a word.  */

static void
regword (int mode, char *string)
{
  int ok;

  ok = CLASS_REG_WORD;
  if (ok != mode)
    {
      as_bad (_("register is wrong size for a word %s"), string);
    }
}

/* Make sure the mode supplied is the size of an address.  */

static void
regaddr (int mode, char *string)
{
  int ok;

  ok = segmented_mode ? CLASS_REG_LONG : CLASS_REG_WORD;
  if (ok != mode)
    {
      as_bad (_("register is wrong size for address %s"), string);
    }
}

struct ctrl_names {
  int value;
  char *name;
};

static struct ctrl_names ctrl_table[] = {
  { 0x1, "flags" },   /* ldctlb only.  */
  { 0x2, "fcw" },     /* ldctl only.  Applies to all remaining control registers.  */
  { 0x3, "refresh" },
  { 0x4, "psapseg" },
  { 0x5, "psapoff" },
  { 0x5, "psap" },
  { 0x6, "nspseg" },
  { 0x7, "nspoff" },
  { 0x7, "nsp" },
  { 0  , 0 }
};

static void
get_ctrl_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  int i, l;

  while (*src == ' ')
    src++;

  mode->mode = CLASS_CTRL;
  for (i = 0; ctrl_table[i].name; i++)
    {
      l = strlen (ctrl_table[i].name);
      if (! strncasecmp (ctrl_table[i].name, src, l))
        {
          the_ctrl = ctrl_table[i].value;
          if (*(src + l) && *(src + l) != ',')
            break;
          *ptr = src + l;  /* Valid control name found: "consume" it.  */
          return;
        }
    }
  the_ctrl = 0;
}

struct flag_names {
  int value;
  char *name;
};

static struct flag_names flag_table[] = {
  { 0x1, "P" },
  { 0x1, "V" },
  { 0x2, "S" },
  { 0x4, "Z" },
  { 0x8, "C" },
  { 0x0, "+" },
  { 0x0, "," },
  { 0, 0 }
};

static void
get_flags_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  char c;
  int i;
  int j;

  while (*src == ' ')
    src++;

  mode->mode = CLASS_FLAGS;
  the_flags = 0;
  for (j = 0; j <= 9; j++)
    {
      if (!src[j])
	goto done;
      c = TOUPPER(src[j]);
      for (i = 0; flag_table[i].name; i++)
	{
	  if (flag_table[i].name[0] == c)
	    {
	      the_flags = the_flags | flag_table[i].value;
	      goto match;
	    }
	}
      goto done;
    match:
      ;
    }
 done:
  *ptr = src + j;
}

struct interrupt_names {
  int value;
  char *name;
};

static struct interrupt_names intr_table[] = {
  { 0x1, "nvi" },
  { 0x2, "vi" },
  { 0x3, "both" },
  { 0x3, "all" },
  { 0, 0 }
};

static void
get_interrupt_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  int i, l;

  while (*src == ' ')
    src++;

  mode->mode = CLASS_IMM;
  the_interrupt = 0;

  while (*src)
    {
      for (i = 0; intr_table[i].name; i++)
	{
	  l = strlen (intr_table[i].name);
	  if (! strncasecmp (intr_table[i].name, src, l))
	    {
	      the_interrupt |= intr_table[i].value;
	      if (*(src + l) && *(src + l) != ',')
		{
		  *ptr = src + l;
		invalid:
		  as_bad (_("unknown interrupt %s"), src);
		  while (**ptr && ! is_end_of_line[(unsigned char) **ptr])
		    (*ptr)++;	 /* Consume rest of line.  */
		  return;
		}
	      src += l;
	      if (! *src)
		{
		  *ptr = src;
		  return;
		}
	    }
	}
      if (*src == ',')
	src++;
      else
	{
	  *ptr = src;
	  goto invalid;
	}
    }

  /* No interrupt type specified, opcode won't do anything.  */
  as_warn (_("opcode has no effect"));
  the_interrupt = 0x0;
}

struct cc_names {
  int value;
  char *name;
};

static struct cc_names table[] = {
  { 0x0, "f" },
  { 0x1, "lt" },
  { 0x2, "le" },
  { 0x3, "ule" },
  { 0x4, "ov/pe" },
  { 0x4, "ov" },
  { 0x4, "pe/ov" },
  { 0x4, "pe" },
  { 0x5, "mi" },
  { 0x6, "eq" },
  { 0x6, "z" },
  { 0x7, "c/ult" },
  { 0x7, "c" },
  { 0x7, "ult/c" },
  { 0x7, "ult" },
  { 0x8, "t" },
  { 0x9, "ge" },
  { 0xa, "gt" },
  { 0xb, "ugt" },
  { 0xc, "nov/po" },
  { 0xc, "nov" },
  { 0xc, "po/nov" },
  { 0xc, "po" },
  { 0xd, "pl" },
  { 0xe, "ne" },
  { 0xe, "nz" },
  { 0xf, "nc/uge" },
  { 0xf, "nc" },
  { 0xf, "uge/nc" },
  { 0xf, "uge" },
  { 0  ,  0 }
};

static void
get_cc_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  int i, l;

  while (*src == ' ')
    src++;

  mode->mode = CLASS_CC;
  for (i = 0; table[i].name; i++)
    {
      l = strlen (table[i].name);
      if (! strncasecmp (table[i].name, src, l))
        {
          the_cc = table[i].value;
          if (*(src + l) && *(src + l) != ',')
            break;
          *ptr = src + l;  /* Valid cc found: "consume" it.  */
          return;
        }
    }
  the_cc = 0x8;  /* Not recognizing the cc defaults to t.  (Assuming no cc present.)  */
}

static void
get_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
{
  char *src = *ptr;
  char *end;

  mode->mode = 0;

  while (*src == ' ')
    src++;
  if (*src == '#')
    {
      mode->mode = CLASS_IMM;
      imm_operand = &(mode->exp);
      src = parse_exp (src + 1, &(mode->exp));
    }
  else if (*src == '@@')
    {
      mode->mode = CLASS_IR;
      src = parse_reg (src + 1, &mode->regsize, &mode->reg);
    }
  else
    {
      int regn;

      end = parse_reg (src, &mode->mode, &regn);

      if (end)
	{
	  int nw, nr;

	  src = end;
	  if (*src == '(')
	    {
	      src++;
	      end = parse_reg (src, &nw, &nr);
	      if (end)
		{
		  /* Got Ra(Rb).  */
		  src = end;

		  if (*src != ')')
		    as_bad (_("Missing ) in ra(rb)"));
		  else
		    src++;

		  regaddr (mode->mode, "ra(rb) ra");
#if 0
		  regword (mode->mode, "ra(rb) rb");
#endif
		  mode->mode = CLASS_BX;
		  mode->reg = regn;
		  mode->x_reg = nr;
		  reg[ARG_RX] = nr;
		}
	      else
		{
		  /* Got Ra(disp).  */
		  if (*src == '#')
		    src++;
		  src = parse_exp (src, &(mode->exp));
		  src = checkfor (src, ')');
		  mode->mode = CLASS_BA;
		  mode->reg = regn;
		  mode->x_reg = 0;
		  imm_operand = &(mode->exp);
		}
	    }
	  else
	    {
	      mode->reg = regn;
	      mode->x_reg = 0;
	    }
	}
      else
	{
	  /* No initial reg.  */
	  src = parse_exp (src, &(mode->exp));
	  if (*src == '(')
	    {
	      src++;
	      end = parse_reg (src, &(mode->mode), &regn);
	      regword (mode->mode, "addr(Ra) ra");
	      mode->mode = CLASS_X;
	      mode->reg = regn;
	      mode->x_reg = 0;
	      da_operand = &(mode->exp);
	      src = checkfor (end, ')');
	    }
	  else
	    {
	      /* Just an address.  */
	      mode->mode = CLASS_DA;
	      mode->reg = 0;
	      mode->x_reg = 0;
	      da_operand = &(mode->exp);
	    }
	}
    }
  *ptr = src;
}

static char *
get_operands (const opcode_entry_type *opcode, char *op_end, op_type *operand)
{
  char *ptr = op_end;
  char *savptr;

  switch (opcode->noperands)
    {
    case 0:
      operand[0].mode = 0;
      operand[1].mode = 0;
      while (*ptr == ' ')
        ptr++;
      break;

    case 1:
      if (opcode->arg_info[0] == CLASS_CC)
        {
          get_cc_operand (&ptr, operand + 0, 0);
          while (*ptr == ' ')
            ptr++;
          if (*ptr && ! is_end_of_line[(unsigned char) *ptr])
            {
              as_bad (_("invalid condition code '%s'"), ptr);
              while (*ptr && ! is_end_of_line[(unsigned char) *ptr])
                ptr++;   /* Consume rest of line.  */
            }
        }
      else if (opcode->arg_info[0] == CLASS_FLAGS)
	{
	  get_flags_operand (&ptr, operand + 0, 0);
	  while (*ptr == ' ')
	    ptr++;
	  if (*ptr && ! is_end_of_line[(unsigned char) *ptr])
	    {
	      as_bad (_("invalid flag '%s'"), ptr);
	      while (*ptr && ! is_end_of_line[(unsigned char) *ptr])
		ptr++;	 /* Consume rest of line.  */
	    }
	}
      else if (opcode->arg_info[0] == (CLASS_IMM + (ARG_IMM2)))
	get_interrupt_operand (&ptr, operand + 0, 0);
      else
	get_operand (&ptr, operand + 0, 0);

      operand[1].mode = 0;
      break;

    case 2:
      savptr = ptr;
      if (opcode->arg_info[0] == CLASS_CC)
        {
          get_cc_operand (&ptr, operand + 0, 0);
          while (*ptr == ' ')
            ptr++;
          if (*ptr != ',' && strchr (ptr + 1, ','))
            {
              savptr = ptr;
              while (*ptr != ',')
                ptr++;
              *ptr = 0;
              ptr++;
              as_bad (_("invalid condition code '%s'"), savptr);
            }
        }
      else if (opcode->arg_info[0] == CLASS_CTRL)
	{
	  get_ctrl_operand (&ptr, operand + 0, 0);

	  if (the_ctrl == 0)
	    {
	      ptr = savptr;
	      get_operand (&ptr, operand + 0, 0);

	      if (ptr == 0)
		return NULL;
	      if (*ptr == ',')
		ptr++;
	      get_ctrl_operand (&ptr, operand + 1, 1);
	      if (the_ctrl == 0)
		return NULL;
	      return ptr;
	    }
	}
      else
	get_operand (&ptr, operand + 0, 0);

      if (ptr == 0)
	return NULL;
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, 1);
      break;

    case 3:
      get_operand (&ptr, operand + 0, 0);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, 1);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 2, 2);
      break;

    case 4:
      get_operand (&ptr, operand + 0, 0);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, 1);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 2, 2);
      if (*ptr == ',')
	ptr++;
      get_cc_operand (&ptr, operand + 3, 3);
      break;

    default:
      abort ();
    }

  return ptr;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes.  Return the opcode which matches the opcodes
   provided.  */

static opcode_entry_type *
get_specific (opcode_entry_type *opcode, op_type *operands)
{
  opcode_entry_type *this_try = opcode;
  int found = 0;
  unsigned int noperands = opcode->noperands;

  int this_index = opcode->idx;

  while (this_index == opcode->idx && !found)
    {
      unsigned int i;

      this_try = opcode++;
      for (i = 0; i < noperands; i++)
	{
	  unsigned int mode = operands[i].mode;

          if (((mode & CLASS_MASK) == CLASS_IR) && ((this_try->arg_info[i] & CLASS_MASK) == CLASS_IRO))
            {
              mode = operands[i].mode = (operands[i].mode & ~CLASS_MASK) | CLASS_IRO;
            }

	  if ((mode & CLASS_MASK) != (this_try->arg_info[i] & CLASS_MASK))
	    {
	      /* It could be a pc rel operand, if this is a da mode
		 and we like disps, then insert it.  */

	      if (mode == CLASS_DA && this_try->arg_info[i] == CLASS_DISP)
		{
		  /* This is the case.  */
		  operands[i].mode = CLASS_DISP;
		}
	      else if (mode == CLASS_BA && this_try->arg_info[i])
		{
		  /* Can't think of a way to turn what we've been
		     given into something that's OK.  */
		  goto fail;
		}
	      else if (this_try->arg_info[i] & CLASS_PR)
		{
		  if (mode == CLASS_REG_LONG && segmented_mode)
		    {
		      /* OK.  */
		    }
		  else if (mode == CLASS_REG_WORD && !segmented_mode)
		    {
		      /* OK.  */
		    }
		  else
		    goto fail;
		}
	      else
		goto fail;
	    }
	  switch (mode & CLASS_MASK)
	    {
	    default:
	      break;
	    case CLASS_IRO:
	      if (operands[i].regsize != CLASS_REG_WORD)
		as_bad (_("invalid indirect register size"));
	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
	      break;
	    case CLASS_IR:
	      if ((segmented_mode && operands[i].regsize != CLASS_REG_LONG)
		  || (!segmented_mode && operands[i].regsize != CLASS_REG_WORD))
		as_bad (_("invalid indirect register size"));
	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
	      break;
	    case CLASS_X:
	    case CLASS_BA:
	    case CLASS_BX:
	    case CLASS_DISP:
	    case CLASS_REG:
	    case CLASS_REG_WORD:
	    case CLASS_REG_BYTE:
	    case CLASS_REG_QUAD:
	    case CLASS_REG_LONG:
	    case CLASS_REGN0:
	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
	      break;
	    case CLASS_CTRL:
	      if (this_try->opcode == OPC_ldctlb && the_ctrl != 1)
		as_bad (_("invalid control register name"));
	      break;
	    }
	}

      found = 1;
    fail:
      ;
    }
  if (found)
    return this_try;
  else
    return 0;
}

static char buffer[20];

static void
newfix (int ptr, int type, int size, expressionS *operand)
{
  int is_pcrel = 0;

  /* size is in nibbles.  */

  if (operand->X_add_symbol
      || operand->X_op_symbol
      || operand->X_add_number)
    {
      switch(type)
        {
        case R_JR:
        case R_DISP7:
        case R_CALLR:
          is_pcrel = 1;
        }
      fix_new_exp (frag_now,
		   ptr,
		   size / 2,
		   operand,
		   is_pcrel,
		   type);
    }
}

static char *
apply_fix (char *ptr, int type, expressionS *operand, int size)
{
  long n = operand->X_add_number;

  /* size is in nibbles.  */

  newfix ((ptr - buffer) / 2, type, size + 1, operand);
  switch (size)
    {
    case 8:			/* 8 nibbles == 32 bits.  */
      *ptr++ = n >> 28;
      *ptr++ = n >> 24;
      *ptr++ = n >> 20;
      *ptr++ = n >> 16;
    case 4:			/* 4 nibbles == 16 bits.  */
      *ptr++ = n >> 12;
      *ptr++ = n >> 8;
    case 2:
      *ptr++ = n >> 4;
    case 1:
      *ptr++ = n >> 0;
      break;
    }
  return ptr;
}

/* Now we know what sort of opcodes it is.  Let's build the bytes.  */

#define INSERT(x,y) *x++ = y>>24; *x++ = y>> 16; *x++=y>>8; *x++ =y;

static void
build_bytes (opcode_entry_type *this_try, struct z8k_op *operand ATTRIBUTE_UNUSED)
{
  char *output_ptr = buffer;
  int c;
  int nibble;
  unsigned int *class_ptr;

  frag_wane (frag_now);
  frag_new (0);

  memset (buffer, 0, sizeof (buffer));
  class_ptr = this_try->byte_info;

  for (nibble = 0; (c = *class_ptr++); nibble++)
    {

      switch (c & CLASS_MASK)
	{
	default:
	  abort ();

	case CLASS_ADDRESS:
	  /* Direct address, we don't cope with the SS mode right now.  */
	  if (segmented_mode)
	    {
	      /* da_operand->X_add_number |= 0x80000000;  --  Now set at relocation time.  */
	      output_ptr = apply_fix (output_ptr, R_IMM32, da_operand, 8);
	    }
	  else
	    {
	      output_ptr = apply_fix (output_ptr, R_IMM16, da_operand, 4);
	    }
	  da_operand = 0;
	  break;
	case CLASS_DISP8:
	  /* pc rel 8 bit  */
	  output_ptr = apply_fix (output_ptr, R_JR, da_operand, 2);
	  da_operand = 0;
	  break;

	case CLASS_0DISP7:
	  /* pc rel 7 bit  */
	  *output_ptr = 0;
	  output_ptr = apply_fix (output_ptr, R_DISP7, da_operand, 2);
	  da_operand = 0;
	  break;

	case CLASS_1DISP7:
	  /* pc rel 7 bit  */
	  *output_ptr = 0x80;
	  output_ptr = apply_fix (output_ptr, R_DISP7, da_operand, 2);
	  output_ptr[-2] = 0x8;
	  da_operand = 0;
	  break;

	case CLASS_BIT_1OR2:
	  *output_ptr = c & 0xf;
	  if (imm_operand)
	    {
	      if (imm_operand->X_add_number == 2)
		*output_ptr |= 2;
	      else if (imm_operand->X_add_number != 1)
		as_bad (_("immediate must be 1 or 2"));
	    }
	  else
	    as_bad (_("immediate 1 or 2 expected"));
	  output_ptr++;
	  break;
	case CLASS_CC:
	  *output_ptr++ = the_cc;
	  break;
	case CLASS_0CCC:
	  if (the_ctrl < 2 || the_ctrl > 7)
	    as_bad (_("invalid control register name"));
	  *output_ptr++ = the_ctrl;
	  break;
	case CLASS_1CCC:
	  if (the_ctrl < 2 || the_ctrl > 7)
	    as_bad (_("invalid control register name"));
	  *output_ptr++ = the_ctrl | 0x8;
	  break;
	case CLASS_00II:
	  *output_ptr++ = (~the_interrupt & 0x3);
	  break;
	case CLASS_01II:
	  *output_ptr++ = (~the_interrupt & 0x3) | 0x4;
	  break;
	case CLASS_FLAGS:
	  *output_ptr++ = the_flags;
	  break;
	case CLASS_IGNORE:
	case CLASS_BIT:
	  *output_ptr++ = c & 0xf;
	  break;
	case CLASS_REGN0:
	  if (reg[c & 0xf] == 0)
	    as_bad (_("can't use R0 here"));
	  /* Fall through.  */
	case CLASS_REG:
	case CLASS_REG_BYTE:
	case CLASS_REG_WORD:
	case CLASS_REG_LONG:
	case CLASS_REG_QUAD:
	  /* Insert bit mattern of right reg.  */
	  *output_ptr++ = reg[c & 0xf];
	  break;
	case CLASS_DISP:
          switch (c & ARG_MASK)
            {
            case ARG_DISP12:
              output_ptr = apply_fix (output_ptr, R_CALLR, da_operand, 4);
              break;
            case ARG_DISP16:
	      output_ptr = apply_fix (output_ptr, R_REL16, da_operand, 4);
	      break;
	    default:
	      output_ptr = apply_fix (output_ptr, R_IMM16, da_operand, 4);
	    }
	  da_operand = 0;
	  break;

	case CLASS_IMM:
	  {
	    switch (c & ARG_MASK)
	      {
	      case ARG_NIM4:
                if (imm_operand->X_add_number > 15)
                  {
                    as_bad (_("immediate value out of range"));
                  }
		imm_operand->X_add_number = -imm_operand->X_add_number;
		output_ptr = apply_fix (output_ptr, R_IMM4L, imm_operand, 1);
		break;
              /*case ARG_IMMNMINUS1: not used.  */
	      case ARG_IMM4M1:
		imm_operand->X_add_number--;
                /* Drop through.  */
	      case ARG_IMM4:
                if (imm_operand->X_add_number > 15)
                  {
                    as_bad (_("immediate value out of range"));
                  }
		output_ptr = apply_fix (output_ptr, R_IMM4L, imm_operand, 1);
		break;
	      case ARG_NIM8:
		imm_operand->X_add_number = -imm_operand->X_add_number;
                /* Drop through.  */
	      case ARG_IMM8:
		output_ptr = apply_fix (output_ptr, R_IMM8, imm_operand, 2);
		break;
	      case ARG_IMM16:
		output_ptr = apply_fix (output_ptr, R_IMM16, imm_operand, 4);
		break;
	      case ARG_IMM32:
		output_ptr = apply_fix (output_ptr, R_IMM32, imm_operand, 8);
		break;
	      default:
		abort ();
	      }
	  }
	}
    }

  /* Copy from the nibble buffer into the frag.  */
  {
    int length = (output_ptr - buffer) / 2;
    char *src = buffer;
    char *fragp = frag_more (length);

    while (src < output_ptr)
      {
	*fragp = (src[0] << 4) | src[1];
	src += 2;
	fragp++;
      }
  }
}

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (char *str)
{
  char c;
  char *op_start;
  char *op_end;
  struct z8k_op operand[3];
  opcode_entry_type *opcode;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the op code end.  */
  for (op_start = op_end = str;
       *op_end != 0 && *op_end != ' ' && ! is_end_of_line[(unsigned char) *op_end];
       op_end++)
    ;

  if (op_end == op_start)
    {
      as_bad (_("can't find opcode "));
    }
  c = *op_end;

  *op_end = 0;  /* Zero-terminate op code string for hash_find() call.  */

  opcode = (opcode_entry_type *) hash_find (opcode_hash_control, op_start);

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  *op_end = c;  /* Restore original string.  */

  if (opcode->opcode == 250)
    {
      pseudo_typeS *p;
      char oc;
      char *old = input_line_pointer;

      /* Was really a pseudo op.  */

      input_line_pointer = op_end;

      oc = *old;
      *old = '\n';
      while (*input_line_pointer == ' ')
	input_line_pointer++;
      p = (pseudo_typeS *) (opcode->func);

      (p->poc_handler) (p->poc_val);
      input_line_pointer = old;
      *old = oc;
    }
  else
    {
      char *new_input_line_pointer;

      new_input_line_pointer = get_operands (opcode, op_end, operand);
      if (new_input_line_pointer)
        input_line_pointer = new_input_line_pointer;

      opcode = get_specific (opcode, operand);

      if (opcode == 0)
	{
	  /* Couldn't find an opcode which matched the operands.  */
	  char *where = frag_more (2);

	  where[0] = 0x0;
	  where[1] = 0x0;

	  as_bad (_("Can't find opcode to match operands"));
	  return;
	}

      build_bytes (opcode, operand);
    }
}

void
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

void
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_headers_hook \n"));
}

/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

const char *md_shortopts = "z:";

struct option md_longopts[] =
  {
#define OPTION_RELAX  (OPTION_MD_BASE)
    {"linkrelax", no_argument, NULL, OPTION_RELAX},
    {NULL, no_argument, NULL, 0}
  };

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case 'z':
      if (!strcmp (arg, "8001"))
	s_segm (1);
      else if (!strcmp (arg, "8002"))
	s_segm (0);
      else
	{
	  as_bad (_("invalid architecture -z%s"), arg);
	  return 0;
	}
      z8k_target_from_cmdline = 1;
      break;

    case OPTION_RELAX:
      linkrelax = 1;
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
 Z8K options:\n\
  -z8001                  generate segmented code\n\
  -z8002                  generate unsegmented code\n\
  -linkrelax              create linker relaxable code\n"));
}

void
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED,
                 segT seg ATTRIBUTE_UNUSED,
                 fragS *fragP ATTRIBUTE_UNUSED)
{
  printf (_("call to md_convert_frag\n"));
  abort ();
}

valueT
md_section_align (segT seg, valueT size)
{
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
}

/* Attempt to simplify or eliminate a fixup. To indicate that a fixup
   has been eliminated, set fix->fx_done. If fix->fx_addsy is non-NULL,
   we will have to generate a reloc entry.  */
void
md_apply_fix3 (fixS *fixP, valueT *valP, segT segment ATTRIBUTE_UNUSED)
{
  long val = * (long *) valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;

  switch (fixP->fx_r_type)
    {
    case R_IMM4L:
      buf[0] = (buf[0] & 0xf0) | (val & 0xf);
      break;

    case R_JR:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
      if (val & 1)
        as_bad (_("cannot branch to odd address"));
      val /= 2;
      if (val > 127 || val < -128)
            as_warn (_("relative jump out of range"));
      *buf++ = val;
      fixP->fx_no_overflow = 1;
          fixP->fx_done = 1;
        }
      break;

    case R_DISP7:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          if (val & 1)
            as_bad (_("cannot branch to odd address"));
          val /= 2;
          if (val > 0 || val < -127)
            as_bad (_("relative jump out of range"));
          *buf = (*buf & 0x80) | (-val & 0x7f);
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 1;
        }
      break;

    case R_CALLR:
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          if (val & 1)
            as_bad (_("cannot branch to odd address"));
          if (val > 4096 || val < -4095)
            as_bad (_("relative call out of range"));
          val = -val / 2;
          *buf = (*buf & 0xf0) | ((val >> 8) & 0xf);
          buf++;
          *buf++ = val & 0xff;
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 1;
        }
      break;

    case R_IMM8:
      *buf++ = val;
      break;

    case R_IMM16:
      *buf++ = (val >> 8);
      *buf++ = val;
      break;

    case R_IMM32:
      *buf++ = (val >> 24);
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      break;

    case R_REL16:
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
      if (val > 32767 || val < -32768)
        as_bad (_("relative address out of range"));
      *buf++ = (val >> 8);
      *buf++ = val;
      fixP->fx_no_overflow = 1;
      break;

#if 0
    case R_DA | R_SEG:
      *buf++ = (val >> 16);
      *buf++ = 0x00;
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
#endif

    case 0:
      md_number_to_chars (buf, val, fixP->fx_size);
      break;

    default:
      printf(_("md_apply_fix3: unknown r_type 0x%x\n"), fixP->fx_r_type);
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

int
md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED,
                               segT segment_type ATTRIBUTE_UNUSED)
{
  printf (_("call to md_estimate_size_before_relax\n"));
  abort ();
}

/* Put number into target byte order.  */

void
md_number_to_chars (char *ptr, valueT use, int nbytes)
{
  number_to_chars_bigendian (ptr, use, nbytes);
}

/* On the Z8000, a PC-relative offset is relative to the address of the
   instruction plus its size.  */
long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

void
tc_coff_symbol_emit_hook (symbolS *s ATTRIBUTE_UNUSED)
{
}

void
tc_reloc_mangle (fixS *fix_ptr, struct internal_reloc *intr, bfd_vma base)
{
  symbolS *symbol_ptr;

  if (fix_ptr->fx_addsy
      && fix_ptr->fx_subsy)
    {
      symbolS *add = fix_ptr->fx_addsy;
      symbolS *sub = fix_ptr->fx_subsy;

      if (S_GET_SEGMENT (add) != S_GET_SEGMENT (sub))
	as_bad (_("Can't subtract symbols in different sections %s %s"),
		S_GET_NAME (add), S_GET_NAME (sub));
      else
	{
	  int diff = S_GET_VALUE (add) - S_GET_VALUE (sub);

	  fix_ptr->fx_addsy = 0;
	  fix_ptr->fx_subsy = 0;
	  fix_ptr->fx_offset += diff;
	}
    }
  symbol_ptr = fix_ptr->fx_addsy;

  /* If this relocation is attached to a symbol then it's ok
     to output it.  */
  if (fix_ptr->fx_r_type == 0)
    {
      /* cons likes to create reloc32's whatever the size of the reloc.  */
      switch (fix_ptr->fx_size)
	{
	case 2:
	  intr->r_type = R_IMM16;
	  break;
	case 1:
	  intr->r_type = R_IMM8;
	  break;
	case 4:
	  intr->r_type = R_IMM32;
	  break;
	default:
	  abort ();
	}
    }
  else
    intr->r_type = fix_ptr->fx_r_type;

  intr->r_vaddr = fix_ptr->fx_frag->fr_address + fix_ptr->fx_where + base;
  intr->r_offset = fix_ptr->fx_offset;

  if (symbol_ptr)
    intr->r_symndx = symbol_ptr->sy_number;
  else
    intr->r_symndx = -1;
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@a43 5
static void s_segm PARAMS ((int));
static void even PARAMS ((int));
static int tohex PARAMS ((int));
static void sval PARAMS ((int));

d45 1
a45 2
s_segm (segm)
     int segm;
d49 3
a51 3
  segmented_mode = 1;
  machine = bfd_mach_z8001;
  coff_flags = F_Z8001;
d55 3
a57 3
  segmented_mode = 0;
  machine = bfd_mach_z8002;
  coff_flags = F_Z8002;
d62 1
a62 2
even (ignore)
     int ignore ATTRIBUTE_UNUSED;
d69 1
a69 2
tohex (c)
     int c;
d79 1
a79 2
sval (ignore)
     int ignore ATTRIBUTE_UNUSED;
d149 1
a149 1
md_begin ()
a179 6
struct z8k_exp {
  char *e_beg;
  char *e_end;
  expressionS e_exp;
};

d181 2
a182 2
  /* 'b','w','r','q'.  */
  char regsize;
d199 5
a203 32
int reg[16];
int the_cc;
int the_ctrl;
int the_flags;
int the_interrupt;

static char *whatreg PARAMS ((int *, char *));
static char *parse_reg PARAMS ((char *, int *, unsigned int *));
static char *parse_exp PARAMS ((char *, expressionS *));
static char *checkfor PARAMS ((char *, char));
static void regword PARAMS ((int, char *));
static void regaddr PARAMS ((int, char *));
static void get_ctrl_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_flags_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_interrupt_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_cc_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static char *get_operands
  PARAMS ((const opcode_entry_type *, char *, op_type *));
static opcode_entry_type *get_specific
  PARAMS ((opcode_entry_type *, op_type *));
static void newfix
  PARAMS ((int, int, int, expressionS *));
static char *apply_fix
  PARAMS ((char *, int, expressionS *, int));
static void build_bytes
  PARAMS ((opcode_entry_type *, struct z8k_op *));
d206 1
a206 3
whatreg (reg, src)
     int *reg;
     char *src;
d238 1
a238 4
parse_reg (src, mode, reg)
     char *src;
     int *mode;
     unsigned int *reg;
d243 4
a246 1
  if (src[0] == 's' && src[1] == 'p' && (src[2] == 0 || src[2] == ','))
d260 2
a261 1
  if (src[0] == 'r')
d263 1
a263 1
      if (src[1] == 'r')
d271 3
a273 1
	    as_warn (_("register rr%d, out of range."), regno);
d275 1
a275 1
      else if (src[1] == 'h')
d283 1
a283 1
	    as_warn (_("register rh%d, out of range."), regno);
d285 1
a285 1
      else if (src[1] == 'l')
d293 1
a293 1
	    as_warn (_("register rl%d, out of range."), regno);
d296 1
a296 1
      else if (src[1] == 'q')
d304 3
a306 1
	    as_warn (_("register rq%d, out of range."), regno);
d316 1
a316 1
	    as_warn (_("register r%d, out of range."), regno);
d323 1
a323 3
parse_exp (s, op)
     char *s;
     expressionS *op;
d352 1
a352 3
checkfor (ptr, what)
     char *ptr;
     char what;
d365 1
a365 3
regword (mode, string)
     int mode;
     char *string;
d379 1
a379 3
regaddr (mode, string)
     int mode;
     char *string;
d395 3
a397 2
struct ctrl_names ctrl_table[] = {
  { 0x2, "fcw" },
d409 1
a409 4
get_ctrl_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d412 1
a412 1
  int i;
d420 9
a428 12
      int j;

      for (j = 0; ctrl_table[i].name[j]; j++)
	{
	  if (ctrl_table[i].name[j] != src[j])
	    goto fail;
	}
      the_ctrl = ctrl_table[i].value;
      *ptr = src + j;
      return;
    fail:
      ;
a430 1
  return;
a435 1

d438 6
a443 6
struct flag_names flag_table[] = {
  { 0x1, "p" },
  { 0x1, "v" },
  { 0x2, "s" },
  { 0x4, "z" },
  { 0x8, "c" },
d445 1
d450 1
a450 4
get_flags_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d453 1
d466 1
d469 1
a469 1
	  if (flag_table[i].name[0] == src[j])
a480 1
  return;
a485 1

d488 1
a488 1
struct interrupt_names intr_table[] = {
d497 1
a497 4
get_interrupt_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d500 1
a500 1
  int i;
d506 3
a508 1
  for (i = 0; intr_table[i].name; i++)
d510 26
a535 3
      int j;

      for (j = 0; intr_table[i].name[j]; j++)
d537 2
a538 2
	  if (intr_table[i].name[j] != src[j])
	    goto fail;
a539 5
      the_interrupt = intr_table[i].value;
      *ptr = src + j;
      return;
    fail:
      ;
d541 1
d543 1
a543 1
  as_warn (_("opcode has no effect."));
a544 1
  return;
d552 1
a552 1
struct cc_names table[] = {
d557 1
d559 1
d564 1
d566 1
d572 1
d574 1
d579 1
d581 1
d587 1
a587 4
get_cc_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d590 1
a590 1
  int i;
d598 9
a606 12
      int j;

      for (j = 0; table[i].name[j]; j++)
	{
	  if (table[i].name[j] != src[j])
	    goto fail;
	}
      the_cc = table[i].value;
      *ptr = src + j;
      return;
    fail:
      ;
d608 1
a608 1
  the_cc = 0x8;
d612 1
a612 4
get_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
a628 2
      int d;

d630 1
a630 1
      src = parse_reg (src + 1, &d, &mode->reg);
d714 1
a714 4
get_operands (opcode, op_end, operand)
     const opcode_entry_type *opcode;
     char *op_end;
     op_type *operand;
a718 1
  ptr++;
d724 2
d730 11
a740 2
	get_cc_operand (&ptr, operand + 0, 0);

d742 11
a752 2
	get_flags_operand (&ptr, operand + 0, 0);

a754 1

d764 14
a777 2
	get_cc_operand (&ptr, operand + 0, 0);

d792 2
d842 1
a842 3
get_specific (opcode, operands)
     opcode_entry_type *opcode;
     op_type *operands;
d859 5
d900 11
a911 1
	    case CLASS_IR:
d923 4
a939 26
#if 0 /* Not used.  */
static void
check_operand (operand, width, string)
     struct z8k_op *operand;
     unsigned int width;
     char *string;
{
  if (operand->exp.X_add_symbol == 0
      && operand->exp.X_op_symbol == 0)
    {

      /* No symbol involved, let's look at offset, it's dangerous if
	 any of the high bits are not 0 or ff's, find out by oring or
	 anding with the width and seeing if the answer is 0 or all
	 fs.  */
      if ((operand->exp.X_add_number & ~width) != 0 &&
	  (operand->exp.X_add_number | width) != (~0))
	{
	  as_warn (_("operand %s0x%x out of range."),
		   string, operand->exp.X_add_number);
	}
    }

}
#endif

d943 1
a943 5
newfix (ptr, type, size, operand)
     int ptr;
     int type;
     int size;   /* nibbles.  */
     expressionS *operand;
d945 4
d953 7
d964 1
a964 1
		   0,
d970 1
a970 5
apply_fix (ptr, type, operand, size)
     char *ptr;
     int type;
     expressionS *operand;
     int size;   /* nibbles.  */
d974 2
d1001 1
a1001 3
build_bytes (this_try, operand)
     opcode_entry_type *this_try;
     struct z8k_op *operand ATTRIBUTE_UNUSED;
d1073 2
d1078 2
d1184 1
a1184 2
md_assemble (str)
     char *str;
a1190 1
  opcode_entry_type *prev_opcode;
d1198 1
a1198 1
       *op_end != 0 && *op_end != ' ';
d1208 1
a1208 1
  *op_end = 0;
d1218 2
a1224 1
      *op_end = c;
a1246 1
      prev_opcode = opcode; /* XXX is this used ?? */
d1267 1
a1267 2
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d1275 1
a1275 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1281 1
a1281 2
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d1296 1
a1296 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d1358 1
a1358 3
md_parse_option (c, arg)
     int c;
     char *arg;
d1387 1
a1387 2
md_show_usage (stream)
     FILE *stream;
d1397 3
a1399 4
md_convert_frag (headers, seg, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d1406 1
a1406 3
md_section_align (seg, size)
     segT seg;
     valueT size;
d1412 3
d1416 1
a1416 4
md_apply_fix3 (fixP, valP, segment)
     fixS * fixP;
     valueT * valP;
     segT segment ATTRIBUTE_UNUSED;
d1428 7
a1434 1
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
d1439 1
a1439 1
        as_bad (_("relative jump out of range"));
d1442 2
d1447 16
a1462 8
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
      if (val & 1)
        as_bad (_("cannot branch to odd address"));
      val /= 2;
      if (val > 0 || val < -128)
        as_bad (_("relative jump out of range"));
      *buf = (*buf & 0x80) | (val & 0x7f);
      fixP->fx_no_overflow = 1;
d1466 18
a1483 5
      if (val > 8191 || val < -8192)
        as_bad (_("relative call out of range"));
      val = -val;
      *buf++ = (buf[0] & 0xf0) | ((val >> 8) & 0xf);
      *buf++ = val & 0xff;
d1534 2
a1535 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP ATTRIBUTE_UNUSED;
     register segT segment_type ATTRIBUTE_UNUSED;
d1544 1
a1544 4
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
d1549 2
d1552 1
a1552 2
md_pcrel_from (fixP)
     fixS *fixP ATTRIBUTE_UNUSED;
d1554 1
a1554 1
  abort ();
d1558 1
a1558 2
tc_coff_symbol_emit_hook (s)
     symbolS *s ATTRIBUTE_UNUSED;
d1563 1
a1563 5
tc_reloc_mangle (fix_ptr, intr, base)
     fixS *fix_ptr;
     struct internal_reloc *intr;
     bfd_vma base;

@


1.6
log
@better. this is what has been applied to binutils.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000
a26 2
#include "opcodes/z8k-opc.h"

d29 2
a30 1
#include <ctype.h>
d41 2
a42 1
void cons ();
d44 8
a51 2
void
s_segm ()
d53 2
d58 3
a60 5
}

void
s_unseg ()
{
d64 1
d68 2
a69 1
even ()
d75 1
a75 3
void obj_coff_section ();

int
d79 1
a79 1
  if (isdigit (c))
d81 1
a81 1
  if (islower (c))
d86 3
a88 2
void
sval ()
d128 2
a129 2
  {"z8001"  , s_segm          , 0},
  {"z8002"  , s_unseg         , 0},
d131 3
a133 3
  {"segm"   , s_segm          , 0},
  {"unsegm" , s_unseg         , 0},
  {"unseg"  , s_unseg         , 0},
d160 2
a161 3
  opcode_entry_type *opcode;
  char *prev_name = "";
  int idx = 0;
d168 3
a170 7
      if (strcmp (opcode->name, prev_name))
	{
	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
	  idx++;
	}
      opcode->idx = idx;
      prev_name = opcode->name;
d174 2
a175 1
  s_unseg ();
a186 2

  linkrelax = 1;
d220 28
a247 1
char *
d252 1
a252 1
  if (isdigit (src[1]))
d281 1
a281 1
char *
d290 1
a290 1
  if (src[0] == 's' && src[1] == 'p')
d308 2
d318 2
d328 2
d339 2
d349 2
d361 1
a361 1
char *
d580 2
a588 1

d757 1
a757 1
     opcode_entry_type *opcode;
d764 1
a772 1
      ptr++;
d774 2
a775 3
	{
	  get_cc_operand (&ptr, operand + 0, 0);
	}
d777 2
a778 3
	{
	  get_flags_operand (&ptr, operand + 0, 0);
	}
d780 2
a781 3
	{
	  get_interrupt_operand (&ptr, operand + 0, 0);
	}
d783 2
a784 3
	{
	  get_operand (&ptr, operand + 0, 0);
	}
a788 1
      ptr++;
d791 2
a792 3
	{
	  get_cc_operand (&ptr, operand + 0, 0);
	}
d796 1
d801 1
d811 2
a812 3
	{
	  get_operand (&ptr, operand + 0, 0);
	}
a820 1
      ptr++;
a830 1
      ptr++;
a857 1

d876 1
a876 1
	      /* It could be an pc rel operand, if this is a da mode
d965 1
a965 1
newfix (ptr, type, operand)
d968 1
d977 1
a977 1
		   1,
d989 1
a989 1
     int size;
d991 1
a991 1
  int n = operand->X_add_number;
d993 1
a993 1
  newfix ((ptr - buffer) / 2, type, operand);
a1023 1
  int nib;
d1106 1
a1138 1
	    nib = 0;
d1141 6
a1146 1
	      case ARG_IMM4:
d1149 1
d1152 6
a1157 4
		output_ptr = apply_fix (output_ptr, R_IMM4L, imm_operand, 1);
		break;
	      case ARG_IMMNMINUS1:
		imm_operand->X_add_number--;
d1162 1
a1168 1

a1171 1

a1236 2
      /* Was really a pseudo op.  */

a1238 1

d1242 2
d1258 6
a1263 2
      input_line_pointer = get_operands (opcode, op_end, operand);
      prev_opcode = opcode;
d1290 2
a1324 1
  char *atof_ieee ();
d1369 1
a1369 1
CONST char *md_shortopts = "z:";
d1371 6
a1376 3
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
d1389 1
a1389 1
	s_segm ();
d1391 1
a1391 1
	s_unseg ();
d1397 5
d1416 4
a1419 3
Z8K options:\n\
-z8001			generate segmented code\n\
-z8002			generate unsegmented code\n"));
a1422 7
tc_aout_fix_to_chars ()
{
  printf (_("call to tc_aout_fix_to_chars \n"));
  abort ();
}

void
d1428 1
a1428 1
  printf (_("call to md_convert_frag \n"));
a1438 1

d1442 4
a1445 3
md_apply_fix (fixP, val)
     fixS *fixP;
     long val;
d1447 1
d1453 1
a1453 1
      buf[0] = (buf[0] & 0xf0) | ((buf[0] + val) & 0xf);
d1457 6
a1462 1

d1464 1
a1464 4
#if 0
      if (val != 0)
	abort ();
#endif
d1468 9
d1478 6
a1483 5
      *buf++ += val;
#if 0
      if (val != 0)
	abort ();
#endif
d1487 1
a1487 1
      buf[0] += val;
d1489 1
d1494 1
d1501 10
d1525 1
d1528 3
d1538 1
a1538 1
  printf (_("call tomd_estimate_size_before_relax \n"));
@


1.5
log
@Correct memset arguments; from Moritz Jodeit <moritz@@jodeit.org> via
PR/2822. Submited to binutils as well.
@
text
@d999 1
a999 1
  memset (buffer, 0, 20);
@


1.4
log
@resolve conflicts.
@
text
@d999 1
a999 1
  memset (buffer, 20, 0);
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999 Free Software Foundation.
d22 2
a23 4
/*
  Written By Steve Chamberlain
  sac@@cygnus.com
  */
d33 3
a35 6
const char comment_chars[] =
{'!', 0};
const char line_separator_chars[] =
{';', 0};
const char line_comment_chars[] =
{'#', 0};
a41 7
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */

d60 1
a60 2
static
void
a82 1

d102 1
d104 34
a137 30
}
const pseudo_typeS md_pseudo_table[] =
{
  {"int", cons, 2},
  {"data.b", cons, 1},
  {"data.w", cons, 2},
  {"data.l", cons, 4},
  {"form", listing_psize, 0},
  {"heading", listing_title, 0},
  {"import", s_ignore, 0},
  {"page", listing_eject, 0},
  {"program", s_ignore, 0},
  {"z8001", s_segm, 0},
  {"z8002", s_unseg, 0},


  {"segm", s_segm, 0},
  {"unsegm", s_unseg, 0},
  {"unseg", s_unseg, 0},
  {"name", s_app_file, 0},
  {"global", s_globl, 0},
  {"wval", cons, 2},
  {"lval", cons, 4},
  {"bval", cons, 1},
  {"sval", sval, 0},
  {"rsect", obj_coff_section, 0},
  {"sect", obj_coff_section, 0},
  {"block", s_space, 0},
  {"even", even, 0},
  {0, 0, 0}
d142 3
a144 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d147 2
a148 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
d161 1
a161 3
      /* Only enter unique codes into the table */
      char *src = opcode->name;

d171 1
a171 1
  /* default to z8002 */
d174 1
a174 1
  /* insert the pseudo ops too */
d179 2
a180 2
      fake_opcode->name = md_pseudo_table[idx].poc_name,
	fake_opcode->func = (void *) (md_pseudo_table + idx);
d188 1
a188 2
struct z8k_exp
{
d193 7
a199 4
typedef struct z8k_op
{
  char regsize;			/* 'b','w','r','q' */
  unsigned int reg;		/* 0..15 */
d203 2
a204 3
  unsigned int x_reg;		/* any other register associated with the mode */
  expressionS exp;		/* any expression */
}
d206 3
a208 1
op_type;
d220 3
a222 3
DEFUN (whatreg, (reg, src),
       int *reg AND
       char *src)
d236 1
a236 2
/*
  parse operands
d238 11
a248 10
  rh0-rh7, rl0-rl7
  r0-r15
  rr0-rr14
  rq0--rq12
  WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp
  r0l,r0h,..r7l,r7h
  @@WREG
  @@WREG+
  @@-WREG
  #const
d250 2
a251 1
  */
a252 1
/* try and parse a reg name, returns number of chars consumed */
d254 4
a257 4
DEFUN (parse_reg, (src, mode, reg),
       char *src AND
       int *mode AND
       unsigned int *reg)
d265 4
a268 4
        {
          *mode = CLASS_REG_LONG;
          *reg = 14;
        }
d270 4
a273 4
        {
          *mode = CLASS_REG_WORD;
          *reg = 15;
        }
d279 3
a281 3
        {
          *mode = CLASS_REG_LONG;
          res = whatreg (reg, src + 2);
d284 2
a285 2
          	as_warn (_("register rr%d, out of range."),regno);
        }
d287 3
a289 3
        {
          *mode = CLASS_REG_BYTE;
          res = whatreg (reg, src + 2);
d292 2
a293 2
          	as_warn (_("register rh%d, out of range."),regno);
        }
d295 3
a297 3
        {
          *mode = CLASS_REG_BYTE;
          res = whatreg (reg, src + 2);
d300 3
a302 3
          	as_warn (_("register rl%d, out of range."),regno);
          *reg += 8;
        }
d304 3
a306 3
        {
          *mode = CLASS_REG_QUAD;
          res = whatreg (reg, src + 2);
d309 2
a310 2
          	as_warn (_("register rq%d, out of range."),regno);
        }
d312 3
a314 3
        {
          *mode = CLASS_REG_WORD;
          res = whatreg (reg, src + 1);
d317 2
a318 2
          	as_warn (_("register r%d, out of range."),regno);
        }
a320 1

d324 3
a326 3
DEFUN (parse_exp, (s, op),
       char *s AND
       expressionS * op)
a351 3



d354 4
a357 5
static
char *
DEFUN (checkfor, (ptr, what),
       char *ptr AND
       char what)
d362 2
a363 3
    {
      as_bad (_("expected %c"), what);
    }
d367 2
a368 1
/* Make sure the mode supplied is the size of a word */
d370 3
a372 3
DEFUN (regword, (mode, string),
       int mode AND
       char *string)
d383 2
a384 1
/* Make sure the mode supplied is the size of an address */
d386 3
a388 3
DEFUN (regaddr, (mode, string),
       int mode AND
       char *string)
d399 3
a401 4
struct ctrl_names
{
   int value;
   char *name;
d404 10
a413 11
struct ctrl_names ctrl_table[] =
{
   0x2, "fcw",
   0X3, "refresh",
   0x4, "psapseg",
   0x5, "psapoff",
   0x5, "psap",
   0x6, "nspseg",
   0x7, "nspoff",
   0x7, "nsp",
   0, 0
d415 1
a415 1
   
d417 4
a420 4
DEFUN (get_ctrl_operand, (ptr, mode, dst),
       char **ptr AND
       struct z8k_op *mode AND
       unsigned int dst)
a422 1
  int r;
d434 4
a437 4
        {
          if (ctrl_table[i].name[j] != src[j])
            goto fail;
        }
d441 2
a442 1
    fail:;
d448 1
a448 2
struct flag_names
{
d454 8
a461 9
struct flag_names flag_table[] =
{
  0x1, "p",
  0x1, "v",
  0x2, "s",
  0x4, "z",
  0x8, "c",
  0x0, "+",
  0, 0
d465 4
a468 4
DEFUN (get_flags_operand, (ptr, mode, dst),
       char **ptr AND
       struct z8k_op *mode AND
       unsigned int dst)
a470 1
  int r;
d481 1
a481 1
     if (!src[j])
d483 8
a490 8
     for (i = 0; flag_table[i].name; i++)
        {
          if (flag_table[i].name[0] == src[j])
		{
	        the_flags = the_flags | flag_table[i].value;
		goto match;
		}
        }
d493 1
a493 1
     ;
d495 1
a495 1
  done:
d500 1
a500 3

struct interrupt_names
{
d506 6
a511 7
struct interrupt_names intr_table[] =
{
  0x1, "nvi",
  0x2, "vi",
  0x3, "both",
  0x3, "all",
  0, 0
d515 4
a518 4
DEFUN (get_interrupt_operand, (ptr, mode, dst),
       char **ptr AND
       struct z8k_op *mode AND
       unsigned int dst)
a520 1
  int r;
d532 4
a535 4
        {
          if (intr_table[i].name[j] != src[j])
            goto fail;
        }
d539 2
a540 1
    fail:;
d546 1
a546 2
struct cc_names
{
d552 24
a575 25
struct cc_names table[] =
{
  0x0, "f",
  0x1, "lt",
  0x2, "le",
  0x3, "ule",
  0x4, "ov",
  0x4, "pe",
  0x5, "mi",
  0x6, "eq",
  0x6, "z",
  0x7, "c",
  0x7, "ult",
  0x8, "t",
  0x9, "ge",
  0xa, "gt",
  0xb, "ugt",
  0xc, "nov",
  0xc, "po",
  0xd, "pl",
  0xe, "ne",
  0xe, "nz",
  0xf, "nc",
  0xf, "uge",
  0, 0
d579 4
a582 4
DEFUN (get_cc_operand, (ptr, mode, dst),
       char **ptr AND
       struct z8k_op *mode AND
       unsigned int dst)
a584 1
  int r;
d603 2
a604 1
    fail:;
d613 1
a613 1
     unsigned int dst;
a616 3
  unsigned int num;
  unsigned int len;
  unsigned int size;
d652 1
a652 1
		  /* Got Ra(Rb) */
d656 1
a656 3
		    {
		      as_bad (_("Missing ) in ra(rb)"));
		    }
d658 1
a658 3
		    {
		      src++;
		    }
d661 3
a663 1
/*		  regword (mode->mode, "ra(rb) rb");*/
d671 1
a671 1
		  /* Got Ra(disp) */
d690 1
a690 1
	  /* No initial reg */
d705 1
a705 1
	      /* Just an address */
d716 1
a716 2
static
char *
d723 2
a724 1
char *savptr;
d735 3
a737 3
        {
          get_cc_operand (&ptr, operand + 0, 0);
        }
d739 7
a745 7
        {
          get_flags_operand (&ptr, operand + 0, 0);
        }
      else if (opcode->arg_info[0] == (CLASS_IMM +(ARG_IMM2)))
        {
          get_interrupt_operand (&ptr, operand + 0, 0);
        }
d747 3
a749 3
        {
          get_operand (&ptr, operand + 0, 0);
        }
d757 3
a759 3
        {
          get_cc_operand (&ptr, operand + 0, 0);
        }
d761 14
a774 14
             {
               get_ctrl_operand (&ptr, operand + 0, 0);
               if (the_ctrl == 0)
                 {
                   ptr = savptr;
                   get_operand (&ptr, operand + 0, 0);
                   if (ptr == 0)
                     return;
                   if (*ptr == ',')
                     ptr++;
                   get_ctrl_operand (&ptr, operand + 1, 1);
                   return ptr;
                 }
             }
d776 3
a778 3
        {
          get_operand (&ptr, operand + 0, 0);
        }
d780 1
a780 1
        return;
d782 1
a782 1
        ptr++;
d810 1
d819 2
a820 3
   addressing modes, return the opcode which matches the opcodes
   provided
   */
d822 4
a825 5
static
opcode_entry_type *
DEFUN (get_specific, (opcode, operands),
       opcode_entry_type * opcode AND
       op_type * operands)
d832 1
a832 2
  unsigned int dispreg;
  unsigned int this_index = opcode->idx;
d841 1
a841 1
	  int mode = operands[i].mode;
d845 2
a846 2
	      /* it could be an pc rel operand, if this is a da mode and
	   we like disps, then insert it */
d850 1
a850 1
		  /* This is the case */
d855 2
a856 2
		  /* Can't think of a way to turn what we've been given into
	     something that's ok */
d863 1
a863 1
		      /* ok */
d867 1
a867 1
		      /* ok */
d896 2
a897 1
    fail:;
d905 1
d907 4
a910 4
DEFUN (check_operand, (operand, width, string),
       struct z8k_op *operand AND
       unsigned int width AND
       char *string)
d916 4
a919 3
      /* No symbol involved, let's look at offset, it's dangerous if any of
       the high bits are not 0 or ff's, find out by oring or anding with
       the width and seeing if the answer is 0 or all fs*/
d923 2
a924 1
	  as_warn (_("operand %s0x%x out of range."), string, operand->exp.X_add_number);
d929 1
d934 4
a937 4
DEFUN (newfix, (ptr, type, operand),
       int ptr AND
       int type AND
       expressionS * operand)
d953 5
a957 5
DEFUN (apply_fix, (ptr, type, operand, size),
       char *ptr AND
       int type AND
       expressionS * operand AND
       int size)
a960 1
  operand->X_add_number = n;
a961 1
#if 1
d964 1
a964 1
    case 8:			/* 8 nibbles == 32 bits */
d969 1
a969 1
    case 4:			/* 4 niblles == 16 bits */
a977 1
#endif
d979 1
d981 1
a981 1
}
a982 2
/* Now we know what sort of opcodes it is, lets build the bytes -
 */
d984 1
d987 2
a988 2
     opcode_entry_type * this_try;
     struct z8k_op *operand;
a989 4
  unsigned int i;

  int length;
  char *output;
a990 1
  char part;
a991 1
  char high;
a1000 1
top:;
d1002 1
a1002 1
  for (nibble = 0; c = *class_ptr++; nibble++)
d1008 1
a1009 1
	  abort ();
d1011 1
a1011 1
	  /* Direct address, we don't cope with the SS mode right now */
d1014 1
a1014 1
	      da_operand->X_add_number |= 0x80000000;
d1024 1
a1024 1
	  /* pc rel 8 bit */
d1030 1
a1030 1
	  /* pc rel 7 bit */
d1037 1
a1037 1
	  /* pc rel 7 bit */
d1040 1
a1040 1
          output_ptr[-2] =  0x8;
d1049 1
a1049 3
		{
		  *output_ptr |= 2;
		}
d1051 1
a1051 3
		{
		  as_bad (_("immediate must be 1 or 2"));
		}
d1054 1
a1054 3
	    {
	      as_bad (_("immediate 1 or 2 expected"));
	    }
d1060 15
a1074 15
        case CLASS_0CCC:
          *output_ptr++ = the_ctrl;
          break;
        case CLASS_1CCC:
          *output_ptr++ = the_ctrl | 0x8;
          break;
        case CLASS_00II:
          *output_ptr++ = (~the_interrupt & 0x3);
          break;
        case CLASS_01II:
          *output_ptr++ = (~the_interrupt & 0x3) | 0x4;
          break;
        case CLASS_FLAGS:
          *output_ptr++ = the_flags;
          break;
d1080 2
a1081 3
	    {
	      as_bad (_("can't use R0 here"));
	    }
d1087 1
a1087 2
	  /* Insert bit mattern of
	 right reg */
d1091 11
a1101 1
	  output_ptr = apply_fix (output_ptr, R_IMM16, da_operand, 4);
d1141 1
a1141 2
  /* Copy from the nibble buffer into the frag */

a1152 1

a1153 1

d1157 2
a1158 3
   machine dependent instruction.  This funciton is supposed to emit
   the frags/bytes it assembles to.
   */
d1161 2
a1162 2
DEFUN (md_assemble, (str),
       char *str)
d1164 1
a1166 1
  unsigned int i;
d1171 1
a1171 4
  char *dot = 0;
  char c;

  /* Drop leading whitespace */
d1175 1
a1175 1
  /* find the op code end */
d1179 1
a1179 4
    {
    }

  ;
d1189 1
a1189 3
  opcode = (opcode_entry_type *) hash_find (opcode_hash_control,
					    op_start);

d1199 1
a1199 1
      /* was really a pseudo op */
a1206 1

d1221 1
a1221 2
      input_line_pointer = get_operands (opcode, op_end,
					 operand);
d1228 1
a1228 1
	  /* Couldn't find an opcode which matched the operands */
d1243 2
a1244 2
DEFUN (tc_crawl_symbol_chain, (headers),
       object_headers * headers)
d1250 2
a1251 2
DEFUN (md_undefined_symbol, (name),
       char *name)
d1257 2
a1258 2
DEFUN (tc_headers_hook, (headers),
       object_headers * headers)
d1263 2
a1264 2
/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
d1267 5
a1271 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
   */
d1328 1
d1332 2
a1333 1
size_t md_longopts_size = sizeof(md_longopts);
d1365 1
a1365 1
  fprintf(stream, _("\
d1380 3
a1382 3
     object_headers *headers;
     segT seg;
     fragS *fragP;
d1389 3
a1391 3
DEFUN (md_section_align, (seg, size),
       segT seg AND
       valueT size)
d1393 2
a1394 1
  return ((size + (1 << section_alignment[(int) seg]) - 1) & (-1 << section_alignment[(int) seg]));
d1414 4
a1417 1
      /*    if (val != 0) abort();*/
d1423 4
a1426 1
      /*    if (val != 0) abort();*/
a1456 1

d1462 2
a1463 2
     register fragS *fragP;
     register segT segment_type;
d1469 1
a1469 1
/* Put number into target byte order */
d1472 4
a1475 4
DEFUN (md_number_to_chars, (ptr, use, nbytes),
       char *ptr AND
       valueT use AND
       int nbytes)
d1479 1
d1482 1
a1482 1
     fixS *fixP;
d1489 1
a1489 1
     symbolS *s;
d1502 2
a1503 2
  if (fix_ptr->fx_addsy &&
      fix_ptr->fx_subsy) 
d1507 5
a1511 1
      if (S_GET_SEGMENT(add) != S_GET_SEGMENT(sub))
d1513 5
a1517 2
	  as_bad(_("Can't subtract symbols in different sections %s %s"),
		 S_GET_NAME(add), S_GET_NAME(sub));
a1518 6
      else {
	int diff = S_GET_VALUE(add) - S_GET_VALUE(sub);
	fix_ptr->fx_addsy = 0;
	fix_ptr->fx_subsy = 0;
	fix_ptr->fx_offset += diff;
      }
d1523 1
a1523 1
     to output it */
d1526 1
a1526 1
      /* cons likes to create reloc32's whatever the size of the reloc.. */
a1540 1

d1543 1
a1543 3
    {
      intr->r_type = fix_ptr->fx_r_type;
    }
a1552 1

@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 1
a2 1
   Copyright (C) 1992 Free Software Foundation.
d17 3
a19 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d75 1
a75 1
  frag_align (1, 0);
d290 1
a290 1
          	as_warn ("register rr%d, out of range.",regno);
d298 1
a298 1
          	as_warn ("register rh%d, out of range.",regno);
d306 1
a306 1
          	as_warn ("register rl%d, out of range.",regno);
d315 1
a315 1
          	as_warn ("register rq%d, out of range.",regno);
d323 1
a323 1
          	as_warn ("register r%d, out of range.",regno);
d341 1
a341 1
    as_bad ("missing operand");
d374 1
a374 1
      as_bad ("expected %c", what);
d390 1
a390 1
      as_bad ("register is wrong size for a word %s", string);
d405 1
a405 1
      as_bad ("register is wrong size for address %s", string);
d680 1
a680 1
		      as_bad ("Missing ) in ra(rb)");
d947 1
a947 1
	  as_warn ("operand %s0x%x out of range.", string, operand->exp.X_add_number);
d1086 1
a1086 1
		  as_bad ("immediate must be 1 or 2");
d1091 1
a1091 1
	      as_bad ("immediate 1 or 2 expected");
d1119 1
a1119 1
	      as_bad ("can't use R0 here");
d1223 1
a1223 1
      as_bad ("can't find opcode ");
d1235 1
a1235 1
      as_bad ("unknown opcode");
d1278 1
a1278 1
	  as_bad ("Can't find opcode to match operands");
d1290 1
a1290 1
  printf ("call to tc_crawl_symbol_chain \n");
d1304 1
a1304 1
  printf ("call to tc_headers_hook \n");
d1355 1
a1355 1
      return "Bad call to MD_ATOF()";
d1390 1
a1390 1
	  as_bad ("invalid architecture -z%s", arg);
d1406 1
a1406 1
  fprintf(stream, "\
d1409 1
a1409 1
-z8002			generate unsegmented code\n");
a1411 2
int md_short_jump_size;

d1415 1
a1415 1
  printf ("call to tc_aout_fix_to_chars \n");
a1419 21
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr;
     addressT to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}

void
d1425 1
a1425 1
  printf ("call to md_convert_frag \n");
a1494 1
int md_long_jump_size;
d1500 1
a1500 1
  printf ("call tomd_estimate_size_before_relax \n");
d1523 1
a1523 1
     struct symbol *s;
d1543 1
a1543 1
	  as_bad("Can't subtract symbols in different sections %s %s",
@


1.1
log
@Initial revision
@
text
@d1507 4
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@a1506 4
    case 0:
      md_number_to_chars (buf, val, fixP->fx_size);
      break;

@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d74 1
a74 1
  frag_align (1, 0, 0);
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999 Free Software Foundation.
d290 1
a290 1
          	as_warn (_("register rr%d, out of range."),regno);
d298 1
a298 1
          	as_warn (_("register rh%d, out of range."),regno);
d306 1
a306 1
          	as_warn (_("register rl%d, out of range."),regno);
d315 1
a315 1
          	as_warn (_("register rq%d, out of range."),regno);
d323 1
a323 1
          	as_warn (_("register r%d, out of range."),regno);
d341 1
a341 1
    as_bad (_("missing operand"));
d374 1
a374 1
      as_bad (_("expected %c"), what);
d390 1
a390 1
      as_bad (_("register is wrong size for a word %s"), string);
d405 1
a405 1
      as_bad (_("register is wrong size for address %s"), string);
d680 1
a680 1
		      as_bad (_("Missing ) in ra(rb)"));
d947 1
a947 1
	  as_warn (_("operand %s0x%x out of range."), string, operand->exp.X_add_number);
d1086 1
a1086 1
		  as_bad (_("immediate must be 1 or 2"));
d1091 1
a1091 1
	      as_bad (_("immediate 1 or 2 expected"));
d1119 1
a1119 1
	      as_bad (_("can't use R0 here"));
d1223 1
a1223 1
      as_bad (_("can't find opcode "));
d1235 1
a1235 1
      as_bad (_("unknown opcode"));
d1278 1
a1278 1
	  as_bad (_("Can't find opcode to match operands"));
d1290 1
a1290 1
  printf (_("call to tc_crawl_symbol_chain \n"));
d1304 1
a1304 1
  printf (_("call to tc_headers_hook \n"));
d1355 1
a1355 1
      return _("Bad call to MD_ATOF()");
d1390 1
a1390 1
	  as_bad (_("invalid architecture -z%s"), arg);
d1406 1
a1406 1
  fprintf(stream, _("\
d1409 1
a1409 1
-z8002			generate unsegmented code\n"));
d1412 2
d1417 1
a1417 1
  printf (_("call to tc_aout_fix_to_chars \n"));
d1422 21
d1448 1
a1448 1
  printf (_("call to md_convert_frag \n"));
d1518 1
d1524 1
a1524 1
  printf (_("call tomd_estimate_size_before_relax \n"));
d1547 1
a1547 1
     symbolS *s;
d1567 1
a1567 1
	  as_bad(_("Can't subtract symbols in different sections %s %s"),
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000
   Free Software Foundation, Inc.
d21 4
a24 2
/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

d34 6
a39 3
const char comment_chars[] = "!";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = ";";
d46 7
d71 2
a72 1
static void
d95 1
d115 1
d117 29
a145 35

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */

const pseudo_typeS md_pseudo_table[] = {
  {"int"    , cons            , 2},
  {"data.b" , cons            , 1},
  {"data.w" , cons            , 2},
  {"data.l" , cons            , 4},
  {"form"   , listing_psize   , 0},
  {"heading", listing_title   , 0},
  {"import" , s_ignore        , 0},
  {"page"   , listing_eject   , 0},
  {"program", s_ignore        , 0},
  {"z8001"  , s_segm          , 0},
  {"z8002"  , s_unseg         , 0},

  {"segm"   , s_segm          , 0},
  {"unsegm" , s_unseg         , 0},
  {"unseg"  , s_unseg         , 0},
  {"name"   , s_app_file      , 0},
  {"global" , s_globl         , 0},
  {"wval"   , cons            , 2},
  {"lval"   , cons            , 4},
  {"bval"   , cons            , 1},
  {"sval"   , sval            , 0},
  {"rsect"  , obj_coff_section, 0},
  {"sect"   , obj_coff_section, 0},
  {"block"  , s_space         , 0},
  {"even"   , even            , 0},
  {0        , 0               , 0}
d150 3
a152 3
/* Chars that mean this number is a floating point constant.
   As in 0f12.456
   or    0d1.2345e12  */
d155 1
a155 2
/* Opcode mnemonics.  */
static struct hash_control *opcode_hash_control;
d168 3
a170 1
      /* Only enter unique codes into the table.  */
d180 1
a180 1
  /* Default to z8002.  */
d183 1
a183 1
  /* Insert the pseudo ops, too.  */
d188 2
a189 2
      fake_opcode->name = md_pseudo_table[idx].poc_name;
      fake_opcode->func = (void *) (md_pseudo_table + idx);
d197 2
a198 1
struct z8k_exp {
d203 4
a206 7

typedef struct z8k_op {
  /* 'b','w','r','q'.  */
  char regsize;

  /* 0 .. 15.  */
  unsigned int reg;
d210 3
a212 2
  /* Any other register associated with the mode.  */
  unsigned int x_reg;
d214 1
a214 3
  /* Any expression.  */
  expressionS exp;
} op_type;
d226 3
a228 3
whatreg (reg, src)
     int *reg;
     char *src;
d242 2
a243 1
/* Parse operands
d245 10
a254 11
   rh0-rh7, rl0-rl7
   r0-r15
   rr0-rr14
   rq0--rq12
   WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp
   r0l,r0h,..r7l,r7h
   @@WREG
   @@WREG+
   @@-WREG
   #const
*/
d256 1
a256 2
/* Try to parse a reg name.  Return a pointer to the first character
   in SRC after the reg name.  */
d258 1
d260 4
a263 4
parse_reg (src, mode, reg)
     char *src;
     int *mode;
     unsigned int *reg;
d271 4
a274 4
	{
	  *mode = CLASS_REG_LONG;
	  *reg = 14;
	}
d276 4
a279 4
	{
	  *mode = CLASS_REG_WORD;
	  *reg = 15;
	}
d285 3
a287 3
	{
	  *mode = CLASS_REG_LONG;
	  res = whatreg (reg, src + 2);
d290 2
a291 2
	    as_warn (_("register rr%d, out of range."), regno);
	}
d293 3
a295 3
	{
	  *mode = CLASS_REG_BYTE;
	  res = whatreg (reg, src + 2);
d298 2
a299 2
	    as_warn (_("register rh%d, out of range."), regno);
	}
d301 3
a303 3
	{
	  *mode = CLASS_REG_BYTE;
	  res = whatreg (reg, src + 2);
d306 3
a308 3
	    as_warn (_("register rl%d, out of range."), regno);
	  *reg += 8;
	}
d310 3
a312 3
	{
	  *mode = CLASS_REG_QUAD;
	  res = whatreg (reg, src + 2);
d315 2
a316 2
	    as_warn (_("register rq%d, out of range."), regno);
	}
d318 3
a320 3
	{
	  *mode = CLASS_REG_WORD;
	  res = whatreg (reg, src + 1);
d323 2
a324 2
	    as_warn (_("register r%d, out of range."), regno);
	}
d327 1
d331 3
a333 3
parse_exp (s, op)
     char *s;
     expressionS *op;
d359 3
d364 5
a368 4
static char *
checkfor (ptr, what)
     char *ptr;
     char what;
d373 3
a375 2
    as_bad (_("expected %c"), what);

d379 1
a379 2
/* Make sure the mode supplied is the size of a word.  */

d381 3
a383 3
regword (mode, string)
     int mode;
     char *string;
d394 1
a394 2
/* Make sure the mode supplied is the size of an address.  */

d396 3
a398 3
regaddr (mode, string)
     int mode;
     char *string;
d409 4
a412 3
struct ctrl_names {
  int value;
  char *name;
d415 11
a425 10
struct ctrl_names ctrl_table[] = {
  { 0x2, "fcw" },
  { 0x3, "refresh" },
  { 0x4, "psapseg" },
  { 0x5, "psapoff" },
  { 0x5, "psap" },
  { 0x6, "nspseg" },
  { 0x7, "nspoff" },
  { 0x7, "nsp" },
  { 0  , 0 }
d427 1
a427 1

d429 4
a432 4
get_ctrl_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d435 1
d447 4
a450 4
	{
	  if (ctrl_table[i].name[j] != src[j])
	    goto fail;
	}
d454 1
a454 2
    fail:
      ;
d460 2
a461 1
struct flag_names {
d467 9
a475 8
struct flag_names flag_table[] = {
  { 0x1, "p" },
  { 0x1, "v" },
  { 0x2, "s" },
  { 0x4, "z" },
  { 0x8, "c" },
  { 0x0, "+" },
  { 0, 0 }
d479 4
a482 4
get_flags_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d485 1
d496 1
a496 1
      if (!src[j])
d498 8
a505 8
      for (i = 0; flag_table[i].name; i++)
	{
	  if (flag_table[i].name[0] == src[j])
	    {
	      the_flags = the_flags | flag_table[i].value;
	      goto match;
	    }
	}
d508 1
a508 1
      ;
d510 1
a510 1
 done:
d515 3
a517 1
struct interrupt_names {
d523 7
a529 6
struct interrupt_names intr_table[] = {
  { 0x1, "nvi" },
  { 0x2, "vi" },
  { 0x3, "both" },
  { 0x3, "all" },
  { 0, 0 }
d533 4
a536 4
get_interrupt_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d539 1
d551 4
a554 4
	{
	  if (intr_table[i].name[j] != src[j])
	    goto fail;
	}
d558 1
a558 2
    fail:
      ;
d564 2
a565 1
struct cc_names {
d571 25
a595 24
struct cc_names table[] = {
  { 0x0, "f" },
  { 0x1, "lt" },
  { 0x2, "le" },
  { 0x3, "ule" },
  { 0x4, "ov" },
  { 0x4, "pe" },
  { 0x5, "mi" },
  { 0x6, "eq" },
  { 0x6, "z" },
  { 0x7, "c" },
  { 0x7, "ult" },
  { 0x8, "t" },
  { 0x9, "ge" },
  { 0xa, "gt" },
  { 0xb, "ugt" },
  { 0xc, "nov" },
  { 0xc, "po" },
  { 0xd, "pl" },
  { 0xe, "ne" },
  { 0xe, "nz" },
  { 0xf, "nc" },
  { 0xf, "uge" },
  { 0  ,  0 }
d599 4
a602 4
get_cc_operand (ptr, mode, dst)
     char **ptr;
     struct z8k_op *mode;
     unsigned int dst ATTRIBUTE_UNUSED;
d605 1
d624 1
a624 2
    fail:
      ;
d633 1
a633 1
     unsigned int dst ATTRIBUTE_UNUSED;
d637 3
d675 1
a675 1
		  /* Got Ra(Rb).  */
d679 3
a681 1
		    as_bad (_("Missing ) in ra(rb)"));
d683 3
a685 1
		    src++;
d688 1
a688 3
#if 0
		  regword (mode->mode, "ra(rb) rb");
#endif
d696 1
a696 1
		  /* Got Ra(disp).  */
d715 1
a715 1
	  /* No initial reg.  */
d730 1
a730 1
	      /* Just an address.  */
d741 2
a742 1
static char *
d749 1
a749 2
  char *savptr;

d760 3
a762 3
	{
	  get_cc_operand (&ptr, operand + 0, 0);
	}
d764 7
a770 7
	{
	  get_flags_operand (&ptr, operand + 0, 0);
	}
      else if (opcode->arg_info[0] == (CLASS_IMM + (ARG_IMM2)))
	{
	  get_interrupt_operand (&ptr, operand + 0, 0);
	}
d772 3
a774 3
	{
	  get_operand (&ptr, operand + 0, 0);
	}
d782 3
a784 3
	{
	  get_cc_operand (&ptr, operand + 0, 0);
	}
d786 14
a799 14
	{
	  get_ctrl_operand (&ptr, operand + 0, 0);
	  if (the_ctrl == 0)
	    {
	      ptr = savptr;
	      get_operand (&ptr, operand + 0, 0);
	      if (ptr == 0)
		return NULL;
	      if (*ptr == ',')
		ptr++;
	      get_ctrl_operand (&ptr, operand + 1, 1);
	      return ptr;
	    }
	}
d801 3
a803 3
	{
	  get_operand (&ptr, operand + 0, 0);
	}
d805 1
a805 1
	return NULL;
d807 1
a807 1
	ptr++;
a834 1

d843 3
a845 2
   addressing modes.  Return the opcode which matches the opcodes
   provided.  */
d847 5
a851 4
static opcode_entry_type *
get_specific (opcode, operands)
     opcode_entry_type *opcode;
     op_type *operands;
d858 2
a859 1
  int this_index = opcode->idx;
d868 1
a868 1
	  unsigned int mode = operands[i].mode;
d872 2
a873 2
	      /* It could be an pc rel operand, if this is a da mode
		 and we like disps, then insert it.  */
d877 1
a877 1
		  /* This is the case.  */
d882 2
a883 2
		  /* Can't think of a way to turn what we've been
		     given into something that's OK.  */
d890 1
a890 1
		      /* OK.  */
d894 1
a894 1
		      /* OK.  */
d923 1
a923 2
    fail:
      ;
a930 1
#if 0 /* Not used.  */
d932 4
a935 4
check_operand (operand, width, string)
     struct z8k_op *operand;
     unsigned int width;
     char *string;
d941 3
a943 4
      /* No symbol involved, let's look at offset, it's dangerous if
	 any of the high bits are not 0 or ff's, find out by oring or
	 anding with the width and seeing if the answer is 0 or all
	 fs.  */
d947 1
a947 2
	  as_warn (_("operand %s0x%x out of range."),
		   string, operand->exp.X_add_number);
a951 1
#endif
d956 4
a959 4
newfix (ptr, type, operand)
     int ptr;
     int type;
     expressionS *operand;
d975 5
a979 5
apply_fix (ptr, type, operand, size)
     char *ptr;
     int type;
     expressionS *operand;
     int size;
d983 1
d985 1
d988 1
a988 1
    case 8:			/* 8 nibbles == 32 bits.  */
d993 1
a993 1
    case 4:			/* 4 nibbles == 16 bits.  */
d1002 1
d1004 1
d1007 2
a1008 2
/* Now we know what sort of opcodes it is.  Let's build the bytes.  */

a1009 1

d1012 2
a1013 2
     opcode_entry_type *this_try;
     struct z8k_op *operand ATTRIBUTE_UNUSED;
d1015 4
d1020 1
d1022 1
d1032 1
d1034 1
a1034 1
  for (nibble = 0; (c = *class_ptr++); nibble++)
d1040 1
a1041 1

d1043 1
a1043 1
	  /* Direct address, we don't cope with the SS mode right now.  */
d1046 1
a1046 1
	      /* da_operand->X_add_number |= 0x80000000;  --  Now set at relocation time.  */
d1056 1
a1056 1
	  /* pc rel 8 bit  */
d1062 1
a1062 1
	  /* pc rel 7 bit  */
d1069 1
a1069 1
	  /* pc rel 7 bit  */
d1072 1
a1072 1
	  output_ptr[-2] = 0x8;
d1081 3
a1083 1
		*output_ptr |= 2;
d1085 3
a1087 1
		as_bad (_("immediate must be 1 or 2"));
d1090 3
a1092 1
	    as_bad (_("immediate 1 or 2 expected"));
d1098 15
a1112 15
	case CLASS_0CCC:
	  *output_ptr++ = the_ctrl;
	  break;
	case CLASS_1CCC:
	  *output_ptr++ = the_ctrl | 0x8;
	  break;
	case CLASS_00II:
	  *output_ptr++ = (~the_interrupt & 0x3);
	  break;
	case CLASS_01II:
	  *output_ptr++ = (~the_interrupt & 0x3) | 0x4;
	  break;
	case CLASS_FLAGS:
	  *output_ptr++ = the_flags;
	  break;
d1118 3
a1120 2
	    as_bad (_("can't use R0 here"));
	  /* Fall through.  */
d1126 2
a1127 1
	  /* Insert bit mattern of right reg.  */
d1131 1
a1131 11
          switch (c & ARG_MASK)
            {
            case ARG_DISP12:
              output_ptr = apply_fix (output_ptr, R_CALLR, da_operand, 4);
              break;
            case ARG_DISP16:
	      output_ptr = apply_fix (output_ptr, R_REL16, da_operand, 4);
	      break;
	    default:
	      output_ptr = apply_fix (output_ptr, R_IMM16, da_operand, 4);
	    }
d1171 2
a1172 1
  /* Copy from the nibble buffer into the frag.  */
d1184 1
d1186 1
d1190 3
a1192 2
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */
d1195 2
a1196 2
md_assemble (str)
     char *str;
a1197 1
  char c;
d1200 1
d1205 4
a1208 1
  /* Drop leading whitespace.  */
d1212 1
a1212 1
  /* Find the op code end.  */
d1216 4
a1219 1
    ;
d1229 3
a1231 1
  opcode = (opcode_entry_type *) hash_find (opcode_hash_control, op_start);
d1241 1
a1241 1
      /* Was really a pseudo op.  */
d1249 1
d1264 2
a1265 1
      input_line_pointer = get_operands (opcode, op_end, operand);
d1272 1
a1272 1
	  /* Couldn't find an opcode which matched the operands.  */
d1287 2
a1288 2
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d1294 2
a1295 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1301 2
a1302 2
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d1307 2
a1308 2
/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
d1311 4
a1314 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

a1370 1

d1374 1
a1374 2

size_t md_longopts_size = sizeof (md_longopts);
d1406 1
a1406 1
  fprintf (stream, _("\
d1421 3
a1423 3
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d1430 3
a1432 3
md_section_align (seg, size)
     segT seg;
     valueT size;
d1434 1
a1434 2
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
d1454 1
a1454 4
#if 0
      if (val != 0)
	abort ();
#endif
d1460 1
a1460 4
#if 0
      if (val != 0)
	abort ();
#endif
d1491 1
d1497 2
a1498 2
     register fragS *fragP ATTRIBUTE_UNUSED;
     register segT segment_type ATTRIBUTE_UNUSED;
d1504 1
a1504 1
/* Put number into target byte order.  */
d1507 4
a1510 4
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
a1513 1

d1516 1
a1516 1
     fixS *fixP ATTRIBUTE_UNUSED;
d1523 1
a1523 1
     symbolS *s ATTRIBUTE_UNUSED;
d1536 2
a1537 2
  if (fix_ptr->fx_addsy
      && fix_ptr->fx_subsy)
d1541 1
a1541 5

      if (S_GET_SEGMENT (add) != S_GET_SEGMENT (sub))
	as_bad (_("Can't subtract symbols in different sections %s %s"),
		S_GET_NAME (add), S_GET_NAME (sub));
      else
d1543 2
a1544 5
	  int diff = S_GET_VALUE (add) - S_GET_VALUE (sub);

	  fix_ptr->fx_addsy = 0;
	  fix_ptr->fx_subsy = 0;
	  fix_ptr->fx_offset += diff;
d1546 6
d1556 1
a1556 1
     to output it.  */
d1559 1
a1559 1
      /* cons likes to create reloc32's whatever the size of the reloc.  */
d1574 1
d1577 3
a1579 1
    intr->r_type = fix_ptr->fx_r_type;
d1589 1
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001, 2002, 2003
d27 2
d31 1
a31 2
#include "safe-ctype.h"
#include "opcodes/z8k-opc.h"
d42 1
a42 2
/* This is non-zero if target was set from the command line.  */
static int z8k_target_from_cmdline;
d44 2
a45 8
static void s_segm PARAMS ((int));
static void even PARAMS ((int));
static int tohex PARAMS ((int));
static void sval PARAMS ((int));

static void
s_segm (segm)
     int segm;
a46 2
  if (segm)
    {
d50 5
a54 3
    }
  else
    {
a57 1
    }
d61 1
a61 2
even (ignore)
     int ignore ATTRIBUTE_UNUSED;
d67 3
a69 1
static int
d73 1
a73 1
  if (ISDIGIT (c))
d75 1
a75 1
  if (ISLOWER (c))
d80 2
a81 3
static void
sval (ignore)
     int ignore ATTRIBUTE_UNUSED;
d121 2
a122 2
  {"z8001"  , s_segm          , 1},
  {"z8002"  , s_segm          , 0},
d124 3
a126 3
  {"segm"   , s_segm          , 1},
  {"unsegm" , s_segm          , 0},
  {"unseg"  , s_segm          , 0},
d153 3
a155 2
  const opcode_entry_type *opcode;
  int idx = -1;
d162 7
a168 3
      if (idx != opcode->idx)
	hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
      idx = opcode->idx;
d172 1
a172 2
  if (! z8k_target_from_cmdline)
    s_segm (0);
d184 2
d219 1
a219 28
static char *whatreg PARAMS ((int *, char *));
static char *parse_reg PARAMS ((char *, int *, unsigned int *));
static char *parse_exp PARAMS ((char *, expressionS *));
static char *checkfor PARAMS ((char *, char));
static void regword PARAMS ((int, char *));
static void regaddr PARAMS ((int, char *));
static void get_ctrl_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_flags_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_interrupt_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_cc_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static void get_operand
  PARAMS ((char **, struct z8k_op *, unsigned int));
static char *get_operands
  PARAMS ((const opcode_entry_type *, char *, op_type *));
static opcode_entry_type *get_specific
  PARAMS ((opcode_entry_type *, op_type *));
static void newfix
  PARAMS ((int, int, int, expressionS *));
static char *apply_fix
  PARAMS ((char *, int, expressionS *, int));
static void build_bytes
  PARAMS ((opcode_entry_type *, struct z8k_op *));

static char *
d224 1
a224 1
  if (ISDIGIT (src[1]))
d253 1
a253 1
static char *
d262 1
a262 1
  if (src[0] == 's' && src[1] == 'p' && (src[2] == 0 || src[2] == ','))
a279 2
	  if (src[2] < '0' || src[2] > '9')
	    return res;	 /* Assume no register name but a label starting with 'rr'.  */
a287 2
	  if (src[2] < '0' || src[2] > '9')
	    return res;	 /* Assume no register name but a label starting with 'rh'.  */
a295 2
	  if (src[2] < '0' || src[2] > '9')
	    return res;	 /* Assume no register name but a label starting with 'rl'.  */
a304 2
	  if (src[2] < '0' || src[2] > '9')
	    return res;	 /* Assume no register name but a label starting with 'rq'.  */
a312 2
	  if (src[1] < '0' || src[1] > '9')
	    return res;	 /* Assume no register name but a label starting with 'r'.  */
d323 1
a323 1
static char *
a541 2
  /* No interrupt type specified, opcode won't do anything.  */
  as_warn (_("opcode has no effect."));
d549 1
d718 1
a718 1
     const opcode_entry_type *opcode;
a724 1
  ptr++;
d733 1
d735 3
a737 2
	get_cc_operand (&ptr, operand + 0, 0);

d739 3
a741 2
	get_flags_operand (&ptr, operand + 0, 0);

d743 3
a745 2
	get_interrupt_operand (&ptr, operand + 0, 0);

d747 3
a749 2
	get_operand (&ptr, operand + 0, 0);

d754 1
d757 3
a759 2
	get_cc_operand (&ptr, operand + 0, 0);

a762 1

a766 1

d776 3
a778 2
	get_operand (&ptr, operand + 0, 0);

d787 1
d798 1
d826 1
d845 1
a845 1
	      /* It could be a pc rel operand, if this is a da mode
d934 1
a934 1
newfix (ptr, type, size, operand)
a936 1
     int size;   /* nibbles.  */
d945 1
a945 1
		   size / 2,
d957 1
a957 1
     int size;   /* nibbles.  */
d959 1
a959 1
  long n = operand->X_add_number;
d961 1
a961 1
  newfix ((ptr - buffer) / 2, type, size + 1, operand);
d992 1
d999 1
a999 1
  memset (buffer, 0, sizeof (buffer));
a1074 1
	case CLASS_IGNORE:
d1107 1
d1110 1
a1110 6
	      case ARG_NIM4:
                if (imm_operand->X_add_number > 15)
                  {
                    as_bad (_("immediate value out of range"));
                  }
		imm_operand->X_add_number = -imm_operand->X_add_number;
a1112 1
              /*case ARG_IMMNMINUS1: not used.  */
d1115 4
a1118 6
                /* Drop through.  */
	      case ARG_IMM4:
                if (imm_operand->X_add_number > 15)
                  {
                    as_bad (_("immediate value out of range"));
                  }
a1122 1
                /* Drop through.  */
d1129 1
d1133 1
d1199 2
d1203 1
a1206 2
      /* Was really a pseudo op.  */

d1221 2
a1222 6
      char *new_input_line_pointer;

      new_input_line_pointer = get_operands (opcode, op_end, operand);
      if (new_input_line_pointer)
        input_line_pointer = new_input_line_pointer;
      prev_opcode = opcode; /* XXX is this used ?? */
a1248 2
/* We have no need to default values of symbols.  */

d1282 1
d1327 1
a1327 1
const char *md_shortopts = "z:";
d1329 3
a1331 6
struct option md_longopts[] =
  {
#define OPTION_RELAX  (OPTION_MD_BASE)
    {"linkrelax", no_argument, NULL, OPTION_RELAX},
    {NULL, no_argument, NULL, 0}
  };
d1344 1
a1344 1
	s_segm (1);
d1346 1
a1346 1
	s_segm (0);
a1351 5
      z8k_target_from_cmdline = 1;
      break;

    case OPTION_RELAX:
      linkrelax = 1;
d1366 3
a1368 4
 Z8K options:\n\
  -z8001                  generate segmented code\n\
  -z8002                  generate unsegmented code\n\
  -linkrelax              create linker relaxable code\n"));
d1372 7
d1384 1
a1384 1
  printf (_("call to md_convert_frag\n"));
d1395 1
d1399 3
a1401 4
md_apply_fix3 (fixP, valP, segment)
     fixS * fixP;
     valueT * valP;
     segT segment ATTRIBUTE_UNUSED;
a1402 1
  long val = * (long *) valP;
d1408 1
a1408 1
      buf[0] = (buf[0] & 0xf0) | (val & 0xf);
d1412 1
a1412 6
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
      if (val & 1)
        as_bad (_("cannot branch to odd address"));
      val /= 2;
      if (val > 127 || val < -128)
        as_bad (_("relative jump out of range"));
d1414 4
a1417 1
      fixP->fx_no_overflow = 1;
a1420 9
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
      if (val & 1)
        as_bad (_("cannot branch to odd address"));
      val /= 2;
      if (val > 0 || val < -128)
        as_bad (_("relative jump out of range"));
      *buf = (*buf & 0x80) | (val & 0x7f);
      fixP->fx_no_overflow = 1;
      break;
d1422 5
a1426 6
    case R_CALLR:
      if (val > 8191 || val < -8192)
        as_bad (_("relative call out of range"));
      val = -val;
      *buf++ = (buf[0] & 0xf0) | ((val >> 8) & 0xf);
      *buf++ = val & 0xff;
d1430 1
a1430 1
      *buf++ = val;
a1431 1

a1435 1

a1441 10

    case R_REL16:
      val = val - fixP->fx_frag->fr_address + fixP->fx_where - fixP->fx_size;
      if (val > 32767 || val < -32768)
        as_bad (_("relative address out of range"));
      *buf++ = (val >> 8);
      *buf++ = val;
      fixP->fx_no_overflow = 1;
      break;

a1455 1
      printf(_("md_apply_fix3: unknown r_type 0x%x\n"), fixP->fx_r_type);
a1457 3

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
d1465 1
a1465 1
  printf (_("call to md_estimate_size_before_relax\n"));
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d44 5
d50 2
a51 1
s_segm (int segm)
d55 3
a57 3
      segmented_mode = 1;
      machine = bfd_mach_z8001;
      coff_flags = F_Z8001;
d61 3
a63 3
      segmented_mode = 0;
      machine = bfd_mach_z8002;
      coff_flags = F_Z8002;
d68 2
a69 1
even (int ignore ATTRIBUTE_UNUSED)
d76 2
a77 1
tohex (int c)
d87 2
a88 1
sval (int ignore ATTRIBUTE_UNUSED)
d158 1
a158 1
md_begin (void)
d189 6
d196 2
a197 2
  /* CLASS_REG_xxx.  */
  int regsize;
d214 32
a245 5
static int reg[16];
static int the_cc;
static int the_ctrl;
static int the_flags;
static int the_interrupt;
d248 3
a250 1
whatreg (int *reg, char *src)
d282 4
a285 1
parse_reg (char *src, int *mode, unsigned int *reg)
d290 1
a290 4
  /* Check for stack pointer "sp" alias.  */
  if ((src[0] == 's' || src[0] == 'S')
      && (src[1] == 'p' || src[1] == 'P')
      && (src[2] == 0 || src[2] == ','))
d304 1
a304 2

  if (src[0] == 'r' || src[0] == 'R')
d306 1
a306 1
      if (src[1] == 'r' || src[1] == 'R')
d314 1
a314 3
	    as_bad (_("register rr%d out of range"), regno);
	  if (regno & 1)
	    as_bad (_("register rr%d does not exist"), regno);
d316 1
a316 1
      else if (src[1] == 'h' || src[1] == 'H')
d324 1
a324 1
	    as_bad (_("register rh%d out of range"), regno);
d326 1
a326 1
      else if (src[1] == 'l' || src[1] == 'L')
d334 1
a334 1
	    as_bad (_("register rl%d out of range"), regno);
d337 1
a337 1
      else if (src[1] == 'q' || src[1] == 'Q')
d345 1
a345 3
	    as_bad (_("register rq%d out of range"), regno);
	  if (regno & 3)
	    as_bad (_("register rq%d does not exist"), regno);
d355 1
a355 1
	    as_bad (_("register r%d out of range"), regno);
d362 3
a364 1
parse_exp (char *s, expressionS *op)
d393 3
a395 1
checkfor (char *ptr, char what)
d408 3
a410 1
regword (int mode, char *string)
d424 3
a426 1
regaddr (int mode, char *string)
d442 2
a443 3
static struct ctrl_names ctrl_table[] = {
  { 0x1, "flags" },   /* ldctlb only.  */
  { 0x2, "fcw" },     /* ldctl only.  Applies to all remaining control registers.  */
d455 4
a458 1
get_ctrl_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
d461 1
a461 1
  int i, l;
d469 12
a480 9
      l = strlen (ctrl_table[i].name);
      if (! strncasecmp (ctrl_table[i].name, src, l))
        {
          the_ctrl = ctrl_table[i].value;
          if (*(src + l) && *(src + l) != ',')
            break;
          *ptr = src + l;  /* Valid control name found: "consume" it.  */
          return;
        }
d483 1
d489 1
d492 6
a497 6
static struct flag_names flag_table[] = {
  { 0x1, "P" },
  { 0x1, "V" },
  { 0x2, "S" },
  { 0x4, "Z" },
  { 0x8, "C" },
a498 1
  { 0x0, "," },
d503 4
a506 1
get_flags_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
a508 1
  char c;
a520 1
      c = TOUPPER(src[j]);
d523 1
a523 1
	  if (flag_table[i].name[0] == c)
d535 1
d541 1
d544 1
a544 1
static struct interrupt_names intr_table[] = {
d553 4
a556 1
get_interrupt_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
d559 1
a559 1
  int i, l;
d565 3
a567 1
  the_interrupt = 0;
d569 1
a569 28
  while (*src)
    {
      for (i = 0; intr_table[i].name; i++)
	{
	  l = strlen (intr_table[i].name);
	  if (! strncasecmp (intr_table[i].name, src, l))
	    {
	      the_interrupt |= intr_table[i].value;
	      if (*(src + l) && *(src + l) != ',')
		{
		  *ptr = src + l;
		invalid:
		  as_bad (_("unknown interrupt %s"), src);
		  while (**ptr && ! is_end_of_line[(unsigned char) **ptr])
		    (*ptr)++;	 /* Consume rest of line.  */
		  return;
		}
	      src += l;
	      if (! *src)
		{
		  *ptr = src;
		  return;
		}
	    }
	}
      if (*src == ',')
	src++;
      else
d571 2
a572 2
	  *ptr = src;
	  goto invalid;
d574 5
a579 1

d581 1
a581 1
  as_warn (_("opcode has no effect"));
d583 1
d591 1
a591 1
static struct cc_names table[] = {
a595 1
  { 0x4, "ov/pe" },
a596 1
  { 0x4, "pe/ov" },
a600 1
  { 0x7, "c/ult" },
a601 1
  { 0x7, "ult/c" },
a606 1
  { 0xc, "nov/po" },
a607 1
  { 0xc, "po/nov" },
a611 1
  { 0xf, "nc/uge" },
a612 1
  { 0xf, "uge/nc" },
d618 4
a621 1
get_cc_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
d624 1
a624 1
  int i, l;
d632 12
a643 9
      l = strlen (table[i].name);
      if (! strncasecmp (table[i].name, src, l))
        {
          the_cc = table[i].value;
          if (*(src + l) && *(src + l) != ',')
            break;
          *ptr = src + l;  /* Valid cc found: "consume" it.  */
          return;
        }
d645 1
a645 1
  the_cc = 0x8;  /* Not recognizing the cc defaults to t.  (Assuming no cc present.)  */
d649 4
a652 1
get_operand (char **ptr, struct z8k_op *mode, unsigned int dst ATTRIBUTE_UNUSED)
d669 2
d672 1
a672 1
      src = parse_reg (src + 1, &mode->regsize, &mode->reg);
d756 4
a759 1
get_operands (const opcode_entry_type *opcode, char *op_end, op_type *operand)
d764 1
a769 2
      while (*ptr == ' ')
        ptr++;
d774 2
a775 11
        {
          get_cc_operand (&ptr, operand + 0, 0);
          while (*ptr == ' ')
            ptr++;
          if (*ptr && ! is_end_of_line[(unsigned char) *ptr])
            {
              as_bad (_("invalid condition code '%s'"), ptr);
              while (*ptr && ! is_end_of_line[(unsigned char) *ptr])
                ptr++;   /* Consume rest of line.  */
            }
        }
d777 2
a778 11
	{
	  get_flags_operand (&ptr, operand + 0, 0);
	  while (*ptr == ' ')
	    ptr++;
	  if (*ptr && ! is_end_of_line[(unsigned char) *ptr])
	    {
	      as_bad (_("invalid flag '%s'"), ptr);
	      while (*ptr && ! is_end_of_line[(unsigned char) *ptr])
		ptr++;	 /* Consume rest of line.  */
	    }
	}
d781 1
d791 2
a792 14
        {
          get_cc_operand (&ptr, operand + 0, 0);
          while (*ptr == ' ')
            ptr++;
          if (*ptr != ',' && strchr (ptr + 1, ','))
            {
              savptr = ptr;
              while (*ptr != ',')
                ptr++;
              *ptr = 0;
              ptr++;
              as_bad (_("invalid condition code '%s'"), savptr);
            }
        }
a806 2
	      if (the_ctrl == 0)
		return NULL;
d855 3
a857 1
get_specific (opcode_entry_type *opcode, op_type *operands)
a873 5
          if (((mode & CLASS_MASK) == CLASS_IR) && ((this_try->arg_info[i] & CLASS_MASK) == CLASS_IRO))
            {
              mode = operands[i].mode = (operands[i].mode & ~CLASS_MASK) | CLASS_IRO;
            }

d910 1
a910 5
	    case CLASS_IRO:
	      if (operands[i].regsize != CLASS_REG_WORD)
		as_bad (_("invalid indirect register size"));
	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
	      break;
a911 6
	      if ((segmented_mode && operands[i].regsize != CLASS_REG_LONG)
		  || (!segmented_mode && operands[i].regsize != CLASS_REG_WORD))
		as_bad (_("invalid indirect register size"));
	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
	      break;
	    case CLASS_X:
a922 4
	    case CLASS_CTRL:
	      if (this_try->opcode == OPC_ldctlb && the_ctrl != 1)
		as_bad (_("invalid control register name"));
	      break;
d936 26
d965 5
a969 1
newfix (int ptr, int type, int size, expressionS *operand)
a970 4
  int is_pcrel = 0;

  /* size is in nibbles.  */

a974 7
      switch(type)
        {
        case R_JR:
        case R_DISP7:
        case R_CALLR:
          is_pcrel = 1;
        }
d979 1
a979 1
		   is_pcrel,
d985 5
a989 1
apply_fix (char *ptr, int type, expressionS *operand, int size)
a992 2
  /* size is in nibbles.  */

d1018 3
a1020 1
build_bytes (opcode_entry_type *this_try, struct z8k_op *operand ATTRIBUTE_UNUSED)
a1091 2
	  if (the_ctrl < 2 || the_ctrl > 7)
	    as_bad (_("invalid control register name"));
a1094 2
	  if (the_ctrl < 2 || the_ctrl > 7)
	    as_bad (_("invalid control register name"));
d1199 2
a1200 1
md_assemble (char *str)
d1207 1
d1215 1
a1215 1
       *op_end != 0 && *op_end != ' ' && ! is_end_of_line[(unsigned char) *op_end];
d1225 1
a1225 1
  *op_end = 0;  /* Zero-terminate op code string for hash_find() call.  */
a1234 2
  *op_end = c;  /* Restore original string.  */

d1240 1
d1263 1
d1284 2
a1285 1
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
d1293 2
a1294 1
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
d1300 2
a1301 1
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
d1316 4
a1319 1
md_atof (int type, char *litP, int *sizeP)
d1381 3
a1383 1
md_parse_option (int c, char *arg)
d1412 2
a1413 1
md_show_usage (FILE *stream)
d1423 4
a1426 3
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED,
                 segT seg ATTRIBUTE_UNUSED,
                 fragS *fragP ATTRIBUTE_UNUSED)
d1433 3
a1435 1
md_section_align (segT seg, valueT size)
a1440 3
/* Attempt to simplify or eliminate a fixup. To indicate that a fixup
   has been eliminated, set fix->fx_done. If fix->fx_addsy is non-NULL,
   we will have to generate a reloc entry.  */
d1442 4
a1445 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT segment ATTRIBUTE_UNUSED)
d1457 1
a1457 7
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
d1462 1
a1462 1
            as_warn (_("relative jump out of range"));
a1464 2
          fixP->fx_done = 1;
        }
d1468 8
a1475 16
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          if (val & 1)
            as_bad (_("cannot branch to odd address"));
          val /= 2;
          if (val > 0 || val < -127)
            as_bad (_("relative jump out of range"));
          *buf = (*buf & 0x80) | (-val & 0x7f);
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 1;
        }
d1479 5
a1483 18
      if (fixP->fx_addsy)
        {
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 0;
        }
      else
        {
          if (val & 1)
            as_bad (_("cannot branch to odd address"));
          if (val > 4096 || val < -4095)
            as_bad (_("relative call out of range"));
          val = -val / 2;
          *buf = (*buf & 0xf0) | ((val >> 8) & 0xf);
          buf++;
          *buf++ = val & 0xff;
          fixP->fx_no_overflow = 1;
          fixP->fx_done = 1;
        }
d1534 3
a1536 2
md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED,
                               segT segment_type ATTRIBUTE_UNUSED)
d1545 4
a1548 1
md_number_to_chars (char *ptr, valueT use, int nbytes)
a1552 2
/* On the Z8000, a PC-relative offset is relative to the address of the
   instruction plus its size.  */
d1554 2
a1555 1
md_pcrel_from (fixS *fixP)
d1557 1
a1557 1
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
d1561 2
a1562 1
tc_coff_symbol_emit_hook (symbolS *s ATTRIBUTE_UNUSED)
d1567 5
a1571 1
tc_reloc_mangle (fixS *fix_ptr, struct internal_reloc *intr, bfd_vma base)
@


