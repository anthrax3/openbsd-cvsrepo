head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.30;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.31;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.37;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.53;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.06.17;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.12;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.12;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.50;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.45.14;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.23.22;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.46.30;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.36.57;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.33;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-sh.c -- Assemble code for the Renesas / SuperH SH
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004  Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>  */

#include <stdio.h>
#include "as.h"
#include "bfd.h"
#include "subsegs.h"
#define DEFINE_TABLE
#include "opcodes/sh-opc.h"
#include "safe-ctype.h"
#include "struc-symbol.h"

#ifdef OBJ_ELF
#include "elf/sh.h"
#endif

#include "dwarf2dbg.h"
#include "dw2gencfi.h"

typedef struct
  {
    sh_arg_type type;
    int reg;
    expressionS immediate;
  }
sh_operand_info;

const char comment_chars[] = "!";
const char line_separator_chars[] = ";";
const char line_comment_chars[] = "!#";

static void s_uses (int);
static void s_uacons (int);

#ifdef OBJ_ELF
static void sh_elf_cons (int);

symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
#endif

static void
big (int ignore ATTRIBUTE_UNUSED)
{
  if (! target_big_endian)
    as_bad (_("directive .big encountered when option -big required"));

  /* Stop further messages.  */
  target_big_endian = 1;
}

static void
little (int ignore ATTRIBUTE_UNUSED)
{
  if (target_big_endian)
    as_bad (_("directive .little encountered when option -little required"));

  /* Stop further messages.  */
  target_big_endian = 0;
}

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
#ifdef OBJ_ELF
  {"long", sh_elf_cons, 4},
  {"int", sh_elf_cons, 4},
  {"word", sh_elf_cons, 2},
  {"short", sh_elf_cons, 2},
#else
  {"int", cons, 4},
  {"word", cons, 2},
#endif /* OBJ_ELF */
  {"big", big, 0},
  {"form", listing_psize, 0},
  {"little", little, 0},
  {"heading", listing_title, 0},
  {"import", s_ignore, 0},
  {"page", listing_eject, 0},
  {"program", s_ignore, 0},
  {"uses", s_uses, 0},
  {"uaword", s_uacons, 2},
  {"ualong", s_uacons, 4},
  {"uaquad", s_uacons, 8},
  {"2byte", s_uacons, 2},
  {"4byte", s_uacons, 4},
  {"8byte", s_uacons, 8},
#ifdef HAVE_SH64
  {"mode", s_sh64_mode, 0 },

  /* Have the old name too.  */
  {"isa", s_sh64_mode, 0 },

  /* Assert that the right ABI is used.  */
  {"abi", s_sh64_abi, 0 },

  { "vtable_inherit", sh64_vtable_inherit, 0 },
  { "vtable_entry", sh64_vtable_entry, 0 },
#endif /* HAVE_SH64 */
  {0, 0, 0}
};

/*int md_reloc_size; */

int sh_relax;		/* set if -relax seen */

/* Whether -small was seen.  */

int sh_small;

/* Flag to generate relocations against symbol values for local symbols.  */

static int dont_adjust_reloc_32;

/* preset architecture set, if given; zero otherwise.  */

static int preset_target_arch;

/* The bit mask of architectures that could
   accommodate the insns seen so far.  */
static int valid_arch;

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

#define C(a,b) ENCODE_RELAX(a,b)

#define ENCODE_RELAX(what,length) (((what) << 4) + (length))
#define GET_WHAT(x) ((x>>4))

/* These are the three types of relaxable instruction.  */
/* These are the types of relaxable instructions; except for END which is
   a marker.  */
#define COND_JUMP 1
#define COND_JUMP_DELAY 2
#define UNCOND_JUMP  3

#ifdef HAVE_SH64

/* A 16-bit (times four) pc-relative operand, at most expanded to 32 bits.  */
#define SH64PCREL16_32 4
/* A 16-bit (times four) pc-relative operand, at most expanded to 64 bits.  */
#define SH64PCREL16_64 5

/* Variants of the above for adjusting the insn to PTA or PTB according to
   the label.  */
#define SH64PCREL16PT_32 6
#define SH64PCREL16PT_64 7

/* A MOVI expansion, expanding to at most 32 or 64 bits.  */
#define MOVI_IMM_32 8
#define MOVI_IMM_32_PCREL 9
#define MOVI_IMM_64 10
#define MOVI_IMM_64_PCREL 11
#define END 12

#else  /* HAVE_SH64 */

#define END 4

#endif /* HAVE_SH64 */

#define UNDEF_DISP 0
#define COND8  1
#define COND12 2
#define COND32 3
#define UNDEF_WORD_DISP 4

#define UNCOND12 1
#define UNCOND32 2

#ifdef HAVE_SH64
#define UNDEF_SH64PCREL 0
#define SH64PCREL16 1
#define SH64PCREL32 2
#define SH64PCREL48 3
#define SH64PCREL64 4
#define SH64PCRELPLT 5

#define UNDEF_MOVI 0
#define MOVI_16 1
#define MOVI_32 2
#define MOVI_48 3
#define MOVI_64 4
#define MOVI_PLT 5
#define MOVI_GOTOFF 6
#define MOVI_GOTPC 7
#endif /* HAVE_SH64 */

/* Branch displacements are from the address of the branch plus
   four, thus all minimum and maximum values have 4 added to them.  */
#define COND8_F 258
#define COND8_M -252
#define COND8_LENGTH 2

/* There is one extra instruction before the branch, so we must add
   two more bytes to account for it.  */
#define COND12_F 4100
#define COND12_M -4090
#define COND12_LENGTH 6

#define COND12_DELAY_LENGTH 4

/* ??? The minimum and maximum values are wrong, but this does not matter
   since this relocation type is not supported yet.  */
#define COND32_F (1<<30)
#define COND32_M -(1<<30)
#define COND32_LENGTH 14

#define UNCOND12_F 4098
#define UNCOND12_M -4092
#define UNCOND12_LENGTH 2

/* ??? The minimum and maximum values are wrong, but this does not matter
   since this relocation type is not supported yet.  */
#define UNCOND32_F (1<<30)
#define UNCOND32_M -(1<<30)
#define UNCOND32_LENGTH 14

#ifdef HAVE_SH64
/* The trivial expansion of a SH64PCREL16 relaxation is just a "PT label,
   TRd" as is the current insn, so no extra length.  Note that the "reach"
   is calculated from the address *after* that insn, but the offset in the
   insn is calculated from the beginning of the insn.  We also need to
   take into account the implicit 1 coded as the "A" in PTA when counting
   forward.  If PTB reaches an odd address, we trap that as an error
   elsewhere, so we don't have to have different relaxation entries.  We
   don't add a one to the negative range, since PTB would then have the
   farthest backward-reaching value skipped, not generated at relaxation.  */
#define SH64PCREL16_F (32767 * 4 - 4 + 1)
#define SH64PCREL16_M (-32768 * 4 - 4)
#define SH64PCREL16_LENGTH 0

/* The next step is to change that PT insn into
     MOVI ((label - datalabel Ln) >> 16) & 65535, R25
     SHORI (label - datalabel Ln) & 65535, R25
    Ln:
     PTREL R25,TRd
   which means two extra insns, 8 extra bytes.  This is the limit for the
   32-bit ABI.

   The expressions look a bit bad since we have to adjust this to avoid overflow on a
   32-bit host.  */
#define SH64PCREL32_F ((((long) 1 << 30) - 1) * 2 + 1 - 4)
#define SH64PCREL32_LENGTH (2 * 4)

/* Similarly, we just change the MOVI and add a SHORI for the 48-bit
   expansion.  */
#if BFD_HOST_64BIT_LONG
/* The "reach" type is long, so we can only do this for a 64-bit-long
   host.  */
#define SH64PCREL32_M (((long) -1 << 30) * 2 - 4)
#define SH64PCREL48_F ((((long) 1 << 47) - 1) - 4)
#define SH64PCREL48_M (((long) -1 << 47) - 4)
#define SH64PCREL48_LENGTH (3 * 4)
#else
/* If the host does not have 64-bit longs, just make this state identical
   in reach to the 32-bit state.  Note that we have a slightly incorrect
   reach, but the correct one above will overflow a 32-bit number.  */
#define SH64PCREL32_M (((long) -1 << 30) * 2)
#define SH64PCREL48_F SH64PCREL32_F
#define SH64PCREL48_M SH64PCREL32_M
#define SH64PCREL48_LENGTH (3 * 4)
#endif /* BFD_HOST_64BIT_LONG */

/* And similarly for the 64-bit expansion; a MOVI + SHORI + SHORI + SHORI
   + PTREL sequence.  */
#define SH64PCREL64_LENGTH (4 * 4)

/* For MOVI, we make the MOVI + SHORI... expansion you can see in the
   SH64PCREL expansions.  The PCREL one is similar, but the other has no
   pc-relative reach; it must be fully expanded in
   shmedia_md_estimate_size_before_relax.  */
#define MOVI_16_LENGTH 0
#define MOVI_16_F (32767 - 4)
#define MOVI_16_M (-32768 - 4)
#define MOVI_32_LENGTH 4
#define MOVI_32_F ((((long) 1 << 30) - 1) * 2 + 1 - 4)
#define MOVI_48_LENGTH 8

#if BFD_HOST_64BIT_LONG
/* The "reach" type is long, so we can only do this for a 64-bit-long
   host.  */
#define MOVI_32_M (((long) -1 << 30) * 2 - 4)
#define MOVI_48_F ((((long) 1 << 47) - 1) - 4)
#define MOVI_48_M (((long) -1 << 47) - 4)
#else
/* If the host does not have 64-bit longs, just make this state identical
   in reach to the 32-bit state.  Note that we have a slightly incorrect
   reach, but the correct one above will overflow a 32-bit number.  */
#define MOVI_32_M (((long) -1 << 30) * 2)
#define MOVI_48_F MOVI_32_F
#define MOVI_48_M MOVI_32_M
#endif /* BFD_HOST_64BIT_LONG */

#define MOVI_64_LENGTH 12
#endif /* HAVE_SH64 */

#define EMPTY { 0, 0, 0, 0 }

const relax_typeS md_relax_table[C (END, 0)] = {
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  EMPTY,
  /* C (COND_JUMP, COND8) */
  { COND8_F, COND8_M, COND8_LENGTH, C (COND_JUMP, COND12) },
  /* C (COND_JUMP, COND12) */
  { COND12_F, COND12_M, COND12_LENGTH, C (COND_JUMP, COND32), },
  /* C (COND_JUMP, COND32) */
  { COND32_F, COND32_M, COND32_LENGTH, 0, },
  /* C (COND_JUMP, UNDEF_WORD_DISP) */
  { 0, 0, COND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  EMPTY,
  /* C (COND_JUMP_DELAY, COND8) */
  { COND8_F, COND8_M, COND8_LENGTH, C (COND_JUMP_DELAY, COND12) },
  /* C (COND_JUMP_DELAY, COND12) */
  { COND12_F, COND12_M, COND12_DELAY_LENGTH, C (COND_JUMP_DELAY, COND32), },
  /* C (COND_JUMP_DELAY, COND32) */
  { COND32_F, COND32_M, COND32_LENGTH, 0, },
  /* C (COND_JUMP_DELAY, UNDEF_WORD_DISP) */
  { 0, 0, COND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  EMPTY,
  /* C (UNCOND_JUMP, UNCOND12) */
  { UNCOND12_F, UNCOND12_M, UNCOND12_LENGTH, C (UNCOND_JUMP, UNCOND32), },
  /* C (UNCOND_JUMP, UNCOND32) */
  { UNCOND32_F, UNCOND32_M, UNCOND32_LENGTH, 0, },
  EMPTY,
  /* C (UNCOND_JUMP, UNDEF_WORD_DISP) */
  { 0, 0, UNCOND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

#ifdef HAVE_SH64
  /* C (SH64PCREL16_32, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16_32, SH64PCREL32) },
  /* C (SH64PCREL16_32, SH64PCREL32) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  /* C (SH64PCREL16_32, SH64PCRELPLT) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (SH64PCREL16_64, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16_64, SH64PCREL32) },
  /* C (SH64PCREL16_64, SH64PCREL32) */
  { SH64PCREL32_F, SH64PCREL32_M, SH64PCREL32_LENGTH, C (SH64PCREL16_64, SH64PCREL48) },
  /* C (SH64PCREL16_64, SH64PCREL48) */
  { SH64PCREL48_F, SH64PCREL48_M, SH64PCREL48_LENGTH, C (SH64PCREL16_64, SH64PCREL64) },
  /* C (SH64PCREL16_64, SH64PCREL64) */
  { 0, 0, SH64PCREL64_LENGTH, 0 },
  /* C (SH64PCREL16_64, SH64PCRELPLT) */
  { 0, 0, SH64PCREL64_LENGTH, 0 },
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (SH64PCREL16PT_32, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16PT_32, SH64PCREL32) },
  /* C (SH64PCREL16PT_32, SH64PCREL32) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  /* C (SH64PCREL16PT_32, SH64PCRELPLT) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (SH64PCREL16PT_64, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16PT_64, SH64PCREL32) },
  /* C (SH64PCREL16PT_64, SH64PCREL32) */
  { SH64PCREL32_F,
    SH64PCREL32_M,
    SH64PCREL32_LENGTH,
    C (SH64PCREL16PT_64, SH64PCREL48) },
  /* C (SH64PCREL16PT_64, SH64PCREL48) */
  { SH64PCREL48_F, SH64PCREL48_M, SH64PCREL48_LENGTH, C (SH64PCREL16PT_64, SH64PCREL64) },
  /* C (SH64PCREL16PT_64, SH64PCREL64) */
  { 0, 0, SH64PCREL64_LENGTH, 0 },
  /* C (SH64PCREL16PT_64, SH64PCRELPLT) */
  { 0, 0, SH64PCREL64_LENGTH, 0},
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_32, UNDEF_MOVI) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  /* C (MOVI_IMM_32, MOVI_16) */
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_32, MOVI_32) },
  /* C (MOVI_IMM_32, MOVI_32) */
  { MOVI_32_F, MOVI_32_M, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY,
  /* C (MOVI_IMM_32, MOVI_GOTOFF) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_32_PCREL, MOVI_16) */
  EMPTY,
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_32_PCREL, MOVI_32) },
  /* C (MOVI_IMM_32_PCREL, MOVI_32) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY,
  /* C (MOVI_IMM_32_PCREL, MOVI_PLT) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY,
  /* C (MOVI_IMM_32_PCREL, MOVI_GOTPC) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_64, UNDEF_MOVI) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  /* C (MOVI_IMM_64, MOVI_16) */
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_64, MOVI_32) },
  /* C (MOVI_IMM_64, MOVI_32) */
  { MOVI_32_F, MOVI_32_M, MOVI_32_LENGTH, C (MOVI_IMM_64, MOVI_48) },
  /* C (MOVI_IMM_64, MOVI_48) */
  { MOVI_48_F, MOVI_48_M, MOVI_48_LENGTH, C (MOVI_IMM_64, MOVI_64) },
  /* C (MOVI_IMM_64, MOVI_64) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY,
  /* C (MOVI_IMM_64, MOVI_GOTOFF) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_64_PCREL, MOVI_16) */
  EMPTY,
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_64_PCREL, MOVI_32) },
  /* C (MOVI_IMM_64_PCREL, MOVI_32) */
  { MOVI_32_F, MOVI_32_M, MOVI_32_LENGTH, C (MOVI_IMM_64_PCREL, MOVI_48) },
  /* C (MOVI_IMM_64_PCREL, MOVI_48) */
  { MOVI_48_F, MOVI_48_M, MOVI_48_LENGTH, C (MOVI_IMM_64_PCREL, MOVI_64) },
  /* C (MOVI_IMM_64_PCREL, MOVI_64) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  /* C (MOVI_IMM_64_PCREL, MOVI_PLT) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY,
  /* C (MOVI_IMM_64_PCREL, MOVI_GOTPC) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

#endif /* HAVE_SH64 */

};

#undef EMPTY

static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */


#ifdef OBJ_ELF
/* Determinet whether the symbol needs any kind of PIC relocation.  */

inline static int
sh_PIC_related_p (symbolS *sym)
{
  expressionS *exp;

  if (! sym)
    return 0;

  if (sym == GOT_symbol)
    return 1;

#ifdef HAVE_SH64
  if (sh_PIC_related_p (*symbol_get_tc (sym)))
    return 1;
#endif

  exp = symbol_get_value_expression (sym);

  return (exp->X_op == O_PIC_reloc
	  || sh_PIC_related_p (exp->X_add_symbol)
	  || sh_PIC_related_p (exp->X_op_symbol));
}

/* Determine the relocation type to be used to represent the
   expression, that may be rearranged.  */

static int
sh_check_fixup (expressionS *main_exp, bfd_reloc_code_real_type *r_type_p)
{
  expressionS *exp = main_exp;

  /* This is here for backward-compatibility only.  GCC used to generated:

	f@@PLT + . - (.LPCS# + 2)

     but we'd rather be able to handle this as a PIC-related reference
     plus/minus a symbol.  However, gas' parser gives us:

	O_subtract (O_add (f@@PLT, .), .LPCS#+2)

     so we attempt to transform this into:

        O_subtract (f@@PLT, O_subtract (.LPCS#+2, .))

     which we can handle simply below.  */
  if (exp->X_op == O_subtract)
    {
      if (sh_PIC_related_p (exp->X_op_symbol))
	return 1;

      exp = symbol_get_value_expression (exp->X_add_symbol);

      if (exp && sh_PIC_related_p (exp->X_op_symbol))
	return 1;

      if (exp && exp->X_op == O_add
	  && sh_PIC_related_p (exp->X_add_symbol))
	{
	  symbolS *sym = exp->X_add_symbol;

	  exp->X_op = O_subtract;
	  exp->X_add_symbol = main_exp->X_op_symbol;

	  main_exp->X_op_symbol = main_exp->X_add_symbol;
	  main_exp->X_add_symbol = sym;

	  main_exp->X_add_number += exp->X_add_number;
	  exp->X_add_number = 0;
	}

      exp = main_exp;
    }
  else if (exp->X_op == O_add && sh_PIC_related_p (exp->X_op_symbol))
    return 1;

  if (exp->X_op == O_symbol || exp->X_op == O_add || exp->X_op == O_subtract)
    {
#ifdef HAVE_SH64
      if (exp->X_add_symbol
	  && (exp->X_add_symbol == GOT_symbol
	      || (GOT_symbol
		  && *symbol_get_tc (exp->X_add_symbol) == GOT_symbol)))
	{
	  switch (*r_type_p)
	    {
	    case BFD_RELOC_SH_IMM_LOW16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_LOW16;
	      break;

	    case BFD_RELOC_SH_IMM_MEDLOW16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_MEDLOW16;
	      break;

	    case BFD_RELOC_SH_IMM_MEDHI16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_MEDHI16;
	      break;

	    case BFD_RELOC_SH_IMM_HI16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_HI16;
	      break;

	    case BFD_RELOC_NONE:
	    case BFD_RELOC_UNUSED:
	      *r_type_p = BFD_RELOC_SH_GOTPC;
	      break;

	    default:
	      abort ();
	    }
	  return 0;
	}
#else
      if (exp->X_add_symbol && exp->X_add_symbol == GOT_symbol)
	{
	  *r_type_p = BFD_RELOC_SH_GOTPC;
	  return 0;
	}
#endif
      exp = symbol_get_value_expression (exp->X_add_symbol);
      if (! exp)
	return 0;
    }

  if (exp->X_op == O_PIC_reloc)
    {
#ifdef HAVE_SH64
      switch (*r_type_p)
	{
	case BFD_RELOC_NONE:
	case BFD_RELOC_UNUSED:
	  *r_type_p = exp->X_md;
	  break;

	case BFD_RELOC_SH_IMM_LOW16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_LOW16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_LOW16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_LOW16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_LOW16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case BFD_RELOC_SH_IMM_MEDLOW16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_MEDLOW16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_MEDLOW16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_MEDLOW16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_MEDLOW16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case BFD_RELOC_SH_IMM_MEDHI16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_MEDHI16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_MEDHI16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_MEDHI16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_MEDHI16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case BFD_RELOC_SH_IMM_HI16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_HI16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_HI16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_HI16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_HI16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	default:
	  abort ();
	}
#else
      *r_type_p = exp->X_md;
#endif
      if (exp == main_exp)
	exp->X_op = O_symbol;
      else
	{
	  main_exp->X_add_symbol = exp->X_add_symbol;
	  main_exp->X_add_number += exp->X_add_number;
	}
    }
  else
    return (sh_PIC_related_p (exp->X_add_symbol)
	    || sh_PIC_related_p (exp->X_op_symbol));

  return 0;
}

/* Add expression EXP of SIZE bytes to offset OFF of fragment FRAG.  */

void
sh_cons_fix_new (fragS *frag, int off, int size, expressionS *exp)
{
  bfd_reloc_code_real_type r_type = BFD_RELOC_UNUSED;

  if (sh_check_fixup (exp, &r_type))
    as_bad (_("Invalid PIC expression."));

  if (r_type == BFD_RELOC_UNUSED)
    switch (size)
      {
      case 1:
	r_type = BFD_RELOC_8;
	break;

      case 2:
	r_type = BFD_RELOC_16;
	break;

      case 4:
	r_type = BFD_RELOC_32;
	break;

#ifdef HAVE_SH64
      case 8:
	r_type = BFD_RELOC_64;
	break;
#endif

      default:
	goto error;
      }
  else if (size != 4)
    {
    error:
      as_bad (_("unsupported BFD relocation size %u"), size);
      r_type = BFD_RELOC_UNUSED;
    }

  fix_new_exp (frag, off, size, exp, 0, r_type);
}

/* The regular cons() function, that reads constants, doesn't support
   suffixes such as @@GOT, @@GOTOFF and @@PLT, that generate
   machine-specific relocation types.  So we must define it here.  */
/* Clobbers input_line_pointer, checks end-of-line.  */
/* NBYTES 1=.byte, 2=.word, 4=.long */
static void
sh_elf_cons (register int nbytes)
{
  expressionS exp;

#ifdef HAVE_SH64

  /* Update existing range to include a previous insn, if there was one.  */
  sh64_update_contents_mark (TRUE);

  /* We need to make sure the contents type is set to data.  */
  sh64_flag_output ();

#endif /* HAVE_SH64 */

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  do
    {
      expression (&exp);
      emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  if (*input_line_pointer == '#' || *input_line_pointer == '!')
    {
       while (! is_end_of_line[(unsigned char) *input_line_pointer++]);
    }
  else
    demand_empty_rest_of_line ();
}
#endif /* OBJ_ELF */


/* This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs.  */

void
md_begin (void)
{
  const sh_opcode_info *opcode;
  char *prev_name = "";
  int target_arch;

  target_arch
    = preset_target_arch ? preset_target_arch : arch_sh1_up & ~arch_sh_dsp_up;
  valid_arch = target_arch;

#ifdef HAVE_SH64
  shmedia_md_begin ();
#endif

  opcode_hash_control = hash_new ();

  /* Insert unique names into hash table.  */
  for (opcode = sh_table; opcode->name; opcode++)
    {
      if (strcmp (prev_name, opcode->name) != 0)
	{
	  if (! (opcode->arch & target_arch))
	    continue;
	  prev_name = opcode->name;
	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
	}
    }
}

static int reg_m;
static int reg_n;
static int reg_x, reg_y;
static int reg_efg;
static int reg_b;

#define IDENT_CHAR(c) (ISALNUM (c) || (c) == '_')

/* Try to parse a reg name.  Return the number of chars consumed.  */

static int
parse_reg (char *src, int *mode, int *reg)
{
  char l0 = TOLOWER (src[0]);
  char l1 = l0 ? TOLOWER (src[1]) : 0;

  /* We use ! IDENT_CHAR for the next character after the register name, to
     make sure that we won't accidentally recognize a symbol name such as
     'sram' or sr_ram as being a reference to the register 'sr'.  */

  if (l0 == 'r')
    {
      if (l1 == '1')
	{
	  if (src[2] >= '0' && src[2] <= '5'
	      && ! IDENT_CHAR ((unsigned char) src[3]))
	    {
	      *mode = A_REG_N;
	      *reg = 10 + src[2] - '0';
	      return 3;
	    }
	}
      if (l1 >= '0' && l1 <= '9'
	  && ! IDENT_CHAR ((unsigned char) src[2]))
	{
	  *mode = A_REG_N;
	  *reg = (l1 - '0');
	  return 2;
	}
      if (l1 >= '0' && l1 <= '7' && strncasecmp (&src[2], "_bank", 5) == 0
	  && ! IDENT_CHAR ((unsigned char) src[7]))
	{
	  *mode = A_REG_B;
	  *reg  = (l1 - '0');
	  return 7;
	}

      if (l1 == 'e' && ! IDENT_CHAR ((unsigned char) src[2]))
	{
	  *mode = A_RE;
	  return 2;
	}
      if (l1 == 's' && ! IDENT_CHAR ((unsigned char) src[2]))
	{
	  *mode = A_RS;
	  return 2;
	}
    }

  if (l0 == 'a')
    {
      if (l1 == '0')
	{
	  if (! IDENT_CHAR ((unsigned char) src[2]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A0_NUM;
	      return 2;
	    }
	  if (TOLOWER (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A0G_NUM;
	      return 3;
	    }
	}
      if (l1 == '1')
	{
	  if (! IDENT_CHAR ((unsigned char) src[2]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A1_NUM;
	      return 2;
	    }
	  if (TOLOWER (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A1G_NUM;
	      return 3;
	    }
	}

      if (l1 == 'x' && src[2] >= '0' && src[2] <= '1'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = A_REG_N;
	  *reg = 4 + (l1 - '0');
	  return 3;
	}
      if (l1 == 'y' && src[2] >= '0' && src[2] <= '1'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = A_REG_N;
	  *reg = 6 + (l1 - '0');
	  return 3;
	}
      if (l1 == 's' && src[2] >= '0' && src[2] <= '3'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  int n = l1 - '0';

	  *mode = A_REG_N;
	  *reg = n | ((~n & 2) << 1);
	  return 3;
	}
    }

  if (l0 == 'i' && l1 && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      if (l1 == 's')
	{
	  *mode = A_REG_N;
	  *reg = 8;
	  return 2;
	}
      if (l1 == 'x')
	{
	  *mode = A_REG_N;
	  *reg = 8;
	  return 2;
	}
      if (l1 == 'y')
	{
	  *mode = A_REG_N;
	  *reg = 9;
	  return 2;
	}
    }

  if (l0 == 'x' && l1 >= '0' && l1 <= '1'
      && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = DSP_REG_N;
      *reg = A_X0_NUM + l1 - '0';
      return 2;
    }

  if (l0 == 'y' && l1 >= '0' && l1 <= '1'
      && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = DSP_REG_N;
      *reg = A_Y0_NUM + l1 - '0';
      return 2;
    }

  if (l0 == 'm' && l1 >= '0' && l1 <= '1'
      && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = DSP_REG_N;
      *reg = l1 == '0' ? A_M0_NUM : A_M1_NUM;
      return 2;
    }

  if (l0 == 's'
      && l1 == 's'
      && TOLOWER (src[2]) == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_SSR;
      return 3;
    }

  if (l0 == 's' && l1 == 'p' && TOLOWER (src[2]) == 'c'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_SPC;
      return 3;
    }

  if (l0 == 's' && l1 == 'g' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_SGR;
      return 3;
    }

  if (l0 == 'd' && l1 == 's' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_DSR;
      return 3;
    }

  if (l0 == 'd' && l1 == 'b' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_DBR;
      return 3;
    }

  if (l0 == 's' && l1 == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = A_SR;
      return 2;
    }

  if (l0 == 's' && l1 == 'p' && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = A_REG_N;
      *reg = 15;
      return 2;
    }

  if (l0 == 'p' && l1 == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = A_PR;
      return 2;
    }
  if (l0 == 'p' && l1 == 'c' && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      /* Don't use A_DISP_PC here - that would accept stuff like 'mova pc,r0'
         and use an uninitialized immediate.  */
      *mode = A_PC;
      return 2;
    }
  if (l0 == 'g' && l1 == 'b' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_GBR;
      return 3;
    }
  if (l0 == 'v' && l1 == 'b' && TOLOWER (src[2]) == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_VBR;
      return 3;
    }

  if (l0 == 'm' && l1 == 'a' && TOLOWER (src[2]) == 'c'
      && ! IDENT_CHAR ((unsigned char) src[4]))
    {
      if (TOLOWER (src[3]) == 'l')
	{
	  *mode = A_MACL;
	  return 4;
	}
      if (TOLOWER (src[3]) == 'h')
	{
	  *mode = A_MACH;
	  return 4;
	}
    }
  if (l0 == 'm' && l1 == 'o' && TOLOWER (src[2]) == 'd'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_MOD;
      return 3;
    }
  if (l0 == 'f' && l1 == 'r')
    {
      if (src[2] == '1')
	{
	  if (src[3] >= '0' && src[3] <= '5'
	      && ! IDENT_CHAR ((unsigned char) src[4]))
	    {
	      *mode = F_REG_N;
	      *reg = 10 + src[3] - '0';
	      return 4;
	    }
	}
      if (src[2] >= '0' && src[2] <= '9'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = F_REG_N;
	  *reg = (src[2] - '0');
	  return 3;
	}
    }
  if (l0 == 'd' && l1 == 'r')
    {
      if (src[2] == '1')
	{
	  if (src[3] >= '0' && src[3] <= '4' && ! ((src[3] - '0') & 1)
	      && ! IDENT_CHAR ((unsigned char) src[4]))
	    {
	      *mode = D_REG_N;
	      *reg = 10 + src[3] - '0';
	      return 4;
	    }
	}
      if (src[2] >= '0' && src[2] <= '8' && ! ((src[2] - '0') & 1)
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = D_REG_N;
	  *reg = (src[2] - '0');
	  return 3;
	}
    }
  if (l0 == 'x' && l1 == 'd')
    {
      if (src[2] == '1')
	{
	  if (src[3] >= '0' && src[3] <= '4' && ! ((src[3] - '0') & 1)
	      && ! IDENT_CHAR ((unsigned char) src[4]))
	    {
	      *mode = X_REG_N;
	      *reg = 11 + src[3] - '0';
	      return 4;
	    }
	}
      if (src[2] >= '0' && src[2] <= '8' && ! ((src[2] - '0') & 1)
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = X_REG_N;
	  *reg = (src[2] - '0') + 1;
	  return 3;
	}
    }
  if (l0 == 'f' && l1 == 'v')
    {
      if (src[2] == '1'&& src[3] == '2' && ! IDENT_CHAR ((unsigned char) src[4]))
	{
	  *mode = V_REG_N;
	  *reg = 12;
	  return 4;
	}
      if ((src[2] == '0' || src[2] == '4' || src[2] == '8')
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = V_REG_N;
	  *reg = (src[2] - '0');
	  return 3;
	}
    }
  if (l0 == 'f' && l1 == 'p' && TOLOWER (src[2]) == 'u'
      && TOLOWER (src[3]) == 'l'
      && ! IDENT_CHAR ((unsigned char) src[4]))
    {
      *mode = FPUL_N;
      return 4;
    }

  if (l0 == 'f' && l1 == 'p' && TOLOWER (src[2]) == 's'
      && TOLOWER (src[3]) == 'c'
      && TOLOWER (src[4]) == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
    {
      *mode = FPSCR_N;
      return 5;
    }

  if (l0 == 'x' && l1 == 'm' && TOLOWER (src[2]) == 't'
      && TOLOWER (src[3]) == 'r'
      && TOLOWER (src[4]) == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
    {
      *mode = XMTRX_M4;
      return 5;
    }

  return 0;
}

static char *
parse_exp (char *s, sh_operand_info *op)
{
  char *save;
  char *new;

  save = input_line_pointer;
  input_line_pointer = s;
  expression (&op->immediate);
  if (op->immediate.X_op == O_absent)
    as_bad (_("missing operand"));
#ifdef OBJ_ELF
  else if (op->immediate.X_op == O_PIC_reloc
	   || sh_PIC_related_p (op->immediate.X_add_symbol)
	   || sh_PIC_related_p (op->immediate.X_op_symbol))
    as_bad (_("misplaced PIC operand"));
#endif
  new = input_line_pointer;
  input_line_pointer = save;
  return new;
}

/* The many forms of operand:

   Rn                   Register direct
   @@Rn                  Register indirect
   @@Rn+                 Autoincrement
   @@-Rn                 Autodecrement
   @@(disp:4,Rn)
   @@(disp:8,GBR)
   @@(disp:8,PC)

   @@(R0,Rn)
   @@(R0,GBR)

   disp:8
   disp:12
   #imm8
   pr, gbr, vbr, macl, mach
 */

static char *
parse_at (char *src, sh_operand_info *op)
{
  int len;
  int mode;
  src++;
  if (src[0] == '-')
    {
      /* Must be predecrement.  */
      src++;

      len = parse_reg (src, &mode, &(op->reg));
      if (mode != A_REG_N)
	as_bad (_("illegal register after @@-"));

      op->type = A_DEC_N;
      src += len;
    }
  else if (src[0] == '(')
    {
      /* Could be @@(disp, rn), @@(disp, gbr), @@(disp, pc),  @@(r0, gbr) or
         @@(r0, rn).  */
      src++;
      len = parse_reg (src, &mode, &(op->reg));
      if (len && mode == A_REG_N)
	{
	  src += len;
	  if (op->reg != 0)
	    {
	      as_bad (_("must be @@(r0,...)"));
	    }
	  if (src[0] == ',')
	    {
	      src++;
	      /* Now can be rn or gbr.  */
	      len = parse_reg (src, &mode, &(op->reg));
	    }
	  else
	    {
	      len = 0;
	    }
	  if (len)
	    {
	      if (mode == A_GBR)
		{
		  op->type = A_R0_GBR;
		}
	      else if (mode == A_REG_N)
		{
		  op->type = A_IND_R0_REG_N;
		}
	      else
		{
		  as_bad (_("syntax error in @@(r0,...)"));
		}
	    }
	  else
	    {
	      as_bad (_("syntax error in @@(r0...)"));
	    }
	}
      else
	{
	  /* Must be an @@(disp,.. thing).  */
	  src = parse_exp (src, op);
	  if (src[0] == ',')
	    src++;
	  /* Now can be rn, gbr or pc.  */
	  len = parse_reg (src, &mode, &op->reg);
	  if (len)
	    {
	      if (mode == A_REG_N)
		{
		  op->type = A_DISP_REG_N;
		}
	      else if (mode == A_GBR)
		{
		  op->type = A_DISP_GBR;
		}
	      else if (mode == A_PC)
		{
		  /* We want @@(expr, pc) to uniformly address . + expr,
		     no matter if expr is a constant, or a more complex
		     expression, e.g. sym-. or sym1-sym2.
		     However, we also used to accept @@(sym,pc)
		     as addressing sym, i.e. meaning the same as plain sym.
		     Some existing code does use the @@(sym,pc) syntax, so
		     we give it the old semantics for now, but warn about
		     its use, so that users have some time to fix their code.

		     Note that due to this backward compatibility hack,
		     we'll get unexpected results when @@(offset, pc) is used,
		     and offset is a symbol that is set later to an an address
		     difference, or an external symbol that is set to an
		     address difference in another source file, so we want to
		     eventually remove it.  */
		  if (op->immediate.X_op == O_symbol)
		    {
		      op->type = A_DISP_PC;
		      as_warn (_("Deprecated syntax."));
		    }
		  else
		    {
		      op->type = A_DISP_PC_ABS;
		      /* Such operands don't get corrected for PC==.+4, so
			 make the correction here.  */
		      op->immediate.X_add_number -= 4;
		    }
		}
	      else
		{
		  as_bad (_("syntax error in @@(disp,[Rn, gbr, pc])"));
		}
	    }
	  else
	    {
	      as_bad (_("syntax error in @@(disp,[Rn, gbr, pc])"));
	    }
	}
      src += len;
      if (src[0] != ')')
	as_bad (_("expecting )"));
      else
	src++;
    }
  else
    {
      src += parse_reg (src, &mode, &(op->reg));
      if (mode != A_REG_N)
	as_bad (_("illegal register after @@"));

      if (src[0] == '+')
	{
	  char l0, l1;

	  src++;
	  l0 = TOLOWER (src[0]);
	  l1 = TOLOWER (src[1]);

	  if ((l0 == 'r' && l1 == '8')
	      || (l0 == 'i' && (l1 == 'x' || l1 == 's')))
	    {
	      src += 2;
	      op->type = AX_PMOD_N;
	    }
	  else if (   (l0 == 'r' && l1 == '9')
		   || (l0 == 'i' && l1 == 'y'))
	    {
	      src += 2;
	      op->type = AY_PMOD_N;
	    }
	  else
	    op->type = A_INC_N;
	}
      else
	op->type = A_IND_N;
    }
  return src;
}

static void
get_operand (char **ptr, sh_operand_info *op)
{
  char *src = *ptr;
  int mode = -1;
  unsigned int len;

  if (src[0] == '#')
    {
      src++;
      *ptr = parse_exp (src, op);
      op->type = A_IMM;
      return;
    }

  else if (src[0] == '@@')
    {
      *ptr = parse_at (src, op);
      return;
    }
  len = parse_reg (src, &mode, &(op->reg));
  if (len)
    {
      *ptr = src + len;
      op->type = mode;
      return;
    }
  else
    {
      /* Not a reg, the only thing left is a displacement.  */
      *ptr = parse_exp (src, op);
      op->type = A_DISP_PC;
      return;
    }
}

static char *
get_operands (sh_opcode_info *info, char *args, sh_operand_info *operand)
{
  char *ptr = args;
  if (info->arg[0])
    {
      /* The pre-processor will eliminate whitespace in front of '@@'
	 after the first argument; we may be called multiple times
	 from assemble_ppi, so don't insist on finding whitespace here.  */
      if (*ptr == ' ')
	ptr++;

      get_operand (&ptr, operand + 0);
      if (info->arg[1])
	{
	  if (*ptr == ',')
	    {
	      ptr++;
	    }
	  get_operand (&ptr, operand + 1);
	  /* ??? Hack: psha/pshl have a varying operand number depending on
	     the type of the first operand.  We handle this by having the
	     three-operand version first and reducing the number of operands
	     parsed to two if we see that the first operand is an immediate.
             This works because no insn with three operands has an immediate
	     as first operand.  */
	  if (info->arg[2] && operand[0].type != A_IMM)
	    {
	      if (*ptr == ',')
		{
		  ptr++;
		}
	      get_operand (&ptr, operand + 2);
	    }
	  else
	    {
	      operand[2].type = 0;
	    }
	}
      else
	{
	  operand[1].type = 0;
	  operand[2].type = 0;
	}
    }
  else
    {
      operand[0].type = 0;
      operand[1].type = 0;
      operand[2].type = 0;
    }
  return ptr;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes, return the opcode which matches the opcodes
   provided.  */

static sh_opcode_info *
get_specific (sh_opcode_info *opcode, sh_operand_info *operands)
{
  sh_opcode_info *this_try = opcode;
  char *name = opcode->name;
  int n = 0;

  while (opcode->name)
    {
      this_try = opcode++;
      if ((this_try->name != name) && (strcmp (this_try->name, name) != 0))
	{
	  /* We've looked so far down the table that we've run out of
	     opcodes with the same name.  */
	  return 0;
	}

      /* Look at both operands needed by the opcodes and provided by
         the user - since an arg test will often fail on the same arg
         again and again, we'll try and test the last failing arg the
         first on each opcode try.  */
      for (n = 0; this_try->arg[n]; n++)
	{
	  sh_operand_info *user = operands + n;
	  sh_arg_type arg = this_try->arg[n];

	  switch (arg)
	    {
	    case A_DISP_PC:
	      if (user->type == A_DISP_PC_ABS)
		break;
	      /* Fall through.  */
	    case A_IMM:
	    case A_BDISP12:
	    case A_BDISP8:
	    case A_DISP_GBR:
	    case A_MACH:
	    case A_PR:
	    case A_MACL:
	      if (user->type != arg)
		goto fail;
	      break;
	    case A_R0:
	      /* opcode needs r0 */
	      if (user->type != A_REG_N || user->reg != 0)
		goto fail;
	      break;
	    case A_R0_GBR:
	      if (user->type != A_R0_GBR || user->reg != 0)
		goto fail;
	      break;
	    case F_FR0:
	      if (user->type != F_REG_N || user->reg != 0)
		goto fail;
	      break;

	    case A_REG_N:
	    case A_INC_N:
	    case A_DEC_N:
	    case A_IND_N:
	    case A_IND_R0_REG_N:
	    case A_DISP_REG_N:
	    case F_REG_N:
	    case D_REG_N:
	    case X_REG_N:
	    case V_REG_N:
	    case FPUL_N:
	    case FPSCR_N:
	    case DSP_REG_N:
	      /* Opcode needs rn */
	      if (user->type != arg)
		goto fail;
	      reg_n = user->reg;
	      break;
	    case DX_REG_N:
	      if (user->type != D_REG_N && user->type != X_REG_N)
		goto fail;
	      reg_n = user->reg;
	      break;
	    case A_GBR:
	    case A_SR:
	    case A_VBR:
	    case A_DSR:
	    case A_MOD:
	    case A_RE:
	    case A_RS:
	    case A_SSR:
	    case A_SPC:
	    case A_SGR:
	    case A_DBR:
	      if (user->type != arg)
		goto fail;
	      break;

	    case A_REG_B:
	      if (user->type != arg)
		goto fail;
	      reg_b = user->reg;
	      break;

	    case A_REG_M:
	    case A_INC_M:
	    case A_DEC_M:
	    case A_IND_M:
	    case A_IND_R0_REG_M:
	    case A_DISP_REG_M:
	    case DSP_REG_M:
	      /* Opcode needs rn */
	      if (user->type != arg - A_REG_M + A_REG_N)
		goto fail;
	      reg_m = user->reg;
	      break;

	    case AS_DEC_N:
	      if (user->type != A_DEC_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AS_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AS_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AS_PMOD_N:
	      if (user->type != AX_PMOD_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AX_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg < 4 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AX_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if (user->reg < 4 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AX_PMOD_N:
	      if (user->type != AX_PMOD_N)
		goto fail;
	      if (user->reg < 4 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AXY_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if ((user->reg < 4 || user->reg > 5)
		  && (user->reg < 0 || user->reg > 1))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AXY_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if ((user->reg < 4 || user->reg > 5)
		  && (user->reg < 0 || user->reg > 1))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AXY_PMOD_N:
	      if (user->type != AX_PMOD_N)
		goto fail;
	      if ((user->reg < 4 || user->reg > 5)
		  && (user->reg < 0 || user->reg > 1))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AY_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg < 6 || user->reg > 7)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AY_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if (user->reg < 6 || user->reg > 7)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AY_PMOD_N:
	      if (user->type != AY_PMOD_N)
		goto fail;
	      if (user->reg < 6 || user->reg > 7)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AYX_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if ((user->reg < 6 || user->reg > 7)
		  && (user->reg < 2 || user->reg > 3))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AYX_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if ((user->reg < 6 || user->reg > 7)
		  && (user->reg < 2 || user->reg > 3))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AYX_PMOD_N:
	      if (user->type != AY_PMOD_N)
		goto fail;
	      if ((user->reg < 6 || user->reg > 7)
		  && (user->reg < 2 || user->reg > 3))
		goto fail;
	      reg_n = user->reg;
	      break;

	    case DSP_REG_A_M:
	      if (user->type != DSP_REG_N)
		goto fail;
	      if (user->reg != A_A0_NUM
		  && user->reg != A_A1_NUM)
		goto fail;
	      reg_m = user->reg;
	      break;

	    case DSP_REG_AX:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_A0_NUM:
		  reg_x = 0;
		  break;
		case A_A1_NUM:
		  reg_x = 2;
		  break;
		case A_X0_NUM:
		  reg_x = 1;
		  break;
		case A_X1_NUM:
		  reg_x = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_XY:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_X0_NUM:
		  reg_x = 0;
		  break;
		case A_X1_NUM:
		  reg_x = 2;
		  break;
		case A_Y0_NUM:
		  reg_x = 1;
		  break;
		case A_Y1_NUM:
		  reg_x = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_AY:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_A0_NUM:
		  reg_y = 0;
		  break;
		case A_A1_NUM:
		  reg_y = 1;
		  break;
		case A_Y0_NUM:
		  reg_y = 2;
		  break;
		case A_Y1_NUM:
		  reg_y = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_YX:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_Y0_NUM:
		  reg_y = 0;
		  break;
		case A_Y1_NUM:
		  reg_y = 1;
		  break;
		case A_X0_NUM:
		  reg_y = 2;
		  break;
		case A_X1_NUM:
		  reg_y = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_X:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_X0_NUM:
		  reg_x = 0;
		  break;
		case A_X1_NUM:
		  reg_x = 1;
		  break;
		case A_A0_NUM:
		  reg_x = 2;
		  break;
		case A_A1_NUM:
		  reg_x = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_Y:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_Y0_NUM:
		  reg_y = 0;
		  break;
		case A_Y1_NUM:
		  reg_y = 1;
		  break;
		case A_M0_NUM:
		  reg_y = 2;
		  break;
		case A_M1_NUM:
		  reg_y = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_E:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_X0_NUM:
		  reg_efg = 0 << 10;
		  break;
		case A_X1_NUM:
		  reg_efg = 1 << 10;
		  break;
		case A_Y0_NUM:
		  reg_efg = 2 << 10;
		  break;
		case A_A1_NUM:
		  reg_efg = 3 << 10;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_F:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_Y0_NUM:
		  reg_efg |= 0 << 8;
		  break;
		case A_Y1_NUM:
		  reg_efg |= 1 << 8;
		  break;
		case A_X0_NUM:
		  reg_efg |= 2 << 8;
		  break;
		case A_A1_NUM:
		  reg_efg |= 3 << 8;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_G:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_M0_NUM:
		  reg_efg |= 0 << 2;
		  break;
		case A_M1_NUM:
		  reg_efg |= 1 << 2;
		  break;
		case A_A0_NUM:
		  reg_efg |= 2 << 2;
		  break;
		case A_A1_NUM:
		  reg_efg |= 3 << 2;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case A_A0:
	      if (user->type != DSP_REG_N || user->reg != A_A0_NUM)
		goto fail;
	      break;
	    case A_X0:
	      if (user->type != DSP_REG_N || user->reg != A_X0_NUM)
		goto fail;
	      break;
	    case A_X1:
	      if (user->type != DSP_REG_N || user->reg != A_X1_NUM)
		goto fail;
	      break;
	    case A_Y0:
	      if (user->type != DSP_REG_N || user->reg != A_Y0_NUM)
		goto fail;
	      break;
	    case A_Y1:
	      if (user->type != DSP_REG_N || user->reg != A_Y1_NUM)
		goto fail;
	      break;

	    case F_REG_M:
	    case D_REG_M:
	    case X_REG_M:
	    case V_REG_M:
	    case FPUL_M:
	    case FPSCR_M:
	      /* Opcode needs rn */
	      if (user->type != arg - F_REG_M + F_REG_N)
		goto fail;
	      reg_m = user->reg;
	      break;
	    case DX_REG_M:
	      if (user->type != D_REG_N && user->type != X_REG_N)
		goto fail;
	      reg_m = user->reg;
	      break;
	    case XMTRX_M4:
	      if (user->type != XMTRX_M4)
		goto fail;
	      reg_m = 4;
	      break;

	    default:
	      printf (_("unhandled %d\n"), arg);
	      goto fail;
	    }
	}
      if ( !(valid_arch & this_try->arch))
	goto fail;
      valid_arch &= this_try->arch;
      return this_try;
    fail:
      ;
    }

  return 0;
}

static void
insert (char *where, int how, int pcrel, sh_operand_info *op)
{
  fix_new_exp (frag_now,
	       where - frag_now->fr_literal,
	       2,
	       &op->immediate,
	       pcrel,
	       how);
}

static void
build_relax (sh_opcode_info *opcode, sh_operand_info *op)
{
  int high_byte = target_big_endian ? 0 : 1;
  char *p;

  if (opcode->arg[0] == A_BDISP8)
    {
      int what = (opcode->nibbles[1] & 4) ? COND_JUMP_DELAY : COND_JUMP;
      p = frag_var (rs_machine_dependent,
		    md_relax_table[C (what, COND32)].rlx_length,
		    md_relax_table[C (what, COND8)].rlx_length,
		    C (what, 0),
		    op->immediate.X_add_symbol,
		    op->immediate.X_add_number,
		    0);
      p[high_byte] = (opcode->nibbles[0] << 4) | (opcode->nibbles[1]);
    }
  else if (opcode->arg[0] == A_BDISP12)
    {
      p = frag_var (rs_machine_dependent,
		    md_relax_table[C (UNCOND_JUMP, UNCOND32)].rlx_length,
		    md_relax_table[C (UNCOND_JUMP, UNCOND12)].rlx_length,
		    C (UNCOND_JUMP, 0),
		    op->immediate.X_add_symbol,
		    op->immediate.X_add_number,
		    0);
      p[high_byte] = (opcode->nibbles[0] << 4);
    }

}

/* Insert ldrs & ldre with fancy relocations that relaxation can recognize.  */

static char *
insert_loop_bounds (char *output, sh_operand_info *operand)
{
  char *name;
  symbolS *end_sym;

  /* Since the low byte of the opcode will be overwritten by the reloc, we
     can just stash the high byte into both bytes and ignore endianness.  */
  output[0] = 0x8c;
  output[1] = 0x8c;
  insert (output, BFD_RELOC_SH_LOOP_START, 1, operand);
  insert (output, BFD_RELOC_SH_LOOP_END, 1, operand + 1);

  if (sh_relax)
    {
      static int count = 0;

      /* If the last loop insn is a two-byte-insn, it is in danger of being
	 swapped with the insn after it.  To prevent this, create a new
	 symbol - complete with SH_LABEL reloc - after the last loop insn.
	 If the last loop insn is four bytes long, the symbol will be
	 right in the middle, but four byte insns are not swapped anyways.  */
      /* A REPEAT takes 6 bytes.  The SH has a 32 bit address space.
	 Hence a 9 digit number should be enough to count all REPEATs.  */
      name = alloca (11);
      sprintf (name, "_R%x", count++ & 0x3fffffff);
      end_sym = symbol_new (name, undefined_section, 0, &zero_address_frag);
      /* Make this a local symbol.  */
#ifdef OBJ_COFF
      SF_SET_LOCAL (end_sym);
#endif /* OBJ_COFF */
      symbol_table_insert (end_sym);
      end_sym->sy_value = operand[1].immediate;
      end_sym->sy_value.X_add_number += 2;
      fix_new (frag_now, frag_now_fix (), 2, end_sym, 0, 1, BFD_RELOC_SH_LABEL);
    }

  output = frag_more (2);
  output[0] = 0x8e;
  output[1] = 0x8e;
  insert (output, BFD_RELOC_SH_LOOP_START, 1, operand);
  insert (output, BFD_RELOC_SH_LOOP_END, 1, operand + 1);

  return frag_more (2);
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static unsigned int
build_Mytes (sh_opcode_info *opcode, sh_operand_info *operand)
{
  int index;
  char nbuf[4];
  char *output = frag_more (2);
  unsigned int size = 2;
  int low_byte = target_big_endian ? 1 : 0;
  nbuf[0] = 0;
  nbuf[1] = 0;
  nbuf[2] = 0;
  nbuf[3] = 0;

  for (index = 0; index < 4; index++)
    {
      sh_nibble_type i = opcode->nibbles[index];
      if (i < 16)
	{
	  nbuf[index] = i;
	}
      else
	{
	  switch (i)
	    {
	    case REG_N:
	    case REG_N_D:
	      nbuf[index] = reg_n;
	      break;
	    case REG_M:
	      nbuf[index] = reg_m;
	      break;
	    case SDT_REG_N:
	      if (reg_n < 2 || reg_n > 5)
		as_bad (_("Invalid register: 'r%d'"), reg_n);
	      nbuf[index] = (reg_n & 3) | 4;
	      break;
	    case REG_NM:
	      nbuf[index] = reg_n | (reg_m >> 2);
	      break;
	    case REG_B:
	      nbuf[index] = reg_b | 0x08;
	      break;
	    case REG_N_B01:
	      nbuf[index] = reg_n | 0x01;
	      break;
	    case IMM0_4BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY4, 0, operand);
	      break;
	    case IMM0_4BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY2, 0, operand);
	      break;
	    case IMM0_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0, operand);
	      break;
	    case IMM1_4BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY4, 0, operand + 1);
	      break;
	    case IMM1_4BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY2, 0, operand + 1);
	      break;
	    case IMM1_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0, operand + 1);
	      break;
	    case IMM0_8BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY4, 0, operand);
	      break;
	    case IMM0_8BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY2, 0, operand);
	      break;
	    case IMM0_8:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8, 0, operand);
	      break;
	    case IMM1_8BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY4, 0, operand + 1);
	      break;
	    case IMM1_8BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY2, 0, operand + 1);
	      break;
	    case IMM1_8:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8, 0, operand + 1);
	      break;
	    case PCRELIMM_8BY4:
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY4,
		      operand->type != A_DISP_PC_ABS, operand);
	      break;
	    case PCRELIMM_8BY2:
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY2,
		      operand->type != A_DISP_PC_ABS, operand);
	      break;
	    case REPEAT:
	      output = insert_loop_bounds (output, operand);
	      nbuf[index] = opcode->nibbles[3];
	      operand += 2;
	      break;
	    default:
	      printf (_("failed for %d\n"), i);
	    }
	}
    }
  if (!target_big_endian)
    {
      output[1] = (nbuf[0] << 4) | (nbuf[1]);
      output[0] = (nbuf[2] << 4) | (nbuf[3]);
    }
  else
    {
      output[0] = (nbuf[0] << 4) | (nbuf[1]);
      output[1] = (nbuf[2] << 4) | (nbuf[3]);
    }
  return size;
}

/* Find an opcode at the start of *STR_P in the hash table, and set
   *STR_P to the first character after the last one read.  */

static sh_opcode_info *
find_cooked_opcode (char **str_p)
{
  char *str = *str_p;
  unsigned char *op_start;
  unsigned char *op_end;
  char name[20];
  int nlen = 0;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the op code end.
     The pre-processor will eliminate whitespace in front of
     any '@@' after the first argument; we may be called from
     assemble_ppi, so the opcode might be terminated by an '@@'.  */
  for (op_start = op_end = (unsigned char *) (str);
       *op_end
       && nlen < 20
       && !is_end_of_line[*op_end] && *op_end != ' ' && *op_end != '@@';
       op_end++)
    {
      unsigned char c = op_start[nlen];

      /* The machine independent code will convert CMP/EQ into cmp/EQ
	 because it thinks the '/' is the end of the symbol.  Moreover,
	 all but the first sub-insn is a parallel processing insn won't
	 be capitalized.  Instead of hacking up the machine independent
	 code, we just deal with it here.  */
      c = TOLOWER (c);
      name[nlen] = c;
      nlen++;
    }

  name[nlen] = 0;
  *str_p = op_end;

  if (nlen == 0)
    as_bad (_("can't find opcode "));

  return (sh_opcode_info *) hash_find (opcode_hash_control, name);
}

/* Assemble a parallel processing insn.  */
#define DDT_BASE 0xf000 /* Base value for double data transfer insns */

static unsigned int
assemble_ppi (char *op_end, sh_opcode_info *opcode)
{
  int movx = 0;
  int movy = 0;
  int cond = 0;
  int field_b = 0;
  char *output;
  int move_code;
  unsigned int size;

  for (;;)
    {
      sh_operand_info operand[3];

      /* Some insn ignore one or more register fields, e.g. psts machl,a0.
	 Make sure we encode a defined insn pattern.  */
      reg_x = 0;
      reg_y = 0;
      reg_n = 0;

      if (opcode->arg[0] != A_END)
	op_end = get_operands (opcode, op_end, operand);
    try_another_opcode:
      opcode = get_specific (opcode, operand);
      if (opcode == 0)
	{
	  /* Couldn't find an opcode which matched the operands.  */
	  char *where = frag_more (2);
	  size = 2;

	  where[0] = 0x0;
	  where[1] = 0x0;
	  as_bad (_("invalid operands for opcode"));
	  return size;
	}

      if (opcode->nibbles[0] != PPI)
	as_bad (_("insn can't be combined with parallel processing insn"));

      switch (opcode->nibbles[1])
	{

	case NOPX:
	  if (movx)
	    as_bad (_("multiple movx specifications"));
	  movx = DDT_BASE;
	  break;
	case NOPY:
	  if (movy)
	    as_bad (_("multiple movy specifications"));
	  movy = DDT_BASE;
	  break;

	case MOVX_NOPY:
	  if (movx)
	    as_bad (_("multiple movx specifications"));
	  if ((reg_n < 4 || reg_n > 5)
	      && (reg_n < 0 || reg_n > 1))
	    as_bad (_("invalid movx address register"));
	  if (movy && movy != DDT_BASE)
	    as_bad (_("insn cannot be combined with non-nopy"));
	  movx = ((((reg_n & 1) != 0) << 9)
		  + (((reg_n & 4) == 0) << 8)
		  + (reg_x << 6)
		  + (opcode->nibbles[2] << 4)
		  + opcode->nibbles[3]
		  + DDT_BASE);
	  break;

	case MOVY_NOPX:
	  if (movy)
	    as_bad (_("multiple movy specifications"));
	  if ((reg_n < 6 || reg_n > 7)
	      && (reg_n < 2 || reg_n > 3))
	    as_bad (_("invalid movy address register"));
	  if (movx && movx != DDT_BASE)
	    as_bad (_("insn cannot be combined with non-nopx"));
	  movy = ((((reg_n & 1) != 0) << 8)
		  + (((reg_n & 4) == 0) << 9)
		  + (reg_y << 6)
		  + (opcode->nibbles[2] << 4)
		  + opcode->nibbles[3]
		  + DDT_BASE);
	  break;

	case MOVX:
	  if (movx)
	    as_bad (_("multiple movx specifications"));
	  if (movy & 0x2ac)
	    as_bad (_("previous movy requires nopx"));
	  if (reg_n < 4 || reg_n > 5)
	    as_bad (_("invalid movx address register"));
	  if (opcode->nibbles[2] & 8)
	    {
	      if (reg_m == A_A1_NUM)
		movx = 1 << 7;
	      else if (reg_m != A_A0_NUM)
		as_bad (_("invalid movx dsp register"));
	    }
	  else
	    {
	      if (reg_x > 1)
		as_bad (_("invalid movx dsp register"));
	      movx = reg_x << 7;
	    }
	  movx += ((reg_n - 4) << 9) + (opcode->nibbles[2] << 2) + DDT_BASE;
	  break;

	case MOVY:
	  if (movy)
	    as_bad (_("multiple movy specifications"));
	  if (movx & 0x153)
	    as_bad (_("previous movx requires nopy"));
	  if (opcode->nibbles[2] & 8)
	    {
	      /* Bit 3 in nibbles[2] is intended for bit 4 of the opcode,
		 so add 8 more.  */
	      movy = 8;
	      if (reg_m == A_A1_NUM)
		movy += 1 << 6;
	      else if (reg_m != A_A0_NUM)
		as_bad (_("invalid movy dsp register"));
	    }
	  else
	    {
	      if (reg_y > 1)
		as_bad (_("invalid movy dsp register"));
	      movy = reg_y << 6;
	    }
	  if (reg_n < 6 || reg_n > 7)
	    as_bad (_("invalid movy address register"));
	  movy += ((reg_n - 6) << 8) + opcode->nibbles[2] + DDT_BASE;
	  break;

	case PSH:
	  if (operand[0].immediate.X_op != O_constant)
	    as_bad (_("dsp immediate shift value not constant"));
	  field_b = ((opcode->nibbles[2] << 12)
		     | (operand[0].immediate.X_add_number & 127) << 4
		     | reg_n);
	  break;
	case PPI3NC:
	  if (cond)
	    {
	      opcode++;
	      goto try_another_opcode;
	    }
	  /* Fall through.  */
	case PPI3:
	  if (field_b)
	    as_bad (_("multiple parallel processing specifications"));
	  field_b = ((opcode->nibbles[2] << 12) + (opcode->nibbles[3] << 8)
		     + (reg_x << 6) + (reg_y << 4) + reg_n);
	  switch (opcode->nibbles[4])
	    {
	    case HEX_0:
	    case HEX_XX00:
	    case HEX_00YY:
	      break;
	    case HEX_1:
	    case HEX_4:
	      field_b += opcode->nibbles[4] << 4;
	      break;
	    default:
	      abort ();
	    }
	  break;
	case PDC:
	  if (cond)
	    as_bad (_("multiple condition specifications"));
	  cond = opcode->nibbles[2] << 8;
	  if (*op_end)
	    goto skip_cond_check;
	  break;
	case PPIC:
	  if (field_b)
	    as_bad (_("multiple parallel processing specifications"));
	  field_b = ((opcode->nibbles[2] << 12) + (opcode->nibbles[3] << 8)
		     + cond + (reg_x << 6) + (reg_y << 4) + reg_n);
	  cond = 0;
	  switch (opcode->nibbles[4])
	    {
	    case HEX_0:
	    case HEX_XX00:
	    case HEX_00YY:
	      break;
	    case HEX_1:
	    case HEX_4:
	      field_b += opcode->nibbles[4] << 4;
	      break;
	    default:
	      abort ();
	    }
	  break;
	case PMUL:
	  if (field_b)
	    {
	      if ((field_b & 0xef00) == 0xa100)
		field_b -= 0x8100;
	      /* pclr Dz pmuls Se,Sf,Dg */
	      else if ((field_b & 0xff00) == 0x8d00
		       && (valid_arch & arch_sh4al_dsp_up))
		{
		  valid_arch &= arch_sh4al_dsp_up;
		  field_b -= 0x8cf0;
		}
	      else
		as_bad (_("insn cannot be combined with pmuls"));
	      switch (field_b & 0xf)
		{
		case A_X0_NUM:
		  field_b += 0 - A_X0_NUM;
		  break;
		case A_Y0_NUM:
		  field_b += 1 - A_Y0_NUM;
		  break;
		case A_A0_NUM:
		  field_b += 2 - A_A0_NUM;
		  break;
		case A_A1_NUM:
		  field_b += 3 - A_A1_NUM;
		  break;
		default:
		  as_bad (_("bad combined pmuls output operand"));
		}
		/* Generate warning if the destination register for padd / psub
		   and pmuls is the same ( only for A0 or A1 ).
		   If the last nibble is 1010 then A0 is used in both
		   padd / psub and pmuls. If it is 1111 then A1 is used
		   as destination register in both padd / psub and pmuls.  */

		if ((((field_b | reg_efg) & 0x000F) == 0x000A)
		    || (((field_b | reg_efg) & 0x000F) == 0x000F))
		  as_warn (_("destination register is same for parallel insns"));
	    }
	  field_b += 0x4000 + reg_efg;
	  break;
	default:
	  abort ();
	}
      if (cond)
	{
	  as_bad (_("condition not followed by conditionalizable insn"));
	  cond = 0;
	}
      if (! *op_end)
	break;
    skip_cond_check:
      opcode = find_cooked_opcode (&op_end);
      if (opcode == NULL)
	{
	  (as_bad
	   (_("unrecognized characters at end of parallel processing insn")));
	  break;
	}
    }

  move_code = movx | movy;
  if (field_b)
    {
      /* Parallel processing insn.  */
      unsigned long ppi_code = (movx | movy | 0xf800) << 16 | field_b;

      output = frag_more (4);
      size = 4;
      if (! target_big_endian)
	{
	  output[3] = ppi_code >> 8;
	  output[2] = ppi_code;
	}
      else
	{
	  output[2] = ppi_code >> 8;
	  output[3] = ppi_code;
	}
      move_code |= 0xf800;
    }
  else
    {
      /* Just a double data transfer.  */
      output = frag_more (2);
      size = 2;
    }
  if (! target_big_endian)
    {
      output[1] = move_code >> 8;
      output[0] = move_code;
    }
  else
    {
      output[0] = move_code >> 8;
      output[1] = move_code;
    }
  return size;
}

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (char *str)
{
  unsigned char *op_end;
  sh_operand_info operand[3];
  sh_opcode_info *opcode;
  unsigned int size = 0;

#ifdef HAVE_SH64
  if (sh64_isa_mode == sh64_isa_shmedia)
    {
      shmedia_md_assemble (str);
      return;
    }
  else
    {
      /* If we've seen pseudo-directives, make sure any emitted data or
	 frags are marked as data.  */
      if (!seen_insn)
	{
	  sh64_update_contents_mark (TRUE);
	  sh64_set_contents_type (CRT_SH5_ISA16);
	}

      seen_insn = TRUE;
    }
#endif /* HAVE_SH64 */

  opcode = find_cooked_opcode (&str);
  op_end = str;

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  if (sh_relax
      && ! seg_info (now_seg)->tc_segment_info_data.in_code)
    {
      /* Output a CODE reloc to tell the linker that the following
         bytes are instructions, not data.  */
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0,
	       BFD_RELOC_SH_CODE);
      seg_info (now_seg)->tc_segment_info_data.in_code = 1;
    }

  if (opcode->nibbles[0] == PPI)
    {
      size = assemble_ppi (op_end, opcode);
    }
  else
    {
      if (opcode->arg[0] == A_BDISP12
	  || opcode->arg[0] == A_BDISP8)
	{
	  /* Since we skip get_specific here, we have to check & update
	     valid_arch now.  */
	  if (valid_arch & opcode->arch)
	    valid_arch &= opcode->arch;
	  else
	    as_bad (_("Delayed branches not available on SH1"));
	  parse_exp (op_end + 1, &operand[0]);
	  build_relax (opcode, &operand[0]);
	}
      else
	{
	  if (opcode->arg[0] == A_END)
	    {
	      /* Ignore trailing whitespace.  If there is any, it has already
		 been compressed to a single space.  */
	      if (*op_end == ' ')
		op_end++;
	    }
	  else
	    {
	      op_end = get_operands (opcode, op_end, operand);
	    }
	  opcode = get_specific (opcode, operand);

	  if (opcode == 0)
	    {
	      /* Couldn't find an opcode which matched the operands.  */
	      char *where = frag_more (2);
	      size = 2;

	      where[0] = 0x0;
	      where[1] = 0x0;
	      as_bad (_("invalid operands for opcode"));
	    }
	  else
	    {
	      if (*op_end)
		as_bad (_("excess operands: '%s'"), op_end);

	      size = build_Mytes (opcode, operand);
	    }
	}
    }

#ifdef BFD_ASSEMBLER
  dwarf2_emit_insn (size);
#endif
}

/* This routine is called each time a label definition is seen.  It
   emits a BFD_RELOC_SH_LABEL reloc if necessary.  */

void
sh_frob_label (void)
{
  static fragS *last_label_frag;
  static int last_label_offset;

  if (sh_relax
      && seg_info (now_seg)->tc_segment_info_data.in_code)
    {
      int offset;

      offset = frag_now_fix ();
      if (frag_now != last_label_frag
	  || offset != last_label_offset)
	{
	  fix_new (frag_now, offset, 2, &abs_symbol, 0, 0, BFD_RELOC_SH_LABEL);
	  last_label_frag = frag_now;
	  last_label_offset = offset;
	}
    }
}

/* This routine is called when the assembler is about to output some
   data.  It emits a BFD_RELOC_SH_DATA reloc if necessary.  */

void
sh_flush_pending_output (void)
{
  if (sh_relax
      && seg_info (now_seg)->tc_segment_info_data.in_code)
    {
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0,
	       BFD_RELOC_SH_DATA);
      seg_info (now_seg)->tc_segment_info_data.in_code = 0;
    }
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

#ifdef OBJ_COFF
#ifndef BFD_ASSEMBLER

void
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}

void
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_headers_hook \n"));
}

#endif
#endif

/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP .  An error message is
   returned, or NULL on OK.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * 2;

  if (! target_big_endian)
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }

  return NULL;
}

/* Handle the .uses pseudo-op.  This pseudo-op is used just before a
   call instruction.  It refers to a label of the instruction which
   loads the register which the call uses.  We use it to generate a
   special reloc for the linker.  */

static void
s_uses (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex;

  if (! sh_relax)
    as_warn (_(".uses pseudo-op seen when not relaxing"));

  expression (&ex);

  if (ex.X_op != O_symbol || ex.X_add_number != 0)
    {
      as_bad (_("bad .uses format"));
      ignore_rest_of_line ();
      return;
    }

  fix_new_exp (frag_now, frag_now_fix (), 2, &ex, 1, BFD_RELOC_SH_USES);

  demand_empty_rest_of_line ();
}

const char *md_shortopts = "";
struct option md_longopts[] =
{
#define OPTION_RELAX  (OPTION_MD_BASE)
#define OPTION_BIG (OPTION_MD_BASE + 1)
#define OPTION_LITTLE (OPTION_BIG + 1)
#define OPTION_SMALL (OPTION_LITTLE + 1)
#define OPTION_DSP (OPTION_SMALL + 1)
#define OPTION_ISA                    (OPTION_DSP + 1)
#define OPTION_RENESAS (OPTION_ISA + 1)

  {"relax", no_argument, NULL, OPTION_RELAX},
  {"big", no_argument, NULL, OPTION_BIG},
  {"little", no_argument, NULL, OPTION_LITTLE},
  {"small", no_argument, NULL, OPTION_SMALL},
  {"dsp", no_argument, NULL, OPTION_DSP},
  {"isa",                    required_argument, NULL, OPTION_ISA},
  {"renesas", no_argument, NULL, OPTION_RENESAS},

#ifdef HAVE_SH64
#define OPTION_ABI                    (OPTION_RENESAS + 1)
#define OPTION_NO_MIX                 (OPTION_ABI + 1)
#define OPTION_SHCOMPACT_CONST_CRANGE (OPTION_NO_MIX + 1)
#define OPTION_NO_EXPAND              (OPTION_SHCOMPACT_CONST_CRANGE + 1)
#define OPTION_PT32                   (OPTION_NO_EXPAND + 1)
  {"abi",                    required_argument, NULL, OPTION_ABI},
  {"no-mix",                 no_argument, NULL, OPTION_NO_MIX},
  {"shcompact-const-crange", no_argument, NULL, OPTION_SHCOMPACT_CONST_CRANGE},
  {"no-expand",              no_argument, NULL, OPTION_NO_EXPAND},
  {"expand-pt32",            no_argument, NULL, OPTION_PT32},
#endif /* HAVE_SH64 */

  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    case OPTION_RELAX:
      sh_relax = 1;
      break;

    case OPTION_BIG:
      target_big_endian = 1;
      break;

    case OPTION_LITTLE:
      target_big_endian = 0;
      break;

    case OPTION_SMALL:
      sh_small = 1;
      break;

    case OPTION_DSP:
      preset_target_arch = arch_sh1_up & ~arch_sh2e_up;
      break;

    case OPTION_RENESAS:
      dont_adjust_reloc_32 = 1;
      break;

    case OPTION_ISA:
      if (strcasecmp (arg, "sh4") == 0)
	preset_target_arch = arch_sh4;
      else if (strcasecmp (arg, "sh4a") == 0)
	preset_target_arch = arch_sh4a;
      else if (strcasecmp (arg, "dsp") == 0)
	preset_target_arch = arch_sh1_up & ~arch_sh2e_up;
      else if (strcasecmp (arg, "fp") == 0)
	preset_target_arch = arch_sh2e_up;
      else if (strcasecmp (arg, "any") == 0)
	preset_target_arch = arch_sh1_up;
#ifdef HAVE_SH64
      else if (strcasecmp (arg, "shmedia") == 0)
	{
	  if (sh64_isa_mode == sh64_isa_shcompact)
	    as_bad (_("Invalid combination: --isa=SHcompact with --isa=SHmedia"));
	  sh64_isa_mode = sh64_isa_shmedia;
	}
      else if (strcasecmp (arg, "shcompact") == 0)
	{
	  if (sh64_isa_mode == sh64_isa_shmedia)
	    as_bad (_("Invalid combination: --isa=SHmedia with --isa=SHcompact"));
	  if (sh64_abi == sh64_abi_64)
	    as_bad (_("Invalid combination: --abi=64 with --isa=SHcompact"));
	  sh64_isa_mode = sh64_isa_shcompact;
	}
#endif /* HAVE_SH64 */
      else
	as_bad ("Invalid argument to --isa option: %s", arg);
      break;

#ifdef HAVE_SH64
    case OPTION_ABI:
      if (strcmp (arg, "32") == 0)
	{
	  if (sh64_abi == sh64_abi_64)
	    as_bad (_("Invalid combination: --abi=32 with --abi=64"));
	  sh64_abi = sh64_abi_32;
	}
      else if (strcmp (arg, "64") == 0)
	{
	  if (sh64_abi == sh64_abi_32)
	    as_bad (_("Invalid combination: --abi=64 with --abi=32"));
	  if (sh64_isa_mode == sh64_isa_shcompact)
	    as_bad (_("Invalid combination: --isa=SHcompact with --abi=64"));
	  sh64_abi = sh64_abi_64;
	}
      else
	as_bad ("Invalid argument to --abi option: %s", arg);
      break;

    case OPTION_NO_MIX:
      sh64_mix = FALSE;
      break;

    case OPTION_SHCOMPACT_CONST_CRANGE:
      sh64_shcompact_const_crange = TRUE;
      break;

    case OPTION_NO_EXPAND:
      sh64_expand = FALSE;
      break;

    case OPTION_PT32:
      sh64_pt32 = TRUE;
      break;
#endif /* HAVE_SH64 */

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
SH options:\n\
-little			generate little endian code\n\
-big			generate big endian code\n\
-relax			alter jump instructions for long displacements\n\
-renesas		disable optimization with section symbol for\n\
			compatibility with Renesas assembler.\n\
-small			align sections to 4 byte boundaries, not 16\n\
-dsp			enable sh-dsp insns, and disable floating-point ISAs.\n"));
#ifdef HAVE_SH64
  fprintf (stream, _("\
-isa=[sh4\n\
    | sh4a\n\
    | dsp		same as '-dsp'\n\
    | fp\n\
    | shmedia		set as the default instruction set for SH64\n\
    | SHmedia\n\
    | shcompact\n\
    | SHcompact\n"));
  fprintf (stream, _("\
-abi=[32|64]		set size of expanded SHmedia operands and object\n\
			file type\n\
-shcompact-const-crange	emit code-range descriptors for constants in\n\
			SHcompact code sections\n\
-no-mix			disallow SHmedia code in the same section as\n\
			constants and SHcompact code\n\
-no-expand		do not expand MOVI, PT, PTA or PTB instructions\n\
-expand-pt32		with -abi=64, expand PT, PTA and PTB instructions\n\
			to 32 bits only\n"));
#else
  fprintf (stream, _("\
-isa=[sh4\n\
    | sh4a\n\
    | dsp		same as '-dsp'\n\
    | fp\n\
    | any]\n"));
#endif /* HAVE_SH64 */
}

/* This struct is used to pass arguments to sh_count_relocs through
   bfd_map_over_sections.  */

struct sh_count_relocs
{
  /* Symbol we are looking for.  */
  symbolS *sym;
  /* Count of relocs found.  */
  int count;
};

/* Count the number of fixups in a section which refer to a particular
   symbol.  When using BFD_ASSEMBLER, this is called via
   bfd_map_over_sections.  */

static void
sh_count_relocs (bfd *abfd ATTRIBUTE_UNUSED, segT sec, void *data)
{
  struct sh_count_relocs *info = (struct sh_count_relocs *) data;
  segment_info_type *seginfo;
  symbolS *sym;
  fixS *fix;

  seginfo = seg_info (sec);
  if (seginfo == NULL)
    return;

  sym = info->sym;
  for (fix = seginfo->fix_root; fix != NULL; fix = fix->fx_next)
    {
      if (fix->fx_addsy == sym)
	{
	  ++info->count;
	  fix->fx_tcbit = 1;
	}
    }
}

/* Handle the count relocs for a particular section.  When using
   BFD_ASSEMBLER, this is called via bfd_map_over_sections.  */

static void
sh_frob_section (bfd *abfd ATTRIBUTE_UNUSED, segT sec,
		 void *ignore ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo;
  fixS *fix;

  seginfo = seg_info (sec);
  if (seginfo == NULL)
    return;

  for (fix = seginfo->fix_root; fix != NULL; fix = fix->fx_next)
    {
      symbolS *sym;
      bfd_vma val;
      fixS *fscan;
      struct sh_count_relocs info;

      if (fix->fx_r_type != BFD_RELOC_SH_USES)
	continue;

      /* The BFD_RELOC_SH_USES reloc should refer to a defined local
	 symbol in the same section.  */
      sym = fix->fx_addsy;
      if (sym == NULL
	  || fix->fx_subsy != NULL
	  || fix->fx_addnumber != 0
	  || S_GET_SEGMENT (sym) != sec
#if ! defined (BFD_ASSEMBLER) && defined (OBJ_COFF)
	  || S_GET_STORAGE_CLASS (sym) == C_EXT
#endif
	  || S_IS_EXTERNAL (sym))
	{
	  as_warn_where (fix->fx_file, fix->fx_line,
			 _(".uses does not refer to a local symbol in the same section"));
	  continue;
	}

      /* Look through the fixups again, this time looking for one
	 at the same location as sym.  */
      val = S_GET_VALUE (sym);
      for (fscan = seginfo->fix_root;
	   fscan != NULL;
	   fscan = fscan->fx_next)
	if (val == fscan->fx_frag->fr_address + fscan->fx_where
	    && fscan->fx_r_type != BFD_RELOC_SH_ALIGN
	    && fscan->fx_r_type != BFD_RELOC_SH_CODE
	    && fscan->fx_r_type != BFD_RELOC_SH_DATA
	    && fscan->fx_r_type != BFD_RELOC_SH_LABEL)
	  break;
      if (fscan == NULL)
	{
	  as_warn_where (fix->fx_file, fix->fx_line,
			 _("can't find fixup pointed to by .uses"));
	  continue;
	}

      if (fscan->fx_tcbit)
	{
	  /* We've already done this one.  */
	  continue;
	}

      /* The variable fscan should also be a fixup to a local symbol
	 in the same section.  */
      sym = fscan->fx_addsy;
      if (sym == NULL
	  || fscan->fx_subsy != NULL
	  || fscan->fx_addnumber != 0
	  || S_GET_SEGMENT (sym) != sec
#if ! defined (BFD_ASSEMBLER) && defined (OBJ_COFF)
	  || S_GET_STORAGE_CLASS (sym) == C_EXT
#endif
	  || S_IS_EXTERNAL (sym))
	{
	  as_warn_where (fix->fx_file, fix->fx_line,
			 _(".uses target does not refer to a local symbol in the same section"));
	  continue;
	}

      /* Now we look through all the fixups of all the sections,
	 counting the number of times we find a reference to sym.  */
      info.sym = sym;
      info.count = 0;
#ifdef BFD_ASSEMBLER
      bfd_map_over_sections (stdoutput, sh_count_relocs, &info);
#else
      {
	int iscan;

	for (iscan = SEG_E0; iscan < SEG_UNKNOWN; iscan++)
	  sh_count_relocs ((bfd *) NULL, iscan, &info);
      }
#endif

      if (info.count < 1)
	abort ();

      /* Generate a BFD_RELOC_SH_COUNT fixup at the location of sym.
	 We have already adjusted the value of sym to include the
	 fragment address, so we undo that adjustment here.  */
      subseg_change (sec, 0);
      fix_new (fscan->fx_frag,
	       S_GET_VALUE (sym) - fscan->fx_frag->fr_address,
	       4, &abs_symbol, info.count, 0, BFD_RELOC_SH_COUNT);
    }
}

/* This function is called after the symbol table has been completed,
   but before the relocs or section contents have been written out.
   If we have seen any .uses pseudo-ops, they point to an instruction
   which loads a register with the address of a function.  We look
   through the fixups to find where the function address is being
   loaded from.  We then generate a COUNT reloc giving the number of
   times that function address is referred to.  The linker uses this
   information when doing relaxing, to decide when it can eliminate
   the stored function address entirely.  */

void
sh_frob_file (void)
{
#ifdef HAVE_SH64
  shmedia_frob_file_before_adjust ();
#endif

  if (! sh_relax)
    return;

#ifdef BFD_ASSEMBLER
  bfd_map_over_sections (stdoutput, sh_frob_section, NULL);
#else
  {
    int iseg;

    for (iseg = SEG_E0; iseg < SEG_UNKNOWN; iseg++)
      sh_frob_section ((bfd *) NULL, iseg, NULL);
  }
#endif
}

/* Called after relaxing.  Set the correct sizes of the fragments, and
   create relocs so that md_apply_fix3 will fill in the correct values.  */

void
#ifdef BFD_ASSEMBLER
md_convert_frag (bfd *headers ATTRIBUTE_UNUSED, segT seg, fragS *fragP)
#else
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED, segT seg,
		 fragS *fragP)
#endif
{
  int donerelax = 0;

  switch (fragP->fr_subtype)
    {
    case C (COND_JUMP, COND8):
    case C (COND_JUMP_DELAY, COND8):
      subseg_change (seg, 0);
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, BFD_RELOC_SH_PCDISP8BY2);
      fragP->fr_fix += 2;
      fragP->fr_var = 0;
      break;

    case C (UNCOND_JUMP, UNCOND12):
      subseg_change (seg, 0);
      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
	       1, BFD_RELOC_SH_PCDISP12BY2);
      fragP->fr_fix += 2;
      fragP->fr_var = 0;
      break;

    case C (UNCOND_JUMP, UNCOND32):
    case C (UNCOND_JUMP, UNDEF_WORD_DISP):
      if (fragP->fr_symbol == NULL)
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement overflows 12-bit field"));
      else if (S_IS_DEFINED (fragP->fr_symbol))
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to defined symbol %s overflows 12-bit field"),
		      S_GET_NAME (fragP->fr_symbol));
      else
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to undefined symbol %s overflows 12-bit field"),
		      S_GET_NAME (fragP->fr_symbol));
      /* Stabilize this frag, so we don't trip an assert.  */
      fragP->fr_fix += fragP->fr_var;
      fragP->fr_var = 0;
      break;

    case C (COND_JUMP, COND12):
    case C (COND_JUMP_DELAY, COND12):
      /* A bcond won't fit, so turn it into a b!cond; bra disp; nop.  */
      /* I found that a relax failure for gcc.c-torture/execute/930628-1.c
	 was due to gas incorrectly relaxing an out-of-range conditional
	 branch with delay slot.  It turned:
                     bf.s    L6              (slot mov.l   r12,@@(44,r0))
         into:

2c:  8f 01 a0 8b     bf.s    32 <_main+32>   (slot bra       L6)
30:  00 09           nop
32:  10 cb           mov.l   r12,@@(44,r0)
         Therefore, branches with delay slots have to be handled
	 differently from ones without delay slots.  */
      {
	unsigned char *buffer =
	  (unsigned char *) (fragP->fr_fix + fragP->fr_literal);
	int highbyte = target_big_endian ? 0 : 1;
	int lowbyte = target_big_endian ? 1 : 0;
	int delay = fragP->fr_subtype == C (COND_JUMP_DELAY, COND12);

	/* Toggle the true/false bit of the bcond.  */
	buffer[highbyte] ^= 0x2;

	/* If this is a delayed branch, we may not put the bra in the
	   slot.  So we change it to a non-delayed branch, like that:
	   b! cond slot_label; bra disp; slot_label: slot_insn
	   ??? We should try if swapping the conditional branch and
	   its delay-slot insn already makes the branch reach.  */

	/* Build a relocation to six / four bytes farther on.  */
	subseg_change (seg, 0);
	fix_new (fragP, fragP->fr_fix, 2,
#ifdef BFD_ASSEMBLER
		 section_symbol (seg),
#else
		 seg_info (seg)->dot,
#endif
		 fragP->fr_address + fragP->fr_fix + (delay ? 4 : 6),
		 1, BFD_RELOC_SH_PCDISP8BY2);

	/* Set up a jump instruction.  */
	buffer[highbyte + 2] = 0xa0;
	buffer[lowbyte + 2] = 0;
	fix_new (fragP, fragP->fr_fix + 2, 2, fragP->fr_symbol,
		 fragP->fr_offset, 1, BFD_RELOC_SH_PCDISP12BY2);

	if (delay)
	  {
	    buffer[highbyte] &= ~0x4; /* Removes delay slot from branch.  */
	    fragP->fr_fix += 4;
	  }
	else
	  {
	    /* Fill in a NOP instruction.  */
	    buffer[highbyte + 4] = 0x0;
	    buffer[lowbyte + 4] = 0x9;

	    fragP->fr_fix += 6;
	  }
	fragP->fr_var = 0;
	donerelax = 1;
      }
      break;

    case C (COND_JUMP, COND32):
    case C (COND_JUMP_DELAY, COND32):
    case C (COND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP_DELAY, UNDEF_WORD_DISP):
      if (fragP->fr_symbol == NULL)
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement overflows 8-bit field"));
      else if (S_IS_DEFINED (fragP->fr_symbol))
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to defined symbol %s overflows 8-bit field"),
		      S_GET_NAME (fragP->fr_symbol));
      else
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to undefined symbol %s overflows 8-bit field "),
		      S_GET_NAME (fragP->fr_symbol));
      /* Stabilize this frag, so we don't trip an assert.  */
      fragP->fr_fix += fragP->fr_var;
      fragP->fr_var = 0;
      break;

    default:
#ifdef HAVE_SH64
      shmedia_md_convert_frag (headers, seg, fragP, TRUE);
#else
      abort ();
#endif
    }

  if (donerelax && !sh_relax)
    as_warn_where (fragP->fr_file, fragP->fr_line,
		   _("overflow in branch to %s; converted into longer instruction sequence"),
		   (fragP->fr_symbol != NULL
		    ? S_GET_NAME (fragP->fr_symbol)
		    : ""));
}

valueT
md_section_align (segT seg ATTRIBUTE_UNUSED, valueT size)
{
#ifdef BFD_ASSEMBLER
#ifdef OBJ_ELF
  return size;
#else /* ! OBJ_ELF */
  return ((size + (1 << bfd_get_section_alignment (stdoutput, seg)) - 1)
	  & (-1 << bfd_get_section_alignment (stdoutput, seg)));
#endif /* ! OBJ_ELF */
#else /* ! BFD_ASSEMBLER */
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
#endif /* ! BFD_ASSEMBLER */
}

/* This static variable is set by s_uacons to tell sh_cons_align that
   the expression does not need to be aligned.  */

static int sh_no_align_cons = 0;

/* This handles the unaligned space allocation pseudo-ops, such as
   .uaword.  .uaword is just like .word, but the value does not need
   to be aligned.  */

static void
s_uacons (int bytes)
{
  /* Tell sh_cons_align not to align this value.  */
  sh_no_align_cons = 1;
  cons (bytes);
}

/* If a .word, et. al., pseud-op is seen, warn if the value is not
   aligned correctly.  Note that this can cause warnings to be issued
   when assembling initialized structured which were declared with the
   packed attribute.  FIXME: Perhaps we should require an option to
   enable this warning?  */

void
sh_cons_align (int nbytes)
{
  int nalign;
  char *p;

  if (sh_no_align_cons)
    {
      /* This is an unaligned pseudo-op.  */
      sh_no_align_cons = 0;
      return;
    }

  nalign = 0;
  while ((nbytes & 1) == 0)
    {
      ++nalign;
      nbytes >>= 1;
    }

  if (nalign == 0)
    return;

  if (now_seg == absolute_section)
    {
      if ((abs_section_offset & ((1 << nalign) - 1)) != 0)
	as_warn (_("misaligned data"));
      return;
    }

  p = frag_var (rs_align_test, 1, 1, (relax_substateT) 0,
		(symbolS *) NULL, (offsetT) nalign, (char *) NULL);

  record_alignment (now_seg, nalign);
}

/* When relaxing, we need to output a reloc for any .align directive
   that requests alignment to a four byte boundary or larger.  This is
   also where we check for misaligned data.  */

void
sh_handle_align (fragS *frag)
{
  int bytes = frag->fr_next->fr_address - frag->fr_address - frag->fr_fix;

  if (frag->fr_type == rs_align_code)
    {
      static const unsigned char big_nop_pattern[] = { 0x00, 0x09 };
      static const unsigned char little_nop_pattern[] = { 0x09, 0x00 };

      char *p = frag->fr_literal + frag->fr_fix;

      if (bytes & 1)
	{
	  *p++ = 0;
	  bytes--;
	  frag->fr_fix += 1;
	}

      if (target_big_endian)
	{
	  memcpy (p, big_nop_pattern, sizeof big_nop_pattern);
	  frag->fr_var = sizeof big_nop_pattern;
	}
      else
	{
	  memcpy (p, little_nop_pattern, sizeof little_nop_pattern);
	  frag->fr_var = sizeof little_nop_pattern;
	}
    }
  else if (frag->fr_type == rs_align_test)
    {
      if (bytes != 0)
	as_warn_where (frag->fr_file, frag->fr_line, _("misaligned data"));
    }

  if (sh_relax
      && (frag->fr_type == rs_align
	  || frag->fr_type == rs_align_code)
      && frag->fr_address + frag->fr_fix > 0
      && frag->fr_offset > 1
      && now_seg != bss_section)
    fix_new (frag, frag->fr_fix, 2, &abs_symbol, frag->fr_offset, 0,
	     BFD_RELOC_SH_ALIGN);
}

/* See whether the relocation should be resolved locally.  */

static bfd_boolean
sh_local_pcrel (fixS *fix)
{
  return (! sh_relax
	  && (fix->fx_r_type == BFD_RELOC_SH_PCDISP8BY2
	      || fix->fx_r_type == BFD_RELOC_SH_PCDISP12BY2
	      || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY2
	      || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY4
	      || fix->fx_r_type == BFD_RELOC_8_PCREL
	      || fix->fx_r_type == BFD_RELOC_SH_SWITCH16
	      || fix->fx_r_type == BFD_RELOC_SH_SWITCH32));
}

/* See whether we need to force a relocation into the output file.
   This is used to force out switch and PC relative relocations when
   relaxing.  */

int
sh_force_relocation (fixS *fix)
{
  /* These relocations can't make it into a DSO, so no use forcing
     them for global symbols.  */
  if (sh_local_pcrel (fix))
    return 0;

  /* Make sure some relocations get emitted.  */
  if (fix->fx_r_type == BFD_RELOC_SH_LOOP_START
      || fix->fx_r_type == BFD_RELOC_SH_LOOP_END
      || fix->fx_r_type == BFD_RELOC_SH_TLS_GD_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_LD_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_IE_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_LDO_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_LE_32
      || generic_force_reloc (fix))
    return 1;

  if (! sh_relax)
    return 0;

  return (fix->fx_pcrel
	  || SWITCH_TABLE (fix)
	  || fix->fx_r_type == BFD_RELOC_SH_COUNT
	  || fix->fx_r_type == BFD_RELOC_SH_ALIGN
	  || fix->fx_r_type == BFD_RELOC_SH_CODE
	  || fix->fx_r_type == BFD_RELOC_SH_DATA
#ifdef HAVE_SH64
	  || fix->fx_r_type == BFD_RELOC_SH_SHMEDIA_CODE
#endif
	  || fix->fx_r_type == BFD_RELOC_SH_LABEL);
}

#ifdef OBJ_ELF
bfd_boolean
sh_fix_adjustable (fixS *fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_32_PLT_PCREL
      || fixP->fx_r_type == BFD_RELOC_32_GOT_PCREL
      || fixP->fx_r_type == BFD_RELOC_SH_GOTPC
      || ((fixP->fx_r_type == BFD_RELOC_32) && dont_adjust_reloc_32)
      || fixP->fx_r_type == BFD_RELOC_RVA)
    return 0;

  /* We need the symbol name for the VTABLE entries */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}

void
sh_elf_final_processing (void)
{
  int val;

  /* Set file-specific flags to indicate if this code needs
     a processor with the sh-dsp / sh2e ISA to execute.  */
#ifdef HAVE_SH64
  /* SH5 and above don't know about the valid_arch arch_sh* bits defined
     in sh-opc.h, so check SH64 mode before checking valid_arch.  */
  if (sh64_isa_mode != sh64_isa_unspecified)
    val = EF_SH5;
  else
#endif /* HAVE_SH64 */
  if (valid_arch & arch_sh1)
    val = EF_SH1;
  else if (valid_arch & arch_sh2)
    val = EF_SH2;
  else if (valid_arch & arch_sh2e)
    val = EF_SH2E;
  else if (valid_arch & arch_sh_dsp)
    val = EF_SH_DSP;
  else if (valid_arch & arch_sh3)
    val = EF_SH3;
  else if (valid_arch & arch_sh3_dsp)
    val = EF_SH3_DSP;
  else if (valid_arch & arch_sh3e)
    val = EF_SH3E;
  else if (valid_arch & arch_sh4_nofpu)
    val = EF_SH4_NOFPU;
  else if (valid_arch & arch_sh4)
    val = EF_SH4;
  else if (valid_arch & arch_sh4a_nofpu)
    val = EF_SH4A_NOFPU;
  else if (valid_arch & arch_sh4a)
    val = EF_SH4A;
  else if (valid_arch & arch_sh4al_dsp)
    val = EF_SH4AL_DSP;
  else
    abort ();

  elf_elfheader (stdoutput)->e_flags &= ~EF_SH_MACH_MASK;
  elf_elfheader (stdoutput)->e_flags |= val;
}
#endif

/* Apply a fixup to the object file.  */

void
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  int lowbyte = target_big_endian ? 1 : 0;
  int highbyte = target_big_endian ? 0 : 1;
  long val = (long) *valP;
  long max, min;
  int shift;

#ifdef BFD_ASSEMBLER
  /* A difference between two symbols, the second of which is in the
     current section, is transformed in a PC-relative relocation to
     the other symbol.  We have to adjust the relocation type here.  */
  if (fixP->fx_pcrel)
    {
      switch (fixP->fx_r_type)
	{
	default:
	  break;

	case BFD_RELOC_32:
	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  break;

	  /* Currently, we only support 32-bit PCREL relocations.
	     We'd need a new reloc type to handle 16_PCREL, and
	     8_PCREL is already taken for R_SH_SWITCH8, which
	     apparently does something completely different than what
	     we need.  FIXME.  */
	case BFD_RELOC_16:
	  bfd_set_error (bfd_error_bad_value);
	  return;

	case BFD_RELOC_8:
	  bfd_set_error (bfd_error_bad_value);
	  return;
	}
    }

  /* The function adjust_reloc_syms won't convert a reloc against a weak
     symbol into a reloc against a section, but bfd_install_relocation
     will screw up if the symbol is defined, so we have to adjust val here
     to avoid the screw up later.

     For ordinary relocs, this does not happen for ELF, since for ELF,
     bfd_install_relocation uses the "special function" field of the
     howto, and does not execute the code that needs to be undone, as long
     as the special function does not return bfd_reloc_continue.
     It can happen for GOT- and PLT-type relocs the way they are
     described in elf32-sh.c as they use bfd_elf_generic_reloc, but it
     doesn't matter here since those relocs don't use VAL; see below.  */
  if (OUTPUT_FLAVOR != bfd_target_elf_flavour
      && fixP->fx_addsy != NULL
      && S_IS_WEAK (fixP->fx_addsy))
    val -= S_GET_VALUE  (fixP->fx_addsy);
#endif

#ifdef BFD_ASSEMBLER
  if (SWITCH_TABLE (fixP))
    val -= S_GET_VALUE  (fixP->fx_subsy);
#else
  if (fixP->fx_r_type == 0)
    {
      if (fixP->fx_size == 2)
	fixP->fx_r_type = BFD_RELOC_16;
      else if (fixP->fx_size == 4)
	fixP->fx_r_type = BFD_RELOC_32;
      else if (fixP->fx_size == 1)
	fixP->fx_r_type = BFD_RELOC_8;
      else
	abort ();
    }
#endif

  max = min = 0;
  shift = 0;
  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_SH_IMM4:
      max = 0xf;
      *buf = (*buf & 0xf0) | (val & 0xf);
      break;

    case BFD_RELOC_SH_IMM4BY2:
      max = 0xf;
      shift = 1;
      *buf = (*buf & 0xf0) | ((val >> 1) & 0xf);
      break;

    case BFD_RELOC_SH_IMM4BY4:
      max = 0xf;
      shift = 2;
      *buf = (*buf & 0xf0) | ((val >> 2) & 0xf);
      break;

    case BFD_RELOC_SH_IMM8BY2:
      max = 0xff;
      shift = 1;
      *buf = val >> 1;
      break;

    case BFD_RELOC_SH_IMM8BY4:
      max = 0xff;
      shift = 2;
      *buf = val >> 2;
      break;

    case BFD_RELOC_8:
    case BFD_RELOC_SH_IMM8:
      /* Sometimes the 8 bit value is sign extended (e.g., add) and
         sometimes it is not (e.g., and).  We permit any 8 bit value.
         Note that adding further restrictions may invalidate
         reasonable looking assembly code, such as ``and -0x1,r0''.  */
      max = 0xff;
      min = -0xff;
      *buf++ = val;
      break;

    case BFD_RELOC_SH_PCRELIMM8BY4:
      /* The lower two bits of the PC are cleared before the
         displacement is added in.  We can assume that the destination
         is on a 4 byte boundary.  If this instruction is also on a 4
         byte boundary, then we want
	   (target - here) / 4
	 and target - here is a multiple of 4.
	 Otherwise, we are on a 2 byte boundary, and we want
	   (target - (here - 2)) / 4
	 and target - here is not a multiple of 4.  Computing
	   (target - (here - 2)) / 4 == (target - here + 2) / 4
	 works for both cases, since in the first case the addition of
	 2 will be removed by the division.  target - here is in the
	 variable val.  */
      val = (val + 2) / 4;
      if (val & ~0xff)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
      buf[lowbyte] = val;
      break;

    case BFD_RELOC_SH_PCRELIMM8BY2:
      val /= 2;
      if (val & ~0xff)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
      buf[lowbyte] = val;
      break;

    case BFD_RELOC_SH_PCDISP8BY2:
      val /= 2;
      if (val < -0x80 || val > 0x7f)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
      buf[lowbyte] = val;
      break;

    case BFD_RELOC_SH_PCDISP12BY2:
      val /= 2;
      if (val < -0x800 || val > 0x7ff)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
      buf[lowbyte] = val & 0xff;
      buf[highbyte] |= (val >> 8) & 0xf;
      break;

    case BFD_RELOC_32:
    case BFD_RELOC_32_PCREL:
      md_number_to_chars (buf, val, 4);
      break;

    case BFD_RELOC_16:
      md_number_to_chars (buf, val, 2);
      break;

    case BFD_RELOC_SH_USES:
      /* Pass the value into sh_coff_reloc_mangle.  */
      fixP->fx_addnumber = val;
      break;

    case BFD_RELOC_SH_COUNT:
    case BFD_RELOC_SH_ALIGN:
    case BFD_RELOC_SH_CODE:
    case BFD_RELOC_SH_DATA:
    case BFD_RELOC_SH_LABEL:
      /* Nothing to do here.  */
      break;

    case BFD_RELOC_SH_LOOP_START:
    case BFD_RELOC_SH_LOOP_END:

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

#ifdef OBJ_ELF
    case BFD_RELOC_32_PLT_PCREL:
      /* Make the jump instruction point to the address of the operand.  At
	 runtime we merely add the offset to the actual PLT entry.  */
      * valP = 0xfffffffc;
      val = fixP->fx_offset;
      if (fixP->fx_subsy)
	val -= S_GET_VALUE (fixP->fx_subsy);
      fixP->fx_addnumber = val;
      md_number_to_chars (buf, val, 4);
      break;

    case BFD_RELOC_SH_GOTPC:
      /* This is tough to explain.  We end up with this one if we have
         operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".
         The goal here is to obtain the absolute address of the GOT,
         and it is strongly preferable from a performance point of
         view to avoid using a runtime relocation for this.  There are
         cases where you have something like:

         .long	_GLOBAL_OFFSET_TABLE_+[.-.L66]

         and here no correction would be required.  Internally in the
         assembler we treat operands of this form as not being pcrel
         since the '.' is explicitly mentioned, and I wonder whether
         it would simplify matters to do it this way.  Who knows.  In
         earlier versions of the PIC patches, the pcrel_adjust field
         was used to store the correction, but since the expression is
         not pcrel, I felt it would be confusing to do it this way.  */
      * valP -= 1;
      md_number_to_chars (buf, val, 4);
      break;

    case BFD_RELOC_SH_TLS_GD_32:
    case BFD_RELOC_SH_TLS_LD_32:
    case BFD_RELOC_SH_TLS_IE_32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* Fallthrough */
    case BFD_RELOC_32_GOT_PCREL:
    case BFD_RELOC_SH_GOTPLT32:
      * valP = 0; /* Fully resolved at runtime.  No addend.  */
      md_number_to_chars (buf, 0, 4);
      break;

    case BFD_RELOC_SH_TLS_LDO_32:
    case BFD_RELOC_SH_TLS_LE_32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* Fallthrough */
    case BFD_RELOC_32_GOTOFF:
      md_number_to_chars (buf, val, 4);
      break;
#endif

    default:
#ifdef HAVE_SH64
      shmedia_md_apply_fix3 (fixP, valP);
      return;
#else
      abort ();
#endif
    }

  if (shift != 0)
    {
      if ((val & ((1 << shift) - 1)) != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("misaligned offset"));
      if (val >= 0)
	val >>= shift;
      else
	val = ((val >> shift)
	       | ((long) -1 & ~ ((long) -1 >> shift)));
    }
  if (max != 0 && (val < min || val > max))
    as_bad_where (fixP->fx_file, fixP->fx_line, _("offset out of range"));

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Called just before address relaxation.  Return the length
   by which a fragment must grow to reach it's destination.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment_type)
{
  int what;

  switch (fragP->fr_subtype)
    {
    default:
#ifdef HAVE_SH64
      return shmedia_md_estimate_size_before_relax (fragP, segment_type);
#else
      abort ();
#endif


    case C (UNCOND_JUMP, UNDEF_DISP):
      /* Used to be a branch to somewhere which was unknown.  */
      if (!fragP->fr_symbol)
	{
	  fragP->fr_subtype = C (UNCOND_JUMP, UNCOND12);
	}
      else if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  fragP->fr_subtype = C (UNCOND_JUMP, UNCOND12);
	}
      else
	{
	  fragP->fr_subtype = C (UNCOND_JUMP, UNDEF_WORD_DISP);
	}
      break;

    case C (COND_JUMP, UNDEF_DISP):
    case C (COND_JUMP_DELAY, UNDEF_DISP):
      what = GET_WHAT (fragP->fr_subtype);
      /* Used to be a branch to somewhere which was unknown.  */
      if (fragP->fr_symbol
	  && S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  /* Got a symbol and it's defined in this segment, become byte
	     sized - maybe it will fix up.  */
	  fragP->fr_subtype = C (what, COND8);
	}
      else if (fragP->fr_symbol)
	{
	  /* Its got a segment, but its not ours, so it will always be long.  */
	  fragP->fr_subtype = C (what, UNDEF_WORD_DISP);
	}
      else
	{
	  /* We know the abs value.  */
	  fragP->fr_subtype = C (what, COND8);
	}
      break;

    case C (UNCOND_JUMP, UNCOND12):
    case C (UNCOND_JUMP, UNCOND32):
    case C (UNCOND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP, COND8):
    case C (COND_JUMP, COND12):
    case C (COND_JUMP, COND32):
    case C (COND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP_DELAY, COND8):
    case C (COND_JUMP_DELAY, COND12):
    case C (COND_JUMP_DELAY, COND32):
    case C (COND_JUMP_DELAY, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
    }

  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
  return fragP->fr_var;
}

/* Put number into target byte order.  */

void
md_number_to_chars (char *ptr, valueT use, int nbytes)
{
#ifdef HAVE_SH64
  /* We might need to set the contents type to data.  */
  sh64_flag_output ();
#endif

  if (! target_big_endian)
    number_to_chars_littleendian (ptr, use, nbytes);
  else
    number_to_chars_bigendian (ptr, use, nbytes);
}

/* This version is used in obj-coff.c when not using BFD_ASSEMBLER.
   eg for the sh-hms target.  */

long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address + 2;
}

long
md_pcrel_from_section (fixS *fixP, segT sec)
{
  if (! sh_local_pcrel (fixP)
      && fixP->fx_addsy != (symbolS *) NULL
      && (generic_force_reloc (fixP)
	  || S_GET_SEGMENT (fixP->fx_addsy) != sec))
    {
      /* The symbol is undefined (or is defined but not in this section,
	 or we're not sure about it being the final definition).  Let the
	 linker figure it out.  We need to adjust the subtraction of a
	 symbol to the position of the relocated data, though.  */
      return fixP->fx_subsy ? fixP->fx_where + fixP->fx_frag->fr_address : 0;
    }

  return md_pcrel_from (fixP);
}

#ifdef OBJ_COFF

int
tc_coff_sizemachdep (fragS *frag)
{
  return md_relax_table[frag->fr_subtype].rlx_length;
}

#endif /* OBJ_COFF */

#ifndef BFD_ASSEMBLER
#ifdef OBJ_COFF

/* Map BFD relocs to SH COFF relocs.  */

struct reloc_map
{
  bfd_reloc_code_real_type bfd_reloc;
  int sh_reloc;
};

static const struct reloc_map coff_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32 },
  { BFD_RELOC_16, R_SH_IMM16 },
  { BFD_RELOC_8, R_SH_IMM8 },
  { BFD_RELOC_SH_PCDISP8BY2, R_SH_PCDISP8BY2 },
  { BFD_RELOC_SH_PCDISP12BY2, R_SH_PCDISP },
  { BFD_RELOC_SH_IMM4, R_SH_IMM4 },
  { BFD_RELOC_SH_IMM4BY2, R_SH_IMM4BY2 },
  { BFD_RELOC_SH_IMM4BY4, R_SH_IMM4BY4 },
  { BFD_RELOC_SH_IMM8, R_SH_IMM8 },
  { BFD_RELOC_SH_IMM8BY2, R_SH_IMM8BY2 },
  { BFD_RELOC_SH_IMM8BY4, R_SH_IMM8BY4 },
  { BFD_RELOC_SH_PCRELIMM8BY2, R_SH_PCRELIMM8BY2 },
  { BFD_RELOC_SH_PCRELIMM8BY4, R_SH_PCRELIMM8BY4 },
  { BFD_RELOC_8_PCREL, R_SH_SWITCH8 },
  { BFD_RELOC_SH_SWITCH16, R_SH_SWITCH16 },
  { BFD_RELOC_SH_SWITCH32, R_SH_SWITCH32 },
  { BFD_RELOC_SH_USES, R_SH_USES },
  { BFD_RELOC_SH_COUNT, R_SH_COUNT },
  { BFD_RELOC_SH_ALIGN, R_SH_ALIGN },
  { BFD_RELOC_SH_CODE, R_SH_CODE },
  { BFD_RELOC_SH_DATA, R_SH_DATA },
  { BFD_RELOC_SH_LABEL, R_SH_LABEL },
  { BFD_RELOC_UNUSED, 0 }
};

/* Adjust a reloc for the SH.  This is similar to the generic code,
   but does some minor tweaking.  */

void
sh_coff_reloc_mangle (segment_info_type *seg, fixS *fix,
		      struct internal_reloc *intr, unsigned int paddr)
{
  symbolS *symbol_ptr = fix->fx_addsy;
  symbolS *dot;

  intr->r_vaddr = paddr + fix->fx_frag->fr_address + fix->fx_where;

  if (! SWITCH_TABLE (fix))
    {
      const struct reloc_map *rm;

      for (rm = coff_reloc_map; rm->bfd_reloc != BFD_RELOC_UNUSED; rm++)
	if (rm->bfd_reloc == (bfd_reloc_code_real_type) fix->fx_r_type)
	  break;
      if (rm->bfd_reloc == BFD_RELOC_UNUSED)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("Can not represent %s relocation in this object file format"),
		      bfd_get_reloc_code_name (fix->fx_r_type));
      intr->r_type = rm->sh_reloc;
      intr->r_offset = 0;
    }
  else
    {
      know (sh_relax);

      if (fix->fx_r_type == BFD_RELOC_16)
	intr->r_type = R_SH_SWITCH16;
      else if (fix->fx_r_type == BFD_RELOC_8)
	intr->r_type = R_SH_SWITCH8;
      else if (fix->fx_r_type == BFD_RELOC_32)
	intr->r_type = R_SH_SWITCH32;
      else
	abort ();

      /* For a switch reloc, we set r_offset to the difference between
         the reloc address and the subtrahend.  When the linker is
         doing relaxing, it can use the determine the starting and
         ending points of the switch difference expression.  */
      intr->r_offset = intr->r_vaddr - S_GET_VALUE (fix->fx_subsy);
    }

  /* PC relative relocs are always against the current section.  */
  if (symbol_ptr == NULL)
    {
      switch (fix->fx_r_type)
	{
	case BFD_RELOC_SH_PCRELIMM8BY2:
	case BFD_RELOC_SH_PCRELIMM8BY4:
	case BFD_RELOC_SH_PCDISP8BY2:
	case BFD_RELOC_SH_PCDISP12BY2:
	case BFD_RELOC_SH_USES:
	  symbol_ptr = seg->dot;
	  break;
	default:
	  break;
	}
    }

  if (fix->fx_r_type == BFD_RELOC_SH_USES)
    {
      /* We can't store the offset in the object file, since this
	 reloc does not take up any space, so we store it in r_offset.
	 The fx_addnumber field was set in md_apply_fix3.  */
      intr->r_offset = fix->fx_addnumber;
    }
  else if (fix->fx_r_type == BFD_RELOC_SH_COUNT)
    {
      /* We can't store the count in the object file, since this reloc
         does not take up any space, so we store it in r_offset.  The
         fx_offset field was set when the fixup was created in
         sh_coff_frob_file.  */
      intr->r_offset = fix->fx_offset;
      /* This reloc is always absolute.  */
      symbol_ptr = NULL;
    }
  else if (fix->fx_r_type == BFD_RELOC_SH_ALIGN)
    {
      /* Store the alignment in the r_offset field.  */
      intr->r_offset = fix->fx_offset;
      /* This reloc is always absolute.  */
      symbol_ptr = NULL;
    }
  else if (fix->fx_r_type == BFD_RELOC_SH_CODE
	   || fix->fx_r_type == BFD_RELOC_SH_DATA
	   || fix->fx_r_type == BFD_RELOC_SH_LABEL)
    {
      /* These relocs are always absolute.  */
      symbol_ptr = NULL;
    }

  /* Turn the segment of the symbol into an offset.  */
  if (symbol_ptr != NULL)
    {
      dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
      if (dot != NULL)
	intr->r_symndx = dot->sy_number;
      else
	intr->r_symndx = symbol_ptr->sy_number;
    }
  else
    intr->r_symndx = -1;
}

#endif /* OBJ_COFF */
#endif /* ! BFD_ASSEMBLER */

#ifdef BFD_ASSEMBLER

/* Create a reloc.  */

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *rel;
  bfd_reloc_code_real_type r_type;

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;

  r_type = fixp->fx_r_type;

  if (SWITCH_TABLE (fixp))
    {
      *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_subsy);
      rel->addend = 0;
      if (r_type == BFD_RELOC_16)
	r_type = BFD_RELOC_SH_SWITCH16;
      else if (r_type == BFD_RELOC_8)
	r_type = BFD_RELOC_8_PCREL;
      else if (r_type == BFD_RELOC_32)
	r_type = BFD_RELOC_SH_SWITCH32;
      else
	abort ();
    }
  else if (r_type == BFD_RELOC_SH_USES)
    rel->addend = fixp->fx_addnumber;
  else if (r_type == BFD_RELOC_SH_COUNT)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_SH_ALIGN)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_VTABLE_INHERIT
           || r_type == BFD_RELOC_VTABLE_ENTRY)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_SH_LOOP_START
           || r_type == BFD_RELOC_SH_LOOP_END)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_SH_LABEL && fixp->fx_pcrel)
    {
      rel->addend = 0;
      rel->address = rel->addend = fixp->fx_offset;
    }
#ifdef HAVE_SH64
  else if (shmedia_init_reloc (rel, fixp))
    ;
#endif
  else if (fixp->fx_pcrel)
    rel->addend = fixp->fx_addnumber;
  else if (r_type == BFD_RELOC_32 || r_type == BFD_RELOC_32_GOTOFF)
    rel->addend = fixp->fx_addnumber;
  else
    rel->addend = 0;

  rel->howto = bfd_reloc_type_lookup (stdoutput, r_type);

  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (r_type));
      /* Set howto to a garbage value so that we can keep going.  */
      rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
      assert (rel->howto != NULL);
    }
#ifdef OBJ_ELF
  else if (rel->howto->type == R_SH_IND12W)
    rel->addend += fixp->fx_offset - 4;
#endif

  return rel;
}

#ifdef OBJ_ELF
inline static char *
sh_end_of_match (char *cont, char *what)
{
  int len = strlen (what);

  if (strncasecmp (cont, what, strlen (what)) == 0
      && ! is_part_of_name (cont[len]))
    return cont + len;

  return NULL;
}

int
sh_parse_name (char const *name, expressionS *exprP, char *nextcharP)
{
  char *next = input_line_pointer;
  char *next_end;
  int reloc_type;
  segT segment;

  exprP->X_op_symbol = NULL;

  if (strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (! GOT_symbol)
	GOT_symbol = symbol_find_or_make (name);

      exprP->X_add_symbol = GOT_symbol;
    no_suffix:
      /* If we have an absolute symbol or a reg, then we know its
	     value now.  */
      segment = S_GET_SEGMENT (exprP->X_add_symbol);
      if (segment == absolute_section)
	{
	  exprP->X_op = O_constant;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else if (segment == reg_section)
	{
	  exprP->X_op = O_register;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else
	{
	  exprP->X_op = O_symbol;
	  exprP->X_add_number = 0;
	}

      return 1;
    }

  exprP->X_add_symbol = symbol_find_or_make (name);

  if (*nextcharP != '@@')
    goto no_suffix;
  else if ((next_end = sh_end_of_match (next + 1, "GOTOFF")))
    reloc_type = BFD_RELOC_32_GOTOFF;
  else if ((next_end = sh_end_of_match (next + 1, "GOTPLT")))
    reloc_type = BFD_RELOC_SH_GOTPLT32;
  else if ((next_end = sh_end_of_match (next + 1, "GOT")))
    reloc_type = BFD_RELOC_32_GOT_PCREL;
  else if ((next_end = sh_end_of_match (next + 1, "PLT")))
    reloc_type = BFD_RELOC_32_PLT_PCREL;
  else if ((next_end = sh_end_of_match (next + 1, "TLSGD")))
    reloc_type = BFD_RELOC_SH_TLS_GD_32;
  else if ((next_end = sh_end_of_match (next + 1, "TLSLDM")))
    reloc_type = BFD_RELOC_SH_TLS_LD_32;
  else if ((next_end = sh_end_of_match (next + 1, "GOTTPOFF")))
    reloc_type = BFD_RELOC_SH_TLS_IE_32;
  else if ((next_end = sh_end_of_match (next + 1, "TPOFF")))
    reloc_type = BFD_RELOC_SH_TLS_LE_32;
  else if ((next_end = sh_end_of_match (next + 1, "DTPOFF")))
    reloc_type = BFD_RELOC_SH_TLS_LDO_32;
  else
    goto no_suffix;

  *input_line_pointer = *nextcharP;
  input_line_pointer = next_end;
  *nextcharP = *input_line_pointer;
  *input_line_pointer = '\0';

  exprP->X_op = O_PIC_reloc;
  exprP->X_add_number = 0;
  exprP->X_md = reloc_type;

  return 1;
}
#endif

void
sh_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (15, 0);
}

int
sh_regname_to_dw2regnum (const char *regname)
{
  unsigned int regnum = -1;
  unsigned int i;
  const char *p;
  char *q;
  static struct { char *name; int dw2regnum; } regnames[] =
    {
      { "pr", 17 }, { "t", 18 }, { "gbr", 19 }, { "mach", 20 },
      { "macl", 21 }, { "fpul", 23 }
    };

  for (i = 0; i < ARRAY_SIZE (regnames); ++i)
    if (strcmp (regnames[i].name, regname) == 0)
      return regnames[i].dw2regnum;

  if (regname[0] == 'r')
    {
      p = regname + 1;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 16)
	return -1;
    }
  else if (regname[0] == 'f' && regname[1] == 'r')
    {
      p = regname + 2;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 16)
	return -1;
      regnum += 25;
    }
  else if (regname[0] == 'x' && regname[1] == 'd')
    {
      p = regname + 2;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 8)
	return -1;
      regnum += 87;
    }
  return regnum;
}
#endif /* BFD_ASSEMBLER */
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d38 1
d52 2
a53 24
static void s_uses PARAMS ((int));

static void sh_count_relocs PARAMS ((bfd *, segT, PTR));
static void sh_frob_section PARAMS ((bfd *, segT, PTR));

static void s_uacons PARAMS ((int));
static sh_opcode_info *find_cooked_opcode PARAMS ((char **));
static unsigned int assemble_ppi PARAMS ((char *, sh_opcode_info *));
static void little PARAMS ((int));
static void big PARAMS ((int));
static int parse_reg PARAMS ((char *, int *, int *));
static char *parse_exp PARAMS ((char *, sh_operand_info *));
static char *parse_at PARAMS ((char *, sh_operand_info *));
static void get_operand PARAMS ((char **, sh_operand_info *));
static char *get_operands
  PARAMS ((sh_opcode_info *, char *, sh_operand_info *));
static sh_opcode_info *get_specific
  PARAMS ((sh_opcode_info *, sh_operand_info *));
static void insert PARAMS ((char *, int, int, sh_operand_info *));
static void build_relax PARAMS ((sh_opcode_info *, sh_operand_info *));
static char *insert_loop_bounds PARAMS ((char *, sh_operand_info *));
static unsigned int build_Mytes
  PARAMS ((sh_opcode_info *, sh_operand_info *));
static bfd_boolean sh_local_pcrel PARAMS ((fixS *fix));
d56 1
a56 5
static void sh_elf_cons PARAMS ((int));

inline static int sh_PIC_related_p PARAMS ((symbolS *));
static int sh_check_fixup PARAMS ((expressionS *, bfd_reloc_code_real_type *));
inline static char *sh_end_of_match PARAMS ((char *, char *));
d62 1
a62 2
big (ignore)
     int ignore ATTRIBUTE_UNUSED;
d72 1
a72 2
little (ignore)
     int ignore ATTRIBUTE_UNUSED;
a111 4
#ifdef BFD_ASSEMBLER
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
#endif
d135 4
d144 1
a144 1
   accomodate the insns seen so far.  */
d159 1
a159 1
/* These are the three types of relaxable instrction.  */
d490 1
a490 2
sh_PIC_related_p (sym)
     symbolS *sym;
d516 1
a516 3
sh_check_fixup (main_exp, r_type_p)
     expressionS *main_exp;
     bfd_reloc_code_real_type *r_type_p;
d742 1
a742 4
sh_cons_fix_new (frag, off, size, exp)
     fragS *frag;
     int off, size;
     expressionS *exp;
d787 1
d789 1
a789 2
sh_elf_cons (nbytes)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
d809 4
d835 1
a835 1
md_begin ()
d875 1
a875 4
parse_reg (src, mode, reg)
     char *src;
     int *mode;
     int *reg;
d1225 1
a1225 3
parse_exp (s, op)
     char *s;
     sh_operand_info *op;
d1266 1
a1266 3
parse_at (src, op)
     char *src;
     sh_operand_info *op;
d1350 1
a1350 1
		     as adressing sym, i.e. meaning the same as plain sym.
d1408 1
a1408 1
	      op->type = A_PMOD_N;
d1414 1
a1414 1
	      op->type = A_PMODY_N;
d1426 1
a1426 3
get_operand (ptr, op)
     char **ptr;
     sh_operand_info *op;
d1462 1
a1462 4
get_operands (info, args, operand)
     sh_opcode_info *info;
     char *args;
     sh_operand_info *operand;
d1520 1
a1520 3
get_specific (opcode, operands)
     sh_opcode_info *opcode;
     sh_operand_info *operands;
a1586 2
	    case A_PMOD_N:
	    case A_PMODY_N:
d1632 231
d2033 1
a2033 5
insert (where, how, pcrel, op)
     char *where;
     int how;
     int pcrel;
     sh_operand_info *op;
d2044 1
a2044 3
build_relax (opcode, op)
     sh_opcode_info *opcode;
     sh_operand_info *op;
d2078 1
a2078 3
insert_loop_bounds (output, operand)
     char *output;
     sh_operand_info *operand;
d2126 1
a2126 3
build_Mytes (opcode, operand)
     sh_opcode_info *opcode;
     sh_operand_info *operand;
d2150 1
d2167 3
d2241 1
a2241 2
find_cooked_opcode (str_p)
     char **str_p;
d2288 1
a2288 3
assemble_ppi (op_end, opcode)
     char *op_end;
     sh_opcode_info *opcode;
d2310 1
d2341 32
d2376 2
d2399 2
d2429 7
d2441 13
d2468 13
d2485 10
a2494 1
	      if ((field_b & 0xef00) != 0xa100)
a2495 1
	      field_b -= 0x8100;
d2511 1
a2511 1
		  as_bad (_("bad padd / psub pmuls output operand"));
d2589 1
a2589 2
md_assemble (str)
     char *str;
d2644 6
d2697 1
a2697 1
sh_frob_label ()
d2722 1
a2722 1
sh_flush_pending_output ()
d2734 1
a2734 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d2743 1
a2743 2
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d2749 1
a2749 2
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d2767 1
a2767 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d2821 1
a2821 2
s_uses (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2851 1
d2859 2
d2862 1
a2862 1
#define OPTION_ABI                    (OPTION_ISA + 1)
d2879 1
a2879 3
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
d2900 5
a2904 1
      preset_target_arch = arch_sh1_up & ~arch_sh3e_up;
d2910 6
d2983 1
a2983 2
md_show_usage (stream)
     FILE *stream;
d2990 2
d2993 1
a2993 1
-dsp			enable sh-dsp insns, and disable sh2e/sh3e/sh4 insns.\n"));
d2996 9
a3004 4
-isa=[shmedia		set default instruction set for SH64\n\
      | SHmedia\n\
      | shcompact\n\
      | SHcompact]\n\
d3013 8
a3020 1
			to 32 bits only"));
d3040 1
a3040 4
sh_count_relocs (abfd, sec, data)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec;
     PTR data;
d3066 2
a3067 4
sh_frob_section (abfd, sec, ignore)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec;
     PTR ignore ATTRIBUTE_UNUSED;
d3150 1
a3150 1
      bfd_map_over_sections (stdoutput, sh_count_relocs, (PTR) &info);
d3156 1
a3156 1
	  sh_count_relocs ((bfd *) NULL, iscan, (PTR) &info);
d3184 1
a3184 1
sh_frob_file ()
d3194 1
a3194 1
  bfd_map_over_sections (stdoutput, sh_frob_section, (PTR) NULL);
d3200 1
a3200 1
      sh_frob_section ((bfd *) NULL, iseg, (PTR) NULL);
a3208 1
md_convert_frag (headers, seg, fragP)
d3210 1
a3210 1
     bfd *headers ATTRIBUTE_UNUSED;
d3212 2
a3213 1
     object_headers *headers ATTRIBUTE_UNUSED;
a3214 2
     segT seg;
     fragS *fragP;
d3357 1
a3357 3
md_section_align (seg, size)
     segT seg ATTRIBUTE_UNUSED;
     valueT size;
d3373 1
a3373 1
   the expession does not need to be aligned.  */
d3382 1
a3382 2
s_uacons (bytes)
     int bytes;
d3396 1
a3396 2
sh_cons_align (nbytes)
     int nbytes;
d3436 1
a3436 2
sh_handle_align (frag)
     fragS *frag;
d3484 1
a3484 2
sh_local_pcrel (fix)
     fixS *fix;
d3501 1
a3501 2
sh_force_relocation (fix)
     fixS *fix;
d3536 1
a3536 2
sh_fix_adjustable (fixP)
   fixS *fixP;
d3541 1
d3554 1
a3554 1
sh_elf_final_processing ()
d3559 1
a3559 1
     a processor with the sh-dsp / sh3e ISA to execute.  */
d3578 1
a3578 1
    val = EF_SH_DSP;
d3581 2
d3585 6
d3602 1
a3602 4
md_apply_fix3 (fixP, valP, seg)
     fixS * fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d3723 1
a3723 1
         is on a 4 byte bounday.  If this instruction is also on a 4
d3875 1
a3875 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP;
     register segT segment_type;
d3951 1
a3951 4
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
d3968 1
a3968 2
md_pcrel_from (fixP)
     fixS *fixP;
d3974 1
a3974 3
md_pcrel_from_section (fixP, sec)
     fixS *fixP;
     segT sec;
d3994 1
a3994 2
tc_coff_sizemachdep (frag)
     fragS *frag;
d4043 2
a4044 5
sh_coff_reloc_mangle (seg, fix, intr, paddr)
     segment_info_type *seg;
     fixS *fix;
     struct internal_reloc *intr;
     unsigned int paddr;
d4155 1
a4155 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d4209 1
a4209 2
  if (rel->howto->type == R_SH_IND12W)
      rel->addend += fixp->fx_offset - 4;
d4219 4
d4229 1
a4229 2
sh_end_of_match (cont, what)
     char *cont, *what;
d4241 1
a4241 4
sh_parse_name (name, exprP, nextcharP)
     char const *name;
     expressionS *exprP;
     char *nextcharP;
d4318 49
@


1.5
log
@resolve conflicts.
@
text
@d1 2
a2 2
/* tc-sh.c -- Assemble code for the Hitachi Super-H
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d30 1
a30 1
#include <ctype.h>
d39 8
a55 2
void cons ();
void s_align_bytes ();
d59 16
d79 4
d86 10
a95 1
int shl = 0;
d101 4
a104 1
  shl = 1;
d125 1
d140 1
a140 1
  {"file", dwarf2_directive_file, 0 },
d143 12
d166 1
a166 1
/* Whether -dsp was seen.  */
d168 1
a168 1
static int sh_dsp;
d187 2
d192 22
d216 2
d227 18
d275 79
d394 112
d514 33
a546 6
/* Parse @@got, etc. and return the desired relocation.
   If we have additional arithmetic expression, then we fill in new_exp_p.  */
static bfd_reloc_code_real_type
sh_elf_suffix (str_p, exp_p, new_exp_p)
     char **str_p;
     expressionS *exp_p, *new_exp_p;
d548 10
a557 5
  struct map_bfd {
    char *string;
    int length;
    bfd_reloc_code_real_type reloc;
  };
d559 56
a614 6
  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;
  struct map_bfd *ptr;
d616 3
a618 1
#define MAP(str,reloc) { str, sizeof (str)-1, reloc }
d620 4
a623 6
  static struct map_bfd mapping[] = {
    MAP ("got",		BFD_RELOC_32_GOT_PCREL),
    MAP ("plt",		BFD_RELOC_32_PLT_PCREL),
    MAP ("gotoff",	BFD_RELOC_32_GOTOFF),
    { (char *)0,	0,	BFD_RELOC_UNUSED }
  };
d625 16
a640 2
  if (*str++ != '@@')
    return BFD_RELOC_UNUSED;
d642 1
a642 4
  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
	&& (isalnum (ch) || ch == '@@'));
       ch = *++str)
d644 117
a760 1
      *str2++ = (islower (ch)) ? ch : tolower (ch);
d762 8
d771 7
a777 2
  *str2 = '\0';
  len = str2 - ident;
d779 5
a783 5
  ch = ident[0];
  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (ch == ptr->string[0]
	&& len == ptr->length
	&& memcmp (ident, ptr->string, ptr->length) == 0)
d785 7
a791 4
	/* Now check for identifier@@suffix+constant */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;
d793 3
a795 9
	    input_line_pointer = str;
	    expression (new_exp_p);
	    if (new_exp_p->X_op == O_constant)
	      {
		exp_p->X_add_number += new_exp_p->X_add_number;
		str = input_line_pointer;
	      }
	    if (new_exp_p->X_op == O_subtract)
	      str = input_line_pointer;
d797 5
a801 3
	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }
d803 2
a804 2
	*str_p = str;
	return ptr->reloc;
d806 6
d813 1
a813 1
  return BFD_RELOC_UNUSED;
d824 11
a834 3
  expressionS exp, new_exp;
  bfd_reloc_code_real_type reloc;
  const char *name;
d845 1
a845 73
      new_exp.X_op = O_absent;
      new_exp.X_add_symbol = new_exp.X_op_symbol = NULL;
      /* If the _GLOBAL_OFFSET_TABLE_ symbol hasn't been found yet,
	 use the name of the symbol to tell whether it's the
	 _GLOBAL_OFFSET_TABLE_.  If it has, comparing the symbols is
	 sufficient.  */
      if (! GOT_symbol && exp.X_add_symbol)
	name = S_GET_NAME (exp.X_add_symbol);
      else
	name = NULL;
      /* Check whether this expression involves the
	 _GLOBAL_OFFSET_TABLE_ symbol, by itself or added to a
	 difference of two other symbols.  */
      if (((GOT_symbol && GOT_symbol == exp.X_add_symbol)
	   || (! GOT_symbol && name
	       && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0))
	  && (exp.X_op == O_symbol
	      || (exp.X_op == O_add
		  && ((symbol_get_value_expression (exp.X_op_symbol)->X_op)
		      == O_subtract))))
	{
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput,
								 BFD_RELOC_32);
	  int size = bfd_get_reloc_size (reloc_howto);

	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	  if (size > nbytes)
	    as_bad (_("%s relocations do not fit in %d bytes\n"),
		    reloc_howto->name, nbytes);
	  else
	    {
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;

	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset,
			   size, &exp, 0, TC_RELOC_GLOBAL_OFFSET_TABLE);
	    }
	}
      /* Check if this symbol involves one of the magic suffixes, such
	 as @@GOT, @@GOTOFF or @@PLT, and determine which relocation type
	 to use.  */
      else if ((exp.X_op == O_symbol || (exp.X_op == O_add && exp.X_op_symbol))
	  && *input_line_pointer == '@@'
	  && ((reloc = sh_elf_suffix (&input_line_pointer, &exp, &new_exp))
	      != BFD_RELOC_UNUSED))
	{
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput,
								 reloc);
	  int size = bfd_get_reloc_size (reloc_howto);

	  /* Force a GOT to be generated.  */
	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	  if (size > nbytes)
	    as_bad (_("%s relocations do not fit in %d bytes\n"),
		    reloc_howto->name, nbytes);
	  else
	    {
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;

	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	      if (new_exp.X_op != O_absent)
		fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			     &new_exp, 0, BFD_RELOC_32);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
d866 1
a866 1
  sh_opcode_info *opcode;
d870 6
a875 6
#ifdef TE_PE
  /* The WinCE OS only supports little endian executables.  */
  target_big_endian = 0;
#else
  if (! shl)
    target_big_endian = 1;
a877 3
  target_arch = arch_sh1_up & ~(sh_dsp ? arch_sh3e_up : arch_sh_dsp_up);
  valid_arch = target_arch;

d883 1
a883 1
      if (strcmp (prev_name, opcode->name))
a889 6
      else
	{
	  /* Make all the opcodes with the same name point to the same
	     string.  */
	  opcode->name = prev_name;
	}
d899 1
a899 9
typedef struct
  {
    sh_arg_type type;
    int reg;
    expressionS immediate;
  }
sh_operand_info;

#define IDENT_CHAR(c) (isalnum (c) || (c) == '_')
d909 2
a910 2
  char l0 = tolower (src[0]);
  char l1 = l0 ? tolower (src[1]) : 0;
d965 1
a965 1
	  if (tolower (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d980 1
a980 1
	  if (tolower (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d1013 1
a1013 1
  if (l0 == 'i' && l1 && ! IDENT_CHAR ((unsigned char) src[3]))
d1061 1
a1061 1
      && tolower (src[2]) == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
d1067 1
a1067 1
  if (l0 == 's' && l1 == 'p' && tolower (src[2]) == 'c'
d1074 1
a1074 1
  if (l0 == 's' && l1 == 'g' && tolower (src[2]) == 'r'
d1081 1
a1081 1
  if (l0 == 'd' && l1 == 's' && tolower (src[2]) == 'r'
d1088 1
a1088 1
  if (l0 == 'd' && l1 == 'b' && tolower (src[2]) == 'r'
d1120 1
a1120 1
  if (l0 == 'g' && l1 == 'b' && tolower (src[2]) == 'r'
d1126 1
a1126 1
  if (l0 == 'v' && l1 == 'b' && tolower (src[2]) == 'r'
d1133 1
a1133 1
  if (l0 == 'm' && l1 == 'a' && tolower (src[2]) == 'c'
d1136 1
a1136 1
      if (tolower (src[3]) == 'l')
d1141 1
a1141 1
      if (tolower (src[3]) == 'h')
d1147 2
a1148 2
  if (l0 == 'm' && l1 == 'o' && tolower (src[2]) == 'd'
      && ! IDENT_CHAR ((unsigned char) src[4]))
d1229 2
a1230 2
  if (l0 == 'f' && l1 == 'p' && tolower (src[2]) == 'u'
      && tolower (src[3]) == 'l'
d1237 3
a1239 3
  if (l0 == 'f' && l1 == 'p' && tolower (src[2]) == 's'
      && tolower (src[3]) == 'c'
      && tolower (src[4]) == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
d1245 3
a1247 3
  if (l0 == 'x' && l1 == 'm' && tolower (src[2]) == 't'
      && tolower (src[3]) == 'r'
      && tolower (src[4]) == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
a1255 14
static symbolS *
dot ()
{
  const char *fake;

  /* JF: '.' is pseudo symbol with value of current location
     in current segment.  */
  fake = FAKE_LABEL_NAME;
  return  symbol_new (fake,
		      now_seg,
		      (valueT) frag_now_fix (),
		      frag_now);
}

d1269 6
d1322 1
a1322 1
         @@(r0, rn) */
a1332 4
	    src++;
	  /* Now can be rn or gbr */
	  len = parse_reg (src, &mode, &(op->reg));
	  if (mode == A_GBR)
d1334 7
a1340 1
	      op->type = A_R0_GBR;
d1342 1
a1342 1
	  else if (mode == A_REG_N)
d1344 12
a1355 1
	      op->type = A_IND_R0_REG_N;
d1359 1
a1359 1
	      as_bad (_("syntax error in @@(r0,...)"));
d1364 1
a1364 1
	  /* Must be an @@(disp,.. thing) */
d1368 1
a1368 1
	  /* Now can be rn, gbr or pc */
d1382 16
a1397 2
		  /* Turn a plain @@(4,pc) into @@(.+4,pc).  */
		  if (op->immediate.X_op == O_constant)
d1399 9
a1407 2
		      op->immediate.X_add_symbol = dot();
		      op->immediate.X_op = O_symbol;
a1408 1
		  op->type = A_DISP_PC;
d1430 2
a1431 3
	{
	  as_bad (_("illegal register after @@"));
	}
d1434 2
d1437 5
a1441 2
	  if ((src[0] == 'r' && src[1] == '8')
	      || (src[0] == 'i' && (src[1] == 'x' || src[1] == 's')))
d1446 2
a1447 2
	  if ((src[0] == 'r' && src[1] == '9')
	      || (src[0] == 'i' && src[1] == 'y'))
d1456 1
a1456 3
	{
	  op->type = A_IND_N;
	}
d1572 1
a1572 1
      if (this_try->name != name)
d1590 4
a1597 1
	    case A_DISP_PC:
a1845 15
int
check (operand, low, high)
     expressionS *operand;
     int low;
     int high;
{
  if (operand->X_op != O_constant
      || operand->X_add_number < low
      || operand->X_add_number > high)
    {
      as_bad (_("operand must be absolute in range %d..%d"), low, high);
    }
  return operand->X_add_number;
}

a1950 1

d2027 2
a2028 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY4, 1, operand);
d2031 2
a2032 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY2, 1, operand);
d2089 1
a2089 1
	 be capitailzed.  Instead of hacking up the machine independent
d2091 1
a2091 1
      c = isupper (c) ? tolower (c) : c;
a2120 5
  /* Some insn ignore one or more register fields, e.g. psts machl,a0.
     Make sure we encode a defined insn pattern.  */
  reg_x = 0;
  reg_y = 0;

d2125 6
d2258 9
d2342 20
d2475 1
a2475 1
     char *name;
a2476 18
#ifdef OBJ_ELF
  /* Under ELF we need to default _GLOBAL_OFFSET_TABLE.  Otherwise we
     have no need to default values of symbols.  */
  if (strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");

	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT)0, & zero_address_frag);
	}

      return GOT_symbol;
    }
#endif /* OBJ_ELF */

d2485 1
a2485 1
     object_headers *headers;
d2492 1
a2492 1
     object_headers *headers;
d2589 1
a2589 1
CONST char *md_shortopts = "";
d2593 2
a2594 1
#define OPTION_LITTLE (OPTION_MD_BASE + 1)
d2597 1
d2600 1
d2604 14
d2633 4
a2637 1
      shl = 1;
d2646 54
a2699 1
      sh_dsp = 1;
d2702 9
d2725 1
d2728 17
a2744 1
-dsp			enable sh-dsp insns, and disable sh3e / sh4 insns.\n"));
a2746 7
void
tc_Nout_fix_to_chars ()
{
  printf (_("call to tc_Nout_fix_to_chars \n"));
  abort ();
}

d2895 2
a2896 2
      fix_new (symbol_get_frag (sym),
	       S_GET_VALUE (sym) - symbol_get_frag (sym)->fr_address,
d2914 4
d2934 1
a2934 1
   create relocs so that md_apply_fix will fill in the correct values.  */
d2941 1
a2941 1
     object_headers *headers;
d3009 1
a3009 1
	/* If this is a dalayed branch, we may not put the the bra in the
d3071 3
d3075 1
d3216 1
a3216 4
/* This macro decides whether a particular reloc is an entry in a
   switch table.  It is used when relaxing, because the linker needs
   to know about all such entries so that it can adjust them if
   necessary.  */
d3218 13
a3230 19
#ifdef BFD_ASSEMBLER
#define SWITCH_TABLE_CONS(fix) (0)
#else
#define SWITCH_TABLE_CONS(fix)				\
  ((fix)->fx_r_type == 0				\
   && ((fix)->fx_size == 2				\
       || (fix)->fx_size == 1				\
       || (fix)->fx_size == 4))
#endif

#define SWITCH_TABLE(fix)				\
  ((fix)->fx_addsy != NULL				\
   && (fix)->fx_subsy != NULL				\
   && S_GET_SEGMENT ((fix)->fx_addsy) == text_section	\
   && S_GET_SEGMENT ((fix)->fx_subsy) == text_section	\
   && ((fix)->fx_r_type == BFD_RELOC_32			\
       || (fix)->fx_r_type == BFD_RELOC_16		\
       || (fix)->fx_r_type == BFD_RELOC_8		\
       || SWITCH_TABLE_CONS (fix)))
d3240 4
d3245 9
a3253 4
  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fix->fx_r_type == BFD_RELOC_SH_LOOP_START
      || fix->fx_r_type == BFD_RELOC_SH_LOOP_END)
d3265 3
d3272 1
a3272 1
boolean
d3276 3
a3278 15

  if (fixP->fx_addsy == NULL)
    return 1;

  if (fixP->fx_r_type == BFD_RELOC_SH_PCDISP8BY2
      || fixP->fx_r_type == BFD_RELOC_SH_PCDISP12BY2
      || fixP->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY2
      || fixP->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY4
      || fixP->fx_r_type == BFD_RELOC_8_PCREL
      || fixP->fx_r_type == BFD_RELOC_SH_SWITCH16
      || fixP->fx_r_type == BFD_RELOC_SH_SWITCH32)
    return 1;

  if (! TC_RELOC_RTSYM_LOC_FIXUP (fixP)
      || fixP->fx_r_type == BFD_RELOC_32_GOTOFF
d3297 7
d3308 2
a3329 6
#ifdef BFD_ASSEMBLER
int
md_apply_fix (fixP, valp)
     fixS *fixP;
     valueT *valp;
#else
d3331 4
a3334 4
md_apply_fix (fixP, val)
     fixS *fixP;
     long val;
#endif
d3339 1
a3339 3
#ifdef BFD_ASSEMBLER
  long val = *valp;
#endif
d3365 1
a3365 1
	  return false;
d3369 1
a3369 1
	  return false;
d3391 4
a3394 1
#ifndef BFD_ASSEMBLER
a3521 3
#ifdef BFD_ASSEMBLER
      return 0;
#else
a3522 1
#endif
d3528 6
a3533 1
      *valp = 0xfffffffc;
d3553 1
a3553 1
      *valp -= 1;
d3557 5
d3563 2
a3564 1
      *valp = 0; /* Fully resolved at runtime.  No addend.  */
d3568 4
d3573 1
d3578 4
d3583 1
d3599 2
a3600 3
#ifdef BFD_ASSEMBLER
  return 0;
#endif
d3616 3
d3620 2
d3690 5
d3701 3
d3711 20
d3850 1
a3850 1
	 The fx_addnumber field was set in md_apply_fix.  */
d3915 2
a3916 1
      rel->addend = rel->address - S_GET_VALUE (fixp->fx_subsy);
d3943 4
d3955 2
d3970 95
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000 Free Software Foundation.
d22 1
a22 4
/*
   Written By Steve Chamberlain
   sac@@cygnus.com
 */
d31 1
d37 2
d52 7
a58 1
static void assemble_ppi PARAMS ((char *, sh_opcode_info *));
d64 1
a64 1
     int ignore;
d74 1
a74 2
   Integer arg to pass to the function
 */
d78 6
d86 1
d96 8
d125 1
a125 1
/* Chars that mean this number is a floating point constant */
a131 1
#define JREG 14			/* Register used as a temp when relaxing */
d135 1
a135 1
/* These are the three types of relaxable instrction */
a144 2
#define UNCOND12 1
#define UNCOND32 2
d180 2
d183 2
a184 2
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
d186 1
a186 1
  { 0 },
d193 4
a196 2
  { 0 }, { 0 }, { 0 }, { 0 },
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
d198 1
a198 1
  { 0 },
d205 4
a208 2
  { 0 }, { 0 }, { 0 }, { 0 },
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
d210 1
a210 1
  { 0 },
d215 5
a219 2
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },
d222 2
d226 187
a412 4
/*
   This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs
 */
d434 1
a434 1
  /* Insert unique names into hash table */
d447 1
a447 1
	     string */
a458 2
static expressionS immediate;	/* absolute expression */

d463 1
a464 1

d469 2
a470 1
/* try and parse a reg name, returns number of chars consumed */
d477 3
d484 1
a484 1
  if (src[0] == 'r')
d486 1
a486 1
      if (src[1] == '1')
d496 1
a496 1
      if (src[1] >= '0' && src[1] <= '9'
d500 1
a500 1
	  *reg = (src[1] - '0');
d503 1
a503 1
      if (src[1] >= '0' && src[1] <= '7' && strncmp (&src[2], "_bank", 5) == 0
d507 1
a507 1
	  *reg  = (src[1] - '0');
d511 1
a511 1
      if (src[1] == 'e' && ! IDENT_CHAR ((unsigned char) src[2]))
d516 1
a516 1
      if (src[1] == 's' && ! IDENT_CHAR ((unsigned char) src[2]))
d523 1
a523 1
  if (src[0] == 'a')
d525 1
a525 1
      if (src[1] == '0')
d533 1
a533 1
	  if (src[2] == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d540 1
a540 1
      if (src[1] == '1')
d548 1
a548 1
	  if (src[2] == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d556 1
a556 1
      if (src[1] == 'x' && src[2] >= '0' && src[2] <= '1'
d560 1
a560 1
	  *reg = 4 + (src[1] - '0');
d563 1
a563 1
      if (src[1] == 'y' && src[2] >= '0' && src[2] <= '1'
d567 1
a567 1
	  *reg = 6 + (src[1] - '0');
d570 1
a570 1
      if (src[1] == 's' && src[2] >= '0' && src[2] <= '3'
d573 1
a573 1
	  int n = src[1] - '0';
d581 1
a581 1
  if (src[0] == 'i' && src[1] && ! IDENT_CHAR ((unsigned char) src[3]))
d583 1
a583 1
      if (src[1] == 's')
d589 1
a589 1
      if (src[1] == 'x')
d595 1
a595 1
      if (src[1] == 'y')
d603 1
a603 1
  if (src[0] == 'x' && src[1] >= '0' && src[1] <= '1'
d607 1
a607 1
      *reg = A_X0_NUM + src[1] - '0';
d611 1
a611 1
  if (src[0] == 'y' && src[1] >= '0' && src[1] <= '1'
d615 1
a615 1
      *reg = A_Y0_NUM + src[1] - '0';
d619 1
a619 1
  if (src[0] == 'm' && src[1] >= '0' && src[1] <= '1'
d623 1
a623 1
      *reg = src[1] == '0' ? A_M0_NUM : A_M1_NUM;
d627 3
a629 3
  if (src[0] == 's'
      && src[1] == 's'
      && src[2] == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
d635 1
a635 1
  if (src[0] == 's' && src[1] == 'p' && src[2] == 'c'
d642 1
a642 1
  if (src[0] == 's' && src[1] == 'g' && src[2] == 'r'
d649 1
a649 1
  if (src[0] == 'd' && src[1] == 's' && src[2] == 'r'
d656 1
a656 1
  if (src[0] == 'd' && src[1] == 'b' && src[2] == 'r'
d663 1
a663 1
  if (src[0] == 's' && src[1] == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
d669 1
a669 1
  if (src[0] == 's' && src[1] == 'p' && ! IDENT_CHAR ((unsigned char) src[2]))
d676 1
a676 1
  if (src[0] == 'p' && src[1] == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
d681 1
a681 1
  if (src[0] == 'p' && src[1] == 'c' && ! IDENT_CHAR ((unsigned char) src[2]))
d683 3
a685 1
      *mode = A_DISP_PC;
d688 1
a688 1
  if (src[0] == 'g' && src[1] == 'b' && src[2] == 'r'
d694 1
a694 1
  if (src[0] == 'v' && src[1] == 'b' && src[2] == 'r'
d701 1
a701 1
  if (src[0] == 'm' && src[1] == 'a' && src[2] == 'c'
d704 1
a704 1
      if (src[3] == 'l')
d709 1
a709 1
      if (src[3] == 'h')
d715 1
a715 1
  if (src[0] == 'm' && src[1] == 'o' && src[2] == 'd'
d721 1
a721 1
  if (src[0] == 'f' && src[1] == 'r')
d741 1
a741 1
  if (src[0] == 'd' && src[1] == 'r')
d761 1
a761 1
  if (src[0] == 'x' && src[1] == 'd')
d781 1
a781 1
  if (src[0] == 'f' && src[1] == 'v')
d797 2
a798 1
  if (src[0] == 'f' && src[1] == 'p' && src[2] == 'u' && src[3] == 'l'
d805 3
a807 2
  if (src[0] == 'f' && src[1] == 'p' && src[2] == 's' && src[3] == 'c'
      && src[4] == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
d813 3
a815 2
  if (src[0] == 'x' && src[1] == 'm' && src[2] == 't' && src[3] == 'r'
      && src[4] == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
d824 2
a825 1
static symbolS *dot()
a835 1

d838 2
a839 4

static
char *
parse_exp (s)
d841 1
d848 2
a849 2
  expression (&immediate);
  if (immediate.X_op == O_absent)
a855 1

a872 1

d875 1
a875 2
static
char *
d885 1
a885 1
      /* Must be predecrement */
d928 1
a928 1
	  src = parse_exp (src);
d943 1
a943 1
	      else if (mode == A_DISP_PC)
d945 6
a950 5
		  /* Turn a plain @@(4,pc) into @@(.+4,pc) */
		  if (immediate.X_op == O_constant) { 
		    immediate.X_add_symbol = dot();
		    immediate.X_op = O_symbol;
		  }
d1014 1
a1014 1
      *ptr = parse_exp (src);
d1033 2
a1034 2
      /* Not a reg, the only thing left is a displacement */
      *ptr = parse_exp (src);
d1040 1
a1040 2
static
char *
a1044 1

d1063 7
a1069 1
	  if (info->arg[2])
d1099 1
a1099 2
   provided
 */
d1101 1
a1101 2
static
sh_opcode_info *
d1109 1
d1116 1
a1116 1
	     opcodes with the same name */
d1119 2
a1120 1
      /* look at both operands needed by the opcodes and provided by
d1123 1
a1123 2
         first on each opcode try */

d1128 1
d1196 1
a1196 1
            case A_REG_B:
d1367 1
a1367 1
	
d1377 2
a1378 1
    fail:;
a1398 1

d1400 1
a1400 1
insert (where, how, pcrel)
d1404 1
d1409 1
a1409 1
	       &immediate,
d1415 1
a1415 1
build_relax (opcode)
d1417 1
d1429 2
a1430 2
		    immediate.X_add_symbol,
		    immediate.X_add_number,
d1440 2
a1441 2
		    immediate.X_add_symbol,
		    immediate.X_add_number,
d1448 53
a1500 3
/* Now we know what sort of opcodes it is, lets build the bytes -
 */
static void
d1509 1
d1541 1
a1541 1
            case REG_B:
d1544 8
a1551 2
	    case DISP_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0);
d1553 2
a1554 2
	    case IMM_4BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY4, 0);
d1556 2
a1557 2
	    case IMM_4BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY2, 0);
d1559 2
a1560 2
	    case IMM_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0);
d1562 2
a1563 2
	    case IMM_8BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY4, 0);
d1565 2
a1566 2
	    case IMM_8BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY2, 0);
d1568 11
a1578 2
	    case IMM_8:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8, 0);
d1581 1
a1581 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY4, 1);
d1584 6
a1589 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY2, 1);
d1596 11
a1606 8
  if (! target_big_endian) {
    output[1] = (nbuf[0] << 4) | (nbuf[1]);
    output[0] = (nbuf[2] << 4) | (nbuf[3]);
  }
  else {
    output[0] = (nbuf[0] << 4) | (nbuf[1]);
    output[1] = (nbuf[2] << 4) | (nbuf[3]);
  }
d1621 2
a1622 1
  /* Drop leading whitespace */
d1647 1
d1652 1
a1652 3
    {
      as_bad (_("can't find opcode "));
    }
d1659 2
a1660 1
static void
d1671 1
d1687 1
a1687 1
	  /* Couldn't find an opcode which matched the operands */
d1689 1
d1694 1
a1694 1
	  return;
d1696 1
d1760 1
a1760 1
	  if (immediate.X_op != O_constant)
d1763 1
a1763 1
		     | (immediate.X_add_number & 127) << 4
d1839 1
d1853 5
a1857 2
    /* Just a double data transfer.  */
    output = frag_more (2);
d1868 1
d1873 1
a1873 2
   the frags/bytes it assembles to.
 */
d1882 1
d1905 1
a1905 9
      assemble_ppi (op_end, opcode);
      return;
    }

  if (opcode->arg[0] == A_BDISP12
      || opcode->arg[0] == A_BDISP8)
    {
      parse_exp (op_end + 1);
      build_relax (opcode);
d1909 2
a1910 1
      if (opcode->arg[0] == A_END)
d1912 2
a1913 4
	  /* Ignore trailing whitespace.  If there is any, it has already
	     been compressed to a single space.  */
	  if (*op_end == ' ')
	    op_end++;
d1917 18
a1934 3
	  op_end = get_operands (opcode, op_end, operand);
	}
      opcode = get_specific (opcode, operand);
d1936 8
a1943 4
      if (opcode == 0)
	{
	  /* Couldn't find an opcode which matched the operands */
	  char *where = frag_more (2);
d1945 2
a1946 4
	  where[0] = 0x0;
	  where[1] = 0x0;
	  as_bad (_("invalid operands for opcode"));
	  return;
a1947 5

      if (*op_end)
	as_bad (_("excess operands: '%s'"), op_end);

      build_Mytes (opcode, operand);
d1950 3
d1972 1
a1972 1
	{	
d1996 2
a1997 2
DEFUN (md_undefined_symbol, (name),
       char *name)
d1999 18
d2024 2
a2025 2
DEFUN (tc_crawl_symbol_chain, (headers),
       object_headers * headers)
d2031 2
a2032 2
DEFUN (tc_headers_hook, (headers),
       object_headers * headers)
d2040 2
a2041 2
/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
d2044 5
a2048 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
d2097 1
a2097 1
     
d2108 1
a2108 1
     int ignore;
d2130 2
a2131 2
struct option md_longopts[] = {

d2143 1
a2143 1
size_t md_longopts_size = sizeof(md_longopts);
d2148 1
a2148 1
     char *arg;
d2180 1
a2180 1
  fprintf(stream, _("\
a2209 1
/*ARGSUSED*/
d2212 1
a2212 1
     bfd *abfd;
a2238 1
/*ARGSUSED*/
d2241 1
a2241 1
     bfd *abfd;
d2243 1
a2243 1
     PTR ignore;
d2304 2
a2305 2
      /* fscan should also be a fixup to a local symbol in the same
	 section.  */
d2383 1
a2383 1
     bfd *headers;
d2414 2
a2415 2
	as_bad (_("at 0x%lx, displacement overflows 12-bit field"),
		(unsigned long) fragP->fr_address);
d2417 3
a2419 3
	as_bad (_("at 0x%lx, displacement to defined symbol %s overflows 12-bit field"),
		(unsigned long) fragP->fr_address,		
		S_GET_NAME (fragP->fr_symbol));
d2421 5
a2425 40
	as_bad (_("at 0x%lx, displacement to undefined symbol %s overflows 12-bit field"),
		(unsigned long) fragP->fr_address,		
		S_GET_NAME (fragP->fr_symbol));

#if 0				/* This code works, but generates poor code and the compiler
				   should never produce a sequence that requires it to be used.  */

      /* A jump wont fit in 12 bits, make code which looks like
	 bra foo
	 mov.w @@(0, PC), r14
	 .long disp
	 foo: bra @@r14
	 */
      int t = buffer[0] & 0x10;

      buffer[highbyte] = 0xa0;	/* branch over move and disp */
      buffer[lowbyte] = 3;
      buffer[highbyte+2] = 0xd0 | JREG;	/* Build mov insn */
      buffer[lowbyte+2] = 0x00;

      buffer[highbyte+4] = 0;	/* space for 32 bit jump disp */
      buffer[lowbyte+4] = 0;
      buffer[highbyte+6] = 0;
      buffer[lowbyte+6] = 0;

      buffer[highbyte+8] = 0x40 | JREG;	/* Build jmp @@JREG */
      buffer[lowbyte+8] = t ? 0xb : 0x2b;

      buffer[highbyte+10] = 0x20; /* build nop */
      buffer[lowbyte+10] = 0x0b;

      /* Make reloc for the long disp */
      fix_new (fragP,
	       fragP->fr_fix + 4,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       BFD_RELOC_32);
      fragP->fr_fix += UNCOND32_LENGTH;
a2426 3
      donerelax = 1;
#endif

d2431 1
a2431 1
      /* A bcond won't fit, so turn it into a b!cond; bra disp; nop */
d2437 1
a2437 1
   
d2499 2
a2500 2
	as_bad (_("at 0x%lx, displacement overflows 8-bit field"), 
		(unsigned long) fragP->fr_address);
d2502 3
a2504 3
	as_bad (_("at 0x%lx, displacement to defined symbol %s overflows 8-bit field "),
		(unsigned long) fragP->fr_address,		
		S_GET_NAME (fragP->fr_symbol));
d2506 5
a2510 41
	as_bad (_("at 0x%lx, displacement to undefined symbol %s overflows 8-bit field "),
		(unsigned long) fragP->fr_address,		
		S_GET_NAME (fragP->fr_symbol));

#if 0				/* This code works, but generates poor code, and the compiler
				   should never produce a sequence that requires it to be used.  */

      /* A bcond won't fit and it won't go into a 12 bit
	 displacement either, the code sequence looks like:
	 b!cond foop
	 mov.w @@(n, PC), r14
	 jmp  @@r14
	 nop
	 .long where
	 foop:
	 */

      buffer[0] ^= 0x2;		/* Toggle T/F bit */
#define JREG 14
      buffer[1] = 5;		/* branch over mov, jump, nop and ptr */
      buffer[2] = 0xd0 | JREG;	/* Build mov insn */
      buffer[3] = 0x2;
      buffer[4] = 0x40 | JREG;	/* Build jmp @@JREG */
      buffer[5] = 0x0b;
      buffer[6] = 0x20;		/* build nop */
      buffer[7] = 0x0b;
      buffer[8] = 0;		/* space for 32 bit jump disp */
      buffer[9] = 0;
      buffer[10] = 0;
      buffer[11] = 0;
      buffer[12] = 0;
      buffer[13] = 0;
      /* Make reloc for the long disp */
      fix_new (fragP,
	       fragP->fr_fix + 8,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       BFD_RELOC_32);
      fragP->fr_fix += COND32_LENGTH;
a2511 3
      donerelax = 1;
#endif

d2527 3
a2529 3
DEFUN (md_section_align, (seg, size),
       segT seg AND
       valueT size)
d2599 1
a2599 1
  p = frag_var (rs_align_code, 1, 1, (relax_substateT) 0,
d2613 33
d2647 2
a2648 1
      && frag->fr_type == rs_align
a2653 4

  if (frag->fr_type == rs_align_code
      && frag->fr_next->fr_address - frag->fr_address - frag->fr_fix != 0)
    as_warn_where (frag->fr_file, frag->fr_line, _("misaligned data"));
d2691 3
a2693 1
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
d2716 15
a2730 1
  
d2739 2
a2740 1
void sh_elf_final_processing()
d2792 43
a2834 5
  /* adjust_reloc_syms won't convert a reloc against a weak symbol
     into a reloc against a section, but bfd_install_relocation will
     screw up if the symbol is defined, so we have to adjust val here
     to avoid the screw up later.  */
  if (fixP->fx_addsy != NULL
d2893 1
a2893 1
      min = - 0xff;
d2933 1
a2933 1
      if (val < -0x800 || val >= 0x7ff)
d2940 2
a2941 14
      if (! target_big_endian) 
	{
	  *buf++ = val >> 0;
	  *buf++ = val >> 8;
	  *buf++ = val >> 16;
	  *buf++ = val >> 24;
	}
      else 
	{
	  *buf++ = val >> 24;
	  *buf++ = val >> 16;
	  *buf++ = val >> 8;
	  *buf++ = val >> 0;
	}
d2945 1
a2945 10
      if (! target_big_endian)
	{
	  *buf++ = val >> 0;
	  *buf++ = val >> 8;
	} 
      else 
	{
	  *buf++ = val >> 8;
	  *buf++ = val >> 0;
	}
d2961 3
d2973 37
d3040 2
d3044 3
d3048 1
a3048 1
      /* used to be a branch to somewhere which was unknown */
a3051 1
	  fragP->fr_var = md_relax_table[C (UNCOND_JUMP, UNCOND12)].rlx_length;
a3055 1
	  fragP->fr_var = md_relax_table[C (UNCOND_JUMP, UNCOND12)].rlx_length;
a3059 2
	  fragP->fr_var = md_relax_table[C (UNCOND_JUMP, UNCOND32)].rlx_length;
	  return md_relax_table[C (UNCOND_JUMP, UNCOND32)].rlx_length;
a3062 2
    default:
      abort ();
d3065 2
a3066 1
      /* used to be a branch to somewhere which was unknown */
a3069 1
	  int what = GET_WHAT (fragP->fr_subtype);
d3071 1
a3071 1
	     sized - maybe it will fix up */
a3072 1
	  fragP->fr_var = md_relax_table[C (what, COND8)].rlx_length;
d3076 1
a3076 2
	  int what = GET_WHAT (fragP->fr_subtype);
	  /* Its got a segment, but its not ours, so it will always be long */
a3077 2
	  fragP->fr_var = md_relax_table[C (what, COND32)].rlx_length;
	  return md_relax_table[C (what, COND32)].rlx_length;
d3081 1
a3081 2
	  int what = GET_WHAT (fragP->fr_subtype);
	  /* We know the abs value */
a3082 1
	  fragP->fr_var = md_relax_table[C (what, COND8)].rlx_length;
d3084 1
d3086 13
d3101 2
d3106 1
a3106 1
/* Put number into target byte order */
a3137 30
/* When we align the .text section, insert the correct NOP pattern.  */

int
sh_do_align (n, fill, len, max)
     int n;
     const char *fill;
     int len;
     int max;
{
  if (fill == NULL
      && subseg_text_p (now_seg)
      && n > 1)
    {
      static const unsigned char big_nop_pattern[] = { 0x00, 0x09 };
      static const unsigned char little_nop_pattern[] = { 0x09, 0x00 };

      /* First align to a 2 byte boundary, in case there is an odd
         .byte.  */
      frag_align (1, 0, 0);
      if (target_big_endian)
	frag_align_pattern (n, big_nop_pattern, sizeof big_nop_pattern, max);
      else
	frag_align_pattern (n, little_nop_pattern, sizeof little_nop_pattern,
			    max);
      return 1;
    }

  return 0;
}

d3296 1
a3296 1
     asection *section;
d3330 8
d3339 2
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 1996 Free Software Foundation.
d33 5
a46 7
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
 */

d49 3
d63 7
d81 2
d90 12
d115 1
a115 1
/* These are the two types of relaxable instrction */
d117 3
a119 1
#define UNCOND_JUMP  2
a127 1
#define END 5
d144 2
d177 10
d207 1
d209 4
d215 4
d227 2
d243 2
d257 2
d266 1
a266 1
  /* We use !isalnum for the next character after the register name, to
d268 1
a268 1
     'sram' as being a reference to the register 'sr'.  */
d272 19
a290 2
      if (src[1] >= '0' && src[1] <= '7' && strncmp(&src[2], "_bank", 5) == 0
	  && ! isalnum (src[7]))
d296 11
d309 1
a309 1
  if (src[0] == 'r')
d311 15
d328 7
a334 1
	  if (src[2] >= '0' && src[2] <= '5' && ! isalnum (src[3]))
d336 2
a337 2
	      *mode = A_REG_N;
	      *reg = 10 + src[2] - '0';
d341 10
a350 1
      if (src[1] >= '0' && src[1] <= '9' && ! isalnum (src[2]))
d353 32
a384 1
	  *reg = (src[1] - '0');
d389 27
a415 1
  if (src[0] == 's' && src[1] == 's' && src[2] == 'r' && ! isalnum (src[3]))
d421 2
a422 1
  if (src[0] == 's' && src[1] == 'p' && src[2] == 'c' && ! isalnum (src[3]))
d428 22
a449 1
  if (src[0] == 's' && src[1] == 'r' && ! isalnum (src[2]))
d455 1
a455 1
  if (src[0] == 's' && src[1] == 'p' && ! isalnum (src[2]))
d462 1
a462 1
  if (src[0] == 'p' && src[1] == 'r' && ! isalnum (src[2]))
d467 1
a467 1
  if (src[0] == 'p' && src[1] == 'c' && ! isalnum (src[2]))
d472 2
a473 1
  if (src[0] == 'g' && src[1] == 'b' && src[2] == 'r' && ! isalnum (src[3]))
d478 2
a479 1
  if (src[0] == 'v' && src[1] == 'b' && src[2] == 'r' && ! isalnum (src[3]))
d485 2
a486 1
  if (src[0] == 'm' && src[1] == 'a' && src[2] == 'c' && ! isalnum (src[4]))
d499 6
d509 2
a510 1
	  if (src[3] >= '0' && src[3] <= '5' && ! isalnum (src[4]))
d517 2
a518 1
      if (src[2] >= '0' && src[2] <= '9' && ! isalnum (src[3]))
d525 56
d582 1
a582 1
      && ! isalnum (src[4]))
d589 1
a589 1
      && src[4] == 'r' && ! isalnum (src[5]))
d595 7
d632 1
a632 1
    as_bad ("missing operand");
d675 1
a675 1
	as_bad ("illegal register after @@-");
d691 1
a691 1
	      as_bad ("must be @@(r0,...)");
d707 1
a707 1
	      as_bad ("syntax error in @@(r0,...)");
d739 1
a739 1
		  as_bad ("syntax error in @@(disp,[Rn, gbr, pc])");
d744 1
a744 1
	      as_bad ("syntax error in @@(disp,[Rn, gbr, pc])");
d749 1
a749 1
	as_bad ("expecting )");
d758 1
a758 1
	  as_bad ("illegal register after @@");
a761 1
	  op->type = A_INC_N;
d763 14
d835 5
a839 1
      ptr++;
d943 3
d948 3
d956 5
d964 4
d970 2
d988 1
d995 131
d1127 3
d1137 10
d1149 1
a1149 1
	      printf ("unhandled %d\n", arg);
d1153 3
d1173 1
a1173 1
      as_bad ("operand must be absolute in range %d..%d", low, high);
d1202 1
d1204 3
a1206 3
		    md_relax_table[C (COND_JUMP, COND32)].rlx_length,
		    md_relax_table[C (COND_JUMP, COND8)].rlx_length,
		    C (COND_JUMP, 0),
d1260 8
d1299 1
a1299 1
	      printf ("failed for %d\n", i);
d1313 2
a1314 4
/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.
 */
d1316 3
a1318 3
void
md_assemble (str)
     char *str;
d1320 1
a1322 2
  sh_operand_info operand[3];
  sh_opcode_info *opcode;
d1329 4
a1332 1
  /* find the op code end */
d1336 1
a1336 1
       && !is_end_of_line[*op_end] && *op_end != ' ';
d1339 9
a1347 1
      name[nlen] = op_start[nlen];
d1351 1
d1355 1
a1355 1
      as_bad ("can't find opcode ");
d1358 223
a1580 1
  opcode = (sh_opcode_info *) hash_find (opcode_hash_control, name);
d1584 1
a1584 1
      as_bad ("unknown opcode");
d1598 6
d1612 8
a1619 1
      if (opcode->arg[0] != A_END)
d1621 1
a1621 1
	  get_operands (opcode, op_end, operand);
d1632 1
a1632 1
	  as_bad ("invalid operands for opcode");
d1636 3
d1692 1
d1698 1
a1698 1
  printf ("call to tc_crawl_symbol_chain \n");
d1705 1
a1705 1
  printf ("call to tc_headers_hook \n");
d1709 1
d1742 1
a1742 1
      return "bad call to md_atof";
d1783 1
a1783 1
    as_warn (".uses pseudo-op seen when not relaxing");
d1789 1
a1789 1
      as_bad ("bad .uses format");
d1803 3
a1805 1
#define OPTION_LITTLE (OPTION_MD_BASE+1)
d1809 2
d1825 1
d1831 8
d1850 1
a1850 1
  fprintf(stream, "\
d1853 3
a1855 1
-relax			alter jump instructions for long displacements\n");
a1857 2
int md_short_jump_size;

d1861 1
a1861 1
  printf ("call to tc_Nout_fix_to_chars \n");
a1864 21
void
md_create_short_jump (ptr, from_Nddr, to_Nddr, frag, to_symbol)
     char *ptr;
     addressT from_Nddr;
     addressT to_Nddr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}

void
md_create_long_jump (ptr, from_Nddr, to_Nddr, frag, to_symbol)
     char *ptr;
     addressT from_Nddr, to_Nddr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}

d1947 1
a1947 1
			 ".uses does not refer to a local symbol in the same section");
d1966 1
a1966 1
			 "can't find fixup pointed to by .uses");
d1989 1
a1989 1
			 ".uses target does not refer to a local symbol in the same section");
d2015 2
a2016 1
      fix_new (sym->sy_frag, S_GET_VALUE (sym) - sym->sy_frag->fr_address,
d2067 1
d2086 1
a2086 1
	as_bad ("at 0x%lx, displacement overflows 12-bit field",
d2088 4
d2093 1
a2093 1
	as_bad ("at 0x%lx, displacement to %sdefined symbol %s overflows 12-bit field",
a2094 1
		S_IS_DEFINED (fragP->fr_symbol) ? "" : "un",
d2140 1
d2142 11
d2158 1
d2163 7
a2169 1
	/* Build a relocation to six bytes farther on.  */
d2177 1
a2177 1
		 fragP->fr_address + fragP->fr_fix + 6,
d2186 10
a2195 3
	/* Fill in a NOP instruction.  */
	buffer[highbyte + 4] = 0x0;
	buffer[lowbyte + 4] = 0x9;
d2197 2
a2198 1
	fragP->fr_fix += 6;
d2205 1
d2207 1
d2209 1
a2209 1
	as_bad ("at 0x%lx, displacement overflows 8-bit field", 
d2211 6
a2216 2
      else  
	as_bad ("at 0x%lx, displacement to %sdefined symbol %s overflows 8-bit field ",
a2217 1
		S_IS_DEFINED (fragP->fr_symbol) ? "" : "un",
d2268 5
a2272 4
    as_warn ("Offset doesn't fit at 0x%lx, trying to get to %s+0x%lx",
	     (unsigned long) fragP->fr_address,
	     fragP->fr_symbol ? S_GET_NAME(fragP->fr_symbol): "",
	     (unsigned long) fragP->fr_offset);
d2293 61
d2355 2
a2356 1
   that requests alignment to a four byte boundary or larger.  */
d2369 4
d2386 1
d2397 1
d2408 5
d2425 45
d2490 12
d2511 1
a2511 1
	fixP->fx_r_type = BFD_RELOC_SH_IMM8;
d2517 2
d2522 1
d2527 2
d2533 2
d2539 2
d2545 2
d2552 6
d2577 1
a2577 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d2584 1
a2584 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d2591 1
a2591 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d2598 1
a2598 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d2646 9
d2659 13
a2676 2
int md_long_jump_size;

d2710 1
d2715 1
d2718 2
a2719 2
	  fragP->fr_subtype = C (COND_JUMP, COND8);
	  fragP->fr_var = md_relax_table[C (COND_JUMP, COND8)].rlx_length;
d2723 1
d2725 3
a2727 3
	  fragP->fr_subtype = C (COND_JUMP, UNDEF_WORD_DISP);
	  fragP->fr_var = md_relax_table[C (COND_JUMP, COND32)].rlx_length;
	  return md_relax_table[C (COND_JUMP, COND32)].rlx_length;
d2731 1
d2733 2
a2734 2
	  fragP->fr_subtype = C (COND_JUMP, COND8);
	  fragP->fr_var = md_relax_table[C (COND_JUMP, COND8)].rlx_length;
d2777 1
a2777 1
sh_do_align (n, fill, len)
d2781 1
d2783 2
a2784 7
  if ((fill == NULL || (*fill == 0 && len == 1))
#ifdef BFD_ASSEMBLER
      && (now_seg->flags & SEC_CODE) != 0
#else
      && now_seg != data_section
      && now_seg != bss_section
#endif
d2792 1
a2792 1
      frag_align (1, 0);
d2794 1
a2794 1
	frag_align_pattern (n, big_nop_pattern, sizeof big_nop_pattern);
d2796 2
a2797 1
	frag_align_pattern (n, little_nop_pattern, sizeof little_nop_pattern);
d2830 1
d2866 1
a2866 1
		      "Can not represent %s relocation in this object file format",
d2877 2
d2968 3
a2970 4
  rel = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  if (rel == NULL)
    as_fatal ("Out of memory");
  rel->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d2980 2
d2993 3
d3005 1
a3005 1
		    "Cannot represent relocation type %s",
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@a1 1

d39 3
d820 1
a820 1
	      insert (output + low_byte, R_SH_IMM4, 0);
d823 1
a823 1
	      insert (output + low_byte, R_SH_IMM4BY4, 0);
d826 1
a826 1
	      insert (output + low_byte, R_SH_IMM4BY2, 0);
d829 1
a829 1
	      insert (output + low_byte, R_SH_IMM4, 0);
d832 1
a832 1
	      insert (output + low_byte, R_SH_IMM8BY4, 0);
d835 1
a835 1
	      insert (output + low_byte, R_SH_IMM8BY2, 0);
d838 1
a838 1
	      insert (output + low_byte, R_SH_IMM8, 0);
d841 1
a841 1
	      insert (output, R_SH_PCRELIMM8BY4, 1);
d844 1
a844 1
	      insert (output, R_SH_PCRELIMM8BY2, 1);
d910 2
a911 1
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0, R_SH_CODE);
d946 1
a946 1
   emits a R_SH_LABEL reloc if necessary.  */
d963 1
a963 1
	  fix_new (frag_now, offset, 2, &abs_symbol, 0, 0, R_SH_LABEL);
d971 1
a971 1
   data.  It emits a R_SH_DATA reloc if necessary.  */
d979 2
a980 1
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0, R_SH_DATA);
d985 9
a1000 7
symbolS *
DEFUN (md_undefined_symbol, (name),
       char *name)
{
  return 0;
}

d1008 2
d1093 1
a1093 1
  fix_new_exp (frag_now, frag_now_fix (), 2, &ex, 1, R_SH_USES);
d1172 2
a1173 9
/* This is function is called after the symbol table has been
   completed, but before md_convert_frag has been called.  If we have
   seen any .uses pseudo-ops, they point to an instruction which loads
   a register with the address of a function.  We look through the
   fixups to find where the function address is being loaded from.  We
   then generate a COUNT reloc giving the number of times that
   function address is referred to.  The linker uses this information
   when doing relaxing, to decide when it can eliminate the stored
   function address entirely.  */
d1175 1
a1175 2
void
sh_coff_frob_file ()
d1177 21
a1197 1
  int iseg;
d1199 2
a1200 1
  if (! sh_relax)
d1203 2
a1204 1
  for (iseg = SEG_E0; iseg < SEG_UNKNOWN; iseg++)
d1206 7
a1212 1
      fixS *fix;
d1214 57
a1270 1
      for (fix = segment_info[iseg].fix_root; fix != NULL; fix = fix->fx_next)
d1272 4
a1275 22
	  symbolS *sym;
	  bfd_vma val;
	  fixS *fscan;
	  int iscan;
	  int count;

	  if (fix->fx_r_type != R_SH_USES)
	    continue;

	  /* The R_SH_USES reloc should refer to a defined local
             symbol in the same section.  */
	  sym = fix->fx_addsy;
	  if (sym == NULL
	      || fix->fx_subsy != NULL
	      || fix->fx_addnumber != 0
	      || S_GET_SEGMENT (sym) != iseg
	      || S_GET_STORAGE_CLASS (sym) == C_EXT)
	    {
	      as_warn_where (fix->fx_file, fix->fx_line,
			     ".uses does not refer to a local symbol in the same section");
	      continue;
	    }
d1277 5
a1281 18
	  /* Look through the fixups again, this time looking for one
             at the same location as sym.  */
	  val = S_GET_VALUE (sym);
	  for (fscan = segment_info[iseg].fix_root;
	       fscan != NULL;
	       fscan = fscan->fx_next)
	    if (val == fscan->fx_frag->fr_address + fscan->fx_where
		&& fscan->fx_r_type != R_SH_ALIGN
		&& fscan->fx_r_type != R_SH_CODE
		&& fscan->fx_r_type != R_SH_DATA
		&& fscan->fx_r_type != R_SH_LABEL)
	      break;
	  if (fscan == NULL)
	    {
	      as_warn_where (fix->fx_file, fix->fx_line,
			     "can't find fixup pointed to by .uses");
	      continue;
	    }
d1283 16
a1298 5
	  if (fscan->fx_tcbit)
	    {
	      /* We've already done this one.  */
	      continue;
	    }
d1300 9
a1308 13
	  /* fscan should also be a fixup to a local symbol in the same
             section.  */
	  sym = fscan->fx_addsy;
	  if (sym == NULL
	      || fscan->fx_subsy != NULL
	      || fscan->fx_addnumber != 0
	      || S_GET_SEGMENT (sym) != iseg
	      || S_GET_STORAGE_CLASS (sym) == C_EXT)
	    {
	      as_warn_where (fix->fx_file, fix->fx_line,
			     ".uses target does not refer to a local symbol in the same section");
	      continue;
	    }
d1310 4
a1313 16
	  /* Now we look through all the fixups of all the sections,
	     counting the number of times we find a reference to sym.  */
	  count = 0;
	  for (iscan = SEG_E0; iscan < SEG_UNKNOWN; iscan++)
	    {
	      for (fscan = segment_info[iscan].fix_root;
		   fscan != NULL;
		   fscan = fscan->fx_next)
		{
		  if (fscan->fx_addsy == sym)
		    {
		      ++count;
		      fscan->fx_tcbit = 1;
		    }
		}
	    }
d1315 2
a1316 2
	  if (count < 1)
	    abort ();
d1318 6
a1323 7
	  /* Generate a R_SH_COUNT fixup at the location of sym.  We
             have already adjusted the value of sym to include the
             fragment address, so we undo that adjustment here.  */
	  subseg_change (iseg, 0);
	  fix_new (sym->sy_frag, S_GET_VALUE (sym) - sym->sy_frag->fr_address,
		   4, &abs_symbol, count, 0, R_SH_COUNT);
	}
d1327 28
d1360 3
d1364 1
d1375 1
a1375 1
	       1, R_SH_PCDISP8BY2);
d1383 1
a1383 1
	       1, R_SH_PCDISP);
d1433 1
a1433 1
	       R_SH_IMM32);
d1455 5
a1459 1
		 segment_info[seg].dot,
d1461 1
a1461 1
		 1, R_SH_PCDISP8BY2);
d1467 1
a1467 1
		 fragP->fr_offset, 1, R_SH_PCDISP);
d1525 1
a1525 1
	       R_SH_IMM32);
d1549 8
d1559 1
a1559 1

d1575 1
a1575 1
	     R_SH_ALIGN);
d1583 9
d1597 3
a1599 5
   && ((fix)->fx_r_type == R_SH_IMM32			\
       || (fix)->fx_r_type == R_SH_IMM16		\
       || ((fix)->fx_r_type == 0			\
	   && ((fix)->fx_size == 2			\
	       || (fix)->fx_size == 4))))
d1614 5
a1618 5
	  || fix->fx_r_type == R_SH_COUNT
	  || fix->fx_r_type == R_SH_ALIGN
	  || fix->fx_r_type == R_SH_CODE
	  || fix->fx_r_type == R_SH_DATA
	  || fix->fx_r_type == R_SH_LABEL);
d1623 6
d1633 1
d1638 3
d1642 1
d1646 1
a1646 1
	fixP->fx_r_type = R_SH_IMM16;
d1648 1
a1648 1
	fixP->fx_r_type = R_SH_IMM32;
d1650 1
a1650 1
	fixP->fx_r_type = R_SH_IMM8;
d1654 1
d1658 1
a1658 1
    case R_SH_IMM4:
d1662 1
a1662 1
    case R_SH_IMM4BY2:
d1666 1
a1666 1
    case R_SH_IMM4BY4:
d1670 1
a1670 1
    case R_SH_IMM8BY2:
d1674 1
a1674 1
    case R_SH_IMM8BY4:
d1678 2
a1679 1
    case R_SH_IMM8:
d1683 1
a1683 1
    case R_SH_PCRELIMM8BY4:
d1703 1
a1703 1
    case R_SH_PCRELIMM8BY2:
d1710 1
a1710 1
    case R_SH_PCDISP8BY2:
d1717 1
a1717 1
    case R_SH_PCDISP:
d1725 1
a1725 1
    case R_SH_IMM32:
d1742 1
a1742 1
    case R_SH_IMM16:
d1755 1
a1755 1
    case R_SH_USES:
d1760 5
a1764 5
    case R_SH_COUNT:
    case R_SH_ALIGN:
    case R_SH_CODE:
    case R_SH_DATA:
    case R_SH_LABEL:
d1771 4
d1861 2
d1870 2
a1880 1
      && (now_seg == text_section
d1882 4
a1885 1
	  || (now_seg->flags & SEC_CODE) != 0
a1886 1
	  || strcmp (obj_segment_name (now_seg), ".init") == 0)
d1905 1
d1908 34
d1959 10
a1968 1
      intr->r_type = fix->fx_r_type;
d1975 1
a1975 1
      if (fix->fx_r_type == R_SH_IMM16)
d1977 1
a1977 1
      else if (fix->fx_r_type == R_SH_IMM32)
d1994 5
a1998 5
	case R_SH_PCRELIMM8BY2:
	case R_SH_PCRELIMM8BY4:
	case R_SH_PCDISP8BY2:
	case R_SH_PCDISP:
	case R_SH_USES:
d2006 1
a2006 1
  if (fix->fx_r_type == R_SH_USES)
d2013 1
a2013 1
  else if (fix->fx_r_type == R_SH_COUNT)
d2023 1
a2023 1
  else if (fix->fx_r_type == R_SH_ALIGN)
d2030 3
a2032 3
  else if (fix->fx_r_type == R_SH_CODE
	   || fix->fx_r_type == R_SH_DATA
	   || fix->fx_r_type == R_SH_LABEL)
d2051 59
a2109 1
#endif
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright (C) 1993, 1994, 1995 Free Software Foundation.
d195 2
d214 15
d233 1
a233 1
	  if (src[2] >= '0' && src[2] <= '5')
d240 1
a240 1
      if (src[1] >= '0' && src[1] <= '9')
d248 13
a260 1
  if (src[0] == 's' && src[1] == 'r')
d266 1
a266 1
  if (src[0] == 's' && src[1] == 'p')
d273 1
a273 1
  if (src[0] == 'p' && src[1] == 'r')
d278 1
a278 1
  if (src[0] == 'p' && src[1] == 'c')
d283 1
a283 1
  if (src[0] == 'g' && src[1] == 'b' && src[2] == 'r')
d288 1
a288 1
  if (src[0] == 'v' && src[1] == 'b' && src[2] == 'r')
d294 1
a294 1
  if (src[0] == 'm' && src[1] == 'a' && src[2] == 'c')
d307 31
d569 12
d585 1
d592 1
d651 4
d662 3
d673 7
d682 1
d697 8
d814 3
d903 9
d942 39
a1189 1
	  bfd_vma paddr;
a1213 1
	  paddr = segment_info[iseg].scnhdr.s_paddr;
d1217 5
a1221 1
	    if (val == paddr + fscan->fx_frag->fr_address + fscan->fx_where)
a1254 1
	      paddr = segment_info[iscan].scnhdr.s_paddr;
d1399 1
a1399 1
	as_bad ("at %0xlx, displacement overflows 8-bit field", 
d1481 2
a1482 1
      && frag->fr_offset > 1)
d1517 4
a1520 1
	  || fix->fx_r_type == R_SH_ALIGN);
d1588 1
a1588 1
	as_warn_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d1595 1
a1595 1
	as_warn_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d1602 1
a1602 1
	as_warn_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d1609 1
a1609 1
	as_warn_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d1651 3
d1753 32
d1864 7
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d3 1
a3 1
   Copyright (C) 1993, 94, 95, 1996 Free Software Foundation.
a194 2
static int reg_b;

a211 15
  /* We use !isalnum for the next character after the register name, to
     make sure that we won't accidentally recognize a symbol name such as
     'sram' as being a reference to the register 'sr'.  */

  if (src[0] == 'r')
    {
      if (src[1] >= '0' && src[1] <= '7' && strncmp(&src[2], "_bank", 5) == 0
	  && ! isalnum (src[7]))
	{
	  *mode = A_REG_B;
	  *reg  = (src[1] - '0');
	  return 7;
	}
    }

d216 1
a216 1
	  if (src[2] >= '0' && src[2] <= '5' && ! isalnum (src[3]))
d223 1
a223 1
      if (src[1] >= '0' && src[1] <= '9' && ! isalnum (src[2]))
d231 1
a231 13
  if (src[0] == 's' && src[1] == 's' && src[2] == 'r' && ! isalnum (src[3]))
    {
      *mode = A_SSR;
      return 3;
    }

  if (src[0] == 's' && src[1] == 'p' && src[2] == 'c' && ! isalnum (src[3]))
    {
      *mode = A_SPC;
      return 3;
    }

  if (src[0] == 's' && src[1] == 'r' && ! isalnum (src[2]))
d237 1
a237 1
  if (src[0] == 's' && src[1] == 'p' && ! isalnum (src[2]))
d244 1
a244 1
  if (src[0] == 'p' && src[1] == 'r' && ! isalnum (src[2]))
d249 1
a249 1
  if (src[0] == 'p' && src[1] == 'c' && ! isalnum (src[2]))
d254 1
a254 1
  if (src[0] == 'g' && src[1] == 'b' && src[2] == 'r' && ! isalnum (src[3]))
d259 1
a259 1
  if (src[0] == 'v' && src[1] == 'b' && src[2] == 'r' && ! isalnum (src[3]))
d265 1
a265 1
  if (src[0] == 'm' && src[1] == 'a' && src[2] == 'c' && ! isalnum (src[4]))
a277 31
  if (src[0] == 'f' && src[1] == 'r')
    {
      if (src[2] == '1')
	{
	  if (src[3] >= '0' && src[3] <= '5' && ! isalnum (src[4]))
	    {
	      *mode = F_REG_N;
	      *reg = 10 + src[3] - '0';
	      return 4;
	    }
	}
      if (src[2] >= '0' && src[2] <= '9' && ! isalnum (src[3]))
	{
	  *mode = F_REG_N;
	  *reg = (src[2] - '0');
	  return 3;
	}
    }
  if (src[0] == 'f' && src[1] == 'p' && src[2] == 'u' && src[3] == 'l'
      && ! isalnum (src[4]))
    {
      *mode = FPUL_N;
      return 4;
    }

  if (src[0] == 'f' && src[1] == 'p' && src[2] == 's' && src[3] == 'c'
      && src[4] == 'r' && ! isalnum (src[5]))
    {
      *mode = FPSCR_N;
      return 5;
    }
a508 12
	  if (info->arg[2])
	    {
	      if (*ptr == ',')
		{
		  ptr++;
		}
	      get_operand (&ptr, operand + 2);
	    }
	  else
	    {
	      operand[2].type = 0;
	    }
a512 1
	  operand[2].type = 0;
a518 1
      operand[2].type = 0;
a576 4
	    case F_FR0:
	      if (user->type != F_REG_N || user->reg != 0)
		goto fail;
	      break;
a583 3
	    case F_REG_N:
	    case FPUL_N:
	    case FPSCR_N:
a591 7
	    case A_SSR:
	    case A_SPC:
	      if (user->type != arg)
		goto fail;
	      break;

            case A_REG_B:
a593 1
	      reg_b = user->reg;
a607 8
	    case F_REG_M:
	    case FPUL_M:
	    case FPSCR_M:
	      /* Opcode needs rn */
	      if (user->type != arg - F_REG_M + F_REG_N)
		goto fail;
	      reg_m = user->reg;
	      break;
a716 3
            case REG_B:
	      nbuf[index] = reg_b | 0x08;
	      break;
a802 9
  if (sh_relax
      && ! seg_info (now_seg)->tc_segment_info_data.in_code)
    {
      /* Output a CODE reloc to tell the linker that the following
         bytes are instructions, not data.  */
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0, R_SH_CODE);
      seg_info (now_seg)->tc_segment_info_data.in_code = 1;
    }

a832 39
/* This routine is called each time a label definition is seen.  It
   emits a R_SH_LABEL reloc if necessary.  */

void
sh_frob_label ()
{
  static fragS *last_label_frag;
  static int last_label_offset;

  if (sh_relax
      && seg_info (now_seg)->tc_segment_info_data.in_code)
    {
      int offset;

      offset = frag_now_fix ();
      if (frag_now != last_label_frag
	  || offset != last_label_offset)
	{	
	  fix_new (frag_now, offset, 2, &abs_symbol, 0, 0, R_SH_LABEL);
	  last_label_frag = frag_now;
	  last_label_offset = offset;
	}
    }
}

/* This routine is called when the assembler is about to output some
   data.  It emits a R_SH_DATA reloc if necessary.  */

void
sh_flush_pending_output ()
{
  if (sh_relax
      && seg_info (now_seg)->tc_segment_info_data.in_code)
    {
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0, R_SH_DATA);
      seg_info (now_seg)->tc_segment_info_data.in_code = 0;
    }
}

d1042 1
d1067 1
d1071 1
a1071 5
	    if (val == fscan->fx_frag->fr_address + fscan->fx_where
		&& fscan->fx_r_type != R_SH_ALIGN
		&& fscan->fx_r_type != R_SH_CODE
		&& fscan->fx_r_type != R_SH_DATA
		&& fscan->fx_r_type != R_SH_LABEL)
d1105 1
d1250 1
a1250 1
	as_bad ("at 0x%lx, displacement overflows 8-bit field", 
d1332 1
a1332 2
      && frag->fr_offset > 1
      && now_seg != bss_section)
d1367 1
a1367 4
	  || fix->fx_r_type == R_SH_ALIGN
	  || fix->fx_r_type == R_SH_CODE
	  || fix->fx_r_type == R_SH_DATA
	  || fix->fx_r_type == R_SH_LABEL);
d1435 1
a1435 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d1442 1
a1442 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d1449 1
a1449 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
d1456 1
a1456 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far");
a1497 3
    case R_SH_CODE:
    case R_SH_DATA:
    case R_SH_LABEL:
a1596 32
/* When we align the .text section, insert the correct NOP pattern.  */

int
sh_do_align (n, fill, len)
     int n;
     const char *fill;
     int len;
{
  if ((fill == NULL || (*fill == 0 && len == 1))
      && (now_seg == text_section
#ifdef BFD_ASSEMBLER
	  || (now_seg->flags & SEC_CODE) != 0
#endif
	  || strcmp (obj_segment_name (now_seg), ".init") == 0)
      && n > 1)
    {
      static const unsigned char big_nop_pattern[] = { 0x00, 0x09 };
      static const unsigned char little_nop_pattern[] = { 0x09, 0x00 };

      /* First align to a 2 byte boundary, in case there is an odd
         .byte.  */
      frag_align (1, 0);
      if (target_big_endian)
	frag_align_pattern (n, big_nop_pattern, sizeof big_nop_pattern);
      else
	frag_align_pattern (n, little_nop_pattern, sizeof little_nop_pattern);
      return 1;
    }

  return 0;
}

a1675 7
      symbol_ptr = NULL;
    }
  else if (fix->fx_r_type == R_SH_CODE
	   || fix->fx_r_type == R_SH_DATA
	   || fix->fx_r_type == R_SH_LABEL)
    {
      /* These relocs are always absolute.  */
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a39 3
static void sh_count_relocs PARAMS ((bfd *, segT, PTR));
static void sh_frob_section PARAMS ((bfd *, segT, PTR));

d818 1
a818 1
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0);
d821 1
a821 1
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY4, 0);
d824 1
a824 1
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY2, 0);
d827 1
a827 1
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0);
d830 1
a830 1
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY4, 0);
d833 1
a833 1
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY2, 0);
d836 1
a836 1
	      insert (output + low_byte, BFD_RELOC_SH_IMM8, 0);
d839 1
a839 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY4, 1);
d842 1
a842 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY2, 1);
d908 1
a908 2
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0,
	       BFD_RELOC_SH_CODE);
d943 1
a943 1
   emits a BFD_RELOC_SH_LABEL reloc if necessary.  */
d960 1
a960 1
	  fix_new (frag_now, offset, 2, &abs_symbol, 0, 0, BFD_RELOC_SH_LABEL);
d968 1
a968 1
   data.  It emits a BFD_RELOC_SH_DATA reloc if necessary.  */
d976 1
a976 2
      fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0,
	       BFD_RELOC_SH_DATA);
d981 7
a994 9
#ifdef OBJ_COFF

void
DEFUN (tc_crawl_symbol_chain, (headers),
       object_headers * headers)
{
  printf ("call to tc_crawl_symbol_chain \n");
}

a1001 2
#endif

d1085 1
a1085 1
  fix_new_exp (frag_now, frag_now_fix (), 2, &ex, 1, BFD_RELOC_SH_USES);
d1164 9
a1172 2
/* This struct is used to pass arguments to sh_count_relocs through
   bfd_map_over_sections.  */
d1174 2
a1175 1
struct sh_count_relocs
d1177 1
a1177 5
  /* Symbol we are looking for.  */
  symbolS *sym;
  /* Count of relocs found.  */
  int count;
};
d1179 1
a1179 18
/* Count the number of fixups in a section which refer to a particular
   symbol.  When using BFD_ASSEMBLER, this is called via
   bfd_map_over_sections.  */

/*ARGSUSED*/
static void
sh_count_relocs (abfd, sec, data)
     bfd *abfd;
     segT sec;
     PTR data;
{
  struct sh_count_relocs *info = (struct sh_count_relocs *) data;
  segment_info_type *seginfo;
  symbolS *sym;
  fixS *fix;

  seginfo = seg_info (sec);
  if (seginfo == NULL)
d1182 1
a1182 2
  sym = info->sym;
  for (fix = seginfo->fix_root; fix != NULL; fix = fix->fx_next)
d1184 3
a1186 1
      if (fix->fx_addsy == sym)
d1188 22
a1209 5
	  ++info->count;
	  fix->fx_tcbit = 1;
	}
    }
}
d1211 18
a1228 2
/* Handle the count relocs for a particular section.  When using
   BFD_ASSEMBLER, this is called via bfd_map_over_sections.  */
d1230 5
a1234 9
/*ARGSUSED*/
static void
sh_frob_section (abfd, sec, ignore)
     bfd *abfd;
     segT sec;
     PTR ignore;
{
  segment_info_type *seginfo;
  fixS *fix;
d1236 13
a1248 3
  seginfo = seg_info (sec);
  if (seginfo == NULL)
    return;
d1250 16
a1265 45
  for (fix = seginfo->fix_root; fix != NULL; fix = fix->fx_next)
    {
      symbolS *sym;
      bfd_vma val;
      fixS *fscan;
      struct sh_count_relocs info;

      if (fix->fx_r_type != BFD_RELOC_SH_USES)
	continue;

      /* The BFD_RELOC_SH_USES reloc should refer to a defined local
	 symbol in the same section.  */
      sym = fix->fx_addsy;
      if (sym == NULL
	  || fix->fx_subsy != NULL
	  || fix->fx_addnumber != 0
	  || S_GET_SEGMENT (sym) != sec
#if ! defined (BFD_ASSEMBLER) && defined (OBJ_COFF)
	  || S_GET_STORAGE_CLASS (sym) == C_EXT
#endif
	  || S_IS_EXTERNAL (sym))
	{
	  as_warn_where (fix->fx_file, fix->fx_line,
			 ".uses does not refer to a local symbol in the same section");
	  continue;
	}

      /* Look through the fixups again, this time looking for one
	 at the same location as sym.  */
      val = S_GET_VALUE (sym);
      for (fscan = seginfo->fix_root;
	   fscan != NULL;
	   fscan = fscan->fx_next)
	if (val == fscan->fx_frag->fr_address + fscan->fx_where
	    && fscan->fx_r_type != BFD_RELOC_SH_ALIGN
	    && fscan->fx_r_type != BFD_RELOC_SH_CODE
	    && fscan->fx_r_type != BFD_RELOC_SH_DATA
	    && fscan->fx_r_type != BFD_RELOC_SH_LABEL)
	  break;
      if (fscan == NULL)
	{
	  as_warn_where (fix->fx_file, fix->fx_line,
			 "can't find fixup pointed to by .uses");
	  continue;
	}
d1267 2
a1268 5
      if (fscan->fx_tcbit)
	{
	  /* We've already done this one.  */
	  continue;
	}
d1270 6
a1275 15
      /* fscan should also be a fixup to a local symbol in the same
	 section.  */
      sym = fscan->fx_addsy;
      if (sym == NULL
	  || fscan->fx_subsy != NULL
	  || fscan->fx_addnumber != 0
	  || S_GET_SEGMENT (sym) != sec
#if ! defined (BFD_ASSEMBLER) && defined (OBJ_COFF)
	  || S_GET_STORAGE_CLASS (sym) == C_EXT
#endif
	  || S_IS_EXTERNAL (sym))
	{
	  as_warn_where (fix->fx_file, fix->fx_line,
			 ".uses target does not refer to a local symbol in the same section");
	  continue;
a1276 25

      /* Now we look through all the fixups of all the sections,
	 counting the number of times we find a reference to sym.  */
      info.sym = sym;
      info.count = 0;
#ifdef BFD_ASSEMBLER
      bfd_map_over_sections (stdoutput, sh_count_relocs, (PTR) &info);
#else
      {
	int iscan;

	for (iscan = SEG_E0; iscan < SEG_UNKNOWN; iscan++)
	  sh_count_relocs ((bfd *) NULL, iscan, (PTR) &info);
      }
#endif

      if (info.count < 1)
	abort ();

      /* Generate a BFD_RELOC_SH_COUNT fixup at the location of sym.
	 We have already adjusted the value of sym to include the
	 fragment address, so we undo that adjustment here.  */
      subseg_change (sec, 0);
      fix_new (sym->sy_frag, S_GET_VALUE (sym) - sym->sy_frag->fr_address,
	       4, &abs_symbol, info.count, 0, BFD_RELOC_SH_COUNT);
a1279 28
/* This function is called after the symbol table has been completed,
   but before the relocs or section contents have been written out.
   If we have seen any .uses pseudo-ops, they point to an instruction
   which loads a register with the address of a function.  We look
   through the fixups to find where the function address is being
   loaded from.  We then generate a COUNT reloc giving the number of
   times that function address is referred to.  The linker uses this
   information when doing relaxing, to decide when it can eliminate
   the stored function address entirely.  */

void
sh_frob_file ()
{
  if (! sh_relax)
    return;

#ifdef BFD_ASSEMBLER
  bfd_map_over_sections (stdoutput, sh_frob_section, (PTR) NULL);
#else
  {
    int iseg;

    for (iseg = SEG_E0; iseg < SEG_UNKNOWN; iseg++)
      sh_frob_section ((bfd *) NULL, iseg, (PTR) NULL);
  }
#endif
}

a1284 3
#ifdef BFD_ASSEMBLER
     bfd *headers;
#else
a1285 1
#endif
d1296 1
a1296 1
	       1, BFD_RELOC_SH_PCDISP8BY2);
d1304 1
a1304 1
	       1, BFD_RELOC_SH_PCDISP12BY2);
d1354 1
a1354 1
	       BFD_RELOC_32);
d1376 1
a1376 5
#ifdef BFD_ASSEMBLER
		 section_symbol (seg),
#else
		 seg_info (seg)->dot,
#endif
d1378 1
a1378 1
		 1, BFD_RELOC_SH_PCDISP8BY2);
d1384 1
a1384 1
		 fragP->fr_offset, 1, BFD_RELOC_SH_PCDISP12BY2);
d1442 1
a1442 1
	       BFD_RELOC_32);
a1465 8
#ifdef BFD_ASSEMBLER
#ifdef OBJ_ELF
  return size;
#else /* ! OBJ_ELF */
  return ((size + (1 << bfd_get_section_alignment (stdoutput, seg)) - 1)
	  & (-1 << bfd_get_section_alignment (stdoutput, seg)));
#endif /* ! OBJ_ELF */
#else /* ! BFD_ASSEMBLER */
d1468 1
a1468 1
#endif /* ! BFD_ASSEMBLER */
d1484 1
a1484 1
	     BFD_RELOC_SH_ALIGN);
a1491 9
#ifdef BFD_ASSEMBLER
#define SWITCH_TABLE_CONS(fix) (0)
#else
#define SWITCH_TABLE_CONS(fix)				\
  ((fix)->fx_r_type == 0				\
   && ((fix)->fx_size == 2				\
       || (fix)->fx_size == 4))
#endif

d1497 5
a1501 3
   && ((fix)->fx_r_type == BFD_RELOC_32			\
       || (fix)->fx_r_type == BFD_RELOC_16		\
       || SWITCH_TABLE_CONS (fix)))
d1516 5
a1520 5
	  || fix->fx_r_type == BFD_RELOC_SH_COUNT
	  || fix->fx_r_type == BFD_RELOC_SH_ALIGN
	  || fix->fx_r_type == BFD_RELOC_SH_CODE
	  || fix->fx_r_type == BFD_RELOC_SH_DATA
	  || fix->fx_r_type == BFD_RELOC_SH_LABEL);
a1524 6
#ifdef BFD_ASSEMBLER
int
md_apply_fix (fixP, valp)
     fixS *fixP;
     valueT *valp;
#else
a1528 1
#endif
a1532 3
#ifdef BFD_ASSEMBLER
  long val = *valp;
#endif
a1533 1
#ifndef BFD_ASSEMBLER
d1537 1
a1537 1
	fixP->fx_r_type = BFD_RELOC_16;
d1539 1
a1539 1
	fixP->fx_r_type = BFD_RELOC_32;
d1541 1
a1541 1
	fixP->fx_r_type = BFD_RELOC_SH_IMM8;
a1544 1
#endif
d1548 1
a1548 1
    case BFD_RELOC_SH_IMM4:
d1552 1
a1552 1
    case BFD_RELOC_SH_IMM4BY2:
d1556 1
a1556 1
    case BFD_RELOC_SH_IMM4BY4:
d1560 1
a1560 1
    case BFD_RELOC_SH_IMM8BY2:
d1564 1
a1564 1
    case BFD_RELOC_SH_IMM8BY4:
d1568 1
a1568 2
    case BFD_RELOC_8:
    case BFD_RELOC_SH_IMM8:
d1572 1
a1572 1
    case BFD_RELOC_SH_PCRELIMM8BY4:
d1592 1
a1592 1
    case BFD_RELOC_SH_PCRELIMM8BY2:
d1599 1
a1599 1
    case BFD_RELOC_SH_PCDISP8BY2:
d1606 1
a1606 1
    case BFD_RELOC_SH_PCDISP12BY2:
d1614 1
a1614 1
    case BFD_RELOC_32:
d1631 1
a1631 1
    case BFD_RELOC_16:
d1644 1
a1644 1
    case BFD_RELOC_SH_USES:
d1649 5
a1653 5
    case BFD_RELOC_SH_COUNT:
    case BFD_RELOC_SH_ALIGN:
    case BFD_RELOC_SH_CODE:
    case BFD_RELOC_SH_DATA:
    case BFD_RELOC_SH_LABEL:
a1659 4

#ifdef BFD_ASSEMBLER
  return 0;
#endif
a1745 2
#ifdef OBJ_COFF

a1752 2
#endif /* OBJ_COFF */

d1762 1
d1764 1
a1764 4
      && (now_seg->flags & SEC_CODE) != 0
#else
      && now_seg != data_section
      && now_seg != bss_section
d1766 1
a1784 1
#ifndef BFD_ASSEMBLER
a1786 34
/* Map BFD relocs to SH COFF relocs.  */

struct reloc_map
{
  bfd_reloc_code_real_type bfd_reloc;
  int sh_reloc;
};

static const struct reloc_map coff_reloc_map[] =
{
  { BFD_RELOC_32, R_SH_IMM32 },
  { BFD_RELOC_16, R_SH_IMM16 },
  { BFD_RELOC_8, R_SH_IMM8 },
  { BFD_RELOC_SH_PCDISP8BY2, R_SH_PCDISP8BY2 },
  { BFD_RELOC_SH_PCDISP12BY2, R_SH_PCDISP },
  { BFD_RELOC_SH_IMM4, R_SH_IMM4 },
  { BFD_RELOC_SH_IMM4BY2, R_SH_IMM4BY2 },
  { BFD_RELOC_SH_IMM4BY4, R_SH_IMM4BY4 },
  { BFD_RELOC_SH_IMM8, R_SH_IMM8 },
  { BFD_RELOC_SH_IMM8BY2, R_SH_IMM8BY2 },
  { BFD_RELOC_SH_IMM8BY4, R_SH_IMM8BY4 },
  { BFD_RELOC_SH_PCRELIMM8BY2, R_SH_PCRELIMM8BY2 },
  { BFD_RELOC_SH_PCRELIMM8BY4, R_SH_PCRELIMM8BY4 },
  { BFD_RELOC_SH_SWITCH16, R_SH_SWITCH16 },
  { BFD_RELOC_SH_SWITCH32, R_SH_SWITCH32 },
  { BFD_RELOC_SH_USES, R_SH_USES },
  { BFD_RELOC_SH_COUNT, R_SH_COUNT },
  { BFD_RELOC_SH_ALIGN, R_SH_ALIGN },
  { BFD_RELOC_SH_CODE, R_SH_CODE },
  { BFD_RELOC_SH_DATA, R_SH_DATA },
  { BFD_RELOC_SH_LABEL, R_SH_LABEL },
  { BFD_RELOC_UNUSED, 0 }
};

d1804 1
a1804 10
      const struct reloc_map *rm;

      for (rm = coff_reloc_map; rm->bfd_reloc != BFD_RELOC_UNUSED; rm++)
	if (rm->bfd_reloc == (bfd_reloc_code_real_type) fix->fx_r_type)
	  break;
      if (rm->bfd_reloc == BFD_RELOC_UNUSED)
	as_bad_where (fix->fx_file, fix->fx_line,
		      "Can not represent %s relocation in this object file format",
		      bfd_get_reloc_code_name (fix->fx_r_type));
      intr->r_type = rm->sh_reloc;
d1811 1
a1811 1
      if (fix->fx_r_type == BFD_RELOC_16)
d1813 1
a1813 1
      else if (fix->fx_r_type == BFD_RELOC_32)
d1830 5
a1834 5
	case BFD_RELOC_SH_PCRELIMM8BY2:
	case BFD_RELOC_SH_PCRELIMM8BY4:
	case BFD_RELOC_SH_PCDISP8BY2:
	case BFD_RELOC_SH_PCDISP12BY2:
	case BFD_RELOC_SH_USES:
d1842 1
a1842 1
  if (fix->fx_r_type == BFD_RELOC_SH_USES)
d1849 1
a1849 1
  else if (fix->fx_r_type == BFD_RELOC_SH_COUNT)
d1859 1
a1859 1
  else if (fix->fx_r_type == BFD_RELOC_SH_ALIGN)
d1866 3
a1868 3
  else if (fix->fx_r_type == BFD_RELOC_SH_CODE
	   || fix->fx_r_type == BFD_RELOC_SH_DATA
	   || fix->fx_r_type == BFD_RELOC_SH_LABEL)
d1887 1
a1887 59
#endif /* OBJ_COFF */
#endif /* ! BFD_ASSEMBLER */

#ifdef BFD_ASSEMBLER

/* Create a reloc.  */

arelent *
tc_gen_reloc (section, fixp)
     asection *section;
     fixS *fixp;
{
  arelent *rel;
  bfd_reloc_code_real_type r_type;

  rel = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  if (rel == NULL)
    as_fatal ("Out of memory");
  rel->sym_ptr_ptr = &fixp->fx_addsy->bsym;
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;

  r_type = fixp->fx_r_type;

  if (SWITCH_TABLE (fixp))
    {
      rel->addend = rel->address - S_GET_VALUE (fixp->fx_subsy);
      if (r_type == BFD_RELOC_16)
	r_type = BFD_RELOC_SH_SWITCH16;
      else if (r_type == BFD_RELOC_32)
	r_type = BFD_RELOC_SH_SWITCH32;
      else
	abort ();
    }
  else if (r_type == BFD_RELOC_SH_USES)
    rel->addend = fixp->fx_addnumber;
  else if (r_type == BFD_RELOC_SH_COUNT)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_SH_ALIGN)
    rel->addend = fixp->fx_offset;
  else if (fixp->fx_pcrel)
    rel->addend = fixp->fx_addnumber;
  else
    rel->addend = 0;

  rel->howto = bfd_reloc_type_lookup (stdoutput, r_type);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    "Cannot represent relocation type %s",
		    bfd_get_reloc_code_name (r_type));
      /* Set howto to a garbage value so that we can keep going.  */
      rel->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
      assert (rel->howto != NULL);
    }

  return rel;
}

#endif /* BFD_ASSEMBLER */
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 1997 Free Software Foundation.
d1538 4
a1541 5
    as_warn_where (fragP->fr_file, fragP->fr_line,
		   "overflow in branch to %s; converted into longer instruction sequence",
		   (fragP->fr_symbol != NULL
		    ? S_GET_NAME (fragP->fr_symbol)
		    : ""));
d1875 1
a1875 1
sh_do_align (n, fill, len, max)
a1878 1
     int max;
d1880 1
a1880 1
  if (fill == NULL
d1894 1
a1894 1
      frag_align (1, 0, 0);
d1896 1
a1896 1
	frag_align_pattern (n, big_nop_pattern, sizeof big_nop_pattern, max);
d1898 1
a1898 2
	frag_align_pattern (n, little_nop_pattern, sizeof little_nop_pattern,
			    max);
d2066 3
a2068 1
  rel = (arelent *) xmalloc (sizeof (arelent));
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000 Free Software Foundation.
a32 5

#ifdef OBJ_ELF
#include "elf/sh.h"
#endif

d42 7
a50 3
static void s_uacons PARAMS ((int));
static sh_opcode_info *find_cooked_opcode PARAMS ((char **));
static void assemble_ppi PARAMS ((char *, sh_opcode_info *));
a61 7
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
 */

a72 2
  {"uaword", s_uacons, 2},
  {"ualong", s_uacons, 4},
a79 12
/* Whether -small was seen.  */

int sh_small;

/* Whether -dsp was seen.  */

static int sh_dsp;

/* The bit mask of architectures that could
   accomodate the insns seen so far.  */
static int valid_arch;

d93 1
a93 1
/* These are the three types of relaxable instrction */
d95 1
a95 3
#define COND_JUMP_DELAY 2
#define UNCOND_JUMP  3
#define END 4
d104 1
a120 2
#define COND12_DELAY_LENGTH 4

a151 10
  /* C (COND_JUMP_DELAY, COND8) */
  { COND8_F, COND8_M, COND8_LENGTH, C (COND_JUMP_DELAY, COND12) },
  /* C (COND_JUMP_DELAY, COND12) */
  { COND12_F, COND12_M, COND12_DELAY_LENGTH, C (COND_JUMP_DELAY, COND32), },
  /* C (COND_JUMP_DELAY, COND32) */
  { COND32_F, COND32_M, COND32_LENGTH, 0, },
  { 0 }, { 0 }, { 0 }, { 0 },
  { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },

  { 0 },
a171 1
  int target_arch;
a172 4
#ifdef TE_PE
  /* The WinCE OS only supports little endian executables.  */
  target_big_endian = 0;
#else
a174 4
#endif

  target_arch = arch_sh1_up & ~(sh_dsp ? arch_sh3e_up : arch_sh_dsp_up);
  valid_arch = target_arch;
a182 2
	  if (! (opcode->arch & target_arch))
	    continue;
a196 2
static int reg_x, reg_y;
static int reg_efg;
a208 2
#define IDENT_CHAR(c) (isalnum (c) || (c) == '_')

d216 1
a216 1
  /* We use ! IDENT_CHAR for the next character after the register name, to
d218 1
a218 1
     'sram' or sr_ram as being a reference to the register 'sr'.  */
d222 2
a223 19
      if (src[1] == '1')
	{
	  if (src[2] >= '0' && src[2] <= '5'
	      && ! IDENT_CHAR ((unsigned char) src[3]))
	    {
	      *mode = A_REG_N;
	      *reg = 10 + src[2] - '0';
	      return 3;
	    }
	}
      if (src[1] >= '0' && src[1] <= '9'
	  && ! IDENT_CHAR ((unsigned char) src[2]))
	{
	  *mode = A_REG_N;
	  *reg = (src[1] - '0');
	  return 2;
	}
      if (src[1] >= '0' && src[1] <= '7' && strncmp (&src[2], "_bank", 5) == 0
	  && ! IDENT_CHAR ((unsigned char) src[7]))
a228 11

      if (src[1] == 'e' && ! IDENT_CHAR ((unsigned char) src[2]))
	{
	  *mode = A_RE;
	  return 2;
	}
      if (src[1] == 's' && ! IDENT_CHAR ((unsigned char) src[2]))
	{
	  *mode = A_RS;
	  return 2;
	}
d231 1
a231 1
  if (src[0] == 'a')
a232 15
      if (src[1] == '0')
	{
	  if (! IDENT_CHAR ((unsigned char) src[2]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A0_NUM;
	      return 2;
	    }
	  if (src[2] == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A0G_NUM;
	      return 3;
	    }
	}
d235 1
a235 1
	  if (! IDENT_CHAR ((unsigned char) src[2]))
d237 2
a238 8
	      *mode = DSP_REG_N;
	      *reg = A_A1_NUM;
	      return 2;
	    }
	  if (src[2] == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
	    {
	      *mode = DSP_REG_N;
	      *reg = A_A1G_NUM;
d242 1
a242 3

      if (src[1] == 'x' && src[2] >= '0' && src[2] <= '1'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
d245 1
a245 27
	  *reg = 4 + (src[1] - '0');
	  return 3;
	}
      if (src[1] == 'y' && src[2] >= '0' && src[2] <= '1'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = A_REG_N;
	  *reg = 6 + (src[1] - '0');
	  return 3;
	}
      if (src[1] == 's' && src[2] >= '0' && src[2] <= '3'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  int n = src[1] - '0';

	  *mode = A_REG_N;
	  *reg = n | ((~n & 2) << 1);
	  return 3;
	}
    }

  if (src[0] == 'i' && src[1] && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      if (src[1] == 's')
	{
	  *mode = A_REG_N;
	  *reg = 8;
a247 20
      if (src[1] == 'x')
	{
	  *mode = A_REG_N;
	  *reg = 8;
	  return 2;
	}
      if (src[1] == 'y')
	{
	  *mode = A_REG_N;
	  *reg = 9;
	  return 2;
	}
    }

  if (src[0] == 'x' && src[1] >= '0' && src[1] <= '1'
      && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = DSP_REG_N;
      *reg = A_X0_NUM + src[1] - '0';
      return 2;
d250 1
a250 19
  if (src[0] == 'y' && src[1] >= '0' && src[1] <= '1'
      && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = DSP_REG_N;
      *reg = A_Y0_NUM + src[1] - '0';
      return 2;
    }

  if (src[0] == 'm' && src[1] >= '0' && src[1] <= '1'
      && ! IDENT_CHAR ((unsigned char) src[2]))
    {
      *mode = DSP_REG_N;
      *reg = src[1] == '0' ? A_M0_NUM : A_M1_NUM;
      return 2;
    }

  if (src[0] == 's'
      && src[1] == 's'
      && src[2] == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
d256 1
a256 2
  if (src[0] == 's' && src[1] == 'p' && src[2] == 'c'
      && ! IDENT_CHAR ((unsigned char) src[3]))
d262 1
a262 22
  if (src[0] == 's' && src[1] == 'g' && src[2] == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_SGR;
      return 3;
    }

  if (src[0] == 'd' && src[1] == 's' && src[2] == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_DSR;
      return 3;
    }

  if (src[0] == 'd' && src[1] == 'b' && src[2] == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
    {
      *mode = A_DBR;
      return 3;
    }

  if (src[0] == 's' && src[1] == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
d268 1
a268 1
  if (src[0] == 's' && src[1] == 'p' && ! IDENT_CHAR ((unsigned char) src[2]))
d275 1
a275 1
  if (src[0] == 'p' && src[1] == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
d280 1
a280 1
  if (src[0] == 'p' && src[1] == 'c' && ! IDENT_CHAR ((unsigned char) src[2]))
d285 1
a285 2
  if (src[0] == 'g' && src[1] == 'b' && src[2] == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
d290 1
a290 2
  if (src[0] == 'v' && src[1] == 'b' && src[2] == 'r'
      && ! IDENT_CHAR ((unsigned char) src[3]))
d296 1
a296 2
  if (src[0] == 'm' && src[1] == 'a' && src[2] == 'c'
      && ! IDENT_CHAR ((unsigned char) src[4]))
a308 6
  if (src[0] == 'm' && src[1] == 'o' && src[2] == 'd'
      && ! IDENT_CHAR ((unsigned char) src[4]))
    {
      *mode = A_MOD;
      return 3;
    }
d313 1
a313 2
	  if (src[3] >= '0' && src[3] <= '5'
	      && ! IDENT_CHAR ((unsigned char) src[4]))
d320 1
a320 2
      if (src[2] >= '0' && src[2] <= '9'
	  && ! IDENT_CHAR ((unsigned char) src[3]))
a326 56
  if (src[0] == 'd' && src[1] == 'r')
    {
      if (src[2] == '1')
	{
	  if (src[3] >= '0' && src[3] <= '4' && ! ((src[3] - '0') & 1)
	      && ! IDENT_CHAR ((unsigned char) src[4]))
	    {
	      *mode = D_REG_N;
	      *reg = 10 + src[3] - '0';
	      return 4;
	    }
	}
      if (src[2] >= '0' && src[2] <= '8' && ! ((src[2] - '0') & 1)
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = D_REG_N;
	  *reg = (src[2] - '0');
	  return 3;
	}
    }
  if (src[0] == 'x' && src[1] == 'd')
    {
      if (src[2] == '1')
	{
	  if (src[3] >= '0' && src[3] <= '4' && ! ((src[3] - '0') & 1)
	      && ! IDENT_CHAR ((unsigned char) src[4]))
	    {
	      *mode = X_REG_N;
	      *reg = 11 + src[3] - '0';
	      return 4;
	    }
	}
      if (src[2] >= '0' && src[2] <= '8' && ! ((src[2] - '0') & 1)
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = X_REG_N;
	  *reg = (src[2] - '0') + 1;
	  return 3;
	}
    }
  if (src[0] == 'f' && src[1] == 'v')
    {
      if (src[2] == '1'&& src[3] == '2' && ! IDENT_CHAR ((unsigned char) src[4]))
	{
	  *mode = V_REG_N;
	  *reg = 12;
	  return 4;
	}
      if ((src[2] == '0' || src[2] == '4' || src[2] == '8')
	  && ! IDENT_CHAR ((unsigned char) src[3]))
	{
	  *mode = V_REG_N;
	  *reg = (src[2] - '0');
	  return 3;
	}
    }
d328 1
a328 1
      && ! IDENT_CHAR ((unsigned char) src[4]))
d335 1
a335 1
      && src[4] == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
a340 7
  if (src[0] == 'x' && src[1] == 'm' && src[2] == 't' && src[3] == 'r'
      && src[4] == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
    {
      *mode = XMTRX_M4;
      return 5;
    }

d371 1
a371 1
    as_bad (_("missing operand"));
d414 1
a414 1
	as_bad (_("illegal register after @@-"));
d430 1
a430 1
	      as_bad (_("must be @@(r0,...)"));
d446 1
a446 1
	      as_bad (_("syntax error in @@(r0,...)"));
d478 1
a478 1
		  as_bad (_("syntax error in @@(disp,[Rn, gbr, pc])"));
d483 1
a483 1
	      as_bad (_("syntax error in @@(disp,[Rn, gbr, pc])"));
d488 1
a488 1
	as_bad (_("expecting )"));
d497 1
a497 1
	  as_bad (_("illegal register after @@"));
d501 1
a502 14
	  if ((src[0] == 'r' && src[1] == '8')
	      || (src[0] == 'i' && (src[1] == 'x' || src[1] == 's')))
	    {
	      src += 2;
	      op->type = A_PMOD_N;
	    }
	  if ((src[0] == 'r' && src[1] == '9')
	      || (src[0] == 'i' && src[1] == 'y'))
	    {
	      src += 2;
	      op->type = A_PMODY_N;
	    }
	  else
	    op->type = A_INC_N;
d561 1
a561 5
      /* The pre-processor will eliminate whitespace in front of '@@'
	 after the first argument; we may be called multiple times
	 from assemble_ppi, so don't insist on finding whitespace here.  */
      if (*ptr == ' ')
	ptr++;
a664 3
	    case D_REG_N:
	    case X_REG_N:
	    case V_REG_N:
a666 3
	    case A_PMOD_N:
	    case A_PMODY_N:
	    case DSP_REG_N:
a671 5
	    case DX_REG_N:
	      if (user->type != D_REG_N && user->type != X_REG_N)
		goto fail;
	      reg_n = user->reg;
	      break;
a674 4
	    case A_DSR:
	    case A_MOD:
	    case A_RE:
	    case A_RS:
a676 2
	    case A_SGR:
	    case A_DBR:
a692 1
	    case DSP_REG_M:
a698 131
	    case DSP_REG_X:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_X0_NUM:
		  reg_x = 0;
		  break;
		case A_X1_NUM:
		  reg_x = 1;
		  break;
		case A_A0_NUM:
		  reg_x = 2;
		  break;
		case A_A1_NUM:
		  reg_x = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_Y:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_Y0_NUM:
		  reg_y = 0;
		  break;
		case A_Y1_NUM:
		  reg_y = 1;
		  break;
		case A_M0_NUM:
		  reg_y = 2;
		  break;
		case A_M1_NUM:
		  reg_y = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_E:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_X0_NUM:
		  reg_efg = 0 << 10;
		  break;
		case A_X1_NUM:
		  reg_efg = 1 << 10;
		  break;
		case A_Y0_NUM:
		  reg_efg = 2 << 10;
		  break;
		case A_A1_NUM:
		  reg_efg = 3 << 10;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_F:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_Y0_NUM:
		  reg_efg |= 0 << 8;
		  break;
		case A_Y1_NUM:
		  reg_efg |= 1 << 8;
		  break;
		case A_X0_NUM:
		  reg_efg |= 2 << 8;
		  break;
		case A_A1_NUM:
		  reg_efg |= 3 << 8;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_G:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_M0_NUM:
		  reg_efg |= 0 << 2;
		  break;
		case A_M1_NUM:
		  reg_efg |= 1 << 2;
		  break;
		case A_A0_NUM:
		  reg_efg |= 2 << 2;
		  break;
		case A_A1_NUM:
		  reg_efg |= 3 << 2;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case A_A0:
	      if (user->type != DSP_REG_N || user->reg != A_A0_NUM)
		goto fail;
	      break;
	    case A_X0:
	      if (user->type != DSP_REG_N || user->reg != A_X0_NUM)
		goto fail;
	      break;
	    case A_X1:
	      if (user->type != DSP_REG_N || user->reg != A_X1_NUM)
		goto fail;
	      break;
	    case A_Y0:
	      if (user->type != DSP_REG_N || user->reg != A_Y0_NUM)
		goto fail;
	      break;
	    case A_Y1:
	      if (user->type != DSP_REG_N || user->reg != A_Y1_NUM)
		goto fail;
	      break;

a699 3
	    case D_REG_M:
	    case X_REG_M:
	    case V_REG_M:
a706 10
	    case DX_REG_M:
	      if (user->type != D_REG_N && user->type != X_REG_N)
		goto fail;
	      reg_m = user->reg;
	      break;
	    case XMTRX_M4:
	      if (user->type != XMTRX_M4)
		goto fail;
	      reg_m = 4;
	      break;
d709 1
a709 1
	      printf (_("unhandled %d\n"), arg);
a712 3
      if ( !(valid_arch & this_try->arch))
	goto fail;
      valid_arch &= this_try->arch;
d730 1
a730 1
      as_bad (_("operand must be absolute in range %d..%d"), low, high);
a758 1
      int what = (opcode->nibbles[1] & 4) ? COND_JUMP_DELAY : COND_JUMP;
d760 3
a762 3
		    md_relax_table[C (what, COND32)].rlx_length,
		    md_relax_table[C (what, COND8)].rlx_length,
		    C (what, 0),
a815 8
	    case SDT_REG_N:
	      if (reg_n < 2 || reg_n > 5)
		as_bad (_("Invalid register: 'r%d'"), reg_n);
	      nbuf[index] = (reg_n & 3) | 4;
	      break;
	    case REG_NM:
	      nbuf[index] = reg_n | (reg_m >> 2);
	      break;
d847 1
a847 1
	      printf (_("failed for %d\n"), i);
d861 4
a864 2
/* Find an opcode at the start of *STR_P in the hash table, and set
   *STR_P to the first character after the last one read.  */
d866 3
a868 3
static sh_opcode_info *
find_cooked_opcode (str_p)
     char **str_p;
a869 1
  char *str = *str_p;
d872 2
d880 1
a880 4
  /* Find the op code end.
     The pre-processor will eliminate whitespace in front of
     any '@@' after the first argument; we may be called from
     assemble_ppi, so the opcode might be terminated by an '@@'.  */
d884 1
a884 1
       && !is_end_of_line[*op_end] && *op_end != ' ' && *op_end != '@@';
d887 1
a887 9
      unsigned char c = op_start[nlen];

      /* The machine independent code will convert CMP/EQ into cmp/EQ
	 because it thinks the '/' is the end of the symbol.  Moreover,
	 all but the first sub-insn is a parallel processing insn won't
	 be capitailzed.  Instead of hacking up the machine independent
	 code, we just deal with it here.  */
      c = isupper (c) ? tolower (c) : c;
      name[nlen] = c;
a890 1
  *str_p = op_end;
d894 1
a894 1
      as_bad (_("can't find opcode "));
d897 1
a897 223
  return (sh_opcode_info *) hash_find (opcode_hash_control, name);
}

/* Assemble a parallel processing insn.  */
#define DDT_BASE 0xf000 /* Base value for double data transfer insns */
static void
assemble_ppi (op_end, opcode)
     char *op_end;
     sh_opcode_info *opcode;
{
  int movx = 0;
  int movy = 0;
  int cond = 0;
  int field_b = 0;
  char *output;
  int move_code;

  /* Some insn ignore one or more register fields, e.g. psts machl,a0.
     Make sure we encode a defined insn pattern.  */
  reg_x = 0;
  reg_y = 0;

  for (;;)
    {
      sh_operand_info operand[3];

      if (opcode->arg[0] != A_END)
	op_end = get_operands (opcode, op_end, operand);
      opcode = get_specific (opcode, operand);
      if (opcode == 0)
	{
	  /* Couldn't find an opcode which matched the operands */
	  char *where = frag_more (2);

	  where[0] = 0x0;
	  where[1] = 0x0;
	  as_bad (_("invalid operands for opcode"));
	  return;
	}
      if (opcode->nibbles[0] != PPI)
	as_bad (_("insn can't be combined with parallel processing insn"));

      switch (opcode->nibbles[1])
	{

	case NOPX:
	  if (movx)
	    as_bad (_("multiple movx specifications"));
	  movx = DDT_BASE;
	  break;
	case NOPY:
	  if (movy)
	    as_bad (_("multiple movy specifications"));
	  movy = DDT_BASE;
	  break;

	case MOVX:
	  if (movx)
	    as_bad (_("multiple movx specifications"));
	  if (reg_n < 4 || reg_n > 5)
	    as_bad (_("invalid movx address register"));
	  if (opcode->nibbles[2] & 8)
	    {
	      if (reg_m == A_A1_NUM)
		movx = 1 << 7;
	      else if (reg_m != A_A0_NUM)
		as_bad (_("invalid movx dsp register"));
	    }
	  else
	    {
	      if (reg_x > 1)
		as_bad (_("invalid movx dsp register"));
	      movx = reg_x << 7;
	    }
	  movx += ((reg_n - 4) << 9) + (opcode->nibbles[2] << 2) + DDT_BASE;
	  break;

	case MOVY:
	  if (movy)
	    as_bad (_("multiple movy specifications"));
	  if (opcode->nibbles[2] & 8)
	    {
	      /* Bit 3 in nibbles[2] is intended for bit 4 of the opcode,
		 so add 8 more.  */
	      movy = 8;
	      if (reg_m == A_A1_NUM)
		movy += 1 << 6;
	      else if (reg_m != A_A0_NUM)
		as_bad (_("invalid movy dsp register"));
	    }
	  else
	    {
	      if (reg_y > 1)
		as_bad (_("invalid movy dsp register"));
	      movy = reg_y << 6;
	    }
	  if (reg_n < 6 || reg_n > 7)
	    as_bad (_("invalid movy address register"));
	  movy += ((reg_n - 6) << 8) + opcode->nibbles[2] + DDT_BASE;
	  break;

	case PSH:
	  if (immediate.X_op != O_constant)
	    as_bad (_("dsp immediate shift value not constant"));
	  field_b = ((opcode->nibbles[2] << 12)
		     | (immediate.X_add_number & 127) << 4
		     | reg_n);
	  break;
	case PPI3:
	  if (field_b)
	    as_bad (_("multiple parallel processing specifications"));
	  field_b = ((opcode->nibbles[2] << 12) + (opcode->nibbles[3] << 8)
		     + (reg_x << 6) + (reg_y << 4) + reg_n);
	  break;
	case PDC:
	  if (cond)
	    as_bad (_("multiple condition specifications"));
	  cond = opcode->nibbles[2] << 8;
	  if (*op_end)
	    goto skip_cond_check;
	  break;
	case PPIC:
	  if (field_b)
	    as_bad (_("multiple parallel processing specifications"));
	  field_b = ((opcode->nibbles[2] << 12) + (opcode->nibbles[3] << 8)
		     + cond + (reg_x << 6) + (reg_y << 4) + reg_n);
	  cond = 0;
	  break;
	case PMUL:
	  if (field_b)
	    {
	      if ((field_b & 0xef00) != 0xa100)
		as_bad (_("insn cannot be combined with pmuls"));
	      field_b -= 0x8100;
	      switch (field_b & 0xf)
		{
		case A_X0_NUM:
		  field_b += 0 - A_X0_NUM;
		  break;
		case A_Y0_NUM:
		  field_b += 1 - A_Y0_NUM;
		  break;
		case A_A0_NUM:
		  field_b += 2 - A_A0_NUM;
		  break;
		case A_A1_NUM:
		  field_b += 3 - A_A1_NUM;
		  break;
		default:
		  as_bad (_("bad padd / psub pmuls output operand"));
		}
	    }
	  field_b += 0x4000 + reg_efg;
	  break;
	default:
	  abort ();
	}
      if (cond)
	{
	  as_bad (_("condition not followed by conditionalizable insn"));
	  cond = 0;
	}
      if (! *op_end)
	break;
    skip_cond_check:
      opcode = find_cooked_opcode (&op_end);
      if (opcode == NULL)
	{
	  (as_bad
	   (_("unrecognized characters at end of parallel processing insn")));
	  break;
	}
    }

  move_code = movx | movy;
  if (field_b)
    {
      /* Parallel processing insn.  */
      unsigned long ppi_code = (movx | movy | 0xf800) << 16 | field_b;

      output = frag_more (4);
      if (! target_big_endian)
	{
	  output[3] = ppi_code >> 8;
	  output[2] = ppi_code;
	}
      else
	{
	  output[2] = ppi_code >> 8;
	  output[3] = ppi_code;
	}
      move_code |= 0xf800;
    }
  else
    /* Just a double data transfer.  */
    output = frag_more (2);
  if (! target_big_endian)
    {
      output[1] = move_code >> 8;
      output[0] = move_code;
    }
  else
    {
      output[0] = move_code >> 8;
      output[1] = move_code;
    }
}

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.
 */

void
md_assemble (str)
     char *str;
{
  unsigned char *op_end;
  sh_operand_info operand[3];
  sh_opcode_info *opcode;

  opcode = find_cooked_opcode (&str);
  op_end = str;
d901 1
a901 1
      as_bad (_("unknown opcode"));
a914 6
  if (opcode->nibbles[0] == PPI)
    {
      assemble_ppi (op_end, opcode);
      return;
    }

d923 1
a923 1
      if (opcode->arg[0] == A_END)
d925 1
a925 8
	  /* Ignore trailing whitespace.  If there is any, it has already
	     been compressed to a single space.  */
	  if (*op_end == ' ')
	    op_end++;
	}
      else
	{
	  op_end = get_operands (opcode, op_end, operand);
d936 1
a936 1
	  as_bad (_("invalid operands for opcode"));
a939 3
      if (*op_end)
	as_bad (_("excess operands: '%s'"), op_end);

a992 1
#ifndef BFD_ASSEMBLER
d998 1
a998 1
  printf (_("call to tc_crawl_symbol_chain \n"));
d1005 1
a1005 1
  printf (_("call to tc_headers_hook \n"));
a1008 1
#endif
d1041 1
a1041 1
      return _("bad call to md_atof");
d1082 1
a1082 1
    as_warn (_(".uses pseudo-op seen when not relaxing"));
d1088 1
a1088 1
      as_bad (_("bad .uses format"));
d1102 1
a1102 3
#define OPTION_LITTLE (OPTION_MD_BASE + 1)
#define OPTION_SMALL (OPTION_LITTLE + 1)
#define OPTION_DSP (OPTION_SMALL + 1)
a1105 2
  {"small", no_argument, NULL, OPTION_SMALL},
  {"dsp", no_argument, NULL, OPTION_DSP},
a1119 1

a1124 8
    case OPTION_SMALL:
      sh_small = 1;
      break;

    case OPTION_DSP:
      sh_dsp = 1;
      break;

d1136 1
a1136 1
  fprintf(stream, _("\
d1139 1
a1139 3
-relax			alter jump instructions for long displacements\n\
-small			align sections to 4 byte boundaries, not 16\n\
-dsp			enable sh-dsp insns, and disable sh3e / sh4 insns.\n"));
d1142 2
d1147 1
a1147 1
  printf (_("call to tc_Nout_fix_to_chars \n"));
d1151 21
d1254 1
a1254 1
			 _(".uses does not refer to a local symbol in the same section"));
d1273 1
a1273 1
			 _("can't find fixup pointed to by .uses"));
d1296 1
a1296 1
			 _(".uses target does not refer to a local symbol in the same section"));
d1322 1
a1322 2
      fix_new (symbol_get_frag (sym),
	       S_GET_VALUE (sym) - symbol_get_frag (sym)->fr_address,
a1372 1
    case C (COND_JUMP_DELAY, COND8):
d1391 1
a1391 1
	as_bad (_("at 0x%lx, displacement overflows 12-bit field"),
a1392 4
      else if (S_IS_DEFINED (fragP->fr_symbol))
	as_bad (_("at 0x%lx, displacement to defined symbol %s overflows 12-bit field"),
		(unsigned long) fragP->fr_address,		
		S_GET_NAME (fragP->fr_symbol));
d1394 1
a1394 1
	as_bad (_("at 0x%lx, displacement to undefined symbol %s overflows 12-bit field"),
d1396 1
a1441 1
    case C (COND_JUMP_DELAY, COND12):
a1442 11
      /* I found that a relax failure for gcc.c-torture/execute/930628-1.c
	 was due to gas incorrectly relaxing an out-of-range conditional
	 branch with delay slot.  It turned:
                     bf.s    L6              (slot mov.l   r12,@@(44,r0))
         into:
   
2c:  8f 01 a0 8b     bf.s    32 <_main+32>   (slot bra       L6)
30:  00 09           nop
32:  10 cb           mov.l   r12,@@(44,r0)
         Therefore, branches with delay slots have to be handled
	 differently from ones without delay slots.  */
a1447 1
	int delay = fragP->fr_subtype == C (COND_JUMP_DELAY, COND12);
d1452 1
a1452 7
	/* If this is a dalayed branch, we may not put the the bra in the
	   slot.  So we change it to a non-delayed branch, like that:
	   b! cond slot_label; bra disp; slot_label: slot_insn
	   ??? We should try if swapping the conditional branch and
	   its delay-slot insn already makes the branch reach.  */

	/* Build a relocation to six / four bytes farther on.  */
d1460 1
a1460 1
		 fragP->fr_address + fragP->fr_fix + (delay ? 4 : 6),
d1469 3
a1471 10
	if (delay)
	  {
	    buffer[highbyte] &= ~0x4; /* Removes delay slot from branch.  */
	    fragP->fr_fix += 4;
	  }
	else
	  {
	    /* Fill in a NOP instruction.  */
	    buffer[highbyte + 4] = 0x0;
	    buffer[lowbyte + 4] = 0x9;
d1473 1
a1473 2
	    fragP->fr_fix += 6;
	  }
a1479 1
    case C (COND_JUMP_DELAY, COND32):
a1480 1
    case C (COND_JUMP_DELAY, UNDEF_WORD_DISP):
d1482 1
a1482 1
	as_bad (_("at 0x%lx, displacement overflows 8-bit field"), 
d1484 2
a1485 6
      else if (S_IS_DEFINED (fragP->fr_symbol))
	as_bad (_("at 0x%lx, displacement to defined symbol %s overflows 8-bit field "),
		(unsigned long) fragP->fr_address,		
		S_GET_NAME (fragP->fr_symbol));
      else
	as_bad (_("at 0x%lx, displacement to undefined symbol %s overflows 8-bit field "),
d1487 1
d1539 1
a1539 1
		   _("overflow in branch to %s; converted into longer instruction sequence"),
a1562 61
/* This static variable is set by s_uacons to tell sh_cons_align that
   the expession does not need to be aligned.  */

static int sh_no_align_cons = 0;

/* This handles the unaligned space allocation pseudo-ops, such as
   .uaword.  .uaword is just like .word, but the value does not need
   to be aligned.  */

static void
s_uacons (bytes)
     int bytes;
{
  /* Tell sh_cons_align not to align this value.  */
  sh_no_align_cons = 1;
  cons (bytes);
}

/* If a .word, et. al., pseud-op is seen, warn if the value is not
   aligned correctly.  Note that this can cause warnings to be issued
   when assembling initialized structured which were declared with the
   packed attribute.  FIXME: Perhaps we should require an option to
   enable this warning?  */

void
sh_cons_align (nbytes)
     int nbytes;
{
  int nalign;
  char *p;

  if (sh_no_align_cons)
    {
      /* This is an unaligned pseudo-op.  */
      sh_no_align_cons = 0;
      return;
    }

  nalign = 0;
  while ((nbytes & 1) == 0)
    {
      ++nalign;
      nbytes >>= 1;
    }

  if (nalign == 0)
    return;

  if (now_seg == absolute_section)
    {
      if ((abs_section_offset & ((1 << nalign) - 1)) != 0)
	as_warn (_("misaligned data"));
      return;
    }

  p = frag_var (rs_align_code, 1, 1, (relax_substateT) 0,
		(symbolS *) NULL, (offsetT) nalign, (char *) NULL);

  record_alignment (now_seg, nalign);
}

d1564 1
a1564 2
   that requests alignment to a four byte boundary or larger.  This is
   also where we check for misaligned data.  */
a1576 4

  if (frag->fr_type == rs_align_code
      && frag->fr_next->fr_address - frag->fr_address - frag->fr_fix != 0)
    as_warn_where (frag->fr_file, frag->fr_line, _("misaligned data"));
a1589 1
       || (fix)->fx_size == 1				\
a1599 1
       || (fix)->fx_r_type == BFD_RELOC_8		\
a1609 5

  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

a1621 45
#ifdef OBJ_ELF
boolean
sh_fix_adjustable (fixP)
   fixS *fixP;
{

  if (fixP->fx_addsy == NULL)
    return 1;
  
  /* We need the symbol name for the VTABLE entries */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}

void sh_elf_final_processing()
{
  int val;

  /* Set file-specific flags to indicate if this code needs
     a processor with the sh-dsp / sh3e ISA to execute.  */
  if (valid_arch & arch_sh1)
    val = EF_SH1;
  else if (valid_arch & arch_sh2)
    val = EF_SH2;
  else if (valid_arch & arch_sh_dsp)
    val = EF_SH_DSP;
  else if (valid_arch & arch_sh3)
    val = EF_SH3;
  else if (valid_arch & arch_sh3_dsp)
    val = EF_SH_DSP;
  else if (valid_arch & arch_sh3e)
    val = EF_SH3E;
  else if (valid_arch & arch_sh4)
    val = EF_SH4;
  else
    abort ();

  elf_elfheader (stdoutput)->e_flags &= ~EF_SH_MACH_MASK;
  elf_elfheader (stdoutput)->e_flags |= val;
}
#endif

a1641 12
  long max, min;
  int shift;

#ifdef BFD_ASSEMBLER
  /* adjust_reloc_syms won't convert a reloc against a weak symbol
     into a reloc against a section, but bfd_install_relocation will
     screw up if the symbol is defined, so we have to adjust val here
     to avoid the screw up later.  */
  if (fixP->fx_addsy != NULL
      && S_IS_WEAK (fixP->fx_addsy))
    val -= S_GET_VALUE  (fixP->fx_addsy);
#endif
d1651 1
a1651 1
	fixP->fx_r_type = BFD_RELOC_8;
a1656 2
  max = min = 0;
  shift = 0;
a1659 1
      max = 0xf;
a1663 2
      max = 0xf;
      shift = 1;
a1667 2
      max = 0xf;
      shift = 2;
a1671 2
      max = 0xff;
      shift = 1;
a1675 2
      max = 0xff;
      shift = 2;
a1680 6
      /* Sometimes the 8 bit value is sign extended (e.g., add) and
         sometimes it is not (e.g., and).  We permit any 8 bit value.
         Note that adding further restrictions may invalidate
         reasonable looking assembly code, such as ``and -0x1,r0''.  */
      max = 0xff;
      min = - 0xff;
d1700 1
a1700 1
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
d1707 1
a1707 1
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
d1714 1
a1714 1
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
d1721 1
a1721 1
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far"));
a1768 9
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
#ifdef BFD_ASSEMBLER
      return 0;
#else
      return;
#endif

a1772 13
  if (shift != 0)
    {
      if ((val & ((1 << shift) - 1)) != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("misaligned offset"));
      if (val >= 0)
	val >>= shift;
      else
	val = ((val >> shift)
	       | ((long) -1 & ~ ((long) -1 >> shift)));
    }
  if (max != 0 && (val < min || val > max))
    as_bad_where (fixP->fx_file, fixP->fx_line, _("offset out of range"));

d1778 2
a1812 1
    case C (COND_JUMP_DELAY, UNDEF_DISP):
a1816 1
	  int what = GET_WHAT (fragP->fr_subtype);
d1819 2
a1820 2
	  fragP->fr_subtype = C (what, COND8);
	  fragP->fr_var = md_relax_table[C (what, COND8)].rlx_length;
a1823 1
	  int what = GET_WHAT (fragP->fr_subtype);
d1825 3
a1827 3
	  fragP->fr_subtype = C (what, UNDEF_WORD_DISP);
	  fragP->fr_var = md_relax_table[C (what, COND32)].rlx_length;
	  return md_relax_table[C (what, COND32)].rlx_length;
a1830 1
	  int what = GET_WHAT (fragP->fr_subtype);
d1832 2
a1833 2
	  fragP->fr_subtype = C (what, COND8);
	  fragP->fr_var = md_relax_table[C (what, COND8)].rlx_length;
d1883 6
a1888 1
      && subseg_text_p (now_seg)
a1933 1
  { BFD_RELOC_8_PCREL, R_SH_SWITCH8 },
d1969 1
a1969 1
		      _("Can not represent %s relocation in this object file format"),
a1979 2
      else if (fix->fx_r_type == BFD_RELOC_8)
	intr->r_type = R_SH_SWITCH8;
d2070 1
a2070 2
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
a2079 2
      else if (r_type == BFD_RELOC_8)
	r_type = BFD_RELOC_8_PCREL;
a2090 3
  else if (r_type == BFD_RELOC_VTABLE_INHERIT
           || r_type == BFD_RELOC_VTABLE_ENTRY)
    rel->addend = fixp->fx_offset;
d2100 1
a2100 1
		    _("Cannot represent relocation type %s"),
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d21 4
a24 1
/* Written By Steve Chamberlain <sac@@cygnus.com>  */
a32 1
#include "struc-symbol.h"
a37 2
#include "dwarf2dbg.h"

d51 1
a51 7
static unsigned int assemble_ppi PARAMS ((char *, sh_opcode_info *));

#ifdef OBJ_ELF
static void sh_elf_cons PARAMS ((int));

symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
#endif
d57 1
a57 1
     int ignore ATTRIBUTE_UNUSED;
d67 2
a68 1
   Integer arg to pass to the function.  */
a71 6
#ifdef OBJ_ELF
  {"long", sh_elf_cons, 4},
  {"int", sh_elf_cons, 4},
  {"word", sh_elf_cons, 2},
  {"short", sh_elf_cons, 2},
#else
a73 1
#endif /* OBJ_ELF */
a82 8
  {"uaquad", s_uacons, 8},
  {"2byte", s_uacons, 2},
  {"4byte", s_uacons, 4},
  {"8byte", s_uacons, 8},
#ifdef BFD_ASSEMBLER
  {"file", dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
#endif
d104 1
a104 1
/* Chars that mean this number is a floating point constant.  */
d111 1
d115 1
a115 1
/* These are the three types of relaxable instrction.  */
d125 2
a161 2
#define EMPTY { 0, 0, 0, 0 }

d163 2
a164 2
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
d166 1
a166 1
  EMPTY,
d173 2
a174 4
  /* C (COND_JUMP, UNDEF_WORD_DISP) */
  { 0, 0, COND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
d176 1
a176 1
  EMPTY,
d183 2
a184 4
  /* C (COND_JUMP_DELAY, UNDEF_WORD_DISP) */
  { 0, 0, COND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
d186 1
a186 1
  EMPTY,
d191 2
a192 5
  EMPTY,
  /* C (UNCOND_JUMP, UNDEF_WORD_DISP) */
  { 0, 0, UNCOND32_LENGTH, 0, },
  EMPTY, EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,
a194 2
#undef EMPTY

d197 4
a200 187

#ifdef OBJ_ELF
/* Parse @@got, etc. and return the desired relocation.
   If we have additional arithmetic expression, then we fill in new_exp_p.  */
static bfd_reloc_code_real_type
sh_elf_suffix (str_p, exp_p, new_exp_p)
     char **str_p;
     expressionS *exp_p, *new_exp_p;
{
  struct map_bfd {
    char *string;
    int length;
    bfd_reloc_code_real_type reloc;
  };

  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;
  struct map_bfd *ptr;

#define MAP(str,reloc) { str, sizeof (str)-1, reloc }

  static struct map_bfd mapping[] = {
    MAP ("got",		BFD_RELOC_32_GOT_PCREL),
    MAP ("plt",		BFD_RELOC_32_PLT_PCREL),
    MAP ("gotoff",	BFD_RELOC_32_GOTOFF),
    { (char *)0,	0,	BFD_RELOC_UNUSED }
  };

  if (*str++ != '@@')
    return BFD_RELOC_UNUSED;

  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
	&& (isalnum (ch) || ch == '@@'));
       ch = *++str)
    {
      *str2++ = (islower (ch)) ? ch : tolower (ch);
    }

  *str2 = '\0';
  len = str2 - ident;

  ch = ident[0];
  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (ch == ptr->string[0]
	&& len == ptr->length
	&& memcmp (ident, ptr->string, ptr->length) == 0)
      {
	/* Now check for identifier@@suffix+constant */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;

	    input_line_pointer = str;
	    expression (new_exp_p);
	    if (new_exp_p->X_op == O_constant)
	      {
		exp_p->X_add_number += new_exp_p->X_add_number;
		str = input_line_pointer;
	      }
	    if (new_exp_p->X_op == O_subtract)
	      str = input_line_pointer;

	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }

	*str_p = str;
	return ptr->reloc;
      }

  return BFD_RELOC_UNUSED;
}

/* The regular cons() function, that reads constants, doesn't support
   suffixes such as @@GOT, @@GOTOFF and @@PLT, that generate
   machine-specific relocation types.  So we must define it here.  */
/* Clobbers input_line_pointer, checks end-of-line.  */
static void
sh_elf_cons (nbytes)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
{
  expressionS exp, new_exp;
  bfd_reloc_code_real_type reloc;
  const char *name;

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);
      new_exp.X_op = O_absent;
      new_exp.X_add_symbol = new_exp.X_op_symbol = NULL;
      /* If the _GLOBAL_OFFSET_TABLE_ symbol hasn't been found yet,
	 use the name of the symbol to tell whether it's the
	 _GLOBAL_OFFSET_TABLE_.  If it has, comparing the symbols is
	 sufficient.  */
      if (! GOT_symbol && exp.X_add_symbol)
	name = S_GET_NAME (exp.X_add_symbol);
      else
	name = NULL;
      /* Check whether this expression involves the
	 _GLOBAL_OFFSET_TABLE_ symbol, by itself or added to a
	 difference of two other symbols.  */
      if (((GOT_symbol && GOT_symbol == exp.X_add_symbol)
	   || (! GOT_symbol && name
	       && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0))
	  && (exp.X_op == O_symbol
	      || (exp.X_op == O_add
		  && ((symbol_get_value_expression (exp.X_op_symbol)->X_op)
		      == O_subtract))))
	{
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput,
								 BFD_RELOC_32);
	  int size = bfd_get_reloc_size (reloc_howto);

	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	  if (size > nbytes)
	    as_bad (_("%s relocations do not fit in %d bytes\n"),
		    reloc_howto->name, nbytes);
	  else
	    {
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;

	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset,
			   size, &exp, 0, TC_RELOC_GLOBAL_OFFSET_TABLE);
	    }
	}
      /* Check if this symbol involves one of the magic suffixes, such
	 as @@GOT, @@GOTOFF or @@PLT, and determine which relocation type
	 to use.  */
      else if ((exp.X_op == O_symbol || (exp.X_op == O_add && exp.X_op_symbol))
	  && *input_line_pointer == '@@'
	  && ((reloc = sh_elf_suffix (&input_line_pointer, &exp, &new_exp))
	      != BFD_RELOC_UNUSED))
	{
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput,
								 reloc);
	  int size = bfd_get_reloc_size (reloc_howto);

	  /* Force a GOT to be generated.  */
	  if (GOT_symbol == NULL)
	    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);

	  if (size > nbytes)
	    as_bad (_("%s relocations do not fit in %d bytes\n"),
		    reloc_howto->name, nbytes);
	  else
	    {
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;

	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	      if (new_exp.X_op != O_absent)
		fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			     &new_exp, 0, BFD_RELOC_32);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  if (*input_line_pointer == '#' || *input_line_pointer == '!')
    {
       while (! is_end_of_line[(unsigned char) *input_line_pointer++]);
    }
  else
    demand_empty_rest_of_line ();
}
#endif /* OBJ_ELF */


/* This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs.  */
d222 1
a222 1
  /* Insert unique names into hash table.  */
d235 1
a235 1
	     string.  */
d247 2
a252 1
    expressionS immediate;
d254 1
d259 1
a259 2
/* Try to parse a reg name.  Return the number of chars consumed.  */

a265 3
  char l0 = tolower (src[0]);
  char l1 = l0 ? tolower (src[1]) : 0;

d270 1
a270 1
  if (l0 == 'r')
d272 1
a272 1
      if (l1 == '1')
d282 1
a282 1
      if (l1 >= '0' && l1 <= '9'
d286 1
a286 1
	  *reg = (l1 - '0');
d289 1
a289 1
      if (l1 >= '0' && l1 <= '7' && strncasecmp (&src[2], "_bank", 5) == 0
d293 1
a293 1
	  *reg  = (l1 - '0');
d297 1
a297 1
      if (l1 == 'e' && ! IDENT_CHAR ((unsigned char) src[2]))
d302 1
a302 1
      if (l1 == 's' && ! IDENT_CHAR ((unsigned char) src[2]))
d309 1
a309 1
  if (l0 == 'a')
d311 1
a311 1
      if (l1 == '0')
d319 1
a319 1
	  if (tolower (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d326 1
a326 1
      if (l1 == '1')
d334 1
a334 1
	  if (tolower (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d342 1
a342 1
      if (l1 == 'x' && src[2] >= '0' && src[2] <= '1'
d346 1
a346 1
	  *reg = 4 + (l1 - '0');
d349 1
a349 1
      if (l1 == 'y' && src[2] >= '0' && src[2] <= '1'
d353 1
a353 1
	  *reg = 6 + (l1 - '0');
d356 1
a356 1
      if (l1 == 's' && src[2] >= '0' && src[2] <= '3'
d359 1
a359 1
	  int n = l1 - '0';
d367 1
a367 1
  if (l0 == 'i' && l1 && ! IDENT_CHAR ((unsigned char) src[3]))
d369 1
a369 1
      if (l1 == 's')
d375 1
a375 1
      if (l1 == 'x')
d381 1
a381 1
      if (l1 == 'y')
d389 1
a389 1
  if (l0 == 'x' && l1 >= '0' && l1 <= '1'
d393 1
a393 1
      *reg = A_X0_NUM + l1 - '0';
d397 1
a397 1
  if (l0 == 'y' && l1 >= '0' && l1 <= '1'
d401 1
a401 1
      *reg = A_Y0_NUM + l1 - '0';
d405 1
a405 1
  if (l0 == 'm' && l1 >= '0' && l1 <= '1'
d409 1
a409 1
      *reg = l1 == '0' ? A_M0_NUM : A_M1_NUM;
d413 3
a415 3
  if (l0 == 's'
      && l1 == 's'
      && tolower (src[2]) == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
d421 1
a421 1
  if (l0 == 's' && l1 == 'p' && tolower (src[2]) == 'c'
d428 1
a428 1
  if (l0 == 's' && l1 == 'g' && tolower (src[2]) == 'r'
d435 1
a435 1
  if (l0 == 'd' && l1 == 's' && tolower (src[2]) == 'r'
d442 1
a442 1
  if (l0 == 'd' && l1 == 'b' && tolower (src[2]) == 'r'
d449 1
a449 1
  if (l0 == 's' && l1 == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
d455 1
a455 1
  if (l0 == 's' && l1 == 'p' && ! IDENT_CHAR ((unsigned char) src[2]))
d462 1
a462 1
  if (l0 == 'p' && l1 == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
d467 1
a467 1
  if (l0 == 'p' && l1 == 'c' && ! IDENT_CHAR ((unsigned char) src[2]))
d469 1
a469 3
      /* Don't use A_DISP_PC here - that would accept stuff like 'mova pc,r0'
         and use an uninitialized immediate.  */
      *mode = A_PC;
d472 1
a472 1
  if (l0 == 'g' && l1 == 'b' && tolower (src[2]) == 'r'
d478 1
a478 1
  if (l0 == 'v' && l1 == 'b' && tolower (src[2]) == 'r'
d485 1
a485 1
  if (l0 == 'm' && l1 == 'a' && tolower (src[2]) == 'c'
d488 1
a488 1
      if (tolower (src[3]) == 'l')
d493 1
a493 1
      if (tolower (src[3]) == 'h')
d499 1
a499 1
  if (l0 == 'm' && l1 == 'o' && tolower (src[2]) == 'd'
d505 1
a505 1
  if (l0 == 'f' && l1 == 'r')
d525 1
a525 1
  if (l0 == 'd' && l1 == 'r')
d545 1
a545 1
  if (l0 == 'x' && l1 == 'd')
d565 1
a565 1
  if (l0 == 'f' && l1 == 'v')
d581 1
a581 2
  if (l0 == 'f' && l1 == 'p' && tolower (src[2]) == 'u'
      && tolower (src[3]) == 'l'
d588 2
a589 3
  if (l0 == 'f' && l1 == 'p' && tolower (src[2]) == 's'
      && tolower (src[3]) == 'c'
      && tolower (src[4]) == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
d595 2
a596 3
  if (l0 == 'x' && l1 == 'm' && tolower (src[2]) == 't'
      && tolower (src[3]) == 'r'
      && tolower (src[4]) == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
d605 1
a605 2
static symbolS *
dot ()
d616 1
d619 4
a622 2
static char *
parse_exp (s, op)
a623 1
     sh_operand_info *op;
d630 2
a631 2
  expression (&op->immediate);
  if (op->immediate.X_op == O_absent)
d638 1
d656 1
d659 2
a660 1
static char *
d670 1
a670 1
      /* Must be predecrement.  */
d713 1
a713 1
	  src = parse_exp (src, op);
d728 1
a728 1
	      else if (mode == A_PC)
d730 5
a734 6
		  /* Turn a plain @@(4,pc) into @@(.+4,pc).  */
		  if (op->immediate.X_op == O_constant)
		    {
		      op->immediate.X_add_symbol = dot();
		      op->immediate.X_op = O_symbol;
		    }
d798 1
a798 1
      *ptr = parse_exp (src, op);
d817 2
a818 2
      /* Not a reg, the only thing left is a displacement.  */
      *ptr = parse_exp (src, op);
d824 2
a825 1
static char *
d830 1
d849 1
a849 7
	  /* ??? Hack: psha/pshl have a varying operand number depending on
	     the type of the first operand.  We handle this by having the
	     three-operand version first and reducing the number of operands
	     parsed to two if we see that the first operand is an immediate.
             This works because no insn with three operands has an immediate
	     as first operand.  */
	  if (info->arg[2] && operand[0].type != A_IMM)
d879 2
a880 1
   provided.  */
d882 2
a883 1
static sh_opcode_info *
a890 1

d897 1
a897 1
	     opcodes with the same name.  */
d900 1
a900 2

      /* Look at both operands needed by the opcodes and provided by
d903 2
a904 1
         first on each opcode try.  */
a908 1

d976 1
a976 1
	    case A_REG_B:
d1147 1
a1147 1

d1157 1
a1157 2
    fail:
      ;
d1178 1
d1180 1
a1180 1
insert (where, how, pcrel, op)
a1183 1
     sh_operand_info *op;
d1188 1
a1188 1
	       &op->immediate,
d1194 1
a1194 1
build_relax (opcode, op)
a1195 1
     sh_operand_info *op;
d1207 2
a1208 2
		    op->immediate.X_add_symbol,
		    op->immediate.X_add_number,
d1218 2
a1219 2
		    op->immediate.X_add_symbol,
		    op->immediate.X_add_number,
d1226 3
a1228 53
/* Insert ldrs & ldre with fancy relocations that relaxation can recognize.  */

static char *
insert_loop_bounds (output, operand)
     char *output;
     sh_operand_info *operand;
{
  char *name;
  symbolS *end_sym;

  /* Since the low byte of the opcode will be overwritten by the reloc, we
     can just stash the high byte into both bytes and ignore endianness.  */
  output[0] = 0x8c;
  output[1] = 0x8c;
  insert (output, BFD_RELOC_SH_LOOP_START, 1, operand);
  insert (output, BFD_RELOC_SH_LOOP_END, 1, operand + 1);

  if (sh_relax)
    {
      static int count = 0;

      /* If the last loop insn is a two-byte-insn, it is in danger of being
	 swapped with the insn after it.  To prevent this, create a new
	 symbol - complete with SH_LABEL reloc - after the last loop insn.
	 If the last loop insn is four bytes long, the symbol will be
	 right in the middle, but four byte insns are not swapped anyways.  */
      /* A REPEAT takes 6 bytes.  The SH has a 32 bit address space.
	 Hence a 9 digit number should be enough to count all REPEATs.  */
      name = alloca (11);
      sprintf (name, "_R%x", count++ & 0x3fffffff);
      end_sym = symbol_new (name, undefined_section, 0, &zero_address_frag);
      /* Make this a local symbol.  */
#ifdef OBJ_COFF
      SF_SET_LOCAL (end_sym);
#endif /* OBJ_COFF */
      symbol_table_insert (end_sym);
      end_sym->sy_value = operand[1].immediate;
      end_sym->sy_value.X_add_number += 2;
      fix_new (frag_now, frag_now_fix (), 2, end_sym, 0, 1, BFD_RELOC_SH_LABEL);
    }

  output = frag_more (2);
  output[0] = 0x8e;
  output[1] = 0x8e;
  insert (output, BFD_RELOC_SH_LOOP_START, 1, operand);
  insert (output, BFD_RELOC_SH_LOOP_END, 1, operand + 1);

  return frag_more (2);
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static unsigned int
a1236 1
  unsigned int size = 2;
d1268 1
a1268 1
	    case REG_B:
d1271 2
a1272 8
	    case IMM0_4BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY4, 0, operand);
	      break;
	    case IMM0_4BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY2, 0, operand);
	      break;
	    case IMM0_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0, operand);
d1274 2
a1275 2
	    case IMM1_4BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY4, 0, operand + 1);
d1277 2
a1278 2
	    case IMM1_4BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4BY2, 0, operand + 1);
d1280 2
a1281 2
	    case IMM1_4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM4, 0, operand + 1);
d1283 2
a1284 2
	    case IMM0_8BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY4, 0, operand);
d1286 2
a1287 2
	    case IMM0_8BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY2, 0, operand);
d1289 2
a1290 11
	    case IMM0_8:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8, 0, operand);
	      break;
	    case IMM1_8BY4:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY4, 0, operand + 1);
	      break;
	    case IMM1_8BY2:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8BY2, 0, operand + 1);
	      break;
	    case IMM1_8:
	      insert (output + low_byte, BFD_RELOC_SH_IMM8, 0, operand + 1);
d1293 1
a1293 1
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY4, 1, operand);
d1296 1
a1296 6
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY2, 1, operand);
	      break;
	    case REPEAT:
	      output = insert_loop_bounds (output, operand);
	      nbuf[index] = opcode->nibbles[3];
	      operand += 2;
d1303 8
a1310 11
  if (!target_big_endian)
    {
      output[1] = (nbuf[0] << 4) | (nbuf[1]);
      output[0] = (nbuf[2] << 4) | (nbuf[3]);
    }
  else
    {
      output[0] = (nbuf[0] << 4) | (nbuf[1]);
      output[1] = (nbuf[2] << 4) | (nbuf[3]);
    }
  return size;
d1325 1
a1325 2

  /* Drop leading whitespace.  */
a1349 1

d1354 3
a1356 1
    as_bad (_("can't find opcode "));
d1363 1
a1363 2

static unsigned int
a1373 1
  unsigned int size;
d1389 1
a1389 1
	  /* Couldn't find an opcode which matched the operands.  */
a1390 1
	  size = 2;
d1395 1
a1395 1
	  return size;
a1396 1

d1460 1
a1460 1
	  if (operand[0].immediate.X_op != O_constant)
d1463 1
a1463 1
		     | (operand[0].immediate.X_add_number & 127) << 4
a1538 1
      size = 4;
d1552 2
a1553 5
    {
      /* Just a double data transfer.  */
      output = frag_more (2);
      size = 2;
    }
a1563 1
  return size;
d1568 2
a1569 1
   the frags/bytes it assembles to.  */
a1577 1
  unsigned int size = 0;
d1600 9
a1608 1
      size = assemble_ppi (op_end, opcode);
d1612 1
a1612 2
      if (opcode->arg[0] == A_BDISP12
	  || opcode->arg[0] == A_BDISP8)
d1614 4
a1617 2
	  parse_exp (op_end + 1, &operand[0]);
	  build_relax (opcode, &operand[0]);
d1621 8
a1628 12
	  if (opcode->arg[0] == A_END)
	    {
	      /* Ignore trailing whitespace.  If there is any, it has already
		 been compressed to a single space.  */
	      if (*op_end == ' ')
		op_end++;
	    }
	  else
	    {
	      op_end = get_operands (opcode, op_end, operand);
	    }
	  opcode = get_specific (opcode, operand);
d1630 5
a1634 5
	  if (opcode == 0)
	    {
	      /* Couldn't find an opcode which matched the operands.  */
	      char *where = frag_more (2);
	      size = 2;
d1636 2
a1637 8
	      where[0] = 0x0;
	      where[1] = 0x0;
	      as_bad (_("invalid operands for opcode"));
	    }
	  else
	    {
	      if (*op_end)
		as_bad (_("excess operands: '%s'"), op_end);
d1639 1
a1639 3
	      size = build_Mytes (opcode, operand);
	    }
	}
a1641 3
#ifdef BFD_ASSEMBLER
  dwarf2_emit_insn (size);
#endif
d1661 1
a1661 1
	{
d1685 2
a1686 2
md_undefined_symbol (name)
     char *name;
a1687 18
#ifdef OBJ_ELF
  /* Under ELF we need to default _GLOBAL_OFFSET_TABLE.  Otherwise we
     have no need to default values of symbols.  */
  if (strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");

	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT)0, & zero_address_frag);
	}

      return GOT_symbol;
    }
#endif /* OBJ_ELF */

d1695 2
a1696 2
tc_crawl_symbol_chain (headers)
     object_headers *headers;
d1702 2
a1703 2
tc_headers_hook (headers)
     object_headers *headers;
d1711 2
a1712 2
/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
d1715 4
a1718 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP .  An error message is
   returned, or NULL on OK.  */

d1767 1
a1767 1

d1778 1
a1778 1
     int ignore ATTRIBUTE_UNUSED;
d1800 2
a1801 2
struct option md_longopts[] =
{
d1813 1
a1813 1
size_t md_longopts_size = sizeof (md_longopts);
d1818 1
a1818 1
     char *arg ATTRIBUTE_UNUSED;
d1850 1
a1850 1
  fprintf (stream, _("\
d1880 1
d1883 1
a1883 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1910 1
d1913 1
a1913 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1915 1
a1915 1
     PTR ignore ATTRIBUTE_UNUSED;
d1976 2
a1977 2
      /* The variable fscan should also be a fixup to a local symbol
	 in the same section.  */
d2055 1
a2055 1
     bfd *headers ATTRIBUTE_UNUSED;
d2086 2
a2087 2
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement overflows 12-bit field"));
d2089 3
a2091 3
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to defined symbol %s overflows 12-bit field"),
		      S_GET_NAME (fragP->fr_symbol));
d2093 40
a2132 5
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to undefined symbol %s overflows 12-bit field"),
		      S_GET_NAME (fragP->fr_symbol));
      /* Stabilize this frag, so we don't trip an assert.  */
      fragP->fr_fix += fragP->fr_var;
d2134 3
d2141 1
a2141 1
      /* A bcond won't fit, so turn it into a b!cond; bra disp; nop.  */
d2147 1
a2147 1

d2209 2
a2210 2
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement overflows 8-bit field"));
d2212 3
a2214 3
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to defined symbol %s overflows 8-bit field"),
		      S_GET_NAME (fragP->fr_symbol));
d2216 41
a2256 5
	as_bad_where (fragP->fr_file, fragP->fr_line,
		      _("displacement to undefined symbol %s overflows 8-bit field "),
		      S_GET_NAME (fragP->fr_symbol));
      /* Stabilize this frag, so we don't trip an assert.  */
      fragP->fr_fix += fragP->fr_var;
d2258 3
d2276 3
a2278 3
md_section_align (seg, size)
     segT seg ATTRIBUTE_UNUSED;
     valueT size;
d2348 1
a2348 1
  p = frag_var (rs_align_test, 1, 1, (relax_substateT) 0,
a2361 33
  int bytes = frag->fr_next->fr_address - frag->fr_address - frag->fr_fix;

  if (frag->fr_type == rs_align_code)
    {
      static const unsigned char big_nop_pattern[] = { 0x00, 0x09 };
      static const unsigned char little_nop_pattern[] = { 0x09, 0x00 };

      char *p = frag->fr_literal + frag->fr_fix;

      if (bytes & 1)
	{
	  *p++ = 0;
	  bytes--;
	  frag->fr_fix += 1;
	}

      if (target_big_endian)
	{
	  memcpy (p, big_nop_pattern, sizeof big_nop_pattern);
	  frag->fr_var = sizeof big_nop_pattern;
	}
      else
	{
	  memcpy (p, little_nop_pattern, sizeof little_nop_pattern);
	  frag->fr_var = sizeof little_nop_pattern;
	}
    }
  else if (frag->fr_type == rs_align_test)
    {
      if (bytes != 0)
	as_warn_where (frag->fr_file, frag->fr_line, _("misaligned data"));
    }

d2363 1
a2363 2
      && (frag->fr_type == rs_align
	  || frag->fr_type == rs_align_code)
d2369 4
d2410 1
a2410 3
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fix->fx_r_type == BFD_RELOC_SH_LOOP_START
      || fix->fx_r_type == BFD_RELOC_SH_LOOP_END)
d2433 1
a2433 15

  if (fixP->fx_r_type == BFD_RELOC_SH_PCDISP8BY2
      || fixP->fx_r_type == BFD_RELOC_SH_PCDISP12BY2
      || fixP->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY2
      || fixP->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY4
      || fixP->fx_r_type == BFD_RELOC_8_PCREL
      || fixP->fx_r_type == BFD_RELOC_SH_SWITCH16
      || fixP->fx_r_type == BFD_RELOC_SH_SWITCH32)
    return 1;

  if (! TC_RELOC_RTSYM_LOC_FIXUP (fixP)
      || fixP->fx_r_type == BFD_RELOC_32_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_RVA)
    return 0;

d2442 1
a2442 2
void
sh_elf_final_processing ()
d2494 5
a2498 43
  /* A difference between two symbols, the second of which is in the
     current section, is transformed in a PC-relative relocation to
     the other symbol.  We have to adjust the relocation type here.  */
  if (fixP->fx_pcrel)
    {
      switch (fixP->fx_r_type)
	{
	default:
	  break;

	case BFD_RELOC_32:
	  fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  break;

	  /* Currently, we only support 32-bit PCREL relocations.
	     We'd need a new reloc type to handle 16_PCREL, and
	     8_PCREL is already taken for R_SH_SWITCH8, which
	     apparently does something completely different than what
	     we need.  FIXME.  */
	case BFD_RELOC_16:
	  bfd_set_error (bfd_error_bad_value);
	  return false;

	case BFD_RELOC_8:
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
    }

  /* The function adjust_reloc_syms won't convert a reloc against a weak
     symbol into a reloc against a section, but bfd_install_relocation
     will screw up if the symbol is defined, so we have to adjust val here
     to avoid the screw up later.

     For ordinary relocs, this does not happen for ELF, since for ELF,
     bfd_install_relocation uses the "special function" field of the
     howto, and does not execute the code that needs to be undone, as long
     as the special function does not return bfd_reloc_continue.
     It can happen for GOT- and PLT-type relocs the way they are
     described in elf32-sh.c as they use bfd_elf_generic_reloc, but it
     doesn't matter here since those relocs don't use VAL; see below.  */
  if (OUTPUT_FLAVOR != bfd_target_elf_flavour
      && fixP->fx_addsy != NULL
d2557 1
a2557 1
      min = -0xff;
d2597 1
a2597 1
      if (val < -0x800 || val > 0x7ff)
d2604 14
a2617 2
    case BFD_RELOC_32_PCREL:
      md_number_to_chars (buf, val, 4);
d2621 10
a2630 1
      md_number_to_chars (buf, val, 2);
a2645 3
    case BFD_RELOC_SH_LOOP_START:
    case BFD_RELOC_SH_LOOP_END:

a2654 37
#ifdef OBJ_ELF
    case BFD_RELOC_32_PLT_PCREL:
      /* Make the jump instruction point to the address of the operand.  At
	 runtime we merely add the offset to the actual PLT entry.  */
      *valp = 0xfffffffc;
      break;

    case BFD_RELOC_SH_GOTPC:
      /* This is tough to explain.  We end up with this one if we have
         operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".
         The goal here is to obtain the absolute address of the GOT,
         and it is strongly preferable from a performance point of
         view to avoid using a runtime relocation for this.  There are
         cases where you have something like:

         .long	_GLOBAL_OFFSET_TABLE_+[.-.L66]

         and here no correction would be required.  Internally in the
         assembler we treat operands of this form as not being pcrel
         since the '.' is explicitly mentioned, and I wonder whether
         it would simplify matters to do it this way.  Who knows.  In
         earlier versions of the PIC patches, the pcrel_adjust field
         was used to store the correction, but since the expression is
         not pcrel, I felt it would be confusing to do it this way.  */
      *valp -= 1;
      md_number_to_chars (buf, val, 4);
      break;

    case BFD_RELOC_32_GOT_PCREL:
      *valp = 0; /* Fully resolved at runtime.  No addend.  */
      md_number_to_chars (buf, 0, 4);
      break;

    case BFD_RELOC_32_GOTOFF:
      break;
#endif

a2684 2
  int what;

a2686 3
    default:
      abort ();

d2688 1
a2688 1
      /* Used to be a branch to somewhere which was unknown.  */
d2692 1
d2697 1
d2702 2
d2707 2
d2711 1
a2711 2
      what = GET_WHAT (fragP->fr_subtype);
      /* Used to be a branch to somewhere which was unknown.  */
d2715 1
d2717 1
a2717 1
	     sized - maybe it will fix up.  */
d2719 1
d2723 2
a2724 1
	  /* Its got a segment, but its not ours, so it will always be long.  */
d2726 2
d2731 2
a2732 1
	  /* We know the abs value.  */
d2734 1
a2735 1
      break;
a2736 13
    case C (UNCOND_JUMP, UNCOND12):
    case C (UNCOND_JUMP, UNCOND32):
    case C (UNCOND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP, COND8):
    case C (COND_JUMP, COND12):
    case C (COND_JUMP, COND32):
    case C (COND_JUMP, UNDEF_WORD_DISP):
    case C (COND_JUMP_DELAY, COND8):
    case C (COND_JUMP_DELAY, COND12):
    case C (COND_JUMP_DELAY, COND32):
    case C (COND_JUMP_DELAY, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
a2738 2

  fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
d2742 1
a2742 1
/* Put number into target byte order.  */
d2774 30
d2962 1
a2962 1
     asection *section ATTRIBUTE_UNUSED;
a2995 8
  else if (r_type == BFD_RELOC_SH_LOOP_START
           || r_type == BFD_RELOC_SH_LOOP_END)
    rel->addend = fixp->fx_offset;
  else if (r_type == BFD_RELOC_SH_LABEL && fixp->fx_pcrel)
    {
      rel->addend = 0;
      rel->address = rel->addend = fixp->fx_offset;
    }
a2996 2
    rel->addend = fixp->fx_addnumber;
  else if (r_type == BFD_RELOC_32 || r_type == BFD_RELOC_32_GOTOFF)
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d1 2
a2 2
/* tc-sh.c -- Assemble code for the Renesas / SuperH SH
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d30 1
a30 1
#include "safe-ctype.h"
a38 8
typedef struct
  {
    sh_arg_type type;
    int reg;
    expressionS immediate;
  }
sh_operand_info;

d48 2
a52 16
static void little PARAMS ((int));
static void big PARAMS ((int));
static int parse_reg PARAMS ((char *, int *, int *));
static char *parse_exp PARAMS ((char *, sh_operand_info *));
static char *parse_at PARAMS ((char *, sh_operand_info *));
static void get_operand PARAMS ((char **, sh_operand_info *));
static char *get_operands
  PARAMS ((sh_opcode_info *, char *, sh_operand_info *));
static sh_opcode_info *get_specific
  PARAMS ((sh_opcode_info *, sh_operand_info *));
static void insert PARAMS ((char *, int, int, sh_operand_info *));
static void build_relax PARAMS ((sh_opcode_info *, sh_operand_info *));
static char *insert_loop_bounds PARAMS ((char *, sh_operand_info *));
static unsigned int build_Mytes
  PARAMS ((sh_opcode_info *, sh_operand_info *));
static bfd_boolean sh_local_pcrel PARAMS ((fixS *fix));
a56 4
inline static int sh_PIC_related_p PARAMS ((symbolS *));
static int sh_check_fixup PARAMS ((expressionS *, bfd_reloc_code_real_type *));
inline static char *sh_end_of_match PARAMS ((char *, char *));

d60 1
a60 10
static void
big (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (! target_big_endian)
    as_bad (_("directive .big encountered when option -big required"));

  /* Stop further messages.  */
  target_big_endian = 1;
}
d66 1
a66 4
  if (target_big_endian)
    as_bad (_("directive .little encountered when option -little required"));

  /* Stop further messages.  */
a86 1
  {"big", big, 0},
d101 1
a101 1
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
a103 12
#ifdef HAVE_SH64
  {"mode", s_sh64_mode, 0 },

  /* Have the old name too.  */
  {"isa", s_sh64_mode, 0 },

  /* Assert that the right ABI is used.  */
  {"abi", s_sh64_abi, 0 },

  { "vtable_inherit", sh64_vtable_inherit, 0 },
  { "vtable_entry", sh64_vtable_entry, 0 },
#endif /* HAVE_SH64 */
d115 1
a115 1
/* preset architecture set, if given; zero otherwise.  */
d117 1
a117 1
static int preset_target_arch;
a135 2
/* These are the types of relaxable instructions; except for END which is
   a marker.  */
a138 22

#ifdef HAVE_SH64

/* A 16-bit (times four) pc-relative operand, at most expanded to 32 bits.  */
#define SH64PCREL16_32 4
/* A 16-bit (times four) pc-relative operand, at most expanded to 64 bits.  */
#define SH64PCREL16_64 5

/* Variants of the above for adjusting the insn to PTA or PTB according to
   the label.  */
#define SH64PCREL16PT_32 6
#define SH64PCREL16PT_64 7

/* A MOVI expansion, expanding to at most 32 or 64 bits.  */
#define MOVI_IMM_32 8
#define MOVI_IMM_32_PCREL 9
#define MOVI_IMM_64 10
#define MOVI_IMM_64_PCREL 11
#define END 12

#else  /* HAVE_SH64 */

a140 2
#endif /* HAVE_SH64 */

a149 18
#ifdef HAVE_SH64
#define UNDEF_SH64PCREL 0
#define SH64PCREL16 1
#define SH64PCREL32 2
#define SH64PCREL48 3
#define SH64PCREL64 4
#define SH64PCRELPLT 5

#define UNDEF_MOVI 0
#define MOVI_16 1
#define MOVI_32 2
#define MOVI_48 3
#define MOVI_64 4
#define MOVI_PLT 5
#define MOVI_GOTOFF 6
#define MOVI_GOTPC 7
#endif /* HAVE_SH64 */

a179 79
#ifdef HAVE_SH64
/* The trivial expansion of a SH64PCREL16 relaxation is just a "PT label,
   TRd" as is the current insn, so no extra length.  Note that the "reach"
   is calculated from the address *after* that insn, but the offset in the
   insn is calculated from the beginning of the insn.  We also need to
   take into account the implicit 1 coded as the "A" in PTA when counting
   forward.  If PTB reaches an odd address, we trap that as an error
   elsewhere, so we don't have to have different relaxation entries.  We
   don't add a one to the negative range, since PTB would then have the
   farthest backward-reaching value skipped, not generated at relaxation.  */
#define SH64PCREL16_F (32767 * 4 - 4 + 1)
#define SH64PCREL16_M (-32768 * 4 - 4)
#define SH64PCREL16_LENGTH 0

/* The next step is to change that PT insn into
     MOVI ((label - datalabel Ln) >> 16) & 65535, R25
     SHORI (label - datalabel Ln) & 65535, R25
    Ln:
     PTREL R25,TRd
   which means two extra insns, 8 extra bytes.  This is the limit for the
   32-bit ABI.

   The expressions look a bit bad since we have to adjust this to avoid overflow on a
   32-bit host.  */
#define SH64PCREL32_F ((((long) 1 << 30) - 1) * 2 + 1 - 4)
#define SH64PCREL32_LENGTH (2 * 4)

/* Similarly, we just change the MOVI and add a SHORI for the 48-bit
   expansion.  */
#if BFD_HOST_64BIT_LONG
/* The "reach" type is long, so we can only do this for a 64-bit-long
   host.  */
#define SH64PCREL32_M (((long) -1 << 30) * 2 - 4)
#define SH64PCREL48_F ((((long) 1 << 47) - 1) - 4)
#define SH64PCREL48_M (((long) -1 << 47) - 4)
#define SH64PCREL48_LENGTH (3 * 4)
#else
/* If the host does not have 64-bit longs, just make this state identical
   in reach to the 32-bit state.  Note that we have a slightly incorrect
   reach, but the correct one above will overflow a 32-bit number.  */
#define SH64PCREL32_M (((long) -1 << 30) * 2)
#define SH64PCREL48_F SH64PCREL32_F
#define SH64PCREL48_M SH64PCREL32_M
#define SH64PCREL48_LENGTH (3 * 4)
#endif /* BFD_HOST_64BIT_LONG */

/* And similarly for the 64-bit expansion; a MOVI + SHORI + SHORI + SHORI
   + PTREL sequence.  */
#define SH64PCREL64_LENGTH (4 * 4)

/* For MOVI, we make the MOVI + SHORI... expansion you can see in the
   SH64PCREL expansions.  The PCREL one is similar, but the other has no
   pc-relative reach; it must be fully expanded in
   shmedia_md_estimate_size_before_relax.  */
#define MOVI_16_LENGTH 0
#define MOVI_16_F (32767 - 4)
#define MOVI_16_M (-32768 - 4)
#define MOVI_32_LENGTH 4
#define MOVI_32_F ((((long) 1 << 30) - 1) * 2 + 1 - 4)
#define MOVI_48_LENGTH 8

#if BFD_HOST_64BIT_LONG
/* The "reach" type is long, so we can only do this for a 64-bit-long
   host.  */
#define MOVI_32_M (((long) -1 << 30) * 2 - 4)
#define MOVI_48_F ((((long) 1 << 47) - 1) - 4)
#define MOVI_48_M (((long) -1 << 47) - 4)
#else
/* If the host does not have 64-bit longs, just make this state identical
   in reach to the 32-bit state.  Note that we have a slightly incorrect
   reach, but the correct one above will overflow a 32-bit number.  */
#define MOVI_32_M (((long) -1 << 30) * 2)
#define MOVI_48_F MOVI_32_F
#define MOVI_48_M MOVI_32_M
#endif /* BFD_HOST_64BIT_LONG */

#define MOVI_64_LENGTH 12
#endif /* HAVE_SH64 */

a219 112

#ifdef HAVE_SH64
  /* C (SH64PCREL16_32, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16_32, SH64PCREL32) },
  /* C (SH64PCREL16_32, SH64PCREL32) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  /* C (SH64PCREL16_32, SH64PCRELPLT) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (SH64PCREL16_64, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16_64, SH64PCREL32) },
  /* C (SH64PCREL16_64, SH64PCREL32) */
  { SH64PCREL32_F, SH64PCREL32_M, SH64PCREL32_LENGTH, C (SH64PCREL16_64, SH64PCREL48) },
  /* C (SH64PCREL16_64, SH64PCREL48) */
  { SH64PCREL48_F, SH64PCREL48_M, SH64PCREL48_LENGTH, C (SH64PCREL16_64, SH64PCREL64) },
  /* C (SH64PCREL16_64, SH64PCREL64) */
  { 0, 0, SH64PCREL64_LENGTH, 0 },
  /* C (SH64PCREL16_64, SH64PCRELPLT) */
  { 0, 0, SH64PCREL64_LENGTH, 0 },
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (SH64PCREL16PT_32, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16PT_32, SH64PCREL32) },
  /* C (SH64PCREL16PT_32, SH64PCREL32) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  /* C (SH64PCREL16PT_32, SH64PCRELPLT) */
  { 0, 0, SH64PCREL32_LENGTH, 0 },
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (SH64PCREL16PT_64, SH64PCREL16) */
  EMPTY,
  { SH64PCREL16_F, SH64PCREL16_M, SH64PCREL16_LENGTH, C (SH64PCREL16PT_64, SH64PCREL32) },
  /* C (SH64PCREL16PT_64, SH64PCREL32) */
  { SH64PCREL32_F,
    SH64PCREL32_M,
    SH64PCREL32_LENGTH,
    C (SH64PCREL16PT_64, SH64PCREL48) },
  /* C (SH64PCREL16PT_64, SH64PCREL48) */
  { SH64PCREL48_F, SH64PCREL48_M, SH64PCREL48_LENGTH, C (SH64PCREL16PT_64, SH64PCREL64) },
  /* C (SH64PCREL16PT_64, SH64PCREL64) */
  { 0, 0, SH64PCREL64_LENGTH, 0 },
  /* C (SH64PCREL16PT_64, SH64PCRELPLT) */
  { 0, 0, SH64PCREL64_LENGTH, 0},
  EMPTY, EMPTY,
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_32, UNDEF_MOVI) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  /* C (MOVI_IMM_32, MOVI_16) */
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_32, MOVI_32) },
  /* C (MOVI_IMM_32, MOVI_32) */
  { MOVI_32_F, MOVI_32_M, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY,
  /* C (MOVI_IMM_32, MOVI_GOTOFF) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_32_PCREL, MOVI_16) */
  EMPTY,
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_32_PCREL, MOVI_32) },
  /* C (MOVI_IMM_32_PCREL, MOVI_32) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY,
  /* C (MOVI_IMM_32_PCREL, MOVI_PLT) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY,
  /* C (MOVI_IMM_32_PCREL, MOVI_GOTPC) */
  { 0, 0, MOVI_32_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_64, UNDEF_MOVI) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  /* C (MOVI_IMM_64, MOVI_16) */
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_64, MOVI_32) },
  /* C (MOVI_IMM_64, MOVI_32) */
  { MOVI_32_F, MOVI_32_M, MOVI_32_LENGTH, C (MOVI_IMM_64, MOVI_48) },
  /* C (MOVI_IMM_64, MOVI_48) */
  { MOVI_48_F, MOVI_48_M, MOVI_48_LENGTH, C (MOVI_IMM_64, MOVI_64) },
  /* C (MOVI_IMM_64, MOVI_64) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY,
  /* C (MOVI_IMM_64, MOVI_GOTOFF) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

  /* C (MOVI_IMM_64_PCREL, MOVI_16) */
  EMPTY,
  { MOVI_16_F, MOVI_16_M, MOVI_16_LENGTH, C (MOVI_IMM_64_PCREL, MOVI_32) },
  /* C (MOVI_IMM_64_PCREL, MOVI_32) */
  { MOVI_32_F, MOVI_32_M, MOVI_32_LENGTH, C (MOVI_IMM_64_PCREL, MOVI_48) },
  /* C (MOVI_IMM_64_PCREL, MOVI_48) */
  { MOVI_48_F, MOVI_48_M, MOVI_48_LENGTH, C (MOVI_IMM_64_PCREL, MOVI_64) },
  /* C (MOVI_IMM_64_PCREL, MOVI_64) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  /* C (MOVI_IMM_64_PCREL, MOVI_PLT) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY,
  /* C (MOVI_IMM_64_PCREL, MOVI_GOTPC) */
  { 0, 0, MOVI_64_LENGTH, 0 },
  EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,

#endif /* HAVE_SH64 */

d228 6
a233 5
/* Determinet whether the symbol needs any kind of PIC relocation.  */

inline static int
sh_PIC_related_p (sym)
     symbolS *sym;
d235 5
a239 1
  expressionS *exp;
d241 6
a246 93
  if (! sym)
    return 0;

  if (sym == GOT_symbol)
    return 1;

#ifdef HAVE_SH64
  if (sh_PIC_related_p (*symbol_get_tc (sym)))
    return 1;
#endif

  exp = symbol_get_value_expression (sym);

  return (exp->X_op == O_PIC_reloc
	  || sh_PIC_related_p (exp->X_add_symbol)
	  || sh_PIC_related_p (exp->X_op_symbol));
}

/* Determine the relocation type to be used to represent the
   expression, that may be rearranged.  */

static int
sh_check_fixup (main_exp, r_type_p)
     expressionS *main_exp;
     bfd_reloc_code_real_type *r_type_p;
{
  expressionS *exp = main_exp;

  /* This is here for backward-compatibility only.  GCC used to generated:

	f@@PLT + . - (.LPCS# + 2)

     but we'd rather be able to handle this as a PIC-related reference
     plus/minus a symbol.  However, gas' parser gives us:

	O_subtract (O_add (f@@PLT, .), .LPCS#+2)

     so we attempt to transform this into:

        O_subtract (f@@PLT, O_subtract (.LPCS#+2, .))

     which we can handle simply below.  */
  if (exp->X_op == O_subtract)
    {
      if (sh_PIC_related_p (exp->X_op_symbol))
	return 1;

      exp = symbol_get_value_expression (exp->X_add_symbol);

      if (exp && sh_PIC_related_p (exp->X_op_symbol))
	return 1;

      if (exp && exp->X_op == O_add
	  && sh_PIC_related_p (exp->X_add_symbol))
	{
	  symbolS *sym = exp->X_add_symbol;

	  exp->X_op = O_subtract;
	  exp->X_add_symbol = main_exp->X_op_symbol;

	  main_exp->X_op_symbol = main_exp->X_add_symbol;
	  main_exp->X_add_symbol = sym;

	  main_exp->X_add_number += exp->X_add_number;
	  exp->X_add_number = 0;
	}

      exp = main_exp;
    }
  else if (exp->X_op == O_add && sh_PIC_related_p (exp->X_op_symbol))
    return 1;

  if (exp->X_op == O_symbol || exp->X_op == O_add || exp->X_op == O_subtract)
    {
#ifdef HAVE_SH64
      if (exp->X_add_symbol
	  && (exp->X_add_symbol == GOT_symbol
	      || (GOT_symbol
		  && *symbol_get_tc (exp->X_add_symbol) == GOT_symbol)))
	{
	  switch (*r_type_p)
	    {
	    case BFD_RELOC_SH_IMM_LOW16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_LOW16;
	      break;

	    case BFD_RELOC_SH_IMM_MEDLOW16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_MEDLOW16;
	      break;

	    case BFD_RELOC_SH_IMM_MEDHI16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_MEDHI16;
	      break;
d248 1
a248 3
	    case BFD_RELOC_SH_IMM_HI16:
	      *r_type_p = BFD_RELOC_SH_GOTPC_HI16;
	      break;
d250 6
a255 4
	    case BFD_RELOC_NONE:
	    case BFD_RELOC_UNUSED:
	      *r_type_p = BFD_RELOC_SH_GOTPC;
	      break;
d257 2
a258 16
	    default:
	      abort ();
	    }
	  return 0;
	}
#else
      if (exp->X_add_symbol && exp->X_add_symbol == GOT_symbol)
	{
	  *r_type_p = BFD_RELOC_SH_GOTPC;
	  return 0;
	}
#endif
      exp = symbol_get_value_expression (exp->X_add_symbol);
      if (! exp)
	return 0;
    }
d260 4
a263 1
  if (exp->X_op == O_PIC_reloc)
d265 1
a265 117
#ifdef HAVE_SH64
      switch (*r_type_p)
	{
	case BFD_RELOC_NONE:
	case BFD_RELOC_UNUSED:
	  *r_type_p = exp->X_md;
	  break;

	case BFD_RELOC_SH_IMM_LOW16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_LOW16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_LOW16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_LOW16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_LOW16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case BFD_RELOC_SH_IMM_MEDLOW16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_MEDLOW16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_MEDLOW16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_MEDLOW16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_MEDLOW16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case BFD_RELOC_SH_IMM_MEDHI16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_MEDHI16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_MEDHI16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_MEDHI16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_MEDHI16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case BFD_RELOC_SH_IMM_HI16:
	  switch (exp->X_md)
	    {
	    case BFD_RELOC_32_GOTOFF:
	      *r_type_p = BFD_RELOC_SH_GOTOFF_HI16;
	      break;

	    case BFD_RELOC_SH_GOTPLT32:
	      *r_type_p = BFD_RELOC_SH_GOTPLT_HI16;
	      break;

	    case BFD_RELOC_32_GOT_PCREL:
	      *r_type_p = BFD_RELOC_SH_GOT_HI16;
	      break;

	    case BFD_RELOC_32_PLT_PCREL:
	      *r_type_p = BFD_RELOC_SH_PLT_HI16;
	      break;

	    default:
	      abort ();
	    }
	  break;

	default:
	  abort ();
	}
#else
      *r_type_p = exp->X_md;
#endif
      if (exp == main_exp)
	exp->X_op = O_symbol;
      else
	{
	  main_exp->X_add_symbol = exp->X_add_symbol;
	  main_exp->X_add_number += exp->X_add_number;
	}
a266 8
  else
    return (sh_PIC_related_p (exp->X_add_symbol)
	    || sh_PIC_related_p (exp->X_op_symbol));

  return 0;
}

/* Add expression EXP of SIZE bytes to offset OFF of fragment FRAG.  */
d268 2
a269 7
void
sh_cons_fix_new (frag, off, size, exp)
     fragS *frag;
     int off, size;
     expressionS *exp;
{
  bfd_reloc_code_real_type r_type = BFD_RELOC_UNUSED;
d271 5
a275 5
  if (sh_check_fixup (exp, &r_type))
    as_bad (_("Invalid PIC expression."));

  if (r_type == BFD_RELOC_UNUSED)
    switch (size)
d277 4
a280 3
      case 1:
	r_type = BFD_RELOC_8;
	break;
d282 9
a290 3
      case 2:
	r_type = BFD_RELOC_16;
	break;
d292 3
a294 9
      case 4:
	r_type = BFD_RELOC_32;
	break;

#ifdef HAVE_SH64
      case 8:
	r_type = BFD_RELOC_64;
	break;
#endif
d296 2
a297 2
      default:
	goto error;
a298 6
  else if (size != 4)
    {
    error:
      as_bad (_("unsupported BFD relocation size %u"), size);
      r_type = BFD_RELOC_UNUSED;
    }
d300 1
a300 1
  fix_new_exp (frag, off, size, exp, 0, r_type);
d311 3
a313 11
  expressionS exp;

#ifdef HAVE_SH64

  /* Update existing range to include a previous insn, if there was one.  */
  sh64_update_contents_mark (TRUE);

  /* We need to make sure the contents type is set to data.  */
  sh64_flag_output ();

#endif /* HAVE_SH64 */
d324 73
a396 1
      emit_expr (&exp, (unsigned int) nbytes);
d417 1
a417 1
  const sh_opcode_info *opcode;
d421 9
a429 2
  target_arch
    = preset_target_arch ? preset_target_arch : arch_sh1_up & ~arch_sh_dsp_up;
a431 4
#ifdef HAVE_SH64
  shmedia_md_begin ();
#endif

d437 1
a437 1
      if (strcmp (prev_name, opcode->name) != 0)
d444 6
d459 9
a467 1
#define IDENT_CHAR(c) (ISALNUM (c) || (c) == '_')
d477 2
a478 2
  char l0 = TOLOWER (src[0]);
  char l1 = l0 ? TOLOWER (src[1]) : 0;
d533 1
a533 1
	  if (TOLOWER (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d548 1
a548 1
	  if (TOLOWER (src[2]) == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
d581 1
a581 1
  if (l0 == 'i' && l1 && ! IDENT_CHAR ((unsigned char) src[2]))
d629 1
a629 1
      && TOLOWER (src[2]) == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
d635 1
a635 1
  if (l0 == 's' && l1 == 'p' && TOLOWER (src[2]) == 'c'
d642 1
a642 1
  if (l0 == 's' && l1 == 'g' && TOLOWER (src[2]) == 'r'
d649 1
a649 1
  if (l0 == 'd' && l1 == 's' && TOLOWER (src[2]) == 'r'
d656 1
a656 1
  if (l0 == 'd' && l1 == 'b' && TOLOWER (src[2]) == 'r'
d688 1
a688 1
  if (l0 == 'g' && l1 == 'b' && TOLOWER (src[2]) == 'r'
d694 1
a694 1
  if (l0 == 'v' && l1 == 'b' && TOLOWER (src[2]) == 'r'
d701 1
a701 1
  if (l0 == 'm' && l1 == 'a' && TOLOWER (src[2]) == 'c'
d704 1
a704 1
      if (TOLOWER (src[3]) == 'l')
d709 1
a709 1
      if (TOLOWER (src[3]) == 'h')
d715 2
a716 2
  if (l0 == 'm' && l1 == 'o' && TOLOWER (src[2]) == 'd'
      && ! IDENT_CHAR ((unsigned char) src[3]))
d797 2
a798 2
  if (l0 == 'f' && l1 == 'p' && TOLOWER (src[2]) == 'u'
      && TOLOWER (src[3]) == 'l'
d805 3
a807 3
  if (l0 == 'f' && l1 == 'p' && TOLOWER (src[2]) == 's'
      && TOLOWER (src[3]) == 'c'
      && TOLOWER (src[4]) == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
d813 3
a815 3
  if (l0 == 'x' && l1 == 'm' && TOLOWER (src[2]) == 't'
      && TOLOWER (src[3]) == 'r'
      && TOLOWER (src[4]) == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
d824 14
a850 6
#ifdef OBJ_ELF
  else if (op->immediate.X_op == O_PIC_reloc
	   || sh_PIC_related_p (op->immediate.X_add_symbol)
	   || sh_PIC_related_p (op->immediate.X_op_symbol))
    as_bad (_("misplaced PIC operand"));
#endif
d898 1
a898 1
         @@(r0, rn).  */
d909 4
d914 1
a914 3
	      src++;
	      /* Now can be rn or gbr.  */
	      len = parse_reg (src, &mode, &(op->reg));
d916 1
a916 5
	  else
	    {
	      len = 0;
	    }
	  if (len)
d918 1
a918 12
	      if (mode == A_GBR)
		{
		  op->type = A_R0_GBR;
		}
	      else if (mode == A_REG_N)
		{
		  op->type = A_IND_R0_REG_N;
		}
	      else
		{
		  as_bad (_("syntax error in @@(r0,...)"));
		}
d922 1
a922 1
	      as_bad (_("syntax error in @@(r0...)"));
d927 1
a927 1
	  /* Must be an @@(disp,.. thing).  */
d931 1
a931 1
	  /* Now can be rn, gbr or pc.  */
d945 2
a946 16
		  /* We want @@(expr, pc) to uniformly address . + expr,
		     no matter if expr is a constant, or a more complex
		     expression, e.g. sym-. or sym1-sym2.
		     However, we also used to accept @@(sym,pc)
		     as adressing sym, i.e. meaning the same as plain sym.
		     Some existing code does use the @@(sym,pc) syntax, so
		     we give it the old semantics for now, but warn about
		     its use, so that users have some time to fix their code.

		     Note that due to this backward compatibility hack,
		     we'll get unexpected results when @@(offset, pc) is used,
		     and offset is a symbol that is set later to an an address
		     difference, or an external symbol that is set to an
		     address difference in another source file, so we want to
		     eventually remove it.  */
		  if (op->immediate.X_op == O_symbol)
d948 2
a949 9
		      op->type = A_DISP_PC;
		      as_warn (_("Deprecated syntax."));
		    }
		  else
		    {
		      op->type = A_DISP_PC_ABS;
		      /* Such operands don't get corrected for PC==.+4, so
			 make the correction here.  */
		      op->immediate.X_add_number -= 4;
d951 1
d973 3
a975 2
	as_bad (_("illegal register after @@"));

a977 2
	  char l0, l1;

d979 2
a980 5
	  l0 = TOLOWER (src[0]);
	  l1 = TOLOWER (src[1]);

	  if ((l0 == 'r' && l1 == '8')
	      || (l0 == 'i' && (l1 == 'x' || l1 == 's')))
d985 2
a986 2
	  else if (   (l0 == 'r' && l1 == '9')
		   || (l0 == 'i' && l1 == 'y'))
d995 3
a997 1
	op->type = A_IND_N;
d1113 1
a1113 1
      if ((this_try->name != name) && (strcmp (this_try->name, name) != 0))
a1130 4
	    case A_DISP_PC:
	      if (user->type == A_DISP_PC_ABS)
		break;
	      /* Fall through.  */
d1135 1
d1384 15
d1504 1
d1581 1
a1581 2
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY4,
		      operand->type != A_DISP_PC_ABS, operand);
d1584 1
a1584 2
	      insert (output, BFD_RELOC_SH_PCRELIMM8BY2,
		      operand->type != A_DISP_PC_ABS, operand);
d1641 1
a1641 1
	 be capitalized.  Instead of hacking up the machine independent
d1643 1
a1643 1
      c = TOLOWER (c);
d1673 5
a1681 6
      /* Some insn ignore one or more register fields, e.g. psts machl,a0.
	 Make sure we encode a defined insn pattern.  */
      reg_x = 0;
      reg_y = 0;
      reg_n = 0;

a1808 9
		/* Generate warning if the destination register for padd / psub
		   and pmuls is the same ( only for A0 or A1 ).
		   If the last nibble is 1010 then A0 is used in both
		   padd / psub and pmuls. If it is 1111 then A1 is used
		   as destination register in both padd / psub and pmuls.  */

		if ((((field_b | reg_efg) & 0x000F) == 0x000A)
		    || (((field_b | reg_efg) & 0x000F) == 0x000F))
		  as_warn (_("destination register is same for parallel insns"));
a1883 20
#ifdef HAVE_SH64
  if (sh64_isa_mode == sh64_isa_shmedia)
    {
      shmedia_md_assemble (str);
      return;
    }
  else
    {
      /* If we've seen pseudo-directives, make sure any emitted data or
	 frags are marked as data.  */
      if (!seen_insn)
	{
	  sh64_update_contents_mark (TRUE);
	  sh64_set_contents_type (CRT_SH5_ISA16);
	}

      seen_insn = TRUE;
    }
#endif /* HAVE_SH64 */

d1997 1
a1997 1
     char *name ATTRIBUTE_UNUSED;
d1999 18
d2025 1
a2025 1
     object_headers *headers ATTRIBUTE_UNUSED;
d2032 1
a2032 1
     object_headers *headers ATTRIBUTE_UNUSED;
d2129 1
a2129 1
const char *md_shortopts = "";
d2133 1
a2133 2
#define OPTION_BIG (OPTION_MD_BASE + 1)
#define OPTION_LITTLE (OPTION_BIG + 1)
a2135 1
#define OPTION_ISA                    (OPTION_DSP + 1)
a2137 1
  {"big", no_argument, NULL, OPTION_BIG},
a2140 14
  {"isa",                    required_argument, NULL, OPTION_ISA},
#ifdef HAVE_SH64
#define OPTION_ABI                    (OPTION_ISA + 1)
#define OPTION_NO_MIX                 (OPTION_ABI + 1)
#define OPTION_SHCOMPACT_CONST_CRANGE (OPTION_NO_MIX + 1)
#define OPTION_NO_EXPAND              (OPTION_SHCOMPACT_CONST_CRANGE + 1)
#define OPTION_PT32                   (OPTION_NO_EXPAND + 1)
  {"abi",                    required_argument, NULL, OPTION_ABI},
  {"no-mix",                 no_argument, NULL, OPTION_NO_MIX},
  {"shcompact-const-crange", no_argument, NULL, OPTION_SHCOMPACT_CONST_CRANGE},
  {"no-expand",              no_argument, NULL, OPTION_NO_EXPAND},
  {"expand-pt32",            no_argument, NULL, OPTION_PT32},
#endif /* HAVE_SH64 */

a2155 4
    case OPTION_BIG:
      target_big_endian = 1;
      break;

d2157 1
d2166 1
a2166 54
      preset_target_arch = arch_sh1_up & ~arch_sh3e_up;
      break;

    case OPTION_ISA:
      if (strcasecmp (arg, "sh4") == 0)
	preset_target_arch = arch_sh4;
      else if (strcasecmp (arg, "any") == 0)
	preset_target_arch = arch_sh1_up;
#ifdef HAVE_SH64
      else if (strcasecmp (arg, "shmedia") == 0)
	{
	  if (sh64_isa_mode == sh64_isa_shcompact)
	    as_bad (_("Invalid combination: --isa=SHcompact with --isa=SHmedia"));
	  sh64_isa_mode = sh64_isa_shmedia;
	}
      else if (strcasecmp (arg, "shcompact") == 0)
	{
	  if (sh64_isa_mode == sh64_isa_shmedia)
	    as_bad (_("Invalid combination: --isa=SHmedia with --isa=SHcompact"));
	  if (sh64_abi == sh64_abi_64)
	    as_bad (_("Invalid combination: --abi=64 with --isa=SHcompact"));
	  sh64_isa_mode = sh64_isa_shcompact;
	}
#endif /* HAVE_SH64 */
      else
	as_bad ("Invalid argument to --isa option: %s", arg);
      break;

#ifdef HAVE_SH64
    case OPTION_ABI:
      if (strcmp (arg, "32") == 0)
	{
	  if (sh64_abi == sh64_abi_64)
	    as_bad (_("Invalid combination: --abi=32 with --abi=64"));
	  sh64_abi = sh64_abi_32;
	}
      else if (strcmp (arg, "64") == 0)
	{
	  if (sh64_abi == sh64_abi_32)
	    as_bad (_("Invalid combination: --abi=64 with --abi=32"));
	  if (sh64_isa_mode == sh64_isa_shcompact)
	    as_bad (_("Invalid combination: --isa=SHcompact with --abi=64"));
	  sh64_abi = sh64_abi_64;
	}
      else
	as_bad ("Invalid argument to --abi option: %s", arg);
      break;

    case OPTION_NO_MIX:
      sh64_mix = FALSE;
      break;

    case OPTION_SHCOMPACT_CONST_CRANGE:
      sh64_shcompact_const_crange = TRUE;
a2168 9
    case OPTION_NO_EXPAND:
      sh64_expand = FALSE;
      break;

    case OPTION_PT32:
      sh64_pt32 = TRUE;
      break;
#endif /* HAVE_SH64 */

a2182 1
-big			generate big endian code\n\
d2185 1
a2185 17
-dsp			enable sh-dsp insns, and disable sh2e/sh3e/sh4 insns.\n"));
#ifdef HAVE_SH64
  fprintf (stream, _("\
-isa=[shmedia		set default instruction set for SH64\n\
      | SHmedia\n\
      | shcompact\n\
      | SHcompact]\n\
-abi=[32|64]		set size of expanded SHmedia operands and object\n\
			file type\n\
-shcompact-const-crange	emit code-range descriptors for constants in\n\
			SHcompact code sections\n\
-no-mix			disallow SHmedia code in the same section as\n\
			constants and SHcompact code\n\
-no-expand		do not expand MOVI, PT, PTA or PTB instructions\n\
-expand-pt32		with -abi=64, expand PT, PTA and PTB instructions\n\
			to 32 bits only"));
#endif /* HAVE_SH64 */
d2188 7
d2343 2
a2344 2
      fix_new (fscan->fx_frag,
	       S_GET_VALUE (sym) - fscan->fx_frag->fr_address,
a2361 4
#ifdef HAVE_SH64
  shmedia_frob_file_before_adjust ();
#endif

d2378 1
a2378 1
   create relocs so that md_apply_fix3 will fill in the correct values.  */
d2385 1
a2385 1
     object_headers *headers ATTRIBUTE_UNUSED;
d2453 1
a2453 1
	/* If this is a delayed branch, we may not put the bra in the
a2514 3
#ifdef HAVE_SH64
      shmedia_md_convert_frag (headers, seg, fragP, TRUE);
#else
a2515 1
#endif
d2656 4
a2659 1
/* See whether the relocation should be resolved locally.  */
d2661 19
a2679 13
static bfd_boolean
sh_local_pcrel (fix)
     fixS *fix;
{
  return (! sh_relax
	  && (fix->fx_r_type == BFD_RELOC_SH_PCDISP8BY2
	      || fix->fx_r_type == BFD_RELOC_SH_PCDISP12BY2
	      || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY2
	      || fix->fx_r_type == BFD_RELOC_SH_PCRELIMM8BY4
	      || fix->fx_r_type == BFD_RELOC_8_PCREL
	      || fix->fx_r_type == BFD_RELOC_SH_SWITCH16
	      || fix->fx_r_type == BFD_RELOC_SH_SWITCH32));
}
a2688 4
  /* These relocations can't make it into a DSO, so no use forcing
     them for global symbols.  */
  if (sh_local_pcrel (fix))
    return 0;
d2690 4
a2693 9
  /* Make sure some relocations get emitted.  */
  if (fix->fx_r_type == BFD_RELOC_SH_LOOP_START
      || fix->fx_r_type == BFD_RELOC_SH_LOOP_END
      || fix->fx_r_type == BFD_RELOC_SH_TLS_GD_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_LD_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_IE_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_LDO_32
      || fix->fx_r_type == BFD_RELOC_SH_TLS_LE_32
      || generic_force_reloc (fix))
a2704 3
#ifdef HAVE_SH64
	  || fix->fx_r_type == BFD_RELOC_SH_SHMEDIA_CODE
#endif
d2709 1
a2709 1
bfd_boolean
d2713 15
a2727 3
  if (fixP->fx_r_type == BFD_RELOC_32_PLT_PCREL
      || fixP->fx_r_type == BFD_RELOC_32_GOT_PCREL
      || fixP->fx_r_type == BFD_RELOC_SH_GOTPC
a2745 7
#ifdef HAVE_SH64
  /* SH5 and above don't know about the valid_arch arch_sh* bits defined
     in sh-opc.h, so check SH64 mode before checking valid_arch.  */
  if (sh64_isa_mode != sh64_isa_unspecified)
    val = EF_SH5;
  else
#endif /* HAVE_SH64 */
a2749 2
  else if (valid_arch & arch_sh2e)
    val = EF_SH2E;
d2770 6
d2777 4
a2780 4
md_apply_fix3 (fixP, valP, seg)
     fixS * fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d2785 3
a2787 1
  long val = (long) *valP;
d2813 1
a2813 1
	  return;
d2817 1
a2817 1
	  return;
d2839 1
a2839 4
#ifdef BFD_ASSEMBLER
  if (SWITCH_TABLE (fixP))
    val -= S_GET_VALUE  (fixP->fx_subsy);
#else
d2967 3
d2971 1
d2977 1
a2977 6
      * valP = 0xfffffffc;
      val = fixP->fx_offset;
      if (fixP->fx_subsy)
	val -= S_GET_VALUE (fixP->fx_subsy);
      fixP->fx_addnumber = val;
      md_number_to_chars (buf, val, 4);
d2997 1
a2997 1
      * valP -= 1;
a3000 5
    case BFD_RELOC_SH_TLS_GD_32:
    case BFD_RELOC_SH_TLS_LD_32:
    case BFD_RELOC_SH_TLS_IE_32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* Fallthrough */
d3002 1
a3002 2
    case BFD_RELOC_SH_GOTPLT32:
      * valP = 0; /* Fully resolved at runtime.  No addend.  */
a3005 4
    case BFD_RELOC_SH_TLS_LDO_32:
    case BFD_RELOC_SH_TLS_LE_32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* Fallthrough */
a3006 1
      md_number_to_chars (buf, val, 4);
a3010 4
#ifdef HAVE_SH64
      shmedia_md_apply_fix3 (fixP, valP);
      return;
#else
a3011 1
#endif
d3027 3
a3029 2
  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
a3044 3
#ifdef HAVE_SH64
      return shmedia_md_estimate_size_before_relax (fragP, segment_type);
#else
a3045 2
#endif

a3113 5
#ifdef HAVE_SH64
  /* We might need to set the contents type to data.  */
  sh64_flag_output ();
#endif

a3119 3
/* This version is used in obj-coff.c when not using BFD_ASSEMBLER.
   eg for the sh-hms target.  */

a3126 20
long
md_pcrel_from_section (fixP, sec)
     fixS *fixP;
     segT sec;
{
  if (! sh_local_pcrel (fixP)
      && fixP->fx_addsy != (symbolS *) NULL
      && (generic_force_reloc (fixP)
	  || S_GET_SEGMENT (fixP->fx_addsy) != sec))
    {
      /* The symbol is undefined (or is defined but not in this section,
	 or we're not sure about it being the final definition).  Let the
	 linker figure it out.  We need to adjust the subtraction of a
	 symbol to the position of the relocated data, though.  */
      return fixP->fx_subsy ? fixP->fx_where + fixP->fx_frag->fr_address : 0;
    }

  return md_pcrel_from (fixP);
}

d3246 1
a3246 1
	 The fx_addnumber field was set in md_apply_fix3.  */
d3311 1
a3311 2
      *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_subsy);
      rel->addend = 0;
a3337 4
#ifdef HAVE_SH64
  else if (shmedia_init_reloc (rel, fixp))
    ;
#endif
a3345 2
  if (rel->howto->type == R_SH_IND12W)
      rel->addend += fixp->fx_offset - 4;
a3358 95
#ifdef OBJ_ELF
inline static char *
sh_end_of_match (cont, what)
     char *cont, *what;
{
  int len = strlen (what);

  if (strncasecmp (cont, what, strlen (what)) == 0
      && ! is_part_of_name (cont[len]))
    return cont + len;

  return NULL;
}

int
sh_parse_name (name, exprP, nextcharP)
     char const *name;
     expressionS *exprP;
     char *nextcharP;
{
  char *next = input_line_pointer;
  char *next_end;
  int reloc_type;
  segT segment;

  exprP->X_op_symbol = NULL;

  if (strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
    {
      if (! GOT_symbol)
	GOT_symbol = symbol_find_or_make (name);

      exprP->X_add_symbol = GOT_symbol;
    no_suffix:
      /* If we have an absolute symbol or a reg, then we know its
	     value now.  */
      segment = S_GET_SEGMENT (exprP->X_add_symbol);
      if (segment == absolute_section)
	{
	  exprP->X_op = O_constant;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else if (segment == reg_section)
	{
	  exprP->X_op = O_register;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else
	{
	  exprP->X_op = O_symbol;
	  exprP->X_add_number = 0;
	}

      return 1;
    }

  exprP->X_add_symbol = symbol_find_or_make (name);

  if (*nextcharP != '@@')
    goto no_suffix;
  else if ((next_end = sh_end_of_match (next + 1, "GOTOFF")))
    reloc_type = BFD_RELOC_32_GOTOFF;
  else if ((next_end = sh_end_of_match (next + 1, "GOTPLT")))
    reloc_type = BFD_RELOC_SH_GOTPLT32;
  else if ((next_end = sh_end_of_match (next + 1, "GOT")))
    reloc_type = BFD_RELOC_32_GOT_PCREL;
  else if ((next_end = sh_end_of_match (next + 1, "PLT")))
    reloc_type = BFD_RELOC_32_PLT_PCREL;
  else if ((next_end = sh_end_of_match (next + 1, "TLSGD")))
    reloc_type = BFD_RELOC_SH_TLS_GD_32;
  else if ((next_end = sh_end_of_match (next + 1, "TLSLDM")))
    reloc_type = BFD_RELOC_SH_TLS_LD_32;
  else if ((next_end = sh_end_of_match (next + 1, "GOTTPOFF")))
    reloc_type = BFD_RELOC_SH_TLS_IE_32;
  else if ((next_end = sh_end_of_match (next + 1, "TPOFF")))
    reloc_type = BFD_RELOC_SH_TLS_LE_32;
  else if ((next_end = sh_end_of_match (next + 1, "DTPOFF")))
    reloc_type = BFD_RELOC_SH_TLS_LDO_32;
  else
    goto no_suffix;

  *input_line_pointer = *nextcharP;
  input_line_pointer = next_end;
  *nextcharP = *input_line_pointer;
  *input_line_pointer = '\0';

  exprP->X_op = O_PIC_reloc;
  exprP->X_add_number = 0;
  exprP->X_md = reloc_type;

  return 1;
}
#endif
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004  Free Software Foundation, Inc.
a37 1
#include "dw2gencfi.h"
d51 24
a74 2
static void s_uses (int);
static void s_uacons (int);
d77 5
a81 1
static void sh_elf_cons (int);
d87 2
a88 1
big (int ignore ATTRIBUTE_UNUSED)
d98 2
a99 1
little (int ignore ATTRIBUTE_UNUSED)
d139 4
a165 4
/* Flag to generate relocations against symbol values for local symbols.  */

static int dont_adjust_reloc_32;

d171 1
a171 1
   accommodate the insns seen so far.  */
d186 1
a186 1
/* These are the three types of relaxable instruction.  */
d517 2
a518 1
sh_PIC_related_p (symbolS *sym)
d544 3
a546 1
sh_check_fixup (expressionS *main_exp, bfd_reloc_code_real_type *r_type_p)
d772 4
a775 1
sh_cons_fix_new (fragS *frag, int off, int size, expressionS *exp)
a819 1
/* NBYTES 1=.byte, 2=.word, 4=.long */
d821 2
a822 1
sh_elf_cons (register int nbytes)
a841 4
#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

d864 1
a864 1
md_begin (void)
d904 4
a907 1
parse_reg (char *src, int *mode, int *reg)
d1257 3
a1259 1
parse_exp (char *s, sh_operand_info *op)
d1300 3
a1302 1
parse_at (char *src, sh_operand_info *op)
d1386 1
a1386 1
		     as addressing sym, i.e. meaning the same as plain sym.
d1444 1
a1444 1
	      op->type = AX_PMOD_N;
d1450 1
a1450 1
	      op->type = AY_PMOD_N;
d1462 3
a1464 1
get_operand (char **ptr, sh_operand_info *op)
d1500 4
a1503 1
get_operands (sh_opcode_info *info, char *args, sh_operand_info *operand)
d1561 3
a1563 1
get_specific (sh_opcode_info *opcode, sh_operand_info *operands)
d1630 2
a1676 231
	    case AS_DEC_N:
	      if (user->type != A_DEC_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AS_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AS_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AS_PMOD_N:
	      if (user->type != AX_PMOD_N)
		goto fail;
	      if (user->reg < 2 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AX_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg < 4 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AX_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if (user->reg < 4 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AX_PMOD_N:
	      if (user->type != AX_PMOD_N)
		goto fail;
	      if (user->reg < 4 || user->reg > 5)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AXY_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if ((user->reg < 4 || user->reg > 5)
		  && (user->reg < 0 || user->reg > 1))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AXY_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if ((user->reg < 4 || user->reg > 5)
		  && (user->reg < 0 || user->reg > 1))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AXY_PMOD_N:
	      if (user->type != AX_PMOD_N)
		goto fail;
	      if ((user->reg < 4 || user->reg > 5)
		  && (user->reg < 0 || user->reg > 1))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AY_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if (user->reg < 6 || user->reg > 7)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AY_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if (user->reg < 6 || user->reg > 7)
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AY_PMOD_N:
	      if (user->type != AY_PMOD_N)
		goto fail;
	      if (user->reg < 6 || user->reg > 7)
		goto fail;
	      reg_n = user->reg;
	      break;

	    case AYX_INC_N:
	      if (user->type != A_INC_N)
		goto fail;
	      if ((user->reg < 6 || user->reg > 7)
		  && (user->reg < 2 || user->reg > 3))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AYX_IND_N:
	      if (user->type != A_IND_N)
		goto fail;
	      if ((user->reg < 6 || user->reg > 7)
		  && (user->reg < 2 || user->reg > 3))
		goto fail;
	      reg_n = user->reg;
	      break;
	      
	    case AYX_PMOD_N:
	      if (user->type != AY_PMOD_N)
		goto fail;
	      if ((user->reg < 6 || user->reg > 7)
		  && (user->reg < 2 || user->reg > 3))
		goto fail;
	      reg_n = user->reg;
	      break;

	    case DSP_REG_A_M:
	      if (user->type != DSP_REG_N)
		goto fail;
	      if (user->reg != A_A0_NUM
		  && user->reg != A_A1_NUM)
		goto fail;
	      reg_m = user->reg;
	      break;

	    case DSP_REG_AX:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_A0_NUM:
		  reg_x = 0;
		  break;
		case A_A1_NUM:
		  reg_x = 2;
		  break;
		case A_X0_NUM:
		  reg_x = 1;
		  break;
		case A_X1_NUM:
		  reg_x = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_XY:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_X0_NUM:
		  reg_x = 0;
		  break;
		case A_X1_NUM:
		  reg_x = 2;
		  break;
		case A_Y0_NUM:
		  reg_x = 1;
		  break;
		case A_Y1_NUM:
		  reg_x = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_AY:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_A0_NUM:
		  reg_y = 0;
		  break;
		case A_A1_NUM:
		  reg_y = 1;
		  break;
		case A_Y0_NUM:
		  reg_y = 2;
		  break;
		case A_Y1_NUM:
		  reg_y = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

	    case DSP_REG_YX:
	      if (user->type != DSP_REG_N)
		goto fail;
	      switch (user->reg)
		{
		case A_Y0_NUM:
		  reg_y = 0;
		  break;
		case A_Y1_NUM:
		  reg_y = 1;
		  break;
		case A_X0_NUM:
		  reg_y = 2;
		  break;
		case A_X1_NUM:
		  reg_y = 3;
		  break;
		default:
		  goto fail;
		}
	      break;

d1847 5
a1851 1
insert (char *where, int how, int pcrel, sh_operand_info *op)
d1862 3
a1864 1
build_relax (sh_opcode_info *opcode, sh_operand_info *op)
d1898 3
a1900 1
insert_loop_bounds (char *output, sh_operand_info *operand)
d1948 3
a1950 1
build_Mytes (sh_opcode_info *opcode, sh_operand_info *operand)
a1973 1
	    case REG_N_D:
a1989 3
	    case REG_N_B01:
	      nbuf[index] = reg_n | 0x01;
	      break;
d2061 2
a2062 1
find_cooked_opcode (char **str_p)
d2109 3
a2111 1
assemble_ppi (char *op_end, sh_opcode_info *opcode)
a2132 1
    try_another_opcode:
a2162 32
	case MOVX_NOPY:
	  if (movx)
	    as_bad (_("multiple movx specifications"));
	  if ((reg_n < 4 || reg_n > 5)
	      && (reg_n < 0 || reg_n > 1))
	    as_bad (_("invalid movx address register"));
	  if (movy && movy != DDT_BASE)
	    as_bad (_("insn cannot be combined with non-nopy"));
	  movx = ((((reg_n & 1) != 0) << 9)
		  + (((reg_n & 4) == 0) << 8)
		  + (reg_x << 6)
		  + (opcode->nibbles[2] << 4)
		  + opcode->nibbles[3]
		  + DDT_BASE);
	  break;

	case MOVY_NOPX:
	  if (movy)
	    as_bad (_("multiple movy specifications"));
	  if ((reg_n < 6 || reg_n > 7)
	      && (reg_n < 2 || reg_n > 3))
	    as_bad (_("invalid movy address register"));
	  if (movx && movx != DDT_BASE)
	    as_bad (_("insn cannot be combined with non-nopx"));
	  movy = ((((reg_n & 1) != 0) << 8)
		  + (((reg_n & 4) == 0) << 9)
		  + (reg_y << 6)
		  + (opcode->nibbles[2] << 4)
		  + opcode->nibbles[3]
		  + DDT_BASE);
	  break;

a2165 2
	  if (movy & 0x2ac)
	    as_bad (_("previous movy requires nopx"));
a2186 2
	  if (movx & 0x153)
	    as_bad (_("previous movx requires nopy"));
a2214 7
	case PPI3NC:
	  if (cond)
	    {
	      opcode++;
	      goto try_another_opcode;
	    }
	  /* Fall through.  */
a2219 13
	  switch (opcode->nibbles[4])
	    {
	    case HEX_0:
	    case HEX_XX00:
	    case HEX_00YY:
	      break;
	    case HEX_1:
	    case HEX_4:
	      field_b += opcode->nibbles[4] << 4;
	      break;
	    default:
	      abort ();
	    }
a2233 13
	  switch (opcode->nibbles[4])
	    {
	    case HEX_0:
	    case HEX_XX00:
	    case HEX_00YY:
	      break;
	    case HEX_1:
	    case HEX_4:
	      field_b += opcode->nibbles[4] << 4;
	      break;
	    default:
	      abort ();
	    }
d2238 1
a2238 10
	      if ((field_b & 0xef00) == 0xa100)
		field_b -= 0x8100;
	      /* pclr Dz pmuls Se,Sf,Dg */
	      else if ((field_b & 0xff00) == 0x8d00
		       && (valid_arch & arch_sh4al_dsp_up))
		{
		  valid_arch &= arch_sh4al_dsp_up;
		  field_b -= 0x8cf0;
		}
	      else
d2240 1
d2256 1
a2256 1
		  as_bad (_("bad combined pmuls output operand"));
d2334 2
a2335 1
md_assemble (char *str)
a2389 6
	  /* Since we skip get_specific here, we have to check & update
	     valid_arch now.  */
	  if (valid_arch & opcode->arch)
	    valid_arch &= opcode->arch;
	  else
	    as_bad (_("Delayed branches not available on SH1"));
d2437 1
a2437 1
sh_frob_label (void)
d2462 1
a2462 1
sh_flush_pending_output (void)
d2474 2
a2475 1
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
d2484 2
a2485 1
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
d2491 2
a2492 1
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
d2510 4
a2513 1
md_atof (int type, char *litP, int *sizeP)
d2567 2
a2568 1
s_uses (int ignore ATTRIBUTE_UNUSED)
a2597 1
#define OPTION_RENESAS (OPTION_ISA + 1)
a2604 2
  {"renesas", no_argument, NULL, OPTION_RENESAS},

d2606 1
a2606 1
#define OPTION_ABI                    (OPTION_RENESAS + 1)
d2623 3
a2625 1
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
d2646 1
a2646 5
      preset_target_arch = arch_sh1_up & ~arch_sh2e_up;
      break;

    case OPTION_RENESAS:
      dont_adjust_reloc_32 = 1;
a2651 6
      else if (strcasecmp (arg, "sh4a") == 0)
	preset_target_arch = arch_sh4a;
      else if (strcasecmp (arg, "dsp") == 0)
	preset_target_arch = arch_sh1_up & ~arch_sh2e_up;
      else if (strcasecmp (arg, "fp") == 0)
	preset_target_arch = arch_sh2e_up;
d2719 2
a2720 1
md_show_usage (FILE *stream)
a2726 2
-renesas		disable optimization with section symbol for\n\
			compatibility with Renesas assembler.\n\
d2728 1
a2728 1
-dsp			enable sh-dsp insns, and disable floating-point ISAs.\n"));
d2731 4
a2734 9
-isa=[sh4\n\
    | sh4a\n\
    | dsp		same as '-dsp'\n\
    | fp\n\
    | shmedia		set as the default instruction set for SH64\n\
    | SHmedia\n\
    | shcompact\n\
    | SHcompact\n"));
  fprintf (stream, _("\
d2743 1
a2743 8
			to 32 bits only\n"));
#else
  fprintf (stream, _("\
-isa=[sh4\n\
    | sh4a\n\
    | dsp		same as '-dsp'\n\
    | fp\n\
    | any]\n"));
d2763 4
a2766 1
sh_count_relocs (bfd *abfd ATTRIBUTE_UNUSED, segT sec, void *data)
d2792 4
a2795 2
sh_frob_section (bfd *abfd ATTRIBUTE_UNUSED, segT sec,
		 void *ignore ATTRIBUTE_UNUSED)
d2878 1
a2878 1
      bfd_map_over_sections (stdoutput, sh_count_relocs, &info);
d2884 1
a2884 1
	  sh_count_relocs ((bfd *) NULL, iscan, &info);
d2912 1
a2912 1
sh_frob_file (void)
d2922 1
a2922 1
  bfd_map_over_sections (stdoutput, sh_frob_section, NULL);
d2928 1
a2928 1
      sh_frob_section ((bfd *) NULL, iseg, NULL);
d2937 1
d2939 1
a2939 1
md_convert_frag (bfd *headers ATTRIBUTE_UNUSED, segT seg, fragS *fragP)
d2941 1
a2941 2
md_convert_frag (object_headers *headers ATTRIBUTE_UNUSED, segT seg,
		 fragS *fragP)
d2943 2
d3087 3
a3089 1
md_section_align (segT seg ATTRIBUTE_UNUSED, valueT size)
d3105 1
a3105 1
   the expression does not need to be aligned.  */
d3114 2
a3115 1
s_uacons (int bytes)
d3129 2
a3130 1
sh_cons_align (int nbytes)
d3170 2
a3171 1
sh_handle_align (fragS *frag)
d3219 2
a3220 1
sh_local_pcrel (fixS *fix)
d3237 2
a3238 1
sh_force_relocation (fixS *fix)
d3273 2
a3274 1
sh_fix_adjustable (fixS *fixP)
a3278 1
      || ((fixP->fx_r_type == BFD_RELOC_32) && dont_adjust_reloc_32)
d3291 1
a3291 1
sh_elf_final_processing (void)
d3296 1
a3296 1
     a processor with the sh-dsp / sh2e ISA to execute.  */
d3315 1
a3315 1
    val = EF_SH3_DSP;
a3317 2
  else if (valid_arch & arch_sh4_nofpu)
    val = EF_SH4_NOFPU;
a3319 6
  else if (valid_arch & arch_sh4a_nofpu)
    val = EF_SH4A_NOFPU;
  else if (valid_arch & arch_sh4a)
    val = EF_SH4A;
  else if (valid_arch & arch_sh4al_dsp)
    val = EF_SH4AL_DSP;
d3331 4
a3334 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
d3455 1
a3455 1
         is on a 4 byte boundary.  If this instruction is also on a 4
d3607 3
a3609 1
md_estimate_size_before_relax (fragS *fragP, segT segment_type)
d3685 4
a3688 1
md_number_to_chars (char *ptr, valueT use, int nbytes)
d3705 2
a3706 1
md_pcrel_from (fixS *fixP)
d3712 3
a3714 1
md_pcrel_from_section (fixS *fixP, segT sec)
d3734 2
a3735 1
tc_coff_sizemachdep (fragS *frag)
d3784 5
a3788 2
sh_coff_reloc_mangle (segment_info_type *seg, fixS *fix,
		      struct internal_reloc *intr, unsigned int paddr)
d3899 3
a3901 1
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
d3955 2
a3956 1

a3965 4
#ifdef OBJ_ELF
  else if (rel->howto->type == R_SH_IND12W)
    rel->addend += fixp->fx_offset - 4;
#endif
d3972 2
a3973 1
sh_end_of_match (char *cont, char *what)
d3985 4
a3988 1
sh_parse_name (char const *name, expressionS *exprP, char *nextcharP)
a4064 49

void
sh_cfi_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (15, 0);
}

int
sh_regname_to_dw2regnum (const char *regname)
{
  unsigned int regnum = -1;
  unsigned int i;
  const char *p;
  char *q;
  static struct { char *name; int dw2regnum; } regnames[] =
    {
      { "pr", 17 }, { "t", 18 }, { "gbr", 19 }, { "mach", 20 },
      { "macl", 21 }, { "fpul", 23 }
    };

  for (i = 0; i < ARRAY_SIZE (regnames); ++i)
    if (strcmp (regnames[i].name, regname) == 0)
      return regnames[i].dw2regnum;

  if (regname[0] == 'r')
    {
      p = regname + 1;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 16)
	return -1;
    }
  else if (regname[0] == 'f' && regname[1] == 'r')
    {
      p = regname + 2;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 16)
	return -1;
      regnum += 25;
    }
  else if (regname[0] == 'x' && regname[1] == 'd')
    {
      p = regname + 2;
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 8)
	return -1;
      regnum += 87;
    }
  return regnum;
}
@


