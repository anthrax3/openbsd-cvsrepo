head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.54
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.52
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.48
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.44
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.46
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.38
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.42
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.40
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.36
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.34
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.6.0.8
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	new-binutils:1.5.0.14
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2004.11.02.20.45.26;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.12.19.11.45;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	97.01.21.10.33.05;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.32;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.05.14;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.54;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.54;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.10;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.44.17;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.13;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.22.34;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.18;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.32.52;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.27;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.47;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* a.out object file format
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000,
   2001, 2002 Free Software Foundation, Inc.

This file is part of GAS, the GNU Assembler.

GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2,
or (at your option) any later version.

GAS is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */

#define OBJ_HEADER "obj-aout.h"

#include "as.h"
#ifdef BFD_ASSEMBLER
#undef NO_RELOC
#include "aout/aout64.h"
#endif
#include "obstack.h"

#ifndef BFD_ASSEMBLER
/* in: segT   out: N_TYPE bits */
const short seg_N_TYPE[] =
{
  N_ABS,
  N_TEXT,
  N_DATA,
  N_BSS,
  N_UNDF,			/* unknown */
  N_UNDF,			/* error */
  N_UNDF,			/* expression */
  N_UNDF,			/* debug */
  N_UNDF,			/* ntv */
  N_UNDF,			/* ptv */
  N_REGISTER,			/* register */
};

const segT N_TYPE_seg[N_TYPE + 2] =
{				/* N_TYPE == 0x1E = 32-2 */
  SEG_UNKNOWN,			/* N_UNDF == 0 */
  SEG_GOOF,
  SEG_ABSOLUTE,			/* N_ABS == 2 */
  SEG_GOOF,
  SEG_TEXT,			/* N_TEXT == 4 */
  SEG_GOOF,
  SEG_DATA,			/* N_DATA == 6 */
  SEG_GOOF,
  SEG_BSS,			/* N_BSS == 8 */
  SEG_GOOF,
  SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF,
  SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF,
  SEG_GOOF, SEG_GOOF, SEG_GOOF, SEG_GOOF,
  SEG_REGISTER,			/* dummy N_REGISTER for regs = 30 */
  SEG_GOOF,
};
#endif

static void obj_aout_line PARAMS ((int));
static void obj_aout_weak PARAMS ((int));
static void obj_aout_type PARAMS ((int));

const pseudo_typeS aout_pseudo_table[] =
{
  {"line", obj_aout_line, 0},	/* source code line number */
  {"ln", obj_aout_line, 0},	/* coff line number that we use anyway */

  {"weak", obj_aout_weak, 0},	/* mark symbol as weak.  */

  {"type", obj_aout_type, 0},

  /* coff debug pseudos (ignored) */
  {"def", s_ignore, 0},
  {"dim", s_ignore, 0},
  {"endef", s_ignore, 0},
  {"ident", s_ignore, 0},
  {"line", s_ignore, 0},
  {"ln", s_ignore, 0},
  {"scl", s_ignore, 0},
  {"size", s_ignore, 0},
  {"tag", s_ignore, 0},
  {"val", s_ignore, 0},
  {"version", s_ignore, 0},

  {"optim", s_ignore, 0},	/* For sun386i cc (?) */

  /* other stuff */
  {"ABORT", s_abort, 0},

  {NULL, NULL, 0}		/* end sentinel */
};				/* aout_pseudo_table */

#ifdef BFD_ASSEMBLER

void
obj_aout_frob_symbol (sym, punt)
     symbolS *sym;
     int *punt ATTRIBUTE_UNUSED;
{
  flagword flags;
  asection *sec;
  int desc, type, other;

  flags = symbol_get_bfdsym (sym)->flags;
  desc = aout_symbol (symbol_get_bfdsym (sym))->desc;
  type = aout_symbol (symbol_get_bfdsym (sym))->type;
  other = aout_symbol (symbol_get_bfdsym (sym))->other;
  sec = S_GET_SEGMENT (sym);

  /* Only frob simple symbols this way right now.  */
  if (! (type & ~ (N_TYPE | N_EXT)))
    {
      if (type == (N_UNDF | N_EXT)
	  && sec == &bfd_abs_section)
	{
	  sec = bfd_und_section_ptr;
	  S_SET_SEGMENT (sym, sec);
	}

      if ((type & N_TYPE) != N_INDR
	  && (type & N_TYPE) != N_SETA
	  && (type & N_TYPE) != N_SETT
	  && (type & N_TYPE) != N_SETD
	  && (type & N_TYPE) != N_SETB
	  && type != N_WARNING
	  && (sec == &bfd_abs_section
	      || sec == &bfd_und_section))
	return;
      if (flags & BSF_EXPORT)
	type |= N_EXT;

      switch (type & N_TYPE)
	{
	case N_SETA:
	case N_SETT:
	case N_SETD:
	case N_SETB:
	  /* Set the debugging flag for constructor symbols so that
	     BFD leaves them alone.  */
	  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;

	  /* You can't put a common symbol in a set.  The way a set
	     element works is that the symbol has a definition and a
	     name, and the linker adds the definition to the set of
	     that name.  That does not work for a common symbol,
	     because the linker can't tell which common symbol the
	     user means.  FIXME: Using as_bad here may be
	     inappropriate, since the user may want to force a
	     particular type without regard to the semantics of sets;
	     on the other hand, we certainly don't want anybody to be
	     mislead into thinking that their code will work.  */
	  if (S_IS_COMMON (sym))
	    as_bad (_("Attempt to put a common symbol into set %s"),
		    S_GET_NAME (sym));
	  /* Similarly, you can't put an undefined symbol in a set.  */
	  else if (! S_IS_DEFINED (sym))
	    as_bad (_("Attempt to put an undefined symbol into set %s"),
		    S_GET_NAME (sym));

	  break;
	case N_INDR:
	  /* Put indirect symbols in the indirect section.  */
	  S_SET_SEGMENT (sym, bfd_ind_section_ptr);
	  symbol_get_bfdsym (sym)->flags |= BSF_INDIRECT;
	  if (type & N_EXT)
	    {
	      symbol_get_bfdsym (sym)->flags |= BSF_EXPORT;
	      symbol_get_bfdsym (sym)->flags &=~ BSF_LOCAL;
	    }
	  break;
	case N_WARNING:
	  /* Mark warning symbols.  */
	  symbol_get_bfdsym (sym)->flags |= BSF_WARNING;
	  break;
	}
    }
  else
    {
      symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
    }

  aout_symbol (symbol_get_bfdsym (sym))->type = type;

  /* Double check weak symbols.  */
  if (S_IS_WEAK (sym))
    {
      if (S_IS_COMMON (sym))
	as_bad (_("Symbol `%s' can not be both weak and common"),
		S_GET_NAME (sym));
    }
}

void
obj_aout_frob_file_before_fix ()
{
  /* Relocation processing may require knowing the VMAs of the sections.
     Since writing to a section will cause the BFD back end to compute the
     VMAs, fake it out here....  */
  bfd_byte b = 0;
  bfd_boolean x = TRUE;
  if (bfd_section_size (stdoutput, text_section) != 0)
    {
      x = bfd_set_section_contents (stdoutput, text_section, &b, (file_ptr) 0,
				    (bfd_size_type) 1);
    }
  else if (bfd_section_size (stdoutput, data_section) != 0)
    {
      x = bfd_set_section_contents (stdoutput, data_section, &b, (file_ptr) 0,
				    (bfd_size_type) 1);
    }
  assert (x);
}

#else /* ! BFD_ASSEMBLER */

/* Relocation.  */

/*
 *		emit_relocations()
 *
 * Crawl along a fixS chain. Emit the segment's relocations.
 */
void
obj_emit_relocations (where, fixP, segment_address_in_file)
     char **where;
     fixS *fixP;		/* Fixup chain for this segment.  */
     relax_addressT segment_address_in_file;
{
  for (; fixP; fixP = fixP->fx_next)
    if (fixP->fx_done == 0)
      {
	symbolS *sym;

	sym = fixP->fx_addsy;
	while (sym->sy_value.X_op == O_symbol
	       && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
	  sym = sym->sy_value.X_add_symbol;
	fixP->fx_addsy = sym;

	if (! sym->sy_resolved && ! S_IS_DEFINED (sym))
	  {
	    char *file;
	    unsigned int line;

	    if (expr_symbol_where (sym, &file, &line))
	      as_bad_where (file, line, _("unresolved relocation"));
	    else
	      as_bad (_("bad relocation: symbol `%s' not in symbol table"),
		      S_GET_NAME (sym));
	  }

	tc_aout_fix_to_chars (*where, fixP, segment_address_in_file);
	*where += md_reloc_size;
      }
}

#ifndef obj_header_append
/* Aout file generation & utilities */
void
obj_header_append (where, headers)
     char **where;
     object_headers *headers;
{
  tc_headers_hook (headers);

#ifdef CROSS_COMPILE
  md_number_to_chars (*where, headers->header.a_info, sizeof (headers->header.a_info));
  *where += sizeof (headers->header.a_info);
  md_number_to_chars (*where, headers->header.a_text, sizeof (headers->header.a_text));
  *where += sizeof (headers->header.a_text);
  md_number_to_chars (*where, headers->header.a_data, sizeof (headers->header.a_data));
  *where += sizeof (headers->header.a_data);
  md_number_to_chars (*where, headers->header.a_bss, sizeof (headers->header.a_bss));
  *where += sizeof (headers->header.a_bss);
  md_number_to_chars (*where, headers->header.a_syms, sizeof (headers->header.a_syms));
  *where += sizeof (headers->header.a_syms);
  md_number_to_chars (*where, headers->header.a_entry, sizeof (headers->header.a_entry));
  *where += sizeof (headers->header.a_entry);
  md_number_to_chars (*where, headers->header.a_trsize, sizeof (headers->header.a_trsize));
  *where += sizeof (headers->header.a_trsize);
  md_number_to_chars (*where, headers->header.a_drsize, sizeof (headers->header.a_drsize));
  *where += sizeof (headers->header.a_drsize);

#else /* CROSS_COMPILE */

  append (where, (char *) &headers->header, sizeof (headers->header));
#endif /* CROSS_COMPILE */

}
#endif /* ! defined (obj_header_append) */

void
obj_symbol_to_chars (where, symbolP)
     char **where;
     symbolS *symbolP;
{
  md_number_to_chars ((char *) &(S_GET_OFFSET (symbolP)), S_GET_OFFSET (symbolP), sizeof (S_GET_OFFSET (symbolP)));
  md_number_to_chars ((char *) &(S_GET_DESC (symbolP)), S_GET_DESC (symbolP), sizeof (S_GET_DESC (symbolP)));
  md_number_to_chars ((char *) &(symbolP->sy_symbol.n_value), S_GET_VALUE (symbolP), sizeof (symbolP->sy_symbol.n_value));

  append (where, (char *) &symbolP->sy_symbol, sizeof (obj_symbol_type));
}

void
obj_emit_symbols (where, symbol_rootP)
     char **where;
     symbolS *symbol_rootP;
{
  symbolS *symbolP;

  /* Emit all symbols left in the symbol chain.  */
  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      /* Used to save the offset of the name. It is used to point
	 to the string in memory but must be a file offset.  */
      register char *temp;

      temp = S_GET_NAME (symbolP);
      S_SET_OFFSET (symbolP, symbolP->sy_name_offset);

      /* Any symbol still undefined and is not a dbg symbol is made N_EXT.  */
      if (!S_IS_DEBUG (symbolP) && !S_IS_DEFINED (symbolP))
	S_SET_EXTERNAL (symbolP);

      /* Adjust the type of a weak symbol.  */
      if (S_GET_WEAK (symbolP))
	{
	  switch (S_GET_TYPE (symbolP))
	    {
	    case N_UNDF: S_SET_TYPE (symbolP, N_WEAKU); break;
	    case N_ABS:	 S_SET_TYPE (symbolP, N_WEAKA); break;
	    case N_TEXT: S_SET_TYPE (symbolP, N_WEAKT); break;
	    case N_DATA: S_SET_TYPE (symbolP, N_WEAKD); break;
	    case N_BSS:  S_SET_TYPE (symbolP, N_WEAKB); break;
	    default: as_bad (_("%s: bad type for weak symbol"), temp); break;
	    }
	}

      obj_symbol_to_chars (where, symbolP);
      S_SET_NAME (symbolP, temp);
    }
}

#endif /* ! BFD_ASSEMBLER */

static void
obj_aout_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* Assume delimiter is part of expression.
     BSD4.2 as fails with delightful bug, so we
     are not being incompatible here.  */
  new_logical_line ((char *) NULL, (int) (get_absolute_expression ()));
  demand_empty_rest_of_line ();
}				/* obj_aout_line() */

/* Handle .weak.  This is a GNU extension.  */

static void
obj_aout_weak (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  int c;
  symbolS *symbolP;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();
      S_SET_WEAK (symbolP);
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');
  demand_empty_rest_of_line ();
}

/* Handle .type.  On {Net,Open}BSD, this is used to set the n_other field,
   which is then apparently used when doing dynamic linking.  Older
   versions of gas ignored the .type pseudo-op, so we also ignore it if
   we can't parse it.  */

static void
obj_aout_type (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  int c;
  symbolS *sym;

  name = input_line_pointer;
  c = get_symbol_end ();
  sym = symbol_find_or_make (name);
  *input_line_pointer = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (*input_line_pointer == '@@')
	{
	  ++input_line_pointer;
	  if (strncmp (input_line_pointer, "object", 6) == 0)
#ifdef BFD_ASSEMBLER
	    aout_symbol (symbol_get_bfdsym (sym))->other = 1;
#else
	  S_SET_OTHER (sym, 1);
#endif
	  else if (strncmp (input_line_pointer, "function", 8) == 0)
#ifdef BFD_ASSEMBLER
	    aout_symbol (symbol_get_bfdsym (sym))->other = 2;
#else
	  S_SET_OTHER (sym, 2);
#endif
	}
    }

  /* Ignore everything else on the line.  */
  s_ignore (0);
}

#ifndef BFD_ASSEMBLER

void
obj_crawl_symbol_chain (headers)
     object_headers *headers;
{
  symbolS *symbolP;
  symbolS **symbolPP;
  int symbol_number = 0;

  tc_crawl_symbol_chain (headers);

  symbolPP = &symbol_rootP;	/*->last symbol chain link.  */
  while ((symbolP = *symbolPP) != NULL)
    {
      if (symbolP->sy_mri_common)
	{
	  if (S_IS_EXTERNAL (symbolP))
	    as_bad (_("%s: global symbols not supported in common sections"),
		    S_GET_NAME (symbolP));
	  *symbolPP = symbol_next (symbolP);
	  continue;
	}

      if (flag_readonly_data_in_text && (S_GET_SEGMENT (symbolP) == SEG_DATA))
	{
	  S_SET_SEGMENT (symbolP, SEG_TEXT);
	}			/* if pushing data into text */

      resolve_symbol_value (symbolP);

      /* Skip symbols which were equated to undefined or common
	 symbols.  Also skip defined uncommon symbols which can
	 be resolved since in this case they should have been
	 resolved to a non-symbolic constant.  */
      if (symbolP->sy_value.X_op == O_symbol
	  && (! S_IS_DEFINED (symbolP)
	      || S_IS_COMMON (symbolP)
	      || symbol_resolved_p (symbolP)))
	{
	  *symbolPP = symbol_next (symbolP);
	  continue;
	}

      /* OK, here is how we decide which symbols go out into the brave
	 new symtab.  Symbols that do are:

	 * symbols with no name (stabd's?)
	 * symbols with debug info in their N_TYPE
	 * symbols marked "forceout" (to force out local `L' symbols in Net-
				      or OpenBSD PIC code)

	 Symbols that don't are:
	 * symbols that are registers
	 * symbols with \1 as their 3rd character (numeric labels)
	 * "local labels" as defined by S_LOCAL_NAME(name) if the -L
	 switch was passed to gas.

	 All other symbols are output.  We complain if a deleted
	 symbol was marked external.  */

      if (!S_IS_REGISTER (symbolP)
	  && (!S_GET_NAME (symbolP)
	      || S_IS_DEBUG (symbolP)
	      || !S_IS_DEFINED (symbolP)
	      || S_IS_EXTERNAL (symbolP)
	      || (S_GET_NAME (symbolP)[0] != '\001'
		  && (flag_keep_locals || !S_LOCAL_NAME (symbolP))
#if defined(TE_NetBSD) || defined(TE_OpenBSD)
		 || (flag_pic && symbolP->sy_forceout)
#endif
		 ))
#if defined(TE_NetBSD) || defined(TE_OpenBSD)
	 && (!flag_pic || symbolP != GOT_symbol || got_referenced != 0)
#endif
         )
	{
	  symbolP->sy_number = symbol_number++;

	  /* The + 1 after strlen account for the \0 at the
			   end of each string */
	  if (!S_IS_STABD (symbolP))
	    {
	      /* Ordinary case.  */
	      symbolP->sy_name_offset = string_byte_count;
	      string_byte_count += strlen (S_GET_NAME (symbolP)) + 1;
	    }
	  else			/* .Stabd case.  */
	    symbolP->sy_name_offset = 0;
	  symbolPP = &symbolP->sy_next;
	}
      else
	{
	  if (S_IS_EXTERNAL (symbolP) || !S_IS_DEFINED (symbolP)
#if defined(TE_NetBSD) || defined(TE_OpenBSD)
	     && (!flag_pic || symbolP != GOT_symbol || got_referenced != 0)
#endif
	     )
	  if (S_IS_EXTERNAL (symbolP) || !S_IS_DEFINED (symbolP))
	    /* This warning should never get triggered any more.
	       Well, maybe if you're doing twisted things with
	       register names...  */
	    {
	      as_bad (_("Local symbol %s never defined."), decode_local_label_name (S_GET_NAME (symbolP)));
	    }			/* oops.  */

	  /* Unhook it from the chain */
	  *symbolPP = symbol_next (symbolP);
	}			/* if this symbol should be in the output */
    }				/* for each symbol */

  H_SET_SYMBOL_TABLE_SIZE (headers, symbol_number);
}

/*
 * Find strings by crawling along symbol table chain.
 */

void
obj_emit_strings (where)
     char **where;
{
  symbolS *symbolP;

#ifdef CROSS_COMPILE
  /* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
  md_number_to_chars (*where, string_byte_count, sizeof (string_byte_count));
  *where += sizeof (string_byte_count);
#else /* CROSS_COMPILE */
  append (where, (char *) &string_byte_count, (unsigned long) sizeof (string_byte_count));
#endif /* CROSS_COMPILE */

  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      if (S_GET_NAME (symbolP))
	append (&next_object_file_charP, S_GET_NAME (symbolP),
		(unsigned long) (strlen (S_GET_NAME (symbolP)) + 1));
    }				/* walk symbol chain */
}

#ifndef AOUT_VERSION
#define AOUT_VERSION 0
#endif

void
obj_pre_write_hook (headers)
     object_headers *headers;
{
  H_SET_DYNAMIC (headers, 0);
  H_SET_VERSION (headers, AOUT_VERSION);
  H_SET_MACHTYPE (headers, AOUT_MACHTYPE);
  tc_aout_pre_write_hook (headers);
}

#endif /* ! BFD_ASSEMBLER */

#ifdef BFD_ASSEMBLER

/* Support for an AOUT emulation.  */

static void aout_pop_insert PARAMS ((void));
static int obj_aout_s_get_other PARAMS ((symbolS *));
static void obj_aout_s_set_other PARAMS ((symbolS *, int));
static int obj_aout_s_get_desc PARAMS ((symbolS *));
static void obj_aout_s_set_desc PARAMS ((symbolS *, int));
static int obj_aout_s_get_type PARAMS ((symbolS *));
static void obj_aout_s_set_type PARAMS ((symbolS *, int));
static int obj_aout_separate_stab_sections PARAMS ((void));
static int obj_aout_sec_sym_ok_for_reloc PARAMS ((asection *));
static void obj_aout_process_stab PARAMS ((segT, int, const char *, int, int, int));

static void
aout_pop_insert ()
{
  pop_insert (aout_pseudo_table);
}

static int
obj_aout_s_get_other (sym)
     symbolS *sym;
{
  return aout_symbol (symbol_get_bfdsym (sym))->other;
}

static void
obj_aout_s_set_other (sym, o)
     symbolS *sym;
     int o;
{
  aout_symbol (symbol_get_bfdsym (sym))->other = o;
}

static int
obj_aout_sec_sym_ok_for_reloc (sec)
     asection *sec ATTRIBUTE_UNUSED;
{
  return obj_sec_sym_ok_for_reloc (sec);
}

static void
obj_aout_process_stab (seg, w, s, t, o, d)
     segT seg ATTRIBUTE_UNUSED;
     int w;
     const char *s;
     int t;
     int o;
     int d;
{
  aout_process_stab (w, s, t, o, d);
}

static int
obj_aout_s_get_desc (sym)
     symbolS *sym;
{
  return aout_symbol (symbol_get_bfdsym (sym))->desc;
}

static void
obj_aout_s_set_desc (sym, d)
     symbolS *sym;
     int d;
{
  aout_symbol (symbol_get_bfdsym (sym))->desc = d;
}

static int
obj_aout_s_get_type (sym)
     symbolS *sym;
{
  return aout_symbol (symbol_get_bfdsym (sym))->type;
}

static void
obj_aout_s_set_type (sym, t)
     symbolS *sym;
     int t;
{
  aout_symbol (symbol_get_bfdsym (sym))->type = t;
}

static int
obj_aout_separate_stab_sections ()
{
  return 0;
}

/* When changed, make sure these table entries match the single-format
   definitions in obj-aout.h.  */
const struct format_ops aout_format_ops =
{
  bfd_target_aout_flavour,
  1,	/* dfl_leading_underscore */
  0,	/* emit_section_symbols */
  0,	/* begin */
  0,	/* app_file */
  obj_aout_frob_symbol,
  0,	/* frob_file */
  0,	/* frob_file_before_adjust */
  obj_aout_frob_file_before_fix,
  0,	/* frob_file_after_relocs */
  0,	/* s_get_size */
  0,	/* s_set_size */
  0,	/* s_get_align */
  0,	/* s_set_align */
  obj_aout_s_get_other,
  obj_aout_s_set_other,
  obj_aout_s_get_desc,
  obj_aout_s_set_desc,
  obj_aout_s_get_type,
  obj_aout_s_set_type,
  0,	/* copy_symbol_attributes */
  0,	/* generate_asm_lineno */
  obj_aout_process_stab,
  obj_aout_separate_stab_sections,
  0,	/* init_stab_section */
  obj_aout_sec_sym_ok_for_reloc,
  aout_pop_insert,
  0,	/* ecoff_set_ext */
  0,	/* read_begin_hook */
  0 	/* symbol_new_hook */
};
#endif /* BFD_ASSEMBLER */
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d467 1
a467 1
	}			/* if pusing data into text */
d472 3
a474 1
	 symbols.  */
d476 3
a478 1
	  && (! S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP)))
d509 1
a509 1
		  || (flag_pic && symbolP->sy_forceout)
d511 1
a511 1
		  ))
d513 1
a513 1
	  && (!flag_pic || symbolP != GOT_symbol || got_referenced != 0)
d515 1
a515 1
	  )
d534 2
a535 2
#if defined(TE_NetBSD) || TE_OpenBSD)
	      && (!flag_pic || symbolP != GOT_symbol || got_referenced != 0)
d537 1
a537 1
	      )
@


1.7
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001
   Free Software Foundation, Inc.
d203 1
a203 1
obj_aout_frob_file ()
d209 1
a209 1
  boolean x = true;
d220 1
a220 1
  assert (x == true);
d469 1
a469 1
      resolve_symbol_value (symbolP, 1);
d486 1
a486 1
	 			      or OpenBSD PIC code)
d505 1
a505 1
	          || (flag_pic && symbolP->sy_forceout)
d534 1
a589 56
void
s_sect ()
{
  /* Strip out the section name */
  char *section_name;
  char *section_name_end;
  char c;

  unsigned int len;
  unsigned int exp;
  char *save;

  section_name = input_line_pointer;
  c = get_symbol_end ();
  section_name_end = input_line_pointer;

  len = section_name_end - section_name;
  input_line_pointer++;
  save = input_line_pointer;

  SKIP_WHITESPACE ();
  if (c == ',')
    {
      exp = get_absolute_expression ();
    }
  else if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      exp = get_absolute_expression ();
    }
  else
    {
      input_line_pointer = save;
      exp = 0;
    }
  if (exp >= 1000)
    {
      as_bad (_("subsegment index too high"));
    }

  if (strcmp (section_name, ".text") == 0)
    {
      subseg_set (SEG_TEXT, (subsegT) exp);
    }

  if (strcmp (section_name, ".data") == 0)
    {
      if (flag_readonly_data_in_text)
	subseg_set (SEG_TEXT, (subsegT) exp + 1000);
      else
	subseg_set (SEG_DATA, (subsegT) exp);
    }

  *section_name_end = c;
}

d693 1
a693 1
  obj_aout_frob_file,
d695 1
d718 1
a718 1
#endif BFD_ASSEMBLER
@


1.6
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d20 1
a20 1
02111-1307, USA. */
a101 1

d107 1
a107 1
     int *punt;
d225 1
a225 1
/* Relocation. */
d235 1
a235 1
     fixS *fixP;		/* Fixup chain for this segment. */
d324 1
a324 1
	 to the string in memory but must be a file offset. */
d330 1
a330 1
      /* Any symbol still undefined and is not a dbg symbol is made N_EXT. */
d357 1
a357 1
     int ignore;
d361 1
a361 1
     are not being incompatible here. */
d370 1
a370 1
     int ignore;
d398 1
a398 1
   versions ogas ignored the .type pseudo-op, so we also ignore it if
d403 1
a403 1
     int ignore;
d411 1
a411 1
  sym = symbol_find (name);
d413 2
a414 1
  if (sym != NULL)
d416 1
d418 1
a418 1
      if (*input_line_pointer == ',')
d421 1
a421 5
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '@@')
	    {
	      ++input_line_pointer;
	      if (strncmp (input_line_pointer, "object", 6) == 0)
d423 1
a423 1
		aout_symbol (symbol_get_bfdsym (sym))->other = 1;
d425 1
a425 1
		S_SET_OTHER (sym, 1);
d427 1
a427 1
	      else if (strncmp (input_line_pointer, "function", 8) == 0)
d429 1
a429 1
		aout_symbol (symbol_get_bfdsym (sym))->other = 2;
d431 1
a431 1
		S_SET_OTHER (sym, 2);
a432 1
	    }
d452 1
a452 1
  symbolPP = &symbol_rootP;	/*->last symbol chain link. */
d495 1
a495 2
	 symbol was marked external. */

d519 1
a519 1
	      /* Ordinary case. */
d523 1
a523 1
	  else			/* .Stabd case. */
d539 1
a539 1
	    }			/* oops. */
d590 1
a590 1
DEFUN_VOID (s_sect)
d653 1
d655 6
d675 27
d709 14
d724 16
d745 2
d749 1
d756 1
d758 3
d763 4
a766 2
  0,	/* process_stab */
  0,	/* sec_sym_ok_for_reloc */
a772 2

/* end of obj-aout.c */
@


1.5
log
@Clone NetBSD config for us, add handling of temporary local labels
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 1996
d17 6
a22 3
You should have received a copy of the GNU General Public
License along with GAS; see the file COPYING.  If not, write
to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d72 1
a72 1
const pseudo_typeS obj_pseudo_table[] =
d99 2
a100 2
  {NULL}			/* end sentinel */
};				/* obj_pseudo_table */
d114 5
a118 5
  flags = sym->bsym->flags;
  desc = S_GET_DESC (sym);
  type = S_GET_TYPE (sym);
  other = S_GET_OTHER (sym);
  sec = sym->bsym->section;
d125 4
a128 1
	sym->bsym->section = sec = bfd_und_section_ptr;
d150 1
a150 1
	  sym->bsym->flags |= BSF_DEBUGGING;
d163 1
a163 1
	    as_bad ("Attempt to put a common symbol into set %s",
d167 1
a167 1
	    as_bad ("Attempt to put an undefined symbol into set %s",
d173 2
a174 2
	  sym->bsym->section = bfd_ind_section_ptr;
	  sym->bsym->flags |= BSF_INDIRECT;
d177 2
a178 2
	      sym->bsym->flags |= BSF_EXPORT;
	      sym->bsym->flags &=~ BSF_LOCAL;
d183 1
a183 1
	  sym->bsym->flags |= BSF_WARNING;
d189 1
a189 1
      sym->bsym->flags |= BSF_DEBUGGING;
d192 1
a192 1
  S_SET_TYPE (sym, type);
d195 1
a195 1
  if (sym->bsym->flags & BSF_WEAK)
d198 1
a198 1
	as_bad ("Symbol `%s' can not be both weak and common",
d224 1
a224 1
#else
d256 1
a256 1
	      as_bad_where (file, line, "unresolved relocation");
d258 1
a258 1
	      as_bad ("bad relocation: symbol `%s' not in symbol table",
d300 1
a300 1
#endif
d345 1
a345 1
	    default: as_bad ("%s: bad type for weak symbol", temp); break;
d425 3
d429 1
d431 3
d435 1
a443 5
void
obj_read_begin_hook ()
{
}

d462 1
a462 1
	    as_bad ("%s: global symbols not supported in common sections",
d473 1
a473 1
      resolve_symbol_value (symbolP);
d530 1
a530 1
	  symbolPP = &(symbol_next (symbolP));
d543 1
a543 1
	      as_bad ("Local symbol %s never defined.", decode_local_label_name (S_GET_NAME (symbolP)));
d631 1
a631 1
      as_bad ("subsegment index too high");
d651 54
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d391 1
a391 1
/* Handle .type.  On NetBSD, this is used to set the n_other field,
d480 2
a481 2
	 * symbols marked "forceout" (to force out local `L' symbols in NetBSD
	                              PIC code)
d500 1
a500 1
#ifdef TE_NetBSD
d504 1
a504 1
#ifdef TE_NetBSD
d526 1
a526 1
#ifdef TE_NetBSD
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d67 1
d76 2
a87 1
  {"type", s_ignore, 0},
d391 39
d480 2
d499 9
a507 1
		  && (flag_keep_locals || !S_LOCAL_NAME (symbolP)))))
d525 5
a529 1
	  if (S_IS_EXTERNAL (symbolP) || !S_IS_DEFINED (symbolP))
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d242 12
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d234 8
d412 9
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 2
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 1996
   Free Software Foundation, Inc.
a232 8
	symbolS *sym;

	sym = fixP->fx_addsy;
	while (sym->sy_value.X_op == O_symbol
	       && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
	  sym = sym->sy_value.X_add_symbol;
	fixP->fx_addsy = sym;

a402 9

      /* Skip symbols which were equated to undefined or common
	 symbols.  */
      if (symbolP->sy_value.X_op == O_symbol
	  && (! S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP)))
	{
	  *symbolPP = symbol_next (symbolP);
	  continue;
	}
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a241 12
	if (! sym->sy_resolved && ! S_IS_DEFINED (sym))
	  {
	    char *file;
	    unsigned int line;

	    if (expr_symbol_where (sym, &file, &line))
	      as_bad_where (file, line, "unresolved relocation");
	    else
	      as_bad ("bad relocation: symbol `%s' not in symbol table",
		      S_GET_NAME (sym));
	  }

@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a66 1
static void obj_aout_type PARAMS ((int));
a74 2
  {"type", obj_aout_type, 0},

d85 1
a386 39
}

/* Handle .type.  On NetBSD, this is used to set the n_other field,
   which is then apparently used when doing dynamic linking.  Older
   versions ogas ignored the .type pseudo-op, so we also ignore it if
   we can't parse it.  */

static void
obj_aout_type (ignore)
     int ignore;
{
  char *name;
  int c;
  symbolS *sym;

  name = input_line_pointer;
  c = get_symbol_end ();
  sym = symbol_find (name);
  *input_line_pointer = c;
  if (sym != NULL)
    {
      SKIP_WHITESPACE ();
      if (*input_line_pointer == ',')
	{
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '@@')
	    {
	      ++input_line_pointer;
	      if (strncmp (input_line_pointer, "object", 6) == 0)
		S_SET_OTHER (sym, 1);
	      else if (strncmp (input_line_pointer, "function", 8) == 0)
		S_SET_OTHER (sym, 2);
	    }
	}
    }

  /* Ignore everything else on the line.  */
  s_ignore (0);
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d391 1
a391 1
/* Handle .type.  On {Net,Open}BSD, this is used to set the n_other field,
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d17 3
a19 6
You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA. */

#define OBJ_HEADER "obj-aout.h"
d69 1
a69 1
const pseudo_typeS aout_pseudo_table[] =
d96 2
a97 2
  {NULL, NULL, 0}		/* end sentinel */
};				/* aout_pseudo_table */
d111 5
a115 5
  flags = symbol_get_bfdsym (sym)->flags;
  desc = aout_symbol (symbol_get_bfdsym (sym))->desc;
  type = aout_symbol (symbol_get_bfdsym (sym))->type;
  other = aout_symbol (symbol_get_bfdsym (sym))->other;
  sec = S_GET_SEGMENT (sym);
d122 1
a122 4
	{
	  sec = bfd_und_section_ptr;
	  S_SET_SEGMENT (sym, sec);
	}
d144 1
a144 1
	  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
d157 1
a157 1
	    as_bad (_("Attempt to put a common symbol into set %s"),
d161 1
a161 1
	    as_bad (_("Attempt to put an undefined symbol into set %s"),
d167 2
a168 2
	  S_SET_SEGMENT (sym, bfd_ind_section_ptr);
	  symbol_get_bfdsym (sym)->flags |= BSF_INDIRECT;
d171 2
a172 2
	      symbol_get_bfdsym (sym)->flags |= BSF_EXPORT;
	      symbol_get_bfdsym (sym)->flags &=~ BSF_LOCAL;
d177 1
a177 1
	  symbol_get_bfdsym (sym)->flags |= BSF_WARNING;
d183 1
a183 1
      symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
d186 1
a186 1
  aout_symbol (symbol_get_bfdsym (sym))->type = type;
d189 1
a189 1
  if (S_IS_WEAK (sym))
d192 1
a192 1
	as_bad (_("Symbol `%s' can not be both weak and common"),
d218 1
a218 1
#else /* ! BFD_ASSEMBLER */
d250 1
a250 1
	      as_bad_where (file, line, _("unresolved relocation"));
d252 1
a252 1
	      as_bad (_("bad relocation: symbol `%s' not in symbol table"),
d294 1
a294 1
#endif /* ! defined (obj_header_append) */
d339 1
a339 1
	    default: as_bad (_("%s: bad type for weak symbol"), temp); break;
a418 3
#ifdef BFD_ASSEMBLER
		aout_symbol (symbol_get_bfdsym (sym))->other = 1;
#else
a419 1
#endif
a420 3
#ifdef BFD_ASSEMBLER
		aout_symbol (symbol_get_bfdsym (sym))->other = 2;
#else
a421 1
#endif
d430 5
d453 1
a453 1
	    as_bad (_("%s: global symbols not supported in common sections"),
d464 1
a464 1
      resolve_symbol_value (symbolP, 1);
d511 1
a511 1
	  symbolPP = &symbolP->sy_next;
d520 1
a520 1
	      as_bad (_("Local symbol %s never defined."), decode_local_label_name (S_GET_NAME (symbolP)));
d608 1
a608 1
      as_bad (_("subsegment index too high"));
a627 54

#ifdef BFD_ASSEMBLER

/* Support for an AOUT emulation.  */

static void aout_pop_insert PARAMS ((void));
static int obj_aout_s_get_other PARAMS ((symbolS *));
static int obj_aout_s_get_desc PARAMS ((symbolS *));

static void
aout_pop_insert ()
{
  pop_insert (aout_pseudo_table);
}

static int
obj_aout_s_get_other (sym)
     symbolS *sym;
{
  return aout_symbol (symbol_get_bfdsym (sym))->other;
}

static int
obj_aout_s_get_desc (sym)
     symbolS *sym;
{
  return aout_symbol (symbol_get_bfdsym (sym))->desc;
}


const struct format_ops aout_format_ops =
{
  bfd_target_aout_flavour,
  1,	/* dfl_leading_underscore */
  0,	/* emit_section_symbols */
  obj_aout_frob_symbol,
  obj_aout_frob_file,
  0,	/* frob_file_after_relocs */
  0,	/* s_get_size */
  0,	/* s_set_size */
  0,	/* s_get_align */
  0,	/* s_set_align */
  obj_aout_s_get_other,
  obj_aout_s_get_desc,
  0,	/* copy_symbol_attributes */
  0,	/* generate_asm_lineno */
  0,	/* process_stab */
  0,	/* sec_sym_ok_for_reloc */
  aout_pop_insert,
  0,	/* ecoff_set_ext */
  0,	/* read_begin_hook */
  0 	/* symbol_new_hook */
};
#endif BFD_ASSEMBLER
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001
d20 1
a20 1
02111-1307, USA.  */
d102 1
d108 1
a108 1
     int *punt ATTRIBUTE_UNUSED;
d226 1
a226 1
/* Relocation.  */
d236 1
a236 1
     fixS *fixP;		/* Fixup chain for this segment.  */
d325 1
a325 1
	 to the string in memory but must be a file offset.  */
d331 1
a331 1
      /* Any symbol still undefined and is not a dbg symbol is made N_EXT.  */
d358 1
a358 1
     int ignore ATTRIBUTE_UNUSED;
d362 1
a362 1
     are not being incompatible here.  */
d371 1
a371 1
     int ignore ATTRIBUTE_UNUSED;
d399 1
a399 1
   versions of gas ignored the .type pseudo-op, so we also ignore it if
d404 1
a404 1
     int ignore ATTRIBUTE_UNUSED;
d412 1
a412 1
  sym = symbol_find_or_make (name);
d414 1
a414 2
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
a415 1
      ++input_line_pointer;
d417 1
a417 1
      if (*input_line_pointer == '@@')
d420 5
a424 1
	  if (strncmp (input_line_pointer, "object", 6) == 0)
d426 1
a426 1
	    aout_symbol (symbol_get_bfdsym (sym))->other = 1;
d428 1
a428 1
	  S_SET_OTHER (sym, 1);
d430 1
a430 1
	  else if (strncmp (input_line_pointer, "function", 8) == 0)
d432 1
a432 1
	    aout_symbol (symbol_get_bfdsym (sym))->other = 2;
d434 1
a434 1
	  S_SET_OTHER (sym, 2);
d436 1
d456 1
a456 1
  symbolPP = &symbol_rootP;	/*->last symbol chain link.  */
d497 2
a498 1
	 symbol was marked external.  */
d514 1
a514 1
	      /* Ordinary case.  */
d518 1
a518 1
	  else			/* .Stabd case.  */
d530 1
a530 1
	    }			/* oops.  */
d581 1
a581 1
s_sect ()
a643 1
static void obj_aout_s_set_other PARAMS ((symbolS *, int));
a644 6
static void obj_aout_s_set_desc PARAMS ((symbolS *, int));
static int obj_aout_s_get_type PARAMS ((symbolS *));
static void obj_aout_s_set_type PARAMS ((symbolS *, int));
static int obj_aout_separate_stab_sections PARAMS ((void));
static int obj_aout_sec_sym_ok_for_reloc PARAMS ((asection *));
static void obj_aout_process_stab PARAMS ((segT, int, const char *, int, int, int));
a658 27
static void
obj_aout_s_set_other (sym, o)
     symbolS *sym;
     int o;
{
  aout_symbol (symbol_get_bfdsym (sym))->other = o;
}

static int
obj_aout_sec_sym_ok_for_reloc (sec)
     asection *sec ATTRIBUTE_UNUSED;
{
  return obj_sec_sym_ok_for_reloc (sec);
}

static void
obj_aout_process_stab (seg, w, s, t, o, d)
     segT seg ATTRIBUTE_UNUSED;
     int w;
     const char *s;
     int t;
     int o;
     int d;
{
  aout_process_stab (w, s, t, o, d);
}

a665 14
static void
obj_aout_s_set_desc (sym, d)
     symbolS *sym;
     int d;
{
  aout_symbol (symbol_get_bfdsym (sym))->desc = d;
}

static int
obj_aout_s_get_type (sym)
     symbolS *sym;
{
  return aout_symbol (symbol_get_bfdsym (sym))->type;
}
a666 16
static void
obj_aout_s_set_type (sym, t)
     symbolS *sym;
     int t;
{
  aout_symbol (symbol_get_bfdsym (sym))->type = t;
}

static int
obj_aout_separate_stab_sections ()
{
  return 0;
}

/* When changed, make sure these table entries match the single-format
   definitions in obj-aout.h.  */
a671 2
  0,	/* begin */
  0,	/* app_file */
a673 1
  0,	/* frob_file_before_adjust */
a679 1
  obj_aout_s_set_other,
a680 3
  obj_aout_s_set_desc,
  obj_aout_s_get_type,
  obj_aout_s_set_type,
d683 2
a684 4
  obj_aout_process_stab,
  obj_aout_separate_stab_sections,
  0,	/* init_stab_section */
  obj_aout_sec_sym_ok_for_reloc,
d691 2
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000,
   2001, 2002 Free Software Foundation, Inc.
d203 1
a203 1
obj_aout_frob_file_before_fix ()
d209 1
a209 1
  bfd_boolean x = TRUE;
d220 1
a220 1
  assert (x);
d469 1
a469 1
      resolve_symbol_value (symbolP);
d575 56
d734 1
a734 1
  0,	/* frob_file */
a735 1
  obj_aout_frob_file_before_fix,
d758 1
a758 1
#endif /* BFD_ASSEMBLER */
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d467 1
a467 1
	}			/* if pushing data into text */
d472 1
a472 3
	 symbols.  Also skip defined uncommon symbols which can
	 be resolved since in this case they should have been
	 resolved to a non-symbolic constant.  */
d474 1
a474 3
	  && (! S_IS_DEFINED (symbolP)
	      || S_IS_COMMON (symbolP)
	      || symbol_resolved_p (symbolP)))
@


