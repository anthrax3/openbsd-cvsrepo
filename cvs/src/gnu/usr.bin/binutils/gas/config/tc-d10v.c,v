head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.5.0.52
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.48
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.44
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.46
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.38
	OPENBSD_5_7_BASE:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.42
	OPENBSD_5_6_BASE:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.40
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.36
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.34
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.32
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.30
	OPENBSD_5_0:1.1.1.5.0.28
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.26
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.24
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.20
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.22
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.18
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.16
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.14
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.12
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.10
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.8
	OPENBSD_4_0_BASE:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.1.1.3.0.8
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.6
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.4
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.2
	OPENBSD_3_2_BASE:1.1.1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.1.1.2.0.8
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.6
	OPENBSD_3_0_BASE:1.1.1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.4
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	BINUTILS-2_10:1.1.1.2
	FSF:1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	new-binutils:1.1.1.1.0.12
	OPENBSD_2_6:1.1.1.1.0.10
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.8
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.6
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.4
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.2
	OPENBSD_2_2_BASE:1.1.1.1
	BINUTILS-2_8_1:1.1.1.1
	CYGNUS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	97.05.29.09.22.56;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.29.09.22.56;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.46.23;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.34.15;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.29;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.50;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* tc-d10v.c -- Assembler code for the Mitsubishi D10V

   Copyright (C) 1996, 1997 Free Software Foundation.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include <ctype.h>
#include "as.h"
#include "subsegs.h"     
#include "opcode/d10v.h"
#include "elf/ppc.h"

const char comment_chars[] = ";";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = "";
const char *md_shortopts = "O";
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "dD";

int Optimizing = 0;

#define AT_WORD (-1)

/* fixups */
#define MAX_INSN_FIXUPS (5)
struct d10v_fixup
{
  expressionS exp;
  int operand;
  int pcrel;
  int size;
  bfd_reloc_code_real_type reloc;
};

typedef struct _fixups
{
  int fc;
  struct d10v_fixup fix[MAX_INSN_FIXUPS];
  struct _fixups *next;
} Fixups;

static Fixups FixUps[2];
static Fixups *fixups;

/* local functions */
static int reg_name_search PARAMS ((char *name));
static int register_name PARAMS ((expressionS *expressionP));
static int check_range PARAMS ((unsigned long num, int bits, int flags));
static int postfix PARAMS ((char *p));
static bfd_reloc_code_real_type get_reloc PARAMS ((struct d10v_operand *op));
static int get_operands PARAMS ((expressionS exp[]));
static struct d10v_opcode *find_opcode PARAMS ((struct d10v_opcode *opcode, expressionS ops[]));
static unsigned long build_insn PARAMS ((struct d10v_opcode *opcode, expressionS *opers, unsigned long insn));
static void write_long PARAMS ((struct d10v_opcode *opcode, unsigned long insn, Fixups *fx));
static void write_1_short PARAMS ((struct d10v_opcode *opcode, unsigned long insn, Fixups *fx));
static int write_2_short PARAMS ((struct d10v_opcode *opcode1, unsigned long insn1, 
				  struct d10v_opcode *opcode2, unsigned long insn2, int exec_type, Fixups *fx));
static unsigned long do_assemble PARAMS ((char *str, struct d10v_opcode **opcode));
static unsigned long d10v_insert_operand PARAMS (( unsigned long insn, int op_type,
						   offsetT value, int left, fixS *fix));
static int parallel_ok PARAMS ((struct d10v_opcode *opcode1, unsigned long insn1, 
				struct d10v_opcode *opcode2, unsigned long insn2,
				int exec_type));

struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof(md_longopts);       

static void d10v_dot_word PARAMS ((int));

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "word",	d10v_dot_word,	2 },
  { NULL,       NULL,           0 }
};

/* Opcode hash table.  */
static struct hash_control *d10v_hash;

/* reg_name_search does a binary search of the d10v_predefined_registers
   array to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure. */

static int
reg_name_search (name)
     char *name;
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = d10v_reg_name_cnt() - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, d10v_predefined_registers[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else 
	  return d10v_predefined_registers[middle].value;
    }
  while (low <= high);
  return -1;
}

/* register_name() checks the string at input_line_pointer
   to see if it is a valid register name */

static int
register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char c, *p = input_line_pointer;
  
  while (*p && *p!='\n' && *p!='\r' && *p !=',' && *p!=' ' && *p!=')')
    p++;

  c = *p;
  if (c)
    *p++ = 0;

  /* look to see if it's in the register table */
  reg_number = reg_name_search (input_line_pointer);
  if (reg_number >= 0) 
    {
      expressionP->X_op = O_register;
      /* temporarily store a pointer to the string here */
      expressionP->X_op_symbol = (struct symbol *)input_line_pointer;
      expressionP->X_add_number = reg_number;
      input_line_pointer = p;
      return 1;
    }
  if (c)
    *(p-1) = c;
  return 0;
}


static int
check_range (num, bits, flags)
     unsigned long num;
     int bits;
     int flags;
{
  long min, max, bit1;
  int retval=0;

  /* don't bother checking 16-bit values */
  if (bits == 16)
    return 0;

  if (flags & OPERAND_SHIFT)
    {
      /* all special shift operands are unsigned */
      /* and <= 16.  We allow 0 for now. */
      if (num>16)
	return 1;
      else
	return 0;
    }

  if (flags & OPERAND_SIGNED)
    {
      max = (1 << (bits - 1))-1; 
      min = - (1 << (bits - 1));  
      if (((long)num > max) || ((long)num < min))
	retval = 1;
    }
  else
    {
      max = (1 << bits) - 1;
      min = 0;
      if ((num > max) || (num < min))
	retval = 1;
    }
  return retval;
}


void
md_show_usage (stream)
  FILE *stream;
{
  fprintf(stream, "D10V options:\n\
-O                      optimize.  Will do some operations in parallel.\n");
} 

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
    {
    case 'O':
      /* Optimize. Will attempt to parallelize operations */
      Optimizing = 1;
      break;
    default:
      return 0;
    }
  return 1;
}

symbolS *
md_undefined_symbol (name)
  char *name;
{
  return 0;
}

/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
char *
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;
  
  switch (type)
    {
    case 'f':
      prec = 2;
      break;
    case 'd':
      prec = 4;
      break;
    default:
      *sizeP = 0;
      return "bad call to md_atof";
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  
  *sizeP = prec * 2;
  
  for (i = 0; i < prec; i++)
    {
      md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
    }
  return NULL;
}

void
md_convert_frag (abfd, sec, fragP)
  bfd *abfd;
  asection *sec;
  fragS *fragP;
{
  abort ();
}

valueT
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}


void
md_begin ()
{
  char *prev_name = "";
  struct d10v_opcode *opcode;
  d10v_hash = hash_new();

  /* Insert unique names into hash table.  The D10v instruction set
     has many identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */

  for (opcode = (struct d10v_opcode *)d10v_opcodes; opcode->name; opcode++)
    {
      if (strcmp (prev_name, opcode->name))
	{
	  prev_name = (char *)opcode->name;
	  hash_insert (d10v_hash, opcode->name, (char *) opcode);
	}
    }

  fixups = &FixUps[0];
  FixUps[0].next = &FixUps[1];
  FixUps[1].next = &FixUps[0];
}


/* this function removes the postincrement or postdecrement
   operator ( '+' or '-' ) from an expression */

static int postfix (p) 
     char *p;
{
  while (*p != '-' && *p != '+') 
    {
      if (*p==0 || *p=='\n' || *p=='\r') 
	break;
      p++;
    }

  if (*p == '-') 
    {
      *p = ' ';
      return (-1);
    }
  if (*p == '+') 
    {
      *p = ' ';
      return (1);
    }

  return (0);
}


static bfd_reloc_code_real_type 
get_reloc (op) 
     struct d10v_operand *op;
{
  int bits = op->bits;

  if (bits <= 4) 
    return (0);
      
  if (op->flags & OPERAND_ADDR) 
    {
      if (bits == 8)
	return (BFD_RELOC_D10V_10_PCREL_R);
      else
	return (BFD_RELOC_D10V_18_PCREL);
    }

  return (BFD_RELOC_16);
}


/* get_operands parses a string of operands and returns
   an array of expressions */

static int
get_operands (exp) 
     expressionS exp[];
{
  char *p = input_line_pointer;
  int numops = 0;
  int post = 0;

  while (*p)  
    {
      while (*p == ' ' || *p == '\t' || *p == ',') 
	p++;
      if (*p==0 || *p=='\n' || *p=='\r') 
	break;
      
      if (*p == '@@') 
	{
	  p++;
	  exp[numops].X_op = O_absent;
	  if (*p == '(') 
	    {
	      p++;
	      exp[numops].X_add_number = OPERAND_ATPAR;
	    }
	  else if (*p == '-') 
	    {
	      p++;
	      exp[numops].X_add_number = OPERAND_ATMINUS;
	    }
	  else
	    {
	      exp[numops].X_add_number = OPERAND_ATSIGN;
	      post = postfix (p);
	    }
	  numops++;
	  continue;
	}

      if (*p == ')') 
	{
	  /* just skip the trailing paren */
	  p++;
	  continue;
	}

      input_line_pointer = p;

      /* check to see if it might be a register name */
      if (!register_name (&exp[numops]))
	{
	  /* parse as an expression */
	  expression (&exp[numops]);
	}

      if (!strncasecmp (input_line_pointer, "@@word", 5))
	{
	  if (exp[numops].X_op == O_register)
	    {
	      /* if it looked like a register name but was followed by "@@word" */
	      /* then it was really a symbol, so change it to one */
	      exp[numops].X_op = O_symbol;
	      exp[numops].X_add_symbol = symbol_find_or_make ((char *)exp[numops].X_op_symbol);
	      exp[numops].X_op_symbol = NULL;
	    }
	  exp[numops].X_add_number = AT_WORD;
	  input_line_pointer += 5;
	}
      
      if (exp[numops].X_op == O_illegal) 
	as_bad ("illegal operand");
      else if (exp[numops].X_op == O_absent) 
	as_bad ("missing operand");

      numops++;
      p = input_line_pointer;
    }

  switch (post) 
    {
    case -1:	/* postdecrement mode */
      exp[numops].X_op = O_absent;
      exp[numops++].X_add_number = OPERAND_MINUS;
      break;
    case 1:	/* postincrement mode */
      exp[numops].X_op = O_absent;
      exp[numops++].X_add_number = OPERAND_PLUS;
      break;
    }

  exp[numops].X_op = 0;
  return (numops);
}

static unsigned long
d10v_insert_operand (insn, op_type, value, left, fix) 
     unsigned long insn;
     int op_type;
     offsetT value;
     int left;
     fixS *fix;
{
  int shift, bits;

  shift = d10v_operands[op_type].shift;
  if (left)
    shift += 15;

  bits = d10v_operands[op_type].bits;

  /* truncate to the proper number of bits */
  if (check_range (value, bits, d10v_operands[op_type].flags))
    as_bad_where (fix->fx_file, fix->fx_line, "operand out of range: %d", value);

  value &= 0x7FFFFFFF >> (31 - bits);
  insn |= (value << shift);

  return insn;
}


/* build_insn takes a pointer to the opcode entry in the opcode table
   and the array of operand expressions and returns the instruction */

static unsigned long
build_insn (opcode, opers, insn) 
     struct d10v_opcode *opcode;
     expressionS *opers;
     unsigned long insn;
{
  int i, bits, shift, flags, format;
  unsigned int number;
  
  /* the insn argument is only used for the DIVS kludge */
  if (insn)
    format = LONG_R;
  else
    {
      insn = opcode->opcode;
      format = opcode->format;
    }
  
  for (i=0;opcode->operands[i];i++) 
    {
      flags = d10v_operands[opcode->operands[i]].flags;
      bits = d10v_operands[opcode->operands[i]].bits;
      shift = d10v_operands[opcode->operands[i]].shift;
      number = opers[i].X_add_number;

      if (flags & OPERAND_REG) 
	{
	  number &= REGISTER_MASK;
	  if (format == LONG_L)
	    shift += 15;
	}

      if (opers[i].X_op != O_register && opers[i].X_op != O_constant) 
	{
	  /* now create a fixup */

	  if (fixups->fc >= MAX_INSN_FIXUPS)
	    as_fatal ("too many fixups");

	  if (opers[i].X_op == O_symbol && number == AT_WORD)
	    {
	      number = opers[i].X_add_number = 0;
	      fixups->fix[fixups->fc].reloc = BFD_RELOC_D10V_18;
	    } else
	      fixups->fix[fixups->fc].reloc = 
		get_reloc((struct d10v_operand *)&d10v_operands[opcode->operands[i]]);

	  if (fixups->fix[fixups->fc].reloc == BFD_RELOC_16 || 
	      fixups->fix[fixups->fc].reloc == BFD_RELOC_D10V_18)
	    fixups->fix[fixups->fc].size = 2; 	    
	  else
	    fixups->fix[fixups->fc].size = 4;
 	    
	  fixups->fix[fixups->fc].exp = opers[i];
	  fixups->fix[fixups->fc].operand = opcode->operands[i];
	  fixups->fix[fixups->fc].pcrel = (flags & OPERAND_ADDR) ? true : false;
	  (fixups->fc)++;
	}

      /* truncate to the proper number of bits */
      if ((opers[i].X_op == O_constant) && check_range (number, bits, flags))
	as_bad("operand out of range: %d",number);
      number &= 0x7FFFFFFF >> (31 - bits);
      insn = insn | (number << shift);
    }

  /* kludge: for DIVS, we need to put the operands in twice */
  /* on the second pass, format is changed to LONG_R to force */
  /* the second set of operands to not be shifted over 15 */
  if ((opcode->opcode == OPCODE_DIVS) && (format==LONG_L))
    insn = build_insn (opcode, opers, insn);
      
  return insn;
}

/* write out a long form instruction */
static void
write_long (opcode, insn, fx) 
     struct d10v_opcode *opcode;
     unsigned long insn;
     Fixups *fx;
{
  int i, where;
  char *f = frag_more(4);

  insn |= FM11;
  number_to_chars_bigendian (f, insn, 4);

  for (i=0; i < fx->fc; i++) 
    {
      if (fx->fix[i].reloc)
	{ 
	  where = f - frag_now->fr_literal; 
	  if (fx->fix[i].size == 2)
	    where += 2;

	  if (fx->fix[i].reloc == BFD_RELOC_D10V_18)
	    fx->fix[i].operand |= 4096;	  

	  fix_new_exp (frag_now,
		       where,
		       fx->fix[i].size,
		       &(fx->fix[i].exp),
		       fx->fix[i].pcrel,
		       fx->fix[i].operand|2048);
	}
    }
  fx->fc = 0;
}


/* write out a short form instruction by itself */
static void
write_1_short (opcode, insn, fx) 
     struct d10v_opcode *opcode;
     unsigned long insn;
     Fixups *fx;
{
  char *f = frag_more(4);
  int i, where;

  if (opcode->exec_type & PARONLY)
    as_fatal ("Instruction must be executed in parallel with another instruction.");

  /* the other container needs to be NOP */
  /* according to 4.3.1: for FM=00, sub-instructions performed only
     by IU cannot be encoded in L-container. */
  if (opcode->unit == IU)
    insn |= FM00 | (NOP << 15);		/* right container */
  else
    insn = FM00 | (insn << 15) | NOP;	/* left container */

  number_to_chars_bigendian (f, insn, 4);
  for (i=0; i < fx->fc; i++) 
    {
      if (fx->fix[i].reloc)
	{ 
	  where = f - frag_now->fr_literal; 
	  if (fx->fix[i].size == 2)
	    where += 2;

	  if (fx->fix[i].reloc == BFD_RELOC_D10V_18)
	    fx->fix[i].operand |= 4096;	  

	  /* if it's an R reloc, we may have to switch it to L */
	  if ( (fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R) && (opcode->unit != IU) )
	    fx->fix[i].operand |= 1024;

	  fix_new_exp (frag_now,
		       where, 
		       fx->fix[i].size,
		       &(fx->fix[i].exp),
		       fx->fix[i].pcrel,
		       fx->fix[i].operand|2048);
	}
    }
  fx->fc = 0;
}

/* write out a short form instruction if possible */
/* return number of instructions not written out */
static int
write_2_short (opcode1, insn1, opcode2, insn2, exec_type, fx) 
     struct d10v_opcode *opcode1, *opcode2;
     unsigned long insn1, insn2;
     int exec_type;
     Fixups *fx;
{
  unsigned long insn;
  char *f;
  int i,j, where;

  if ( (exec_type != 1) && ((opcode1->exec_type & PARONLY)
	                || (opcode2->exec_type & PARONLY)))
    as_fatal("Instruction must be executed in parallel");
  
  if ( (opcode1->format & LONG_OPCODE) || (opcode2->format & LONG_OPCODE))
    as_fatal ("Long instructions may not be combined.");

  if(opcode1->exec_type & BRANCH_LINK && opcode2->exec_type != PARONLY)
    {
      /* subroutines must be called from 32-bit boundaries */
      /* so the return address will be correct */
      write_1_short (opcode1, insn1, fx->next);
      return (1);
    }

  switch (exec_type) 
    {
    case 0:	/* order not specified */
      if ( Optimizing && parallel_ok (opcode1, insn1, opcode2, insn2, exec_type))
	{
	  /* parallel */
	  if (opcode1->unit == IU)
	    insn = FM00 | (insn2 << 15) | insn1;
	  else if (opcode2->unit == MU)
	    insn = FM00 | (insn2 << 15) | insn1;
	  else
	    {
	      insn = FM00 | (insn1 << 15) | insn2;  
	      fx = fx->next;
	    }
	}
      else if (opcode1->unit == IU) 
	{
	  /* reverse sequential */
	  insn = FM10 | (insn2 << 15) | insn1;
	}
      else
	{
	  /* sequential */
	  insn = FM01 | (insn1 << 15) | insn2;
	  fx = fx->next;  
	}
      break;
    case 1:	/* parallel */
      if (opcode1->exec_type & SEQ || opcode2->exec_type & SEQ)
	as_fatal ("One of these instructions may not be executed in parallel.");

      if (opcode1->unit == IU)
	{
	  if (opcode2->unit == IU)
	    as_fatal ("Two IU instructions may not be executed in parallel");
	  as_warn ("Swapping instruction order");
 	  insn = FM00 | (insn2 << 15) | insn1;
	}
      else if (opcode2->unit == MU)
	{
	  if (opcode1->unit == MU)
	    as_fatal ("Two MU instructions may not be executed in parallel");
	  as_warn ("Swapping instruction order");
	  insn = FM00 | (insn2 << 15) | insn1;
	}
      else
	{
	  insn = FM00 | (insn1 << 15) | insn2;  
	  fx = fx->next;
	}
      break;
    case 2:	/* sequential */
      if (opcode1->unit == IU)
	as_fatal ("IU instruction may not be in the left container");
      insn = FM01 | (insn1 << 15) | insn2;  
      fx = fx->next;
      break;
    case 3:	/* reverse sequential */
      if (opcode2->unit == MU)
	as_fatal ("MU instruction may not be in the right container");
      insn = FM10 | (insn1 << 15) | insn2;  
      fx = fx->next;
      break;
    default:
      as_fatal("unknown execution type passed to write_2_short()");
    }

  f = frag_more(4);
  number_to_chars_bigendian (f, insn, 4);

  for (j=0; j<2; j++) 
    {
      for (i=0; i < fx->fc; i++) 
	{
	  if (fx->fix[i].reloc)
	    {
	      where = f - frag_now->fr_literal; 
	      if (fx->fix[i].size == 2)
		where += 2;
	      
	      if ( (fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R) && (j == 0) )
		fx->fix[i].operand |= 1024;
	      
	      if (fx->fix[i].reloc == BFD_RELOC_D10V_18)
		fx->fix[i].operand |= 4096;	  

	      fix_new_exp (frag_now,
			   where, 
			   fx->fix[i].size,
			   &(fx->fix[i].exp),
			   fx->fix[i].pcrel,
			   fx->fix[i].operand|2048);
	    }
	}
      fx->fc = 0;
      fx = fx->next;
    }
  return (0);
}


/* Check 2 instructions and determine if they can be safely */
/* executed in parallel.  Returns 1 if they can be.         */
static int
parallel_ok (op1, insn1, op2, insn2, exec_type)
     struct d10v_opcode *op1, *op2;
     unsigned long insn1, insn2;
     int exec_type;
{
  int i, j, flags, mask, shift, regno;
  unsigned long ins, mod[2], used[2];
  struct d10v_opcode *op;

  if ((op1->exec_type & SEQ) != 0 || (op2->exec_type & SEQ) != 0
      || (op1->exec_type & PAR) == 0 || (op2->exec_type & PAR) == 0
      || (op1->unit == BOTH) || (op2->unit == BOTH)
      || (op1->unit == IU && op2->unit == IU)
      || (op1->unit == MU && op2->unit == MU))
    return 0;

  /* If the first instruction is a branch and this is auto parallazation,
     don't combine with any second instruction.  */
  if (exec_type == 0 && (op1->exec_type & BRANCH) != 0)
    return 0;

  /* The idea here is to create two sets of bitmasks (mod and used) */
  /* which indicate which registers are modified or used by each instruction. */
  /* The operation can only be done in parallel if instruction 1 and instruction 2 */
  /* modify different registers, and neither instruction modifies any registers */
  /* the other is using.  Accesses to control registers, PSW, and memory are treated */
  /* as accesses to a single register.  So if both instructions write memory or one */
  /* instruction writes memory and the other reads, then they cannot be done in parallel. */
  /* Likewise, if one instruction mucks with the psw and the other reads the PSW */
  /* (which includes C, F0, and F1), then they cannot operate safely in parallel. */

  /* the bitmasks (mod and used) look like this (bit 31 = MSB) */
  /* r0-r15	  0-15  */
  /* a0-a1	  16-17 */
  /* cr (not psw) 18    */
  /* psw	  19    */
  /* mem	  20    */

  for (j=0;j<2;j++)
    {
      if (j == 0)
	{
	  op = op1;
	  ins = insn1;
	}
      else
	{
	  op = op2;
	  ins = insn2;
	}
      mod[j] = used[j] = 0;
      if (op->exec_type & BRANCH_LINK)
	mod[j] |= 1 << 13;

      for (i = 0; op->operands[i]; i++)
	{
	  flags = d10v_operands[op->operands[i]].flags;
	  shift = d10v_operands[op->operands[i]].shift;
	  mask = 0x7FFFFFFF >> (31 - d10v_operands[op->operands[i]].bits);
	  if (flags & OPERAND_REG)
	    {
	      regno = (ins >> shift) & mask;
	      if (flags & OPERAND_ACC)     
		regno += 16;
	      else if (flags & OPERAND_CONTROL)	/* mvtc or mvfc */
		{ 
		  if (regno == 0)
		    regno = 19;
		  else
		    regno = 18; 
		}
	      else if (flags & OPERAND_FLAG)  
		regno = 19;
	      
	      if ( flags & OPERAND_DEST )
		{
		  mod[j] |= 1 << regno;
		  if (flags & OPERAND_EVEN)
		    mod[j] |= 1 << (regno + 1);
		}
	      else
		{
		  used[j] |= 1 << regno ;
		  if (flags & OPERAND_EVEN)
		    used[j] |= 1 << (regno + 1);
		}
	    }
	}
      if (op->exec_type & RMEM)
	used[j] |= 1 << 20;
      else if (op->exec_type & WMEM)
	mod[j] |= 1 << 20;
      else if (op->exec_type & RF0)
	used[j] |= 1 << 19;
      else if (op->exec_type & WF0)
	mod[j] |= 1 << 19;
      else if (op->exec_type & WCAR)
	mod[j] |= 1 << 19;
    }
  if ((mod[0] & mod[1]) == 0 && (mod[0] & used[1]) == 0 && (mod[1] & used[0]) == 0)
    return 1;
  return 0;
}


/* This is the main entry point for the machine-dependent assembler.  str points to a
   machine-dependent instruction.  This function is supposed to emit the frags/bytes 
   it assembles to.  For the D10V, it mostly handles the special VLIW parsing and packing
   and leaves the difficult stuff to do_assemble().
 */

static unsigned long prev_insn;
static struct d10v_opcode *prev_opcode = 0;
static subsegT prev_subseg;
static segT prev_seg = 0;;

void
md_assemble (str)
     char *str;
{
  struct d10v_opcode *opcode;
  unsigned long insn;
  int extype=0;			/* execution type; parallel, etc */
  static int etype=0;		/* saved extype.  used for multiline instructions */
  char *str2;

  if (etype == 0)
    {
      /* look for the special multiple instruction separators */
      str2 = strstr (str, "||");
      if (str2) 
	extype = 1;
      else
	{
	  str2 = strstr (str, "->");
	  if (str2) 
	    extype = 2;
	  else
	    {
	      str2 = strstr (str, "<-");
	      if (str2) 
		extype = 3;
	    }
	}
      /* str2 points to the separator, if one */
      if (str2) 
	{
	  *str2 = 0;
	  
	  /* if two instructions are present and we already have one saved
	     then first write it out */
	  d10v_cleanup();
	  
	  /* assemble first instruction and save it */
	  prev_insn = do_assemble (str, &prev_opcode);
	  if (prev_insn == -1)
	    as_fatal ("can't find opcode ");
	  fixups = fixups->next;
	  str = str2 + 2;
	}
    }

  insn = do_assemble (str, &opcode);
  if (insn == -1)
    {
      if (extype)
	{
	  etype = extype;
	  return;
	}
      as_fatal ("can't find opcode ");
    }

  if (etype)
    {
      extype = etype;
      etype = 0;
    }

  /* if this is a long instruction, write it and any previous short instruction */
  if (opcode->format & LONG_OPCODE) 
    {
      if (extype) 
	as_fatal("Unable to mix instructions as specified");
      d10v_cleanup();
      write_long (opcode, insn, fixups);
      prev_opcode = NULL;
      return;
    }
  
  if (prev_opcode && prev_seg && ((prev_seg != now_seg) || (prev_subseg != now_subseg)))
    d10v_cleanup();
  
  if (prev_opcode && (write_2_short (prev_opcode, prev_insn, opcode, insn, extype, fixups) == 0)) 
    {
      /* no instructions saved */
      prev_opcode = NULL;
    }
  else
    {
      if (extype) 
	as_fatal("Unable to mix instructions as specified");
      /* save off last instruction so it may be packed on next pass */
      prev_opcode = opcode;
      prev_insn = insn;
      prev_seg = now_seg;
      prev_subseg = now_subseg;
      fixups = fixups->next;
    }
}


/* do_assemble assembles a single instruction and returns an opcode */
/* it returns -1 (an invalid opcode) on error */

static unsigned long
do_assemble (str, opcode) 
     char *str;
     struct d10v_opcode **opcode;
{
  unsigned char *op_start, *save;
  unsigned char *op_end;
  char name[20];
  int nlen = 0;
  expressionS myops[6];
  unsigned long insn;

  /* Drop leading whitespace */
  while (*str == ' ')
    str++;

  /* find the opcode end */
  for (op_start = op_end = (unsigned char *) (str);
       *op_end
       && nlen < 20
       && !is_end_of_line[*op_end] && *op_end != ' ';
       op_end++)
    {
      name[nlen] = tolower(op_start[nlen]);
      nlen++;
    }
  name[nlen] = 0;

  if (nlen == 0)
    return (-1);
  
  /* find the first opcode with the proper name */
  *opcode = (struct d10v_opcode *)hash_find (d10v_hash, name);
  if (*opcode == NULL)
      as_fatal ("unknown opcode: %s",name);

  save = input_line_pointer;
  input_line_pointer = op_end;
  *opcode = find_opcode (*opcode, myops);
  if (*opcode == 0)
    return -1;
  input_line_pointer = save;

  insn = build_insn ((*opcode), myops, 0); 
  return (insn);
}

/* find_opcode() gets a pointer to an entry in the opcode table.       */
/* It must look at all opcodes with the same name and use the operands */
/* to choose the correct opcode. */

static struct d10v_opcode *
find_opcode (opcode, myops)
     struct d10v_opcode *opcode;
     expressionS myops[];
{
  int i, match, done;
  struct d10v_opcode *next_opcode;

  /* get all the operands and save them as expressions */
  get_operands (myops);

  /* now see if the operand is a fake.  If so, find the correct size */
  /* instruction, if possible */
  if (opcode->format == OPCODE_FAKE)
    {
      int opnum = opcode->operands[0];
			 
      if (myops[opnum].X_op == O_register)
	{
	  myops[opnum].X_op = O_symbol;
	  myops[opnum].X_add_symbol = symbol_find_or_make ((char *)myops[opnum].X_op_symbol);
	  myops[opnum].X_add_number = 0;
	  myops[opnum].X_op_symbol = NULL;
	}

      if (myops[opnum].X_op == O_constant || (myops[opnum].X_op == O_symbol &&
	  S_IS_DEFINED(myops[opnum].X_add_symbol) &&
	  (S_GET_SEGMENT(myops[opnum].X_add_symbol) == now_seg)))
	{
	  next_opcode=opcode+1;
	  for (i=0; opcode->operands[i+1]; i++)
	    {
	      int bits = d10v_operands[next_opcode->operands[opnum]].bits;
	      int flags = d10v_operands[next_opcode->operands[opnum]].flags;
	      if (flags & OPERAND_ADDR)
		bits += 2;
	      if (myops[opnum].X_op == O_constant)
		{
		  if (!check_range (myops[opnum].X_add_number, bits, flags))
		    return next_opcode;
		}
	      else
		{
		  fragS *f;
		  long value;
		  /* calculate the current address by running through the previous frags */
		  /* and adding our current offset */
		  for (value = 0, f = frchain_now->frch_root; f; f = f->fr_next)
		    value += f->fr_fix + f->fr_offset;

		  if (flags & OPERAND_ADDR)
		    value = S_GET_VALUE(myops[opnum].X_add_symbol) - value -
		      (obstack_next_free(&frchain_now->frch_obstack) - frag_now->fr_literal);
		  else
		    value = S_GET_VALUE(myops[opnum].X_add_symbol);

		  if (myops[opnum].X_add_number == AT_WORD)
		    {
		      if (bits > 4)
			{
			  bits += 2;
			  if (!check_range (value, bits, flags))
			    return next_opcode;
			}
		    }
		  else if (!check_range (value, bits, flags))
		    return next_opcode;
		}
	      next_opcode++;
	    }
	  as_fatal ("value out of range");
	}
      else
	{
	  /* not a constant, so use a long instruction */    
	  return opcode+2;
	}
    }
  else
    {
      match = 0;
      /* now search the opcode table table for one with operands */
      /* that matches what we've got */
      while (!match)
	{
	  match = 1;
	  for (i = 0; opcode->operands[i]; i++) 
	    {
	      int flags = d10v_operands[opcode->operands[i]].flags;
	      int X_op = myops[i].X_op;
	      int num = myops[i].X_add_number;

	      if (X_op==0)
		{
		  match=0;
		  break;
		}
	      
	      if (flags & OPERAND_REG)
		{
		  if ((X_op != O_register) ||
		      ((flags & OPERAND_ACC) != (num & OPERAND_ACC)) ||
		      ((flags & OPERAND_FLAG) != (num & OPERAND_FLAG)) ||
		      ((flags & OPERAND_CONTROL) != (num & OPERAND_CONTROL)))
		    {
		      match=0;
		      break;
		    }
		}
	      
	      if (((flags & OPERAND_MINUS) && ((X_op != O_absent) || (num != OPERAND_MINUS))) ||
		  ((flags & OPERAND_PLUS) && ((X_op != O_absent) || (num != OPERAND_PLUS))) ||
		  ((flags & OPERAND_ATMINUS) && ((X_op != O_absent) || (num != OPERAND_ATMINUS))) ||
		  ((flags & OPERAND_ATPAR) && ((X_op != O_absent) || (num != OPERAND_ATPAR))) ||
		  ((flags & OPERAND_ATSIGN) && ((X_op != O_absent) || (num != OPERAND_ATSIGN))))
		{
		  match=0;
		  break;
		}	      
	    }
	  /* we're only done if the operands matched so far AND there
	     are no more to check */
	  if (match && myops[i].X_op==0) 
	    break;
	  else
	    match = 0;

	  next_opcode = opcode+1;
	  if (next_opcode->opcode == 0) 
	    break;
	  if (strcmp(next_opcode->name, opcode->name))
	    break;
	  opcode = next_opcode;
	}
    }

  if (!match)  
    {
      as_bad ("bad opcode or operands");
      return (0);
    }

  /* Check that all registers that are required to be even are. */
  /* Also, if any operands were marked as registers, but were really symbols */
  /* fix that here. */
  for (i=0; opcode->operands[i]; i++) 
    {
      if ((d10v_operands[opcode->operands[i]].flags & OPERAND_EVEN) &&
	  (myops[i].X_add_number & 1)) 
	as_fatal("Register number must be EVEN");
      if (myops[i].X_op == O_register)
	{
	  if (!(d10v_operands[opcode->operands[i]].flags & OPERAND_REG)) 
	    {
	      myops[i].X_op = O_symbol;
	      myops[i].X_add_symbol = symbol_find_or_make ((char *)myops[i].X_op_symbol);
	      myops[i].X_add_number = 0;
	      myops[i].X_op_symbol = NULL;
	    }
	}
    }
  return opcode;
}

/* if while processing a fixup, a reloc really needs to be created */
/* then it is done here */
                 
arelent *
tc_gen_reloc (seg, fixp)
     asection *seg;
     fixS *fixp;
{
  arelent *reloc;
  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    "reloc %d not supported by object file format", (int)fixp->fx_r_type);
      return NULL;
    }
  reloc->addend = fixp->fx_addnumber;
  return reloc;
}

int
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp;
     asection *seg;
{
  abort ();
  return 0;
} 

long
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec;
{
  if (fixp->fx_addsy != (symbolS *)NULL && (!S_IS_DEFINED (fixp->fx_addsy) ||
      (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
    return 0;
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
     segT seg;
{
  char *where;
  unsigned long insn;
  long value;
  int op_type;
  int left=0;

  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    value = *valuep;
  else
    {
      value = fixp->fx_offset;
      if (fixp->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixp->fx_subsy);
	  else
	    {
	      /* We don't actually support subtracting a symbol.  */
 	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    "expression too complex");
	    }
	}
    }

  op_type = fixp->fx_r_type;
  if (op_type & 2048)
    {
      op_type -= 2048;
      if (op_type & 1024)
	{
	  op_type -= 1024;
	  fixp->fx_r_type = BFD_RELOC_D10V_10_PCREL_L;
	  left = 1;
	}
      else if (op_type & 4096)
	{
	  op_type -= 4096;
	  fixp->fx_r_type = BFD_RELOC_D10V_18;
	}
      else
	fixp->fx_r_type = get_reloc((struct d10v_operand *)&d10v_operands[op_type]); 
    }

  /* Fetch the instruction, insert the fully resolved operand
     value, and stuff the instruction back again.  */
  where = fixp->fx_frag->fr_literal + fixp->fx_where;
  insn = bfd_getb32 ((unsigned char *) where);

  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_D10V_10_PCREL_L:
    case BFD_RELOC_D10V_10_PCREL_R:
    case BFD_RELOC_D10V_18_PCREL:
    case BFD_RELOC_D10V_18:
      /* instruction addresses are always right-shifted by 2 */
      value >>= 2;
      if (fixp->fx_size == 2)
	bfd_putb16 ((bfd_vma) value, (unsigned char *) where);
      else
	{
	  insn = d10v_insert_operand (insn, op_type, (offsetT)value, left, fixp);
	  bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);  
	}
      break;
    case BFD_RELOC_32:
      bfd_putb32 ((bfd_vma) value, (unsigned char *) where);
      break;
    case BFD_RELOC_16:
      bfd_putb16 ((bfd_vma) value, (unsigned char *) where);
      break;
    default:
      as_fatal ("line %d: unknown relocation type: 0x%x",fixp->fx_line,fixp->fx_r_type);
    }
  return 0;
}

/* d10v_cleanup() is called after the assembler has finished parsing the input 
   file or after a label is defined.  Because the D10V assembler sometimes saves short 
   instructions to see if it can package them with the next instruction, there may
   be a short instruction that still needs written.  */
int
d10v_cleanup ()
{
  segT seg;
  subsegT subseg;

  if (prev_opcode)
    {
      seg = now_seg;
      subseg = now_subseg;
      subseg_set (prev_seg, prev_subseg);
      write_1_short (prev_opcode, prev_insn, fixups->next);
      subseg_set (seg, subseg);
      prev_opcode = NULL;
    }
  return 1;
}

/* Like normal .word, except support @@word */
/* clobbers input_line_pointer, checks end-of-line. */
static void
d10v_dot_word (nbytes)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
{
  expressionS exp;
  bfd_reloc_code_real_type reloc;
  char *p;
  int offset;

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);
      if (!strncasecmp (input_line_pointer, "@@word", 5))
	{
	  exp.X_add_number = 0;
	  input_line_pointer += 5;
	
	  p = frag_more (2);
	  fix_new_exp (frag_now, p - frag_now->fr_literal, 2, 
		       &exp, 0, BFD_RELOC_D10V_18);
	}
      else
	emit_expr (&exp, 2);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream. */
  demand_empty_rest_of_line ();
}


/* Mitsubishi asked that we support some old syntax that apparently */
/* had immediate operands starting with '#'.  This is in some of their */
/* sample code but is not documented (although it appears in some  */
/* examples in their assembler manual). For now, we'll solve this */
/* compatibility problem by simply ignoring any '#' at the beginning */
/* of an operand. */

/* operands that begin with '#' should fall through to here */
/* from expr.c */

void 
md_operand (expressionP)
     expressionS *expressionP;
{
  if (*input_line_pointer == '#')
    {
      input_line_pointer++;
      expression (expressionP);
    }
}

@


1.1.1.1
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
d38 1
a38 6
#define AT_WORD_P(X) ((X)->X_op == O_right_shift \
		      && (X)->X_op_symbol != NULL \
		      && symbol_constant_p ((X)->X_op_symbol) \
		      && S_GET_VALUE ((X)->X_op_symbol) == AT_WORD_RIGHT_SHIFT)
#define AT_WORD_RIGHT_SHIFT 2

a60 5
static int do_not_ignore_hash = 0;

/* True if instruction swapping warnings should be inhibited.  */
static unsigned char flag_warn_suppress_instructionswap; /* --nowarnswap */

a79 1
static symbolS * find_symbol_matching_register PARAMS ((expressionS *));
d81 1
a81 4
struct option md_longopts[] =
{
#define OPTION_NOWARNSWAP (OPTION_MD_BASE)
  {"nowarnswap", no_argument, NULL, OPTION_NOWARNSWAP},
d150 1
a150 1
      expressionP->X_op_symbol = (symbolS *)input_line_pointer;
d186 4
a189 13
      /* Signed 3-bit integers are restricted to the (-2, 3) range */
      if (flags & RESTRICTED_NUM3)
	{
	  if ((long) num < -2 || (long) num > 3)
	    retval = 1;
	}
      else
	{
	  max = (1 << (bits - 1)) - 1; 
	  min = - (1 << (bits - 1));  
	  if (((long) num > max) || ((long) num < min))
	    retval = 1;
	}
d206 2
a207 2
  fprintf(stream, _("D10V options:\n\
-O                      optimize.  Will do some operations in parallel.\n"));
a220 3
    case OPTION_NOWARNSWAP:
      flag_warn_suppress_instructionswap = 1;
      break;
d259 1
a259 1
      return _("bad call to md_atof");
d381 1
a381 2
  int uses_at = 0;
  
a390 2
	  uses_at = 1;
	  
d425 1
a425 14
	  if (uses_at)
	    {
	      /* Any expression that involves the indirect addressing
		 cannot also involve immediate addressing.  Therefore
		 the use of the hash character is illegal.  */
	      int save = do_not_ignore_hash;
	      do_not_ignore_hash = 1;
	      
	      expression (&exp[numops]);
	      
	      do_not_ignore_hash = save;
	    }
	  else
	    expression (&exp[numops]);
d428 1
a428 1
      if (strncasecmp (input_line_pointer, "@@word", 5) == 0)
a429 1
	  input_line_pointer += 5;
d432 2
a433 3
	      /* if it looked like a register name but was followed by
                 "@@word" then it was really a symbol, so change it to
                 one */
d436 1
d438 2
a439 22

	  /* check for identifier@@word+constant */
	  if (*input_line_pointer == '-' || *input_line_pointer == '+')
	  {
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;
	    expression (&new_exp);
	    exp[numops].X_add_number = new_exp.X_add_number;
	  }

	  /* convert expr into a right shift by AT_WORD_RIGHT_SHIFT */
	  {
	    expressionS new_exp;
	    memset (&new_exp, 0, sizeof new_exp);
	    new_exp.X_add_number = AT_WORD_RIGHT_SHIFT;
	    new_exp.X_op = O_constant;
	    new_exp.X_unsigned = 1;
	    exp[numops].X_op_symbol = make_expr_symbol (&new_exp);
	    exp[numops].X_op = O_right_shift;
	  }

	  know (AT_WORD_P (&exp[numops]));
d443 1
a443 1
	as_bad (_("illegal operand"));
d445 1
a445 1
	as_bad (_("missing operand"));
d485 1
a485 1
    as_bad_where (fix->fx_file, fix->fx_line, _("operand out of range: %d"), value);
d504 1
a504 1
  unsigned long number;
d534 1
a534 1
	    as_fatal (_("too many fixups"));
d536 1
a536 1
	  if (AT_WORD_P (&opers[i]))
d538 1
a538 1
	      /* Reconize XXX>>1+N aka XXX@@word+N as special (AT_WORD) */
d540 3
a542 12
	      opers[i].X_op = O_symbol;
	      opers[i].X_op_symbol = NULL; /* Should free it */
	      /* number is left shifted by AT_WORD_RIGHT_SHIFT so
                 that, it is aligned with the symbol's value.  Later,
                 BFD_RELOC_D10V_18 will right shift (symbol_value +
                 X_add_number). */
	      number <<= AT_WORD_RIGHT_SHIFT;
	      opers[i].X_add_number = number;
	    }
	  else
	    fixups->fix[fixups->fc].reloc = 
	      get_reloc((struct d10v_operand *)&d10v_operands[opcode->operands[i]]);
d558 1
a558 1
	as_bad (_("operand out of range: %d"),number);
d619 1
a619 1
    as_fatal (_("Instruction must be executed in parallel with another instruction."));
d671 1
a671 1
    as_fatal (_("Instruction must be executed in parallel"));
d674 1
a674 1
    as_fatal (_("Long instructions may not be combined."));
d676 1
a676 1
  if(opcode1->exec_type & BRANCH_LINK && exec_type == 0)
d678 2
a679 2
      /* Instructions paired with a subroutine call are executed before the
	 subroutine, so don't do these pairings unless explicitly requested.  */
d714 1
a714 1
	as_fatal (_("One of these instructions may not be executed in parallel."));
d719 2
a720 3
	    as_fatal (_("Two IU instructions may not be executed in parallel"));
          if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
d726 2
a727 3
	    as_fatal (_("Two MU instructions may not be executed in parallel"));
          if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
d737 3
a739 10
      if (opcode1->unit != IU)
	insn = FM01 | (insn1 << 15) | insn2;  
      else if (opcode2->unit == MU || opcode2->unit == EITHER)
	{
          if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM10 | (insn2 << 15) | insn1;  
	}
      else
	as_fatal (_("IU instruction may not be in the left container"));
d743 3
a745 10
      if (opcode2->unit != MU)
	insn = FM10 | (insn1 << 15) | insn2;
      else if (opcode1->unit == IU || opcode1->unit == EITHER)
	{
          if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM01 | (insn2 << 15) | insn1;  
	}
      else
	as_fatal (_("MU instruction may not be in the right container"));
d749 1
a749 1
      as_fatal (_("unknown execution type passed to write_2_short()"));
d810 9
a818 14
  /* The idea here is to create two sets of bitmasks (mod and used)
     which indicate which registers are modified or used by each
     instruction.  The operation can only be done in parallel if
     instruction 1 and instruction 2 modify different registers, and
     the first instruction does not modify registers that the second
     is using (The second instruction can modify registers that the
     first is using as they are only written back after the first
     instruction has completed).  Accesses to control registers, PSW,
     and memory are treated as accesses to a single register.  So if
     both instructions write memory or if the first instruction writes
     memory and the second reads, then they cannot be done in
     parallel.  Likewise, if the first instruction mucks with the psw
     and the second reads the PSW (which includes C, F0, and F1), then
     they cannot operate safely in parallel. */
d851 1
a851 1
	      if (flags & (OPERAND_ACC0|OPERAND_ACC1))
d860 1
a860 1
	      else if (flags & (OPERAND_FFLAG|OPERAND_CFLAG))
a873 6

		  /* Auto inc/dec also modifies the register.  */
		  if (op->operands[i+1] != 0
		      && (d10v_operands[op->operands[i+1]].flags
			  & (OPERAND_PLUS | OPERAND_MINUS)) != 0)
		    mod[j] |= 1 << regno;
a875 6
	  else if (flags & OPERAND_ATMINUS)
	    {
	      /* SP implicitly used/modified */
	      mod[j] |= 1 << 15;
	      used[j] |= 1 << 15;
	    }
d888 1
a888 1
  if ((mod[0] & mod[1]) == 0 && (mod[0] & used[1]) == 0)
a903 1
static int etype = 0;		/* saved extype.  used for multiline instructions */
d909 1
a909 1
  struct d10v_opcode * opcode;
d911 3
a913 2
  int extype = 0;		/* execution type; parallel, etc */
  char * str2;
d940 1
a940 1
	  d10v_cleanup ();
d945 1
a945 1
	    as_fatal (_("can't find opcode "));
d959 1
a959 1
      as_fatal (_("can't find opcode "));
d972 2
a973 2
	as_fatal (_("Unable to mix instructions as specified"));
      d10v_cleanup ();
d990 1
a990 1
	as_fatal (_("Unable to mix instructions as specified"));
d1016 1
a1016 1
  /* Drop leading whitespace.  */
d1020 1
a1020 1
  /* Find the opcode end.  */
d1027 1
a1027 1
      name[nlen] = tolower (op_start[nlen]);
d1033 1
a1033 1
    return -1;
d1035 1
a1035 1
  /* Find the first opcode with the proper name.  */
d1038 1
a1038 1
      as_fatal (_("unknown opcode: %s"),name);
a1050 23
/* Find the symbol which has the same name as the register in the given expression.  */
static symbolS *
find_symbol_matching_register (exp)
     expressionS * exp;
{
  int i;
  
  if (exp->X_op != O_register)
    return NULL;
  
  /* Find the name of the register.  */
  for (i = d10v_reg_name_cnt (); i--;)
    if (d10v_predefined_registers [i].value == exp->X_add_number)
      break;

  if (i < 0)
    abort ();

  /* Now see if a symbol has been defined with the same name.  */
  return symbol_find (d10v_predefined_registers [i].name);
}


a1070 1
      int flags;
a1079 20
      next_opcode=opcode+1;

      /* If the first operand is supposed to be a register, make sure
	 we got a valid one.  */
      flags = d10v_operands[next_opcode->operands[0]].flags;
      if (flags & OPERAND_REG)
	{
	  int X_op = myops[0].X_op;
	  int num = myops[0].X_add_number;

	  if (X_op != O_register
	      || (num & ~flags
		  & (OPERAND_GPR | OPERAND_ACC0 | OPERAND_ACC1
		     | OPERAND_FFLAG | OPERAND_CFLAG | OPERAND_CONTROL)))
	    {
	      as_bad (_("bad opcode or operands"));
	      return 0;
	    }
	}

d1084 1
d1109 1
a1109 1
		    value += S_GET_VALUE(myops[opnum].X_add_symbol);
d1111 1
a1111 1
		  if (AT_WORD_P (&myops[opnum]))
d1125 1
a1125 1
	  as_fatal (_("value out of range"));
d1147 1
a1147 1
	      if (X_op == 0)
d1149 1
a1149 1
		  match = 0;
d1155 4
a1158 5
		  if ((X_op != O_register)
		      || (num & ~flags
			  & (OPERAND_GPR | OPERAND_ACC0 | OPERAND_ACC1
			     | OPERAND_FFLAG | OPERAND_CFLAG
			     | OPERAND_CONTROL)))
d1160 1
a1160 1
		      match = 0;
d1165 2
a1166 2
	      if (((flags & OPERAND_MINUS)   && ((X_op != O_absent) || (num != OPERAND_MINUS))) ||
		  ((flags & OPERAND_PLUS)    && ((X_op != O_absent) || (num != OPERAND_PLUS))) ||
d1168 2
a1169 2
		  ((flags & OPERAND_ATPAR)   && ((X_op != O_absent) || (num != OPERAND_ATPAR))) ||
		  ((flags & OPERAND_ATSIGN)  && ((X_op != O_absent) || ((num != OPERAND_ATSIGN) && (num != OPERAND_ATPAR)))))
d1171 1
a1171 1
		  match = 0;
d1173 1
a1173 25
		}
	      
	      /* Unfortunatly, for the indirect operand in instructions such as
		 ``ldb r1, @@(c,r14)'' this function can be passed X_op == O_register
		 (because 'c' is a valid register name).  However we cannot just
		 ignore the case when X_op == O_register but flags & OPERAND_REG is
		 null, so we check to see if a symbol of the same name as the register
		 exists.  If the symbol does exist, then the parser was unable to
		 distinguish the two cases and we fix things here.  (Ref: PR14826) */
	      
	      if (!(flags & OPERAND_REG) && (X_op == O_register))
		{
		  symbolS * sym;
		  
		  sym = find_symbol_matching_register (& myops[i]);
		  
		  if (sym != NULL)
		    {
		      myops [i].X_op == X_op == O_symbol;
		      myops [i].X_add_symbol = sym;
		    }
		  else
		    as_bad
		      (_("illegal operand - register name found where none expected"));
		}
d1175 3
a1177 4
	  
	  /* We're only done if the operands matched so far AND there
	     are no more to check.  */
	  if (match && myops[i].X_op == 0) 
d1182 1
a1182 2
	  next_opcode = opcode + 1;
	  
d1185 1
a1185 2
	  
	  if (strcmp (next_opcode->name, opcode->name))
a1186 1
	  
d1193 1
a1193 1
      as_bad (_("bad opcode or operands"));
d1204 1
a1204 1
	as_fatal (_("Register number must be EVEN"));
d1229 1
a1229 2
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d1235 1
a1235 1
                    _("reloc %d not supported by object file format"), (int)fixp->fx_r_type);
a1237 5

  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

a1238 1

d1292 1
a1292 1
			    _("expression too complex"));
d1328 1
a1328 1
      value >>= AT_WORD_RIGHT_SHIFT;
a1332 11
	  struct d10v_opcode *rep, *repi;

	  rep = (struct d10v_opcode *) hash_find (d10v_hash, "rep");
	  repi = (struct d10v_opcode *) hash_find (d10v_hash, "repi");
	  if ((insn & FM11) == FM11
	      && (repi != NULL && (insn & repi->mask) == repi->opcode
		  || rep != NULL && (insn & rep->mask) == rep->opcode)
	      && value < 4)
	    as_fatal
	      (_("line %d: rep or repi must include at least 4 instructions"),
	       fixp->fx_line);
a1342 6

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixp->fx_done = 0;
      return 1;

d1344 1
a1344 1
      as_fatal (_("line %d: unknown relocation type: 0x%x"),fixp->fx_line,fixp->fx_r_type);
d1359 1
a1359 1
  if (prev_opcode && etype == 0)
d1363 1
a1363 2
      if (prev_seg)
	subseg_set (prev_seg, prev_subseg);
d1424 1
a1424 1
  if (*input_line_pointer == '#' && ! do_not_ignore_hash)
a1430 32
boolean
d10v_fix_adjustable (fixP)
   fixS *fixP;
{

  if (fixP->fx_addsy == NULL)
    return 1;
  
  /* Prevent all adjustments to global symbols. */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;

  /* We need the symbol name for the VTABLE entries */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}

int
d10v_force_relocation (fixp)
      struct fix *fixp;
{
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

  return 0;
}
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d24 1
a24 1
#include "subsegs.h"
a26 1
//#include "read.h"
d43 2
a44 1
/* Fixups.  */
d67 2
a68 14
typedef int packing_type;
#define PACK_UNSPEC 	(0)	/* Packing order not specified.  */
#define PACK_PARALLEL	(1)	/* "||"  */
#define PACK_LEFT_RIGHT (2)	/* "->"  */
#define PACK_RIGHT_LEFT (3)	/* "<-"  */
static packing_type etype = PACK_UNSPEC; /* Used by d10v_cleanup.  */

/* True if instruction swapping warnings should be inhibited.
   --nowarnswap.  */
static boolean flag_warn_suppress_instructionswap;

/* True if instruction packing should be performed when --gstabs is specified.
   --gstabs-packing, --no-gstabs-packing.  */
static boolean flag_allow_gstabs_packing = 1;
d70 1
a70 1
/* Local functions.  */
d79 1
a79 1
static void write_long PARAMS ((unsigned long insn, Fixups *fx));
d81 2
a82 2
static int write_2_short PARAMS ((struct d10v_opcode *opcode1, unsigned long insn1,
				  struct d10v_opcode *opcode2, unsigned long insn2, packing_type exec_type, Fixups *fx));
d86 1
a86 1
static int parallel_ok PARAMS ((struct d10v_opcode *opcode1, unsigned long insn1,
d88 1
a88 1
				packing_type exec_type));
a94 6
#define OPTION_GSTABSPACKING (OPTION_MD_BASE + 1)
  {"gstabspacking",  no_argument, NULL, OPTION_GSTABSPACKING},
  {"gstabs-packing", no_argument, NULL, OPTION_GSTABSPACKING},
#define OPTION_NOGSTABSPACKING (OPTION_MD_BASE + 2)
  {"nogstabspacking",   no_argument, NULL, OPTION_NOGSTABSPACKING},
  {"no-gstabs-packing", no_argument, NULL, OPTION_NOGSTABSPACKING},
d97 1
a97 2

size_t md_longopts_size = sizeof (md_longopts);
d111 3
a113 3
/* Do a binary search of the d10v_predefined_registers array to see if
   NAME is a valid regiter name.  Return the register number from the
   array on success, or -1 on failure.  */
d123 1
a123 1
  high = d10v_reg_name_cnt () - 1;
d133 2
a134 2
      else
	return d10v_predefined_registers[middle].value;
d140 2
a141 2
/* Check the string at input_line_pointer
   to see if it is a valid register name.  */
d149 2
a150 3

  while (*p
	 && *p != '\n' && *p != '\r' && *p != ',' && *p != ' ' && *p != ')')
d157 1
a157 1
  /* Look to see if it's in the register table.  */
d159 1
a159 1
  if (reg_number >= 0)
d162 2
a163 2
      /* Temporarily store a pointer to the string here.  */
      expressionP->X_op_symbol = (symbolS *) input_line_pointer;
d169 1
a169 1
    *(p - 1) = c;
d173 1
d180 2
a181 2
  long min, max;
  int retval = 0;
d183 1
a183 1
  /* Don't bother checking 16-bit values.  */
d189 3
a191 3
      /* All special shift operands are unsigned and <= 16.
	 We allow 0 for now.  */
      if (num > 16)
d199 1
a199 1
      /* Signed 3-bit integers are restricted to the (-2, 3) range.  */
d207 2
a208 2
	  max = (1 << (bits - 1)) - 1;
	  min = - (1 << (bits - 1));
d217 1
a217 1
      if (((long) num > max) || ((long) num < min))
d223 1
d226 1
a226 1
     FILE *stream;
d228 3
a230 7
  fprintf (stream, _("D10V options:\n\
-O                      Optimize.  Will do some operations in parallel.\n\
--gstabs-packing        Pack adjacent short instructions together even\n\
                        when --gstabs is specified.  On by default.\n\
--no-gstabs-packing     If --gstabs is specified, do not pack adjacent\n\
                        instructions together.\n"));
}
d235 1
a235 1
     char *arg ATTRIBUTE_UNUSED;
d240 1
a240 1
      /* Optimize. Will attempt to parallelize operations.  */
a245 6
    case OPTION_GSTABSPACKING:
      flag_allow_gstabs_packing = 1;
      break;
    case OPTION_NOGSTABSPACKING:
      flag_allow_gstabs_packing = 0;
      break;
d254 1
a254 1
     char *name ATTRIBUTE_UNUSED;
d259 4
a262 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d273 1
a273 1

d290 1
a290 1

d292 1
a292 1

d296 1
a296 1
      litP += 2;
d303 3
a305 3
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d319 1
d325 1
a325 1
  d10v_hash = hash_new ();
d332 1
a332 1
  for (opcode = (struct d10v_opcode *) d10v_opcodes; opcode->name; opcode++)
d336 1
a336 1
	  prev_name = (char *) opcode->name;
a345 2
/* Remove the postincrement or postdecrement operator ( '+' or '-' )
   from an expression.  */
d347 4
a350 2
static int
postfix (p)
d353 1
a353 1
  while (*p != '-' && *p != '+')
d355 1
a355 1
      if (*p == 0 || *p == '\n' || *p == '\r')
d360 1
a360 1
  if (*p == '-')
d365 1
a365 1
  if (*p == '+')
d374 3
a376 2
static bfd_reloc_code_real_type
get_reloc (op)
d381 1
a381 1
  if (bits <= 4)
d383 2
a384 2

  if (op->flags & OPERAND_ADDR)
d395 3
a397 1
/* Parse a string of operands.  Return an array of expressions.  */
d400 1
a400 1
get_operands (exp)
d407 2
a408 2

  while (*p)
d410 1
a410 1
      while (*p == ' ' || *p == '\t' || *p == ',')
d412 1
a412 1
      if (*p == 0 || *p == '\n' || *p == '\r')
d414 2
a415 2

      if (*p == '@@')
d418 1
a418 1

d421 1
a421 1
	  if (*p == '(')
d426 1
a426 1
	  else if (*p == '-')
d440 1
a440 1
      if (*p == ')')
d442 1
a442 1
	  /* Just skip the trailing paren.  */
d449 1
a449 1
      /* Check to see if it might be a register name.  */
d452 1
a452 1
	  /* Parse as an expression.  */
d460 1
a460 1

d462 1
a462 1

d474 1
a474 1
	      /* If it looked like a register name but was followed by
d476 1
a476 1
                 one.  */
d478 1
a478 2
	      exp[numops].X_add_symbol =
		symbol_find_or_make ((char *) exp[numops].X_op_symbol);
d481 1
a481 1
	  /* Check for identifier@@word+constant.  */
d483 6
a488 5
	    {
	      expressionS new_exp;
	      expression (&new_exp);
	      exp[numops].X_add_number = new_exp.X_add_number;
	    }
d490 1
a490 1
	  /* Convert expr into a right shift by AT_WORD_RIGHT_SHIFT.  */
d503 2
a504 2

      if (exp[numops].X_op == O_illegal)
d506 1
a506 1
      else if (exp[numops].X_op == O_absent)
d513 1
a513 1
  switch (post)
d515 1
a515 1
    case -1:	/* Postdecrement mode.  */
d519 1
a519 1
    case 1:	/* Postincrement mode.  */
d530 1
a530 1
d10v_insert_operand (insn, op_type, value, left, fix)
d545 1
a545 1
  /* Truncate to the proper number of bits.  */
d547 1
a547 2
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("operand out of range: %d"), value);
d555 3
a557 2
/* Take a pointer to the opcode entry in the opcode table and the
   array of operand expressions.  Return the instruction.  */
d560 1
a560 1
build_insn (opcode, opers, insn)
d567 2
a568 2

  /* The insn argument is only used for the DIVS kludge.  */
d576 2
a577 2

  for (i = 0; opcode->operands[i]; i++)
d584 1
a584 1
      if (flags & OPERAND_REG)
d591 1
a591 1
      if (opers[i].X_op != O_register && opers[i].X_op != O_constant)
d593 1
a593 1
	  /* Now create a fixup.  */
d600 1
a600 1
	      /* Reconize XXX>>1+N aka XXX@@word+N as special (AT_WORD).  */
d603 1
a603 1
	      opers[i].X_op_symbol = NULL; /* Should free it.  */
d607 1
a607 1
                 X_add_number).  */
d612 2
a613 2
	    fixups->fix[fixups->fc].reloc =
	      get_reloc ((struct d10v_operand *) &d10v_operands[opcode->operands[i]]);
d615 1
a615 1
	  if (fixups->fix[fixups->fc].reloc == BFD_RELOC_16 ||
d617 1
a617 1
	    fixups->fix[fixups->fc].size = 2;
d620 1
a620 1

d623 1
a623 2
	  fixups->fix[fixups->fc].pcrel =
	    (flags & OPERAND_ADDR) ? true : false;
d627 1
a627 1
      /* Truncate to the proper number of bits.  */
d629 1
a629 1
	as_bad (_("operand out of range: %d"), number);
d634 4
a637 4
  /* kludge: for DIVS, we need to put the operands in twice  */
  /* on the second pass, format is changed to LONG_R to force
     the second set of operands to not be shifted over 15.  */
  if ((opcode->opcode == OPCODE_DIVS) && (format == LONG_L))
d639 1
a639 1

d643 1
a643 2
/* Write out a long form instruction.  */

d645 2
a646 1
write_long (insn, fx)
d651 1
a651 1
  char *f = frag_more (4);
d656 1
a656 1
  for (i = 0; i < fx->fc; i++)
d659 2
a660 2
	{
	  where = f - frag_now->fr_literal;
d665 1
a665 1
	    fx->fix[i].operand |= 4096;
a677 1
/* Write out a short form instruction by itself.  */
d679 1
d681 1
a681 1
write_1_short (opcode, insn, fx)
d686 1
a686 1
  char *f = frag_more (4);
d692 3
a694 3
  /* The other container needs to be NOP.  */
  /* According to 4.3.1: for FM=00, sub-instructions performed only
     by IU cannot be encoded in L-container.  */
d696 1
a696 1
    insn |= FM00 | (NOP << 15);		/* Right container.  */
d698 1
a698 1
    insn = FM00 | (insn << 15) | NOP;	/* Left container.  */
d701 1
a701 1
  for (i = 0; i < fx->fc; i++)
d704 2
a705 2
	{
	  where = f - frag_now->fr_literal;
d710 1
a710 1
	    fx->fix[i].operand |= 4096;
d712 2
a713 3
	  /* If it's an R reloc, we may have to switch it to L.  */
	  if ((fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R)
	      && (opcode->unit != IU))
d717 1
a717 1
		       where,
d727 2
a728 5
/* Expects two short instructions.
   If possible, writes out both as a single packed instruction.
   Otherwise, writes out the first one, packed with a NOP.
   Returns number of instructions not written out.  */

d730 1
a730 1
write_2_short (opcode1, insn1, opcode2, insn2, exec_type, fx)
d733 1
a733 1
     packing_type exec_type;
d738 1
a738 1
  int i, j, where;
d740 2
a741 2
  if ((exec_type != PACK_PARALLEL)
      && ((opcode1->exec_type & PARONLY) || (opcode2->exec_type & PARONLY)))
d743 3
d747 7
a753 2
  if ((opcode1->format & LONG_OPCODE) || (opcode2->format & LONG_OPCODE))
    as_fatal (_("Long instructions may not be combined."));
d755 1
a755 1
  switch (exec_type)
d757 2
a758 2
    case PACK_UNSPEC:	/* Order not specified.  */
      if (opcode1->exec_type & ALONE)
d760 1
a760 9
	  /* Case of a short branch on a separate GAS line.
	     Pack with NOP.  */
	  write_1_short (opcode1, insn1, fx->next);
	  return 1;
	}
      if (Optimizing
	  && parallel_ok (opcode1, insn1, opcode2, insn2, exec_type))
	{
	  /* Parallel.  */
d767 1
a767 2
	      insn = FM00 | (insn1 << 15) | insn2;
	      /* Advance over dummy fixup since packed insn1 in L.  */
d771 5
a775 3
      else if (opcode1->unit == IU)
	/* Reverse sequential with IU opcode1 on right and done first.  */
	insn = FM10 | (insn2 << 15) | insn1;
d778 1
a778 1
	  /* Sequential with non-IU opcode1 on left and done first.  */
d780 1
a780 2
	  /* Advance over dummy fixup since packed insn1 in L.  */
	  fx = fx->next;
d783 3
a786 4
    case PACK_PARALLEL:
      if (opcode1->exec_type & SEQ || opcode2->exec_type & SEQ)
	as_fatal
	  (_("One of these instructions may not be executed in parallel."));
d791 1
a791 1
	  if (!flag_warn_suppress_instructionswap)
d793 1
a793 1
	  insn = FM00 | (insn2 << 15) | insn1;
d799 1
a799 1
	  if (!flag_warn_suppress_instructionswap)
d805 1
a805 2
	  insn = FM00 | (insn1 << 15) | insn2;
	  /* Advance over dummy fixup since packed insn1 in L.  */
d809 1
a809 2

    case PACK_LEFT_RIGHT:
d811 1
a811 1
	insn = FM01 | (insn1 << 15) | insn2;
d814 1
a814 1
	  if (!flag_warn_suppress_instructionswap)
d816 1
a816 1
	  insn = FM10 | (insn2 << 15) | insn1;
a819 3
      if (opcode1->exec_type & ALONE)
	as_warn (_("Instruction in R container is squashed by flow control instruction in L container."));
      /* Advance over dummy fixup.  */
d822 1
a822 2

    case PACK_RIGHT_LEFT:
d827 1
a827 1
	  if (!flag_warn_suppress_instructionswap)
d829 1
a829 1
	  insn = FM01 | (insn2 << 15) | insn1;
a832 3
      if (opcode2->exec_type & ALONE)
	as_warn (_("Instruction in R container is squashed by flow control instruction in L container."));
      /* Advance over dummy fixup.  */
a834 1

d839 1
a839 1
  f = frag_more (4);
d842 1
a842 9
  /* Process fixup chains.
     Note that the packing code above advanced fx conditionally.
     dlindsay@@cygnus.com:  There's something subtle going on here involving
	_dummy_first_bfd_reloc_code_real.  This is related to the
	difference between BFD_RELOC_D10V_10_PCREL_R and _L, ie whether
	a fixup is done in the L or R container.  A bug in this code
	can pass Plum Hall fine, yet still affect hand-written assembler.  */

  for (j = 0; j < 2; j++)
d844 1
a844 1
      for (i = 0; i < fx->fc; i++)
d848 1
a848 1
	      where = f - frag_now->fr_literal;
d851 2
a852 2

	      if ((fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R) && (j == 0))
d854 1
a854 1

d856 1
a856 1
		fx->fix[i].operand |= 4096;
d859 1
a859 1
			   where,
a871 2
/* Check 2 instructions and determine if they can be safely
   executed in parallel.  Return 1 if they can be.  */
d873 2
d879 1
a879 1
     packing_type exec_type;
d892 3
a894 4
  /* If this is auto parallization, and either instruction is a branch,
     don't parallel.  */
  if (exec_type == PACK_UNSPEC
      && (op1->exec_type & ALONE || op2->exec_type & ALONE))
d910 1
a910 1
     they cannot operate safely in parallel.  */
d912 6
a917 6
  /* The bitmasks (mod and used) look like this (bit 31 = MSB).  */
  /* r0-r15	  0-15   */
  /* a0-a1	  16-17  */
  /* cr (not psw) 18     */
  /* psw	  19     */
  /* mem	  20     */
d919 1
a919 1
  for (j = 0; j < 2; j++)
d943 1
a943 1
	      if (flags & (OPERAND_ACC0 | OPERAND_ACC1))
d945 2
a946 2
	      else if (flags & OPERAND_CONTROL)	/* mvtc or mvfc.  */
		{
d950 1
a950 1
		    regno = 18;
d952 1
a952 1
	      else if (flags & (OPERAND_FFLAG | OPERAND_CFLAG))
d954 2
a955 2

	      if (flags & OPERAND_DEST)
d963 1
a963 1
		  used[j] |= 1 << regno;
d968 2
a969 2
		  if (op->operands[i + 1] != 0
		      && (d10v_operands[op->operands[i + 1]].flags
d976 1
a976 1
	      /* SP implicitly used/modified.  */
d997 6
a1002 5
/* This is the main entry point for the machine-dependent assembler.
   STR points to a machine-dependent instruction.  This function is
   supposed to emit the frags/bytes it assembles to.  For the D10V, it
   mostly handles the special VLIW parsing and packing and leaves the
   difficult stuff to do_assemble().  */
d1008 1
d1014 1
a1014 5
  /* etype is saved extype.  For multi-line instructions.  */

  packing_type extype = PACK_UNSPEC;		/* Parallel, etc.  */

  struct d10v_opcode *opcode;
d1016 2
a1017 1
  char *str2;
d1019 1
a1019 1
  if (etype == PACK_UNSPEC)
d1021 1
a1021 1
      /* Look for the special multiple instruction separators.  */
d1023 2
a1024 2
      if (str2)
	extype = PACK_PARALLEL;
d1028 2
a1029 2
	  if (str2)
	    extype = PACK_LEFT_RIGHT;
d1033 2
a1034 2
	      if (str2)
		extype = PACK_RIGHT_LEFT;
d1037 2
a1038 2
      /* STR2 points to the separator, if there is one.  */
      if (str2)
d1041 3
a1043 3

	  /* If two instructions are present and we already have one saved,
	     then first write out the saved one.  */
d1045 2
a1046 2

	  /* Assemble first instruction and save it.  */
d1048 1
a1048 3
	  prev_seg = now_seg;
	  prev_subseg = now_subseg;
	  if (prev_insn == (unsigned long) -1)
d1056 1
a1056 1
  if (insn == (unsigned long) -1)
d1058 1
a1058 1
      if (extype != PACK_UNSPEC)
d1066 1
a1066 1
  if (etype != PACK_UNSPEC)
d1069 1
a1069 1
      etype = PACK_UNSPEC;
d1072 2
a1073 3
  /* If this is a long instruction, write it and any previous short
     instruction.  */
  if (opcode->format & LONG_OPCODE)
d1075 1
a1075 1
      if (extype != PACK_UNSPEC)
d1078 1
a1078 1
      write_long (insn, fixups);
d1082 5
a1086 8

  if (prev_opcode
      && prev_seg
      && ((prev_seg != now_seg) || (prev_subseg != now_subseg)))
    d10v_cleanup ();

  if (prev_opcode
      && (write_2_short (prev_opcode, prev_insn, opcode, insn, extype, fixups) == 0))
d1088 1
a1088 1
      /* No instructions saved.  */
d1093 1
a1093 1
      if (extype != PACK_UNSPEC)
d1095 1
a1095 1
      /* Save last instruction so it may be packed on next pass.  */
d1104 3
a1106 2
/* Assemble a single instruction.
   Return an opcode, or -1 (an invalid opcode) on error.  */
d1109 1
a1109 1
do_assemble (str, opcode)
d1138 1
a1138 1

d1140 1
a1140 1
  *opcode = (struct d10v_opcode *) hash_find (d10v_hash, name);
d1142 1
a1142 1
    as_fatal (_("unknown opcode: %s"), name);
d1151 1
a1151 1
  insn = build_insn ((*opcode), myops, 0);
d1155 1
a1155 2
/* Find the symbol which has the same name as the register in EXP.  */

d1158 1
a1158 1
     expressionS *exp;
d1161 1
a1161 1

d1164 1
a1164 1

d1167 1
a1167 1
    if (d10v_predefined_registers[i].value == exp->X_add_number)
d1174 1
a1174 1
  return symbol_find (d10v_predefined_registers[i].name);
d1177 4
a1180 3
/* Get a pointer to an entry in the opcode table.
   The function must look at all opcodes with the same name and use
   the operands to choose the correct opcode.  */
d1187 1
a1187 1
  int i, match;
d1190 1
a1190 1
  /* Get all the operands and save them as expressions.  */
d1193 2
a1194 2
  /* Now see if the operand is a fake.  If so, find the correct size
     instruction, if possible.  */
d1199 1
a1199 1

d1203 1
a1203 2
	  myops[opnum].X_add_symbol =
	    symbol_find_or_make ((char *) myops[opnum].X_op_symbol);
d1208 1
a1208 1
      next_opcode = opcode + 1;
d1228 3
a1230 4
      if (myops[opnum].X_op == O_constant
	  || (myops[opnum].X_op == O_symbol
	      && S_IS_DEFINED (myops[opnum].X_add_symbol)
	      && (S_GET_SEGMENT (myops[opnum].X_add_symbol) == now_seg)))
d1232 1
a1232 1
	  for (i = 0; opcode->operands[i + 1]; i++)
a1237 1

a1244 1
		  fragS *sym_frag;
d1246 5
a1250 29
		  unsigned long current_position;
		  unsigned long symbol_position;
		  unsigned long value;
		  boolean found_symbol;

		  /* Calculate the address of the current instruction
		     and the address of the symbol.  Do this by summing
		     the offsets of previous frags until we reach the
		     frag containing the symbol, and the current frag.  */
		  sym_frag = symbol_get_frag (myops[opnum].X_add_symbol);
		  found_symbol = false;

		  current_position =
		    obstack_next_free (&frchain_now->frch_obstack)
		    - frag_now->fr_literal;
		  symbol_position = S_GET_VALUE (myops[opnum].X_add_symbol);

		  for (f = frchain_now->frch_root; f; f = f->fr_next)
		    {
		      current_position += f->fr_fix + f->fr_offset;

		      if (f == sym_frag)
			found_symbol = true;

		      if (! found_symbol)
			symbol_position += f->fr_fix + f->fr_offset;
		    }

		  value = symbol_position;
d1253 4
a1256 1
		    value -= current_position;
d1276 2
a1277 2
	  /* Not a constant, so use a long instruction.  */
	  return opcode + 2;
d1283 2
a1284 2
      /* Now search the opcode table table for one with operands
	 that matches what we've got.  */
d1288 1
a1288 1
	  for (i = 0; opcode->operands[i]; i++)
d1299 1
a1299 1

d1312 1
a1312 1

d1322 9
a1330 12

	      /* Unfortunatly, for the indirect operand in
		 instructions such as ``ldb r1, @@(c,r14)'' this
		 function can be passed X_op == O_register (because
		 'c' is a valid register name).  However we cannot
		 just ignore the case when X_op == O_register but
		 flags & OPERAND_REG is null, so we check to see if a
		 symbol of the same name as the register exists.  If
		 the symbol does exist, then the parser was unable to
		 distinguish the two cases and we fix things here.
		 (Ref: PR14826)  */

d1333 4
a1336 2
		  symbolS *sym = find_symbol_matching_register (&myops[i]);

d1339 2
a1340 2
		      myops[i].X_op = X_op = O_symbol;
		      myops[i].X_add_symbol = sym;
d1347 1
a1347 1

d1350 1
a1350 1
	  if (match && myops[i].X_op == 0)
d1356 2
a1357 2

	  if (next_opcode->opcode == 0)
d1359 1
a1359 1

d1362 1
a1362 1

d1367 1
a1367 1
  if (!match)
d1373 4
a1376 4
  /* Check that all registers that are required to be even are.
     Also, if any operands were marked as registers, but were really symbols,
     fix that here.  */
  for (i = 0; opcode->operands[i]; i++)
d1379 1
a1379 1
	  (myops[i].X_add_number & 1))
d1383 1
a1383 1
	  if (!(d10v_operands[opcode->operands[i]].flags & OPERAND_REG))
d1386 1
a1386 2
	      myops[i].X_add_symbol =
		symbol_find_or_make ((char *) myops[i].X_op_symbol);
d1395 3
a1397 3
/* If while processing a fixup, a reloc really needs to be created.
   Then it is done here.  */

d1400 1
a1400 1
     asection *seg ATTRIBUTE_UNUSED;
d1412 1
a1412 2
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
d1427 2
a1428 2
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
d1432 1
a1432 1
}
d1439 2
a1440 3
  if (fixp->fx_addsy != (symbolS *) NULL
      && (!S_IS_DEFINED (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
d1449 1
a1449 1
     segT seg ATTRIBUTE_UNUSED;
d1455 1
a1455 1
  int left = 0;
d1474 1
a1474 1
	      as_bad_where (fixp->fx_file, fixp->fx_line,
d1496 1
a1496 2
	fixp->fx_r_type =
	  get_reloc ((struct d10v_operand *) &d10v_operands[op_type]);
d1510 1
a1510 1
      /* Instruction addresses are always right-shifted by 2.  */
d1521 2
a1522 2
	      && (  (repi != NULL && (insn & repi->mask) == (unsigned) repi->opcode)
		  || (rep != NULL && (insn & rep->mask) == (unsigned) rep->opcode))
d1527 2
a1528 3
	  insn =
	    d10v_insert_operand (insn, op_type, (offsetT) value, left, fixp);
	  bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
d1544 1
a1544 2
      as_fatal (_("line %d: unknown relocation type: 0x%x"),
		fixp->fx_line, fixp->fx_r_type);
d1549 4
a1552 10
/* d10v_cleanup() is called after the assembler has finished parsing
   the input file, when a label is read from the input file, or when a
   stab directive is output.  Because the D10V assembler sometimes
   saves short instructions to see if it can package them with the
   next instruction, there may be a short instruction that still needs
   to be written.

   NOTE: accesses a global, etype.
   NOTE: invoked by various macros such as md_cleanup: see.  */

d1559 1
a1559 9
  /* If cleanup was invoked because the assembler encountered, e.g., a
     user label, we write out the pending instruction, if any.  If it
     was invoked because the assembler is outputting a piece of line
     debugging information, though, we write out the pending
     instruction only if the --no-gstabs-packing command line switch
     has been specified.  */
  if (prev_opcode
      && etype == PACK_UNSPEC
      && (! outputting_stabs_line_debug || ! flag_allow_gstabs_packing))
a1562 1

a1564 1

a1565 1

d1572 2
a1573 3
/* Like normal .word, except support @@word.  */
/* Clobbers input_line_pointer, checks end-of-line.  */

d1575 2
a1576 2
d10v_dot_word (dummy)
     int dummy ATTRIBUTE_UNUSED;
d1579 1
d1581 1
d1596 1
a1596 1

d1598 1
a1598 1
	  fix_new_exp (frag_now, p - frag_now->fr_literal, 2,
d1606 1
a1606 1
  input_line_pointer--;		/* Put terminator back into stream.  */
a1609 6
/* Mitsubishi asked that we support some old syntax that apparently
   had immediate operands starting with '#'.  This is in some of their
   sample code but is not documented (although it appears in some
   examples in their assembler manual). For now, we'll solve this
   compatibility problem by simply ignoring any '#' at the beginning
   of an operand.  */
d1611 6
a1616 2
/* Operands that begin with '#' should fall through to here.  */
/* From expr.c.  */
d1618 4
a1621 1
void
d1634 1
a1634 1
     fixS *fixP;
d1636 1
d1639 2
a1640 2

  /* Prevent all adjustments to global symbols.  */
d1646 1
a1646 1
  /* We need the symbol name for the VTABLE entries.  */
d1656 1
a1656 1
     fixS *fixp;
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d23 1
a24 1
#include "safe-ctype.h"
d28 1
d75 1
a75 1
/* TRUE if instruction swapping warnings should be inhibited.
d77 1
a77 1
static bfd_boolean flag_warn_suppress_instructionswap;
d79 1
a79 1
/* TRUE if instruction packing should be performed when --gstabs is specified.
d81 1
a81 1
static bfd_boolean flag_allow_gstabs_packing = 1;
a101 6

static void check_resource_conflict PARAMS ((struct d10v_opcode *opcode1,
					     unsigned long insn1,
					     struct d10v_opcode *opcode2,
					     unsigned long insn2));

a459 7
	      if (*p == '+')
		{
		  numops++;
		  exp[numops].X_op = O_absent;
		  exp[numops].X_add_number = OPERAND_PLUS;
		  p++;
		}
d574 1
a574 1
		  _("operand out of range: %ld"), (long) value);
d638 2
a639 9
	    {
	      fixups->fix[fixups->fc].reloc =
		get_reloc ((struct d10v_operand *) &d10v_operands[opcode->operands[i]]);

	      /* Check that an immediate was passed to ops that expect one.  */
	      if ((flags & OPERAND_NUM)
		  && (fixups->fix[fixups->fc].reloc == 0))
		as_bad (_("operand is not an immediate"));
	    }
d650 1
a650 1
	    (flags & OPERAND_ADDR) ? TRUE : FALSE;
d656 1
a656 1
	as_bad (_("operand out of range: %lu"), number);
d661 3
a663 3
  /* kludge: for DIVS, we need to put the operands in twice on the second
     pass, format is changed to LONG_R to force the second set of operands
     to not be shifted over 15.  */
d719 3
a721 3
  /* The other container needs to be NOP.
     According to 4.3.1: for FM=00, sub-instructions performed only by IU
     cannot be encoded in L-container.  */
d783 2
a784 1
	  /* Case of a short branch on a separate GAS line.  Pack with NOP.  */
d797 5
a801 1
	    insn = FM00 | (insn1 << 15) | insn2;
d807 6
a812 2
	/* Sequential with non-IU opcode1 on left and done first.  */
	insn = FM01 | (insn1 << 15) | insn2;
d836 5
a840 2
	insn = FM00 | (insn1 << 15) | insn2;
      check_resource_conflict (opcode1, insn1, opcode2, insn2);
d856 2
d873 2
d884 7
a890 2
  /* Process fixup chains.  fx refers to insn2 when j == 0, and to
     insn1 when j == 1.  Yes, it's reversed.  */
d902 1
a902 12
	      if (fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R
		  /* A BFD_RELOC_D10V_10_PCREL_R relocation applied to
		     the instruction in the L container has to be
		     adjusted to BDF_RELOC_D10V_10_PCREL_L.  When
		     j==0, we're processing insn2's operands, so we
		     want to mark the operand if insn2 is *not* in the
		     R container.  When j==1, we're processing insn1's
		     operands, so we want to mark the operand if insn2
		     *is* in the R container.  Note that, if two
		     instructions are identical, we're never going to
		     swap them, so the test is safe.  */
		  && j == ((insn & 0x7fff) == insn2))
d942 2
a943 2
  /* If this is auto parallelization, and the first instruction is a
     branch or should not be packed, then don't parallelize.  */
d945 1
a945 1
      && (op1->exec_type & (ALONE | BRANCH)))
d963 6
a968 6
  /* The bitmasks (mod and used) look like this (bit 31 = MSB).
     r0-r15	  0-15
     a0-a1	  16-17
     cr (not psw) 18
     psw	  19
     mem	  20  */
a1047 135
/* Determine if there are any resource conflicts among two manually
   parallelized instructions.  Some of this was lifted from parallel_ok.  */

static void
check_resource_conflict (op1, insn1, op2, insn2)
     struct d10v_opcode *op1, *op2;
     unsigned long insn1, insn2;
{
  int i, j, flags, mask, shift, regno;
  unsigned long ins, mod[2];
  struct d10v_opcode *op;

  if ((op1->exec_type & SEQ)
      || ! ((op1->exec_type & PAR) || (op1->exec_type & PARONLY)))
    {
      as_warn (_("packing conflict: %s must dispatch sequentially"),
	      op1->name);
      return;
    }

  if ((op2->exec_type & SEQ)
      || ! ((op2->exec_type & PAR) || (op2->exec_type & PARONLY)))
    {
      as_warn (_("packing conflict: %s must dispatch sequentially"),
	      op2->name);
      return;
    }

   /* See if both instructions write to the same resource.

      The idea here is to create two sets of bitmasks (mod and used) which
      indicate which registers are modified or used by each instruction.
      The operation can only be done in parallel if neither instruction
      modifies the same register. Accesses to control registers and memory
      are treated as accesses to a single register. So if both instructions
      write memory or if the first instruction writes memory and the second
      reads, then they cannot be done in parallel. We treat reads to the PSW
      (which includes C, F0, and F1) in isolation. So simultaneously writing
      C and F0 in two different sub-instructions is permitted.  */

  /* The bitmasks (mod and used) look like this (bit 31 = MSB).
     r0-r15	  0-15
     a0-a1	  16-17
     cr (not psw) 18
     psw(other)   19
     mem	  20
     psw(C flag)  21
     psw(F0 flag) 22  */

  for (j = 0; j < 2; j++)
    {
      if (j == 0)
	{
	  op = op1;
	  ins = insn1;
	}
      else
	{
	  op = op2;
	  ins = insn2;
	}
      mod[j] = 0;
      if (op->exec_type & BRANCH_LINK)
	mod[j] |= 1 << 13;

      for (i = 0; op->operands[i]; i++)
	{
	  flags = d10v_operands[op->operands[i]].flags;
	  shift = d10v_operands[op->operands[i]].shift;
	  mask = 0x7FFFFFFF >> (31 - d10v_operands[op->operands[i]].bits);
	  if (flags & OPERAND_REG)
	    {
	      regno = (ins >> shift) & mask;
	      if (flags & (OPERAND_ACC0 | OPERAND_ACC1))
		regno += 16;
	      else if (flags & OPERAND_CONTROL)	/* mvtc or mvfc */
		{
		  if (regno == 0)
		    regno = 19;
		  else
		    regno = 18;
		}
	      else if (flags & OPERAND_FFLAG)
		regno = 22;
	      else if (flags & OPERAND_CFLAG)
		regno = 21;

	      if (flags & OPERAND_DEST
		  /* Auto inc/dec also modifies the register.  */
		  || (op->operands[i + 1] != 0
		      && (d10v_operands[op->operands[i + 1]].flags
			  & (OPERAND_PLUS | OPERAND_MINUS)) != 0))
		{
		  mod[j] |= 1 << regno;
		  if (flags & OPERAND_EVEN)
		    mod[j] |= 1 << (regno + 1);
		}
	    }
	  else if (flags & OPERAND_ATMINUS)
	    {
	      /* SP implicitly used/modified.  */
	      mod[j] |= 1 << 15;
	    }
	}

      if (op->exec_type & WMEM)
	mod[j] |= 1 << 20;
      else if (op->exec_type & WF0)
	mod[j] |= 1 << 22;
      else if (op->exec_type & WCAR)
	mod[j] |= 1 << 21;
    }

  if ((mod[0] & mod[1]) == 0)
    return;
  else
    {
      unsigned long x;
      x = mod[0] & mod[1];

      for (j = 0; j <= 15; j++)
	if (x & (1 << j))
	  as_warn (_("resource conflict (R%d)"), j);
      for (j = 16; j <= 17; j++)
	if (x & (1 << j))
	  as_warn (_("resource conflict (A%d)"), j - 16);
      if (x & (1 << 19))
	as_warn (_("resource conflict (PSW)"));
      if (x & (1 << 21))
	as_warn (_("resource conflict (C flag)"));
      if (x & (1 << 22))
	as_warn (_("resource conflict (F flag)"));
    }
}

d1049 1
a1049 1
   str points to a machine-dependent instruction.  This function is
d1089 1
a1089 2

      /* str2 points to the separator, if there is one.  */
d1144 1
a1144 2
      && (0 == write_2_short (prev_opcode, prev_insn, opcode, insn, extype,
			      fixups)))
d1188 1
a1188 1
      name[nlen] = TOLOWER (op_start[nlen]);
d1212 1
a1212 1
/* Find the symbol which has the same name as the register in exp.  */
d1279 1
a1279 2
		     | OPERAND_FFLAG | OPERAND_CFLAG | OPERAND_CONTROL))
	      || ((flags & OPERAND_SP) && ! (num & OPERAND_SP)))
d1301 1
a1301 1
		    break;
d1310 1
a1310 1
		  bfd_boolean found_symbol;
d1317 1
a1317 1
		  found_symbol = FALSE;
d1329 1
a1329 1
			found_symbol = TRUE;
d1346 1
a1346 1
			    break;
d1350 1
a1350 1
		    break;
d1354 1
a1354 5

	  if (opcode->operands [i + 1] == 0)
	    as_fatal (_("value out of range"));
	  else
	    opcode = next_opcode;
d1359 1
a1359 1
	  opcode += 2;
d1362 1
a1362 6

  match = 0;

  /* Now search the opcode table table for one with operands
     that matches what we've got.  */
  while (!match)
d1364 11
a1374 12
      match = 1;
      for (i = 0; opcode->operands[i]; i++)
	{
	  int flags = d10v_operands[opcode->operands[i]].flags;
	  int X_op = myops[i].X_op;
	  int num = myops[i].X_add_number;

	  if (X_op == 0)
	    {
	      match = 0;
	      break;
	    }
d1376 1
a1376 8
	  if (flags & OPERAND_REG)
	    {
	      if ((X_op != O_register)
		  || (num & ~flags
		      & (OPERAND_GPR | OPERAND_ACC0 | OPERAND_ACC1
			 | OPERAND_FFLAG | OPERAND_CFLAG
			 | OPERAND_CONTROL))
		  || ((flags & OPERAND_SP) && ! (num & OPERAND_SP)))
a1380 1
	    }
d1382 12
a1393 9
	  if (((flags & OPERAND_MINUS)   && ((X_op != O_absent) || (num != OPERAND_MINUS))) ||
	      ((flags & OPERAND_PLUS)    && ((X_op != O_absent) || (num != OPERAND_PLUS))) ||
	      ((flags & OPERAND_ATMINUS) && ((X_op != O_absent) || (num != OPERAND_ATMINUS))) ||
	      ((flags & OPERAND_ATPAR)   && ((X_op != O_absent) || (num != OPERAND_ATPAR))) ||
	      ((flags & OPERAND_ATSIGN)  && ((X_op != O_absent) || ((num != OPERAND_ATSIGN) && (num != OPERAND_ATPAR)))))
	    {
	      match = 0;
	      break;
	    }
d1395 9
a1403 8
	  /* Unfortunatly, for the indirect operand in instructions such
	     as ``ldb r1, @@(c,r14)'' this function can be passed
	     X_op == O_register (because 'c' is a valid register name).
	     However we cannot just ignore the case when X_op == O_register
	     but flags & OPERAND_REG is null, so we check to see if a symbol
	     of the same name as the register exists.  If the symbol does
	     exist, then the parser was unable to distinguish the two cases
	     and we fix things here. (Ref: PR14826)  */
d1405 10
a1414 3
	  if (!(flags & OPERAND_REG) && (X_op == O_register))
	    {
	      symbolS * sym;
d1416 3
a1418 1
	      sym = find_symbol_matching_register (& myops[i]);
d1420 8
a1427 4
	      if (sym != NULL)
		{
		  myops[i].X_op = X_op = O_symbol;
		  myops[i].X_add_symbol = sym;
a1428 3
	      else
		as_bad
		  (_("illegal operand - register name found where none expected"));
a1429 1
	}
d1431 1
a1431 1
      /* We're only done if the operands matched so far AND there
d1433 4
a1436 4
      if (match && myops[i].X_op == 0)
	break;
      else
	match = 0;
d1438 1
a1438 1
      next_opcode = opcode + 1;
d1440 2
a1441 2
      if (next_opcode->opcode == 0)
	break;
d1443 2
a1444 2
      if (strcmp (next_opcode->name, opcode->name))
	break;
d1446 2
a1447 1
      opcode = next_opcode;
a1463 3
      if ((d10v_operands[opcode->operands[i]].flags & OPERAND_NOSP)
	  && (myops[i].X_add_number & OPERAND_SP))
	as_bad (_("Unsupported use of sp"));
a1474 9
      if ((d10v_operands[opcode->operands[i]].flags & OPERAND_CONTROL)
	  && (myops[i].X_add_number == OPERAND_CONTROL + 4
	      || myops[i].X_add_number == OPERAND_CONTROL + 5
	      || myops[i].X_add_number == OPERAND_CONTROL + 6
	      || myops[i].X_add_number == OPERAND_CONTROL + 12
	      || myops[i].X_add_number == OPERAND_CONTROL + 13
	      || myops[i].X_add_number == OPERAND_CONTROL + 15))
	as_warn (_("cr%ld is a reserved control register"),
		 myops[i].X_add_number - OPERAND_CONTROL);
d1501 2
a1502 1
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
d1505 1
a1505 1
  reloc->addend = 0;
d1531 4
a1534 4
void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
d1539 1
a1539 1
  long value = *valP;
d1543 22
a1564 6
  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  /* We don't actually support subtracting a symbol.  */
  if (fixP->fx_subsy != (symbolS *) NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));
d1566 1
a1566 1
  op_type = fixP->fx_r_type;
d1573 1
a1573 1
	  fixP->fx_r_type = BFD_RELOC_D10V_10_PCREL_L;
d1579 1
a1579 1
	  fixP->fx_r_type = BFD_RELOC_D10V_18;
d1582 1
a1582 1
	fixP->fx_r_type =
d1588 1
a1588 1
  where = fixP->fx_frag->fr_literal + fixP->fx_where;
d1591 1
a1591 1
  switch (fixP->fx_r_type)
a1595 13
      /* If the fix is relative to a global symbol, not a section
	 symbol, then ignore the offset.
         XXX - Do we have to worry about branches to a symbol + offset ?  */
      if (fixP->fx_addsy != NULL
	  && S_IS_EXTERN (fixP->fx_addsy) )
        {
          segT fseg = S_GET_SEGMENT (fixP->fx_addsy);
          segment_info_type *segf = seg_info(fseg);

	  if ( segf && segf->sym != fixP->fx_addsy)
	    value = 0;
        }
      /* Drop through.  */
d1599 1
a1599 1
      if (fixP->fx_size == 2)
d1608 2
a1609 4
	      && ((repi != NULL
		   && (insn & repi->mask) == (unsigned) repi->opcode)
		  || (rep != NULL
		      && (insn & rep->mask) == (unsigned) rep->opcode))
d1613 1
a1613 1
	       fixP->fx_line);
d1615 1
a1615 1
	    d10v_insert_operand (insn, op_type, (offsetT) value, left, fixP);
d1628 2
a1629 2
      fixP->fx_done = 0;
      return;
d1633 1
a1633 1
		fixP->fx_line, fixP->fx_r_type);
d1635 1
d1671 1
d1678 2
a1679 2
/* Like normal .word, except support @@word.
   Clobbers input_line_pointer, checks end-of-line.  */
d1722 2
a1723 2
/* Operands that begin with '#' should fall through to here.
   From expr.c.  */
d1736 1
a1736 1
bfd_boolean
d1740 9
d1755 11
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d638 1
a638 1
	      /* Recognize XXX>>1+N aka XXX@@word+N as special (AT_WORD).  */
d1557 1
a1557 1
	  /* Unfortunately, for the indirect operand in instructions such
@


