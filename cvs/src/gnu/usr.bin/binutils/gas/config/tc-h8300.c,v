head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.52
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.27;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.30;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.49;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.05.37;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.04;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.04;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.31;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.44.39;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.46.23;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.34.24;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.29;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.51;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-h8300.c -- Assemble code for the Renesas H8/300
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

#include <stdio.h>
#include "as.h"
#include "subsegs.h"
#include "bfd.h"

#ifdef BFD_ASSEMBLER
#include "dwarf2dbg.h"
#endif

#define DEFINE_TABLE
#define h8_opcodes ops
#include "opcode/h8300.h"
#include "safe-ctype.h"

#ifdef OBJ_ELF
#include "elf/h8.h"
#endif

const char comment_chars[] = ";";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = "";

static void sbranch (int);
static void h8300hmode (int);
static void h8300smode (int);
static void h8300hnmode (int);
static void h8300snmode (int);
static void h8300sxmode (int);
static void h8300sxnmode (int);
static void pint (int);

int Hmode;
int Smode;
int Nmode;
int SXmode;

#define PSIZE (Hmode && !Nmode ? L_32 : L_16)

static int bsize = L_8;		/* Default branch displacement.  */

struct h8_instruction
{
  int length;
  int noperands;
  int idx;
  int size;
  const struct h8_opcode *opcode;
};

static struct h8_instruction *h8_instructions;

static void
h8300hmode (int arg ATTRIBUTE_UNUSED)
{
  Hmode = 1;
  Smode = 0;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300h))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
h8300smode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300s))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
h8300hnmode (int arg ATTRIBUTE_UNUSED)
{
  Hmode = 1;
  Smode = 0;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300hn))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
h8300snmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sn))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
h8300sxmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  SXmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sx))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
h8300sxnmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  SXmode = 1;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sxn))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
sbranch (int size)
{
  bsize = size;
}

static void
pint (int arg ATTRIBUTE_UNUSED)
{
  cons (Hmode ? 4 : 2);
}

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
  {"h8300h",  h8300hmode,  0},
  {"h8300hn", h8300hnmode, 0},
  {"h8300s",  h8300smode,  0},
  {"h8300sn", h8300snmode, 0},
  {"h8300sx", h8300sxmode, 0},
  {"h8300sxn", h8300sxnmode, 0},
  {"sbranch", sbranch, L_8},
  {"lbranch", sbranch, L_16},

  {"int", pint, 0},
  {"data.b", cons, 1},
  {"data.w", cons, 2},
  {"data.l", cons, 4},
  {"form", listing_psize, 0},
  {"heading", listing_title, 0},
  {"import",  s_ignore, 0},
  {"page",    listing_eject, 0},
  {"program", s_ignore, 0},
  {0, 0, 0}
};

const int md_reloc_size;

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant
   As in 0f12.456
   or    0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

static struct hash_control *opcode_hash_control;	/* Opcode mnemonics.  */

/* This function is called once, at assembler startup time.  This
   should set up all the tables, etc. that the MD part of the assembler
   needs.  */

void
md_begin (void)
{
  unsigned int nopcodes;
  struct h8_opcode *p, *p1;
  struct h8_instruction *pi;
  char prev_buffer[100];
  int idx = 0;

#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300))
    as_warn (_("could not set architecture and machine"));
#endif

  opcode_hash_control = hash_new ();
  prev_buffer[0] = 0;

  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);
  
  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  pi = h8_instructions;
  p1 = h8_opcodes;
  /* We do a minimum amount of sorting on the opcode table; this is to
     make it easy to describe the mova instructions without unnecessary
     code duplication.
     Sorting only takes place inside blocks of instructions of the form
     X/Y, so for example mova/b, mova/w and mova/l can be intermixed.  */
  while (p1)
    {
      struct h8_opcode *first_skipped = 0;
      int len, cmplen = 0;
      char *src = p1->name;
      char *dst, *buffer;

      if (p1->name == 0)
	break;
      /* Strip off any . part when inserting the opcode and only enter
	 unique codes into the hash table.  */
      dst = buffer = malloc (strlen (src) + 1);
      while (*src)
	{
	  if (*src == '.')
	    {
	      src++;
	      break;
	    }
	  if (*src == '/')
	    cmplen = src - p1->name + 1;
	  *dst++ = *src++;
	}
      *dst = 0;
      len = dst - buffer;
      if (cmplen == 0)
	cmplen = len;
      hash_insert (opcode_hash_control, buffer, (char *) pi);
      strcpy (prev_buffer, buffer);
      idx++;

      for (p = p1; p->name; p++)
	{
	  /* A negative TIME is used to indicate that we've added this opcode
	     already.  */
	  if (p->time == -1)
	    continue;
	  if (strncmp (p->name, buffer, cmplen) != 0
	      || (p->name[cmplen] != '\0' && p->name[cmplen] != '.'
		  && p->name[cmplen - 1] != '/'))
	    {
	      if (first_skipped == 0)
		first_skipped = p;
	      break;
	    }
	  if (strncmp (p->name, buffer, len) != 0)
	    {
	      if (first_skipped == 0)
		first_skipped = p;
	      continue;
	    }

	  p->time = -1;
	  pi->size = p->name[len] == '.' ? p->name[len + 1] : 0;
	  pi->idx = idx;

	  /* Find the number of operands.  */
	  pi->noperands = 0;
	  while (pi->noperands < 3 && p->args.nib[pi->noperands] != (op_type) E)
	    pi->noperands++;

	  /* Find the length of the opcode in bytes.  */
	  pi->length = 0;
	  while (p->data.nib[pi->length * 2] != (op_type) E)
	    pi->length++;

	  pi->opcode = p;
	  pi++;
	}
      p1 = first_skipped;
    }

  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->noperands = 0;
  pi->idx = 0;
  pi->size = 0;
  pi->opcode = 0;

  linkrelax = 1;
}

struct h8_op
{
  op_type mode;
  unsigned reg;
  expressionS exp;
};

static void clever_message (const struct h8_instruction *, struct h8_op *);
static void fix_operand_size (struct h8_op *, int);
static void build_bytes (const struct h8_instruction *, struct h8_op *);
static void do_a_fix_imm (int, int, struct h8_op *, int);
static void check_operand (struct h8_op *, unsigned int, char *);
static const struct h8_instruction * get_specific (const struct h8_instruction *, struct h8_op *, int) ;
static char *get_operands (unsigned, char *, struct h8_op *);
static void get_operand (char **, struct h8_op *, int);
static int parse_reg (char *, op_type *, unsigned *, int);
static char *skip_colonthing (char *, int *);
static char *parse_exp (char *, struct h8_op *);

static int constant_fits_width_p (struct h8_op *, unsigned int);
static int constant_fits_size_p (struct h8_op *, int, int);

/*
  parse operands
  WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp
  r0l,r0h,..r7l,r7h
  @@WREG
  @@WREG+
  @@-WREG
  #const
  ccr
*/

/* Try to parse a reg name.  Return the number of chars consumed.  */

static int
parse_reg (char *src, op_type *mode, unsigned int *reg, int direction)
{
  char *end;
  int len;

  /* Cribbed from get_symbol_end.  */
  if (!is_name_beginner (*src) || *src == '\001')
    return 0;
  end = src + 1;
  while ((is_part_of_name (*end) && *end != '.') || *end == '\001')
    end++;
  len = end - src;

  if (len == 2 && TOLOWER (src[0]) == 's' && TOLOWER (src[1]) == 'p')
    {
      *mode = PSIZE | REG | direction;
      *reg = 7;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 'c' && 
      TOLOWER (src[1]) == 'c' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = CCR;
      *reg = 0;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 'e' && 
      TOLOWER (src[1]) == 'x' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = EXR;
      *reg = 1;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 'v' && 
      TOLOWER (src[1]) == 'b' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = VBR;
      *reg = 6;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 's' && 
      TOLOWER (src[1]) == 'b' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = SBR;
      *reg = 7;
      return len;
    }
  if (len == 2 && TOLOWER (src[0]) == 'f' && TOLOWER (src[1]) == 'p')
    {
      *mode = PSIZE | REG | direction;
      *reg = 6;
      return len;
    }
  if (len == 3 && TOLOWER (src[0]) == 'e' && TOLOWER (src[1]) == 'r' &&
      src[2] >= '0' && src[2] <= '7')
    {
      *mode = L_32 | REG | direction;
      *reg = src[2] - '0';
      if (!Hmode)
	as_warn (_("Reg not valid for H8/300"));
      return len;
    }
  if (len == 2 && TOLOWER (src[0]) == 'e' && src[1] >= '0' && src[1] <= '7')
    {
      *mode = L_16 | REG | direction;
      *reg = src[1] - '0' + 8;
      if (!Hmode)
	as_warn (_("Reg not valid for H8/300"));
      return len;
    }

  if (TOLOWER (src[0]) == 'r')
    {
      if (src[1] >= '0' && src[1] <= '7')
	{
	  if (len == 3 && TOLOWER (src[2]) == 'l')
	    {
	      *mode = L_8 | REG | direction;
	      *reg = (src[1] - '0') + 8;
	      return len;
	    }
	  if (len == 3 && TOLOWER (src[2]) == 'h')
	    {
	      *mode = L_8 | REG | direction;
	      *reg = (src[1] - '0');
	      return len;
	    }
	  if (len == 2)
	    {
	      *mode = L_16 | REG | direction;
	      *reg = (src[1] - '0');
	      return len;
	    }
	}
    }

  return 0;
}


/* Parse an immediate or address-related constant and store it in OP.
   If the user also specifies the operand's size, store that size
   in OP->MODE, otherwise leave it for later code to decide.  */

static char *
parse_exp (char *src, struct h8_op *op)
{
  char *save;

  save = input_line_pointer;
  input_line_pointer = src;
  expression (&op->exp);
  if (op->exp.X_op == O_absent)
    as_bad (_("missing operand"));
  src = input_line_pointer;
  input_line_pointer = save;

  return skip_colonthing (src, &op->mode);
}


/* If SRC starts with an explicit operand size, skip it and store the size
   in *MODE.  Leave *MODE unchanged otherwise.  */

static char *
skip_colonthing (char *src, int *mode)
{
  if (*src == ':')
    {
      src++;
      *mode &= ~SIZE;
      if (src[0] == '8' && !ISDIGIT (src[1]))
	*mode |= L_8;
      else if (src[0] == '2' && !ISDIGIT (src[1]))
	*mode |= L_2;
      else if (src[0] == '3' && !ISDIGIT (src[1]))
	*mode |= L_3;
      else if (src[0] == '4' && !ISDIGIT (src[1]))
	*mode |= L_4;
      else if (src[0] == '5' && !ISDIGIT (src[1]))
	*mode |= L_5;
      else if (src[0] == '2' && src[1] == '4' && !ISDIGIT (src[2]))
	*mode |= L_24;
      else if (src[0] == '3' && src[1] == '2' && !ISDIGIT (src[2]))
	*mode |= L_32;
      else if (src[0] == '1' && src[1] == '6' && !ISDIGIT (src[2]))
	*mode |= L_16;
      else
	as_bad (_("invalid operand size requested"));

      while (ISDIGIT (*src))
	src++;
    }
  return src;
}

/* The many forms of operand:

   Rn			Register direct
   @@Rn			Register indirect
   @@(exp[:16], Rn)	Register indirect with displacement
   @@Rn+
   @@-Rn
   @@aa:8		absolute 8 bit
   @@aa:16		absolute 16 bit
   @@aa			absolute 16 bit

   #xx[:size]		immediate data
   @@(exp:[8], pc)	pc rel
   @@@@aa[:8]		memory indirect.  */

static int
constant_fits_width_p (struct h8_op *operand, unsigned int width)
{
  return ((operand->exp.X_add_number & ~width) == 0
	  || (operand->exp.X_add_number | width) == (unsigned)(~0));
}

static int
constant_fits_size_p (struct h8_op *operand, int size, int no_symbols)
{
  offsetT num = operand->exp.X_add_number;
  if (no_symbols
      && (operand->exp.X_add_symbol != 0 || operand->exp.X_op_symbol != 0))
    return 0;
  switch (size)
    {
    case L_2:
      return (num & ~3) == 0;
    case L_3:
      return (num & ~7) == 0;
    case L_3NZ:
      return num >= 1 && num < 8;
    case L_4:
      return (num & ~15) == 0;
    case L_5:
      return num >= 1 && num < 32;
    case L_8:
      return (num & ~0xFF) == 0 || ((unsigned)num | 0x7F) == ~0u;
    case L_8U:
      return (num & ~0xFF) == 0;
    case L_16:
      return (num & ~0xFFFF) == 0 || ((unsigned)num | 0x7FFF) == ~0u;
    case L_16U:
      return (num & ~0xFFFF) == 0;
    case L_32:
      return 1;
    default:
      abort ();
    }
}

static void
get_operand (char **ptr, struct h8_op *op, int direction)
{
  char *src = *ptr;
  op_type mode;
  unsigned int num;
  unsigned int len;

  op->mode = 0;

  /* Check for '(' and ')' for instructions ldm and stm.  */
  if (src[0] == '(' && src[8] == ')')
    ++ src;

  /* Gross.  Gross.  ldm and stm have a format not easily handled
     by get_operand.  We deal with it explicitly here.  */
  if (TOLOWER (src[0]) == 'e' && TOLOWER (src[1]) == 'r' && 
      ISDIGIT (src[2]) && src[3] == '-' &&
      TOLOWER (src[4]) == 'e' && TOLOWER (src[5]) == 'r' && ISDIGIT (src[6]))
    {
      int low, high;

      low = src[2] - '0';
      high = src[6] - '0';

       /* Check register pair's validity as per tech note TN-H8*-193A/E
	  from Renesas for H8S and H8SX hardware manual.  */
      if (   !(low == 0 && (high == 1 || high == 2 || high == 3))
          && !(low == 1 && (high == 2 || high == 3 || high == 4) && SXmode)
          && !(low == 2 && (high == 3 || ((high == 4 || high == 5) && SXmode)))
          && !(low == 3 && (high == 4 || high == 5 || high == 6) && SXmode)
          && !(low == 4 && (high == 5 || high == 6))
          && !(low == 4 && high == 7 && SXmode)
          && !(low == 5 && (high == 6 || high == 7) && SXmode)
          && !(low == 6 && high == 7 && SXmode))
	as_bad (_("Invalid register list for ldm/stm\n"));

      /* Even sicker.  We encode two registers into op->reg.  One
	 for the low register to save, the other for the high
	 register to save;  we also set the high bit in op->reg
	 so we know this is "very special".  */
      op->reg = 0x80000000 | (high << 8) | low;
      op->mode = REG;
      if (src[7] == ')')
	*ptr = src + 8;
      else
	*ptr = src + 7;
      return;
    }

  len = parse_reg (src, &op->mode, &op->reg, direction);
  if (len)
    {
      src += len;
      if (*src == '.')
	{
	  int size = op->mode & SIZE;
	  switch (src[1])
	    {
	    case 'l': case 'L':
	      if (size != L_32)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      break;
	    case 'w': case 'W':
	      if (size != L_32 && size != L_16)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      op->mode = (op->mode & ~SIZE) | L_16;
	      break;
	    case 'b': case 'B':
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      if (size != L_32 && size != L_8)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      op->mode = (op->mode & ~SIZE) | L_8;
	      break;
	    default:
	      as_warn ("invalid suffix after register.");
	      break;
	    }
	  src += 2;
	}
      *ptr = src;
      return;
    }

  if (*src == '@@')
    {
      src++;
      if (*src == '@@')
	{
	  *ptr = parse_exp (src + 1, op);
	  if (op->exp.X_add_number >= 0x100)
	    {
	      int divisor = 1;

	      op->mode = VECIND;
	      /* FIXME : 2?  or 4?  */
	      if (op->exp.X_add_number >= 0x400)
		as_bad (_("address too high for vector table jmp/jsr"));
	      else if (op->exp.X_add_number >= 0x200)
		divisor = 4;
	      else
		divisor = 2;

	      op->exp.X_add_number = op->exp.X_add_number / divisor - 0x80;
	    }
	  else
	    op->mode = MEMIND;
	  return;
	}

      if (*src == '-' || *src == '+')
	{
	  len = parse_reg (src + 1, &mode, &num, direction);
	  if (len == 0)
	    {
	      /* Oops, not a reg after all, must be ordinary exp.  */
	      op->mode = ABS | direction;
	      *ptr = parse_exp (src, op);
	      return;
	    }

	  if (((mode & SIZE) != PSIZE)
	      /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
	      && (!Nmode || ((mode & SIZE) != L_32)))
	    as_bad (_("Wrong size pointer register for architecture."));

	  op->mode = src[0] == '-' ? RDPREDEC : RDPREINC;
	  op->reg = num;
	  *ptr = src + 1 + len;
	  return;
	}
      if (*src == '(')
	{
	  src++;

	  /* See if this is @@(ERn.x, PC).  */
	  len = parse_reg (src, &mode, &op->reg, direction);
	  if (len != 0 && (mode & MODE) == REG && src[len] == '.')
	    {
	      switch (TOLOWER (src[len + 1]))
		{
		case 'b':
		  mode = PCIDXB | direction;
		  break;
		case 'w':
		  mode = PCIDXW | direction;
		  break;
		case 'l':
		  mode = PCIDXL | direction;
		  break;
		default:
		  mode = 0;
		  break;
		}
	      if (mode
		  && src[len + 2] == ','
		  && TOLOWER (src[len + 3]) != 'p' 
		  && TOLOWER (src[len + 4]) != 'c'
		  && src[len + 5] != ')')
		{
		  *ptr = src + len + 6;
		  op->mode |= mode;
		  return;
		}
	      /* Fall through into disp case - the grammar is somewhat
		 ambiguous, so we should try whether it's a DISP operand
		 after all ("ER3.L" might be a poorly named label...).  */
	    }

	  /* Disp.  */

	  /* Start off assuming a 16 bit offset.  */

	  src = parse_exp (src, op);
	  if (*src == ')')
	    {
	      op->mode |= ABS | direction;
	      *ptr = src + 1;
	      return;
	    }

	  if (*src != ',')
	    {
	      as_bad (_("expected @@(exp, reg16)"));
	      return;
	    }
	  src++;

	  len = parse_reg (src, &mode, &op->reg, direction);
	  if (len == 0 || (mode & MODE) != REG)
	    {
	      as_bad (_("expected @@(exp, reg16)"));
	      return;
	    }
	  src += len;
	  if (src[0] == '.')
	    {
	      switch (TOLOWER (src[1]))
		{
		case 'b':
		  op->mode |= INDEXB | direction;
		  break;
		case 'w':
		  op->mode |= INDEXW | direction;
		  break;
		case 'l':
		  op->mode |= INDEXL | direction;
		  break;
		default:
		  as_bad (_("expected .L, .W or .B for register in indexed addressing mode"));
		}
	      src += 2;
	      op->reg &= 7;
	    }
	  else
	    op->mode |= DISP | direction;
	  src = skip_colonthing (src, &op->mode);

	  if (*src != ')' && '(')
	    {
	      as_bad (_("expected @@(exp, reg16)"));
	      return;
	    }
	  *ptr = src + 1;
	  return;
	}
      len = parse_reg (src, &mode, &num, direction);

      if (len)
	{
	  src += len;
	  if (*src == '+' || *src == '-')
	    {
	      if (((mode & SIZE) != PSIZE)
		  /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
		  && (!Nmode || ((mode & SIZE) != L_32)))
		as_bad (_("Wrong size pointer register for architecture."));
	      op->mode = *src == '+' ? RSPOSTINC : RSPOSTDEC;
	      op->reg = num;
	      src++;
	      *ptr = src;
	      return;
	    }
	  if (((mode & SIZE) != PSIZE)
	      /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
	      && (!Nmode || ((mode & SIZE) != L_32)))
	    as_bad (_("Wrong size pointer register for architecture."));

	  op->mode = direction | IND | PSIZE;
	  op->reg = num;
	  *ptr = src;

	  return;
	}
      else
	{
	  /* must be a symbol */

	  op->mode = ABS | direction;
	  *ptr = parse_exp (src, op);
	  return;
	}
    }

  if (*src == '#')
    {
      op->mode = IMM;
      *ptr = parse_exp (src + 1, op);
      return;
    }
  else if (strncmp (src, "mach", 4) == 0 || 
	   strncmp (src, "macl", 4) == 0 ||
	   strncmp (src, "MACH", 4) == 0 || 
	   strncmp (src, "MACL", 4) == 0)
    {
      op->reg = TOLOWER (src[3]) == 'l';
      op->mode = MACREG;
      *ptr = src + 4;
      return;
    }
  else
    {
      op->mode = PCREL;
      *ptr = parse_exp (src, op);
    }
}

static char *
get_operands (unsigned int noperands, char *op_end, struct h8_op *operand)
{
  char *ptr = op_end;

  switch (noperands)
    {
    case 0:
      break;

    case 1:
      ptr++;
      get_operand (&ptr, operand + 0, SRC);
      if (*ptr == ',')
	{
	  ptr++;
	  get_operand (&ptr, operand + 1, DST);
	}
      break;

    case 2:
      ptr++;
      get_operand (&ptr, operand + 0, SRC);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, DST);
      break;

    case 3:
      ptr++;
      get_operand (&ptr, operand + 0, SRC);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, DST);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 2, OP3);
      break;

    default:
      abort ();
    }

  return ptr;
}

/* MOVA has special requirements.  Rather than adding twice the amount of
   addressing modes, we simply special case it a bit.  */
static void
get_mova_operands (char *op_end, struct h8_op *operand)
{
  char *ptr = op_end;

  if (ptr[1] != '@@' || ptr[2] != '(')
    goto error;
  ptr += 3;
  operand[0].mode = 0;
  ptr = parse_exp (ptr, &operand[0]);

  if (*ptr !=',')
    goto error;
  ptr++;
  get_operand (&ptr, operand + 1, DST);

  if (*ptr =='.')
    {
      ptr++;
      switch (*ptr++)
	{
	case 'b': case 'B':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXB;
	  break;
	case 'w': case 'W':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXW;
	  break;
	case 'l': case 'L':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXL;
	  break;
	default:
	  goto error;
	}
    }
  else if ((operand[1].mode & MODE) == LOWREG)
    {
      switch (operand[1].mode & SIZE) 
	{
	case L_8:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXB;
	  break;
	case L_16:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXW;
	  break;
	case L_32:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXL;
	  break;
	default:
	  goto error;
	}
    }
  else
    goto error;

  if (*ptr++ != ')' || *ptr++ != ',')
    goto error;
  get_operand (&ptr, operand + 2, OP3);
  /* See if we can use the short form of MOVA.  */
  if (((operand[1].mode & MODE) == REG || (operand[1].mode & MODE) == LOWREG)
      && (operand[2].mode & MODE) == REG
      && (operand[1].reg & 7) == (operand[2].reg & 7))
    {
      operand[1].mode = operand[2].mode = 0;
      operand[0].reg = operand[2].reg & 7;
    }
  return;

 error:
  as_bad (_("expected valid addressing mode for mova: \"@@(disp, ea.sz),ERn\""));
}

static void
get_rtsl_operands (char *ptr, struct h8_op *operand)
{
  int mode, num, num2, len, type = 0;

  ptr++;
  if (*ptr == '(')
    {
      ptr++;
      type = 1;
    }
  len = parse_reg (ptr, &mode, &num, SRC);
  if (len == 0 || (mode & MODE) != REG)
    {
      as_bad (_("expected register"));
      return;
    }
  ptr += len;
  if (*ptr == '-')
    {
      len = parse_reg (++ptr, &mode, &num2, SRC);
      if (len == 0 || (mode & MODE) != REG)
	{
	  as_bad (_("expected register"));
	  return;
	}
      ptr += len;
      /* CONST_xxx are used as placeholders in the opcode table.  */
      num = num2 - num;
      if (num < 0 || num > 3)
	{
	  as_bad (_("invalid register list"));
	  return;
	}
    }
  else
    num2 = num, num = 0;
  if (type == 1 && *ptr++ != ')')
    {
      as_bad (_("expected closing paren"));
      return;
    }
  operand[0].mode = RS32;
  operand[1].mode = RD32;
  operand[0].reg = num;
  operand[1].reg = num2;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes, return the opcode which matches the opcodes
   provided.  */

static const struct h8_instruction *
get_specific (const struct h8_instruction *instruction,
	      struct h8_op *operands, int size)
{
  const struct h8_instruction *this_try = instruction;
  const struct h8_instruction *found_other = 0, *found_mismatched = 0;
  int found = 0;
  int this_index = instruction->idx;
  int noperands = 0;

  /* There's only one ldm/stm and it's easier to just
     get out quick for them.  */
  if (OP_KIND (instruction->opcode->how) == O_LDM
      || OP_KIND (instruction->opcode->how) == O_STM)
    return this_try;

  while (noperands < 3 && operands[noperands].mode != 0)
    noperands++;

  while (this_index == instruction->idx && !found)
    {
      int this_size;

      found = 1;
      this_try = instruction++;
      this_size = this_try->opcode->how & SN;

      if (this_try->noperands != noperands)
	found = 0;
      else if (this_try->noperands > 0)
	{
	  int i;

	  for (i = 0; i < this_try->noperands && found; i++)
	    {
	      op_type op = this_try->opcode->args.nib[i];
	      int op_mode = op & MODE;
	      int op_size = op & SIZE;
	      int x = operands[i].mode;
	      int x_mode = x & MODE;
	      int x_size = x & SIZE;

	      if (op_mode == LOWREG && (x_mode == REG || x_mode == LOWREG))
		{
		  if ((x_size == L_8 && (operands[i].reg & 8) == 0)
		      || (x_size == L_16 && (operands[i].reg & 8) == 8))
		    as_warn (_("can't use high part of register in operand %d"), i);

		  if (x_size != op_size)
		    found = 0;
		}
	      else if (op_mode == REG)
		{
		  if (x_mode == LOWREG)
		    x_mode = REG;
		  if (x_mode != REG)
		    found = 0;

		  if (x_size == L_P)
		    x_size = (Hmode ? L_32 : L_16);
		  if (op_size == L_P)
		    op_size = (Hmode ? L_32 : L_16);

		  /* The size of the reg is v important.  */
		  if (op_size != x_size)
		    found = 0;
		}
	      else if (op_mode & CTRL)	/* control register */
		{
		  if (!(x_mode & CTRL))
		    found = 0;

		  switch (x_mode)
		    {
		    case CCR:
		      if (op_mode != CCR &&
			  op_mode != CCR_EXR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case EXR:
		      if (op_mode != EXR &&
			  op_mode != CCR_EXR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case MACH:
		      if (op_mode != MACH &&
			  op_mode != MACREG)
			found = 0;
		      break;
		    case MACL:
		      if (op_mode != MACL &&
			  op_mode != MACREG)
			found = 0;
		      break;
		    case VBR:
		      if (op_mode != VBR &&
			  op_mode != VBR_SBR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case SBR:
		      if (op_mode != SBR &&
			  op_mode != VBR_SBR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    }
		}
	      else if ((op & ABSJMP) && (x_mode == ABS || x_mode == PCREL))
		{
		  operands[i].mode &= ~MODE;
		  operands[i].mode |= ABSJMP;
		  /* But it may not be 24 bits long.  */
		  if (x_mode == ABS && !Hmode)
		    {
		      operands[i].mode &= ~SIZE;
		      operands[i].mode |= L_16;
		    }
		  if ((operands[i].mode & SIZE) == L_32
		      && (op_mode & SIZE) != L_32)
		   found = 0;
		}
	      else if (x_mode == IMM && op_mode != IMM)
		{
		  offsetT num = operands[i].exp.X_add_number;
		  if (op_mode == KBIT || op_mode == DBIT)
		    /* This is ok if the immediate value is sensible.  */;
		  else if (op_mode == CONST_2)
		    found = num == 2;
		  else if (op_mode == CONST_4)
		    found = num == 4;
		  else if (op_mode == CONST_8)
		    found = num == 8;
		  else if (op_mode == CONST_16)
		    found = num == 16;
		  else
		    found = 0;
		}
	      else if (op_mode == PCREL && op_mode == x_mode)
		{
		  /* movsd, bsr/bc and bsr/bs only come in PCREL16 flavour:
		     If x_size is L_8, promote it.  */
		  if (OP_KIND (this_try->opcode->how) == O_MOVSD
		      || OP_KIND (this_try->opcode->how) == O_BSRBC
		      || OP_KIND (this_try->opcode->how) == O_BSRBS)
		    if (x_size == L_8)
		      x_size = L_16;

		  /* The size of the displacement is important.  */
		  if (op_size != x_size)
		    found = 0;
		}
	      else if ((op_mode == DISP || op_mode == IMM || op_mode == ABS
			|| op_mode == INDEXB || op_mode == INDEXW
			|| op_mode == INDEXL)
		       && op_mode == x_mode)
		{
		  /* Promote a L_24 to L_32 if it makes us match.  */
		  if (x_size == L_24 && op_size == L_32)
		    {
		      x &= ~SIZE;
		      x |= x_size = L_32;
		    }

#if 0 /* ??? */
		  /* Promote an L8 to L_16 if it makes us match.  */
		  if ((op_mode == ABS || op_mode == DISP) && x_size == L_8)
		    {
		      if (op_size == L_16)
			x_size = L_16;
		    }
#endif

		  if (((x_size == L_16 && op_size == L_16U)
		       || (x_size == L_8 && op_size == L_8U)
		       || (x_size == L_3 && op_size == L_3NZ))
		      /* We're deliberately more permissive for ABS modes.  */
		      && (op_mode == ABS
			  || constant_fits_size_p (operands + i, op_size,
						   op & NO_SYMBOLS)))
		    x_size = op_size;

		  if (x_size != 0 && op_size != x_size)
		    found = 0;
		  else if (x_size == 0
			   && ! constant_fits_size_p (operands + i, op_size,
						      op & NO_SYMBOLS))
		    found = 0;
		}
	      else if (op_mode != x_mode)
		{
		  found = 0;
		}
	    }
	}
      if (found)
	{
	  if ((this_try->opcode->available == AV_H8SX && ! SXmode)
	      || (this_try->opcode->available == AV_H8S && ! Smode)
	      || (this_try->opcode->available == AV_H8H && ! Hmode))
	    found = 0, found_other = this_try;
	  else if (this_size != size && (this_size != SN && size != SN))
	    found_mismatched = this_try, found = 0;

	}
    }
  if (found)
    return this_try;
  if (found_other)
    {
      as_warn (_("Opcode `%s' with these operand types not available in %s mode"),
	       found_other->opcode->name,
	       (! Hmode && ! Smode ? "H8/300"
		: SXmode ? "H8sx"
		: Smode ? "H8/300S"
		: "H8/300H"));
    }
  else if (found_mismatched)
    {
      as_warn (_("mismatch between opcode size and operand size"));
      return found_mismatched;
    }
  return 0;
}

static void
check_operand (struct h8_op *operand, unsigned int width, char *string)
{
  if (operand->exp.X_add_symbol == 0
      && operand->exp.X_op_symbol == 0)
    {
      /* No symbol involved, let's look at offset, it's dangerous if
	 any of the high bits are not 0 or ff's, find out by oring or
	 anding with the width and seeing if the answer is 0 or all
	 fs.  */

      if (! constant_fits_width_p (operand, width))
	{
	  if (width == 255
	      && (operand->exp.X_add_number & 0xff00) == 0xff00)
	    {
	      /* Just ignore this one - which happens when trying to
		 fit a 16 bit address truncated into an 8 bit address
		 of something like bset.  */
	    }
	  else if (strcmp (string, "@@") == 0
		   && width == 0xffff
		   && (operand->exp.X_add_number & 0xff8000) == 0xff8000)
	    {
	      /* Just ignore this one - which happens when trying to
		 fit a 24 bit address truncated into a 16 bit address
		 of something like mov.w.  */
	    }
	  else
	    {
	      as_warn (_("operand %s0x%lx out of range."), string,
		       (unsigned long) operand->exp.X_add_number);
	    }
	}
    }
}

/* RELAXMODE has one of 3 values:

   0 Output a "normal" reloc, no relaxing possible for this insn/reloc

   1 Output a relaxable 24bit absolute mov.w address relocation
     (may relax into a 16bit absolute address).

   2 Output a relaxable 16/24 absolute mov.b address relocation
     (may relax into an 8bit absolute address).  */

static void
do_a_fix_imm (int offset, int nibble, struct h8_op *operand, int relaxmode)
{
  int idx;
  int size;
  int where;
  char *bytes = frag_now->fr_literal + offset;

  char *t = ((operand->mode & MODE) == IMM) ? "#" : "@@";

  if (operand->exp.X_add_symbol == 0)
    {
      switch (operand->mode & SIZE)
	{
	case L_2:
	  check_operand (operand, 0x3, t);
	  bytes[0] |= (operand->exp.X_add_number & 3) << (nibble ? 0 : 4);
	  break;
	case L_3:
	case L_3NZ:
	  check_operand (operand, 0x7, t);
	  bytes[0] |= (operand->exp.X_add_number & 7) << (nibble ? 0 : 4);
	  break;
	case L_4:
	  check_operand (operand, 0xF, t);
	  bytes[0] |= (operand->exp.X_add_number & 15) << (nibble ? 0 : 4);
	  break;
	case L_5:
	  check_operand (operand, 0x1F, t);
	  bytes[0] |= operand->exp.X_add_number & 31;
	  break;
	case L_8:
	case L_8U:
	  check_operand (operand, 0xff, t);
	  bytes[0] |= operand->exp.X_add_number;
	  break;
	case L_16:
	case L_16U:
	  check_operand (operand, 0xffff, t);
	  bytes[0] |= operand->exp.X_add_number >> 8;
	  bytes[1] |= operand->exp.X_add_number >> 0;
	  break;
	case L_24:
	  check_operand (operand, 0xffffff, t);
	  bytes[0] |= operand->exp.X_add_number >> 16;
	  bytes[1] |= operand->exp.X_add_number >> 8;
	  bytes[2] |= operand->exp.X_add_number >> 0;
	  break;

	case L_32:
	  /* This should be done with bfd.  */
	  bytes[0] |= operand->exp.X_add_number >> 24;
	  bytes[1] |= operand->exp.X_add_number >> 16;
	  bytes[2] |= operand->exp.X_add_number >> 8;
	  bytes[3] |= operand->exp.X_add_number >> 0;
	  if (relaxmode != 0)
	    {
	      idx = (relaxmode == 2) ? R_MOV24B1 : R_MOVL1;
	      fix_new_exp (frag_now, offset, 4, &operand->exp, 0, idx);
	    }
	  break;
	}
    }
  else
    {
      switch (operand->mode & SIZE)
	{
	case L_24:
	case L_32:
	  size = 4;
	  where = (operand->mode & SIZE) == L_24 ? -1 : 0;
	  if (relaxmode == 2)
	    idx = R_MOV24B1;
	  else if (relaxmode == 1)
	    idx = R_MOVL1;
	  else
	    idx = R_RELLONG;
	  break;
	default:
	  as_bad (_("Can't work out size of operand.\n"));
	case L_16:
	case L_16U:
	  size = 2;
	  where = 0;
	  if (relaxmode == 2)
	    idx = R_MOV16B1;
	  else
	    idx = R_RELWORD;
	  operand->exp.X_add_number =
	    ((operand->exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	  operand->exp.X_add_number |= (bytes[0] << 8) | bytes[1];
	  break;
	case L_8:
	  size = 1;
	  where = 0;
	  idx = R_RELBYTE;
	  operand->exp.X_add_number =
	    ((operand->exp.X_add_number & 0xff) ^ 0x80) - 0x80;
	  operand->exp.X_add_number |= bytes[0];
	}

      fix_new_exp (frag_now,
		   offset + where,
		   size,
		   &operand->exp,
		   0,
		   idx);
    }
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static void
build_bytes (const struct h8_instruction *this_try, struct h8_op *operand)
{
  int i;
  char *output = frag_more (this_try->length);
  op_type *nibble_ptr = this_try->opcode->data.nib;
  op_type c;
  unsigned int nibble_count = 0;
  int op_at[3];
  int nib = 0;
  int movb = 0;
  char asnibbles[100];
  char *p = asnibbles;
  int high, low;

  if (!Hmode && this_try->opcode->available != AV_H8)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300 mode"),
	     this_try->opcode->name);
  else if (!Smode 
	   && this_try->opcode->available != AV_H8 
	   && this_try->opcode->available != AV_H8H)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300H mode"),
	     this_try->opcode->name);
  else if (!SXmode 
	   && this_try->opcode->available != AV_H8
	   && this_try->opcode->available != AV_H8H
	   && this_try->opcode->available != AV_H8S)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300S mode"),
	     this_try->opcode->name);

  while (*nibble_ptr != (op_type) E)
    {
      int d;

      nib = 0;
      c = *nibble_ptr++;

      d = (c & OP3) == OP3 ? 2 : (c & DST) == DST ? 1 : 0;

      if (c < 16)
	nib = c;
      else
	{
	  int c2 = c & MODE;

	  if (c2 == REG || c2 == LOWREG
	      || c2 == IND || c2 == PREINC || c2 == PREDEC
	      || c2 == POSTINC || c2 == POSTDEC)
	    {
	      nib = operand[d].reg;
	      if (c2 == LOWREG)
		nib &= 7;
	    }

	  else if (c & CTRL)	/* Control reg operand.  */
	    nib = operand[d].reg;

	  else if ((c & DISPREG) == (DISPREG))
	    {
	      nib = operand[d].reg;
	    }
	  else if (c2 == ABS)
	    {
	      operand[d].mode = c;
	      op_at[d] = nibble_count;
	      nib = 0;
	    }
	  else if (c2 == IMM || c2 == PCREL || c2 == ABS
		   || (c & ABSJMP) || c2 == DISP)
	    {
	      operand[d].mode = c;
	      op_at[d] = nibble_count;
	      nib = 0;
	    }
	  else if ((c & IGNORE) || (c & DATA))
	    nib = 0;

	  else if (c2 == DBIT)
	    {
	      switch (operand[0].exp.X_add_number)
		{
		case 1:
		  nib = c;
		  break;
		case 2:
		  nib = 0x8 | c;
		  break;
		default:
		  as_bad (_("Need #1 or #2 here"));
		}
	    }
	  else if (c2 == KBIT)
	    {
	      switch (operand[0].exp.X_add_number)
		{
		case 1:
		  nib = 0;
		  break;
		case 2:
		  nib = 8;
		  break;
		case 4:
		  if (!Hmode)
		    as_warn (_("#4 not valid on H8/300."));
		  nib = 9;
		  break;

		default:
		  as_bad (_("Need #1 or #2 here"));
		  break;
		}
	      /* Stop it making a fix.  */
	      operand[0].mode = 0;
	    }

	  if (c & MEMRELAX)
	    operand[d].mode |= MEMRELAX;

	  if (c & B31)
	    nib |= 0x8;

	  if (c & B21)
	    nib |= 0x4;

	  if (c & B11)
	    nib |= 0x2;

	  if (c & B01)
	    nib |= 0x1;

	  if (c2 == MACREG)
	    {
	      if (operand[0].mode == MACREG)
		/* stmac has mac[hl] as the first operand.  */
		nib = 2 + operand[0].reg;
	      else
		/* ldmac has mac[hl] as the second operand.  */
		nib = 2 + operand[1].reg;
	    }
	}
      nibble_count++;

      *p++ = nib;
    }

  /* Disgusting.  Why, oh why didn't someone ask us for advice
     on the assembler format.  */
  if (OP_KIND (this_try->opcode->how) == O_LDM)
    {
      high = (operand[1].reg >> 8) & 0xf;
      low  = (operand[1].reg) & 0xf;
      asnibbles[2] = high - low;
      asnibbles[7] = high;
    }
  else if (OP_KIND (this_try->opcode->how) == O_STM)
    {
      high = (operand[0].reg >> 8) & 0xf;
      low  = (operand[0].reg) & 0xf;
      asnibbles[2] = high - low;
      asnibbles[7] = low;
    }

  for (i = 0; i < this_try->length; i++)
    output[i] = (asnibbles[i * 2] << 4) | asnibbles[i * 2 + 1];

  /* Note if this is a movb or a bit manipulation instruction
     there is a special relaxation which only applies.  */
  if (   this_try->opcode->how == O (O_MOV,   SB)
      || this_try->opcode->how == O (O_BCLR,  SB)
      || this_try->opcode->how == O (O_BAND,  SB)
      || this_try->opcode->how == O (O_BIAND, SB)
      || this_try->opcode->how == O (O_BILD,  SB)
      || this_try->opcode->how == O (O_BIOR,  SB)
      || this_try->opcode->how == O (O_BIST,  SB)
      || this_try->opcode->how == O (O_BIXOR, SB)
      || this_try->opcode->how == O (O_BLD,   SB)
      || this_try->opcode->how == O (O_BNOT,  SB)
      || this_try->opcode->how == O (O_BOR,   SB)
      || this_try->opcode->how == O (O_BSET,  SB)
      || this_try->opcode->how == O (O_BST,   SB)
      || this_try->opcode->how == O (O_BTST,  SB)
      || this_try->opcode->how == O (O_BXOR,  SB))
    movb = 1;

  /* Output any fixes.  */
  for (i = 0; i < this_try->noperands; i++)
    {
      int x = operand[i].mode;
      int x_mode = x & MODE;

      if (x_mode == IMM || x_mode == DISP)
	do_a_fix_imm (output - frag_now->fr_literal + op_at[i] / 2,
		      op_at[i] & 1, operand + i, (x & MEMRELAX) != 0);

      else if (x_mode == ABS)
	do_a_fix_imm (output - frag_now->fr_literal + op_at[i] / 2,
		      op_at[i] & 1, operand + i,
		      (x & MEMRELAX) ? movb + 1 : 0);

      else if (x_mode == PCREL)
	{
	  int size16 = (x & SIZE) == L_16;
	  int size = size16 ? 2 : 1;
	  int type = size16 ? R_PCRWORD : R_PCRBYTE;
	  fixS *fixP;

	  check_operand (operand + i, size16 ? 0x7fff : 0x7f, "@@");

	  if (operand[i].exp.X_add_number & 1)
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);
#ifndef OBJ_ELF
	  /* The COFF port has always been off by one, changing it
	     now would be an incompatible change, so we leave it as-is.

	     We don't want to do this for ELF as we want to be
	     compatible with the proposed ELF format from Hitachi.  */
	  operand[i].exp.X_add_number -= 1;
#endif
	  if (size16)
	    {
	      operand[i].exp.X_add_number =
		((operand[i].exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	    }
	  else
	    {
	      operand[i].exp.X_add_number =
		((operand[i].exp.X_add_number & 0xff) ^ 0x80) - 0x80;
	    }

	  /* For BRA/S.  */
	  if (! size16)
	    operand[i].exp.X_add_number |= output[op_at[i] / 2];

	  fixP = fix_new_exp (frag_now,
			      output - frag_now->fr_literal + op_at[i] / 2,
			      size,
			      &operand[i].exp,
			      1,
			      type);
	  fixP->fx_signed = 1;
	}
      else if (x_mode == MEMIND)
	{
	  check_operand (operand + i, 0xff, "@@@@");
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + 1,
		       1,
		       &operand[i].exp,
		       0,
		       R_MEM_INDIRECT);
	}
      else if (x_mode == VECIND)
	{
	  check_operand (operand + i, 0x7f, "@@@@");
	  /* FIXME: approximating the effect of "B31" here...
	     This is very hackish, and ought to be done a better way.  */
	  operand[i].exp.X_add_number |= 0x80;
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + 1,
		       1,
		       &operand[i].exp,
		       0,
		       R_MEM_INDIRECT);
	}
      else if (x & ABSJMP)
	{
	  int where = 0;
	  bfd_reloc_code_real_type reloc_type = R_JMPL1;

#ifdef OBJ_ELF
	  /* To be compatible with the proposed H8 ELF format, we
	     want the relocation's offset to point to the first byte
	     that will be modified, not to the start of the instruction.  */
	  
	  if ((operand->mode & SIZE) == L_32)
	    {
	      where = 2;
	      reloc_type = R_RELLONG;
	    }
	  else
	    where = 1;
#endif

	  /* This jmp may be a jump or a branch.  */

	  check_operand (operand + i, 
			 SXmode ? 0xffffffff : Hmode ? 0xffffff : 0xffff, 
			 "@@");

	  if (operand[i].exp.X_add_number & 1)
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);

	  if (!Hmode)
	    operand[i].exp.X_add_number =
	      ((operand[i].exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + where,
		       4,
		       &operand[i].exp,
		       0,
		       reloc_type);
	}
    }
}

/* Try to give an intelligent error message for common and simple to
   detect errors.  */

static void
clever_message (const struct h8_instruction *instruction,
		struct h8_op *operand)
{
  /* Find out if there was more than one possible opcode.  */

  if ((instruction + 1)->idx != instruction->idx)
    {
      int argn;

      /* Only one opcode of this flavour, try to guess which operand
         didn't match.  */
      for (argn = 0; argn < instruction->noperands; argn++)
	{
	  switch (instruction->opcode->args.nib[argn])
	    {
	    case RD16:
	      if (operand[argn].mode != RD16)
		{
		  as_bad (_("destination operand must be 16 bit register"));
		  return;

		}
	      break;

	    case RS8:
	      if (operand[argn].mode != RS8)
		{
		  as_bad (_("source operand must be 8 bit register"));
		  return;
		}
	      break;

	    case ABS16DST:
	      if (operand[argn].mode != ABS16DST)
		{
		  as_bad (_("destination operand must be 16bit absolute address"));
		  return;
		}
	      break;
	    case RD8:
	      if (operand[argn].mode != RD8)
		{
		  as_bad (_("destination operand must be 8 bit register"));
		  return;
		}
	      break;

	    case ABS16SRC:
	      if (operand[argn].mode != ABS16SRC)
		{
		  as_bad (_("source operand must be 16bit absolute address"));
		  return;
		}
	      break;

	    }
	}
    }
  as_bad (_("invalid operands"));
}


/* If OPERAND is part of an address, adjust its size and value given
   that it addresses SIZE bytes.

   This function decides how big non-immediate constants are when no
   size was explicitly given.  It also scales down the assembly-level
   displacement in an @@(d:2,ERn) operand.  */

static void
fix_operand_size (struct h8_op *operand, int size)
{
  if (SXmode && (operand->mode & MODE) == DISP)
    {
      /* If the user didn't specify an operand width, see if we
	 can use @@(d:2,ERn).  */
      if ((operand->mode & SIZE) == 0
	  && operand->exp.X_add_symbol == 0
	  && operand->exp.X_op_symbol == 0
	  && (operand->exp.X_add_number == size
	      || operand->exp.X_add_number == size * 2
	      || operand->exp.X_add_number == size * 3))
	operand->mode |= L_2;

      /* Scale down the displacement in an @@(d:2,ERn) operand.
	 X_add_number then contains the desired field value.  */
      if ((operand->mode & SIZE) == L_2)
	{
	  if (operand->exp.X_add_number % size != 0)
	    as_warn (_("operand/size mis-match"));
	  operand->exp.X_add_number /= size;
	}
    }

  if ((operand->mode & SIZE) == 0)
    switch (operand->mode & MODE)
      {
      case DISP:
      case INDEXB:
      case INDEXW:
      case INDEXL:
      case ABS:
	/* Pick a 24-bit address unless we know that a 16-bit address
	   is safe.  get_specific() will relax L_24 into L_32 where
	   necessary.  */
	if (Hmode
	    && !Nmode 
	    && (operand->exp.X_add_number < -32768
		|| operand->exp.X_add_number > 32767
		|| operand->exp.X_add_symbol != 0
		|| operand->exp.X_op_symbol != 0))
	  operand->mode |= L_24;
	else
	  operand->mode |= L_16;
	break;

      case PCREL:
	/* This condition is long standing, though somewhat suspect.  */
	if (operand->exp.X_add_number > -128
	    && operand->exp.X_add_number < 127)
	  operand->mode |= L_8;
	else
	  operand->mode |= L_16;
	break;
      }
}


/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles.  */

void
md_assemble (char *str)
{
  char *op_start;
  char *op_end;
  struct h8_op operand[3];
  const struct h8_instruction *instruction;
  const struct h8_instruction *prev_instruction;

  char *dot = 0;
  char *slash = 0;
  char c;
  int size, i;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the op code end.  */
  for (op_start = op_end = str;
       *op_end != 0 && *op_end != ' ';
       op_end++)
    {
      if (*op_end == '.')
	{
	  dot = op_end + 1;
	  *op_end = 0;
	  op_end += 2;
	  break;
	}
      else if (*op_end == '/' && ! slash)
	slash = op_end;
    }

  if (op_end == op_start)
    {
      as_bad (_("can't find opcode "));
    }
  c = *op_end;

  *op_end = 0;

  /* The assembler stops scanning the opcode at slashes, so it fails
     to make characters following them lower case.  Fix them.  */
  if (slash)
    while (*++slash)
      *slash = TOLOWER (*slash);

  instruction = (const struct h8_instruction *)
    hash_find (opcode_hash_control, op_start);

  if (instruction == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  /* We used to set input_line_pointer to the result of get_operands,
     but that is wrong.  Our caller assumes we don't change it.  */

  operand[0].mode = 0;
  operand[1].mode = 0;
  operand[2].mode = 0;

  if (OP_KIND (instruction->opcode->how) == O_MOVAB
      || OP_KIND (instruction->opcode->how) == O_MOVAW
      || OP_KIND (instruction->opcode->how) == O_MOVAL)
    get_mova_operands (op_end, operand);
  else if (OP_KIND (instruction->opcode->how) == O_RTEL
	   || OP_KIND (instruction->opcode->how) == O_RTSL)
    get_rtsl_operands (op_end, operand);
  else
    get_operands (instruction->noperands, op_end, operand);

  *op_end = c;
  prev_instruction = instruction;

  /* Now we have operands from instruction.
     Let's check them out for ldm and stm.  */
  if (OP_KIND (instruction->opcode->how) == O_LDM)
    {
      /* The first operand must be @@er7+, and the
	 second operand must be a register pair.  */
      if ((operand[0].mode != RSINC)
           || (operand[0].reg != 7)
           || ((operand[1].reg & 0x80000000) == 0))
	as_bad (_("invalid operand in ldm"));
    }
  else if (OP_KIND (instruction->opcode->how) == O_STM)
    {
      /* The first operand must be a register pair,
	 and the second operand must be @@-er7.  */
      if (((operand[0].reg & 0x80000000) == 0)
            || (operand[1].mode != RDDEC)
            || (operand[1].reg != 7))
	as_bad (_("invalid operand in stm"));
    }

  size = SN;
  if (dot)
    {
      switch (TOLOWER (*dot))
	{
	case 'b':
	  size = SB;
	  break;

	case 'w':
	  size = SW;
	  break;

	case 'l':
	  size = SL;
	  break;
	}
    }
  if (OP_KIND (instruction->opcode->how) == O_MOVAB ||
      OP_KIND (instruction->opcode->how) == O_MOVAW ||
      OP_KIND (instruction->opcode->how) == O_MOVAL)
    {
      switch (operand[0].mode & MODE)
	{
	case INDEXB:
	default:
	  fix_operand_size (&operand[1], 1);
	  break;
	case INDEXW:
	  fix_operand_size (&operand[1], 2);
	  break;
	case INDEXL:
	  fix_operand_size (&operand[1], 4);
	  break;
	}
    }
  else
    {
      for (i = 0; i < 3 && operand[i].mode != 0; i++)
	switch (size)
	  {
	  case SN:
	  case SB:
	  default:
	    fix_operand_size (&operand[i], 1);
	    break;
	  case SW:
	    fix_operand_size (&operand[i], 2);
	    break;
	  case SL:
	    fix_operand_size (&operand[i], 4);
	    break;
	  }
    }

  instruction = get_specific (instruction, operand, size);

  if (instruction == 0)
    {
      /* Couldn't find an opcode which matched the operands.  */
      char *where = frag_more (2);

      where[0] = 0x0;
      where[1] = 0x0;
      clever_message (prev_instruction, operand);

      return;
    }

  build_bytes (instruction, operand);

#ifdef BFD_ASSEMBLER
  dwarf2_emit_insn (instruction->length);
#endif
}

#ifndef BFD_ASSEMBLER
void
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}
#endif

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

#ifndef BFD_ASSEMBLER
void
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
{
  printf (_("call to tc_headers_hook \n"));
}
#endif

/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

const char *md_shortopts = "";
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
{
  return 0;
}

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
}

void tc_aout_fix_to_chars (void);

void
tc_aout_fix_to_chars (void)
{
  printf (_("call to tc_aout_fix_to_chars \n"));
  abort ();
}

void
md_convert_frag (
#ifdef BFD_ASSEMBLER
		 bfd *headers ATTRIBUTE_UNUSED,
#else
		 object_headers *headers ATTRIBUTE_UNUSED,
#endif
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
{
  printf (_("call to md_convert_frag \n"));
  abort ();
}

#ifdef BFD_ASSEMBLER
valueT
md_section_align (segT segment, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << align) - 1) & (-1 << align));
}
#else
valueT
md_section_align (segT seg, valueT size)
{
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
}
#endif


void
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  long val = *valP;

  switch (fixP->fx_size)
    {
    case 1:
      *buf++ = val;
      break;
    case 2:
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    case 4:
      *buf++ = (val >> 24);
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    default:
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

int
md_estimate_size_before_relax (register fragS *fragP ATTRIBUTE_UNUSED,
			       register segT segment_type ATTRIBUTE_UNUSED)
{
  printf (_("call tomd_estimate_size_before_relax \n"));
  abort ();
}

/* Put number into target byte order.  */
void
md_number_to_chars (char *ptr, valueT use, int nbytes)
{
  number_to_chars_bigendian (ptr, use, nbytes);
}

long
md_pcrel_from (fixS *fixP ATTRIBUTE_UNUSED)
{
  abort ();
}

#ifndef BFD_ASSEMBLER
void
tc_reloc_mangle (fixS *fix_ptr, struct internal_reloc *intr, bfd_vma base)
{
  symbolS *symbol_ptr;

  symbol_ptr = fix_ptr->fx_addsy;

  /* If this relocation is attached to a symbol then it's ok
     to output it.  */
  if (fix_ptr->fx_r_type == TC_CONS_RELOC)
    {
      /* cons likes to create reloc32's whatever the size of the reloc..
       */
      switch (fix_ptr->fx_size)
	{
	case 4:
	  intr->r_type = R_RELLONG;
	  break;
	case 2:
	  intr->r_type = R_RELWORD;
	  break;
	case 1:
	  intr->r_type = R_RELBYTE;
	  break;
	default:
	  abort ();
	}
    }
  else
    {
      intr->r_type = fix_ptr->fx_r_type;
    }

  intr->r_vaddr = fix_ptr->fx_frag->fr_address + fix_ptr->fx_where + base;
  intr->r_offset = fix_ptr->fx_offset;

  if (symbol_ptr)
    {
      if (symbol_ptr->sy_number != -1)
	intr->r_symndx = symbol_ptr->sy_number;
      else
	{
	  symbolS *segsym;

	  /* This case arises when a reference is made to `.'.  */
	  segsym = seg_info (S_GET_SEGMENT (symbol_ptr))->dot;
	  if (segsym == NULL)
	    intr->r_symndx = -1;
	  else
	    {
	      intr->r_symndx = segsym->sy_number;
	      intr->r_offset += S_GET_VALUE (symbol_ptr);
	    }
	}
    }
  else
    intr->r_symndx = -1;
}
#else /* BFD_ASSEMBLER */
arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *rel;
  bfd_reloc_code_real_type r_type;

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Difference of symbols in different sections is not supported");
	  return NULL;
	}
    }

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  rel->addend = fixp->fx_offset;

  r_type = fixp->fx_r_type;

#define DEBUG 0
#if DEBUG
  fprintf (stderr, "%s\n", bfd_get_reloc_code_name (r_type));
  fflush(stderr);
#endif
  rel->howto = bfd_reloc_type_lookup (stdoutput, r_type);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (r_type));
      return NULL;
    }

  return rel;
}
#endif
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d46 8
a53 7
void cons        PARAMS ((int));
void sbranch     PARAMS ((int));
void h8300hmode  PARAMS ((int));
void h8300smode  PARAMS ((int));
void h8300hnmode PARAMS ((int));
void h8300snmode PARAMS ((int));
static void pint PARAMS ((int));
d58 1
d60 1
a60 3
#define PSIZE (Hmode ? L_32 : L_16)
#define DMODE (L_16)
#define DSYMMODE (Hmode ? L_24 : L_16)
d62 1
a62 1
int bsize = L_8;		/* Default branch displacement.  */
d73 1
a73 1
struct h8_instruction *h8_instructions;
d75 2
a76 3
void
h8300hmode (arg)
     int arg ATTRIBUTE_UNUSED;
d86 2
a87 3
void
h8300smode (arg)
     int arg ATTRIBUTE_UNUSED;
d97 2
a98 3
void
h8300hnmode (arg)
     int arg ATTRIBUTE_UNUSED;
d109 2
a110 3
void
h8300snmode (arg)
     int arg ATTRIBUTE_UNUSED;
d121 27
a147 3
void
sbranch (size)
     int size;
d153 1
a153 2
pint (arg)
     int arg ATTRIBUTE_UNUSED;
d166 1
a166 1
  {"h8300h", h8300hmode, 0},
d168 1
a168 1
  {"h8300s", h8300smode, 0},
d170 2
a174 5
#ifdef BFD_ASSEMBLER
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
#endif

d181 2
a182 2
  {"import", s_ignore, 0},
  {"page", listing_eject, 0},
d203 1
a203 1
md_begin ()
d206 1
a206 1
  const struct h8_opcode *p;
d224 16
a239 2
  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
    {
d241 2
a242 7
         unique codes into the hash table.  */
      char *src = p->name;
      unsigned int len = strlen (src);
      char *dst = malloc (len + 1);
      char *buffer = dst;

      pi->size = 0;
a247 1
	      pi->size = *src;
d250 2
d254 42
a295 18
      *dst++ = 0;
      if (strcmp (buffer, prev_buffer))
	{
	  hash_insert (opcode_hash_control, buffer, (char *) pi);
	  strcpy (prev_buffer, buffer);
	  idx++;
	}
      pi->idx = idx;

      /* Find the number of operands.  */
      pi->noperands = 0;
      while (p->args.nib[pi->noperands] != E)
	pi->noperands++;

      /* Find the length of the opcode in bytes.  */
      pi->length = 0;
      while (p->data.nib[pi->length * 2] != E)
	pi->length++;
d297 4
a300 1
      pi->opcode = p;
d308 1
a308 1
  pi->opcode = p;
a312 10
struct h8_exp
{
  char *e_beg;
  char *e_end;
  expressionS e_exp;
};

int dispreg;
int opsize;			/* Set when a register size is seen.  */

d320 14
a333 11
static void clever_message PARAMS ((const struct h8_instruction *, struct h8_op *));
static void build_bytes    PARAMS ((const struct h8_instruction *, struct h8_op *));
static void do_a_fix_imm   PARAMS ((int, struct h8_op *, int));
static void check_operand  PARAMS ((struct h8_op *, unsigned int, char *));
static const struct h8_instruction * get_specific PARAMS ((const struct h8_instruction *, struct h8_op *, int));
static char * get_operands PARAMS ((unsigned, char *, struct h8_op *));
static void   get_operand  PARAMS ((char **, struct h8_op *, unsigned, int));
static char * skip_colonthing PARAMS ((char *, expressionS *, int *));
static char * parse_exp PARAMS ((char *, expressionS *));
static int    parse_reg PARAMS ((char *, op_type *, unsigned *, int));
char * colonmod24 PARAMS ((struct h8_op *, char *));
d349 1
a349 5
parse_reg (src, mode, reg, direction)
     char *src;
     op_type *mode;
     unsigned int *reg;
     int direction;
d358 1
a358 1
  while (is_part_of_name (*end) || *end == '\001')
d362 1
a362 1
  if (len == 2 && src[0] == 's' && src[1] == 'p')
d368 4
a371 1
  if (len == 3 && src[0] == 'c' && src[1] == 'c' && src[2] == 'r')
d377 4
a380 1
  if (len == 3 && src[0] == 'e' && src[1] == 'x' && src[2] == 'r')
d383 19
a401 1
      *reg = 0;
d404 1
a404 1
  if (len == 2 && src[0] == 'f' && src[1] == 'p')
d410 2
a411 2
  if (len == 3 && src[0] == 'e' && src[1] == 'r'
      && src[2] >= '0' && src[2] <= '7')
d419 1
a419 1
  if (len == 2 && src[0] == 'e' && src[1] >= '0' && src[1] <= '7')
d428 1
a428 1
  if (src[0] == 'r')
d432 1
a432 1
	  if (len == 3 && src[2] == 'l')
d438 1
a438 1
	  if (len == 3 && src[2] == 'h')
d456 5
d462 8
a469 10
parse_exp (s, op)
     char *s;
     expressionS *op;
{
  char *save = input_line_pointer;
  char *new;

  input_line_pointer = s;
  expression (op);
  if (op->X_op == O_absent)
d471 1
a471 1
  new = input_line_pointer;
d473 2
a474 1
  return new;
d477 4
d482 1
a482 4
skip_colonthing (ptr, exp, mode)
     char *ptr;
     expressionS *exp ATTRIBUTE_UNUSED;
     int *mode;
d484 1
a484 1
  if (*ptr == ':')
d486 1
a486 1
      ptr++;
d488 16
a503 7
      if (*ptr == '8')
	{
	  ptr++;
	  /* ff fill any 8 bit quantity.  */
	  /* exp->X_add_number -= 0x100; */
	  *mode |= L_8;
	}
d505 4
a508 16
	{
	  if (*ptr == '2')
	    {
	      *mode |= L_24;
	    }
	  else if (*ptr == '3')
	    {
	      *mode |= L_32;
	    }
	  else if (*ptr == '1')
	    {
	      *mode |= L_16;
	    }
	  while (ISDIGIT (*ptr))
	    ptr++;
	}
d510 1
a510 1
  return ptr;
d528 2
a529 4
char *
colonmod24 (op, src)
     struct h8_op *op;
     char *src;
d531 3
a533 2
  int mode = 0;
  src = skip_colonthing (src, &op->exp, &mode);
d535 8
a542 1
  if (!mode)
d544 22
a565 14
      /* Choose a default mode.  */
      if (op->exp.X_add_number < -32768
	  || op->exp.X_add_number > 32767)
	{
	  if (Hmode)
	    mode = L_24;
	  else
	    mode = L_16;
	}
      else if (op->exp.X_add_symbol
	       || op->exp.X_op_symbol)
	mode = DSYMMODE;
      else
	mode = DMODE;
a566 3

  op->mode |= mode;
  return src;
d570 1
a570 5
get_operand (ptr, op, dst, direction)
     char **ptr;
     struct h8_op *op;
     unsigned int dst ATTRIBUTE_UNUSED;
     int direction;
d577 1
a577 1
  op->mode = E;
d585 3
a587 2
  if (src[0] == 'e' && src[1] == 'r' && ISDIGIT (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && ISDIGIT (src[6]))
d594 10
a603 11
      if (high < low)
	as_bad (_("Invalid register list for ldm/stm\n"));

      if (low % 2)
	as_bad (_("Invalid register list for ldm/stm\n"));

      if (high - low > 3)
	as_bad (_("Invalid register list for ldm/stm\n"));

      if (high - low != 1
	  && low % 4)
d622 31
a652 1
      *ptr = src + len;
d661 4
a664 2
	  src++;
	  src = parse_exp (src, &op->exp);
d666 8
a673 1
	  src = skip_colonthing (src, &op->exp, &op->mode);
d675 4
a678 3
	  *ptr = src;

	  op->mode = MEMIND;
d682 1
a682 1
      if (*src == '-')
d684 1
a684 2
	  src++;
	  len = parse_reg (src, &mode, &num, direction);
d688 2
a689 6
	      src--;
	      /* Must be a symbol.  */
	      op->mode = ABS | PSIZE | direction;
	      *ptr = skip_colonthing (parse_exp (src, &op->exp),
				      &op->exp, &op->mode);

d693 3
a695 1
	  if ((mode & SIZE) != PSIZE)
d697 2
a698 1
	  op->mode = RDDEC;
d700 1
a700 1
	  *ptr = src + len;
a704 1
	  /* Disp.  */
d707 33
a739 1
	  /* Start off assuming a 16 bit offset.  */
d741 1
a741 1
	  src = parse_exp (src, &op->exp);
d743 1
a743 1
	  src = colonmod24 (op, src);
d745 1
a747 1
	      src++;
d749 1
a749 1
	      *ptr = src;
a756 1

d761 1
a761 1
	  if (len == 0 || !(mode & REG))
a765 2
	  op->mode |= DISP | direction;
	  dispreg = op->reg;
d767 22
a788 1
	  src = skip_colonthing (src, &op->exp, &op->mode);
a795 1

d803 1
a803 1
	  if (*src == '+')
d805 3
a807 2
	      src++;
	      if ((mode & SIZE) != PSIZE)
d809 1
a809 1
	      op->mode = RSINC;
d811 1
d815 3
a817 1
	  if ((mode & SIZE) != PSIZE)
d831 1
a831 4
	  src = parse_exp (src, &op->exp);

	  *ptr = colonmod24 (op, src);

a837 1
      src++;
d839 1
a839 3
      src = parse_exp (src, &op->exp);
      *ptr = skip_colonthing (src, &op->exp, &op->mode);

d842 4
a845 2
  else if (strncmp (src, "mach", 4) == 0
	   || strncmp (src, "macl", 4) == 0)
d847 1
a847 1
      op->reg = src[3] == 'l';
d854 2
a855 21
      src = parse_exp (src, &op->exp);
      /* Trailing ':' size ? */
      if (*src == ':')
	{
	  if (src[1] == '1' && src[2] == '6')
	    {
	      op->mode = PCREL | L_16;
	      src += 3;
	    }
	  else if (src[1] == '8')
	    {
	      op->mode = PCREL | L_8;
	      src += 2;
	    }
	  else
	    as_bad (_("expect :8 or :16 here"));
	}
      else
	op->mode = PCREL | bsize;

      *ptr = src;
d860 1
a860 4
get_operands (noperands, op_end, operand)
     unsigned int noperands;
     char *op_end;
     struct h8_op *operand;
a866 2
      operand[0].mode = 0;
      operand[1].mode = 0;
d871 1
a871 1
      get_operand (&ptr, operand + 0, 0, SRC);
d875 1
a875 5
	  get_operand (&ptr, operand + 1, 1, DST);
	}
      else
	{
	  operand[1].mode = 0;
d881 1
a881 1
      get_operand (&ptr, operand + 0, 0, SRC);
d884 12
a895 1
      get_operand (&ptr, operand + 1, 1, DST);
d905 121
d1031 2
a1032 4
get_specific (instruction, operands, size)
     const struct h8_instruction *instruction;
     struct h8_op *operands;
     int size;
d1035 1
d1038 1
d1042 2
a1043 2
  if (strcmp (instruction->opcode->name, "stm.l") == 0
      || strcmp (instruction->opcode->name, "ldm.l") == 0)
d1046 3
d1051 2
a1053 1

d1055 1
a1055 3
      if (this_try->noperands == 0)
	{
	  int this_size;
d1057 3
a1059 5
	  this_size = this_try->opcode->how & SN;
	  if (this_size != size && (this_size != SB || size != SN))
	    found = 0;
	}
      else
d1066 2
d1069 2
d1072 1
a1072 2
	      if ((op & (DISP | REG)) == (DISP | REG)
		  && ((x & (DISP | REG)) == (DISP | REG)))
d1074 6
a1079 1
		  dispreg = operands[i].reg;
d1081 1
a1081 1
	      else if (op & REG)
d1083 3
a1085 1
		  if (!(x & REG))
d1088 4
a1091 6
		  if (x & L_P)
		    x = (x & ~L_P) | (Hmode ? L_32 : L_16);
		  if (op & L_P)
		    op = (op & ~L_P) | (Hmode ? L_32 : L_16);

		  opsize = op & SIZE;
d1094 1
a1094 1
		  if ((op & SIZE) != (x & SIZE))
d1097 1
a1097 1
	      else if ((op & ABSJMP) && (x & ABS))
d1099 44
a1142 1
		  operands[i].mode &= ~ABS;
d1145 1
a1145 1
		  if (!Hmode)
d1150 3
d1154 1
a1154 1
	      else if ((op & (KBIT | DBIT)) && (x & IMM))
d1156 13
a1168 1
		  /* This is ok if the immediate value is sensible.  */
d1170 1
a1170 1
	      else if (op & PCREL)
d1172 8
d1181 1
a1181 1
		  if ((op & SIZE) != (x & SIZE))
d1184 4
a1187 2
	      else if ((op & (DISP | IMM | ABS))
		       && (op & (DISP | IMM | ABS)) == (x & (DISP | IMM | ABS)))
d1190 1
a1190 1
		  if ((x & L_24) && (op & L_32))
d1192 2
a1193 2
		      x &= ~L_24;
		      x |= L_32;
d1195 2
d1198 1
a1198 1
		  if (op & ABS && op & L_8 && op & DISP)
d1200 2
a1201 2
		      if (x & L_16)
			found = 1;
d1203 16
a1218 2
		  else if ((x & SIZE) != 0
			   && ((op & SIZE) != (x & SIZE)))
d1221 1
a1221 5
	      else if ((op & MACREG) != (x & MACREG))
		{
		  found = 0;
		}
	      else if ((op & MODE) != (x & MODE))
d1227 10
d1240 15
a1254 2
  else
    return 0;
d1258 1
a1258 4
check_operand (operand, width, string)
     struct h8_op *operand;
     unsigned int width;
     char *string;
d1268 1
a1268 2
      if ((operand->exp.X_add_number & ~width) != 0 &&
	  (operand->exp.X_add_number | width) != (unsigned)(~0))
d1305 1
a1305 4
do_a_fix_imm (offset, operand, relaxmode)
     int offset;
     struct h8_op *operand;
     int relaxmode;
d1310 1
d1312 1
a1312 1
  char *t = operand->mode & IMM ? "#" : "@@";
a1315 1
      char *bytes = frag_now->fr_literal + offset;
d1320 1
a1320 1
	  bytes[0] |= (operand->exp.X_add_number) << 4;
d1323 1
d1325 9
a1333 1
	  bytes[0] |= (operand->exp.X_add_number) << 4;
d1336 1
d1338 1
a1338 1
	  bytes[0] = operand->exp.X_add_number;
d1341 1
d1343 2
a1344 2
	  bytes[0] = operand->exp.X_add_number >> 8;
	  bytes[1] = operand->exp.X_add_number >> 0;
d1348 3
a1350 3
	  bytes[0] = operand->exp.X_add_number >> 16;
	  bytes[1] = operand->exp.X_add_number >> 8;
	  bytes[2] = operand->exp.X_add_number >> 0;
d1355 4
a1358 4
	  bytes[0] = operand->exp.X_add_number >> 24;
	  bytes[1] = operand->exp.X_add_number >> 16;
	  bytes[2] = operand->exp.X_add_number >> 8;
	  bytes[3] = operand->exp.X_add_number >> 0;
d1385 1
d1394 1
d1402 1
d1417 1
a1417 3
build_bytes (this_try, operand)
     const struct h8_instruction *this_try;
     struct h8_op *operand;
d1424 1
a1424 2
  int absat = 0;
  int immat = 0;
d1427 1
a1427 1
  char asnibbles[30];
d1429 1
d1431 1
a1431 1
  if (!(this_try->opcode->inbase || Hmode))
d1434 11
d1446 1
a1446 1
  while (*nibble_ptr != E)
d1449 2
d1453 1
a1453 1
      d = (c & (DST | SRC_IN_DST)) != 0;
d1459 12
a1470 1
	  if (c & (REG | IND | INC | DEC))
d1474 4
a1477 3
	    nib = dispreg;

	  else if (c & ABS)
d1480 1
a1480 1
	      absat = nibble_count / 2;
d1483 2
a1484 1
	  else if (c & (IMM | PCREL | ABS | ABSJMP | DISP))
d1487 1
a1487 1
	      immat = nibble_count / 2;
d1490 1
a1490 1
	  else if (c & IGNORE)
d1493 1
a1493 1
	  else if (c & DBIT)
d1507 1
a1507 1
	  else if (c & KBIT)
d1537 10
a1546 1
	  if (c & MACREG)
d1563 1
a1563 2
  if (strcmp (this_try->opcode->name, "stm.l") == 0
      || strcmp (this_try->opcode->name, "ldm.l") == 0)
d1565 9
a1573 4
      int high, low;
      high = (operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg & 0xf;

d1575 1
a1575 1
      asnibbles[7] = (this_try->opcode->name[0] == 'l') ? high : low;
d1581 17
a1597 3
  /* Note if this is a movb instruction -- there's a special relaxation
     which only applies to them.  */
  if (strcmp (this_try->opcode->name, "mov.b") == 0)
d1601 1
a1601 1
  for (i = 0; i < 2; i++)
d1604 5
d1610 4
a1613 7
      if (x & (IMM | DISP))
	do_a_fix_imm (output - frag_now->fr_literal + immat,
		      operand + i, (x & MEMRELAX) != 0);

      else if (x & ABS)
	do_a_fix_imm (output - frag_now->fr_literal + absat,
		      operand + i, (x & MEMRELAX) ? movb + 1 : 0);
d1615 1
a1615 1
      else if (x & PCREL)
d1617 1
a1617 2
	  int size16 = x & (L_16);
	  int where = size16 ? 2 : 1;
d1635 14
a1648 2
	  operand[i].exp.X_add_number =
	    ((operand[i].exp.X_add_number & 0xff) ^ 0x80) - 0x80;
d1651 1
a1651 1
			      output - frag_now->fr_literal + where,
d1658 1
a1658 1
      else if (x & MEMIND)
d1668 13
d1684 1
d1690 8
a1697 1
	  where += 1;
d1702 3
a1704 1
	  check_operand (operand + i, Hmode ? 0xffffff : 0xffff, "@@");
d1718 1
a1718 1
		       R_JMPL1);
d1727 2
a1728 3
clever_message (instruction, operand)
     const struct h8_instruction *instruction;
     struct h8_op *operand;
d1788 67
d1860 1
a1860 2
md_assemble (str)
     char *str;
d1864 1
a1864 1
  struct h8_op operand[2];
d1869 1
d1871 1
a1871 1
  int size;
d1889 2
d1901 6
d1919 14
a1932 1
  (void) get_operands (instruction->noperands, op_end, operand);
d1936 21
d1960 1
a1960 1
      switch (*dot)
d1975 37
a2024 7
  if (instruction->size && dot)
    {
      if (instruction->size != *dot)
	{
	  as_warn (_("mismatch between opcode size and operand size"));
	}
    }
d2035 1
a2035 2
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d2042 1
a2042 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d2049 1
a2049 2
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
d2065 1
a2065 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d2123 1
a2123 3
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d2129 1
a2129 2
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
d2133 1
a2133 1
void tc_aout_fix_to_chars PARAMS ((void));
d2136 1
a2136 1
tc_aout_fix_to_chars ()
d2143 1
a2143 1
md_convert_frag (headers, seg, fragP)
d2145 1
a2145 1
     bfd *headers ATTRIBUTE_UNUSED;
d2147 1
a2147 1
     object_headers *headers ATTRIBUTE_UNUSED;
d2149 2
a2150 2
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d2158 1
a2158 3
md_section_align (segment, size)
     segT segment;
     valueT size;
d2165 1
a2165 3
md_section_align (seg, size)
     segT seg;
     valueT size;
d2174 1
a2174 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d2203 2
a2204 3
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP ATTRIBUTE_UNUSED;
     register segT segment_type ATTRIBUTE_UNUSED;
d2212 1
a2212 4
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
d2218 1
a2218 2
md_pcrel_from (fixP)
     fixS *fixP ATTRIBUTE_UNUSED;
d2225 1
a2225 5
tc_reloc_mangle (fix_ptr, intr, base)
     fixS *fix_ptr;
     struct internal_reloc *intr;
     bfd_vma base;

d2284 1
a2284 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
@


1.5
log
@resolve conflicts.
@
text
@d1 3
a3 3
/* tc-h8300.c -- Assemble code for the Hitachi H8/300
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000
   Free Software Foundation, Inc.
d28 5
d36 5
a40 1
#include <ctype.h>
d46 7
a52 8
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */

void cons ();
d56 2
d61 13
a73 1
int bsize = L_8;		/* default branch displacement */
d76 2
a77 1
h8300hmode ()
d81 4
d88 2
a89 1
h8300smode ()
d93 30
d133 2
a134 1
pint ()
d139 6
d148 1
d150 1
d154 5
d175 3
a177 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d180 1
a180 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
d185 1
d189 3
a191 1
  struct h8_opcode *opcode;
d195 5
d203 6
a208 1
  for (opcode = h8_opcodes; opcode->name; opcode++)
d212 1
a212 1
      char *src = opcode->name;
d217 1
a217 1
      opcode->size = 0;
d223 1
a223 1
	      opcode->size = *src;
d231 1
a231 1
	  hash_insert (opcode_hash_control, buffer, (char *) opcode);
d235 1
a235 1
      opcode->idx = idx;
d238 3
a240 3
      opcode->noperands = 0;
      while (opcode->args.nib[opcode->noperands] != E)
	opcode->noperands++;
d243 5
a247 3
      opcode->length = 0;
      while (opcode->data.nib[opcode->length * 2] != E)
	opcode->length++;
d250 7
d268 1
a268 1
int opsize;			/* Set when a register size is seen */
d277 12
a307 1

d420 1
a420 1
	  /* ff fill any 8 bit quantity */
d438 1
a438 1
	  while (isdigit (*ptr))
d458 1
a458 3
   @@@@aa[:8]		memory indirect

   */
a463 1

d485 1
a487 1

d504 4
d510 2
a511 2
  if (src[0] == 'e' && src[1] == 'r' && isdigit (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && isdigit (src[6]))
d537 4
a540 1
      *ptr = src + 7;
d708 1
a708 3
	    {
	      as_bad (_("expect :8 or :16 here"));
	    }
d711 2
a712 3
	{
	  op->mode = PCREL | bsize;
	}
d764 4
a767 3
static struct h8_opcode *
get_specific (opcode, operands, size)
     struct h8_opcode *opcode;
d771 1
a771 1
  struct h8_opcode *this_try = opcode;
d773 1
a773 2

  unsigned int this_index = opcode->idx;
d777 2
a778 2
  if (strcmp (opcode->name, "stm.l") == 0
      || strcmp (opcode->name, "ldm.l") == 0)
d781 1
a781 1
  while (this_index == opcode->idx && !found)
d785 1
a785 1
      this_try = opcode++;
d790 1
a790 1
	  this_size = this_try->how & SN;
d796 1
a796 1
	  unsigned int i;
d800 1
a800 1
	      op_type op = this_try->args.nib[i];
d896 1
a896 1
	  (operand->exp.X_add_number | width) != (~0))
d905 8
d1032 1
d1035 1
a1035 1
     struct h8_opcode *this_try;
d1038 1
a1038 2
  unsigned int i;

d1040 1
a1040 1
  op_type *nibble_ptr = this_try->data.nib;
d1043 3
a1045 3
  int absat;
  int immat;
  int nib;
d1050 1
a1050 1
  if (!(this_try->inbase || Hmode))
d1052 1
a1052 1
	     this_try->name);
d1062 1
a1062 3
	{
	  nib = c;
	}
d1066 2
a1067 3
	    {
	      nib = operand[d].reg;
	    }
d1069 2
a1070 3
	    {
	      nib = dispreg;
	    }
d1084 2
a1085 3
	    {
	      nib = 0;
	    }
d1125 1
a1125 3
	    {
	      operand[d].mode |= MEMRELAX;
	    }
d1128 1
a1128 3
	    {
	      nib |= 0x8;
	    }
d1147 2
a1148 2
  if (strcmp (this_try->name, "stm.l") == 0
      || strcmp (this_try->name, "ldm.l") == 0)
d1151 2
a1152 2
      high = (operand[this_try->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->name[0] == 'l' ? 1 : 0].reg & 0xf;
d1155 1
a1155 1
      asnibbles[7] = (this_try->name[0] == 'l') ? high : low;
d1159 1
a1159 3
    {
      output[i] = (asnibbles[i * 2] << 4) | asnibbles[i * 2 + 1];
    }
d1163 1
a1163 1
  if (strcmp (this_try->name, "mov.b") == 0)
d1172 3
a1174 4
	{
	  do_a_fix_imm (output - frag_now->fr_literal + immat,
			operand + i, x & MEMRELAX != 0);
	}
d1176 3
a1178 4
	{
	  do_a_fix_imm (output - frag_now->fr_literal + absat,
			operand + i, x & MEMRELAX ? movb + 1 : 0);
	}
d1181 1
a1181 1
	  int size16 = x & L_16;
d1185 1
d1190 5
a1194 4
	    {
	      as_warn (_("branch operand has odd offset (%lx)\n"),
		       (unsigned long) operand->exp.X_add_number);
	    }
d1196 2
d1199 1
d1203 7
a1209 6
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + where,
		       size,
		       &operand[i].exp,
		       1,
		       type);
d1223 9
d1235 1
d1237 3
a1239 4
	    {
	      as_warn (_("branch operand has odd offset (%lx)\n"),
		       (unsigned long) operand->exp.X_add_number);
	    }
d1244 1
a1244 1
		       output - frag_now->fr_literal,
d1255 1
d1257 2
a1258 2
clever_message (opcode, operand)
     struct h8_opcode *opcode;
d1263 1
a1263 1
  if ((opcode + 1)->idx != opcode->idx)
d1265 1
a1265 1
      unsigned int argn;
d1269 1
a1269 1
      for (argn = 0; argn < opcode->noperands; argn++)
d1271 1
a1271 1
	  switch (opcode->args.nib[argn])
d1322 1
d1330 2
a1331 2
  struct h8_opcode *opcode;
  struct h8_opcode *prev_opcode;
d1363 2
a1364 2
  opcode = (struct h8_opcode *) hash_find (opcode_hash_control,
					   op_start);
d1366 1
a1366 1
  if (opcode == NULL)
d1375 1
a1375 1
  (void) get_operands (opcode->noperands, op_end, operand);
d1377 1
a1377 1
  prev_opcode = opcode;
d1397 1
a1397 1
  opcode = get_specific (opcode, operand, size);
d1399 1
a1399 1
  if (opcode == 0)
d1406 1
a1406 1
      clever_message (prev_opcode, operand);
d1410 1
a1410 1
  if (opcode->size && dot)
d1412 1
a1412 1
      if (opcode->size != *dot)
d1418 5
a1422 1
  build_bytes (opcode, operand);
d1425 1
d1432 1
d1441 1
d1448 1
a1468 1
  char *atof_ieee ();
d1513 1
a1513 1
CONST char *md_shortopts = "";
d1534 2
d1545 3
d1549 1
d1557 10
d1575 2
d1579 1
a1579 1
md_apply_fix (fixP, val)
d1581 2
a1582 1
     long val;
d1585 1
d1605 3
d1636 1
d1699 45
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 1998 Free Software Foundation.
d22 1
a22 5

/*
  Written By Steve Chamberlain
  sac@@cygnus.com
  */
d33 1
a33 4
const char comment_chars[] =
{';', 0};
const char line_separator_chars[] =
{0};
d35 1
a52 1

d66 1
d74 2
a75 1
static void pint ()
a81 1

d110 3
a112 6
/*
  This function is called once, at assembler startup time.  This should
  set up all the tables, etc that the MD part of the assembler needs
  */


d126 1
a126 2
         unique codes into the hash table
         */
d152 1
a152 2

      /* Find the number of operands */
d156 2
a157 1
      /* Find the length of the opcode in bytes */
a165 1

d172 1
a175 1

d194 3
a196 2
/* try and parse a reg name, returns number of chars consumed */
int
d207 1
a207 1
  /* Cribbed from get_symbol_end().  */
d210 1
a210 1
  end = src+1;
d285 1
a285 1
char *
d288 1
a288 1
     expressionS * op;
d316 1
a316 1
	 /* exp->X_add_number -= 0x100;*/
d347 2
a348 2
   @@aa:8			absolute 8 bit
   @@aa:16			absolute 16 bit
d352 1
a352 1
   @@(exp:[8], pc)		pc rel
d368 1
a368 1
      /* Choose a default mode */
a387 1

d404 2
a405 2
  if (src[0] == 'e' && src[1] == 'r' && isdigit(src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && isdigit(src[6]))
a455 1

a457 1

d464 1
a464 1
	      /* Oops, not a reg after all, must be ordinary exp */
d466 1
a466 1
	      /* must be a symbol */
a471 2


a473 1

d483 1
a483 1
	  /* Disp */
d486 1
a486 2
	  /* Start off assuming a 16 bit offset */

a564 1

d611 1
a611 3

static
char *
d638 1
a639 1
      break;
a651 1

d657 2
a658 4
   provided
   */
static
struct h8_opcode *
d714 1
a714 1
		  /* The size of the reg is v important */
d722 1
a722 1
		  /* But it may not be 24 bits long */
d731 1
a731 1
		  /* This is ok if the immediate value is sensible */
d735 1
a735 1
		  /* The size of the displacement is important */
d749 1
a749 1
		  if (op & ABS && op & L_8 && op & DISP) 
d752 1
a752 1
			found= 1;
d765 1
a765 1
		}	
d784 4
a788 4
      /* No symbol involved, let's look at offset, it's dangerous if any of
	 the high bits are not 0 or ff's, find out by oring or anding with
	 the width and seeing if the answer is 0 or all fs*/
      
d792 1
a792 1
	  if (width == 255 
d799 1
a799 1
	  else 
a805 1

a827 1

d860 1
a860 1
	  /* This should be done with bfd */
d865 5
a871 1

a876 1

d889 1
a889 1
	  as_bad(_("Can't work out size of operand.\n"));
d897 2
a898 1
	  operand->exp.X_add_number = (short)operand->exp.X_add_number;
d904 2
a905 7
	  /* This used to use a cast to char, but that fails if char is an
	     unsigned type.  We can't use `signed char', as that isn't valid
	     K&R C.  */
	  if (operand->exp.X_add_number & 0x80)
	    operand->exp.X_add_number |= ((offsetT) -1 << 8);
	  else
	    operand->exp.X_add_number &= 0xff;
a914 1

d917 1
a917 2
/* Now we know what sort of opcodes it is, lets build the bytes -
 */
a952 1

d961 1
a961 1
	  else if (c &  ABS )
d1011 1
a1011 1
	      /* stop it making a fix */
d1027 6
a1032 1
	      nib = 2 + operand[d].reg;
d1063 1
a1063 1
  /* output any fixes */
d1094 2
a1095 7
	  /* This used to use a cast to char, but that fails if char is an
	     unsigned type.  We can't use `signed char', as that isn't valid
	     K&R C.  */
	  if (operand[i].exp.X_add_number & 0x80)
	    operand[i].exp.X_add_number |= ((offsetT) -1 << 8);
	  else
	    operand[i].exp.X_add_number &= 0xff;
a1105 1

d1116 1
a1116 1
	  /* This jmp may be a jump or a branch */
d1125 2
a1126 1
	    operand[i].exp.X_add_number = (short) operand[i].exp.X_add_number;
a1134 1

d1137 2
a1138 5
/*
  try and give an intelligent error message for common and simple to
  detect errors
  */

d1144 1
a1144 1
  /* Find out if there was more than one possible opccode */
d1150 2
a1151 2
      /* Only one opcode of this flavour, try and guess which operand
         didn't match */
a1165 1

a1187 1

d1202 3
a1204 7
/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This funciton is supposed to emit
   the frags/bytes it assembles to.
   */



d1219 1
a1219 1
  /* Drop leading whitespace */
d1223 1
a1223 1
  /* find the op code end */
a1236 2
  ;

d1254 1
a1254 1
  /* We use to set input_line_pointer to the result of get_operands,
d1283 1
a1283 1
      /* Couldn't find an opcode which matched the operands */
a1300 1

d1305 1
a1305 1
     object_headers * headers ATTRIBUTE_UNUSED;
d1319 1
a1319 1
     object_headers * headers ATTRIBUTE_UNUSED;
d1328 5
a1332 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
   */
d1392 2
a1393 1
size_t md_longopts_size = sizeof(md_longopts);
d1426 1
a1426 1
valueT 
d1431 2
a1432 2
  return ((size + (1 << section_alignment[(int) seg]) - 1) & (-1 << section_alignment[(int) seg]));

d1471 1
a1471 2
/* Put number into target byte order */

d1480 1
a1487 1

d1500 1
a1500 1
     to output it */
a1517 1

a1518 1

a1548 2


a1549 2

/* end of tc-h8300.c */
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1991, 1992 Free Software Foundation.
d17 3
a19 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 1
d201 2
a202 2

  */
d213 12
a224 1
  if (src[0] == 's' && src[1] == 'p')
d228 1
a228 1
      return 2;
d230 1
a230 1
  if (src[0] == 'c' && src[1] == 'c' && src[2] == 'r')
d234 1
a234 1
      return 3;
d236 1
a236 1
  if (src[0] == 'e' && src[1] == 'x' && src[2] == 'r')
d240 1
a240 1
      return 3;
d242 1
a242 1
  if (src[0] == 'f' && src[1] == 'p')
d246 1
a246 1
      return 2;
d248 1
a248 2
  if (src[0] == 'e'
      && src[1] == 'r'
d254 2
a255 3
	as_warn ("Reg not valid for H8/300");

      return 3;
d257 1
a257 2
  if (src[0] == 'e'
      && src[1] >= '0' && src[1] <= '7')
d262 2
a263 2
	as_warn ("Reg not valid for H8/300");
      return 2;
d270 1
a270 1
	  if (src[2] == 'l')
d274 1
a274 1
	      return 3;
d276 1
a276 1
	  if (src[2] == 'h')
d280 7
a286 1
	      return 3;
a287 3
	  *mode = L_16 | REG | direction;
	  *reg = (src[1] - '0');
	  return 2;
d290 1
d305 1
a305 1
    as_bad ("missing operand");
d314 1
a314 1
     expressionS *exp;
d402 1
a402 1
     unsigned int dst;
d423 1
a423 1
	as_bad ("Invalid register list for ldm/stm\n");
d426 1
a426 1
	as_bad ("Invalid register list for ldm/stm\n");
d428 2
a429 2
      if (high - low > 4)
	as_bad ("Invalid register list for ldm/stm\n");
d431 1
a431 1
      if (high - low != 2
d433 1
a433 1
	as_bad ("Invalid register list for ldm/stm\n");
d490 1
a490 1
	    as_bad ("Wrong size pointer register for architecture.");
d518 1
a518 1
	      as_bad ("expected @@(exp, reg16)");
d527 1
a527 1
	      as_bad ("expected @@(exp, reg16)");
d537 1
a537 1
	      as_bad ("expected @@(exp, reg16)");
d553 1
a553 1
		as_bad ("Wrong size pointer register for architecture.");
d560 1
a560 1
	    as_bad ("Wrong size pointer register for architecture.");
d617 1
a617 1
	      as_bad ("expect :8 or :16 here");
d823 1
a823 1
	      as_warn ("operand %s0x%lx out of range.", string,
d910 1
a910 1
	  as_bad("Can't work out size of operand.\n");
d924 7
a930 1
	  operand->exp.X_add_number = (char)operand->exp.X_add_number;
d964 2
a965 1
    as_warn ("Opcode `%s' not available in H8/300 mode", this_try->name);
d1016 1
a1016 1
		  as_bad ("Need #1 or #2 here");
d1031 1
a1031 1
		    as_warn ("#4 not valid on H8/300.");
d1036 1
a1036 1
		  as_bad ("Need #1 or #2 here");
d1112 1
a1112 1
	      as_warn ("branch operand has odd offset (%lx)\n",
d1116 9
a1124 2
	  operand[i].exp.X_add_number =
	    (char) (operand[i].exp.X_add_number - 1);
d1150 1
a1150 1
	      as_warn ("branch operand has odd offset (%lx)\n",
d1191 1
a1191 1
		  as_bad ("destination operand must be 16 bit register");
d1201 1
a1201 1
		  as_bad ("source operand must be 8 bit register");
d1209 1
a1209 1
		  as_bad ("destination operand must be 16bit absolute address");
d1216 1
a1216 1
		  as_bad ("destination operand must be 8 bit register");
d1225 1
a1225 1
		  as_bad ("source operand must be 16bit absolute address");
d1233 1
a1233 1
  as_bad ("invalid operands");
d1279 1
a1279 1
      as_bad ("can't find opcode ");
d1290 1
a1290 1
      as_bad ("unknown opcode");
d1336 1
a1336 1
	  as_warn ("mismatch between opcode size and operand size");
d1346 1
a1346 1
     object_headers * headers;
d1348 1
a1348 1
  printf ("call to tc_crawl_symbol_chain \n");
d1353 1
a1353 1
     char *name;
d1360 1
a1360 1
     object_headers * headers;
d1362 1
a1362 1
  printf ("call to tc_headers_hook \n");
d1413 1
a1413 1
      return "Bad call to MD_ATOF()";
d1436 2
a1437 2
     int c;
     char *arg;
d1444 1
a1444 1
     FILE *stream;
a1447 2
int md_short_jump_size;

d1451 1
a1451 1
  printf ("call to tc_aout_fix_to_chars \n");
a1455 21
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr;
     addressT to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}

void
d1457 3
a1459 3
     object_headers *headers;
     segT seg;
     fragS *fragP;
d1461 1
a1461 1
  printf ("call to md_convert_frag \n");
a1500 2
int md_long_jump_size;

d1503 2
a1504 2
     register fragS *fragP;
     register segT segment_type;
d1506 1
a1506 1
  printf ("call tomd_estimate_size_before_relax \n");
d1522 1
a1522 1
     fixS *fixP;
d1571 18
a1588 1
    intr->r_symndx = symbol_ptr->sy_number;
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d50 1
d61 1
d64 6
a69 1

d86 1
d223 6
d242 1
a242 1
	as_warn ("Reg only legal for H8/300-H");
d252 1
a252 1
	as_warn ("Reg only legal for H8/300-H");
d320 4
d398 33
d577 8
d667 1
a667 1
get_specific (opcode, operands)
d670 1
d677 6
a684 1
      unsigned int i;
d688 9
a696 1
      for (i = 0; i < this_try->noperands && found; i++)
d698 1
a698 2
	  op_type op = this_try->args.nib[i];
	  int x = operands[i].mode;
d700 1
a700 2
	  if ((op & (DISP | REG)) == (DISP | REG)
	      && ((x & (DISP | REG)) == (DISP | REG)))
d702 12
a713 6
	      dispreg = operands[i].reg;
	    }
	  else if (op & REG)
	    {
	      if (!(x & REG))
		found = 0;
d715 12
a726 1
	      if (x & L_P)
d728 8
a735 1
		  x = (x & ~L_P) | (Hmode ? L_32 : L_16);
d737 1
a737 1
	      if (op & L_P)
d739 1
a739 1
		  op = (op & ~L_P) | (Hmode ? L_32 : L_16);
d741 8
a748 13

	      opsize = op & SIZE;

	      /* The size of the reg is v important */
	      if ((op & SIZE) != (x & SIZE))
		found = 0;
	    }
	  else if ((op & ABSJMP) && (x & ABS))
	    {
	      operands[i].mode &= ~ABS;
	      operands[i].mode |= ABSJMP;
	      /* But it may not be 24 bits long */
	      if (!Hmode)
d750 15
a764 2
		  operands[i].mode &= ~SIZE;
		  operands[i].mode |= L_16;
d766 1
a766 21


	    }
	  else if ((op & (KBIT | DBIT)) && (x & IMM))
	    {
	      /* This is ok if the immediate value is sensible */

	    }
	  else if (op & PCREL)
	    {

	      /* The size of the displacement is important */
	      if ((op & SIZE) != (x & SIZE))
		found = 0;

	    }
	  else if ((op & (DISP | IMM | ABS))
		   && (op & (DISP | IMM | ABS)) == (x & (DISP | IMM | ABS)))
	    {
	      /* Got a diplacement,will fit if no size or same size as try */
	      if (op & ABS && op & L_8) 
d768 1
a768 3
		  /* We want an 8 bit abs here, but one which looks like 16 bits will do fine */
		  if (x & L_16)
		    found= 1;
d770 4
a773 8
	      else
	      if ((x & SIZE) != 0
		  && ((op & SIZE) != (x & SIZE)))
		found = 0;
	    }
	  else if ((op & MODE) != (x & MODE))
	    {
	      found = 0;
a774 1

d885 1
d887 1
a887 1
	  where = -1;
a896 5
	case L_32:
	  size = 4;
	  where = 0;
	  idx = R_RELLONG;
	  break;
d944 1
a944 4
    {
      as_warn ("Opcode `%s' only available in this mode on H8/300-H",
	       this_try->name);
    }
d951 1
a951 1
      d = (c & DST) != 0;
d1010 1
a1010 1
		    as_warn ("#4 only valid in h8/300 mode.");
d1031 5
d1042 13
d1227 1
d1273 19
a1291 1
  opcode = get_specific (opcode, operand);
@


1.1
log
@Initial revision
@
text
@a693 7
#if 0
	  else if ((op & ABSMOV) && (x & ABS))
	    {
	      /* An absmov is only */
	      /* Ok */
	    }
#endif
d741 10
d752 1
a752 1
do_a_fix_imm (offset, operand, relaxing)
d755 1
a755 1
     int relaxing;
d811 6
a816 1
	  idx = relaxing ? R_MOVLB1 : R_RELLONG;
d828 5
a832 1
	  idx = relaxing ? R_MOVB1 : R_RELWORD;
d838 1
a840 2
      /* Sign extend any expression */
      operand->exp.X_add_number = (short)operand->exp.X_add_number;
d867 1
a898 8

	  else if (c & ABSMOV)
	    {
	      operand[d].mode &= ~ABS;
	      operand[d].mode |= ABSMOV;
	      immat = nibble_count / 2;
	      nib = 0;
	    }
d953 5
d973 5
d985 2
a986 1
	  do_a_fix_imm (output - frag_now->fr_literal + immat, operand + i, 0);
d990 2
a991 1
	  do_a_fix_imm (output - frag_now->fr_literal + absat, operand + i, 0);
d1026 1
a1026 7
		       R_RELBYTE);
	}

      else if (x & ABSMOV)
	{
	  /* This mov is either absolute long or thru a memory loc */
	  do_a_fix_imm (output - frag_now->fr_literal + immat, operand + i, 1);
a1027 1

d1432 1
a1432 1
  if (fix_ptr->fx_r_type == RELOC_32)
d1438 3
a1440 1

@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d694 7
a747 10
/* RELAXMODE has one of 3 values:

   0 Output a "normal" reloc, no relaxing possible for this insn/reloc

   1 Output a relaxable 24bit absolute mov.w address relocation
     (may relax into a 16bit absolute address).

   2 Output a relaxable 16/24 absolute mov.b address relocation
     (may relax into an 8bit absolute address).  */

d749 1
a749 1
do_a_fix_imm (offset, operand, relaxmode)
d752 1
a752 1
     int relaxmode;
d808 1
a808 6
	  if (relaxmode == 2)
	    idx = R_MOV24B1;
	  else if (relaxmode == 1)
	    idx = R_MOVL1;
	  else
	    idx = R_RELLONG;
d820 1
a820 5
	  if (relaxmode == 2)
	    idx = R_MOV16B1;
	  else
	    idx = R_RELWORD;
	  operand->exp.X_add_number = (short)operand->exp.X_add_number;
a825 1
	  operand->exp.X_add_number = (char)operand->exp.X_add_number;
d828 2
a855 1
  int movb = 0;
d887 8
a948 5
	  if (c & MEMRELAX)
	    {
	      operand[d].mode |= MEMRELAX;
	    }

a963 5
  /* Note if this is a movb instruction -- there's a special relaxation
     which only applies to them.  */
  if (strcmp (this_try->name, "mov.b") == 0)
    movb = 1;

d971 1
a971 2
	  do_a_fix_imm (output - frag_now->fr_literal + immat,
			operand + i, x & MEMRELAX != 0);
d975 1
a975 2
	  do_a_fix_imm (output - frag_now->fr_literal + absat,
			operand + i, x & MEMRELAX ? movb + 1 : 0);
d1010 7
a1016 1
		       R_MEM_INDIRECT);
d1018 1
d1423 1
a1423 1
  if (fix_ptr->fx_r_type == TC_CONS_RELOC)
d1429 1
a1429 3
	case 4:
	  intr->r_type = R_RELLONG;
	  break;
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a49 1
int Smode;
a59 1
  Smode = 0;
d62 1
a62 6
void
h8300smode ()
{
  Smode = 1;
  Hmode = 1;
}
a78 1
  {"h8300s", h8300smode, 0},
a214 6
  if (src[0] == 'e' && src[1] == 'x' && src[2] == 'r')
    {
      *mode = EXR;
      *reg = 0;
      return 3;
    }
d228 1
a228 1
	as_warn ("Reg not valid for H8/300");
d238 1
a238 1
	as_warn ("Reg not valid for H8/300");
a305 4
	  else if (*ptr == '3')
	    {
	      *mode |= L_32;
	    }
a379 33
  /* Gross.  Gross.  ldm and stm have a format not easily handled
     by get_operand.  We deal with it explicitly here.  */
  if (src[0] == 'e' && src[1] == 'r' && isdigit(src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && isdigit(src[6]))
    {
      int low, high;

      low = src[2] - '0';
      high = src[6] - '0';

      if (high < low)
	as_bad ("Invalid register list for ldm/stm\n");

      if (low % 2)
	as_bad ("Invalid register list for ldm/stm\n");

      if (high - low > 4)
	as_bad ("Invalid register list for ldm/stm\n");

      if (high - low != 2
	  && low % 4)
	as_bad ("Invalid register list for ldm/stm\n");

      /* Even sicker.  We encode two registers into op->reg.  One
	 for the low register to save, the other for the high
	 register to save;  we also set the high bit in op->reg
	 so we know this is "very special".  */
      op->reg = 0x80000000 | (high << 8) | low;
      op->mode = REG;
      *ptr = src + 7;
      return;
    }

a525 8
  else if (strncmp (src, "mach", 4) == 0
	   || strncmp (src, "macl", 4) == 0)
    {
      op->reg = src[3] == 'l';
      op->mode = MACREG;
      *ptr = src + 4;
      return;
    }
d608 1
a608 1
get_specific (opcode, operands, size)
a610 1
     int size;
a616 6
  /* There's only one ldm/stm and it's easier to just
     get out quick for them.  */
  if (strcmp (opcode->name, "stm.l") == 0
      || strcmp (opcode->name, "ldm.l") == 0)
    return this_try;

d619 1
d623 1
a623 1
      if (this_try->noperands == 0)
d625 2
a626 1
	  int this_size;
d628 6
a633 9
	  this_size = this_try->how & SN;
	  if (this_size != size && (this_size != SB || size != SN))
	    found = 0;
	}
      else
	{
	  unsigned int i;

	  for (i = 0; i < this_try->noperands && found; i++)
d635 2
a636 2
	      op_type op = this_try->args.nib[i];
	      int x = operands[i].mode;
d638 1
a638 2
	      if ((op & (DISP | REG)) == (DISP | REG)
		  && ((x & (DISP | REG)) == (DISP | REG)))
d640 1
a640 1
		  dispreg = operands[i].reg;
d642 1
a642 1
	      else if (op & REG)
d644 4
a647 2
		  if (!(x & REG))
		    found = 0;
d649 10
a658 12
		  if (x & L_P)
		    x = (x & ~L_P) | (Hmode ? L_32 : L_16);
		  if (op & L_P)
		    op = (op & ~L_P) | (Hmode ? L_32 : L_16);

		  opsize = op & SIZE;

		  /* The size of the reg is v important */
		  if ((op & SIZE) != (x & SIZE))
		    found = 0;
		}
	      else if ((op & ABSJMP) && (x & ABS))
d660 2
a661 8
		  operands[i].mode &= ~ABS;
		  operands[i].mode |= ABSJMP;
		  /* But it may not be 24 bits long */
		  if (!Hmode)
		    {
		      operands[i].mode &= ~SIZE;
		      operands[i].mode |= L_16;
		    }
d663 21
a683 1
	      else if ((op & (KBIT | DBIT)) && (x & IMM))
d685 3
a687 1
		  /* This is ok if the immediate value is sensible */
d689 8
a696 33
	      else if (op & PCREL)
		{
		  /* The size of the displacement is important */
		  if ((op & SIZE) != (x & SIZE))
		    found = 0;
		}
	      else if ((op & (DISP | IMM | ABS))
		       && (op & (DISP | IMM | ABS)) == (x & (DISP | IMM | ABS)))
		{
		  /* Promote a L_24 to L_32 if it makes us match.  */
		  if ((x & L_24) && (op & L_32))
		    {
		      x &= ~L_24;
		      x |= L_32;
		    }
		  /* Promote an L8 to L_16 if it makes us match.  */
		  if (op & ABS && op & L_8 && op & DISP) 
		    {
		      if (x & L_16)
			found= 1;
		    }
		  else if ((x & SIZE) != 0
			   && ((op & SIZE) != (x & SIZE)))
		    found = 0;
		}
	      else if ((op & MACREG) != (x & MACREG))
		{
		  found = 0;
		}
	      else if ((op & MODE) != (x & MODE))
		{
		  found = 0;
		}	
d698 1
a808 1
	case L_32:
d810 1
a810 1
	  where = (operand->mode & SIZE) == L_24 ? -1 : 0;
d820 5
d872 4
a875 1
    as_warn ("Opcode `%s' not available in H8/300 mode", this_try->name);
d882 1
a882 1
      d = (c & (DST | SRC_IN_DST)) != 0;
d941 1
a941 1
		    as_warn ("#4 not valid on H8/300.");
a961 5

	  if (c & MACREG)
	    {
	      nib = 2 + operand[d].reg;
	    }
a967 13
  /* Disgusting.  Why, oh why didn't someone ask us for advice
     on the assembler format.  */
  if (strcmp (this_try->name, "stm.l") == 0
      || strcmp (this_try->name, "ldm.l") == 0)
    {
      int high, low;
      high = (operand[this_try->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->name[0] == 'l' ? 1 : 0].reg & 0xf;

      asnibbles[2] = high - low;
      asnibbles[7] = (this_try->name[0] == 'l') ? high : low;
    }

a1139 1
  int size;
d1185 1
a1185 19
  size = SN;
  if (dot)
    {
      switch (*dot)
	{
	case 'b':
	  size = SB;
	  break;

	case 'w':
	  size = SW;
	  break;

	case 'l':
	  size = SL;
	  break;
	}
    }
  opcode = get_specific (opcode, operand, size);
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 1998 Free Software Foundation.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a27 1
#include "subsegs.h"
d199 2
a200 2
  ccr
*/
d211 1
a211 12
  char *end;
  int len;

  /* Cribbed from get_symbol_end().  */
  if (!is_name_beginner (*src) || *src == '\001')
    return 0;
  end = src+1;
  while (is_part_of_name (*end) || *end == '\001')
    end++;
  len = end - src;

  if (len == 2 && src[0] == 's' && src[1] == 'p')
d215 1
a215 1
      return len;
d217 1
a217 1
  if (len == 3 && src[0] == 'c' && src[1] == 'c' && src[2] == 'r')
d221 1
a221 1
      return len;
d223 1
a223 1
  if (len == 3 && src[0] == 'e' && src[1] == 'x' && src[2] == 'r')
d227 1
a227 1
      return len;
d229 1
a229 1
  if (len == 2 && src[0] == 'f' && src[1] == 'p')
d233 1
a233 1
      return len;
d235 2
a236 1
  if (len == 3 && src[0] == 'e' && src[1] == 'r'
d242 3
a244 2
	as_warn (_("Reg not valid for H8/300"));
      return len;
d246 2
a247 1
  if (len == 2 && src[0] == 'e' && src[1] >= '0' && src[1] <= '7')
d252 2
a253 2
	as_warn (_("Reg not valid for H8/300"));
      return len;
d260 1
a260 1
	  if (len == 3 && src[2] == 'l')
d264 1
a264 1
	      return len;
d266 1
a266 1
	  if (len == 3 && src[2] == 'h')
d270 1
a270 7
	      return len;
	    }
	  if (len == 2)
	    {
	      *mode = L_16 | REG | direction;
	      *reg = (src[1] - '0');
	      return len;
d272 3
a276 1

d291 1
a291 1
    as_bad (_("missing operand"));
d300 1
a300 1
     expressionS *exp ATTRIBUTE_UNUSED;
d388 1
a388 1
     unsigned int dst ATTRIBUTE_UNUSED;
d409 1
a409 1
	as_bad (_("Invalid register list for ldm/stm\n"));
d412 1
a412 1
	as_bad (_("Invalid register list for ldm/stm\n"));
d414 2
a415 2
      if (high - low > 3)
	as_bad (_("Invalid register list for ldm/stm\n"));
d417 1
a417 1
      if (high - low != 1
d419 1
a419 1
	as_bad (_("Invalid register list for ldm/stm\n"));
d476 1
a476 1
	    as_bad (_("Wrong size pointer register for architecture."));
d504 1
a504 1
	      as_bad (_("expected @@(exp, reg16)"));
d513 1
a513 1
	      as_bad (_("expected @@(exp, reg16)"));
d523 1
a523 1
	      as_bad (_("expected @@(exp, reg16)"));
d539 1
a539 1
		as_bad (_("Wrong size pointer register for architecture."));
d546 1
a546 1
	    as_bad (_("Wrong size pointer register for architecture."));
d603 1
a603 1
	      as_bad (_("expect :8 or :16 here"));
d809 1
a809 1
	      as_warn (_("operand %s0x%lx out of range."), string,
d896 1
a896 1
	  as_bad(_("Can't work out size of operand.\n"));
d910 1
a910 7
	  /* This used to use a cast to char, but that fails if char is an
	     unsigned type.  We can't use `signed char', as that isn't valid
	     K&R C.  */
	  if (operand->exp.X_add_number & 0x80)
	    operand->exp.X_add_number |= ((offsetT) -1 << 8);
	  else
	    operand->exp.X_add_number &= 0xff;
d944 1
a944 2
    as_warn (_("Opcode `%s' with these operand types not available in H8/300 mode"),
	     this_try->name);
d995 1
a995 1
		  as_bad (_("Need #1 or #2 here"));
d1010 1
a1010 1
		    as_warn (_("#4 not valid on H8/300."));
d1015 1
a1015 1
		  as_bad (_("Need #1 or #2 here"));
d1091 1
a1091 1
	      as_warn (_("branch operand has odd offset (%lx)\n"),
d1095 2
a1096 9
	  operand[i].exp.X_add_number -= 1;
	  /* This used to use a cast to char, but that fails if char is an
	     unsigned type.  We can't use `signed char', as that isn't valid
	     K&R C.  */
	  if (operand[i].exp.X_add_number & 0x80)
	    operand[i].exp.X_add_number |= ((offsetT) -1 << 8);
	  else
	    operand[i].exp.X_add_number &= 0xff;

d1122 1
a1122 1
	      as_warn (_("branch operand has odd offset (%lx)\n"),
d1163 1
a1163 1
		  as_bad (_("destination operand must be 16 bit register"));
d1173 1
a1173 1
		  as_bad (_("source operand must be 8 bit register"));
d1181 1
a1181 1
		  as_bad (_("destination operand must be 16bit absolute address"));
d1188 1
a1188 1
		  as_bad (_("destination operand must be 8 bit register"));
d1197 1
a1197 1
		  as_bad (_("source operand must be 16bit absolute address"));
d1205 1
a1205 1
  as_bad (_("invalid operands"));
d1251 1
a1251 1
      as_bad (_("can't find opcode "));
d1262 1
a1262 1
      as_bad (_("unknown opcode"));
d1308 1
a1308 1
	  as_warn (_("mismatch between opcode size and operand size"));
d1318 1
a1318 1
     object_headers * headers ATTRIBUTE_UNUSED;
d1320 1
a1320 1
  printf (_("call to tc_crawl_symbol_chain \n"));
d1325 1
a1325 1
     char *name ATTRIBUTE_UNUSED;
d1332 1
a1332 1
     object_headers * headers ATTRIBUTE_UNUSED;
d1334 1
a1334 1
  printf (_("call to tc_headers_hook \n"));
d1385 1
a1385 1
      return _("Bad call to MD_ATOF()");
d1408 2
a1409 2
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d1416 1
a1416 1
     FILE *stream ATTRIBUTE_UNUSED;
d1420 2
d1425 1
a1425 1
  printf (_("call to tc_aout_fix_to_chars \n"));
d1430 21
d1452 3
a1454 3
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d1456 1
a1456 1
  printf (_("call to md_convert_frag \n"));
d1496 2
d1500 2
a1501 2
     register fragS *fragP ATTRIBUTE_UNUSED;
     register segT segment_type ATTRIBUTE_UNUSED;
d1503 1
a1503 1
  printf (_("call tomd_estimate_size_before_relax \n"));
d1519 1
a1519 1
     fixS *fixP ATTRIBUTE_UNUSED;
d1568 1
a1568 18
    {
      if (symbol_ptr->sy_number != -1)
	intr->r_symndx = symbol_ptr->sy_number;
      else
	{
	  symbolS *segsym;

	  /* This case arises when a reference is made to `.'.  */
	  segsym = seg_info (S_GET_SEGMENT (symbol_ptr))->dot;
	  if (segsym == NULL)
	    intr->r_symndx = -1;
	  else
	    {
	      intr->r_symndx = segsym->sy_number;
	      intr->r_offset += S_GET_VALUE (symbol_ptr);
	    }
	}
    }
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000
   Free Software Foundation, Inc.
d21 5
a25 1
/* Written By Steve Chamberlain <sac@@cygnus.com>.  */
d36 4
a39 1
const char comment_chars[] = ";";
a40 1
const char line_separator_chars[] = "";
d58 1
a71 1

d79 1
a79 2
static void
pint ()
d86 1
d115 6
a120 3
/* This function is called once, at assembler startup time.  This
   should set up all the tables, etc. that the MD part of the assembler
   needs.  */
d134 2
a135 1
         unique codes into the hash table.  */
d161 2
a162 1
      /* Find the number of operands.  */
d166 1
a166 2

      /* Find the length of the opcode in bytes.  */
d175 1
a181 1

d185 1
d204 2
a205 3
/* Try to parse a reg name.  Return the number of chars consumed.  */

static int
d216 1
a216 1
  /* Cribbed from get_symbol_end.  */
d219 1
a219 1
  end = src + 1;
d294 1
a294 1
static char *
d297 1
a297 1
     expressionS *op;
d325 1
a325 1
	  /* exp->X_add_number -= 0x100; */
d356 2
a357 2
   @@aa:8		absolute 8 bit
   @@aa:16		absolute 16 bit
d361 1
a361 1
   @@(exp:[8], pc)	pc rel
d377 1
a377 1
      /* Choose a default mode.  */
d397 1
d414 2
a415 2
  if (src[0] == 'e' && src[1] == 'r' && isdigit (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && isdigit (src[6]))
d466 1
d469 1
d476 1
a476 1
	      /* Oops, not a reg after all, must be ordinary exp.  */
d478 1
a478 1
	      /* Must be a symbol.  */
d484 2
d488 1
d498 1
a498 1
	  /* Disp.  */
d501 2
a502 1
	  /* Start off assuming a 16 bit offset.  */
d581 1
d628 3
a630 1
static char *
d657 1
a658 1

d671 1
d677 4
a680 2
   provided.  */
static struct h8_opcode *
d736 1
a736 1
		  /* The size of the reg is v important.  */
d744 1
a744 1
		  /* But it may not be 24 bits long.  */
d753 1
a753 1
		  /* This is ok if the immediate value is sensible.  */
d757 1
a757 1
		  /* The size of the displacement is important.  */
d771 1
a771 1
		  if (op & ABS && op & L_8 && op & DISP)
d774 1
a774 1
			found = 1;
d787 1
a787 1
		}
a805 4
      /* No symbol involved, let's look at offset, it's dangerous if
	 any of the high bits are not 0 or ff's, find out by oring or
	 anding with the width and seeing if the answer is 0 or all
	 fs.  */
d807 4
d814 1
a814 1
	  if (width == 255
d821 1
a821 1
	  else
d828 1
d851 1
d884 1
a884 1
	  /* This should be done with bfd.  */
a888 5
	  if (relaxmode != 0)
	    {
	      idx = (relaxmode == 2) ? R_MOV24B1 : R_MOVL1;
	      fix_new_exp (frag_now, offset, 4, &operand->exp, 0, idx);
	    }
d891 1
d897 1
d910 1
a910 1
	  as_bad (_("Can't work out size of operand.\n"));
d918 1
a918 2
	  operand->exp.X_add_number =
	    ((operand->exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
d924 7
a930 2
	  operand->exp.X_add_number =
	    ((operand->exp.X_add_number & 0xff) ^ 0x80) - 0x80;
d940 1
d943 2
a944 1
/* Now we know what sort of opcodes it is, let's build the bytes.  */
d980 1
d989 1
a989 1
	  else if (c & ABS)
d1039 1
a1039 1
	      /* Stop it making a fix.  */
d1055 1
a1055 6
	      if (operand[0].mode == MACREG)
		/* stmac has mac[hl] as the first operand.  */
		nib = 2 + operand[0].reg;
	      else
		/* ldmac has mac[hl] as the second operand.  */
		nib = 2 + operand[1].reg;
d1086 1
a1086 1
  /* Output any fixes.  */
d1117 7
a1123 2
	  operand[i].exp.X_add_number =
	    ((operand[i].exp.X_add_number & 0xff) ^ 0x80) - 0x80;
d1134 1
d1145 1
a1145 1
	  /* This jmp may be a jump or a branch.  */
d1154 1
a1154 2
	    operand[i].exp.X_add_number =
	      ((operand[i].exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
d1163 1
d1166 5
a1170 2
/* Try to give an intelligent error message for common and simple to
   detect errors.  */
d1176 1
a1176 1
  /* Find out if there was more than one possible opcode.  */
d1182 2
a1183 2
      /* Only one opcode of this flavour, try to guess which operand
         didn't match.  */
d1198 1
d1221 1
d1236 7
a1242 3
/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles.  */
d1257 1
a1257 1
  /* Drop leading whitespace.  */
d1261 1
a1261 1
  /* Find the op code end.  */
d1275 2
d1294 1
a1294 1
  /* We used to set input_line_pointer to the result of get_operands,
d1323 1
a1323 1
      /* Couldn't find an opcode which matched the operands.  */
d1341 1
d1346 1
a1346 1
     object_headers *headers ATTRIBUTE_UNUSED;
d1360 1
a1360 1
     object_headers *headers ATTRIBUTE_UNUSED;
d1369 4
a1372 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d1432 1
a1432 2

size_t md_longopts_size = sizeof (md_longopts);
d1465 1
a1465 1
valueT
d1470 2
a1471 2
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));
d1510 2
a1511 1
/* Put number into target byte order.  */
a1519 1

d1527 1
d1540 1
a1540 1
     to output it.  */
d1558 1
d1560 1
d1591 2
d1594 2
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d1 3
a3 3
/* tc-h8300.c -- Assemble code for the Renesas H8/300
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.
a27 5

#ifdef BFD_ASSEMBLER
#include "dwarf2dbg.h"
#endif

d31 1
a31 5
#include "safe-ctype.h"

#ifdef OBJ_ELF
#include "elf/h8.h"
#endif
d37 8
a44 7
void cons        PARAMS ((int));
void sbranch     PARAMS ((int));
void h8300hmode  PARAMS ((int));
void h8300smode  PARAMS ((int));
void h8300hnmode PARAMS ((int));
void h8300snmode PARAMS ((int));
static void pint PARAMS ((int));
a47 2
int Nmode;

d51 1
a51 13

int bsize = L_8;		/* Default branch displacement.  */

struct h8_instruction
{
  int length;
  int noperands;
  int idx;
  int size;
  const struct h8_opcode *opcode;
};

struct h8_instruction *h8_instructions;
d54 1
a54 2
h8300hmode (arg)
     int arg ATTRIBUTE_UNUSED;
a57 4
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300h))
    as_warn (_("could not set architecture and machine"));
#endif
d61 1
a61 2
h8300smode (arg)
     int arg ATTRIBUTE_UNUSED;
a64 30
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300s))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
h8300hnmode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Hmode = 1;
  Smode = 0;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300hn))
    as_warn (_("could not set architecture and machine"));
#endif
}

void
h8300snmode (arg)
     int arg ATTRIBUTE_UNUSED;
{
  Smode = 1;
  Hmode = 1;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sn))
    as_warn (_("could not set architecture and machine"));
#endif
d75 1
a75 2
pint (arg)
     int arg ATTRIBUTE_UNUSED;
a79 6
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function.  */

a82 1
  {"h8300hn", h8300hnmode, 0},
a83 1
  {"h8300sn", h8300snmode, 0},
a86 5
#ifdef BFD_ASSEMBLER
  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  {"loc", dwarf2_directive_loc, 0 },
#endif

d103 3
a105 3
/* Chars that mean this number is a floating point constant
   As in 0f12.456
   or    0d1.2345e12.  */
d108 1
a108 1
static struct hash_control *opcode_hash_control;	/* Opcode mnemonics.  */
a112 1

d116 1
a116 3
  unsigned int nopcodes;
  const struct h8_opcode *p;
  struct h8_instruction *pi;
a119 5
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300))
    as_warn (_("could not set architecture and machine"));
#endif

d123 1
a123 6
  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);
  
  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
d127 1
a127 1
      char *src = p->name;
d132 1
a132 1
      pi->size = 0;
d138 1
a138 1
	      pi->size = *src;
d146 1
a146 1
	  hash_insert (opcode_hash_control, buffer, (char *) pi);
d150 1
a150 1
      pi->idx = idx;
d153 3
a155 3
      pi->noperands = 0;
      while (p->args.nib[pi->noperands] != E)
	pi->noperands++;
d158 3
a160 5
      pi->length = 0;
      while (p->data.nib[pi->length * 2] != E)
	pi->length++;

      pi->opcode = p;
a162 7
  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->noperands = 0;
  pi->idx = 0;
  pi->size = 0;
  pi->opcode = p;

d174 1
a174 1
int opsize;			/* Set when a register size is seen.  */
a182 12
static void clever_message PARAMS ((const struct h8_instruction *, struct h8_op *));
static void build_bytes    PARAMS ((const struct h8_instruction *, struct h8_op *));
static void do_a_fix_imm   PARAMS ((int, struct h8_op *, int));
static void check_operand  PARAMS ((struct h8_op *, unsigned int, char *));
static const struct h8_instruction * get_specific PARAMS ((const struct h8_instruction *, struct h8_op *, int));
static char * get_operands PARAMS ((unsigned, char *, struct h8_op *));
static void   get_operand  PARAMS ((char **, struct h8_op *, unsigned, int));
static char * skip_colonthing PARAMS ((char *, expressionS *, int *));
static char * parse_exp PARAMS ((char *, expressionS *));
static int    parse_reg PARAMS ((char *, op_type *, unsigned *, int));
char * colonmod24 PARAMS ((struct h8_op *, char *));

d202 1
d315 1
a315 1
	  /* ff fill any 8 bit quantity.  */
d333 1
a333 1
	  while (ISDIGIT (*ptr))
d353 3
a355 1
   @@@@aa[:8]		memory indirect.  */
d361 1
a382 1

d385 1
a401 4
  /* Check for '(' and ')' for instructions ldm and stm.  */
  if (src[0] == '(' && src[8] == ')')
    ++ src;

d404 2
a405 2
  if (src[0] == 'e' && src[1] == 'r' && ISDIGIT (src[2])
      && src[3] == '-' && src[4] == 'e' && src[5] == 'r' && ISDIGIT (src[6]))
d431 1
a431 4
      if (src[7] == ')')
	*ptr = src + 8;
      else
	*ptr = src + 7;
d599 3
a601 1
	    as_bad (_("expect :8 or :16 here"));
d604 3
a606 2
	op->mode = PCREL | bsize;

d658 3
a660 4

static const struct h8_instruction *
get_specific (instruction, operands, size)
     const struct h8_instruction *instruction;
d664 1
a664 1
  const struct h8_instruction *this_try = instruction;
d666 2
a667 1
  int this_index = instruction->idx;
d671 2
a672 2
  if (strcmp (instruction->opcode->name, "stm.l") == 0
      || strcmp (instruction->opcode->name, "ldm.l") == 0)
d675 1
a675 1
  while (this_index == instruction->idx && !found)
d679 1
a679 1
      this_try = instruction++;
d684 1
a684 1
	  this_size = this_try->opcode->how & SN;
d690 1
a690 1
	  int i;
d694 1
a694 1
	      op_type op = this_try->opcode->args.nib[i];
d790 1
a790 1
	  (operand->exp.X_add_number | width) != (unsigned)(~0))
a798 8
	  else if (strcmp (string, "@@") == 0
		   && width == 0xffff
		   && (operand->exp.X_add_number & 0xff8000) == 0xff8000)
	    {
	      /* Just ignore this one - which happens when trying to
		 fit a 24 bit address truncated into a 16 bit address
		 of something like mov.w.  */
	    }
a917 1

d920 1
a920 1
     const struct h8_instruction *this_try;
d923 2
a924 1
  int i;
d926 1
a926 1
  op_type *nibble_ptr = this_try->opcode->data.nib;
d929 3
a931 3
  int absat = 0;
  int immat = 0;
  int nib = 0;
d936 1
a936 1
  if (!(this_try->opcode->inbase || Hmode))
d938 1
a938 1
	     this_try->opcode->name);
d948 3
a950 1
	nib = c;
d954 3
a956 2
	    nib = operand[d].reg;

d958 3
a960 2
	    nib = dispreg;

d974 3
a976 2
	    nib = 0;

d1016 3
a1018 1
	    operand[d].mode |= MEMRELAX;
d1021 3
a1023 1
	    nib |= 0x8;
d1042 2
a1043 2
  if (strcmp (this_try->opcode->name, "stm.l") == 0
      || strcmp (this_try->opcode->name, "ldm.l") == 0)
d1046 2
a1047 2
      high = (operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg >> 8) & 0xf;
      low = operand[this_try->opcode->name[0] == 'l' ? 1 : 0].reg & 0xf;
d1050 1
a1050 1
      asnibbles[7] = (this_try->opcode->name[0] == 'l') ? high : low;
d1054 3
a1056 1
    output[i] = (asnibbles[i * 2] << 4) | asnibbles[i * 2 + 1];
d1060 1
a1060 1
  if (strcmp (this_try->opcode->name, "mov.b") == 0)
d1069 4
a1072 3
	do_a_fix_imm (output - frag_now->fr_literal + immat,
		      operand + i, (x & MEMRELAX) != 0);

d1074 4
a1077 3
	do_a_fix_imm (output - frag_now->fr_literal + absat,
		      operand + i, (x & MEMRELAX) ? movb + 1 : 0);

d1080 1
a1080 1
	  int size16 = x & (L_16);
a1083 1
	  fixS *fixP;
d1088 4
a1091 5
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);
#ifndef OBJ_ELF
	  /* The COFF port has always been off by one, changing it
	     now would be an incompatible change, so we leave it as-is.
a1092 2
	     We don't want to do this for ELF as we want to be
	     compatible with the proposed ELF format from Hitachi.  */
a1093 1
#endif
d1097 6
a1102 7
	  fixP = fix_new_exp (frag_now,
			      output - frag_now->fr_literal + where,
			      size,
			      &operand[i].exp,
			      1,
			      type);
	  fixP->fx_signed = 1;
a1115 9
	  int where = 0;

#ifdef OBJ_ELF
	  /* To be compatible with the proposed H8 ELF format, we
	     want the relocation's offset to point to the first byte
	     that will be modified, not to the start of the instruction.  */
	  where += 1;
#endif

a1118 1

d1120 4
a1123 3
	    as_warn (_("branch operand has odd offset (%lx)\n"),
		     (unsigned long) operand->exp.X_add_number);

d1128 1
a1128 1
		       output - frag_now->fr_literal + where,
a1138 1

d1140 2
a1141 2
clever_message (instruction, operand)
     const struct h8_instruction *instruction;
d1146 1
a1146 1
  if ((instruction + 1)->idx != instruction->idx)
d1148 1
a1148 1
      int argn;
d1152 1
a1152 1
      for (argn = 0; argn < instruction->noperands; argn++)
d1154 1
a1154 1
	  switch (instruction->opcode->args.nib[argn])
a1204 1

d1212 2
a1213 2
  const struct h8_instruction *instruction;
  const struct h8_instruction *prev_instruction;
d1245 2
a1246 2
  instruction = (const struct h8_instruction *)
    hash_find (opcode_hash_control, op_start);
d1248 1
a1248 1
  if (instruction == NULL)
d1257 1
a1257 1
  (void) get_operands (instruction->noperands, op_end, operand);
d1259 1
a1259 1
  prev_instruction = instruction;
d1279 1
a1279 1
  instruction = get_specific (instruction, operand, size);
d1281 1
a1281 1
  if (instruction == 0)
d1288 1
a1288 1
      clever_message (prev_instruction, operand);
d1292 1
a1292 1
  if (instruction->size && dot)
d1294 1
a1294 1
      if (instruction->size != *dot)
d1300 1
a1300 5
  build_bytes (instruction, operand);

#ifdef BFD_ASSEMBLER
  dwarf2_emit_insn (instruction->length);
#endif
a1302 1
#ifndef BFD_ASSEMBLER
a1308 1
#endif
a1316 1
#ifndef BFD_ASSEMBLER
a1322 1
#endif
d1343 1
d1388 1
a1388 1
const char *md_shortopts = "";
a1408 2
void tc_aout_fix_to_chars PARAMS ((void));

a1417 3
#ifdef BFD_ASSEMBLER
     bfd *headers ATTRIBUTE_UNUSED;
#else
a1418 1
#endif
a1425 10
#ifdef BFD_ASSEMBLER
valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << align) - 1) & (-1 << align));
}
#else
a1433 2
#endif

d1436 1
a1436 1
md_apply_fix3 (fixP, valP, seg)
d1438 1
a1438 2
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
a1440 1
  long val = *valP;
a1459 3

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
a1487 1
#ifndef BFD_ASSEMBLER
a1549 45
#else /* BFD_ASSEMBLER */
arelent *
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *rel;
  bfd_reloc_code_real_type r_type;

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Difference of symbols in different sections is not supported");
	  return NULL;
	}
    }

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  rel->addend = fixp->fx_offset;

  r_type = fixp->fx_r_type;

#define DEBUG 0
#if DEBUG
  fprintf (stderr, "%s\n", bfd_get_reloc_code_name (r_type));
  fflush(stderr);
#endif
  rel->howto = bfd_reloc_type_lookup (stdoutput, r_type);
  if (rel->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent relocation type %s"),
		    bfd_get_reloc_code_name (r_type));
      return NULL;
    }

  return rel;
}
#endif
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d46 7
a52 8
static void sbranch (int);
static void h8300hmode (int);
static void h8300smode (int);
static void h8300hnmode (int);
static void h8300snmode (int);
static void h8300sxmode (int);
static void h8300sxnmode (int);
static void pint (int);
a56 1
int SXmode;
d58 3
a60 1
#define PSIZE (Hmode && !Nmode ? L_32 : L_16)
d62 1
a62 1
static int bsize = L_8;		/* Default branch displacement.  */
d73 1
a73 1
static struct h8_instruction *h8_instructions;
d75 3
a77 2
static void
h8300hmode (int arg ATTRIBUTE_UNUSED)
d87 3
a89 2
static void
h8300smode (int arg ATTRIBUTE_UNUSED)
d99 3
a101 2
static void
h8300hnmode (int arg ATTRIBUTE_UNUSED)
d112 3
a114 2
static void
h8300snmode (int arg ATTRIBUTE_UNUSED)
d125 3
a127 27
static void
h8300sxmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  SXmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sx))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
h8300sxnmode (int arg ATTRIBUTE_UNUSED)
{
  Smode = 1;
  Hmode = 1;
  SXmode = 1;
  Nmode = 1;
#ifdef BFD_ASSEMBLER
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, bfd_mach_h8300sxn))
    as_warn (_("could not set architecture and machine"));
#endif
}

static void
sbranch (int size)
d133 2
a134 1
pint (int arg ATTRIBUTE_UNUSED)
d147 1
a147 1
  {"h8300h",  h8300hmode,  0},
d149 1
a149 1
  {"h8300s",  h8300smode,  0},
a150 2
  {"h8300sx", h8300sxmode, 0},
  {"h8300sxn", h8300sxnmode, 0},
d154 5
d165 2
a166 2
  {"import",  s_ignore, 0},
  {"page",    listing_eject, 0},
d187 1
a187 1
md_begin (void)
d190 1
a190 1
  struct h8_opcode *p, *p1;
d208 8
a215 13
  pi = h8_instructions;
  p1 = h8_opcodes;
  /* We do a minimum amount of sorting on the opcode table; this is to
     make it easy to describe the mova instructions without unnecessary
     code duplication.
     Sorting only takes place inside blocks of instructions of the form
     X/Y, so for example mova/b, mova/w and mova/l can be intermixed.  */
  while (p1)
    {
      struct h8_opcode *first_skipped = 0;
      int len, cmplen = 0;
      char *src = p1->name;
      char *dst, *buffer;
d217 1
a217 5
      if (p1->name == 0)
	break;
      /* Strip off any . part when inserting the opcode and only enter
	 unique codes into the hash table.  */
      dst = buffer = malloc (strlen (src) + 1);
d223 1
a225 2
	  if (*src == '/')
	    cmplen = src - p1->name + 1;
d228 18
a245 37
      *dst = 0;
      len = dst - buffer;
      if (cmplen == 0)
	cmplen = len;
      hash_insert (opcode_hash_control, buffer, (char *) pi);
      strcpy (prev_buffer, buffer);
      idx++;

      for (p = p1; p->name; p++)
	{
	  /* A negative TIME is used to indicate that we've added this opcode
	     already.  */
	  if (p->time == -1)
	    continue;
	  if (strncmp (p->name, buffer, cmplen) != 0
	      || (p->name[cmplen] != '\0' && p->name[cmplen] != '.'
		  && p->name[cmplen - 1] != '/'))
	    {
	      if (first_skipped == 0)
		first_skipped = p;
	      break;
	    }
	  if (strncmp (p->name, buffer, len) != 0)
	    {
	      if (first_skipped == 0)
		first_skipped = p;
	      continue;
	    }

	  p->time = -1;
	  pi->size = p->name[len] == '.' ? p->name[len + 1] : 0;
	  pi->idx = idx;

	  /* Find the number of operands.  */
	  pi->noperands = 0;
	  while (pi->noperands < 3 && p->args.nib[pi->noperands] != (op_type) E)
	    pi->noperands++;
d247 1
a247 9
	  /* Find the length of the opcode in bytes.  */
	  pi->length = 0;
	  while (p->data.nib[pi->length * 2] != (op_type) E)
	    pi->length++;

	  pi->opcode = p;
	  pi++;
	}
      p1 = first_skipped;
d255 1
a255 1
  pi->opcode = 0;
d260 10
d277 11
a287 14
static void clever_message (const struct h8_instruction *, struct h8_op *);
static void fix_operand_size (struct h8_op *, int);
static void build_bytes (const struct h8_instruction *, struct h8_op *);
static void do_a_fix_imm (int, int, struct h8_op *, int);
static void check_operand (struct h8_op *, unsigned int, char *);
static const struct h8_instruction * get_specific (const struct h8_instruction *, struct h8_op *, int) ;
static char *get_operands (unsigned, char *, struct h8_op *);
static void get_operand (char **, struct h8_op *, int);
static int parse_reg (char *, op_type *, unsigned *, int);
static char *skip_colonthing (char *, int *);
static char *parse_exp (char *, struct h8_op *);

static int constant_fits_width_p (struct h8_op *, unsigned int);
static int constant_fits_size_p (struct h8_op *, int, int);
d303 5
a307 1
parse_reg (char *src, op_type *mode, unsigned int *reg, int direction)
d316 1
a316 1
  while ((is_part_of_name (*end) && *end != '.') || *end == '\001')
d320 1
a320 1
  if (len == 2 && TOLOWER (src[0]) == 's' && TOLOWER (src[1]) == 'p')
d326 1
a326 4
  if (len == 3 && 
      TOLOWER (src[0]) == 'c' && 
      TOLOWER (src[1]) == 'c' && 
      TOLOWER (src[2]) == 'r')
d332 1
a332 4
  if (len == 3 && 
      TOLOWER (src[0]) == 'e' && 
      TOLOWER (src[1]) == 'x' && 
      TOLOWER (src[2]) == 'r')
d335 1
a335 19
      *reg = 1;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 'v' && 
      TOLOWER (src[1]) == 'b' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = VBR;
      *reg = 6;
      return len;
    }
  if (len == 3 && 
      TOLOWER (src[0]) == 's' && 
      TOLOWER (src[1]) == 'b' && 
      TOLOWER (src[2]) == 'r')
    {
      *mode = SBR;
      *reg = 7;
d338 1
a338 1
  if (len == 2 && TOLOWER (src[0]) == 'f' && TOLOWER (src[1]) == 'p')
d344 2
a345 2
  if (len == 3 && TOLOWER (src[0]) == 'e' && TOLOWER (src[1]) == 'r' &&
      src[2] >= '0' && src[2] <= '7')
d353 1
a353 1
  if (len == 2 && TOLOWER (src[0]) == 'e' && src[1] >= '0' && src[1] <= '7')
d362 1
a362 1
  if (TOLOWER (src[0]) == 'r')
d366 1
a366 1
	  if (len == 3 && TOLOWER (src[2]) == 'l')
d372 1
a372 1
	  if (len == 3 && TOLOWER (src[2]) == 'h')
a389 5

/* Parse an immediate or address-related constant and store it in OP.
   If the user also specifies the operand's size, store that size
   in OP->MODE, otherwise leave it for later code to decide.  */

d391 10
a400 8
parse_exp (char *src, struct h8_op *op)
{
  char *save;

  save = input_line_pointer;
  input_line_pointer = src;
  expression (&op->exp);
  if (op->exp.X_op == O_absent)
d402 1
a402 1
  src = input_line_pointer;
d404 1
a404 2

  return skip_colonthing (src, &op->mode);
a406 4

/* If SRC starts with an explicit operand size, skip it and store the size
   in *MODE.  Leave *MODE unchanged otherwise.  */

d408 4
a411 1
skip_colonthing (char *src, int *mode)
d413 1
a413 1
  if (*src == ':')
d415 1
a415 1
      src++;
d417 7
a423 16
      if (src[0] == '8' && !ISDIGIT (src[1]))
	*mode |= L_8;
      else if (src[0] == '2' && !ISDIGIT (src[1]))
	*mode |= L_2;
      else if (src[0] == '3' && !ISDIGIT (src[1]))
	*mode |= L_3;
      else if (src[0] == '4' && !ISDIGIT (src[1]))
	*mode |= L_4;
      else if (src[0] == '5' && !ISDIGIT (src[1]))
	*mode |= L_5;
      else if (src[0] == '2' && src[1] == '4' && !ISDIGIT (src[2]))
	*mode |= L_24;
      else if (src[0] == '3' && src[1] == '2' && !ISDIGIT (src[2]))
	*mode |= L_32;
      else if (src[0] == '1' && src[1] == '6' && !ISDIGIT (src[2]))
	*mode |= L_16;
d425 16
a440 4
	as_bad (_("invalid operand size requested"));

      while (ISDIGIT (*src))
	src++;
d442 1
a442 1
  return src;
d460 4
a463 2
static int
constant_fits_width_p (struct h8_op *operand, unsigned int width)
d465 2
a466 3
  return ((operand->exp.X_add_number & ~width) == 0
	  || (operand->exp.X_add_number | width) == (unsigned)(~0));
}
d468 1
a468 8
static int
constant_fits_size_p (struct h8_op *operand, int size, int no_symbols)
{
  offsetT num = operand->exp.X_add_number;
  if (no_symbols
      && (operand->exp.X_add_symbol != 0 || operand->exp.X_op_symbol != 0))
    return 0;
  switch (size)
d470 14
a483 22
    case L_2:
      return (num & ~3) == 0;
    case L_3:
      return (num & ~7) == 0;
    case L_3NZ:
      return num >= 1 && num < 8;
    case L_4:
      return (num & ~15) == 0;
    case L_5:
      return num >= 1 && num < 32;
    case L_8:
      return (num & ~0xFF) == 0 || ((unsigned)num | 0x7F) == ~0u;
    case L_8U:
      return (num & ~0xFF) == 0;
    case L_16:
      return (num & ~0xFFFF) == 0 || ((unsigned)num | 0x7FFF) == ~0u;
    case L_16U:
      return (num & ~0xFFFF) == 0;
    case L_32:
      return 1;
    default:
      abort ();
d485 3
d491 5
a495 1
get_operand (char **ptr, struct h8_op *op, int direction)
d502 1
a502 1
  op->mode = 0;
d510 2
a511 3
  if (TOLOWER (src[0]) == 'e' && TOLOWER (src[1]) == 'r' && 
      ISDIGIT (src[2]) && src[3] == '-' &&
      TOLOWER (src[4]) == 'e' && TOLOWER (src[5]) == 'r' && ISDIGIT (src[6]))
d518 11
a528 10
       /* Check register pair's validity as per tech note TN-H8*-193A/E
	  from Renesas for H8S and H8SX hardware manual.  */
      if (   !(low == 0 && (high == 1 || high == 2 || high == 3))
          && !(low == 1 && (high == 2 || high == 3 || high == 4) && SXmode)
          && !(low == 2 && (high == 3 || ((high == 4 || high == 5) && SXmode)))
          && !(low == 3 && (high == 4 || high == 5 || high == 6) && SXmode)
          && !(low == 4 && (high == 5 || high == 6))
          && !(low == 4 && high == 7 && SXmode)
          && !(low == 5 && (high == 6 || high == 7) && SXmode)
          && !(low == 6 && high == 7 && SXmode))
d547 1
a547 31
      src += len;
      if (*src == '.')
	{
	  int size = op->mode & SIZE;
	  switch (src[1])
	    {
	    case 'l': case 'L':
	      if (size != L_32)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      break;
	    case 'w': case 'W':
	      if (size != L_32 && size != L_16)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      op->mode = (op->mode & ~SIZE) | L_16;
	      break;
	    case 'b': case 'B':
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      if (size != L_32 && size != L_8)
		as_warn (_("mismatch between register and suffix"));
	      op->mode = (op->mode & ~MODE) | LOWREG;
	      op->mode = (op->mode & ~SIZE) | L_8;
	      break;
	    default:
	      as_warn ("invalid suffix after register.");
	      break;
	    }
	  src += 2;
	}
      *ptr = src;
d556 4
a559 4
	  *ptr = parse_exp (src + 1, op);
	  if (op->exp.X_add_number >= 0x100)
	    {
	      int divisor = 1;
d561 1
a561 8
	      op->mode = VECIND;
	      /* FIXME : 2?  or 4?  */
	      if (op->exp.X_add_number >= 0x400)
		as_bad (_("address too high for vector table jmp/jsr"));
	      else if (op->exp.X_add_number >= 0x200)
		divisor = 4;
	      else
		divisor = 2;
d563 1
a563 4
	      op->exp.X_add_number = op->exp.X_add_number / divisor - 0x80;
	    }
	  else
	    op->mode = MEMIND;
d567 1
a567 1
      if (*src == '-' || *src == '+')
d569 2
a570 1
	  len = parse_reg (src + 1, &mode, &num, direction);
d574 6
a579 2
	      op->mode = ABS | direction;
	      *ptr = parse_exp (src, op);
d583 1
a583 3
	  if (((mode & SIZE) != PSIZE)
	      /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
	      && (!Nmode || ((mode & SIZE) != L_32)))
d585 1
a585 2

	  op->mode = src[0] == '-' ? RDPREDEC : RDPREINC;
d587 1
a587 1
	  *ptr = src + 1 + len;
d592 1
d595 1
a595 33
	  /* See if this is @@(ERn.x, PC).  */
	  len = parse_reg (src, &mode, &op->reg, direction);
	  if (len != 0 && (mode & MODE) == REG && src[len] == '.')
	    {
	      switch (TOLOWER (src[len + 1]))
		{
		case 'b':
		  mode = PCIDXB | direction;
		  break;
		case 'w':
		  mode = PCIDXW | direction;
		  break;
		case 'l':
		  mode = PCIDXL | direction;
		  break;
		default:
		  mode = 0;
		  break;
		}
	      if (mode
		  && src[len + 2] == ','
		  && TOLOWER (src[len + 3]) != 'p' 
		  && TOLOWER (src[len + 4]) != 'c'
		  && src[len + 5] != ')')
		{
		  *ptr = src + len + 6;
		  op->mode |= mode;
		  return;
		}
	      /* Fall through into disp case - the grammar is somewhat
		 ambiguous, so we should try whether it's a DISP operand
		 after all ("ER3.L" might be a poorly named label...).  */
	    }
d597 1
a597 1
	  /* Disp.  */
d599 1
a599 1
	  /* Start off assuming a 16 bit offset.  */
a600 1
	  src = parse_exp (src, op);
d603 1
d605 1
a605 1
	      *ptr = src + 1;
d613 1
d618 1
a618 1
	  if (len == 0 || (mode & MODE) != REG)
d623 2
d626 1
a626 22
	  if (src[0] == '.')
	    {
	      switch (TOLOWER (src[1]))
		{
		case 'b':
		  op->mode |= INDEXB | direction;
		  break;
		case 'w':
		  op->mode |= INDEXW | direction;
		  break;
		case 'l':
		  op->mode |= INDEXL | direction;
		  break;
		default:
		  as_bad (_("expected .L, .W or .B for register in indexed addressing mode"));
		}
	      src += 2;
	      op->reg &= 7;
	    }
	  else
	    op->mode |= DISP | direction;
	  src = skip_colonthing (src, &op->mode);
d634 1
d642 1
a642 1
	  if (*src == '+' || *src == '-')
d644 2
a645 3
	      if (((mode & SIZE) != PSIZE)
		  /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
		  && (!Nmode || ((mode & SIZE) != L_32)))
d647 1
a647 1
	      op->mode = *src == '+' ? RSPOSTINC : RSPOSTDEC;
a648 1
	      src++;
d652 1
a652 3
	  if (((mode & SIZE) != PSIZE)
	      /* For Normal mode accept 16 bit and 32 bit pointer registers.  */
	      && (!Nmode || ((mode & SIZE) != L_32)))
d666 4
a669 1
	  *ptr = parse_exp (src, op);
d676 1
d678 3
a680 1
      *ptr = parse_exp (src + 1, op);
d683 2
a684 4
  else if (strncmp (src, "mach", 4) == 0 || 
	   strncmp (src, "macl", 4) == 0 ||
	   strncmp (src, "MACH", 4) == 0 || 
	   strncmp (src, "MACL", 4) == 0)
d686 1
a686 1
      op->reg = TOLOWER (src[3]) == 'l';
d693 21
a713 2
      op->mode = PCREL;
      *ptr = parse_exp (src, op);
d718 4
a721 1
get_operands (unsigned int noperands, char *op_end, struct h8_op *operand)
d728 2
d734 1
a734 1
      get_operand (&ptr, operand + 0, SRC);
d738 5
a742 1
	  get_operand (&ptr, operand + 1, DST);
d748 1
a748 1
      get_operand (&ptr, operand + 0, SRC);
d751 1
a751 12
      get_operand (&ptr, operand + 1, DST);
      break;

    case 3:
      ptr++;
      get_operand (&ptr, operand + 0, SRC);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, DST);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 2, OP3);
a760 121
/* MOVA has special requirements.  Rather than adding twice the amount of
   addressing modes, we simply special case it a bit.  */
static void
get_mova_operands (char *op_end, struct h8_op *operand)
{
  char *ptr = op_end;

  if (ptr[1] != '@@' || ptr[2] != '(')
    goto error;
  ptr += 3;
  operand[0].mode = 0;
  ptr = parse_exp (ptr, &operand[0]);

  if (*ptr !=',')
    goto error;
  ptr++;
  get_operand (&ptr, operand + 1, DST);

  if (*ptr =='.')
    {
      ptr++;
      switch (*ptr++)
	{
	case 'b': case 'B':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXB;
	  break;
	case 'w': case 'W':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXW;
	  break;
	case 'l': case 'L':
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXL;
	  break;
	default:
	  goto error;
	}
    }
  else if ((operand[1].mode & MODE) == LOWREG)
    {
      switch (operand[1].mode & SIZE) 
	{
	case L_8:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXB;
	  break;
	case L_16:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXW;
	  break;
	case L_32:
	  operand[0].mode = (operand[0].mode & ~MODE) | INDEXL;
	  break;
	default:
	  goto error;
	}
    }
  else
    goto error;

  if (*ptr++ != ')' || *ptr++ != ',')
    goto error;
  get_operand (&ptr, operand + 2, OP3);
  /* See if we can use the short form of MOVA.  */
  if (((operand[1].mode & MODE) == REG || (operand[1].mode & MODE) == LOWREG)
      && (operand[2].mode & MODE) == REG
      && (operand[1].reg & 7) == (operand[2].reg & 7))
    {
      operand[1].mode = operand[2].mode = 0;
      operand[0].reg = operand[2].reg & 7;
    }
  return;

 error:
  as_bad (_("expected valid addressing mode for mova: \"@@(disp, ea.sz),ERn\""));
}

static void
get_rtsl_operands (char *ptr, struct h8_op *operand)
{
  int mode, num, num2, len, type = 0;

  ptr++;
  if (*ptr == '(')
    {
      ptr++;
      type = 1;
    }
  len = parse_reg (ptr, &mode, &num, SRC);
  if (len == 0 || (mode & MODE) != REG)
    {
      as_bad (_("expected register"));
      return;
    }
  ptr += len;
  if (*ptr == '-')
    {
      len = parse_reg (++ptr, &mode, &num2, SRC);
      if (len == 0 || (mode & MODE) != REG)
	{
	  as_bad (_("expected register"));
	  return;
	}
      ptr += len;
      /* CONST_xxx are used as placeholders in the opcode table.  */
      num = num2 - num;
      if (num < 0 || num > 3)
	{
	  as_bad (_("invalid register list"));
	  return;
	}
    }
  else
    num2 = num, num = 0;
  if (type == 1 && *ptr++ != ')')
    {
      as_bad (_("expected closing paren"));
      return;
    }
  operand[0].mode = RS32;
  operand[1].mode = RD32;
  operand[0].reg = num;
  operand[1].reg = num2;
}

d766 4
a769 2
get_specific (const struct h8_instruction *instruction,
	      struct h8_op *operands, int size)
a771 1
  const struct h8_instruction *found_other = 0, *found_mismatched = 0;
a773 1
  int noperands = 0;
d777 2
a778 2
  if (OP_KIND (instruction->opcode->how) == O_LDM
      || OP_KIND (instruction->opcode->how) == O_STM)
a780 3
  while (noperands < 3 && operands[noperands].mode != 0)
    noperands++;

d783 1
a783 1
      int this_size;
a784 1
      found = 1;
d786 3
a788 1
      this_size = this_try->opcode->how & SN;
d790 5
a794 3
      if (this_try->noperands != noperands)
	found = 0;
      else if (this_try->noperands > 0)
a800 2
	      int op_mode = op & MODE;
	      int op_size = op & SIZE;
a801 2
	      int x_mode = x & MODE;
	      int x_size = x & SIZE;
d803 2
a804 1
	      if (op_mode == LOWREG && (x_mode == REG || x_mode == LOWREG))
d806 1
a806 6
		  if ((x_size == L_8 && (operands[i].reg & 8) == 0)
		      || (x_size == L_16 && (operands[i].reg & 8) == 8))
		    as_warn (_("can't use high part of register in operand %d"), i);

		  if (x_size != op_size)
		    found = 0;
d808 1
a808 1
	      else if (op_mode == REG)
d810 1
a810 3
		  if (x_mode == LOWREG)
		    x_mode = REG;
		  if (x_mode != REG)
d813 6
a818 4
		  if (x_size == L_P)
		    x_size = (Hmode ? L_32 : L_16);
		  if (op_size == L_P)
		    op_size = (Hmode ? L_32 : L_16);
d821 1
a821 1
		  if (op_size != x_size)
d824 1
a824 1
	      else if (op_mode & CTRL)	/* control register */
d826 1
a826 44
		  if (!(x_mode & CTRL))
		    found = 0;

		  switch (x_mode)
		    {
		    case CCR:
		      if (op_mode != CCR &&
			  op_mode != CCR_EXR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case EXR:
		      if (op_mode != EXR &&
			  op_mode != CCR_EXR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case MACH:
		      if (op_mode != MACH &&
			  op_mode != MACREG)
			found = 0;
		      break;
		    case MACL:
		      if (op_mode != MACL &&
			  op_mode != MACREG)
			found = 0;
		      break;
		    case VBR:
		      if (op_mode != VBR &&
			  op_mode != VBR_SBR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    case SBR:
		      if (op_mode != SBR &&
			  op_mode != VBR_SBR &&
			  op_mode != CC_EX_VB_SB)
			found = 0;
		      break;
		    }
		}
	      else if ((op & ABSJMP) && (x_mode == ABS || x_mode == PCREL))
		{
		  operands[i].mode &= ~MODE;
d829 1
a829 1
		  if (x_mode == ABS && !Hmode)
a833 3
		  if ((operands[i].mode & SIZE) == L_32
		      && (op_mode & SIZE) != L_32)
		   found = 0;
d835 1
a835 1
	      else if (x_mode == IMM && op_mode != IMM)
d837 1
a837 13
		  offsetT num = operands[i].exp.X_add_number;
		  if (op_mode == KBIT || op_mode == DBIT)
		    /* This is ok if the immediate value is sensible.  */;
		  else if (op_mode == CONST_2)
		    found = num == 2;
		  else if (op_mode == CONST_4)
		    found = num == 4;
		  else if (op_mode == CONST_8)
		    found = num == 8;
		  else if (op_mode == CONST_16)
		    found = num == 16;
		  else
		    found = 0;
d839 1
a839 1
	      else if (op_mode == PCREL && op_mode == x_mode)
a840 8
		  /* movsd, bsr/bc and bsr/bs only come in PCREL16 flavour:
		     If x_size is L_8, promote it.  */
		  if (OP_KIND (this_try->opcode->how) == O_MOVSD
		      || OP_KIND (this_try->opcode->how) == O_BSRBC
		      || OP_KIND (this_try->opcode->how) == O_BSRBS)
		    if (x_size == L_8)
		      x_size = L_16;

d842 1
a842 1
		  if (op_size != x_size)
d845 2
a846 4
	      else if ((op_mode == DISP || op_mode == IMM || op_mode == ABS
			|| op_mode == INDEXB || op_mode == INDEXW
			|| op_mode == INDEXL)
		       && op_mode == x_mode)
d849 1
a849 1
		  if (x_size == L_24 && op_size == L_32)
d851 2
a852 2
		      x &= ~SIZE;
		      x |= x_size = L_32;
a853 2

#if 0 /* ??? */
d855 1
a855 1
		  if ((op_mode == ABS || op_mode == DISP) && x_size == L_8)
d857 2
a858 2
		      if (op_size == L_16)
			x_size = L_16;
d860 2
a861 16
#endif

		  if (((x_size == L_16 && op_size == L_16U)
		       || (x_size == L_8 && op_size == L_8U)
		       || (x_size == L_3 && op_size == L_3NZ))
		      /* We're deliberately more permissive for ABS modes.  */
		      && (op_mode == ABS
			  || constant_fits_size_p (operands + i, op_size,
						   op & NO_SYMBOLS)))
		    x_size = op_size;

		  if (x_size != 0 && op_size != x_size)
		    found = 0;
		  else if (x_size == 0
			   && ! constant_fits_size_p (operands + i, op_size,
						      op & NO_SYMBOLS))
d864 5
a868 1
	      else if (op_mode != x_mode)
a873 10
      if (found)
	{
	  if ((this_try->opcode->available == AV_H8SX && ! SXmode)
	      || (this_try->opcode->available == AV_H8S && ! Smode)
	      || (this_try->opcode->available == AV_H8H && ! Hmode))
	    found = 0, found_other = this_try;
	  else if (this_size != size && (this_size != SN && size != SN))
	    found_mismatched = this_try, found = 0;

	}
d877 2
a878 15
  if (found_other)
    {
      as_warn (_("Opcode `%s' with these operand types not available in %s mode"),
	       found_other->opcode->name,
	       (! Hmode && ! Smode ? "H8/300"
		: SXmode ? "H8sx"
		: Smode ? "H8/300S"
		: "H8/300H"));
    }
  else if (found_mismatched)
    {
      as_warn (_("mismatch between opcode size and operand size"));
      return found_mismatched;
    }
  return 0;
d882 4
a885 1
check_operand (struct h8_op *operand, unsigned int width, char *string)
d895 2
a896 1
      if (! constant_fits_width_p (operand, width))
d933 4
a936 1
do_a_fix_imm (int offset, int nibble, struct h8_op *operand, int relaxmode)
a940 1
  char *bytes = frag_now->fr_literal + offset;
d942 1
a942 1
  char *t = ((operand->mode & MODE) == IMM) ? "#" : "@@";
d946 1
d951 1
a951 1
	  bytes[0] |= (operand->exp.X_add_number & 3) << (nibble ? 0 : 4);
a953 1
	case L_3NZ:
d955 1
a955 9
	  bytes[0] |= (operand->exp.X_add_number & 7) << (nibble ? 0 : 4);
	  break;
	case L_4:
	  check_operand (operand, 0xF, t);
	  bytes[0] |= (operand->exp.X_add_number & 15) << (nibble ? 0 : 4);
	  break;
	case L_5:
	  check_operand (operand, 0x1F, t);
	  bytes[0] |= operand->exp.X_add_number & 31;
a957 1
	case L_8U:
d959 1
a959 1
	  bytes[0] |= operand->exp.X_add_number;
a961 1
	case L_16U:
d963 2
a964 2
	  bytes[0] |= operand->exp.X_add_number >> 8;
	  bytes[1] |= operand->exp.X_add_number >> 0;
d968 3
a970 3
	  bytes[0] |= operand->exp.X_add_number >> 16;
	  bytes[1] |= operand->exp.X_add_number >> 8;
	  bytes[2] |= operand->exp.X_add_number >> 0;
d975 4
a978 4
	  bytes[0] |= operand->exp.X_add_number >> 24;
	  bytes[1] |= operand->exp.X_add_number >> 16;
	  bytes[2] |= operand->exp.X_add_number >> 8;
	  bytes[3] |= operand->exp.X_add_number >> 0;
a1004 1
	case L_16U:
a1012 1
	  operand->exp.X_add_number |= (bytes[0] << 8) | bytes[1];
a1019 1
	  operand->exp.X_add_number |= bytes[0];
d1034 3
a1036 1
build_bytes (const struct h8_instruction *this_try, struct h8_op *operand)
d1043 2
a1044 1
  int op_at[3];
d1047 1
a1047 1
  char asnibbles[100];
a1048 1
  int high, low;
d1050 1
a1050 1
  if (!Hmode && this_try->opcode->available != AV_H8)
a1052 11
  else if (!Smode 
	   && this_try->opcode->available != AV_H8 
	   && this_try->opcode->available != AV_H8H)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300H mode"),
	     this_try->opcode->name);
  else if (!SXmode 
	   && this_try->opcode->available != AV_H8
	   && this_try->opcode->available != AV_H8H
	   && this_try->opcode->available != AV_H8S)
    as_warn (_("Opcode `%s' with these operand types not available in H8/300S mode"),
	     this_try->opcode->name);
d1054 1
a1054 1
  while (*nibble_ptr != (op_type) E)
a1056 2

      nib = 0;
d1059 1
a1059 1
      d = (c & OP3) == OP3 ? 2 : (c & DST) == DST ? 1 : 0;
d1065 1
a1065 12
	  int c2 = c & MODE;

	  if (c2 == REG || c2 == LOWREG
	      || c2 == IND || c2 == PREINC || c2 == PREDEC
	      || c2 == POSTINC || c2 == POSTDEC)
	    {
	      nib = operand[d].reg;
	      if (c2 == LOWREG)
		nib &= 7;
	    }

	  else if (c & CTRL)	/* Control reg operand.  */
d1069 3
a1071 4
	    {
	      nib = operand[d].reg;
	    }
	  else if (c2 == ABS)
d1074 1
a1074 1
	      op_at[d] = nibble_count;
d1077 1
a1077 2
	  else if (c2 == IMM || c2 == PCREL || c2 == ABS
		   || (c & ABSJMP) || c2 == DISP)
d1080 1
a1080 1
	      op_at[d] = nibble_count;
d1083 1
a1083 1
	  else if ((c & IGNORE) || (c & DATA))
d1086 1
a1086 1
	  else if (c2 == DBIT)
d1100 1
a1100 1
	  else if (c2 == KBIT)
d1130 1
a1130 10
	  if (c & B21)
	    nib |= 0x4;

	  if (c & B11)
	    nib |= 0x2;

	  if (c & B01)
	    nib |= 0x1;

	  if (c2 == MACREG)
d1147 2
a1148 1
  if (OP_KIND (this_try->opcode->how) == O_LDM)
d1150 4
a1153 2
      high = (operand[1].reg >> 8) & 0xf;
      low  = (operand[1].reg) & 0xf;
d1155 1
a1155 8
      asnibbles[7] = high;
    }
  else if (OP_KIND (this_try->opcode->how) == O_STM)
    {
      high = (operand[0].reg >> 8) & 0xf;
      low  = (operand[0].reg) & 0xf;
      asnibbles[2] = high - low;
      asnibbles[7] = low;
d1161 3
a1163 17
  /* Note if this is a movb or a bit manipulation instruction
     there is a special relaxation which only applies.  */
  if (   this_try->opcode->how == O (O_MOV,   SB)
      || this_try->opcode->how == O (O_BCLR,  SB)
      || this_try->opcode->how == O (O_BAND,  SB)
      || this_try->opcode->how == O (O_BIAND, SB)
      || this_try->opcode->how == O (O_BILD,  SB)
      || this_try->opcode->how == O (O_BIOR,  SB)
      || this_try->opcode->how == O (O_BIST,  SB)
      || this_try->opcode->how == O (O_BIXOR, SB)
      || this_try->opcode->how == O (O_BLD,   SB)
      || this_try->opcode->how == O (O_BNOT,  SB)
      || this_try->opcode->how == O (O_BOR,   SB)
      || this_try->opcode->how == O (O_BSET,  SB)
      || this_try->opcode->how == O (O_BST,   SB)
      || this_try->opcode->how == O (O_BTST,  SB)
      || this_try->opcode->how == O (O_BXOR,  SB))
d1167 1
a1167 1
  for (i = 0; i < this_try->noperands; i++)
a1169 5
      int x_mode = x & MODE;

      if (x_mode == IMM || x_mode == DISP)
	do_a_fix_imm (output - frag_now->fr_literal + op_at[i] / 2,
		      op_at[i] & 1, operand + i, (x & MEMRELAX) != 0);
d1171 7
a1177 4
      else if (x_mode == ABS)
	do_a_fix_imm (output - frag_now->fr_literal + op_at[i] / 2,
		      op_at[i] & 1, operand + i,
		      (x & MEMRELAX) ? movb + 1 : 0);
d1179 1
a1179 1
      else if (x_mode == PCREL)
d1181 2
a1182 1
	  int size16 = (x & SIZE) == L_16;
d1200 2
a1201 14
	  if (size16)
	    {
	      operand[i].exp.X_add_number =
		((operand[i].exp.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
	    }
	  else
	    {
	      operand[i].exp.X_add_number =
		((operand[i].exp.X_add_number & 0xff) ^ 0x80) - 0x80;
	    }

	  /* For BRA/S.  */
	  if (! size16)
	    operand[i].exp.X_add_number |= output[op_at[i] / 2];
d1204 1
a1204 1
			      output - frag_now->fr_literal + op_at[i] / 2,
d1211 1
a1211 1
      else if (x_mode == MEMIND)
a1220 13
      else if (x_mode == VECIND)
	{
	  check_operand (operand + i, 0x7f, "@@@@");
	  /* FIXME: approximating the effect of "B31" here...
	     This is very hackish, and ought to be done a better way.  */
	  operand[i].exp.X_add_number |= 0x80;
	  fix_new_exp (frag_now,
		       output - frag_now->fr_literal + 1,
		       1,
		       &operand[i].exp,
		       0,
		       R_MEM_INDIRECT);
	}
a1223 1
	  bfd_reloc_code_real_type reloc_type = R_JMPL1;
d1229 1
a1229 8
	  
	  if ((operand->mode & SIZE) == L_32)
	    {
	      where = 2;
	      reloc_type = R_RELLONG;
	    }
	  else
	    where = 1;
d1234 1
a1234 3
	  check_operand (operand + i, 
			 SXmode ? 0xffffffff : Hmode ? 0xffffff : 0xffff, 
			 "@@");
d1248 1
a1248 1
		       reloc_type);
d1257 3
a1259 2
clever_message (const struct h8_instruction *instruction,
		struct h8_op *operand)
a1318 67

/* If OPERAND is part of an address, adjust its size and value given
   that it addresses SIZE bytes.

   This function decides how big non-immediate constants are when no
   size was explicitly given.  It also scales down the assembly-level
   displacement in an @@(d:2,ERn) operand.  */

static void
fix_operand_size (struct h8_op *operand, int size)
{
  if (SXmode && (operand->mode & MODE) == DISP)
    {
      /* If the user didn't specify an operand width, see if we
	 can use @@(d:2,ERn).  */
      if ((operand->mode & SIZE) == 0
	  && operand->exp.X_add_symbol == 0
	  && operand->exp.X_op_symbol == 0
	  && (operand->exp.X_add_number == size
	      || operand->exp.X_add_number == size * 2
	      || operand->exp.X_add_number == size * 3))
	operand->mode |= L_2;

      /* Scale down the displacement in an @@(d:2,ERn) operand.
	 X_add_number then contains the desired field value.  */
      if ((operand->mode & SIZE) == L_2)
	{
	  if (operand->exp.X_add_number % size != 0)
	    as_warn (_("operand/size mis-match"));
	  operand->exp.X_add_number /= size;
	}
    }

  if ((operand->mode & SIZE) == 0)
    switch (operand->mode & MODE)
      {
      case DISP:
      case INDEXB:
      case INDEXW:
      case INDEXL:
      case ABS:
	/* Pick a 24-bit address unless we know that a 16-bit address
	   is safe.  get_specific() will relax L_24 into L_32 where
	   necessary.  */
	if (Hmode
	    && !Nmode 
	    && (operand->exp.X_add_number < -32768
		|| operand->exp.X_add_number > 32767
		|| operand->exp.X_add_symbol != 0
		|| operand->exp.X_op_symbol != 0))
	  operand->mode |= L_24;
	else
	  operand->mode |= L_16;
	break;

      case PCREL:
	/* This condition is long standing, though somewhat suspect.  */
	if (operand->exp.X_add_number > -128
	    && operand->exp.X_add_number < 127)
	  operand->mode |= L_8;
	else
	  operand->mode |= L_16;
	break;
      }
}


d1324 2
a1325 1
md_assemble (char *str)
d1329 1
a1329 1
  struct h8_op operand[3];
a1333 1
  char *slash = 0;
d1335 1
a1335 1
  int size, i;
a1352 2
      else if (*op_end == '/' && ! slash)
	slash = op_end;
a1362 6
  /* The assembler stops scanning the opcode at slashes, so it fails
     to make characters following them lower case.  Fix them.  */
  if (slash)
    while (*++slash)
      *slash = TOLOWER (*slash);

d1375 1
a1375 14
  operand[0].mode = 0;
  operand[1].mode = 0;
  operand[2].mode = 0;

  if (OP_KIND (instruction->opcode->how) == O_MOVAB
      || OP_KIND (instruction->opcode->how) == O_MOVAW
      || OP_KIND (instruction->opcode->how) == O_MOVAL)
    get_mova_operands (op_end, operand);
  else if (OP_KIND (instruction->opcode->how) == O_RTEL
	   || OP_KIND (instruction->opcode->how) == O_RTSL)
    get_rtsl_operands (op_end, operand);
  else
    get_operands (instruction->noperands, op_end, operand);

a1378 21
  /* Now we have operands from instruction.
     Let's check them out for ldm and stm.  */
  if (OP_KIND (instruction->opcode->how) == O_LDM)
    {
      /* The first operand must be @@er7+, and the
	 second operand must be a register pair.  */
      if ((operand[0].mode != RSINC)
           || (operand[0].reg != 7)
           || ((operand[1].reg & 0x80000000) == 0))
	as_bad (_("invalid operand in ldm"));
    }
  else if (OP_KIND (instruction->opcode->how) == O_STM)
    {
      /* The first operand must be a register pair,
	 and the second operand must be @@-er7.  */
      if (((operand[0].reg & 0x80000000) == 0)
            || (operand[1].mode != RDDEC)
            || (operand[1].reg != 7))
	as_bad (_("invalid operand in stm"));
    }

d1382 1
a1382 1
      switch (TOLOWER (*dot))
a1396 37
  if (OP_KIND (instruction->opcode->how) == O_MOVAB ||
      OP_KIND (instruction->opcode->how) == O_MOVAW ||
      OP_KIND (instruction->opcode->how) == O_MOVAL)
    {
      switch (operand[0].mode & MODE)
	{
	case INDEXB:
	default:
	  fix_operand_size (&operand[1], 1);
	  break;
	case INDEXW:
	  fix_operand_size (&operand[1], 2);
	  break;
	case INDEXL:
	  fix_operand_size (&operand[1], 4);
	  break;
	}
    }
  else
    {
      for (i = 0; i < 3 && operand[i].mode != 0; i++)
	switch (size)
	  {
	  case SN:
	  case SB:
	  default:
	    fix_operand_size (&operand[i], 1);
	    break;
	  case SW:
	    fix_operand_size (&operand[i], 2);
	    break;
	  case SL:
	    fix_operand_size (&operand[i], 4);
	    break;
	  }
    }

d1410 7
d1427 2
a1428 1
tc_crawl_symbol_chain (object_headers *headers ATTRIBUTE_UNUSED)
d1435 2
a1436 1
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
d1443 2
a1444 1
tc_headers_hook (object_headers *headers ATTRIBUTE_UNUSED)
d1460 4
a1463 1
md_atof (int type, char *litP, int *sizeP)
d1521 3
a1523 1
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
d1529 2
a1530 1
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
d1534 1
a1534 1
void tc_aout_fix_to_chars (void);
d1537 1
a1537 1
tc_aout_fix_to_chars (void)
d1544 1
a1544 1
md_convert_frag (
d1546 1
a1546 1
		 bfd *headers ATTRIBUTE_UNUSED,
d1548 1
a1548 1
		 object_headers *headers ATTRIBUTE_UNUSED,
d1550 2
a1551 2
		 segT seg ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
d1559 3
a1561 1
md_section_align (segT segment, valueT size)
d1568 3
a1570 1
md_section_align (segT seg, valueT size)
d1579 4
a1582 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
d1611 3
a1613 2
md_estimate_size_before_relax (register fragS *fragP ATTRIBUTE_UNUSED,
			       register segT segment_type ATTRIBUTE_UNUSED)
d1621 4
a1624 1
md_number_to_chars (char *ptr, valueT use, int nbytes)
d1630 2
a1631 1
md_pcrel_from (fixS *fixP ATTRIBUTE_UNUSED)
d1638 5
a1642 1
tc_reloc_mangle (fixS *fix_ptr, struct internal_reloc *intr, bfd_vma base)
d1701 3
a1703 1
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
@


