head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.48
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.44
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.46
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.38
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.42
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.40
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.36
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.34
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.32
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.30
	OPENBSD_5_0:1.9.0.28
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.26
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.24
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BINUTILS_2_15:1.1.1.10
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	BINUTILS-2_14:1.1.1.9
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	binutils-2_11_2:1.1.1.8
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	BINUTILS-2_10_1:1.1.1.7
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2004.11.02.20.45.26;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.09.22.29.33;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.46;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.34;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.05.17;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.56;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.56;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.14;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.44.21;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.15;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.22.35;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.18;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2001.06.09.22.07.13;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2002.05.13.13.33.04;	author fgsch;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.05.17.20.42.27;	author drahn;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2004.11.02.20.22.47;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* coff object file format
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GAS.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#define OBJ_HEADER "obj-coff.h"

#include "as.h"
#include "obstack.h"
#include "subsegs.h"

/* I think this is probably always correct.  */
#ifndef KEEP_RELOC_INFO
#define KEEP_RELOC_INFO
#endif

/* The BFD_ASSEMBLER version of obj_coff_section will use this macro to set
   a new section's attributes when a directive has no valid flags or the
   "w" flag is used. This default should be appropriate for most.  */
#ifndef TC_COFF_SECTION_DEFAULT_ATTRIBUTES
#define TC_COFF_SECTION_DEFAULT_ATTRIBUTES (SEC_LOAD | SEC_DATA)
#endif

/* This is used to hold the symbol built by a sequence of pseudo-ops
   from .def and .endef.  */
static symbolS *def_symbol_in_progress;

typedef struct
  {
    unsigned long chunk_size;
    unsigned long element_size;
    unsigned long size;
    char *data;
    unsigned long pointer;
  }
stack;

static stack *stack_init PARAMS ((unsigned long, unsigned long));
static char *stack_push PARAMS ((stack *, char *));
static char *stack_pop PARAMS ((stack *));
static void tag_init PARAMS ((void));
static void tag_insert PARAMS ((const char *, symbolS *));
static symbolS *tag_find PARAMS ((char *));
static symbolS *tag_find_or_make PARAMS ((char *));
static void obj_coff_bss PARAMS ((int));
static void obj_coff_weak PARAMS ((int));
const char *s_get_name PARAMS ((symbolS * s));
static void obj_coff_ln PARAMS ((int));
static void obj_coff_def PARAMS ((int));
static void obj_coff_endef PARAMS ((int));
static void obj_coff_dim PARAMS ((int));
static void obj_coff_line PARAMS ((int));
static void obj_coff_size PARAMS ((int));
static void obj_coff_scl PARAMS ((int));
static void obj_coff_tag PARAMS ((int));
static void obj_coff_val PARAMS ((int));
static void obj_coff_type PARAMS ((int));
static void obj_coff_ident PARAMS ((int));
#ifdef BFD_ASSEMBLER
static void obj_coff_loc PARAMS((int));
#endif

/* stack stuff */

static stack *
stack_init (chunk_size, element_size)
     unsigned long chunk_size;
     unsigned long element_size;
{
  stack *st;

  st = (stack *) malloc (sizeof (stack));
  if (!st)
    return 0;
  st->data = malloc (chunk_size);
  if (!st->data)
    {
      free (st);
      return 0;
    }
  st->pointer = 0;
  st->size = chunk_size;
  st->chunk_size = chunk_size;
  st->element_size = element_size;
  return st;
}

#if 0
/* Not currently used.  */
static void
stack_delete (st)
     stack *st;
{
  free (st->data);
  free (st);
}
#endif

static char *
stack_push (st, element)
     stack *st;
     char *element;
{
  if (st->pointer + st->element_size >= st->size)
    {
      st->size += st->chunk_size;
      if ((st->data = xrealloc (st->data, st->size)) == (char *) 0)
	return (char *) 0;
    }
  memcpy (st->data + st->pointer, element, st->element_size);
  st->pointer += st->element_size;
  return st->data + st->pointer;
}

static char *
stack_pop (st)
     stack *st;
{
  if (st->pointer < st->element_size)
    {
      st->pointer = 0;
      return (char *) 0;
    }
  st->pointer -= st->element_size;
  return st->data + st->pointer;
}

/*
 * Maintain a list of the tagnames of the structures.
 */

static struct hash_control *tag_hash;

static void
tag_init ()
{
  tag_hash = hash_new ();
}

static void
tag_insert (name, symbolP)
     const char *name;
     symbolS *symbolP;
{
  const char *error_string;

  if ((error_string = hash_jam (tag_hash, name, (char *) symbolP)))
    {
      as_fatal (_("Inserting \"%s\" into structure table failed: %s"),
		name, error_string);
    }
}

static symbolS *
tag_find (name)
     char *name;
{
#ifdef STRIP_UNDERSCORE
  if (*name == '_')
    name++;
#endif /* STRIP_UNDERSCORE */
  return (symbolS *) hash_find (tag_hash, name);
}

static symbolS *
tag_find_or_make (name)
     char *name;
{
  symbolS *symbolP;

  if ((symbolP = tag_find (name)) == NULL)
    {
      symbolP = symbol_new (name, undefined_section,
			    0, &zero_address_frag);

      tag_insert (S_GET_NAME (symbolP), symbolP);
#ifdef BFD_ASSEMBLER
      symbol_table_insert (symbolP);
#endif
    }				/* not found */

  return symbolP;
}

/* We accept the .bss directive to set the section for backward
   compatibility with earlier versions of gas.  */

static void
obj_coff_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (*input_line_pointer == '\n')
    subseg_new (".bss", get_absolute_expression ());
  else
    s_lcomm (0);
}

/* Handle .weak.  This is a GNU extension.  */

static void
obj_coff_weak (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  int c;
  symbolS *symbolP;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();

#if defined BFD_ASSEMBLER || defined S_SET_WEAK
      S_SET_WEAK (symbolP);
#endif

#ifdef TE_PE
      S_SET_STORAGE_CLASS (symbolP, C_NT_WEAK);
#else
      S_SET_STORAGE_CLASS (symbolP, C_WEAKEXT);
#endif

      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

#ifdef BFD_ASSEMBLER

static segT fetch_coff_debug_section PARAMS ((void));
static void SA_SET_SYM_TAGNDX PARAMS ((symbolS *, symbolS *));
static int S_GET_DATA_TYPE PARAMS ((symbolS *));
void c_symbol_merge PARAMS ((symbolS *, symbolS *));
static void add_lineno PARAMS ((fragS *, addressT, int));

#define GET_FILENAME_STRING(X) \
((char*) (&((X)->sy_symbol.ost_auxent->x_file.x_n.x_offset))[1])

/* @@@@ Ick.  */
static segT
fetch_coff_debug_section ()
{
  static segT debug_section;
  if (!debug_section)
    {
      const asymbol *s;
      s = bfd_make_debug_symbol (stdoutput, (char *) 0, 0);
      assert (s != 0);
      debug_section = s->section;
    }
  return debug_section;
}

void
SA_SET_SYM_ENDNDX (sym, val)
     symbolS *sym;
     symbolS *val;
{
  combined_entry_type *entry, *p;

  entry = &coffsymbol (symbol_get_bfdsym (sym))->native[1];
  p = coffsymbol (symbol_get_bfdsym (val))->native;
  entry->u.auxent.x_sym.x_fcnary.x_fcn.x_endndx.p = p;
  entry->fix_end = 1;
}

static void
SA_SET_SYM_TAGNDX (sym, val)
     symbolS *sym;
     symbolS *val;
{
  combined_entry_type *entry, *p;

  entry = &coffsymbol (symbol_get_bfdsym (sym))->native[1];
  p = coffsymbol (symbol_get_bfdsym (val))->native;
  entry->u.auxent.x_sym.x_tagndx.p = p;
  entry->fix_tag = 1;
}

static int
S_GET_DATA_TYPE (sym)
     symbolS *sym;
{
  return coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_type;
}

int
S_SET_DATA_TYPE (sym, val)
     symbolS *sym;
     int val;
{
  coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_type = val;
  return val;
}

int
S_GET_STORAGE_CLASS (sym)
     symbolS *sym;
{
  return coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_sclass;
}

int
S_SET_STORAGE_CLASS (sym, val)
     symbolS *sym;
     int val;
{
  coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_sclass = val;
  return val;
}

/* Merge a debug symbol containing debug information into a normal symbol.  */

void
c_symbol_merge (debug, normal)
     symbolS *debug;
     symbolS *normal;
{
  S_SET_DATA_TYPE (normal, S_GET_DATA_TYPE (debug));
  S_SET_STORAGE_CLASS (normal, S_GET_STORAGE_CLASS (debug));

  if (S_GET_NUMBER_AUXILIARY (debug) > S_GET_NUMBER_AUXILIARY (normal))
    {
      /* take the most we have */
      S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));
    }

  if (S_GET_NUMBER_AUXILIARY (debug) > 0)
    {
      /* Move all the auxiliary information.  */
      memcpy (SYM_AUXINFO (normal), SYM_AUXINFO (debug),
	      (S_GET_NUMBER_AUXILIARY (debug)
	       * sizeof (*SYM_AUXINFO (debug))));
    }

  /* Move the debug flags.  */
  SF_SET_DEBUG_FIELD (normal, SF_GET_DEBUG_FIELD (debug));
}

void
c_dot_file_symbol (filename)
     const char *filename;
{
  symbolS *symbolP;

  /* BFD converts filename to a .file symbol with an aux entry.  It
     also handles chaining.  */
  symbolP = symbol_new (filename, bfd_abs_section_ptr, 0, &zero_address_frag);

  S_SET_STORAGE_CLASS (symbolP, C_FILE);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);

  symbol_get_bfdsym (symbolP)->flags = BSF_DEBUGGING;

#ifndef NO_LISTING
  {
    extern int listing;
    if (listing)
      {
	listing_source_file (filename);
      }
  }
#endif

  /* Make sure that the symbol is first on the symbol chain */
  if (symbol_rootP != symbolP)
    {
      symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
      symbol_insert (symbolP, symbol_rootP, &symbol_rootP, &symbol_lastP);
    }				/* if not first on the list */
}

/* Line number handling */

struct line_no {
  struct line_no *next;
  fragS *frag;
  alent l;
};

int coff_line_base;

/* Symbol of last function, which we should hang line#s off of.  */
static symbolS *line_fsym;

#define in_function()		(line_fsym != 0)
#define clear_function()	(line_fsym = 0)
#define set_function(F)		(line_fsym = (F), coff_add_linesym (F))


void
coff_obj_symbol_new_hook (symbolP)
     symbolS *symbolP;
{
  long   sz = (OBJ_COFF_MAX_AUXENTRIES + 1) * sizeof (combined_entry_type);
  char * s  = (char *) xmalloc (sz);

  memset (s, 0, sz);
  coffsymbol (symbol_get_bfdsym (symbolP))->native = (combined_entry_type *) s;

  S_SET_DATA_TYPE (symbolP, T_NULL);
  S_SET_STORAGE_CLASS (symbolP, 0);
  S_SET_NUMBER_AUXILIARY (symbolP, 0);

  if (S_IS_STRING (symbolP))
    SF_SET_STRING (symbolP);

  if (S_IS_LOCAL (symbolP))
    SF_SET_LOCAL (symbolP);
}


/*
 * Handle .ln directives.
 */

static symbolS *current_lineno_sym;
static struct line_no *line_nos;
/* @@@@ Blindly assume all .ln directives will be in the .text section...  */
int coff_n_line_nos;

static void
add_lineno (frag, offset, num)
     fragS *frag;
     addressT offset;
     int num;
{
  struct line_no *new_line =
    (struct line_no *) xmalloc (sizeof (struct line_no));
  if (!current_lineno_sym)
    {
      abort ();
    }

#ifndef OBJ_XCOFF
  /* The native aix assembler accepts negative line number */

  if (num <= 0)
    {
      /* Zero is used as an end marker in the file.  */
      as_warn (_("Line numbers must be positive integers\n"));
      num = 1;
    }
#endif /* OBJ_XCOFF */
  new_line->next = line_nos;
  new_line->frag = frag;
  new_line->l.line_number = num;
  new_line->l.u.offset = offset;
  line_nos = new_line;
  coff_n_line_nos++;
}

void
coff_add_linesym (sym)
     symbolS *sym;
{
  if (line_nos)
    {
      coffsymbol (symbol_get_bfdsym (current_lineno_sym))->lineno =
	(alent *) line_nos;
      coff_n_line_nos++;
      line_nos = 0;
    }
  current_lineno_sym = sym;
}

static void
obj_coff_ln (appline)
     int appline;
{
  int l;

  if (! appline && def_symbol_in_progress != NULL)
    {
      as_warn (_(".ln pseudo-op inside .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  l = get_absolute_expression ();

  /* If there is no lineno symbol, treat a .ln
     directive as if it were a .appline directive.  */
  if (appline || current_lineno_sym == NULL)
    new_logical_line ((char *) NULL, l - 1);
  else
    add_lineno (frag_now, frag_now_fix (), l);

#ifndef NO_LISTING
  {
    extern int listing;

    if (listing)
      {
	if (! appline)
	  l += coff_line_base - 1;
	listing_source_line (l);
      }
  }
#endif

  demand_empty_rest_of_line ();
}

/* .loc is essentially the same as .ln; parse it for assembler
   compatibility.  */

static void
obj_coff_loc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int lineno;

  /* FIXME: Why do we need this check?  We need it for ECOFF, but why
     do we need it for COFF?  */
  if (now_seg != text_section)
    {
      as_warn (_(".loc outside of .text"));
      demand_empty_rest_of_line ();
      return;
    }

  if (def_symbol_in_progress != NULL)
    {
      as_warn (_(".loc pseudo-op inside .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  /* Skip the file number.  */
  SKIP_WHITESPACE ();
  get_absolute_expression ();
  SKIP_WHITESPACE ();

  lineno = get_absolute_expression ();

#ifndef NO_LISTING
  {
    extern int listing;

    if (listing)
      {
	lineno += coff_line_base - 1;
	listing_source_line (lineno);
      }
  }
#endif

  demand_empty_rest_of_line ();

  add_lineno (frag_now, frag_now_fix (), lineno);
}

/* Handle the .ident pseudo-op.  */

static void
obj_coff_ident (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  segT current_seg = now_seg;
  subsegT current_subseg = now_subseg;

#ifdef TE_PE
  {
    segT sec;

    /* We could put it in .comment, but that creates an extra section
       that shouldn't be loaded into memory, which requires linker
       changes...  For now, until proven otherwise, use .rdata.  */
    sec = subseg_new (".rdata$zzz", 0);
    bfd_set_section_flags (stdoutput, sec,
			   ((SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA)
			    & bfd_applicable_section_flags (stdoutput)));
  }
#else
  subseg_new (".comment", 0);
#endif

  stringer (1);
  subseg_set (current_seg, current_subseg);
}

/*
 *			def()
 *
 * Handle .def directives.
 *
 * One might ask : why can't we symbol_new if the symbol does not
 * already exist and fill it with debug information.  Because of
 * the C_EFCN special symbol. It would clobber the value of the
 * function symbol before we have a chance to notice that it is
 * a C_EFCN. And a second reason is that the code is more clear this
 * way. (at least I think it is :-).
 *
 */

#define SKIP_SEMI_COLON()	while (*input_line_pointer++ != ';')
#define SKIP_WHITESPACES()	while (*input_line_pointer == ' ' || \
				       *input_line_pointer == '\t') \
    input_line_pointer++;

static void
obj_coff_def (what)
     int what ATTRIBUTE_UNUSED;
{
  char name_end;		/* Char after the end of name */
  char *symbol_name;		/* Name of the debug symbol */
  char *symbol_name_copy;	/* Temporary copy of the name */
  unsigned int symbol_name_length;

  if (def_symbol_in_progress != NULL)
    {
      as_warn (_(".def pseudo-op used inside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }				/* if not inside .def/.endef */

  SKIP_WHITESPACES ();

  symbol_name = input_line_pointer;
#ifdef STRIP_UNDERSCORE
  if (symbol_name[0] == '_' && symbol_name[1] != 0)
    symbol_name++;
#endif /* STRIP_UNDERSCORE */

  name_end = get_symbol_end ();
  symbol_name_length = strlen (symbol_name);
  symbol_name_copy = xmalloc (symbol_name_length + 1);
  strcpy (symbol_name_copy, symbol_name);
#ifdef tc_canonicalize_symbol_name
  symbol_name_copy = tc_canonicalize_symbol_name (symbol_name_copy);
#endif

  /* Initialize the new symbol */
  def_symbol_in_progress = symbol_make (symbol_name_copy);
  symbol_set_frag (def_symbol_in_progress, &zero_address_frag);
  S_SET_VALUE (def_symbol_in_progress, 0);

  if (S_IS_STRING (def_symbol_in_progress))
    SF_SET_STRING (def_symbol_in_progress);

  *input_line_pointer = name_end;

  demand_empty_rest_of_line ();
}

unsigned int dim_index;

static void
obj_coff_endef (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *symbolP = NULL;

  /* DIM BUG FIX sac@@cygnus.com */
  dim_index = 0;
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".endef pseudo-op used outside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }				/* if not inside .def/.endef */

  /* Set the section number according to storage class.  */
  switch (S_GET_STORAGE_CLASS (def_symbol_in_progress))
    {
    case C_STRTAG:
    case C_ENTAG:
    case C_UNTAG:
      SF_SET_TAG (def_symbol_in_progress);
      /* intentional fallthrough */
    case C_FILE:
    case C_TPDEF:
      SF_SET_DEBUG (def_symbol_in_progress);
      S_SET_SEGMENT (def_symbol_in_progress, fetch_coff_debug_section ());
      break;

    case C_EFCN:
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol.  */
      /* intentional fallthrough */
    case C_BLOCK:
      SF_SET_PROCESS (def_symbol_in_progress);	/* Will need processing before writing */
      /* intentional fallthrough */
    case C_FCN:
      {
	const char *name;
	S_SET_SEGMENT (def_symbol_in_progress, text_section);

	name = S_GET_NAME (def_symbol_in_progress);
	if (name[0] == '.' && name[2] == 'f' && name[3] == '\0')
	  {
	    switch (name[1])
	      {
	      case 'b':
		/* .bf */
		if (! in_function ())
		  as_warn (_("`%s' symbol without preceding function"), name);
		/* Will need relocating.  */
		SF_SET_PROCESS (def_symbol_in_progress);
		clear_function ();
		break;
#ifdef TE_PE
	      case 'e':
		/* .ef */
		/* The MS compilers output the actual endline, not the
		   function-relative one... we want to match without
		   changing the assembler input.  */
		SA_SET_SYM_LNNO (def_symbol_in_progress,
				 (SA_GET_SYM_LNNO (def_symbol_in_progress)
				  + coff_line_base));
		break;
#endif
	      }
	  }
      }
      break;

#ifdef C_AUTOARG
    case C_AUTOARG:
#endif /* C_AUTOARG */
    case C_AUTO:
    case C_REG:
    case C_ARG:
    case C_REGPARM:
    case C_FIELD:

    /* According to the COFF documentation:

       http://osr5doc.sco.com:1996/topics/COFF_SectNumFld.html

       A special section number (-2) marks symbolic debugging symbols,
       including structure/union/enumeration tag names, typedefs, and
       the name of the file. A section number of -1 indicates that the
       symbol has a value but is not relocatable. Examples of
       absolute-valued symbols include automatic and register variables,
       function arguments, and .eos symbols.

       But from Ian Lance Taylor:

       http://sources.redhat.com/ml/binutils/2000-08/msg00202.html

       the actual tools all marked them as section -1. So the GNU COFF
       assembler follows historical COFF assemblers.

       However, it causes problems for djgpp

       http://sources.redhat.com/ml/binutils/2000-08/msg00210.html

       By defining STRICTCOFF, a COFF port can make the assembler to
       follow the documented behavior.  */
#ifdef STRICTCOFF
    case C_MOS:
    case C_MOE:
    case C_MOU:
    case C_EOS:
#endif
      SF_SET_DEBUG (def_symbol_in_progress);
      S_SET_SEGMENT (def_symbol_in_progress, absolute_section);
      break;

#ifndef STRICTCOFF
    case C_MOS:
    case C_MOE:
    case C_MOU:
    case C_EOS:
      S_SET_SEGMENT (def_symbol_in_progress, absolute_section);
      break;
#endif

    case C_EXT:
    case C_WEAKEXT:
#ifdef TE_PE
    case C_NT_WEAK:
#endif
    case C_STAT:
    case C_LABEL:
      /* Valid but set somewhere else (s_comm, s_lcomm, colon) */
      break;

    default:
    case C_USTATIC:
    case C_EXTDEF:
    case C_ULABEL:
      as_warn (_("unexpected storage class %d"),
	       S_GET_STORAGE_CLASS (def_symbol_in_progress));
      break;
    }				/* switch on storage class */

  /* Now that we have built a debug symbol, try to find if we should
     merge with an existing symbol or not.  If a symbol is C_EFCN or
     absolute_section or untagged SEG_DEBUG it never merges.  We also
     don't merge labels, which are in a different namespace, nor
     symbols which have not yet been defined since they are typically
     unique, nor do we merge tags with non-tags.  */

  /* Two cases for functions.  Either debug followed by definition or
     definition followed by debug.  For definition first, we will
     merge the debug symbol into the definition.  For debug first, the
     lineno entry MUST point to the definition function or else it
     will point off into space when obj_crawl_symbol_chain() merges
     the debug symbol into the real symbol.  Therefor, let's presume
     the debug symbol is a real function reference.  */

  /* FIXME-SOON If for some reason the definition label/symbol is
     never seen, this will probably leave an undefined symbol at link
     time.  */

  if (S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_EFCN
      || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_LABEL
      || (!strcmp (bfd_get_section_name (stdoutput,
					 S_GET_SEGMENT (def_symbol_in_progress)),
		   "*DEBUG*")
	  && !SF_GET_TAG (def_symbol_in_progress))
      || S_GET_SEGMENT (def_symbol_in_progress) == absolute_section
      || ! symbol_constant_p (def_symbol_in_progress)
      || (symbolP = symbol_find_base (S_GET_NAME (def_symbol_in_progress),
				      DO_NOT_STRIP)) == NULL
      || SF_GET_TAG (def_symbol_in_progress) != SF_GET_TAG (symbolP))
    {
      /* If it already is at the end of the symbol list, do nothing */
      if (def_symbol_in_progress != symbol_lastP)
	{
	  symbol_remove (def_symbol_in_progress, &symbol_rootP, &symbol_lastP);
	  symbol_append (def_symbol_in_progress, symbol_lastP, &symbol_rootP,
			 &symbol_lastP);
	}
    }
  else
    {
      /* This symbol already exists, merge the newly created symbol
	 into the old one.  This is not mandatory. The linker can
	 handle duplicate symbols correctly. But I guess that it save
	 a *lot* of space if the assembly file defines a lot of
	 symbols. [loic] */

      /* The debug entry (def_symbol_in_progress) is merged into the
	 previous definition.  */

      c_symbol_merge (def_symbol_in_progress, symbolP);
      symbol_remove (def_symbol_in_progress, &symbol_rootP, &symbol_lastP);

      def_symbol_in_progress = symbolP;

      if (SF_GET_FUNCTION (def_symbol_in_progress)
	  || SF_GET_TAG (def_symbol_in_progress)
	  || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_STAT)
	{
	  /* For functions, and tags, and static symbols, the symbol
	     *must* be where the debug symbol appears.  Move the
	     existing symbol to the current place.  */
	  /* If it already is at the end of the symbol list, do nothing */
	  if (def_symbol_in_progress != symbol_lastP)
	    {
	      symbol_remove (def_symbol_in_progress, &symbol_rootP, &symbol_lastP);
	      symbol_append (def_symbol_in_progress, symbol_lastP, &symbol_rootP, &symbol_lastP);
	    }
	}
    }

  if (SF_GET_TAG (def_symbol_in_progress))
    {
      symbolS *oldtag;

      oldtag = symbol_find_base (S_GET_NAME (def_symbol_in_progress),
				 DO_NOT_STRIP);
      if (oldtag == NULL || ! SF_GET_TAG (oldtag))
	tag_insert (S_GET_NAME (def_symbol_in_progress),
		    def_symbol_in_progress);
    }

  if (SF_GET_FUNCTION (def_symbol_in_progress))
    {
      know (sizeof (def_symbol_in_progress) <= sizeof (long));
      set_function (def_symbol_in_progress);
      SF_SET_PROCESS (def_symbol_in_progress);

      if (symbolP == NULL)
	{
	  /* That is, if this is the first time we've seen the
	     function...  */
	  symbol_table_insert (def_symbol_in_progress);
	} /* definition follows debug */
    } /* Create the line number entry pointing to the function being defined */

  def_symbol_in_progress = NULL;
  demand_empty_rest_of_line ();
}

static void
obj_coff_dim (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int dim_index;

  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".dim pseudo-op used outside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }				/* if not inside .def/.endef */

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);

  for (dim_index = 0; dim_index < DIMNUM; dim_index++)
    {
      SKIP_WHITESPACES ();
      SA_SET_SYM_DIMEN (def_symbol_in_progress, dim_index,
			get_absolute_expression ());

      switch (*input_line_pointer)
	{
	case ',':
	  input_line_pointer++;
	  break;

	default:
	  as_warn (_("badly formed .dim directive ignored"));
	  /* intentional fallthrough */
	case '\n':
	case ';':
	  dim_index = DIMNUM;
	  break;
	}
    }

  demand_empty_rest_of_line ();
}

static void
obj_coff_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int this_base;

  if (def_symbol_in_progress == NULL)
    {
      /* Probably stabs-style line?  */
      obj_coff_ln (0);
      return;
    }

  this_base = get_absolute_expression ();
  if (!strcmp (".bf", S_GET_NAME (def_symbol_in_progress)))
    coff_line_base = this_base;

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  SA_SET_SYM_LNNO (def_symbol_in_progress, this_base);

  demand_empty_rest_of_line ();

#ifndef NO_LISTING
  if (strcmp (".bf", S_GET_NAME (def_symbol_in_progress)) == 0)
    {
      extern int listing;

      if (listing)
	listing_source_line ((unsigned int) this_base);
    }
#endif
}

static void
obj_coff_size (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".size pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }				/* if not inside .def/.endef */

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  SA_SET_SYM_SIZE (def_symbol_in_progress, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
obj_coff_scl (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".scl pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }				/* if not inside .def/.endef */

  S_SET_STORAGE_CLASS (def_symbol_in_progress, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
obj_coff_tag (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *symbol_name;
  char name_end;

  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".tag pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  symbol_name = input_line_pointer;
  name_end = get_symbol_end ();

#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif

  /* Assume that the symbol referred to by .tag is always defined.
     This was a bad assumption.  I've added find_or_make. xoxorich.  */
  SA_SET_SYM_TAGNDX (def_symbol_in_progress,
		     tag_find_or_make (symbol_name));
  if (SA_GET_SYM_TAGNDX (def_symbol_in_progress) == 0L)
    {
      as_warn (_("tag not found for .tag %s"), symbol_name);
    }				/* not defined */

  SF_SET_TAGGED (def_symbol_in_progress);
  *input_line_pointer = name_end;

  demand_empty_rest_of_line ();
}

static void
obj_coff_type (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".type pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }				/* if not inside .def/.endef */

  S_SET_DATA_TYPE (def_symbol_in_progress, get_absolute_expression ());

  if (ISFCN (S_GET_DATA_TYPE (def_symbol_in_progress)) &&
      S_GET_STORAGE_CLASS (def_symbol_in_progress) != C_TPDEF)
    {
      SF_SET_FUNCTION (def_symbol_in_progress);
    }				/* is a function */

  demand_empty_rest_of_line ();
}

static void
obj_coff_val (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".val pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }				/* if not inside .def/.endef */

  if (is_name_beginner (*input_line_pointer))
    {
      char *symbol_name = input_line_pointer;
      char name_end = get_symbol_end ();

#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif
      if (!strcmp (symbol_name, "."))
	{
	  symbol_set_frag (def_symbol_in_progress, frag_now);
	  S_SET_VALUE (def_symbol_in_progress, (valueT) frag_now_fix ());
	  /* If the .val is != from the .def (e.g. statics) */
	}
      else if (strcmp (S_GET_NAME (def_symbol_in_progress), symbol_name))
	{
	  expressionS exp;

	  exp.X_op = O_symbol;
	  exp.X_add_symbol = symbol_find_or_make (symbol_name);
	  exp.X_op_symbol = NULL;
	  exp.X_add_number = 0;
	  symbol_set_value_expression (def_symbol_in_progress, &exp);

	  /* If the segment is undefined when the forward reference is
	     resolved, then copy the segment id from the forward
	     symbol.  */
	  SF_SET_GET_SEGMENT (def_symbol_in_progress);

	  /* FIXME: gcc can generate address expressions here in
	     unusual cases (search for "obscure" in sdbout.c).  We
	     just ignore the offset here, thus generating incorrect
	     debugging information.  We ignore the rest of the line
	     just below.  */
	}
      /* Otherwise, it is the name of a non debug symbol and its value
         will be calculated later.  */
      *input_line_pointer = name_end;
    }
  else
    {
      S_SET_VALUE (def_symbol_in_progress, get_absolute_expression ());
    }				/* if symbol based */

  demand_empty_rest_of_line ();
}

void
coff_obj_read_begin_hook ()
{
  /* These had better be the same.  Usually 18 bytes.  */
#ifndef BFD_HEADERS
  know (sizeof (SYMENT) == sizeof (AUXENT));
  know (SYMESZ == AUXESZ);
#endif
  tag_init ();
}

symbolS *coff_last_function;
#ifndef OBJ_XCOFF
static symbolS *coff_last_bf;
#endif

void
coff_frob_symbol (symp, punt)
     symbolS *symp;
     int *punt;
{
  static symbolS *last_tagP;
  static stack *block_stack;
  static symbolS *set_end;
  symbolS *next_set_end = NULL;

  if (symp == &abs_symbol)
    {
      *punt = 1;
      return;
    }

  if (current_lineno_sym)
    coff_add_linesym ((symbolS *) 0);

  if (!block_stack)
    block_stack = stack_init (512, sizeof (symbolS*));

  if (S_IS_WEAK (symp))
    {
#ifdef TE_PE
      S_SET_STORAGE_CLASS (symp, C_NT_WEAK);
#else
      S_SET_STORAGE_CLASS (symp, C_WEAKEXT);
#endif
    }

  if (!S_IS_DEFINED (symp)
      && !S_IS_WEAK (symp)
      && S_GET_STORAGE_CLASS (symp) != C_STAT)
    S_SET_STORAGE_CLASS (symp, C_EXT);

  if (!SF_GET_DEBUG (symp))
    {
      symbolS * real;

      if (!SF_GET_LOCAL (symp)
	  && !SF_GET_STATICS (symp)
	  && S_GET_STORAGE_CLASS (symp) != C_LABEL
	  && symbol_constant_p(symp)
	  && (real = symbol_find_base (S_GET_NAME (symp), DO_NOT_STRIP))
	  && S_GET_STORAGE_CLASS (real) == C_NULL
	  && real != symp)
	{
	  c_symbol_merge (symp, real);
	  *punt = 1;
	  return;
	}

      if (!S_IS_DEFINED (symp) && !SF_GET_LOCAL (symp))
	{
	  assert (S_GET_VALUE (symp) == 0);
	  S_SET_EXTERNAL (symp);
	}
      else if (S_GET_STORAGE_CLASS (symp) == C_NULL)
	{
	  if (S_GET_SEGMENT (symp) == text_section
	      && symp != seg_info (text_section)->sym)
	    S_SET_STORAGE_CLASS (symp, C_LABEL);
	  else
	    S_SET_STORAGE_CLASS (symp, C_STAT);
	}

      if (SF_GET_PROCESS (symp))
	{
	  if (S_GET_STORAGE_CLASS (symp) == C_BLOCK)
	    {
	      if (!strcmp (S_GET_NAME (symp), ".bb"))
		stack_push (block_stack, (char *) &symp);
	      else
		{
		  symbolS *begin;

		  begin = *(symbolS **) stack_pop (block_stack);
		  if (begin == 0)
		    as_warn (_("mismatched .eb"));
		  else
		    next_set_end = begin;
		}
	    }

	  if (coff_last_function == 0 && SF_GET_FUNCTION (symp))
	    {
	      union internal_auxent *auxp;

	      coff_last_function = symp;
	      if (S_GET_NUMBER_AUXILIARY (symp) < 1)
		S_SET_NUMBER_AUXILIARY (symp, 1);
	      auxp = SYM_AUXENT (symp);
	      memset (auxp->x_sym.x_fcnary.x_ary.x_dimen, 0,
		      sizeof (auxp->x_sym.x_fcnary.x_ary.x_dimen));
	    }

	  if (S_GET_STORAGE_CLASS (symp) == C_EFCN)
	    {
	      if (coff_last_function == 0)
		as_fatal (_("C_EFCN symbol out of scope"));
	      SA_SET_SYM_FSIZE (coff_last_function,
				(long) (S_GET_VALUE (symp)
					- S_GET_VALUE (coff_last_function)));
	      next_set_end = coff_last_function;
	      coff_last_function = 0;
	    }
	}

      if (S_IS_EXTERNAL (symp))
	S_SET_STORAGE_CLASS (symp, C_EXT);
      else if (SF_GET_LOCAL (symp))
	*punt = 1;

      if (SF_GET_FUNCTION (symp))
	symbol_get_bfdsym (symp)->flags |= BSF_FUNCTION;

      /* more ...  */
    }

  /* Double check weak symbols.  */
  if (S_IS_WEAK (symp) && S_IS_COMMON (symp))
    as_bad (_("Symbol `%s' can not be both weak and common"),
	    S_GET_NAME (symp));

  if (SF_GET_TAG (symp))
    last_tagP = symp;
  else if (S_GET_STORAGE_CLASS (symp) == C_EOS)
    next_set_end = last_tagP;

#ifdef OBJ_XCOFF
  /* This is pretty horrible, but we have to set *punt correctly in
     order to call SA_SET_SYM_ENDNDX correctly.  */
  if (! symbol_used_in_reloc_p (symp)
      && ((symbol_get_bfdsym (symp)->flags & BSF_SECTION_SYM) != 0
	  || (! S_IS_EXTERNAL (symp)
	      && ! symbol_get_tc (symp)->output
	      && S_GET_STORAGE_CLASS (symp) != C_FILE)))
    *punt = 1;
#endif

  if (set_end != (symbolS *) NULL
      && ! *punt
      && ((symbol_get_bfdsym (symp)->flags & BSF_NOT_AT_END) != 0
	  || (S_IS_DEFINED (symp)
	      && ! S_IS_COMMON (symp)
	      && (! S_IS_EXTERNAL (symp) || SF_GET_FUNCTION (symp)))))
    {
      SA_SET_SYM_ENDNDX (set_end, symp);
      set_end = NULL;
    }

  if (next_set_end != NULL)
    {
      if (set_end != NULL)
	as_warn ("Warning: internal error: forgetting to set endndx of %s",
		 S_GET_NAME (set_end));
      set_end = next_set_end;
    }

#ifndef OBJ_XCOFF
  if (! *punt
      && S_GET_STORAGE_CLASS (symp) == C_FCN
      && strcmp (S_GET_NAME (symp), ".bf") == 0)
    {
      if (coff_last_bf != NULL)
	SA_SET_SYM_ENDNDX (coff_last_bf, symp);
      coff_last_bf = symp;
    }
#endif
  if (coffsymbol (symbol_get_bfdsym (symp))->lineno)
    {
      int i;
      struct line_no *lptr;
      alent *l;

      lptr = (struct line_no *) coffsymbol (symbol_get_bfdsym (symp))->lineno;
      for (i = 0; lptr; lptr = lptr->next)
	i++;
      lptr = (struct line_no *) coffsymbol (symbol_get_bfdsym (symp))->lineno;

      /* We need i entries for line numbers, plus 1 for the first
	 entry which BFD will override, plus 1 for the last zero
	 entry (a marker for BFD).  */
      l = (alent *) xmalloc ((i + 2) * sizeof (alent));
      coffsymbol (symbol_get_bfdsym (symp))->lineno = l;
      l[i + 1].line_number = 0;
      l[i + 1].u.sym = NULL;
      for (; i > 0; i--)
	{
	  if (lptr->frag)
	    lptr->l.u.offset += lptr->frag->fr_address / OCTETS_PER_BYTE;
	  l[i] = lptr->l;
	  lptr = lptr->next;
	}
    }
}

void
coff_adjust_section_syms (abfd, sec, x)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR x ATTRIBUTE_UNUSED;
{
  symbolS *secsym;
  segment_info_type *seginfo = seg_info (sec);
  int nlnno, nrelocs = 0;

  /* RS/6000 gas creates a .debug section manually in ppc_frob_file in
     tc-ppc.c.  Do not get confused by it.  */
  if (seginfo == NULL)
    return;

  if (!strcmp (sec->name, ".text"))
    nlnno = coff_n_line_nos;
  else
    nlnno = 0;
  {
    /* @@@@ Hope that none of the fixups expand to more than one reloc
       entry...  */
    fixS *fixp = seginfo->fix_root;
    while (fixp)
      {
	if (! fixp->fx_done)
	  nrelocs++;
	fixp = fixp->fx_next;
      }
  }
  if (bfd_get_section_size_before_reloc (sec) == 0
      && nrelocs == 0
      && nlnno == 0
      && sec != text_section
      && sec != data_section
      && sec != bss_section)
    return;
  secsym = section_symbol (sec);
  /* This is an estimate; we'll plug in the real value using
     SET_SECTION_RELOCS later */
  SA_SET_SCN_NRELOC (secsym, nrelocs);
  SA_SET_SCN_NLINNO (secsym, nlnno);
}

void
coff_frob_file_after_relocs ()
{
  bfd_map_over_sections (stdoutput, coff_adjust_section_syms, (char*) 0);
}

/* Implement the .section pseudo op:
  	.section name {, "flags"}
                  ^         ^
                  |         +--- optional flags: 'b' for bss
                  |                              'i' for info
                  +-- section name               'l' for lib
                                                 'n' for noload
                                                 'o' for over
                                                 'w' for data
  						 'd' (apparently m88k for data)
                                                 'x' for text
  						 'r' for read-only data
  						 's' for shared data (PE)
   But if the argument is not a quoted string, treat it as a
   subsegment number.

   Note the 'a' flag is silently ignored.  This allows the same
   .section directive to be parsed in both ELF and COFF formats.  */

void
obj_coff_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* Strip out the section name */
  char *section_name;
  char c;
  char *name;
  unsigned int exp;
  flagword flags, oldflags;
  asection *sec;

  if (flag_mri)
    {
      char type;

      s_mri_sect (&type);
      return;
    }

  section_name = input_line_pointer;
  c = get_symbol_end ();

  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);

  *input_line_pointer = c;

  SKIP_WHITESPACE ();

  exp = 0;
  flags = SEC_NO_FLAGS;

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (*input_line_pointer != '"')
	exp = get_absolute_expression ();
      else
	{
	  ++input_line_pointer;
	  while (*input_line_pointer != '"'
		 && ! is_end_of_line[(unsigned char) *input_line_pointer])
	    {
	      switch (*input_line_pointer)
		{
		case 'b': flags |= SEC_ALLOC; flags &=~ SEC_LOAD; break;
		case 'n': flags &=~ SEC_LOAD; flags |= SEC_NEVER_LOAD; break;

		case 's': flags |= SEC_SHARED; /* fall through */
		case 'd': flags |= SEC_DATA | SEC_LOAD; /* fall through */
		case 'w': flags &=~ SEC_READONLY; break;

		case 'a': break; /* For compatibility with ELF.  */
		case 'x': flags |= SEC_CODE | SEC_LOAD; break;
		case 'r': flags |= SEC_DATA | SEC_LOAD | SEC_READONLY; break;

		case 'i': /* STYP_INFO */
		case 'l': /* STYP_LIB */
		case 'o': /* STYP_OVER */
		  as_warn (_("unsupported section attribute '%c'"),
			   *input_line_pointer);
		  break;

		default:
		  as_warn(_("unknown section attribute '%c'"),
			  *input_line_pointer);
		  break;
		}
	      ++input_line_pointer;
	    }
	  if (*input_line_pointer == '"')
	    ++input_line_pointer;
	}
    }

  sec = subseg_new (name, (subsegT) exp);

  oldflags = bfd_get_section_flags (stdoutput, sec);
  if (oldflags == SEC_NO_FLAGS)
    {
      /* Set section flags for a new section just created by subseg_new.
         Provide a default if no flags were parsed.  */
      if (flags == SEC_NO_FLAGS)
	flags = TC_COFF_SECTION_DEFAULT_ATTRIBUTES;

#ifdef COFF_LONG_SECTION_NAMES
      /* Add SEC_LINK_ONCE and SEC_LINK_DUPLICATES_DISCARD to .gnu.linkonce
         sections so adjust_reloc_syms in write.c will correctly handle
         relocs which refer to non-local symbols in these sections.  */
      if (strncmp (name, ".gnu.linkonce", sizeof (".gnu.linkonce") - 1) == 0)
	flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
#endif

      if (! bfd_set_section_flags (stdoutput, sec, flags))
	as_warn (_("error setting flags for \"%s\": %s"),
		 bfd_section_name (stdoutput, sec),
		 bfd_errmsg (bfd_get_error ()));
    }
  else if (flags != SEC_NO_FLAGS)
    {
      /* This section's attributes have already been set. Warn if the
         attributes don't match.  */
      flagword matchflags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
			     | SEC_DATA | SEC_SHARED | SEC_NEVER_LOAD);
      if ((flags ^ oldflags) & matchflags)
	as_warn (_("Ignoring changed section attributes for %s"), name);
    }

  demand_empty_rest_of_line ();
}

void
coff_adjust_symtab ()
{
  if (symbol_rootP == NULL
      || S_GET_STORAGE_CLASS (symbol_rootP) != C_FILE)
    c_dot_file_symbol ("fake");
}

void
coff_frob_section (sec)
     segT sec;
{
  segT strsec;
  char *p;
  fragS *fragp;
  bfd_vma size, n_entries, mask;
  bfd_vma align_power = (bfd_vma)sec->alignment_power + OCTETS_PER_BYTE_POWER;

  /* The COFF back end in BFD requires that all section sizes be
     rounded up to multiples of the corresponding section alignments,
     supposedly because standard COFF has no other way of encoding alignment
     for sections.  If your COFF flavor has a different way of encoding
     section alignment, then skip this step, as TICOFF does.  */
  size = bfd_get_section_size_before_reloc (sec);
  mask = ((bfd_vma) 1 << align_power) - 1;
#if !defined(TICOFF)
  if (size & mask)
    {
      bfd_vma new_size;
      fragS *last;

      new_size = (size + mask) & ~mask;
      bfd_set_section_size (stdoutput, sec, new_size);

      /* If the size had to be rounded up, add some padding in
         the last non-empty frag.  */
      fragp = seg_info (sec)->frchainP->frch_root;
      last = seg_info (sec)->frchainP->frch_last;
      while (fragp->fr_next != last)
	fragp = fragp->fr_next;
      last->fr_address = size;
      fragp->fr_offset += new_size - size;
    }
#endif

  /* If the section size is non-zero, the section symbol needs an aux
     entry associated with it, indicating the size.  We don't know
     all the values yet; coff_frob_symbol will fill them in later.  */
#ifndef TICOFF
  if (size != 0
      || sec == text_section
      || sec == data_section
      || sec == bss_section)
#endif
    {
      symbolS *secsym = section_symbol (sec);

      S_SET_STORAGE_CLASS (secsym, C_STAT);
      S_SET_NUMBER_AUXILIARY (secsym, 1);
      SF_SET_STATICS (secsym);
      SA_SET_SCN_SCNLEN (secsym, size);
    }

  /* @@@@ these should be in a "stabs.h" file, or maybe as.h */
#ifndef STAB_SECTION_NAME
#define STAB_SECTION_NAME ".stab"
#endif
#ifndef STAB_STRING_SECTION_NAME
#define STAB_STRING_SECTION_NAME ".stabstr"
#endif
  if (strcmp (STAB_STRING_SECTION_NAME, sec->name))
    return;

  strsec = sec;
  sec = subseg_get (STAB_SECTION_NAME, 0);
  /* size is already rounded up, since other section will be listed first */
  size = bfd_get_section_size_before_reloc (strsec);

  n_entries = bfd_get_section_size_before_reloc (sec) / 12 - 1;

  /* Find first non-empty frag.  It should be large enough.  */
  fragp = seg_info (sec)->frchainP->frch_root;
  while (fragp && fragp->fr_fix == 0)
    fragp = fragp->fr_next;
  assert (fragp != 0 && fragp->fr_fix >= 12);

  /* Store the values.  */
  p = fragp->fr_literal;
  bfd_h_put_16 (stdoutput, n_entries, (bfd_byte *) p + 6);
  bfd_h_put_32 (stdoutput, size, (bfd_byte *) p + 8);
}

void
obj_coff_init_stab_section (seg)
     segT seg;
{
  char *file;
  char *p;
  char *stabstr_name;
  unsigned int stroff;

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  as_where (&file, (unsigned int *) NULL);
  stabstr_name = (char *) xmalloc (strlen (seg->name) + 4);
  strcpy (stabstr_name, seg->name);
  strcat (stabstr_name, "str");
  stroff = get_stab_string_offset (file, stabstr_name);
  know (stroff == 1);
  md_number_to_chars (p, stroff, 4);
}

#ifdef DEBUG
/* for debugging */
const char *
s_get_name (s)
     symbolS *s;
{
  return ((s == NULL) ? "(NULL)" : S_GET_NAME (s));
}

void
symbol_dump ()
{
  symbolS *symbolP;

  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      printf (_("0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n"),
	     (unsigned long) symbolP,
	     S_GET_NAME(symbolP),
	     (long) S_GET_DATA_TYPE(symbolP),
	     S_GET_STORAGE_CLASS(symbolP),
	     (int) S_GET_SEGMENT(symbolP));
    }
}

#endif /* DEBUG */

#else /* not BFD_ASSEMBLER */

#include "frags.h"
/* This is needed because we include internal bfd things.  */
#include <time.h>

#include "libbfd.h"
#include "libcoff.h"

#ifdef TE_PE
#include "coff/pe.h"
#endif

/* The NOP_OPCODE is for the alignment fill value.  Fill with nop so
   that we can stick sections together without causing trouble.  */
#ifndef NOP_OPCODE
#define NOP_OPCODE 0x00
#endif

/* The zeroes if symbol name is longer than 8 chars */
#define S_SET_ZEROES(s,v)		((s)->sy_symbol.ost_entry.n_zeroes = (v))

#define MIN(a,b) ((a) < (b)? (a) : (b))

/* This vector is used to turn a gas internal segment number into a
   section number suitable for insertion into a coff symbol table.
   This must correspond to seg_info_off_by_4.  */

const short seg_N_TYPE[] =
{				/* in: segT   out: N_TYPE bits */
  C_ABS_SECTION,
  1,    2,  3,   4,    5,   6,   7,   8,   9,  10,
  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,
  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,
  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
  C_UNDEF_SECTION,		/* SEG_UNKNOWN */
  C_UNDEF_SECTION,		/* SEG_GOOF */
  C_UNDEF_SECTION,		/* SEG_EXPR */
  C_DEBUG_SECTION,		/* SEG_DEBUG */
  C_NTV_SECTION,		/* SEG_NTV */
  C_PTV_SECTION,		/* SEG_PTV */
  C_REGISTER_SECTION,		/* SEG_REGISTER */
};

int function_lineoff = -1;	/* Offset in line#s where the last function
				   started (the odd entry for line #0) */

/* Structure used to keep the filenames which
   are too long around so that we can stick them
   into the string table.  */
struct filename_list
{
  char *filename;
  struct filename_list *next;
};

static struct filename_list *filename_list_head;
static struct filename_list *filename_list_tail;

static symbolS *last_line_symbol;

/* Add 4 to the real value to get the index and compensate the
   negatives. This vector is used by S_GET_SEGMENT to turn a coff
   section number into a segment number.  */

bfd *abfd;
static symbolS *previous_file_symbol;
static int line_base;

void c_symbol_merge PARAMS ((symbolS *, symbolS *));
symbolS *c_section_symbol PARAMS ((char *, int));
void obj_coff_section PARAMS ((int));
void do_relocs_for PARAMS ((bfd *, object_headers *, unsigned long *));
char * symbol_to_chars PARAMS ((bfd *, char *, symbolS *));
void w_strings PARAMS ((char *));

static void fixup_segment PARAMS ((segment_info_type *, segT));
static void fixup_mdeps PARAMS ((fragS *, object_headers *, segT));
static void fill_section PARAMS ((bfd *,  object_headers *, unsigned long *));
static int c_line_new PARAMS ((symbolS *, long, int, fragS *));
static void w_symbols PARAMS ((bfd *, char *, symbolS *));
static void adjust_stab_section PARAMS ((bfd *, segT));
static void obj_coff_lcomm PARAMS ((int));
static void obj_coff_text PARAMS ((int));
static void obj_coff_data PARAMS ((int));
static unsigned int count_entries_in_chain PARAMS ((unsigned int));
static void coff_header_append PARAMS ((bfd *, object_headers *));
static unsigned int yank_symbols PARAMS ((void));
static unsigned int glue_symbols PARAMS ((symbolS **, symbolS **));
static unsigned int tie_tags PARAMS ((void));
static void crawl_symbols PARAMS ((object_headers *, bfd *));
static void do_linenos_for PARAMS ((bfd *, object_headers *, unsigned long *));
static void remove_subsegs PARAMS ((void));



/* When not using BFD_ASSEMBLER, we permit up to 40 sections.

   This array maps a COFF section number into a gas section number.
   Because COFF uses negative section numbers, you must add 4 to the
   COFF section number when indexing into this array; this is done via
   the SEG_INFO_FROM_SECTION_NUMBER macro.  This must correspond to
   seg_N_TYPE.  */

static const segT seg_info_off_by_4[] =
{
 SEG_PTV,
 SEG_NTV,
 SEG_DEBUG,
 SEG_ABSOLUTE,
 SEG_UNKNOWN,
 SEG_E0,  SEG_E1,  SEG_E2,  SEG_E3,  SEG_E4,
 SEG_E5,  SEG_E6,  SEG_E7,  SEG_E8,  SEG_E9,
 SEG_E10, SEG_E11, SEG_E12, SEG_E13, SEG_E14,
 SEG_E15, SEG_E16, SEG_E17, SEG_E18, SEG_E19,
 SEG_E20, SEG_E21, SEG_E22, SEG_E23, SEG_E24,
 SEG_E25, SEG_E26, SEG_E27, SEG_E28, SEG_E29,
 SEG_E30, SEG_E31, SEG_E32, SEG_E33, SEG_E34,
 SEG_E35, SEG_E36, SEG_E37, SEG_E38, SEG_E39,
 (segT) 40,
 (segT) 41,
 (segT) 42,
 (segT) 43,
 (segT) 44,
 (segT) 45,
 (segT) 0,
 (segT) 0,
 (segT) 0,
 SEG_REGISTER
};

#define SEG_INFO_FROM_SECTION_NUMBER(x) (seg_info_off_by_4[(x)+4])

static relax_addressT relax_align PARAMS ((relax_addressT, long));

static relax_addressT
relax_align (address, alignment)
     relax_addressT address;
     long alignment;
{
  relax_addressT mask;
  relax_addressT new_address;

  mask = ~((~0) << alignment);
  new_address = (address + mask) & (~mask);
  return (new_address - address);
}

segT
s_get_segment (x)
     symbolS * x;
{
  return SEG_INFO_FROM_SECTION_NUMBER (x->sy_symbol.ost_entry.n_scnum);
}

static unsigned int size_section PARAMS ((bfd *, unsigned int));

/* Calculate the size of the frag chain and fill in the section header
   to contain all of it, also fill in the addr of the sections.  */

static unsigned int
size_section (abfd, idx)
     bfd *abfd ATTRIBUTE_UNUSED;
     unsigned int idx;
{

  unsigned int size = 0;
  fragS *frag = segment_info[idx].frchainP->frch_root;

  while (frag)
    {
      size = frag->fr_address;
      if (frag->fr_address != size)
	{
	  fprintf (stderr, _("Out of step\n"));
	  size = frag->fr_address;
	}

      switch (frag->fr_type)
	{
#ifdef TC_COFF_SIZEMACHDEP
	case rs_machine_dependent:
	  size += TC_COFF_SIZEMACHDEP (frag);
	  break;
#endif
	case rs_space:
	case rs_fill:
	case rs_org:
	  size += frag->fr_fix;
	  size += frag->fr_offset * frag->fr_var;
	  break;
	case rs_align:
	case rs_align_code:
	case rs_align_test:
	  {
	    addressT off;

	    size += frag->fr_fix;
	    off = relax_align (size, frag->fr_offset);
	    if (frag->fr_subtype != 0 && off > frag->fr_subtype)
	      off = 0;
	    size += off;
	  }
	  break;
	default:
	  BAD_CASE (frag->fr_type);
	  break;
	}
      frag = frag->fr_next;
    }
  segment_info[idx].scnhdr.s_size = size;
  return size;
}

static unsigned int
count_entries_in_chain (idx)
     unsigned int idx;
{
  unsigned int nrelocs;
  fixS *fixup_ptr;

  /* Count the relocations.  */
  fixup_ptr = segment_info[idx].fix_root;
  nrelocs = 0;
  while (fixup_ptr != (fixS *) NULL)
    {
      if (fixup_ptr->fx_done == 0 && TC_COUNT_RELOC (fixup_ptr))
	{
#if defined(TC_A29K) || defined(TC_OR32)
	  if (fixup_ptr->fx_r_type == RELOC_CONSTH)
	    nrelocs += 2;
	  else
	    nrelocs++;
#else
	  nrelocs++;
#endif
	}

      fixup_ptr = fixup_ptr->fx_next;
    }
  return nrelocs;
}

#ifdef TE_AUX

static int compare_external_relocs PARAMS ((const PTR, const PTR));

/* AUX's ld expects relocations to be sorted.  */

static int
compare_external_relocs (x, y)
     const PTR x;
     const PTR y;
{
  struct external_reloc *a = (struct external_reloc *) x;
  struct external_reloc *b = (struct external_reloc *) y;
  bfd_vma aadr = bfd_getb32 (a->r_vaddr);
  bfd_vma badr = bfd_getb32 (b->r_vaddr);
  return (aadr < badr ? -1 : badr < aadr ? 1 : 0);
}

#endif

/* Output all the relocations for a section.  */

void
do_relocs_for (abfd, h, file_cursor)
     bfd * abfd;
     object_headers * h;
     unsigned long *file_cursor;
{
  unsigned int nrelocs;
  unsigned int idx;
  unsigned long reloc_start = *file_cursor;

  for (idx = SEG_E0; idx < SEG_LAST; idx++)
    {
      if (segment_info[idx].scnhdr.s_name[0])
	{
	  struct external_reloc *ext_ptr;
	  struct external_reloc *external_reloc_vec;
	  unsigned int external_reloc_size;
	  unsigned int base = segment_info[idx].scnhdr.s_paddr;
	  fixS *fix_ptr = segment_info[idx].fix_root;
	  nrelocs = count_entries_in_chain (idx);

	  if (nrelocs)
	    /* Bypass this stuff if no relocs.  This also incidentally
	       avoids a SCO bug, where free(malloc(0)) tends to crash.  */
	    {
	      external_reloc_size = nrelocs * RELSZ;
	      external_reloc_vec =
		(struct external_reloc *) malloc (external_reloc_size);

	      ext_ptr = external_reloc_vec;

	      /* Fill in the internal coff style reloc struct from the
		 internal fix list.  */
	      while (fix_ptr)
		{
		  struct internal_reloc intr;

		  /* Only output some of the relocations.  */
		  if (fix_ptr->fx_done == 0 && TC_COUNT_RELOC (fix_ptr))
		    {
#ifdef TC_RELOC_MANGLE
		      TC_RELOC_MANGLE (&segment_info[idx], fix_ptr, &intr,
				       base);
#else
		      symbolS *dot;
		      symbolS *symbol_ptr = fix_ptr->fx_addsy;

		      intr.r_type = TC_COFF_FIX2RTYPE (fix_ptr);
		      intr.r_vaddr =
			base + fix_ptr->fx_frag->fr_address + fix_ptr->fx_where;

#ifdef TC_KEEP_FX_OFFSET
		      intr.r_offset = fix_ptr->fx_offset;
#else
		      intr.r_offset = 0;
#endif

		      while (symbol_ptr->sy_value.X_op == O_symbol
			     && (! S_IS_DEFINED (symbol_ptr)
				 || S_IS_COMMON (symbol_ptr)))
			{
			  symbolS *n;

			  /* We must avoid looping, as that can occur
                             with a badly written program.  */
			  n = symbol_ptr->sy_value.X_add_symbol;
			  if (n == symbol_ptr)
			    break;
			  symbol_ptr = n;
			}

		      /* Turn the segment of the symbol into an offset.  */
		      if (symbol_ptr)
			{
			  resolve_symbol_value (symbol_ptr);
			  if (! symbol_ptr->sy_resolved)
			    {
			      char *file;
			      unsigned int line;

			      if (expr_symbol_where (symbol_ptr, &file, &line))
				as_bad_where (file, line,
					      _("unresolved relocation"));
			      else
				as_bad (_("bad relocation: symbol `%s' not in symbol table"),
					S_GET_NAME (symbol_ptr));
			    }

			  dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
			  if (dot)
			    intr.r_symndx = dot->sy_number;
			  else
			    intr.r_symndx = symbol_ptr->sy_number;
			}
		      else
			intr.r_symndx = -1;
#endif
		      (void) bfd_coff_swap_reloc_out (abfd, &intr, ext_ptr);
		      ext_ptr++;
#if defined(TC_A29K)
		      /* The 29k has a special kludge for the high 16 bit
			 reloc.  Two relocations are emitted, R_IHIHALF,
			 and R_IHCONST. The second one doesn't contain a
			 symbol, but uses the value for offset.  */
		      if (intr.r_type == R_IHIHALF)
			{
			  /* Now emit the second bit.  */
			  intr.r_type = R_IHCONST;
			  intr.r_symndx = fix_ptr->fx_addnumber;
			  (void) bfd_coff_swap_reloc_out (abfd, &intr, ext_ptr);
			  ext_ptr++;
			}
#endif
#if defined(TC_OR32)
		      /* The or32 has a special kludge for the high 16 bit
			 reloc.  Two relocations are emitted, R_IHIHALF,
			 and R_IHCONST. The second one doesn't contain a
			 symbol, but uses the value for offset.  */
		      if (intr.r_type == R_IHIHALF)
			{
			  /* Now emit the second bit.  */
			  intr.r_type = R_IHCONST;
			  intr.r_symndx = fix_ptr->fx_addnumber;
			  (void) bfd_coff_swap_reloc_out (abfd, & intr, ext_ptr);
			  ext_ptr ++;
			}
#endif
		    }

		  fix_ptr = fix_ptr->fx_next;
		}
#ifdef TE_AUX
	      /* Sort the reloc table.  */
	      qsort ((PTR) external_reloc_vec, nrelocs,
		     sizeof (struct external_reloc), compare_external_relocs);
#endif
	      /* Write out the reloc table.  */
	      bfd_bwrite ((PTR) external_reloc_vec,
			  (bfd_size_type) external_reloc_size, abfd);
	      free (external_reloc_vec);

	      /* Fill in section header info.  */
	      segment_info[idx].scnhdr.s_relptr = *file_cursor;
	      *file_cursor += external_reloc_size;
	      segment_info[idx].scnhdr.s_nreloc = nrelocs;
	    }
	  else
	    {
	      /* No relocs.  */
	      segment_info[idx].scnhdr.s_relptr = 0;
	    }
	}
    }

  /* Set relocation_size field in file headers.  */
  H_SET_RELOCATION_SIZE (h, *file_cursor - reloc_start, 0);
}

/* Run through a frag chain and write out the data to go with it, fill
   in the scnhdrs with the info on the file positions.  */

static void
fill_section (abfd, h, file_cursor)
     bfd * abfd;
     object_headers *h ATTRIBUTE_UNUSED;
     unsigned long *file_cursor;
{
  unsigned int i;
  unsigned int paddr = 0;

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      unsigned int offset = 0;
      struct internal_scnhdr *s = &(segment_info[i].scnhdr);

      PROGRESS (1);

      if (s->s_name[0])
	{
	  fragS *frag = segment_info[i].frchainP->frch_root;
	  char *buffer = NULL;

	  if (s->s_size == 0)
	    s->s_scnptr = 0;
	  else
	    {
	      buffer = xmalloc (s->s_size);
	      s->s_scnptr = *file_cursor;
	    }
	  know (s->s_paddr == paddr);

	  if (strcmp (s->s_name, ".text") == 0)
	    s->s_flags |= STYP_TEXT;
	  else if (strcmp (s->s_name, ".data") == 0)
	    s->s_flags |= STYP_DATA;
	  else if (strcmp (s->s_name, ".bss") == 0)
	    {
	      s->s_scnptr = 0;
	      s->s_flags |= STYP_BSS;

	      /* @@@@ Should make the i386 and a29k coff targets define
		 COFF_NOLOAD_PROBLEM, and have only one test here.  */
#ifndef TC_I386
#ifndef TC_A29K
#ifndef TC_OR32
#ifndef COFF_NOLOAD_PROBLEM
	      /* Apparently the SVR3 linker (and exec syscall) and UDI
		 mondfe progrem are confused by noload sections.  */
	      s->s_flags |= STYP_NOLOAD;
#endif
#endif
#endif
#endif
	    }
	  else if (strcmp (s->s_name, ".lit") == 0)
	    s->s_flags = STYP_LIT | STYP_TEXT;
	  else if (strcmp (s->s_name, ".init") == 0)
	    s->s_flags |= STYP_TEXT;
	  else if (strcmp (s->s_name, ".fini") == 0)
	    s->s_flags |= STYP_TEXT;
	  else if (strncmp (s->s_name, ".comment", 8) == 0)
	    s->s_flags |= STYP_INFO;

	  while (frag)
	    {
	      unsigned int fill_size;
	      switch (frag->fr_type)
		{
		case rs_machine_dependent:
		  if (frag->fr_fix)
		    {
		      memcpy (buffer + frag->fr_address,
			      frag->fr_literal,
			      (unsigned int) frag->fr_fix);
		      offset += frag->fr_fix;
		    }

		  break;
		case rs_space:
		case rs_fill:
		case rs_align:
		case rs_align_code:
		case rs_align_test:
		case rs_org:
		  if (frag->fr_fix)
		    {
		      memcpy (buffer + frag->fr_address,
			      frag->fr_literal,
			      (unsigned int) frag->fr_fix);
		      offset += frag->fr_fix;
		    }

		  fill_size = frag->fr_var;
		  if (fill_size && frag->fr_offset > 0)
		    {
		      unsigned int count;
		      unsigned int off = frag->fr_fix;
		      for (count = frag->fr_offset; count; count--)
			{
			  if (fill_size + frag->fr_address + off <= s->s_size)
			    {
			      memcpy (buffer + frag->fr_address + off,
				      frag->fr_literal + frag->fr_fix,
				      fill_size);
			      off += fill_size;
			      offset += fill_size;
			    }
			}
		    }
		  break;
		case rs_broken_word:
		  break;
		default:
		  abort ();
		}
	      frag = frag->fr_next;
	    }

	  if (s->s_size != 0)
	    {
	      if (s->s_scnptr != 0)
		{
		  bfd_bwrite (buffer, s->s_size, abfd);
		  *file_cursor += s->s_size;
		}
	      free (buffer);
	    }
	  paddr += s->s_size;
	}
    }
}

/* Coff file generation & utilities.  */

static void
coff_header_append (abfd, h)
     bfd * abfd;
     object_headers * h;
{
  unsigned int i;
  char buffer[1000];
  char buffero[1000];
#ifdef COFF_LONG_SECTION_NAMES
  unsigned long string_size = 4;
#endif

  bfd_seek (abfd, (file_ptr) 0, 0);

#ifndef OBJ_COFF_OMIT_OPTIONAL_HEADER
  H_SET_MAGIC_NUMBER (h, COFF_MAGIC);
  H_SET_VERSION_STAMP (h, 0);
  H_SET_ENTRY_POINT (h, 0);
  H_SET_TEXT_START (h, segment_info[SEG_E0].frchainP->frch_root->fr_address);
  H_SET_DATA_START (h, segment_info[SEG_E1].frchainP->frch_root->fr_address);
  H_SET_SIZEOF_OPTIONAL_HEADER (h, bfd_coff_swap_aouthdr_out(abfd, &h->aouthdr,
							     buffero));
#else /* defined (OBJ_COFF_OMIT_OPTIONAL_HEADER) */
  H_SET_SIZEOF_OPTIONAL_HEADER (h, 0);
#endif /* defined (OBJ_COFF_OMIT_OPTIONAL_HEADER) */

  i = bfd_coff_swap_filehdr_out (abfd, &h->filehdr, buffer);

  bfd_bwrite (buffer, (bfd_size_type) i, abfd);
  bfd_bwrite (buffero, (bfd_size_type) H_GET_SIZEOF_OPTIONAL_HEADER (h), abfd);

  for (i = SEG_E0; i < SEG_LAST; i++)
    {
      if (segment_info[i].scnhdr.s_name[0])
	{
	  unsigned int size;

#ifdef COFF_LONG_SECTION_NAMES
	  /* Support long section names as found in PE.  This code
             must coordinate with that in write_object_file and
             w_strings.  */
	  if (strlen (segment_info[i].name) > SCNNMLEN)
	    {
	      memset (segment_info[i].scnhdr.s_name, 0, SCNNMLEN);
	      sprintf (segment_info[i].scnhdr.s_name, "/%lu", string_size);
	      string_size += strlen (segment_info[i].name) + 1;
	    }
#endif
	  size = bfd_coff_swap_scnhdr_out (abfd,
					   &(segment_info[i].scnhdr),
					   buffer);
	  if (size == 0)
	    as_bad (_("bfd_coff_swap_scnhdr_out failed"));
	  bfd_bwrite (buffer, (bfd_size_type) size, abfd);
	}
    }
}

char *
symbol_to_chars (abfd, where, symbolP)
     bfd * abfd;
     char *where;
     symbolS * symbolP;
{
  unsigned int numaux = symbolP->sy_symbol.ost_entry.n_numaux;
  unsigned int i;
  valueT val;

  /* Turn any symbols with register attributes into abs symbols.  */
  if (S_GET_SEGMENT (symbolP) == reg_section)
    S_SET_SEGMENT (symbolP, absolute_section);

  /* At the same time, relocate all symbols to their output value.  */
#ifndef TE_PE
  val = (segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_paddr
	 + S_GET_VALUE (symbolP));
#else
  val = S_GET_VALUE (symbolP);
#endif

  S_SET_VALUE (symbolP, val);

  symbolP->sy_symbol.ost_entry.n_value = val;

  where += bfd_coff_swap_sym_out (abfd, &symbolP->sy_symbol.ost_entry,
				  where);

  for (i = 0; i < numaux; i++)
    {
      where += bfd_coff_swap_aux_out (abfd,
				      &symbolP->sy_symbol.ost_auxent[i],
				      S_GET_DATA_TYPE (symbolP),
				      S_GET_STORAGE_CLASS (symbolP),
				      i, numaux, where);
    }

  return where;
}

void
coff_obj_symbol_new_hook (symbolP)
     symbolS *symbolP;
{
  char underscore = 0;		/* Symbol has leading _  */

  /* Effective symbol.  */
  /* Store the pointer in the offset.  */
  S_SET_ZEROES (symbolP, 0L);
  S_SET_DATA_TYPE (symbolP, T_NULL);
  S_SET_STORAGE_CLASS (symbolP, 0);
  S_SET_NUMBER_AUXILIARY (symbolP, 0);
  /* Additional information.  */
  symbolP->sy_symbol.ost_flags = 0;
  /* Auxiliary entries.  */
  memset ((char *) &symbolP->sy_symbol.ost_auxent[0], 0, AUXESZ);

  if (S_IS_STRING (symbolP))
    SF_SET_STRING (symbolP);
  if (!underscore && S_IS_LOCAL (symbolP))
    SF_SET_LOCAL (symbolP);
}

/* Handle .ln directives.  */

static void
obj_coff_ln (appline)
     int appline;
{
  int l;

  if (! appline && def_symbol_in_progress != NULL)
    {
      /* Wrong context.  */
      as_warn (_(".ln pseudo-op inside .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  l = get_absolute_expression ();
  c_line_new (0, frag_now_fix (), l, frag_now);

  if (appline)
    new_logical_line ((char *) NULL, l - 1);

#ifndef NO_LISTING
  {
    extern int listing;

    if (listing)
      {
	if (! appline)
	  l += line_base - 1;
	listing_source_line ((unsigned int) l);
      }

  }
#endif
  demand_empty_rest_of_line ();
}

/* Handle .def directives.
 
  One might ask : why can't we symbol_new if the symbol does not
  already exist and fill it with debug information.  Because of
  the C_EFCN special symbol. It would clobber the value of the
  function symbol before we have a chance to notice that it is
  a C_EFCN. And a second reason is that the code is more clear this
  way. (at least I think it is :-).  */

#define SKIP_SEMI_COLON()	while (*input_line_pointer++ != ';')
#define SKIP_WHITESPACES()	while (*input_line_pointer == ' ' || \
				      *input_line_pointer == '\t') \
                                         input_line_pointer++;

static void
obj_coff_def (what)
     int what ATTRIBUTE_UNUSED;
{
  char name_end;		/* Char after the end of name.  */
  char *symbol_name;		/* Name of the debug symbol.  */
  char *symbol_name_copy;	/* Temporary copy of the name.  */
  unsigned int symbol_name_length;

  if (def_symbol_in_progress != NULL)
    {
      as_warn (_(".def pseudo-op used inside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  SKIP_WHITESPACES ();

  def_symbol_in_progress = (symbolS *) obstack_alloc (&notes, sizeof (*def_symbol_in_progress));
  memset (def_symbol_in_progress, 0, sizeof (*def_symbol_in_progress));

  symbol_name = input_line_pointer;
  name_end = get_symbol_end ();
  symbol_name_length = strlen (symbol_name);
  symbol_name_copy = xmalloc (symbol_name_length + 1);
  strcpy (symbol_name_copy, symbol_name);
#ifdef tc_canonicalize_symbol_name
  symbol_name_copy = tc_canonicalize_symbol_name (symbol_name_copy);
#endif

  /* Initialize the new symbol.  */
#ifdef STRIP_UNDERSCORE
  S_SET_NAME (def_symbol_in_progress, (*symbol_name_copy == '_'
				       ? symbol_name_copy + 1
				       : symbol_name_copy));
#else /* STRIP_UNDERSCORE */
  S_SET_NAME (def_symbol_in_progress, symbol_name_copy);
#endif /* STRIP_UNDERSCORE */
  /* free(symbol_name_copy); */
  def_symbol_in_progress->sy_name_offset = (unsigned long) ~0;
  def_symbol_in_progress->sy_number = ~0;
  def_symbol_in_progress->sy_frag = &zero_address_frag;
  S_SET_VALUE (def_symbol_in_progress, 0);

  if (S_IS_STRING (def_symbol_in_progress))
    SF_SET_STRING (def_symbol_in_progress);

  *input_line_pointer = name_end;

  demand_empty_rest_of_line ();
}

unsigned int dim_index;

static void
obj_coff_endef (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *symbolP = 0;
  /* DIM BUG FIX sac@@cygnus.com */
  dim_index = 0;
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".endef pseudo-op used outside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  /* Set the section number according to storage class.  */
  switch (S_GET_STORAGE_CLASS (def_symbol_in_progress))
    {
    case C_STRTAG:
    case C_ENTAG:
    case C_UNTAG:
      SF_SET_TAG (def_symbol_in_progress);
      /* Intentional fallthrough.  */

    case C_FILE:
    case C_TPDEF:
      SF_SET_DEBUG (def_symbol_in_progress);
      S_SET_SEGMENT (def_symbol_in_progress, SEG_DEBUG);
      break;

    case C_EFCN:
      /* Do not emit this symbol.  */
      SF_SET_LOCAL (def_symbol_in_progress);
      /* Intentional fallthrough. */
      
    case C_BLOCK:
      /* Will need processing before writing.  */
      SF_SET_PROCESS (def_symbol_in_progress);
      /* Intentional fallthrough.  */

    case C_FCN:
      S_SET_SEGMENT (def_symbol_in_progress, SEG_E0);

      if (strcmp (S_GET_NAME (def_symbol_in_progress), ".bf") == 0)
	{			/* .bf */
	  if (function_lineoff < 0)
	    fprintf (stderr, _("`.bf' symbol without preceding function\n"));

	  SA_GET_SYM_LNNOPTR (last_line_symbol) = function_lineoff;

	  SF_SET_PROCESS (last_line_symbol);
	  SF_SET_ADJ_LNNOPTR (last_line_symbol);
	  SF_SET_PROCESS (def_symbol_in_progress);
	  function_lineoff = -1;
	}

      /* Value is always set to .  */
      def_symbol_in_progress->sy_frag = frag_now;
      S_SET_VALUE (def_symbol_in_progress, (valueT) frag_now_fix ());
      break;

#ifdef C_AUTOARG
    case C_AUTOARG:
#endif /* C_AUTOARG */
    case C_AUTO:
    case C_REG:
    case C_MOS:
    case C_MOE:
    case C_MOU:
    case C_ARG:
    case C_REGPARM:
    case C_FIELD:
    case C_EOS:
      SF_SET_DEBUG (def_symbol_in_progress);
      S_SET_SEGMENT (def_symbol_in_progress, absolute_section);
      break;

    case C_EXT:
    case C_WEAKEXT:
#ifdef TE_PE
    case C_NT_WEAK:
#endif
    case C_STAT:
    case C_LABEL:
      /* Valid but set somewhere else (s_comm, s_lcomm, colon).  */
      break;

    case C_USTATIC:
    case C_EXTDEF:
    case C_ULABEL:
      as_warn (_("unexpected storage class %d"), S_GET_STORAGE_CLASS (def_symbol_in_progress));
      break;
    }

  /* Now that we have built a debug symbol, try to find if we should
     merge with an existing symbol or not.  If a symbol is C_EFCN or
     absolute_section or untagged SEG_DEBUG it never merges.  We also
     don't merge labels, which are in a different namespace, nor
     symbols which have not yet been defined since they are typically
     unique, nor do we merge tags with non-tags.  */

  /* Two cases for functions.  Either debug followed by definition or
     definition followed by debug.  For definition first, we will
     merge the debug symbol into the definition.  For debug first, the
     lineno entry MUST point to the definition function or else it
     will point off into space when crawl_symbols() merges the debug
     symbol into the real symbol.  Therefor, let's presume the debug
     symbol is a real function reference.  */

  /* FIXME-SOON If for some reason the definition label/symbol is
     never seen, this will probably leave an undefined symbol at link
     time.  */

  if (S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_EFCN
      || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_LABEL
      || (S_GET_SEGMENT (def_symbol_in_progress) == SEG_DEBUG
	  && !SF_GET_TAG (def_symbol_in_progress))
      || S_GET_SEGMENT (def_symbol_in_progress) == absolute_section
      || def_symbol_in_progress->sy_value.X_op != O_constant
      || (symbolP = symbol_find_base (S_GET_NAME (def_symbol_in_progress), DO_NOT_STRIP)) == NULL
      || (SF_GET_TAG (def_symbol_in_progress) != SF_GET_TAG (symbolP)))
    {
      symbol_append (def_symbol_in_progress, symbol_lastP, &symbol_rootP,
		     &symbol_lastP);
    }
  else
    {
      /* This symbol already exists, merge the newly created symbol
	 into the old one.  This is not mandatory. The linker can
	 handle duplicate symbols correctly. But I guess that it save
	 a *lot* of space if the assembly file defines a lot of
	 symbols. [loic] */

      /* The debug entry (def_symbol_in_progress) is merged into the
	 previous definition.  */

      c_symbol_merge (def_symbol_in_progress, symbolP);
      /* FIXME-SOON Should *def_symbol_in_progress be free'd? xoxorich.  */
      def_symbol_in_progress = symbolP;

      if (SF_GET_FUNCTION (def_symbol_in_progress)
	  || SF_GET_TAG (def_symbol_in_progress)
	  || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_STAT)
	{
	  /* For functions, and tags, and static symbols, the symbol
	     *must* be where the debug symbol appears.  Move the
	     existing symbol to the current place.  */
	  /* If it already is at the end of the symbol list, do nothing.  */
	  if (def_symbol_in_progress != symbol_lastP)
	    {
	      symbol_remove (def_symbol_in_progress, &symbol_rootP,
			     &symbol_lastP);
	      symbol_append (def_symbol_in_progress, symbol_lastP,
			     &symbol_rootP, &symbol_lastP);
	    }
	}
    }

  if (SF_GET_TAG (def_symbol_in_progress))
    {
      symbolS *oldtag;

      oldtag = symbol_find_base (S_GET_NAME (def_symbol_in_progress),
				 DO_NOT_STRIP);
      if (oldtag == NULL || ! SF_GET_TAG (oldtag))
	tag_insert (S_GET_NAME (def_symbol_in_progress),
		    def_symbol_in_progress);
    }

  if (SF_GET_FUNCTION (def_symbol_in_progress))
    {
      know (sizeof (def_symbol_in_progress) <= sizeof (long));
      function_lineoff
	= c_line_new (def_symbol_in_progress, 0, 0, &zero_address_frag);

      SF_SET_PROCESS (def_symbol_in_progress);

      if (symbolP == NULL)
	{
	  /* That is, if this is the first time we've seen the
	     function...  */
	  symbol_table_insert (def_symbol_in_progress);
	}
    }

  def_symbol_in_progress = NULL;
  demand_empty_rest_of_line ();
}

static void
obj_coff_dim (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int dim_index;

  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".dim pseudo-op used outside of .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);

  for (dim_index = 0; dim_index < DIMNUM; dim_index++)
    {
      SKIP_WHITESPACES ();
      SA_SET_SYM_DIMEN (def_symbol_in_progress, dim_index,
			get_absolute_expression ());

      switch (*input_line_pointer)
	{
	case ',':
	  input_line_pointer++;
	  break;

	default:
	  as_warn (_("badly formed .dim directive ignored"));
	  /* Intentional fallthrough.  */

	case '\n':
	case ';':
	  dim_index = DIMNUM;
	  break;
	}
    }

  demand_empty_rest_of_line ();
}

static void
obj_coff_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int this_base;
  const char *name;

  if (def_symbol_in_progress == NULL)
    {
      obj_coff_ln (0);
      return;
    }

  name = S_GET_NAME (def_symbol_in_progress);
  this_base = get_absolute_expression ();

  /* Only .bf symbols indicate the use of a new base line number; the
     line numbers associated with .ef, .bb, .eb are relative to the
     start of the containing function.  */
  if (!strcmp (".bf", name))
    {
#if 0 /* XXX Can we ever have line numbers going backwards?  */
      if (this_base > line_base)
#endif
	line_base = this_base;

#ifndef NO_LISTING
      {
	extern int listing;
	if (listing)
	  listing_source_line ((unsigned int) line_base);
      }
#endif
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  SA_SET_SYM_LNNO (def_symbol_in_progress, this_base);

  demand_empty_rest_of_line ();
}

static void
obj_coff_size (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".size pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  SA_SET_SYM_SIZE (def_symbol_in_progress, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
obj_coff_scl (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".scl pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_STORAGE_CLASS (def_symbol_in_progress, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
obj_coff_tag (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *symbol_name;
  char name_end;

  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".tag pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_NUMBER_AUXILIARY (def_symbol_in_progress, 1);
  symbol_name = input_line_pointer;
  name_end = get_symbol_end ();
#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif

  /* Assume that the symbol referred to by .tag is always defined.
     This was a bad assumption.  I've added find_or_make. xoxorich.  */
  SA_SET_SYM_TAGNDX (def_symbol_in_progress,
		     (long) tag_find_or_make (symbol_name));
  if (SA_GET_SYM_TAGNDX (def_symbol_in_progress) == 0L)
    as_warn (_("tag not found for .tag %s"), symbol_name);

  SF_SET_TAGGED (def_symbol_in_progress);
  *input_line_pointer = name_end;

  demand_empty_rest_of_line ();
}

static void
obj_coff_type (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".type pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  S_SET_DATA_TYPE (def_symbol_in_progress, get_absolute_expression ());

  if (ISFCN (S_GET_DATA_TYPE (def_symbol_in_progress)) &&
      S_GET_STORAGE_CLASS (def_symbol_in_progress) != C_TPDEF)
    SF_SET_FUNCTION (def_symbol_in_progress);

  demand_empty_rest_of_line ();
}

static void
obj_coff_val (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (def_symbol_in_progress == NULL)
    {
      as_warn (_(".val pseudo-op used outside of .def/.endef ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  if (is_name_beginner (*input_line_pointer))
    {
      char *symbol_name = input_line_pointer;
      char name_end = get_symbol_end ();

#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif

      if (!strcmp (symbol_name, "."))
	{
	  def_symbol_in_progress->sy_frag = frag_now;
	  S_SET_VALUE (def_symbol_in_progress, (valueT) frag_now_fix ());
	  /* If the .val is != from the .def (e.g. statics).  */
	}
      else if (strcmp (S_GET_NAME (def_symbol_in_progress), symbol_name))
	{
	  def_symbol_in_progress->sy_value.X_op = O_symbol;
	  def_symbol_in_progress->sy_value.X_add_symbol =
	    symbol_find_or_make (symbol_name);
	  def_symbol_in_progress->sy_value.X_op_symbol = NULL;
	  def_symbol_in_progress->sy_value.X_add_number = 0;

	  /* If the segment is undefined when the forward reference is
	     resolved, then copy the segment id from the forward
	     symbol.  */
	  SF_SET_GET_SEGMENT (def_symbol_in_progress);

	  /* FIXME: gcc can generate address expressions here in
	     unusual cases (search for "obscure" in sdbout.c).  We
	     just ignore the offset here, thus generating incorrect
	     debugging information.  We ignore the rest of the line
	     just below.  */
	}
      /* Otherwise, it is the name of a non debug symbol and
	 its value will be calculated later.  */
      *input_line_pointer = name_end;

      /* FIXME: this is to avoid an error message in the
	 FIXME case mentioned just above.  */
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }
  else
    {
      S_SET_VALUE (def_symbol_in_progress,
		   (valueT) get_absolute_expression ());
    }				/* if symbol based */

  demand_empty_rest_of_line ();
}

#ifdef TE_PE

/* Handle the .linkonce pseudo-op.  This is parsed by s_linkonce in
   read.c, which then calls this object file format specific routine.  */

void
obj_coff_pe_handle_link_once (type)
     enum linkonce_type type;
{
  seg_info (now_seg)->scnhdr.s_flags |= IMAGE_SCN_LNK_COMDAT;

  /* We store the type in the seg_info structure, and use it to set up
     the auxiliary entry for the section symbol in c_section_symbol.  */
  seg_info (now_seg)->linkonce = type;
}

#endif /* TE_PE */

void
coff_obj_read_begin_hook ()
{
  /* These had better be the same.  Usually 18 bytes.  */
#ifndef BFD_HEADERS
  know (sizeof (SYMENT) == sizeof (AUXENT));
  know (SYMESZ == AUXESZ);
#endif
  tag_init ();
}

/* This function runs through the symbol table and puts all the
   externals onto another chain.  */

/* The chain of globals.  */
symbolS *symbol_globalP;
symbolS *symbol_global_lastP;

/* The chain of externals.  */
symbolS *symbol_externP;
symbolS *symbol_extern_lastP;

stack *block_stack;
symbolS *last_functionP;
static symbolS *last_bfP;
symbolS *last_tagP;

static unsigned int
yank_symbols ()
{
  symbolS *symbolP;
  unsigned int symbol_number = 0;
  unsigned int last_file_symno = 0;

  struct filename_list *filename_list_scan = filename_list_head;

  for (symbolP = symbol_rootP;
       symbolP;
       symbolP = symbolP ? symbol_next (symbolP) : symbol_rootP)
    {
      if (symbolP->sy_mri_common)
	{
	  if (S_GET_STORAGE_CLASS (symbolP) == C_EXT
#ifdef TE_PE
	      || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK
#endif
	      || S_GET_STORAGE_CLASS (symbolP) == C_WEAKEXT)
	    as_bad (_("%s: global symbols not supported in common sections"),
		    S_GET_NAME (symbolP));
	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	  continue;
	}

      if (!SF_GET_DEBUG (symbolP))
	{
	  /* Debug symbols do not need all this rubbish.  */
	  symbolS *real_symbolP;

	  /* L* and C_EFCN symbols never merge.  */
	  if (!SF_GET_LOCAL (symbolP)
	      && !SF_GET_STATICS (symbolP)
	      && S_GET_STORAGE_CLASS (symbolP) != C_LABEL
	      && symbolP->sy_value.X_op == O_constant
	      && (real_symbolP = symbol_find_base (S_GET_NAME (symbolP), DO_NOT_STRIP))
	      && real_symbolP != symbolP)
	    {
	      /* FIXME-SOON: where do dups come from?
		 Maybe tag references before definitions? xoxorich.  */
	      /* Move the debug data from the debug symbol to the
		 real symbol. Do NOT do the opposite (i.e. move from
		 real symbol to debug symbol and remove real symbol from the
		 list.) Because some pointers refer to the real symbol
		 whereas no pointers refer to the debug symbol.  */
	      c_symbol_merge (symbolP, real_symbolP);
	      /* Replace the current symbol by the real one.  */
	      /* The symbols will never be the last or the first
		 because : 1st symbol is .file and 3 last symbols are
		 .text, .data, .bss.  */
	      symbol_remove (real_symbolP, &symbol_rootP, &symbol_lastP);
	      symbol_insert (real_symbolP, symbolP, &symbol_rootP, &symbol_lastP);
	      symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	      symbolP = real_symbolP;
	    }

	  if (flag_readonly_data_in_text && (S_GET_SEGMENT (symbolP) == SEG_E1))
	    S_SET_SEGMENT (symbolP, SEG_E0);

	  resolve_symbol_value (symbolP);

	  if (S_GET_STORAGE_CLASS (symbolP) == C_NULL)
	    {
	      if (!S_IS_DEFINED (symbolP) && !SF_GET_LOCAL (symbolP))
		{
		  S_SET_EXTERNAL (symbolP);
		}

	      else if (S_GET_SEGMENT (symbolP) == SEG_E0)
		S_SET_STORAGE_CLASS (symbolP, C_LABEL);

	      else
		S_SET_STORAGE_CLASS (symbolP, C_STAT);
	    }

	  /* Mainly to speed up if not -g.  */
	  if (SF_GET_PROCESS (symbolP))
	    {
	      /* Handle the nested blocks auxiliary info.  */
	      if (S_GET_STORAGE_CLASS (symbolP) == C_BLOCK)
		{
		  if (!strcmp (S_GET_NAME (symbolP), ".bb"))
		    stack_push (block_stack, (char *) &symbolP);
		  else
		    {
		      /* .eb */
		      symbolS *begin_symbolP;

		      begin_symbolP = *(symbolS **) stack_pop (block_stack);
		      if (begin_symbolP == (symbolS *) 0)
			as_warn (_("mismatched .eb"));
		      else
			SA_SET_SYM_ENDNDX (begin_symbolP, symbol_number + 2);
		    }
		}
	      /* If we are able to identify the type of a function, and we
	       are out of a function (last_functionP == 0) then, the
	       function symbol will be associated with an auxiliary
	       entry.  */
	      if (last_functionP == (symbolS *) 0 &&
		  SF_GET_FUNCTION (symbolP))
		{
		  last_functionP = symbolP;

		  if (S_GET_NUMBER_AUXILIARY (symbolP) < 1)
		    S_SET_NUMBER_AUXILIARY (symbolP, 1);

		  /* Clobber possible stale .dim information.  */
#if 0
		  /* Iffed out by steve - this fries the lnnoptr info too.  */
		  bzero (symbolP->sy_symbol.ost_auxent[0].x_sym.x_fcnary.x_ary.x_dimen,
			 sizeof (symbolP->sy_symbol.ost_auxent[0].x_sym.x_fcnary.x_ary.x_dimen));
#endif
		}
	      if (S_GET_STORAGE_CLASS (symbolP) == C_FCN)
		{
		  if (strcmp (S_GET_NAME (symbolP), ".bf") == 0)
		    {
		      if (last_bfP != NULL)
			SA_SET_SYM_ENDNDX (last_bfP, symbol_number);
		      last_bfP = symbolP;
		    }
		}
	      else if (S_GET_STORAGE_CLASS (symbolP) == C_EFCN)
		{
		  /* I don't even know if this is needed for sdb. But
		     the standard assembler generates it, so...  */
		  if (last_functionP == (symbolS *) 0)
		    as_fatal (_("C_EFCN symbol out of scope"));
		  SA_SET_SYM_FSIZE (last_functionP,
				    (long) (S_GET_VALUE (symbolP) -
					    S_GET_VALUE (last_functionP)));
		  SA_SET_SYM_ENDNDX (last_functionP, symbol_number);
		 last_functionP = (symbolS *) 0;
		}
	    }
	}
      else if (SF_GET_TAG (symbolP))
	{
	  /* First descriptor of a structure must point to
	     the first slot after the structure description.  */
	  last_tagP = symbolP;

	}
      else if (S_GET_STORAGE_CLASS (symbolP) == C_EOS)
	{
	  /* +2 take in account the current symbol.  */
	  SA_SET_SYM_ENDNDX (last_tagP, symbol_number + 2);
	}
      else if (S_GET_STORAGE_CLASS (symbolP) == C_FILE)
	{
	  /* If the filename was too long to fit in the
	     auxent, put it in the string table.  */
	  if (SA_GET_FILE_FNAME_ZEROS (symbolP) == 0
	      && SA_GET_FILE_FNAME_OFFSET (symbolP) != 0)
	    {
	      SA_SET_FILE_FNAME_OFFSET (symbolP, string_byte_count);
	      string_byte_count += strlen (filename_list_scan->filename) + 1;
	      filename_list_scan = filename_list_scan->next;
	    }
	  if (S_GET_VALUE (symbolP))
	    {
	      S_SET_VALUE (symbolP, last_file_symno);
	      last_file_symno = symbol_number;
	    }
	}

#ifdef tc_frob_coff_symbol
      tc_frob_coff_symbol (symbolP);
#endif

      /* We must put the external symbols apart. The loader
	 does not bomb if we do not. But the references in
	 the endndx field for a .bb symbol are not corrected
	 if an external symbol is removed between .bb and .be.
	 I.e in the following case :
	 [20] .bb endndx = 22
	 [21] foo external
	 [22] .be
	 ld will move the symbol 21 to the end of the list but
	 endndx will still be 22 instead of 21.  */

      if (SF_GET_LOCAL (symbolP))
	{
	  /* Remove C_EFCN and LOCAL (L...) symbols.  */
	  /* Next pointer remains valid.  */
	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);

	}
      else if (symbolP->sy_value.X_op == O_symbol
	       && (! S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP)))
	{
	  /* Skip symbols which were equated to undefined or common
	     symbols.  */
	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	}
      else if (!S_IS_DEFINED (symbolP)
	       && !S_IS_DEBUG (symbolP)
	       && !SF_GET_STATICS (symbolP)
	       && (S_GET_STORAGE_CLASS (symbolP) == C_EXT
#ifdef TE_PE
		   || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK
#endif
		   || S_GET_STORAGE_CLASS (symbolP) == C_WEAKEXT))
	{
	  /* If external, Remove from the list.  */
	  symbolS *hold = symbol_previous (symbolP);

	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	  symbol_clear_list_pointers (symbolP);
	  symbol_append (symbolP, symbol_extern_lastP, &symbol_externP, &symbol_extern_lastP);
	  symbolP = hold;
	}
      else if (! S_IS_DEBUG (symbolP)
	       && ! SF_GET_STATICS (symbolP)
	       && ! SF_GET_FUNCTION (symbolP)
	       && (S_GET_STORAGE_CLASS (symbolP) == C_EXT
#ifdef TE_PE
		   || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK
#endif
		   || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK))
	{
	  symbolS *hold = symbol_previous (symbolP);

	  /* The O'Reilly COFF book says that defined global symbols
             come at the end of the symbol table, just before
             undefined global symbols.  */
	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	  symbol_clear_list_pointers (symbolP);
	  symbol_append (symbolP, symbol_global_lastP, &symbol_globalP,
			 &symbol_global_lastP);
	  symbolP = hold;
	}
      else
	{
	  if (SF_GET_STRING (symbolP))
	    {
	      symbolP->sy_name_offset = string_byte_count;
	      string_byte_count += strlen (S_GET_NAME (symbolP)) + 1;
	    }
	  else
	    {
	      symbolP->sy_name_offset = 0;
	    }

	  symbolP->sy_number = symbol_number;
	  symbol_number += 1 + S_GET_NUMBER_AUXILIARY (symbolP);
	}
    }

  return symbol_number;
}

static unsigned int
glue_symbols (head, tail)
     symbolS **head;
     symbolS **tail;
{
  unsigned int symbol_number = 0;

  while (*head != NULL)
    {
      symbolS *tmp = *head;

      /* Append.  */
      symbol_remove (tmp, head, tail);
      symbol_append (tmp, symbol_lastP, &symbol_rootP, &symbol_lastP);

      /* Process.  */
      if (SF_GET_STRING (tmp))
	{
	  tmp->sy_name_offset = string_byte_count;
	  string_byte_count += strlen (S_GET_NAME (tmp)) + 1;
	}
      else
	{
	  /* Fix "long" names.  */
	  tmp->sy_name_offset = 0;
	}

      tmp->sy_number = symbol_number;
      symbol_number += 1 + S_GET_NUMBER_AUXILIARY (tmp);
    }

  return symbol_number;
}

static unsigned int
tie_tags ()
{
  unsigned int symbol_number = 0;
  symbolS *symbolP;

  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      symbolP->sy_number = symbol_number;

      if (SF_GET_TAGGED (symbolP))
	{
	  SA_SET_SYM_TAGNDX
	    (symbolP,
	     ((symbolS *) SA_GET_SYM_TAGNDX (symbolP))->sy_number);
	}

      symbol_number += 1 + S_GET_NUMBER_AUXILIARY (symbolP);
    }

  return symbol_number;
}


static void
crawl_symbols (h, abfd)
     object_headers *h;
     bfd *abfd ATTRIBUTE_UNUSED;
{
  unsigned int i;

  /* Initialize the stack used to keep track of the matching .bb .be.  */

  block_stack = stack_init (512, sizeof (symbolS *));

  /* The symbol list should be ordered according to the following sequence
     order :
     . .file symbol
     . debug entries for functions
     . fake symbols for the sections, including .text .data and .bss
     . defined symbols
     . undefined symbols
     But this is not mandatory. The only important point is to put the
     undefined symbols at the end of the list.  */

  /* Is there a .file symbol ? If not insert one at the beginning.  */
  if (symbol_rootP == NULL
      || S_GET_STORAGE_CLASS (symbol_rootP) != C_FILE)
    c_dot_file_symbol ("fake");

  /* Build up static symbols for the sections, they are filled in later.  */

  for (i = SEG_E0; i < SEG_LAST; i++)
    if (segment_info[i].scnhdr.s_name[0])
      segment_info[i].dot = c_section_symbol ((char *) segment_info[i].name,
					      i - SEG_E0 + 1);

  /* Take all the externals out and put them into another chain.  */
  H_SET_SYMBOL_TABLE_SIZE (h, yank_symbols ());
  /* Take the externals and glue them onto the end.  */
  H_SET_SYMBOL_TABLE_SIZE (h,
			   (H_GET_SYMBOL_COUNT (h)
			    + glue_symbols (&symbol_globalP,
					    &symbol_global_lastP)
			    + glue_symbols (&symbol_externP,
					    &symbol_extern_lastP)));

  H_SET_SYMBOL_TABLE_SIZE (h, tie_tags ());
  know (symbol_globalP == NULL);
  know (symbol_global_lastP == NULL);
  know (symbol_externP == NULL);
  know (symbol_extern_lastP == NULL);
}

/* Find strings by crawling along symbol table chain.  */

void
w_strings (where)
     char *where;
{
  symbolS *symbolP;
  struct filename_list *filename_list_scan = filename_list_head;

  /* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK.  */
  md_number_to_chars (where, (valueT) string_byte_count, 4);
  where += 4;

#ifdef COFF_LONG_SECTION_NAMES
  /* Support long section names as found in PE.  This code must
     coordinate with that in coff_header_append and write_object_file.  */
  {
    unsigned int i;

    for (i = SEG_E0; i < SEG_LAST; i++)
      {
	if (segment_info[i].scnhdr.s_name[0]
	    && strlen (segment_info[i].name) > SCNNMLEN)
	  {
	    unsigned int size;

	    size = strlen (segment_info[i].name) + 1;
	    memcpy (where, segment_info[i].name, size);
	    where += size;
	  }
      }
  }
#endif /* COFF_LONG_SECTION_NAMES */

  for (symbolP = symbol_rootP;
       symbolP;
       symbolP = symbol_next (symbolP))
    {
      unsigned int size;

      if (SF_GET_STRING (symbolP))
	{
	  size = strlen (S_GET_NAME (symbolP)) + 1;
	  memcpy (where, S_GET_NAME (symbolP), size);
	  where += size;
	}
      if (S_GET_STORAGE_CLASS (symbolP) == C_FILE
	  && SA_GET_FILE_FNAME_ZEROS (symbolP) == 0
	  && SA_GET_FILE_FNAME_OFFSET (symbolP) != 0)
	{
	  size = strlen (filename_list_scan->filename) + 1;
	  memcpy (where, filename_list_scan->filename, size);
	  filename_list_scan = filename_list_scan ->next;
	  where += size;
	}
    }
}

static void
do_linenos_for (abfd, h, file_cursor)
     bfd * abfd;
     object_headers * h;
     unsigned long *file_cursor;
{
  unsigned int idx;
  unsigned long start = *file_cursor;

  for (idx = SEG_E0; idx < SEG_LAST; idx++)
    {
      segment_info_type *s = segment_info + idx;

      if (s->scnhdr.s_nlnno != 0)
	{
	  struct lineno_list *line_ptr;

	  struct external_lineno *buffer =
	  (struct external_lineno *) xmalloc (s->scnhdr.s_nlnno * LINESZ);

	  struct external_lineno *dst = buffer;

	  /* Run through the table we've built and turn it into its external
	     form, take this chance to remove duplicates.  */

	  for (line_ptr = s->lineno_list_head;
	       line_ptr != (struct lineno_list *) NULL;
	       line_ptr = line_ptr->next)
	    {
	      if (line_ptr->line.l_lnno == 0)
		{
		  /* Turn a pointer to a symbol into the symbols' index,
		     provided that it has been initialised.  */
		  if (line_ptr->line.l_addr.l_symndx)
		    line_ptr->line.l_addr.l_symndx =
		      ((symbolS *) line_ptr->line.l_addr.l_symndx)->sy_number;
		}
	      else
		line_ptr->line.l_addr.l_paddr += ((struct frag *) (line_ptr->frag))->fr_address;

	      (void) bfd_coff_swap_lineno_out (abfd, &(line_ptr->line), dst);
	      dst++;
	    }

	  s->scnhdr.s_lnnoptr = *file_cursor;

	  bfd_bwrite (buffer, (bfd_size_type) s->scnhdr.s_nlnno * LINESZ, abfd);
	  free (buffer);

	  *file_cursor += s->scnhdr.s_nlnno * LINESZ;
	}
    }

  H_SET_LINENO_SIZE (h, *file_cursor - start);
}

/* Now we run through the list of frag chains in a segment and
   make all the subsegment frags appear at the end of the
   list, as if the seg 0 was extra long.  */

static void
remove_subsegs ()
{
  unsigned int i;

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      frchainS *head = segment_info[i].frchainP;
      fragS dummy;
      fragS *prev_frag = &dummy;

      while (head && head->frch_seg == i)
	{
	  prev_frag->fr_next = head->frch_root;
	  prev_frag = head->frch_last;
	  head = head->frch_next;
	}
      prev_frag->fr_next = 0;
    }
}

unsigned long machine;
int coff_flags;

#ifndef SUB_SEGMENT_ALIGN
#ifdef HANDLE_ALIGN
/* The last subsegment gets an alignment corresponding to the alignment
   of the section.  This allows proper nop-filling at the end of
   code-bearing sections.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
   ? get_recorded_alignment (SEG) : 0)
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 1
#endif
#endif

extern void
write_object_file ()
{
  int i;
  const char *name;
  struct frchain *frchain_ptr;

  object_headers headers;
  unsigned long file_cursor;
  bfd *abfd;
  unsigned int addr;
  abfd = bfd_openw (out_file_name, TARGET_FORMAT);

  if (abfd == 0)
    {
      as_perror (_("FATAL: Can't create %s"), out_file_name);
      exit (EXIT_FAILURE);
    }
  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, BFD_ARCH, machine);

  string_byte_count = 4;

  /* Run through all the sub-segments and align them up.  Also
     close any open frags.  We tack a .fill onto the end of the
     frag chain so that any .align's size can be worked by looking
     at the next frag.  */
  for (frchain_ptr = frchain_root;
       frchain_ptr != (struct frchain *) NULL;
       frchain_ptr = frchain_ptr->frch_next)
    {
      int alignment;

      subseg_set (frchain_ptr->frch_seg, frchain_ptr->frch_subseg);

      alignment = SUB_SEGMENT_ALIGN (now_seg, frchain_ptr);

#ifdef md_do_align
      md_do_align (alignment, (char *) NULL, 0, 0, alignment_done);
#endif
      if (subseg_text_p (now_seg))
	frag_align_code (alignment, 0);
      else
	frag_align (alignment, 0, 0);

#ifdef md_do_align
    alignment_done:
#endif

      frag_wane (frag_now);
      frag_now->fr_fix = 0;
      know (frag_now->fr_next == NULL);
    }

  remove_subsegs ();

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    relax_segment (segment_info[i].frchainP->frch_root, i);

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;

  H_SET_NUMBER_OF_SECTIONS (&headers, 0);

  /* Find out how big the sections are, and set the addresses.  */
  addr = 0;
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      long size;

      segment_info[i].scnhdr.s_paddr = addr;
      segment_info[i].scnhdr.s_vaddr = addr;

      if (segment_info[i].scnhdr.s_name[0])
	{
	  H_SET_NUMBER_OF_SECTIONS (&headers,
				    H_GET_NUMBER_OF_SECTIONS (&headers) + 1);

#ifdef COFF_LONG_SECTION_NAMES
	  /* Support long section names as found in PE.  This code
	     must coordinate with that in coff_header_append and
	     w_strings.  */
	  {
	    unsigned int len;

	    len = strlen (segment_info[i].name);
	    if (len > SCNNMLEN)
	      string_byte_count += len + 1;
	  }
#endif /* COFF_LONG_SECTION_NAMES */
	}

      size = size_section (abfd, (unsigned int) i);
      addr += size;

      /* I think the section alignment is only used on the i960; the
	 i960 needs it, and it should do no harm on other targets.  */
#ifdef ALIGNMENT_IN_S_FLAGS
      segment_info[i].scnhdr.s_flags |= (section_alignment[i] & 0xF) << 8;
#else
      segment_info[i].scnhdr.s_align = 1 << section_alignment[i];
#endif

      if (i == SEG_E0)
	H_SET_TEXT_SIZE (&headers, size);
      else if (i == SEG_E1)
	H_SET_DATA_SIZE (&headers, size);
      else if (i == SEG_E2)
	H_SET_BSS_SIZE (&headers, size);
    }

  /* Turn the gas native symbol table shape into a coff symbol table.  */
  crawl_symbols (&headers, abfd);

  if (string_byte_count == 4)
    string_byte_count = 0;

  H_SET_STRING_SIZE (&headers, string_byte_count);

#ifdef tc_frob_file
  tc_frob_file ();
#endif

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      fixup_mdeps (segment_info[i].frchainP->frch_root, &headers, i);
      fixup_segment (&segment_info[i], i);
    }

  /* Look for ".stab" segments and fill in their initial symbols
     correctly.  */
  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      name = segment_info[i].name;

      if (name != NULL
	  && strncmp (".stab", name, 5) == 0
	  && strncmp (".stabstr", name, 8) != 0)
	adjust_stab_section (abfd, i);
    }

  file_cursor = H_GET_TEXT_FILE_OFFSET (&headers);

  bfd_seek (abfd, (file_ptr) file_cursor, 0);

  /* Plant the data.  */
  fill_section (abfd, &headers, &file_cursor);

  do_relocs_for (abfd, &headers, &file_cursor);

  do_linenos_for (abfd, &headers, &file_cursor);

  H_SET_FILE_MAGIC_NUMBER (&headers, COFF_MAGIC);
#ifndef OBJ_COFF_OMIT_TIMESTAMP
  H_SET_TIME_STAMP (&headers, (long)time((time_t *)0));
#else
  H_SET_TIME_STAMP (&headers, 0);
#endif
#ifdef TC_COFF_SET_MACHINE
  TC_COFF_SET_MACHINE (&headers);
#endif

#ifndef COFF_FLAGS
#define COFF_FLAGS 0
#endif

#ifdef KEEP_RELOC_INFO
  H_SET_FLAGS (&headers, ((H_GET_LINENO_SIZE(&headers) ? 0 : F_LNNO) |
			  COFF_FLAGS | coff_flags));
#else
  H_SET_FLAGS (&headers, ((H_GET_LINENO_SIZE(&headers)     ? 0 : F_LNNO)   |
			  (H_GET_RELOCATION_SIZE(&headers) ? 0 : F_RELFLG) |
			  COFF_FLAGS | coff_flags));
#endif

  {
    unsigned int symtable_size = H_GET_SYMBOL_TABLE_SIZE (&headers);
    char *buffer1 = xmalloc (symtable_size + string_byte_count + 1);

    H_SET_SYMBOL_TABLE_POINTER (&headers, bfd_tell (abfd));
    w_symbols (abfd, buffer1, symbol_rootP);
    if (string_byte_count > 0)
      w_strings (buffer1 + symtable_size);
    bfd_bwrite (buffer1, (bfd_size_type) symtable_size + string_byte_count,
		abfd);
    free (buffer1);
  }

  coff_header_append (abfd, &headers);
#if 0
  /* Recent changes to write need this, but where it should
     go is up to Ken..  */
  if (!bfd_close_all_done (abfd))
    as_fatal (_("Can't close %s: %s"), out_file_name,
	      bfd_errmsg (bfd_get_error ()));
#else
  {
    extern bfd *stdoutput;
    stdoutput = abfd;
  }
#endif

}

/* Add a new segment.  This is called from subseg_new via the
   obj_new_segment macro.  */

segT
obj_coff_add_segment (name)
     const char *name;
{
  unsigned int i;

#ifndef COFF_LONG_SECTION_NAMES
  char buf[SCNNMLEN + 1];

  strncpy (buf, name, SCNNMLEN);
  buf[SCNNMLEN] = '\0';
  name = buf;
#endif

  for (i = SEG_E0; i < SEG_LAST && segment_info[i].scnhdr.s_name[0]; i++)
    if (strcmp (name, segment_info[i].name) == 0)
      return (segT) i;

  if (i == SEG_LAST)
    {
      as_bad (_("Too many new sections; can't add \"%s\""), name);
      return now_seg;
    }

  /* Add a new section.  */
  strncpy (segment_info[i].scnhdr.s_name, name,
	   sizeof (segment_info[i].scnhdr.s_name));
  segment_info[i].scnhdr.s_flags = STYP_REG;
  segment_info[i].name = xstrdup (name);

  return (segT) i;
}

/* Implement the .section pseudo op:
  	.section name {, "flags"}
                  ^         ^
                  |         +--- optional flags: 'b' for bss
                  |                              'i' for info
                  +-- section name               'l' for lib
                                                 'n' for noload
                                                 'o' for over
                                                 'w' for data
  						 'd' (apparently m88k for data)
                                                 'x' for text
  						 'r' for read-only data
   But if the argument is not a quoted string, treat it as a
   subsegment number.  */

void
obj_coff_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* Strip out the section name.  */
  char *section_name, *name;
  char c;
  unsigned int exp;
  long flags;

  if (flag_mri)
    {
      char type;

      s_mri_sect (&type);
      flags = 0;
      if (type == 'C')
	flags = STYP_TEXT;
      else if (type == 'D')
	flags = STYP_DATA;
      segment_info[now_seg].scnhdr.s_flags |= flags;

      return;
    }

  section_name = input_line_pointer;
  c = get_symbol_end ();

  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);

  *input_line_pointer = c;

  exp = 0;
  flags = 0;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (*input_line_pointer != '"')
	exp = get_absolute_expression ();
      else
	{
	  ++input_line_pointer;
	  while (*input_line_pointer != '"'
		 && ! is_end_of_line[(unsigned char) *input_line_pointer])
	    {
	      switch (*input_line_pointer)
		{
		case 'b': flags |= STYP_BSS;    break;
		case 'i': flags |= STYP_INFO;   break;
		case 'l': flags |= STYP_LIB;    break;
		case 'n': flags |= STYP_NOLOAD; break;
		case 'o': flags |= STYP_OVER;   break;
		case 'd':
		case 'w': flags |= STYP_DATA;   break;
		case 'x': flags |= STYP_TEXT;   break;
		case 'r': flags |= STYP_LIT;	break;
		default:
		  as_warn(_("unknown section attribute '%c'"),
			  *input_line_pointer);
		  break;
		}
	      ++input_line_pointer;
	    }
	  if (*input_line_pointer == '"')
	    ++input_line_pointer;
	}
    }

  subseg_new (name, (subsegT) exp);

  segment_info[now_seg].scnhdr.s_flags |= flags;

  demand_empty_rest_of_line ();
}

static void
obj_coff_text (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  subseg_new (".text", get_absolute_expression ());
}

static void
obj_coff_data (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (flag_readonly_data_in_text)
    subseg_new (".text", get_absolute_expression () + 1000);
  else
    subseg_new (".data", get_absolute_expression ());
}

static void
obj_coff_ident (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  segT current_seg = now_seg;		/* Save current seg.  */
  subsegT current_subseg = now_subseg;

  subseg_new (".comment", 0);		/* .comment seg.  */
  stringer (1);				/* Read string.  */
  subseg_set (current_seg, current_subseg);	/* Restore current seg.  */
}

void
c_symbol_merge (debug, normal)
     symbolS *debug;
     symbolS *normal;
{
  S_SET_DATA_TYPE (normal, S_GET_DATA_TYPE (debug));
  S_SET_STORAGE_CLASS (normal, S_GET_STORAGE_CLASS (debug));

  if (S_GET_NUMBER_AUXILIARY (debug) > S_GET_NUMBER_AUXILIARY (normal))
    S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));

  if (S_GET_NUMBER_AUXILIARY (debug) > 0)
    memcpy ((char *) &normal->sy_symbol.ost_auxent[0],
	    (char *) &debug->sy_symbol.ost_auxent[0],
	    (unsigned int) (S_GET_NUMBER_AUXILIARY (debug) * AUXESZ));

  /* Move the debug flags.  */
  SF_SET_DEBUG_FIELD (normal, SF_GET_DEBUG_FIELD (debug));
}

static int
c_line_new (symbol, paddr, line_number, frag)
     symbolS * symbol;
     long paddr;
     int line_number;
     fragS * frag;
{
  struct lineno_list *new_line =
  (struct lineno_list *) xmalloc (sizeof (struct lineno_list));

  segment_info_type *s = segment_info + now_seg;
  new_line->line.l_lnno = line_number;

  if (line_number == 0)
    {
      last_line_symbol = symbol;
      new_line->line.l_addr.l_symndx = (long) symbol;
    }
  else
    {
      new_line->line.l_addr.l_paddr = paddr;
    }

  new_line->frag = (char *) frag;
  new_line->next = (struct lineno_list *) NULL;

  if (s->lineno_list_head == (struct lineno_list *) NULL)
    s->lineno_list_head = new_line;
  else
    s->lineno_list_tail->next = new_line;

  s->lineno_list_tail = new_line;
  return LINESZ * s->scnhdr.s_nlnno++;
}

void
c_dot_file_symbol (filename)
     char *filename;
{
  symbolS *symbolP;

  symbolP = symbol_new (".file",
			SEG_DEBUG,
			0,
			&zero_address_frag);

  S_SET_STORAGE_CLASS (symbolP, C_FILE);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);

  if (strlen (filename) > FILNMLEN)
    {
      /* Filename is too long to fit into an auxent,
	 we stick it into the string table instead.  We keep
	 a linked list of the filenames we find so we can emit
	 them later.  */
      struct filename_list *f = ((struct filename_list *)
				 xmalloc (sizeof (struct filename_list)));

      f->filename = filename;
      f->next = 0;

      SA_SET_FILE_FNAME_ZEROS (symbolP, 0);
      SA_SET_FILE_FNAME_OFFSET (symbolP, 1);

      if (filename_list_tail)
	filename_list_tail->next = f;
      else
	filename_list_head = f;
      filename_list_tail = f;
    }
  else
    {
      SA_SET_FILE_FNAME (symbolP, filename);
    }
#ifndef NO_LISTING
  {
    extern int listing;
    if (listing)
      listing_source_file (filename);
  }
#endif
  SF_SET_DEBUG (symbolP);
  S_SET_VALUE (symbolP, (valueT) previous_file_symbol);

  previous_file_symbol = symbolP;

  /* Make sure that the symbol is first on the symbol chain.  */
  if (symbol_rootP != symbolP)
    {
      symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
      symbol_insert (symbolP, symbol_rootP, &symbol_rootP, &symbol_lastP);
    }
}

/* Build a 'section static' symbol.  */

symbolS *
c_section_symbol (name, idx)
     char *name;
     int idx;
{
  symbolS *symbolP;

  symbolP = symbol_find_base (name, DO_NOT_STRIP);
  if (symbolP == NULL)
    symbolP = symbol_new (name, idx, 0, &zero_address_frag);
  else
    {
      /* Mmmm.  I just love violating interfaces.  Makes me feel...dirty.  */
      S_SET_SEGMENT (symbolP, idx);
      symbolP->sy_frag = &zero_address_frag;
    }

  S_SET_STORAGE_CLASS (symbolP, C_STAT);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);

  SF_SET_STATICS (symbolP);

#ifdef TE_DELTA
  /* manfred@@s-direktnet.de: section symbols *must* have the LOCAL bit cleared,
     which is set by the new definition of LOCAL_LABEL in tc-m68k.h.  */
  SF_CLEAR_LOCAL (symbolP);
#endif
#ifdef TE_PE
  /* If the .linkonce pseudo-op was used for this section, we must
     store the information in the auxiliary entry for the section
     symbol.  */
  if (segment_info[idx].linkonce != LINKONCE_UNSET)
    {
      int type;

      switch (segment_info[idx].linkonce)
	{
	default:
	  abort ();
	case LINKONCE_DISCARD:
	  type = IMAGE_COMDAT_SELECT_ANY;
	  break;
	case LINKONCE_ONE_ONLY:
	  type = IMAGE_COMDAT_SELECT_NODUPLICATES;
	  break;
	case LINKONCE_SAME_SIZE:
	  type = IMAGE_COMDAT_SELECT_SAME_SIZE;
	  break;
	case LINKONCE_SAME_CONTENTS:
	  type = IMAGE_COMDAT_SELECT_EXACT_MATCH;
	  break;
	}

      SYM_AUXENT (symbolP)->x_scn.x_comdat = type;
    }
#endif /* TE_PE */

  return symbolP;
}

static void
w_symbols (abfd, where, symbol_rootP)
     bfd * abfd;
     char *where;
     symbolS * symbol_rootP;
{
  symbolS *symbolP;
  unsigned int i;

  /* First fill in those values we have only just worked out.  */
  for (i = SEG_E0; i < SEG_LAST; i++)
    {
      symbolP = segment_info[i].dot;
      if (symbolP)
	{
	  SA_SET_SCN_SCNLEN (symbolP, segment_info[i].scnhdr.s_size);
	  SA_SET_SCN_NRELOC (symbolP, segment_info[i].scnhdr.s_nreloc);
	  SA_SET_SCN_NLINNO (symbolP, segment_info[i].scnhdr.s_nlnno);
	}
    }

  /* Emit all symbols left in the symbol chain.  */
  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
    {
      /* Used to save the offset of the name. It is used to point
	 to the string in memory but must be a file offset.  */
      char *temp;

      /* We can't fix the lnnoptr field in yank_symbols with the other
         adjustments, because we have to wait until we know where they
         go in the file.  */
      if (SF_GET_ADJ_LNNOPTR (symbolP))
	SA_GET_SYM_LNNOPTR (symbolP) +=
	  segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_lnnoptr;

      tc_coff_symbol_emit_hook (symbolP);

      temp = S_GET_NAME (symbolP);
      if (SF_GET_STRING (symbolP))
	{
	  S_SET_OFFSET (symbolP, symbolP->sy_name_offset);
	  S_SET_ZEROES (symbolP, 0);
	}
      else
	{
	  memset (symbolP->sy_symbol.ost_entry.n_name, 0, SYMNMLEN);
	  strncpy (symbolP->sy_symbol.ost_entry.n_name, temp, SYMNMLEN);
	}
      where = symbol_to_chars (abfd, where, symbolP);
      S_SET_NAME (symbolP, temp);
    }
}

static void
obj_coff_lcomm (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  s_lcomm(0);
  return;
#if 0
  char *name;
  char c;
  int temp;
  char *p;

  symbolS *symbolP;

  name = input_line_pointer;

  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after name"));
      ignore_rest_of_line ();
      return;
    }
  if (*input_line_pointer == '\n')
    {
      as_bad (_("Missing size expression"));
      return;
    }
  input_line_pointer++;
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_("lcomm length (%d.) <0! Ignored."), temp);
      ignore_rest_of_line ();
      return;
    }
  *p = 0;

  symbolP = symbol_find_or_make (name);

  if (S_GET_SEGMENT (symbolP) == SEG_UNKNOWN &&
      S_GET_VALUE (symbolP) == 0)
    {
      if (! need_pass_2)
	{
	  char *p;
	  segT current_seg = now_seg; 	/* Save current seg.  */
	  subsegT current_subseg = now_subseg;

	  subseg_set (SEG_E2, 1);
	  symbolP->sy_frag = frag_now;
	  p = frag_var(rs_org, 1, 1, (relax_substateT)0, symbolP,
		       (offsetT) temp, (char *) 0);
	  *p = 0;
	  subseg_set (current_seg, current_subseg); /* Restore current seg.  */
	  S_SET_SEGMENT (symbolP, SEG_E2);
	  S_SET_STORAGE_CLASS (symbolP, C_STAT);
	}
    }
  else
    as_bad (_("Symbol %s already defined"), name);

  demand_empty_rest_of_line ();
#endif
}

static void
fixup_mdeps (frags, h, this_segment)
     fragS *frags;
     object_headers *h ATTRIBUTE_UNUSED;
     segT this_segment;
{
  subseg_change (this_segment, 0);

  while (frags)
    {
      switch (frags->fr_type)
	{
	case rs_align:
	case rs_align_code:
	case rs_align_test:
	case rs_org:
#ifdef HANDLE_ALIGN
	  HANDLE_ALIGN (frags);
#endif
	  frags->fr_type = rs_fill;
	  frags->fr_offset =
	    ((frags->fr_next->fr_address - frags->fr_address - frags->fr_fix)
	     / frags->fr_var);
	  break;
	case rs_machine_dependent:
	  md_convert_frag (h, this_segment, frags);
	  frag_wane (frags);
	  break;
	default:
	  ;
	}
      frags = frags->fr_next;
    }
}

#if 1

#ifndef TC_FORCE_RELOCATION
#define TC_FORCE_RELOCATION(fix) 0
#endif

static void
fixup_segment (segP, this_segment_type)
     segment_info_type * segP;
     segT this_segment_type;
{
  fixS * fixP;
  symbolS *add_symbolP;
  symbolS *sub_symbolP;
  long add_number;
  int size;
  char *place;
  long where;
  char pcrel;
  fragS *fragP;
  segT add_symbol_segment = absolute_section;

  for (fixP = segP->fix_root; fixP; fixP = fixP->fx_next)
    {
      fragP = fixP->fx_frag;
      know (fragP);
      where = fixP->fx_where;
      place = fragP->fr_literal + where;
      size = fixP->fx_size;
      add_symbolP = fixP->fx_addsy;
      sub_symbolP = fixP->fx_subsy;
      add_number = fixP->fx_offset;
      pcrel = fixP->fx_pcrel;

      /* We want function-relative stabs to work on systems which
	 may use a relaxing linker; thus we must handle the sym1-sym2
	 fixups function-relative stabs generates.

	 Of course, if you actually enable relaxing in the linker, the
	 line and block scoping information is going to be incorrect
	 in some cases.  The only way to really fix this is to support
	 a reloc involving the difference of two symbols.  */
      if (linkrelax
	  && (!sub_symbolP || pcrel))
	continue;

#ifdef TC_I960
      if (fixP->fx_tcbit && SF_GET_CALLNAME (add_symbolP))
	{
	  /* Relocation should be done via the associated 'bal' entry
	     point symbol.  */

	  if (!SF_GET_BALNAME (tc_get_bal_of_call (add_symbolP)))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("No 'bal' entry point for leafproc %s"),
			    S_GET_NAME (add_symbolP));
	      continue;
	    }
	  fixP->fx_addsy = add_symbolP = tc_get_bal_of_call (add_symbolP);
	}
#endif

      /* Make sure the symbols have been resolved; this may not have
         happened if these are expression symbols.  */
      if (add_symbolP != NULL && ! add_symbolP->sy_resolved)
	resolve_symbol_value (add_symbolP);

      if (add_symbolP != NULL)
	{
	  /* If this fixup is against a symbol which has been equated
	     to another symbol, convert it to the other symbol.  */
	  if (add_symbolP->sy_value.X_op == O_symbol
	      && (! S_IS_DEFINED (add_symbolP)
		  || S_IS_COMMON (add_symbolP)))
	    {
	      while (add_symbolP->sy_value.X_op == O_symbol
		     && (! S_IS_DEFINED (add_symbolP)
			 || S_IS_COMMON (add_symbolP)))
		{
		  symbolS *n;

		  /* We must avoid looping, as that can occur with a
		     badly written program.  */
		  n = add_symbolP->sy_value.X_add_symbol;
		  if (n == add_symbolP)
		    break;
		  add_number += add_symbolP->sy_value.X_add_number;
		  add_symbolP = n;
		}
	      fixP->fx_addsy = add_symbolP;
	      fixP->fx_offset = add_number;
	    }
	}

      if (sub_symbolP != NULL && ! sub_symbolP->sy_resolved)
	resolve_symbol_value (sub_symbolP);

      if (add_symbolP != NULL
	  && add_symbolP->sy_mri_common)
	{
	  know (add_symbolP->sy_value.X_op == O_symbol);
	  add_number += S_GET_VALUE (add_symbolP);
	  fixP->fx_offset = add_number;
	  add_symbolP = fixP->fx_addsy = add_symbolP->sy_value.X_add_symbol;
	}

      if (add_symbolP)
	add_symbol_segment = S_GET_SEGMENT (add_symbolP);

      if (sub_symbolP)
	{
	  if (add_symbolP == NULL || add_symbol_segment == absolute_section)
	    {
	      if (add_symbolP != NULL)
		{
		  add_number += S_GET_VALUE (add_symbolP);
		  add_symbolP = NULL;
		  fixP->fx_addsy = NULL;
		}

	      /* It's just -sym.  */
	      if (S_GET_SEGMENT (sub_symbolP) == absolute_section)
		{
		  add_number -= S_GET_VALUE (sub_symbolP);
		  fixP->fx_subsy = 0;
		  fixP->fx_done = 1;
		}
	      else
		{
#ifndef TC_M68K
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("Negative of non-absolute symbol %s"),
				S_GET_NAME (sub_symbolP));
#endif
		  add_number -= S_GET_VALUE (sub_symbolP);
		}		/* not absolute */

	      /* if sub_symbol is in the same segment that add_symbol
		 and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE.  */
	    }
	  else if (S_GET_SEGMENT (sub_symbolP) == add_symbol_segment
		   && SEG_NORMAL (add_symbol_segment))
	    {
	      /* Difference of 2 symbols from same segment.  Can't
		 make difference of 2 undefineds: 'value' means
		 something different for N_UNDF.  */
#ifdef TC_I960
	      /* Makes no sense to use the difference of 2 arbitrary symbols
	         as the target of a call instruction.  */
	      if (fixP->fx_tcbit)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("callj to difference of 2 symbols"));
#endif /* TC_I960 */
	      add_number += S_GET_VALUE (add_symbolP) -
		S_GET_VALUE (sub_symbolP);
	      add_symbolP = NULL;

	      if (!TC_FORCE_RELOCATION (fixP))
		{
		  fixP->fx_addsy = NULL;
		  fixP->fx_subsy = NULL;
		  fixP->fx_done = 1;
#ifdef TC_M68K /* is this right? */
		  pcrel = 0;
		  fixP->fx_pcrel = 0;
#endif
		}
	    }
	  else
	    {
	      /* Different segments in subtraction.  */
	      know (!(S_IS_EXTERNAL (sub_symbolP) && (S_GET_SEGMENT (sub_symbolP) == absolute_section)));

	      if ((S_GET_SEGMENT (sub_symbolP) == absolute_section))
		add_number -= S_GET_VALUE (sub_symbolP);

#ifdef DIFF_EXPR_OK
	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type
#if 0 /* Okay for 68k, at least...  */
		       && !pcrel
#endif
		       )
		{
		  /* Make it pc-relative.  */
		  add_number += (md_pcrel_from (fixP)
				 - S_GET_VALUE (sub_symbolP));
		  pcrel = 1;
		  fixP->fx_pcrel = 1;
		  sub_symbolP = 0;
		  fixP->fx_subsy = 0;
		}
#endif
	      else
		{
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("Can't emit reloc {- %s-seg symbol \"%s\"} @@ file address %ld."),
				segment_name (S_GET_SEGMENT (sub_symbolP)),
				S_GET_NAME (sub_symbolP),
				(long) (fragP->fr_address + where));
		}
	    }
	}

      if (add_symbolP)
	{
	  if (add_symbol_segment == this_segment_type && pcrel)
	    {
	      /* This fixup was made when the symbol's segment was
	         SEG_UNKNOWN, but it is now in the local segment.
	         So we know how to do the address without relocation.  */
#ifdef TC_I960
	      /* reloc_callj() may replace a 'call' with a 'calls' or a 'bal',
	         in which cases it modifies *fixP as appropriate.  In the case
	         of a 'calls', no further work is required, and *fixP has been
	         set up to make the rest of the code below a no-op.  */
	      reloc_callj (fixP);
#endif /* TC_I960 */

	      add_number += S_GET_VALUE (add_symbolP);
	      add_number -= md_pcrel_from (fixP);

	      /* We used to do
		   add_number -= segP->scnhdr.s_vaddr;
		 if defined (TC_I386) || defined (TE_LYNX).  I now
		 think that was an error propagated from the case when
		 we are going to emit the relocation.  If we are not
		 going to emit the relocation, then we just want to
		 set add_number to the difference between the symbols.
		 This is a case that would only arise when there is a
		 PC relative reference from a section other than .text
		 to a symbol defined in the same section, and the
		 reference is not relaxed.  Since jump instructions on
		 the i386 are relaxed, this could only arise with a
		 call instruction.  */

	      pcrel = 0;	/* Lie. Don't want further pcrel processing.  */
	      if (!TC_FORCE_RELOCATION (fixP))
		{
		  fixP->fx_addsy = NULL;
		  fixP->fx_done = 1;
		}
	    }
	  else
	    {
	      switch (add_symbol_segment)
		{
		case absolute_section:
#ifdef TC_I960
		  /* See comment about reloc_callj() above.  */
		  reloc_callj (fixP);
#endif /* TC_I960 */
		  add_number += S_GET_VALUE (add_symbolP);
		  add_symbolP = NULL;

		  if (!TC_FORCE_RELOCATION (fixP))
		    {
		      fixP->fx_addsy = NULL;
		      fixP->fx_done = 1;
		    }
		  break;
		default:

#if defined(TC_A29K) || (defined(TE_PE) && defined(TC_I386)) || defined(TC_M88K) || defined(TC_OR32)
		  /* This really should be handled in the linker, but
		     backward compatibility forbids.  */
		  add_number += S_GET_VALUE (add_symbolP);
#else
		  add_number += S_GET_VALUE (add_symbolP) +
		    segment_info[S_GET_SEGMENT (add_symbolP)].scnhdr.s_paddr;
#endif
		  break;

		case SEG_UNKNOWN:
#ifdef TC_I960
		  if ((int) fixP->fx_bit_fixP == 13)
		    {
		      /* This is a COBR instruction.  They have only a
		         13-bit displacement and are only to be used
		         for local branches: flag as error, don't generate
		         relocation.  */
		      as_bad_where (fixP->fx_file, fixP->fx_line,
				    _("can't use COBR format with external label"));
		      fixP->fx_addsy = NULL;
		      fixP->fx_done = 1;
		      continue;
		    }
#endif /* TC_I960 */
#if ((defined (TC_I386) || defined (TE_LYNX) || defined (TE_AUX)) && !defined(TE_PE)) || defined (COFF_COMMON_ADDEND)
		  /* 386 COFF uses a peculiar format in which the
		     value of a common symbol is stored in the .text
		     segment (I've checked this on SVR3.2 and SCO
		     3.2.2) Ian Taylor <ian@@cygnus.com>.  */
		  /* This is also true for 68k COFF on sysv machines
		     (Checked on Motorola sysv68 R3V6 and R3V7.1, and also on
		     UNIX System V/M68000, Release 1.0 from ATT/Bell Labs)
		     Philippe De Muyter <phdm@@info.ucl.ac.be>.  */
		  if (S_IS_COMMON (add_symbolP))
		    add_number += S_GET_VALUE (add_symbolP);
#endif
		  break;

		}
	    }
	}

      if (pcrel)
	{
#if !defined(TC_M88K) && !(defined(TE_PE) && defined(TC_I386)) && !defined(TC_A29K) && !defined(TC_OR32)
	  /* This adjustment is not correct on the m88k, for which the
	     linker does all the computation.  */
	  add_number -= md_pcrel_from (fixP);
#endif
	  if (add_symbolP == 0)
	    fixP->fx_addsy = &abs_symbol;
#if defined (TC_I386) || defined (TE_LYNX) || defined (TC_I960) || defined (TC_M68K)
	  /* On the 386 we must adjust by the segment vaddr as well.
	     Ian Taylor.

	     I changed the i960 to work this way as well.  This is
	     compatible with the current GNU linker behaviour.  I do
	     not know what other i960 COFF assemblers do.  This is not
	     a common case: normally, only assembler code will contain
	     a PC relative reloc, and only branches which do not
	     originate in the .text section will have a non-zero
	     address.

	     I changed the m68k to work this way as well.  This will
	     break existing PC relative relocs from sections which do
	     not start at address 0, but it will make ld -r work.
	     Ian Taylor, 4 Oct 96.  */

	  add_number -= segP->scnhdr.s_vaddr;
#endif
	}

      md_apply_fix3 (fixP, (valueT *) & add_number, this_segment_type);

      if (!fixP->fx_bit_fixP && ! fixP->fx_no_overflow)
	{
#ifndef TC_M88K
	  /* The m88k uses the offset field of the reloc to get around
	     this problem.  */
	  if ((size == 1
	       && ((add_number & ~0xFF)
		   || (fixP->fx_signed && (add_number & 0x80)))
	       && ((add_number & ~0xFF) != (-1 & ~0xFF)
		   || (add_number & 0x80) == 0))
	      || (size == 2
		  && ((add_number & ~0xFFFF)
		      || (fixP->fx_signed && (add_number & 0x8000)))
		  && ((add_number & ~0xFFFF) != (-1 & ~0xFFFF)
		      || (add_number & 0x8000) == 0)))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("Value of %ld too large for field of %d bytes at 0x%lx"),
			    (long) add_number, size,
			    (unsigned long) (fragP->fr_address + where));
	    }
#endif
#ifdef WARN_SIGNED_OVERFLOW_WORD
	  /* Warn if a .word value is too large when treated as a
	     signed number.  We already know it is not too negative.
	     This is to catch over-large switches generated by gcc on
	     the 68k.  */
	  if (!flag_signed_overflow_ok
	      && size == 2
	      && add_number > 0x7fff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("Signed .word overflow; switch may be too large; %ld at 0x%lx"),
			  (long) add_number,
			  (unsigned long) (fragP->fr_address + where));
#endif
	}
    }
}

#endif

/* The first entry in a .stab section is special.  */

void
obj_coff_init_stab_section (seg)
     segT seg;
{
  char *file;
  char *p;
  char *stabstr_name;
  unsigned int stroff;

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  as_where (&file, (unsigned int *) NULL);
  stabstr_name = (char *) alloca (strlen (segment_info[seg].name) + 4);
  strcpy (stabstr_name, segment_info[seg].name);
  strcat (stabstr_name, "str");
  stroff = get_stab_string_offset (file, stabstr_name);
  know (stroff == 1);
  md_number_to_chars (p, stroff, 4);
}

/* Fill in the counts in the first entry in a .stab section.  */

static void
adjust_stab_section(abfd, seg)
     bfd *abfd;
     segT seg;
{
  segT stabstrseg = SEG_UNKNOWN;
  const char *secname, *name2;
  char *name;
  char *p = NULL;
  int i, strsz = 0, nsyms;
  fragS *frag = segment_info[seg].frchainP->frch_root;

  /* Look for the associated string table section.  */

  secname = segment_info[seg].name;
  name = (char *) alloca (strlen (secname) + 4);
  strcpy (name, secname);
  strcat (name, "str");

  for (i = SEG_E0; i < SEG_UNKNOWN; i++)
    {
      name2 = segment_info[i].name;
      if (name2 != NULL && strncmp(name2, name, 8) == 0)
	{
	  stabstrseg = i;
	  break;
	}
    }

  /* If we found the section, get its size.  */
  if (stabstrseg != SEG_UNKNOWN)
    strsz = size_section (abfd, stabstrseg);

  nsyms = size_section (abfd, seg) / 12 - 1;

  /* Look for the first frag of sufficient size for the initial stab
     symbol, and collect a pointer to it.  */
  while (frag && frag->fr_fix < 12)
    frag = frag->fr_next;
  assert (frag != 0);
  p = frag->fr_literal;
  assert (p != 0);

  /* Write in the number of stab symbols and the size of the string
     table.  */
  bfd_h_put_16 (abfd, (bfd_vma) nsyms, (bfd_byte *) p + 6);
  bfd_h_put_32 (abfd, (bfd_vma) strsz, (bfd_byte *) p + 8);
}

#endif /* not BFD_ASSEMBLER */

const pseudo_typeS coff_pseudo_table[] =
{
  {"def", obj_coff_def, 0},
  {"dim", obj_coff_dim, 0},
  {"endef", obj_coff_endef, 0},
  {"line", obj_coff_line, 0},
  {"ln", obj_coff_ln, 0},
#ifdef BFD_ASSEMBLER
  {"loc", obj_coff_loc, 0},
#endif
  {"appline", obj_coff_ln, 1},
  {"scl", obj_coff_scl, 0},
  {"size", obj_coff_size, 0},
  {"tag", obj_coff_tag, 0},
  {"type", obj_coff_type, 0},
  {"val", obj_coff_val, 0},
  {"section", obj_coff_section, 0},
  {"sect", obj_coff_section, 0},
  /* FIXME: We ignore the MRI short attribute.  */
  {"section.s", obj_coff_section, 0},
  {"sect.s", obj_coff_section, 0},
  /* We accept the .bss directive for backward compatibility with
     earlier versions of gas.  */
  {"bss", obj_coff_bss, 0},
  {"weak", obj_coff_weak, 0},
  {"ident", obj_coff_ident, 0},
#ifndef BFD_ASSEMBLER
  {"use", obj_coff_section, 0},
  {"text", obj_coff_text, 0},
  {"data", obj_coff_data, 0},
  {"lcomm", obj_coff_lcomm, 0},
#else
  {"optim", s_ignore, 0},	/* For sun386i cc (?) */
#endif
  {"version", s_ignore, 0},
  {"ABORT", s_abort, 0},
#if defined( TC_M88K ) || defined ( TC_TIC4X )
  /* The m88k and tic4x uses sdef instead of def.  */
  {"sdef", obj_coff_def, 0},
#endif
  {NULL, NULL, 0}		/* end sentinel */
};				/* coff_pseudo_table */

#ifdef BFD_ASSEMBLER

/* Support for a COFF emulation.  */

static void coff_pop_insert PARAMS ((void));
static int coff_separate_stab_sections PARAMS ((void));

static void
coff_pop_insert ()
{
  pop_insert (coff_pseudo_table);
}

static int
coff_separate_stab_sections ()
{
  return 1;
}

const struct format_ops coff_format_ops =
{
  bfd_target_coff_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  0,    /* begin */
  c_dot_file_symbol,
  coff_frob_symbol,
  0,	/* frob_file */
  0,	/* frob_file_before_adjust */
  0,	/* frob_file_before_fix */
  coff_frob_file_after_relocs,
  0,	/* s_get_size */
  0,	/* s_set_size */
  0,	/* s_get_align */
  0,	/* s_set_align */
  0,	/* s_get_other */
  0,	/* s_set_other */
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  0,	/* copy_symbol_attributes */
  0,	/* generate_asm_lineno */
  0,	/* process_stab */
  coff_separate_stab_sections,
  obj_coff_init_stab_section,
  0,	/* sec_sym_ok_for_reloc */
  coff_pop_insert,
  0,	/* ecoff_set_ext */
  coff_obj_read_begin_hook,
  coff_obj_symbol_new_hook
};

#endif
@


1.8
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d146 1
a146 1
 * Maintain a list of the tagnames of the structres.
d1475 1
a1475 1
		case 'a': break; /* For compatability with ELF.  */
d1477 1
a1477 1
		case 'r': flags |= SEC_READONLY; break;
d2041 1
a2041 1
			 reloc.  Two relocations are emited, R_IHIHALF,
d2055 1
a2055 1
			 reloc.  Two relocations are emited, R_IHIHALF,
d2099 1
a2099 1
   in the scnhdrs with the info on the file postions.  */
d2967 1
a2967 1
		 real symbol. Do NOT do the oposite (i.e. move from
d3431 1
a3431 1
/* The last subsegment gets an aligment corresponding to the alignment
@


1.7
log
@resolve conflicts.
@
text
@d3 1
a3 1
   1999, 2000, 2001
d41 21
d63 1
a78 4

/* This is used to hold the symbol built by a sequence of pseudo-ops
   from .def and .endef.  */
static symbolS *def_symbol_in_progress;
a80 9
typedef struct
  {
    unsigned long chunk_size;
    unsigned long element_size;
    unsigned long size;
    char *data;
    unsigned long pointer;
  }
stack;
d258 1
d260 3
d274 1
a274 1
      CONST asymbol *s;
a508 4
  if (!appline)
    {
      add_lineno (frag_now, frag_now_fix (), l);
    }
d510 3
a512 1
  if (appline)
d514 2
d571 1
a571 1
        lineno += coff_line_base - 1;
d714 1
a714 1
	CONST char *name;
d719 1
a719 1
  	  {
d845 1
a845 1
                                      DO_NOT_STRIP)) == NULL
d850 1
a850 1
        {
d854 1
a854 1
        }
d1150 1
d1152 1
d1192 2
a1193 1
      symbolS *real;
d1199 1
d1206 1
d1220 1
d1230 1
d1238 1
d1242 1
d1250 1
d1262 1
d1314 1
d1323 1
a1323 1

d1402 18
a1419 17
/*
 * implement the .section pseudo op:
 *	.section name {, "flags"}
 *                ^         ^
 *                |         +--- optional flags: 'b' for bss
 *                |                              'i' for info
 *                +-- section name               'l' for lib
 *                                               'n' for noload
 *                                               'o' for over
 *                                               'w' for data
 *						 'd' (apparently m88k for data)
 *                                               'x' for text
 *						 'r' for read-only data
 *						 's' for shared data (PE)
 * But if the argument is not a quoted string, treat it as a
 * subsegment number.
 */
d1470 2
d1474 2
a1477 1
		case 's': flags |= SEC_SHARED; break;
d1513 1
a1513 1
        flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
d1517 3
a1519 3
        as_warn (_("error setting flags for \"%s\": %s"),
                 bfd_section_name (stdoutput, sec),
                 bfd_errmsg (bfd_get_error ()));
d1573 1
a1573 1
        fragp = fragp->fr_next;
d1640 1
a1640 1
  stabstr_name = (char *) alloca (strlen (seg->name) + 4);
d1722 1
a1722 1
/* structure used to keep the filenames which
d1724 1
a1724 1
   into the string table */
d1738 3
a1740 2
   section number into a segment number
*/
a1741 1
void c_symbol_merge ();
d1744 13
a1756 23
symbolS *c_section_symbol ();
bfd *abfd;

static void fixup_segment PARAMS ((segment_info_type *segP,
				   segT this_segment_type));

static void fixup_mdeps PARAMS ((fragS *,
				 object_headers *,
				 segT));

static void fill_section PARAMS ((bfd * abfd,
				  object_headers *,
				  unsigned long *));

static int c_line_new PARAMS ((symbolS * symbol, long paddr,
			       int line_number,
			       fragS * frag));

static void w_symbols PARAMS ((bfd * abfd, char *where,
			       symbolS * symbol_rootP));

static void adjust_stab_section PARAMS ((bfd *abfd, segT seg));

d1760 10
a1769 1
void obj_coff_section PARAMS ((int));
d1808 2
d1830 5
a1834 2
/* calculate the size of the frag chain and fill in the section header
   to contain all of it, also fill in the addr of the sections */
d1843 1
a1860 1
	  assert (frag->fr_symbol == 0);
d1896 1
a1896 1
  /* Count the relocations */
d1903 1
a1903 1
#ifdef TC_A29K
d1922 2
a1923 1
/* AUX's ld expects relocations to be sorted */
d1938 2
a1939 1
/* output all the relocations for a section */
d1977 1
a1977 1
		  /* Only output some of the relocations */
a1982 1

d2014 1
a2014 1
			  resolve_symbol_value (symbol_ptr, 1);
d2027 1
d2030 1
a2030 3
			    {
			      intr.r_symndx = dot->sy_number;
			    }
d2032 1
a2032 4
			    {
			      intr.r_symndx = symbol_ptr->sy_number;
			    }

d2035 1
a2035 3
			{
			  intr.r_symndx = -1;
			}
a2036 1

a2038 1

a2039 1

a2043 1

d2046 1
a2046 1
			  /* now emit the second bit */
d2053 14
a2070 1

d2072 1
a2072 1
	      /* Sort the reloc table */
d2076 3
a2078 4

	      /* Write out the reloc table */
	      bfd_write ((PTR) external_reloc_vec, 1, external_reloc_size,
			 abfd);
d2088 1
a2088 1
	      /* No relocs */
d2093 2
a2094 1
  /* Set relocation_size field in file headers */
d2098 3
a2100 3
/* run through a frag chain and write out the data to go with it, fill
   in the scnhdrs with the info on the file postions
*/
a2106 1

d2144 1
d2152 1
a2178 1
		  assert (frag->fr_symbol == 0);
d2222 1
a2222 1
		  bfd_write (buffer, s->s_size, 1, abfd);
d2232 1
a2232 1
/* Coff file generation & utilities */
d2246 1
a2246 1
  bfd_seek (abfd, 0, 0);
d2262 2
a2263 2
  bfd_write (buffer, i, 1, abfd);
  bfd_write (buffero, H_GET_SIZEOF_OPTIONAL_HEADER (h), 1, abfd);
a2281 1

d2287 1
a2287 1
	  bfd_write (buffer, size, 1, abfd);
d2302 1
a2302 1
  /* Turn any symbols with register attributes into abs symbols */
d2304 1
a2304 4
    {
      S_SET_SEGMENT (symbolP, absolute_section);
    }
  /* At the same time, relocate all symbols to their output value */
d2306 1
d2329 1
a2330 1

d2337 1
a2337 1
  char underscore = 0;		/* Symbol has leading _ */
d2339 1
a2339 1
  /* Effective symbol */
d2345 1
a2345 1
  /* Additional information */
d2347 1
a2347 1
  /* Auxiliary entries */
d2356 1
a2356 3
/*
 * Handle .ln directives.
 */
d2366 1
d2370 1
a2370 1
    }				/* wrong context */
d2394 8
a2401 13
/*
 *			def()
 *
 * Handle .def directives.
 *
 * One might ask : why can't we symbol_new if the symbol does not
 * already exist and fill it with debug information.  Because of
 * the C_EFCN special symbol. It would clobber the value of the
 * function symbol before we have a chance to notice that it is
 * a C_EFCN. And a second reason is that the code is more clear this
 * way. (at least I think it is :-).
 *
 */
d2412 3
a2414 3
  char name_end;		/* Char after the end of name */
  char *symbol_name;		/* Name of the debug symbol */
  char *symbol_name_copy;	/* Temporary copy of the name */
d2422 1
a2422 1
    }				/* if not inside .def/.endef */
d2438 1
a2438 1
  /* Initialize the new symbol */
d2474 1
a2474 1
    }				/* if not inside .def/.endef */
d2483 2
a2484 1
      /* intentional fallthrough */
d2492 4
a2495 2
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol.  */
      /* intentional fallthrough */
d2497 4
a2500 2
      SF_SET_PROCESS (def_symbol_in_progress);	/* Will need processing before writing */
      /* intentional fallthrough */
d2507 2
a2508 3
	    {
	      fprintf (stderr, _("`.bf' symbol without preceding function\n"));
	    }			/* missing function symbol */
d2516 1
d2545 1
a2545 1
      /* Valid but set somewhere else (s_comm, s_lcomm, colon) */
d2553 1
a2553 1
    }				/* switch on storage class */
d2608 1
a2608 1
	  /* If it already is at the end of the symbol list, do nothing */
d2615 3
a2617 3
	    }			/* if not already in place */
	}			/* if function */
    }				/* normal or mergable */
d2643 2
a2644 2
	}			/* definition follows debug */
    }				/* Create the line number entry pointing to the function being defined */
d2661 1
a2661 1
    }				/* if not inside .def/.endef */
d2679 2
a2680 1
	  /* intentional fallthrough */
d2715 1
a2715 3
	{
	  line_base = this_base;
	}
d2721 1
a2721 3
	  {
	    listing_source_line ((unsigned int) line_base);
	  }
d2741 1
a2741 1
    }				/* if not inside .def/.endef */
d2757 1
a2757 1
    }				/* if not inside .def/.endef */
d2789 1
a2789 3
    {
      as_warn (_("tag not found for .tag %s"), symbol_name);
    }				/* not defined */
d2806 1
a2806 1
    }				/* if not inside .def/.endef */
d2812 1
a2812 3
    {
      SF_SET_FUNCTION (def_symbol_in_progress);
    }				/* is a function */
d2826 1
a2826 1
    }				/* if not inside .def/.endef */
d2841 1
a2841 1
	  /* If the .val is != from the .def (e.g. statics) */
d2910 1
a2910 1
   externals onto another chain */
d2916 1
a2916 1
/* The chain of externals */
d2953 1
a2953 1
	  /* Debug symbols do not need all this rubbish */
d2972 1
a2972 1
	      /* Replace the current symbol by the real one */
d2975 1
a2975 1
		 .text, .data, .bss */
d2980 1
a2980 1
	    }			/* if not local but dup'd */
d2983 1
a2983 3
	    {
	      S_SET_SEGMENT (symbolP, SEG_E0);
	    }			/* push data into text */
d2985 1
a2985 1
	  resolve_symbol_value (symbolP, 1);
d2993 1
d2995 2
a2996 3
		{
		  S_SET_STORAGE_CLASS (symbolP, C_LABEL);
		}
d2998 1
a2998 3
		{
		  S_SET_STORAGE_CLASS (symbolP, C_STAT);
		}
d3001 1
a3001 1
	  /* Mainly to speed up if not -g */
d3010 4
a3013 2
		    {		/* .eb */
		      register symbolS *begin_symbolP;
d3031 1
a3031 3
		    {
		      S_SET_NUMBER_AUXILIARY (symbolP, 1);
		    }		/* make it at least 1 */
d3035 1
a3035 1
		  /* Iffed out by steve - this fries the lnnoptr info too */
d3066 1
a3066 1
	       the first slot after the structure description.  */
d3072 1
a3072 1
	  /* +2 take in account the current symbol */
d3078 1
a3078 1
	     auxent, put it in the string table */
d3090 2
a3091 2
	    }			/* no one points at the first .file symbol */
	}			/* if debug or tag or eos or file */
d3110 2
a3111 2
	  /* remove C_EFCN and LOCAL (L...) symbols */
	  /* next pointer remains valid */
d3131 1
a3131 1
	  /* if external, Remove from the list */
a3152 1

d3169 1
a3169 1
	    }			/* fix "long" names */
d3173 3
a3175 2
	}			/* if local symbol */
    }				/* traverse the symbol list */
a3176 1

d3190 1
a3190 1
      /* append */
d3194 1
a3194 1
      /* and process */
d3202 1
d3204 1
a3204 1
	}			/* fix "long" names */
d3208 1
a3208 1
    }				/* append the entire extern chain */
d3236 1
d3244 1
a3244 1
  /* Initialize the stack used to keep track of the matching .bb .be */
d3249 8
a3256 9
   * order :
   * . .file symbol
   * . debug entries for functions
   * . fake symbols for the sections, including .text .data and .bss
   * . defined symbols
   * . undefined symbols
   * But this is not mandatory. The only important point is to put the
   * undefined symbols at the end of the list.
   */
d3261 1
a3261 3
    {
      c_dot_file_symbol ("fake");
    }
d3263 1
a3263 3
  /*
   * Build up static symbols for the sections, they are filled in later
   */
d3267 1
a3267 1
      segment_info[i].dot = c_section_symbol (segment_info[i].name,
d3270 1
a3270 1
  /* Take all the externals out and put them into another chain */
d3272 1
a3272 1
  /* Take the externals and glue them onto the end.*/
d3287 1
a3287 3
/*
 * Find strings by crawling along symbol table chain.
 */
d3296 1
a3296 1
  /* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
d3368 1
a3368 1
	 form, take this chance to remove duplicates */
d3383 1
a3383 3
		{
		  line_ptr->line.l_addr.l_paddr += ((struct frag *) (line_ptr->frag))->fr_address;
		}
a3386 1

d3391 1
a3391 1
	  bfd_write (buffer, 1, s->scnhdr.s_nlnno * LINESZ, abfd);
d3397 1
d3403 1
a3403 1
   list, as if the seg 0 was extra long */
d3428 14
d3465 4
d3473 1
a3473 4
      /* Run through all the sub-segments and align them up.  Also
	 close any open frags.  We tack a .fill onto the end of the
	 frag chain so that any .align's size can be worked by looking
	 at the next frag.  */
d3477 2
a3478 3
#ifndef SUB_SEGMENT_ALIGN
#define SUB_SEGMENT_ALIGN(SEG) 1
#endif
d3480 1
a3480 2
      md_do_align (SUB_SEGMENT_ALIGN (now_seg), (char *) NULL, 0, 0,
		   alignment_done);
d3483 1
a3483 1
	frag_align_code (SUB_SEGMENT_ALIGN (now_seg), 0);
d3485 1
a3485 1
	frag_align (SUB_SEGMENT_ALIGN (now_seg), 0, 0);
d3499 4
a3502 3
    {
      relax_segment (segment_info[i].frchainP->frch_root, i);
    }
d3553 1
a3553 1
  /* Turn the gas native symbol table shape into a coff symbol table */
d3587 1
a3587 2
  /* Plant the data */

d3625 2
a3626 1
    bfd_write (buffer1, 1, symtable_size + string_byte_count, abfd);
d3634 1
a3634 1
  if (bfd_close_all_done (abfd) == false)
d3682 14
a3695 16
/*
 * implement the .section pseudo op:
 *	.section name {, "flags"}
 *                ^         ^
 *                |         +--- optional flags: 'b' for bss
 *                |                              'i' for info
 *                +-- section name               'l' for lib
 *                                               'n' for noload
 *                                               'o' for over
 *                                               'w' for data
 *						 'd' (apparently m88k for data)
 *                                               'x' for text
 *						 'r' for read-only data
 * But if the argument is not a quoted string, treat it as a
 * subsegment number.
 */
d3701 1
a3701 1
  /* Strip out the section name */
d3798 1
a3798 1
  segT current_seg = now_seg;		/* save current seg	*/
d3800 4
a3803 3
  subseg_new (".comment", 0);		/* .comment seg		*/
  stringer (1);				/* read string		*/
  subseg_set (current_seg, current_subseg);	/* restore current seg	*/
d3815 1
a3815 3
    {
      S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));
    }				/* take the most we have */
d3818 3
a3820 5
    {
      memcpy ((char *) &normal->sy_symbol.ost_auxent[0],
	      (char *) &debug->sy_symbol.ost_auxent[0],
	      (unsigned int) (S_GET_NUMBER_AUXILIARY (debug) * AUXESZ));
    }				/* Move all the auxiliary information */
d3824 1
a3824 1
}				/* c_symbol_merge() */
d3853 1
a3853 3
    {
      s->lineno_list_head = new_line;
    }
d3855 2
a3856 3
    {
      s->lineno_list_tail->next = new_line;
    }
d3880 1
a3880 1
	 them later.*/
d3904 1
a3904 4
      {
	listing_source_file (filename);
      }

a3905 1

d3912 1
a3912 1
  /* Make sure that the symbol is first on the symbol chain */
d3918 1
a3918 1
}				/* c_dot_file_symbol() */
d3920 1
a3920 3
/*
 * Build a 'section static' symbol.
 */
d3980 1
a3980 1
}				/* c_section_symbol() */
d3991 1
a3991 1
  /* First fill in those values we have only just worked out */
d4003 1
a4003 3
  /*
     * Emit all symbols left in the symbol chain.
     */
d4007 2
a4008 2
	       to the string in memory but must be a file offset.  */
      register char *temp;
d4014 2
a4015 4
	{
	  SA_GET_SYM_LNNOPTR (symbolP) +=
	    segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_lnnoptr;
	}
d4033 1
a4033 2

}				/* w_symbols() */
d4083 1
a4083 1
	  segT current_seg = now_seg; 	/* save current seg     */
d4091 1
a4091 1
	  subseg_set (current_seg, current_subseg); /* restore current seg */
d4105 2
a4106 2
     fragS * frags;
     object_headers * h;
d4110 1
d4149 3
a4151 3
  register fixS * fixP;
  register symbolS *add_symbolP;
  register symbolS *sub_symbolP;
d4153 6
a4158 6
  register int size;
  register char *place;
  register long where;
  register char pcrel;
  register fragS *fragP;
  register segT add_symbol_segment = absolute_section;
d4204 1
a4204 1
	resolve_symbol_value (add_symbolP, 1);
d4234 1
a4234 1
	resolve_symbol_value (sub_symbolP, 1);
d4246 1
a4246 3
	{
	  add_symbol_segment = S_GET_SEGMENT (add_symbolP);
	}			/* if there is an addend */
d4277 1
a4277 1
		 and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE */
d4289 2
a4290 4
		{
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("callj to difference of 2 symbols"));
		}
d4313 2
a4314 3
		{
		  add_number -= S_GET_VALUE (sub_symbolP);
		}
d4338 1
a4338 1
		}		/* if absolute */
d4340 1
a4340 1
	}			/* if sub_symbolP */
d4346 3
a4348 5
	      /*
	       * This fixup was made when the symbol's segment was
	       * SEG_UNKNOWN, but it is now in the local segment.
	       * So we know how to do the address without relocation.
	       */
d4351 3
a4353 4
	       * in which cases it modifies *fixP as appropriate.  In the case
	       * of a 'calls', no further work is required, and *fixP has been
	       * set up to make the rest of the code below a no-op.
	       */
d4387 2
a4388 1
		  reloc_callj (fixP);	/* See comment about reloc_callj() above*/
d4401 1
a4401 1
#if defined(TC_A29K) || (defined(TE_PE) && defined(TC_I386)) || defined(TC_M88K)
d4416 3
a4418 4
		       * 13-bit displacement and are only to be used
		       * for local branches: flag as error, don't generate
		       * relocation.
		       */
d4424 1
a4424 1
		    }		/* COBR */
d4440 3
a4442 3
		}		/* switch on symbol seg */
	    }			/* if not in local seg */
	}			/* if there was a + symbol */
d4446 1
a4446 1
#if !defined(TC_M88K) && !(defined(TE_PE) && defined(TC_I386)) && !defined(TC_A29K)
d4452 1
a4452 3
	    {
	      fixP->fx_addsy = &abs_symbol;
	    }			/* if there's an add_symbol */
d4472 1
a4472 1
	}			/* if pcrel */
d4474 1
a4474 5
#ifdef MD_APPLY_FIX3
      md_apply_fix3 (fixP, (valueT *) &add_number, this_segment_type);
#else
      md_apply_fix (fixP, add_number);
#endif
d4511 3
a4513 3
	}			/* not a bit fix */
    }				/* For each fixS in this segment.  */
}				/* fixup_segment() */
d4630 2
a4631 2
#ifdef TC_M88K
  /* The m88k uses sdef instead of def.  */
d4666 1
@


1.6
log
@Automatic cvs merge. Dread what I will have to fix after this excuse
of a program is done...
@
text
@d2 2
a3 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d34 7
d215 1
a215 1
 
d224 1
a224 1
#ifdef BFD_ASSEMBLER
d252 1
a252 1
((char*)(&((X)->sy_symbol.ost_auxent->x_file.x_n.x_offset))[1])
d327 1
a327 1
/* Merge a debug symbol containing debug information into a normal symbol. */
d351 1
a351 1
  /* Move the debug flags. */
d357 1
a357 1
     char *filename;
d412 1
a412 1
  
d422 1
a422 1
  
d440 1
a440 1
     int offset;
d449 5
a453 1
  if (num <= 0) 
d459 1
d668 1
a668 1
  symbolS *symbolP;
d679 1
a679 1
  /* Set the section number according to storage class. */
d694 1
a694 1
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol. */
d709 1
a709 1
	      case 'b':  
d718 1
a718 1
	      case 'e':  
d723 1
a723 1
		SA_SET_SYM_LNNO (def_symbol_in_progress, 
d741 31
d776 1
d783 1
d817 1
a817 1
     the debug symbol is a real function reference. */
d821 1
a821 1
     time. */
d852 1
a852 1
	 previous definition. */
d865 1
a865 1
	     existing symbol to the current place. */
d895 1
a895 1
	     function... */
d1031 1
a1031 1
     This was a bad assumption.  I've added find_or_make. xoxorich. */
d1114 1
a1114 1
         will be calculated later. */
d1128 1
a1128 1
  /* These had better be the same.  Usually 18 bytes. */
a1135 1

d1180 2
d1187 1
d1247 1
a1247 1
      /* more ... */
d1404 1
a1404 1
  flagword flags;
d1426 1
a1426 1
  flags = SEC_LOAD;
d1443 1
a1443 1
		case 'n': flags &=~ SEC_LOAD; break;
d1471 2
a1472 1
  if (flags != SEC_NO_FLAGS)
d1474 4
a1477 1
      flagword oldflags;
d1479 7
a1485 3
      oldflags = bfd_get_section_flags (stdoutput, sec);
      oldflags &= SEC_LINK_ONCE | SEC_LINK_DUPLICATES;
      flags |= oldflags;
d1488 12
a1499 3
	as_warn (_("error setting flags for \"%s\": %s"),
		 bfd_section_name (stdoutput, sec),
		 bfd_errmsg (bfd_get_error ()));
d1527 1
a1527 1
     section alignment, then skip this step, as TICOFF does. */
d1533 14
a1546 2
      size = (size + mask) & ~mask;
      bfd_set_section_size (stdoutput, sec, size);
d1606 1
a1606 1
  /* Make space for this first symbol. */
d1608 1
a1608 1
  /* Zero it out. */
d1635 1
a1635 1
      printf(_("0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n"),
d1649 1
a1649 1
/* This is needed because we include internal bfd things. */
d1696 1
a1696 1
struct filename_list 
a1720 1

a1724 1

a1728 1

a1732 1

a1792 1

d1835 1
a1855 1

a2060 1

d2084 1
a2084 1
	  char *buffer;
d2145 1
a2255 1

d2306 1
a2306 1
  /* Store the pointer in the offset. */
a2433 1

d2448 1
a2448 1
  /* Set the section number according to storage class. */
d2463 1
a2463 1
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol. */
d2484 1
a2484 1
      /* Value is always set to . */
d2535 1
a2535 1
     symbol is a real function reference. */
d2539 1
a2539 1
     time. */
d2565 1
a2565 1
      /* FIXME-SOON Should *def_symbol_in_progress be free'd? xoxorich. */
d2574 1
a2574 1
	     existing symbol to the current place. */
d2608 1
a2608 1
	     function... */
d2755 1
a2755 1
     This was a bad assumption.  I've added find_or_make. xoxorich. */
d2837 1
a2837 1
	 its value will be calculated later. */
d2875 1
a2875 1
  /* These had better be the same.  Usually 18 bytes. */
d2930 1
a2930 1
	  /* L* and C_EFCN symbols never merge. */
d2939 1
a2939 1
		 Maybe tag references before definitions? xoxorich. */
d2944 1
a2944 1
		 whereas no pointers refer to the debug symbol. */
d2982 1
a2982 1
	      /* Handle the nested blocks auxiliary info. */
d3000 1
a3000 1
	       entry. */
d3011 1
a3011 1
		  /* Clobber possible stale .dim information. */
d3044 1
a3044 1
	       the first slot after the structure description. */
d3084 1
a3084 2
	 endndx will still be 22 instead of 21. */

a3157 1

d3236 1
a3236 1
  /* Is there a .file symbol ? If not insert one at the beginning. */
a3246 1

a3341 1

a3357 1

d3360 5
a3364 3
		  /* Turn a pointer to a symbol into the symbols' index */
		  line_ptr->line.l_addr.l_symndx =
		    ((symbolS *) line_ptr->line.l_addr.l_symndx)->sy_number;
a3370 1

a3386 1

a3426 1

d3455 5
a3459 3
      frag_align (SUB_SEGMENT_ALIGN (now_seg),
		  subseg_text_p (now_seg) ? NOP_OPCODE : 0,
		  0);
d3463 1
a3468 1

a3470 1

d3544 1
a3544 1
     correctly. */
d3605 1
a3605 1
     go is up to Ken.. */
a3750 1

a3757 1

d3799 1
a3799 1
  /* Move the debug flags. */
a3828 1

d3870 1
a3870 1
      if (filename_list_tail) 
d3874 1
a3874 1
      filename_list_tail = f;      
d3876 1
a3876 1
  else 
d3995 1
a3995 1
	       to the string in memory but must be a file offset. */
d4066 1
a4066 1
  symbolP = symbol_find_or_make(name);
d4068 2
a4069 2
  if (S_GET_SEGMENT(symbolP) == SEG_UNKNOWN &&
      S_GET_VALUE(symbolP) == 0)
d4083 2
a4084 2
	  S_SET_SEGMENT(symbolP, SEG_E2);
	  S_SET_STORAGE_CLASS(symbolP, C_STAT);
d4088 1
a4088 1
    as_bad(_("Symbol %s already defined"), name);
d4090 1
a4090 1
  demand_empty_rest_of_line();
d4107 1
d4178 1
a4178 1
	     point symbol. */
d4276 1
a4276 1
		 something different for N_UNDF. */
d4303 1
a4303 1
	      /* Different segments in subtraction. */
d4312 1
a4312 1
#if 0 /* Okay for 68k, at least... */
d4372 1
a4372 1
	      pcrel = 0;	/* Lie. Don't want further pcrel processing. */
a4397 1

d4432 1
a4432 1
		     Philippe De Muyter <phdm@@info.ucl.ac.be>. */
a4437 1

d4516 1
a4516 1
    }				/* For each fixS in this segment. */
d4532 1
a4532 1
  /* Make space for this first symbol. */
d4534 1
a4534 1
  /* Zero it out. */
d4559 1
a4559 1
  /* Look for the associated string table section. */
d4576 1
a4576 1
  /* If we found the section, get its size. */
d4583 1
a4583 1
     symbol, and collect a pointer to it. */
d4591 1
a4591 1
     table. */
d4646 1
d4654 6
d4665 2
d4669 1
d4676 1
d4678 3
d4684 2
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d216 1
a216 1
#ifdef BFD_ASSEMLER
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 1996
d22 2
d33 1
d35 17
a52 1

d149 1
a149 1
      as_fatal ("Inserting \"%s\" into structure table failed: %s",
d185 50
d236 2
d268 2
a269 2
  entry = &coffsymbol (sym->bsym)->native[1];
  p = coffsymbol (val->bsym)->native;
d281 2
a282 2
  entry = &coffsymbol (sym->bsym)->native[1];
  p = coffsymbol (val->bsym)->native;
d291 1
a291 1
  return coffsymbol (sym->bsym)->native->u.syment.n_type;
d299 1
a299 1
  coffsymbol (sym->bsym)->native->u.syment.n_type = val;
d307 1
a307 1
  return coffsymbol (sym->bsym)->native->u.syment.n_sclass;
d315 1
a315 1
  coffsymbol (sym->bsym)->native->u.syment.n_sclass = val;
d330 4
a333 2
    /* take the most we have */
    S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));
d338 3
a340 9
      /* @@@@ How many fields do we want to preserve?  Would it make more
	 sense to pick and choose those we want to copy?  Should look
	 into this further....  [raeburn:19920512.2209EST]  */
      alent *linenos;
      linenos = coffsymbol (normal->bsym)->lineno;
      memcpy ((char *) &coffsymbol (normal->bsym)->native,
	      (char *) &coffsymbol (debug->bsym)->native,
	      S_GET_NUMBER_AUXILIARY(debug) * AUXESZ);
      coffsymbol (normal->bsym)->lineno = linenos;
d353 2
d360 1
a360 1
  symbolP->bsym->flags = BSF_DEBUGGING;
d399 1
a399 1
obj_symbol_new_hook (symbolP)
d402 5
a406 1
  char underscore = 0;		/* Symbol has leading _ */
a407 6
  {
    long sz = (OBJ_COFF_MAX_AUXENTRIES + 1) * sizeof (combined_entry_type);
    char *s = (char *) bfd_alloc_by_size_t (stdoutput, sz);
    memset (s, 0, sz);
    coffsymbol (symbolP->bsym)->native = (combined_entry_type *) s;
  }
d414 2
a415 1
  if (!underscore && S_IS_LOCAL (symbolP))
d435 2
a436 2
  struct line_no *new_line = (struct line_no *) bfd_alloc_by_size_t (stdoutput,
								     sizeof (struct line_no));
d441 6
d461 2
a462 1
      coffsymbol (current_lineno_sym->bsym)->lineno = (alent *) line_nos;
d477 1
a477 1
      as_warn (".ln pseudo-op inside .def/.endef: ignored.");
d488 3
d507 78
d606 1
a606 1
     int what;
d615 1
a615 1
      as_warn (".def pseudo-op used inside of .def/.endef: ignored.");
d632 3
d638 1
a638 1
  def_symbol_in_progress->sy_frag = &zero_address_frag;
d653 1
a653 1
     int ignore;
d656 1
d661 1
a661 1
      as_warn (".endef pseudo-op used outside of .def/.endef: ignored.");
d691 25
a715 9
	name = bfd_asymbol_name (def_symbol_in_progress->bsym);
	if (name[1] == 'b' && name[2] == 'f')
	  {
	    if (! in_function ())
	      as_warn ("`%s' symbol without preceding function", name);
/*	    SA_SET_SYM_LNNO (def_symbol_in_progress, 12345);*/
	    /* Will need relocating */
	    SF_SET_PROCESS (def_symbol_in_progress);
	    clear_function ();
d740 4
d749 1
d753 1
a753 1
      as_warn ("unexpected storage class %d",
d760 4
a763 1
     SEG_ABSOLUTE or untagged SEG_DEBUG it never merges. */
d778 1
d784 4
a787 1
      || (symbolP = symbol_find_base (S_GET_NAME (def_symbol_in_progress), DO_NOT_STRIP)) == NULL)
d789 1
d791 5
a795 2
	symbol_append (def_symbol_in_progress, symbol_lastP, &symbol_rootP,
		       &symbol_lastP);
d860 1
a860 1
     int ignore;
d866 1
a866 1
      as_warn (".dim pseudo-op used outside of .def/.endef: ignored.");
d886 1
a886 1
	  as_warn ("badly formed .dim directive ignored");
d900 1
a900 1
     int ignore;
d916 1
a916 1
  SA_SET_SYM_LNNO (def_symbol_in_progress, coff_line_base);
d926 1
a926 1
	listing_source_line ((unsigned int) coff_line_base);
d933 1
a933 1
     int ignore;
d937 1
a937 1
      as_warn (".size pseudo-op used outside of .def/.endef ignored.");
d949 1
a949 1
     int ignore;
d953 1
a953 1
      as_warn (".scl pseudo-op used outside of .def/.endef ignored.");
d964 1
a964 1
     int ignore;
d971 1
a971 1
      as_warn (".tag pseudo-op used outside of .def/.endef ignored.");
d980 4
d990 1
a990 1
      as_warn ("tag not found for .tag %s", symbol_name);
d1001 1
a1001 1
     int ignore;
d1005 1
a1005 1
      as_warn (".type pseudo-op used outside of .def/.endef ignored.");
d1023 1
a1023 1
     int ignore;
d1027 1
a1027 1
      as_warn (".val pseudo-op used outside of .def/.endef ignored.");
d1037 3
d1042 1
a1042 1
	  def_symbol_in_progress->sy_frag = frag_now;
d1048 7
a1054 5
	  def_symbol_in_progress->sy_value.X_op = O_symbol;
	  def_symbol_in_progress->sy_value.X_add_symbol =
	    symbol_find_or_make (symbol_name);
	  def_symbol_in_progress->sy_value.X_op_symbol = NULL;
	  def_symbol_in_progress->sy_value.X_add_number = 0;
d1060 6
d1067 2
a1068 1
      /* Otherwise, it is the name of a non debug symbol and its value will be calculated later. */
d1080 1
a1080 1
obj_read_begin_hook ()
d1116 12
a1127 1
  if (!S_IS_DEFINED (symp) && S_GET_STORAGE_CLASS (symp) != C_STAT)
d1165 1
a1165 1
		    as_warn ("mismatched .eb");
d1176 1
a1176 1
	      auxp = &coffsymbol (symp->bsym)->native[1].u.auxent;
d1183 1
a1183 1
		as_fatal ("C_EFCN symbol out of scope");
d1197 1
a1197 1
	symp->bsym->flags |= BSF_FUNCTION;
d1202 5
d1215 2
a1216 2
  if (! symp->sy_used_in_reloc
      && ((symp->bsym->flags & BSF_SECTION_SYM) != 0
d1218 1
a1218 1
	      && ! symp->sy_tc.output
d1225 1
a1225 1
      && ((symp->bsym->flags & BSF_NOT_AT_END) != 0
d1234 7
a1240 3
  if (next_set_end != NULL
      && ! *punt)
    set_end = next_set_end;
d1251 1
a1251 1
  if (coffsymbol (symp->bsym)->lineno)
d1257 1
a1257 1
      lptr = (struct line_no *) coffsymbol (symp->bsym)->lineno;
d1260 1
a1260 1
      lptr = (struct line_no *) coffsymbol (symp->bsym)->lineno;
d1265 2
a1266 2
      l = (alent *) bfd_alloc_by_size_t (stdoutput, (i + 2) * sizeof (alent));
      coffsymbol (symp->bsym)->lineno = l;
d1272 1
a1272 1
	    lptr->l.u.offset += lptr->frag->fr_address;
d1281 1
a1281 1
     bfd *abfd;
d1283 1
a1283 1
     PTR x;
d1304 2
a1306 1
	nrelocs++;
d1317 2
d1324 1
a1324 1
coff_frob_file ()
d1341 2
d1349 1
a1349 1
     int ignore;
d1378 1
a1378 1
  flags = SEC_NO_FLAGS;
d1396 1
a1396 1
		case 'd':
d1398 3
a1400 1
		case 'x': flags |= SEC_CODE; break;
d1405 1
a1405 1
		  as_warn ("unsupported section attribute '%c'",
d1410 1
a1410 1
		  as_warn("unknown section attribute '%c'",
d1425 6
d1432 1
a1432 1
	as_warn ("error setting flags for \"%s\": %s",
d1456 1
d1459 4
a1462 2
     rounded up to multiples of the corresponding section alignments.
     Seems kinda silly to me, but that's the way it is.  */
d1464 2
a1465 1
  mask = ((bfd_vma) 1 << (bfd_vma) sec->alignment_power) - 1;
d1471 1
d1476 1
d1481 1
d1558 1
a1558 1
      printf("0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n",
d1592 4
a1595 3
/* This vector is used to turn an internal segment into a section #
   suitable for insertion into a coff symbol table
 */
a1667 2
static void obj_coff_bss PARAMS ((int));
static void obj_coff_ident PARAMS ((int));
d1670 1
a1670 14
/* Section stuff

   We allow more than just the standard 3 sections, infact, we allow
   40 sections, (though the usual three have to be there).

   This structure performs the mappings for us:
*/


typedef struct
{
  segT seg_t;
  int i;
} seg_info_type;
d1672 31
a1702 25
static const seg_info_type seg_info_off_by_4[] =
{
 {SEG_PTV,  },
 {SEG_NTV,  },
 {SEG_DEBUG, },
 {SEG_ABSOLUTE,  },
 {SEG_UNKNOWN,	 },
 {SEG_E0}, {SEG_E1}, {SEG_E2}, {SEG_E3}, {SEG_E4},
 {SEG_E5}, {SEG_E6}, {SEG_E7}, {SEG_E8}, {SEG_E9},
 {SEG_E10},{SEG_E11},{SEG_E12},{SEG_E13},{SEG_E14},
 {SEG_E15},{SEG_E16},{SEG_E17},{SEG_E18},{SEG_E19},
 {SEG_E20},{SEG_E21},{SEG_E22},{SEG_E23},{SEG_E24},
 {SEG_E25},{SEG_E26},{SEG_E27},{SEG_E28},{SEG_E29},
 {SEG_E30},{SEG_E31},{SEG_E32},{SEG_E33},{SEG_E34},
 {SEG_E35},{SEG_E36},{SEG_E37},{SEG_E38},{SEG_E39},
 {(segT)40},
 {(segT)41},
 {(segT)42},
 {(segT)43},
 {(segT)44},
 {(segT)45},
 {(segT)0},
 {(segT)0},
 {(segT)0},
 {SEG_REGISTER}
a1704 2


d1725 1
a1725 1
  return SEG_INFO_FROM_SECTION_NUMBER (x->sy_symbol.ost_entry.n_scnum).seg_t;
a1727 2


d1732 1
a1732 1
     bfd * abfd;
d1743 1
a1743 1
	  fprintf (stderr, "Out of step\n");
d1763 9
a1771 2
	  size += frag->fr_fix;
	  size += relax_align (size, frag->fr_offset);
d1894 10
a1903 1
			symbol_ptr = symbol_ptr->sy_value.X_add_symbol;
d1908 1
a1908 1
			  resolve_symbol_value (symbol_ptr);
d1916 1
a1916 1
					      "unresolved relocation");
d1918 1
a1918 1
				as_bad ("bad relocation: symbol `%s' not in symbol table",
d1996 1
a1996 1
     object_headers *h;
d2133 3
a2157 4
#ifdef COFF_LONG_SECTION_NAMES
      unsigned long string_size = 4;
#endif

d2178 1
a2178 1
	    as_bad ("bfd_coff_swap_scnhdr_out failed");
d2202 1
d2205 3
d2229 1
a2229 1
obj_symbol_new_hook (symbolP)
d2263 1
a2263 1
      as_warn (".ln pseudo-op inside .def/.endef: ignored.");
d2270 4
d2311 1
a2311 1
     int what;
d2320 1
a2320 1
      as_warn (".def pseudo-op used inside of .def/.endef: ignored.");
d2335 3
d2366 1
a2366 1
     int ignore;
d2373 1
a2373 1
      as_warn (".endef pseudo-op used outside of .def/.endef: ignored.");
d2405 1
a2405 1
	      fprintf (stderr, "`.bf' symbol without preceding function\n");
d2436 4
d2448 1
a2448 1
      as_warn ("unexpected storage class %d", S_GET_STORAGE_CLASS (def_symbol_in_progress));
d2549 1
a2549 1
     int ignore;
d2555 1
a2555 1
      as_warn (".dim pseudo-op used outside of .def/.endef: ignored.");
d2575 1
a2575 1
	  as_warn ("badly formed .dim directive ignored");
d2589 1
a2589 1
     int ignore;
d2634 1
a2634 1
     int ignore;
d2638 1
a2638 1
      as_warn (".size pseudo-op used outside of .def/.endef ignored.");
d2650 1
a2650 1
     int ignore;
d2654 1
a2654 1
      as_warn (".scl pseudo-op used outside of .def/.endef ignored.");
d2665 1
a2665 1
     int ignore;
d2672 1
a2672 1
      as_warn (".tag pseudo-op used outside of .def/.endef ignored.");
d2680 3
d2690 1
a2690 1
      as_warn ("tag not found for .tag %s", symbol_name);
d2701 1
a2701 1
     int ignore;
d2705 1
a2705 1
      as_warn (".type pseudo-op used outside of .def/.endef ignored.");
d2723 1
a2723 1
     int ignore;
d2727 1
a2727 1
      as_warn (".val pseudo-op used outside of .def/.endef ignored.");
d2737 4
d2760 5
a2764 6
	  /* FIXME: gcc can generate address expressions
	     here in unusual cases (search for "obscure"
	     in sdbout.c).  We just ignore the offset
	     here, thus generating incorrect debugging
	     information.  We ignore the rest of the
	     line just below.  */
d2803 1
a2803 1
obj_read_begin_hook ()
d2844 6
a2849 2
	  if (S_GET_STORAGE_CLASS (symbolP) == C_EXT)
	    as_bad ("%s: global symbols not supported in common sections",
d2891 1
a2891 1
	  resolve_symbol_value (symbolP);
d2922 1
a2922 1
			as_warn ("mismatched .eb");
d2962 1
a2962 1
		    as_fatal ("C_EFCN symbol out of scope");
d3001 4
d3033 7
a3039 3
	       && !SF_GET_STATICS (symbolP) &&
	       S_GET_STORAGE_CLASS (symbolP) == C_EXT)
	{			/* C_EXT && !SF_GET_FUNCTION(symbolP))  */
d3051 5
a3055 1
	       && S_GET_STORAGE_CLASS (symbolP) == C_EXT)
a3095 1
  symbolS *symbolP;
d3097 1
a3097 1
  for (symbolP = *head; *head != NULL;)
d3127 1
d3129 1
a3129 3
  symbolS *symbolP;
  for (symbolP = symbol_rootP; symbolP; symbolP =
       symbol_next (symbolP))
a3132 2


d3142 1
a3143 1

d3149 1
a3149 1
     bfd * abfd;
d3161 1
a3161 1
   * . fake symbols for the sections, including.text .data and .bss
d3168 1
a3173 1
  /* Is there a .file symbol ? If not insert one at the beginning. */
d3365 1
a3365 1
      as_perror ("FATAL: Can't create %s", out_file_name);
d3383 1
d3388 2
a3389 4
      {
	static char nop = NOP_OPCODE;
	md_do_align (SUB_SEGMENT_ALIGN (now_seg), &nop, 1, alignment_done);
      }
d3391 3
a3393 1
      frag_align (SUB_SEGMENT_ALIGN (now_seg), NOP_OPCODE);
d3446 3
d3450 1
d3542 1
a3542 1
    as_fatal ("Can't close %s: %s", out_file_name,
d3576 1
a3576 1
      as_bad ("Too many new sections; can't add \"%s\"", name);
d3601 1
d3608 1
a3608 1
     int ignore;
d3666 1
d3668 1
a3668 1
		  as_warn("unknown section attribute '%c'",
d3689 1
a3689 1
     int ignore;
d3697 1
a3697 1
     int ignore;
a3705 10
obj_coff_bss (ignore)
     int ignore;
{
  if (*input_line_pointer == '\n')	/* .bss 		*/
    subseg_new(".bss", get_absolute_expression());
  else					/* .bss id,expr		*/
    obj_coff_lcomm(0);
}

static void
d3707 1
a3707 1
     int ignore;
a3836 5
      if (symbolP == symbol_lastP)
	{
	  symbol_lastP = symbol_lastP->sy_previous;
	}			/* if it was the last thing on the list */

d3839 1
a3839 3
      symbol_rootP = symbolP;
    }				/* if not first on the list */

d3853 9
a3861 3
  symbolP = symbol_new (name, idx,
			0,
			&zero_address_frag);
d3868 5
d3966 1
a3966 1
     int ignore;
d3986 1
a3986 1
      as_bad ("Expected comma after name");
d3992 1
a3992 1
      as_bad ("Missing size expression");
d3998 1
a3998 1
      as_warn ("lcomm length (%d.) <0! Ignored.", temp);
d4018 1
a4018 1
		       temp, (char *)0);
d4026 1
a4026 1
    as_bad("Symbol %s already defined", name);
d4120 1
a4120 1
			    "No 'bal' entry point for leafproc %s",
d4128 35
d4199 1
a4199 1
				"Negative of non-absolute symbol %s",
d4220 1
a4220 1
				"callj to difference of 2 symbols");
d4266 1
a4266 1
				"Can't emit reloc {- %s-seg symbol \"%s\"} @@ file address %ld.",
d4294 15
a4308 5
#if defined (TC_I386) || defined (TE_LYNX)
	      /* On the 386 we must adjust by the segment vaddr as
		 well.  Ian Taylor.  */
	      add_number -= segP->scnhdr.s_vaddr;
#endif
d4356 1
a4356 1
				    "can't use COBR format with external label");
d4362 1
a4362 1
#if (defined (TC_I386) || defined (TE_LYNX) || defined (TE_AUX)) && !defined(TE_PE)
d4367 4
d4413 7
a4419 1
      if (!fixP->fx_bit_fixP)
d4425 4
a4428 2
	       && (add_number & ~0xFF)
	       && ((add_number & ~0xFF) != (-1 & ~0xFF)))
d4430 4
a4433 2
		  && (add_number & ~0xFFFF)
		  && ((add_number & ~0xFFFF) != (-1 & ~0xFFFF))))
d4436 1
a4436 1
			    "Value of %ld too large for field of %d bytes at 0x%lx",
d4450 1
a4450 1
			  "Signed .word overflow; switch may be too large; %ld at 0x%lx",
a4454 7
      /* Once this fix has been applied, we don't have to output
	 anything nothing more need be done.  */
#ifdef MD_APPLY_FIX3
      md_apply_fix3 (fixP, &add_number, this_segment_type);
#else
      md_apply_fix (fixP, add_number);
#endif
d4537 1
a4537 1
const pseudo_typeS obj_pseudo_table[] =
d4544 3
d4558 5
a4566 1
  {"bss", obj_coff_bss, 0},
a4567 1
  {"ident", obj_coff_ident, 0},
a4569 1
  {"ident", s_ignore, 0},	/* we don't yet handle this. */
d4571 1
d4577 40
a4616 2
  {NULL}			/* end sentinel */
};				/* obj_pseudo_table */
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@a24 1
#include "libiberty.h"
d622 2
a623 1
	  || SF_GET_TAG (def_symbol_in_progress))
d625 3
a627 3
	  /* For functions, and tags, the symbol *must* be where the
	     debug symbol appears.  Move the existing symbol to the
	     current place. */
d1656 1
d2233 2
a2234 1
	  || SF_GET_TAG (def_symbol_in_progress))
d2236 3
a2238 3
	  /* For functions, and tags, the symbol *must* be where the
	     debug symbol appears.  Move the existing symbol to the
	     current place. */
d3974 1
a3974 1
#if defined (TC_I386) || defined (TE_LYNX) || defined (TC_I960)
d3976 1
a3976 7
		 well.  Ian Taylor.  I changed the i960 to work this
		 way as well.  This is compatible with the current GNU
		 linker behaviour.  I do not know what other i960 COFF
		 assemblers do.  This is not a common case: normally,
		 only assembler code will contain a PC relative reloc,
		 and only branches which do not originate in the .text
		 section will have a non-zero address.  */
d4058 1
a4058 1
#if defined (TC_I386) || defined (TE_LYNX) || defined (TC_I960)
d4060 15
a4074 2
	     Ian Taylor.  As noted above, I made the i960 work this
	     way as well.  */
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@a31 13

/* structure used to keep the filenames which
   are too long around so that we can stick them
   into the string table */
struct filename_list 
{
  char *filename;
  struct filename_list *next;
};

static struct filename_list *filename_list_head;
static struct filename_list *filename_list_tail;

a280 1
static symbolS *previous_file_symbol;
a303 4
  S_SET_VALUE (symbolP, (long) previous_file_symbol);

  previous_file_symbol = symbolP;

a306 5
      if (symbolP == symbol_lastP)
	{
	  symbol_lastP = symbol_lastP->sy_previous;
	}			/* if it was the last thing on the list */

a308 1
      symbol_rootP = symbolP;
a311 35
/*
 * Build a 'section static' symbol.
 */

char *
c_section_symbol (name, value, length, nreloc, nlnno)
     char *name;
     long value;
     long length;
     unsigned short nreloc;
     unsigned short nlnno;
{
  symbolS *symbolP;

  symbolP = symbol_new (name,
			(name[1] == 't'
			 ? text_section
			 : name[1] == 'd'
			 ? data_section
			 : bss_section),
			value,
			&zero_address_frag);

  S_SET_STORAGE_CLASS (symbolP, C_STAT);
  S_SET_NUMBER_AUXILIARY (symbolP, 1);

  SA_SET_SCN_SCNLEN (symbolP, length);
  SA_SET_SCN_NRELOC (symbolP, nreloc);
  SA_SET_SCN_NLINNO (symbolP, nlnno);

  SF_SET_STATICS (symbolP);

  return (char *) symbolP;
}

d550 7
a559 3
    case C_ARG:
    case C_REGPARM:
    case C_FIELD:
a560 1
      SF_SET_DEBUG (def_symbol_in_progress);
d618 2
a619 1
      /* FIXME-SOON Should *def_symbol_in_progress be free'd? xoxorich. */
d637 1
a637 2
  if (SF_GET_TAG (def_symbol_in_progress)
      && symbol_find_base (S_GET_NAME (def_symbol_in_progress), DO_NOT_STRIP) == NULL)
d639 7
a645 1
      tag_insert (S_GET_NAME (def_symbol_in_progress), def_symbol_in_progress);
a971 12
      else if (SF_GET_TAG (symp))
	last_tagP = symp;
      else if (S_GET_STORAGE_CLASS (symp) == C_EOS)
	next_set_end = last_tagP;
      else if (S_GET_STORAGE_CLASS (symp) == C_FILE)
	{
	  if (S_GET_VALUE (symp))
	    {
	      S_SET_VALUE ((symbolS *) S_GET_VALUE (symp), 0xdeadbeef);
	      S_SET_VALUE (symp, 0);
	    }
	}
d983 5
d1000 5
a1004 1
      && ! *punt)
d1081 5
a1085 1
      && nrelocs == 0 && nlnno == 0)
d1204 1
a1204 4
    {
      assert (previous_file_symbol == 0);
      c_dot_file_symbol ("fake");
    }
d1212 1
a1212 1
  char *strname, *p;
d1230 4
a1233 1
  if (size)
d1367 12
d1656 12
d2248 1
a2248 2
  if (SF_GET_TAG (def_symbol_in_progress)
      && symbol_find_base (S_GET_NAME (def_symbol_in_progress), DO_NOT_STRIP) == NULL)
d2250 7
a2256 1
      tag_insert (S_GET_NAME (def_symbol_in_progress), def_symbol_in_progress);
d3972 9
a3980 3
#if defined (TC_I386) || defined (TE_LYNX)
	      /* On the 386 we must adjust by the segment
		 vaddr as well.  Ian Taylor.  */
d4062 4
a4065 3
#if defined (TC_I386) || defined (TE_LYNX)
	  /* On the 386 we must adjust by the segment vaddr
	     as well.  Ian Taylor.  */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 1
d934 1
d965 1
d1067 9
d1244 2
d1379 4
d1400 4
a1403 10
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
d1463 1
a1463 1
   10 sections, (though the usual three have to be there).
d1466 1
a1467 1
*/
a1468 1
#define N_SEG 32
d1475 1
a1475 1
static const seg_info_type seg_info_off_by_4[N_SEG] =
d1482 14
a1495 16
 {SEG_E0},
 {SEG_E1},
 {SEG_E2},
 {SEG_E3},
 {SEG_E4},
 {SEG_E5},
 {SEG_E6},
 {SEG_E7},
 {SEG_E8},
 {SEG_E9},
 {(segT)15},
 {(segT)16},
 {(segT)17},
 {(segT)18},
 {(segT)19},
 {(segT)20},
d1563 1
d1590 1
a1590 1
      if (TC_COUNT_RELOC (fixup_ptr))
d1607 19
d1637 1
a1637 1
  for (idx = SEG_E0; idx < SEG_E9; idx++)
d1665 1
a1665 1
		  if (TC_COUNT_RELOC (fix_ptr))
d1685 5
d1734 6
d1845 1
d1925 1
a1925 1
  for (i = SEG_E0; i < SEG_E9; i++)
d1927 4
d1933 17
a1949 4
	  unsigned int size =
	  bfd_coff_swap_scnhdr_out (abfd,
				    &(segment_info[i].scnhdr),
				    buffer);
d2172 2
d2530 18
d2572 1
d2604 1
d2690 10
a2699 4
	      /* The C_FCN doesn't need any additional information.  I
		 don't even know if this is needed for sdb. But the
		 standard assembler generates it, so...  */
	      if (S_GET_STORAGE_CLASS (symbolP) == C_EFCN)
d2701 2
d2729 2
a2730 1
	  if (SA_GET_FILE_FNAME_ZEROS (symbolP) == 0)
d2762 7
d2914 4
a2917 12
  for (i = SEG_E0; i < SEG_E9; i++)
    {
      if (segment_info[i].scnhdr.s_name[0])
	{
	  char name[9];

	  strncpy (name, segment_info[i].scnhdr.s_name, 8);
	  name[8] = '\0';
	  segment_info[i].dot = c_section_symbol (name, i - SEG_E0 + 1);
	}
    }

d2950 22
d2985 2
a2986 1
	  && SA_GET_FILE_FNAME_ZEROS (symbolP) == 0)
d3005 1
a3005 1
  for (idx = SEG_E0; idx < SEG_E9; idx++)
d3087 1
a3087 1
  char *name;
d3123 1
a3123 1
	md_do_align (SUB_SEGMENT_ALIGN (now_seg), &nop, alignment_done);
d3159 13
d3179 1
a3179 1
      segment_info[i].scnhdr.s_align = section_alignment[i];
d3211 1
a3211 1
      name = segment_info[i].scnhdr.s_name;
a3288 1
  unsigned int len;
d3291 10
a3300 10
  /* Find out if we've already got a section of this name.  */
  len = strlen (name);
  if (len < sizeof (segment_info[i].scnhdr.s_name))
    ++len;
  else
    len = sizeof (segment_info[i].scnhdr.s_name);
  for (i = SEG_E0; i < SEG_E9 && segment_info[i].scnhdr.s_name[0]; i++)
    if (strncmp (segment_info[i].scnhdr.s_name, name, len) == 0
	&& (len == sizeof (segment_info[i].scnhdr.s_name)
	    || segment_info[i].scnhdr.s_name[len] == '\0'))
d3303 1
a3303 1
  if (i == SEG_E9)
d3313 1
d3339 1
a3339 2
  char *section_name;
  char *section_name_end;
a3340 2
  int argp;
  unsigned int len;
a3360 1
  section_name_end = input_line_pointer;
d3362 8
a3369 2
  len = section_name_end - section_name;
  input_line_pointer++;
d3371 1
a3371 5

  argp = 0;
  if (c == ',')
    argp = 1;
  else if (*input_line_pointer == ',')
a3372 1
      argp = 1;
a3374 1
    }
a3375 4
  exp = 0;
  flags = 0;
  if (argp)
    {
d3406 1
a3406 1
  subseg_new (section_name, (subsegT) exp);
d3410 1
a3410 1
  *section_name_end = c;
d3543 1
a3543 1
      SA_SET_FILE_FNAME_OFFSET (symbolP, 0);
d3606 30
d3649 1
a3649 1
  for (i = SEG_E0; i < SEG_E9; i++)
d3669 9
d3777 1
d3784 2
a3785 1
	    (frags->fr_next->fr_address - frags->fr_address - frags->fr_fix);
a3819 3
  if (linkrelax)
    return;

d3828 16
a3859 3
      sub_symbolP = fixP->fx_subsy;
      add_number = fixP->fx_offset;
      pcrel = fixP->fx_pcrel;
d4024 1
a4024 1
#if defined(TC_A29K) || (defined(TE_PE) && defined(TC_I386))
d4050 1
a4050 1
#if (defined (TC_I386) || defined (TE_LYNX)) && !defined(TE_PE)
d4143 2
a4144 2
  stabstr_name = (char *) alloca (strlen (segment_info[seg].scnhdr.s_name) + 4);
  strcpy (stabstr_name, segment_info[seg].scnhdr.s_name);
d4159 2
a4160 1
  char *secname, *name, *name2;
d4167 1
a4167 1
  secname = segment_info[seg].scnhdr.s_name;
d4174 1
a4174 1
      name2 = segment_info[i].scnhdr.s_name;
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 1996
d18 2
a19 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a23 1
#include "libiberty.h"
a931 1
static symbolS *coff_last_bf;
a961 1
	  && !SF_GET_STATICS (symp)
a1062 9
  if (! *punt
      && S_GET_STORAGE_CLASS (symp) == C_FCN
      && strcmp (S_GET_NAME (symp), ".bf") == 0)
    {
      if (coff_last_bf != NULL)
	SA_SET_SYM_ENDNDX (coff_last_bf, symp);
      coff_last_bf = symp;
    }

a1230 2

  demand_empty_rest_of_line ();
a1363 4
#ifdef TE_PE
#include "coff/pe.h"
#endif

d1381 10
a1390 4
  1,    2,  3,   4,    5,   6,   7,   8,   9,  10,
  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,
  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,
  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
d1450 1
a1450 1
   40 sections, (though the usual three have to be there).
d1453 1
d1456 1
a1456 1

d1463 1
a1463 1
static const seg_info_type seg_info_off_by_4[] =
d1470 16
a1485 14
 {SEG_E0}, {SEG_E1}, {SEG_E2}, {SEG_E3}, {SEG_E4},
 {SEG_E5}, {SEG_E6}, {SEG_E7}, {SEG_E8}, {SEG_E9},
 {SEG_E10},{SEG_E11},{SEG_E12},{SEG_E13},{SEG_E14},
 {SEG_E15},{SEG_E16},{SEG_E17},{SEG_E18},{SEG_E19},
 {SEG_E20},{SEG_E21},{SEG_E22},{SEG_E23},{SEG_E24},
 {SEG_E25},{SEG_E26},{SEG_E27},{SEG_E28},{SEG_E29},
 {SEG_E30},{SEG_E31},{SEG_E32},{SEG_E33},{SEG_E34},
 {SEG_E35},{SEG_E36},{SEG_E37},{SEG_E38},{SEG_E39},
 {(segT)40},
 {(segT)41},
 {(segT)42},
 {(segT)43},
 {(segT)44},
 {(segT)45},
a1552 1
	case rs_align_code:
d1579 1
a1579 1
      if (fixup_ptr->fx_done == 0 && TC_COUNT_RELOC (fixup_ptr))
a1595 19
#ifdef TE_AUX

static int compare_external_relocs PARAMS ((const PTR, const PTR));

/* AUX's ld expects relocations to be sorted */
static int
compare_external_relocs (x, y)
     const PTR x;
     const PTR y;
{
  struct external_reloc *a = (struct external_reloc *) x;
  struct external_reloc *b = (struct external_reloc *) y;
  bfd_vma aadr = bfd_getb32 (a->r_vaddr);
  bfd_vma badr = bfd_getb32 (b->r_vaddr);
  return (aadr < badr ? -1 : badr < aadr ? 1 : 0);
}

#endif

d1607 1
a1607 1
  for (idx = SEG_E0; idx < SEG_LAST; idx++)
d1635 1
a1635 1
		  if (fix_ptr->fx_done == 0 && TC_COUNT_RELOC (fix_ptr))
a1654 5
		      while (symbol_ptr->sy_value.X_op == O_symbol
			     && (! S_IS_DEFINED (symbol_ptr)
				 || S_IS_COMMON (symbol_ptr)))
			symbol_ptr = symbol_ptr->sy_value.X_add_symbol;

a1698 6
#ifdef TE_AUX
	      /* Sort the reloc table */
	      qsort ((PTR) external_reloc_vec, nrelocs,
		     sizeof (struct external_reloc), compare_external_relocs);
#endif

a1803 1
		case rs_align_code:
d1883 1
a1883 1
  for (i = SEG_E0; i < SEG_LAST; i++)
a1884 4
#ifdef COFF_LONG_SECTION_NAMES
      unsigned long string_size = 4;
#endif

d1887 4
a1890 17
	  unsigned int size;

#ifdef COFF_LONG_SECTION_NAMES
	  /* Support long section names as found in PE.  This code
             must coordinate with that in write_object_file and
             w_strings.  */
	  if (strlen (segment_info[i].name) > SCNNMLEN)
	    {
	      memset (segment_info[i].scnhdr.s_name, 0, SCNNMLEN);
	      sprintf (segment_info[i].scnhdr.s_name, "/%lu", string_size);
	      string_size += strlen (segment_info[i].name) + 1;
	    }
#endif

	  size = bfd_coff_swap_scnhdr_out (abfd,
					   &(segment_info[i].scnhdr),
					   buffer);
a2112 2
	  SF_SET_ADJ_LNNOPTR (last_line_symbol);
	  SF_SET_PROCESS (def_symbol_in_progress);
a2468 18
#ifdef TE_PE

/* Handle the .linkonce pseudo-op.  This is parsed by s_linkonce in
   read.c, which then calls this object file format specific routine.  */

void
obj_coff_pe_handle_link_once (type)
     enum linkonce_type type;
{
  seg_info (now_seg)->scnhdr.s_flags |= IMAGE_SCN_LNK_COMDAT;

  /* We store the type in the seg_info structure, and use it to set up
     the auxiliary entry for the section symbol in c_section_symbol.  */
  seg_info (now_seg)->linkonce = type;
}

#endif /* TE_PE */

a2492 1
static symbolS *last_bfP;
a2523 1
	      && !SF_GET_STATICS (symbolP)
d2609 4
a2612 10
	      if (S_GET_STORAGE_CLASS (symbolP) == C_FCN)
		{
		  if (strcmp (S_GET_NAME (symbolP), ".bf") == 0)
		    {
		      if (last_bfP != NULL)
			SA_SET_SYM_ENDNDX (last_bfP, symbol_number);
		      last_bfP = symbolP;
		    }
		}
	      else if (S_GET_STORAGE_CLASS (symbolP) == C_EFCN)
a2613 2
		  /* I don't even know if this is needed for sdb. But
		     the standard assembler generates it, so...  */
d2640 1
a2640 2
	  if (SA_GET_FILE_FNAME_ZEROS (symbolP) == 0
	      && SA_GET_FILE_FNAME_OFFSET (symbolP) != 0)
a2671 7
      else if (symbolP->sy_value.X_op == O_symbol
	       && (! S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP)))
	{
	  /* Skip symbols which were equated to undefined or common
	     symbols.  */
	  symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
	}
d2817 12
a2828 4
  for (i = SEG_E0; i < SEG_LAST; i++)
    if (segment_info[i].scnhdr.s_name[0])
      segment_info[i].dot = c_section_symbol (segment_info[i].name,
					      i - SEG_E0 + 1);
a2860 22

#ifdef COFF_LONG_SECTION_NAMES
  /* Support long section names as found in PE.  This code must
     coordinate with that in coff_header_append and write_object_file.  */
  {
    unsigned int i;

    for (i = SEG_E0; i < SEG_LAST; i++)
      {
	if (segment_info[i].scnhdr.s_name[0]
	    && strlen (segment_info[i].name) > SCNNMLEN)
	  {
	    unsigned int size;

	    size = strlen (segment_info[i].name) + 1;
	    memcpy (where, segment_info[i].name, size);
	    where += size;
	  }
      }
  }
#endif /* COFF_LONG_SECTION_NAMES */

d2874 1
a2874 2
	  && SA_GET_FILE_FNAME_ZEROS (symbolP) == 0
	  && SA_GET_FILE_FNAME_OFFSET (symbolP) != 0)
d2893 1
a2893 1
  for (idx = SEG_E0; idx < SEG_LAST; idx++)
d2975 1
a2975 1
  const char *name;
d3011 1
a3011 1
	md_do_align (SUB_SEGMENT_ALIGN (now_seg), &nop, 1, alignment_done);
a3046 13

#ifdef COFF_LONG_SECTION_NAMES
	  /* Support long section names as found in PE.  This code
	     must coordinate with that in coff_header_append and
	     w_strings.  */
	  {
	    unsigned int len;

	    len = strlen (segment_info[i].name);
	    if (len > SCNNMLEN)
	      string_byte_count += len + 1;
	  }
#endif /* COFF_LONG_SECTION_NAMES */
d3054 1
a3054 1
      segment_info[i].scnhdr.s_align = 1 << section_alignment[i];
d3086 1
a3086 1
      name = segment_info[i].name;
d3164 1
d3167 10
a3176 10
#ifndef COFF_LONG_SECTION_NAMES
  char buf[SCNNMLEN + 1];

  strncpy (buf, name, SCNNMLEN);
  buf[SCNNMLEN] = '\0';
  name = buf;
#endif

  for (i = SEG_E0; i < SEG_LAST && segment_info[i].scnhdr.s_name[0]; i++)
    if (strcmp (name, segment_info[i].name) == 0)
d3179 1
a3179 1
  if (i == SEG_LAST)
a3188 1
  segment_info[i].name = xstrdup (name);
d3214 2
a3215 1
  char *section_name, *name;
d3217 2
d3239 1
d3241 3
a3243 2
  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);
d3245 9
a3253 1
  *input_line_pointer = c;
d3257 1
a3257 3

  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
a3258 3
      ++input_line_pointer;
      SKIP_WHITESPACE ();

d3289 1
a3289 1
  subseg_new (name, (subsegT) exp);
d3293 1
a3293 1
  demand_empty_rest_of_line ();
d3426 1
a3426 1
      SA_SET_FILE_FNAME_OFFSET (symbolP, 1);
a3488 30
#ifdef TE_PE
  /* If the .linkonce pseudo-op was used for this section, we must
     store the information in the auxiliary entry for the section
     symbol.  */
  if (segment_info[idx].linkonce != LINKONCE_UNSET)
    {
      int type;

      switch (segment_info[idx].linkonce)
	{
	default:
	  abort ();
	case LINKONCE_DISCARD:
	  type = IMAGE_COMDAT_SELECT_ANY;
	  break;
	case LINKONCE_ONE_ONLY:
	  type = IMAGE_COMDAT_SELECT_NODUPLICATES;
	  break;
	case LINKONCE_SAME_SIZE:
	  type = IMAGE_COMDAT_SELECT_SAME_SIZE;
	  break;
	case LINKONCE_SAME_CONTENTS:
	  type = IMAGE_COMDAT_SELECT_EXACT_MATCH;
	  break;
	}

      SYM_AUXENT (symbolP)->x_scn.x_comdat = type;
    }
#endif /* TE_PE */

d3502 1
a3502 1
  for (i = SEG_E0; i < SEG_LAST; i++)
a3521 9
      /* We can't fix the lnnoptr field in yank_symbols with the other
         adjustments, because we have to wait until we know where they
         go in the file.  */
      if (SF_GET_ADJ_LNNOPTR (symbolP))
	{
	  SA_GET_SYM_LNNOPTR (symbolP) +=
	    segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_lnnoptr;
	}

a3620 1
	case rs_align_code:
d3627 1
a3627 2
	    ((frags->fr_next->fr_address - frags->fr_address - frags->fr_fix)
	     / frags->fr_var);
d3662 3
a3672 16
      sub_symbolP = fixP->fx_subsy;
      add_number = fixP->fx_offset;
      pcrel = fixP->fx_pcrel;

      /* We want function-relative stabs to work on systems which
	 may use a relaxing linker; thus we must handle the sym1-sym2
	 fixups function-relative stabs generates.

	 Of course, if you actually enable relaxing in the linker, the
	 line and block scoping information is going to be incorrect
	 in some cases.  The only way to really fix this is to support
	 a reloc involving the difference of two symbols.  */
      if (linkrelax
	  && (!sub_symbolP || pcrel))
	continue;

d3689 3
d3856 1
a3856 1
#if defined(TC_A29K) || (defined(TE_PE) && defined(TC_I386)) || defined(TC_M88K)
d3882 1
a3882 1
#if (defined (TC_I386) || defined (TE_LYNX) || defined (TE_AUX)) && !defined(TE_PE)
d3975 2
a3976 2
  stabstr_name = (char *) alloca (strlen (segment_info[seg].name) + 4);
  strcpy (stabstr_name, segment_info[seg].name);
d3991 1
a3991 2
  const char *secname, *name2;
  char *name;
d3998 1
a3998 1
  secname = segment_info[seg].name;
d4005 1
a4005 1
      name2 = segment_info[i].name;
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d32 13
d294 1
d318 4
d325 5
d332 1
d336 35
d609 3
d615 1
a619 7
    case C_MOS:
    case C_MOE:
    case C_MOU:
    case C_EOS:
      S_SET_SEGMENT (def_symbol_in_progress, absolute_section);
      break;

d674 1
a674 2
      symbol_remove (def_symbol_in_progress, &symbol_rootP, &symbol_lastP);

d692 2
a693 1
  if (SF_GET_TAG (def_symbol_in_progress))
d695 1
a695 7
      symbolS *oldtag;

      oldtag = symbol_find_base (S_GET_NAME (def_symbol_in_progress),
				 DO_NOT_STRIP);
      if (oldtag == NULL || ! SF_GET_TAG (oldtag))
	tag_insert (S_GET_NAME (def_symbol_in_progress),
		    def_symbol_in_progress);
d1022 12
a1044 5
  if (SF_GET_TAG (symp))
    last_tagP = symp;
  else if (S_GET_STORAGE_CLASS (symp) == C_EOS)
    next_set_end = last_tagP;

d1057 1
a1057 5
      && ! *punt
      && ((symp->bsym->flags & BSF_NOT_AT_END) != 0
	  || (S_IS_DEFINED (symp)
	      && ! S_IS_COMMON (symp)
	      && (! S_IS_EXTERNAL (symp) || SF_GET_FUNCTION (symp)))))
d1134 1
a1134 5
      && nrelocs == 0
      && nlnno == 0
      && sec != text_section
      && sec != data_section
      && sec != bss_section)
d1253 4
a1256 1
    c_dot_file_symbol ("fake");
d1264 1
a1264 1
  char *p;
d1282 1
a1282 4
  if (size != 0
      || sec == text_section
      || sec == data_section
      || sec == bss_section)
a1415 12
/* structure used to keep the filenames which
   are too long around so that we can stick them
   into the string table */
struct filename_list 
{
  char *filename;
  struct filename_list *next;
};

static struct filename_list *filename_list_head;
static struct filename_list *filename_list_tail;

a1692 12
			  if (! symbol_ptr->sy_resolved)
			    {
			      char *file;
			      unsigned int line;

			      if (expr_symbol_where (symbol_ptr, &file, &line))
				as_bad_where (file, line,
					      "unresolved relocation");
			      else
				as_bad ("bad relocation: symbol `%s' not in symbol table",
					S_GET_NAME (symbol_ptr));
			    }
d2273 2
a2274 1
  if (SF_GET_TAG (def_symbol_in_progress))
d2276 1
a2276 7
      symbolS *oldtag;

      oldtag = symbol_find_base (S_GET_NAME (def_symbol_in_progress),
				 DO_NOT_STRIP);
      if (oldtag == NULL || ! SF_GET_TAG (oldtag))
	tag_insert (S_GET_NAME (def_symbol_in_progress),
		    def_symbol_in_progress);
d3992 3
a3994 9
#if defined (TC_I386) || defined (TE_LYNX) || defined (TC_I960)
	      /* On the 386 we must adjust by the segment vaddr as
		 well.  Ian Taylor.  I changed the i960 to work this
		 way as well.  This is compatible with the current GNU
		 linker behaviour.  I do not know what other i960 COFF
		 assemblers do.  This is not a common case: normally,
		 only assembler code will contain a PC relative reloc,
		 and only branches which do not originate in the .text
		 section will have a non-zero address.  */
d4076 3
a4078 4
#if defined (TC_I386) || defined (TE_LYNX) || defined (TC_I960)
	  /* On the 386 we must adjust by the segment vaddr as well.
	     Ian Taylor.  As noted above, I made the i960 work this
	     way as well.  */
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d25 1
d623 1
a623 2
	  || SF_GET_TAG (def_symbol_in_progress)
	  || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_STAT)
d625 3
a627 3
	  /* For functions, and tags, and static symbols, the symbol
	     *must* be where the debug symbol appears.  Move the
	     existing symbol to the current place. */
a1655 1
			  resolve_symbol_value (symbol_ptr);
d2232 1
a2232 2
	  || SF_GET_TAG (def_symbol_in_progress)
	  || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_STAT)
d2234 3
a2236 3
	  /* For functions, and tags, and static symbols, the symbol
	     *must* be where the debug symbol appears.  Move the
	     existing symbol to the current place. */
d3972 1
a3972 1
#if defined (TC_I386) || defined (TE_LYNX)
d3974 7
a3980 1
		 well.  Ian Taylor.  */
d4062 1
a4062 1
#if defined (TC_I386) || defined (TE_LYNX) || defined (TC_I960) || defined (TC_M68K)
d4064 2
a4065 15
	     Ian Taylor.

	     I changed the i960 to work this way as well.  This is
	     compatible with the current GNU linker behaviour.  I do
	     not know what other i960 COFF assemblers do.  This is not
	     a common case: normally, only assembler code will contain
	     a PC relative reloc, and only branches which do not
	     originate in the .text section will have a non-zero
	     address.

	     I changed the m68k to work this way as well.  This will
	     break existing PC relative relocs from sections which do
	     not start at address 0, but it will make ld -r work.
	     Ian Taylor, 4 Oct 96.  */

@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 1997
a21 2
#define OBJ_HEADER "obj-coff.h"

d330 1
a330 1
coff_obj_symbol_new_hook (symbolP)
d337 1
a337 1
    char *s = (char *) xmalloc (sz);
d367 2
a368 2
  struct line_no *new_line =
    (struct line_no *) xmalloc (sizeof (struct line_no));
a412 3
  if (appline)
    new_logical_line ((char *) NULL, l - 1);

a475 3
#ifdef tc_canonicalize_symbol_name
  symbol_name_copy = tc_canonicalize_symbol_name (symbol_name_copy);
#endif
a787 4
#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif

a840 3
#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif
d872 1
a872 1
coff_obj_read_begin_hook ()
d1037 1
a1037 1
      l = (alent *) xmalloc ((i + 2) * sizeof (alent));
a1109 1
 *						 'r' for read-only data
a1165 1
		case 'r': flags |= SEC_READONLY; break;
d1490 2
d1527 2
a1528 9
	  {
	    addressT off;

	    size += frag->fr_fix;
	    off = relax_align (size, frag->fr_offset);
	    if (frag->fr_subtype != 0 && off > frag->fr_subtype)
	      off = 0;
	    size += off;
	  }
d1651 1
a1651 10
			{
			  symbolS *n;

			  /* We must avoid looping, as that can occur
                             with a badly written program.  */
			  n = symbol_ptr->sy_value.X_add_symbol;
			  if (n == symbol_ptr)
			    break;
			  symbol_ptr = n;
			}
a1880 3
#ifdef COFF_LONG_SECTION_NAMES
  unsigned long string_size = 4;
#endif
d1903 4
d1974 1
a1974 1
coff_obj_symbol_new_hook (symbolP)
a2014 4

  if (appline)
    new_logical_line ((char *) NULL, l - 1);

a2075 3
#ifdef tc_canonicalize_symbol_name
  symbol_name_copy = tc_canonicalize_symbol_name (symbol_name_copy);
#endif
a2413 3
#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif
a2467 4
#ifdef tc_canonicalize_symbol_name
  symbol_name = tc_canonicalize_symbol_name (symbol_name);
#endif

d2531 1
a2531 1
coff_obj_read_begin_hook ()
a2724 4
#ifdef tc_frob_coff_symbol
      tc_frob_coff_symbol (symbolP);
#endif

d2808 1
d2810 1
a2810 1
  while (*head != NULL)
d2840 1
d2842 2
a2843 2

  for (symbolP = symbol_rootP; symbolP; symbolP = symbol_next (symbolP))
d2847 2
d2858 1
a2859 1
  return symbol_number;
d2877 1
a2877 1
   * . fake symbols for the sections, including .text .data and .bss
a2883 1
  /* Is there a .file symbol ? If not insert one at the beginning. */
d2889 1
d3103 4
a3106 2
      md_do_align (SUB_SEGMENT_ALIGN (now_seg), (char *) NULL, 0, 0,
		   alignment_done);
d3108 1
a3108 1
      frag_align (SUB_SEGMENT_ALIGN (now_seg), NOP_OPCODE, 0);
a3311 1
 *						 'r' for read-only data
a3375 1
		case 'r': flags |= STYP_LIT;	break;
d3556 5
d3563 3
a3565 1
    }
a3587 5
#ifdef TE_DELTA
  /* manfred@@s-direktnet.de: section symbols *must* have the LOCAL bit cleared,
     which is set by the new definition of LOCAL_LABEL in tc-m68k.h.  */
  SF_CLEAR_LOCAL (symbolP);
#endif
d3733 1
a3733 1
		       (offsetT) temp, (char *) 0);
a3842 35
      /* Make sure the symbols have been resolved; this may not have
         happened if these are expression symbols.  */
      if (add_symbolP != NULL && ! add_symbolP->sy_resolved)
	resolve_symbol_value (add_symbolP);

      if (add_symbolP != NULL)
	{
	  /* If this fixup is against a symbol which has been equated
	     to another symbol, convert it to the other symbol.  */
	  if (add_symbolP->sy_value.X_op == O_symbol
	      && (! S_IS_DEFINED (add_symbolP)
		  || S_IS_COMMON (add_symbolP)))
	    {
	      while (add_symbolP->sy_value.X_op == O_symbol
		     && (! S_IS_DEFINED (add_symbolP)
			 || S_IS_COMMON (add_symbolP)))
		{
		  symbolS *n;

		  /* We must avoid looping, as that can occur with a
		     badly written program.  */
		  n = add_symbolP->sy_value.X_add_symbol;
		  if (n == add_symbolP)
		    break;
		  add_number += add_symbolP->sy_value.X_add_number;
		  add_symbolP = n;
		}
	      fixP->fx_addsy = add_symbolP;
	      fixP->fx_offset = add_number;
	    }
	}

      if (sub_symbolP != NULL && ! sub_symbolP->sy_resolved)
	resolve_symbol_value (sub_symbolP);

d4032 1
a4032 1
#if ((defined (TC_I386) || defined (TE_LYNX) || defined (TE_AUX)) && !defined(TE_PE)) || defined (COFF_COMMON_ADDEND)
a4036 4
		  /* This is also true for 68k COFF on sysv machines
		     (Checked on Motorola sysv68 R3V6 and R3V7.1, and also on
		     UNIX System V/M68000, Release 1.0 from ATT/Bell Labs)
		     Philippe De Muyter <phdm@@info.ucl.ac.be>. */
d4079 1
a4079 1
      if (!fixP->fx_bit_fixP && ! fixP->fx_no_overflow)
d4085 2
a4086 4
	       && ((add_number & ~0xFF)
		   || (fixP->fx_signed && (add_number & 0x80)))
	       && ((add_number & ~0xFF) != (-1 & ~0xFF)
		   || (add_number & 0x80) == 0))
d4088 2
a4089 4
		  && ((add_number & ~0xFFFF)
		      || (fixP->fx_signed && (add_number & 0x8000)))
		  && ((add_number & ~0xFFFF) != (-1 & ~0xFFFF)
		      || (add_number & 0x8000) == 0)))
a4228 1
  {"version", s_ignore, 0},
a4235 57

#ifdef BFD_ASSEMBLER

/* Support for a COFF emulation.  */

static void
coff_pop_insert ()
{
  pop_insert (obj_pseudo_table);
}

static int
coff_sec_sym_ok_for_reloc (sec)
     asection *sec;
{
  return 0;
}

static void
no_func ()
{
  abort ();
}

const struct format_ops coff_format_ops =
{
  bfd_target_coff_flavour,
  0,
  1,
  coff_frob_symbol,
  coff_frob_file,
  no_func,
  0, 0,
  0, 0,
  0,
#if 0
  obj_generate_asm_lineno,
#else
  no_func,
#endif
#if 0
  obj_stab,
#else
  no_func,
#endif
  coff_sec_sym_ok_for_reloc,
  coff_pop_insert,
#if 0
  obj_set_ext,
#else
  no_func,
#endif
  coff_obj_read_begin_hook,
  coff_obj_symbol_new_hook,
};

#endif
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1989, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a32 1
static void obj_coff_bss PARAMS ((int));
d34 1
a34 14
static void obj_coff_ln PARAMS ((int));
static void obj_coff_def PARAMS ((int));
static void obj_coff_endef PARAMS ((int));
static void obj_coff_dim PARAMS ((int));
static void obj_coff_line PARAMS ((int));
static void obj_coff_size PARAMS ((int));
static void obj_coff_scl PARAMS ((int));
static void obj_coff_tag PARAMS ((int));
static void obj_coff_val PARAMS ((int));
static void obj_coff_type PARAMS ((int));
static void obj_coff_ident PARAMS ((int));
#ifdef BFD_ASSEMBLER
static void obj_coff_loc PARAMS((int));
#endif
a35 3
/* This is used to hold the symbol built by a sequence of pseudo-ops
   from .def and .endef.  */
static symbolS *def_symbol_in_progress;
d132 1
a132 1
      as_fatal (_("Inserting \"%s\" into structure table failed: %s"),
a167 50
/* We accept the .bss directive to set the section for backward
   compatibility with earlier versions of gas.  */

static void
obj_coff_bss (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (*input_line_pointer == '\n')
    subseg_new (".bss", get_absolute_expression ());
  else
    s_lcomm (0);
}

/* Handle .weak.  This is a GNU extension.  */

static void
obj_coff_weak (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  int c;
  symbolS *symbolP;
 
  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();

#ifdef BFD_ASSEMLER
      S_SET_WEAK (symbolP);
#endif

#ifdef TE_PE
      S_SET_STORAGE_CLASS (symbolP, C_NT_WEAK);
#else
      S_SET_STORAGE_CLASS (symbolP, C_WEAKEXT);
#endif

      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');
a168 2
  demand_empty_rest_of_line ();
}
d199 2
a200 2
  entry = &coffsymbol (symbol_get_bfdsym (sym))->native[1];
  p = coffsymbol (symbol_get_bfdsym (val))->native;
d212 2
a213 2
  entry = &coffsymbol (symbol_get_bfdsym (sym))->native[1];
  p = coffsymbol (symbol_get_bfdsym (val))->native;
d222 1
a222 1
  return coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_type;
d230 1
a230 1
  coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_type = val;
d238 1
a238 1
  return coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_sclass;
d246 1
a246 1
  coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_sclass = val;
d261 2
a262 4
    {
      /* take the most we have */
      S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));
    }
d267 9
a275 3
      memcpy (SYM_AUXINFO (normal), SYM_AUXINFO (debug),
	      (S_GET_NUMBER_AUXILIARY (debug)
	       * sizeof (*SYM_AUXINFO (debug))));
a287 2
  /* BFD converts filename to a .file symbol with an aux entry.  It
     also handles chaining.  */
d293 1
a293 1
  symbol_get_bfdsym (symbolP)->flags = BSF_DEBUGGING;
d335 1
a335 5
  long   sz = (OBJ_COFF_MAX_AUXENTRIES + 1) * sizeof (combined_entry_type);
  char * s  = (char *) xmalloc (sz);
  
  memset (s, 0, sz);
  coffsymbol (symbol_get_bfdsym (symbolP))->native = (combined_entry_type *) s;
d337 6
d349 1
a349 2
  
  if (S_IS_LOCAL (symbolP))
a374 6
  if (num <= 0) 
    {
      /* Zero is used as an end marker in the file.  */
      as_warn (_("Line numbers must be positive integers\n"));
      num = 1;
    }
d389 1
a389 2
      coffsymbol (symbol_get_bfdsym (current_lineno_sym))->lineno =
	(alent *) line_nos;
d404 1
a404 1
      as_warn (_(".ln pseudo-op inside .def/.endef: ignored."));
a433 78
/* .loc is essentially the same as .ln; parse it for assembler
   compatibility.  */

static void
obj_coff_loc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  int lineno;

  /* FIXME: Why do we need this check?  We need it for ECOFF, but why
     do we need it for COFF?  */
  if (now_seg != text_section)
    {
      as_warn (_(".loc outside of .text"));
      demand_empty_rest_of_line ();
      return;
    }

  if (def_symbol_in_progress != NULL)
    {
      as_warn (_(".loc pseudo-op inside .def/.endef: ignored."));
      demand_empty_rest_of_line ();
      return;
    }

  /* Skip the file number.  */
  SKIP_WHITESPACE ();
  get_absolute_expression ();
  SKIP_WHITESPACE ();

  lineno = get_absolute_expression ();

#ifndef NO_LISTING
  {
    extern int listing;

    if (listing)
      {
        lineno += coff_line_base - 1;
	listing_source_line (lineno);
      }
  }
#endif

  demand_empty_rest_of_line ();

  add_lineno (frag_now, frag_now_fix (), lineno);
}

/* Handle the .ident pseudo-op.  */

static void
obj_coff_ident (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  segT current_seg = now_seg;
  subsegT current_subseg = now_subseg;

#ifdef TE_PE
  {
    segT sec;

    /* We could put it in .comment, but that creates an extra section
       that shouldn't be loaded into memory, which requires linker
       changes...  For now, until proven otherwise, use .rdata.  */
    sec = subseg_new (".rdata$zzz", 0);
    bfd_set_section_flags (stdoutput, sec,
			   ((SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA)
			    & bfd_applicable_section_flags (stdoutput)));
  }
#else
  subseg_new (".comment", 0);
#endif

  stringer (1);
  subseg_set (current_seg, current_subseg);
}

d455 1
a455 1
     int what ATTRIBUTE_UNUSED;
d464 1
a464 1
      as_warn (_(".def pseudo-op used inside of .def/.endef: ignored."));
d487 1
a487 1
  symbol_set_frag (def_symbol_in_progress, &zero_address_frag);
d502 1
a502 1
     int ignore ATTRIBUTE_UNUSED;
a504 1

d509 1
a509 1
      as_warn (_(".endef pseudo-op used outside of .def/.endef: ignored."));
d539 9
a547 25
	name = S_GET_NAME (def_symbol_in_progress);
	if (name[0] == '.' && name[2] == 'f' && name[3] == '\0')
  	  {
	    switch (name[1])
	      {
	      case 'b':  
		/* .bf */
		if (! in_function ())
		  as_warn (_("`%s' symbol without preceding function"), name);
		/* Will need relocating.  */
		SF_SET_PROCESS (def_symbol_in_progress);
		clear_function ();
		break;
#ifdef TE_PE
	      case 'e':  
		/* .ef */
		/* The MS compilers output the actual endline, not the
		   function-relative one... we want to match without
		   changing the assembler input.  */
		SA_SET_SYM_LNNO (def_symbol_in_progress, 
				 (SA_GET_SYM_LNNO (def_symbol_in_progress)
				  + coff_line_base));
		break;
#endif
	      }
a571 4
    case C_WEAKEXT:
#ifdef TE_PE
    case C_NT_WEAK:
#endif
a576 1
    default:
d580 1
a580 1
      as_warn (_("unexpected storage class %d"),
d587 1
a587 4
     absolute_section or untagged SEG_DEBUG it never merges.  We also
     don't merge labels, which are in a different namespace, nor
     symbols which have not yet been defined since they are typically
     unique, nor do we merge tags with non-tags.  */
a601 1
      || S_GET_STORAGE_CLASS (def_symbol_in_progress) == C_LABEL
d607 1
a607 4
      || ! symbol_constant_p (def_symbol_in_progress)
      || (symbolP = symbol_find_base (S_GET_NAME (def_symbol_in_progress),
                                      DO_NOT_STRIP)) == NULL
      || SF_GET_TAG (def_symbol_in_progress) != SF_GET_TAG (symbolP))
a608 1
      /* If it already is at the end of the symbol list, do nothing */
d610 2
a611 5
        {
	  symbol_remove (def_symbol_in_progress, &symbol_rootP, &symbol_lastP);
	  symbol_append (def_symbol_in_progress, symbol_lastP, &symbol_rootP,
			 &symbol_lastP);
        }
d676 1
a676 1
     int ignore ATTRIBUTE_UNUSED;
d682 1
a682 1
      as_warn (_(".dim pseudo-op used outside of .def/.endef: ignored."));
d702 1
a702 1
	  as_warn (_("badly formed .dim directive ignored"));
d716 1
a716 1
     int ignore ATTRIBUTE_UNUSED;
d732 1
a732 1
  SA_SET_SYM_LNNO (def_symbol_in_progress, this_base);
d742 1
a742 1
	listing_source_line ((unsigned int) this_base);
d749 1
a749 1
     int ignore ATTRIBUTE_UNUSED;
d753 1
a753 1
      as_warn (_(".size pseudo-op used outside of .def/.endef ignored."));
d765 1
a765 1
     int ignore ATTRIBUTE_UNUSED;
d769 1
a769 1
      as_warn (_(".scl pseudo-op used outside of .def/.endef ignored."));
d780 1
a780 1
     int ignore ATTRIBUTE_UNUSED;
d787 1
a787 1
      as_warn (_(".tag pseudo-op used outside of .def/.endef ignored."));
d806 1
a806 1
      as_warn (_("tag not found for .tag %s"), symbol_name);
d817 1
a817 1
     int ignore ATTRIBUTE_UNUSED;
d821 1
a821 1
      as_warn (_(".type pseudo-op used outside of .def/.endef ignored."));
d839 1
a839 1
     int ignore ATTRIBUTE_UNUSED;
d843 1
a843 1
      as_warn (_(".val pseudo-op used outside of .def/.endef ignored."));
d858 1
a858 1
	  symbol_set_frag (def_symbol_in_progress, frag_now);
d864 5
a868 7
	  expressionS exp;

	  exp.X_op = O_symbol;
	  exp.X_add_symbol = symbol_find_or_make (symbol_name);
	  exp.X_op_symbol = NULL;
	  exp.X_add_number = 0;
	  symbol_set_value_expression (def_symbol_in_progress, &exp);
a873 6

	  /* FIXME: gcc can generate address expressions here in
	     unusual cases (search for "obscure" in sdbout.c).  We
	     just ignore the offset here, thus generating incorrect
	     debugging information.  We ignore the rest of the line
	     just below.  */
d875 1
a875 2
      /* Otherwise, it is the name of a non debug symbol and its value
         will be calculated later. */
d923 1
a923 12
  if (S_IS_WEAK (symp))
    {
#ifdef TE_PE
      S_SET_STORAGE_CLASS (symp, C_NT_WEAK);
#else
      S_SET_STORAGE_CLASS (symp, C_WEAKEXT);
#endif
    }

  if (!S_IS_DEFINED (symp)
      && !S_IS_WEAK (symp)
      && S_GET_STORAGE_CLASS (symp) != C_STAT)
d961 1
a961 1
		    as_warn (_("mismatched .eb"));
d972 1
a972 1
	      auxp = SYM_AUXENT (symp);
d979 1
a979 1
		as_fatal (_("C_EFCN symbol out of scope"));
d993 1
a993 1
	symbol_get_bfdsym (symp)->flags |= BSF_FUNCTION;
a997 5
  /* Double check weak symbols.  */
  if (S_IS_WEAK (symp) && S_IS_COMMON (symp))
    as_bad (_("Symbol `%s' can not be both weak and common"),
	    S_GET_NAME (symp));

d1006 2
a1007 2
  if (! symbol_used_in_reloc_p (symp)
      && ((symbol_get_bfdsym (symp)->flags & BSF_SECTION_SYM) != 0
d1009 1
a1009 1
	      && ! symbol_get_tc (symp)->output
d1016 1
a1016 1
      && ((symbol_get_bfdsym (symp)->flags & BSF_NOT_AT_END) != 0
d1025 3
a1027 7
  if (next_set_end != NULL)
    {
      if (set_end != NULL)
	as_warn ("Warning: internal error: forgetting to set endndx of %s",
		 S_GET_NAME (set_end));
      set_end = next_set_end;
    }
d1038 1
a1038 1
  if (coffsymbol (symbol_get_bfdsym (symp))->lineno)
d1044 1
a1044 1
      lptr = (struct line_no *) coffsymbol (symbol_get_bfdsym (symp))->lineno;
d1047 1
a1047 1
      lptr = (struct line_no *) coffsymbol (symbol_get_bfdsym (symp))->lineno;
d1053 1
a1053 1
      coffsymbol (symbol_get_bfdsym (symp))->lineno = l;
d1059 1
a1059 1
	    lptr->l.u.offset += lptr->frag->fr_address / OCTETS_PER_BYTE;
d1068 1
a1068 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1070 1
a1070 1
     PTR x ATTRIBUTE_UNUSED;
a1090 2
	if (! fixp->fx_done)
	  nrelocs++;
d1092 1
a1102 2
  /* This is an estimate; we'll plug in the real value using
     SET_SECTION_RELOCS later */
d1108 1
a1108 1
coff_frob_file_after_relocs ()
a1125 1
 *						 's' for shared data (PE)
d1132 1
a1132 1
     int ignore ATTRIBUTE_UNUSED;
d1161 1
a1161 1
  flags = SEC_LOAD;
d1179 1
a1179 1
		case 'd': flags |= SEC_DATA | SEC_LOAD; /* fall through */
d1181 1
a1181 1
		case 'x': flags |= SEC_CODE | SEC_LOAD; break;
a1182 1
		case 's': flags |= SEC_SHARED; break;
d1187 1
a1187 1
		  as_warn (_("unsupported section attribute '%c'"),
d1192 1
a1192 1
		  as_warn(_("unknown section attribute '%c'"),
a1206 6
      flagword oldflags;

      oldflags = bfd_get_section_flags (stdoutput, sec);
      oldflags &= SEC_LINK_ONCE | SEC_LINK_DUPLICATES;
      flags |= oldflags;

d1208 1
a1208 1
	as_warn (_("error setting flags for \"%s\": %s"),
a1231 1
  bfd_vma align_power = (bfd_vma)sec->alignment_power + OCTETS_PER_BYTE_POWER;
d1234 2
a1235 4
     rounded up to multiples of the corresponding section alignments,
     supposedly because standard COFF has no other way of encoding alignment
     for sections.  If your COFF flavor has a different way of encoding
     section alignment, then skip this step, as TICOFF does. */
d1237 1
a1237 2
  mask = ((bfd_vma) 1 << align_power) - 1;
#if !defined(TICOFF)
a1242 1
#endif
a1246 1
#ifndef TICOFF
a1250 1
#endif
d1327 1
a1327 1
      printf(_("0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n"),
d1361 3
a1363 4

/* This vector is used to turn a gas internal segment number into a
   section number suitable for insertion into a coff symbol table.
   This must correspond to seg_info_off_by_4.  */
d1436 2
d1440 1
a1440 1
/* When not using BFD_ASSEMBLER, we permit up to 40 sections.
d1442 38
a1479 31
   This array maps a COFF section number into a gas section number.
   Because COFF uses negative section numbers, you must add 4 to the
   COFF section number when indexing into this array; this is done via
   the SEG_INFO_FROM_SECTION_NUMBER macro.  This must correspond to
   seg_N_TYPE.  */

static const segT seg_info_off_by_4[] =
{
 SEG_PTV,
 SEG_NTV,
 SEG_DEBUG,
 SEG_ABSOLUTE,
 SEG_UNKNOWN,
 SEG_E0,  SEG_E1,  SEG_E2,  SEG_E3,  SEG_E4,
 SEG_E5,  SEG_E6,  SEG_E7,  SEG_E8,  SEG_E9,
 SEG_E10, SEG_E11, SEG_E12, SEG_E13, SEG_E14,
 SEG_E15, SEG_E16, SEG_E17, SEG_E18, SEG_E19,
 SEG_E20, SEG_E21, SEG_E22, SEG_E23, SEG_E24,
 SEG_E25, SEG_E26, SEG_E27, SEG_E28, SEG_E29,
 SEG_E30, SEG_E31, SEG_E32, SEG_E33, SEG_E34,
 SEG_E35, SEG_E36, SEG_E37, SEG_E38, SEG_E39,
 (segT) 40,
 (segT) 41,
 (segT) 42,
 (segT) 43,
 (segT) 44,
 (segT) 45,
 (segT) 0,
 (segT) 0,
 (segT) 0,
 SEG_REGISTER
d1482 2
d1504 1
a1504 1
  return SEG_INFO_FROM_SECTION_NUMBER (x->sy_symbol.ost_entry.n_scnum);
d1511 1
a1511 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1522 1
a1522 1
	  fprintf (stderr, _("Out of step\n"));
d1687 1
a1687 1
			  resolve_symbol_value (symbol_ptr, 1);
d1695 1
a1695 1
					      _("unresolved relocation"));
d1697 1
a1697 1
				as_bad (_("bad relocation: symbol `%s' not in symbol table"),
d1775 1
a1775 1
     object_headers *h ATTRIBUTE_UNUSED;
d1957 1
a1957 1
	    as_bad (_("bfd_coff_swap_scnhdr_out failed"));
a1980 1
#ifndef TE_PE
a1982 3
#else
  val = S_GET_VALUE (symbolP);
#endif
d2038 1
a2038 1
      as_warn (_(".ln pseudo-op inside .def/.endef: ignored."));
d2086 1
a2086 1
     int what ATTRIBUTE_UNUSED;
d2095 1
a2095 1
      as_warn (_(".def pseudo-op used inside of .def/.endef: ignored."));
d2141 1
a2141 1
     int ignore ATTRIBUTE_UNUSED;
d2148 1
a2148 1
      as_warn (_(".endef pseudo-op used outside of .def/.endef: ignored."));
d2180 1
a2180 1
	      fprintf (stderr, _("`.bf' symbol without preceding function\n"));
a2210 4
    case C_WEAKEXT:
#ifdef TE_PE
    case C_NT_WEAK:
#endif
d2219 1
a2219 1
      as_warn (_("unexpected storage class %d"), S_GET_STORAGE_CLASS (def_symbol_in_progress));
d2320 1
a2320 1
     int ignore ATTRIBUTE_UNUSED;
d2326 1
a2326 1
      as_warn (_(".dim pseudo-op used outside of .def/.endef: ignored."));
d2346 1
a2346 1
	  as_warn (_("badly formed .dim directive ignored"));
d2360 1
a2360 1
     int ignore ATTRIBUTE_UNUSED;
d2405 1
a2405 1
     int ignore ATTRIBUTE_UNUSED;
d2409 1
a2409 1
      as_warn (_(".size pseudo-op used outside of .def/.endef ignored."));
d2421 1
a2421 1
     int ignore ATTRIBUTE_UNUSED;
d2425 1
a2425 1
      as_warn (_(".scl pseudo-op used outside of .def/.endef ignored."));
d2436 1
a2436 1
     int ignore ATTRIBUTE_UNUSED;
d2443 1
a2443 1
      as_warn (_(".tag pseudo-op used outside of .def/.endef ignored."));
d2461 1
a2461 1
      as_warn (_("tag not found for .tag %s"), symbol_name);
d2472 1
a2472 1
     int ignore ATTRIBUTE_UNUSED;
d2476 1
a2476 1
      as_warn (_(".type pseudo-op used outside of .def/.endef ignored."));
d2494 1
a2494 1
     int ignore ATTRIBUTE_UNUSED;
d2498 1
a2498 1
      as_warn (_(".val pseudo-op used outside of .def/.endef ignored."));
d2531 6
a2536 5
	  /* FIXME: gcc can generate address expressions here in
	     unusual cases (search for "obscure" in sdbout.c).  We
	     just ignore the offset here, thus generating incorrect
	     debugging information.  We ignore the rest of the line
	     just below.  */
d2616 2
a2617 6
	  if (S_GET_STORAGE_CLASS (symbolP) == C_EXT
#ifdef TE_PE
	      || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK
#endif
	      || S_GET_STORAGE_CLASS (symbolP) == C_WEAKEXT)
	    as_bad (_("%s: global symbols not supported in common sections"),
d2659 1
a2659 1
	  resolve_symbol_value (symbolP, 1);
d2690 1
a2690 1
			as_warn (_("mismatched .eb"));
d2730 1
a2730 1
		    as_fatal (_("C_EFCN symbol out of scope"));
d2801 3
a2803 7
	       && !SF_GET_STATICS (symbolP)
	       && (S_GET_STORAGE_CLASS (symbolP) == C_EXT
#ifdef TE_PE
		   || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK
#endif
		   || S_GET_STORAGE_CLASS (symbolP) == C_WEAKEXT))
	{
d2815 1
a2815 5
	       && (S_GET_STORAGE_CLASS (symbolP) == C_EXT
#ifdef TE_PE
		   || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK
#endif
		   || S_GET_STORAGE_CLASS (symbolP) == C_NT_WEAK))
d2909 1
a2909 1
     bfd *abfd ATTRIBUTE_UNUSED;
d3125 1
a3125 1
      as_perror (_("FATAL: Can't create %s"), out_file_name);
a3142 1

d3150 1
a3150 3
      frag_align (SUB_SEGMENT_ALIGN (now_seg),
		  subseg_text_p (now_seg) ? NOP_OPCODE : 0,
		  0);
a3202 3
#ifdef ALIGNMENT_IN_S_FLAGS
      segment_info[i].scnhdr.s_flags |= (section_alignment[i] & 0xF) << 8;
#else
a3203 1
#endif
d3295 1
a3295 1
    as_fatal (_("Can't close %s: %s"), out_file_name,
d3329 1
a3329 1
      as_bad (_("Too many new sections; can't add \"%s\""), name);
d3361 1
a3361 1
     int ignore ATTRIBUTE_UNUSED;
d3421 1
a3421 1
		  as_warn(_("unknown section attribute '%c'"),
d3442 1
a3442 1
     int ignore ATTRIBUTE_UNUSED;
d3450 1
a3450 1
     int ignore ATTRIBUTE_UNUSED;
d3459 10
d3470 1
a3470 1
     int ignore ATTRIBUTE_UNUSED;
d3616 3
a3618 9
  symbolP = symbol_find_base (name, DO_NOT_STRIP);
  if (symbolP == NULL)
    symbolP = symbol_new (name, idx, 0, &zero_address_frag);
  else
    {
      /* Mmmm.  I just love violating interfaces.  Makes me feel...dirty.  */
      S_SET_SEGMENT (symbolP, idx);
      symbolP->sy_frag = &zero_address_frag;
    }
d3723 1
a3723 1
     int ignore ATTRIBUTE_UNUSED;
d3743 1
a3743 1
      as_bad (_("Expected comma after name"));
d3749 1
a3749 1
      as_bad (_("Missing size expression"));
d3755 1
a3755 1
      as_warn (_("lcomm length (%d.) <0! Ignored."), temp);
d3783 1
a3783 1
    as_bad(_("Symbol %s already defined"), name);
d3877 1
a3877 1
			    _("No 'bal' entry point for leafproc %s"),
d3888 1
a3888 1
	resolve_symbol_value (add_symbolP, 1);
d3918 1
a3918 1
	resolve_symbol_value (sub_symbolP, 1);
d3956 1
a3956 1
				_("Negative of non-absolute symbol %s"),
d3977 1
a3977 1
				_("callj to difference of 2 symbols"));
d4023 1
a4023 1
				_("Can't emit reloc {- %s-seg symbol \"%s\"} @@ file address %ld."),
d4051 5
a4055 15

	      /* We used to do
		   add_number -= segP->scnhdr.s_vaddr;
		 if defined (TC_I386) || defined (TE_LYNX).  I now
		 think that was an error propagated from the case when
		 we are going to emit the relocation.  If we are not
		 going to emit the relocation, then we just want to
		 set add_number to the difference between the symbols.
		 This is a case that would only arise when there is a
		 PC relative reference from a section other than .text
		 to a symbol defined in the same section, and the
		 reference is not relaxed.  Since jump instructions on
		 the i386 are relaxed, this could only arise with a
		 call instruction.  */

d4103 1
a4103 1
				    _("can't use COBR format with external label"));
a4159 6
#ifdef MD_APPLY_FIX3
      md_apply_fix3 (fixP, (valueT *) &add_number, this_segment_type);
#else
      md_apply_fix (fixP, add_number);
#endif

d4177 1
a4177 1
			    _("Value of %ld too large for field of %d bytes at 0x%lx"),
d4191 1
a4191 1
			  _("Signed .word overflow; switch may be too large; %ld at 0x%lx"),
d4196 7
d4285 1
a4285 1
const pseudo_typeS coff_pseudo_table[] =
a4291 3
#ifdef BFD_ASSEMBLER
  {"loc", obj_coff_loc, 0},
#endif
a4302 5
  /* We accept the .bss directive for backward compatibility with
     earlier versions of gas.  */
  {"bss", obj_coff_bss, 0},
  {"weak", obj_coff_weak, 0},
  {"ident", obj_coff_ident, 0},
d4307 1
d4309 1
d4312 1
d4320 2
a4321 2
  {NULL, NULL, 0}		/* end sentinel */
};				/* coff_pseudo_table */
d4327 12
a4338 1
static void coff_pop_insert PARAMS ((void));
d4341 1
a4341 1
coff_pop_insert ()
d4343 1
a4343 1
  pop_insert (coff_pseudo_table);
d4349 2
a4350 2
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
d4352 16
a4367 12
  0,	/* frob_file */
  coff_frob_file_after_relocs,
  0,	/* s_get_size */
  0,	/* s_set_size */
  0,	/* s_get_align */
  0,	/* s_set_align */
  0,	/* s_get_other */
  0,	/* s_get_desc */
  0,	/* copy_symbol_attributes */
  0,	/* generate_asm_lineno */
  0,	/* process_stab */
  0,	/* sec_sym_ok_for_reloc */
d4369 5
a4373 1
  0,	/* ecoff_set_ext */
d4375 1
a4375 1
  coff_obj_symbol_new_hook
@


1.1.1.7
log
@Long delayed import of binutils-2.10.1. Turns out art@@ needs some alpha
bug-fixes...
@
text
@d216 1
a216 1
#ifdef BFD_ASSEMBLER
@


1.1.1.8
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001
a32 7
/* The BFD_ASSEMBLER version of obj_coff_section will use this macro to set
   a new section's attributes when a directive has no valid flags or the
   "w" flag is used. This default should be appropriate for most.  */
#ifndef TC_COFF_SECTION_DEFAULT_ATTRIBUTES
#define TC_COFF_SECTION_DEFAULT_ATTRIBUTES (SEC_LOAD | SEC_DATA)
#endif

d207 1
a207 1

d216 1
a216 1
#if defined BFD_ASSEMBLER || defined S_SET_WEAK
d244 1
a244 1
((char*) (&((X)->sy_symbol.ost_auxent->x_file.x_n.x_offset))[1])
d319 1
a319 1
/* Merge a debug symbol containing debug information into a normal symbol.  */
d343 1
a343 1
  /* Move the debug flags.  */
d349 1
a349 1
     const char *filename;
d404 1
a404 1

d414 1
a414 1

d432 1
a432 1
     addressT offset;
d441 1
a441 5

#ifndef OBJ_XCOFF
  /* The native aix assembler accepts negative line number */

  if (num <= 0)
a446 1
#endif /* OBJ_XCOFF */
d655 1
a655 1
  symbolS *symbolP = NULL;
d666 1
a666 1
  /* Set the section number according to storage class.  */
d681 1
a681 1
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol.  */
d696 1
a696 1
	      case 'b':
d705 1
a705 1
	      case 'e':
d710 1
a710 1
		SA_SET_SYM_LNNO (def_symbol_in_progress,
a727 31

    /* According to the COFF documentation:

       http://osr5doc.sco.com:1996/topics/COFF_SectNumFld.html

       A special section number (-2) marks symbolic debugging symbols,
       including structure/union/enumeration tag names, typedefs, and
       the name of the file. A section number of -1 indicates that the
       symbol has a value but is not relocatable. Examples of
       absolute-valued symbols include automatic and register variables,
       function arguments, and .eos symbols.

       But from Ian Lance Taylor:

       http://sources.redhat.com/ml/binutils/2000-08/msg00202.html

       the actual tools all marked them as section -1. So the GNU COFF
       assembler follows historical COFF assemblers.

       However, it causes problems for djgpp

       http://sources.redhat.com/ml/binutils/2000-08/msg00210.html

       By defining STRICTCOFF, a COFF port can make the assembler to
       follow the documented behavior.  */
#ifdef STRICTCOFF
    case C_MOS:
    case C_MOE:
    case C_MOU:
    case C_EOS:
#endif
a731 1
#ifndef STRICTCOFF
a737 1
#endif
d771 1
a771 1
     the debug symbol is a real function reference.  */
d775 1
a775 1
     time.  */
d806 1
a806 1
	 previous definition.  */
d819 1
a819 1
	     existing symbol to the current place.  */
d849 1
a849 1
	     function...  */
d985 1
a985 1
     This was a bad assumption.  I've added find_or_make. xoxorich.  */
d1068 1
a1068 1
         will be calculated later.  */
d1082 1
a1082 1
  /* These had better be the same.  Usually 18 bytes.  */
d1090 1
a1134 2
	  && S_GET_STORAGE_CLASS (symp) != C_LABEL
	  && symbol_constant_p(symp)
a1139 1
	  return;
d1199 1
a1199 1
      /* more ...  */
d1356 1
a1356 1
  flagword flags, oldflags;
d1378 1
a1378 1
  flags = SEC_NO_FLAGS;
d1395 1
a1395 1
		case 'n': flags &=~ SEC_LOAD; flags |= SEC_NEVER_LOAD; break;
d1423 1
a1423 2
  oldflags = bfd_get_section_flags (stdoutput, sec);
  if (oldflags == SEC_NO_FLAGS)
d1425 1
a1425 4
      /* Set section flags for a new section just created by subseg_new.
         Provide a default if no flags were parsed.  */
      if (flags == SEC_NO_FLAGS)
	flags = TC_COFF_SECTION_DEFAULT_ATTRIBUTES;
d1427 3
a1429 7
#ifdef COFF_LONG_SECTION_NAMES
      /* Add SEC_LINK_ONCE and SEC_LINK_DUPLICATES_DISCARD to .gnu.linkonce
         sections so adjust_reloc_syms in write.c will correctly handle
         relocs which refer to non-local symbols in these sections.  */
      if (strncmp (name, ".gnu.linkonce", sizeof (".gnu.linkonce") - 1) == 0)
        flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
#endif
d1432 3
a1434 12
        as_warn (_("error setting flags for \"%s\": %s"),
                 bfd_section_name (stdoutput, sec),
                 bfd_errmsg (bfd_get_error ()));
    }
  else if (flags != SEC_NO_FLAGS)
    {
      /* This section's attributes have already been set. Warn if the
         attributes don't match.  */
      flagword matchflags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
			     | SEC_DATA | SEC_SHARED | SEC_NEVER_LOAD);
      if ((flags ^ oldflags) & matchflags)
	as_warn (_("Ignoring changed section attributes for %s"), name);
d1462 1
a1462 1
     section alignment, then skip this step, as TICOFF does.  */
d1468 2
a1469 14
      bfd_vma new_size;
      fragS *last;

      new_size = (size + mask) & ~mask;
      bfd_set_section_size (stdoutput, sec, new_size);

      /* If the size had to be rounded up, add some padding in
         the last non-empty frag.  */
      fragp = seg_info (sec)->frchainP->frch_root;
      last = seg_info (sec)->frchainP->frch_last;
      while (fragp->fr_next != last)
        fragp = fragp->fr_next;
      last->fr_address = size;
      fragp->fr_offset += new_size - size;
d1529 1
a1529 1
  /* Make space for this first symbol.  */
d1531 1
a1531 1
  /* Zero it out.  */
d1558 1
a1558 1
      printf (_("0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n"),
d1572 1
a1572 1
/* This is needed because we include internal bfd things.  */
d1619 1
a1619 1
struct filename_list
d1644 1
d1649 1
d1654 1
d1659 1
d1720 1
a1762 1
	case rs_align_test:
d1783 1
d1989 1
d2013 1
a2013 1
	  char *buffer = NULL;
a2073 1
		case rs_align_test:
d2184 1
d2235 1
a2235 1
  /* Store the pointer in the offset.  */
d2363 1
d2378 1
a2378 1
  /* Set the section number according to storage class.  */
d2393 1
a2393 1
      SF_SET_LOCAL (def_symbol_in_progress);	/* Do not emit this symbol.  */
d2414 1
a2414 1
      /* Value is always set to .  */
d2465 1
a2465 1
     symbol is a real function reference.  */
d2469 1
a2469 1
     time.  */
d2495 1
a2495 1
      /* FIXME-SOON Should *def_symbol_in_progress be free'd? xoxorich.  */
d2504 1
a2504 1
	     existing symbol to the current place.  */
d2538 1
a2538 1
	     function...  */
d2685 1
a2685 1
     This was a bad assumption.  I've added find_or_make. xoxorich.  */
d2767 1
a2767 1
	 its value will be calculated later.  */
d2805 1
a2805 1
  /* These had better be the same.  Usually 18 bytes.  */
d2860 1
a2860 1
	  /* L* and C_EFCN symbols never merge.  */
d2869 1
a2869 1
		 Maybe tag references before definitions? xoxorich.  */
d2874 1
a2874 1
		 whereas no pointers refer to the debug symbol.  */
d2912 1
a2912 1
	      /* Handle the nested blocks auxiliary info.  */
d2930 1
a2930 1
	       entry.  */
d2941 1
a2941 1
		  /* Clobber possible stale .dim information.  */
d2974 1
a2974 1
	       the first slot after the structure description.  */
d3014 2
a3015 1
	 endndx will still be 22 instead of 21.  */
d3089 1
d3168 1
a3168 1
  /* Is there a .file symbol ? If not insert one at the beginning.  */
d3179 1
d3275 1
d3292 1
d3295 3
a3297 5
		  /* Turn a pointer to a symbol into the symbols' index,
		     provided that it has been initialised.  */
		  if (line_ptr->line.l_addr.l_symndx)
		    line_ptr->line.l_addr.l_symndx =
		      ((symbolS *) line_ptr->line.l_addr.l_symndx)->sy_number;
d3304 1
d3321 1
d3362 1
d3391 3
a3393 5
      if (subseg_text_p (now_seg))
	frag_align_code (SUB_SEGMENT_ALIGN (now_seg), 0);
      else
	frag_align (SUB_SEGMENT_ALIGN (now_seg), 0, 0);

a3396 1

d3402 1
d3405 1
d3479 1
a3479 1
     correctly.  */
d3540 1
a3540 1
     go is up to Ken..  */
d3686 1
d3694 1
d3736 1
a3736 1
  /* Move the debug flags.  */
d3766 1
d3808 1
a3808 1
      if (filename_list_tail)
d3812 1
a3812 1
      filename_list_tail = f;
d3814 1
a3814 1
  else
d3933 1
a3933 1
	       to the string in memory but must be a file offset.  */
d4004 1
a4004 1
  symbolP = symbol_find_or_make (name);
d4006 2
a4007 2
  if (S_GET_SEGMENT (symbolP) == SEG_UNKNOWN &&
      S_GET_VALUE (symbolP) == 0)
d4021 2
a4022 2
	  S_SET_SEGMENT (symbolP, SEG_E2);
	  S_SET_STORAGE_CLASS (symbolP, C_STAT);
d4026 1
a4026 1
    as_bad (_("Symbol %s already defined"), name);
d4028 1
a4028 1
  demand_empty_rest_of_line ();
a4044 1
	case rs_align_test:
d4115 1
a4115 1
	     point symbol.  */
d4213 1
a4213 1
		 something different for N_UNDF.  */
d4240 1
a4240 1
	      /* Different segments in subtraction.  */
d4249 1
a4249 1
#if 0 /* Okay for 68k, at least...  */
d4309 1
a4309 1
	      pcrel = 0;	/* Lie. Don't want further pcrel processing.  */
d4335 1
d4370 1
a4370 1
		     Philippe De Muyter <phdm@@info.ucl.ac.be>.  */
d4376 1
d4455 1
a4455 1
    }				/* For each fixS in this segment.  */
d4471 1
a4471 1
  /* Make space for this first symbol.  */
d4473 1
a4473 1
  /* Zero it out.  */
d4498 1
a4498 1
  /* Look for the associated string table section.  */
d4515 1
a4515 1
  /* If we found the section, get its size.  */
d4522 1
a4522 1
     symbol, and collect a pointer to it.  */
d4530 1
a4530 1
     table.  */
a4584 1
static int coff_separate_stab_sections PARAMS ((void));
a4591 6
static int
coff_separate_stab_sections ()
{
  return 1;
}

a4596 2
  0,    /* begin */
  c_dot_file_symbol,
a4598 1
  0,	/* frob_file_before_adjust */
a4604 1
  0,	/* s_set_other */
a4605 3
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
a4608 2
  coff_separate_stab_sections,
  obj_coff_init_stab_section,
@


1.1.1.9
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002
a40 21
/* This is used to hold the symbol built by a sequence of pseudo-ops
   from .def and .endef.  */
static symbolS *def_symbol_in_progress;

typedef struct
  {
    unsigned long chunk_size;
    unsigned long element_size;
    unsigned long size;
    char *data;
    unsigned long pointer;
  }
stack;

static stack *stack_init PARAMS ((unsigned long, unsigned long));
static char *stack_push PARAMS ((stack *, char *));
static char *stack_pop PARAMS ((stack *));
static void tag_init PARAMS ((void));
static void tag_insert PARAMS ((const char *, symbolS *));
static symbolS *tag_find PARAMS ((char *));
static symbolS *tag_find_or_make PARAMS ((char *));
a41 1
static void obj_coff_weak PARAMS ((int));
d57 4
d63 9
a248 1
static segT fetch_coff_debug_section PARAMS ((void));
a249 3
static int S_GET_DATA_TYPE PARAMS ((symbolS *));
void c_symbol_merge PARAMS ((symbolS *, symbolS *));
static void add_lineno PARAMS ((fragS *, addressT, int));
d261 1
a261 1
      const asymbol *s;
d496 4
d501 1
a501 3
  /* If there is no lineno symbol, treat a .ln
     directive as if it were a .appline directive.  */
  if (appline || current_lineno_sym == NULL)
a502 2
  else
    add_lineno (frag_now, frag_now_fix (), l);
d558 1
a558 1
	lineno += coff_line_base - 1;
d701 1
a701 1
	const char *name;
d706 1
a706 1
	  {
d832 1
a832 1
				      DO_NOT_STRIP)) == NULL
d837 1
a837 1
	{
d841 1
a841 1
	}
a1136 1
#ifndef OBJ_XCOFF
a1137 1
#endif
d1177 1
a1177 2
      symbolS * real;

a1182 1
	  && S_GET_STORAGE_CLASS (real) == C_NULL
a1188 1

a1201 1

a1210 1

a1217 1

a1220 1

a1227 1

a1238 1

a1289 1
#ifndef OBJ_XCOFF
d1298 1
a1298 1
#endif
d1377 17
a1393 18
/* Implement the .section pseudo op:
  	.section name {, "flags"}
                  ^         ^
                  |         +--- optional flags: 'b' for bss
                  |                              'i' for info
                  +-- section name               'l' for lib
                                                 'n' for noload
                                                 'o' for over
                                                 'w' for data
  						 'd' (apparently m88k for data)
                                                 'x' for text
  						 'r' for read-only data
  						 's' for shared data (PE)
   But if the argument is not a quoted string, treat it as a
   subsegment number.

   Note the 'a' flag is silently ignored.  This allows the same
   .section directive to be parsed in both ELF and COFF formats.  */
a1443 2

		case 's': flags |= SEC_SHARED; /* fall through */
a1445 2

		case 'a': break; /* For compatability with ELF.  */
d1448 1
d1484 1
a1484 1
	flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
d1488 3
a1490 3
	as_warn (_("error setting flags for \"%s\": %s"),
		 bfd_section_name (stdoutput, sec),
		 bfd_errmsg (bfd_get_error ()));
d1544 1
a1544 1
	fragp = fragp->fr_next;
d1611 1
a1611 1
  stabstr_name = (char *) xmalloc (strlen (seg->name) + 4);
d1693 1
a1693 1
/* Structure used to keep the filenames which
d1695 1
a1695 1
   into the string table.  */
d1709 5
a1713 1
   section number into a segment number.  */
d1715 1
a1716 2
static symbolS *previous_file_symbol;
static int line_base;
d1718 20
a1737 13
void c_symbol_merge PARAMS ((symbolS *, symbolS *));
symbolS *c_section_symbol PARAMS ((char *, int));
void obj_coff_section PARAMS ((int));
void do_relocs_for PARAMS ((bfd *, object_headers *, unsigned long *));
char * symbol_to_chars PARAMS ((bfd *, char *, symbolS *));
void w_strings PARAMS ((char *));

static void fixup_segment PARAMS ((segment_info_type *, segT));
static void fixup_mdeps PARAMS ((fragS *, object_headers *, segT));
static void fill_section PARAMS ((bfd *,  object_headers *, unsigned long *));
static int c_line_new PARAMS ((symbolS *, long, int, fragS *));
static void w_symbols PARAMS ((bfd *, char *, symbolS *));
static void adjust_stab_section PARAMS ((bfd *, segT));
d1741 1
a1741 10
static unsigned int count_entries_in_chain PARAMS ((unsigned int));
static void coff_header_append PARAMS ((bfd *, object_headers *));
static unsigned int yank_symbols PARAMS ((void));
static unsigned int glue_symbols PARAMS ((symbolS **, symbolS **));
static unsigned int tie_tags PARAMS ((void));
static void crawl_symbols PARAMS ((object_headers *, bfd *));
static void do_linenos_for PARAMS ((bfd *, object_headers *, unsigned long *));
static void remove_subsegs PARAMS ((void));


a1779 2
static relax_addressT relax_align PARAMS ((relax_addressT, long));

d1800 2
a1801 5
static unsigned int size_section PARAMS ((bfd *, unsigned int));

/* Calculate the size of the frag chain and fill in the section header
   to contain all of it, also fill in the addr of the sections.  */

a1809 1

d1827 1
d1863 1
a1863 1
  /* Count the relocations.  */
d1870 1
a1870 1
#if defined(TC_A29K) || defined(TC_OR32)
d1889 1
a1889 2
/* AUX's ld expects relocations to be sorted.  */

d1904 1
a1904 2
/* Output all the relocations for a section.  */

d1942 1
a1942 1
		  /* Only output some of the relocations.  */
d1948 1
d1980 1
a1980 1
			  resolve_symbol_value (symbol_ptr);
a1992 1

d1995 3
a1997 1
			    intr.r_symndx = dot->sy_number;
d1999 4
a2002 1
			    intr.r_symndx = symbol_ptr->sy_number;
d2005 3
a2007 1
			intr.r_symndx = -1;
d2009 1
d2012 1
d2014 1
d2019 1
d2022 1
a2022 1
			  /* Now emit the second bit.  */
a2028 14
#if defined(TC_OR32)
		      /* The or32 has a special kludge for the high 16 bit
			 reloc.  Two relocations are emited, R_IHIHALF,
			 and R_IHCONST. The second one doesn't contain a
			 symbol, but uses the value for offset.  */
		      if (intr.r_type == R_IHIHALF)
			{
			  /* Now emit the second bit.  */
			  intr.r_type = R_IHCONST;
			  intr.r_symndx = fix_ptr->fx_addnumber;
			  (void) bfd_coff_swap_reloc_out (abfd, & intr, ext_ptr);
			  ext_ptr ++;
			}
#endif
d2033 1
d2035 1
a2035 1
	      /* Sort the reloc table.  */
d2039 4
a2042 3
	      /* Write out the reloc table.  */
	      bfd_bwrite ((PTR) external_reloc_vec,
			  (bfd_size_type) external_reloc_size, abfd);
d2052 1
a2052 1
	      /* No relocs.  */
d2057 1
a2057 2

  /* Set relocation_size field in file headers.  */
d2061 3
a2063 3
/* Run through a frag chain and write out the data to go with it, fill
   in the scnhdrs with the info on the file postions.  */

d2070 1
a2107 1
#ifndef TC_OR32
a2114 1
#endif
d2141 1
d2185 1
a2185 1
		  bfd_bwrite (buffer, s->s_size, abfd);
d2195 1
a2195 1
/* Coff file generation & utilities.  */
d2209 1
a2209 1
  bfd_seek (abfd, (file_ptr) 0, 0);
d2225 2
a2226 2
  bfd_bwrite (buffer, (bfd_size_type) i, abfd);
  bfd_bwrite (buffero, (bfd_size_type) H_GET_SIZEOF_OPTIONAL_HEADER (h), abfd);
d2245 1
d2251 1
a2251 1
	  bfd_bwrite (buffer, (bfd_size_type) size, abfd);
d2266 1
a2266 1
  /* Turn any symbols with register attributes into abs symbols.  */
d2268 4
a2271 1
    S_SET_SEGMENT (symbolP, absolute_section);
a2272 1
  /* At the same time, relocate all symbols to their output value.  */
d2295 1
a2296 1
  return where;
d2303 1
a2303 1
  char underscore = 0;		/* Symbol has leading _  */
d2305 1
a2305 1
  /* Effective symbol.  */
d2311 1
a2311 1
  /* Additional information.  */
d2313 1
a2313 1
  /* Auxiliary entries.  */
d2322 3
a2324 1
/* Handle .ln directives.  */
a2333 1
      /* Wrong context.  */
d2337 1
a2337 1
    }
d2361 13
a2373 8
/* Handle .def directives.
 
  One might ask : why can't we symbol_new if the symbol does not
  already exist and fill it with debug information.  Because of
  the C_EFCN special symbol. It would clobber the value of the
  function symbol before we have a chance to notice that it is
  a C_EFCN. And a second reason is that the code is more clear this
  way. (at least I think it is :-).  */
d2384 3
a2386 3
  char name_end;		/* Char after the end of name.  */
  char *symbol_name;		/* Name of the debug symbol.  */
  char *symbol_name_copy;	/* Temporary copy of the name.  */
d2394 1
a2394 1
    }
d2410 1
a2410 1
  /* Initialize the new symbol.  */
d2446 1
a2446 1
    }
d2455 1
a2455 2
      /* Intentional fallthrough.  */

d2463 2
a2464 4
      /* Do not emit this symbol.  */
      SF_SET_LOCAL (def_symbol_in_progress);
      /* Intentional fallthrough. */
      
d2466 2
a2467 4
      /* Will need processing before writing.  */
      SF_SET_PROCESS (def_symbol_in_progress);
      /* Intentional fallthrough.  */

d2474 3
a2476 2
	    fprintf (stderr, _("`.bf' symbol without preceding function\n"));

a2483 1

d2512 1
a2512 1
      /* Valid but set somewhere else (s_comm, s_lcomm, colon).  */
d2520 1
a2520 1
    }
d2575 1
a2575 1
	  /* If it already is at the end of the symbol list, do nothing.  */
d2582 3
a2584 3
	    }
	}
    }
d2610 2
a2611 2
	}
    }
d2628 1
a2628 1
    }
d2646 1
a2646 2
	  /* Intentional fallthrough.  */

d2681 3
a2683 1
	line_base = this_base;
d2689 3
a2691 1
	  listing_source_line ((unsigned int) line_base);
d2711 1
a2711 1
    }
d2727 1
a2727 1
    }
d2759 3
a2761 1
    as_warn (_("tag not found for .tag %s"), symbol_name);
d2778 1
a2778 1
    }
d2784 3
a2786 1
    SF_SET_FUNCTION (def_symbol_in_progress);
d2800 1
a2800 1
    }
d2815 1
a2815 1
	  /* If the .val is != from the .def (e.g. statics).  */
d2884 1
a2884 1
   externals onto another chain.  */
d2890 1
a2890 1
/* The chain of externals.  */
d2927 1
a2927 1
	  /* Debug symbols do not need all this rubbish.  */
d2946 1
a2946 1
	      /* Replace the current symbol by the real one.  */
d2949 1
a2949 1
		 .text, .data, .bss.  */
d2954 1
a2954 1
	    }
d2957 3
a2959 1
	    S_SET_SEGMENT (symbolP, SEG_E0);
d2961 1
a2961 1
	  resolve_symbol_value (symbolP);
a2968 1

d2970 3
a2972 2
		S_SET_STORAGE_CLASS (symbolP, C_LABEL);

d2974 3
a2976 1
		S_SET_STORAGE_CLASS (symbolP, C_STAT);
d2979 1
a2979 1
	  /* Mainly to speed up if not -g.  */
d2988 2
a2989 4
		    {
		      /* .eb */
		      symbolS *begin_symbolP;

d3007 3
a3009 1
		    S_SET_NUMBER_AUXILIARY (symbolP, 1);
d3013 1
a3013 1
		  /* Iffed out by steve - this fries the lnnoptr info too.  */
d3044 1
a3044 1
	     the first slot after the structure description.  */
d3050 1
a3050 1
	  /* +2 take in account the current symbol.  */
d3056 1
a3056 1
	     auxent, put it in the string table.  */
d3068 2
a3069 2
	    }
	}
d3088 2
a3089 2
	  /* Remove C_EFCN and LOCAL (L...) symbols.  */
	  /* Next pointer remains valid.  */
d3109 1
a3109 1
	  /* If external, Remove from the list.  */
d3131 1
d3148 1
a3148 1
	    }
d3152 3
a3154 2
	}
    }
a3155 1
  return symbol_number;
d3169 1
a3169 1
      /* Append.  */
d3173 1
a3173 1
      /* Process.  */
a3180 1
	  /* Fix "long" names.  */
d3182 1
a3182 1
	}
d3186 1
a3186 1
    }
a3213 1

d3221 1
a3221 1
  /* Initialize the stack used to keep track of the matching .bb .be.  */
d3226 9
a3234 8
     order :
     . .file symbol
     . debug entries for functions
     . fake symbols for the sections, including .text .data and .bss
     . defined symbols
     . undefined symbols
     But this is not mandatory. The only important point is to put the
     undefined symbols at the end of the list.  */
d3239 3
a3241 1
    c_dot_file_symbol ("fake");
d3243 3
a3245 1
  /* Build up static symbols for the sections, they are filled in later.  */
d3249 1
a3249 1
      segment_info[i].dot = c_section_symbol ((char *) segment_info[i].name,
d3252 1
a3252 1
  /* Take all the externals out and put them into another chain.  */
d3254 1
a3254 1
  /* Take the externals and glue them onto the end.  */
d3269 3
a3271 1
/* Find strings by crawling along symbol table chain.  */
d3280 1
a3280 1
  /* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK.  */
d3352 1
a3352 1
	     form, take this chance to remove duplicates.  */
d3367 3
a3369 1
		line_ptr->line.l_addr.l_paddr += ((struct frag *) (line_ptr->frag))->fr_address;
d3373 1
d3378 1
a3378 1
	  bfd_bwrite (buffer, (bfd_size_type) s->scnhdr.s_nlnno * LINESZ, abfd);
a3383 1

d3389 1
a3389 1
   list, as if the seg 0 was extra long.  */
a3413 14

#ifndef SUB_SEGMENT_ALIGN
#ifdef HANDLE_ALIGN
/* The last subsegment gets an aligment corresponding to the alignment
   of the section.  This allows proper nop-filling at the end of
   code-bearing sections.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
   ? get_recorded_alignment (SEG) : 0)
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 1
#endif
#endif

a3436 4
  /* Run through all the sub-segments and align them up.  Also
     close any open frags.  We tack a .fill onto the end of the
     frag chain so that any .align's size can be worked by looking
     at the next frag.  */
d3441 4
a3444 1
      int alignment;
d3448 3
a3450 2
      alignment = SUB_SEGMENT_ALIGN (now_seg, frchain_ptr);

d3452 2
a3453 1
      md_do_align (alignment, (char *) NULL, 0, 0, alignment_done);
d3456 1
a3456 1
	frag_align_code (alignment, 0);
d3458 1
a3458 1
	frag_align (alignment, 0, 0);
d3472 3
a3474 4
    relax_segment (segment_info[i].frchainP->frch_root, i);

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;
d3525 1
a3525 1
  /* Turn the gas native symbol table shape into a coff symbol table.  */
d3559 2
a3560 1
  /* Plant the data.  */
d3598 1
a3598 2
    bfd_bwrite (buffer1, (bfd_size_type) symtable_size + string_byte_count,
		abfd);
d3606 1
a3606 1
  if (!bfd_close_all_done (abfd))
d3654 16
a3669 14
/* Implement the .section pseudo op:
  	.section name {, "flags"}
                  ^         ^
                  |         +--- optional flags: 'b' for bss
                  |                              'i' for info
                  +-- section name               'l' for lib
                                                 'n' for noload
                                                 'o' for over
                                                 'w' for data
  						 'd' (apparently m88k for data)
                                                 'x' for text
  						 'r' for read-only data
   But if the argument is not a quoted string, treat it as a
   subsegment number.  */
d3675 1
a3675 1
  /* Strip out the section name.  */
d3772 1
a3772 1
  segT current_seg = now_seg;		/* Save current seg.  */
d3774 3
a3776 4

  subseg_new (".comment", 0);		/* .comment seg.  */
  stringer (1);				/* Read string.  */
  subseg_set (current_seg, current_subseg);	/* Restore current seg.  */
d3788 3
a3790 1
    S_SET_NUMBER_AUXILIARY (normal, S_GET_NUMBER_AUXILIARY (debug));
d3793 5
a3797 3
    memcpy ((char *) &normal->sy_symbol.ost_auxent[0],
	    (char *) &debug->sy_symbol.ost_auxent[0],
	    (unsigned int) (S_GET_NUMBER_AUXILIARY (debug) * AUXESZ));
d3801 1
a3801 1
}
d3830 3
a3832 1
    s->lineno_list_head = new_line;
d3834 3
a3836 2
    s->lineno_list_tail->next = new_line;

d3860 1
a3860 1
	 them later.  */
d3884 4
a3887 1
      listing_source_file (filename);
d3889 1
d3896 1
a3896 1
  /* Make sure that the symbol is first on the symbol chain.  */
d3902 1
a3902 1
}
d3904 3
a3906 1
/* Build a 'section static' symbol.  */
d3966 1
a3966 1
}
d3977 1
a3977 1
  /* First fill in those values we have only just worked out.  */
d3989 3
a3991 1
  /* Emit all symbols left in the symbol chain.  */
d3995 2
a3996 2
	 to the string in memory but must be a file offset.  */
      char *temp;
d4002 4
a4005 2
	SA_GET_SYM_LNNOPTR (symbolP) +=
	  segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_lnnoptr;
d4023 2
a4024 1
}
d4074 1
a4074 1
	  segT current_seg = now_seg; 	/* Save current seg.  */
d4082 1
a4082 1
	  subseg_set (current_seg, current_subseg); /* Restore current seg.  */
d4096 2
a4097 2
     fragS *frags;
     object_headers *h ATTRIBUTE_UNUSED;
a4100 1

d4139 3
a4141 3
  fixS * fixP;
  symbolS *add_symbolP;
  symbolS *sub_symbolP;
d4143 6
a4148 6
  int size;
  char *place;
  long where;
  char pcrel;
  fragS *fragP;
  segT add_symbol_segment = absolute_section;
d4194 1
a4194 1
	resolve_symbol_value (add_symbolP);
d4224 1
a4224 1
	resolve_symbol_value (sub_symbolP);
d4236 3
a4238 1
	add_symbol_segment = S_GET_SEGMENT (add_symbolP);
d4269 1
a4269 1
		 and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE.  */
d4281 4
a4284 2
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("callj to difference of 2 symbols"));
d4307 3
a4309 2
		add_number -= S_GET_VALUE (sub_symbolP);

d4333 1
a4333 1
		}
d4335 1
a4335 1
	}
d4341 5
a4345 3
	      /* This fixup was made when the symbol's segment was
	         SEG_UNKNOWN, but it is now in the local segment.
	         So we know how to do the address without relocation.  */
d4348 4
a4351 3
	         in which cases it modifies *fixP as appropriate.  In the case
	         of a 'calls', no further work is required, and *fixP has been
	         set up to make the rest of the code below a no-op.  */
d4385 1
a4385 2
		  /* See comment about reloc_callj() above.  */
		  reloc_callj (fixP);
d4398 1
a4398 1
#if defined(TC_A29K) || (defined(TE_PE) && defined(TC_I386)) || defined(TC_M88K) || defined(TC_OR32)
d4413 4
a4416 3
		         13-bit displacement and are only to be used
		         for local branches: flag as error, don't generate
		         relocation.  */
d4422 1
a4422 1
		    }
d4438 3
a4440 3
		}
	    }
	}
d4444 1
a4444 1
#if !defined(TC_M88K) && !(defined(TE_PE) && defined(TC_I386)) && !defined(TC_A29K) && !defined(TC_OR32)
d4450 3
a4452 1
	    fixP->fx_addsy = &abs_symbol;
d4472 1
a4472 1
	}
d4474 5
a4478 1
      md_apply_fix3 (fixP, (valueT *) & add_number, this_segment_type);
d4515 3
a4517 3
	}
    }
}
d4634 2
a4635 2
#if defined( TC_M88K ) || defined ( TC_TIC4X )
  /* The m88k and tic4x uses sdef instead of def.  */
a4669 1
  0,	/* frob_file_before_fix */
@


1.1.1.10
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d146 1
a146 1
 * Maintain a list of the tagnames of the structures.
d1475 1
a1475 1
		case 'a': break; /* For compatibility with ELF.  */
d1477 1
a1477 1
		case 'r': flags |= SEC_DATA | SEC_LOAD | SEC_READONLY; break;
d2041 1
a2041 1
			 reloc.  Two relocations are emitted, R_IHIHALF,
d2055 1
a2055 1
			 reloc.  Two relocations are emitted, R_IHIHALF,
d2099 1
a2099 1
   in the scnhdrs with the info on the file positions.  */
d2967 1
a2967 1
		 real symbol. Do NOT do the opposite (i.e. move from
d3431 1
a3431 1
/* The last subsegment gets an alignment corresponding to the alignment
@


