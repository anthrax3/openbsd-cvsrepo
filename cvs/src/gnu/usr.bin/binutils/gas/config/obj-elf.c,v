head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.26;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.46;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.34.37;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.08;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.57;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.57;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.19;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.14.18;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.22.39;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.46.19;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.33.13;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.27;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.48;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* ELF object file format
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2,
   or (at your option) any later version.

   GAS is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#define OBJ_HEADER "obj-elf.h"
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "obstack.h"
#include "struc-symbol.h"
#include "dwarf2dbg.h"

#ifndef ECOFF_DEBUGGING
#define ECOFF_DEBUGGING 0
#else
#define NEED_ECOFF_DEBUG
#endif

#ifdef NEED_ECOFF_DEBUG
#include "ecoff.h"
#endif

#ifdef TC_ALPHA
#include "elf/alpha.h"
#endif

#ifdef TC_MIPS
#include "elf/mips.h"
#endif

#ifdef TC_PPC
#include "elf/ppc.h"
#endif

#ifdef TC_I370
#include "elf/i370.h"
#endif

static void obj_elf_line (int);
static void obj_elf_size (int);
static void obj_elf_type (int);
static void obj_elf_ident (int);
static void obj_elf_weak (int);
static void obj_elf_local (int);
static void obj_elf_visibility (int);
static void obj_elf_symver (int);
static void obj_elf_subsection (int);
static void obj_elf_popsection (int);
static void obj_elf_tls_common (int);
static void obj_elf_lcomm (int);

static const pseudo_typeS elf_pseudo_table[] =
{
  {"comm", obj_elf_common, 0},
  {"common", obj_elf_common, 1},
  {"ident", obj_elf_ident, 0},
  {"lcomm", obj_elf_lcomm, 0},
  {"local", obj_elf_local, 0},
  {"previous", obj_elf_previous, 0},
  {"section", obj_elf_section, 0},
  {"section.s", obj_elf_section, 0},
  {"sect", obj_elf_section, 0},
  {"sect.s", obj_elf_section, 0},
  {"pushsection", obj_elf_section, 1},
  {"popsection", obj_elf_popsection, 0},
  {"size", obj_elf_size, 0},
  {"type", obj_elf_type, 0},
  {"version", obj_elf_version, 0},
  {"weak", obj_elf_weak, 0},

  /* These define symbol visibility.  */
  {"internal", obj_elf_visibility, STV_INTERNAL},
  {"hidden", obj_elf_visibility, STV_HIDDEN},
  {"protected", obj_elf_visibility, STV_PROTECTED},

  /* These are used for stabs-in-elf configurations.  */
  {"line", obj_elf_line, 0},

  /* This is a GNU extension to handle symbol versions.  */
  {"symver", obj_elf_symver, 0},

  /* A GNU extension to change subsection only.  */
  {"subsection", obj_elf_subsection, 0},

  /* These are GNU extensions to aid in garbage collecting C++ vtables.  */
  {"vtable_inherit", (void (*) (int)) &obj_elf_vtable_inherit, 0},
  {"vtable_entry", (void (*) (int)) &obj_elf_vtable_entry, 0},

  /* These are used for dwarf.  */
  {"2byte", cons, 2},
  {"4byte", cons, 4},
  {"8byte", cons, 8},
  /* These are used for dwarf2.  */
  { "file", (void (*) (int)) dwarf2_directive_file, 0 },
  { "loc",  dwarf2_directive_loc,  0 },

  /* We need to trap the section changing calls to handle .previous.  */
  {"data", obj_elf_data, 0},
  {"text", obj_elf_text, 0},

  {"tls_common", obj_elf_tls_common, 0},

  /* End sentinel.  */
  {NULL, NULL, 0},
};

static const pseudo_typeS ecoff_debug_pseudo_table[] =
{
#ifdef NEED_ECOFF_DEBUG
  /* COFF style debugging information for ECOFF. .ln is not used; .loc
     is used instead.  */
  { "def",	ecoff_directive_def,	0 },
  { "dim",	ecoff_directive_dim,	0 },
  { "endef",	ecoff_directive_endef,	0 },
  { "file",	ecoff_directive_file,	0 },
  { "scl",	ecoff_directive_scl,	0 },
  { "tag",	ecoff_directive_tag,	0 },
  { "val",	ecoff_directive_val,	0 },

  /* COFF debugging requires pseudo-ops .size and .type, but ELF
     already has meanings for those.  We use .esize and .etype
     instead.  These are only generated by gcc anyhow.  */
  { "esize",	ecoff_directive_size,	0 },
  { "etype",	ecoff_directive_type,	0 },

  /* ECOFF specific debugging information.  */
  { "begin",	ecoff_directive_begin,	0 },
  { "bend",	ecoff_directive_bend,	0 },
  { "end",	ecoff_directive_end,	0 },
  { "ent",	ecoff_directive_ent,	0 },
  { "fmask",	ecoff_directive_fmask,	0 },
  { "frame",	ecoff_directive_frame,	0 },
  { "loc",	ecoff_directive_loc,	0 },
  { "mask",	ecoff_directive_mask,	0 },

  /* Other ECOFF directives.  */
  { "extern",	ecoff_directive_extern,	0 },

  /* These are used on Irix.  I don't know how to implement them.  */
  { "alias",	s_ignore,		0 },
  { "bgnb",	s_ignore,		0 },
  { "endb",	s_ignore,		0 },
  { "lab",	s_ignore,		0 },
  { "noalias",	s_ignore,		0 },
  { "verstamp",	s_ignore,		0 },
  { "vreg",	s_ignore,		0 },
#endif

  {NULL, NULL, 0}			/* end sentinel */
};

#undef NO_RELOC
#include "aout/aout64.h"

/* This is called when the assembler starts.  */

void
elf_begin (void)
{
  asection *s;

  /* Add symbols for the known sections to the symbol table.  */
  s = bfd_get_section_by_name (stdoutput, TEXT_SECTION_NAME);
  symbol_table_insert (section_symbol (s));
  s = bfd_get_section_by_name (stdoutput, DATA_SECTION_NAME);
  symbol_table_insert (section_symbol (s));
  s = bfd_get_section_by_name (stdoutput, BSS_SECTION_NAME);
  symbol_table_insert (section_symbol (s));
}

void
elf_pop_insert (void)
{
  pop_insert (elf_pseudo_table);
  if (ECOFF_DEBUGGING)
    pop_insert (ecoff_debug_pseudo_table);
}

static bfd_vma
elf_s_get_size (symbolS *sym)
{
  return S_GET_SIZE (sym);
}

static void
elf_s_set_size (symbolS *sym, bfd_vma sz)
{
  S_SET_SIZE (sym, sz);
}

static bfd_vma
elf_s_get_align (symbolS *sym)
{
  return S_GET_ALIGN (sym);
}

static void
elf_s_set_align (symbolS *sym, bfd_vma align)
{
  S_SET_ALIGN (sym, align);
}

int
elf_s_get_other (symbolS *sym)
{
  return elf_symbol (symbol_get_bfdsym (sym))->internal_elf_sym.st_other;
}

static void
elf_s_set_other (symbolS *sym, int other)
{
  S_SET_OTHER (sym, other);
}

static int
elf_sec_sym_ok_for_reloc (asection *sec)
{
  return obj_sec_sym_ok_for_reloc (sec);
}

void
elf_file_symbol (const char *s)
{
  symbolS *sym;

  sym = symbol_new (s, absolute_section, 0, NULL);
  symbol_set_frag (sym, &zero_address_frag);
  symbol_get_bfdsym (sym)->flags |= BSF_FILE;

  if (symbol_rootP != sym)
    {
      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_insert (sym, symbol_rootP, &symbol_rootP, &symbol_lastP);
#ifdef DEBUG
      verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif
    }

#ifdef NEED_ECOFF_DEBUG
  ecoff_new_file (s);
#endif
}

/* Called from read.c:s_comm after we've parsed .comm symbol, size.
   Parse a possible alignment value.  */

static symbolS *
elf_common_parse (int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT size)
{
  addressT align = 0;
  int is_local = symbol_get_obj (symbolP)->local;

  if (*input_line_pointer == ',')
    {
      char *save = input_line_pointer;

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '"')
	{
	  /* For sparc.  Accept .common symbol, length, "bss"  */
	  input_line_pointer++;
	  /* Some use the dot, some don't.  */
	  if (*input_line_pointer == '.')
	    input_line_pointer++;
	  /* Some say data, some say bss.  */
	  if (strncmp (input_line_pointer, "bss\"", 4) == 0)
	    input_line_pointer += 4;
	  else if (strncmp (input_line_pointer, "data\"", 5) == 0)
	    input_line_pointer += 5;
	  else
	    {
	      char *p = input_line_pointer;
	      char c;

	      while (*--p != '"')
		;
	      while (!is_end_of_line[(unsigned char) *input_line_pointer])
		if (*input_line_pointer++ == '"')
		  break;
	      c = *input_line_pointer;
	      *input_line_pointer = '\0';
	      as_bad (_("bad .common segment %s"), p);
	      *input_line_pointer = c;
	      ignore_rest_of_line ();
	      return NULL;
	    }
	  /* ??? Don't ask me why these are always global.  */
	  is_local = 0;
	}
      else
	{
	  input_line_pointer = save;
	  align = parse_align (is_local);
	  if (align == (addressT) -1)
	    return NULL;
	}
    }

  if (is_local)
    {
      bss_alloc (symbolP, size, align);
      S_CLEAR_EXTERNAL (symbolP);
    }
  else
    {
      S_SET_VALUE (symbolP, size);
      S_SET_ALIGN (symbolP, align);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
    }

  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  return symbolP;
}

void
obj_elf_common (int is_common)
{
  if (flag_mri && is_common)
    s_mri_common (0);
  else
    s_comm_internal (0, elf_common_parse);
}

static void
obj_elf_tls_common (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = s_comm_internal (0, elf_common_parse);

  if (symbolP)
    symbol_get_bfdsym (symbolP)->flags |= BSF_THREAD_LOCAL;
}

static void
obj_elf_lcomm (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = s_comm_internal (0, s_lcomm_internal);

  if (symbolP)
    symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
}

static void
obj_elf_local (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  int c;
  symbolS *symbolP;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();
      S_CLEAR_EXTERNAL (symbolP);
      symbol_get_obj (symbolP)->local = 1;
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');
  demand_empty_rest_of_line ();
}

static void
obj_elf_weak (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  int c;
  symbolS *symbolP;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();
      S_SET_WEAK (symbolP);
      symbol_get_obj (symbolP)->local = 1;
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');
  demand_empty_rest_of_line ();
}

static void
obj_elf_visibility (int visibility)
{
  char *name;
  int c;
  symbolS *symbolP;
  asymbol *bfdsym;
  elf_symbol_type *elfsym;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;

      SKIP_WHITESPACE ();

      bfdsym = symbol_get_bfdsym (symbolP);
      elfsym = elf_symbol_from (bfd_asymbol_bfd (bfdsym), bfdsym);

      assert (elfsym);

      elfsym->internal_elf_sym.st_other &= ~3;
      elfsym->internal_elf_sym.st_other |= visibility;

      if (c == ',')
	{
	  input_line_pointer ++;

	  SKIP_WHITESPACE ();

	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

static segT previous_section;
static int previous_subsection;

struct section_stack
{
  struct section_stack *next;
  segT seg, prev_seg;
  int subseg, prev_subseg;
};

static struct section_stack *section_stack;

/* Handle the .section pseudo-op.  This code supports two different
   syntaxes.

   The first is found on Solaris, and looks like
       .section ".sec1",#alloc,#execinstr,#write
   Here the names after '#' are the SHF_* flags to turn on for the
   section.  I'm not sure how it determines the SHT_* type (BFD
   doesn't really give us control over the type, anyhow).

   The second format is found on UnixWare, and probably most SVR4
   machines, and looks like
       .section .sec1,"a",@@progbits
   The quoted string may contain any combination of a, w, x, and
   represents the SHF_* flags to turn on for the section.  The string
   beginning with '@@' can be progbits or nobits.  There should be
   other possibilities, but I don't know what they are.  In any case,
   BFD doesn't really let us set the section type.  */

void
obj_elf_change_section (const char *name,
			int type,
			int attr,
			int entsize,
			const char *group_name,
			int linkonce,
			int push)
{
  asection *old_sec;
  segT sec;
  flagword flags;
  const struct bfd_elf_special_section *ssect;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  /* Switch to the section, creating it if necessary.  */
  if (push)
    {
      struct section_stack *elt;
      elt = xmalloc (sizeof (struct section_stack));
      elt->next = section_stack;
      elt->seg = now_seg;
      elt->prev_seg = previous_section;
      elt->subseg = now_subseg;
      elt->prev_subseg = previous_subsection;
      section_stack = elt;
    }
  previous_section = now_seg;
  previous_subsection = now_subseg;

  old_sec = bfd_get_section_by_name (stdoutput, name);
  sec = subseg_new (name, 0);
  ssect = _bfd_elf_get_sec_type_attr (stdoutput, name);

  if (ssect != NULL)
    {
      bfd_boolean override = FALSE;

      if (type == SHT_NULL)
	type = ssect->type;
      else if (type != ssect->type)
	{
	  if (old_sec == NULL
	      /* FIXME: gcc, as of 2002-10-22, will emit

		 .section .init_array,"aw",@@progbits

		 for __attribute__ ((section (".init_array"))).
		 "@@progbits" is incorrect.  */
	      && ssect->type != SHT_INIT_ARRAY
	      && ssect->type != SHT_FINI_ARRAY
	      && ssect->type != SHT_PREINIT_ARRAY)
	    {
	      /* We allow to specify any type for a .note section.  */
	      if (ssect->type != SHT_NOTE)
		as_warn (_("setting incorrect section type for %s"),
			 name);
	    }
	  else
	    {
	      as_warn (_("ignoring incorrect section type for %s"),
		       name);
	      type = ssect->type;
	    }
	}

      if (old_sec == NULL && (attr & ~ssect->attr) != 0)
	{
	  /* As a GNU extension, we permit a .note section to be
	     allocatable.  If the linker sees an allocatable .note
	     section, it will create a PT_NOTE segment in the output
	     file.  We also allow "x" for .note.GNU-stack.  */
	  if (ssect->type == SHT_NOTE
	      && (attr == SHF_ALLOC || attr == SHF_EXECINSTR))
	    ;
	  /* Allow different SHF_MERGE and SHF_STRINGS if we have
	     something like .rodata.str.  */
	  else if (ssect->suffix_length == -2
		   && name[ssect->prefix_length] == '.'
		   && (attr
		       & ~ssect->attr
		       & ~SHF_MERGE
		       & ~SHF_STRINGS) == 0)
	    ;
	  /* .interp, .strtab and .symtab can have SHF_ALLOC.  */
	  else if (attr == SHF_ALLOC
		   && (strcmp (name, ".interp") == 0
		       || strcmp (name, ".strtab") == 0
		       || strcmp (name, ".symtab") == 0))
	    override = TRUE;
	  else
	    {
	      as_warn (_("setting incorrect section attributes for %s"),
		       name);
	      override = TRUE;
	    }
	}
      if (!override && old_sec == NULL)
	attr |= ssect->attr;
    }

  if (type != SHT_NULL)
    elf_section_type (sec) = type;
  if (attr != 0)
    elf_section_flags (sec) = attr;

  /* Convert ELF type and flags to BFD flags.  */
  flags = (SEC_RELOC
	   | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
	   | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	   | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
	   | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0)
	   | ((attr & SHF_MERGE) ? SEC_MERGE : 0)
	   | ((attr & SHF_STRINGS) ? SEC_STRINGS : 0)
	   | ((attr & SHF_TLS) ? SEC_THREAD_LOCAL : 0));
#ifdef md_elf_section_flags
  flags = md_elf_section_flags (flags, attr, type);
#endif

  if (old_sec == NULL)
    {
      symbolS *secsym;

      /* Prevent SEC_HAS_CONTENTS from being inadvertently set.  */
      if (type == SHT_NOBITS)
	seg_info (sec)->bss = 1;

      if (linkonce)
	flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
      bfd_set_section_flags (stdoutput, sec, flags);
      if (flags & SEC_MERGE)
	sec->entsize = entsize;
      elf_group_name (sec) = group_name;

      /* Add a symbol for this section to the symbol table.  */
      secsym = symbol_find (name);
      if (secsym != NULL)
	symbol_set_bfdsym (secsym, sec->symbol);
      else
	symbol_table_insert (section_symbol (sec));
    }
  else if (attr != 0)
    {
      /* If section attributes are specified the second time we see a
	 particular section, then check that they are the same as we
	 saw the first time.  */
      if (((old_sec->flags ^ flags)
	   & (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	      | SEC_EXCLUDE | SEC_SORT_ENTRIES | SEC_MERGE | SEC_STRINGS
	      | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
	      | SEC_THREAD_LOCAL)))
	as_warn (_("ignoring changed section attributes for %s"), name);
      if ((flags & SEC_MERGE) && old_sec->entsize != (unsigned) entsize)
	as_warn (_("ignoring changed section entity size for %s"), name);
      if ((attr & SHF_GROUP) != 0
	  && strcmp (elf_group_name (old_sec), group_name) != 0)
	as_warn (_("ignoring new section group for %s"), name);
    }

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static int
obj_elf_parse_section_letters (char *str, size_t len)
{
  int attr = 0;

  while (len > 0)
    {
      switch (*str)
	{
	case 'a':
	  attr |= SHF_ALLOC;
	  break;
	case 'w':
	  attr |= SHF_WRITE;
	  break;
	case 'x':
	  attr |= SHF_EXECINSTR;
	  break;
	case 'M':
	  attr |= SHF_MERGE;
	  break;
	case 'S':
	  attr |= SHF_STRINGS;
	  break;
	case 'G':
	  attr |= SHF_GROUP;
	  break;
	case 'T':
	  attr |= SHF_TLS;
	  break;
	/* Compatibility.  */
	case 'm':
	  if (*(str - 1) == 'a')
	    {
	      attr |= SHF_MERGE;
	      if (len > 1 && str[1] == 's')
		{
		  attr |= SHF_STRINGS;
		  str++, len--;
		}
	      break;
	    }
	default:
	  {
	    char *bad_msg = _("unrecognized .section attribute: want a,w,x,M,S,G,T");
#ifdef md_elf_section_letter
	    int md_attr = md_elf_section_letter (*str, &bad_msg);
	    if (md_attr >= 0)
	      attr |= md_attr;
	    else
#endif
	      as_fatal ("%s", bad_msg);
	  }
	  break;
	}
      str++, len--;
    }

  return attr;
}

static int
obj_elf_section_word (char *str, size_t len)
{
  if (len == 5 && strncmp (str, "write", 5) == 0)
    return SHF_WRITE;
  if (len == 5 && strncmp (str, "alloc", 5) == 0)
    return SHF_ALLOC;
  if (len == 9 && strncmp (str, "execinstr", 9) == 0)
    return SHF_EXECINSTR;
  if (len == 3 && strncmp (str, "tls", 3) == 0)
    return SHF_TLS;

#ifdef md_elf_section_word
  {
    int md_attr = md_elf_section_word (str, len);
    if (md_attr >= 0)
      return md_attr;
  }
#endif

  as_warn (_("unrecognized section attribute"));
  return 0;
}

static int
obj_elf_section_type (char *str, size_t len)
{
  if (len == 8 && strncmp (str, "progbits", 8) == 0)
    return SHT_PROGBITS;
  if (len == 6 && strncmp (str, "nobits", 6) == 0)
    return SHT_NOBITS;
  if (len == 4 && strncmp (str, "note", 4) == 0)
    return SHT_NOTE;

#ifdef md_elf_section_type
  {
    int md_type = md_elf_section_type (str, len);
    if (md_type >= 0)
      return md_type;
  }
#endif

  as_warn (_("unrecognized section type"));
  return 0;
}

/* Get name of section.  */
static char *
obj_elf_section_name (void)
{
  char *name;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      int dummy;

      name = demand_copy_C_string (&dummy);
      if (name == NULL)
	{
	  ignore_rest_of_line ();
	  return NULL;
	}
    }
  else
    {
      char *end = input_line_pointer;

      while (0 == strchr ("\n\t,; ", *end))
	end++;
      if (end == input_line_pointer)
	{
	  as_bad (_("missing name"));
	  ignore_rest_of_line ();
	  return NULL;
	}

      name = xmalloc (end - input_line_pointer + 1);
      memcpy (name, input_line_pointer, end - input_line_pointer);
      name[end - input_line_pointer] = '\0';
#ifdef tc_canonicalize_section_name
      name = tc_canonicalize_section_name (name);
#endif
      input_line_pointer = end;
    }
  SKIP_WHITESPACE ();
  return name;
}

void
obj_elf_section (int push)
{
  char *name, *group_name, *beg;
  int type, attr, dummy;
  int entsize;
  int linkonce;

#ifndef TC_I370
  if (flag_mri)
    {
      char mri_type;

#ifdef md_flush_pending_output
      md_flush_pending_output ();
#endif

      previous_section = now_seg;
      previous_subsection = now_subseg;

      s_mri_sect (&mri_type);

#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif

      return;
    }
#endif /* ! defined (TC_I370) */

  name = obj_elf_section_name ();
  if (name == NULL)
    return;
  type = SHT_NULL;
  attr = 0;
  group_name = NULL;
  entsize = 0;
  linkonce = 0;

  if (*input_line_pointer == ',')
    {
      /* Skip the comma.  */
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '"')
	{
	  beg = demand_copy_C_string (&dummy);
	  if (beg == NULL)
	    {
	      ignore_rest_of_line ();
	      return;
	    }
	  attr |= obj_elf_parse_section_letters (beg, strlen (beg));

	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      char c;
	      char *save = input_line_pointer;

	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      c = *input_line_pointer;
	      if (c == '"')
		{
		  beg = demand_copy_C_string (&dummy);
		  if (beg == NULL)
		    {
		      ignore_rest_of_line ();
		      return;
		    }
		  type = obj_elf_section_type (beg, strlen (beg));
		}
	      else if (c == '@@' || c == '%')
		{
		  beg = ++input_line_pointer;
		  c = get_symbol_end ();
		  *input_line_pointer = c;
		  type = obj_elf_section_type (beg, input_line_pointer - beg);
		}
	      else
		input_line_pointer = save;
	    }

	  SKIP_WHITESPACE ();
	  if ((attr & SHF_MERGE) != 0 && *input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      entsize = get_absolute_expression ();
	      SKIP_WHITESPACE ();
	      if (entsize < 0)
		{
		  as_warn (_("invalid merge entity size"));
		  attr &= ~SHF_MERGE;
		  entsize = 0;
		}
	    }
	  else if ((attr & SHF_MERGE) != 0)
	    {
	      as_warn (_("entity size for SHF_MERGE not specified"));
	      attr &= ~SHF_MERGE;
	    }

	  if ((attr & SHF_GROUP) != 0 && *input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      group_name = obj_elf_section_name ();
	      if (group_name == NULL)
		attr &= ~SHF_GROUP;
	      else if (strncmp (input_line_pointer, ",comdat", 7) == 0)
		{
		  input_line_pointer += 7;
		  linkonce = 1;
		}
	      else if (strncmp (name, ".gnu.linkonce", 13) == 0)
		linkonce = 1;
	    }
	  else if ((attr & SHF_GROUP) != 0)
	    {
	      as_warn (_("group name for SHF_GROUP not specified"));
	      attr &= ~SHF_GROUP;
	    }
	}
      else
	{
	  do
	    {
	      char c;

	      SKIP_WHITESPACE ();
	      if (*input_line_pointer != '#')
		{
		  as_bad (_("character following name is not '#'"));
		  ignore_rest_of_line ();
		  return;
		}
	      beg = ++input_line_pointer;
	      c = get_symbol_end ();
	      *input_line_pointer = c;

	      attr |= obj_elf_section_word (beg, input_line_pointer - beg);

	      SKIP_WHITESPACE ();
	    }
	  while (*input_line_pointer++ == ',');
	  --input_line_pointer;
	}
    }

  demand_empty_rest_of_line ();

  obj_elf_change_section (name, type, attr, entsize, group_name, linkonce, push);
}

/* Change to the .data section.  */

void
obj_elf_data (int i)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  previous_section = now_seg;
  previous_subsection = now_subseg;
  s_data (i);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* Change to the .text section.  */

void
obj_elf_text (int i)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  previous_section = now_seg;
  previous_subsection = now_subseg;
  s_text (i);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_subsection (int ignore ATTRIBUTE_UNUSED)
{
  register int temp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  previous_section = now_seg;
  previous_subsection = now_subseg;

  temp = get_absolute_expression ();
  subseg_set (now_seg, (subsegT) temp);
  demand_empty_rest_of_line ();

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* This can be called from the processor backends if they change
   sections.  */

void
obj_elf_section_change_hook (void)
{
  previous_section = now_seg;
  previous_subsection = now_subseg;
}

void
obj_elf_previous (int ignore ATTRIBUTE_UNUSED)
{
  segT new_section;
  int new_subsection;

  if (previous_section == 0)
    {
      as_warn (_(".previous without corresponding .section; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  new_section = previous_section;
  new_subsection = previous_subsection;
  previous_section = now_seg;
  previous_subsection = now_subseg;
  subseg_set (new_section, new_subsection);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_popsection (int xxx ATTRIBUTE_UNUSED)
{
  struct section_stack *top = section_stack;

  if (top == NULL)
    {
      as_warn (_(".popsection without corresponding .pushsection; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  section_stack = top->next;
  previous_section = top->prev_seg;
  previous_subsection = top->prev_subseg;
  subseg_set (top->seg, top->subseg);
  free (top);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_line (int ignore ATTRIBUTE_UNUSED)
{
  /* Assume delimiter is part of expression.  BSD4.2 as fails with
     delightful bug, so we are not being incompatible here.  */
  new_logical_line (NULL, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

/* This handles the .symver pseudo-op, which is used to specify a
   symbol version.  The syntax is ``.symver NAME,SYMVERNAME''.
   SYMVERNAME may contain ELF_VER_CHR ('@@') characters.  This
   pseudo-op causes the assembler to emit a symbol named SYMVERNAME
   with the same value as the symbol NAME.  */

static void
obj_elf_symver (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char old_lexat;
  symbolS *sym;

  name = input_line_pointer;
  c = get_symbol_end ();

  sym = symbol_find_or_make (name);

  *input_line_pointer = c;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .symver"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();
  name = input_line_pointer;

  /* Temporarily include '@@' in symbol names.  */
  old_lexat = lex_type[(unsigned char) '@@'];
  lex_type[(unsigned char) '@@'] |= LEX_NAME;
  c = get_symbol_end ();
  lex_type[(unsigned char) '@@'] = old_lexat;

  if (symbol_get_obj (sym)->versioned_name == NULL)
    {
      symbol_get_obj (sym)->versioned_name = xstrdup (name);

      *input_line_pointer = c;

      if (strchr (symbol_get_obj (sym)->versioned_name,
		  ELF_VER_CHR) == NULL)
	{
	  as_bad (_("missing version name in `%s' for symbol `%s'"),
		  symbol_get_obj (sym)->versioned_name,
		  S_GET_NAME (sym));
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    {
      if (strcmp (symbol_get_obj (sym)->versioned_name, name))
	{
	  as_bad (_("multiple versions [`%s'|`%s'] for symbol `%s'"),
		  name, symbol_get_obj (sym)->versioned_name,
		  S_GET_NAME (sym));
	  ignore_rest_of_line ();
	  return;
	}

      *input_line_pointer = c;
    }

  demand_empty_rest_of_line ();
}

/* This handles the .vtable_inherit pseudo-op, which is used to indicate
   to the linker the hierarchy in which a particular table resides.  The
   syntax is ".vtable_inherit CHILDNAME, PARENTNAME".  */

struct fix *
obj_elf_vtable_inherit (int ignore ATTRIBUTE_UNUSED)
{
  char *cname, *pname;
  symbolS *csym, *psym;
  char c, bad = 0;

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  cname = input_line_pointer;
  c = get_symbol_end ();
  csym = symbol_find (cname);

  /* GCFIXME: should check that we don't have two .vtable_inherits for
     the same child symbol.  Also, we can currently only do this if the
     child symbol is already exists and is placed in a fragment.  */

  if (csym == NULL || symbol_get_frag (csym) == NULL)
    {
      as_bad ("expected `%s' to have already been set for .vtable_inherit",
	      cname);
      bad = 1;
    }

  *input_line_pointer = c;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after name in .vtable_inherit");
      ignore_rest_of_line ();
      return NULL;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  if (input_line_pointer[0] == '0'
      && (input_line_pointer[1] == '\0'
	  || ISSPACE (input_line_pointer[1])))
    {
      psym = section_symbol (absolute_section);
      ++input_line_pointer;
    }
  else
    {
      pname = input_line_pointer;
      c = get_symbol_end ();
      psym = symbol_find_or_make (pname);
      *input_line_pointer = c;
    }

  demand_empty_rest_of_line ();

  if (bad)
    return NULL;

  assert (symbol_get_value_expression (csym)->X_op == O_constant);
  return fix_new (symbol_get_frag (csym),
		  symbol_get_value_expression (csym)->X_add_number,
		  0, psym, 0, 0, BFD_RELOC_VTABLE_INHERIT);
}

/* This handles the .vtable_entry pseudo-op, which is used to indicate
   to the linker that a vtable slot was used.  The syntax is
   ".vtable_entry tablename, offset".  */

struct fix *
obj_elf_vtable_entry (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  symbolS *sym;
  offsetT offset;
  char c;

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  name = input_line_pointer;
  c = get_symbol_end ();
  sym = symbol_find_or_make (name);
  *input_line_pointer = c;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after name in .vtable_entry");
      ignore_rest_of_line ();
      return NULL;
    }

  ++input_line_pointer;
  if (*input_line_pointer == '#')
    ++input_line_pointer;

  offset = get_absolute_expression ();

  demand_empty_rest_of_line ();

  return fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
		  BFD_RELOC_VTABLE_ENTRY);
}

void
elf_obj_read_begin_hook (void)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_read_begin_hook ();
#endif
}

void
elf_obj_symbol_new_hook (symbolS *symbolP)
{
  struct elf_obj_sy *sy_obj;

  sy_obj = symbol_get_obj (symbolP);
  sy_obj->size = NULL;
  sy_obj->versioned_name = NULL;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_symbol_new_hook (symbolP);
#endif
}

/* When setting one symbol equal to another, by default we probably
   want them to have the same "size", whatever it means in the current
   context.  */

void
elf_copy_symbol_attributes (symbolS *dest, symbolS *src)
{
  struct elf_obj_sy *srcelf = symbol_get_obj (src);
  struct elf_obj_sy *destelf = symbol_get_obj (dest);
  if (srcelf->size)
    {
      if (destelf->size == NULL)
	destelf->size = xmalloc (sizeof (expressionS));
      *destelf->size = *srcelf->size;
    }
  else
    {
      if (destelf->size != NULL)
	free (destelf->size);
      destelf->size = NULL;
    }
  S_SET_SIZE (dest, S_GET_SIZE (src));
  /* Don't copy visibility.  */
  S_SET_OTHER (dest, (ELF_ST_VISIBILITY (S_GET_OTHER (dest))
		      | (S_GET_OTHER (src) & ~ELF_ST_VISIBILITY (-1))));
}

void
obj_elf_version (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  unsigned int c;
  char *p;
  asection *seg = now_seg;
  subsegT subseg = now_subseg;
  Elf_Internal_Note i_note;
  Elf_External_Note e_note;
  asection *note_secp = NULL;
  int len;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '\"')
    {
      ++input_line_pointer;	/* -> 1st char of string.  */
      name = input_line_pointer;

      while (is_a_char (c = next_char_of_string ()))
	;
      c = *input_line_pointer;
      *input_line_pointer = '\0';
      *(input_line_pointer - 1) = '\0';
      *input_line_pointer = c;

      /* create the .note section */

      note_secp = subseg_new (".note", 0);
      bfd_set_section_flags (stdoutput,
			     note_secp,
			     SEC_HAS_CONTENTS | SEC_READONLY);

      /* process the version string */

      len = strlen (name);

      i_note.namesz = ((len + 1) + 3) & ~3; /* round this to word boundary */
      i_note.descsz = 0;	/* no description */
      i_note.type = NT_VERSION;
      p = frag_more (sizeof (e_note.namesz));
      md_number_to_chars (p, i_note.namesz, sizeof (e_note.namesz));
      p = frag_more (sizeof (e_note.descsz));
      md_number_to_chars (p, i_note.descsz, sizeof (e_note.descsz));
      p = frag_more (sizeof (e_note.type));
      md_number_to_chars (p, i_note.type, sizeof (e_note.type));
      p = frag_more (len + 1);
      strcpy (p, name);

      frag_align (2, 0, 0);

      subseg_set (seg, subseg);
    }
  else
    {
      as_bad (_("expected quoted string"));
    }
  demand_empty_rest_of_line ();
}

static void
obj_elf_size (int ignore ATTRIBUTE_UNUSED)
{
  char *name = input_line_pointer;
  char c = get_symbol_end ();
  char *p;
  expressionS exp;
  symbolS *sym;

  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      *p = 0;
      as_bad (_("expected comma after name `%s' in .size directive"), name);
      *p = c;
      ignore_rest_of_line ();
      return;
    }
  input_line_pointer++;
  expression (&exp);
  if (exp.X_op == O_absent)
    {
      as_bad (_("missing expression in .size directive"));
      exp.X_op = O_constant;
      exp.X_add_number = 0;
    }
  *p = 0;
  sym = symbol_find_or_make (name);
  *p = c;
  if (exp.X_op == O_constant)
    {
      S_SET_SIZE (sym, exp.X_add_number);
      if (symbol_get_obj (sym)->size)
	{
	  xfree (symbol_get_obj (sym)->size);
	  symbol_get_obj (sym)->size = NULL;
	}
    }
  else
    {
      symbol_get_obj (sym)->size = xmalloc (sizeof (expressionS));
      *symbol_get_obj (sym)->size = exp;
    }
  demand_empty_rest_of_line ();
}

/* Handle the ELF .type pseudo-op.  This sets the type of a symbol.
   There are five syntaxes:

   The first (used on Solaris) is
       .type SYM,#function
   The second (used on UnixWare) is
       .type SYM,@@function
   The third (reportedly to be used on Irix 6.0) is
       .type SYM STT_FUNC
   The fourth (used on NetBSD/Arm and Linux/ARM) is
       .type SYM,%function
   The fifth (used on SVR4/860) is
       .type SYM,"function"
   */

static void
obj_elf_type (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  int type;
  const char *typename;
  symbolS *sym;
  elf_symbol_type *elfsym;

  name = input_line_pointer;
  c = get_symbol_end ();
  sym = symbol_find_or_make (name);
  elfsym = (elf_symbol_type *) symbol_get_bfdsym (sym);
  *input_line_pointer = c;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    ++input_line_pointer;

  SKIP_WHITESPACE ();
  if (   *input_line_pointer == '#'
      || *input_line_pointer == '@@'
      || *input_line_pointer == '"'
      || *input_line_pointer == '%')
    ++input_line_pointer;

  typename = input_line_pointer;
  c = get_symbol_end ();

  type = 0;
  if (strcmp (typename, "function") == 0
      || strcmp (typename, "STT_FUNC") == 0)
    type = BSF_FUNCTION;
  else if (strcmp (typename, "object") == 0
	   || strcmp (typename, "STT_OBJECT") == 0)
    type = BSF_OBJECT;
  else if (strcmp (typename, "tls_object") == 0
	   || strcmp (typename, "STT_TLS") == 0)
    type = BSF_OBJECT | BSF_THREAD_LOCAL;
  else if (strcmp (typename, "notype") == 0
	   || strcmp (typename, "STT_NOTYPE") == 0)
    ;
#ifdef md_elf_symbol_type
  else if ((type = md_elf_symbol_type (typename, sym, elfsym)) != -1)
    ;
#endif
  else
    as_bad (_("unrecognized symbol type \"%s\""), typename);

  *input_line_pointer = c;

  if (*input_line_pointer == '"')
    ++input_line_pointer;

  elfsym->symbol.flags |= type;

  demand_empty_rest_of_line ();
}

static void
obj_elf_ident (int ignore ATTRIBUTE_UNUSED)
{
  static segT comment_section;
  segT old_section = now_seg;
  int old_subsection = now_subseg;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (!comment_section)
    {
      char *p;
      comment_section = subseg_new (".comment", 0);
      bfd_set_section_flags (stdoutput, comment_section,
			     SEC_READONLY | SEC_HAS_CONTENTS);
      p = frag_more (1);
      *p = 0;
    }
  else
    subseg_set (comment_section, 0);
  stringer (1);
  subseg_set (old_section, old_subsection);
}

#ifdef INIT_STAB_SECTION

/* The first entry in a .stabs section is special.  */

void
obj_elf_init_stab_section (segT seg)
{
  char *file;
  char *p;
  char *stabstr_name;
  unsigned int stroff;

  /* Force the section to align to a longword boundary.  Without this,
     UnixWare ar crashes.  */
  bfd_set_section_alignment (stdoutput, seg, 2);

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  as_where (&file, NULL);
  stabstr_name = xmalloc (strlen (segment_name (seg)) + 4);
  strcpy (stabstr_name, segment_name (seg));
  strcat (stabstr_name, "str");
  stroff = get_stab_string_offset (file, stabstr_name);
  know (stroff == 1);
  md_number_to_chars (p, stroff, 4);
  seg_info (seg)->stabu.p = p;
}

#endif

/* Fill in the counts in the first entry in a .stabs section.  */

static void
adjust_stab_sections (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)
{
  char *name;
  asection *strsec;
  char *p;
  int strsz, nsyms;

  if (strncmp (".stab", sec->name, 5))
    return;
  if (!strcmp ("str", sec->name + strlen (sec->name) - 3))
    return;

  name = alloca (strlen (sec->name) + 4);
  strcpy (name, sec->name);
  strcat (name, "str");
  strsec = bfd_get_section_by_name (abfd, name);
  if (strsec)
    strsz = bfd_section_size (abfd, strsec);
  else
    strsz = 0;
  nsyms = bfd_section_size (abfd, sec) / 12 - 1;

  p = seg_info (sec)->stabu.p;
  assert (p != 0);

  bfd_h_put_16 (abfd, nsyms, p + 6);
  bfd_h_put_32 (abfd, strsz, p + 8);
}

#ifdef NEED_ECOFF_DEBUG

/* This function is called by the ECOFF code.  It is supposed to
   record the external symbol information so that the backend can
   write it out correctly.  The ELF backend doesn't actually handle
   this at the moment, so we do it ourselves.  We save the information
   in the symbol.  */

void
elf_ecoff_set_ext (symbolS *sym, struct ecoff_extr *ext)
{
  symbol_get_bfdsym (sym)->udata.p = ext;
}

/* This function is called by bfd_ecoff_debug_externals.  It is
   supposed to *EXT to the external symbol information, and return
   whether the symbol should be used at all.  */

static bfd_boolean
elf_get_extr (asymbol *sym, EXTR *ext)
{
  if (sym->udata.p == NULL)
    return FALSE;
  *ext = *(EXTR *) sym->udata.p;
  return TRUE;
}

/* This function is called by bfd_ecoff_debug_externals.  It has
   nothing to do for ELF.  */

static void
elf_set_index (asymbol *sym ATTRIBUTE_UNUSED,
	       bfd_size_type indx ATTRIBUTE_UNUSED)
{
}

#endif /* NEED_ECOFF_DEBUG */

void
elf_frob_symbol (symbolS *symp, int *puntp)
{
  struct elf_obj_sy *sy_obj;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_frob_symbol (symp);
#endif

  sy_obj = symbol_get_obj (symp);

  if (sy_obj->size != NULL)
    {
      switch (sy_obj->size->X_op)
	{
	case O_subtract:
	  S_SET_SIZE (symp,
		      (S_GET_VALUE (sy_obj->size->X_add_symbol)
		       + sy_obj->size->X_add_number
		       - S_GET_VALUE (sy_obj->size->X_op_symbol)));
	  break;
	case O_constant:
	  S_SET_SIZE (symp,
		      (S_GET_VALUE (sy_obj->size->X_add_symbol)
		       + sy_obj->size->X_add_number));
	  break;
	default:
	  as_bad (_(".size expression too complicated to fix up"));
	  break;
	}
      free (sy_obj->size);
      sy_obj->size = NULL;
    }

  if (sy_obj->versioned_name != NULL)
    {
      char *p;

      p = strchr (sy_obj->versioned_name, ELF_VER_CHR);
      know (p != NULL);

      /* This symbol was given a new name with the .symver directive.

	 If this is an external reference, just rename the symbol to
	 include the version string.  This will make the relocs be
	 against the correct versioned symbol.

	 If this is a definition, add an alias.  FIXME: Using an alias
	 will permit the debugging information to refer to the right
	 symbol.  However, it's not clear whether it is the best
	 approach.  */

      if (! S_IS_DEFINED (symp))
	{
	  /* Verify that the name isn't using the @@@@ syntax--this is
	     reserved for definitions of the default version to link
	     against.  */
	  if (p[1] == ELF_VER_CHR)
	    {
	      as_bad (_("invalid attempt to declare external version name as default in symbol `%s'"),
		      sy_obj->versioned_name);
	      *puntp = TRUE;
	    }
	  S_SET_NAME (symp, sy_obj->versioned_name);
	}
      else
	{
	  if (p[1] == ELF_VER_CHR && p[2] == ELF_VER_CHR)
	    {
	      size_t l;

	      /* The @@@@@@ syntax is a special case. It renames the
		 symbol name to versioned_name with one `@@' removed.  */
	      l = strlen (&p[3]) + 1;
	      memmove (&p[2], &p[3], l);
	      S_SET_NAME (symp, sy_obj->versioned_name);
	    }
	  else
	    {
	      symbolS *symp2;

	      /* FIXME: Creating a new symbol here is risky.  We're
		 in the final loop over the symbol table.  We can
		 get away with it only because the symbol goes to
		 the end of the list, where the loop will still see
		 it.  It would probably be better to do this in
		 obj_frob_file_before_adjust.  */

	      symp2 = symbol_find_or_make (sy_obj->versioned_name);

	      /* Now we act as though we saw symp2 = sym.  */

	      S_SET_SEGMENT (symp2, S_GET_SEGMENT (symp));

	      /* Subtracting out the frag address here is a hack
		 because we are in the middle of the final loop.  */
	      S_SET_VALUE (symp2,
			   (S_GET_VALUE (symp)
			    - symbol_get_frag (symp)->fr_address));

	      symbol_set_frag (symp2, symbol_get_frag (symp));

	      /* This will copy over the size information.  */
	      copy_symbol_attributes (symp2, symp);

	      S_SET_OTHER (symp2, S_GET_OTHER (symp));

	      if (S_IS_WEAK (symp))
		S_SET_WEAK (symp2);

	      if (S_IS_EXTERNAL (symp))
		S_SET_EXTERNAL (symp2);
	    }
	}
    }

  /* Double check weak symbols.  */
  if (S_IS_WEAK (symp))
    {
      if (S_IS_COMMON (symp))
	as_bad (_("symbol `%s' can not be both weak and common"),
		S_GET_NAME (symp));
    }

#ifdef TC_MIPS
  /* The Irix 5 and 6 assemblers set the type of any common symbol and
     any undefined non-function symbol to STT_OBJECT.  We try to be
     compatible, since newer Irix 5 and 6 linkers care.  However, we
     only set undefined symbols to be STT_OBJECT if we are on Irix,
     because that is the only time gcc will generate the necessary
     .global directives to mark functions.  */

  if (S_IS_COMMON (symp))
    symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;

  if (strstr (TARGET_OS, "irix") != NULL
      && ! S_IS_DEFINED (symp)
      && (symbol_get_bfdsym (symp)->flags & BSF_FUNCTION) == 0)
    symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;
#endif

#if 0 /* TC_PPC */
  /* If TC_PPC is defined, we used to force the type of a symbol to be
     BSF_OBJECT if it was otherwise unset.  This was required by some
     version of VxWorks.  Thomas de Lellis <tdel@@windriver.com> says
     that this is no longer needed, so it is now commented out.  */
  if ((symbol_get_bfdsym (symp)->flags
       & (BSF_FUNCTION | BSF_FILE | BSF_SECTION_SYM)) == 0
      && S_IS_DEFINED (symp))
    symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;
#endif
}

struct group_list
{
  asection **head;		/* Section lists.  */
  unsigned int *elt_count;	/* Number of sections in each list.  */
  unsigned int num_group;	/* Number of lists.  */
};

/* Called via bfd_map_over_sections.  If SEC is a member of a group,
   add it to a list of sections belonging to the group.  INF is a
   pointer to a struct group_list, which is where we store the head of
   each list.  */

static void
build_group_lists (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
{
  struct group_list *list = inf;
  const char *group_name = elf_group_name (sec);
  unsigned int i;

  if (group_name == NULL)
    return;

  /* If this group already has a list, add the section to the head of
     the list.  */
  for (i = 0; i < list->num_group; i++)
    {
      if (strcmp (group_name, elf_group_name (list->head[i])) == 0)
	{
	  elf_next_in_group (sec) = list->head[i];
	  list->head[i] = sec;
	  list->elt_count[i] += 1;
	  return;
	}
    }

  /* New group.  Make the arrays bigger in chunks to minimize calls to
     realloc.  */
  i = list->num_group;
  if ((i & 127) == 0)
    {
      unsigned int newsize = i + 128;
      list->head = xrealloc (list->head, newsize * sizeof (*list->head));
      list->elt_count = xrealloc (list->elt_count,
				  newsize * sizeof (*list->elt_count));
    }
  list->head[i] = sec;
  list->elt_count[i] = 1;
  list->num_group += 1;
}

void
elf_frob_file (void)
{
  struct group_list list;
  unsigned int i;

  bfd_map_over_sections (stdoutput, adjust_stab_sections, NULL);

  /* Go find section groups.  */
  list.num_group = 0;
  list.head = NULL;
  list.elt_count = NULL;
  bfd_map_over_sections (stdoutput, build_group_lists, &list);

  /* Make the SHT_GROUP sections that describe each section group.  We
     can't set up the section contents here yet, because elf section
     indices have yet to be calculated.  elf.c:set_group_contents does
     the rest of the work.  */
  for (i = 0; i < list.num_group; i++)
    {
      const char *group_name = elf_group_name (list.head[i]);
      const char *sec_name;
      asection *s;
      flagword flags;
      struct symbol *sy;
      int has_sym;

      flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP;
      for (s = list.head[i]; s != NULL; s = elf_next_in_group (s))
	if ((s->flags ^ flags) & SEC_LINK_ONCE)
	  {
	    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
	    if (s != list.head[i])
	      {
		as_warn (_("assuming all members of group `%s' are COMDAT"),
			 group_name);
		break;
	      }
	  }

      sec_name = group_name;
      sy = symbol_find_exact (group_name);
      has_sym = 0;
      if (sy != NULL
	  && (sy == symbol_lastP
	      || (sy->sy_next != NULL
		  && sy->sy_next->sy_previous == sy)))
	{
	  has_sym = 1;
	  sec_name = ".group";
	}
      s = subseg_force_new (sec_name, 0);
      if (s == NULL
	  || !bfd_set_section_flags (stdoutput, s, flags)
	  || !bfd_set_section_alignment (stdoutput, s, 2))
	{
	  as_fatal (_("can't create group: %s"),
		    bfd_errmsg (bfd_get_error ()));
	}
      elf_section_type (s) = SHT_GROUP;

      /* Pass a pointer to the first section in this group.  */
      elf_next_in_group (s) = list.head[i];
      if (has_sym)
	elf_group_id (s) = sy->bsym;

      s->_raw_size = 4 * (list.elt_count[i] + 1);
      s->contents = frag_more (s->_raw_size);
      frag_now->fr_fix = frag_now_fix_octets ();
    }

#ifdef elf_tc_final_processing
  elf_tc_final_processing ();
#endif
}

/* It removes any unneeded versioned symbols from the symbol table.  */

void
elf_frob_file_before_adjust (void)
{
  if (symbol_rootP)
    {
      symbolS *symp;

      for (symp = symbol_rootP; symp; symp = symbol_next (symp))
	if (!S_IS_DEFINED (symp))
	  {
	    if (symbol_get_obj (symp)->versioned_name)
	      {
		char *p;

		/* The @@@@@@ syntax is a special case. If the symbol is
		   not defined, 2 `@@'s will be removed from the
		   versioned_name.  */

		p = strchr (symbol_get_obj (symp)->versioned_name,
			    ELF_VER_CHR);
		know (p != NULL);
		if (p[1] == ELF_VER_CHR && p[2] == ELF_VER_CHR)
		  {
		    size_t l = strlen (&p[3]) + 1;
		    memmove (&p[1], &p[3], l);
		  }
		if (symbol_used_p (symp) == 0
		    && symbol_used_in_reloc_p (symp) == 0)
		  symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	      }

	    /* If there was .weak foo, but foo was neither defined nor
	       used anywhere, remove it.  */

	    else if (S_IS_WEAK (symp)
		     && symbol_used_p (symp) == 0
		     && symbol_used_in_reloc_p (symp) == 0)
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	  }
    }
}

/* It is required that we let write_relocs have the opportunity to
   optimize away fixups before output has begun, since it is possible
   to eliminate all fixups for a section and thus we never should
   have generated the relocation section.  */

void
elf_frob_file_after_relocs (void)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    /* Generate the ECOFF debugging information.  */
    {
      const struct ecoff_debug_swap *debug_swap;
      struct ecoff_debug_info debug;
      char *buf;
      asection *sec;

      debug_swap
	= get_elf_backend_data (stdoutput)->elf_backend_ecoff_debug_swap;
      know (debug_swap != NULL);
      ecoff_build_debug (&debug.symbolic_header, &buf, debug_swap);

      /* Set up the pointers in debug.  */
#define SET(ptr, offset, type) \
    debug.ptr = (type) (buf + debug.symbolic_header.offset)

      SET (line, cbLineOffset, unsigned char *);
      SET (external_dnr, cbDnOffset, void *);
      SET (external_pdr, cbPdOffset, void *);
      SET (external_sym, cbSymOffset, void *);
      SET (external_opt, cbOptOffset, void *);
      SET (external_aux, cbAuxOffset, union aux_ext *);
      SET (ss, cbSsOffset, char *);
      SET (external_fdr, cbFdOffset, void *);
      SET (external_rfd, cbRfdOffset, void *);
      /* ssext and external_ext are set up just below.  */

#undef SET

      /* Set up the external symbols.  */
      debug.ssext = debug.ssext_end = NULL;
      debug.external_ext = debug.external_ext_end = NULL;
      if (! bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, TRUE,
				       elf_get_extr, elf_set_index))
	as_fatal (_("failed to set up debugging information: %s"),
		  bfd_errmsg (bfd_get_error ()));

      sec = bfd_get_section_by_name (stdoutput, ".mdebug");
      assert (sec != NULL);

      know (!stdoutput->output_has_begun);

      /* We set the size of the section, call bfd_set_section_contents
	 to force the ELF backend to allocate a file position, and then
	 write out the data.  FIXME: Is this really the best way to do
	 this?  */
      sec->_raw_size = bfd_ecoff_debug_size (stdoutput, &debug, debug_swap);

      /* Pass BUF to bfd_set_section_contents because this will
	 eventually become a call to fwrite, and ISO C prohibits
	 passing a NULL pointer to a stdio function even if the
	 pointer will not be used.  */
      if (! bfd_set_section_contents (stdoutput, sec, buf, 0, 0))
	as_fatal (_("can't start writing .mdebug section: %s"),
		  bfd_errmsg (bfd_get_error ()));

      know (stdoutput->output_has_begun);
      know (sec->filepos != 0);

      if (! bfd_ecoff_write_debug (stdoutput, &debug, debug_swap,
				   sec->filepos))
	as_fatal (_("could not write .mdebug section: %s"),
		  bfd_errmsg (bfd_get_error ()));
    }
#endif /* NEED_ECOFF_DEBUG */
}

#ifdef SCO_ELF

/* Heavily plagiarized from obj_elf_version.  The idea is to emit the
   SCO specific identifier in the .notes section to satisfy the SCO
   linker.

   This looks more complicated than it really is.  As opposed to the
   "obvious" solution, this should handle the cross dev cases
   correctly.  (i.e, hosting on a 64 bit big endian processor, but
   generating SCO Elf code) Efficiency isn't a concern, as there
   should be exactly one of these sections per object module.

   SCO OpenServer 5 identifies it's ELF modules with a standard ELF
   .note section.

   int_32 namesz  = 4 ;  Name size
   int_32 descsz  = 12 ; Descriptive information
   int_32 type    = 1 ;
   char   name[4] = "SCO" ; Originator name ALWAYS SCO + NULL
   int_32 version = (major ver # << 16)  | version of tools ;
   int_32 source  = (tool_id << 16 ) | 1 ;
   int_32 info    = 0 ;    These are set by the SCO tools, but we
			   don't know enough about the source
			   environment to set them.  SCO ld currently
			   ignores them, and recommends we set them
			   to zero.  */

#define SCO_MAJOR_VERSION 0x1
#define SCO_MINOR_VERSION 0x1

void
sco_id (void)
{

  char *name;
  unsigned int c;
  char ch;
  char *p;
  asection *seg = now_seg;
  subsegT subseg = now_subseg;
  Elf_Internal_Note i_note;
  Elf_External_Note e_note;
  asection *note_secp = NULL;
  int i, len;

  /* create the .note section */

  note_secp = subseg_new (".note", 0);
  bfd_set_section_flags (stdoutput,
			 note_secp,
			 SEC_HAS_CONTENTS | SEC_READONLY);

  /* process the version string */

  i_note.namesz = 4;
  i_note.descsz = 12;		/* 12 descriptive bytes */
  i_note.type = NT_VERSION;	/* Contains a version string */

  p = frag_more (sizeof (i_note.namesz));
  md_number_to_chars (p, i_note.namesz, 4);

  p = frag_more (sizeof (i_note.descsz));
  md_number_to_chars (p, i_note.descsz, 4);

  p = frag_more (sizeof (i_note.type));
  md_number_to_chars (p, i_note.type, 4);

  p = frag_more (4);
  strcpy (p, "SCO");

  /* Note: this is the version number of the ELF we're representing */
  p = frag_more (4);
  md_number_to_chars (p, (SCO_MAJOR_VERSION << 16) | (SCO_MINOR_VERSION), 4);

  /* Here, we pick a magic number for ourselves (yes, I "registered"
     it with SCO.  The bottom bit shows that we are compat with the
     SCO ABI.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x4c520000 | 0x0001, 4);

  /* If we knew (or cared) what the source language options were, we'd
     fill them in here.  SCO has given us permission to ignore these
     and just set them to zero.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x0000, 4);

  frag_align (2, 0, 0);

  /* We probably can't restore the current segment, for there likely
     isn't one yet...  */
  if (seg && subseg)
    subseg_set (seg, subseg);

}

#endif /* SCO_ELF */

static int
elf_separate_stab_sections (void)
{
#ifdef NEED_ECOFF_DEBUG
  return (!ECOFF_DEBUGGING);
#else
  return 1;
#endif
}

static void
elf_init_stab_section (segT seg)
{
#ifdef NEED_ECOFF_DEBUG
  if (!ECOFF_DEBUGGING)
#endif
    obj_elf_init_stab_section (seg);
}

const struct format_ops elf_format_ops =
{
  bfd_target_elf_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  elf_begin,
  elf_file_symbol,
  elf_frob_symbol,
  elf_frob_file,
  elf_frob_file_before_adjust,
  0,	/* obj_frob_file_before_fix */
  elf_frob_file_after_relocs,
  elf_s_get_size, elf_s_set_size,
  elf_s_get_align, elf_s_set_align,
  elf_s_get_other,
  elf_s_set_other,
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  elf_copy_symbol_attributes,
#ifdef NEED_ECOFF_DEBUG
  ecoff_generate_asm_lineno,
  ecoff_stab,
#else
  0,	/* generate_asm_lineno */
  0,	/* process_stab */
#endif
  elf_separate_stab_sections,
  elf_init_stab_section,
  elf_sec_sym_ok_for_reloc,
  elf_pop_insert,
#ifdef NEED_ECOFF_DEBUG
  elf_ecoff_set_ext,
#else
  0,	/* ecoff_set_ext */
#endif
  elf_obj_read_begin_hook,
  elf_obj_symbol_new_hook
};
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d28 1
d56 12
a67 33
static bfd_vma elf_s_get_size PARAMS ((symbolS *));
static void elf_s_set_size PARAMS ((symbolS *, bfd_vma));
static bfd_vma elf_s_get_align PARAMS ((symbolS *));
static void elf_s_set_align PARAMS ((symbolS *, bfd_vma));
static void elf_s_set_other PARAMS ((symbolS *, int));
static int elf_sec_sym_ok_for_reloc PARAMS ((asection *));
static void adjust_stab_sections PARAMS ((bfd *, asection *, PTR));
static void build_group_lists PARAMS ((bfd *, asection *, PTR));
static int elf_separate_stab_sections PARAMS ((void));
static void elf_init_stab_section PARAMS ((segT));
static symbolS *elf_common PARAMS ((int));

#ifdef NEED_ECOFF_DEBUG
static bfd_boolean elf_get_extr PARAMS ((asymbol *, EXTR *));
static void elf_set_index PARAMS ((asymbol *, bfd_size_type));
#endif

static void obj_elf_line PARAMS ((int));
void obj_elf_version PARAMS ((int));
static void obj_elf_size PARAMS ((int));
static void obj_elf_type PARAMS ((int));
static void obj_elf_ident PARAMS ((int));
static void obj_elf_weak PARAMS ((int));
static void obj_elf_local PARAMS ((int));
static void obj_elf_visibility PARAMS ((int));
static int obj_elf_parse_section_letters PARAMS ((char *, size_t));
static int obj_elf_section_word PARAMS ((char *, size_t));
static char *obj_elf_section_name PARAMS ((void));
static int obj_elf_section_type PARAMS ((char *, size_t));
static void obj_elf_symver PARAMS ((int));
static void obj_elf_subsection PARAMS ((int));
static void obj_elf_popsection PARAMS ((int));
static void obj_elf_tls_common PARAMS ((int));
d74 1
d103 2
a104 2
  {"vtable_inherit", (void (*) PARAMS ((int))) &obj_elf_vtable_inherit, 0},
  {"vtable_entry", (void (*) PARAMS ((int))) &obj_elf_vtable_entry, 0},
d110 3
d175 1
a175 1
elf_begin ()
d177 2
d180 6
a185 6
  symbol_table_insert (section_symbol (bfd_get_section_by_name (stdoutput,
								TEXT_SECTION_NAME)));
  symbol_table_insert (section_symbol (bfd_get_section_by_name (stdoutput,
								DATA_SECTION_NAME)));
  symbol_table_insert (section_symbol (bfd_get_section_by_name (stdoutput,
								BSS_SECTION_NAME)));
d189 1
a189 1
elf_pop_insert ()
d197 1
a197 2
elf_s_get_size (sym)
     symbolS *sym;
d203 1
a203 3
elf_s_set_size (sym, sz)
     symbolS *sym;
     bfd_vma sz;
d209 1
a209 2
elf_s_get_align (sym)
     symbolS *sym;
d215 1
a215 3
elf_s_set_align (sym, align)
     symbolS *sym;
     bfd_vma align;
d221 1
a221 2
elf_s_get_other (sym)
     symbolS *sym;
d227 1
a227 3
elf_s_set_other (sym, other)
     symbolS *sym;
     int other;
d233 1
a233 2
elf_sec_sym_ok_for_reloc (sec)
     asection *sec;
d239 1
a239 2
elf_file_symbol (s)
     const char *s;
d243 1
a243 1
  sym = symbol_new (s, absolute_section, (valueT) 0, (struct frag *) 0);
d261 3
d265 1
a265 2
elf_common (is_common)
     int is_common;
d267 2
a268 7
  char *name;
  char c;
  char *p;
  offsetT temp, size, sign;
  symbolS *symbolP;
  int have_align;
  expressionS exp;
d270 1
a270 1
  if (flag_mri && is_common)
d272 1
a272 3
      s_mri_common (0);
      return NULL;
    }
a273 46
  name = input_line_pointer;
  c = get_symbol_end ();
  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after symbol-name"));
      ignore_rest_of_line ();
      return NULL;
    }
  input_line_pointer++;		/* skip ',' */
  temp = get_absolute_expr (&exp);
  sign = (offsetT) 1 << (stdoutput->arch_info->bits_per_address - 1);
  size = temp & ((sign << 1) - 1);
  if (temp != size || !exp.X_unsigned)
    {
      as_bad (_(".COMMon length (%ld) out of range, ignored."), (long) temp);
      ignore_rest_of_line ();
      return NULL;
    }
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));
      ignore_rest_of_line ();
      return NULL;
    }
  if (S_GET_VALUE (symbolP) != 0)
    {
      if (S_GET_VALUE (symbolP) != (valueT) size)
	{
	  as_warn (_("length of .comm \"%s\" is already %ld; not changed to %ld"),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP),
		   (long) size);
	}
    }
  know (symbolP->sy_frag == &zero_address_frag);
  if (*input_line_pointer != ',')
    have_align = 0;
  else
    {
      have_align = 1;
d276 2
a277 6
    }
  if (! have_align || *input_line_pointer != '"')
    {
      if (! have_align)
	temp = 0;
      else
d279 11
a289 2
	  temp = get_absolute_expr (&exp);
	  if (!exp.X_unsigned)
d291 14
a304 24
	      temp = 0;
	      as_warn (_("common alignment negative; 0 assumed"));
	    }
	}
      if (symbol_get_obj (symbolP)->local)
	{
	  segT old_sec;
	  int old_subsec;
	  char *pfrag;
	  int align;

	/* allocate_bss: */
	  old_sec = now_seg;
	  old_subsec = now_subseg;
	  if (temp)
	    {
	      /* convert to a power of 2 alignment */
	      for (align = 0; (temp & 1) == 0; temp >>= 1, ++align);
	      if (temp != 1)
		{
		  as_bad (_("common alignment not a power of 2"));
		  ignore_rest_of_line ();
		  return NULL;
		}
d306 2
a307 16
	  else
	    align = 0;
	  record_alignment (bss_section, align);
	  subseg_set (bss_section, 0);
	  if (align)
	    frag_align (align, 0, 0);
	  if (S_GET_SEGMENT (symbolP) == bss_section)
	    symbol_get_frag (symbolP)->fr_symbol = 0;
	  symbol_set_frag (symbolP, frag_now);
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			    (offsetT) size, (char *) 0);
	  *pfrag = 0;
	  S_SET_SIZE (symbolP, size);
	  S_SET_SEGMENT (symbolP, bss_section);
	  S_CLEAR_EXTERNAL (symbolP);
	  subseg_set (old_sec, old_subsec);
d311 4
a314 5
	allocate_common:
	  S_SET_VALUE (symbolP, (valueT) size);
	  S_SET_ALIGN (symbolP, temp);
	  S_SET_EXTERNAL (symbolP);
	  S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
d317 6
d325 4
a328 16
      input_line_pointer++;
      /* @@@@ Some use the dot, some don't.  Can we get some consistency??  */
      if (*input_line_pointer == '.')
	input_line_pointer++;
      /* @@@@ Some say data, some say bss.  */
      if (strncmp (input_line_pointer, "bss\"", 4)
	  && strncmp (input_line_pointer, "data\"", 5))
	{
	  while (*--input_line_pointer != '"')
	    ;
	  input_line_pointer--;
	  goto bad_common_segment;
	}
      while (*input_line_pointer++ != '"')
	;
      goto allocate_common;
a332 1
  demand_empty_rest_of_line ();
a333 14

  {
  bad_common_segment:
    p = input_line_pointer;
    while (*p && *p != '\n')
      p++;
    c = *p;
    *p = '\0';
    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
    *p = c;
    input_line_pointer = p;
    ignore_rest_of_line ();
    return NULL;
  }
d337 1
a337 2
obj_elf_common (is_common)
     int is_common;
d339 4
a342 1
  elf_common (is_common);
d346 1
a346 2
obj_elf_tls_common (ignore)
     int ignore ATTRIBUTE_UNUSED;
d348 1
a348 1
  symbolS *symbolP = elf_common (0);
d355 10
a364 2
obj_elf_local (ignore)
     int ignore ATTRIBUTE_UNUSED;
d392 1
a392 2
obj_elf_weak (ignore)
     int ignore ATTRIBUTE_UNUSED;
d420 1
a420 2
obj_elf_visibility (visibility)
     int visibility;
a489 57
/* Certain named sections have particular defined types, listed on p.
   4-19 of the ABI.  */
struct special_section
{
  const char *name;
  int type;
  int attributes;
};

static struct special_section const special_sections[] =
{
  { ".bss",	SHT_NOBITS,	SHF_ALLOC + SHF_WRITE		},
  { ".comment",	SHT_PROGBITS,	0				},
  { ".data",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
  { ".data1",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
  { ".debug",	SHT_PROGBITS,	0				},
#if defined (TC_HPPA) && !defined (TE_LINUX) && TARGET_ARCH_SIZE == 64
  { ".fini",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
  { ".init",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
#else
  { ".fini",	SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR	},
  { ".init",	SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR	},
#endif
  { ".line",	SHT_PROGBITS,	0				},
  { ".note",	SHT_NOTE,	0				},
  { ".rodata",	SHT_PROGBITS,	SHF_ALLOC			},
  { ".rodata1",	SHT_PROGBITS,	SHF_ALLOC			},
  { ".tbss",	SHT_NOBITS,	SHF_ALLOC + SHF_WRITE + SHF_TLS	},
  { ".tdata",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_TLS	},
  { ".text",	SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR	},
  { ".init_array",SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE         },
  { ".fini_array",SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE         },
  { ".preinit_array",SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE   },

#ifdef ELF_TC_SPECIAL_SECTIONS
  ELF_TC_SPECIAL_SECTIONS
#endif

#if 0
  /* The following section names are special, but they can not
     reasonably appear in assembler code.  Some of the attributes are
     processor dependent.  */
  { ".dynamic",	SHT_DYNAMIC,	SHF_ALLOC /* + SHF_WRITE */ 	},
  { ".dynstr",	SHT_STRTAB,	SHF_ALLOC			},
  { ".dynsym",	SHT_DYNSYM,	SHF_ALLOC			},
  { ".got",	SHT_PROGBITS,	0				},
  { ".hash",	SHT_HASH,	SHF_ALLOC			},
  { ".interp",	SHT_PROGBITS,	/* SHF_ALLOC */			},
  { ".plt",	SHT_PROGBITS,	0				},
  { ".shstrtab",SHT_STRTAB,	0				},
  { ".strtab",	SHT_STRTAB,	/* SHF_ALLOC */			},
  { ".symtab",	SHT_SYMTAB,	/* SHF_ALLOC */			},
#endif

  { NULL,	0,		0				}
};

d491 7
a497 8
obj_elf_change_section (name, type, attr, entsize, group_name, linkonce, push)
     const char *name;
     int type;
     int attr;
     int entsize;
     const char *group_name;
     int linkonce;
     int push;
d502 1
a502 1
  int i;
d525 12
d538 1
a538 10
  /* See if this is one of the special sections.  */
  for (i = 0; special_sections[i].name != NULL; i++)
    if (strcmp (name, special_sections[i].name) == 0)
      {
	if (type == SHT_NULL)
	  type = special_sections[i].type;
	else if (type != special_sections[i].type)
	  {
	    if (old_sec == NULL
		/* FIXME: gcc, as of 2002-10-22, will emit
d540 18
a557 1
		   .section .init_array,"aw",@@progbits
d559 26
a584 23
		   for __attribute__ ((section (".init_array"))).
		   "@@progbits" is incorrect.  */
		&& special_sections[i].type != SHT_INIT_ARRAY
		&& special_sections[i].type != SHT_FINI_ARRAY
		&& special_sections[i].type != SHT_PREINIT_ARRAY)
	      {
		as_warn (_("setting incorrect section type for %s"), name);
	      }
	    else
	      {
		as_warn (_("ignoring incorrect section type for %s"), name);
		type = special_sections[i].type;
	      }
	  }
	if ((attr &~ special_sections[i].attributes) != 0
	    && old_sec == NULL)
	  {
	    /* As a GNU extension, we permit a .note section to be
	       allocatable.  If the linker sees an allocateable .note
	       section, it will create a PT_NOTE segment in the output
	       file.  */
	    if (strcmp (name, ".note") != 0
		|| attr != SHF_ALLOC)
d587 11
a597 4
	  }
	attr |= special_sections[i].attributes;
	break;
      }
d618 1
a618 1
        seg_info (sec)->bss = 1;
d632 1
a632 1
        symbol_table_insert (section_symbol (sec));
d658 1
a658 3
obj_elf_parse_section_letters (str, len)
     char *str;
     size_t len;
d708 1
a708 4
	      {
		as_warn ("%s", bad_msg);
		attr = -1;
	      }
d719 1
a719 3
obj_elf_section_word (str, len)
     char *str;
     size_t len;
d743 1
a743 3
obj_elf_section_type (str, len)
     char *str;
     size_t len;
d749 2
d766 1
a766 1
obj_elf_section_name ()
d790 1
a790 1
	  as_warn (_("missing name"));
d798 3
d808 1
a808 2
obj_elf_section (push)
     int push;
d941 1
a941 1
		  as_warn (_("character following name is not '#'"));
d966 1
a966 2
obj_elf_data (i)
     int i;
d984 1
a984 2
obj_elf_text (i)
     int i;
d1000 1
a1000 2
obj_elf_subsection (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1024 1
a1024 1
obj_elf_section_change_hook ()
d1031 1
a1031 2
obj_elf_previous (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1058 1
a1058 2
obj_elf_popsection (xxx)
     int xxx ATTRIBUTE_UNUSED;
d1084 1
a1084 2
obj_elf_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1088 1
a1088 1
  new_logical_line ((char *) NULL, (int) (get_absolute_expression ()));
d1099 1
a1099 2
obj_elf_symver (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1169 1
a1169 2
obj_elf_vtable_inherit (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1240 1
a1240 2
obj_elf_vtable_entry (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1276 1
a1276 1
elf_obj_read_begin_hook ()
d1285 1
a1285 2
elf_obj_symbol_new_hook (symbolP)
     symbolS *symbolP;
d1304 1
a1304 2
elf_copy_symbol_attributes (dest, src)
     symbolS *dest, *src;
d1311 1
a1311 2
	destelf->size =
	  (expressionS *) xmalloc (sizeof (expressionS));
d1327 1
a1327 2
obj_elf_version (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1336 1
a1336 1
  asection *note_secp = (asection *) NULL;
d1367 1
a1367 1
      md_number_to_chars (p, (valueT) i_note.namesz, sizeof (e_note.namesz));
d1369 1
a1369 1
      md_number_to_chars (p, (valueT) i_note.descsz, sizeof (e_note.descsz));
d1371 1
a1371 1
      md_number_to_chars (p, (valueT) i_note.type, sizeof (e_note.type));
d1387 1
a1387 2
obj_elf_size (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1428 1
a1428 2
      symbol_get_obj (sym)->size =
	(expressionS *) xmalloc (sizeof (expressionS));
d1450 1
a1450 2
obj_elf_type (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1489 3
d1510 1
a1510 2
obj_elf_ident (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1540 1
a1540 2
obj_elf_init_stab_section (seg)
     segT seg;
d1555 2
a1556 2
  as_where (&file, (unsigned int *) NULL);
  stabstr_name = (char *) xmalloc (strlen (segment_name (seg)) + 4);
d1570 1
a1570 4
adjust_stab_sections (abfd, sec, xxx)
     bfd *abfd;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d1582 1
a1582 1
  name = (char *) alloca (strlen (sec->name) + 4);
d1595 2
a1596 2
  bfd_h_put_16 (abfd, (bfd_vma) nsyms, (bfd_byte *) p + 6);
  bfd_h_put_32 (abfd, (bfd_vma) strsz, (bfd_byte *) p + 8);
d1608 1
a1608 3
elf_ecoff_set_ext (sym, ext)
     symbolS *sym;
     struct ecoff_extr *ext;
d1610 1
a1610 1
  symbol_get_bfdsym (sym)->udata.p = (PTR) ext;
d1618 1
a1618 3
elf_get_extr (sym, ext)
     asymbol *sym;
     EXTR *ext;
a1628 1
/*ARGSUSED*/
d1630 2
a1631 3
elf_set_index (sym, indx)
     asymbol *sym ATTRIBUTE_UNUSED;
     bfd_size_type indx ATTRIBUTE_UNUSED;
d1638 1
a1638 3
elf_frob_symbol (symp, puntp)
     symbolS *symp;
     int *puntp;
d1681 3
a1683 3
         If this is an external reference, just rename the symbol to
         include the version string.  This will make the relocs be
         against the correct versioned symbol.
d1693 2
a1694 2
             reserved for definitions of the default version to link
             against.  */
d1705 1
a1705 1
	  if (p [1] == ELF_VER_CHR && p [2] == ELF_VER_CHR)
d1712 1
a1712 1
	      memmove (&p [2], &p[3], l);
d1804 1
a1804 4
build_group_lists (abfd, sec, inf)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR inf;
d1806 1
a1806 1
  struct group_list *list = (struct group_list *) inf;
d1842 1
a1842 1
elf_frob_file ()
d1847 1
a1847 1
  bfd_map_over_sections (stdoutput, adjust_stab_sections, (PTR) 0);
d1853 1
a1853 1
  bfd_map_over_sections (stdoutput, build_group_lists, (PTR) &list);
d1900 1
d1920 1
a1920 1
elf_frob_file_before_adjust ()
d1940 1
a1940 1
		if (p [1] == ELF_VER_CHR && p [2] == ELF_VER_CHR)
d1943 1
a1943 1
		    memmove (&p [1], &p[3], l);
d1967 1
a1967 1
elf_frob_file_after_relocs ()
d1980 1
a1980 1
      know (debug_swap != (const struct ecoff_debug_swap *) NULL);
d1988 4
a1991 4
      SET (external_dnr, cbDnOffset, PTR);
      SET (external_pdr, cbPdOffset, PTR);
      SET (external_sym, cbSymOffset, PTR);
      SET (external_opt, cbOptOffset, PTR);
d1994 2
a1995 2
      SET (external_fdr, cbFdOffset, PTR);
      SET (external_rfd, cbRfdOffset, PTR);
d2020 4
a2023 5
         eventually become a call to fwrite, and ISO C prohibits
         passing a NULL pointer to a stdio function even if the
         pointer will not be used.  */
      if (! bfd_set_section_contents (stdoutput, sec, (PTR) buf,
				      (file_ptr) 0, (bfd_size_type) 0))
d2040 1
a2040 1
/* Heavily plagarized from obj_elf_version.  The idea is to emit the
d2060 1
a2060 1
                           don't know enough about the source
d2069 1
a2069 1
sco_id ()
d2080 1
a2080 1
  asection *note_secp = (asection *) NULL;
d2097 1
a2097 1
  md_number_to_chars (p, (valueT) i_note.namesz, 4);
d2100 1
a2100 1
  md_number_to_chars (p, (valueT) i_note.descsz, 4);
d2103 1
a2103 1
  md_number_to_chars (p, (valueT) i_note.type, 4);
d2136 1
a2136 1
elf_separate_stab_sections ()
d2146 1
a2146 2
elf_init_stab_section (seg)
     segT seg;
@


1.5
log
@resolve conflicts.
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d24 1
d27 1
a59 1
static void elf_copy_symbol_attributes PARAMS ((symbolS *, symbolS *));
d62 1
d65 1
d68 1
a68 1
static boolean elf_get_extr PARAMS ((asymbol *, EXTR *));
d80 4
d87 1
d134 2
a254 7
static void
elf_copy_symbol_attributes (dest, src)
     symbolS *dest, *src;
{
  OBJ_COPY_SYMBOL_ATTRIBUTES (dest, src);
}

d286 2
a287 2
void
obj_elf_common (is_common)
d293 1
a293 1
  int temp, size;
d296 1
d301 1
a301 1
      return;
d312 1
a312 1
      as_bad (_("Expected comma after symbol-name"));
d314 1
a314 1
      return;
d317 4
a320 1
  if ((temp = get_absolute_expression ()) < 0)
d322 1
a322 1
      as_bad (_(".COMMon length (%d.) <0! Ignored."), temp);
d324 1
a324 1
      return;
a325 1
  size = temp;
d331 1
a331 1
      as_bad (_("Ignoring attempt to re-define symbol"));
d333 1
a333 1
      return;
d339 3
a341 2
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
d359 2
a360 2
	  temp = get_absolute_expression ();
	  if (temp < 0)
d363 1
a363 1
	      as_warn (_("Common alignment negative; 0 assumed"));
d382 1
a382 1
		  as_bad (_("Common alignment not a power of 2"));
d384 1
a384 1
		  return;
d436 1
a436 1
  return;
d449 1
a449 1
    return;
d453 17
d552 2
a553 1
      elfsym->internal_elf_sym.st_other = visibility;
d616 4
d622 1
d627 2
d630 3
d658 8
a665 3
obj_elf_change_section (name, type, attr, push)
     char *name;
     int type, attr, push;
d702 10
a711 1
	    if (old_sec == NULL)
d713 1
a713 1
		as_warn (_("Setting incorrect section type for %s"), name);
d717 1
a717 1
		as_warn (_("Ignoring incorrect section type for %s"), name);
d730 1
a730 1
	      as_warn (_("Setting incorrect section attributes for %s"),
d742 4
a745 1
	   | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0));
d758 2
d761 3
d777 11
a787 4
      if ((old_sec->flags ^ flags)
	  & (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	     | SEC_EXCLUDE | SEC_SORT_ENTRIES))
	as_warn (_("Ignoring changed section attributes for %s"), name);
d795 1
a795 1
int
d815 24
d841 1
a841 1
	    char *bad_msg = _("Unrecognized .section attribute: want a,w,x");
d861 1
a861 1
int
d872 2
d883 1
a883 1
  as_warn (_("Unrecognized section attribute"));
d887 1
a887 1
int
d905 1
a905 1
  as_warn (_("Unrecognized section type"));
d909 40
d953 1
a953 1
  char *name, *beg, *end;
d955 2
d980 3
a982 30
  /* Get name of section.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      name = demand_copy_C_string (&dummy);
      if (name == NULL)
	{
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    {
      end = input_line_pointer;
      while (0 == strchr ("\n\t,; ", *end))
	end++;
      if (end == input_line_pointer)
	{
	  as_warn (_("Missing section name"));
	  ignore_rest_of_line ();
	  return;
	}

      name = xmalloc (end - input_line_pointer + 1);
      memcpy (name, input_line_pointer, end - input_line_pointer);
      name[end - input_line_pointer] = '\0';
      input_line_pointer = end;
    }
  SKIP_WHITESPACE ();

d985 3
d1009 2
d1031 42
d1084 1
a1084 1
		  as_warn (_("Bad .section directive - character following name is not '#'"));
d1103 1
a1103 1
  obj_elf_change_section (name, type, attr, push);
d1185 1
a1185 1
      as_bad (_(".previous without corresponding .section; ignored"));
d1212 1
a1212 1
      as_bad (_(".popsection without corresponding .pushsection; ignored"));
d1253 1
d1272 1
d1274 6
a1279 7
  while (1)
    {
      c = get_symbol_end ();
      if (c != ELF_VER_CHR)
	break;
      *input_line_pointer++ = c;
    }
d1362 1
a1362 1
	  || isspace ((unsigned char) input_line_pointer[1])))
d1452 29
a1486 1
  char ch;
d1493 1
a1493 1
  int i, len;
d1523 1
a1523 1
      md_number_to_chars (p, (valueT) i_note.namesz, 4);
d1525 1
a1525 1
      md_number_to_chars (p, (valueT) i_note.descsz, 4);
d1527 3
a1529 1
      md_number_to_chars (p, (valueT) i_note.type, 4);
a1530 7
      for (i = 0; i < len; i++)
	{
	  ch = *(name + i);
	  {
	    FRAG_APPEND_1_CHAR (ch);
	  }
	}
d1537 1
a1537 1
      as_bad (_("Expected quoted string"));
d1575 8
a1582 1
    S_SET_SIZE (sym, exp.X_add_number);
d1645 3
d1653 1
a1653 1
    as_bad (_("ignoring unrecognized symbol type \"%s\""), typename);
d1714 1
a1714 1
  stabstr_name = (char *) alloca (strlen (segment_name (seg)) + 4);
d1780 1
a1780 1
static boolean
d1786 1
a1786 1
    return false;
d1788 1
a1788 1
  return true;
d1868 1
a1868 1
	      *puntp = true;
d1912 2
d1927 1
a1927 1
	as_bad (_("Symbol `%s' can not be both weak and common"),
d1960 53
d2016 3
d2021 62
d2098 1
a2098 1
	if (symbol_get_obj (symp)->versioned_name)
d2100 1
a2100 1
	    if (!S_IS_DEFINED (symp))
d2120 8
d2174 1
a2174 1
      if (! bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, true,
d2176 1
a2176 1
	as_fatal (_("Failed to set up debugging information: %s"),
d2182 1
a2182 1
      know (stdoutput->output_has_begun == false);
d2196 1
a2196 1
	as_fatal (_("Can't start writing .mdebug section: %s"),
d2199 1
a2199 1
      know (stdoutput->output_has_begun == true);
d2204 1
a2204 1
	as_fatal (_("Could not write .mdebug section: %s"),
d2337 1
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 99, 2000
d20 1
a20 1
   02111-1307, USA. */
d57 1
d61 2
a77 2
static void obj_elf_vtable_inherit PARAMS ((int));
static void obj_elf_vtable_entry PARAMS ((int));
d99 1
a99 1
  /* These define symbol visibility. */
d114 2
a115 2
  {"vtable_inherit", obj_elf_vtable_inherit, 0},
  {"vtable_entry", obj_elf_vtable_entry, 0},
d117 1
a117 1
  /* These are used for dwarf. */
d238 8
d261 1
a261 1
     char *s;
a544 1

a556 1

d627 1
a627 1
  int new_sec;
d629 2
d651 1
a651 1
  new_sec = bfd_get_section_by_name (stdoutput, name) == NULL;
d654 13
a666 16
  if (new_sec)
    {
      flagword flags;
      symbolS *secsym;
      int i;

      /* See if this is one of the special sections.  */
      for (i = 0; special_sections[i].name != NULL; i++)
        if (strcmp (name, special_sections[i].name) == 0)
          {
	    if (type == SHT_NULL)
	      type = special_sections[i].type;
	    else if (type != special_sections[i].type)
	      as_warn (_("Setting incorrect section type for %s"), name);

	    if ((attr &~ special_sections[i].attributes) != 0)
d668 2
a669 8
	        /* As a GNU extension, we permit a .note section to be
		   allocatable.  If the linker sees an allocateable .note
		   section, it will create a PT_NOTE segment in the output
		   file.  */
		if (strcmp (name, ".note") != 0
		    || attr != SHF_ALLOC)
		  as_warn (_("Setting incorrect section attributes for %s"),
			   name);
a670 2
	    attr |= special_sections[i].attributes;
	    break;
d672 15
d688 6
a693 6
      /* Convert ELF type and flags to BFD flags.  */
      flags = (SEC_RELOC
	       | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
	       | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	       | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
	       | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0));
d695 1
a695 1
      flags = md_elf_section_flags (flags, attr, type);
d698 4
d715 10
d727 1
a727 1
      md_elf_section_change_hook ();
d832 1
a832 1
  md_flush_pending_output ();
d1084 1
a1084 1
     delightful bug, so we are not being incompatible here. */
a1109 8
  if (symbol_get_obj (sym)->versioned_name != NULL)
    {
      as_bad (_("multiple .symver directives for symbol `%s'"),
	      S_GET_NAME (sym));
      ignore_rest_of_line ();
      return;
    }

d1128 3
a1130 1
  symbol_get_obj (sym)->versioned_name = xstrdup (name);
d1132 1
a1132 1
  *input_line_pointer = c;
d1134 11
a1144 1
  if (strchr (symbol_get_obj (sym)->versioned_name, ELF_VER_CHR) == NULL)
d1146 10
a1155 4
      as_bad (_("missing version name in `%s' for symbol `%s'"),
	      symbol_get_obj (sym)->versioned_name, S_GET_NAME (sym));
      ignore_rest_of_line ();
      return;
d1165 1
a1165 1
static void
d1198 1
a1198 1
      return;
d1225 1
a1225 1
    return;
d1228 3
a1230 3
  fix_new (symbol_get_frag (csym),
	   symbol_get_value_expression (csym)->X_add_number, 0, psym, 0, 0,
	   BFD_RELOC_VTABLE_INHERIT);
d1237 1
a1237 1
static void
d1259 1
a1259 1
      return;
d1268 1
a1268 2
  fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
	   BFD_RELOC_VTABLE_ENTRY);
d1270 2
a1271 1
  demand_empty_rest_of_line ();
d1317 1
a1317 1
      ++input_line_pointer;	/* -> 1st char of string. */
d1410 1
a1410 1
   There are four syntaxes:
d1420 2
d1433 1
d1438 1
d1448 1
d1462 4
d1471 4
a1474 1
  symbol_get_bfdsym (sym)->flags |= type;
d1523 1
a1523 1
  /* Make space for this first symbol. */
d1525 1
a1525 1
  /* Zero it out. */
d1657 5
a1674 2
	  char *p;

a1677 2
	  p = strchr (sy_obj->versioned_name, ELF_VER_CHR);
	  know (p != NULL);
d1688 13
a1700 1
	  symbolS *symp2;
d1702 6
a1707 5
	  /* FIXME: Creating a new symbol here is risky.  We're in the
             final loop over the symbol table.  We can get away with
             it only because the symbol goes to the end of the list,
             where the loop will still see it.  It would probably be
             better to do this in obj_frob_file_before_adjust. */
d1709 1
a1709 1
	  symp2 = symbol_find_or_make (sy_obj->versioned_name);
d1711 1
a1711 1
	  /* Now we act as though we saw symp2 = sym.  */
d1713 1
a1713 1
	  S_SET_SEGMENT (symp2, S_GET_SEGMENT (symp));
d1715 5
a1719 5
	  /* Subtracting out the frag address here is a hack because
             we are in the middle of the final loop.  */
	  S_SET_VALUE (symp2,
		       (S_GET_VALUE (symp)
			- symbol_get_frag (symp)->fr_address));
d1721 1
a1721 1
	  symbol_set_frag (symp2, symbol_get_frag (symp));
d1723 2
a1724 2
	  /* This will copy over the size information.  */
	  copy_symbol_attributes (symp2, symp);
d1726 2
a1727 2
	  if (S_IS_WEAK (symp))
	    S_SET_WEAK (symp2);
d1729 3
a1731 2
	  if (S_IS_EXTERNAL (symp))
	    S_SET_EXTERNAL (symp2);
d1782 36
d1993 20
d2018 2
d2022 1
d2027 1
d2029 3
d2040 2
d2050 1
a2050 1
  elf_obj_symbol_new_hook,
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d37 4
d49 12
d73 6
a78 3
static void obj_elf_common PARAMS ((int));
static void obj_elf_data PARAMS ((int));
static void obj_elf_text PARAMS ((int));
d83 1
d91 2
d98 6
a103 1
/* These are used for stabs-in-elf configurations.  */
d106 10
d126 1
a126 1
  {NULL},
d171 1
a171 1
  {NULL}			/* end sentinel */
d184 1
a184 1
								".text")));
d186 1
a186 1
								".data")));
d188 1
a188 1
								".bss")));
d229 7
d257 2
a258 2
  sym->sy_frag = &zero_address_frag;
  sym->bsym->flags |= BSF_FILE;
d268 4
d274 3
a276 3
static void
obj_elf_common (ignore)
     int ignore;
d285 6
d299 1
a299 1
      as_bad ("Expected comma after symbol-name");
d306 1
a306 1
      as_bad (".COMMon length (%d.) <0! Ignored.", temp);
d314 1
a314 1
  if (S_IS_DEFINED (symbolP))
d316 1
a316 1
      as_bad ("Ignoring attempt to re-define symbol");
d322 1
a322 1
      if (S_GET_VALUE (symbolP) != size)
d324 1
a324 1
	  as_warn ("Length of .comm \"%s\" is already %ld. Not changed to %d.",
d347 1
a347 1
	      as_warn ("Common alignment negative; 0 assumed");
d350 1
a350 1
      if (symbolP->local)
d366 1
a366 1
		  as_bad ("Common alignment not a power of 2");
d376 1
a376 1
	    frag_align (align, 0);
d378 4
a381 4
	    symbolP->sy_frag->fr_symbol = 0;
	  symbolP->sy_frag = frag_now;
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP, size,
			    (char *) 0);
d394 1
a394 2
	  /* should be common, but this is how gas does it for now */
	  S_SET_SEGMENT (symbolP, bfd_und_section_ptr);
d416 3
d429 1
a429 1
    as_bad ("bad .common segment %s", input_line_pointer + 1);
d439 1
a439 1
     int ignore;
d453 1
a453 1
      symbolP->local = 1;
d468 1
a468 1
     int ignore;
d482 1
a482 1
      symbolP->local = 1;
d495 42
d540 10
d577 1
a577 1
static struct special_section special_sections[] =
d616 3
a618 2
obj_elf_section (xxx)
     int xxx;
a619 1
  char *string;
a621 4
  int type, attr;
  int i;
  flagword flags;
  symbolS *secsym;
d627 173
d804 4
d819 1
d825 2
a826 2
      string = demand_copy_C_string (&xxx);
      if (string == NULL)
d834 4
a837 5
      char *p = input_line_pointer;
      char c;
      while (0 == strchr ("\n\t,; ", *p))
	p++;
      if (p == input_line_pointer)
d839 1
a839 1
	  as_warn ("Missing section name");
a842 26
      c = *p;
      *p = 0;
      string = xmalloc ((unsigned long) (p - input_line_pointer + 1));
      strcpy (string, input_line_pointer);
      *p = c;
      input_line_pointer = p;
    }

  /* Switch to the section, creating it if necessary.  */
  previous_section = now_seg;
  previous_subsection = now_subseg;

  new_sec = bfd_get_section_by_name (stdoutput, string) == NULL;
  sec = subseg_new (string, 0);

  /* If this section already existed, we don't bother to change the
     flag values.  */
  if (! new_sec)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
      ++input_line_pointer;

#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif
d844 4
a847 1
      return;
a848 1

d858 1
a859 1
      SKIP_WHITESPACE ();
d862 2
a863 3
	  /* Pick up a string with a combination of a, w, x.  */
	  ++input_line_pointer;
	  while (*input_line_pointer != '"')
d865 2
a866 28
	      switch (*input_line_pointer)
		{
		case 'a':
		  attr |= SHF_ALLOC;
		  break;
		case 'w':
		  attr |= SHF_WRITE;
		  break;
		case 'x':
		  attr |= SHF_EXECINSTR;
		  break;
		default:
		  {
		    char *bad_msg = "Bad .section directive: want a,w,x in string";
#ifdef md_elf_section_letter
		    int md_attr = md_elf_section_letter (*input_line_pointer, &bad_msg);
		    if (md_attr)
		      attr |= md_attr;
		    else
#endif
		      {
			as_warn (bad_msg);
			ignore_rest_of_line ();
			return;
		      }
		  }
		}
	      ++input_line_pointer;
d868 1
a868 3

	  /* Skip the closing quote.  */
	  ++input_line_pointer;
d873 1
d876 2
a877 1
	      if (*input_line_pointer == '@@')
d879 2
a880 3
		  ++input_line_pointer;
		  if (strncmp (input_line_pointer, "progbits",
			       sizeof "progbits" - 1) == 0)
d882 2
a883 21
		      type = SHT_PROGBITS;
		      input_line_pointer += sizeof "progbits" - 1;
		    }
		  else if (strncmp (input_line_pointer, "nobits",
				    sizeof "nobits" - 1) == 0)
		    {
		      type = SHT_NOBITS;
		      input_line_pointer += sizeof "nobits" - 1;
		    }
		  else
		    {
#ifdef md_elf_section_type
		    int md_type = md_elf_section_type (&input_line_pointer);
		    if (md_type)
		      type = md_type;
		    else
#endif
		      {
			as_warn ("Unrecognized section type");
			ignore_rest_of_line ();
		      }
d885 8
d900 2
d905 1
a905 1
		  as_warn ("Bad .section directive");
d909 6
a914 33
	      ++input_line_pointer;
	      if (strncmp (input_line_pointer, "write",
			   sizeof "write" - 1) == 0)
		{
		  attr |= SHF_WRITE;
		  input_line_pointer += sizeof "write" - 1;
		}
	      else if (strncmp (input_line_pointer, "alloc",
				sizeof "alloc" - 1) == 0)
		{
		  attr |= SHF_ALLOC;
		  input_line_pointer += sizeof "alloc" - 1;
		}
	      else if (strncmp (input_line_pointer, "execinstr",
				sizeof "execinstr" - 1) == 0)
		{
		  attr |= SHF_EXECINSTR;
		  input_line_pointer += sizeof "execinstr" - 1;
		}
	      else
		{
#ifdef md_elf_section_word
		  int md_attr = md_elf_section_word (&input_line_pointer);
		  if (md_attr)
		    attr |= md_attr;
		  else
#endif
		    {
		      as_warn ("Unrecognized section attribute");
		      ignore_rest_of_line ();
		      return;
		    }
		}
d922 6
a927 14
  /* See if this is one of the special sections.  */
  for (i = 0; special_sections[i].name != NULL; i++)
    {
      if (string[1] == special_sections[i].name[1]
	  && strcmp (string, special_sections[i].name) == 0)
	{
	  if (type == SHT_NULL)
	    type = special_sections[i].type;
	  else if (type != special_sections[i].type)
	    as_warn ("Setting incorrect section type for %s", string);

	  if ((attr &~ special_sections[i].attributes) != 0)
	    as_warn ("Setting incorrect section attributes for %s", string);
	  attr |= special_sections[i].attributes;
d929 7
a935 3
	  break;
	}
    }
d937 3
a939 14
  flags = (SEC_RELOC
	   | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
	   | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	   | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
	   | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0));
  if (special_sections[i].name == NULL)
    {
      if (type == SHT_PROGBITS)
	flags |= SEC_ALLOC | SEC_LOAD;
      else if (type == SHT_NOBITS)
	{
	  flags |= SEC_ALLOC;
	  flags &=~ SEC_LOAD;
	}
d941 2
a942 2
#ifdef md_elf_section_flags
      flags = md_elf_section_flags (flags, attr, type);
d944 3
a946 1
    }
d948 7
a954 1
  bfd_set_section_flags (stdoutput, sec, flags);
d956 3
a958 6
  /* Add a symbol for this section to the symbol table.  */
  secsym = symbol_find (string);
  if (secsym != NULL)
    secsym->bsym = sec->symbol;
  else
    symbol_table_insert (section_symbol (sec));
a962 2

  demand_empty_rest_of_line ();
a964 2
/* Change to the .data section.  */

d966 2
a967 2
obj_elf_data (i)
     int i;
d969 6
d977 8
a984 1
  s_data (i);
d987 2
a988 1
/* Change to the .text section.  */
d990 2
a991 3
static void
obj_elf_text (i)
     int i;
a994 1
  s_text (i);
d999 1
a999 1
     int ignore;
d1001 3
d1006 28
a1033 1
      as_bad (".previous without corresponding .section; ignored");
d1036 14
a1049 2
  subseg_set (previous_section, previous_subsection);
  previous_section = 0;
d1054 1
a1054 1
     int ignore;
d1062 175
d1238 1
a1238 1
obj_read_begin_hook ()
d1247 1
a1247 1
obj_symbol_new_hook (symbolP)
d1250 5
a1254 1
  symbolP->sy_obj = 0;
d1264 1
a1264 1
     int ignore;
d1318 1
a1318 1
      frag_align (2, 0);
d1324 1
a1324 1
      as_bad ("Expected quoted string");
d1331 1
a1331 1
     int ignore;
d1345 1
a1345 1
      as_bad ("expected comma after name `%s' in .size directive", name);
d1354 1
a1354 1
      as_bad ("missing expression in .size directive");
d1365 3
a1367 2
      sym->sy_obj = (expressionS *) xmalloc (sizeof (expressionS));
      *sym->sy_obj = exp;
d1373 3
a1375 1
   There are three syntaxes.  The first (used on Solaris) is
d1381 2
d1387 1
a1387 1
     int ignore;
d1405 3
a1407 1
  if (*input_line_pointer == '#' || *input_line_pointer == '@@')
d1421 1
a1421 1
    as_bad ("ignoring unrecognized symbol type \"%s\"", typename);
d1425 1
a1425 1
  sym->bsym->flags |= type;
d1432 1
a1432 1
     int ignore;
d1438 4
d1496 1
a1496 1
     PTR xxx;
d1538 1
a1538 1
  sym->bsym->udata.p = (PTR) ext;
d1562 2
a1563 2
     asymbol *sym;
     bfd_size_type indx;
d1574 2
d1581 3
a1583 1
  if (symp->sy_obj)
d1585 1
a1585 1
      switch (symp->sy_obj->X_op)
d1589 3
a1591 3
		      (S_GET_VALUE (symp->sy_obj->X_add_symbol)
		       + symp->sy_obj->X_add_number
		       - S_GET_VALUE (symp->sy_obj->X_op_symbol)));
d1595 2
a1596 2
		      (S_GET_VALUE (symp->sy_obj->X_add_symbol)
		       + symp->sy_obj->X_add_number));
d1599 1
a1599 1
	  as_bad (".size expression too complicated to fix up");
d1602 67
a1668 2
      free (symp->sy_obj);
      symp->sy_obj = 0;
d1672 1
a1672 1
  if (symp->bsym->flags & BSF_WEAK)
d1675 1
a1675 1
	as_bad ("Symbol `%s' can not be both weak and common",
d1680 7
a1686 3
  /* The Irix 5 assembler appears to set the type of any common symbol
     to STT_OBJECT.  We try to be compatible, since the Irix 5 linker
     apparently sometimes cares.  FIXME: What about Irix 6?  */
d1688 6
a1693 1
    symp->bsym->flags |= BSF_OBJECT;
d1696 7
a1702 4
#ifdef TC_PPC
  /* Frob the PowerPC, so that the symbol always has object type
     if it is not some other type.  VxWorks needs this.  */
  if ((symp->bsym->flags & (BSF_FUNCTION | BSF_FILE | BSF_SECTION_SYM)) == 0
d1704 1
a1704 1
    symp->bsym->flags |= BSF_OBJECT;
d1762 1
a1762 1
	as_fatal ("Failed to set up debugging information: %s",
d1776 5
a1780 1
      if (! bfd_set_section_contents (stdoutput, sec, (PTR) NULL,
d1782 1
a1782 1
	as_fatal ("Can't start writing .mdebug section: %s",
d1790 1
a1790 1
	as_fatal ("Could not write .mdebug section: %s",
d1796 97
d1896 2
a1897 2
  0,
  1,
d1903 2
d1910 2
a1911 2
  0,
  0,				/* process_stab */
d1918 1
a1918 1
  0,
d1920 2
a1921 2
  obj_read_begin_hook,
  obj_symbol_new_hook,
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d139 14
d380 1
a380 1
static void 
d409 1
a409 1
static void 
d442 1
a442 1
   syntaxes.  
d516 1
d769 7
d828 1
a828 1
void 
d837 1
a837 1
void 
d849 1
a849 1
void 
d1203 1
a1203 1
void 
d1211 6
d1218 3
d1239 1
a1239 1
	SET (line, cbLineOffset, unsigned char *);
d1250 1
a1250 1
#undef SET    
d1294 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1992, 1993 Free Software Foundation, Inc.
d16 4
a19 3
   You should have received a copy of the GNU General Public
   License along with GAS; see the file COPYING.  If not, write
   to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d40 4
d509 1
a509 1
      char type;
d514 1
a514 1
      s_mri_sect (&type);
d605 14
a618 3
		  as_warn ("Bad .section directive: want a,w,x in string");
		  ignore_rest_of_line ();
		  return;
d648 10
a657 2
		      as_warn ("Unrecognized section type");
		      ignore_rest_of_line ();
d694 11
a704 3
		  as_warn ("Unrecognized section attribute");
		  ignore_rest_of_line ();
		  return;
d734 2
a735 1
	   | ((attr & SHF_ALLOC) ? SEC_ALLOC | SEC_LOAD : 0)
d746 4
d943 1
a943 4

   FIXME: We do not fully support this pseudo-op.  In fact, the only
   case we do support is setting the type to STT_FUNC, which we do by
   setting the BSF_FUNCTION flag.  */
d977 1
a977 1
    ;
d1152 2
a1154 2
  free (symp->sy_obj);
  symp->sy_obj = 0;
d1163 16
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
d16 3
a18 4
   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA. */
a38 4
#ifdef TC_PPC
#include "elf/ppc.h"
#endif

d504 1
a504 1
      char mri_type;
d509 1
a509 1
      s_mri_sect (&mri_type);
d600 3
a602 14
		  {
		    char *bad_msg = "Bad .section directive: want a,w,x in string";
#ifdef md_elf_section_letter
		    int md_attr = md_elf_section_letter (*input_line_pointer, &bad_msg);
		    if (md_attr)
		      attr |= md_attr;
		    else
#endif
		      {
			as_warn (bad_msg);
			ignore_rest_of_line ();
			return;
		      }
		  }
d632 2
a633 10
#ifdef md_elf_section_type
		    int md_type = md_elf_section_type (&input_line_pointer);
		    if (md_type)
		      type = md_type;
		    else
#endif
		      {
			as_warn ("Unrecognized section type");
			ignore_rest_of_line ();
		      }
d670 3
a672 11
#ifdef md_elf_section_word
		  int md_attr = md_elf_section_word (&input_line_pointer);
		  if (md_attr)
		    attr |= md_attr;
		  else
#endif
		    {
		      as_warn ("Unrecognized section attribute");
		      ignore_rest_of_line ();
		      return;
		    }
d702 1
a702 2
	   | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	   | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
a712 4

#ifdef md_elf_section_flags
      flags = md_elf_section_flags (flags, attr, type);
#endif
d906 4
a909 1
   */
d943 1
a943 1
    type = BSF_OBJECT;
a1117 2
      free (symp->sy_obj);
      symp->sy_obj = 0;
d1119 2
a1128 16

#ifdef TC_MIPS
  /* The Irix 5 assembler appears to set the type of any common symbol
     to STT_OBJECT.  We try to be compatible, since the Irix 5 linker
     apparently sometimes cares.  FIXME: What about Irix 6?  */
  if (S_IS_COMMON (symp))
    symp->bsym->flags |= BSF_OBJECT;
#endif

#ifdef TC_PPC
  /* Frob the PowerPC, so that the symbol always has object type
     if it is not some other type.  VxWorks needs this.  */
  if ((symp->bsym->flags & (BSF_FUNCTION | BSF_FILE | BSF_SECTION_SYM)) == 0
      && S_IS_DEFINED (symp))
    symp->bsym->flags |= BSF_OBJECT;
#endif
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@a138 14
/* This is called when the assembler starts.  */

void
elf_begin ()
{
  /* Add symbols for the known sections to the symbol table.  */
  symbol_table_insert (section_symbol (bfd_get_section_by_name (stdoutput,
								".text")));
  symbol_table_insert (section_symbol (bfd_get_section_by_name (stdoutput,
								".data")));
  symbol_table_insert (section_symbol (bfd_get_section_by_name (stdoutput,
								".bss")));
}

d366 1
a366 1
static void
d395 1
a395 1
static void
d428 1
a428 1
   syntaxes.
a501 1
  symbolS *secsym;
a753 7
  /* Add a symbol for this section to the symbol table.  */
  secsym = symbol_find (string);
  if (secsym != NULL)
    secsym->bsym = sec->symbol;
  else
    symbol_table_insert (section_symbol (sec));

d806 1
a806 1
void
d815 1
a815 1
void
d827 1
a827 1
void
d1181 1
a1181 1
void
a1188 6
}

/* It is required that we let write_relocs have the opportunity to
   optimize away fixups before output has begun, since it is possible
   to eliminate all fixups for a section and thus we never should
   have generated the relocation section.  */
a1189 3
void
elf_frob_file_after_relocs ()
{
d1208 1
a1208 1
      SET (line, cbLineOffset, unsigned char *);
d1219 1
a1219 1
#undef SET
a1262 1
  elf_frob_file_after_relocs,
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a43 8
static bfd_vma elf_s_get_size PARAMS ((symbolS *));
static void elf_s_set_size PARAMS ((symbolS *, bfd_vma));
static bfd_vma elf_s_get_align PARAMS ((symbolS *));
static void elf_s_set_align PARAMS ((symbolS *, bfd_vma));
static void elf_copy_symbol_attributes PARAMS ((symbolS *, symbolS *));
static int elf_sec_sym_ok_for_reloc PARAMS ((asection *));
static void adjust_stab_sections PARAMS ((bfd *, asection *, PTR));

a56 1
static void obj_elf_symver PARAMS ((int));
d75 1
a75 1
  /* These are used for stabs-in-elf configurations.  */
a77 3
  /* This is a GNU extension to handle symbol versions.  */
  {"symver", obj_elf_symver, 0},

a222 4

#ifdef NEED_ECOFF_DEBUG
  ecoff_new_file (s);
#endif
d259 1
a259 1
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d321 1
a321 1
	    frag_align (align, 0, 0);
d325 2
a326 2
	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			    (offsetT) size, (char *) 0);
d339 2
a340 1
	  S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
a361 3

  symbolP->bsym->flags |= BSF_OBJECT;

d740 1
a740 10
	    {
	      /* As a GNU extension, we permit a .note section to be
                 allocatable.  If the linker sees an allocateable
                 .note section, it will create a PT_NOTE segment in
                 the output file.  */
	      if (strcmp (string, ".note") != 0
		  || attr != SHF_ALLOC)
		as_warn ("Setting incorrect section attributes for %s",
			 string);
	    }
a788 4
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

a791 4

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
a799 4
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

a802 14

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* This can be called from the processor backends if they change
   sections.  */

void
obj_elf_section_change_hook ()
{
  previous_section = now_seg;
  previous_subsection = now_subseg;
a813 5

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

a815 4

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
a827 62
/* This handle the .symver pseudo-op, which is used to specify a
   symbol version.  The syntax is ``.symver NAME,SYMVERNAME''.
   SYMVERNAME may contain ELF_VER_CHR ('@@') characters.  This
   pseudo-op causes the assembler to emit a symbol named SYMVERNAME
   with the same value as the symbol NAME.  */

static void
obj_elf_symver (ignore)
     int ignore;
{
  char *name;
  char c;
  symbolS *sym;

  name = input_line_pointer;
  c = get_symbol_end ();

  sym = symbol_find_or_make (name);

  *input_line_pointer = c;

  if (sym->sy_obj.versioned_name != NULL)
    {
      as_bad ("multiple .symver directives for symbol `%s'",
	      S_GET_NAME (sym));
      ignore_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after name in .symver");
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  name = input_line_pointer;
  while (1)
    {
      c = get_symbol_end ();
      if (c != ELF_VER_CHR)
	break;
      *input_line_pointer++ = c;
    }

  sym->sy_obj.versioned_name = xstrdup (name);

  *input_line_pointer = c;

  if (strchr (sym->sy_obj.versioned_name, ELF_VER_CHR) == NULL)
    {
      as_bad ("missing version name in `%s' for symbol `%s'",
	      sym->sy_obj.versioned_name, S_GET_NAME (sym));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();
}

d841 1
a841 2
  symbolP->sy_obj.size = NULL;
  symbolP->sy_obj.versioned_name = NULL;
d905 1
a905 1
      frag_align (2, 0, 0);
d952 2
a953 2
      sym->sy_obj.size = (expressionS *) xmalloc (sizeof (expressionS));
      *sym->sy_obj.size = exp;
d1155 1
a1155 1
  if (symp->sy_obj.size != NULL)
d1157 1
a1157 1
      switch (symp->sy_obj.size->X_op)
d1161 3
a1163 3
		      (S_GET_VALUE (symp->sy_obj.size->X_add_symbol)
		       + symp->sy_obj.size->X_add_number
		       - S_GET_VALUE (symp->sy_obj.size->X_op_symbol)));
d1167 2
a1168 2
		      (S_GET_VALUE (symp->sy_obj.size->X_add_symbol)
		       + symp->sy_obj.size->X_add_number));
d1174 2
a1175 65
      free (symp->sy_obj.size);
      symp->sy_obj.size = NULL;
    }

  if (symp->sy_obj.versioned_name != NULL)
    {
      /* This symbol was given a new name with the .symver directive.

         If this is an external reference, just rename the symbol to
         include the version string.  This will make the relocs be
         against the correct versioned symbol.

	 If this is a definition, add an alias.  FIXME: Using an alias
	 will permit the debugging information to refer to the right
	 symbol.  However, it's not clear whether it is the best
	 approach.  */

      if (! S_IS_DEFINED (symp))
	{
	  char *p;

	  /* Verify that the name isn't using the @@@@ syntax--this is
             reserved for definitions of the default version to link
             against.  */
	  p = strchr (symp->sy_obj.versioned_name, ELF_VER_CHR);
	  know (p != NULL);
	  if (p[1] == ELF_VER_CHR)
	    {
	      as_bad ("invalid attempt to declare external version name as default in symbol `%s'",
		      symp->sy_obj.versioned_name);
	      *puntp = true;
	    }
	  S_SET_NAME (symp, symp->sy_obj.versioned_name);
	}
      else
	{
	  symbolS *symp2;

	  /* FIXME: Creating a new symbol here is risky.  We're in the
             final loop over the symbol table.  We can get away with
             it only because the symbol goes to the end of the list,
             where the loop will still see it.  It would probably be
             better to do this in obj_frob_file_before_adjust. */

	  symp2 = symbol_find_or_make (symp->sy_obj.versioned_name);

	  /* Now we act as though we saw symp2 = sym.  */

	  S_SET_SEGMENT (symp2, S_GET_SEGMENT (symp));

	  /* Subtracting out the frag address here is a hack because
             we are in the middle of the final loop.  */
	  S_SET_VALUE (symp2, S_GET_VALUE (symp) - symp->sy_frag->fr_address);

	  symp2->sy_frag = symp->sy_frag;

	  /* This will copy over the size information.  */
	  copy_symbol_attributes (symp2, symp);

	  if (S_IS_WEAK (symp))
	    S_SET_WEAK (symp2);

	  if (S_IS_EXTERNAL (symp))
	    S_SET_EXTERNAL (symp2);
	}
d1187 4
a1190 5
  /* The Irix 5 and 6 assemblers set the type of any common symbol and
     any undefined non-function symbol to STT_OBJECT.  We try to be compatible,
     since newer Irix 5 and 6 linkers care.  */
  if (S_IS_COMMON (symp)
      || (! S_IS_DEFINED (symp) && ((symp->bsym->flags & BSF_FUNCTION) == 0)))
a1285 97

#ifdef SCO_ELF

/* Heavily plagarized from obj_elf_version.  The idea is to emit the
   SCO specific identifier in the .notes section to satisfy the SCO
   linker.

   This looks more complicated than it really is.  As opposed to the
   "obvious" solution, this should handle the cross dev cases
   correctly.  (i.e, hosting on a 64 bit big endian processor, but
   generating SCO Elf code) Efficiency isn't a concern, as there
   should be exactly one of these sections per object module.

   SCO OpenServer 5 identifies it's ELF modules with a standard ELF
   .note section.

   int_32 namesz  = 4 ;  Name size 
   int_32 descsz  = 12 ; Descriptive information 
   int_32 type    = 1 ;  
   char   name[4] = "SCO" ; Originator name ALWAYS SCO + NULL 
   int_32 version = (major ver # << 16)  | version of tools ;
   int_32 source  = (tool_id << 16 ) | 1 ;
   int_32 info    = 0 ;    These are set by the SCO tools, but we
                           don't know enough about the source 
			   environment to set them.  SCO ld currently
			   ignores them, and recommends we set them
			   to zero.  */

#define SCO_MAJOR_VERSION 0x1
#define SCO_MINOR_VERSION 0x1

void
sco_id ()
{

  char *name;
  unsigned int c;
  char ch;
  char *p;
  asection *seg = now_seg;
  subsegT subseg = now_subseg;
  Elf_Internal_Note i_note;
  Elf_External_Note e_note;
  asection *note_secp = (asection *) NULL;
  int i, len;

  /* create the .note section */

  note_secp = subseg_new (".note", 0);
  bfd_set_section_flags (stdoutput,
			 note_secp,
			 SEC_HAS_CONTENTS | SEC_READONLY);

  /* process the version string */

  i_note.namesz = 4; 
  i_note.descsz = 12;		/* 12 descriptive bytes */
  i_note.type = NT_VERSION;	/* Contains a version string */

  p = frag_more (sizeof (i_note.namesz));
  md_number_to_chars (p, (valueT) i_note.namesz, 4);

  p = frag_more (sizeof (i_note.descsz));
  md_number_to_chars (p, (valueT) i_note.descsz, 4);

  p = frag_more (sizeof (i_note.type));
  md_number_to_chars (p, (valueT) i_note.type, 4);

  p = frag_more (4);
  strcpy (p, "SCO"); 

  /* Note: this is the version number of the ELF we're representing */
  p = frag_more (4);
  md_number_to_chars (p, (SCO_MAJOR_VERSION << 16) | (SCO_MINOR_VERSION), 4);

  /* Here, we pick a magic number for ourselves (yes, I "registered"
     it with SCO.  The bottom bit shows that we are compat with the
     SCO ABI.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x4c520000 | 0x0001, 4);

  /* If we knew (or cared) what the source language options were, we'd
     fill them in here.  SCO has given us permission to ignore these
     and just set them to zero.  */
  p = frag_more (4);
  md_number_to_chars (p, 0x0000, 4);
 
  frag_align (2, 0, 0);

  /* We probably can't restore the current segment, for there likely
     isn't one yet...  */
  if (seg && subseg)
    subseg_set (seg, subseg);

}

#endif /* SCO_ELF */
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
a35 4
#ifdef TC_ALPHA
#include "elf/alpha.h"
#endif

a43 4
#ifdef TC_I370
#include "elf/i370.h"
#endif

d64 1
a64 1
static void obj_elf_visibility PARAMS ((int));
d66 2
a67 4
static void obj_elf_vtable_inherit PARAMS ((int));
static void obj_elf_vtable_entry PARAMS ((int));
static void obj_elf_subsection PARAMS ((int));
static void obj_elf_popsection PARAMS ((int));
a71 1
  {"common", obj_elf_common, 1},
a78 2
  {"pushsection", obj_elf_section, 1},
  {"popsection", obj_elf_popsection, 0},
a83 5
  /* These define symbol visibility. */
  {"internal", obj_elf_visibility, STV_INTERNAL},
  {"hidden", obj_elf_visibility, STV_HIDDEN},
  {"protected", obj_elf_visibility, STV_PROTECTED},

a89 7
  /* A GNU extension to change subsection only.  */
  {"subsection", obj_elf_subsection, 0},

  /* These are GNU extensions to aid in garbage collecting C++ vtables.  */
  {"vtable_inherit", obj_elf_vtable_inherit, 0},
  {"vtable_entry", obj_elf_vtable_entry, 0},

d100 1
a100 1
  {NULL, NULL, 0},
d145 1
a145 1
  {NULL, NULL, 0}			/* end sentinel */
d158 1
a158 1
								TEXT_SECTION_NAME)));
d160 1
a160 1
								DATA_SECTION_NAME)));
d162 1
a162 1
								BSS_SECTION_NAME)));
a202 7
int
elf_s_get_other (sym)
     symbolS *sym;
{
  return elf_symbol (symbol_get_bfdsym (sym))->internal_elf_sym.st_other;
}

d224 2
a225 2
  symbol_set_frag (sym, &zero_address_frag);
  symbol_get_bfdsym (sym)->flags |= BSF_FILE;
d241 3
a243 3
void
obj_elf_common (is_common)
     int is_common;
a251 6
  if (flag_mri && is_common)
    {
      s_mri_common (0);
      return;
    }

d260 1
a260 1
      as_bad (_("Expected comma after symbol-name"));
d267 1
a267 1
      as_bad (_(".COMMon length (%d.) <0! Ignored."), temp);
d277 1
a277 1
      as_bad (_("Ignoring attempt to re-define symbol"));
d283 1
a283 1
      if (S_GET_VALUE (symbolP) != (valueT) size)
d285 1
a285 1
	  as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
d308 1
a308 1
	      as_warn (_("Common alignment negative; 0 assumed"));
d311 1
a311 1
      if (symbol_get_obj (symbolP)->local)
d327 1
a327 1
		  as_bad (_("Common alignment not a power of 2"));
d339 2
a340 2
	    symbol_get_frag (symbolP)->fr_symbol = 0;
	  symbol_set_frag (symbolP, frag_now);
d378 1
a378 1
  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
d390 1
a390 1
    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
d400 1
a400 1
     int ignore ATTRIBUTE_UNUSED;
d414 1
a414 1
      symbol_get_obj (symbolP)->local = 1;
d429 1
a429 1
     int ignore ATTRIBUTE_UNUSED;
d443 1
a443 1
      symbol_get_obj (symbolP)->local = 1;
a455 42
static void
obj_elf_visibility (visibility)
     int visibility;
{
  char *name;
  int c;
  symbolS *symbolP;
  asymbol *bfdsym;
  elf_symbol_type *elfsym;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);
      *input_line_pointer = c;

      SKIP_WHITESPACE ();

      bfdsym = symbol_get_bfdsym (symbolP);
      elfsym = elf_symbol_from (bfd_asymbol_bfd (bfdsym), bfdsym);

      assert (elfsym);

      elfsym->internal_elf_sym.st_other = visibility;

      if (c == ',')
	{
	  input_line_pointer ++;

	  SKIP_WHITESPACE ();

	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}


a458 10
struct section_stack
{
  struct section_stack *next;
  segT seg, prev_seg;
  int subseg, prev_subseg;
};

static struct section_stack *section_stack;


d486 1
a486 1
static struct special_section const special_sections[] =
d525 2
a526 3
obj_elf_change_section (name, type, attr, push)
     char *name;
     int type, attr, push;
d528 1
d531 4
a539 173
  /* Switch to the section, creating it if necessary.  */
  if (push)
    {
      struct section_stack *elt;
      elt = xmalloc (sizeof (struct section_stack));
      elt->next = section_stack;
      elt->seg = now_seg;
      elt->prev_seg = previous_section;
      elt->subseg = now_subseg;
      elt->prev_subseg = previous_subsection;
      section_stack = elt;
    }
  previous_section = now_seg;
  previous_subsection = now_subseg;

  new_sec = bfd_get_section_by_name (stdoutput, name) == NULL;
  sec = subseg_new (name, 0);

  if (new_sec)
    {
      flagword flags;
      symbolS *secsym;
      int i;

      /* See if this is one of the special sections.  */
      for (i = 0; special_sections[i].name != NULL; i++)
        if (strcmp (name, special_sections[i].name) == 0)
          {
	    if (type == SHT_NULL)
	      type = special_sections[i].type;
	    else if (type != special_sections[i].type)
	      as_warn (_("Setting incorrect section type for %s"), name);

	    if ((attr &~ special_sections[i].attributes) != 0)
	      {
	        /* As a GNU extension, we permit a .note section to be
		   allocatable.  If the linker sees an allocateable .note
		   section, it will create a PT_NOTE segment in the output
		   file.  */
		if (strcmp (name, ".note") != 0
		    || attr != SHF_ALLOC)
		  as_warn (_("Setting incorrect section attributes for %s"),
			   name);
	      }
	    attr |= special_sections[i].attributes;
	    break;
	  }

      /* Convert ELF type and flags to BFD flags.  */
      flags = (SEC_RELOC
	       | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
	       | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	       | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
	       | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0));
#ifdef md_elf_section_flags
      flags = md_elf_section_flags (flags, attr, type);
#endif

      /* Prevent SEC_HAS_CONTENTS from being inadvertently set.  */
      if (type == SHT_NOBITS)
        seg_info (sec)->bss = 1;

      bfd_set_section_flags (stdoutput, sec, flags);

      /* Add a symbol for this section to the symbol table.  */
      secsym = symbol_find (name);
      if (secsym != NULL)
	symbol_set_bfdsym (secsym, sec->symbol);
      else
        symbol_table_insert (section_symbol (sec));
    }

#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif
}

int
obj_elf_parse_section_letters (str, len)
     char *str;
     size_t len;
{
  int attr = 0;

  while (len > 0)
    {
      switch (*str)
	{
	case 'a':
	  attr |= SHF_ALLOC;
	  break;
	case 'w':
	  attr |= SHF_WRITE;
	  break;
	case 'x':
	  attr |= SHF_EXECINSTR;
	  break;
	default:
	  {
	    char *bad_msg = _("Unrecognized .section attribute: want a,w,x");
#ifdef md_elf_section_letter
	    int md_attr = md_elf_section_letter (*str, &bad_msg);
	    if (md_attr >= 0)
	      attr |= md_attr;
	    else
#endif
	      {
		as_warn ("%s", bad_msg);
		attr = -1;
	      }
	  }
	  break;
	}
      str++, len--;
    }

  return attr;
}

int
obj_elf_section_word (str, len)
     char *str;
     size_t len;
{
  if (len == 5 && strncmp (str, "write", 5) == 0)
    return SHF_WRITE;
  if (len == 5 && strncmp (str, "alloc", 5) == 0)
    return SHF_ALLOC;
  if (len == 9 && strncmp (str, "execinstr", 9) == 0)
    return SHF_EXECINSTR;

#ifdef md_elf_section_word
  {
    int md_attr = md_elf_section_word (str, len);
    if (md_attr >= 0)
      return md_attr;
  }
#endif

  as_warn (_("Unrecognized section attribute"));
  return 0;
}

int
obj_elf_section_type (str, len)
     char *str;
     size_t len;
{
  if (len == 8 && strncmp (str, "progbits", 8) == 0)
    return SHT_PROGBITS;
  if (len == 6 && strncmp (str, "nobits", 6) == 0)
    return SHT_NOBITS;

#ifdef md_elf_section_type
  {
    int md_type = md_elf_section_type (str, len);
    if (md_type >= 0)
      return md_type;
  }
#endif

  as_warn (_("Unrecognized section type"));
  return 0;
}

void
obj_elf_section (push)
     int push;
{
  char *name, *beg, *end;
  int type, attr, dummy;

#ifndef TC_I370
a543 4
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

a554 1
#endif /* ! defined (TC_I370) */
d560 2
a561 2
      name = demand_copy_C_string (&dummy);
      if (name == NULL)
d569 5
a573 4
      end = input_line_pointer;
      while (0 == strchr ("\n\t,; ", *end))
	end++;
      if (end == input_line_pointer)
d575 1
a575 1
	  as_warn (_("Missing section name"));
d579 26
d606 1
a606 4
      name = xmalloc (end - input_line_pointer + 1);
      memcpy (name, input_line_pointer, end - input_line_pointer);
      name[end - input_line_pointer] = '\0';
      input_line_pointer = end;
d608 1
d618 1
a619 1

d622 3
a624 2
	  beg = demand_copy_C_string (&dummy);
	  if (beg == NULL)
d626 28
a653 2
	      ignore_rest_of_line ();
	      return;
d655 3
a657 1
	  attr |= obj_elf_parse_section_letters (beg, strlen (beg));
a661 1
	      char c;
d664 1
a664 2
	      c = *input_line_pointer;
	      if (c == '"')
d666 14
a679 2
		  beg = demand_copy_C_string (&dummy);
		  if (beg == NULL)
d681 10
a690 2
		      ignore_rest_of_line ();
		      return;
a691 8
		  type = obj_elf_section_type (beg, strlen (beg));
		}
	      else if (c == '@@' || c == '%')
		{
		  beg = ++input_line_pointer;
		  c = get_symbol_end ();
		  *input_line_pointer = c;
		  type = obj_elf_section_type (beg, input_line_pointer - beg);
a698 2
	      char c;

d702 1
a702 1
		  as_warn (_("Bad .section directive - character following name is not '#'"));
d706 33
a738 6
	      beg = ++input_line_pointer;
	      c = get_symbol_end ();
	      *input_line_pointer = c;

	      attr |= obj_elf_section_word (beg, input_line_pointer - beg);

d746 23
a768 1
  demand_empty_rest_of_line ();
d770 3
a772 2
  obj_elf_change_section (name, type, attr, push);
}
d774 14
a787 1
/* Change to the .data section.  */
d789 2
a790 6
void
obj_elf_data (i)
     int i;
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
d792 3
d796 6
a801 3
  previous_section = now_seg;
  previous_subsection = now_subseg;
  s_data (i);
d806 2
d810 1
a810 1
/* Change to the .text section.  */
d812 2
a813 2
void
obj_elf_text (i)
d822 1
a822 1
  s_text (i);
d829 2
d832 2
a833 2
obj_elf_subsection (ignore)
     int ignore ATTRIBUTE_UNUSED;
a834 2
  register int temp;

d841 1
a841 4

  temp = get_absolute_expression ();
  subseg_set (now_seg, (subsegT) temp);
  demand_empty_rest_of_line ();
d860 1
a860 1
     int ignore ATTRIBUTE_UNUSED;
a861 3
  segT new_section;
  int new_subsection;

d864 1
a864 1
      as_bad (_(".previous without corresponding .section; ignored"));
d872 2
a873 32
  new_section = previous_section;
  new_subsection = previous_subsection;
  previous_section = now_seg;
  previous_subsection = now_subseg;
  subseg_set (new_section, new_subsection);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_popsection (xxx)
     int xxx ATTRIBUTE_UNUSED;
{
  struct section_stack *top = section_stack;

  if (top == NULL)
    {
      as_bad (_(".popsection without corresponding .pushsection; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  section_stack = top->next;
  previous_section = top->prev_seg;
  previous_subsection = top->prev_subseg;
  subseg_set (top->seg, top->subseg);
  free (top);
d882 1
a882 1
     int ignore ATTRIBUTE_UNUSED;
d890 1
a890 1
/* This handles the .symver pseudo-op, which is used to specify a
d898 1
a898 1
     int ignore ATTRIBUTE_UNUSED;
d911 1
a911 1
  if (symbol_get_obj (sym)->versioned_name != NULL)
d913 1
a913 1
      as_bad (_("multiple .symver directives for symbol `%s'"),
d922 1
a922 1
      as_bad (_("expected comma after name in .symver"));
d937 1
a937 44
  symbol_get_obj (sym)->versioned_name = xstrdup (name);

  *input_line_pointer = c;

  if (strchr (symbol_get_obj (sym)->versioned_name, ELF_VER_CHR) == NULL)
    {
      as_bad (_("missing version name in `%s' for symbol `%s'"),
	      symbol_get_obj (sym)->versioned_name, S_GET_NAME (sym));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();
}

/* This handles the .vtable_inherit pseudo-op, which is used to indicate
   to the linker the hierarchy in which a particular table resides.  The
   syntax is ".vtable_inherit CHILDNAME, PARENTNAME".  */

static void
obj_elf_vtable_inherit (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *cname, *pname;
  symbolS *csym, *psym;
  char c, bad = 0;

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  cname = input_line_pointer;
  c = get_symbol_end ();
  csym = symbol_find (cname);

  /* GCFIXME: should check that we don't have two .vtable_inherits for
     the same child symbol.  Also, we can currently only do this if the
     child symbol is already exists and is placed in a fragment.  */

  if (csym == NULL || symbol_get_frag (csym) == NULL)
    {
      as_bad ("expected `%s' to have already been set for .vtable_inherit",
	      cname);
      bad = 1;
    }
d941 1
a941 2
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
d943 2
a944 1
      as_bad ("expected comma after name in .vtable_inherit");
a948 70
  ++input_line_pointer;
  SKIP_WHITESPACE ();

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  if (input_line_pointer[0] == '0'
      && (input_line_pointer[1] == '\0'
	  || isspace ((unsigned char) input_line_pointer[1])))
    {
      psym = section_symbol (absolute_section);
      ++input_line_pointer;
    }
  else
    {
      pname = input_line_pointer;
      c = get_symbol_end ();
      psym = symbol_find_or_make (pname);
      *input_line_pointer = c;
    }

  demand_empty_rest_of_line ();

  if (bad)
    return;

  assert (symbol_get_value_expression (csym)->X_op == O_constant);
  fix_new (symbol_get_frag (csym),
	   symbol_get_value_expression (csym)->X_add_number, 0, psym, 0, 0,
	   BFD_RELOC_VTABLE_INHERIT);
}

/* This handles the .vtable_entry pseudo-op, which is used to indicate
   to the linker that a vtable slot was used.  The syntax is
   ".vtable_entry tablename, offset".  */

static void
obj_elf_vtable_entry (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  symbolS *sym;
  offsetT offset;
  char c;

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  name = input_line_pointer;
  c = get_symbol_end ();
  sym = symbol_find_or_make (name);
  *input_line_pointer = c;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad ("expected comma after name in .vtable_entry");
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  if (*input_line_pointer == '#')
    ++input_line_pointer;

  offset = get_absolute_expression ();

  fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
	   BFD_RELOC_VTABLE_ENTRY);

d953 1
a953 1
elf_obj_read_begin_hook ()
d962 1
a962 1
elf_obj_symbol_new_hook (symbolP)
d965 2
a966 5
  struct elf_obj_sy *sy_obj;

  sy_obj = symbol_get_obj (symbolP);
  sy_obj->size = NULL;
  sy_obj->versioned_name = NULL;
d976 1
a976 1
     int ignore ATTRIBUTE_UNUSED;
d1036 1
a1036 1
      as_bad (_("Expected quoted string"));
d1043 1
a1043 1
     int ignore ATTRIBUTE_UNUSED;
d1057 1
a1057 1
      as_bad (_("expected comma after name `%s' in .size directive"), name);
d1066 1
a1066 1
      as_bad (_("missing expression in .size directive"));
d1077 2
a1078 3
      symbol_get_obj (sym)->size =
	(expressionS *) xmalloc (sizeof (expressionS));
      *symbol_get_obj (sym)->size = exp;
d1084 1
a1084 3
   There are four syntaxes:

   The first (used on Solaris) is
a1089 2
   The fourth (used on NetBSD/Arm and Linux/ARM) is
       .type SYM,%function
d1094 1
a1094 1
     int ignore ATTRIBUTE_UNUSED;
d1112 1
a1112 3
  if (   *input_line_pointer == '#'
      || *input_line_pointer == '@@'
      || *input_line_pointer == '%')
d1126 1
a1126 1
    as_bad (_("ignoring unrecognized symbol type \"%s\""), typename);
d1130 1
a1130 1
  symbol_get_bfdsym (sym)->flags |= type;
d1137 1
a1137 1
     int ignore ATTRIBUTE_UNUSED;
a1142 4
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

d1197 1
a1197 1
     PTR xxx ATTRIBUTE_UNUSED;
d1239 1
a1239 1
  symbol_get_bfdsym (sym)->udata.p = (PTR) ext;
d1263 2
a1264 2
     asymbol *sym ATTRIBUTE_UNUSED;
     bfd_size_type indx ATTRIBUTE_UNUSED;
a1274 2
  struct elf_obj_sy *sy_obj;

d1280 1
a1280 3
  sy_obj = symbol_get_obj (symp);

  if (sy_obj->size != NULL)
d1282 1
a1282 1
      switch (sy_obj->size->X_op)
d1286 3
a1288 3
		      (S_GET_VALUE (sy_obj->size->X_add_symbol)
		       + sy_obj->size->X_add_number
		       - S_GET_VALUE (sy_obj->size->X_op_symbol)));
d1292 2
a1293 2
		      (S_GET_VALUE (sy_obj->size->X_add_symbol)
		       + sy_obj->size->X_add_number));
d1296 1
a1296 1
	  as_bad (_(".size expression too complicated to fix up"));
d1299 2
a1300 2
      free (sy_obj->size);
      sy_obj->size = NULL;
d1303 1
a1303 1
  if (sy_obj->versioned_name != NULL)
d1323 1
a1323 1
	  p = strchr (sy_obj->versioned_name, ELF_VER_CHR);
d1327 2
a1328 2
	      as_bad (_("invalid attempt to declare external version name as default in symbol `%s'"),
		      sy_obj->versioned_name);
d1331 1
a1331 1
	  S_SET_NAME (symp, sy_obj->versioned_name);
d1343 1
a1343 1
	  symp2 = symbol_find_or_make (sy_obj->versioned_name);
d1351 1
a1351 3
	  S_SET_VALUE (symp2,
		       (S_GET_VALUE (symp)
			- symbol_get_frag (symp)->fr_address));
d1353 1
a1353 1
	  symbol_set_frag (symp2, symbol_get_frag (symp));
d1367 1
a1367 1
  if (S_IS_WEAK (symp))
d1370 1
a1370 1
	as_bad (_("Symbol `%s' can not be both weak and common"),
d1376 11
a1386 22
     any undefined non-function symbol to STT_OBJECT.  We try to be
     compatible, since newer Irix 5 and 6 linkers care.  However, we
     only set undefined symbols to be STT_OBJECT if we are on Irix,
     because that is the only time gcc will generate the necessary
     .global directives to mark functions.  */

  if (S_IS_COMMON (symp))
    symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;

  if (strstr (TARGET_OS, "irix") != NULL
      && ! S_IS_DEFINED (symp)
      && (symbol_get_bfdsym (symp)->flags & BSF_FUNCTION) == 0)
    symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;
#endif

#if 0 /* TC_PPC */
  /* If TC_PPC is defined, we used to force the type of a symbol to be
     BSF_OBJECT if it was otherwise unset.  This was required by some
     version of VxWorks.  Thomas de Lellis <tdel@@windriver.com> says
     that this is no longer needed, so it is now commented out.  */
  if ((symbol_get_bfdsym (symp)->flags
       & (BSF_FUNCTION | BSF_FILE | BSF_SECTION_SYM)) == 0
d1388 1
a1388 1
    symbol_get_bfdsym (symp)->flags |= BSF_OBJECT;
d1446 1
a1446 1
	as_fatal (_("Failed to set up debugging information: %s"),
d1460 1
a1460 5
      /* Pass BUF to bfd_set_section_contents because this will
         eventually become a call to fwrite, and ISO C prohibits
         passing a NULL pointer to a stdio function even if the
         pointer will not be used.  */
      if (! bfd_set_section_contents (stdoutput, sec, (PTR) buf,
d1462 1
a1462 1
	as_fatal (_("Can't start writing .mdebug section: %s"),
d1470 1
a1470 1
	as_fatal (_("Could not write .mdebug section: %s"),
d1491 4
a1494 4
   int_32 namesz  = 4 ;  Name size
   int_32 descsz  = 12 ; Descriptive information
   int_32 type    = 1 ;
   char   name[4] = "SCO" ; Originator name ALWAYS SCO + NULL
d1498 1
a1498 1
                           don't know enough about the source
d1530 1
a1530 1
  i_note.namesz = 4;
d1544 1
a1544 1
  strcpy (p, "SCO");
d1561 1
a1561 1

d1576 2
a1577 2
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
a1582 2
  elf_s_get_other,
  0,	/* s_get_desc */
d1588 2
a1589 2
  0,	/* generate_asm_lineno */
  0,	/* process_stab */
d1596 1
a1596 1
  0,	/* ecoff_set_ext */
d1598 2
a1599 2
  elf_obj_read_begin_hook,
  elf_obj_symbol_new_hook,
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d20 1
a20 1
   02111-1307, USA.  */
a56 1
static void elf_s_set_other PARAMS ((symbolS *, int));
a59 2
static int elf_separate_stab_sections PARAMS ((void));
static void elf_init_stab_section PARAMS ((segT));
d75 2
d98 1
a98 1
  /* These define symbol visibility.  */
d113 2
a114 2
  {"vtable_inherit", (void (*) PARAMS ((int))) &obj_elf_vtable_inherit, 0},
  {"vtable_entry", (void (*) PARAMS ((int))) &obj_elf_vtable_entry, 0},
d116 1
a116 1
  /* These are used for dwarf.  */
a236 8
elf_s_set_other (sym, other)
     symbolS *sym;
     int other;
{
  S_SET_OTHER (sym, other);
}

static void
d252 1
a252 1
     const char *s;
d536 1
d549 1
d620 1
a620 1
  asection *old_sec;
a621 2
  flagword flags;
  int i;
d642 1
a642 1
  old_sec = bfd_get_section_by_name (stdoutput, name);
d645 16
a660 9
  /* See if this is one of the special sections.  */
  for (i = 0; special_sections[i].name != NULL; i++)
    if (strcmp (name, special_sections[i].name) == 0)
      {
	if (type == SHT_NULL)
	  type = special_sections[i].type;
	else if (type != special_sections[i].type)
	  {
	    if (old_sec == NULL)
d662 8
a669 1
		as_warn (_("Setting incorrect section type for %s"), name);
d671 2
a672 17
	    else
	      {
		as_warn (_("Ignoring incorrect section type for %s"), name);
		type = special_sections[i].type;
	      }
	  }
	if ((attr &~ special_sections[i].attributes) != 0
	    && old_sec == NULL)
	  {
	    /* As a GNU extension, we permit a .note section to be
	       allocatable.  If the linker sees an allocateable .note
	       section, it will create a PT_NOTE segment in the output
	       file.  */
	    if (strcmp (name, ".note") != 0
		|| attr != SHF_ALLOC)
	      as_warn (_("Setting incorrect section attributes for %s"),
		       name);
a673 3
	attr |= special_sections[i].attributes;
	break;
      }
d675 6
a680 6
  /* Convert ELF type and flags to BFD flags.  */
  flags = (SEC_RELOC
	   | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
	   | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	   | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
	   | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0));
d682 1
a682 1
  flags = md_elf_section_flags (flags, attr, type);
a684 4
  if (old_sec == NULL)
    {
      symbolS *secsym;

a697 10
  else if (attr != 0)
    {
      /* If section attributes are specified the second time we see a
	 particular section, then check that they are the same as we
	 saw the first time.  */
      if ((old_sec->flags ^ flags)
	  & (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	     | SEC_EXCLUDE | SEC_SORT_ENTRIES))
	as_warn (_("Ignoring changed section attributes for %s"), name);
    }
d700 1
a700 1
  md_elf_section_change_hook ();
d805 1
a805 1
      md_flush_pending_output ();
d1057 1
a1057 1
     delightful bug, so we are not being incompatible here.  */
d1083 8
d1109 1
a1109 3
  if (symbol_get_obj (sym)->versioned_name == NULL)
    {
      symbol_get_obj (sym)->versioned_name = xstrdup (name);
d1111 1
a1111 1
      *input_line_pointer = c;
d1113 1
a1113 11
      if (strchr (symbol_get_obj (sym)->versioned_name,
		  ELF_VER_CHR) == NULL)
	{
	  as_bad (_("missing version name in `%s' for symbol `%s'"),
		  symbol_get_obj (sym)->versioned_name,
		  S_GET_NAME (sym));
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
d1115 4
a1118 10
      if (strcmp (symbol_get_obj (sym)->versioned_name, name))
	{
	  as_bad (_("multiple versions [`%s'|`%s'] for symbol `%s'"),
		  name, symbol_get_obj (sym)->versioned_name,
		  S_GET_NAME (sym));
	  ignore_rest_of_line ();
	  return;
	}

      *input_line_pointer = c;
d1128 1
a1128 1
struct fix *
d1161 1
a1161 1
      return NULL;
d1188 1
a1188 1
    return NULL;
d1191 3
a1193 3
  return fix_new (symbol_get_frag (csym),
		  symbol_get_value_expression (csym)->X_add_number,
		  0, psym, 0, 0, BFD_RELOC_VTABLE_INHERIT);
d1200 1
a1200 1
struct fix *
d1222 1
a1222 1
      return NULL;
d1231 3
a1234 3

  return fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
		  BFD_RELOC_VTABLE_ENTRY);
d1280 1
a1280 1
      ++input_line_pointer;	/* -> 1st char of string.  */
d1373 1
a1373 1
   There are five syntaxes:
a1382 2
   The fifth (used on SVR4/860) is
       .type SYM,"function"
a1393 1
  elf_symbol_type *elfsym;
a1397 1
  elfsym = (elf_symbol_type *) symbol_get_bfdsym (sym);
a1406 1
      || *input_line_pointer == '"'
a1419 4
#ifdef md_elf_symbol_type
  else if ((type = md_elf_symbol_type (typename, sym, elfsym)) != -1)
    ;
#endif
d1425 1
a1425 4
  if (*input_line_pointer == '"')
    ++input_line_pointer;

  elfsym->symbol.flags |= type;
d1474 1
a1474 1
  /* Make space for this first symbol.  */
d1476 1
a1476 1
  /* Zero it out.  */
a1607 5
      char *p;

      p = strchr (sy_obj->versioned_name, ELF_VER_CHR);
      know (p != NULL);

d1621 2
d1626 2
d1638 1
a1638 13
	  if (p [1] == ELF_VER_CHR && p [2] == ELF_VER_CHR)
	    {
	      size_t l;

	      /* The @@@@@@ syntax is a special case. It renames the
		 symbol name to versioned_name with one `@@' removed.  */
	      l = strlen (&p[3]) + 1;
	      memmove (&p [2], &p[3], l);
	      S_SET_NAME (symp, sy_obj->versioned_name);
	    }
	  else
	    {
	      symbolS *symp2;
d1640 5
a1644 6
	      /* FIXME: Creating a new symbol here is risky.  We're
		 in the final loop over the symbol table.  We can
		 get away with it only because the symbol goes to
		 the end of the list, where the loop will still see
		 it.  It would probably be better to do this in
		 obj_frob_file_before_adjust.  */
d1646 1
a1646 1
	      symp2 = symbol_find_or_make (sy_obj->versioned_name);
d1648 1
a1648 1
	      /* Now we act as though we saw symp2 = sym.  */
d1650 1
a1650 1
	      S_SET_SEGMENT (symp2, S_GET_SEGMENT (symp));
d1652 5
a1656 5
	      /* Subtracting out the frag address here is a hack
		 because we are in the middle of the final loop.  */
	      S_SET_VALUE (symp2,
			   (S_GET_VALUE (symp)
			    - symbol_get_frag (symp)->fr_address));
d1658 1
a1658 1
	      symbol_set_frag (symp2, symbol_get_frag (symp));
d1660 2
a1661 2
	      /* This will copy over the size information.  */
	      copy_symbol_attributes (symp2, symp);
d1663 2
a1664 2
	      if (S_IS_WEAK (symp))
		S_SET_WEAK (symp2);
d1666 2
a1667 3
	      if (S_IS_EXTERNAL (symp))
		S_SET_EXTERNAL (symp2);
	    }
a1717 36
/* It removes any unneeded versioned symbols from the symbol table.  */

void
elf_frob_file_before_adjust ()
{
  if (symbol_rootP)
    {
      symbolS *symp;

      for (symp = symbol_rootP; symp; symp = symbol_next (symp))
	if (symbol_get_obj (symp)->versioned_name)
	  {
	    if (!S_IS_DEFINED (symp))
	      {
		char *p;

		/* The @@@@@@ syntax is a special case. If the symbol is
		   not defined, 2 `@@'s will be removed from the
		   versioned_name.  */

		p = strchr (symbol_get_obj (symp)->versioned_name,
			    ELF_VER_CHR);
		know (p != NULL);
		if (p [1] == ELF_VER_CHR && p [2] == ELF_VER_CHR)
		  {
		    size_t l = strlen (&p[3]) + 1;
		    memmove (&p [1], &p[3], l);
		  }
		if (symbol_used_p (symp) == 0
		    && symbol_used_in_reloc_p (symp) == 0)
		  symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	      }
	  }
    }
}

a1892 20
static int
elf_separate_stab_sections ()
{
#ifdef NEED_ECOFF_DEBUG
  return (!ECOFF_DEBUGGING);
#else
  return 1;
#endif
}

static void
elf_init_stab_section (seg)
     segT seg;
{
#ifdef NEED_ECOFF_DEBUG
  if (!ECOFF_DEBUGGING)
#endif
    obj_elf_init_stab_section (seg);
}

a1897 2
  elf_begin,
  elf_file_symbol,
a1899 1
  elf_frob_file_before_adjust,
a1903 1
  elf_s_set_other,
a1904 3
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
a1912 2
  elf_separate_stab_sections,
  elf_init_stab_section,
d1921 1
a1921 1
  elf_obj_symbol_new_hook
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 2
a3 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003 Free Software Foundation, Inc.
a23 1
#include "safe-ctype.h"
a25 1
#include "struc-symbol.h"
d58 1
a60 1
static void build_group_lists PARAMS ((bfd *, asection *, PTR));
a62 1
static symbolS *elf_common PARAMS ((int));
d65 1
a65 1
static bfd_boolean elf_get_extr PARAMS ((asymbol *, EXTR *));
a76 4
static int obj_elf_parse_section_letters PARAMS ((char *, size_t));
static int obj_elf_section_word PARAMS ((char *, size_t));
static char *obj_elf_section_name PARAMS ((void));
static int obj_elf_section_type PARAMS ((char *, size_t));
a79 1
static void obj_elf_tls_common PARAMS ((int));
a125 2
  {"tls_common", obj_elf_tls_common, 0},

d245 7
d283 2
a284 2
static symbolS *
elf_common (is_common)
d290 1
a290 1
  offsetT temp, size, sign;
a292 1
  expressionS exp;
d297 1
a297 1
      return NULL;
d308 1
a308 1
      as_bad (_("expected comma after symbol-name"));
d310 1
a310 1
      return NULL;
d313 1
a313 4
  temp = get_absolute_expr (&exp);
  sign = (offsetT) 1 << (stdoutput->arch_info->bits_per_address - 1);
  size = temp & ((sign << 1) - 1);
  if (temp != size || !exp.X_unsigned)
d315 1
a315 1
      as_bad (_(".COMMon length (%ld) out of range, ignored."), (long) temp);
d317 1
a317 1
      return NULL;
d319 1
d325 1
a325 1
      as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));
d327 1
a327 1
      return NULL;
d333 2
a334 3
	  as_warn (_("length of .comm \"%s\" is already %ld; not changed to %ld"),
		   S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP),
		   (long) size);
d352 2
a353 2
	  temp = get_absolute_expr (&exp);
	  if (!exp.X_unsigned)
d356 1
a356 1
	      as_warn (_("common alignment negative; 0 assumed"));
d375 1
a375 1
		  as_bad (_("common alignment not a power of 2"));
d377 1
a377 1
		  return NULL;
d429 1
a429 1
  return symbolP;
d442 1
a442 1
    return NULL;
a445 17
void
obj_elf_common (is_common)
     int is_common;
{
  elf_common (is_common);
}

static void
obj_elf_tls_common (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *symbolP = elf_common (0);

  if (symbolP)
    symbol_get_bfdsym (symbolP)->flags |= BSF_THREAD_LOCAL;
}

d528 1
a528 2
      elfsym->internal_elf_sym.st_other &= ~3;
      elfsym->internal_elf_sym.st_other |= visibility;
a590 4
#if defined (TC_HPPA) && !defined (TE_LINUX) && TARGET_ARCH_SIZE == 64
  { ".fini",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
  { ".init",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE		},
#else
a592 1
#endif
a596 2
  { ".tbss",	SHT_NOBITS,	SHF_ALLOC + SHF_WRITE + SHF_TLS	},
  { ".tdata",	SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_TLS	},
a597 3
  { ".init_array",SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE         },
  { ".fini_array",SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE         },
  { ".preinit_array",SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE   },
d623 3
a625 8
obj_elf_change_section (name, type, attr, entsize, group_name, linkonce, push)
     const char *name;
     int type;
     int attr;
     int entsize;
     const char *group_name;
     int linkonce;
     int push;
d662 1
a662 10
	    if (old_sec == NULL
		/* FIXME: gcc, as of 2002-10-22, will emit

		   .section .init_array,"aw",@@progbits

		   for __attribute__ ((section (".init_array"))).
		   "@@progbits" is incorrect.  */
		&& special_sections[i].type != SHT_INIT_ARRAY
		&& special_sections[i].type != SHT_FINI_ARRAY
		&& special_sections[i].type != SHT_PREINIT_ARRAY)
d664 1
a664 1
		as_warn (_("setting incorrect section type for %s"), name);
d668 1
a668 1
		as_warn (_("ignoring incorrect section type for %s"), name);
d681 1
a681 1
	      as_warn (_("setting incorrect section attributes for %s"),
d693 1
a693 4
	   | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0)
	   | ((attr & SHF_MERGE) ? SEC_MERGE : 0)
	   | ((attr & SHF_STRINGS) ? SEC_STRINGS : 0)
	   | ((attr & SHF_TLS) ? SEC_THREAD_LOCAL : 0));
a705 2
      if (linkonce)
	flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
a706 3
      if (flags & SEC_MERGE)
	sec->entsize = entsize;
      elf_group_name (sec) = group_name;
d720 4
a723 11
      if (((old_sec->flags ^ flags)
	   & (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	      | SEC_EXCLUDE | SEC_SORT_ENTRIES | SEC_MERGE | SEC_STRINGS
	      | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
	      | SEC_THREAD_LOCAL)))
	as_warn (_("ignoring changed section attributes for %s"), name);
      if ((flags & SEC_MERGE) && old_sec->entsize != (unsigned) entsize)
	as_warn (_("ignoring changed section entity size for %s"), name);
      if ((attr & SHF_GROUP) != 0
	  && strcmp (elf_group_name (old_sec), group_name) != 0)
	as_warn (_("ignoring new section group for %s"), name);
d731 1
a731 1
static int
a750 24
	case 'M':
	  attr |= SHF_MERGE;
	  break;
	case 'S':
	  attr |= SHF_STRINGS;
	  break;
	case 'G':
	  attr |= SHF_GROUP;
	  break;
	case 'T':
	  attr |= SHF_TLS;
	  break;
	/* Compatibility.  */
	case 'm':
	  if (*(str - 1) == 'a')
	    {
	      attr |= SHF_MERGE;
	      if (len > 1 && str[1] == 's')
		{
		  attr |= SHF_STRINGS;
		  str++, len--;
		}
	      break;
	    }
d753 1
a753 1
	    char *bad_msg = _("unrecognized .section attribute: want a,w,x,M,S,G,T");
d773 1
a773 1
static int
a783 2
  if (len == 3 && strncmp (str, "tls", 3) == 0)
    return SHF_TLS;
d793 1
a793 1
  as_warn (_("unrecognized section attribute"));
d797 1
a797 1
static int
d815 1
a815 1
  as_warn (_("unrecognized section type"));
a818 40
/* Get name of section.  */
static char *
obj_elf_section_name ()
{
  char *name;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      int dummy;

      name = demand_copy_C_string (&dummy);
      if (name == NULL)
	{
	  ignore_rest_of_line ();
	  return NULL;
	}
    }
  else
    {
      char *end = input_line_pointer;

      while (0 == strchr ("\n\t,; ", *end))
	end++;
      if (end == input_line_pointer)
	{
	  as_warn (_("missing name"));
	  ignore_rest_of_line ();
	  return NULL;
	}

      name = xmalloc (end - input_line_pointer + 1);
      memcpy (name, input_line_pointer, end - input_line_pointer);
      name[end - input_line_pointer] = '\0';
      input_line_pointer = end;
    }
  SKIP_WHITESPACE ();
  return name;
}

d823 1
a823 1
  char *name, *group_name, *beg;
a824 2
  int entsize;
  int linkonce;
d848 30
a877 3
  name = obj_elf_section_name ();
  if (name == NULL)
    return;
a879 3
  group_name = NULL;
  entsize = 0;
  linkonce = 0;
a900 2
	      char *save = input_line_pointer;

a920 42
	      else
		input_line_pointer = save;
	    }

	  SKIP_WHITESPACE ();
	  if ((attr & SHF_MERGE) != 0 && *input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      entsize = get_absolute_expression ();
	      SKIP_WHITESPACE ();
	      if (entsize < 0)
		{
		  as_warn (_("invalid merge entity size"));
		  attr &= ~SHF_MERGE;
		  entsize = 0;
		}
	    }
	  else if ((attr & SHF_MERGE) != 0)
	    {
	      as_warn (_("entity size for SHF_MERGE not specified"));
	      attr &= ~SHF_MERGE;
	    }

	  if ((attr & SHF_GROUP) != 0 && *input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      group_name = obj_elf_section_name ();
	      if (group_name == NULL)
		attr &= ~SHF_GROUP;
	      else if (strncmp (input_line_pointer, ",comdat", 7) == 0)
		{
		  input_line_pointer += 7;
		  linkonce = 1;
		}
	      else if (strncmp (name, ".gnu.linkonce", 13) == 0)
		linkonce = 1;
	    }
	  else if ((attr & SHF_GROUP) != 0)
	    {
	      as_warn (_("group name for SHF_GROUP not specified"));
	      attr &= ~SHF_GROUP;
d932 1
a932 1
		  as_warn (_("character following name is not '#'"));
d951 1
a951 1
  obj_elf_change_section (name, type, attr, entsize, group_name, linkonce, push);
d1033 1
a1033 1
      as_warn (_(".previous without corresponding .section; ignored"));
d1060 1
a1060 1
      as_warn (_(".popsection without corresponding .pushsection; ignored"));
a1100 1
  char old_lexat;
a1118 1
  SKIP_WHITESPACE ();
d1120 7
a1126 6

  /* Temporarily include '@@' in symbol names.  */
  old_lexat = lex_type[(unsigned char) '@@'];
  lex_type[(unsigned char) '@@'] |= LEX_NAME;
  c = get_symbol_end ();
  lex_type[(unsigned char) '@@'] = old_lexat;
d1209 1
a1209 1
	  || ISSPACE (input_line_pointer[1])))
a1298 29
/* When setting one symbol equal to another, by default we probably
   want them to have the same "size", whatever it means in the current
   context.  */

void
elf_copy_symbol_attributes (dest, src)
     symbolS *dest, *src;
{
  struct elf_obj_sy *srcelf = symbol_get_obj (src);
  struct elf_obj_sy *destelf = symbol_get_obj (dest);
  if (srcelf->size)
    {
      if (destelf->size == NULL)
	destelf->size =
	  (expressionS *) xmalloc (sizeof (expressionS));
      *destelf->size = *srcelf->size;
    }
  else
    {
      if (destelf->size != NULL)
	free (destelf->size);
      destelf->size = NULL;
    }
  S_SET_SIZE (dest, S_GET_SIZE (src));
  /* Don't copy visibility.  */
  S_SET_OTHER (dest, (ELF_ST_VISIBILITY (S_GET_OTHER (dest))
		      | (S_GET_OTHER (src) & ~ELF_ST_VISIBILITY (-1))));
}

d1305 1
d1312 1
a1312 1
  int len;
d1342 1
a1342 1
      md_number_to_chars (p, (valueT) i_note.namesz, sizeof (e_note.namesz));
d1344 1
a1344 1
      md_number_to_chars (p, (valueT) i_note.descsz, sizeof (e_note.descsz));
d1346 1
a1346 3
      md_number_to_chars (p, (valueT) i_note.type, sizeof (e_note.type));
      p = frag_more (len + 1);
      strcpy (p, name);
d1348 7
d1361 1
a1361 1
      as_bad (_("expected quoted string"));
d1399 1
a1399 8
    {
      S_SET_SIZE (sym, exp.X_add_number);
      if (symbol_get_obj (sym)->size)
	{
	  xfree (symbol_get_obj (sym)->size);
	  symbol_get_obj (sym)->size = NULL;
	}
    }
a1461 3
  else if (strcmp (typename, "tls_object") == 0
	   || strcmp (typename, "STT_TLS") == 0)
    type = BSF_OBJECT | BSF_THREAD_LOCAL;
d1467 1
a1467 1
    as_bad (_("unrecognized symbol type \"%s\""), typename);
d1528 1
a1528 1
  stabstr_name = (char *) xmalloc (strlen (segment_name (seg)) + 4);
d1594 1
a1594 1
static bfd_boolean
d1600 1
a1600 1
    return FALSE;
d1602 1
a1602 1
  return TRUE;
d1682 1
a1682 1
	      *puntp = TRUE;
a1725 2
	      S_SET_OTHER (symp2, S_GET_OTHER (symp));

d1739 1
a1739 1
	as_bad (_("symbol `%s' can not be both weak and common"),
a1771 53
struct group_list
{
  asection **head;		/* Section lists.  */
  unsigned int *elt_count;	/* Number of sections in each list.  */
  unsigned int num_group;	/* Number of lists.  */
};

/* Called via bfd_map_over_sections.  If SEC is a member of a group,
   add it to a list of sections belonging to the group.  INF is a
   pointer to a struct group_list, which is where we store the head of
   each list.  */

static void
build_group_lists (abfd, sec, inf)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR inf;
{
  struct group_list *list = (struct group_list *) inf;
  const char *group_name = elf_group_name (sec);
  unsigned int i;

  if (group_name == NULL)
    return;

  /* If this group already has a list, add the section to the head of
     the list.  */
  for (i = 0; i < list->num_group; i++)
    {
      if (strcmp (group_name, elf_group_name (list->head[i])) == 0)
	{
	  elf_next_in_group (sec) = list->head[i];
	  list->head[i] = sec;
	  list->elt_count[i] += 1;
	  return;
	}
    }

  /* New group.  Make the arrays bigger in chunks to minimize calls to
     realloc.  */
  i = list->num_group;
  if ((i & 127) == 0)
    {
      unsigned int newsize = i + 128;
      list->head = xrealloc (list->head, newsize * sizeof (*list->head));
      list->elt_count = xrealloc (list->elt_count,
				  newsize * sizeof (*list->elt_count));
    }
  list->head[i] = sec;
  list->elt_count[i] = 1;
  list->num_group += 1;
}

a1774 3
  struct group_list list;
  unsigned int i;

a1776 62
  /* Go find section groups.  */
  list.num_group = 0;
  list.head = NULL;
  list.elt_count = NULL;
  bfd_map_over_sections (stdoutput, build_group_lists, (PTR) &list);

  /* Make the SHT_GROUP sections that describe each section group.  We
     can't set up the section contents here yet, because elf section
     indices have yet to be calculated.  elf.c:set_group_contents does
     the rest of the work.  */
  for (i = 0; i < list.num_group; i++)
    {
      const char *group_name = elf_group_name (list.head[i]);
      const char *sec_name;
      asection *s;
      flagword flags;
      struct symbol *sy;
      int has_sym;

      flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP;
      for (s = list.head[i]; s != NULL; s = elf_next_in_group (s))
	if ((s->flags ^ flags) & SEC_LINK_ONCE)
	  {
	    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
	    if (s != list.head[i])
	      {
		as_warn (_("assuming all members of group `%s' are COMDAT"),
			 group_name);
		break;
	      }
	  }

      sec_name = group_name;
      sy = symbol_find_exact (group_name);
      has_sym = 0;
      if (sy != NULL
	  && (sy == symbol_lastP
	      || (sy->sy_next != NULL
		  && sy->sy_next->sy_previous == sy)))
	{
	  has_sym = 1;
	  sec_name = ".group";
	}
      s = subseg_force_new (sec_name, 0);
      if (s == NULL
	  || !bfd_set_section_flags (stdoutput, s, flags)
	  || !bfd_set_section_alignment (stdoutput, s, 2))
	{
	  as_fatal (_("can't create group: %s"),
		    bfd_errmsg (bfd_get_error ()));
	}

      /* Pass a pointer to the first section in this group.  */
      elf_next_in_group (s) = list.head[i];
      if (has_sym)
	elf_group_id (s) = sy->bsym;

      s->_raw_size = 4 * (list.elt_count[i] + 1);
      s->contents = frag_more (s->_raw_size);
      frag_now->fr_fix = frag_now_fix_octets ();
    }

d1792 1
a1792 1
	if (!S_IS_DEFINED (symp))
d1794 1
a1794 1
	    if (symbol_get_obj (symp)->versioned_name)
a1813 8

	    /* If there was .weak foo, but foo was neither defined nor
	       used anywhere, remove it.  */

	    else if (S_IS_WEAK (symp)
		     && symbol_used_p (symp) == 0
		     && symbol_used_in_reloc_p (symp) == 0)
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
d1860 1
a1860 1
      if (! bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, TRUE,
d1862 1
a1862 1
	as_fatal (_("failed to set up debugging information: %s"),
d1868 1
a1868 1
      know (!stdoutput->output_has_begun);
d1882 1
a1882 1
	as_fatal (_("can't start writing .mdebug section: %s"),
d1885 1
a1885 1
      know (stdoutput->output_has_begun);
d1890 1
a1890 1
	as_fatal (_("could not write .mdebug section: %s"),
a2022 1
  0,	/* obj_frob_file_before_fix */
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@a27 1
#include "dwarf2dbg.h"
d55 33
a87 12
static void obj_elf_line (int);
static void obj_elf_size (int);
static void obj_elf_type (int);
static void obj_elf_ident (int);
static void obj_elf_weak (int);
static void obj_elf_local (int);
static void obj_elf_visibility (int);
static void obj_elf_symver (int);
static void obj_elf_subsection (int);
static void obj_elf_popsection (int);
static void obj_elf_tls_common (int);
static void obj_elf_lcomm (int);
a93 1
  {"lcomm", obj_elf_lcomm, 0},
d122 2
a123 2
  {"vtable_inherit", (void (*) (int)) &obj_elf_vtable_inherit, 0},
  {"vtable_entry", (void (*) (int)) &obj_elf_vtable_entry, 0},
a128 3
  /* These are used for dwarf2.  */
  { "file", (void (*) (int)) dwarf2_directive_file, 0 },
  { "loc",  dwarf2_directive_loc,  0 },
d191 1
a191 1
elf_begin (void)
a192 2
  asection *s;

d194 6
a199 6
  s = bfd_get_section_by_name (stdoutput, TEXT_SECTION_NAME);
  symbol_table_insert (section_symbol (s));
  s = bfd_get_section_by_name (stdoutput, DATA_SECTION_NAME);
  symbol_table_insert (section_symbol (s));
  s = bfd_get_section_by_name (stdoutput, BSS_SECTION_NAME);
  symbol_table_insert (section_symbol (s));
d203 1
a203 1
elf_pop_insert (void)
d211 2
a212 1
elf_s_get_size (symbolS *sym)
d218 3
a220 1
elf_s_set_size (symbolS *sym, bfd_vma sz)
d226 2
a227 1
elf_s_get_align (symbolS *sym)
d233 3
a235 1
elf_s_set_align (symbolS *sym, bfd_vma align)
d241 2
a242 1
elf_s_get_other (symbolS *sym)
d248 3
a250 1
elf_s_set_other (symbolS *sym, int other)
d256 2
a257 1
elf_sec_sym_ok_for_reloc (asection *sec)
d263 2
a264 1
elf_file_symbol (const char *s)
d268 1
a268 1
  sym = symbol_new (s, absolute_section, 0, NULL);
a285 3
/* Called from read.c:s_comm after we've parsed .comm symbol, size.
   Parse a possible alignment value.  */

d287 2
a288 1
elf_common_parse (int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT size)
d290 7
a296 2
  addressT align = 0;
  int is_local = symbol_get_obj (symbolP)->local;
d298 1
a298 1
  if (*input_line_pointer == ',')
d300 3
a302 1
      char *save = input_line_pointer;
d304 46
d352 15
a366 2

      if (*input_line_pointer == '"')
d368 9
a376 11
	  /* For sparc.  Accept .common symbol, length, "bss"  */
	  input_line_pointer++;
	  /* Some use the dot, some don't.  */
	  if (*input_line_pointer == '.')
	    input_line_pointer++;
	  /* Some say data, some say bss.  */
	  if (strncmp (input_line_pointer, "bss\"", 4) == 0)
	    input_line_pointer += 4;
	  else if (strncmp (input_line_pointer, "data\"", 5) == 0)
	    input_line_pointer += 5;
	  else
d378 8
a385 14
	      char *p = input_line_pointer;
	      char c;

	      while (*--p != '"')
		;
	      while (!is_end_of_line[(unsigned char) *input_line_pointer])
		if (*input_line_pointer++ == '"')
		  break;
	      c = *input_line_pointer;
	      *input_line_pointer = '\0';
	      as_bad (_("bad .common segment %s"), p);
	      *input_line_pointer = c;
	      ignore_rest_of_line ();
	      return NULL;
d387 16
a402 2
	  /* ??? Don't ask me why these are always global.  */
	  is_local = 0;
d406 5
a410 4
	  input_line_pointer = save;
	  align = parse_align (is_local);
	  if (align == (addressT) -1)
	    return NULL;
a412 6

  if (is_local)
    {
      bss_alloc (symbolP, size, align);
      S_CLEAR_EXTERNAL (symbolP);
    }
d415 16
a430 4
      S_SET_VALUE (symbolP, size);
      S_SET_ALIGN (symbolP, align);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
d435 1
d437 14
d454 2
a455 1
obj_elf_common (int is_common)
d457 1
a457 4
  if (flag_mri && is_common)
    s_mri_common (0);
  else
    s_comm_internal (0, elf_common_parse);
d461 2
a462 1
obj_elf_tls_common (int ignore ATTRIBUTE_UNUSED)
d464 1
a464 1
  symbolS *symbolP = s_comm_internal (0, elf_common_parse);
d471 2
a472 10
obj_elf_lcomm (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = s_comm_internal (0, s_lcomm_internal);

  if (symbolP)
    symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
}

static void
obj_elf_local (int ignore ATTRIBUTE_UNUSED)
d500 2
a501 1
obj_elf_weak (int ignore ATTRIBUTE_UNUSED)
d529 2
a530 1
obj_elf_visibility (int visibility)
d600 57
d658 8
a665 7
obj_elf_change_section (const char *name,
			int type,
			int attr,
			int entsize,
			const char *group_name,
			int linkonce,
			int push)
d670 1
a670 1
  const struct bfd_elf_special_section *ssect;
a692 1
  ssect = _bfd_elf_get_sec_type_attr (stdoutput, name);
d694 10
a703 3
  if (ssect != NULL)
    {
      bfd_boolean override = FALSE;
d705 1
a705 6
      if (type == SHT_NULL)
	type = ssect->type;
      else if (type != ssect->type)
	{
	  if (old_sec == NULL
	      /* FIXME: gcc, as of 2002-10-22, will emit
d707 23
a729 47
		 .section .init_array,"aw",@@progbits

		 for __attribute__ ((section (".init_array"))).
		 "@@progbits" is incorrect.  */
	      && ssect->type != SHT_INIT_ARRAY
	      && ssect->type != SHT_FINI_ARRAY
	      && ssect->type != SHT_PREINIT_ARRAY)
	    {
	      /* We allow to specify any type for a .note section.  */
	      if (ssect->type != SHT_NOTE)
		as_warn (_("setting incorrect section type for %s"),
			 name);
	    }
	  else
	    {
	      as_warn (_("ignoring incorrect section type for %s"),
		       name);
	      type = ssect->type;
	    }
	}

      if (old_sec == NULL && (attr & ~ssect->attr) != 0)
	{
	  /* As a GNU extension, we permit a .note section to be
	     allocatable.  If the linker sees an allocatable .note
	     section, it will create a PT_NOTE segment in the output
	     file.  We also allow "x" for .note.GNU-stack.  */
	  if (ssect->type == SHT_NOTE
	      && (attr == SHF_ALLOC || attr == SHF_EXECINSTR))
	    ;
	  /* Allow different SHF_MERGE and SHF_STRINGS if we have
	     something like .rodata.str.  */
	  else if (ssect->suffix_length == -2
		   && name[ssect->prefix_length] == '.'
		   && (attr
		       & ~ssect->attr
		       & ~SHF_MERGE
		       & ~SHF_STRINGS) == 0)
	    ;
	  /* .interp, .strtab and .symtab can have SHF_ALLOC.  */
	  else if (attr == SHF_ALLOC
		   && (strcmp (name, ".interp") == 0
		       || strcmp (name, ".strtab") == 0
		       || strcmp (name, ".symtab") == 0))
	    override = TRUE;
	  else
	    {
d732 4
a735 11
	      override = TRUE;
	    }
	}
      if (!override && old_sec == NULL)
	attr |= ssect->attr;
    }

  if (type != SHT_NULL)
    elf_section_type (sec) = type;
  if (attr != 0)
    elf_section_flags (sec) = attr;
d756 1
a756 1
	seg_info (sec)->bss = 1;
d770 1
a770 1
	symbol_table_insert (section_symbol (sec));
d796 3
a798 1
obj_elf_parse_section_letters (char *str, size_t len)
d848 4
a851 1
	      as_fatal ("%s", bad_msg);
d862 3
a864 1
obj_elf_section_word (char *str, size_t len)
d888 3
a890 1
obj_elf_section_type (char *str, size_t len)
a895 2
  if (len == 4 && strncmp (str, "note", 4) == 0)
    return SHT_NOTE;
d911 1
a911 1
obj_elf_section_name (void)
d935 1
a935 1
	  as_bad (_("missing name"));
a942 3
#ifdef tc_canonicalize_section_name
      name = tc_canonicalize_section_name (name);
#endif
d950 2
a951 1
obj_elf_section (int push)
d1084 1
a1084 1
		  as_bad (_("character following name is not '#'"));
d1109 2
a1110 1
obj_elf_data (int i)
d1128 2
a1129 1
obj_elf_text (int i)
d1145 2
a1146 1
obj_elf_subsection (int ignore ATTRIBUTE_UNUSED)
d1170 1
a1170 1
obj_elf_section_change_hook (void)
d1177 2
a1178 1
obj_elf_previous (int ignore ATTRIBUTE_UNUSED)
d1205 2
a1206 1
obj_elf_popsection (int xxx ATTRIBUTE_UNUSED)
d1232 2
a1233 1
obj_elf_line (int ignore ATTRIBUTE_UNUSED)
d1237 1
a1237 1
  new_logical_line (NULL, get_absolute_expression ());
d1248 2
a1249 1
obj_elf_symver (int ignore ATTRIBUTE_UNUSED)
d1319 2
a1320 1
obj_elf_vtable_inherit (int ignore ATTRIBUTE_UNUSED)
d1391 2
a1392 1
obj_elf_vtable_entry (int ignore ATTRIBUTE_UNUSED)
d1428 1
a1428 1
elf_obj_read_begin_hook (void)
d1437 2
a1438 1
elf_obj_symbol_new_hook (symbolS *symbolP)
d1457 2
a1458 1
elf_copy_symbol_attributes (symbolS *dest, symbolS *src)
d1465 2
a1466 1
	destelf->size = xmalloc (sizeof (expressionS));
d1482 2
a1483 1
obj_elf_version (int ignore ATTRIBUTE_UNUSED)
d1492 1
a1492 1
  asection *note_secp = NULL;
d1523 1
a1523 1
      md_number_to_chars (p, i_note.namesz, sizeof (e_note.namesz));
d1525 1
a1525 1
      md_number_to_chars (p, i_note.descsz, sizeof (e_note.descsz));
d1527 1
a1527 1
      md_number_to_chars (p, i_note.type, sizeof (e_note.type));
d1543 2
a1544 1
obj_elf_size (int ignore ATTRIBUTE_UNUSED)
d1585 2
a1586 1
      symbol_get_obj (sym)->size = xmalloc (sizeof (expressionS));
d1608 2
a1609 1
obj_elf_type (int ignore ATTRIBUTE_UNUSED)
a1647 3
  else if (strcmp (typename, "notype") == 0
	   || strcmp (typename, "STT_NOTYPE") == 0)
    ;
d1666 2
a1667 1
obj_elf_ident (int ignore ATTRIBUTE_UNUSED)
d1697 2
a1698 1
obj_elf_init_stab_section (segT seg)
d1713 2
a1714 2
  as_where (&file, NULL);
  stabstr_name = xmalloc (strlen (segment_name (seg)) + 4);
d1728 4
a1731 1
adjust_stab_sections (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)
d1743 1
a1743 1
  name = alloca (strlen (sec->name) + 4);
d1756 2
a1757 2
  bfd_h_put_16 (abfd, nsyms, p + 6);
  bfd_h_put_32 (abfd, strsz, p + 8);
d1769 3
a1771 1
elf_ecoff_set_ext (symbolS *sym, struct ecoff_extr *ext)
d1773 1
a1773 1
  symbol_get_bfdsym (sym)->udata.p = ext;
d1781 3
a1783 1
elf_get_extr (asymbol *sym, EXTR *ext)
d1794 1
d1796 3
a1798 2
elf_set_index (asymbol *sym ATTRIBUTE_UNUSED,
	       bfd_size_type indx ATTRIBUTE_UNUSED)
d1805 3
a1807 1
elf_frob_symbol (symbolS *symp, int *puntp)
d1850 3
a1852 3
	 If this is an external reference, just rename the symbol to
	 include the version string.  This will make the relocs be
	 against the correct versioned symbol.
d1862 2
a1863 2
	     reserved for definitions of the default version to link
	     against.  */
d1874 1
a1874 1
	  if (p[1] == ELF_VER_CHR && p[2] == ELF_VER_CHR)
d1881 1
a1881 1
	      memmove (&p[2], &p[3], l);
d1973 4
a1976 1
build_group_lists (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
d1978 1
a1978 1
  struct group_list *list = inf;
d2014 1
a2014 1
elf_frob_file (void)
d2019 1
a2019 1
  bfd_map_over_sections (stdoutput, adjust_stab_sections, NULL);
d2025 1
a2025 1
  bfd_map_over_sections (stdoutput, build_group_lists, &list);
a2071 1
      elf_section_type (s) = SHT_GROUP;
d2091 1
a2091 1
elf_frob_file_before_adjust (void)
d2111 1
a2111 1
		if (p[1] == ELF_VER_CHR && p[2] == ELF_VER_CHR)
d2114 1
a2114 1
		    memmove (&p[1], &p[3], l);
d2138 1
a2138 1
elf_frob_file_after_relocs (void)
d2151 1
a2151 1
      know (debug_swap != NULL);
d2159 4
a2162 4
      SET (external_dnr, cbDnOffset, void *);
      SET (external_pdr, cbPdOffset, void *);
      SET (external_sym, cbSymOffset, void *);
      SET (external_opt, cbOptOffset, void *);
d2165 2
a2166 2
      SET (external_fdr, cbFdOffset, void *);
      SET (external_rfd, cbRfdOffset, void *);
d2191 5
a2195 4
	 eventually become a call to fwrite, and ISO C prohibits
	 passing a NULL pointer to a stdio function even if the
	 pointer will not be used.  */
      if (! bfd_set_section_contents (stdoutput, sec, buf, 0, 0))
d2212 1
a2212 1
/* Heavily plagiarized from obj_elf_version.  The idea is to emit the
d2232 1
a2232 1
			   don't know enough about the source
d2241 1
a2241 1
sco_id (void)
d2252 1
a2252 1
  asection *note_secp = NULL;
d2269 1
a2269 1
  md_number_to_chars (p, i_note.namesz, 4);
d2272 1
a2272 1
  md_number_to_chars (p, i_note.descsz, 4);
d2275 1
a2275 1
  md_number_to_chars (p, i_note.type, 4);
d2308 1
a2308 1
elf_separate_stab_sections (void)
d2318 2
a2319 1
elf_init_stab_section (segT seg)
@


