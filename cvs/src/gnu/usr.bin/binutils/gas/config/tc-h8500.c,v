head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.50
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.46
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.48
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.40
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.44
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.42
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.38
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.36
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.34
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.32
	OPENBSD_5_0:1.4.0.30
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.28
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.26
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.22
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.24
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.20
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.18
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.16
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.05.17.21.54.30;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.35;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.49;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.04;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.04;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.46.24;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.34.26;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.29;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* tc-h8500.c -- Assemble code for the Renesas H8/500
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Written By Steve Chamberlain <sac@@cygnus.com>.  */

#include <stdio.h>
#include "as.h"
#include "bfd.h"
#include "subsegs.h"
#define DEFINE_TABLE
#define ASSEMBLER_TABLE
#include "opcodes/h8500-opc.h"
#include "safe-ctype.h"

const char comment_chars[] = "!";
const char line_separator_chars[] = ";";
const char line_comment_chars[] = "!#";

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
   pseudo-op name without dot
   function to call to execute this pseudo-op
   Integer arg to pass to the function
   */

const pseudo_typeS md_pseudo_table[] =
{
  {"int", cons, 2},
  {"data.b", cons, 1},
  {"data.w", cons, 2},
  {"data.l", cons, 4},
  {"form", listing_psize, 0},
  {"heading", listing_title, 0},
  {"import", s_ignore, 0},
  {"page", listing_eject, 0},
  {"program", s_ignore, 0},
  {0, 0, 0}
};

const int md_reloc_size;

const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

#define C(a,b) ENCODE_RELAX(a,b)
#define ENCODE_RELAX(what,length) (((what) << 2) + (length))

#define GET_WHAT(x) ((x>>2))

#define BYTE_DISP 1
#define WORD_DISP 2
#define UNDEF_BYTE_DISP 0
#define UNDEF_WORD_DISP 3

#define BRANCH  1
#define SCB_F   2
#define SCB_TST 3
#define END 4

#define BYTE_F 127
#define BYTE_B -126
#define WORD_F 32767
#define WORD_B 32768

relax_typeS md_relax_table[C (END, 0)] = {
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },

  /* BRANCH */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  2, C (BRANCH, WORD_DISP) },
  { WORD_F, WORD_B,  3, 0 },
  { 0,      0,       3, 0 },

  /* SCB_F */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  3, C (SCB_F, WORD_DISP) },
  { WORD_F, WORD_B,  8, 0 },
  { 0,      0,       8, 0 },

  /* SCB_TST */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  3, C (SCB_TST, WORD_DISP) },
  { WORD_F, WORD_B, 10, 0 },
  { 0,      0,      10, 0 }

};

static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */

/*
  This function is called once, at assembler startup time.  This should
  set up all the tables, etc. that the MD part of the assembler needs
  */

void
md_begin ()
{
  const h8500_opcode_info *opcode;
  char prev_buffer[100];
  int idx = 0;

  opcode_hash_control = hash_new ();
  prev_buffer[0] = 0;

  /* Insert unique names into hash table */
  for (opcode = h8500_table; opcode->name; opcode++)
    {
      if (idx != opcode->idx)
	{
	  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
	  idx++;
	}
    }
}

static int rn;			/* register number used by RN */
static int rs;			/* register number used by RS */
static int rd;			/* register number used by RD */
static int crb;			/* byte size cr */
static int crw;			/* word sized cr */
static int cr;			/* unknown size cr */

static expressionS displacement;/* displacement expression */

static int immediate_inpage;
static expressionS immediate;	/* immediate expression */

static expressionS absolute;	/* absolute expression */

typedef struct
{
  int type;
  int reg;
  expressionS exp;
  int page;
}

h8500_operand_info;

/* Try to parse a reg name.  Return the number of chars consumed.  */

static int parse_reg PARAMS ((char *, int *, int *));

static int
parse_reg (src, mode, reg)
     char *src;
     int *mode;
     int *reg;
{
  char *end;
  int len;

  /* Cribbed from get_symbol_end().  */
  if (!is_name_beginner (*src) || *src == '\001')
    return 0;
  end = src + 1;
  while (is_part_of_name (*end) || *end == '\001')
    end++;
  len = end - src;

  if (len == 2 && src[0] == 'r')
    {
      if (src[1] >= '0' && src[1] <= '7')
	{
	  *mode = RN;
	  *reg = (src[1] - '0');
	  return len;
	}
    }
  if (len == 2 && src[0] == 's' && src[1] == 'p')
    {
      *mode = RN;
      *reg = 7;
      return len;
    }
  if (len == 3 && src[0] == 'c' && src[1] == 'c' && src[2] == 'r')
    {
      *mode = CRB;
      *reg = 1;
      return len;
    }
  if (len == 2 && src[0] == 's' && src[1] == 'r')
    {
      *mode = CRW;
      *reg = 0;
      return len;
    }
  if (len == 2 && src[0] == 'b' && src[1] == 'r')
    {
      *mode = CRB;
      *reg = 3;
      return len;
    }
  if (len == 2 && src[0] == 'e' && src[1] == 'p')
    {
      *mode = CRB;
      *reg = 4;
      return len;
    }
  if (len == 2 && src[0] == 'd' && src[1] == 'p')
    {
      *mode = CRB;
      *reg = 5;
      return len;
    }
  if (len == 2 && src[0] == 't' && src[1] == 'p')
    {
      *mode = CRB;
      *reg = 7;
      return len;
    }
  if (len == 2 && src[0] == 'f' && src[1] == 'p')
    {
      *mode = RN;
      *reg = 6;
      return len;
    }
  return 0;
}

static char *parse_exp PARAMS ((char *, expressionS *, int *));

static char *
parse_exp (s, op, page)
     char *s;
     expressionS *op;
     int *page;
{
  char *save;
  char *new;

  save = input_line_pointer;

  *page = 0;
  if (s[0] == '%')
    {
      if (s[1] == 'p' && s[2] == 'a' && s[3] == 'g' && s[4] == 'e')
	{
	  s += 5;
	  *page = 'p';
	}
      if (s[1] == 'h' && s[2] == 'i' && s[3] == '1' && s[4] == '6')
	{
	  s += 5;
	  *page = 'h';
	}
      else if (s[1] == 'o' && s[2] == 'f' && s[3] == 'f')
	{
	  s += 4;
	  *page = 'o';
	}
    }

  input_line_pointer = s;

  expression (op);
  if (op->X_op == O_absent)
    as_bad (_("missing operand"));
  new = input_line_pointer;
  input_line_pointer = save;
  return new;
}

typedef enum
  {
    exp_signed, exp_unsigned, exp_sandu
  } sign_type;

static char *skip_colonthing
  PARAMS ((sign_type, char *, h8500_operand_info *, int, int, int, int));

static char *
skip_colonthing (sign, ptr, exp, def, size8, size16, size24)
     sign_type sign;
     char *ptr;
     h8500_operand_info *exp;
     int def;
     int size8;
     int size16;
     int size24;
{
  ptr = parse_exp (ptr, &exp->exp, &exp->page);
  if (*ptr == ':')
    {
      ptr++;
      if (*ptr == '8')
	{
	  ptr++;
	  exp->type = size8;
	}
      else if (ptr[0] == '1' && ptr[1] == '6')
	{
	  ptr += 2;
	  exp->type = size16;
	}
      else if (ptr[0] == '2' && ptr[1] == '4')
	{
	  if (!size24)
	    {
	      as_bad (_(":24 not valid for this opcode"));
	    }
	  ptr += 2;
	  exp->type = size24;
	}
      else
	{
	  as_bad (_("expect :8,:16 or :24"));
	  exp->type = size16;
	}
    }
  else
    {
      if (exp->page == 'p')
	{
	  exp->type = IMM8;
	}
      else if (exp->page == 'h')
	{
	  exp->type = IMM16;
	}
      else
	{
	  /* Let's work out the size from the context */
	  int n = exp->exp.X_add_number;
	  if (size8
	      && exp->exp.X_op == O_constant
	      && ((sign == exp_signed && (n >= -128 && n <= 127))
		  || (sign == exp_unsigned && (n >= 0 && (n <= 255)))
		  || (sign == exp_sandu && (n >= -128 && (n <= 255)))))
	    {
	      exp->type = size8;
	    }
	  else
	    {
	      exp->type = def;
	    }
	}
    }
  return ptr;
}

static int parse_reglist PARAMS ((char *, h8500_operand_info *));

static int
parse_reglist (src, op)
     char *src;
     h8500_operand_info *op;
{
  int mode;
  int rn;
  int mask = 0;
  int rm;
  int idx = 1;			/* skip ( */

  while (src[idx] && src[idx] != ')')
    {
      int done = parse_reg (src + idx, &mode, &rn);

      if (done)
	{
	  idx += done;
	  mask |= 1 << rn;
	}
      else
	{
	  as_bad (_("syntax error in reg list"));
	  return 0;
	}
      if (src[idx] == '-')
	{
	  idx++;
	  done = parse_reg (src + idx, &mode, &rm);
	  if (done)
	    {
	      idx += done;
	      while (rn <= rm)
		{
		  mask |= 1 << rn;
		  rn++;
		}
	    }
	  else
	    {
	      as_bad (_("missing final register in range"));
	    }
	}
      if (src[idx] == ',')
	idx++;
    }
  idx++;
  op->exp.X_add_symbol = 0;
  op->exp.X_op_symbol = 0;
  op->exp.X_add_number = mask;
  op->exp.X_op = O_constant;
  op->exp.X_unsigned = 1;
  op->type = IMM8;
  return idx;

}

/* The many forms of operand:

   Rn			Register direct
   @@Rn			Register indirect
   @@(disp[:size], Rn)	Register indirect with displacement
   @@Rn+
   @@-Rn
   @@aa[:size]		absolute
   #xx[:size]		immediate data

   */

static void get_operand PARAMS ((char **, h8500_operand_info *, char));

static void
get_operand (ptr, op, ispage)
     char **ptr;
     h8500_operand_info *op;
     char ispage;
{
  char *src = *ptr;
  int mode;
  unsigned int num;
  unsigned int len;
  op->page = 0;
  if (src[0] == '(' && src[1] == 'r')
    {
      /* This is a register list */
      *ptr = src + parse_reglist (src, op);
      return;
    }

  len = parse_reg (src, &op->type, &op->reg);

  if (len)
    {
      *ptr = src + len;
      return;
    }

  if (*src == '@@')
    {
      src++;
      if (*src == '-')
	{
	  src++;
	  len = parse_reg (src, &mode, &num);
	  if (len == 0)
	    {
	      /* Oops, not a reg after all, must be ordinary exp */
	      src--;
	      /* must be a symbol */
	      *ptr = skip_colonthing (exp_unsigned, src,
				      op, ABS16, ABS8, ABS16, ABS24);
	      return;
	    }

	  op->type = RNDEC;
	  op->reg = num;
	  *ptr = src + len;
	  return;
	}
      if (*src == '(')
	{
	  /* Disp */
	  src++;

	  src = skip_colonthing (exp_signed, src,
				 op, RNIND_D16, RNIND_D8, RNIND_D16, 0);

	  if (*src != ',')
	    {
	      as_bad (_("expected @@(exp, Rn)"));
	      return;
	    }
	  src++;
	  len = parse_reg (src, &mode, &op->reg);
	  if (len == 0 || mode != RN)
	    {
	      as_bad (_("expected @@(exp, Rn)"));
	      return;
	    }
	  src += len;
	  if (*src != ')')
	    {
	      as_bad (_("expected @@(exp, Rn)"));
	      return;
	    }
	  *ptr = src + 1;
	  return;
	}
      len = parse_reg (src, &mode, &num);

      if (len)
	{
	  src += len;
	  if (*src == '+')
	    {
	      src++;
	      if (mode != RN)
		{
		  as_bad (_("@@Rn+ needs word register"));
		  return;
		}
	      op->type = RNINC;
	      op->reg = num;
	      *ptr = src;
	      return;
	    }
	  if (mode != RN)
	    {
	      as_bad (_("@@Rn needs word register"));
	      return;
	    }
	  op->type = RNIND;
	  op->reg = num;
	  *ptr = src;
	  return;
	}
      else
	{
	  /* must be a symbol */
	  *ptr =
	    skip_colonthing (exp_unsigned, src, op,
			     ispage ? ABS24 : ABS16, ABS8, ABS16, ABS24);
	  return;
	}
    }

  if (*src == '#')
    {
      src++;
      *ptr = skip_colonthing (exp_sandu, src, op, IMM16, IMM8, IMM16, ABS24);
      return;
    }
  else
    {
      *ptr = skip_colonthing (exp_signed, src, op,
			      ispage ? ABS24 : PCREL8, PCREL8, PCREL16, ABS24);
    }
}

static char *get_operands
  PARAMS ((h8500_opcode_info *, char *, h8500_operand_info *));

static char *
get_operands (info, args, operand)
     h8500_opcode_info *info;
     char *args;
     h8500_operand_info *operand;
{
  char *ptr = args;

  switch (info->nargs)
    {
    case 0:
      operand[0].type = 0;
      operand[1].type = 0;
      break;

    case 1:
      ptr++;
      get_operand (&ptr, operand + 0, info->name[0] == 'p');
      operand[1].type = 0;
      break;

    case 2:
      ptr++;
      get_operand (&ptr, operand + 0, 0);
      if (*ptr == ',')
	ptr++;
      get_operand (&ptr, operand + 1, 0);
      break;

    default:
      abort ();
    }

  return ptr;
}

/* Passed a pointer to a list of opcodes which use different
   addressing modes, return the opcode which matches the opcodes
   provided.  */

int pcrel8;			/* Set when we've seen a pcrel operand */

static h8500_opcode_info *get_specific
  PARAMS ((h8500_opcode_info *, h8500_operand_info *));

static h8500_opcode_info *
get_specific (opcode, operands)
     h8500_opcode_info *opcode;
     h8500_operand_info *operands;
{
  h8500_opcode_info *this_try = opcode;
  int found = 0;
  unsigned int noperands = opcode->nargs;
  int this_index = opcode->idx;

  while (this_index == opcode->idx && !found)
    {
      unsigned int i;

      this_try = opcode++;

      /* look at both operands needed by the opcodes and provided by
       the user*/
      for (i = 0; i < noperands; i++)
	{
	  h8500_operand_info *user = operands + i;

	  switch (this_try->arg_type[i])
	    {
	    case FPIND_D8:
	      /* Opcode needs (disp:8,fp) */
	      if (user->type == RNIND_D8 && user->reg == 6)
		{
		  displacement = user->exp;
		  continue;
		}
	      break;
	    case RDIND_D16:
	      if (user->type == RNIND_D16)
		{
		  displacement = user->exp;
		  rd = user->reg;
		  continue;
		}
	      break;
	    case RDIND_D8:
	      if (user->type == RNIND_D8)
		{
		  displacement = user->exp;
		  rd = user->reg;
		  continue;
		}
	      break;
	    case RNIND_D16:
	    case RNIND_D8:
	      if (user->type == this_try->arg_type[i])
		{
		  displacement = user->exp;
		  rn = user->reg;
		  continue;
		}
	      break;

	    case SPDEC:
	      if (user->type == RNDEC && user->reg == 7)
		{
		  continue;
		}
	      break;
	    case SPINC:
	      if (user->type == RNINC && user->reg == 7)
		{
		  continue;
		}
	      break;
	    case ABS16:
	      if (user->type == ABS16)
		{
		  absolute = user->exp;
		  continue;
		}
	      break;
	    case ABS8:
	      if (user->type == ABS8)
		{
		  absolute = user->exp;
		  continue;
		}
	      break;
	    case ABS24:
	      if (user->type == ABS24)
		{
		  absolute = user->exp;
		  continue;
		}
	      break;

	    case CRB:
	      if ((user->type == CRB || user->type == CR) && user->reg != 0)
		{
		  crb = user->reg;
		  continue;
		}
	      break;
	    case CRW:
	      if ((user->type == CRW || user->type == CR) && user->reg == 0)
		{
		  crw = user->reg;
		  continue;
		}
	      break;
	    case DISP16:
	      if (user->type == DISP16)
		{
		  displacement = user->exp;
		  continue;
		}
	      break;
	    case DISP8:
	      if (user->type == DISP8)
		{
		  displacement = user->exp;
		  continue;
		}
	      break;
	    case FP:
	      if (user->type == RN && user->reg == 6)
		{
		  continue;
		}
	      break;
	    case PCREL16:
	      if (user->type == PCREL16)
		{
		  displacement = user->exp;
		  continue;
		}
	      break;
	    case PCREL8:
	      if (user->type == PCREL8)
		{
		  displacement = user->exp;
		  pcrel8 = 1;
		  continue;
		}
	      break;

	    case IMM16:
	      if (user->type == IMM16
		  || user->type == IMM8)
		{
		  immediate_inpage = user->page;
		  immediate = user->exp;
		  continue;
		}
	      break;
	    case RLIST:
	    case IMM8:
	      if (user->type == IMM8)
		{
		  immediate_inpage = user->page;
		  immediate = user->exp;
		  continue;
		}
	      break;
	    case IMM4:
	      if (user->type == IMM8)
		{
		  immediate_inpage = user->page;
		  immediate = user->exp;
		  continue;
		}
	      break;
	    case QIM:
	      if (user->type == IMM8
		  && user->exp.X_op == O_constant
		  &&
		  (user->exp.X_add_number == -2
		   || user->exp.X_add_number == -1
		   || user->exp.X_add_number == 1
		   || user->exp.X_add_number == 2))
		{
		  immediate_inpage = user->page;
		  immediate = user->exp;
		  continue;
		}
	      break;
	    case RD:
	      if (user->type == RN)
		{
		  rd = user->reg;
		  continue;
		}
	      break;
	    case RS:
	      if (user->type == RN)
		{
		  rs = user->reg;
		  continue;
		}
	      break;
	    case RDIND:
	      if (user->type == RNIND)
		{
		  rd = user->reg;
		  continue;

		}
	      break;
	    case RNINC:
	    case RNIND:
	    case RNDEC:
	    case RN:

	      if (user->type == this_try->arg_type[i])
		{
		  rn = user->reg;
		  continue;
		}
	      break;
	    case SP:
	      if (user->type == RN && user->reg == 7)
		{
		  continue;
		}
	      break;
	    default:
	      printf (_("unhandled %d\n"), this_try->arg_type[i]);
	      break;
	    }

	  /* If we get here this didn't work out */
	  goto fail;
	}
      found = 1;
    fail:;

    }

  if (found)
    return this_try;
  else
    return 0;
}

static int check PARAMS ((expressionS *, int, int));

static int
check (operand, low, high)
     expressionS *operand;
     int low;
     int high;
{
  if (operand->X_op != O_constant
      || operand->X_add_number < low
      || operand->X_add_number > high)
    {
      as_bad (_("operand must be absolute in range %d..%d"), low, high);
    }
  return operand->X_add_number;
}

static void insert PARAMS ((char *, int, expressionS *, int, int));

static void
insert (output, index, exp, reloc, pcrel)
     char *output;
     int index;
     expressionS *exp;
     int reloc;
     int pcrel;
{
  fix_new_exp (frag_now,
	       output - frag_now->fr_literal + index,
	       4,	       	/* always say size is 4, but we know better */
	       exp,
	       pcrel,
	       reloc);
}

static void build_relaxable_instruction
  PARAMS ((h8500_opcode_info *, h8500_operand_info *));

static void
build_relaxable_instruction (opcode, operand)
     h8500_opcode_info *opcode;
     h8500_operand_info *operand ATTRIBUTE_UNUSED;
{
  /* All relaxable instructions start life as two bytes but can become
     three bytes long if a lonely branch and up to 9 bytes if long
     scb.  */
  char *p;
  int len;
  int type;

  if (opcode->bytes[0].contents == 0x01)
    {
      type = SCB_F;
    }
  else if (opcode->bytes[0].contents == 0x06
	   || opcode->bytes[0].contents == 0x07)
    {
      type = SCB_TST;
    }
  else
    {
      type = BRANCH;
    }

  p = frag_var (rs_machine_dependent,
		md_relax_table[C (type, WORD_DISP)].rlx_length,
		len = md_relax_table[C (type, BYTE_DISP)].rlx_length,
		C (type, UNDEF_BYTE_DISP),
		displacement.X_add_symbol,
		displacement.X_add_number,
		0);

  p[0] = opcode->bytes[0].contents;
  if (type != BRANCH)
    {
      p[1] = opcode->bytes[1].contents | rs;
    }
}

/* Now we know what sort of opcodes it is, let's build the bytes.  */

static void build_bytes PARAMS ((h8500_opcode_info *, h8500_operand_info *));

static void
build_bytes (opcode, operand)
     h8500_opcode_info *opcode;
     h8500_operand_info *operand;
{
  int index;

  if (pcrel8)
    {
      pcrel8 = 0;
      build_relaxable_instruction (opcode, operand);
    }
  else
    {
      char *output = frag_more (opcode->length);

      memset (output, 0, opcode->length);
      for (index = 0; index < opcode->length; index++)
	{
	  output[index] = opcode->bytes[index].contents;

	  switch (opcode->bytes[index].insert)
	    {
	    default:
	      printf (_("failed for %d\n"), opcode->bytes[index].insert);
	      break;
	    case 0:
	      break;
	    case RN:
	      output[index] |= rn;
	      break;
	    case RD:
	    case RDIND:
	      output[index] |= rd;
	      break;
	    case RS:
	      output[index] |= rs;
	      break;
	    case DISP16:
	      insert (output, index, &displacement, R_H8500_IMM16, 0);
	      index++;
	      break;
	    case DISP8:
	    case FPIND_D8:
	      insert (output, index, &displacement, R_H8500_IMM8, 0);
	      break;
	    case IMM16:
	      {
		int p;

		switch (immediate_inpage)
		  {
		  case 'p':
		    p = R_H8500_HIGH16;
		    break;
		  case 'h':
		    p = R_H8500_HIGH16;
		    break;
		  default:
		    p = R_H8500_IMM16;
		    break;
		  }
		insert (output, index, &immediate, p, 0);
	      }
	      index++;
	      break;
	    case RLIST:
	    case IMM8:
	      if (immediate_inpage)
		insert (output, index, &immediate, R_H8500_HIGH8, 0);
	      else
		insert (output, index, &immediate, R_H8500_IMM8, 0);
	      break;
	    case PCREL16:
	      insert (output, index, &displacement, R_H8500_PCREL16, 1);
	      index++;
	      break;
	    case PCREL8:
	      insert (output, index, &displacement, R_H8500_PCREL8, 1);
	      break;
	    case IMM4:
	      output[index] |= check (&immediate, 0, 15);
	      break;
	    case CR:
	      output[index] |= cr;
	      if (cr == 0)
		output[0] |= 0x8;
	      else
		output[0] &= ~0x8;
	      break;
	    case CRB:
	      output[index] |= crb;
	      output[0] &= ~0x8;
	      break;
	    case CRW:
	      output[index] |= crw;
	      output[0] |= 0x8;
	      break;
	    case ABS24:
	      insert (output, index, &absolute, R_H8500_IMM24, 0);
	      index += 2;
	      break;
	    case ABS16:
	      insert (output, index, &absolute, R_H8500_IMM16, 0);
	      index++;
	      break;
	    case ABS8:
	      insert (output, index, &absolute, R_H8500_IMM8, 0);
	      break;
	    case QIM:
	      switch (immediate.X_add_number)
		{
		case -2:
		  output[index] |= 0x5;
		  break;
		case -1:
		  output[index] |= 0x4;
		  break;
		case 1:
		  output[index] |= 0;
		  break;
		case 2:
		  output[index] |= 1;
		  break;
		}
	      break;
	    }
	}
    }
}

/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (str)
     char *str;
{
  char *op_start;
  char *op_end;
  h8500_operand_info operand[2];
  h8500_opcode_info *opcode;
  h8500_opcode_info *prev_opcode;
  char name[11];

  int nlen = 0;

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the op code end.  */
  for (op_start = op_end = str;
       !is_end_of_line[(unsigned char) *op_end] && *op_end != ' ';
       op_end++)
    {
      if (			/**op_end != '.'
	  && *op_end != ':'
	   	   	   	  && */ nlen < 10)
	{
	  name[nlen++] = *op_end;
	}
    }
  name[nlen] = 0;

  if (op_end == op_start)
    as_bad (_("can't find opcode "));

  opcode = (h8500_opcode_info *) hash_find (opcode_hash_control, name);

  if (opcode == NULL)
    {
      as_bad (_("unknown opcode"));
      return;
    }

  get_operands (opcode, op_end, operand);
  prev_opcode = opcode;

  opcode = get_specific (opcode, operand);

  if (opcode == 0)
    {
      /* Couldn't find an opcode which matched the operands */
      char *where = frag_more (2);

      where[0] = 0x0;
      where[1] = 0x0;
      as_bad (_("invalid operands for opcode"));
      return;
    }

  build_bytes (opcode, operand);
}

void
tc_crawl_symbol_chain (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
{
  printf (_("call to tc_crawl_symbol_chain \n"));
}

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

void
tc_headers_hook (headers)
     object_headers *headers ATTRIBUTE_UNUSED;
{
  printf (_("call to tc_headers_hook \n"));
}

/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn a string in input_line_pointer into a floating point constant
   of type type, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

const char *md_shortopts = "";
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
{
  return 0;
}

void
md_show_usage (stream)
     FILE *stream ATTRIBUTE_UNUSED;
{
}

static void wordify_scb PARAMS ((char *, int *, int *));

static void
wordify_scb (buffer, disp_size, inst_size)
     char *buffer;
     int *disp_size;
     int *inst_size;
{
  int rn = buffer[1] & 0x7;

  switch (buffer[0])
    {
    case 0x0e:			/* BSR */
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2a:
    case 0x2b:
    case 0x2c:
    case 0x2d:
    case 0x2e:
    case 0x2f:
      buffer[0] |= 0x10;
      buffer[1] = 0;
      buffer[2] = 0;
      *disp_size = 2;
      *inst_size = 1;
      return;
    default:
      abort ();

    case 0x01:
      *inst_size = 6;
      *disp_size = 2;
      break;
    case 0x06:
      *inst_size = 8;
      *disp_size = 2;

      *buffer++ = 0x26;		/* bne + 8 */
      *buffer++ = 0x08;
      break;
    case 0x07:
      *inst_size = 8;
      *disp_size = 2;
      *buffer++ = 0x27;		/* bne + 8 */
      *buffer++ = 0x08;
      break;

    }
  *buffer++ = 0xa8 | rn;	/* addq -1,rn */
  *buffer++ = 0x0c;
  *buffer++ = 0x04;		/* cmp #0xff:8, rn */
  *buffer++ = 0xff;
  *buffer++ = 0x70 | rn;
  *buffer++ = 0x36;		/* bne ...  */
  *buffer++ = 0;
  *buffer++ = 0;
}

/* Called after relaxing, change the frags so they know how big they
   are.  */

void
md_convert_frag (headers, seg, fragP)
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *fragP;
{
  int disp_size = 0;
  int inst_size = 0;
  char *buffer = fragP->fr_fix + fragP->fr_literal;

  switch (fragP->fr_subtype)
    {
    case C (BRANCH, BYTE_DISP):
      disp_size = 1;
      inst_size = 1;
      break;

    case C (SCB_F, BYTE_DISP):
    case C (SCB_TST, BYTE_DISP):
      disp_size = 1;
      inst_size = 2;
      break;

      /* Branches to a known 16 bit displacement.  */

      /* Turn on the 16bit bit.  */
    case C (BRANCH, WORD_DISP):
    case C (SCB_F, WORD_DISP):
    case C (SCB_TST, WORD_DISP):
      wordify_scb (buffer, &disp_size, &inst_size);
      break;

    case C (BRANCH, UNDEF_WORD_DISP):
    case C (SCB_F, UNDEF_WORD_DISP):
    case C (SCB_TST, UNDEF_WORD_DISP):
      /* This tried to be relaxed, but didn't manage it, it now needs
	 a fix.  */
      wordify_scb (buffer, &disp_size, &inst_size);

      /* Make a reloc */
      fix_new (fragP,
	       fragP->fr_fix + inst_size,
	       4,
	       fragP->fr_symbol,
	       fragP->fr_offset,
	       0,
	       R_H8500_PCREL16);

      fragP->fr_fix += disp_size + inst_size;
      return;
      break;
    default:
      abort ();
    }
  if (inst_size)
    {
      /* Get the address of the end of the instruction */
      int next_inst = fragP->fr_fix + fragP->fr_address + disp_size + inst_size;
      int targ_addr = (S_GET_VALUE (fragP->fr_symbol) +
		       fragP->fr_offset);
      int disp = targ_addr - next_inst;

      md_number_to_chars (buffer + inst_size, disp, disp_size);
      fragP->fr_fix += disp_size + inst_size;
    }
}

valueT
md_section_align (seg, size)
     segT seg ;
     valueT size;
{
  return ((size + (1 << section_alignment[(int) seg]) - 1)
	  & (-1 << section_alignment[(int) seg]));

}

void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
{
  long val = * (long *) valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;

  if (fixP->fx_r_type == 0)
    fixP->fx_r_type = fixP->fx_size == 4 ? R_H8500_IMM32 : R_H8500_IMM16;

  switch (fixP->fx_r_type)
    {
    case R_H8500_IMM8:
    case R_H8500_PCREL8:
      *buf++ = val;
      break;
    case R_H8500_IMM16:
    case R_H8500_LOW16:
    case R_H8500_PCREL16:
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    case R_H8500_HIGH8:
      *buf++ = val >> 16;
      break;
    case R_H8500_HIGH16:
      *buf++ = val >> 24;
      *buf++ = val >> 16;
      break;
    case R_H8500_IMM24:
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    case R_H8500_IMM32:
      *buf++ = (val >> 24);
      *buf++ = (val >> 16);
      *buf++ = (val >> 8);
      *buf++ = val;
      break;
    default:
      abort ();
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Called just before address relaxation, return the length
   by which a fragment must grow to reach it's destination.  */

int
md_estimate_size_before_relax (fragP, segment_type)
     register fragS *fragP;
     register segT segment_type;
{
  int what;

  switch (fragP->fr_subtype)
    {
    default:
      abort ();

    case C (BRANCH, UNDEF_BYTE_DISP):
    case C (SCB_F, UNDEF_BYTE_DISP):
    case C (SCB_TST, UNDEF_BYTE_DISP):
      what = GET_WHAT (fragP->fr_subtype);
      /* used to be a branch to somewhere which was unknown */
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type)
	{
	  /* Got a symbol and it's defined in this segment, become byte
	     sized - maybe it will fix up.  */
	  fragP->fr_subtype = C (what, BYTE_DISP);
	}
      else
	{
	  /* Its got a segment, but its not ours, so it will always be
             long.  */
	  fragP->fr_subtype = C (what, UNDEF_WORD_DISP);
	}
      break;

    case C (BRANCH, BYTE_DISP):
    case C (BRANCH, WORD_DISP):
    case C (BRANCH, UNDEF_WORD_DISP):
    case C (SCB_F, BYTE_DISP):
    case C (SCB_F, WORD_DISP):
    case C (SCB_F, UNDEF_WORD_DISP):
    case C (SCB_TST, BYTE_DISP):
    case C (SCB_TST, WORD_DISP):
    case C (SCB_TST, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
    }

  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* Put number into target byte order.  */

void
md_number_to_chars (ptr, use, nbytes)
     char *ptr;
     valueT use;
     int nbytes;
{
  number_to_chars_bigendian (ptr, use, nbytes);
}

long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

void
tc_coff_symbol_emit_hook (ignore)
     symbolS *ignore ATTRIBUTE_UNUSED;
{
}

short
tc_coff_fix2rtype (fix_ptr)
     fixS *fix_ptr;
{
  if (fix_ptr->fx_r_type == RELOC_32)
    {
      /* cons likes to create reloc32's whatever the size of the reloc..
     */
      switch (fix_ptr->fx_size)
	{
	case 2:
	  return R_H8500_IMM16;
	  break;
	case 1:
	  return R_H8500_IMM8;
	  break;
	default:
	  abort ();
	}
    }
  return fix_ptr->fx_r_type;
}

void
tc_reloc_mangle (fix_ptr, intr, base)
     fixS *fix_ptr;
     struct internal_reloc *intr;
     bfd_vma base;

{
  symbolS *symbol_ptr;

  symbol_ptr = fix_ptr->fx_addsy;

  /* If this relocation is attached to a symbol then it's ok
     to output it */
  if (fix_ptr->fx_r_type == RELOC_32)
    {
      /* cons likes to create reloc32's whatever the size of the reloc..
       */
      switch (fix_ptr->fx_size)
	{
	case 2:
	  intr->r_type = R_IMM16;
	  break;
	case 1:
	  intr->r_type = R_IMM8;
	  break;
	default:
	  abort ();
	}
    }
  else
    {
      intr->r_type = fix_ptr->fx_r_type;
    }

  intr->r_vaddr = fix_ptr->fx_frag->fr_address + fix_ptr->fx_where + base;
  intr->r_offset = fix_ptr->fx_offset;

  /* Turn the segment of the symbol into an offset.  */
  if (symbol_ptr)
    {
      symbolS *dot;

      dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
      if (dot)
	{
#if 0
	  intr->r_offset -=
	    segment_info[S_GET_SEGMENT (symbol_ptr)].scnhdr.s_paddr;
#endif
	  intr->r_offset += S_GET_VALUE (symbol_ptr);
	  intr->r_symndx = dot->sy_number;
	}
      else
	{
	  intr->r_symndx = symbol_ptr->sy_number;
	}

    }
  else
    {
      intr->r_symndx = -1;
    }

}

int
start_label (ptr)
     char *ptr;
{
  /* Check for :s.w */
  if (ISALPHA (ptr[1]) && ptr[2] == '.')
    return 0;
  /* Check for :s */
  if (ISALPHA (ptr[1]) && !ISALPHA (ptr[2]))
    return 0;
  return 1;
}

int
tc_coff_sizemachdep (frag)
     fragS *frag;
{
  return md_relax_table[frag->fr_subtype].rlx_length;
}
@


1.3
log
@resolve conflicts.
@
text
@d1 2
a2 2
/* tc-h8500.c -- Assemble code for the Hitachi H8/500
   Copyright 1993, 1994, 1995, 1998, 2000, 2001
d31 1
a31 1
#include <ctype.h>
a43 2
void cons ();

d123 1
a123 1
  h8500_opcode_info *opcode;
a148 1
static int displacement_size;	/* and size if given */
a151 1
static int immediate_size;	/* and size if given */
a153 1
static int absolute_size;	/* and size if given */
d167 2
d246 2
d294 3
d316 1
a316 1
      else if (ptr[0] == '1' & ptr[1] == '6')
d321 1
a321 1
      else if (ptr[0] == '2' & ptr[1] == '4')
d367 2
d438 2
d568 3
a575 1

d613 3
d624 1
a624 2

  unsigned int this_index = opcode->idx;
d856 3
a858 1
int
d873 2
d891 4
a894 1
void
d897 1
a897 1
     h8500_operand_info *operand;
d937 2
a942 1

d1137 1
a1137 1
     object_headers *headers;
d1144 1
a1144 1
     char *name;
d1151 1
a1151 1
     object_headers *headers;
a1174 1
  char *atof_ieee ();
d1219 1
a1219 1
CONST char *md_shortopts = "";
d1227 2
a1228 2
     int c;
     char *arg;
d1235 1
a1235 1
     FILE *stream;
d1239 1
a1239 6
void
tc_aout_fix_to_chars ()
{
  printf (_("call to tc_aout_fix_to_chars \n"));
  abort ();
}
d1311 2
a1312 2
     object_headers *headers;
     segT seg;
d1387 1
a1387 1
md_apply_fix (fixP, val)
d1389 2
a1390 1
     long val;
d1392 1
d1396 1
a1396 3
    {
      fixP->fx_r_type = fixP->fx_size == 4 ? R_H8500_IMM32 : R_H8500_IMM16;
    }
a1399 1

d1430 1
d1432 2
a1433 1
    }
d1436 3
a1438 4
/*
called just before address relaxation, return the length
by which a fragment must grow to reach it's destination
*/
d1507 1
a1507 1
     symbolS *ignore;
d1604 1
a1604 1
  if (isalpha (ptr[1]) && ptr[2] == '.')
d1607 1
a1607 1
  if (isalpha (ptr[1]) && !isalpha (ptr[2]))
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 1998 Free Software Foundation.
d22 1
a22 4
/*
  Written By Steve Chamberlain
  sac@@cygnus.com
  */
d89 25
a113 1
relax_typeS md_relax_table[C (END, 0)];
d119 1
a119 1
  set up all the tables, etc that the MD part of the assembler needs
a127 1
  register relax_typeS *table;
a140 34

  /* Initialize the relax table.  We use a local variable to avoid
     warnings about modifying a supposedly const data structure.  */
  table = (relax_typeS *) md_relax_table;
  table[C (BRANCH, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (BRANCH, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (BRANCH, BYTE_DISP)].rlx_length = 2;
  table[C (BRANCH, BYTE_DISP)].rlx_more = C (BRANCH, WORD_DISP);

  table[C (BRANCH, WORD_DISP)].rlx_forward = WORD_F;
  table[C (BRANCH, WORD_DISP)].rlx_backward = WORD_B;
  table[C (BRANCH, WORD_DISP)].rlx_length = 3;
  table[C (BRANCH, WORD_DISP)].rlx_more = 0;

  table[C (SCB_F, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (SCB_F, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (SCB_F, BYTE_DISP)].rlx_length = 3;
  table[C (SCB_F, BYTE_DISP)].rlx_more = C (SCB_F, WORD_DISP);

  table[C (SCB_F, WORD_DISP)].rlx_forward = WORD_F;
  table[C (SCB_F, WORD_DISP)].rlx_backward = WORD_B;
  table[C (SCB_F, WORD_DISP)].rlx_length = 8;
  table[C (SCB_F, WORD_DISP)].rlx_more = 0;

  table[C (SCB_TST, BYTE_DISP)].rlx_forward = BYTE_F;
  table[C (SCB_TST, BYTE_DISP)].rlx_backward = BYTE_B;
  table[C (SCB_TST, BYTE_DISP)].rlx_length = 3;
  table[C (SCB_TST, BYTE_DISP)].rlx_more = C (SCB_TST, WORD_DISP);

  table[C (SCB_TST, WORD_DISP)].rlx_forward = WORD_F;
  table[C (SCB_TST, WORD_DISP)].rlx_backward = WORD_B;
  table[C (SCB_TST, WORD_DISP)].rlx_length = 10;
  table[C (SCB_TST, WORD_DISP)].rlx_more = 0;

d170 2
a171 1
/* try and parse a reg name, returns number of chars consumed */
d184 1
a184 1
  end = src+1;
d249 1
a249 2
static
char *
a294 1

d487 1
a487 1
	  src = skip_colonthing (exp_signed, src, 
d562 1
a562 2
static
char *
d601 1
a601 2
   provided
   */
d605 1
a605 2
static
h8500_opcode_info *
d861 1
a861 2
static
void
d883 2
a884 2
     three bytes long if a lonely branch and up to 9 bytes if long scb
     */
d918 2
a919 2
/* Now we know what sort of opcodes it is, lets build the bytes -
 */
a953 1
	      
a966 1

d970 14
a983 13
		switch (immediate_inpage) {
		case 'p':
		  p = R_H8500_HIGH16;
		  break;
		case 'h':		
		  p = R_H8500_HIGH16;
		  break;
		default:
		  p = R_H8500_IMM16;
		  break;
		}
		
		insert (output, index, &immediate,p, 0);
a984 1
		
d990 1
a990 3
		{
		  insert (output, index, &immediate, R_H8500_HIGH8, 0);
		}
d992 1
a992 3
		{
		  insert (output, index, &immediate, R_H8500_IMM8, 0);
		}
a1004 1

d1007 1
a1007 3
		{
		  output[0] |= 0x8;
		}
d1009 1
a1009 4
		{
		  output[0] &= ~0x8;
		}

a1010 1

d1052 3
a1054 4
/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This funciton is supposed to emit
   the frags/bytes it assembles to.
   */
d1057 2
a1058 2
DEFUN (md_assemble, (str),
       char *str)
d1069 1
a1069 1
  /* Drop leading whitespace */
d1073 1
a1073 1
  /* find the op code end */
d1075 1
a1075 2
       *op_end &&
       !is_end_of_line[*op_end] && *op_end != ' ';
d1088 1
a1088 3
    {
      as_bad (_("can't find opcode "));
    }
a1114 1

d1118 2
a1119 2
DEFUN (tc_crawl_symbol_chain, (headers),
       object_headers * headers)
d1125 2
a1126 2
DEFUN (md_undefined_symbol, (name),
       char *name)
d1132 2
a1133 2
DEFUN (tc_headers_hook, (headers),
       object_headers * headers)
d1138 2
a1139 2
/* Various routines to kill one day */
/* Equal to MAX_PRECISION in atof-ieee.c */
d1142 5
a1146 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
   */
d1206 1
a1206 1
size_t md_longopts_size = sizeof(md_longopts);
d1229 1
a1229 2
static
void
d1289 1
a1289 1
  *buffer++ = 0x36;		/* bne ... */
d1294 3
a1296 3
/*
called after relaxing, change the frags so they know how big they are
*/
d1320 1
a1320 1
      /* Branches to a known 16 bit displacement */
d1322 1
a1322 1
      /* Turn on the 16bit bit */
d1332 2
a1333 2
      /* This tried to be relaxed, but didn't manage it, it now needs a
	 fix */
a1345 1
      fragP->fr_var = 0;
a1360 1
      fragP->fr_var = 0;
d1369 1
a1369 1
  return ((size + (1 << section_alignment[(int) seg]) - 1) 
d1432 1
a1432 1
  int what = GET_WHAT (fragP->fr_subtype);
d1438 1
d1442 1
d1447 1
a1447 1
	 sized - maybe it will fix up */
a1448 1
	  fragP->fr_var = md_relax_table[C (what, BYTE_DISP)].rlx_length;
d1452 2
a1453 1
	  /* Its got a segment, but its not ours, so it will always be long */
a1454 2
	  fragP->fr_var = md_relax_table[C (what, WORD_DISP)].rlx_length;
	  return md_relax_table[C (what, WORD_DISP)].rlx_length;
d1456 14
d1471 2
a1472 1
  return fragP->fr_var;
d1475 1
a1475 1
/* Put number into target byte order */
a1492 1
/*ARGSUSED*/
d1567 4
a1570 2
	  /*	  intr->r_offset -=
	    segment_info[S_GET_SEGMENT(symbol_ptr)].scnhdr.s_paddr;*/
a1586 2


a1599 1

a1605 3

/* end of tc-h8500.c */

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1993 Free Software Foundation.
d17 3
a19 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d190 12
a201 1
  if (src[0] == 'r')
d207 1
a207 1
	  return 2;
d210 1
a210 2

  if (src[0] == 's' && src[1] == 'p')
d214 1
a214 1
      return 2;
d216 1
a216 1
  if (src[0] == 'c' && src[1] == 'c' && src[2] == 'r')
d220 1
a220 1
      return 3;
d222 1
a222 1
  if (src[0] == 's' && src[1] == 'r')
d226 1
a226 1
      return 2;
d228 1
a228 2

  if (src[0] == 'b' && src[1] == 'r')
d232 1
a232 1
      return 2;
d234 1
a234 2

  if (src[0] == 'e' && src[1] == 'p')
d238 1
a238 1
      return 2;
d240 1
a240 2

  if (src[0] == 'd' && src[1] == 'p')
d244 1
a244 1
      return 2;
d246 1
a246 2

  if (src[0] == 't' && src[1] == 'p')
d250 1
a250 1
      return 2;
d252 1
a252 2

  if (src[0] == 'f' && src[1] == 'p')
d256 1
a256 1
      return 2;
d297 1
a297 1
    as_bad ("missing operand");
d337 1
a337 1
	      as_bad (":24 not valid for this opcode");
d344 1
a344 1
	  as_bad ("expect :8,:16 or :24");
d401 1
a401 1
	  as_bad ("syntax error in reg list");
d419 1
a419 1
	      as_bad ("missing final register in range");
d506 1
a506 1
	      as_bad ("expected @@(exp, Rn)");
d513 1
a513 1
	      as_bad ("expected @@(exp, Rn)");
d519 1
a519 1
	      as_bad ("expected @@(exp, Rn)");
d535 1
a535 1
		  as_bad ("@@Rn+ needs word register");
d545 1
a545 1
	      as_bad ("@@Rn needs word register");
d845 1
a845 1
	      printf ("unhandled %d\n", this_try->arg_type[i]);
d873 1
a873 1
      as_bad ("operand must be absolute in range %d..%d", low, high);
d963 1
a963 1
	      printf ("failed for %d\n", opcode->bytes[index].insert);
d1122 1
a1122 1
      as_bad ("can't find opcode ");
d1129 1
a1129 1
      as_bad ("unknown opcode");
d1145 1
a1145 1
      as_bad ("invalid operands for opcode");
d1157 1
a1157 1
  printf ("call to tc_crawl_symbol_chain \n");
d1171 1
a1171 1
  printf ("call to tc_headers_hook \n");
d1222 1
a1222 1
      return "Bad call to MD_ATOF()";
a1256 2
int md_short_jump_size;

d1260 1
a1260 1
  printf ("call to tc_aout_fix_to_chars \n");
a1263 21
void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr;
     addressT to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("failed sanity check.");
}

a1459 2

int md_long_jump_size;
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 1998 Free Software Foundation.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d189 1
a189 12
  char *end;
  int len;

  /* Cribbed from get_symbol_end().  */
  if (!is_name_beginner (*src) || *src == '\001')
    return 0;
  end = src+1;
  while (is_part_of_name (*end) || *end == '\001')
    end++;
  len = end - src;

  if (len == 2 && src[0] == 'r')
d195 1
a195 1
	  return len;
d198 2
a199 1
  if (len == 2 && src[0] == 's' && src[1] == 'p')
d203 1
a203 1
      return len;
d205 1
a205 1
  if (len == 3 && src[0] == 'c' && src[1] == 'c' && src[2] == 'r')
d209 1
a209 1
      return len;
d211 1
a211 1
  if (len == 2 && src[0] == 's' && src[1] == 'r')
d215 1
a215 1
      return len;
d217 2
a218 1
  if (len == 2 && src[0] == 'b' && src[1] == 'r')
d222 1
a222 1
      return len;
d224 2
a225 1
  if (len == 2 && src[0] == 'e' && src[1] == 'p')
d229 1
a229 1
      return len;
d231 2
a232 1
  if (len == 2 && src[0] == 'd' && src[1] == 'p')
d236 1
a236 1
      return len;
d238 2
a239 1
  if (len == 2 && src[0] == 't' && src[1] == 'p')
d243 1
a243 1
      return len;
d245 2
a246 1
  if (len == 2 && src[0] == 'f' && src[1] == 'p')
d250 1
a250 1
      return len;
d291 1
a291 1
    as_bad (_("missing operand"));
d331 1
a331 1
	      as_bad (_(":24 not valid for this opcode"));
d338 1
a338 1
	  as_bad (_("expect :8,:16 or :24"));
d395 1
a395 1
	  as_bad (_("syntax error in reg list"));
d413 1
a413 1
	      as_bad (_("missing final register in range"));
d500 1
a500 1
	      as_bad (_("expected @@(exp, Rn)"));
d507 1
a507 1
	      as_bad (_("expected @@(exp, Rn)"));
d513 1
a513 1
	      as_bad (_("expected @@(exp, Rn)"));
d529 1
a529 1
		  as_bad (_("@@Rn+ needs word register"));
d539 1
a539 1
	      as_bad (_("@@Rn needs word register"));
d839 1
a839 1
	      printf (_("unhandled %d\n"), this_try->arg_type[i]);
d867 1
a867 1
      as_bad (_("operand must be absolute in range %d..%d"), low, high);
d957 1
a957 1
	      printf (_("failed for %d\n"), opcode->bytes[index].insert);
d1116 1
a1116 1
      as_bad (_("can't find opcode "));
d1123 1
a1123 1
      as_bad (_("unknown opcode"));
d1139 1
a1139 1
      as_bad (_("invalid operands for opcode"));
d1151 1
a1151 1
  printf (_("call to tc_crawl_symbol_chain \n"));
d1165 1
a1165 1
  printf (_("call to tc_headers_hook \n"));
d1216 1
a1216 1
      return _("Bad call to MD_ATOF()");
d1251 2
d1256 1
a1256 1
  printf (_("call to tc_aout_fix_to_chars \n"));
d1260 21
d1477 2
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1998, 2000, 2001
   Free Software Foundation, Inc.
d21 4
a24 1
/* Written By Steve Chamberlain <sac@@cygnus.com>.  */
d91 1
a91 25
relax_typeS md_relax_table[C (END, 0)] = {
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },
  { 0, 0, 0, 0 },

  /* BRANCH */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  2, C (BRANCH, WORD_DISP) },
  { WORD_F, WORD_B,  3, 0 },
  { 0,      0,       3, 0 },

  /* SCB_F */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  3, C (SCB_F, WORD_DISP) },
  { WORD_F, WORD_B,  8, 0 },
  { 0,      0,       8, 0 },

  /* SCB_TST */
  { 0,      0,       0, 0 },
  { BYTE_F, BYTE_B,  3, C (SCB_TST, WORD_DISP) },
  { WORD_F, WORD_B, 10, 0 },
  { 0,      0,      10, 0 }

};
d97 1
a97 1
  set up all the tables, etc. that the MD part of the assembler needs
d106 1
d120 34
d183 1
a183 2
/* Try to parse a reg name.  Return the number of chars consumed.  */

d196 1
a196 1
  end = src + 1;
d261 2
a262 1
static char *
d308 1
d501 1
a501 1
	  src = skip_colonthing (exp_signed, src,
d576 2
a577 1
static char *
d616 2
a617 1
   provided.  */
d621 2
a622 1
static h8500_opcode_info *
d878 2
a879 1
static void
d901 2
a902 2
     three bytes long if a lonely branch and up to 9 bytes if long
     scb.  */
d936 2
a937 2
/* Now we know what sort of opcodes it is, let's build the bytes.  */

d972 1
d986 1
d990 13
a1002 14

		switch (immediate_inpage)
		  {
		  case 'p':
		    p = R_H8500_HIGH16;
		    break;
		  case 'h':
		    p = R_H8500_HIGH16;
		    break;
		  default:
		    p = R_H8500_IMM16;
		    break;
		  }
		insert (output, index, &immediate, p, 0);
d1004 1
d1010 3
a1012 1
		insert (output, index, &immediate, R_H8500_HIGH8, 0);
d1014 3
a1016 1
		insert (output, index, &immediate, R_H8500_IMM8, 0);
d1029 1
d1032 3
a1034 1
		output[0] |= 0x8;
d1036 4
a1039 1
		output[0] &= ~0x8;
d1041 1
d1083 4
a1086 3
/* This is the guts of the machine-dependent assembler.  STR points to
   a machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */
d1089 2
a1090 2
md_assemble (str)
     char *str;
d1101 1
a1101 1
  /* Drop leading whitespace.  */
d1105 1
a1105 1
  /* Find the op code end.  */
d1107 2
a1108 1
       !is_end_of_line[(unsigned char) *op_end] && *op_end != ' ';
d1121 3
a1123 1
    as_bad (_("can't find opcode "));
d1150 1
d1154 2
a1155 2
tc_crawl_symbol_chain (headers)
     object_headers *headers;
d1161 2
a1162 2
md_undefined_symbol (name)
     char *name;
d1168 2
a1169 2
tc_headers_hook (headers)
     object_headers *headers;
d1174 2
a1175 2
/* Various routines to kill one day.  */
/* Equal to MAX_PRECISION in atof-ieee.c.  */
d1178 4
a1181 5
/* Turn a string in input_line_pointer into a floating point constant
   of type type, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d1241 1
a1241 1
size_t md_longopts_size = sizeof (md_longopts);
d1264 2
a1265 1
static void
d1325 1
a1325 1
  *buffer++ = 0x36;		/* bne ...  */
d1330 3
a1332 3
/* Called after relaxing, change the frags so they know how big they
   are.  */

d1356 1
a1356 1
      /* Branches to a known 16 bit displacement.  */
d1358 1
a1358 1
      /* Turn on the 16bit bit.  */
d1368 2
a1369 2
      /* This tried to be relaxed, but didn't manage it, it now needs
	 a fix.  */
d1382 1
d1398 1
d1407 1
a1407 1
  return ((size + (1 << section_alignment[(int) seg]) - 1)
d1470 1
a1470 1
  int what;
a1475 1

a1478 1
      what = GET_WHAT (fragP->fr_subtype);
d1483 1
a1483 1
	     sized - maybe it will fix up.  */
d1485 1
d1489 1
a1489 2
	  /* Its got a segment, but its not ours, so it will always be
             long.  */
d1491 2
a1493 14
      break;

    case C (BRANCH, BYTE_DISP):
    case C (BRANCH, WORD_DISP):
    case C (BRANCH, UNDEF_WORD_DISP):
    case C (SCB_F, BYTE_DISP):
    case C (SCB_F, WORD_DISP):
    case C (SCB_F, UNDEF_WORD_DISP):
    case C (SCB_TST, BYTE_DISP):
    case C (SCB_TST, WORD_DISP):
    case C (SCB_TST, UNDEF_WORD_DISP):
      /* When relaxing a section for the second time, we don't need to
	 do anything besides return the current size.  */
      break;
d1495 1
a1495 2

  return md_relax_table[fragP->fr_subtype].rlx_length;
d1498 1
a1498 1
/* Put number into target byte order.  */
d1516 1
d1591 2
a1592 4
#if 0
	  intr->r_offset -=
	    segment_info[S_GET_SEGMENT (symbol_ptr)].scnhdr.s_paddr;
#endif
d1609 2
d1624 1
d1631 3
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d1 2
a2 2
/* tc-h8500.c -- Assemble code for the Renesas H8/500
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003
d31 1
a31 1
#include "safe-ctype.h"
d44 2
d125 1
a125 1
  const h8500_opcode_info *opcode;
d151 1
d155 1
d158 1
a171 2
static int parse_reg PARAMS ((char *, int *, int *));

a248 2
static char *parse_exp PARAMS ((char *, expressionS *, int *));

a294 3
static char *skip_colonthing
  PARAMS ((sign_type, char *, h8500_operand_info *, int, int, int, int));

d314 1
a314 1
      else if (ptr[0] == '1' && ptr[1] == '6')
d319 1
a319 1
      else if (ptr[0] == '2' && ptr[1] == '4')
a364 2
static int parse_reglist PARAMS ((char *, h8500_operand_info *));

a433 2
static void get_operand PARAMS ((char **, h8500_operand_info *, char));

a561 3
static char *get_operands
  PARAMS ((h8500_opcode_info *, char *, h8500_operand_info *));

d567 1
a604 3
static h8500_opcode_info *get_specific
  PARAMS ((h8500_opcode_info *, h8500_operand_info *));

d613 2
a614 1
  int this_index = opcode->idx;
d846 1
a846 3
static int check PARAMS ((expressionS *, int, int));

static int
a860 2
static void insert PARAMS ((char *, int, expressionS *, int, int));

d877 1
a877 4
static void build_relaxable_instruction
  PARAMS ((h8500_opcode_info *, h8500_operand_info *));

static void
d880 1
a880 1
     h8500_operand_info *operand ATTRIBUTE_UNUSED;
a919 2
static void build_bytes PARAMS ((h8500_opcode_info *, h8500_operand_info *));

d924 1
d1119 1
a1119 1
     object_headers *headers ATTRIBUTE_UNUSED;
d1126 1
a1126 1
     char *name ATTRIBUTE_UNUSED;
d1133 1
a1133 1
     object_headers *headers ATTRIBUTE_UNUSED;
d1157 1
d1202 1
a1202 1
const char *md_shortopts = "";
d1210 2
a1211 2
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d1218 1
a1218 1
     FILE *stream ATTRIBUTE_UNUSED;
d1222 6
a1227 1
static void wordify_scb PARAMS ((char *, int *, int *));
d1299 2
a1300 2
     object_headers *headers ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
d1375 1
a1375 1
md_apply_fix3 (fixP, valP, seg)
d1377 1
a1377 2
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
a1378 1
  long val = * (long *) valP;
d1382 3
a1384 1
    fixP->fx_r_type = fixP->fx_size == 4 ? R_H8500_IMM32 : R_H8500_IMM16;
d1388 1
d1419 1
a1420 3

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
d1423 4
a1426 3
/* Called just before address relaxation, return the length
   by which a fragment must grow to reach it's destination.  */

d1495 1
a1495 1
     symbolS *ignore ATTRIBUTE_UNUSED;
d1592 1
a1592 1
  if (ISALPHA (ptr[1]) && ptr[2] == '.')
d1595 1
a1595 1
  if (ISALPHA (ptr[1]) && !ISALPHA (ptr[2]))
@


