head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.54
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.52
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.29;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.31;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.36;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.52;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.06.07;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.11;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.11;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.45.03;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.23.18;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.46.29;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.36.40;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.33;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* ns32k.c  -- Assemble on the National Semiconductor 32k series
   Copyright 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/*#define SHOW_NUM 1*//* Uncomment for debugging.  */

#include <stdio.h>

#include "as.h"
#include "opcode/ns32k.h"

#include "obstack.h"

/* Macros.  */
#define IIF_ENTRIES 13		/* Number of entries in iif.  */
#define PRIVATE_SIZE 256	/* Size of my garbage memory.  */
#define MAX_ARGS 4
#define DEFAULT	-1		/* addr_mode returns this value when
                                   plain constant or label is
                                   encountered.  */

#define IIF(ptr,a1,c1,e1,g1,i1,k1,m1,o1,q1,s1,u1)	\
    iif.iifP[ptr].type= a1;				\
    iif.iifP[ptr].size= c1;				\
    iif.iifP[ptr].object= e1;				\
    iif.iifP[ptr].object_adjust= g1;			\
    iif.iifP[ptr].pcrel= i1;				\
    iif.iifP[ptr].pcrel_adjust= k1;			\
    iif.iifP[ptr].im_disp= m1;				\
    iif.iifP[ptr].relax_substate= o1;			\
    iif.iifP[ptr].bit_fixP= q1;				\
    iif.iifP[ptr].addr_mode= s1;			\
    iif.iifP[ptr].bsr= u1;

#ifdef SEQUENT_COMPATABILITY
#define LINE_COMMENT_CHARS "|"
#define ABSOLUTE_PREFIX '@@'
#define IMMEDIATE_PREFIX '#'
#endif

#ifndef LINE_COMMENT_CHARS
#define LINE_COMMENT_CHARS "#"
#endif

const char comment_chars[] = "#";
const char line_comment_chars[] = LINE_COMMENT_CHARS;
const char line_separator_chars[] = ";";
static int default_disp_size = 4; /* Displacement size for external refs.  */

#if !defined(ABSOLUTE_PREFIX) && !defined(IMMEDIATE_PREFIX)
#define ABSOLUTE_PREFIX '@@'	/* One or the other MUST be defined.  */
#endif

struct addr_mode
  {
    signed char mode;		/* Addressing mode of operand (0-31).  */
    signed char scaled_mode;	/* Mode combined with scaled mode.  */
    char scaled_reg;		/* Register used in scaled+1 (1-8).  */
    char float_flag;		/* Set if R0..R7 was F0..F7 ie a
				   floating-point-register.  */
    char am_size;		/* Estimated max size of general addr-mode
				   parts.  */
    char im_disp;		/* If im_disp==1 we have a displacement.  */
    char pcrel;			/* 1 if pcrel, this is really redundant info.  */
    char disp_suffix[2];	/* Length of displacement(s), 0=undefined.  */
    char *disp[2];		/* Pointer(s) at displacement(s)
				   or immediates(s)     (ascii).  */
    char index_byte;		/* Index byte.  */
  };
typedef struct addr_mode addr_modeS;

char *freeptr, *freeptr_static;	/* Points at some number of free bytes.  */
struct hash_control *inst_hash_handle;

struct ns32k_opcode *desc;	/* Pointer at description of instruction.  */
addr_modeS addr_modeP;
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "fd";	/* We don't want to support lowercase,
                                   do we?  */

/* UPPERCASE denotes live names when an instruction is built, IIF is
   used as an intermediate form to store the actual parts of the
   instruction. A ns32k machine instruction can be divided into a
   couple of sub PARTs. When an instruction is assembled the
   appropriate PART get an assignment. When an IIF has been completed
   it is converted to a FRAGment as specified in AS.H.  */

/* Internal structs.  */
struct ns32k_option
{
  char *pattern;
  unsigned long or;
  unsigned long and;
};

typedef struct
  {
    int type;			/* How to interpret object.  */
    int size;			/* Estimated max size of object.  */
    unsigned long object;	/* Binary data.  */
    int object_adjust;		/* Number added to object.  */
    int pcrel;			/* True if object is pcrel.  */
    int pcrel_adjust;		/* Length in bytes from the instruction
				   start to the	displacement.  */
    int im_disp;		/* True if the object is a displacement.  */
    relax_substateT relax_substate;	/* Initial relaxsubstate.  */
    bit_fixS *bit_fixP;		/* Pointer at bit_fix struct.  */
    int addr_mode;		/* What addrmode do we associate with this
				   iif-entry.  */
    char bsr;			/* Sequent hack.  */
  } iif_entryT;			/* Internal Instruction Format.  */

struct int_ins_form
  {
    int instr_size;		/* Max size of instruction in bytes.  */
    iif_entryT iifP[IIF_ENTRIES + 1];
  };

struct int_ins_form iif;
expressionS exprP;
char *input_line_pointer;

/* Description of the PARTs in IIF
  object[n]:
   0	total length in bytes of entries in iif
   1	opcode
   2	index_byte_a
   3	index_byte_b
   4	disp_a_1
   5	disp_a_2
   6	disp_b_1
   7	disp_b_2
   8	imm_a
   9	imm_b
   10	implied1
   11	implied2

   For every entry there is a datalength in bytes. This is stored in size[n].
  	 0,	the objectlength is not explicitly given by the instruction
  		and the operand is undefined. This is a case for relaxation.
  		Reserve 4 bytes for the final object.

  	 1,	the entry contains one byte
  	 2,	the entry contains two bytes
  	 3,	the entry contains three bytes
  	 4,	the entry contains four bytes
  	etc

   Furthermore, every entry has a data type identifier in type[n].

   	 0,	the entry is void, ignore it.
   	 1,	the entry is a binary number.
  	 2,	the entry is a pointer at an expression.
  		Where expression may be as simple as a single '1',
  		and as complicated as  foo-bar+12,
   		foo and bar may be undefined but suffixed by :{b|w|d} to
  		control the length of the object.

  	 3,	the entry is a pointer at a bignum struct

   The low-order-byte corresponds to low physical memory.
   Obviously a FRAGment must be created for each valid disp in PART whose
   datalength is undefined (to bad) .
   The case where just the expression is undefined is less severe and is
   handled by fix. Here the number of bytes in the objectfile is known.
   With this representation we simplify the assembly and separates the
   machine dependent/independent parts in a more clean way (said OE).  */

struct ns32k_option opt1[] =		/* restore, exit.  */
{
  {"r0", 0x80, 0xff},
  {"r1", 0x40, 0xff},
  {"r2", 0x20, 0xff},
  {"r3", 0x10, 0xff},
  {"r4", 0x08, 0xff},
  {"r5", 0x04, 0xff},
  {"r6", 0x02, 0xff},
  {"r7", 0x01, 0xff},
  {0, 0x00, 0xff}
};
struct ns32k_option opt2[] =		/* save, enter.  */
{
  {"r0", 0x01, 0xff},
  {"r1", 0x02, 0xff},
  {"r2", 0x04, 0xff},
  {"r3", 0x08, 0xff},
  {"r4", 0x10, 0xff},
  {"r5", 0x20, 0xff},
  {"r6", 0x40, 0xff},
  {"r7", 0x80, 0xff},
  {0, 0x00, 0xff}
};
struct ns32k_option opt3[] =		/* setcfg.  */
{
  {"c", 0x8, 0xff},
  {"m", 0x4, 0xff},
  {"f", 0x2, 0xff},
  {"i", 0x1, 0xff},
  {0, 0x0, 0xff}
};
struct ns32k_option opt4[] =		/* cinv.  */
{
  {"a", 0x4, 0xff},
  {"i", 0x2, 0xff},
  {"d", 0x1, 0xff},
  {0, 0x0, 0xff}
};
struct ns32k_option opt5[] =		/* String inst.  */
{
  {"b", 0x2, 0xff},
  {"u", 0xc, 0xff},
  {"w", 0x4, 0xff},
  {0, 0x0, 0xff}
};
struct ns32k_option opt6[] =		/* Plain reg ext,cvtp etc.  */
{
  {"r0", 0x00, 0xff},
  {"r1", 0x01, 0xff},
  {"r2", 0x02, 0xff},
  {"r3", 0x03, 0xff},
  {"r4", 0x04, 0xff},
  {"r5", 0x05, 0xff},
  {"r6", 0x06, 0xff},
  {"r7", 0x07, 0xff},
  {0, 0x00, 0xff}
};

#if !defined(NS32032) && !defined(NS32532)
#define NS32532
#endif

struct ns32k_option cpureg_532[] =	/* lpr spr.  */
{
  {"us", 0x0, 0xff},
  {"dcr", 0x1, 0xff},
  {"bpc", 0x2, 0xff},
  {"dsr", 0x3, 0xff},
  {"car", 0x4, 0xff},
  {"fp", 0x8, 0xff},
  {"sp", 0x9, 0xff},
  {"sb", 0xa, 0xff},
  {"usp", 0xb, 0xff},
  {"cfg", 0xc, 0xff},
  {"psr", 0xd, 0xff},
  {"intbase", 0xe, 0xff},
  {"mod", 0xf, 0xff},
  {0, 0x00, 0xff}
};
struct ns32k_option mmureg_532[] =	/* lmr smr.  */
{
  {"mcr", 0x9, 0xff},
  {"msr", 0xa, 0xff},
  {"tear", 0xb, 0xff},
  {"ptb0", 0xc, 0xff},
  {"ptb1", 0xd, 0xff},
  {"ivar0", 0xe, 0xff},
  {"ivar1", 0xf, 0xff},
  {0, 0x0, 0xff}
};

struct ns32k_option cpureg_032[] =	/* lpr spr.  */
{
  {"upsr", 0x0, 0xff},
  {"fp", 0x8, 0xff},
  {"sp", 0x9, 0xff},
  {"sb", 0xa, 0xff},
  {"psr", 0xd, 0xff},
  {"intbase", 0xe, 0xff},
  {"mod", 0xf, 0xff},
  {0, 0x0, 0xff}
};
struct ns32k_option mmureg_032[] =	/* lmr smr.  */
{
  {"bpr0", 0x0, 0xff},
  {"bpr1", 0x1, 0xff},
  {"pf0", 0x4, 0xff},
  {"pf1", 0x5, 0xff},
  {"sc", 0x8, 0xff},
  {"msr", 0xa, 0xff},
  {"bcnt", 0xb, 0xff},
  {"ptb0", 0xc, 0xff},
  {"ptb1", 0xd, 0xff},
  {"eia", 0xf, 0xff},
  {0, 0x0, 0xff}
};

#if defined(NS32532)
struct ns32k_option *cpureg = cpureg_532;
struct ns32k_option *mmureg = mmureg_532;
#else
struct ns32k_option *cpureg = cpureg_032;
struct ns32k_option *mmureg = mmureg_032;
#endif


const pseudo_typeS md_pseudo_table[] =
{					/* So far empty.  */
  {0, 0, 0}
};

#define IND(x,y)	(((x)<<2)+(y))

/* Those are index's to relax groups in md_relax_table ie it must be
   multiplied by 4 to point at a group start. Viz IND(x,y) Se function
   relax_segment in write.c for more info.  */

#define BRANCH		1
#define PCREL		2

/* Those are index's to entries in a relax group.  */

#define BYTE		0
#define WORD		1
#define DOUBLE		2
#define UNDEF           3
/* Those limits are calculated from the displacement start in memory.
   The ns32k uses the beginning of the instruction as displacement
   base.  This type of displacements could be handled here by moving
   the limit window up or down. I choose to use an internal
   displacement base-adjust as there are other routines that must
   consider this. Also, as we have two various offset-adjusts in the
   ns32k (acb versus br/brs/jsr/bcond), two set of limits would have
   had to be used.  Now we dont have to think about that.  */

const relax_typeS md_relax_table[] =
{
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  {(63), (-64), 1, IND (BRANCH, WORD)},
  {(8192), (-8192), 2, IND (BRANCH, DOUBLE)},
  {0, 0, 4, 0},
  {1, 1, 0, 0}
};

/* Array used to test if mode contains displacements.
   Value is true if mode contains displacement.  */

char disp_test[] =
{0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 0, 0, 1, 1, 0,
 1, 1, 1, 1, 1, 1, 1, 1};

/* Array used to calculate max size of displacements.  */

char disp_size[] =
{4, 1, 2, 0, 4};

static void evaluate_expr PARAMS ((expressionS * resultP, char *));
static void md_number_to_disp PARAMS ((char *, long, int));
static void md_number_to_imm PARAMS ((char *, long, int));
static void md_number_to_field PARAMS ((char *, long, bit_fixS *));

/* Parse a general operand into an addressingmode struct

   In:  pointer at operand in ascii form
        pointer at addr_mode struct for result
        the level of recursion. (always 0 or 1)

   Out: data in addr_mode struct.  */

static int addr_mode PARAMS ((char *, addr_modeS *, int));

static int
addr_mode (operand, addr_modeP, recursive_level)
     char *operand;
     addr_modeS *addr_modeP;
     int recursive_level;
{
  char *str;
  int i;
  int strl;
  int mode;
  int j;

  mode = DEFAULT;		/* Default.  */
  addr_modeP->scaled_mode = 0;	/* Why not.  */
  addr_modeP->scaled_reg = 0;	/* If 0, not scaled index.  */
  addr_modeP->float_flag = 0;
  addr_modeP->am_size = 0;
  addr_modeP->im_disp = 0;
  addr_modeP->pcrel = 0;	/* Not set in this function.  */
  addr_modeP->disp_suffix[0] = 0;
  addr_modeP->disp_suffix[1] = 0;
  addr_modeP->disp[0] = NULL;
  addr_modeP->disp[1] = NULL;
  str = operand;

  if (str[0] == 0)
    return 0;

  strl = strlen (str);

  switch (str[0])
    {
      /* The following three case statements controls the mode-chars
	 this is the place to ed if you want to change them.  */
#ifdef ABSOLUTE_PREFIX
    case ABSOLUTE_PREFIX:
      if (str[strl - 1] == ']')
	break;
      addr_modeP->mode = 21;	/* absolute */
      addr_modeP->disp[0] = str + 1;
      return -1;
#endif
#ifdef IMMEDIATE_PREFIX
    case IMMEDIATE_PREFIX:
      if (str[strl - 1] == ']')
	break;
      addr_modeP->mode = 20;	/* immediate */
      addr_modeP->disp[0] = str + 1;
      return -1;
#endif
    case '.':
      if (str[strl - 1] != ']')
	{
	  switch (str[1])
	    {
	    case '-':
	    case '+':
	      if (str[2] != '\000')
		{
		  addr_modeP->mode = 27;	/* pc-relative */
		  addr_modeP->disp[0] = str + 2;
		  return -1;
		}
	    default:
	      as_bad (_("Invalid syntax in PC-relative addressing mode"));
	      return 0;
	    }
	}
      break;
    case 'e':
      if (str[strl - 1] != ']')
	{
	  if ((!strncmp (str, "ext(", 4)) && strl > 7)
	    {				/* external */
	      addr_modeP->disp[0] = str + 4;
	      i = 0;
	      j = 2;
	      do
		{			/* disp[0]'s termination point.  */
		  j += 1;
		  if (str[j] == '(')
		    i++;
		  if (str[j] == ')')
		    i--;
		}
	      while (j < strl && i != 0);
	      if (i != 0 || !(str[j + 1] == '-' || str[j + 1] == '+'))
		{
		  as_bad (_("Invalid syntax in External addressing mode"));
		  return (0);
		}
	      str[j] = '\000';		/* null terminate disp[0] */
	      addr_modeP->disp[1] = str + j + 2;
	      addr_modeP->mode = 22;
	      return -1;
	    }
	}
      break;

    default:
      ;
    }

  strl = strlen (str);

  switch (strl)
    {
    case 2:
      switch (str[0])
	{
	case 'f':
	  addr_modeP->float_flag = 1;
	  /* Drop through.  */
	case 'r':
	  if (str[1] >= '0' && str[1] < '8')
	    {
	      addr_modeP->mode = str[1] - '0';
	      return -1;
	    }
	  break;
	default:
	  break;
	}
      /* Drop through.  */

    case 3:
      if (!strncmp (str, "tos", 3))
	{
	  addr_modeP->mode = 23;	/* TopOfStack */
	  return -1;
	}
      break;

    default:
      break;
    }

  if (strl > 4)
    {
      if (str[strl - 1] == ')')
	{
	  if (str[strl - 2] == ')')
	    {
	      if (!strncmp (&str[strl - 5], "(fp", 3))
		mode = 16;		/* Memory Relative.  */
	      else if (!strncmp (&str[strl - 5], "(sp", 3))
		mode = 17;
	      else if (!strncmp (&str[strl - 5], "(sb", 3))
		mode = 18;

	      if (mode != DEFAULT)
		{
		  /* Memory relative.  */
		  addr_modeP->mode = mode;
		  j = strl - 5;		/* Temp for end of disp[0].  */
		  i = 0;

		  do
		    {
		      strl -= 1;
		      if (str[strl] == ')')
			i++;
		      if (str[strl] == '(')
			i--;
		    }
		  while (strl > -1 && i != 0);

		  if (i != 0)
		    {
		      as_bad (_("Invalid syntax in Memory Relative addressing mode"));
		      return (0);
		    }

		  addr_modeP->disp[1] = str;
		  addr_modeP->disp[0] = str + strl + 1;
		  str[j] = '\000';	/* Null terminate disp[0] .  */
		  str[strl] = '\000';	/* Null terminate disp[1].  */

		  return -1;
		}
	    }

	  switch (str[strl - 3])
	    {
	    case 'r':
	    case 'R':
	      if (str[strl - 2] >= '0'
		  && str[strl - 2] < '8'
		  && str[strl - 4] == '(')
		{
		  addr_modeP->mode = str[strl - 2] - '0' + 8;
		  addr_modeP->disp[0] = str;
		  str[strl - 4] = 0;
		  return -1;		/* reg rel */
		}
	      /* Drop through.  */

	    default:
	      if (!strncmp (&str[strl - 4], "(fp", 3))
		mode = 24;
	      else if (!strncmp (&str[strl - 4], "(sp", 3))
		mode = 25;
	      else if (!strncmp (&str[strl - 4], "(sb", 3))
		mode = 26;
	      else if (!strncmp (&str[strl - 4], "(pc", 3))
		mode = 27;

	      if (mode != DEFAULT)
		{
		  addr_modeP->mode = mode;
		  addr_modeP->disp[0] = str;
		  str[strl - 4] = '\0';

		  return -1;		/* Memory space.  */
		}
	    }
	}

      /* No trailing ')' do we have a ']' ?  */
      if (str[strl - 1] == ']')
	{
	  switch (str[strl - 2])
	    {
	    case 'b':
	      mode = 28;
	      break;
	    case 'w':
	      mode = 29;
	      break;
	    case 'd':
	      mode = 30;
	      break;
	    case 'q':
	      mode = 31;
	      break;
	    default:
	      as_bad (_("Invalid scaled-indexed mode, use (b,w,d,q)"));

	      if (str[strl - 3] != ':' || str[strl - 6] != '['
		  || str[strl - 5] == 'r' || str[strl - 4] < '0'
		  || str[strl - 4] > '7')
		as_bad (_("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"));
	    } /* Scaled index.  */

	  if (recursive_level > 0)
	    {
	      as_bad (_("Scaled-indexed addressing mode combined with scaled-index"));
	      return 0;
	    }

	  addr_modeP->am_size += 1;	/* scaled index byte.  */
	  j = str[strl - 4] - '0';	/* store temporary.  */
	  str[strl - 6] = '\000';	/* nullterminate for recursive call.  */
	  i = addr_mode (str, addr_modeP, 1);

	  if (!i || addr_modeP->mode == 20)
	    {
	      as_bad (_("Invalid or illegal addressing mode combined with scaled-index"));
	      return 0;
	    }

	  addr_modeP->scaled_mode = addr_modeP->mode;	/* Store the inferior mode.  */
	  addr_modeP->mode = mode;
	  addr_modeP->scaled_reg = j + 1;

	  return -1;
	}
    }

  addr_modeP->mode = DEFAULT;	/* Default to whatever.  */
  addr_modeP->disp[0] = str;

  return -1;
}

/* ptr points at string addr_modeP points at struct with result This
   routine calls addr_mode to determine the general addr.mode of the
   operand. When this is ready it parses the displacements for size
   specifying suffixes and determines size of immediate mode via
   ns32k-opcode.  Also builds index bytes if needed.  */

static int get_addr_mode PARAMS ((char *, addr_modeS *));
static int
get_addr_mode (ptr, addr_modeP)
     char *ptr;
     addr_modeS *addr_modeP;
{
  int tmp;

  addr_mode (ptr, addr_modeP, 0);

  if (addr_modeP->mode == DEFAULT || addr_modeP->scaled_mode == -1)
    {
      /* Resolve ambiguous operands, this shouldn't be necessary if
	 one uses standard NSC operand syntax. But the sequent
	 compiler doesn't!!!  This finds a proper addressing mode
	 if it is implicitly stated. See ns32k-opcode.h.  */
      (void) evaluate_expr (&exprP, ptr); /* This call takes time Sigh!  */

      if (addr_modeP->mode == DEFAULT)
	{
	  if (exprP.X_add_symbol || exprP.X_op_symbol)
	    addr_modeP->mode = desc->default_model; /* We have a label.  */
	  else
	    addr_modeP->mode = desc->default_modec; /* We have a constant.  */
	}
      else
	{
	  if (exprP.X_add_symbol || exprP.X_op_symbol)
	    addr_modeP->scaled_mode = desc->default_model;
	  else
	    addr_modeP->scaled_mode = desc->default_modec;
	}

      /* Must put this mess down in addr_mode to handle the scaled
         case better.  */
    }

  /* It appears as the sequent compiler wants an absolute when we have
     a label without @@. Constants becomes immediates besides the addr
     case.  Think it does so with local labels too, not optimum, pcrel
     is better.  When I have time I will make gas check this and
     select pcrel when possible Actually that is trivial.  */
  if ((tmp = addr_modeP->scaled_reg))
    {				/* Build indexbyte.  */
      tmp--;			/* Remember regnumber comes incremented for
				   flagpurpose.  */
      tmp |= addr_modeP->scaled_mode << 3;
      addr_modeP->index_byte = (char) tmp;
      addr_modeP->am_size += 1;
    }

  assert (addr_modeP->mode >= 0); 
  if (disp_test[(unsigned int) addr_modeP->mode])
    {
      char c;
      char suffix;
      char suffix_sub;
      int i;
      char *toP;
      char *fromP;

      /* There was a displacement, probe for length  specifying suffix.  */
      addr_modeP->pcrel = 0;

      assert(addr_modeP->mode >= 0);
      if (disp_test[(unsigned int) addr_modeP->mode])
	{
	  /* There is a displacement.  */
	  if (addr_modeP->mode == 27 || addr_modeP->scaled_mode == 27)
	    /* Do we have pcrel. mode.  */
	    addr_modeP->pcrel = 1;

	  addr_modeP->im_disp = 1;

	  for (i = 0; i < 2; i++)
	    {
	      suffix_sub = suffix = 0;

	      if ((toP = addr_modeP->disp[i]))
		{
		  /* Suffix of expression, the largest size rules.  */
		  fromP = toP;

		  while ((c = *fromP++))
		    {
		      *toP++ = c;
		      if (c == ':')
			{
			  switch (*fromP)
			    {
			    case '\0':
			      as_warn (_("Premature end of suffix -- Defaulting to d"));
			      suffix = 4;
			      continue;
			    case 'b':
			      suffix_sub = 1;
			      break;
			    case 'w':
			      suffix_sub = 2;
			      break;
			    case 'd':
			      suffix_sub = 4;
			      break;
			    default:
			      as_warn (_("Bad suffix after ':' use {b|w|d} Defaulting to d"));
			      suffix = 4;
			    }

			  fromP ++;
			  toP --;	/* So we write over the ':' */

			  if (suffix < suffix_sub)
			    suffix = suffix_sub;
			}
		    }

		  *toP = '\0'; /* Terminate properly.  */
		  addr_modeP->disp_suffix[i] = suffix;
		  addr_modeP->am_size += suffix ? suffix : 4;
		}
	    }
	}
    }
  else
    {
      if (addr_modeP->mode == 20)
	{
	  /* Look in ns32k_opcode for size.  */
	  addr_modeP->disp_suffix[0] = addr_modeP->am_size = desc->im_size;
	  addr_modeP->im_disp = 0;
	}
    }

  return addr_modeP->mode;
}

/* Read an optionlist.  */

static void optlist PARAMS ((char *, struct ns32k_option *, unsigned long *));
static void
optlist (str, optionP, default_map)
     char *str;			/* The string to extract options from.  */
     struct ns32k_option *optionP;	/* How to search the string.  */
     unsigned long *default_map;	/* Default pattern and output.  */
{
  int i, j, k, strlen1, strlen2;
  char *patternP, *strP;

  strlen1 = strlen (str);

  if (strlen1 < 1)
    as_fatal (_("Very short instr to option, ie you can't do it on a NULLstr"));

  for (i = 0; optionP[i].pattern != 0; i++)
    {
      strlen2 = strlen (optionP[i].pattern);

      for (j = 0; j < strlen1; j++)
	{
	  patternP = optionP[i].pattern;
	  strP = &str[j];

	  for (k = 0; k < strlen2; k++)
	    {
	      if (*(strP++) != *(patternP++))
		break;
	    }

	  if (k == strlen2)
	    {			/* match */
	      *default_map |= optionP[i].or;
	      *default_map &= optionP[i].and;
	    }
	}
    }
}

/* Search struct for symbols.
   This function is used to get the short integer form of reg names in
   the instructions lmr, smr, lpr, spr return true if str is found in
   list.  */

static int list_search PARAMS ((char *, struct ns32k_option *, unsigned long *));

static int
list_search (str, optionP, default_map)
     char *str;				/* The string to match.  */
     struct ns32k_option *optionP;	/* List to search.  */
     unsigned long *default_map;	/* Default pattern and output.  */
{
  int i;

  for (i = 0; optionP[i].pattern != 0; i++)
    {
      if (!strncmp (optionP[i].pattern, str, 20))
	{
	  /* Use strncmp to be safe.  */
	  *default_map |= optionP[i].or;
	  *default_map &= optionP[i].and;

	  return -1;
	}
    }

  as_bad (_("No such entry in list. (cpu/mmu register)"));
  return 0;
}

static void
evaluate_expr (resultP, ptr)
     expressionS *resultP;
     char *ptr;
{
  char *tmp_line;

  tmp_line = input_line_pointer;
  input_line_pointer = ptr;
  expression (resultP);
  input_line_pointer = tmp_line;
}

/* Convert operands to iif-format and adds bitfields to the opcode.
   Operands are parsed in such an order that the opcode is updated from
   its most significant bit, that is when the operand need to alter the
   opcode.
   Be careful not to put to objects in the same iif-slot.  */

static void encode_operand
  PARAMS ((int, char **, const char *, const char *, char, char));

static void
encode_operand (argc, argv, operandsP, suffixP, im_size, opcode_bit_ptr)
     int argc;
     char **argv;
     const char *operandsP;
     const char *suffixP;
     char im_size ATTRIBUTE_UNUSED;
     char opcode_bit_ptr;
{
  int i, j;
  char d;
  int pcrel, b, loop, pcrel_adjust;
  unsigned long tmp;

  for (loop = 0; loop < argc; loop++)
    {
      /* What operand are we supposed to work on.  */
      i = operandsP[loop << 1] - '1';
      if (i > 3)
	as_fatal (_("Internal consistency error.  check ns32k-opcode.h"));

      pcrel = 0;
      pcrel_adjust = 0;
      tmp = 0;

      switch ((d = operandsP[(loop << 1) + 1]))
	{
	case 'f':		/* Operand of sfsr turns out to be a nasty
				   specialcase.  */
	  opcode_bit_ptr -= 5;
	case 'Z':		/* Float not immediate.  */
	case 'F':		/* 32 bit float	general form.  */
	case 'L':		/* 64 bit float.  */
	case 'I':		/* Integer not immediate.  */
	case 'B':		/* Byte	 */
	case 'W':		/* Word	 */
	case 'D':		/* Double-word.  */
	case 'A':		/* Double-word	gen-address-form ie no regs
				   allowed.  */
	  get_addr_mode (argv[i], &addr_modeP);

	  if ((addr_modeP.mode == 20) &&
	     (d == 'I' || d == 'Z' || d == 'A'))
	    as_fatal (d == 'A'? _("Address of immediate operand"):
			_("Invalid immediate write operand."));

	  if (opcode_bit_ptr == desc->opcode_size)
	    b = 4;
	  else
	    b = 6;

	  for (j = b; j < (b + 2); j++)
	    {
	      if (addr_modeP.disp[j - b])
		{
		  IIF (j,
		       2,
		       addr_modeP.disp_suffix[j - b],
		       (unsigned long) addr_modeP.disp[j - b],
		       0,
		       addr_modeP.pcrel,
		       iif.instr_size,
		       addr_modeP.im_disp,
		       IND (BRANCH, BYTE),
		       NULL,
		       (addr_modeP.scaled_reg ? addr_modeP.scaled_mode
			: addr_modeP.mode),
		       0);
		}
	    }

	  opcode_bit_ptr -= 5;
	  iif.iifP[1].object |= ((long) addr_modeP.mode) << opcode_bit_ptr;

	  if (addr_modeP.scaled_reg)
	    {
	      j = b / 2;
	      IIF (j, 1, 1, (unsigned long) addr_modeP.index_byte,
		   0, 0, 0, 0, 0, NULL, -1, 0);
	    }
	  break;

	case 'b':		/* Multiple instruction disp.  */
	  freeptr++;		/* OVE:this is an useful hack.  */
	  sprintf (freeptr, "((%s-1)*%d)", argv[i], desc->im_size);
	  argv[i] = freeptr;
	  pcrel -= 1;		/* Make pcrel 0 in spite of what case 'p':
				   wants.  */
	  /* fall thru */
	case 'p':		/* Displacement - pc relative addressing.  */
	  pcrel += 1;
	  /* fall thru */
	case 'd':		/* Displacement.  */
	  iif.instr_size += suffixP[i] ? suffixP[i] : 4;
	  IIF (12, 2, suffixP[i], (unsigned long) argv[i], 0,
	       pcrel, pcrel_adjust, 1, IND (BRANCH, BYTE), NULL, -1, 0);
	  break;
	case 'H':		/* Sequent-hack: the linker wants a bit set
				   when bsr.  */
	  pcrel = 1;
	  iif.instr_size += suffixP[i] ? suffixP[i] : 4;
	  IIF (12, 2, suffixP[i], (unsigned long) argv[i], 0,
	       pcrel, pcrel_adjust, 1, IND (BRANCH, BYTE), NULL, -1, 1);
	  break;
	case 'q':		/* quick */
	  opcode_bit_ptr -= 4;
	  IIF (11, 2, 42, (unsigned long) argv[i], 0, 0, 0, 0, 0,
	       bit_fix_new (4, opcode_bit_ptr, -8, 7, 0, 1, 0), -1, 0);
	  break;
	case 'r':		/* Register number (3 bits).  */
	  list_search (argv[i], opt6, &tmp);
	  opcode_bit_ptr -= 3;
	  iif.iifP[1].object |= tmp << opcode_bit_ptr;
	  break;
	case 'O':		/* Setcfg instruction optionslist.  */
	  optlist (argv[i], opt3, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << 15;
	  break;
	case 'C':		/* Cinv instruction optionslist.  */
	  optlist (argv[i], opt4, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << 15; /* Insert the regtype in opcode.  */
	  break;
	case 'S':		/* String instruction options list.  */
	  optlist (argv[i], opt5, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << 15;
	  break;
	case 'u':
	case 'U':		/* Register list.  */
	  IIF (10, 1, 1, 0, 0, 0, 0, 0, 0, NULL, -1, 0);
	  switch (operandsP[(i << 1) + 1])
	    {
	    case 'u':		/* Restore, exit.  */
	      optlist (argv[i], opt1, &iif.iifP[10].object);
	      break;
	    case 'U':		/* Save, enter.  */
	      optlist (argv[i], opt2, &iif.iifP[10].object);
	      break;
	    }
	  iif.instr_size += 1;
	  break;
	case 'M':		/* MMU register.  */
	  list_search (argv[i], mmureg, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << opcode_bit_ptr;
	  break;
	case 'P':		/* CPU register.  */
	  list_search (argv[i], cpureg, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << opcode_bit_ptr;
	  break;
	case 'g':		/* Inss exts.  */
	  iif.instr_size += 1;	/* 1 byte is allocated after the opcode.  */
	  IIF (10, 2, 1,
	       (unsigned long) argv[i],	/* i always 2 here.  */
	       0, 0, 0, 0, 0,
	       bit_fix_new (3, 5, 0, 7, 0, 0, 0), /* A bit_fix is targeted to
						     the byte.  */
	       -1, 0);
	  break;
	case 'G':
	  IIF (11, 2, 42,
	       (unsigned long) argv[i],	/* i always 3 here.  */
	       0, 0, 0, 0, 0,
	       bit_fix_new (5, 0, 1, 32, -1, 0, -1), -1, 0);
	  break;
	case 'i':
	  iif.instr_size += 1;
	  b = 2 + i;		/* Put the extension byte after opcode.  */
	  IIF (b, 2, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0);
	  break;
	default:
	  as_fatal (_("Bad opcode-table-option, check in file ns32k-opcode.h"));
	}
    }
}

/* in:  instruction line
   out: internal structure of instruction
   that has been prepared for direct conversion to fragment(s) and
   fixes in a systematical fashion
   Return-value = recursive_level.  */
/* Build iif of one assembly text line.  */

static int parse PARAMS ((const char *, int));

static int
parse (line, recursive_level)
     const char *line;
     int recursive_level;
{
  const char *lineptr;
  char c, suffix_separator;
  int i;
  unsigned int argc;
  int arg_type;
  char sqr, sep;
  char suffix[MAX_ARGS], *argv[MAX_ARGS];	/* No more than 4 operands.  */

  if (recursive_level <= 0)
    {
      /* Called from md_assemble.  */
      for (lineptr = line; (*lineptr) != '\0' && (*lineptr) != ' '; lineptr++)
	continue;

      c = *lineptr;
      *(char *) lineptr = '\0';

      if (!(desc = (struct ns32k_opcode *) hash_find (inst_hash_handle, line)))
	as_fatal (_("No such opcode"));

      *(char *) lineptr = c;
    }
  else
    {
      lineptr = line;
    }

  argc = 0;

  if (*desc->operands)
    {
      if (*lineptr++ != '\0')
	{
	  sqr = '[';
	  sep = ',';

	  while (*lineptr != '\0')
	    {
	      if (desc->operands[argc << 1])
		{
		  suffix[argc] = 0;
		  arg_type = desc->operands[(argc << 1) + 1];

		  switch (arg_type)
		    {
		    case 'd':
		    case 'b':
		    case 'p':
		    case 'H':
		      /* The operand is supposed to be a displacement.  */
		      /* Hackwarning: do not forget to update the 4
                         cases above when editing ns32k-opcode.h.  */
		      suffix_separator = ':';
		      break;
		    default:
		      /* If this char occurs we loose.  */
		      suffix_separator = '\255';
		      break;
		    }

		  suffix[argc] = 0; /* 0 when no ':' is encountered.  */
		  argv[argc] = freeptr;
		  *freeptr = '\0';

		  while ((c = *lineptr) != '\0' && c != sep)
		    {
		      if (c == sqr)
			{
			  if (sqr == '[')
			    {
			      sqr = ']';
			      sep = '\0';
			    }
			  else
			    {
			      sqr = '[';
			      sep = ',';
			    }
			}

		      if (c == suffix_separator)
			{
			  /* ':' - label/suffix separator.  */
			  switch (lineptr[1])
			    {
			    case 'b':
			      suffix[argc] = 1;
			      break;
			    case 'w':
			      suffix[argc] = 2;
			      break;
			    case 'd':
			      suffix[argc] = 4;
			      break;
			    default:
			      as_warn (_("Bad suffix, defaulting to d"));
			      suffix[argc] = 4;
			      if (lineptr[1] == '\0' || lineptr[1] == sep)
				{
				  lineptr += 1;
				  continue;
				}
			      break;
			    }

			  lineptr += 2;
			  continue;
			}

		      *freeptr++ = c;
		      lineptr++;
		    }

		  *freeptr++ = '\0';
		  argc += 1;

		  if (*lineptr == '\0')
		    continue;

		  lineptr += 1;
		}
	      else
		{
		  as_fatal (_("Too many operands passed to instruction"));
		}
	    }
	}
    }

  if (argc != strlen (desc->operands) / 2)
    {
      if (strlen (desc->default_args))
	{
	  /* We can apply default, don't goof.  */
	  if (parse (desc->default_args, 1) != 1)
	    /* Check error in default.  */
	    as_fatal (_("Wrong numbers of operands in default, check ns32k-opcodes.h"));
	}
      else
	{
	  as_fatal (_("Wrong number of operands"));
	}
    }

  for (i = 0; i < IIF_ENTRIES; i++)
    /* Mark all entries as void.  */
    iif.iifP[i].type = 0;

  /* Build opcode iif-entry.  */
  iif.instr_size = desc->opcode_size / 8;
  IIF (1, 1, iif.instr_size, desc->opcode_seed, 0, 0, 0, 0, 0, 0, -1, 0);

  /* This call encodes operands to iif format.  */
  if (argc)
    {
      encode_operand (argc,
		      argv,
		      &desc->operands[0],
		      &suffix[0],
		      desc->im_size,
		      desc->opcode_size);
    }
  return recursive_level;
}

/* Convert iif to fragments.  From this point we start to dribble with
   functions in other files than this one.(Except hash.c) So, if it's
   possible to make an iif for an other CPU, you don't need to know
   what frags, relax, obstacks, etc is in order to port this
   assembler. You only need to know if it's possible to reduce your
   cpu-instruction to iif-format (takes some work) and adopt the other
   md_? parts according to given instructions Note that iif was
   invented for the clean ns32k`s architecture.  */

/* GAS for the ns32k has a problem. PC relative displacements are
   relative to the address of the opcode, not the address of the
   operand. We used to keep track of the offset between the operand
   and the opcode in pcrel_adjust for each frag and each fix. However,
   we get into trouble where there are two or more pc-relative
   operands and the size of the first one can't be determined. Then in
   the relax phase, the size of the first operand will change and
   pcrel_adjust will no longer be correct.  The current solution is
   keep a pointer to the frag with the opcode in it and the offset in
   that frag for each frag and each fix. Then, when needed, we can
   always figure out how far it is between the opcode and the pcrel
   object.  See also md_pcrel_adjust and md_fix_pcrel_adjust.  For
   objects not part of an instruction, the pointer to the opcode frag
   is always zero.  */

static void convert_iif PARAMS ((void));
static void
convert_iif ()
{
  int i;
  bit_fixS *j;
  fragS *inst_frag;
  unsigned int inst_offset;
  char *inst_opcode;
  char *memP;
  int l;
  int k;
  char type;
  char size = 0;

  frag_grow (iif.instr_size);	/* This is important.  */
  memP = frag_more (0);
  inst_opcode = memP;
  inst_offset = (memP - frag_now->fr_literal);
  inst_frag = frag_now;

  for (i = 0; i < IIF_ENTRIES; i++)
    {
      if ((type = iif.iifP[i].type))
	{
	  /* The object exist, so handle it.  */
	  switch (size = iif.iifP[i].size)
	    {
	    case 42:
	      size = 0;
	      /* It's a bitfix that operates on an existing object.  */
	      if (iif.iifP[i].bit_fixP->fx_bit_base)
		/* Expand fx_bit_base to point at opcode.  */
		iif.iifP[i].bit_fixP->fx_bit_base = (long) inst_opcode;
	      /* Fall through.  */

	    case 8:		/* bignum or doublefloat.  */
	    case 1:
	    case 2:
	    case 3:
	    case 4:
	      /* The final size in objectmemory is known.  */
	      memP = frag_more (size);
	      j = iif.iifP[i].bit_fixP;

	      switch (type)
		{
		case 1:	/* The object is pure binary.  */
		  if (j)
		    {
		      md_number_to_field(memP, exprP.X_add_number, j);
		    }
		  else if (iif.iifP[i].pcrel)
		    {
		      fix_new_ns32k (frag_now,
				     (long) (memP - frag_now->fr_literal),
				     size,
				     0,
				     iif.iifP[i].object,
				     iif.iifP[i].pcrel,
				     iif.iifP[i].im_disp,
				     0,
				     iif.iifP[i].bsr,	/* Sequent hack.  */
				     inst_frag, inst_offset);
		    }
		  else
		    {
		      /* Good, just put them bytes out.  */
		      switch (iif.iifP[i].im_disp)
			{
			case 0:
			  md_number_to_chars (memP, iif.iifP[i].object, size);
			  break;
			case 1:
			  md_number_to_disp (memP, iif.iifP[i].object, size);
			  break;
			default:
			  as_fatal (_("iif convert internal pcrel/binary"));
			}
		    }
		  break;

		case 2:
		  /* The object is a pointer at an expression, so
                     unpack it, note that bignums may result from the
                     expression.  */
		  evaluate_expr (&exprP, (char *) iif.iifP[i].object);
		  if (exprP.X_op == O_big || size == 8)
		    {
		      if ((k = exprP.X_add_number) > 0)
			{
			  /* We have a bignum ie a quad. This can only
                             happens in a long suffixed instruction.  */
			  if (k * 2 > size)
			    as_bad (_("Bignum too big for long"));

			  if (k == 3)
			    memP += 2;

			  for (l = 0; k > 0; k--, l += 2)
			    md_number_to_chars (memP + l,
						generic_bignum[l >> 1],
						sizeof (LITTLENUM_TYPE));
			}
		      else
			{
			  /* flonum.  */
			  LITTLENUM_TYPE words[4];

			  switch (size)
			    {
			    case 4:
			      gen_to_words (words, 2, 8);
			      md_number_to_imm (memP, (long) words[0],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + sizeof (LITTLENUM_TYPE),
						(long) words[1],
						sizeof (LITTLENUM_TYPE));
			      break;
			    case 8:
			      gen_to_words (words, 4, 11);
			      md_number_to_imm (memP, (long) words[0],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + sizeof (LITTLENUM_TYPE),
						(long) words[1],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm ((memP + 2
						 * sizeof (LITTLENUM_TYPE)),
						(long) words[2],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm ((memP + 3
						 * sizeof (LITTLENUM_TYPE)),
						(long) words[3],
						sizeof (LITTLENUM_TYPE));
			      break;
			    }
			}
		      break;
		    }
		  if (exprP.X_add_symbol ||
		      exprP.X_op_symbol ||
		      iif.iifP[i].pcrel)
		    {
		      /* The expression was undefined due to an
                         undefined label. Create a fix so we can fix
                         the object later.  */
		      exprP.X_add_number += iif.iifP[i].object_adjust;
		      fix_new_ns32k_exp (frag_now,
					 (long) (memP - frag_now->fr_literal),
					 size,
					 &exprP,
					 iif.iifP[i].pcrel,
					 iif.iifP[i].im_disp,
					 j,
					 iif.iifP[i].bsr,
					 inst_frag, inst_offset);
		    }
		  else if (j)
		    {
		      md_number_to_field(memP, exprP.X_add_number, j);
		    }
		  else
		    {
		      /* Good, just put them bytes out.  */
		      switch (iif.iifP[i].im_disp)
			{
			case 0:
			  md_number_to_imm (memP, exprP.X_add_number, size);
			  break;
			case 1:
			  md_number_to_disp (memP, exprP.X_add_number, size);
			  break;
			default:
			  as_fatal (_("iif convert internal pcrel/pointer"));
			}
		    }
		  break;
		default:
		  as_fatal (_("Internal logic error in iif.iifP[n].type"));
		}
	      break;

	    case 0:
	      /* Too bad, the object may be undefined as far as its
		 final nsize in object memory is concerned.  The size
		 of the object in objectmemory is not explicitly
		 given.  If the object is defined its length can be
		 determined and a fix can replace the frag.  */
	      {
		evaluate_expr (&exprP, (char *) iif.iifP[i].object);

		if ((exprP.X_add_symbol || exprP.X_op_symbol) &&
		    !iif.iifP[i].pcrel)
		  {
		    /* Size is unknown until link time so have to default.  */
		    size = default_disp_size; /* Normally 4 bytes.  */
		    memP = frag_more (size);
		    fix_new_ns32k_exp (frag_now,
				       (long) (memP - frag_now->fr_literal),
				       size,
				       &exprP,
				       0, /* never iif.iifP[i].pcrel, */
				       1, /* always iif.iifP[i].im_disp */
				       (bit_fixS *) 0, 0,
				       inst_frag,
				       inst_offset);
		    break;		/* Exit this absolute hack.  */
		  }

		if (exprP.X_add_symbol || exprP.X_op_symbol)
		  {
		    /* Frag it.  */
		    if (exprP.X_op_symbol)
		      {
			/* We cant relax this case.  */
			as_fatal (_("Can't relax difference"));
		      }
		    else
		      {
			/* Size is not important.  This gets fixed by
			   relax, but we assume 0 in what follows.  */
			memP = frag_more (4); /* Max size.  */
			size = 0;

			{
			  fragS *old_frag = frag_now;
			  frag_variant (rs_machine_dependent,
					4, /* Max size.  */
					0, /* Size.  */
					IND (BRANCH, UNDEF), /* Expecting
                                                                the worst.  */
					exprP.X_add_symbol,
					exprP.X_add_number,
					inst_opcode);
			  frag_opcode_frag (old_frag) = inst_frag;
			  frag_opcode_offset (old_frag) = inst_offset;
			  frag_bsr (old_frag) = iif.iifP[i].bsr;
			}
		      }
		  }
		else
		  {
		    /* This duplicates code in md_number_to_disp.  */
		    if (-64 <= exprP.X_add_number && exprP.X_add_number <= 63)
		      {
			size = 1;
		      }
		    else
		      {
			if (-8192 <= exprP.X_add_number
			    && exprP.X_add_number <= 8191)
			  {
			    size = 2;
			  }
			else
			  {
			    if (-0x20000000 <= exprP.X_add_number
				&& exprP.X_add_number<=0x1fffffff)
			      {
				size = 4;
			      }
			    else
			      {
				as_bad (_("Displacement to large for :d"));
				size = 4;
			      }
			  }
		      }

		    memP = frag_more (size);
		    md_number_to_disp (memP, exprP.X_add_number, size);
		  }
	      }
	      break;

	    default:
	      as_fatal (_("Internal logic error in iif.iifP[].type"));
	    }
	}
    }
}

#ifdef BFD_ASSEMBLER
/* This functionality should really be in the bfd library.  */
static bfd_reloc_code_real_type
reloc (int size, int pcrel, int type)
{
  int length, index;
  bfd_reloc_code_real_type relocs[] =
  {
    BFD_RELOC_NS32K_IMM_8,
    BFD_RELOC_NS32K_IMM_16,
    BFD_RELOC_NS32K_IMM_32,
    BFD_RELOC_NS32K_IMM_8_PCREL,
    BFD_RELOC_NS32K_IMM_16_PCREL,
    BFD_RELOC_NS32K_IMM_32_PCREL,

    /* ns32k displacements.  */
    BFD_RELOC_NS32K_DISP_8,
    BFD_RELOC_NS32K_DISP_16,
    BFD_RELOC_NS32K_DISP_32,
    BFD_RELOC_NS32K_DISP_8_PCREL,
    BFD_RELOC_NS32K_DISP_16_PCREL,
    BFD_RELOC_NS32K_DISP_32_PCREL,

    /* Normal 2's complement.  */
    BFD_RELOC_8,
    BFD_RELOC_16,
    BFD_RELOC_32,
    BFD_RELOC_8_PCREL,
    BFD_RELOC_16_PCREL,
    BFD_RELOC_32_PCREL
  };

  switch (size)
    {
    case 1:
      length = 0;
      break;
    case 2:
      length = 1;
      break;
    case 4:
      length = 2;
      break;
    default:
      length = -1;
      break;
    }

  index = length + 3 * pcrel + 6 * type;

  if (index >= 0 && (unsigned int) index < sizeof (relocs) / sizeof (relocs[0]))
    return relocs[index];

  if (pcrel)
    as_bad (_("Can not do %d byte pc-relative relocation for storage type %d"),
	    size, type);
  else
    as_bad (_("Can not do %d byte relocation for storage type %d"),
	    size, type);

  return BFD_RELOC_NONE;

}
#endif

void
md_assemble (line)
     char *line;
{
  freeptr = freeptr_static;
  parse (line, 0);		/* Explode line to more fix form in iif.  */
  convert_iif ();		/* Convert iif to frags, fix's etc.  */
#ifdef SHOW_NUM
  printf (" \t\t\t%s\n", line);
#endif
}

void
md_begin ()
{
  /* Build a hashtable of the instructions.  */
  const struct ns32k_opcode *ptr;
  const char *stat;
  const struct ns32k_opcode *endop;

  inst_hash_handle = hash_new ();

  endop = ns32k_opcodes + sizeof (ns32k_opcodes) / sizeof (ns32k_opcodes[0]);
  for (ptr = ns32k_opcodes; ptr < endop; ptr++)
    {
      if ((stat = hash_insert (inst_hash_handle, ptr->name, (char *) ptr)))
	/* Fatal.  */
	as_fatal (_("Can't hash %s: %s"), ptr->name, stat);
    }

  /* Some private space please!  */
  freeptr_static = (char *) malloc (PRIVATE_SIZE);
}

/* Must be equal to MAX_PRECISON in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn the string pointed to by litP into a floating point constant
   of type TYPE, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;
    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words + prec; prec--;)
    {
      md_number_to_chars (litP, (long) (*--wordP), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
}

/* Convert number to chars in correct order.  */

void
md_number_to_chars (buf, value, nbytes)
     char *buf;
     valueT value;
     int nbytes;
{
  number_to_chars_littleendian (buf, value, nbytes);
}

/* This is a variant of md_numbers_to_chars. The reason for its'
   existence is the fact that ns32k uses Huffman coded
   displacements. This implies that the bit order is reversed in
   displacements and that they are prefixed with a size-tag.

   binary: msb -> lsb
   0xxxxxxx				byte
   10xxxxxx xxxxxxxx			word
   11xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx	double word

   This must be taken care of and we do it here!  */

static void
md_number_to_disp (buf, val, n)
     char *buf;
     long val;
     char n;
{
  switch (n)
    {
    case 1:
      if (val < -64 || val > 63)
	as_bad (_("value of %ld out of byte displacement range."), val);
      val &= 0x7f;
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    case 2:
      if (val < -8192 || val > 8191)
	as_bad (_("value of %ld out of word displacement range."), val);
      val &= 0x3fff;
      val |= 0x8000;
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    case 4:
      if (val < -0x20000000 || val >= 0x20000000)
	as_bad (_("value of %ld out of double word displacement range."), val);
      val |= 0xc0000000;
#ifdef SHOW_NUM
      printf ("%x ", val >> 24 & 0xff);
#endif
      *buf++ = (val >> 24);
#ifdef SHOW_NUM
      printf ("%x ", val >> 16 & 0xff);
#endif
      *buf++ = (val >> 16);
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    default:
      as_fatal (_("Internal logic error.  line %d, file \"%s\""),
		__LINE__, __FILE__);
    }
}

static void
md_number_to_imm (buf, val, n)
     char *buf;
     long val;
     char n;
{
  switch (n)
    {
    case 1:
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    case 2:
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    case 4:
#ifdef SHOW_NUM
      printf ("%x ", val >> 24 & 0xff);
#endif
      *buf++ = (val >> 24);
#ifdef SHOW_NUM
      printf ("%x ", val >> 16 & 0xff);
#endif
      *buf++ = (val >> 16);
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    default:
      as_fatal (_("Internal logic error. line %d, file \"%s\""),
		__LINE__, __FILE__);
    }
}

/* Fast bitfiddling support.  */
/* Mask used to zero bitfield before oring in the true field.  */

static unsigned long l_mask[] =
{
  0xffffffff, 0xfffffffe, 0xfffffffc, 0xfffffff8,
  0xfffffff0, 0xffffffe0, 0xffffffc0, 0xffffff80,
  0xffffff00, 0xfffffe00, 0xfffffc00, 0xfffff800,
  0xfffff000, 0xffffe000, 0xffffc000, 0xffff8000,
  0xffff0000, 0xfffe0000, 0xfffc0000, 0xfff80000,
  0xfff00000, 0xffe00000, 0xffc00000, 0xff800000,
  0xff000000, 0xfe000000, 0xfc000000, 0xf8000000,
  0xf0000000, 0xe0000000, 0xc0000000, 0x80000000,
};
static unsigned long r_mask[] =
{
  0x00000000, 0x00000001, 0x00000003, 0x00000007,
  0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
  0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
  0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
  0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
  0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
  0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
  0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
};
#define MASK_BITS 31
/* Insert bitfield described by field_ptr and val at buf
   This routine is written for modification of the first 4 bytes pointed
   to by buf, to yield speed.
   The ifdef stuff is for selection between a ns32k-dependent routine
   and a general version. (My advice: use the general version!).  */

static void
md_number_to_field (buf, val, field_ptr)
     char *buf;
     long val;
     bit_fixS *field_ptr;
{
  unsigned long object;
  unsigned long mask;
  /* Define ENDIAN on a ns32k machine.  */
#ifdef ENDIAN
  unsigned long *mem_ptr;
#else
  char *mem_ptr;
#endif

  if (field_ptr->fx_bit_min <= val && val <= field_ptr->fx_bit_max)
    {
#ifdef ENDIAN
      if (field_ptr->fx_bit_base)
	/* Override buf.  */
	mem_ptr = (unsigned long *) field_ptr->fx_bit_base;
      else
	mem_ptr = (unsigned long *) buf;

      mem_ptr = ((unsigned long *)
		 ((char *) mem_ptr + field_ptr->fx_bit_base_adj));
#else
      if (field_ptr->fx_bit_base)
	mem_ptr = (char *) field_ptr->fx_bit_base;
      else
	mem_ptr = buf;

      mem_ptr += field_ptr->fx_bit_base_adj;
#endif
#ifdef ENDIAN
      /* We have a nice ns32k machine with lowbyte at low-physical mem.  */
      object = *mem_ptr;	/* get some bytes */
#else /* OVE Goof! the machine is a m68k or dito.  */
      /* That takes more byte fiddling.  */
      object = 0;
      object |= mem_ptr[3] & 0xff;
      object <<= 8;
      object |= mem_ptr[2] & 0xff;
      object <<= 8;
      object |= mem_ptr[1] & 0xff;
      object <<= 8;
      object |= mem_ptr[0] & 0xff;
#endif
      mask = 0;
      mask |= (r_mask[field_ptr->fx_bit_offset]);
      mask |= (l_mask[field_ptr->fx_bit_offset + field_ptr->fx_bit_size]);
      object &= mask;
      val += field_ptr->fx_bit_add;
      object |= ((val << field_ptr->fx_bit_offset) & (mask ^ 0xffffffff));
#ifdef ENDIAN
      *mem_ptr = object;
#else
      mem_ptr[0] = (char) object;
      object >>= 8;
      mem_ptr[1] = (char) object;
      object >>= 8;
      mem_ptr[2] = (char) object;
      object >>= 8;
      mem_ptr[3] = (char) object;
#endif
    }
  else
    {
      as_bad (_("Bit field out of range"));
    }
}

int
md_pcrel_adjust (fragP)
     fragS *fragP;
{
  fragS *opcode_frag;
  addressT opcode_address;
  unsigned int offset;

  opcode_frag = frag_opcode_frag (fragP);
  if (opcode_frag == 0)
    return 0;

  offset = frag_opcode_offset (fragP);
  opcode_address = offset + opcode_frag->fr_address;

  return fragP->fr_address + fragP->fr_fix - opcode_address;
}

static int md_fix_pcrel_adjust PARAMS ((fixS *fixP));
static int
md_fix_pcrel_adjust (fixP)
     fixS *fixP;
{
  fragS *opcode_frag;
  addressT opcode_address;
  unsigned int offset;

  opcode_frag = fix_opcode_frag (fixP);
  if (opcode_frag == 0)
    return 0;

  offset = fix_opcode_offset (fixP);
  opcode_address = offset + opcode_frag->fr_address;

  return fixP->fx_where + fixP->fx_frag->fr_address - opcode_address;
}

/* Apply a fixS (fixup of an instruction or data that we didn't have
   enough info to complete immediately) to the data in a frag.

   On the ns32k, everything is in a different format, so we have broken
   out separate functions for each kind of thing we could be fixing.
   They all get called from here.  */

void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
{
  long val = * (long *) valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;

  if (fix_bit_fixP (fixP))
    {
      /* Bitfields to fix, sigh.  */
      md_number_to_field (buf, val, fix_bit_fixP (fixP));
    }
  else switch (fix_im_disp (fixP))
    {
    case 0:
      /* Immediate field.  */
      md_number_to_imm (buf, val, fixP->fx_size);
      break;

    case 1:
      /* Displacement field.  */
      /* Calculate offset.  */
      md_number_to_disp (buf,
			 (fixP->fx_pcrel ? val + md_fix_pcrel_adjust (fixP)
			  : val), fixP->fx_size);
      break;

    case 2:
      /* Pointer in a data object.  */
      md_number_to_chars (buf, val, fixP->fx_size);
      break;
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Convert a relaxed displacement to ditto in final output.  */

#ifndef BFD_ASSEMBLER
void
md_convert_frag (headers, sec, fragP)
     object_headers *headers;
     segT sec;
     fragS *fragP;
#else
void
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
#endif
{
  long disp;
  long ext = 0;
  /* Address in gas core of the place to store the displacement.  */
  char *buffer_address = fragP->fr_fix + fragP->fr_literal;
  /* Address in object code of the displacement.  */
  int object_address;

  switch (fragP->fr_subtype)
    {
    case IND (BRANCH, BYTE):
      ext = 1;
      break;
    case IND (BRANCH, WORD):
      ext = 2;
      break;
    case IND (BRANCH, DOUBLE):
      ext = 4;
      break;
    }

  if (ext == 0)
    return;

  know (fragP->fr_symbol);

  object_address = fragP->fr_fix + fragP->fr_address;

  /* The displacement of the address, from current location.  */
  disp = (S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset) - object_address;
  disp += md_pcrel_adjust (fragP);

  md_number_to_disp (buffer_address, (long) disp, (int) ext);
  fragP->fr_fix += ext;
}

/* This function returns the estimated size a variable object will occupy,
   one can say that we tries to guess the size of the objects before we
   actually know it.  */

int
md_estimate_size_before_relax (fragP, segment)
     fragS *fragP;
     segT segment;
{
  if (fragP->fr_subtype == IND (BRANCH, UNDEF))
    {
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
	{
	  /* We don't relax symbols defined in another segment.  The
	     thing to do is to assume the object will occupy 4 bytes.  */
	  fix_new_ns32k (fragP,
			 (int) (fragP->fr_fix),
			 4,
			 fragP->fr_symbol,
			 fragP->fr_offset,
			 1,
			 1,
			 0,
			 frag_bsr(fragP), /* Sequent hack.  */
			 frag_opcode_frag (fragP),
			 frag_opcode_offset (fragP));
	  fragP->fr_fix += 4;
#if 0
	  fragP->fr_opcode[1] = 0xff;
#endif
	  frag_wane (fragP);
	  return 4;
	}

      /* Relaxable case.  Set up the initial guess for the variable
	 part of the frag.  */
      fragP->fr_subtype = IND (BRANCH, BYTE);
    }

  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

int md_short_jump_size = 3;
int md_long_jump_size = 5;
const int md_reloc_size = 8;	/* Size of relocation record.  */

void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
{
  valueT offset;

  offset = to_addr - from_addr;
  md_number_to_chars (ptr, (valueT) 0xEA, 1);
  md_number_to_disp (ptr + 1, (valueT) offset, 2);
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
{
  valueT offset;

  offset = to_addr - from_addr;
  md_number_to_chars (ptr, (valueT) 0xEA, 1);
  md_number_to_disp (ptr + 1, (valueT) offset, 4);
}

const char *md_shortopts = "m:";

struct option md_longopts[] =
{
#define OPTION_DISP_SIZE (OPTION_MD_BASE)
  {"disp-size-default", required_argument , NULL, OPTION_DISP_SIZE},
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
    {
    case 'm':
      if (!strcmp (arg, "32032"))
	{
	  cpureg = cpureg_032;
	  mmureg = mmureg_032;
	}
      else if (!strcmp (arg, "32532"))
	{
	  cpureg = cpureg_532;
	  mmureg = mmureg_532;
	}
      else
	{
	  as_warn (_("invalid architecture option -m%s, ignored"), arg);
	  return 0;
	}
      break;
    case OPTION_DISP_SIZE:
      {
	int size = atoi(arg);
	switch (size)
	  {
	  case 1: case 2: case 4:
	    default_disp_size = size;
	    break;
	  default:
	    as_warn (_("invalid default displacement size \"%s\". Defaulting to %d."),
		     arg, default_disp_size);
	  }
	break;
      }

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (stream)
     FILE *stream;
{
  fprintf (stream, _("\
NS32K options:\n\
-m32032 | -m32532	select variant of NS32K architecture\n\
--disp-size-default=<1|2|4>\n"));
}

/* Create a bit_fixS in obstack 'notes'.
   This struct is used to profile the normal fix. If the bit_fixP is a
   valid pointer (not NULL) the bit_fix data will be used to format
   the fix.  */

bit_fixS *
bit_fix_new (size, offset, min, max, add, base_type, base_adj)
     char size;			/* Length of bitfield.  */
     char offset;		/* Bit offset to bitfield.  */
     long min;			/* Signextended min for bitfield.  */
     long max;			/* Signextended max for bitfield.  */
     long add;			/* Add mask, used for huffman prefix.  */
     long base_type;		/* 0 or 1, if 1 it's exploded to opcode ptr.  */
     long base_adj;
{
  bit_fixS *bit_fixP;

  bit_fixP = (bit_fixS *) obstack_alloc (&notes, sizeof (bit_fixS));

  bit_fixP->fx_bit_size = size;
  bit_fixP->fx_bit_offset = offset;
  bit_fixP->fx_bit_base = base_type;
  bit_fixP->fx_bit_base_adj = base_adj;
  bit_fixP->fx_bit_max = max;
  bit_fixP->fx_bit_min = min;
  bit_fixP->fx_bit_add = add;

  return bit_fixP;
}

void
fix_new_ns32k (frag, where, size, add_symbol, offset, pcrel,
	       im_disp, bit_fixP, bsr, opcode_frag, opcode_offset)
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2  or 4 usually.  */
     symbolS *add_symbol;	/* X_add_symbol.  */
     long offset;		/* X_add_number.  */
     int pcrel;			/* True if PC-relative relocation.  */
     char im_disp;		/* True if the value to write is a
				   displacement.  */
     bit_fixS *bit_fixP;	/* Pointer at struct of bit_fix's, ignored if
				   NULL.  */
     char bsr;			/* Sequent-linker-hack: 1 when relocobject is
				   a bsr.  */
     fragS *opcode_frag;
     unsigned int opcode_offset;
{
  fixS *fixP = fix_new (frag, where, size, add_symbol,
			offset, pcrel,
#ifdef BFD_ASSEMBLER
			bit_fixP ? NO_RELOC : reloc (size, pcrel, im_disp)
#else
			NO_RELOC
#endif
			);

  fix_opcode_frag (fixP) = opcode_frag;
  fix_opcode_offset (fixP) = opcode_offset;
  fix_im_disp (fixP) = im_disp;
  fix_bsr (fixP) = bsr;
  fix_bit_fixP (fixP) = bit_fixP;
  /* We have a MD overflow check for displacements.  */
  fixP->fx_no_overflow = (im_disp != 0);
}

void
fix_new_ns32k_exp (frag, where, size, exp, pcrel,
		   im_disp, bit_fixP, bsr, opcode_frag, opcode_offset)
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2  or 4 usually.  */
     expressionS *exp;		/* Expression.  */
     int pcrel;			/* True if PC-relative relocation.  */
     char im_disp;		/* True if the value to write is a
				   displacement.  */
     bit_fixS *bit_fixP;	/* Pointer at struct of bit_fix's, ignored if
				   NULL.  */
     char bsr;			/* Sequent-linker-hack: 1 when relocobject is
				   a bsr.  */
     fragS *opcode_frag;
     unsigned int opcode_offset;
{
  fixS *fixP = fix_new_exp (frag, where, size, exp, pcrel,
#ifdef BFD_ASSEMBLER
			    bit_fixP ? NO_RELOC : reloc (size, pcrel, im_disp)
#else
			    NO_RELOC
#endif
			    );

  fix_opcode_frag (fixP) = opcode_frag;
  fix_opcode_offset (fixP) = opcode_offset;
  fix_im_disp (fixP) = im_disp;
  fix_bsr (fixP) = bsr;
  fix_bit_fixP (fixP) = bit_fixP;
  /* We have a MD overflow check for displacements.  */
  fixP->fx_no_overflow = (im_disp != 0);
}

/* This is TC_CONS_FIX_NEW, called by emit_expr in read.c.  */

void
cons_fix_new_ns32k (frag, where, size, exp)
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2  or 4 usually.  */
     expressionS *exp;		/* Expression.  */
{
  fix_new_ns32k_exp (frag, where, size, exp,
		     0, 2, 0, 0, 0, 0);
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
{
  return size;			/* Byte alignment is fine.  */
}

/* Exactly what point is a PC-relative offset relative TO?  On the
   ns32k, they're relative to the start of the instruction.  */

long
md_pcrel_from (fixP)
     fixS *fixP;
{
  long res;

  res = fixP->fx_where + fixP->fx_frag->fr_address;
#ifdef SEQUENT_COMPATABILITY
  if (frag_bsr (fixP->fx_frag))
    res += 0x12			/* FOO Kludge alert!  */
#endif
      return res;
}

#ifdef BFD_ASSEMBLER

arelent *
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *rel;
  bfd_reloc_code_real_type code;

  code = reloc (fixp->fx_size, fixp->fx_pcrel, fix_im_disp (fixp));

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  if (fixp->fx_pcrel)
    rel->addend = fixp->fx_addnumber;
  else
    rel->addend = 0;

  rel->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (!rel->howto)
    {
      const char *name;

      name = S_GET_NAME (fixp->fx_addsy);
      if (name == NULL)
	name = _("<unknown>");
      as_fatal (_("Cannot find relocation type for symbol %s, code %d"),
		name, (int) code);
    }

  return rel;
}
#else /* BFD_ASSEMBLER */

#ifdef OBJ_AOUT
void
cons_fix_new_ns32k (where, fixP, segment_address_in_file)
     char *where;
     struct fix *fixP;
     relax_addressT segment_address_in_file;
{
  /* In:  Length of relocation (or of address) in chars: 1, 2 or 4.
     Out: GNU LD relocation length code: 0, 1, or 2.  */

  static unsigned char nbytes_r_length[] = { 42, 0, 1, 42, 2 };
  long r_symbolnum;

  know (fixP->fx_addsy != NULL);

  md_number_to_chars (where,
       fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
		      4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);

  md_number_to_chars (where + 4,
		      ((long) (r_symbolnum)
		       | (long) (fixP->fx_pcrel << 24)
		       | (long) (nbytes_r_length[fixP->fx_size] << 25)
		       | (long) ((!S_IS_DEFINED (fixP->fx_addsy)) << 27)
		       | (long) (fix_bsr (fixP) << 28)
		       | (long) (fix_im_disp (fixP) << 29)),
		      4);
}

#endif /* OBJ_AOUT */
#endif /* BFD_ASSEMBLER */
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d179 1
a179 1
   The low-order-byte coresponds to low physical memory.
d335 1
a335 1
   The ns32k uses the begining of the instruction as displacement
d444 1
a444 1
		  addr_modeP->mode = 27;	/* pc-relativ */
d678 1
a678 1
      /* Resolve ambigious operands, this shouldn't be necessary if
d680 1
a680 1
	 compiler doesn't!!!  This finds a proper addressinging mode
d891 1
a891 1
   Be carefull not to put to objects in the same iif-slot.  */
d982 1
a982 1
	  pcrel -= 1;		/* Make pcrel 0 inspite of what case 'p':
d1261 1
a1261 1
   invented for the clean ns32k`s architecure.  */
d1643 2
a1645 1
  const struct ns32k_opcode *endop;
d2439 1
a2439 1
#endif /* BFD_ASSMEBLER */
@


1.4
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2001
a25 1
#include <ctype.h>
d66 1
d69 1
a69 1
#define ABSOLUTE_PREFIX '@@'	/* One or the other MUST be defined */
d74 13
a86 13
    char mode;			/* addressing mode of operand (0-31) */
    char scaled_mode;		/* mode combined with scaled mode */
    char scaled_reg;		/* register used in scaled+1 (1-8) */
    char float_flag;		/* set if R0..R7 was F0..F7 ie a
				   floating-point-register */
    char am_size;		/* estimated max size of general addr-mode
				   parts */
    char im_disp;		/* if im_disp==1 we have a displacement */
    char pcrel;			/* 1 if pcrel, this is really redundant info */
    char disp_suffix[2];	/* length of displacement(s), 0=undefined */
    char *disp[2];		/* pointer(s) at displacement(s)
				   or immediates(s)     (ascii) */
    char index_byte;		/* index byte */
d100 5
a104 5
 * used as an intermediate form to store the actual parts of the
 * instruction. A ns32k machine instruction can be divided into a
 * couple of sub PARTs. When an instruction is assembled the
 * appropriate PART get an assignment. When an IIF has been completed
 * it is converted to a FRAGment as specified in AS.H.  */
d116 10
a125 11
    int type;			/* how to interpret object */
    int size;			/* Estimated max size of object */
    unsigned long object;	/* binary data */
    int object_adjust;		/* number added to object */
    int pcrel;			/* True if object is pcrel */
    int pcrel_adjust;		/* length in bytes from the
					   instruction start to the
					   displacement */
    int im_disp;		/* True if the object is a displacement */
    relax_substateT relax_substate;	/* Initial relaxsubstate */
    bit_fixS *bit_fixP;		/* Pointer at bit_fix struct */
d127 3
a129 3
				   iif-entry */
    char bsr;			/* Sequent hack */
  } iif_entryT;			/* Internal Instruction Format */
d187 1
a187 1
struct ns32k_option opt1[] =		/* restore, exit */
d199 1
a199 1
struct ns32k_option opt2[] =		/* save, enter */
d211 1
a211 1
struct ns32k_option opt3[] =		/* setcfg */
d219 1
a219 1
struct ns32k_option opt4[] =		/* cinv */
d226 1
a226 1
struct ns32k_option opt5[] =		/* string inst */
d233 1
a233 1
struct ns32k_option opt6[] =		/* plain reg ext,cvtp etc */
d250 1
a250 1
struct ns32k_option cpureg_532[] =	/* lpr spr */
d267 1
a267 1
struct ns32k_option mmureg_532[] =	/* lmr smr */
d279 1
a279 1
struct ns32k_option cpureg_032[] =	/* lpr spr */
d290 1
a290 1
struct ns32k_option mmureg_032[] =	/* lmr smr */
d370 4
a373 3
static void evaluate_expr PARAMS ((expressionS * resultP, char *ptr));
static void md_number_to_disp PARAMS ((char *buf, long val, int n));
static void md_number_to_imm PARAMS ((char *buf, long val, int n));
d383 3
a385 1
int
d388 1
a388 1
     register addr_modeS *addr_modeP;
d391 4
a394 4
  register char *str;
  register int i;
  register int strl;
  register int mode;
d397 3
a399 3
  mode = DEFAULT;		/* default */
  addr_modeP->scaled_mode = 0;	/* why not */
  addr_modeP->scaled_reg = 0;	/* if 0, not scaled index */
d403 1
a403 1
  addr_modeP->pcrel = 0;	/* not set in this function */
d449 1
a449 1
	      as_warn (_("Invalid syntax in PC-relative addressing mode"));
d463 1
a463 1
		{			/* disp[0]'s termination point */
d473 1
a473 1
		  as_warn (_("Invalid syntax in External addressing mode"));
d536 2
a537 1
		{			/* Memory relative.  */
d554 1
a554 1
		      as_warn (_("Invalid syntax in Memory Relative addressing mode"));
d621 1
a621 1
	      as_warn (_("Invalid scaled-indexed mode, use (b,w,d,q)"));
d626 1
a626 1
		as_warn (_("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"));
d631 1
a631 1
	      as_warn (_("Scaled-indexed addressing mode combined with scaled-index"));
d635 3
a637 3
	  addr_modeP->am_size += 1;	/* scaled index byte */
	  j = str[strl - 4] - '0';	/* store temporary */
	  str[strl - 6] = '\000';	/* nullterminate for recursive call */
d642 1
a642 1
	      as_warn (_("Invalid or illegal addressing mode combined with scaled-index"));
d666 2
a667 1
int
d708 1
a708 1
  if (tmp = addr_modeP->scaled_reg)
d717 2
a718 1
  if (disp_test[addr_modeP->mode])
d720 6
a725 6
      register char c;
      register char suffix;
      register char suffix_sub;
      register int i;
      register char *toP;
      register char *fromP;
d730 2
a731 1
      if (disp_test[addr_modeP->mode])
d744 1
a744 1
	      if (toP = addr_modeP->disp[i])
d749 1
a749 1
		  while (c = *fromP++)
d804 2
a805 1
void
d811 2
a812 2
  register int i, j, k, strlen1, strlen2;
  register char *patternP, *strP;
d848 3
a850 1
int
d856 1
a856 1
  register int i;
d870 1
a870 1
  as_warn (_("No such entry in list. (cpu/mmu register)"));
d879 1
a879 1
  register char *tmp_line;
d883 1
a883 1
  expression (&exprP);
d893 4
a896 1
void
d900 3
a902 3
     char *operandsP;
     char *suffixP;
     char im_size;
d905 1
a905 1
  register int i, j;
d907 2
a908 1
  int pcrel, tmp, b, loop, pcrel_adjust;
d923 2
a924 2
	case 'f':		/* operand of sfsr turns out to be a nasty
				   specialcase */
d926 9
a934 9
	case 'Z':		/* float not immediate */
	case 'F':		/* 32 bit float	general form */
	case 'L':		/* 64 bit float	*/
	case 'I':		/* integer not immediate */
	case 'B':		/* byte	 */
	case 'W':		/* word	 */
	case 'D':		/* double-word	*/
	case 'A':		/* double-word	gen-address-form ie no regs
				   allowed */
d978 3
a980 3
	case 'b':		/* multiple instruction disp */
	  freeptr++;		/* OVE:this is an useful hack */
	  sprintf (freeptr, "((%s-1)*%d)\000", argv[i], desc->im_size);
d982 2
a983 2
	  pcrel -= 1;		/* make pcrel 0 inspite of what case 'p':
				   wants */
d985 1
a985 1
	case 'p':		/* displacement - pc relative addressing */
d988 1
a988 1
	case 'd':		/* displacement */
d993 2
a994 2
	case 'H':		/* sequent-hack: the linker wants a bit set
				   when bsr */
d1005 1
a1005 1
	case 'r':		/* register number (3 bits) */
d1010 1
a1010 1
	case 'O':		/* setcfg instruction optionslist */
d1015 1
a1015 1
	case 'C':		/* cinv instruction optionslist */
d1018 1
a1018 1
	  iif.iifP[1].object |= tmp << 15; /* insert the regtype in opcode */
d1020 1
a1020 1
	case 'S':		/* stringinstruction optionslist */
d1026 1
a1026 1
	case 'U':		/* registerlist */
d1030 1
a1030 1
	    case 'u':		/* restore, exit */
d1033 1
a1033 1
	    case 'U':		/* save,enter */
d1039 1
a1039 1
	case 'M':		/* mmu register */
d1044 1
a1044 1
	case 'P':		/* cpu register  */
d1049 2
a1050 2
	case 'g':		/* inss exts */
	  iif.instr_size += 1;	/* 1 byte is allocated after the opcode */
d1052 1
a1052 1
	       (unsigned long) argv[i],	/* i always 2 here */
d1054 2
a1055 2
	       bit_fix_new (3, 5, 0, 7, 0, 0, 0), /* a bit_fix is targeted to
						     the byte */
d1060 1
a1060 1
	       (unsigned long) argv[i],	/* i always 3 here */
d1066 1
a1066 1
	  b = 2 + i;		/* put the extension byte after opcode */
d1079 1
a1079 1
   Return-value = recursive_level.    */
d1082 3
a1084 1
int
d1086 1
a1086 1
     char *line;
d1089 5
a1093 3
  register char *lineptr, c, suffix_separator;
  register int i;
  int argc, arg_type;
d1104 1
a1104 1
      *lineptr = '\0';
d1109 1
a1109 1
      *lineptr = c;
d1149 1
a1149 1
		  suffix[argc] = 0; /* 0 when no ':' is encountered */
d1278 2
a1279 1
void
a1291 1
  int size_so_far;
d1293 1
d1301 1
a1301 1
      if (type = iif.iifP[i].type)
d1314 1
a1314 1
	    case 8:		/* bignum or doublefloat */
d1320 1
a1320 1
	      memP = frag_more(size);
d1326 5
a1330 1
		  if (j || iif.iifP[i].pcrel)
d1339 2
a1340 2
				     j,
				     iif.iifP[i].bsr,	/* sequent hack */
d1372 1
a1372 1
			    as_warn (_("Bignum too big for long"));
d1378 3
a1380 5
			    {
			      md_number_to_chars (memP + l,
						  generic_bignum[l >> 1],
						  sizeof (LITTLENUM_TYPE));
			    }
d1417 1
a1417 2
		  if (j ||
		      exprP.X_add_symbol ||
d1435 4
d1472 3
a1474 4
		    /* Size is unknown until link time so have to
                       allow 4 bytes.  */
		    size = 4;
		    memP = frag_more(size);
d1484 1
a1484 1
		    break;		/* exit this absolute hack */
d1499 1
a1499 1
			memP = frag_more(4); /* Max size.  */
d1541 1
a1541 1
				as_warn (_("Displacement to large for :d"));
d1610 1
a1610 1
  if (index >= 0 && index < sizeof (relocs) / sizeof (relocs[0]))
d1644 1
d1646 1
d1739 1
a1739 1
	as_warn (_("Byte displacement out of range.  line number not valid"));
d1748 1
a1748 1
	as_warn (_("Word displacement out of range.  line number not valid"));
d1762 1
a1762 1
	as_warn (_("Double word displacement out of range"));
d1782 1
a1782 1
      as_fatal (_("Internal logic error.  line %s, file \"%s\""),
d1830 1
a1830 1
      as_fatal (_("Internal logic error. line %s, file \"%s\""),
d1869 7
a1875 7
     register char *buf;
     register long val;
     register bit_fixS *field_ptr;
{
  register unsigned long object;
  register unsigned long mask;
  /* define ENDIAN on a ns32k machine */
d1877 1
a1877 1
  register unsigned long *mem_ptr;
d1879 1
a1879 1
  register char *mem_ptr;
d1881 1
d1904 1
a1904 1
#else /* OVE Goof! the machine is a m68k or dito */
d1935 1
a1935 1
      as_warn (_("Bit field out of range"));
d1957 2
a1958 1
int
a1961 1
  fragS *fragP = fixP->fx_frag;
a1982 6
#ifdef BFD_ASSEMBLER
int
md_apply_fix (fixP, valp)
     fixS *fixP;
     valueT *valp;
#else
d1984 1
a1984 1
md_apply_fix (fixP, val)
d1986 2
a1987 2
     long val;
#endif
d1989 1
a1989 5
#ifdef BFD_ASSEMBLER
  long val = *valp;
#endif
  fragS *fragP = fixP->fx_frag;

d1993 2
a1994 1
    {				/* Bitfields to fix, sigh.  */
d1997 14
a2010 6
  else
    switch (fix_im_disp (fixP))
      {
      case 0:			/* Immediate field.  */
	md_number_to_imm (buf, val, fixP->fx_size);
	break;
d2012 5
a2016 8
      case 1:			/* Displacement field.  */
	/* Calculate offset */
	{
	  md_number_to_disp (buf,
			     (fixP->fx_pcrel ? val + md_fix_pcrel_adjust (fixP)
			      : val), fixP->fx_size);
	}
	break;
d2018 2
a2019 7
      case 2:			/* Pointer in a data object.  */
	md_number_to_chars (buf, val, fixP->fx_size);
	break;
      }
#ifdef BSD_ASSEMBLER
  return 1;
#endif
d2022 1
a2022 1
/* Convert a relaxed displacement to ditto in final output */
d2029 1
a2029 1
     register fragS *fragP;
d2033 3
a2035 3
     bfd *abfd;
     segT sec;
     register fragS *fragP;
a2039 1

d2041 1
a2041 1
  register char *buffer_address = fragP->fr_fix + fragP->fr_literal;
a2044 2
  fragS *opcode_frag;

a2066 3
#ifdef BFD_ASSEMBLER
  disp += symbol_get_frag (fragP->fr_symbol)->fr_address;
#endif
d2079 1
a2079 1
     register fragS *fragP;
d2096 1
a2096 1
			 frag_bsr(fragP), /*sequent hack */
d2127 2
a2128 2
     fragS *frag;
     symbolS *to_symbol;
d2141 2
a2142 2
     fragS *frag;
     symbolS *to_symbol;
d2151 1
a2151 1
CONST char *md_shortopts = "m:";
d2155 2
d2182 1
a2182 1
	  as_bad (_("invalid architecture option -m%s"), arg);
d2186 14
d2214 2
a2215 1
-m32032 | -m32532	select variant of NS32K architecture\n"));
d2225 6
a2230 6
     char size;			/* Length of bitfield		*/
     char offset;		/* Bit offset to bitfield	*/
     long min;			/* Signextended min for bitfield */
     long max;			/* Signextended max for bitfield */
     long add;			/* Add mask, used for huffman prefix */
     long base_type;		/* 0 or 1, if 1 it's exploded to opcode ptr */
d2233 1
a2233 1
  register bit_fixS *bit_fixP;
d2245 1
a2245 1
  return (bit_fixP);
d2256 7
a2262 7
     int pcrel;			/* TRUE if PC-relative relocation.  */
     char im_disp;		/* true if the value to write is a
				   displacement */
     bit_fixS *bit_fixP;	/* pointer at struct of bit_fix's, ignored if
				   NULL */
     char bsr;			/* sequent-linker-hack: 1 when relocobject is
				   a bsr */
d2280 2
d2291 7
a2297 7
     int pcrel;			/* TRUE if PC-relative relocation.  */
     char im_disp;		/* true if the value to write is a
				   displacement */
     bit_fixS *bit_fixP;	/* pointer at struct of bit_fix's, ignored if
				   NULL */
     char bsr;			/* sequent-linker-hack: 1 when relocobject is
				   a bsr */
d2314 2
d2335 1
a2335 1
     char *name;
d2344 1
a2344 1
     segT segment;
d2358 1
d2371 1
a2371 1
     asection *section;
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 1999
d23 1
a23 1
/*#define SHOW_NUM 1*//* uncomment for debugging */
d33 3
a35 3
/* Macros */
#define IIF_ENTRIES 13		/* number of entries in iif */
#define PRIVATE_SIZE 256	/* size of my garbage memory */
d39 1
a39 1
                                   encountered */
d66 2
a67 1
const char line_separator_chars[] = "";
d90 1
a90 2

char *freeptr, *freeptr_static;	/* points at some number of free bytes */
d93 1
a93 1
struct ns32k_opcode *desc;	/* pointer at description of instruction */
d96 2
a97 1
const char FLT_CHARS[] = "fd";	/* we don't want to support lowercase, do we */
d104 1
a104 1
 * it is converted to a FRAGment as specified in AS.H */
d106 1
a106 1
/* internal structs */
d108 5
a112 5
  {
    char *pattern;
    unsigned long or;
    unsigned long and;
  };
d134 1
a134 1
    int instr_size;		/* Max size of instruction in bytes. */
d137 1
d141 46
a186 47
/* description of the PARTs in IIF
 *object[n]:
 * 0	total length in bytes of entries in iif
 * 1	opcode
 * 2	index_byte_a
 * 3	index_byte_b
 * 4	disp_a_1
 * 5	disp_a_2
 * 6	disp_b_1
 * 7	disp_b_2
 * 8	imm_a
 * 9	imm_b
 * 10	implied1
 * 11	implied2
 *
 * For every entry there is a datalength in bytes. This is stored in size[n].
 *	 0,	the objectlength is not explicitly given by the instruction
 *		and the operand is undefined. This is a case for relaxation.
 *		Reserve 4 bytes for the final object.
 *
 *	 1,	the entry contains one byte
 *	 2,	the entry contains two bytes
 *	 3,	the entry contains three bytes
 *	 4,	the entry contains four bytes
 *	etc
 *
 * Furthermore, every entry has a data type identifier in type[n].
 *
 * 	 0,	the entry is void, ignore it.
 * 	 1,	the entry is a binary number.
 *	 2,	the entry is a pointer at an expression.
 *		Where expression may be as simple as a single '1',
 *		and as complicated as  foo-bar+12,
 * 		foo and bar may be undefined but suffixed by :{b|w|d} to
 *		control the length of the object.
 *
 *	 3,	the entry is a pointer at a bignum struct
 *
 *
 * The low-order-byte coresponds to low physical memory.
 * Obviously a FRAGment must be created for each valid disp in PART whose
 * datalength is undefined (to bad) .
 * The case where just the expression is undefined is less severe and is
 * handled by fix. Here the number of bytes in the objectfile is known.
 * With this representation we simplify the assembly and separates the
 * machine dependent/independent parts in a more clean way (said OE)
 */
d316 1
a316 1
{					/* so far empty */
d322 1
a322 1
/* those are index's to relax groups in md_relax_table ie it must be
d324 1
a324 1
   relax_segment in write.c for more info */
d329 1
a329 1
/* those are index's to entries in a relax group */
d342 1
a342 2
   had to be used.  Now we dont have to think about that. */

d358 1
a358 1
   Value is true if mode contains displacement. */
d366 1
a366 1
/* Array used to calculate max size of displacements */
d375 1
a375 1
/* Parses a general operand into an addressingmode struct
d377 5
a381 3
   in:  pointer at operand in ascii form
   pointer at addr_mode struct for result
   the level of recursion. (always 0 or 1)
a382 2
   out: data in addr_mode struct
   */
d394 1
d407 1
d409 2
a410 3
    {
      return (0);
    }				/* we don't want this */
d412 1
d415 2
a416 2
      /* the following three case statements controls the mode-chars
	 this is the place to ed if you want to change them */
d423 1
a423 1
      return (-1);
d431 1
a431 1
      return (-1);
d444 1
a444 1
		  return (-1);
d448 1
a448 1
	      return (0);
d477 1
a477 1
	      return (-1);
d481 3
a483 1
    default:;
d485 1
d487 1
d495 1
d500 1
a500 1
	      return (-1);
d502 3
d506 2
d512 1
a512 1
	  return (-1);
d514 4
a517 1
    default:;
d519 1
d527 6
a532 11
		{
		  mode = 16;		/* Memory Relative */
		}
	      if (!strncmp (&str[strl - 5], "(sp", 3))
		{
		  mode = 17;
		}
	      if (!strncmp (&str[strl - 5], "(sb", 3))
		{
		  mode = 18;
		}
d534 1
a534 1
		{			/* memory relative */
d536 1
a536 1
		  j = strl - 5;		/* temp for end of disp[0] */
d538 1
d548 1
d554 1
d557 4
a560 3
		  str[j] = '\000';	/* null terminate disp[0] */
		  str[strl] = '\000';	/* null terminate disp[1] */
		  return (-1);
d563 1
d575 1
a575 1
		  return (-1);		/* reg rel */
d577 2
d581 8
a588 15
		{
		  mode = 24;
		}
	      if (!strncmp (&str[strl - 4], "(sp", 3))
		{
		  mode = 25;
		}
	      if (!strncmp (&str[strl - 4], "(sb", 3))
		{
		  mode = 26;
		}
	      if (!strncmp (&str[strl - 4], "(pc", 3))
		{
		  mode = 27;
		}
d594 2
a595 1
		  return (-1);		/* memory space */
d599 2
a600 1
      /* no trailing ')' do we have a ']' ? */
d617 1
a617 1
	    default:;
d619 1
d623 25
a647 25
		{
		  as_warn (_("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"));
		}
	    } /* scaled index */
	  {
	    if (recursive_level > 0)
	      {
		as_warn (_("Scaled-indexed addressing mode combined with scaled-index"));
		return (0);
	      }
	    addr_modeP->am_size += 1;	/* scaled index byte */
	    j = str[strl - 4] - '0';	/* store temporary */
	    str[strl - 6] = '\000';	/* nullterminate for recursive call */
	    i = addr_mode (str, addr_modeP, 1);
	    if (!i || addr_modeP->mode == 20)
	      {
		as_warn (_("Invalid or illegal addressing mode combined with scaled-index"));
		return (0);
	      }
	    addr_modeP->scaled_mode = addr_modeP->mode;	/* store the inferior
							   mode */
	    addr_modeP->mode = mode;
	    addr_modeP->scaled_reg = j + 1;
	    return (-1);
	  }
d650 2
a651 1
  addr_modeP->mode = DEFAULT;	/* default to whatever */
d653 2
a654 1
  return (-1);
d662 1
d669 1
d671 1
d674 1
a674 1
      /* resolve ambigious operands, this shouldn't be necessary if
d677 3
a679 2
	 if it is implicitly stated. See ns32k-opcode.h */
      (void) evaluate_expr (&exprP, ptr); /* this call takes time Sigh! */
d683 1
a683 3
	    {
	      addr_modeP->mode = desc->default_model; /* we have a label */
	    }
d685 1
a685 3
	    {
	      addr_modeP->mode = desc->default_modec; /* we have a constant */
	    }
d690 1
a690 3
	    {
	      addr_modeP->scaled_mode = desc->default_model;
	    }
d692 1
a692 3
	    {
	      addr_modeP->scaled_mode = desc->default_modec;
	    }
d694 3
a696 2
      /* must put this mess down in addr_mode to handle the scaled
         case better */
d698 1
d705 3
a707 3
    {				/* build indexbyte */
      tmp--;			/* remember regnumber comes incremented for
				   flagpurpose */
d712 1
d714 68
a781 62
    {				/* there was a displacement, probe for length
				   specifying suffix */
      {
	register char c;
	register char suffix;
	register char suffix_sub;
	register int i;
	register char *toP;
	register char *fromP;

	addr_modeP->pcrel = 0;
	if (disp_test[addr_modeP->mode])
	  {			/* there is a displacement */
	    if (addr_modeP->mode == 27 || addr_modeP->scaled_mode == 27)
	      {			/* do we have pcrel. mode */
		addr_modeP->pcrel = 1;
	      }
	    addr_modeP->im_disp = 1;
	    for (i = 0; i < 2; i++)
	      {
		suffix_sub = suffix = 0;
		if (toP = addr_modeP->disp[i])
		  {		/* suffix of expression, the largest size
				   rules */
		    fromP = toP;
		    while (c = *fromP++)
		      {
			*toP++ = c;
			if (c == ':')
			  {
			    switch (*fromP)
			      {
			      case '\0':
				as_warn (_("Premature end of suffix -- Defaulting to d"));
				suffix = 4;
				continue;
			      case 'b':
				suffix_sub = 1;
				break;
			      case 'w':
				suffix_sub = 2;
				break;
			      case 'd':
				suffix_sub = 4;
				break;
			      default:
				as_warn (_("Bad suffix after ':' use {b|w|d} Defaulting to d"));
				suffix = 4;
			      }
			    fromP++;
			    toP--;	/* So we write over the ':' */
			    if (suffix < suffix_sub)
			      suffix = suffix_sub;
			  }
		      }
		    *toP = '\0';/* terminate properly */
		    addr_modeP->disp_suffix[i] = suffix;
		    addr_modeP->am_size += suffix ? suffix : 4;
		  }
	      }
	  }
      }
d786 2
a787 1
	{			/* look in ns32k_opcode for size */
d792 1
d796 1
a797 1
/* read an optionlist */
d800 3
a802 3
     char *str;			/* the string to extract options from */
     struct ns32k_option *optionP;	/* how to search the string */
     unsigned long *default_map;	/* default pattern and output */
d806 1
d808 1
d810 2
a811 3
    {
      as_fatal (_("Very short instr to option, ie you can't do it on a NULLstr"));
    }
d815 1
d820 1
d826 1
d836 1
a836 1
/* search struct for symbols
d839 1
a839 1
   list */
d843 3
a845 3
     char *str;				/* the string to match */
     struct ns32k_option *optionP;	/* list to search */
     unsigned long *default_map;	/* default pattern and output */
d848 1
d852 2
a853 1
	{				/* use strncmp to be safe */
d856 1
d860 1
d882 1
a882 2
   Be carefull not to put to objects in the same iif-slot.
   */
d896 1
d899 2
a900 2
      i = operandsP[loop << 1] - '1';	/* what operand are we supposed
					   to work on */
d903 1
d907 1
d923 5
a927 5
	  if((addr_modeP.mode == 20) &&
	     (d == 'I' || d == 'Z' || d == 'A')) {
	    as_fatal(d == 'A'? _("Address of immediate operand"):
		     _("Invalid immediate write operand."));
	  }
d933 1
d953 1
d956 1
d964 1
d1066 3
a1068 3
   Return-value = recursive_level
   */
/* build iif of one assembly text line */
d1078 2
a1079 1
  char suffix[MAX_ARGS], *argv[MAX_ARGS];	/* no more than 4 operands */
d1081 5
a1085 2
    {				/* called from md_assemble */
      for (lineptr = line; (*lineptr) != '\0' && (*lineptr) != ' '; lineptr++);
d1088 1
d1090 2
a1091 3
	{
	  as_fatal (_("No such opcode"));
	}
d1098 1
d1100 1
d1107 1
d1114 1
d1120 2
a1121 2
		    case 'H':	/* the operand is supposed to be a
				   displacement */
d1123 1
a1123 1
                         cases above when editing ns32k-opcode.h */
d1127 3
a1129 2
		      suffix_separator = '\255'; /* if this char occurs we
						    loose */
d1131 1
d1135 1
d1151 1
d1153 2
a1154 1
			{	/* ':' - label/suffix separator */
d1174 1
d1176 1
d1180 1
d1184 1
d1187 1
d1190 1
d1200 1
d1204 2
a1205 1
	{			/* we can apply default, dont goof */
d1207 2
a1208 3
	    {			/* check error in default */
	      as_fatal (_("Wrong numbers of operands in default, check ns32k-opcodes.h"));
	    }
d1214 1
a1215 1
    }
d1217 2
a1218 3
    {
      iif.iifP[i].type = 0;	/* mark all entries as void*/
    }
d1220 1
a1220 1
  /* build opcode iif-entry */
d1224 1
a1224 1
  /* this call encodes operands to iif format */
a1236 1

d1238 7
a1244 8
 * functions in other files than this one.(Except hash.c) So, if it's
 * possible to make an iif for an other CPU, you don't need to know
 * what frags, relax, obstacks, etc is in order to port this
 * assembler. You only need to know if it's possible to reduce your
 * cpu-instruction to iif-format (takes some work) and adopt the other
 * md_? parts according to given instructions Note that iif was
 * invented for the clean ns32k`s architecure.
 */
d1247 13
a1259 13
 * relative to the address of the opcode, not the address of the
 * operand. We used to keep track of the offset between the operand
 * and the opcode in pcrel_adjust for each frag and each fix. However,
 * we get into trouble where there are two or more pc-relative
 * operands and the size of the first one can't be determined. Then in
 * the relax phase, the size of the first operand will change and
 * pcrel_adjust will no longer be correct.  The current solution is
 * keep a pointer to the frag with the opcode in it and the offset in
 * that frag for each frag and each fix. Then, when needed, we can
 * always figure out how far it is between the opcode and the pcrel
 * object.  See also md_pcrel_adjust and md_fix_pcrel_adjust.  For
 * objects not part of an instruction, the pointer to the opcode frag
 * is always zero.  */
d1284 2
a1285 1
	{			/* the object exist, so handle it */
d1289 2
a1290 2
	      size = 0;		/* it's a bitfix that operates on an existing
				   object*/
d1292 4
a1295 3
		{		/* expand fx_bit_base to point at opcode */
		  iif.iifP[i].bit_fixP->fx_bit_base = (long) inst_opcode;
		}
d1300 2
a1301 1
	    case 4:		/* the final size in objectmemory is known */
d1304 1
d1307 1
a1307 1
		case 1:	/* the object is pure binary */
d1322 2
a1323 1
		    {		/* good, just put them bytes out */
d1337 1
d1339 1
a1339 1
		  /* the object is a pointer at an expression, so
d1341 1
a1341 1
                     expression */
d1347 2
a1348 2
			  /* we have a bignum ie a quad. This can only
                             happens in a long suffixed instruction */
d1351 1
d1354 1
d1363 2
a1364 1
			{	/* flonum */
d1404 1
a1404 1
                         the object later. */
d1418 1
a1418 1
		      /* good, just put them bytes out */
d1436 1
d1438 1
a1438 1
	      /* To bad, the object may be undefined as far as its
d1442 1
a1442 1
		 determined and a fix can replace the frag. */
d1445 1
d1450 1
a1450 1
                       allow 4 bytes. */
d1466 2
a1467 1
		  {			/* frag it */
d1469 2
a1470 1
		      {			/* We cant relax this case */
d1475 3
a1477 5

			/* Size is not important. This gets fixed by relax,
			 * but we assume 0 in what follows
			 */
			memP = frag_more(4); /* Max size */
d1483 4
a1486 3
					4, /* Max size */
					0, /* size */
					IND (BRANCH, UNDEF), /* expecting the worst */
d1490 3
a1492 3
			  frag_opcode_frag(old_frag) = inst_frag;
			  frag_opcode_offset(old_frag) = inst_offset;
			  frag_bsr(old_frag) = iif.iifP[i].bsr;
d1498 1
a1498 1
		    /* This duplicates code in md_number_to_disp */
d1512 2
a1513 2
			    if (-0x20000000<=exprP.X_add_number &&
				exprP.X_add_number<=0x1fffffff)
d1524 2
a1525 1
		    memP = frag_more(size);
d1530 1
d1539 1
a1539 1
/* This functionality should really be in the bfd library */
d1544 2
a1545 1
  bfd_reloc_code_real_type relocs[] = {
d1553 1
a1553 1
    /* ns32k displacements */
d1561 1
a1561 1
    /* Normal 2's complement */
d1568 2
a1569 1
    };
d1585 1
d1587 2
a1588 1
  if (index >= 0 && index < sizeof(relocs)/sizeof(relocs[0]))
d1590 1
d1597 1
a1600 1

d1608 2
a1609 2
  parse (line, 0);		/* explode line to more fix form in iif */
  convert_iif ();		/* convert iif to frags, fix's etc */
a1614 1

d1618 1
a1618 1
  /* build a hashtable of the instructions */
d1622 1
d1626 2
a1627 3
	{
	  as_fatal (_("Can't hash %s: %s"), ptr->name, stat);	/*fatal*/
	}
d1629 3
a1631 2
  freeptr_static = (char *) malloc (PRIVATE_SIZE); /* some private space
						      please! */
d1634 1
a1634 1
/* Must be equal to MAX_PRECISON in atof-ieee.c */
d1638 2
a1639 2
   of type type, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *sizeP .  An error message is
d1641 1
d1666 1
d1672 1
d1678 1
d1682 1
a1682 1
/* Convert number to chars in correct order */
a1692 1

d1704 1
d1811 2
a1812 3

/* fast bitfiddling support */
/* mask used to zero bitfield before oring in the true field */
d1841 1
a1841 2
   and a general version. (My advice: use the general version!)
   */
d1861 2
a1862 3
	{			/* override buf */
	  mem_ptr = (unsigned long *) field_ptr->fx_bit_base;
	}
d1864 2
a1865 3
	{
	  mem_ptr = (unsigned long *) buf;
	}
d1870 1
a1870 3
	{			/* override buf */
	  mem_ptr = (char *) field_ptr->fx_bit_base;
	}
d1872 2
a1873 3
	{
	  mem_ptr = buf;
	}
d1876 2
a1877 2
#ifdef ENDIAN			/* we have a nice ns32k machine with lowbyte
				   at low-physical mem */
d1880 1
a1880 1
      /* That takes more byte fiddling */
d1914 3
a1916 1
int md_pcrel_adjust (fragS *fragP)
d1921 2
a1922 1
  opcode_frag = frag_opcode_frag(fragP);
d1925 2
a1926 1
  offset = frag_opcode_offset(fragP);
d1928 1
d1932 3
a1934 1
int md_fix_pcrel_adjust (fixS *fixP)
d1940 2
a1941 1
  opcode_frag = fix_opcode_frag(fixP);
d1944 2
a1945 1
  offset = fix_opcode_offset(fixP);
d1947 1
d1977 3
a1979 3
  if (fix_bit_fixP(fixP))
    {				/* Bitfields to fix, sigh */
      md_number_to_field (buf, val, fix_bit_fixP(fixP));
d1982 1
a1982 1
    switch (fix_im_disp(fixP))
d1984 1
a1984 2

      case 0:			/* Immediate field */
d1988 1
a1988 1
      case 1:			/* Displacement field */
d1991 3
a1993 3
	md_number_to_disp (buf,
			   (fixP->fx_pcrel ? val + md_fix_pcrel_adjust(fixP)
			    : val), fixP->fx_size);
d1997 1
a1997 1
      case 2:			/* Pointer in a data object */
d2045 1
a2045 1
  if(ext == 0)
d2051 1
d2057 1
a2057 1
  disp += md_pcrel_adjust(fragP);
d2065 1
a2065 1
   actually know it */
d2072 1
a2072 3
  int old_fix;
  old_fix = fragP->fr_fix;
  switch (fragP->fr_subtype)
d2074 1
a2074 7
    case IND (BRANCH, UNDEF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
	{
	  /* the symbol has been assigned a value */
	  fragP->fr_subtype = IND (BRANCH, BYTE);
	}
      else
d2076 2
a2077 2
	  /* we don't relax symbols defined in an other segment the
	     thing to do is to assume the object will occupy 4 bytes */
d2087 2
a2088 2
			 frag_opcode_frag(fragP),
			 frag_opcode_offset(fragP));
d2090 3
a2092 1
	  /* fragP->fr_opcode[1]=0xff; */
d2094 1
a2094 1
	  break;
d2096 4
a2099 5
    case IND (BRANCH, BYTE):
      fragP->fr_var += 1;
      break;
    default:
      break;
d2101 6
a2106 1
  return fragP->fr_var + fragP->fr_fix - old_fix;
d2111 1
a2111 1
const int md_reloc_size = 8;	/* Size of relocation record */
d2142 3
a2144 1
struct option md_longopts[] = {
d2147 2
a2148 1
size_t md_longopts_size = sizeof(md_longopts);
d2186 1
a2186 1
  fprintf(stream, _("\
d2190 5
a2195 8

/*
 *			bit_fix_new()
 *
 * Create a bit_fixS in obstack 'notes'.
 * This struct is used to profile the normal fix. If the bit_fixP is a
 * valid pointer (not NULL) the bit_fix data will be used to format the fix.
 */
d2226 4
a2229 4
     int size;			/* 1, 2  or 4 usually. */
     symbolS *add_symbol;	/* X_add_symbol. */
     long offset;		/* X_add_number. */
     int pcrel;			/* TRUE if PC-relative relocation. */
a2237 1

d2242 1
a2242 1
			bit_fixP? NO_RELOC: reloc(size, pcrel, im_disp)
d2248 6
a2253 6
  fix_opcode_frag(fixP) = opcode_frag;
  fix_opcode_offset(fixP) = opcode_offset;
  fix_im_disp(fixP) = im_disp;
  fix_bsr(fixP) = bsr;
  fix_bit_fixP(fixP) = bit_fixP;
}				/* fix_new_ns32k() */
d2260 3
a2262 3
     int size;			/* 1, 2  or 4 usually. */
     expressionS *exp;		/* Expression. */
     int pcrel;			/* TRUE if PC-relative relocation. */
d2274 1
a2274 1
			    bit_fixP? NO_RELOC: reloc(size, pcrel, im_disp)
d2280 6
a2285 6
  fix_opcode_frag(fixP) = opcode_frag;
  fix_opcode_offset(fixP) = opcode_offset;
  fix_im_disp(fixP) = im_disp;
  fix_bsr(fixP) = bsr;
  fix_bit_fixP(fixP) = bit_fixP;
}				/* fix_new_ns32k() */
d2293 2
a2294 2
     int size;			/* 1, 2  or 4 usually. */
     expressionS *exp;		/* Expression. */
d2310 1
d2316 1
a2316 1
  return size;			/* Byte alignment is fine */
d2320 2
a2321 1
   ns32k, they're relative to the start of the instruction. */
d2329 2
a2330 2
  if (frag_bsr(fixP->fx_frag))
    res += 0x12			/* FOO Kludge alert! */
d2345 1
a2345 1
  code = reloc(fixp->fx_size, fixp->fx_pcrel, fix_im_disp(fixp));
d2379 2
a2380 4
  /*
   * In: length of relocation (or of address) in chars: 1, 2 or 4.
   * Out: GNU LD relocation length code: 0, 1, or 2.
   */
d2382 1
a2382 1
  static unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
d2400 2
a2401 2
		       | (long) (fix_bsr(fixP) << 28)
		       | (long) (fix_im_disp(fixP) << 29)),
a2406 2

/* end of tc-ns32k.c */
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d2 2
a3 1
   Copyright (C) 1987, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d36 15
a50 13
#define DEFAULT	-1		/* addr_mode returns this value when plain constant or label is encountered */

#define IIF(ptr,a1,c1,e1,g1,i1,k1,m1,o1,q1,s1,u1) \
    iif.iifP[ptr].type= a1; \
    iif.iifP[ptr].size= c1; \
    iif.iifP[ptr].object= e1; \
    iif.iifP[ptr].object_adjust= g1; \
    iif.iifP[ptr].pcrel= i1; \
    iif.iifP[ptr].pcrel_adjust= k1; \
    iif.iifP[ptr].im_disp= m1; \
    iif.iifP[ptr].relax_substate= o1; \
    iif.iifP[ptr].bit_fixP= q1; \
    iif.iifP[ptr].addr_mode= s1; \
d75 4
a78 2
    char float_flag;		/* set if R0..R7 was F0..F7 ie a floating-point-register */
    char am_size;		/* estimated max size of general addr-mode parts*/
d97 6
a102 6
/* UPPERCASE denotes live names
 * when an instruction is built, IIF is used as an intermidiate form to store
 * the actual parts of the instruction. A ns32k machine instruction can
 * be divided into a couple of sub PARTs. When an instruction is assembled
 * the appropriate PART get an assignment. When an IIF has been completed it's
 * converted to a FRAGment as specified in AS.H */
d125 2
a126 1
    int addr_mode;		/* What addrmode do we associate with this iif-entry */
d128 1
a128 3
  }

iif_entryT;			/* Internal Instruction Format */
d314 1
a314 1
{				/* so far empty */
d320 3
a322 3
/* those are index's to relax groups in md_relax_table
   ie it must be multiplied by 4 to point at a group start. Viz IND(x,y)
   Se function relax_segment in write.c for more info */
d334 7
a340 7
   The ns32k uses the begining of the instruction as displacement base.
   This type of displacements could be handled here by moving the limit window
   up or down. I choose to use an internal displacement base-adjust as there
   are other routines that must consider this. Also, as we have two various
   offset-adjusts in the ns32k (acb versus br/brs/jsr/bcond), two set of limits
   would have had to be used.
   Now we dont have to think about that. */
d413 1
a413 1
		   this is the place to ed if you want to change them */
d444 1
a444 1
	      as_warn ("Invalid syntax in PC-relative addressing mode");
d453 1
a453 1
	    {			/* external */
d458 1
a458 1
		{		/* disp[0]'s termination point */
d468 1
a468 1
		  as_warn ("Invalid syntax in External addressing mode");
d471 1
a471 1
	      str[j] = '\000';	/* null terminate disp[0] */
d498 1
a498 1
	  addr_modeP->mode = 23;/* TopOfStack */
d511 1
a511 1
		  mode = 16;	/* Memory Relative */
d522 1
a522 1
		{		/* memory relative */
d524 1
a524 1
		  j = strl - 5;	/* temp for end of disp[0] */
d537 1
a537 1
		      as_warn ("Invalid syntax in Memory Relative addressing mode");
d551 3
a553 1
	      if (str[strl - 2] >= '0' && str[strl - 2] < '8' && str[strl - 4] == '(')
d558 1
a558 1
		  return (-1);	/* reg rel */
d582 1
a582 1
		  return (-1);	/* memory space */
d604 4
a607 3
	      as_warn ("Invalid scaled-indexed mode, use (b,w,d,q)");
	      if (str[strl - 3] != ':' || str[strl - 6] != '[' ||
		  str[strl - 5] == 'r' || str[strl - 4] < '0' || str[strl - 4] > '7')
d609 1
a609 1
		  as_warn ("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}");
d611 1
a611 1
	    }			/* scaled index */
d615 1
a615 1
		as_warn ("Scaled-indexed addressing mode combined with scaled-index");
d624 1
a624 1
		as_warn ("Invalid or illegal addressing mode combined with scaled-index");
d627 2
a628 1
	    addr_modeP->scaled_mode = addr_modeP->mode;	/* store the inferior mode */
d640 5
a644 7
/* ptr points at string
   addr_modeP points at struct with result
   This routine calls addr_mode to determine the general addr.mode of
   the operand. When this is ready it parses the displacements for size
   specifying suffixes and determines size of immediate mode via ns32k-opcode.
   Also builds index bytes if needed.
   */
d654 5
a658 6
      /* resolve ambigious operands, this shouldn't
	 be necessary if one uses standard NSC operand
	 syntax. But the sequent compiler doesn't!!!
	 This finds a proper addressinging mode if it
	 is implicitly stated. See ns32k-opcode.h */
      (void) evaluate_expr (&exprP, ptr);	/* this call takes time Sigh! */
d663 1
a663 1
	      addr_modeP->mode = desc->default_model;	/* we have a label */
d667 1
a667 1
	      addr_modeP->mode = desc->default_modec;	/* we have a constant */
d681 2
a682 1
      /* must put this mess down in addr_mode to handle the scaled case better */
d684 5
a688 6
  /* It appears as the sequent compiler wants an absolute when we have a
	   label without @@. Constants becomes immediates besides the addr case.
	   Think it does so with local labels too, not optimum, pcrel is better.
	   When I have time I will make gas check this and select pcrel when possible
	   Actually that is trivial.
	   */
d691 2
a692 1
      tmp--;			/* remember regnumber comes incremented for flagpurpose */
d698 2
a699 1
    {				/* there was a displacement, probe for length specifying suffix*/
d720 2
a721 1
		  {		/* suffix of expression, the largest size rules */
d731 1
a731 1
				as_warn ("Premature end of suffix--Defaulting to d");
d744 1
a744 1
				as_warn ("Bad suffix after ':' use {b|w|d} Defaulting to d");
d778 1
a778 1
     unsigned long *default_map;/* default pattern and output */
d785 1
a785 1
      as_fatal ("Very short instr to option, ie you can't do it on a NULLstr");
d809 3
a811 3
   This function is used to get the short integer form of reg names
   in the instructions lmr, smr, lpr, spr
   return true if str is found in list */
d815 1
a815 1
     char *str;			/* the string to match */
d817 1
a817 1
     unsigned long *default_map;/* default pattern and output */
d823 1
a823 1
	{			/* use strncmp to be safe */
d829 1
a829 1
  as_warn ("No such entry in list. (cpu/mmu register)");
d867 2
a868 1
      i = operandsP[loop << 1] - '1';	/* what operand are we supposed to work on */
d870 1
a870 1
	as_fatal ("Internal consistency error.  check ns32k-opcode.h");
d876 2
a877 1
	case 'f':		/* operand of sfsr turns out to be a nasty specialcase */
d886 2
a887 1
	case 'A':		/* double-word	gen-address-form ie no regs allowed */
d891 2
a892 2
	    as_fatal(d == 'A'? "Address of immediate operand":
		     "Invalid immediate write operand.");
d894 1
a894 1
	  iif.instr_size += addr_modeP.am_size;
d909 1
a909 1
		       iif.instr_size - addr_modeP.am_size,	/* this aint used (now) */
d913 2
a914 1
		       addr_modeP.scaled_reg ? addr_modeP.scaled_mode : addr_modeP.mode,
d923 2
a924 1
	      IIF (j, 1, 1, (unsigned long) addr_modeP.index_byte, 0, 0, 0, 0, 0, NULL, -1, 0);
d931 2
a932 1
	  pcrel -= 1;		/* make pcrel 0 inspite of what case 'p': wants */
d942 2
a943 1
	case 'H':		/* sequent-hack: the linker wants a bit set when bsr */
d967 1
a967 1
	  iif.iifP[1].object |= tmp << 15;	/*insert the regtype in opcode */
d1003 2
a1004 1
	       bit_fix_new (3, 5, 0, 7, 0, 0, 0),	/* a bit_fix is targeted to the byte */
d1019 1
a1019 1
	  as_fatal ("Bad opcode-table-option, check in file ns32k-opcode.h");
d1048 1
a1048 1
	  as_fatal ("No such opcode");
d1074 4
a1077 2
		    case 'H':	/* the operand is supposed to be a displacement */
		      /* Hackwarning: do not forget to update the 4 cases above when editing ns32k-opcode.h */
d1081 2
a1082 1
		      suffix_separator = '\255';	/* if this char occurs we loose */
d1084 1
a1084 1
		  suffix[argc] = 0;	/* 0 when no ':' is encountered */
d1116 1
a1116 1
			      as_warn ("Bad suffix, defaulting to d");
d1138 1
a1138 1
		  as_fatal ("Too many operands passed to instruction");
d1149 1
a1149 1
	      as_fatal ("Wrong numbers of operands in default, check ns32k-opcodes.h");
d1154 1
a1154 1
	  as_fatal ("Wrong number of operands");
d1189 1
a1189 1
   */
d1191 14
a1204 23
/* GAS for the ns32k has a problem. PC relative displacements are relative
 * to the address of the opcode, not the address of the operand. We can
 * keep track of the offset between the operand and the opcode in
 * pcrel_adjust. That is what it is for. However, we get into trouble
 * where there is two or more pc-relative operands and the size of the
 * first one can't be determined. Then in the relax phase, the size of the
 * first operand will change and pcrel_adjust will no longer be correct.
 * In an earlier attempt to fix this, I added an extra field to frags to
 * keep track of how much the pcrel_adjust had changed during relax.
 * That meant cluttering up write.c with (more) ns32k dependent things.
 * The current solution is to note that operands whose size isn't determined
 * yet must be in the variable part of a frag. The next operand (if any)]
 * must be in a new frag. What we need is a way to find out where in what
 * frag the opcode for this operand is.
 * What we do is allocate and extra structure and for frags which do not
 * contain the opcode, use the opcode pointer to point at this new
 * structure. Requires that a pointer to a struct can be cast to a pointer
 * to char * without loss.
 */
struct opcode_location {
  fragS *fragP;
  unsigned int offset;
};
a1213 2
  struct opcode_location *opcode_location;
  fragS *opcode_frag;
a1216 1
  int rem_size;			/* count the remaining bytes of instruction */
d1219 1
a1219 4
  int size_so_far = 0;		/* used to calculate pcrel_adjust */
  char first = 1;		/* true until after the first frag of this
 				 * instruction has been done
 				 */
d1221 1
a1221 2
  rem_size = iif.instr_size;
  memP = frag_more (iif.instr_size);	/* make sure we have enough bytes for instruction */
d1233 2
a1234 1
	      size = 0;		/* it's a bitfix that operates on an existing object*/
a1239 1
	      memset (memP, '\0', size);
d1244 1
a1256 1
				     (char) (first? size_so_far: 0),	/*iif.iifP[i].pcrel_adjust,*/
d1259 2
a1260 1
				     iif.iifP[i].bsr);	/* sequent hack */
d1273 1
a1273 1
			  as_fatal ("iif convert internal pcrel/binary");
a1275 2
		  memP += size;
		  rem_size -= size;
d1277 4
a1280 3
		case 2:	/* the object is a pointer at an expression, so unpack
					   it, note that bignums may result from the expression
					   */
d1285 3
a1287 3
			{	/* we have a bignum ie a quad */
			  /* this can only happens in a long suffixed instruction */
			  memset (memP, '\0', size);	/* size normally is 8 */
d1289 1
a1289 1
			    as_warn ("Bignum too big for long");
d1294 3
a1296 1
			      md_number_to_chars (memP + l, generic_bignum[l >> 1], sizeof (LITTLENUM_TYPE));
d1307 5
a1311 2
			      md_number_to_imm (memP, (long) words[0], sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + sizeof (LITTLENUM_TYPE), (long) words[1], sizeof (LITTLENUM_TYPE));
d1315 13
a1327 4
			      md_number_to_imm (memP, (long) words[0], sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + sizeof (LITTLENUM_TYPE), (long) words[1], sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + 2 * sizeof (LITTLENUM_TYPE), (long) words[2], sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + 3 * sizeof (LITTLENUM_TYPE), (long) words[3], sizeof (LITTLENUM_TYPE));
a1330 2
		      memP += size;
		      rem_size -= size;
d1337 4
a1340 3
		    {		/* fixit */
		      /* the expression was undefined due to an undefined label */
		      /* create a fix so we can fix the object later */
a1346 1
					 (char) (first? size_so_far: 0),	/*iif.iifP[i].pcrel_adjust,*/
d1349 2
a1350 2
					 iif.iifP[i].bsr);	/* sequent hack */

d1353 2
a1354 1
		    {		/* good, just put them bytes out */
d1364 1
a1364 1
			  as_fatal ("iif convert internal pcrel/pointer");
a1366 2
		  memP += size;
		  rem_size -= size;
d1369 1
a1369 1
		  as_fatal ("Internal logic error in iif.iifP[n].type");
d1372 6
a1377 7
	    case 0: /* To bad, the object may be undefined as far as
		     * its final nsize in object memory is concerned.
		     * The size of the object in objectmemory is not
		     * explicitly given.  If the object is defined its
		     * length can be determined and a fix can replace
		     * the frag.
					    */
a1378 1
		int temp;
d1382 5
a1386 2
		  {		/* OVE: hack, clamp to 4 bytes */
		    size = 4;	/* we dont wan't to frag this, use 4 so it reaches */
d1391 6
a1396 7
				       0,	/* never iif.iifP[i].pcrel, */
				       (char) (first? size_so_far: 0),	/*iif.iifP[i].pcrel_adjust,*/
				       1,	/* always iif.iifP[i].im_disp, */
				       (bit_fixS *) 0, 0);
		    memP += size;
		    rem_size -= 4;
		    break;	/* exit this absolute hack */
d1400 1
a1400 1
		  {		/* frag it */
d1402 2
a1403 2
		      {		/* We cant relax this case */
			as_fatal ("Can't relax difference");
a1407 11
			/* at this stage we must undo some of the
			 * effect caused by frag_more, ie we must make
			 * sure that frag_var causes frag_new to creat
			 * a valid fix-size in the frag it`s closing
			 * * we rewind none, some or all of the
			 * requested size we requested by the first
			 * frag_more for this iif chunk.  Note: that
			 * we allocate 4 bytes to an object we NOT YET
			 * know the size of, thus rem_size-4.
							   */

d1411 1
a1413 3
			temp = -(rem_size - 4);
			frag_grow (temp);

d1417 1
a1417 1
					4,
d1422 4
a1425 6
					(first
					 ? inst_opcode
					 : (char *) opcode_location));
			  if (first)
			    old_frag->fr_pcrel_adjust = (char) size_so_far;
			  old_frag->fr_bsr = iif.iifP[i].bsr;
a1426 18

			if (first) {
			  /* The opcode is really in the last frag.
			   * overload the inst_opcode pointer.
			   */
			  opcode_location
			    = (struct opcode_location *) obstack_alloc(&notes, sizeof(struct opcode_location));
			  opcode_location->fragP = inst_frag;
			  opcode_location->offset = inst_offset;

			  first = 0;
			}

			rem_size -= 4;
			if (rem_size > 0)
			  {
			    memP = frag_more (rem_size);
			  }
d1430 2
a1431 3
		  {		/* Double work, this is done in md_number_to_disp */
		    /*	      exprP.X_add_number; what was this supposed to be?
							      xoxorich. */
d1438 2
a1439 1
			if (-8192 <= exprP.X_add_number && exprP.X_add_number <= 8191)
d1452 1
a1452 1
				as_warn ("Displacement to large for :d");
d1457 1
a1457 2
		    /* rewind the bytes not used */
		    temp = -(4 - size);
a1458 3
		    frag_grow (temp);
		    memP += size;
		    rem_size -= 4;	/* we allocated this amount */
d1463 1
a1463 1
	      as_fatal ("Internal logic error in iif.iifP[].type");
a1464 2
	  size_so_far += size;
	  size = 0;
d1517 6
a1522 2
  as_bad ("Can not do %d byte %s relocation for storage type %d", size,
	  pcrel ? "pc-relative" : "", type);
d1553 1
a1553 1
	  as_fatal ("Can't hash %s: %s", ptr->name, stat);	/*fatal*/
d1556 2
a1557 1
  freeptr_static = (char *) malloc (PRIVATE_SIZE);	/* some private space please! */
d1563 4
a1566 4
/* Turn the string pointed to by litP into a floating point constant of type
   type, and emit the appropriate bytes.  The number of LITTLENUMS emitted
   is stored in *sizeP .  An error message is returned, or NULL on OK.
   */
d1589 1
a1589 1
      return "Bad call to MD_ATOF()";
d1616 4
a1619 4
/* This is a variant of md_numbers_to_chars. The reason for its' existence
   is the fact that ns32k uses Huffman coded displacements. This implies
   that the bit order is reversed in displacements and that they are prefixed
   with a size-tag.
d1626 1
a1626 2
   This must be taken care of and we do it here!
   */
d1637 1
a1637 1
	as_warn ("Byte displacement out of range.  line number not valid");
d1646 1
a1646 1
	as_warn ("Word displacement out of range.  line number not valid");
d1660 1
a1660 1
	as_warn ("Double word displacement out of range");
d1680 2
a1681 1
      as_fatal ("Internal logic error.  line %s, file \"%s\"", __LINE__, __FILE__);
d1728 2
a1729 1
      as_fatal ("Internal logic error. line %s, file \"%s\"", __LINE__, __FILE__);
a1732 33
/* Translate internal representation of relocation info into target format.

   OVE: on a ns32k the twiddling continues at an even deeper level
   here we have to distinguish between displacements and immediates.

   The sequent has a bit for this. It also has a bit for relocobjects that
   points at the target for a bsr (BranchSubRoutine) !?!?!?!

   This md_ri.... is tailored for sequent.
   */

#ifdef comment
void
md_ri_to_chars (the_bytes, ri)
     char *the_bytes;
     struct reloc_info_generic *ri;
{
  if (ri->r_bsr)
    {
      ri->r_pcrel = 0;
    }				/* sequent seems to want this */
  md_number_to_chars (the_bytes, ri->r_address, sizeof (ri->r_address));
  md_number_to_chars (the_bytes + 4, ((long) (ri->r_symbolnum)
				      | (long) (ri->r_pcrel << 24)
				      | (long) (ri->r_length << 25)
				      | (long) (ri->r_extern << 27)
				      | (long) (ri->r_bsr << 28)
				      | (long) (ri->r_disp << 29)),
		      4);
  /* the first and second md_number_to_chars never overlaps (32bit cpu case) */
}

#endif /* comment */
d1805 2
a1806 1
#ifdef ENDIAN			/* we have a nice ns32k machine with lowbyte at low-physical mem */
d1839 1
a1839 1
      as_warn ("Bit field out of range");
d1846 8
a1853 13
  int ret;
  int st = fragP->fr_subtype;
  unsigned int opcode_address;
  if ((st >> 2) == BRANCH && fragP->fr_pcrel_adjust == 0) {
    unsigned int offset;
    opcode_frag = ((struct opcode_location *) fragP->fr_opcode)->fragP;
    offset = ((struct opcode_location *) fragP->fr_opcode)->offset;
    opcode_address = offset + opcode_frag->fr_address;
    ret = fragP->fr_address - opcode_address;
  }
  else
    ret = fragP->fr_pcrel_adjust;
  return ret;
d1860 8
a1867 13
  int ret;
  int st = fragP->fr_subtype;
  unsigned int opcode_address;
  if (fixP->fx_pcrel && fixP->fx_pcrel_adjust == 0) {
    unsigned int offset;
    opcode_frag = ((struct opcode_location *) fragP->fr_opcode)->fragP;
    offset = ((struct opcode_location *) fragP->fr_opcode)->offset;
    opcode_address = offset + opcode_frag->fr_address;
    ret = fragP->fr_address - opcode_address;
  }
  else
    ret = fixP->fx_pcrel_adjust;
  return ret;
d1896 1
a1896 1
  if (fixP->fx_bit_fixP)
d1898 1
a1898 1
      md_number_to_field (buf, val, fixP->fx_bit_fixP);
d1901 1
a1901 1
    switch (fixP->fx_im_disp)
d1912 2
a1913 2
			     fixP->fx_pcrel ? val + md_fix_pcrel_adjust(fixP): val,
			   fixP->fx_size);
d1974 1
a1974 1
  disp += fragP->fr_symbol->sy_frag->fr_address;
d1978 2
a1979 2
      md_number_to_disp (buffer_address, (long) disp, (int) ext);
      fragP->fr_fix += ext;
d2003 2
a2004 2
	  /* we don't relax symbols defined in an other segment
		       the thing to do is to assume the object will occupy 4 bytes */
a2010 1
			 fragP->fr_pcrel_adjust,
d2013 3
a2015 1
			 fragP->fr_bsr);	/*sequent hack */
d2088 1
a2088 1
	  as_bad ("invalid architecture option -m%s", arg);
d2104 1
a2104 1
  fprintf(stream, "\
d2106 1
a2106 1
-m32032 | -m32532	select variant of NS32K architecture\n");
d2144 1
a2144 1
	       pcrel_adjust, im_disp, bit_fixP, bsr)
d2151 8
a2158 4
     char pcrel_adjust;		/* not zero if adjustment of pcrel offset is needed */
     char im_disp;		/* true if the value to write is a displacement */
     bit_fixS *bit_fixP;	/* pointer at struct of bit_fix's, ignored if NULL */
     char bsr;			/* sequent-linker-hack: 1 when relocobject is a bsr */
d2170 5
a2174 4
  fixP->fx_pcrel_adjust = pcrel_adjust;
  fixP->fx_im_disp = im_disp;
  fixP->fx_bit_fixP = bit_fixP;
  fixP->fx_bsr = bsr;
d2179 1
a2179 1
		   pcrel_adjust, im_disp, bit_fixP, bsr)
d2185 8
a2192 4
     char pcrel_adjust;		/* not zero if adjustment of pcrel offset is needed */
     char im_disp;		/* true if the value to write is a displacement */
     bit_fixS *bit_fixP;	/* pointer at struct of bit_fix's, ignored if NULL */
     char bsr;			/* sequent-linker-hack: 1 when relocobject is a bsr */
d2202 5
a2206 4
  fixP->fx_pcrel_adjust = pcrel_adjust;
  fixP->fx_im_disp = im_disp;
  fixP->fx_bit_fixP = bit_fixP;
  fixP->fx_bsr = bsr;
d2219 1
a2219 1
		     0, 0, 2, 0, 0);
d2240 2
a2241 4
/* Exactly what point is a PC-relative offset relative TO?
   On the National warts, they're relative to the address of the offset,
   with some funny adjustments in some circumstances during blue moons.
   (??? Is this right?  FIXME-SOON) */
d2249 1
a2249 1
  if (fixP->fx_frag->fr_bsr)
d2265 1
a2265 1
  code = reloc(fixp->fx_size, fixp->fx_pcrel, fixp->fx_im_disp);
d2267 3
a2269 3
  rel = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
  assert (rel != 0);
  rel->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d2283 2
a2284 2
	name = "<unknown>";
      as_fatal ("Cannot find relocation type for symbol %s, code %d",
d2294 1
a2294 1
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
d2322 2
a2323 2
		       | (long) (fixP->fx_bsr << 28)
		       | (long) (fixP->fx_im_disp << 29)),
a2328 5
/*
 * Local Variables:
 * comment-column: 0
 * End:
 */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1992, 1993 Free Software Foundation, Inc.
d1410 1
a1410 1
			obstack_blank_fast (&frags, temp);
d1478 1
a1478 1
		    obstack_blank_fast (&frags, temp);
d1843 2
d1854 1
a1855 1
      mem_ptr += field_ptr->fx_bit_base_adj;
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d1410 1
a1410 1
			frag_grow (temp);
d1478 1
a1478 1
		    frag_grow (temp);
a1842 2
      mem_ptr = ((unsigned long *)
		 ((char *) mem_ptr + field_ptr->fx_bit_base_adj));
d1852 1
a1853 1
#endif
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d1424 2
a1425 2
			    old_frag->fr_targ.ns32k.pcrel_adjust = (char) size_so_far;
			  old_frag->fr_targ.ns32k.bsr = iif.iifP[i].bsr;
d1899 1
a1899 1
  if ((st >> 2) == BRANCH && fragP->fr_targ.ns32k.pcrel_adjust == 0) {
d1907 1
a1907 1
    ret = fragP->fr_targ.ns32k.pcrel_adjust;
d2071 1
a2071 1
			 fragP->fr_targ.ns32k.pcrel_adjust,
d2074 1
a2074 1
			 fragP->fr_targ.ns32k.bsr);	/*sequent hack */
d2300 1
a2300 1
  if (fixP->fx_frag->fr_targ.ns32k.bsr)
d2318 2
a2319 1
  rel = (arelent *) xmalloc (sizeof (arelent));
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d34 13
a46 15
#define DEFAULT	-1		/* addr_mode returns this value when
                                   plain constant or label is
                                   encountered */

#define IIF(ptr,a1,c1,e1,g1,i1,k1,m1,o1,q1,s1,u1)	\
    iif.iifP[ptr].type= a1;				\
    iif.iifP[ptr].size= c1;				\
    iif.iifP[ptr].object= e1;				\
    iif.iifP[ptr].object_adjust= g1;			\
    iif.iifP[ptr].pcrel= i1;				\
    iif.iifP[ptr].pcrel_adjust= k1;			\
    iif.iifP[ptr].im_disp= m1;				\
    iif.iifP[ptr].relax_substate= o1;			\
    iif.iifP[ptr].bit_fixP= q1;				\
    iif.iifP[ptr].addr_mode= s1;			\
d71 2
a72 4
    char float_flag;		/* set if R0..R7 was F0..F7 ie a
				   floating-point-register */
    char am_size;		/* estimated max size of general addr-mode
				   parts */
d91 6
a96 6
/* UPPERCASE denotes live names when an instruction is built, IIF is
 * used as an intermediate form to store the actual parts of the
 * instruction. A ns32k machine instruction can be divided into a
 * couple of sub PARTs. When an instruction is assembled the
 * appropriate PART get an assignment. When an IIF has been completed
 * it is converted to a FRAGment as specified in AS.H */
d119 1
a119 2
    int addr_mode;		/* What addrmode do we associate with this
				   iif-entry */
d121 3
a123 1
  } iif_entryT;			/* Internal Instruction Format */
d309 1
a309 1
{					/* so far empty */
d315 3
a317 3
/* those are index's to relax groups in md_relax_table ie it must be
   multiplied by 4 to point at a group start. Viz IND(x,y) Se function
   relax_segment in write.c for more info */
d329 7
a335 7
   The ns32k uses the begining of the instruction as displacement
   base.  This type of displacements could be handled here by moving
   the limit window up or down. I choose to use an internal
   displacement base-adjust as there are other routines that must
   consider this. Also, as we have two various offset-adjusts in the
   ns32k (acb versus br/brs/jsr/bcond), two set of limits would have
   had to be used.  Now we dont have to think about that. */
d408 1
a408 1
	 this is the place to ed if you want to change them */
d439 1
a439 1
	      as_warn (_("Invalid syntax in PC-relative addressing mode"));
d448 1
a448 1
	    {				/* external */
d453 1
a453 1
		{			/* disp[0]'s termination point */
d463 1
a463 1
		  as_warn (_("Invalid syntax in External addressing mode"));
d466 1
a466 1
	      str[j] = '\000';		/* null terminate disp[0] */
d493 1
a493 1
	  addr_modeP->mode = 23;	/* TopOfStack */
d506 1
a506 1
		  mode = 16;		/* Memory Relative */
d517 1
a517 1
		{			/* memory relative */
d519 1
a519 1
		  j = strl - 5;		/* temp for end of disp[0] */
d532 1
a532 1
		      as_warn (_("Invalid syntax in Memory Relative addressing mode"));
d546 1
a546 3
	      if (str[strl - 2] >= '0'
		  && str[strl - 2] < '8'
		  && str[strl - 4] == '(')
d551 1
a551 1
		  return (-1);		/* reg rel */
d575 1
a575 1
		  return (-1);		/* memory space */
d597 3
a599 4
	      as_warn (_("Invalid scaled-indexed mode, use (b,w,d,q)"));
	      if (str[strl - 3] != ':' || str[strl - 6] != '['
		  || str[strl - 5] == 'r' || str[strl - 4] < '0'
		  || str[strl - 4] > '7')
d601 1
a601 1
		  as_warn (_("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"));
d603 1
a603 1
	    } /* scaled index */
d607 1
a607 1
		as_warn (_("Scaled-indexed addressing mode combined with scaled-index"));
d616 1
a616 1
		as_warn (_("Invalid or illegal addressing mode combined with scaled-index"));
d619 1
a619 2
	    addr_modeP->scaled_mode = addr_modeP->mode;	/* store the inferior
							   mode */
d631 7
a637 5
/* ptr points at string addr_modeP points at struct with result This
   routine calls addr_mode to determine the general addr.mode of the
   operand. When this is ready it parses the displacements for size
   specifying suffixes and determines size of immediate mode via
   ns32k-opcode.  Also builds index bytes if needed.  */
d647 6
a652 5
      /* resolve ambigious operands, this shouldn't be necessary if
	 one uses standard NSC operand syntax. But the sequent
	 compiler doesn't!!!  This finds a proper addressinging mode
	 if it is implicitly stated. See ns32k-opcode.h */
      (void) evaluate_expr (&exprP, ptr); /* this call takes time Sigh! */
d657 1
a657 1
	      addr_modeP->mode = desc->default_model; /* we have a label */
d661 1
a661 1
	      addr_modeP->mode = desc->default_modec; /* we have a constant */
d675 1
a675 2
      /* must put this mess down in addr_mode to handle the scaled
         case better */
d677 6
a682 5
  /* It appears as the sequent compiler wants an absolute when we have
     a label without @@. Constants becomes immediates besides the addr
     case.  Think it does so with local labels too, not optimum, pcrel
     is better.  When I have time I will make gas check this and
     select pcrel when possible Actually that is trivial.  */
d685 1
a685 2
      tmp--;			/* remember regnumber comes incremented for
				   flagpurpose */
d691 1
a691 2
    {				/* there was a displacement, probe for length
				   specifying suffix */
d712 1
a712 2
		  {		/* suffix of expression, the largest size
				   rules */
d722 1
a722 1
				as_warn (_("Premature end of suffix -- Defaulting to d"));
d735 1
a735 1
				as_warn (_("Bad suffix after ':' use {b|w|d} Defaulting to d"));
d769 1
a769 1
     unsigned long *default_map;	/* default pattern and output */
d776 1
a776 1
      as_fatal (_("Very short instr to option, ie you can't do it on a NULLstr"));
d800 3
a802 3
   This function is used to get the short integer form of reg names in
   the instructions lmr, smr, lpr, spr return true if str is found in
   list */
d806 1
a806 1
     char *str;				/* the string to match */
d808 1
a808 1
     unsigned long *default_map;	/* default pattern and output */
d814 1
a814 1
	{				/* use strncmp to be safe */
d820 1
a820 1
  as_warn (_("No such entry in list. (cpu/mmu register)"));
d858 1
a858 2
      i = operandsP[loop << 1] - '1';	/* what operand are we supposed
					   to work on */
d860 1
a860 1
	as_fatal (_("Internal consistency error.  check ns32k-opcode.h"));
d866 1
a866 2
	case 'f':		/* operand of sfsr turns out to be a nasty
				   specialcase */
d875 1
a875 2
	case 'A':		/* double-word	gen-address-form ie no regs
				   allowed */
d879 2
a880 2
	    as_fatal(d == 'A'? _("Address of immediate operand"):
		     _("Invalid immediate write operand."));
d882 1
a882 1

d897 1
a897 1
		       iif.instr_size,
d901 1
a901 2
		       (addr_modeP.scaled_reg ? addr_modeP.scaled_mode
			: addr_modeP.mode),
d910 1
a910 2
	      IIF (j, 1, 1, (unsigned long) addr_modeP.index_byte,
		   0, 0, 0, 0, 0, NULL, -1, 0);
d917 1
a917 2
	  pcrel -= 1;		/* make pcrel 0 inspite of what case 'p':
				   wants */
d927 1
a927 2
	case 'H':		/* sequent-hack: the linker wants a bit set
				   when bsr */
d951 1
a951 1
	  iif.iifP[1].object |= tmp << 15; /* insert the regtype in opcode */
d987 1
a987 2
	       bit_fix_new (3, 5, 0, 7, 0, 0, 0), /* a bit_fix is targeted to
						     the byte */
d1002 1
a1002 1
	  as_fatal (_("Bad opcode-table-option, check in file ns32k-opcode.h"));
d1031 1
a1031 1
	  as_fatal (_("No such opcode"));
d1057 2
a1058 4
		    case 'H':	/* the operand is supposed to be a
				   displacement */
		      /* Hackwarning: do not forget to update the 4
                         cases above when editing ns32k-opcode.h */
d1062 1
a1062 2
		      suffix_separator = '\255'; /* if this char occurs we
						    loose */
d1064 1
a1064 1
		  suffix[argc] = 0; /* 0 when no ':' is encountered */
d1096 1
a1096 1
			      as_warn (_("Bad suffix, defaulting to d"));
d1118 1
a1118 1
		  as_fatal (_("Too many operands passed to instruction"));
d1129 1
a1129 1
	      as_fatal (_("Wrong numbers of operands in default, check ns32k-opcodes.h"));
d1134 1
a1134 1
	  as_fatal (_("Wrong number of operands"));
d1169 20
d1190 4
a1193 15

/* GAS for the ns32k has a problem. PC relative displacements are
 * relative to the address of the opcode, not the address of the
 * operand. We used to keep track of the offset between the operand
 * and the opcode in pcrel_adjust for each frag and each fix. However,
 * we get into trouble where there are two or more pc-relative
 * operands and the size of the first one can't be determined. Then in
 * the relax phase, the size of the first operand will change and
 * pcrel_adjust will no longer be correct.  The current solution is
 * keep a pointer to the frag with the opcode in it and the offset in
 * that frag for each frag and each fix. Then, when needed, we can
 * always figure out how far it is between the opcode and the pcrel
 * object.  See also md_pcrel_adjust and md_fix_pcrel_adjust.  For
 * objects not part of an instruction, the pointer to the opcode frag
 * is always zero.  */
d1203 2
d1208 1
d1211 4
a1214 1
  int size_so_far;
d1216 2
a1217 1
  memP = frag_more (0);
d1229 1
a1229 2
	      size = 0;		/* it's a bitfix that operates on an existing
				   object*/
d1235 1
a1239 1
	      memP = frag_more(size);
d1252 1
d1255 1
a1255 2
				     iif.iifP[i].bsr,	/* sequent hack */
				     inst_frag, inst_offset);
d1268 1
a1268 1
			  as_fatal (_("iif convert internal pcrel/binary"));
d1271 2
d1274 3
a1276 4
		case 2:
		  /* the object is a pointer at an expression, so
                     unpack it, note that bignums may result from the
                     expression */
d1281 3
a1283 3
			{
			  /* we have a bignum ie a quad. This can only
                             happens in a long suffixed instruction */
d1285 1
a1285 1
			    as_warn (_("Bignum too big for long"));
d1290 1
a1290 3
			      md_number_to_chars (memP + l,
						  generic_bignum[l >> 1],
						  sizeof (LITTLENUM_TYPE));
d1301 2
a1302 5
			      md_number_to_imm (memP, (long) words[0],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + sizeof (LITTLENUM_TYPE),
						(long) words[1],
						sizeof (LITTLENUM_TYPE));
d1306 4
a1309 13
			      md_number_to_imm (memP, (long) words[0],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + sizeof (LITTLENUM_TYPE),
						(long) words[1],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm ((memP + 2
						 * sizeof (LITTLENUM_TYPE)),
						(long) words[2],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm ((memP + 3
						 * sizeof (LITTLENUM_TYPE)),
						(long) words[3],
						sizeof (LITTLENUM_TYPE));
d1313 2
d1321 3
a1323 4
		    {
		      /* The expression was undefined due to an
                         undefined label. Create a fix so we can fix
                         the object later. */
d1330 1
d1333 2
a1334 2
					 iif.iifP[i].bsr,
					 inst_frag, inst_offset);
d1337 1
a1337 2
		    {
		      /* good, just put them bytes out */
d1347 1
a1347 1
			  as_fatal (_("iif convert internal pcrel/pointer"));
d1350 2
d1354 1
a1354 1
		  as_fatal (_("Internal logic error in iif.iifP[n].type"));
d1357 7
a1363 6
	    case 0:
	      /* To bad, the object may be undefined as far as its
		 final nsize in object memory is concerned.  The size
		 of the object in objectmemory is not explicitly
		 given.  If the object is defined its length can be
		 determined and a fix can replace the frag. */
d1365 1
d1369 2
a1370 5
		  {
		    /* Size is unknown until link time so have to
                       allow 4 bytes. */
		    size = 4;
		    memP = frag_more(size);
d1375 7
a1381 6
				       0, /* never iif.iifP[i].pcrel, */
				       1, /* always iif.iifP[i].im_disp */
				       (bit_fixS *) 0, 0,
				       inst_frag,
				       inst_offset);
		    break;		/* exit this absolute hack */
d1385 1
a1385 1
		  {			/* frag it */
d1387 2
a1388 2
		      {			/* We cant relax this case */
			as_fatal (_("Can't relax difference"));
d1393 11
a1406 1
			memP = frag_more(4); /* Max size */
d1409 3
d1415 1
a1415 1
					4, /* Max size */
d1420 6
a1425 4
					inst_opcode);
			  frag_opcode_frag(old_frag) = inst_frag;
			  frag_opcode_offset(old_frag) = inst_offset;
			  frag_bsr(old_frag) = iif.iifP[i].bsr;
d1427 18
d1448 3
a1450 2
		  {
		    /* This duplicates code in md_number_to_disp */
d1457 1
a1457 2
			if (-8192 <= exprP.X_add_number
			    && exprP.X_add_number <= 8191)
d1470 1
a1470 1
				as_warn (_("Displacement to large for :d"));
d1475 2
a1476 1
		    memP = frag_more(size);
d1478 3
d1485 1
a1485 1
	      as_fatal (_("Internal logic error in iif.iifP[].type"));
d1487 2
d1541 2
a1542 6
  if (pcrel)
    as_bad (_("Can not do %d byte pc-relative relocation for storage type %d"),
	    size, type);
  else
    as_bad (_("Can not do %d byte relocation for storage type %d"),
	    size, type);
d1573 1
a1573 1
	  as_fatal (_("Can't hash %s: %s"), ptr->name, stat);	/*fatal*/
d1576 1
a1576 2
  freeptr_static = (char *) malloc (PRIVATE_SIZE); /* some private space
						      please! */
d1582 4
a1585 4
/* Turn the string pointed to by litP into a floating point constant
   of type type, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *sizeP .  An error message is
   returned, or NULL on OK.  */
d1608 1
a1608 1
      return _("Bad call to MD_ATOF()");
d1635 4
a1638 4
/* This is a variant of md_numbers_to_chars. The reason for its'
   existence is the fact that ns32k uses Huffman coded
   displacements. This implies that the bit order is reversed in
   displacements and that they are prefixed with a size-tag.
d1645 2
a1646 1
   This must be taken care of and we do it here!  */
d1657 1
a1657 1
	as_warn (_("Byte displacement out of range.  line number not valid"));
d1666 1
a1666 1
	as_warn (_("Word displacement out of range.  line number not valid"));
d1680 1
a1680 1
	as_warn (_("Double word displacement out of range"));
d1700 1
a1700 2
      as_fatal (_("Internal logic error.  line %s, file \"%s\""),
		__LINE__, __FILE__);
d1747 1
a1747 2
      as_fatal (_("Internal logic error. line %s, file \"%s\""),
		__LINE__, __FILE__);
d1751 33
d1856 1
a1856 2
#ifdef ENDIAN			/* we have a nice ns32k machine with lowbyte
				   at low-physical mem */
d1889 1
a1889 1
      as_warn (_("Bit field out of range"));
d1896 13
a1908 8
  addressT opcode_address;
  unsigned int offset;
  opcode_frag = frag_opcode_frag(fragP);
  if (opcode_frag == 0)
    return 0;
  offset = frag_opcode_offset(fragP);
  opcode_address = offset + opcode_frag->fr_address;
  return fragP->fr_address + fragP->fr_fix - opcode_address;
d1915 13
a1927 8
  addressT opcode_address;
  unsigned int offset;
  opcode_frag = fix_opcode_frag(fixP);
  if (opcode_frag == 0)
    return 0;
  offset = fix_opcode_offset(fixP);
  opcode_address = offset + opcode_frag->fr_address;
  return fixP->fx_where + fixP->fx_frag->fr_address - opcode_address;
d1956 1
a1956 1
  if (fix_bit_fixP(fixP))
d1958 1
a1958 1
      md_number_to_field (buf, val, fix_bit_fixP(fixP));
d1961 1
a1961 1
    switch (fix_im_disp(fixP))
d1972 2
a1973 2
			   (fixP->fx_pcrel ? val + md_fix_pcrel_adjust(fixP)
			    : val), fixP->fx_size);
d2034 1
a2034 1
  disp += symbol_get_frag (fragP->fr_symbol)->fr_address;
d2038 2
a2039 2
  md_number_to_disp (buffer_address, (long) disp, (int) ext);
  fragP->fr_fix += ext;
d2063 2
a2064 2
	  /* we don't relax symbols defined in an other segment the
	     thing to do is to assume the object will occupy 4 bytes */
d2071 1
d2074 1
a2074 3
			 frag_bsr(fragP), /*sequent hack */
			 frag_opcode_frag(fragP),
			 frag_opcode_offset(fragP));
d2147 1
a2147 1
	  as_bad (_("invalid architecture option -m%s"), arg);
d2163 1
a2163 1
  fprintf(stream, _("\
d2165 1
a2165 1
-m32032 | -m32532	select variant of NS32K architecture\n"));
d2203 1
a2203 1
	       im_disp, bit_fixP, bsr, opcode_frag, opcode_offset)
d2210 4
a2213 8
     char im_disp;		/* true if the value to write is a
				   displacement */
     bit_fixS *bit_fixP;	/* pointer at struct of bit_fix's, ignored if
				   NULL */
     char bsr;			/* sequent-linker-hack: 1 when relocobject is
				   a bsr */
     fragS *opcode_frag;
     unsigned int opcode_offset;
d2225 4
a2228 5
  fix_opcode_frag(fixP) = opcode_frag;
  fix_opcode_offset(fixP) = opcode_offset;
  fix_im_disp(fixP) = im_disp;
  fix_bsr(fixP) = bsr;
  fix_bit_fixP(fixP) = bit_fixP;
d2233 1
a2233 1
		   im_disp, bit_fixP, bsr, opcode_frag, opcode_offset)
d2239 4
a2242 8
     char im_disp;		/* true if the value to write is a
				   displacement */
     bit_fixS *bit_fixP;	/* pointer at struct of bit_fix's, ignored if
				   NULL */
     char bsr;			/* sequent-linker-hack: 1 when relocobject is
				   a bsr */
     fragS *opcode_frag;
     unsigned int opcode_offset;
d2252 4
a2255 5
  fix_opcode_frag(fixP) = opcode_frag;
  fix_opcode_offset(fixP) = opcode_offset;
  fix_im_disp(fixP) = im_disp;
  fix_bsr(fixP) = bsr;
  fix_bit_fixP(fixP) = bit_fixP;
d2268 1
a2268 1
		     0, 2, 0, 0, 0, 0);
d2289 4
a2292 2
/* Exactly what point is a PC-relative offset relative TO?  On the
   ns32k, they're relative to the start of the instruction. */
d2300 1
a2300 1
  if (frag_bsr(fixP->fx_frag))
d2316 1
a2316 1
  code = reloc(fixp->fx_size, fixp->fx_pcrel, fix_im_disp(fixp));
d2319 1
a2319 2
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d2333 2
a2334 2
	name = _("<unknown>");
      as_fatal (_("Cannot find relocation type for symbol %s, code %d"),
d2344 1
a2344 1
cons_fix_new_ns32k (where, fixP, segment_address_in_file)
d2372 2
a2373 2
		       | (long) (fix_bsr(fixP) << 28)
		       | (long) (fix_im_disp(fixP) << 29)),
d2379 5
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
d22 1
a22 1
/*#define SHOW_NUM 1*//* Uncomment for debugging.  */
d32 3
a34 3
/* Macros.  */
#define IIF_ENTRIES 13		/* Number of entries in iif.  */
#define PRIVATE_SIZE 256	/* Size of my garbage memory.  */
d38 1
a38 1
                                   encountered.  */
d65 1
a65 2
const char line_separator_chars[] = ";";

d88 2
a89 1
char *freeptr, *freeptr_static;	/* Points at some number of free bytes.  */
d92 1
a92 1
struct ns32k_opcode *desc;	/* Pointer at description of instruction.  */
d95 1
a95 2
const char FLT_CHARS[] = "fd";	/* We don't want to support lowercase,
                                   do we?  */
d102 1
a102 1
 * it is converted to a FRAGment as specified in AS.H.  */
d104 1
a104 1
/* Internal structs.  */
d106 5
a110 5
{
  char *pattern;
  unsigned long or;
  unsigned long and;
};
d132 1
a132 1
    int instr_size;		/* Max size of instruction in bytes.  */
a134 1

d138 47
a184 46

/* Description of the PARTs in IIF
  object[n]:
   0	total length in bytes of entries in iif
   1	opcode
   2	index_byte_a
   3	index_byte_b
   4	disp_a_1
   5	disp_a_2
   6	disp_b_1
   7	disp_b_2
   8	imm_a
   9	imm_b
   10	implied1
   11	implied2

   For every entry there is a datalength in bytes. This is stored in size[n].
  	 0,	the objectlength is not explicitly given by the instruction
  		and the operand is undefined. This is a case for relaxation.
  		Reserve 4 bytes for the final object.

  	 1,	the entry contains one byte
  	 2,	the entry contains two bytes
  	 3,	the entry contains three bytes
  	 4,	the entry contains four bytes
  	etc

   Furthermore, every entry has a data type identifier in type[n].

   	 0,	the entry is void, ignore it.
   	 1,	the entry is a binary number.
  	 2,	the entry is a pointer at an expression.
  		Where expression may be as simple as a single '1',
  		and as complicated as  foo-bar+12,
   		foo and bar may be undefined but suffixed by :{b|w|d} to
  		control the length of the object.

  	 3,	the entry is a pointer at a bignum struct

   The low-order-byte coresponds to low physical memory.
   Obviously a FRAGment must be created for each valid disp in PART whose
   datalength is undefined (to bad) .
   The case where just the expression is undefined is less severe and is
   handled by fix. Here the number of bytes in the objectfile is known.
   With this representation we simplify the assembly and separates the
   machine dependent/independent parts in a more clean way (said OE).  */
d314 1
a314 1
{					/* So far empty.  */
d320 1
a320 1
/* Those are index's to relax groups in md_relax_table ie it must be
d322 1
a322 1
   relax_segment in write.c for more info.  */
d327 1
a327 1
/* Those are index's to entries in a relax group.  */
d340 2
a341 1
   had to be used.  Now we dont have to think about that.  */
d357 1
a357 1
   Value is true if mode contains displacement.  */
d365 1
a365 1
/* Array used to calculate max size of displacements.  */
d374 1
a374 1
/* Parse a general operand into an addressingmode struct
d376 3
a378 5
   In:  pointer at operand in ascii form
        pointer at addr_mode struct for result
        the level of recursion. (always 0 or 1)

   Out: data in addr_mode struct.  */
d380 2
a392 1

a404 1

d406 3
a408 2
    return 0;

a409 1

d412 2
a413 2
      /* The following three case statements controls the mode-chars
	 this is the place to ed if you want to change them.  */
d420 1
a420 1
      return -1;
d428 1
a428 1
      return -1;
d441 1
a441 1
		  return -1;
d445 1
a445 1
	      return 0;
d474 1
a474 1
	      return -1;
d478 1
a478 3

    default:
      ;
a479 1

a480 1

a487 1
	  /* Drop through.  */
d492 1
a492 1
	      return -1;
a493 3
	  break;
	default:
	  break;
a494 2
      /* Drop through.  */

d499 1
a499 1
	  return -1;
d501 1
a501 4
      break;

    default:
      break;
a502 1

d510 11
a520 6
		mode = 16;		/* Memory Relative.  */
	      else if (!strncmp (&str[strl - 5], "(sp", 3))
		mode = 17;
	      else if (!strncmp (&str[strl - 5], "(sb", 3))
		mode = 18;

d522 1
a522 1
		{			/* Memory relative.  */
d524 1
a524 1
		  j = strl - 5;		/* Temp for end of disp[0].  */
a525 1

a534 1

a539 1

d542 3
a544 4
		  str[j] = '\000';	/* Null terminate disp[0] .  */
		  str[strl] = '\000';	/* Null terminate disp[1].  */

		  return -1;
a546 1

d558 1
a558 1
		  return -1;		/* reg rel */
a559 2
	      /* Drop through.  */

d562 15
a576 8
		mode = 24;
	      else if (!strncmp (&str[strl - 4], "(sp", 3))
		mode = 25;
	      else if (!strncmp (&str[strl - 4], "(sb", 3))
		mode = 26;
	      else if (!strncmp (&str[strl - 4], "(pc", 3))
		mode = 27;

d582 1
a582 2

		  return -1;		/* Memory space.  */
d586 1
a586 2

      /* No trailing ')' do we have a ']' ?  */
d603 1
a603 1
	    default:
a604 1

d608 25
a632 25
		as_warn (_("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"));
	    } /* Scaled index.  */

	  if (recursive_level > 0)
	    {
	      as_warn (_("Scaled-indexed addressing mode combined with scaled-index"));
	      return 0;
	    }

	  addr_modeP->am_size += 1;	/* scaled index byte */
	  j = str[strl - 4] - '0';	/* store temporary */
	  str[strl - 6] = '\000';	/* nullterminate for recursive call */
	  i = addr_mode (str, addr_modeP, 1);

	  if (!i || addr_modeP->mode == 20)
	    {
	      as_warn (_("Invalid or illegal addressing mode combined with scaled-index"));
	      return 0;
	    }

	  addr_modeP->scaled_mode = addr_modeP->mode;	/* Store the inferior mode.  */
	  addr_modeP->mode = mode;
	  addr_modeP->scaled_reg = j + 1;

	  return -1;
d635 1
a635 2

  addr_modeP->mode = DEFAULT;	/* Default to whatever.  */
d637 1
a637 2

  return -1;
a644 1

a650 1

a651 1

d654 1
a654 1
      /* Resolve ambigious operands, this shouldn't be necessary if
d657 2
a658 3
	 if it is implicitly stated. See ns32k-opcode.h.  */
      (void) evaluate_expr (&exprP, ptr); /* This call takes time Sigh!  */

d662 3
a664 1
	    addr_modeP->mode = desc->default_model; /* We have a label.  */
d666 3
a668 1
	    addr_modeP->mode = desc->default_modec; /* We have a constant.  */
d673 3
a675 1
	    addr_modeP->scaled_mode = desc->default_model;
d677 3
a679 1
	    addr_modeP->scaled_mode = desc->default_modec;
d681 2
a682 3

      /* Must put this mess down in addr_mode to handle the scaled
         case better.  */
a683 1

d690 3
a692 3
    {				/* Build indexbyte.  */
      tmp--;			/* Remember regnumber comes incremented for
				   flagpurpose.  */
a696 1

d698 62
a759 68
    {
      register char c;
      register char suffix;
      register char suffix_sub;
      register int i;
      register char *toP;
      register char *fromP;

      /* There was a displacement, probe for length  specifying suffix.  */
      addr_modeP->pcrel = 0;

      if (disp_test[addr_modeP->mode])
	{
	  /* There is a displacement.  */
	  if (addr_modeP->mode == 27 || addr_modeP->scaled_mode == 27)
	    /* Do we have pcrel. mode.  */
	    addr_modeP->pcrel = 1;

	  addr_modeP->im_disp = 1;

	  for (i = 0; i < 2; i++)
	    {
	      suffix_sub = suffix = 0;

	      if (toP = addr_modeP->disp[i])
		{
		  /* Suffix of expression, the largest size rules.  */
		  fromP = toP;

		  while (c = *fromP++)
		    {
		      *toP++ = c;
		      if (c == ':')
			{
			  switch (*fromP)
			    {
			    case '\0':
			      as_warn (_("Premature end of suffix -- Defaulting to d"));
			      suffix = 4;
			      continue;
			    case 'b':
			      suffix_sub = 1;
			      break;
			    case 'w':
			      suffix_sub = 2;
			      break;
			    case 'd':
			      suffix_sub = 4;
			      break;
			    default:
			      as_warn (_("Bad suffix after ':' use {b|w|d} Defaulting to d"));
			      suffix = 4;
			    }

			  fromP ++;
			  toP --;	/* So we write over the ':' */

			  if (suffix < suffix_sub)
			    suffix = suffix_sub;
			}
		    }

		  *toP = '\0'; /* Terminate properly.  */
		  addr_modeP->disp_suffix[i] = suffix;
		  addr_modeP->am_size += suffix ? suffix : 4;
		}
	    }
	}
d764 1
a764 2
	{
	  /* Look in ns32k_opcode for size.  */
a768 1

a771 1
/* Read an optionlist.  */
d773 1
d776 3
a778 3
     char *str;			/* The string to extract options from.  */
     struct ns32k_option *optionP;	/* How to search the string.  */
     unsigned long *default_map;	/* Default pattern and output.  */
a781 1

a782 1

d784 3
a786 2
    as_fatal (_("Very short instr to option, ie you can't do it on a NULLstr"));

a789 1

a793 1

a798 1

d808 1
a808 1
/* Search struct for symbols.
d811 1
a811 1
   list.  */
d815 3
a817 3
     char *str;				/* The string to match.  */
     struct ns32k_option *optionP;	/* List to search.  */
     unsigned long *default_map;	/* Default pattern and output.  */
a819 1

d823 1
a823 2
	{
	  /* Use strncmp to be safe.  */
a825 1

a828 1

d850 2
a851 1
   Be carefull not to put to objects in the same iif-slot.  */
a864 1

d867 2
a868 2
      /* What operand are we supposed to work on.  */
      i = operandsP[loop << 1] - '1';
a870 1

a873 1

d889 5
a893 5

	  if ((addr_modeP.mode == 20) &&
	     (d == 'I' || d == 'Z' || d == 'A'))
	    as_fatal (d == 'A'? _("Address of immediate operand"):
			_("Invalid immediate write operand."));
a898 1

a917 1

a919 1

a926 1

d1028 3
a1030 3
   Return-value = recursive_level.    */
/* Build iif of one assembly text line.  */

d1040 1
a1040 2
  char suffix[MAX_ARGS], *argv[MAX_ARGS];	/* No more than 4 operands.  */

d1042 2
a1043 5
    {
      /* Called from md_assemble.  */
      for (lineptr = line; (*lineptr) != '\0' && (*lineptr) != ' '; lineptr++)
	continue;

a1045 1

d1047 3
a1049 2
	as_fatal (_("No such opcode"));

a1055 1

a1056 1

a1062 1

a1068 1

d1074 2
a1075 2
		    case 'H':
		      /* The operand is supposed to be a displacement.  */
d1077 1
a1077 1
                         cases above when editing ns32k-opcode.h.  */
d1081 2
a1082 3
		      /* If this char occurs we loose.  */
		      suffix_separator = '\255';
		      break;
a1083 1

a1086 1

a1101 1

d1103 1
a1103 2
			{
			  /* ':' - label/suffix separator.  */
a1122 1
			      break;
a1123 1

a1126 1

a1129 1

a1131 1

a1133 1

a1142 1

d1146 1
a1146 2
	{
	  /* We can apply default, don't goof.  */
d1148 3
a1150 2
	    /* Check error in default.  */
	    as_fatal (_("Wrong numbers of operands in default, check ns32k-opcodes.h"));
d1156 1
a1157 1

d1159 3
a1161 2
    /* Mark all entries as void.  */
    iif.iifP[i].type = 0;
d1163 1
a1163 1
  /* Build opcode iif-entry.  */
d1167 1
a1167 1
  /* This call encodes operands to iif format.  */
d1180 1
d1182 8
a1189 7
   functions in other files than this one.(Except hash.c) So, if it's
   possible to make an iif for an other CPU, you don't need to know
   what frags, relax, obstacks, etc is in order to port this
   assembler. You only need to know if it's possible to reduce your
   cpu-instruction to iif-format (takes some work) and adopt the other
   md_? parts according to given instructions Note that iif was
   invented for the clean ns32k`s architecure.  */
d1192 13
a1204 13
   relative to the address of the opcode, not the address of the
   operand. We used to keep track of the offset between the operand
   and the opcode in pcrel_adjust for each frag and each fix. However,
   we get into trouble where there are two or more pc-relative
   operands and the size of the first one can't be determined. Then in
   the relax phase, the size of the first operand will change and
   pcrel_adjust will no longer be correct.  The current solution is
   keep a pointer to the frag with the opcode in it and the offset in
   that frag for each frag and each fix. Then, when needed, we can
   always figure out how far it is between the opcode and the pcrel
   object.  See also md_pcrel_adjust and md_fix_pcrel_adjust.  For
   objects not part of an instruction, the pointer to the opcode frag
   is always zero.  */
d1229 1
a1229 2
	{
	  /* The object exist, so handle it.  */
d1233 2
a1234 2
	      size = 0;
	      /* It's a bitfix that operates on an existing object.  */
d1236 3
a1238 4
		/* Expand fx_bit_base to point at opcode.  */
		iif.iifP[i].bit_fixP->fx_bit_base = (long) inst_opcode;
	      /* Fall through.  */

d1243 1
a1243 2
	    case 4:
	      /* The final size in objectmemory is known.  */
a1245 1

d1248 1
a1248 1
		case 1:	/* The object is pure binary.  */
d1263 1
a1263 2
		    {
		      /* Good, just put them bytes out.  */
a1276 1

d1278 1
a1278 1
		  /* The object is a pointer at an expression, so
d1280 1
a1280 1
                     expression.  */
d1286 2
a1287 2
			  /* We have a bignum ie a quad. This can only
                             happens in a long suffixed instruction.  */
a1289 1

a1291 1

d1300 1
a1300 2
			{
			  /* flonum.  */
d1340 1
a1340 1
                         the object later.  */
d1354 1
a1354 1
		      /* Good, just put them bytes out.  */
a1371 1

d1373 1
a1373 1
	      /* Too bad, the object may be undefined as far as its
d1377 1
a1377 1
		 determined and a fix can replace the frag.  */
a1379 1

d1384 1
a1384 1
                       allow 4 bytes.  */
d1400 1
a1400 2
		  {
		    /* Frag it.  */
d1402 1
a1402 2
		      {
			/* We cant relax this case.  */
d1407 5
a1411 3
			/* Size is not important.  This gets fixed by
			   relax, but we assume 0 in what follows.  */
			memP = frag_more(4); /* Max size.  */
d1417 3
a1419 4
					4, /* Max size.  */
					0, /* Size.  */
					IND (BRANCH, UNDEF), /* Expecting
                                                                the worst.  */
d1423 3
a1425 3
			  frag_opcode_frag (old_frag) = inst_frag;
			  frag_opcode_offset (old_frag) = inst_offset;
			  frag_bsr (old_frag) = iif.iifP[i].bsr;
d1431 1
a1431 1
		    /* This duplicates code in md_number_to_disp.  */
d1445 2
a1446 2
			    if (-0x20000000 <= exprP.X_add_number
				&& exprP.X_add_number<=0x1fffffff)
d1457 1
a1457 2

		    memP = frag_more (size);
a1461 1

d1470 1
a1470 1
/* This functionality should really be in the bfd library.  */
d1475 1
a1475 2
  bfd_reloc_code_real_type relocs[] =
  {
d1483 1
a1483 1
    /* ns32k displacements.  */
d1491 1
a1491 1
    /* Normal 2's complement.  */
d1498 1
a1498 2
  };

a1513 1

d1515 1
a1515 2

  if (index >= 0 && index < sizeof (relocs) / sizeof (relocs[0]))
a1516 1

a1522 1

d1526 1
d1534 2
a1535 2
  parse (line, 0);		/* Explode line to more fix form in iif.  */
  convert_iif ();		/* Convert iif to frags, fix's etc.  */
d1541 1
d1545 1
a1545 1
  /* Build a hashtable of the instructions.  */
a1548 1

d1552 3
a1554 2
	/* Fatal.  */
	as_fatal (_("Can't hash %s: %s"), ptr->name, stat);
d1556 2
a1557 3

  /* Some private space please!  */
  freeptr_static = (char *) malloc (PRIVATE_SIZE);
d1560 1
a1560 1
/* Must be equal to MAX_PRECISON in atof-ieee.c.  */
d1564 2
a1565 2
   of type TYPE, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is
a1566 1

a1590 1

a1595 1

a1600 1

d1604 1
a1604 1
/* Convert number to chars in correct order.  */
d1615 1
a1626 1

d1733 3
a1735 2
/* Fast bitfiddling support.  */
/* Mask used to zero bitfield before oring in the true field.  */
d1764 2
a1765 1
   and a general version. (My advice: use the general version!).  */
d1785 3
a1787 2
	/* Override buf.  */
	mem_ptr = (unsigned long *) field_ptr->fx_bit_base;
d1789 3
a1791 2
	mem_ptr = (unsigned long *) buf;

d1796 3
a1798 1
	mem_ptr = (char *) field_ptr->fx_bit_base;
d1800 3
a1802 2
	mem_ptr = buf;

d1805 2
a1806 2
#ifdef ENDIAN
      /* We have a nice ns32k machine with lowbyte at low-physical mem.  */
d1809 1
a1809 1
      /* That takes more byte fiddling.  */
d1843 1
a1843 3
int
md_pcrel_adjust (fragP)
     fragS *fragP;
d1848 1
a1848 2

  opcode_frag = frag_opcode_frag (fragP);
d1851 1
a1851 2

  offset = frag_opcode_offset (fragP);
a1852 1

d1856 1
a1856 3
int
md_fix_pcrel_adjust (fixP)
     fixS *fixP;
d1862 1
a1862 2

  opcode_frag = fix_opcode_frag (fixP);
d1865 1
a1865 2

  offset = fix_opcode_offset (fixP);
a1866 1

d1896 3
a1898 3
  if (fix_bit_fixP (fixP))
    {				/* Bitfields to fix, sigh.  */
      md_number_to_field (buf, val, fix_bit_fixP (fixP));
d1901 1
a1901 1
    switch (fix_im_disp (fixP))
d1903 2
a1904 1
      case 0:			/* Immediate field.  */
d1908 1
a1908 1
      case 1:			/* Displacement field.  */
d1911 3
a1913 3
	  md_number_to_disp (buf,
			     (fixP->fx_pcrel ? val + md_fix_pcrel_adjust (fixP)
			      : val), fixP->fx_size);
d1917 1
a1917 1
      case 2:			/* Pointer in a data object.  */
d1965 1
a1965 1
  if (ext == 0)
a1970 1

d1976 1
a1976 1
  disp += md_pcrel_adjust (fragP);
d1984 1
a1984 1
   actually know it.  */
d1991 3
a1993 1
  if (fragP->fr_subtype == IND (BRANCH, UNDEF))
d1995 7
a2001 1
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
d2003 2
a2004 2
	  /* We don't relax symbols defined in another segment.  The
	     thing to do is to assume the object will occupy 4 bytes.  */
d2014 2
a2015 2
			 frag_opcode_frag (fragP),
			 frag_opcode_offset (fragP));
d2017 1
a2017 3
#if 0
	  fragP->fr_opcode[1] = 0xff;
#endif
d2019 1
a2019 1
	  return 4;
d2021 5
a2025 4

      /* Relaxable case.  Set up the initial guess for the variable
	 part of the frag.  */
      fragP->fr_subtype = IND (BRANCH, BYTE);
d2027 1
a2027 6

  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
d2032 1
a2032 1
const int md_reloc_size = 8;	/* Size of relocation record.  */
d2063 1
a2063 3

struct option md_longopts[] =
{
d2066 1
a2066 2

size_t md_longopts_size = sizeof (md_longopts);
d2104 1
a2104 1
  fprintf (stream, _("\
d2108 1
d2110 7
a2116 5
/* Create a bit_fixS in obstack 'notes'.
   This struct is used to profile the normal fix. If the bit_fixP is a
   valid pointer (not NULL) the bit_fix data will be used to format
   the fix.  */

d2147 4
a2150 4
     int size;			/* 1, 2  or 4 usually.  */
     symbolS *add_symbol;	/* X_add_symbol.  */
     long offset;		/* X_add_number.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
d2159 1
d2164 1
a2164 1
			bit_fixP ? NO_RELOC : reloc (size, pcrel, im_disp)
d2170 6
a2175 6
  fix_opcode_frag (fixP) = opcode_frag;
  fix_opcode_offset (fixP) = opcode_offset;
  fix_im_disp (fixP) = im_disp;
  fix_bsr (fixP) = bsr;
  fix_bit_fixP (fixP) = bit_fixP;
}
d2182 3
a2184 3
     int size;			/* 1, 2  or 4 usually.  */
     expressionS *exp;		/* Expression.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
d2196 1
a2196 1
			    bit_fixP ? NO_RELOC : reloc (size, pcrel, im_disp)
d2202 6
a2207 6
  fix_opcode_frag (fixP) = opcode_frag;
  fix_opcode_offset (fixP) = opcode_offset;
  fix_im_disp (fixP) = im_disp;
  fix_bsr (fixP) = bsr;
  fix_bit_fixP (fixP) = bit_fixP;
}
d2215 2
a2216 2
     int size;			/* 1, 2  or 4 usually.  */
     expressionS *exp;		/* Expression.  */
a2231 1

d2237 1
a2237 1
  return size;			/* Byte alignment is fine.  */
d2241 1
a2241 2
   ns32k, they're relative to the start of the instruction.  */

d2249 2
a2250 2
  if (frag_bsr (fixP->fx_frag))
    res += 0x12			/* FOO Kludge alert!  */
d2265 1
a2265 1
  code = reloc (fixp->fx_size, fixp->fx_pcrel, fix_im_disp (fixp));
d2299 4
a2302 2
  /* In:  Length of relocation (or of address) in chars: 1, 2 or 4.
     Out: GNU LD relocation length code: 0, 1, or 2.  */
d2304 1
a2304 1
  static unsigned char nbytes_r_length[] = { 42, 0, 1, 42, 2 };
d2322 2
a2323 2
		       | (long) (fix_bsr (fixP) << 28)
		       | (long) (fix_im_disp (fixP) << 29)),
d2329 2
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002
d26 1
a66 1
static int default_disp_size = 4; /* Displacement size for external refs.  */
d69 1
a69 1
#define ABSOLUTE_PREFIX '@@'	/* One or the other MUST be defined.  */
d74 13
a86 13
    signed char mode;		/* Addressing mode of operand (0-31).  */
    signed char scaled_mode;	/* Mode combined with scaled mode.  */
    char scaled_reg;		/* Register used in scaled+1 (1-8).  */
    char float_flag;		/* Set if R0..R7 was F0..F7 ie a
				   floating-point-register.  */
    char am_size;		/* Estimated max size of general addr-mode
				   parts.  */
    char im_disp;		/* If im_disp==1 we have a displacement.  */
    char pcrel;			/* 1 if pcrel, this is really redundant info.  */
    char disp_suffix[2];	/* Length of displacement(s), 0=undefined.  */
    char *disp[2];		/* Pointer(s) at displacement(s)
				   or immediates(s)     (ascii).  */
    char index_byte;		/* Index byte.  */
d100 5
a104 5
   used as an intermediate form to store the actual parts of the
   instruction. A ns32k machine instruction can be divided into a
   couple of sub PARTs. When an instruction is assembled the
   appropriate PART get an assignment. When an IIF has been completed
   it is converted to a FRAGment as specified in AS.H.  */
d116 11
a126 10
    int type;			/* How to interpret object.  */
    int size;			/* Estimated max size of object.  */
    unsigned long object;	/* Binary data.  */
    int object_adjust;		/* Number added to object.  */
    int pcrel;			/* True if object is pcrel.  */
    int pcrel_adjust;		/* Length in bytes from the instruction
				   start to the	displacement.  */
    int im_disp;		/* True if the object is a displacement.  */
    relax_substateT relax_substate;	/* Initial relaxsubstate.  */
    bit_fixS *bit_fixP;		/* Pointer at bit_fix struct.  */
d128 3
a130 3
				   iif-entry.  */
    char bsr;			/* Sequent hack.  */
  } iif_entryT;			/* Internal Instruction Format.  */
d188 1
a188 1
struct ns32k_option opt1[] =		/* restore, exit.  */
d200 1
a200 1
struct ns32k_option opt2[] =		/* save, enter.  */
d212 1
a212 1
struct ns32k_option opt3[] =		/* setcfg.  */
d220 1
a220 1
struct ns32k_option opt4[] =		/* cinv.  */
d227 1
a227 1
struct ns32k_option opt5[] =		/* String inst.  */
d234 1
a234 1
struct ns32k_option opt6[] =		/* Plain reg ext,cvtp etc.  */
d251 1
a251 1
struct ns32k_option cpureg_532[] =	/* lpr spr.  */
d268 1
a268 1
struct ns32k_option mmureg_532[] =	/* lmr smr.  */
d280 1
a280 1
struct ns32k_option cpureg_032[] =	/* lpr spr.  */
d291 1
a291 1
struct ns32k_option mmureg_032[] =	/* lmr smr.  */
d371 3
a373 4
static void evaluate_expr PARAMS ((expressionS * resultP, char *));
static void md_number_to_disp PARAMS ((char *, long, int));
static void md_number_to_imm PARAMS ((char *, long, int));
static void md_number_to_field PARAMS ((char *, long, bit_fixS *));
d383 1
a383 3
static int addr_mode PARAMS ((char *, addr_modeS *, int));

static int
d386 1
a386 1
     addr_modeS *addr_modeP;
d389 4
a392 4
  char *str;
  int i;
  int strl;
  int mode;
d395 3
a397 3
  mode = DEFAULT;		/* Default.  */
  addr_modeP->scaled_mode = 0;	/* Why not.  */
  addr_modeP->scaled_reg = 0;	/* If 0, not scaled index.  */
d401 1
a401 1
  addr_modeP->pcrel = 0;	/* Not set in this function.  */
d447 1
a447 1
	      as_bad (_("Invalid syntax in PC-relative addressing mode"));
d461 1
a461 1
		{			/* disp[0]'s termination point.  */
d471 1
a471 1
		  as_bad (_("Invalid syntax in External addressing mode"));
d534 1
a534 2
		{
		  /* Memory relative.  */
d551 1
a551 1
		      as_bad (_("Invalid syntax in Memory Relative addressing mode"));
d618 1
a618 1
	      as_bad (_("Invalid scaled-indexed mode, use (b,w,d,q)"));
d623 1
a623 1
		as_bad (_("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"));
d628 1
a628 1
	      as_bad (_("Scaled-indexed addressing mode combined with scaled-index"));
d632 3
a634 3
	  addr_modeP->am_size += 1;	/* scaled index byte.  */
	  j = str[strl - 4] - '0';	/* store temporary.  */
	  str[strl - 6] = '\000';	/* nullterminate for recursive call.  */
d639 1
a639 1
	      as_bad (_("Invalid or illegal addressing mode combined with scaled-index"));
d663 1
a663 2
static int get_addr_mode PARAMS ((char *, addr_modeS *));
static int
d704 1
a704 1
  if ((tmp = addr_modeP->scaled_reg))
d713 1
a713 2
  assert (addr_modeP->mode >= 0); 
  if (disp_test[(unsigned int) addr_modeP->mode])
d715 6
a720 6
      char c;
      char suffix;
      char suffix_sub;
      int i;
      char *toP;
      char *fromP;
d725 1
a725 2
      assert(addr_modeP->mode >= 0);
      if (disp_test[(unsigned int) addr_modeP->mode])
d738 1
a738 1
	      if ((toP = addr_modeP->disp[i]))
d743 1
a743 1
		  while ((c = *fromP++))
d798 1
a798 2
static void optlist PARAMS ((char *, struct ns32k_option *, unsigned long *));
static void
d804 2
a805 2
  int i, j, k, strlen1, strlen2;
  char *patternP, *strP;
d841 1
a841 3
static int list_search PARAMS ((char *, struct ns32k_option *, unsigned long *));

static int
d847 1
a847 1
  int i;
d861 1
a861 1
  as_bad (_("No such entry in list. (cpu/mmu register)"));
d870 1
a870 1
  char *tmp_line;
d874 1
a874 1
  expression (resultP);
d884 1
a884 4
static void encode_operand
  PARAMS ((int, char **, const char *, const char *, char, char));

static void
d888 3
a890 3
     const char *operandsP;
     const char *suffixP;
     char im_size ATTRIBUTE_UNUSED;
d893 1
a893 1
  int i, j;
d895 1
a895 2
  int pcrel, b, loop, pcrel_adjust;
  unsigned long tmp;
d910 2
a911 2
	case 'f':		/* Operand of sfsr turns out to be a nasty
				   specialcase.  */
d913 9
a921 9
	case 'Z':		/* Float not immediate.  */
	case 'F':		/* 32 bit float	general form.  */
	case 'L':		/* 64 bit float.  */
	case 'I':		/* Integer not immediate.  */
	case 'B':		/* Byte	 */
	case 'W':		/* Word	 */
	case 'D':		/* Double-word.  */
	case 'A':		/* Double-word	gen-address-form ie no regs
				   allowed.  */
d965 3
a967 3
	case 'b':		/* Multiple instruction disp.  */
	  freeptr++;		/* OVE:this is an useful hack.  */
	  sprintf (freeptr, "((%s-1)*%d)", argv[i], desc->im_size);
d969 2
a970 2
	  pcrel -= 1;		/* Make pcrel 0 inspite of what case 'p':
				   wants.  */
d972 1
a972 1
	case 'p':		/* Displacement - pc relative addressing.  */
d975 1
a975 1
	case 'd':		/* Displacement.  */
d980 2
a981 2
	case 'H':		/* Sequent-hack: the linker wants a bit set
				   when bsr.  */
d992 1
a992 1
	case 'r':		/* Register number (3 bits).  */
d997 1
a997 1
	case 'O':		/* Setcfg instruction optionslist.  */
d1002 1
a1002 1
	case 'C':		/* Cinv instruction optionslist.  */
d1005 1
a1005 1
	  iif.iifP[1].object |= tmp << 15; /* Insert the regtype in opcode.  */
d1007 1
a1007 1
	case 'S':		/* String instruction options list.  */
d1013 1
a1013 1
	case 'U':		/* Register list.  */
d1017 1
a1017 1
	    case 'u':		/* Restore, exit.  */
d1020 1
a1020 1
	    case 'U':		/* Save, enter.  */
d1026 1
a1026 1
	case 'M':		/* MMU register.  */
d1031 1
a1031 1
	case 'P':		/* CPU register.  */
d1036 2
a1037 2
	case 'g':		/* Inss exts.  */
	  iif.instr_size += 1;	/* 1 byte is allocated after the opcode.  */
d1039 1
a1039 1
	       (unsigned long) argv[i],	/* i always 2 here.  */
d1041 2
a1042 2
	       bit_fix_new (3, 5, 0, 7, 0, 0, 0), /* A bit_fix is targeted to
						     the byte.  */
d1047 1
a1047 1
	       (unsigned long) argv[i],	/* i always 3 here.  */
d1053 1
a1053 1
	  b = 2 + i;		/* Put the extension byte after opcode.  */
d1066 1
a1066 1
   Return-value = recursive_level.  */
d1069 1
a1069 3
static int parse PARAMS ((const char *, int));

static int
d1071 1
a1071 1
     const char *line;
d1074 3
a1076 5
  const char *lineptr;
  char c, suffix_separator;
  int i;
  unsigned int argc;
  int arg_type;
d1087 1
a1087 1
      *(char *) lineptr = '\0';
d1092 1
a1092 1
      *(char *) lineptr = c;
d1132 1
a1132 1
		  suffix[argc] = 0; /* 0 when no ':' is encountered.  */
d1261 1
a1261 2
static void convert_iif PARAMS ((void));
static void
d1274 1
a1275 1
  frag_grow (iif.instr_size);	/* This is important.  */
d1283 1
a1283 1
      if ((type = iif.iifP[i].type))
d1296 1
a1296 1
	    case 8:		/* bignum or doublefloat.  */
d1302 1
a1302 1
	      memP = frag_more (size);
d1308 1
a1308 5
		  if (j)
		    {
		      md_number_to_field(memP, exprP.X_add_number, j);
		    }
		  else if (iif.iifP[i].pcrel)
d1317 2
a1318 2
				     0,
				     iif.iifP[i].bsr,	/* Sequent hack.  */
d1350 1
a1350 1
			    as_bad (_("Bignum too big for long"));
d1356 5
a1360 3
			    md_number_to_chars (memP + l,
						generic_bignum[l >> 1],
						sizeof (LITTLENUM_TYPE));
d1397 2
a1398 1
		  if (exprP.X_add_symbol ||
a1415 4
		  else if (j)
		    {
		      md_number_to_field(memP, exprP.X_add_number, j);
		    }
d1449 4
a1452 3
		    /* Size is unknown until link time so have to default.  */
		    size = default_disp_size; /* Normally 4 bytes.  */
		    memP = frag_more (size);
d1462 1
a1462 1
		    break;		/* Exit this absolute hack.  */
d1477 1
a1477 1
			memP = frag_more (4); /* Max size.  */
d1519 1
a1519 1
				as_bad (_("Displacement to large for :d"));
d1588 1
a1588 1
  if (index >= 0 && (unsigned int) index < sizeof (relocs) / sizeof (relocs[0]))
a1621 1
  const struct ns32k_opcode *endop;
a1622 1
  endop = ns32k_opcodes + sizeof (ns32k_opcodes) / sizeof (ns32k_opcodes[0]);
d1715 1
a1715 1
	as_bad (_("value of %ld out of byte displacement range."), val);
d1724 1
a1724 1
	as_bad (_("value of %ld out of word displacement range."), val);
d1738 1
a1738 1
	as_bad (_("value of %ld out of double word displacement range."), val);
d1758 1
a1758 1
      as_fatal (_("Internal logic error.  line %d, file \"%s\""),
d1806 1
a1806 1
      as_fatal (_("Internal logic error. line %d, file \"%s\""),
d1845 7
a1851 7
     char *buf;
     long val;
     bit_fixS *field_ptr;
{
  unsigned long object;
  unsigned long mask;
  /* Define ENDIAN on a ns32k machine.  */
d1853 1
a1853 1
  unsigned long *mem_ptr;
d1855 1
a1855 1
  char *mem_ptr;
a1856 1

d1879 1
a1879 1
#else /* OVE Goof! the machine is a m68k or dito.  */
d1910 1
a1910 1
      as_bad (_("Bit field out of range"));
d1932 1
a1932 2
static int md_fix_pcrel_adjust PARAMS ((fixS *fixP));
static int
d1936 1
d1958 6
d1965 1
a1965 1
md_apply_fix3 (fixP, valP, seg)
d1967 2
a1968 2
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d1970 5
a1974 1
  long val = * (long *) valP;
d1978 1
a1978 2
    {
      /* Bitfields to fix, sigh.  */
d1981 6
a1986 6
  else switch (fix_im_disp (fixP))
    {
    case 0:
      /* Immediate field.  */
      md_number_to_imm (buf, val, fixP->fx_size);
      break;
d1988 8
a1995 7
    case 1:
      /* Displacement field.  */
      /* Calculate offset.  */
      md_number_to_disp (buf,
			 (fixP->fx_pcrel ? val + md_fix_pcrel_adjust (fixP)
			  : val), fixP->fx_size);
      break;
d1997 7
a2003 8
    case 2:
      /* Pointer in a data object.  */
      md_number_to_chars (buf, val, fixP->fx_size);
      break;
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
d2006 1
a2006 1
/* Convert a relaxed displacement to ditto in final output.  */
d2013 1
a2013 1
     fragS *fragP;
d2017 3
a2019 3
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
d2024 1
d2026 1
a2026 1
  char *buffer_address = fragP->fr_fix + fragP->fr_literal;
d2030 2
d2054 3
d2069 1
a2069 1
     fragS *fragP;
d2086 1
a2086 1
			 frag_bsr(fragP), /* Sequent hack.  */
d2117 2
a2118 2
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d2131 2
a2132 2
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d2141 1
a2141 1
const char *md_shortopts = "m:";
a2144 2
#define OPTION_DISP_SIZE (OPTION_MD_BASE)
  {"disp-size-default", required_argument , NULL, OPTION_DISP_SIZE},
d2170 1
a2170 1
	  as_warn (_("invalid architecture option -m%s, ignored"), arg);
a2173 14
    case OPTION_DISP_SIZE:
      {
	int size = atoi(arg);
	switch (size)
	  {
	  case 1: case 2: case 4:
	    default_disp_size = size;
	    break;
	  default:
	    as_warn (_("invalid default displacement size \"%s\". Defaulting to %d."),
		     arg, default_disp_size);
	  }
	break;
      }
d2188 1
a2188 2
-m32032 | -m32532	select variant of NS32K architecture\n\
--disp-size-default=<1|2|4>\n"));
d2198 6
a2203 6
     char size;			/* Length of bitfield.  */
     char offset;		/* Bit offset to bitfield.  */
     long min;			/* Signextended min for bitfield.  */
     long max;			/* Signextended max for bitfield.  */
     long add;			/* Add mask, used for huffman prefix.  */
     long base_type;		/* 0 or 1, if 1 it's exploded to opcode ptr.  */
d2206 1
a2206 1
  bit_fixS *bit_fixP;
d2218 1
a2218 1
  return bit_fixP;
d2229 7
a2235 7
     int pcrel;			/* True if PC-relative relocation.  */
     char im_disp;		/* True if the value to write is a
				   displacement.  */
     bit_fixS *bit_fixP;	/* Pointer at struct of bit_fix's, ignored if
				   NULL.  */
     char bsr;			/* Sequent-linker-hack: 1 when relocobject is
				   a bsr.  */
a2252 2
  /* We have a MD overflow check for displacements.  */
  fixP->fx_no_overflow = (im_disp != 0);
d2262 7
a2268 7
     int pcrel;			/* True if PC-relative relocation.  */
     char im_disp;		/* True if the value to write is a
				   displacement.  */
     bit_fixS *bit_fixP;	/* Pointer at struct of bit_fix's, ignored if
				   NULL.  */
     char bsr;			/* Sequent-linker-hack: 1 when relocobject is
				   a bsr.  */
a2284 2
  /* We have a MD overflow check for displacements.  */
  fixP->fx_no_overflow = (im_disp != 0);
d2304 1
a2304 1
     char *name ATTRIBUTE_UNUSED;
d2313 1
a2313 1
     segT segment ATTRIBUTE_UNUSED;
a2326 1

d2339 1
a2339 1
     asection *section ATTRIBUTE_UNUSED;
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d179 1
a179 1
   The low-order-byte corresponds to low physical memory.
d335 1
a335 1
   The ns32k uses the beginning of the instruction as displacement
d444 1
a444 1
		  addr_modeP->mode = 27;	/* pc-relative */
d678 1
a678 1
      /* Resolve ambiguous operands, this shouldn't be necessary if
d680 1
a680 1
	 compiler doesn't!!!  This finds a proper addressing mode
d891 1
a891 1
   Be careful not to put to objects in the same iif-slot.  */
d982 1
a982 1
	  pcrel -= 1;		/* Make pcrel 0 in spite of what case 'p':
d1261 1
a1261 1
   invented for the clean ns32k`s architecture.  */
d1643 1
a1645 2
  inst_hash_handle = hash_new ();

d2438 1
a2438 1
#endif /* BFD_ASSEMBLER */
@


