head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.54
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.52
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.48
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.44
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.46
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.38
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.42
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.40
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.36
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.34
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.32
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.30
	OPENBSD_5_0:1.11.0.28
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.26
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.24
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.20
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.22
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.18
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.16
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.14
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.12
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.8.0.8
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	new-binutils:1.7.0.10
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2004.11.02.20.45.29;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.17.21.54.31;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.13.17.07.36;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.12.19.11.52;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	98.03.25.12.00.28;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	97.05.01.22.30.07;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	97.01.26.08.17.27;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.50;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.06.11;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.51.33;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.11;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.11;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.40.48;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.45.06;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.33;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.23.20;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.30;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.36.50;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.33;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.54;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-ppc.c -- Assemble for the PowerPC or POWER (RS/6000)
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include <stdio.h>
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "dw2gencfi.h"
#include "opcode/ppc.h"

#ifdef OBJ_ELF
#include "elf/ppc.h"
#include "dwarf2dbg.h"
#endif

#ifdef TE_PE
#include "coff/pe.h"
#endif

/* This is the assembler for the PowerPC or POWER (RS/6000) chips.  */

/* Tell the main code what the endianness is.  */
extern int target_big_endian;

/* Whether or not, we've set target_big_endian.  */
static int set_target_endian = 0;

/* Whether to use user friendly register names.  */
#ifndef TARGET_REG_NAMES_P
#ifdef TE_PE
#define TARGET_REG_NAMES_P TRUE
#else
#define TARGET_REG_NAMES_P FALSE
#endif
#endif

/* Macros for calculating LO, HI, HA, HIGHER, HIGHERA, HIGHEST,
   HIGHESTA.  */

/* #lo(value) denotes the least significant 16 bits of the indicated.  */
#define PPC_LO(v) ((v) & 0xffff)

/* #hi(value) denotes bits 16 through 31 of the indicated value.  */
#define PPC_HI(v) (((v) >> 16) & 0xffff)

/* #ha(value) denotes the high adjusted value: bits 16 through 31 of
  the indicated value, compensating for #lo() being treated as a
  signed number.  */
#define PPC_HA(v) PPC_HI ((v) + 0x8000)

/* #higher(value) denotes bits 32 through 47 of the indicated value.  */
#define PPC_HIGHER(v) (((v) >> 16 >> 16) & 0xffff)

/* #highera(value) denotes bits 32 through 47 of the indicated value,
   compensating for #lo() being treated as a signed number.  */
#define PPC_HIGHERA(v) PPC_HIGHER ((v) + 0x8000)

/* #highest(value) denotes bits 48 through 63 of the indicated value.  */
#define PPC_HIGHEST(v) (((v) >> 24 >> 24) & 0xffff)

/* #highesta(value) denotes bits 48 through 63 of the indicated value,
   compensating for #lo being treated as a signed number.  */
#define PPC_HIGHESTA(v) PPC_HIGHEST ((v) + 0x8000)

#define SEX16(val) ((((val) & 0xffff) ^ 0x8000) - 0x8000)

static bfd_boolean reg_names_p = TARGET_REG_NAMES_P;

static bfd_boolean register_name PARAMS ((expressionS *));
static void ppc_set_cpu PARAMS ((void));
static unsigned long ppc_insert_operand
  PARAMS ((unsigned long insn, const struct powerpc_operand *operand,
	   offsetT val, char *file, unsigned int line));
static void ppc_macro PARAMS ((char *str, const struct powerpc_macro *macro));
static void ppc_byte PARAMS ((int));

#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
static int ppc_is_toc_sym PARAMS ((symbolS *sym));
static void ppc_tc PARAMS ((int));
static void ppc_machine PARAMS ((int));
#endif

#ifdef OBJ_XCOFF
static void ppc_comm PARAMS ((int));
static void ppc_bb PARAMS ((int));
static void ppc_bc PARAMS ((int));
static void ppc_bf PARAMS ((int));
static void ppc_biei PARAMS ((int));
static void ppc_bs PARAMS ((int));
static void ppc_eb PARAMS ((int));
static void ppc_ec PARAMS ((int));
static void ppc_ef PARAMS ((int));
static void ppc_es PARAMS ((int));
static void ppc_csect PARAMS ((int));
static void ppc_change_csect PARAMS ((symbolS *, offsetT));
static void ppc_function PARAMS ((int));
static void ppc_extern PARAMS ((int));
static void ppc_lglobl PARAMS ((int));
static void ppc_section PARAMS ((int));
static void ppc_named_section PARAMS ((int));
static void ppc_stabx PARAMS ((int));
static void ppc_rename PARAMS ((int));
static void ppc_toc PARAMS ((int));
static void ppc_xcoff_cons PARAMS ((int));
static void ppc_vbyte PARAMS ((int));
#endif

#ifdef OBJ_ELF
static bfd_reloc_code_real_type ppc_elf_suffix PARAMS ((char **, expressionS *));
static void ppc_elf_cons PARAMS ((int));
static void ppc_elf_rdata PARAMS ((int));
static void ppc_elf_lcomm PARAMS ((int));
static void ppc_elf_validate_fix PARAMS ((fixS *, segT));
static void ppc_apuinfo_section_add PARAMS ((unsigned int apu, unsigned int version));
#endif

#ifdef TE_PE
static void ppc_set_current_section PARAMS ((segT));
static void ppc_previous PARAMS ((int));
static void ppc_pdata PARAMS ((int));
static void ppc_ydata PARAMS ((int));
static void ppc_reldata PARAMS ((int));
static void ppc_rdata PARAMS ((int));
static void ppc_ualong PARAMS ((int));
static void ppc_znop PARAMS ((int));
static void ppc_pe_comm PARAMS ((int));
static void ppc_pe_section PARAMS ((int));
static void ppc_pe_function PARAMS ((int));
static void ppc_pe_tocd PARAMS ((int));
#endif

/* Generic assembler global variables which must be defined by all
   targets.  */

#ifdef OBJ_ELF
/* This string holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  The macro
   tc_comment_chars points to this.  We use this, rather than the
   usual comment_chars, so that we can switch for Solaris conventions.  */
static const char ppc_solaris_comment_chars[] = "#!";
static const char ppc_eabi_comment_chars[] = "#";

#ifdef TARGET_SOLARIS_COMMENT
const char *ppc_comment_chars = ppc_solaris_comment_chars;
#else
const char *ppc_comment_chars = ppc_eabi_comment_chars;
#endif
#else
const char comment_chars[] = "#";
#endif

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";

/* '+' and '-' can be used as postfix predicate predictors for conditional
   branches.  So they need to be accepted as symbol characters.  */
const char ppc_symbol_chars[] = "+-";

/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
int ppc_cie_data_alignment;

/* The target specific pseudo-ops which we support.  */

const pseudo_typeS md_pseudo_table[] =
{
  /* Pseudo-ops which must be overridden.  */
  { "byte",	ppc_byte,	0 },

#ifdef OBJ_XCOFF
  /* Pseudo-ops specific to the RS/6000 XCOFF format.  Some of these
     legitimately belong in the obj-*.c file.  However, XCOFF is based
     on COFF, and is only implemented for the RS/6000.  We just use
     obj-coff.c, and add what we need here.  */
  { "comm",	ppc_comm,	0 },
  { "lcomm",	ppc_comm,	1 },
  { "bb",	ppc_bb,		0 },
  { "bc",	ppc_bc,		0 },
  { "bf",	ppc_bf,		0 },
  { "bi",	ppc_biei,	0 },
  { "bs",	ppc_bs,		0 },
  { "csect",	ppc_csect,	0 },
  { "data",	ppc_section,	'd' },
  { "eb",	ppc_eb,		0 },
  { "ec",	ppc_ec,		0 },
  { "ef",	ppc_ef,		0 },
  { "ei",	ppc_biei,	1 },
  { "es",	ppc_es,		0 },
  { "extern",	ppc_extern,	0 },
  { "function",	ppc_function,	0 },
  { "lglobl",	ppc_lglobl,	0 },
  { "rename",	ppc_rename,	0 },
  { "section",	ppc_named_section, 0 },
  { "stabx",	ppc_stabx,	0 },
  { "text",	ppc_section,	't' },
  { "toc",	ppc_toc,	0 },
  { "long",	ppc_xcoff_cons,	2 },
  { "llong",	ppc_xcoff_cons,	3 },
  { "word",	ppc_xcoff_cons,	1 },
  { "short",	ppc_xcoff_cons,	1 },
  { "vbyte",    ppc_vbyte,	0 },
#endif

#ifdef OBJ_ELF
  { "llong",	ppc_elf_cons,	8 },
  { "quad",	ppc_elf_cons,	8 },
  { "long",	ppc_elf_cons,	4 },
  { "word",	ppc_elf_cons,	2 },
  { "short",	ppc_elf_cons,	2 },
  { "rdata",	ppc_elf_rdata,	0 },
  { "rodata",	ppc_elf_rdata,	0 },
  { "lcomm",	ppc_elf_lcomm,	0 },
#endif

#ifdef TE_PE
  /* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format.  */
  { "previous", ppc_previous,   0 },
  { "pdata",    ppc_pdata,      0 },
  { "ydata",    ppc_ydata,      0 },
  { "reldata",  ppc_reldata,    0 },
  { "rdata",    ppc_rdata,      0 },
  { "ualong",   ppc_ualong,     0 },
  { "znop",     ppc_znop,       0 },
  { "comm",	ppc_pe_comm,	0 },
  { "lcomm",	ppc_pe_comm,	1 },
  { "section",  ppc_pe_section, 0 },
  { "function",	ppc_pe_function,0 },
  { "tocd",     ppc_pe_tocd,    0 },
#endif

#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
  { "tc",	ppc_tc,		0 },
  { "machine",  ppc_machine,    0 },
#endif

  { NULL,	NULL,		0 }
};


/* Predefined register names if -mregnames (or default for Windows NT).
   In general, there are lots of them, in an attempt to be compatible
   with a number of other Windows NT assemblers.  */

/* Structure to hold information about predefined registers.  */
struct pd_reg
  {
    char *name;
    int value;
  };

/* List of registers that are pre-defined:

   Each general register has predefined names of the form:
   1. r<reg_num> which has the value <reg_num>.
   2. r.<reg_num> which has the value <reg_num>.

   Each floating point register has predefined names of the form:
   1. f<reg_num> which has the value <reg_num>.
   2. f.<reg_num> which has the value <reg_num>.

   Each vector unit register has predefined names of the form:
   1. v<reg_num> which has the value <reg_num>.
   2. v.<reg_num> which has the value <reg_num>.

   Each condition register has predefined names of the form:
   1. cr<reg_num> which has the value <reg_num>.
   2. cr.<reg_num> which has the value <reg_num>.

   There are individual registers as well:
   sp or r.sp     has the value 1
   rtoc or r.toc  has the value 2
   fpscr          has the value 0
   xer            has the value 1
   lr             has the value 8
   ctr            has the value 9
   pmr            has the value 0
   dar            has the value 19
   dsisr          has the value 18
   dec            has the value 22
   sdr1           has the value 25
   srr0           has the value 26
   srr1           has the value 27

   The table is sorted. Suitable for searching by a binary search.  */

static const struct pd_reg pre_defined_registers[] =
{
  { "cr.0", 0 },    /* Condition Registers */
  { "cr.1", 1 },
  { "cr.2", 2 },
  { "cr.3", 3 },
  { "cr.4", 4 },
  { "cr.5", 5 },
  { "cr.6", 6 },
  { "cr.7", 7 },

  { "cr0", 0 },
  { "cr1", 1 },
  { "cr2", 2 },
  { "cr3", 3 },
  { "cr4", 4 },
  { "cr5", 5 },
  { "cr6", 6 },
  { "cr7", 7 },

  { "ctr", 9 },

  { "dar", 19 },    /* Data Access Register */
  { "dec", 22 },    /* Decrementer */
  { "dsisr", 18 },  /* Data Storage Interrupt Status Register */

  { "f.0", 0 },     /* Floating point registers */
  { "f.1", 1 },
  { "f.10", 10 },
  { "f.11", 11 },
  { "f.12", 12 },
  { "f.13", 13 },
  { "f.14", 14 },
  { "f.15", 15 },
  { "f.16", 16 },
  { "f.17", 17 },
  { "f.18", 18 },
  { "f.19", 19 },
  { "f.2", 2 },
  { "f.20", 20 },
  { "f.21", 21 },
  { "f.22", 22 },
  { "f.23", 23 },
  { "f.24", 24 },
  { "f.25", 25 },
  { "f.26", 26 },
  { "f.27", 27 },
  { "f.28", 28 },
  { "f.29", 29 },
  { "f.3", 3 },
  { "f.30", 30 },
  { "f.31", 31 },
  { "f.4", 4 },
  { "f.5", 5 },
  { "f.6", 6 },
  { "f.7", 7 },
  { "f.8", 8 },
  { "f.9", 9 },

  { "f0", 0 },
  { "f1", 1 },
  { "f10", 10 },
  { "f11", 11 },
  { "f12", 12 },
  { "f13", 13 },
  { "f14", 14 },
  { "f15", 15 },
  { "f16", 16 },
  { "f17", 17 },
  { "f18", 18 },
  { "f19", 19 },
  { "f2", 2 },
  { "f20", 20 },
  { "f21", 21 },
  { "f22", 22 },
  { "f23", 23 },
  { "f24", 24 },
  { "f25", 25 },
  { "f26", 26 },
  { "f27", 27 },
  { "f28", 28 },
  { "f29", 29 },
  { "f3", 3 },
  { "f30", 30 },
  { "f31", 31 },
  { "f4", 4 },
  { "f5", 5 },
  { "f6", 6 },
  { "f7", 7 },
  { "f8", 8 },
  { "f9", 9 },

  { "fpscr", 0 },

  { "lr", 8 },     /* Link Register */

  { "pmr", 0 },

  { "r.0", 0 },    /* General Purpose Registers */
  { "r.1", 1 },
  { "r.10", 10 },
  { "r.11", 11 },
  { "r.12", 12 },
  { "r.13", 13 },
  { "r.14", 14 },
  { "r.15", 15 },
  { "r.16", 16 },
  { "r.17", 17 },
  { "r.18", 18 },
  { "r.19", 19 },
  { "r.2", 2 },
  { "r.20", 20 },
  { "r.21", 21 },
  { "r.22", 22 },
  { "r.23", 23 },
  { "r.24", 24 },
  { "r.25", 25 },
  { "r.26", 26 },
  { "r.27", 27 },
  { "r.28", 28 },
  { "r.29", 29 },
  { "r.3", 3 },
  { "r.30", 30 },
  { "r.31", 31 },
  { "r.4", 4 },
  { "r.5", 5 },
  { "r.6", 6 },
  { "r.7", 7 },
  { "r.8", 8 },
  { "r.9", 9 },

  { "r.sp", 1 },   /* Stack Pointer */

  { "r.toc", 2 },  /* Pointer to the table of contents */

  { "r0", 0 },     /* More general purpose registers */
  { "r1", 1 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "r16", 16 },
  { "r17", 17 },
  { "r18", 18 },
  { "r19", 19 },
  { "r2", 2 },
  { "r20", 20 },
  { "r21", 21 },
  { "r22", 22 },
  { "r23", 23 },
  { "r24", 24 },
  { "r25", 25 },
  { "r26", 26 },
  { "r27", 27 },
  { "r28", 28 },
  { "r29", 29 },
  { "r3", 3 },
  { "r30", 30 },
  { "r31", 31 },
  { "r4", 4 },
  { "r5", 5 },
  { "r6", 6 },
  { "r7", 7 },
  { "r8", 8 },
  { "r9", 9 },

  { "rtoc", 2 },  /* Table of contents */

  { "sdr1", 25 }, /* Storage Description Register 1 */

  { "sp", 1 },

  { "srr0", 26 }, /* Machine Status Save/Restore Register 0 */
  { "srr1", 27 }, /* Machine Status Save/Restore Register 1 */

  { "v.0", 0 },     /* Vector registers */
  { "v.1", 1 },
  { "v.10", 10 },
  { "v.11", 11 },
  { "v.12", 12 },
  { "v.13", 13 },
  { "v.14", 14 },
  { "v.15", 15 },
  { "v.16", 16 },
  { "v.17", 17 },
  { "v.18", 18 },
  { "v.19", 19 },
  { "v.2", 2 },
  { "v.20", 20 },
  { "v.21", 21 },
  { "v.22", 22 },
  { "v.23", 23 },
  { "v.24", 24 },
  { "v.25", 25 },
  { "v.26", 26 },
  { "v.27", 27 },
  { "v.28", 28 },
  { "v.29", 29 },
  { "v.3", 3 },
  { "v.30", 30 },
  { "v.31", 31 },
  { "v.4", 4 },
  { "v.5", 5 },
  { "v.6", 6 },
  { "v.7", 7 },
  { "v.8", 8 },
  { "v.9", 9 },

  { "v0", 0 },
  { "v1", 1 },
  { "v10", 10 },
  { "v11", 11 },
  { "v12", 12 },
  { "v13", 13 },
  { "v14", 14 },
  { "v15", 15 },
  { "v16", 16 },
  { "v17", 17 },
  { "v18", 18 },
  { "v19", 19 },
  { "v2", 2 },
  { "v20", 20 },
  { "v21", 21 },
  { "v22", 22 },
  { "v23", 23 },
  { "v24", 24 },
  { "v25", 25 },
  { "v26", 26 },
  { "v27", 27 },
  { "v28", 28 },
  { "v29", 29 },
  { "v3", 3 },
  { "v30", 30 },
  { "v31", 31 },
  { "v4", 4 },
  { "v5", 5 },
  { "v6", 6 },
  { "v7", 7 },
  { "v8", 8 },
  { "v9", 9 },

  { "xer", 1 },

};

#define REG_NAME_CNT	(sizeof (pre_defined_registers) / sizeof (struct pd_reg))

/* Given NAME, find the register number associated with that name, return
   the integer value associated with the given name or -1 on failure.  */

static int reg_name_search
  PARAMS ((const struct pd_reg *, int, const char * name));

static int
reg_name_search (regs, regcount, name)
     const struct pd_reg *regs;
     int regcount;
     const char *name;
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return regs[middle].value;
    }
  while (low <= high);

  return -1;
}

/*
 * Summary of register_name.
 *
 * in:	Input_line_pointer points to 1st char of operand.
 *
 * out:	A expressionS.
 *      The operand may have been a register: in this case, X_op == O_register,
 *      X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in its
 *      original state.
 */

static bfd_boolean
register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;
  if (name[0] == '%' && ISALPHA (name[1]))
    name = ++input_line_pointer;

  else if (!reg_names_p || !ISALPHA (name[0]))
    return FALSE;

  c = get_symbol_end ();
  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

/* This function is called for each symbol seen in an expression.  It
   handles the special parsing which PowerPC assemblers are supposed
   to use for condition codes.  */

/* Whether to do the special parsing.  */
static bfd_boolean cr_operand;

/* Names to recognize in a condition code.  This table is sorted.  */
static const struct pd_reg cr_names[] =
{
  { "cr0", 0 },
  { "cr1", 1 },
  { "cr2", 2 },
  { "cr3", 3 },
  { "cr4", 4 },
  { "cr5", 5 },
  { "cr6", 6 },
  { "cr7", 7 },
  { "eq", 2 },
  { "gt", 1 },
  { "lt", 0 },
  { "so", 3 },
  { "un", 3 }
};

/* Parsing function.  This returns non-zero if it recognized an
   expression.  */

int
ppc_parse_name (name, expr)
     const char *name;
     expressionS *expr;
{
  int val;

  if (! cr_operand)
    return 0;

  val = reg_name_search (cr_names, sizeof cr_names / sizeof cr_names[0],
			 name);
  if (val < 0)
    return 0;

  expr->X_op = O_constant;
  expr->X_add_number = val;

  return 1;
}

/* Local variables.  */

/* The type of processor we are assembling for.  This is one or more
   of the PPC_OPCODE flags defined in opcode/ppc.h.  */
static unsigned long ppc_cpu = 0;

/* Whether to target xcoff64/elf64.  */
static unsigned int ppc_obj64 = BFD_DEFAULT_TARGET_SIZE == 64;

/* Opcode hash table.  */
static struct hash_control *ppc_hash;

/* Macro hash table.  */
static struct hash_control *ppc_macro_hash;

#ifdef OBJ_ELF
/* What type of shared library support to use.  */
static enum { SHLIB_NONE, SHLIB_PIC, SHLIB_MRELOCATABLE } shlib = SHLIB_NONE;

/* Flags to set in the elf header.  */
static flagword ppc_flags = 0;

/* Whether this is Solaris or not.  */
#ifdef TARGET_SOLARIS_COMMENT
#define SOLARIS_P TRUE
#else
#define SOLARIS_P FALSE
#endif

static bfd_boolean msolaris = SOLARIS_P;
#endif

#ifdef OBJ_XCOFF

/* The RS/6000 assembler uses the .csect pseudo-op to generate code
   using a bunch of different sections.  These assembler sections,
   however, are all encompassed within the .text or .data sections of
   the final output file.  We handle this by using different
   subsegments within these main segments.  */

/* Next subsegment to allocate within the .text segment.  */
static subsegT ppc_text_subsegment = 2;

/* Linked list of csects in the text section.  */
static symbolS *ppc_text_csects;

/* Next subsegment to allocate within the .data segment.  */
static subsegT ppc_data_subsegment = 2;

/* Linked list of csects in the data section.  */
static symbolS *ppc_data_csects;

/* The current csect.  */
static symbolS *ppc_current_csect;

/* The RS/6000 assembler uses a TOC which holds addresses of functions
   and variables.  Symbols are put in the TOC with the .tc pseudo-op.
   A special relocation is used when accessing TOC entries.  We handle
   the TOC as a subsegment within the .data segment.  We set it up if
   we see a .toc pseudo-op, and save the csect symbol here.  */
static symbolS *ppc_toc_csect;

/* The first frag in the TOC subsegment.  */
static fragS *ppc_toc_frag;

/* The first frag in the first subsegment after the TOC in the .data
   segment.  NULL if there are no subsegments after the TOC.  */
static fragS *ppc_after_toc_frag;

/* The current static block.  */
static symbolS *ppc_current_block;

/* The COFF debugging section; set by md_begin.  This is not the
   .debug section, but is instead the secret BFD section which will
   cause BFD to set the section number of a symbol to N_DEBUG.  */
static asection *ppc_coff_debug_section;

#endif /* OBJ_XCOFF */

#ifdef TE_PE

/* Various sections that we need for PE coff support.  */
static segT ydata_section;
static segT pdata_section;
static segT reldata_section;
static segT rdata_section;
static segT tocdata_section;

/* The current section and the previous section. See ppc_previous.  */
static segT ppc_previous_section;
static segT ppc_current_section;

#endif /* TE_PE */

#ifdef OBJ_ELF
symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE" */
#define PPC_APUINFO_ISEL	0x40
#define PPC_APUINFO_PMR		0x41
#define PPC_APUINFO_RFMCI	0x42
#define PPC_APUINFO_CACHELCK	0x43
#define PPC_APUINFO_SPE		0x100
#define PPC_APUINFO_EFS		0x101
#define PPC_APUINFO_BRLOCK	0x102

/*
 * We keep a list of APUinfo
 */
unsigned long *ppc_apuinfo_list;
unsigned int ppc_apuinfo_num;
unsigned int ppc_apuinfo_num_alloc;
#endif /* OBJ_ELF */

#ifdef OBJ_ELF
const char *const md_shortopts = "b:l:usm:K:VQ:";
#else
const char *const md_shortopts = "um:";
#endif
const struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
};
const size_t md_longopts_size = sizeof (md_longopts);


/* Handle -m options that set cpu type, and .machine arg.  */

static int
parse_cpu (const char *arg)
{
  /* -mpwrx and -mpwr2 mean to assemble for the IBM POWER/2
     (RIOS2).  */
  if (strcmp (arg, "pwrx") == 0 || strcmp (arg, "pwr2") == 0)
    ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_POWER2 | PPC_OPCODE_32;
  /* -mpwr means to assemble for the IBM POWER (RIOS1).  */
  else if (strcmp (arg, "pwr") == 0)
    ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
  /* -m601 means to assemble for the PowerPC 601, which includes
     instructions that are holdovers from the Power.  */
  else if (strcmp (arg, "601") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_601 | PPC_OPCODE_32);
  /* -mppc, -mppc32, -m603, and -m604 mean to assemble for the
     PowerPC 603/604.  */
  else if (strcmp (arg, "ppc") == 0
	   || strcmp (arg, "ppc32") == 0
	   || strcmp (arg, "603") == 0
	   || strcmp (arg, "604") == 0)
    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
  /* -m403 and -m405 mean to assemble for the PowerPC 403/405.  */
  else if (strcmp (arg, "403") == 0
	   || strcmp (arg, "405") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_403 | PPC_OPCODE_32);
  else if (strcmp (arg, "440") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32
	       | PPC_OPCODE_440 | PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI);
  else if (strcmp (arg, "7400") == 0
	   || strcmp (arg, "7410") == 0
	   || strcmp (arg, "7450") == 0
	   || strcmp (arg, "7455") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_ALTIVEC | PPC_OPCODE_32);
  else if (strcmp (arg, "altivec") == 0)
    {
      if (ppc_cpu == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_ALTIVEC;
      else
	ppc_cpu |= PPC_OPCODE_ALTIVEC;
    }
  else if (strcmp (arg, "e500") == 0 || strcmp (arg, "e500x2") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
		 | PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
		 | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
		 | PPC_OPCODE_RFMCI);
    }
  else if (strcmp (arg, "spe") == 0)
    {
      if (ppc_cpu == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_SPE | PPC_OPCODE_EFS;
      else
	ppc_cpu |= PPC_OPCODE_SPE;
    }
  /* -mppc64 and -m620 mean to assemble for the 64-bit PowerPC
     620.  */
  else if (strcmp (arg, "ppc64") == 0 || strcmp (arg, "620") == 0)
    {
      ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
    }
  else if (strcmp (arg, "ppc64bridge") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_64_BRIDGE | PPC_OPCODE_64);
    }
  /* -mbooke/-mbooke32 mean enable 32-bit BookE support.  */
  else if (strcmp (arg, "booke") == 0 || strcmp (arg, "booke32") == 0)
    {
      ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32;
    }
  /* -mbooke64 means enable 64-bit BookE support.  */
  else if (strcmp (arg, "booke64") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE
		 | PPC_OPCODE_BOOKE64 | PPC_OPCODE_64);
    }
  else if (strcmp (arg, "power4") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_64 | PPC_OPCODE_POWER4);
    }
  /* -mcom means assemble for the common intersection between Power
     and PowerPC.  At present, we just allow the union, rather
     than the intersection.  */
  else if (strcmp (arg, "com") == 0)
    ppc_cpu = PPC_OPCODE_COMMON | PPC_OPCODE_32;
  /* -many means to assemble for any architecture (PWR/PWRX/PPC).  */
  else if (strcmp (arg, "any") == 0)
    ppc_cpu |= PPC_OPCODE_ANY;
  else
    return 0;

  return 1;
}

int
md_parse_option (c, arg)
     int c;
     char *arg;
{
  switch (c)
    {
    case 'u':
      /* -u means that any undefined symbols should be treated as
	 external, which is the default for gas anyhow.  */
      break;

#ifdef OBJ_ELF
    case 'l':
      /* Solaris as takes -le (presumably for little endian).  For completeness
	 sake, recognize -be also.  */
      if (strcmp (arg, "e") == 0)
	{
	  target_big_endian = 0;
	  set_target_endian = 1;
	}
      else
	return 0;

      break;

    case 'b':
      if (strcmp (arg, "e") == 0)
	{
	  target_big_endian = 1;
	  set_target_endian = 1;
	}
      else
	return 0;

      break;

    case 'K':
      /* Recognize -K PIC.  */
      if (strcmp (arg, "PIC") == 0 || strcmp (arg, "pic") == 0)
	{
	  shlib = SHLIB_PIC;
	  ppc_flags |= EF_PPC_RELOCATABLE_LIB;
	}
      else
	return 0;

      break;
#endif

      /* a64 and a32 determine whether to use XCOFF64 or XCOFF32.  */
    case 'a':
      if (strcmp (arg, "64") == 0)
	{
#ifdef BFD64
	  ppc_obj64 = 1;
#else
	  as_fatal (_("%s unsupported"), "-a64");
#endif
	}
      else if (strcmp (arg, "32") == 0)
	ppc_obj64 = 0;
      else
	return 0;
      break;

    case 'm':
      if (parse_cpu (arg))
	;

      else if (strcmp (arg, "regnames") == 0)
	reg_names_p = TRUE;

      else if (strcmp (arg, "no-regnames") == 0)
	reg_names_p = FALSE;

#ifdef OBJ_ELF
      /* -mrelocatable/-mrelocatable-lib -- warn about initializations
	 that require relocation.  */
      else if (strcmp (arg, "relocatable") == 0)
	{
	  shlib = SHLIB_MRELOCATABLE;
	  ppc_flags |= EF_PPC_RELOCATABLE;
	}

      else if (strcmp (arg, "relocatable-lib") == 0)
	{
	  shlib = SHLIB_MRELOCATABLE;
	  ppc_flags |= EF_PPC_RELOCATABLE_LIB;
	}

      /* -memb, set embedded bit.  */
      else if (strcmp (arg, "emb") == 0)
	ppc_flags |= EF_PPC_EMB;

      /* -mlittle/-mbig set the endianess.  */
      else if (strcmp (arg, "little") == 0
	       || strcmp (arg, "little-endian") == 0)
	{
	  target_big_endian = 0;
	  set_target_endian = 1;
	}

      else if (strcmp (arg, "big") == 0 || strcmp (arg, "big-endian") == 0)
	{
	  target_big_endian = 1;
	  set_target_endian = 1;
	}

      else if (strcmp (arg, "solaris") == 0)
	{
	  msolaris = TRUE;
	  ppc_comment_chars = ppc_solaris_comment_chars;
	}

      else if (strcmp (arg, "no-solaris") == 0)
	{
	  msolaris = FALSE;
	  ppc_comment_chars = ppc_eabi_comment_chars;
	}
#endif
      else
	{
	  as_bad (_("invalid switch -m%s"), arg);
	  return 0;
	}
      break;

#ifdef OBJ_ELF
      /* -V: SVR4 argument to print version ID.  */
    case 'V':
      print_version_id ();
      break;

      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
	 should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

      /* Solaris takes -s to specify that .stabs go in a .stabs section,
	 rather than .stabs.excl, which is ignored by the linker.
	 FIXME: Not implemented.  */
    case 's':
      if (arg)
	return 0;

      break;
#endif

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (stream)
     FILE *stream;
{
  fprintf (stream, _("\
PowerPC options:\n\
-a32			generate ELF32/XCOFF32\n\
-a64			generate ELF64/XCOFF64\n\
-u			ignored\n\
-mpwrx, -mpwr2		generate code for POWER/2 (RIOS2)\n\
-mpwr			generate code for POWER (RIOS1)\n\
-m601			generate code for PowerPC 601\n\
-mppc, -mppc32, -m603, -m604\n\
			generate code for PowerPC 603/604\n\
-m403, -m405		generate code for PowerPC 403/405\n\
-m440			generate code for PowerPC 440\n\
-m7400, -m7410, -m7450, -m7455\n\
			generate code For PowerPC 7400/7410/7450/7455\n"));
  fprintf (stream, _("\
-mppc64, -m620		generate code for PowerPC 620/625/630\n\
-mppc64bridge		generate code for PowerPC 64, including bridge insns\n\
-mbooke64		generate code for 64-bit PowerPC BookE\n\
-mbooke, mbooke32	generate code for 32-bit PowerPC BookE\n\
-mpower4		generate code for Power4 architecture\n\
-mcom			generate code Power/PowerPC common instructions\n\
-many			generate code for any architecture (PWR/PWRX/PPC)\n"));
  fprintf (stream, _("\
-maltivec		generate code for AltiVec\n\
-me500, -me500x2	generate code for Motorola e500 core complex\n\
-mspe			generate code for Motorola SPE instructions\n\
-mregnames		Allow symbolic names for registers\n\
-mno-regnames		Do not allow symbolic names for registers\n"));
#ifdef OBJ_ELF
  fprintf (stream, _("\
-mrelocatable		support for GCC's -mrelocatble option\n\
-mrelocatable-lib	support for GCC's -mrelocatble-lib option\n\
-memb			set PPC_EMB bit in ELF flags\n\
-mlittle, -mlittle-endian, -l, -le\n\
			generate code for a little endian machine\n\
-mbig, -mbig-endian, -b, -be\n\
			generate code for a big endian machine\n\
-msolaris		generate code for Solaris\n\
-mno-solaris		do not generate code for Solaris\n\
-V			print assembler version number\n\
-Qy, -Qn		ignored\n"));
#endif
}

/* Set ppc_cpu if it is not already set.  */

static void
ppc_set_cpu ()
{
  const char *default_os  = TARGET_OS;
  const char *default_cpu = TARGET_CPU;

  if ((ppc_cpu & ~PPC_OPCODE_ANY) == 0)
    {
      if (ppc_obj64)
	ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
      else if (strncmp (default_os, "aix", 3) == 0
	       && default_os[3] >= '4' && default_os[3] <= '9')
	ppc_cpu |= PPC_OPCODE_COMMON | PPC_OPCODE_32;
      else if (strncmp (default_os, "aix3", 4) == 0)
	ppc_cpu |= PPC_OPCODE_POWER | PPC_OPCODE_32;
      else if (strcmp (default_cpu, "rs6000") == 0)
	ppc_cpu |= PPC_OPCODE_POWER | PPC_OPCODE_32;
      else if (strncmp (default_cpu, "powerpc", 7) == 0)
	{
	  if (default_cpu[7] == '6' && default_cpu[8] == '4')
	    ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
	  else
	    ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
	}
      else
	as_fatal (_("Unknown default cpu = %s, os = %s"),
		  default_cpu, default_os);
    }
}

/* Figure out the BFD architecture to use.  */

enum bfd_architecture
ppc_arch ()
{
  const char *default_cpu = TARGET_CPU;
  ppc_set_cpu ();

  if ((ppc_cpu & PPC_OPCODE_PPC) != 0)
    return bfd_arch_powerpc;
  else if ((ppc_cpu & PPC_OPCODE_POWER) != 0)
    return bfd_arch_rs6000;
  else if ((ppc_cpu & (PPC_OPCODE_COMMON | PPC_OPCODE_ANY)) != 0)
    {
      if (strcmp (default_cpu, "rs6000") == 0)
	return bfd_arch_rs6000;
      else if (strncmp (default_cpu, "powerpc", 7) == 0)
	return bfd_arch_powerpc;
    }

  as_fatal (_("Neither Power nor PowerPC opcodes were selected."));
  return bfd_arch_unknown;
}

unsigned long
ppc_mach ()
{
  if (ppc_obj64)
    return bfd_mach_ppc64;
  else if (ppc_arch () == bfd_arch_rs6000)
    return bfd_mach_rs6k;
  else
    return bfd_mach_ppc;
}

extern char*
ppc_target_format ()
{
#ifdef OBJ_COFF
#ifdef TE_PE
  return target_big_endian ? "pe-powerpc" : "pe-powerpcle";
#elif TE_POWERMAC
  return "xcoff-powermac";
#else
#  ifdef TE_AIX5
    return (ppc_obj64 ? "aix5coff64-rs6000" : "aixcoff-rs6000");
#  else
    return (ppc_obj64 ? "aixcoff64-rs6000" : "aixcoff-rs6000");
#  endif
#endif
#endif
#ifdef OBJ_ELF
  return (target_big_endian
	  ? (ppc_obj64 ? "elf64-powerpc" : "elf32-powerpc")
	  : (ppc_obj64 ? "elf64-powerpcle" : "elf32-powerpcle"));
#endif
}

/* Insert opcodes and macros into hash tables.  Called at startup and
   for .cpu pseudo.  */

static void
ppc_setup_opcodes (void)
{
  register const struct powerpc_opcode *op;
  const struct powerpc_opcode *op_end;
  const struct powerpc_macro *macro;
  const struct powerpc_macro *macro_end;
  bfd_boolean dup_insn = FALSE;

  if (ppc_hash != NULL)
    hash_die (ppc_hash);
  if (ppc_macro_hash != NULL)
    hash_die (ppc_macro_hash);

  /* Insert the opcodes into a hash table.  */
  ppc_hash = hash_new ();

  op_end = powerpc_opcodes + powerpc_num_opcodes;
  for (op = powerpc_opcodes; op < op_end; op++)
    {
      know ((op->opcode & op->mask) == op->opcode);

      if ((op->flags & ppc_cpu & ~(PPC_OPCODE_32 | PPC_OPCODE_64)) != 0
	  && ((op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64)) == 0
	      || ((op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64))
		  == (ppc_cpu & (PPC_OPCODE_32 | PPC_OPCODE_64)))
	      || (ppc_cpu & PPC_OPCODE_64_BRIDGE) != 0)
	  /* Certain instructions (eg: extsw) do not exist in the
	     32-bit BookE instruction set, but they do exist in the
	     64-bit BookE instruction set, and other PPC instruction
	     sets.  Check to see if the opcode has the BOOKE64 flag set.
	     If it does make sure that the target CPU is not the BookE32.  */
	  && ((op->flags & PPC_OPCODE_BOOKE64) == 0
	      || (ppc_cpu & PPC_OPCODE_BOOKE64) == PPC_OPCODE_BOOKE64
	      || (ppc_cpu & PPC_OPCODE_BOOKE) == 0)
	  && ((op->flags & (PPC_OPCODE_POWER4 | PPC_OPCODE_NOPOWER4)) == 0
	      || ((op->flags & PPC_OPCODE_POWER4)
		  == (ppc_cpu & PPC_OPCODE_POWER4))))
	{
	  const char *retval;

	  retval = hash_insert (ppc_hash, op->name, (PTR) op);
	  if (retval != NULL)
	    {
	      /* Ignore Power duplicates for -m601.  */
	      if ((ppc_cpu & PPC_OPCODE_601) != 0
		  && (op->flags & PPC_OPCODE_POWER) != 0)
		continue;

	      as_bad (_("Internal assembler error for instruction %s"),
		      op->name);
	      dup_insn = TRUE;
	    }
	}
    }

  if ((ppc_cpu & PPC_OPCODE_ANY) != 0)
    for (op = powerpc_opcodes; op < op_end; op++)
      hash_insert (ppc_hash, op->name, (PTR) op);

  /* Insert the macros into a hash table.  */
  ppc_macro_hash = hash_new ();

  macro_end = powerpc_macros + powerpc_num_macros;
  for (macro = powerpc_macros; macro < macro_end; macro++)
    {
      if ((macro->flags & ppc_cpu) != 0)
	{
	  const char *retval;

	  retval = hash_insert (ppc_macro_hash, macro->name, (PTR) macro);
	  if (retval != (const char *) NULL)
	    {
	      as_bad (_("Internal assembler error for macro %s"), macro->name);
	      dup_insn = TRUE;
	    }
	}
    }

  if (dup_insn)
    abort ();
}

/* This function is called when the assembler starts up.  It is called
   after the options have been parsed and the output file has been
   opened.  */

void
md_begin ()
{
  ppc_set_cpu ();

  ppc_cie_data_alignment = ppc_obj64 ? -8 : -4;

#ifdef OBJ_ELF
  /* Set the ELF flags if desired.  */
  if (ppc_flags && !msolaris)
    bfd_set_private_flags (stdoutput, ppc_flags);
#endif

  ppc_setup_opcodes ();

  /* Tell the main code what the endianness is if it is not overridden
     by the user.  */
  if (!set_target_endian)
    {
      set_target_endian = 1;
      target_big_endian = PPC_BIG_ENDIAN;
    }

#ifdef OBJ_XCOFF
  ppc_coff_debug_section = coff_section_from_bfd_index (stdoutput, N_DEBUG);

  /* Create dummy symbols to serve as initial csects.  This forces the
     text csects to precede the data csects.  These symbols will not
     be output.  */
  ppc_text_csects = symbol_make ("dummy\001");
  symbol_get_tc (ppc_text_csects)->within = ppc_text_csects;
  ppc_data_csects = symbol_make ("dummy\001");
  symbol_get_tc (ppc_data_csects)->within = ppc_data_csects;
#endif

#ifdef TE_PE

  ppc_current_section = text_section;
  ppc_previous_section = 0;

#endif
}

void
ppc_cleanup ()
{
#ifdef OBJ_ELF
  if (ppc_apuinfo_list == NULL)
    return;

  /* Ok, so write the section info out.  We have this layout:

  byte	data		what
  ----	----		----
  0	8		length of "APUinfo\0"
  4	(n*4)		number of APU's (4 bytes each)
  8	2		note type 2
  12	"APUinfo\0"	name
  20	APU#1		first APU's info
  24	APU#2		second APU's info
  ...	...
  */
  {
    char *p;
    asection *seg = now_seg;
    subsegT subseg = now_subseg;
    asection *apuinfo_secp = (asection *) NULL;
    unsigned int i;

    /* Create the .PPC.EMB.apuinfo section.  */
    apuinfo_secp = subseg_new (".PPC.EMB.apuinfo", 0);
    bfd_set_section_flags (stdoutput,
			   apuinfo_secp,
			   SEC_HAS_CONTENTS | SEC_READONLY);

    p = frag_more (4);
    md_number_to_chars (p, (valueT) 8, 4);

    p = frag_more (4);
    md_number_to_chars (p, (valueT) ppc_apuinfo_num * 4, 4);

    p = frag_more (4);
    md_number_to_chars (p, (valueT) 2, 4);

    p = frag_more (8);
    strcpy (p, "APUinfo");

    for (i = 0; i < ppc_apuinfo_num; i++)
      {
	p = frag_more (4);
	md_number_to_chars (p, (valueT) ppc_apuinfo_list[i], 4);
      }

    frag_align (2, 0, 0);

    /* We probably can't restore the current segment, for there likely
       isn't one yet...  */
    if (seg && subseg)
      subseg_set (seg, subseg);
  }
#endif
}

/* Insert an operand value into an instruction.  */

static unsigned long
ppc_insert_operand (insn, operand, val, file, line)
     unsigned long insn;
     const struct powerpc_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
{
  if (operand->bits != 32)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & PPC_OPERAND_SIGNED) != 0)
	{
	  if ((operand->flags & PPC_OPERAND_SIGNOPT) != 0)
	    max = (1 << operand->bits) - 1;
	  else
	    max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));

	  if (!ppc_obj64)
	    {
	      /* Some people write 32 bit hex constants with the sign
		 extension done by hand.  This shouldn't really be
		 valid, but, to permit this code to assemble on a 64
		 bit host, we sign extend the 32 bit value.  */
	      if (val > 0
		  && (val & (offsetT) 0x80000000) != 0
		  && (val & (offsetT) 0xffffffff) == val)
		{
		  val -= 0x80000000;
		  val -= 0x80000000;
		}
	    }
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      if ((operand->flags & PPC_OPERAND_NEGATIVE) != 0)
	test = - val;
      else
	test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	{
	  const char *err =
	    _("operand out of range (%s not between %ld and %ld)");
	  char buf[100];

	  sprint_value (buf, test);
	  as_bad_where (file, line, err, buf, min, max);
	}
    }

  if (operand->insert)
    {
      const char *errmsg;

      errmsg = NULL;
      insn = (*operand->insert) (insn, (long) val, ppc_cpu, &errmsg);
      if (errmsg != (const char *) NULL)
	as_bad_where (file, line, errmsg);
    }
  else
    insn |= (((long) val & ((1 << operand->bits) - 1))
	     << operand->shift);

  return insn;
}


#ifdef OBJ_ELF
/* Parse @@got, etc. and return the desired relocation.  */
static bfd_reloc_code_real_type
ppc_elf_suffix (str_p, exp_p)
     char **str_p;
     expressionS *exp_p;
{
  struct map_bfd {
    char *string;
    unsigned int length : 8;
    unsigned int valid32 : 1;
    unsigned int valid64 : 1;
    unsigned int reloc;
  };

  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;
  const struct map_bfd *ptr;

#define MAP(str, reloc)   { str, sizeof (str) - 1, 1, 1, reloc }
#define MAP32(str, reloc) { str, sizeof (str) - 1, 1, 0, reloc }
#define MAP64(str, reloc) { str, sizeof (str) - 1, 0, 1, reloc }

  static const struct map_bfd mapping[] = {
    MAP ("l",			BFD_RELOC_LO16),
    MAP ("h",			BFD_RELOC_HI16),
    MAP ("ha",			BFD_RELOC_HI16_S),
    MAP ("brtaken",		BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",		BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",			BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",		BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",		BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",		BFD_RELOC_HI16_S_GOTOFF),
    MAP ("plt@@l",		BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",		BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",		BFD_RELOC_HI16_S_PLTOFF),
    MAP ("copy",		BFD_RELOC_PPC_COPY),
    MAP ("globdat",		BFD_RELOC_PPC_GLOB_DAT),
    MAP ("sectoff",		BFD_RELOC_16_BASEREL),
    MAP ("sectoff@@l",		BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",		BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",		BFD_RELOC_HI16_S_BASEREL),
    MAP ("tls",			BFD_RELOC_PPC_TLS),
    MAP ("dtpmod",		BFD_RELOC_PPC_DTPMOD),
    MAP ("dtprel",		BFD_RELOC_PPC_DTPREL),
    MAP ("dtprel@@l",		BFD_RELOC_PPC_DTPREL16_LO),
    MAP ("dtprel@@h",		BFD_RELOC_PPC_DTPREL16_HI),
    MAP ("dtprel@@ha",		BFD_RELOC_PPC_DTPREL16_HA),
    MAP ("tprel",		BFD_RELOC_PPC_TPREL),
    MAP ("tprel@@l",		BFD_RELOC_PPC_TPREL16_LO),
    MAP ("tprel@@h",		BFD_RELOC_PPC_TPREL16_HI),
    MAP ("tprel@@ha",		BFD_RELOC_PPC_TPREL16_HA),
    MAP ("got@@tlsgd",		BFD_RELOC_PPC_GOT_TLSGD16),
    MAP ("got@@tlsgd@@l",		BFD_RELOC_PPC_GOT_TLSGD16_LO),
    MAP ("got@@tlsgd@@h",		BFD_RELOC_PPC_GOT_TLSGD16_HI),
    MAP ("got@@tlsgd@@ha",	BFD_RELOC_PPC_GOT_TLSGD16_HA),
    MAP ("got@@tlsld",		BFD_RELOC_PPC_GOT_TLSLD16),
    MAP ("got@@tlsld@@l",		BFD_RELOC_PPC_GOT_TLSLD16_LO),
    MAP ("got@@tlsld@@h",		BFD_RELOC_PPC_GOT_TLSLD16_HI),
    MAP ("got@@tlsld@@ha",	BFD_RELOC_PPC_GOT_TLSLD16_HA),
    MAP ("got@@dtprel",		BFD_RELOC_PPC_GOT_DTPREL16),
    MAP ("got@@dtprel@@l",	BFD_RELOC_PPC_GOT_DTPREL16_LO),
    MAP ("got@@dtprel@@h",	BFD_RELOC_PPC_GOT_DTPREL16_HI),
    MAP ("got@@dtprel@@ha",	BFD_RELOC_PPC_GOT_DTPREL16_HA),
    MAP ("got@@tprel",		BFD_RELOC_PPC_GOT_TPREL16),
    MAP ("got@@tprel@@l",		BFD_RELOC_PPC_GOT_TPREL16_LO),
    MAP ("got@@tprel@@h",		BFD_RELOC_PPC_GOT_TPREL16_HI),
    MAP ("got@@tprel@@ha",	BFD_RELOC_PPC_GOT_TPREL16_HA),
    MAP32 ("fixup",		BFD_RELOC_CTOR),
    MAP32 ("plt",		BFD_RELOC_24_PLT_PCREL),
    MAP32 ("pltrel24",		BFD_RELOC_24_PLT_PCREL),
    MAP32 ("local24pc",		BFD_RELOC_PPC_LOCAL24PC),
    MAP32 ("local",		BFD_RELOC_PPC_LOCAL24PC),
    MAP32 ("pltrel",		BFD_RELOC_32_PLT_PCREL),
    MAP32 ("sdarel",		BFD_RELOC_GPREL16),
    MAP32 ("naddr",		BFD_RELOC_PPC_EMB_NADDR32),
    MAP32 ("naddr16",		BFD_RELOC_PPC_EMB_NADDR16),
    MAP32 ("naddr@@l",		BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP32 ("naddr@@h",		BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP32 ("naddr@@ha",		BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP32 ("sdai16",		BFD_RELOC_PPC_EMB_SDAI16),
    MAP32 ("sda2rel",		BFD_RELOC_PPC_EMB_SDA2REL),
    MAP32 ("sda2i16",		BFD_RELOC_PPC_EMB_SDA2I16),
    MAP32 ("sda21",		BFD_RELOC_PPC_EMB_SDA21),
    MAP32 ("mrkref",		BFD_RELOC_PPC_EMB_MRKREF),
    MAP32 ("relsect",		BFD_RELOC_PPC_EMB_RELSEC16),
    MAP32 ("relsect@@l",		BFD_RELOC_PPC_EMB_RELST_LO),
    MAP32 ("relsect@@h",		BFD_RELOC_PPC_EMB_RELST_HI),
    MAP32 ("relsect@@ha",	BFD_RELOC_PPC_EMB_RELST_HA),
    MAP32 ("bitfld",		BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP32 ("relsda",		BFD_RELOC_PPC_EMB_RELSDA),
    MAP32 ("xgot",		BFD_RELOC_PPC_TOC16),
    MAP64 ("higher",		BFD_RELOC_PPC64_HIGHER),
    MAP64 ("highera",		BFD_RELOC_PPC64_HIGHER_S),
    MAP64 ("highest",		BFD_RELOC_PPC64_HIGHEST),
    MAP64 ("highesta",		BFD_RELOC_PPC64_HIGHEST_S),
    MAP64 ("tocbase",		BFD_RELOC_PPC64_TOC),
    MAP64 ("toc",		BFD_RELOC_PPC_TOC16),
    MAP64 ("toc@@l",		BFD_RELOC_PPC64_TOC16_LO),
    MAP64 ("toc@@h",		BFD_RELOC_PPC64_TOC16_HI),
    MAP64 ("toc@@ha",		BFD_RELOC_PPC64_TOC16_HA),
    MAP64 ("dtprel@@higher",	BFD_RELOC_PPC64_DTPREL16_HIGHER),
    MAP64 ("dtprel@@highera",	BFD_RELOC_PPC64_DTPREL16_HIGHERA),
    MAP64 ("dtprel@@highest",	BFD_RELOC_PPC64_DTPREL16_HIGHEST),
    MAP64 ("dtprel@@highesta",	BFD_RELOC_PPC64_DTPREL16_HIGHESTA),
    MAP64 ("tprel@@higher",	BFD_RELOC_PPC64_TPREL16_HIGHER),
    MAP64 ("tprel@@highera",	BFD_RELOC_PPC64_TPREL16_HIGHERA),
    MAP64 ("tprel@@highest",	BFD_RELOC_PPC64_TPREL16_HIGHEST),
    MAP64 ("tprel@@highesta",	BFD_RELOC_PPC64_TPREL16_HIGHESTA),
    { (char *) 0, 0, 0, 0,	BFD_RELOC_UNUSED }
  };

  if (*str++ != '@@')
    return BFD_RELOC_UNUSED;

  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
	&& (ISALNUM (ch) || ch == '@@'));
       ch = *++str)
    {
      *str2++ = TOLOWER (ch);
    }

  *str2 = '\0';
  len = str2 - ident;

  ch = ident[0];
  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (ch == ptr->string[0]
	&& len == ptr->length
	&& memcmp (ident, ptr->string, ptr->length) == 0
	&& (ppc_obj64 ? ptr->valid64 : ptr->valid32))
      {
	int reloc = ptr->reloc;

	if (!ppc_obj64)
	  if (exp_p->X_add_number != 0
	      && (reloc == (int) BFD_RELOC_16_GOTOFF
		  || reloc == (int) BFD_RELOC_LO16_GOTOFF
		  || reloc == (int) BFD_RELOC_HI16_GOTOFF
		  || reloc == (int) BFD_RELOC_HI16_S_GOTOFF))
	    as_warn (_("identifier+constant@@got means identifier@@got+constant"));

	/* Now check for identifier@@suffix+constant.  */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;

	    input_line_pointer = str;
	    expression (&new_exp);
	    if (new_exp.X_op == O_constant)
	      {
		exp_p->X_add_number += new_exp.X_add_number;
		str = input_line_pointer;
	      }

	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }
	*str_p = str;

	if (reloc == (int) BFD_RELOC_PPC64_TOC
	    && exp_p->X_op == O_symbol
	    && strcmp (S_GET_NAME (exp_p->X_add_symbol), ".TOC.") == 0)
	  {
	    /* Change the symbol so that the dummy .TOC. symbol can be
	       omitted from the object file.  */
	    exp_p->X_add_symbol = &abs_symbol;
	  }

	return (bfd_reloc_code_real_type) reloc;
      }

  return BFD_RELOC_UNUSED;
}

/* Like normal .long/.short/.word, except support @@got, etc.
   Clobbers input_line_pointer, checks end-of-line.  */
static void
ppc_elf_cons (nbytes)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long, 8=.llong.  */
{
  expressionS exp;
  bfd_reloc_code_real_type reloc;

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);
      if (exp.X_op == O_symbol
	  && *input_line_pointer == '@@'
	  && (reloc = ppc_elf_suffix (&input_line_pointer,
				      &exp)) != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto;
	  int size;

	  reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  size = bfd_get_reloc_size (reloc_howto);

	  if (size > nbytes)
	    {
	      as_bad (_("%s relocations do not fit in %d bytes\n"),
		      reloc_howto->name, nbytes);
	    }
	  else
	    {
	      char *p;
	      int offset;

	      p = frag_more (nbytes);
	      offset = 0;
	      if (target_big_endian)
		offset = nbytes - size;
	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  input_line_pointer--;
  demand_empty_rest_of_line ();
}

/* Solaris pseduo op to change to the .rodata section.  */
static void
ppc_elf_rdata (xxx)
     int xxx;
{
  char *save_line = input_line_pointer;
  static char section[] = ".rodata\n";

  /* Just pretend this is .section .rodata  */
  input_line_pointer = section;
  obj_elf_section (xxx);

  input_line_pointer = save_line;
}

/* Pseudo op to make file scope bss items.  */
static void
ppc_elf_lcomm (xxx)
     int xxx ATTRIBUTE_UNUSED;
{
  register char *name;
  register char c;
  register char *p;
  offsetT size;
  register symbolS *symbolP;
  offsetT align;
  segT old_sec;
  int old_subsec;
  char *pfrag;
  int align2;

  name = input_line_pointer;
  c = get_symbol_end ();

  /* just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ',' */
  if ((size = get_absolute_expression ()) < 0)
    {
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) size);
      ignore_rest_of_line ();
      return;
    }

  /* The third argument to .lcomm is the alignment.  */
  if (*input_line_pointer != ',')
    align = 8;
  else
    {
      ++input_line_pointer;
      align = get_absolute_expression ();
      if (align <= 0)
	{
	  as_warn (_("ignoring bad alignment"));
	  align = 8;
	}
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
	      S_GET_NAME (symbolP));
      ignore_rest_of_line ();
      return;
    }

  if (S_GET_VALUE (symbolP) && S_GET_VALUE (symbolP) != (valueT) size)
    {
      as_bad (_("Length of .lcomm \"%s\" is already %ld. Not changed to %ld."),
	      S_GET_NAME (symbolP),
	      (long) S_GET_VALUE (symbolP),
	      (long) size);

      ignore_rest_of_line ();
      return;
    }

  /* Allocate_bss.  */
  old_sec = now_seg;
  old_subsec = now_subseg;
  if (align)
    {
      /* Convert to a power of 2 alignment.  */
      for (align2 = 0; (align & 1) == 0; align >>= 1, ++align2);
      if (align != 1)
	{
	  as_bad (_("Common alignment not a power of 2"));
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    align2 = 0;

  record_alignment (bss_section, align2);
  subseg_set (bss_section, 0);
  if (align2)
    frag_align (align2, 0, 0);
  if (S_GET_SEGMENT (symbolP) == bss_section)
    symbol_get_frag (symbolP)->fr_symbol = 0;
  symbol_set_frag (symbolP, frag_now);
  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP, size,
		    (char *) 0);
  *pfrag = 0;
  S_SET_SIZE (symbolP, size);
  S_SET_SEGMENT (symbolP, bss_section);
  subseg_set (old_sec, old_subsec);
  demand_empty_rest_of_line ();
}

/* Validate any relocations emitted for -mrelocatable, possibly adding
   fixups for word relocations in writable segments, so we can adjust
   them at runtime.  */
static void
ppc_elf_validate_fix (fixp, seg)
     fixS *fixp;
     segT seg;
{
  if (fixp->fx_done || fixp->fx_pcrel)
    return;

  switch (shlib)
    {
    case SHLIB_NONE:
    case SHLIB_PIC:
      return;

    case SHLIB_MRELOCATABLE:
      if (fixp->fx_r_type <= BFD_RELOC_UNUSED
	  && fixp->fx_r_type != BFD_RELOC_16_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_HI16_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_LO16_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_HI16_S_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_16_BASEREL
	  && fixp->fx_r_type != BFD_RELOC_LO16_BASEREL
	  && fixp->fx_r_type != BFD_RELOC_HI16_BASEREL
	  && fixp->fx_r_type != BFD_RELOC_HI16_S_BASEREL
	  && (seg->flags & SEC_LOAD) != 0
	  && strcmp (segment_name (seg), ".got2") != 0
	  && strcmp (segment_name (seg), ".dtors") != 0
	  && strcmp (segment_name (seg), ".ctors") != 0
	  && strcmp (segment_name (seg), ".fixup") != 0
	  && strcmp (segment_name (seg), ".gcc_except_table") != 0
	  && strcmp (segment_name (seg), ".eh_frame") != 0
	  && strcmp (segment_name (seg), ".ex_shared") != 0)
	{
	  if ((seg->flags & (SEC_READONLY | SEC_CODE)) != 0
	      || fixp->fx_r_type != BFD_RELOC_CTOR)
	    {
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("Relocation cannot be done when using -mrelocatable"));
	    }
	}
      return;
    }
}

/* Prevent elf_frob_file_before_adjust removing a weak undefined
   function descriptor sym if the corresponding code sym is used.  */

void
ppc_frob_file_before_adjust ()
{
  symbolS *symp;

  if (!ppc_obj64)
    return;

  for (symp = symbol_rootP; symp; symp = symbol_next (symp))
    {
      const char *name;
      char *dotname;
      symbolS *dotsym;
      size_t len;

      name = S_GET_NAME (symp);
      if (name[0] == '.')
	continue;

      if (! S_IS_WEAK (symp)
	  || S_IS_DEFINED (symp))
	continue;

      len = strlen (name) + 1;
      dotname = xmalloc (len + 1);
      dotname[0] = '.';
      memcpy (dotname + 1, name, len);
      dotsym = symbol_find (dotname);
      free (dotname);
      if (dotsym != NULL && (symbol_used_p (dotsym)
			     || symbol_used_in_reloc_p (dotsym)))
	{
	  symbol_mark_used (symp);
	}
    }

  /* Don't emit .TOC. symbol.  */
  symp = symbol_find (".TOC.");
  if (symp != NULL)
    symbol_remove (symp, &symbol_rootP, &symbol_lastP);
}
#endif /* OBJ_ELF */

#ifdef TE_PE

/*
 * Summary of parse_toc_entry.
 *
 * in:	Input_line_pointer points to the '[' in one of:
 *
 *        [toc] [tocv] [toc32] [toc64]
 *
 *      Anything else is an error of one kind or another.
 *
 * out:
 *   return value: success or failure
 *   toc_kind:     kind of toc reference
 *   input_line_pointer:
 *     success: first char after the ']'
 *     failure: unchanged
 *
 * settings:
 *
 *     [toc]   - rv == success, toc_kind = default_toc
 *     [tocv]  - rv == success, toc_kind = data_in_toc
 *     [toc32] - rv == success, toc_kind = must_be_32
 *     [toc64] - rv == success, toc_kind = must_be_64
 *
 */

enum toc_size_qualifier
{
  default_toc, /* The toc cell constructed should be the system default size */
  data_in_toc, /* This is a direct reference to a toc cell                   */
  must_be_32,  /* The toc cell constructed must be 32 bits wide              */
  must_be_64   /* The toc cell constructed must be 64 bits wide              */
};

static int
parse_toc_entry (toc_kind)
     enum toc_size_qualifier *toc_kind;
{
  char *start;
  char *toc_spec;
  char c;
  enum toc_size_qualifier t;

  /* Save the input_line_pointer.  */
  start = input_line_pointer;

  /* Skip over the '[' , and whitespace.  */
  ++input_line_pointer;
  SKIP_WHITESPACE ();

  /* Find the spelling of the operand.  */
  toc_spec = input_line_pointer;
  c = get_symbol_end ();

  if (strcmp (toc_spec, "toc") == 0)
    {
      t = default_toc;
    }
  else if (strcmp (toc_spec, "tocv") == 0)
    {
      t = data_in_toc;
    }
  else if (strcmp (toc_spec, "toc32") == 0)
    {
      t = must_be_32;
    }
  else if (strcmp (toc_spec, "toc64") == 0)
    {
      t = must_be_64;
    }
  else
    {
      as_bad (_("syntax error: invalid toc specifier `%s'"), toc_spec);
      *input_line_pointer = c;
      input_line_pointer = start;
      return 0;
    }

  /* Now find the ']'.  */
  *input_line_pointer = c;

  SKIP_WHITESPACE ();	     /* leading whitespace could be there.  */
  c = *input_line_pointer++; /* input_line_pointer->past char in c.  */

  if (c != ']')
    {
      as_bad (_("syntax error: expected `]', found  `%c'"), c);
      input_line_pointer = start;
      return 0;
    }

  *toc_kind = t;
  return 1;
}
#endif


#ifdef OBJ_ELF
#define APUID(a,v)	((((a) & 0xffff) << 16) | ((v) & 0xffff))
static void
ppc_apuinfo_section_add (apu, version)
      unsigned int apu, version;
{
  unsigned int i;

  /* Check we don't already exist.  */
  for (i = 0; i < ppc_apuinfo_num; i++)
    if (ppc_apuinfo_list[i] == APUID (apu, version))
      return;

  if (ppc_apuinfo_num == ppc_apuinfo_num_alloc)
    {
      if (ppc_apuinfo_num_alloc == 0)
	{
	  ppc_apuinfo_num_alloc = 4;
	  ppc_apuinfo_list = (unsigned long *)
	      xmalloc (sizeof (unsigned long) * ppc_apuinfo_num_alloc);
	}
      else
	{
	  ppc_apuinfo_num_alloc += 4;
	  ppc_apuinfo_list = (unsigned long *) xrealloc (ppc_apuinfo_list,
	      sizeof (unsigned long) * ppc_apuinfo_num_alloc);
	}
    }
  ppc_apuinfo_list[ppc_apuinfo_num++] = APUID (apu, version);
}
#undef APUID
#endif


/* We need to keep a list of fixups.  We can't simply generate them as
   we go, because that would require us to first create the frag, and
   that would screw up references to ``.''.  */

struct ppc_fixup
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};

#define MAX_INSN_FIXUPS (5)

/* This routine is called for each instruction to be assembled.  */

void
md_assemble (str)
     char *str;
{
  char *s;
  const struct powerpc_opcode *opcode;
  unsigned long insn;
  const unsigned char *opindex_ptr;
  int skip_optional;
  int need_paren;
  int next_opindex;
  struct ppc_fixup fixups[MAX_INSN_FIXUPS];
  int fc;
  char *f;
  int i;
#ifdef OBJ_ELF
  bfd_reloc_code_real_type reloc;
#endif

  /* Get the opcode.  */
  for (s = str; *s != '\0' && ! ISSPACE (*s); s++)
    ;
  if (*s != '\0')
    *s++ = '\0';

  /* Look up the opcode in the hash table.  */
  opcode = (const struct powerpc_opcode *) hash_find (ppc_hash, str);
  if (opcode == (const struct powerpc_opcode *) NULL)
    {
      const struct powerpc_macro *macro;

      macro = (const struct powerpc_macro *) hash_find (ppc_macro_hash, str);
      if (macro == (const struct powerpc_macro *) NULL)
	as_bad (_("Unrecognized opcode: `%s'"), str);
      else
	ppc_macro (s, macro);

      return;
    }

  insn = opcode->opcode;

  str = s;
  while (ISSPACE (*str))
    ++str;

  /* PowerPC operands are just expressions.  The only real issue is
     that a few operand types are optional.  All cases which might use
     an optional operand separate the operands only with commas (in some
     cases parentheses are used, as in ``lwz 1,0(1)'' but such cases never
     have optional operands).  Most instructions with optional operands
     have only one.  Those that have more than one optional operand can
     take either all their operands or none.  So, before we start seriously
     parsing the operands, we check to see if we have optional operands,
     and if we do, we count the number of commas to see which operands
     have been omitted.  */
  skip_optional = 0;
  for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
    {
      const struct powerpc_operand *operand;

      operand = &powerpc_operands[*opindex_ptr];
      if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0)
	{
	  unsigned int opcount;
	  unsigned int num_operands_expected;
	  unsigned int i;

	  /* There is an optional operand.  Count the number of
	     commas in the input line.  */
	  if (*str == '\0')
	    opcount = 0;
	  else
	    {
	      opcount = 1;
	      s = str;
	      while ((s = strchr (s, ',')) != (char *) NULL)
		{
		  ++opcount;
		  ++s;
		}
	    }

	  /* Compute the number of expected operands.
	     Do not count fake operands.  */
	  for (num_operands_expected = 0, i = 0; opcode->operands[i]; i ++)
	    if ((powerpc_operands [opcode->operands[i]].flags & PPC_OPERAND_FAKE) == 0)
	      ++ num_operands_expected;

	  /* If there are fewer operands in the line then are called
	     for by the instruction, we want to skip the optional
	     operands.  */
	  if (opcount < num_operands_expected)
	    skip_optional = 1;

	  break;
	}
    }

  /* Gather the operands.  */
  need_paren = 0;
  next_opindex = 0;
  fc = 0;
  for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
    {
      const struct powerpc_operand *operand;
      const char *errmsg;
      char *hold;
      expressionS ex;
      char endc;

      if (next_opindex == 0)
	operand = &powerpc_operands[*opindex_ptr];
      else
	{
	  operand = &powerpc_operands[next_opindex];
	  next_opindex = 0;
	}
      errmsg = NULL;

      /* If this is a fake operand, then we do not expect anything
	 from the input.  */
      if ((operand->flags & PPC_OPERAND_FAKE) != 0)
	{
	  insn = (*operand->insert) (insn, 0L, ppc_cpu, &errmsg);
	  if (errmsg != (const char *) NULL)
	    as_bad (errmsg);
	  continue;
	}

      /* If this is an optional operand, and we are skipping it, just
	 insert a zero.  */
      if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0
	  && skip_optional)
	{
	  if (operand->insert)
	    {
	      insn = (*operand->insert) (insn, 0L, ppc_cpu, &errmsg);
	      if (errmsg != (const char *) NULL)
		as_bad (errmsg);
	    }
	  if ((operand->flags & PPC_OPERAND_NEXT) != 0)
	    next_opindex = *opindex_ptr + 1;
	  continue;
	}

      /* Gather the operand.  */
      hold = input_line_pointer;
      input_line_pointer = str;

#ifdef TE_PE
      if (*input_line_pointer == '[')
	{
	  /* We are expecting something like the second argument here:
	   *
	   *    lwz r4,[toc].GS.0.static_int(rtoc)
	   *           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
	   * The argument following the `]' must be a symbol name, and the
	   * register must be the toc register: 'rtoc' or '2'
	   *
	   * The effect is to 0 as the displacement field
	   * in the instruction, and issue an IMAGE_REL_PPC_TOCREL16 (or
	   * the appropriate variation) reloc against it based on the symbol.
	   * The linker will build the toc, and insert the resolved toc offset.
	   *
	   * Note:
	   * o The size of the toc entry is currently assumed to be
	   *   32 bits. This should not be assumed to be a hard coded
	   *   number.
	   * o In an effort to cope with a change from 32 to 64 bits,
	   *   there are also toc entries that are specified to be
	   *   either 32 or 64 bits:
	   *     lwz r4,[toc32].GS.0.static_int(rtoc)
	   *     lwz r4,[toc64].GS.0.static_int(rtoc)
	   *   These demand toc entries of the specified size, and the
	   *   instruction probably requires it.
	   */

	  int valid_toc;
	  enum toc_size_qualifier toc_kind;
	  bfd_reloc_code_real_type toc_reloc;

	  /* Go parse off the [tocXX] part.  */
	  valid_toc = parse_toc_entry (&toc_kind);

	  if (!valid_toc)
	    {
	      /* Note: message has already been issued.
		 FIXME: what sort of recovery should we do?
		 demand_rest_of_line (); return; ?  */
	    }

	  /* Now get the symbol following the ']'.  */
	  expression (&ex);

	  switch (toc_kind)
	    {
	    case default_toc:
	      /* In this case, we may not have seen the symbol yet,
		 since  it is allowed to appear on a .extern or .globl
		 or just be a label in the .data section.  */
	      toc_reloc = BFD_RELOC_PPC_TOC16;
	      break;
	    case data_in_toc:
	      /* 1. The symbol must be defined and either in the toc
		 section, or a global.
		 2. The reloc generated must have the TOCDEFN flag set
		 in upper bit mess of the reloc type.
		 FIXME: It's a little confusing what the tocv
		 qualifier can be used for.  At the very least, I've
		 seen three uses, only one of which I'm sure I can
		 explain.  */
	      if (ex.X_op == O_symbol)
		{
		  assert (ex.X_add_symbol != NULL);
		  if (symbol_get_bfdsym (ex.X_add_symbol)->section
		      != tocdata_section)
		    {
		      as_bad (_("[tocv] symbol is not a toc symbol"));
		    }
		}

	      toc_reloc = BFD_RELOC_PPC_TOC16;
	      break;
	    case must_be_32:
	      /* FIXME: these next two specifically specify 32/64 bit
		 toc entries.  We don't support them today.  Is this
		 the right way to say that?  */
	      toc_reloc = BFD_RELOC_UNUSED;
	      as_bad (_("Unimplemented toc32 expression modifier"));
	      break;
	    case must_be_64:
	      /* FIXME: see above.  */
	      toc_reloc = BFD_RELOC_UNUSED;
	      as_bad (_("Unimplemented toc64 expression modifier"));
	      break;
	    default:
	      fprintf (stderr,
		       _("Unexpected return value [%d] from parse_toc_entry!\n"),
		       toc_kind);
	      abort ();
	      break;
	    }

	  /* We need to generate a fixup for this expression.  */
	  if (fc >= MAX_INSN_FIXUPS)
	    as_fatal (_("too many fixups"));

	  fixups[fc].reloc = toc_reloc;
	  fixups[fc].exp = ex;
	  fixups[fc].opindex = *opindex_ptr;
	  ++fc;

	  /* Ok. We've set up the fixup for the instruction. Now make it
	     look like the constant 0 was found here.  */
	  ex.X_unsigned = 1;
	  ex.X_op = O_constant;
	  ex.X_add_number = 0;
	  ex.X_add_symbol = NULL;
	  ex.X_op_symbol = NULL;
	}

      else
#endif		/* TE_PE */
	{
	  if (! register_name (&ex))
	    {
	      if ((operand->flags & PPC_OPERAND_CR) != 0)
		cr_operand = TRUE;
	      expression (&ex);
	      cr_operand = FALSE;
	    }
	}

      str = input_line_pointer;
      input_line_pointer = hold;

      if (ex.X_op == O_illegal)
	as_bad (_("illegal operand"));
      else if (ex.X_op == O_absent)
	as_bad (_("missing operand"));
      else if (ex.X_op == O_register)
	{
	  insn = ppc_insert_operand (insn, operand, ex.X_add_number,
				     (char *) NULL, 0);
	}
      else if (ex.X_op == O_constant)
	{
#ifdef OBJ_ELF
	  /* Allow @@HA, @@L, @@H on constants.  */
	  char *orig_str = str;

	  if ((reloc = ppc_elf_suffix (&str, &ex)) != BFD_RELOC_UNUSED)
	    switch (reloc)
	      {
	      default:
		str = orig_str;
		break;

	      case BFD_RELOC_LO16:
		/* X_unsigned is the default, so if the user has done
		   something which cleared it, we always produce a
		   signed value.  */
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number &= 0xffff;
		else
		  ex.X_add_number = SEX16 (ex.X_add_number);
		break;

	      case BFD_RELOC_HI16:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HI (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HI (ex.X_add_number));
		break;

	      case BFD_RELOC_HI16_S:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HA (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HA (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHER:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHER (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHER (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHER_S:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHERA (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHERA (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHEST:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHEST (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHEST (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHEST_S:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHESTA (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHESTA (ex.X_add_number));
		break;
	      }
#endif /* OBJ_ELF */
	  insn = ppc_insert_operand (insn, operand, ex.X_add_number,
				     (char *) NULL, 0);
	}
#ifdef OBJ_ELF
      else if ((reloc = ppc_elf_suffix (&str, &ex)) != BFD_RELOC_UNUSED)
	{
	  /* Some TLS tweaks.  */
	  switch (reloc)
	    {
	    default:
	      break;
	    case BFD_RELOC_PPC_TLS:
	      insn = ppc_insert_operand (insn, operand, ppc_obj64 ? 13 : 2,
					 (char *) NULL, 0);
	      break;
	  /* We'll only use the 32 (or 64) bit form of these relocations
	     in constants.  Instructions get the 16 bit form.  */
	    case BFD_RELOC_PPC_DTPREL:
	      reloc = BFD_RELOC_PPC_DTPREL16;
	      break;
	    case BFD_RELOC_PPC_TPREL:
	      reloc = BFD_RELOC_PPC_TPREL16;
	      break;
	    }

	  /* For the absolute forms of branches, convert the PC
	     relative form back into the absolute.  */
	  if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
	    {
	      switch (reloc)
		{
		case BFD_RELOC_PPC_B26:
		  reloc = BFD_RELOC_PPC_BA26;
		  break;
		case BFD_RELOC_PPC_B16:
		  reloc = BFD_RELOC_PPC_BA16;
		  break;
		case BFD_RELOC_PPC_B16_BRTAKEN:
		  reloc = BFD_RELOC_PPC_BA16_BRTAKEN;
		  break;
		case BFD_RELOC_PPC_B16_BRNTAKEN:
		  reloc = BFD_RELOC_PPC_BA16_BRNTAKEN;
		  break;
		default:
		  break;
		}
	    }

	  if (ppc_obj64
	      && (operand->flags & (PPC_OPERAND_DS | PPC_OPERAND_DQ)) != 0)
	    {
	      switch (reloc)
		{
		case BFD_RELOC_16:
		  reloc = BFD_RELOC_PPC64_ADDR16_DS;
		  break;
		case BFD_RELOC_LO16:
		  reloc = BFD_RELOC_PPC64_ADDR16_LO_DS;
		  break;
		case BFD_RELOC_16_GOTOFF:
		  reloc = BFD_RELOC_PPC64_GOT16_DS;
		  break;
		case BFD_RELOC_LO16_GOTOFF:
		  reloc = BFD_RELOC_PPC64_GOT16_LO_DS;
		  break;
		case BFD_RELOC_LO16_PLTOFF:
		  reloc = BFD_RELOC_PPC64_PLT16_LO_DS;
		  break;
		case BFD_RELOC_16_BASEREL:
		  reloc = BFD_RELOC_PPC64_SECTOFF_DS;
		  break;
		case BFD_RELOC_LO16_BASEREL:
		  reloc = BFD_RELOC_PPC64_SECTOFF_LO_DS;
		  break;
		case BFD_RELOC_PPC_TOC16:
		  reloc = BFD_RELOC_PPC64_TOC16_DS;
		  break;
		case BFD_RELOC_PPC64_TOC16_LO:
		  reloc = BFD_RELOC_PPC64_TOC16_LO_DS;
		  break;
		case BFD_RELOC_PPC64_PLTGOT16:
		  reloc = BFD_RELOC_PPC64_PLTGOT16_DS;
		  break;
		case BFD_RELOC_PPC64_PLTGOT16_LO:
		  reloc = BFD_RELOC_PPC64_PLTGOT16_LO_DS;
		  break;
		case BFD_RELOC_PPC_DTPREL16:
		  reloc = BFD_RELOC_PPC64_DTPREL16_DS;
		  break;
		case BFD_RELOC_PPC_DTPREL16_LO:
		  reloc = BFD_RELOC_PPC64_DTPREL16_LO_DS;
		  break;
		case BFD_RELOC_PPC_TPREL16:
		  reloc = BFD_RELOC_PPC64_TPREL16_DS;
		  break;
		case BFD_RELOC_PPC_TPREL16_LO:
		  reloc = BFD_RELOC_PPC64_TPREL16_LO_DS;
		  break;
		case BFD_RELOC_PPC_GOT_DTPREL16:
		case BFD_RELOC_PPC_GOT_DTPREL16_LO:
		case BFD_RELOC_PPC_GOT_TPREL16:
		case BFD_RELOC_PPC_GOT_TPREL16_LO:
		  break;
		default:
		  as_bad (_("unsupported relocation for DS offset field"));
		  break;
		}
	    }

	  /* We need to generate a fixup for this expression.  */
	  if (fc >= MAX_INSN_FIXUPS)
	    as_fatal (_("too many fixups"));
	  fixups[fc].exp = ex;
	  fixups[fc].opindex = 0;
	  fixups[fc].reloc = reloc;
	  ++fc;
	}
#endif /* OBJ_ELF */

      else
	{
	  /* We need to generate a fixup for this expression.  */
	  if (fc >= MAX_INSN_FIXUPS)
	    as_fatal (_("too many fixups"));
	  fixups[fc].exp = ex;
	  fixups[fc].opindex = *opindex_ptr;
	  fixups[fc].reloc = BFD_RELOC_UNUSED;
	  ++fc;
	}

      if (need_paren)
	{
	  endc = ')';
	  need_paren = 0;
	}
      else if ((operand->flags & PPC_OPERAND_PARENS) != 0)
	{
	  endc = '(';
	  need_paren = 1;
	}
      else
	endc = ',';

      /* The call to expression should have advanced str past any
	 whitespace.  */
      if (*str != endc
	  && (endc != ',' || *str != '\0'))
	{
	  as_bad (_("syntax error; found `%c' but expected `%c'"), *str, endc);
	  break;
	}

      if (*str != '\0')
	++str;
    }

  while (ISSPACE (*str))
    ++str;

  if (*str != '\0')
    as_bad (_("junk at end of line: `%s'"), str);

#ifdef OBJ_ELF
  /* Do we need/want a APUinfo section? */
  if (ppc_cpu & (PPC_OPCODE_SPE
   	       | PPC_OPCODE_ISEL | PPC_OPCODE_EFS
	       | PPC_OPCODE_BRLOCK | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
	       | PPC_OPCODE_RFMCI))
    {
      /* These are all version "1".  */
      if (opcode->flags & PPC_OPCODE_SPE)
	ppc_apuinfo_section_add (PPC_APUINFO_SPE, 1);
      if (opcode->flags & PPC_OPCODE_ISEL)
	ppc_apuinfo_section_add (PPC_APUINFO_ISEL, 1);
      if (opcode->flags & PPC_OPCODE_EFS)
	ppc_apuinfo_section_add (PPC_APUINFO_EFS, 1);
      if (opcode->flags & PPC_OPCODE_BRLOCK)
	ppc_apuinfo_section_add (PPC_APUINFO_BRLOCK, 1);
      if (opcode->flags & PPC_OPCODE_PMR)
	ppc_apuinfo_section_add (PPC_APUINFO_PMR, 1);
      if (opcode->flags & PPC_OPCODE_CACHELCK)
	ppc_apuinfo_section_add (PPC_APUINFO_CACHELCK, 1);
      if (opcode->flags & PPC_OPCODE_RFMCI)
	ppc_apuinfo_section_add (PPC_APUINFO_RFMCI, 1);
    }
#endif

  /* Write out the instruction.  */
  f = frag_more (4);
  md_number_to_chars (f, insn, 4);

#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif

  /* Create any fixups.  At this point we do not use a
     bfd_reloc_code_real_type, but instead just use the
     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
     handle fixups for any operand type, although that is admittedly
     not a very exciting feature.  We pick a BFD reloc type in
     md_apply_fix3.  */
  for (i = 0; i < fc; i++)
    {
      const struct powerpc_operand *operand;

      operand = &powerpc_operands[fixups[i].opindex];
      if (fixups[i].reloc != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto;
	  int size;
	  int offset;
	  fixS *fixP;

	  reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
	  if (!reloc_howto)
	    abort ();

	  size = bfd_get_reloc_size (reloc_howto);
	  offset = target_big_endian ? (4 - size) : 0;

	  if (size < 1 || size > 4)
	    abort ();

	  fixP = fix_new_exp (frag_now,
			      f - frag_now->fr_literal + offset,
			      size,
			      &fixups[i].exp,
			      reloc_howto->pc_relative,
			      fixups[i].reloc);

	  /* Turn off complaints that the addend is too large for things like
	     foo+100000@@ha.  */
	  switch (fixups[i].reloc)
	    {
	    case BFD_RELOC_16_GOTOFF:
	    case BFD_RELOC_PPC_TOC16:
	    case BFD_RELOC_LO16:
	    case BFD_RELOC_HI16:
	    case BFD_RELOC_HI16_S:
#ifdef OBJ_ELF
	    case BFD_RELOC_PPC64_HIGHER:
	    case BFD_RELOC_PPC64_HIGHER_S:
	    case BFD_RELOC_PPC64_HIGHEST:
	    case BFD_RELOC_PPC64_HIGHEST_S:
#endif
	      fixP->fx_no_overflow = 1;
	      break;
	    default:
	      break;
	    }
	}
      else
	fix_new_exp (frag_now,
		     f - frag_now->fr_literal,
		     4,
		     &fixups[i].exp,
		     (operand->flags & PPC_OPERAND_RELATIVE) != 0,
		     ((bfd_reloc_code_real_type)
		      (fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
    }
}

/* Handle a macro.  Gather all the operands, transform them as
   described by the macro, and call md_assemble recursively.  All the
   operands are separated by commas; we don't accept parentheses
   around operands here.  */

static void
ppc_macro (str, macro)
     char *str;
     const struct powerpc_macro *macro;
{
  char *operands[10];
  unsigned int count;
  char *s;
  unsigned int len;
  const char *format;
  int arg;
  char *send;
  char *complete;

  /* Gather the users operands into the operands array.  */
  count = 0;
  s = str;
  while (1)
    {
      if (count >= sizeof operands / sizeof operands[0])
	break;
      operands[count++] = s;
      s = strchr (s, ',');
      if (s == (char *) NULL)
	break;
      *s++ = '\0';
    }

  if (count != macro->operands)
    {
      as_bad (_("wrong number of operands"));
      return;
    }

  /* Work out how large the string must be (the size is unbounded
     because it includes user input).  */
  len = 0;
  format = macro->format;
  while (*format != '\0')
    {
      if (*format != '%')
	{
	  ++len;
	  ++format;
	}
      else
	{
	  arg = strtol (format + 1, &send, 10);
	  know (send != format && arg >= 0 && arg < count);
	  len += strlen (operands[arg]);
	  format = send;
	}
    }

  /* Put the string together.  */
  complete = s = (char *) alloca (len + 1);
  format = macro->format;
  while (*format != '\0')
    {
      if (*format != '%')
	*s++ = *format++;
      else
	{
	  arg = strtol (format + 1, &send, 10);
	  strcpy (s, operands[arg]);
	  s += strlen (s);
	  format = send;
	}
    }
  *s = '\0';

  /* Assemble the constructed instruction.  */
  md_assemble (complete);
}

#ifdef OBJ_ELF
/* For ELF, add support for SHF_EXCLUDE and SHT_ORDERED.  */

int
ppc_section_letter (letter, ptr_msg)
     int letter;
     char **ptr_msg;
{
  if (letter == 'e')
    return SHF_EXCLUDE;

  *ptr_msg = _("Bad .section directive: want a,e,w,x,M,S,G,T in string");
  return -1;
}

int
ppc_section_word (str, len)
     char *str;
     size_t len;
{
  if (len == 7 && strncmp (str, "exclude", 7) == 0)
    return SHF_EXCLUDE;

  return -1;
}

int
ppc_section_type (str, len)
     char *str;
     size_t len;
{
  if (len == 7 && strncmp (str, "ordered", 7) == 0)
    return SHT_ORDERED;

  return -1;
}

int
ppc_section_flags (flags, attr, type)
     int flags;
     int attr;
     int type;
{
  if (type == SHT_ORDERED)
    flags |= SEC_ALLOC | SEC_LOAD | SEC_SORT_ENTRIES;

  if (attr & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;

  return flags;
}
#endif /* OBJ_ELF */


/* Pseudo-op handling.  */

/* The .byte pseudo-op.  This is similar to the normal .byte
   pseudo-op, but it can also take a single ASCII string.  */

static void
ppc_byte (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (*input_line_pointer != '\"')
    {
      cons (1);
      return;
    }

  /* Gather characters.  A real double quote is doubled.  Unusual
     characters are not permitted.  */
  ++input_line_pointer;
  while (1)
    {
      char c;

      c = *input_line_pointer++;

      if (c == '\"')
	{
	  if (*input_line_pointer != '\"')
	    break;
	  ++input_line_pointer;
	}

      FRAG_APPEND_1_CHAR (c);
    }

  demand_empty_rest_of_line ();
}

#ifdef OBJ_XCOFF

/* XCOFF specific pseudo-op handling.  */

/* This is set if we are creating a .stabx symbol, since we don't want
   to handle symbol suffixes for such symbols.  */
static bfd_boolean ppc_stab_symbol;

/* The .comm and .lcomm pseudo-ops for XCOFF.  XCOFF puts common
   symbols in the .bss segment as though they were local common
   symbols, and uses a different smclas.  The native Aix 4.3.3 assembler
   aligns .comm and .lcomm to 4 bytes.  */

static void
ppc_comm (lcomm)
     int lcomm;
{
  asection *current_seg = now_seg;
  subsegT current_subseg = now_subseg;
  char *name;
  char endc;
  char *end_name;
  offsetT size;
  offsetT align;
  symbolS *lcomm_sym = NULL;
  symbolS *sym;
  char *pfrag;

  name = input_line_pointer;
  endc = get_symbol_end ();
  end_name = input_line_pointer;
  *end_name = endc;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing size"));
      ignore_rest_of_line ();
      return;
    }
  ++input_line_pointer;

  size = get_absolute_expression ();
  if (size < 0)
    {
      as_bad (_("negative size"));
      ignore_rest_of_line ();
      return;
    }

  if (! lcomm)
    {
      /* The third argument to .comm is the alignment.  */
      if (*input_line_pointer != ',')
	align = 2;
      else
	{
	  ++input_line_pointer;
	  align = get_absolute_expression ();
	  if (align <= 0)
	    {
	      as_warn (_("ignoring bad alignment"));
	      align = 2;
	    }
	}
    }
  else
    {
      char *lcomm_name;
      char lcomm_endc;

      if (size <= 4)
	align = 2;
      else
	align = 3;

      /* The third argument to .lcomm appears to be the real local
	 common symbol to create.  References to the symbol named in
	 the first argument are turned into references to the third
	 argument.  */
      if (*input_line_pointer != ',')
	{
	  as_bad (_("missing real symbol name"));
	  ignore_rest_of_line ();
	  return;
	}
      ++input_line_pointer;

      lcomm_name = input_line_pointer;
      lcomm_endc = get_symbol_end ();

      lcomm_sym = symbol_find_or_make (lcomm_name);

      *input_line_pointer = lcomm_endc;
    }

  *end_name = '\0';
  sym = symbol_find_or_make (name);
  *end_name = endc;

  if (S_IS_DEFINED (sym)
      || S_GET_VALUE (sym) != 0)
    {
      as_bad (_("attempt to redefine symbol"));
      ignore_rest_of_line ();
      return;
    }

  record_alignment (bss_section, align);

  if (! lcomm
      || ! S_IS_DEFINED (lcomm_sym))
    {
      symbolS *def_sym;
      offsetT def_size;

      if (! lcomm)
	{
	  def_sym = sym;
	  def_size = size;
	  S_SET_EXTERNAL (sym);
	}
      else
	{
	  symbol_get_tc (lcomm_sym)->output = 1;
	  def_sym = lcomm_sym;
	  def_size = 0;
	}

      subseg_set (bss_section, 1);
      frag_align (align, 0, 0);

      symbol_set_frag (def_sym, frag_now);
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, def_sym,
			def_size, (char *) NULL);
      *pfrag = 0;
      S_SET_SEGMENT (def_sym, bss_section);
      symbol_get_tc (def_sym)->align = align;
    }
  else if (lcomm)
    {
      /* Align the size of lcomm_sym.  */
      symbol_get_frag (lcomm_sym)->fr_offset =
	((symbol_get_frag (lcomm_sym)->fr_offset + (1 << align) - 1)
	 &~ ((1 << align) - 1));
      if (align > symbol_get_tc (lcomm_sym)->align)
	symbol_get_tc (lcomm_sym)->align = align;
    }

  if (lcomm)
    {
      /* Make sym an offset from lcomm_sym.  */
      S_SET_SEGMENT (sym, bss_section);
      symbol_set_frag (sym, symbol_get_frag (lcomm_sym));
      S_SET_VALUE (sym, symbol_get_frag (lcomm_sym)->fr_offset);
      symbol_get_frag (lcomm_sym)->fr_offset += size;
    }

  subseg_set (current_seg, current_subseg);

  demand_empty_rest_of_line ();
}

/* The .csect pseudo-op.  This switches us into a different
   subsegment.  The first argument is a symbol whose value is the
   start of the .csect.  In COFF, csect symbols get special aux
   entries defined by the x_csect field of union internal_auxent.  The
   optional second argument is the alignment (the default is 2).  */

static void
ppc_csect (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char endc;
  symbolS *sym;
  offsetT align;

  name = input_line_pointer;
  endc = get_symbol_end ();

  sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  if (S_GET_NAME (sym)[0] == '\0')
    {
      /* An unnamed csect is assumed to be [PR].  */
      symbol_get_tc (sym)->class = XMC_PR;
    }

  align = 2;
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      align = get_absolute_expression ();
    }

  ppc_change_csect (sym, align);

  demand_empty_rest_of_line ();
}

/* Change to a different csect.  */

static void
ppc_change_csect (sym, align)
     symbolS *sym;
     offsetT align;
{
  if (S_IS_DEFINED (sym))
    subseg_set (S_GET_SEGMENT (sym), symbol_get_tc (sym)->subseg);
  else
    {
      symbolS **list_ptr;
      int after_toc;
      int hold_chunksize;
      symbolS *list;
      int is_code;
      segT sec;

      /* This is a new csect.  We need to look at the symbol class to
	 figure out whether it should go in the text section or the
	 data section.  */
      after_toc = 0;
      is_code = 0;
      switch (symbol_get_tc (sym)->class)
	{
	case XMC_PR:
	case XMC_RO:
	case XMC_DB:
	case XMC_GL:
	case XMC_XO:
	case XMC_SV:
	case XMC_TI:
	case XMC_TB:
	  S_SET_SEGMENT (sym, text_section);
	  symbol_get_tc (sym)->subseg = ppc_text_subsegment;
	  ++ppc_text_subsegment;
	  list_ptr = &ppc_text_csects;
	  is_code = 1;
	  break;
	case XMC_RW:
	case XMC_TC0:
	case XMC_TC:
	case XMC_DS:
	case XMC_UA:
	case XMC_BS:
	case XMC_UC:
	  if (ppc_toc_csect != NULL
	      && (symbol_get_tc (ppc_toc_csect)->subseg + 1
		  == ppc_data_subsegment))
	    after_toc = 1;
	  S_SET_SEGMENT (sym, data_section);
	  symbol_get_tc (sym)->subseg = ppc_data_subsegment;
	  ++ppc_data_subsegment;
	  list_ptr = &ppc_data_csects;
	  break;
	default:
	  abort ();
	}

      /* We set the obstack chunk size to a small value before
	 changing subsegments, so that we don't use a lot of memory
	 space for what may be a small section.  */
      hold_chunksize = chunksize;
      chunksize = 64;

      sec = subseg_new (segment_name (S_GET_SEGMENT (sym)),
			symbol_get_tc (sym)->subseg);

      chunksize = hold_chunksize;

      if (after_toc)
	ppc_after_toc_frag = frag_now;

      record_alignment (sec, align);
      if (is_code)
	frag_align_code (align, 0);
      else
	frag_align (align, 0, 0);

      symbol_set_frag (sym, frag_now);
      S_SET_VALUE (sym, (valueT) frag_now_fix ());

      symbol_get_tc (sym)->align = align;
      symbol_get_tc (sym)->output = 1;
      symbol_get_tc (sym)->within = sym;

      for (list = *list_ptr;
	   symbol_get_tc (list)->next != (symbolS *) NULL;
	   list = symbol_get_tc (list)->next)
	;
      symbol_get_tc (list)->next = sym;

      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_append (sym, symbol_get_tc (list)->within, &symbol_rootP,
		     &symbol_lastP);
    }

  ppc_current_csect = sym;
}

/* This function handles the .text and .data pseudo-ops.  These
   pseudo-ops aren't really used by XCOFF; we implement them for the
   convenience of people who aren't used to XCOFF.  */

static void
ppc_section (type)
     int type;
{
  const char *name;
  symbolS *sym;

  if (type == 't')
    name = ".text[PR]";
  else if (type == 'd')
    name = ".data[RW]";
  else
    abort ();

  sym = symbol_find_or_make (name);

  ppc_change_csect (sym, 2);

  demand_empty_rest_of_line ();
}

/* This function handles the .section pseudo-op.  This is mostly to
   give an error, since XCOFF only supports .text, .data and .bss, but
   we do permit the user to name the text or data section.  */

static void
ppc_named_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *user_name;
  const char *real_name;
  char c;
  symbolS *sym;

  user_name = input_line_pointer;
  c = get_symbol_end ();

  if (strcmp (user_name, ".text") == 0)
    real_name = ".text[PR]";
  else if (strcmp (user_name, ".data") == 0)
    real_name = ".data[RW]";
  else
    {
      as_bad (_("The XCOFF file format does not support arbitrary sections"));
      *input_line_pointer = c;
      ignore_rest_of_line ();
      return;
    }

  *input_line_pointer = c;

  sym = symbol_find_or_make (real_name);

  ppc_change_csect (sym, 2);

  demand_empty_rest_of_line ();
}

/* The .extern pseudo-op.  We create an undefined symbol.  */

static void
ppc_extern (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char endc;

  name = input_line_pointer;
  endc = get_symbol_end ();

  (void) symbol_find_or_make (name);

  *input_line_pointer = endc;

  demand_empty_rest_of_line ();
}

/* The .lglobl pseudo-op.  Keep the symbol in the symbol table.  */

static void
ppc_lglobl (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char endc;
  symbolS *sym;

  name = input_line_pointer;
  endc = get_symbol_end ();

  sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  symbol_get_tc (sym)->output = 1;

  demand_empty_rest_of_line ();
}

/* The .rename pseudo-op.  The RS/6000 assembler can rename symbols,
   although I don't know why it bothers.  */

static void
ppc_rename (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char endc;
  symbolS *sym;
  int len;

  name = input_line_pointer;
  endc = get_symbol_end ();

  sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing rename string"));
      ignore_rest_of_line ();
      return;
    }
  ++input_line_pointer;

  symbol_get_tc (sym)->real_name = demand_copy_C_string (&len);

  demand_empty_rest_of_line ();
}

/* The .stabx pseudo-op.  This is similar to a normal .stabs
   pseudo-op, but slightly different.  A sample is
       .stabx "main:F-1",.main,142,0
   The first argument is the symbol name to create.  The second is the
   value, and the third is the storage class.  The fourth seems to be
   always zero, and I am assuming it is the type.  */

static void
ppc_stabx (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  int len;
  symbolS *sym;
  expressionS exp;

  name = demand_copy_C_string (&len);

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing value"));
      return;
    }
  ++input_line_pointer;

  ppc_stab_symbol = TRUE;
  sym = symbol_make (name);
  ppc_stab_symbol = FALSE;

  symbol_get_tc (sym)->real_name = name;

  (void) expression (&exp);

  switch (exp.X_op)
    {
    case O_illegal:
    case O_absent:
    case O_big:
      as_bad (_("illegal .stabx expression; zero assumed"));
      exp.X_add_number = 0;
      /* Fall through.  */
    case O_constant:
      S_SET_VALUE (sym, (valueT) exp.X_add_number);
      symbol_set_frag (sym, &zero_address_frag);
      break;

    case O_symbol:
      if (S_GET_SEGMENT (exp.X_add_symbol) == undefined_section)
	symbol_set_value_expression (sym, &exp);
      else
	{
	  S_SET_VALUE (sym,
		       exp.X_add_number + S_GET_VALUE (exp.X_add_symbol));
	  symbol_set_frag (sym, symbol_get_frag (exp.X_add_symbol));
	}
      break;

    default:
      /* The value is some complex expression.  This will probably
	 fail at some later point, but this is probably the right
	 thing to do here.  */
      symbol_set_value_expression (sym, &exp);
      break;
    }

  S_SET_SEGMENT (sym, ppc_coff_debug_section);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing class"));
      return;
    }
  ++input_line_pointer;

  S_SET_STORAGE_CLASS (sym, get_absolute_expression ());

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing type"));
      return;
    }
  ++input_line_pointer;

  S_SET_DATA_TYPE (sym, get_absolute_expression ());

  symbol_get_tc (sym)->output = 1;

  if (S_GET_STORAGE_CLASS (sym) == C_STSYM) {

    symbol_get_tc (sym)->within = ppc_current_block;

    /* In this case :

       .bs name
       .stabx	"z",arrays_,133,0
       .es

       .comm arrays_,13768,3

       resolve_symbol_value will copy the exp's "within" into sym's when the
       offset is 0.  Since this seems to be corner case problem,
       only do the correction for storage class C_STSYM.  A better solution
       would be to have the tc field updated in ppc_symbol_new_hook.  */

    if (exp.X_op == O_symbol)
      {
	symbol_get_tc (exp.X_add_symbol)->within = ppc_current_block;
      }
  }

  if (exp.X_op != O_symbol
      || ! S_IS_EXTERNAL (exp.X_add_symbol)
      || S_GET_SEGMENT (exp.X_add_symbol) != bss_section)
    ppc_frob_label (sym);
  else
    {
      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_append (sym, exp.X_add_symbol, &symbol_rootP, &symbol_lastP);
      if (symbol_get_tc (ppc_current_csect)->within == exp.X_add_symbol)
	symbol_get_tc (ppc_current_csect)->within = sym;
    }

  demand_empty_rest_of_line ();
}

/* The .function pseudo-op.  This takes several arguments.  The first
   argument seems to be the external name of the symbol.  The second
   argument seems to be the label for the start of the function.  gcc
   uses the same name for both.  I have no idea what the third and
   fourth arguments are meant to be.  The optional fifth argument is
   an expression for the size of the function.  In COFF this symbol
   gets an aux entry like that used for a csect.  */

static void
ppc_function (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char endc;
  char *s;
  symbolS *ext_sym;
  symbolS *lab_sym;

  name = input_line_pointer;
  endc = get_symbol_end ();

  /* Ignore any [PR] suffix.  */
  name = ppc_canonicalize_symbol_name (name);
  s = strchr (name, '[');
  if (s != (char *) NULL
      && strcmp (s + 1, "PR]") == 0)
    *s = '\0';

  ext_sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing symbol name"));
      ignore_rest_of_line ();
      return;
    }
  ++input_line_pointer;

  name = input_line_pointer;
  endc = get_symbol_end ();

  lab_sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  if (ext_sym != lab_sym)
    {
      expressionS exp;

      exp.X_op = O_symbol;
      exp.X_add_symbol = lab_sym;
      exp.X_op_symbol = NULL;
      exp.X_add_number = 0;
      exp.X_unsigned = 0;
      symbol_set_value_expression (ext_sym, &exp);
    }

  if (symbol_get_tc (ext_sym)->class == -1)
    symbol_get_tc (ext_sym)->class = XMC_PR;
  symbol_get_tc (ext_sym)->output = 1;

  if (*input_line_pointer == ',')
    {
      expressionS ignore;

      /* Ignore the third argument.  */
      ++input_line_pointer;
      expression (&ignore);
      if (*input_line_pointer == ',')
	{
	  /* Ignore the fourth argument.  */
	  ++input_line_pointer;
	  expression (&ignore);
	  if (*input_line_pointer == ',')
	    {
	      /* The fifth argument is the function size.  */
	      ++input_line_pointer;
	      symbol_get_tc (ext_sym)->size = symbol_new ("L0\001",
							  absolute_section,
							  (valueT) 0,
							  &zero_address_frag);
	      pseudo_set (symbol_get_tc (ext_sym)->size);
	    }
	}
    }

  S_SET_DATA_TYPE (ext_sym, DT_FCN << N_BTSHFT);
  SF_SET_FUNCTION (ext_sym);
  SF_SET_PROCESS (ext_sym);
  coff_add_linesym (ext_sym);

  demand_empty_rest_of_line ();
}

/* The .bf pseudo-op.  This is just like a COFF C_FCN symbol named
   ".bf".  If the pseudo op .bi was seen before .bf, patch the .bi sym
   with the correct line number */

static symbolS *saved_bi_sym = 0;

static void
ppc_bf (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *sym;

  sym = symbol_make (".bf");
  S_SET_SEGMENT (sym, text_section);
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, frag_now_fix ());
  S_SET_STORAGE_CLASS (sym, C_FCN);

  coff_line_base = get_absolute_expression ();

  S_SET_NUMBER_AUXILIARY (sym, 1);
  SA_SET_SYM_LNNO (sym, coff_line_base);

  /* Line number for bi.  */
  if (saved_bi_sym)
    {
      S_SET_VALUE (saved_bi_sym, coff_n_line_nos);
      saved_bi_sym = 0;
    }


  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .ef pseudo-op.  This is just like a COFF C_FCN symbol named
   ".ef", except that the line number is absolute, not relative to the
   most recent ".bf" symbol.  */

static void
ppc_ef (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *sym;

  sym = symbol_make (".ef");
  S_SET_SEGMENT (sym, text_section);
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, frag_now_fix ());
  S_SET_STORAGE_CLASS (sym, C_FCN);
  S_SET_NUMBER_AUXILIARY (sym, 1);
  SA_SET_SYM_LNNO (sym, get_absolute_expression ());
  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .bi and .ei pseudo-ops.  These take a string argument and
   generates a C_BINCL or C_EINCL symbol, which goes at the start of
   the symbol list.  The value of .bi will be know when the next .bf
   is encountered.  */

static void
ppc_biei (ei)
     int ei;
{
  static symbolS *last_biei;

  char *name;
  int len;
  symbolS *sym;
  symbolS *look;

  name = demand_copy_C_string (&len);

  /* The value of these symbols is actually file offset.  Here we set
     the value to the index into the line number entries.  In
     ppc_frob_symbols we set the fix_line field, which will cause BFD
     to do the right thing.  */

  sym = symbol_make (name);
  /* obj-coff.c currently only handles line numbers correctly in the
     .text section.  */
  S_SET_SEGMENT (sym, text_section);
  S_SET_VALUE (sym, coff_n_line_nos);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;

  S_SET_STORAGE_CLASS (sym, ei ? C_EINCL : C_BINCL);
  symbol_get_tc (sym)->output = 1;

  /* Save bi.  */
  if (ei)
    saved_bi_sym = 0;
  else
    saved_bi_sym = sym;

  for (look = last_biei ? last_biei : symbol_rootP;
       (look != (symbolS *) NULL
	&& (S_GET_STORAGE_CLASS (look) == C_FILE
	    || S_GET_STORAGE_CLASS (look) == C_BINCL
	    || S_GET_STORAGE_CLASS (look) == C_EINCL));
       look = symbol_next (look))
    ;
  if (look != (symbolS *) NULL)
    {
      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_insert (sym, look, &symbol_rootP, &symbol_lastP);
      last_biei = sym;
    }

  demand_empty_rest_of_line ();
}

/* The .bs pseudo-op.  This generates a C_BSTAT symbol named ".bs".
   There is one argument, which is a csect symbol.  The value of the
   .bs symbol is the index of this csect symbol.  */

static void
ppc_bs (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char endc;
  symbolS *csect;
  symbolS *sym;

  if (ppc_current_block != NULL)
    as_bad (_("nested .bs blocks"));

  name = input_line_pointer;
  endc = get_symbol_end ();

  csect = symbol_find_or_make (name);

  *input_line_pointer = endc;

  sym = symbol_make (".bs");
  S_SET_SEGMENT (sym, now_seg);
  S_SET_STORAGE_CLASS (sym, C_BSTAT);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  symbol_get_tc (sym)->output = 1;

  symbol_get_tc (sym)->within = csect;

  ppc_frob_label (sym);

  ppc_current_block = sym;

  demand_empty_rest_of_line ();
}

/* The .es pseudo-op.  Generate a C_ESTART symbol named .es.  */

static void
ppc_es (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *sym;

  if (ppc_current_block == NULL)
    as_bad (_(".es without preceding .bs"));

  sym = symbol_make (".es");
  S_SET_SEGMENT (sym, now_seg);
  S_SET_STORAGE_CLASS (sym, C_ESTAT);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  ppc_current_block = NULL;

  demand_empty_rest_of_line ();
}

/* The .bb pseudo-op.  Generate a C_BLOCK symbol named .bb, with a
   line number.  */

static void
ppc_bb (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *sym;

  sym = symbol_make (".bb");
  S_SET_SEGMENT (sym, text_section);
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, frag_now_fix ());
  S_SET_STORAGE_CLASS (sym, C_BLOCK);

  S_SET_NUMBER_AUXILIARY (sym, 1);
  SA_SET_SYM_LNNO (sym, get_absolute_expression ());

  symbol_get_tc (sym)->output = 1;

  SF_SET_PROCESS (sym);

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .eb pseudo-op.  Generate a C_BLOCK symbol named .eb, with a
   line number.  */

static void
ppc_eb (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *sym;

  sym = symbol_make (".eb");
  S_SET_SEGMENT (sym, text_section);
  symbol_set_frag (sym, frag_now);
  S_SET_VALUE (sym, frag_now_fix ());
  S_SET_STORAGE_CLASS (sym, C_BLOCK);
  S_SET_NUMBER_AUXILIARY (sym, 1);
  SA_SET_SYM_LNNO (sym, get_absolute_expression ());
  symbol_get_tc (sym)->output = 1;

  SF_SET_PROCESS (sym);

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .bc pseudo-op.  This just creates a C_BCOMM symbol with a
   specified name.  */

static void
ppc_bc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  int len;
  symbolS *sym;

  name = demand_copy_C_string (&len);
  sym = symbol_make (name);
  S_SET_SEGMENT (sym, ppc_coff_debug_section);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  S_SET_STORAGE_CLASS (sym, C_BCOMM);
  S_SET_VALUE (sym, 0);
  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .ec pseudo-op.  This just creates a C_ECOMM symbol.  */

static void
ppc_ec (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *sym;

  sym = symbol_make (".ec");
  S_SET_SEGMENT (sym, ppc_coff_debug_section);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  S_SET_STORAGE_CLASS (sym, C_ECOMM);
  S_SET_VALUE (sym, 0);
  symbol_get_tc (sym)->output = 1;

  ppc_frob_label (sym);

  demand_empty_rest_of_line ();
}

/* The .toc pseudo-op.  Switch to the .toc subsegment.  */

static void
ppc_toc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (ppc_toc_csect != (symbolS *) NULL)
    subseg_set (data_section, symbol_get_tc (ppc_toc_csect)->subseg);
  else
    {
      subsegT subseg;
      symbolS *sym;
      symbolS *list;

      subseg = ppc_data_subsegment;
      ++ppc_data_subsegment;

      subseg_new (segment_name (data_section), subseg);
      ppc_toc_frag = frag_now;

      sym = symbol_find_or_make ("TOC[TC0]");
      symbol_set_frag (sym, frag_now);
      S_SET_SEGMENT (sym, data_section);
      S_SET_VALUE (sym, (valueT) frag_now_fix ());
      symbol_get_tc (sym)->subseg = subseg;
      symbol_get_tc (sym)->output = 1;
      symbol_get_tc (sym)->within = sym;

      ppc_toc_csect = sym;

      for (list = ppc_data_csects;
	   symbol_get_tc (list)->next != (symbolS *) NULL;
	   list = symbol_get_tc (list)->next)
	;
      symbol_get_tc (list)->next = sym;

      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_append (sym, symbol_get_tc (list)->within, &symbol_rootP,
		     &symbol_lastP);
    }

  ppc_current_csect = ppc_toc_csect;

  demand_empty_rest_of_line ();
}

/* The AIX assembler automatically aligns the operands of a .long or
   .short pseudo-op, and we want to be compatible.  */

static void
ppc_xcoff_cons (log_size)
     int log_size;
{
  frag_align (log_size, 0, 0);
  record_alignment (now_seg, log_size);
  cons (1 << log_size);
}

static void
ppc_vbyte (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  expressionS exp;
  int byte_count;

  (void) expression (&exp);

  if (exp.X_op != O_constant)
    {
      as_bad (_("non-constant byte count"));
      return;
    }

  byte_count = exp.X_add_number;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing value"));
      return;
    }

  ++input_line_pointer;
  cons (byte_count);
}

#endif /* OBJ_XCOFF */
#if defined (OBJ_XCOFF) || defined (OBJ_ELF)

/* The .tc pseudo-op.  This is used when generating either XCOFF or
   ELF.  This takes two or more arguments.

   When generating XCOFF output, the first argument is the name to
   give to this location in the toc; this will be a symbol with class
   TC.  The rest of the arguments are N-byte values to actually put at
   this location in the TOC; often there is just one more argument, a
   relocatable symbol reference.  The size of the value to store
   depends on target word size.  A 32-bit target uses 4-byte values, a
   64-bit target uses 8-byte values.

   When not generating XCOFF output, the arguments are the same, but
   the first argument is simply ignored.  */

static void
ppc_tc (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
#ifdef OBJ_XCOFF

  /* Define the TOC symbol name.  */
  {
    char *name;
    char endc;
    symbolS *sym;

    if (ppc_toc_csect == (symbolS *) NULL
	|| ppc_toc_csect != ppc_current_csect)
      {
	as_bad (_(".tc not in .toc section"));
	ignore_rest_of_line ();
	return;
      }

    name = input_line_pointer;
    endc = get_symbol_end ();

    sym = symbol_find_or_make (name);

    *input_line_pointer = endc;

    if (S_IS_DEFINED (sym))
      {
	symbolS *label;

	label = symbol_get_tc (ppc_current_csect)->within;
	if (symbol_get_tc (label)->class != XMC_TC0)
	  {
	    as_bad (_(".tc with no label"));
	    ignore_rest_of_line ();
	    return;
	  }

	S_SET_SEGMENT (label, S_GET_SEGMENT (sym));
	symbol_set_frag (label, symbol_get_frag (sym));
	S_SET_VALUE (label, S_GET_VALUE (sym));

	while (! is_end_of_line[(unsigned char) *input_line_pointer])
	  ++input_line_pointer;

	return;
      }

    S_SET_SEGMENT (sym, now_seg);
    symbol_set_frag (sym, frag_now);
    S_SET_VALUE (sym, (valueT) frag_now_fix ());
    symbol_get_tc (sym)->class = XMC_TC;
    symbol_get_tc (sym)->output = 1;

    ppc_frob_label (sym);
  }

#endif /* OBJ_XCOFF */
#ifdef OBJ_ELF
  int align;

  /* Skip the TOC symbol name.  */
  while (is_part_of_name (*input_line_pointer)
	 || *input_line_pointer == '['
	 || *input_line_pointer == ']'
	 || *input_line_pointer == '{'
	 || *input_line_pointer == '}')
    ++input_line_pointer;

  /* Align to a four/eight byte boundary.  */
  align = ppc_obj64 ? 3 : 2;
  frag_align (align, 0, 0);
  record_alignment (now_seg, align);
#endif /* OBJ_ELF */

  if (*input_line_pointer != ',')
    demand_empty_rest_of_line ();
  else
    {
      ++input_line_pointer;
      cons (ppc_obj64 ? 8 : 4);
    }
}

/* Pseudo-op .machine.  */

static void
ppc_machine (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *cpu_string;
#define MAX_HISTORY 100
  static unsigned long *cpu_history;
  static int curr_hist;

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '"')
    {
      int len;
      cpu_string = demand_copy_C_string (&len);
    }
  else
    {
      char c;
      cpu_string = input_line_pointer;
      c = get_symbol_end ();
      cpu_string = xstrdup (cpu_string);
      *input_line_pointer = c;
    }

  if (cpu_string != NULL)
    {
      unsigned long old_cpu = ppc_cpu;
      char *p;

      for (p = cpu_string; *p != 0; p++)
	*p = TOLOWER (*p);

      if (strcmp (cpu_string, "push") == 0)
	{
	  if (cpu_history == NULL)
	    cpu_history = xmalloc (MAX_HISTORY * sizeof (*cpu_history));

	  if (curr_hist >= MAX_HISTORY)
	    as_bad (_(".machine stack overflow"));
	  else
	    cpu_history[curr_hist++] = ppc_cpu;
	}
      else if (strcmp (cpu_string, "pop") == 0)
	{
	  if (curr_hist <= 0)
	    as_bad (_(".machine stack underflow"));
	  else
	    ppc_cpu = cpu_history[--curr_hist];
	}
      else if (parse_cpu (cpu_string))
	;
      else
	as_bad (_("invalid machine `%s'"), cpu_string);

      if (ppc_cpu != old_cpu)
	ppc_setup_opcodes ();
    }

  demand_empty_rest_of_line ();
}

/* See whether a symbol is in the TOC section.  */

static int
ppc_is_toc_sym (sym)
     symbolS *sym;
{
#ifdef OBJ_XCOFF
  return symbol_get_tc (sym)->class == XMC_TC;
#endif
#ifdef OBJ_ELF
  const char *sname = segment_name (S_GET_SEGMENT (sym));
  if (ppc_obj64)
    return strcmp (sname, ".toc") == 0;
  else
    return strcmp (sname, ".got") == 0;
#endif
}
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */

#ifdef TE_PE

/* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format.  */

/* Set the current section.  */
static void
ppc_set_current_section (new)
     segT new;
{
  ppc_previous_section = ppc_current_section;
  ppc_current_section = new;
}

/* pseudo-op: .previous
   behaviour: toggles the current section with the previous section.
   errors:    None
   warnings:  "No previous section"  */

static void
ppc_previous (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  symbolS *tmp;

  if (ppc_previous_section == NULL)
    {
      as_warn (_("No previous section to return to. Directive ignored."));
      return;
    }

  subseg_set (ppc_previous_section, 0);

  ppc_set_current_section (ppc_previous_section);
}

/* pseudo-op: .pdata
   behaviour: predefined read only data section
	      double word aligned
   errors:    None
   warnings:  None
   initial:   .section .pdata "adr3"
	      a - don't know -- maybe a misprint
	      d - initialized data
	      r - readable
	      3 - double word aligned (that would be 4 byte boundary)

   commentary:
   Tag index tables (also known as the function table) for exception
   handling, debugging, etc.  */

static void
ppc_pdata (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (pdata_section == 0)
    {
      pdata_section = subseg_new (".pdata", 0);

      bfd_set_section_flags (stdoutput, pdata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_READONLY | SEC_DATA ));

      bfd_set_section_alignment (stdoutput, pdata_section, 2);
    }
  else
    {
      pdata_section = subseg_new (".pdata", 0);
    }
  ppc_set_current_section (pdata_section);
}

/* pseudo-op: .ydata
   behaviour: predefined read only data section
	      double word aligned
   errors:    None
   warnings:  None
   initial:   .section .ydata "drw3"
	      a - don't know -- maybe a misprint
	      d - initialized data
	      r - readable
	      3 - double word aligned (that would be 4 byte boundary)
   commentary:
   Tag tables (also known as the scope table) for exception handling,
   debugging, etc.  */

static void
ppc_ydata (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (ydata_section == 0)
    {
      ydata_section = subseg_new (".ydata", 0);
      bfd_set_section_flags (stdoutput, ydata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_READONLY | SEC_DATA ));

      bfd_set_section_alignment (stdoutput, ydata_section, 3);
    }
  else
    {
      ydata_section = subseg_new (".ydata", 0);
    }
  ppc_set_current_section (ydata_section);
}

/* pseudo-op: .reldata
   behaviour: predefined read write data section
	      double word aligned (4-byte)
	      FIXME: relocation is applied to it
	      FIXME: what's the difference between this and .data?
   errors:    None
   warnings:  None
   initial:   .section .reldata "drw3"
	      d - initialized data
	      r - readable
	      w - writeable
	      3 - double word aligned (that would be 8 byte boundary)

   commentary:
   Like .data, but intended to hold data subject to relocation, such as
   function descriptors, etc.  */

static void
ppc_reldata (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (reldata_section == 0)
    {
      reldata_section = subseg_new (".reldata", 0);

      bfd_set_section_flags (stdoutput, reldata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_DATA));

      bfd_set_section_alignment (stdoutput, reldata_section, 2);
    }
  else
    {
      reldata_section = subseg_new (".reldata", 0);
    }
  ppc_set_current_section (reldata_section);
}

/* pseudo-op: .rdata
   behaviour: predefined read only data section
	      double word aligned
   errors:    None
   warnings:  None
   initial:   .section .rdata "dr3"
	      d - initialized data
	      r - readable
	      3 - double word aligned (that would be 4 byte boundary)  */

static void
ppc_rdata (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (rdata_section == 0)
    {
      rdata_section = subseg_new (".rdata", 0);
      bfd_set_section_flags (stdoutput, rdata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_READONLY | SEC_DATA ));

      bfd_set_section_alignment (stdoutput, rdata_section, 2);
    }
  else
    {
      rdata_section = subseg_new (".rdata", 0);
    }
  ppc_set_current_section (rdata_section);
}

/* pseudo-op: .ualong
   behaviour: much like .int, with the exception that no alignment is
	      performed.
	      FIXME: test the alignment statement
   errors:    None
   warnings:  None  */

static void
ppc_ualong (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* Try for long.  */
  cons (4);
}

/* pseudo-op: .znop  <symbol name>
   behaviour: Issue a nop instruction
	      Issue a IMAGE_REL_PPC_IFGLUE relocation against it, using
	      the supplied symbol name.
   errors:    None
   warnings:  Missing symbol name  */

static void
ppc_znop (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  unsigned long insn;
  const struct powerpc_opcode *opcode;
  expressionS ex;
  char *f;
  symbolS *sym;
  char *symbol_name;
  char c;
  char *name;
  unsigned int exp;
  flagword flags;
  asection *sec;

  /* Strip out the symbol name.  */
  symbol_name = input_line_pointer;
  c = get_symbol_end ();

  name = xmalloc (input_line_pointer - symbol_name + 1);
  strcpy (name, symbol_name);

  sym = symbol_find_or_make (name);

  *input_line_pointer = c;

  SKIP_WHITESPACE ();

  /* Look up the opcode in the hash table.  */
  opcode = (const struct powerpc_opcode *) hash_find (ppc_hash, "nop");

  /* Stick in the nop.  */
  insn = opcode->opcode;

  /* Write out the instruction.  */
  f = frag_more (4);
  md_number_to_chars (f, insn, 4);
  fix_new (frag_now,
	   f - frag_now->fr_literal,
	   4,
	   sym,
	   0,
	   0,
	   BFD_RELOC_16_GOT_PCREL);

}

/* pseudo-op:
   behaviour:
   errors:
   warnings:  */

static void
ppc_pe_comm (lcomm)
     int lcomm;
{
  register char *name;
  register char c;
  register char *p;
  offsetT temp;
  register symbolS *symbolP;
  offsetT align;

  name = input_line_pointer;
  c = get_symbol_end ();

  /* just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ',' */
  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
      ignore_rest_of_line ();
      return;
    }

  if (! lcomm)
    {
      /* The third argument to .comm is the alignment.  */
      if (*input_line_pointer != ',')
	align = 3;
      else
	{
	  ++input_line_pointer;
	  align = get_absolute_expression ();
	  if (align <= 0)
	    {
	      as_warn (_("ignoring bad alignment"));
	      align = 3;
	    }
	}
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);

  *p = c;
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
	      S_GET_NAME (symbolP));
      ignore_rest_of_line ();
      return;
    }

  if (S_GET_VALUE (symbolP))
    {
      if (S_GET_VALUE (symbolP) != (valueT) temp)
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
		S_GET_NAME (symbolP),
		(long) S_GET_VALUE (symbolP),
		(long) temp);
    }
  else
    {
      S_SET_VALUE (symbolP, (valueT) temp);
      S_SET_EXTERNAL (symbolP);
    }

  demand_empty_rest_of_line ();
}

/*
 * implement the .section pseudo op:
 *	.section name {, "flags"}
 *                ^         ^
 *                |         +--- optional flags: 'b' for bss
 *                |                              'i' for info
 *                +-- section name               'l' for lib
 *                                               'n' for noload
 *                                               'o' for over
 *                                               'w' for data
 *						 'd' (apparently m88k for data)
 *                                               'x' for text
 * But if the argument is not a quoted string, treat it as a
 * subsegment number.
 *
 * FIXME: this is a copy of the section processing from obj-coff.c, with
 * additions/changes for the moto-pas assembler support. There are three
 * categories:
 *
 * FIXME: I just noticed this. This doesn't work at all really. It it
 *        setting bits that bfd probably neither understands or uses. The
 *        correct approach (?) will have to incorporate extra fields attached
 *        to the section to hold the system specific stuff. (krk)
 *
 * Section Contents:
 * 'a' - unknown - referred to in documentation, but no definition supplied
 * 'c' - section has code
 * 'd' - section has initialized data
 * 'u' - section has uninitialized data
 * 'i' - section contains directives (info)
 * 'n' - section can be discarded
 * 'R' - remove section at link time
 *
 * Section Protection:
 * 'r' - section is readable
 * 'w' - section is writeable
 * 'x' - section is executable
 * 's' - section is sharable
 *
 * Section Alignment:
 * '0' - align to byte boundary
 * '1' - align to halfword undary
 * '2' - align to word boundary
 * '3' - align to doubleword boundary
 * '4' - align to quadword boundary
 * '5' - align to 32 byte boundary
 * '6' - align to 64 byte boundary
 *
 */

void
ppc_pe_section (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  /* Strip out the section name.  */
  char *section_name;
  char c;
  char *name;
  unsigned int exp;
  flagword flags;
  segT sec;
  int align;

  section_name = input_line_pointer;
  c = get_symbol_end ();

  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);

  *input_line_pointer = c;

  SKIP_WHITESPACE ();

  exp = 0;
  flags = SEC_NO_FLAGS;

  if (strcmp (name, ".idata$2") == 0)
    {
      align = 0;
    }
  else if (strcmp (name, ".idata$3") == 0)
    {
      align = 0;
    }
  else if (strcmp (name, ".idata$4") == 0)
    {
      align = 2;
    }
  else if (strcmp (name, ".idata$5") == 0)
    {
      align = 2;
    }
  else if (strcmp (name, ".idata$6") == 0)
    {
      align = 1;
    }
  else
    /* Default alignment to 16 byte boundary.  */
    align = 4;

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (*input_line_pointer != '"')
	exp = get_absolute_expression ();
      else
	{
	  ++input_line_pointer;
	  while (*input_line_pointer != '"'
		 && ! is_end_of_line[(unsigned char) *input_line_pointer])
	    {
	      switch (*input_line_pointer)
		{
		  /* Section Contents */
		case 'a': /* unknown */
		  as_bad (_("Unsupported section attribute -- 'a'"));
		  break;
		case 'c': /* code section */
		  flags |= SEC_CODE;
		  break;
		case 'd': /* section has initialized data */
		  flags |= SEC_DATA;
		  break;
		case 'u': /* section has uninitialized data */
		  /* FIXME: This is IMAGE_SCN_CNT_UNINITIALIZED_DATA
		     in winnt.h */
		  flags |= SEC_ROM;
		  break;
		case 'i': /* section contains directives (info) */
		  /* FIXME: This is IMAGE_SCN_LNK_INFO
		     in winnt.h */
		  flags |= SEC_HAS_CONTENTS;
		  break;
		case 'n': /* section can be discarded */
		  flags &=~ SEC_LOAD;
		  break;
		case 'R': /* Remove section at link time */
		  flags |= SEC_NEVER_LOAD;
		  break;

		  /* Section Protection */
		case 'r': /* section is readable */
		  flags |= IMAGE_SCN_MEM_READ;
		  break;
		case 'w': /* section is writeable */
		  flags |= IMAGE_SCN_MEM_WRITE;
		  break;
		case 'x': /* section is executable */
		  flags |= IMAGE_SCN_MEM_EXECUTE;
		  break;
		case 's': /* section is sharable */
		  flags |= IMAGE_SCN_MEM_SHARED;
		  break;

		  /* Section Alignment */
		case '0': /* align to byte boundary */
		  flags |= IMAGE_SCN_ALIGN_1BYTES;
		  align = 0;
		  break;
		case '1':  /* align to halfword boundary */
		  flags |= IMAGE_SCN_ALIGN_2BYTES;
		  align = 1;
		  break;
		case '2':  /* align to word boundary */
		  flags |= IMAGE_SCN_ALIGN_4BYTES;
		  align = 2;
		  break;
		case '3':  /* align to doubleword boundary */
		  flags |= IMAGE_SCN_ALIGN_8BYTES;
		  align = 3;
		  break;
		case '4':  /* align to quadword boundary */
		  flags |= IMAGE_SCN_ALIGN_16BYTES;
		  align = 4;
		  break;
		case '5':  /* align to 32 byte boundary */
		  flags |= IMAGE_SCN_ALIGN_32BYTES;
		  align = 5;
		  break;
		case '6':  /* align to 64 byte boundary */
		  flags |= IMAGE_SCN_ALIGN_64BYTES;
		  align = 6;
		  break;

		default:
		  as_bad (_("unknown section attribute '%c'"),
			  *input_line_pointer);
		  break;
		}
	      ++input_line_pointer;
	    }
	  if (*input_line_pointer == '"')
	    ++input_line_pointer;
	}
    }

  sec = subseg_new (name, (subsegT) exp);

  ppc_set_current_section (sec);

  if (flags != SEC_NO_FLAGS)
    {
      if (! bfd_set_section_flags (stdoutput, sec, flags))
	as_bad (_("error setting flags for \"%s\": %s"),
		bfd_section_name (stdoutput, sec),
		bfd_errmsg (bfd_get_error ()));
    }

  bfd_set_section_alignment (stdoutput, sec, align);

}

static void
ppc_pe_function (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  char *name;
  char endc;
  symbolS *ext_sym;

  name = input_line_pointer;
  endc = get_symbol_end ();

  ext_sym = symbol_find_or_make (name);

  *input_line_pointer = endc;

  S_SET_DATA_TYPE (ext_sym, DT_FCN << N_BTSHFT);
  SF_SET_FUNCTION (ext_sym);
  SF_SET_PROCESS (ext_sym);
  coff_add_linesym (ext_sym);

  demand_empty_rest_of_line ();
}

static void
ppc_pe_tocd (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  if (tocdata_section == 0)
    {
      tocdata_section = subseg_new (".tocd", 0);
      /* FIXME: section flags won't work.  */
      bfd_set_section_flags (stdoutput, tocdata_section,
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_READONLY | SEC_DATA));

      bfd_set_section_alignment (stdoutput, tocdata_section, 2);
    }
  else
    {
      rdata_section = subseg_new (".tocd", 0);
    }

  ppc_set_current_section (tocdata_section);

  demand_empty_rest_of_line ();
}

/* Don't adjust TOC relocs to use the section symbol.  */

int
ppc_pe_fix_adjustable (fix)
     fixS *fix;
{
  return fix->fx_r_type != BFD_RELOC_PPC_TOC16;
}

#endif

#ifdef OBJ_XCOFF

/* XCOFF specific symbol and file handling.  */

/* Canonicalize the symbol name.  We use the to force the suffix, if
   any, to use square brackets, and to be in upper case.  */

char *
ppc_canonicalize_symbol_name (name)
     char *name;
{
  char *s;

  if (ppc_stab_symbol)
    return name;

  for (s = name; *s != '\0' && *s != '{' && *s != '['; s++)
    ;
  if (*s != '\0')
    {
      char brac;

      if (*s == '[')
	brac = ']';
      else
	{
	  *s = '[';
	  brac = '}';
	}

      for (s++; *s != '\0' && *s != brac; s++)
	*s = TOUPPER (*s);

      if (*s == '\0' || s[1] != '\0')
	as_bad (_("bad symbol suffix"));

      *s = ']';
    }

  return name;
}

/* Set the class of a symbol based on the suffix, if any.  This is
   called whenever a new symbol is created.  */

void
ppc_symbol_new_hook (sym)
     symbolS *sym;
{
  struct ppc_tc_sy *tc;
  const char *s;

  tc = symbol_get_tc (sym);
  tc->next = NULL;
  tc->output = 0;
  tc->class = -1;
  tc->real_name = NULL;
  tc->subseg = 0;
  tc->align = 0;
  tc->size = NULL;
  tc->within = NULL;

  if (ppc_stab_symbol)
    return;

  s = strchr (S_GET_NAME (sym), '[');
  if (s == (const char *) NULL)
    {
      /* There is no suffix.  */
      return;
    }

  ++s;

  switch (s[0])
    {
    case 'B':
      if (strcmp (s, "BS]") == 0)
	tc->class = XMC_BS;
      break;
    case 'D':
      if (strcmp (s, "DB]") == 0)
	tc->class = XMC_DB;
      else if (strcmp (s, "DS]") == 0)
	tc->class = XMC_DS;
      break;
    case 'G':
      if (strcmp (s, "GL]") == 0)
	tc->class = XMC_GL;
      break;
    case 'P':
      if (strcmp (s, "PR]") == 0)
	tc->class = XMC_PR;
      break;
    case 'R':
      if (strcmp (s, "RO]") == 0)
	tc->class = XMC_RO;
      else if (strcmp (s, "RW]") == 0)
	tc->class = XMC_RW;
      break;
    case 'S':
      if (strcmp (s, "SV]") == 0)
	tc->class = XMC_SV;
      break;
    case 'T':
      if (strcmp (s, "TC]") == 0)
	tc->class = XMC_TC;
      else if (strcmp (s, "TI]") == 0)
	tc->class = XMC_TI;
      else if (strcmp (s, "TB]") == 0)
	tc->class = XMC_TB;
      else if (strcmp (s, "TC0]") == 0 || strcmp (s, "T0]") == 0)
	tc->class = XMC_TC0;
      break;
    case 'U':
      if (strcmp (s, "UA]") == 0)
	tc->class = XMC_UA;
      else if (strcmp (s, "UC]") == 0)
	tc->class = XMC_UC;
      break;
    case 'X':
      if (strcmp (s, "XO]") == 0)
	tc->class = XMC_XO;
      break;
    }

  if (tc->class == -1)
    as_bad (_("Unrecognized symbol suffix"));
}

/* Set the class of a label based on where it is defined.  This
   handles symbols without suffixes.  Also, move the symbol so that it
   follows the csect symbol.  */

void
ppc_frob_label (sym)
     symbolS *sym;
{
  if (ppc_current_csect != (symbolS *) NULL)
    {
      if (symbol_get_tc (sym)->class == -1)
	symbol_get_tc (sym)->class = symbol_get_tc (ppc_current_csect)->class;

      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_append (sym, symbol_get_tc (ppc_current_csect)->within,
		     &symbol_rootP, &symbol_lastP);
      symbol_get_tc (ppc_current_csect)->within = sym;
    }
}

/* This variable is set by ppc_frob_symbol if any absolute symbols are
   seen.  It tells ppc_adjust_symtab whether it needs to look through
   the symbols.  */

static bfd_boolean ppc_saw_abs;

/* Change the name of a symbol just before writing it out.  Set the
   real name if the .rename pseudo-op was used.  Otherwise, remove any
   class suffix.  Return 1 if the symbol should not be included in the
   symbol table.  */

int
ppc_frob_symbol (sym)
     symbolS *sym;
{
  static symbolS *ppc_last_function;
  static symbolS *set_end;

  /* Discard symbols that should not be included in the output symbol
     table.  */
  if (! symbol_used_in_reloc_p (sym)
      && ((symbol_get_bfdsym (sym)->flags & BSF_SECTION_SYM) != 0
	  || (! S_IS_EXTERNAL (sym)
	      && ! symbol_get_tc (sym)->output
	      && S_GET_STORAGE_CLASS (sym) != C_FILE)))
    return 1;

  /* This one will disappear anyway.  Don't make a csect sym for it.  */
  if (sym == abs_section_sym)
    return 1;

  if (symbol_get_tc (sym)->real_name != (char *) NULL)
    S_SET_NAME (sym, symbol_get_tc (sym)->real_name);
  else
    {
      const char *name;
      const char *s;

      name = S_GET_NAME (sym);
      s = strchr (name, '[');
      if (s != (char *) NULL)
	{
	  unsigned int len;
	  char *snew;

	  len = s - name;
	  snew = xmalloc (len + 1);
	  memcpy (snew, name, len);
	  snew[len] = '\0';

	  S_SET_NAME (sym, snew);
	}
    }

  if (set_end != (symbolS *) NULL)
    {
      SA_SET_SYM_ENDNDX (set_end, sym);
      set_end = NULL;
    }

  if (SF_GET_FUNCTION (sym))
    {
      if (ppc_last_function != (symbolS *) NULL)
	as_bad (_("two .function pseudo-ops with no intervening .ef"));
      ppc_last_function = sym;
      if (symbol_get_tc (sym)->size != (symbolS *) NULL)
	{
	  resolve_symbol_value (symbol_get_tc (sym)->size);
	  SA_SET_SYM_FSIZE (sym,
			    (long) S_GET_VALUE (symbol_get_tc (sym)->size));
	}
    }
  else if (S_GET_STORAGE_CLASS (sym) == C_FCN
	   && strcmp (S_GET_NAME (sym), ".ef") == 0)
    {
      if (ppc_last_function == (symbolS *) NULL)
	as_bad (_(".ef with no preceding .function"));
      else
	{
	  set_end = ppc_last_function;
	  ppc_last_function = NULL;

	  /* We don't have a C_EFCN symbol, but we need to force the
	     COFF backend to believe that it has seen one.  */
	  coff_last_function = NULL;
	}
    }

  if (! S_IS_EXTERNAL (sym)
      && (symbol_get_bfdsym (sym)->flags & BSF_SECTION_SYM) == 0
      && S_GET_STORAGE_CLASS (sym) != C_FILE
      && S_GET_STORAGE_CLASS (sym) != C_FCN
      && S_GET_STORAGE_CLASS (sym) != C_BLOCK
      && S_GET_STORAGE_CLASS (sym) != C_BSTAT
      && S_GET_STORAGE_CLASS (sym) != C_ESTAT
      && S_GET_STORAGE_CLASS (sym) != C_BINCL
      && S_GET_STORAGE_CLASS (sym) != C_EINCL
      && S_GET_SEGMENT (sym) != ppc_coff_debug_section)
    S_SET_STORAGE_CLASS (sym, C_HIDEXT);

  if (S_GET_STORAGE_CLASS (sym) == C_EXT
      || S_GET_STORAGE_CLASS (sym) == C_HIDEXT)
    {
      int i;
      union internal_auxent *a;

      /* Create a csect aux.  */
      i = S_GET_NUMBER_AUXILIARY (sym);
      S_SET_NUMBER_AUXILIARY (sym, i + 1);
      a = &coffsymbol (symbol_get_bfdsym (sym))->native[i + 1].u.auxent;
      if (symbol_get_tc (sym)->class == XMC_TC0)
	{
	  /* This is the TOC table.  */
	  know (strcmp (S_GET_NAME (sym), "TOC") == 0);
	  a->x_csect.x_scnlen.l = 0;
	  a->x_csect.x_smtyp = (2 << 3) | XTY_SD;
	}
      else if (symbol_get_tc (sym)->subseg != 0)
	{
	  /* This is a csect symbol.  x_scnlen is the size of the
	     csect.  */
	  if (symbol_get_tc (sym)->next == (symbolS *) NULL)
	    a->x_csect.x_scnlen.l = (bfd_section_size (stdoutput,
						       S_GET_SEGMENT (sym))
				     - S_GET_VALUE (sym));
	  else
	    {
	      resolve_symbol_value (symbol_get_tc (sym)->next);
	      a->x_csect.x_scnlen.l = (S_GET_VALUE (symbol_get_tc (sym)->next)
				       - S_GET_VALUE (sym));
	    }
	  a->x_csect.x_smtyp = (symbol_get_tc (sym)->align << 3) | XTY_SD;
	}
      else if (S_GET_SEGMENT (sym) == bss_section)
	{
	  /* This is a common symbol.  */
	  a->x_csect.x_scnlen.l = symbol_get_frag (sym)->fr_offset;
	  a->x_csect.x_smtyp = (symbol_get_tc (sym)->align << 3) | XTY_CM;
	  if (S_IS_EXTERNAL (sym))
	    symbol_get_tc (sym)->class = XMC_RW;
	  else
	    symbol_get_tc (sym)->class = XMC_BS;
	}
      else if (S_GET_SEGMENT (sym) == absolute_section)
	{
	  /* This is an absolute symbol.  The csect will be created by
	     ppc_adjust_symtab.  */
	  ppc_saw_abs = TRUE;
	  a->x_csect.x_smtyp = XTY_LD;
	  if (symbol_get_tc (sym)->class == -1)
	    symbol_get_tc (sym)->class = XMC_XO;
	}
      else if (! S_IS_DEFINED (sym))
	{
	  /* This is an external symbol.  */
	  a->x_csect.x_scnlen.l = 0;
	  a->x_csect.x_smtyp = XTY_ER;
	}
      else if (symbol_get_tc (sym)->class == XMC_TC)
	{
	  symbolS *next;

	  /* This is a TOC definition.  x_scnlen is the size of the
	     TOC entry.  */
	  next = symbol_next (sym);
	  while (symbol_get_tc (next)->class == XMC_TC0)
	    next = symbol_next (next);
	  if (next == (symbolS *) NULL
	      || symbol_get_tc (next)->class != XMC_TC)
	    {
	      if (ppc_after_toc_frag == (fragS *) NULL)
		a->x_csect.x_scnlen.l = (bfd_section_size (stdoutput,
							   data_section)
					 - S_GET_VALUE (sym));
	      else
		a->x_csect.x_scnlen.l = (ppc_after_toc_frag->fr_address
					 - S_GET_VALUE (sym));
	    }
	  else
	    {
	      resolve_symbol_value (next);
	      a->x_csect.x_scnlen.l = (S_GET_VALUE (next)
				       - S_GET_VALUE (sym));
	    }
	  a->x_csect.x_smtyp = (2 << 3) | XTY_SD;
	}
      else
	{
	  symbolS *csect;

	  /* This is a normal symbol definition.  x_scnlen is the
	     symbol index of the containing csect.  */
	  if (S_GET_SEGMENT (sym) == text_section)
	    csect = ppc_text_csects;
	  else if (S_GET_SEGMENT (sym) == data_section)
	    csect = ppc_data_csects;
	  else
	    abort ();

	  /* Skip the initial dummy symbol.  */
	  csect = symbol_get_tc (csect)->next;

	  if (csect == (symbolS *) NULL)
	    {
	      as_warn (_("warning: symbol %s has no csect"), S_GET_NAME (sym));
	      a->x_csect.x_scnlen.l = 0;
	    }
	  else
	    {
	      while (symbol_get_tc (csect)->next != (symbolS *) NULL)
		{
		  resolve_symbol_value (symbol_get_tc (csect)->next);
		  if (S_GET_VALUE (symbol_get_tc (csect)->next)
		      > S_GET_VALUE (sym))
		    break;
		  csect = symbol_get_tc (csect)->next;
		}

	      a->x_csect.x_scnlen.p =
		coffsymbol (symbol_get_bfdsym (csect))->native;
	      coffsymbol (symbol_get_bfdsym (sym))->native[i + 1].fix_scnlen =
		1;
	    }
	  a->x_csect.x_smtyp = XTY_LD;
	}

      a->x_csect.x_parmhash = 0;
      a->x_csect.x_snhash = 0;
      if (symbol_get_tc (sym)->class == -1)
	a->x_csect.x_smclas = XMC_PR;
      else
	a->x_csect.x_smclas = symbol_get_tc (sym)->class;
      a->x_csect.x_stab = 0;
      a->x_csect.x_snstab = 0;

      /* Don't let the COFF backend resort these symbols.  */
      symbol_get_bfdsym (sym)->flags |= BSF_NOT_AT_END;
    }
  else if (S_GET_STORAGE_CLASS (sym) == C_BSTAT)
    {
      /* We want the value to be the symbol index of the referenced
	 csect symbol.  BFD will do that for us if we set the right
	 flags.  */
      asymbol *bsym = symbol_get_bfdsym (symbol_get_tc (sym)->within);
      combined_entry_type *c = coffsymbol (bsym)->native;

      S_SET_VALUE (sym, (valueT) (size_t) c);
      coffsymbol (symbol_get_bfdsym (sym))->native->fix_value = 1;
    }
  else if (S_GET_STORAGE_CLASS (sym) == C_STSYM)
    {
      symbolS *block;
      symbolS *csect;

      /* The value is the offset from the enclosing csect.  */
      block = symbol_get_tc (sym)->within;
      csect = symbol_get_tc (block)->within;
      resolve_symbol_value (csect);
      S_SET_VALUE (sym, S_GET_VALUE (sym) - S_GET_VALUE (csect));
    }
  else if (S_GET_STORAGE_CLASS (sym) == C_BINCL
	   || S_GET_STORAGE_CLASS (sym) == C_EINCL)
    {
      /* We want the value to be a file offset into the line numbers.
	 BFD will do that for us if we set the right flags.  We have
	 already set the value correctly.  */
      coffsymbol (symbol_get_bfdsym (sym))->native->fix_line = 1;
    }

  return 0;
}

/* Adjust the symbol table.  This creates csect symbols for all
   absolute symbols.  */

void
ppc_adjust_symtab ()
{
  symbolS *sym;

  if (! ppc_saw_abs)
    return;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      symbolS *csect;
      int i;
      union internal_auxent *a;

      if (S_GET_SEGMENT (sym) != absolute_section)
	continue;

      csect = symbol_create (".abs[XO]", absolute_section,
			     S_GET_VALUE (sym), &zero_address_frag);
      symbol_get_bfdsym (csect)->value = S_GET_VALUE (sym);
      S_SET_STORAGE_CLASS (csect, C_HIDEXT);
      i = S_GET_NUMBER_AUXILIARY (csect);
      S_SET_NUMBER_AUXILIARY (csect, i + 1);
      a = &coffsymbol (symbol_get_bfdsym (csect))->native[i + 1].u.auxent;
      a->x_csect.x_scnlen.l = 0;
      a->x_csect.x_smtyp = XTY_SD;
      a->x_csect.x_parmhash = 0;
      a->x_csect.x_snhash = 0;
      a->x_csect.x_smclas = XMC_XO;
      a->x_csect.x_stab = 0;
      a->x_csect.x_snstab = 0;

      symbol_insert (csect, sym, &symbol_rootP, &symbol_lastP);

      i = S_GET_NUMBER_AUXILIARY (sym);
      a = &coffsymbol (symbol_get_bfdsym (sym))->native[i].u.auxent;
      a->x_csect.x_scnlen.p = coffsymbol (symbol_get_bfdsym (csect))->native;
      coffsymbol (symbol_get_bfdsym (sym))->native[i].fix_scnlen = 1;
    }

  ppc_saw_abs = FALSE;
}

/* Set the VMA for a section.  This is called on all the sections in
   turn.  */

void
ppc_frob_section (sec)
     asection *sec;
{
  static bfd_vma vma = 0;

  vma = md_section_align (sec, vma);
  bfd_set_section_vma (stdoutput, sec, vma);
  vma += bfd_section_size (stdoutput, sec);
}

#endif /* OBJ_XCOFF */

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (type, litp, sizep)
     int type;
     char *litp;
     int *sizep;
{
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litp, (valueT) words[i], 2);
	  litp += 2;
	}
    }
  else
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litp, (valueT) words[i], 2);
	  litp += 2;
	}
    }

  return NULL;
}

/* Write a value out to the object file, using the appropriate
   endianness.  */

void
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

/* Align a section (I don't know why this is machine dependent).  */

valueT
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
{
  int align = bfd_get_section_alignment (stdoutput, seg);

  return ((addr + (1 << align) - 1) & (-1 << align));
}

/* We don't have any form of relaxing.  */

int
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
{
  abort ();
  return 0;
}

/* Convert a machine dependent frag.  We never generate these.  */

void
md_convert_frag (abfd, sec, fragp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragp ATTRIBUTE_UNUSED;
{
  abort ();
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

/* Functions concerning relocs.  */

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec ATTRIBUTE_UNUSED;
{
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

#ifdef OBJ_XCOFF

/* This is called to see whether a fixup should be adjusted to use a
   section symbol.  We take the opportunity to change a fixup against
   a symbol in the TOC subsegment into a reloc against the
   corresponding .tc symbol.  */

int
ppc_fix_adjustable (fix)
     fixS *fix;
{
  valueT val = resolve_symbol_value (fix->fx_addsy);
  segT symseg = S_GET_SEGMENT (fix->fx_addsy);
  TC_SYMFIELD_TYPE *tc;

  if (symseg == absolute_section)
    return 0;

  if (ppc_toc_csect != (symbolS *) NULL
      && fix->fx_addsy != ppc_toc_csect
      && symseg == data_section
      && val >= ppc_toc_frag->fr_address
      && (ppc_after_toc_frag == (fragS *) NULL
	  || val < ppc_after_toc_frag->fr_address))
    {
      symbolS *sy;

      for (sy = symbol_next (ppc_toc_csect);
	   sy != (symbolS *) NULL;
	   sy = symbol_next (sy))
	{
	  TC_SYMFIELD_TYPE *sy_tc = symbol_get_tc (sy);

	  if (sy_tc->class == XMC_TC0)
	    continue;
	  if (sy_tc->class != XMC_TC)
	    break;
	  if (val == resolve_symbol_value (sy))
	    {
	      fix->fx_addsy = sy;
	      fix->fx_addnumber = val - ppc_toc_frag->fr_address;
	      return 0;
	    }
	}

      as_bad_where (fix->fx_file, fix->fx_line,
		    _("symbol in .toc does not match any .tc"));
    }

  /* Possibly adjust the reloc to be against the csect.  */
  tc = symbol_get_tc (fix->fx_addsy);
  if (tc->subseg == 0
      && tc->class != XMC_TC0
      && tc->class != XMC_TC
      && symseg != bss_section
      /* Don't adjust if this is a reloc in the toc section.  */
      && (symseg != data_section
	  || ppc_toc_csect == NULL
	  || val < ppc_toc_frag->fr_address
	  || (ppc_after_toc_frag != NULL
	      && val >= ppc_after_toc_frag->fr_address)))
    {
      symbolS *csect;
      symbolS *next_csect;

      if (symseg == text_section)
	csect = ppc_text_csects;
      else if (symseg == data_section)
	csect = ppc_data_csects;
      else
	abort ();

      /* Skip the initial dummy symbol.  */
      csect = symbol_get_tc (csect)->next;

      if (csect != (symbolS *) NULL)
	{
	  while ((next_csect = symbol_get_tc (csect)->next) != (symbolS *) NULL
		 && (symbol_get_frag (next_csect)->fr_address <= val))
	    {
	      /* If the csect address equals the symbol value, then we
		 have to look through the full symbol table to see
		 whether this is the csect we want.  Note that we will
		 only get here if the csect has zero length.  */
	      if (symbol_get_frag (csect)->fr_address == val
		  && S_GET_VALUE (csect) == val)
		{
		  symbolS *scan;

		  for (scan = symbol_next (csect);
		       scan != NULL;
		       scan = symbol_next (scan))
		    {
		      if (symbol_get_tc (scan)->subseg != 0)
			break;
		      if (scan == fix->fx_addsy)
			break;
		    }

		  /* If we found the symbol before the next csect
		     symbol, then this is the csect we want.  */
		  if (scan == fix->fx_addsy)
		    break;
		}

	      csect = next_csect;
	    }

	  fix->fx_offset += val - symbol_get_frag (csect)->fr_address;
	  fix->fx_addsy = csect;
	}
      return 0;
    }

  /* Adjust a reloc against a .lcomm symbol to be against the base
     .lcomm.  */
  if (symseg == bss_section
      && ! S_IS_EXTERNAL (fix->fx_addsy))
    {
      symbolS *sy = symbol_get_frag (fix->fx_addsy)->fr_symbol;

      fix->fx_offset += val - resolve_symbol_value (sy);
      fix->fx_addsy = sy;
    }

  return 0;
}

/* A reloc from one csect to another must be kept.  The assembler
   will, of course, keep relocs between sections, and it will keep
   absolute relocs, but we need to force it to keep PC relative relocs
   between two csects in the same section.  */

int
ppc_force_relocation (fix)
     fixS *fix;
{
  /* At this point fix->fx_addsy should already have been converted to
     a csect symbol.  If the csect does not include the fragment, then
     we need to force the relocation.  */
  if (fix->fx_pcrel
      && fix->fx_addsy != NULL
      && symbol_get_tc (fix->fx_addsy)->subseg != 0
      && ((symbol_get_frag (fix->fx_addsy)->fr_address
	   > fix->fx_frag->fr_address)
	  || (symbol_get_tc (fix->fx_addsy)->next != NULL
	      && (symbol_get_frag (symbol_get_tc (fix->fx_addsy)->next)->fr_address
		  <= fix->fx_frag->fr_address))))
    return 1;

  return generic_force_reloc (fix);
}

#endif /* OBJ_XCOFF */

#ifdef OBJ_ELF
/* If this function returns non-zero, it guarantees that a relocation
   will be emitted for a fixup.  */

int
ppc_force_relocation (fix)
     fixS *fix;
{
  /* Branch prediction relocations must force a relocation, as must
     the vtable description relocs.  */
  switch (fix->fx_r_type)
    {
    case BFD_RELOC_PPC_B16_BRTAKEN:
    case BFD_RELOC_PPC_B16_BRNTAKEN:
    case BFD_RELOC_PPC_BA16_BRTAKEN:
    case BFD_RELOC_PPC_BA16_BRNTAKEN:
    case BFD_RELOC_PPC64_TOC:
      return 1;
    default:
      break;
    }

  if (fix->fx_r_type >= BFD_RELOC_PPC_TLS
      && fix->fx_r_type <= BFD_RELOC_PPC64_DTPREL16_HIGHESTA)
    return 1;

  return generic_force_reloc (fix);
}

int
ppc_fix_adjustable (fix)
     fixS *fix;
{
  return (fix->fx_r_type != BFD_RELOC_16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_LO16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_HI16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_HI16_S_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_GPREL16
	  && fix->fx_r_type != BFD_RELOC_VTABLE_INHERIT
	  && fix->fx_r_type != BFD_RELOC_VTABLE_ENTRY
	  && !(fix->fx_r_type >= BFD_RELOC_PPC_TLS
	       && fix->fx_r_type <= BFD_RELOC_PPC64_DTPREL16_HIGHESTA)
	  && (fix->fx_pcrel
	      || (fix->fx_subsy != NULL
		  && (S_GET_SEGMENT (fix->fx_subsy)
		      == S_GET_SEGMENT (fix->fx_addsy)))
	      || S_IS_LOCAL (fix->fx_addsy)));
}
#endif

/* Apply a fixup to the object code.  This is called for all the
   fixups we generated by the call to fix_new_exp, above.  In the call
   above we used a reloc code which was the largest legal reloc code
   plus the operand index.  Here we undo that to recover the operand
   index.  At this point all symbol values should be fully resolved,
   and we attempt to completely resolve the reloc.  If we can not do
   that, we determine the correct reloc code and put it back in the
   fixup.  */

void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
{
  valueT value = * valP;

#ifdef OBJ_ELF
  if (fixP->fx_addsy != NULL)
    {
      /* Hack around bfd_install_relocation brain damage.  */
      if (fixP->fx_pcrel)
	value += fixP->fx_frag->fr_address + fixP->fx_where;
    }
  else
    fixP->fx_done = 1;
#else
  /* FIXME FIXME FIXME: The value we are passed in *valP includes
     the symbol values.  Since we are using BFD_ASSEMBLER, if we are
     doing this relocation the code in write.c is going to call
     bfd_install_relocation, which is also going to use the symbol
     value.  That means that if the reloc is fully resolved we want to
     use *valP since bfd_install_relocation is not being used.
     However, if the reloc is not fully resolved we do not want to use
     *valP, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valP since it includes the
     result of md_pcrel_from.  This is confusing.  */
  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  else if (fixP->fx_pcrel)
    ;

  else
    value = fixP->fx_offset;
#endif

  if (fixP->fx_subsy != (symbolS *) NULL)
    {
      /* We can't actually support subtracting a symbol.  */
      as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));
    }

  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int opindex;
      const struct powerpc_operand *operand;
      char *where;
      unsigned long insn;

      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;

      operand = &powerpc_operands[opindex];

#ifdef OBJ_XCOFF
      /* An instruction like `lwz 9,sym(30)' when `sym' is not a TOC symbol
	 does not generate a reloc.  It uses the offset of `sym' within its
	 csect.  Other usages, such as `.long sym', generate relocs.  This
	 is the documented behaviour of non-TOC symbols.  */
      if ((operand->flags & PPC_OPERAND_PARENS) != 0
	  && operand->bits == 16
	  && operand->shift == 0
	  && (operand->insert == NULL || ppc_obj64)
	  && fixP->fx_addsy != NULL
	  && symbol_get_tc (fixP->fx_addsy)->subseg != 0
	  && symbol_get_tc (fixP->fx_addsy)->class != XMC_TC
	  && symbol_get_tc (fixP->fx_addsy)->class != XMC_TC0
	  && S_GET_SEGMENT (fixP->fx_addsy) != bss_section)
	{
	  value = fixP->fx_offset;
	  fixP->fx_done = 1;
	}
#endif

      /* Fetch the instruction, insert the fully resolved operand
	 value, and stuff the instruction back again.  */
      where = fixP->fx_frag->fr_literal + fixP->fx_where;
      if (target_big_endian)
	insn = bfd_getb32 ((unsigned char *) where);
      else
	insn = bfd_getl32 ((unsigned char *) where);
      insn = ppc_insert_operand (insn, operand, (offsetT) value,
				 fixP->fx_file, fixP->fx_line);
      if (target_big_endian)
	bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
      else
	bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);

      if (fixP->fx_done)
	/* Nothing else to do here.  */
	return;

      assert (fixP->fx_addsy != NULL);

      /* Determine a BFD reloc value based on the operand information.
	 We are only prepared to turn a few of the operands into
	 relocs.  */
      if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
	  && operand->bits == 26
	  && operand->shift == 0)
	fixP->fx_r_type = BFD_RELOC_PPC_B26;
      else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0
	  && operand->bits == 16
	  && operand->shift == 0)
	{
	  fixP->fx_r_type = BFD_RELOC_PPC_B16;
#ifdef OBJ_XCOFF
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
#endif
	}
      else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
	       && operand->bits == 26
	       && operand->shift == 0)
	fixP->fx_r_type = BFD_RELOC_PPC_BA26;
      else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0
	       && operand->bits == 16
	       && operand->shift == 0)
	{
	  fixP->fx_r_type = BFD_RELOC_PPC_BA16;
#ifdef OBJ_XCOFF
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
#endif
	}
#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
      else if ((operand->flags & PPC_OPERAND_PARENS) != 0
	       && operand->bits == 16
	       && operand->shift == 0)
	{
	  if (ppc_is_toc_sym (fixP->fx_addsy))
	    {
	      fixP->fx_r_type = BFD_RELOC_PPC_TOC16;
#ifdef OBJ_ELF
	      if (ppc_obj64
		  && (operand->flags & PPC_OPERAND_DS) != 0)
		fixP->fx_r_type = BFD_RELOC_PPC64_TOC16_DS;
#endif
	    }
	  else
	    {
	      fixP->fx_r_type = BFD_RELOC_16;
#ifdef OBJ_ELF
	      if (ppc_obj64
		  && (operand->flags & PPC_OPERAND_DS) != 0)
		fixP->fx_r_type = BFD_RELOC_PPC64_ADDR16_DS;
#endif
	    }
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
	}
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */
      else
	{
	  char *sfile;
	  unsigned int sline;

	  /* Use expr_symbol_where to see if this is an expression
	     symbol.  */
	  if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unresolved expression that must be resolved"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unsupported relocation against %s"),
			  S_GET_NAME (fixP->fx_addsy));
	  fixP->fx_done = 1;
	  return;
	}
    }
  else
    {
#ifdef OBJ_ELF
      ppc_elf_validate_fix (fixP, seg);
#endif
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_CTOR:
	  if (ppc_obj64)
	    goto ctor64;
	  /* fall through */

	case BFD_RELOC_32:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  /* fall through */

	case BFD_RELOC_RVA:
	case BFD_RELOC_32_PCREL:
	case BFD_RELOC_PPC_EMB_NADDR32:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 4);
	  break;

	case BFD_RELOC_64:
	ctor64:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_64_PCREL;
	  /* fall through */

	case BFD_RELOC_64_PCREL:
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 8);
	  break;

	case BFD_RELOC_LO16:
	case BFD_RELOC_16:
	case BFD_RELOC_GPREL16:
	case BFD_RELOC_16_GOT_PCREL:
	case BFD_RELOC_16_GOTOFF:
	case BFD_RELOC_LO16_GOTOFF:
	case BFD_RELOC_HI16_GOTOFF:
	case BFD_RELOC_HI16_S_GOTOFF:
	case BFD_RELOC_16_BASEREL:
	case BFD_RELOC_LO16_BASEREL:
	case BFD_RELOC_HI16_BASEREL:
	case BFD_RELOC_HI16_S_BASEREL:
	case BFD_RELOC_PPC_EMB_NADDR16:
	case BFD_RELOC_PPC_EMB_NADDR16_LO:
	case BFD_RELOC_PPC_EMB_NADDR16_HI:
	case BFD_RELOC_PPC_EMB_NADDR16_HA:
	case BFD_RELOC_PPC_EMB_SDAI16:
	case BFD_RELOC_PPC_EMB_SDA2REL:
	case BFD_RELOC_PPC_EMB_SDA2I16:
	case BFD_RELOC_PPC_EMB_RELSEC16:
	case BFD_RELOC_PPC_EMB_RELST_LO:
	case BFD_RELOC_PPC_EMB_RELST_HI:
	case BFD_RELOC_PPC_EMB_RELST_HA:
	case BFD_RELOC_PPC_EMB_RELSDA:
	case BFD_RELOC_PPC_TOC16:
#ifdef OBJ_ELF
	case BFD_RELOC_PPC64_TOC16_LO:
	case BFD_RELOC_PPC64_TOC16_HI:
	case BFD_RELOC_PPC64_TOC16_HA:
#endif
	  if (fixP->fx_pcrel)
	    {
	      if (fixP->fx_addsy != NULL)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("cannot emit PC relative %s relocation against %s"),
			      bfd_get_reloc_code_name (fixP->fx_r_type),
			      S_GET_NAME (fixP->fx_addsy));
	      else
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("cannot emit PC relative %s relocation"),
			      bfd_get_reloc_code_name (fixP->fx_r_type));
	    }

	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 2);
	  break;

	  /* This case happens when you write, for example,
	     lis %r3,(L1-L2)@@ha
	     where L1 and L2 are defined later.  */
	case BFD_RELOC_HI16:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HI (value), 2);
	  break;

	case BFD_RELOC_HI16_S:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HA (value), 2);
	  break;

#ifdef OBJ_ELF
	case BFD_RELOC_PPC64_HIGHER:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHER (value), 2);
	  break;

	case BFD_RELOC_PPC64_HIGHER_S:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHERA (value), 2);
	  break;

	case BFD_RELOC_PPC64_HIGHEST:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHEST (value), 2);
	  break;

	case BFD_RELOC_PPC64_HIGHEST_S:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHESTA (value), 2);
	  break;

	case BFD_RELOC_PPC64_ADDR16_DS:
	case BFD_RELOC_PPC64_ADDR16_LO_DS:
	case BFD_RELOC_PPC64_GOT16_DS:
	case BFD_RELOC_PPC64_GOT16_LO_DS:
	case BFD_RELOC_PPC64_PLT16_LO_DS:
	case BFD_RELOC_PPC64_SECTOFF_DS:
	case BFD_RELOC_PPC64_SECTOFF_LO_DS:
	case BFD_RELOC_PPC64_TOC16_DS:
	case BFD_RELOC_PPC64_TOC16_LO_DS:
	case BFD_RELOC_PPC64_PLTGOT16_DS:
	case BFD_RELOC_PPC64_PLTGOT16_LO_DS:
	  if (fixP->fx_pcrel)
	    abort ();
	  {
	    unsigned char *where = fixP->fx_frag->fr_literal + fixP->fx_where;
	    unsigned long val, mask;

	    if (target_big_endian)
	      val = bfd_getb32 (where - 2);
	    else
	      val = bfd_getl32 (where);
	    mask = 0xfffc;
	    /* lq insns reserve the four lsbs.  */
	    if ((ppc_cpu & PPC_OPCODE_POWER4) != 0
		&& (val & (0x3f << 26)) == (56u << 26))
	      mask = 0xfff0;
	    val |= value & mask;
	    if (target_big_endian)
	      bfd_putb16 ((bfd_vma) val, where);
	    else
	      bfd_putl16 ((bfd_vma) val, where);
	  }
	  break;

	case BFD_RELOC_PPC_B16_BRTAKEN:
	case BFD_RELOC_PPC_B16_BRNTAKEN:
	case BFD_RELOC_PPC_BA16_BRTAKEN:
	case BFD_RELOC_PPC_BA16_BRNTAKEN:
	  break;

	case BFD_RELOC_PPC_TLS:
	case BFD_RELOC_PPC_DTPMOD:
	case BFD_RELOC_PPC_TPREL16:
	case BFD_RELOC_PPC_TPREL16_LO:
	case BFD_RELOC_PPC_TPREL16_HI:
	case BFD_RELOC_PPC_TPREL16_HA:
	case BFD_RELOC_PPC_TPREL:
	case BFD_RELOC_PPC_DTPREL16:
	case BFD_RELOC_PPC_DTPREL16_LO:
	case BFD_RELOC_PPC_DTPREL16_HI:
	case BFD_RELOC_PPC_DTPREL16_HA:
	case BFD_RELOC_PPC_DTPREL:
	case BFD_RELOC_PPC_GOT_TLSGD16:
	case BFD_RELOC_PPC_GOT_TLSGD16_LO:
	case BFD_RELOC_PPC_GOT_TLSGD16_HI:
	case BFD_RELOC_PPC_GOT_TLSGD16_HA:
	case BFD_RELOC_PPC_GOT_TLSLD16:
	case BFD_RELOC_PPC_GOT_TLSLD16_LO:
	case BFD_RELOC_PPC_GOT_TLSLD16_HI:
	case BFD_RELOC_PPC_GOT_TLSLD16_HA:
	case BFD_RELOC_PPC_GOT_TPREL16:
	case BFD_RELOC_PPC_GOT_TPREL16_LO:
	case BFD_RELOC_PPC_GOT_TPREL16_HI:
	case BFD_RELOC_PPC_GOT_TPREL16_HA:
	case BFD_RELOC_PPC_GOT_DTPREL16:
	case BFD_RELOC_PPC_GOT_DTPREL16_LO:
	case BFD_RELOC_PPC_GOT_DTPREL16_HI:
	case BFD_RELOC_PPC_GOT_DTPREL16_HA:
	case BFD_RELOC_PPC64_TPREL16_DS:
	case BFD_RELOC_PPC64_TPREL16_LO_DS:
	case BFD_RELOC_PPC64_TPREL16_HIGHER:
	case BFD_RELOC_PPC64_TPREL16_HIGHERA:
	case BFD_RELOC_PPC64_TPREL16_HIGHEST:
	case BFD_RELOC_PPC64_TPREL16_HIGHESTA:
	case BFD_RELOC_PPC64_DTPREL16_DS:
	case BFD_RELOC_PPC64_DTPREL16_LO_DS:
	case BFD_RELOC_PPC64_DTPREL16_HIGHER:
	case BFD_RELOC_PPC64_DTPREL16_HIGHERA:
	case BFD_RELOC_PPC64_DTPREL16_HIGHEST:
	case BFD_RELOC_PPC64_DTPREL16_HIGHESTA:
	  break;
#endif
	  /* Because SDA21 modifies the register field, the size is set to 4
	     bytes, rather than 2, so offset it here appropriately.  */
	case BFD_RELOC_PPC_EMB_SDA21:
	  if (fixP->fx_pcrel)
	    abort ();

	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where
			      + ((target_big_endian) ? 2 : 0),
			      value, 2);
	  break;

	case BFD_RELOC_8:
	  if (fixP->fx_pcrel)
	    {
	      /* This can occur if there is a bug in the input assembler, eg:
		 ".byte <undefined_symbol> - ."  */
	      if (fixP->fx_addsy)
		as_bad (_("Unable to handle reference to symbol %s"),
			S_GET_NAME (fixP->fx_addsy));
	      else
		as_bad (_("Unable to resolve expression"));
	      fixP->fx_done = 1;
	    }
	  else
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
				value, 1);
	  break;

	case BFD_RELOC_24_PLT_PCREL:
	case BFD_RELOC_PPC_LOCAL24PC:
	  if (!fixP->fx_pcrel && !fixP->fx_done)
	    abort ();

	  if (fixP->fx_done)
	    {
	      char *where;
	      unsigned long insn;

	      /* Fetch the instruction, insert the fully resolved operand
		 value, and stuff the instruction back again.  */
	      where = fixP->fx_frag->fr_literal + fixP->fx_where;
	      if (target_big_endian)
		insn = bfd_getb32 ((unsigned char *) where);
	      else
		insn = bfd_getl32 ((unsigned char *) where);
	      if ((value & 3) != 0)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("must branch to an address a multiple of 4"));
	      if ((offsetT) value < -0x40000000
		  || (offsetT) value >= 0x40000000)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("@@local or @@plt branch destination is too far away, %ld bytes"),
			      (long) value);
	      insn = insn | (value & 0x03fffffc);
	      if (target_big_endian)
		bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	      else
		bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
	    }
	  break;

	case BFD_RELOC_VTABLE_INHERIT:
	  fixP->fx_done = 0;
	  if (fixP->fx_addsy
	      && !S_IS_DEFINED (fixP->fx_addsy)
	      && !S_IS_WEAK (fixP->fx_addsy))
	    S_SET_WEAK (fixP->fx_addsy);
	  break;

	case BFD_RELOC_VTABLE_ENTRY:
	  fixP->fx_done = 0;
	  break;

#ifdef OBJ_ELF
	  /* Generated by reference to `sym@@tocbase'.  The sym is
	     ignored by the linker.  */
	case BFD_RELOC_PPC64_TOC:
	  fixP->fx_done = 0;
	  break;
#endif
	default:
	  fprintf (stderr,
		   _("Gas failure, reloc value %d\n"), fixP->fx_r_type);
	  fflush (stderr);
	  abort ();
	}
    }

#ifdef OBJ_ELF
  fixP->fx_addnumber = value;
#else
  if (fixP->fx_r_type != BFD_RELOC_PPC_TOC16)
    fixP->fx_addnumber = 0;
  else
    {
#ifdef TE_PE
      fixP->fx_addnumber = 0;
#else
      /* We want to use the offset within the data segment of the
	 symbol, not the actual VMA of the symbol.  */
      fixP->fx_addnumber =
	- bfd_get_section_vma (stdoutput, S_GET_SEGMENT (fixP->fx_addsy));
#endif
    }
#endif
}

/* Generate a reloc for a fixup.  */

arelent *
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *reloc;

  reloc = (arelent *) xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }
  reloc->addend = fixp->fx_addnumber;

  return reloc;
}

void
ppc_cfi_frame_initial_instructions ()
{
  cfi_add_CFA_def_cfa (1, 0);
}

int
tc_ppc_regname_to_dw2regnum (const char *regname)
{
  unsigned int regnum = -1;
  unsigned int i;
  const char *p;
  char *q;
  static struct { char *name; int dw2regnum; } regnames[] =
    {
      { "sp", 1 }, { "r.sp", 1 }, { "rtoc", 2 }, { "r.toc", 2 },
      { "mq", 64 }, { "lr", 65 }, { "ctr", 66 }, { "ap", 67 },
      { "cc", 68 }, { "xer", 76 }, { "vrsave", 109 }, { "vscr", 110 },
      { "spe_acc", 111 }, { "spefscr", 112 }
    };

  for (i = 0; i < ARRAY_SIZE (regnames); ++i)
    if (strcmp (regnames[i].name, regname) == 0)
      return regnames[i].dw2regnum;

  if (regname[0] == 'r' || regname[0] == 'f' || regname[0] == 'v')
    {
      p = regname + 1 + (regname[1] == '.');
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 32)
	return -1;
      if (regname[0] == 'f')
	regnum += 32;
      else if (regname[0] == 'v')
	regnum += 77;
    }
  else if (regname[0] == 'c' && regname[1] == 'r')
    {
      p = regname + 2 + (regname[2] == '.');
      if (p[0] < '0' || p[0] > '7' || p[1])
	return -1;
      regnum = p[0] - '0' + 68;
    }
  return regnum;
}
@


1.10
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d27 1
a27 1

d114 1
a114 1
static void ppc_change_csect PARAMS ((symbolS *));
d185 7
a242 2
  { "file",	(void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
  { "loc",	dwarf2_directive_loc, 0 },
d822 101
d990 2
a991 86
      /* -mpwrx and -mpwr2 mean to assemble for the IBM POWER/2
	 (RIOS2).  */
      if (strcmp (arg, "pwrx") == 0 || strcmp (arg, "pwr2") == 0)
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_POWER2 | PPC_OPCODE_32;
      /* -mpwr means to assemble for the IBM POWER (RIOS1).  */
      else if (strcmp (arg, "pwr") == 0)
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
      /* -m601 means to assemble for the PowerPC 601, which includes
	 instructions that are holdovers from the Power.  */
      else if (strcmp (arg, "601") == 0)
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		   | PPC_OPCODE_601 | PPC_OPCODE_32);
      /* -mppc, -mppc32, -m603, and -m604 mean to assemble for the
	 PowerPC 603/604.  */
      else if (strcmp (arg, "ppc") == 0
	       || strcmp (arg, "ppc32") == 0
	       || strcmp (arg, "603") == 0
	       || strcmp (arg, "604") == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
      /* -m403 and -m405 mean to assemble for the PowerPC 403/405.  */
      else if (strcmp (arg, "403") == 0
	       || strcmp (arg, "405") == 0)
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		   | PPC_OPCODE_403 | PPC_OPCODE_32);
      else if (strcmp (arg, "7400") == 0
	       || strcmp (arg, "7410") == 0
	       || strcmp (arg, "7450") == 0
	       || strcmp (arg, "7455") == 0)
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		   | PPC_OPCODE_ALTIVEC | PPC_OPCODE_32);
      else if (strcmp (arg, "altivec") == 0)
	{
	  if (ppc_cpu == 0)
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_ALTIVEC;
	  else
	    ppc_cpu |= PPC_OPCODE_ALTIVEC;
	}
      else if (strcmp (arg, "e500") == 0 || strcmp (arg, "e500x2") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
		     | PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
		     | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
		     | PPC_OPCODE_RFMCI);
	}
      else if (strcmp (arg, "spe") == 0)
	{
	  if (ppc_cpu == 0)
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_SPE | PPC_OPCODE_EFS;
	  else
	    ppc_cpu |= PPC_OPCODE_SPE;
	}
      /* -mppc64 and -m620 mean to assemble for the 64-bit PowerPC
	 620.  */
      else if (strcmp (arg, "ppc64") == 0 || strcmp (arg, "620") == 0)
	{
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
	}
      else if (strcmp (arg, "ppc64bridge") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		     | PPC_OPCODE_64_BRIDGE | PPC_OPCODE_64);
	}
      /* -mbooke/-mbooke32 mean enable 32-bit BookE support.  */
      else if (strcmp (arg, "booke") == 0 || strcmp (arg, "booke32") == 0)
	{
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32;
	}
      /* -mbooke64 means enable 64-bit BookE support.  */
      else if (strcmp (arg, "booke64") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE
		     | PPC_OPCODE_BOOKE64 | PPC_OPCODE_64);
	}
      else if (strcmp (arg, "power4") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		     | PPC_OPCODE_64 | PPC_OPCODE_POWER4);
	}
      /* -mcom means assemble for the common intersection between Power
	 and PowerPC.  At present, we just allow the union, rather
	 than the intersection.  */
      else if (strcmp (arg, "com") == 0)
	ppc_cpu = PPC_OPCODE_COMMON | PPC_OPCODE_32;
      /* -many means to assemble for any architecture (PWR/PWRX/PPC).  */
      else if (strcmp (arg, "any") == 0)
	ppc_cpu = PPC_OPCODE_ANY | PPC_OPCODE_32;
d1085 2
d1093 2
a1094 1
-m403, -m405            generate code for PowerPC 403/405\n\
d1096 2
a1097 1
			generate code For PowerPC 7400/7410/7450/7455\n\
d1103 3
d1107 2
a1108 2
-mcom			generate code Power/PowerPC common instructions\n\
-many			generate code for any architecture (PWR/PWRX/PPC)\n\
a1110 3
  fprintf (stream, _("\
-me500, -me500x2	generate code for Motorola e500 core complex\n\
-mspe			generate code for Motorola SPE instructions\n"));
d1116 1
a1116 1
-mlittle, -mlittle-endian\n\
d1118 2
a1119 1
-mbig, -mbig-endian	generate code for a big endian machine\n\
d1135 1
a1135 1
  if (ppc_cpu == 0)
d1138 1
a1138 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
d1141 1
a1141 1
	ppc_cpu = PPC_OPCODE_COMMON | PPC_OPCODE_32;
d1143 1
a1143 1
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
d1145 1
a1145 1
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
d1149 1
a1149 1
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
d1151 1
a1151 1
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
d1217 2
a1218 3
/* This function is called when the assembler starts up.  It is called
   after the options have been parsed and the output file has been
   opened.  */
d1220 2
a1221 2
void
md_begin ()
d1229 4
a1232 7
  ppc_set_cpu ();

#ifdef OBJ_ELF
  /* Set the ELF flags if desired.  */
  if (ppc_flags && !msolaris)
    bfd_set_private_flags (stdoutput, ppc_flags);
#endif
d1262 1
a1262 1
	  if (retval != (const char *) NULL)
d1276 4
d1301 1
d1303 20
a1322 1
  /* Tell the main code what the endianness is if it is not overidden
d1386 1
a1386 1
    md_number_to_chars (p, (valueT) ppc_apuinfo_num, 4);
d1496 4
a1499 2
    int length;
    int reloc;
d1509 3
a1511 1
#define MAP(str,reloc) { str, sizeof (str)-1, reloc }
d1514 86
a1599 88
    MAP ("l",			(int) BFD_RELOC_LO16),
    MAP ("h",			(int) BFD_RELOC_HI16),
    MAP ("ha",			(int) BFD_RELOC_HI16_S),
    MAP ("brtaken",		(int) BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",		(int) BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",			(int) BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",		(int) BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",		(int) BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",		(int) BFD_RELOC_HI16_S_GOTOFF),
    MAP ("fixup",		(int) BFD_RELOC_CTOR),
    MAP ("plt",			(int) BFD_RELOC_24_PLT_PCREL),
    MAP ("pltrel24",		(int) BFD_RELOC_24_PLT_PCREL),
    MAP ("copy",		(int) BFD_RELOC_PPC_COPY),
    MAP ("globdat",		(int) BFD_RELOC_PPC_GLOB_DAT),
    MAP ("local24pc",		(int) BFD_RELOC_PPC_LOCAL24PC),
    MAP ("local",		(int) BFD_RELOC_PPC_LOCAL24PC),
    MAP ("pltrel",		(int) BFD_RELOC_32_PLT_PCREL),
    MAP ("plt@@l",		(int) BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",		(int) BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",		(int) BFD_RELOC_HI16_S_PLTOFF),
    MAP ("sdarel",		(int) BFD_RELOC_GPREL16),
    MAP ("sectoff",		(int) BFD_RELOC_16_BASEREL),
    MAP ("sectoff@@l",		(int) BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",		(int) BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",		(int) BFD_RELOC_HI16_S_BASEREL),
    MAP ("naddr",		(int) BFD_RELOC_PPC_EMB_NADDR32),
    MAP ("naddr16",		(int) BFD_RELOC_PPC_EMB_NADDR16),
    MAP ("naddr@@l",		(int) BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP ("naddr@@h",		(int) BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP ("naddr@@ha",		(int) BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP ("sdai16",		(int) BFD_RELOC_PPC_EMB_SDAI16),
    MAP ("sda2rel",		(int) BFD_RELOC_PPC_EMB_SDA2REL),
    MAP ("sda2i16",		(int) BFD_RELOC_PPC_EMB_SDA2I16),
    MAP ("sda21",		(int) BFD_RELOC_PPC_EMB_SDA21),
    MAP ("mrkref",		(int) BFD_RELOC_PPC_EMB_MRKREF),
    MAP ("relsect",		(int) BFD_RELOC_PPC_EMB_RELSEC16),
    MAP ("relsect@@l",		(int) BFD_RELOC_PPC_EMB_RELST_LO),
    MAP ("relsect@@h",		(int) BFD_RELOC_PPC_EMB_RELST_HI),
    MAP ("relsect@@ha",		(int) BFD_RELOC_PPC_EMB_RELST_HA),
    MAP ("bitfld",		(int) BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP ("relsda",		(int) BFD_RELOC_PPC_EMB_RELSDA),
    MAP ("xgot",		(int) BFD_RELOC_PPC_TOC16),
    MAP ("tls",			(int) BFD_RELOC_PPC_TLS),
    MAP ("dtpmod",		(int) BFD_RELOC_PPC_DTPMOD),
    MAP ("dtprel",		(int) BFD_RELOC_PPC_DTPREL),
    MAP ("dtprel@@l",		(int) BFD_RELOC_PPC_DTPREL16_LO),
    MAP ("dtprel@@h",		(int) BFD_RELOC_PPC_DTPREL16_HI),
    MAP ("dtprel@@ha",		(int) BFD_RELOC_PPC_DTPREL16_HA),
    MAP ("tprel",		(int) BFD_RELOC_PPC_TPREL),
    MAP ("tprel@@l",		(int) BFD_RELOC_PPC_TPREL16_LO),
    MAP ("tprel@@h",		(int) BFD_RELOC_PPC_TPREL16_HI),
    MAP ("tprel@@ha",		(int) BFD_RELOC_PPC_TPREL16_HA),
    MAP ("got@@tlsgd",		(int) BFD_RELOC_PPC_GOT_TLSGD16),
    MAP ("got@@tlsgd@@l",		(int) BFD_RELOC_PPC_GOT_TLSGD16_LO),
    MAP ("got@@tlsgd@@h",		(int) BFD_RELOC_PPC_GOT_TLSGD16_HI),
    MAP ("got@@tlsgd@@ha",	(int) BFD_RELOC_PPC_GOT_TLSGD16_HA),
    MAP ("got@@tlsld",		(int) BFD_RELOC_PPC_GOT_TLSLD16),
    MAP ("got@@tlsld@@l",		(int) BFD_RELOC_PPC_GOT_TLSLD16_LO),
    MAP ("got@@tlsld@@h",		(int) BFD_RELOC_PPC_GOT_TLSLD16_HI),
    MAP ("got@@tlsld@@ha",	(int) BFD_RELOC_PPC_GOT_TLSLD16_HA),
    MAP ("got@@dtprel",		(int) BFD_RELOC_PPC_GOT_DTPREL16),
    MAP ("got@@dtprel@@l",	(int) BFD_RELOC_PPC_GOT_DTPREL16_LO),
    MAP ("got@@dtprel@@h",	(int) BFD_RELOC_PPC_GOT_DTPREL16_HI),
    MAP ("got@@dtprel@@ha",	(int) BFD_RELOC_PPC_GOT_DTPREL16_HA),
    MAP ("got@@tprel",		(int) BFD_RELOC_PPC_GOT_TPREL16),
    MAP ("got@@tprel@@l",		(int) BFD_RELOC_PPC_GOT_TPREL16_LO),
    MAP ("got@@tprel@@h",		(int) BFD_RELOC_PPC_GOT_TPREL16_HI),
    MAP ("got@@tprel@@ha",	(int) BFD_RELOC_PPC_GOT_TPREL16_HA),
    /* The following are only valid for ppc64.  Negative values are
       used instead of a flag.  */
    MAP ("higher",		- (int) BFD_RELOC_PPC64_HIGHER),
    MAP ("highera",		- (int) BFD_RELOC_PPC64_HIGHER_S),
    MAP ("highest",		- (int) BFD_RELOC_PPC64_HIGHEST),
    MAP ("highesta",		- (int) BFD_RELOC_PPC64_HIGHEST_S),
    MAP ("tocbase",		- (int) BFD_RELOC_PPC64_TOC),
    MAP ("toc",			- (int) BFD_RELOC_PPC_TOC16),
    MAP ("toc@@l",		- (int) BFD_RELOC_PPC64_TOC16_LO),
    MAP ("toc@@h",		- (int) BFD_RELOC_PPC64_TOC16_HI),
    MAP ("toc@@ha",		- (int) BFD_RELOC_PPC64_TOC16_HA),
    MAP ("dtprel@@higher",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHER),
    MAP ("dtprel@@highera",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHERA),
    MAP ("dtprel@@highest",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHEST),
    MAP ("dtprel@@highesta",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHESTA),
    MAP ("tprel@@higher",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHER),
    MAP ("tprel@@highera",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHERA),
    MAP ("tprel@@highest",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHEST),
    MAP ("tprel@@highesta",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHESTA),
    { (char *) 0, 0,		(int) BFD_RELOC_UNUSED }
d1620 2
a1621 1
	&& memcmp (ident, ptr->string, ptr->length) == 0)
a1624 7
	if (reloc < 0)
	  {
	    if (!ppc_obj64)
	      return BFD_RELOC_UNUSED;
	    reloc = -reloc;
	  }

d1653 2
a1654 1
	    && exp_p->X_op == O_symbol)
d1656 2
a1657 3
	    /* This reloc type ignores the symbol.  Change the symbol
	       so that the dummy .TOC. symbol can be omitted from the
	       object file.  */
d2135 8
a2142 7
     an optional operand separate the operands only with commas (in
     some cases parentheses are used, as in ``lwz 1,0(1)'' but such
     cases never have optional operands).  There is never more than
     one optional operand for an instruction.  So, before we start
     seriously parsing the operands, we check to see if we have an
     optional operand, and, if we do, we count the number of commas to
     see whether the operand should be omitted.  */
d2178 1
a2178 1
	     operand.  */
d2488 1
a2488 1
	      && (operand->flags & PPC_OPERAND_DS) != 0)
d2793 1
a2793 1
  return 0;
d2882 1
a2882 1
   symbols, and uses a different smclas.  The native Aix 4.3.3 assember
d3047 1
d3062 1
a3062 2
  ppc_change_csect (sym);

d3066 1
a3066 1
      symbol_get_tc (sym)->align = get_absolute_expression ();
d3069 2
d3077 1
a3077 1
ppc_change_csect (sym)
d3079 1
d3089 2
d3096 1
d3111 1
d3139 2
a3140 2
      subseg_new (segment_name (S_GET_SEGMENT (sym)),
		  symbol_get_tc (sym)->subseg);
d3147 6
d3156 1
a3156 1
      symbol_get_tc (sym)->align = 2;
d3194 1
a3194 1
  ppc_change_csect (sym);
d3231 1
a3231 1
  ppc_change_csect (sym);
d3437 1
a3437 1
   argment seems to be the label for the start of the function.  gcc
d3902 1
a3902 1
   relocateable symbol reference.  The size of the value to store
a3994 6
/* FIXME: `.machine' is a nop for the moment.  It would be nice to
   accept this directive on the first line of input and set ppc_obj64
   and the target format accordingly.  Unfortunately, the target
   format is selected in output-file.c:output_file_create before we
   even get to md_begin, so it's not possible without changing
   as.c:main.  */
d4000 56
a4055 1
  discard_rest_of_line ();
d5150 1
a5150 1
  static bfd_size_type vma = 0;
d5152 1
d5818 1
a5818 1
	    unsigned long val;
d5821 1
a5821 1
	      val = bfd_getb16 (where);
d5823 7
a5829 2
	      val = bfd_getl16 (where);
	    val |= (value & 0xfffc);
d5837 6
d5898 13
a5910 4
	    abort ();

	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      value, 1);
d6017 46
@


1.9
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
a23 1
#include <ctype.h>
d25 1
d50 1
a50 1
#define TARGET_REG_NAMES_P true
d52 1
a52 1
#define TARGET_REG_NAMES_P false
d56 2
a57 1
static boolean reg_names_p = TARGET_REG_NAMES_P;
d59 30
a88 1
static boolean register_name PARAMS ((expressionS *));
d95 2
d99 2
a123 1
static void ppc_machine PARAMS ((int));
d133 1
a224 1
  { "machine",  ppc_machine,    0 },
d228 2
d236 1
a236 1
  { "file",	dwarf2_directive_file, 0 },
d241 1
a241 1
  /* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format */
d256 1
a256 1
  /* This pseudo-op is used even when not generating XCOFF output.  */
d258 2
d265 3
a267 3
/* Predefined register names if -mregnames (or default for Windows NT).  */
/* In general, there are lots of them, in an attempt to be compatible */
/* with a number of other Windows NT assemblers.                      */
d595 1
a595 1
 * Summary of register_name().
d606 1
a606 1
static boolean
d615 1
a615 1
  /* Find the spelling of the operand */
d617 1
a617 1
  if (name[0] == '%' && isalpha (name[1]))
d620 2
a621 2
  else if (!reg_names_p || !isalpha (name[0]))
    return false;
d626 4
a629 1
  /* look to see if it's in the register table */
d635 1
a635 1
      /* make the rest nice */
d638 1
a638 9
      *input_line_pointer = c;   /* put back the delimiting char */
      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
      return false;
d640 4
d651 1
a651 1
static boolean cr_operand;
d699 1
a699 5
static int ppc_cpu = 0;

/* The size of the processor we are assembling for.  This is either
   PPC_OPCODE_32 or PPC_OPCODE_64.  */
static unsigned long ppc_size = PPC_OPCODE_32;
d701 2
a702 2
/* Whether to target xcoff64 */
static int ppc_xcoff64 = 0;
d711 1
a711 1
/* What type of shared library support to use */
d714 1
a714 1
/* Flags to set in the elf header */
d719 1
a719 1
#define SOLARIS_P true
d721 1
a721 1
#define SOLARIS_P false
d724 1
a724 1
static boolean msolaris = SOLARIS_P;
d791 14
d808 1
a808 1
CONST char *md_shortopts = "b:l:usm:K:VQ:";
d810 1
a810 1
CONST char *md_shortopts = "um:";
d812 1
a812 1
struct option md_longopts[] = {
d815 1
a815 1
size_t md_longopts_size = sizeof (md_longopts);
d832 1
a832 1
         sake, recognize -be also.  */
d855 1
a855 1
      /* Recognize -K PIC */
d870 7
a876 1
	ppc_xcoff64 = 1;
d878 1
a878 1
	ppc_xcoff64 = 0;
d885 1
a885 1
         (RIOS2).  */
d887 1
a887 1
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_POWER2;
d890 3
a892 3
	ppc_cpu = PPC_OPCODE_POWER;
      /* -m601 means to assemble for the Motorola PowerPC 601, which includes
         instructions that are holdovers from the Power.  */
d894 2
a895 1
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_601;
d897 1
a897 1
         Motorola PowerPC 603/604.  */
a899 2
	       || strcmp (arg, "403") == 0
	       || strcmp (arg, "405") == 0
d902 33
a934 3
	ppc_cpu = PPC_OPCODE_PPC;
      else if (strcmp (arg, "7400") == 0)
        ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC;
d936 1
a936 1
         620.  */
d939 1
a939 2
	  ppc_cpu = PPC_OPCODE_PPC;
	  ppc_size = PPC_OPCODE_64;
d943 18
a960 2
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64_BRIDGE;
	  ppc_size = PPC_OPCODE_64;
d966 1
a966 1
	ppc_cpu = PPC_OPCODE_COMMON;
d969 1
a969 1
	ppc_cpu = PPC_OPCODE_ANY;
d972 1
a972 1
	reg_names_p = true;
d975 1
a975 1
	reg_names_p = false;
d978 2
a979 1
      /* -mrelocatable/-mrelocatable-lib -- warn about initializations that require relocation */
d992 1
a992 1
      /* -memb, set embedded bit */
d996 3
a998 2
      /* -mlittle/-mbig set the endianess */
      else if (strcmp (arg, "little") == 0 || strcmp (arg, "little-endian") == 0)
d1012 1
a1012 1
	  msolaris = true;
d1018 1
a1018 1
	  msolaris = false;
d1064 9
a1072 6
-mpwrx, -mpwr2		generate code for IBM POWER/2 (RIOS2)\n\
-mpwr			generate code for IBM POWER (RIOS1)\n\
-m601			generate code for Motorola PowerPC 601\n\
-mppc, -mppc32, -m403, -m405, -m603, -m604\n\
			generate code for Motorola PowerPC 603/604\n\
-mppc64, -m620		generate code for Motorola PowerPC 620\n\
d1074 4
d1082 3
d1110 5
a1114 3
      if (strncmp (default_os, "aix", 3) == 0
	  && default_os[3] >= '4' && default_os[3] <= '9')
	ppc_cpu = PPC_OPCODE_COMMON;
d1116 1
a1116 1
	ppc_cpu = PPC_OPCODE_POWER;
d1118 8
a1125 4
	ppc_cpu = PPC_OPCODE_POWER;
      else if (strcmp (default_cpu, "powerpc") == 0
	       || strcmp (default_cpu, "powerpcle") == 0)
	ppc_cpu = PPC_OPCODE_PPC;
d1127 2
a1128 1
	as_fatal (_("Unknown default cpu = %s, os = %s"), default_cpu, default_os);
d1148 1
a1148 2
      else if (strcmp (default_cpu, "powerpc") == 0
	       || strcmp (default_cpu, "powerpcle") == 0)
d1159 6
a1164 7
  return (ppc_size == PPC_OPCODE_64) ? 620 : 0;
}

int
ppc_subseg_align()
{
  return (ppc_xcoff64) ? 3 : 2;
d1168 1
a1168 1
ppc_target_format()
d1172 1
a1172 1
  return (target_big_endian ? "pe-powerpc" : "pe-powerpcle");
d1174 1
d1176 5
a1180 4
  return (ppc_xcoff64 ? "aixcoff64-rs6000" : "aixcoff-rs6000");
#endif
#ifdef TE_POWERMAC
  return "xcoff-powermac";
d1184 3
a1186 1
  return (target_big_endian ? "elf32-powerpc" : "elf32-powerpcle");
d1201 1
a1201 1
  boolean dup_insn = false;
d1219 1
a1219 1
      if ((op->flags & ppc_cpu) != 0
d1221 14
a1234 2
	      || (op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64)) == ppc_size
	      || (ppc_cpu & PPC_OPCODE_64_BRIDGE) != 0))
d1241 1
a1241 1
	      /* Ignore Power duplicates for -m601 */
d1246 3
a1248 2
	      as_bad (_("Internal assembler error for instruction %s"), op->name);
	      dup_insn = true;
d1267 1
a1267 1
	      dup_insn = true;
d1275 2
a1276 1
  /* Tell the main code what the endianness is if it is not overidden by the user.  */
d1303 60
d1386 1
a1386 1
	  if (ppc_size == PPC_OPCODE_32)
d1419 1
a1419 4
	  if (file == (char *) NULL)
	    as_bad (err, buf, min, max);
	  else
	    as_bad_where (file, line, err, buf, min, max);
d1428 1
a1428 1
      insn = (*operand->insert) (insn, (long) val, &errmsg);
d1430 1
a1430 1
	as_bad (errmsg);
d1450 1
a1450 1
    bfd_reloc_code_real_type reloc;
d1458 1
a1458 1
  struct map_bfd *ptr;
d1462 89
a1550 45
  static struct map_bfd mapping[] = {
    MAP ("l",		BFD_RELOC_LO16),
    MAP ("h",		BFD_RELOC_HI16),
    MAP ("ha",		BFD_RELOC_HI16_S),
    MAP ("brtaken",	BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",	BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",		BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",	BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",	BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",	BFD_RELOC_HI16_S_GOTOFF),
    MAP ("fixup",	BFD_RELOC_CTOR),		/* warnings with -mrelocatable */
    MAP ("plt",		BFD_RELOC_24_PLT_PCREL),
    MAP ("pltrel24",	BFD_RELOC_24_PLT_PCREL),
    MAP ("copy",	BFD_RELOC_PPC_COPY),
    MAP ("globdat",	BFD_RELOC_PPC_GLOB_DAT),
    MAP ("local24pc",	BFD_RELOC_PPC_LOCAL24PC),
    MAP ("local",	BFD_RELOC_PPC_LOCAL24PC),
    MAP ("pltrel",	BFD_RELOC_32_PLT_PCREL),
    MAP ("plt@@l",	BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",	BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",	BFD_RELOC_HI16_S_PLTOFF),
    MAP ("sdarel",	BFD_RELOC_GPREL16),
    MAP ("sectoff",	BFD_RELOC_32_BASEREL),
    MAP ("sectoff@@l",	BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",	BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",	BFD_RELOC_HI16_S_BASEREL),
    MAP ("naddr",	BFD_RELOC_PPC_EMB_NADDR32),
    MAP ("naddr16",	BFD_RELOC_PPC_EMB_NADDR16),
    MAP ("naddr@@l",	BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP ("naddr@@h",	BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP ("naddr@@ha",	BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP ("sdai16",	BFD_RELOC_PPC_EMB_SDAI16),
    MAP ("sda2rel",	BFD_RELOC_PPC_EMB_SDA2REL),
    MAP ("sda2i16",	BFD_RELOC_PPC_EMB_SDA2I16),
    MAP ("sda21",	BFD_RELOC_PPC_EMB_SDA21),
    MAP ("mrkref",	BFD_RELOC_PPC_EMB_MRKREF),
    MAP ("relsect",	BFD_RELOC_PPC_EMB_RELSEC16),
    MAP ("relsect@@l",	BFD_RELOC_PPC_EMB_RELST_LO),
    MAP ("relsect@@h",	BFD_RELOC_PPC_EMB_RELST_HI),
    MAP ("relsect@@ha",	BFD_RELOC_PPC_EMB_RELST_HA),
    MAP ("bitfld",	BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP ("relsda",	BFD_RELOC_PPC_EMB_RELSDA),
    MAP ("xgot",	BFD_RELOC_PPC_TOC16),

    { (char *)0,	0,	BFD_RELOC_UNUSED }
d1558 1
a1558 1
	&& (isalnum (ch) || ch == '@@'));
d1561 1
a1561 1
      *str2++ = (islower (ch)) ? ch : tolower (ch);
d1573 16
a1588 6
	if (exp_p->X_add_number != 0
	    && (ptr->reloc == BFD_RELOC_16_GOTOFF
		|| ptr->reloc == BFD_RELOC_LO16_GOTOFF
		|| ptr->reloc == BFD_RELOC_HI16_GOTOFF
		|| ptr->reloc == BFD_RELOC_HI16_S_GOTOFF))
	  as_warn (_("identifier+constant@@got means identifier@@got+constant"));
d1590 1
a1590 1
	/* Now check for identifier@@suffix+constant */
d1607 1
d1609 10
a1618 2
	*str_p = str;
	return ptr->reloc;
d1624 2
a1625 3
/* Like normal .long/.short/.word, except support @@got, etc.  */
/* clobbers input_line_pointer, checks */
/* end-of-line.  */
d1628 1
a1628 1
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
d1644 2
a1645 1
	  && (reloc = ppc_elf_suffix (&input_line_pointer, &exp)) != BFD_RELOC_UNUSED)
d1647 5
a1651 2
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  int size = bfd_get_reloc_size (reloc_howto);
d1654 4
a1657 2
	    as_bad (_("%s relocations do not fit in %d bytes\n"), reloc_howto->name, nbytes);

d1660 2
a1661 2
	      register char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;
d1663 6
a1668 1
	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size, &exp, 0, reloc);
d1676 2
a1677 1
  input_line_pointer--;		/* Put terminator back into stream.  */
d1689 1
a1689 1
  /* Just pretend this is .section .rodata */
d1696 1
a1696 1
/* Pseudo op to make file scope bss items */
d1698 1
a1698 1
ppc_elf_lcomm(xxx)
d1715 1
a1715 1
  /* just after name is now '\0' */
d1771 1
a1771 1
  /* allocate_bss: */
d1776 1
a1776 1
      /* convert to a power of 2 alignment */
d1827 1
a1827 1
	  && fixp->fx_r_type != BFD_RELOC_32_BASEREL
d1831 1
a1835 1
	  && strcmp (segment_name (seg), ".stab") != 0
d1850 45
d1900 1
a1900 1
 * Summary of parse_toc_entry().
d1933 1
a1933 1
parse_toc_entry(toc_kind)
d1941 1
a1941 1
  /* save the input_line_pointer */
d1944 1
a1944 1
  /* skip over the '[' , and whitespace */
d1948 1
a1948 1
  /* find the spelling of the operand */
d1952 1
a1952 1
  if (strcmp(toc_spec, "toc") == 0)
d1956 1
a1956 1
  else if (strcmp(toc_spec, "tocv") == 0)
d1960 1
a1960 1
  else if (strcmp(toc_spec, "toc32") == 0)
d1964 1
a1964 1
  else if (strcmp(toc_spec, "toc64") == 0)
d1971 2
a1972 2
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d1976 2
a1977 2
  /* now find the ']' */
  *input_line_pointer = c;   /* put back the delimiting char */
d1985 1
a1985 1
      input_line_pointer = start; /* reset input_line pointer */
d1989 1
a1989 1
  *toc_kind = t;             /* set return value */
d1995 34
d2064 1
a2064 1
  for (s = str; *s != '\0' && ! isspace (*s); s++)
d2087 1
a2087 1
  while (isspace (*str))
d2108 2
d2126 6
d2135 1
a2135 1
	  if (opcount < strlen (opcode->operands))
a2160 1

d2167 1
a2167 1
	  insn = (*operand->insert) (insn, 0L, &errmsg);
d2180 1
a2180 1
	      insn = (*operand->insert) (insn, 0L, &errmsg);
d2197 23
a2219 23

	        lwz r4,[toc].GS.0.static_int(rtoc)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
	     The argument following the `]' must be a symbol name, and the
             register must be the toc register: 'rtoc' or '2'

	     The effect is to 0 as the displacement field
	     in the instruction, and issue an IMAGE_REL_PPC_TOCREL16 (or
	     the appropriate variation) reloc against it based on the symbol.
	     The linker will build the toc, and insert the resolved toc offset.

	     Note:
	     o The size of the toc entry is currently assumed to be
	       32 bits. This should not be assumed to be a hard coded
	       number.
	     o In an effort to cope with a change from 32 to 64 bits,
	       there are also toc entries that are specified to be
	       either 32 or 64 bits:
                 lwz r4,[toc32].GS.0.static_int(rtoc)
	         lwz r4,[toc64].GS.0.static_int(rtoc)
	       These demand toc entries of the specified size, and the
	       instruction probably requires it.
          */
d2225 2
a2226 2
	  /* go parse off the [tocXX] part */
	  valid_toc = parse_toc_entry(&toc_kind);
d2230 3
a2232 3
	      /* Note: message has already been issued.     */
	      /* FIXME: what sort of recovery should we do? */
	      /*        demand_rest_of_line(); return; ?    */
d2235 2
a2236 2
	  /* Now get the symbol following the ']' */
	  expression(&ex);
d2241 3
a2243 3
	      /* In this case, we may not have seen the symbol yet, since  */
	      /* it is allowed to appear on a .extern or .globl or just be */
	      /* a label in the .data section.                             */
d2247 8
a2254 7
	      /* 1. The symbol must be defined and either in the toc        */
	      /*    section, or a global.                                   */
	      /* 2. The reloc generated must have the TOCDEFN flag set in   */
	      /*    upper bit mess of the reloc type.                       */
	      /* FIXME: It's a little confusing what the tocv qualifier can */
	      /*        be used for. At the very least, I've seen three     */
	      /*        uses, only one of which I'm sure I can explain.     */
d2261 1
a2261 1
		      as_bad(_("[tocv] symbol is not a toc symbol"));
d2268 3
a2270 3
	      /* FIXME: these next two specifically specify 32/64 bit toc   */
	      /*        entries. We don't support them today. Is this the   */
	      /*        right way to say that?                              */
d2275 1
a2275 1
	      /* FIXME: see above */
d2281 2
a2282 2
		      _("Unexpected return value [%d] from parse_toc_entry!\n"),
		      toc_kind);
d2296 2
a2297 2
          /* Ok. We've set up the fixup for the instruction. Now make it
	     look like the constant 0 was found here */
d2311 1
a2311 1
		cr_operand = true;
d2313 1
a2313 1
	      cr_operand = false;
d2344 3
a2346 4
                   something which cleared it, we always produce a
                   signed value.  */
		if (ex.X_unsigned
		    && (operand->flags & PPC_OPERAND_SIGNED) == 0)
d2349 1
a2349 3
		  ex.X_add_number = (((ex.X_add_number & 0xffff)
				      ^ 0x8000)
				     - 0x8000);
d2353 4
a2356 1
		ex.X_add_number = (ex.X_add_number >> 16) & 0xffff;
d2360 32
a2391 3
		ex.X_add_number = ((((ex.X_add_number >> 16) & 0xffff)
				    + ((ex.X_add_number >> 15) & 1))
				   & 0xffff);
d2394 1
a2394 1
#endif
d2401 21
a2421 2
	  /* For the absoulte forms of branchs, convert the PC relative form back into
	     the absolute.  */
d2443 61
d2551 1
a2551 1
  while (isspace (*str))
d2557 25
d2595 1
a2595 1
     md_apply_fix.  */
d2603 1
a2603 1
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
d2608 1
d2618 5
a2622 2
	  fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset, size,
			      &fixups[i].exp, reloc_howto->pc_relative,
d2634 6
d2647 3
a2649 1
	fix_new_exp (frag_now, f - frag_now->fr_literal, 4,
d2653 1
a2653 1
		       (fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
d2738 1
a2738 1
/* For ELF, add support for SHF_EXCLUDE and SHT_ORDERED */
d2748 1
a2748 1
  *ptr_msg = _("Bad .section directive: want a,w,x,e in string");
d2834 1
a2834 1
static boolean ppc_stab_symbol;
d2838 2
a2839 1
   symbols, and uses a different smclas.  */
d2881 1
a2881 1
	align = 3;
d2889 1
a2889 1
	      align = 3;
d2898 1
a2898 5
      if (size <= 1)
	align = 0;
      else if (size <= 2)
	align = 1;
      else if (size <= 4)
d3083 2
a3084 2
         changing subsegments, so that we don't use a lot of memory
         space for what may be a small section.  */
d3099 1
a3099 1
      symbol_get_tc (sym)->align = (ppc_xcoff64) ? 3 : 2;
d3277 1
a3277 1
  ppc_stab_symbol = true;
d3279 1
a3279 1
  ppc_stab_symbol = false;
d3311 2
a3312 2
         fail at some later point, but this is probably the right
         thing to do here.  */
d3341 1
a3341 1
	  
d3345 1
a3345 1
      
d3349 1
a3349 1
       
d3351 1
a3351 1
       
d3355 3
a3357 3
       would be to have the tc	field updated in ppc_symbol_new_hook. */
    
    if (exp.X_op == O_symbol) 
d3475 4
a3478 1
   ".bf".  */
d3497 8
d3538 2
a3539 1
   the symbol list.  */
d3569 6
a3808 8
ppc_machine(dummy)
    int dummy ATTRIBUTE_UNUSED;
{
    discard_rest_of_line();
   /* What does aix use this for?  */
}

static void
d3836 1
d3843 1
a3843 1
   TC.  The rest of the arguments are 4 byte values to actually put at
d3845 3
a3847 1
   relocateable symbol reference.
d3910 3
a3912 1
#else /* ! defined (OBJ_XCOFF) */
d3922 5
a3926 5
  /* Align to a four byte boundary.  */
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

#endif /* ! defined (OBJ_XCOFF) */
d3933 1
a3933 1
      cons ((ppc_size == PPC_OPCODE_64) ? 8 : 4);
d3936 34
d3973 1
a3973 1
/* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format */
d3987 2
a3988 2
   warnings:  "No previous section"
*/
d3990 1
a3990 1
ppc_previous(ignore)
d3997 1
a3997 1
      as_warn(_("No previous section to return to. Directive ignored."));
d4001 1
a4001 1
  subseg_set(ppc_previous_section, 0);
d4003 1
a4003 1
  ppc_set_current_section(ppc_previous_section);
d4008 1
a4008 1
              double word aligned
d4012 1
a4012 1
              a - don't know -- maybe a misprint
d4019 1
a4019 1
   handling, debugging, etc.
a4020 1
*/
d4022 1
a4022 1
ppc_pdata(ignore)
d4037 1
a4037 1
      pdata_section = subseg_new(".pdata", 0);
d4039 1
a4039 1
  ppc_set_current_section(pdata_section);
d4044 1
a4044 1
              double word aligned
d4048 1
a4048 1
              a - don't know -- maybe a misprint
d4054 2
a4055 2
   debugging, etc.
*/
d4057 1
a4057 1
ppc_ydata(ignore)
d4064 2
a4065 2
			 (SEC_ALLOC | SEC_LOAD | SEC_RELOC
				       | SEC_READONLY | SEC_DATA ));
d4073 1
a4073 1
  ppc_set_current_section(ydata_section);
d4078 1
a4078 1
              double word aligned (4-byte)
d4091 2
a4092 2
   function descriptors, etc.
*/
d4094 1
a4094 1
ppc_reldata(ignore)
d4102 2
a4103 2
			     ( SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_DATA ));
d4111 1
a4111 1
  ppc_set_current_section(reldata_section);
d4116 1
a4116 1
              double word aligned
d4122 2
a4123 2
	      3 - double word aligned (that would be 4 byte boundary)
*/
d4125 1
a4125 1
ppc_rdata(ignore)
d4141 1
a4141 1
  ppc_set_current_section(rdata_section);
d4146 1
a4146 1
              performed.
d4149 2
a4150 2
   warnings:  None
*/
d4152 1
a4152 1
ppc_ualong(ignore)
d4155 2
a4156 2
  /* try for long */
  cons ( 4 );
d4161 1
a4161 1
              Issue a IMAGE_REL_PPC_IFGLUE relocation against it, using
d4164 2
a4165 2
   warnings:  Missing symbol name
*/
d4167 1
a4167 1
ppc_znop(ignore)
a4173 1

a4174 2

  /* Strip out the symbol name */
d4182 1
d4198 1
a4198 1
  /* stick in the nop */
d4217 2
a4218 2
   warnings:
*/
d4220 1
a4220 1
ppc_pe_comm(lcomm)
d4233 1
a4233 1
  /* just after name is now '\0' */
d4352 1
a4352 1
  /* Strip out the section name */
d4395 2
a4396 1
    align = 4; /* default alignment to 16 byte boundary */
d4484 2
a4485 2
		  as_bad(_("unknown section attribute '%c'"),
			 *input_line_pointer);
d4497 1
a4497 1
  ppc_set_current_section(sec);
d4507 1
a4507 1
  bfd_set_section_alignment(stdoutput, sec, align);
d4541 1
a4541 1
      /* FIXME: section flags won't work */
d4544 1
a4544 1
			      | SEC_READONLY | SEC_DATA ));
d4553 1
a4553 1
  ppc_set_current_section(tocdata_section);
d4600 1
a4600 2
	if (islower (*s))
	  *s = toupper (*s);
d4723 1
a4723 1
static boolean ppc_saw_abs;
d4746 4
d4786 1
a4786 1
	  resolve_symbol_value (symbol_get_tc (sym)->size, 1);
d4846 1
a4846 1
	      resolve_symbol_value (symbol_get_tc (sym)->next, 1);
d4865 2
a4866 2
             ppc_adjust_symtab.  */
	  ppc_saw_abs = true;
d4899 1
a4899 1
	      resolve_symbol_value (next, 1);
d4930 1
a4930 1
		  resolve_symbol_value (symbol_get_tc (csect)->next, 1);
d4962 4
a4965 4
      S_SET_VALUE (sym,
		   ((valueT)
		    coffsymbol (symbol_get_bfdsym
				(symbol_get_tc (sym)->within))->native));
d4976 1
a4976 1
      resolve_symbol_value (csect, 1);
d4983 2
a4984 2
         BFD will do that for us if we set the right flags.  We have
         already set the value correctly.  */
d5034 1
a5034 1
  ppc_saw_abs = false;
d5191 6
a5196 1
  valueT val;
a5197 2
  resolve_symbol_value (fix->fx_addsy, 1);
  val = S_GET_VALUE (fix->fx_addsy);
a5198 1
      && fix->fx_addsy != (symbolS *) NULL
d5200 1
a5200 1
      && S_GET_SEGMENT (fix->fx_addsy) == data_section
d5211 3
a5213 1
	  if (symbol_get_tc (sy)->class == XMC_TC0)
d5215 1
a5215 1
	  if (symbol_get_tc (sy)->class != XMC_TC)
d5217 1
a5217 2
	  resolve_symbol_value (sy, 1);
	  if (val == S_GET_VALUE (sy))
d5230 5
a5234 5
  if (fix->fx_addsy != (symbolS *) NULL
      && symbol_get_tc (fix->fx_addsy)->subseg == 0
      && symbol_get_tc (fix->fx_addsy)->class != XMC_TC0
      && symbol_get_tc (fix->fx_addsy)->class != XMC_TC
      && S_GET_SEGMENT (fix->fx_addsy) != bss_section
d5236 1
a5236 1
      && (S_GET_SEGMENT (fix->fx_addsy) != data_section
d5243 1
d5245 1
a5245 1
      if (S_GET_SEGMENT (fix->fx_addsy) == text_section)
d5247 1
a5247 1
      else if (S_GET_SEGMENT (fix->fx_addsy) == data_section)
d5257 2
a5258 3
	  while (symbol_get_tc (csect)->next != (symbolS *) NULL
		 && (symbol_get_frag (symbol_get_tc (csect)->next)->fr_address
		     <= val))
d5261 5
a5265 5
                 have to look through the full symbol table to see
                 whether this is the csect we want.  Note that we will
                 only get here if the csect has zero length.  */
	      if ((symbol_get_frag (csect)->fr_address == val)
		  && S_GET_VALUE (csect) == S_GET_VALUE (fix->fx_addsy))
d5280 1
a5280 1
                     symbol, then this is the csect we want.  */
d5285 1
a5285 1
	      csect = symbol_get_tc (csect)->next;
d5288 1
a5288 2
	  fix->fx_offset += (S_GET_VALUE (fix->fx_addsy)
			     - symbol_get_frag (csect)->fr_address);
d5291 1
d5296 1
a5296 2
  if (fix->fx_addsy != (symbolS *) NULL
      && S_GET_SEGMENT (fix->fx_addsy) == bss_section
d5299 4
a5302 5
      resolve_symbol_value (symbol_get_frag (fix->fx_addsy)->fr_symbol, 1);
      fix->fx_offset +=
	(S_GET_VALUE (fix->fx_addsy)
	 - S_GET_VALUE (symbol_get_frag (fix->fx_addsy)->fr_symbol));
      fix->fx_addsy = symbol_get_frag (fix->fx_addsy)->fr_symbol;
d5330 1
a5330 1
  return 0;
d5335 28
a5362 1
/* See whether a symbol is in the TOC section.  */
d5364 3
a5366 3
static int
ppc_is_toc_sym (sym)
     symbolS *sym;
d5368 15
a5382 4
#ifdef OBJ_XCOFF
  return symbol_get_tc (sym)->class == XMC_TC;
#else
  return strcmp (segment_name (S_GET_SEGMENT (sym)), ".got") == 0;
a5383 1
}
d5394 5
a5398 5
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
     segT seg;
d5400 1
a5400 1
  valueT value;
d5403 1
a5403 2
  value = *valuep;
  if (fixp->fx_addsy != NULL)
d5405 3
a5407 13
      /* `*valuep' may contain the value of the symbol on which the reloc
	 will be based; we have to remove it.  */
      if (symbol_used_in_reloc_p (fixp->fx_addsy)
	  && S_GET_SEGMENT (fixp->fx_addsy) != absolute_section
	  && S_GET_SEGMENT (fixp->fx_addsy) != undefined_section
	  && ! bfd_is_com_section (S_GET_SEGMENT (fixp->fx_addsy)))
	value -= S_GET_VALUE (fixp->fx_addsy);

      /* FIXME: Why '+'?  Better yet, what exactly is '*valuep'
	 supposed to be?  I think this is related to various similar
	 FIXMEs in tc-i386.c and tc-sparc.c.  */
      if (fixp->fx_pcrel)
	value += fixp->fx_frag->fr_address + fixp->fx_where;
d5410 1
a5410 3
    {
      fixp->fx_done = 1;
    }
d5412 1
a5412 1
  /* FIXME FIXME FIXME: The value we are passed in *valuep includes
d5417 1
a5417 1
     use *valuep since bfd_install_relocation is not being used.
d5419 2
a5420 2
     *valuep, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valuep since it includes the
d5422 6
a5427 7
  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    value = *valuep;
d5429 4
d5434 2
a5435 12
      value = fixp->fx_offset;
      if (fixp->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixp->fx_subsy);
	  else
	    {
	      /* We can't actually support subtracting a symbol.  */
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("expression too complex"));
	    }
	}
a5436 1
#endif
d5438 1
a5438 1
  if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
d5445 1
a5445 1
      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
d5450 4
a5453 7
      /* It appears that an instruction like
	     l 9,LC..1(30)
	 when LC..1 is not a TOC symbol does not generate a reloc.  It
	 uses the offset of LC..1 within its csect.  However, .long
	 LC..1 will generate a reloc.  I can't find any documentation
	 on how these cases are to be distinguished, so this is a wild
	 guess.  These cases are generated by gcc -mminimal-toc.  */
d5457 6
a5462 6
	  && operand->insert == NULL
	  && fixp->fx_addsy != NULL
	  && symbol_get_tc (fixp->fx_addsy)->subseg != 0
	  && symbol_get_tc (fixp->fx_addsy)->class != XMC_TC
	  && symbol_get_tc (fixp->fx_addsy)->class != XMC_TC0
	  && S_GET_SEGMENT (fixp->fx_addsy) != bss_section)
d5464 2
a5465 2
	  value = fixp->fx_offset;
	  fixp->fx_done = 1;
d5471 1
a5471 1
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
d5477 1
a5477 1
				 fixp->fx_file, fixp->fx_line);
d5483 5
a5487 5
      if (fixp->fx_done)
	{
	  /* Nothing else to do here.  */
	  return 1;
	}
d5491 1
a5491 4
	 relocs.
	 FIXME: We need to handle the DS field at the very least.
	 FIXME: Selecting the reloc type is a bit haphazard; perhaps
	 there should be a new field in the operand table.  */
d5495 1
a5495 1
	fixp->fx_r_type = BFD_RELOC_PPC_B26;
d5499 8
a5506 1
	fixp->fx_r_type = BFD_RELOC_PPC_B16;
d5510 1
a5510 1
	fixp->fx_r_type = BFD_RELOC_PPC_BA26;
d5514 9
a5522 1
	fixp->fx_r_type = BFD_RELOC_PPC_BA16;
d5525 1
a5525 3
	       && operand->shift == 0
	       && fixp->fx_addsy != NULL
	       && ppc_is_toc_sym (fixp->fx_addsy))
d5527 19
a5545 1
	  fixp->fx_size = 2;
d5547 1
a5547 2
	    fixp->fx_where += 2;
	  fixp->fx_r_type = BFD_RELOC_PPC_TOC16;
d5549 1
d5556 3
a5558 3
             symbol.  */
	  if (expr_symbol_where (fixp->fx_addsy, &sfile, &sline))
	    as_bad_where (fixp->fx_file, fixp->fx_line,
d5561 5
a5565 4
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  _("unsupported relocation type"));
	  fixp->fx_done = 1;
	  return 1;
d5571 1
a5571 1
      ppc_elf_validate_fix (fixp, seg);
d5573 1
a5573 1
      switch (fixp->fx_r_type)
d5575 5
d5581 3
a5583 4
	case BFD_RELOC_CTOR:
	  if (fixp->fx_pcrel)
	    fixp->fx_r_type = BFD_RELOC_32_PCREL;
					/* fall through */
a5586 1
	case BFD_RELOC_32_BASEREL:
d5588 1
a5588 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5593 5
a5597 3
	  if (fixp->fx_pcrel)
	    fixp->fx_r_type = BFD_RELOC_64_PCREL;
					/* fall through */
d5599 1
a5599 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5602 1
d5611 1
d5628 6
a5633 1
	  if (fixp->fx_pcrel)
d5635 2
a5636 2
	      if (fixp->fx_addsy != NULL)
		as_bad_where (fixp->fx_file, fixp->fx_line,
d5638 2
a5639 2
			      bfd_get_reloc_code_name (fixp->fx_r_type),
			      S_GET_NAME (fixp->fx_addsy));
d5641 1
a5641 1
		as_bad_where (fixp->fx_file, fixp->fx_line,
d5643 1
a5643 1
			      bfd_get_reloc_code_name (fixp->fx_r_type));
d5646 1
a5646 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5654 1
a5654 1
	  if (fixp->fx_pcrel)
d5656 2
a5657 2
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
			      value >> 16, 2);
d5659 1
d5661 16
a5676 1
	  if (fixp->fx_pcrel)
d5678 45
a5722 2
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
			      (value + 0x8000) >> 16, 2);
d5725 42
d5768 1
a5768 1
	     bytes, rather than 2, so offset it here appropriately */
d5770 1
a5770 1
	  if (fixp->fx_pcrel)
d5773 1
a5773 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where
d5779 1
a5779 1
	  if (fixp->fx_pcrel)
d5782 1
a5782 1
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d5788 1
a5788 1
	  if (!fixp->fx_pcrel && !fixp->fx_done)
d5791 4
a5794 4
	  if (fixp->fx_done)
	  {
	    char *where;
	    unsigned long insn;
d5796 21
a5816 21
	    /* Fetch the instruction, insert the fully resolved operand
	       value, and stuff the instruction back again.  */
	    where = fixp->fx_frag->fr_literal + fixp->fx_where;
	    if (target_big_endian)
	      insn = bfd_getb32 ((unsigned char *) where);
	    else
	      insn = bfd_getl32 ((unsigned char *) where);
	    if ((value & 3) != 0)
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("must branch to an address a multiple of 4"));
	    if ((offsetT) value < -0x40000000
		|| (offsetT) value >= 0x40000000)
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("@@local or @@plt branch destination is too far away, %ld bytes"),
			    value);
	    insn = insn | (value & 0x03fffffc);
	    if (target_big_endian)
	      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	    else
	      bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
	  }
d5820 5
a5824 5
	  fixp->fx_done = 0;
	  if (fixp->fx_addsy
	      && !S_IS_DEFINED (fixp->fx_addsy)
	      && !S_IS_WEAK (fixp->fx_addsy))
	    S_SET_WEAK (fixp->fx_addsy);
d5828 1
a5828 1
	  fixp->fx_done = 0;
d5831 7
d5840 2
a5841 2
		  _("Gas failure, reloc value %d\n"), fixp->fx_r_type);
	  fflush(stderr);
d5847 1
a5847 1
  fixp->fx_addnumber = value;
d5849 2
a5850 2
  if (fixp->fx_r_type != BFD_RELOC_PPC_TOC16)
    fixp->fx_addnumber = 0;
d5854 1
a5854 1
      fixp->fx_addnumber = 0;
d5858 2
a5859 2
      fixp->fx_addnumber =
	- bfd_get_section_vma (stdoutput, S_GET_SEGMENT (fixp->fx_addsy));
a5862 2

  return 1;
d5883 2
a5884 1
		    _("reloc %d not supported by object file format"), (int)fixp->fx_r_type);
@


1.8
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000 
d21 1
a21 1
   02111-1307, USA. */
d32 1
d90 1
d187 1
d191 1
d201 2
a244 1

d249 4
d272 1
a272 1
   The table is sorted. Suitable for searching by a binary search. */
d301 23
a323 23
  { "f.1", 1 }, 
  { "f.10", 10 }, 
  { "f.11", 11 }, 
  { "f.12", 12 }, 
  { "f.13", 13 }, 
  { "f.14", 14 }, 
  { "f.15", 15 }, 
  { "f.16", 16 }, 
  { "f.17", 17 }, 
  { "f.18", 18 }, 
  { "f.19", 19 }, 
  { "f.2", 2 }, 
  { "f.20", 20 }, 
  { "f.21", 21 }, 
  { "f.22", 22 }, 
  { "f.23", 23 }, 
  { "f.24", 24 }, 
  { "f.25", 25 }, 
  { "f.26", 26 }, 
  { "f.27", 27 }, 
  { "f.28", 28 }, 
  { "f.29", 29 }, 
  { "f.3", 3 }, 
d326 31
a356 31
  { "f.4", 4 }, 
  { "f.5", 5 }, 
  { "f.6", 6 }, 
  { "f.7", 7 }, 
  { "f.8", 8 }, 
  { "f.9", 9 }, 

  { "f0", 0 }, 
  { "f1", 1 }, 
  { "f10", 10 }, 
  { "f11", 11 }, 
  { "f12", 12 }, 
  { "f13", 13 }, 
  { "f14", 14 }, 
  { "f15", 15 }, 
  { "f16", 16 }, 
  { "f17", 17 }, 
  { "f18", 18 }, 
  { "f19", 19 }, 
  { "f2", 2 }, 
  { "f20", 20 }, 
  { "f21", 21 }, 
  { "f22", 22 }, 
  { "f23", 23 }, 
  { "f24", 24 }, 
  { "f25", 25 }, 
  { "f26", 26 }, 
  { "f27", 27 }, 
  { "f28", 28 }, 
  { "f29", 29 }, 
  { "f3", 3 }, 
d359 6
a364 6
  { "f4", 4 }, 
  { "f5", 5 }, 
  { "f6", 6 }, 
  { "f7", 7 }, 
  { "f8", 8 }, 
  { "f9", 9 }, 
d451 66
d521 1
a521 1
#define REG_NAME_CNT	(sizeof(pre_defined_registers) / sizeof(struct pd_reg))
d590 1
a590 1
  if (reg_number >= 0) 
d594 1
a594 1
      
d669 3
d680 1
a680 1
static enum { SHLIB_NONE, SHLIB_PIC, SHILB_MRELOCATABLE } shlib = SHLIB_NONE;
d751 1
a751 1
/* The current section and the previous section. See ppc_previous. */
d769 1
a769 1
size_t md_longopts_size = sizeof(md_longopts);
d821 10
d840 1
a840 1
         instructions that are holdovers from the Power. */
d848 1
d852 2
d885 1
a885 1
	  shlib = SHILB_MRELOCATABLE;
d891 1
a891 1
	  shlib = SHILB_MRELOCATABLE;
d963 1
a963 1
  fprintf(stream, _("\
d969 1
a969 1
-mppc, -mppc32, -m403, -m603, -m604\n\
d978 1
a978 1
  fprintf(stream, _("\
d1042 31
d1089 1
a1089 1
  /* Set the ELF flags if desired. */
d1167 1
a1167 1
  ppc_previous_section = 0;  
d1272 1
a1272 1
#define MAP(str,reloc) { str, sizeof(str)-1, reloc }
d1373 1
a1373 1
/* Like normal .long/.short/.word, except support @@got, etc. */
d1375 1
a1375 1
/* end-of-line. */
d1415 1
a1415 1
  input_line_pointer--;		/* Put terminator back into stream. */
d1559 1
a1559 1
    case SHILB_MRELOCATABLE:
d1601 1
a1601 1
 * out:	
d1617 2
a1618 2
enum toc_size_qualifier 
{ 
d1640 1
a1640 1
  
d1645 1
a1645 1
  if (strcmp(toc_spec, "toc") == 0) 
d1649 1
a1649 1
  else if (strcmp(toc_spec, "tocv") == 0) 
d1653 1
a1653 1
  else if (strcmp(toc_spec, "toc32") == 0) 
d1657 1
a1657 1
  else if (strcmp(toc_spec, "toc64") == 0) 
d1672 2
a1673 2
  SKIP_WHITESPACE ();	     /* leading whitespace could be there. */
  c = *input_line_pointer++; /* input_line_pointer->past char in c. */
d1846 1
a1846 1
      if (*input_line_pointer == '[') 
d1852 1
a1852 1
	     The argument following the `]' must be a symbol name, and the 
d1880 1
a1880 1
	  if (!valid_toc) 
d1906 2
a1907 2
	      if (ex.X_op == O_symbol) 
		{		  
d1931 1
a1931 1
	      fprintf(stderr, 
d1934 1
a1934 1
	      abort();
d1983 1
a1983 1
	  /* Allow @@HA, @@L, @@H on constants. */
d2103 4
d2132 1
a2132 1
	    abort();
d2193 1
a2193 1
    }  
d2240 1
a2240 1
}  
d2425 1
a2425 1
      
d2442 1
a2442 1
    
d2444 1
a2444 1
	  
d2466 1
a2466 1
  
d2506 1
a2506 1
     int ignore;
d2514 1
a2514 1
  
d2607 1
a2607 1
      symbol_get_tc (sym)->align = 2;
d2610 1
a2610 1
	  
d2616 1
a2616 1
	  
d2656 1
a2656 1
     int ignore;
d2691 1
a2691 1
     int ignore;
d2710 1
a2710 1
     int ignore;
d2733 1
a2733 1
     int ignore;
d2769 1
a2769 1
     int ignore;
d2848 2
a2849 1
  if (S_GET_STORAGE_CLASS (sym) == C_STSYM)
d2852 19
d2896 1
a2896 1
     int ignore;
d2987 1
a2987 1
     int ignore;
d3015 1
a3015 1
     int ignore;
d3064 1
a3064 1
  
d3088 1
a3088 1
     int ignore;
d3124 1
a3124 1
     int ignore;
d3149 1
a3149 1
     int ignore;
d3176 1
a3176 1
     int ignore;
d3201 1
a3201 1
     int ignore;
d3224 1
a3224 1
     int ignore;
d3244 1
a3244 1
     int ignore;
d3253 1
a3253 1
    
d3269 1
a3269 1
	  
d3299 8
d3308 1
a3308 1
     int dummy;
d3426 1
a3426 1
      cons (4);
d3450 1
a3450 1
     int ignore;
d3454 1
a3454 1
  if (ppc_previous_section == NULL) 
d3483 1
a3483 1
     int ignore;
d3485 1
a3485 1
  if (pdata_section == 0) 
d3488 1
a3488 1
      
d3492 1
a3492 1
      
d3518 1
a3518 1
     int ignore;
d3520 1
a3520 1
  if (ydata_section == 0) 
d3555 1
a3555 1
     int ignore;
d3562 1
a3562 1
			     ( SEC_ALLOC | SEC_LOAD | SEC_RELOC 
d3586 1
a3586 1
     int ignore;
d3605 1
a3605 1
   behaviour: much like .int, with the exception that no alignment is 
d3613 1
a3613 1
     int ignore;
d3628 1
a3628 1
     int ignore;
d3676 4
a3679 4
/* pseudo-op: 
   behaviour: 
   errors:    
   warnings:  
d3779 1
a3779 1
 * FIXME: I just noticed this. This doesn't work at all really. It it 
d3812 1
a3812 1
     int ignore;
d3878 1
a3878 1
		  flags |= SEC_CODE; 
d3894 1
a3894 1
		  flags &=~ SEC_LOAD; 
d3974 1
a3974 1
     int ignore;
d3997 1
a3997 1
     int ignore;
d4402 1
a4402 1
	
d4511 2
a4512 2
   of type type, and store the appropriate bytes in *litp.  The number
   of LITTLENUMS emitted is stored in *sizep .  An error message is
d4563 1
a4563 1
     
a4617 1
/*ARGSUSED*/
a4957 1
	       && operand->insert == NULL
d5004 8
d5097 1
a5097 1
	    
d5134 1
a5134 1
	  fprintf(stderr,
@


1.7
log
@don't localise .lcomm if it's defined .globl
@
text
@d2 2
a3 1
   Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
d57 1
d84 1
d88 2
d93 1
a93 1
static bfd_reloc_code_real_type ppc_elf_suffix PARAMS ((char **));
d118 8
a125 1
/* Characters which always start a comment.  */
d127 4
a130 1
const char comment_chars[] = "#!";
d180 1
d184 4
d592 1
a592 1
static int ppc_size = PPC_OPCODE_32;
d601 2
a602 3
/* Whether to warn about non PC relative relocations that aren't
   in the .got2 section. */
static boolean mrelocatable = false;
d606 9
a681 5

#ifndef WORKING_DOT_WORD
const int md_short_jump_size = 4;
const int md_long_jump_size = 4;
#endif
d732 1
a732 1
      if (strcmp (arg, "PIC") == 0)
d734 1
a734 1
	  mrelocatable = true;
d770 5
d794 1
a794 1
	  mrelocatable = true;
d800 1
a800 1
	  mrelocatable = true;
d820 12
d835 1
a835 1
	  as_bad ("invalid switch -m%s", arg);
d872 1
a872 1
  fprintf(stream, "\
d881 1
d885 1
a885 1
-mno-regnames		Do not allow symbolic names for registers\n");
d887 1
a887 1
  fprintf(stream, "\
d894 2
d897 1
a897 1
-Qy, -Qn		ignored\n");
d922 1
a922 1
	as_fatal ("Unknown default cpu = %s, os = %s", default_cpu, default_os);
d947 1
a947 1
  as_fatal ("Neither Power nor PowerPC opcodes were selected.");
d968 1
a968 1
  if (ppc_flags)
d982 2
a983 1
	      || (op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64)) == ppc_size))
d995 1
a995 1
	      as_bad ("Internal assembler error for instruction %s", op->name);
d1014 1
a1014 1
	      as_bad ("Internal assembler error for macro %s", macro->name);
d1037 1
a1037 1
  ppc_text_csects->sy_tc.within = ppc_text_csects;
d1039 1
a1039 1
  ppc_data_csects->sy_tc.within = ppc_data_csects;
d1067 1
a1067 2
	  if ((operand->flags & PPC_OPERAND_SIGNOPT) != 0
	      && ppc_size == PPC_OPCODE_32)
d1072 15
d1102 1
a1102 1
	    "operand out of range (%s not between %ld and %ld)";
d1133 1
a1133 1
ppc_elf_suffix (str_p)
d1135 1
d1163 1
d1168 1
a1168 1
    MAP ("plt",		BFD_RELOC_32_PLTOFF),
d1215 3
a1217 1
    if (ch == ptr->string[0] && len == ptr->length && memcmp (ident, ptr->string, ptr->length) == 0)
d1219 25
d1272 1
a1272 1
	  && (reloc = ppc_elf_suffix (&input_line_pointer)) != BFD_RELOC_UNUSED)
d1278 1
a1278 1
	    as_bad ("%s relocations do not fit in %d bytes\n", reloc_howto->name, nbytes);
d1315 1
a1315 1
     int xxx;
d1337 1
a1337 1
      as_bad ("Expected comma after symbol-name: rest of line ignored.");
d1345 1
a1345 1
      as_warn (".COMMon length (%ld.) <0! Ignored.", (long) size);
d1352 1
a1352 1
    align = 3;
d1359 2
a1360 2
	  as_warn ("ignoring bad alignment");
	  align = 3;
d1368 1
a1368 1
  if (S_IS_DEFINED (symbolP))
d1370 1
a1370 1
      as_bad ("Ignoring attempt to re-define symbol `%s'.",
d1378 1
a1378 1
      as_bad ("Length of .lcomm \"%s\" is already %ld. Not changed to %ld.",
d1396 1
a1396 1
	  as_bad ("Common alignment not a power of 2");
d1407 1
a1407 1
    frag_align (align2, 0);
d1409 2
a1410 2
    symbolP->sy_frag->fr_symbol = 0;
  symbolP->sy_frag = frag_now;
d1428 4
a1431 19
  if (mrelocatable
      && !fixp->fx_done
      && !fixp->fx_pcrel
      && fixp->fx_r_type <= BFD_RELOC_UNUSED
      && fixp->fx_r_type != BFD_RELOC_16_GOTOFF
      && fixp->fx_r_type != BFD_RELOC_HI16_GOTOFF
      && fixp->fx_r_type != BFD_RELOC_LO16_GOTOFF
      && fixp->fx_r_type != BFD_RELOC_HI16_S_GOTOFF
      && fixp->fx_r_type != BFD_RELOC_32_BASEREL
      && fixp->fx_r_type != BFD_RELOC_LO16_BASEREL
      && fixp->fx_r_type != BFD_RELOC_HI16_BASEREL
      && fixp->fx_r_type != BFD_RELOC_HI16_S_BASEREL
      && strcmp (segment_name (seg), ".got2") != 0
      && strcmp (segment_name (seg), ".dtors") != 0
      && strcmp (segment_name (seg), ".ctors") != 0
      && strcmp (segment_name (seg), ".fixup") != 0
      && strcmp (segment_name (seg), ".stab") != 0
      && strcmp (segment_name (seg), ".gcc_except_table") != 0
      && strcmp (segment_name (seg), ".ex_shared") != 0)
d1433 22
a1454 2
      if ((seg->flags & (SEC_READONLY | SEC_CODE)) != 0
	  || fixp->fx_r_type != BFD_RELOC_CTOR)
d1456 6
a1461 2
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Relocation cannot be done when using -mrelocatable");
d1463 1
d1541 1
a1541 1
      as_bad ("syntax error: invalid toc specifier `%s'", toc_spec);
d1555 1
a1555 1
      as_bad ("syntax error: expected `]', found  `%c'", c);
d1614 1
a1614 1
	as_bad ("Unrecognized opcode: `%s'", str);
d1787 2
a1788 1
		  if (ex.X_add_symbol->bsym->section != tocdata_section)
d1790 1
a1790 1
		      as_bad("[tocv] symbol is not a toc symbol");
d1801 1
a1801 1
	      as_bad ("Unimplemented toc32 expression modifier");
d1806 1
a1806 1
	      as_bad ("Unimplemented toc64 expression modifier");
d1810 1
a1810 1
		      "Unexpected return value [%d] from parse_toc_entry!\n",
d1818 1
a1818 1
	    as_fatal ("too many fixups");
d1850 1
a1850 1
	as_bad ("illegal operand");
d1852 1
a1852 1
	as_bad ("missing operand");
d1864 1
a1864 1
	  if ((reloc = ppc_elf_suffix (&str)) != BFD_RELOC_UNUSED)
d1872 7
a1878 1
		if (operand->flags & PPC_OPERAND_SIGNED) {
a1881 3
		} else {
		  ex.X_add_number &= 0xffff;
		}
d1889 3
a1891 2
		ex.X_add_number = (((ex.X_add_number >> 16) & 0xffff)
				   + ((ex.X_add_number >> 15) & 1));
d1899 1
a1899 1
      else if ((reloc = ppc_elf_suffix (&str)) != BFD_RELOC_UNUSED)
d1926 1
a1926 1
	    as_fatal ("too many fixups");
d1938 1
a1938 1
	    as_fatal ("too many fixups");
d1963 1
a1963 1
	  as_bad ("syntax error; found `%c' but expected `%c'", *str, endc);
d1975 1
a1975 1
    as_bad ("junk at end of line: `%s'", str);
a2035 23
#ifndef WORKING_DOT_WORD
/* Handle long and short jumps */
void
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  abort ();
}

void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  abort ();
}
#endif

d2071 1
a2071 1
      as_bad ("wrong number of operands");
d2127 1
a2127 1
  *ptr_msg = "Bad .section directive: want a,w,x,e in string";
d2132 3
a2134 2
ppc_section_word (ptr_str)
     char **ptr_str;
d2136 2
a2137 5
  if (strncmp (*ptr_str, "exclude", sizeof ("exclude")-1) == 0)
    {
      *ptr_str += sizeof ("exclude")-1;
      return SHF_EXCLUDE;
    }
d2139 1
a2139 1
  return 0;
d2143 3
a2145 2
ppc_section_type (ptr_str)
     char **ptr_str;
d2147 2
a2148 5
  if (strncmp (*ptr_str, "ordered", sizeof ("ordered")-1) == 0)
    {
      *ptr_str += sizeof ("ordered")-1;
      return SHT_ORDERED;
    }
d2150 1
a2150 1
  return 0;
d2177 1
a2177 1
     int ignore;
d2241 1
a2241 1
      as_bad ("missing size");
d2250 1
a2250 1
      as_bad ("negative size");
d2266 1
a2266 1
	      as_warn ("ignoring bad alignment");
d2291 1
a2291 1
	  as_bad ("missing real symbol name");
d2312 1
a2312 1
      as_bad ("attempt to redefine symbol");
d2333 1
a2333 1
	  lcomm_sym->sy_tc.output = 1;
d2339 1
a2339 1
      frag_align (align, 0);
d2341 1
a2341 1
      def_sym->sy_frag = frag_now;
d2346 1
a2346 1
      def_sym->sy_tc.align = align;
d2351 2
a2352 2
      lcomm_sym->sy_frag->fr_offset =
	((lcomm_sym->sy_frag->fr_offset + (1 << align) - 1)
d2354 2
a2355 2
      if (align > lcomm_sym->sy_tc.align)
	lcomm_sym->sy_tc.align = align;
d2362 3
a2364 3
      sym->sy_frag = lcomm_sym->sy_frag;
      S_SET_VALUE (sym, lcomm_sym->sy_frag->fr_offset);
      lcomm_sym->sy_frag->fr_offset += size;
d2396 1
a2396 1
      sym->sy_tc.class = XMC_PR;
d2404 1
a2404 1
      sym->sy_tc.align = get_absolute_expression ();
d2417 1
a2417 1
    subseg_set (S_GET_SEGMENT (sym), sym->sy_tc.subseg);
d2422 1
d2429 1
a2429 1
      switch (sym->sy_tc.class)
d2440 1
a2440 1
	  sym->sy_tc.subseg = ppc_text_subsegment;
d2452 2
a2453 1
	      && ppc_toc_csect->sy_tc.subseg + 1 == ppc_data_subsegment)
d2456 1
a2456 1
	  sym->sy_tc.subseg = ppc_data_subsegment;
d2464 11
a2474 1
      subseg_new (segment_name (S_GET_SEGMENT (sym)), sym->sy_tc.subseg);
d2478 1
a2478 1
      sym->sy_frag = frag_now;
d2481 3
a2483 3
      sym->sy_tc.align = 2;
      sym->sy_tc.output = 1;
      sym->sy_tc.within = sym;
d2486 2
a2487 2
	   list->sy_tc.next != (symbolS *) NULL;
	   list = list->sy_tc.next)
d2489 1
a2489 1
      list->sy_tc.next = sym;
d2492 2
a2493 1
      symbol_append (sym, list->sy_tc.within, &symbol_rootP, &symbol_lastP);
d2524 37
d2597 1
a2597 1
  sym->sy_tc.output = 1;
d2623 1
a2623 1
      as_bad ("missing rename string");
d2629 1
a2629 1
  sym->sy_tc.real_name = demand_copy_C_string (&len);
d2654 1
a2654 1
      as_bad ("missing value");
d2663 1
a2663 1
  sym->sy_tc.real_name = name;
d2672 1
a2672 1
      as_bad ("illegal .stabx expression; zero assumed");
d2677 1
a2677 1
      sym->sy_frag = &zero_address_frag;
d2682 1
a2682 1
	sym->sy_value = exp;
d2687 1
a2687 1
	  sym->sy_frag = exp.X_add_symbol->sy_frag;
d2695 1
a2695 1
      sym->sy_value = exp;
d2700 1
a2700 1
  sym->bsym->flags |= BSF_DEBUGGING;
d2704 1
a2704 1
      as_bad ("missing class");
d2713 1
a2713 1
      as_bad ("missing type");
d2720 1
a2720 1
  sym->sy_tc.output = 1;
d2723 1
a2723 1
    sym->sy_tc.within = ppc_current_block;
d2733 2
a2734 2
      if (ppc_current_csect->sy_tc.within == exp.X_add_symbol)
	ppc_current_csect->sy_tc.within = sym;
d2774 1
a2774 1
      as_bad ("missing symbol name");
d2789 8
a2796 4
      ext_sym->sy_value.X_op = O_symbol;
      ext_sym->sy_value.X_add_symbol = lab_sym;
      ext_sym->sy_value.X_op_symbol = NULL;
      ext_sym->sy_value.X_add_number = 0;
d2799 3
a2801 3
  if (ext_sym->sy_tc.class == -1)
    ext_sym->sy_tc.class = XMC_PR;
  ext_sym->sy_tc.output = 1;
d2819 5
a2823 5
	      ext_sym->sy_tc.size = symbol_new ("L0\001",
						absolute_section,
						(valueT) 0,
						&zero_address_frag);
	      pseudo_set (ext_sym->sy_tc.size);
d2847 1
a2847 1
  sym->sy_frag = frag_now;
d2856 1
a2856 1
  sym->sy_tc.output = 1;
d2875 1
a2875 1
  sym->sy_frag = frag_now;
d2880 1
a2880 1
  sym->sy_tc.output = 1;
d2895 2
d2914 1
a2914 1
  sym->bsym->flags |= BSF_DEBUGGING;
d2917 1
a2917 1
  sym->sy_tc.output = 1;
d2919 1
a2919 1
  for (look = symbol_rootP;
d2930 1
d2950 1
a2950 1
    as_bad ("nested .bs blocks");
d2962 2
a2963 2
  sym->bsym->flags |= BSF_DEBUGGING;
  sym->sy_tc.output = 1;
d2965 1
a2965 1
  sym->sy_tc.within = csect;
d2983 1
a2983 1
    as_bad (".es without preceding .bs");
d2988 2
a2989 2
  sym->bsym->flags |= BSF_DEBUGGING;
  sym->sy_tc.output = 1;
d3009 1
a3009 1
  sym->sy_frag = frag_now;
d3016 1
a3016 1
  sym->sy_tc.output = 1;
d3036 1
a3036 1
  sym->sy_frag = frag_now;
d3041 1
a3041 1
  sym->sy_tc.output = 1;
d3064 1
a3064 1
  sym->bsym->flags |= BSF_DEBUGGING;
d3067 1
a3067 1
  sym->sy_tc.output = 1;
d3084 1
a3084 1
  sym->bsym->flags |= BSF_DEBUGGING;
d3087 1
a3087 1
  sym->sy_tc.output = 1;
d3101 1
a3101 1
    subseg_set (data_section, ppc_toc_csect->sy_tc.subseg);
d3115 1
a3115 1
      sym->sy_frag = frag_now;
d3118 3
a3120 3
      sym->sy_tc.subseg = subseg;
      sym->sy_tc.output = 1;
      sym->sy_tc.within = sym;
d3125 2
a3126 2
	   list->sy_tc.next != (symbolS *) NULL;
	   list = list->sy_tc.next)
d3128 1
a3128 1
      list->sy_tc.next = sym;
d3131 2
a3132 1
      symbol_append (sym, list->sy_tc.within, &symbol_rootP, &symbol_lastP);
d3140 39
d3195 1
a3195 1
     int ignore;
d3208 1
a3208 1
	as_bad (".tc not in .toc section");
d3224 2
a3225 2
	label = ppc_current_csect->sy_tc.within;
	if (label->sy_tc.class != XMC_TC0)
d3227 1
a3227 1
	    as_bad (".tc with no label");
d3233 1
a3233 1
	label->sy_frag = sym->sy_frag;
d3243 1
a3243 1
    sym->sy_frag = frag_now;
d3245 2
a3246 2
    sym->sy_tc.class = XMC_TC;
    sym->sy_tc.output = 1;
d3262 1
a3262 1
  frag_align (2, 0);
d3302 1
a3302 1
      as_warn("No previous section to return to. Directive ignored.");
d3547 1
a3547 1
      as_bad ("Expected comma after symbol-name: rest of line ignored.");
d3555 1
a3555 1
      as_warn (".COMMon length (%ld.) <0! Ignored.", (long) temp);
d3571 1
a3571 1
	      as_warn ("ignoring bad alignment");
d3581 1
a3581 1
  if (S_IS_DEFINED (symbolP))
d3583 1
a3583 1
      as_bad ("Ignoring attempt to re-define symbol `%s'.",
d3592 1
a3592 1
	as_bad ("Length of .comm \"%s\" is already %ld. Not changed to %ld.",
d3721 1
a3721 1
		  as_bad ("Unsupported section attribute -- 'a'");
d3791 1
a3791 1
		  as_bad("unknown section attribute '%c'",
d3809 1
a3809 1
	as_bad ("error setting flags for \"%s\": %s",
d3911 1
a3911 1
	as_bad ("bad symbol suffix");
d3926 1
d3929 9
a3937 8
  sym->sy_tc.next = NULL;
  sym->sy_tc.output = 0;
  sym->sy_tc.class = -1;
  sym->sy_tc.real_name = NULL;
  sym->sy_tc.subseg = 0;
  sym->sy_tc.align = 0;
  sym->sy_tc.size = NULL;
  sym->sy_tc.within = NULL;
d3955 1
a3955 1
	sym->sy_tc.class = XMC_BS;
d3959 1
a3959 1
	sym->sy_tc.class = XMC_DB;
d3961 1
a3961 1
	sym->sy_tc.class = XMC_DS;
d3965 1
a3965 1
	sym->sy_tc.class = XMC_GL;
d3969 1
a3969 1
	sym->sy_tc.class = XMC_PR;
d3973 1
a3973 1
	sym->sy_tc.class = XMC_RO;
d3975 1
a3975 1
	sym->sy_tc.class = XMC_RW;
d3979 1
a3979 1
	sym->sy_tc.class = XMC_SV;
d3983 1
a3983 1
	sym->sy_tc.class = XMC_TC;
d3985 1
a3985 1
	sym->sy_tc.class = XMC_TI;
d3987 1
a3987 1
	sym->sy_tc.class = XMC_TB;
d3989 1
a3989 1
	sym->sy_tc.class = XMC_TC0;
d3993 1
a3993 1
	sym->sy_tc.class = XMC_UA;
d3995 1
a3995 1
	sym->sy_tc.class = XMC_UC;
d3999 1
a3999 1
	sym->sy_tc.class = XMC_XO;
d4003 2
a4004 2
  if (sym->sy_tc.class == -1)
    as_bad ("Unrecognized symbol suffix");
d4017 2
a4018 2
      if (sym->sy_tc.class == -1)
	sym->sy_tc.class = ppc_current_csect->sy_tc.class;
d4021 3
a4023 3
      symbol_append (sym, ppc_current_csect->sy_tc.within, &symbol_rootP,
		     &symbol_lastP);
      ppc_current_csect->sy_tc.within = sym;
d4047 2
a4048 2
  if (! sym->sy_used_in_reloc
      && ((sym->bsym->flags & BSF_SECTION_SYM) != 0
d4050 1
a4050 1
	      && ! sym->sy_tc.output
d4054 2
a4055 2
  if (sym->sy_tc.real_name != (char *) NULL)
    S_SET_NAME (sym, sym->sy_tc.real_name);
d4086 1
a4086 1
	as_bad ("two .function pseudo-ops with no intervening .ef");
d4088 1
a4088 1
      if (sym->sy_tc.size != (symbolS *) NULL)
d4090 3
a4092 2
	  resolve_symbol_value (sym->sy_tc.size);
	  SA_SET_SYM_FSIZE (sym, (long) S_GET_VALUE (sym->sy_tc.size));
d4099 1
a4099 1
	as_bad (".ef with no preceding .function");
d4112 1
a4112 1
      && (sym->bsym->flags & BSF_SECTION_SYM) == 0
d4132 2
a4133 2
      a = &coffsymbol (sym->bsym)->native[i + 1].u.auxent;
      if (sym->sy_tc.class == XMC_TC0)
d4140 1
a4140 1
      else if (sym->sy_tc.subseg != 0)
d4144 1
a4144 1
	  if (sym->sy_tc.next == (symbolS *) NULL)
d4150 2
a4151 2
	      resolve_symbol_value (sym->sy_tc.next);
	      a->x_csect.x_scnlen.l = (S_GET_VALUE (sym->sy_tc.next)
d4154 1
a4154 1
	  a->x_csect.x_smtyp = (sym->sy_tc.align << 3) | XTY_SD;
d4159 2
a4160 2
	  a->x_csect.x_scnlen.l = sym->sy_frag->fr_offset;
	  a->x_csect.x_smtyp = (sym->sy_tc.align << 3) | XTY_CM;
d4162 1
a4162 1
	    sym->sy_tc.class = XMC_RW;
d4164 1
a4164 1
	    sym->sy_tc.class = XMC_BS;
d4172 2
a4173 2
	  if (sym->sy_tc.class == -1)
	    sym->sy_tc.class = XMC_XO;
d4181 1
a4181 1
      else if (sym->sy_tc.class == XMC_TC)
d4188 1
a4188 1
	  while (next->sy_tc.class == XMC_TC0)
d4191 1
a4191 1
	      || next->sy_tc.class != XMC_TC)
d4203 1
a4203 1
	      resolve_symbol_value (next);
d4223 1
a4223 1
	  csect = csect->sy_tc.next;
d4227 1
a4227 1
	      as_warn ("warning: symbol %s has no csect", S_GET_NAME (sym));
d4232 1
a4232 1
	      while (csect->sy_tc.next != (symbolS *) NULL)
d4234 3
a4236 2
		  resolve_symbol_value (csect->sy_tc.next);
		  if (S_GET_VALUE (csect->sy_tc.next) > S_GET_VALUE (sym))
d4238 1
a4238 1
		  csect = csect->sy_tc.next;
d4241 4
a4244 2
	      a->x_csect.x_scnlen.p = coffsymbol (csect->bsym)->native;
	      coffsymbol (sym->bsym)->native[i + 1].fix_scnlen = 1;
d4251 1
a4251 1
      if (sym->sy_tc.class == -1)
d4254 1
a4254 1
	a->x_csect.x_smclas = sym->sy_tc.class;
d4259 1
a4259 1
      sym->bsym->flags |= BSF_NOT_AT_END;
d4267 4
a4270 2
		   (valueT) coffsymbol (sym->sy_tc.within->bsym)->native);
      coffsymbol (sym->bsym)->native->fix_value = 1;
d4278 3
a4280 3
      block = sym->sy_tc.within;
      csect = block->sy_tc.within;
      resolve_symbol_value (csect);
d4289 1
a4289 1
      coffsymbol (sym->bsym)->native->fix_line = 1;
d4317 1
a4317 1
      csect->bsym->value = S_GET_VALUE (sym);
d4321 1
a4321 1
      a = &coffsymbol (csect->bsym)->native[i + 1].u.auxent;
d4333 3
a4335 3
      a = &coffsymbol (sym->bsym)->native[i].u.auxent;
      a->x_csect.x_scnlen.p = coffsymbol (csect->bsym)->native;
      coffsymbol (sym->bsym)->native[i].fix_scnlen = 1;
d4384 1
a4384 1
      return "bad call to md_atof";
d4444 2
a4445 2
     fragS *fragp;
     asection *seg;
d4455 3
a4457 3
     bfd *abfd;
     asection *sec;
     fragS *fragp;
d4467 1
a4467 1
     char *name;
d4480 1
a4480 1
     segT sec;
a4481 7
#ifdef OBJ_ELF
  if (fixp->fx_addsy != (symbolS *) NULL
      && (! S_IS_DEFINED (fixp->fx_addsy)
	  || TC_FORCE_RELOCATION_SECTION (fixp, sec)))
    return 0;
#endif

d4498 1
a4498 1
  resolve_symbol_value (fix->fx_addsy);
d4514 1
a4514 1
	  if (sy->sy_tc.class == XMC_TC0)
d4516 1
a4516 1
	  if (sy->sy_tc.class != XMC_TC)
d4518 1
a4518 1
	  resolve_symbol_value (sy);
d4528 1
a4528 1
		    "symbol in .toc does not match any .tc");
d4533 10
a4542 4
      && fix->fx_addsy->sy_tc.subseg == 0
      && fix->fx_addsy->sy_tc.class != XMC_TC0
      && fix->fx_addsy->sy_tc.class != XMC_TC
      && S_GET_SEGMENT (fix->fx_addsy) != bss_section)
d4554 1
a4554 1
      csect = csect->sy_tc.next;
d4558 31
a4588 4
	  while (csect->sy_tc.next != (symbolS *) NULL
		 && (csect->sy_tc.next->sy_frag->fr_address
		     <= fix->fx_addsy->sy_frag->fr_address))
	    csect = csect->sy_tc.next;
d4591 1
a4591 1
			     - csect->sy_frag->fr_address);
d4602 5
a4606 4
      resolve_symbol_value (fix->fx_addsy->sy_frag->fr_symbol);
      fix->fx_offset += (S_GET_VALUE (fix->fx_addsy)
			 - S_GET_VALUE (fix->fx_addsy->sy_frag->fr_symbol));
      fix->fx_addsy = fix->fx_addsy->sy_frag->fr_symbol;
d4626 5
a4630 4
      && fix->fx_addsy->sy_tc.subseg != 0
      && (fix->fx_addsy->sy_frag->fr_address > fix->fx_frag->fr_address
	  || (fix->fx_addsy->sy_tc.next != NULL
	      && (fix->fx_addsy->sy_tc.next->sy_frag->fr_address
d4646 1
a4646 1
  return sym->sy_tc.class == XMC_TC;
d4669 23
d4695 1
a4695 1
     bfd_perform_relocation, which is also going to use the symbol
d4697 1
a4697 1
     use *valuep since bfd_perform_relocation is not being used.
a4701 1

d4720 1
a4720 1
			    "expression too complex");
d4724 1
d4750 3
a4752 3
	  && fixp->fx_addsy->sy_tc.subseg != 0
	  && fixp->fx_addsy->sy_tc.class != XMC_TC
	  && fixp->fx_addsy->sy_tc.class != XMC_TC0
d4823 1
a4823 1
			  "unresolved expression that must be resolved");
d4826 1
a4826 1
			  "unsupported relocation type");
a4852 2
	case BFD_RELOC_HI16:
	case BFD_RELOC_HI16_S:
d4877 11
a4887 7
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  "cannot emit PC relative %s relocation%s%s",
			  bfd_get_reloc_code_name (fixp->fx_r_type),
			  fixp->fx_addsy != NULL ? " against " : "",
			  (fixp->fx_addsy != NULL
			   ? S_GET_NAME (fixp->fx_addsy)
			   : ""));
d4893 16
d4928 45
d4975 1
a4975 1
		  "Gas failure, reloc value %d\n", fixp->fx_r_type);
d5006 1
a5006 1
     asection *seg;
d5011 1
a5011 1
  reloc = (arelent *) bfd_alloc_by_size_t (stdoutput, sizeof (arelent));
d5013 2
a5014 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
d5020 1
a5020 1
		    "reloc %d not supported by object file format", (int)fixp->fx_r_type);
@


1.6
log
@Back out half of my changes to this file.
The way that I had done the sign extension was incorrect, but
did happen to work on the archs tested. Changed back to the
correct method.
This was after some conversation with Ian Lance Taylor.
@
text
@a1328 1
  S_CLEAR_EXTERNAL (symbolP);
@


1.5
log
@change constant handling with @@l.
if the expected argument to the opcode is unsigned,
return (val & 0xffff)
if the expected argument to the occode is signed,
sign extend the 16 bit value
	short = val;
	val = (int) short;
@
text
@d1776 3
a1778 4
			/* sign extend */
			signed short i;
			i = ex.X_add_number;
			ex.X_add_number = (int) i;
d1780 1
a1780 1
			ex.X_add_number &= 0xffff;
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d1775 8
a1782 6
		if (ex.X_unsigned)
		  ex.X_add_number &= 0xffff;
		else
		  ex.X_add_number = (((ex.X_add_number & 0xffff)
				      ^ 0x8000)
				     - 0x8000);
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d1049 1
a1049 1
	    as_warn (err, buf, min, max);
d1051 1
a1051 1
	    as_warn_where (file, line, err, buf, min, max);
d1062 1
a1062 1
	as_warn (errmsg);
d1365 2
a1366 2
	  as_warn_where (fixp->fx_file, fixp->fx_line,
			 "Relocation cannot be done when using -mrelocatable");
d1603 1
a1603 1
	    as_warn (errmsg);
d1616 1
a1616 1
		as_warn (errmsg);
d1693 1
a1693 1
		      as_warn("[tocv] symbol is not a toc symbol");
d3055 1
a3055 1
	    as_warn (".tc with no label");
d3549 1
a3549 1
		  as_warn ("Unsupported section attribute -- 'a'");
d3619 2
a3620 2
		  as_warn("unknown section attribute '%c'",
			  *input_line_pointer);
d3637 3
a3639 3
	as_warn ("error setting flags for \"%s\": %s",
		 bfd_section_name (stdoutput, sec),
		 bfd_errmsg (bfd_get_error ()));
d3912 1
a3912 1
	as_warn ("two .function pseudo-ops with no intervening .ef");
d3924 1
a3924 1
	as_warn (".ef with no preceding .function");
d4585 11
a4595 2
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"unresolved expression that must be resolved");
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d91 1
d176 1
d431 2
a432 1
static int reg_name_search PARAMS ( (char * name) );
d435 4
a438 2
reg_name_search (name)
     char *name;
d444 1
a444 1
  high = REG_NAME_CNT - 1;
d449 1
a449 1
      cmp = strcasecmp (name, pre_defined_registers[middle].name);
d455 1
a455 1
	return pre_defined_registers[middle].value;
d492 1
a492 1
  reg_number = reg_name_search (name);
d514 35
d550 13
d661 1
a661 1
CONST char *md_shortopts = "b:l:usm:VQ:";
d706 12
d1071 1
d1143 2
a1144 1
       str2 < ident + sizeof(ident) - 1 && isalnum (ch) || ch == '@@';
d1225 109
a1369 1

d1371 1
a1371 1

a1466 1

d1468 1
a1468 1

d1739 9
a1747 2
	if (!register_name(&ex))
	  expression (&ex);
d1775 6
a1780 1
		ex.X_add_number = ((ex.X_add_number & 0xffff) ^ 0x8000) - 0x8000;
d1788 2
a1789 2
		ex.X_add_number = ((ex.X_add_number >> 16) & 0xffff)
		  + ((ex.X_add_number >> 15) & 1);
d1802 19
a1820 7
	    switch (reloc)
	      {
	      case BFD_RELOC_PPC_B26:		reloc = BFD_RELOC_PPC_BA26;		break;
	      case BFD_RELOC_PPC_B16:		reloc = BFD_RELOC_PPC_BA16;		break;
	      case BFD_RELOC_PPC_B16_BRTAKEN:	reloc = BFD_RELOC_PPC_BA16_BRTAKEN;	break;
	      case BFD_RELOC_PPC_B16_BRNTAKEN:	reloc = BFD_RELOC_PPC_BA16_BRNTAKEN;	break;
	      }
d4405 25
a4429 1
#endif
d4639 7
a4645 1
	    abort ();
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1994 Free Software Foundation, Inc.
d44 11
d89 1
d112 3
d116 1
d172 2
d199 1
a199 3
#ifdef TE_PE
/* The Windows NT PowerPC assembler uses predefined names.            */

d456 52
a507 1
#endif
a579 3
/* The size of the .debug section.  */
static bfd_size_type ppc_debug_name_section_size;

d607 1
a607 1
CONST char *md_shortopts = "um:VQ:";
d628 26
d690 6
d744 9
d776 3
a778 1
-many			generate code for any architecture (PWR/PWRX/PPC)\n");
d797 1
d802 6
a807 1
      if (strcmp (default_cpu, "rs6000") == 0)
d813 1
a813 1
	as_fatal ("Unknown default cpu = %s", default_cpu);
a1026 1
    MAP ("got",		BFD_RELOC_PPC_TOC16),
d1032 1
d1051 17
d1142 15
d1169 8
d1181 3
a1183 1
      && strcmp (segment_name (seg), ".stab") != 0)
a1196 45
/*
 * Summary of register_name().
 *
 * in:	Input_line_pointer points to 1st char of operand.
 *
 * out:	A expressionS.
 *      The operand may have been a register: in this case, X_op == O_register,
 *      X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in its
 *      original state.
 */

static int
register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char c;

  /* Find the spelling of the operand */
  name = input_line_pointer;
  c = get_symbol_end ();
  reg_number = reg_name_search (name);

  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;
      
      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      *input_line_pointer = c;   /* put back the delimiting char */
      return 1;
    }
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = name; /* reset input_line pointer */
      return 0;
    }
}
d1561 1
d1563 3
a1565 6
	{
	  if (!register_name(&ex))
	    {
	      expression (&ex);
	    }
	}
a1568 5
#else
      expression (&ex);
      str = input_line_pointer;
      input_line_pointer = hold;
#endif
d1574 5
a1608 7
#ifdef TE_PE
      else if (ex.X_op == O_register)
	{
	  insn = ppc_insert_operand (insn, operand, ex.X_add_number,
				     (char *) NULL, 0);
	}
#endif
d1715 2
d1838 58
d2119 6
a2412 7
  if (strlen (name) > SYMNMLEN)
    {
      /* For some reason, each name is preceded by a two byte length
	 and followed by a null byte.  */
      ppc_debug_name_section_size += strlen (name) + 3;
    }

a2739 3
  if (strlen (name) > SYMNMLEN)
    ppc_debug_name_section_size += strlen (name) + 3;

d2968 1
a2968 1
      bfd_set_section_alignment (stdoutput, pdata_section, 3);
d3040 1
a3040 1
      bfd_set_section_alignment (stdoutput, reldata_section, 3);
a3297 2
  align = 4; /* default alignment to 16 byte boundary */

d3311 23
a3974 19
/* Adjust the file by adding a .debug section if needed.  */

void
ppc_frob_file ()
{
  if (ppc_debug_name_section_size > 0)
    {
      asection *sec;

      sec = bfd_make_section (stdoutput, ".debug");
      if (sec == (asection *) NULL
	  || ! bfd_set_section_size (stdoutput, sec,
				     ppc_debug_name_section_size)
	  || ! bfd_set_section_flags (stdoutput, sec,
				      SEC_HAS_CONTENTS | SEC_LOAD))
	as_fatal ("can't make .debug section");
    }
}

d4378 2
a4379 4
	    {
	      fixp->fx_r_type = BFD_RELOC_32_PCREL;
	      value += fixp->fx_frag->fr_address + fixp->fx_where;
	    }			/* fall through */
d4383 2
a4391 1
	case BFD_RELOC_PPC_TOC16:
d4395 20
d4419 11
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.
a43 11
/* Whether to use user friendly register names.  */
#ifndef TARGET_REG_NAMES_P
#ifdef TE_PE
#define TARGET_REG_NAMES_P true
#else
#define TARGET_REG_NAMES_P false
#endif
#endif

static boolean reg_names_p = TARGET_REG_NAMES_P;

a77 1
static void ppc_elf_rdata PARAMS ((int));
a99 3
#ifdef TARGET_SOLARIS_COMMENT
const char comment_chars[] = "#!";
#else
a100 1
#endif
a155 2
  { "rdata",	ppc_elf_rdata,	0 },
  { "rodata",	ppc_elf_rdata,	0 },
d181 3
a183 1
/* Predefined register names if -mregnames (or default for Windows NT).  */
d440 1
a440 52
/*
 * Summary of register_name().
 *
 * in:	Input_line_pointer points to 1st char of operand.
 *
 * out:	A expressionS.
 *      The operand may have been a register: in this case, X_op == O_register,
 *      X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in its
 *      original state.
 */

static boolean
register_name (expressionP)
     expressionS *expressionP;
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand */
  start = name = input_line_pointer;
  if (name[0] == '%' && isalpha (name[1]))
    name = ++input_line_pointer;

  else if (!reg_names_p || !isalpha (name[0]))
    return false;

  c = get_symbol_end ();
  reg_number = reg_name_search (name);

  /* look to see if it's in the register table */
  if (reg_number >= 0) 
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;
      
      /* make the rest nice */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      *input_line_pointer = c;   /* put back the delimiting char */
      return true;
    }
  else
    {
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
      return false;
    }
}
d513 3
d543 1
a543 1
CONST char *md_shortopts = "b:l:usm:VQ:";
a563 26
#ifdef OBJ_ELF
    case 'l':
      /* Solaris as takes -le (presumably for little endian).  For completeness
         sake, recognize -be also.  */
      if (strcmp (arg, "e") == 0)
	{
	  target_big_endian = 0;
	  set_target_endian = 1;
	}
      else
	return 0;

      break;

    case 'b':
      if (strcmp (arg, "e") == 0)
	{
	  target_big_endian = 1;
	  set_target_endian = 1;
	}
      else
	return 0;

      break;
#endif

a599 6
      else if (strcmp (arg, "regnames") == 0)
	reg_names_p = true;

      else if (strcmp (arg, "no-regnames") == 0)
	reg_names_p = false;

a647 9

      /* Solaris takes -s to specify that .stabs go in a .stabs section,
	 rather than .stabs.excl, which is ignored by the linker.
	 FIXME: Not implemented.  */
    case 's':
      if (arg)
	return 0;

      break;
d671 1
a671 3
-many			generate code for any architecture (PWR/PWRX/PPC)\n\
-mregnames		Allow symbolic names for registers\n\
-mno-regnames		Do not allow symbolic names for registers\n");
a689 1
  const char *default_os  = TARGET_OS;
d694 1
a694 6
      if (strncmp (default_os, "aix", 3) == 0
	  && default_os[3] >= '4' && default_os[3] <= '9')
	ppc_cpu = PPC_OPCODE_COMMON;
      else if (strncmp (default_os, "aix3", 4) == 0)
	ppc_cpu = PPC_OPCODE_POWER;
      else if (strcmp (default_cpu, "rs6000") == 0)
d700 1
a700 1
	as_fatal ("Unknown default cpu = %s, os = %s", default_cpu, default_os);
d914 1
a919 1
    MAP ("got",		BFD_RELOC_16_GOTOFF),
a937 17
    MAP ("naddr",	BFD_RELOC_PPC_EMB_NADDR32),
    MAP ("naddr16",	BFD_RELOC_PPC_EMB_NADDR16),
    MAP ("naddr@@l",	BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP ("naddr@@h",	BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP ("naddr@@ha",	BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP ("sdai16",	BFD_RELOC_PPC_EMB_SDAI16),
    MAP ("sda2rel",	BFD_RELOC_PPC_EMB_SDA2REL),
    MAP ("sda2i16",	BFD_RELOC_PPC_EMB_SDA2I16),
    MAP ("sda21",	BFD_RELOC_PPC_EMB_SDA21),
    MAP ("mrkref",	BFD_RELOC_PPC_EMB_MRKREF),
    MAP ("relsect",	BFD_RELOC_PPC_EMB_RELSEC16),
    MAP ("relsect@@l",	BFD_RELOC_PPC_EMB_RELST_LO),
    MAP ("relsect@@h",	BFD_RELOC_PPC_EMB_RELST_HI),
    MAP ("relsect@@ha",	BFD_RELOC_PPC_EMB_RELST_HA),
    MAP ("bitfld",	BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP ("relsda",	BFD_RELOC_PPC_EMB_RELSDA),
    MAP ("xgot",	BFD_RELOC_PPC_TOC16),
a1011 15
/* Solaris pseduo op to change to the .rodata section.  */
static void
ppc_elf_rdata (xxx)
     int xxx;
{
  char *save_line = input_line_pointer;
  static char section[] = ".rodata\n";

  /* Just pretend this is .section .rodata */
  input_line_pointer = section;
  obj_elf_section (xxx);

  input_line_pointer = save_line;
}

a1023 8
      && fixp->fx_r_type != BFD_RELOC_16_GOTOFF
      && fixp->fx_r_type != BFD_RELOC_HI16_GOTOFF
      && fixp->fx_r_type != BFD_RELOC_LO16_GOTOFF
      && fixp->fx_r_type != BFD_RELOC_HI16_S_GOTOFF
      && fixp->fx_r_type != BFD_RELOC_32_BASEREL
      && fixp->fx_r_type != BFD_RELOC_LO16_BASEREL
      && fixp->fx_r_type != BFD_RELOC_HI16_BASEREL
      && fixp->fx_r_type != BFD_RELOC_HI16_S_BASEREL
d1028 1
a1028 3
      && strcmp (segment_name (seg), ".stab") != 0
      && strcmp (segment_name (seg), ".gcc_except_table") != 0
      && strcmp (segment_name (seg), ".ex_shared") != 0)
d1042 45
a1450 1

d1452 6
a1457 3
#endif		/* TE_PE */
	if (!register_name(&ex))
	  expression (&ex);
d1461 5
a1470 5
      else if (ex.X_op == O_register)
	{
	  insn = ppc_insert_operand (insn, operand, ex.X_add_number,
				     (char *) NULL, 0);
	}
d1501 7
a1613 2
	    case BFD_RELOC_16_GOTOFF:
	    case BFD_RELOC_PPC_TOC16:
a1734 58
#ifdef OBJ_ELF
/* For ELF, add support for SHF_EXCLUDE and SHT_ORDERED */

int
ppc_section_letter (letter, ptr_msg)
     int letter;
     char **ptr_msg;
{
  if (letter == 'e')
    return SHF_EXCLUDE;

  *ptr_msg = "Bad .section directive: want a,w,x,e in string";
  return 0;
}

int
ppc_section_word (ptr_str)
     char **ptr_str;
{
  if (strncmp (*ptr_str, "exclude", sizeof ("exclude")-1) == 0)
    {
      *ptr_str += sizeof ("exclude")-1;
      return SHF_EXCLUDE;
    }

  return 0;
}

int
ppc_section_type (ptr_str)
     char **ptr_str;
{
  if (strncmp (*ptr_str, "ordered", sizeof ("ordered")-1) == 0)
    {
      *ptr_str += sizeof ("ordered")-1;
      return SHT_ORDERED;
    }

  return 0;
}

int
ppc_section_flags (flags, attr, type)
     int flags;
     int attr;
     int type;
{
  if (type == SHT_ORDERED)
    flags |= SEC_ALLOC | SEC_LOAD | SEC_SORT_ENTRIES;

  if (attr & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;

  return flags;
}
#endif /* OBJ_ELF */


a1957 6
  if (S_GET_NAME (sym)[0] == '\0')
    {
      /* An unnamed csect is assumed to be [PR].  */
      sym->sy_tc.class = XMC_PR;
    }

d2246 7
d2580 3
d2811 1
a2811 1
      bfd_set_section_alignment (stdoutput, pdata_section, 2);
d2883 1
a2883 1
      bfd_set_section_alignment (stdoutput, reldata_section, 2);
d3141 2
a3155 23
  if (strcmp (name, ".idata$2") == 0)
    {
      align = 0;
    }
  else if (strcmp (name, ".idata$3") == 0)
    {
      align = 0;
    }
  else if (strcmp (name, ".idata$4") == 0)
    {
      align = 2;
    }
  else if (strcmp (name, ".idata$5") == 0)
    {
      align = 2;
    }
  else if (strcmp (name, ".idata$6") == 0)
    {
      align = 1;
    }
  else
    align = 4; /* default alignment to 16 byte boundary */

d3797 19
d4219 4
a4222 2
	    fixp->fx_r_type = BFD_RELOC_32_PCREL;
					/* fall through */
a4225 2
	case BFD_RELOC_32_BASEREL:
	case BFD_RELOC_PPC_EMB_NADDR32:
d4233 1
a4236 20
	case BFD_RELOC_16_GOTOFF:
	case BFD_RELOC_LO16_GOTOFF:
	case BFD_RELOC_HI16_GOTOFF:
	case BFD_RELOC_HI16_S_GOTOFF:
	case BFD_RELOC_LO16_BASEREL:
	case BFD_RELOC_HI16_BASEREL:
	case BFD_RELOC_HI16_S_BASEREL:
	case BFD_RELOC_PPC_EMB_NADDR16:
	case BFD_RELOC_PPC_EMB_NADDR16_LO:
	case BFD_RELOC_PPC_EMB_NADDR16_HI:
	case BFD_RELOC_PPC_EMB_NADDR16_HA:
	case BFD_RELOC_PPC_EMB_SDAI16:
	case BFD_RELOC_PPC_EMB_SDA2REL:
	case BFD_RELOC_PPC_EMB_SDA2I16:
	case BFD_RELOC_PPC_EMB_RELSEC16:
	case BFD_RELOC_PPC_EMB_RELST_LO:
	case BFD_RELOC_PPC_EMB_RELST_HI:
	case BFD_RELOC_PPC_EMB_RELST_HA:
	case BFD_RELOC_PPC_EMB_RELSDA:
	case BFD_RELOC_PPC_TOC16:
a4240 11
			      value, 2);
	  break;

	  /* Because SDA21 modifies the register field, the size is set to 4
	     bytes, rather than 2, so offset it here appropriately */
	case BFD_RELOC_PPC_EMB_SDA21:
	  if (fixp->fx_pcrel)
	    abort ();

	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where
			      + ((target_big_endian) ? 2 : 0),
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d18 2
a19 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA. */
a89 1
static void ppc_elf_lcomm PARAMS ((int));
a173 1
  { "lcomm",	ppc_elf_lcomm,	0 },
d428 1
a428 2
static int reg_name_search
  PARAMS ((const struct pd_reg *, int, const char * name));
d431 2
a432 4
reg_name_search (regs, regcount, name)
     const struct pd_reg *regs;
     int regcount;
     const char *name;
d438 1
a438 1
  high = regcount - 1;
d443 1
a443 1
      cmp = strcasecmp (name, regs[middle].name);
d449 1
a449 1
	return regs[middle].value;
d486 1
a486 1
  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT, name);
a507 35

/* This function is called for each symbol seen in an expression.  It
   handles the special parsing which PowerPC assemblers are supposed
   to use for condition codes.  */

/* Whether to do the special parsing.  */
static boolean cr_operand;

/* Names to recognize in a condition code.  This table is sorted.  */
static const struct pd_reg cr_names[] =
{
  { "cr0", 0 },
  { "cr1", 1 },
  { "cr2", 2 },
  { "cr3", 3 },
  { "cr4", 4 },
  { "cr5", 5 },
  { "cr6", 6 },
  { "cr7", 7 },
  { "eq", 2 },
  { "gt", 1 },
  { "lt", 0 },
  { "so", 3 },
  { "un", 3 }
};

/* Parsing function.  This returns non-zero if it recognized an
   expression.  */

int
ppc_parse_name (name, expr)
     const char *name;
     expressionS *expr;
{
  int val;
a508 13
  if (! cr_operand)
    return 0;

  val = reg_name_search (cr_names, sizeof cr_names / sizeof cr_names[0],
			 name);
  if (val < 0)
    return 0;

  expr->X_op = O_constant;
  expr->X_add_number = val;

  return 1;
}
d607 1
a607 1
CONST char *md_shortopts = "b:l:usm:K:VQ:";
a651 12

    case 'K':
      /* Recognize -K PIC */
      if (strcmp (arg, "PIC") == 0)
	{
	  mrelocatable = true;
	  ppc_flags |= EF_PPC_RELOCATABLE_LIB;
	}
      else
	return 0;

      break;
a1004 1

d1076 1
a1076 2
       (str2 < ident + sizeof (ident) - 1
	&& (isalnum (ch) || ch == '@@'));
a1156 109
/* Pseudo op to make file scope bss items */
static void
ppc_elf_lcomm(xxx)
     int xxx;
{
  register char *name;
  register char c;
  register char *p;
  offsetT size;
  register symbolS *symbolP;
  offsetT align;
  segT old_sec;
  int old_subsec;
  char *pfrag;
  int align2;

  name = input_line_pointer;
  c = get_symbol_end ();

  /* just after name is now '\0' */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad ("Expected comma after symbol-name: rest of line ignored.");
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;		/* skip ',' */
  if ((size = get_absolute_expression ()) < 0)
    {
      as_warn (".COMMon length (%ld.) <0! Ignored.", (long) size);
      ignore_rest_of_line ();
      return;
    }

  /* The third argument to .lcomm is the alignment.  */
  if (*input_line_pointer != ',')
    align = 3;
  else
    {
      ++input_line_pointer;
      align = get_absolute_expression ();
      if (align <= 0)
	{
	  as_warn ("ignoring bad alignment");
	  align = 3;
	}
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (S_IS_DEFINED (symbolP))
    {
      as_bad ("Ignoring attempt to re-define symbol `%s'.",
	      S_GET_NAME (symbolP));
      ignore_rest_of_line ();
      return;
    }

  if (S_GET_VALUE (symbolP) && S_GET_VALUE (symbolP) != (valueT) size)
    {
      as_bad ("Length of .lcomm \"%s\" is already %ld. Not changed to %ld.",
	      S_GET_NAME (symbolP),
	      (long) S_GET_VALUE (symbolP),
	      (long) size);

      ignore_rest_of_line ();
      return;
    }

  /* allocate_bss: */
  old_sec = now_seg;
  old_subsec = now_subseg;
  if (align)
    {
      /* convert to a power of 2 alignment */
      for (align2 = 0; (align & 1) == 0; align >>= 1, ++align2);
      if (align != 1)
	{
	  as_bad ("Common alignment not a power of 2");
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    align2 = 0;

  record_alignment (bss_section, align2);
  subseg_set (bss_section, 0);
  if (align2)
    frag_align (align2, 0);
  if (S_GET_SEGMENT (symbolP) == bss_section)
    symbolP->sy_frag->fr_symbol = 0;
  symbolP->sy_frag = frag_now;
  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP, size,
		    (char *) 0);
  *pfrag = 0;
  S_SET_SIZE (symbolP, size);
  S_SET_SEGMENT (symbolP, bss_section);
  S_CLEAR_EXTERNAL (symbolP);
  subseg_set (old_sec, old_subsec);
  demand_empty_rest_of_line ();
}

d1193 1
d1195 1
a1195 1

d1291 1
d1293 1
a1293 1

d1564 2
a1565 9
	{
	  if (! register_name (&ex))
	    {
	      if ((operand->flags & PPC_OPERAND_CR) != 0)
		cr_operand = true;
	      expression (&ex);
	      cr_operand = false;
	    }
	}
d1593 1
a1593 6
		if (ex.X_unsigned)
		  ex.X_add_number &= 0xffff;
		else
		  ex.X_add_number = (((ex.X_add_number & 0xffff)
				      ^ 0x8000)
				     - 0x8000);
d1601 2
a1602 2
		ex.X_add_number = (((ex.X_add_number >> 16) & 0xffff)
				   + ((ex.X_add_number >> 15) & 1));
d1615 7
a1621 19
	    {
	      switch (reloc)
		{
		case BFD_RELOC_PPC_B26:
		  reloc = BFD_RELOC_PPC_BA26;
		  break;
		case BFD_RELOC_PPC_B16:
		  reloc = BFD_RELOC_PPC_BA16;
		  break;
		case BFD_RELOC_PPC_B16_BRTAKEN:
		  reloc = BFD_RELOC_PPC_BA16_BRTAKEN;
		  break;
		case BFD_RELOC_PPC_B16_BRNTAKEN:
		  reloc = BFD_RELOC_PPC_BA16_BRNTAKEN;
		  break;
		default:
		  break;
		}
	    }
d4206 1
a4206 25
/* A reloc from one csect to another must be kept.  The assembler
   will, of course, keep relocs between sections, and it will keep
   absolute relocs, but we need to force it to keep PC relative relocs
   between two csects in the same section.  */

int
ppc_force_relocation (fix)
     fixS *fix;
{
  /* At this point fix->fx_addsy should already have been converted to
     a csect symbol.  If the csect does not include the fragment, then
     we need to force the relocation.  */
  if (fix->fx_pcrel
      && fix->fx_addsy != NULL
      && fix->fx_addsy->sy_tc.subseg != 0
      && (fix->fx_addsy->sy_frag->fr_address > fix->fx_frag->fr_address
	  || (fix->fx_addsy->sy_tc.next != NULL
	      && (fix->fx_addsy->sy_tc.next->sy_frag->fr_address
		  <= fix->fx_frag->fr_address))))
    return 1;

  return 0;
}

#endif /* OBJ_XCOFF */
d4416 1
a4416 7
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  "cannot emit PC relative %s relocation%s%s",
			  bfd_get_reloc_code_name (fixp->fx_r_type),
			  fixp->fx_addsy != NULL ? " against " : "",
			  (fixp->fx_addsy != NULL
			   ? S_GET_NAME (fixp->fx_addsy)
			   : ""));
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d1049 1
a1049 1
	    as_bad (err, buf, min, max);
d1051 1
a1051 1
	    as_bad_where (file, line, err, buf, min, max);
d1062 1
a1062 1
	as_bad (errmsg);
d1365 2
a1366 2
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Relocation cannot be done when using -mrelocatable");
d1603 1
a1603 1
	    as_bad (errmsg);
d1616 1
a1616 1
		as_bad (errmsg);
d1693 1
a1693 1
		      as_bad("[tocv] symbol is not a toc symbol");
d3055 1
a3055 1
	    as_bad (".tc with no label");
d3549 1
a3549 1
		  as_bad ("Unsupported section attribute -- 'a'");
d3619 2
a3620 2
		  as_bad("unknown section attribute '%c'",
			 *input_line_pointer);
d3637 3
a3639 3
	as_bad ("error setting flags for \"%s\": %s",
		bfd_section_name (stdoutput, sec),
		bfd_errmsg (bfd_get_error ()));
d3912 1
a3912 1
	as_bad ("two .function pseudo-ops with no intervening .ef");
d3924 1
a3924 1
	as_bad (".ef with no preceding .function");
d4585 2
a4586 11
	  char *sfile;
	  unsigned int sline;

	  /* Use expr_symbol_where to see if this is an expression
             symbol.  */
	  if (expr_symbol_where (fixp->fx_addsy, &sfile, &sline))
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  "unresolved expression that must be resolved");
	  else
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  "unsupported relocation type");
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.
a55 1
static boolean register_name PARAMS ((expressionS *));
a84 1
static void ppc_xcoff_cons PARAMS ((int));
d88 1
a88 1
static bfd_reloc_code_real_type ppc_elf_suffix PARAMS ((char **, expressionS *));
d113 1
a113 8
#ifdef OBJ_ELF
/* This string holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  The macro
   tc_comment_chars points to this.  We use this, rather than the
   usual comment_chars, so that we can switch for Solaris conventions.  */
static const char ppc_solaris_comment_chars[] = "#!";
static const char ppc_eabi_comment_chars[] = "#";

d115 1
a115 4
const char *ppc_comment_chars = ppc_solaris_comment_chars;
#else
const char *ppc_comment_chars = ppc_eabi_comment_chars;
#endif
a167 3
  { "long",	ppc_xcoff_cons,	2 },
  { "word",	ppc_xcoff_cons,	1 },
  { "short",	ppc_xcoff_cons,	1 },
d581 3
a583 2
/* What type of shared library support to use */
static enum { SHLIB_NONE, SHLIB_PIC, SHILB_MRELOCATABLE } shlib = SHLIB_NONE;
a586 9

/* Whether this is Solaris or not.  */
#ifdef TARGET_SOLARIS_COMMENT
#define SOLARIS_P true
#else
#define SOLARIS_P false
#endif

static boolean msolaris = SOLARIS_P;
d709 1
a709 1
      if (strcmp (arg, "PIC") == 0 || strcmp (arg, "pic") == 0)
d711 1
a711 1
	  shlib = SHLIB_PIC;
d766 1
a766 1
	  shlib = SHILB_MRELOCATABLE;
d772 1
a772 1
	  shlib = SHILB_MRELOCATABLE;
a791 12

      else if (strcmp (arg, "solaris") == 0)
	{
	  msolaris = true;
	  ppc_comment_chars = ppc_solaris_comment_chars;
	}

      else if (strcmp (arg, "no-solaris") == 0)
	{
	  msolaris = false;
	  ppc_comment_chars = ppc_eabi_comment_chars;
	}
a852 2
-msolaris		generate code for Solaris\n\
-mno-solaris		do not generate code for Solaris\n\
d925 1
a925 1
  if (ppc_flags && !msolaris)
d1075 1
a1075 1
ppc_elf_suffix (str_p, exp_p)
a1076 1
     expressionS *exp_p;
a1103 1
    MAP ("plt",		BFD_RELOC_24_PLT_PCREL),
d1108 1
a1108 1
    MAP ("local",	BFD_RELOC_PPC_LOCAL24PC),
a1156 18
	/* Now check for identifier@@suffix+constant */
	if (*str == '-' || *str == '+')
	  {
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;

	    input_line_pointer = str;
	    expression (&new_exp);
	    if (new_exp.X_op == O_constant)
	      {
		exp_p->X_add_number += new_exp.X_add_number;
		str = input_line_pointer;
	      }

	    if (&input_line_pointer != str_p)
	      input_line_pointer = orig_line;
	  }

d1185 1
a1185 1
	  && (reloc = ppc_elf_suffix (&input_line_pointer, &exp)) != BFD_RELOC_UNUSED)
d1265 1
a1265 1
    align = 8;
d1273 1
a1273 1
	  align = 8;
d1281 1
a1281 1
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d1320 1
a1320 1
    frag_align (align2, 0, 0);
d1329 1
d1342 19
a1360 4
  if (fixp->fx_done || fixp->fx_pcrel)
    return;

  switch (shlib)
d1362 2
a1363 21
    case SHLIB_NONE:
    case SHLIB_PIC:
      return;

    case SHILB_MRELOCATABLE:
      if (fixp->fx_r_type <= BFD_RELOC_UNUSED
	  && fixp->fx_r_type != BFD_RELOC_16_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_HI16_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_LO16_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_HI16_S_GOTOFF
	  && fixp->fx_r_type != BFD_RELOC_32_BASEREL
	  && fixp->fx_r_type != BFD_RELOC_LO16_BASEREL
	  && fixp->fx_r_type != BFD_RELOC_HI16_BASEREL
	  && fixp->fx_r_type != BFD_RELOC_HI16_S_BASEREL
	  && strcmp (segment_name (seg), ".got2") != 0
	  && strcmp (segment_name (seg), ".dtors") != 0
	  && strcmp (segment_name (seg), ".ctors") != 0
	  && strcmp (segment_name (seg), ".fixup") != 0
	  && strcmp (segment_name (seg), ".stab") != 0
	  && strcmp (segment_name (seg), ".gcc_except_table") != 0
	  && strcmp (segment_name (seg), ".ex_shared") != 0)
d1365 2
a1366 6
	  if ((seg->flags & (SEC_READONLY | SEC_CODE)) != 0
	      || fixp->fx_r_type != BFD_RELOC_CTOR)
	    {
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    "Relocation cannot be done when using -mrelocatable");
	    }
a1367 1
      return;
d1767 1
a1767 1
	  if ((reloc = ppc_elf_suffix (&str, &ex)) != BFD_RELOC_UNUSED)
d1797 1
a1797 1
      else if ((reloc = ppc_elf_suffix (&str, &ex)) != BFD_RELOC_UNUSED)
d2264 1
a2264 1
      frag_align (align, 0, 0);
a3006 12
/* The AIX assembler automatically aligns the operands of a .long or
   .short pseudo-op, and we want to be compatible.  */

static void
ppc_xcoff_cons (log_size)
     int log_size;
{
  frag_align (log_size, 0, 0);
  record_alignment (now_seg, log_size);
  cons (1 << log_size);
}

d3090 1
a3090 1
  frag_align (2, 0, 0);
d3409 1
a3409 1
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d4464 1
a4464 1
     bfd_install_relocation, which is also going to use the symbol
d4466 1
a4466 1
     use *valuep since bfd_install_relocation is not being used.
a4678 7
	case BFD_RELOC_24_PLT_PCREL:
	case BFD_RELOC_PPC_LOCAL24PC:
	  if (!fixp->fx_pcrel)
	    abort ();

	  break;

d4717 1
a4717 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000 
   Free Software Foundation, Inc.
a82 1
static void ppc_named_section PARAMS ((int));
a86 1
static void ppc_vbyte PARAMS ((int));
a176 1
  { "section",	ppc_named_section, 0 },
a182 1
  { "vbyte",    ppc_vbyte,	0 },
d587 1
a587 1
static unsigned long ppc_size = PPC_OPCODE_32;
d677 5
a769 5
      else if (strcmp (arg, "ppc64bridge") == 0)
	{
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_64_BRIDGE;
	  ppc_size = PPC_OPCODE_64;
	}
d830 1
a830 1
	  as_bad (_("invalid switch -m%s"), arg);
d867 1
a867 1
  fprintf(stream, _("\
a875 1
-mppc64bridge		generate code for PowerPC 64, including bridge insns\n\
d879 1
a879 1
-mno-regnames		Do not allow symbolic names for registers\n"));
d881 1
a881 1
  fprintf(stream, _("\
d891 1
a891 1
-Qy, -Qn		ignored\n"));
d916 1
a916 1
	as_fatal (_("Unknown default cpu = %s, os = %s"), default_cpu, default_os);
d941 1
a941 1
  as_fatal (_("Neither Power nor PowerPC opcodes were selected."));
d976 1
a976 2
	      || (op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64)) == ppc_size
	      || (ppc_cpu & PPC_OPCODE_64_BRIDGE) != 0))
d988 1
a988 1
	      as_bad (_("Internal assembler error for instruction %s"), op->name);
d1007 1
a1007 1
	      as_bad (_("Internal assembler error for macro %s"), macro->name);
d1030 1
a1030 1
  symbol_get_tc (ppc_text_csects)->within = ppc_text_csects;
d1032 1
a1032 1
  symbol_get_tc (ppc_data_csects)->within = ppc_data_csects;
d1060 2
a1061 1
	  if ((operand->flags & PPC_OPERAND_SIGNOPT) != 0)
a1065 15

	  if (ppc_size == PPC_OPCODE_32)
	    {
	      /* Some people write 32 bit hex constants with the sign
		 extension done by hand.  This shouldn't really be
		 valid, but, to permit this code to assemble on a 64
		 bit host, we sign extend the 32 bit value.  */
	      if (val > 0
		  && (val & (offsetT) 0x80000000) != 0
		  && (val & (offsetT) 0xffffffff) == val)
		{
		  val -= 0x80000000;
		  val -= 0x80000000;
		}
	    }
d1081 1
a1081 1
	    _("operand out of range (%s not between %ld and %ld)");
d1194 1
a1194 3
    if (ch == ptr->string[0]
	&& len == ptr->length
	&& memcmp (ident, ptr->string, ptr->length) == 0)
a1195 7
	if (exp_p->X_add_number != 0
	    && (ptr->reloc == BFD_RELOC_16_GOTOFF
		|| ptr->reloc == BFD_RELOC_LO16_GOTOFF
		|| ptr->reloc == BFD_RELOC_HI16_GOTOFF
		|| ptr->reloc == BFD_RELOC_HI16_S_GOTOFF))
	  as_warn (_("identifier+constant@@got means identifier@@got+constant"));

d1248 1
a1248 1
	    as_bad (_("%s relocations do not fit in %d bytes\n"), reloc_howto->name, nbytes);
d1285 1
a1285 1
     int xxx ATTRIBUTE_UNUSED;
d1307 1
a1307 1
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
d1315 1
a1315 1
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) size);
d1329 1
a1329 1
	  as_warn (_("ignoring bad alignment"));
d1340 1
a1340 1
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
d1348 1
a1348 1
      as_bad (_("Length of .lcomm \"%s\" is already %ld. Not changed to %ld."),
d1366 1
a1366 1
	  as_bad (_("Common alignment not a power of 2"));
d1379 2
a1380 2
    symbol_get_frag (symbolP)->fr_symbol = 0;
  symbol_set_frag (symbolP, frag_now);
a1422 1
	  && strcmp (segment_name (seg), ".eh_frame") != 0
d1429 1
a1429 1
			    _("Relocation cannot be done when using -mrelocatable"));
d1510 1
a1510 1
      as_bad (_("syntax error: invalid toc specifier `%s'"), toc_spec);
d1524 1
a1524 1
      as_bad (_("syntax error: expected `]', found  `%c'"), c);
d1583 1
a1583 1
	as_bad (_("Unrecognized opcode: `%s'"), str);
d1756 1
a1756 2
		  if (symbol_get_bfdsym (ex.X_add_symbol)->section
		      != tocdata_section)
d1758 1
a1758 1
		      as_bad(_("[tocv] symbol is not a toc symbol"));
d1769 1
a1769 1
	      as_bad (_("Unimplemented toc32 expression modifier"));
d1774 1
a1774 1
	      as_bad (_("Unimplemented toc64 expression modifier"));
d1778 1
a1778 1
		      _("Unexpected return value [%d] from parse_toc_entry!\n"),
d1786 1
a1786 1
	    as_fatal (_("too many fixups"));
d1818 1
a1818 1
	as_bad (_("illegal operand"));
d1820 1
a1820 1
	as_bad (_("missing operand"));
d1840 1
a1840 5
		/* X_unsigned is the default, so if the user has done
                   something which cleared it, we always produce a
                   signed value.  */
		if (ex.X_unsigned
		    && (operand->flags & PPC_OPERAND_SIGNED) == 0)
d1853 2
a1854 3
		ex.X_add_number = ((((ex.X_add_number >> 16) & 0xffff)
				    + ((ex.X_add_number >> 15) & 1))
				   & 0xffff);
d1889 1
a1889 1
	    as_fatal (_("too many fixups"));
d1901 1
a1901 1
	    as_fatal (_("too many fixups"));
d1926 1
a1926 1
	  as_bad (_("syntax error; found `%c' but expected `%c'"), *str, endc);
d1938 1
a1938 1
    as_bad (_("junk at end of line: `%s'"), str);
d1999 23
d2057 1
a2057 1
      as_bad (_("wrong number of operands"));
d2113 1
a2113 1
  *ptr_msg = _("Bad .section directive: want a,w,x,e in string");
d2118 2
a2119 3
ppc_section_word (str, len)
     char *str;
     size_t len;
d2121 5
a2125 2
  if (len == 7 && strncmp (str, "exclude", 7) == 0)
    return SHF_EXCLUDE;
d2127 1
a2127 1
  return -1;
d2131 2
a2132 3
ppc_section_type (str, len)
     char *str;
     size_t len;
d2134 5
a2138 2
  if (len == 7 && strncmp (str, "ordered", 7) == 0)
    return SHT_ORDERED;
d2140 1
a2140 1
  return -1;
d2167 1
a2167 1
     int ignore ATTRIBUTE_UNUSED;
d2231 1
a2231 1
      as_bad (_("missing size"));
d2240 1
a2240 1
      as_bad (_("negative size"));
d2256 1
a2256 1
	      as_warn (_("ignoring bad alignment"));
d2281 1
a2281 1
	  as_bad (_("missing real symbol name"));
d2302 1
a2302 1
      as_bad (_("attempt to redefine symbol"));
d2323 1
a2323 1
	  symbol_get_tc (lcomm_sym)->output = 1;
d2331 1
a2331 1
      symbol_set_frag (def_sym, frag_now);
d2336 1
a2336 1
      symbol_get_tc (def_sym)->align = align;
d2341 2
a2342 2
      symbol_get_frag (lcomm_sym)->fr_offset =
	((symbol_get_frag (lcomm_sym)->fr_offset + (1 << align) - 1)
d2344 2
a2345 2
      if (align > symbol_get_tc (lcomm_sym)->align)
	symbol_get_tc (lcomm_sym)->align = align;
d2352 3
a2354 3
      symbol_set_frag (sym, symbol_get_frag (lcomm_sym));
      S_SET_VALUE (sym, symbol_get_frag (lcomm_sym)->fr_offset);
      symbol_get_frag (lcomm_sym)->fr_offset += size;
d2386 1
a2386 1
      symbol_get_tc (sym)->class = XMC_PR;
d2394 1
a2394 1
      symbol_get_tc (sym)->align = get_absolute_expression ();
d2407 1
a2407 1
    subseg_set (S_GET_SEGMENT (sym), symbol_get_tc (sym)->subseg);
a2411 1
      int hold_chunksize;
d2418 1
a2418 1
      switch (symbol_get_tc (sym)->class)
d2429 1
a2429 1
	  symbol_get_tc (sym)->subseg = ppc_text_subsegment;
d2441 1
a2441 2
	      && (symbol_get_tc (ppc_toc_csect)->subseg + 1
		  == ppc_data_subsegment))
d2444 1
a2444 1
	  symbol_get_tc (sym)->subseg = ppc_data_subsegment;
d2452 1
a2452 11
      /* We set the obstack chunk size to a small value before
         changing subsegments, so that we don't use a lot of memory
         space for what may be a small section.  */
      hold_chunksize = chunksize;
      chunksize = 64;

      subseg_new (segment_name (S_GET_SEGMENT (sym)),
		  symbol_get_tc (sym)->subseg);

      chunksize = hold_chunksize;

d2456 1
a2456 1
      symbol_set_frag (sym, frag_now);
d2459 3
a2461 3
      symbol_get_tc (sym)->align = 2;
      symbol_get_tc (sym)->output = 1;
      symbol_get_tc (sym)->within = sym;
d2464 2
a2465 2
	   symbol_get_tc (list)->next != (symbolS *) NULL;
	   list = symbol_get_tc (list)->next)
d2467 1
a2467 1
      symbol_get_tc (list)->next = sym;
d2470 1
a2470 2
      symbol_append (sym, symbol_get_tc (list)->within, &symbol_rootP,
		     &symbol_lastP);
a2500 37
/* This function handles the .section pseudo-op.  This is mostly to
   give an error, since XCOFF only supports .text, .data and .bss, but
   we do permit the user to name the text or data section.  */

static void
ppc_named_section (ignore)
     int ignore;
{
  char *user_name;
  const char *real_name;
  char c;
  symbolS *sym;

  user_name = input_line_pointer;
  c = get_symbol_end ();

  if (strcmp (user_name, ".text") == 0)
    real_name = ".text[PR]";
  else if (strcmp (user_name, ".data") == 0)
    real_name = ".data[RW]";
  else
    {
      as_bad (_("The XCOFF file format does not support arbitrary sections"));
      *input_line_pointer = c;
      ignore_rest_of_line ();
      return;
    }

  *input_line_pointer = c;

  sym = symbol_find_or_make (real_name);

  ppc_change_csect (sym);

  demand_empty_rest_of_line ();
}

d2537 1
a2537 1
  symbol_get_tc (sym)->output = 1;
d2563 1
a2563 1
      as_bad (_("missing rename string"));
d2569 1
a2569 1
  symbol_get_tc (sym)->real_name = demand_copy_C_string (&len);
d2594 1
a2594 1
      as_bad (_("missing value"));
d2603 1
a2603 1
  symbol_get_tc (sym)->real_name = name;
d2612 1
a2612 1
      as_bad (_("illegal .stabx expression; zero assumed"));
d2617 1
a2617 1
      symbol_set_frag (sym, &zero_address_frag);
d2622 1
a2622 1
	symbol_set_value_expression (sym, &exp);
d2627 1
a2627 1
	  symbol_set_frag (sym, symbol_get_frag (exp.X_add_symbol));
d2635 1
a2635 1
      symbol_set_value_expression (sym, &exp);
d2640 1
a2640 1
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
d2644 1
a2644 1
      as_bad (_("missing class"));
d2653 1
a2653 1
      as_bad (_("missing type"));
d2660 1
a2660 1
  symbol_get_tc (sym)->output = 1;
d2663 1
a2663 1
    symbol_get_tc (sym)->within = ppc_current_block;
d2673 2
a2674 2
      if (symbol_get_tc (ppc_current_csect)->within == exp.X_add_symbol)
	symbol_get_tc (ppc_current_csect)->within = sym;
d2714 1
a2714 1
      as_bad (_("missing symbol name"));
d2729 4
a2732 8
      expressionS exp;

      exp.X_op = O_symbol;
      exp.X_add_symbol = lab_sym;
      exp.X_op_symbol = NULL;
      exp.X_add_number = 0;
      exp.X_unsigned = 0;
      symbol_set_value_expression (ext_sym, &exp);
d2735 3
a2737 3
  if (symbol_get_tc (ext_sym)->class == -1)
    symbol_get_tc (ext_sym)->class = XMC_PR;
  symbol_get_tc (ext_sym)->output = 1;
d2755 5
a2759 5
	      symbol_get_tc (ext_sym)->size = symbol_new ("L0\001",
							  absolute_section,
							  (valueT) 0,
							  &zero_address_frag);
	      pseudo_set (symbol_get_tc (ext_sym)->size);
d2783 1
a2783 1
  symbol_set_frag (sym, frag_now);
d2792 1
a2792 1
  symbol_get_tc (sym)->output = 1;
d2811 1
a2811 1
  symbol_set_frag (sym, frag_now);
d2816 1
a2816 1
  symbol_get_tc (sym)->output = 1;
a2830 2
  static symbolS *last_biei;

d2848 1
a2848 1
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
d2851 1
a2851 1
  symbol_get_tc (sym)->output = 1;
d2853 1
a2853 1
  for (look = last_biei ? last_biei : symbol_rootP;
a2863 1
      last_biei = sym;
d2883 1
a2883 1
    as_bad (_("nested .bs blocks"));
d2895 2
a2896 2
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  symbol_get_tc (sym)->output = 1;
d2898 1
a2898 1
  symbol_get_tc (sym)->within = csect;
d2916 1
a2916 1
    as_bad (_(".es without preceding .bs"));
d2921 2
a2922 2
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
  symbol_get_tc (sym)->output = 1;
d2942 1
a2942 1
  symbol_set_frag (sym, frag_now);
d2949 1
a2949 1
  symbol_get_tc (sym)->output = 1;
d2969 1
a2969 1
  symbol_set_frag (sym, frag_now);
d2974 1
a2974 1
  symbol_get_tc (sym)->output = 1;
d2997 1
a2997 1
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
d3000 1
a3000 1
  symbol_get_tc (sym)->output = 1;
d3017 1
a3017 1
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING;
d3020 1
a3020 1
  symbol_get_tc (sym)->output = 1;
d3034 1
a3034 1
    subseg_set (data_section, symbol_get_tc (ppc_toc_csect)->subseg);
d3048 1
a3048 1
      symbol_set_frag (sym, frag_now);
d3051 3
a3053 3
      symbol_get_tc (sym)->subseg = subseg;
      symbol_get_tc (sym)->output = 1;
      symbol_get_tc (sym)->within = sym;
d3058 2
a3059 2
	   symbol_get_tc (list)->next != (symbolS *) NULL;
	   list = symbol_get_tc (list)->next)
d3061 1
a3061 1
      symbol_get_tc (list)->next = sym;
d3064 1
a3064 2
      symbol_append (sym, symbol_get_tc (list)->within, &symbol_rootP,
		     &symbol_lastP);
a3083 27
static void
ppc_vbyte (dummy)
     int dummy;
{
  expressionS exp;
  int byte_count;

  (void) expression (&exp);

  if (exp.X_op != O_constant)
    {
      as_bad (_("non-constant byte count"));
      return;
    }

  byte_count = exp.X_add_number;

  if (*input_line_pointer != ',')
    {
      as_bad (_("missing value"));
      return;
    }

  ++input_line_pointer;
  cons (byte_count);
}

d3100 1
a3100 1
     int ignore ATTRIBUTE_UNUSED;
d3113 1
a3113 1
	as_bad (_(".tc not in .toc section"));
d3129 2
a3130 2
	label = symbol_get_tc (ppc_current_csect)->within;
	if (symbol_get_tc (label)->class != XMC_TC0)
d3132 1
a3132 1
	    as_bad (_(".tc with no label"));
d3138 1
a3138 1
	symbol_set_frag (label, symbol_get_frag (sym));
d3148 1
a3148 1
    symbol_set_frag (sym, frag_now);
d3150 2
a3151 2
    symbol_get_tc (sym)->class = XMC_TC;
    symbol_get_tc (sym)->output = 1;
d3207 1
a3207 1
      as_warn(_("No previous section to return to. Directive ignored."));
d3452 1
a3452 1
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
d3460 1
a3460 1
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
d3476 1
a3476 1
	      as_warn (_("ignoring bad alignment"));
d3488 1
a3488 1
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
d3497 1
a3497 1
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
d3626 1
a3626 1
		  as_bad (_("Unsupported section attribute -- 'a'"));
d3696 1
a3696 1
		  as_bad(_("unknown section attribute '%c'"),
d3714 1
a3714 1
	as_bad (_("error setting flags for \"%s\": %s"),
d3816 1
a3816 1
	as_bad (_("bad symbol suffix"));
a3830 1
  struct ppc_tc_sy *tc;
d3833 8
a3840 9
  tc = symbol_get_tc (sym);
  tc->next = NULL;
  tc->output = 0;
  tc->class = -1;
  tc->real_name = NULL;
  tc->subseg = 0;
  tc->align = 0;
  tc->size = NULL;
  tc->within = NULL;
d3858 1
a3858 1
	tc->class = XMC_BS;
d3862 1
a3862 1
	tc->class = XMC_DB;
d3864 1
a3864 1
	tc->class = XMC_DS;
d3868 1
a3868 1
	tc->class = XMC_GL;
d3872 1
a3872 1
	tc->class = XMC_PR;
d3876 1
a3876 1
	tc->class = XMC_RO;
d3878 1
a3878 1
	tc->class = XMC_RW;
d3882 1
a3882 1
	tc->class = XMC_SV;
d3886 1
a3886 1
	tc->class = XMC_TC;
d3888 1
a3888 1
	tc->class = XMC_TI;
d3890 1
a3890 1
	tc->class = XMC_TB;
d3892 1
a3892 1
	tc->class = XMC_TC0;
d3896 1
a3896 1
	tc->class = XMC_UA;
d3898 1
a3898 1
	tc->class = XMC_UC;
d3902 1
a3902 1
	tc->class = XMC_XO;
d3906 2
a3907 2
  if (tc->class == -1)
    as_bad (_("Unrecognized symbol suffix"));
d3920 2
a3921 2
      if (symbol_get_tc (sym)->class == -1)
	symbol_get_tc (sym)->class = symbol_get_tc (ppc_current_csect)->class;
d3924 3
a3926 3
      symbol_append (sym, symbol_get_tc (ppc_current_csect)->within,
		     &symbol_rootP, &symbol_lastP);
      symbol_get_tc (ppc_current_csect)->within = sym;
d3950 2
a3951 2
  if (! symbol_used_in_reloc_p (sym)
      && ((symbol_get_bfdsym (sym)->flags & BSF_SECTION_SYM) != 0
d3953 1
a3953 1
	      && ! symbol_get_tc (sym)->output
d3957 2
a3958 2
  if (symbol_get_tc (sym)->real_name != (char *) NULL)
    S_SET_NAME (sym, symbol_get_tc (sym)->real_name);
d3989 1
a3989 1
	as_bad (_("two .function pseudo-ops with no intervening .ef"));
d3991 1
a3991 1
      if (symbol_get_tc (sym)->size != (symbolS *) NULL)
d3993 2
a3994 3
	  resolve_symbol_value (symbol_get_tc (sym)->size, 1);
	  SA_SET_SYM_FSIZE (sym,
			    (long) S_GET_VALUE (symbol_get_tc (sym)->size));
d4001 1
a4001 1
	as_bad (_(".ef with no preceding .function"));
d4014 1
a4014 1
      && (symbol_get_bfdsym (sym)->flags & BSF_SECTION_SYM) == 0
d4034 2
a4035 2
      a = &coffsymbol (symbol_get_bfdsym (sym))->native[i + 1].u.auxent;
      if (symbol_get_tc (sym)->class == XMC_TC0)
d4042 1
a4042 1
      else if (symbol_get_tc (sym)->subseg != 0)
d4046 1
a4046 1
	  if (symbol_get_tc (sym)->next == (symbolS *) NULL)
d4052 2
a4053 2
	      resolve_symbol_value (symbol_get_tc (sym)->next, 1);
	      a->x_csect.x_scnlen.l = (S_GET_VALUE (symbol_get_tc (sym)->next)
d4056 1
a4056 1
	  a->x_csect.x_smtyp = (symbol_get_tc (sym)->align << 3) | XTY_SD;
d4061 2
a4062 2
	  a->x_csect.x_scnlen.l = symbol_get_frag (sym)->fr_offset;
	  a->x_csect.x_smtyp = (symbol_get_tc (sym)->align << 3) | XTY_CM;
d4064 1
a4064 1
	    symbol_get_tc (sym)->class = XMC_RW;
d4066 1
a4066 1
	    symbol_get_tc (sym)->class = XMC_BS;
d4074 2
a4075 2
	  if (symbol_get_tc (sym)->class == -1)
	    symbol_get_tc (sym)->class = XMC_XO;
d4083 1
a4083 1
      else if (symbol_get_tc (sym)->class == XMC_TC)
d4090 1
a4090 1
	  while (symbol_get_tc (next)->class == XMC_TC0)
d4093 1
a4093 1
	      || symbol_get_tc (next)->class != XMC_TC)
d4105 1
a4105 1
	      resolve_symbol_value (next, 1);
d4125 1
a4125 1
	  csect = symbol_get_tc (csect)->next;
d4129 1
a4129 1
	      as_warn (_("warning: symbol %s has no csect"), S_GET_NAME (sym));
d4134 1
a4134 1
	      while (symbol_get_tc (csect)->next != (symbolS *) NULL)
d4136 2
a4137 3
		  resolve_symbol_value (symbol_get_tc (csect)->next, 1);
		  if (S_GET_VALUE (symbol_get_tc (csect)->next)
		      > S_GET_VALUE (sym))
d4139 1
a4139 1
		  csect = symbol_get_tc (csect)->next;
d4142 2
a4143 4
	      a->x_csect.x_scnlen.p =
		coffsymbol (symbol_get_bfdsym (csect))->native;
	      coffsymbol (symbol_get_bfdsym (sym))->native[i + 1].fix_scnlen =
		1;
d4150 1
a4150 1
      if (symbol_get_tc (sym)->class == -1)
d4153 1
a4153 1
	a->x_csect.x_smclas = symbol_get_tc (sym)->class;
d4158 1
a4158 1
      symbol_get_bfdsym (sym)->flags |= BSF_NOT_AT_END;
d4166 2
a4167 4
		   ((valueT)
		    coffsymbol (symbol_get_bfdsym
				(symbol_get_tc (sym)->within))->native));
      coffsymbol (symbol_get_bfdsym (sym))->native->fix_value = 1;
d4175 3
a4177 3
      block = symbol_get_tc (sym)->within;
      csect = symbol_get_tc (block)->within;
      resolve_symbol_value (csect, 1);
d4186 1
a4186 1
      coffsymbol (symbol_get_bfdsym (sym))->native->fix_line = 1;
d4214 1
a4214 1
      symbol_get_bfdsym (csect)->value = S_GET_VALUE (sym);
d4218 1
a4218 1
      a = &coffsymbol (symbol_get_bfdsym (csect))->native[i + 1].u.auxent;
d4230 3
a4232 3
      a = &coffsymbol (symbol_get_bfdsym (sym))->native[i].u.auxent;
      a->x_csect.x_scnlen.p = coffsymbol (symbol_get_bfdsym (csect))->native;
      coffsymbol (symbol_get_bfdsym (sym))->native[i].fix_scnlen = 1;
d4281 1
a4281 1
      return _("bad call to md_atof");
d4341 2
a4342 2
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
d4352 3
a4354 3
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragp ATTRIBUTE_UNUSED;
d4364 1
a4364 1
     char *name ATTRIBUTE_UNUSED;
d4377 1
a4377 1
     segT sec ATTRIBUTE_UNUSED;
d4379 7
d4402 1
a4402 1
  resolve_symbol_value (fix->fx_addsy, 1);
d4418 1
a4418 1
	  if (symbol_get_tc (sy)->class == XMC_TC0)
d4420 1
a4420 1
	  if (symbol_get_tc (sy)->class != XMC_TC)
d4422 1
a4422 1
	  resolve_symbol_value (sy, 1);
d4432 1
a4432 1
		    _("symbol in .toc does not match any .tc"));
d4437 4
a4440 10
      && symbol_get_tc (fix->fx_addsy)->subseg == 0
      && symbol_get_tc (fix->fx_addsy)->class != XMC_TC0
      && symbol_get_tc (fix->fx_addsy)->class != XMC_TC
      && S_GET_SEGMENT (fix->fx_addsy) != bss_section
      /* Don't adjust if this is a reloc in the toc section.  */
      && (S_GET_SEGMENT (fix->fx_addsy) != data_section
	  || ppc_toc_csect == NULL
	  || val < ppc_toc_frag->fr_address
	  || (ppc_after_toc_frag != NULL
	      && val >= ppc_after_toc_frag->fr_address)))
d4452 1
a4452 1
      csect = symbol_get_tc (csect)->next;
d4456 4
a4459 31
	  while (symbol_get_tc (csect)->next != (symbolS *) NULL
		 && (symbol_get_frag (symbol_get_tc (csect)->next)->fr_address
		     <= val))
	    {
	      /* If the csect address equals the symbol value, then we
                 have to look through the full symbol table to see
                 whether this is the csect we want.  Note that we will
                 only get here if the csect has zero length.  */
	      if ((symbol_get_frag (csect)->fr_address == val)
		  && S_GET_VALUE (csect) == S_GET_VALUE (fix->fx_addsy))
		{
		  symbolS *scan;

		  for (scan = symbol_next (csect);
		       scan != NULL;
		       scan = symbol_next (scan))
		    {
		      if (symbol_get_tc (scan)->subseg != 0)
			break;
		      if (scan == fix->fx_addsy)
			break;
		    }

		  /* If we found the symbol before the next csect
                     symbol, then this is the csect we want.  */
		  if (scan == fix->fx_addsy)
		    break;
		}

	      csect = symbol_get_tc (csect)->next;
	    }
d4462 1
a4462 1
			     - symbol_get_frag (csect)->fr_address);
d4473 4
a4476 5
      resolve_symbol_value (symbol_get_frag (fix->fx_addsy)->fr_symbol, 1);
      fix->fx_offset +=
	(S_GET_VALUE (fix->fx_addsy)
	 - S_GET_VALUE (symbol_get_frag (fix->fx_addsy)->fr_symbol));
      fix->fx_addsy = symbol_get_frag (fix->fx_addsy)->fr_symbol;
d4496 4
a4499 5
      && symbol_get_tc (fix->fx_addsy)->subseg != 0
      && ((symbol_get_frag (fix->fx_addsy)->fr_address
	   > fix->fx_frag->fr_address)
	  || (symbol_get_tc (fix->fx_addsy)->next != NULL
	      && (symbol_get_frag (symbol_get_tc (fix->fx_addsy)->next)->fr_address
d4515 1
a4515 1
  return symbol_get_tc (sym)->class == XMC_TC;
a4537 23
#ifdef OBJ_ELF
  value = *valuep;
  if (fixp->fx_addsy != NULL)
    {
      /* `*valuep' may contain the value of the symbol on which the reloc
	 will be based; we have to remove it.  */
      if (symbol_used_in_reloc_p (fixp->fx_addsy)
	  && S_GET_SEGMENT (fixp->fx_addsy) != absolute_section
	  && S_GET_SEGMENT (fixp->fx_addsy) != undefined_section
	  && ! bfd_is_com_section (S_GET_SEGMENT (fixp->fx_addsy)))
	value -= S_GET_VALUE (fixp->fx_addsy);

      /* FIXME: Why '+'?  Better yet, what exactly is '*valuep'
	 supposed to be?  I think this is related to various similar
	 FIXMEs in tc-i386.c and tc-sparc.c.  */
      if (fixp->fx_pcrel)
	value += fixp->fx_frag->fr_address + fixp->fx_where;
    }
  else
    {
      fixp->fx_done = 1;
    }
#else
d4548 1
d4567 1
a4567 1
			    _("expression too complex"));
a4570 1
#endif
d4596 3
a4598 3
	  && symbol_get_tc (fixp->fx_addsy)->subseg != 0
	  && symbol_get_tc (fixp->fx_addsy)->class != XMC_TC
	  && symbol_get_tc (fixp->fx_addsy)->class != XMC_TC0
d4669 1
a4669 1
			  _("unresolved expression that must be resolved"));
d4672 1
a4672 1
			  _("unsupported relocation type"));
d4699 2
d4725 7
a4731 11
	    {
	      if (fixp->fx_addsy != NULL)
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("cannot emit PC relative %s relocation against %s"),
			      bfd_get_reloc_code_name (fixp->fx_r_type),
			      S_GET_NAME (fixp->fx_addsy));
	      else
		as_bad_where (fixp->fx_file, fixp->fx_line,
			      _("cannot emit PC relative %s relocation"),
			      bfd_get_reloc_code_name (fixp->fx_r_type));
	    }
a4736 16
	  /* This case happens when you write, for example,
	     lis %r3,(L1-L2)@@ha
	     where L1 and L2 are defined later.  */
	case BFD_RELOC_HI16:
	  if (fixp->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
			      value >> 16, 2);
	  break;
	case BFD_RELOC_HI16_S:
	  if (fixp->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
			      (value + 0x8000) >> 16, 2);
	  break;

d4758 1
a4758 1
	  if (!fixp->fx_pcrel && !fixp->fx_done)
a4760 38
	  if (fixp->fx_done)
	  {
	    char *where;
	    unsigned long insn;
	    
	    /* Fetch the instruction, insert the fully resolved operand
	       value, and stuff the instruction back again.  */
	    where = fixp->fx_frag->fr_literal + fixp->fx_where;
	    if (target_big_endian)
	      insn = bfd_getb32 ((unsigned char *) where);
	    else
	      insn = bfd_getl32 ((unsigned char *) where);
	    if ((value & 3) != 0)
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("must branch to an address a multiple of 4"));
	    if ((offsetT) value < -0x40000000
		|| (offsetT) value >= 0x40000000)
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("@@local or @@plt branch destination is too far away, %ld bytes"),
			    value);
	    insn = insn | (value & 0x03fffffc);
	    if (target_big_endian)
	      bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	    else
	      bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
	  }
	  break;

	case BFD_RELOC_VTABLE_INHERIT:
	  fixp->fx_done = 0;
	  if (fixp->fx_addsy
	      && !S_IS_DEFINED (fixp->fx_addsy)
	      && !S_IS_WEAK (fixp->fx_addsy))
	    S_SET_WEAK (fixp->fx_addsy);
	  break;

	case BFD_RELOC_VTABLE_ENTRY:
	  fixp->fx_done = 0;
d4765 1
a4765 1
		  _("Gas failure, reloc value %d\n"), fixp->fx_r_type);
d4796 1
a4796 1
     asection *seg ATTRIBUTE_UNUSED;
d4803 1
a4803 2
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
d4809 1
a4809 1
		    _("reloc %d not supported by object file format"), (int)fixp->fx_r_type);
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d21 1
a21 1
   02111-1307, USA.  */
a31 1
#include "dwarf2dbg.h"
a88 1
static void ppc_machine PARAMS ((int));
a184 1
  { "llong",	ppc_xcoff_cons,	3 },
a187 1
  { "machine",  ppc_machine,    0 },
a196 2
  { "file",	dwarf2_directive_file, 0 },
  { "loc",	dwarf2_directive_loc, 0 },
d239 1
a243 4
   Each vector unit register has predefined names of the form:
   1. v<reg_num> which has the value <reg_num>.
   2. v.<reg_num> which has the value <reg_num>.

d263 1
a263 1
   The table is sorted. Suitable for searching by a binary search.  */
d292 23
a314 23
  { "f.1", 1 },
  { "f.10", 10 },
  { "f.11", 11 },
  { "f.12", 12 },
  { "f.13", 13 },
  { "f.14", 14 },
  { "f.15", 15 },
  { "f.16", 16 },
  { "f.17", 17 },
  { "f.18", 18 },
  { "f.19", 19 },
  { "f.2", 2 },
  { "f.20", 20 },
  { "f.21", 21 },
  { "f.22", 22 },
  { "f.23", 23 },
  { "f.24", 24 },
  { "f.25", 25 },
  { "f.26", 26 },
  { "f.27", 27 },
  { "f.28", 28 },
  { "f.29", 29 },
  { "f.3", 3 },
d317 31
a347 31
  { "f.4", 4 },
  { "f.5", 5 },
  { "f.6", 6 },
  { "f.7", 7 },
  { "f.8", 8 },
  { "f.9", 9 },

  { "f0", 0 },
  { "f1", 1 },
  { "f10", 10 },
  { "f11", 11 },
  { "f12", 12 },
  { "f13", 13 },
  { "f14", 14 },
  { "f15", 15 },
  { "f16", 16 },
  { "f17", 17 },
  { "f18", 18 },
  { "f19", 19 },
  { "f2", 2 },
  { "f20", 20 },
  { "f21", 21 },
  { "f22", 22 },
  { "f23", 23 },
  { "f24", 24 },
  { "f25", 25 },
  { "f26", 26 },
  { "f27", 27 },
  { "f28", 28 },
  { "f29", 29 },
  { "f3", 3 },
d350 6
a355 6
  { "f4", 4 },
  { "f5", 5 },
  { "f6", 6 },
  { "f7", 7 },
  { "f8", 8 },
  { "f9", 9 },
a441 66
  { "v.0", 0 },     /* Vector registers */
  { "v.1", 1 },
  { "v.10", 10 },
  { "v.11", 11 },
  { "v.12", 12 },
  { "v.13", 13 },
  { "v.14", 14 },
  { "v.15", 15 },
  { "v.16", 16 },
  { "v.17", 17 },
  { "v.18", 18 },
  { "v.19", 19 },
  { "v.2", 2 },
  { "v.20", 20 },
  { "v.21", 21 },
  { "v.22", 22 },
  { "v.23", 23 },
  { "v.24", 24 },
  { "v.25", 25 },
  { "v.26", 26 },
  { "v.27", 27 },
  { "v.28", 28 },
  { "v.29", 29 },
  { "v.3", 3 },
  { "v.30", 30 },
  { "v.31", 31 },
  { "v.4", 4 },
  { "v.5", 5 },
  { "v.6", 6 },
  { "v.7", 7 },
  { "v.8", 8 },
  { "v.9", 9 },

  { "v0", 0 },
  { "v1", 1 },
  { "v10", 10 },
  { "v11", 11 },
  { "v12", 12 },
  { "v13", 13 },
  { "v14", 14 },
  { "v15", 15 },
  { "v16", 16 },
  { "v17", 17 },
  { "v18", 18 },
  { "v19", 19 },
  { "v2", 2 },
  { "v20", 20 },
  { "v21", 21 },
  { "v22", 22 },
  { "v23", 23 },
  { "v24", 24 },
  { "v25", 25 },
  { "v26", 26 },
  { "v27", 27 },
  { "v28", 28 },
  { "v29", 29 },
  { "v3", 3 },
  { "v30", 30 },
  { "v31", 31 },
  { "v4", 4 },
  { "v5", 5 },
  { "v6", 6 },
  { "v7", 7 },
  { "v8", 8 },
  { "v9", 9 },

d446 1
a446 1
#define REG_NAME_CNT	(sizeof (pre_defined_registers) / sizeof (struct pd_reg))
d515 1
a515 1
  if (reg_number >= 0)
d519 1
a519 1

a593 3
/* Whether to target xcoff64 */
static int ppc_xcoff64 = 0;

d602 1
a602 1
static enum { SHLIB_NONE, SHLIB_PIC, SHLIB_MRELOCATABLE } shlib = SHLIB_NONE;
d673 1
a673 1
/* The current section and the previous section. See ppc_previous.  */
d691 1
a691 1
size_t md_longopts_size = sizeof (md_longopts);
a742 10
      /* a64 and a32 determine whether to use XCOFF64 or XCOFF32.  */
    case 'a':
      if (strcmp (arg, "64") == 0)
	ppc_xcoff64 = 1;
      else if (strcmp (arg, "32") == 0)
	ppc_xcoff64 = 0;
      else
	return 0;
      break;

d752 1
a752 1
         instructions that are holdovers from the Power.  */
a759 1
	       || strcmp (arg, "405") == 0
a762 2
      else if (strcmp (arg, "7400") == 0)
        ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC;
d794 1
a794 1
	  shlib = SHLIB_MRELOCATABLE;
d800 1
a800 1
	  shlib = SHLIB_MRELOCATABLE;
d872 1
a872 1
  fprintf (stream, _("\
d878 1
a878 1
-mppc, -mppc32, -m403, -m405, -m603, -m604\n\
d887 1
a887 1
  fprintf (stream, _("\
a950 31
unsigned long
ppc_mach ()
{
  return (ppc_size == PPC_OPCODE_64) ? 620 : 0;
}

int
ppc_subseg_align()
{
  return (ppc_xcoff64) ? 3 : 2;
}

extern char*
ppc_target_format()
{
#ifdef OBJ_COFF
#ifdef TE_PE
  return (target_big_endian ? "pe-powerpc" : "pe-powerpcle");
#elif TE_POWERMAC
#else
  return (ppc_xcoff64 ? "aixcoff64-rs6000" : "aixcoff-rs6000");
#endif
#ifdef TE_POWERMAC
  return "xcoff-powermac";
#endif
#endif
#ifdef OBJ_ELF
  return (target_big_endian ? "elf32-powerpc" : "elf32-powerpcle");
#endif
}

d967 1
a967 1
  /* Set the ELF flags if desired.  */
d1045 1
a1045 1
  ppc_previous_section = 0;
d1150 1
a1150 1
#define MAP(str,reloc) { str, sizeof (str)-1, reloc }
d1251 1
a1251 1
/* Like normal .long/.short/.word, except support @@got, etc.  */
d1253 1
a1253 1
/* end-of-line.  */
d1293 1
a1293 1
  input_line_pointer--;		/* Put terminator back into stream.  */
d1437 1
a1437 1
    case SHLIB_MRELOCATABLE:
d1479 1
a1479 1
 * out:
d1495 2
a1496 2
enum toc_size_qualifier
{
d1518 1
a1518 1

d1523 1
a1523 1
  if (strcmp(toc_spec, "toc") == 0)
d1527 1
a1527 1
  else if (strcmp(toc_spec, "tocv") == 0)
d1531 1
a1531 1
  else if (strcmp(toc_spec, "toc32") == 0)
d1535 1
a1535 1
  else if (strcmp(toc_spec, "toc64") == 0)
d1550 2
a1551 2
  SKIP_WHITESPACE ();	     /* leading whitespace could be there.  */
  c = *input_line_pointer++; /* input_line_pointer->past char in c.  */
d1724 1
a1724 1
      if (*input_line_pointer == '[')
d1730 1
a1730 1
	     The argument following the `]' must be a symbol name, and the
d1758 1
a1758 1
	  if (!valid_toc)
d1784 2
a1785 2
	      if (ex.X_op == O_symbol)
		{
d1809 1
a1809 1
	      fprintf (stderr,
d1812 1
a1812 1
	      abort ();
d1861 1
a1861 1
	  /* Allow @@HA, @@L, @@H on constants.  */
a1980 4
#ifdef OBJ_ELF
  dwarf2_emit_insn (4);
#endif

d2006 1
a2006 1
	    abort ();
d2067 1
a2067 1
    }
d2114 1
a2114 1
}
d2299 1
a2299 1

d2316 1
a2316 1

d2318 1
a2318 1

d2340 1
a2340 1

d2380 1
a2380 1
     int ignore ATTRIBUTE_UNUSED;
d2388 1
a2388 1

d2481 1
a2481 1
      symbol_get_tc (sym)->align = (ppc_xcoff64) ? 3 : 2;
d2484 1
a2484 1

d2490 1
a2490 1

d2530 1
a2530 1
     int ignore ATTRIBUTE_UNUSED;
d2565 1
a2565 1
     int ignore ATTRIBUTE_UNUSED;
d2584 1
a2584 1
     int ignore ATTRIBUTE_UNUSED;
d2607 1
a2607 1
     int ignore ATTRIBUTE_UNUSED;
d2643 1
a2643 1
     int ignore ATTRIBUTE_UNUSED;
d2722 1
a2722 2
  if (S_GET_STORAGE_CLASS (sym) == C_STSYM) {
	  
a2724 19
    /* In this case :
      
       .bs name
       .stabx	"z",arrays_,133,0
       .es
       
       .comm arrays_,13768,3
       
       resolve_symbol_value will copy the exp's "within" into sym's when the
       offset is 0.  Since this seems to be corner case problem,
       only do the correction for storage class C_STSYM.  A better solution
       would be to have the tc	field updated in ppc_symbol_new_hook. */
    
    if (exp.X_op == O_symbol) 
      {
	symbol_get_tc (exp.X_add_symbol)->within = ppc_current_block;
      }
  }

d2750 1
a2750 1
     int ignore ATTRIBUTE_UNUSED;
d2841 1
a2841 1
     int ignore ATTRIBUTE_UNUSED;
d2869 1
a2869 1
     int ignore ATTRIBUTE_UNUSED;
d2918 1
a2918 1

d2942 1
a2942 1
     int ignore ATTRIBUTE_UNUSED;
d2978 1
a2978 1
     int ignore ATTRIBUTE_UNUSED;
d3003 1
a3003 1
     int ignore ATTRIBUTE_UNUSED;
d3030 1
a3030 1
     int ignore ATTRIBUTE_UNUSED;
d3055 1
a3055 1
     int ignore ATTRIBUTE_UNUSED;
d3078 1
a3078 1
     int ignore ATTRIBUTE_UNUSED;
d3098 1
a3098 1
     int ignore ATTRIBUTE_UNUSED;
d3107 1
a3107 1

d3123 1
a3123 1

a3152 8
ppc_machine(dummy)
    int dummy ATTRIBUTE_UNUSED;
{
    discard_rest_of_line();
   /* What does aix use this for?  */
}

static void
d3154 1
a3154 1
     int dummy ATTRIBUTE_UNUSED;
d3272 1
a3272 1
      cons ((ppc_size == PPC_OPCODE_64) ? 8 : 4);
d3296 1
a3296 1
     int ignore ATTRIBUTE_UNUSED;
d3300 1
a3300 1
  if (ppc_previous_section == NULL)
d3329 1
a3329 1
     int ignore ATTRIBUTE_UNUSED;
d3331 1
a3331 1
  if (pdata_section == 0)
d3334 1
a3334 1

d3338 1
a3338 1

d3364 1
a3364 1
     int ignore ATTRIBUTE_UNUSED;
d3366 1
a3366 1
  if (ydata_section == 0)
d3401 1
a3401 1
     int ignore ATTRIBUTE_UNUSED;
d3408 1
a3408 1
			     ( SEC_ALLOC | SEC_LOAD | SEC_RELOC
d3432 1
a3432 1
     int ignore ATTRIBUTE_UNUSED;
d3451 1
a3451 1
   behaviour: much like .int, with the exception that no alignment is
d3459 1
a3459 1
     int ignore ATTRIBUTE_UNUSED;
d3474 1
a3474 1
     int ignore ATTRIBUTE_UNUSED;
d3522 4
a3525 4
/* pseudo-op:
   behaviour:
   errors:
   warnings:
d3625 1
a3625 1
 * FIXME: I just noticed this. This doesn't work at all really. It it
d3658 1
a3658 1
     int ignore ATTRIBUTE_UNUSED;
d3724 1
a3724 1
		  flags |= SEC_CODE;
d3740 1
a3740 1
		  flags &=~ SEC_LOAD;
d3820 1
a3820 1
     int ignore ATTRIBUTE_UNUSED;
d3843 1
a3843 1
     int ignore ATTRIBUTE_UNUSED;
d4248 1
a4248 1

d4357 2
a4358 2
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
d4409 1
a4409 1

d4464 1
d4805 1
a4851 8
	case BFD_RELOC_64:
	  if (fixp->fx_pcrel)
	    fixp->fx_r_type = BFD_RELOC_64_PCREL;
					/* fall through */
	case BFD_RELOC_64_PCREL:
	  md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
			      value, 8);
	  break;
d4937 1
a4937 1

d4974 1
a4974 1
	  fprintf (stderr,
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d24 1
a25 1
#include "safe-ctype.h"
d50 1
a50 1
#define TARGET_REG_NAMES_P TRUE
d52 1
a52 1
#define TARGET_REG_NAMES_P FALSE
d56 1
a56 2
/* Macros for calculating LO, HI, HA, HIGHER, HIGHERA, HIGHEST,
   HIGHESTA.  */
d58 1
a58 30
/* #lo(value) denotes the least significant 16 bits of the indicated.  */
#define PPC_LO(v) ((v) & 0xffff)

/* #hi(value) denotes bits 16 through 31 of the indicated value.  */
#define PPC_HI(v) (((v) >> 16) & 0xffff)

/* #ha(value) denotes the high adjusted value: bits 16 through 31 of
  the indicated value, compensating for #lo() being treated as a
  signed number.  */
#define PPC_HA(v) PPC_HI ((v) + 0x8000)

/* #higher(value) denotes bits 32 through 47 of the indicated value.  */
#define PPC_HIGHER(v) (((v) >> 16 >> 16) & 0xffff)

/* #highera(value) denotes bits 32 through 47 of the indicated value,
   compensating for #lo() being treated as a signed number.  */
#define PPC_HIGHERA(v) PPC_HIGHER ((v) + 0x8000)

/* #highest(value) denotes bits 48 through 63 of the indicated value.  */
#define PPC_HIGHEST(v) (((v) >> 24 >> 24) & 0xffff)

/* #highesta(value) denotes bits 48 through 63 of the indicated value,
   compensating for #lo being treated as a signed number.  */
#define PPC_HIGHESTA(v) PPC_HIGHEST ((v) + 0x8000)

#define SEX16(val) ((((val) & 0xffff) ^ 0x8000) - 0x8000)

static bfd_boolean reg_names_p = TARGET_REG_NAMES_P;

static bfd_boolean register_name PARAMS ((expressionS *));
a64 2

#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
a66 2
static void ppc_machine PARAMS ((int));
#endif
d90 1
a99 1
static void ppc_apuinfo_section_add PARAMS ((unsigned int apu, unsigned int version));
d191 1
a194 2
  { "llong",	ppc_elf_cons,	8 },
  { "quad",	ppc_elf_cons,	8 },
d201 1
a201 1
  { "file",	(void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
d206 1
a206 1
  /* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format.  */
d221 1
a221 1
#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
a222 2
  { "machine",  ppc_machine,    0 },
#endif
d228 3
a230 3
/* Predefined register names if -mregnames (or default for Windows NT).
   In general, there are lots of them, in an attempt to be compatible
   with a number of other Windows NT assemblers.  */
d558 1
a558 1
 * Summary of register_name.
d569 1
a569 1
static bfd_boolean
d578 1
a578 1
  /* Find the spelling of the operand.  */
d580 1
a580 1
  if (name[0] == '%' && ISALPHA (name[1]))
d583 2
a584 2
  else if (!reg_names_p || !ISALPHA (name[0]))
    return FALSE;
d589 1
a589 4
  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
d595 1
a595 1
      /* Make the rest nice.  */
d598 9
a606 1
      return TRUE;
a607 4

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
d615 1
a615 1
static bfd_boolean cr_operand;
d663 5
a667 1
static unsigned long ppc_cpu = 0;
d669 2
a670 2
/* Whether to target xcoff64/elf64.  */
static unsigned int ppc_obj64 = BFD_DEFAULT_TARGET_SIZE == 64;
d679 1
a679 1
/* What type of shared library support to use.  */
d682 1
a682 1
/* Flags to set in the elf header.  */
d687 1
a687 1
#define SOLARIS_P TRUE
d689 1
a689 1
#define SOLARIS_P FALSE
d692 1
a692 1
static bfd_boolean msolaris = SOLARIS_P;
a758 14
#define PPC_APUINFO_ISEL	0x40
#define PPC_APUINFO_PMR		0x41
#define PPC_APUINFO_RFMCI	0x42
#define PPC_APUINFO_CACHELCK	0x43
#define PPC_APUINFO_SPE		0x100
#define PPC_APUINFO_EFS		0x101
#define PPC_APUINFO_BRLOCK	0x102

/*
 * We keep a list of APUinfo
 */
unsigned long *ppc_apuinfo_list;
unsigned int ppc_apuinfo_num;
unsigned int ppc_apuinfo_num_alloc;
d762 1
a762 1
const char *const md_shortopts = "b:l:usm:K:VQ:";
d764 1
a764 1
const char *const md_shortopts = "um:";
d766 1
a766 1
const struct option md_longopts[] = {
d769 1
a769 1
const size_t md_longopts_size = sizeof (md_longopts);
d786 1
a786 1
	 sake, recognize -be also.  */
d809 1
a809 1
      /* Recognize -K PIC.  */
d824 1
a824 7
	{
#ifdef BFD64
	  ppc_obj64 = 1;
#else
	  as_fatal (_("%s unsupported"), "-a64");
#endif
	}
d826 1
a826 1
	ppc_obj64 = 0;
d833 1
a833 1
	 (RIOS2).  */
d835 1
a835 1
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_POWER2 | PPC_OPCODE_32;
d838 3
a840 3
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
      /* -m601 means to assemble for the PowerPC 601, which includes
	 instructions that are holdovers from the Power.  */
d842 1
a842 2
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		   | PPC_OPCODE_601 | PPC_OPCODE_32);
d844 1
a844 1
	 PowerPC 603/604.  */
d847 2
d851 3
a853 33
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
      /* -m403 and -m405 mean to assemble for the PowerPC 403/405.  */
      else if (strcmp (arg, "403") == 0
	       || strcmp (arg, "405") == 0)
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		   | PPC_OPCODE_403 | PPC_OPCODE_32);
      else if (strcmp (arg, "7400") == 0
	       || strcmp (arg, "7410") == 0
	       || strcmp (arg, "7450") == 0
	       || strcmp (arg, "7455") == 0)
	ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		   | PPC_OPCODE_ALTIVEC | PPC_OPCODE_32);
      else if (strcmp (arg, "altivec") == 0)
	{
	  if (ppc_cpu == 0)
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_ALTIVEC;
	  else
	    ppc_cpu |= PPC_OPCODE_ALTIVEC;
	}
      else if (strcmp (arg, "e500") == 0 || strcmp (arg, "e500x2") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
		     | PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
		     | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
		     | PPC_OPCODE_RFMCI);
	}
      else if (strcmp (arg, "spe") == 0)
	{
	  if (ppc_cpu == 0)
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_SPE | PPC_OPCODE_EFS;
	  else
	    ppc_cpu |= PPC_OPCODE_SPE;
	}
d855 1
a855 1
	 620.  */
d858 2
a859 1
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
d863 2
a864 18
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		     | PPC_OPCODE_64_BRIDGE | PPC_OPCODE_64);
	}
      /* -mbooke/-mbooke32 mean enable 32-bit BookE support.  */
      else if (strcmp (arg, "booke") == 0 || strcmp (arg, "booke32") == 0)
	{
	  ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32;
	}
      /* -mbooke64 means enable 64-bit BookE support.  */
      else if (strcmp (arg, "booke64") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE
		     | PPC_OPCODE_BOOKE64 | PPC_OPCODE_64);
	}
      else if (strcmp (arg, "power4") == 0)
	{
	  ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		     | PPC_OPCODE_64 | PPC_OPCODE_POWER4);
d870 1
a870 1
	ppc_cpu = PPC_OPCODE_COMMON | PPC_OPCODE_32;
d873 1
a873 1
	ppc_cpu = PPC_OPCODE_ANY | PPC_OPCODE_32;
d876 1
a876 1
	reg_names_p = TRUE;
d879 1
a879 1
	reg_names_p = FALSE;
d882 1
a882 2
      /* -mrelocatable/-mrelocatable-lib -- warn about initializations
	 that require relocation.  */
d895 1
a895 1
      /* -memb, set embedded bit.  */
d899 2
a900 3
      /* -mlittle/-mbig set the endianess.  */
      else if (strcmp (arg, "little") == 0
	       || strcmp (arg, "little-endian") == 0)
d914 1
a914 1
	  msolaris = TRUE;
d920 1
a920 1
	  msolaris = FALSE;
d966 6
a971 9
-mpwrx, -mpwr2		generate code for POWER/2 (RIOS2)\n\
-mpwr			generate code for POWER (RIOS1)\n\
-m601			generate code for PowerPC 601\n\
-mppc, -mppc32, -m603, -m604\n\
			generate code for PowerPC 603/604\n\
-m403, -m405            generate code for PowerPC 403/405\n\
-m7400, -m7410, -m7450, -m7455\n\
			generate code For PowerPC 7400/7410/7450/7455\n\
-mppc64, -m620		generate code for PowerPC 620/625/630\n\
a972 4
-mbooke64		generate code for 64-bit PowerPC BookE\n\
-mbooke, mbooke32	generate code for 32-bit PowerPC BookE\n\
-mpower4		generate code for Power4 architecture\n\
-maltivec		generate code for AltiVec\n\
a976 3
  fprintf (stream, _("\
-me500, -me500x2	generate code for Motorola e500 core complex\n\
-mspe			generate code for Motorola SPE instructions\n"));
d1002 3
a1004 5
      if (ppc_obj64)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
      else if (strncmp (default_os, "aix", 3) == 0
	       && default_os[3] >= '4' && default_os[3] <= '9')
	ppc_cpu = PPC_OPCODE_COMMON | PPC_OPCODE_32;
d1006 1
a1006 1
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
d1008 4
a1011 8
	ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
      else if (strncmp (default_cpu, "powerpc", 7) == 0)
	{
	  if (default_cpu[7] == '6' && default_cpu[8] == '4')
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
	  else
	    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
	}
d1013 1
a1013 2
	as_fatal (_("Unknown default cpu = %s, os = %s"),
		  default_cpu, default_os);
d1033 2
a1034 1
      else if (strncmp (default_cpu, "powerpc", 7) == 0)
d1045 7
a1051 6
  if (ppc_obj64)
    return bfd_mach_ppc64;
  else if (ppc_arch () == bfd_arch_rs6000)
    return bfd_mach_rs6k;
  else
    return bfd_mach_ppc;
d1055 1
a1055 1
ppc_target_format ()
d1059 1
a1059 1
  return target_big_endian ? "pe-powerpc" : "pe-powerpcle";
d1061 4
a1065 6
#else
#  ifdef TE_AIX5
    return (ppc_obj64 ? "aix5coff64-rs6000" : "aixcoff-rs6000");
#  else
    return (ppc_obj64 ? "aixcoff64-rs6000" : "aixcoff-rs6000");
#  endif
d1069 1
a1069 3
  return (target_big_endian
	  ? (ppc_obj64 ? "elf64-powerpc" : "elf32-powerpc")
	  : (ppc_obj64 ? "elf64-powerpcle" : "elf32-powerpcle"));
d1084 1
a1084 1
  bfd_boolean dup_insn = FALSE;
d1102 1
a1102 1
      if ((op->flags & ppc_cpu & ~(PPC_OPCODE_32 | PPC_OPCODE_64)) != 0
d1104 2
a1105 14
	      || ((op->flags & (PPC_OPCODE_32 | PPC_OPCODE_64))
		  == (ppc_cpu & (PPC_OPCODE_32 | PPC_OPCODE_64)))
	      || (ppc_cpu & PPC_OPCODE_64_BRIDGE) != 0)
	  /* Certain instructions (eg: extsw) do not exist in the
	     32-bit BookE instruction set, but they do exist in the
	     64-bit BookE instruction set, and other PPC instruction
	     sets.  Check to see if the opcode has the BOOKE64 flag set.
	     If it does make sure that the target CPU is not the BookE32.  */
	  && ((op->flags & PPC_OPCODE_BOOKE64) == 0
	      || (ppc_cpu & PPC_OPCODE_BOOKE64) == PPC_OPCODE_BOOKE64
	      || (ppc_cpu & PPC_OPCODE_BOOKE) == 0)
	  && ((op->flags & (PPC_OPCODE_POWER4 | PPC_OPCODE_NOPOWER4)) == 0
	      || ((op->flags & PPC_OPCODE_POWER4)
		  == (ppc_cpu & PPC_OPCODE_POWER4))))
d1112 1
a1112 1
	      /* Ignore Power duplicates for -m601.  */
d1117 2
a1118 3
	      as_bad (_("Internal assembler error for instruction %s"),
		      op->name);
	      dup_insn = TRUE;
d1137 1
a1137 1
	      dup_insn = TRUE;
d1145 1
a1145 2
  /* Tell the main code what the endianness is if it is not overidden
     by the user.  */
a1171 60
void
ppc_cleanup ()
{
#ifdef OBJ_ELF
  if (ppc_apuinfo_list == NULL)
    return;

  /* Ok, so write the section info out.  We have this layout:

  byte	data		what
  ----	----		----
  0	8		length of "APUinfo\0"
  4	(n*4)		number of APU's (4 bytes each)
  8	2		note type 2
  12	"APUinfo\0"	name
  20	APU#1		first APU's info
  24	APU#2		second APU's info
  ...	...
  */
  {
    char *p;
    asection *seg = now_seg;
    subsegT subseg = now_subseg;
    asection *apuinfo_secp = (asection *) NULL;
    unsigned int i;

    /* Create the .PPC.EMB.apuinfo section.  */
    apuinfo_secp = subseg_new (".PPC.EMB.apuinfo", 0);
    bfd_set_section_flags (stdoutput,
			   apuinfo_secp,
			   SEC_HAS_CONTENTS | SEC_READONLY);

    p = frag_more (4);
    md_number_to_chars (p, (valueT) 8, 4);

    p = frag_more (4);
    md_number_to_chars (p, (valueT) ppc_apuinfo_num, 4);

    p = frag_more (4);
    md_number_to_chars (p, (valueT) 2, 4);

    p = frag_more (8);
    strcpy (p, "APUinfo");

    for (i = 0; i < ppc_apuinfo_num; i++)
      {
	p = frag_more (4);
	md_number_to_chars (p, (valueT) ppc_apuinfo_list[i], 4);
      }

    frag_align (2, 0, 0);

    /* We probably can't restore the current segment, for there likely
       isn't one yet...  */
    if (seg && subseg)
      subseg_set (seg, subseg);
  }
#endif
}

d1195 1
a1195 1
	  if (!ppc_obj64)
d1228 4
a1231 1
	  as_bad_where (file, line, err, buf, min, max);
d1240 1
a1240 1
      insn = (*operand->insert) (insn, (long) val, ppc_cpu, &errmsg);
d1242 1
a1242 1
	as_bad_where (file, line, errmsg);
d1262 1
a1262 1
    int reloc;
d1270 1
a1270 1
  const struct map_bfd *ptr;
d1274 45
a1318 89
  static const struct map_bfd mapping[] = {
    MAP ("l",			(int) BFD_RELOC_LO16),
    MAP ("h",			(int) BFD_RELOC_HI16),
    MAP ("ha",			(int) BFD_RELOC_HI16_S),
    MAP ("brtaken",		(int) BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",		(int) BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",			(int) BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",		(int) BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",		(int) BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",		(int) BFD_RELOC_HI16_S_GOTOFF),
    MAP ("fixup",		(int) BFD_RELOC_CTOR),
    MAP ("plt",			(int) BFD_RELOC_24_PLT_PCREL),
    MAP ("pltrel24",		(int) BFD_RELOC_24_PLT_PCREL),
    MAP ("copy",		(int) BFD_RELOC_PPC_COPY),
    MAP ("globdat",		(int) BFD_RELOC_PPC_GLOB_DAT),
    MAP ("local24pc",		(int) BFD_RELOC_PPC_LOCAL24PC),
    MAP ("local",		(int) BFD_RELOC_PPC_LOCAL24PC),
    MAP ("pltrel",		(int) BFD_RELOC_32_PLT_PCREL),
    MAP ("plt@@l",		(int) BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",		(int) BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",		(int) BFD_RELOC_HI16_S_PLTOFF),
    MAP ("sdarel",		(int) BFD_RELOC_GPREL16),
    MAP ("sectoff",		(int) BFD_RELOC_16_BASEREL),
    MAP ("sectoff@@l",		(int) BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",		(int) BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",		(int) BFD_RELOC_HI16_S_BASEREL),
    MAP ("naddr",		(int) BFD_RELOC_PPC_EMB_NADDR32),
    MAP ("naddr16",		(int) BFD_RELOC_PPC_EMB_NADDR16),
    MAP ("naddr@@l",		(int) BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP ("naddr@@h",		(int) BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP ("naddr@@ha",		(int) BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP ("sdai16",		(int) BFD_RELOC_PPC_EMB_SDAI16),
    MAP ("sda2rel",		(int) BFD_RELOC_PPC_EMB_SDA2REL),
    MAP ("sda2i16",		(int) BFD_RELOC_PPC_EMB_SDA2I16),
    MAP ("sda21",		(int) BFD_RELOC_PPC_EMB_SDA21),
    MAP ("mrkref",		(int) BFD_RELOC_PPC_EMB_MRKREF),
    MAP ("relsect",		(int) BFD_RELOC_PPC_EMB_RELSEC16),
    MAP ("relsect@@l",		(int) BFD_RELOC_PPC_EMB_RELST_LO),
    MAP ("relsect@@h",		(int) BFD_RELOC_PPC_EMB_RELST_HI),
    MAP ("relsect@@ha",		(int) BFD_RELOC_PPC_EMB_RELST_HA),
    MAP ("bitfld",		(int) BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP ("relsda",		(int) BFD_RELOC_PPC_EMB_RELSDA),
    MAP ("xgot",		(int) BFD_RELOC_PPC_TOC16),
    MAP ("tls",			(int) BFD_RELOC_PPC_TLS),
    MAP ("dtpmod",		(int) BFD_RELOC_PPC_DTPMOD),
    MAP ("dtprel",		(int) BFD_RELOC_PPC_DTPREL),
    MAP ("dtprel@@l",		(int) BFD_RELOC_PPC_DTPREL16_LO),
    MAP ("dtprel@@h",		(int) BFD_RELOC_PPC_DTPREL16_HI),
    MAP ("dtprel@@ha",		(int) BFD_RELOC_PPC_DTPREL16_HA),
    MAP ("tprel",		(int) BFD_RELOC_PPC_TPREL),
    MAP ("tprel@@l",		(int) BFD_RELOC_PPC_TPREL16_LO),
    MAP ("tprel@@h",		(int) BFD_RELOC_PPC_TPREL16_HI),
    MAP ("tprel@@ha",		(int) BFD_RELOC_PPC_TPREL16_HA),
    MAP ("got@@tlsgd",		(int) BFD_RELOC_PPC_GOT_TLSGD16),
    MAP ("got@@tlsgd@@l",		(int) BFD_RELOC_PPC_GOT_TLSGD16_LO),
    MAP ("got@@tlsgd@@h",		(int) BFD_RELOC_PPC_GOT_TLSGD16_HI),
    MAP ("got@@tlsgd@@ha",	(int) BFD_RELOC_PPC_GOT_TLSGD16_HA),
    MAP ("got@@tlsld",		(int) BFD_RELOC_PPC_GOT_TLSLD16),
    MAP ("got@@tlsld@@l",		(int) BFD_RELOC_PPC_GOT_TLSLD16_LO),
    MAP ("got@@tlsld@@h",		(int) BFD_RELOC_PPC_GOT_TLSLD16_HI),
    MAP ("got@@tlsld@@ha",	(int) BFD_RELOC_PPC_GOT_TLSLD16_HA),
    MAP ("got@@dtprel",		(int) BFD_RELOC_PPC_GOT_DTPREL16),
    MAP ("got@@dtprel@@l",	(int) BFD_RELOC_PPC_GOT_DTPREL16_LO),
    MAP ("got@@dtprel@@h",	(int) BFD_RELOC_PPC_GOT_DTPREL16_HI),
    MAP ("got@@dtprel@@ha",	(int) BFD_RELOC_PPC_GOT_DTPREL16_HA),
    MAP ("got@@tprel",		(int) BFD_RELOC_PPC_GOT_TPREL16),
    MAP ("got@@tprel@@l",		(int) BFD_RELOC_PPC_GOT_TPREL16_LO),
    MAP ("got@@tprel@@h",		(int) BFD_RELOC_PPC_GOT_TPREL16_HI),
    MAP ("got@@tprel@@ha",	(int) BFD_RELOC_PPC_GOT_TPREL16_HA),
    /* The following are only valid for ppc64.  Negative values are
       used instead of a flag.  */
    MAP ("higher",		- (int) BFD_RELOC_PPC64_HIGHER),
    MAP ("highera",		- (int) BFD_RELOC_PPC64_HIGHER_S),
    MAP ("highest",		- (int) BFD_RELOC_PPC64_HIGHEST),
    MAP ("highesta",		- (int) BFD_RELOC_PPC64_HIGHEST_S),
    MAP ("tocbase",		- (int) BFD_RELOC_PPC64_TOC),
    MAP ("toc",			- (int) BFD_RELOC_PPC_TOC16),
    MAP ("toc@@l",		- (int) BFD_RELOC_PPC64_TOC16_LO),
    MAP ("toc@@h",		- (int) BFD_RELOC_PPC64_TOC16_HI),
    MAP ("toc@@ha",		- (int) BFD_RELOC_PPC64_TOC16_HA),
    MAP ("dtprel@@higher",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHER),
    MAP ("dtprel@@highera",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHERA),
    MAP ("dtprel@@highest",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHEST),
    MAP ("dtprel@@highesta",	- (int) BFD_RELOC_PPC64_DTPREL16_HIGHESTA),
    MAP ("tprel@@higher",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHER),
    MAP ("tprel@@highera",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHERA),
    MAP ("tprel@@highest",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHEST),
    MAP ("tprel@@highesta",	- (int) BFD_RELOC_PPC64_TPREL16_HIGHESTA),
    { (char *) 0, 0,		(int) BFD_RELOC_UNUSED }
d1326 1
a1326 1
	&& (ISALNUM (ch) || ch == '@@'));
d1329 1
a1329 1
      *str2++ = TOLOWER (ch);
d1341 6
a1346 16
	int reloc = ptr->reloc;

	if (reloc < 0)
	  {
	    if (!ppc_obj64)
	      return BFD_RELOC_UNUSED;
	    reloc = -reloc;
	  }

	if (!ppc_obj64)
	  if (exp_p->X_add_number != 0
	      && (reloc == (int) BFD_RELOC_16_GOTOFF
		  || reloc == (int) BFD_RELOC_LO16_GOTOFF
		  || reloc == (int) BFD_RELOC_HI16_GOTOFF
		  || reloc == (int) BFD_RELOC_HI16_S_GOTOFF))
	    as_warn (_("identifier+constant@@got means identifier@@got+constant"));
d1348 1
a1348 1
	/* Now check for identifier@@suffix+constant.  */
d1365 1
d1367 1
a1367 11

	if (reloc == (int) BFD_RELOC_PPC64_TOC
	    && exp_p->X_op == O_symbol)
	  {
	    /* This reloc type ignores the symbol.  Change the symbol
	       so that the dummy .TOC. symbol can be omitted from the
	       object file.  */
	    exp_p->X_add_symbol = &abs_symbol;
	  }

	return (bfd_reloc_code_real_type) reloc;
d1373 3
a1375 2
/* Like normal .long/.short/.word, except support @@got, etc.
   Clobbers input_line_pointer, checks end-of-line.  */
d1378 1
a1378 1
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long, 8=.llong.  */
d1394 1
a1394 2
	  && (reloc = ppc_elf_suffix (&input_line_pointer,
				      &exp)) != BFD_RELOC_UNUSED)
d1396 2
a1397 2
	  reloc_howto_type *reloc_howto;
	  int size;
d1399 2
a1400 2
	  reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  size = bfd_get_reloc_size (reloc_howto);
a1401 5
	  if (size > nbytes)
	    {
	      as_bad (_("%s relocations do not fit in %d bytes\n"),
		      reloc_howto->name, nbytes);
	    }
d1404 2
a1405 2
	      char *p;
	      int offset;
d1407 1
a1407 6
	      p = frag_more (nbytes);
	      offset = 0;
	      if (target_big_endian)
		offset = nbytes - size;
	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
d1415 1
a1415 2
  /* Put terminator back into stream.  */
  input_line_pointer--;
d1427 1
a1427 1
  /* Just pretend this is .section .rodata  */
d1434 1
a1434 1
/* Pseudo op to make file scope bss items.  */
d1436 1
a1436 1
ppc_elf_lcomm (xxx)
d1453 1
a1453 1
  /* just after name is now '\0'.  */
d1509 1
a1509 1
  /* Allocate_bss.  */
d1514 1
a1514 1
      /* Convert to a power of 2 alignment.  */
d1565 1
a1565 1
	  && fixp->fx_r_type != BFD_RELOC_16_BASEREL
a1568 1
	  && (seg->flags & SEC_LOAD) != 0
d1573 1
a1587 45

/* Prevent elf_frob_file_before_adjust removing a weak undefined
   function descriptor sym if the corresponding code sym is used.  */

void
ppc_frob_file_before_adjust ()
{
  symbolS *symp;

  if (!ppc_obj64)
    return;

  for (symp = symbol_rootP; symp; symp = symbol_next (symp))
    {
      const char *name;
      char *dotname;
      symbolS *dotsym;
      size_t len;

      name = S_GET_NAME (symp);
      if (name[0] == '.')
	continue;

      if (! S_IS_WEAK (symp)
	  || S_IS_DEFINED (symp))
	continue;

      len = strlen (name) + 1;
      dotname = xmalloc (len + 1);
      dotname[0] = '.';
      memcpy (dotname + 1, name, len);
      dotsym = symbol_find (dotname);
      free (dotname);
      if (dotsym != NULL && (symbol_used_p (dotsym)
			     || symbol_used_in_reloc_p (dotsym)))
	{
	  symbol_mark_used (symp);
	}
    }

  /* Don't emit .TOC. symbol.  */
  symp = symbol_find (".TOC.");
  if (symp != NULL)
    symbol_remove (symp, &symbol_rootP, &symbol_lastP);
}
d1593 1
a1593 1
 * Summary of parse_toc_entry.
d1626 1
a1626 1
parse_toc_entry (toc_kind)
d1634 1
a1634 1
  /* Save the input_line_pointer.  */
d1637 1
a1637 1
  /* Skip over the '[' , and whitespace.  */
d1641 1
a1641 1
  /* Find the spelling of the operand.  */
d1645 1
a1645 1
  if (strcmp (toc_spec, "toc") == 0)
d1649 1
a1649 1
  else if (strcmp (toc_spec, "tocv") == 0)
d1653 1
a1653 1
  else if (strcmp (toc_spec, "toc32") == 0)
d1657 1
a1657 1
  else if (strcmp (toc_spec, "toc64") == 0)
d1664 2
a1665 2
      *input_line_pointer = c;
      input_line_pointer = start;
d1669 2
a1670 2
  /* Now find the ']'.  */
  *input_line_pointer = c;
d1678 1
a1678 1
      input_line_pointer = start;
d1682 1
a1682 1
  *toc_kind = t;
a1687 34
#ifdef OBJ_ELF
#define APUID(a,v)	((((a) & 0xffff) << 16) | ((v) & 0xffff))
static void
ppc_apuinfo_section_add (apu, version)
      unsigned int apu, version;
{
  unsigned int i;

  /* Check we don't already exist.  */
  for (i = 0; i < ppc_apuinfo_num; i++)
    if (ppc_apuinfo_list[i] == APUID (apu, version))
      return;

  if (ppc_apuinfo_num == ppc_apuinfo_num_alloc)
    {
      if (ppc_apuinfo_num_alloc == 0)
	{
	  ppc_apuinfo_num_alloc = 4;
	  ppc_apuinfo_list = (unsigned long *)
	      xmalloc (sizeof (unsigned long) * ppc_apuinfo_num_alloc);
	}
      else
	{
	  ppc_apuinfo_num_alloc += 4;
	  ppc_apuinfo_list = (unsigned long *) xrealloc (ppc_apuinfo_list,
	      sizeof (unsigned long) * ppc_apuinfo_num_alloc);
	}
    }
  ppc_apuinfo_list[ppc_apuinfo_num++] = APUID (apu, version);
}
#undef APUID
#endif


d1723 1
a1723 1
  for (s = str; *s != '\0' && ! ISSPACE (*s); s++)
d1746 1
a1746 1
  while (ISSPACE (*str))
a1766 2
	  unsigned int num_operands_expected;
	  unsigned int i;
a1782 6
	  /* Compute the number of expected operands.
	     Do not count fake operands.  */
	  for (num_operands_expected = 0, i = 0; opcode->operands[i]; i ++)
	    if ((powerpc_operands [opcode->operands[i]].flags & PPC_OPERAND_FAKE) == 0)
	      ++ num_operands_expected;

d1786 1
a1786 1
	  if (opcount < num_operands_expected)
d1812 1
d1819 1
a1819 1
	  insn = (*operand->insert) (insn, 0L, ppc_cpu, &errmsg);
d1832 1
a1832 1
	      insn = (*operand->insert) (insn, 0L, ppc_cpu, &errmsg);
d1849 23
a1871 23
	   *
	   *    lwz r4,[toc].GS.0.static_int(rtoc)
	   *           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
	   * The argument following the `]' must be a symbol name, and the
	   * register must be the toc register: 'rtoc' or '2'
	   *
	   * The effect is to 0 as the displacement field
	   * in the instruction, and issue an IMAGE_REL_PPC_TOCREL16 (or
	   * the appropriate variation) reloc against it based on the symbol.
	   * The linker will build the toc, and insert the resolved toc offset.
	   *
	   * Note:
	   * o The size of the toc entry is currently assumed to be
	   *   32 bits. This should not be assumed to be a hard coded
	   *   number.
	   * o In an effort to cope with a change from 32 to 64 bits,
	   *   there are also toc entries that are specified to be
	   *   either 32 or 64 bits:
	   *     lwz r4,[toc32].GS.0.static_int(rtoc)
	   *     lwz r4,[toc64].GS.0.static_int(rtoc)
	   *   These demand toc entries of the specified size, and the
	   *   instruction probably requires it.
	   */
d1877 2
a1878 2
	  /* Go parse off the [tocXX] part.  */
	  valid_toc = parse_toc_entry (&toc_kind);
d1882 3
a1884 3
	      /* Note: message has already been issued.
		 FIXME: what sort of recovery should we do?
		 demand_rest_of_line (); return; ?  */
d1887 2
a1888 2
	  /* Now get the symbol following the ']'.  */
	  expression (&ex);
d1893 3
a1895 3
	      /* In this case, we may not have seen the symbol yet,
		 since  it is allowed to appear on a .extern or .globl
		 or just be a label in the .data section.  */
d1899 7
a1905 8
	      /* 1. The symbol must be defined and either in the toc
		 section, or a global.
		 2. The reloc generated must have the TOCDEFN flag set
		 in upper bit mess of the reloc type.
		 FIXME: It's a little confusing what the tocv
		 qualifier can be used for.  At the very least, I've
		 seen three uses, only one of which I'm sure I can
		 explain.  */
d1912 1
a1912 1
		      as_bad (_("[tocv] symbol is not a toc symbol"));
d1919 3
a1921 3
	      /* FIXME: these next two specifically specify 32/64 bit
		 toc entries.  We don't support them today.  Is this
		 the right way to say that?  */
d1926 1
a1926 1
	      /* FIXME: see above.  */
d1932 2
a1933 2
		       _("Unexpected return value [%d] from parse_toc_entry!\n"),
		       toc_kind);
d1947 2
a1948 2
	  /* Ok. We've set up the fixup for the instruction. Now make it
	     look like the constant 0 was found here.  */
d1962 1
a1962 1
		cr_operand = TRUE;
d1964 1
a1964 1
	      cr_operand = FALSE;
d1995 4
a1998 3
		   something which cleared it, we always produce a
		   signed value.  */
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
d2001 3
a2003 1
		  ex.X_add_number = SEX16 (ex.X_add_number);
d2007 1
a2007 4
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HI (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HI (ex.X_add_number));
d2011 3
a2013 32
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HA (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HA (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHER:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHER (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHER (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHER_S:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHERA (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHERA (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHEST:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHEST (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHEST (ex.X_add_number));
		break;

	      case BFD_RELOC_PPC64_HIGHEST_S:
		if (ex.X_unsigned && ! (operand->flags & PPC_OPERAND_SIGNED))
		  ex.X_add_number = PPC_HIGHESTA (ex.X_add_number);
		else
		  ex.X_add_number = SEX16 (PPC_HIGHESTA (ex.X_add_number));
d2016 1
a2016 1
#endif /* OBJ_ELF */
d2023 2
a2024 21
	  /* Some TLS tweaks.  */
	  switch (reloc)
	    {
	    default:
	      break;
	    case BFD_RELOC_PPC_TLS:
	      insn = ppc_insert_operand (insn, operand, ppc_obj64 ? 13 : 2,
					 (char *) NULL, 0);
	      break;
	  /* We'll only use the 32 (or 64) bit form of these relocations
	     in constants.  Instructions get the 16 bit form.  */
	    case BFD_RELOC_PPC_DTPREL:
	      reloc = BFD_RELOC_PPC_DTPREL16;
	      break;
	    case BFD_RELOC_PPC_TPREL:
	      reloc = BFD_RELOC_PPC_TPREL16;
	      break;
	    }

	  /* For the absolute forms of branches, convert the PC
	     relative form back into the absolute.  */
a2045 61
	  if (ppc_obj64
	      && (operand->flags & PPC_OPERAND_DS) != 0)
	    {
	      switch (reloc)
		{
		case BFD_RELOC_16:
		  reloc = BFD_RELOC_PPC64_ADDR16_DS;
		  break;
		case BFD_RELOC_LO16:
		  reloc = BFD_RELOC_PPC64_ADDR16_LO_DS;
		  break;
		case BFD_RELOC_16_GOTOFF:
		  reloc = BFD_RELOC_PPC64_GOT16_DS;
		  break;
		case BFD_RELOC_LO16_GOTOFF:
		  reloc = BFD_RELOC_PPC64_GOT16_LO_DS;
		  break;
		case BFD_RELOC_LO16_PLTOFF:
		  reloc = BFD_RELOC_PPC64_PLT16_LO_DS;
		  break;
		case BFD_RELOC_16_BASEREL:
		  reloc = BFD_RELOC_PPC64_SECTOFF_DS;
		  break;
		case BFD_RELOC_LO16_BASEREL:
		  reloc = BFD_RELOC_PPC64_SECTOFF_LO_DS;
		  break;
		case BFD_RELOC_PPC_TOC16:
		  reloc = BFD_RELOC_PPC64_TOC16_DS;
		  break;
		case BFD_RELOC_PPC64_TOC16_LO:
		  reloc = BFD_RELOC_PPC64_TOC16_LO_DS;
		  break;
		case BFD_RELOC_PPC64_PLTGOT16:
		  reloc = BFD_RELOC_PPC64_PLTGOT16_DS;
		  break;
		case BFD_RELOC_PPC64_PLTGOT16_LO:
		  reloc = BFD_RELOC_PPC64_PLTGOT16_LO_DS;
		  break;
		case BFD_RELOC_PPC_DTPREL16:
		  reloc = BFD_RELOC_PPC64_DTPREL16_DS;
		  break;
		case BFD_RELOC_PPC_DTPREL16_LO:
		  reloc = BFD_RELOC_PPC64_DTPREL16_LO_DS;
		  break;
		case BFD_RELOC_PPC_TPREL16:
		  reloc = BFD_RELOC_PPC64_TPREL16_DS;
		  break;
		case BFD_RELOC_PPC_TPREL16_LO:
		  reloc = BFD_RELOC_PPC64_TPREL16_LO_DS;
		  break;
		case BFD_RELOC_PPC_GOT_DTPREL16:
		case BFD_RELOC_PPC_GOT_DTPREL16_LO:
		case BFD_RELOC_PPC_GOT_TPREL16:
		case BFD_RELOC_PPC_GOT_TPREL16_LO:
		  break;
		default:
		  as_bad (_("unsupported relocation for DS offset field"));
		  break;
		}
	    }

d2093 1
a2093 1
  while (ISSPACE (*str))
a2098 25
#ifdef OBJ_ELF
  /* Do we need/want a APUinfo section? */
  if (ppc_cpu & (PPC_OPCODE_SPE
   	       | PPC_OPCODE_ISEL | PPC_OPCODE_EFS
	       | PPC_OPCODE_BRLOCK | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
	       | PPC_OPCODE_RFMCI))
    {
      /* These are all version "1".  */
      if (opcode->flags & PPC_OPCODE_SPE)
	ppc_apuinfo_section_add (PPC_APUINFO_SPE, 1);
      if (opcode->flags & PPC_OPCODE_ISEL)
	ppc_apuinfo_section_add (PPC_APUINFO_ISEL, 1);
      if (opcode->flags & PPC_OPCODE_EFS)
	ppc_apuinfo_section_add (PPC_APUINFO_EFS, 1);
      if (opcode->flags & PPC_OPCODE_BRLOCK)
	ppc_apuinfo_section_add (PPC_APUINFO_BRLOCK, 1);
      if (opcode->flags & PPC_OPCODE_PMR)
	ppc_apuinfo_section_add (PPC_APUINFO_PMR, 1);
      if (opcode->flags & PPC_OPCODE_CACHELCK)
	ppc_apuinfo_section_add (PPC_APUINFO_CACHELCK, 1);
      if (opcode->flags & PPC_OPCODE_RFMCI)
	ppc_apuinfo_section_add (PPC_APUINFO_RFMCI, 1);
    }
#endif

d2112 1
a2112 1
     md_apply_fix3.  */
d2120 1
a2120 1
	  reloc_howto_type *reloc_howto;
a2124 1
	  reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
d2134 2
a2135 5
	  fixP = fix_new_exp (frag_now,
			      f - frag_now->fr_literal + offset,
			      size,
			      &fixups[i].exp,
			      reloc_howto->pc_relative,
a2146 6
#ifdef OBJ_ELF
	    case BFD_RELOC_PPC64_HIGHER:
	    case BFD_RELOC_PPC64_HIGHER_S:
	    case BFD_RELOC_PPC64_HIGHEST:
	    case BFD_RELOC_PPC64_HIGHEST_S:
#endif
d2154 1
a2154 3
	fix_new_exp (frag_now,
		     f - frag_now->fr_literal,
		     4,
d2158 1
a2158 1
		      (fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
d2243 1
a2243 1
/* For ELF, add support for SHF_EXCLUDE and SHT_ORDERED.  */
d2253 1
a2253 1
  *ptr_msg = _("Bad .section directive: want a,e,w,x,M,S,G,T in string");
d2339 1
a2339 1
static bfd_boolean ppc_stab_symbol;
d2343 1
a2343 2
   symbols, and uses a different smclas.  The native Aix 4.3.3 assember
   aligns .comm and .lcomm to 4 bytes.  */
d2385 1
a2385 1
	align = 2;
d2393 1
a2393 1
	      align = 2;
d2402 5
a2406 1
      if (size <= 4)
d2591 2
a2592 2
	 changing subsegments, so that we don't use a lot of memory
	 space for what may be a small section.  */
d2607 1
a2607 1
      symbol_get_tc (sym)->align = 2;
d2785 1
a2785 1
  ppc_stab_symbol = TRUE;
d2787 1
a2787 1
  ppc_stab_symbol = FALSE;
d2819 2
a2820 2
	 fail at some later point, but this is probably the right
	 thing to do here.  */
d2849 1
a2849 1

d2853 1
a2853 1

d2857 1
a2857 1

d2859 1
a2859 1

d2863 3
a2865 3
       would be to have the tc field updated in ppc_symbol_new_hook.  */

    if (exp.X_op == O_symbol)
d2983 1
a2983 4
   ".bf".  If the pseudo op .bi was seen before .bf, patch the .bi sym
   with the correct line number */

static symbolS *saved_bi_sym = 0;
a3001 8
  /* Line number for bi.  */
  if (saved_bi_sym)
    {
      S_SET_VALUE (saved_bi_sym, coff_n_line_nos);
      saved_bi_sym = 0;
    }


d3035 1
a3035 2
   the symbol list.  The value of .bi will be know when the next .bf
   is encountered.  */
a3064 6
  /* Save bi.  */
  if (ei)
    saved_bi_sym = 0;
  else
    saved_bi_sym = sym;

d3299 8
a3333 1
#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
d3340 1
a3340 1
   TC.  The rest of the arguments are N-byte values to actually put at
d3342 1
a3342 3
   relocateable symbol reference.  The size of the value to store
   depends on target word size.  A 32-bit target uses 4-byte values, a
   64-bit target uses 8-byte values.
d3405 1
a3405 3
#endif /* OBJ_XCOFF */
#ifdef OBJ_ELF
  int align;
d3415 5
a3419 5
  /* Align to a four/eight byte boundary.  */
  align = ppc_obj64 ? 3 : 2;
  frag_align (align, 0, 0);
  record_alignment (now_seg, align);
#endif /* OBJ_ELF */
d3426 1
a3426 1
      cons (ppc_obj64 ? 8 : 4);
a3428 34

/* Pseudo-op .machine.  */
/* FIXME: `.machine' is a nop for the moment.  It would be nice to
   accept this directive on the first line of input and set ppc_obj64
   and the target format accordingly.  Unfortunately, the target
   format is selected in output-file.c:output_file_create before we
   even get to md_begin, so it's not possible without changing
   as.c:main.  */

static void
ppc_machine (ignore)
     int ignore ATTRIBUTE_UNUSED;
{
  discard_rest_of_line ();
}

/* See whether a symbol is in the TOC section.  */

static int
ppc_is_toc_sym (sym)
     symbolS *sym;
{
#ifdef OBJ_XCOFF
  return symbol_get_tc (sym)->class == XMC_TC;
#endif
#ifdef OBJ_ELF
  const char *sname = segment_name (S_GET_SEGMENT (sym));
  if (ppc_obj64)
    return strcmp (sname, ".toc") == 0;
  else
    return strcmp (sname, ".got") == 0;
#endif
}
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */
d3432 1
a3432 1
/* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format.  */
d3446 2
a3447 2
   warnings:  "No previous section"  */

d3449 1
a3449 1
ppc_previous (ignore)
d3456 1
a3456 1
      as_warn (_("No previous section to return to. Directive ignored."));
d3460 1
a3460 1
  subseg_set (ppc_previous_section, 0);
d3462 1
a3462 1
  ppc_set_current_section (ppc_previous_section);
d3467 1
a3467 1
	      double word aligned
d3471 1
a3471 1
	      a - don't know -- maybe a misprint
d3478 1
a3478 1
   handling, debugging, etc.  */
d3480 1
d3482 1
a3482 1
ppc_pdata (ignore)
d3497 1
a3497 1
      pdata_section = subseg_new (".pdata", 0);
d3499 1
a3499 1
  ppc_set_current_section (pdata_section);
d3504 1
a3504 1
	      double word aligned
d3508 1
a3508 1
	      a - don't know -- maybe a misprint
d3514 2
a3515 2
   debugging, etc.  */

d3517 1
a3517 1
ppc_ydata (ignore)
d3524 2
a3525 2
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_READONLY | SEC_DATA ));
d3533 1
a3533 1
  ppc_set_current_section (ydata_section);
d3538 1
a3538 1
	      double word aligned (4-byte)
d3551 2
a3552 2
   function descriptors, etc.  */

d3554 1
a3554 1
ppc_reldata (ignore)
d3562 2
a3563 2
			     (SEC_ALLOC | SEC_LOAD | SEC_RELOC
			      | SEC_DATA));
d3571 1
a3571 1
  ppc_set_current_section (reldata_section);
d3576 1
a3576 1
	      double word aligned
d3582 2
a3583 2
	      3 - double word aligned (that would be 4 byte boundary)  */

d3585 1
a3585 1
ppc_rdata (ignore)
d3601 1
a3601 1
  ppc_set_current_section (rdata_section);
d3606 1
a3606 1
	      performed.
d3609 2
a3610 2
   warnings:  None  */

d3612 1
a3612 1
ppc_ualong (ignore)
d3615 2
a3616 2
  /* Try for long.  */
  cons (4);
d3621 1
a3621 1
	      Issue a IMAGE_REL_PPC_IFGLUE relocation against it, using
d3624 2
a3625 2
   warnings:  Missing symbol name  */

d3627 1
a3627 1
ppc_znop (ignore)
d3634 1
d3636 2
a3644 1
  /* Strip out the symbol name.  */
d3660 1
a3660 1
  /* Stick in the nop.  */
d3679 2
a3680 2
   warnings:  */

d3682 1
a3682 1
ppc_pe_comm (lcomm)
d3695 1
a3695 1
  /* just after name is now '\0'.  */
d3814 1
a3814 1
  /* Strip out the section name.  */
d3857 1
a3857 2
    /* Default alignment to 16 byte boundary.  */
    align = 4;
d3945 2
a3946 2
		  as_bad (_("unknown section attribute '%c'"),
			  *input_line_pointer);
d3958 1
a3958 1
  ppc_set_current_section (sec);
d3968 1
a3968 1
  bfd_set_section_alignment (stdoutput, sec, align);
d4002 1
a4002 1
      /* FIXME: section flags won't work.  */
d4005 1
a4005 1
			      | SEC_READONLY | SEC_DATA));
d4014 1
a4014 1
  ppc_set_current_section (tocdata_section);
d4061 2
a4062 1
	*s = TOUPPER (*s);
d4185 1
a4185 1
static bfd_boolean ppc_saw_abs;
a4207 4
  /* This one will disappear anyway.  Don't make a csect sym for it.  */
  if (sym == abs_section_sym)
    return 1;

d4244 1
a4244 1
	  resolve_symbol_value (symbol_get_tc (sym)->size);
d4304 1
a4304 1
	      resolve_symbol_value (symbol_get_tc (sym)->next);
d4323 2
a4324 2
	     ppc_adjust_symtab.  */
	  ppc_saw_abs = TRUE;
d4357 1
a4357 1
	      resolve_symbol_value (next);
d4388 1
a4388 1
		  resolve_symbol_value (symbol_get_tc (csect)->next);
d4420 4
a4423 4
      asymbol *bsym = symbol_get_bfdsym (symbol_get_tc (sym)->within);
      combined_entry_type *c = coffsymbol (bsym)->native;

      S_SET_VALUE (sym, (valueT) (size_t) c);
d4434 1
a4434 1
      resolve_symbol_value (csect);
d4441 2
a4442 2
	 BFD will do that for us if we set the right flags.  We have
	 already set the value correctly.  */
d4492 1
a4492 1
  ppc_saw_abs = FALSE;
d4649 1
a4649 6
  valueT val = resolve_symbol_value (fix->fx_addsy);
  segT symseg = S_GET_SEGMENT (fix->fx_addsy);
  TC_SYMFIELD_TYPE *tc;

  if (symseg == absolute_section)
    return 0;
d4651 2
d4654 1
d4656 1
a4656 1
      && symseg == data_section
d4667 1
a4667 3
	  TC_SYMFIELD_TYPE *sy_tc = symbol_get_tc (sy);

	  if (sy_tc->class == XMC_TC0)
d4669 1
a4669 1
	  if (sy_tc->class != XMC_TC)
d4671 2
a4672 1
	  if (val == resolve_symbol_value (sy))
d4685 5
a4689 5
  tc = symbol_get_tc (fix->fx_addsy);
  if (tc->subseg == 0
      && tc->class != XMC_TC0
      && tc->class != XMC_TC
      && symseg != bss_section
d4691 1
a4691 1
      && (symseg != data_section
a4697 1
      symbolS *next_csect;
d4699 1
a4699 1
      if (symseg == text_section)
d4701 1
a4701 1
      else if (symseg == data_section)
d4711 3
a4713 2
	  while ((next_csect = symbol_get_tc (csect)->next) != (symbolS *) NULL
		 && (symbol_get_frag (next_csect)->fr_address <= val))
d4716 5
a4720 5
		 have to look through the full symbol table to see
		 whether this is the csect we want.  Note that we will
		 only get here if the csect has zero length.  */
	      if (symbol_get_frag (csect)->fr_address == val
		  && S_GET_VALUE (csect) == val)
d4735 1
a4735 1
		     symbol, then this is the csect we want.  */
d4740 1
a4740 1
	      csect = next_csect;
d4743 2
a4744 1
	  fix->fx_offset += val - symbol_get_frag (csect)->fr_address;
a4746 1
      return 0;
d4751 2
a4752 1
  if (symseg == bss_section
d4755 5
a4759 4
      symbolS *sy = symbol_get_frag (fix->fx_addsy)->fr_symbol;

      fix->fx_offset += val - resolve_symbol_value (sy);
      fix->fx_addsy = sy;
d4787 1
a4787 1
  return generic_force_reloc (fix);
d4792 1
a4792 3
#ifdef OBJ_ELF
/* If this function returns non-zero, it guarantees that a relocation
   will be emitted for a fixup.  */
d4794 3
a4796 3
int
ppc_force_relocation (fix)
     fixS *fix;
d4798 5
a4802 19
  /* Branch prediction relocations must force a relocation, as must
     the vtable description relocs.  */
  switch (fix->fx_r_type)
    {
    case BFD_RELOC_PPC_B16_BRTAKEN:
    case BFD_RELOC_PPC_B16_BRNTAKEN:
    case BFD_RELOC_PPC_BA16_BRTAKEN:
    case BFD_RELOC_PPC_BA16_BRNTAKEN:
    case BFD_RELOC_PPC64_TOC:
      return 1;
    default:
      break;
    }

  if (fix->fx_r_type >= BFD_RELOC_PPC_TLS
      && fix->fx_r_type <= BFD_RELOC_PPC64_DTPREL16_HIGHESTA)
    return 1;

  return generic_force_reloc (fix);
a4804 21
int
ppc_fix_adjustable (fix)
     fixS *fix;
{
  return (fix->fx_r_type != BFD_RELOC_16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_LO16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_HI16_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_HI16_S_GOTOFF
	  && fix->fx_r_type != BFD_RELOC_GPREL16
	  && fix->fx_r_type != BFD_RELOC_VTABLE_INHERIT
	  && fix->fx_r_type != BFD_RELOC_VTABLE_ENTRY
	  && !(fix->fx_r_type >= BFD_RELOC_PPC_TLS
	       && fix->fx_r_type <= BFD_RELOC_PPC64_DTPREL16_HIGHESTA)
	  && (fix->fx_pcrel
	      || (fix->fx_subsy != NULL
		  && (S_GET_SEGMENT (fix->fx_subsy)
		      == S_GET_SEGMENT (fix->fx_addsy)))
	      || S_IS_LOCAL (fix->fx_addsy)));
}
#endif

d4814 5
a4818 5
void
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d4820 1
a4820 1
  valueT value = * valP;
d4823 2
a4824 1
  if (fixP->fx_addsy != NULL)
d4826 13
a4838 3
      /* Hack around bfd_install_relocation brain damage.  */
      if (fixP->fx_pcrel)
	value += fixP->fx_frag->fr_address + fixP->fx_where;
d4841 3
a4843 1
    fixP->fx_done = 1;
d4845 1
a4845 1
  /* FIXME FIXME FIXME: The value we are passed in *valP includes
d4850 1
a4850 1
     use *valP since bfd_install_relocation is not being used.
d4852 2
a4853 2
     *valP, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valP since it includes the
d4855 7
a4861 6
  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  else if (fixP->fx_pcrel)
    ;

a4862 4
    value = fixP->fx_offset;
#endif

  if (fixP->fx_subsy != (symbolS *) NULL)
d4864 12
a4875 2
      /* We can't actually support subtracting a symbol.  */
      as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));
d4877 1
d4879 1
a4879 1
  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
d4886 1
a4886 1
      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
d4891 7
a4897 4
      /* An instruction like `lwz 9,sym(30)' when `sym' is not a TOC symbol
	 does not generate a reloc.  It uses the offset of `sym' within its
	 csect.  Other usages, such as `.long sym', generate relocs.  This
	 is the documented behaviour of non-TOC symbols.  */
d4901 6
a4906 6
	  && (operand->insert == NULL || ppc_obj64)
	  && fixP->fx_addsy != NULL
	  && symbol_get_tc (fixP->fx_addsy)->subseg != 0
	  && symbol_get_tc (fixP->fx_addsy)->class != XMC_TC
	  && symbol_get_tc (fixP->fx_addsy)->class != XMC_TC0
	  && S_GET_SEGMENT (fixP->fx_addsy) != bss_section)
d4908 2
a4909 2
	  value = fixP->fx_offset;
	  fixP->fx_done = 1;
d4915 1
a4915 1
      where = fixP->fx_frag->fr_literal + fixP->fx_where;
d4921 1
a4921 1
				 fixP->fx_file, fixP->fx_line);
d4927 5
a4931 5
      if (fixP->fx_done)
	/* Nothing else to do here.  */
	return;

      assert (fixP->fx_addsy != NULL);
d4935 4
a4938 1
	 relocs.  */
d4942 1
a4942 1
	fixP->fx_r_type = BFD_RELOC_PPC_B26;
d4946 1
a4946 8
	{
	  fixP->fx_r_type = BFD_RELOC_PPC_B16;
#ifdef OBJ_XCOFF
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
#endif
	}
d4950 1
a4950 1
	fixP->fx_r_type = BFD_RELOC_PPC_BA26;
d4954 1
a4954 9
	{
	  fixP->fx_r_type = BFD_RELOC_PPC_BA16;
#ifdef OBJ_XCOFF
	  fixP->fx_size = 2;
	  if (target_big_endian)
	    fixP->fx_where += 2;
#endif
	}
#if defined (OBJ_XCOFF) || defined (OBJ_ELF)
d4957 3
a4959 1
	       && operand->shift == 0)
d4961 1
a4961 19
	  if (ppc_is_toc_sym (fixP->fx_addsy))
	    {
	      fixP->fx_r_type = BFD_RELOC_PPC_TOC16;
#ifdef OBJ_ELF
	      if (ppc_obj64
		  && (operand->flags & PPC_OPERAND_DS) != 0)
		fixP->fx_r_type = BFD_RELOC_PPC64_TOC16_DS;
#endif
	    }
	  else
	    {
	      fixP->fx_r_type = BFD_RELOC_16;
#ifdef OBJ_ELF
	      if (ppc_obj64
		  && (operand->flags & PPC_OPERAND_DS) != 0)
		fixP->fx_r_type = BFD_RELOC_PPC64_ADDR16_DS;
#endif
	    }
	  fixP->fx_size = 2;
d4963 2
a4964 1
	    fixP->fx_where += 2;
a4965 1
#endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */
d4972 3
a4974 3
	     symbol.  */
	  if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
	    as_bad_where (fixP->fx_file, fixP->fx_line,
d4977 4
a4980 5
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("unsupported relocation against %s"),
			  S_GET_NAME (fixP->fx_addsy));
	  fixP->fx_done = 1;
	  return;
d4986 1
a4986 1
      ppc_elf_validate_fix (fixP, seg);
d4988 1
a4988 1
      switch (fixP->fx_r_type)
d4990 1
d4992 3
a4994 8
	  if (ppc_obj64)
	    goto ctor64;
	  /* fall through */

	case BFD_RELOC_32:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  /* fall through */
d4998 1
d5000 1
a5000 1
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
d5005 3
a5007 5
	ctor64:
	  if (fixP->fx_pcrel)
	    fixP->fx_r_type = BFD_RELOC_64_PCREL;
	  /* fall through */

d5009 1
a5009 1
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
a5011 1

a5019 1
	case BFD_RELOC_16_BASEREL:
d5036 1
a5036 6
#ifdef OBJ_ELF
	case BFD_RELOC_PPC64_TOC16_LO:
	case BFD_RELOC_PPC64_TOC16_HI:
	case BFD_RELOC_PPC64_TOC16_HA:
#endif
	  if (fixP->fx_pcrel)
d5038 2
a5039 2
	      if (fixP->fx_addsy != NULL)
		as_bad_where (fixP->fx_file, fixP->fx_line,
d5041 2
a5042 2
			      bfd_get_reloc_code_name (fixP->fx_r_type),
			      S_GET_NAME (fixP->fx_addsy));
d5044 1
a5044 1
		as_bad_where (fixP->fx_file, fixP->fx_line,
d5046 1
a5046 1
			      bfd_get_reloc_code_name (fixP->fx_r_type));
d5049 1
a5049 1
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
d5057 1
a5057 1
	  if (fixP->fx_pcrel)
d5059 2
a5060 2
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HI (value), 2);
a5061 1

d5063 1
a5063 16
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HA (value), 2);
	  break;

#ifdef OBJ_ELF
	case BFD_RELOC_PPC64_HIGHER:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHER (value), 2);
	  break;

	case BFD_RELOC_PPC64_HIGHER_S:
	  if (fixP->fx_pcrel)
d5065 2
a5066 45
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHERA (value), 2);
	  break;

	case BFD_RELOC_PPC64_HIGHEST:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHEST (value), 2);
	  break;

	case BFD_RELOC_PPC64_HIGHEST_S:
	  if (fixP->fx_pcrel)
	    abort ();
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
			      PPC_HIGHESTA (value), 2);
	  break;

	case BFD_RELOC_PPC64_ADDR16_DS:
	case BFD_RELOC_PPC64_ADDR16_LO_DS:
	case BFD_RELOC_PPC64_GOT16_DS:
	case BFD_RELOC_PPC64_GOT16_LO_DS:
	case BFD_RELOC_PPC64_PLT16_LO_DS:
	case BFD_RELOC_PPC64_SECTOFF_DS:
	case BFD_RELOC_PPC64_SECTOFF_LO_DS:
	case BFD_RELOC_PPC64_TOC16_DS:
	case BFD_RELOC_PPC64_TOC16_LO_DS:
	case BFD_RELOC_PPC64_PLTGOT16_DS:
	case BFD_RELOC_PPC64_PLTGOT16_LO_DS:
	  if (fixP->fx_pcrel)
	    abort ();
	  {
	    unsigned char *where = fixP->fx_frag->fr_literal + fixP->fx_where;
	    unsigned long val;

	    if (target_big_endian)
	      val = bfd_getb16 (where);
	    else
	      val = bfd_getl16 (where);
	    val |= (value & 0xfffc);
	    if (target_big_endian)
	      bfd_putb16 ((bfd_vma) val, where);
	    else
	      bfd_putl16 ((bfd_vma) val, where);
	  }
a5068 42
	case BFD_RELOC_PPC_TLS:
	case BFD_RELOC_PPC_DTPMOD:
	case BFD_RELOC_PPC_TPREL16:
	case BFD_RELOC_PPC_TPREL16_LO:
	case BFD_RELOC_PPC_TPREL16_HI:
	case BFD_RELOC_PPC_TPREL16_HA:
	case BFD_RELOC_PPC_TPREL:
	case BFD_RELOC_PPC_DTPREL16:
	case BFD_RELOC_PPC_DTPREL16_LO:
	case BFD_RELOC_PPC_DTPREL16_HI:
	case BFD_RELOC_PPC_DTPREL16_HA:
	case BFD_RELOC_PPC_DTPREL:
	case BFD_RELOC_PPC_GOT_TLSGD16:
	case BFD_RELOC_PPC_GOT_TLSGD16_LO:
	case BFD_RELOC_PPC_GOT_TLSGD16_HI:
	case BFD_RELOC_PPC_GOT_TLSGD16_HA:
	case BFD_RELOC_PPC_GOT_TLSLD16:
	case BFD_RELOC_PPC_GOT_TLSLD16_LO:
	case BFD_RELOC_PPC_GOT_TLSLD16_HI:
	case BFD_RELOC_PPC_GOT_TLSLD16_HA:
	case BFD_RELOC_PPC_GOT_TPREL16:
	case BFD_RELOC_PPC_GOT_TPREL16_LO:
	case BFD_RELOC_PPC_GOT_TPREL16_HI:
	case BFD_RELOC_PPC_GOT_TPREL16_HA:
	case BFD_RELOC_PPC_GOT_DTPREL16:
	case BFD_RELOC_PPC_GOT_DTPREL16_LO:
	case BFD_RELOC_PPC_GOT_DTPREL16_HI:
	case BFD_RELOC_PPC_GOT_DTPREL16_HA:
	case BFD_RELOC_PPC64_TPREL16_DS:
	case BFD_RELOC_PPC64_TPREL16_LO_DS:
	case BFD_RELOC_PPC64_TPREL16_HIGHER:
	case BFD_RELOC_PPC64_TPREL16_HIGHERA:
	case BFD_RELOC_PPC64_TPREL16_HIGHEST:
	case BFD_RELOC_PPC64_TPREL16_HIGHESTA:
	case BFD_RELOC_PPC64_DTPREL16_DS:
	case BFD_RELOC_PPC64_DTPREL16_LO_DS:
	case BFD_RELOC_PPC64_DTPREL16_HIGHER:
	case BFD_RELOC_PPC64_DTPREL16_HIGHERA:
	case BFD_RELOC_PPC64_DTPREL16_HIGHEST:
	case BFD_RELOC_PPC64_DTPREL16_HIGHESTA:
	  break;
#endif
d5070 1
a5070 1
	     bytes, rather than 2, so offset it here appropriately.  */
d5072 1
a5072 1
	  if (fixP->fx_pcrel)
d5075 1
a5075 1
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where
d5081 1
a5081 1
	  if (fixP->fx_pcrel)
d5084 1
a5084 1
	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
d5090 1
a5090 1
	  if (!fixP->fx_pcrel && !fixP->fx_done)
d5093 4
a5096 4
	  if (fixP->fx_done)
	    {
	      char *where;
	      unsigned long insn;
d5098 21
a5118 21
	      /* Fetch the instruction, insert the fully resolved operand
		 value, and stuff the instruction back again.  */
	      where = fixP->fx_frag->fr_literal + fixP->fx_where;
	      if (target_big_endian)
		insn = bfd_getb32 ((unsigned char *) where);
	      else
		insn = bfd_getl32 ((unsigned char *) where);
	      if ((value & 3) != 0)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("must branch to an address a multiple of 4"));
	      if ((offsetT) value < -0x40000000
		  || (offsetT) value >= 0x40000000)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("@@local or @@plt branch destination is too far away, %ld bytes"),
			      (long) value);
	      insn = insn | (value & 0x03fffffc);
	      if (target_big_endian)
		bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	      else
		bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
	    }
d5122 5
a5126 5
	  fixP->fx_done = 0;
	  if (fixP->fx_addsy
	      && !S_IS_DEFINED (fixP->fx_addsy)
	      && !S_IS_WEAK (fixP->fx_addsy))
	    S_SET_WEAK (fixP->fx_addsy);
d5130 1
a5130 1
	  fixP->fx_done = 0;
a5132 7
#ifdef OBJ_ELF
	  /* Generated by reference to `sym@@tocbase'.  The sym is
	     ignored by the linker.  */
	case BFD_RELOC_PPC64_TOC:
	  fixP->fx_done = 0;
	  break;
#endif
d5135 2
a5136 2
		   _("Gas failure, reloc value %d\n"), fixP->fx_r_type);
	  fflush (stderr);
d5142 1
a5142 1
  fixP->fx_addnumber = value;
d5144 2
a5145 2
  if (fixP->fx_r_type != BFD_RELOC_PPC_TOC16)
    fixP->fx_addnumber = 0;
d5149 1
a5149 1
      fixP->fx_addnumber = 0;
d5153 2
a5154 2
      fixP->fx_addnumber =
	- bfd_get_section_vma (stdoutput, S_GET_SEGMENT (fixP->fx_addsy));
d5158 2
d5180 1
a5180 2
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d27 1
a27 1
#include "dw2gencfi.h"
d114 1
a114 1
static void ppc_change_csect PARAMS ((symbolS *, offsetT));
a184 7

/* '+' and '-' can be used as postfix predicate predictors for conditional
   branches.  So they need to be accepted as symbol characters.  */
const char ppc_symbol_chars[] = "+-";

/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
int ppc_cie_data_alignment;
d236 2
a816 101

/* Handle -m options that set cpu type, and .machine arg.  */

static int
parse_cpu (const char *arg)
{
  /* -mpwrx and -mpwr2 mean to assemble for the IBM POWER/2
     (RIOS2).  */
  if (strcmp (arg, "pwrx") == 0 || strcmp (arg, "pwr2") == 0)
    ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_POWER2 | PPC_OPCODE_32;
  /* -mpwr means to assemble for the IBM POWER (RIOS1).  */
  else if (strcmp (arg, "pwr") == 0)
    ppc_cpu = PPC_OPCODE_POWER | PPC_OPCODE_32;
  /* -m601 means to assemble for the PowerPC 601, which includes
     instructions that are holdovers from the Power.  */
  else if (strcmp (arg, "601") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_601 | PPC_OPCODE_32);
  /* -mppc, -mppc32, -m603, and -m604 mean to assemble for the
     PowerPC 603/604.  */
  else if (strcmp (arg, "ppc") == 0
	   || strcmp (arg, "ppc32") == 0
	   || strcmp (arg, "603") == 0
	   || strcmp (arg, "604") == 0)
    ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
  /* -m403 and -m405 mean to assemble for the PowerPC 403/405.  */
  else if (strcmp (arg, "403") == 0
	   || strcmp (arg, "405") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_403 | PPC_OPCODE_32);
  else if (strcmp (arg, "440") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32
	       | PPC_OPCODE_440 | PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI);
  else if (strcmp (arg, "7400") == 0
	   || strcmp (arg, "7410") == 0
	   || strcmp (arg, "7450") == 0
	   || strcmp (arg, "7455") == 0)
    ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
	       | PPC_OPCODE_ALTIVEC | PPC_OPCODE_32);
  else if (strcmp (arg, "altivec") == 0)
    {
      if (ppc_cpu == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_ALTIVEC;
      else
	ppc_cpu |= PPC_OPCODE_ALTIVEC;
    }
  else if (strcmp (arg, "e500") == 0 || strcmp (arg, "e500x2") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
		 | PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
		 | PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
		 | PPC_OPCODE_RFMCI);
    }
  else if (strcmp (arg, "spe") == 0)
    {
      if (ppc_cpu == 0)
	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_SPE | PPC_OPCODE_EFS;
      else
	ppc_cpu |= PPC_OPCODE_SPE;
    }
  /* -mppc64 and -m620 mean to assemble for the 64-bit PowerPC
     620.  */
  else if (strcmp (arg, "ppc64") == 0 || strcmp (arg, "620") == 0)
    {
      ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
    }
  else if (strcmp (arg, "ppc64bridge") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_64_BRIDGE | PPC_OPCODE_64);
    }
  /* -mbooke/-mbooke32 mean enable 32-bit BookE support.  */
  else if (strcmp (arg, "booke") == 0 || strcmp (arg, "booke32") == 0)
    {
      ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_32;
    }
  /* -mbooke64 means enable 64-bit BookE support.  */
  else if (strcmp (arg, "booke64") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE
		 | PPC_OPCODE_BOOKE64 | PPC_OPCODE_64);
    }
  else if (strcmp (arg, "power4") == 0)
    {
      ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
		 | PPC_OPCODE_64 | PPC_OPCODE_POWER4);
    }
  /* -mcom means assemble for the common intersection between Power
     and PowerPC.  At present, we just allow the union, rather
     than the intersection.  */
  else if (strcmp (arg, "com") == 0)
    ppc_cpu = PPC_OPCODE_COMMON | PPC_OPCODE_32;
  /* -many means to assemble for any architecture (PWR/PWRX/PPC).  */
  else if (strcmp (arg, "any") == 0)
    ppc_cpu |= PPC_OPCODE_ANY;
  else
    return 0;

  return 1;
}

d884 86
a969 2
      if (parse_cpu (arg))
	;
a1062 2
-a32			generate ELF32/XCOFF32\n\
-a64			generate ELF64/XCOFF64\n\
d1069 1
a1069 2
-m403, -m405		generate code for PowerPC 403/405\n\
-m440			generate code for PowerPC 440\n\
d1071 1
a1071 2
			generate code For PowerPC 7400/7410/7450/7455\n"));
  fprintf (stream, _("\
d1077 1
d1079 3
a1081 1
-many			generate code for any architecture (PWR/PWRX/PPC)\n"));
a1082 1
-maltivec		generate code for AltiVec\n\
d1084 1
a1084 3
-mspe			generate code for Motorola SPE instructions\n\
-mregnames		Allow symbolic names for registers\n\
-mno-regnames		Do not allow symbolic names for registers\n"));
d1090 1
a1090 1
-mlittle, -mlittle-endian, -l, -le\n\
d1092 1
a1092 2
-mbig, -mbig-endian, -b, -be\n\
			generate code for a big endian machine\n\
d1108 1
a1108 1
  if ((ppc_cpu & ~PPC_OPCODE_ANY) == 0)
d1111 1
a1111 1
	ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
d1114 1
a1114 1
	ppc_cpu |= PPC_OPCODE_COMMON | PPC_OPCODE_32;
d1116 1
a1116 1
	ppc_cpu |= PPC_OPCODE_POWER | PPC_OPCODE_32;
d1118 1
a1118 1
	ppc_cpu |= PPC_OPCODE_POWER | PPC_OPCODE_32;
d1122 1
a1122 1
	    ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_64;
d1124 1
a1124 1
	    ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
d1190 3
a1192 2
/* Insert opcodes and macros into hash tables.  Called at startup and
   for .cpu pseudo.  */
d1194 2
a1195 2
static void
ppc_setup_opcodes (void)
d1203 7
a1209 4
  if (ppc_hash != NULL)
    hash_die (ppc_hash);
  if (ppc_macro_hash != NULL)
    hash_die (ppc_macro_hash);
d1239 1
a1239 1
	  if (retval != NULL)
a1252 4
  if ((ppc_cpu & PPC_OPCODE_ANY) != 0)
    for (op = powerpc_opcodes; op < op_end; op++)
      hash_insert (ppc_hash, op->name, (PTR) op);

a1273 1
}
d1275 1
a1275 20
/* This function is called when the assembler starts up.  It is called
   after the options have been parsed and the output file has been
   opened.  */

void
md_begin ()
{
  ppc_set_cpu ();

  ppc_cie_data_alignment = ppc_obj64 ? -8 : -4;

#ifdef OBJ_ELF
  /* Set the ELF flags if desired.  */
  if (ppc_flags && !msolaris)
    bfd_set_private_flags (stdoutput, ppc_flags);
#endif

  ppc_setup_opcodes ();

  /* Tell the main code what the endianness is if it is not overridden
d1339 1
a1339 1
    md_number_to_chars (p, (valueT) ppc_apuinfo_num * 4, 4);
d1449 2
a1450 4
    unsigned int length : 8;
    unsigned int valid32 : 1;
    unsigned int valid64 : 1;
    unsigned int reloc;
d1460 1
a1460 3
#define MAP(str, reloc)   { str, sizeof (str) - 1, 1, 1, reloc }
#define MAP32(str, reloc) { str, sizeof (str) - 1, 1, 0, reloc }
#define MAP64(str, reloc) { str, sizeof (str) - 1, 0, 1, reloc }
d1463 88
a1550 86
    MAP ("l",			BFD_RELOC_LO16),
    MAP ("h",			BFD_RELOC_HI16),
    MAP ("ha",			BFD_RELOC_HI16_S),
    MAP ("brtaken",		BFD_RELOC_PPC_B16_BRTAKEN),
    MAP ("brntaken",		BFD_RELOC_PPC_B16_BRNTAKEN),
    MAP ("got",			BFD_RELOC_16_GOTOFF),
    MAP ("got@@l",		BFD_RELOC_LO16_GOTOFF),
    MAP ("got@@h",		BFD_RELOC_HI16_GOTOFF),
    MAP ("got@@ha",		BFD_RELOC_HI16_S_GOTOFF),
    MAP ("plt@@l",		BFD_RELOC_LO16_PLTOFF),
    MAP ("plt@@h",		BFD_RELOC_HI16_PLTOFF),
    MAP ("plt@@ha",		BFD_RELOC_HI16_S_PLTOFF),
    MAP ("copy",		BFD_RELOC_PPC_COPY),
    MAP ("globdat",		BFD_RELOC_PPC_GLOB_DAT),
    MAP ("sectoff",		BFD_RELOC_16_BASEREL),
    MAP ("sectoff@@l",		BFD_RELOC_LO16_BASEREL),
    MAP ("sectoff@@h",		BFD_RELOC_HI16_BASEREL),
    MAP ("sectoff@@ha",		BFD_RELOC_HI16_S_BASEREL),
    MAP ("tls",			BFD_RELOC_PPC_TLS),
    MAP ("dtpmod",		BFD_RELOC_PPC_DTPMOD),
    MAP ("dtprel",		BFD_RELOC_PPC_DTPREL),
    MAP ("dtprel@@l",		BFD_RELOC_PPC_DTPREL16_LO),
    MAP ("dtprel@@h",		BFD_RELOC_PPC_DTPREL16_HI),
    MAP ("dtprel@@ha",		BFD_RELOC_PPC_DTPREL16_HA),
    MAP ("tprel",		BFD_RELOC_PPC_TPREL),
    MAP ("tprel@@l",		BFD_RELOC_PPC_TPREL16_LO),
    MAP ("tprel@@h",		BFD_RELOC_PPC_TPREL16_HI),
    MAP ("tprel@@ha",		BFD_RELOC_PPC_TPREL16_HA),
    MAP ("got@@tlsgd",		BFD_RELOC_PPC_GOT_TLSGD16),
    MAP ("got@@tlsgd@@l",		BFD_RELOC_PPC_GOT_TLSGD16_LO),
    MAP ("got@@tlsgd@@h",		BFD_RELOC_PPC_GOT_TLSGD16_HI),
    MAP ("got@@tlsgd@@ha",	BFD_RELOC_PPC_GOT_TLSGD16_HA),
    MAP ("got@@tlsld",		BFD_RELOC_PPC_GOT_TLSLD16),
    MAP ("got@@tlsld@@l",		BFD_RELOC_PPC_GOT_TLSLD16_LO),
    MAP ("got@@tlsld@@h",		BFD_RELOC_PPC_GOT_TLSLD16_HI),
    MAP ("got@@tlsld@@ha",	BFD_RELOC_PPC_GOT_TLSLD16_HA),
    MAP ("got@@dtprel",		BFD_RELOC_PPC_GOT_DTPREL16),
    MAP ("got@@dtprel@@l",	BFD_RELOC_PPC_GOT_DTPREL16_LO),
    MAP ("got@@dtprel@@h",	BFD_RELOC_PPC_GOT_DTPREL16_HI),
    MAP ("got@@dtprel@@ha",	BFD_RELOC_PPC_GOT_DTPREL16_HA),
    MAP ("got@@tprel",		BFD_RELOC_PPC_GOT_TPREL16),
    MAP ("got@@tprel@@l",		BFD_RELOC_PPC_GOT_TPREL16_LO),
    MAP ("got@@tprel@@h",		BFD_RELOC_PPC_GOT_TPREL16_HI),
    MAP ("got@@tprel@@ha",	BFD_RELOC_PPC_GOT_TPREL16_HA),
    MAP32 ("fixup",		BFD_RELOC_CTOR),
    MAP32 ("plt",		BFD_RELOC_24_PLT_PCREL),
    MAP32 ("pltrel24",		BFD_RELOC_24_PLT_PCREL),
    MAP32 ("local24pc",		BFD_RELOC_PPC_LOCAL24PC),
    MAP32 ("local",		BFD_RELOC_PPC_LOCAL24PC),
    MAP32 ("pltrel",		BFD_RELOC_32_PLT_PCREL),
    MAP32 ("sdarel",		BFD_RELOC_GPREL16),
    MAP32 ("naddr",		BFD_RELOC_PPC_EMB_NADDR32),
    MAP32 ("naddr16",		BFD_RELOC_PPC_EMB_NADDR16),
    MAP32 ("naddr@@l",		BFD_RELOC_PPC_EMB_NADDR16_LO),
    MAP32 ("naddr@@h",		BFD_RELOC_PPC_EMB_NADDR16_HI),
    MAP32 ("naddr@@ha",		BFD_RELOC_PPC_EMB_NADDR16_HA),
    MAP32 ("sdai16",		BFD_RELOC_PPC_EMB_SDAI16),
    MAP32 ("sda2rel",		BFD_RELOC_PPC_EMB_SDA2REL),
    MAP32 ("sda2i16",		BFD_RELOC_PPC_EMB_SDA2I16),
    MAP32 ("sda21",		BFD_RELOC_PPC_EMB_SDA21),
    MAP32 ("mrkref",		BFD_RELOC_PPC_EMB_MRKREF),
    MAP32 ("relsect",		BFD_RELOC_PPC_EMB_RELSEC16),
    MAP32 ("relsect@@l",		BFD_RELOC_PPC_EMB_RELST_LO),
    MAP32 ("relsect@@h",		BFD_RELOC_PPC_EMB_RELST_HI),
    MAP32 ("relsect@@ha",	BFD_RELOC_PPC_EMB_RELST_HA),
    MAP32 ("bitfld",		BFD_RELOC_PPC_EMB_BIT_FLD),
    MAP32 ("relsda",		BFD_RELOC_PPC_EMB_RELSDA),
    MAP32 ("xgot",		BFD_RELOC_PPC_TOC16),
    MAP64 ("higher",		BFD_RELOC_PPC64_HIGHER),
    MAP64 ("highera",		BFD_RELOC_PPC64_HIGHER_S),
    MAP64 ("highest",		BFD_RELOC_PPC64_HIGHEST),
    MAP64 ("highesta",		BFD_RELOC_PPC64_HIGHEST_S),
    MAP64 ("tocbase",		BFD_RELOC_PPC64_TOC),
    MAP64 ("toc",		BFD_RELOC_PPC_TOC16),
    MAP64 ("toc@@l",		BFD_RELOC_PPC64_TOC16_LO),
    MAP64 ("toc@@h",		BFD_RELOC_PPC64_TOC16_HI),
    MAP64 ("toc@@ha",		BFD_RELOC_PPC64_TOC16_HA),
    MAP64 ("dtprel@@higher",	BFD_RELOC_PPC64_DTPREL16_HIGHER),
    MAP64 ("dtprel@@highera",	BFD_RELOC_PPC64_DTPREL16_HIGHERA),
    MAP64 ("dtprel@@highest",	BFD_RELOC_PPC64_DTPREL16_HIGHEST),
    MAP64 ("dtprel@@highesta",	BFD_RELOC_PPC64_DTPREL16_HIGHESTA),
    MAP64 ("tprel@@higher",	BFD_RELOC_PPC64_TPREL16_HIGHER),
    MAP64 ("tprel@@highera",	BFD_RELOC_PPC64_TPREL16_HIGHERA),
    MAP64 ("tprel@@highest",	BFD_RELOC_PPC64_TPREL16_HIGHEST),
    MAP64 ("tprel@@highesta",	BFD_RELOC_PPC64_TPREL16_HIGHESTA),
    { (char *) 0, 0, 0, 0,	BFD_RELOC_UNUSED }
d1571 1
a1571 2
	&& memcmp (ident, ptr->string, ptr->length) == 0
	&& (ppc_obj64 ? ptr->valid64 : ptr->valid32))
d1575 7
d1610 1
a1610 2
	    && exp_p->X_op == O_symbol
	    && strcmp (S_GET_NAME (exp_p->X_add_symbol), ".TOC.") == 0)
d1612 3
a1614 2
	    /* Change the symbol so that the dummy .TOC. symbol can be
	       omitted from the object file.  */
d2092 7
a2098 8
     an optional operand separate the operands only with commas (in some
     cases parentheses are used, as in ``lwz 1,0(1)'' but such cases never
     have optional operands).  Most instructions with optional operands
     have only one.  Those that have more than one optional operand can
     take either all their operands or none.  So, before we start seriously
     parsing the operands, we check to see if we have optional operands,
     and if we do, we count the number of commas to see which operands
     have been omitted.  */
d2134 1
a2134 1
	     operands.  */
d2444 1
a2444 1
	      && (operand->flags & (PPC_OPERAND_DS | PPC_OPERAND_DQ)) != 0)
d2749 1
a2749 1
  return -1;
d2838 1
a2838 1
   symbols, and uses a different smclas.  The native Aix 4.3.3 assembler
a3002 1
  offsetT align;
d3017 2
a3018 1
  align = 2;
d3022 1
a3022 1
      align = get_absolute_expression ();
a3024 2
  ppc_change_csect (sym, align);

d3031 1
a3031 1
ppc_change_csect (sym, align)
a3032 1
     offsetT align;
a3041 2
      int is_code;
      segT sec;
a3046 1
      is_code = 0;
a3060 1
	  is_code = 1;
d3088 2
a3089 2
      sec = subseg_new (segment_name (S_GET_SEGMENT (sym)),
			symbol_get_tc (sym)->subseg);
a3095 6
      record_alignment (sec, align);
      if (is_code)
	frag_align_code (align, 0);
      else
	frag_align (align, 0, 0);

d3099 1
a3099 1
      symbol_get_tc (sym)->align = align;
d3137 1
a3137 1
  ppc_change_csect (sym, 2);
d3174 1
a3174 1
  ppc_change_csect (sym, 2);
d3380 1
a3380 1
   argument seems to be the label for the start of the function.  gcc
d3845 1
a3845 1
   relocatable symbol reference.  The size of the value to store
d3938 6
d3949 1
a3949 56
  char *cpu_string;
#define MAX_HISTORY 100
  static unsigned long *cpu_history;
  static int curr_hist;

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '"')
    {
      int len;
      cpu_string = demand_copy_C_string (&len);
    }
  else
    {
      char c;
      cpu_string = input_line_pointer;
      c = get_symbol_end ();
      cpu_string = xstrdup (cpu_string);
      *input_line_pointer = c;
    }

  if (cpu_string != NULL)
    {
      unsigned long old_cpu = ppc_cpu;
      char *p;

      for (p = cpu_string; *p != 0; p++)
	*p = TOLOWER (*p);

      if (strcmp (cpu_string, "push") == 0)
	{
	  if (cpu_history == NULL)
	    cpu_history = xmalloc (MAX_HISTORY * sizeof (*cpu_history));

	  if (curr_hist >= MAX_HISTORY)
	    as_bad (_(".machine stack overflow"));
	  else
	    cpu_history[curr_hist++] = ppc_cpu;
	}
      else if (strcmp (cpu_string, "pop") == 0)
	{
	  if (curr_hist <= 0)
	    as_bad (_(".machine stack underflow"));
	  else
	    ppc_cpu = cpu_history[--curr_hist];
	}
      else if (parse_cpu (cpu_string))
	;
      else
	as_bad (_("invalid machine `%s'"), cpu_string);

      if (ppc_cpu != old_cpu)
	ppc_setup_opcodes ();
    }

  demand_empty_rest_of_line ();
d5044 1
a5044 1
  static bfd_vma vma = 0;
a5045 1
  vma = md_section_align (sec, vma);
d5711 1
a5711 1
	    unsigned long val, mask;
d5714 1
a5714 1
	      val = bfd_getb32 (where - 2);
d5716 2
a5717 7
	      val = bfd_getl32 (where);
	    mask = 0xfffc;
	    /* lq insns reserve the four lsbs.  */
	    if ((ppc_cpu & PPC_OPCODE_POWER4) != 0
		&& (val & (0x3f << 26)) == (56u << 26))
	      mask = 0xfff0;
	    val |= value & mask;
a5724 6
	case BFD_RELOC_PPC_B16_BRTAKEN:
	case BFD_RELOC_PPC_B16_BRNTAKEN:
	case BFD_RELOC_PPC_BA16_BRTAKEN:
	case BFD_RELOC_PPC_BA16_BRNTAKEN:
	  break;

d5780 4
a5783 13
	    {
	      /* This can occur if there is a bug in the input assembler, eg:
		 ".byte <undefined_symbol> - ."  */
	      if (fixP->fx_addsy)
		as_bad (_("Unable to handle reference to symbol %s"),
			S_GET_NAME (fixP->fx_addsy));
	      else
		as_bad (_("Unable to resolve expression"));
	      fixP->fx_done = 1;
	    }
	  else
	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
				value, 1);
a5889 46
}

void
ppc_cfi_frame_initial_instructions ()
{
  cfi_add_CFA_def_cfa (1, 0);
}

int
tc_ppc_regname_to_dw2regnum (const char *regname)
{
  unsigned int regnum = -1;
  unsigned int i;
  const char *p;
  char *q;
  static struct { char *name; int dw2regnum; } regnames[] =
    {
      { "sp", 1 }, { "r.sp", 1 }, { "rtoc", 2 }, { "r.toc", 2 },
      { "mq", 64 }, { "lr", 65 }, { "ctr", 66 }, { "ap", 67 },
      { "cc", 68 }, { "xer", 76 }, { "vrsave", 109 }, { "vscr", 110 },
      { "spe_acc", 111 }, { "spefscr", 112 }
    };

  for (i = 0; i < ARRAY_SIZE (regnames); ++i)
    if (strcmp (regnames[i].name, regname) == 0)
      return regnames[i].dw2regnum;

  if (regname[0] == 'r' || regname[0] == 'f' || regname[0] == 'v')
    {
      p = regname + 1 + (regname[1] == '.');
      regnum = strtoul (p, &q, 10);
      if (p == q || *q || regnum >= 32)
	return -1;
      if (regname[0] == 'f')
	regnum += 32;
      else if (regname[0] == 'v')
	regnum += 77;
    }
  else if (regname[0] == 'c' && regname[1] == 'r')
    {
      p = regname + 2 + (regname[2] == '.');
      if (p[0] < '0' || p[0] > '7' || p[1])
	return -1;
      regnum = p[0] - '0' + 68;
    }
  return regnum;
@


