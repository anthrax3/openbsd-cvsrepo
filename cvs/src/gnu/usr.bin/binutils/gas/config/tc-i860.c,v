head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.54
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.52
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.48
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.44
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.46
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.38
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.42
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.40
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.36
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.34
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.30
	OPENBSD_5_0:1.5.0.28
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.26
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.24
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.20
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.22
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.18
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.16
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BINUTILS_2_15:1.1.1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	BINUTILS-2_14:1.1.1.4
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	binutils-2_11_2:1.1.1.3
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	BINUTILS-2_10_1:1.1.1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	BINUTILS-2_10:1.1.1.2
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.11.02.20.45.28;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.17.21.54.30;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.17.07.36;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.19.11.50;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.06.07;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.07;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.09.12.14.46.25;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.05.13.13.35.05;	author fgsch;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.17.20.42.30;	author drahn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.11.02.20.22.52;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* tc-i860.c -- Assembler for the Intel i860 architecture.
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   Brought back from the dead and completely reworked
   by Jason Eckhardt <jle@@cygnus.com>.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with GAS; see the file COPYING.  If not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include <string.h>
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/i860.h"
#include "elf/i860.h"


/* The opcode hash table.  */
static struct hash_control *op_hash = NULL;

/* These characters always start a comment.  */
const char comment_chars[] = "#!/";

/* These characters start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#/";

const char line_separator_chars[] = ";";

/* Characters that can be used to separate the mantissa from the exponent
   in floating point numbers.  */
const char EXP_CHARS[] = "eE";

/* Characters that indicate this number is a floating point constant.
   As in 0f12.456 or 0d1.2345e12.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* Register prefix (depends on syntax).  */
static char reg_prefix;

#define MAX_FIXUPS 2

struct i860_it
{
  char *error;
  unsigned long opcode;
  enum expand_type expand;
  struct i860_fi
  {
    expressionS exp;
    bfd_reloc_code_real_type reloc;
    int pcrel;
    valueT fup;
  } fi[MAX_FIXUPS];
} the_insn;

/* The current fixup count.  */
static int fc;

static char *expr_end;

/* Indicates error if a pseudo operation was expanded after a branch.  */
static char last_expand;

/* If true, then warn if any pseudo operations were expanded.  */
static int target_warn_expand = 0;

/* If true, then XP support is enabled.  */
static int target_xp = 0;

/* If true, then Intel syntax is enabled (default to AT&T/SVR4 syntax).  */
static int target_intel_syntax = 0;


/* Prototypes.  */
static void i860_process_insn (char *);
static void s_dual (int);
static void s_enddual (int);
static void s_atmp (int);
static void s_align_wrapper (int);
static int i860_get_expression (char *);
static bfd_reloc_code_real_type obtain_reloc_for_imm16 (fixS *, long *); 
#ifdef DEBUG_I860
static void print_insn (struct i860_it *);
#endif

const pseudo_typeS md_pseudo_table[] =
{
  {"align",   s_align_wrapper, 0},
  {"dual",    s_dual,          0},
  {"enddual", s_enddual,       0},
  {"atmp",    s_atmp,          0},
  {NULL,      0,               0},
};

/* Dual-instruction mode handling.  */
enum dual
{
  DUAL_OFF = 0, DUAL_ON, DUAL_DDOT, DUAL_ONDDOT,
};
static enum dual dual_mode = DUAL_OFF;

/* Handle ".dual" directive.  */
static void
s_dual (int ignore ATTRIBUTE_UNUSED)
{
  if (target_intel_syntax)
    dual_mode = DUAL_ON;
  else
    as_bad (_("Directive .dual available only with -mintel-syntax option"));
}

/* Handle ".enddual" directive.  */
static void
s_enddual (int ignore ATTRIBUTE_UNUSED)
{
  if (target_intel_syntax)
    dual_mode = DUAL_OFF;
  else
    as_bad (_("Directive .enddual available only with -mintel-syntax option"));
}

/* Temporary register used when expanding assembler pseudo operations.  */
static int atmp = 31;

static void
s_atmp (int ignore ATTRIBUTE_UNUSED)
{
  int temp;

  if (! target_intel_syntax)
    {
      as_bad (_("Directive .atmp available only with -mintel-syntax option"));
      demand_empty_rest_of_line ();
      return;
    }

  if (strncmp (input_line_pointer, "sp", 2) == 0)
    {
      input_line_pointer += 2;
      atmp = 2;
    }
  else if (strncmp (input_line_pointer, "fp", 2) == 0)
    {
      input_line_pointer += 2;
      atmp = 3;
    }
  else if (strncmp (input_line_pointer, "r", 1) == 0)
    {
      input_line_pointer += 1;
      temp = get_absolute_expression ();
      if (temp >= 0 && temp <= 31)
	atmp = temp;
      else
	as_bad (_("Unknown temporary pseudo register"));
    }
  else
    {
      as_bad (_("Unknown temporary pseudo register"));
    }
  demand_empty_rest_of_line ();
}

/* Handle ".align" directive depending on syntax mode.
   AT&T/SVR4 syntax uses the standard align directive.  However, 
   the Intel syntax additionally allows keywords for the alignment
   parameter: ".align type", where type is one of {.short, .long,
   .quad, .single, .double} representing alignments of 2, 4,
   16, 4, and 8, respectively.  */
static void
s_align_wrapper (int arg)
{
  char *parm = input_line_pointer;

  if (target_intel_syntax)
    {
      /* Replace a keyword with the equivalent integer so the
         standard align routine can parse the directive.  */
      if (strncmp (parm, ".short", 6) == 0)
        strncpy (parm, "     2", 6);
      else if (strncmp (parm, ".long", 5) == 0)
        strncpy (parm, "    4", 5);
      else if (strncmp (parm, ".quad", 5) == 0)
        strncpy (parm, "   16", 5);
      else if (strncmp (parm, ".single", 7) == 0)
        strncpy (parm, "      4", 7);
      else if (strncmp (parm, ".double", 7) == 0)
        strncpy (parm, "      8", 7);
     
      while (*input_line_pointer == ' ')
        ++input_line_pointer;
    }

  s_align_bytes (arg);
}

/* This function is called once, at assembler startup time.  It should
   set up all the tables and data structures that the MD part of the
   assembler will need.  */
void
md_begin (void)
{
  const char *retval = NULL;
  int lose = 0;
  unsigned int i = 0;

  op_hash = hash_new ();

  while (i860_opcodes[i].name != NULL)
    {
      const char *name = i860_opcodes[i].name;
      retval = hash_insert (op_hash, name, (PTR)&i860_opcodes[i]);
      if (retval != NULL)
	{
	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
		   i860_opcodes[i].name, retval);
	  lose = 1;
	}
      do
	{
	  if (i860_opcodes[i].match & i860_opcodes[i].lose)
	    {
	      fprintf (stderr,
		       _("internal error: losing opcode: `%s' \"%s\"\n"),
		       i860_opcodes[i].name, i860_opcodes[i].args);
	      lose = 1;
	    }
	  ++i;
	}
      while (i860_opcodes[i].name != NULL
	     && strcmp (i860_opcodes[i].name, name) == 0);
    }

  if (lose)
    as_fatal (_("Defective assembler.  No assembly attempted."));

  /* Set the register prefix for either Intel or AT&T/SVR4 syntax.  */
  reg_prefix = target_intel_syntax ? 0 : '%';
}

/* This is the core of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function emits the frags/bytes
   it assembles to.  */
void
md_assemble (char *str)
{
  char *destp;
  int num_opcodes = 1;
  int i;
  struct i860_it pseudo[3];

  assert (str);
  fc = 0;

  /* Assemble the instruction.  */
  i860_process_insn (str);

  /* Check for expandable flag to produce pseudo-instructions.  This
     is an undesirable feature that should be avoided.  */
  if (the_insn.expand != 0 && the_insn.expand != XP_ONLY
      && ! (the_insn.fi[0].fup & (OP_SEL_HA | OP_SEL_H | OP_SEL_L | OP_SEL_GOT
			    | OP_SEL_GOTOFF | OP_SEL_PLT)))
    {
      for (i = 0; i < 3; i++)
	pseudo[i] = the_insn;

      fc = 1;
      switch (the_insn.expand)
	{

	case E_DELAY:
	  num_opcodes = 1;
	  break;

	case E_MOV:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 15)
		  && the_insn.fi[0].exp.X_add_number >= -(1 << 15)))
	    break;

	  /* Emit "or l%const,r0,ireg_dest".  */
	  pseudo[0].opcode = (the_insn.opcode & 0x001f0000) | 0xe4000000;
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);

	  /* Emit "orh h%const,ireg_dest,ireg_dest".  */
	  pseudo[1].opcode = (the_insn.opcode & 0x03ffffff) | 0xec000000
			      | ((the_insn.opcode & 0x001f0000) << 5);
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);

	  num_opcodes = 2;
	  break;

	case E_ADDR:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 15)
		  && the_insn.fi[0].exp.X_add_number >= -(1 << 15)))
	    break;

	  /* Emit "orh ha%addr_expr,ireg_src2,r31".  */
	  pseudo[0].opcode = 0xec000000 | (the_insn.opcode & 0x03e00000)
			     | (atmp << 16);
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_HA);

	  /* Emit "l%addr_expr(r31),ireg_dest".  We pick up the fixup
	     information from the original instruction.   */
	  pseudo[1].opcode = (the_insn.opcode & ~0x03e00000) | (atmp << 21);
	  pseudo[1].fi[0].fup = the_insn.fi[0].fup | OP_SEL_L;

	  num_opcodes = 2;
	  break;

	case E_U32:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 16)
		  && the_insn.fi[0].exp.X_add_number >= 0))
	    break;

	  /* Emit "$(opcode)h h%const,ireg_src2,r31".  */
	  pseudo[0].opcode = (the_insn.opcode & 0xf3e0ffff) | 0x0c000000
			      | (atmp << 16);
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);

	  /* Emit "$(opcode) l%const,r31,ireg_dest".  */
	  pseudo[1].opcode = (the_insn.opcode & 0xf01f0000) | 0x04000000
			      | (atmp << 21);
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);

	  num_opcodes = 2;
	  break;

	case E_AND:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 16)
		  && the_insn.fi[0].exp.X_add_number >= 0))
	    break;

	  /* Emit "andnot h%const,ireg_src2,r31".  */
	  pseudo[0].opcode = (the_insn.opcode & 0x03e0ffff) | 0xd4000000
			      | (atmp << 16);
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);
	  pseudo[0].fi[0].exp.X_add_number =
            -1 - the_insn.fi[0].exp.X_add_number;

	  /* Emit "andnot l%const,r31,ireg_dest".  */
	  pseudo[1].opcode = (the_insn.opcode & 0x001f0000) | 0xd4000000
			      | (atmp << 21);
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);
	  pseudo[1].fi[0].exp.X_add_number =
            -1 - the_insn.fi[0].exp.X_add_number;

	  num_opcodes = 2;
	  break;

	case E_S32:
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 15)
		  && the_insn.fi[0].exp.X_add_number >= -(1 << 15)))
	    break;

	  /* Emit "orh h%const,r0,r31".  */
	  pseudo[0].opcode = 0xec000000 | (atmp << 16);
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);

	  /* Emit "or l%const,r31,r31".  */
	  pseudo[1].opcode = 0xe4000000 | (atmp << 21) | (atmp << 16);
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);

	  /* Emit "r31,ireg_src2,ireg_dest".  */
	  pseudo[2].opcode = (the_insn.opcode & ~0x0400ffff) | (atmp << 11);
	  pseudo[2].fi[0].fup = OP_IMM_S16;

	  num_opcodes = 3;
	  break;

	default:
	  as_fatal (_("failed sanity check."));
	}

      the_insn = pseudo[0];

      /* Warn if an opcode is expanded after a delayed branch.  */
      if (num_opcodes > 1 && last_expand == 1)
	as_warn (_("Expanded opcode after delayed branch: `%s'"), str);

      /* Warn if an opcode is expanded in dual mode.  */
      if (num_opcodes > 1 && dual_mode != DUAL_OFF)
	as_warn (_("Expanded opcode in dual mode: `%s'"), str);

      /* Notify if any expansions happen.  */
      if (target_warn_expand && num_opcodes > 1)
	as_warn (_("An instruction was expanded (%s)"), str);
    }

  i = 0;
  do
    {
      int tmp;

      /* Output the opcode.  Note that the i860 always reads instructions
	 as little-endian data.  */
      destp = frag_more (4);
      number_to_chars_littleendian (destp, the_insn.opcode, 4);

      /* Check for expanded opcode after branch or in dual mode.  */
      last_expand = the_insn.fi[0].pcrel;

      /* Output the symbol-dependent stuff.  Only btne and bte will ever
         loop more than once here, since only they (possibly) have more
         than one fixup.  */
      for (tmp = 0; tmp < fc; tmp++)
        {
          if (the_insn.fi[tmp].fup != OP_NONE)
	    {
	      fixS *fix;
	      fix = fix_new_exp (frag_now,
			         destp - frag_now->fr_literal,
			         4,
			         &the_insn.fi[tmp].exp,
			         the_insn.fi[tmp].pcrel,
			         the_insn.fi[tmp].reloc);

	     /* Despite the odd name, this is a scratch field.  We use
	        it to encode operand type information.  */
	     fix->fx_addnumber = the_insn.fi[tmp].fup;
	   }
        }
      the_insn = pseudo[++i];
    }
  while (--num_opcodes > 0);

}

/* Assemble the instruction pointed to by STR.  */
static void
i860_process_insn (char *str)
{
  char *s;
  const char *args;
  char c;
  struct i860_opcode *insn;
  char *args_start;
  unsigned long opcode;
  unsigned int mask;
  int match = 0;
  int comma = 0;

#if 1 /* For compiler warnings.  */
  args = 0;
  insn = 0;
  args_start = 0;
  opcode = 0;
#endif

  for (s = str; ISLOWER (*s) || *s == '.' || *s == '3'
       || *s == '2' || *s == '1'; ++s)
    ;

  switch (*s)
    {
    case '\0':
      break;

    case ',':
      comma = 1;

      /*FALLTHROUGH*/

    case ' ':
      *s++ = '\0';
      break;

    default:
      as_fatal (_("Unknown opcode: `%s'"), str);
    }

  /* Check for dual mode ("d.") opcode prefix.  */
  if (strncmp (str, "d.", 2) == 0)
    {
      if (dual_mode == DUAL_ON)
	dual_mode = DUAL_ONDDOT;
      else
	dual_mode = DUAL_DDOT;
      str += 2;
    }

  if ((insn = (struct i860_opcode *) hash_find (op_hash, str)) == NULL)
    {
      if (dual_mode == DUAL_DDOT || dual_mode == DUAL_ONDDOT)
	str -= 2;
      as_bad (_("Unknown opcode: `%s'"), str);
      return;
    }

  if (comma)
    *--s = ',';

  args_start = s;
  for (;;)
    {
      int t;
      opcode = insn->match;
      memset (&the_insn, '\0', sizeof (the_insn));
      fc = 0;
      for (t = 0; t < MAX_FIXUPS; t++)
        {
          the_insn.fi[t].reloc = BFD_RELOC_NONE;
          the_insn.fi[t].pcrel = 0;
          the_insn.fi[t].fup = OP_NONE;
        }

      /* Build the opcode, checking as we go that the operands match.  */
      for (args = insn->args; ; ++args)
	{
          if (fc > MAX_FIXUPS)
            abort ();

	  switch (*args)
	    {

	    /* End of args.  */
	    case '\0':
	      if (*s == '\0')
		match = 1;
	      break;

	    /* These must match exactly.  */
	    case '+':
	    case '(':
	    case ')':
	    case ',':
	    case ' ':
	      if (*s++ == *args)
		continue;
	      break;

	    /* Must be at least one digit.  */
	    case '#':
	      if (ISDIGIT (*s++))
		{
		  while (ISDIGIT (*s))
		    ++s;
		  continue;
		}
	      break;

	    /* Next operand must be a register.  */
	    case '1':
	    case '2':
	    case 'd':
	      /* Check for register prefix if necessary.  */
	      if (reg_prefix && *s != reg_prefix)
		goto error;
	      else if (reg_prefix)
		s++;

	      switch (*s)
		{
		/* Frame pointer.  */
		case 'f':
		  s++;
		  if (*s++ == 'p')
		    {
		      mask = 0x3;
		      break;
		    }
		  goto error;

		/* Stack pointer.  */
		case 's':
		  s++;
		  if (*s++ == 'p')
		    {
		      mask = 0x2;
		      break;
		    }
		  goto error;

		/* Any register r0..r31.  */
		case 'r':
		  s++;
		  if (!ISDIGIT (c = *s++))
		    {
		      goto error;
		    }
		  if (ISDIGIT (*s))
		    {
		      if ((c = 10 * (c - '0') + (*s++ - '0')) >= 32)
			goto error;
		    }
		  else
		    c -= '0';
		  mask = c;
		  break;

		/* Not this opcode.  */
		default:
		  goto error;
		}

	      /* Obtained the register, now place it in the opcode.  */
	      switch (*args)
		{
		case '1':
		  opcode |= mask << 11;
		  continue;

		case '2':
		  opcode |= mask << 21;
		  continue;

		case 'd':
		  opcode |= mask << 16;
		  continue;

		}
	      break;

	    /* Next operand is a floating point register.  */
	    case 'e':
	    case 'f':
	    case 'g':
	      /* Check for register prefix if necessary.  */
	      if (reg_prefix && *s != reg_prefix)
		goto error;
	      else if (reg_prefix)
		s++;

	      if (*s++ == 'f' && ISDIGIT (*s))
		{
		  mask = *s++;
		  if (ISDIGIT (*s))
		    {
		      mask = 10 * (mask - '0') + (*s++ - '0');
		      if (mask >= 32)
			{
			  break;
			}
		    }
		  else
		    mask -= '0';

		  switch (*args)
		    {

		    case 'e':
		      opcode |= mask << 11;
		      continue;

		    case 'f':
		      opcode |= mask << 21;
		      continue;

		    case 'g':
		      opcode |= mask << 16;
		      if ((opcode & (1 << 10)) && mask != 0
			  && (mask == ((opcode >> 11) & 0x1f)))
			as_warn (_("Pipelined instruction: fsrc1 = fdest"));
		      continue;
		    }
		}
	      break;

	    /* Next operand must be a control register.  */
	    case 'c':
	      /* Check for register prefix if necessary.  */
	      if (reg_prefix && *s != reg_prefix)
		goto error;
	      else if (reg_prefix)
		s++;

	      if (strncmp (s, "fir", 3) == 0)
		{
		  opcode |= 0x0 << 21;
		  s += 3;
		  continue;
		}
	      if (strncmp (s, "psr", 3) == 0)
		{
		  opcode |= 0x1 << 21;
		  s += 3;
		  continue;
		}
	      if (strncmp (s, "dirbase", 7) == 0)
		{
		  opcode |= 0x2 << 21;
		  s += 7;
		  continue;
		}
	      if (strncmp (s, "db", 2) == 0)
		{
		  opcode |= 0x3 << 21;
		  s += 2;
		  continue;
		}
	      if (strncmp (s, "fsr", 3) == 0)
		{
		  opcode |= 0x4 << 21;
		  s += 3;
		  continue;
		}
	      if (strncmp (s, "epsr", 4) == 0)
		{
		  opcode |= 0x5 << 21;
		  s += 4;
		  continue;
		}
	      /* The remaining control registers are XP only.  */
	      if (target_xp && strncmp (s, "bear", 4) == 0)
		{
		  opcode |= 0x6 << 21;
		  s += 4;
		  continue;
		}
	      if (target_xp && strncmp (s, "ccr", 3) == 0)
		{
		  opcode |= 0x7 << 21;
		  s += 3;
		  continue;
		}
	      if (target_xp && strncmp (s, "p0", 2) == 0)
		{
		  opcode |= 0x8 << 21;
		  s += 2;
		  continue;
		}
	      if (target_xp && strncmp (s, "p1", 2) == 0)
		{
		  opcode |= 0x9 << 21;
		  s += 2;
		  continue;
		}
	      if (target_xp && strncmp (s, "p2", 2) == 0)
		{
		  opcode |= 0xa << 21;
		  s += 2;
		  continue;
		}
	      if (target_xp && strncmp (s, "p3", 2) == 0)
		{
		  opcode |= 0xb << 21;
		  s += 2;
		  continue;
		}
	      break;

	    /* 5-bit immediate in src1.  */
	    case '5':
	      if (! i860_get_expression (s))
		{
		  s = expr_end;
		  the_insn.fi[fc].fup |= OP_IMM_U5;
		  fc++;
		  continue;
		}
	      break;

	    /* 26-bit immediate, relative branch (lbroff).  */
	    case 'l':
	      the_insn.fi[fc].pcrel = 1;
	      the_insn.fi[fc].fup |= OP_IMM_BR26;
	      goto immediate;

	    /* 16-bit split immediate, relative branch (sbroff).  */
	    case 'r':
	      the_insn.fi[fc].pcrel = 1;
	      the_insn.fi[fc].fup |= OP_IMM_BR16;
	      goto immediate;

	    /* 16-bit split immediate.  */
	    case 's':
	      the_insn.fi[fc].fup |= OP_IMM_SPLIT16;
	      goto immediate;

	    /* 16-bit split immediate, byte aligned (st.b).  */
	    case 'S':
	      the_insn.fi[fc].fup |= OP_IMM_SPLIT16;
	      goto immediate;

	    /* 16-bit split immediate, half-word aligned (st.s).  */
	    case 'T':
	      the_insn.fi[fc].fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN2);
	      goto immediate;

	    /* 16-bit split immediate, word aligned (st.l).  */
	    case 'U':
	      the_insn.fi[fc].fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN4);
	      goto immediate;

	    /* 16-bit immediate.  */
	    case 'i':
	      the_insn.fi[fc].fup |= OP_IMM_S16;
	      goto immediate;

	    /* 16-bit immediate, byte aligned (ld.b).  */
	    case 'I':
	      the_insn.fi[fc].fup |= OP_IMM_S16;
	      goto immediate;

	    /* 16-bit immediate, half-word aligned (ld.s).  */
	    case 'J':
	      the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN2);
	      goto immediate;

	    /* 16-bit immediate, word aligned (ld.l, {p}fld.l, fst.l).  */
	    case 'K':
	      if (insn->name[0] == 'l')
		the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN4);
	      else
		the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE2 | OP_ALIGN4);
	      goto immediate;

	    /* 16-bit immediate, double-word aligned ({p}fld.d, fst.d).  */
	    case 'L':
	      the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN8);
	      goto immediate;

	    /* 16-bit immediate, quad-word aligned (fld.q, fst.q).  */
	    case 'M':
	      the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN16);

	      /*FALLTHROUGH*/

	      /* Handle the immediate for either the Intel syntax or
		 SVR4 syntax. The Intel syntax is "ha%immediate"
		 whereas SVR4 syntax is "[immediate]@@ha".  */
	    immediate:
	      if (target_intel_syntax == 0)
		{
		  /* AT&T/SVR4 syntax.  */
	          if (*s == ' ')
		    s++;

	          /* Note that if i860_get_expression() fails, we will still
	  	     have created U entries in the symbol table for the
		     'symbols' in the input string.  Try not to create U
		     symbols for registers, etc.  */
	          if (! i860_get_expression (s))
		    s = expr_end;
	          else
		    goto error;

	          if (strncmp (s, "@@ha", 3) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_HA;
		      s += 3;
		    }
	          else if (strncmp (s, "@@h", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_H;
		      s += 2;
		    }
	          else if (strncmp (s, "@@l", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_L;
		      s += 2;
		    }
	          else if (strncmp (s, "@@gotoff", 7) == 0
		           || strncmp (s, "@@GOTOFF", 7) == 0)
		    {
		      as_bad (_("Assembler does not yet support PIC"));
		      the_insn.fi[fc].fup |= OP_SEL_GOTOFF;
		      s += 7;
		    }
	          else if (strncmp (s, "@@got", 4) == 0
		           || strncmp (s, "@@GOT", 4) == 0)
		    {
		      as_bad (_("Assembler does not yet support PIC"));
		      the_insn.fi[fc].fup |= OP_SEL_GOT;
		      s += 4;
		    }
	          else if (strncmp (s, "@@plt", 4) == 0
		           || strncmp (s, "@@PLT", 4) == 0)
		    {
		      as_bad (_("Assembler does not yet support PIC"));
		      the_insn.fi[fc].fup |= OP_SEL_PLT;
		      s += 4;
		    }

	          the_insn.expand = insn->expand;
                  fc++;
              
	          continue;
		}
	      else
		{
		  /* Intel syntax.  */
	          if (*s == ' ')
		    s++;
	          if (strncmp (s, "ha%", 3) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_HA;
		      s += 3;
		    }
	          else if (strncmp (s, "h%", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_H;
		      s += 2;
		    }
	          else if (strncmp (s, "l%", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_L;
		      s += 2;
		    }
	          the_insn.expand = insn->expand;

	          /* Note that if i860_get_expression() fails, we will still
		     have created U entries in the symbol table for the
		     'symbols' in the input string.  Try not to create U
		     symbols for registers, etc.  */
	          if (! i860_get_expression (s))
		    s = expr_end;
	          else
		    goto error;

                  fc++;
	          continue;
		}
	      break;

	    default:
	      as_fatal (_("failed sanity check."));
	    }
	  break;
	}
    error:
      if (match == 0)
	{
	  /* Args don't match.  */
	  if (insn[1].name != NULL
	      && ! strcmp (insn->name, insn[1].name))
	    {
	      ++insn;
	      s = args_start;
	      continue;
	    }
	  else
	    {
	      as_bad (_("Illegal operands for %s"), insn->name);
	      return;
	    }
	}
      break;
    }

  /* Set the dual bit on this instruction if necessary.  */
  if (dual_mode != DUAL_OFF)
    {
      if ((opcode & 0xfc000000) == 0x48000000 || opcode == 0xb0000000)
        {
	  /* The instruction is a flop or a fnop, so set its dual bit
	     (but check that it is 8-byte aligned).  */
	  if (((frag_now->fr_address + frag_now_fix_octets ()) & 7) == 0)
	    opcode |= (1 << 9);
	  else
            as_bad (_("'d.%s' must be 8-byte aligned"), insn->name);

          if (dual_mode == DUAL_DDOT)
	    dual_mode = DUAL_OFF;
          else if (dual_mode == DUAL_ONDDOT)
	    dual_mode = DUAL_ON;
        }
      else if (dual_mode == DUAL_DDOT || dual_mode == DUAL_ONDDOT)
        as_bad (_("Prefix 'd.' invalid for instruction `%s'"), insn->name);
    }

  the_insn.opcode = opcode;

  /* Only recognize XP instructions when the user has requested it.  */
  if (insn->expand == XP_ONLY && ! target_xp)
    as_bad (_("Unknown opcode: `%s'"), insn->name);
}

static int
i860_get_expression (char *str)
{
  char *save_in;
  segT seg;

  save_in = input_line_pointer;
  input_line_pointer = str;
  seg = expression (&the_insn.fi[fc].exp);
  if (seg != absolute_section
      && seg != undefined_section
      && ! SEG_NORMAL (seg))
    {
      the_insn.error = _("bad segment");
      expr_end = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
  expr_end = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
}

/* Turn a string in input_line_pointer into a floating point constant of
   type TYPE, and store the appropriate bytes in *LITP.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is returned,
   or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

char *
md_atof (int type, char *litP, int *sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  for (wordP = words; prec--;)
    {
      md_number_to_chars (litP, (long) (*wordP++), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }
  return 0;
}

/* Write out in current endian mode.  */
void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

/* This should never be called for i860.  */
int
md_estimate_size_before_relax (register fragS *fragP ATTRIBUTE_UNUSED,
			       segT segtype ATTRIBUTE_UNUSED)
{
  as_fatal (_("i860_estimate_size_before_relax\n"));
}

#ifdef DEBUG_I860
static void
print_insn (struct i860_it *insn)
{
  if (insn->error)
    fprintf (stderr, "ERROR: %s\n", insn->error);

  fprintf (stderr, "opcode = 0x%08lx\t", insn->opcode);
  fprintf (stderr, "expand = 0x%x\t", insn->expand);
  fprintf (stderr, "reloc = %s\t\n",
	   bfd_get_reloc_code_name (insn->reloc));
  fprintf (stderr, "exp =  {\n");
  fprintf (stderr, "\t\tX_add_symbol = %s\n",
	   insn->exp.X_add_symbol ?
	   (S_GET_NAME (insn->exp.X_add_symbol) ?
	    S_GET_NAME (insn->exp.X_add_symbol) : "???") : "0");
  fprintf (stderr, "\t\tX_op_symbol = %s\n",
	   insn->exp.X_op_symbol ?
	   (S_GET_NAME (insn->exp.X_op_symbol) ?
	    S_GET_NAME (insn->exp.X_op_symbol) : "???") : "0");
  fprintf (stderr, "\t\tX_add_number = %lx\n",
	   insn->exp.X_add_number);
  fprintf (stderr, "}\n");
}
#endif /* DEBUG_I860 */


#ifdef OBJ_ELF
const char *md_shortopts = "VQ:";
#else
const char *md_shortopts = "";
#endif

#define OPTION_EB		(OPTION_MD_BASE + 0)
#define OPTION_EL		(OPTION_MD_BASE + 1)
#define OPTION_WARN_EXPAND	(OPTION_MD_BASE + 2)
#define OPTION_XP		(OPTION_MD_BASE + 3)
#define OPTION_INTEL_SYNTAX	(OPTION_MD_BASE + 4)

struct option md_longopts[] = {
  { "EB",	    no_argument, NULL, OPTION_EB },
  { "EL",	    no_argument, NULL, OPTION_EL },
  { "mwarn-expand", no_argument, NULL, OPTION_WARN_EXPAND },
  { "mxp",	    no_argument, NULL, OPTION_XP },
  { "mintel-syntax",no_argument, NULL, OPTION_INTEL_SYNTAX },
  { NULL,	    no_argument, NULL, 0 }
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    case OPTION_EB:
      target_big_endian = 1;
      break;

    case OPTION_EL:
      target_big_endian = 0;
      break;

    case OPTION_WARN_EXPAND:
      target_warn_expand = 1;
      break;

    case OPTION_XP:
      target_xp = 1;
      break;

    case OPTION_INTEL_SYNTAX:
      target_intel_syntax = 1;
      break;

#ifdef OBJ_ELF
    /* SVR4 argument compatibility (-V): print version ID.  */
    case 'V':
      print_version_id ();
      break;

    /* SVR4 argument compatibility (-Qy, -Qn): controls whether
       a .comment section should be emitted or not (ignored).  */
    case 'Q':
      break;
#endif

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
  -EL			  generate code for little endian mode (default)\n\
  -EB			  generate code for big endian mode\n\
  -mwarn-expand		  warn if pseudo operations are expanded\n\
  -mxp			  enable i860XP support (disabled by default)\n\
  -mintel-syntax	  enable Intel syntax (default to AT&T/SVR4)\n"));
#ifdef OBJ_ELF
  /* SVR4 compatibility flags.  */
  fprintf (stream, _("\
  -V			  print assembler version number\n\
  -Qy, -Qn		  ignored\n"));
#endif
}


/* We have no need to default values of symbols.  */
symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* The i860 denotes auto-increment with '++'.  */
void
md_operand (expressionS *exp)
{
  char *s;

  for (s = input_line_pointer; *s; s++)
    {
      if (s[0] == '+' && s[1] == '+')
	{
	  input_line_pointer += 2;
	  exp->X_op = O_register;
	  break;
	}
    }
}

/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segT segment ATTRIBUTE_UNUSED,
		  valueT size ATTRIBUTE_UNUSED)
{
  /* Byte alignment is fine.  */
  return size;
}

/* On the i860, a PC-relative offset is relative to the address of the
   offset plus its size.  */
long
md_pcrel_from (fixS *fixP)
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

/* Determine the relocation needed for non PC-relative 16-bit immediates.
   Also adjust the given immediate as necessary.  Finally, check that
   all constraints (such as alignment) are satisfied.   */
static bfd_reloc_code_real_type
obtain_reloc_for_imm16 (fixS *fix, long *val)
{
  valueT fup = fix->fx_addnumber;
  bfd_reloc_code_real_type reloc;

  if (fix->fx_pcrel)
    abort ();

  /* Check alignment restrictions.  */
  if ((fup & OP_ALIGN2) && (*val & 0x1))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 2 alignment"));
  else if ((fup & OP_ALIGN4) && (*val & 0x3))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 4 alignment"));
  else if ((fup & OP_ALIGN8) && (*val & 0x7))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 8 alignment"));
  else if ((fup & OP_ALIGN16) && (*val & 0xf))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 16 alignment"));

  if (fup & OP_SEL_HA)
    {
      *val = (*val >> 16) + (*val & 0x8000 ? 1 : 0);
      reloc = BFD_RELOC_860_HIGHADJ;
    }
  else if (fup & OP_SEL_H)
    {
      *val >>= 16;
      reloc = BFD_RELOC_860_HIGH;
    }
  else if (fup & OP_SEL_L)
    {
      int num_encode;
      if (fup & OP_IMM_SPLIT16)
	{
	  if (fup & OP_ENCODE1)
	    {
	      num_encode = 1;
	      reloc = BFD_RELOC_860_SPLIT1;
	    }
	  else if (fup & OP_ENCODE2)
	    {
	      num_encode = 2;
	      reloc = BFD_RELOC_860_SPLIT2;
	    }
	  else
	    {
	      num_encode = 0;
	      reloc = BFD_RELOC_860_SPLIT0;
	    }
	}
      else
	{
	  if (fup & OP_ENCODE1)
	    {
	      num_encode = 1;
	      reloc = BFD_RELOC_860_LOW1;
	    }
	  else if (fup & OP_ENCODE2)
	    {
	      num_encode = 2;
	      reloc = BFD_RELOC_860_LOW2;
	    }
	  else if (fup & OP_ENCODE3)
	    {
	      num_encode = 3;
	      reloc = BFD_RELOC_860_LOW3;
	    }
	  else
	    {
	      num_encode = 0;
	      reloc = BFD_RELOC_860_LOW0;
	    }
	}

      /* Preserve size encode bits.  */
      *val &= ~((1 << num_encode) - 1);
    }
  else
    {
      /* No selector.  What reloc do we generate (???)?  */
      reloc = BFD_RELOC_32;
    }

  return reloc;
}

/* Attempt to simplify or eliminate a fixup. To indicate that a fixup
   has been eliminated, set fix->fx_done. If fix->fx_addsy is non-NULL,
   we will have to generate a reloc entry.  */

void
md_apply_fix3 (fixS *fix, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *buf;
  long val = *valP;
  unsigned long insn;
  valueT fup;

  buf = fix->fx_frag->fr_literal + fix->fx_where;

  /* Recall that earlier we stored the opcode little-endian.  */
  insn = bfd_getl32 (buf);

  /* We stored a fix-up in this oddly-named scratch field.  */
  fup = fix->fx_addnumber;

  /* Determine the necessary relocations as well as inserting an
     immediate into the instruction.   */
  if (fup & OP_IMM_U5)
    {
      if (val & ~0x1f)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("5-bit immediate too large"));
      if (fix->fx_addsy)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("5-bit field must be absolute"));

      insn |= (val & 0x1f) << 11;
      bfd_putl32 (insn, buf);
      fix->fx_r_type = BFD_RELOC_NONE;
      fix->fx_done = 1;
    }
  else if (fup & OP_IMM_S16)
    {
      fix->fx_r_type = obtain_reloc_for_imm16 (fix, &val);

      /* Insert the immediate.  */
      if (fix->fx_addsy)
	fix->fx_done = 0;
      else
	{
	  insn |= val & 0xffff;
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup & OP_IMM_U16)
    abort ();

  else if (fup & OP_IMM_SPLIT16)
    {
      fix->fx_r_type = obtain_reloc_for_imm16 (fix, &val);

      /* Insert the immediate.  */
      if (fix->fx_addsy)
	fix->fx_done = 0;
      else
	{
	  insn |= val & 0x7ff;
	  insn |= (val & 0xf800) << 5;
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup & OP_IMM_BR16)
    {
      if (val & 0x3)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("A branch offset requires 0 MOD 4 alignment"));

      val = val >> 2;

      /* Insert the immediate.  */
      if (fix->fx_addsy)
	{
	  fix->fx_done = 0;
	  fix->fx_r_type = BFD_RELOC_860_PC16;
	}
      else
	{
	  insn |= (val & 0x7ff);
	  insn |= ((val & 0xf800) << 5);
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup & OP_IMM_BR26)
    {
      if (val & 0x3)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("A branch offset requires 0 MOD 4 alignment"));

      val >>= 2;

      /* Insert the immediate.  */
      if (fix->fx_addsy)
	{
	  fix->fx_r_type = BFD_RELOC_860_PC26;
	  fix->fx_done = 0;
	}
      else
	{
	  insn |= (val & 0x3ffffff);
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup != OP_NONE)
    {
      as_bad_where (fix->fx_file, fix->fx_line,
		    _("Unrecognized fix-up (0x%08lx)"), (unsigned long) fup);
      abort ();
    }
  else
    {
      /* I believe only fix-ups such as ".long .ep.main-main+0xc8000000"
 	 reach here (???).  */
      if (fix->fx_addsy)
	{
	  fix->fx_r_type = BFD_RELOC_32;
	  fix->fx_done = 0;
	}
      else
	{
	  insn |= (val & 0xffffffff);
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
}

/* Generate a machine dependent reloc from a fixup.  */
arelent*
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED,
	      fixS *fixp)
{
  arelent *reloc;

  reloc = xmalloc (sizeof (*reloc));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->addend = fixp->fx_offset;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (! reloc->howto)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    "Cannot represent %s relocation in object file",
                    bfd_get_reloc_code_name (fixp->fx_r_type));
    }
  return reloc;
}

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
i860_handle_align (fragS *fragp)
{
  /* Instructions are always stored little-endian on the i860.  */
  static const unsigned char le_nop[] = { 0x00, 0x00, 0x00, 0xA0 };

  int bytes;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;

  /* Make sure we are on a 4-byte boundary, in case someone has been
     putting data into a text section.  */
  if (bytes & 3)
    {
      int fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      fragp->fr_fix += fix;
    }

  memcpy (p, le_nop, 4);
  fragp->fr_var = 4;
}

/* This is called after a user-defined label is seen.  We check
   if the label has a double colon (valid in Intel syntax mode only),
   in which case it should be externalized.  */

void
i860_check_label (symbolS *labelsym)
{
  /* At this point, the current line pointer is sitting on the character
     just after the first colon on the label.  */ 
  if (target_intel_syntax && *input_line_pointer == ':')
    {
      S_SET_EXTERNAL (labelsym);
      input_line_pointer++;
    }
}

@


1.4
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d2 1
a2 1
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002
a31 5
/* Defined by default since this is primarily a SVR4/860 assembler.
   However, I'm trying to leave the door open for Intel syntax. Of course,
   if full support for anything other than SVR4 is done, then we should
   select this based on a command-line flag.  */
#define SYNTAX_SVR4
d52 4
a55 6
/* Register prefix.  */
#ifdef SYNTAX_SVR4
static const char reg_prefix = '%';
#else
static const char reg_prefix = 0;
#endif
a60 1
  expressionS exp;
d62 7
a68 3
  bfd_reloc_code_real_type reloc;
  int pcrel;
  valueT fup;
d71 3
d82 7
d90 7
a96 7
static void i860_process_insn	PARAMS ((char *));
static void s_dual		PARAMS ((int));
static void s_enddual		PARAMS ((int));
static void s_atmp		PARAMS ((int));
static int i860_get_expression	PARAMS ((char *));
static bfd_reloc_code_real_type obtain_reloc_for_imm16
  PARAMS ((fixS *, long *));
d98 1
a98 1
static void print_insn		PARAMS ((struct i860_it *));
d103 5
a107 7
#ifdef OBJ_ELF
  {"align",   s_align_bytes, 0},
#endif
  {"dual",    s_dual,        0},
  {"enddual", s_enddual,     0},
  {"atmp",    s_atmp,        0},
  {NULL,      0,             0},
d119 1
a119 2
s_dual (ignore)
     int ignore ATTRIBUTE_UNUSED;
d121 4
a124 1
  dual_mode = DUAL_ON;
d129 1
a129 2
s_enddual (ignore)
     int ignore ATTRIBUTE_UNUSED;
d131 4
a134 1
  dual_mode = DUAL_OFF;
d141 1
a141 2
s_atmp (ignore)
     int ignore ATTRIBUTE_UNUSED;
d143 9
a151 1
  register int temp;
d178 33
d215 1
a215 1
md_begin ()
d250 3
d259 1
a259 2
md_assemble (str)
     char *str;
d267 1
d274 2
a275 2
  if (the_insn.expand != 0
      && ! (the_insn.fup & (OP_SEL_HA | OP_SEL_H | OP_SEL_L | OP_SEL_GOT
d281 1
d290 4
a293 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 15)
		  && the_insn.exp.X_add_number >= -(1 << 15)))
d298 1
a298 1
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_L);
d303 1
a303 1
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_H);
d309 4
a312 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 15)
		  && the_insn.exp.X_add_number >= -(1 << 15)))
d315 4
a318 3
	  /* Emit "orh ha%addr_expr,r0,r31".  */
	  pseudo[0].opcode = 0xec000000 | (atmp << 16);
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_HA);
d323 1
a323 1
	  pseudo[1].fup = the_insn.fup | OP_SEL_L;
d329 4
a332 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 16)
		  && the_insn.exp.X_add_number >= 0))
d338 1
a338 1
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_H);
d343 1
a343 1
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_L);
d349 4
a352 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 16)
		  && the_insn.exp.X_add_number >= 0))
d358 3
a360 2
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_H);
	  pseudo[0].exp.X_add_number = -1 - the_insn.exp.X_add_number;
d365 3
a367 2
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_L);
	  pseudo[1].exp.X_add_number = -1 - the_insn.exp.X_add_number;
d373 4
a376 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 15)
		  && the_insn.exp.X_add_number >= -(1 << 15)))
d381 1
a381 1
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_H);
d385 1
a385 1
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_L);
d389 1
a389 1
	  pseudo[2].fup = OP_IMM_S16;
d416 2
d424 1
a424 1
      last_expand = the_insn.pcrel;
d426 20
a445 15
      /* Output the symbol-dependent stuff.  */
      if (the_insn.fup != OP_NONE)
	{
	  fixS *fix;
	  fix = fix_new_exp (frag_now,
			     destp - frag_now->fr_literal,
			     4,
			     &the_insn.exp,
			     the_insn.pcrel,
			     the_insn.reloc);

	  /* Despite the odd name, this is a scratch field.  We use
	     it to encode operand type information.  */
	  fix->fx_addnumber = the_insn.fup;
	}
d454 1
a454 2
i860_process_insn (str)
     char *str;
d519 1
d522 7
a528 3
      the_insn.reloc = BFD_RELOC_NONE;
      the_insn.pcrel = 0;
      the_insn.fup = OP_NONE;
d533 3
d572 1
a572 1
	      else
d644 1
a644 1
	      else
a673 6
		      if (dual_mode != DUAL_OFF)
			opcode |= (1 << 9);
		      if (dual_mode == DUAL_DDOT)
			dual_mode = DUAL_OFF;
		      if (dual_mode == DUAL_ONDDOT)
			dual_mode = DUAL_ON;
d687 1
a687 1
	      else
d726 37
d770 2
a771 1
		  the_insn.fup |= OP_IMM_U5;
d778 2
a779 2
	      the_insn.pcrel = 1;
	      the_insn.fup |= OP_IMM_BR26;
d784 2
a785 2
	      the_insn.pcrel = 1;
	      the_insn.fup |= OP_IMM_BR16;
d790 1
a790 1
	      the_insn.fup |= OP_IMM_SPLIT16;
d795 1
a795 1
	      the_insn.fup |= OP_IMM_SPLIT16;
d800 1
a800 1
	      the_insn.fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN2);
d805 1
a805 1
	      the_insn.fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN4);
d810 1
a810 1
	      the_insn.fup |= OP_IMM_S16;
d815 1
a815 1
	      the_insn.fup |= OP_IMM_S16;
d820 1
a820 1
	      the_insn.fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN2);
d826 1
a826 1
		the_insn.fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN4);
d828 1
a828 1
		the_insn.fup |= (OP_IMM_S16 | OP_ENCODE2 | OP_ALIGN4);
d833 1
a833 1
	      the_insn.fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN8);
d838 1
a838 1
	      the_insn.fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN16);
d846 14
a859 3
#ifdef SYNTAX_SVR4
	      if (*s == ' ')
		s++;
d861 36
a896 8
	      /* Note that if i860_get_expression() fails, we will still
		 have created U entries in the symbol table for the
		 'symbols' in the input string.  Try not to create U
		 symbols for registers, etc.  */
	      if (! i860_get_expression (s))
		s = expr_end;
	      else
		goto error;
d898 4
a901 4
	      if (strncmp (s, "@@ha", 3) == 0)
		{
		  the_insn.fup |= OP_SEL_HA;
		  s += 3;
d903 1
a903 1
	      else if (strncmp (s, "@@h", 2) == 0)
d905 19
a923 29
		  the_insn.fup |= OP_SEL_H;
		  s += 2;
		}
	      else if (strncmp (s, "@@l", 2) == 0)
		{
		  the_insn.fup |= OP_SEL_L;
		  s += 2;
		}
	      else if (strncmp (s, "@@gotoff", 7) == 0
		       || strncmp (s, "@@GOTOFF", 7) == 0)
		{
		  as_bad (_("Assembler does not yet support PIC"));
		  the_insn.fup |= OP_SEL_GOTOFF;
		  s += 7;
		}
	      else if (strncmp (s, "@@got", 4) == 0
		       || strncmp (s, "@@GOT", 4) == 0)
		{
		  as_bad (_("Assembler does not yet support PIC"));
		  the_insn.fup |= OP_SEL_GOT;
		  s += 4;
		}
	      else if (strncmp (s, "@@plt", 4) == 0
		       || strncmp (s, "@@PLT", 4) == 0)
		{
		  as_bad (_("Assembler does not yet support PIC"));
		  the_insn.fup |= OP_SEL_PLT;
		  s += 4;
		}
d925 8
a932 1
	      the_insn.expand = insn->expand;
d934 2
a935 18
	      continue;
#else /* ! SYNTAX_SVR4 */
	      if (*s == ' ')
		s++;
	      if (strncmp (s, "ha%", 3) == 0)
		{
		  the_insn.fup |= OP_SEL_HA;
		  s += 3;
		}
	      else if (strncmp (s, "h%", 2) == 0)
		{
		  the_insn.fup |= OP_SEL_H;
		  s += 2;
		}
	      else if (strncmp (s, "l%", 2) == 0)
		{
		  the_insn.fup |= OP_SEL_L;
		  s += 2;
a936 13
	      the_insn.expand = insn->expand;

	      /* Note that if i860_get_expression() fails, we will still
		 have created U entries in the symbol table for the
		 'symbols' in the input string.  Try not to create U
		 symbols for registers, etc.  */
	      if (! i860_get_expression (s))
		s = expr_end;
	      else
		goto error;

	      continue;
#endif /* SYNTAX_SVR4 */
d964 21
d986 4
d993 1
a993 2
i860_get_expression (str)
     char *str;
d1000 1
a1000 1
  seg = expression (&the_insn.exp);
d1024 1
a1024 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d1075 1
a1075 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d1085 2
a1086 3
md_estimate_size_before_relax (fragP, segtype)
     register fragS *fragP ATTRIBUTE_UNUSED;
     segT segtype ATTRIBUTE_UNUSED;
d1093 1
a1093 2
print_insn (insn)
     struct i860_it *insn;
d1127 2
d1134 2
d1141 1
a1141 3
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
d1157 8
d1185 1
a1185 2
md_show_usage (stream)
     FILE *stream;
d1190 3
a1192 1
  -mwarn-expand		  warn if pseudo operations are expanded\n"));
d1204 1
a1204 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1211 1
a1211 2
md_operand (exp)
     expressionS *exp;
d1228 2
a1229 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size ATTRIBUTE_UNUSED;
d1236 1
a1236 1
   of the offset plus its size.  */
d1238 1
a1238 2
md_pcrel_from (fixP)
     fixS *fixP;
d1247 1
a1247 3
obtain_reloc_for_imm16 (fix, val)
     fixS *fix;
     long *val;
d1341 1
a1341 4
md_apply_fix3 (fix, valP, seg)
     fixS * fix;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d1358 1
a1358 1
  if (fup == OP_IMM_U5)
d1478 2
a1479 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d1498 49
@


1.3
log
@resolve conflicts.
@
text
@d2 1
a2 1
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000
a23 1
#include <ctype.h>
d27 1
d412 1
a412 1
  for (s = str; islower (*s) || *s == '.' || *s == '3'
d488 1
a488 1
	      if (isdigit (*s++))
d490 1
a490 1
		  while (isdigit (*s))
d531 1
a531 1
		  if (!isdigit (c = *s++))
d535 1
a535 1
		  if (isdigit (*s))
d578 1
a578 1
	      if (*s++ == 'f' && isdigit (*s))
d581 1
a581 1
		  if (isdigit (*s))
a900 1
  char *atof_ieee ();
a957 20
void
md_number_to_disp (buf, val, n)
     char *buf ATTRIBUTE_UNUSED;
     long val ATTRIBUTE_UNUSED;
     int n ATTRIBUTE_UNUSED;
{
  as_fatal (_("md_number_to_disp\n"));
}

/* This should never be called for i860.  */
void
md_number_to_field (buf, val, fix)
     char *buf ATTRIBUTE_UNUSED;
     long val ATTRIBUTE_UNUSED;
     void *fix ATTRIBUTE_UNUSED;
{
  as_fatal (_("i860_number_to_field\n"));
}

/* This should never be called for i860.  */
d995 1
a995 1
CONST char *md_shortopts = "VQ:";
d997 1
a997 1
CONST char *md_shortopts = "";
d1210 5
a1214 4
int
md_apply_fix3 (fix, valuep, seg)
     fixS *fix;
     valueT *valuep;
a1216 1

d1218 1
a1218 1
  long val = (long) (*valuep);
d1262 2
a1263 3
    {
      abort ();
    }
d1328 1
a1328 1
		    _("Unrecognized fix-up (0x%08x)"), fup);
a1347 3

  /* Return value ignored.  */
  return 0;
@


1.2
log
@Help stupid cvs fixing basic conflicts.
@
text
@d1 6
a6 2
/* tc-i860.c -- Assemble for the I860
   Copyright (C) 1989, 92, 93, 94, 95, 98, 1999 Free Software Foundation, Inc.
d24 3
d28 1
a28 1

d30 1
d32 5
a36 14
void md_begin ();
void md_number_to_chars ();
void md_assemble ();
char *md_atof ();
void md_convert_frag ();
int md_estimate_size_before_relax ();
void md_number_to_imm ();
void md_number_to_disp ();
void md_number_to_field ();
void md_ri_to_chars ();
static void i860_ip ();
/* void emit_machine_reloc(); */

const int md_reloc_size = sizeof (struct relocation_info);
d38 1
a38 3
/* void (*md_emit_relocations)() = emit_machine_reloc; */

/* handle of the OPCODE hash table */
d41 2
a42 11
static void s_dual (), s_enddual ();
static void s_atmp ();

const pseudo_typeS
  md_pseudo_table[] =
{
  {"dual", s_dual, 4},
  {"enddual", s_enddual, 4},
  {"atmp", s_atmp, 4},
  {NULL, 0, 0},
};
d44 1
a44 11
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful */
const char comment_chars[] = "!/";	/* JF removed '|' from comment_chars */

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output. */
/* Also note that comments like this one will always work. */
d47 1
a47 1
const char line_separator_chars[] = "";
d49 2
a50 1
/* Chars that can be used to separate mant from exp in floating point nums */
d53 2
a54 3
/* Chars that mean this number is a floating point constant */
/* As in 0f12.456 */
/* or    0d1.2345e12 */
d57 6
a62 9
/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
   changed in read.c .  Ideally it shouldn't have to know about it at all,
   but nothing is ideal around here.
   */
int size_reloc_info = sizeof (struct relocation_info);

static unsigned char octal[256];
#define isoctal(c)  octal[c]
static unsigned char toHex[256];
d65 9
a73 15
  {
    char *error;
    unsigned long opcode;
    struct nlist *nlistp;
    expressionS exp;
    int pcrel;
    enum expand_type expand;
    enum highlow_type highlow;
    enum reloc_type reloc;
  } the_insn;

#if __STDC__ == 1

static void print_insn (struct i860_it *insn);
static int getExpression (char *str);
d75 4
a78 1
#else /* not __STDC__ */
d80 2
a81 2
static void print_insn ();
static int getExpression ();
d83 11
a93 1
#endif /* not __STDC__ */
d95 10
a104 2
static char *expr_end;
static char last_expand;	/* error if expansion after branch */
d106 1
d111 1
a111 1
static enum dual dual_mode = DUAL_OFF;	/* dual-instruction mode */
d113 1
d115 2
a116 1
s_dual ()			/* floating point instructions have dual set */
d121 1
d123 2
a124 1
s_enddual ()			/* floating point instructions have dual set */
d129 2
a130 1
static int atmp = 31;		/* temporary register for pseudo's */
d133 2
a134 1
s_atmp ()
d164 2
a165 1
   set up all the tables, etc. that the MD part of the assembler will need.  */
d169 1
a169 1
  register char *retval = NULL;
d171 1
a171 1
  register unsigned int i = 0;
d175 1
a175 1
  while (i < NUMOPCODES)
d178 1
a178 1
      retval = hash_insert (op_hash, name, &i860_opcodes[i]);
d189 2
a190 1
	      fprintf (stderr, _("internal error: losing opcode: `%s' \"%s\"\n"),
d196 2
a197 2
      while (i < NUMOPCODES
	     && !strcmp (i860_opcodes[i].name, name));
d201 1
a201 10
    as_fatal (_("Broken assembler.  No assembly attempted."));

  for (i = '0'; i < '8'; ++i)
    octal[i] = 1;
  for (i = '0'; i <= '9'; ++i)
    toHex[i] = i - '0';
  for (i = 'a'; i <= 'f'; ++i)
    toHex[i] = i + 10 - 'a';
  for (i = 'A'; i <= 'F'; ++i)
    toHex[i] = i + 10 - 'A';
d204 3
d211 2
a212 3
  char *toP;
  int rsd;
  int no_opcodes = 1;
a216 1
  i860_ip (str);
d218 8
a225 2
  /* check for expandable flag to produce pseudo-instructions */
  if (the_insn.expand != 0 && the_insn.highlow == NO_SPEC)
d234 1
a234 1
	  no_opcodes = 1;
d238 4
a241 4
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL &&
	      (the_insn.exp.X_add_number < (1 << 15) &&
	       the_insn.exp.X_add_number >= -(1 << 15)))
d243 2
a244 1
	  /* or l%const,r0,ireg_dest */
d246 8
a253 6
	  pseudo[0].highlow = PAIR;
	  /* orh h%const,ireg_dest,ireg_dest */
	  pseudo[1].opcode = (the_insn.opcode & 0x03ffffff) | 0xec000000 |
	    ((the_insn.opcode & 0x001f0000) << 5);
	  pseudo[1].highlow = HIGH;
	  no_opcodes = 2;
d257 4
a260 2
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL)
d262 2
a263 1
	  /* orh ha%addr_expr,r0,r31 */
d265 8
a272 6
	  pseudo[0].highlow = HIGHADJ;
	  pseudo[0].reloc = LOW0;	/* must overwrite */
	  /* l%addr_expr(r31),ireg_dest */
	  pseudo[1].opcode = (the_insn.opcode & ~0x003e0000) | (atmp << 21);
	  pseudo[1].highlow = PAIR;
	  no_opcodes = 2;
d275 5
a279 5
	case E_U32:		/* 2nd version emulates Intel as, not doc. */
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL &&
	      (the_insn.exp.X_add_number < (1 << 16) &&
	       the_insn.exp.X_add_number >= 0))
d281 12
a292 14
	  /* $(opcode)h h%const,ireg_src2,ireg_dest
			   pseudo[0].opcode = (the_insn.opcode & 0xf3ffffff) | 0x0c000000; */
	  /* $(opcode)h h%const,ireg_src2,r31 */
	  pseudo[0].opcode = (the_insn.opcode & 0xf3e0ffff) | 0x0c000000 |
	    (atmp << 16);
	  pseudo[0].highlow = HIGH;
	  /* $(opcode) l%const,ireg_dest,ireg_dest
			   pseudo[1].opcode = (the_insn.opcode & 0xf01f0000) | 0x04000000 |
			   ((the_insn.opcode & 0x001f0000) << 5); */
	  /* $(opcode) l%const,r31,ireg_dest */
	  pseudo[1].opcode = (the_insn.opcode & 0xf01f0000) | 0x04000000 |
	    (atmp << 21);
	  pseudo[1].highlow = PAIR;
	  no_opcodes = 2;
d295 5
a299 5
	case E_AND:		/* 2nd version emulates Intel as, not doc. */
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL &&
	      (the_insn.exp.X_add_number < (1 << 16) &&
	       the_insn.exp.X_add_number >= 0))
d301 5
a305 6
	  /* andnot h%const,ireg_src2,ireg_dest
			   pseudo[0].opcode = (the_insn.opcode & 0x03ffffff) | 0xd4000000; */
	  /* andnot h%const,ireg_src2,r31 */
	  pseudo[0].opcode = (the_insn.opcode & 0x03e0ffff) | 0xd4000000 |
	    (atmp << 16);
	  pseudo[0].highlow = HIGH;
d307 5
a311 7
	  /* andnot l%const,ireg_dest,ireg_dest
			   pseudo[1].opcode = (the_insn.opcode & 0x001f0000) | 0xd4000000 |
			   ((the_insn.opcode & 0x001f0000) << 5); */
	  /* andnot l%const,r31,ireg_dest */
	  pseudo[1].opcode = (the_insn.opcode & 0x001f0000) | 0xd4000000 |
	    (atmp << 21);
	  pseudo[1].highlow = PAIR;
d313 2
a314 1
	  no_opcodes = 2;
d318 4
a321 4
	  if (the_insn.exp.X_add_symbol == NULL &&
	      the_insn.exp.X_op_symbol == NULL &&
	      (the_insn.exp.X_add_number < (1 << 15) &&
	       the_insn.exp.X_add_number >= -(1 << 15)))
d323 2
a324 1
	  /* orh h%const,r0,r31 */
d326 3
a328 2
	  pseudo[0].highlow = HIGH;
	  /* or l%const,r31,r31 */
d330 3
a332 2
	  pseudo[1].highlow = PAIR;
	  /* r31,ireg_src2,ireg_dest */
d334 3
a336 2
	  pseudo[2].reloc = NO_RELOC;
	  no_opcodes = 3;
d344 3
a346 2
      /* check for expanded opcode after branch or in dual */
      if (no_opcodes > 1 && last_expand == 1)
d348 3
a350 1
      if (no_opcodes > 1 && dual_mode != DUAL_OFF)
d352 4
d360 5
a364 4
    {				/* always produce at least one opcode */
      toP = frag_more (4);
      /* put out the opcode */
      md_number_to_chars (toP, the_insn.opcode, 4);
d366 1
a366 1
      /* check for expanded opcode after branch or in dual */
d369 2
a370 2
      /* put out the symbol-dependent stuff */
      if (the_insn.reloc != NO_RELOC)
d372 11
a382 7
	  fix_new (frag_now,	/* which frag */
		   (toP - frag_now->fr_literal),	/* where */
		   4,		/* size */
		   &the_insn.exp,
		   the_insn.pcrel,
	  /* merge bit fields into one argument */
	  (int) (((the_insn.highlow & 0x3) << 4) | (the_insn.reloc & 0xf)));
d386 1
a386 1
  while (--no_opcodes > 0);
d390 1
d392 1
a392 1
i860_ip (str)
a397 1
  unsigned long i;
d399 1
a399 1
  char *argsStart;
d405 6
d412 2
a413 1
  for (s = str; islower (*s) || *s == '.' || *s == '3'; ++s)
d415 1
a417 1

d434 1
d436 1
a436 1
    {				/* check for d. opcode prefix */
d451 1
d453 3
a455 4
    {
      *--s = ',';
    }
  argsStart = s;
d460 3
a462 1
      the_insn.reloc = NO_RELOC;
d464 2
a465 5
      /*
		 * Build the opcode, checking as we go to make
		 * sure that the operands match
		 */
      for (args = insn->args;; ++args)
d470 2
a471 1
	    case '\0':		/* end of args */
d473 1
a473 3
		{
		  match = 1;
		}
d476 1
d478 1
a478 1
	    case '(':		/* these must match exactly */
d486 2
a487 1
	    case '#':		/* must be at least one digit */
d491 1
a491 3
		    {
		      ++s;
		    }
d496 2
a497 1
	    case '1':		/* next operand must be a register */
d500 6
d508 2
a509 2

		case 'f':	/* frame pointer */
d518 2
a519 1
		case 's':	/* stack pointer */
d528 2
a529 1
		case 'r':	/* any register */
d538 1
a538 3
			{
			  goto error;
			}
d541 1
a541 3
		    {
		      c -= '0';
		    }
d545 2
a546 1
		default:	/* not this opcode */
d549 2
a550 4
	      /*
				 * Got the register, now figure out where
				 * it goes in the opcode.
				 */
a552 1

d568 2
a569 1
	    case 'e':		/* next operand is a floating point register */
d572 6
d590 2
a591 3
		    {
		      mask -= '0';
		    }
d606 1
a606 1
			opcode |= (1 << 9);	/* dual mode instruction */
d611 3
a613 2
		      if ((opcode & (1 << 10)) && (mask == ((opcode >> 11) & 0x1f)))
			as_warn (_("Fsr1 equals fdest with Pipelining"));
d619 8
a626 1
	    case 'c':		/* next operand must be a control register */
d665 3
a667 3
	    case '5':		/* 5 bit immediate in src1 */
	      memset (&the_insn, '\0', sizeof (the_insn));
	      if (!getExpression (s))
d670 1
a670 5
		  if (the_insn.exp.X_add_number & ~0x1f)
		    as_bad (_("5-bit immediate too large"));
		  opcode |= (the_insn.exp.X_add_number & 0x1f) << 11;
		  memset (&the_insn, '\0', sizeof (the_insn));
		  the_insn.reloc = NO_RELOC;
d675 2
a676 2
	    case 'l':		/* 26 bit immediate, relative branch */
	      the_insn.reloc = BRADDR;
d678 1
d681 2
a682 2
	    case 's':		/* 16 bit immediate, split relative branch */
	      /* upper 5 bits of offset in dest field */
d684 26
a709 1
	      the_insn.reloc = SPLIT0;
d712 14
a725 6
	    case 'S':		/* 16 bit immediate, split (st), aligned */
	      if (opcode & (1 << 28))
		if (opcode & 0x1)
		  the_insn.reloc = SPLIT2;
		else
		  the_insn.reloc = SPLIT1;
d727 1
a727 1
		the_insn.reloc = SPLIT0;
d730 3
a732 8
	    case 'I':		/* 16 bit immediate, aligned */
	      if (opcode & (1 << 28))
		if (opcode & 0x1)
		  the_insn.reloc = LOW2;
		else
		  the_insn.reloc = LOW1;
	      else
		the_insn.reloc = LOW0;
d735 3
a737 2
	    case 'i':		/* 16 bit immediate */
	      the_insn.reloc = LOW0;
d741 3
d745 54
d803 1
a803 1
		  the_insn.highlow = HIGHADJ;
d808 1
a808 1
		  the_insn.highlow = HIGH;
d813 1
a813 1
		  the_insn.highlow = PAIR;
d818 8
a825 4
	      /* Note that if the getExpression() fails, we will still have
				   created U entries in the symbol table for the 'symbols'
				   in the input string.  Try not to create U symbols for
				   registers, etc. */
d827 2
a828 5
	      if (!getExpression (s))
		{
		  s = expr_end;
		  continue;
		}
d840 2
a841 2
	  if (&insn[1] - i860_opcodes < NUMOPCODES
	      && !strcmp (insn->name, insn[1].name))
d844 1
a844 1
	      s = argsStart;
d849 1
a849 1
	      as_bad (_("Illegal operands"));
d860 1
a860 1
getExpression (str)
d883 4
d888 1
a888 10
/*
  This is identical to the md_atof in m68k.c.  I think this is right,
  but I'm not sure.

  Turn a string in input_line_pointer into a floating point constant of type
  type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
  emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
  */

/* Equal to MAX_PRECISION in atof-ieee.c */
a904 1

d945 1
a945 3
/*
 * Write out big-endian.
 */
d952 4
a955 107
  number_to_chars_bigendian (buf, val, n);
}

void
md_number_to_imm (buf, val, n, fixP)
     char *buf;
     long val;
     int n;
     fixS *fixP;
{
  enum reloc_type reloc = fixP->fx_r_type & 0xf;
  enum highlow_type highlow = (fixP->fx_r_type >> 4) & 0x3;

  assert (buf);
  assert (n == 4);		/* always on i860 */

  switch (highlow)
    {

    case HIGHADJ:		/* adjusts the high-order 16-bits */
      if (val & (1 << 15))
	val += (1 << 16);

      /*FALLTHROUGH*/

    case HIGH:			/* selects the high-order 16-bits */
      val >>= 16;
      break;

    case PAIR:			/* selects the low-order 16-bits */
      val = val & 0xffff;
      break;

    default:
      break;
    }

  switch (reloc)
    {

    case BRADDR:		/* br,call,bc,bc.t,bnc,bnc.t w/26-bit immediate */
      if (fixP->fx_pcrel != 1)
	as_bad (_("26-bit branch w/o pc relative set: 0x%08x"), val);
      val >>= 2;		/* align pcrel offset, see manual */

      if (val >= (1 << 25) || val < -(1 << 25))	/* check for overflow */
	as_bad (_("26-bit branch offset overflow: 0x%08x"), val);
      buf[0] = (buf[0] & 0xfc) | ((val >> 24) & 0x3);
      buf[1] = val >> 16;
      buf[2] = val >> 8;
      buf[3] = val;
      break;

    case SPLIT2:		/* 16 bit immediate, 4-byte aligned */
      if (val & 0x3)
	as_bad (_("16-bit immediate 4-byte alignment error: 0x%08x"), val);
      val &= ~0x3;		/* 4-byte align value */
      /*FALLTHROUGH*/
    case SPLIT1:		/* 16 bit immediate, 2-byte aligned */
      if (val & 0x1)
	as_bad (_("16-bit immediate 2-byte alignment error: 0x%08x"), val);
      val &= ~0x1;		/* 2-byte align value */
      /*FALLTHROUGH*/
    case SPLIT0:		/* st,bla,bte,btne w/16-bit immediate */
      if (fixP->fx_pcrel == 1)
	val >>= 2;		/* align pcrel offset, see manual */
      /* check for bounds */
      if (highlow != PAIR && (val >= (1 << 16) || val < -(1 << 15)))
	as_bad (_("16-bit branch offset overflow: 0x%08x"), val);
      buf[1] = (buf[1] & ~0x1f) | ((val >> 11) & 0x1f);
      buf[2] = (buf[2] & ~0x7) | ((val >> 8) & 0x7);
      buf[3] |= val;		/* perserve bottom opcode bits */
      break;

    case LOW4:			/* fld,pfld,pst,flush 16-byte aligned */
      if (val & 0xf)
	as_bad (_("16-bit immediate 16-byte alignment error: 0x%08x"), val);
      val &= ~0xf;		/* 16-byte align value */
      /*FALLTHROUGH*/
    case LOW3:			/* fld,pfld,pst,flush 8-byte aligned */
      if (val & 0x7)
	as_bad (_("16-bit immediate 8-byte alignment error: 0x%08x"), val);
      val &= ~0x7;		/* 8-byte align value */
      /*FALLTHROUGH*/
    case LOW2:			/* 16 bit immediate, 4-byte aligned */
      if (val & 0x3)
	as_bad (_("16-bit immediate 4-byte alignment error: 0x%08x"), val);
      val &= ~0x3;		/* 4-byte align value */
      /*FALLTHROUGH*/
    case LOW1:			/* 16 bit immediate, 2-byte aligned */
      if (val & 0x1)
	as_bad (_("16-bit immediate 2-byte alignment error: 0x%08x"), val);
      val &= ~0x1;		/* 2-byte align value */
      /*FALLTHROUGH*/
    case LOW0:			/* 16 bit immediate, byte aligned */
      /* check for bounds */
      if (highlow != PAIR && (val >= (1 << 16) || val < -(1 << 15)))
	as_bad (_("16-bit immediate overflow: 0x%08x"), val);
      buf[2] = val >> 8;
      buf[3] |= val;		/* perserve bottom opcode bits */
      break;

    case NO_RELOC:
    default:
      as_bad (_("bad relocation type: 0x%02x"), reloc);
      break;
    }
d958 1
a958 1
/* should never be called for i860 */
d961 3
a963 2
     char *buf;
     long val;
d968 1
a968 1
/* should never be called for i860 */
d971 3
a973 3
     char *buf;
     long val;
     void *fix;
d978 1
a978 41
/* the bit-field entries in the relocation_info struct plays hell
   with the byte-order problems of cross-assembly.  So as a hack,
   I added this mach. dependent ri twiddler.  Ugly, but it gets
   you there. -KWK */
/* on i860: first 4 bytes are normal unsigned long address, next three
   bytes are index, most sig. byte first.  Byte 7 is broken up with
   bit 7 as pcrel, bit 6 as extern, and the lower six bits as
   relocation type (highlow 5-4).  Next 4 bytes are long addend. */
/* Thanx and a tip of the hat to Michael Bloom, mb@@ttidca.tti.com */
void
md_ri_to_chars (ri_p, ri)
     struct relocation_info *ri_p, ri;
{
#if 0
  unsigned char the_bytes[sizeof (*ri_p)];

  /* this is easy */
  md_number_to_chars (the_bytes, ri.r_address, sizeof (ri.r_address));
  /* now the fun stuff */
  the_bytes[4] = (ri.r_index >> 16) & 0x0ff;
  the_bytes[5] = (ri.r_index >> 8) & 0x0ff;
  the_bytes[6] = ri.r_index & 0x0ff;
  the_bytes[7] = ((ri.r_extern << 7) & 0x80) | (0 & 0x60) | (ri.r_type & 0x1F);
  /* Also easy */
  md_number_to_chars (&the_bytes[8], ri.r_addend, sizeof (ri.r_addend));
  /* now put it back where you found it, Junior... */
  memcpy ((char *) ri_p, the_bytes, sizeof (*ri_p));
#endif
}

/* should never be called for i860 */
void
md_convert_frag (headers, seg, fragP)
     object_headers *headers;
     segT seg;
     register fragS *fragP;
{
  as_fatal (_("i860_convert_frag\n"));
}

/* should never be called for i860 */
d981 2
a982 2
     register fragS *fragP;
     segT segtype;
d987 1
a987 22
/* for debugging only, must match enum reloc_type */
static char *Reloc[] =
{
  "NO_RELOC",
  "BRADDR",
  "LOW0",
  "LOW1",
  "LOW2",
  "LOW3",
  "LOW4",
  "SPLIT0",
  "SPLIT1",
  "SPLIT2",
  "RELOC_32",
};
static char *Highlow[] =
{
  "NO_SPEC",
  "PAIR",
  "HIGH",
  "HIGHADJ",
};
d993 6
a998 7
    {
      fprintf (stderr, "ERROR: %s\n");
    }
  fprintf (stderr, "opcode=0x%08x\t", insn->opcode);
  fprintf (stderr, "expand=0x%08x\t", insn->expand);
  fprintf (stderr, "reloc = %s\t", Reloc[insn->reloc]);
  fprintf (stderr, "highlow = %s\n", Highlow[insn->highlow]);
d1008 1
a1008 1
  fprintf (stderr, "\t\tX_add_number = %d\n",
d1012 2
d1015 3
d1019 6
d1026 4
a1029 1
  {NULL, no_argument, NULL, 0}
d1031 1
a1031 1
size_t md_longopts_size = sizeof(md_longopts);
d1036 1
a1036 1
     char *arg;
d1038 31
a1068 1
  return 0;
d1075 10
d1086 1
d1088 9
a1096 5
#ifdef comment
/*
 * I860 relocations are completely different, so it needs
 * this machine dependent routine to emit them.
 */
d1098 2
a1099 3
emit_machine_reloc (fixP, segment_address_in_file)
     register fixS *fixP;
     relax_addressT segment_address_in_file;
d1101 1
a1101 4
  struct reloc_info_i860 ri;
  register symbolS *symbolP;
  extern char *next_object_file_charP;
  long add_number;
d1103 1
a1103 2
  memset ((char *) &ri, '\0', sizeof (ri));
  for (; fixP; fixP = fixP->fx_next)
d1105 1
a1105 2

      if (fixP->fx_r_type & ~0x3f)
d1107 3
a1109 1
	  as_fatal ("fixP->fx_r_type = %d\n", fixP->fx_r_type);
d1111 2
a1112 2
      ri.r_pcrel = fixP->fx_pcrel;
      ri.r_type = fixP->fx_r_type;
d1114 61
a1174 1
      if ((symbolP = fixP->fx_addsy) != NULL)
d1176 6
a1181 3
	  ri.r_address = fixP->fx_frag->fr_address +
	    fixP->fx_where - segment_address_in_file;
	  if (!S_IS_DEFINED (symbolP))
d1183 2
a1184 2
	      ri.r_extern = 1;
	      ri.r_symbolnum = symbolP->sy_number;
d1188 2
a1189 2
	      ri.r_extern = 0;
	      ri.r_symbolnum = S_GET_TYPE (symbolP);
d1191 4
a1194 1
	  if (symbolP && symbol_get_frag (symbolP))
d1196 2
a1197 1
	      ri.r_addend = symbol_get_frag (symbolP)->fr_address;
d1199 1
a1199 2
	  ri.r_type = fixP->fx_r_type;
	  if (fixP->fx_pcrel)
d1201 7
a1207 2
	      /* preserve actual offset vs. pc + 4 */
	      ri.r_addend -= (ri.r_address + 4);
d1211 2
a1212 1
	      ri.r_addend = fixP->fx_addnumber;
d1214 1
d1216 7
a1222 3
	  md_ri_to_chars ((char *) &ri, ri);
	  append (&next_object_file_charP, (char *) &ri, sizeof (ri));
	}
d1224 2
d1228 14
a1241 1
#endif /* comment */
d1243 1
a1243 1
#ifdef OBJ_AOUT
d1245 2
a1246 4
/* on i860: first 4 bytes are normal unsigned long address, next three
   bytes are index, most sig. byte first.  Byte 7 is broken up with
   bit 7 as pcrel, bit 6 as extern, and the lower six bits as
   relocation type (highlow 5-4).  Next 4 bytes are long addend. */
d1248 2
a1249 10
void
tc_aout_fix_to_chars (where, fixP, segment_address_in_file)
     char *where;
     fixS *fixP;
     relax_addressT segment_address_in_file;
{
  long r_index;
  long r_extern;
  long r_addend = 0;
  long r_address;
d1251 10
a1260 2
  know (fixP->fx_addsy);
  know (!(fixP->fx_r_type & ~0x3f));
d1262 6
a1267 1
  if (!S_IS_DEFINED (fixP->fx_addsy))
d1269 12
a1280 2
      r_extern = 1;
      r_index = fixP->fx_addsy->sy_number;
d1282 1
a1282 1
  else
d1284 1
a1284 2
      r_extern = 0;
      r_index = S_GET_TYPE (fixP->fx_addsy);
d1286 3
d1290 17
a1306 3
  md_number_to_chars (where,
		      r_address = fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
		      4);
d1308 1
a1308 6
  where[4] = (r_index >> 16) & 0x0ff;
  where[5] = (r_index >> 8) & 0x0ff;
  where[6] = r_index & 0x0ff;
  where[7] = (((fixP->fx_pcrel << 7) & 0x80)
	      | ((r_extern << 6) & 0x40)
	      | (fixP->fx_r_type & 0x3F));
d1310 16
a1325 1
  if (symbol_get_frag (fixP->fx_addsy))
d1327 19
a1345 1
      r_addend = symbol_get_frag (fixP->fx_addsy)->fr_address;
d1347 1
a1347 2

  if (fixP->fx_pcrel)
d1349 3
a1351 2
      /* preserve actual offset vs. pc + 4 */
      r_addend -= (r_address + 4);
d1355 14
a1368 1
      r_addend = fixP->fx_addnumber;
d1371 1
a1371 12
  md_number_to_chars (&where[8], r_addend, 4);
}

#endif /* OBJ_AOUT */

/* We have no need to default values of symbols.  */

/* ARGSUSED */
symbolS *
md_undefined_symbol (name)
     char *name;
{
d1375 20
a1394 36
/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
{
  return size;			/* Byte alignment is fine */
}

/* Exactly what point is a PC-relative offset relative TO?
   On the i860, they're relative to the address of the offset, plus
   its size. (??? Is this right?  FIXME-SOON!) */
long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

void
md_apply_fix (fixP, val)
     fixS *fixP;
     long val;
{
  char *place = fixP->fx_where + fixP->fx_frag->fr_literal;

  /* looks to me like i860 never has bit fixes. Let's see. xoxorich. */
  know (fixP->fx_bit_fixP == NULL);
  if (!fixP->fx_bit_fixP)
    {
      fixP->fx_addnumber = val;
      md_number_to_imm (place, val, fixP->fx_size, fixP);
    }
  else
    {
      md_number_to_field (place, val, fixP->fx_bit_fixP);
d1396 1
a1397 9

/*
 * Local Variables:
 * fill-column: 131
 * comment-column: 0
 * End:
 */

/* end of tc-i860.c */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1989, 1992, 1993 Free Software Foundation, Inc.
d16 3
a18 3
   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a28 2
void md_create_short_jump ();
void md_create_long_jump ();
a55 3
int md_short_jump_size = 4;
int md_long_jump_size = 4;

d157 1
a157 1
	as_bad ("Unknown temporary pseudo register");
d161 1
a161 1
      as_bad ("Unknown temporary pseudo register");
d183 1
a183 1
	  fprintf (stderr, "internal error: can't hash `%s': %s\n",
d191 1
a191 1
	      fprintf (stderr, "internal error: losing opcode: `%s' \"%s\"\n",
d202 1
a202 1
    as_fatal ("Broken assembler.  No assembly attempted.");
d335 1
a335 1
	  as_fatal ("failed sanity check.");
d341 1
a341 1
	as_warn ("Expanded opcode after delayed branch: `%s'", str);
d343 1
a343 1
	as_warn ("Expanded opcode in dual mode: `%s'", str);
d407 1
a407 1
      as_fatal ("Unknown opcode: `%s'", str);
d423 1
a423 1
      as_bad ("Unknown opcode: `%s'", str);
d580 1
a580 1
			as_warn ("Fsr1 equals fdest with Pipelining");
d631 1
a631 1
		    as_bad ("5-bit immediate too large");
d708 1
a708 1
	      as_fatal ("failed sanity check.");
d725 1
a725 1
	      as_bad ("Illegal operands");
d749 1
a749 1
      the_insn.error = "bad segment";
d813 1
a813 1
      return "Bad call to MD_ATOF()";
d878 1
a878 1
	as_bad ("26-bit branch w/o pc relative set: 0x%08x", val);
d882 1
a882 1
	as_bad ("26-bit branch offset overflow: 0x%08x", val);
d891 1
a891 1
	as_bad ("16-bit immediate 4-byte alignment error: 0x%08x", val);
d896 1
a896 1
	as_bad ("16-bit immediate 2-byte alignment error: 0x%08x", val);
d904 1
a904 1
	as_bad ("16-bit branch offset overflow: 0x%08x", val);
d912 1
a912 1
	as_bad ("16-bit immediate 16-byte alignment error: 0x%08x", val);
d917 1
a917 1
	as_bad ("16-bit immediate 8-byte alignment error: 0x%08x", val);
d922 1
a922 1
	as_bad ("16-bit immediate 4-byte alignment error: 0x%08x", val);
d927 1
a927 1
	as_bad ("16-bit immediate 2-byte alignment error: 0x%08x", val);
d933 1
a933 1
	as_bad ("16-bit immediate overflow: 0x%08x", val);
d940 1
a940 1
      as_bad ("bad relocation type: 0x%02x", reloc);
a946 11
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("i860_create_short_jmp\n");
}

/* should never be called for i860 */
void
d951 1
a951 1
  as_fatal ("md_number_to_disp\n");
d961 1
a961 1
  as_fatal ("i860_number_to_field\n");
d1001 1
a1001 12
  as_fatal ("i860_convert_frag\n");
}

/* should never be called for i860 */
void
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag;
     symbolS *to_symbol;
{
  as_fatal ("i860_create_long_jump\n");
d1010 1
a1010 1
  as_fatal ("i860_estimate_size_before_relax\n");
d1121 1
a1121 1
	  if (symbolP && symbolP->sy_frag)
d1123 1
a1123 1
	      ri.r_addend = symbolP->sy_frag->fr_address;
d1187 1
a1187 1
  if (fixP->fx_addsy->sy_frag)
d1189 1
a1189 1
      r_addend = fixP->fx_addsy->sy_frag->fr_address;
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1989, 92, 93, 94, 95, 98, 1999 Free Software Foundation, Inc.
d16 3
a18 3
   You should have received a copy of the GNU General Public License along
   with GAS; see the file COPYING.  If not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 2
d58 3
d162 1
a162 1
	as_bad (_("Unknown temporary pseudo register"));
d166 1
a166 1
      as_bad (_("Unknown temporary pseudo register"));
d188 1
a188 1
	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
d196 1
a196 1
	      fprintf (stderr, _("internal error: losing opcode: `%s' \"%s\"\n"),
d207 1
a207 1
    as_fatal (_("Broken assembler.  No assembly attempted."));
d340 1
a340 1
	  as_fatal (_("failed sanity check."));
d346 1
a346 1
	as_warn (_("Expanded opcode after delayed branch: `%s'"), str);
d348 1
a348 1
	as_warn (_("Expanded opcode in dual mode: `%s'"), str);
d412 1
a412 1
      as_fatal (_("Unknown opcode: `%s'"), str);
d428 1
a428 1
      as_bad (_("Unknown opcode: `%s'"), str);
d585 1
a585 1
			as_warn (_("Fsr1 equals fdest with Pipelining"));
d636 1
a636 1
		    as_bad (_("5-bit immediate too large"));
d713 1
a713 1
	      as_fatal (_("failed sanity check."));
d730 1
a730 1
	      as_bad (_("Illegal operands"));
d754 1
a754 1
      the_insn.error = _("bad segment");
d818 1
a818 1
      return _("Bad call to MD_ATOF()");
d883 1
a883 1
	as_bad (_("26-bit branch w/o pc relative set: 0x%08x"), val);
d887 1
a887 1
	as_bad (_("26-bit branch offset overflow: 0x%08x"), val);
d896 1
a896 1
	as_bad (_("16-bit immediate 4-byte alignment error: 0x%08x"), val);
d901 1
a901 1
	as_bad (_("16-bit immediate 2-byte alignment error: 0x%08x"), val);
d909 1
a909 1
	as_bad (_("16-bit branch offset overflow: 0x%08x"), val);
d917 1
a917 1
	as_bad (_("16-bit immediate 16-byte alignment error: 0x%08x"), val);
d922 1
a922 1
	as_bad (_("16-bit immediate 8-byte alignment error: 0x%08x"), val);
d927 1
a927 1
	as_bad (_("16-bit immediate 4-byte alignment error: 0x%08x"), val);
d932 1
a932 1
	as_bad (_("16-bit immediate 2-byte alignment error: 0x%08x"), val);
d938 1
a938 1
	as_bad (_("16-bit immediate overflow: 0x%08x"), val);
d945 1
a945 1
      as_bad (_("bad relocation type: 0x%02x"), reloc);
d952 11
d967 1
a967 1
  as_fatal (_("md_number_to_disp\n"));
d977 1
a977 1
  as_fatal (_("i860_number_to_field\n"));
d1017 12
a1028 1
  as_fatal (_("i860_convert_frag\n"));
d1037 1
a1037 1
  as_fatal (_("i860_estimate_size_before_relax\n"));
d1148 1
a1148 1
	  if (symbolP && symbol_get_frag (symbolP))
d1150 1
a1150 1
	      ri.r_addend = symbol_get_frag (symbolP)->fr_address;
d1214 1
a1214 1
  if (symbol_get_frag (fixP->fx_addsy))
d1216 1
a1216 1
      r_addend = symbol_get_frag (fixP->fx_addsy)->fr_address;
@


1.1.1.3
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 2
a2 6
/* tc-i860.c -- Assembler for the Intel i860 architecture.
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000
   Free Software Foundation, Inc.

   Brought back from the dead and completely reworked
   by Jason Eckhardt <jle@@cygnus.com>.
a19 3
#include <ctype.h>
#include <stdio.h>
#include <string.h>
d21 1
a21 1
#include "subsegs.h"
a22 1
#include "elf/i860.h"
d24 14
a37 5
/* Defined by default since this is primarily a SVR4/860 assembler.
   However, I'm trying to leave the door open for Intel syntax. Of course,
   if full support for anything other than SVR4 is done, then we should
   select this based on a command-line flag.  */
#define SYNTAX_SVR4
d39 3
a41 1
/* The opcode hash table.  */
d44 11
a54 2
/* These characters always start a comment.  */
const char comment_chars[] = "#!/";
d56 11
a66 1
/* These characters start a comment at the beginning of a line.  */
d69 1
a69 1
const char line_separator_chars[] = ";";
d71 1
a71 2
/* Characters that can be used to separate the mantissa from the exponent
   in floating point numbers.  */
d74 3
a76 2
/* Characters that indicate this number is a floating point constant.
   As in 0f12.456 or 0d1.2345e12.  */
d79 9
a87 6
/* Register prefix.  */
#ifdef SYNTAX_SVR4
static const char reg_prefix = '%';
#else
static const char reg_prefix = 0;
#endif
d90 15
a104 9
{
  char *error;
  unsigned long opcode;
  expressionS exp;
  enum expand_type expand;
  bfd_reloc_code_real_type reloc;
  int pcrel;
  valueT fup;
} the_insn;
d106 1
a106 1
static char *expr_end;
d108 2
a109 2
/* Indicates error if a pseudo operation was expanded after a branch.  */
static char last_expand;
d111 1
a111 2
/* If true, then warn if any pseudo operations were expanded.  */
static int target_warn_expand = 0;
d113 2
a114 22
/* Prototypes.  */
static void i860_process_insn	PARAMS ((char *));
static void s_dual		PARAMS ((int));
static void s_enddual		PARAMS ((int));
static void s_atmp		PARAMS ((int));
static int i860_get_expression	PARAMS ((char *));
static bfd_reloc_code_real_type obtain_reloc_for_imm16
  PARAMS ((fixS *, long *));
#ifdef DEBUG_I860
static void print_insn		PARAMS ((struct i860_it *));
#endif

const pseudo_typeS md_pseudo_table[] =
{
#ifdef OBJ_ELF
  {"align",   s_align_bytes, 0},
#endif
  {"dual",    s_dual,        0},
  {"enddual", s_enddual,     0},
  {"atmp",    s_atmp,        0},
  {NULL,      0,             0},
};
a115 1
/* Dual-instruction mode handling.  */
d120 1
a120 1
static enum dual dual_mode = DUAL_OFF;
a121 1
/* Handle ".dual" directive.  */
d123 1
a123 2
s_dual (ignore)
     int ignore ATTRIBUTE_UNUSED;
a127 1
/* Handle ".enddual" directive.  */
d129 1
a129 2
s_enddual (ignore)
     int ignore ATTRIBUTE_UNUSED;
d134 1
a134 2
/* Temporary register used when expanding assembler pseudo operations.  */
static int atmp = 31;
d137 1
a137 2
s_atmp (ignore)
     int ignore ATTRIBUTE_UNUSED;
d167 1
a167 2
   set up all the tables and data structures that the MD part of the
   assembler will need.  */
d171 1
a171 1
  const char *retval = NULL;
d173 1
a173 1
  unsigned int i = 0;
d177 1
a177 1
  while (i860_opcodes[i].name != NULL)
d180 1
a180 1
      retval = hash_insert (op_hash, name, (PTR)&i860_opcodes[i]);
d191 1
a191 2
	      fprintf (stderr,
		       _("internal error: losing opcode: `%s' \"%s\"\n"),
d197 2
a198 2
      while (i860_opcodes[i].name != NULL
	     && strcmp (i860_opcodes[i].name, name) == 0);
d202 10
a211 1
    as_fatal (_("Defective assembler.  No assembly attempted."));
a213 3
/* This is the core of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function emits the frags/bytes
   it assembles to.  */
d218 3
a220 2
  char *destp;
  int num_opcodes = 1;
d225 1
d227 2
a228 8
  /* Assemble the instruction.  */
  i860_process_insn (str);

  /* Check for expandable flag to produce pseudo-instructions.  This
     is an undesirable feature that should be avoided.  */
  if (the_insn.expand != 0
      && ! (the_insn.fup & (OP_SEL_HA | OP_SEL_H | OP_SEL_L | OP_SEL_GOT
			    | OP_SEL_GOTOFF | OP_SEL_PLT)))
d237 1
a237 1
	  num_opcodes = 1;
d241 4
a244 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 15)
		  && the_insn.exp.X_add_number >= -(1 << 15)))
d246 1
a246 2

	  /* Emit "or l%const,r0,ireg_dest".  */
d248 6
a253 8
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_L);

	  /* Emit "orh h%const,ireg_dest,ireg_dest".  */
	  pseudo[1].opcode = (the_insn.opcode & 0x03ffffff) | 0xec000000
			      | ((the_insn.opcode & 0x001f0000) << 5);
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_H);

	  num_opcodes = 2;
d257 2
a258 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 15)
		  && the_insn.exp.X_add_number >= -(1 << 15)))
d260 1
a260 2

	  /* Emit "orh ha%addr_expr,r0,r31".  */
d262 6
a267 8
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_HA);

	  /* Emit "l%addr_expr(r31),ireg_dest".  We pick up the fixup
	     information from the original instruction.   */
	  pseudo[1].opcode = (the_insn.opcode & ~0x03e00000) | (atmp << 21);
	  pseudo[1].fup = the_insn.fup | OP_SEL_L;

	  num_opcodes = 2;
d270 5
a274 5
	case E_U32:
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 16)
		  && the_insn.exp.X_add_number >= 0))
d276 14
a289 12

	  /* Emit "$(opcode)h h%const,ireg_src2,r31".  */
	  pseudo[0].opcode = (the_insn.opcode & 0xf3e0ffff) | 0x0c000000
			      | (atmp << 16);
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_H);

	  /* Emit "$(opcode) l%const,r31,ireg_dest".  */
	  pseudo[1].opcode = (the_insn.opcode & 0xf01f0000) | 0x04000000
			      | (atmp << 21);
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_L);

	  num_opcodes = 2;
d292 5
a296 5
	case E_AND:
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 16)
		  && the_insn.exp.X_add_number >= 0))
d298 6
a303 5

	  /* Emit "andnot h%const,ireg_src2,r31".  */
	  pseudo[0].opcode = (the_insn.opcode & 0x03e0ffff) | 0xd4000000
			      | (atmp << 16);
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_H);
d305 7
a311 5

	  /* Emit "andnot l%const,r31,ireg_dest".  */
	  pseudo[1].opcode = (the_insn.opcode & 0x001f0000) | 0xd4000000
			      | (atmp << 21);
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_L);
d313 1
a313 2

	  num_opcodes = 2;
d317 4
a320 4
	  if (the_insn.exp.X_add_symbol == NULL
	      && the_insn.exp.X_op_symbol == NULL
	      && (the_insn.exp.X_add_number < (1 << 15)
		  && the_insn.exp.X_add_number >= -(1 << 15)))
d322 1
a322 2

	  /* Emit "orh h%const,r0,r31".  */
d324 2
a325 3
	  pseudo[0].fup = (OP_IMM_S16 | OP_SEL_H);

	  /* Emit "or l%const,r31,r31".  */
d327 2
a328 3
	  pseudo[1].fup = (OP_IMM_S16 | OP_SEL_L);

	  /* Emit "r31,ireg_src2,ireg_dest".  */
d330 2
a331 3
	  pseudo[2].fup = OP_IMM_S16;

	  num_opcodes = 3;
d339 2
a340 3

      /* Warn if an opcode is expanded after a delayed branch.  */
      if (num_opcodes > 1 && last_expand == 1)
d342 1
a342 3

      /* Warn if an opcode is expanded in dual mode.  */
      if (num_opcodes > 1 && dual_mode != DUAL_OFF)
a343 4

      /* Notify if any expansions happen.  */
      if (target_warn_expand && num_opcodes > 1)
	as_warn (_("An instruction was expanded (%s)"), str);
d348 4
a351 5
    {
      /* Output the opcode.  Note that the i860 always reads instructions
	 as little-endian data.  */
      destp = frag_more (4);
      number_to_chars_littleendian (destp, the_insn.opcode, 4);
d353 1
a353 1
      /* Check for expanded opcode after branch or in dual mode.  */
d356 2
a357 2
      /* Output the symbol-dependent stuff.  */
      if (the_insn.fup != OP_NONE)
d359 7
a365 11
	  fixS *fix;
	  fix = fix_new_exp (frag_now,
			     destp - frag_now->fr_literal,
			     4,
			     &the_insn.exp,
			     the_insn.pcrel,
			     the_insn.reloc);

	  /* Despite the odd name, this is a scratch field.  We use
	     it to encode operand type information.  */
	  fix->fx_addnumber = the_insn.fup;
d369 1
a369 1
  while (--num_opcodes > 0);
a372 1
/* Assemble the instruction pointed to by STR.  */
d374 1
a374 1
i860_process_insn (str)
d380 1
d382 1
a382 1
  char *args_start;
a387 6
#if 1 /* For compiler warnings.  */
  args = 0;
  insn = 0;
  args_start = 0;
  opcode = 0;
#endif
d389 1
a389 2
  for (s = str; islower (*s) || *s == '.' || *s == '3'
       || *s == '2' || *s == '1'; ++s)
a390 1

d393 1
a409 1
  /* Check for dual mode ("d.") opcode prefix.  */
d411 1
a411 1
    {
a425 1

d427 4
a430 3
    *--s = ',';

  args_start = s;
d435 1
a435 3
      the_insn.reloc = BFD_RELOC_NONE;
      the_insn.pcrel = 0;
      the_insn.fup = OP_NONE;
d437 5
a441 2
      /* Build the opcode, checking as we go that the operands match.  */
      for (args = insn->args; ; ++args)
d446 1
a446 2
	    /* End of args.  */
	    case '\0':
d448 3
a450 1
		match = 1;
a452 1
	    /* These must match exactly.  */
d454 1
a454 1
	    case '(':
d462 1
a462 2
	    /* Must be at least one digit.  */
	    case '#':
d466 3
a468 1
		    ++s;
d473 1
a473 2
	    /* Next operand must be a register.  */
	    case '1':
a475 6
	      /* Check for register prefix if necessary.  */
	      if (reg_prefix && *s != reg_prefix)
		goto error;
	      else
		s++;

d478 2
a479 2
		/* Frame pointer.  */
		case 'f':
d488 1
a488 2
		/* Stack pointer.  */
		case 's':
d497 1
a497 2
		/* Any register r0..r31.  */
		case 'r':
d506 3
a508 1
			goto error;
d511 3
a513 1
		    c -= '0';
d517 1
a517 2
		/* Not this opcode.  */
		default:
d520 4
a523 2

	      /* Obtained the register, now place it in the opcode.  */
d526 1
d542 1
a542 2
	    /* Next operand is a floating point register.  */
	    case 'e':
a544 6
	      /* Check for register prefix if necessary.  */
	      if (reg_prefix && *s != reg_prefix)
		goto error;
	      else
		s++;

d557 3
a559 2
		    mask -= '0';

d574 1
a574 1
			opcode |= (1 << 9);
d579 2
a580 3
		      if ((opcode & (1 << 10)) && mask != 0
			  && (mask == ((opcode >> 11) & 0x1f)))
			as_warn (_("Pipelined instruction: fsrc1 = fdest"));
d586 1
a586 8
	    /* Next operand must be a control register.  */
	    case 'c':
	      /* Check for register prefix if necessary.  */
	      if (reg_prefix && *s != reg_prefix)
		goto error;
	      else
		s++;

d625 3
a627 3
	    /* 5-bit immediate in src1.  */
	    case '5':
	      if (! i860_get_expression (s))
d630 5
a634 1
		  the_insn.fup |= OP_IMM_U5;
d639 2
a640 2
	    /* 26-bit immediate, relative branch (lbroff).  */
	    case 'l':
a641 1
	      the_insn.fup |= OP_IMM_BR26;
d644 2
a645 2
	    /* 16-bit split immediate, relative branch (sbroff).  */
	    case 'r':
d647 1
a647 1
	      the_insn.fup |= OP_IMM_BR16;
d650 8
a657 3
	    /* 16-bit split immediate.  */
	    case 's':
	      the_insn.fup |= OP_IMM_SPLIT16;
d660 6
a665 34
	    /* 16-bit split immediate, byte aligned (st.b).  */
	    case 'S':
	      the_insn.fup |= OP_IMM_SPLIT16;
	      goto immediate;

	    /* 16-bit split immediate, half-word aligned (st.s).  */
	    case 'T':
	      the_insn.fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN2);
	      goto immediate;

	    /* 16-bit split immediate, word aligned (st.l).  */
	    case 'U':
	      the_insn.fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN4);
	      goto immediate;

	    /* 16-bit immediate.  */
	    case 'i':
	      the_insn.fup |= OP_IMM_S16;
	      goto immediate;

	    /* 16-bit immediate, byte aligned (ld.b).  */
	    case 'I':
	      the_insn.fup |= OP_IMM_S16;
	      goto immediate;

	    /* 16-bit immediate, half-word aligned (ld.s).  */
	    case 'J':
	      the_insn.fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN2);
	      goto immediate;

	    /* 16-bit immediate, word aligned (ld.l, {p}fld.l, fst.l).  */
	    case 'K':
	      if (insn->name[0] == 'l')
		the_insn.fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN4);
d667 1
a667 6
		the_insn.fup |= (OP_IMM_S16 | OP_ENCODE2 | OP_ALIGN4);
	      goto immediate;

	    /* 16-bit immediate, double-word aligned ({p}fld.d, fst.d).  */
	    case 'L':
	      the_insn.fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN8);
d670 2
a671 3
	    /* 16-bit immediate, quad-word aligned (fld.q, fst.q).  */
	    case 'M':
	      the_insn.fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN16);
a674 3
	      /* Handle the immediate for either the Intel syntax or
		 SVR4 syntax. The Intel syntax is "ha%immediate"
		 whereas SVR4 syntax is "[immediate]@@ha".  */
a675 54
#ifdef SYNTAX_SVR4
	      if (*s == ' ')
		s++;

	      /* Note that if i860_get_expression() fails, we will still
		 have created U entries in the symbol table for the
		 'symbols' in the input string.  Try not to create U
		 symbols for registers, etc.  */
	      if (! i860_get_expression (s))
		s = expr_end;
	      else
		goto error;

	      if (strncmp (s, "@@ha", 3) == 0)
		{
		  the_insn.fup |= OP_SEL_HA;
		  s += 3;
		}
	      else if (strncmp (s, "@@h", 2) == 0)
		{
		  the_insn.fup |= OP_SEL_H;
		  s += 2;
		}
	      else if (strncmp (s, "@@l", 2) == 0)
		{
		  the_insn.fup |= OP_SEL_L;
		  s += 2;
		}
	      else if (strncmp (s, "@@gotoff", 7) == 0
		       || strncmp (s, "@@GOTOFF", 7) == 0)
		{
		  as_bad (_("Assembler does not yet support PIC"));
		  the_insn.fup |= OP_SEL_GOTOFF;
		  s += 7;
		}
	      else if (strncmp (s, "@@got", 4) == 0
		       || strncmp (s, "@@GOT", 4) == 0)
		{
		  as_bad (_("Assembler does not yet support PIC"));
		  the_insn.fup |= OP_SEL_GOT;
		  s += 4;
		}
	      else if (strncmp (s, "@@plt", 4) == 0
		       || strncmp (s, "@@PLT", 4) == 0)
		{
		  as_bad (_("Assembler does not yet support PIC"));
		  the_insn.fup |= OP_SEL_PLT;
		  s += 4;
		}

	      the_insn.expand = insn->expand;

	      continue;
#else /* ! SYNTAX_SVR4 */
d680 1
a680 1
		  the_insn.fup |= OP_SEL_HA;
d685 1
a685 1
		  the_insn.fup |= OP_SEL_H;
d690 1
a690 1
		  the_insn.fup |= OP_SEL_L;
d695 4
a698 8
	      /* Note that if i860_get_expression() fails, we will still
		 have created U entries in the symbol table for the
		 'symbols' in the input string.  Try not to create U
		 symbols for registers, etc.  */
	      if (! i860_get_expression (s))
		s = expr_end;
	      else
		goto error;
d700 5
a704 2
	      continue;
#endif /* SYNTAX_SVR4 */
d716 2
a717 2
	  if (insn[1].name != NULL
	      && ! strcmp (insn->name, insn[1].name))
d720 1
a720 1
	      s = args_start;
d725 1
a725 1
	      as_bad (_("Illegal operands for %s"), insn->name);
d736 1
a736 1
i860_get_expression (str)
a758 4
/* Turn a string in input_line_pointer into a floating point constant of
   type TYPE, and store the appropriate bytes in *LITP.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is returned,
   or NULL on OK.  */
d760 10
a769 1
/* Equal to MAX_PRECISION in atof-ieee.c.  */
d786 1
d827 3
a829 1
/* Write out in current endian mode.  */
d836 107
a942 4
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
d945 1
a945 1
/* This should never be called for i860.  */
d948 2
a949 3
     char *buf ATTRIBUTE_UNUSED;
     long val ATTRIBUTE_UNUSED;
     int n ATTRIBUTE_UNUSED;
d954 1
a954 1
/* This should never be called for i860.  */
d957 3
a959 3
     char *buf ATTRIBUTE_UNUSED;
     long val ATTRIBUTE_UNUSED;
     void *fix ATTRIBUTE_UNUSED;
d964 41
a1004 1
/* This should never be called for i860.  */
d1007 2
a1008 2
     register fragS *fragP ATTRIBUTE_UNUSED;
     segT segtype ATTRIBUTE_UNUSED;
d1013 22
a1034 1
#ifdef DEBUG_I860
d1040 7
a1046 6
    fprintf (stderr, "ERROR: %s\n", insn->error);

  fprintf (stderr, "opcode = 0x%08lx\t", insn->opcode);
  fprintf (stderr, "expand = 0x%x\t", insn->expand);
  fprintf (stderr, "reloc = %s\t\n",
	   bfd_get_reloc_code_name (insn->reloc));
d1056 1
a1056 1
  fprintf (stderr, "\t\tX_add_number = %lx\n",
a1059 2
#endif /* DEBUG_I860 */

a1060 3
#ifdef OBJ_ELF
CONST char *md_shortopts = "VQ:";
#else
a1061 6
#endif

#define OPTION_EB		(OPTION_MD_BASE + 0)
#define OPTION_EL		(OPTION_MD_BASE + 1)
#define OPTION_WARN_EXPAND	(OPTION_MD_BASE + 2)

d1063 1
a1063 4
  { "EB",	    no_argument, NULL, OPTION_EB },
  { "EL",	    no_argument, NULL, OPTION_EL },
  { "mwarn-expand", no_argument, NULL, OPTION_WARN_EXPAND },
  { NULL,	    no_argument, NULL, 0 }
d1065 1
a1065 1
size_t md_longopts_size = sizeof (md_longopts);
d1070 1
a1070 1
     char *arg ATTRIBUTE_UNUSED;
d1072 1
a1072 31
  switch (c)
    {
    case OPTION_EB:
      target_big_endian = 1;
      break;

    case OPTION_EL:
      target_big_endian = 0;
      break;

    case OPTION_WARN_EXPAND:
      target_warn_expand = 1;
      break;

#ifdef OBJ_ELF
    /* SVR4 argument compatibility (-V): print version ID.  */
    case 'V':
      print_version_id ();
      break;

    /* SVR4 argument compatibility (-Qy, -Qn): controls whether
       a .comment section should be emitted or not (ignored).  */
    case 'Q':
      break;
#endif

    default:
      return 0;
    }

  return 1;
a1078 10
  fprintf (stream, _("\
  -EL			  generate code for little endian mode (default)\n\
  -EB			  generate code for big endian mode\n\
  -mwarn-expand		  warn if pseudo operations are expanded\n"));
#ifdef OBJ_ELF
  /* SVR4 compatibility flags.  */
  fprintf (stream, _("\
  -V			  print assembler version number\n\
  -Qy, -Qn		  ignored\n"));
#endif
a1079 1

d1081 5
a1085 9
/* We have no need to default values of symbols.  */
symbolS *
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
{
  return 0;
}

/* The i860 denotes auto-increment with '++'.  */
d1087 3
a1089 2
md_operand (exp)
     expressionS *exp;
d1091 4
a1094 1
  char *s;
d1096 2
a1097 1
  for (s = input_line_pointer; *s; s++)
d1099 2
a1100 1
      if (s[0] == '+' && s[1] == '+')
d1102 1
a1102 3
	  input_line_pointer += 2;
	  exp->X_op = O_register;
	  break;
d1104 2
a1105 2
    }
}
d1107 1
a1107 61
/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size ATTRIBUTE_UNUSED;
{
  /* Byte alignment is fine.  */
  return size;
}

/* On the i860, a PC-relative offset is relative to the address of the
   of the offset plus its size.  */
long
md_pcrel_from (fixP)
     fixS *fixP;
{
  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
}

/* Determine the relocation needed for non PC-relative 16-bit immediates.
   Also adjust the given immediate as necessary.  Finally, check that
   all constraints (such as alignment) are satisfied.   */
static bfd_reloc_code_real_type
obtain_reloc_for_imm16 (fix, val)
     fixS *fix;
     long *val;
{
  valueT fup = fix->fx_addnumber;
  bfd_reloc_code_real_type reloc;

  if (fix->fx_pcrel)
    abort ();

  /* Check alignment restrictions.  */
  if ((fup & OP_ALIGN2) && (*val & 0x1))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 2 alignment"));
  else if ((fup & OP_ALIGN4) && (*val & 0x3))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 4 alignment"));
  else if ((fup & OP_ALIGN8) && (*val & 0x7))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 8 alignment"));
  else if ((fup & OP_ALIGN16) && (*val & 0xf))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("This immediate requires 0 MOD 16 alignment"));

  if (fup & OP_SEL_HA)
    {
      *val = (*val >> 16) + (*val & 0x8000 ? 1 : 0);
      reloc = BFD_RELOC_860_HIGHADJ;
    }
  else if (fup & OP_SEL_H)
    {
      *val >>= 16;
      reloc = BFD_RELOC_860_HIGH;
    }
  else if (fup & OP_SEL_L)
    {
      int num_encode;
      if (fup & OP_IMM_SPLIT16)
d1109 3
a1111 6
	  if (fup & OP_ENCODE1)
	    {
	      num_encode = 1;
	      reloc = BFD_RELOC_860_SPLIT1;
	    }
	  else if (fup & OP_ENCODE2)
d1113 2
a1114 2
	      num_encode = 2;
	      reloc = BFD_RELOC_860_SPLIT2;
d1118 2
a1119 2
	      num_encode = 0;
	      reloc = BFD_RELOC_860_SPLIT0;
d1121 1
a1121 4
	}
      else
	{
	  if (fup & OP_ENCODE1)
d1123 1
a1123 2
	      num_encode = 1;
	      reloc = BFD_RELOC_860_LOW1;
d1125 2
a1126 1
	  else if (fup & OP_ENCODE2)
d1128 2
a1129 7
	      num_encode = 2;
	      reloc = BFD_RELOC_860_LOW2;
	    }
	  else if (fup & OP_ENCODE3)
	    {
	      num_encode = 3;
	      reloc = BFD_RELOC_860_LOW3;
d1133 1
a1133 2
	      num_encode = 0;
	      reloc = BFD_RELOC_860_LOW0;
d1135 3
a1138 8

      /* Preserve size encode bits.  */
      *val &= ~((1 << num_encode) - 1);
    }
  else
    {
      /* No selector.  What reloc do we generate (???)?  */
      reloc = BFD_RELOC_32;
a1139 2

  return reloc;
d1142 1
a1142 9
/* Attempt to simplify or eliminate a fixup. To indicate that a fixup
   has been eliminated, set fix->fx_done. If fix->fx_addsy is non-NULL,
   we will have to generate a reloc entry.  */
int
md_apply_fix3 (fix, valuep, seg)
     fixS *fix;
     valueT *valuep;
     segT seg ATTRIBUTE_UNUSED;
{
d1144 1
a1144 4
  char *buf;
  long val = (long) (*valuep);
  unsigned long insn;
  valueT fup;
d1146 4
a1149 1
  buf = fix->fx_frag->fr_literal + fix->fx_where;
d1151 10
a1160 2
  /* Recall that earlier we stored the opcode little-endian.  */
  insn = bfd_getl32 (buf);
d1162 2
a1163 2
  /* We stored a fix-up in this oddly-named scratch field.  */
  fup = fix->fx_addnumber;
d1165 1
a1165 3
  /* Determine the necessary relocations as well as inserting an
     immediate into the instruction.   */
  if (fup == OP_IMM_U5)
d1167 2
a1168 11
      if (val & ~0x1f)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("5-bit immediate too large"));
      if (fix->fx_addsy)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("5-bit field must be absolute"));

      insn |= (val & 0x1f) << 11;
      bfd_putl32 (insn, buf);
      fix->fx_r_type = BFD_RELOC_NONE;
      fix->fx_done = 1;
d1170 1
a1170 1
  else if (fup & OP_IMM_S16)
d1172 3
a1174 1
      fix->fx_r_type = obtain_reloc_for_imm16 (fix, &val);
d1176 14
a1189 10
      /* Insert the immediate.  */
      if (fix->fx_addsy)
	fix->fx_done = 0;
      else
	{
	  insn |= val & 0xffff;
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
d1191 2
a1192 1
  else if (fup & OP_IMM_U16)
d1194 2
a1195 1
      abort ();
d1197 1
a1197 1
  else if (fup & OP_IMM_SPLIT16)
d1199 7
a1205 1
      fix->fx_r_type = obtain_reloc_for_imm16 (fix, &val);
d1207 9
a1215 17
      /* Insert the immediate.  */
      if (fix->fx_addsy)
	fix->fx_done = 0;
      else
	{
	  insn |= val & 0x7ff;
	  insn |= (val & 0xf800) << 5;
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup & OP_IMM_BR16)
    {
      if (val & 0x3)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("A branch offset requires 0 MOD 4 alignment"));
d1217 8
a1224 1
      val = val >> 2;
d1226 9
a1234 20
      /* Insert the immediate.  */
      if (fix->fx_addsy)
	{
	  fix->fx_done = 0;
	  fix->fx_r_type = BFD_RELOC_860_PC16;
	}
      else
	{
	  insn |= (val & 0x7ff);
	  insn |= ((val & 0xf800) << 5);
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup & OP_IMM_BR26)
    {
      if (val & 0x3)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("A branch offset requires 0 MOD 4 alignment"));
d1236 6
a1241 1
      val >>= 2;
d1243 3
a1245 15
      /* Insert the immediate.  */
      if (fix->fx_addsy)
	{
	  fix->fx_r_type = BFD_RELOC_860_PC26;
	  fix->fx_done = 0;
	}
      else
	{
	  insn |= (val & 0x3ffffff);
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
    }
  else if (fup != OP_NONE)
d1247 2
a1248 3
      as_bad_where (fix->fx_file, fix->fx_line,
		    _("Unrecognized fix-up (0x%08x)"), fup);
      abort ();
d1252 1
a1252 14
      /* I believe only fix-ups such as ".long .ep.main-main+0xc8000000"
 	 reach here (???).  */
      if (fix->fx_addsy)
	{
	  fix->fx_r_type = BFD_RELOC_32;
	  fix->fx_done = 0;
	}
      else
	{
	  insn |= (val & 0xffffffff);
	  bfd_putl32 (insn, buf);
	  fix->fx_r_type = BFD_RELOC_NONE;
	  fix->fx_done = 1;
	}
d1254 1
d1256 6
a1261 3
  /* Return value ignored.  */
  return 0;
}
d1263 1
a1263 23
/* Generate a machine dependent reloc from a fixup.  */
arelent*
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *reloc;

  reloc = xmalloc (sizeof (*reloc));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->addend = fixp->fx_offset;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (! reloc->howto)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
                    "Cannot represent %s relocation in object file",
                    bfd_get_reloc_code_name (fixp->fx_r_type));
    }
  return reloc;
}
@


1.1.1.4
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002
d24 1
a27 1
#include "safe-ctype.h"
d412 1
a412 1
  for (s = str; ISLOWER (*s) || *s == '.' || *s == '3'
d488 1
a488 1
	      if (ISDIGIT (*s++))
d490 1
a490 1
		  while (ISDIGIT (*s))
d531 1
a531 1
		  if (!ISDIGIT (c = *s++))
d535 1
a535 1
		  if (ISDIGIT (*s))
d578 1
a578 1
	      if (*s++ == 'f' && ISDIGIT (*s))
d581 1
a581 1
		  if (ISDIGIT (*s))
d901 1
d959 20
d1016 1
a1016 1
const char *md_shortopts = "VQ:";
d1018 1
a1018 1
const char *md_shortopts = "";
d1231 4
a1234 5

void
md_apply_fix3 (fix, valP, seg)
     fixS * fix;
     valueT * valP;
d1237 1
d1239 1
a1239 1
  long val = *valP;
d1283 3
a1285 2
    abort ();

d1350 1
a1350 1
		    _("Unrecognized fix-up (0x%08lx)"), (unsigned long) fup);
d1370 3
@


1.1.1.5
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d2 1
a2 1
   Copyright 1989, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003
d32 5
d57 6
a62 4
/* Register prefix (depends on syntax).  */
static char reg_prefix;

#define MAX_FIXUPS 2
d68 1
d70 3
a72 7
  struct i860_fi
  {
    expressionS exp;
    bfd_reloc_code_real_type reloc;
    int pcrel;
    valueT fup;
  } fi[MAX_FIXUPS];
a74 3
/* The current fixup count.  */
static int fc;

a82 7
/* If true, then XP support is enabled.  */
static int target_xp = 0;

/* If true, then Intel syntax is enabled (default to AT&T/SVR4 syntax).  */
static int target_intel_syntax = 0;


d84 7
a90 7
static void i860_process_insn (char *);
static void s_dual (int);
static void s_enddual (int);
static void s_atmp (int);
static void s_align_wrapper (int);
static int i860_get_expression (char *);
static bfd_reloc_code_real_type obtain_reloc_for_imm16 (fixS *, long *); 
d92 1
a92 1
static void print_insn (struct i860_it *);
d97 7
a103 5
  {"align",   s_align_wrapper, 0},
  {"dual",    s_dual,          0},
  {"enddual", s_enddual,       0},
  {"atmp",    s_atmp,          0},
  {NULL,      0,               0},
d115 2
a116 1
s_dual (int ignore ATTRIBUTE_UNUSED)
d118 1
a118 4
  if (target_intel_syntax)
    dual_mode = DUAL_ON;
  else
    as_bad (_("Directive .dual available only with -mintel-syntax option"));
d123 2
a124 1
s_enddual (int ignore ATTRIBUTE_UNUSED)
d126 1
a126 4
  if (target_intel_syntax)
    dual_mode = DUAL_OFF;
  else
    as_bad (_("Directive .enddual available only with -mintel-syntax option"));
d133 2
a134 1
s_atmp (int ignore ATTRIBUTE_UNUSED)
d136 1
a136 9
  int temp;

  if (! target_intel_syntax)
    {
      as_bad (_("Directive .atmp available only with -mintel-syntax option"));
      demand_empty_rest_of_line ();
      return;
    }

a162 33
/* Handle ".align" directive depending on syntax mode.
   AT&T/SVR4 syntax uses the standard align directive.  However, 
   the Intel syntax additionally allows keywords for the alignment
   parameter: ".align type", where type is one of {.short, .long,
   .quad, .single, .double} representing alignments of 2, 4,
   16, 4, and 8, respectively.  */
static void
s_align_wrapper (int arg)
{
  char *parm = input_line_pointer;

  if (target_intel_syntax)
    {
      /* Replace a keyword with the equivalent integer so the
         standard align routine can parse the directive.  */
      if (strncmp (parm, ".short", 6) == 0)
        strncpy (parm, "     2", 6);
      else if (strncmp (parm, ".long", 5) == 0)
        strncpy (parm, "    4", 5);
      else if (strncmp (parm, ".quad", 5) == 0)
        strncpy (parm, "   16", 5);
      else if (strncmp (parm, ".single", 7) == 0)
        strncpy (parm, "      4", 7);
      else if (strncmp (parm, ".double", 7) == 0)
        strncpy (parm, "      8", 7);
     
      while (*input_line_pointer == ' ')
        ++input_line_pointer;
    }

  s_align_bytes (arg);
}

d167 1
a167 1
md_begin (void)
a201 3

  /* Set the register prefix for either Intel or AT&T/SVR4 syntax.  */
  reg_prefix = target_intel_syntax ? 0 : '%';
d208 2
a209 1
md_assemble (char *str)
a216 1
  fc = 0;
d223 2
a224 2
  if (the_insn.expand != 0 && the_insn.expand != XP_ONLY
      && ! (the_insn.fi[0].fup & (OP_SEL_HA | OP_SEL_H | OP_SEL_L | OP_SEL_GOT
a229 1
      fc = 1;
d238 4
a241 4
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 15)
		  && the_insn.fi[0].exp.X_add_number >= -(1 << 15)))
d246 1
a246 1
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);
d251 1
a251 1
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);
d257 4
a260 4
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 15)
		  && the_insn.fi[0].exp.X_add_number >= -(1 << 15)))
d263 3
a265 4
	  /* Emit "orh ha%addr_expr,ireg_src2,r31".  */
	  pseudo[0].opcode = 0xec000000 | (the_insn.opcode & 0x03e00000)
			     | (atmp << 16);
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_HA);
d270 1
a270 1
	  pseudo[1].fi[0].fup = the_insn.fi[0].fup | OP_SEL_L;
d276 4
a279 4
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 16)
		  && the_insn.fi[0].exp.X_add_number >= 0))
d285 1
a285 1
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);
d290 1
a290 1
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);
d296 4
a299 4
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 16)
		  && the_insn.fi[0].exp.X_add_number >= 0))
d305 2
a306 3
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);
	  pseudo[0].fi[0].exp.X_add_number =
            -1 - the_insn.fi[0].exp.X_add_number;
d311 2
a312 3
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);
	  pseudo[1].fi[0].exp.X_add_number =
            -1 - the_insn.fi[0].exp.X_add_number;
d318 4
a321 4
	  if (the_insn.fi[0].exp.X_add_symbol == NULL
	      && the_insn.fi[0].exp.X_op_symbol == NULL
	      && (the_insn.fi[0].exp.X_add_number < (1 << 15)
		  && the_insn.fi[0].exp.X_add_number >= -(1 << 15)))
d326 1
a326 1
	  pseudo[0].fi[0].fup = (OP_IMM_S16 | OP_SEL_H);
d330 1
a330 1
	  pseudo[1].fi[0].fup = (OP_IMM_S16 | OP_SEL_L);
d334 1
a334 1
	  pseudo[2].fi[0].fup = OP_IMM_S16;
a360 2
      int tmp;

d367 1
a367 1
      last_expand = the_insn.fi[0].pcrel;
d369 15
a383 20
      /* Output the symbol-dependent stuff.  Only btne and bte will ever
         loop more than once here, since only they (possibly) have more
         than one fixup.  */
      for (tmp = 0; tmp < fc; tmp++)
        {
          if (the_insn.fi[tmp].fup != OP_NONE)
	    {
	      fixS *fix;
	      fix = fix_new_exp (frag_now,
			         destp - frag_now->fr_literal,
			         4,
			         &the_insn.fi[tmp].exp,
			         the_insn.fi[tmp].pcrel,
			         the_insn.fi[tmp].reloc);

	     /* Despite the odd name, this is a scratch field.  We use
	        it to encode operand type information.  */
	     fix->fx_addnumber = the_insn.fi[tmp].fup;
	   }
        }
d392 2
a393 1
i860_process_insn (char *str)
a457 1
      int t;
d460 3
a462 7
      fc = 0;
      for (t = 0; t < MAX_FIXUPS; t++)
        {
          the_insn.fi[t].reloc = BFD_RELOC_NONE;
          the_insn.fi[t].pcrel = 0;
          the_insn.fi[t].fup = OP_NONE;
        }
a466 3
          if (fc > MAX_FIXUPS)
            abort ();

d503 1
a503 1
	      else if (reg_prefix)
d575 1
a575 1
	      else if (reg_prefix)
d605 6
d624 1
a624 1
	      else if (reg_prefix)
a662 37
	      /* The remaining control registers are XP only.  */
	      if (target_xp && strncmp (s, "bear", 4) == 0)
		{
		  opcode |= 0x6 << 21;
		  s += 4;
		  continue;
		}
	      if (target_xp && strncmp (s, "ccr", 3) == 0)
		{
		  opcode |= 0x7 << 21;
		  s += 3;
		  continue;
		}
	      if (target_xp && strncmp (s, "p0", 2) == 0)
		{
		  opcode |= 0x8 << 21;
		  s += 2;
		  continue;
		}
	      if (target_xp && strncmp (s, "p1", 2) == 0)
		{
		  opcode |= 0x9 << 21;
		  s += 2;
		  continue;
		}
	      if (target_xp && strncmp (s, "p2", 2) == 0)
		{
		  opcode |= 0xa << 21;
		  s += 2;
		  continue;
		}
	      if (target_xp && strncmp (s, "p3", 2) == 0)
		{
		  opcode |= 0xb << 21;
		  s += 2;
		  continue;
		}
d670 1
a670 2
		  the_insn.fi[fc].fup |= OP_IMM_U5;
		  fc++;
d677 2
a678 2
	      the_insn.fi[fc].pcrel = 1;
	      the_insn.fi[fc].fup |= OP_IMM_BR26;
d683 2
a684 2
	      the_insn.fi[fc].pcrel = 1;
	      the_insn.fi[fc].fup |= OP_IMM_BR16;
d689 1
a689 1
	      the_insn.fi[fc].fup |= OP_IMM_SPLIT16;
d694 1
a694 1
	      the_insn.fi[fc].fup |= OP_IMM_SPLIT16;
d699 1
a699 1
	      the_insn.fi[fc].fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN2);
d704 1
a704 1
	      the_insn.fi[fc].fup |= (OP_IMM_SPLIT16 | OP_ENCODE1 | OP_ALIGN4);
d709 1
a709 1
	      the_insn.fi[fc].fup |= OP_IMM_S16;
d714 1
a714 1
	      the_insn.fi[fc].fup |= OP_IMM_S16;
d719 1
a719 1
	      the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN2);
d725 1
a725 1
		the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE1 | OP_ALIGN4);
d727 1
a727 1
		the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE2 | OP_ALIGN4);
d732 1
a732 1
	      the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN8);
d737 1
a737 1
	      the_insn.fi[fc].fup |= (OP_IMM_S16 | OP_ENCODE3 | OP_ALIGN16);
d745 37
a781 1
	      if (target_intel_syntax == 0)
d783 11
a793 12
		  /* AT&T/SVR4 syntax.  */
	          if (*s == ' ')
		    s++;

	          /* Note that if i860_get_expression() fails, we will still
	  	     have created U entries in the symbol table for the
		     'symbols' in the input string.  Try not to create U
		     symbols for registers, etc.  */
	          if (! i860_get_expression (s))
		    s = expr_end;
	          else
		    goto error;
d795 1
a795 36
	          if (strncmp (s, "@@ha", 3) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_HA;
		      s += 3;
		    }
	          else if (strncmp (s, "@@h", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_H;
		      s += 2;
		    }
	          else if (strncmp (s, "@@l", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_L;
		      s += 2;
		    }
	          else if (strncmp (s, "@@gotoff", 7) == 0
		           || strncmp (s, "@@GOTOFF", 7) == 0)
		    {
		      as_bad (_("Assembler does not yet support PIC"));
		      the_insn.fi[fc].fup |= OP_SEL_GOTOFF;
		      s += 7;
		    }
	          else if (strncmp (s, "@@got", 4) == 0
		           || strncmp (s, "@@GOT", 4) == 0)
		    {
		      as_bad (_("Assembler does not yet support PIC"));
		      the_insn.fi[fc].fup |= OP_SEL_GOT;
		      s += 4;
		    }
	          else if (strncmp (s, "@@plt", 4) == 0
		           || strncmp (s, "@@PLT", 4) == 0)
		    {
		      as_bad (_("Assembler does not yet support PIC"));
		      the_insn.fi[fc].fup |= OP_SEL_PLT;
		      s += 4;
		    }
d797 13
a809 4
	          the_insn.expand = insn->expand;
                  fc++;
              
	          continue;
d811 1
a811 1
	      else
d813 4
a816 19
		  /* Intel syntax.  */
	          if (*s == ' ')
		    s++;
	          if (strncmp (s, "ha%", 3) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_HA;
		      s += 3;
		    }
	          else if (strncmp (s, "h%", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_H;
		      s += 2;
		    }
	          else if (strncmp (s, "l%", 2) == 0)
		    {
		      the_insn.fi[fc].fup |= OP_SEL_L;
		      s += 2;
		    }
	          the_insn.expand = insn->expand;
d818 8
a825 8
	          /* Note that if i860_get_expression() fails, we will still
		     have created U entries in the symbol table for the
		     'symbols' in the input string.  Try not to create U
		     symbols for registers, etc.  */
	          if (! i860_get_expression (s))
		    s = expr_end;
	          else
		    goto error;
d827 2
a828 3
                  fc++;
	          continue;
		}
a855 21
  /* Set the dual bit on this instruction if necessary.  */
  if (dual_mode != DUAL_OFF)
    {
      if ((opcode & 0xfc000000) == 0x48000000 || opcode == 0xb0000000)
        {
	  /* The instruction is a flop or a fnop, so set its dual bit
	     (but check that it is 8-byte aligned).  */
	  if (((frag_now->fr_address + frag_now_fix_octets ()) & 7) == 0)
	    opcode |= (1 << 9);
	  else
            as_bad (_("'d.%s' must be 8-byte aligned"), insn->name);

          if (dual_mode == DUAL_DDOT)
	    dual_mode = DUAL_OFF;
          else if (dual_mode == DUAL_ONDDOT)
	    dual_mode = DUAL_ON;
        }
      else if (dual_mode == DUAL_DDOT || dual_mode == DUAL_ONDDOT)
        as_bad (_("Prefix 'd.' invalid for instruction `%s'"), insn->name);
    }

a856 4

  /* Only recognize XP instructions when the user has requested it.  */
  if (insn->expand == XP_ONLY && ! target_xp)
    as_bad (_("Unknown opcode: `%s'"), insn->name);
d860 2
a861 1
i860_get_expression (char *str)
d868 1
a868 1
  seg = expression (&the_insn.fi[fc].exp);
d892 4
a895 1
md_atof (int type, char *litP, int *sizeP)
d946 4
a949 1
md_number_to_chars (char *buf, valueT val, int n)
d959 3
a961 2
md_estimate_size_before_relax (register fragS *fragP ATTRIBUTE_UNUSED,
			       segT segtype ATTRIBUTE_UNUSED)
d968 2
a969 1
print_insn (struct i860_it *insn)
a1002 2
#define OPTION_XP		(OPTION_MD_BASE + 3)
#define OPTION_INTEL_SYNTAX	(OPTION_MD_BASE + 4)
a1007 2
  { "mxp",	    no_argument, NULL, OPTION_XP },
  { "mintel-syntax",no_argument, NULL, OPTION_INTEL_SYNTAX },
d1013 3
a1015 1
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
a1030 8
    case OPTION_XP:
      target_xp = 1;
      break;

    case OPTION_INTEL_SYNTAX:
      target_intel_syntax = 1;
      break;

d1051 2
a1052 1
md_show_usage (FILE *stream)
d1057 1
a1057 3
  -mwarn-expand		  warn if pseudo operations are expanded\n\
  -mxp			  enable i860XP support (disabled by default)\n\
  -mintel-syntax	  enable Intel syntax (default to AT&T/SVR4)\n"));
d1069 2
a1070 1
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
d1077 2
a1078 1
md_operand (expressionS *exp)
d1095 3
a1097 2
md_section_align (segT segment ATTRIBUTE_UNUSED,
		  valueT size ATTRIBUTE_UNUSED)
d1104 1
a1104 1
   offset plus its size.  */
d1106 2
a1107 1
md_pcrel_from (fixS *fixP)
d1116 3
a1118 1
obtain_reloc_for_imm16 (fixS *fix, long *val)
d1212 4
a1215 1
md_apply_fix3 (fixS *fix, valueT *valP, segT seg ATTRIBUTE_UNUSED)
d1232 1
a1232 1
  if (fup & OP_IMM_U5)
d1352 3
a1354 2
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED,
	      fixS *fixp)
a1372 49

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
i860_handle_align (fragS *fragp)
{
  /* Instructions are always stored little-endian on the i860.  */
  static const unsigned char le_nop[] = { 0x00, 0x00, 0x00, 0xA0 };

  int bytes;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;

  /* Make sure we are on a 4-byte boundary, in case someone has been
     putting data into a text section.  */
  if (bytes & 3)
    {
      int fix = bytes & 3;
      memset (p, 0, fix);
      p += fix;
      fragp->fr_fix += fix;
    }

  memcpy (p, le_nop, 4);
  fragp->fr_var = 4;
}

/* This is called after a user-defined label is seen.  We check
   if the label has a double colon (valid in Intel syntax mode only),
   in which case it should be externalized.  */

void
i860_check_label (symbolS *labelsym)
{
  /* At this point, the current line pointer is sitting on the character
     just after the first colon on the label.  */ 
  if (target_intel_syntax && *input_line_pointer == ':')
    {
      S_SET_EXTERNAL (labelsym);
      input_line_pointer++;
    }
}

@


