head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.50
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.16
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.24;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.28;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.42;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.04.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.38;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.38;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.35;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.43.36;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.46.11;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.31.55;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.25;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.43;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* hash.c -- gas hash table code
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* This version of the hash table code is a wholescale replacement of
   the old hash table code, which was fairly bad.  This is based on
   the hash table code in BFD, but optimized slightly for the
   assembler.  The assembler does not need to derive structures that
   are stored in the hash table.  Instead, it always stores a pointer.
   The assembler uses the hash table mostly to store symbols, and we
   don't need to confuse the symbol structure with a hash table
   structure.  */

#include "as.h"
#include "safe-ctype.h"
#include "obstack.h"

/* The default number of entries to use when creating a hash table.  */

#define DEFAULT_SIZE (4051)

/* An entry in a hash table.  */

struct hash_entry {
  /* Next entry for this hash code.  */
  struct hash_entry *next;
  /* String being hashed.  */
  const char *string;
  /* Hash code.  This is the full hash code, not the index into the
     table.  */
  unsigned long hash;
  /* Pointer being stored in the hash table.  */
  PTR data;
};

/* A hash table.  */

struct hash_control {
  /* The hash array.  */
  struct hash_entry **table;
  /* The number of slots in the hash table.  */
  unsigned int size;
  /* An obstack for this hash table.  */
  struct obstack memory;

#ifdef HASH_STATISTICS
  /* Statistics.  */
  unsigned long lookups;
  unsigned long hash_compares;
  unsigned long string_compares;
  unsigned long insertions;
  unsigned long replacements;
  unsigned long deletions;
#endif /* HASH_STATISTICS */
};

/* Create a hash table.  This return a control block.  */

struct hash_control *
hash_new (void)
{
  unsigned int size;
  struct hash_control *ret;
  unsigned int alloc;

  size = DEFAULT_SIZE;

  ret = (struct hash_control *) xmalloc (sizeof *ret);
  obstack_begin (&ret->memory, chunksize);
  alloc = size * sizeof (struct hash_entry *);
  ret->table = (struct hash_entry **) obstack_alloc (&ret->memory, alloc);
  memset (ret->table, 0, alloc);
  ret->size = size;

#ifdef HASH_STATISTICS
  ret->lookups = 0;
  ret->hash_compares = 0;
  ret->string_compares = 0;
  ret->insertions = 0;
  ret->replacements = 0;
  ret->deletions = 0;
#endif

  return ret;
}

/* Delete a hash table, freeing all allocated memory.  */

void
hash_die (struct hash_control *table)
{
  obstack_free (&table->memory, 0);
  free (table);
}

/* Look up a string in a hash table.  This returns a pointer to the
   hash_entry, or NULL if the string is not in the table.  If PLIST is
   not NULL, this sets *PLIST to point to the start of the list which
   would hold this hash entry.  If PHASH is not NULL, this sets *PHASH
   to the hash code for KEY.

   Each time we look up a string, we move it to the start of the list
   for its hash code, to take advantage of referential locality.  */

static struct hash_entry *hash_lookup (struct hash_control *,
				       const char *,
				       struct hash_entry ***,
				       unsigned long *);

static struct hash_entry *
hash_lookup (struct hash_control *table, const char *key,
	     struct hash_entry ***plist, unsigned long *phash)
{
  register unsigned long hash;
  unsigned int len;
  register const unsigned char *s;
  register unsigned int c;
  unsigned int index;
  struct hash_entry **list;
  struct hash_entry *p;
  struct hash_entry *prev;

#ifdef HASH_STATISTICS
  ++table->lookups;
#endif

  hash = 0;
  len = 0;
  s = (const unsigned char *) key;
  while ((c = *s++) != '\0')
    {
      hash += c + (c << 17);
      hash ^= hash >> 2;
      ++len;
    }
  hash += len + (len << 17);
  hash ^= hash >> 2;

  if (phash != NULL)
    *phash = hash;

  index = hash % table->size;
  list = table->table + index;

  if (plist != NULL)
    *plist = list;

  prev = NULL;
  for (p = *list; p != NULL; p = p->next)
    {
#ifdef HASH_STATISTICS
      ++table->hash_compares;
#endif

      if (p->hash == hash)
	{
#ifdef HASH_STATISTICS
	  ++table->string_compares;
#endif

	  if (strcmp (p->string, key) == 0)
	    {
	      if (prev != NULL)
		{
		  prev->next = p->next;
		  p->next = *list;
		  *list = p;
		}

	      return p;
	    }
	}

      prev = p;
    }

  return NULL;
}

/* Insert an entry into a hash table.  This returns NULL on success.
   On error, it returns a printable string indicating the error.  It
   is considered to be an error if the entry already exists in the
   hash table.  */

const char *
hash_insert (struct hash_control *table, const char *key, PTR value)
{
  struct hash_entry *p;
  struct hash_entry **list;
  unsigned long hash;

  p = hash_lookup (table, key, &list, &hash);
  if (p != NULL)
    return "exists";

#ifdef HASH_STATISTICS
  ++table->insertions;
#endif

  p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
  p->string = key;
  p->hash = hash;
  p->data = value;

  p->next = *list;
  *list = p;

  return NULL;
}

/* Insert or replace an entry in a hash table.  This returns NULL on
   success.  On error, it returns a printable string indicating the
   error.  If an entry already exists, its value is replaced.  */

const char *
hash_jam (struct hash_control *table, const char *key, PTR value)
{
  struct hash_entry *p;
  struct hash_entry **list;
  unsigned long hash;

  p = hash_lookup (table, key, &list, &hash);
  if (p != NULL)
    {
#ifdef HASH_STATISTICS
      ++table->replacements;
#endif

      p->data = value;
    }
  else
    {
#ifdef HASH_STATISTICS
      ++table->insertions;
#endif

      p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
      p->string = key;
      p->hash = hash;
      p->data = value;

      p->next = *list;
      *list = p;
    }

  return NULL;
}

/* Replace an existing entry in a hash table.  This returns the old
   value stored for the entry.  If the entry is not found in the hash
   table, this does nothing and returns NULL.  */

PTR
hash_replace (struct hash_control *table, const char *key, PTR value)
{
  struct hash_entry *p;
  PTR ret;

  p = hash_lookup (table, key, NULL, NULL);
  if (p == NULL)
    return NULL;

#ifdef HASH_STATISTICS
  ++table->replacements;
#endif

  ret = p->data;

  p->data = value;

  return ret;
}

/* Find an entry in a hash table, returning its value.  Returns NULL
   if the entry is not found.  */

PTR
hash_find (struct hash_control *table, const char *key)
{
  struct hash_entry *p;

  p = hash_lookup (table, key, NULL, NULL);
  if (p == NULL)
    return NULL;

  return p->data;
}

/* Delete an entry from a hash table.  This returns the value stored
   for that entry, or NULL if there is no such entry.  */

PTR
hash_delete (struct hash_control *table, const char *key)
{
  struct hash_entry *p;
  struct hash_entry **list;

  p = hash_lookup (table, key, &list, NULL);
  if (p == NULL)
    return NULL;

  if (p != *list)
    abort ();

#ifdef HASH_STATISTICS
  ++table->deletions;
#endif

  *list = p->next;

  /* Note that we never reclaim the memory for this entry.  If gas
     ever starts deleting hash table entries in a big way, this will
     have to change.  */

  return p->data;
}

/* Traverse a hash table.  Call the function on every entry in the
   hash table.  */

void
hash_traverse (struct hash_control *table,
	       void (*pfn) (const char *key, PTR value))
{
  unsigned int i;

  for (i = 0; i < table->size; ++i)
    {
      struct hash_entry *p;

      for (p = table->table[i]; p != NULL; p = p->next)
	(*pfn) (p->string, p->data);
    }
}

/* Print hash table statistics on the specified file.  NAME is the
   name of the hash table, used for printing a header.  */

void
hash_print_statistics (FILE *f ATTRIBUTE_UNUSED,
		       const char *name ATTRIBUTE_UNUSED,
		       struct hash_control *table ATTRIBUTE_UNUSED)
{
#ifdef HASH_STATISTICS
  unsigned int i;
  unsigned long total;
  unsigned long empty;

  fprintf (f, "%s hash statistics:\n", name);
  fprintf (f, "\t%lu lookups\n", table->lookups);
  fprintf (f, "\t%lu hash comparisons\n", table->hash_compares);
  fprintf (f, "\t%lu string comparisons\n", table->string_compares);
  fprintf (f, "\t%lu insertions\n", table->insertions);
  fprintf (f, "\t%lu replacements\n", table->replacements);
  fprintf (f, "\t%lu deletions\n", table->deletions);

  total = 0;
  empty = 0;
  for (i = 0; i < table->size; ++i)
    {
      struct hash_entry *p;

      if (table->table[i] == NULL)
	++empty;
      else
	{
	  for (p = table->table[i]; p != NULL; p = p->next)
	    ++total;
	}
    }

  fprintf (f, "\t%g average chain length\n", (double) total / table->size);
  fprintf (f, "\t%lu empty slots\n", empty);
#endif
}

#ifdef TEST

/* This test program is left over from the old hash table code.  */

/* Number of hash tables to maintain (at once) in any testing.  */
#define TABLES (6)

/* We can have 12 statistics.  */
#define STATBUFSIZE (12)

/* Display statistics here.  */
int statbuf[STATBUFSIZE];

/* Human farts here.  */
char answer[100];

/* We test many hash tables at once.  */
char *hashtable[TABLES];

/* Points to current hash_control.  */
char *h;
char **pp;
char *p;
char *name;
char *value;
int size;
int used;
char command;

/* Number 0:TABLES-1 of current hashed symbol table.  */
int number;

int
main ()
{
  void applicatee ();
  void destroy ();
  char *what ();
  int *ip;

  number = 0;
  h = 0;
  printf ("type h <RETURN> for help\n");
  for (;;)
    {
      printf ("hash_test command: ");
      gets (answer);
      command = answer[0];
      command = TOLOWER (command);	/* Ecch!  */
      switch (command)
	{
	case '#':
	  printf ("old hash table #=%d.\n", number);
	  whattable ();
	  break;
	case '?':
	  for (pp = hashtable; pp < hashtable + TABLES; pp++)
	    {
	      printf ("address of hash table #%d control block is %xx\n",
		      pp - hashtable, *pp);
	    }
	  break;
	case 'a':
	  hash_traverse (h, applicatee);
	  break;
	case 'd':
	  hash_traverse (h, destroy);
	  hash_die (h);
	  break;
	case 'f':
	  p = hash_find (h, name = what ("symbol"));
	  printf ("value of \"%s\" is \"%s\"\n", name, p ? p : "NOT-PRESENT");
	  break;
	case 'h':
	  printf ("# show old, select new default hash table number\n");
	  printf ("? display all hashtable control block addresses\n");
	  printf ("a apply a simple display-er to each symbol in table\n");
	  printf ("d die: destroy hashtable\n");
	  printf ("f find value of nominated symbol\n");
	  printf ("h this help\n");
	  printf ("i insert value into symbol\n");
	  printf ("j jam value into symbol\n");
	  printf ("n new hashtable\n");
	  printf ("r replace a value with another\n");
	  printf ("s say what %% of table is used\n");
	  printf ("q exit this program\n");
	  printf ("x delete a symbol from table, report its value\n");
	  break;
	case 'i':
	  p = hash_insert (h, name = what ("symbol"), value = what ("value"));
	  if (p)
	    {
	      printf ("symbol=\"%s\"  value=\"%s\"  error=%s\n", name, value,
		      p);
	    }
	  break;
	case 'j':
	  p = hash_jam (h, name = what ("symbol"), value = what ("value"));
	  if (p)
	    {
	      printf ("symbol=\"%s\"  value=\"%s\"  error=%s\n", name, value, p);
	    }
	  break;
	case 'n':
	  h = hashtable[number] = (char *) hash_new ();
	  break;
	case 'q':
	  exit (EXIT_SUCCESS);
	case 'r':
	  p = hash_replace (h, name = what ("symbol"), value = what ("value"));
	  printf ("old value was \"%s\"\n", p ? p : "{}");
	  break;
	case 's':
	  hash_say (h, statbuf, STATBUFSIZE);
	  for (ip = statbuf; ip < statbuf + STATBUFSIZE; ip++)
	    {
	      printf ("%d ", *ip);
	    }
	  printf ("\n");
	  break;
	case 'x':
	  p = hash_delete (h, name = what ("symbol"));
	  printf ("old value was \"%s\"\n", p ? p : "{}");
	  break;
	default:
	  printf ("I can't understand command \"%c\"\n", command);
	  break;
	}
    }
}

char *
what (description)
     char *description;
{
  printf ("   %s : ", description);
  gets (answer);
  return xstrdup (answer);
}

void
destroy (string, value)
     char *string;
     char *value;
{
  free (string);
  free (value);
}

void
applicatee (string, value)
     char *string;
     char *value;
{
  printf ("%.20s-%.20s\n", string, value);
}

/* Determine number: what hash table to use.
   Also determine h: points to hash_control.  */

void
whattable ()
{
  for (;;)
    {
      printf ("   what hash table (%d:%d) ?  ", 0, TABLES - 1);
      gets (answer);
      sscanf (answer, "%d", &number);
      if (number >= 0 && number < TABLES)
	{
	  h = hashtable[number];
	  if (!h)
	    {
	      printf ("warning: current hash-table-#%d. has no hash-control\n", number);
	    }
	  return;
	}
      else
	{
	  printf ("invalid hash table number: %d\n", number);
	}
    }
}

#endif /* TEST */
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d26 1
a26 1
   asssembler.  The assembler does not need to derive structures that
d78 1
a78 1
hash_new ()
d108 1
a108 2
hash_die (table)
     struct hash_control *table;
d123 4
a126 4
static struct hash_entry *hash_lookup PARAMS ((struct hash_control *,
					       const char *,
					       struct hash_entry ***,
					       unsigned long *));
d129 2
a130 5
hash_lookup (table, key, plist, phash)
     struct hash_control *table;
     const char *key;
     struct hash_entry ***plist;
     unsigned long *phash;
d204 1
a204 4
hash_insert (table, key, value)
     struct hash_control *table;
     const char *key;
     PTR value;
d234 1
a234 4
hash_jam (table, key, value)
     struct hash_control *table;
     const char *key;
     PTR value;
d272 1
a272 4
hash_replace (table, key, value)
     struct hash_control *table;
     const char *key;
     PTR value;
d296 1
a296 3
hash_find (table, key)
     struct hash_control *table;
     const char *key;
d311 1
a311 3
hash_delete (table, key)
     struct hash_control *table;
     const char *key;
d340 2
a341 3
hash_traverse (table, pfn)
     struct hash_control *table;
     void (*pfn) PARAMS ((const char *key, PTR value));
d358 3
a360 4
hash_print_statistics (f, name, table)
     FILE *f ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     struct hash_control *table ATTRIBUTE_UNUSED;
d414 1
a414 1
/* Points to curent hash_control.  */
@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2000
d33 1
d462 1
a462 2
      if (isupper (command))
	command = tolower (command);	/* Ecch!  */
a548 3
  char *retval;
  char *malloc ();

d551 1
a551 8
  /* Will one day clean up answer here.  */
  retval = malloc (strlen (answer) + 1);
  if (!retval)
    {
      error ("room");
    }
  (void) strcpy (retval, answer);
  return (retval);
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 98, 1999
d41 1
a41 2
struct hash_entry
{
d55 1
a55 2
struct hash_control
{
d101 1
a101 1
  return ret;  
d224 1
a224 1
  p = obstack_alloc (&table->memory, sizeof *p);
d264 1
a264 1
      p = obstack_alloc (&table->memory, sizeof *p);
d417 17
a433 8
#define TABLES (6)		/* number of hash tables to maintain */
				/* (at once) in any testing */
#define STATBUFSIZE (12)	/* we can have 12 statistics */

int statbuf[STATBUFSIZE];	/* display statistics here */
char answer[100];		/* human farts here */
char *hashtable[TABLES];	/* we test many hash tables at once */
char *h;			/* points to curent hash_control */
d441 3
a443 2
int number;			/* number 0:TABLES-1 of current hashed */
				/* symbol table */
d462 1
a462 1
	command = tolower (command);	/* ecch! */
d472 2
a473 2
	      printf ("address of hash table #%d control block is %xx\n"
		      ,pp - hashtable, *pp);
d554 1
a554 1
  /* will one day clean up answer here */
a572 1

d581 3
d585 1
a585 2
whattable ()			/* determine number: what hash table to use */
			        /* also determine h: points to hash_control */
a586 1

d608 1
a608 3
#endif /* #ifdef TEST */

/* end of hash.c */
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d1 2
a2 2
/* hash.c - hash table lookup strings -
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996
d18 12
a29 117
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*
 * BUGS, GRIPES, APOLOGIA etc.
 *
 * A typical user doesn't need ALL this: I intend to make a library out
 * of it one day - Dean Elsner.
 * Also, I want to change the definition of a symbol to (address,length)
 * so I can put arbitrary binary in the names stored. [see hsh.c for that]
 *
 * This slime is common coupled inside the module. Com-coupling (and other
 * vandalism) was done to speed running time. The interfaces at the
 * module's edges are adequately clean.
 *
 * There is no way to (a) run a test script through this heap and (b)
 * compare results with previous scripts, to see if we have broken any
 * code. Use GNU (f)utilities to do this. A few commands assist test.
 * The testing is awkward: it tries to be both batch & interactive.
 * For now, interactive rules!
 */

/*
 *  The idea is to implement a symbol table. A test jig is here.
 *  Symbols are arbitrary strings; they can't contain '\0'.
 *	[See hsh.c for a more general symbol flavour.]
 *  Each symbol is associated with a char*, which can point to anything
 *  you want, allowing an arbitrary property list for each symbol.
 *
 *  The basic operations are:
 *
 *    new                     creates symbol table, returns handle
 *    find (symbol)           returns char*
 *    insert (symbol,char*)   error if symbol already in table
 *    delete (symbol)         returns char* if symbol was in table
 *    apply                   so you can delete all symbols before die()
 *    die                     destroy symbol table (free up memory)
 *
 *  Supplementary functions include:
 *
 *    say                     how big? what % full?
 *    replace (symbol,newval) report previous value
 *    jam (symbol,value)      assert symbol:=value
 *
 *  You, the caller, have control over errors: this just reports them.
 *
 *  This package requires malloc(), free().
 *  Malloc(size) returns NULL or address of char[size].
 *  Free(address) frees same.
 */

/*
 *  The code and its structures are re-enterent.
 *
 *  Before you do anything else, you must call hash_new() which will
 *  return the address of a hash-table-control-block.  You then use
 *  this address as a handle of the symbol table by passing it to all
 *  the other hash_...() functions.  The only approved way to recover
 *  the memory used by the symbol table is to call hash_die() with the
 *  handle of the symbol table.
 *
 *  Before you call hash_die() you normally delete anything pointed to
 *  by individual symbols. After hash_die() you can't use that symbol
 *  table again.
 *
 *  The char* you associate with a symbol may not be NULL (0) because
 *  NULL is returned whenever a symbol is not in the table. Any other
 *  value is OK, except DELETED, #defined below.
 *
 *  When you supply a symbol string for insertion, YOU MUST PRESERVE THE
 *  STRING until that symbol is deleted from the table. The reason is that
 *  only the address you supply, NOT the symbol string itself, is stored
 *  in the symbol table.
 *
 *  You may delete and add symbols arbitrarily.
 *  Any or all symbols may have the same 'value' (char *). In fact, these
 *  routines don't do anything with your symbol values.
 *
 *  You have no right to know where the symbol:char* mapping is stored,
 *  because it moves around in memory; also because we may change how it
 *  works and we don't want to break your code do we? However the handle
 *  (address of struct hash_control) is never changed in
 *  the life of the symbol table.
 *
 *  What you CAN find out about a symbol table is:
 *    how many slots are in the hash table?
 *    how many slots are filled with symbols?
 *    (total hashes,collisions) for (reads,writes) (*)
 *  All of the above values vary in time.
 *  (*) some of these numbers will not be meaningful if we change the
 *  internals. */

/*
 *  I N T E R N A L
 *
 *  Hash table is an array of hash_entries; each entry is a pointer to a
 *  a string and a user-supplied value 1 char* wide.
 *
 *  The array always has 2 ** n elements, n>0, n integer.
 *  There is also a 'wall' entry after the array, which is always empty
 *  and acts as a sentinel to stop running off the end of the array.
 *  When the array gets too full, we create a new array twice as large
 *  and re-hash the symbols into the new array, then forget the old array.
 *  (Of course, we copy the values into the new array before we junk the
 *  old array!)
 *
 */

#include <stdio.h>

#ifndef FALSE
#define FALSE	(0)
#define TRUE	(!FALSE)
#endif /* no FALSE yet */

#include <ctype.h>
#define min(a, b)	((a) < (b) ? (a) : (b))
d32 1
d34 1
a34 1
#define error	as_fatal
d36 1
a36 28
static char _deleted_[1];
#define DELETED     ((PTR)_deleted_)	/* guarenteed unique address */
#define START_POWER    (10)	/* power of two: size of new hash table */

/* TRUE if a symbol is in entry @@ ptr.  */
#define islive(ptr) (ptr->hash_string && ptr->hash_string!=DELETED)

enum stat_enum {
  /* Number of slots in hash table.  The wall does not count here.
     We expect this is always a power of 2.  */
  STAT_SIZE = 0,
  /* Number of hash_ask calls.  */
  STAT_ACCESS,
  STAT_ACCESS_w,
  /* Number of collisions (total).  This may exceed STAT_ACCESS if we
     have lots of collisions/access.  */
  STAT_COLLIDE,
  STAT_COLLIDE_w,
  /* Slots used right now.  */
  STAT_USED,
  /* How many string compares?  */
  STAT_STRCMP,
  STAT_STRCMP_w,
  /* Size of statistics block... this must be last.  */
  STATLENGTH
};
#define STAT__READ     (0)	/* reading */
#define STAT__WRITE    (1)	/* writing */
d38 1
a38 4
/* When we grow a hash table, by what power of two do we increase it?  */
#define GROW_FACTOR 1
/* When should we grow it?  */
#define FULL_VALUE(N)	((N) / 2)
a39 13
/* #define SUSPECT to do runtime checks */
/* #define TEST to be a test jig for hash...() */

#ifdef TEST
/* TEST: use smaller hash table */
#undef  START_POWER
#define START_POWER (3)
#undef  START_SIZE
#define START_SIZE  (8)
#undef  START_FULL
#define START_FULL  (4)
#endif

d42 9
a50 5
  const char *hash_string;	/* points to where the symbol string is */
  /* NULL means slot is not used */
  /* DELETED means slot was deleted */
  PTR hash_value;		/* user's datum, associated with symbol */
  unsigned long h;
d53 20
a72 9
struct hash_control {
  struct hash_entry *hash_where;/* address of hash table */
  int hash_sizelog;		/* Log of ( hash_mask + 1 ) */
  int hash_mask;		/* masks a hash into index into table */
  int hash_full;		/* when hash_stat[STAT_USED] exceeds this, */
  /* grow table */
  struct hash_entry *hash_wall;	/* point just after last (usable) entry */
  /* here we have some statistics */
  int hash_stat[STATLENGTH];	/* lies & statistics */
a73 2

/*------------------ plan ---------------------------------- i = internal
d75 1
a75 47
  struct hash_control * c;
  struct hash_entry   * e;                                                    i
  int                   b[z];     buffer for statistics
  z         size of b
  char                * s;        symbol string (address) [ key ]
  char                * v;        value string (address)  [datum]
  boolean               f;        TRUE if we found s in hash table            i
  char                * t;        error string; 0 means OK
  int                   a;        access type [0...n)                         i

  c=hash_new       ()             create new hash_control

  hash_die         (c)            destroy hash_control (and hash table)
  table should be empty.
  doesn't check if table is empty.
  c has no meaning after this.

  hash_say         (c,b,z)        report statistics of hash_control.
  also report number of available statistics.

  v=hash_delete    (c,s)          delete symbol, return old value if any.
  ask()                       NULL means no old value.
  f

  v=hash_replace   (c,s,v)        replace old value of s with v.
  ask()                       NULL means no old value: no table change.
  f

  t=hash_insert    (c,s,v)        insert (s,v) in c.
  ask()                       return error string.
  f                           it is an error to insert if s is already
  in table.
  if any error, c is unchanged.

  t=hash_jam       (c,s,v)        assert that new value of s will be v.       i
  ask()                       it may decide to GROW the table.            i
  f                                                                       i
  grow()                                                                  i
  t=hash_grow      (c)            grow the hash table.                        i
  jam()                       will invoke JAM.                            i

  ?=hash_apply     (c,y)          apply y() to every symbol in c.
  y                           evtries visited in 'unspecified' order.

  v=hash_find      (c,s)          return value of s, or NULL if s not in c.
  ask()
  f
a76 21
  f,e=hash_ask()   (c,s,a)        return slot where s SHOULD live.            i
  code()                      maintain collision stats in c.              i

  .=hash_code      (c,s)          compute hash-code for s,                    i
  from parameters of c.                       i

  */

/* Returned by hash_ask() to stop extra testing. hash_ask() wants to
   return both a slot and a status. This is the status.  TRUE: found
   symbol FALSE: absent: empty or deleted slot Also returned by
   hash_jam().  TRUE: we replaced a value FALSE: we inserted a value.  */
static char hash_found;

static struct hash_entry *hash_ask PARAMS ((struct hash_control *,
					    const char *, int));
static int hash_code PARAMS ((struct hash_control *, const char *));
static const char *hash_grow PARAMS ((struct hash_control *));

/* Create a new hash table.  Return NULL if failed; otherwise return handle
   (address of struct hash).  */
d80 23
a102 27
  struct hash_control *retval;
  struct hash_entry *room;	/* points to hash table */
  struct hash_entry *wall;
  struct hash_entry *entry;
  int *ip;		/* scan stats block of struct hash_control */
  int *nd;		/* limit of stats block */

  room = (struct hash_entry *) xmalloc (sizeof (struct hash_entry)
					/* +1 for the wall entry */
					* ((1 << START_POWER) + 1));
  retval = (struct hash_control *) xmalloc (sizeof (struct hash_control));

  nd = retval->hash_stat + STATLENGTH;
  for (ip = retval->hash_stat; ip < nd; ip++)
    *ip = 0;

  retval->hash_stat[STAT_SIZE] = 1 << START_POWER;
  retval->hash_mask = (1 << START_POWER) - 1;
  retval->hash_sizelog = START_POWER;
  /* works for 1's compl ok */
  retval->hash_where = room;
  retval->hash_wall =
    wall = room + (1 << START_POWER);
  retval->hash_full = FULL_VALUE (1 << START_POWER);
  for (entry = room; entry <= wall; entry++)
    entry->hash_string = NULL;
  return retval;
d105 2
a106 10
/*
 *           h a s h _ d i e ( )
 *
 * Table should be empty, but this is not checked.
 * To empty the table, try hash_apply()ing a symbol deleter.
 * Return to free memory both the hash table and it's control
 * block.
 * 'handle' has no meaning after this function.
 * No errors are recoverable.
 */
d108 2
a109 2
hash_die (handle)
     struct hash_control *handle;
d111 2
a112 2
  free ((char *) handle->hash_where);
  free ((char *) handle);
a113 23

#ifdef TEST
/*
 *           h a s h _ s a y ( )
 *
 * Return the size of the statistics table, and as many statistics as
 * we can until either (a) we have run out of statistics or (b) caller
 * has run out of buffer.
 * NOTE: hash_say treats all statistics alike.
 * These numbers may change with time, due to insertions, deletions
 * and expansions of the table.
 * The first "statistic" returned is the length of hash_stat[].
 * Then contents of hash_stat[] are read out (in ascending order)
 * until your buffer or hash_stat[] is exausted.
 */
static void
hash_say (handle, buffer, bufsiz)
     struct hash_control *handle;
     int buffer[ /*bufsiz*/ ];
     int bufsiz;
{
  int *nd;		/* limit of statistics block */
  int *ip;		/* scan statistics */
d115 38
a152 3
  ip = handle->hash_stat;
  nd = ip + min (bufsiz - 1, STATLENGTH);
  if (bufsiz > 0)		/* trust nothing! bufsiz<=0 is dangerous */
d154 3
a156 5
      *buffer++ = STATLENGTH;
      for (; ip < nd; ip++, buffer++)
	{
	  *buffer = *ip;
	}
d158 17
a174 1
}
a175 18

/*
 *           h a s h _ d e l e t e ( )
 *
 * Try to delete a symbol from the table.
 * If it was there, return its value (and adjust STAT_USED).
 * Otherwise, return NULL.
 * Anyway, the symbol is not present after this function.
 *
 */
PTR				/* NULL if string not in table, else */
/* returns value of deleted symbol */
hash_delete (handle, string)
     struct hash_control *handle;
     const char *string;
{
  PTR retval;
  struct hash_entry *entry;
d177 1
a177 8
  entry = hash_ask (handle, string, STAT__WRITE);
  if (hash_found)
    {
      retval = entry->hash_value;
      entry->hash_string = DELETED;
      handle->hash_stat[STAT_USED] -= 1;
#ifdef SUSPECT
      if (handle->hash_stat[STAT_USED] < 0)
d179 15
a193 1
	  error ("hash_delete");
d195 2
a196 1
#endif /* def SUSPECT */
d198 2
a199 5
  else
    {
      retval = NULL;
    }
  return (retval);
d201 10
a210 13

/*
 *                   h a s h _ r e p l a c e ( )
 *
 * Try to replace the old value of a symbol with a new value.
 * Normally return the old value.
 * Return NULL and don't change the table if the symbol is not already
 * in the table.
 */
PTR
hash_replace (handle, string, value)
     struct hash_control *handle;
     const char *string;
d213 19
a231 2
  struct hash_entry *entry;
  char *retval;
d233 1
a233 12
  entry = hash_ask (handle, string, STAT__WRITE);
  if (hash_found)
    {
      retval = entry->hash_value;
      entry->hash_value = value;
    }
  else
    {
      retval = NULL;
    }
  ;
  return retval;
d235 9
a243 13

/*
 *                   h a s h _ i n s e r t ( )
 *
 * Insert a (symbol-string, value) into the hash table.
 * Return an error string, 0 means OK.
 * It is an 'error' to insert an existing symbol.
 */

const char *			/* return error string */
hash_insert (handle, string, value)
     struct hash_control *handle;
     const char *string;
d246 3
a248 2
  struct hash_entry *entry;
  const char *retval;
d250 2
a251 2
  retval = 0;
  if (handle->hash_stat[STAT_USED] > handle->hash_full)
d253 5
a257 1
      retval = hash_grow (handle);
d259 1
a259 1
  if (!retval)
d261 11
a271 11
      entry = hash_ask (handle, string, STAT__WRITE);
      if (hash_found)
	{
	  retval = "exists";
	}
      else
	{
	  entry->hash_value = value;
	  entry->hash_string = string;
	  handle->hash_stat[STAT_USED] += 1;
	}
d273 2
a274 1
  return retval;
d276 9
a284 19

/*
 *               h a s h _ j a m ( )
 *
 * Regardless of what was in the symbol table before, after hash_jam()
 * the named symbol has the given value. The symbol is either inserted or
 * (its value is) replaced.
 * An error message string is returned, 0 means OK.
 *
 * WARNING: this may decide to grow the hashed symbol table.
 * To do this, we call hash_grow(), WHICH WILL recursively CALL US.
 *
 * We report status internally: hash_found is TRUE if we replaced, but
 * false if we inserted.
 */
const char *
hash_jam (handle, string, value)
     struct hash_control *handle;
     const char *string;
d287 2
a288 2
  const char *retval;
  struct hash_entry *entry;
d290 3
a292 17
  retval = 0;
  if (handle->hash_stat[STAT_USED] > handle->hash_full)
    {
      retval = hash_grow (handle);
    }
  if (!retval)
    {
      entry = hash_ask (handle, string, STAT__WRITE);
      if (!hash_found)
	{
	  entry->hash_string = string;
	  handle->hash_stat[STAT_USED] += 1;
	}
      entry->hash_value = value;
    }
  return retval;
}
d294 2
a295 27
/*
 *               h a s h _ g r o w ( )
 *
 * Grow a new (bigger) hash table from the old one.
 * We choose to double the hash table's size.
 * Return a human-scrutible error string: 0 if OK.
 * Warning! This uses hash_jam(), which had better not recurse
 * back here! Hash_jam() conditionally calls us, but we ALWAYS
 * call hash_jam()!
 * Internal.
 */
static const char *
hash_grow (handle)		/* make a hash table grow */
     struct hash_control *handle;
{
  struct hash_entry *newwall;
  struct hash_entry *newwhere;
  struct hash_entry *newtrack;
  struct hash_entry *oldtrack;
  struct hash_entry *oldwhere;
  struct hash_entry *oldwall;
  int temp;
  int newsize;
  const char *string;
  const char *retval;
#ifdef SUSPECT
  int oldused;
d298 1
a298 45
  /*
   * capture info about old hash table
   */
  oldwhere = handle->hash_where;
  oldwall = handle->hash_wall;
#ifdef SUSPECT
  oldused = handle->hash_stat[STAT_USED];
#endif
  /*
   * attempt to get enough room for a hash table twice as big
   */
  temp = handle->hash_stat[STAT_SIZE];
  newwhere = ((struct hash_entry *)
	      xmalloc ((unsigned long) ((temp << (GROW_FACTOR + 1))
					/* +1 for wall slot */
					* sizeof (struct hash_entry))));
  if (newwhere == NULL)
    return "no_room";

  /*
   * have enough room: now we do all the work.
   * double the size of everything in handle.
   */
  handle->hash_mask = ((handle->hash_mask + 1) << GROW_FACTOR) - 1;
  handle->hash_stat[STAT_SIZE] <<= GROW_FACTOR;
  newsize = handle->hash_stat[STAT_SIZE];
  handle->hash_where = newwhere;
  handle->hash_full <<= GROW_FACTOR;
  handle->hash_sizelog += GROW_FACTOR;
  handle->hash_wall = newwall = newwhere + newsize;
  /* Set all those pesky new slots to vacant.  */
  for (newtrack = newwhere; newtrack <= newwall; newtrack++)
    newtrack->hash_string = NULL;
  /* We will do a scan of the old table, the hard way, using the
   * new control block to re-insert the data into new hash table.  */
  handle->hash_stat[STAT_USED] = 0;
  for (oldtrack = oldwhere; oldtrack < oldwall; oldtrack++)
    if (((string = oldtrack->hash_string) != NULL) && string != DELETED)
      if ((retval = hash_jam (handle, string, oldtrack->hash_value)))
	return retval;

#ifdef SUSPECT
  if (handle->hash_stat[STAT_USED] != oldused)
    return "hash_used";
#endif
d300 1
a300 3
  /* We have a completely faked up control block.
     Return the old hash table.  */
  free ((char *) oldwhere);
d302 1
a302 1
  return 0;
d304 8
a311 44

#ifdef TEST
/*
 *          h a s h _ a p p l y ( )
 *
 * Use this to scan each entry in symbol table.
 * For each symbol, this calls (applys) a nominated function supplying the
 * symbol's value (and the symbol's name).
 * The idea is you use this to destroy whatever is associted with
 * any values in the table BEFORE you destroy the table with hash_die.
 * Of course, you can use it for other jobs; whenever you need to
 * visit all extant symbols in the table.
 *
 * We choose to have a call-you-back idea for two reasons:
 *  asthetic: it is a neater idea to use apply than an explicit loop
 *  sensible: if we ever had to grow the symbol table (due to insertions)
 *            then we would lose our place in the table when we re-hashed
 *            symbols into the new table in a different order.
 *
 * The order symbols are visited depends entirely on the hashing function.
 * Whenever you insert a (symbol, value) you risk expanding the table. If
 * you do expand the table, then the hashing function WILL change, so you
 * MIGHT get a different order of symbols visited. In other words, if you
 * want the same order of visiting symbols as the last time you used
 * hash_apply() then you better not have done any hash_insert()s or
 * hash_jam()s since the last time you used hash_apply().
 *
 * In future we may use the value returned by your nominated function.
 * One idea is to abort the scan if, after applying the function to a
 * certain node, the function returns a certain code.
 *
 * The function you supply should be of the form:
 *      void myfunct(string,value)
 *              char * string;        |* the symbol's name *|
 *              char * value;         |* the symbol's value *|
 *      {
 *        |* ... *|
 *      }
 *
 */
void
hash_apply (handle, function)
     struct hash_control *handle;
     void (*function) ();
d313 5
a317 2
  struct hash_entry *entry;
  struct hash_entry *wall;
d319 1
a319 8
  wall = handle->hash_wall;
  for (entry = handle->hash_where; entry < wall; entry++)
    {
      if (islive (entry))	/* silly code: tests entry->string twice! */
	{
	  (*function) (entry->hash_string, entry->hash_value);
	}
    }
d321 4
a324 8
#endif

/*
 *          h a s h _ f i n d ( )
 *
 * Given symbol string, find value (if any).
 * Return found value or NULL.
 */
d326 3
a328 3
hash_find (handle, string)
     struct hash_control *handle;
     const char *string;
d330 2
a331 1
  struct hash_entry *entry;
d333 2
a334 4
  entry = hash_ask (handle, string, STAT__READ);
  if (hash_found)
    return entry->hash_value;
  else
a335 111
}

/*
 *          h a s h _ a s k ( )
 *
 * Searches for given symbol string.
 * Return the slot where it OUGHT to live. It may be there.
 * Return hash_found: TRUE only if symbol is in that slot.
 * Access argument is to help keep statistics in control block.
 * Internal.
 */
static struct hash_entry *	/* string slot, may be empty or deleted */
hash_ask (handle, string, access_type)
     struct hash_control *handle;
     const char *string;
     int access_type;
{
  const char *s;
  struct hash_entry *slot;
  int collision;	/* count collisions */
  int strcmps;
  int hcode;

  /* start looking here */
  hcode = hash_code (handle, string);
  slot = handle->hash_where + (hcode & handle->hash_mask);

  handle->hash_stat[STAT_ACCESS + access_type] += 1;
  collision = strcmps = 0;
  hash_found = FALSE;
  while (((s = slot->hash_string) != NULL) && s != DELETED)
    {
      if (string == s)
	{
	  hash_found = TRUE;
	  break;
	}
      if (slot->h == hcode)
	{
	  if (!strcmp (string, s))
	    {
	      hash_found = TRUE;
	      break;
	    }
	  strcmps++;
	}
      collision++;
      slot++;
    }
  /*
   * slot:                                                      return:
   *       in use:     we found string                           slot
   *       at empty:
   *                   at wall:        we fell off: wrap round   ????
   *                   in table:       dig here                  slot
   *       at DELETED: dig here                                  slot
   */
  if (slot == handle->hash_wall)
    {
      slot = handle->hash_where;/* now look again */
      while (((s = slot->hash_string) != NULL) && s != DELETED)
	{
	  if (string == s)
	    {
	      hash_found = TRUE;
	      break;
	    }
	  if (slot->h == hcode)
	    {
	      if (!strcmp (string, s))
		{
		  hash_found = TRUE;
		  break;
		}
	      strcmps++;
	    }
	  collision++;
	  slot++;
	}
      /*
       * slot:                                                   return:
       *       in use: we found it                                slot
       *       empty:  wall:         ERROR IMPOSSIBLE             !!!!
       *               in table:     dig here                     slot
       *       DELETED:dig here                                   slot
       */
    }
  handle->hash_stat[STAT_COLLIDE + access_type] += collision;
  handle->hash_stat[STAT_STRCMP + access_type] += strcmps;
  if (!hash_found)
    slot->h = hcode;
  return slot;			/* also return hash_found */
}

/*
 *           h a s h _ c o d e
 *
 * Does hashing of symbol string to hash number.
 * Internal.
 */
static int
hash_code (handle, string)
     struct hash_control *handle;
     const char *string;
{
#if 1 /* There seems to be some interesting property of this function
	 that prevents the bfd version below from being an adequate
	 substitute.  @@@@ Figure out what this property is!  */
  long h;		/* hash code built here */
  long c;		/* each character lands here */
  int n;		/* Amount to shift h by */
d337 2
a338 13
  n = (handle->hash_sizelog - 3);
  h = 0;
  while ((c = *string++) != 0)
    {
      h += c;
      h = (h << 3) + (h >> n) + c;
    }
  return h;
#else
  /* from bfd */
  unsigned long h = 0;
  unsigned int len = 0;
  unsigned int c;
d340 2
a341 9
  while ((c = *string++) != 0)
    {
      h += c + (c << 17);
      h ^= h >> 2;
      ++len;
    }
  h += len + (len << 17);
  h ^= h >> 2;
  return h;
d343 8
d352 4
a355 1

d357 3
a359 4
hash_print_statistics (file, name, h)
     FILE *file;
     const char *name;
     struct hash_control *h;
d361 1
a361 1
  unsigned long sz, used, pct;
d363 3
a365 2
  if (h == 0)
    return;
d367 4
a370 3
  sz = h->hash_stat[STAT_SIZE];
  used = h->hash_stat[STAT_USED];
  pct = (used * 100 + sz / 2) / sz;
d372 2
a373 2
  fprintf (file, "%s hash statistics:\n\t%lu/%lu slots used (%lu%%)\n",
	   name, used, sz, pct);
d375 24
a398 5
#define P(name, off)							\
  fprintf (file, "\t%-16s %6dr + %6dw = %7d\n", name,			\
	   h->hash_stat[off+STAT__READ],				\
	   h->hash_stat[off+STAT__WRITE],				\
	   h->hash_stat[off+STAT__READ] + h->hash_stat[off+STAT__WRITE])
d400 8
a407 3
  P ("accesses:", STAT_ACCESS);
  P ("collisions:", STAT_COLLIDE);
  P ("string compares:", STAT_STRCMP);
d409 3
a411 1
#undef P
a413 3
/*
 * Here is a test program to exercise above.
 */
d416 2
d419 1
a419 1
/* (at once) in any testing */
d434 1
a434 1
/* symbol table */
d436 1
d468 1
a468 1
	  hash_apply (h, applicatee);
d471 1
a471 1
	  hash_apply (h, destroy);
d573 1
d575 1
a575 1
     /* also determine h: points to hash_control */
a597 2


@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 2
a3 1
   Copyright (C) 1987, 1990, 1991, 1992 Free Software Foundation, Inc.
d555 1
a555 1
	      xmalloc ((unsigned long) ((temp << GROW_FACTOR + 1)
d824 1
a824 1
  fprintf (file, "%s hash statistics:\n\t%d/%d slots used (%d%%)\n",
@


1.1
log
@Initial revision
@
text
@d139 3
a141 2
#define DELETED     ((PTR)1)	/* guarenteed invalid address */
#define START_POWER    (11)	/* power of two: size of new hash table */
d146 19
a164 4
/* Number of slots in hash table.  The wall does not count here.
   We expect this is always a power of 2.  */
#define STAT_SIZE      (0)
#define STAT_ACCESS    (1)	/* number of hash_ask()s */
d167 5
a171 8
/* Number of collisions (total).  This may exceed STAT_ACCESS if we
   have lots of collisions/access.  */
#define STAT_COLLIDE   (3)
#define STAT_USED      (5)	/* slots used right now */
#define STATLENGTH     (6)	/* size of statistics block */
#if STATLENGTH != HASH_STATLENGTH
Panic! Please make #include "stat.h" agree with previous definitions!
#endif
d186 20
d303 1
a303 1
  retval->hash_full = (1 << START_POWER) / 2;
d327 1
d341 1
a341 1
void
d361 1
d476 1
a476 1
 * (its value is) relpaced.
d553 28
a580 37
  if ((newwhere = ((struct hash_entry *)
		   xmalloc ((unsigned long) ((temp + temp + 1)
					     * sizeof (struct hash_entry)))))
      != NULL)
    /* +1 for wall slot */
    {
      retval = 0;		/* assume success until proven otherwise */
      /*
       * have enough room: now we do all the work.
       * double the size of everything in handle,
       * note: hash_mask frob works for 1's & for 2's complement machines
       */
      handle->hash_mask = handle->hash_mask + handle->hash_mask + 1;
      handle->hash_stat[STAT_SIZE] <<= 1;
      newsize = handle->hash_stat[STAT_SIZE];
      handle->hash_where = newwhere;
      handle->hash_full <<= 1;
      handle->hash_sizelog += 1;
      handle->hash_stat[STAT_USED] = 0;
      handle->hash_wall =
	newwall = newwhere + newsize;
      /*
       * set all those pesky new slots to vacant.
       */
      for (newtrack = newwhere; newtrack <= newwall; newtrack++)
	{
	  newtrack->hash_string = NULL;
	}
      /*
       * we will do a scan of the old table, the hard way, using the
       * new control block to re-insert the data into new hash table.
       */
      handle->hash_stat[STAT_USED] = 0;	/* inserts will bump it up to correct */
      for (oldtrack = oldwhere; oldtrack < oldwall; oldtrack++)
	if (((string = oldtrack->hash_string) != NULL) && string != DELETED)
	  if ((retval = hash_jam (handle, string, oldtrack->hash_value)))
	    break;
d583 2
a584 4
      if (!retval && handle->hash_stat[STAT_USED] != oldused)
	{
	  retval = "hash_used";
	}
d586 6
a591 17
      if (!retval)
	{
	  /*
	   * we have a completely faked up control block.
	   * return the old hash table.
	   */
	  free ((char *) oldwhere);
	  /*
	   * Here with success. retval is already 0.
	   */
	}
    }
  else
    {
      retval = "no room";
    }
  return retval;
d594 1
a622 4
 * To be safe, please make your functions of type char *. If you always
 * return NULL, then the scan will complete, visiting every symbol in
 * the table exactly once. ALL OTHER RETURNED VALUES have no meaning yet!
 * Caveat Actor!
d625 1
a625 1
 *      char * myfunct(string,value)
a629 1
 *        return(NULL);
a631 3
 * The returned value of hash_apply() is (char*)NULL. In future it may return
 * other values. NULL means "completed scan OK". Other values have no meaning
 * yet. (The function has no graceful failures.)
d633 1
a633 1
char *
d636 1
a636 1
     char *(*function) ();
a648 1
  return (NULL);
d650 1
d690 2
d694 2
a695 1
  slot = handle->hash_where + hash_code (handle, string);
d698 1
a698 1
  collision = 0;
d702 14
a715 4
      if (string == s || !strcmp (string, s))
	hash_found = TRUE;
      if (hash_found)
	break;
d732 1
a732 1
	  if (string == s || !strcmp (string, s))
d737 9
d758 4
a761 1
  return (slot);		/* also return hash_found */
d789 1
a789 1
  return (h & handle->hash_mask);
d804 1
a804 1
  return h & handle->hash_mask;
d808 31
d864 2
a865 2
  char (*applicatee ());
  char *destroy ();
d980 1
a980 1
char *
a986 1
  return (NULL);
d990 1
a990 1
char *
a995 1
  return (NULL);
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d139 2
a140 3
static char _deleted_[1];
#define DELETED     ((PTR)_deleted_)	/* guarenteed unique address */
#define START_POWER    (10)	/* power of two: size of new hash table */
d145 4
a148 19
enum stat_enum {
  /* Number of slots in hash table.  The wall does not count here.
     We expect this is always a power of 2.  */
  STAT_SIZE = 0,
  /* Number of hash_ask calls.  */
  STAT_ACCESS,
  STAT_ACCESS_w,
  /* Number of collisions (total).  This may exceed STAT_ACCESS if we
     have lots of collisions/access.  */
  STAT_COLLIDE,
  STAT_COLLIDE_w,
  /* Slots used right now.  */
  STAT_USED,
  /* How many string compares?  */
  STAT_STRCMP,
  STAT_STRCMP_w,
  /* Size of statistics block... this must be last.  */
  STATLENGTH
};
d151 8
a158 5

/* When we grow a hash table, by what power of two do we increase it?  */
#define GROW_FACTOR 1
/* When should we grow it?  */
#define FULL_VALUE(N)	((N) / 2)
a172 20
struct hash_entry
{
  const char *hash_string;	/* points to where the symbol string is */
  /* NULL means slot is not used */
  /* DELETED means slot was deleted */
  PTR hash_value;		/* user's datum, associated with symbol */
  unsigned long h;
};

struct hash_control {
  struct hash_entry *hash_where;/* address of hash table */
  int hash_sizelog;		/* Log of ( hash_mask + 1 ) */
  int hash_mask;		/* masks a hash into index into table */
  int hash_full;		/* when hash_stat[STAT_USED] exceeds this, */
  /* grow table */
  struct hash_entry *hash_wall;	/* point just after last (usable) entry */
  /* here we have some statistics */
  int hash_stat[STATLENGTH];	/* lies & statistics */
};

d270 1
a270 1
  retval->hash_full = FULL_VALUE (1 << START_POWER);
a293 1
#ifdef TEST
d307 1
a307 1
static void
a326 1
#endif
d441 1
a441 1
 * (its value is) replaced.
d518 37
a554 28
  newwhere = ((struct hash_entry *)
	      xmalloc ((unsigned long) ((temp << GROW_FACTOR + 1)
					/* +1 for wall slot */
					* sizeof (struct hash_entry))));
  if (newwhere == NULL)
    return "no_room";

  /*
   * have enough room: now we do all the work.
   * double the size of everything in handle.
   */
  handle->hash_mask = ((handle->hash_mask + 1) << GROW_FACTOR) - 1;
  handle->hash_stat[STAT_SIZE] <<= GROW_FACTOR;
  newsize = handle->hash_stat[STAT_SIZE];
  handle->hash_where = newwhere;
  handle->hash_full <<= GROW_FACTOR;
  handle->hash_sizelog += GROW_FACTOR;
  handle->hash_wall = newwall = newwhere + newsize;
  /* Set all those pesky new slots to vacant.  */
  for (newtrack = newwhere; newtrack <= newwall; newtrack++)
    newtrack->hash_string = NULL;
  /* We will do a scan of the old table, the hard way, using the
   * new control block to re-insert the data into new hash table.  */
  handle->hash_stat[STAT_USED] = 0;
  for (oldtrack = oldwhere; oldtrack < oldwall; oldtrack++)
    if (((string = oldtrack->hash_string) != NULL) && string != DELETED)
      if ((retval = hash_jam (handle, string, oldtrack->hash_value)))
	return retval;
d557 4
a560 2
  if (handle->hash_stat[STAT_USED] != oldused)
    return "hash_used";
d562 17
a578 6

  /* We have a completely faked up control block.
     Return the old hash table.  */
  free ((char *) oldwhere);

  return 0;
a580 1
#ifdef TEST
d609 4
d615 1
a615 1
 *      void myfunct(string,value)
d620 1
d623 3
d627 1
a627 1
void
d630 1
a630 1
     void (*function) ();
d643 1
a644 1
#endif
a683 2
  int strcmps;
  int hcode;
d686 1
a686 2
  hcode = hash_code (handle, string);
  slot = handle->hash_where + (hcode & handle->hash_mask);
d689 1
a689 1
  collision = strcmps = 0;
d693 4
a696 14
      if (string == s)
	{
	  hash_found = TRUE;
	  break;
	}
      if (slot->h == hcode)
	{
	  if (!strcmp (string, s))
	    {
	      hash_found = TRUE;
	      break;
	    }
	  strcmps++;
	}
d713 1
a713 1
	  if (string == s)
a717 9
	  if (slot->h == hcode)
	    {
	      if (!strcmp (string, s))
		{
		  hash_found = TRUE;
		  break;
		}
	      strcmps++;
	    }
d730 1
a730 4
  handle->hash_stat[STAT_STRCMP + access_type] += strcmps;
  if (!hash_found)
    slot->h = hcode;
  return slot;			/* also return hash_found */
d758 1
a758 1
  return h;
d773 1
a773 1
  return h;
a776 31
void
hash_print_statistics (file, name, h)
     FILE *file;
     const char *name;
     struct hash_control *h;
{
  unsigned long sz, used, pct;

  if (h == 0)
    return;

  sz = h->hash_stat[STAT_SIZE];
  used = h->hash_stat[STAT_USED];
  pct = (used * 100 + sz / 2) / sz;

  fprintf (file, "%s hash statistics:\n\t%d/%d slots used (%d%%)\n",
	   name, used, sz, pct);

#define P(name, off)							\
  fprintf (file, "\t%-16s %6dr + %6dw = %7d\n", name,			\
	   h->hash_stat[off+STAT__READ],				\
	   h->hash_stat[off+STAT__WRITE],				\
	   h->hash_stat[off+STAT__READ] + h->hash_stat[off+STAT__WRITE])

  P ("accesses:", STAT_ACCESS);
  P ("collisions:", STAT_COLLIDE);
  P ("string compares:", STAT_STRCMP);

#undef P
}

d802 2
a803 2
  void applicatee ();
  void destroy ();
d918 1
a918 1
void
d925 1
d929 1
a929 1
void
d935 1
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d2 1
a2 2
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996
   Free Software Foundation, Inc.
d554 1
a554 1
	      xmalloc ((unsigned long) ((temp << (GROW_FACTOR + 1))
d823 1
a823 1
  fprintf (file, "%s hash statistics:\n\t%lu/%lu slots used (%lu%%)\n",
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d1 2
a2 2
/* hash.c -- gas hash table code
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 98, 1999
d18 117
a134 12
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* This version of the hash table code is a wholescale replacement of
   the old hash table code, which was fairly bad.  This is based on
   the hash table code in BFD, but optimized slightly for the
   asssembler.  The assembler does not need to derive structures that
   are stored in the hash table.  Instead, it always stores a pointer.
   The assembler uses the hash table mostly to store symbols, and we
   don't need to confuse the symbol structure with a hash table
   structure.  */
a136 1
#include "obstack.h"
d138 1
a138 1
/* The default number of entries to use when creating a hash table.  */
d140 28
a167 1
#define DEFAULT_SIZE (4051)
d169 4
a172 1
/* An entry in a hash table.  */
d174 13
d189 16
a204 9
  /* Next entry for this hash code.  */
  struct hash_entry *next;
  /* String being hashed.  */
  const char *string;
  /* Hash code.  This is the full hash code, not the index into the
     table.  */
  unsigned long hash;
  /* Pointer being stored in the hash table.  */
  PTR data;
d206 2
d209 47
a255 1
/* A hash table.  */
d257 2
a258 19
struct hash_control
{
  /* The hash array.  */
  struct hash_entry **table;
  /* The number of slots in the hash table.  */
  unsigned int size;
  /* An obstack for this hash table.  */
  struct obstack memory;

#ifdef HASH_STATISTICS
  /* Statistics.  */
  unsigned long lookups;
  unsigned long hash_compares;
  unsigned long string_compares;
  unsigned long insertions;
  unsigned long replacements;
  unsigned long deletions;
#endif /* HASH_STATISTICS */
};
d260 2
a261 1
/* Create a hash table.  This return a control block.  */
d263 15
d281 27
a307 23
  unsigned int size;
  struct hash_control *ret;
  unsigned int alloc;

  size = DEFAULT_SIZE;

  ret = (struct hash_control *) xmalloc (sizeof *ret);
  obstack_begin (&ret->memory, chunksize);
  alloc = size * sizeof (struct hash_entry *);
  ret->table = (struct hash_entry **) obstack_alloc (&ret->memory, alloc);
  memset (ret->table, 0, alloc);
  ret->size = size;

#ifdef HASH_STATISTICS
  ret->lookups = 0;
  ret->hash_compares = 0;
  ret->string_compares = 0;
  ret->insertions = 0;
  ret->replacements = 0;
  ret->deletions = 0;
#endif

  return ret;  
d310 10
a319 2
/* Delete a hash table, freeing all allocated memory.  */

d321 2
a322 2
hash_die (table)
     struct hash_control *table;
d324 2
a325 2
  obstack_free (&table->memory, 0);
  free (table);
d327 23
d351 3
a353 38
/* Look up a string in a hash table.  This returns a pointer to the
   hash_entry, or NULL if the string is not in the table.  If PLIST is
   not NULL, this sets *PLIST to point to the start of the list which
   would hold this hash entry.  If PHASH is not NULL, this sets *PHASH
   to the hash code for KEY.

   Each time we look up a string, we move it to the start of the list
   for its hash code, to take advantage of referential locality.  */

static struct hash_entry *hash_lookup PARAMS ((struct hash_control *,
					       const char *,
					       struct hash_entry ***,
					       unsigned long *));

static struct hash_entry *
hash_lookup (table, key, plist, phash)
     struct hash_control *table;
     const char *key;
     struct hash_entry ***plist;
     unsigned long *phash;
{
  register unsigned long hash;
  unsigned int len;
  register const unsigned char *s;
  register unsigned int c;
  unsigned int index;
  struct hash_entry **list;
  struct hash_entry *p;
  struct hash_entry *prev;

#ifdef HASH_STATISTICS
  ++table->lookups;
#endif

  hash = 0;
  len = 0;
  s = (const unsigned char *) key;
  while ((c = *s++) != '\0')
d355 5
a359 3
      hash += c + (c << 17);
      hash ^= hash >> 2;
      ++len;
d361 20
a380 8
  hash += len + (len << 17);
  hash ^= hash >> 2;

  if (phash != NULL)
    *phash = hash;

  index = hash % table->size;
  list = table->table + index;
d382 2
a383 5
  if (plist != NULL)
    *plist = list;

  prev = NULL;
  for (p = *list; p != NULL; p = p->next)
d385 5
a389 5
#ifdef HASH_STATISTICS
      ++table->hash_compares;
#endif

      if (p->hash == hash)
d391 1
a391 15
#ifdef HASH_STATISTICS
	  ++table->string_compares;
#endif

	  if (strcmp (p->string, key) == 0)
	    {
	      if (prev != NULL)
		{
		  prev->next = p->next;
		  p->next = *list;
		  *list = p;
		}

	      return p;
	    }
d393 25
d419 9
a427 1
      prev = p;
d429 2
a430 2

  return NULL;
d432 13
a444 10

/* Insert an entry into a hash table.  This returns NULL on success.
   On error, it returns a printable string indicating the error.  It
   is considered to be an error if the entry already exists in the
   hash table.  */

const char *
hash_insert (table, key, value)
     struct hash_control *table;
     const char *key;
d447 2
a448 7
  struct hash_entry *p;
  struct hash_entry **list;
  unsigned long hash;

  p = hash_lookup (table, key, &list, &hash);
  if (p != NULL)
    return "exists";
d450 20
a469 13
#ifdef HASH_STATISTICS
  ++table->insertions;
#endif

  p = obstack_alloc (&table->memory, sizeof *p);
  p->string = key;
  p->hash = hash;
  p->data = value;

  p->next = *list;
  *list = p;

  return NULL;
d471 15
a485 5

/* Insert or replace an entry in a hash table.  This returns NULL on
   success.  On error, it returns a printable string indicating the
   error.  If an entry already exists, its value is replaced.  */

d487 3
a489 3
hash_jam (table, key, value)
     struct hash_control *table;
     const char *key;
d492 2
a493 3
  struct hash_entry *p;
  struct hash_entry **list;
  unsigned long hash;
d495 2
a496 2
  p = hash_lookup (table, key, &list, &hash);
  if (p != NULL)
d498 1
a498 5
#ifdef HASH_STATISTICS
      ++table->replacements;
#endif

      p->data = value;
d500 1
a500 1
  else
d502 7
a508 11
#ifdef HASH_STATISTICS
      ++table->insertions;
#endif

      p = obstack_alloc (&table->memory, sizeof *p);
      p->string = key;
      p->hash = hash;
      p->data = value;

      p->next = *list;
      *list = p;
d510 1
a510 2

  return NULL;
d513 14
a526 9
/* Replace an existing entry in a hash table.  This returns the old
   value stored for the entry.  If the entry is not found in the hash
   table, this does nothing and returns NULL.  */

PTR
hash_replace (table, key, value)
     struct hash_control *table;
     const char *key;
     PTR value;
d528 13
a540 2
  struct hash_entry *p;
  PTR ret;
d542 44
a585 6
  p = hash_lookup (table, key, NULL, NULL);
  if (p == NULL)
    return NULL;

#ifdef HASH_STATISTICS
  ++table->replacements;
d588 3
a590 1
  ret = p->data;
d592 49
a640 1
  p->data = value;
d642 8
a649 1
  return ret;
d651 8
a658 4

/* Find an entry in a hash table, returning its value.  Returns NULL
   if the entry is not found.  */

d660 3
a662 3
hash_find (table, key)
     struct hash_control *table;
     const char *key;
d664 1
a664 1
  struct hash_entry *p;
d666 4
a669 2
  p = hash_lookup (table, key, NULL, NULL);
  if (p == NULL)
a670 2

  return p->data;
d672 103
a774 8

/* Delete an entry from a hash table.  This returns the value stored
   for that entry, or NULL if there is no such entry.  */

PTR
hash_delete (table, key)
     struct hash_control *table;
     const char *key;
d776 6
a781 2
  struct hash_entry *p;
  struct hash_entry **list;
d783 13
a795 3
  p = hash_lookup (table, key, &list, NULL);
  if (p == NULL)
    return NULL;
d797 9
a805 5
  if (p != *list)
    abort ();

#ifdef HASH_STATISTICS
  ++table->deletions;
a806 8

  *list = p->next;

  /* Note that we never reclaim the memory for this entry.  If gas
     ever starts deleting hash table entries in a big way, this will
     have to change.  */

  return p->data;
d808 1
a808 4

/* Traverse a hash table.  Call the function on every entry in the
   hash table.  */

d810 4
a813 3
hash_traverse (table, pfn)
     struct hash_control *table;
     void (*pfn) PARAMS ((const char *key, PTR value));
d815 1
a815 1
  unsigned int i;
d817 2
a818 3
  for (i = 0; i < table->size; ++i)
    {
      struct hash_entry *p;
d820 3
a822 4
      for (p = table->table[i]; p != NULL; p = p->next)
	(*pfn) (p->string, p->data);
    }
}
d824 2
a825 2
/* Print hash table statistics on the specified file.  NAME is the
   name of the hash table, used for printing a header.  */
d827 5
a831 24
void
hash_print_statistics (f, name, table)
     FILE *f ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     struct hash_control *table ATTRIBUTE_UNUSED;
{
#ifdef HASH_STATISTICS
  unsigned int i;
  unsigned long total;
  unsigned long empty;

  fprintf (f, "%s hash statistics:\n", name);
  fprintf (f, "\t%lu lookups\n", table->lookups);
  fprintf (f, "\t%lu hash comparisons\n", table->hash_compares);
  fprintf (f, "\t%lu string comparisons\n", table->string_compares);
  fprintf (f, "\t%lu insertions\n", table->insertions);
  fprintf (f, "\t%lu replacements\n", table->replacements);
  fprintf (f, "\t%lu deletions\n", table->deletions);

  total = 0;
  empty = 0;
  for (i = 0; i < table->size; ++i)
    {
      struct hash_entry *p;
d833 3
a835 8
      if (table->table[i] == NULL)
	++empty;
      else
	{
	  for (p = table->table[i]; p != NULL; p = p->next)
	    ++total;
	}
    }
d837 1
a837 3
  fprintf (f, "\t%g average chain length\n", (double) total / table->size);
  fprintf (f, "\t%lu empty slots\n", empty);
#endif
d840 3
a844 2
/* This test program is left over from the old hash table code.  */

d846 1
a846 1
				/* (at once) in any testing */
d861 1
a861 1
				/* symbol table */
a862 1
int
d894 1
a894 1
	  hash_traverse (h, applicatee);
d897 1
a897 1
	  hash_traverse (h, destroy);
a998 1
void
d1000 1
a1000 1
			        /* also determine h: points to hash_control */
d1023 2
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000
d40 2
a41 1
struct hash_entry {
d55 2
a56 1
struct hash_control {
d102 1
a102 1
  return ret;
d225 1
a225 1
  p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
d265 1
a265 1
      p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
d418 8
a425 17
/* Number of hash tables to maintain (at once) in any testing.  */
#define TABLES (6)

/* We can have 12 statistics.  */
#define STATBUFSIZE (12)

/* Display statistics here.  */
int statbuf[STATBUFSIZE];

/* Human farts here.  */
char answer[100];

/* We test many hash tables at once.  */
char *hashtable[TABLES];

/* Points to curent hash_control.  */
char *h;
d433 2
a434 3

/* Number 0:TABLES-1 of current hashed symbol table.  */
int number;
d453 1
a453 1
	command = tolower (command);	/* Ecch!  */
d463 2
a464 2
	      printf ("address of hash table #%d control block is %xx\n",
		      pp - hashtable, *pp);
d545 1
a545 1
  /* Will one day clean up answer here.  */
d564 1
a572 3
/* Determine number: what hash table to use.
   Also determine h: points to hash_control.  */

d574 2
a575 1
whattable ()
d577 1
d599 3
a601 1
#endif /* TEST */
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2000, 2001, 2002
a32 1
#include "safe-ctype.h"
d461 2
a462 1
      command = TOLOWER (command);	/* Ecch!  */
d549 3
d554 8
a561 1
  return xstrdup (answer);
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d26 1
a26 1
   assembler.  The assembler does not need to derive structures that
d78 1
a78 1
hash_new (void)
d108 2
a109 1
hash_die (struct hash_control *table)
d124 4
a127 4
static struct hash_entry *hash_lookup (struct hash_control *,
				       const char *,
				       struct hash_entry ***,
				       unsigned long *);
d130 5
a134 2
hash_lookup (struct hash_control *table, const char *key,
	     struct hash_entry ***plist, unsigned long *phash)
d208 4
a211 1
hash_insert (struct hash_control *table, const char *key, PTR value)
d241 4
a244 1
hash_jam (struct hash_control *table, const char *key, PTR value)
d282 4
a285 1
hash_replace (struct hash_control *table, const char *key, PTR value)
d309 3
a311 1
hash_find (struct hash_control *table, const char *key)
d326 3
a328 1
hash_delete (struct hash_control *table, const char *key)
d357 3
a359 2
hash_traverse (struct hash_control *table,
	       void (*pfn) (const char *key, PTR value))
d376 4
a379 3
hash_print_statistics (FILE *f ATTRIBUTE_UNUSED,
		       const char *name ATTRIBUTE_UNUSED,
		       struct hash_control *table ATTRIBUTE_UNUSED)
d433 1
a433 1
/* Points to current hash_control.  */
@


