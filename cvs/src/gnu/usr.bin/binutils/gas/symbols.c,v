head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.50
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.25;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.44;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.29;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.04.59;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.48;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.45;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.45;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.48;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.43.53;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.10;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.22.20;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.15;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.32.35;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.26;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.44;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* symbols.c -symbol table-
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* #define DEBUG_SYMS / * to debug symbol list maintenance.  */

#include "as.h"

#include "safe-ctype.h"
#include "obstack.h"		/* For "symbols.h" */
#include "subsegs.h"

#include "struc-symbol.h"

/* This is non-zero if symbols are case sensitive, which is the
   default.  */
int symbols_case_sensitive = 1;

#ifndef WORKING_DOT_WORD
extern int new_broken_words;
#endif

/* symbol-name => struct symbol pointer */
static struct hash_control *sy_hash;

/* Table of local symbols.  */
static struct hash_control *local_hash;

/* Below are commented in "symbols.h".  */
symbolS *symbol_rootP;
symbolS *symbol_lastP;
symbolS abs_symbol;

#ifdef DEBUG_SYMS
#define debug_verify_symchain verify_symbol_chain
#else
#define debug_verify_symchain(root, last) ((void) 0)
#endif

#define DOLLAR_LABEL_CHAR	'\001'
#define LOCAL_LABEL_CHAR	'\002'

struct obstack notes;

static char *save_symbol_name (const char *);
static void fb_label_init (void);
static long dollar_label_instance (long);
static long fb_label_instance (long);

static void print_binary (FILE *, const char *, expressionS *);
static void report_op_error (symbolS *, symbolS *, symbolS *);

/* Return a pointer to a new symbol.  Die if we can't make a new
   symbol.  Fill in the symbol's values.  Add symbol to end of symbol
   chain.

   This function should be called in the general case of creating a
   symbol.  However, if the output file symbol table has already been
   set, and you are certain that this symbol won't be wanted in the
   output file, you can call symbol_create.  */

symbolS *
symbol_new (const char *name, segT segment, valueT valu, fragS *frag)
{
  symbolS *symbolP = symbol_create (name, segment, valu, frag);

  /* Link to end of symbol chain.  */
#ifdef BFD_ASSEMBLER
  {
    extern int symbol_table_frozen;
    if (symbol_table_frozen)
      abort ();
  }
#endif
  symbol_append (symbolP, symbol_lastP, &symbol_rootP, &symbol_lastP);

  return symbolP;
}

/* Save a symbol name on a permanent obstack, and convert it according
   to the object file format.  */

static char *
save_symbol_name (const char *name)
{
  unsigned int name_length;
  char *ret;

  name_length = strlen (name) + 1;	/* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  ret = obstack_finish (&notes);

#ifdef STRIP_UNDERSCORE
  if (ret[0] == '_')
    ++ret;
#endif

#ifdef tc_canonicalize_symbol_name
  ret = tc_canonicalize_symbol_name (ret);
#endif

  if (! symbols_case_sensitive)
    {
      char *s;

      for (s = ret; *s != '\0'; s++)
	*s = TOUPPER (*s);
    }

  return ret;
}

symbolS *
symbol_create (const char *name, /* It is copied, the caller can destroy/modify.  */
	       segT segment,	/* Segment identifier (SEG_<something>).  */
	       valueT valu,	/* Symbol value.  */
	       fragS *frag	/* Associated fragment.  */)
{
  char *preserved_copy_of_name;
  symbolS *symbolP;

  preserved_copy_of_name = save_symbol_name (name);

  symbolP = (symbolS *) obstack_alloc (&notes, sizeof (symbolS));

  /* symbol must be born in some fixed state.  This seems as good as any.  */
  memset (symbolP, 0, sizeof (symbolS));

#ifdef BFD_ASSEMBLER
  symbolP->bsym = bfd_make_empty_symbol (stdoutput);
  if (symbolP->bsym == NULL)
    as_perror ("%s", "bfd_make_empty_symbol");
  symbolP->bsym->udata.p = (PTR) symbolP;
#endif
  S_SET_NAME (symbolP, preserved_copy_of_name);

  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);

  symbolP->sy_frag = frag;
#ifndef BFD_ASSEMBLER
  symbolP->sy_number = ~0;
  symbolP->sy_name_offset = (unsigned int) ~0;
#endif

  obj_symbol_new_hook (symbolP);

#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif

  return symbolP;
}

#ifdef BFD_ASSEMBLER

/* Local symbol support.  If we can get away with it, we keep only a
   small amount of information for local symbols.  */

static symbolS *local_symbol_convert (struct local_symbol *);

/* Used for statistics.  */

static unsigned long local_symbol_count;
static unsigned long local_symbol_conversion_count;

/* This macro is called with a symbol argument passed by reference.
   It returns whether this is a local symbol.  If necessary, it
   changes its argument to the real symbol.  */

#define LOCAL_SYMBOL_CHECK(s)						\
  (s->bsym == NULL							\
   ? (local_symbol_converted_p ((struct local_symbol *) s)		\
      ? (s = local_symbol_get_real_symbol ((struct local_symbol *) s),	\
	 0)								\
      : 1)								\
   : 0)

/* Create a local symbol and insert it into the local hash table.  */

struct local_symbol *
local_symbol_make (const char *name, segT section, valueT value, fragS *frag)
{
  char *name_copy;
  struct local_symbol *ret;

  ++local_symbol_count;

  name_copy = save_symbol_name (name);

  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);
  ret->lsy_marker = NULL;
  ret->lsy_name = name_copy;
  ret->lsy_section = section;
  local_symbol_set_frag (ret, frag);
  ret->lsy_value = value;

  hash_jam (local_hash, name_copy, (PTR) ret);

  return ret;
}

/* Convert a local symbol into a real symbol.  Note that we do not
   reclaim the space used by the local symbol.  */

static symbolS *
local_symbol_convert (struct local_symbol *locsym)
{
  symbolS *ret;

  assert (locsym->lsy_marker == NULL);
  if (local_symbol_converted_p (locsym))
    return local_symbol_get_real_symbol (locsym);

  ++local_symbol_conversion_count;

  ret = symbol_new (locsym->lsy_name, locsym->lsy_section, locsym->lsy_value,
		    local_symbol_get_frag (locsym));

  if (local_symbol_resolved_p (locsym))
    ret->sy_resolved = 1;

  /* Local symbols are always either defined or used.  */
  ret->sy_used = 1;

#ifdef TC_LOCAL_SYMFIELD_CONVERT
  TC_LOCAL_SYMFIELD_CONVERT (locsym, ret);
#endif

  symbol_table_insert (ret);

  local_symbol_mark_converted (locsym);
  local_symbol_set_real_symbol (locsym, ret);

  hash_jam (local_hash, locsym->lsy_name, NULL);

  return ret;
}

#else /* ! BFD_ASSEMBLER */

#define LOCAL_SYMBOL_CHECK(s) 0
#define local_symbol_convert(s) ((symbolS *) s)

#endif /* ! BFD_ASSEMBLER */

/* We have just seen "<name>:".
   Creates a struct symbol unless it already exists.

   Gripes if we are redefining a symbol incompatibly (and ignores it).  */

symbolS *
colon (/* Just seen "x:" - rattle symbols & frags.  */
       const char *sym_name	/* Symbol name, as a cannonical string.  */
       /* We copy this string: OK to alter later.  */)
{
  register symbolS *symbolP;	/* Symbol we are working with.  */

  /* Sun local labels go out of scope whenever a non-local symbol is
     defined.  */
  if (LOCAL_LABELS_DOLLAR)
    {
      int local;

#ifdef BFD_ASSEMBLER
      local = bfd_is_local_label_name (stdoutput, sym_name);
#else
      local = LOCAL_LABEL (sym_name);
#endif

      if (! local)
	dollar_label_clear ();
    }

#ifndef WORKING_DOT_WORD
  if (new_broken_words)
    {
      struct broken_word *a;
      int possible_bytes;
      fragS *frag_tmp;
      char *frag_opcode;

      extern const int md_short_jump_size;
      extern const int md_long_jump_size;

      if (now_seg == absolute_section)
	{
	  as_bad (_("cannot define symbol `%s' in absolute section"), sym_name);
	  return NULL;
	}

      possible_bytes = (md_short_jump_size
			+ new_broken_words * md_long_jump_size);

      frag_tmp = frag_now;
      frag_opcode = frag_var (rs_broken_word,
			      possible_bytes,
			      possible_bytes,
			      (relax_substateT) 0,
			      (symbolS *) broken_words,
			      (offsetT) 0,
			      NULL);

      /* We want to store the pointer to where to insert the jump
	 table in the fr_opcode of the rs_broken_word frag.  This
	 requires a little hackery.  */
      while (frag_tmp
	     && (frag_tmp->fr_type != rs_broken_word
		 || frag_tmp->fr_opcode))
	frag_tmp = frag_tmp->fr_next;
      know (frag_tmp);
      frag_tmp->fr_opcode = frag_opcode;
      new_broken_words = 0;

      for (a = broken_words; a && a->dispfrag == 0; a = a->next_broken_word)
	a->dispfrag = frag_tmp;
    }
#endif /* WORKING_DOT_WORD */

  if ((symbolP = symbol_find (sym_name)) != 0)
    {
#ifdef RESOLVE_SYMBOL_REDEFINITION
      if (RESOLVE_SYMBOL_REDEFINITION (symbolP))
	return symbolP;
#endif
      /* Now check for undefined symbols.  */
      if (LOCAL_SYMBOL_CHECK (symbolP))
	{
#ifdef BFD_ASSEMBLER
	  struct local_symbol *locsym = (struct local_symbol *) symbolP;

	  if (locsym->lsy_section != undefined_section
	      && (local_symbol_get_frag (locsym) != frag_now
		  || locsym->lsy_section != now_seg
		  || locsym->lsy_value != frag_now_fix ()))
	    {
	      as_bad (_("symbol `%s' is already defined"), sym_name);
	      return symbolP;
	    }

	  locsym->lsy_section = now_seg;
	  local_symbol_set_frag (locsym, frag_now);
	  locsym->lsy_value = frag_now_fix ();
#endif
	}
      else if (!S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP))
	{
	  if (S_GET_VALUE (symbolP) == 0)
	    {
	      symbolP->sy_frag = frag_now;
#ifdef OBJ_VMS
	      S_SET_OTHER (symbolP, const_flag);
#endif
	      S_SET_VALUE (symbolP, (valueT) frag_now_fix ());
	      S_SET_SEGMENT (symbolP, now_seg);
#ifdef N_UNDF
	      know (N_UNDF == 0);
#endif /* if we have one, it better be zero.  */

	    }
	  else
	    {
	      /* There are still several cases to check:

		 A .comm/.lcomm symbol being redefined as initialized
		 data is OK

		 A .comm/.lcomm symbol being redefined with a larger
		 size is also OK

		 This only used to be allowed on VMS gas, but Sun cc
		 on the sparc also depends on it.  */

	      if (((!S_IS_DEBUG (symbolP)
		    && (!S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP))
		    && S_IS_EXTERNAL (symbolP))
		   || S_GET_SEGMENT (symbolP) == bss_section)
		  && (now_seg == data_section
		      || now_seg == S_GET_SEGMENT (symbolP)))
		{
		  /* Select which of the 2 cases this is.  */
		  if (now_seg != data_section)
		    {
		      /* New .comm for prev .comm symbol.

			 If the new size is larger we just change its
			 value.  If the new size is smaller, we ignore
			 this symbol.  */
		      if (S_GET_VALUE (symbolP)
			  < ((unsigned) frag_now_fix ()))
			{
			  S_SET_VALUE (symbolP, (valueT) frag_now_fix ());
			}
		    }
		  else
		    {
		      /* It is a .comm/.lcomm being converted to initialized
			 data.  */
		      symbolP->sy_frag = frag_now;
#ifdef OBJ_VMS
		      S_SET_OTHER (symbolP, const_flag);
#endif
		      S_SET_VALUE (symbolP, (valueT) frag_now_fix ());
		      S_SET_SEGMENT (symbolP, now_seg);	/* Keep N_EXT bit.  */
		    }
		}
	      else
		{
#if (!defined (OBJ_AOUT) && !defined (OBJ_MAYBE_AOUT) \
     && !defined (OBJ_BOUT) && !defined (OBJ_MAYBE_BOUT))
		  static const char *od_buf = "";
#else
		  char od_buf[100];
		  od_buf[0] = '\0';
#ifdef BFD_ASSEMBLER
		  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
#endif
		    sprintf (od_buf, "%d.%d.",
			     S_GET_OTHER (symbolP),
			     S_GET_DESC (symbolP));
#endif
		  as_bad (_("symbol `%s' is already defined as \"%s\"/%s%ld"),
			    sym_name,
			    segment_name (S_GET_SEGMENT (symbolP)),
			    od_buf,
			    (long) S_GET_VALUE (symbolP));
		}
	    }			/* if the undefined symbol has no value  */
	}
      else
	{
	  /* Don't blow up if the definition is the same.  */
	  if (!(frag_now == symbolP->sy_frag
		&& S_GET_VALUE (symbolP) == frag_now_fix ()
		&& S_GET_SEGMENT (symbolP) == now_seg))
	    as_bad (_("symbol `%s' is already defined"), sym_name);
	}

    }
#ifdef BFD_ASSEMBLER
  else if (! flag_keep_locals && bfd_is_local_label_name (stdoutput, sym_name))
    {
      symbolP = (symbolS *) local_symbol_make (sym_name, now_seg,
					       (valueT) frag_now_fix (),
					       frag_now);
    }
#endif /* BFD_ASSEMBLER */
  else
    {
      symbolP = symbol_new (sym_name, now_seg, (valueT) frag_now_fix (),
			    frag_now);
#ifdef OBJ_VMS
      S_SET_OTHER (symbolP, const_flag);
#endif /* OBJ_VMS */

      symbol_table_insert (symbolP);
    }

  if (mri_common_symbol != NULL)
    {
      /* This symbol is actually being defined within an MRI common
	 section.  This requires special handling.  */
      if (LOCAL_SYMBOL_CHECK (symbolP))
	symbolP = local_symbol_convert ((struct local_symbol *) symbolP);
      symbolP->sy_value.X_op = O_symbol;
      symbolP->sy_value.X_add_symbol = mri_common_symbol;
      symbolP->sy_value.X_add_number = S_GET_VALUE (mri_common_symbol);
      symbolP->sy_frag = &zero_address_frag;
      S_SET_SEGMENT (symbolP, expr_section);
      symbolP->sy_mri_common = 1;
    }

#ifdef tc_frob_label
  tc_frob_label (symbolP);
#endif
#ifdef obj_frob_label
  obj_frob_label (symbolP);
#endif

  return symbolP;
}

/* Die if we can't insert the symbol.  */

void
symbol_table_insert (symbolS *symbolP)
{
  register const char *error_string;

  know (symbolP);
  know (S_GET_NAME (symbolP));

  if (LOCAL_SYMBOL_CHECK (symbolP))
    {
      error_string = hash_jam (local_hash, S_GET_NAME (symbolP),
			       (PTR) symbolP);
      if (error_string != NULL)
	as_fatal (_("inserting \"%s\" into symbol table failed: %s"),
		  S_GET_NAME (symbolP), error_string);
      return;
    }

  if ((error_string = hash_jam (sy_hash, S_GET_NAME (symbolP), (PTR) symbolP)))
    {
      as_fatal (_("inserting \"%s\" into symbol table failed: %s"),
		S_GET_NAME (symbolP), error_string);
    }				/* on error  */
}

/* If a symbol name does not exist, create it as undefined, and insert
   it into the symbol table.  Return a pointer to it.  */

symbolS *
symbol_find_or_make (const char *name)
{
  register symbolS *symbolP;

  symbolP = symbol_find (name);

  if (symbolP == NULL)
    {
#ifdef BFD_ASSEMBLER
      if (! flag_keep_locals && bfd_is_local_label_name (stdoutput, name))
	{
	  symbolP = md_undefined_symbol ((char *) name);
	  if (symbolP != NULL)
	    return symbolP;

	  symbolP = (symbolS *) local_symbol_make (name, undefined_section,
						   (valueT) 0,
						   &zero_address_frag);
	  return symbolP;
	}
#endif

      symbolP = symbol_make (name);

      symbol_table_insert (symbolP);
    }				/* if symbol wasn't found */

  return (symbolP);
}

symbolS *
symbol_make (const char *name)
{
  symbolS *symbolP;

  /* Let the machine description default it, e.g. for register names.  */
  symbolP = md_undefined_symbol ((char *) name);

  if (!symbolP)
    symbolP = symbol_new (name, undefined_section, (valueT) 0, &zero_address_frag);

  return (symbolP);
}

symbolS *
symbol_temp_new (segT seg, valueT ofs, fragS *frag)
{
  return symbol_new (FAKE_LABEL_NAME, seg, ofs, frag);
}

symbolS *
symbol_temp_new_now (void)
{
  return symbol_temp_new (now_seg, frag_now_fix (), frag_now);
}

symbolS *
symbol_temp_make (void)
{
  return symbol_make (FAKE_LABEL_NAME);
}

/* Implement symbol table lookup.
   In:	A symbol's name as a string: '\0' can't be part of a symbol name.
   Out:	NULL if the name was not in the symbol table, else the address
   of a struct symbol associated with that name.  */

symbolS *
symbol_find (const char *name)
{
#ifdef STRIP_UNDERSCORE
  return (symbol_find_base (name, 1));
#else /* STRIP_UNDERSCORE */
  return (symbol_find_base (name, 0));
#endif /* STRIP_UNDERSCORE */
}

symbolS *
symbol_find_exact (const char *name)
{
#ifdef BFD_ASSEMBLER
  {
    struct local_symbol *locsym;

    locsym = (struct local_symbol *) hash_find (local_hash, name);
    if (locsym != NULL)
      return (symbolS *) locsym;
  }
#endif

  return ((symbolS *) hash_find (sy_hash, name));
}

symbolS *
symbol_find_base (const char *name, int strip_underscore)
{
  if (strip_underscore && *name == '_')
    name++;

#ifdef tc_canonicalize_symbol_name
  {
    char *copy;
    size_t len = strlen (name) + 1;

    copy = (char *) alloca (len);
    memcpy (copy, name, len);
    name = tc_canonicalize_symbol_name (copy);
  }
#endif

  if (! symbols_case_sensitive)
    {
      char *copy;
      const char *orig;
      unsigned char c;

      orig = name;
      name = copy = (char *) alloca (strlen (name) + 1);

      while ((c = *orig++) != '\0')
	{
	  *copy++ = TOUPPER (c);
	}
      *copy = '\0';
    }

  return symbol_find_exact (name);
}

/* Once upon a time, symbols were kept in a singly linked list.  At
   least coff needs to be able to rearrange them from time to time, for
   which a doubly linked list is much more convenient.  Loic did these
   as macros which seemed dangerous to me so they're now functions.
   xoxorich.  */

/* Link symbol ADDME after symbol TARGET in the chain.  */

void
symbol_append (symbolS *addme, symbolS *target,
	       symbolS **rootPP, symbolS **lastPP)
{
  if (LOCAL_SYMBOL_CHECK (addme))
    abort ();
  if (target != NULL && LOCAL_SYMBOL_CHECK (target))
    abort ();

  if (target == NULL)
    {
      know (*rootPP == NULL);
      know (*lastPP == NULL);
      addme->sy_next = NULL;
#ifdef SYMBOLS_NEED_BACKPOINTERS
      addme->sy_previous = NULL;
#endif
      *rootPP = addme;
      *lastPP = addme;
      return;
    }				/* if the list is empty  */

  if (target->sy_next != NULL)
    {
#ifdef SYMBOLS_NEED_BACKPOINTERS
      target->sy_next->sy_previous = addme;
#endif /* SYMBOLS_NEED_BACKPOINTERS */
    }
  else
    {
      know (*lastPP == target);
      *lastPP = addme;
    }				/* if we have a next  */

  addme->sy_next = target->sy_next;
  target->sy_next = addme;

#ifdef SYMBOLS_NEED_BACKPOINTERS
  addme->sy_previous = target;
#endif /* SYMBOLS_NEED_BACKPOINTERS */

  debug_verify_symchain (symbol_rootP, symbol_lastP);
}

/* Set the chain pointers of SYMBOL to null.  */

void
symbol_clear_list_pointers (symbolS *symbolP)
{
  if (LOCAL_SYMBOL_CHECK (symbolP))
    abort ();
  symbolP->sy_next = NULL;
#ifdef SYMBOLS_NEED_BACKPOINTERS
  symbolP->sy_previous = NULL;
#endif
}

#ifdef SYMBOLS_NEED_BACKPOINTERS
/* Remove SYMBOLP from the list.  */

void
symbol_remove (symbolS *symbolP, symbolS **rootPP, symbolS **lastPP)
{
  if (LOCAL_SYMBOL_CHECK (symbolP))
    abort ();

  if (symbolP == *rootPP)
    {
      *rootPP = symbolP->sy_next;
    }				/* if it was the root  */

  if (symbolP == *lastPP)
    {
      *lastPP = symbolP->sy_previous;
    }				/* if it was the tail  */

  if (symbolP->sy_next != NULL)
    {
      symbolP->sy_next->sy_previous = symbolP->sy_previous;
    }				/* if not last  */

  if (symbolP->sy_previous != NULL)
    {
      symbolP->sy_previous->sy_next = symbolP->sy_next;
    }				/* if not first  */

  debug_verify_symchain (*rootPP, *lastPP);
}

/* Link symbol ADDME before symbol TARGET in the chain.  */

void
symbol_insert (symbolS *addme, symbolS *target,
	       symbolS **rootPP, symbolS **lastPP ATTRIBUTE_UNUSED)
{
  if (LOCAL_SYMBOL_CHECK (addme))
    abort ();
  if (LOCAL_SYMBOL_CHECK (target))
    abort ();

  if (target->sy_previous != NULL)
    {
      target->sy_previous->sy_next = addme;
    }
  else
    {
      know (*rootPP == target);
      *rootPP = addme;
    }				/* if not first  */

  addme->sy_previous = target->sy_previous;
  target->sy_previous = addme;
  addme->sy_next = target;

  debug_verify_symchain (*rootPP, *lastPP);
}

#endif /* SYMBOLS_NEED_BACKPOINTERS */

void
verify_symbol_chain (symbolS *rootP, symbolS *lastP)
{
  symbolS *symbolP = rootP;

  if (symbolP == NULL)
    return;

  for (; symbol_next (symbolP) != NULL; symbolP = symbol_next (symbolP))
    {
#ifdef BFD_ASSEMBLER
      assert (symbolP->bsym != NULL);
#endif
#ifdef SYMBOLS_NEED_BACKPOINTERS
      assert (symbolP->sy_next->sy_previous == symbolP);
#else
      /* Walk the list anyways, to make sure pointers are still good.  */
      ;
#endif /* SYMBOLS_NEED_BACKPOINTERS */
    }

  assert (lastP == symbolP);
}

void
verify_symbol_chain_2 (symbolS *sym)
{
  symbolS *p = sym, *n = sym;
#ifdef SYMBOLS_NEED_BACKPOINTERS
  while (symbol_previous (p))
    p = symbol_previous (p);
#endif
  while (symbol_next (n))
    n = symbol_next (n);
  verify_symbol_chain (p, n);
}

static void
report_op_error (symbolS *symp, symbolS *left, symbolS *right)
{
  char *file;
  unsigned int line;
  segT seg_left = S_GET_SEGMENT (left);
  segT seg_right = right ? S_GET_SEGMENT (right) : 0;

  if (expr_symbol_where (symp, &file, &line))
    {
      if (seg_left == undefined_section)
	as_bad_where (file, line,
		      _("undefined symbol `%s' in operation"),
		      S_GET_NAME (left));
      if (seg_right == undefined_section)
	as_bad_where (file, line,
		      _("undefined symbol `%s' in operation"),
		      S_GET_NAME (right));
      if (seg_left != undefined_section
	  && seg_right != undefined_section)
	{
	  if (right)
	    as_bad_where (file, line,
			  _("invalid sections for operation on `%s' and `%s'"),
			  S_GET_NAME (left), S_GET_NAME (right));
	  else
	    as_bad_where (file, line,
			  _("invalid section for operation on `%s'"),
			  S_GET_NAME (left));
	}

    }
  else
    {
      if (seg_left == undefined_section)
	as_bad (_("undefined symbol `%s' in operation setting `%s'"),
		S_GET_NAME (left), S_GET_NAME (symp));
      if (seg_right == undefined_section)
	as_bad (_("undefined symbol `%s' in operation setting `%s'"),
		S_GET_NAME (right), S_GET_NAME (symp));
      if (seg_left != undefined_section
	  && seg_right != undefined_section)
	{
	  if (right)
	    as_bad_where (file, line,
			  _("invalid sections for operation on `%s' and `%s' setting `%s'"),
			  S_GET_NAME (left), S_GET_NAME (right), S_GET_NAME (symp));
	  else
	    as_bad_where (file, line,
			  _("invalid section for operation on `%s' setting `%s'"),
			  S_GET_NAME (left), S_GET_NAME (symp));
	}
    }
}

/* Resolve the value of a symbol.  This is called during the final
   pass over the symbol table to resolve any symbols with complex
   values.  */

valueT
resolve_symbol_value (symbolS *symp)
{
  int resolved;
  valueT final_val = 0;
  segT final_seg;

#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (symp))
    {
      struct local_symbol *locsym = (struct local_symbol *) symp;

      final_val = locsym->lsy_value;
      if (local_symbol_resolved_p (locsym))
	return final_val;

      final_val += local_symbol_get_frag (locsym)->fr_address / OCTETS_PER_BYTE;

      if (finalize_syms)
	{
	  locsym->lsy_value = final_val;
	  local_symbol_mark_resolved (locsym);
	}

      return final_val;
    }
#endif

  if (symp->sy_resolved)
    {
      if (symp->sy_value.X_op == O_constant)
	return (valueT) symp->sy_value.X_add_number;
      else
	return 0;
    }

  resolved = 0;
  final_seg = S_GET_SEGMENT (symp);

  if (symp->sy_resolving)
    {
      if (finalize_syms)
	as_bad (_("symbol definition loop encountered at `%s'"),
		S_GET_NAME (symp));
      final_val = 0;
      resolved = 1;
    }
  else
    {
      symbolS *add_symbol, *op_symbol;
      offsetT left, right;
      segT seg_left, seg_right;
      operatorT op;

      symp->sy_resolving = 1;

      /* Help out with CSE.  */
      add_symbol = symp->sy_value.X_add_symbol;
      op_symbol = symp->sy_value.X_op_symbol;
      final_val = symp->sy_value.X_add_number;
      op = symp->sy_value.X_op;

      switch (op)
	{
	default:
	  BAD_CASE (op);
	  break;

	case O_absent:
	  final_val = 0;
	  /* Fall through.  */

	case O_constant:
	  final_val += symp->sy_frag->fr_address / OCTETS_PER_BYTE;
	  if (final_seg == expr_section)
	    final_seg = absolute_section;
	  resolved = 1;
	  break;

	case O_symbol:
	case O_symbol_rva:
	  left = resolve_symbol_value (add_symbol);
	  seg_left = S_GET_SEGMENT (add_symbol);
	  if (finalize_syms)
	    symp->sy_value.X_op_symbol = NULL;

	do_symbol:
	  if (symp->sy_mri_common)
	    {
	      /* This is a symbol inside an MRI common section.  The
		 relocation routines are going to handle it specially.
		 Don't change the value.  */
	      resolved = symbol_resolved_p (add_symbol);
	      break;
	    }

	  if (finalize_syms && final_val == 0)
	    {
	      if (LOCAL_SYMBOL_CHECK (add_symbol))
		add_symbol = local_symbol_convert ((struct local_symbol *)
						   add_symbol);
	      copy_symbol_attributes (symp, add_symbol);
	    }

	  /* If we have equated this symbol to an undefined or common
	     symbol, keep X_op set to O_symbol, and don't change
	     X_add_number.  This permits the routine which writes out
	     relocation to detect this case, and convert the
	     relocation to be against the symbol to which this symbol
	     is equated.  */
	  if (! S_IS_DEFINED (add_symbol) || S_IS_COMMON (add_symbol))
	    {
	      if (finalize_syms)
		{
		  symp->sy_value.X_op = O_symbol;
		  symp->sy_value.X_add_symbol = add_symbol;
		  symp->sy_value.X_add_number = final_val;
		  /* Use X_op_symbol as a flag.  */
		  symp->sy_value.X_op_symbol = add_symbol;
		  final_seg = seg_left;
		}
	      final_val = 0;
	      resolved = symbol_resolved_p (add_symbol);
	      symp->sy_resolving = 0;
	      goto exit_dont_set_value;
	    }
	  else if (finalize_syms && final_seg == expr_section
		   && seg_left != expr_section)
	    {
	      /* If the symbol is an expression symbol, do similarly
		 as for undefined and common syms above.  Handles
		 "sym +/- expr" where "expr" cannot be evaluated
		 immediately, and we want relocations to be against
		 "sym", eg. because it is weak.  */
	      symp->sy_value.X_op = O_symbol;
	      symp->sy_value.X_add_symbol = add_symbol;
	      symp->sy_value.X_add_number = final_val;
	      symp->sy_value.X_op_symbol = add_symbol;
	      final_seg = seg_left;
	      final_val += symp->sy_frag->fr_address + left;
	      resolved = symbol_resolved_p (add_symbol);
	      symp->sy_resolving = 0;
	      goto exit_dont_set_value;
	    }
	  else
	    {
	      final_val += symp->sy_frag->fr_address + left;
	      if (final_seg == expr_section || final_seg == undefined_section)
		final_seg = seg_left;
	    }

	  resolved = symbol_resolved_p (add_symbol);
	  break;

	case O_uminus:
	case O_bit_not:
	case O_logical_not:
	  left = resolve_symbol_value (add_symbol);
	  seg_left = S_GET_SEGMENT (add_symbol);

	  /* By reducing these to the relevant dyadic operator, we get
	     	!S -> S == 0 	permitted on anything,
		-S -> 0 - S 	only permitted on absolute
		~S -> S ^ ~0 	only permitted on absolute  */
	  if (op != O_logical_not && seg_left != absolute_section
	      && finalize_syms)
	    report_op_error (symp, add_symbol, NULL);

	  if (final_seg == expr_section || final_seg == undefined_section)
	    final_seg = absolute_section;

	  if (op == O_uminus)
	    left = -left;
	  else if (op == O_logical_not)
	    left = !left;
	  else
	    left = ~left;

	  final_val += left + symp->sy_frag->fr_address;

	  resolved = symbol_resolved_p (add_symbol);
	  break;

	case O_multiply:
	case O_divide:
	case O_modulus:
	case O_left_shift:
	case O_right_shift:
	case O_bit_inclusive_or:
	case O_bit_or_not:
	case O_bit_exclusive_or:
	case O_bit_and:
	case O_add:
	case O_subtract:
	case O_eq:
	case O_ne:
	case O_lt:
	case O_le:
	case O_ge:
	case O_gt:
	case O_logical_and:
	case O_logical_or:
	  left = resolve_symbol_value (add_symbol);
	  right = resolve_symbol_value (op_symbol);
	  seg_left = S_GET_SEGMENT (add_symbol);
	  seg_right = S_GET_SEGMENT (op_symbol);

	  /* Simplify addition or subtraction of a constant by folding the
	     constant into X_add_number.  */
	  if (op == O_add)
	    {
	      if (seg_right == absolute_section)
		{
		  final_val += right;
		  goto do_symbol;
		}
	      else if (seg_left == absolute_section)
		{
		  final_val += left;
		  add_symbol = op_symbol;
		  left = right;
		  seg_left = seg_right;
		  goto do_symbol;
		}
	    }
	  else if (op == O_subtract)
	    {
	      if (seg_right == absolute_section)
		{
		  final_val -= right;
		  goto do_symbol;
		}
	    }

	  /* Equality and non-equality tests are permitted on anything.
	     Subtraction, and other comparison operators are permitted if
	     both operands are in the same section.  Otherwise, both
	     operands must be absolute.  We already handled the case of
	     addition or subtraction of a constant above.  This will
	     probably need to be changed for an object file format which
	     supports arbitrary expressions, such as IEEE-695.

	     Don't emit messages unless we're finalizing the symbol value,
	     otherwise we may get the same message multiple times.  */
	  if (finalize_syms
	      && !(seg_left == absolute_section
		   && seg_right == absolute_section)
	      && !(op == O_eq || op == O_ne)
	      && !((op == O_subtract
		    || op == O_lt || op == O_le || op == O_ge || op == O_gt)
		   && seg_left == seg_right
		   && (seg_left != undefined_section
		       || add_symbol == op_symbol)))
	    report_op_error (symp, add_symbol, op_symbol);

	  if (final_seg == expr_section || final_seg == undefined_section)
	    final_seg = absolute_section;

	  /* Check for division by zero.  */
	  if ((op == O_divide || op == O_modulus) && right == 0)
	    {
	      /* If seg_right is not absolute_section, then we've
		 already issued a warning about using a bad symbol.  */
	      if (seg_right == absolute_section && finalize_syms)
		{
		  char *file;
		  unsigned int line;

		  if (expr_symbol_where (symp, &file, &line))
		    as_bad_where (file, line, _("division by zero"));
		  else
		    as_bad (_("division by zero when setting `%s'"),
			    S_GET_NAME (symp));
		}

	      right = 1;
	    }

	  switch (symp->sy_value.X_op)
	    {
	    case O_multiply:		left *= right; break;
	    case O_divide:		left /= right; break;
	    case O_modulus:		left %= right; break;
	    case O_left_shift:		left <<= right; break;
	    case O_right_shift:		left >>= right; break;
	    case O_bit_inclusive_or:	left |= right; break;
	    case O_bit_or_not:		left |= ~right; break;
	    case O_bit_exclusive_or:	left ^= right; break;
	    case O_bit_and:		left &= right; break;
	    case O_add:			left += right; break;
	    case O_subtract:		left -= right; break;
	    case O_eq:
	    case O_ne:
	      left = (left == right && seg_left == seg_right
		      && (seg_left != undefined_section
			  || add_symbol == op_symbol)
		      ? ~ (offsetT) 0 : 0);
	      if (symp->sy_value.X_op == O_ne)
		left = ~left;
	      break;
	    case O_lt:	left = left <  right ? ~ (offsetT) 0 : 0; break;
	    case O_le:	left = left <= right ? ~ (offsetT) 0 : 0; break;
	    case O_ge:	left = left >= right ? ~ (offsetT) 0 : 0; break;
	    case O_gt:	left = left >  right ? ~ (offsetT) 0 : 0; break;
	    case O_logical_and:	left = left && right; break;
	    case O_logical_or:	left = left || right; break;
	    default:		abort ();
	    }

	  final_val += symp->sy_frag->fr_address + left;
	  if (final_seg == expr_section || final_seg == undefined_section)
	    {
	      if (seg_left == undefined_section
		  || seg_right == undefined_section)
		final_seg = undefined_section;
	      else if (seg_left == absolute_section)
		final_seg = seg_right;
	      else
		final_seg = seg_left;
	    }
	  resolved = (symbol_resolved_p (add_symbol)
		      && symbol_resolved_p (op_symbol));
	  break;

	case O_register:
	case O_big:
	case O_illegal:
	  /* Give an error (below) if not in expr_section.  We don't
	     want to worry about expr_section symbols, because they
	     are fictional (they are created as part of expression
	     resolution), and any problems may not actually mean
	     anything.  */
	  break;
	}

      symp->sy_resolving = 0;
    }

  if (finalize_syms)
    S_SET_VALUE (symp, final_val);

exit_dont_set_value:
  /* Always set the segment, even if not finalizing the value.
     The segment is used to determine whether a symbol is defined.  */
#if defined (OBJ_AOUT) && ! defined (BFD_ASSEMBLER)
  /* The old a.out backend does not handle S_SET_SEGMENT correctly
     for a stab symbol, so we use this bad hack.  */
  if (final_seg != S_GET_SEGMENT (symp))
#endif
    S_SET_SEGMENT (symp, final_seg);

  /* Don't worry if we can't resolve an expr_section symbol.  */
  if (finalize_syms)
    {
      if (resolved)
	symp->sy_resolved = 1;
      else if (S_GET_SEGMENT (symp) != expr_section)
	{
	  as_bad (_("can't resolve value for symbol `%s'"),
		  S_GET_NAME (symp));
	  symp->sy_resolved = 1;
	}
    }

  return final_val;
}

#ifdef BFD_ASSEMBLER

static void resolve_local_symbol (const char *, PTR);

/* A static function passed to hash_traverse.  */

static void
resolve_local_symbol (const char *key ATTRIBUTE_UNUSED, PTR value)
{
  if (value != NULL)
    resolve_symbol_value (value);
}

#endif

/* Resolve all local symbols.  */

void
resolve_local_symbol_values (void)
{
#ifdef BFD_ASSEMBLER
  hash_traverse (local_hash, resolve_local_symbol);
#endif
}

/* Dollar labels look like a number followed by a dollar sign.  Eg, "42$".
   They are *really* local.  That is, they go out of scope whenever we see a
   label that isn't local.  Also, like fb labels, there can be multiple
   instances of a dollar label.  Therefor, we name encode each instance with
   the instance number, keep a list of defined symbols separate from the real
   symbol table, and we treat these buggers as a sparse array.  */

static long *dollar_labels;
static long *dollar_label_instances;
static char *dollar_label_defines;
static unsigned long dollar_label_count;
static unsigned long dollar_label_max;

int
dollar_label_defined (long label)
{
  long *i;

  know ((dollar_labels != NULL) || (dollar_label_count == 0));

  for (i = dollar_labels; i < dollar_labels + dollar_label_count; ++i)
    if (*i == label)
      return dollar_label_defines[i - dollar_labels];

  /* If we get here, label isn't defined.  */
  return 0;
}

static long
dollar_label_instance (long label)
{
  long *i;

  know ((dollar_labels != NULL) || (dollar_label_count == 0));

  for (i = dollar_labels; i < dollar_labels + dollar_label_count; ++i)
    if (*i == label)
      return (dollar_label_instances[i - dollar_labels]);

  /* If we get here, we haven't seen the label before.
     Therefore its instance count is zero.  */
  return 0;
}

void
dollar_label_clear (void)
{
  memset (dollar_label_defines, '\0', (unsigned int) dollar_label_count);
}

#define DOLLAR_LABEL_BUMP_BY 10

void
define_dollar_label (long label)
{
  long *i;

  for (i = dollar_labels; i < dollar_labels + dollar_label_count; ++i)
    if (*i == label)
      {
	++dollar_label_instances[i - dollar_labels];
	dollar_label_defines[i - dollar_labels] = 1;
	return;
      }

  /* If we get to here, we don't have label listed yet.  */

  if (dollar_labels == NULL)
    {
      dollar_labels = (long *) xmalloc (DOLLAR_LABEL_BUMP_BY * sizeof (long));
      dollar_label_instances = (long *) xmalloc (DOLLAR_LABEL_BUMP_BY * sizeof (long));
      dollar_label_defines = xmalloc (DOLLAR_LABEL_BUMP_BY);
      dollar_label_max = DOLLAR_LABEL_BUMP_BY;
      dollar_label_count = 0;
    }
  else if (dollar_label_count == dollar_label_max)
    {
      dollar_label_max += DOLLAR_LABEL_BUMP_BY;
      dollar_labels = (long *) xrealloc ((char *) dollar_labels,
					 dollar_label_max * sizeof (long));
      dollar_label_instances = (long *) xrealloc ((char *) dollar_label_instances,
					  dollar_label_max * sizeof (long));
      dollar_label_defines = xrealloc (dollar_label_defines, dollar_label_max);
    }				/* if we needed to grow  */

  dollar_labels[dollar_label_count] = label;
  dollar_label_instances[dollar_label_count] = 1;
  dollar_label_defines[dollar_label_count] = 1;
  ++dollar_label_count;
}

/* Caller must copy returned name: we re-use the area for the next name.

   The mth occurence of label n: is turned into the symbol "Ln^Am"
   where n is the label number and m is the instance number. "L" makes
   it a label discarded unless debugging and "^A"('\1') ensures no
   ordinary symbol SHOULD get the same name as a local label
   symbol. The first "4:" is "L4^A1" - the m numbers begin at 1.

   fb labels get the same treatment, except that ^B is used in place
   of ^A.  */

char *				/* Return local label name.  */
dollar_label_name (register long n,	/* we just saw "n$:" : n a number.  */
		   register int augend	/* 0 for current instance, 1 for new instance.  */)
{
  long i;
  /* Returned to caller, then copied.  Used for created names ("4f").  */
  static char symbol_name_build[24];
  register char *p;
  register char *q;
  char symbol_name_temporary[20];	/* Build up a number, BACKWARDS.  */

  know (n >= 0);
  know (augend == 0 || augend == 1);
  p = symbol_name_build;
#ifdef LOCAL_LABEL_PREFIX
  *p++ = LOCAL_LABEL_PREFIX;
#endif
  *p++ = 'L';

  /* Next code just does sprintf( {}, "%d", n);  */
  /* Label number.  */
  q = symbol_name_temporary;
  for (*q++ = 0, i = n; i; ++q)
    {
      *q = i % 10 + '0';
      i /= 10;
    }
  while ((*p = *--q) != '\0')
    ++p;

  *p++ = DOLLAR_LABEL_CHAR;		/* ^A  */

  /* Instance number.  */
  q = symbol_name_temporary;
  for (*q++ = 0, i = dollar_label_instance (n) + augend; i; ++q)
    {
      *q = i % 10 + '0';
      i /= 10;
    }
  while ((*p++ = *--q) != '\0');;

  /* The label, as a '\0' ended string, starts at symbol_name_build.  */
  return symbol_name_build;
}

/* Somebody else's idea of local labels. They are made by "n:" where n
   is any decimal digit. Refer to them with
    "nb" for previous (backward) n:
   or "nf" for next (forward) n:.

   We do a little better and let n be any number, not just a single digit, but
   since the other guy's assembler only does ten, we treat the first ten
   specially.

   Like someone else's assembler, we have one set of local label counters for
   entire assembly, not one set per (sub)segment like in most assemblers. This
   implies that one can refer to a label in another segment, and indeed some
   crufty compilers have done just that.

   Since there could be a LOT of these things, treat them as a sparse
   array.  */

#define FB_LABEL_SPECIAL (10)

static long fb_low_counter[FB_LABEL_SPECIAL];
static long *fb_labels;
static long *fb_label_instances;
static long fb_label_count;
static long fb_label_max;

/* This must be more than FB_LABEL_SPECIAL.  */
#define FB_LABEL_BUMP_BY (FB_LABEL_SPECIAL + 6)

static void
fb_label_init (void)
{
  memset ((void *) fb_low_counter, '\0', sizeof (fb_low_counter));
}

/* Add one to the instance number of this fb label.  */

void
fb_label_instance_inc (long label)
{
  long *i;

  if (label < FB_LABEL_SPECIAL)
    {
      ++fb_low_counter[label];
      return;
    }

  if (fb_labels != NULL)
    {
      for (i = fb_labels + FB_LABEL_SPECIAL;
	   i < fb_labels + fb_label_count; ++i)
	{
	  if (*i == label)
	    {
	      ++fb_label_instances[i - fb_labels];
	      return;
	    }			/* if we find it  */
	}			/* for each existing label  */
    }

  /* If we get to here, we don't have label listed yet.  */

  if (fb_labels == NULL)
    {
      fb_labels = (long *) xmalloc (FB_LABEL_BUMP_BY * sizeof (long));
      fb_label_instances = (long *) xmalloc (FB_LABEL_BUMP_BY * sizeof (long));
      fb_label_max = FB_LABEL_BUMP_BY;
      fb_label_count = FB_LABEL_SPECIAL;

    }
  else if (fb_label_count == fb_label_max)
    {
      fb_label_max += FB_LABEL_BUMP_BY;
      fb_labels = (long *) xrealloc ((char *) fb_labels,
				     fb_label_max * sizeof (long));
      fb_label_instances = (long *) xrealloc ((char *) fb_label_instances,
					      fb_label_max * sizeof (long));
    }				/* if we needed to grow  */

  fb_labels[fb_label_count] = label;
  fb_label_instances[fb_label_count] = 1;
  ++fb_label_count;
}

static long
fb_label_instance (long label)
{
  long *i;

  if (label < FB_LABEL_SPECIAL)
    {
      return (fb_low_counter[label]);
    }

  if (fb_labels != NULL)
    {
      for (i = fb_labels + FB_LABEL_SPECIAL;
	   i < fb_labels + fb_label_count; ++i)
	{
	  if (*i == label)
	    {
	      return (fb_label_instances[i - fb_labels]);
	    }			/* if we find it  */
	}			/* for each existing label  */
    }

  /* We didn't find the label, so this must be a reference to the
     first instance.  */
  return 0;
}

/* Caller must copy returned name: we re-use the area for the next name.

   The mth occurence of label n: is turned into the symbol "Ln^Bm"
   where n is the label number and m is the instance number. "L" makes
   it a label discarded unless debugging and "^B"('\2') ensures no
   ordinary symbol SHOULD get the same name as a local label
   symbol. The first "4:" is "L4^B1" - the m numbers begin at 1.

   dollar labels get the same treatment, except that ^A is used in
   place of ^B.  */

char *				/* Return local label name.  */
fb_label_name (long n,	/* We just saw "n:", "nf" or "nb" : n a number.  */
	       long augend	/* 0 for nb, 1 for n:, nf.  */)
{
  long i;
  /* Returned to caller, then copied.  Used for created names ("4f").  */
  static char symbol_name_build[24];
  register char *p;
  register char *q;
  char symbol_name_temporary[20];	/* Build up a number, BACKWARDS.  */

  know (n >= 0);
  know (augend == 0 || augend == 1);
  p = symbol_name_build;
#ifdef LOCAL_LABEL_PREFIX
  *p++ = LOCAL_LABEL_PREFIX;
#endif
  *p++ = 'L';

  /* Next code just does sprintf( {}, "%d", n);  */
  /* Label number.  */
  q = symbol_name_temporary;
  for (*q++ = 0, i = n; i; ++q)
    {
      *q = i % 10 + '0';
      i /= 10;
    }
  while ((*p = *--q) != '\0')
    ++p;

  *p++ = LOCAL_LABEL_CHAR;		/* ^B  */

  /* Instance number.  */
  q = symbol_name_temporary;
  for (*q++ = 0, i = fb_label_instance (n) + augend; i; ++q)
    {
      *q = i % 10 + '0';
      i /= 10;
    }
  while ((*p++ = *--q) != '\0');;

  /* The label, as a '\0' ended string, starts at symbol_name_build.  */
  return (symbol_name_build);
}

/* Decode name that may have been generated by foo_label_name() above.
   If the name wasn't generated by foo_label_name(), then return it
   unaltered.  This is used for error messages.  */

char *
decode_local_label_name (char *s)
{
  char *p;
  char *symbol_decode;
  int label_number;
  int instance_number;
  char *type;
  const char *message_format;
  int index = 0;

#ifdef LOCAL_LABEL_PREFIX
  if (s[index] == LOCAL_LABEL_PREFIX)
    ++index;
#endif

  if (s[index] != 'L')
    return s;

  for (label_number = 0, p = s + index + 1; ISDIGIT (*p); ++p)
    label_number = (10 * label_number) + *p - '0';

  if (*p == DOLLAR_LABEL_CHAR)
    type = "dollar";
  else if (*p == LOCAL_LABEL_CHAR)
    type = "fb";
  else
    return s;

  for (instance_number = 0, p++; ISDIGIT (*p); ++p)
    instance_number = (10 * instance_number) + *p - '0';

  message_format = _("\"%d\" (instance number %d of a %s label)");
  symbol_decode = obstack_alloc (&notes, strlen (message_format) + 30);
  sprintf (symbol_decode, message_format, label_number, instance_number, type);

  return symbol_decode;
}

/* Get the value of a symbol.  */

valueT
S_GET_VALUE (symbolS *s)
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    return resolve_symbol_value (s);
#endif

  if (!s->sy_resolved)
    {
      valueT val = resolve_symbol_value (s);
      if (!finalize_syms)
	return val;
    }
  if (s->sy_value.X_op != O_constant)
    {
      static symbolS *recur;

      /* FIXME: In non BFD assemblers, S_IS_DEFINED and S_IS_COMMON
	 may call S_GET_VALUE.  We use a static symbol to avoid the
	 immediate recursion.  */
      if (recur == s)
	return (valueT) s->sy_value.X_add_number;
      recur = s;
      if (! s->sy_resolved
	  || s->sy_value.X_op != O_symbol
	  || (S_IS_DEFINED (s) && ! S_IS_COMMON (s)))
	as_bad (_("attempt to get value of unresolved symbol `%s'"),
		S_GET_NAME (s));
      recur = NULL;
    }
  return (valueT) s->sy_value.X_add_number;
}

/* Set the value of a symbol.  */

void
S_SET_VALUE (symbolS *s, valueT val)
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    {
      ((struct local_symbol *) s)->lsy_value = val;
      return;
    }
#endif

  s->sy_value.X_op = O_constant;
  s->sy_value.X_add_number = (offsetT) val;
  s->sy_value.X_unsigned = 0;
}

void
copy_symbol_attributes (symbolS *dest, symbolS *src)
{
  if (LOCAL_SYMBOL_CHECK (dest))
    dest = local_symbol_convert ((struct local_symbol *) dest);
  if (LOCAL_SYMBOL_CHECK (src))
    src = local_symbol_convert ((struct local_symbol *) src);

#ifdef BFD_ASSEMBLER
  /* In an expression, transfer the settings of these flags.
     The user can override later, of course.  */
#define COPIED_SYMFLAGS	(BSF_FUNCTION | BSF_OBJECT)
  dest->bsym->flags |= src->bsym->flags & COPIED_SYMFLAGS;
#endif

#ifdef OBJ_COPY_SYMBOL_ATTRIBUTES
  OBJ_COPY_SYMBOL_ATTRIBUTES (dest, src);
#endif
}

#ifdef BFD_ASSEMBLER

int
S_IS_FUNCTION (symbolS *s)
{
  flagword flags;

  if (LOCAL_SYMBOL_CHECK (s))
    return 0;

  flags = s->bsym->flags;

  return (flags & BSF_FUNCTION) != 0;
}

int
S_IS_EXTERNAL (symbolS *s)
{
  flagword flags;

  if (LOCAL_SYMBOL_CHECK (s))
    return 0;

  flags = s->bsym->flags;

  /* Sanity check.  */
  if ((flags & BSF_LOCAL) && (flags & BSF_GLOBAL))
    abort ();

  return (flags & BSF_GLOBAL) != 0;
}

int
S_IS_WEAK (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return (s->bsym->flags & BSF_WEAK) != 0;
}

int
S_IS_COMMON (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return bfd_is_com_section (s->bsym->section);
}

int
S_IS_DEFINED (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_section != undefined_section;
  return s->bsym->section != undefined_section;
}


#ifndef EXTERN_FORCE_RELOC
#define EXTERN_FORCE_RELOC IS_ELF
#endif

/* Return true for symbols that should not be reduced to section
   symbols or eliminated from expressions, because they may be
   overridden by the linker.  */
int
S_FORCE_RELOC (symbolS *s, int strict)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_section == undefined_section;

  return ((strict
	   && ((s->bsym->flags & BSF_WEAK) != 0
	       || (EXTERN_FORCE_RELOC
		   && (s->bsym->flags & BSF_GLOBAL) != 0)))
	  || s->bsym->section == undefined_section
	  || bfd_is_com_section (s->bsym->section));
}

int
S_IS_DEBUG (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  if (s->bsym->flags & BSF_DEBUGGING)
    return 1;
  return 0;
}

int
S_IS_LOCAL (symbolS *s)
{
  flagword flags;
  const char *name;

  if (LOCAL_SYMBOL_CHECK (s))
    return 1;

  flags = s->bsym->flags;

  /* Sanity check.  */
  if ((flags & BSF_LOCAL) && (flags & BSF_GLOBAL))
    abort ();

  if (bfd_get_section (s->bsym) == reg_section)
    return 1;

  if (flag_strip_local_absolute
      && (flags & BSF_GLOBAL) == 0
      && bfd_get_section (s->bsym) == absolute_section)
    return 1;

  name = S_GET_NAME (s);
  return (name != NULL
	  && ! S_IS_DEBUG (s)
	  && (strchr (name, DOLLAR_LABEL_CHAR)
	      || strchr (name, LOCAL_LABEL_CHAR)
	      || (! flag_keep_locals
		  && (bfd_is_local_label (stdoutput, s->bsym)
		      || (flag_mri
			  && name[0] == '?'
			  && name[1] == '?')))));
}

int
S_IS_EXTERN (symbolS *s)
{
  return S_IS_EXTERNAL (s);
}

int
S_IS_STABD (symbolS *s)
{
  return S_GET_NAME (s) == 0;
}

const char *
S_GET_NAME (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_name;
  return s->bsym->name;
}

segT
S_GET_SEGMENT (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_section;
  return s->bsym->section;
}

void
S_SET_SEGMENT (symbolS *s, segT seg)
{
  /* Don't reassign section symbols.  The direct reason is to prevent seg
     faults assigning back to const global symbols such as *ABS*, but it
     shouldn't happen anyway.  */

  if (LOCAL_SYMBOL_CHECK (s))
    {
      if (seg == reg_section)
	s = local_symbol_convert ((struct local_symbol *) s);
      else
	{
	  ((struct local_symbol *) s)->lsy_section = seg;
	  return;
	}
    }

  if (s->bsym->flags & BSF_SECTION_SYM)
    {
      if (s->bsym->section != seg)
	abort ();
    }
  else
    s->bsym->section = seg;
}

void
S_SET_EXTERNAL (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  if ((s->bsym->flags & BSF_WEAK) != 0)
    {
      /* Let .weak override .global.  */
      return;
    }
  if (s->bsym->flags & BSF_SECTION_SYM)
    {
      char * file;
      unsigned int line;

      /* Do not reassign section symbols.  */
      as_where (& file, & line);
      as_warn_where (file, line,
		     _("section symbols are already global"));
      return;
    }
  s->bsym->flags |= BSF_GLOBAL;
  s->bsym->flags &= ~(BSF_LOCAL | BSF_WEAK);
}

void
S_CLEAR_EXTERNAL (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  if ((s->bsym->flags & BSF_WEAK) != 0)
    {
      /* Let .weak override.  */
      return;
    }
  s->bsym->flags |= BSF_LOCAL;
  s->bsym->flags &= ~(BSF_GLOBAL | BSF_WEAK);
}

void
S_SET_WEAK (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->bsym->flags |= BSF_WEAK;
  s->bsym->flags &= ~(BSF_GLOBAL | BSF_LOCAL);
}

void
S_SET_THREAD_LOCAL (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  if (bfd_is_com_section (s->bsym->section)
      && (s->bsym->flags & BSF_THREAD_LOCAL) != 0)
    return;
  s->bsym->flags |= BSF_THREAD_LOCAL;
  if ((s->bsym->flags & BSF_FUNCTION) != 0)
    as_bad (_("Accessing function `%s' as thread-local object"),
	    S_GET_NAME (s));
  else if (! bfd_is_und_section (s->bsym->section)
	   && (s->bsym->section->flags & SEC_THREAD_LOCAL) == 0)
    as_bad (_("Accessing `%s' as thread-local object"),
	    S_GET_NAME (s));
}

void
S_SET_NAME (symbolS *s, char *name)
{
  if (LOCAL_SYMBOL_CHECK (s))
    {
      ((struct local_symbol *) s)->lsy_name = name;
      return;
    }
  s->bsym->name = name;
}
#endif /* BFD_ASSEMBLER */

#ifdef SYMBOLS_NEED_BACKPOINTERS

/* Return the previous symbol in a chain.  */

symbolS *
symbol_previous (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    abort ();
  return s->sy_previous;
}

#endif /* SYMBOLS_NEED_BACKPOINTERS */

/* Return the next symbol in a chain.  */

symbolS *
symbol_next (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    abort ();
  return s->sy_next;
}

/* Return a pointer to the value of a symbol as an expression.  */

expressionS *
symbol_get_value_expression (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return &s->sy_value;
}

/* Set the value of a symbol to an expression.  */

void
symbol_set_value_expression (symbolS *s, const expressionS *exp)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_value = *exp;
}

/* Set the value of SYM to the current position in the current segment.  */

void
symbol_set_value_now (symbolS *sym)
{
  S_SET_SEGMENT (sym, now_seg);
  S_SET_VALUE (sym, frag_now_fix ());
  symbol_set_frag (sym, frag_now);
}

/* Set the frag of a symbol.  */

void
symbol_set_frag (symbolS *s, fragS *f)
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    {
      local_symbol_set_frag ((struct local_symbol *) s, f);
      return;
    }
#endif
  s->sy_frag = f;
}

/* Return the frag of a symbol.  */

fragS *
symbol_get_frag (symbolS *s)
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    return local_symbol_get_frag ((struct local_symbol *) s);
#endif
  return s->sy_frag;
}

/* Mark a symbol as having been used.  */

void
symbol_mark_used (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_used = 1;
}

/* Clear the mark of whether a symbol has been used.  */

void
symbol_clear_used (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_used = 0;
}

/* Return whether a symbol has been used.  */

int
symbol_used_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 1;
  return s->sy_used;
}

/* Mark a symbol as having been used in a reloc.  */

void
symbol_mark_used_in_reloc (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_used_in_reloc = 1;
}

/* Clear the mark of whether a symbol has been used in a reloc.  */

void
symbol_clear_used_in_reloc (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_used_in_reloc = 0;
}

/* Return whether a symbol has been used in a reloc.  */

int
symbol_used_in_reloc_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_used_in_reloc;
}

/* Mark a symbol as an MRI common symbol.  */

void
symbol_mark_mri_common (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_mri_common = 1;
}

/* Clear the mark of whether a symbol is an MRI common symbol.  */

void
symbol_clear_mri_common (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_mri_common = 0;
}

/* Return whether a symbol is an MRI common symbol.  */

int
symbol_mri_common_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_mri_common;
}

/* Mark a symbol as having been written.  */

void
symbol_mark_written (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->written = 1;
}

/* Clear the mark of whether a symbol has been written.  */

void
symbol_clear_written (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->written = 0;
}

/* Return whether a symbol has been written.  */

int
symbol_written_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->written;
}

/* Mark a symbol has having been resolved.  */

void
symbol_mark_resolved (symbolS *s)
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    {
      local_symbol_mark_resolved ((struct local_symbol *) s);
      return;
    }
#endif
  s->sy_resolved = 1;
}

/* Return whether a symbol has been resolved.  */

int
symbol_resolved_p (symbolS *s)
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    return local_symbol_resolved_p ((struct local_symbol *) s);
#endif
  return s->sy_resolved;
}

/* Return whether a symbol is a section symbol.  */

int
symbol_section_p (symbolS *s ATTRIBUTE_UNUSED)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
#ifdef BFD_ASSEMBLER
  return (s->bsym->flags & BSF_SECTION_SYM) != 0;
#else
  /* FIXME.  */
  return 0;
#endif
}

/* Return whether a symbol is equated to another symbol.  */

int
symbol_equated_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_value.X_op == O_symbol;
}

/* Return whether a symbol is equated to another symbol, and should be
   treated specially when writing out relocs.  */

int
symbol_equated_reloc_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  /* X_op_symbol, normally not used for O_symbol, is set by
     resolve_symbol_value to flag expression syms that have been
     equated.  */
  return (s->sy_value.X_op == O_symbol
	  && ((s->sy_resolved && s->sy_value.X_op_symbol != NULL)
	      || ! S_IS_DEFINED (s)
	      || S_IS_COMMON (s)));
}

/* Return whether a symbol has a constant value.  */

int
symbol_constant_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 1;
  return s->sy_value.X_op == O_constant;
}

#ifdef BFD_ASSEMBLER

/* Return the BFD symbol for a symbol.  */

asymbol *
symbol_get_bfdsym (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return s->bsym;
}

/* Set the BFD symbol for a symbol.  */

void
symbol_set_bfdsym (symbolS *s, asymbol *bsym)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->bsym = bsym;
}

#endif /* BFD_ASSEMBLER */

#ifdef OBJ_SYMFIELD_TYPE

/* Get a pointer to the object format information for a symbol.  */

OBJ_SYMFIELD_TYPE *
symbol_get_obj (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return &s->sy_obj;
}

/* Set the object format information for a symbol.  */

void
symbol_set_obj (symbolS *s, OBJ_SYMFIELD_TYPE *o)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_obj = *o;
}

#endif /* OBJ_SYMFIELD_TYPE */

#ifdef TC_SYMFIELD_TYPE

/* Get a pointer to the processor information for a symbol.  */

TC_SYMFIELD_TYPE *
symbol_get_tc (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return &s->sy_tc;
}

/* Set the processor information for a symbol.  */

void
symbol_set_tc (symbolS *s, TC_SYMFIELD_TYPE *o)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_tc = *o;
}

#endif /* TC_SYMFIELD_TYPE */

void
symbol_begin (void)
{
  symbol_lastP = NULL;
  symbol_rootP = NULL;		/* In case we have 0 symbols (!!)  */
  sy_hash = hash_new ();
#ifdef BFD_ASSEMBLER
  local_hash = hash_new ();
#endif

  memset ((char *) (&abs_symbol), '\0', sizeof (abs_symbol));
#ifdef BFD_ASSEMBLER
#if defined (EMIT_SECTION_SYMBOLS) || !defined (RELOC_REQUIRES_SYMBOL)
  abs_symbol.bsym = bfd_abs_section.symbol;
#endif
#else
  /* Can't initialise a union. Sigh.  */
  S_SET_SEGMENT (&abs_symbol, absolute_section);
#endif
  abs_symbol.sy_value.X_op = O_constant;
  abs_symbol.sy_frag = &zero_address_frag;

  if (LOCAL_LABELS_FB)
    fb_label_init ();
}

int indent_level;

/* Maximum indent level.
   Available for modification inside a gdb session.  */
int max_indent_level = 8;

#if 0

static void
indent (void)
{
  printf ("%*s", indent_level * 4, "");
}

#endif

void
print_symbol_value_1 (FILE *file, symbolS *sym)
{
  const char *name = S_GET_NAME (sym);
  if (!name || !name[0])
    name = "(unnamed)";
  fprintf (file, "sym %lx %s", (unsigned long) sym, name);

  if (LOCAL_SYMBOL_CHECK (sym))
    {
#ifdef BFD_ASSEMBLER
      struct local_symbol *locsym = (struct local_symbol *) sym;
      if (local_symbol_get_frag (locsym) != &zero_address_frag
	  && local_symbol_get_frag (locsym) != NULL)
	fprintf (file, " frag %lx", (long) local_symbol_get_frag (locsym));
      if (local_symbol_resolved_p (locsym))
	fprintf (file, " resolved");
      fprintf (file, " local");
#endif
    }
  else
    {
      if (sym->sy_frag != &zero_address_frag)
	fprintf (file, " frag %lx", (long) sym->sy_frag);
      if (sym->written)
	fprintf (file, " written");
      if (sym->sy_resolved)
	fprintf (file, " resolved");
      else if (sym->sy_resolving)
	fprintf (file, " resolving");
      if (sym->sy_used_in_reloc)
	fprintf (file, " used-in-reloc");
      if (sym->sy_used)
	fprintf (file, " used");
      if (S_IS_LOCAL (sym))
	fprintf (file, " local");
      if (S_IS_EXTERN (sym))
	fprintf (file, " extern");
      if (S_IS_DEBUG (sym))
	fprintf (file, " debug");
      if (S_IS_DEFINED (sym))
	fprintf (file, " defined");
    }
  fprintf (file, " %s", segment_name (S_GET_SEGMENT (sym)));
  if (symbol_resolved_p (sym))
    {
      segT s = S_GET_SEGMENT (sym);

      if (s != undefined_section
	  && s != expr_section)
	fprintf (file, " %lx", (long) S_GET_VALUE (sym));
    }
  else if (indent_level < max_indent_level
	   && S_GET_SEGMENT (sym) != undefined_section)
    {
      indent_level++;
      fprintf (file, "\n%*s<", indent_level * 4, "");
#ifdef BFD_ASSEMBLER
      if (LOCAL_SYMBOL_CHECK (sym))
	fprintf (file, "constant %lx",
		 (long) ((struct local_symbol *) sym)->lsy_value);
      else
#endif
	print_expr_1 (file, &sym->sy_value);
      fprintf (file, ">");
      indent_level--;
    }
  fflush (file);
}

void
print_symbol_value (symbolS *sym)
{
  indent_level = 0;
  print_symbol_value_1 (stderr, sym);
  fprintf (stderr, "\n");
}

static void
print_binary (FILE *file, const char *name, expressionS *exp)
{
  indent_level++;
  fprintf (file, "%s\n%*s<", name, indent_level * 4, "");
  print_symbol_value_1 (file, exp->X_add_symbol);
  fprintf (file, ">\n%*s<", indent_level * 4, "");
  print_symbol_value_1 (file, exp->X_op_symbol);
  fprintf (file, ">");
  indent_level--;
}

void
print_expr_1 (FILE *file, expressionS *exp)
{
  fprintf (file, "expr %lx ", (long) exp);
  switch (exp->X_op)
    {
    case O_illegal:
      fprintf (file, "illegal");
      break;
    case O_absent:
      fprintf (file, "absent");
      break;
    case O_constant:
      fprintf (file, "constant %lx", (long) exp->X_add_number);
      break;
    case O_symbol:
      indent_level++;
      fprintf (file, "symbol\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_add_symbol);
      fprintf (file, ">");
    maybe_print_addnum:
      if (exp->X_add_number)
	fprintf (file, "\n%*s%lx", indent_level * 4, "",
		 (long) exp->X_add_number);
      indent_level--;
      break;
    case O_register:
      fprintf (file, "register #%d", (int) exp->X_add_number);
      break;
    case O_big:
      fprintf (file, "big");
      break;
    case O_uminus:
      fprintf (file, "uminus -<");
      indent_level++;
      print_symbol_value_1 (file, exp->X_add_symbol);
      fprintf (file, ">");
      goto maybe_print_addnum;
    case O_bit_not:
      fprintf (file, "bit_not");
      break;
    case O_multiply:
      print_binary (file, "multiply", exp);
      break;
    case O_divide:
      print_binary (file, "divide", exp);
      break;
    case O_modulus:
      print_binary (file, "modulus", exp);
      break;
    case O_left_shift:
      print_binary (file, "lshift", exp);
      break;
    case O_right_shift:
      print_binary (file, "rshift", exp);
      break;
    case O_bit_inclusive_or:
      print_binary (file, "bit_ior", exp);
      break;
    case O_bit_exclusive_or:
      print_binary (file, "bit_xor", exp);
      break;
    case O_bit_and:
      print_binary (file, "bit_and", exp);
      break;
    case O_eq:
      print_binary (file, "eq", exp);
      break;
    case O_ne:
      print_binary (file, "ne", exp);
      break;
    case O_lt:
      print_binary (file, "lt", exp);
      break;
    case O_le:
      print_binary (file, "le", exp);
      break;
    case O_ge:
      print_binary (file, "ge", exp);
      break;
    case O_gt:
      print_binary (file, "gt", exp);
      break;
    case O_logical_and:
      print_binary (file, "logical_and", exp);
      break;
    case O_logical_or:
      print_binary (file, "logical_or", exp);
      break;
    case O_add:
      indent_level++;
      fprintf (file, "add\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_add_symbol);
      fprintf (file, ">\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_op_symbol);
      fprintf (file, ">");
      goto maybe_print_addnum;
    case O_subtract:
      indent_level++;
      fprintf (file, "subtract\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_add_symbol);
      fprintf (file, ">\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_op_symbol);
      fprintf (file, ">");
      goto maybe_print_addnum;
    default:
      fprintf (file, "{unknown opcode %d}", (int) exp->X_op);
      break;
    }
  fflush (stdout);
}

void
print_expr (expressionS *exp)
{
  print_expr_1 (stderr, exp);
  fprintf (stderr, "\n");
}

void
symbol_print_statistics (FILE *file)
{
  hash_print_statistics (file, "symbol table", sy_hash);
#ifdef BFD_ASSEMBLER
  hash_print_statistics (file, "mini local symbol table", local_hash);
  fprintf (file, "%lu mini local symbols created, %lu converted\n",
	   local_symbol_count, local_symbol_conversion_count);
#endif
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d63 4
a66 4
static char *save_symbol_name PARAMS ((const char *));
static void fb_label_init PARAMS ((void));
static long dollar_label_instance PARAMS ((long));
static long fb_label_instance PARAMS ((long));
d68 2
a69 2
static void print_binary PARAMS ((FILE *, const char *, expressionS *));
static void report_op_error PARAMS ((symbolS *, symbolS *, symbolS *));
d81 1
a81 5
symbol_new (name, segment, valu, frag)
     const char *name;
     segT segment;
     valueT valu;
     fragS *frag;
d102 1
a102 2
save_symbol_name (name)
     const char *name;
d132 4
a135 5
symbol_create (name, segment, valu, frag)
     const char *name;		/* It is copied, the caller can destroy/modify.  */
     segT segment;		/* Segment identifier (SEG_<something>).  */
     valueT valu;		/* Symbol value.  */
     fragS *frag;		/* Associated fragment.  */
d179 1
a179 3
static struct local_symbol *local_symbol_make PARAMS ((const char *, segT,
						       valueT, fragS *));
static symbolS *local_symbol_convert PARAMS ((struct local_symbol *));
d200 2
a201 6
static struct local_symbol *
local_symbol_make (name, section, value, frag)
     const char *name;
     segT section;
     valueT value;
     fragS *frag;
d226 1
a226 2
local_symbol_convert (locsym)
     struct local_symbol *locsym;
d272 3
a274 3
colon (sym_name)		/* Just seen "x:" - rattle symbols & frags.  */
     const char *sym_name;	/* Symbol name, as a cannonical string.  */
     /* We copy this string: OK to alter later.  */
d505 1
a505 2
symbol_table_insert (symbolP)
     symbolS *symbolP;
d533 1
a533 2
symbol_find_or_make (name)
     const char *name;
d564 1
a564 2
symbol_make (name)
     const char *name;
d577 18
d601 1
a601 2
symbol_find (name)
     const char *name;
d611 1
a611 2
symbol_find_exact (name)
     const char *name;
d627 1
a627 3
symbol_find_base (name, strip_underscore)
     const char *name;
     int strip_underscore;
d671 2
a672 5
symbol_append (addme, target, rootPP, lastPP)
     symbolS *addme;
     symbolS *target;
     symbolS **rootPP;
     symbolS **lastPP;
d717 1
a717 2
symbol_clear_list_pointers (symbolP)
     symbolS *symbolP;
d731 1
a731 4
symbol_remove (symbolP, rootPP, lastPP)
     symbolS *symbolP;
     symbolS **rootPP;
     symbolS **lastPP;
d762 2
a763 5
symbol_insert (addme, target, rootPP, lastPP)
     symbolS *addme;
     symbolS *target;
     symbolS **rootPP;
     symbolS **lastPP ATTRIBUTE_UNUSED;
d790 1
a790 3
verify_symbol_chain (rootP, lastP)
     symbolS *rootP;
     symbolS *lastP;
d814 1
a814 2
verify_symbol_chain_2 (sym)
     symbolS *sym;
d827 1
a827 3
report_op_error (symp, left, right)
     symbolS *symp;
     symbolS *left, *right;
d886 1
a886 2
resolve_symbol_value (symp)
     symbolS *symp;
d1254 1
a1254 1
static void resolve_local_symbol PARAMS ((const char *, PTR));
d1259 1
a1259 3
resolve_local_symbol (key, value)
     const char *key ATTRIBUTE_UNUSED;
     PTR value;
d1270 1
a1270 1
resolve_local_symbol_values ()
d1291 1
a1291 2
dollar_label_defined (label)
     long label;
d1306 1
a1306 2
dollar_label_instance (label)
     long label;
d1322 1
a1322 1
dollar_label_clear ()
d1330 1
a1330 2
define_dollar_label (label)
     long label;
d1380 2
a1381 3
dollar_label_name (n, augend)
     register long n;		/* we just saw "n$:" : n a number.  */
     register int augend;	/* 0 for current instance, 1 for new instance.  */
d1424 1
a1424 1
/* Sombody else's idea of local labels. They are made by "n:" where n
d1453 1
a1453 1
fb_label_init ()
d1461 1
a1461 2
fb_label_instance_inc (label)
     long label;
d1509 1
a1509 2
fb_label_instance (label)
     long label;
d1547 2
a1548 3
fb_label_name (n, augend)
     long n;			/* We just saw "n:", "nf" or "nb" : n a number.  */
     long augend;		/* 0 for nb, 1 for n:, nf.  */
d1596 1
a1596 2
decode_local_label_name (s)
     char *s;
d1637 1
a1637 2
S_GET_VALUE (s)
     symbolS *s;
d1673 1
a1673 3
S_SET_VALUE (s, val)
     symbolS *s;
     valueT val;
d1689 1
a1689 2
copy_symbol_attributes (dest, src)
     symbolS *dest, *src;
d1711 1
a1711 2
S_IS_FUNCTION (s)
     symbolS *s;
d1724 1
a1724 2
S_IS_EXTERNAL (s)
     symbolS *s;
d1741 1
a1741 2
S_IS_WEAK (s)
     symbolS *s;
d1749 1
a1749 2
S_IS_COMMON (s)
     symbolS *s;
d1757 1
a1757 2
S_IS_DEFINED (s)
     symbolS *s;
d1773 1
a1773 3
S_FORCE_RELOC (s, strict)
     symbolS *s;
     int strict;
d1787 1
a1787 2
S_IS_DEBUG (s)
     symbolS *s;
d1797 1
a1797 2
S_IS_LOCAL (s)
     symbolS *s;
d1832 1
a1832 2
S_IS_EXTERN (s)
     symbolS *s;
d1838 1
a1838 2
S_IS_STABD (s)
     symbolS *s;
d1844 1
a1844 2
S_GET_NAME (s)
     symbolS *s;
d1852 1
a1852 2
S_GET_SEGMENT (s)
     symbolS *s;
d1860 1
a1860 3
S_SET_SEGMENT (s, seg)
     symbolS *s;
     segT seg;
d1887 1
a1887 2
S_SET_EXTERNAL (s)
     symbolS *s;
d1912 1
a1912 2
S_CLEAR_EXTERNAL (s)
     symbolS *s;
d1926 1
a1926 2
S_SET_WEAK (s)
     symbolS *s;
d1935 1
a1935 2
S_SET_THREAD_LOCAL (s)
     symbolS *s;
d1953 1
a1953 3
S_SET_NAME (s, name)
     symbolS *s;
     char *name;
d1969 1
a1969 2
symbol_previous (s)
     symbolS *s;
d1981 1
a1981 2
symbol_next (s)
     symbolS *s;
d1991 1
a1991 2
symbol_get_value_expression (s)
     symbolS *s;
d2001 1
a2001 3
symbol_set_value_expression (s, exp)
     symbolS *s;
     const expressionS *exp;
d2008 10
d2021 1
a2021 3
symbol_set_frag (s, f)
     symbolS *s;
     fragS *f;
d2036 1
a2036 2
symbol_get_frag (s)
     symbolS *s;
d2048 1
a2048 2
symbol_mark_used (s)
     symbolS *s;
d2058 1
a2058 2
symbol_clear_used (s)
     symbolS *s;
d2068 1
a2068 2
symbol_used_p (s)
     symbolS *s;
d2078 1
a2078 2
symbol_mark_used_in_reloc (s)
     symbolS *s;
d2088 1
a2088 2
symbol_clear_used_in_reloc (s)
     symbolS *s;
d2098 1
a2098 2
symbol_used_in_reloc_p (s)
     symbolS *s;
d2108 1
a2108 2
symbol_mark_mri_common (s)
     symbolS *s;
d2118 1
a2118 2
symbol_clear_mri_common (s)
     symbolS *s;
d2128 1
a2128 2
symbol_mri_common_p (s)
     symbolS *s;
d2138 1
a2138 2
symbol_mark_written (s)
     symbolS *s;
d2148 1
a2148 2
symbol_clear_written (s)
     symbolS *s;
d2158 1
a2158 2
symbol_written_p (s)
     symbolS *s;
d2168 1
a2168 2
symbol_mark_resolved (s)
     symbolS *s;
d2183 1
a2183 2
symbol_resolved_p (s)
     symbolS *s;
d2195 1
a2195 2
symbol_section_p (s)
     symbolS *s ATTRIBUTE_UNUSED;
d2210 1
a2210 2
symbol_equated_p (s)
     symbolS *s;
d2221 1
a2221 2
symbol_equated_reloc_p (s)
     symbolS *s;
d2237 1
a2237 2
symbol_constant_p (s)
     symbolS *s;
d2249 1
a2249 2
symbol_get_bfdsym (s)
     symbolS *s;
d2259 1
a2259 3
symbol_set_bfdsym (s, bsym)
     symbolS *s;
     asymbol *bsym;
d2273 1
a2273 2
symbol_get_obj (s)
     symbolS *s;
d2283 1
a2283 3
symbol_set_obj (s, o)
     symbolS *s;
     OBJ_SYMFIELD_TYPE *o;
d2297 1
a2297 2
symbol_get_tc (s)
     symbolS *s;
d2307 1
a2307 3
symbol_set_tc (s, o)
     symbolS *s;
     TC_SYMFIELD_TYPE *o;
d2317 1
a2317 1
symbol_begin ()
d2351 1
a2351 1
indent ()
d2359 1
a2359 3
print_symbol_value_1 (file, sym)
     FILE *file;
     symbolS *sym;
d2429 1
a2429 2
print_symbol_value (sym)
     symbolS *sym;
d2437 1
a2437 4
print_binary (file, name, exp)
     FILE *file;
     const char *name;
     expressionS *exp;
d2449 1
a2449 3
print_expr_1 (file, exp)
     FILE *file;
     expressionS *exp;
d2561 1
a2561 2
print_expr (exp)
     expressionS *exp;
d2568 1
a2568 2
symbol_print_statistics (file)
     FILE *file;
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   1999, 2000, 2001
a24 2
#include <ctype.h>

d27 1
d63 1
d69 1
d127 1
a127 1
      unsigned char *s;
d129 2
a130 3
      for (s = (unsigned char *) ret; *s != '\0'; s++)
	if (islower (*s))
	  *s = toupper (*s);
d209 1
a209 1
local_symbol_make (name, section, offset, frag)
d212 1
a212 1
     valueT offset;
d227 1
a227 1
  ret->lsy_offset = offset;
d249 1
a249 1
  ret = symbol_new (locsym->lsy_name, locsym->lsy_section, locsym->lsy_offset,
d258 4
d317 7
d367 1
a367 1
		  || locsym->lsy_offset != frag_now_fix ()))
d369 1
a369 1
	      as_bad (_("Symbol %s already defined."), sym_name);
d375 1
a375 1
	  locsym->lsy_offset = frag_now_fix ();
d450 3
a452 3
		    sprintf(od_buf, "%d.%d.",
			    S_GET_OTHER (symbolP),
			    S_GET_DESC (symbolP));
d454 1
a454 1
		  as_bad (_("Symbol \"%s\" is already defined as \"%s\"/%s%ld."),
d468 1
a468 1
	    as_bad (_("Symbol %s already defined."), sym_name);
d494 1
a494 1
         section.  This requires special handling.  */
d531 1
a531 1
	as_fatal (_("Inserting \"%s\" into symbol table failed: %s"),
d538 1
a538 1
      as_fatal (_("Inserting \"%s\" into symbol table failed: %s"),
d580 1
a580 1
     CONST char *name;
d600 1
a600 1
     CONST char *name;
d610 17
d628 1
a628 1
     CONST char *name;
d656 1
a656 3
	  if (islower (c))
	    c = toupper (c);
	  *copy++ = c;
d661 1
a661 11
#ifdef BFD_ASSEMBLER
  {
    struct local_symbol *locsym;

    locsym = (struct local_symbol *) hash_find (local_hash, name);
    if (locsym != NULL)
      return (symbolS *) locsym;
  }
#endif

  return ((symbolS *) hash_find (sy_hash, name));
d841 57
d903 1
a903 1
resolve_symbol_value (symp, finalize)
a904 1
     int finalize;
d907 1
a907 1
  valueT final_val;
d915 1
d917 1
a917 1
	return locsym->lsy_offset / bfd_octets_per_byte (stdoutput);
d919 1
a919 2
      final_val = (local_symbol_get_frag (locsym)->fr_address
		   + locsym->lsy_offset) / bfd_octets_per_byte (stdoutput);
d921 1
a921 1
      if (finalize)
d923 1
a923 1
	  locsym->lsy_offset = final_val;
d944 2
a945 2
      if (finalize)
	as_bad (_("Symbol definition loop encountered at %s"),
d984 5
a988 1
	  left = resolve_symbol_value (add_symbol, finalize);
a989 1

d993 2
a994 2
                 relocation routines are going to handle it specially.
                 Don't change the value.  */
d999 1
a999 1
	  if (finalize && final_val == 0)
d1007 6
a1012 6
	  /* If we have equated this symbol to an undefined symbol, we
             keep X_op set to O_symbol, and we don't change
             X_add_number.  This permits the routine which writes out
             relocation to detect this case, and convert the
             relocation to be against the symbol to which this symbol
             is equated.  */
d1015 1
a1015 1
	      if (finalize)
a1016 1
		  S_SET_SEGMENT (symp, S_GET_SEGMENT (add_symbol));
d1020 3
d1026 19
d1051 1
a1051 1
		final_seg = S_GET_SEGMENT (add_symbol);
d1060 13
a1072 1
	  left = resolve_symbol_value (add_symbol, finalize);
a1081 2
	  if (final_seg == expr_section || final_seg == undefined_section)
	    final_seg = absolute_section;
d1105 2
a1106 2
	  left = resolve_symbol_value (add_symbol, finalize);
	  right = resolve_symbol_value (op_symbol, finalize);
d1112 1
a1112 1
	  if (op == O_add || op == O_subtract)
d1116 1
a1116 6
		  if (op == O_add)
		    final_val += right;
		  else
		    final_val -= right;
		  op = O_symbol;
		  op_symbol = NULL;
d1119 1
a1119 1
	      else if (seg_left == absolute_section && op == O_add)
a1120 1
		  op = O_symbol;
d1124 1
a1124 1
		  op_symbol = NULL;
d1128 1
a1128 15

	  /* Subtraction is permitted if both operands are in the same
	     section.  Otherwise, both operands must be absolute.  We
	     already handled the case of addition or subtraction of a
	     constant above.  This will probably need to be changed
	     for an object file format which supports arbitrary
	     expressions, such as IEEE-695.  */
	  /* Don't emit messages unless we're finalizing the symbol value,
	     otherwise we may get the same message multiple times.  */
	  if ((seg_left != absolute_section
	       || seg_right != absolute_section)
	      && (op != O_subtract
		  || seg_left != seg_right
		  || seg_left == undefined_section)
	      && finalize)
d1130 1
a1130 4
	      char *file;
	      unsigned int line;

	      if (expr_symbol_where (symp, &file, &line))
d1132 2
a1133 27
		  if (seg_left == undefined_section)
		    as_bad_where (file, line,
				  _("undefined symbol %s in operation"),
				  S_GET_NAME (symp->sy_value.X_add_symbol));
		  if (seg_right == undefined_section)
		    as_bad_where (file, line,
				  _("undefined symbol %s in operation"),
				  S_GET_NAME (symp->sy_value.X_op_symbol));
		  if (seg_left != undefined_section
		      && seg_right != undefined_section)
		    as_bad_where (file, line,
				  _("invalid section for operation"));
		}
	      else
		{
		  if (seg_left == undefined_section)
		    as_bad (_("undefined symbol %s in operation setting %s"),
			    S_GET_NAME (symp->sy_value.X_add_symbol),
			    S_GET_NAME (symp));
		  if (seg_right == undefined_section)
		    as_bad (_("undefined symbol %s in operation setting %s"),
			    S_GET_NAME (symp->sy_value.X_op_symbol),
			    S_GET_NAME (symp));
		  if (seg_left != undefined_section
		      && seg_right != undefined_section)
		    as_bad (_("invalid section for operation setting %s"),
			    S_GET_NAME (symp));
d1137 24
d1165 2
a1166 2
                 already issued a warning about using a bad symbol.  */
	      if (seg_right == absolute_section && finalize)
d1174 1
a1174 1
		    as_bad (_("division by zero when setting %s"),
d1194 9
a1202 2
	    case O_eq:	left = left == right ? ~ (offsetT) 0 : 0; break;
	    case O_ne:	left = left != right ? ~ (offsetT) 0 : 0; break;
d1214 9
a1222 1
	    final_seg = absolute_section;
d1241 2
a1242 3
  if (finalize)
    {
      S_SET_VALUE (symp, final_val);
d1244 3
d1248 3
a1250 3
      /* The old a.out backend does not handle S_SET_SEGMENT correctly
         for a stab symbol, so we use this bad hack.  */
      if (final_seg != S_GET_SEGMENT (symp))
d1252 1
a1252 2
	S_SET_SEGMENT (symp, final_seg);
    }
a1253 1
exit_dont_set_value:
d1255 1
a1255 1
  if (finalize)
d1261 1
a1261 1
	  as_bad (_("can't resolve value for symbol \"%s\""),
d1282 1
a1282 1
    resolve_symbol_value (value, 1);
d1642 1
a1642 1
  for (label_number = 0, p = s + index + 1; isdigit ((unsigned char) *p); ++p)
d1652 1
a1652 1
  for (instance_number = 0, p++; isdigit ((unsigned char) *p); ++p)
d1670 1
a1670 1
    return ((struct local_symbol *) s)->lsy_offset;
d1673 6
a1678 2
  if (!s->sy_resolved && s->sy_value.X_op != O_constant)
    resolve_symbol_value (s, 1);
d1684 2
a1685 2
         may call S_GET_VALUE.  We use a static symbol to avoid the
         immediate recursion.  */
d1692 1
a1692 1
	as_bad (_("Attempt to get value of unresolved symbol %s"),
d1709 1
a1709 1
      ((struct local_symbol *) s)->lsy_offset = val;
d1801 24
d1886 1
a1886 1
CONST char *
d1948 1
a1948 1
      
d1952 1
a1952 1
		     _("Section symbols are already global"));
d1985 19
d2284 18
d2487 1
a2487 1
          && s != expr_section)
d2498 1
a2498 1
		 (long) ((struct local_symbol *) sym)->lsy_offset);
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d23 1
a23 1
/* #define DEBUG_SYMS / * to debug symbol list maintenance */
d48 1
a48 1
/* Below are commented in "symbols.h". */
d59 3
d70 1
a70 3
/* symbol_new()
  
   Return a pointer to a new symbol.  Die if we can't make a new
d73 1
a73 1
 
d88 1
a88 3
  /*
   * Link to end of symbol chain.
   */
d111 1
a111 1
  name_length = strlen (name) + 1;	/* +1 for \0 */
d138 4
a141 4
     const char *name;		/* It is copied, the caller can destroy/modify */
     segT segment;		/* Segment identifier (SEG_<something>) */
     valueT valu;		/* Symbol value */
     fragS *frag;		/* Associated fragment */
d150 1
a150 1
  /* symbol must be born in some fixed state.  This seems as good as any. */
d275 4
a279 9
/*
 *			colon()
 *
 * We have just seen "<name>:".
 * Creates a struct symbol unless it already exists.
 *
 * Gripes if we are redefining a symbol incompatibly (and ignores it).
 *
 */
d281 3
a283 3
colon (sym_name)		/* just seen "x:" - rattle symbols & frags */
     const char *sym_name;	/* symbol name, as a cannonical string */
     /* We copy this string: OK to alter later. */
d285 1
a285 1
  register symbolS *symbolP;	/* symbol we are working with */
d325 3
a327 3
      /* We want to store the pointer to where to insert the jump table in the
	 fr_opcode of the rs_broken_word frag.  This requires a little
	 hackery.  */
d347 1
a347 3
      /*
       *	Now check for undefined symbols
       */
d373 1
a373 1
	      S_SET_OTHER(symbolP, const_flag);
d379 1
a379 1
#endif /* if we have one, it better be zero. */
d384 10
a393 10
	      /*
	       *	There are still several cases to check:
	       *		A .comm/.lcomm symbol being redefined as
	       *			initialized data is OK
	       *		A .comm/.lcomm symbol being redefined with
	       *			a larger size is also OK
	       *
	       * This only used to be allowed on VMS gas, but Sun cc
	       * on the sparc also depends on it.
	       */
d402 1
a402 3
		  /*
		   *	Select which of the 2 cases this is
		   */
d405 5
a409 6
		      /*
		       *   New .comm for prev .comm symbol.
		       *	If the new size is larger we just
		       *	change its value.  If the new size
		       *	is smaller, we ignore this symbol
		       */
d422 1
a422 1
		      S_SET_OTHER(symbolP, const_flag);
d425 1
a425 1
		      S_SET_SEGMENT (symbolP, now_seg);	/* keep N_EXT bit */
d443 1
a443 1
		  as_fatal (_("Symbol \"%s\" is already defined as \"%s\"/%s%ld."),
d449 1
a449 1
	    }			/* if the undefined symbol has no value */
d453 1
a453 1
	  /* Don't blow up if the definition is the same */
d457 2
a458 2
	    as_fatal (_("Symbol %s already defined."), sym_name);
	}			/* if this symbol is not yet defined */
d478 1
a478 1
    }				/* if we have seen this symbol before */
d504 1
d506 1
a506 8
/*
 *			symbol_table_insert()
 *
 * Die if we can't insert the symbol.
 *
 */

void 
d529 2
a530 2
    }				/* on error */
}				/* symbol_table_insert() */
d532 3
a534 6
/*
 *			symbol_find_or_make()
 *
 * If a symbol name does not exist, create it as undefined, and insert
 * it into the symbol table. Return a pointer to it.
 */
d565 1
a565 1
}				/* symbol_find_or_make() */
d573 1
a573 1
  /* Let the machine description default it, e.g. for register names. */
d580 1
a580 1
}				/* symbol_make() */
d582 4
a585 8
/*
 *			symbol_find()
 *
 * Implement symbol table lookup.
 * In:	A symbol's name as a string: '\0' can't be part of a symbol name.
 * Out:	NULL if the name was not in the symbol table, else the address
 *	of a struct symbol associated with that name.
 */
d596 1
a596 1
}				/* symbol_find() */
d648 5
a652 7
/*
 * Once upon a time, symbols were kept in a singly linked list.  At
 * least coff needs to be able to rearrange them from time to time, for
 * which a doubly linked list is much more convenient.  Loic did these
 * as macros which seemed dangerous to me so they're now functions.
 * xoxorich.
 */
d654 3
a656 2
/* Link symbol ADDME after symbol TARGET in the chain. */
void 
d679 1
a679 1
    }				/* if the list is empty */
d691 1
a691 1
    }				/* if we have a next */
d703 3
a705 2
/* Set the chain pointers of SYMBOL to null. */
void 
d718 3
a720 2
/* Remove SYMBOLP from the list. */
void 
d732 1
a732 1
    }				/* if it was the root */
d737 1
a737 1
    }				/* if it was the tail */
d742 1
a742 1
    }				/* if not last */
d747 1
a747 1
    }				/* if not first */
d752 3
a754 2
/* Link symbol ADDME before symbol TARGET in the chain. */
void 
d774 1
a774 1
    }				/* if not first */
d785 1
a785 1
void 
d844 1
a844 1
	return locsym->lsy_offset / OCTETS_PER_BYTE;
d847 1
a847 1
		   + locsym->lsy_offset) / OCTETS_PER_BYTE;
d873 2
a874 1
	as_bad (_("Symbol definition loop encountered at %s"), S_GET_NAME (symp));
d1059 2
a1060 1
		    as_bad_where (file, line, _("invalid section for operation"));
d1128 1
a1128 1
   	  break;
d1164 2
a1165 1
	  as_bad (_("can't resolve value for symbol \"%s\""), S_GET_NAME (symp));
d1213 1
a1213 1
int 
d1225 1
a1225 1
  /* if we get here, label isn't defined */
d1227 1
a1227 1
}				/* dollar_label_defined() */
d1241 2
a1242 2
  /* If we get here, we haven't seen the label before, therefore its instance
     count is zero.  */
d1246 1
a1246 1
void 
d1254 1
a1254 1
void 
d1268 1
a1268 1
  /* if we get to here, we don't have label listed yet. */
d1286 1
a1286 1
    }				/* if we needed to grow */
d1294 7
a1300 13
/*
 *			dollar_label_name()
 *
 * Caller must copy returned name: we re-use the area for the next name.
 *
 * The mth occurence of label n: is turned into the symbol "Ln^Am"
 * where n is the label number and m is the instance number. "L" makes
 * it a label discarded unless debugging and "^A"('\1') ensures no
 * ordinary symbol SHOULD get the same name as a local label
 * symbol. The first "4:" is "L4^A1" - the m numbers begin at 1.
 *
 * fb labels get the same treatment, except that ^B is used in place of ^A.
 */
d1302 4
a1305 1
char *				/* Return local label name. */
d1307 2
a1308 2
     register long n;		/* we just saw "n$:" : n a number */
     register int augend;	/* 0 for current instance, 1 for new instance */
d1311 1
a1311 1
  /* Returned to caller, then copied.  used for created names ("4f") */
d1315 1
a1315 1
  char symbol_name_temporary[20];	/* build up a number, BACKWARDS */
d1325 2
a1326 2
  /* Next code just does sprintf( {}, "%d", n); */
  /* label number */
d1336 1
a1336 1
  *p++ = 1;			/* ^A */
d1338 1
a1338 1
  /* instance number */
d1347 1
a1347 1
  /* The label, as a '\0' ended string, starts at symbol_name_build. */
d1351 16
a1366 17
/*
 * Sombody else's idea of local labels. They are made by "n:" where n
 * is any decimal digit. Refer to them with
 *  "nb" for previous (backward) n:
 *  or "nf" for next (forward) n:.
 *
 * We do a little better and let n be any number, not just a single digit, but
 * since the other guy's assembler only does ten, we treat the first ten
 * specially.
 *
 * Like someone else's assembler, we have one set of local label counters for
 * entire assembly, not one set per (sub)segment like in most assemblers. This
 * implies that one can refer to a label in another segment, and indeed some
 * crufty compilers have done just that.
 *
 * Since there could be a LOT of these things, treat them as a sparse array.
 */
d1376 1
a1376 1
/* this must be more than FB_LABEL_SPECIAL */
d1379 1
a1379 1
static void 
d1383 3
a1385 1
}				/* fb_label_init() */
d1387 1
a1387 2
/* add one to the instance number of this fb label */
void 
d1408 2
a1409 2
	    }			/* if we find it */
	}			/* for each existing label */
d1412 1
a1412 1
  /* if we get to here, we don't have label listed yet. */
d1429 1
a1429 1
    }				/* if we needed to grow */
d1436 1
a1436 1
static long 
d1455 2
a1456 2
	    }			/* if we find it */
	}			/* for each existing label */
d1464 1
a1464 12
/*
 *			fb_label_name()
 *
 * Caller must copy returned name: we re-use the area for the next name.
 *
 * The mth occurence of label n: is turned into the symbol "Ln^Bm"
 * where n is the label number and m is the instance number. "L" makes
 * it a label discarded unless debugging and "^B"('\2') ensures no
 * ordinary symbol SHOULD get the same name as a local label
 * symbol. The first "4:" is "L4^B1" - the m numbers begin at 1.
 *
 * dollar labels get the same treatment, except that ^A is used in place of ^B. */
d1466 10
a1475 1
char *				/* Return local label name. */
d1477 2
a1478 2
     long n;			/* we just saw "n:", "nf" or "nb" : n a number */
     long augend;		/* 0 for nb, 1 for n:, nf */
d1481 1
a1481 1
  /* Returned to caller, then copied.  used for created names ("4f") */
d1485 1
a1485 1
  char symbol_name_temporary[20];	/* build up a number, BACKWARDS */
d1490 3
d1495 2
a1496 2
  /* Next code just does sprintf( {}, "%d", n); */
  /* label number */
d1506 1
a1506 1
  *p++ = 2;			/* ^B */
d1508 1
a1508 1
  /* instance number */
d1517 1
a1517 1
  /* The label, as a '\0' ended string, starts at symbol_name_build. */
d1519 1
a1519 1
}				/* fb_label_name() */
d1521 3
a1523 5
/*
 * decode name that may have been generated by foo_label_name() above.  If
 * the name wasn't generated by foo_label_name(), then return it unaltered.
 * This is used for error messages.
 */
d1534 2
a1535 1
  const char *message_format = _("\"%d\" (instance number %d of a %s label)");
d1537 6
a1542 1
  if (s[0] != 'L')
d1545 1
a1545 1
  for (label_number = 0, p = s + 1; isdigit ((unsigned char) *p); ++p)
d1548 1
a1548 1
  if (*p == 1)
d1550 1
a1550 1
  else if (*p == 2)
d1558 1
d1666 1
a1666 1
  /* sanity check */
d1723 1
a1723 1
  /* sanity check */
d1738 2
a1739 2
	  && (strchr (name, '\001')
	      || strchr (name, '\002')
d1802 1
a1802 1
	abort();
d1819 11
d1831 1
a1831 1
  s->bsym->flags &= ~(BSF_LOCAL|BSF_WEAK);
d1846 1
a1846 1
  s->bsym->flags &= ~(BSF_GLOBAL|BSF_WEAK);
d1856 1
a1856 1
  s->bsym->flags &= ~(BSF_GLOBAL|BSF_LOCAL);
d2124 1
a2124 1
  /* FIXME */
d2236 1
a2236 1
  symbol_rootP = NULL;		/* In case we have 0 symbols (!!) */
d2248 1
a2248 1
  /* Can't initialise a union. Sigh. */
a2256 2


d2358 1
a2358 1
     const char * name;
a2502 2

/* end of symbols.c */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 2
d44 3
d61 4
a96 1
  debug_verify_symchain (symbol_rootP, symbol_lastP);
d101 6
a106 6
symbolS *
symbol_create (name, segment, valu, frag)
     const char *name;		/* It is copied, the caller can destroy/modify */
     segT segment;		/* Segment identifier (SEG_<something>) */
     valueT valu;		/* Symbol value */
     fragS *frag;		/* Associated fragment */
d109 1
a109 2
  char *preserved_copy_of_name;
  symbolS *symbolP;
d113 2
a114 1
  preserved_copy_of_name = obstack_finish (&notes);
d116 2
a117 2
  if (preserved_copy_of_name[0] == '_')
    preserved_copy_of_name++;
d121 1
a121 2
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
d128 1
a128 1
      for (s = (unsigned char *) preserved_copy_of_name; *s != '\0'; s++)
d133 15
d180 95
d294 13
a306 2
  if (LOCAL_LABELS_DOLLAR && ! LOCAL_LABEL (sym_name))
    dollar_label_clear ();
d327 1
a327 1
			      0L,
d355 20
a374 1
      if (!S_IS_DEFINED (symbolP))
d403 1
a403 1
		    && !S_IS_DEFINED (symbolP)
d440 3
a442 6
#if defined (S_GET_OTHER) && defined (S_GET_DESC)
		  as_fatal ("Symbol \"%s\" is already defined as \"%s\"/%d.%d.%ld.",
			    sym_name,
			    segment_name (S_GET_SEGMENT (symbolP)),
			    S_GET_OTHER (symbolP), S_GET_DESC (symbolP),
			    (long) S_GET_VALUE (symbolP));
d444 10
a453 1
		  as_fatal ("Symbol \"%s\" is already defined as \"%s\"/%ld.",
d456 1
a457 1
#endif
d467 1
a467 1
	    as_fatal ("Symbol %s already defined.", sym_name);
d471 8
d494 2
d507 3
d531 10
d543 1
a543 1
      as_fatal ("Inserting \"%s\" into symbol table failed: %s",
d564 14
d632 1
d634 2
a635 2
    copy = (char *) alloca (strlen (name) + 1);
    strcpy (copy, name);
d642 6
a647 1
      unsigned char *copy;
d649 7
a655 5
      copy = (unsigned char *) alloca (strlen (name) + 1);
      name = (const char *) copy;
      for (; *copy != '\0'; copy++)
	if (islower (*copy))
	  *copy = toupper (*copy);
d658 10
d687 5
d696 4
d723 2
d732 2
d748 3
d780 1
a780 1
     symbolS **lastPP;
d782 5
d818 3
d822 1
a822 1
      know (symbolP->sy_next->sy_previous == symbolP);
d850 2
a851 2
void
resolve_symbol_value (symp)
d853 1
d856 23
d881 6
a886 1
    return;
d889 1
d893 3
a895 3
      as_bad ("Symbol definition loop encountered at %s",
	      S_GET_NAME (symp));
      S_SET_VALUE (symp, (valueT) 0);
d900 2
a901 1
      offsetT left, right, val;
d903 1
d907 7
a913 4
      /* Simplify addition or subtraction of a constant by folding the
         constant into X_add_number.  */
      if (symp->sy_value.X_op == O_add
	  || symp->sy_value.X_op == O_subtract)
d915 3
a917 23
	  resolve_symbol_value (symp->sy_value.X_add_symbol);
	  resolve_symbol_value (symp->sy_value.X_op_symbol);
	  if (S_GET_SEGMENT (symp->sy_value.X_op_symbol) == absolute_section)
	    {
	      right = S_GET_VALUE (symp->sy_value.X_op_symbol);
	      if (symp->sy_value.X_op == O_add)
		symp->sy_value.X_add_number += right;
	      else
		symp->sy_value.X_add_number -= right;
	      symp->sy_value.X_op = O_symbol;
	      symp->sy_value.X_op_symbol = NULL;
	    }
	  else if ((S_GET_SEGMENT (symp->sy_value.X_add_symbol)
		    == absolute_section)
		   && symp->sy_value.X_op == O_add)
	    {
	      left = S_GET_VALUE (symp->sy_value.X_add_symbol);
	      symp->sy_value.X_add_symbol = symp->sy_value.X_op_symbol;
	      symp->sy_value.X_add_number += left;
	      symp->sy_value.X_op = O_symbol;
	      symp->sy_value.X_op_symbol = NULL;
	    }
	}
a918 2
      switch (symp->sy_value.X_op)
	{
d920 1
a920 1
	  S_SET_VALUE (symp, 0);
d922 1
d924 3
a926 3
	  S_SET_VALUE (symp, S_GET_VALUE (symp) + symp->sy_frag->fr_address);
	  if (S_GET_SEGMENT (symp) == expr_section)
	    S_SET_SEGMENT (symp, absolute_section);
d931 3
a933 1
	  resolve_symbol_value (symp->sy_value.X_add_symbol);
d940 1
a940 2
	      S_SET_VALUE (symp, symp->sy_value.X_add_number);
	      resolved = symp->sy_value.X_add_symbol->sy_resolved;
d944 7
a950 11
	  if (symp->sy_value.X_add_number == 0)
	    copy_symbol_attributes (symp, symp->sy_value.X_add_symbol);

	  S_SET_VALUE (symp,
		       (symp->sy_value.X_add_number
			+ symp->sy_frag->fr_address
			+ S_GET_VALUE (symp->sy_value.X_add_symbol)));
	  if (S_GET_SEGMENT (symp) == expr_section
	      || S_GET_SEGMENT (symp) == undefined_section)
	    S_SET_SEGMENT (symp,
			   S_GET_SEGMENT (symp->sy_value.X_add_symbol));
d953 24
a976 6
             keep X_op set to O_symbol.  This permits the routine
             which writes out relocation to detect this case, and
             convert the relocation to be against the symbol to which
             this symbol is equated.  */
	  if (! S_IS_DEFINED (symp) || S_IS_COMMON (symp))
	    symp->sy_value.X_op = O_symbol;
d978 1
a978 1
	  resolved = symp->sy_value.X_add_symbol->sy_resolved;
d984 6
a989 5
	  resolve_symbol_value (symp->sy_value.X_add_symbol);
	  if (symp->sy_value.X_op == O_uminus)
	    val = - S_GET_VALUE (symp->sy_value.X_add_symbol);
	  else if (symp->sy_value.X_op == O_logical_not)
	    val = ! S_GET_VALUE (symp->sy_value.X_add_symbol);
d991 7
a997 9
	    val = ~ S_GET_VALUE (symp->sy_value.X_add_symbol);
	  S_SET_VALUE (symp,
		       (val
			+ symp->sy_value.X_add_number
			+ symp->sy_frag->fr_address));
	  if (S_GET_SEGMENT (symp) == expr_section
	      || S_GET_SEGMENT (symp) == undefined_section)
	    S_SET_SEGMENT (symp, absolute_section);
	  resolved = symp->sy_value.X_add_symbol->sy_resolved;
d1019 29
a1047 6
	  resolve_symbol_value (symp->sy_value.X_add_symbol);
	  resolve_symbol_value (symp->sy_value.X_op_symbol);
	  seg_left = S_GET_SEGMENT (symp->sy_value.X_add_symbol);
	  seg_right = S_GET_SEGMENT (symp->sy_value.X_op_symbol);
	  left = S_GET_VALUE (symp->sy_value.X_add_symbol);
	  right = S_GET_VALUE (symp->sy_value.X_op_symbol);
d1055 2
d1059 4
a1062 2
	      && (symp->sy_value.X_op != O_subtract
		  || seg_left != seg_right))
d1069 5
a1073 2
		  if (seg_left == undefined_section
		      || seg_right == undefined_section)
d1075 5
a1079 6
				  "undefined symbol %s in operation",
				  (seg_left == undefined_section
				   ? S_GET_NAME (symp->sy_value.X_add_symbol)
				   : S_GET_NAME (symp->sy_value.X_op_symbol)));
		  else
		    as_bad_where (file, line, "invalid section for operation");
d1083 7
a1089 6
		  if (seg_left == undefined_section
		      || seg_right == undefined_section)
		    as_bad ("undefined symbol %s in operation setting %s",
			    (seg_left == undefined_section
			     ? S_GET_NAME (symp->sy_value.X_add_symbol)
			     : S_GET_NAME (symp->sy_value.X_op_symbol)),
d1091 19
d1111 1
a1111 1
		    as_bad ("invalid section for operation setting %s",
d1114 2
d1120 20
a1139 20
	    case O_multiply:		val = left * right; break;
	    case O_divide:		val = left / right; break;
	    case O_modulus:		val = left % right; break;
	    case O_left_shift:		val = left << right; break;
	    case O_right_shift:		val = left >> right; break;
	    case O_bit_inclusive_or:	val = left | right; break;
	    case O_bit_or_not:		val = left |~ right; break;
	    case O_bit_exclusive_or:	val = left ^ right; break;
	    case O_bit_and:		val = left & right; break;
	    case O_add:			val = left + right; break;
	    case O_subtract:		val = left - right; break;
	    case O_eq:		val = left == right ? ~ (offsetT) 0 : 0;
	    case O_ne:		val = left != right ? ~ (offsetT) 0 : 0;
	    case O_lt:		val = left <  right ? ~ (offsetT) 0 : 0;
	    case O_le:		val = left <= right ? ~ (offsetT) 0 : 0;
	    case O_ge:		val = left >= right ? ~ (offsetT) 0 : 0;
	    case O_gt:		val = left >  right ? ~ (offsetT) 0 : 0;
	    case O_logical_and:	val = left && right; break;
	    case O_logical_or:	val = left || right; break;
	    default:			abort ();
d1141 6
a1146 9
	  S_SET_VALUE (symp,
		       (symp->sy_value.X_add_number
			+ symp->sy_frag->fr_address
			+ val));
	  if (S_GET_SEGMENT (symp) == expr_section
	      || S_GET_SEGMENT (symp) == undefined_section)
	    S_SET_SEGMENT (symp, absolute_section);
	  resolved = (symp->sy_value.X_add_symbol->sy_resolved
		      && symp->sy_value.X_op_symbol->sy_resolved);
d1159 14
d1175 1
d1177 1
a1177 3
  if (resolved)
    symp->sy_resolved = 1;
  else if (S_GET_SEGMENT (symp) != expr_section)
d1179 7
a1185 2
      as_bad ("can't resolve value for symbol \"%s\"", S_GET_NAME (symp));
      symp->sy_resolved = 1;
d1187 29
d1228 1
a1228 1
static long dollar_label_count;
d1247 1
a1247 1
static int 
d1341 3
d1556 1
a1556 1
  const char *message_format = "\"%d\" (instance number %d of a %s label)";
d1561 1
a1561 1
  for (label_number = 0, p = s + 1; isdigit (*p); ++p)
d1571 1
a1571 1
  for (instance_number = 0, p++; isdigit (*p); ++p)
d1586 7
a1592 2
  if (!s->sy_resolved && !s->sy_resolving && s->sy_value.X_op != O_constant)
    resolve_symbol_value (s);
d1606 1
a1606 1
	as_bad ("Attempt to get value of unresolved symbol %s",
d1620 8
d1637 5
d1645 1
a1645 1
#define COPIED_SYMFLAGS	(BSF_FUNCTION)
d1657 14
d1674 6
a1679 1
  flagword flags = s->bsym->flags;
d1682 1
a1682 1
  if (flags & BSF_LOCAL && flags & BSF_GLOBAL)
d1692 2
d1701 2
d1710 2
d1719 2
d1730 1
a1730 1
  flagword flags = s->bsym->flags;
d1733 5
d1739 1
a1739 1
  if (flags & BSF_LOCAL && flags & BSF_GLOBAL)
d1745 5
d1756 1
a1756 1
		  && (LOCAL_LABEL (name)
d1780 2
d1789 2
d1799 22
a1820 1
  s->bsym->section = seg;
d1827 2
d1842 2
d1857 2
d1868 5
d1877 359
d2242 3
d2262 1
d2266 4
a2279 3
void print_expr_1 PARAMS ((FILE *, expressionS *));
void print_symbol_value_1 PARAMS ((FILE *, symbolS *));

d2289 36
a2324 20
  if (sym->sy_frag != &zero_address_frag)
    fprintf (file, " frag %lx", (long) sym->sy_frag);
  if (sym->written)
    fprintf (file, " written");
  if (sym->sy_resolved)
    fprintf (file, " resolved");
  else if (sym->sy_resolving)
    fprintf (file, " resolving");
  if (sym->sy_used_in_reloc)
    fprintf (file, " used-in-reloc");
  if (sym->sy_used)
    fprintf (file, " used");
  if (S_IS_LOCAL (sym))
    fprintf (file, " local");
  if (S_IS_EXTERN (sym))
    fprintf (file, " extern");
  if (S_IS_DEBUG (sym))
    fprintf (file, " debug");
  if (S_IS_DEFINED (sym))
    fprintf (file, " defined");
d2326 1
a2326 1
  if (sym->sy_resolved)
d2334 2
a2335 1
  else if (indent_level < 8 && S_GET_SEGMENT (sym) != undefined_section)
d2339 7
a2345 1
      print_expr_1 (file, &sym->sy_value);
d2361 15
d2420 1
a2420 1
      fprintf (file, "multiply");
d2423 1
a2423 1
      fprintf (file, "divide");
d2426 1
a2426 1
      fprintf (file, "modulus");
d2429 1
a2429 1
      fprintf (file, "lshift");
d2432 1
a2432 1
      fprintf (file, "rshift");
d2435 1
a2435 1
      fprintf (file, "bit_ior");
d2438 1
a2438 1
      fprintf (file, "bit_xor");
d2441 1
a2441 1
      fprintf (file, "bit_and");
d2444 1
a2444 1
      fprintf (file, "eq");
d2447 1
a2447 1
      fprintf (file, "ne");
d2450 1
a2450 1
      fprintf (file, "lt");
d2453 1
a2453 1
      fprintf (file, "le");
d2456 1
a2456 1
      fprintf (file, "ge");
d2459 1
a2459 1
      fprintf (file, "gt");
d2462 1
a2462 1
      fprintf (file, "logical_and");
d2465 1
a2465 1
      fprintf (file, "logical_or");
d2503 5
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d780 11
a790 1
		as_bad_where (file, line, "invalid section for operation");
d792 12
a803 2
		as_bad ("invalid section for operation setting %s",
			S_GET_NAME (symp));
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d49 1
a49 1
#define debug_verify_symchain (void)
d232 1
a232 1
	      S_GET_OTHER(symbolP) = const_flag;
d284 2
a285 2
		      S_GET_OTHER(symbolP) = const_flag;
#endif /* OBJ_VMS */
d642 29
a670 1
    reduce:
a738 33
	case O_add:
	  resolve_symbol_value (symp->sy_value.X_add_symbol);
	  resolve_symbol_value (symp->sy_value.X_op_symbol);
	  seg_left = S_GET_SEGMENT (symp->sy_value.X_add_symbol);
	  seg_right = S_GET_SEGMENT (symp->sy_value.X_op_symbol);
	  /* This case comes up with PIC support.  */
	  {
	    symbolS *s_left = symp->sy_value.X_add_symbol;
	    symbolS *s_right = symp->sy_value.X_op_symbol;

	    if (seg_left == absolute_section)
	      {
		symbolS *t;
		segT ts;
		t = s_left;
		s_left = s_right;
		s_right = t;
		ts = seg_left;
		seg_left = seg_right;
		seg_right = ts;
	      }
	    if (seg_right == absolute_section
		&& s_right->sy_resolved)
	      {
		symp->sy_value.X_add_number += S_GET_VALUE (s_right);
		symp->sy_value.X_op_symbol = 0;
		symp->sy_value.X_add_symbol = s_left;
		symp->sy_value.X_op = O_symbol;
		goto reduce;
	      }
	  }
	  /* fall through */

d748 1
a761 10
	  if (seg_left != seg_right
	      && seg_left != undefined_section
	      && seg_right != undefined_section)
	    as_bad ("%s is operation on symbols in different sections",
		    S_GET_NAME (symp));
	  if ((S_GET_SEGMENT (symp->sy_value.X_add_symbol)
	       != absolute_section)
	      && symp->sy_value.X_op != O_subtract)
	    as_bad ("%s is illegal operation on non-absolute symbols",
		    S_GET_NAME (symp));
d764 22
d1369 4
a1372 1
    as_warn ("%s already declared as weak", S_GET_NAME (s));
d1382 4
a1385 1
    as_warn ("%s already declared as weak", S_GET_NAME (s));
a1393 2
  if ((s->bsym->flags & BSF_GLOBAL) != 0)
    as_warn ("%s already declared as global", S_GET_NAME (s));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1990, 1991, 1992, 1993, 1994
d132 2
a133 1
  assert (symbolP->bsym != 0);
d176 1
a176 1
  if (LOCAL_LABELS_DOLLAR && *sym_name != 'L')
d668 19
a686 9
#if 0 /* I thought this was needed for some of the i386-svr4 PIC
	 support, but it appears I was wrong, and it breaks rs6000
	 support.  */
	  if (S_GET_SEGMENT (symp->sy_value.X_add_symbol) != undefined_section
	      && S_GET_SEGMENT (symp->sy_value.X_add_symbol) != expr_section)
#endif
	    {
	      if (symp->sy_value.X_add_number == 0)
		copy_symbol_attributes (symp, symp->sy_value.X_add_symbol);
a687 9
	      S_SET_VALUE (symp,
			   (symp->sy_value.X_add_number
			    + symp->sy_frag->fr_address
			    + S_GET_VALUE (symp->sy_value.X_add_symbol)));
	      if (S_GET_SEGMENT (symp) == expr_section
		  || S_GET_SEGMENT (symp) == undefined_section)
		S_SET_SEGMENT (symp,
			       S_GET_SEGMENT (symp->sy_value.X_add_symbol));
	    }
d693 1
d697 2
d1202 16
a1217 1
    as_bad ("Attempt to get value of unresolved symbol %s", S_GET_NAME (s));
d1612 7
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d132 1
a132 2
  if (symbolP->bsym == NULL)
    as_perror ("%s", "bfd_make_empty_symbol");
d175 1
a175 1
  if (LOCAL_LABELS_DOLLAR && ! LOCAL_LABEL (sym_name))
d667 9
a675 19
	  if (symp->sy_value.X_add_number == 0)
	    copy_symbol_attributes (symp, symp->sy_value.X_add_symbol);

	  S_SET_VALUE (symp,
		       (symp->sy_value.X_add_number
			+ symp->sy_frag->fr_address
			+ S_GET_VALUE (symp->sy_value.X_add_symbol)));
	  if (S_GET_SEGMENT (symp) == expr_section
	      || S_GET_SEGMENT (symp) == undefined_section)
	    S_SET_SEGMENT (symp,
			   S_GET_SEGMENT (symp->sy_value.X_add_symbol));

	  /* If we have equated this symbol to an undefined symbol, we
             keep X_op set to O_symbol.  This permits the routine
             which writes out relocation to detect this case, and
             convert the relocation to be against the symbol to which
             this symbol is equated.  */
	  if (! S_IS_DEFINED (symp) || S_IS_COMMON (symp))
	    symp->sy_value.X_op = O_symbol;
d677 9
a690 1
	case O_logical_not:
a693 2
	  else if (symp->sy_value.X_op == O_logical_not)
	    val = ! S_GET_VALUE (symp->sy_value.X_add_symbol);
d1197 1
a1197 16
    {
      static symbolS *recur;

      /* FIXME: In non BFD assemblers, S_IS_DEFINED and S_IS_COMMON
         may call S_GET_VALUE.  We use a static symbol to avoid the
         immediate recursion.  */
      if (recur == s)
	return (valueT) s->sy_value.X_add_number;
      recur = s;
      if (! s->sy_resolved
	  || s->sy_value.X_op != O_symbol
	  || (S_IS_DEFINED (s) && ! S_IS_COMMON (s)))
	as_bad ("Attempt to get value of unresolved symbol %s",
		S_GET_NAME (s));
      recur = NULL;
    }
a1591 7
}

void
symbol_print_statistics (file)
     FILE *file;
{
  hash_print_statistics (file, "symbol table", sy_hash);
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d49 1
a49 1
#define debug_verify_symchain(root, last) ((void) 0)
d232 1
a232 1
	      S_SET_OTHER(symbolP, const_flag);
d284 2
a285 2
		      S_SET_OTHER(symbolP, const_flag);
#endif
d642 1
a642 29
      /* Simplify addition or subtraction of a constant by folding the
         constant into X_add_number.  */
      if (symp->sy_value.X_op == O_add
	  || symp->sy_value.X_op == O_subtract)
	{
	  resolve_symbol_value (symp->sy_value.X_add_symbol);
	  resolve_symbol_value (symp->sy_value.X_op_symbol);
	  if (S_GET_SEGMENT (symp->sy_value.X_op_symbol) == absolute_section)
	    {
	      right = S_GET_VALUE (symp->sy_value.X_op_symbol);
	      if (symp->sy_value.X_op == O_add)
		symp->sy_value.X_add_number += right;
	      else
		symp->sy_value.X_add_number -= right;
	      symp->sy_value.X_op = O_symbol;
	      symp->sy_value.X_op_symbol = NULL;
	    }
	  else if ((S_GET_SEGMENT (symp->sy_value.X_add_symbol)
		    == absolute_section)
		   && symp->sy_value.X_op == O_add)
	    {
	      left = S_GET_VALUE (symp->sy_value.X_add_symbol);
	      symp->sy_value.X_add_symbol = symp->sy_value.X_op_symbol;
	      symp->sy_value.X_add_number += left;
	      symp->sy_value.X_op = O_symbol;
	      symp->sy_value.X_op_symbol = NULL;
	    }
	}

d711 33
a752 1
	case O_add:
d766 10
a777 22

	  /* Subtraction is permitted if both operands are in the same
	     section.  Otherwise, both operands must be absolute.  We
	     already handled the case of addition or subtraction of a
	     constant above.  This will probably need to be changed
	     for an object file format which supports arbitrary
	     expressions, such as IEEE-695.  */
	  if ((seg_left != absolute_section
	       || seg_right != absolute_section)
	      && (symp->sy_value.X_op != O_subtract
		  || seg_left != seg_right))
	    {
	      char *file;
	      unsigned int line;

	      if (expr_symbol_where (symp, &file, &line))
		as_bad_where (file, line, "invalid section for operation");
	      else
		as_bad ("invalid section for operation setting %s",
			S_GET_NAME (symp));
	    }

d1361 1
a1361 4
    {
      /* Let .weak override .global.  */
      return;
    }
d1371 1
a1371 4
    {
      /* Let .weak override.  */
      return;
    }
d1380 2
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d780 1
a780 11
		{
		  if (seg_left == undefined_section
		      || seg_right == undefined_section)
		    as_bad_where (file, line,
				  "undefined symbol %s in operation",
				  (seg_left == undefined_section
				   ? S_GET_NAME (symp->sy_value.X_add_symbol)
				   : S_GET_NAME (symp->sy_value.X_op_symbol)));
		  else
		    as_bad_where (file, line, "invalid section for operation");
		}
d782 2
a783 12
		{
		  if (seg_left == undefined_section
		      || seg_right == undefined_section)
		    as_bad ("undefined symbol %s in operation setting %s",
			    (seg_left == undefined_section
			     ? S_GET_NAME (symp->sy_value.X_add_symbol)
			     : S_GET_NAME (symp->sy_value.X_op_symbol)),
			    S_GET_NAME (symp));
		  else
		    as_bad ("invalid section for operation setting %s",
			    S_GET_NAME (symp));
		}
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1997
d18 2
a19 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a54 2
static long dollar_label_instance PARAMS ((long));
static long fb_label_instance PARAMS ((long));
d87 1
d176 2
a177 13
  if (LOCAL_LABELS_DOLLAR)
    {
      int local;

#ifdef BFD_ASSEMBLER
      local = bfd_is_local_label_name (stdoutput, sym_name);
#else
      local = LOCAL_LABEL (sym_name);
#endif

      if (! local)
	dollar_label_clear ();
    }
d198 1
a198 1
			      (offsetT) 0,
d226 1
a226 1
      if (!S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP))
d255 1
a255 1
		    && (!S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP))
a342 3
#ifdef obj_frob_label
  obj_frob_label (symbolP);
#endif
a481 4
      addme->sy_next = NULL;
#ifdef SYMBOLS_NEED_BACKPOINTERS
      addme->sy_previous = NULL;
#endif
a504 2

  debug_verify_symchain (symbol_rootP, symbol_lastP);
d589 1
a589 1
      assert (symbolP->sy_next->sy_previous == symbolP);
d699 9
d709 6
a714 23
             keep X_op set to O_symbol, and we don't change
             X_add_number.  This permits the routine which writes out
             relocation to detect this case, and convert the
             relocation to be against the symbol to which this symbol
             is equated.  */
	  if (! S_IS_DEFINED (symp->sy_value.X_add_symbol)
	      || S_IS_COMMON (symp->sy_value.X_add_symbol))
	    {
	      symp->sy_value.X_op = O_symbol;
	      S_SET_SEGMENT (symp,
			     S_GET_SEGMENT (symp->sy_value.X_add_symbol));
	    }
	  else
	    {
	      S_SET_VALUE (symp,
			   (symp->sy_value.X_add_number
			    + symp->sy_frag->fr_address
			    + S_GET_VALUE (symp->sy_value.X_add_symbol)));
	      if (S_GET_SEGMENT (symp) == expr_section
		  || S_GET_SEGMENT (symp) == undefined_section)
		S_SET_SEGMENT (symp,
			       S_GET_SEGMENT (symp->sy_value.X_add_symbol));
	    }
d781 2
a782 1
		  if (seg_left == undefined_section)
d785 4
a788 7
				  S_GET_NAME (symp->sy_value.X_add_symbol));
		  if (seg_right == undefined_section)
		    as_bad_where (file, line,
				  "undefined symbol %s in operation",
				  S_GET_NAME (symp->sy_value.X_op_symbol));
		  if (seg_left != undefined_section
		      && seg_right != undefined_section)
d793 2
a794 1
		  if (seg_left == undefined_section)
d796 3
a798 1
			    S_GET_NAME (symp->sy_value.X_add_symbol),
d800 1
a800 6
		  if (seg_right == undefined_section)
		    as_bad ("undefined symbol %s in operation setting %s",
			    S_GET_NAME (symp->sy_value.X_op_symbol),
			    S_GET_NAME (symp));
		  if (seg_left != undefined_section
		      && seg_right != undefined_section)
d891 1
a891 1
static long
d1342 1
a1342 1
		  && (bfd_is_local_label (stdoutput, s->bsym)
d1462 3
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a30 2
#include "struc-symbol.h"

a41 3
/* Table of local symbols.  */
static struct hash_control *local_hash;

a58 2
static void print_binary PARAMS ((FILE *, const char *, expressionS *));

d94 6
a99 6
/* Save a symbol name on a permanent obstack, and convert it according
   to the object file format.  */

static char *
save_symbol_name (name)
     const char *name;
d102 2
a103 1
  char *ret;
d107 1
a107 2
  ret = obstack_finish (&notes);

d109 2
a110 2
  if (ret[0] == '_')
    ++ret;
d114 2
a115 1
  ret = tc_canonicalize_symbol_name (ret);
d122 1
a122 1
      for (s = (unsigned char *) ret; *s != '\0'; s++)
a126 15
  return ret;
}

symbolS *
symbol_create (name, segment, valu, frag)
     const char *name;		/* It is copied, the caller can destroy/modify */
     segT segment;		/* Segment identifier (SEG_<something>) */
     valueT valu;		/* Symbol value */
     fragS *frag;		/* Associated fragment */
{
  char *preserved_copy_of_name;
  symbolS *symbolP;

  preserved_copy_of_name = save_symbol_name (name);

a158 95
#ifdef BFD_ASSEMBLER

/* Local symbol support.  If we can get away with it, we keep only a
   small amount of information for local symbols.  */

static struct local_symbol *local_symbol_make PARAMS ((const char *, segT,
						       valueT, fragS *));
static symbolS *local_symbol_convert PARAMS ((struct local_symbol *));

/* Used for statistics.  */

static unsigned long local_symbol_count;
static unsigned long local_symbol_conversion_count;

/* This macro is called with a symbol argument passed by reference.
   It returns whether this is a local symbol.  If necessary, it
   changes its argument to the real symbol.  */

#define LOCAL_SYMBOL_CHECK(s)						\
  (s->bsym == NULL							\
   ? (local_symbol_converted_p ((struct local_symbol *) s)		\
      ? (s = local_symbol_get_real_symbol ((struct local_symbol *) s),	\
	 0)								\
      : 1)								\
   : 0)

/* Create a local symbol and insert it into the local hash table.  */

static struct local_symbol *
local_symbol_make (name, section, offset, frag)
     const char *name;
     segT section;
     valueT offset;
     fragS *frag;
{
  char *name_copy;
  struct local_symbol *ret;

  ++local_symbol_count;

  name_copy = save_symbol_name (name);

  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);
  ret->lsy_marker = NULL;
  ret->lsy_name = name_copy;
  ret->lsy_section = section;
  local_symbol_set_frag (ret, frag);
  ret->lsy_offset = offset;

  hash_jam (local_hash, name_copy, (PTR) ret);

  return ret;
}

/* Convert a local symbol into a real symbol.  Note that we do not
   reclaim the space used by the local symbol.  */

static symbolS *
local_symbol_convert (locsym)
     struct local_symbol *locsym;
{
  symbolS *ret;

  assert (locsym->lsy_marker == NULL);
  if (local_symbol_converted_p (locsym))
    return local_symbol_get_real_symbol (locsym);

  ++local_symbol_conversion_count;

  ret = symbol_new (locsym->lsy_name, locsym->lsy_section, locsym->lsy_offset,
		    local_symbol_get_frag (locsym));

  if (local_symbol_resolved_p (locsym))
    ret->sy_resolved = 1;

  /* Local symbols are always either defined or used.  */
  ret->sy_used = 1;

  symbol_table_insert (ret);

  local_symbol_mark_converted (locsym);
  local_symbol_set_real_symbol (locsym, ret);

  hash_jam (local_hash, locsym->lsy_name, NULL);

  return ret;
}

#else /* ! BFD_ASSEMBLER */

#define LOCAL_SYMBOL_CHECK(s) 0
#define local_symbol_convert(s) ((symbolS *) s)

#endif /* ! BFD_ASSEMBLER */

d239 1
a239 20
      if (LOCAL_SYMBOL_CHECK (symbolP))
	{
#ifdef BFD_ASSEMBLER
	  struct local_symbol *locsym = (struct local_symbol *) symbolP;

	  if (locsym->lsy_section != undefined_section
	      && (local_symbol_get_frag (locsym) != frag_now
		  || locsym->lsy_section != now_seg
		  || locsym->lsy_offset != frag_now_fix ()))
	    {
	      as_bad (_("Symbol %s already defined."), sym_name);
	      return symbolP;
	    }

	  locsym->lsy_section = now_seg;
	  local_symbol_set_frag (locsym, frag_now);
	  locsym->lsy_offset = frag_now_fix ();
#endif
	}
      else if (!S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP))
d305 6
a310 3
#if (!defined (OBJ_AOUT) && !defined (OBJ_MAYBE_AOUT) \
     && !defined (OBJ_BOUT) && !defined (OBJ_MAYBE_BOUT))
		  static const char *od_buf = "";
d312 1
a312 10
		  char od_buf[100];
		  od_buf[0] = '\0';
#ifdef BFD_ASSEMBLER
		  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
#endif
		    sprintf(od_buf, "%d.%d.",
			    S_GET_OTHER (symbolP),
			    S_GET_DESC (symbolP));
#endif
		  as_fatal (_("Symbol \"%s\" is already defined as \"%s\"/%s%ld."),
a314 1
			    od_buf,
d316 1
d326 1
a326 1
	    as_fatal (_("Symbol %s already defined."), sym_name);
a329 8
#ifdef BFD_ASSEMBLER
  else if (! flag_keep_locals && bfd_is_local_label_name (stdoutput, sym_name))
    {
      symbolP = (symbolS *) local_symbol_make (sym_name, now_seg,
					       (valueT) frag_now_fix (),
					       frag_now);
    }
#endif /* BFD_ASSEMBLER */
a344 2
      if (LOCAL_SYMBOL_CHECK (symbolP))
	symbolP = local_symbol_convert ((struct local_symbol *) symbolP);
a379 10
  if (LOCAL_SYMBOL_CHECK (symbolP))
    {
      error_string = hash_jam (local_hash, S_GET_NAME (symbolP),
			       (PTR) symbolP);
      if (error_string != NULL)
	as_fatal (_("Inserting \"%s\" into symbol table failed: %s"),
		  S_GET_NAME (symbolP), error_string);
      return;
    }

d382 1
a382 1
      as_fatal (_("Inserting \"%s\" into symbol table failed: %s"),
a402 14
#ifdef BFD_ASSEMBLER
      if (! flag_keep_locals && bfd_is_local_label_name (stdoutput, name))
	{
	  symbolP = md_undefined_symbol ((char *) name);
	  if (symbolP != NULL)
	    return symbolP;

	  symbolP = (symbolS *) local_symbol_make (name, undefined_section,
						   (valueT) 0,
						   &zero_address_frag);
	  return symbolP;
	}
#endif

a456 1
    size_t len = strlen (name) + 1;
d458 2
a459 2
    copy = (char *) alloca (len);
    memcpy (copy, name, len);
d466 1
a466 3
      char *copy;
      const char *orig;
      unsigned char c;
d468 5
a472 10
      orig = name;
      name = copy = (char *) alloca (strlen (name) + 1);

      while ((c = *orig++) != '\0')
	{
	  if (islower (c))
	    c = toupper (c);
	  *copy++ = c;
	}
      *copy = '\0';
a474 10
#ifdef BFD_ASSEMBLER
  {
    struct local_symbol *locsym;

    locsym = (struct local_symbol *) hash_find (local_hash, name);
    if (locsym != NULL)
      return (symbolS *) locsym;
  }
#endif

a493 5
  if (LOCAL_SYMBOL_CHECK (addme))
    abort ();
  if (target != NULL && LOCAL_SYMBOL_CHECK (target))
    abort ();

a533 2
  if (LOCAL_SYMBOL_CHECK (symbolP))
    abort ();
a547 3
  if (LOCAL_SYMBOL_CHECK (symbolP))
    abort ();

d577 1
a577 1
     symbolS **lastPP ATTRIBUTE_UNUSED;
a578 5
  if (LOCAL_SYMBOL_CHECK (addme))
    abort ();
  if (LOCAL_SYMBOL_CHECK (target))
    abort ();

a609 3
#ifdef BFD_ASSEMBLER
      assert (symbolP->bsym != NULL);
#endif
d639 2
a640 2
valueT
resolve_symbol_value (symp, finalize)
a641 1
     int finalize;
a643 23
  valueT final_val;
  segT final_seg;

#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (symp))
    {
      struct local_symbol *locsym = (struct local_symbol *) symp;

      if (local_symbol_resolved_p (locsym))
	return locsym->lsy_offset / OCTETS_PER_BYTE;

      final_val = (local_symbol_get_frag (locsym)->fr_address
		   + locsym->lsy_offset) / OCTETS_PER_BYTE;

      if (finalize)
	{
	  locsym->lsy_offset = final_val;
	  local_symbol_mark_resolved (locsym);
	}

      return final_val;
    }
#endif
d646 1
a646 6
    {
      if (symp->sy_value.X_op == O_constant)
	return (valueT) symp->sy_value.X_add_number;
      else
	return 0;
    }
a648 1
  final_seg = S_GET_SEGMENT (symp);
d652 3
a654 3
      if (finalize)
	as_bad (_("Symbol definition loop encountered at %s"), S_GET_NAME (symp));
      final_val = 0;
d659 1
a659 2
      symbolS *add_symbol, *op_symbol;
      offsetT left, right;
a660 1
      operatorT op;
d664 28
a691 5
      /* Help out with CSE.  */
      add_symbol = symp->sy_value.X_add_symbol;
      op_symbol = symp->sy_value.X_op_symbol;
      final_val = symp->sy_value.X_add_number;
      op = symp->sy_value.X_op;
d693 1
a693 1
      switch (op)
a694 4
	default:
	  BAD_CASE (op);
	  break;

d696 1
a696 1
	  final_val = 0;
a697 1

d699 3
a701 3
	  final_val += symp->sy_frag->fr_address / OCTETS_PER_BYTE;
	  if (final_seg == expr_section)
	    final_seg = absolute_section;
d706 1
a706 3
	case O_symbol_rva:
	  left = resolve_symbol_value (add_symbol, finalize);
	do_symbol:
d713 2
a714 1
	      resolved = symbol_resolved_p (add_symbol);
d718 2
a719 7
	  if (finalize && final_val == 0)
	    {
	      if (LOCAL_SYMBOL_CHECK (add_symbol))
		add_symbol = local_symbol_convert ((struct local_symbol *)
						   add_symbol);
	      copy_symbol_attributes (symp, add_symbol);
	    }
d727 2
a728 1
	  if (! S_IS_DEFINED (add_symbol) || S_IS_COMMON (add_symbol))
d730 3
a732 10
	      if (finalize)
		{
		  S_SET_SEGMENT (symp, S_GET_SEGMENT (add_symbol));
		  symp->sy_value.X_op = O_symbol;
		  symp->sy_value.X_add_symbol = add_symbol;
		  symp->sy_value.X_add_number = final_val;
		}
	      final_val = 0;
	      resolved = symbol_resolved_p (add_symbol);
	      goto exit_dont_set_value;
d736 8
a743 3
	      final_val += symp->sy_frag->fr_address + left;
	      if (final_seg == expr_section || final_seg == undefined_section)
		final_seg = S_GET_SEGMENT (add_symbol);
d746 1
a746 1
	  resolved = symbol_resolved_p (add_symbol);
d752 5
a756 6
	  left = resolve_symbol_value (add_symbol, finalize);

	  if (op == O_uminus)
	    left = -left;
	  else if (op == O_logical_not)
	    left = !left;
d758 9
a766 7
	    left = ~left;

	  final_val += left + symp->sy_frag->fr_address;
	  if (final_seg == expr_section || final_seg == undefined_section)
	    final_seg = absolute_section;

	  resolved = symbol_resolved_p (add_symbol);
d788 6
a793 29
	  left = resolve_symbol_value (add_symbol, finalize);
	  right = resolve_symbol_value (op_symbol, finalize);
	  seg_left = S_GET_SEGMENT (add_symbol);
	  seg_right = S_GET_SEGMENT (op_symbol);

	  /* Simplify addition or subtraction of a constant by folding the
	     constant into X_add_number.  */
	  if (op == O_add || op == O_subtract)
	    {
	      if (seg_right == absolute_section)
		{
		  if (op == O_add)
		    final_val += right;
		  else
		    final_val -= right;
		  op = O_symbol;
		  op_symbol = NULL;
		  goto do_symbol;
		}
	      else if (seg_left == absolute_section && op == O_add)
		{
		  op = O_symbol;
		  final_val += left;
		  add_symbol = op_symbol;
		  left = right;
		  op_symbol = NULL;
		  goto do_symbol;
		}
	    }
a800 2
	  /* Don't emit messages unless we're finalizing the symbol value,
	     otherwise we may get the same message multiple times.  */
d803 2
a804 4
	      && (op != O_subtract
		  || seg_left != seg_right
		  || seg_left == undefined_section)
	      && finalize)
d813 1
a813 1
				  _("undefined symbol %s in operation"),
d817 1
a817 1
				  _("undefined symbol %s in operation"),
d821 1
a821 1
		    as_bad_where (file, line, _("invalid section for operation"));
d826 1
a826 1
		    as_bad (_("undefined symbol %s in operation setting %s"),
d830 1
a830 1
		    as_bad (_("undefined symbol %s in operation setting %s"),
d835 1
a835 19
		    as_bad (_("invalid section for operation setting %s"),
			    S_GET_NAME (symp));
		}
	    }

	  /* Check for division by zero.  */
	  if ((op == O_divide || op == O_modulus) && right == 0)
	    {
	      /* If seg_right is not absolute_section, then we've
                 already issued a warning about using a bad symbol.  */
	      if (seg_right == absolute_section && finalize)
		{
		  char *file;
		  unsigned int line;

		  if (expr_symbol_where (symp, &file, &line))
		    as_bad_where (file, line, _("division by zero"));
		  else
		    as_bad (_("division by zero when setting %s"),
a837 2

	      right = 1;
d842 20
a861 20
	    case O_multiply:		left *= right; break;
	    case O_divide:		left /= right; break;
	    case O_modulus:		left %= right; break;
	    case O_left_shift:		left <<= right; break;
	    case O_right_shift:		left >>= right; break;
	    case O_bit_inclusive_or:	left |= right; break;
	    case O_bit_or_not:		left |= ~right; break;
	    case O_bit_exclusive_or:	left ^= right; break;
	    case O_bit_and:		left &= right; break;
	    case O_add:			left += right; break;
	    case O_subtract:		left -= right; break;
	    case O_eq:	left = left == right ? ~ (offsetT) 0 : 0; break;
	    case O_ne:	left = left != right ? ~ (offsetT) 0 : 0; break;
	    case O_lt:	left = left <  right ? ~ (offsetT) 0 : 0; break;
	    case O_le:	left = left <= right ? ~ (offsetT) 0 : 0; break;
	    case O_ge:	left = left >= right ? ~ (offsetT) 0 : 0; break;
	    case O_gt:	left = left >  right ? ~ (offsetT) 0 : 0; break;
	    case O_logical_and:	left = left && right; break;
	    case O_logical_or:	left = left || right; break;
	    default:		abort ();
d863 9
a871 6

	  final_val += symp->sy_frag->fr_address + left;
	  if (final_seg == expr_section || final_seg == undefined_section)
	    final_seg = absolute_section;
	  resolved = (symbol_resolved_p (add_symbol)
		      && symbol_resolved_p (op_symbol));
a883 14

      symp->sy_resolving = 0;
    }

  if (finalize)
    {
      S_SET_VALUE (symp, final_val);

#if defined (OBJ_AOUT) && ! defined (BFD_ASSEMBLER)
      /* The old a.out backend does not handle S_SET_SEGMENT correctly
         for a stab symbol, so we use this bad hack.  */
      if (final_seg != S_GET_SEGMENT (symp))
#endif
	S_SET_SEGMENT (symp, final_seg);
a885 1
exit_dont_set_value:
d887 3
a889 1
  if (finalize)
d891 2
a892 7
      if (resolved)
	symp->sy_resolved = 1;
      else if (S_GET_SEGMENT (symp) != expr_section)
	{
	  as_bad (_("can't resolve value for symbol \"%s\""), S_GET_NAME (symp));
	  symp->sy_resolved = 1;
	}
a893 29

  return final_val;
}

#ifdef BFD_ASSEMBLER

static void resolve_local_symbol PARAMS ((const char *, PTR));

/* A static function passed to hash_traverse.  */

static void
resolve_local_symbol (key, value)
     const char *key ATTRIBUTE_UNUSED;
     PTR value;
{
  if (value != NULL)
    resolve_symbol_value (value, 1);
}

#endif

/* Resolve all local symbols.  */

void
resolve_local_symbol_values ()
{
#ifdef BFD_ASSEMBLER
  hash_traverse (local_hash, resolve_local_symbol);
#endif
d906 1
a906 1
static unsigned long dollar_label_count;
a1018 3
#ifdef LOCAL_LABEL_PREFIX
  *p++ = LOCAL_LABEL_PREFIX;
#endif
d1231 1
a1231 1
  const char *message_format = _("\"%d\" (instance number %d of a %s label)");
d1236 1
a1236 1
  for (label_number = 0, p = s + 1; isdigit ((unsigned char) *p); ++p)
d1246 1
a1246 1
  for (instance_number = 0, p++; isdigit ((unsigned char) *p); ++p)
d1261 2
a1262 7
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_offset;
#endif

  if (!s->sy_resolved && s->sy_value.X_op != O_constant)
    resolve_symbol_value (s, 1);
d1276 1
a1276 1
	as_bad (_("Attempt to get value of unresolved symbol %s"),
a1289 8
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    {
      ((struct local_symbol *) s)->lsy_offset = val;
      return;
    }
#endif

a1298 5
  if (LOCAL_SYMBOL_CHECK (dest))
    dest = local_symbol_convert ((struct local_symbol *) dest);
  if (LOCAL_SYMBOL_CHECK (src))
    src = local_symbol_convert ((struct local_symbol *) src);

d1302 1
a1302 1
#define COPIED_SYMFLAGS	(BSF_FUNCTION | BSF_OBJECT)
a1313 14
S_IS_FUNCTION (s)
     symbolS *s;
{
  flagword flags;

  if (LOCAL_SYMBOL_CHECK (s))
    return 0;

  flags = s->bsym->flags;

  return (flags & BSF_FUNCTION) != 0;
}

int
d1317 1
a1317 6
  flagword flags;

  if (LOCAL_SYMBOL_CHECK (s))
    return 0;

  flags = s->bsym->flags;
d1320 1
a1320 1
  if ((flags & BSF_LOCAL) && (flags & BSF_GLOBAL))
a1329 2
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
a1336 2
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
a1343 2
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_section != undefined_section;
a1350 2
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
d1360 1
a1360 1
  flagword flags;
a1362 5
  if (LOCAL_SYMBOL_CHECK (s))
    return 1;

  flags = s->bsym->flags;

d1364 1
a1364 1
  if ((flags & BSF_LOCAL) && (flags & BSF_GLOBAL))
a1369 5
  if (flag_strip_local_absolute
      && (flags & BSF_GLOBAL) == 0
      && bfd_get_section (s->bsym) == absolute_section)
    return 1;

a1399 2
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_name;
a1406 2
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_section;
d1415 1
a1415 22
  /* Don't reassign section symbols.  The direct reason is to prevent seg
     faults assigning back to const global symbols such as *ABS*, but it
     shouldn't happen anyway.  */

  if (LOCAL_SYMBOL_CHECK (s))
    {
      if (seg == reg_section)
	s = local_symbol_convert ((struct local_symbol *) s);
      else
	{
	  ((struct local_symbol *) s)->lsy_section = seg;
	  return;
	}
    }

  if (s->bsym->flags & BSF_SECTION_SYM)
    {
      if (s->bsym->section != seg)
	abort();
    }
  else
    s->bsym->section = seg;
a1421 2
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
a1434 2
  if (LOCAL_SYMBOL_CHECK (s))
    return;
a1447 2
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
a1456 5
  if (LOCAL_SYMBOL_CHECK (s))
    {
      ((struct local_symbol *) s)->lsy_name = name;
      return;
    }
a1460 359
#ifdef SYMBOLS_NEED_BACKPOINTERS

/* Return the previous symbol in a chain.  */

symbolS *
symbol_previous (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    abort ();
  return s->sy_previous;
}

#endif /* SYMBOLS_NEED_BACKPOINTERS */

/* Return the next symbol in a chain.  */

symbolS *
symbol_next (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    abort ();
  return s->sy_next;
}

/* Return a pointer to the value of a symbol as an expression.  */

expressionS *
symbol_get_value_expression (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return &s->sy_value;
}

/* Set the value of a symbol to an expression.  */

void
symbol_set_value_expression (s, exp)
     symbolS *s;
     const expressionS *exp;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_value = *exp;
}

/* Set the frag of a symbol.  */

void
symbol_set_frag (s, f)
     symbolS *s;
     fragS *f;
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    {
      local_symbol_set_frag ((struct local_symbol *) s, f);
      return;
    }
#endif
  s->sy_frag = f;
}

/* Return the frag of a symbol.  */

fragS *
symbol_get_frag (s)
     symbolS *s;
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    return local_symbol_get_frag ((struct local_symbol *) s);
#endif
  return s->sy_frag;
}

/* Mark a symbol as having been used.  */

void
symbol_mark_used (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_used = 1;
}

/* Clear the mark of whether a symbol has been used.  */

void
symbol_clear_used (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_used = 0;
}

/* Return whether a symbol has been used.  */

int
symbol_used_p (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 1;
  return s->sy_used;
}

/* Mark a symbol as having been used in a reloc.  */

void
symbol_mark_used_in_reloc (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_used_in_reloc = 1;
}

/* Clear the mark of whether a symbol has been used in a reloc.  */

void
symbol_clear_used_in_reloc (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_used_in_reloc = 0;
}

/* Return whether a symbol has been used in a reloc.  */

int
symbol_used_in_reloc_p (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_used_in_reloc;
}

/* Mark a symbol as an MRI common symbol.  */

void
symbol_mark_mri_common (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_mri_common = 1;
}

/* Clear the mark of whether a symbol is an MRI common symbol.  */

void
symbol_clear_mri_common (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_mri_common = 0;
}

/* Return whether a symbol is an MRI common symbol.  */

int
symbol_mri_common_p (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_mri_common;
}

/* Mark a symbol as having been written.  */

void
symbol_mark_written (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->written = 1;
}

/* Clear the mark of whether a symbol has been written.  */

void
symbol_clear_written (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->written = 0;
}

/* Return whether a symbol has been written.  */

int
symbol_written_p (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->written;
}

/* Mark a symbol has having been resolved.  */

void
symbol_mark_resolved (s)
     symbolS *s;
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    {
      local_symbol_mark_resolved ((struct local_symbol *) s);
      return;
    }
#endif
  s->sy_resolved = 1;
}

/* Return whether a symbol has been resolved.  */

int
symbol_resolved_p (s)
     symbolS *s;
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    return local_symbol_resolved_p ((struct local_symbol *) s);
#endif
  return s->sy_resolved;
}

/* Return whether a symbol is a section symbol.  */

int
symbol_section_p (s)
     symbolS *s ATTRIBUTE_UNUSED;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
#ifdef BFD_ASSEMBLER
  return (s->bsym->flags & BSF_SECTION_SYM) != 0;
#else
  /* FIXME */
  return 0;
#endif
}

/* Return whether a symbol is equated to another symbol.  */

int
symbol_equated_p (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_value.X_op == O_symbol;
}

/* Return whether a symbol has a constant value.  */

int
symbol_constant_p (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 1;
  return s->sy_value.X_op == O_constant;
}

#ifdef BFD_ASSEMBLER

/* Return the BFD symbol for a symbol.  */

asymbol *
symbol_get_bfdsym (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return s->bsym;
}

/* Set the BFD symbol for a symbol.  */

void
symbol_set_bfdsym (s, bsym)
     symbolS *s;
     asymbol *bsym;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->bsym = bsym;
}

#endif /* BFD_ASSEMBLER */

#ifdef OBJ_SYMFIELD_TYPE

/* Get a pointer to the object format information for a symbol.  */

OBJ_SYMFIELD_TYPE *
symbol_get_obj (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return &s->sy_obj;
}

/* Set the object format information for a symbol.  */

void
symbol_set_obj (s, o)
     symbolS *s;
     OBJ_SYMFIELD_TYPE *o;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_obj = *o;
}

#endif /* OBJ_SYMFIELD_TYPE */

#ifdef TC_SYMFIELD_TYPE

/* Get a pointer to the processor information for a symbol.  */

TC_SYMFIELD_TYPE *
symbol_get_tc (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return &s->sy_tc;
}

/* Set the processor information for a symbol.  */

void
symbol_set_tc (s, o)
     symbolS *s;
     TC_SYMFIELD_TYPE *o;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_tc = *o;
}

#endif /* TC_SYMFIELD_TYPE */

a1466 3
#ifdef BFD_ASSEMBLER
  local_hash = hash_new ();
#endif
a1483 1

a1486 4
/* Maximum indent level.
   Available for modification inside a gdb session.  */
int max_indent_level = 8;

d1506 20
a1525 36

  if (LOCAL_SYMBOL_CHECK (sym))
    {
#ifdef BFD_ASSEMBLER
      struct local_symbol *locsym = (struct local_symbol *) sym;
      if (local_symbol_get_frag (locsym) != &zero_address_frag
	  && local_symbol_get_frag (locsym) != NULL)
	fprintf (file, " frag %lx", (long) local_symbol_get_frag (locsym));
      if (local_symbol_resolved_p (locsym))
	fprintf (file, " resolved");
      fprintf (file, " local");
#endif
    }
  else
    {
      if (sym->sy_frag != &zero_address_frag)
	fprintf (file, " frag %lx", (long) sym->sy_frag);
      if (sym->written)
	fprintf (file, " written");
      if (sym->sy_resolved)
	fprintf (file, " resolved");
      else if (sym->sy_resolving)
	fprintf (file, " resolving");
      if (sym->sy_used_in_reloc)
	fprintf (file, " used-in-reloc");
      if (sym->sy_used)
	fprintf (file, " used");
      if (S_IS_LOCAL (sym))
	fprintf (file, " local");
      if (S_IS_EXTERN (sym))
	fprintf (file, " extern");
      if (S_IS_DEBUG (sym))
	fprintf (file, " debug");
      if (S_IS_DEFINED (sym))
	fprintf (file, " defined");
    }
d1527 1
a1527 1
  if (symbol_resolved_p (sym))
d1535 1
a1535 2
  else if (indent_level < max_indent_level
	   && S_GET_SEGMENT (sym) != undefined_section)
d1539 1
a1539 7
#ifdef BFD_ASSEMBLER
      if (LOCAL_SYMBOL_CHECK (sym))
	fprintf (file, "constant %lx",
		 (long) ((struct local_symbol *) sym)->lsy_offset);
      else
#endif
	print_expr_1 (file, &sym->sy_value);
a1554 15
static void
print_binary (file, name, exp)
     FILE *file;
     const char * name;
     expressionS *exp;
{
  indent_level++;
  fprintf (file, "%s\n%*s<", name, indent_level * 4, "");
  print_symbol_value_1 (file, exp->X_add_symbol);
  fprintf (file, ">\n%*s<", indent_level * 4, "");
  print_symbol_value_1 (file, exp->X_op_symbol);
  fprintf (file, ">");
  indent_level--;
}

d1599 1
a1599 1
      print_binary (file, "multiply", exp);
d1602 1
a1602 1
      print_binary (file, "divide", exp);
d1605 1
a1605 1
      print_binary (file, "modulus", exp);
d1608 1
a1608 1
      print_binary (file, "lshift", exp);
d1611 1
a1611 1
      print_binary (file, "rshift", exp);
d1614 1
a1614 1
      print_binary (file, "bit_ior", exp);
d1617 1
a1617 1
      print_binary (file, "bit_xor", exp);
d1620 1
a1620 1
      print_binary (file, "bit_and", exp);
d1623 1
a1623 1
      print_binary (file, "eq", exp);
d1626 1
a1626 1
      print_binary (file, "ne", exp);
d1629 1
a1629 1
      print_binary (file, "lt", exp);
d1632 1
a1632 1
      print_binary (file, "le", exp);
d1635 1
a1635 1
      print_binary (file, "ge", exp);
d1638 1
a1638 1
      print_binary (file, "gt", exp);
d1641 1
a1641 1
      print_binary (file, "logical_and", exp);
d1644 1
a1644 1
      print_binary (file, "logical_or", exp);
a1681 5
#ifdef BFD_ASSEMBLER
  hash_print_statistics (file, "mini local symbol table", local_hash);
  fprintf (file, "%lu mini local symbols created, %lu converted\n",
	   local_symbol_count, local_symbol_conversion_count);
#endif
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001
d22 1
a22 1
/* #define DEBUG_SYMS / * to debug symbol list maintenance.  */
d47 1
a47 1
/* Below are commented in "symbols.h".  */
a57 3
#define DOLLAR_LABEL_CHAR	'\001'
#define LOCAL_LABEL_CHAR	'\002'

d66 3
a68 1
/* Return a pointer to a new symbol.  Die if we can't make a new
d71 1
a71 1

d86 3
a88 1
  /* Link to end of symbol chain.  */
d111 1
a111 1
  name_length = strlen (name) + 1;	/* +1 for \0.  */
d138 4
a141 4
     const char *name;		/* It is copied, the caller can destroy/modify.  */
     segT segment;		/* Segment identifier (SEG_<something>).  */
     valueT valu;		/* Symbol value.  */
     fragS *frag;		/* Associated fragment.  */
d150 1
a150 1
  /* symbol must be born in some fixed state.  This seems as good as any.  */
a274 4
/* We have just seen "<name>:".
   Creates a struct symbol unless it already exists.

   Gripes if we are redefining a symbol incompatibly (and ignores it).  */
d276 9
d286 3
a288 3
colon (sym_name)		/* Just seen "x:" - rattle symbols & frags.  */
     const char *sym_name;	/* Symbol name, as a cannonical string.  */
     /* We copy this string: OK to alter later.  */
d290 1
a290 1
  register symbolS *symbolP;	/* Symbol we are working with.  */
d330 3
a332 3
      /* We want to store the pointer to where to insert the jump
	 table in the fr_opcode of the rs_broken_word frag.  This
	 requires a little hackery.  */
d352 3
a354 1
      /* Now check for undefined symbols.  */
d380 1
a380 1
	      S_SET_OTHER (symbolP, const_flag);
d386 1
a386 1
#endif /* if we have one, it better be zero.  */
d391 10
a400 10
	      /* There are still several cases to check:

		 A .comm/.lcomm symbol being redefined as initialized
		 data is OK

		 A .comm/.lcomm symbol being redefined with a larger
		 size is also OK

		 This only used to be allowed on VMS gas, but Sun cc
		 on the sparc also depends on it.  */
d409 3
a411 1
		  /* Select which of the 2 cases this is.  */
d414 6
a419 5
		      /* New .comm for prev .comm symbol.

			 If the new size is larger we just change its
			 value.  If the new size is smaller, we ignore
			 this symbol.  */
d432 1
a432 1
		      S_SET_OTHER (symbolP, const_flag);
d435 1
a435 1
		      S_SET_SEGMENT (symbolP, now_seg);	/* Keep N_EXT bit.  */
d453 1
a453 1
		  as_bad (_("Symbol \"%s\" is already defined as \"%s\"/%s%ld."),
d459 1
a459 1
	    }			/* if the undefined symbol has no value  */
d463 1
a463 1
	  /* Don't blow up if the definition is the same.  */
d467 2
a468 2
	    as_bad (_("Symbol %s already defined."), sym_name);
	}
d488 1
a488 1
    }
a513 1
/* Die if we can't insert the symbol.  */
d515 8
a522 1
void
d545 2
a546 2
    }				/* on error  */
}
d548 6
a553 3
/* If a symbol name does not exist, create it as undefined, and insert
   it into the symbol table.  Return a pointer to it.  */

d584 1
a584 1
}
d592 1
a592 1
  /* Let the machine description default it, e.g. for register names.  */
d599 1
a599 1
}
d601 8
a608 4
/* Implement symbol table lookup.
   In:	A symbol's name as a string: '\0' can't be part of a symbol name.
   Out:	NULL if the name was not in the symbol table, else the address
   of a struct symbol associated with that name.  */
d619 1
a619 1
}
d671 7
a677 5
/* Once upon a time, symbols were kept in a singly linked list.  At
   least coff needs to be able to rearrange them from time to time, for
   which a doubly linked list is much more convenient.  Loic did these
   as macros which seemed dangerous to me so they're now functions.
   xoxorich.  */
d679 2
a680 3
/* Link symbol ADDME after symbol TARGET in the chain.  */

void
d703 1
a703 1
    }				/* if the list is empty  */
d715 1
a715 1
    }				/* if we have a next  */
d727 2
a728 3
/* Set the chain pointers of SYMBOL to null.  */

void
d741 2
a742 3
/* Remove SYMBOLP from the list.  */

void
d754 1
a754 1
    }				/* if it was the root  */
d759 1
a759 1
    }				/* if it was the tail  */
d764 1
a764 1
    }				/* if not last  */
d769 1
a769 1
    }				/* if not first  */
d774 2
a775 3
/* Link symbol ADDME before symbol TARGET in the chain.  */

void
d795 1
a795 1
    }				/* if not first  */
d806 1
a806 1
void
d865 1
a865 1
	return locsym->lsy_offset / bfd_octets_per_byte (stdoutput);
d868 1
a868 1
		   + locsym->lsy_offset) / bfd_octets_per_byte (stdoutput);
d894 1
a894 2
	as_bad (_("Symbol definition loop encountered at %s"),
		S_GET_NAME (symp));
d1079 1
a1079 2
		    as_bad_where (file, line,
				  _("invalid section for operation"));
d1147 1
a1147 1
	  break;
d1183 1
a1183 2
	  as_bad (_("can't resolve value for symbol \"%s\""),
		  S_GET_NAME (symp));
d1231 1
a1231 1
int
d1243 1
a1243 1
  /* If we get here, label isn't defined.  */
d1245 1
a1245 1
}
d1259 2
a1260 2
  /* If we get here, we haven't seen the label before.
     Therefore its instance count is zero.  */
d1264 1
a1264 1
void
d1272 1
a1272 1
void
d1286 1
a1286 1
  /* If we get to here, we don't have label listed yet.  */
d1304 1
a1304 1
    }				/* if we needed to grow  */
d1312 13
a1324 7
/* Caller must copy returned name: we re-use the area for the next name.

   The mth occurence of label n: is turned into the symbol "Ln^Am"
   where n is the label number and m is the instance number. "L" makes
   it a label discarded unless debugging and "^A"('\1') ensures no
   ordinary symbol SHOULD get the same name as a local label
   symbol. The first "4:" is "L4^A1" - the m numbers begin at 1.
d1326 1
a1326 4
   fb labels get the same treatment, except that ^B is used in place
   of ^A.  */

char *				/* Return local label name.  */
d1328 2
a1329 2
     register long n;		/* we just saw "n$:" : n a number.  */
     register int augend;	/* 0 for current instance, 1 for new instance.  */
d1332 1
a1332 1
  /* Returned to caller, then copied.  Used for created names ("4f").  */
d1336 1
a1336 1
  char symbol_name_temporary[20];	/* Build up a number, BACKWARDS.  */
d1346 2
a1347 2
  /* Next code just does sprintf( {}, "%d", n);  */
  /* Label number.  */
d1357 1
a1357 1
  *p++ = DOLLAR_LABEL_CHAR;		/* ^A  */
d1359 1
a1359 1
  /* Instance number.  */
d1368 1
a1368 1
  /* The label, as a '\0' ended string, starts at symbol_name_build.  */
d1372 17
a1388 16
/* Sombody else's idea of local labels. They are made by "n:" where n
   is any decimal digit. Refer to them with
    "nb" for previous (backward) n:
   or "nf" for next (forward) n:.

   We do a little better and let n be any number, not just a single digit, but
   since the other guy's assembler only does ten, we treat the first ten
   specially.

   Like someone else's assembler, we have one set of local label counters for
   entire assembly, not one set per (sub)segment like in most assemblers. This
   implies that one can refer to a label in another segment, and indeed some
   crufty compilers have done just that.

   Since there could be a LOT of these things, treat them as a sparse
   array.  */
d1398 1
a1398 1
/* This must be more than FB_LABEL_SPECIAL.  */
d1401 1
a1401 1
static void
d1405 1
a1405 3
}

/* Add one to the instance number of this fb label.  */
d1407 2
a1408 1
void
d1429 2
a1430 2
	    }			/* if we find it  */
	}			/* for each existing label  */
d1433 1
a1433 1
  /* If we get to here, we don't have label listed yet.  */
d1450 1
a1450 1
    }				/* if we needed to grow  */
d1457 1
a1457 1
static long
d1476 2
a1477 2
	    }			/* if we find it  */
	}			/* for each existing label  */
d1485 12
a1496 1
/* Caller must copy returned name: we re-use the area for the next name.
d1498 1
a1498 10
   The mth occurence of label n: is turned into the symbol "Ln^Bm"
   where n is the label number and m is the instance number. "L" makes
   it a label discarded unless debugging and "^B"('\2') ensures no
   ordinary symbol SHOULD get the same name as a local label
   symbol. The first "4:" is "L4^B1" - the m numbers begin at 1.

   dollar labels get the same treatment, except that ^A is used in
   place of ^B.  */

char *				/* Return local label name.  */
d1500 2
a1501 2
     long n;			/* We just saw "n:", "nf" or "nb" : n a number.  */
     long augend;		/* 0 for nb, 1 for n:, nf.  */
d1504 1
a1504 1
  /* Returned to caller, then copied.  Used for created names ("4f").  */
d1508 1
a1508 1
  char symbol_name_temporary[20];	/* Build up a number, BACKWARDS.  */
a1512 3
#ifdef LOCAL_LABEL_PREFIX
  *p++ = LOCAL_LABEL_PREFIX;
#endif
d1515 2
a1516 2
  /* Next code just does sprintf( {}, "%d", n);  */
  /* Label number.  */
d1526 1
a1526 1
  *p++ = LOCAL_LABEL_CHAR;		/* ^B  */
d1528 1
a1528 1
  /* Instance number.  */
d1537 1
a1537 1
  /* The label, as a '\0' ended string, starts at symbol_name_build.  */
d1539 1
a1539 1
}
d1541 5
a1545 3
/* Decode name that may have been generated by foo_label_name() above.
   If the name wasn't generated by foo_label_name(), then return it
   unaltered.  This is used for error messages.  */
d1556 1
a1556 2
  const char *message_format;
  int index = 0;
d1558 1
a1558 6
#ifdef LOCAL_LABEL_PREFIX
  if (s[index] == LOCAL_LABEL_PREFIX)
    ++index;
#endif

  if (s[index] != 'L')
d1561 1
a1561 1
  for (label_number = 0, p = s + index + 1; isdigit ((unsigned char) *p); ++p)
d1564 1
a1564 1
  if (*p == DOLLAR_LABEL_CHAR)
d1566 1
a1566 1
  else if (*p == LOCAL_LABEL_CHAR)
a1573 1
  message_format = _("\"%d\" (instance number %d of a %s label)");
d1681 1
a1681 1
  /* Sanity check.  */
d1738 1
a1738 1
  /* Sanity check.  */
d1753 2
a1754 2
	  && (strchr (name, DOLLAR_LABEL_CHAR)
	      || strchr (name, LOCAL_LABEL_CHAR)
d1817 1
a1817 1
	abort ();
a1833 11
  if (s->bsym->flags & BSF_SECTION_SYM)
    {
      char * file;
      unsigned int line;
      
      /* Do not reassign section symbols.  */
      as_where (& file, & line);
      as_warn_where (file, line,
		     _("Section symbols are already global"));
      return;
    }
d1835 1
a1835 1
  s->bsym->flags &= ~(BSF_LOCAL | BSF_WEAK);
d1850 1
a1850 1
  s->bsym->flags &= ~(BSF_GLOBAL | BSF_WEAK);
d1860 1
a1860 1
  s->bsym->flags &= ~(BSF_GLOBAL | BSF_LOCAL);
d2128 1
a2128 1
  /* FIXME.  */
d2240 1
a2240 1
  symbol_rootP = NULL;		/* In case we have 0 symbols (!!)  */
d2252 1
a2252 1
  /* Can't initialise a union. Sigh.  */
d2261 2
d2364 1
a2364 1
     const char *name;
d2509 2
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003
d25 2
a28 1
#include "safe-ctype.h"
a63 1
static char *save_symbol_name PARAMS ((const char *));
a68 1
static void report_op_error PARAMS ((symbolS *, symbolS *, symbolS *));
d126 1
a126 1
      char *s;
d128 3
a130 2
      for (s = ret; *s != '\0'; s++)
	*s = TOUPPER (*s);
d209 1
a209 1
local_symbol_make (name, section, value, frag)
d212 1
a212 1
     valueT value;
d227 1
a227 1
  ret->lsy_value = value;
d249 1
a249 1
  ret = symbol_new (locsym->lsy_name, locsym->lsy_section, locsym->lsy_value,
a257 4
#ifdef TC_LOCAL_SYMFIELD_CONVERT
  TC_LOCAL_SYMFIELD_CONVERT (locsym, ret);
#endif

a312 7

      if (now_seg == absolute_section)
	{
	  as_bad (_("cannot define symbol `%s' in absolute section"), sym_name);
	  return NULL;
	}

d356 1
a356 1
		  || locsym->lsy_value != frag_now_fix ()))
d358 1
a358 1
	      as_bad (_("symbol `%s' is already defined"), sym_name);
d364 1
a364 1
	  locsym->lsy_value = frag_now_fix ();
d439 3
a441 3
		    sprintf (od_buf, "%d.%d.",
			     S_GET_OTHER (symbolP),
			     S_GET_DESC (symbolP));
d443 1
a443 1
		  as_bad (_("symbol `%s' is already defined as \"%s\"/%s%ld"),
d457 1
a457 1
	    as_bad (_("symbol `%s' is already defined"), sym_name);
d483 1
a483 1
	 section.  This requires special handling.  */
d520 1
a520 1
	as_fatal (_("inserting \"%s\" into symbol table failed: %s"),
d527 1
a527 1
      as_fatal (_("inserting \"%s\" into symbol table failed: %s"),
d569 1
a569 1
     const char *name;
d589 1
a589 1
     const char *name;
a598 17
symbol_find_exact (name)
     const char *name;
{
#ifdef BFD_ASSEMBLER
  {
    struct local_symbol *locsym;

    locsym = (struct local_symbol *) hash_find (local_hash, name);
    if (locsym != NULL)
      return (symbolS *) locsym;
  }
#endif

  return ((symbolS *) hash_find (sy_hash, name));
}

symbolS *
d600 1
a600 1
     const char *name;
d628 3
a630 1
	  *copy++ = TOUPPER (c);
d635 11
a645 1
  return symbol_find_exact (name);
a824 57
static void
report_op_error (symp, left, right)
     symbolS *symp;
     symbolS *left, *right;
{
  char *file;
  unsigned int line;
  segT seg_left = S_GET_SEGMENT (left);
  segT seg_right = right ? S_GET_SEGMENT (right) : 0;

  if (expr_symbol_where (symp, &file, &line))
    {
      if (seg_left == undefined_section)
	as_bad_where (file, line,
		      _("undefined symbol `%s' in operation"),
		      S_GET_NAME (left));
      if (seg_right == undefined_section)
	as_bad_where (file, line,
		      _("undefined symbol `%s' in operation"),
		      S_GET_NAME (right));
      if (seg_left != undefined_section
	  && seg_right != undefined_section)
	{
	  if (right)
	    as_bad_where (file, line,
			  _("invalid sections for operation on `%s' and `%s'"),
			  S_GET_NAME (left), S_GET_NAME (right));
	  else
	    as_bad_where (file, line,
			  _("invalid section for operation on `%s'"),
			  S_GET_NAME (left));
	}

    }
  else
    {
      if (seg_left == undefined_section)
	as_bad (_("undefined symbol `%s' in operation setting `%s'"),
		S_GET_NAME (left), S_GET_NAME (symp));
      if (seg_right == undefined_section)
	as_bad (_("undefined symbol `%s' in operation setting `%s'"),
		S_GET_NAME (right), S_GET_NAME (symp));
      if (seg_left != undefined_section
	  && seg_right != undefined_section)
	{
	  if (right)
	    as_bad_where (file, line,
			  _("invalid sections for operation on `%s' and `%s' setting `%s'"),
			  S_GET_NAME (left), S_GET_NAME (right), S_GET_NAME (symp));
	  else
	    as_bad_where (file, line,
			  _("invalid section for operation on `%s' setting `%s'"),
			  S_GET_NAME (left), S_GET_NAME (symp));
	}
    }
}

d830 1
a830 1
resolve_symbol_value (symp)
d832 1
d835 1
a835 1
  valueT final_val = 0;
a842 1
      final_val = locsym->lsy_value;
d844 1
a844 1
	return final_val;
d846 2
a847 1
      final_val += local_symbol_get_frag (locsym)->fr_address / OCTETS_PER_BYTE;
d849 1
a849 1
      if (finalize_syms)
d851 1
a851 1
	  locsym->lsy_value = final_val;
d872 2
a873 2
      if (finalize_syms)
	as_bad (_("symbol definition loop encountered at `%s'"),
d912 2
a913 4
	  left = resolve_symbol_value (add_symbol);
	  seg_left = S_GET_SEGMENT (add_symbol);
	  if (finalize_syms)
	    symp->sy_value.X_op_symbol = NULL;
a914 1
	do_symbol:
d918 2
a919 2
		 relocation routines are going to handle it specially.
		 Don't change the value.  */
d924 1
a924 1
	  if (finalize_syms && final_val == 0)
d932 6
a937 6
	  /* If we have equated this symbol to an undefined or common
	     symbol, keep X_op set to O_symbol, and don't change
	     X_add_number.  This permits the routine which writes out
	     relocation to detect this case, and convert the
	     relocation to be against the symbol to which this symbol
	     is equated.  */
d940 1
a940 1
	      if (finalize_syms)
d942 1
a945 3
		  /* Use X_op_symbol as a flag.  */
		  symp->sy_value.X_op_symbol = add_symbol;
		  final_seg = seg_left;
a948 19
	      symp->sy_resolving = 0;
	      goto exit_dont_set_value;
	    }
	  else if (finalize_syms && final_seg == expr_section
		   && seg_left != expr_section)
	    {
	      /* If the symbol is an expression symbol, do similarly
		 as for undefined and common syms above.  Handles
		 "sym +/- expr" where "expr" cannot be evaluated
		 immediately, and we want relocations to be against
		 "sym", eg. because it is weak.  */
	      symp->sy_value.X_op = O_symbol;
	      symp->sy_value.X_add_symbol = add_symbol;
	      symp->sy_value.X_add_number = final_val;
	      symp->sy_value.X_op_symbol = add_symbol;
	      final_seg = seg_left;
	      final_val += symp->sy_frag->fr_address + left;
	      resolved = symbol_resolved_p (add_symbol);
	      symp->sy_resolving = 0;
d955 1
a955 1
		final_seg = seg_left;
d964 1
a964 13
	  left = resolve_symbol_value (add_symbol);
	  seg_left = S_GET_SEGMENT (add_symbol);

	  /* By reducing these to the relevant dyadic operator, we get
	     	!S -> S == 0 	permitted on anything,
		-S -> 0 - S 	only permitted on absolute
		~S -> S ^ ~0 	only permitted on absolute  */
	  if (op != O_logical_not && seg_left != absolute_section
	      && finalize_syms)
	    report_op_error (symp, add_symbol, NULL);

	  if (final_seg == expr_section || final_seg == undefined_section)
	    final_seg = absolute_section;
d974 2
d999 2
a1000 2
	  left = resolve_symbol_value (add_symbol);
	  right = resolve_symbol_value (op_symbol);
d1006 1
a1006 1
	  if (op == O_add)
d1010 6
a1015 1
		  final_val += right;
d1018 1
a1018 1
	      else if (seg_left == absolute_section)
d1020 1
d1024 1
a1024 1
		  seg_left = seg_right;
d1028 15
a1042 1
	  else if (op == O_subtract)
d1044 19
a1062 1
	      if (seg_right == absolute_section)
d1064 12
a1075 2
		  final_val -= right;
		  goto do_symbol;
a1078 24
	  /* Equality and non-equality tests are permitted on anything.
	     Subtraction, and other comparison operators are permitted if
	     both operands are in the same section.  Otherwise, both
	     operands must be absolute.  We already handled the case of
	     addition or subtraction of a constant above.  This will
	     probably need to be changed for an object file format which
	     supports arbitrary expressions, such as IEEE-695.

	     Don't emit messages unless we're finalizing the symbol value,
	     otherwise we may get the same message multiple times.  */
	  if (finalize_syms
	      && !(seg_left == absolute_section
		   && seg_right == absolute_section)
	      && !(op == O_eq || op == O_ne)
	      && !((op == O_subtract
		    || op == O_lt || op == O_le || op == O_ge || op == O_gt)
		   && seg_left == seg_right
		   && (seg_left != undefined_section
		       || add_symbol == op_symbol)))
	    report_op_error (symp, add_symbol, op_symbol);

	  if (final_seg == expr_section || final_seg == undefined_section)
	    final_seg = absolute_section;

d1083 2
a1084 2
		 already issued a warning about using a bad symbol.  */
	      if (seg_right == absolute_section && finalize_syms)
d1092 1
a1092 1
		    as_bad (_("division by zero when setting `%s'"),
d1112 2
a1113 9
	    case O_eq:
	    case O_ne:
	      left = (left == right && seg_left == seg_right
		      && (seg_left != undefined_section
			  || add_symbol == op_symbol)
		      ? ~ (offsetT) 0 : 0);
	      if (symp->sy_value.X_op == O_ne)
		left = ~left;
	      break;
d1125 1
a1125 9
	    {
	      if (seg_left == undefined_section
		  || seg_right == undefined_section)
		final_seg = undefined_section;
	      else if (seg_left == absolute_section)
		final_seg = seg_right;
	      else
		final_seg = seg_left;
	    }
d1144 3
a1146 2
  if (finalize_syms)
    S_SET_VALUE (symp, final_val);
a1147 3
exit_dont_set_value:
  /* Always set the segment, even if not finalizing the value.
     The segment is used to determine whether a symbol is defined.  */
d1149 3
a1151 3
  /* The old a.out backend does not handle S_SET_SEGMENT correctly
     for a stab symbol, so we use this bad hack.  */
  if (final_seg != S_GET_SEGMENT (symp))
d1153 2
a1154 1
    S_SET_SEGMENT (symp, final_seg);
d1156 1
d1158 1
a1158 1
  if (finalize_syms)
d1164 1
a1164 1
	  as_bad (_("can't resolve value for symbol `%s'"),
d1185 1
a1185 1
    resolve_symbol_value (value);
d1545 1
a1545 1
  for (label_number = 0, p = s + index + 1; ISDIGIT (*p); ++p)
d1555 1
a1555 1
  for (instance_number = 0, p++; ISDIGIT (*p); ++p)
d1573 1
a1573 1
    return resolve_symbol_value (s);
d1576 2
a1577 6
  if (!s->sy_resolved)
    {
      valueT val = resolve_symbol_value (s);
      if (!finalize_syms)
	return val;
    }
d1583 2
a1584 2
	 may call S_GET_VALUE.  We use a static symbol to avoid the
	 immediate recursion.  */
d1591 1
a1591 1
	as_bad (_("attempt to get value of unresolved symbol `%s'"),
d1608 1
a1608 1
      ((struct local_symbol *) s)->lsy_value = val;
a1699 24

#ifndef EXTERN_FORCE_RELOC
#define EXTERN_FORCE_RELOC IS_ELF
#endif

/* Return true for symbols that should not be reduced to section
   symbols or eliminated from expressions, because they may be
   overridden by the linker.  */
int
S_FORCE_RELOC (s, strict)
     symbolS *s;
     int strict;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_section == undefined_section;

  return ((strict
	   && ((s->bsym->flags & BSF_WEAK) != 0
	       || (EXTERN_FORCE_RELOC
		   && (s->bsym->flags & BSF_GLOBAL) != 0)))
	  || s->bsym->section == undefined_section
	  || bfd_is_com_section (s->bsym->section));
}

d1761 1
a1761 1
const char *
d1823 1
a1823 1

d1827 1
a1827 1
		     _("section symbols are already global"));
a1859 19
S_SET_THREAD_LOCAL (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  if (bfd_is_com_section (s->bsym->section)
      && (s->bsym->flags & BSF_THREAD_LOCAL) != 0)
    return;
  s->bsym->flags |= BSF_THREAD_LOCAL;
  if ((s->bsym->flags & BSF_FUNCTION) != 0)
    as_bad (_("Accessing function `%s' as thread-local object"),
	    S_GET_NAME (s));
  else if (! bfd_is_und_section (s->bsym->section)
	   && (s->bsym->section->flags & SEC_THREAD_LOCAL) == 0)
    as_bad (_("Accessing `%s' as thread-local object"),
	    S_GET_NAME (s));
}

void
a2139 18
/* Return whether a symbol is equated to another symbol, and should be
   treated specially when writing out relocs.  */

int
symbol_equated_reloc_p (s)
     symbolS *s;
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  /* X_op_symbol, normally not used for O_symbol, is set by
     resolve_symbol_value to flag expression syms that have been
     equated.  */
  return (s->sy_value.X_op == O_symbol
	  && ((s->sy_resolved && s->sy_value.X_op_symbol != NULL)
	      || ! S_IS_DEFINED (s)
	      || S_IS_COMMON (s)));
}

d2325 1
a2325 1
	  && s != expr_section)
d2336 1
a2336 1
		 (long) ((struct local_symbol *) sym)->lsy_value);
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d63 4
a66 4
static char *save_symbol_name (const char *);
static void fb_label_init (void);
static long dollar_label_instance (long);
static long fb_label_instance (long);
d68 2
a69 2
static void print_binary (FILE *, const char *, expressionS *);
static void report_op_error (symbolS *, symbolS *, symbolS *);
d81 5
a85 1
symbol_new (const char *name, segT segment, valueT valu, fragS *frag)
d106 2
a107 1
save_symbol_name (const char *name)
d137 5
a141 4
symbol_create (const char *name, /* It is copied, the caller can destroy/modify.  */
	       segT segment,	/* Segment identifier (SEG_<something>).  */
	       valueT valu,	/* Symbol value.  */
	       fragS *frag	/* Associated fragment.  */)
d185 3
a187 1
static symbolS *local_symbol_convert (struct local_symbol *);
d208 6
a213 2
struct local_symbol *
local_symbol_make (const char *name, segT section, valueT value, fragS *frag)
d238 2
a239 1
local_symbol_convert (struct local_symbol *locsym)
d285 3
a287 3
colon (/* Just seen "x:" - rattle symbols & frags.  */
       const char *sym_name	/* Symbol name, as a cannonical string.  */
       /* We copy this string: OK to alter later.  */)
d518 2
a519 1
symbol_table_insert (symbolS *symbolP)
d547 2
a548 1
symbol_find_or_make (const char *name)
d579 2
a580 1
symbol_make (const char *name)
a592 18
symbolS *
symbol_temp_new (segT seg, valueT ofs, fragS *frag)
{
  return symbol_new (FAKE_LABEL_NAME, seg, ofs, frag);
}

symbolS *
symbol_temp_new_now (void)
{
  return symbol_temp_new (now_seg, frag_now_fix (), frag_now);
}

symbolS *
symbol_temp_make (void)
{
  return symbol_make (FAKE_LABEL_NAME);
}

d599 2
a600 1
symbol_find (const char *name)
d610 2
a611 1
symbol_find_exact (const char *name)
d627 3
a629 1
symbol_find_base (const char *name, int strip_underscore)
d673 5
a677 2
symbol_append (symbolS *addme, symbolS *target,
	       symbolS **rootPP, symbolS **lastPP)
d722 2
a723 1
symbol_clear_list_pointers (symbolS *symbolP)
d737 4
a740 1
symbol_remove (symbolS *symbolP, symbolS **rootPP, symbolS **lastPP)
d771 5
a775 2
symbol_insert (symbolS *addme, symbolS *target,
	       symbolS **rootPP, symbolS **lastPP ATTRIBUTE_UNUSED)
d802 3
a804 1
verify_symbol_chain (symbolS *rootP, symbolS *lastP)
d828 2
a829 1
verify_symbol_chain_2 (symbolS *sym)
d842 3
a844 1
report_op_error (symbolS *symp, symbolS *left, symbolS *right)
d903 2
a904 1
resolve_symbol_value (symbolS *symp)
d1272 1
a1272 1
static void resolve_local_symbol (const char *, PTR);
d1277 3
a1279 1
resolve_local_symbol (const char *key ATTRIBUTE_UNUSED, PTR value)
d1290 1
a1290 1
resolve_local_symbol_values (void)
d1311 2
a1312 1
dollar_label_defined (long label)
d1327 2
a1328 1
dollar_label_instance (long label)
d1344 1
a1344 1
dollar_label_clear (void)
d1352 2
a1353 1
define_dollar_label (long label)
d1403 3
a1405 2
dollar_label_name (register long n,	/* we just saw "n$:" : n a number.  */
		   register int augend	/* 0 for current instance, 1 for new instance.  */)
d1448 1
a1448 1
/* Somebody else's idea of local labels. They are made by "n:" where n
d1477 1
a1477 1
fb_label_init (void)
d1485 2
a1486 1
fb_label_instance_inc (long label)
d1534 2
a1535 1
fb_label_instance (long label)
d1573 3
a1575 2
fb_label_name (long n,	/* We just saw "n:", "nf" or "nb" : n a number.  */
	       long augend	/* 0 for nb, 1 for n:, nf.  */)
d1623 2
a1624 1
decode_local_label_name (char *s)
d1665 2
a1666 1
S_GET_VALUE (symbolS *s)
d1702 3
a1704 1
S_SET_VALUE (symbolS *s, valueT val)
d1720 2
a1721 1
copy_symbol_attributes (symbolS *dest, symbolS *src)
d1743 2
a1744 1
S_IS_FUNCTION (symbolS *s)
d1757 2
a1758 1
S_IS_EXTERNAL (symbolS *s)
d1775 2
a1776 1
S_IS_WEAK (symbolS *s)
d1784 2
a1785 1
S_IS_COMMON (symbolS *s)
d1793 2
a1794 1
S_IS_DEFINED (symbolS *s)
d1810 3
a1812 1
S_FORCE_RELOC (symbolS *s, int strict)
d1826 2
a1827 1
S_IS_DEBUG (symbolS *s)
d1837 2
a1838 1
S_IS_LOCAL (symbolS *s)
d1873 2
a1874 1
S_IS_EXTERN (symbolS *s)
d1880 2
a1881 1
S_IS_STABD (symbolS *s)
d1887 2
a1888 1
S_GET_NAME (symbolS *s)
d1896 2
a1897 1
S_GET_SEGMENT (symbolS *s)
d1905 3
a1907 1
S_SET_SEGMENT (symbolS *s, segT seg)
d1934 2
a1935 1
S_SET_EXTERNAL (symbolS *s)
d1960 2
a1961 1
S_CLEAR_EXTERNAL (symbolS *s)
d1975 2
a1976 1
S_SET_WEAK (symbolS *s)
d1985 2
a1986 1
S_SET_THREAD_LOCAL (symbolS *s)
d2004 3
a2006 1
S_SET_NAME (symbolS *s, char *name)
d2022 2
a2023 1
symbol_previous (symbolS *s)
d2035 2
a2036 1
symbol_next (symbolS *s)
d2046 2
a2047 1
symbol_get_value_expression (symbolS *s)
d2057 3
a2059 1
symbol_set_value_expression (symbolS *s, const expressionS *exp)
a2065 10
/* Set the value of SYM to the current position in the current segment.  */

void
symbol_set_value_now (symbolS *sym)
{
  S_SET_SEGMENT (sym, now_seg);
  S_SET_VALUE (sym, frag_now_fix ());
  symbol_set_frag (sym, frag_now);
}

d2069 3
a2071 1
symbol_set_frag (symbolS *s, fragS *f)
d2086 2
a2087 1
symbol_get_frag (symbolS *s)
d2099 2
a2100 1
symbol_mark_used (symbolS *s)
d2110 2
a2111 1
symbol_clear_used (symbolS *s)
d2121 2
a2122 1
symbol_used_p (symbolS *s)
d2132 2
a2133 1
symbol_mark_used_in_reloc (symbolS *s)
d2143 2
a2144 1
symbol_clear_used_in_reloc (symbolS *s)
d2154 2
a2155 1
symbol_used_in_reloc_p (symbolS *s)
d2165 2
a2166 1
symbol_mark_mri_common (symbolS *s)
d2176 2
a2177 1
symbol_clear_mri_common (symbolS *s)
d2187 2
a2188 1
symbol_mri_common_p (symbolS *s)
d2198 2
a2199 1
symbol_mark_written (symbolS *s)
d2209 2
a2210 1
symbol_clear_written (symbolS *s)
d2220 2
a2221 1
symbol_written_p (symbolS *s)
d2231 2
a2232 1
symbol_mark_resolved (symbolS *s)
d2247 2
a2248 1
symbol_resolved_p (symbolS *s)
d2260 2
a2261 1
symbol_section_p (symbolS *s ATTRIBUTE_UNUSED)
d2276 2
a2277 1
symbol_equated_p (symbolS *s)
d2288 2
a2289 1
symbol_equated_reloc_p (symbolS *s)
d2305 2
a2306 1
symbol_constant_p (symbolS *s)
d2318 2
a2319 1
symbol_get_bfdsym (symbolS *s)
d2329 3
a2331 1
symbol_set_bfdsym (symbolS *s, asymbol *bsym)
d2345 2
a2346 1
symbol_get_obj (symbolS *s)
d2356 3
a2358 1
symbol_set_obj (symbolS *s, OBJ_SYMFIELD_TYPE *o)
d2372 2
a2373 1
symbol_get_tc (symbolS *s)
d2383 3
a2385 1
symbol_set_tc (symbolS *s, TC_SYMFIELD_TYPE *o)
d2395 1
a2395 1
symbol_begin (void)
d2429 1
a2429 1
indent (void)
d2437 3
a2439 1
print_symbol_value_1 (FILE *file, symbolS *sym)
d2509 2
a2510 1
print_symbol_value (symbolS *sym)
d2518 4
a2521 1
print_binary (FILE *file, const char *name, expressionS *exp)
d2533 3
a2535 1
print_expr_1 (FILE *file, expressionS *exp)
d2647 2
a2648 1
print_expr (expressionS *exp)
d2655 2
a2656 1
symbol_print_statistics (FILE *file)
@


