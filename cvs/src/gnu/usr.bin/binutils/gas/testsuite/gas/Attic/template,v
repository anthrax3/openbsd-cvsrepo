head	1.2;
access;
symbols
	OPENBSD_3_5:1.1.0.34
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.32
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.30
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.28
	OPENBSD_3_2_BASE:1.1
	binutils-2_11_2:1.1.1.1
	OPENBSD_3_1:1.1.0.26
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.24
	OPENBSD_3_0_BASE:1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.0.22
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.20
	OPENBSD_2_8_BASE:1.1
	BINUTILS-2_10:1.1.1.1
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2004.05.17.21.54.33;	author drahn;	state dead;
branches;
next	1.1;

1.1
date	96.01.08.11.06.33;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.06.33;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@#
# This is sort of a prototype test case, which parses the listing output
# from the assembler.  Later, more prototypes should be added for cases
# where objdump gets run over the .o file, and anything else like that...
#
# When you write a test case that uses the listing output, just copy this
# file (trimming down the overly-verbose comments a little), and
# adjust it to do what you need.
#
# Remember that any ".exp" file found in the tree will be processed by
# dejagnu.

#
# FIRST SAMPLE TEST CASE
#

proc do_foo {} {
# This string is used below when printing out a success or failure message.
# If more than one test is run by a given .exp file, it'd be nice to include
# the name of the input file.
    set testname "foo.s: multi-register tweaking and frobnication"

# I use this as a flag to record whether the test case passed.  If this
# flag is still clear when EOF is reached, this test fails.  If there are
# two or more patterns, and I need to see all of them, I'll create N variables
# and check if the sum is N.
    set x 0

# Call gas_start with two arguments: The input file name (which it'll search
# for in $srcdir/$subdir, that is, the source directory where the .exp file
# is), and a (possibly empty) string of options to pass to the assembler.
    gas_start "foo.s" "-al"

# Now I just iterate over all the output lines, looking for what I want
# to see.  Since each pattern explicitly will not span line breaks, there's
# also a pattern for lines that don't match anything else.   (Is it safe to
# use ".*" for patterns not crossing line breaks? I don't think "$" does the
# right thing for that, in any case.  I should check into whether the extra
# pattern is even needed.

# Apparently CRLF is received when using ptys for subprocesses; hence the
# \r\n for matching line number 3.

# Note that if you use "{ ... }" for the expect clause, you can't have
# comments inside it.

# This test case is kinda bogus in that seeing either a word of all zeros
# at address zero or a C-style comment on line three that says "Looking for
# C comments" (with very specific punctuation and whitespace) will cause
# it to pass this test.  Usually 
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 00000000\[^\n\]*\n"		{ set x 1 }
	    -re "^ +3\[ \t\]+/. Looking for C comments. ./\r\n"	{ set x 1 }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }
# This was intended to do any cleanup necessary.  It kinda looks like it isn't
# needed, but just in case, please keep it in for now.
    gas_finish

# Did we find what we were looking for?  If not, flunk it.
    if $x then { pass $testname } else { fail $testname }
}

# Now actually run the test.  It can be conditionalized if the test is
# not appropriate for all targets.  The proc "istarget" checks a generalized
# form of the target name, so that (e.g.) "m68332-unknown-aout" would match
# here.  So far, I think only the CPU name is actually ever altered.
if [istarget m68k-*] then {
    do_foo
}




#
# SECOND SAMPLE TEST CASE
#

# This is a tiny bit like the C compiler torture tests, in that it'll run
# the assembler with the power set of the list of options supplied.
#
# The first argument is the test file name; the second is arguments that
# are always to be provided; the third is a space-separated list of options
# which are optional (ending in ">" if output should be ignored, like "-a>");
# the fourth is the name of the test.  So far, only binary options are handled
# this way; N-way options (like CPU type for m68k) aren't handled yet.
#
# The variable $stdoptlist usually has a reasonable set of optional options
# for this target.

# No, PIC isn't supported yet.  This is only an example.
gas_test "quux.s" "-K" $stdoptlist "use of quuxes in PIC mode"
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@
