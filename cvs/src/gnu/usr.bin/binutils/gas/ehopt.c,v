head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.4.0.48
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.44
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.46
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.38
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.42
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.40
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.36
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.34
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.32
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.30
	OPENBSD_5_0:1.1.1.4.0.28
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.26
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.24
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.20
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.22
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.18
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.16
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.14
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.12
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.10
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.8
	OPENBSD_4_0_BASE:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	BINUTILS_2_15:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	BINUTILS-2_14:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	BINUTILS-2_10:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.09.12.14.46.09;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.12.14.46.09;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.31.41;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.05.17.20.42.25;	author drahn;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.11.02.20.22.43;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* ehopt.c--optimize gcc exception frame information.
   Copyright (C) 1998 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>.

This file is part of GAS, the GNU Assembler.

GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA. */

#include "as.h"
#include "subsegs.h"

/* We include this ELF file, even though we may not be assembling for
   ELF, since the exception frame information is always in a format
   derived from DWARF.  */

#include "elf/dwarf2.h"

/* Try to optimize gcc 2.8 exception frame information.

   Exception frame information is emitted for every function in the
   .eh_frame section.  Simple information for a function with no
   exceptions looks like this:

__FRAME_BEGIN__:
	.4byte	.LLCIE1	/ Length of Common Information Entry
.LSCIE1:
	.4byte	0x0	/ CIE Identifier Tag
	.byte	0x1	/ CIE Version
	.byte	0x0	/ CIE Augmentation (none)
	.byte	0x1	/ ULEB128 0x1 (CIE Code Alignment Factor)
	.byte	0x7c	/ SLEB128 -4 (CIE Data Alignment Factor)
	.byte	0x8	/ CIE RA Column
	.byte	0xc	/ DW_CFA_def_cfa
	.byte	0x4	/ ULEB128 0x4
	.byte	0x4	/ ULEB128 0x4
	.byte	0x88	/ DW_CFA_offset, column 0x8
	.byte	0x1	/ ULEB128 0x1
	.align 4
.LECIE1:
	.set	.LLCIE1,.LECIE1-.LSCIE1	/ CIE Length Symbol
	.4byte	.LLFDE1	/ FDE Length
.LSFDE1:
	.4byte	.LSFDE1-__FRAME_BEGIN__	/ FDE CIE offset
	.4byte	.LFB1	/ FDE initial location
	.4byte	.LFE1-.LFB1	/ FDE address range
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI0-.LFB1
	.byte	0xe	/ DW_CFA_def_cfa_offset
	.byte	0x8	/ ULEB128 0x8
	.byte	0x85	/ DW_CFA_offset, column 0x5
	.byte	0x2	/ ULEB128 0x2
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI1-.LCFI0
	.byte	0xd	/ DW_CFA_def_cfa_register
	.byte	0x5	/ ULEB128 0x5
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI2-.LCFI1
	.byte	0x2e	/ DW_CFA_GNU_args_size
	.byte	0x4	/ ULEB128 0x4
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI3-.LCFI2
	.byte	0x2e	/ DW_CFA_GNU_args_size
	.byte	0x0	/ ULEB128 0x0
	.align 4
.LEFDE1:
	.set	.LLFDE1,.LEFDE1-.LSFDE1	/ FDE Length Symbol

   The immediate issue we can address in the assembler is the
   DW_CFA_advance_loc4 followed by a four byte value.  The value is
   the difference of two addresses in the function.  Since gcc does
   not know this value, it always uses four bytes.  We will know the
   value at the end of assembly, so we can do better.  */

static int eh_frame_code_alignment PARAMS ((void));

/* Get the code alignment factor from the CIE.  */

static int
eh_frame_code_alignment ()
{
  static int code_alignment;
  segT current_seg;
  subsegT current_subseg;
  fragS *f;
  fixS *fix;
  int offset;
  char augmentation[10];
  int iaug;

  if (code_alignment != 0)
    return code_alignment;

  /* We should find the CIE at the start of the .eh_frame section.  */

  current_seg = now_seg;
  current_subseg = now_subseg;
  subseg_new (".eh_frame", 0);
#if defined (BFD_ASSEMBLER) || defined (MANY_SEGMENTS)
  f = seg_info (now_seg)->frchainP->frch_root;
#else
  f = frchain_now->frch_root;
#endif
#ifdef BFD_ASSEMBLER
  fix = seg_info (now_seg)->frchainP->fix_root;
#else
  fix = *seg_fix_rootP;
#endif
  subseg_set (current_seg, current_subseg);

  /* Look through the frags of the section to find the code alignment.  */

  /* First make sure that the CIE Identifier Tag is 0.  */

  offset = 4;
  while (f != NULL && offset >= f->fr_fix)
    {
      offset -= f->fr_fix;
      f = f->fr_next;
    }
  if (f == NULL
      || f->fr_fix - offset < 4
      || f->fr_literal[offset] != 0
      || f->fr_literal[offset + 1] != 0
      || f->fr_literal[offset + 2] != 0
      || f->fr_literal[offset + 3] != 0)
    {
      code_alignment = -1;
      return -1;
    }

  /* Next make sure the CIE version number is 1.  */

  offset += 4;
  while (f != NULL && offset >= f->fr_fix)
    {
      offset -= f->fr_fix;
      f = f->fr_next;
    }
  if (f == NULL
      || f->fr_fix - offset < 1
      || f->fr_literal[offset] != 1)
    {
      code_alignment = -1;
      return -1;
    }

  /* Skip the augmentation (a null terminated string).  */

  iaug = 0;
  ++offset;
  while (1)
    {
      while (f != NULL && offset >= f->fr_fix)
	{
	  offset -= f->fr_fix;
	  f = f->fr_next;
	}
      if (f == NULL)
	{
	  code_alignment = -1;
	  return -1;
	}
      while (offset < f->fr_fix && f->fr_literal[offset] != '\0')
	{
	  if ((size_t) iaug < (sizeof augmentation) - 1)
	    {
	      augmentation[iaug] = f->fr_literal[offset];
	      ++iaug;
	    }
	  ++offset;
	}
      if (offset < f->fr_fix)
	break;
    }
  ++offset;
  while (f != NULL && offset >= f->fr_fix)
    {
      offset -= f->fr_fix;
      f = f->fr_next;
    }
  if (f == NULL)
    {
      code_alignment = -1;
      return -1;
    }

  augmentation[iaug] = '\0';
  if (augmentation[0] == '\0')
    {
      /* No augmentation.  */
    }
  else if (strcmp (augmentation, "eh") == 0)
    {
      /* We have to skip a pointer.  Unfortunately, we don't know how
	 large it is.  We find out by looking for a matching fixup.  */
      while (fix != NULL
	     && (fix->fx_frag != f || fix->fx_where != offset))
	fix = fix->fx_next;
      if (fix == NULL)
	offset += 4;
      else
	offset += fix->fx_size;
      while (f != NULL && offset >= f->fr_fix)
	{
	  offset -= f->fr_fix;
	  f = f->fr_next;
	}
      if (f == NULL)
	{
	  code_alignment = -1;
	  return -1;
	}
    }
  else
    {
      code_alignment = -1;
      return -1;
    }

  /* We're now at the code alignment factor, which is a ULEB128.  If
     it isn't a single byte, forget it.  */

  code_alignment = f->fr_literal[offset] & 0xff;
  if ((code_alignment & 0x80) != 0 || code_alignment == 0)
    {
      code_alignment = -1;
      return -1;
    }

  return code_alignment;
}

/* This function is called from emit_expr.  It looks for cases which
   we can optimize.

   Rather than try to parse all this information as we read it, we
   look for a single byte DW_CFA_advance_loc4 followed by a 4 byte
   difference.  We turn that into a rs_cfa_advance frag, and handle
   those frags at the end of the assembly.  If the gcc output changes
   somewhat, this optimization may stop working.

   This function returns non-zero if it handled the expression and
   emit_expr should not do anything, or zero otherwise.  It can also
   change *EXP and *PNBYTES.  */

int
check_eh_frame (exp, pnbytes)
     expressionS *exp;
     unsigned int *pnbytes;
{
  static int saw_size;
  static symbolS *size_end_sym;
  static int saw_advance_loc4;
  static fragS *loc4_frag;
  static int loc4_fix;

  if (saw_size
      && S_IS_DEFINED (size_end_sym))
    {
      /* We have come to the end of the CIE or FDE.  See below where
         we set saw_size.  We must check this first because we may now
         be looking at the next size.  */
      saw_size = 0;
      saw_advance_loc4 = 0;
    }

  if (flag_traditional_format)
    {
      /* Don't optimize.  */
    }
  else if (strcmp (segment_name (now_seg), ".eh_frame") != 0)
    {
      saw_size = 0;
      saw_advance_loc4 = 0;
    }
  else if (! saw_size
	   && *pnbytes == 4)
    {
      /* This might be the size of the CIE or FDE.  We want to know
         the size so that we don't accidentally optimize across an FDE
         boundary.  We recognize the size in one of two forms: a
         symbol which will later be defined as a difference, or a
         subtraction of two symbols.  Either way, we can tell when we
         are at the end of the FDE because the symbol becomes defined
         (in the case of a subtraction, the end symbol, from which the
         start symbol is being subtracted).  Other ways of describing
         the size will not be optimized.  */
      if ((exp->X_op == O_symbol || exp->X_op == O_subtract)
	  && ! S_IS_DEFINED (exp->X_add_symbol))
	{
	  saw_size = 1;
	  size_end_sym = exp->X_add_symbol;
	}
    }
  else if (saw_size
	   && *pnbytes == 1
	   && exp->X_op == O_constant
	   && exp->X_add_number == DW_CFA_advance_loc4)
    {
      /* This might be a DW_CFA_advance_loc4.  Record the frag and the
         position within the frag, so that we can change it later.  */
      saw_advance_loc4 = 1;
      frag_grow (1);
      loc4_frag = frag_now;
      loc4_fix = frag_now_fix ();
    }
  else if (saw_advance_loc4
	   && *pnbytes == 4
	   && exp->X_op == O_constant)
    {
      int ca;

      /* This is a case which we can optimize.  The two symbols being
         subtracted were in the same frag and the expression was
         reduced to a constant.  We can do the optimization entirely
         in this function.  */

      saw_advance_loc4 = 0;

      ca = eh_frame_code_alignment ();
      if (ca < 0)
	{
	  /* Don't optimize.  */
	}
      else if (exp->X_add_number % ca == 0
	       && exp->X_add_number / ca < 0x40)
	{
	  loc4_frag->fr_literal[loc4_fix]
	    = DW_CFA_advance_loc | (exp->X_add_number / ca);
	  /* No more bytes needed.  */
	  return 1;
	}
      else if (exp->X_add_number < 0x100)
	{
	  loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc1;
	  *pnbytes = 1;
	}
      else if (exp->X_add_number < 0x10000)
	{
	  loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc2;
	  *pnbytes = 2;
	}
    }
  else if (saw_advance_loc4
	   && *pnbytes == 4
	   && exp->X_op == O_subtract)
    {

      /* This is a case we can optimize.  The expression was not
         reduced, so we can not finish the optimization until the end
         of the assembly.  We set up a variant frag which we handle
         later.  */

      saw_advance_loc4 = 0;

      frag_var (rs_cfa, 4, 0, 0, make_expr_symbol (exp),
		loc4_fix, (char *) loc4_frag);

      return 1;
    }
  else
    saw_advance_loc4 = 0;

  return 0;
}

/* The function estimates the size of a rs_cfa variant frag based on
   the current values of the symbols.  It is called before the
   relaxation loop.  We set fr_subtype to the expected length.  */

int
eh_frame_estimate_size_before_relax (frag)
     fragS *frag;
{
  int ca;
  offsetT diff;
  int ret;

  ca = eh_frame_code_alignment ();
  diff = resolve_symbol_value (frag->fr_symbol, 0);

  if (ca < 0)
    ret = 4;
  else if (diff % ca == 0 && diff / ca < 0x40)
    ret = 0;
  else if (diff < 0x100)
    ret = 1;
  else if (diff < 0x10000)
    ret = 2;
  else
    ret = 4;

  frag->fr_subtype = ret;

  return ret;
}

/* This function relaxes a rs_cfa variant frag based on the current
   values of the symbols.  fr_subtype is the current length of the
   frag.  This returns the change in frag length.  */

int
eh_frame_relax_frag (frag)
     fragS *frag;
{
  int oldsize, newsize;

  oldsize = frag->fr_subtype;
  newsize = eh_frame_estimate_size_before_relax (frag);
  return newsize - oldsize;
}

/* This function converts a rs_cfa variant frag into a normal fill
   frag.  This is called after all relaxation has been done.
   fr_subtype will be the desired length of the frag.  */

void
eh_frame_convert_frag (frag)
     fragS *frag;
{
  offsetT diff;
  fragS *loc4_frag;
  int loc4_fix;

  loc4_frag = (fragS *) frag->fr_opcode;
  loc4_fix = (int) frag->fr_offset;

  diff = resolve_symbol_value (frag->fr_symbol, 1);

  if (frag->fr_subtype == 0)
    {
      int ca;

      ca = eh_frame_code_alignment ();
      assert (ca > 0 && diff % ca == 0 && diff / ca < 0x40);
      loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc | (diff / ca);
    }
  else if (frag->fr_subtype == 1)
    {
      assert (diff < 0x100);
      loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc1;
      frag->fr_literal[frag->fr_fix] = diff;
    }
  else if (frag->fr_subtype == 2)
    {
      assert (diff < 0x10000);
      loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc2;
      md_number_to_chars (frag->fr_literal + frag->fr_fix, diff, 2);
    }
  else
    md_number_to_chars (frag->fr_literal + frag->fr_fix, diff, 4);

  frag->fr_fix += frag->fr_subtype;
  frag->fr_type = rs_fill;
  frag->fr_offset = 0;
}
@


1.1.1.1
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1998, 2000, 2001 Free Software Foundation, Inc.
d20 1
a20 1
02111-1307, USA.  */
d34 2
a35 2
   .eh_frame or .debug_frame sections.  Simple information for a function
   with no exceptions looks like this:
a39 1
#if .eh_frame
a40 3
#elif .debug_frame
	.4byte	0xffffffff / CIE Identifier Tag
#endif
d87 1
a87 7
struct cie_info
{
  unsigned code_alignment;
  int z_augmentation;
};

static int get_cie_info PARAMS ((struct cie_info *));
d89 1
a89 1
/* Extract information from the CIE.  */
d92 1
a92 2
get_cie_info (info)
     struct cie_info *info;
d94 3
a99 1
  char CIE_id;
a101 1
  int code_alignment = 0;
d103 2
a104 1
  /* We should find the CIE at the start of the section.  */
d106 5
d121 1
d125 1
a125 6
  /* First make sure that the CIE Identifier Tag is 0/-1.  */

  if (strcmp (segment_name (now_seg), ".debug_frame") == 0)
    CIE_id = (char)0xff;
  else
    CIE_id = 0;
d135 8
a142 5
      || f->fr_literal[offset] != CIE_id
      || f->fr_literal[offset + 1] != CIE_id
      || f->fr_literal[offset + 2] != CIE_id
      || f->fr_literal[offset + 3] != CIE_id)
    return 0;
d155 4
a158 1
    return 0;
d172 4
a175 2
	return 0;

d195 4
a198 1
    return 0;
d222 9
a230 1
	return 0;
a231 2
  else if (augmentation[0] != 'z')
    return 0;
d237 5
a241 5
  if ((code_alignment & 0x80) != 0)
    code_alignment = 0;

  info->code_alignment = code_alignment;
  info->z_augmentation = (augmentation[0] == 'z');
d243 1
a243 1
  return 1;
d264 5
a268 41
  struct frame_data
  {
    enum frame_state
    {
      state_idle,
      state_saw_size,
      state_saw_cie_offset,
      state_saw_pc_begin,
      state_seeing_aug_size,
      state_skipping_aug,
      state_wait_loc4,
      state_saw_loc4,
      state_error,
    } state;

    int cie_info_ok;
    struct cie_info cie_info;

    symbolS *size_end_sym;
    fragS *loc4_frag;
    int loc4_fix;

    int aug_size;
    int aug_shift;
  };

  static struct frame_data eh_frame_data;
  static struct frame_data debug_frame_data;
  struct frame_data *d;

  /* Don't optimize.  */
  if (flag_traditional_format)
    return 0;

  /* Select the proper section data.  */
  if (strcmp (segment_name (now_seg), ".eh_frame") == 0)
    d = &eh_frame_data;
  else if (strcmp (segment_name (now_seg), ".debug_frame") == 0)
    d = &debug_frame_data;
  else
    return 0;
d270 2
a271 1
  if (d->state >= state_saw_size && S_IS_DEFINED (d->size_end_sym))
d276 2
a277 1
      d->state = state_idle;
d280 11
a290 1
  switch (d->state)
d292 11
a302 2
    case state_idle:
      if (*pnbytes == 4)
d304 2
a305 15
	  /* This might be the size of the CIE or FDE.  We want to know
	     the size so that we don't accidentally optimize across an FDE
	     boundary.  We recognize the size in one of two forms: a
	     symbol which will later be defined as a difference, or a
	     subtraction of two symbols.  Either way, we can tell when we
	     are at the end of the FDE because the symbol becomes defined
	     (in the case of a subtraction, the end symbol, from which the
	     start symbol is being subtracted).  Other ways of describing
	     the size will not be optimized.  */
	  if ((exp->X_op == O_symbol || exp->X_op == O_subtract)
	      && ! S_IS_DEFINED (exp->X_add_symbol))
	    {
	      d->state = state_saw_size;
	      d->size_end_sym = exp->X_add_symbol;
	    }
d307 23
a329 1
      break;
d331 4
a334 12
    case state_saw_size:
    case state_saw_cie_offset:
      /* Assume whatever form it appears in, it appears atomically.  */
      d->state += 1;
      break;

    case state_saw_pc_begin:
      /* Decide whether we should see an augmentation.  */
      if (! d->cie_info_ok
	  && ! (d->cie_info_ok = get_cie_info (&d->cie_info)))
	d->state = state_error;
      else if (d->cie_info.z_augmentation)
d336 1
a336 3
	  d->state = state_seeing_aug_size;
	  d->aug_size = 0;
	  d->aug_shift = 0;
d338 2
a339 7
      else
	d->state = state_wait_loc4;
      break;

    case state_seeing_aug_size:
      /* Bytes == -1 means this comes from an leb128 directive.  */
      if ((int)*pnbytes == -1 && exp->X_op == O_constant)
d341 4
a344 2
	  d->aug_size = exp->X_add_number;
	  d->state = state_skipping_aug;
d346 1
a346 1
      else if (*pnbytes == 1 && exp->X_op == O_constant)
d348 2
a349 5
	  unsigned char byte = exp->X_add_number;
	  d->aug_size |= (byte & 0x7f) << d->aug_shift;
	  d->aug_shift += 7;
	  if ((byte & 0x80) == 0)
	    d->state = state_skipping_aug;
d351 1
a351 8
      else
	d->state = state_error;
      break;

    case state_skipping_aug:
      if ((int)*pnbytes < 0)
	d->state = state_error;
      else
d353 2
a354 5
          int left = (d->aug_size -= *pnbytes);
	  if (left == 0)
	    d->state = state_wait_loc4;
	  else if (left < 0)
	    d->state = state_error;
d356 5
a360 1
      break;
d362 4
a365 13
    case state_wait_loc4:
      if (*pnbytes == 1
	  && exp->X_op == O_constant
	  && exp->X_add_number == DW_CFA_advance_loc4)
	{
	  /* This might be a DW_CFA_advance_loc4.  Record the frag and the
	     position within the frag, so that we can change it later.  */
	  frag_grow (1);
	  d->state = state_saw_loc4;
	  d->loc4_frag = frag_now;
	  d->loc4_fix = frag_now_fix ();
	}
      break;
d367 1
a367 43
    case state_saw_loc4:
      d->state = state_wait_loc4;
      if (*pnbytes != 4)
	break;
      if (exp->X_op == O_constant)
	{
	  /* This is a case which we can optimize.  The two symbols being
	     subtracted were in the same frag and the expression was
	     reduced to a constant.  We can do the optimization entirely
	     in this function.  */
	  if (d->cie_info.code_alignment > 0
	      && exp->X_add_number % d->cie_info.code_alignment == 0
	      && exp->X_add_number / d->cie_info.code_alignment < 0x40)
	    {
	      d->loc4_frag->fr_literal[d->loc4_fix]
		= DW_CFA_advance_loc
		  | (exp->X_add_number / d->cie_info.code_alignment);
	      /* No more bytes needed.  */
	      return 1;
	    }
	  else if (exp->X_add_number < 0x100)
	    {
	      d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc1;
	      *pnbytes = 1;
	    }
	  else if (exp->X_add_number < 0x10000)
	    {
	      d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc2;
	      *pnbytes = 2;
	    }
	}
      else if (exp->X_op == O_subtract)
	{
	  /* This is a case we can optimize.  The expression was not
	     reduced, so we can not finish the optimization until the end
	     of the assembly.  We set up a variant frag which we handle
	     later.  */
	  int fr_subtype;

	  if (d->cie_info.code_alignment > 0)
	    fr_subtype = d->cie_info.code_alignment << 3;
	  else
	    fr_subtype = 0;
d369 2
a370 5
	  frag_var (rs_cfa, 4, 0, fr_subtype, make_expr_symbol (exp),
		    d->loc4_fix, (char *) d->loc4_frag);
	  return 1;
	}
      break;
d372 1
a372 3
    case state_error:
      /* Just skipping everything.  */
      break;
d374 2
d382 1
a382 1
   relaxation loop.  We set fr_subtype{0:2} to the expected length.  */
d388 1
a389 1
  int ca = frag->fr_subtype >> 3;
d392 1
d395 3
a397 1
  if (ca > 0 && diff % ca == 0 && diff / ca < 0x40)
d406 1
a406 1
  frag->fr_subtype = (frag->fr_subtype & ~7) | ret;
d412 2
a413 2
   values of the symbols.  fr_subtype{0:2} is the current length of
   the frag.  This returns the change in frag length.  */
d421 1
a421 1
  oldsize = frag->fr_subtype & 7;
d428 1
a428 1
   fr_subtype{0:2} will be the desired length of the frag.  */
d443 1
a443 1
  switch (frag->fr_subtype & 7)
d445 1
a445 7
    case 0:
      {
	int ca = frag->fr_subtype >> 3;
	assert (ca > 0 && diff % ca == 0 && diff / ca < 0x40);
	loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc | (diff / ca);
      }
      break;
d447 6
a452 1
    case 1:
d456 3
a458 3
      break;

    case 2:
a461 5
      break;

    default:
      md_number_to_chars (frag->fr_literal + frag->fr_fix, diff, 4);
      break;
d463 2
d466 1
a466 1
  frag->fr_fix += frag->fr_subtype & 7;
a467 1
  frag->fr_subtype = 0;
@


1.1.1.3
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d2 1
a2 1
   Copyright 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
a365 2
      if (d->state == state_skipping_aug && d->aug_size == 0)
	d->state = state_wait_loc4;
d373 1
a373 1
	  int left = (d->aug_size -= *pnbytes);
d465 1
a465 1
  diff = resolve_symbol_value (frag->fr_symbol);
d511 1
a511 1
  diff = resolve_symbol_value (frag->fr_symbol);
@


1.1.1.4
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d97 1
a97 1
static int get_cie_info (struct cie_info *);
d102 2
a103 1
get_cie_info (struct cie_info *info)
d251 3
a253 1
check_eh_frame (expressionS *exp, unsigned int *pnbytes)
d460 2
a461 1
eh_frame_estimate_size_before_relax (fragS *frag)
d488 2
a489 1
eh_frame_relax_frag (fragS *frag)
d503 2
a504 1
eh_frame_convert_frag (fragS *frag)
@


