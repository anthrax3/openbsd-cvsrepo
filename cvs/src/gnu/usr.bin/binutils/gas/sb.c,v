head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.54
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.52
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.48
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.44
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.46
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.38
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.42
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.40
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.36
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.34
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.32
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.30
	OPENBSD_5_0:1.3.0.28
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.26
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.24
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.20
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.22
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.18
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.16
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.14
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	BINUTILS_2_15:1.1.1.3
	OPENBSD_3_6:1.2.0.10
	OPENBSD_3_6_BASE:1.2
	BINUTILS-2_14:1.1.1.2
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	binutils-2_11_2:1.1.1.2
	OPENBSD_3_1:1.1.0.26
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.24
	OPENBSD_3_0_BASE:1.1
	BINUTILS-2_10_1:1.1.1.1
	OPENBSD_2_9:1.1.0.22
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.20
	OPENBSD_2_8_BASE:1.1
	BINUTILS-2_10:1.1.1.1
	OPENBSD_2_7:1.1.0.18
	OPENBSD_2_7_BASE:1.1
	new-binutils:1.1.0.16
	OPENBSD_2_6:1.1.0.14
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.12
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.10
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	BINUTILS-2_8_1:1.1.1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	CYGNUS-961112:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.11.02.20.45.25;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.44;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.44;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.05.13.13.32.27;	author fgsch;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.11.02.20.22.44;	author miod;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* sb.c - string buffer manipulation routines
   Copyright 1994, 1995, 2000 Free Software Foundation, Inc.

   Written by Steve and Judy Chamberlain of Cygnus Support,
      sac@@cygnus.com

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "config.h"
#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "libiberty.h"
#include "sb.h"

/* These routines are about manipulating strings.

   They are managed in things called `sb's which is an abbreviation
   for string buffers.  An sb has to be created, things can be glued
   on to it, and at the end of it's life it should be freed.  The
   contents should never be pointed at whilst it is still growing,
   since it could be moved at any time

   eg:
   sb_new (&foo);
   sb_grow... (&foo,...);
   use foo->ptr[*];
   sb_kill (&foo);

*/

#define dsize 5

static void sb_check (sb *, int);

/* Statistics of sb structures.  */

int string_count[sb_max_power_two];

/* Free list of sb structures.  */

static sb_list_vector free_list;

/* initializes an sb.  */

void
sb_build (sb *ptr, int size)
{
  /* see if we can find one to allocate */
  sb_element *e;

  if (size > sb_max_power_two)
    abort ();

  e = free_list.size[size];
  if (!e)
    {
      /* nothing there, allocate one and stick into the free list */
      e = (sb_element *) xmalloc (sizeof (sb_element) + (1 << size));
      e->next = free_list.size[size];
      e->size = 1 << size;
      free_list.size[size] = e;
      string_count[size]++;
    }

  /* remove from free list */

  free_list.size[size] = e->next;

  /* copy into callers world */
  ptr->ptr = e->data;
  ptr->pot = size;
  ptr->len = 0;
  ptr->item = e;
}

void
sb_new (sb *ptr)
{
  sb_build (ptr, dsize);
}

/* deallocate the sb at ptr */

void
sb_kill (sb *ptr)
{
  /* return item to free list */
  ptr->item->next = free_list.size[ptr->pot];
  free_list.size[ptr->pot] = ptr->item;
}

/* add the sb at s to the end of the sb at ptr */

void
sb_add_sb (sb *ptr, sb *s)
{
  sb_check (ptr, s->len);
  memcpy (ptr->ptr + ptr->len, s->ptr, s->len);
  ptr->len += s->len;
}

/* make sure that the sb at ptr has room for another len characters,
   and grow it if it doesn't.  */

static void
sb_check (sb *ptr, int len)
{
  if (ptr->len + len >= 1 << ptr->pot)
    {
      sb tmp;
      int pot = ptr->pot;
      while (ptr->len + len >= 1 << pot)
	pot++;
      sb_build (&tmp, pot);
      sb_add_sb (&tmp, ptr);
      sb_kill (ptr);
      *ptr = tmp;
    }
}

/* make the sb at ptr point back to the beginning.  */

void
sb_reset (sb *ptr)
{
  ptr->len = 0;
}

/* add character c to the end of the sb at ptr.  */

void
sb_add_char (sb *ptr, int c)
{
  sb_check (ptr, 1);
  ptr->ptr[ptr->len++] = c;
}

/* add null terminated string s to the end of sb at ptr.  */

void
sb_add_string (sb *ptr, const char *s)
{
  int len = strlen (s);
  sb_check (ptr, len);
  memcpy (ptr->ptr + ptr->len, s, len);
  ptr->len += len;
}

/* add string at s of length len to sb at ptr */

void
sb_add_buffer (sb *ptr, const char *s, int len)
{
  sb_check (ptr, len);
  memcpy (ptr->ptr + ptr->len, s, len);
  ptr->len += len;
}

/* print the sb at ptr to the output file */

void
sb_print (FILE *outfile, sb *ptr)
{
  int i;
  int nc = 0;

  for (i = 0; i < ptr->len; i++)
    {
      if (nc)
	{
	  fprintf (outfile, ",");
	}
      fprintf (outfile, "%d", ptr->ptr[i]);
      nc = 1;
    }
}

void
sb_print_at (FILE *outfile, int idx, sb *ptr)
{
  int i;
  for (i = idx; i < ptr->len; i++)
    putc (ptr->ptr[i], outfile);
}

/* put a null at the end of the sb at in and return the start of the
   string, so that it can be used as an arg to printf %s.  */

char *
sb_name (sb *in)
{
  /* stick a null on the end of the string */
  sb_add_char (in, 0);
  return in->ptr;
}

/* like sb_name, but don't include the null byte in the string.  */

char *
sb_terminate (sb *in)
{
  sb_add_char (in, 0);
  --in->len;
  return in->ptr;
}

/* start at the index idx into the string in sb at ptr and skip
   whitespace. return the index of the first non whitespace character */

int
sb_skip_white (int idx, sb *ptr)
{
  while (idx < ptr->len
	 && (ptr->ptr[idx] == ' '
	     || ptr->ptr[idx] == '\t'))
    idx++;
  return idx;
}

/* start at the index idx into the sb at ptr. skips whitespace,
   a comma and any following whitespace. returns the index of the
   next character.  */

int
sb_skip_comma (int idx, sb *ptr)
{
  while (idx < ptr->len
	 && (ptr->ptr[idx] == ' '
	     || ptr->ptr[idx] == '\t'))
    idx++;

  if (idx < ptr->len
      && ptr->ptr[idx] == ',')
    idx++;

  while (idx < ptr->len
	 && (ptr->ptr[idx] == ' '
	     || ptr->ptr[idx] == '\t'))
    idx++;

  return idx;
}
@


1.2
log
@resolve conflicts.
@
text
@d55 1
a55 1
static void sb_check PARAMS ((sb *, int));
d68 1
a68 3
sb_build (ptr, size)
     sb *ptr;
     int size;
d99 1
a99 2
sb_new (ptr)
     sb *ptr;
d107 1
a107 2
sb_kill (ptr)
     sb *ptr;
d117 1
a117 3
sb_add_sb (ptr, s)
     sb *ptr;
     sb *s;
d128 1
a128 3
sb_check (ptr, len)
     sb *ptr;
     int len;
d146 1
a146 2
sb_reset (ptr)
     sb *ptr;
d154 1
a154 3
sb_add_char (ptr, c)
     sb *ptr;
     int c;
d163 1
a163 3
sb_add_string (ptr, s)
     sb *ptr;
     const char *s;
d174 1
a174 4
sb_add_buffer (ptr, s, len)
     sb *ptr;
     const char *s;
     int len;
d184 1
a184 3
sb_print (outfile, ptr)
     FILE *outfile;
     sb *ptr;
d201 1
a201 4
sb_print_at (outfile, idx, ptr)
     FILE *outfile;
     int idx;
     sb *ptr;
d212 1
a212 2
sb_name (in)
     sb *in;
d222 1
a222 2
sb_terminate (in)
     sb *in;
d233 1
a233 3
sb_skip_white (idx, ptr)
     int idx;
     sb *ptr;
d243 1
a243 1
   a comma and any following whitespace. returnes the index of the
d247 1
a247 3
sb_skip_comma (idx, ptr)
     int idx;
     sb *ptr;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995 Free Software Foundation, Inc.
d22 1
a22 1
   02111-1307, USA. */
d26 3
d65 1
a65 1
/* initializes an sb. */
a99 1

d131 1
a131 1
   and grow it if it doesn't. */
d160 1
a160 1
/* add character c to the end of the sb at ptr. */
d171 1
a171 1
/* add null terminated string s to the end of sb at ptr. */
d218 1
a218 1
void 
d230 1
a230 1
   string, so that it can be used as an arg to printf %s. */
d269 1
a269 1
   next character. */
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 2000 Free Software Foundation, Inc.
d22 1
a22 1
   02111-1307, USA.  */
a25 3
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
d62 1
a62 1
/* initializes an sb.  */
d97 1
d129 1
a129 1
   and grow it if it doesn't.  */
d158 1
a158 1
/* add character c to the end of the sb at ptr.  */
d169 1
a169 1
/* add null terminated string s to the end of sb at ptr.  */
d216 1
a216 1
void
d228 1
a228 1
   string, so that it can be used as an arg to printf %s.  */
d267 1
a267 1
   next character.  */
@


1.1.1.3
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d55 1
a55 1
static void sb_check (sb *, int);
d68 3
a70 1
sb_build (sb *ptr, int size)
d101 2
a102 1
sb_new (sb *ptr)
d110 2
a111 1
sb_kill (sb *ptr)
d121 3
a123 1
sb_add_sb (sb *ptr, sb *s)
d134 3
a136 1
sb_check (sb *ptr, int len)
d154 2
a155 1
sb_reset (sb *ptr)
d163 3
a165 1
sb_add_char (sb *ptr, int c)
d174 3
a176 1
sb_add_string (sb *ptr, const char *s)
d187 4
a190 1
sb_add_buffer (sb *ptr, const char *s, int len)
d200 3
a202 1
sb_print (FILE *outfile, sb *ptr)
d219 4
a222 1
sb_print_at (FILE *outfile, int idx, sb *ptr)
d233 2
a234 1
sb_name (sb *in)
d244 2
a245 1
sb_terminate (sb *in)
d256 3
a258 1
sb_skip_white (int idx, sb *ptr)
d268 1
a268 1
   a comma and any following whitespace. returns the index of the
d272 3
a274 1
sb_skip_comma (int idx, sb *ptr)
@


