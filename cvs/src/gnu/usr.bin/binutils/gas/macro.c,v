head	1.6;
access;
symbols
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.52
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.14
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1
	CYGNUS-960904:1.1.1.1
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.28;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.42;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.11.23.03.34.23;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.40;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.40;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.11.19.14.14.04;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.22.03;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.46.11;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.32.15;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.26;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.43;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* macro.c - macro support for gas
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   Written by Steve and Judy Chamberlain of Cygnus Support,
      sac@@cygnus.com

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "config.h"

#ifndef __GNUC__
# if HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifdef _AIX
/* Indented so that pre-ansi C compilers will ignore it, rather than
   choke on it.  Some versions of AIX require this to be the first
   thing in the file.  */
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
#    if !defined (__STDC__) && !defined (__hpux)
extern char *alloca ();
#    else
extern void *alloca ();
#    endif /* __STDC__, __hpux */
#   endif /* alloca */
#  endif /* _AIX */
# endif /* HAVE_ALLOCA_H */
#endif /* __GNUC__ */

#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#include "libiberty.h"
#include "safe-ctype.h"
#include "sb.h"
#include "hash.h"
#include "macro.h"

#include "asintl.h"

/* The routines in this file handle macro definition and expansion.
   They are called by gas.  */

/* Internal functions.  */

static int get_token (int, sb *, sb *);
static int getstring (int, sb *, sb *);
static int get_any_string (int, sb *, sb *, int, int);
static int do_formals (macro_entry *, int, sb *);
static int get_apost_token (int, sb *, sb *, int);
static int sub_actual (int, sb *, sb *, struct hash_control *, int, sb *, int);
static const char *macro_expand_body
  (sb *, sb *, formal_entry *, struct hash_control *, int);
static const char *macro_expand (int, sb *, macro_entry *, sb *);

#define ISWHITE(x) ((x) == ' ' || (x) == '\t')

#define ISSEP(x) \
 ((x) == ' ' || (x) == '\t' || (x) == ',' || (x) == '"' || (x) == ';' \
  || (x) == ')' || (x) == '(' \
  || ((macro_alternate || macro_mri) && ((x) == '<' || (x) == '>')))

#define ISBASE(x) \
  ((x) == 'b' || (x) == 'B' \
   || (x) == 'q' || (x) == 'Q' \
   || (x) == 'h' || (x) == 'H' \
   || (x) == 'd' || (x) == 'D')

/* The macro hash table.  */

struct hash_control *macro_hash;

/* Whether any macros have been defined.  */

int macro_defined;

/* Whether we are in alternate syntax mode.  */

static int macro_alternate;

/* Whether we are in MRI mode.  */

static int macro_mri;

/* Whether we should strip '@@' characters.  */

static int macro_strip_at;

/* Function to use to parse an expression.  */

static int (*macro_expr) (const char *, int, sb *, int *);

/* Number of macro expansions that have been done.  */

static int macro_number;

/* Initialize macro processing.  */

void
macro_init (int alternate, int mri, int strip_at,
	    int (*expr) (const char *, int, sb *, int *))
{
  macro_hash = hash_new ();
  macro_defined = 0;
  macro_alternate = alternate;
  macro_mri = mri;
  macro_strip_at = strip_at;
  macro_expr = expr;
}

/* Switch in and out of MRI mode on the fly.  */

void
macro_mri_mode (int mri)
{
  macro_mri = mri;
}

/* Read input lines till we get to a TO string.
   Increase nesting depth if we get a FROM string.
   Put the results into sb at PTR.
   Add a new input line to an sb using GET_LINE.
   Return 1 on success, 0 on unexpected EOF.  */

int
buffer_and_nest (const char *from, const char *to, sb *ptr,
		 int (*get_line) (sb *))
{
  int from_len = strlen (from);
  int to_len = strlen (to);
  int depth = 1;
  int line_start = ptr->len;

  int more = get_line (ptr);

  while (more)
    {
      /* Try and find the first pseudo op on the line.  */
      int i = line_start;

      if (! macro_alternate && ! macro_mri)
	{
	  /* With normal syntax we can suck what we want till we get
	     to the dot.  With the alternate, labels have to start in
	     the first column, since we cant tell what's a label and
	     whats a pseudoop.  */

	  /* Skip leading whitespace.  */
	  while (i < ptr->len && ISWHITE (ptr->ptr[i]))
	    i++;

	  /* Skip over a label.  */
	  while (i < ptr->len
		 && (ISALNUM (ptr->ptr[i])
		     || ptr->ptr[i] == '_'
		     || ptr->ptr[i] == '$'))
	    i++;

	  /* And a colon.  */
	  if (i < ptr->len
	      && ptr->ptr[i] == ':')
	    i++;

	}
      /* Skip trailing whitespace.  */
      while (i < ptr->len && ISWHITE (ptr->ptr[i]))
	i++;

      if (i < ptr->len && (ptr->ptr[i] == '.'
			   || macro_alternate
			   || macro_mri))
	{
	  if (ptr->ptr[i] == '.')
	    i++;
	  if (strncasecmp (ptr->ptr + i, from, from_len) == 0
	      && (ptr->len == (i + from_len)
		  || ! ISALNUM (ptr->ptr[i + from_len])))
	    depth++;
	  if (strncasecmp (ptr->ptr + i, to, to_len) == 0
	      && (ptr->len == (i + to_len)
		  || ! ISALNUM (ptr->ptr[i + to_len])))
	    {
	      depth--;
	      if (depth == 0)
		{
		  /* Reset the string to not include the ending rune.  */
		  ptr->len = line_start;
		  break;
		}
	    }
	}

      /* Add the original end-of-line char to the end and keep running.  */
      sb_add_char (ptr, more);
      line_start = ptr->len;
      more = get_line (ptr);
    }

  /* Return 1 on success, 0 on unexpected EOF.  */
  return depth == 0;
}

/* Pick up a token.  */

static int
get_token (int idx, sb *in, sb *name)
{
  if (idx < in->len
      && (ISALPHA (in->ptr[idx])
	  || in->ptr[idx] == '_'
	  || in->ptr[idx] == '$'))
    {
      sb_add_char (name, in->ptr[idx++]);
      while (idx < in->len
	     && (ISALNUM (in->ptr[idx])
		 || in->ptr[idx] == '_'
		 || in->ptr[idx] == '$'))
	{
	  sb_add_char (name, in->ptr[idx++]);
	}
    }
  /* Ignore trailing &.  */
  if (macro_alternate && idx < in->len && in->ptr[idx] == '&')
    idx++;
  return idx;
}

/* Pick up a string.  */

static int
getstring (int idx, sb *in, sb *acc)
{
  idx = sb_skip_white (idx, in);

  while (idx < in->len
	 && (in->ptr[idx] == '"'
	     || (in->ptr[idx] == '<' && (macro_alternate || macro_mri))
	     || (in->ptr[idx] == '\'' && macro_alternate)))
    {
      if (in->ptr[idx] == '<')
	{
	  int nest = 0;
	  idx++;
	  while ((in->ptr[idx] != '>' || nest)
		 && idx < in->len)
	    {
	      if (in->ptr[idx] == '!')
		{
		  idx++;
		  sb_add_char (acc, in->ptr[idx++]);
		}
	      else
		{
		  if (in->ptr[idx] == '>')
		    nest--;
		  if (in->ptr[idx] == '<')
		    nest++;
		  sb_add_char (acc, in->ptr[idx++]);
		}
	    }
	  idx++;
	}
      else if (in->ptr[idx] == '"' || in->ptr[idx] == '\'')
	{
	  char tchar = in->ptr[idx];
	  int escaped = 0;

	  idx++;

	  while (idx < in->len)
	    {
	      if (in->ptr[idx - 1] == '\\')
		escaped ^= 1;
	      else
		escaped = 0;

	      if (macro_alternate && in->ptr[idx] == '!')
		{
		  idx ++;

		  sb_add_char (acc, in->ptr[idx]);

		  idx ++;
		}
	      else if (escaped && in->ptr[idx] == tchar)
		{
		  sb_add_char (acc, tchar);
		  idx ++;
		}
	      else
		{
		  if (in->ptr[idx] == tchar)
		    {
		      idx ++;

		      if (idx >= in->len || in->ptr[idx] != tchar)
			break;
		    }

		  sb_add_char (acc, in->ptr[idx]);
		  idx ++;
		}
	    }
	}
    }

  return idx;
}

/* Fetch string from the input stream,
   rules:
    'Bxyx<whitespace>  	-> return 'Bxyza
    %<char>		-> return string of decimal value of x
    "<string>"		-> return string
    xyx<whitespace>     -> return xyz
*/

static int
get_any_string (int idx, sb *in, sb *out, int expand, int pretend_quoted)
{
  sb_reset (out);
  idx = sb_skip_white (idx, in);

  if (idx < in->len)
    {
      if (in->len > idx + 2 && in->ptr[idx + 1] == '\'' && ISBASE (in->ptr[idx]))
	{
	  while (!ISSEP (in->ptr[idx]))
	    sb_add_char (out, in->ptr[idx++]);
	}
      else if (in->ptr[idx] == '%'
	       && macro_alternate
	       && expand)
	{
	  int val;
	  char buf[20];
	  /* Turns the next expression into a string.  */
	  /* xgettext: no-c-format */
	  idx = (*macro_expr) (_("% operator needs absolute expression"),
			       idx + 1,
			       in,
			       &val);
	  sprintf (buf, "%d", val);
	  sb_add_string (out, buf);
	}
      else if (in->ptr[idx] == '"'
	       || (in->ptr[idx] == '<' && (macro_alternate || macro_mri))
	       || (macro_alternate && in->ptr[idx] == '\''))
	{
	  if (macro_alternate
	      && ! macro_strip_at
	      && expand)
	    {
	      /* Keep the quotes.  */
	      sb_add_char (out, '\"');

	      idx = getstring (idx, in, out);
	      sb_add_char (out, '\"');
	    }
	  else
	    {
	      idx = getstring (idx, in, out);
	    }
	}
      else
	{
	  while (idx < in->len
		 && (in->ptr[idx] == '"'
		     || in->ptr[idx] == '\''
		     || pretend_quoted
		     || (in->ptr[idx] != ' '
			 && in->ptr[idx] != '\t'
			 && in->ptr[idx] != ','
			 && (in->ptr[idx] != '<'
			     || (! macro_alternate && ! macro_mri)))))
	    {
	      if (in->ptr[idx] == '"'
		  || in->ptr[idx] == '\'')
		{
		  char tchar = in->ptr[idx];
		  sb_add_char (out, in->ptr[idx++]);
		  while (idx < in->len
			 && in->ptr[idx] != tchar)
		    sb_add_char (out, in->ptr[idx++]);
		  if (idx == in->len)
		    return idx;
		}
	      sb_add_char (out, in->ptr[idx++]);
	    }
	}
    }

  return idx;
}

/* Pick up the formal parameters of a macro definition.  */

static int
do_formals (macro_entry *macro, int idx, sb *in)
{
  formal_entry **p = &macro->formals;

  macro->formal_count = 0;
  macro->formal_hash = hash_new ();
  while (idx < in->len)
    {
      formal_entry *formal;

      formal = (formal_entry *) xmalloc (sizeof (formal_entry));

      sb_new (&formal->name);
      sb_new (&formal->def);
      sb_new (&formal->actual);

      idx = sb_skip_white (idx, in);
      idx = get_token (idx, in, &formal->name);
      if (formal->name.len == 0)
	break;
      idx = sb_skip_white (idx, in);
      if (formal->name.len)
	{
	  /* This is a formal.  */
	  if (idx < in->len && in->ptr[idx] == '=')
	    {
	      /* Got a default.  */
	      idx = get_any_string (idx + 1, in, &formal->def, 1, 0);
	    }
	}

      /* Add to macro's hash table.  */
      hash_jam (macro->formal_hash, sb_terminate (&formal->name), formal);

      formal->index = macro->formal_count;
      idx = sb_skip_comma (idx, in);
      macro->formal_count++;
      *p = formal;
      p = &formal->next;
      *p = NULL;
    }

  if (macro_mri)
    {
      formal_entry *formal;
      const char *name;

      /* Add a special NARG formal, which macro_expand will set to the
         number of arguments.  */
      formal = (formal_entry *) xmalloc (sizeof (formal_entry));

      sb_new (&formal->name);
      sb_new (&formal->def);
      sb_new (&formal->actual);

      /* The same MRI assemblers which treat '@@' characters also use
         the name $NARG.  At least until we find an exception.  */
      if (macro_strip_at)
	name = "$NARG";
      else
	name = "NARG";

      sb_add_string (&formal->name, name);

      /* Add to macro's hash table.  */
      hash_jam (macro->formal_hash, name, formal);

      formal->index = NARG_INDEX;
      *p = formal;
      formal->next = NULL;
    }

  return idx;
}

/* Define a new macro.  Returns NULL on success, otherwise returns an
   error message.  If NAMEP is not NULL, *NAMEP is set to the name of
   the macro which was defined.  */

const char *
define_macro (int idx, sb *in, sb *label,
	      int (*get_line) (sb *), const char **namep)
{
  macro_entry *macro;
  sb name;
  const char *namestr;

  macro = (macro_entry *) xmalloc (sizeof (macro_entry));
  sb_new (&macro->sub);
  sb_new (&name);

  macro->formal_count = 0;
  macro->formals = 0;

  idx = sb_skip_white (idx, in);
  if (! buffer_and_nest ("MACRO", "ENDM", &macro->sub, get_line))
    return _("unexpected end of file in macro definition");
  if (label != NULL && label->len != 0)
    {
      sb_add_sb (&name, label);
      if (idx < in->len && in->ptr[idx] == '(')
	{
	  /* It's the label: MACRO (formals,...)  sort  */
	  idx = do_formals (macro, idx + 1, in);
	  if (in->ptr[idx] != ')')
	    return _("missing ) after formals");
	}
      else
	{
	  /* It's the label: MACRO formals,...  sort  */
	  idx = do_formals (macro, idx, in);
	}
    }
  else
    {
      idx = get_token (idx, in, &name);
      idx = sb_skip_comma (idx, in);
      idx = do_formals (macro, idx, in);
    }

  /* And stick it in the macro hash table.  */
  for (idx = 0; idx < name.len; idx++)
    name.ptr[idx] = TOLOWER (name.ptr[idx]);
  namestr = sb_terminate (&name);
  hash_jam (macro_hash, namestr, (PTR) macro);

  macro_defined = 1;

  if (namep != NULL)
    *namep = namestr;

  return NULL;
}

/* Scan a token, and then skip KIND.  */

static int
get_apost_token (int idx, sb *in, sb *name, int kind)
{
  idx = get_token (idx, in, name);
  if (idx < in->len
      && in->ptr[idx] == kind
      && (! macro_mri || macro_strip_at)
      && (! macro_strip_at || kind == '@@'))
    idx++;
  return idx;
}

/* Substitute the actual value for a formal parameter.  */

static int
sub_actual (int start, sb *in, sb *t, struct hash_control *formal_hash,
	    int kind, sb *out, int copyifnotthere)
{
  int src;
  formal_entry *ptr;

  src = get_apost_token (start, in, t, kind);
  /* See if it's in the macro's hash table, unless this is
     macro_strip_at and kind is '@@' and the token did not end in '@@'.  */
  if (macro_strip_at
      && kind == '@@'
      && (src == start || in->ptr[src - 1] != '@@'))
    ptr = NULL;
  else
    ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (t));
  if (ptr)
    {
      if (ptr->actual.len)
	{
	  sb_add_sb (out, &ptr->actual);
	}
      else
	{
	  sb_add_sb (out, &ptr->def);
	}
    }
  else if (kind == '&')
    {
      /* Doing this permits people to use & in macro bodies.  */
      sb_add_char (out, '&');
      sb_add_sb (out, t);
    }
  else if (copyifnotthere)
    {
      sb_add_sb (out, t);
    }
  else
    {
      sb_add_char (out, '\\');
      sb_add_sb (out, t);
    }
  return src;
}

/* Expand the body of a macro.  */

static const char *
macro_expand_body (sb *in, sb *out, formal_entry *formals,
		   struct hash_control *formal_hash, int locals)
{
  sb t;
  int src = 0;
  int inquote = 0;
  formal_entry *loclist = NULL;

  sb_new (&t);

  while (src < in->len)
    {
      if (in->ptr[src] == '&')
	{
	  sb_reset (&t);
	  if (macro_mri)
	    {
	      if (src + 1 < in->len && in->ptr[src + 1] == '&')
		src = sub_actual (src + 2, in, &t, formal_hash, '\'', out, 1);
	      else
		sb_add_char (out, in->ptr[src++]);
	    }
	  else
	    {
	      /* FIXME: Why do we do this?  */
	      src = sub_actual (src + 1, in, &t, formal_hash, '&', out, 0);
	    }
	}
      else if (in->ptr[src] == '\\')
	{
	  src++;
	  if (in->ptr[src] == '(')
	    {
	      /* Sub in till the next ')' literally.  */
	      src++;
	      while (src < in->len && in->ptr[src] != ')')
		{
		  sb_add_char (out, in->ptr[src++]);
		}
	      if (in->ptr[src] == ')')
		src++;
	      else
		return _("missplaced )");
	    }
	  else if (in->ptr[src] == '@@')
	    {
	      /* Sub in the macro invocation number.  */

	      char buffer[10];
	      src++;
	      sprintf (buffer, "%d", macro_number);
	      sb_add_string (out, buffer);
	    }
	  else if (in->ptr[src] == '&')
	    {
	      /* This is a preprocessor variable name, we don't do them
		 here.  */
	      sb_add_char (out, '\\');
	      sb_add_char (out, '&');
	      src++;
	    }
	  else if (macro_mri && ISALNUM (in->ptr[src]))
	    {
	      int ind;
	      formal_entry *f;

	      if (ISDIGIT (in->ptr[src]))
		ind = in->ptr[src] - '0';
	      else if (ISUPPER (in->ptr[src]))
		ind = in->ptr[src] - 'A' + 10;
	      else
		ind = in->ptr[src] - 'a' + 10;
	      ++src;
	      for (f = formals; f != NULL; f = f->next)
		{
		  if (f->index == ind - 1)
		    {
		      if (f->actual.len != 0)
			sb_add_sb (out, &f->actual);
		      else
			sb_add_sb (out, &f->def);
		      break;
		    }
		}
	    }
	  else
	    {
	      sb_reset (&t);
	      src = sub_actual (src, in, &t, formal_hash, '\'', out, 0);
	    }
	}
      else if ((macro_alternate || macro_mri)
	       && (ISALPHA (in->ptr[src])
		   || in->ptr[src] == '_'
		   || in->ptr[src] == '$')
	       && (! inquote
		   || ! macro_strip_at
		   || (src > 0 && in->ptr[src - 1] == '@@')))
	{
	  if (! locals
	      || src + 5 >= in->len
	      || strncasecmp (in->ptr + src, "LOCAL", 5) != 0
	      || ! ISWHITE (in->ptr[src + 5]))
	    {
	      sb_reset (&t);
	      src = sub_actual (src, in, &t, formal_hash,
				(macro_strip_at && inquote) ? '@@' : '\'',
				out, 1);
	    }
	  else
	    {
	      formal_entry *f;

	      src = sb_skip_white (src + 5, in);
	      while (in->ptr[src] != '\n')
		{
		  static int loccnt;
		  char buf[20];
		  const char *err;

		  f = (formal_entry *) xmalloc (sizeof (formal_entry));
		  sb_new (&f->name);
		  sb_new (&f->def);
		  sb_new (&f->actual);
		  f->index = LOCAL_INDEX;
		  f->next = loclist;
		  loclist = f;

		  src = get_token (src, in, &f->name);
		  ++loccnt;
		  sprintf (buf, "LL%04x", loccnt);
		  sb_add_string (&f->actual, buf);

		  err = hash_jam (formal_hash, sb_terminate (&f->name), f);
		  if (err != NULL)
		    return err;

		  src = sb_skip_comma (src, in);
		}
	    }
	}
      else if (in->ptr[src] == '"'
	       || (macro_mri && in->ptr[src] == '\''))
	{
	  inquote = !inquote;
	  sb_add_char (out, in->ptr[src++]);
	}
      else if (in->ptr[src] == '@@' && macro_strip_at)
	{
	  ++src;
	  if (src < in->len
	      && in->ptr[src] == '@@')
	    {
	      sb_add_char (out, '@@');
	      ++src;
	    }
	}
      else if (macro_mri
	       && in->ptr[src] == '='
	       && src + 1 < in->len
	       && in->ptr[src + 1] == '=')
	{
	  formal_entry *ptr;

	  sb_reset (&t);
	  src = get_token (src + 2, in, &t);
	  ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (&t));
	  if (ptr == NULL)
	    {
	      /* FIXME: We should really return a warning string here,
                 but we can't, because the == might be in the MRI
                 comment field, and, since the nature of the MRI
                 comment field depends upon the exact instruction
                 being used, we don't have enough information here to
                 figure out whether it is or not.  Instead, we leave
                 the == in place, which should cause a syntax error if
                 it is not in a comment.  */
	      sb_add_char (out, '=');
	      sb_add_char (out, '=');
	      sb_add_sb (out, &t);
	    }
	  else
	    {
	      if (ptr->actual.len)
		{
		  sb_add_string (out, "-1");
		}
	      else
		{
		  sb_add_char (out, '0');
		}
	    }
	}
      else
	{
	  sb_add_char (out, in->ptr[src++]);
	}
    }

  sb_kill (&t);

  while (loclist != NULL)
    {
      formal_entry *f;

      f = loclist->next;
      /* Setting the value to NULL effectively deletes the entry.  We
         avoid calling hash_delete because it doesn't reclaim memory.  */
      hash_jam (formal_hash, sb_terminate (&loclist->name), NULL);
      sb_kill (&loclist->name);
      sb_kill (&loclist->def);
      sb_kill (&loclist->actual);
      free (loclist);
      loclist = f;
    }

  return NULL;
}

/* Assign values to the formal parameters of a macro, and expand the
   body.  */

static const char *
macro_expand (int idx, sb *in, macro_entry *m, sb *out)
{
  sb t;
  formal_entry *ptr;
  formal_entry *f;
  int is_positional = 0;
  int is_keyword = 0;
  int narg = 0;
  const char *err;

  sb_new (&t);

  /* Reset any old value the actuals may have.  */
  for (f = m->formals; f; f = f->next)
    sb_reset (&f->actual);
  f = m->formals;
  while (f != NULL && f->index < 0)
    f = f->next;

  if (macro_mri)
    {
      /* The macro may be called with an optional qualifier, which may
         be referred to in the macro body as \0.  */
      if (idx < in->len && in->ptr[idx] == '.')
	{
	  /* The Microtec assembler ignores this if followed by a white space.
	     (Macro invocation with empty extension) */
	  idx++;
	  if (    idx < in->len
		  && in->ptr[idx] != ' '
		  && in->ptr[idx] != '\t')
	    {
	      formal_entry *n;

	      n = (formal_entry *) xmalloc (sizeof (formal_entry));
	      sb_new (&n->name);
	      sb_new (&n->def);
	      sb_new (&n->actual);
	      n->index = QUAL_INDEX;

	      n->next = m->formals;
	      m->formals = n;

	      idx = get_any_string (idx, in, &n->actual, 1, 0);
	    }
	}
    }

  /* Peel off the actuals and store them away in the hash tables' actuals.  */
  idx = sb_skip_white (idx, in);
  while (idx < in->len)
    {
      int scan;

      /* Look and see if it's a positional or keyword arg.  */
      scan = idx;
      while (scan < in->len
	     && !ISSEP (in->ptr[scan])
	     && !(macro_mri && in->ptr[scan] == '\'')
	     && (!macro_alternate && in->ptr[scan] != '='))
	scan++;
      if (scan < in->len && !macro_alternate && in->ptr[scan] == '=')
	{
	  is_keyword = 1;

	  /* It's OK to go from positional to keyword.  */

	  /* This is a keyword arg, fetch the formal name and
	     then the actual stuff.  */
	  sb_reset (&t);
	  idx = get_token (idx, in, &t);
	  if (in->ptr[idx] != '=')
	    return _("confusion in formal parameters");

	  /* Lookup the formal in the macro's list.  */
	  ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));
	  if (!ptr)
	    return _("macro formal argument does not exist");
	  else
	    {
	      /* Insert this value into the right place.  */
	      sb_reset (&ptr->actual);
	      idx = get_any_string (idx + 1, in, &ptr->actual, 0, 0);
	      if (ptr->actual.len > 0)
		++narg;
	    }
	}
      else
	{
	  /* This is a positional arg.  */
	  is_positional = 1;
	  if (is_keyword)
	    return _("can't mix positional and keyword arguments");

	  if (!f)
	    {
	      formal_entry **pf;
	      int c;

	      if (!macro_mri)
		return _("too many positional arguments");

	      f = (formal_entry *) xmalloc (sizeof (formal_entry));
	      sb_new (&f->name);
	      sb_new (&f->def);
	      sb_new (&f->actual);
	      f->next = NULL;

	      c = -1;
	      for (pf = &m->formals; *pf != NULL; pf = &(*pf)->next)
		if ((*pf)->index >= c)
		  c = (*pf)->index + 1;
	      if (c == -1)
		c = 0;
	      *pf = f;
	      f->index = c;
	    }

	  sb_reset (&f->actual);
	  idx = get_any_string (idx, in, &f->actual, 1, 0);
	  if (f->actual.len > 0)
	    ++narg;
	  do
	    {
	      f = f->next;
	    }
	  while (f != NULL && f->index < 0);
	}

      if (! macro_mri)
	idx = sb_skip_comma (idx, in);
      else
	{
	  if (in->ptr[idx] == ',')
	    ++idx;
	  if (ISWHITE (in->ptr[idx]))
	    break;
	}
    }

  if (macro_mri)
    {
      char buffer[20];

      sb_reset (&t);
      sb_add_string (&t, macro_strip_at ? "$NARG" : "NARG");
      ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));
      sb_reset (&ptr->actual);
      sprintf (buffer, "%d", narg);
      sb_add_string (&ptr->actual, buffer);
    }

  err = macro_expand_body (&m->sub, out, m->formals, m->formal_hash, 1);
  if (err != NULL)
    return err;

  /* Discard any unnamed formal arguments.  */
  if (macro_mri)
    {
      formal_entry **pf;

      pf = &m->formals;
      while (*pf != NULL)
	{
	  if ((*pf)->name.len != 0)
	    pf = &(*pf)->next;
	  else
	    {
	      sb_kill (&(*pf)->name);
	      sb_kill (&(*pf)->def);
	      sb_kill (&(*pf)->actual);
	      f = (*pf)->next;
	      free (*pf);
	      *pf = f;
	    }
	}
    }

  sb_kill (&t);
  macro_number++;

  return NULL;
}

/* Check for a macro.  If one is found, put the expansion into
   *EXPAND.  Return 1 if a macro is found, 0 otherwise.  */

int
check_macro (const char *line, sb *expand,
	     const char **error, macro_entry **info)
{
  const char *s;
  char *copy, *cs;
  macro_entry *macro;
  sb line_sb;

  if (! ISALPHA (*line)
      && *line != '_'
      && *line != '$'
      && (! macro_mri || *line != '.'))
    return 0;

  s = line + 1;
  while (ISALNUM (*s)
	 || *s == '_'
	 || *s == '$')
    ++s;

  copy = (char *) alloca (s - line + 1);
  memcpy (copy, line, s - line);
  copy[s - line] = '\0';
  for (cs = copy; *cs != '\0'; cs++)
    *cs = TOLOWER (*cs);

  macro = (macro_entry *) hash_find (macro_hash, copy);

  if (macro == NULL)
    return 0;

  /* Wrap the line up in an sb.  */
  sb_new (&line_sb);
  while (*s != '\0' && *s != '\n' && *s != '\r')
    sb_add_char (&line_sb, *s++);

  sb_new (expand);
  *error = macro_expand (0, &line_sb, macro, expand);

  sb_kill (&line_sb);

  /* Export the macro information if requested.  */
  if (info)
    *info = macro;

  return 1;
}

/* Delete a macro.  */

void
delete_macro (const char *name)
{
  hash_delete (macro_hash, name);
}

/* Handle the MRI IRP and IRPC pseudo-ops.  These are handled as a
   combined macro definition and execution.  This returns NULL on
   success, or an error message otherwise.  */

const char *
expand_irp (int irpc, int idx, sb *in, sb *out, int (*get_line) (sb *))
{
  const char *mn;
  sb sub;
  formal_entry f;
  struct hash_control *h;
  const char *err;

  if (irpc)
    mn = "IRPC";
  else
    mn = "IRP";

  idx = sb_skip_white (idx, in);

  sb_new (&sub);
  if (! buffer_and_nest (mn, "ENDR", &sub, get_line))
    return _("unexpected end of file in irp or irpc");

  sb_new (&f.name);
  sb_new (&f.def);
  sb_new (&f.actual);

  idx = get_token (idx, in, &f.name);
  if (f.name.len == 0)
    return _("missing model parameter");

  h = hash_new ();
  err = hash_jam (h, sb_terminate (&f.name), &f);
  if (err != NULL)
    return err;

  f.index = 1;
  f.next = NULL;

  sb_reset (out);

  idx = sb_skip_comma (idx, in);
  if (idx >= in->len)
    {
      /* Expand once with a null string.  */
      err = macro_expand_body (&sub, out, &f, h, 0);
      if (err != NULL)
	return err;
    }
  else
    {
      if (irpc && in->ptr[idx] == '"')
	++idx;
      while (idx < in->len)
	{
	  if (!irpc)
	    idx = get_any_string (idx, in, &f.actual, 1, 0);
	  else
	    {
	      if (in->ptr[idx] == '"')
		{
		  int nxt;

		  nxt = sb_skip_white (idx + 1, in);
		  if (nxt >= in->len)
		    {
		      idx = nxt;
		      break;
		    }
		}
	      sb_reset (&f.actual);
	      sb_add_char (&f.actual, in->ptr[idx]);
	      ++idx;
	    }
	  err = macro_expand_body (&sub, out, &f, h, 0);
	  if (err != NULL)
	    return err;
	  if (!irpc)
	    idx = sb_skip_comma (idx, in);
	  else
	    idx = sb_skip_white (idx, in);
	}
    }

  hash_die (h);
  sb_kill (&sub);

  return NULL;
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d70 6
a75 7
static int get_token PARAMS ((int, sb *, sb *));
static int getstring PARAMS ((int, sb *, sb *));
static int get_any_string PARAMS ((int, sb *, sb *, int, int));
static int do_formals PARAMS ((macro_entry *, int, sb *));
static int get_apost_token PARAMS ((int, sb *, sb *, int));
static int sub_actual
  PARAMS ((int, sb *, sb *, struct hash_control *, int, sb *, int));
d77 2
a78 2
  PARAMS ((sb *, sb *, formal_entry *, struct hash_control *, int));
static const char *macro_expand PARAMS ((int, sb *, macro_entry *, sb *));
d115 1
a115 1
static int (*macro_expr) PARAMS ((const char *, int, sb *, int *));
d124 2
a125 5
macro_init (alternate, mri, strip_at, expr)
     int alternate;
     int mri;
     int strip_at;
     int (*expr) PARAMS ((const char *, int, sb *, int *));
d138 1
a138 2
macro_mri_mode (mri)
     int mri;
d150 2
a151 5
buffer_and_nest (from, to, ptr, get_line)
     const char *from;
     const char *to;
     sb *ptr;
     int (*get_line) PARAMS ((sb *));
d230 1
a230 4
get_token (idx, in, name)
     int idx;
     sb *in;
     sb *name;
d255 1
a255 4
getstring (idx, in, acc)
     int idx;
     sb *in;
     sb *acc;
d343 1
a343 6
get_any_string (idx, in, out, expand, pretend_quoted)
     int idx;
     sb *in;
     sb *out;
     int expand;
     int pretend_quoted;
d423 1
a423 4
do_formals (macro, idx, in)
     macro_entry *macro;
     int idx;
     sb *in;
d503 2
a504 6
define_macro (idx, in, label, get_line, namep)
     int idx;
     sb *in;
     sb *label;
     int (*get_line) PARAMS ((sb *));
     const char **namep;
d560 1
a560 5
get_apost_token (idx, in, name, kind)
     int idx;
     sb *in;
     sb *name;
     int kind;
d574 2
a575 8
sub_actual (start, in, t, formal_hash, kind, out, copyifnotthere)
     int start;
     sb *in;
     sb *t;
     struct hash_control *formal_hash;
     int kind;
     sb *out;
     int copyifnotthere;
d621 2
a622 6
macro_expand_body (in, out, formals, formal_hash, locals)
     sb *in;
     sb *out;
     formal_entry *formals;
     struct hash_control *formal_hash;
     int locals;
d844 1
a844 5
macro_expand (idx, in, m, out)
     int idx;
     sb *in;
     macro_entry *m;
     sb *out;
d1032 2
a1033 5
check_macro (line, expand, error, info)
     const char *line;
     sb *expand;
     const char **error;
     macro_entry **info;
d1083 1
a1083 2
delete_macro (name)
     const char *name;
d1093 1
a1093 6
expand_irp (irpc, idx, in, out, get_line)
     int irpc;
     int idx;
     sb *in;
     sb *out;
     int (*get_line) PARAMS ((sb *));
@


1.4
log
@resolve conflicts.
@
text
@d1 2
a2 2
/* macro.c - macro support for gas and gasp
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000
d27 1
a27 10
/* AIX requires this to be the first thing in the file.  */
#ifdef __GNUC__
# ifndef alloca
#  ifdef __STDC__
extern void *alloca ();
#  else
extern char *alloca ();
#  endif
# endif
#else
d32 3
d46 1
a46 1
#endif
a53 1
#include <ctype.h>
d58 1
d66 1
a66 1
   They are called by both gasp and gas.  */
d78 2
a79 2
  PARAMS ((sb *, sb *, formal_entry *, struct hash_control *, int, int));
static const char *macro_expand PARAMS ((int, sb *, macro_entry *, sb *, int));
d96 1
a96 1
static struct hash_control *macro_hash;
d102 1
a102 1
/* Whether we are in GASP alternate mode.  */
d186 1
a186 1
		 && (isalnum ((unsigned char) ptr->ptr[i])
d209 1
a209 1
		  || ! isalnum (ptr->ptr[i + from_len])))
d213 1
a213 1
		  || ! isalnum (ptr->ptr[i + to_len])))
d225 2
a226 2
      /* Add a CR to the end and keep running.  */
      sb_add_char (ptr, '\n');
d244 1
a244 1
      && (isalpha ((unsigned char) in->ptr[idx])
d250 1
a250 1
	     && (isalnum ((unsigned char) in->ptr[idx])
d369 1
a369 1
      if (in->len > 2 && in->ptr[idx + 1] == '\'' && ISBASE (in->ptr[idx]))
d381 1
d386 1
a386 1
	  sprintf(buf, "%d", val);
d571 1
a571 2
    if (isupper ((unsigned char) name.ptr[idx]))
      name.ptr[idx] = tolower (name.ptr[idx]);
d640 1
d657 1
a657 1
macro_expand_body (in, out, formals, formal_hash, comment_char, locals)
a661 1
     int comment_char;
d692 1
a692 8
	  if (in->ptr[src] == comment_char && comment_char != '\0')
	    {
	      /* This is a comment, just drop the rest of the line.  */
	      while (src < in->len
		     && in->ptr[src] != '\n')
		src++;
	    }
	  else if (in->ptr[src] == '(')
d722 1
a722 2
	  else if (macro_mri
		   && isalnum ((unsigned char) in->ptr[src]))
d727 1
a727 1
	      if (isdigit ((unsigned char) in->ptr[src]))
d729 1
a729 1
	      else if (isupper ((unsigned char) in->ptr[src]))
d753 1
a753 1
	       && (isalpha ((unsigned char) in->ptr[src])
d775 1
a775 1
	      while (in->ptr[src] != '\n' && in->ptr[src] != comment_char)
a801 11
      else if (comment_char != '\0'
	       && in->ptr[src] == comment_char
	       && src + 1 < in->len
	       && in->ptr[src + 1] == comment_char
	       && !inquote)
	{
	  /* Two comment chars in a row cause the rest of the line to
             be dropped.  */
	  while (src < in->len && in->ptr[src] != '\n')
	    src++;
	}
d884 1
a884 1
macro_expand (idx, in, m, out, comment_char)
a888 1
     int comment_char;
d913 14
a926 1
	  formal_entry *n;
d928 2
a929 5
	  n = (formal_entry *) xmalloc (sizeof (formal_entry));
	  sb_new (&n->name);
	  sb_new (&n->def);
	  sb_new (&n->actual);
	  n->index = QUAL_INDEX;
d931 2
a932 4
	  n->next = m->formals;
	  m->formals = n;

	  idx = get_any_string (idx + 1, in, &n->actual, 1, 0);
d938 1
a938 1
  while (idx < in->len && in->ptr[idx] != comment_char)
d1040 1
a1040 2
  err = macro_expand_body (&m->sub, out, m->formals, m->formal_hash,
			   comment_char, 1);
d1073 1
a1073 2
   *EXPAND.  COMMENT_CHAR is the comment character--this is used by
   gasp.  Return 1 if a macro is found, 0 otherwise.  */
d1076 1
a1076 1
check_macro (line, expand, comment_char, error, info)
a1078 1
     int comment_char;
d1087 1
a1087 1
  if (! isalpha ((unsigned char) *line)
d1094 1
a1094 1
  while (isalnum ((unsigned char) *s)
d1103 1
a1103 2
    if (isupper ((unsigned char) *cs))
      *cs = tolower (*cs);
d1116 1
a1116 1
  *error = macro_expand (0, &line_sb, macro, expand, comment_char);
d1141 1
a1141 1
expand_irp (irpc, idx, in, out, get_line, comment_char)
a1146 1
     int comment_char;
d1184 1
a1184 1
  if (idx >= in->len || in->ptr[idx] == comment_char)
d1187 1
a1187 1
      err = macro_expand_body (&sub, out, &f, h, comment_char, 0);
d1195 1
a1195 1
      while (idx < in->len && in->ptr[idx] != comment_char)
d1206 1
a1206 1
		  if (nxt >= in->len || in->ptr[nxt] == comment_char)
d1216 1
a1216 1
	  err = macro_expand_body (&sub, out, &f, h, comment_char, 0);
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d23 1
a23 1
   02111-1307, USA. */
d176 1
a176 1
      /* Try and find the first pseudo op on the line */
d184 1
a184 1
	     whats a pseudoop */
d186 1
a186 1
	  /* Skip leading whitespace */
d190 1
a190 1
	  /* Skip over a label */
d197 1
a197 1
	  /* And a colon */
d203 1
a203 1
      /* Skip trailing whitespace */
d212 1
a212 1
	      i++;
d214 2
a215 1
	      && (ptr->len == (i + from_len) || ! isalnum (ptr->ptr[i + from_len])))
d218 2
a219 1
	      && (ptr->len == (i + to_len) || ! isalnum (ptr->ptr[i + to_len])))
d224 1
a224 1
		  /* Reset the string to not include the ending rune */
d231 1
a231 1
      /* Add a CR to the end and keep running */
d263 1
a263 1
  /* Ignore trailing & */
d280 1
a280 1
	 && (in->ptr[idx] == '"' 
d293 1
a293 1
		  idx++  ;
d310 2
d313 1
d316 5
d323 10
a332 2
		  idx++  ;
		  sb_add_char (acc, in->ptr[idx++]);
d338 2
a339 1
		      idx++;
d343 1
d345 1
a345 1
		  idx++;
d350 1
a350 1
  
d375 1
a375 1
      if (in->len > 2 && in->ptr[idx+1] == '\'' && ISBASE (in->ptr[idx]))
d386 1
a386 1
	  /* Turns the next expression into a string */
d402 2
a403 2
	      /* Keep the quotes */
	      sb_add_char (out,  '\"');
d406 1
a406 1
	      sb_add_char (out,  '\"');
d413 1
a413 1
      else 
d415 1
a415 1
	  while (idx < in->len 
d418 1
a418 1
		     || pretend_quoted 
d425 1
a425 1
	      if (in->ptr[idx] == '"' 
d432 1
a432 1
		    sb_add_char (out, in->ptr[idx++]);		    
d434 1
a434 1
		    return idx;	      
d473 1
a473 1
	  /* This is a formal */
d476 1
a476 1
	      /* Got a default */
d481 1
a481 1
      /* Add to macro's hash table */
d514 1
a514 1
      /* Add to macro's hash table */
d556 1
a556 1
	  /* It's the label: MACRO (formals,...)  sort */
d563 1
a563 1
	  /* It's the label: MACRO formals,...  sort */
d574 1
a574 1
  /* and stick it in the macro hash table */
d651 1
a651 1
  else 
d700 1
a700 1
	      /* This is a comment, just drop the rest of the line */
d707 1
a707 1
	      /* Sub in till the next ')' literally */
d720 1
a720 1
	      /* Sub in the macro invocation number */
d724 1
a724 1
	      sprintf (buffer, "%05d", macro_number);
d730 1
a730 1
		 here */
d925 2
a926 2
  
  /* Reset any old value the actuals may have */
d928 1
a928 1
      sb_reset (&f->actual);
d954 1
a954 1
  /* Peel off the actuals and store them away in the hash tables' actuals */
d960 1
a960 1
      /* Look and see if it's a positional or keyword arg */
d974 1
a974 1
	     then the actual stuff */
d980 1
a980 1
	  /* Lookup the formal in the macro's list */
d986 1
a986 1
	      /* Insert this value into the right place */
d995 1
a995 1
	  /* This is a positional arg */
d1142 1
a1142 1
  /* export the macro information if requested */
d1187 1
a1187 1
  
@


1.2
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995 Free Software Foundation, Inc.
d25 28
d68 2
a72 36
/* Structures used to store macros. 

   Each macro knows its name and included text.  It gets built with a
   list of formal arguments, and also keeps a hash table which points
   into the list to speed up formal search.  Each formal knows its
   name and its default value.  Each time the macro is expanded, the
   formals get the actual values attatched to them. */

/* describe the formal arguments to a macro */

typedef struct formal_struct
  {
    struct formal_struct *next;	/* next formal in list */
    sb name;			/* name of the formal */
    sb def;			/* the default value */
    sb actual;			/* the actual argument (changed on each expansion) */
    int index;			/* the index of the formal 0..formal_count-1 */
  }
formal_entry;

/* Other values found in the index field of a formal_entry.  */
#define QUAL_INDEX (-1)
#define NARG_INDEX (-2)
#define LOCAL_INDEX (-3)

/* describe the macro. */

typedef struct macro_struct
  {
    sb sub;			/* substitution text. */
    int formal_count;		/* number of formal args. */
    formal_entry *formals;	/* pointer to list of formal_structs */
    struct hash_control *formal_hash; /* hash table of formals. */
  }
macro_entry;

d90 2
a91 1
  || (x) == '<' || (x) == '>' || (x) == ')' || (x) == '(')
d144 9
d212 2
a213 1
	  if (strncasecmp (ptr->ptr + i, from, from_len) == 0)
d215 2
a216 1
	  if (strncasecmp (ptr->ptr + i, to, to_len) == 0)
d278 1
a278 1
	     || in->ptr[idx] == '<' 
d283 4
a286 1
	  if (macro_alternate || macro_mri)
d288 1
a288 4
	      int nest = 0;
	      idx++;
	      while ((in->ptr[idx] != '>' || nest)
		     && idx < in->len)
d290 10
a299 13
		  if (in->ptr[idx] == '!')
		    {
		      idx++  ;
		      sb_add_char (acc, in->ptr[idx++]);
		    }
		  else
		    {
		      if (in->ptr[idx] == '>')
			nest--;
		      if (in->ptr[idx] == '<')
			nest++;
		      sb_add_char (acc, in->ptr[idx++]);
		    }
a300 16
	      idx++;
	    }
	  else
	    {
	      int code;
	      idx++;
	      idx = ((*macro_expr)
		     ("character code in string must be absolute expression",
		      idx, in, &code));
	      sb_add_char (acc, code);

#if 0
	      if (in->ptr[idx] != '>')
		ERROR ((stderr, "Missing > for character code.\n"));
#endif
	      idx++;
d302 1
d366 1
a366 1
	  idx = (*macro_expr) ("% operator needs absolute expression",
d374 1
a374 1
	       || in->ptr[idx] == '<'
d401 2
a402 1
			 && in->ptr[idx] != '<')))
d529 1
a529 1
    return "unexpected end of file in macro definition";
d533 1
a533 1
      if (in->ptr[idx] == '(')
d538 1
a538 1
	    return "missing ) after formals";
d555 1
a555 1
    if (isupper (name.ptr[idx]))
d621 5
d661 1
a661 1
	  if (macro_mri && src + 1 < in->len && in->ptr[src + 1] == '&')
d663 4
a666 1
	      src = sub_actual (src + 2, in, &t, formal_hash, '\'', out, 1);
d670 1
d695 1
a695 1
		return "missplaced )";
d701 1
a701 1
	      char buffer[6];
d871 3
a873 1
      hash_delete (formal_hash, sb_terminate (&loclist->name));
d943 1
d949 2
a950 2
	  if (is_positional)
	    return "can't mix positional and keyword arguments";
d957 1
a957 1
	    return "confusion in formal parameters";
d962 1
a962 1
	    return "macro formal argument does not exist";
d977 1
a977 1
	    return "can't mix positional and keyword arguments";
d985 1
a985 1
		return "too many positional arguments";
d1075 1
a1075 1
check_macro (line, expand, comment_char, error)
d1080 1
d1099 1
a1099 1
  copy = (char *) xmalloc (s - line + 1);
d1103 1
a1103 1
    if (isupper (*cs))
d1121 4
d1165 1
a1165 1
    return "unexpected end of file in irp or irpc";
d1173 1
a1173 1
    return "missing model parameter";
@


1.1
log
@Initial revision
@
text
@d516 2
a517 1
   error message.  */
d520 1
a520 1
define_macro (idx, in, label, get_line)
d525 1
d529 1
d568 2
a569 1
  hash_jam (macro_hash, sb_terminate (&name), (PTR) macro);
d572 3
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d516 1
a516 2
   error message.  If NAMEP is not NULL, *NAMEP is set to the name of
   the macro which was defined.  */
d519 1
a519 1
define_macro (idx, in, label, get_line, namep)
a523 1
     const char **namep;
a526 1
  const char *namestr;
d565 1
a565 2
  namestr = sb_terminate (&name);
  hash_jam (macro_hash, namestr, (PTR) macro);
a567 3

  if (namep != NULL)
    *namep = namestr;
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 1997 Free Software Foundation, Inc.
d667 1
a667 1
	  if (macro_mri)
d669 1
a669 4
	      if (src + 1 < in->len && in->ptr[src + 1] == '&')
		src = sub_actual (src + 2, in, &t, formal_hash, '\'', out, 1);
	      else
		sb_add_char (out, in->ptr[src++]);
a672 2
	      /* FIXME: Why do we do this?  It prevents people from
                 using the & operator in a macro.  */
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
a24 28

/* AIX requires this to be the first thing in the file.  */
#ifdef __GNUC__
# ifndef alloca
#  ifdef __STDC__
extern void *alloca ();
#  else
extern char *alloca ();
#  endif
# endif
#else
# if HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifdef _AIX
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
#    if !defined (__STDC__) && !defined (__hpux)
extern char *alloca ();
#    else
extern void *alloca ();
#    endif /* __STDC__, __hpux */
#   endif /* alloca */
#  endif /* _AIX */
# endif /* HAVE_ALLOCA_H */
#endif

a39 2
#include "asintl.h"

d43 36
d96 1
a96 2
  || (x) == ')' || (x) == '(' \
  || ((macro_alternate || macro_mri) && ((x) == '<' || (x) == '>')))
a148 9
/* Switch in and out of MRI mode on the fly.  */

void
macro_mri_mode (mri)
     int mri;
{
  macro_mri = mri;
}

d208 1
a208 2
	  if (strncasecmp (ptr->ptr + i, from, from_len) == 0
	      && (ptr->len == (i + from_len) || ! isalnum (ptr->ptr[i + from_len])))
d210 1
a210 2
	  if (strncasecmp (ptr->ptr + i, to, to_len) == 0
	      && (ptr->len == (i + to_len) || ! isalnum (ptr->ptr[i + to_len])))
d272 1
a272 1
	     || (in->ptr[idx] == '<' && (macro_alternate || macro_mri))
d277 1
a277 4
	  int nest = 0;
	  idx++;
	  while ((in->ptr[idx] != '>' || nest)
		 && idx < in->len)
d279 4
a282 1
	      if (in->ptr[idx] == '!')
d284 13
a296 10
		  idx++  ;
		  sb_add_char (acc, in->ptr[idx++]);
		}
	      else
		{
		  if (in->ptr[idx] == '>')
		    nest--;
		  if (in->ptr[idx] == '<')
		    nest++;
		  sb_add_char (acc, in->ptr[idx++]);
d298 16
a314 1
	  idx++;
d378 1
a378 1
	  idx = (*macro_expr) (_("% operator needs absolute expression"),
d386 1
a386 1
	       || (in->ptr[idx] == '<' && (macro_alternate || macro_mri))
d413 1
a413 2
			 && (in->ptr[idx] != '<'
			     || (! macro_alternate && ! macro_mri)))))
d540 1
a540 1
    return _("unexpected end of file in macro definition");
d544 1
a544 1
      if (idx < in->len && in->ptr[idx] == '(')
d549 1
a549 1
	    return _("missing ) after formals");
d566 1
a566 1
    if (isupper ((unsigned char) name.ptr[idx]))
a631 5
  else if (kind == '&')
    {
      /* Doing this permits people to use & in macro bodies.  */
      sb_add_char (out, '&');
    }
d676 2
a677 1
	      /* FIXME: Why do we do this?  */
d702 1
a702 1
		return _("missplaced )");
d708 1
a708 1
	      char buffer[10];
d878 1
a878 3
      /* Setting the value to NULL effectively deletes the entry.  We
         avoid calling hash_delete because it doesn't reclaim memory.  */
      hash_jam (formal_hash, sb_terminate (&loclist->name), NULL);
a947 1
	     && !(macro_mri && in->ptr[scan] == '\'')
d953 2
a954 2

	  /* It's OK to go from positional to keyword.  */
d961 1
a961 1
	    return _("confusion in formal parameters");
d966 1
a966 1
	    return _("macro formal argument does not exist");
d981 1
a981 1
	    return _("can't mix positional and keyword arguments");
d989 1
a989 1
		return _("too many positional arguments");
d1079 1
a1079 1
check_macro (line, expand, comment_char, error, info)
a1083 1
     macro_entry **info;
d1102 1
a1102 1
  copy = (char *) alloca (s - line + 1);
d1106 1
a1106 1
    if (isupper ((unsigned char) *cs))
a1123 4
  /* export the macro information if requested */
  if (info)
    *info = macro;

d1164 1
a1164 1
    return _("unexpected end of file in irp or irpc");
d1172 1
a1172 1
    return _("missing model parameter");
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
d22 1
a22 1
   02111-1307, USA.  */
d175 1
a175 1
      /* Try and find the first pseudo op on the line.  */
d183 1
a183 1
	     whats a pseudoop.  */
d185 1
a185 1
	  /* Skip leading whitespace.  */
d189 1
a189 1
	  /* Skip over a label.  */
d196 1
a196 1
	  /* And a colon.  */
d202 1
a202 1
      /* Skip trailing whitespace.  */
d211 1
a211 1
	    i++;
d213 1
a213 2
	      && (ptr->len == (i + from_len)
		  || ! isalnum (ptr->ptr[i + from_len])))
d216 1
a216 2
	      && (ptr->len == (i + to_len)
		  || ! isalnum (ptr->ptr[i + to_len])))
d221 1
a221 1
		  /* Reset the string to not include the ending rune.  */
d228 1
a228 1
      /* Add a CR to the end and keep running.  */
d260 1
a260 1
  /* Ignore trailing &.  */
d277 1
a277 1
	 && (in->ptr[idx] == '"'
d290 1
a290 1
		  idx++;
a306 2
	  int escaped = 0;

a307 1

a309 5
	      if (in->ptr[idx - 1] == '\\')
		escaped ^= 1;
	      else
		escaped = 0;

d312 2
a313 10
		  idx ++;

		  sb_add_char (acc, in->ptr[idx]);

		  idx ++;
		}
	      else if (escaped && in->ptr[idx] == tchar)
		{
		  sb_add_char (acc, tchar);
		  idx ++;
d319 1
a319 2
		      idx ++;

a322 1

d324 1
a324 1
		  idx ++;
d329 1
a329 1

d354 1
a354 1
      if (in->len > 2 && in->ptr[idx + 1] == '\'' && ISBASE (in->ptr[idx]))
d365 1
a365 1
	  /* Turns the next expression into a string.  */
d381 2
a382 2
	      /* Keep the quotes.  */
	      sb_add_char (out, '\"');
d385 1
a385 1
	      sb_add_char (out, '\"');
d392 1
a392 1
      else
d394 1
a394 1
	  while (idx < in->len
d397 1
a397 1
		     || pretend_quoted
d404 1
a404 1
	      if (in->ptr[idx] == '"'
d411 1
a411 1
		    sb_add_char (out, in->ptr[idx++]);
d413 1
a413 1
		    return idx;
d452 1
a452 1
	  /* This is a formal.  */
d455 1
a455 1
	      /* Got a default.  */
d460 1
a460 1
      /* Add to macro's hash table.  */
d493 1
a493 1
      /* Add to macro's hash table.  */
d535 1
a535 1
	  /* It's the label: MACRO (formals,...)  sort  */
d542 1
a542 1
	  /* It's the label: MACRO formals,...  sort  */
d553 1
a553 1
  /* And stick it in the macro hash table.  */
d630 1
a630 1
  else
d679 1
a679 1
	      /* This is a comment, just drop the rest of the line.  */
d686 1
a686 1
	      /* Sub in till the next ')' literally.  */
d699 1
a699 1
	      /* Sub in the macro invocation number.  */
d703 1
a703 1
	      sprintf (buffer, "%d", macro_number);
d709 1
a709 1
		 here.  */
d904 2
a905 2

  /* Reset any old value the actuals may have.  */
d907 1
a907 1
    sb_reset (&f->actual);
d933 1
a933 1
  /* Peel off the actuals and store them away in the hash tables' actuals.  */
d939 1
a939 1
      /* Look and see if it's a positional or keyword arg.  */
d953 1
a953 1
	     then the actual stuff.  */
d959 1
a959 1
	  /* Lookup the formal in the macro's list.  */
d965 1
a965 1
	      /* Insert this value into the right place.  */
d974 1
a974 1
	  /* This is a positional arg.  */
d1121 1
a1121 1
  /* Export the macro information if requested.  */
d1166 1
a1166 1

@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d1 2
a2 2
/* macro.c - macro support for gas
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d27 10
a36 1
#ifndef __GNUC__
a40 3
/* Indented so that pre-ansi C compilers will ignore it, rather than
   choke on it.  Some versions of AIX require this to be the first
   thing in the file.  */
d52 1
a52 1
#endif /* __GNUC__ */
d60 1
a64 1
#include "safe-ctype.h"
d72 1
a72 1
   They are called by gas.  */
d84 2
a85 2
  PARAMS ((sb *, sb *, formal_entry *, struct hash_control *, int));
static const char *macro_expand PARAMS ((int, sb *, macro_entry *, sb *));
d102 1
a102 1
struct hash_control *macro_hash;
d108 1
a108 1
/* Whether we are in alternate syntax mode.  */
d192 1
a192 1
		 && (ISALNUM (ptr->ptr[i])
d215 1
a215 1
		  || ! ISALNUM (ptr->ptr[i + from_len])))
d219 1
a219 1
		  || ! ISALNUM (ptr->ptr[i + to_len])))
d231 2
a232 2
      /* Add the original end-of-line char to the end and keep running.  */
      sb_add_char (ptr, more);
d250 1
a250 1
      && (ISALPHA (in->ptr[idx])
d256 1
a256 1
	     && (ISALNUM (in->ptr[idx])
d375 1
a375 1
      if (in->len > idx + 2 && in->ptr[idx + 1] == '\'' && ISBASE (in->ptr[idx]))
a386 1
	  /* xgettext: no-c-format */
d391 1
a391 1
	  sprintf (buf, "%d", val);
d576 2
a577 1
    name.ptr[idx] = TOLOWER (name.ptr[idx]);
a645 1
      sb_add_sb (out, t);
d662 1
a662 1
macro_expand_body (in, out, formals, formal_hash, locals)
d667 1
d698 8
a705 1
	  if (in->ptr[src] == '(')
d735 2
a736 1
	  else if (macro_mri && ISALNUM (in->ptr[src]))
d741 1
a741 1
	      if (ISDIGIT (in->ptr[src]))
d743 1
a743 1
	      else if (ISUPPER (in->ptr[src]))
d767 1
a767 1
	       && (ISALPHA (in->ptr[src])
d789 1
a789 1
	      while (in->ptr[src] != '\n')
d816 11
d909 1
a909 1
macro_expand (idx, in, m, out)
d914 1
d939 7
a945 14
	  /* The Microtec assembler ignores this if followed by a white space.
	     (Macro invocation with empty extension) */
	  idx++;
	  if (    idx < in->len
		  && in->ptr[idx] != ' '
		  && in->ptr[idx] != '\t')
	    {
	      formal_entry *n;

	      n = (formal_entry *) xmalloc (sizeof (formal_entry));
	      sb_new (&n->name);
	      sb_new (&n->def);
	      sb_new (&n->actual);
	      n->index = QUAL_INDEX;
d947 2
a948 2
	      n->next = m->formals;
	      m->formals = n;
d950 1
a950 2
	      idx = get_any_string (idx, in, &n->actual, 1, 0);
	    }
d956 1
a956 1
  while (idx < in->len)
d1058 2
a1059 1
  err = macro_expand_body (&m->sub, out, m->formals, m->formal_hash, 1);
d1092 2
a1093 1
   *EXPAND.  Return 1 if a macro is found, 0 otherwise.  */
d1096 1
a1096 1
check_macro (line, expand, error, info)
d1099 1
d1108 1
a1108 1
  if (! ISALPHA (*line)
d1115 1
a1115 1
  while (ISALNUM (*s)
d1124 2
a1125 1
    *cs = TOLOWER (*cs);
d1138 1
a1138 1
  *error = macro_expand (0, &line_sb, macro, expand);
d1163 1
a1163 1
expand_irp (irpc, idx, in, out, get_line)
d1169 1
d1207 1
a1207 1
  if (idx >= in->len)
d1210 1
a1210 1
      err = macro_expand_body (&sub, out, &f, h, 0);
d1218 1
a1218 1
      while (idx < in->len)
d1229 1
a1229 1
		  if (nxt >= in->len)
d1239 1
a1239 1
	  err = macro_expand_body (&sub, out, &f, h, 0);
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d70 7
a76 6
static int get_token (int, sb *, sb *);
static int getstring (int, sb *, sb *);
static int get_any_string (int, sb *, sb *, int, int);
static int do_formals (macro_entry *, int, sb *);
static int get_apost_token (int, sb *, sb *, int);
static int sub_actual (int, sb *, sb *, struct hash_control *, int, sb *, int);
d78 2
a79 2
  (sb *, sb *, formal_entry *, struct hash_control *, int);
static const char *macro_expand (int, sb *, macro_entry *, sb *);
d116 1
a116 1
static int (*macro_expr) (const char *, int, sb *, int *);
d125 5
a129 2
macro_init (int alternate, int mri, int strip_at,
	    int (*expr) (const char *, int, sb *, int *))
d142 2
a143 1
macro_mri_mode (int mri)
d155 5
a159 2
buffer_and_nest (const char *from, const char *to, sb *ptr,
		 int (*get_line) (sb *))
d238 4
a241 1
get_token (int idx, sb *in, sb *name)
d266 4
a269 1
getstring (int idx, sb *in, sb *acc)
d357 6
a362 1
get_any_string (int idx, sb *in, sb *out, int expand, int pretend_quoted)
d442 4
a445 1
do_formals (macro_entry *macro, int idx, sb *in)
d525 6
a530 2
define_macro (int idx, sb *in, sb *label,
	      int (*get_line) (sb *), const char **namep)
d586 5
a590 1
get_apost_token (int idx, sb *in, sb *name, int kind)
d604 8
a611 2
sub_actual (int start, sb *in, sb *t, struct hash_control *formal_hash,
	    int kind, sb *out, int copyifnotthere)
d657 6
a662 2
macro_expand_body (sb *in, sb *out, formal_entry *formals,
		   struct hash_control *formal_hash, int locals)
d884 5
a888 1
macro_expand (int idx, sb *in, macro_entry *m, sb *out)
d1076 5
a1080 2
check_macro (const char *line, sb *expand,
	     const char **error, macro_entry **info)
d1130 2
a1131 1
delete_macro (const char *name)
d1141 6
a1146 1
expand_irp (int irpc, int idx, sb *in, sb *out, int (*get_line) (sb *))
@


