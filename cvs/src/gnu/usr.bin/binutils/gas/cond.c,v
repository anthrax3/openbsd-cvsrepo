head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.50
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.48
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.44
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.46
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.38
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.42
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.40
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BINUTILS_2_15:1.1.1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	BINUTILS-2_14:1.1.1.6
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	binutils-2_11_2:1.1.1.5
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	BINUTILS-2_10_1:1.1.1.4
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	BINUTILS-2_10:1.1.1.4
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	new-binutils:1.2.0.16
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	BINUTILS-2_8_1:1.1.1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	CYGNUS-961112:1.1.1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.11.02.20.45.23;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.17.21.54.28;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.12.19.11.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.17;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.32;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.32;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.22;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.05.29.09.21.35;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.09.12.14.46.08;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.05.13.13.31.08;	author fgsch;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.05.17.20.42.24;	author drahn;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.11.02.20.22.41;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* cond.c - conditional assembly pseudo-ops, and .include
   Copyright 1990, 1991, 1992, 1993, 1995, 1997, 1998, 2000, 2001
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "as.h"
#include "macro.h"

#include "obstack.h"

/* This is allocated to grow and shrink as .ifdef/.endif pairs are
   scanned.  */
struct obstack cond_obstack;

struct file_line {
  char *file;
  unsigned int line;
};

/* We push one of these structures for each .if, and pop it at the
   .endif.  */

struct conditional_frame {
  /* The source file & line number of the "if".  */
  struct file_line if_file_line;
  /* The source file & line of the "else".  */
  struct file_line else_file_line;
  /* The previous conditional.  */
  struct conditional_frame *previous_cframe;
  /* Have we seen an else yet?  */
  int else_seen;
  /* Whether we are currently ignoring input.  */
  int ignoring;
  /* Whether a conditional at a higher level is ignoring input.
     Set also when a branch of an "if .. elseif .." tree has matched
     to prevent further matches.  */
  int dead_tree;
  /* Macro nesting level at which this conditional was created.  */
  int macro_nest;
};

static void initialize_cframe (struct conditional_frame *cframe);
static char *get_mri_string (int, int *);

static struct conditional_frame *current_cframe = NULL;

/* Performs the .ifdef (test_defined == 1) and
   the .ifndef (test_defined == 0) pseudo op.  */

void
s_ifdef (int test_defined)
{
  /* Points to name of symbol.  */
  char *name;
  /* Points to symbol.  */
  symbolS *symbolP;
  struct conditional_frame cframe;
  char c;

  /* Leading whitespace is part of operand.  */
  SKIP_WHITESPACE ();
  name = input_line_pointer;

  if (!is_name_beginner (*name))
    {
      as_bad (_("invalid identifier for \".ifdef\""));
      obstack_1grow (&cond_obstack, 0);
      ignore_rest_of_line ();
      return;
    }

  c = get_symbol_end ();
  symbolP = symbol_find (name);
  *input_line_pointer = c;

  initialize_cframe (&cframe);
  
  if (cframe.dead_tree)
    cframe.ignoring = 1;
  else
    {
      int is_defined;

      /* Use the same definition of 'defined' as .equiv so that a symbol
	 which has been referenced but not yet given a value/address is
	 considered to be undefined.  */
      is_defined =
	symbolP != NULL
	&& S_IS_DEFINED (symbolP)
	&& S_GET_SEGMENT (symbolP) != reg_section;

      cframe.ignoring = ! (test_defined ^ is_defined);
    }

  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe,
				  sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  demand_empty_rest_of_line ();
}

void
s_if (int arg)
{
  expressionS operand;
  struct conditional_frame cframe;
  int t;
  char *stop = NULL;
  char stopc;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  /* Leading whitespace is part of operand.  */
  SKIP_WHITESPACE ();

  if (current_cframe != NULL && current_cframe->ignoring)
    {
      operand.X_add_number = 0;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }
  else
    {
      expression (&operand);
      if (operand.X_op != O_constant)
	as_bad (_("non-constant expression in \".if\" statement"));
    }

  switch ((operatorT) arg)
    {
    case O_eq: t = operand.X_add_number == 0; break;
    case O_ne: t = operand.X_add_number != 0; break;
    case O_lt: t = operand.X_add_number < 0; break;
    case O_le: t = operand.X_add_number <= 0; break;
    case O_ge: t = operand.X_add_number >= 0; break;
    case O_gt: t = operand.X_add_number > 0; break;
    default:
      abort ();
      return;
    }

  /* If the above error is signaled, this will dispatch
     using an undefined result.  No big deal.  */
  initialize_cframe (&cframe);
  cframe.ignoring = cframe.dead_tree || ! t;
  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe, sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  if (flag_mri)
    mri_comment_end (stop, stopc);

  demand_empty_rest_of_line ();
}

/* Get a string for the MRI IFC or IFNC pseudo-ops.  */

static char *
get_mri_string (int terminator, int *len)
{
  char *ret;
  char *s;

  SKIP_WHITESPACE ();
  s = ret = input_line_pointer;
  if (*input_line_pointer == '\'')
    {
      ++s;
      ++input_line_pointer;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	{
	  *s++ = *input_line_pointer++;
	  if (s[-1] == '\'')
	    {
	      if (*input_line_pointer != '\'')
		break;
	      ++input_line_pointer;
	    }
	}
      SKIP_WHITESPACE ();
    }
  else
    {
      while (*input_line_pointer != terminator
	     && ! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
      s = input_line_pointer;
      while (s > ret && (s[-1] == ' ' || s[-1] == '\t'))
	--s;
    }

  *len = s - ret;
  return ret;
}

/* The MRI IFC and IFNC pseudo-ops.  */

void
s_ifc (int arg)
{
  char *stop = NULL;
  char stopc;
  char *s1, *s2;
  int len1, len2;
  int res;
  struct conditional_frame cframe;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  s1 = get_mri_string (',', &len1);

  if (*input_line_pointer != ',')
    as_bad (_("bad format for ifc or ifnc"));
  else
    ++input_line_pointer;

  s2 = get_mri_string (';', &len2);

  res = len1 == len2 && strncmp (s1, s2, len1) == 0;

  initialize_cframe (&cframe);
  cframe.ignoring = cframe.dead_tree || ! (res ^ arg);
  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe, sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  if (flag_mri)
    mri_comment_end (stop, stopc);

  demand_empty_rest_of_line ();
}

void
s_elseif (int arg)
{
  if (current_cframe == NULL)
    {
      as_bad (_("\".elseif\" without matching \".if\""));
    }
  else if (current_cframe->else_seen)
    {
      as_bad (_("\".elseif\" after \".else\""));
      as_bad_where (current_cframe->else_file_line.file,
		    current_cframe->else_file_line.line,
		    _("here is the previous \"else\""));
      as_bad_where (current_cframe->if_file_line.file,
		    current_cframe->if_file_line.line,
		    _("here is the previous \"if\""));
    }
  else
    {
      as_where (&current_cframe->else_file_line.file,
		&current_cframe->else_file_line.line);

      current_cframe->dead_tree |= !current_cframe->ignoring;
      current_cframe->ignoring = current_cframe->dead_tree;
    }

  if (current_cframe == NULL || current_cframe->ignoring)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;

      if (current_cframe == NULL)
	return;
    }
  else
    {
      expressionS operand;
      int t;

      /* Leading whitespace is part of operand.  */
      SKIP_WHITESPACE ();

      expression (&operand);
      if (operand.X_op != O_constant)
	as_bad (_("non-constant expression in \".elseif\" statement"));

      switch ((operatorT) arg)
	{
	case O_eq: t = operand.X_add_number == 0; break;
	case O_ne: t = operand.X_add_number != 0; break;
	case O_lt: t = operand.X_add_number < 0; break;
	case O_le: t = operand.X_add_number <= 0; break;
	case O_ge: t = operand.X_add_number >= 0; break;
	case O_gt: t = operand.X_add_number > 0; break;
	default:
	  abort ();
	  return;
	}

      current_cframe->ignoring = current_cframe->dead_tree || ! t;
    }

  if (LISTING_SKIP_COND ()
      && (current_cframe->previous_cframe == NULL
	  || ! current_cframe->previous_cframe->ignoring))
    {
      if (! current_cframe->ignoring)
	listing_list (1);
      else
	listing_list (2);
    }

  demand_empty_rest_of_line ();
}

void
s_endif (int arg ATTRIBUTE_UNUSED)
{
  struct conditional_frame *hold;

  if (current_cframe == NULL)
    {
      as_bad (_("\".endif\" without \".if\""));
    }
  else
    {
      if (LISTING_SKIP_COND ()
	  && current_cframe->ignoring
	  && (current_cframe->previous_cframe == NULL
	      || ! current_cframe->previous_cframe->ignoring))
	listing_list (1);

      hold = current_cframe;
      current_cframe = current_cframe->previous_cframe;
      obstack_free (&cond_obstack, hold);
    }				/* if one pop too many */

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

void
s_else (int arg ATTRIBUTE_UNUSED)
{
  if (current_cframe == NULL)
    {
      as_bad (_("\".else\" without matching \".if\""));
    }
  else if (current_cframe->else_seen)
    {
      as_bad (_("duplicate \"else\""));
      as_bad_where (current_cframe->else_file_line.file,
		    current_cframe->else_file_line.line,
		    _("here is the previous \"else\""));
      as_bad_where (current_cframe->if_file_line.file,
		    current_cframe->if_file_line.line,
		    _("here is the previous \"if\""));
    }
  else
    {
      as_where (&current_cframe->else_file_line.file,
		&current_cframe->else_file_line.line);

      current_cframe->ignoring =
	current_cframe->dead_tree | !current_cframe->ignoring;

      if (LISTING_SKIP_COND ()
	  && (current_cframe->previous_cframe == NULL
	      || ! current_cframe->previous_cframe->ignoring))
	{
	  if (! current_cframe->ignoring)
	    listing_list (1);
	  else
	    listing_list (2);
	}

      current_cframe->else_seen = 1;
    }

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

void
s_ifeqs (int arg)
{
  char *s1, *s2;
  int len1, len2;
  int res;
  struct conditional_frame cframe;

  s1 = demand_copy_C_string (&len1);

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_(".ifeqs syntax error"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;

  s2 = demand_copy_C_string (&len2);

  res = len1 == len2 && strncmp (s1, s2, len1) == 0;

  initialize_cframe (&cframe);
  cframe.ignoring = cframe.dead_tree || ! (res ^ arg);
  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe, sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  demand_empty_rest_of_line ();
}

int
ignore_input (void)
{
  char *s;

  s = input_line_pointer;

  if (NO_PSEUDO_DOT || flag_m68k_mri)
    {
      if (s[-1] != '.')
	--s;
    }
  else
    {
      if (s[-1] != '.')
	return (current_cframe != NULL) && (current_cframe->ignoring);
    }

  /* We cannot ignore certain pseudo ops.  */
  if (((s[0] == 'i'
	|| s[0] == 'I')
       && (!strncasecmp (s, "if", 2)
	   || !strncasecmp (s, "ifdef", 5)
	   || !strncasecmp (s, "ifndef", 6)))
      || ((s[0] == 'e'
	   || s[0] == 'E')
	  && (!strncasecmp (s, "else", 4)
	      || !strncasecmp (s, "endif", 5)
	      || !strncasecmp (s, "endc", 4))))
    return 0;

  return (current_cframe != NULL) && (current_cframe->ignoring);
}

static void
initialize_cframe (struct conditional_frame *cframe)
{
  memset (cframe, 0, sizeof (*cframe));
  as_where (&cframe->if_file_line.file,
	    &cframe->if_file_line.line);
  cframe->previous_cframe = current_cframe;
  cframe->dead_tree = current_cframe != NULL && current_cframe->ignoring;
  cframe->macro_nest = macro_nest;
}

/* Give an error if a conditional is unterminated inside a macro or
   the assembly as a whole.  If NEST is non negative, we are being
   called because of the end of a macro expansion.  If NEST is
   negative, we are being called at the of the input files.  */

void
cond_finish_check (int nest)
{
  if (current_cframe != NULL && current_cframe->macro_nest >= nest)
    {
      if (nest >= 0)
	as_bad (_("end of macro inside conditional"));
      else
	as_bad (_("end of file inside conditional"));
      as_bad_where (current_cframe->if_file_line.file,
		    current_cframe->if_file_line.line,
		    _("here is the start of the unterminated conditional"));
      if (current_cframe->else_seen)
	as_bad_where (current_cframe->else_file_line.file,
		      current_cframe->else_file_line.line,
		      _("here is the \"else\" of the unterminated conditional"));
    }
}

/* This function is called when we exit out of a macro.  We assume
   that any conditionals which began within the macro are correctly
   nested, and just pop them off the stack.  */

void
cond_exit_macro (int nest)
{
  while (current_cframe != NULL && current_cframe->macro_nest >= nest)
    {
      struct conditional_frame *hold;

      hold = current_cframe;
      current_cframe = current_cframe->previous_cframe;
      obstack_free (&cond_obstack, hold);
    }
}
@


1.5
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d58 2
a59 2
static void initialize_cframe PARAMS ((struct conditional_frame *cframe));
static char *get_mri_string PARAMS ((int, int *));
d67 1
a67 2
s_ifdef (test_defined)
     int test_defined;
d125 1
a125 2
s_if (arg)
     int arg;
d187 1
a187 3
get_mri_string (terminator, len)
     int terminator;
     int *len;
d227 1
a227 2
s_ifc (arg)
     int arg;
d268 1
a268 2
s_elseif (arg)
     int arg;
d343 1
a343 2
s_endif (arg)
     int arg ATTRIBUTE_UNUSED;
d374 1
a374 2
s_else (arg)
     int arg ATTRIBUTE_UNUSED;
d421 1
a421 2
s_ifeqs (arg)
     int arg;
d459 1
a459 1
ignore_input ()
d493 1
a493 2
initialize_cframe (cframe)
     struct conditional_frame *cframe;
d509 1
a509 2
cond_finish_check (nest)
     int nest;
d532 1
a532 2
cond_exit_macro (nest)
     int nest;
@


1.4
log
@resolve conflicts.
@
text
@d63 3
d67 2
a68 2
s_ifdef (arg)
     int arg;
d71 1
a71 1
  register char *name;
d73 1
a73 1
  register symbolS *symbolP;
d75 1
d86 1
d88 9
d99 12
a110 1
      char c;
d112 3
a114 9
      c = get_symbol_end ();
      symbolP = symbol_find (name);
      *input_line_pointer = c;

      initialize_cframe (&cframe);
      cframe.ignoring = cframe.dead_tree || !((symbolP != 0) ^ arg);
      current_cframe = ((struct conditional_frame *)
			obstack_copy (&cond_obstack, &cframe,
				      sizeof (cframe)));
d116 5
a120 5
      if (LISTING_SKIP_COND ()
	  && cframe.ignoring
	  && (cframe.previous_cframe == NULL
	      || ! cframe.previous_cframe->ignoring))
	listing_list (2);
d122 1
a122 2
      demand_empty_rest_of_line ();
    }				/* if a valid identifyer name */
d278 1
a278 1
      as_bad (_("\".elseif\" without matching \".if\" - ignored"));
d282 1
a282 1
      as_bad (_("\".elseif\" after \".else\" - ignored"));
d386 1
a386 1
      as_bad (_(".else without matching .if - ignored"));
d390 1
a390 1
      as_bad (_("duplicate \"else\" - ignored"));
@


1.3
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 95, 96, 97, 98, 99, 2000
d27 2
a28 1
/* This is allocated to grow and shrink as .ifdef/.endif pairs are scanned. */
d31 1
a31 2
struct file_line
{
d39 1
a39 2
struct conditional_frame
{
d50 3
a52 1
  /* Whether a conditional at a higher level is ignoring input.  */
d63 1
a63 1
void 
d67 4
a70 2
  register char *name;		/* points to name of symbol */
  register symbolS *symbolP;	/* Points to symbol */
d73 2
a74 1
  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand. */
d105 1
a105 1
}				/* s_ifdef() */
d107 1
a107 1
void 
d120 2
a121 1
  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand. */
d166 1
a166 1
}				/* s_if() */
d254 1
a254 1
void 
a257 3
  expressionS operand;
  int t;

a260 1

d277 3
a279 12
      if (!current_cframe->dead_tree)
	{
	  current_cframe->ignoring = !current_cframe->ignoring;
	  if (LISTING_SKIP_COND ())
	    {
	      if (! current_cframe->ignoring)
		listing_list (1);
	      else
		listing_list (2);
	    }
	}			/* if not a dead tree */
    }				/* if error else do it */
d281 1
a281 4

  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand. */

  if (current_cframe != NULL && current_cframe->ignoring)
a282 1
      operand.X_add_number = 0;
d285 3
d291 6
d300 15
a314 13
    }
  
  switch ((operatorT) arg)
    {
    case O_eq: t = operand.X_add_number == 0; break;
    case O_ne: t = operand.X_add_number != 0; break;
    case O_lt: t = operand.X_add_number < 0; break;
    case O_le: t = operand.X_add_number <= 0; break;
    case O_ge: t = operand.X_add_number >= 0; break;
    case O_gt: t = operand.X_add_number > 0; break;
    default:
      abort ();
      return;
a316 2
  current_cframe->ignoring = current_cframe->dead_tree || ! t;

a317 1
      && current_cframe->ignoring
d320 6
a325 1
    listing_list (2);
d330 1
a330 1
void 
d360 1
a360 1
}				/* s_endif() */
d362 1
a362 1
void 
a368 1

d385 6
a390 1
      if (!current_cframe->dead_tree)
d392 5
a396 9
	  current_cframe->ignoring = !current_cframe->ignoring;
	  if (LISTING_SKIP_COND ())
	    {
	      if (! current_cframe->ignoring)
		listing_list (1);
	      else
		listing_list (2);
	    }
	}			/* if not a dead tree */
d399 1
a399 1
    }				/* if error else do it */
d408 1
a408 1
}				/* s_else() */
d410 1
a410 1
void 
d447 1
a447 1
}				/* s_ifeqs() */
d449 1
a449 1
int 
d481 1
a481 1
}				/* ignore_input() */
d483 1
a483 1
static void 
a536 2

/* end of cond.c */
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 95, 1996 Free Software Foundation, Inc.
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 1
d34 4
a37 1
};				/* file_line */
a38 1
/* This is what we push and pop. */
d40 16
a55 8
  {
    struct file_line if_file_line;	/* the source file & line number of the "if" */
    struct file_line else_file_line;	/* the source file & line of the "else" */
    struct conditional_frame *previous_cframe;
    int else_seen;		/* have we seen an else yet? */
    int ignoring;		/* if we are currently ignoring input. */
    int dead_tree;		/* if a conditional at a higher level is ignoring input. */
  };				/* conditional_frame */
d67 1
a67 1
  register struct symbol *symbolP;	/* Points to symbol */
d75 1
a75 1
      as_bad ("invalid identifier for \".ifdef\"");
d92 7
d128 1
a128 1
	as_bad ("non-constant expression in \".if\" statement");
d141 1
d151 6
d211 2
d218 3
d224 1
a224 1
    as_bad ("bad format for ifc or ifnc");
d236 91
d331 1
a331 1
     int arg;
d337 1
a337 1
      as_bad ("\".endif\" without \".if\"");
d341 6
d363 1
a363 1
     int arg;
d367 1
a367 1
      as_bad (".else without matching .if - ignored");
d372 1
a372 1
      as_bad ("duplicate \"else\" - ignored");
d375 1
a375 1
		    "here is the previous \"else\"");
d378 1
a378 1
		    "here is the previous \"if\"");
d388 7
d423 1
a423 1
      as_bad (".ifeqs syntax error");
d439 6
d455 1
a455 5
  if (flag_m68k_mri
#ifdef NO_PSEUDO_DOT
      || 1
#endif
      )
d491 27
d519 3
a521 2
  return;
}				/* initialize_cframe() */
d523 13
a535 6
/*
 * Local Variables:
 * fill-column: 131
 * comment-column: 0
 * End:
 */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
d313 1
a313 5
#ifndef MRI_MODE_NEEDS_PSEUDO_DOT
#define MRI_MODE_NEEDS_PSEUDO_DOT 0
#endif

  if ((flag_mri && ! MRI_MODE_NEEDS_PSEUDO_DOT)
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 95, 1996 Free Software Foundation, Inc.
d313 5
a317 1
  if (flag_m68k_mri
@


1.1.1.3
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 95, 96, 1997 Free Software Foundation, Inc.
d17 2
a18 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a20 1
#include "macro.h"
d31 1
a31 4
};

/* We push one of these structures for each .if, and pop it at the
   .endif.  */
d33 1
d35 8
a42 16
{
  /* The source file & line number of the "if".  */
  struct file_line if_file_line;
  /* The source file & line of the "else".  */
  struct file_line else_file_line;
  /* The previous conditional.  */
  struct conditional_frame *previous_cframe;
  /* Have we seen an else yet?  */
  int else_seen;
  /* Whether we are currently ignoring input.  */
  int ignoring;
  /* Whether a conditional at a higher level is ignoring input.  */
  int dead_tree;
  /* Macro nesting level at which this conditional was created.  */
  int macro_nest;
};
a78 7

      if (LISTING_SKIP_COND ()
	  && cframe.ignoring
	  && (cframe.previous_cframe == NULL
	      || ! cframe.previous_cframe->ignoring))
	listing_list (2);

a129 6
  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

a183 2
  char *stop = NULL;
  char stopc;
a188 3
  if (flag_mri)
    stop = mri_comment_field (&stopc);

a203 9

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  if (flag_mri)
    mri_comment_end (stop, stopc);
a217 6
      if (LISTING_SKIP_COND ()
	  && current_cframe->ignoring
	  && (current_cframe->previous_cframe == NULL
	      || ! current_cframe->previous_cframe->ignoring))
	listing_list (1);

a258 3
	  if (LISTING_SKIP_COND ()
	      && ! current_cframe->ignoring)
	    listing_list (1);
a302 6
  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

a352 2
  cframe->macro_nest = macro_nest;
}
d354 2
a355 4
/* Give an error if a conditional is unterminated inside a macro or
   the assembly as a whole.  If NEST is non negative, we are being
   called because of the end of a macro expansion.  If NEST is
   negative, we are being called at the of the input files.  */
d357 6
a362 35
void
cond_finish_check (nest)
     int nest;
{
  if (current_cframe != NULL && current_cframe->macro_nest >= nest)
    {
      as_bad ("end of %s inside conditional",
	      nest >= 0 ? "macro" : "file");
      as_bad_where (current_cframe->if_file_line.file,
		    current_cframe->if_file_line.line,
		    "here is the start of the unterminated conditional");
      if (current_cframe->else_seen)
	as_bad_where (current_cframe->else_file_line.file,
		      current_cframe->else_file_line.line,
		      "here is the \"else\" of the unterminated conditional");
    }
}

/* This function is called when we exit out of a macro.  We assume
   that any conditionals which began within the macro are correctly
   nested, and just pop them off the stack.  */

void
cond_exit_macro (nest)
     int nest;
{
  while (current_cframe != NULL && current_cframe->macro_nest >= nest)
    {
      struct conditional_frame *hold;

      hold = current_cframe;
      current_cframe = current_cframe->previous_cframe;
      obstack_free (&cond_obstack, hold);
    }
}
@


1.1.1.4
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1990, 91, 92, 93, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d66 1
a66 1
  register symbolS *symbolP;	/* Points to symbol */
d74 1
a74 1
      as_bad (_("invalid identifier for \".ifdef\""));
d127 1
a127 1
	as_bad (_("non-constant expression in \".if\" statement"));
a139 1
      return;
d222 1
a222 1
    as_bad (_("bad format for ifc or ifnc"));
a242 2

  demand_empty_rest_of_line ();
d246 1
a246 1
s_elseif (arg)
a248 80
  expressionS operand;
  int t;

  if (current_cframe == NULL)
    {
      as_bad (_("\".elseif\" without matching \".if\" - ignored"));

    }
  else if (current_cframe->else_seen)
    {
      as_bad (_("\".elseif\" after \".else\" - ignored"));
      as_bad_where (current_cframe->else_file_line.file,
		    current_cframe->else_file_line.line,
		    _("here is the previous \"else\""));
      as_bad_where (current_cframe->if_file_line.file,
		    current_cframe->if_file_line.line,
		    _("here is the previous \"if\""));
    }
  else
    {
      as_where (&current_cframe->else_file_line.file,
		&current_cframe->else_file_line.line);

      if (!current_cframe->dead_tree)
	{
	  current_cframe->ignoring = !current_cframe->ignoring;
	  if (LISTING_SKIP_COND ())
	    {
	      if (! current_cframe->ignoring)
		listing_list (1);
	      else
		listing_list (2);
	    }
	}			/* if not a dead tree */
    }				/* if error else do it */


  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand. */

  if (current_cframe != NULL && current_cframe->ignoring)
    {
      operand.X_add_number = 0;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }
  else
    {
      expression (&operand);
      if (operand.X_op != O_constant)
	as_bad (_("non-constant expression in \".elseif\" statement"));
    }
  
  switch ((operatorT) arg)
    {
    case O_eq: t = operand.X_add_number == 0; break;
    case O_ne: t = operand.X_add_number != 0; break;
    case O_lt: t = operand.X_add_number < 0; break;
    case O_le: t = operand.X_add_number <= 0; break;
    case O_ge: t = operand.X_add_number >= 0; break;
    case O_gt: t = operand.X_add_number > 0; break;
    default:
      abort ();
      return;
    }

  current_cframe->ignoring = current_cframe->dead_tree || ! t;

  if (LISTING_SKIP_COND ()
      && current_cframe->ignoring
      && (current_cframe->previous_cframe == NULL
	  || ! current_cframe->previous_cframe->ignoring))
    listing_list (2);

  demand_empty_rest_of_line ();
}

void 
s_endif (arg)
     int arg ATTRIBUTE_UNUSED;
{
d253 1
a253 1
      as_bad (_("\".endif\" without \".if\""));
d279 1
a279 1
     int arg ATTRIBUTE_UNUSED;
d283 1
a283 1
      as_bad (_(".else without matching .if - ignored"));
d288 1
a288 1
      as_bad (_("duplicate \"else\" - ignored"));
d291 1
a291 1
		    _("here is the previous \"else\""));
d294 1
a294 1
		    _("here is the previous \"if\""));
d304 3
a306 7
	  if (LISTING_SKIP_COND ())
	    {
	      if (! current_cframe->ignoring)
		listing_list (1);
	      else
		listing_list (2);
	    }
d335 1
a335 1
      as_bad (_(".ifeqs syntax error"));
d367 5
a371 1
  if (NO_PSEUDO_DOT || flag_m68k_mri)
d421 2
a422 4
      if (nest >= 0)
	as_bad (_("end of macro inside conditional"));
      else
	as_bad (_("end of file inside conditional"));
d425 1
a425 1
		    _("here is the start of the unterminated conditional"));
d429 1
a429 1
		      _("here is the \"else\" of the unterminated conditional"));
@


1.1.1.5
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1995, 1997, 1998, 2000, 2001
d27 1
a27 2
/* This is allocated to grow and shrink as .ifdef/.endif pairs are
   scanned.  */
d30 2
a31 1
struct file_line {
d39 2
a40 1
struct conditional_frame {
d51 1
a51 3
  /* Whether a conditional at a higher level is ignoring input.
     Set also when a branch of an "if .. elseif .." tree has matched
     to prevent further matches.  */
d62 1
a62 1
void
d66 2
a67 4
  /* Points to name of symbol.  */
  register char *name;
  /* Points to symbol.  */
  register symbolS *symbolP;
d70 1
a70 2
  /* Leading whitespace is part of operand.  */
  SKIP_WHITESPACE ();
d101 1
a101 1
}
d103 1
a103 1
void
d116 1
a116 2
  /* Leading whitespace is part of operand.  */
  SKIP_WHITESPACE ();
d161 1
a161 1
}
d249 1
a249 1
void
d253 3
d259 1
d276 15
a290 3
      current_cframe->dead_tree |= !current_cframe->ignoring;
      current_cframe->ignoring = current_cframe->dead_tree;
    }
d292 1
a292 1
  if (current_cframe == NULL || current_cframe->ignoring)
d294 1
a296 3

      if (current_cframe == NULL)
	return;
a299 6
      expressionS operand;
      int t;

      /* Leading whitespace is part of operand.  */
      SKIP_WHITESPACE ();

d303 14
d318 1
a318 15
      switch ((operatorT) arg)
	{
	case O_eq: t = operand.X_add_number == 0; break;
	case O_ne: t = operand.X_add_number != 0; break;
	case O_lt: t = operand.X_add_number < 0; break;
	case O_le: t = operand.X_add_number <= 0; break;
	case O_ge: t = operand.X_add_number >= 0; break;
	case O_gt: t = operand.X_add_number > 0; break;
	default:
	  abort ();
	  return;
	}

      current_cframe->ignoring = current_cframe->dead_tree || ! t;
    }
d321 1
d324 1
a324 6
    {
      if (! current_cframe->ignoring)
	listing_list (1);
      else
	listing_list (2);
    }
d329 1
a329 1
void
d359 1
a359 1
}
d361 1
a361 1
void
d368 1
d385 1
a385 6
      current_cframe->ignoring =
	current_cframe->dead_tree | !current_cframe->ignoring;

      if (LISTING_SKIP_COND ()
	  && (current_cframe->previous_cframe == NULL
	      || ! current_cframe->previous_cframe->ignoring))
d387 9
a395 5
	  if (! current_cframe->ignoring)
	    listing_list (1);
	  else
	    listing_list (2);
	}
d398 1
a398 1
    }
d407 1
a407 1
}
d409 1
a409 1
void
d446 1
a446 1
}
d448 1
a448 1
int
d480 1
a480 1
}
d482 1
a482 1
static void
d536 2
@


1.1.1.6
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@a62 3
/* Performs the .ifdef (test_defined == 1) and
   the .ifndef (test_defined == 0) pseudo op.  */

d64 2
a65 2
s_ifdef (test_defined)
     int test_defined;
d68 1
a68 1
  char *name;
d70 1
a70 1
  symbolS *symbolP;
a71 1
  char c;
a81 1
      return;
a82 9

  c = get_symbol_end ();
  symbolP = symbol_find (name);
  *input_line_pointer = c;

  initialize_cframe (&cframe);
  
  if (cframe.dead_tree)
    cframe.ignoring = 1;
d85 1
a85 1
      int is_defined;
d87 9
a95 7
      /* Use the same definition of 'defined' as .equiv so that a symbol
	 which has been referenced but not yet given a value/address is
	 considered to be undefined.  */
      is_defined =
	symbolP != NULL
	&& S_IS_DEFINED (symbolP)
	&& S_GET_SEGMENT (symbolP) != reg_section;
d97 5
a101 2
      cframe.ignoring = ! (test_defined ^ is_defined);
    }
d103 2
a104 11
  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe,
				  sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  demand_empty_rest_of_line ();
d260 1
a260 1
      as_bad (_("\".elseif\" without matching \".if\""));
d264 1
a264 1
      as_bad (_("\".elseif\" after \".else\""));
d368 1
a368 1
      as_bad (_("\".else\" without matching \".if\""));
d372 1
a372 1
      as_bad (_("duplicate \"else\""));
@


1.1.1.7
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d58 2
a59 2
static void initialize_cframe (struct conditional_frame *cframe);
static char *get_mri_string (int, int *);
d67 2
a68 1
s_ifdef (int test_defined)
d126 2
a127 1
s_if (int arg)
d189 3
a191 1
get_mri_string (int terminator, int *len)
d231 2
a232 1
s_ifc (int arg)
d273 2
a274 1
s_elseif (int arg)
d349 2
a350 1
s_endif (int arg ATTRIBUTE_UNUSED)
d381 2
a382 1
s_else (int arg ATTRIBUTE_UNUSED)
d429 2
a430 1
s_ifeqs (int arg)
d468 1
a468 1
ignore_input (void)
d502 2
a503 1
initialize_cframe (struct conditional_frame *cframe)
d519 2
a520 1
cond_finish_check (int nest)
d543 2
a544 1
cond_exit_macro (int nest)
@


