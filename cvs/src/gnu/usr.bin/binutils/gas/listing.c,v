head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.48
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.44
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.46
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.38
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.42
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.40
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.36
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.34
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.32
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	BINUTILS_2_15:1.1.1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	BINUTILS-2_14:1.1.1.7
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	binutils-2_11_2:1.1.1.6
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	BINUTILS-2_10_1:1.1.1.5
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	BINUTILS-2_10:1.1.1.5
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	new-binutils:1.3.0.14
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	BINUTILS-2_8_1:1.1.1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	CYGNUS-961112:1.1.1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	CYGNUS-960904:1.1.1.2
	CYGNUS-960609:1.1.1.1
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.11.02.20.45.24;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.17.21.54.28;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.19.11.42;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.23.03.34.22;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.09.04.19.04.44;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.41;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.41;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.09.04.17.43.38;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.11.19.14.14.04;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.05.29.09.21.58;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.09.12.14.46.12;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.05.13.13.32.08;	author fgsch;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.05.17.20.42.26;	author drahn;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.11.02.20.22.43;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* listing.c - maintain assembly listings
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* Contributed by Steve Chamberlain <sac@@cygnus.com>

 A listing page looks like:

 LISTING_HEADER  sourcefilename pagenumber
 TITLE LINE
 SUBTITLE LINE
 linenumber address data  source
 linenumber address data  source
 linenumber address data  source
 linenumber address data  source

 If not overridden, the listing commands are:

 .title  "stuff"
 	Put "stuff" onto the title line
 .sbttl  "stuff"
        Put stuff onto the subtitle line

  If these commands come within 10 lines of the top of the page, they
  will affect the page they are on, as well as any subsequent page

 .eject
 	Thow a page
 .list
 	Increment the enable listing counter
 .nolist
 	Decrement the enable listing counter

 .psize Y[,X]
 	Set the paper size to X wide and Y high. Setting a psize Y of
	zero will suppress form feeds except where demanded by .eject

 If the counter goes below zero, listing is suppressed.

 Listings are a maintained by read calling various listing_<foo>
 functions.  What happens most is that the macro NO_LISTING is not
 defined (from the Makefile), then the macro LISTING_NEWLINE expands
 into a call to listing_newline.  The call is done from read.c, every
 time it sees a newline, and -l is on the command line.

 The function listing_newline remembers the frag associated with the
 newline, and creates a new frag - note that this is wasteful, but not
 a big deal, since listing slows things down a lot anyway.  The
 function also remembers when the filename changes.

 When all the input has finished, and gas has had a chance to settle
 down, the listing is output. This is done by running down the list of
 frag/source file records, and opening the files as needed and printing
 out the bytes and chars associated with them.

 The only things which the architecture can change about the listing
 are defined in these macros:

 LISTING_HEADER		The name of the architecture
 LISTING_WORD_SIZE      The make of the number of bytes in a word, this determines
 			the clumping of the output data. eg a value of
			2 makes words look like 1234 5678, whilst 1
			would make the same value look like 12 34 56
			78
 LISTING_LHS_WIDTH      Number of words of above size for the lhs

 LISTING_LHS_WIDTH_SECOND   Number of words for the data on the lhs
 			for the second line

 LISTING_LHS_CONT_LINES	Max number of lines to use up for a continuation
 LISTING_RHS_WIDTH      Number of chars from the input file to print
                        on a line.  */

#include "as.h"
#include "obstack.h"
#include "safe-ctype.h"
#include "input-file.h"
#include "subsegs.h"

#ifndef NO_LISTING

#ifndef LISTING_HEADER
#define LISTING_HEADER "GAS LISTING"
#endif
#ifndef LISTING_WORD_SIZE
#define LISTING_WORD_SIZE 4
#endif
#ifndef LISTING_LHS_WIDTH
#define LISTING_LHS_WIDTH ((LISTING_WORD_SIZE) > 4 ? 1 : 4 / (LISTING_WORD_SIZE))
#endif
#ifndef LISTING_LHS_WIDTH_SECOND
#define LISTING_LHS_WIDTH_SECOND LISTING_LHS_WIDTH
#endif
#ifndef LISTING_RHS_WIDTH
#define LISTING_RHS_WIDTH 100
#endif
#ifndef LISTING_LHS_CONT_LINES
#define LISTING_LHS_CONT_LINES 4
#endif

/* This structure remembers which .s were used.  */
typedef struct file_info_struct
{
  struct file_info_struct * next;
  char *                    filename;
  long                      pos;
  unsigned int              linenum;
  int                       at_end;
} file_info_type;

/* This structure remembers which line from which file goes into which
   frag.  */
struct list_info_struct
{
  /* Frag which this line of source is nearest to.  */
  fragS *frag;

  /* The actual line in the source file.  */
  unsigned int line;

  /* Pointer to the file info struct for the file which this line
     belongs to.  */
  file_info_type *file;

  /* The expanded text of any macro that may have been executing.  */
  char *line_contents;

  /* Next in list.  */
  struct list_info_struct *next;

  /* Pointer to the file info struct for the high level language
     source line that belongs here.  */
  file_info_type *hll_file;

  /* High level language source line.  */
  unsigned int hll_line;

  /* Pointer to any error message associated with this line.  */
  char *message;

  enum
    {
      EDICT_NONE,
      EDICT_SBTTL,
      EDICT_TITLE,
      EDICT_NOLIST,
      EDICT_LIST,
      EDICT_NOLIST_NEXT,
      EDICT_EJECT
    } edict;
  char *edict_arg;

  /* Nonzero if this line is to be omitted because it contains
     debugging information.  This can become a flags field if we come
     up with more information to store here.  */
  int debugging;
};

typedef struct list_info_struct list_info_type;

int listing_lhs_width        = LISTING_LHS_WIDTH;
int listing_lhs_width_second = LISTING_LHS_WIDTH_SECOND;
int listing_lhs_cont_lines   = LISTING_LHS_CONT_LINES;
int listing_rhs_width        = LISTING_RHS_WIDTH;

struct list_info_struct *        listing_tail;

static file_info_type *          file_info_head;
static file_info_type *          last_open_file_info;
static FILE *                    last_open_file;
static struct list_info_struct * head;
static int                       paper_width = 200;
static int                       paper_height = 60;

extern int                       listing;

/* File to output listings to.  */
static FILE *list_file;

/* This static array is used to keep the text of data to be printed
   before the start of the line.  */

#define MAX_BYTES							\
  (((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width			\
   + ((((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width_second)	\
      * listing_lhs_cont_lines)						\
   + 20)

static char *data_buffer;

/* Prototypes.  */
static void listing_message (const char *, const char *);
static file_info_type *file_info (const char *);
static void new_frag (void);
static char *buffer_line (file_info_type *, char *, unsigned int);
static void listing_page (list_info_type *);
static unsigned int calc_hex (list_info_type *);
static void print_lines (list_info_type *, unsigned int, char *, unsigned int);
static void list_symbol_table (void);
static void print_source (file_info_type *, list_info_type *, char *, unsigned int);
static int debugging_pseudo (list_info_type *, const char *);
static void listing_listing (char *);

static void
listing_message (const char *name, const char *message)
{
  if (listing_tail != (list_info_type *) NULL)
    {
      unsigned int l = strlen (name) + strlen (message) + 1;
      char *n = (char *) xmalloc (l);
      strcpy (n, name);
      strcat (n, message);
      listing_tail->message = n;
    }
}

void
listing_warning (const char *message)
{
  listing_message (_("Warning:"), message);
}

void
listing_error (const char *message)
{
  listing_message (_("Error:"), message);
}

static file_info_type *
file_info (const char *file_name)
{
  /* Find an entry with this file name.  */
  file_info_type *p = file_info_head;

  while (p != (file_info_type *) NULL)
    {
      if (strcmp (p->filename, file_name) == 0)
	return p;
      p = p->next;
    }

  /* Make new entry.  */
  p = xmalloc (sizeof (file_info_type));
  p->next = file_info_head;
  file_info_head = p;
  p->filename = xstrdup (file_name);
  p->pos = 0;
  p->linenum = 0;
  p->at_end = 0;

  return p;
}

static void
new_frag (void)
{
  frag_wane (frag_now);
  frag_new (0);
}

void
listing_newline (char *ps)
{
  char *file;
  unsigned int line;
  static unsigned int last_line = 0xffff;
  static char *last_file = NULL;
  list_info_type *new = NULL;

  if (listing == 0)
    return;

  if (now_seg == absolute_section)
    return;

#ifdef OBJ_ELF
  /* In ELF, anything in a section beginning with .debug or .line is
     considered to be debugging information.  This includes the
     statement which switches us into the debugging section, which we
     can only set after we are already in the debugging section.  */
  if ((listing & LISTING_NODEBUG) != 0
      && listing_tail != NULL
      && ! listing_tail->debugging)
    {
      const char *segname;

      segname = segment_name (now_seg);
      if (strncmp (segname, ".debug", sizeof ".debug" - 1) == 0
	  || strncmp (segname, ".line", sizeof ".line" - 1) == 0)
	listing_tail->debugging = 1;
    }
#endif

  as_where (&file, &line);
  if (ps == NULL)
    {
      if (line == last_line
	  && !(last_file && file && strcmp (file, last_file)))
	return;

      new = (list_info_type *) xmalloc (sizeof (list_info_type));

      /* Detect if we are reading from stdin by examining the file
	 name returned by as_where().

	 [FIXME: We rely upon the name in the strcmp below being the
	 same as the one used by input_scrub_new_file(), if that is
	 not true, then this code will fail].

	 If we are reading from stdin, then we need to save each input
	 line here (assuming of course that we actually have a line of
	 input to read), so that it can be displayed in the listing
	 that is produced at the end of the assembly.  */
      if (strcmp (file, _("{standard input}")) == 0
	  && input_line_pointer != NULL)
	{
	  char *copy;
	  int len;
	  int seen_quote = 0;

	  for (copy = input_line_pointer - 1;
	       *copy && (seen_quote
			 || (! is_end_of_line [(unsigned char) *copy]));
	       copy++)
	    if (*copy == '"' && copy[-1] != '\\')
	      seen_quote = ! seen_quote;

	  len = (copy - input_line_pointer) + 2;

	  copy = xmalloc (len);

	  if (copy != NULL)
	    {
	      char *src = input_line_pointer - 1;
	      char *dest = copy;

	      while (--len)
		{
		  unsigned char c = *src++;

		  /* Omit control characters in the listing.  */
		  if (!ISCNTRL (c))
		    *dest++ = c;
		}

	      *dest = 0;
	    }

	  new->line_contents = copy;
	}
      else
	new->line_contents = NULL;
    }
  else
    {
      new = xmalloc (sizeof (list_info_type));
      new->line_contents = ps;
    }

  last_line = line;
  last_file = file;

  new_frag ();

  if (listing_tail)
    listing_tail->next = new;
  else
    head = new;

  listing_tail = new;

  new->frag = frag_now;
  new->line = line;
  new->file = file_info (file);
  new->next = (list_info_type *) NULL;
  new->message = (char *) NULL;
  new->edict = EDICT_NONE;
  new->hll_file = (file_info_type *) NULL;
  new->hll_line = 0;
  new->debugging = 0;

  new_frag ();

#ifdef OBJ_ELF
  /* In ELF, anything in a section beginning with .debug or .line is
     considered to be debugging information.  */
  if ((listing & LISTING_NODEBUG) != 0)
    {
      const char *segname;

      segname = segment_name (now_seg);
      if (strncmp (segname, ".debug", sizeof ".debug" - 1) == 0
	  || strncmp (segname, ".line", sizeof ".line" - 1) == 0)
	new->debugging = 1;
    }
#endif
}

/* Attach all current frags to the previous line instead of the
   current line.  This is called by the MIPS backend when it discovers
   that it needs to add some NOP instructions; the added NOP
   instructions should go with the instruction that has the delay, not
   with the new instruction.  */

void
listing_prev_line (void)
{
  list_info_type *l;
  fragS *f;

  if (head == (list_info_type *) NULL
      || head == listing_tail)
    return;

  new_frag ();

  for (l = head; l->next != listing_tail; l = l->next)
    ;

  for (f = frchain_now->frch_root; f != (fragS *) NULL; f = f->fr_next)
    if (f->line == listing_tail)
      f->line = l;

  listing_tail->frag = frag_now;
  new_frag ();
}

/* This function returns the next source line from the file supplied,
   truncated to size.  It appends a fake line to the end of each input
   file to make.  */

static char *
buffer_line (file_info_type *file, char *line, unsigned int size)
{
  unsigned int count = 0;
  int c;

  char *p = line;

  /* If we couldn't open the file, return an empty line.  */
  if (file->at_end)
    return "";

  /* Check the cache and see if we last used this file.  */
  if (!last_open_file_info || file != last_open_file_info)
    {
      if (last_open_file)
	{
	  last_open_file_info->pos = ftell (last_open_file);
	  fclose (last_open_file);
	}

      last_open_file_info = file;
      last_open_file = fopen (file->filename, FOPEN_RT);
      if (last_open_file == NULL)
	{
	  file->at_end = 1;
	  return "";
	}

      /* Seek to where we were last time this file was open.  */
      if (file->pos)
	fseek (last_open_file, file->pos, SEEK_SET);
    }

  c = fgetc (last_open_file);

  /* Leave room for null.  */
  size -= 1;

  while (c != EOF && c != '\n')
    {
      if (count < size)
	*p++ = c;
      count++;

      c = fgetc (last_open_file);

    }
  if (c == EOF)
    {
      file->at_end = 1;
      if (count + 2 < size)
	{
	  *p++ = '.';
	  *p++ = '.';
	  *p++ = '.';
	}
    }
  file->linenum++;
  *p++ = 0;
  return line;
}

static const char *fn;

static unsigned int eject;	/* Eject pending */
static unsigned int page;	/* Current page number */
static char *title;		/* Current title */
static char *subtitle;		/* Current subtitle */
static unsigned int on_page;	/* Number of lines printed on current page */

static void
listing_page (list_info_type *list)
{
  /* Grope around, see if we can see a title or subtitle edict coming up
     soon.  (we look down 10 lines of the page and see if it's there)  */
  if ((eject || (on_page >= (unsigned int) paper_height))
      && paper_height != 0)
    {
      unsigned int c = 10;
      int had_title = 0;
      int had_subtitle = 0;

      page++;

      while (c != 0 && list)
	{
	  if (list->edict == EDICT_SBTTL && !had_subtitle)
	    {
	      had_subtitle = 1;
	      subtitle = list->edict_arg;
	    }
	  if (list->edict == EDICT_TITLE && !had_title)
	    {
	      had_title = 1;
	      title = list->edict_arg;
	    }
	  list = list->next;
	  c--;
	}

      if (page > 1)
	{
	  fprintf (list_file, "\f");
	}

      fprintf (list_file, "%s %s \t\t\tpage %d\n", LISTING_HEADER, fn, page);
      fprintf (list_file, "%s\n", title);
      fprintf (list_file, "%s\n", subtitle);
      on_page = 3;
      eject = 0;
    }
}

static unsigned int
calc_hex (list_info_type *list)
{
  int data_buffer_size;
  list_info_type *first = list;
  unsigned int address = ~(unsigned int) 0;
  fragS *frag;
  fragS *frag_ptr;
  unsigned int octet_in_frag;

  /* Find first frag which says it belongs to this line.  */
  frag = list->frag;
  while (frag && frag->line != list)
    frag = frag->fr_next;

  frag_ptr = frag;

  data_buffer_size = 0;

  /* Dump all the frags which belong to this line.  */
  while (frag_ptr != (fragS *) NULL && frag_ptr->line == first)
    {
      /* Print as many bytes from the fixed part as is sensible.  */
      octet_in_frag = 0;
      while ((offsetT) octet_in_frag < frag_ptr->fr_fix
	     && data_buffer_size < MAX_BYTES - 3)
	{
	  if (address == ~(unsigned int) 0)
	    address = frag_ptr->fr_address / OCTETS_PER_BYTE;

	  sprintf (data_buffer + data_buffer_size,
		   "%02X",
		   (frag_ptr->fr_literal[octet_in_frag]) & 0xff);
	  data_buffer_size += 2;
	  octet_in_frag++;
	}
      if (frag_ptr->fr_type == rs_fill)
	{
	  unsigned int var_rep_max = octet_in_frag;
	  unsigned int var_rep_idx = octet_in_frag;

	  /* Print as many bytes from the variable part as is sensible.  */
	  while (((offsetT) octet_in_frag
		  < (frag_ptr->fr_fix + frag_ptr->fr_var * frag_ptr->fr_offset))
		 && data_buffer_size < MAX_BYTES - 3)
	    {
	      if (address == ~(unsigned int) 0)
		address = frag_ptr->fr_address / OCTETS_PER_BYTE;

	      sprintf (data_buffer + data_buffer_size,
		       "%02X",
		       (frag_ptr->fr_literal[var_rep_idx]) & 0xff);
#if 0
	      data_buffer[data_buffer_size++] = '*';
	      data_buffer[data_buffer_size++] = '*';
#endif
	      data_buffer_size += 2;

	      var_rep_idx++;
	      octet_in_frag++;

	      if ((offsetT) var_rep_idx >= frag_ptr->fr_fix + frag_ptr->fr_var)
		var_rep_idx = var_rep_max;
	    }
	}

      frag_ptr = frag_ptr->fr_next;
    }
  data_buffer[data_buffer_size] = '\0';
  return address;
}

static void
print_lines (list_info_type *list, unsigned int lineno,
	     char *string, unsigned int address)
{
  unsigned int idx;
  unsigned int nchars;
  unsigned int lines;
  unsigned int octet_in_word = 0;
  char *src = data_buffer;
  int cur;

  /* Print the stuff on the first line.  */
  listing_page (list);
  nchars = (LISTING_WORD_SIZE * 2 + 1) * listing_lhs_width;

  /* Print the hex for the first line.  */
  if (address == ~(unsigned int) 0)
    {
      fprintf (list_file, "% 4d     ", lineno);
      for (idx = 0; idx < nchars; idx++)
	fprintf (list_file, " ");

      fprintf (list_file, "\t%s\n", string ? string : "");

      on_page++;

      listing_page (0);

      return;
    }

  if (had_errors ())
    fprintf (list_file, "% 4d ???? ", lineno);
  else
    fprintf (list_file, "% 4d %04x ", lineno, address);

  /* And the data to go along with it.  */
  idx = 0;
  cur = 0;
  while (src[cur] && idx < nchars)
    {
      int offset;
      offset = cur;
      fprintf (list_file, "%c%c", src[offset], src[offset + 1]);
      cur += 2;
      octet_in_word++;

      if (octet_in_word == LISTING_WORD_SIZE)
	{
	  fprintf (list_file, " ");
	  idx++;
	  octet_in_word = 0;
	}

      idx += 2;
    }

  for (; idx < nchars; idx++)
    fprintf (list_file, " ");

  fprintf (list_file, "\t%s\n", string ? string : "");
  on_page++;
  listing_page (list);

  if (list->message)
    {
      fprintf (list_file, "****  %s\n", list->message);
      listing_page (list);
      on_page++;
    }

  for (lines = 0;
       lines < (unsigned int) listing_lhs_cont_lines
	 && src[cur];
       lines++)
    {
      nchars = ((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width_second - 1;
      idx = 0;

      /* Print any more lines of data, but more compactly.  */
      fprintf (list_file, "% 4d      ", lineno);

      while (src[cur] && idx < nchars)
	{
	  int offset;
	  offset = cur;
	  fprintf (list_file, "%c%c", src[offset], src[offset + 1]);
	  cur += 2;
	  idx += 2;
	  octet_in_word++;

	  if (octet_in_word == LISTING_WORD_SIZE)
	    {
	      fprintf (list_file, " ");
	      idx++;
	      octet_in_word = 0;
	    }
	}

      fprintf (list_file, "\n");
      on_page++;
      listing_page (list);
    }
}

static void
list_symbol_table (void)
{
  extern symbolS *symbol_rootP;
  int got_some = 0;

  symbolS *ptr;
  eject = 1;
  listing_page (0);

  for (ptr = symbol_rootP; ptr != (symbolS *) NULL; ptr = symbol_next (ptr))
    {
      if (SEG_NORMAL (S_GET_SEGMENT (ptr))
	  || S_GET_SEGMENT (ptr) == absolute_section)
	{
#ifdef BFD_ASSEMBLER
	  /* Don't report section symbols.  They are not interesting.  */
	  if (symbol_section_p (ptr))
	    continue;
#endif
	  if (S_GET_NAME (ptr))
	    {
	      char buf[30], fmt[8];
	      valueT val = S_GET_VALUE (ptr);

	      /* @@@@ Note that this is dependent on the compilation options,
		 not solely on the target characteristics.  */
	      if (sizeof (val) == 4 && sizeof (int) == 4)
		sprintf (buf, "%08lx", (unsigned long) val);
	      else if (sizeof (val) <= sizeof (unsigned long))
		{
		  sprintf (fmt, "%%0%lulx",
			   (unsigned long) (sizeof (val) * 2));
		  sprintf (buf, fmt, (unsigned long) val);
		}
#if defined (BFD64)
	      else if (sizeof (val) > 4)
		sprintf_vma (buf, val);
#endif
	      else
		abort ();

	      if (!got_some)
		{
		  fprintf (list_file, "DEFINED SYMBOLS\n");
		  on_page++;
		  got_some = 1;
		}

	      if (symbol_get_frag (ptr) && symbol_get_frag (ptr)->line)
		{
		  fprintf (list_file, "%20s:%-5d  %s:%s %s\n",
			   symbol_get_frag (ptr)->line->file->filename,
			   symbol_get_frag (ptr)->line->line,
			   segment_name (S_GET_SEGMENT (ptr)),
			   buf, S_GET_NAME (ptr));
		}
	      else
		{
		  fprintf (list_file, "%33s:%s %s\n",
			   segment_name (S_GET_SEGMENT (ptr)),
			   buf, S_GET_NAME (ptr));
		}

	      on_page++;
	      listing_page (0);
	    }
	}

    }
  if (!got_some)
    {
      fprintf (list_file, "NO DEFINED SYMBOLS\n");
      on_page++;
    }
  fprintf (list_file, "\n");
  on_page++;
  listing_page (0);

  got_some = 0;

  for (ptr = symbol_rootP; ptr != (symbolS *) NULL; ptr = symbol_next (ptr))
    {
      if (S_GET_NAME (ptr) && strlen (S_GET_NAME (ptr)) != 0)
	{
	  if (S_GET_SEGMENT (ptr) == undefined_section)
	    {
	      if (!got_some)
		{
		  got_some = 1;
		  fprintf (list_file, "UNDEFINED SYMBOLS\n");
		  on_page++;
		  listing_page (0);
		}
	      fprintf (list_file, "%s\n", S_GET_NAME (ptr));
	      on_page++;
	      listing_page (0);
	    }
	}
    }
  if (!got_some)
    {
      fprintf (list_file, "NO UNDEFINED SYMBOLS\n");
      on_page++;
      listing_page (0);
    }
}

static void
print_source (file_info_type *current_file, list_info_type *list,
	      char *buffer, unsigned int width)
{
  if (!current_file->at_end)
    {
      while (current_file->linenum < list->hll_line
	     && !current_file->at_end)
	{
	  char *p = buffer_line (current_file, buffer, width);

	  fprintf (list_file, "%4u:%-13s **** %s\n", current_file->linenum,
		   current_file->filename, p);
	  on_page++;
	  listing_page (list);
	}
    }
}

/* Sometimes the user doesn't want to be bothered by the debugging
   records inserted by the compiler, see if the line is suspicious.  */

static int
debugging_pseudo (list_info_type *list, const char *line)
{
  static int in_debug;
  int was_debug;

  if (list->debugging)
    {
      in_debug = 1;
      return 1;
    }

  was_debug = in_debug;
  in_debug = 0;

  while (ISSPACE (*line))
    line++;

  if (*line != '.')
    {
#ifdef OBJ_ELF
      /* The ELF compiler sometimes emits blank lines after switching
         out of a debugging section.  If the next line drops us back
         into debugging information, then don't print the blank line.
         This is a hack for a particular compiler behaviour, not a
         general case.  */
      if (was_debug
	  && *line == '\0'
	  && list->next != NULL
	  && list->next->debugging)
	{
	  in_debug = 1;
	  return 1;
	}
#endif

      return 0;
    }

  line++;

  if (strncmp (line, "def", 3) == 0)
    return 1;
  if (strncmp (line, "val", 3) == 0)
    return 1;
  if (strncmp (line, "scl", 3) == 0)
    return 1;
  if (strncmp (line, "line", 4) == 0)
    return 1;
  if (strncmp (line, "endef", 5) == 0)
    return 1;
  if (strncmp (line, "ln", 2) == 0)
    return 1;
  if (strncmp (line, "type", 4) == 0)
    return 1;
  if (strncmp (line, "size", 4) == 0)
    return 1;
  if (strncmp (line, "dim", 3) == 0)
    return 1;
  if (strncmp (line, "tag", 3) == 0)
    return 1;
  if (strncmp (line, "stabs", 5) == 0)
    return 1;
  if (strncmp (line, "stabn", 5) == 0)
    return 1;

  return 0;
}

static void
listing_listing (char *name ATTRIBUTE_UNUSED)
{
  list_info_type *list = head;
  file_info_type *current_hll_file = (file_info_type *) NULL;
  char *message;
  char *buffer;
  char *p;
  int show_listing = 1;
  unsigned int width;

  buffer = xmalloc (listing_rhs_width);
  data_buffer = xmalloc (MAX_BYTES);
  eject = 1;
  list = head;

  while (list != (list_info_type *) NULL && 0)
    {
      if (list->next)
	list->frag = list->next->frag;
      list = list->next;
    }

  list = head->next;

  while (list)
    {
      unsigned int list_line;

      width = listing_rhs_width > paper_width ? paper_width :
	listing_rhs_width;

      list_line = list->line;
      switch (list->edict)
	{
	case EDICT_LIST:
	  /* Skip all lines up to the current.  */
	  list_line--;
	  break;
	case EDICT_NOLIST:
	  show_listing--;
	  break;
	case EDICT_NOLIST_NEXT:
	  if (show_listing == 0)
	    list_line--;
	  break;
	case EDICT_EJECT:
	  break;
	case EDICT_NONE:
	  break;
	case EDICT_TITLE:
	  title = list->edict_arg;
	  break;
	case EDICT_SBTTL:
	  subtitle = list->edict_arg;
	  break;
	default:
	  abort ();
	}

      if (show_listing <= 0)
	{
	  while (list->file->linenum < list_line
		 && !list->file->at_end)
	    p = buffer_line (list->file, buffer, width);
	}

      if (list->edict == EDICT_LIST
	  || (list->edict == EDICT_NOLIST_NEXT && show_listing == 0))
	{
	  /* Enable listing for the single line that caused the enable.  */
	  list_line++;
	  show_listing++;
	}

      if (show_listing > 0)
	{
	  /* Scan down the list and print all the stuff which can be done
	     with this line (or lines).  */
	  message = 0;

	  if (list->hll_file)
	    current_hll_file = list->hll_file;

	  if (current_hll_file && list->hll_line && (listing & LISTING_HLL))
	    print_source (current_hll_file, list, buffer, width);

	  if (list->line_contents)
	    {
	      if (!((listing & LISTING_NODEBUG)
		    && debugging_pseudo (list, list->line_contents)))
		print_lines (list,
			     list->file->linenum == 0 ? list->line : list->file->linenum,
			     list->line_contents, calc_hex (list));

	      free (list->line_contents);
	      list->line_contents = NULL;
	    }
	  else
	    {
	      while (list->file->linenum < list_line
		     && !list->file->at_end)
		{
		  unsigned int address;

		  p = buffer_line (list->file, buffer, width);

		  if (list->file->linenum < list_line)
		    address = ~(unsigned int) 0;
		  else
		    address = calc_hex (list);

		  if (!((listing & LISTING_NODEBUG)
			&& debugging_pseudo (list, p)))
		    print_lines (list, list->file->linenum, p, address);
		}
	    }

	  if (list->edict == EDICT_EJECT)
	    eject = 1;
	}

      if (list->edict == EDICT_NOLIST_NEXT && show_listing == 1)
	--show_listing;

      list = list->next;
    }

  free (buffer);
  free (data_buffer);
  data_buffer = NULL;
}

void
listing_print (char *name)
{
  int using_stdout;

  title = "";
  subtitle = "";

  if (name == NULL)
    {
      list_file = stdout;
      using_stdout = 1;
    }
  else
    {
      list_file = fopen (name, FOPEN_WT);
      if (list_file != NULL)
	using_stdout = 0;
      else
	{
#ifdef BFD_ASSEMBLER
      bfd_set_error (bfd_error_system_call);
#endif
	  as_perror (_("can't open list file: %s"), name);
	  list_file = stdout;
	  using_stdout = 1;
	}
    }

  if (listing & LISTING_NOFORM)
    paper_height = 0;

  if (listing & LISTING_LISTING)
    listing_listing (name);

  if (listing & LISTING_SYMBOLS)
    list_symbol_table ();

  if (! using_stdout)
    {
      if (fclose (list_file) == EOF)
	{
#ifdef BFD_ASSEMBLER
	  bfd_set_error (bfd_error_system_call);
#endif
	  as_perror (_("error closing list file: %s"), name);
	}
    }

  if (last_open_file)
    fclose (last_open_file);
}

void
listing_file (const char *name)
{
  fn = name;
}

void
listing_eject (int ignore ATTRIBUTE_UNUSED)
{
  if (listing)
    listing_tail->edict = EDICT_EJECT;
}

void
listing_flags (int ignore ATTRIBUTE_UNUSED)
{
  while ((*input_line_pointer++) && (*input_line_pointer != '\n'))
    input_line_pointer++;

}

/* Turn listing on or off.  An argument of 0 means to turn off
   listing.  An argument of 1 means to turn on listing.  An argument
   of 2 means to turn off listing, but as of the next line; that is,
   the current line should be listed, but the next line should not.  */

void
listing_list (int on)
{
  if (listing)
    {
      switch (on)
	{
	case 0:
	  if (listing_tail->edict == EDICT_LIST)
	    listing_tail->edict = EDICT_NONE;
	  else
	    listing_tail->edict = EDICT_NOLIST;
	  break;
	case 1:
	  if (listing_tail->edict == EDICT_NOLIST
	      || listing_tail->edict == EDICT_NOLIST_NEXT)
	    listing_tail->edict = EDICT_NONE;
	  else
	    listing_tail->edict = EDICT_LIST;
	  break;
	case 2:
	  listing_tail->edict = EDICT_NOLIST_NEXT;
	  break;
	default:
	  abort ();
	}
    }
}

void
listing_psize (int width_only)
{
  if (! width_only)
    {
      paper_height = get_absolute_expression ();

      if (paper_height < 0 || paper_height > 1000)
	{
	  paper_height = 0;
	  as_warn (_("strange paper height, set to no form"));
	}

      if (*input_line_pointer != ',')
	{
	  demand_empty_rest_of_line ();
	  return;
	}

      ++input_line_pointer;
    }

  paper_width = get_absolute_expression ();

  demand_empty_rest_of_line ();
}

void
listing_nopage (int ignore ATTRIBUTE_UNUSED)
{
  paper_height = 0;
}

void
listing_title (int depth)
{
  int quoted;
  char *start;
  char *ttl;
  unsigned int length;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != '\"')
    quoted = 0;
  else
    {
      quoted = 1;
      ++input_line_pointer;
    }

  start = input_line_pointer;

  while (*input_line_pointer)
    {
      if (quoted
	  ? *input_line_pointer == '\"'
	  : is_end_of_line[(unsigned char) *input_line_pointer])
	{
	  if (listing)
	    {
	      length = input_line_pointer - start;
	      ttl = xmalloc (length + 1);
	      memcpy (ttl, start, length);
	      ttl[length] = 0;
	      listing_tail->edict = depth ? EDICT_SBTTL : EDICT_TITLE;
	      listing_tail->edict_arg = ttl;
	    }
	  if (quoted)
	    input_line_pointer++;
	  demand_empty_rest_of_line ();
	  return;
	}
      else if (*input_line_pointer == '\n')
	{
	  as_bad (_("new line in title"));
	  demand_empty_rest_of_line ();
	  return;
	}
      else
	{
	  input_line_pointer++;
	}
    }
}

void
listing_source_line (unsigned int line)
{
  if (listing)
    {
      new_frag ();
      listing_tail->hll_line = line;
      new_frag ();
    }
}

void
listing_source_file (const char *file)
{
  if (listing)
    listing_tail->hll_file = file_info (file);
}

#else

/* Dummy functions for when compiled without listing enabled.  */

void
listing_flags (int ignore)
{
  s_ignore (0);
}

void
listing_list (int on)
{
  s_ignore (0);
}

void
listing_eject (int ignore)
{
  s_ignore (0);
}

void
listing_psize (int ignore)
{
  s_ignore (0);
}

void
listing_nopage (int ignore)
{
  s_ignore (0);
}

void
listing_title (int depth)
{
  s_ignore (0);
}

void
listing_file (const char *name)
{
}

void
listing_newline (char *name)
{
}

void
listing_source_line (unsigned int n)
{
}

void
listing_source_file (const char *n)
{
}

#endif
@


1.6
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d1 1
a1 1
/* listing.c - mainting assembly listings
d3 1
a3 1
   2001, 2002
d6 1
a6 1
This file is part of GAS, the GNU Assembler.
d8 14
a21 14
GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d23 1
a23 2
/*
 Contributed by Steve Chamberlain <sac@@cygnus.com>
d67 1
a67 1
 function also rememebers when the filename changes.
d88 1
a88 1
 LISTING_LHS_CONT_LINES	Max number of lines to use up for a continutation
d90 1
a90 2
                        on a line
*/
d120 2
a121 1
typedef struct file_info_struct {
d129 1
a129 1
/* This structure rememebrs which line from which file goes into which
d131 2
a132 1
struct list_info_struct {
d138 1
d152 1
d159 10
a168 9
  enum {
    EDICT_NONE,
    EDICT_SBTTL,
    EDICT_TITLE,
    EDICT_NOLIST,
    EDICT_LIST,
    EDICT_NOLIST_NEXT,
    EDICT_EJECT
  } edict;
d210 11
a220 16
static void listing_message PARAMS ((const char *name, const char *message));
static file_info_type *file_info PARAMS ((const char *file_name));
static void new_frag PARAMS ((void));
static char *buffer_line PARAMS ((file_info_type *file,
				  char *line, unsigned int size));
static void listing_page PARAMS ((list_info_type *list));
static unsigned int calc_hex PARAMS ((list_info_type *list));
static void print_lines PARAMS ((list_info_type *, unsigned int,
				 char *, unsigned int));
static void list_symbol_table PARAMS ((void));
static void print_source PARAMS ((file_info_type *current_file,
				  list_info_type *list,
				  char *buffer,
				  unsigned int width));
static int debugging_pseudo PARAMS ((list_info_type *, const char *));
static void listing_listing PARAMS ((char *name));
d223 1
a223 3
listing_message (name, message)
     const char *name;
     const char *message;
d236 1
a236 2
listing_warning (message)
     const char *message;
d242 1
a242 2
listing_error (message)
     const char *message;
d248 1
a248 2
file_info (file_name)
     const char *file_name;
d261 1
a261 2

  p = (file_info_type *) xmalloc (sizeof (file_info_type));
d273 1
a273 1
new_frag ()
a274 1

a276 1

d280 1
a280 2
listing_newline (ps)
     char *ps;
d374 1
a374 1
      new = (list_info_type *) xmalloc (sizeof (list_info_type));
d424 1
a424 1
listing_prev_line ()
d451 1
a451 4
buffer_line (file, line, size)
     file_info_type *file;
     char *line;
     unsigned int size;
d522 1
a522 2
listing_page (list)
     list_info_type *list;
d565 1
a565 2
calc_hex (list)
     list_info_type *list;
d592 1
a592 3
	    {
	      address = frag_ptr->fr_address / OCTETS_PER_BYTE;
	    }
d611 2
a612 3
		{
		  address = frag_ptr->fr_address / OCTETS_PER_BYTE;
		}
d637 2
a638 5
print_lines (list, lineno, string, address)
     list_info_type *list;
     unsigned int lineno;
     char *string;
     unsigned int address;
d742 1
a742 1
list_symbol_table ()
d850 2
a851 5
print_source (current_file, list, buffer, width)
     file_info_type *current_file;
     list_info_type *list;
     char *buffer;
     unsigned int width;
d859 1
d872 1
a872 3
debugging_pseudo (list, line)
     list_info_type *list;
     const char *line;
a931 1

d941 1
a941 2
listing_listing (name)
     char *name ATTRIBUTE_UNUSED;
a960 1

d1022 1
a1022 3
	    {
	      current_hll_file = list->hll_file;
	    }
d1025 1
a1025 3
	    {
	      print_source (current_hll_file, list, buffer, width);
	    }
d1031 4
a1034 5
		{
		  print_lines (list,
			       list->file->linenum == 0 ? list->line : list->file->linenum,
			       list->line_contents, calc_hex (list));
		}
d1059 1
a1059 3
	    {
	      eject = 1;
	    }
d1074 1
a1074 2
listing_print (name)
     char *name;
d1093 3
d1103 1
a1103 3
    {
      paper_height = 0;
    }
d1106 1
a1106 3
    {
      listing_listing (name);
    }
d1109 1
a1109 3
    {
      list_symbol_table ();
    }
d1114 6
a1119 1
	as_perror (_("error closing list file: %s"), name);
d1123 1
a1123 3
    {
      fclose (last_open_file);
    }
d1127 1
a1127 2
listing_file (name)
     const char *name;
d1133 1
a1133 2
listing_eject (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1140 1
a1140 2
listing_flags (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1153 1
a1153 2
listing_list (on)
     int on;
d1182 1
a1182 2
listing_psize (width_only)
     int width_only;
d1209 1
a1209 2
listing_nopage (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1215 1
a1215 2
listing_title (depth)
     int depth;
d1267 1
a1267 2
listing_source_line (line)
     unsigned int line;
d1278 1
a1278 2
listing_source_file (file)
     const char *file;
d1289 1
a1289 2
listing_flags (ignore)
     int ignore;
d1295 1
a1295 2
listing_list (on)
     int on;
d1301 1
a1301 2
listing_eject (ignore)
     int ignore;
d1307 1
a1307 2
listing_psize (ignore)
     int ignore;
d1313 1
a1313 2
listing_nopage (ignore)
     int ignore;
d1319 1
a1319 2
listing_title (depth)
     int depth;
d1325 1
a1325 2
listing_file (name)
     const char *name;
a1326 1

d1330 1
a1330 2
listing_newline (name)
     char *name;
a1331 1

d1335 1
a1335 2
listing_source_line (n)
     unsigned int n;
a1336 1

d1340 1
a1340 2
listing_source_file (n)
     const char *n;
a1341 1

@


1.5
log
@resolve conflicts.
@
text
@d3 1
a3 1
   2001
a93 2
#include <ctype.h>

d95 2
a96 1
#include <obstack.h>
d272 1
a272 2
  p->filename = xmalloc ((unsigned long) strlen (file_name) + 1);
  strcpy (p->filename, file_name);
d371 1
a371 1
		  if (isascii (c) && ! iscntrl (c))
d486 1
a486 1
      last_open_file = fopen (file->filename, "r");
d515 6
a520 3
      *p++ = '.';
      *p++ = '.';
      *p++ = '.';
d618 17
a634 17
    if (frag_ptr->fr_type == rs_fill)
      {
	unsigned int var_rep_max = octet_in_frag;
	unsigned int var_rep_idx = octet_in_frag;

	/* Print as many bytes from the variable part as is sensible.  */
	while (((offsetT) octet_in_frag
		< (frag_ptr->fr_fix + frag_ptr->fr_var * frag_ptr->fr_offset))
	       && data_buffer_size < MAX_BYTES - 3)
	  {
	    if (address == ~(unsigned int) 0)
	      {
		address = frag_ptr->fr_address / OCTETS_PER_BYTE;
	      }
	    sprintf (data_buffer + data_buffer_size,
		     "%02X",
		     (frag_ptr->fr_literal[var_rep_idx]) & 0xff);
d636 2
a637 2
	    data_buffer[data_buffer_size++] = '*';
	    data_buffer[data_buffer_size++] = '*';
d639 1
a639 1
	    data_buffer_size += 2;
d641 2
a642 2
	    var_rep_idx++;
	    octet_in_frag++;
d644 4
a647 4
	    if ((offsetT) var_rep_idx >= frag_ptr->fr_fix + frag_ptr->fr_var)
	      var_rep_idx = var_rep_max;
	  }
      }
d912 1
a912 1
  while (isspace ((unsigned char) *line))
d1065 1
a1065 1
 		  print_lines (list,
d1125 1
a1125 1
      list_file = fopen (name, "w");
d1299 1
a1299 1
	  as_bad (_("New line in title"));
@


1.4
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
d21 1
a21 1
02111-1307, USA. */
d24 1
a24 3
 Contributed by Steve Chamberlain
 		sac@@cygnus.com

a58 1

d122 2
a123 3
/* This structure remembers which .s were used */
typedef struct file_info_struct
{
d129 1
a129 2
}
file_info_type;
d132 4
a135 5
   frag */
struct list_info_struct
{
  /* Frag which this line of source is nearest to */
  fragS * frag;
d137 1
a137 1
  /* The actual line in the source file */
d140 2
a141 2
     belongs to */
  file_info_type * file;
d144 1
a144 1
  char * line_contents;
d146 2
a147 2
  /* Next in list */
  struct list_info_struct * next;
d150 3
a152 3
     source line that belongs here */
  file_info_type * hll_file;
  /* High level language source line */
d155 2
a156 2
  /* Pointer to any error message associated with this line */
  char * message;
d158 10
a167 11
  enum
    {
      EDICT_NONE,
      EDICT_SBTTL,
      EDICT_TITLE,
      EDICT_NOLIST,
      EDICT_LIST,
      EDICT_NOLIST_NEXT,
      EDICT_EJECT
    } edict;
  char * edict_arg;
a176 1

d194 1
a194 1
static FILE * list_file;
d205 1
a205 1
static char * data_buffer;
d209 1
a209 1
static file_info_type * file_info PARAMS ((const char *file_name));
d211 1
a211 1
static char * buffer_line PARAMS ((file_info_type *file,
a224 1

a229 4
  unsigned int l = strlen (name) + strlen (message) + 1;
  char *n = (char *) xmalloc (l);
  strcpy (n, name);
  strcat (n, message);
d232 4
d258 1
a258 1
  /* Find an entry with this file name */
d268 1
a268 1
  /* Make new entry */
a281 1

d328 2
a329 1
      if (line == last_line && !(last_file && file && strcmp (file, last_file)))
d341 4
a344 4
	 If we are reading from stdin, then we need to save each input line
	 here (assuming of course that we actually have a line of input to read),
	 so that it can be displayed in the listing that is produced at the end
	 of the assembly.  */
d348 1
a348 1
	  char * copy;
d353 4
a356 4
	       * copy && (seen_quote
			  || (! is_end_of_line [(unsigned char) * copy]));
	       copy ++)
	    if (* copy == '"' && copy[-1] != '\\')
d365 3
a367 3
	      char * src = input_line_pointer - 1;
	      char * dest = copy;
	      
d370 1
a370 1
		  unsigned char c = * src ++;
d374 1
a374 1
		    * dest ++ = c;
d376 1
a376 1
	      
d379 1
a379 1
	  
d393 1
a393 1
  
d400 1
a400 1
  
d412 1
a412 1
  
d459 3
a461 5
/*
 This function returns the next source line from the file supplied,
 truncated to size.  It appends a fake line to the end of each input
 file to make
*/
d465 1
a465 1
     file_info_type * file;
d474 1
a474 1
  /* If we couldn't open the file, return an empty line */
d494 1
a494 1
      
d497 1
a497 1
	fseek(last_open_file, file->pos, SEEK_SET);
d502 2
a503 1
  size -= 1;			/* leave room for null */
a525 1

d530 3
a532 4
static char *title;		/* current title */
static char *subtitle;		/* current subtitle */
static unsigned int on_page;	/* number of lines printed on current page */

d539 3
a541 2
     soon  (we look down 10 lines of the page and see if it's there)*/
  if ((eject || (on_page >= (unsigned int) paper_height)) && paper_height != 0)
a564 1

a577 1

d580 1
a580 1
     list_info_type * list;
d584 1
a584 1
  unsigned int address = ~ (unsigned int) 0;
d589 1
a589 1
  /* Find first frag which says it belongs to this line */
d598 1
a598 1
  /* Dump all the frags which belong to this line */
d601 1
a601 1
      /* Print as many bytes from the fixed part as is sensible */
d606 1
a606 1
	  if (address == ~ (unsigned int) 0)
d617 1
d622 1
a622 1
	/* Print as many bytes from the variable part as is sensible */
d627 1
a627 1
	    if (address == ~ (unsigned int) 0)
a653 5





d668 1
a668 1
  /* Print the stuff on the first line */
d671 3
a673 3
  
  /* Print the hex for the first line */
  if (address == ~ (unsigned int) 0)
d680 3
a682 3
      
      on_page ++;
      
d693 1
a693 1
  /* And the data to go along with it */
d700 1
a700 1
      fprintf (list_file, "%c%c", src[offset], src[offset+1]);
d703 1
a703 1
      
d710 1
a710 1
      
d713 1
a713 1
  
d716 1
a716 1
  
d720 1
a720 1
  
d727 1
a727 1
  
d731 1
a731 1
       lines ++)
d733 1
a733 2
      nchars = ((LISTING_WORD_SIZE * 2) + 1)
	* listing_lhs_width_second - 1;
d735 2
a736 2
      
      /* Print any more lines of data, but more compactly */
d738 1
a738 1
      
d741 3
a743 3
          int offset;
          offset = cur;
          fprintf (list_file, "%c%c", src[offset], src[offset+1]);
d747 1
a747 1
	  
d755 1
a755 1
      
d757 1
a757 1
      on_page ++;
a761 1

d826 1
a826 1
	      on_page ++;
a992 1

d1011 2
d1035 2
a1036 1
      if (list->edict == EDICT_LIST)
d1081 1
a1081 1
		    address = ~ (unsigned int) 0;
d1097 1
a1097 1
      if (list->edict == EDICT_NOLIST_NEXT)
d1113 1
a1113 1
  
a1161 1

a1220 1

a1308 2


a1328 2


d1331 1
a1331 2

/* Dummy functions for when compiled without listing enabled */
d1340 1
a1340 1
void 
d1347 1
a1347 1
void 
d1354 1
a1354 1
void 
d1368 1
a1368 1
void 
d1382 1
a1382 1
void 
d1389 1
a1389 1
void 
d1395 2
a1396 1
void 
@


1.3
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1991, 1992 Free Software Foundation, Inc.
d18 3
a20 2
along with GAS; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d104 1
d112 1
a112 1
#define LISTING_LHS_WIDTH 1
d115 1
a115 1
#define LISTING_LHS_WIDTH_SECOND 1
a123 3



d127 5
a131 5
  char *filename;
  int linenum;
  FILE *file;
  struct file_info_struct *next;
  int at_end;
a132 1

d135 1
a135 2

/* this structure rememebrs which line from which file goes into which
d137 1
a137 1
typedef struct list_info_struct
d140 2
a141 1
  fragS *frag;
d146 4
a149 1
  file_info_type *file;
d152 1
a152 2
  struct list_info_struct *next;

d156 1
a156 2
  file_info_type *hll_file;

d158 1
a158 2
  int hll_line;

d161 1
a161 1
  char *message;
d170 1
d173 9
a181 1
  char *edict_arg;
a182 1
}
d184 4
a187 1
list_info_type;
d189 1
d191 6
a196 3
static struct list_info_struct *head;
struct list_info_struct *listing_tail;
extern int listing;
d198 1
a198 2
static int paper_width = 200;
static int paper_height = 60;
d201 1
a201 1
static FILE *list_file;
d203 2
a204 5
/* this static array is used to keep the text of data to be printed
   before the start of the line.
    It is stored so we can give a bit more info on the next line.  To much, and large
   initialized arrays will use up lots of paper.
 */
d206 5
a210 2
static char data_buffer[100];
static unsigned int data_buffer_size;
d212 1
d216 1
a216 1
static file_info_type *file_info PARAMS ((const char *file_name));
d218 1
a218 1
static char *buffer_line PARAMS ((file_info_type *file,
d222 2
a223 3
static void print_lines PARAMS ((list_info_type *list,
				 char *string,
				 unsigned int address));
d229 1
a229 1
static int debugging_pseudo PARAMS ((char *line));
d252 1
a252 1
  listing_message ("Warning:", message);
d259 1
a259 1
  listing_message ("Error:", message);
a261 5



static file_info_type *file_info_head;

d283 1
a286 4
  p->file = fopen (p->filename, "r");
  if (p->file)
    fgetc (p->file);

d308 1
a308 1
  list_info_type *new;
d316 18
d335 1
a335 1
  if (line != last_line || (last_file && file && strcmp(file, last_file)))
d337 2
a338 3
      last_line = line;
      last_file = file;
      new_frag ();
a340 3
      new->frag = frag_now;
      new->line = line;
      new->file = file_info (file);
d342 47
a388 3
      if (listing_tail)
	{
	  listing_tail->next = new;
d391 43
a433 10
	{
	  head = new;
	}
      listing_tail = new;
      new->next = (list_info_type *) NULL;
      new->message = (char *) NULL;
      new->edict = EDICT_NONE;
      new->hll_file = (file_info_type *) NULL;
      new->hll_line = 0;
      new_frag ();
d435 1
d485 5
a489 1
  if (file->file == (FILE *) NULL || file->at_end)
d491 17
a507 1
      return "";
d510 1
a510 4
  if (file->linenum == 0)
    rewind (file->file);

  c = fgetc (file->file);
d520 1
a520 1
      c = fgetc (file->file);
d551 1
a551 1
  if ((eject || (on_page >= paper_height)) && paper_height != 0)
d594 1
d596 1
a596 2
  unsigned int address = (unsigned int) ~0;

d599 1
a599 3

  unsigned int byte_in_frag;

d614 3
a616 2
      byte_in_frag = 0;
      while (byte_in_frag < frag_ptr->fr_fix && data_buffer_size < sizeof (data_buffer) - 10)
d618 1
a618 1
	  if (address == ~0)
d620 1
a620 1
	      address = frag_ptr->fr_address;
d625 1
a625 1
		   (frag_ptr->fr_literal[byte_in_frag]) & 0xff);
d627 1
a627 1
	  byte_in_frag++;
d630 2
a631 2
	unsigned int var_rep_max = byte_in_frag;
	unsigned int var_rep_idx = byte_in_frag;
d634 3
a636 3
	while ((byte_in_frag
		< frag_ptr->fr_fix + frag_ptr->fr_var * frag_ptr->fr_offset)
	       && data_buffer_size < sizeof (data_buffer) - 10)
d638 1
a638 1
	    if (address == ~0)
d640 1
a640 1
		address = frag_ptr->fr_address;
d652 1
a652 1
	    byte_in_frag++;
d654 1
a654 1
	    if (var_rep_idx >= frag_ptr->fr_fix + frag_ptr->fr_var)
d661 1
a661 1
  data_buffer[data_buffer_size++] = 0;
d671 1
a671 1
print_lines (list, string, address)
d673 1
d680 1
a680 1
  unsigned int byte_in_word = 0;
d682 1
d686 2
a687 1
  nchars = (LISTING_WORD_SIZE * 2 + 1) * LISTING_LHS_WIDTH;
d689 1
a689 1
  if (address == ~0)
d691 1
a691 1
      fprintf (list_file, "% 4d     ", list->line);
d696 3
a698 1
      on_page++;
d701 1
d703 3
d707 41
d749 2
a750 10
      if (had_errors ())
	{
	  fprintf (list_file, "% 4d ???? ", list->line);
	}
      else
	{
	  fprintf (list_file, "% 4d %04x ", list->line, address);
	}

      /* And the data to go along with it */
d752 14
a765 7

      while (*src && idx < nchars)
	{
	  fprintf (list_file, "%c%c", src[0], src[1]);
	  src += 2;
	  byte_in_word++;
	  if (byte_in_word == LISTING_WORD_SIZE)
d769 1
a769 1
	      byte_in_word = 0;
a770 1
	  idx += 2;
d772 3
a774 6

      for (; idx < nchars; idx++)
	fprintf (list_file, " ");

      fprintf (list_file, "\t%s\n", string ? string : "");
      on_page++;
a775 38
      if (list->message)
	{
	  fprintf (list_file, "****  %s\n", list->message);
	  listing_page (list);
	  on_page++;
	}

      for (lines = 0;
	   lines < LISTING_LHS_CONT_LINES
	   && *src;
	   lines++)
	{
	  nchars = ((LISTING_WORD_SIZE * 2) + 1) * LISTING_LHS_WIDTH_SECOND - 1;
	  idx = 0;
	  /* Print any more lines of data, but more compactly */
	  fprintf (list_file, "% 4d      ", list->line);

	  while (*src && idx < nchars)
	    {
	      fprintf (list_file, "%c%c", src[0], src[1]);
	      src += 2;
	      idx += 2;
	      byte_in_word++;
	      if (byte_in_word == LISTING_WORD_SIZE)
		{
		  fprintf (list_file, " ");
		  idx++;
		  byte_in_word = 0;
		}
	    }

	  fprintf (list_file, "\n");
	  on_page++;
	  listing_page (list);

	}


d792 2
a793 1
      if (ptr->sy_frag->line)
d795 5
d829 14
a842 5
	      fprintf (list_file, "%20s:%-5d  %s:%s %s\n",
		       ptr->sy_frag->line->file->filename,
		       ptr->sy_frag->line->line,
		       segment_name (S_GET_SEGMENT (ptr)),
		       buf, S_GET_NAME (ptr));
d844 1
a844 1
	      on_page++;
d865 1
a865 5
	  if (ptr->sy_frag->line == 0
#ifdef S_IS_REGISTER
	      && !S_IS_REGISTER (ptr)
#endif
	      && S_GET_SEGMENT (ptr) != reg_section)
d895 1
a895 1
  if (current_file->file)
d901 1
a901 1
	  fprintf (list_file, "%4d:%-13s **** %s\n", current_file->linenum,
d910 1
a910 1
   records inserted by the compiler, see if the line is suspicious */
d913 3
a915 2
debugging_pseudo (line)
     char *line;
d917 13
a929 1
  while (isspace (*line))
d933 19
a951 1
    return 0;
a981 1

d986 1
a986 1
     char *name;
d996 2
a997 1
  buffer = xmalloc (LISTING_RHS_WIDTH);
d1014 1
a1014 2
      width = LISTING_RHS_WIDTH > paper_width ? paper_width :
	LISTING_RHS_WIDTH;
d1016 4
d1023 2
a1024 1
	  show_listing++;
d1029 2
d1045 14
d1070 1
a1070 1
	  if (current_hll_file && list->hll_line && listing & LISTING_HLL)
d1075 13
a1087 3
	  while (list->file->file
		 && list->file->linenum < list->line
		 && !list->file->at_end)
d1089 4
a1092 1
	      p = buffer_line (list->file, buffer, width);
d1094 10
a1103 3
	      if (!((listing & LISTING_NODEBUG) && debugging_pseudo (p)))
		{
		  print_lines (list, p, calc_hex (list));
d1112 3
a1114 7
      else
	{
	  while (list->file->file
		 && list->file->linenum < list->line
		 && !list->file->at_end)
	    p = buffer_line (list->file, buffer, width);
	}
d1118 1
d1120 2
d1129 1
a1129 2
  file_info_type *fi;

d1145 1
a1145 1
	  as_perror ("can't open list file: %s", name);
d1169 1
a1169 1
	as_perror ("error closing list file: %s", name);
d1172 1
a1172 1
  for (fi = file_info_head; fi != NULL; fi = fi->next)
d1174 1
a1174 5
      if (fi->file != NULL)
	{
	  fclose (fi->file);
	  fi->file = NULL;
	}
d1188 1
a1188 1
     int ignore;
d1196 1
a1196 1
     int ignore;
d1203 5
d1213 23
a1235 1
    listing_tail->edict = on ? EDICT_LIST : EDICT_NOLIST;
d1250 1
a1250 1
	  as_warn ("strange paper height, set to no form");
d1269 1
a1269 1
     int ignore;
d1316 1
a1316 1
	  as_bad ("New line in title");
@


1.2
log
@Merge the Cygnus 960904 sources
@
text
@d691 1
a691 6
		{
		  char buf1[30];
		  sprintf_vma (buf1, val);
		  strcpy (buf, "00000000");
		  strcpy (buf + 8 - strlen (buf1), buf1);
		}
@


1.1
log
@Initial revision
@
text
@d305 3
d521 2
a522 1
	while (byte_in_frag < frag_ptr->fr_var * frag_ptr->fr_offset
d541 1
a541 1
	    if (var_rep_idx >= frag_ptr->fr_var)
d932 3
d939 4
a942 1
    list_file = stdout;
d946 3
a948 1
      if (list_file == NULL)
d952 1
d964 1
a965 1
    }
d970 15
d999 2
a1000 1
  listing_tail->edict = EDICT_EJECT;
d1016 2
a1017 1
  listing_tail->edict = on ? EDICT_LIST : EDICT_NOLIST;
d1082 9
a1090 6
	  length = input_line_pointer - start;
	  ttl = xmalloc (length + 1);
	  memcpy (ttl, start, length);
	  ttl[length] = 0;
	  listing_tail->edict = depth ? EDICT_SBTTL : EDICT_TITLE;
	  listing_tail->edict_arg = ttl;
d1115 6
a1120 4
  new_frag ();
  listing_tail->hll_line = line;
  new_frag ();

d1127 1
a1127 1
  if (listing_tail)
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@a304 3
  if (listing == 0)
    return;

d518 1
a518 2
	while ((byte_in_frag
		< frag_ptr->fr_fix + frag_ptr->fr_var * frag_ptr->fr_offset)
d537 1
a537 1
	    if (var_rep_idx >= frag_ptr->fr_fix + frag_ptr->fr_var)
a927 3
  int using_stdout;
  file_info_type *fi;

d932 1
a932 4
    {
      list_file = stdout;
      using_stdout = 1;
    }
d936 1
a936 3
      if (list_file != NULL)
	using_stdout = 0;
      else
a939 1
	  using_stdout = 1;
d951 1
a952 1

a956 15

  if (! using_stdout)
    {
      if (fclose (list_file) == EOF)
	as_perror ("error closing list file: %s", name);
    }

  for (fi = file_info_head; fi != NULL; fi = fi->next)
    {
      if (fi->file != NULL)
	{
	  fclose (fi->file);
	  fi->file = NULL;
	}
    }
d971 1
a971 2
  if (listing)
    listing_tail->edict = EDICT_EJECT;
d987 1
a987 2
  if (listing)
    listing_tail->edict = on ? EDICT_LIST : EDICT_NOLIST;
d1052 6
a1057 9
	  if (listing)
	    {
	      length = input_line_pointer - start;
	      ttl = xmalloc (length + 1);
	      memcpy (ttl, start, length);
	      ttl[length] = 0;
	      listing_tail->edict = depth ? EDICT_SBTTL : EDICT_TITLE;
	      listing_tail->edict_arg = ttl;
	    }
d1082 4
a1085 6
  if (listing)
    {
      new_frag ();
      listing_tail->hll_line = line;
      new_frag ();
    }
d1092 1
a1092 1
  if (listing)
@


1.1.1.3
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d691 6
a696 1
		sprintf_vma (buf, val);
@


1.1.1.4
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d17 2
a18 3
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA. */
a170 1
      EDICT_NOLIST_NEXT,
d208 3
a210 2
static void print_lines PARAMS ((list_info_type *, unsigned int,
				 char *, unsigned int));
d558 1
a558 1
print_lines (list, lineno, string, address)
a559 1
     unsigned int lineno;
d575 1
a575 1
      fprintf (list_file, "% 4d     ", lineno);
d588 1
a588 1
	  fprintf (list_file, "% 4d ???? ", lineno);
d592 1
a592 1
	  fprintf (list_file, "% 4d %04x ", lineno, address);
d633 1
a633 1
	  fprintf (list_file, "% 4d      ", lineno);
a862 2
	case EDICT_NOLIST_NEXT:
	  break;
a896 2
	      unsigned int address;

a898 5
	      if (list->file->linenum < list->line)
		address = ~ (unsigned int) 0;
	      else
		address = calc_hex (list);

d900 3
a902 1
		print_lines (list, list->file->linenum, p, address);
a917 3
      if (list->edict == EDICT_NOLIST_NEXT)
	--show_listing;

a1006 5
/* Turn listing on or off.  An argument of 0 means to turn off
   listing.  An argument of 1 means to turn on listing.  An argument
   of 2 means to turn off listing, but as of the next line; that is,
   the current line should be listed, but the next line should not.  */

d1012 1
a1012 23
    {
      switch (on)
	{
	case 0:
	  if (listing_tail->edict == EDICT_LIST)
	    listing_tail->edict = EDICT_NONE;
	  else
	    listing_tail->edict = EDICT_NOLIST;
	  break;
	case 1:
	  if (listing_tail->edict == EDICT_NOLIST
	      || listing_tail->edict == EDICT_NOLIST_NEXT)
	    listing_tail->edict = EDICT_NONE;
	  else
	    listing_tail->edict = EDICT_LIST;
	  break;
	case 2:
	  listing_tail->edict = EDICT_NOLIST_NEXT;
	  break;
	default:
	  abort ();
	}
    }
@


1.1.1.5
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
   Free Software Foundation, Inc.
a102 1

d110 1
a110 1
#define LISTING_LHS_WIDTH ((LISTING_WORD_SIZE) > 4 ? 1 : 4 / (LISTING_WORD_SIZE))
d113 1
a113 1
#define LISTING_LHS_WIDTH_SECOND LISTING_LHS_WIDTH
d122 3
d128 5
a132 5
  struct file_info_struct * next;
  char *                    filename;
  long                      pos;
  unsigned int              linenum;
  int                       at_end;
d134 1
d137 2
a138 1
/* This structure rememebrs which line from which file goes into which
d140 1
a140 1
struct list_info_struct
d143 1
a143 2
  fragS * frag;

d148 1
a148 1
  file_info_type * file;
d150 2
a151 2
  /* The expanded text of any macro that may have been executing.  */
  char * line_contents;
a152 2
  /* Next in list */
  struct list_info_struct * next;
d156 2
a157 1
  file_info_type * hll_file;
d159 2
a160 1
  unsigned int hll_line;
d163 1
a163 1
  char * message;
d175 1
a175 1
  char * edict_arg;
d177 1
a177 7
  /* Nonzero if this line is to be omitted because it contains
     debugging information.  This can become a flags field if we come
     up with more information to store here.  */
  int debugging;
};

typedef struct list_info_struct list_info_type;
d179 1
a180 4
int listing_lhs_width        = LISTING_LHS_WIDTH;
int listing_lhs_width_second = LISTING_LHS_WIDTH_SECOND;
int listing_lhs_cont_lines   = LISTING_LHS_CONT_LINES;
int listing_rhs_width        = LISTING_RHS_WIDTH;
d182 3
a184 1
struct list_info_struct *        listing_tail;
d186 2
a187 8
static file_info_type *          file_info_head;
static file_info_type *          last_open_file_info;
static FILE *                    last_open_file;
static struct list_info_struct * head;
static int                       paper_width = 200;
static int                       paper_height = 60;

extern int                       listing;
d190 1
a190 1
static FILE * list_file;
d192 5
a196 2
/* This static array is used to keep the text of data to be printed
   before the start of the line.  */
d198 2
a199 5
#define MAX_BYTES							\
  (((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width			\
   + ((((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width_second)	\
      * listing_lhs_cont_lines)						\
   + 20)
a200 1
static char * data_buffer;
d204 1
a204 1
static file_info_type * file_info PARAMS ((const char *file_name));
d206 1
a206 1
static char * buffer_line PARAMS ((file_info_type *file,
d217 1
a217 1
static int debugging_pseudo PARAMS ((list_info_type *, const char *));
d240 1
a240 1
  listing_message (_("Warning:"), message);
d247 1
a247 1
  listing_message (_("Error:"), message);
d250 5
a275 1
  p->pos = 0;
d279 4
d304 1
a304 1
  list_info_type *new = NULL;
a311 18
#ifdef OBJ_ELF
  /* In ELF, anything in a section beginning with .debug or .line is
     considered to be debugging information.  This includes the
     statement which switches us into the debugging section, which we
     can only set after we are already in the debugging section.  */
  if ((listing & LISTING_NODEBUG) != 0
      && listing_tail != NULL
      && ! listing_tail->debugging)
    {
      const char *segname;

      segname = segment_name (now_seg);
      if (strncmp (segname, ".debug", sizeof ".debug" - 1) == 0
	  || strncmp (segname, ".line", sizeof ".line" - 1) == 0)
	listing_tail->debugging = 1;
    }
#endif

d313 1
a313 1
  if (ps == NULL)
d315 3
a317 2
      if (line == last_line && !(last_file && file && strcmp (file, last_file)))
	return;
d320 3
d324 3
a326 47
      /* Detect if we are reading from stdin by examining the file
	 name returned by as_where().

	 [FIXME: We rely upon the name in the strcmp below being the
	 same as the one used by input_scrub_new_file(), if that is
	 not true, then this code will fail].

	 If we are reading from stdin, then we need to save each input line
	 here (assuming of course that we actually have a line of input to read),
	 so that it can be displayed in the listing that is produced at the end
	 of the assembly.  */
      if (strcmp (file, _("{standard input}")) == 0
	  && input_line_pointer != NULL)
	{
	  char * copy;
	  int len;
	  int seen_quote = 0;

	  for (copy = input_line_pointer - 1;
	       * copy && (seen_quote
			  || (! is_end_of_line [(unsigned char) * copy]));
	       copy ++)
	    if (* copy == '"' && copy[-1] != '\\')
	      seen_quote = ! seen_quote;

	  len = (copy - input_line_pointer) + 2;

	  copy = xmalloc (len);

	  if (copy != NULL)
	    {
	      char * src = input_line_pointer - 1;
	      char * dest = copy;
	      
	      while (--len)
		{
		  unsigned char c = * src ++;

		  /* Omit control characters in the listing.  */
		  if (isascii (c) && ! iscntrl (c))
		    * dest ++ = c;
		}
	      
	      *dest = 0;
	    }
	  
	  new->line_contents = copy;
d329 10
a338 43
	new->line_contents = NULL;
    }
  else
    {
      new = (list_info_type *) xmalloc (sizeof (list_info_type));
      new->line_contents = ps;
    }

  last_line = line;
  last_file = file;
  
  new_frag ();

  if (listing_tail)
    listing_tail->next = new;
  else
    head = new;
  
  listing_tail = new;

  new->frag = frag_now;
  new->line = line;
  new->file = file_info (file);
  new->next = (list_info_type *) NULL;
  new->message = (char *) NULL;
  new->edict = EDICT_NONE;
  new->hll_file = (file_info_type *) NULL;
  new->hll_line = 0;
  new->debugging = 0;
  
  new_frag ();

#ifdef OBJ_ELF
  /* In ELF, anything in a section beginning with .debug or .line is
     considered to be debugging information.  */
  if ((listing & LISTING_NODEBUG) != 0)
    {
      const char *segname;

      segname = segment_name (now_seg);
      if (strncmp (segname, ".debug", sizeof ".debug" - 1) == 0
	  || strncmp (segname, ".line", sizeof ".line" - 1) == 0)
	new->debugging = 1;
a339 1
#endif
d389 1
a389 5
  if (file->at_end)
    return "";

  /* Check the cache and see if we last used this file.  */
  if (!last_open_file_info || file != last_open_file_info)
d391 2
a392 5
      if (last_open_file)
	{
	  last_open_file_info->pos = ftell (last_open_file);
	  fclose (last_open_file);
	}
d394 2
a395 12
      last_open_file_info = file;
      last_open_file = fopen (file->filename, "r");
      if (last_open_file == NULL)
	{
	  file->at_end = 1;
	  return "";
	}
      
      /* Seek to where we were last time this file was open.  */
      if (file->pos)
	fseek(last_open_file, file->pos, SEEK_SET);
    }
d397 1
a397 1
  c = fgetc (last_open_file);
d407 1
a407 1
      c = fgetc (last_open_file);
d438 1
a438 1
  if ((eject || (on_page >= (unsigned int) paper_height)) && paper_height != 0)
a480 1
  int data_buffer_size;
d482 2
a483 1
  unsigned int address = ~ (unsigned int) 0;
d486 3
a488 1
  unsigned int octet_in_frag;
d503 2
a504 3
      octet_in_frag = 0;
      while ((offsetT) octet_in_frag < frag_ptr->fr_fix
	     && data_buffer_size < MAX_BYTES - 3)
d506 1
a506 1
	  if (address == ~ (unsigned int) 0)
d508 1
a508 1
	      address = frag_ptr->fr_address / OCTETS_PER_BYTE;
d513 1
a513 1
		   (frag_ptr->fr_literal[octet_in_frag]) & 0xff);
d515 1
a515 1
	  octet_in_frag++;
d518 2
a519 2
	unsigned int var_rep_max = octet_in_frag;
	unsigned int var_rep_idx = octet_in_frag;
d522 3
a524 3
	while (((offsetT) octet_in_frag
		< (frag_ptr->fr_fix + frag_ptr->fr_var * frag_ptr->fr_offset))
	       && data_buffer_size < MAX_BYTES - 3)
d526 1
a526 1
	    if (address == ~ (unsigned int) 0)
d528 1
a528 1
		address = frag_ptr->fr_address / OCTETS_PER_BYTE;
d540 1
a540 1
	    octet_in_frag++;
d542 1
a542 1
	    if ((offsetT) var_rep_idx >= frag_ptr->fr_fix + frag_ptr->fr_var)
d549 1
a549 1
  data_buffer[data_buffer_size] = '\0';
d568 1
a568 1
  unsigned int octet_in_word = 0;
a569 1
  int cur;
d573 1
a573 2
  nchars = (LISTING_WORD_SIZE * 2 + 1) * listing_lhs_width;
  
d575 1
a575 1
  if (address == ~ (unsigned int) 0)
d582 1
a582 3
      
      on_page ++;
      
a584 1
      return;
a585 3

  if (had_errors ())
    fprintf (list_file, "% 4d ???? ", lineno);
d587 9
a595 1
    fprintf (list_file, "% 4d %04x ", lineno, address);
d597 1
a597 42
  /* And the data to go along with it */
  idx = 0;
  cur = 0;
  while (src[cur] && idx < nchars)
    {
      int offset;
      offset = cur;
      fprintf (list_file, "%c%c", src[offset], src[offset+1]);
      cur += 2;
      octet_in_word++;
      
      if (octet_in_word == LISTING_WORD_SIZE)
	{
	  fprintf (list_file, " ");
	  idx++;
	  octet_in_word = 0;
	}
      
      idx += 2;
    }
  
  for (; idx < nchars; idx++)
    fprintf (list_file, " ");
  
  fprintf (list_file, "\t%s\n", string ? string : "");
  on_page++;
  listing_page (list);
  
  if (list->message)
    {
      fprintf (list_file, "****  %s\n", list->message);
      listing_page (list);
      on_page++;
    }
  
  for (lines = 0;
       lines < (unsigned int) listing_lhs_cont_lines
	 && src[cur];
       lines ++)
    {
      nchars = ((LISTING_WORD_SIZE * 2) + 1)
	* listing_lhs_width_second - 1;
d599 7
a605 14
      
      /* Print any more lines of data, but more compactly */
      fprintf (list_file, "% 4d      ", lineno);
      
      while (src[cur] && idx < nchars)
	{
          int offset;
          offset = cur;
          fprintf (list_file, "%c%c", src[offset], src[offset+1]);
	  cur += 2;
	  idx += 2;
	  octet_in_word++;
	  
	  if (octet_in_word == LISTING_WORD_SIZE)
d609 1
a609 1
	      octet_in_word = 0;
d611 1
d613 6
a618 3
      
      fprintf (list_file, "\n");
      on_page ++;
d620 38
d674 1
a674 2
      if (SEG_NORMAL (S_GET_SEGMENT (ptr))
	  || S_GET_SEGMENT (ptr) == absolute_section)
a675 5
#ifdef BFD_ASSEMBLER
	  /* Don't report section symbols.  They are not interesting.  */
	  if (symbol_section_p (ptr))
	    continue;
#endif
d705 5
a709 14
	      if (symbol_get_frag (ptr) && symbol_get_frag (ptr)->line)
		{
		  fprintf (list_file, "%20s:%-5d  %s:%s %s\n",
			   symbol_get_frag (ptr)->line->file->filename,
			   symbol_get_frag (ptr)->line->line,
			   segment_name (S_GET_SEGMENT (ptr)),
			   buf, S_GET_NAME (ptr));
		}
	      else
		{
		  fprintf (list_file, "%33s:%s %s\n",
			   segment_name (S_GET_SEGMENT (ptr)),
			   buf, S_GET_NAME (ptr));
		}
d711 1
a711 1
	      on_page ++;
d732 5
a736 1
	  if (S_GET_SEGMENT (ptr) == undefined_section)
d766 1
a766 1
  if (!current_file->at_end)
d772 1
a772 1
	  fprintf (list_file, "%4u:%-13s **** %s\n", current_file->linenum,
d781 1
a781 1
   records inserted by the compiler, see if the line is suspicious.  */
d784 2
a785 3
debugging_pseudo (list, line)
     list_info_type *list;
     const char *line;
d787 1
a787 13
  static int in_debug;
  int was_debug;

  if (list->debugging)
    {
      in_debug = 1;
      return 1;
    }

  was_debug = in_debug;
  in_debug = 0;

  while (isspace ((unsigned char) *line))
d791 1
a791 19
    {
#ifdef OBJ_ELF
      /* The ELF compiler sometimes emits blank lines after switching
         out of a debugging section.  If the next line drops us back
         into debugging information, then don't print the blank line.
         This is a hack for a particular compiler behaviour, not a
         general case.  */
      if (was_debug
	  && *line == '\0'
	  && list->next != NULL
	  && list->next->debugging)
	{
	  in_debug = 1;
	  return 1;
	}
#endif

      return 0;
    }
d822 1
d827 1
a827 1
     char *name ATTRIBUTE_UNUSED;
d837 1
a837 2
  buffer = xmalloc (listing_rhs_width);
  data_buffer = xmalloc (MAX_BYTES);
d854 2
a855 1
      unsigned int list_line;
a856 4
      width = listing_rhs_width > paper_width ? paper_width :
	listing_rhs_width;

      list_line = list->line;
d860 1
a860 2
	  /* Skip all lines up to the current.  */
	  list_line--;
a880 14
      if (show_listing <= 0)
	{
	  while (list->file->linenum < list_line
		 && !list->file->at_end)
	    p = buffer_line (list->file, buffer, width);
	}

      if (list->edict == EDICT_LIST)
	{
	  /* Enable listing for the single line that caused the enable.  */
	  list_line++;
	  show_listing++;
	}

d892 1
a892 1
	  if (current_hll_file && list->hll_line && (listing & LISTING_HLL))
d897 3
a899 1
	  if (list->line_contents)
d901 3
a903 16
	      if (!((listing & LISTING_NODEBUG)
		    && debugging_pseudo (list, list->line_contents)))
		{
 		  print_lines (list,
			       list->file->linenum == 0 ? list->line : list->file->linenum,
			       list->line_contents, calc_hex (list));
		}
	      free (list->line_contents);
	      list->line_contents = NULL;
	    }
	  else
	    {
	      while (list->file->linenum < list_line
		     && !list->file->at_end)
		{
		  unsigned int address;
d905 4
a908 1
		  p = buffer_line (list->file, buffer, width);
d910 2
a911 9
		  if (list->file->linenum < list_line)
		    address = ~ (unsigned int) 0;
		  else
		    address = calc_hex (list);

		  if (!((listing & LISTING_NODEBUG)
			&& debugging_pseudo (list, p)))
		    print_lines (list, list->file->linenum, p, address);
		}
d919 7
a931 1

a932 2
  free (data_buffer);
  data_buffer = NULL;
d940 2
a941 1
  
d957 1
a957 1
	  as_perror (_("can't open list file: %s"), name);
d981 1
a981 1
	as_perror (_("error closing list file: %s"), name);
d984 1
a984 1
  if (last_open_file)
d986 5
a990 1
      fclose (last_open_file);
d1004 1
a1004 1
     int ignore ATTRIBUTE_UNUSED;
d1012 1
a1012 1
     int ignore ATTRIBUTE_UNUSED;
d1066 1
a1066 1
	  as_warn (_("strange paper height, set to no form"));
d1085 1
a1085 1
     int ignore ATTRIBUTE_UNUSED;
d1132 1
a1132 1
	  as_bad (_("New line in title"));
@


1.1.1.6
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
d20 1
a20 1
02111-1307, USA.  */
d23 3
a25 1
 Contributed by Steve Chamberlain <sac@@cygnus.com>
d60 1
d124 3
a126 2
/* This structure remembers which .s were used.  */
typedef struct file_info_struct {
d132 2
a133 1
} file_info_type;
d136 5
a140 4
   frag.  */
struct list_info_struct {
  /* Frag which this line of source is nearest to.  */
  fragS *frag;
d142 1
a142 1
  /* The actual line in the source file.  */
d145 2
a146 2
     belongs to.  */
  file_info_type *file;
d149 1
a149 1
  char *line_contents;
d151 2
a152 2
  /* Next in list.  */
  struct list_info_struct *next;
d155 3
a157 3
     source line that belongs here.  */
  file_info_type *hll_file;
  /* High level language source line.  */
d160 2
a161 2
  /* Pointer to any error message associated with this line.  */
  char *message;
d163 11
a173 10
  enum {
    EDICT_NONE,
    EDICT_SBTTL,
    EDICT_TITLE,
    EDICT_NOLIST,
    EDICT_LIST,
    EDICT_NOLIST_NEXT,
    EDICT_EJECT
  } edict;
  char *edict_arg;
d183 1
d201 1
a201 1
static FILE *list_file;
d212 1
a212 1
static char *data_buffer;
d216 1
a216 1
static file_info_type *file_info PARAMS ((const char *file_name));
d218 1
a218 1
static char *buffer_line PARAMS ((file_info_type *file,
d232 1
d238 4
a243 4
      unsigned int l = strlen (name) + strlen (message) + 1;
      char *n = (char *) xmalloc (l);
      strcpy (n, name);
      strcat (n, message);
d266 1
a266 1
  /* Find an entry with this file name.  */
d276 1
a276 1
  /* Make new entry.  */
d290 1
d337 1
a337 2
      if (line == last_line
	  && !(last_file && file && strcmp (file, last_file)))
d349 4
a352 4
	 If we are reading from stdin, then we need to save each input
	 line here (assuming of course that we actually have a line of
	 input to read), so that it can be displayed in the listing
	 that is produced at the end of the assembly.  */
d356 1
a356 1
	  char *copy;
d361 4
a364 4
	       *copy && (seen_quote
			 || (! is_end_of_line [(unsigned char) *copy]));
	       copy++)
	    if (*copy == '"' && copy[-1] != '\\')
d373 3
a375 3
	      char *src = input_line_pointer - 1;
	      char *dest = copy;

d378 1
a378 1
		  unsigned char c = *src++;
d382 1
a382 1
		    *dest++ = c;
d384 1
a384 1

d387 1
a387 1

d401 1
a401 1

d408 1
a408 1

d420 1
a420 1

d467 5
a471 3
/* This function returns the next source line from the file supplied,
   truncated to size.  It appends a fake line to the end of each input
   file to make.  */
d475 1
a475 1
     file_info_type *file;
d484 1
a484 1
  /* If we couldn't open the file, return an empty line.  */
d504 1
a504 1

d507 1
a507 1
	fseek (last_open_file, file->pos, SEEK_SET);
d512 1
a512 2
  /* Leave room for null.  */
  size -= 1;
d535 1
d540 4
a543 3
static char *title;		/* Current title */
static char *subtitle;		/* Current subtitle */
static unsigned int on_page;	/* Number of lines printed on current page */
d550 2
a551 3
     soon.  (we look down 10 lines of the page and see if it's there)  */
  if ((eject || (on_page >= (unsigned int) paper_height))
      && paper_height != 0)
d575 1
d589 1
d592 1
a592 1
     list_info_type *list;
d596 1
a596 1
  unsigned int address = ~(unsigned int) 0;
d601 1
a601 1
  /* Find first frag which says it belongs to this line.  */
d610 1
a610 1
  /* Dump all the frags which belong to this line.  */
d613 1
a613 1
      /* Print as many bytes from the fixed part as is sensible.  */
d618 1
a618 1
	  if (address == ~(unsigned int) 0)
a628 1
    if (frag_ptr->fr_type == rs_fill)
d633 1
a633 1
	/* Print as many bytes from the variable part as is sensible.  */
d638 1
a638 1
	    if (address == ~(unsigned int) 0)
d665 5
d684 1
a684 1
  /* Print the stuff on the first line.  */
d687 3
a689 3

  /* Print the hex for the first line.  */
  if (address == ~(unsigned int) 0)
d696 3
a698 3

      on_page++;

d709 1
a709 1
  /* And the data to go along with it.  */
d716 1
a716 1
      fprintf (list_file, "%c%c", src[offset], src[offset + 1]);
d719 1
a719 1

d726 1
a726 1

d729 1
a729 1

d732 1
a732 1

d736 1
a736 1

d743 1
a743 1

d747 1
a747 1
       lines++)
d749 2
a750 1
      nchars = ((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width_second - 1;
d752 2
a753 2

      /* Print any more lines of data, but more compactly.  */
d755 1
a755 1

d758 3
a760 3
	  int offset;
	  offset = cur;
	  fprintf (list_file, "%c%c", src[offset], src[offset + 1]);
d764 1
a764 1

d772 1
a772 1

d774 1
a774 1
      on_page++;
d779 1
d844 1
a844 1
	      on_page++;
d1011 1
a1029 2
	  if (show_listing == 0)
	    list_line--;
d1052 1
a1052 2
      if (list->edict == EDICT_LIST
	  || (list->edict == EDICT_NOLIST_NEXT && show_listing == 0))
d1097 1
a1097 1
		    address = ~(unsigned int) 0;
d1113 1
a1113 1
      if (list->edict == EDICT_NOLIST_NEXT && show_listing == 1)
d1129 1
a1129 1

d1178 1
d1238 1
d1327 2
d1349 2
d1353 2
a1354 1
/* Dummy functions for when compiled without listing enabled.  */
d1363 1
a1363 1
void
d1370 1
a1370 1
void
d1377 1
a1377 1
void
d1391 1
a1391 1
void
d1405 1
a1405 1
void
d1412 1
a1412 1
void
d1418 1
a1418 2

void
@


1.1.1.7
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   2001, 2002
d94 2
d97 1
a97 2
#include "obstack.h"
#include "safe-ctype.h"
d273 2
a274 1
  p->filename = xstrdup (file_name);
d373 1
a373 1
		  if (!ISCNTRL (c))
d488 1
a488 1
      last_open_file = fopen (file->filename, FOPEN_RT);
d517 3
a519 6
      if (count + 2 < size)
	{
	  *p++ = '.';
	  *p++ = '.';
	  *p++ = '.';
	}
d617 17
a633 17
      if (frag_ptr->fr_type == rs_fill)
	{
	  unsigned int var_rep_max = octet_in_frag;
	  unsigned int var_rep_idx = octet_in_frag;

	  /* Print as many bytes from the variable part as is sensible.  */
	  while (((offsetT) octet_in_frag
		  < (frag_ptr->fr_fix + frag_ptr->fr_var * frag_ptr->fr_offset))
		 && data_buffer_size < MAX_BYTES - 3)
	    {
	      if (address == ~(unsigned int) 0)
		{
		  address = frag_ptr->fr_address / OCTETS_PER_BYTE;
		}
	      sprintf (data_buffer + data_buffer_size,
		       "%02X",
		       (frag_ptr->fr_literal[var_rep_idx]) & 0xff);
d635 2
a636 2
	      data_buffer[data_buffer_size++] = '*';
	      data_buffer[data_buffer_size++] = '*';
d638 1
a638 1
	      data_buffer_size += 2;
d640 2
a641 2
	      var_rep_idx++;
	      octet_in_frag++;
d643 4
a646 4
	      if ((offsetT) var_rep_idx >= frag_ptr->fr_fix + frag_ptr->fr_var)
		var_rep_idx = var_rep_max;
	    }
	}
d911 1
a911 1
  while (ISSPACE (*line))
d1064 1
a1064 1
		  print_lines (list,
d1124 1
a1124 1
      list_file = fopen (name, FOPEN_WT);
d1298 1
a1298 1
	  as_bad (_("new line in title"));
@


1.1.1.8
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d1 1
a1 1
/* listing.c - maintain assembly listings
d3 1
a3 1
   2001, 2002, 2003
d6 1
a6 1
   This file is part of GAS, the GNU Assembler.
d8 14
a21 14
   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d23 2
a24 1
/* Contributed by Steve Chamberlain <sac@@cygnus.com>
d68 1
a68 1
 function also remembers when the filename changes.
d89 1
a89 1
 LISTING_LHS_CONT_LINES	Max number of lines to use up for a continuation
d91 2
a92 1
                        on a line.  */
d122 1
a122 2
typedef struct file_info_struct
{
d130 1
a130 1
/* This structure remembers which line from which file goes into which
d132 1
a132 2
struct list_info_struct
{
a137 1

a150 1

d157 9
a165 10
  enum
    {
      EDICT_NONE,
      EDICT_SBTTL,
      EDICT_TITLE,
      EDICT_NOLIST,
      EDICT_LIST,
      EDICT_NOLIST_NEXT,
      EDICT_EJECT
    } edict;
d207 16
a222 11
static void listing_message (const char *, const char *);
static file_info_type *file_info (const char *);
static void new_frag (void);
static char *buffer_line (file_info_type *, char *, unsigned int);
static void listing_page (list_info_type *);
static unsigned int calc_hex (list_info_type *);
static void print_lines (list_info_type *, unsigned int, char *, unsigned int);
static void list_symbol_table (void);
static void print_source (file_info_type *, list_info_type *, char *, unsigned int);
static int debugging_pseudo (list_info_type *, const char *);
static void listing_listing (char *);
d225 3
a227 1
listing_message (const char *name, const char *message)
d240 2
a241 1
listing_warning (const char *message)
d247 2
a248 1
listing_error (const char *message)
d254 2
a255 1
file_info (const char *file_name)
d268 2
a269 1
  p = xmalloc (sizeof (file_info_type));
d281 1
a281 1
new_frag (void)
d283 1
d286 1
d290 2
a291 1
listing_newline (char *ps)
d385 1
a385 1
      new = xmalloc (sizeof (list_info_type));
d435 1
a435 1
listing_prev_line (void)
d462 4
a465 1
buffer_line (file_info_type *file, char *line, unsigned int size)
d536 2
a537 1
listing_page (list_info_type *list)
d580 2
a581 1
calc_hex (list_info_type *list)
d608 3
a610 1
	    address = frag_ptr->fr_address / OCTETS_PER_BYTE;
d629 3
a631 2
		address = frag_ptr->fr_address / OCTETS_PER_BYTE;

d656 5
a660 2
print_lines (list_info_type *list, unsigned int lineno,
	     char *string, unsigned int address)
d764 1
a764 1
list_symbol_table (void)
d872 5
a876 2
print_source (file_info_type *current_file, list_info_type *list,
	      char *buffer, unsigned int width)
a883 1

d896 3
a898 1
debugging_pseudo (list_info_type *list, const char *line)
d958 1
d968 2
a969 1
listing_listing (char *name ATTRIBUTE_UNUSED)
d989 1
d1051 3
a1053 1
	    current_hll_file = list->hll_file;
d1056 3
a1058 1
	    print_source (current_hll_file, list, buffer, width);
d1064 5
a1068 4
		print_lines (list,
			     list->file->linenum == 0 ? list->line : list->file->linenum,
			     list->line_contents, calc_hex (list));

d1093 3
a1095 1
	    eject = 1;
d1110 2
a1111 1
listing_print (char *name)
a1129 3
#ifdef BFD_ASSEMBLER
      bfd_set_error (bfd_error_system_call);
#endif
d1137 3
a1139 1
    paper_height = 0;
d1142 3
a1144 1
    listing_listing (name);
d1147 3
a1149 1
    list_symbol_table ();
d1154 1
a1154 6
	{
#ifdef BFD_ASSEMBLER
	  bfd_set_error (bfd_error_system_call);
#endif
	  as_perror (_("error closing list file: %s"), name);
	}
d1158 3
a1160 1
    fclose (last_open_file);
d1164 2
a1165 1
listing_file (const char *name)
d1171 2
a1172 1
listing_eject (int ignore ATTRIBUTE_UNUSED)
d1179 2
a1180 1
listing_flags (int ignore ATTRIBUTE_UNUSED)
d1193 2
a1194 1
listing_list (int on)
d1223 2
a1224 1
listing_psize (int width_only)
d1251 2
a1252 1
listing_nopage (int ignore ATTRIBUTE_UNUSED)
d1258 2
a1259 1
listing_title (int depth)
d1311 2
a1312 1
listing_source_line (unsigned int line)
d1323 2
a1324 1
listing_source_file (const char *file)
d1335 2
a1336 1
listing_flags (int ignore)
d1342 2
a1343 1
listing_list (int on)
d1349 2
a1350 1
listing_eject (int ignore)
d1356 2
a1357 1
listing_psize (int ignore)
d1363 2
a1364 1
listing_nopage (int ignore)
d1370 2
a1371 1
listing_title (int depth)
d1377 2
a1378 1
listing_file (const char *name)
d1380 1
d1384 2
a1385 1
listing_newline (char *name)
d1387 1
d1391 2
a1392 1
listing_source_line (unsigned int n)
d1394 1
d1398 2
a1399 1
listing_source_file (const char *n)
d1401 1
@


