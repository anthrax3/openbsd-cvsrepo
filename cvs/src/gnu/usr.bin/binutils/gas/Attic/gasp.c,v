head	1.7;
access;
symbols
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2004.05.17.21.54.28;	author drahn;	state dead;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.42;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.21;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.04.39;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.37;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.37;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.33;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.43.34;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.03;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.21.53;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.10;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.31.54;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@/* gasp.c - Gnu assembler preprocessor main program.
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.

   Written by Steve and Judy Chamberlain of Cygnus Support,
      sac@@cygnus.com

   This file is part of GASP, the GNU Assembler Preprocessor.

   GASP is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GASP is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GASP; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/*
This program translates the input macros and stuff into a form
suitable for gas to consume.

  gasp [-sdhau] [-c char] [-o <outfile>] <infile>*

  -s copy source to output
  -c <char> comments are started with <char> instead of !
  -u allow unreasonable stuff
  -p print line numbers
  -d print debugging stats
  -s semi colons start comments
  -a use alternate syntax
     Pseudo ops can start with or without a .
     Labels have to be in first column.
  -I specify include dir
    Macro arg parameters subsituted by name, don't need the &.
     String can start with ' too.
     Strings can be surrounded by <..>
     A %<exp> in a string evaluates the expression
     Literal char in a string with !
*/

#include "config.h"
#include "bin-bugs.h"

#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <ctype.h>

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef NEED_MALLOC_DECLARATION
extern char *malloc ();
#endif

#include "ansidecl.h"
#include "libiberty.h"
#include "sb.h"
#include "macro.h"
#include "asintl.h"

char *program_version = "1.2";

/* This is normally declared in as.h, but we don't include that.  We
   need the function because other files linked with gasp.c might call
   it.  */
extern void as_abort PARAMS ((const char *, int, const char *));

/* The default obstack chunk size.  If we set this to zero, the
   obstack code will use whatever will fit in a 4096 byte block.  This
   is used by the hash table code used by macro.c.  */
int chunksize = 0;

#define MAX_INCLUDES 30		/* Maximum include depth.  */
#define MAX_REASONABLE 1000	/* Maximum number of expansions.  */

int unreasonable;		/* -u on command line.  */
int stats;			/* -d on command line.  */
int print_line_number;		/* -p flag on command line.  */
int copysource;			/* -c flag on command line.  */
int warnings;			/* Number of WARNINGs generated so far.  */
int errors;			/* Number of ERRORs generated so far.  */
int fatals;			/* Number of fatal ERRORs generated so far (either 0 or 1).  */
int alternate = 0;              /* -a on command line.  */
int mri = 0;			/* -M on command line.  */
char comment_char = '!';
int radix = 10;			/* Default radix.  */

int had_end; /* Seen .END.  */

/* The output stream.  */
FILE *outfile;

/* The attributes of each character are stored as a bit pattern
   chartype, which gives us quick tests.  */

#define FIRSTBIT 1
#define NEXTBIT  2
#define SEPBIT   4
#define WHITEBIT 8
#define COMMENTBIT 16
#define BASEBIT  32
#define ISCOMMENTCHAR(x) (chartype[(unsigned char)(x)] & COMMENTBIT)
#define ISFIRSTCHAR(x)  (chartype[(unsigned char)(x)] & FIRSTBIT)
#define ISNEXTCHAR(x)   (chartype[(unsigned char)(x)] & NEXTBIT)
#define ISSEP(x)        (chartype[(unsigned char)(x)] & SEPBIT)
#define ISWHITE(x)      (chartype[(unsigned char)(x)] & WHITEBIT)
#define ISBASE(x)       (chartype[(unsigned char)(x)] & BASEBIT)
static char chartype[256];

/* Conditional assembly uses the `ifstack'.  Each aif pushes another
   entry onto the stack, and sets the on flag if it should.  The aelse
   sets hadelse, and toggles on.  An aend pops a level.  We limit to
   100 levels of nesting, not because we're facists pigs with read
   only minds, but because more than 100 levels of nesting is probably
   a bug in the user's macro structure.  */

#define IFNESTING 100
struct {
  int on;			/* Is the level being output.  */
  int hadelse;			/* Has an aelse been seen.  */
} ifstack[IFNESTING];

int ifi;

/* The final and intermediate results of expression evaluation are kept in
   exp_t's.  Note that a symbol is not an sb, but a pointer into the input
   line.  It must be coped somewhere safe before the next line is read in.  */

typedef struct {
  char *name;
  int len;
} symbol;

typedef struct {
  int value;			/* Constant part.  */
  symbol add_symbol;		/* Name part.  */
  symbol sub_symbol;		/* Name part.  */
} exp_t;

/* Hashing is done in a pretty standard way.  A hash_table has a
   pointer to a vector of pointers to hash_entrys, and the size of the
   vector.  A hash_entry contains a union of all the info we like to
   store in hash table.  If there is a hash collision, hash_entries
   with the same hash are kept in a chain.  */

/* What the data in a hash_entry means.  */
typedef enum {
  hash_integer,			/* Name->integer mapping.  */
  hash_string,			/* Name->string mapping.  */
  hash_macro,			/* Name is a macro.  */
  hash_formal			/* Name is a formal argument.  */
} hash_type;

typedef struct hs {
  sb key;			/* Symbol name.  */
  hash_type type;		/* Symbol meaning.  */
  union {
    sb s;
    int i;
    struct macro_struct *m;
    struct formal_struct *f;
  } value;
  struct hs *next;		/* Next hash_entry with same hash key.  */
} hash_entry;

typedef struct {
  hash_entry **table;
  int size;
} hash_table;

/* How we nest files and expand macros etc.

   We keep a stack of of include_stack structs.  Each include file
   pushes a new level onto the stack.  We keep an sb with a pushback
   too.  unget chars are pushed onto the pushback sb, getchars first
   checks the pushback sb before reading from the input stream.

   Small things are expanded by adding the text of the item onto the
   pushback sb.  Larger items are grown by pushing a new level and
   allocating the entire pushback buf for the item.  Each time
   something like a macro is expanded, the stack index is changed.  We
   can then perform an exitm by popping all entries off the stack with
   the same stack index.  If we're being reasonable, we can detect
   recusive expansion by checking the index is reasonably small.  */

typedef enum {
  include_file, include_repeat, include_while, include_macro
} include_type;

struct include_stack {
  sb pushback;			/* Current pushback stream.  */
  int pushback_index;		/* Next char to read from stream.  */
  FILE *handle;			/* Open file.  */
  sb name;			/* Name of file.  */
  int linecount;		/* Number of lines read so far.  */
  include_type type;
  int index;			/* Index of this layer.  */
} include_stack[MAX_INCLUDES];

struct include_stack *sp;
#define isp (sp - include_stack)

/* Include file list.  */

typedef struct include_path {
  struct include_path *next;
  sb path;
} include_path;

include_path *paths_head;
include_path *paths_tail;

static void quit PARAMS ((void));
static void hash_new_table PARAMS ((int, hash_table *));
static int hash PARAMS ((sb *));
static hash_entry *hash_create PARAMS ((hash_table *, sb *));
static void hash_add_to_string_table PARAMS ((hash_table *, sb *, sb *, int));
static void hash_add_to_int_table PARAMS ((hash_table *, sb *, int));
static hash_entry *hash_lookup PARAMS ((hash_table *, sb *));
static void checkconst PARAMS ((int, exp_t *));
static int sb_strtol PARAMS ((int, sb *, int, int *));
static int level_0 PARAMS ((int, sb *, exp_t *));
static int level_1 PARAMS ((int, sb *, exp_t *));
static int level_2 PARAMS ((int, sb *, exp_t *));
static int level_3 PARAMS ((int, sb *, exp_t *));
static int level_4 PARAMS ((int, sb *, exp_t *));
static int level_5 PARAMS ((int, sb *, exp_t *));
static int exp_parse PARAMS ((int, sb *, exp_t *));
static void exp_string PARAMS ((exp_t *, sb *));
static int exp_get_abs PARAMS ((const char *, int, sb *, int *));
#if 0
static void strip_comments PARAMS ((sb *));
#endif
static void unget PARAMS ((int));
static void include_buf PARAMS ((sb *, sb *, include_type, int));
static void include_print_where_line PARAMS ((FILE *));
static void include_print_line PARAMS ((FILE *));
static int get_line PARAMS ((sb *));
static int grab_label PARAMS ((sb *, sb *));
static void change_base PARAMS ((int, sb *, sb *));
static void do_end PARAMS ((sb *));
static void do_assign PARAMS ((int, int, sb *));
static void do_radix PARAMS ((sb *));
static int get_opsize PARAMS ((int, sb *, int *));
static int eol PARAMS ((int, sb *));
static void do_data PARAMS ((int, sb *, int));
static void do_datab PARAMS ((int, sb *));
static void do_align PARAMS ((int, sb *));
static void do_res PARAMS ((int, sb *, int));
static void do_export PARAMS ((sb *));
static void do_print PARAMS ((int, sb *));
static void do_heading PARAMS ((int, sb *));
static void do_page PARAMS ((void));
static void do_form PARAMS ((int, sb *));
static int get_any_string PARAMS ((int, sb *, sb *, int, int));
static int skip_openp PARAMS ((int, sb *));
static int skip_closep PARAMS ((int, sb *));
static int dolen PARAMS ((int, sb *, sb *));
static int doinstr PARAMS ((int, sb *, sb *));
static int dosubstr PARAMS ((int, sb *, sb *));
static void process_assigns PARAMS ((int, sb *, sb *));
static int get_and_process PARAMS ((int, sb *, sb *));
static void process_file PARAMS ((void));
static void free_old_entry PARAMS ((hash_entry *));
static void do_assigna PARAMS ((int, sb *));
static void do_assignc PARAMS ((int, sb *));
static void do_reg PARAMS ((int, sb *));
static int condass_lookup_name PARAMS ((sb *, int, sb *, int));
static int whatcond PARAMS ((int, sb *, int *));
static int istrue PARAMS ((int, sb *));
static void do_aif PARAMS ((int, sb *));
static void do_aelse PARAMS ((void));
static void do_aendi PARAMS ((void));
static int condass_on PARAMS ((void));
static void do_if PARAMS ((int, sb *, int));
static int get_mri_string PARAMS ((int, sb *, sb *, int));
static void do_ifc PARAMS ((int, sb *, int));
static void do_aendr PARAMS ((void));
static void do_awhile PARAMS ((int, sb *));
static void do_aendw PARAMS ((void));
static void do_exitm PARAMS ((void));
static void do_arepeat PARAMS ((int, sb *));
static void do_endm PARAMS ((void));
static void do_irp PARAMS ((int, sb *, int));
static void do_local PARAMS ((int, sb *));
static void do_macro PARAMS ((int, sb *));
static int macro_op PARAMS ((int, sb *));
static int getstring PARAMS ((int, sb *, sb *));
static void do_sdata PARAMS ((int, sb *, int));
static void do_sdatab PARAMS ((int, sb *));
static int new_file PARAMS ((const char *));
static void do_include PARAMS ((int, sb *));
static void include_pop PARAMS ((void));
static int get PARAMS ((void));
static int linecount PARAMS ((void));
static int include_next_index PARAMS ((void));
static void chartype_init PARAMS ((void));
static int process_pseudo_op PARAMS ((int, sb *, sb *));
static void add_keyword PARAMS ((const char *, int));
static void process_init PARAMS ((void));
static void do_define PARAMS ((const char *));
static void show_usage PARAMS ((FILE *, int));
static void show_help PARAMS ((void));

#define FATAL(x)				\
  do						\
    {						\
      include_print_where_line (stderr);	\
      fprintf x;				\
      fatals++;					\
      quit ();					\
    }						\
  while (0)

#define ERROR(x)				\
  do						\
    {						\
      include_print_where_line (stderr);	\
      fprintf x;				\
      errors++;					\
    }						\
  while (0)

#define WARNING(x)				\
  do						\
    {						\
      include_print_where_line (stderr);	\
      fprintf x;				\
      warnings++;				\
    }						\
  while (0)

/* Exit the program and return the right ERROR code.  */

static void
quit ()
{
  int exitcode;
  if (fatals + errors)
    exitcode = 1;
  else
    exitcode = 0;

  if (stats)
    {
      int i;
      for (i = 0; i < sb_max_power_two; i++)
	{
	  fprintf (stderr, "strings size %8d : %d\n",
		   1 << i, string_count[i]);
	}
    }
  exit (exitcode);
}

/* Hash table maintenance.  */

/* Build a new hash table with size buckets
   and fill in the info at ptr.  */

static void
hash_new_table (size, ptr)
     int size;
     hash_table *ptr;
{
  int i;
  ptr->size = size;
  ptr->table = (hash_entry **) xmalloc (size * (sizeof (hash_entry *)));
  /* Fill with null-pointer, not zero-bit-pattern.  */
  for (i = 0; i < size; i++)
    ptr->table[i] = 0;
}

/* Calculate and return the hash value of the sb at key.  */

static int
hash (key)
     sb *key;
{
  int k = 0x1234;
  int i;
  char *p = key->ptr;
  for (i = 0; i < key->len; i++)
    {
      k ^= (k << 2) ^ *p;
      p++;
    }
  return k & 0xf0fff;
}

/* Look up key in hash_table tab.  If present, then return it,
   otherwise build a new one and fill it with hash_integer.  */

static hash_entry *
hash_create (tab, key)
     hash_table *tab;
     sb *key;
{
  int k = hash (key) % tab->size;
  hash_entry *p;
  hash_entry **table = tab->table;

  p = table[k];

  while (1)
    {
      if (!p)
	{
	  hash_entry *n = (hash_entry *) xmalloc (sizeof (hash_entry));
	  n->next = table[k];
	  sb_new (&n->key);
	  sb_add_sb (&n->key, key);
	  table[k] = n;
	  n->type = hash_integer;
	  return n;
	}
      if (strncmp (table[k]->key.ptr, key->ptr, key->len) == 0)
	{
	  return p;
	}
      p = p->next;
    }
}

/* Add sb name with key into hash_table tab.
   If replacing old value and again, then ERROR.  */

static void
hash_add_to_string_table (tab, key, name, again)
     hash_table *tab;
     sb *key;
     sb *name;
     int again;
{
  hash_entry *ptr = hash_create (tab, key);
  if (ptr->type == hash_integer)
    {
      sb_new (&ptr->value.s);
    }
  if (ptr->value.s.len)
    {
      if (!again)
	ERROR ((stderr, _("redefinition not allowed\n")));
    }

  ptr->type = hash_string;
  sb_reset (&ptr->value.s);

  sb_add_sb (&ptr->value.s, name);
}

/* Add integer name to hash_table tab with sb key.  */

static void
hash_add_to_int_table (tab, key, name)
     hash_table *tab;
     sb *key;
     int name;
{
  hash_entry *ptr = hash_create (tab, key);
  ptr->value.i = name;
}

/* Look up sb key in hash_table tab.
   If found, return hash_entry result, else 0.  */

static hash_entry *
hash_lookup (tab, key)
     hash_table *tab;
     sb *key;
{
  int k = hash (key) % tab->size;
  hash_entry **table = tab->table;
  hash_entry *p = table[k];
  while (p)
    {
      if (p->key.len == key->len
	  && strncmp (p->key.ptr, key->ptr, key->len) == 0)
	return p;
      p = p->next;
    }
  return 0;
}

/* expressions

   are handled in a really simple recursive decent way. each bit of
   the machine takes an index into an sb and a pointer to an exp_t,
   modifies the *exp_t and returns the index of the first character
   past the part of the expression parsed.

 expression precedence:
  ( )
 unary + - ~
  * /
  + -
  &
  | ~
*/

/* Make sure that the exp_t at term is constant.
   If not the give the op ERROR.  */

static void
checkconst (op, term)
     int op;
     exp_t *term;
{
  if (term->add_symbol.len
      || term->sub_symbol.len)
    {
      ERROR ((stderr, _("the %c operator cannot take non-absolute arguments.\n"), op));
    }
}

/* Turn the number in string at idx into a number of base, fill in
   ptr, and return the index of the first character not in the number.  */

static int
sb_strtol (idx, string, base, ptr)
     int idx;
     sb *string;
     int base;
     int *ptr;
{
  int value = 0;
  idx = sb_skip_white (idx, string);

  while (idx < string->len)
    {
      int ch = string->ptr[idx];
      int dig = 0;
      if (isdigit (ch))
	dig = ch - '0';
      else if (ch >= 'a' && ch <= 'f')
	dig = ch - 'a' + 10;
      else if (ch >= 'A' && ch <= 'F')
	dig = ch - 'A' + 10;
      else
	break;

      if (dig >= base)
	break;

      value = value * base + dig;
      idx++;
    }
  *ptr = value;
  return idx;
}

static int
level_0 (idx, string, lhs)
     int idx;
     sb *string;
     exp_t *lhs;
{
  lhs->add_symbol.len = 0;
  lhs->add_symbol.name = 0;

  lhs->sub_symbol.len = 0;
  lhs->sub_symbol.name = 0;

  idx = sb_skip_white (idx, string);

  lhs->value = 0;

  if (isdigit ((unsigned char) string->ptr[idx]))
    {
      idx = sb_strtol (idx, string, 10, &lhs->value);
    }
  else if (ISFIRSTCHAR (string->ptr[idx]))
    {
      int len = 0;
      lhs->add_symbol.name = string->ptr + idx;
      while (idx < string->len && ISNEXTCHAR (string->ptr[idx]))
	{
	  idx++;
	  len++;
	}
      lhs->add_symbol.len = len;
    }
  else if (string->ptr[idx] == '"')
    {
      sb acc;
      sb_new (&acc);
      ERROR ((stderr, _("string where expression expected.\n")));
      idx = getstring (idx, string, &acc);
      sb_kill (&acc);
    }
  else
    {
      ERROR ((stderr, _("can't find primary in expression.\n")));
      idx++;
    }
  return sb_skip_white (idx, string);
}

static int
level_1 (idx, string, lhs)
     int idx;
     sb *string;
     exp_t *lhs;
{
  idx = sb_skip_white (idx, string);

  switch (string->ptr[idx])
    {
    case '+':
      idx = level_1 (idx + 1, string, lhs);
      break;
    case '~':
      idx = level_1 (idx + 1, string, lhs);
      checkconst ('~', lhs);
      lhs->value = ~lhs->value;
      break;
    case '-':
      {
	symbol t;
	idx = level_1 (idx + 1, string, lhs);
	lhs->value = -lhs->value;
	t = lhs->add_symbol;
	lhs->add_symbol = lhs->sub_symbol;
	lhs->sub_symbol = t;
	break;
      }
    case '(':
      idx++;
      idx = level_5 (sb_skip_white (idx, string), string, lhs);
      if (string->ptr[idx] != ')')
	ERROR ((stderr, _("misplaced closing parens.\n")));
      else
	idx++;
      break;
    default:
      idx = level_0 (idx, string, lhs);
      break;
    }
  return sb_skip_white (idx, string);
}

static int
level_2 (idx, string, lhs)
     int idx;
     sb *string;
     exp_t *lhs;
{
  exp_t rhs;

  idx = level_1 (idx, string, lhs);

  while (idx < string->len && (string->ptr[idx] == '*'
			       || string->ptr[idx] == '/'))
    {
      char op = string->ptr[idx++];
      idx = level_1 (idx, string, &rhs);
      switch (op)
	{
	case '*':
	  checkconst ('*', lhs);
	  checkconst ('*', &rhs);
	  lhs->value *= rhs.value;
	  break;
	case '/':
	  checkconst ('/', lhs);
	  checkconst ('/', &rhs);
	  if (rhs.value == 0)
	    ERROR ((stderr, _("attempt to divide by zero.\n")));
	  else
	    lhs->value /= rhs.value;
	  break;
	}
    }
  return sb_skip_white (idx, string);
}

static int
level_3 (idx, string, lhs)
     int idx;
     sb *string;
     exp_t *lhs;
{
  exp_t rhs;

  idx = level_2 (idx, string, lhs);

  while (idx < string->len
	 && (string->ptr[idx] == '+'
	     || string->ptr[idx] == '-'))
    {
      char op = string->ptr[idx++];
      idx = level_2 (idx, string, &rhs);
      switch (op)
	{
	case '+':
	  lhs->value += rhs.value;
	  if (lhs->add_symbol.name && rhs.add_symbol.name)
	    {
	      ERROR ((stderr, _("can't add two relocatable expressions\n")));
	    }
	  /* Change nn+symbol to symbol + nn.  */
	  if (rhs.add_symbol.name)
	    {
	      lhs->add_symbol = rhs.add_symbol;
	    }
	  break;
	case '-':
	  lhs->value -= rhs.value;
	  lhs->sub_symbol = rhs.add_symbol;
	  break;
	}
    }
  return sb_skip_white (idx, string);
}

static int
level_4 (idx, string, lhs)
     int idx;
     sb *string;
     exp_t *lhs;
{
  exp_t rhs;

  idx = level_3 (idx, string, lhs);

  while (idx < string->len &&
	 string->ptr[idx] == '&')
    {
      char op = string->ptr[idx++];
      idx = level_3 (idx, string, &rhs);
      switch (op)
	{
	case '&':
	  checkconst ('&', lhs);
	  checkconst ('&', &rhs);
	  lhs->value &= rhs.value;
	  break;
	}
    }
  return sb_skip_white (idx, string);
}

static int
level_5 (idx, string, lhs)
     int idx;
     sb *string;
     exp_t *lhs;
{
  exp_t rhs;

  idx = level_4 (idx, string, lhs);

  while (idx < string->len
	 && (string->ptr[idx] == '|' || string->ptr[idx] == '~'))
    {
      char op = string->ptr[idx++];
      idx = level_4 (idx, string, &rhs);
      switch (op)
	{
	case '|':
	  checkconst ('|', lhs);
	  checkconst ('|', &rhs);
	  lhs->value |= rhs.value;
	  break;
	case '~':
	  checkconst ('~', lhs);
	  checkconst ('~', &rhs);
	  lhs->value ^= rhs.value;
	  break;
	}
    }
  return sb_skip_white (idx, string);
}

/* Parse the expression at offset idx into string, fill up res with
   the result.  Return the index of the first char past the
   expression.  */

static int
exp_parse (idx, string, res)
     int idx;
     sb *string;
     exp_t *res;
{
  return level_5 (sb_skip_white (idx, string), string, res);
}

/* Turn the expression at exp into text and glue it onto the end of
   string.  */

static void
exp_string (exp, string)
     exp_t *exp;
     sb *string;
{
  int np = 0;
  int ad = 0;
  sb_reset (string);

  if (exp->add_symbol.len)
    {
      sb_add_buffer (string, exp->add_symbol.name, exp->add_symbol.len);
      np = 1;
      ad = 1;
    }
  if (exp->value)
    {
      char buf[20];
      if (np)
	sb_add_char (string, '+');
      sprintf (buf, "%d", exp->value);
      sb_add_string (string, buf);
      np = 1;
      ad = 1;
    }
  if (exp->sub_symbol.len)
    {
      sb_add_char (string, '-');
      sb_add_buffer (string, exp->add_symbol.name, exp->add_symbol.len);
      np = 0;
      ad = 1;
    }

  if (!ad)
    sb_add_char (string, '0');
}

/* Parse the expression at offset idx into sb in.  Return the value in
   val.  If the expression is not constant, give ERROR emsg.  Return
   the index of the first character past the end of the expression.  */

static int
exp_get_abs (emsg, idx, in, val)
     const char *emsg;
     int idx;
     sb *in;
     int *val;
{
  exp_t res;
  idx = exp_parse (idx, in, &res);
  if (res.add_symbol.len || res.sub_symbol.len)
    ERROR ((stderr, "%s", emsg));
  *val = res.value;
  return idx;
}

/* Current label parsed from line.  */
sb label;

/* Hash table for all assigned variables.  */
hash_table assign_hash_table;

/* Hash table for keyword.  */
hash_table keyword_hash_table;

/* Hash table for eq variables.  */
hash_table vars;

#define in_comment ';'

#if 0
static void
strip_comments (out)
     sb *out;
{
  char *s = out->ptr;
  int i = 0;
  for (i = 0; i < out->len; i++)
    {
      if (ISCOMMENTCHAR (s[i]))
	{
	  out->len = i;
	  return;
	}
    }
}
#endif

/* Push back character ch so that it can be read again.  */

static void
unget (ch)
     int ch;
{
  if (ch == '\n')
    {
      sp->linecount--;
    }
  if (sp->pushback_index)
    sp->pushback_index--;
  else
    sb_add_char (&sp->pushback, ch);
}

/* Push the sb ptr onto the include stack, with the given name, type
   and index.  */

static void
include_buf (name, ptr, type, index)
     sb *name;
     sb *ptr;
     include_type type;
     int index;
{
  sp++;
  if (sp - include_stack >= MAX_INCLUDES)
    FATAL ((stderr, _("unreasonable nesting.\n")));
  sb_new (&sp->name);
  sb_add_sb (&sp->name, name);
  sp->handle = 0;
  sp->linecount = 1;
  sp->pushback_index = 0;
  sp->type = type;
  sp->index = index;
  sb_new (&sp->pushback);
  sb_add_sb (&sp->pushback, ptr);
}

/* Used in ERROR messages, print info on where the include stack is
   onto file.  */

static void
include_print_where_line (file)
     FILE *file;
{
  struct include_stack *p = include_stack + 1;

  while (p <= sp)
    {
      fprintf (file, "%s:%d ", sb_name (&p->name), p->linecount - 1);
      p++;
    }
}

/* Used in listings, print the line number onto file.  */

static void
include_print_line (file)
     FILE *file;
{
  int n;
  struct include_stack *p = include_stack + 1;

  n = fprintf (file, "%4d", p->linecount);
  p++;
  while (p <= sp)
    {
      n += fprintf (file, ".%d", p->linecount);
      p++;
    }
  while (n < 8 * 3)
    {
      fprintf (file, " ");
      n++;
    }
}

/* Read a line from the top of the include stack into sb in.  */

static int
get_line (in)
     sb *in;
{
  int online = 0;
  int more = 1;

  if (copysource)
    {
      putc (comment_char, outfile);
      if (print_line_number)
	include_print_line (outfile);
    }

  while (1)
    {
      int ch = get ();

      while (ch == '\r')
	ch = get ();

      if (ch == EOF)
	{
	  if (online)
	    {
	      WARNING ((stderr, _("End of file not at start of line.\n")));
	      if (copysource)
		putc ('\n', outfile);
	      ch = '\n';
	    }
	  else
	    more = 0;
	  break;
	}

      if (copysource)
	{
	  putc (ch, outfile);
	}

      if (ch == '\n')
	{
	  ch = get ();
	  online = 0;
	  if (ch == '+')
	    {
	      /* Continued line.  */
	      if (copysource)
		{
		  putc (comment_char, outfile);
		  putc ('+', outfile);
		}
	      ch = get ();
	    }
	  else
	    {
	      if (ch != EOF)
		unget (ch);
	      break;
	    }
	}
      else
	{
	  sb_add_char (in, ch);
	}
      online++;
    }

  return more;
}

/* Find a label from sb in and put it in out.  */

static int
grab_label (in, out)
     sb *in;
     sb *out;
{
  int i = 0;
  sb_reset (out);
  if (ISFIRSTCHAR (in->ptr[i]) || in->ptr[i] == '\\')
    {
      sb_add_char (out, in->ptr[i]);
      i++;
      while ((ISNEXTCHAR (in->ptr[i])
	      || in->ptr[i] == '\\'
	      || in->ptr[i] == '&')
	     && i < in->len)
	{
	  sb_add_char (out, in->ptr[i]);
	  i++;
	}
    }
  return i;
}

/* Find all strange base stuff and turn into decimal.  Also
   find all the other numbers and convert them from the default radix.  */

static void
change_base (idx, in, out)
     int idx;
     sb *in;
     sb *out;
{
  char buffer[20];

  while (idx < in->len)
    {
      if (in->ptr[idx] == '\\'
	  && idx + 1 < in->len
	  && in->ptr[idx + 1] == '(')
	{
	  idx += 2;
	  while (idx < in->len
		 && in->ptr[idx] != ')')
	    {
	      sb_add_char (out, in->ptr[idx]);
	      idx++;
	    }
	  if (idx < in->len)
	    idx++;
	}
      else if (idx < in->len - 1 && in->ptr[idx + 1] == '\'' && ! mri)
	{
	  int base;
	  int value;
	  switch (in->ptr[idx])
	    {
	    case 'b':
	    case 'B':
	      base = 2;
	      break;
	    case 'q':
	    case 'Q':
	      base = 8;
	      break;
	    case 'h':
	    case 'H':
	      base = 16;
	      break;
	    case 'd':
	    case 'D':
	      base = 10;
	      break;
	    default:
	      ERROR ((stderr, _("Illegal base character %c.\n"), in->ptr[idx]));
	      base = 10;
	      break;
	    }

	  idx = sb_strtol (idx + 2, in, base, &value);
	  sprintf (buffer, "%d", value);
	  sb_add_string (out, buffer);
	}
      else if (ISFIRSTCHAR (in->ptr[idx]))
	{
	  /* Copy entire names through quickly.  */
	  sb_add_char (out, in->ptr[idx]);
	  idx++;
	  while (idx < in->len && ISNEXTCHAR (in->ptr[idx]))
	    {
	      sb_add_char (out, in->ptr[idx]);
	      idx++;
	    }
	}
      else if (isdigit ((unsigned char) in->ptr[idx]))
	{
	  int value;
	  /* All numbers must start with a digit, let's chew it and
	     spit out decimal.  */
	  idx = sb_strtol (idx, in, radix, &value);
	  sprintf (buffer, "%d", value);
	  sb_add_string (out, buffer);

	  /* Skip all undigsested letters.  */
	  while (idx < in->len && ISNEXTCHAR (in->ptr[idx]))
	    {
	      sb_add_char (out, in->ptr[idx]);
	      idx++;
	    }
	}
      else if (in->ptr[idx] == '"' || in->ptr[idx] == '\'')
	{
	  char tchar = in->ptr[idx];
	  /* Copy entire names through quickly.  */
	  sb_add_char (out, in->ptr[idx]);
	  idx++;
	  while (idx < in->len && in->ptr[idx] != tchar)
	    {
	      sb_add_char (out, in->ptr[idx]);
	      idx++;
	    }
	}
      else
	{
	  /* Nothing special, just pass it through.  */
	  sb_add_char (out, in->ptr[idx]);
	  idx++;
	}
    }

}

/* .end  */

static void
do_end (in)
     sb *in;
{
  had_end = 1;
  if (mri)
    fprintf (outfile, "%s\n", sb_name (in));
}

/* .assign  */

static void
do_assign (again, idx, in)
     int again;
     int idx;
     sb *in;
{
  /* Stick label in symbol table with following value.  */
  exp_t e;
  sb acc;

  sb_new (&acc);
  idx = exp_parse (idx, in, &e);
  exp_string (&e, &acc);
  hash_add_to_string_table (&assign_hash_table, &label, &acc, again);
  sb_kill (&acc);
}

/* .radix [b|q|d|h]  */

static void
do_radix (ptr)
     sb *ptr;
{
  int idx = sb_skip_white (0, ptr);
  switch (ptr->ptr[idx])
    {
    case 'B':
    case 'b':
      radix = 2;
      break;
    case 'q':
    case 'Q':
      radix = 8;
      break;
    case 'd':
    case 'D':
      radix = 10;
      break;
    case 'h':
    case 'H':
      radix = 16;
      break;
    default:
      ERROR ((stderr, _("radix is %c must be one of b, q, d or h"), radix));
    }
}

/* Parse off a .b, .w or .l.  */

static int
get_opsize (idx, in, size)
     int idx;
     sb *in;
     int *size;
{
  *size = 4;
  if (in->ptr[idx] == '.')
    {
      idx++;
    }
  switch (in->ptr[idx])
    {
    case 'b':
    case 'B':
      *size = 1;
      break;
    case 'w':
    case 'W':
      *size = 2;
      break;
    case 'l':
    case 'L':
      *size = 4;
      break;
    case ' ':
    case '\t':
      break;
    default:
      ERROR ((stderr, _("size must be one of b, w or l, is %c.\n"), in->ptr[idx]));
      break;
    }
  idx++;

  return idx;
}

static int
eol (idx, line)
     int idx;
     sb *line;
{
  idx = sb_skip_white (idx, line);
  if (idx < line->len
      && ISCOMMENTCHAR(line->ptr[idx]))
    return 1;
  if (idx >= line->len)
    return 1;
  return 0;
}

/* .data [.b|.w|.l] <data>*
    or d[bwl] <data>*  */

static void
do_data (idx, in, size)
     int idx;
     sb *in;
     int size;
{
  int opsize = 4;
  char *opname = ".yikes!";
  sb acc;
  sb_new (&acc);

  if (!size)
    {
      idx = get_opsize (idx, in, &opsize);
    }
  else
    {
      opsize = size;
    }
  switch (opsize)
    {
    case 4:
      opname = ".long";
      break;
    case 2:
      opname = ".short";
      break;
    case 1:
      opname = ".byte";
      break;
    }

  fprintf (outfile, "%s\t", opname);

  idx = sb_skip_white (idx, in);

  if (alternate
      && idx < in->len
      && in->ptr[idx] == '"')
    {
      int i;
      idx = getstring (idx, in, &acc);
      for (i = 0; i < acc.len; i++)
	{
	  if (i)
	    fprintf (outfile, ",");
	  fprintf (outfile, "%d", acc.ptr[i]);
	}
    }
  else
    {
      while (!eol (idx, in))
	{
	  exp_t e;
	  idx = exp_parse (idx, in, &e);
	  exp_string (&e, &acc);
	  sb_add_char (&acc, 0);
	  fprintf (outfile, "%s", acc.ptr);
	  if (idx < in->len && in->ptr[idx] == ',')
	    {
	      fprintf (outfile, ",");
	      idx++;
	    }
	}
    }
  sb_kill (&acc);
  sb_print_at (outfile, idx, in);
  fprintf (outfile, "\n");
}

/* .datab [.b|.w|.l] <repeat>,<fill>  */

static void
do_datab (idx, in)
     int idx;
     sb *in;
{
  int opsize;
  int repeat;
  int fill;

  idx = get_opsize (idx, in, &opsize);

  idx = exp_get_abs (_("datab repeat must be constant.\n"), idx, in, &repeat);
  idx = sb_skip_comma (idx, in);
  idx = exp_get_abs (_("datab data must be absolute.\n"), idx, in, &fill);

  fprintf (outfile, ".fill\t%d,%d,%d\n", repeat, opsize, fill);
}

/* .align <size>  */

static void
do_align (idx, in)
     int idx;
     sb *in;
{
  int al, have_fill, fill;

  idx = exp_get_abs (_("align needs absolute expression.\n"), idx, in, &al);
  idx = sb_skip_white (idx, in);
  have_fill = 0;
  fill = 0;
  if (! eol (idx, in))
    {
      idx = sb_skip_comma (idx, in);
      idx = exp_get_abs (_(".align needs absolute fill value.\n"), idx, in,
			 &fill);
      have_fill = 1;
    }

  fprintf (outfile, ".align	%d", al);
  if (have_fill)
    fprintf (outfile, ",%d", fill);
  fprintf (outfile, "\n");
}

/* .res[.b|.w|.l] <size>  */

static void
do_res (idx, in, type)
     int idx;
     sb *in;
     int type;
{
  int size = 4;
  int count = 0;

  idx = get_opsize (idx, in, &size);
  while (!eol (idx, in))
    {
      idx = sb_skip_white (idx, in);
      if (in->ptr[idx] == ',')
	idx++;
      idx = exp_get_abs (_("res needs absolute expression for fill count.\n"), idx, in, &count);

      if (type == 'c' || type == 'z')
	count++;

      fprintf (outfile, ".space	%d\n", count * size);
    }
}

/* .export  */

static void
do_export (in)
     sb *in;
{
  fprintf (outfile, ".global	%s\n", sb_name (in));
}

/* .print [list] [nolist]  */

static void
do_print (idx, in)
     int idx;
     sb *in;
{
  idx = sb_skip_white (idx, in);
  while (idx < in->len)
    {
      if (strncasecmp (in->ptr + idx, "LIST", 4) == 0)
	{
	  fprintf (outfile, ".list\n");
	  idx += 4;
	}
      else if (strncasecmp (in->ptr + idx, "NOLIST", 6) == 0)
	{
	  fprintf (outfile, ".nolist\n");
	  idx += 6;
	}
      idx++;
    }
}

/* .head  */

static void
do_heading (idx, in)
     int idx;
     sb *in;
{
  sb head;
  sb_new (&head);
  idx = getstring (idx, in, &head);
  fprintf (outfile, ".title	\"%s\"\n", sb_name (&head));
  sb_kill (&head);
}

/* .page  */

static void
do_page ()
{
  fprintf (outfile, ".eject\n");
}

/* .form [lin=<value>] [col=<value>]  */

static void
do_form (idx, in)
     int idx;
     sb *in;
{
  int lines = 60;
  int columns = 132;
  idx = sb_skip_white (idx, in);

  while (idx < in->len)
    {

      if (strncasecmp (in->ptr + idx, "LIN=", 4) == 0)
	{
	  idx += 4;
	  idx = exp_get_abs (_("form LIN= needs absolute expresssion.\n"), idx, in, &lines);
	}

      if (strncasecmp (in->ptr + idx, _("COL="), 4) == 0)
	{
	  idx += 4;
	  idx = exp_get_abs (_("form COL= needs absolute expresssion.\n"), idx, in, &columns);
	}

      idx++;
    }
  fprintf (outfile, ".psize %d,%d\n", lines, columns);

}

/* Fetch string from the input stream,
   rules:
    'Bxyx<whitespace>  	-> return 'Bxyza
    %<char>		-> return string of decimal value of x
    "<string>"		-> return string
    xyx<whitespace>     -> return xyz
*/

static int
get_any_string (idx, in, out, expand, pretend_quoted)
     int idx;
     sb *in;
     sb *out;
     int expand;
     int pretend_quoted;
{
  sb_reset (out);
  idx = sb_skip_white (idx, in);

  if (idx < in->len)
    {
      if (in->len > 2 && in->ptr[idx + 1] == '\'' && ISBASE (in->ptr[idx]))
	{
	  while (!ISSEP (in->ptr[idx]))
	    sb_add_char (out, in->ptr[idx++]);
	}
      else if (in->ptr[idx] == '%'
	       && alternate
	       && expand)
	{
	  int val;
	  char buf[20];
	  /* Turns the next expression into a string.  */
	  idx = exp_get_abs (_("% operator needs absolute expression"),
			     idx + 1,
			     in,
			     &val);
	  sprintf (buf, "%d", val);
	  sb_add_string (out, buf);
	}
      else if (in->ptr[idx] == '"'
	       || in->ptr[idx] == '<'
	       || (alternate && in->ptr[idx] == '\''))
	{
	  if (alternate && expand)
	    {
	      /* Keep the quotes.  */
	      sb_add_char (out, '\"');

	      idx = getstring (idx, in, out);
	      sb_add_char (out, '\"');

	    }
	  else
	    {
	      idx = getstring (idx, in, out);
	    }
	}
      else
	{
	  while (idx < in->len
		 && (in->ptr[idx] == '"'
		     || in->ptr[idx] == '\''
		     || pretend_quoted
		     || !ISSEP (in->ptr[idx])))
	    {
	      if (in->ptr[idx] == '"'
		  || in->ptr[idx] == '\'')
		{
		  char tchar = in->ptr[idx];
		  sb_add_char (out, in->ptr[idx++]);
		  while (idx < in->len
			 && in->ptr[idx] != tchar)
		    sb_add_char (out, in->ptr[idx++]);
		  if (idx == in->len)
		    return idx;
		}
	      sb_add_char (out, in->ptr[idx++]);
	    }
	}
    }

  return idx;
}

/* Skip along sb in starting at idx, suck off whitespace a ( and more
   whitespace.  Return the idx of the next char.  */

static int
skip_openp (idx, in)
     int idx;
     sb *in;
{
  idx = sb_skip_white (idx, in);
  if (in->ptr[idx] != '(')
    ERROR ((stderr, _("misplaced ( .\n")));
  idx = sb_skip_white (idx + 1, in);
  return idx;
}

/* Skip along sb in starting at idx, suck off whitespace a ) and more
   whitespace.  Return the idx of the next char.  */

static int
skip_closep (idx, in)
     int idx;
     sb *in;
{
  idx = sb_skip_white (idx, in);
  if (in->ptr[idx] != ')')
    ERROR ((stderr, _("misplaced ).\n")));
  idx = sb_skip_white (idx + 1, in);
  return idx;
}

/* .len  */

static int
dolen (idx, in, out)
     int idx;
     sb *in;
     sb *out;
{

  sb stringout;
  char buffer[10];

  sb_new (&stringout);
  idx = skip_openp (idx, in);
  idx = get_and_process (idx, in, &stringout);
  idx = skip_closep (idx, in);
  sprintf (buffer, "%d", stringout.len);
  sb_add_string (out, buffer);

  sb_kill (&stringout);
  return idx;
}

/* .instr  */

static int
doinstr (idx, in, out)
     int idx;
     sb *in;
     sb *out;
{
  sb string;
  sb search;
  int i;
  int start;
  int res;
  char buffer[10];

  sb_new (&string);
  sb_new (&search);
  idx = skip_openp (idx, in);
  idx = get_and_process (idx, in, &string);
  idx = sb_skip_comma (idx, in);
  idx = get_and_process (idx, in, &search);
  idx = sb_skip_comma (idx, in);
  if (isdigit ((unsigned char) in->ptr[idx]))
    {
      idx = exp_get_abs (_(".instr needs absolute expresson.\n"), idx, in, &start);
    }
  else
    {
      start = 0;
    }
  idx = skip_closep (idx, in);
  res = -1;
  for (i = start; i < string.len; i++)
    {
      if (strncmp (string.ptr + i, search.ptr, search.len) == 0)
	{
	  res = i;
	  break;
	}
    }
  sprintf (buffer, "%d", res);
  sb_add_string (out, buffer);
  sb_kill (&string);
  sb_kill (&search);
  return idx;
}

static int
dosubstr (idx, in, out)
     int idx;
     sb *in;
     sb *out;
{
  sb string;
  int pos;
  int len;
  sb_new (&string);

  idx = skip_openp (idx, in);
  idx = get_and_process (idx, in, &string);
  idx = sb_skip_comma (idx, in);
  idx = exp_get_abs (_("need absolute position.\n"), idx, in, &pos);
  idx = sb_skip_comma (idx, in);
  idx = exp_get_abs (_("need absolute length.\n"), idx, in, &len);
  idx = skip_closep (idx, in);

  if (len < 0 || pos < 0 ||
      pos > string.len
      || pos + len > string.len)
    {
      sb_add_string (out, " ");
    }
  else
    {
      sb_add_char (out, '"');
      while (len > 0)
	{
	  sb_add_char (out, string.ptr[pos++]);
	  len--;
	}
      sb_add_char (out, '"');
    }
  sb_kill (&string);
  return idx;
}

/* Scan line, change tokens in the hash table to their replacements.  */

static void
process_assigns (idx, in, buf)
     int idx;
     sb *in;
     sb *buf;
{
  while (idx < in->len)
    {
      hash_entry *ptr;
      if (in->ptr[idx] == '\\'
	  && idx + 1 < in->len
	  && in->ptr[idx + 1] == '(')
	{
	  do
	    {
	      sb_add_char (buf, in->ptr[idx]);
	      idx++;
	    }
	  while (idx < in->len && in->ptr[idx - 1] != ')');
	}
      else if (in->ptr[idx] == '\\'
	  && idx + 1 < in->len
	  && in->ptr[idx + 1] == '&')
	{
	  idx = condass_lookup_name (in, idx + 2, buf, 1);
	}
      else if (in->ptr[idx] == '\\'
	       && idx + 1 < in->len
	       && in->ptr[idx + 1] == '$')
	{
	  idx = condass_lookup_name (in, idx + 2, buf, 0);
	}
      else if (idx + 3 < in->len
	       && in->ptr[idx] == '.'
	       && toupper ((unsigned char) in->ptr[idx + 1]) == 'L'
	       && toupper ((unsigned char) in->ptr[idx + 2]) == 'E'
	       && toupper ((unsigned char) in->ptr[idx + 3]) == 'N')
	idx = dolen (idx + 4, in, buf);
      else if (idx + 6 < in->len
	       && in->ptr[idx] == '.'
	       && toupper ((unsigned char) in->ptr[idx + 1]) == 'I'
	       && toupper ((unsigned char) in->ptr[idx + 2]) == 'N'
	       && toupper ((unsigned char) in->ptr[idx + 3]) == 'S'
	       && toupper ((unsigned char) in->ptr[idx + 4]) == 'T'
	       && toupper ((unsigned char) in->ptr[idx + 5]) == 'R')
	idx = doinstr (idx + 6, in, buf);
      else if (idx + 7 < in->len
	       && in->ptr[idx] == '.'
	       && toupper ((unsigned char) in->ptr[idx + 1]) == 'S'
	       && toupper ((unsigned char) in->ptr[idx + 2]) == 'U'
	       && toupper ((unsigned char) in->ptr[idx + 3]) == 'B'
	       && toupper ((unsigned char) in->ptr[idx + 4]) == 'S'
	       && toupper ((unsigned char) in->ptr[idx + 5]) == 'T'
	       && toupper ((unsigned char) in->ptr[idx + 6]) == 'R')
	idx = dosubstr (idx + 7, in, buf);
      else if (ISFIRSTCHAR (in->ptr[idx]))
	{
	  /* May be a simple name subsitution, see if we have a word.  */
	  sb acc;
	  int cur = idx + 1;
	  while (cur < in->len
		 && (ISNEXTCHAR (in->ptr[cur])))
	    cur++;

	  sb_new (&acc);
	  sb_add_buffer (&acc, in->ptr + idx, cur - idx);
	  ptr = hash_lookup (&assign_hash_table, &acc);
	  if (ptr)
	    {
	      /* Found a definition for it.  */
	      sb_add_sb (buf, &ptr->value.s);
	    }
	  else
	    {
	      /* No definition, just copy the word.  */
	      sb_add_sb (buf, &acc);
	    }
	  sb_kill (&acc);
	  idx = cur;
	}
      else
	{
	  sb_add_char (buf, in->ptr[idx++]);
	}
    }
}

static int
get_and_process (idx, in, out)
     int idx;
     sb *in;
     sb *out;
{
  sb t;
  sb_new (&t);
  idx = get_any_string (idx, in, &t, 1, 0);
  process_assigns (0, &t, out);
  sb_kill (&t);
  return idx;
}

static void
process_file ()
{
  sb line;
  sb t1, t2;
  sb acc;
  sb label_in;
  int more;

  sb_new (&line);
  sb_new (&t1);
  sb_new (&t2);
  sb_new (&acc);
  sb_new (&label_in);
  sb_reset (&line);
  more = get_line (&line);
  while (more)
    {
      /* Find any label and pseudo op that we're intested in.  */
      int l;
      if (line.len == 0)
	{
	  if (condass_on ())
	    fprintf (outfile, "\n");
	}
      else if (mri
	       && (line.ptr[0] == '*'
		   || line.ptr[0] == '!'))
	{
	  /* MRI line comment.  */
	  fprintf (outfile, "%s", sb_name (&line));
	}
      else
	{
	  l = grab_label (&line, &label_in);
	  sb_reset (&label);

	  if (line.ptr[l] == ':')
	    l++;
	  while (ISWHITE (line.ptr[l]) && l < line.len)
	    l++;

	  if (label_in.len)
	    {
	      int do_assigns;

	      /* Munge the label, unless this is EQU or ASSIGN.  */
	      do_assigns = 1;
	      if (l < line.len
		  && (line.ptr[l] == '.' || alternate || mri))
		{
		  int lx = l;

		  if (line.ptr[lx] == '.')
		    ++lx;
		  if (lx + 3 <= line.len
		      && strncasecmp ("EQU", line.ptr + lx, 3) == 0
		      && (lx + 3 == line.len
			  || ! ISFIRSTCHAR (line.ptr[lx + 3])))
		    do_assigns = 0;
		  else if (lx + 6 <= line.len
			   && strncasecmp ("ASSIGN", line.ptr + lx, 6) == 0
			   && (lx + 6 == line.len
			       || ! ISFIRSTCHAR (line.ptr[lx + 6])))
		    do_assigns = 0;
		}

	      if (do_assigns)
		process_assigns (0, &label_in, &label);
	      else
		sb_add_sb (&label, &label_in);
	    }

	  if (l < line.len)
	    {
	      if (process_pseudo_op (l, &line, &acc))
		{

		}
	      else if (condass_on ())
		{
		  if (macro_op (l, &line))
		    {

		    }
		  else
		    {
		      {
			if (label.len)
			  {
			    fprintf (outfile, "%s:\t", sb_name (&label));
			  }
			else
			  fprintf (outfile, "\t");
			sb_reset (&t1);
			process_assigns (l, &line, &t1);
			sb_reset (&t2);
			change_base (0, &t1, &t2);
			fprintf (outfile, "%s\n", sb_name (&t2));
		      }
		    }
		}
	    }
	  else
	    {
	      /* Only a label on this line.  */
	      if (label.len && condass_on ())
		{
		  fprintf (outfile, "%s:\n", sb_name (&label));
		}
	    }
	}

      if (had_end)
	break;
      sb_reset (&line);
      more = get_line (&line);
    }

  if (!had_end && !mri)
    WARNING ((stderr, _("END missing from end of file.\n")));
}

static void
free_old_entry (ptr)
     hash_entry *ptr;
{
  if (ptr)
    {
      if (ptr->type == hash_string)
	sb_kill (&ptr->value.s);
    }
}

/* name: .ASSIGNA <value>  */

static void
do_assigna (idx, in)
     int idx;
     sb *in;
{
  sb tmp;
  int val;
  sb_new (&tmp);

  process_assigns (idx, in, &tmp);
  idx = exp_get_abs (_(".ASSIGNA needs constant expression argument.\n"), 0, &tmp, &val);

  if (!label.len)
    {
      ERROR ((stderr, _(".ASSIGNA without label.\n")));
    }
  else
    {
      hash_entry *ptr = hash_create (&vars, &label);
      free_old_entry (ptr);
      ptr->type = hash_integer;
      ptr->value.i = val;
    }
  sb_kill (&tmp);
}

/* name: .ASSIGNC <string>  */

static void
do_assignc (idx, in)
     int idx;
     sb *in;
{
  sb acc;
  sb_new (&acc);
  idx = getstring (idx, in, &acc);

  if (!label.len)
    {
      ERROR ((stderr, _(".ASSIGNS without label.\n")));
    }
  else
    {
      hash_entry *ptr = hash_create (&vars, &label);
      free_old_entry (ptr);
      ptr->type = hash_string;
      sb_new (&ptr->value.s);
      sb_add_sb (&ptr->value.s, &acc);
    }
  sb_kill (&acc);
}

/* name: .REG (reg)  */

static void
do_reg (idx, in)
     int idx;
     sb *in;
{
  /* Remove reg stuff from inside parens.  */
  sb what;
  if (!mri)
    idx = skip_openp (idx, in);
  else
    idx = sb_skip_white (idx, in);
  sb_new (&what);
  while (idx < in->len
	 && (mri
	     ? ! eol (idx, in)
	     : in->ptr[idx] != ')'))
    {
      sb_add_char (&what, in->ptr[idx]);
      idx++;
    }
  hash_add_to_string_table (&assign_hash_table, &label, &what, 1);
  sb_kill (&what);
}

static int
condass_lookup_name (inbuf, idx, out, warn)
     sb *inbuf;
     int idx;
     sb *out;
     int warn;
{
  hash_entry *ptr;
  sb condass_acc;
  sb_new (&condass_acc);

  while (idx < inbuf->len
	 && ISNEXTCHAR (inbuf->ptr[idx]))
    {
      sb_add_char (&condass_acc, inbuf->ptr[idx++]);
    }

  if (inbuf->ptr[idx] == '\'')
    idx++;
  ptr = hash_lookup (&vars, &condass_acc);

  if (!ptr)
    {
      if (warn)
	{
	  WARNING ((stderr, _("Can't find preprocessor variable %s.\n"), sb_name (&condass_acc)));
	}
      else
	{
	  sb_add_string (out, "0");
	}
    }
  else
    {
      if (ptr->type == hash_integer)
	{
	  char buffer[30];
	  sprintf (buffer, "%d", ptr->value.i);
	  sb_add_string (out, buffer);
	}
      else
	{
	  sb_add_sb (out, &ptr->value.s);
	}
    }
  sb_kill (&condass_acc);
  return idx;
}

#define EQ 1
#define NE 2
#define GE 3
#define LT 4
#define LE 5
#define GT 6
#define NEVER 7

static int
whatcond (idx, in, val)
     int idx;
     sb *in;
     int *val;
{
  int cond;

  idx = sb_skip_white (idx, in);
  cond = NEVER;
  if (idx + 1 < in->len)
    {
      char *p;
      char a, b;

      p = in->ptr + idx;
      a = toupper ((unsigned char) p[0]);
      b = toupper ((unsigned char) p[1]);
      if (a == 'E' && b == 'Q')
	cond = EQ;
      else if (a == 'N' && b == 'E')
	cond = NE;
      else if (a == 'L' && b == 'T')
	cond = LT;
      else if (a == 'L' && b == 'E')
	cond = LE;
      else if (a == 'G' && b == 'T')
	cond = GT;
      else if (a == 'G' && b == 'E')
	cond = GE;
    }
  if (cond == NEVER)
    {
      ERROR ((stderr, _("Comparison operator must be one of EQ, NE, LT, LE, GT or GE.\n")));
      cond = NEVER;
    }
  idx = sb_skip_white (idx + 2, in);
  *val = cond;
  return idx;
}

static int
istrue (idx, in)
     int idx;
     sb *in;
{
  int res;
  sb acc_a;
  sb cond;
  sb acc_b;
  sb_new (&acc_a);
  sb_new (&cond);
  sb_new (&acc_b);
  idx = sb_skip_white (idx, in);

  if (in->ptr[idx] == '"')
    {
      int cond;
      int same;
      /* This is a string comparision.  */
      idx = getstring (idx, in, &acc_a);
      idx = whatcond (idx, in, &cond);
      idx = getstring (idx, in, &acc_b);
      same = acc_a.len == acc_b.len
	&& (strncmp (acc_a.ptr, acc_b.ptr, acc_a.len) == 0);

      if (cond != EQ && cond != NE)
	{
	  ERROR ((stderr, _("Comparison operator for strings must be EQ or NE\n")));
	  res = 0;
	}
      else
	res = (cond != EQ) ^ same;
    }
  else
    /* This is a numeric expression.  */
    {
      int vala;
      int valb;
      int cond;
      idx = exp_get_abs (_("Conditional operator must have absolute operands.\n"), idx, in, &vala);
      idx = whatcond (idx, in, &cond);
      idx = sb_skip_white (idx, in);
      if (in->ptr[idx] == '"')
	{
	  WARNING ((stderr, _("String compared against expression.\n")));
	  res = 0;
	}
      else
	{
	  idx = exp_get_abs (_("Conditional operator must have absolute operands.\n"), idx, in, &valb);
	  switch (cond)
	    {
	    default:
	      res = 42;
	      break;
	    case EQ:
	      res = vala == valb;
	      break;
	    case NE:
	      res = vala != valb;
	      break;
	    case LT:
	      res = vala < valb;
	      break;
	    case LE:
	      res = vala <= valb;
	      break;
	    case GT:
	      res = vala > valb;
	      break;
	    case GE:
	      res = vala >= valb;
	      break;
	    case NEVER:
	      res = 0;
	      break;
	    }
	}
    }

  sb_kill (&acc_a);
  sb_kill (&cond);
  sb_kill (&acc_b);
  return res;
}

/* .AIF  */

static void
do_aif (idx, in)
     int idx;
     sb *in;
{
  if (ifi >= IFNESTING)
    {
      FATAL ((stderr, _("AIF nesting unreasonable.\n")));
    }
  ifi++;
  ifstack[ifi].on = ifstack[ifi - 1].on ? istrue (idx, in) : 0;
  ifstack[ifi].hadelse = 0;
}

/* .AELSE  */

static void
do_aelse ()
{
  ifstack[ifi].on = ifstack[ifi - 1].on ? !ifstack[ifi].on : 0;
  if (ifstack[ifi].hadelse)
    {
      ERROR ((stderr, _("Multiple AELSEs in AIF.\n")));
    }
  ifstack[ifi].hadelse = 1;
}

/* .AENDI  */

static void
do_aendi ()
{
  if (ifi != 0)
    {
      ifi--;
    }
  else
    {
      ERROR ((stderr, _("AENDI without AIF.\n")));
    }
}

static int
condass_on ()
{
  return ifstack[ifi].on;
}

/* MRI IFEQ, IFNE, IFLT, IFLE, IFGE, IFGT.  */

static void
do_if (idx, in, cond)
     int idx;
     sb *in;
     int cond;
{
  int val;
  int res;

  if (ifi >= IFNESTING)
    {
      FATAL ((stderr, _("IF nesting unreasonable.\n")));
    }

  idx = exp_get_abs (_("Conditional operator must have absolute operands.\n"),
		     idx, in, &val);
  switch (cond)
    {
    default:
    case EQ: res = val == 0; break;
    case NE: res = val != 0; break;
    case LT: res = val <  0; break;
    case LE: res = val <= 0; break;
    case GE: res = val >= 0; break;
    case GT: res = val >  0; break;
    }

  ifi++;
  ifstack[ifi].on = ifstack[ifi - 1].on ? res : 0;
  ifstack[ifi].hadelse = 0;
}

/* Get a string for the MRI IFC or IFNC pseudo-ops.  */

static int
get_mri_string (idx, in, val, terminator)
     int idx;
     sb *in;
     sb *val;
     int terminator;
{
  idx = sb_skip_white (idx, in);

  if (idx < in->len
      && in->ptr[idx] == '\'')
    {
      sb_add_char (val, '\'');
      for (++idx; idx < in->len; ++idx)
	{
	  sb_add_char (val, in->ptr[idx]);
	  if (in->ptr[idx] == '\'')
	    {
	      ++idx;
	      if (idx >= in->len
		  || in->ptr[idx] != '\'')
		break;
	    }
	}
      idx = sb_skip_white (idx, in);
    }
  else
    {
      int i;

      while (idx < in->len
	     && in->ptr[idx] != terminator)
	{
	  sb_add_char (val, in->ptr[idx]);
	  ++idx;
	}
      i = val->len - 1;
      while (i >= 0 && ISWHITE (val->ptr[i]))
	--i;
      val->len = i + 1;
    }

  return idx;
}

/* MRI IFC, IFNC  */

static void
do_ifc (idx, in, ifnc)
     int idx;
     sb *in;
     int ifnc;
{
  sb first;
  sb second;
  int res;

  if (ifi >= IFNESTING)
    {
      FATAL ((stderr, _("IF nesting unreasonable.\n")));
    }

  sb_new (&first);
  sb_new (&second);

  idx = get_mri_string (idx, in, &first, ',');

  if (idx >= in->len || in->ptr[idx] != ',')
    {
      ERROR ((stderr, _("Bad format for IF or IFNC.\n")));
      return;
    }

  idx = get_mri_string (idx + 1, in, &second, ';');

  res = (first.len == second.len
	 && strncmp (first.ptr, second.ptr, first.len) == 0);
  res ^= ifnc;

  ifi++;
  ifstack[ifi].on = ifstack[ifi - 1].on ? res : 0;
  ifstack[ifi].hadelse = 0;
}

/* .ENDR  */

static void
do_aendr ()
{
  if (!mri)
    ERROR ((stderr, _("AENDR without a AREPEAT.\n")));
  else
    ERROR ((stderr, _("ENDR without a REPT.\n")));
}

/* .AWHILE  */

static void
do_awhile (idx, in)
     int idx;
     sb *in;
{
  int line = linecount ();
  sb exp;
  sb sub;
  int doit;

  sb_new (&sub);
  sb_new (&exp);

  process_assigns (idx, in, &exp);
  doit = istrue (0, &exp);

  if (! buffer_and_nest ("AWHILE", "AENDW", &sub, get_line))
    FATAL ((stderr, _("AWHILE without a AENDW at %d.\n"), line - 1));

  /* Turn
     	.AWHILE exp
	     foo
	.AENDW
     into
        foo
	.AWHILE exp
	foo
	.ENDW
  */

  if (doit)
    {
      int index = include_next_index ();

      sb copy;
      sb_new (&copy);
      sb_add_sb (&copy, &sub);
      sb_add_sb (&copy, in);
      sb_add_string (&copy, "\n");
      sb_add_sb (&copy, &sub);
      sb_add_string (&copy, "\t.AENDW\n");
      /* Push another WHILE.  */
      include_buf (&exp, &copy, include_while, index);
      sb_kill (&copy);
    }
  sb_kill (&exp);
  sb_kill (&sub);
}

/* .AENDW  */

static void
do_aendw ()
{
  ERROR ((stderr, _("AENDW without a AENDW.\n")));
}

/* .EXITM

   Pop things off the include stack until the type and index changes.  */

static void
do_exitm ()
{
  include_type type = sp->type;
  if (type == include_repeat
      || type == include_while
      || type == include_macro)
    {
      int index = sp->index;
      include_pop ();
      while (sp->index == index
	     && sp->type == type)
	{
	  include_pop ();
	}
    }
}

/* .AREPEAT  */

static void
do_arepeat (idx, in)
     int idx;
     sb *in;
{
  int line = linecount ();
  sb exp;			/* Buffer with expression in it.  */
  sb copy;			/* Expanded repeat block.  */
  sb sub;			/* Contents of AREPEAT.  */
  int rc;
  int ret;
  char buffer[30];

  sb_new (&exp);
  sb_new (&copy);
  sb_new (&sub);
  process_assigns (idx, in, &exp);
  idx = exp_get_abs (_("AREPEAT must have absolute operand.\n"), 0, &exp, &rc);
  if (!mri)
    ret = buffer_and_nest ("AREPEAT", "AENDR", &sub, get_line);
  else
    ret = buffer_and_nest ("REPT", "ENDR", &sub, get_line);
  if (! ret)
    FATAL ((stderr, _("AREPEAT without a AENDR at %d.\n"), line - 1));
  if (rc > 0)
    {
      /* Push back the text following the repeat, and another repeat block
	 so
	 .AREPEAT 20
	 foo
	 .AENDR
	 gets turned into
	 foo
	 .AREPEAT 19
	 foo
	 .AENDR
      */
      int index = include_next_index ();
      sb_add_sb (&copy, &sub);
      if (rc > 1)
	{
	  if (!mri)
	    sprintf (buffer, "\t.AREPEAT	%d\n", rc - 1);
	  else
	    sprintf (buffer, "\tREPT	%d\n", rc - 1);
	  sb_add_string (&copy, buffer);
	  sb_add_sb (&copy, &sub);
	  if (!mri)
	    sb_add_string (&copy, "	.AENDR\n");
	  else
	    sb_add_string (&copy, "	ENDR\n");
	}

      include_buf (&exp, &copy, include_repeat, index);
    }
  sb_kill (&exp);
  sb_kill (&sub);
  sb_kill (&copy);
}

/* .ENDM  */

static void
do_endm ()
{
  ERROR ((stderr, _(".ENDM without a matching .MACRO.\n")));
}

/* MRI IRP pseudo-op.  */

static void
do_irp (idx, in, irpc)
     int idx;
     sb *in;
     int irpc;
{
  const char *err;
  sb out;

  sb_new (&out);

  err = expand_irp (irpc, idx, in, &out, get_line, comment_char);
  if (err != NULL)
    ERROR ((stderr, "%s\n", err));

  fprintf (outfile, "%s", sb_terminate (&out));

  sb_kill (&out);
}

/* Macro processing.  */

/* Parse off LOCAL n1, n2,... Invent a label name for it.  */

static void
do_local (idx, line)
     int idx ATTRIBUTE_UNUSED;
     sb *line ATTRIBUTE_UNUSED;
{
  ERROR ((stderr, _("LOCAL outside of MACRO")));
}

static void
do_macro (idx, in)
     int idx;
     sb *in;
{
  const char *err;
  int line = linecount ();

  err = define_macro (idx, in, &label, get_line, (const char **) NULL);
  if (err != NULL)
    ERROR ((stderr, _("macro at line %d: %s\n"), line - 1, err));
}

static int
macro_op (idx, in)
     int idx;
     sb *in;
{
  const char *err;
  sb out;
  sb name;

  if (! macro_defined)
    return 0;

  sb_terminate (in);
  if (! check_macro (in->ptr + idx, &out, comment_char, &err, NULL))
    return 0;

  if (err != NULL)
    ERROR ((stderr, "%s\n", err));

  sb_new (&name);
  sb_add_string (&name, _("macro expansion"));

  include_buf (&name, &out, include_macro, include_next_index ());

  sb_kill (&name);
  sb_kill (&out);

  return 1;
}

/* String handling.  */

static int
getstring (idx, in, acc)
     int idx;
     sb *in;
     sb *acc;
{
  idx = sb_skip_white (idx, in);

  while (idx < in->len
	 && (in->ptr[idx] == '"'
	     || in->ptr[idx] == '<'
	     || (in->ptr[idx] == '\'' && alternate)))
    {
      if (in->ptr[idx] == '<')
	{
	  if (alternate || mri)
	    {
	      int nest = 0;
	      idx++;
	      while ((in->ptr[idx] != '>' || nest)
		     && idx < in->len)
		{
		  if (in->ptr[idx] == '!')
		    {
		      idx++;
		      sb_add_char (acc, in->ptr[idx++]);
		    }
		  else
		    {
		      if (in->ptr[idx] == '>')
			nest--;
		      if (in->ptr[idx] == '<')
			nest++;
		      sb_add_char (acc, in->ptr[idx++]);
		    }
		}
	      idx++;
	    }
	  else
	    {
	      int code;
	      idx++;
	      idx = exp_get_abs (_("Character code in string must be absolute expression.\n"),
				 idx, in, &code);
	      sb_add_char (acc, code);

	      if (in->ptr[idx] != '>')
		ERROR ((stderr, _("Missing > for character code.\n")));
	      idx++;
	    }
	}
      else if (in->ptr[idx] == '"' || in->ptr[idx] == '\'')
	{
	  char tchar = in->ptr[idx];
	  idx++;
	  while (idx < in->len)
	    {
	      if (alternate && in->ptr[idx] == '!')
		{
		  idx++;
		  sb_add_char (acc, in->ptr[idx++]);
		}
	      else
		{
		  if (in->ptr[idx] == tchar)
		    {
		      idx++;
		      if (idx >= in->len || in->ptr[idx] != tchar)
			break;
		    }
		  sb_add_char (acc, in->ptr[idx]);
		  idx++;
		}
	    }
	}
    }

  return idx;
}

/* .SDATA[C|Z] <string>  */

static void
do_sdata (idx, in, type)
     int idx;
     sb *in;
     int type;
{
  int nc = 0;
  int pidx = -1;
  sb acc;
  sb_new (&acc);
  fprintf (outfile, ".byte\t");

  while (!eol (idx, in))
    {
      int i;
      sb_reset (&acc);
      idx = sb_skip_white (idx, in);
      while (!eol (idx, in))
	{
	  pidx = idx = get_any_string (idx, in, &acc, 0, 1);
	  if (type == 'c')
	    {
	      if (acc.len > 255)
		{
		  ERROR ((stderr, _("string for SDATAC longer than 255 characters (%d).\n"), acc.len));
		}
	      fprintf (outfile, "%d", acc.len);
	      nc = 1;
	    }

	  for (i = 0; i < acc.len; i++)
	    {
	      if (nc)
		{
		  fprintf (outfile, ",");
		}
	      fprintf (outfile, "%d", acc.ptr[i]);
	      nc = 1;
	    }

	  if (type == 'z')
	    {
	      if (nc)
		fprintf (outfile, ",");
	      fprintf (outfile, "0");
	    }
	  idx = sb_skip_comma (idx, in);
	  if (idx == pidx)
	    break;
	}
      if (!alternate && in->ptr[idx] != ',' && idx != in->len)
	{
	  fprintf (outfile, "\n");
	  ERROR ((stderr, _("illegal character in SDATA line (0x%x).\n"),
		  in->ptr[idx]));
	  break;
	}
      idx++;
    }
  sb_kill (&acc);
  fprintf (outfile, "\n");
}

/* .SDATAB <count> <string>  */

static void
do_sdatab (idx, in)
     int idx;
     sb *in;
{
  int repeat;
  int i;
  sb acc;
  sb_new (&acc);

  idx = exp_get_abs (_("Must have absolute SDATAB repeat count.\n"), idx, in, &repeat);
  if (repeat <= 0)
    {
      ERROR ((stderr, _("Must have positive SDATAB repeat count (%d).\n"), repeat));
      repeat = 1;
    }

  idx = sb_skip_comma (idx, in);
  idx = getstring (idx, in, &acc);

  for (i = 0; i < repeat; i++)
    {
      if (i)
	fprintf (outfile, "\t");
      fprintf (outfile, ".byte\t");
      sb_print (outfile, &acc);
      fprintf (outfile, "\n");
    }
  sb_kill (&acc);

}

static int
new_file (name)
     const char *name;
{
  FILE *newone = fopen (name, "r");
  if (!newone)
    return 0;

  if (isp == MAX_INCLUDES)
    FATAL ((stderr, _("Unreasonable include depth (%ld).\n"), (long) isp));

  sp++;
  sp->handle = newone;

  sb_new (&sp->name);
  sb_add_string (&sp->name, name);

  sp->linecount = 1;
  sp->pushback_index = 0;
  sp->type = include_file;
  sp->index = 0;
  sb_new (&sp->pushback);
  return 1;
}

static void
do_include (idx, in)
     int idx;
     sb *in;
{
  sb t;
  sb cat;
  include_path *includes;

  sb_new (&t);
  sb_new (&cat);

  if (! mri)
    idx = getstring (idx, in, &t);
  else
    {
      idx = sb_skip_white (idx, in);
      while (idx < in->len && ! ISWHITE (in->ptr[idx]))
	{
	  sb_add_char (&t, in->ptr[idx]);
	  ++idx;
	}
    }

  for (includes = paths_head; includes; includes = includes->next)
    {
      sb_reset (&cat);
      sb_add_sb (&cat, &includes->path);
      sb_add_char (&cat, '/');
      sb_add_sb (&cat, &t);
      if (new_file (sb_name (&cat)))
	{
	  break;
	}
    }
  if (!includes)
    {
      if (! new_file (sb_name (&t)))
	FATAL ((stderr, _("Can't open include file `%s'.\n"), sb_name (&t)));
    }
  sb_kill (&cat);
  sb_kill (&t);
}

static void
include_pop ()
{
  if (sp != include_stack)
    {
      if (sp->handle)
	fclose (sp->handle);
      sp--;
    }
}

/* Get the next character from the include stack.  If there's anything
   in the pushback buffer, take that first.  If we're at eof, pop from
   the stack and try again.  Keep the linecount up to date.  */

static int
get ()
{
  int r;

  if (sp->pushback.len != sp->pushback_index)
    {
      r = (char) (sp->pushback.ptr[sp->pushback_index++]);
      /* When they've all gone, reset the pointer.  */
      if (sp->pushback_index == sp->pushback.len)
	{
	  sp->pushback.len = 0;
	  sp->pushback_index = 0;
	}
    }
  else if (sp->handle)
    {
      r = getc (sp->handle);
    }
  else
    r = EOF;

  if (r == EOF && isp)
    {
      include_pop ();
      r = get ();
      while (r == EOF && isp)
	{
	  include_pop ();
	  r = get ();
	}
      return r;
    }
  if (r == '\n')
    {
      sp->linecount++;
    }

  return r;
}

static int
linecount ()
{
  return sp->linecount;
}

static int
include_next_index ()
{
  static int index;
  if (!unreasonable
      && index > MAX_REASONABLE)
    FATAL ((stderr, _("Unreasonable expansion (-u turns off check).\n")));
  return ++index;
}

/* Initialize the chartype vector.  */

static void
chartype_init ()
{
  int x;
  for (x = 0; x < 256; x++)
    {
      if (isalpha (x) || x == '_' || x == '$')
	chartype[x] |= FIRSTBIT;

      if (mri && x == '.')
	chartype[x] |= FIRSTBIT;

      if (isdigit (x) || isalpha (x) || x == '_' || x == '$')
	chartype[x] |= NEXTBIT;

      if (x == ' ' || x == '\t' || x == ',' || x == '"' || x == ';'
	  || x == '"' || x == '<' || x == '>' || x == ')' || x == '(')
	chartype[x] |= SEPBIT;

      if (x == 'b' || x == 'B'
	  || x == 'q' || x == 'Q'
	  || x == 'h' || x == 'H'
	  || x == 'd' || x == 'D')
	chartype [x] |= BASEBIT;

      if (x == ' ' || x == '\t')
	chartype[x] |= WHITEBIT;

      if (x == comment_char)
	chartype[x] |= COMMENTBIT;
    }
}

/* What to do with all the keywords.  */
#define PROCESS 	0x1000  /* Run substitution over the line.  */
#define LAB		0x2000  /* Spit out the label.  */

#define K_EQU 		(PROCESS|1)
#define K_ASSIGN 	(PROCESS|2)
#define K_REG 		(PROCESS|3)
#define K_ORG 		(PROCESS|4)
#define K_RADIX 	(PROCESS|5)
#define K_DATA 		(LAB|PROCESS|6)
#define K_DATAB 	(LAB|PROCESS|7)
#define K_SDATA 	(LAB|PROCESS|8)
#define K_SDATAB 	(LAB|PROCESS|9)
#define K_SDATAC 	(LAB|PROCESS|10)
#define K_SDATAZ	(LAB|PROCESS|11)
#define K_RES 		(LAB|PROCESS|12)
#define K_SRES 		(LAB|PROCESS|13)
#define K_SRESC 	(LAB|PROCESS|14)
#define K_SRESZ 	(LAB|PROCESS|15)
#define K_EXPORT 	(LAB|PROCESS|16)
#define K_GLOBAL 	(LAB|PROCESS|17)
#define K_PRINT 	(LAB|PROCESS|19)
#define K_FORM 		(LAB|PROCESS|20)
#define K_HEADING	(LAB|PROCESS|21)
#define K_PAGE		(LAB|PROCESS|22)
#define K_IMPORT	(LAB|PROCESS|23)
#define K_PROGRAM	(LAB|PROCESS|24)
#define K_END		(PROCESS|25)
#define K_INCLUDE	(PROCESS|26)
#define K_IGNORED	(PROCESS|27)
#define K_ASSIGNA	(PROCESS|28)
#define K_ASSIGNC	(29)
#define K_AIF		(PROCESS|30)
#define K_AELSE		(PROCESS|31)
#define K_AENDI		(PROCESS|32)
#define K_AREPEAT	(PROCESS|33)
#define K_AENDR		(PROCESS|34)
#define K_AWHILE	(35)
#define K_AENDW		(PROCESS|36)
#define K_EXITM		(37)
#define K_MACRO		(PROCESS|38)
#define K_ENDM		(39)
#define K_ALIGN		(PROCESS|LAB|40)
#define K_ALTERNATE     (41)
#define K_DB		(LAB|PROCESS|42)
#define K_DW		(LAB|PROCESS|43)
#define K_DL		(LAB|PROCESS|44)
#define K_LOCAL		(45)
#define K_IFEQ		(PROCESS|46)
#define K_IFNE		(PROCESS|47)
#define K_IFLT		(PROCESS|48)
#define K_IFLE		(PROCESS|49)
#define K_IFGE		(PROCESS|50)
#define K_IFGT		(PROCESS|51)
#define K_IFC		(PROCESS|52)
#define K_IFNC		(PROCESS|53)
#define K_IRP		(PROCESS|54)
#define K_IRPC		(PROCESS|55)

struct keyword {
  char *name;
  int code;
  int extra;
};

static struct keyword kinfo[] = {
  { "EQU", K_EQU, 0 },
  { "ALTERNATE", K_ALTERNATE, 0 },
  { "ASSIGN", K_ASSIGN, 0 },
  { "REG", K_REG, 0 },
  { "ORG", K_ORG, 0 },
  { "RADIX", K_RADIX, 0 },
  { "DATA", K_DATA, 0 },
  { "DB", K_DB, 0 },
  { "DW", K_DW, 0 },
  { "DL", K_DL, 0 },
  { "DATAB", K_DATAB, 0 },
  { "SDATA", K_SDATA, 0 },
  { "SDATAB", K_SDATAB, 0 },
  { "SDATAZ", K_SDATAZ, 0 },
  { "SDATAC", K_SDATAC, 0 },
  { "RES", K_RES, 0 },
  { "SRES", K_SRES, 0 },
  { "SRESC", K_SRESC, 0 },
  { "SRESZ", K_SRESZ, 0 },
  { "EXPORT", K_EXPORT, 0 },
  { "GLOBAL", K_GLOBAL, 0 },
  { "PRINT", K_PRINT, 0 },
  { "FORM", K_FORM, 0 },
  { "HEADING", K_HEADING, 0 },
  { "PAGE", K_PAGE, 0 },
  { "PROGRAM", K_IGNORED, 0 },
  { "END", K_END, 0 },
  { "INCLUDE", K_INCLUDE, 0 },
  { "ASSIGNA", K_ASSIGNA, 0 },
  { "ASSIGNC", K_ASSIGNC, 0 },
  { "AIF", K_AIF, 0 },
  { "AELSE", K_AELSE, 0 },
  { "AENDI", K_AENDI, 0 },
  { "AREPEAT", K_AREPEAT, 0 },
  { "AENDR", K_AENDR, 0 },
  { "EXITM", K_EXITM, 0 },
  { "MACRO", K_MACRO, 0 },
  { "ENDM", K_ENDM, 0 },
  { "AWHILE", K_AWHILE, 0 },
  { "ALIGN", K_ALIGN, 0 },
  { "AENDW", K_AENDW, 0 },
  { "ALTERNATE", K_ALTERNATE, 0 },
  { "LOCAL", K_LOCAL, 0 },
  { NULL, 0, 0 }
};

/* Although the conditional operators are handled by gas, we need to
   handle them here as well, in case they are used in a recursive
   macro to end the recursion.  */

static struct keyword mrikinfo[] = {
  { "IFEQ", K_IFEQ, 0 },
  { "IFNE", K_IFNE, 0 },
  { "IFLT", K_IFLT, 0 },
  { "IFLE", K_IFLE, 0 },
  { "IFGE", K_IFGE, 0 },
  { "IFGT", K_IFGT, 0 },
  { "IFC", K_IFC, 0 },
  { "IFNC", K_IFNC, 0 },
  { "ELSEC", K_AELSE, 0 },
  { "ENDC", K_AENDI, 0 },
  { "MEXIT", K_EXITM, 0 },
  { "REPT", K_AREPEAT, 0 },
  { "IRP", K_IRP, 0 },
  { "IRPC", K_IRPC, 0 },
  { "ENDR", K_AENDR, 0 },
  { NULL, 0, 0 }
};

/* Look for a pseudo op on the line. If one's there then call
   its handler.  */

static int
process_pseudo_op (idx, line, acc)
     int idx;
     sb *line;
     sb *acc;
{
  int oidx = idx;

  if (line->ptr[idx] == '.' || alternate || mri)
    {
      /* Scan forward and find pseudo name.  */
      char *in;
      hash_entry *ptr;

      char *s;
      char *e;
      if (line->ptr[idx] == '.')
	idx++;
      in = line->ptr + idx;
      s = in;
      e = s;
      sb_reset (acc);

      while (idx < line->len && *e && ISFIRSTCHAR (*e))
	{
	  sb_add_char (acc, *e);
	  e++;
	  idx++;
	}

      ptr = hash_lookup (&keyword_hash_table, acc);

      if (!ptr)
	{
#if 0
	  /* This one causes lots of pain when trying to preprocess
	     ordinary code.  */
	  WARNING ((stderr, _("Unrecognised pseudo op `%s'.\n"),
		    sb_name (acc)));
#endif
	  return 0;
	}
      if (ptr->value.i & LAB)
	{
	  /* Output the label.  */
	  if (label.len)
	    {
	      fprintf (outfile, "%s:\t", sb_name (&label));
	    }
	  else
	    fprintf (outfile, "\t");
	}

      if (mri && ptr->value.i == K_END)
	{
	  sb t;

	  sb_new (&t);
	  sb_add_buffer (&t, line->ptr + oidx, idx - oidx);
	  fprintf (outfile, "\t%s", sb_name (&t));
	  sb_kill (&t);
	}

      if (ptr->value.i & PROCESS)
	{
	  /* Polish the rest of the line before handling the pseudo op.  */
#if 0
	  strip_comments (line);
#endif
	  sb_reset (acc);
	  process_assigns (idx, line, acc);
	  sb_reset (line);
	  change_base (0, acc, line);
	  idx = 0;
	}
      if (!condass_on ())
	{
	  switch (ptr->value.i)
	    {
	    case K_AIF:
	      do_aif (idx, line);
	      break;
	    case K_AELSE:
	      do_aelse ();
	      break;
	    case K_AENDI:
	      do_aendi ();
	      break;
	    }
	  return 1;
	}
      else
	{
	  switch (ptr->value.i)
	    {
	    case K_ALTERNATE:
	      alternate = 1;
	      macro_init (1, mri, 0, exp_get_abs);
	      return 1;
	    case K_AELSE:
	      do_aelse ();
	      return 1;
	    case K_AENDI:
	      do_aendi ();
	      return 1;
	    case K_ORG:
	      ERROR ((stderr, _("ORG command not allowed.\n")));
	      break;
	    case K_RADIX:
	      do_radix (line);
	      return 1;
	    case K_DB:
	      do_data (idx, line, 1);
	      return 1;
	    case K_DW:
	      do_data (idx, line, 2);
	      return 1;
	    case K_DL:
	      do_data (idx, line, 4);
	      return 1;
	    case K_DATA:
	      do_data (idx, line, 0);
	      return 1;
	    case K_DATAB:
	      do_datab (idx, line);
	      return 1;
	    case K_SDATA:
	      do_sdata (idx, line, 0);
	      return 1;
	    case K_SDATAB:
	      do_sdatab (idx, line);
	      return 1;
	    case K_SDATAC:
	      do_sdata (idx, line, 'c');
	      return 1;
	    case K_SDATAZ:
	      do_sdata (idx, line, 'z');
	      return 1;
	    case K_ASSIGN:
	      do_assign (0, 0, line);
	      return 1;
	    case K_AIF:
	      do_aif (idx, line);
	      return 1;
	    case K_AREPEAT:
	      do_arepeat (idx, line);
	      return 1;
	    case K_AENDW:
	      do_aendw ();
	      return 1;
	    case K_AWHILE:
	      do_awhile (idx, line);
	      return 1;
	    case K_AENDR:
	      do_aendr ();
	      return 1;
	    case K_EQU:
	      do_assign (1, idx, line);
	      return 1;
	    case K_ALIGN:
	      do_align (idx, line);
	      return 1;
	    case K_RES:
	      do_res (idx, line, 0);
	      return 1;
	    case K_SRES:
	      do_res (idx, line, 's');
	      return 1;
	    case K_INCLUDE:
	      do_include (idx, line);
	      return 1;
	    case K_LOCAL:
	      do_local (idx, line);
	      return 1;
	    case K_MACRO:
	      do_macro (idx, line);
	      return 1;
	    case K_ENDM:
	      do_endm ();
	      return 1;
	    case K_SRESC:
	      do_res (idx, line, 'c');
	      return 1;
	    case K_PRINT:
	      do_print (idx, line);
	      return 1;
	    case K_FORM:
	      do_form (idx, line);
	      return 1;
	    case K_HEADING:
	      do_heading (idx, line);
	      return 1;
	    case K_PAGE:
	      do_page ();
	      return 1;
	    case K_GLOBAL:
	    case K_EXPORT:
	      do_export (line);
	      return 1;
	    case K_IMPORT:
	      return 1;
	    case K_SRESZ:
	      do_res (idx, line, 'z');
	      return 1;
	    case K_IGNORED:
	      return 1;
	    case K_END:
	      do_end (line);
	      return 1;
	    case K_ASSIGNA:
	      do_assigna (idx, line);
	      return 1;
	    case K_ASSIGNC:
	      do_assignc (idx, line);
	      return 1;
	    case K_EXITM:
	      do_exitm ();
	      return 1;
	    case K_REG:
	      do_reg (idx, line);
	      return 1;
	    case K_IFEQ:
	      do_if (idx, line, EQ);
	      return 1;
	    case K_IFNE:
	      do_if (idx, line, NE);
	      return 1;
	    case K_IFLT:
	      do_if (idx, line, LT);
	      return 1;
	    case K_IFLE:
	      do_if (idx, line, LE);
	      return 1;
	    case K_IFGE:
	      do_if (idx, line, GE);
	      return 1;
	    case K_IFGT:
	      do_if (idx, line, GT);
	      return 1;
	    case K_IFC:
	      do_ifc (idx, line, 0);
	      return 1;
	    case K_IFNC:
	      do_ifc (idx, line, 1);
	      return 1;
	    case K_IRP:
	      do_irp (idx, line, 0);
	      return 1;
	    case K_IRPC:
	      do_irp (idx, line, 1);
	      return 1;
	    }
	}
    }
  return 0;
}

/* Add a keyword to the hash table.  */

static void
add_keyword (name, code)
     const char *name;
     int code;
{
  sb label;
  int j;

  sb_new (&label);
  sb_add_string (&label, name);

  hash_add_to_int_table (&keyword_hash_table, &label, code);

  sb_reset (&label);
  for (j = 0; name[j]; j++)
    sb_add_char (&label, name[j] - 'A' + 'a');
  hash_add_to_int_table (&keyword_hash_table, &label, code);

  sb_kill (&label);
}

/* Build the keyword hash table - put each keyword in the table twice,
   once upper and once lower case.  */

static void
process_init ()
{
  int i;

  for (i = 0; kinfo[i].name; i++)
    add_keyword (kinfo[i].name, kinfo[i].code);

  if (mri)
    {
      for (i = 0; mrikinfo[i].name; i++)
	add_keyword (mrikinfo[i].name, mrikinfo[i].code);
    }
}

static void
do_define (string)
     const char *string;
{
  sb label;
  int res = 1;
  hash_entry *ptr;
  sb_new (&label);

  while (*string)
    {
      if (*string == '=')
	{
	  sb value;
	  sb_new (&value);
	  string++;
	  while (*string)
	    {
	      sb_add_char (&value, *string);
	      string++;
	    }
	  exp_get_abs (_("Invalid expression on command line.\n"),
		       0, &value, &res);
	  sb_kill (&value);
	  break;
	}
      sb_add_char (&label, *string);

      string++;
    }

  ptr = hash_create (&vars, &label);
  free_old_entry (ptr);
  ptr->type = hash_integer;
  ptr->value.i = res;
  sb_kill (&label);
}

char *program_name;

/* The list of long options.  */
static struct option long_options[] =
{
  { "alternate", no_argument, 0, 'a' },
  { "include", required_argument, 0, 'I' },
  { "commentchar", required_argument, 0, 'c' },
  { "copysource", no_argument, 0, 's' },
  { "debug", no_argument, 0, 'd' },
  { "help", no_argument, 0, 'h' },
  { "mri", no_argument, 0, 'M' },
  { "output", required_argument, 0, 'o' },
  { "print", no_argument, 0, 'p' },
  { "unreasonable", no_argument, 0, 'u' },
  { "version", no_argument, 0, 'v' },
  { "define", required_argument, 0, 'd' },
  { NULL, no_argument, 0, 0 }
};

/* Show a usage message and exit.  */
static void
show_usage (file, status)
     FILE *file;
     int status;
{
  fprintf (file, _("\
Usage: %s \n\
  [-a]      [--alternate]         enter alternate macro mode\n\
  [-c char] [--commentchar char]  change the comment character from !\n\
  [-d]      [--debug]             print some debugging info\n\
  [-h]      [--help]              print this message\n\
  [-M]      [--mri]               enter MRI compatibility mode\n\
  [-o out]  [--output out]        set the output file\n\
  [-p]      [--print]             print line numbers\n"), program_name);
  fprintf (file, _("\
  [-s]      [--copysource]        copy source through as comments \n\
  [-u]      [--unreasonable]      allow unreasonable nesting\n\
  [-v]      [--version]           print the program version\n\
  [-Dname=value]                  create preprocessor variable called name, with value\n\
  [-Ipath]                        add to include path list\n\
  [in-file]\n"));
  if (status == 0)
    printf (_("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
}

/* Display a help message and exit.  */

static void
show_help ()
{
  printf (_("%s: Gnu Assembler Macro Preprocessor\n"), program_name);
  show_usage (stdout, 0);
}

int
main (argc, argv)
     int argc;
     char **argv;
{
  int opt;
  char *out_name = 0;
  sp = include_stack;

  ifstack[0].on = 1;
  ifi = 0;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);

  hash_new_table (101, &keyword_hash_table);
  hash_new_table (101, &assign_hash_table);
  hash_new_table (101, &vars);

  sb_new (&label);

  while ((opt = getopt_long (argc, argv, "I:sdhavc:upo:D:M", long_options,
			     (int *) NULL))
	 != EOF)
    {
      switch (opt)
	{
	case 'o':
	  out_name = optarg;
	  break;
	case 'u':
	  unreasonable = 1;
	  break;
	case 'I':
	  {
	    include_path *p = (include_path *) xmalloc (sizeof (include_path));
	    p->next = NULL;
	    sb_new (&p->path);
	    sb_add_string (&p->path, optarg);
	    if (paths_tail)
	      paths_tail->next = p;
	    else
	      paths_head = p;
	    paths_tail = p;
	  }
	  break;
	case 'p':
	  print_line_number = 1;
	  break;
	case 'c':
	  comment_char = optarg[0];
	  break;
	case 'a':
	  alternate = 1;
	  break;
	case 's':
	  copysource = 1;
	  break;
	case 'd':
	  stats = 1;
	  break;
	case 'D':
	  do_define (optarg);
	  break;
	case 'M':
	  mri = 1;
	  comment_char = ';';
	  break;
	case 'h':
	  show_help ();
	  /* NOTREACHED  */
	case 'v':
	  /* This output is intended to follow the GNU standards document.  */
	  printf (_("GNU assembler pre-processor %s\n"), program_version);
	  printf (_("Copyright 1996 Free Software Foundation, Inc.\n"));
	  printf (_("\
This program is free software; you may redistribute it under the terms of\n\
the GNU General Public License.  This program has absolutely no warranty.\n"));
	  exit (0);
	  /* NOTREACHED  */
	case 0:
	  break;
	default:
	  show_usage (stderr, 1);
	  /* NOTREACHED  */
	}
    }

  process_init ();

  macro_init (alternate, mri, 0, exp_get_abs);

  if (out_name)
    {
      outfile = fopen (out_name, "w");
      if (!outfile)
	{
	  fprintf (stderr, _("%s: Can't open output file `%s'.\n"),
		   program_name, out_name);
	  exit (1);
	}
    }
  else
    {
      outfile = stdout;
    }

  chartype_init ();
  if (!outfile)
    outfile = stdout;

  /* Process all the input files.  */

  while (optind < argc)
    {
      if (new_file (argv[optind]))
	{
	  process_file ();
	}
      else
	{
	  fprintf (stderr, _("%s: Can't open input file `%s'.\n"),
		   program_name, argv[optind]);
	  exit (1);
	}
      optind++;
    }

  quit ();
  return 0;
}

/* This function is used because an abort in some of the other files
   may be compiled into as_abort because they include as.h.  */

void
as_abort (file, line, fn)
     const char *file, *fn;
     int line;
{
  fprintf (stderr, _("Internal error, aborting at %s line %d"), file, line);
  if (fn)
    fprintf (stderr, " in %s", fn);
  fprintf (stderr, _("\nPlease report this bug.\n"));
  exit (1);
}
@


1.6
log
@resolve conflicts.
@
text
@@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 98, 99, 2000
d23 1
a23 1
   02111-1307, USA. */
a25 1

a28 1

d44 1
a44 1
     A %<exp> in a string evaluates the expression 
a45 2


d82 2
a83 2
#define MAX_INCLUDES 30		/* Maximum include depth */
#define MAX_REASONABLE 1000	/* Maximum number of expansions */
d85 9
a93 9
int unreasonable;		/* -u on command line */
int stats;			/* -d on command line */
int print_line_number;		/* -p flag on command line */
int copysource;			/* -c flag on command line */
int warnings;			/* Number of WARNINGs generated so far. */
int errors;			/* Number of ERRORs generated so far. */
int fatals;			/* Number of fatal ERRORs generated so far (either 0 or 1). */
int alternate = 0;              /* -a on command line */
int mri = 0;			/* -M on command line */
d95 1
a95 1
int radix = 10;			/* Default radix */
d97 1
a97 1
int had_end; /* Seen .END */
d99 1
a99 1
/* The output stream */
d102 2
a103 3
/* the attributes of each character are stored as a bit pattern
   chartype, which gives us quick tests. */

a118 1

d127 5
a131 6
struct
  {
    int on;			/* is the level being output */
    int hadelse;		/* has an aelse been seen */
  }
ifstack[IFNESTING];
d136 1
a136 1
   line.  It must be coped somewhere safe before the next line is read in. */
d138 4
a141 14
typedef struct
  {
    char *name;
    int len;
  }
symbol;

typedef struct
  {
    int value;			/* constant part */
    symbol add_symbol;		/* name part */
    symbol sub_symbol;		/* name part */
  }
exp_t;
d143 5
d153 1
a153 30
   with the same hash are kept in a chain. */

/* What the data in a hash_entry means */
typedef enum
  {
    hash_integer,		/* name->integer mapping */
    hash_string,		/* name->string mapping */
    hash_macro,			/* name is a macro */
    hash_formal			/* name is a formal argument */
  } hash_type;

typedef struct hs
  {
    sb key;			/* symbol name */
    hash_type type;		/* symbol meaning */
    union
      {
	sb s;
	int i;
	struct macro_struct *m;
	struct formal_struct *f;
      } value;
    struct hs *next;		/* next hash_entry with same hash key */
  } hash_entry;

typedef struct
  {
    hash_entry **table;
    int size;
  } hash_table;
d155 24
d180 1
a180 1
/* how we nest files and expand macros etc.
d182 2
a183 2
   we keep a stack of of include_stack structs.  each include file
   pushes a new level onto the stack.  we keep an sb with a pushback
d187 4
a190 4
   small things are expanded by adding the text of the item onto the
   pushback sb.  larger items are grown by pushing a new level and
   allocating the entire pushback buf for the item.  each time
   something like a macro is expanded, the stack index is changed. we
d192 16
a207 20
   the same stack index.  if we're being reasonable, we can detect
   recusive expansion by checking the index is reasonably small.
 */

typedef enum
  {
    include_file, include_repeat, include_while, include_macro
  } include_type;

struct include_stack
  {
    sb pushback;		/* current pushback stream */
    int pushback_index;		/* next char to read from stream */
    FILE *handle;		/* open file */
    sb name;			/* name of file */
    int linecount;		/* number of lines read so far */
    include_type type;
    int index;			/* index of this layer */
  }
include_stack[MAX_INCLUDES];
d212 1
a212 1
/* Include file list */
d214 1
a214 2
typedef struct include_path 
{
d217 1
a217 1
}  include_path;
a221 1

d314 27
a340 6
#define FATAL(x) \
  do { include_print_where_line (stderr); fprintf x ; fatals++; quit(); } while(0) 
#define ERROR(x) \
  do { include_print_where_line (stderr); fprintf x; errors++; } while(0)
#define WARNING(x) \
  do { include_print_where_line (stderr); fprintf x; warnings++;} while(0) 
d342 1
a343 2

/* exit the program and return the right ERROR code. */
d353 1
a353 1
  if (stats) 
d356 1
a356 1
      for (i = 0; i < sb_max_power_two; i++) 
d358 2
a359 1
	  fprintf (stderr, "strings size %8d : %d\n", 1<<i, string_count[i]);
d365 1
a365 1
/* hash table maintenance. */
d367 2
a368 1
/* build a new hash table with size buckets, and fill in the info at ptr. */
d383 1
a383 1
/* calculate and return the hash value of the sb at key. */
d400 2
a401 2
/* lookup key in hash_table tab, if present, then return it, otherwise
   build a new one and fill it with hash_integer. */
d403 1
a403 2
static
hash_entry *
d434 2
a435 2
/* add sb name with key into hash_table tab.  if replacing old value
   and again, then ERROR. */
d437 1
a437 2
static
void
d457 1
a457 1
  
d461 1
a461 1
/* add integer name to hash_table tab with sb key. */
d463 1
a463 2
static
void
d473 4
a476 5
/* lookup sb key in hash_table tab.  if found return hash_entry result,
   else 0. */
   
static
hash_entry *
a493 1

a507 1

d510 2
d513 1
a513 4
/* make sure that the exp_t at term is constant, if not the give the op ERROR. */

static
void
d525 2
a526 3
/* turn the number in string at idx into a number of base,
   fill in ptr and return the index of the first character not in the
   number. */
d528 1
a528 2
static
int
a607 2


a685 1

d710 1
a710 1
	  /* change nn+symbol to symbol + nn */
d784 3
a786 4

/* parse the expression at offset idx into string, fill up res with
   the result. return the index of the first char past the expression.
   */
d797 2
a798 3

/* turn the expression at exp into text and glue it onto the end of
   string. */
d837 3
a839 4

/* parse the expression at offset idx into sb in, return the value in val.  
   if the expression is not constant, give ERROR emsg.  returns the index
   of the first character past the end of the expression. */
d856 5
d862 5
a866 4
sb label; /* current label parsed from line */
hash_table assign_hash_table;   /* hash table for all assigned variables */
hash_table keyword_hash_table;  /* hash table for keyword */
hash_table vars;  /* hash table for  eq variables */
d879 1
a879 1
      if (ISCOMMENTCHAR(s[i]))
d888 1
a888 1
/* push back character ch so that it can be read again. */
d904 2
a905 1
/* push the sb ptr onto the include stack, with the given name, type and index. */
d907 1
a907 2
static
void
d928 2
d931 1
a931 3
/* used in ERROR messages, print info on where the include stack is onto file. */
static 
void
d944 2
a945 1
/* used in listings, print the line number onto file. */
d967 1
a967 2

/* read a line from the top of the include stack into sb in. */
d1015 1
a1015 1
	      /* continued line */
d1040 1
a1040 1
/* find a label from sb in and put it in out. */
d1053 1
a1053 1
      while ((ISNEXTCHAR (in->ptr[i]) 
d1055 1
a1055 1
	      || in->ptr[i] == '&') 
d1065 2
a1066 2
/* find all strange base stuff and turn into decimal. also
   find all the other numbers and convert them from the default radix */
d1126 1
a1126 1
	  /* copy entire names through quickly */
d1138 2
a1139 2
	  /* all numbers must start with a digit, let's chew it and
	     spit out decimal */
d1144 1
a1144 1
	  /* skip all undigsested letters */
d1154 1
a1154 1
	  /* copy entire names through quickly */
d1165 1
a1165 1
	  /* nothing special, just pass it through */
d1173 2
a1174 1
/* .end */
d1184 1
a1184 1
/* .assign */
d1192 1
a1192 1
  /* stick label in symbol table with following value */
d1203 1
d1205 1
a1205 4
/* .radix [b|q|d|h] */

static
void
d1233 1
a1233 2

/* Parse off a .b, .w or .l */
d1272 2
a1273 2
static 
int eol(idx, line)
d1278 1
a1278 1
  if (idx < line->len 
d1286 2
a1287 2
/* .data [.b|.w|.l] <data>* 
    or d[bwl] <data>* */
d1300 1
a1300 1
  if (!size) 
d1304 4
a1307 3
  else {
    opsize = size;
  }
a1320 1

d1323 1
a1323 1
  idx =   sb_skip_white (idx, in);
d1325 2
a1326 2
  if (alternate 
      && idx < in->len 
d1334 1
a1334 1
	    fprintf(outfile,",");
d1338 1
a1338 1
  else 
d1359 1
a1359 1
/* .datab [.b|.w|.l] <repeat>,<fill> */
d1379 1
a1379 1
/* .align <size> */
d1406 1
a1406 1
/* .res[.b|.w|.l] <size> */
d1418 1
a1418 1
  while (!eol(idx, in))
d1432 1
a1432 2

/* .export */
d1441 1
a1441 1
/* .print [list] [nolist] */
d1465 2
a1466 1
/* .head */
d1479 1
a1479 1
/* .page */
d1487 2
a1488 1
/* .form [lin=<value>] [col=<value>] */
a1518 1

d1526 1
d1540 1
a1540 1
      if (in->len > 2 && in->ptr[idx+1] == '\'' && ISBASE (in->ptr[idx]))
d1551 1
a1551 1
	  /* Turns the next expression into a string */
d1556 1
a1556 1
	  sprintf(buf, "%d", val);
d1565 5
a1569 5
	      /* Keep the quotes */
	      sb_add_char (out,  '\"');
		    
	      idx =  getstring (idx, in, out);
	      sb_add_char (out,  '\"');
d1572 4
a1575 3
	  else {
	    idx = getstring (idx, in, out);
	  }
d1577 1
a1577 1
      else 
d1579 1
a1579 1
	  while (idx < in->len 
d1582 1
a1582 1
		     || pretend_quoted 
d1585 1
a1585 1
	      if (in->ptr[idx] == '"' 
d1592 1
a1592 1
		    sb_add_char (out, in->ptr[idx++]);		    
d1594 1
a1594 1
		    return idx;	      
d1604 2
a1605 3

/* skip along sb in starting at idx, suck off whitespace a ( and more
   whitespace.  return the idx of the next char */
d1619 2
a1620 2
/* skip along sb in starting at idx, suck off whitespace a ) and more
   whitespace.  return the idx of the next char */
d1634 1
a1634 1
/* .len */
d1657 1
d1659 1
a1659 4
/* .instr */

static
int
a1703 1

a1722 1

d1729 1
a1729 1
  else 
d1739 1
a1739 1
  sb_kill(&string);
d1743 2
a1744 1
/* scan line, change tokens in the hash table to their replacements */
d1802 1
a1802 1
	  /* may be a simple name subsitution, see if we have a word */
d1814 1
a1814 1
	      /* Found a definition for it */
d1819 1
a1819 1
	      /* No definition, just copy the word */
d1846 1
a1846 2
static
void
d1858 1
a1858 1
  sb_new(&acc);
d1864 1
a1864 1
      /* Find any label and pseudo op that we're intested in */
d1881 1
a1881 1
	  sb_reset (&label);	  	  
a1923 2


a1929 1

d1940 1
a1940 1
			sb_reset(&t1);
d1949 8
a1956 7
	  else {
	    /* Only a label on this line */
	    if (label.len && condass_on())
	      {
		fprintf (outfile, "%s:\n", sb_name (&label));
	      }
	  }
a1968 4




d1976 1
a1976 1
	sb_kill(&ptr->value.s);
d1980 1
a1980 1
/* name: .ASSIGNA <value> */
d2008 1
a2008 1
/* name: .ASSIGNC <string> */
d2034 1
a2034 2

/* name: .REG (reg) */
d2041 1
a2041 1
  /* remove reg stuff from inside parens */
a2059 1

a2080 1

d2083 1
a2083 1
      if (warn) 
d2087 1
a2087 1
      else 
d2176 1
a2176 1
      /* This is a string comparision */
d2180 2
a2181 1
      same = acc_a.len == acc_b.len && (strncmp (acc_a.ptr, acc_b.ptr, acc_a.len) == 0);
d2192 1
a2192 1
    /* This is a numeric expression */
d2244 2
a2245 1
/* .AIF */
d2256 1
a2256 1
  ifstack[ifi].on = ifstack[ifi-1].on ? istrue (idx, in) : 0;
d2260 1
a2261 1
/* .AELSE */
d2265 1
a2265 1
  ifstack[ifi].on = ifstack[ifi-1].on ? !ifstack[ifi].on : 0;
d2273 1
a2274 1
/* .AENDI */
d2324 1
a2324 1
  ifstack[ifi].on = ifstack[ifi-1].on ? res: 0;
d2375 1
a2375 1
/* MRI IFC, IFNC.  */
d2410 1
a2410 1
  ifstack[ifi].on = ifstack[ifi-1].on ? res : 0;
d2414 2
a2415 1
/* .ENDR */
d2425 1
a2425 1
/* .AWHILE */
d2427 1
a2427 2
static
void
d2455 1
a2455 1
   */
d2468 1
a2468 1
      /* Push another WHILE */
d2476 1
a2476 2

/* .AENDW */
d2484 1
d2486 1
a2486 3
/* .EXITM
   
   Pop things off the include stack until the type and index changes */
d2506 1
a2506 1
/* .AREPEAT */
d2514 3
a2516 3
  sb exp;			/* buffer with expression in it */
  sb copy;			/* expanded repeat block */
  sb sub;			/* contents of AREPEAT */
d2544 1
a2544 1
	 */
d2568 1
a2568 1
/* .ENDM */
d2598 3
a2600 1
/* MACRO PROCESSING */
d2602 1
a2602 3
/* Parse off LOCAL n1, n2,... Invent a label name for it */
static
void 
d2653 1
a2653 1
/* STRING HANDLING */
d2664 2
a2665 2
	 && (in->ptr[idx] == '"' 
	     || in->ptr[idx] == '<' 
d2679 9
a2687 1
		      idx++  ;
a2689 7
		  else {
		    if (in->ptr[idx] == '>')
		      nest--;
		    if (in->ptr[idx] == '<')
		      nest++;
		    sb_add_char (acc, in->ptr[idx++]);
		  }
d2693 7
a2699 6
	  else {
	    int code;
	    idx++;
	    idx = exp_get_abs (_("Character code in string must be absolute expression.\n"),
			       idx, in, &code);
	    sb_add_char (acc, code);
d2701 4
a2704 4
	    if (in->ptr[idx] != '>')
	      ERROR ((stderr, _("Missing > for character code.\n")));
	    idx++;
	  }
d2714 1
a2714 1
		  idx++  ;
d2717 11
a2727 10
	      else {
		if (in->ptr[idx] == tchar)
		  {
		    idx++;
		    if (idx >= in->len || in->ptr[idx] != tchar)
		      break;
		  }
		sb_add_char (acc, in->ptr[idx]);
		idx++;
	      }
d2731 1
a2731 1
  
d2735 1
a2735 1
/* .SDATA[C|Z] <string> */
d2737 1
a2737 2
static
void
d2784 2
a2785 1
	  if (idx == pidx) break;
d2790 2
a2791 1
	  ERROR ((stderr, _("illegal character in SDATA line (0x%x).\n"), in->ptr[idx]));
d2800 1
a2800 1
/* .SDATAB <count> <string> */
d2916 1
a2916 1
   the stack and try again.  Keep the linecount up to date. */
d2926 1
a2926 1
      /* When they've all gone, reset the pointer */
d2975 1
a2975 2

/* Initialize the chartype vector. */
d3001 1
a3001 1
	  
d3010 3
a3012 5


/* What to do with all the keywords */
#define PROCESS 	0x1000  /* Run substitution over the line */
#define LAB		0x2000  /* Spit out the label */
d3069 1
a3069 3

struct keyword
{
d3075 1
a3075 2
static struct keyword kinfo[] =
{
d3126 1
a3126 2
static struct keyword mrikinfo[] =
{
d3146 1
a3146 1
   its handler. */
d3158 1
a3158 1
      /* Scan forward and find pseudo name */
d3184 3
a3186 2
	     ordinary code */
	  WARNING ((stderr, _("Unrecognised pseudo op `%s'.\n"), sb_name (acc)));
d3191 2
a3192 1
	{			/* output the label */
d3213 1
a3213 1
	  /* Polish the rest of the line before handling the pseudo op */
d3215 1
a3215 1
	  strip_comments(line);
d3219 1
a3219 1
	  sb_reset(line);
a3404 2


d3426 1
a3426 1
}  
d3429 1
a3429 1
   once upper and once lower case.*/
a3445 1

a3454 1

d3457 1
a3457 1
      if (*string == '=') 
d3467 2
a3468 1
	  exp_get_abs (_("Invalid expression on command line.\n"), 0, &value, &res);
d3474 1
a3474 1
      string ++;
d3483 1
d3532 1
d3536 1
a3536 2
  printf (_("%s: Gnu Assembler Macro Preprocessor\n"),
	  program_name);
d3616 1
a3616 1
	  /*NOTREACHED*/
d3625 1
a3625 1
	  /*NOTREACHED*/
d3630 1
a3630 1
	  /*NOTREACHED*/
d3638 14
a3651 12
  if (out_name) {
    outfile = fopen (out_name, "w");
    if (!outfile)
      {
	fprintf (stderr, _("%s: Can't open output file `%s'.\n"),
		 program_name, out_name);
	exit (1);
      }
  }
  else  {
    outfile = stdout;
  }
d3657 1
a3657 1
  /* Process all the input files */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 1996 Free Software Foundation, Inc.
d53 1
d72 1
d76 10
d116 6
a121 6
#define ISCOMMENTCHAR(x) (chartype[(unsigned)(x)] & COMMENTBIT)
#define ISFIRSTCHAR(x)  (chartype[(unsigned)(x)] & FIRSTBIT)
#define ISNEXTCHAR(x)   (chartype[(unsigned)(x)] & NEXTBIT)
#define ISSEP(x)        (chartype[(unsigned)(x)] & SEPBIT)
#define ISWHITE(x)      (chartype[(unsigned)(x)] & WHITEBIT)
#define ISBASE(x)       (chartype[(unsigned)(x)] & BASEBIT)
a196 31
/* Structures used to store macros. 

   Each macro knows its name and included text.  It gets built with a
   list of formal arguments, and also keeps a hash table which points
   into the list to speed up formal search.  Each formal knows its
   name and its default value.  Each time the macro is expanded, the
   formals get the actual values attatched to them. */

/* describe the formal arguments to a macro */

typedef struct formal_struct
  {
    struct formal_struct *next;	/* next formal in list */
    sb name;			/* name of the formal */
    sb def;			/* the default value */
    sb actual;			/* the actual argument (changed on each expansion) */
    int index;			/* the index of the formal 0..formal_count-1 */
  }
formal_entry;

/* describe the macro. */

typedef struct macro_struct
  {
    sb sub;			/* substitution text. */
    int formal_count;		/* number of formal args. */
    formal_entry *formals;	/* pointer to list of formal_structs */
    hash_table formal_hash;	/* hash table of formals. */
  }
macro_entry;

d455 1
a455 1
	ERROR ((stderr, "redefintion not allowed"));
d529 1
a529 1
      ERROR ((stderr, "the %c operator cannot take non-absolute arguments.\n", op));
d587 1
a587 1
  if (isdigit (string->ptr[idx]))
d606 1
a606 1
      ERROR ((stderr, "string where expression expected.\n"));
d612 1
a612 1
      ERROR ((stderr, "can't find primary in expression.\n"));
d652 1
a652 1
	ERROR ((stderr, "misplaced closing parens.\n"));
d689 1
a689 1
	    ERROR ((stderr, "attempt to divide by zero.\n"));
d721 1
a721 1
	      ERROR ((stderr, "can't add two relocatable expressions\n"));
d867 1
a867 1
    ERROR ((stderr, emsg));
d926 1
a926 1
    FATAL ((stderr, "unreasonable nesting.\n"));
d1004 1
a1004 1
	      WARNING ((stderr, "End of file not at start of line.\n"));
d1059 1
a1059 1
  if (ISFIRSTCHAR (in->ptr[i]))
d1125 1
a1125 1
	      ERROR ((stderr, "Illegal base character %c.\n", in->ptr[idx]));
d1145 1
a1145 1
      else if (isdigit (in->ptr[idx]))
d1240 1
a1240 1
      ERROR ((stderr, "radix is %c must be one of b, q, d or h", radix));
d1276 1
a1276 1
      ERROR ((stderr, "size must be one of b, w or l, is %c.\n", in->ptr[idx]));
d1358 1
a1358 1
	  fprintf (outfile, acc.ptr);
d1384 1
a1384 1
  idx = exp_get_abs ("datab repeat must be constant.\n", idx, in, &repeat);
d1386 1
a1386 1
  idx = exp_get_abs ("datab data must be absolute.\n", idx, in, &fill);
d1400 1
a1400 1
  idx = exp_get_abs ("align needs absolute expression.\n", idx, in, &al);
d1407 1
a1407 1
      idx = exp_get_abs (".align needs absolute fill value.\n", idx, in,
a1411 5
  if (al != 1
      && al != 2
      && al != 4)
    WARNING ((stderr, "alignment must be one of 1, 2 or 4.\n"));

d1435 1
a1435 1
      idx = exp_get_abs ("res needs absolute expression for fill count.\n", idx, in, &count);
d1515 1
a1515 1
	  idx = exp_get_abs ("form LIN= needs absolute expresssion.\n", idx, in, &lines);
d1518 1
a1518 1
      if (strncasecmp (in->ptr + idx, "COL=", 4) == 0)
d1521 1
a1521 1
	  idx = exp_get_abs ("form COL= needs absolute expresssion.\n", idx, in, &columns);
d1563 1
a1563 1
	  idx = exp_get_abs ("% operator needs absolute expression",
d1625 1
a1625 1
    ERROR ((stderr, "misplaced ( .\n"));
d1640 1
a1640 1
    ERROR ((stderr, "misplaced ).\n"));
d1692 1
a1692 1
  if (isdigit (in->ptr[idx]))
d1694 1
a1694 1
      idx = exp_get_abs (".instr needs absolute expresson.\n", idx, in, &start);
d1732 1
a1732 1
  idx = exp_get_abs ("need absolute position.\n", idx, in, &pos);
d1734 1
a1734 1
  idx = exp_get_abs ("need absolute length.\n", idx, in, &len);
d1891 1
a1891 1
	  fprintf (outfile, sb_name (&line));
a1896 7
	  if (label_in.len)
	    {
	      /* Munge any label */

	      
	      process_assigns (0, &label_in, &label);
	    }
d1903 31
d1983 1
a1983 1
    WARNING ((stderr, "END missing from end of file.\n"));
d2013 1
a2013 1
  idx = exp_get_abs (".ASSIGNA needs constant expression argument.\n", 0, &tmp, &val);
d2017 1
a2017 1
      ERROR ((stderr, ".ASSIGNA without label.\n"));
d2042 1
a2042 1
      ERROR ((stderr, ".ASSIGNS without label.\n"));
d2109 1
a2109 1
	  WARNING ((stderr, "Can't find preprocessor variable %s.\n", sb_name (&condass_acc)));
d2174 1
a2174 1
      ERROR ((stderr, "Comparison operator must be one of EQ, NE, LT, LE, GT or GE.\n"));
d2208 1
a2208 1
	  ERROR ((stderr, "Comparison operator for strings must be EQ or NE\n"));
d2220 1
a2220 1
      idx = exp_get_abs ("Conditional operator must have absolute operands.\n", idx, in, &vala);
d2225 1
a2225 1
	  WARNING ((stderr, "String compared against expression.\n"));
d2230 1
a2230 1
	  idx = exp_get_abs ("Conditional operator must have absolute operands.\n", idx, in, &valb);
d2275 1
a2275 1
      FATAL ((stderr, "AIF nesting unreasonable.\n"));
d2290 1
a2290 1
      ERROR ((stderr, "Multiple AELSEs in AIF.\n"));
d2306 1
a2306 1
      ERROR ((stderr, "AENDI without AIF.\n"));
d2329 1
a2329 1
      FATAL ((stderr, "IF nesting unreasonable.\n"));
d2332 1
a2332 1
  idx = exp_get_abs ("Conditional operator must have absolute operands.\n",
d2411 1
a2411 1
      FATAL ((stderr, "IF nesting unreasonable.\n"));
d2421 1
a2421 1
      ERROR ((stderr, "Bad format for IF or IFNC.\n"));
d2441 1
a2441 1
    ERROR ((stderr, "AENDR without a AREPEAT.\n"));
d2443 1
a2443 1
    ERROR ((stderr, "ENDR without a REPT.\n"));
d2466 1
a2466 1
    FATAL ((stderr, "AWHILE without a AENDW at %d.\n", line - 1));
d2504 1
a2504 1
  ERROR ((stderr, "AENDW without a AENDW.\n"));
d2549 1
a2549 1
  idx = exp_get_abs ("AREPEAT must have absolute operand.\n", 0, &exp, &rc);
d2555 1
a2555 1
    FATAL ((stderr, "AREPEAT without a AENDR at %d.\n", line - 1));
d2597 1
a2597 1
  ERROR ((stderr, ".ENDM without a matching .MACRO.\n"));
d2628 2
a2629 2
     int idx;
     sb *line;
d2631 1
a2631 1
  ERROR ((stderr, "LOCAL outside of MACRO"));
d2644 1
a2644 1
    ERROR ((stderr, "macro at line %d: %s\n", line - 1, err));
d2660 1
a2660 1
  if (! check_macro (in->ptr + idx, &out, comment_char, &err))
d2667 1
a2667 1
  sb_add_string (&name, "macro expansion");
d2719 1
a2719 1
	    idx = exp_get_abs ("Character code in string must be absolute expression.\n",
d2724 1
a2724 1
	      ERROR ((stderr, "Missing > for character code.\n"));
d2783 1
a2783 1
		  ERROR ((stderr, "string for SDATAC longer than 255 characters (%d).\n", acc.len));
d2811 1
a2811 1
	  ERROR ((stderr, "illegal character in SDATA line (0x%x).\n", in->ptr[idx]));
d2832 1
a2832 1
  idx = exp_get_abs ("Must have absolute SDATAB repeat count.\n", idx, in, &repeat);
d2835 1
a2835 1
      ERROR ((stderr, "Must have positive SDATAB repeat count (%d).\n", repeat));
d2863 1
a2863 1
    FATAL ((stderr, "Unreasonable include depth (%ld).\n", (long) isp));
d2917 1
a2917 1
	FATAL ((stderr, "Can't open include file `%s'.\n", sb_name (&t)));
d2991 1
a2991 1
    FATAL ((stderr, "Unreasonable expansion (-u turns off check).\n"));
d3212 1
a3212 1
	  WARNING ((stderr, "Unrecognised pseudo op `%s'.\n", sb_name (acc)));
d3279 1
a3279 1
	      ERROR ((stderr, "ORG command not allowed.\n"));
d3312 1
a3312 1
	      do_assign (1, 0, line);
d3330 1
a3330 1
	      do_assign (0, idx, line);
d3496 1
a3496 1
	  exp_get_abs ("Invalid expression on command line.\n", 0, &value, &res);
d3537 1
a3537 1
  fprintf (file, "\
d3545 2
a3546 2
  [-p]      [--print]             print line numbers\n", program_name);
  fprintf (file, "\
d3552 1
a3552 1
  [in-file]\n");
d3554 1
a3554 1
    printf ("\nReport bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d3562 1
a3562 1
  printf ("%s: Gnu Assembler Macro Preprocessor\n",
d3579 5
a3583 1

d3609 1
d3646 3
a3648 3
	  printf ("GNU assembler pre-processor %s\n", program_version);
	  printf ("Copyright 1996 Free Software Foundation, Inc.\n");
	  printf ("\
d3650 1
a3650 1
the GNU General Public License.  This program has absolutely no warranty.\n");
d3669 1
a3669 1
	fprintf (stderr, "%s: Can't open output file `%s'.\n",
d3692 1
a3692 1
	  fprintf (stderr, "%s: Can't open input file `%s'.\n",
d3711 1
a3711 1
  fprintf (stderr, "Internal error, aborting at %s line %d", file, line);
d3714 1
a3714 1
  fprintf (stderr, "\nPlease report this bug.\n");
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995 Free Software Foundation, Inc.
d2641 1
a2641 1
  err = define_macro (idx, in, &label, get_line);
d3552 2
d3639 6
a3644 1
	  printf ("GNU %s version %s\n", program_name, program_version);
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d1416 2
a1417 1
  int al;
d1419 10
d1435 4
a1438 1
  fprintf (outfile, ".align	%d\n", al);
@


1.1
log
@Initial revision
@
text
@d1106 15
a1120 1
      if (idx < in->len - 1 && in->ptr[idx + 1] == '\'' && ! mri)
d1778 12
d1795 1
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d1106 1
a1106 15
      if (in->ptr[idx] == '\\'
	  && idx + 1 < in->len
	  && in->ptr[idx + 1] == '(')
	{
	  idx += 2;
	  while (idx < in->len
		 && in->ptr[idx] != ')')
	    {
	      sb_add_char (out, in->ptr[idx]);
	      idx++;
	    }
	  if (idx < in->len)
	    idx++;
	}
      else if (idx < in->len - 1 && in->ptr[idx + 1] == '\'' && ! mri)
a1763 12
	  && idx + 1 < in->len
	  && in->ptr[idx + 1] == '(')
	{
	  do
	    {
	      sb_add_char (buf, in->ptr[idx]);
	      idx++;
	    }
	  while (idx < in->len && in->ptr[idx - 1] != ')');
	}
      else if (in->ptr[idx] == '\\'
	  && idx + 1 < in->len
a1768 1
	       && idx + 1 < in->len
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d1416 1
a1416 2
  int al, have_fill, fill;

a1417 10
  idx = sb_skip_white (idx, in);
  have_fill = 0;
  fill = 0;
  if (! eol (idx, in))
    {
      idx = sb_skip_comma (idx, in);
      idx = exp_get_abs (".align needs absolute fill value.\n", idx, in,
			 &fill);
      have_fill = 1;
    }
d1424 1
a1424 4
  fprintf (outfile, ".align	%d", al);
  if (have_fill)
    fprintf (outfile, ",%d", fill);
  fprintf (outfile, "\n");
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 1996 Free Software Foundation, Inc.
d2641 1
a2641 1
  err = define_macro (idx, in, &label, get_line, (const char **) NULL);
a3551 2
  if (status == 0)
    printf ("\nReport bugs to bug-gnu-utils@@prep.ai.mit.edu\n");
d3637 1
a3637 6
	  /* This output is intended to follow the GNU standards document.  */
	  printf ("GNU assembler pre-processor %s\n", program_version);
	  printf ("Copyright 1996 Free Software Foundation, Inc.\n");
	  printf ("\
This program is free software; you may redistribute it under the terms of\n\
the GNU General Public License.  This program has absolutely no warranty.\n");
@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 1997 Free Software Foundation, Inc.
a72 5
/* This is normally declared in as.h, but we don't include that.  We
   need the function because other files linked with gasp.c might call
   it.  */
extern void as_abort PARAMS ((const char *, int, const char *));

d473 1
a473 1
	ERROR ((stderr, "redefinition not allowed\n"));
d1920 7
a1932 31
	  if (label_in.len)
	    {
	      int do_assigns;

	      /* Munge the label, unless this is EQU or ASSIGN.  */
	      do_assigns = 1;
	      if (l < line.len
		  && (line.ptr[l] == '.' || alternate || mri))
		{
		  int lx = l;

		  if (line.ptr[lx] == '.')
		    ++lx;
		  if (lx + 3 <= line.len
		      && strncasecmp ("EQU", line.ptr + lx, 3) == 0
		      && (lx + 3 == line.len
			  || ! ISFIRSTCHAR (line.ptr[lx + 3])))
		    do_assigns = 0;
		  else if (lx + 6 <= line.len
			   && strncasecmp ("ASSIGN", line.ptr + lx, 6) == 0
			   && (lx + 6 == line.len
			       || ! ISFIRSTCHAR (line.ptr[lx + 6])))
		    do_assigns = 0;
		}

	      if (do_assigns)
		process_assigns (0, &label_in, &label);
	      else
		sb_add_sb (&label, &label_in);
	    }

d3311 1
a3311 1
	      do_assign (0, 0, line);
d3329 1
a3329 1
	      do_assign (1, idx, line);
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright (C) 1994, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
a51 1
#include "bin-bugs.h"
a69 1
#include "asintl.h"
a77 5
/* The default obstack chunk size.  If we set this to zero, the
   obstack code will use whatever will fit in a 4096 byte block.  This
   is used by the hash table code used by macro.c.  */
int chunksize = 0;

d108 6
a113 6
#define ISCOMMENTCHAR(x) (chartype[(unsigned char)(x)] & COMMENTBIT)
#define ISFIRSTCHAR(x)  (chartype[(unsigned char)(x)] & FIRSTBIT)
#define ISNEXTCHAR(x)   (chartype[(unsigned char)(x)] & NEXTBIT)
#define ISSEP(x)        (chartype[(unsigned char)(x)] & SEPBIT)
#define ISWHITE(x)      (chartype[(unsigned char)(x)] & WHITEBIT)
#define ISBASE(x)       (chartype[(unsigned char)(x)] & BASEBIT)
d189 31
d478 1
a478 1
	ERROR ((stderr, _("redefinition not allowed\n")));
d552 1
a552 1
      ERROR ((stderr, _("the %c operator cannot take non-absolute arguments.\n"), op));
d610 1
a610 1
  if (isdigit ((unsigned char) string->ptr[idx]))
d629 1
a629 1
      ERROR ((stderr, _("string where expression expected.\n")));
d635 1
a635 1
      ERROR ((stderr, _("can't find primary in expression.\n")));
d675 1
a675 1
	ERROR ((stderr, _("misplaced closing parens.\n")));
d712 1
a712 1
	    ERROR ((stderr, _("attempt to divide by zero.\n")));
d744 1
a744 1
	      ERROR ((stderr, _("can't add two relocatable expressions\n")));
d890 1
a890 1
    ERROR ((stderr, "%s", emsg));
d949 1
a949 1
    FATAL ((stderr, _("unreasonable nesting.\n")));
d1027 1
a1027 1
	      WARNING ((stderr, _("End of file not at start of line.\n")));
d1082 1
a1082 1
  if (ISFIRSTCHAR (in->ptr[i]) || in->ptr[i] == '\\')
d1148 1
a1148 1
	      ERROR ((stderr, _("Illegal base character %c.\n"), in->ptr[idx]));
d1168 1
a1168 1
      else if (isdigit ((unsigned char) in->ptr[idx]))
d1263 1
a1263 1
      ERROR ((stderr, _("radix is %c must be one of b, q, d or h"), radix));
d1299 1
a1299 1
      ERROR ((stderr, _("size must be one of b, w or l, is %c.\n"), in->ptr[idx]));
d1381 1
a1381 1
	  fprintf (outfile, "%s", acc.ptr);
d1407 1
a1407 1
  idx = exp_get_abs (_("datab repeat must be constant.\n"), idx, in, &repeat);
d1409 1
a1409 1
  idx = exp_get_abs (_("datab data must be absolute.\n"), idx, in, &fill);
d1423 1
a1423 1
  idx = exp_get_abs (_("align needs absolute expression.\n"), idx, in, &al);
d1430 1
a1430 1
      idx = exp_get_abs (_(".align needs absolute fill value.\n"), idx, in,
d1435 5
d1463 1
a1463 1
      idx = exp_get_abs (_("res needs absolute expression for fill count.\n"), idx, in, &count);
d1543 1
a1543 1
	  idx = exp_get_abs (_("form LIN= needs absolute expresssion.\n"), idx, in, &lines);
d1546 1
a1546 1
      if (strncasecmp (in->ptr + idx, _("COL="), 4) == 0)
d1549 1
a1549 1
	  idx = exp_get_abs (_("form COL= needs absolute expresssion.\n"), idx, in, &columns);
d1591 1
a1591 1
	  idx = exp_get_abs (_("% operator needs absolute expression"),
d1653 1
a1653 1
    ERROR ((stderr, _("misplaced ( .\n")));
d1668 1
a1668 1
    ERROR ((stderr, _("misplaced ).\n")));
d1720 1
a1720 1
  if (isdigit ((unsigned char) in->ptr[idx]))
d1722 1
a1722 1
      idx = exp_get_abs (_(".instr needs absolute expresson.\n"), idx, in, &start);
d1760 1
a1760 1
  idx = exp_get_abs (_("need absolute position.\n"), idx, in, &pos);
d1762 1
a1762 1
  idx = exp_get_abs (_("need absolute length.\n"), idx, in, &len);
d1919 1
a1919 1
	  fprintf (outfile, "%s", sb_name (&line));
d2011 1
a2011 1
    WARNING ((stderr, _("END missing from end of file.\n")));
d2041 1
a2041 1
  idx = exp_get_abs (_(".ASSIGNA needs constant expression argument.\n"), 0, &tmp, &val);
d2045 1
a2045 1
      ERROR ((stderr, _(".ASSIGNA without label.\n")));
d2070 1
a2070 1
      ERROR ((stderr, _(".ASSIGNS without label.\n")));
d2137 1
a2137 1
	  WARNING ((stderr, _("Can't find preprocessor variable %s.\n"), sb_name (&condass_acc)));
d2202 1
a2202 1
      ERROR ((stderr, _("Comparison operator must be one of EQ, NE, LT, LE, GT or GE.\n")));
d2236 1
a2236 1
	  ERROR ((stderr, _("Comparison operator for strings must be EQ or NE\n")));
d2248 1
a2248 1
      idx = exp_get_abs (_("Conditional operator must have absolute operands.\n"), idx, in, &vala);
d2253 1
a2253 1
	  WARNING ((stderr, _("String compared against expression.\n")));
d2258 1
a2258 1
	  idx = exp_get_abs (_("Conditional operator must have absolute operands.\n"), idx, in, &valb);
d2303 1
a2303 1
      FATAL ((stderr, _("AIF nesting unreasonable.\n")));
d2318 1
a2318 1
      ERROR ((stderr, _("Multiple AELSEs in AIF.\n")));
d2334 1
a2334 1
      ERROR ((stderr, _("AENDI without AIF.\n")));
d2357 1
a2357 1
      FATAL ((stderr, _("IF nesting unreasonable.\n")));
d2360 1
a2360 1
  idx = exp_get_abs (_("Conditional operator must have absolute operands.\n"),
d2439 1
a2439 1
      FATAL ((stderr, _("IF nesting unreasonable.\n")));
d2449 1
a2449 1
      ERROR ((stderr, _("Bad format for IF or IFNC.\n")));
d2469 1
a2469 1
    ERROR ((stderr, _("AENDR without a AREPEAT.\n")));
d2471 1
a2471 1
    ERROR ((stderr, _("ENDR without a REPT.\n")));
d2494 1
a2494 1
    FATAL ((stderr, _("AWHILE without a AENDW at %d.\n"), line - 1));
d2532 1
a2532 1
  ERROR ((stderr, _("AENDW without a AENDW.\n")));
d2577 1
a2577 1
  idx = exp_get_abs (_("AREPEAT must have absolute operand.\n"), 0, &exp, &rc);
d2583 1
a2583 1
    FATAL ((stderr, _("AREPEAT without a AENDR at %d.\n"), line - 1));
d2625 1
a2625 1
  ERROR ((stderr, _(".ENDM without a matching .MACRO.\n")));
d2656 2
a2657 2
     int idx ATTRIBUTE_UNUSED;
     sb *line ATTRIBUTE_UNUSED;
d2659 1
a2659 1
  ERROR ((stderr, _("LOCAL outside of MACRO")));
d2672 1
a2672 1
    ERROR ((stderr, _("macro at line %d: %s\n"), line - 1, err));
d2688 1
a2688 1
  if (! check_macro (in->ptr + idx, &out, comment_char, &err, NULL))
d2695 1
a2695 1
  sb_add_string (&name, _("macro expansion"));
d2747 1
a2747 1
	    idx = exp_get_abs (_("Character code in string must be absolute expression.\n"),
d2752 1
a2752 1
	      ERROR ((stderr, _("Missing > for character code.\n")));
d2811 1
a2811 1
		  ERROR ((stderr, _("string for SDATAC longer than 255 characters (%d).\n"), acc.len));
d2839 1
a2839 1
	  ERROR ((stderr, _("illegal character in SDATA line (0x%x).\n"), in->ptr[idx]));
d2860 1
a2860 1
  idx = exp_get_abs (_("Must have absolute SDATAB repeat count.\n"), idx, in, &repeat);
d2863 1
a2863 1
      ERROR ((stderr, _("Must have positive SDATAB repeat count (%d).\n"), repeat));
d2891 1
a2891 1
    FATAL ((stderr, _("Unreasonable include depth (%ld).\n"), (long) isp));
d2945 1
a2945 1
	FATAL ((stderr, _("Can't open include file `%s'.\n"), sb_name (&t)));
d3019 1
a3019 1
    FATAL ((stderr, _("Unreasonable expansion (-u turns off check).\n")));
d3240 1
a3240 1
	  WARNING ((stderr, _("Unrecognised pseudo op `%s'.\n"), sb_name (acc)));
d3307 1
a3307 1
	      ERROR ((stderr, _("ORG command not allowed.\n")));
d3524 1
a3524 1
	  exp_get_abs (_("Invalid expression on command line.\n"), 0, &value, &res);
d3565 1
a3565 1
  fprintf (file, _("\
d3573 2
a3574 2
  [-p]      [--print]             print line numbers\n"), program_name);
  fprintf (file, _("\
d3580 1
a3580 1
  [in-file]\n"));
d3582 1
a3582 1
    printf (_("Report bugs to %s\n"), REPORT_BUGS_TO);
d3590 1
a3590 1
  printf (_("%s: Gnu Assembler Macro Preprocessor\n"),
d3607 1
a3607 5
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);
a3632 1
	    p->next = NULL;
d3669 3
a3671 3
	  printf (_("GNU assembler pre-processor %s\n"), program_version);
	  printf (_("Copyright 1996 Free Software Foundation, Inc.\n"));
	  printf (_("\
d3673 1
a3673 1
the GNU General Public License.  This program has absolutely no warranty.\n"));
d3692 1
a3692 1
	fprintf (stderr, _("%s: Can't open output file `%s'.\n"),
d3715 1
a3715 1
	  fprintf (stderr, _("%s: Can't open input file `%s'.\n"),
d3734 1
a3734 1
  fprintf (stderr, _("Internal error, aborting at %s line %d"), file, line);
d3737 1
a3737 1
  fprintf (stderr, _("\nPlease report this bug.\n"));
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000
d23 1
a23 1
   02111-1307, USA.  */
d26 1
d30 1
d46 1
a46 1
     A %<exp> in a string evaluates the expression
d48 2
d86 2
a87 2
#define MAX_INCLUDES 30		/* Maximum include depth.  */
#define MAX_REASONABLE 1000	/* Maximum number of expansions.  */
d89 9
a97 9
int unreasonable;		/* -u on command line.  */
int stats;			/* -d on command line.  */
int print_line_number;		/* -p flag on command line.  */
int copysource;			/* -c flag on command line.  */
int warnings;			/* Number of WARNINGs generated so far.  */
int errors;			/* Number of ERRORs generated so far.  */
int fatals;			/* Number of fatal ERRORs generated so far (either 0 or 1).  */
int alternate = 0;              /* -a on command line.  */
int mri = 0;			/* -M on command line.  */
d99 1
a99 1
int radix = 10;			/* Default radix.  */
d101 1
a101 1
int had_end; /* Seen .END.  */
d103 1
a103 1
/* The output stream.  */
d106 3
a108 2
/* The attributes of each character are stored as a bit pattern
   chartype, which gives us quick tests.  */
d124 1
d133 6
a138 5
struct {
  int on;			/* Is the level being output.  */
  int hadelse;			/* Has an aelse been seen.  */
} ifstack[IFNESTING];

d143 1
a143 1
   line.  It must be coped somewhere safe before the next line is read in.  */
d145 14
a158 4
typedef struct {
  char *name;
  int len;
} symbol;
a159 5
typedef struct {
  int value;			/* Constant part.  */
  symbol add_symbol;		/* Name part.  */
  symbol sub_symbol;		/* Name part.  */
} exp_t;
d165 30
a194 1
   with the same hash are kept in a chain.  */
a195 24
/* What the data in a hash_entry means.  */
typedef enum {
  hash_integer,			/* Name->integer mapping.  */
  hash_string,			/* Name->string mapping.  */
  hash_macro,			/* Name is a macro.  */
  hash_formal			/* Name is a formal argument.  */
} hash_type;

typedef struct hs {
  sb key;			/* Symbol name.  */
  hash_type type;		/* Symbol meaning.  */
  union {
    sb s;
    int i;
    struct macro_struct *m;
    struct formal_struct *f;
  } value;
  struct hs *next;		/* Next hash_entry with same hash key.  */
} hash_entry;

typedef struct {
  hash_entry **table;
  int size;
} hash_table;
d197 1
a197 1
/* How we nest files and expand macros etc.
d199 2
a200 2
   We keep a stack of of include_stack structs.  Each include file
   pushes a new level onto the stack.  We keep an sb with a pushback
d204 4
a207 4
   Small things are expanded by adding the text of the item onto the
   pushback sb.  Larger items are grown by pushing a new level and
   allocating the entire pushback buf for the item.  Each time
   something like a macro is expanded, the stack index is changed.  We
d209 20
a228 16
   the same stack index.  If we're being reasonable, we can detect
   recusive expansion by checking the index is reasonably small.  */

typedef enum {
  include_file, include_repeat, include_while, include_macro
} include_type;

struct include_stack {
  sb pushback;			/* Current pushback stream.  */
  int pushback_index;		/* Next char to read from stream.  */
  FILE *handle;			/* Open file.  */
  sb name;			/* Name of file.  */
  int linecount;		/* Number of lines read so far.  */
  include_type type;
  int index;			/* Index of this layer.  */
} include_stack[MAX_INCLUDES];
d233 1
a233 1
/* Include file list.  */
d235 2
a236 1
typedef struct include_path {
d239 1
a239 1
} include_path;
d244 1
d337 6
a342 27
#define FATAL(x)				\
  do						\
    {						\
      include_print_where_line (stderr);	\
      fprintf x;				\
      fatals++;					\
      quit ();					\
    }						\
  while (0)

#define ERROR(x)				\
  do						\
    {						\
      include_print_where_line (stderr);	\
      fprintf x;				\
      errors++;					\
    }						\
  while (0)

#define WARNING(x)				\
  do						\
    {						\
      include_print_where_line (stderr);	\
      fprintf x;				\
      warnings++;				\
    }						\
  while (0)
a343 1
/* Exit the program and return the right ERROR code.  */
d345 2
d356 1
a356 1
  if (stats)
d359 1
a359 1
      for (i = 0; i < sb_max_power_two; i++)
d361 1
a361 2
	  fprintf (stderr, "strings size %8d : %d\n",
		   1 << i, string_count[i]);
d367 1
a367 1
/* Hash table maintenance.  */
d369 1
a369 2
/* Build a new hash table with size buckets
   and fill in the info at ptr.  */
d384 1
a384 1
/* Calculate and return the hash value of the sb at key.  */
d401 2
a402 2
/* Look up key in hash_table tab.  If present, then return it,
   otherwise build a new one and fill it with hash_integer.  */
d404 2
a405 1
static hash_entry *
d436 2
a437 2
/* Add sb name with key into hash_table tab.
   If replacing old value and again, then ERROR.  */
d439 2
a440 1
static void
d460 1
a460 1

d464 1
a464 1
/* Add integer name to hash_table tab with sb key.  */
d466 2
a467 1
static void
d477 5
a481 4
/* Look up sb key in hash_table tab.
   If found, return hash_entry result, else 0.  */

static hash_entry *
d499 1
d514 1
a516 2
/* Make sure that the exp_t at term is constant.
   If not the give the op ERROR.  */
d518 4
a521 1
static void
d533 3
a535 2
/* Turn the number in string at idx into a number of base, fill in
   ptr, and return the index of the first character not in the number.  */
d537 2
a538 1
static int
d618 2
d698 1
d723 1
a723 1
	  /* Change nn+symbol to symbol + nn.  */
d797 4
a800 3
/* Parse the expression at offset idx into string, fill up res with
   the result.  Return the index of the first char past the
   expression.  */
d811 3
a813 2
/* Turn the expression at exp into text and glue it onto the end of
   string.  */
d852 4
a855 3
/* Parse the expression at offset idx into sb in.  Return the value in
   val.  If the expression is not constant, give ERROR emsg.  Return
   the index of the first character past the end of the expression.  */
a871 5
/* Current label parsed from line.  */
sb label;

/* Hash table for all assigned variables.  */
hash_table assign_hash_table;
d873 4
a876 5
/* Hash table for keyword.  */
hash_table keyword_hash_table;

/* Hash table for eq variables.  */
hash_table vars;
d889 1
a889 1
      if (ISCOMMENTCHAR (s[i]))
d898 1
a898 1
/* Push back character ch so that it can be read again.  */
d914 1
a914 2
/* Push the sb ptr onto the include stack, with the given name, type
   and index.  */
d916 2
a917 1
static void
a937 2
/* Used in ERROR messages, print info on where the include stack is
   onto file.  */
d939 3
a941 1
static void
d954 1
a954 2
/* Used in listings, print the line number onto file.  */

d976 2
a977 1
/* Read a line from the top of the include stack into sb in.  */
d1025 1
a1025 1
	      /* Continued line.  */
d1050 1
a1050 1
/* Find a label from sb in and put it in out.  */
d1063 1
a1063 1
      while ((ISNEXTCHAR (in->ptr[i])
d1065 1
a1065 1
	      || in->ptr[i] == '&')
d1075 2
a1076 2
/* Find all strange base stuff and turn into decimal.  Also
   find all the other numbers and convert them from the default radix.  */
d1136 1
a1136 1
	  /* Copy entire names through quickly.  */
d1148 2
a1149 2
	  /* All numbers must start with a digit, let's chew it and
	     spit out decimal.  */
d1154 1
a1154 1
	  /* Skip all undigsested letters.  */
d1164 1
a1164 1
	  /* Copy entire names through quickly.  */
d1175 1
a1175 1
	  /* Nothing special, just pass it through.  */
d1183 1
a1183 2
/* .end  */

d1193 1
a1193 1
/* .assign  */
d1201 1
a1201 1
  /* Stick label in symbol table with following value.  */
a1211 1
/* .radix [b|q|d|h]  */
d1213 4
a1216 1
static void
d1244 2
a1245 1
/* Parse off a .b, .w or .l.  */
d1284 2
a1285 2
static int
eol (idx, line)
d1290 1
a1290 1
  if (idx < line->len
d1298 2
a1299 2
/* .data [.b|.w|.l] <data>*
    or d[bwl] <data>*  */
d1312 1
a1312 1
  if (!size)
d1316 3
a1318 4
  else
    {
      opsize = size;
    }
d1332 1
d1335 1
a1335 1
  idx = sb_skip_white (idx, in);
d1337 2
a1338 2
  if (alternate
      && idx < in->len
d1346 1
a1346 1
	    fprintf (outfile, ",");
d1350 1
a1350 1
  else
d1371 1
a1371 1
/* .datab [.b|.w|.l] <repeat>,<fill>  */
d1391 1
a1391 1
/* .align <size>  */
d1418 1
a1418 1
/* .res[.b|.w|.l] <size>  */
d1430 1
a1430 1
  while (!eol (idx, in))
d1444 2
a1445 1
/* .export  */
d1454 1
a1454 1
/* .print [list] [nolist]  */
d1478 1
a1478 2
/* .head  */

d1491 1
a1491 1
/* .page  */
d1499 1
a1499 2
/* .form [lin=<value>] [col=<value>]  */

d1530 1
a1537 1

d1551 1
a1551 1
      if (in->len > 2 && in->ptr[idx + 1] == '\'' && ISBASE (in->ptr[idx]))
d1562 1
a1562 1
	  /* Turns the next expression into a string.  */
d1567 1
a1567 1
	  sprintf (buf, "%d", val);
d1576 5
a1580 5
	      /* Keep the quotes.  */
	      sb_add_char (out, '\"');

	      idx = getstring (idx, in, out);
	      sb_add_char (out, '\"');
d1583 3
a1585 4
	  else
	    {
	      idx = getstring (idx, in, out);
	    }
d1587 1
a1587 1
      else
d1589 1
a1589 1
	  while (idx < in->len
d1592 1
a1592 1
		     || pretend_quoted
d1595 1
a1595 1
	      if (in->ptr[idx] == '"'
d1602 1
a1602 1
		    sb_add_char (out, in->ptr[idx++]);
d1604 1
a1604 1
		    return idx;
d1614 3
a1616 2
/* Skip along sb in starting at idx, suck off whitespace a ( and more
   whitespace.  Return the idx of the next char.  */
d1630 2
a1631 2
/* Skip along sb in starting at idx, suck off whitespace a ) and more
   whitespace.  Return the idx of the next char.  */
d1645 1
a1645 1
/* .len  */
a1667 1
/* .instr  */
d1669 4
a1672 1
static int
d1717 1
d1737 1
d1744 1
a1744 1
  else
d1754 1
a1754 1
  sb_kill (&string);
d1758 1
a1758 2
/* Scan line, change tokens in the hash table to their replacements.  */

d1816 1
a1816 1
	  /* May be a simple name subsitution, see if we have a word.  */
d1828 1
a1828 1
	      /* Found a definition for it.  */
d1833 1
a1833 1
	      /* No definition, just copy the word.  */
d1860 2
a1861 1
static void
d1873 1
a1873 1
  sb_new (&acc);
d1879 1
a1879 1
      /* Find any label and pseudo op that we're intested in.  */
d1896 1
a1896 1
	  sb_reset (&label);
d1939 2
d1947 1
d1958 1
a1958 1
			sb_reset (&t1);
d1967 7
a1973 8
	  else
	    {
	      /* Only a label on this line.  */
	      if (label.len && condass_on ())
		{
		  fprintf (outfile, "%s:\n", sb_name (&label));
		}
	    }
d1986 4
d1997 1
a1997 1
	sb_kill (&ptr->value.s);
d2001 1
a2001 1
/* name: .ASSIGNA <value>  */
d2029 1
a2029 1
/* name: .ASSIGNC <string>  */
d2055 2
a2056 1
/* name: .REG (reg)  */
d2063 1
a2063 1
  /* Remove reg stuff from inside parens.  */
d2082 1
d2104 1
d2107 1
a2107 1
      if (warn)
d2111 1
a2111 1
      else
d2200 1
a2200 1
      /* This is a string comparision.  */
d2204 1
a2204 2
      same = acc_a.len == acc_b.len
	&& (strncmp (acc_a.ptr, acc_b.ptr, acc_a.len) == 0);
d2215 1
a2215 1
    /* This is a numeric expression.  */
d2267 1
a2267 2
/* .AIF  */

d2278 1
a2278 1
  ifstack[ifi].on = ifstack[ifi - 1].on ? istrue (idx, in) : 0;
a2281 1
/* .AELSE  */
d2283 1
d2287 1
a2287 1
  ifstack[ifi].on = ifstack[ifi - 1].on ? !ifstack[ifi].on : 0;
a2294 1
/* .AENDI  */
d2296 1
d2346 1
a2346 1
  ifstack[ifi].on = ifstack[ifi - 1].on ? res : 0;
d2397 1
a2397 1
/* MRI IFC, IFNC  */
d2432 1
a2432 1
  ifstack[ifi].on = ifstack[ifi - 1].on ? res : 0;
d2436 1
a2436 2
/* .ENDR  */

d2446 1
a2446 1
/* .AWHILE  */
d2448 2
a2449 1
static void
d2477 1
a2477 1
  */
d2490 1
a2490 1
      /* Push another WHILE.  */
d2498 2
a2499 1
/* .AENDW  */
d2507 1
d2509 2
a2510 2

   Pop things off the include stack until the type and index changes.  */
d2530 1
a2530 1
/* .AREPEAT  */
d2538 3
a2540 3
  sb exp;			/* Buffer with expression in it.  */
  sb copy;			/* Expanded repeat block.  */
  sb sub;			/* Contents of AREPEAT.  */
d2568 1
a2568 1
      */
d2592 1
a2592 1
/* .ENDM  */
d2622 1
a2622 3
/* Macro processing.  */

/* Parse off LOCAL n1, n2,... Invent a label name for it.  */
d2624 3
a2626 1
static void
d2677 1
a2677 1
/* String handling.  */
d2688 2
a2689 2
	 && (in->ptr[idx] == '"'
	     || in->ptr[idx] == '<'
d2703 1
a2703 9
		      idx++;
		      sb_add_char (acc, in->ptr[idx++]);
		    }
		  else
		    {
		      if (in->ptr[idx] == '>')
			nest--;
		      if (in->ptr[idx] == '<')
			nest++;
d2706 7
d2716 6
a2721 7
	  else
	    {
	      int code;
	      idx++;
	      idx = exp_get_abs (_("Character code in string must be absolute expression.\n"),
				 idx, in, &code);
	      sb_add_char (acc, code);
d2723 4
a2726 4
	      if (in->ptr[idx] != '>')
		ERROR ((stderr, _("Missing > for character code.\n")));
	      idx++;
	    }
d2736 1
a2736 1
		  idx++;
d2739 10
a2748 11
	      else
		{
		  if (in->ptr[idx] == tchar)
		    {
		      idx++;
		      if (idx >= in->len || in->ptr[idx] != tchar)
			break;
		    }
		  sb_add_char (acc, in->ptr[idx]);
		  idx++;
		}
d2752 1
a2752 1

d2756 1
a2756 1
/* .SDATA[C|Z] <string>  */
d2758 2
a2759 1
static void
d2806 1
a2806 2
	  if (idx == pidx)
	    break;
d2811 1
a2811 2
	  ERROR ((stderr, _("illegal character in SDATA line (0x%x).\n"),
		  in->ptr[idx]));
d2820 1
a2820 1
/* .SDATAB <count> <string>  */
d2936 1
a2936 1
   the stack and try again.  Keep the linecount up to date.  */
d2946 1
a2946 1
      /* When they've all gone, reset the pointer.  */
d2995 2
a2996 1
/* Initialize the chartype vector.  */
d3022 1
a3022 1

d3031 5
a3035 3
/* What to do with all the keywords.  */
#define PROCESS 	0x1000  /* Run substitution over the line.  */
#define LAB		0x2000  /* Spit out the label.  */
d3092 3
a3094 1
struct keyword {
d3100 2
a3101 1
static struct keyword kinfo[] = {
d3152 2
a3153 1
static struct keyword mrikinfo[] = {
d3173 1
a3173 1
   its handler.  */
d3185 1
a3185 1
      /* Scan forward and find pseudo name.  */
d3211 2
a3212 3
	     ordinary code.  */
	  WARNING ((stderr, _("Unrecognised pseudo op `%s'.\n"),
		    sb_name (acc)));
d3217 1
a3217 2
	{
	  /* Output the label.  */
d3238 1
a3238 1
	  /* Polish the rest of the line before handling the pseudo op.  */
d3240 1
a3240 1
	  strip_comments (line);
d3244 1
a3244 1
	  sb_reset (line);
d3430 2
d3453 1
a3453 1
}
d3456 1
a3456 1
   once upper and once lower case.  */
d3473 1
d3483 1
d3486 1
a3486 1
      if (*string == '=')
d3496 1
a3496 2
	  exp_get_abs (_("Invalid expression on command line.\n"),
		       0, &value, &res);
d3502 1
a3502 1
      string++;
a3510 1

a3558 1

d3562 2
a3563 1
  printf (_("%s: Gnu Assembler Macro Preprocessor\n"), program_name);
d3643 1
a3643 1
	  /* NOTREACHED  */
d3652 1
a3652 1
	  /* NOTREACHED  */
d3657 1
a3657 1
	  /* NOTREACHED  */
d3665 12
a3676 14
  if (out_name)
    {
      outfile = fopen (out_name, "w");
      if (!outfile)
	{
	  fprintf (stderr, _("%s: Can't open output file `%s'.\n"),
		   program_name, out_name);
	  exit (1);
	}
    }
  else
    {
      outfile = stdout;
    }
d3682 1
a3682 1
  /* Process all the input files.  */
@


