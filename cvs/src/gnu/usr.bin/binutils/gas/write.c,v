head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.48
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.44
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.46
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.38
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.42
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.40
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.36
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.34
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.32
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.30
	OPENBSD_5_0:1.8.0.28
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.26
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.24
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.20
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.22
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.18
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.16
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	BINUTILS_2_15:1.1.1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	BINUTILS-2_14:1.1.1.8
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	binutils-2_11_2:1.1.1.7
	OPENBSD_3_1:1.5.0.8
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	BINUTILS-2_10_1:1.1.1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	BINUTILS-2_10:1.1.1.6
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	new-binutils:1.4.0.14
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	BINUTILS-2_8_1:1.1.1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	CYGNUS-961112:1.1.1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	CYGNUS-960904:1.1.1.3
	CYGNUS-960609:1.1.1.2
	CYGNUS:1.1.1
	FSF_2_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.11.02.20.45.25;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.17.21.54.29;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.13.17.07.34;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.12.19.11.44;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.03.34.30;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.09.04.19.05.02;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.10.50.50;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.01.08.11.05.46;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.08.11.05.46;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.06.09.19.39.50;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.09.04.17.43.55;	author niklas;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.11.19.14.14.11;	author niklas;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.05.29.09.22.23;	author niklas;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.09.12.14.46.16;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.05.13.13.32.43;	author fgsch;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.05.17.20.42.26;	author drahn;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2004.11.02.20.22.45;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge conflicts, bringing our changes back in:
- extra $(SHELL) and sugar for make (so that files not mode +x still work)
- safer temp file handling
- our W^X binary layout changes in ld
- OpenBSD policy for library file selection in ld
- arm and m88k changes which were not merged in time for official 2.15
- bfd core file handling
- a couple typos

New for 2.15:
- ld(1) and as(1) manpages now generated at build time
- binutils/stabs.c reverted to use our in-tree libiberty for now
- we still use our VIA C3 crypto code over stock binutils, as it recognizes
  more instructions
- new emulations for OpenBSD on mips64 machines, to help OpenBSD/sgi
- relaxed %f# handling in gas on OpenBSD/sparc64 (same as was in 2.14)

Tested on all platforms by various people; special thanks to sturm@@ and
otto@@.
@
text
@/* write.c - emit .o file
   Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

/* This thing should be set up to do byteordering correctly.  But...  */

#include "as.h"
#include "subsegs.h"
#include "obstack.h"
#include "output-file.h"
#include "dwarf2dbg.h"

#ifndef TC_ADJUST_RELOC_COUNT
#define TC_ADJUST_RELOC_COUNT(FIX, COUNT)
#endif

#ifndef TC_FORCE_RELOCATION
#define TC_FORCE_RELOCATION(FIX)		\
  (generic_force_reloc (FIX))
#endif

#ifndef TC_FORCE_RELOCATION_ABS
#define TC_FORCE_RELOCATION_ABS(FIX)		\
  (TC_FORCE_RELOCATION (FIX))
#endif

#ifndef TC_FORCE_RELOCATION_LOCAL
#define TC_FORCE_RELOCATION_LOCAL(FIX)		\
  (!(FIX)->fx_pcrel				\
   || (FIX)->fx_plt				\
   || TC_FORCE_RELOCATION (FIX))
#endif

#ifndef TC_FORCE_RELOCATION_SUB_SAME
#define TC_FORCE_RELOCATION_SUB_SAME(FIX, SEG)	\
  (! SEG_NORMAL (SEG))
#endif

#ifndef TC_FORCE_RELOCATION_SUB_ABS
#define TC_FORCE_RELOCATION_SUB_ABS(FIX)	0
#endif

#ifndef TC_FORCE_RELOCATION_SUB_LOCAL
#ifdef DIFF_EXPR_OK
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX)	0
#else
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX)	1
#endif
#endif

#ifndef TC_VALIDATE_FIX_SUB
#ifdef UNDEFINED_DIFFERENCE_OK
/* The PA needs this for PIC code generation.  */
#define TC_VALIDATE_FIX_SUB(FIX) 1
#else
#ifdef BFD_ASSEMBLER
#define TC_VALIDATE_FIX_SUB(FIX)		\
  ((FIX)->fx_r_type == BFD_RELOC_GPREL32	\
   || (FIX)->fx_r_type == BFD_RELOC_GPREL16)
#else
#define TC_VALIDATE_FIX_SUB(FIX) 0
#endif
#endif
#endif

#ifndef TC_LINKRELAX_FIXUP
#define TC_LINKRELAX_FIXUP(SEG) 1
#endif

#ifndef MD_APPLY_SYM_VALUE
#define MD_APPLY_SYM_VALUE(FIX) 1
#endif

#ifndef TC_FINALIZE_SYMS_BEFORE_SIZE_SEG
#define TC_FINALIZE_SYMS_BEFORE_SIZE_SEG 1
#endif

#ifndef	MD_PCREL_FROM_SECTION
#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from (FIX)
#endif

#ifndef WORKING_DOT_WORD
extern const int md_short_jump_size;
extern const int md_long_jump_size;
#endif

/* Used to control final evaluation of expressions.  */
int finalize_syms = 0;

int symbol_table_frozen;

symbolS *abs_section_sym;

/* Remember the value of dot when parsing expressions.  */
addressT dot_value;

void print_fixup (fixS *);

#ifdef BFD_ASSEMBLER
static void renumber_sections (bfd *, asection *, PTR);

/* We generally attach relocs to frag chains.  However, after we have
   chained these all together into a segment, any relocs we add after
   that must be attached to a segment.  This will include relocs added
   in md_estimate_size_for_relax, for example.  */
static int frags_chained = 0;
#endif

#ifndef BFD_ASSEMBLER

#ifndef MANY_SEGMENTS
struct frag *text_frag_root;
struct frag *data_frag_root;
struct frag *bss_frag_root;

struct frag *text_last_frag;	/* Last frag in segment.  */
struct frag *data_last_frag;	/* Last frag in segment.  */
static struct frag *bss_last_frag;	/* Last frag in segment.  */
#endif

#ifndef BFD
static object_headers headers;
#endif

long string_byte_count;
char *next_object_file_charP;	/* Tracks object file bytes.  */

#ifndef OBJ_VMS
int magic_number_for_object_file = DEFAULT_MAGIC_NUMBER_FOR_OBJECT_FILE;
#endif

#endif /* BFD_ASSEMBLER  */

static int n_fixups;

#ifdef BFD_ASSEMBLER
#define RELOC_ENUM enum bfd_reloc_code_real
#else
#define RELOC_ENUM int
#endif

static fixS *fix_new_internal (fragS *, int where, int size,
			       symbolS *add, symbolS *sub,
			       offsetT offset, int pcrel,
			       RELOC_ENUM r_type);
#if defined (BFD_ASSEMBLER) || (!defined (BFD) && !defined (OBJ_VMS))
static long fixup_segment (fixS *, segT);
#endif
static relax_addressT relax_align (relax_addressT addr, int align);
#if defined (BFD_ASSEMBLER) || ! defined (BFD)
static fragS *chain_frchains_together_1 (segT, struct frchain *);
#endif
#ifdef BFD_ASSEMBLER
static void chain_frchains_together (bfd *, segT, PTR);
static void cvt_frag_to_fill (segT, fragS *);
static void adjust_reloc_syms (bfd *, asection *, PTR);
static void fix_segment (bfd *, asection *, PTR);
static void write_relocs (bfd *, asection *, PTR);
static void write_contents (bfd *, asection *, PTR);
static void set_symtab (void);
#endif
#if defined (BFD_ASSEMBLER) || (! defined (BFD) && ! defined (OBJ_AOUT))
static void merge_data_into_text (void);
#endif
#if ! defined (BFD_ASSEMBLER) && ! defined (BFD)
static void cvt_frag_to_fill (object_headers *, segT, fragS *);
static void remove_subsegs (frchainS *, int, fragS **, fragS **);
static void relax_and_size_all_segments (void);
#endif

/* Create a fixS in obstack 'notes'.  */

static fixS *
fix_new_internal (fragS *frag,		/* Which frag?  */
		  int where,		/* Where in that frag?  */
		  int size,		/* 1, 2, or 4 usually.  */
		  symbolS *add_symbol,	/* X_add_symbol.  */
		  symbolS *sub_symbol,	/* X_op_symbol.  */
		  offsetT offset,	/* X_add_number.  */
		  int pcrel,		/* TRUE if PC-relative relocation.  */
		  RELOC_ENUM r_type ATTRIBUTE_UNUSED /* Relocation type.  */)
{
  fixS *fixP;

  n_fixups++;

  fixP = (fixS *) obstack_alloc (&notes, sizeof (fixS));

  fixP->fx_frag = frag;
  fixP->fx_where = where;
  fixP->fx_size = size;
  /* We've made fx_size a narrow field; check that it's wide enough.  */
  if (fixP->fx_size != size)
    {
      as_bad (_("field fx_size too small to hold %d"), size);
      abort ();
    }
  fixP->fx_addsy = add_symbol;
  fixP->fx_subsy = sub_symbol;
  fixP->fx_offset = offset;
  fixP->fx_dot_value = dot_value;
  fixP->fx_pcrel = pcrel;
  fixP->fx_plt = 0;
#if defined(NEED_FX_R_TYPE) || defined (BFD_ASSEMBLER)
  fixP->fx_r_type = r_type;
#endif
  fixP->fx_im_disp = 0;
  fixP->fx_pcrel_adjust = 0;
  fixP->fx_bit_fixP = 0;
  fixP->fx_addnumber = 0;
  fixP->fx_tcbit = 0;
  fixP->fx_done = 0;
  fixP->fx_no_overflow = 0;
  fixP->fx_signed = 0;

#ifdef USING_CGEN
  fixP->fx_cgen.insn = NULL;
  fixP->fx_cgen.opinfo = 0;
#endif

#ifdef TC_FIX_TYPE
  TC_INIT_FIX_DATA (fixP);
#endif

  as_where (&fixP->fx_file, &fixP->fx_line);

  /* Usually, we want relocs sorted numerically, but while
     comparing to older versions of gas that have relocs
     reverse sorted, it is convenient to have this compile
     time option.  xoxorich.  */
  {

#ifdef BFD_ASSEMBLER
    fixS **seg_fix_rootP = (frags_chained
			    ? &seg_info (now_seg)->fix_root
			    : &frchain_now->fix_root);
    fixS **seg_fix_tailP = (frags_chained
			    ? &seg_info (now_seg)->fix_tail
			    : &frchain_now->fix_tail);
#endif

#ifdef REVERSE_SORT_RELOCS

    fixP->fx_next = *seg_fix_rootP;
    *seg_fix_rootP = fixP;

#else /* REVERSE_SORT_RELOCS  */

    fixP->fx_next = NULL;

    if (*seg_fix_tailP)
      (*seg_fix_tailP)->fx_next = fixP;
    else
      *seg_fix_rootP = fixP;
    *seg_fix_tailP = fixP;

#endif /* REVERSE_SORT_RELOCS  */
  }

  return fixP;
}

/* Create a fixup relative to a symbol (plus a constant).  */

fixS *
fix_new (fragS *frag,		/* Which frag?  */
	 int where,			/* Where in that frag?  */
	 int size,			/* 1, 2, or 4 usually.  */
	 symbolS *add_symbol,	/* X_add_symbol.  */
	 offsetT offset,		/* X_add_number.  */
	 int pcrel,			/* TRUE if PC-relative relocation.  */
	 RELOC_ENUM r_type		/* Relocation type.  */)
{
  return fix_new_internal (frag, where, size, add_symbol,
			   (symbolS *) NULL, offset, pcrel, r_type);
}

/* Create a fixup for an expression.  Currently we only support fixups
   for difference expressions.  That is itself more than most object
   file formats support anyhow.  */

fixS *
fix_new_exp (fragS *frag,		/* Which frag?  */
	     int where,			/* Where in that frag?  */
	     int size,			/* 1, 2, or 4 usually.  */
	     expressionS *exp,		/* Expression.  */
	     int pcrel,			/* TRUE if PC-relative relocation.  */
	     RELOC_ENUM r_type		/* Relocation type.  */)
{
  symbolS *add = NULL;
  symbolS *sub = NULL;
  offsetT off = 0;

  switch (exp->X_op)
    {
    case O_absent:
      break;

    case O_register:
      as_bad (_("register value used as expression"));
      break;

    case O_add:
      /* This comes up when _GLOBAL_OFFSET_TABLE_+(.-L0) is read, if
	 the difference expression cannot immediately be reduced.  */
      {
	symbolS *stmp = make_expr_symbol (exp);

	exp->X_op = O_symbol;
	exp->X_op_symbol = 0;
	exp->X_add_symbol = stmp;
	exp->X_add_number = 0;

	return fix_new_exp (frag, where, size, exp, pcrel, r_type);
      }

    case O_symbol_rva:
      add = exp->X_add_symbol;
      off = exp->X_add_number;

#if defined(BFD_ASSEMBLER)
      r_type = BFD_RELOC_RVA;
#else
#if defined(TC_RVA_RELOC)
      r_type = TC_RVA_RELOC;
#else
      as_fatal (_("rva not supported"));
#endif
#endif
      break;

    case O_uminus:
      sub = exp->X_add_symbol;
      off = exp->X_add_number;
      break;

    case O_subtract:
      sub = exp->X_op_symbol;
      /* Fall through.  */
    case O_symbol:
      add = exp->X_add_symbol;
      /* Fall through.  */
    case O_constant:
      off = exp->X_add_number;
      break;

    default:
      add = make_expr_symbol (exp);
      break;
    }

  return fix_new_internal (frag, where, size, add, sub, off, pcrel, r_type);
}

/* Generic function to determine whether a fixup requires a relocation.  */
int
generic_force_reloc (fixS *fix)
{
#ifdef BFD_ASSEMBLER
  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;
#endif
  return S_FORCE_RELOC (fix->fx_addsy, fix->fx_subsy == NULL);
}

/* Append a string onto another string, bumping the pointer along.  */
void
append (char **charPP, char *fromP, unsigned long length)
{
  /* Don't trust memcpy() of 0 chars.  */
  if (length == 0)
    return;

  memcpy (*charPP, fromP, length);
  *charPP += length;
}

#ifndef BFD_ASSEMBLER
int section_alignment[SEG_MAXIMUM_ORDINAL];
#endif

/* This routine records the largest alignment seen for each segment.
   If the beginning of the segment is aligned on the worst-case
   boundary, all of the other alignments within it will work.  At
   least one object format really uses this info.  */

void
record_alignment (/* Segment to which alignment pertains.  */
		  segT seg,
		  /* Alignment, as a power of 2 (e.g., 1 => 2-byte
		     boundary, 2 => 4-byte boundary, etc.)  */
		  int align)
{
  if (seg == absolute_section)
    return;
#ifdef BFD_ASSEMBLER
  if ((unsigned int) align > bfd_get_section_alignment (stdoutput, seg))
    bfd_set_section_alignment (stdoutput, seg, align);
#else
  if (align > section_alignment[(int) seg])
    section_alignment[(int) seg] = align;
#endif
}

int
get_recorded_alignment (segT seg)
{
  if (seg == absolute_section)
    return 0;
#ifdef BFD_ASSEMBLER
  return bfd_get_section_alignment (stdoutput, seg);
#else
  return section_alignment[(int) seg];
#endif
}

#ifdef BFD_ASSEMBLER

/* Reset the section indices after removing the gas created sections.  */

static void
renumber_sections (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, PTR countparg)
{
  int *countp = (int *) countparg;

  sec->index = *countp;
  ++*countp;
}

#endif /* defined (BFD_ASSEMBLER)  */

#if defined (BFD_ASSEMBLER) || ! defined (BFD)

static fragS *
chain_frchains_together_1 (segT section, struct frchain *frchp)
{
  fragS dummy, *prev_frag = &dummy;
#ifdef BFD_ASSEMBLER
  fixS fix_dummy, *prev_fix = &fix_dummy;
#endif

  for (; frchp && frchp->frch_seg == section; frchp = frchp->frch_next)
    {
      prev_frag->fr_next = frchp->frch_root;
      prev_frag = frchp->frch_last;
      assert (prev_frag->fr_type != 0);
#ifdef BFD_ASSEMBLER
      if (frchp->fix_root != (fixS *) NULL)
	{
	  if (seg_info (section)->fix_root == (fixS *) NULL)
	    seg_info (section)->fix_root = frchp->fix_root;
	  prev_fix->fx_next = frchp->fix_root;
	  seg_info (section)->fix_tail = frchp->fix_tail;
	  prev_fix = frchp->fix_tail;
	}
#endif
    }
  assert (prev_frag->fr_type != 0);
  prev_frag->fr_next = 0;
  return prev_frag;
}

#endif

#ifdef BFD_ASSEMBLER

static void
chain_frchains_together (bfd *abfd ATTRIBUTE_UNUSED,
			 segT section,
			 PTR xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *info;

  /* BFD may have introduced its own sections without using
     subseg_new, so it is possible that seg_info is NULL.  */
  info = seg_info (section);
  if (info != (segment_info_type *) NULL)
    info->frchainP->frch_last
      = chain_frchains_together_1 (section, info->frchainP);

  /* Now that we've chained the frags together, we must add new fixups
     to the segment, not to the frag chain.  */
  frags_chained = 1;
}

#endif

#if !defined (BFD) && !defined (BFD_ASSEMBLER)

static void
remove_subsegs (frchainS *head, int seg, fragS **root, fragS **last)
{
  *root = head->frch_root;
  *last = chain_frchains_together_1 (seg, head);
}

#endif /* BFD  */

#if defined (BFD_ASSEMBLER) || !defined (BFD)

#ifdef BFD_ASSEMBLER
static void
cvt_frag_to_fill (segT sec ATTRIBUTE_UNUSED, fragS *fragP)
#else
static void
cvt_frag_to_fill (object_headers *headersP, segT sec, fragS *fragP)
#endif
{
  switch (fragP->fr_type)
    {
    case rs_align:
    case rs_align_code:
    case rs_align_test:
    case rs_org:
    case rs_space:
#ifdef HANDLE_ALIGN
      HANDLE_ALIGN (fragP);
#endif
      know (fragP->fr_next != NULL);
      fragP->fr_offset = (fragP->fr_next->fr_address
			  - fragP->fr_address
			  - fragP->fr_fix) / fragP->fr_var;
      if (fragP->fr_offset < 0)
	{
	  as_bad_where (fragP->fr_file, fragP->fr_line,
			_("attempt to .org/.space backwards? (%ld)"),
			(long) fragP->fr_offset);
	  fragP->fr_offset = 0;
	}
      fragP->fr_type = rs_fill;
      break;

    case rs_fill:
      break;

    case rs_leb128:
      {
	valueT value = S_GET_VALUE (fragP->fr_symbol);
	int size;

	size = output_leb128 (fragP->fr_literal + fragP->fr_fix, value,
			      fragP->fr_subtype);

	fragP->fr_fix += size;
	fragP->fr_type = rs_fill;
	fragP->fr_var = 0;
	fragP->fr_offset = 0;
	fragP->fr_symbol = NULL;
      }
      break;

    case rs_cfa:
      eh_frame_convert_frag (fragP);
      break;

    case rs_dwarf2dbg:
      dwarf2dbg_convert_frag (fragP);
      break;

    case rs_machine_dependent:
#ifdef BFD_ASSEMBLER
      md_convert_frag (stdoutput, sec, fragP);
#else
      md_convert_frag (headersP, sec, fragP);
#endif

      assert (fragP->fr_next == NULL
	      || ((offsetT) (fragP->fr_next->fr_address - fragP->fr_address)
		  == fragP->fr_fix));

      /* After md_convert_frag, we make the frag into a ".space 0".
	 md_convert_frag() should set up any fixSs and constants
	 required.  */
      frag_wane (fragP);
      break;

#ifndef WORKING_DOT_WORD
    case rs_broken_word:
      {
	struct broken_word *lie;

	if (fragP->fr_subtype)
	  {
	    fragP->fr_fix += md_short_jump_size;
	    for (lie = (struct broken_word *) (fragP->fr_symbol);
		 lie && lie->dispfrag == fragP;
		 lie = lie->next_broken_word)
	      if (lie->added == 1)
		fragP->fr_fix += md_long_jump_size;
	  }
	frag_wane (fragP);
      }
      break;
#endif

    default:
      BAD_CASE (fragP->fr_type);
      break;
    }
}

#endif /* defined (BFD_ASSEMBLER) || !defined (BFD)  */

#ifdef BFD_ASSEMBLER
static void relax_seg (bfd *, asection *, PTR);

static void
relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, PTR xxx)
{
  segment_info_type *seginfo = seg_info (sec);

  if (seginfo && seginfo->frchainP
      && relax_segment (seginfo->frchainP->frch_root, sec))
    {
      int *result = (int *) xxx;
      *result = 1;
    }
}

static void size_seg (bfd *, asection *, PTR);

static void
size_seg (bfd *abfd, asection *sec, PTR xxx ATTRIBUTE_UNUSED)
{
  flagword flags;
  fragS *fragp;
  segment_info_type *seginfo;
  int x;
  valueT size, newsize;

  subseg_change (sec, 0);

  seginfo = seg_info (sec);
  if (seginfo && seginfo->frchainP)
    {
      for (fragp = seginfo->frchainP->frch_root; fragp; fragp = fragp->fr_next)
	cvt_frag_to_fill (sec, fragp);
      for (fragp = seginfo->frchainP->frch_root;
	   fragp->fr_next;
	   fragp = fragp->fr_next)
	/* Walk to last elt.  */
	;
      size = fragp->fr_address + fragp->fr_fix;
    }
  else
    size = 0;

  flags = bfd_get_section_flags (abfd, sec);

  if (size > 0 && ! seginfo->bss)
    flags |= SEC_HAS_CONTENTS;

  /* @@@@ This is just an approximation.  */
  if (seginfo && seginfo->fix_root)
    flags |= SEC_RELOC;
  else
    flags &= ~SEC_RELOC;
  x = bfd_set_section_flags (abfd, sec, flags);
  assert (x);

  newsize = md_section_align (sec, size);
  x = bfd_set_section_size (abfd, sec, newsize);
  assert (x);

  /* If the size had to be rounded up, add some padding in the last
     non-empty frag.  */
  assert (newsize >= size);
  if (size != newsize)
    {
      fragS *last = seginfo->frchainP->frch_last;
      fragp = seginfo->frchainP->frch_root;
      while (fragp->fr_next != last)
	fragp = fragp->fr_next;
      last->fr_address = size;
      if ((newsize - size) % fragp->fr_var == 0)
	fragp->fr_offset += (newsize - size) / fragp->fr_var;
      else
	/* If we hit this abort, it's likely due to subsegs_finish not
	   providing sufficient alignment on the last frag, and the
	   machine dependent code using alignment frags with fr_var
	   greater than 1.  */
	abort ();
    }

#ifdef tc_frob_section
  tc_frob_section (sec);
#endif
#ifdef obj_frob_section
  obj_frob_section (sec);
#endif
}

#ifdef DEBUG2
static void
dump_section_relocs (abfd, sec, stream_)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     char *stream_;
{
  FILE *stream = (FILE *) stream_;
  segment_info_type *seginfo = seg_info (sec);
  fixS *fixp = seginfo->fix_root;

  if (!fixp)
    return;

  fprintf (stream, "sec %s relocs:\n", sec->name);
  while (fixp)
    {
      symbolS *s = fixp->fx_addsy;

      fprintf (stream, "  %08lx: type %d ", (unsigned long) fixp,
	       (int) fixp->fx_r_type);
      if (s == NULL)
	fprintf (stream, "no sym\n");
      else
	{
	  print_symbol_value_1 (stream, s);
	  fprintf (stream, "\n");
	}
      fixp = fixp->fx_next;
    }
}
#else
#define dump_section_relocs(ABFD,SEC,STREAM)	((void) 0)
#endif

#ifndef EMIT_SECTION_SYMBOLS
#define EMIT_SECTION_SYMBOLS 1
#endif

/* This pass over fixups decides whether symbols can be replaced with
   section symbols.  */

static void
adjust_reloc_syms (bfd *abfd ATTRIBUTE_UNUSED,
		   asection *sec,
		   PTR xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  fixS *fixp;

  if (seginfo == NULL)
    return;

  dump_section_relocs (abfd, sec, stderr);

  for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
    if (fixp->fx_done)
      /* Ignore it.  */
      ;
    else if (fixp->fx_addsy)
      {
	symbolS *sym;
	asection *symsec;

#ifdef DEBUG5
	fprintf (stderr, "\n\nadjusting fixup:\n");
	print_fixup (fixp);
#endif

	sym = fixp->fx_addsy;

	/* All symbols should have already been resolved at this
	   point.  It is possible to see unresolved expression
	   symbols, though, since they are not in the regular symbol
	   table.  */
	resolve_symbol_value (sym);

	if (fixp->fx_subsy != NULL)
	  resolve_symbol_value (fixp->fx_subsy);

	/* If this symbol is equated to an undefined symbol, convert
           the fixup to being against that symbol.  */
	if (symbol_equated_reloc_p (sym))
	  {
	    fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
	    sym = symbol_get_value_expression (sym)->X_add_symbol;
	    fixp->fx_addsy = sym;
	  }

	if (symbol_mri_common_p (sym))
	  {
	    /* These symbols are handled specially in fixup_segment.  */
	    continue;
	  }

	/* If the symbol is undefined, common, weak, or global (ELF
	   shared libs), we can't replace it with the section symbol.  */
	if (S_FORCE_RELOC (fixp->fx_addsy, 1))
	  continue;

	/* Is there some other (target cpu dependent) reason we can't adjust
	   this one?  (E.g. relocations involving function addresses on
	   the PA.  */
#ifdef tc_fix_adjustable
	if (! tc_fix_adjustable (fixp))
	  continue;
#endif

	/* Since we're reducing to section symbols, don't attempt to reduce
	   anything that's already using one.  */
	if (symbol_section_p (sym))
	  continue;

	symsec = S_GET_SEGMENT (sym);
	if (symsec == NULL)
	  abort ();

	if (bfd_is_abs_section (symsec))
	  {
	    /* The fixup_segment routine normally will not use this
               symbol in a relocation.  */
	    continue;
	  }

	/* Don't try to reduce relocs which refer to non-local symbols
           in .linkonce sections.  It can lead to confusion when a
           debugging section refers to a .linkonce section.  I hope
           this will always be correct.  */
	if (symsec != sec && ! S_IS_LOCAL (sym))
	  {
	    if ((symsec->flags & SEC_LINK_ONCE) != 0
		|| (IS_ELF
		    /* The GNU toolchain uses an extension for ELF: a
		       section beginning with the magic string
		       .gnu.linkonce is a linkonce section.  */
		    && strncmp (segment_name (symsec), ".gnu.linkonce",
				sizeof ".gnu.linkonce" - 1) == 0))
	      continue;
	  }

	/* Never adjust a reloc against local symbol in a merge section
	   with non-zero addend.  */
	if ((symsec->flags & SEC_MERGE) != 0
	    && (fixp->fx_offset != 0 || fixp->fx_subsy != NULL))
	  continue;

	/* Never adjust a reloc against TLS local symbol.  */
	if ((symsec->flags & SEC_THREAD_LOCAL) != 0)
	  continue;

	/* We refetch the segment when calling section_symbol, rather
	   than using symsec, because S_GET_VALUE may wind up changing
	   the section when it calls resolve_symbol_value.  */
	fixp->fx_offset += S_GET_VALUE (sym);
	fixp->fx_addsy = section_symbol (S_GET_SEGMENT (sym));
#ifdef DEBUG5
	fprintf (stderr, "\nadjusted fixup:\n");
	print_fixup (fixp);
#endif
      }

  dump_section_relocs (abfd, sec, stderr);
}

static void
fix_segment (bfd *abfd ATTRIBUTE_UNUSED,
	     asection *sec,
	     PTR xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);

  fixup_segment (seginfo->fix_root, sec);
}

static void
write_relocs (bfd *abfd, asection *sec, PTR xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  unsigned int i;
  unsigned int n;
  arelent **relocs;
  fixS *fixp;
  char *err;

  /* If seginfo is NULL, we did not create this section; don't do
     anything with it.  */
  if (seginfo == NULL)
    return;

  n = 0;
  for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
    n++;

#ifndef RELOC_EXPANSION_POSSIBLE
  /* Set up reloc information as well.  */
  relocs = (arelent **) xcalloc (n, sizeof (arelent *));

  i = 0;
  for (fixp = seginfo->fix_root; fixp != (fixS *) NULL; fixp = fixp->fx_next)
    {
      arelent *reloc;
      bfd_reloc_status_type s;
      symbolS *sym;

      if (fixp->fx_done)
	{
	  n--;
	  continue;
	}

      /* If this is an undefined symbol which was equated to another
         symbol, then generate the reloc against the latter symbol
         rather than the former.  */
      sym = fixp->fx_addsy;
      while (symbol_equated_reloc_p (sym))
	{
	  symbolS *n;

	  /* We must avoid looping, as that can occur with a badly
	     written program.  */
	  n = symbol_get_value_expression (sym)->X_add_symbol;
	  if (n == sym)
	    break;
	  fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
	  sym = n;
	}
      fixp->fx_addsy = sym;

      reloc = tc_gen_reloc (sec, fixp);
      if (!reloc)
	{
	  n--;
	  continue;
	}

#if 0
      /* This test is triggered inappropriately for the SH.  */
      if (fixp->fx_where + fixp->fx_size
	  > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
	abort ();
#endif

      s = bfd_install_relocation (stdoutput, reloc,
				  fixp->fx_frag->fr_literal,
				  fixp->fx_frag->fr_address,
				  sec, &err);
      switch (s)
	{
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_overflow:
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("relocation overflow"));
	  break;
	case bfd_reloc_outofrange:
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("relocation out of range"));
	  break;
	default:
	  as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
		    fixp->fx_file, fixp->fx_line, s);
	}
      relocs[i++] = reloc;
    }
#else
  n = n * MAX_RELOC_EXPANSION;
  /* Set up reloc information as well.  */
  relocs = (arelent **) xcalloc (n, sizeof (arelent *));

  i = 0;
  for (fixp = seginfo->fix_root; fixp != (fixS *) NULL; fixp = fixp->fx_next)
    {
      arelent **reloc;
      bfd_reloc_status_type s;
      symbolS *sym;
      int j;

      if (fixp->fx_done)
	{
	  n--;
	  continue;
	}

      /* If this is an undefined symbol which was equated to another
         symbol, then generate the reloc against the latter symbol
         rather than the former.  */
      sym = fixp->fx_addsy;
      while (symbol_equated_reloc_p (sym))
	{
	  symbolS *n;

	  /* We must avoid looping, as that can occur with a badly
	     written program.  */
	  n = symbol_get_value_expression (sym)->X_add_symbol;
	  if (n == sym)
	    break;
	  fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
	  sym = n;
	}
      fixp->fx_addsy = sym;

      reloc = tc_gen_reloc (sec, fixp);

      for (j = 0; reloc[j]; j++)
	{
	  relocs[i++] = reloc[j];
	  assert (i <= n);
	}
      if (fixp->fx_where + fixp->fx_size
	  > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("internal error: fixup not contained within frag"));
      for (j = 0; reloc[j]; j++)
	{
	  s = bfd_install_relocation (stdoutput, reloc[j],
				      fixp->fx_frag->fr_literal,
				      fixp->fx_frag->fr_address,
				      sec, &err);
	  switch (s)
	    {
	    case bfd_reloc_ok:
	      break;
	    case bfd_reloc_overflow:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("relocation overflow"));
	      break;
	    case bfd_reloc_outofrange:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("relocation out of range"));
	      break;
	    default:
	      as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
			fixp->fx_file, fixp->fx_line, s);
	    }
	}
    }
  n = i;
#endif

#ifdef DEBUG4
  {
    int i, j, nsyms;
    asymbol **sympp;
    sympp = bfd_get_outsymbols (stdoutput);
    nsyms = bfd_get_symcount (stdoutput);
    for (i = 0; i < n; i++)
      if (((*relocs[i]->sym_ptr_ptr)->flags & BSF_SECTION_SYM) == 0)
	{
	  for (j = 0; j < nsyms; j++)
	    if (sympp[j] == *relocs[i]->sym_ptr_ptr)
	      break;
	  if (j == nsyms)
	    abort ();
	}
  }
#endif

  if (n)
    bfd_set_reloc (stdoutput, sec, relocs, n);
  else
    bfd_set_section_flags (abfd, sec,
			   (bfd_get_section_flags (abfd, sec)
			    & (flagword) ~SEC_RELOC));

#ifdef SET_SECTION_RELOCS
  SET_SECTION_RELOCS (sec, relocs, n);
#endif

#ifdef DEBUG3
  {
    int i;
    arelent *r;
    asymbol *s;
    fprintf (stderr, "relocs for sec %s\n", sec->name);
    for (i = 0; i < n; i++)
      {
	r = relocs[i];
	s = *r->sym_ptr_ptr;
	fprintf (stderr, "  reloc %2d @@%08x off %4x : sym %-10s addend %x\n",
		 i, r, r->address, s->name, r->addend);
      }
  }
#endif
}

static void
write_contents (bfd *abfd ATTRIBUTE_UNUSED,
		asection *sec,
		PTR xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  addressT offset = 0;
  fragS *f;

  /* Write out the frags.  */
  if (seginfo == NULL
      || !(bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS))
    return;

  for (f = seginfo->frchainP->frch_root;
       f;
       f = f->fr_next)
    {
      int x;
      addressT fill_size;
      char *fill_literal;
      offsetT count;

      assert (f->fr_type == rs_fill);
      if (f->fr_fix)
	{
	  x = bfd_set_section_contents (stdoutput, sec,
					f->fr_literal, (file_ptr) offset,
					(bfd_size_type) f->fr_fix);
	  if (!x)
	    {
	      bfd_perror (stdoutput->filename);
	      as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
	      exit (EXIT_FAILURE);
	    }
	  offset += f->fr_fix;
	}
      fill_literal = f->fr_literal + f->fr_fix;
      fill_size = f->fr_var;
      count = f->fr_offset;
      assert (count >= 0);
      if (fill_size && count)
	{
	  char buf[256];
	  if (fill_size > sizeof (buf))
	    {
	      /* Do it the old way. Can this ever happen?  */
	      while (count--)
		{
		  x = bfd_set_section_contents (stdoutput, sec,
						fill_literal,
						(file_ptr) offset,
						(bfd_size_type) fill_size);
		  if (!x)
		    {
		      bfd_perror (stdoutput->filename);
		      as_perror (_("FATAL: Can't write %s"),
				 stdoutput->filename);
		      exit (EXIT_FAILURE);
		    }
		  offset += fill_size;
		}
	    }
	  else
	    {
	      /* Build a buffer full of fill objects and output it as
		 often as necessary. This saves on the overhead of
		 potentially lots of bfd_set_section_contents calls.  */
	      int n_per_buf, i;
	      if (fill_size == 1)
		{
		  n_per_buf = sizeof (buf);
		  memset (buf, *fill_literal, n_per_buf);
		}
	      else
		{
		  char *bufp;
		  n_per_buf = sizeof (buf) / fill_size;
		  for (i = n_per_buf, bufp = buf; i; i--, bufp += fill_size)
		    memcpy (bufp, fill_literal, fill_size);
		}
	      for (; count > 0; count -= n_per_buf)
		{
		  n_per_buf = n_per_buf > count ? count : n_per_buf;
		  x = bfd_set_section_contents
		    (stdoutput, sec, buf, (file_ptr) offset,
		     (bfd_size_type) n_per_buf * fill_size);
		  if (!x)
		    as_fatal (_("cannot write to output file"));
		  offset += n_per_buf * fill_size;
		}
	    }
	}
    }
}
#endif

#if defined(BFD_ASSEMBLER) || (!defined (BFD) && !defined(OBJ_AOUT))
static void
merge_data_into_text (void)
{
#if defined(BFD_ASSEMBLER) || defined(MANY_SEGMENTS)
  seg_info (text_section)->frchainP->frch_last->fr_next =
    seg_info (data_section)->frchainP->frch_root;
  seg_info (text_section)->frchainP->frch_last =
    seg_info (data_section)->frchainP->frch_last;
  seg_info (data_section)->frchainP = 0;
#else
  fixS *tmp;

  text_last_frag->fr_next = data_frag_root;
  text_last_frag = data_last_frag;
  data_last_frag = NULL;
  data_frag_root = NULL;
  if (text_fix_root)
    {
      for (tmp = text_fix_root; tmp->fx_next; tmp = tmp->fx_next);;
      tmp->fx_next = data_fix_root;
      text_fix_tail = data_fix_tail;
    }
  else
    text_fix_root = data_fix_root;
  data_fix_root = NULL;
#endif
}
#endif /* BFD_ASSEMBLER || (! BFD && ! OBJ_AOUT)  */

#if !defined (BFD_ASSEMBLER) && !defined (BFD)
static void
relax_and_size_all_segments ()
{
  fragS *fragP;

  relax_segment (text_frag_root, SEG_TEXT);
  relax_segment (data_frag_root, SEG_DATA);
  relax_segment (bss_frag_root, SEG_BSS);

  /* Now the addresses of frags are correct within the segment.  */
  know (text_last_frag->fr_type == rs_fill && text_last_frag->fr_offset == 0);
  H_SET_TEXT_SIZE (&headers, text_last_frag->fr_address);
  text_last_frag->fr_address = H_GET_TEXT_SIZE (&headers);

  /* Join the 2 segments into 1 huge segment.
     To do this, re-compute every rn_address in the SEG_DATA frags.
     Then join the data frags after the text frags.

     Determine a_data [length of data segment].  */
  if (data_frag_root)
    {
      register relax_addressT slide;

      know ((text_last_frag->fr_type == rs_fill)
	    && (text_last_frag->fr_offset == 0));

      H_SET_DATA_SIZE (&headers, data_last_frag->fr_address);
      data_last_frag->fr_address = H_GET_DATA_SIZE (&headers);
      slide = H_GET_TEXT_SIZE (&headers);	/* & in file of the data segment.  */
#ifdef OBJ_BOUT
#define RoundUp(N,S) (((N)+(S)-1)&-(S))
      /* For b.out: If the data section has a strict alignment
	 requirement, its load address in the .o file will be
	 rounded up from the size of the text section.  These
	 two values are *not* the same!  Similarly for the bss
	 section....  */
      slide = RoundUp (slide, 1 << section_alignment[SEG_DATA]);
#endif

      for (fragP = data_frag_root; fragP; fragP = fragP->fr_next)
	fragP->fr_address += slide;

      know (text_last_frag != 0);
      text_last_frag->fr_next = data_frag_root;
    }
  else
    {
      H_SET_DATA_SIZE (&headers, 0);
    }

#ifdef OBJ_BOUT
  /* See above comments on b.out data section address.  */
  {
    addressT bss_vma;
    if (data_last_frag == 0)
      bss_vma = H_GET_TEXT_SIZE (&headers);
    else
      bss_vma = data_last_frag->fr_address;
    bss_vma = RoundUp (bss_vma, 1 << section_alignment[SEG_BSS]);
    bss_address_frag.fr_address = bss_vma;
  }
#else /* ! OBJ_BOUT  */
  bss_address_frag.fr_address = (H_GET_TEXT_SIZE (&headers) +
				 H_GET_DATA_SIZE (&headers));

#endif /* ! OBJ_BOUT  */

  /* Slide all the frags.  */
  if (bss_frag_root)
    {
      relax_addressT slide = bss_address_frag.fr_address;

      for (fragP = bss_frag_root; fragP; fragP = fragP->fr_next)
	fragP->fr_address += slide;
    }

  if (bss_last_frag)
    H_SET_BSS_SIZE (&headers,
		    bss_last_frag->fr_address - bss_frag_root->fr_address);
  else
    H_SET_BSS_SIZE (&headers, 0);
}
#endif /* ! BFD_ASSEMBLER && ! BFD  */

#if defined (BFD_ASSEMBLER) || !defined (BFD)

#ifdef BFD_ASSEMBLER
static void
set_symtab (void)
{
  int nsyms;
  asymbol **asympp;
  symbolS *symp;
  bfd_boolean result;
  extern PTR bfd_alloc (bfd *, bfd_size_type);

  /* Count symbols.  We can't rely on a count made by the loop in
     write_object_file, because *_frob_file may add a new symbol or
     two.  */
  nsyms = 0;
  for (symp = symbol_rootP; symp; symp = symbol_next (symp))
    nsyms++;

  if (nsyms)
    {
      int i;
      bfd_size_type amt = (bfd_size_type) nsyms * sizeof (asymbol *);

      asympp = (asymbol **) bfd_alloc (stdoutput, amt);
      symp = symbol_rootP;
      for (i = 0; i < nsyms; i++, symp = symbol_next (symp))
	{
	  asympp[i] = symbol_get_bfdsym (symp);
	  symbol_mark_written (symp);
	}
    }
  else
    asympp = 0;
  result = bfd_set_symtab (stdoutput, asympp, nsyms);
  assert (result);
  symbol_table_frozen = 1;
}
#endif

/* Finish the subsegments.  After every sub-segment, we fake an
   ".align ...".  This conforms to BSD4.2 brane-damage.  We then fake
   ".fill 0" because that is the kind of frag that requires least
   thought.  ".align" frags like to have a following frag since that
   makes calculating their intended length trivial.  */

#ifndef SUB_SEGMENT_ALIGN
#ifdef HANDLE_ALIGN
/* The last subsegment gets an alignment corresponding to the alignment
   of the section.  This allows proper nop-filling at the end of
   code-bearing sections.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
   ? get_recorded_alignment (SEG) : 0)
#else
#ifdef BFD_ASSEMBLER
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 0
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 2
#endif
#endif
#endif

void
subsegs_finish (void)
{
  struct frchain *frchainP;

  for (frchainP = frchain_root; frchainP; frchainP = frchainP->frch_next)
    {
      int alignment = 0;

      subseg_set (frchainP->frch_seg, frchainP->frch_subseg);

      /* This now gets called even if we had errors.  In that case,
         any alignment is meaningless, and, moreover, will look weird
         if we are generating a listing.  */
      if (!had_errors ())
	{
	  alignment = SUB_SEGMENT_ALIGN (now_seg, frchainP);
#ifdef BFD_ASSEMBLER
	  if ((bfd_get_section_flags (now_seg->owner, now_seg) & SEC_MERGE)
	      && now_seg->entsize)
	    {
	      unsigned int entsize = now_seg->entsize;
	      int entalign = 0;

	      while ((entsize & 1) == 0)
		{
		  ++entalign;
		  entsize >>= 1;
		}
	      if (entalign > alignment)
		alignment = entalign;
	    }
#endif
	}

      if (subseg_text_p (now_seg))
	frag_align_code (alignment, 0);
      else
	frag_align (alignment, 0, 0);

      /* frag_align will have left a new frag.
	 Use this last frag for an empty ".fill".

	 For this segment ...
	 Create a last frag. Do not leave a "being filled in frag".  */
      frag_wane (frag_now);
      frag_now->fr_fix = 0;
      know (frag_now->fr_next == NULL);
    }
}

/* Write the object file.  */

void
write_object_file (void)
{
#if ! defined (BFD_ASSEMBLER) || ! defined (WORKING_DOT_WORD)
  fragS *fragP;			/* Track along all frags.  */
#endif

  /* Do we really want to write it?  */
  {
    int n_warns, n_errs;
    n_warns = had_warnings ();
    n_errs = had_errors ();
    /* The -Z flag indicates that an object file should be generated,
       regardless of warnings and errors.  */
    if (flag_always_generate_output)
      {
	if (n_warns || n_errs)
	  as_warn (_("%d error%s, %d warning%s, generating bad object file"),
		   n_errs, n_errs == 1 ? "" : "s",
		   n_warns, n_warns == 1 ? "" : "s");
      }
    else
      {
	if (n_errs)
	  as_fatal (_("%d error%s, %d warning%s, no object file generated"),
		    n_errs, n_errs == 1 ? "" : "s",
		    n_warns, n_warns == 1 ? "" : "s");
      }
  }

#ifdef	OBJ_VMS
  /* Under VMS we try to be compatible with VAX-11 "C".  Thus, we call
     a routine to check for the definition of the procedure "_main",
     and if so -- fix it up so that it can be program entry point.  */
  vms_check_for_main ();
#endif /* OBJ_VMS  */

  /* From now on, we don't care about sub-segments.  Build one frag chain
     for each segment. Linked thru fr_next.  */

#ifdef BFD_ASSEMBLER
  /* Remove the sections created by gas for its own purposes.  */
  {
    asection **seclist;
    int i;

    seclist = &stdoutput->sections;
    while (*seclist)
      {
	if (*seclist == reg_section || *seclist == expr_section)
	  {
	    bfd_section_list_remove (stdoutput, seclist);
	    stdoutput->section_count--;
	  }
	else
	  seclist = &(*seclist)->next;
      }
    i = 0;
    bfd_map_over_sections (stdoutput, renumber_sections, &i);
  }

  bfd_map_over_sections (stdoutput, chain_frchains_together, (char *) 0);
#else
  remove_subsegs (frchain_root, SEG_TEXT, &text_frag_root, &text_last_frag);
  remove_subsegs (data0_frchainP, SEG_DATA, &data_frag_root, &data_last_frag);
  remove_subsegs (bss0_frchainP, SEG_BSS, &bss_frag_root, &bss_last_frag);
#endif

  /* We have two segments. If user gave -R flag, then we must put the
     data frags into the text segment. Do this before relaxing so
     we know to take advantage of -R and make shorter addresses.  */
#if !defined (OBJ_AOUT) || defined (BFD_ASSEMBLER)
  if (flag_readonly_data_in_text)
    {
      merge_data_into_text ();
    }
#endif

#ifdef BFD_ASSEMBLER
  while (1)
    {
      int changed;

#ifndef WORKING_DOT_WORD
      /* We need to reset the markers in the broken word list and
	 associated frags between calls to relax_segment (via
	 relax_seg).  Since the broken word list is global, we do it
	 once per round, rather than locally in relax_segment for each
	 segment.  */
      struct broken_word *brokp;

      for (brokp = broken_words;
	   brokp != (struct broken_word *) NULL;
	   brokp = brokp->next_broken_word)
	{
	  brokp->added = 0;

	  if (brokp->dispfrag != (fragS *) NULL
	      && brokp->dispfrag->fr_type == rs_broken_word)
	    brokp->dispfrag->fr_subtype = 0;
	}
#endif

      changed = 0;
      bfd_map_over_sections (stdoutput, relax_seg, &changed);
      if (!changed)
	break;
    }

  /* Note - Most ports will use the default value of
     TC_FINALIZE_SYMS_BEFORE_SIZE_SEG, which 1.  This will force
     local symbols to be resolved, removing their frag information.
     Some ports however, will not have finished relaxing all of
     their frags and will still need the local symbol frag
     information.  These ports can set
     TC_FINALIZE_SYMS_BEFORE_SIZE_SEG to 0.  */
  finalize_syms = TC_FINALIZE_SYMS_BEFORE_SIZE_SEG;

  bfd_map_over_sections (stdoutput, size_seg, (char *) 0);
#else
  relax_and_size_all_segments ();
#endif /* BFD_ASSEMBLER  */

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;

#ifdef md_post_relax_hook
  md_post_relax_hook;
#endif

#ifndef BFD_ASSEMBLER
  /* Crawl the symbol chain.

     For each symbol whose value depends on a frag, take the address of
     that frag and subsume it into the value of the symbol.
     After this, there is just one way to lookup a symbol value.
     Values are left in their final state for object file emission.
     We adjust the values of 'L' local symbols, even if we do
     not intend to emit them to the object file, because their values
     are needed for fix-ups.

     Unless we saw a -L flag, remove all symbols that begin with 'L'
     from the symbol chain.  (They are still pointed to by the fixes.)

     Count the remaining symbols.
     Assign a symbol number to each symbol.
     Count the number of string-table chars we will emit.
     Put this info into the headers as appropriate.  */
  know (zero_address_frag.fr_address == 0);
  string_byte_count = sizeof (string_byte_count);

  obj_crawl_symbol_chain (&headers);

  if (string_byte_count == sizeof (string_byte_count))
    string_byte_count = 0;

  H_SET_STRING_SIZE (&headers, string_byte_count);

  /* Addresses of frags now reflect addresses we use in the object file.
     Symbol values are correct.
     Scan the frags, converting any ".org"s and ".align"s to ".fill"s.
     Also converting any machine-dependent frags using md_convert_frag();  */
  subseg_change (SEG_TEXT, 0);

  for (fragP = text_frag_root; fragP; fragP = fragP->fr_next)
    {
      /* At this point we have linked all the frags into a single
         chain.  However, cvt_frag_to_fill may call md_convert_frag
         which may call fix_new.  We need to ensure that fix_new adds
         the fixup to the right section.  */
      if (fragP == data_frag_root)
	subseg_change (SEG_DATA, 0);

      cvt_frag_to_fill (&headers, SEG_TEXT, fragP);

      /* Some assert macros don't work with # directives mixed in.  */
#ifndef NDEBUG
      if (!(fragP->fr_next == NULL
#ifdef OBJ_BOUT
	    || fragP->fr_next == data_frag_root
#endif
	    || ((offsetT) (fragP->fr_next->fr_address - fragP->fr_address)
		== (fragP->fr_fix + fragP->fr_offset * fragP->fr_var))))
	abort ();
#endif
    }
#endif /* ! BFD_ASSEMBLER  */

#ifndef WORKING_DOT_WORD
  {
    struct broken_word *lie;
    struct broken_word **prevP;

    prevP = &broken_words;
    for (lie = broken_words; lie; lie = lie->next_broken_word)
      if (!lie->added)
	{
	  expressionS exp;

	  subseg_change (lie->seg, lie->subseg);
	  exp.X_op = O_subtract;
	  exp.X_add_symbol = lie->add;
	  exp.X_op_symbol = lie->sub;
	  exp.X_add_number = lie->addnum;
#ifdef BFD_ASSEMBLER
#ifdef TC_CONS_FIX_NEW
	  TC_CONS_FIX_NEW (lie->frag,
			   lie->word_goes_here - lie->frag->fr_literal,
			   2, &exp);
#else
	  fix_new_exp (lie->frag,
		       lie->word_goes_here - lie->frag->fr_literal,
		       2, &exp, 0, BFD_RELOC_16);
#endif
#else
#if defined(TC_SPARC) || defined(TC_A29K) || defined(NEED_FX_R_TYPE)
	  fix_new_exp (lie->frag,
		       lie->word_goes_here - lie->frag->fr_literal,
		       2, &exp, 0, NO_RELOC);
#else
#ifdef TC_NS32K
	  fix_new_ns32k_exp (lie->frag,
			     lie->word_goes_here - lie->frag->fr_literal,
			     2, &exp, 0, 0, 2, 0, 0);
#else
	  fix_new_exp (lie->frag,
		       lie->word_goes_here - lie->frag->fr_literal,
		       2, &exp, 0, 0);
#endif /* TC_NS32K  */
#endif /* TC_SPARC|TC_A29K|NEED_FX_R_TYPE  */
#endif /* BFD_ASSEMBLER  */
	  *prevP = lie->next_broken_word;
	}
      else
	prevP = &(lie->next_broken_word);

    for (lie = broken_words; lie;)
      {
	struct broken_word *untruth;
	char *table_ptr;
	addressT table_addr;
	addressT from_addr, to_addr;
	int n, m;

	subseg_change (lie->seg, lie->subseg);
	fragP = lie->dispfrag;

	/* Find out how many broken_words go here.  */
	n = 0;
	for (untruth = lie;
	     untruth && untruth->dispfrag == fragP;
	     untruth = untruth->next_broken_word)
	  if (untruth->added == 1)
	    n++;

	table_ptr = lie->dispfrag->fr_opcode;
	table_addr = (lie->dispfrag->fr_address
		      + (table_ptr - lie->dispfrag->fr_literal));
	/* Create the jump around the long jumps.  This is a short
	   jump from table_ptr+0 to table_ptr+n*long_jump_size.  */
	from_addr = table_addr;
	to_addr = table_addr + md_short_jump_size + n * md_long_jump_size;
	md_create_short_jump (table_ptr, from_addr, to_addr, lie->dispfrag,
			      lie->add);
	table_ptr += md_short_jump_size;
	table_addr += md_short_jump_size;

	for (m = 0;
	     lie && lie->dispfrag == fragP;
	     m++, lie = lie->next_broken_word)
	  {
	    if (lie->added == 2)
	      continue;
	    /* Patch the jump table.  */
	    /* This is the offset from ??? to table_ptr+0.  */
	    to_addr = table_addr - S_GET_VALUE (lie->sub);
#ifdef TC_CHECK_ADJUSTED_BROKEN_DOT_WORD
	    TC_CHECK_ADJUSTED_BROKEN_DOT_WORD (to_addr, lie);
#endif
	    md_number_to_chars (lie->word_goes_here, to_addr, 2);
	    for (untruth = lie->next_broken_word;
		 untruth && untruth->dispfrag == fragP;
		 untruth = untruth->next_broken_word)
	      {
		if (untruth->use_jump == lie)
		  md_number_to_chars (untruth->word_goes_here, to_addr, 2);
	      }

	    /* Install the long jump.  */
	    /* This is a long jump from table_ptr+0 to the final target.  */
	    from_addr = table_addr;
	    to_addr = S_GET_VALUE (lie->add) + lie->addnum;
	    md_create_long_jump (table_ptr, from_addr, to_addr, lie->dispfrag,
				 lie->add);
	    table_ptr += md_long_jump_size;
	    table_addr += md_long_jump_size;
	  }
      }
  }
#endif /* not WORKING_DOT_WORD  */

#ifndef BFD_ASSEMBLER
#ifndef	OBJ_VMS
  {				/* not vms  */
    char *the_object_file;
    long object_file_size;
    /* Scan every FixS performing fixups. We had to wait until now to
       do this because md_convert_frag() may have made some fixSs.  */
    int trsize, drsize;

    subseg_change (SEG_TEXT, 0);
    trsize = md_reloc_size * fixup_segment (text_fix_root, SEG_TEXT);
    subseg_change (SEG_DATA, 0);
    drsize = md_reloc_size * fixup_segment (data_fix_root, SEG_DATA);
    H_SET_RELOCATION_SIZE (&headers, trsize, drsize);

    /* FIXME: Move this stuff into the pre-write-hook.  */
    H_SET_MAGIC_NUMBER (&headers, magic_number_for_object_file);
    H_SET_ENTRY_POINT (&headers, 0);

    obj_pre_write_hook (&headers);	/* Extra coff stuff.  */

    object_file_size = H_GET_FILE_SIZE (&headers);
    next_object_file_charP = the_object_file = xmalloc (object_file_size);

    output_file_create (out_file_name);

    obj_header_append (&next_object_file_charP, &headers);

    know ((next_object_file_charP - the_object_file)
	  == H_GET_HEADER_SIZE (&headers));

    /* Emit code.  */
    for (fragP = text_frag_root; fragP; fragP = fragP->fr_next)
      {
	register long count;
	register char *fill_literal;
	register long fill_size;

	PROGRESS (1);
	know (fragP->fr_type == rs_fill);
	append (&next_object_file_charP, fragP->fr_literal,
		(unsigned long) fragP->fr_fix);
	fill_literal = fragP->fr_literal + fragP->fr_fix;
	fill_size = fragP->fr_var;
	know (fragP->fr_offset >= 0);

	for (count = fragP->fr_offset; count; count--)
	  append (&next_object_file_charP, fill_literal,
		  (unsigned long) fill_size);
      }

    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)));

    /* Emit relocations.  */
    obj_emit_relocations (&next_object_file_charP, text_fix_root,
			  (relax_addressT) 0);
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)));
#ifdef TC_I960
    /* Make addresses in data relocation directives relative to beginning of
       first data fragment, not end of last text fragment:  alignment of the
       start of the data segment may place a gap between the segments.  */
    obj_emit_relocations (&next_object_file_charP, data_fix_root,
			  data0_frchainP->frch_root->fr_address);
#else /* TC_I960  */
    obj_emit_relocations (&next_object_file_charP, data_fix_root,
			  text_last_frag->fr_address);
#endif /* TC_I960  */

    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)
	      + H_GET_DATA_RELOCATION_SIZE (&headers)));

    /* Emit line number entries.  */
    OBJ_EMIT_LINENO (&next_object_file_charP, lineno_rootP, the_object_file);
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)
	      + H_GET_DATA_RELOCATION_SIZE (&headers)
	      + H_GET_LINENO_SIZE (&headers)));

    /* Emit symbols.  */
    obj_emit_symbols (&next_object_file_charP, symbol_rootP);
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)
	      + H_GET_DATA_RELOCATION_SIZE (&headers)
	      + H_GET_LINENO_SIZE (&headers)
	      + H_GET_SYMBOL_TABLE_SIZE (&headers)));

    /* Emit strings.  */
    if (string_byte_count > 0)
      obj_emit_strings (&next_object_file_charP);

#ifdef BFD_HEADERS
    bfd_seek (stdoutput, (file_ptr) 0, 0);
    bfd_bwrite (the_object_file, (bfd_size_type) object_file_size, stdoutput);
#else

    /* Write the data to the file.  */
    output_file_append (the_object_file, object_file_size, out_file_name);
    free (the_object_file);
#endif
  }
#else /* OBJ_VMS  */
  /* Now do the VMS-dependent part of writing the object file.  */
  vms_write_object_file (H_GET_TEXT_SIZE (&headers),
			 H_GET_DATA_SIZE (&headers),
			 H_GET_BSS_SIZE (&headers),
			 text_frag_root, data_frag_root);
#endif /* OBJ_VMS  */
#else /* BFD_ASSEMBLER  */

  /* Resolve symbol values.  This needs to be done before processing
     the relocations.  */
  if (symbol_rootP)
    {
      symbolS *symp;

      for (symp = symbol_rootP; symp; symp = symbol_next (symp))
	resolve_symbol_value (symp);
    }
  resolve_local_symbol_values ();

  PROGRESS (1);

#ifdef tc_frob_file_before_adjust
  tc_frob_file_before_adjust ();
#endif
#ifdef obj_frob_file_before_adjust
  obj_frob_file_before_adjust ();
#endif

  bfd_map_over_sections (stdoutput, adjust_reloc_syms, (char *) 0);

#ifdef tc_frob_file_before_fix
  tc_frob_file_before_fix ();
#endif
#ifdef obj_frob_file_before_fix
  obj_frob_file_before_fix ();
#endif

  bfd_map_over_sections (stdoutput, fix_segment, (char *) 0);

  /* Set up symbol table, and write it out.  */
  if (symbol_rootP)
    {
      symbolS *symp;

      for (symp = symbol_rootP; symp; symp = symbol_next (symp))
	{
	  int punt = 0;
	  const char *name;

	  if (symbol_mri_common_p (symp))
	    {
	      if (S_IS_EXTERNAL (symp))
		as_bad (_("%s: global symbols not supported in common sections"),
			S_GET_NAME (symp));
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	      continue;
	    }

	  name = S_GET_NAME (symp);
	  if (name)
	    {
	      const char *name2 =
		decode_local_label_name ((char *) S_GET_NAME (symp));
	      /* They only differ if `name' is a fb or dollar local
		 label name.  */
	      if (name2 != name && ! S_IS_DEFINED (symp))
		as_bad (_("local label `%s' is not defined"), name2);
	    }

	  /* Do it again, because adjust_reloc_syms might introduce
	     more symbols.  They'll probably only be section symbols,
	     but they'll still need to have the values computed.  */
	  resolve_symbol_value (symp);

	  /* Skip symbols which were equated to undefined or common
             symbols.  */
	  if (symbol_equated_reloc_p (symp))
	    {
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	      continue;
	    }

	  /* So far, common symbols have been treated like undefined symbols.
	     Put them in the common section now.  */
	  if (S_IS_DEFINED (symp) == 0
	      && S_GET_VALUE (symp) != 0)
	    S_SET_SEGMENT (symp, bfd_com_section_ptr);
#if 0
	  printf ("symbol `%s'\n\t@@%x: value=%d flags=%x seg=%s\n",
		  S_GET_NAME (symp), symp,
		  S_GET_VALUE (symp),
		  symbol_get_bfdsym (symp)->flags,
		  segment_name (S_GET_SEGMENT (symp)));
#endif

#ifdef obj_frob_symbol
	  obj_frob_symbol (symp, punt);
#endif
#ifdef tc_frob_symbol
	  if (! punt || symbol_used_in_reloc_p (symp))
	    tc_frob_symbol (symp, punt);
#endif

	  /* If we don't want to keep this symbol, splice it out of
	     the chain now.  If EMIT_SECTION_SYMBOLS is 0, we never
	     want section symbols.  Otherwise, we skip local symbols
	     and symbols that the frob_symbol macros told us to punt,
	     but we keep such symbols if they are used in relocs.  */
	  if (symp == abs_section_sym
	      || (! EMIT_SECTION_SYMBOLS
		  && symbol_section_p (symp))
	      /* Note that S_IS_EXTERN and S_IS_LOCAL are not always
		 opposites.  Sometimes the former checks flags and the
		 latter examines the name...  */
	      || (!S_IS_EXTERN (symp)
		  && (punt || S_IS_LOCAL (symp))
		  && ! symbol_used_in_reloc_p (symp)))
	    {
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);

	      /* After symbol_remove, symbol_next(symp) still returns
		 the one that came after it in the chain.  So we don't
		 need to do any extra cleanup work here.  */
	      continue;
	    }

	  /* Make sure we really got a value for the symbol.  */
	  if (! symbol_resolved_p (symp))
	    {
	      as_bad (_("can't resolve value for symbol `%s'"),
		      S_GET_NAME (symp));
	      symbol_mark_resolved (symp);
	    }

	  /* Set the value into the BFD symbol.  Up til now the value
	     has only been kept in the gas symbolS struct.  */
	  symbol_get_bfdsym (symp)->value = S_GET_VALUE (symp);
	}
    }

  PROGRESS (1);

  /* Now do any format-specific adjustments to the symbol table, such
     as adding file symbols.  */
#ifdef tc_adjust_symtab
  tc_adjust_symtab ();
#endif
#ifdef obj_adjust_symtab
  obj_adjust_symtab ();
#endif

  /* Now that all the sizes are known, and contents correct, we can
     start writing to the file.  */
  set_symtab ();

  /* If *_frob_file changes the symbol value at this point, it is
     responsible for moving the changed value into symp->bsym->value
     as well.  Hopefully all symbol value changing can be done in
     *_frob_symbol.  */
#ifdef tc_frob_file
  tc_frob_file ();
#endif
#ifdef obj_frob_file
  obj_frob_file ();
#endif

  bfd_map_over_sections (stdoutput, write_relocs, (char *) 0);

#ifdef tc_frob_file_after_relocs
  tc_frob_file_after_relocs ();
#endif
#ifdef obj_frob_file_after_relocs
  obj_frob_file_after_relocs ();
#endif

  bfd_map_over_sections (stdoutput, write_contents, (char *) 0);
#endif /* BFD_ASSEMBLER  */
}
#endif /* ! BFD  */

#ifdef TC_GENERIC_RELAX_TABLE

/* Relax a fragment by scanning TC_GENERIC_RELAX_TABLE.  */

long
relax_frag (segT segment, fragS *fragP, long stretch)
{
  const relax_typeS *this_type;
  const relax_typeS *start_type;
  relax_substateT next_state;
  relax_substateT this_state;
  offsetT growth;
  offsetT aim;
  addressT target;
  addressT address;
  symbolS *symbolP;
  const relax_typeS *table;

  target = fragP->fr_offset;
  address = fragP->fr_address;
  table = TC_GENERIC_RELAX_TABLE;
  this_state = fragP->fr_subtype;
  start_type = this_type = table + this_state;
  symbolP = fragP->fr_symbol;

  if (symbolP)
    {
      fragS *sym_frag;

      sym_frag = symbol_get_frag (symbolP);

#ifndef DIFF_EXPR_OK
#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
      know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
	    || (S_GET_SEGMENT (symbolP) == SEG_DATA)
	    || (S_GET_SEGMENT (symbolP) == SEG_BSS)
	    || (S_GET_SEGMENT (symbolP) == SEG_TEXT));
#endif
      know (sym_frag != NULL);
#endif
      know (S_GET_SEGMENT (symbolP) != absolute_section
	    || sym_frag == &zero_address_frag);
      target += S_GET_VALUE (symbolP);

      /* If frag has yet to be reached on this pass,
	 assume it will move by STRETCH just as we did.
	 If this is not so, it will be because some frag
	 between grows, and that will force another pass.  */

      if (stretch != 0
	  && sym_frag->relax_marker != fragP->relax_marker
	  && S_GET_SEGMENT (symbolP) == segment)
	{
	  target += stretch;
	}
    }

  aim = target - address - fragP->fr_fix;
#ifdef TC_PCREL_ADJUST
  /* Currently only the ns32k family needs this.  */
  aim += TC_PCREL_ADJUST (fragP);
/* #else */
  /* This machine doesn't want to use pcrel_adjust.
     In that case, pcrel_adjust should be zero.  */
#if 0
  assert (fragP->fr_targ.ns32k.pcrel_adjust == 0);
#endif
#endif
#ifdef md_prepare_relax_scan /* formerly called M68K_AIM_KLUDGE  */
  md_prepare_relax_scan (fragP, address, aim, this_state, this_type);
#endif

  if (aim < 0)
    {
      /* Look backwards.  */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim >= this_type->rlx_backward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state.  */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }
  else
    {
      /* Look forwards.  */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim <= this_type->rlx_forward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state.  */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }

  growth = this_type->rlx_length - start_type->rlx_length;
  if (growth != 0)
    fragP->fr_subtype = this_state;
  return growth;
}

#endif /* defined (TC_GENERIC_RELAX_TABLE)  */

/* Relax_align. Advance location counter to next address that has 'alignment'
   lowest order bits all 0s, return size of adjustment made.  */
static relax_addressT
relax_align (register relax_addressT address,	/* Address now.  */
	     register int alignment	/* Alignment (binary).  */)
{
  relax_addressT mask;
  relax_addressT new_address;

  mask = ~((~0) << alignment);
  new_address = (address + mask) & (~mask);
#ifdef LINKER_RELAXING_SHRINKS_ONLY
  if (linkrelax)
    /* We must provide lots of padding, so the linker can discard it
       when needed.  The linker will not add extra space, ever.  */
    new_address += (1 << alignment);
#endif
  return (new_address - address);
}

/* Now we have a segment, not a crowd of sub-segments, we can make
   fr_address values.

   Relax the frags.

   After this, all frags in this segment have addresses that are correct
   within the segment. Since segments live in different file addresses,
   these frag addresses may not be the same as final object-file
   addresses.  */

int
relax_segment (struct frag *segment_frag_root, segT segment)
{
  register struct frag *fragP;
  register relax_addressT address;
  int ret;

#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
  know (segment == SEG_DATA || segment == SEG_TEXT || segment == SEG_BSS);
#endif
  /* In case md_estimate_size_before_relax() wants to make fixSs.  */
  subseg_change (segment, 0);

  /* For each frag in segment: count and store  (a 1st guess of)
     fr_address.  */
  address = 0;
  for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
    {
      fragP->relax_marker = 0;
      fragP->fr_address = address;
      address += fragP->fr_fix;

      switch (fragP->fr_type)
	{
	case rs_fill:
	  address += fragP->fr_offset * fragP->fr_var;
	  break;

	case rs_align:
	case rs_align_code:
	case rs_align_test:
	  {
	    addressT offset = relax_align (address, (int) fragP->fr_offset);

	    if (fragP->fr_subtype != 0 && offset > fragP->fr_subtype)
	      offset = 0;

	    if (offset % fragP->fr_var != 0)
	      {
		as_bad_where (fragP->fr_file, fragP->fr_line,
			      _("alignment padding (%lu bytes) not a multiple of %ld"),
			      (unsigned long) offset, (long) fragP->fr_var);
		offset -= (offset % fragP->fr_var);
	      }

	    address += offset;
	  }
	  break;

	case rs_org:
	case rs_space:
	  /* Assume .org is nugatory. It will grow with 1st relax.  */
	  break;

	case rs_machine_dependent:
	  /* If fr_symbol is an expression, this call to
	     resolve_symbol_value sets up the correct segment, which will
	     likely be needed in md_estimate_size_before_relax.  */
	  if (fragP->fr_symbol)
	    resolve_symbol_value (fragP->fr_symbol);

	  address += md_estimate_size_before_relax (fragP, segment);
	  break;

#ifndef WORKING_DOT_WORD
	  /* Broken words don't concern us yet.  */
	case rs_broken_word:
	  break;
#endif

	case rs_leb128:
	  /* Initial guess is always 1; doing otherwise can result in
	     stable solutions that are larger than the minimum.  */
	  address += fragP->fr_offset = 1;
	  break;

	case rs_cfa:
	  address += eh_frame_estimate_size_before_relax (fragP);
	  break;

	case rs_dwarf2dbg:
	  address += dwarf2dbg_estimate_size_before_relax (fragP);
	  break;

	default:
	  BAD_CASE (fragP->fr_type);
	  break;
	}
    }

  /* Do relax().  */
  {
    offsetT stretch;	/* May be any size, 0 or negative.  */
    /* Cumulative number of addresses we have relaxed this pass.
       We may have relaxed more than one address.  */
    int stretched;	/* Have we stretched on this pass?  */
    /* This is 'cuz stretch may be zero, when, in fact some piece of code
       grew, and another shrank.  If a branch instruction doesn't fit anymore,
       we could be scrod.  */

    do
      {
	stretch = 0;
	stretched = 0;

	for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
	  {
	    offsetT growth = 0;
	    addressT was_address;
	    offsetT offset;
	    symbolS *symbolP;

	    fragP->relax_marker ^= 1;
	    was_address = fragP->fr_address;
	    address = fragP->fr_address += stretch;
	    symbolP = fragP->fr_symbol;
	    offset = fragP->fr_offset;

	    switch (fragP->fr_type)
	      {
	      case rs_fill:	/* .fill never relaxes.  */
		growth = 0;
		break;

#ifndef WORKING_DOT_WORD
		/* JF:  This is RMS's idea.  I do *NOT* want to be blamed
		   for it I do not want to write it.  I do not want to have
		   anything to do with it.  This is not the proper way to
		   implement this misfeature.  */
	      case rs_broken_word:
		{
		  struct broken_word *lie;
		  struct broken_word *untruth;

		  /* Yes this is ugly (storing the broken_word pointer
		     in the symbol slot).  Still, this whole chunk of
		     code is ugly, and I don't feel like doing anything
		     about it.  Think of it as stubbornness in action.  */
		  growth = 0;
		  for (lie = (struct broken_word *) (fragP->fr_symbol);
		       lie && lie->dispfrag == fragP;
		       lie = lie->next_broken_word)
		    {

		      if (lie->added)
			continue;

		      offset = (S_GET_VALUE (lie->add)
				+ lie->addnum
				- S_GET_VALUE (lie->sub));
		      if (offset <= -32768 || offset >= 32767)
			{
			  if (flag_warn_displacement)
			    {
			      char buf[50];
			      sprint_value (buf, (addressT) lie->addnum);
			      as_warn_where (fragP->fr_file, fragP->fr_line,
					     _(".word %s-%s+%s didn't fit"),
					     S_GET_NAME (lie->add),
					     S_GET_NAME (lie->sub),
					     buf);
			    }
			  lie->added = 1;
			  if (fragP->fr_subtype == 0)
			    {
			      fragP->fr_subtype++;
			      growth += md_short_jump_size;
			    }
			  for (untruth = lie->next_broken_word;
			       untruth && untruth->dispfrag == lie->dispfrag;
			       untruth = untruth->next_broken_word)
			    if ((symbol_get_frag (untruth->add)
				 == symbol_get_frag (lie->add))
				&& (S_GET_VALUE (untruth->add)
				    == S_GET_VALUE (lie->add)))
			      {
				untruth->added = 2;
				untruth->use_jump = lie;
			      }
			  growth += md_long_jump_size;
			}
		    }

		  break;
		}		/* case rs_broken_word  */
#endif
	      case rs_align:
	      case rs_align_code:
	      case rs_align_test:
		{
		  addressT oldoff, newoff;

		  oldoff = relax_align (was_address + fragP->fr_fix,
					(int) offset);
		  newoff = relax_align (address + fragP->fr_fix,
					(int) offset);

		  if (fragP->fr_subtype != 0)
		    {
		      if (oldoff > fragP->fr_subtype)
			oldoff = 0;
		      if (newoff > fragP->fr_subtype)
			newoff = 0;
		    }

		  growth = newoff - oldoff;
		}
		break;

	      case rs_org:
		{
		  addressT target = offset;
		  addressT after;

		  if (symbolP)
		    {
#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
		      know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
			    || (S_GET_SEGMENT (symbolP) == SEG_DATA)
			    || (S_GET_SEGMENT (symbolP) == SEG_TEXT)
			    || S_GET_SEGMENT (symbolP) == SEG_BSS);
		      know (symbolP->sy_frag);
		      know (!(S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
			    || (symbolP->sy_frag == &zero_address_frag));
#endif
                      /* Convert from an actual address to an octet offset
                         into the section.  Here it is assumed that the
                         section's VMA is zero, and can omit subtracting it
                         from the symbol's value to get the address offset.  */
                      know (S_GET_SECTION (symbolP)->vma == 0);
		      target += S_GET_VALUE (symbolP) * OCTETS_PER_BYTE;
		    }

		  know (fragP->fr_next);
		  after = fragP->fr_next->fr_address;
		  growth = target - after;
		  if (growth < 0)
		    {
		      /* Growth may be negative, but variable part of frag
			 cannot have fewer than 0 chars.  That is, we can't
			 .org backwards.  */
		      as_bad_where (fragP->fr_file, fragP->fr_line,
				    _("attempt to move .org backwards"));

		      /* We've issued an error message.  Change the
                         frag to avoid cascading errors.  */
		      fragP->fr_type = rs_align;
		      fragP->fr_subtype = 0;
		      fragP->fr_offset = 0;
		      fragP->fr_fix = after - address;
		      growth = stretch;
		    }

		  /* This is an absolute growth factor  */
		  growth -= stretch;
		  break;
		}

	      case rs_space:
		growth = 0;
		if (symbolP)
		  {
		    offsetT amount;

		    amount = S_GET_VALUE (symbolP);
		    if (S_GET_SEGMENT (symbolP) != absolute_section
			|| S_IS_COMMON (symbolP)
			|| ! S_IS_DEFINED (symbolP))
		      {
			as_bad_where (fragP->fr_file, fragP->fr_line,
				      _(".space specifies non-absolute value"));
			/* Prevent repeat of this error message.  */
			fragP->fr_symbol = 0;
		      }
		    else if (amount < 0)
		      {
			as_warn_where (fragP->fr_file, fragP->fr_line,
				       _(".space or .fill with negative value, ignored"));
			fragP->fr_symbol = 0;
		      }
		    else
		      growth = (was_address + fragP->fr_fix + amount
				- fragP->fr_next->fr_address);
		  }
		break;

	      case rs_machine_dependent:
#ifdef md_relax_frag
		growth = md_relax_frag (segment, fragP, stretch);
#else
#ifdef TC_GENERIC_RELAX_TABLE
		/* The default way to relax a frag is to look through
		   TC_GENERIC_RELAX_TABLE.  */
		growth = relax_frag (segment, fragP, stretch);
#endif /* TC_GENERIC_RELAX_TABLE  */
#endif
		break;

	      case rs_leb128:
		{
		  valueT value;
		  offsetT size;

		  value = resolve_symbol_value (fragP->fr_symbol);
		  size = sizeof_leb128 (value, fragP->fr_subtype);
		  growth = size - fragP->fr_offset;
		  fragP->fr_offset = size;
		}
		break;

	      case rs_cfa:
		growth = eh_frame_relax_frag (fragP);
		break;

	      case rs_dwarf2dbg:
		growth = dwarf2dbg_relax_frag (fragP);
		break;

	      default:
		BAD_CASE (fragP->fr_type);
		break;
	      }
	    if (growth)
	      {
		stretch += growth;
		stretched = 1;
	      }
	  }			/* For each frag in the segment.  */
      }
    while (stretched);		/* Until nothing further to relax.  */
  }				/* do_relax  */

  ret = 0;
  for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
    if (fragP->last_fr_address != fragP->fr_address)
      {
	fragP->last_fr_address = fragP->fr_address;
	ret = 1;
      }
  return ret;
}

#if defined (BFD_ASSEMBLER) || (!defined (BFD) && !defined (OBJ_VMS))

/* fixup_segment()

   Go through all the fixS's in a segment and see which ones can be
   handled now.  (These consist of fixS where we have since discovered
   the value of a symbol, or the address of the frag involved.)
   For each one, call md_apply_fix3 to put the fix into the frag data.

   Result is a count of how many relocation structs will be needed to
   handle the remaining fixS's that we couldn't completely handle here.
   These will be output later by emit_relocations().  */

static long
fixup_segment (fixS *fixP, segT this_segment)
{
  long seg_reloc_count = 0;
  valueT add_number;
  fragS *fragP;
  segT add_symbol_segment = absolute_section;

  if (fixP != NULL && abs_section_sym == NULL)
    {
#ifndef BFD_ASSEMBLER
      abs_section_sym = &abs_symbol;
#else
      abs_section_sym = section_symbol (absolute_section);
#endif
    }

  /* If the linker is doing the relaxing, we must not do any fixups.

     Well, strictly speaking that's not true -- we could do any that
     are PC-relative and don't cross regions that could change size.
     And for the i960 we might be able to turn callx/callj into bal
     anyways in cases where we know the maximum displacement.  */
  if (linkrelax && TC_LINKRELAX_FIXUP (this_segment))
    {
      for (; fixP; fixP = fixP->fx_next)
	if (!fixP->fx_done)
	  {
	    if (fixP->fx_addsy == NULL)
	      {
		/* There was no symbol required by this relocation.
		   However, BFD doesn't really handle relocations
		   without symbols well. So fake up a local symbol in
		   the absolute section.  */
		fixP->fx_addsy = abs_section_sym;
	      }
	    symbol_mark_used_in_reloc (fixP->fx_addsy);
	    if (fixP->fx_subsy != NULL)
	      symbol_mark_used_in_reloc (fixP->fx_subsy);
	    seg_reloc_count++;
	  }
      TC_ADJUST_RELOC_COUNT (fixP, seg_reloc_count);
      return seg_reloc_count;
    }

  for (; fixP; fixP = fixP->fx_next)
    {
#ifdef DEBUG5
      fprintf (stderr, "\nprocessing fixup:\n");
      print_fixup (fixP);
#endif

      fragP = fixP->fx_frag;
      know (fragP);
#ifdef TC_VALIDATE_FIX
      TC_VALIDATE_FIX (fixP, this_segment, skip);
#endif
      add_number = fixP->fx_offset;

      if (fixP->fx_addsy != NULL
	  && symbol_mri_common_p (fixP->fx_addsy))
	{
	  know (fixP->fx_addsy->sy_value.X_op == O_symbol);
	  add_number += S_GET_VALUE (fixP->fx_addsy);
	  fixP->fx_offset = add_number;
	  fixP->fx_addsy
	    = symbol_get_value_expression (fixP->fx_addsy)->X_add_symbol;
	}

      if (fixP->fx_addsy != NULL)
	add_symbol_segment = S_GET_SEGMENT (fixP->fx_addsy);

      if (fixP->fx_subsy != NULL)
	{
	  segT sub_symbol_segment;
	  resolve_symbol_value (fixP->fx_subsy);
	  sub_symbol_segment = S_GET_SEGMENT (fixP->fx_subsy);
	  if (fixP->fx_addsy != NULL
	      && sub_symbol_segment == add_symbol_segment
	      && !TC_FORCE_RELOCATION_SUB_SAME (fixP, add_symbol_segment))
	    {
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_addsy = NULL;
	      fixP->fx_subsy = NULL;
#ifdef TC_M68K
	      /* See the comment below about 68k weirdness.  */
	      fixP->fx_pcrel = 0;
#endif
	    }
	  else if (sub_symbol_segment == absolute_section
		   && !TC_FORCE_RELOCATION_SUB_ABS (fixP))
	    {
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_subsy = NULL;
	    }
	  else if (sub_symbol_segment == this_segment
		   && !TC_FORCE_RELOCATION_SUB_LOCAL (fixP))
	    {
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = (add_number + fixP->fx_dot_value
				 + fixP->fx_frag->fr_address);

	      /* Make it pc-relative.  If the back-end code has not
		 selected a pc-relative reloc, cancel the adjustment
		 we do later on all pc-relative relocs.  */
	      if (0
#ifdef TC_M68K
		  /* Do this for m68k even if it's already described
		     as pc-relative.  On the m68k, an operand of
		     "pc@@(foo-.-2)" should address "foo" in a
		     pc-relative mode.  */
		  || 1
#endif
		  || !fixP->fx_pcrel)
		add_number += MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_subsy = NULL;
	      fixP->fx_pcrel = 1;
	    }
	  else if (!TC_VALIDATE_FIX_SUB (fixP))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("can't resolve `%s' {%s section} - `%s' {%s section}"),
			    fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : "0",
			    segment_name (add_symbol_segment),
			    S_GET_NAME (fixP->fx_subsy),
			    segment_name (sub_symbol_segment));
	    }
	}

      if (fixP->fx_addsy)
	{
	  if (add_symbol_segment == this_segment
	      && !TC_FORCE_RELOCATION_LOCAL (fixP))
	    {
	      /* This fixup was made when the symbol's segment was
		 SEG_UNKNOWN, but it is now in the local segment.
		 So we know how to do the address without relocation.  */
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      fixP->fx_offset = add_number;
	      if (fixP->fx_pcrel)
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_addsy = NULL;
	      fixP->fx_pcrel = 0;
	    }
	  else if (add_symbol_segment == absolute_section
		   && !TC_FORCE_RELOCATION_ABS (fixP))
	    {
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_addsy = NULL;
	    }
	  else if (add_symbol_segment != undefined_section
#ifdef BFD_ASSEMBLER
		   && ! bfd_is_com_section (add_symbol_segment)
#endif
		   && MD_APPLY_SYM_VALUE (fixP))
	    add_number += S_GET_VALUE (fixP->fx_addsy);
	}

      if (fixP->fx_pcrel)
	{
	  add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	  if (!fixP->fx_done && fixP->fx_addsy == NULL)
	    {
	      /* There was no symbol required by this relocation.
		 However, BFD doesn't really handle relocations
		 without symbols well. So fake up a local symbol in
		 the absolute section.  */
	      fixP->fx_addsy = abs_section_sym;
	    }
	}

      if (!fixP->fx_done)
	md_apply_fix3 (fixP, &add_number, this_segment);

      if (!fixP->fx_done)
	{
	  ++seg_reloc_count;
	  if (fixP->fx_addsy == NULL)
	    fixP->fx_addsy = abs_section_sym;
	  symbol_mark_used_in_reloc (fixP->fx_addsy);
	  if (fixP->fx_subsy != NULL)
	    symbol_mark_used_in_reloc (fixP->fx_subsy);
	}

      if (!fixP->fx_bit_fixP && !fixP->fx_no_overflow && fixP->fx_size != 0)
	{
	  if (fixP->fx_size < sizeof (valueT))
	    {
	      valueT mask;

	      mask = 0;
	      mask--;		/* Set all bits to one.  */
	      mask <<= fixP->fx_size * 8 - (fixP->fx_signed ? 1 : 0);
	      if ((add_number & mask) != 0 && (add_number & mask) != mask)
		{
		  char buf[50], buf2[50];
		  sprint_value (buf, fragP->fr_address + fixP->fx_where);
		  if (add_number > 1000)
		    sprint_value (buf2, add_number);
		  else
		    sprintf (buf2, "%ld", (long) add_number);
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("value of %s too large for field of %d bytes at %s"),
				buf2, fixP->fx_size, buf);
		} /* Generic error checking.  */
	    }
#ifdef WARN_SIGNED_OVERFLOW_WORD
	  /* Warn if a .word value is too large when treated as a signed
	     number.  We already know it is not too negative.  This is to
	     catch over-large switches generated by gcc on the 68k.  */
	  if (!flag_signed_overflow_ok
	      && fixP->fx_size == 2
	      && add_number > 0x7fff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("signed .word overflow; switch may be too large; %ld at 0x%lx"),
			  (long) add_number,
			  (long) (fragP->fr_address + fixP->fx_where));
#endif
	}			/* Not a bit fix.  */

#ifdef TC_VALIDATE_FIX
    skip:  ATTRIBUTE_UNUSED_LABEL
      ;
#endif
#ifdef DEBUG5
      fprintf (stderr, "result:\n");
      print_fixup (fixP);
#endif
    }				/* For each fixS in this segment.  */

  TC_ADJUST_RELOC_COUNT (fixP, seg_reloc_count);
  return seg_reloc_count;
}

#endif /* defined (BFD_ASSEMBLER) || (!defined (BFD) && !defined (OBJ_VMS)) */

void
number_to_chars_bigendian (char *buf, valueT val, int n)
{
  if (n <= 0)
    abort ();
  while (n--)
    {
      buf[n] = val & 0xff;
      val >>= 8;
    }
}

void
number_to_chars_littleendian (char *buf, valueT val, int n)
{
  if (n <= 0)
    abort ();
  while (n--)
    {
      *buf++ = val & 0xff;
      val >>= 8;
    }
}

void
write_print_statistics (FILE *file)
{
  fprintf (file, "fixups: %d\n", n_fixups);
}

/* For debugging.  */
extern int indent_level;

void
print_fixup (fixS *fixp)
{
  indent_level = 1;
  fprintf (stderr, "fix %lx %s:%d", (long) fixp, fixp->fx_file, fixp->fx_line);
  if (fixp->fx_pcrel)
    fprintf (stderr, " pcrel");
  if (fixp->fx_pcrel_adjust)
    fprintf (stderr, " pcrel_adjust=%d", fixp->fx_pcrel_adjust);
  if (fixp->fx_im_disp)
    {
#ifdef TC_NS32K
      fprintf (stderr, " im_disp=%d", fixp->fx_im_disp);
#else
      fprintf (stderr, " im_disp");
#endif
    }
  if (fixp->fx_tcbit)
    fprintf (stderr, " tcbit");
  if (fixp->fx_done)
    fprintf (stderr, " done");
  fprintf (stderr, "\n    size=%d frag=%lx where=%ld offset=%lx addnumber=%lx",
	   fixp->fx_size, (long) fixp->fx_frag, (long) fixp->fx_where,
	   (long) fixp->fx_offset, (long) fixp->fx_addnumber);
#ifdef BFD_ASSEMBLER
  fprintf (stderr, "\n    %s (%d)", bfd_get_reloc_code_name (fixp->fx_r_type),
	   fixp->fx_r_type);
#else
#ifdef NEED_FX_R_TYPE
  fprintf (stderr, " r_type=%d", fixp->fx_r_type);
#endif
#endif
  if (fixp->fx_addsy)
    {
      fprintf (stderr, "\n   +<");
      print_symbol_value_1 (stderr, fixp->fx_addsy);
      fprintf (stderr, ">");
    }
  if (fixp->fx_subsy)
    {
      fprintf (stderr, "\n   -<");
      print_symbol_value_1 (stderr, fixp->fx_subsy);
      fprintf (stderr, ">");
    }
  fprintf (stderr, "\n");
#ifdef TC_FIX_DATA_PRINT
  TC_FIX_DATA_PRINT (stderr, fixp);
#endif
}
@


1.7
log
@Resolve merge conflicts, adjust method of W^X handing (.sh files)
remove testsuites (not useable) remove mmalloc (not part of new binutils).
@
text
@d115 1
a115 1
void print_fixup PARAMS ((fixS *));
d118 1
a118 1
static void renumber_sections PARAMS ((bfd *, asection *, PTR));
d160 4
a163 4
static fixS *fix_new_internal PARAMS ((fragS *, int where, int size,
				       symbolS *add, symbolS *sub,
				       offsetT offset, int pcrel,
				       RELOC_ENUM r_type));
d165 1
a165 1
static long fixup_segment PARAMS ((fixS *, segT));
d167 1
a167 1
static relax_addressT relax_align PARAMS ((relax_addressT addr, int align));
d169 1
a169 1
static fragS *chain_frchains_together_1 PARAMS ((segT, struct frchain *));
d172 7
a178 7
static void chain_frchains_together PARAMS ((bfd *, segT, PTR));
static void cvt_frag_to_fill PARAMS ((segT, fragS *));
static void adjust_reloc_syms PARAMS ((bfd *, asection *, PTR));
static void fix_segment PARAMS ((bfd *, asection *, PTR));
static void write_relocs PARAMS ((bfd *, asection *, PTR));
static void write_contents PARAMS ((bfd *, asection *, PTR));
static void set_symtab PARAMS ((void));
d181 1
a181 1
static void merge_data_into_text PARAMS ((void));
d184 3
a186 3
static void cvt_frag_to_fill PARAMS ((object_headers *, segT, fragS *));
static void remove_subsegs PARAMS ((frchainS *, int, fragS **, fragS **));
static void relax_and_size_all_segments PARAMS ((void));
d192 8
a199 10
fix_new_internal (frag, where, size, add_symbol, sub_symbol, offset, pcrel,
		  r_type)
     fragS *frag;		/* Which frag?  */
     int where;			/* Where in that frag?  */
     int size;			/* 1, 2, or 4 usually.  */
     symbolS *add_symbol;	/* X_add_symbol.  */
     symbolS *sub_symbol;	/* X_op_symbol.  */
     offsetT offset;		/* X_add_number.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
     RELOC_ENUM r_type ATTRIBUTE_UNUSED; /* Relocation type.  */
d284 7
a290 8
fix_new (frag, where, size, add_symbol, offset, pcrel, r_type)
     fragS *frag;		/* Which frag?  */
     int where;			/* Where in that frag?  */
     int size;			/* 1, 2, or 4 usually.  */
     symbolS *add_symbol;	/* X_add_symbol.  */
     offsetT offset;		/* X_add_number.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
     RELOC_ENUM r_type;		/* Relocation type.  */
d301 6
a306 7
fix_new_exp (frag, where, size, exp, pcrel, r_type)
     fragS *frag;		/* Which frag?  */
     int where;			/* Where in that frag?  */
     int size;			/* 1, 2, or 4 usually.  */
     expressionS *exp;		/* Expression.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
     RELOC_ENUM r_type;		/* Relocation type.  */
d375 1
a375 2
generic_force_reloc (fix)
     fixS *fix;
d387 1
a387 4
append (charPP, fromP, length)
     char **charPP;
     char *fromP;
     unsigned long length;
d407 5
a411 6
record_alignment (seg, align)
     /* Segment to which alignment pertains.  */
     segT seg;
     /* Alignment, as a power of 2 (e.g., 1 => 2-byte boundary, 2 => 4-byte
	boundary, etc.)  */
     int align;
d425 1
a425 2
get_recorded_alignment (seg)
     segT seg;
d441 1
a441 4
renumber_sections (abfd, sec, countparg)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR countparg;
d454 1
a454 3
chain_frchains_together_1 (section, frchp)
     segT section;
     struct frchain *frchp;
d487 3
a489 4
chain_frchains_together (abfd, section, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT section;
     PTR xxx ATTRIBUTE_UNUSED;
d510 1
a510 5
remove_subsegs (head, seg, root, last)
     frchainS *head;
     int seg;
     fragS **root;
     fragS **last;
d522 1
a522 3
cvt_frag_to_fill (sec, fragP)
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
d525 1
a525 4
cvt_frag_to_fill (headersP, sec, fragP)
     object_headers *headersP;
     segT sec;
     fragS *fragP;
d624 2
a625 1
static void relax_seg PARAMS ((bfd *, asection *, PTR));
d627 1
a627 4
relax_seg (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR xxx;
d639 2
a640 1
static void size_seg PARAMS ((bfd *, asection *, PTR));
d642 1
a642 4
size_seg (abfd, sec, xxx)
     bfd *abfd;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d755 3
a757 4
adjust_reloc_syms (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d877 3
a879 4
fix_segment (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d887 1
a887 4
write_relocs (abfd, sec, xxx)
     bfd *abfd;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d907 1
a907 2
  relocs = (arelent **) xmalloc (n * sizeof (arelent *));
  memset ((char *) relocs, 0, n * sizeof (arelent *));
d979 1
a979 1
  relocs = (arelent **) xmalloc (n * sizeof (arelent *));
d1098 3
a1100 4
write_contents (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d1103 1
a1103 1
  unsigned long offset = 0;
d1116 1
a1116 1
      unsigned long fill_size;
d1118 1
a1118 1
      long count;
d1196 1
a1196 1
merge_data_into_text ()
d1278 1
a1278 1
    long bss_vma;
d1313 1
a1313 1
set_symtab ()
d1319 1
a1319 1
  extern PTR bfd_alloc PARAMS ((bfd *, bfd_size_type));
d1357 1
a1357 1
/* The last subsegment gets an aligment corresponding to the alignment
d1373 1
a1373 1
subsegs_finish ()
d1426 1
a1426 1
write_object_file ()
d2029 1
a2029 4
relax_frag (segment, fragP, stretch)
     segT segment;
     fragS *fragP;
     long stretch;
d2035 1
a2035 1
  long growth;
d2136 2
a2137 3
relax_align (address, alignment)
     register relax_addressT address;	/* Address now.  */
     register int alignment;	/* Alignment (binary).  */
d2164 1
a2164 3
relax_segment (segment_frag_root, segment)
     struct frag *segment_frag_root;
     segT segment;
d2255 1
a2255 1
    long stretch;	/* May be any size, 0 or negative.  */
d2270 1
a2270 1
	    long growth = 0;
d2405 1
a2405 1
				    _("attempt to .org backwards"));
d2464 1
a2464 1
		  int size;
d2519 1
a2519 3
fixup_segment (fixP, this_segment)
     fixS *fixP;
     segT this_segment;
a2601 9
	      /* If the back-end code has selected a pc-relative
		 reloc, adjust the value to be pc-relative.  */
	      if (1
#ifdef TC_M68K
		  /* See the comment below about 68k weirdness.  */
		  && 0
#endif
		  && fixP->fx_pcrel)
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment); 
d2604 2
d2607 1
d2759 1
a2759 4
number_to_chars_bigendian (buf, val, n)
     char *buf;
     valueT val;
     int n;
d2771 1
a2771 4
number_to_chars_littleendian (buf, val, n)
     char *buf;
     valueT val;
     int n;
d2783 1
a2783 2
write_print_statistics (file)
     FILE *file;
d2792 1
a2792 2
print_fixup (fixp)
     fixS *fixp;
@


1.6
log
@resolve conflicts.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001
a30 4
/* This looks like a good idea.  Let's try turning it on always, for now.  */
#undef  BFD_FAST_SECTION_FILL
#define BFD_FAST_SECTION_FILL

d32 1
a32 1
#define TC_ADJUST_RELOC_COUNT(FIXP,COUNT)
d36 14
a49 1
#define TC_FORCE_RELOCATION(FIXP) 0
d52 30
a81 2
#ifndef TC_FORCE_RELOCATION_SECTION
#define TC_FORCE_RELOCATION_SECTION(FIXP,SEG) TC_FORCE_RELOCATION(FIXP)
d88 6
a93 2
#ifndef TC_FIX_ADJUSTABLE
#define TC_FIX_ADJUSTABLE(fix) 1
d97 1
a97 1
#define MD_PCREL_FROM_SECTION(FIXP, SEC) md_pcrel_from(FIXP)
d101 2
a102 2
extern CONST int md_short_jump_size;
extern CONST int md_long_jump_size;
d105 3
d109 6
d155 1
a155 4
static fixS *fix_new_internal PARAMS ((fragS *, int where, int size,
				       symbolS *add, symbolS *sub,
				       offsetT offset, int pcrel,
				       bfd_reloc_code_real_type r_type));
d157 3
d163 1
a163 2
				       int r_type));
#endif
d165 1
a165 1
static long fixup_segment PARAMS ((fixS * fixP, segT this_segment_type));
a173 2
static void relax_seg PARAMS ((bfd *, asection *, PTR));
static void size_seg PARAMS ((bfd *, asection *, PTR));
d175 1
a187 3
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && defined (TE_GO32)
static void set_segment_vma PARAMS ((bfd *, asection *, PTR));
#endif
d201 1
a201 5
#ifdef BFD_ASSEMBLER
     bfd_reloc_code_real_type r_type; /* Relocation type.  */
#else
     int r_type;		/* Relocation type.  */
#endif
d221 1
d293 1
a293 5
#ifdef BFD_ASSEMBLER
     bfd_reloc_code_real_type r_type; /* Relocation type.  */
#else
     int r_type;		/* Relocation type.  */
#endif
d310 1
a310 5
#ifdef BFD_ASSEMBLER
     bfd_reloc_code_real_type r_type; /* Relocation type.  */
#else
     int r_type;		/* Relocation type.  */
#endif
d377 13
d572 1
d649 1
d651 2
a652 2
relax_seg (abfd, sec, do_code)
     bfd *abfd;
d654 1
a654 1
     PTR do_code;
a655 1
  flagword flags = bfd_get_section_flags (abfd, sec);
d658 6
a663 3
  if (!(flags & SEC_CODE) == !do_code
      && seginfo && seginfo->frchainP)
    relax_segment (seginfo->frchainP->frch_root, sec);
d666 1
d707 1
a707 1
  assert (x == true);
d711 1
a711 1
  assert (x == true);
d723 8
a730 1
      fragp->fr_offset += newsize - size;
d780 3
d817 1
a817 2
	if (sym != NULL)
	  resolve_symbol_value (sym, 1);
d820 1
a820 1
	  resolve_symbol_value (fixp->fx_subsy, 1);
d824 1
a824 2
	if (sym != NULL && symbol_equated_p (sym)
	    && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
d831 1
a831 1
	if (sym != NULL && symbol_mri_common_p (sym))
d834 1
a834 1
	    goto done;
d837 18
a855 1

d861 3
a863 30
	    /* The fixup_segment routine will not use this symbol in a
               relocation unless TC_FORCE_RELOCATION returns 1.  */
	    if (TC_FORCE_RELOCATION (fixp))
	      {
		symbol_mark_used_in_reloc (fixp->fx_addsy);
#ifdef UNDEFINED_DIFFERENCE_OK
		if (fixp->fx_subsy != NULL)
		  symbol_mark_used_in_reloc (fixp->fx_subsy);
#endif
	      }
	    goto done;
	  }

	/* If it's one of these sections, assume the symbol is
	   definitely going to be output.  The code in
	   md_estimate_size_before_relax in tc-mips.c uses this test
	   as well, so if you change this code you should look at that
	   code.  */
	if (bfd_is_und_section (symsec)
	    || bfd_is_com_section (symsec))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
#ifdef UNDEFINED_DIFFERENCE_OK
	    /* We have the difference of an undefined symbol and some
	       other symbol.  Make sure to mark the other symbol as used
	       in a relocation so that it will always be output.  */
	    if (fixp->fx_subsy)
	      symbol_mark_used_in_reloc (fixp->fx_subsy);
#endif
	    goto done;
d872 8
a879 26
	    boolean linkonce;

	    linkonce = false;
#ifdef BFD_ASSEMBLER
	    if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE)
		!= 0)
	      linkonce = true;
#endif
#ifdef OBJ_ELF
	    /* The GNU toolchain uses an extension for ELF: a section
               beginning with the magic string .gnu.linkonce is a
               linkonce section.  */
	    if (strncmp (segment_name (symsec), ".gnu.linkonce",
			 sizeof ".gnu.linkonce" - 1) == 0)
	      linkonce = true;
#endif

	    if (linkonce)
	      {
		symbol_mark_used_in_reloc (fixp->fx_addsy);
#ifdef UNDEFINED_DIFFERENCE_OK
		if (fixp->fx_subsy != NULL)
		  symbol_mark_used_in_reloc (fixp->fx_subsy);
#endif
		goto done;
	      }
d882 5
a886 7
	/* Since we're reducing to section symbols, don't attempt to reduce
	   anything that's already using one.  */
	if (symbol_section_p (sym))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    goto done;
	  }
d888 3
a890 11
#ifdef BFD_ASSEMBLER
	/* We can never adjust a reloc against a weak symbol.  If we
           did, and the weak symbol was overridden by a real symbol
           somewhere else, then our relocation would be pointing at
           the wrong area of memory.  */
	if (S_IS_WEAK (sym))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    goto done;
	  }
#endif
d892 1
a892 26
	/* Is there some other reason we can't adjust this one?  (E.g.,
	   call/bal links in i960-bout symbols.)  */
#ifdef obj_fix_adjustable
	if (! obj_fix_adjustable (fixp))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    goto done;
	  }
#endif

	/* Is there some other (target cpu dependent) reason we can't adjust
	   this one?  (E.g. relocations involving function addresses on
	   the PA.  */
#ifdef tc_fix_adjustable
	if (! tc_fix_adjustable (fixp))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    goto done;
	  }
#endif

	/* If the section symbol isn't going to be output, the relocs
	   at least should still work.  If not, figure out what to do
	   when we run into that case.

	   We refetch the segment when calling section_symbol, rather
a896 1
	symbol_mark_used_in_reloc (fixp->fx_addsy);
d901 1
d903 2
a904 10
      done:
	;
      }
#if 1 /* def RELOC_REQUIRES_SYMBOL  */
    else
      {
	/* There was no symbol required by this relocation.  However,
	   BFD doesn't really handle relocations without symbols well.
	   (At least, the COFF support doesn't.)  So for now we fake up
	   a local symbol in the absolute section.  */
d906 7
a912 6
	fixp->fx_addsy = section_symbol (absolute_section);
#if 0
	fixp->fx_addsy->sy_used_in_reloc = 1;
#endif
      }
#endif
d914 1
a914 1
  dump_section_relocs (abfd, sec, stderr);
a934 2
  fixup_segment (seginfo->fix_root, sec);

d958 1
a958 1
         symbol, then use generate the reloc against the latter symbol
d961 1
a961 2
      while (symbol_equated_p (sym)
	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
d998 2
a999 1
	  as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation overflow"));
d1002 2
a1003 1
	  as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation out of range"));
a1019 1
      char *data;
d1034 12
a1045 3
      while (symbol_equated_p (sym)
	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
	sym = symbol_get_value_expression (sym)->X_add_symbol;
a1054 1
      data = fixp->fx_frag->fr_literal + fixp->fx_where;
d1073 4
d1078 2
a1079 2
	      as_fatal (_("%s:%u: bad return from bfd_install_relocation"),
			fixp->fx_file, fixp->fx_line);
d1162 1
a1162 1
	  if (x == false)
d1186 1
a1186 1
		  if (x == false)
d1220 2
a1221 2
		  if (x != true)
		    as_fatal (_("Cannot write to output file."));
d1354 2
a1355 2
  boolean result;
  extern PTR bfd_alloc PARAMS ((bfd *, size_t));
d1367 1
d1369 1
a1369 2
      asympp = (asymbol **) bfd_alloc (stdoutput,
				       nsyms * sizeof (asymbol *));
d1380 1
a1380 1
  assert (result == true);
a1384 14
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && defined (TE_GO32)
static void
set_segment_vma (abfd, sec, xxx)
     bfd *abfd;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
{
  static bfd_vma addr = 0;

  bfd_set_section_vma (abfd, sec, addr);
  addr += bfd_section_size (abfd, sec);
}
#endif /* BFD_ASSEMBLER && OBJ_COFF && !TE_PE  */

d1392 8
d1401 1
a1401 1
#define SUB_SEGMENT_ALIGN(SEG) (0)
d1403 2
a1404 1
#define SUB_SEGMENT_ALIGN(SEG) (2)
d1415 1
a1415 1
      int alignment;
d1422 9
a1430 1
      alignment = had_errors () ? 0 : SUB_SEGMENT_ALIGN (now_seg);
d1432 10
a1441 5
      /* The last subsegment gets an aligment corresponding to the
	 alignment of the section.  This allows proper nop-filling
	 at the end of code-bearing sections.  */
      if (!frchainP->frch_next || frchainP->frch_next->frch_seg != now_seg)
	alignment = get_recorded_alignment (now_seg);
d1478 1
a1478 1
	  as_warn (_("%d error%s, %d warning%s, generating bad object file.\n"),
d1485 1
a1485 1
	  as_fatal (_("%d error%s, %d warning%s, no object file generated.\n"),
d1504 1
a1504 1
    asection **seclist, *sec;
d1508 1
a1508 1
    while (seclist && *seclist)
d1510 1
a1510 2
	sec = *seclist;
	while (sec == reg_section || sec == expr_section)
d1512 1
a1512 2
	    sec = sec->next;
	    *seclist = sec;
a1513 2
	    if (!sec)
	      break;
d1515 1
a1515 1
	if (*seclist)
d1540 39
a1578 2
  bfd_map_over_sections (stdoutput, relax_seg, (char *) 1);
  bfd_map_over_sections (stdoutput, relax_seg, (char *) 0);
d1584 5
a1588 6
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && defined (TE_GO32)
  /* Now that the segments have their final sizes, run through the
     sections and set their vma and lma. !BFD gas sets them, and BFD gas
     should too. Currently, only DJGPP uses this code, but other
     COFF targets may need to execute this too.  */
  bfd_map_over_sections (stdoutput, set_segment_vma, (char *) 0);
d1642 1
a1642 1
	    || ((fragP->fr_next->fr_address - fragP->fr_address)
a1736 3
#ifdef BFD_ASSEMBLER
	    to_addr -= symbol_get_frag (lie->sub)->fr_address;
#endif
a1752 3
#ifdef BFD_ASSEMBLER
	    to_addr += symbol_get_frag (lie->add)->fr_address;
#endif
d1870 2
a1871 2
    bfd_seek (stdoutput, 0, 0);
    bfd_write (the_object_file, 1, object_file_size, stdoutput);
d1895 1
a1895 1
	resolve_symbol_value (symp, 1);
d1910 9
d1946 1
a1946 1
		as_bad (_("local label %s is not defined"), name2);
d1952 1
a1952 1
	  resolve_symbol_value (symp, 1);
d1956 1
a1956 2
	  if (symbol_equated_p (symp)
	      && (! S_IS_DEFINED (symp) || S_IS_COMMON (symp)))
d1988 3
a1990 2
	  if ((! EMIT_SECTION_SYMBOLS
	       && symbol_section_p (symp))
d1995 1
a1995 1
		  && (S_IS_LOCAL (symp) || punt)
d2009 1
a2009 1
	      as_bad (_("can't resolve value for symbol \"%s\""),
d2103 1
a2103 1
      know (!(S_GET_SEGMENT (symbolP) == absolute_section)
d2105 1
a2105 1
      target += S_GET_VALUE (symbolP) + sym_frag->fr_address;
d2203 1
a2203 1
void
d2210 2
d2244 3
a2246 2
		as_bad (_("alignment padding (%lu bytes) not a multiple of %ld"),
			(unsigned long) offset, (long) fragP->fr_var);
d2260 6
d2352 1
a2352 2
		      offset = (symbol_get_frag (lie->add)->fr_address
				+ S_GET_VALUE (lie->add)
d2354 1
a2354 2
				- (symbol_get_frag (lie->sub)->fr_address
				   + S_GET_VALUE (lie->sub)));
d2361 5
a2365 4
			      as_warn (_(".word %s-%s+%s didn't fit"),
				       S_GET_NAME (lie->add),
				       S_GET_NAME (lie->sub),
				       buf);
d2430 7
a2436 3
		      target += (S_GET_VALUE (symbolP)
				 + symbol_get_frag (symbolP)->fr_address);
		    }		/* if we have a symbol  */
d2447 1
a2447 1
				    _("attempt to .org backwards ignored"));
d2464 1
d2467 4
a2470 2
		    growth = S_GET_VALUE (symbolP);
		    if (symbol_get_frag (symbolP) != &zero_address_frag
a2472 4
		      as_bad_where (fragP->fr_file, fragP->fr_line,
				    _(".space specifies non-absolute value"));
		    fragP->fr_symbol = 0;
		    if (growth < 0)
d2474 10
a2483 2
			as_warn (_(".space or .fill with negative value, ignored"));
			growth = 0;
d2485 3
a2488 2
		else
		  growth = 0;
d2508 1
a2508 1
		  value = resolve_symbol_value (fragP->fr_symbol, 0);
d2537 8
a2544 4
  /* We now have valid fr_address'es for each frag.  */

  /* All fr_address's are correct, relative to their own segment.
     We have made all the fixS we will ever make.  */
a2548 4
#ifndef TC_RELOC_RTSYM_LOC_FIXUP
#define TC_RELOC_RTSYM_LOC_FIXUP(X) (1)
#endif

d2554 1
a2554 1
   For each one, call md_apply_fix to put the fix into the frag data.
d2561 3
a2563 3
fixup_segment (fixP, this_segment_type)
     register fixS *fixP;
     segT this_segment_type;	/* N_TYPE bits for segment.  */
a2565 2
  symbolS *add_symbolP;
  symbolS *sub_symbolP;
a2566 4
  int size;
  char *place;
  long where;
  int pcrel, plt;
d2570 9
d2581 5
a2585 6
     Well, strictly speaking that's not true -- we could do any that are
     PC-relative and don't cross regions that could change size.  And for the
     i960 (the only machine for which we've got a relaxing linker right now),
     we might be able to turn callx/callj into bal anyways in cases where we
     know the maximum displacement.  */
  if (linkrelax && TC_LINKRELAX_FIXUP (this_segment_type))
d2588 15
a2602 1
	seg_reloc_count++;
a2615 4
      where = fixP->fx_where;
      place = fragP->fr_literal + where;
      size = fixP->fx_size;
      add_symbolP = fixP->fx_addsy;
d2617 1
a2617 1
      TC_VALIDATE_FIX (fixP, this_segment_type, skip);
a2618 1
      sub_symbolP = fixP->fx_subsy;
a2619 2
      pcrel = fixP->fx_pcrel;
      plt = fixP->fx_plt;
d2621 2
a2622 2
      if (add_symbolP != NULL
	  && symbol_mri_common_p (add_symbolP))
d2624 2
a2625 2
	  know (add_symbolP->sy_value.X_op == O_symbol);
	  add_number += S_GET_VALUE (add_symbolP);
d2627 2
a2628 2
	  add_symbolP = fixP->fx_addsy =
	    symbol_get_value_expression (add_symbolP)->X_add_symbol;
d2631 2
a2632 2
      if (add_symbolP)
	add_symbol_segment = S_GET_SEGMENT (add_symbolP);
d2634 1
a2634 1
      if (sub_symbolP)
d2636 25
a2660 2
	  resolve_symbol_value (sub_symbolP, 1);
	  if (add_symbolP == NULL || add_symbol_segment == absolute_section)
d2662 3
a2664 24
	      if (add_symbolP != NULL)
		{
		  add_number += S_GET_VALUE (add_symbolP);
		  add_symbolP = NULL;
		  fixP->fx_addsy = NULL;
		}

	      /* It's just -sym.  */
	      if (S_GET_SEGMENT (sub_symbolP) == absolute_section)
		{
		  add_number -= S_GET_VALUE (sub_symbolP);
		  fixP->fx_subsy = NULL;
		}
	      else if (pcrel
		       && S_GET_SEGMENT (sub_symbolP) == this_segment_type)
		{
		  /* Should try converting to a constant.  */
		  goto bad_sub_reloc;
		}
	      else
	      bad_sub_reloc:
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("Negative of non-absolute symbol %s"),
			      S_GET_NAME (sub_symbolP));
d2666 2
a2667 2
	  else if (S_GET_SEGMENT (sub_symbolP) == add_symbol_segment
		   && SEG_NORMAL (add_symbol_segment))
d2669 19
a2687 25
	      /* Difference of 2 symbols from same segment.
		 Can't make difference of 2 undefineds: 'value' means
		 something different for N_UNDF.  */
#ifdef TC_I960
	      /* Makes no sense to use the difference of 2 arbitrary symbols
		 as the target of a call instruction.  */
	      if (fixP->fx_tcbit)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("callj to difference of 2 symbols"));
#endif /* TC_I960  */
	      add_number += S_GET_VALUE (add_symbolP) -
		S_GET_VALUE (sub_symbolP);

	      add_symbolP = NULL;
	      pcrel = 0;	/* No further pcrel processing.  */

	      /* Let the target machine make the final determination
		 as to whether or not a relocation will be needed to
		 handle this fixup.  */
	      if (!TC_FORCE_RELOCATION_SECTION (fixP, this_segment_type))
		{
		  fixP->fx_pcrel = 0;
		  fixP->fx_addsy = NULL;
		  fixP->fx_subsy = NULL;
		}
d2689 1
a2689 1
	  else
d2691 6
a2696 55
	      /* Different segments in subtraction.  */
	      know (!(S_IS_EXTERNAL (sub_symbolP)
		      && (S_GET_SEGMENT (sub_symbolP) == absolute_section)));

	      if ((S_GET_SEGMENT (sub_symbolP) == absolute_section))
		add_number -= S_GET_VALUE (sub_symbolP);

#ifdef DIFF_EXPR_OK
	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type
#if 0
		       /* Do this even if it's already described as
			  pc-relative.  For example, on the m68k, an
			  operand of "pc@@(foo-.-2)" should address
			  "foo" in a pc-relative mode.  */
		       && pcrel
#endif
		       )
		{
		  /* Make it pc-relative.  */
		  add_number += (MD_PCREL_FROM_SECTION (fixP, this_segment_type)
				 - S_GET_VALUE (sub_symbolP));
		  pcrel = 1;
		  fixP->fx_pcrel = 1;
		  sub_symbolP = 0;
		  fixP->fx_subsy = 0;
		}
#endif
#ifdef UNDEFINED_DIFFERENCE_OK
	      /* The PA needs this for PIC code generation.  We basically
		 don't want to do anything if we have the difference of two
		 symbols at this point.  */
	      else if (1)
		{
		  /* Leave it alone.  */
		}
#endif
#ifdef BFD_ASSEMBLER
	      else if (fixP->fx_r_type == BFD_RELOC_GPREL32
		       || fixP->fx_r_type == BFD_RELOC_GPREL16)
		{
		  /* Leave it alone.  */
		}
#endif
	      else
		{
		  char buf[50];
		  sprint_value (buf, fragP->fr_address + where);
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("Subtraction of two symbols in different sections \"%s\" {%s section} - \"%s\" {%s section} at file address %s."),
				S_GET_NAME (add_symbolP),
				segment_name (S_GET_SEGMENT (add_symbolP)),
				S_GET_NAME (sub_symbolP),
				segment_name (S_GET_SEGMENT (sub_symbolP)),
				buf);
		}
d2700 1
a2700 1
      if (add_symbolP)
d2702 2
a2703 2
	  if (add_symbol_segment == this_segment_type && pcrel && !plt
	      && TC_RELOC_RTSYM_LOC_FIXUP (fixP))
d2708 6
a2713 22
#ifdef TC_I960
	      /* reloc_callj() may replace a 'call' with a 'calls' or a
		 'bal', in which cases it modifies *fixP as appropriate.
		 In the case of a 'calls', no further work is required,
		 and *fixP has been set up to make the rest of the code
		 below a no-op.  */
	      reloc_callj (fixP);
#endif /* TC_I960  */

	      add_number += S_GET_VALUE (add_symbolP);
	      add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment_type);
	      /* Lie.  Don't want further pcrel processing.  */
	      pcrel = 0;

	      /* Let the target machine make the final determination
		 as to whether or not a relocation will be needed to
		 handle this fixup.  */
	      if (!TC_FORCE_RELOCATION (fixP))
		{
		  fixP->fx_pcrel = 0;
		  fixP->fx_addsy = NULL;
		}
d2715 2
a2716 1
	  else
d2718 5
a2722 20
	      if (add_symbol_segment == absolute_section
		  && ! pcrel)
		{
#ifdef TC_I960
		  /* See comment about reloc_callj() above.  */
		  reloc_callj (fixP);
#endif /* TC_I960  */
		  add_number += S_GET_VALUE (add_symbolP);

		  /* Let the target machine make the final determination
		     as to whether or not a relocation will be needed to
		     handle this fixup.  */

		  if (!TC_FORCE_RELOCATION (fixP))
		    {
		      fixP->fx_addsy = NULL;
		      add_symbolP = NULL;
		    }
		}
	      else if (add_symbol_segment == undefined_section
d2724 1
a2724 1
		       || bfd_is_com_section (add_symbol_segment)
d2726 2
a2727 32
		       )
		{
#ifdef TC_I960
		  if ((int) fixP->fx_bit_fixP == 13)
		    {
		      /* This is a COBR instruction.  They have only a
			 13-bit displacement and are only to be used
			 for local branches: flag as error, don't generate
			 relocation.  */
		      as_bad_where (fixP->fx_file, fixP->fx_line,
				    _("can't use COBR format with external label"));
		      fixP->fx_addsy = NULL;
		      fixP->fx_done = 1;
		      continue;
		    }		/* COBR.  */
#endif /* TC_I960  */

#ifdef OBJ_COFF
#ifdef TE_I386AIX
		  if (S_IS_COMMON (add_symbolP))
		    add_number += S_GET_VALUE (add_symbolP);
#endif /* TE_I386AIX  */
#endif /* OBJ_COFF  */
		  ++seg_reloc_count;
		}
	      else
		{
		  seg_reloc_count++;
		  if (TC_FIX_ADJUSTABLE (fixP))
		    add_number += S_GET_VALUE (add_symbolP);
		}
	    }
d2730 1
a2730 1
      if (pcrel)
d2732 2
a2733 2
	  add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment_type);
	  if (add_symbolP == 0)
d2735 5
a2739 7
#ifndef BFD_ASSEMBLER
	      fixP->fx_addsy = &abs_symbol;
#else
	      fixP->fx_addsy = section_symbol (absolute_section);
#endif
	      symbol_mark_used_in_reloc (fixP->fx_addsy);
	      ++seg_reloc_count;
d2744 3
d2748 6
a2753 17
#ifdef MD_APPLY_FIX3
	  md_apply_fix3 (fixP, &add_number, this_segment_type);
#else
#ifdef BFD_ASSEMBLER
	  md_apply_fix (fixP, &add_number);
#else
	  md_apply_fix (fixP, add_number);
#endif
#endif

#ifndef TC_HANDLES_FX_DONE
	  /* If the tc-* files haven't been converted, assume it's handling
	     it the old way, where a null fx_addsy means that the fix has
	     been applied completely, and no further work is needed.  */
	  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
	    fixP->fx_done = 1;
#endif
d2756 1
a2756 1
      if (!fixP->fx_bit_fixP && !fixP->fx_no_overflow && size > 0)
d2758 1
a2758 1
	  if ((size_t) size < sizeof (valueT))
d2764 1
a2764 1
	      mask <<= size * 8 - (fixP->fx_signed ? 1 : 0);
d2768 1
a2768 1
		  sprint_value (buf, fragP->fr_address + where);
d2774 2
a2775 2
				_("Value of %s too large for field of %d bytes at %s"),
				buf2, size, buf);
d2783 1
a2783 1
	      && size == 2
d2786 1
a2786 1
			  _("Signed .word overflow; switch may be too large; %ld at 0x%lx"),
d2788 1
a2788 1
			  (unsigned long) (fragP->fr_address + where));
d2814 1
a2814 1
  if ((size_t) n > sizeof (val) || n <= 0)
d2829 1
a2829 1
  if ((size_t) n > sizeof (val) || n <= 0)
@


1.5
log
@Help stupid cvs fixing basic conflicts.
@
text
@d2 2
a3 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d23 1
a23 1
/* This thing should be set up to do byteordering correctly.  But... */
d29 1
a34 6
/* The NOP_OPCODE is for the alignment fill value.  Fill it with a nop
   instruction so that the disassembler does not choke on it.  */
#ifndef NOP_OPCODE
#define NOP_OPCODE 0x00
#endif

d47 8
d84 3
a86 3
struct frag *text_last_frag;	/* Last frag in segment. */
struct frag *data_last_frag;	/* Last frag in segment. */
static struct frag *bss_last_frag;	/* Last frag in segment. */
d94 1
a94 1
char *next_object_file_charP;	/* Tracks object file bytes. */
d100 1
a100 1
#endif /* BFD_ASSEMBLER */
d125 2
a126 1
static void relax_and_size_seg PARAMS ((bfd *, asection *, PTR));
d140 5
a145 5
/*
 *			fix_new()
 *
 * Create a fixS in obstack 'notes'.
 */
d149 7
a155 7
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2, or 4 usually. */
     symbolS *add_symbol;	/* X_add_symbol. */
     symbolS *sub_symbol;	/* X_op_symbol. */
     offsetT offset;		/* X_add_number. */
     int pcrel;			/* TRUE if PC-relative relocation. */
d157 1
a157 1
     bfd_reloc_code_real_type r_type; /* Relocation type */
d159 1
a159 1
     int r_type;		/* Relocation type */
d200 1
a200 1
  TC_INIT_FIX_DATA(fixP);
d208 1
a208 2
     time option.  xoxorich. */

d225 1
a225 1
#else /* REVERSE_SORT_RELOCS */
d235 1
a235 2
#endif /* REVERSE_SORT_RELOCS */

d245 6
a250 6
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2, or 4 usually. */
     symbolS *add_symbol;	/* X_add_symbol. */
     offsetT offset;		/* X_add_number. */
     int pcrel;			/* TRUE if PC-relative relocation. */
d252 1
a252 1
     bfd_reloc_code_real_type r_type; /* Relocation type */
d254 1
a254 1
     int r_type;		/* Relocation type */
d267 3
a269 3
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2, or 4 usually. */
d271 1
a271 1
     int pcrel;			/* TRUE if PC-relative relocation. */
d273 1
a273 1
     bfd_reloc_code_real_type r_type; /* Relocation type */
d275 1
a275 1
     int r_type;		/* Relocation type */
d287 4
d296 1
d301 1
d315 1
a315 1
      as_fatal(_("rva not supported"));
d330 1
a330 1
      /* Fall through.   */
d340 1
a340 2
  return fix_new_internal (frag, where, size, add, sub, off,
			   pcrel, r_type);
d350 1
a350 1
  /* Don't trust memcpy() of 0 chars. */
d362 5
a366 6
/*
 * This routine records the largest alignment seen for each segment.
 * If the beginning of the segment is aligned on the worst-case
 * boundary, all of the other alignments within it will work.  At
 * least one object format really uses this info.
 */
d369 1
a369 1
     /* Segment to which alignment pertains */
d386 13
d415 1
a415 1
#endif /* defined (BFD_ASSEMBLER) */
d466 2
a467 2
   info->frchainP->frch_last
     = chain_frchains_together_1 (section, info->frchainP);
d489 1
a489 1
#endif /* BFD */
d496 1
a496 1
     segT sec;
d510 1
d552 4
d567 3
a569 5
      /*
       * After md_convert_frag, we make the frag into a ".space 0".
       * Md_convert_frag() should set up any fixSs and constants
       * required.
       */
d598 1
a598 1
#endif /* defined (BFD_ASSEMBLER) || !defined (BFD) */
d602 15
a616 1
relax_and_size_seg (abfd, sec, xxx)
a628 2
  flags = bfd_get_section_flags (abfd, sec);

a631 1
      relax_segment (seginfo->frchainP->frch_root, sec);
d637 2
a638 1
	/* walk to last elt */;
d644 2
d737 2
a738 1
      /* ignore it */;
d757 1
a757 1
	
d781 1
a781 1
	
d897 1
a897 1
	   the section when it calls resolve_symbol_value. */
d909 1
a909 1
#if 1/*def RELOC_REQUIRES_SYMBOL*/
d918 3
a920 1
/*	fixp->fx_addsy->sy_used_in_reloc = 1; */
d934 1
a934 1
  int i;
d954 1
a954 1
  memset ((char*)relocs, 0, n * sizeof (arelent*));
d1043 1
a1043 1
         symbol, then use generate the reloc against the latter symbol
d1055 2
a1056 2
          relocs[i++] = reloc[j];
          assert(i <= n);
d1064 1
a1064 1
        {
d1069 1
a1069 1
          switch (s)
d1081 1
a1081 1
        }
d1144 1
a1144 1
      || ! (bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS))
d1177 1
a1177 1
	  if (fill_size > sizeof(buf))
d1179 1
a1179 1
	      /* Do it the old way. Can this ever happen? */
d1189 2
a1190 1
		      as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
d1210 1
a1210 1
		  n_per_buf = sizeof(buf)/fill_size;
d1212 1
a1212 1
		    memcpy(bufp, fill_literal, fill_size);
d1217 3
a1219 3
		  x = bfd_set_section_contents (stdoutput, sec,
						buf, (file_ptr) offset,
						(bfd_size_type) n_per_buf * fill_size);
d1258 1
a1258 1
#endif /* BFD_ASSEMBLER || (! BFD && ! OBJ_AOUT) */
a1268 3
  /*
   * Now the addresses of frags are correct within the segment.
   */
d1270 1
d1275 5
a1279 7
  /*
   * Join the 2 segments into 1 huge segment.
   * To do this, re-compute every rn_address in the SEG_DATA frags.
   * Then join the data frags after the text frags.
   *
   * Determine a_data [length of data segment].
   */
d1284 2
a1285 1
      know ((text_last_frag->fr_type == rs_fill) && (text_last_frag->fr_offset == 0));
d1289 1
a1289 1
      slide = H_GET_TEXT_SIZE (&headers);	/* & in file of the data segment. */
d1301 1
a1301 3
	{
	  fragP->fr_address += slide;
	}			/* for each data frag */
d1322 1
a1322 1
#else /* ! OBJ_BOUT */
d1326 1
a1326 1
#endif /* ! OBJ_BOUT */
d1328 1
a1328 1
  /* Slide all the frags */
d1334 1
a1334 3
	{
	  fragP->fr_address += slide;
	}			/* for each bss frag */
d1343 1
a1343 1
#endif /* ! BFD_ASSEMBLER && ! BFD */
d1385 14
d1420 2
d1427 12
a1438 3
      frag_align (had_errors () ? 0 : SUB_SEGMENT_ALIGN (now_seg),
		  subseg_text_p (now_seg) ? NOP_OPCODE : 0,
		  0);
a1444 1

d1457 1
a1457 1
  fragS *fragP;			/* Track along all frags. */
d1486 1
a1486 1
     and if so -- fix it up so that it can be program entry point. */
d1488 1
a1488 1
#endif /* OBJ_VMS */
d1536 3
a1538 1
  bfd_map_over_sections (stdoutput, relax_and_size_seg, (char *) 0);
d1541 9
a1549 1
#endif /* BFD_ASSEMBLER */
d1552 17
a1568 21
  /*
   *
   * Crawl the symbol chain.
   *
   * For each symbol whose value depends on a frag, take the address of
   * that frag and subsume it into the value of the symbol.
   * After this, there is just one way to lookup a symbol value.
   * Values are left in their final state for object file emission.
   * We adjust the values of 'L' local symbols, even if we do
   * not intend to emit them to the object file, because their values
   * are needed for fix-ups.
   *
   * Unless we saw a -L flag, remove all symbols that begin with 'L'
   * from the symbol chain.  (They are still pointed to by the fixes.)
   *
   * Count the remaining symbols.
   * Assign a symbol number to each symbol.
   * Count the number of string-table chars we will emit.
   * Put this info into the headers as appropriate.
   *
   */
d1579 4
a1582 6
  /*
   * Addresses of frags now reflect addresses we use in the object file.
   * Symbol values are correct.
   * Scan the frags, converting any ".org"s and ".align"s to ".fill"s.
   * Also converting any machine-dependent frags using md_convert_frag();
   */
d1607 1
a1607 1
#endif /* ! BFD_ASSEMBLER */
d1628 2
a1629 2
		       lie->word_goes_here - lie->frag->fr_literal,
		       2, &exp);
d1649 3
a1651 3
#endif /* TC_NS32K */
#endif /* TC_SPARC|TC_A29K|NEED_FX_R_TYPE */
#endif /* BFD_ASSEMBLER */
d1670 3
a1672 1
	for (untruth = lie; untruth && untruth->dispfrag == fragP; untruth = untruth->next_broken_word)
d1677 2
a1678 1
	table_addr = lie->dispfrag->fr_address + (table_ptr - lie->dispfrag->fr_literal);
d1683 2
a1684 1
	md_create_short_jump (table_ptr, from_addr, to_addr, lie->dispfrag, lie->add);
d1688 3
a1690 1
	for (m = 0; lie && lie->dispfrag == fragP; m++, lie = lie->next_broken_word)
d1694 2
a1695 2
	    /* Patch the jump table */
	    /* This is the offset from ??? to table_ptr+0 */
d1700 3
d1704 3
a1706 1
	    for (untruth = lie->next_broken_word; untruth && untruth->dispfrag == fragP; untruth = untruth->next_broken_word)
d1712 2
a1713 2
	    /* Install the long jump */
	    /* this is a long jump from table_ptr+0 to the final target */
d1719 2
a1720 1
	    md_create_long_jump (table_ptr, from_addr, to_addr, lie->dispfrag, lie->add);
d1726 1
a1726 1
#endif /* not WORKING_DOT_WORD */
d1730 1
a1730 1
  {				/* not vms */
d1733 2
a1734 4
    /*
     * Scan every FixS performing fixups. We had to wait until now to do
     * this because md_convert_frag() may have made some fixSs.
     */
d1743 1
a1743 1
    /* FIXME move this stuff into the pre-write-hook */
d1747 1
a1747 1
    obj_pre_write_hook (&headers);	/* extra coff stuff */
d1756 2
a1757 1
    know ((next_object_file_charP - the_object_file) == H_GET_HEADER_SIZE (&headers));
d1759 1
a1759 3
    /*
     * Emit code.
     */
d1768 2
a1769 1
	append (&next_object_file_charP, fragP->fr_literal, (unsigned long) fragP->fr_fix);
d1775 3
a1777 5
	  {
	    append (&next_object_file_charP, fill_literal, (unsigned long) fill_size);
	  }			/* for each  */

      }				/* for each code frag. */
d1779 13
a1791 7
    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers)));

    /*
     * Emit relocations.
     */
    obj_emit_relocations (&next_object_file_charP, text_fix_root, (relax_addressT) 0);
    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers) + H_GET_TEXT_RELOCATION_SIZE (&headers)));
d1794 17
a1810 13
     * first data fragment, not end of last text fragment:  alignment of the
     * start of the data segment may place a gap between the segments.
     */
    obj_emit_relocations (&next_object_file_charP, data_fix_root, data0_frchainP->frch_root->fr_address);
#else /* TC_I960 */
    obj_emit_relocations (&next_object_file_charP, data_fix_root, text_last_frag->fr_address);
#endif /* TC_I960 */

    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers) + H_GET_TEXT_RELOCATION_SIZE (&headers) + H_GET_DATA_RELOCATION_SIZE (&headers)));

    /*
     * Emit line number entries.
     */
d1812 7
a1818 1
    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers) + H_GET_TEXT_RELOCATION_SIZE (&headers) + H_GET_DATA_RELOCATION_SIZE (&headers) + H_GET_LINENO_SIZE (&headers)));
d1820 1
a1820 3
    /*
     * Emit symbols.
     */
d1822 8
a1829 5
    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers) + H_GET_TEXT_RELOCATION_SIZE (&headers) + H_GET_DATA_RELOCATION_SIZE (&headers) + H_GET_LINENO_SIZE (&headers) + H_GET_SYMBOL_TABLE_SIZE (&headers)));

    /*
     * Emit strings.
     */
d1831 1
d1833 1
a1833 3
      {
	obj_emit_strings (&next_object_file_charP);
      }				/* only if we have a string table */
d1840 1
a1840 1
    /* Write the data to the file */
d1844 3
a1846 5
  }				/* non vms output */
#else /* OBJ_VMS */
  /*
   *	Now do the VMS-dependent part of writing the object file
   */
d1851 2
a1852 2
#endif /* OBJ_VMS */
#else /* BFD_ASSEMBLER */
d1874 1
a1874 1
  bfd_map_over_sections (stdoutput, adjust_reloc_syms, (char *)0);
d1898 2
a1899 1
	      const char *name2 = decode_local_label_name ((char *)S_GET_NAME (symp));
d1956 1
a1959 1

d2013 1
a2013 1
#endif /* BFD_ASSEMBLER */
d2015 1
a2015 14
#endif /* ! BFD */

/*
 *			relax_segment()
 *
 * Now we have a segment, not a crowd of sub-segments, we can make fr_address
 * values.
 *
 * Relax the frags.
 *
 * After this, all frags in this segment have addresses that are correct
 * within the segment. Since segments live in different file addresses,
 * these frag addresses may not be the same as final object-file addresses.
 */
a2018 14
static int is_dnrange PARAMS ((fragS *, fragS *));

/* Subroutines of relax_segment.  */
static int
is_dnrange (f1, f2)
     fragS *f1;
     fragS *f2;
{
  for (; f1; f1 = f1->fr_next)
    if (f1->fr_next == f2)
      return 1;
  return 0;
}

d2022 2
a2023 1
relax_frag (fragP, stretch)
d2031 10
a2040 8
  long aim, target, growth;
  symbolS *symbolP = fragP->fr_symbol;
  long offset = fragP->fr_offset;
  /* Recompute was_address by undoing "+= stretch" done by relax_segment.  */
  unsigned long was_address = fragP->fr_address - stretch;
  unsigned long address = fragP->fr_address;
  const relax_typeS *table = TC_GENERIC_RELAX_TABLE;

d2043 1
a2043 1
  target = offset;
d2047 4
d2058 1
a2058 1
      know (symbolP->sy_frag);
d2061 2
a2062 2
	    || symbolP->sy_frag == &zero_address_frag);
      target +=	S_GET_VALUE (symbolP) + symbol_get_frag (symbolP)->fr_address;
d2067 1
a2067 3
	 between grows, and that will force another pass.

	 Beware zero-length frags.
d2069 3
a2071 4
	 There should be a faster way to do this.  */

      if (symbol_get_frag (symbolP)->fr_address >= was_address
	  && is_dnrange (fragP, symbol_get_frag (symbolP)))
d2079 3
a2081 3
  /* Currently only the ns32k family needs this */
  aim += TC_PCREL_ADJUST(fragP);
/*#else*/
d2084 2
a2085 1
/*  assert (fragP->fr_targ.ns32k.pcrel_adjust == 0);*/
d2087 2
a2088 1
#ifdef md_prepare_relax_scan /* formerly called M68K_AIM_KLUDGE */
d2094 1
a2094 1
      /* Look backwards. */
d2100 1
a2100 1
	    /* Grow to next state. */
d2108 1
a2108 1
      /* Look forwards. */
d2114 1
a2114 1
	    /* Grow to next state. */
d2127 1
a2127 1
#endif /* defined (TC_GENERIC_RELAX_TABLE) */
d2133 2
a2134 2
     register relax_addressT address;	/* Address now. */
     register int alignment;	/* Alignment (binary). */
d2150 10
d2170 1
a2170 1
  /* In case md_estimate_size_before_relax() wants to make fixSs. */
d2178 1
d2190 1
d2218 1
a2218 1
	  /* Broken words don't concern us yet */
d2224 1
a2224 1
	  /* Initial guess is always 1; doing otherwise can result in 
d2233 4
d2240 2
a2241 2
	}			/* switch(fr_type) */
    }				/* for each frag in the segment */
d2245 4
a2248 5
    long stretch;	/* May be any size, 0 or negative. */
    /* Cumulative number of addresses we have */
    /* relaxed this pass. */
    /* We may have relaxed more than one address. */
    long stretched;	/* Have we stretched on this pass? */
d2255 3
a2257 1
	stretch = stretched = 0;
d2265 1
d2273 1
a2273 1
	      case rs_fill:	/* .fill never relaxes. */
d2338 1
a2338 1
		}		/* case rs_broken_word */
d2342 1
d2365 2
a2366 2
		  long target = offset;
		  long after;
d2381 1
a2381 1
		    }		/* if we have a symbol */
d2390 1
a2390 1
			 .org backwards. */
d2403 2
a2404 1
		  growth -= stretch;	/* This is an absolute growth factor */
d2430 1
a2430 1
		growth = md_relax_frag (fragP, stretch);
d2435 2
a2436 2
		growth = relax_frag (fragP, stretch);
#endif /* TC_GENERIC_RELAX_TABLE */
d2456 4
d2467 1
a2467 1
		stretched++;
d2469 1
a2469 1
	  }			/* For each frag in the segment. */
d2471 2
a2472 2
    while (stretched);		/* Until nothing further to relax. */
  }				/* do_relax */
d2474 5
a2478 9
  /*
   * We now have valid fr_address'es for each frag.
   */

  /*
   * All fr_address's are correct, relative to their own segment.
   * We have made all the fixS we will ever make.
   */
}				/* relax_segment() */
d2500 1
a2500 1
     segT this_segment_type;	/* N_TYPE bits for segment. */
d2520 1
a2520 1
  if (linkrelax)
a2529 1

a2534 1

d2574 1
a2574 1
	      /* It's just -sym */
d2597 1
a2597 1
		 something different for N_UNDF. */
d2604 1
a2604 1
#endif /* TC_I960 */
d2609 1
a2609 1
	      pcrel = 0;	/* No further pcrel processing. */
d2623 1
a2623 1
	      /* Different segments in subtraction. */
d2632 5
a2636 3
#if 0 /* Do this even if it's already described as pc-relative.  For example,
	 on the m68k, an operand of "pc@@(foo-.-2)" should address "foo" in a
	 pc-relative mode.  */
d2686 3
a2688 5
	      /*
	       * This fixup was made when the symbol's segment was
	       * SEG_UNKNOWN, but it is now in the local segment.
	       * So we know how to do the address without relocation.
	       */
d2694 1
a2694 1
		 below a no-op. */
d2696 1
a2696 1
#endif /* TC_I960 */
d2700 2
a2701 1
	      pcrel = 0;	/* Lie. Don't want further pcrel processing. */
d2720 1
a2720 1
#endif /* TC_I960 */
d2743 3
a2745 4
		       * 13-bit displacement and are only to be used
		       * for local branches: flag as error, don't generate
		       * relocation.
		       */
d2751 2
a2752 2
		    }		/* COBR */
#endif /* TC_I960 */
d2758 2
a2759 2
#endif /* TE_I386AIX */
#endif /* OBJ_COFF */
d2765 2
a2766 11
#if !(defined (TC_V850) && defined (OBJ_ELF))
#if !(defined (TC_M68K) && defined (OBJ_ELF))
#if !(defined (TC_ARM)  && defined (OBJ_ELF))
#if !(defined (TC_I960) && defined (OBJ_ELF))
#if !defined (TC_I386) || !(defined (OBJ_ELF) || defined (OBJ_COFF)) || defined (TE_PE)
		  add_number += S_GET_VALUE (add_symbolP);
#endif
#endif
#endif
#endif
#endif
d2814 1
a2814 1
	      mask--;		/* set all bits to one */
d2827 1
a2827 1
		} /* generic error checking */
d2841 1
a2841 1
	}			/* not a bit fix */
d2851 1
a2851 1
    }				/* For each fixS in this segment. */
d2896 1
a2896 1
/* for debugging */
a2948 2

/* end of write.c */
@


1.4
log
@Merge to Cygnus 961112 + add some support (not ready) for shared libs
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 1996
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d115 20
d169 1
a169 1
      as_bad ("field fx_size too small to hold %d", size);
d186 7
a287 1
	extern symbolS *make_expr_symbol ();
d306 1
a306 1
      as_fatal("rva not supported");
d371 1
a371 1
  if (align > bfd_get_section_alignment (stdoutput, seg))
d385 1
a385 1
     bfd *abfd;
d436 1
a436 1
     bfd *abfd;			/* unused */
d438 1
a438 1
     PTR xxx;			/* unused */
d458 1
a458 1
void
d501 3
a503 2
	  as_bad ("attempt to .org/.space backwards? (%ld)",
		  (long) fragP->fr_offset);
d511 20
d538 3
a540 1
      assert (fragP->fr_next == NULL || (fragP->fr_next->fr_address - fragP->fr_address == fragP->fr_fix));
d582 1
a582 1
     PTR xxx;
d648 1
a648 1
     bfd *abfd;
d663 6
a668 1
      if (s)
d670 2
a671 11
	  fprintf (stream, "  %08x: %s(%s", fixp, S_GET_NAME (s),
		   s->bsym->section->name);
	  if (s->bsym->flags & BSF_SECTION_SYM)
	    {
	      fprintf (stream, " section sym");
	      if (S_GET_VALUE (s))
		fprintf (stream, "+%x", S_GET_VALUE (s));
	    }
	  else
	    fprintf (stream, "+%x", S_GET_VALUE (s));
	  fprintf (stream, ")+%x\n", fixp->fx_offset);
a672 2
      else
	fprintf (stream, "  %08x: type %d no sym\n", fixp, fixp->fx_r_type);
d686 1
a686 1
     bfd *abfd;
d688 1
a688 1
     PTR xxx;
a705 2
      reduce_fixup:

a711 1
	symsec = sym->bsym->section;
d713 21
a733 1
	if (sym != NULL && sym->sy_mri_common)
d739 5
d750 1
a750 1
		fixp->fx_addsy->sy_used_in_reloc = 1;
d753 1
a753 1
		  fixp->fx_subsy->sy_used_in_reloc = 1;
d767 1
a767 1
	    fixp->fx_addsy->sy_used_in_reloc = 1;
d773 1
a773 1
	      fixp->fx_subsy->sy_used_in_reloc = 1;
d778 34
d814 12
a825 1
	if (sym->bsym->flags & BSF_SECTION_SYM)
d827 1
a827 1
	    fixp->fx_addsy->sy_used_in_reloc = 1;
d830 1
d837 1
a837 1
	    fixp->fx_addsy->sy_used_in_reloc = 1;
d848 1
a848 1
	    fixp->fx_addsy->sy_used_in_reloc = 1;
a852 21
	/* For PIC support: We may get expressions like
	   "_GLOBAL_OFFSET_TABLE_+(.-L5)" where "." and "L5" may not
	   necessarily have had a fixed difference initially.  But now
	   it should be a known constant, so we can reduce it.  Since
	   we can't easily handle a symbol value that looks like
	   someUndefinedSymbol+const, though, we convert the fixup to
	   access the undefined symbol directly, and discard the
	   intermediate symbol.  */
	if (S_GET_SEGMENT (sym) == expr_section
	    && sym->sy_value.X_op == O_add
	    && (resolve_symbol_value (sym->sy_value.X_add_symbol),
		S_GET_SEGMENT (sym->sy_value.X_add_symbol) == undefined_section)
	    && (resolve_symbol_value (sym->sy_value.X_op_symbol),
		S_GET_SEGMENT (sym->sy_value.X_op_symbol) == absolute_section))
	  {
	    fixp->fx_offset += S_GET_VALUE (sym->sy_value.X_op_symbol);
	    fixp->fx_offset += sym->sy_value.X_add_number;
	    fixp->fx_addsy = sym->sy_value.X_add_symbol;
	    goto reduce_fixup;
	  }

d862 5
a866 1
	fixp->fx_addsy->sy_used_in_reloc = 1;
d891 1
a891 1
     PTR xxx;
d913 1
a913 2
  relocs = (arelent **) bfd_alloc_by_size_t (stdoutput,
					     n * sizeof (arelent *));
d933 1
a933 1
      while (sym->sy_value.X_op == O_symbol
d935 11
a945 1
	sym = sym->sy_value.X_add_symbol;
d971 4
a974 1
	  as_bad_where (fixp->fx_file, fixp->fx_line, "relocation overflow");
d977 2
a978 2
	  as_fatal ("%s:%u: bad return from bfd_perform_relocation",
		    fixp->fx_file, fixp->fx_line);
d985 1
a985 2
  relocs = (arelent **) bfd_alloc_by_size_t (stdoutput,
					     n * sizeof (arelent *));
d1006 1
a1006 1
      while (sym->sy_value.X_op == O_symbol
d1008 1
a1008 1
	sym = sym->sy_value.X_add_symbol;
d1021 2
a1022 1
	abort ();
d1035 1
a1035 1
			    "relocation overflow");
d1038 1
a1038 1
	      as_fatal ("%s:%u: bad return from bfd_perform_relocation",
d1071 4
d1094 1
a1094 1
     bfd *abfd;
d1096 1
a1096 1
     PTR xxx;
d1125 1
a1125 1
	      as_perror ("FATAL: Can't write %s", stdoutput->filename);
d1149 1
a1149 1
		      as_perror ("FATAL: Can't write %s", stdoutput->filename);
d1180 1
a1180 1
		    as_fatal ("Cannot write to output file.");
d1339 2
a1340 2
	  asympp[i] = symp->bsym;
	  symp->written = 1;
d1351 44
a1397 1
  struct frchain *frchainP;	/* Track along all frchains. */
d1412 1
a1412 1
	  as_warn ("%d error%s, %d warning%s, generating bad object file.\n",
d1419 1
a1419 1
	  as_fatal ("%d error%s, %d warning%s, no object file generated.\n",
a1431 28
  /* After every sub-segment, we fake an ".align ...". This conforms to
     BSD4.2 brane-damage. We then fake ".fill 0" because that is the kind of
     frag that requires least thought. ".align" frags like to have a
     following frag since that makes calculating their intended length
     trivial.

     @@@@ Is this really necessary??  */
#ifndef SUB_SEGMENT_ALIGN
#ifdef BFD_ASSEMBLER
#define SUB_SEGMENT_ALIGN(SEG) (0)
#else
#define SUB_SEGMENT_ALIGN(SEG) (2)
#endif
#endif
  for (frchainP = frchain_root; frchainP; frchainP = frchainP->frch_next)
    {
      subseg_set (frchainP->frch_seg, frchainP->frch_subseg);
      frag_align (SUB_SEGMENT_ALIGN (now_seg), NOP_OPCODE);
      /* frag_align will have left a new frag.
	 Use this last frag for an empty ".fill".

	 For this segment ...
	 Create a last frag. Do not leave a "being filled in frag".  */
      frag_wane (frag_now);
      frag_now->fr_fix = 0;
      know (frag_now->fr_next == NULL);
    }

d1525 7
d1558 1
d1603 1
d1630 1
a1630 1
	    to_addr -= lie->sub->sy_frag->fr_address;
d1644 1
a1644 1
	    to_addr += lie->add->sy_frag->fr_address;
d1777 1
a1777 2
	if (!symp->sy_resolved)
	  resolve_symbol_value (symp);
d1779 1
d1802 1
a1802 1
	  if (symp->sy_mri_common)
d1805 1
a1805 1
		as_bad ("%s: global symbols not supported in common sections",
d1818 1
a1818 1
		as_bad ("local label %s is not defined", name2);
d1824 1
a1824 13
	  if (! symp->sy_resolved)
	    {
	      if (symp->sy_value.X_op == O_constant)
		{
		  /* This is the normal case; skip the call.  */
		  S_SET_VALUE (symp,
			       (S_GET_VALUE (symp)
				+ symp->sy_frag->fr_address));
		  symp->sy_resolved = 1;
		}
	      else
		resolve_symbol_value (symp);
	    }
d1828 1
a1828 1
	  if (symp->sy_value.X_op == O_symbol
d1844 2
a1845 2
		  symp->bsym->flags,
		  segment_name (symp->bsym->section));
d1852 1
a1852 1
	  if (! punt || symp->sy_used_in_reloc)
d1862 1
a1862 1
	       && (symp->bsym->flags & BSF_SECTION_SYM) != 0)
d1868 1
a1868 1
		  && ! symp->sy_used_in_reloc))
d1879 1
a1879 1
	  if (! symp->sy_resolved)
d1881 1
a1881 1
	      as_bad ("can't resolve value for symbol \"%s\"",
d1883 1
a1883 1
	      symp->sy_resolved = 1;
d1888 1
a1888 1
	  symp->bsym->value = S_GET_VALUE (symp);
a1944 1
#ifndef md_relax_frag
d1947 2
d1952 2
a1953 2
     struct frag *f1;
     struct frag *f2;
d1961 102
a2063 1
#endif /* ! defined (md_relax_frag) */
d2116 5
a2120 1
	    int offset = relax_align (address, (int) fragP->fr_offset);
d2123 2
a2124 2
		as_bad ("alignment padding (%d bytes) not a multiple of %ld",
			offset, (long) fragP->fr_var);
d2127 1
d2147 10
d2180 2
a2181 2
	    unsigned long was_address;
	    long offset;
a2182 2
	    long target;
	    long after;
d2218 1
a2218 1
		      offset = (lie->add->sy_frag->fr_address
d2221 1
a2221 1
				- (lie->sub->sy_frag->fr_address
d2229 1
a2229 1
			      as_warn (".word %s-%s+%s didn't fit",
d2243 4
a2246 2
			    if ((untruth->add->sy_frag == lie->add->sy_frag)
				&& S_GET_VALUE (untruth->add) == S_GET_VALUE (lie->add))
d2260 18
a2277 6
		growth = (relax_align ((relax_addressT) (address
							 + fragP->fr_fix),
				       (int) offset)
			  - relax_align ((relax_addressT) (was_address
							   + fragP->fr_fix),
					 (int) offset));
d2281 3
a2283 1
		target = offset;
d2285 2
a2286 2
		if (symbolP)
		  {
d2288 31
a2318 23
		    know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
			  || (S_GET_SEGMENT (symbolP) == SEG_DATA)
			  || (S_GET_SEGMENT (symbolP) == SEG_TEXT)
			  || S_GET_SEGMENT (symbolP) == SEG_BSS);
		    know (symbolP->sy_frag);
		    know (!(S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
			  || (symbolP->sy_frag == &zero_address_frag));
#endif
		    target += S_GET_VALUE (symbolP)
		      + symbolP->sy_frag->fr_address;
		  }		/* if we have a symbol */

		know (fragP->fr_next);
		after = fragP->fr_next->fr_address;
		growth = target - after;
		if (growth < 0)
		  {
		    /* Growth may be negative, but variable part of frag
		       cannot have fewer than 0 chars.  That is, we can't
		       .org backwards. */
		    as_bad ("attempt to .org backwards ignored");
		    growth = 0;
		  }
d2320 3
a2322 2
		growth -= stretch;	/* This is an absolute growth factor */
		break;
d2328 5
a2332 2
		    if (symbolP->sy_frag != &zero_address_frag)
		      as_bad (".space specifies non-absolute value");
d2336 1
a2336 1
			as_warn (".space or .fill with negative value, ignored");
d2350 3
a2352 21
		   md_relax_table.  */
		{
		  const relax_typeS *this_type;
		  const relax_typeS *start_type;
		  relax_substateT next_state;
		  relax_substateT this_state;
		  long aim;
		  const relax_typeS *table = TC_GENERIC_RELAX_TABLE;

		  this_state = fragP->fr_subtype;
		  start_type = this_type = table + this_state;
		  target = offset;

		  if (symbolP)
		    {
#ifndef DIFF_EXPR_OK
#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
		      know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
			    || (S_GET_SEGMENT (symbolP) == SEG_DATA)
			    || (S_GET_SEGMENT (symbolP) == SEG_BSS)
			    || (S_GET_SEGMENT (symbolP) == SEG_TEXT));
d2354 1
a2354 12
		      know (symbolP->sy_frag);
#endif
		      know (!(S_GET_SEGMENT (symbolP) == absolute_section)
			    || symbolP->sy_frag == &zero_address_frag);
		      target +=
			S_GET_VALUE (symbolP)
			+ symbolP->sy_frag->fr_address;

		      /* If frag has yet to be reached on this pass,
			 assume it will move by STRETCH just as we did.
			 If this is not so, it will be because some frag
			 between grows, and that will force another pass.
d2356 4
a2359 1
			 Beware zero-length frags.
d2361 6
a2366 8
			 There should be a faster way to do this.  */

		      if (symbolP->sy_frag->fr_address >= was_address
			  && is_dnrange (fragP, symbolP->sy_frag))
			{
			  target += stretch;
			}
		    }
d2368 2
a2369 48
		  aim = target - address - fragP->fr_fix;
#ifdef TC_PCREL_ADJUST
		  /* Currently only the ns32k family needs this */
		  aim += TC_PCREL_ADJUST(fragP);
#else
		  /* This machine doesn't want to use pcrel_adjust.
		     In that case, pcrel_adjust should be zero.  */
		  assert (fragP->fr_pcrel_adjust == 0);
#endif

		  if (aim < 0)
		    {
		      /* Look backwards. */
		      for (next_state = this_type->rlx_more; next_state;)
			if (aim >= this_type->rlx_backward)
			  next_state = 0;
			else
			  {
			    /* Grow to next state. */
			    this_state = next_state;
			    this_type = table + this_state;
			    next_state = this_type->rlx_more;
			  }
		    }
		  else
		    {
#ifdef M68K_AIM_KLUDGE
		      M68K_AIM_KLUDGE (aim, this_state, this_type);
#endif
		      /* Look forwards. */
		      for (next_state = this_type->rlx_more; next_state;)
			if (aim <= this_type->rlx_forward)
			  next_state = 0;
			else
			  {
			    /* Grow to next state. */
			    this_state = next_state;
			    this_type = table + this_state;
			    next_state = this_type->rlx_more;
			  }
		    }

		  growth = this_type->rlx_length - start_type->rlx_length;
		  if (growth != 0)
		    fragP->fr_subtype = this_state;
		}
#endif /* TC_GENERIC_RELAX_TABLE */
#endif
d2446 1
d2452 1
d2468 1
a2468 1
	  && add_symbolP->sy_mri_common)
d2473 2
a2474 1
	  add_symbolP = fixP->fx_addsy = add_symbolP->sy_value.X_add_symbol;
d2482 1
a2482 1
	  resolve_symbol_value (sub_symbolP);
d2507 1
a2507 1
			      "Negative of non-absolute symbol %s",
d2521 1
a2521 1
			      "callj to difference of 2 symbols");
d2587 4
a2590 1
				"Can't emit reloc {- %s-seg symbol \"%s\"} @@ file address %s.",
d2592 1
a2592 1
				S_GET_NAME (sub_symbolP), buf);
d2631 2
a2632 1
	      if (add_symbol_segment == absolute_section)
d2665 1
a2665 1
				    "can't use COBR format with external label");
d2683 1
d2685 3
a2687 1
#if !defined (TC_I386) || !(defined (OBJ_ELF) || defined (OBJ_COFF))
d2691 3
d2708 1
a2708 1
	      fixP->fx_addsy->sy_used_in_reloc = 1;
d2713 21
d2736 1
a2736 2
	  valueT mask = 0;
	  if (size < sizeof (mask))
d2738 6
a2743 11
	      /* set all bits to one */
	      mask--;
	      /* Technically, combining these produces an undefined result
		 if size is sizeof (valueT), though I think these two
		 half-way operations should both be defined.  And the
		 compiler should be able to combine them if it's valid on
		 the host architecture.  */
	      mask <<= size * 4;
	      mask <<= size * 4;
	      if ((add_number & mask) != 0
		  && (add_number & mask) != mask)
d2752 1
a2752 1
				"Value of %s too large for field of %d bytes at %s",
d2764 1
a2764 1
			  "Signed .word overflow; switch may be too large; %ld at 0x%lx",
a2769 20
      if (!fixP->fx_done)
	{
#ifdef MD_APPLY_FIX3
	  md_apply_fix3 (fixP, &add_number, this_segment_type);
#else
#ifdef BFD_ASSEMBLER
	  md_apply_fix (fixP, &add_number);
#else
	  md_apply_fix (fixP, add_number);
#endif
#endif

#ifndef TC_HANDLES_FX_DONE
	  /* If the tc-* files haven't been converted, assume it's handling
	     it the old way, where a null fx_addsy means that the fix has
	     been applied completely, and no further work is needed.  */
	  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
	    fixP->fx_done = 1;
#endif
	}
d2771 2
a2772 1
    skip: ;
d2792 1
a2792 1
  if (n > sizeof (val)|| n <= 0)
d2807 1
a2807 1
  if (n > sizeof (val) || n <= 0)
d2820 1
a2820 1
  fprintf (stderr, "fixups: %d\n", n_fixups);
a2824 1
extern void print_symbol_value_1 ();
d2872 3
@


1.3
log
@Merge the Cygnus 960904 sources
@
text
@d298 1
a298 1
      
d300 2
a301 1
      as_bad ("expression too complex for fixup");
d323 1
a323 1
#ifndef BFD_ASSEMBLER 
d333 1
a333 1
void 
d431 1
a431 1
void 
d731 1
a731 1
	   this one?  (E.g. relocations involving function addresses on 
d1240 1
a1240 1
void 
d1797 7
d1826 1
a1826 1
static int 
d1861 1
a1861 1
void 
d2236 1
a2236 1
  
d2284 1
a2284 1
      
d2421 1
a2421 1
	      
d2444 1
a2444 1
		  
d2472 1
a2472 1
		  
@


1.2
log
@Bring Cygnus versions into the trunk, keeping our local patches
@
text
@d632 1
a632 1
#define dump_section_relocs(ABFD,SEC,STREAM)	(void)(ABFD,SEC,STREAM)
d677 15
a697 1
	    || bfd_is_abs_section (symsec)
d763 5
a767 1
	   when we run into that case.  */
d769 1
a769 1
	fixp->fx_addsy = section_symbol (symsec);
d849 3
d855 1
d1436 1
a1436 1
		       2, &exp, 0, BFD_RELOC_NONE);
d1647 7
d1815 1
d1829 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 1995
d97 2
d138 2
d275 2
a276 1
#elif defined(TC_RVA_RELOC)
d281 1
d808 1
d815 10
d864 1
d872 10
d1673 9
d2445 1
d2449 1
d2574 7
@


1.1.1.1
log
@Initial GNU binutils 2.6 import
@
text
@@


1.1.1.2
log
@Import of binutils, gas, ld & gprof from Cygnus 960609 tree
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 1996
a96 2
static int n_fixups;

a135 2
  n_fixups++;

d271 1
a271 2
#else
#if defined(TC_RVA_RELOC)
a275 1
#endif
a801 1
      symbolS *sym;
a807 10

      /* If this is an undefined symbol which was equated to another
         symbol, then use generate the reloc against the latter symbol
         rather than the former.  */
      sym = fixp->fx_addsy;
      while (sym->sy_value.X_op == O_symbol
	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
	sym = sym->sy_value.X_add_symbol;
      fixp->fx_addsy = sym;

a846 1
      symbolS *sym;
a853 10

      /* If this is an undefined symbol which was equated to another
         symbol, then use generate the reloc against the latter symbol
         rather than the former.  */
      sym = fixp->fx_addsy;
      while (sym->sy_value.X_op == O_symbol
	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
	sym = sym->sy_value.X_add_symbol;
      fixp->fx_addsy = sym;

a1644 9
	  /* Skip symbols which were equated to undefined or common
             symbols.  */
	  if (symp->sy_value.X_op == O_symbol
	      && (! S_IS_DEFINED (symp) || S_IS_COMMON (symp)))
	    {
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	      continue;
	    }

a2407 1
#if !(defined (TC_M68K) && defined (OBJ_ELF))
a2410 1
#endif
a2534 7
}

void
write_print_statistics (file)
     FILE *file;
{
  fprintf (stderr, "fixups: %d\n", n_fixups);
@


1.1.1.3
log
@Import of binutils, gas, ld & gprof from Cygnus 960904 tree
@
text
@d632 1
a632 1
#define dump_section_relocs(ABFD,SEC,STREAM)	((void) 0)
a676 15
	if (bfd_is_abs_section (symsec))
	  {
	    /* The fixup_segment routine will not use this symbol in a
               relocation unless TC_FORCE_RELOCATION returns 1.  */
	    if (TC_FORCE_RELOCATION (fixp))
	      {
		fixp->fx_addsy->sy_used_in_reloc = 1;
#ifdef UNDEFINED_DIFFERENCE_OK
		if (fixp->fx_subsy != NULL)
		  fixp->fx_subsy->sy_used_in_reloc = 1;
#endif
	      }
	    goto done;
	  }

d683 1
d749 1
a749 5
	   when we run into that case.

	   We refetch the segment when calling section_symbol, rather
	   than using symsec, because S_GET_VALUE may wind up changing
	   the section when it calls resolve_symbol_value. */
d751 1
a751 1
	fixp->fx_addsy = section_symbol (S_GET_SEGMENT (sym));
a830 3

#if 0
      /* This test is triggered inappropriately for the SH.  */
a833 1
#endif
d1414 1
a1414 1
		       2, &exp, 0, BFD_RELOC_16);
a1624 7
#ifdef tc_frob_file_before_adjust
  tc_frob_file_before_adjust ();
#endif
#ifdef obj_frob_file_before_adjust
  obj_frob_file_before_adjust ();
#endif

a1785 1
#ifdef TC_GENERIC_RELAX_TABLE
a1798 1
#endif /* defined (TC_GENERIC_RELAX_TABLE) */
@


1.1.1.4
log
@Import of 961112 Cygnus binutils+gas+ld+gdb+gprof
@
text
@d298 1
a298 1

d300 1
a300 2
      add = make_expr_symbol (exp);
      break;
d322 1
a322 1
#ifndef BFD_ASSEMBLER
d332 1
a332 1
void
d430 1
a430 1
void
d730 1
a730 1
	   this one?  (E.g. relocations involving function addresses on
d1239 1
a1239 1
void
a1795 7
#ifdef tc_frob_file_after_relocs
  tc_frob_file_after_relocs ();
#endif
#ifdef obj_frob_file_after_relocs
  obj_frob_file_after_relocs ();
#endif

d1818 1
a1818 1
static int
d1853 1
a1853 1
void
d2228 1
a2228 1

d2276 1
a2276 1

d2413 1
a2413 1

d2436 1
a2436 1

d2464 1
a2464 1

@


1.1.1.5
log
@Import of binutils-2.8.1 from Cygnus/FSF
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 1997
d18 2
a19 3
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
a113 20
#if defined (BFD_ASSEMBLER) || ! defined (BFD)
static fragS *chain_frchains_together_1 PARAMS ((segT, struct frchain *));
#endif
#ifdef BFD_ASSEMBLER
static void chain_frchains_together PARAMS ((bfd *, segT, PTR));
static void cvt_frag_to_fill PARAMS ((segT, fragS *));
static void relax_and_size_seg PARAMS ((bfd *, asection *, PTR));
static void adjust_reloc_syms PARAMS ((bfd *, asection *, PTR));
static void write_relocs PARAMS ((bfd *, asection *, PTR));
static void write_contents PARAMS ((bfd *, asection *, PTR));
static void set_symtab PARAMS ((void));
#endif
#if defined (BFD_ASSEMBLER) || (! defined (BFD) && ! defined (OBJ_AOUT))
static void merge_data_into_text PARAMS ((void));
#endif
#if ! defined (BFD_ASSEMBLER) && ! defined (BFD)
static void cvt_frag_to_fill PARAMS ((object_headers *, segT, fragS *));
static void remove_subsegs PARAMS ((frchainS *, int, fragS **, fragS **));
static void relax_and_size_all_segments PARAMS ((void));
#endif
a164 2
  fixP->fx_no_overflow = 0;
  fixP->fx_signed = 0;
d260 1
d431 1
a431 1
static void
d670 1
a670 21

	/* All symbols should have already been resolved at this
	   point.  It is possible to see unresolved expression
	   symbols, though, since they are not in the regular symbol
	   table.  */
	if (sym != NULL && ! sym->sy_resolved)
	  resolve_symbol_value (sym);
	if (fixp->fx_subsy != NULL && ! fixp->fx_subsy->sy_resolved)
	  resolve_symbol_value (fixp->fx_subsy);

	/* If this symbol is equated to an undefined symbol, convert
           the fixup to being against that symbol.  */
	if (sym->sy_value.X_op == O_symbol
	    && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
	  {
	    fixp->fx_offset += sym->sy_value.X_add_number;
	    sym = sym->sy_value.X_add_symbol;
	    fixp->fx_addsy = sym;
	  }

	symsec = S_GET_SEGMENT (sym);
a711 34
	/* Don't try to reduce relocs which refer to .linkonce
           sections.  It can lead to confusion when a debugging
           section refers to a .linkonce section.  I hope this will
           always be correct.  */
	if (symsec != sec)
	  {
	    boolean linkonce;

	    linkonce = false;
#ifdef BFD_ASSEMBLER
	    if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE)
		!= 0)
	      linkonce = true;
#endif
#ifdef OBJ_ELF
	    /* The GNU toolchain uses an extension for ELF: a section
               beginning with the magic string .gnu.linkonce is a
               linkonce section.  */
	    if (strncmp (segment_name (symsec), ".gnu.linkonce",
			 sizeof ".gnu.linkonce" - 1) == 0)
	      linkonce = true;
#endif

	    if (linkonce)
	      {
		fixp->fx_addsy->sy_used_in_reloc = 1;
#ifdef UNDEFINED_DIFFERENCE_OK
		if (fixp->fx_subsy != NULL)
		  fixp->fx_subsy->sy_used_in_reloc = 1;
#endif
		goto done;
	      }
	  }

d741 21
d818 2
a819 1
  relocs = (arelent **) xmalloc (n * sizeof (arelent *));
d841 1
a841 11
	{
	  symbolS *n;

	  /* We must avoid looping, as that can occur with a badly
	     written program.  */
	  n = sym->sy_value.X_add_symbol;
	  if (n == sym)
	    break;
	  fixp->fx_offset += sym->sy_value.X_add_number;
	  sym = n;
	}
d870 1
a870 1
	  as_fatal ("%s:%u: bad return from bfd_install_relocation",
d878 2
a879 1
  relocs = (arelent **) xmalloc (n * sizeof (arelent *));
d915 1
a915 2
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      "internal error: fixup not contained within frag");
d931 1
a931 1
	      as_fatal ("%s:%u: bad return from bfd_install_relocation",
d1295 1
a1295 1
      frag_align (SUB_SEGMENT_ALIGN (now_seg), NOP_OPCODE, 0);
d1822 1
a1824 2
static int is_dnrange PARAMS ((fragS *, fragS *));

d1828 2
a1829 2
     fragS *f1;
     fragS *f2;
a1836 104
/* Relax a fragment by scanning TC_GENERIC_RELAX_TABLE.  */

long
relax_frag (fragP, stretch)
     fragS *fragP;
     long stretch;
{
  const relax_typeS *this_type;
  const relax_typeS *start_type;
  relax_substateT next_state;
  relax_substateT this_state;
  long aim, target, growth;
  symbolS *symbolP = fragP->fr_symbol;
  long offset = fragP->fr_offset;
  /* Recompute was_address by undoing "+= stretch" done by relax_segment.  */
  unsigned long was_address = fragP->fr_address - stretch;
  unsigned long address = fragP->fr_address;
  const relax_typeS *table = TC_GENERIC_RELAX_TABLE;

  this_state = fragP->fr_subtype;
  start_type = this_type = table + this_state;
  target = offset;

  if (symbolP)
    {
#ifndef DIFF_EXPR_OK
#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
      know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
	    || (S_GET_SEGMENT (symbolP) == SEG_DATA)
	    || (S_GET_SEGMENT (symbolP) == SEG_BSS)
	    || (S_GET_SEGMENT (symbolP) == SEG_TEXT));
#endif
      know (symbolP->sy_frag);
#endif
      know (!(S_GET_SEGMENT (symbolP) == absolute_section)
	    || symbolP->sy_frag == &zero_address_frag);
      target +=
	S_GET_VALUE (symbolP)
	  + symbolP->sy_frag->fr_address;

      /* If frag has yet to be reached on this pass,
	 assume it will move by STRETCH just as we did.
	 If this is not so, it will be because some frag
	 between grows, and that will force another pass.

	 Beware zero-length frags.

	 There should be a faster way to do this.  */

      if (symbolP->sy_frag->fr_address >= was_address
	  && is_dnrange (fragP, symbolP->sy_frag))
	{
	  target += stretch;
	}
    }

  aim = target - address - fragP->fr_fix;
#ifdef TC_PCREL_ADJUST
  /* Currently only the ns32k family needs this */
  aim += TC_PCREL_ADJUST(fragP);
/*#else*/
  /* This machine doesn't want to use pcrel_adjust.
     In that case, pcrel_adjust should be zero.  */
/*  assert (fragP->fr_targ.ns32k.pcrel_adjust == 0);*/
#endif
#ifdef md_prepare_relax_scan /* formerly called M68K_AIM_KLUDGE */
  md_prepare_relax_scan (fragP, address, aim, this_state, this_type);
#endif

  if (aim < 0)
    {
      /* Look backwards. */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim >= this_type->rlx_backward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state. */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }
  else
    {
      /* Look forwards. */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim <= this_type->rlx_forward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state. */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }

  growth = this_type->rlx_length - start_type->rlx_length;
  if (growth != 0)
    fragP->fr_subtype = this_state;
  return growth;
}

d1838 1
d1891 1
a1891 5
	    addressT offset = relax_align (address, (int) fragP->fr_offset);

	    if (fragP->fr_subtype != 0 && offset > fragP->fr_subtype)
	      offset = 0;

d1894 2
a1895 2
		as_bad ("alignment padding (%lu bytes) not a multiple of %ld",
			(unsigned long) offset, (long) fragP->fr_var);
a1897 1

d1940 2
a1941 2
	    addressT was_address;
	    offsetT offset;
d1943 2
d2020 6
a2025 18
		{
		  addressT oldoff, newoff;

		  oldoff = relax_align (was_address + fragP->fr_fix,
					(int) offset);
		  newoff = relax_align (address + fragP->fr_fix,
					(int) offset);

		  if (fragP->fr_subtype != 0)
		    {
		      if (oldoff > fragP->fr_subtype)
			oldoff = 0;
		      if (newoff > fragP->fr_subtype)
			newoff = 0;
		    }

		  growth = newoff - oldoff;
		}
d2029 1
a2029 3
		{
		  long target = offset;
		  long after;
d2031 2
a2032 2
		  if (symbolP)
		    {
d2034 23
a2056 11
		      know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
			    || (S_GET_SEGMENT (symbolP) == SEG_DATA)
			    || (S_GET_SEGMENT (symbolP) == SEG_TEXT)
			    || S_GET_SEGMENT (symbolP) == SEG_BSS);
		      know (symbolP->sy_frag);
		      know (!(S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
			    || (symbolP->sy_frag == &zero_address_frag));
#endif
		      target += S_GET_VALUE (symbolP)
			+ symbolP->sy_frag->fr_address;
		    }		/* if we have a symbol */
d2058 2
a2059 15
		  know (fragP->fr_next);
		  after = fragP->fr_next->fr_address;
		  growth = target - after;
		  if (growth < 0)
		    {
		      /* Growth may be negative, but variable part of frag
			 cannot have fewer than 0 chars.  That is, we can't
			 .org backwards. */
		      as_bad ("attempt to .org backwards ignored");
		      growth = 0;
		    }

		  growth -= stretch;	/* This is an absolute growth factor */
		  break;
		}
d2065 2
a2066 5
		    if (symbolP->sy_frag != &zero_address_frag
			|| S_IS_COMMON (symbolP)
			|| ! S_IS_DEFINED (symbolP))
		      as_bad_where (fragP->fr_file, fragP->fr_line,
				    ".space specifies non-absolute value");
d2084 92
a2175 2
		   TC_GENERIC_RELAX_TABLE.  */
		growth = relax_frag (fragP, stretch);
d2433 1
a2433 2
	      if (add_symbol_segment == absolute_section
		  && ! pcrel)
d2510 2
a2511 1
	  if (size < sizeof (valueT))
a2512 2
	      valueT mask, hibit;

a2513 1
	      mask = 0;
d2522 2
a2523 6
	      hibit = (valueT) 1 << (size * 8 - 1);
	      if (((add_number & mask) != 0
		   || (fixP->fx_signed
		       && (add_number & hibit) != 0))
		  && ((add_number & mask) != mask
		      || (add_number & hibit) == 0))
d2624 1
@


1.1.1.6
log
@Import binutils-2.10
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d169 1
a169 1
      as_bad (_("field fx_size too small to hold %d"), size);
a188 5
#ifdef USING_CGEN
  fixP->fx_cgen.insn = NULL;
  fixP->fx_cgen.opinfo = 0;
#endif

d301 1
a301 1
      as_fatal(_("rva not supported"));
d366 1
a366 1
  if ((unsigned int) align > bfd_get_section_alignment (stdoutput, seg))
d380 1
a380 1
     bfd *abfd ATTRIBUTE_UNUSED;
d431 1
a431 1
     bfd *abfd ATTRIBUTE_UNUSED;
d433 1
a433 1
     PTR xxx ATTRIBUTE_UNUSED;
d496 2
a497 3
	  as_bad_where (fragP->fr_file, fragP->fr_line,
			_("attempt to .org/.space backwards? (%ld)"),
			(long) fragP->fr_offset);
a504 20
    case rs_leb128:
      {
	valueT value = S_GET_VALUE (fragP->fr_symbol);
	int size;

	size = output_leb128 (fragP->fr_literal + fragP->fr_fix, value,
			      fragP->fr_subtype);

	fragP->fr_fix += size;
	fragP->fr_type = rs_fill;
	fragP->fr_var = 0;
	fragP->fr_offset = 0;
	fragP->fr_symbol = NULL;
      }
      break;

    case rs_cfa:
      eh_frame_convert_frag (fragP);
      break;

d512 1
a512 3
      assert (fragP->fr_next == NULL
	      || ((offsetT) (fragP->fr_next->fr_address - fragP->fr_address)
		  == fragP->fr_fix));
d554 1
a554 1
     PTR xxx ATTRIBUTE_UNUSED;
d620 1
a620 1
     bfd *abfd ATTRIBUTE_UNUSED;
d635 1
a635 6

      fprintf (stream, "  %08lx: type %d ", (unsigned long) fixp,
	       (int) fixp->fx_r_type);
      if (s == NULL)
	fprintf (stream, "no sym\n");
      else
d637 11
a647 2
	  print_symbol_value_1 (stream, s);
	  fprintf (stream, "\n");
d649 2
d664 1
a664 1
     bfd *abfd ATTRIBUTE_UNUSED;
d666 1
a666 1
     PTR xxx ATTRIBUTE_UNUSED;
d684 2
d697 4
a700 5
	if (sym != NULL)
	  resolve_symbol_value (sym, 1);
	
	if (fixp->fx_subsy != NULL)
	  resolve_symbol_value (fixp->fx_subsy, 1);
d704 1
a704 1
	if (sym != NULL && symbol_equated_p (sym)
d707 2
a708 2
	    fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
	    sym = symbol_get_value_expression (sym)->X_add_symbol;
d712 3
a714 1
	if (sym != NULL && symbol_mri_common_p (sym))
a719 5
	symsec = S_GET_SEGMENT (sym);

	if (symsec == NULL)
	  abort ();
	
d726 1
a726 1
		symbol_mark_used_in_reloc (fixp->fx_addsy);
d729 1
a729 1
		  symbol_mark_used_in_reloc (fixp->fx_subsy);
d743 1
a743 1
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
d749 1
a749 1
	      symbol_mark_used_in_reloc (fixp->fx_subsy);
d754 5
a758 5
	/* Don't try to reduce relocs which refer to non-local symbols
           in .linkonce sections.  It can lead to confusion when a
           debugging section refers to a .linkonce section.  I hope
           this will always be correct.  */
	if (symsec != sec && ! S_IS_LOCAL (sym))
d779 1
a779 1
		symbol_mark_used_in_reloc (fixp->fx_addsy);
d782 1
a782 1
		  symbol_mark_used_in_reloc (fixp->fx_subsy);
d790 1
a790 12
	if (symbol_section_p (sym))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    goto done;
	  }

#ifdef BFD_ASSEMBLER
	/* We can never adjust a reloc against a weak symbol.  If we
           did, and the weak symbol was overridden by a real symbol
           somewhere else, then our relocation would be pointing at
           the wrong area of memory.  */
	if (S_IS_WEAK (sym))
d792 1
a792 1
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
a794 1
#endif
d801 1
a801 1
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
d812 1
a812 1
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
d826 1
a826 5
	symbol_mark_used_in_reloc (fixp->fx_addsy);
#ifdef DEBUG5
	fprintf (stderr, "\nadjusted fixup:\n");
	print_fixup (fixp);
#endif
d851 1
a851 1
     PTR xxx ATTRIBUTE_UNUSED;
d893 1
a893 1
      while (symbol_equated_p (sym)
d900 1
a900 1
	  n = symbol_get_value_expression (sym)->X_add_symbol;
d903 1
a903 1
	  fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
d931 1
a931 4
	  as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation overflow"));
	  break;
	case bfd_reloc_outofrange:
	  as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation out of range"));
d934 2
a935 2
	  as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
		    fixp->fx_file, fixp->fx_line, s);
d963 1
a963 1
      while (symbol_equated_p (sym)
d965 1
a965 1
	sym = symbol_get_value_expression (sym)->X_add_symbol;
d979 1
a979 1
		      _("internal error: fixup not contained within frag"));
d992 1
a992 1
			    _("relocation overflow"));
d995 1
a995 1
	      as_fatal (_("%s:%u: bad return from bfd_install_relocation"),
a1027 4
#ifdef SET_SECTION_RELOCS
  SET_SECTION_RELOCS (sec, relocs, n);
#endif

d1047 1
a1047 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1049 1
a1049 1
     PTR xxx ATTRIBUTE_UNUSED;
d1078 1
a1078 1
	      as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
d1102 1
a1102 1
		      as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
d1133 1
a1133 1
		    as_fatal (_("Cannot write to output file."));
d1292 2
a1293 2
	  asympp[i] = symbol_get_bfdsym (symp);
	  symbol_mark_written (symp);
a1303 44
/* Finish the subsegments.  After every sub-segment, we fake an
   ".align ...".  This conforms to BSD4.2 brane-damage.  We then fake
   ".fill 0" because that is the kind of frag that requires least
   thought.  ".align" frags like to have a following frag since that
   makes calculating their intended length trivial.  */

#ifndef SUB_SEGMENT_ALIGN
#ifdef BFD_ASSEMBLER
#define SUB_SEGMENT_ALIGN(SEG) (0)
#else
#define SUB_SEGMENT_ALIGN(SEG) (2)
#endif
#endif

void
subsegs_finish ()
{
  struct frchain *frchainP;

  for (frchainP = frchain_root; frchainP; frchainP = frchainP->frch_next)
    {
      subseg_set (frchainP->frch_seg, frchainP->frch_subseg);

      /* This now gets called even if we had errors.  In that case,
         any alignment is meaningless, and, moreover, will look weird
         if we are generating a listing.  */
      frag_align (had_errors () ? 0 : SUB_SEGMENT_ALIGN (now_seg),
		  subseg_text_p (now_seg) ? NOP_OPCODE : 0,
		  0);

      /* frag_align will have left a new frag.
	 Use this last frag for an empty ".fill".

	 For this segment ...
	 Create a last frag. Do not leave a "being filled in frag".  */

      frag_wane (frag_now);
      frag_now->fr_fix = 0;
      know (frag_now->fr_next == NULL);
    }
}

/* Write the object file.  */

d1307 1
d1322 1
a1322 1
	  as_warn (_("%d error%s, %d warning%s, generating bad object file.\n"),
d1329 1
a1329 1
	  as_fatal (_("%d error%s, %d warning%s, no object file generated.\n"),
d1342 28
a1462 7
      /* At this point we have linked all the frags into a single
         chain.  However, cvt_frag_to_fill may call md_convert_frag
         which may call fix_new.  We need to ensure that fix_new adds
         the fixup to the right section.  */
      if (fragP == data_frag_root)
	subseg_change (SEG_DATA, 0);

a1488 1
	  subseg_change (lie->seg, lie->subseg);
a1532 1
	subseg_change (lie->seg, lie->subseg);
d1559 1
a1559 1
	    to_addr -= symbol_get_frag (lie->sub)->fr_address;
d1573 1
a1573 1
	    to_addr += symbol_get_frag (lie->add)->fr_address;
d1706 2
a1707 1
	resolve_symbol_value (symp, 1);
a1708 1
  resolve_local_symbol_values ();
d1731 1
a1731 1
	  if (symbol_mri_common_p (symp))
d1734 1
a1734 1
		as_bad (_("%s: global symbols not supported in common sections"),
d1747 1
a1747 1
		as_bad (_("local label %s is not defined"), name2);
d1753 13
a1765 1
	  resolve_symbol_value (symp, 1);
d1769 1
a1769 1
	  if (symbol_equated_p (symp)
d1785 2
a1786 2
		  symbol_get_bfdsym (symp)->flags,
		  segment_name (S_GET_SEGMENT (symp)));
d1793 1
a1793 1
	  if (! punt || symbol_used_in_reloc_p (symp))
d1803 1
a1803 1
	       && symbol_section_p (symp))
d1809 1
a1809 1
		  && ! symbol_used_in_reloc_p (symp)))
d1820 1
a1820 1
	  if (! symbol_resolved_p (symp))
d1822 1
a1822 1
	      as_bad (_("can't resolve value for symbol \"%s\""),
d1824 1
a1824 1
	      symbol_mark_resolved (symp);
d1829 1
a1829 1
	  symbol_get_bfdsym (symp)->value = S_GET_VALUE (symp);
d1938 3
a1940 1
      target +=	S_GET_VALUE (symbolP) + symbol_get_frag (symbolP)->fr_address;
d1951 2
a1952 2
      if (symbol_get_frag (symbolP)->fr_address >= was_address
	  && is_dnrange (fragP, symbol_get_frag (symbolP)))
d2066 1
a2066 1
		as_bad (_("alignment padding (%lu bytes) not a multiple of %ld"),
a2089 10
	case rs_leb128:
	  /* Initial guess is always 1; doing otherwise can result in 
	     stable solutions that are larger than the minimum.  */
	  address += fragP->fr_offset = 1;
	  break;

	case rs_cfa:
	  address += eh_frame_estimate_size_before_relax (fragP);
	  break;

d2151 1
a2151 1
		      offset = (symbol_get_frag (lie->add)->fr_address
d2154 1
a2154 1
				- (symbol_get_frag (lie->sub)->fr_address
d2162 1
a2162 1
			      as_warn (_(".word %s-%s+%s didn't fit"),
d2176 2
a2177 4
			    if ((symbol_get_frag (untruth->add)
				 == symbol_get_frag (lie->add))
				&& (S_GET_VALUE (untruth->add)
				    == S_GET_VALUE (lie->add)))
d2227 2
a2228 2
		      target += (S_GET_VALUE (symbolP)
				 + symbol_get_frag (symbolP)->fr_address);
d2239 2
a2240 10
		      as_bad_where (fragP->fr_file, fragP->fr_line,
				    _("attempt to .org backwards ignored"));

		      /* We've issued an error message.  Change the
                         frag to avoid cascading errors.  */
		      fragP->fr_type = rs_align;
		      fragP->fr_subtype = 0;
		      fragP->fr_offset = 0;
		      fragP->fr_fix = after - address;
		      growth = stretch;
d2251 1
a2251 1
		    if (symbol_get_frag (symbolP) != &zero_address_frag
d2255 1
a2255 1
				    _(".space specifies non-absolute value"));
d2259 1
a2259 1
			as_warn (_(".space or .fill with negative value, ignored"));
a2278 16
	      case rs_leb128:
		{
		  valueT value;
		  int size;

		  value = resolve_symbol_value (fragP->fr_symbol, 0);
		  size = sizeof_leb128 (value, fragP->fr_subtype);
		  growth = size - fragP->fr_offset;
		  fragP->fr_offset = size;
		}
		break;

	      case rs_cfa:
		growth = eh_frame_relax_frag (fragP);
		break;

a2352 1

a2357 1

d2373 1
a2373 1
	  && symbol_mri_common_p (add_symbolP))
d2378 1
a2378 2
	  add_symbolP = fixP->fx_addsy =
	    symbol_get_value_expression (add_symbolP)->X_add_symbol;
d2386 1
a2386 1
	  resolve_symbol_value (sub_symbolP, 1);
d2411 1
a2411 1
			      _("Negative of non-absolute symbol %s"),
d2425 1
a2425 1
			      _("callj to difference of 2 symbols"));
d2491 1
a2491 4
				_("Subtraction of two symbols in different sections \"%s\" {%s section} - \"%s\" {%s section} at file address %s."),
				S_GET_NAME (add_symbolP),
				segment_name (S_GET_SEGMENT (add_symbolP)),
				S_GET_NAME (sub_symbolP),
d2493 1
a2493 1
				buf);
d2566 1
a2566 1
				    _("can't use COBR format with external label"));
a2583 1
#if !(defined (TC_V850) && defined (OBJ_ELF))
d2585 1
a2585 3
#if !(defined (TC_ARM)  && defined (OBJ_ELF))
#if !(defined (TC_I960) && defined (OBJ_ELF))
#if !defined (TC_I386) || !(defined (OBJ_ELF) || defined (OBJ_COFF)) || defined (TE_PE)
a2588 3
#endif
#endif
#endif
d2603 1
a2603 1
	      symbol_mark_used_in_reloc (fixP->fx_addsy);
a2607 21
      if (!fixP->fx_done)
	{
#ifdef MD_APPLY_FIX3
	  md_apply_fix3 (fixP, &add_number, this_segment_type);
#else
#ifdef BFD_ASSEMBLER
	  md_apply_fix (fixP, &add_number);
#else
	  md_apply_fix (fixP, add_number);
#endif
#endif

#ifndef TC_HANDLES_FX_DONE
	  /* If the tc-* files haven't been converted, assume it's handling
	     it the old way, where a null fx_addsy means that the fix has
	     been applied completely, and no further work is needed.  */
	  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
	    fixP->fx_done = 1;
#endif
	}

d2610 1
a2610 1
	  if ((size_t) size < sizeof (valueT))
d2612 1
a2612 1
	      valueT mask;
d2614 1
d2616 14
a2629 3
	      mask--;		/* set all bits to one */
	      mask <<= size * 8 - (fixP->fx_signed ? 1 : 0);
	      if ((add_number & mask) != 0 && (add_number & mask) != mask)
d2638 1
a2638 1
				_("Value of %s too large for field of %d bytes at %s"),
d2650 1
a2650 1
			  _("Signed .word overflow; switch may be too large; %ld at 0x%lx"),
d2656 20
d2677 1
a2677 2
    skip:  ATTRIBUTE_UNUSED_LABEL
      ;
d2697 1
a2697 1
  if ((size_t) n > sizeof (val) || n <= 0)
d2712 1
a2712 1
  if ((size_t) n > sizeof (val) || n <= 0)
d2725 1
a2725 1
  fprintf (file, "fixups: %d\n", n_fixups);
a2776 3
#ifdef TC_FIX_DATA_PRINT
  TC_FIX_DATA_PRINT (stderr, fixp);
#endif
@


1.1.1.7
log
@Import binutils-2.11.2
- only the binutils package (no gdb here)
- don't import libiberty and texinfo, they are elsewhere
- remove all .info* generated files
@
text
@d2 1
a2 2
   Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001
d22 1
a22 1
/* This thing should be set up to do byteordering correctly.  But...  */
a27 1
#include "dwarf2dbg.h"
d33 6
a50 8
#ifndef TC_LINKRELAX_FIXUP
#define TC_LINKRELAX_FIXUP(SEG) 1
#endif

#ifndef TC_FIX_ADJUSTABLE
#define TC_FIX_ADJUSTABLE(fix) 1
#endif

d80 3
a82 3
struct frag *text_last_frag;	/* Last frag in segment.  */
struct frag *data_last_frag;	/* Last frag in segment.  */
static struct frag *bss_last_frag;	/* Last frag in segment.  */
d90 1
a90 1
char *next_object_file_charP;	/* Tracks object file bytes.  */
d96 1
a96 1
#endif /* BFD_ASSEMBLER  */
d121 1
a121 2
static void relax_seg PARAMS ((bfd *, asection *, PTR));
static void size_seg PARAMS ((bfd *, asection *, PTR));
a134 5
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && defined (TE_GO32)
static void set_segment_vma PARAMS ((bfd *, asection *, PTR));
#endif

/* Create a fixS in obstack 'notes'.  */
d136 5
d144 7
a150 7
     fragS *frag;		/* Which frag?  */
     int where;			/* Where in that frag?  */
     int size;			/* 1, 2, or 4 usually.  */
     symbolS *add_symbol;	/* X_add_symbol.  */
     symbolS *sub_symbol;	/* X_op_symbol.  */
     offsetT offset;		/* X_add_number.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
d152 1
a152 1
     bfd_reloc_code_real_type r_type; /* Relocation type.  */
d154 1
a154 1
     int r_type;		/* Relocation type.  */
d195 1
a195 1
  TC_INIT_FIX_DATA (fixP);
d203 2
a204 1
     time option.  xoxorich.  */
d221 1
a221 1
#else /* REVERSE_SORT_RELOCS  */
d231 2
a232 1
#endif /* REVERSE_SORT_RELOCS  */
d242 6
a247 6
     fragS *frag;		/* Which frag?  */
     int where;			/* Where in that frag?  */
     int size;			/* 1, 2, or 4 usually.  */
     symbolS *add_symbol;	/* X_add_symbol.  */
     offsetT offset;		/* X_add_number.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
d249 1
a249 1
     bfd_reloc_code_real_type r_type; /* Relocation type.  */
d251 1
a251 1
     int r_type;		/* Relocation type.  */
d264 3
a266 3
     fragS *frag;		/* Which frag?  */
     int where;			/* Where in that frag?  */
     int size;			/* 1, 2, or 4 usually.  */
d268 1
a268 1
     int pcrel;			/* TRUE if PC-relative relocation.  */
d270 1
a270 1
     bfd_reloc_code_real_type r_type; /* Relocation type.  */
d272 1
a272 1
     int r_type;		/* Relocation type.  */
a283 4
    case O_register:
      as_bad (_("register value used as expression"));
      break;

a288 1

a292 1

d306 1
a306 1
      as_fatal (_("rva not supported"));
d321 1
a321 1
      /* Fall through.  */
d331 2
a332 1
  return fix_new_internal (frag, where, size, add, sub, off, pcrel, r_type);
d342 1
a342 1
  /* Don't trust memcpy() of 0 chars.  */
d354 6
a359 5
/* This routine records the largest alignment seen for each segment.
   If the beginning of the segment is aligned on the worst-case
   boundary, all of the other alignments within it will work.  At
   least one object format really uses this info.  */

d362 1
a362 1
     /* Segment to which alignment pertains.  */
a378 13
int
get_recorded_alignment (seg)
     segT seg;
{
  if (seg == absolute_section)
    return 0;
#ifdef BFD_ASSEMBLER
  return bfd_get_section_alignment (stdoutput, seg);
#else
  return section_alignment[(int) seg];
#endif
}

d395 1
a395 1
#endif /* defined (BFD_ASSEMBLER)  */
d446 2
a447 2
    info->frchainP->frch_last
      = chain_frchains_together_1 (section, info->frchainP);
d469 1
a469 1
#endif /* BFD  */
d476 1
a476 1
     segT sec ATTRIBUTE_UNUSED;
a489 1
    case rs_align_test:
a530 4
    case rs_dwarf2dbg:
      dwarf2dbg_convert_frag (fragP);
      break;

d542 5
a546 3
      /* After md_convert_frag, we make the frag into a ".space 0".
	 md_convert_frag() should set up any fixSs and constants
	 required.  */
d575 1
a575 1
#endif /* defined (BFD_ASSEMBLER) || !defined (BFD)  */
d579 1
a579 15
relax_seg (abfd, sec, do_code)
     bfd *abfd;
     asection *sec;
     PTR do_code;
{
  flagword flags = bfd_get_section_flags (abfd, sec);
  segment_info_type *seginfo = seg_info (sec);

  if (!(flags & SEC_CODE) == !do_code
      && seginfo && seginfo->frchainP)
    relax_segment (seginfo->frchainP->frch_root, sec);
}

static void
size_seg (abfd, sec, xxx)
d592 2
d597 1
d603 1
a603 2
	/* Walk to last elt.  */
	;
a608 2
  flags = bfd_get_section_flags (abfd, sec);

d700 1
a700 2
      /* Ignore it.  */
      ;
d719 1
a719 1

d743 1
a743 1

d859 1
a859 1
	   the section when it calls resolve_symbol_value.  */
d871 1
a871 1
#if 1 /* def RELOC_REQUIRES_SYMBOL  */
d880 1
a880 3
#if 0
	fixp->fx_addsy->sy_used_in_reloc = 1;
#endif
d894 1
a894 1
  unsigned int i;
d914 1
a914 1
  memset ((char *) relocs, 0, n * sizeof (arelent *));
d1003 1
a1003 1
         symbol, then generate the reloc against the latter symbol
d1015 2
a1016 2
	  relocs[i++] = reloc[j];
	  assert (i <= n);
d1024 1
a1024 1
	{
d1029 1
a1029 1
	  switch (s)
d1041 1
a1041 1
	}
d1104 1
a1104 1
      || !(bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS))
d1137 1
a1137 1
	  if (fill_size > sizeof (buf))
d1139 1
a1139 1
	      /* Do it the old way. Can this ever happen?  */
d1149 1
a1149 2
		      as_perror (_("FATAL: Can't write %s"),
				 stdoutput->filename);
d1169 1
a1169 1
		  n_per_buf = sizeof (buf) / fill_size;
d1171 1
a1171 1
		    memcpy (bufp, fill_literal, fill_size);
d1176 3
a1178 3
		  x = bfd_set_section_contents
		    (stdoutput, sec, buf, (file_ptr) offset,
		     (bfd_size_type) n_per_buf * fill_size);
d1217 1
a1217 1
#endif /* BFD_ASSEMBLER || (! BFD && ! OBJ_AOUT)  */
d1228 3
a1231 1
  /* Now the addresses of frags are correct within the segment.  */
d1236 7
a1242 5
  /* Join the 2 segments into 1 huge segment.
     To do this, re-compute every rn_address in the SEG_DATA frags.
     Then join the data frags after the text frags.

     Determine a_data [length of data segment].  */
d1247 1
a1247 2
      know ((text_last_frag->fr_type == rs_fill)
	    && (text_last_frag->fr_offset == 0));
d1251 1
a1251 1
      slide = H_GET_TEXT_SIZE (&headers);	/* & in file of the data segment.  */
d1263 3
a1265 1
	fragP->fr_address += slide;
d1286 1
a1286 1
#else /* ! OBJ_BOUT  */
d1290 1
a1290 1
#endif /* ! OBJ_BOUT  */
d1292 1
a1292 1
  /* Slide all the frags.  */
d1298 3
a1300 1
	fragP->fr_address += slide;
d1309 1
a1309 1
#endif /* ! BFD_ASSEMBLER && ! BFD  */
a1350 14
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && defined (TE_GO32)
static void
set_segment_vma (abfd, sec, xxx)
     bfd *abfd;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
{
  static bfd_vma addr = 0;

  bfd_set_section_vma (abfd, sec, addr);
  addr += bfd_section_size (abfd, sec);
}
#endif /* BFD_ASSEMBLER && OBJ_COFF && !TE_PE  */

a1371 2
      int alignment;

d1377 3
a1379 12
      alignment = had_errors () ? 0 : SUB_SEGMENT_ALIGN (now_seg);

      /* The last subsegment gets an aligment corresponding to the
	 alignment of the section.  This allows proper nop-filling
	 at the end of code-bearing sections.  */
      if (!frchainP->frch_next || frchainP->frch_next->frch_seg != now_seg)
	alignment = get_recorded_alignment (now_seg);

      if (subseg_text_p (now_seg))
	frag_align_code (alignment, 0);
      else
	frag_align (alignment, 0, 0);
d1386 1
d1399 1
a1399 1
  fragS *fragP;			/* Track along all frags.  */
d1428 1
a1428 1
     and if so -- fix it up so that it can be program entry point.  */
d1430 1
a1430 1
#endif /* OBJ_VMS  */
d1478 1
a1478 3
  bfd_map_over_sections (stdoutput, relax_seg, (char *) 1);
  bfd_map_over_sections (stdoutput, relax_seg, (char *) 0);
  bfd_map_over_sections (stdoutput, size_seg, (char *) 0);
d1481 1
a1481 9
#endif /* BFD_ASSEMBLER  */

#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && defined (TE_GO32)
  /* Now that the segments have their final sizes, run through the
     sections and set their vma and lma. !BFD gas sets them, and BFD gas
     should too. Currently, only DJGPP uses this code, but other
     COFF targets may need to execute this too.  */
  bfd_map_over_sections (stdoutput, set_segment_vma, (char *) 0);
#endif
d1484 21
a1504 17
  /* Crawl the symbol chain.

     For each symbol whose value depends on a frag, take the address of
     that frag and subsume it into the value of the symbol.
     After this, there is just one way to lookup a symbol value.
     Values are left in their final state for object file emission.
     We adjust the values of 'L' local symbols, even if we do
     not intend to emit them to the object file, because their values
     are needed for fix-ups.

     Unless we saw a -L flag, remove all symbols that begin with 'L'
     from the symbol chain.  (They are still pointed to by the fixes.)

     Count the remaining symbols.
     Assign a symbol number to each symbol.
     Count the number of string-table chars we will emit.
     Put this info into the headers as appropriate.  */
d1515 6
a1520 4
  /* Addresses of frags now reflect addresses we use in the object file.
     Symbol values are correct.
     Scan the frags, converting any ".org"s and ".align"s to ".fill"s.
     Also converting any machine-dependent frags using md_convert_frag();  */
d1545 1
a1545 1
#endif /* ! BFD_ASSEMBLER  */
d1566 2
a1567 2
			   lie->word_goes_here - lie->frag->fr_literal,
			   2, &exp);
d1587 3
a1589 3
#endif /* TC_NS32K  */
#endif /* TC_SPARC|TC_A29K|NEED_FX_R_TYPE  */
#endif /* BFD_ASSEMBLER  */
d1608 1
a1608 3
	for (untruth = lie;
	     untruth && untruth->dispfrag == fragP;
	     untruth = untruth->next_broken_word)
d1613 1
a1613 2
	table_addr = (lie->dispfrag->fr_address
		      + (table_ptr - lie->dispfrag->fr_literal));
d1618 1
a1618 2
	md_create_short_jump (table_ptr, from_addr, to_addr, lie->dispfrag,
			      lie->add);
d1622 1
a1622 3
	for (m = 0;
	     lie && lie->dispfrag == fragP;
	     m++, lie = lie->next_broken_word)
d1626 2
a1627 2
	    /* Patch the jump table.  */
	    /* This is the offset from ??? to table_ptr+0.  */
a1631 3
#ifdef TC_CHECK_ADJUSTED_BROKEN_DOT_WORD
	    TC_CHECK_ADJUSTED_BROKEN_DOT_WORD (to_addr, lie);
#endif
d1633 1
a1633 3
	    for (untruth = lie->next_broken_word;
		 untruth && untruth->dispfrag == fragP;
		 untruth = untruth->next_broken_word)
d1639 2
a1640 2
	    /* Install the long jump.  */
	    /* This is a long jump from table_ptr+0 to the final target.  */
d1646 1
a1646 2
	    md_create_long_jump (table_ptr, from_addr, to_addr, lie->dispfrag,
				 lie->add);
d1652 1
a1652 1
#endif /* not WORKING_DOT_WORD  */
d1656 1
a1656 1
  {				/* not vms  */
d1659 4
a1662 2
    /* Scan every FixS performing fixups. We had to wait until now to
       do this because md_convert_frag() may have made some fixSs.  */
d1671 1
a1671 1
    /* FIXME: Move this stuff into the pre-write-hook.  */
d1675 1
a1675 1
    obj_pre_write_hook (&headers);	/* Extra coff stuff.  */
d1684 1
a1684 2
    know ((next_object_file_charP - the_object_file)
	  == H_GET_HEADER_SIZE (&headers));
d1686 3
a1688 1
    /* Emit code.  */
d1697 1
a1697 2
	append (&next_object_file_charP, fragP->fr_literal,
		(unsigned long) fragP->fr_fix);
d1703 7
a1709 3
	  append (&next_object_file_charP, fill_literal,
		  (unsigned long) fill_size);
      }
d1711 5
a1715 13
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)));

    /* Emit relocations.  */
    obj_emit_relocations (&next_object_file_charP, text_fix_root,
			  (relax_addressT) 0);
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)));
d1718 13
a1730 17
       first data fragment, not end of last text fragment:  alignment of the
       start of the data segment may place a gap between the segments.  */
    obj_emit_relocations (&next_object_file_charP, data_fix_root,
			  data0_frchainP->frch_root->fr_address);
#else /* TC_I960  */
    obj_emit_relocations (&next_object_file_charP, data_fix_root,
			  text_last_frag->fr_address);
#endif /* TC_I960  */

    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)
	      + H_GET_DATA_RELOCATION_SIZE (&headers)));

    /* Emit line number entries.  */
d1732 1
a1732 7
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)
	      + H_GET_DATA_RELOCATION_SIZE (&headers)
	      + H_GET_LINENO_SIZE (&headers)));
d1734 3
a1736 1
    /* Emit symbols.  */
d1738 5
a1742 8
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)
	      + H_GET_DATA_RELOCATION_SIZE (&headers)
	      + H_GET_LINENO_SIZE (&headers)
	      + H_GET_SYMBOL_TABLE_SIZE (&headers)));
a1743 1
    /* Emit strings.  */
d1745 3
a1747 1
      obj_emit_strings (&next_object_file_charP);
d1754 1
a1754 1
    /* Write the data to the file.  */
d1758 5
a1762 3
  }
#else /* OBJ_VMS  */
  /* Now do the VMS-dependent part of writing the object file.  */
d1767 2
a1768 2
#endif /* OBJ_VMS  */
#else /* BFD_ASSEMBLER  */
d1790 1
a1790 1
  bfd_map_over_sections (stdoutput, adjust_reloc_syms, (char *) 0);
d1814 1
a1814 2
	      const char *name2 =
		decode_local_label_name ((char *) S_GET_NAME (symp));
a1870 1

d1874 1
d1928 1
a1928 1
#endif /* BFD_ASSEMBLER  */
d1930 14
a1943 1
#endif /* ! BFD  */
d1947 14
d1964 1
a1964 2
relax_frag (segment, fragP, stretch)
     segT segment;
d1972 8
a1979 10
  long growth;
  offsetT aim;
  addressT target;
  addressT address;
  symbolS *symbolP;
  const relax_typeS *table;

  target = fragP->fr_offset;
  address = fragP->fr_address;
  table = TC_GENERIC_RELAX_TABLE;
d1982 1
a1982 1
  symbolP = fragP->fr_symbol;
a1985 4
      fragS *sym_frag;

      sym_frag = symbol_get_frag (symbolP);

d1993 1
a1993 1
      know (sym_frag != NULL);
d1996 2
a1997 2
	    || sym_frag == &zero_address_frag);
      target += S_GET_VALUE (symbolP) + sym_frag->fr_address;
d2002 3
a2004 1
	 between grows, and that will force another pass.  */
d2006 4
a2009 3
      if (stretch != 0
	  && sym_frag->relax_marker != fragP->relax_marker
	  && S_GET_SEGMENT (symbolP) == segment)
d2017 3
a2019 3
  /* Currently only the ns32k family needs this.  */
  aim += TC_PCREL_ADJUST (fragP);
/* #else */
d2022 1
a2022 2
#if 0
  assert (fragP->fr_targ.ns32k.pcrel_adjust == 0);
d2024 1
a2024 2
#endif
#ifdef md_prepare_relax_scan /* formerly called M68K_AIM_KLUDGE  */
d2030 1
a2030 1
      /* Look backwards.  */
d2036 1
a2036 1
	    /* Grow to next state.  */
d2044 1
a2044 1
      /* Look forwards.  */
d2050 1
a2050 1
	    /* Grow to next state.  */
d2063 1
a2063 1
#endif /* defined (TC_GENERIC_RELAX_TABLE)  */
d2069 2
a2070 2
     register relax_addressT address;	/* Address now.  */
     register int alignment;	/* Alignment (binary).  */
a2085 10
/* Now we have a segment, not a crowd of sub-segments, we can make
   fr_address values.

   Relax the frags.

   After this, all frags in this segment have addresses that are correct
   within the segment. Since segments live in different file addresses,
   these frag addresses may not be the same as final object-file
   addresses.  */

d2096 1
a2096 1
  /* In case md_estimate_size_before_relax() wants to make fixSs.  */
a2103 1
      fragP->relax_marker = 0;
a2114 1
	case rs_align_test:
d2142 1
a2142 1
	  /* Broken words don't concern us yet.  */
d2148 1
a2148 1
	  /* Initial guess is always 1; doing otherwise can result in
a2156 4
	case rs_dwarf2dbg:
	  address += dwarf2dbg_estimate_size_before_relax (fragP);
	  break;

d2160 2
a2161 2
	}
    }
d2165 5
a2169 4
    long stretch;	/* May be any size, 0 or negative.  */
    /* Cumulative number of addresses we have relaxed this pass.
       We may have relaxed more than one address.  */
    int stretched;	/* Have we stretched on this pass?  */
d2176 1
a2176 3
	stretch = 0;
	stretched = 0;

a2183 1
	    fragP->relax_marker ^= 1;
d2191 1
a2191 1
	      case rs_fill:	/* .fill never relaxes.  */
d2256 1
a2256 1
		}		/* case rs_broken_word  */
a2259 1
	      case rs_align_test:
d2282 2
a2283 2
		  addressT target = offset;
		  addressT after;
d2298 1
a2298 1
		    }		/* if we have a symbol  */
d2307 1
a2307 1
			 .org backwards.  */
d2320 1
a2320 2
		  /* This is an absolute growth factor  */
		  growth -= stretch;
d2346 1
a2346 1
		growth = md_relax_frag (segment, fragP, stretch);
d2351 2
a2352 2
		growth = relax_frag (segment, fragP, stretch);
#endif /* TC_GENERIC_RELAX_TABLE  */
a2371 4
	      case rs_dwarf2dbg:
		growth = dwarf2dbg_relax_frag (fragP);
		break;

d2379 1
a2379 1
		stretched = 1;
d2381 1
a2381 1
	  }			/* For each frag in the segment.  */
d2383 2
a2384 2
    while (stretched);		/* Until nothing further to relax.  */
  }				/* do_relax  */
d2386 9
a2394 5
  /* We now have valid fr_address'es for each frag.  */

  /* All fr_address's are correct, relative to their own segment.
     We have made all the fixS we will ever make.  */
}
d2416 1
a2416 1
     segT this_segment_type;	/* N_TYPE bits for segment.  */
d2436 1
a2436 1
  if (linkrelax && TC_LINKRELAX_FIXUP (this_segment_type))
d2446 1
d2452 1
d2492 1
a2492 1
	      /* It's just -sym.  */
d2515 1
a2515 1
		 something different for N_UNDF.  */
d2522 1
a2522 1
#endif /* TC_I960  */
d2527 1
a2527 1
	      pcrel = 0;	/* No further pcrel processing.  */
d2541 1
a2541 1
	      /* Different segments in subtraction.  */
d2550 3
a2552 5
#if 0
		       /* Do this even if it's already described as
			  pc-relative.  For example, on the m68k, an
			  operand of "pc@@(foo-.-2)" should address
			  "foo" in a pc-relative mode.  */
d2602 5
a2606 3
	      /* This fixup was made when the symbol's segment was
		 SEG_UNKNOWN, but it is now in the local segment.
		 So we know how to do the address without relocation.  */
d2612 1
a2612 1
		 below a no-op.  */
d2614 1
a2614 1
#endif /* TC_I960  */
d2618 1
a2618 2
	      /* Lie.  Don't want further pcrel processing.  */
	      pcrel = 0;
d2637 1
a2637 1
#endif /* TC_I960  */
d2660 4
a2663 3
			 13-bit displacement and are only to be used
			 for local branches: flag as error, don't generate
			 relocation.  */
d2669 2
a2670 2
		    }		/* COBR.  */
#endif /* TC_I960  */
d2676 2
a2677 2
#endif /* TE_I386AIX  */
#endif /* OBJ_COFF  */
d2683 11
a2693 2
		  if (TC_FIX_ADJUSTABLE (fixP))
		    add_number += S_GET_VALUE (add_symbolP);
d2741 1
a2741 1
	      mask--;		/* Set all bits to one.  */
d2754 1
a2754 1
		} /* Generic error checking.  */
d2768 1
a2768 1
	}			/* Not a bit fix.  */
d2778 1
a2778 1
    }				/* For each fixS in this segment.  */
d2823 1
a2823 1
/* For debugging.  */
d2876 2
@


1.1.1.8
log
@import binutils 2.14 (excluding testsuites, .info files, and .po files)
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003
d31 4
d36 1
a36 1
#define TC_ADJUST_RELOC_COUNT(FIX, COUNT)
d40 1
a40 14
#define TC_FORCE_RELOCATION(FIX)		\
  (generic_force_reloc (FIX))
#endif

#ifndef TC_FORCE_RELOCATION_ABS
#define TC_FORCE_RELOCATION_ABS(FIX)		\
  (TC_FORCE_RELOCATION (FIX))
#endif

#ifndef TC_FORCE_RELOCATION_LOCAL
#define TC_FORCE_RELOCATION_LOCAL(FIX)		\
  (!(FIX)->fx_pcrel				\
   || (FIX)->fx_plt				\
   || TC_FORCE_RELOCATION (FIX))
d43 2
a44 30
#ifndef TC_FORCE_RELOCATION_SUB_SAME
#define TC_FORCE_RELOCATION_SUB_SAME(FIX, SEG)	\
  (! SEG_NORMAL (SEG))
#endif

#ifndef TC_FORCE_RELOCATION_SUB_ABS
#define TC_FORCE_RELOCATION_SUB_ABS(FIX)	0
#endif

#ifndef TC_FORCE_RELOCATION_SUB_LOCAL
#ifdef DIFF_EXPR_OK
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX)	0
#else
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX)	1
#endif
#endif

#ifndef TC_VALIDATE_FIX_SUB
#ifdef UNDEFINED_DIFFERENCE_OK
/* The PA needs this for PIC code generation.  */
#define TC_VALIDATE_FIX_SUB(FIX) 1
#else
#ifdef BFD_ASSEMBLER
#define TC_VALIDATE_FIX_SUB(FIX)		\
  ((FIX)->fx_r_type == BFD_RELOC_GPREL32	\
   || (FIX)->fx_r_type == BFD_RELOC_GPREL16)
#else
#define TC_VALIDATE_FIX_SUB(FIX) 0
#endif
#endif
d51 2
a52 6
#ifndef MD_APPLY_SYM_VALUE
#define MD_APPLY_SYM_VALUE(FIX) 1
#endif

#ifndef TC_FINALIZE_SYMS_BEFORE_SIZE_SEG
#define TC_FINALIZE_SYMS_BEFORE_SIZE_SEG 1
d56 1
a56 1
#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from (FIX)
d60 2
a61 2
extern const int md_short_jump_size;
extern const int md_long_jump_size;
a63 3
/* Used to control final evaluation of expressions.  */
int finalize_syms = 0;

a64 6

symbolS *abs_section_sym;

/* Remember the value of dot when parsing expressions.  */
addressT dot_value;

d105 4
a108 1
#define RELOC_ENUM enum bfd_reloc_code_real
a109 3
#define RELOC_ENUM int
#endif

d113 2
a114 1
				       RELOC_ENUM r_type));
d116 1
a116 1
static long fixup_segment PARAMS ((fixS *, segT));
d125 2
a127 1
static void fix_segment PARAMS ((bfd *, asection *, PTR));
d140 3
d156 5
a160 1
     RELOC_ENUM r_type ATTRIBUTE_UNUSED; /* Relocation type.  */
a179 1
  fixP->fx_dot_value = dot_value;
d251 5
a255 1
     RELOC_ENUM r_type;		/* Relocation type.  */
d272 5
a276 1
     RELOC_ENUM r_type;		/* Relocation type.  */
a342 13
/* Generic function to determine whether a fixup requires a relocation.  */
int
generic_force_reloc (fix)
     fixS *fix;
{
#ifdef BFD_ASSEMBLER
  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;
#endif
  return S_FORCE_RELOC (fix->fx_addsy, fix->fx_subsy == NULL);
}

a524 1
	  fragP->fr_offset = 0;
a600 1
static void relax_seg PARAMS ((bfd *, asection *, PTR));
d602 2
a603 2
relax_seg (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
d605 1
a605 1
     PTR xxx;
d607 1
d610 3
a612 6
  if (seginfo && seginfo->frchainP
      && relax_segment (seginfo->frchainP->frch_root, sec))
    {
      int *result = (int *) xxx;
      *result = 1;
    }
a614 1
static void size_seg PARAMS ((bfd *, asection *, PTR));
d655 1
a655 1
  assert (x);
d659 1
a659 1
  assert (x);
d671 1
a671 8
      if ((newsize - size) % fragp->fr_var == 0)
	fragp->fr_offset += (newsize - size) / fragp->fr_var;
      else
	/* If we hit this abort, it's likely due to subsegs_finish not
	   providing sufficient alignment on the last frag, and the
	   machine dependent code using alignment frags with fr_var
	   greater than 1.  */
	abort ();
a720 3
/* This pass over fixups decides whether symbols can be replaced with
   section symbols.  */

d755 2
a756 1
	resolve_symbol_value (sym);
d759 1
a759 1
	  resolve_symbol_value (fixp->fx_subsy);
d763 2
a764 1
	if (symbol_equated_reloc_p (sym))
d771 1
a771 1
	if (symbol_mri_common_p (sym))
d774 1
a774 1
	    continue;
d777 1
a777 17
	/* If the symbol is undefined, common, weak, or global (ELF
	   shared libs), we can't replace it with the section symbol.  */
	if (S_FORCE_RELOC (fixp->fx_addsy, 1))
	  continue;

	/* Is there some other (target cpu dependent) reason we can't adjust
	   this one?  (E.g. relocations involving function addresses on
	   the PA.  */
#ifdef tc_fix_adjustable
	if (! tc_fix_adjustable (fixp))
	  continue;
#endif

	/* Since we're reducing to section symbols, don't attempt to reduce
	   anything that's already using one.  */
	if (symbol_section_p (sym))
	  continue;
a778 1
	symsec = S_GET_SEGMENT (sym);
d784 30
a813 3
	    /* The fixup_segment routine normally will not use this
               symbol in a relocation.  */
	    continue;
d822 55
a876 8
	    if ((symsec->flags & SEC_LINK_ONCE) != 0
		|| (IS_ELF
		    /* The GNU toolchain uses an extension for ELF: a
		       section beginning with the magic string
		       .gnu.linkonce is a linkonce section.  */
		    && strncmp (segment_name (symsec), ".gnu.linkonce",
				sizeof ".gnu.linkonce" - 1) == 0))
	      continue;
d878 1
d880 10
a889 5
	/* Never adjust a reloc against local symbol in a merge section
	   with non-zero addend.  */
	if ((symsec->flags & SEC_MERGE) != 0
	    && (fixp->fx_offset != 0 || fixp->fx_subsy != NULL))
	  continue;
d891 3
a893 3
	/* Never adjust a reloc against TLS local symbol.  */
	if ((symsec->flags & SEC_THREAD_LOCAL) != 0)
	  continue;
d895 1
a895 1
	/* We refetch the segment when calling section_symbol, rather
d900 1
d905 3
d909 14
a927 11
fix_segment (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
{
  segment_info_type *seginfo = seg_info (sec);

  fixup_segment (seginfo->fix_root, sec);
}

static void
d945 2
d970 1
a970 1
         symbol, then generate the reloc against the latter symbol
d973 2
a974 1
      while (symbol_equated_reloc_p (sym))
d1011 1
a1011 2
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("relocation overflow"));
d1014 1
a1014 2
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("relocation out of range"));
d1031 1
d1046 3
a1048 12
      while (symbol_equated_reloc_p (sym))
	{
	  symbolS *n;

	  /* We must avoid looping, as that can occur with a badly
	     written program.  */
	  n = symbol_get_value_expression (sym)->X_add_symbol;
	  if (n == sym)
	    break;
	  fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
	  sym = n;
	}
d1058 1
a1076 4
	    case bfd_reloc_outofrange:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("relocation out of range"));
	      break;
d1078 2
a1079 2
	      as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
			fixp->fx_file, fixp->fx_line, s);
d1162 1
a1162 1
	  if (!x)
d1186 1
a1186 1
		  if (!x)
d1220 2
a1221 2
		  if (!x)
		    as_fatal (_("cannot write to output file"));
d1354 2
a1355 2
  bfd_boolean result;
  extern PTR bfd_alloc PARAMS ((bfd *, bfd_size_type));
a1366 1
      bfd_size_type amt = (bfd_size_type) nsyms * sizeof (asymbol *);
d1368 2
a1369 1
      asympp = (asymbol **) bfd_alloc (stdoutput, amt);
d1380 1
a1380 1
  assert (result);
d1385 14
a1405 8
#ifdef HANDLE_ALIGN
/* The last subsegment gets an aligment corresponding to the alignment
   of the section.  This allows proper nop-filling at the end of
   code-bearing sections.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
   ? get_recorded_alignment (SEG) : 0)
#else
d1407 1
a1407 1
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 0
d1409 1
a1409 2
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 2
#endif
d1420 1
a1420 1
      int alignment = 0;
d1427 1
a1427 9
      if (!had_errors ())
	{
	  alignment = SUB_SEGMENT_ALIGN (now_seg, frchainP);
#ifdef BFD_ASSEMBLER
	  if ((bfd_get_section_flags (now_seg->owner, now_seg) & SEC_MERGE)
	      && now_seg->entsize)
	    {
	      unsigned int entsize = now_seg->entsize;
	      int entalign = 0;
d1429 5
a1433 10
	      while ((entsize & 1) == 0)
		{
		  ++entalign;
		  entsize >>= 1;
		}
	      if (entalign > alignment)
		alignment = entalign;
	    }
#endif
	}
d1470 1
a1470 1
	  as_warn (_("%d error%s, %d warning%s, generating bad object file"),
d1477 1
a1477 1
	  as_fatal (_("%d error%s, %d warning%s, no object file generated"),
d1496 1
a1496 1
    asection **seclist;
d1500 1
a1500 1
    while (*seclist)
d1502 2
a1503 1
	if (*seclist == reg_section || *seclist == expr_section)
d1505 2
a1506 1
	    bfd_section_list_remove (stdoutput, seclist);
d1508 2
d1511 1
a1511 1
	else
d1536 2
a1537 39
  while (1)
    {
      int changed;

#ifndef WORKING_DOT_WORD
      /* We need to reset the markers in the broken word list and
	 associated frags between calls to relax_segment (via
	 relax_seg).  Since the broken word list is global, we do it
	 once per round, rather than locally in relax_segment for each
	 segment.  */
      struct broken_word *brokp;

      for (brokp = broken_words;
	   brokp != (struct broken_word *) NULL;
	   brokp = brokp->next_broken_word)
	{
	  brokp->added = 0;

	  if (brokp->dispfrag != (fragS *) NULL
	      && brokp->dispfrag->fr_type == rs_broken_word)
	    brokp->dispfrag->fr_subtype = 0;
	}
#endif

      changed = 0;
      bfd_map_over_sections (stdoutput, relax_seg, &changed);
      if (!changed)
	break;
    }

  /* Note - Most ports will use the default value of
     TC_FINALIZE_SYMS_BEFORE_SIZE_SEG, which 1.  This will force
     local symbols to be resolved, removing their frag information.
     Some ports however, will not have finished relaxing all of
     their frags and will still need the local symbol frag
     information.  These ports can set
     TC_FINALIZE_SYMS_BEFORE_SIZE_SEG to 0.  */
  finalize_syms = TC_FINALIZE_SYMS_BEFORE_SIZE_SEG;

d1543 6
a1548 5
  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;

#ifdef md_post_relax_hook
  md_post_relax_hook;
d1602 1
a1602 1
	    || ((offsetT) (fragP->fr_next->fr_address - fragP->fr_address)
d1697 3
d1716 3
d1836 2
a1837 2
    bfd_seek (stdoutput, (file_ptr) 0, 0);
    bfd_bwrite (the_object_file, (bfd_size_type) object_file_size, stdoutput);
d1861 1
a1861 1
	resolve_symbol_value (symp);
a1875 9
#ifdef tc_frob_file_before_fix
  tc_frob_file_before_fix ();
#endif
#ifdef obj_frob_file_before_fix
  obj_frob_file_before_fix ();
#endif

  bfd_map_over_sections (stdoutput, fix_segment, (char *) 0);

d1903 1
a1903 1
		as_bad (_("local label `%s' is not defined"), name2);
d1909 1
a1909 1
	  resolve_symbol_value (symp);
d1913 2
a1914 1
	  if (symbol_equated_reloc_p (symp))
d1946 2
a1947 3
	  if (symp == abs_section_sym
	      || (! EMIT_SECTION_SYMBOLS
		  && symbol_section_p (symp))
d1952 1
a1952 1
		  && (punt || S_IS_LOCAL (symp))
d1966 1
a1966 1
	      as_bad (_("can't resolve value for symbol `%s'"),
d2060 1
a2060 1
      know (S_GET_SEGMENT (symbolP) != absolute_section
d2062 1
a2062 1
      target += S_GET_VALUE (symbolP);
d2160 1
a2160 1
int
a2166 2
  int ret;

d2199 2
a2200 3
		as_bad_where (fragP->fr_file, fragP->fr_line,
			      _("alignment padding (%lu bytes) not a multiple of %ld"),
			      (unsigned long) offset, (long) fragP->fr_var);
a2213 6
	  /* If fr_symbol is an expression, this call to
	     resolve_symbol_value sets up the correct segment, which will
	     likely be needed in md_estimate_size_before_relax.  */
	  if (fragP->fr_symbol)
	    resolve_symbol_value (fragP->fr_symbol);

d2300 2
a2301 1
		      offset = (S_GET_VALUE (lie->add)
d2303 2
a2304 1
				- S_GET_VALUE (lie->sub));
d2311 4
a2314 5
			      as_warn_where (fragP->fr_file, fragP->fr_line,
					     _(".word %s-%s+%s didn't fit"),
					     S_GET_NAME (lie->add),
					     S_GET_NAME (lie->sub),
					     buf);
d2379 3
a2381 7
                      /* Convert from an actual address to an octet offset
                         into the section.  Here it is assumed that the
                         section's VMA is zero, and can omit subtracting it
                         from the symbol's value to get the address offset.  */
                      know (S_GET_SECTION (symbolP)->vma == 0);
		      target += S_GET_VALUE (symbolP) * OCTETS_PER_BYTE;
		    }
d2392 1
a2392 1
				    _("attempt to .org backwards"));
a2408 1
		growth = 0;
d2411 2
a2412 4
		    offsetT amount;

		    amount = S_GET_VALUE (symbolP);
		    if (S_GET_SEGMENT (symbolP) != absolute_section
d2415 4
d2420 2
a2421 10
			as_bad_where (fragP->fr_file, fragP->fr_line,
				      _(".space specifies non-absolute value"));
			/* Prevent repeat of this error message.  */
			fragP->fr_symbol = 0;
		      }
		    else if (amount < 0)
		      {
			as_warn_where (fragP->fr_file, fragP->fr_line,
				       _(".space or .fill with negative value, ignored"));
			fragP->fr_symbol = 0;
a2422 3
		    else
		      growth = (was_address + fragP->fr_fix + amount
				- fragP->fr_next->fr_address);
d2424 2
d2445 1
a2445 1
		  value = resolve_symbol_value (fragP->fr_symbol);
d2474 4
a2477 8
  ret = 0;
  for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
    if (fragP->last_fr_address != fragP->fr_address)
      {
	fragP->last_fr_address = fragP->fr_address;
	ret = 1;
      }
  return ret;
d2482 4
d2491 1
a2491 1
   For each one, call md_apply_fix3 to put the fix into the frag data.
d2498 3
a2500 3
fixup_segment (fixP, this_segment)
     fixS *fixP;
     segT this_segment;
d2503 2
d2506 4
a2512 9
  if (fixP != NULL && abs_section_sym == NULL)
    {
#ifndef BFD_ASSEMBLER
      abs_section_sym = &abs_symbol;
#else
      abs_section_sym = section_symbol (absolute_section);
#endif
    }

d2515 6
a2520 5
     Well, strictly speaking that's not true -- we could do any that
     are PC-relative and don't cross regions that could change size.
     And for the i960 we might be able to turn callx/callj into bal
     anyways in cases where we know the maximum displacement.  */
  if (linkrelax && TC_LINKRELAX_FIXUP (this_segment))
d2523 1
a2523 15
	if (!fixP->fx_done)
	  {
	    if (fixP->fx_addsy == NULL)
	      {
		/* There was no symbol required by this relocation.
		   However, BFD doesn't really handle relocations
		   without symbols well. So fake up a local symbol in
		   the absolute section.  */
		fixP->fx_addsy = abs_section_sym;
	      }
	    symbol_mark_used_in_reloc (fixP->fx_addsy);
	    if (fixP->fx_subsy != NULL)
	      symbol_mark_used_in_reloc (fixP->fx_subsy);
	    seg_reloc_count++;
	  }
d2537 4
d2542 1
a2542 1
      TC_VALIDATE_FIX (fixP, this_segment, skip);
d2544 1
d2546 2
d2549 2
a2550 2
      if (fixP->fx_addsy != NULL
	  && symbol_mri_common_p (fixP->fx_addsy))
d2552 2
a2553 2
	  know (fixP->fx_addsy->sy_value.X_op == O_symbol);
	  add_number += S_GET_VALUE (fixP->fx_addsy);
d2555 2
a2556 2
	  fixP->fx_addsy
	    = symbol_get_value_expression (fixP->fx_addsy)->X_add_symbol;
d2559 2
a2560 2
      if (fixP->fx_addsy != NULL)
	add_symbol_segment = S_GET_SEGMENT (fixP->fx_addsy);
d2562 1
a2562 1
      if (fixP->fx_subsy != NULL)
d2564 2
a2565 6
	  segT sub_symbol_segment;
	  resolve_symbol_value (fixP->fx_subsy);
	  sub_symbol_segment = S_GET_SEGMENT (fixP->fx_subsy);
	  if (fixP->fx_addsy != NULL
	      && sub_symbol_segment == add_symbol_segment
	      && !TC_FORCE_RELOCATION_SUB_SAME (fixP, add_symbol_segment))
d2567 24
a2590 15
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = add_number;
	      /* If the back-end code has selected a pc-relative
		 reloc, adjust the value to be pc-relative.  */
	      if (1
#ifdef TC_M68K
		  /* See the comment below about 68k weirdness.  */
		  && 0
#endif
		  && fixP->fx_pcrel)
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment); 
	      fixP->fx_addsy = NULL;
	      fixP->fx_subsy = NULL;
	      fixP->fx_pcrel = 0;
d2592 2
a2593 2
	  else if (sub_symbol_segment == absolute_section
		   && !TC_FORCE_RELOCATION_SUB_ABS (fixP))
d2595 25
a2619 3
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_subsy = NULL;
d2621 1
a2621 2
	  else if (sub_symbol_segment == this_segment
		   && !TC_FORCE_RELOCATION_SUB_LOCAL (fixP))
d2623 55
a2677 28
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = (add_number + fixP->fx_dot_value
				 + fixP->fx_frag->fr_address);

	      /* Make it pc-relative.  If the back-end code has not
		 selected a pc-relative reloc, cancel the adjustment
		 we do later on all pc-relative relocs.  */
	      if (0
#ifdef TC_M68K
		  /* Do this for m68k even if it's already described
		     as pc-relative.  On the m68k, an operand of
		     "pc@@(foo-.-2)" should address "foo" in a
		     pc-relative mode.  */
		  || 1
#endif
		  || !fixP->fx_pcrel)
		add_number += MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_subsy = NULL;
	      fixP->fx_pcrel = 1;
	    }
	  else if (!TC_VALIDATE_FIX_SUB (fixP))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("can't resolve `%s' {%s section} - `%s' {%s section}"),
			    fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : "0",
			    segment_name (add_symbol_segment),
			    S_GET_NAME (fixP->fx_subsy),
			    segment_name (sub_symbol_segment));
d2681 1
a2681 1
      if (fixP->fx_addsy)
d2683 2
a2684 2
	  if (add_symbol_segment == this_segment
	      && !TC_FORCE_RELOCATION_LOCAL (fixP))
d2689 22
a2710 6
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      fixP->fx_offset = add_number;
	      if (fixP->fx_pcrel)
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_addsy = NULL;
	      fixP->fx_pcrel = 0;
d2712 1
a2712 2
	  else if (add_symbol_segment == absolute_section
		   && !TC_FORCE_RELOCATION_ABS (fixP))
d2714 20
a2733 5
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_addsy = NULL;
	    }
	  else if (add_symbol_segment != undefined_section
d2735 1
a2735 1
		   && ! bfd_is_com_section (add_symbol_segment)
d2737 32
a2768 2
		   && MD_APPLY_SYM_VALUE (fixP))
	    add_number += S_GET_VALUE (fixP->fx_addsy);
d2771 1
a2771 1
      if (fixP->fx_pcrel)
d2773 2
a2774 2
	  add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	  if (!fixP->fx_done && fixP->fx_addsy == NULL)
d2776 7
a2782 5
	      /* There was no symbol required by this relocation.
		 However, BFD doesn't really handle relocations
		 without symbols well. So fake up a local symbol in
		 the absolute section.  */
	      fixP->fx_addsy = abs_section_sym;
d2787 10
a2796 1
	md_apply_fix3 (fixP, &add_number, this_segment);
d2798 7
a2804 8
      if (!fixP->fx_done)
	{
	  ++seg_reloc_count;
	  if (fixP->fx_addsy == NULL)
	    fixP->fx_addsy = abs_section_sym;
	  symbol_mark_used_in_reloc (fixP->fx_addsy);
	  if (fixP->fx_subsy != NULL)
	    symbol_mark_used_in_reloc (fixP->fx_subsy);
d2807 1
a2807 1
      if (!fixP->fx_bit_fixP && !fixP->fx_no_overflow && fixP->fx_size != 0)
d2809 1
a2809 1
	  if (fixP->fx_size < sizeof (valueT))
d2815 1
a2815 1
	      mask <<= fixP->fx_size * 8 - (fixP->fx_signed ? 1 : 0);
d2819 1
a2819 1
		  sprint_value (buf, fragP->fr_address + fixP->fx_where);
d2825 2
a2826 2
				_("value of %s too large for field of %d bytes at %s"),
				buf2, fixP->fx_size, buf);
d2834 1
a2834 1
	      && fixP->fx_size == 2
d2837 1
a2837 1
			  _("signed .word overflow; switch may be too large; %ld at 0x%lx"),
d2839 1
a2839 1
			  (long) (fragP->fr_address + fixP->fx_where));
d2865 1
a2865 1
  if (n <= 0)
d2880 1
a2880 1
  if (n <= 0)
@


1.1.1.9
log
@Binutils 2.15, with testsuites removed, and without gdb and libiberty.
@
text
@d115 1
a115 1
void print_fixup (fixS *);
d118 1
a118 1
static void renumber_sections (bfd *, asection *, PTR);
d160 4
a163 4
static fixS *fix_new_internal (fragS *, int where, int size,
			       symbolS *add, symbolS *sub,
			       offsetT offset, int pcrel,
			       RELOC_ENUM r_type);
d165 1
a165 1
static long fixup_segment (fixS *, segT);
d167 1
a167 1
static relax_addressT relax_align (relax_addressT addr, int align);
d169 1
a169 1
static fragS *chain_frchains_together_1 (segT, struct frchain *);
d172 7
a178 7
static void chain_frchains_together (bfd *, segT, PTR);
static void cvt_frag_to_fill (segT, fragS *);
static void adjust_reloc_syms (bfd *, asection *, PTR);
static void fix_segment (bfd *, asection *, PTR);
static void write_relocs (bfd *, asection *, PTR);
static void write_contents (bfd *, asection *, PTR);
static void set_symtab (void);
d181 1
a181 1
static void merge_data_into_text (void);
d184 3
a186 3
static void cvt_frag_to_fill (object_headers *, segT, fragS *);
static void remove_subsegs (frchainS *, int, fragS **, fragS **);
static void relax_and_size_all_segments (void);
d192 10
a201 8
fix_new_internal (fragS *frag,		/* Which frag?  */
		  int where,		/* Where in that frag?  */
		  int size,		/* 1, 2, or 4 usually.  */
		  symbolS *add_symbol,	/* X_add_symbol.  */
		  symbolS *sub_symbol,	/* X_op_symbol.  */
		  offsetT offset,	/* X_add_number.  */
		  int pcrel,		/* TRUE if PC-relative relocation.  */
		  RELOC_ENUM r_type ATTRIBUTE_UNUSED /* Relocation type.  */)
d286 8
a293 7
fix_new (fragS *frag,		/* Which frag?  */
	 int where,			/* Where in that frag?  */
	 int size,			/* 1, 2, or 4 usually.  */
	 symbolS *add_symbol,	/* X_add_symbol.  */
	 offsetT offset,		/* X_add_number.  */
	 int pcrel,			/* TRUE if PC-relative relocation.  */
	 RELOC_ENUM r_type		/* Relocation type.  */)
d304 7
a310 6
fix_new_exp (fragS *frag,		/* Which frag?  */
	     int where,			/* Where in that frag?  */
	     int size,			/* 1, 2, or 4 usually.  */
	     expressionS *exp,		/* Expression.  */
	     int pcrel,			/* TRUE if PC-relative relocation.  */
	     RELOC_ENUM r_type		/* Relocation type.  */)
d379 2
a380 1
generic_force_reloc (fixS *fix)
d392 4
a395 1
append (char **charPP, char *fromP, unsigned long length)
d415 6
a420 5
record_alignment (/* Segment to which alignment pertains.  */
		  segT seg,
		  /* Alignment, as a power of 2 (e.g., 1 => 2-byte
		     boundary, 2 => 4-byte boundary, etc.)  */
		  int align)
d434 2
a435 1
get_recorded_alignment (segT seg)
d451 4
a454 1
renumber_sections (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, PTR countparg)
d467 3
a469 1
chain_frchains_together_1 (segT section, struct frchain *frchp)
d502 4
a505 3
chain_frchains_together (bfd *abfd ATTRIBUTE_UNUSED,
			 segT section,
			 PTR xxx ATTRIBUTE_UNUSED)
d526 5
a530 1
remove_subsegs (frchainS *head, int seg, fragS **root, fragS **last)
d542 3
a544 1
cvt_frag_to_fill (segT sec ATTRIBUTE_UNUSED, fragS *fragP)
d547 4
a550 1
cvt_frag_to_fill (object_headers *headersP, segT sec, fragS *fragP)
d649 1
a649 2
static void relax_seg (bfd *, asection *, PTR);

d651 4
a654 1
relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, PTR xxx)
d666 1
a666 2
static void size_seg (bfd *, asection *, PTR);

d668 4
a671 1
size_seg (bfd *abfd, asection *sec, PTR xxx ATTRIBUTE_UNUSED)
d784 4
a787 3
adjust_reloc_syms (bfd *abfd ATTRIBUTE_UNUSED,
		   asection *sec,
		   PTR xxx ATTRIBUTE_UNUSED)
d907 4
a910 3
fix_segment (bfd *abfd ATTRIBUTE_UNUSED,
	     asection *sec,
	     PTR xxx ATTRIBUTE_UNUSED)
d918 4
a921 1
write_relocs (bfd *abfd, asection *sec, PTR xxx ATTRIBUTE_UNUSED)
d941 2
a942 1
  relocs = (arelent **) xcalloc (n, sizeof (arelent *));
d1014 1
a1014 1
  relocs = (arelent **) xcalloc (n, sizeof (arelent *));
d1133 4
a1136 3
write_contents (bfd *abfd ATTRIBUTE_UNUSED,
		asection *sec,
		PTR xxx ATTRIBUTE_UNUSED)
d1139 1
a1139 1
  addressT offset = 0;
d1152 1
a1152 1
      addressT fill_size;
d1154 1
a1154 1
      offsetT count;
d1232 1
a1232 1
merge_data_into_text (void)
d1314 1
a1314 1
    addressT bss_vma;
d1349 1
a1349 1
set_symtab (void)
d1355 1
a1355 1
  extern PTR bfd_alloc (bfd *, bfd_size_type);
d1393 1
a1393 1
/* The last subsegment gets an alignment corresponding to the alignment
d1409 1
a1409 1
subsegs_finish (void)
d1462 1
a1462 1
write_object_file (void)
d2065 4
a2068 1
relax_frag (segT segment, fragS *fragP, long stretch)
d2074 1
a2074 1
  offsetT growth;
d2175 3
a2177 2
relax_align (register relax_addressT address,	/* Address now.  */
	     register int alignment	/* Alignment (binary).  */)
d2204 3
a2206 1
relax_segment (struct frag *segment_frag_root, segT segment)
d2297 1
a2297 1
    offsetT stretch;	/* May be any size, 0 or negative.  */
d2312 1
a2312 1
	    offsetT growth = 0;
d2447 1
a2447 1
				    _("attempt to move .org backwards"));
d2506 1
a2506 1
		  offsetT size;
d2561 3
a2563 1
fixup_segment (fixS *fixP, segT this_segment)
d2646 9
a2656 2
#ifdef TC_M68K
	      /* See the comment below about 68k weirdness.  */
a2657 1
#endif
d2809 4
a2812 1
number_to_chars_bigendian (char *buf, valueT val, int n)
d2824 4
a2827 1
number_to_chars_littleendian (char *buf, valueT val, int n)
d2839 2
a2840 1
write_print_statistics (FILE *file)
d2849 2
a2850 1
print_fixup (fixS *fixp)
@


