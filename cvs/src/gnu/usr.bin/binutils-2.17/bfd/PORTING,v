head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.24
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.18
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.20
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.12
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.16
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.14
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.10
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.8
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.6
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.4
	OPENBSD_5_0:1.1.1.1.0.2
	OPENBSD_5_0_BASE:1.1.1.1
	BINUTILS_2_17_RELEASE:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2011.04.24.20.14.41;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.04.24.20.14.41;	author miod;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@	Preliminary Notes on Porting BFD
	--------------------------------

The 'host' is the system a tool runs *on*.
The 'target' is the system a tool runs *for*, i.e.
a tool can read/write the binaries of the target.

Porting to a new host
---------------------
Pick a name for your host. Call that <host>.
(<host> might be sun4, ...)
Create a file hosts/<host>.mh.

Porting to a new target
-----------------------
Pick a name for your target. Call that <target>.
Call the name for your CPU architecture <cpu>.
You need to create <target>.c and config/<target>.mt,
and add a case for it to a case statements in bfd/configure.host and
bfd/config.bfd, which associates each canonical host type with a BFD
host type (used as the base of the makefile fragment names), and to the
table in bfd/configure.in which associates each target vector with
the .o files it uses.

config/<target>.mt is a Makefile fragment.
The following is usually enough:
DEFAULT_VECTOR=<target>_vec
SELECT_ARCHITECTURES=bfd_<cpu>_arch

See the list of cpu types in archures.c, or "ls cpu-*.c".
If your architecture is new, you need to add it to the tables
in bfd/archures.c, opcodes/configure.in, and binutils/objdump.c.

For more information about .mt and .mh files, see config/README.

The file <target>.c is the hard part.  It implements the
bfd_target <target>_vec, which includes pointers to
functions that do the actual <target>-specific methods.

Porting to a <target> that uses the a.out binary format
-------------------------------------------------------

In this case, the include file aout-target.h probaby does most
of what you need. The program gen-aout generates <target>.c for
you automatically for many a.out systems.  Do:
	make gen-aout
	./gen-aout <target> > <target>.c
(This only works if you are building on the target ("native").
If you must make a cross-port from scratch, copy the most
similar existing file that includes aout-target.h, and fix what is wrong.)

Check the parameters in <target>.c, and fix anything that is wrong.
(Also let us know about it; perhaps we can improve gen-aout.c.)

TARGET_IS_BIG_ENDIAN_P
	Should be defined if <target> is big-endian.

N_HEADER_IN_TEXT(x)
	See discussion in ../include/aout/aout64.h.

BYTES_IN_WORD
	Number of bytes per word. (Usually 4 but can be 8.)

ARCH
	Number of bits per word.  (Usually 32, but can be 64.)

ENTRY_CAN_BE_ZERO
	Define if the extry point (start address of an
	executable program) can be 0x0.

TEXT_START_ADDR
	The address of the start of the text segemnt in
	virtual memory.  Normally, the same as the entry point.

TARGET_PAGE_SIZE

SEGMENT_SIZE
        Usually, the same as the TARGET_PAGE_SIZE.
        Alignment needed for the data segment.

TARGETNAME
	The name of the target, for run-time lookups.
	Usually "a.out-<target>"
@


1.1.1.1
log
@Here comes the easter bunnytils 2.17 (the last version released against a
licence mere mortals can understand the terms of); will be connected to the
build on an arch-by-arch basis.

Testsuites and generated files have been intentionnaly omitted from this import.

Peer pressure and ok from at least drahn@@ pirofti@@ deraadt@@
@
text
@@
