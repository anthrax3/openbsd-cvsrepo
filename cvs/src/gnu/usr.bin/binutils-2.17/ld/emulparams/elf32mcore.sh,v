head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.28
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.26
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.24
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.18
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.20
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.12
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.16
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.14
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.10
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.8
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.6
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.4
	OPENBSD_5_0:1.1.1.1.0.2
	OPENBSD_5_0_BASE:1.1.1.1
	BINUTILS_2_17_RELEASE:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2011.04.24.20.14.49;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.04.24.20.14.49;	author miod;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@SCRIPT_NAME=elf
OUTPUT_FORMAT="elf32-mcore-little"
BIG_OUTPUT_FORMAT="elf32-mcore-big"
LITTLE_OUTPUT_FORMAT="elf32-mcore-little"
PAGE_SIZE=0x1000
TARGET_PAGE_SIZE=0x400
MAXPAGESIZE=0x1000
TEXT_START_ADDR=0
NONPAGED_TEXT_START_ADDR=0
ARCH=mcore
EMBEDDED=yes

# There is a problem with the NOP value - it must work for both
# big endian and little endian systems.  Unfortunately there is
# no symmetrical mcore opcode that functions as a noop.  The
# chosen solution is to use "tst r0, r14".  This is a symetrical
# value, and apart from the corruption of the C bit, it has no other
# side effects.  Since the carry bit is never tested without being
# explicitly set first, and since the NOP code is only used as a
# fill value between independantly viable peices of code, it should
# not matter.
NOP=0x0e0e0e0e

OTHER_BSS_SYMBOLS="__bss_start__ = . ;"
OTHER_BSS_END_SYMBOLS="__bss_end__ = . ;"

# This sets the stack to the top of the simulator memory (2^19 bytes).
STACK_ADDR=0x80000

TEMPLATE_NAME=elf32
GENERATE_SHLIB_SCRIPT=yes

# This code gets inserted into the generic elf32.sc linker script
# and allows us to define our own command line switches.
PARSE_AND_LIST_PROLOGUE='
#define OPTION_BASE_FILE		300
'

PARSE_AND_LIST_LONGOPTS='
  {"base-file", required_argument, NULL, OPTION_BASE_FILE},
'

PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("  --base_file <basefile>\n"));
  fprintf (file, _("\t\t\tGenerate a base file for relocatable DLLs\n"));
'

PARSE_AND_LIST_ARGS_CASES='
    case OPTION_BASE_FILE:
      link_info.base_file = fopen (optarg, FOPEN_WB);
      if (link_info.base_file == NULL)
	{
	  /* xgettext:c-format */
	  fprintf (stderr, _("%s: Cannot open base file %s\n"),
		   program_name, optarg);
	  xexit (1);
	}
      break;
'
@


1.1.1.1
log
@Here comes the easter bunnytils 2.17 (the last version released against a
licence mere mortals can understand the terms of); will be connected to the
build on an arch-by-arch basis.

Testsuites and generated files have been intentionnaly omitted from this import.

Peer pressure and ok from at least drahn@@ pirofti@@ deraadt@@
@
text
@@
