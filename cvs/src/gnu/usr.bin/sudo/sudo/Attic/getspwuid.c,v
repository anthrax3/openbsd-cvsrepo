head	1.11;
access;
symbols
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.11
date	99.11.18.16.39.34;	author millert;	state dead;
branches;
next	1.10;

1.10
date	99.03.29.20.29.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.02.19.04.32.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.11.21.01.34.52;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.11.13.22.44.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.09.15.02.42.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.03.31.06.40.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.01.13.05.30.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.23.07.15.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.11.17.16.33.57;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.10.14.05.14.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove old GPL'd sudo
@
text
@/*	$OpenBSD: getspwuid.c,v 1.10 1999/03/29 20:29:03 millert Exp $	*/

/*
 *  CU sudo version 1.5.9
 *  Copyright (c) 1996, 1998, 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 1, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  Please send bugs, changes, problems to sudo-bugs@@courtesan.com
 *
 *******************************************************************
 *
 *  This module contains sudo_getpwuid(), a function that
 *  Makes a dynamic copy of the struct passwd returned by
 *  getpwuid() and substitutes the shadow password if
 *  necesary.
 *
 *  Todd C. Miller  Mon Nov 20 13:53:06 MST 1995
 */

#include "config.h"

#include <stdio.h>
#ifdef STDC_HEADERS
#include <stdlib.h>
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <netinet/in.h>
#include <pwd.h>
#ifdef HAVE_GETSPNAM
#  include <shadow.h>
#endif /* HAVE_GETSPNAM */
#ifdef HAVE_GETPRPWNAM
#  ifdef __hpux
#    include <hpsecurity.h>
#  else
#    include <sys/security.h>
#  endif /* __hpux */
#  include <prot.h>
#endif /* HAVE_GETPRPWNAM */
#ifdef HAVE_GETPWANAM
#  include <sys/label.h>
#  include <sys/audit.h>
#  include <pwdadj.h>
#endif /* HAVE_GETPWANAM */
#ifdef HAVE_GETAUTHUID
#  include <auth.h>
#endif /* HAVE_GETAUTHUID */

#include "sudo.h"

#ifndef lint
static const char rcsid[] = "$Sudo: getspwuid.c,v 1.45 1999/03/29 04:05:08 millert Exp $";
#endif /* lint */

#ifndef STDC_HEADERS
extern char *getenv     __P((const char *));
#endif /* !STDC_HEADERS */

/*
 * Global variables (yuck)
 */
#if defined(HAVE_GETPRPWNAM) && defined(__alpha)
int crypt_type = INT_MAX;
#endif /* HAVE_GETPRPWNAM && __alpha */


/*
 * Local functions not visible outside getspwuid.c
 */
static char *sudo_getshell	__P((struct passwd *));
static char *sudo_getepw	__P((struct passwd *));



/**********************************************************************
 *
 * sudo_getshell()
 *
 *  This function returns the user's shell based on either the
 *  SHELL evariable or the passwd(5) entry (in that order).
 */

static char *sudo_getshell(pw)
    struct passwd *pw;
{
    char *pw_shell;

    if ((pw_shell = getenv("SHELL")) == NULL)
	pw_shell = pw -> pw_shell;

#ifdef _PATH_BSHELL
    /* empty string "" means bourne shell */
    if (*pw_shell == '\0')
	pw_shell = _PATH_BSHELL;
#endif /* _PATH_BSHELL */

    return(pw_shell);
}


/**********************************************************************
 *
 *  sudo_getepw()
 *
 *  This function returns the encrypted password for the user described
 *  by pw.  If there is a shadow password it is returned, else the
 *  normal UN*X password is returned instead.
 */

static char *sudo_getepw(pw)
    struct passwd *pw;
{

    /* if there is a function to check for shadow enabled, use it... */
#ifdef HAVE_ISCOMSEC
    if (!iscomsec())
	return(pw->pw_passwd);
#endif /* HAVE_ISCOMSEC */
#ifdef HAVE_ISSECURE
    if (!issecure())
	return(pw->pw_passwd);
#endif /* HAVE_ISSECURE */

#ifdef HAVE_GETPRPWNAM
    {
	struct pr_passwd *spw;

	spw = getprpwnam(pw->pw_name);
	if (spw != NULL && spw->ufld.fd_encrypt != NULL) {
#  ifdef __alpha
	    crypt_type = spw -> ufld.fd_oldcrypt;
#  endif /* __alpha */
	    return(spw -> ufld.fd_encrypt);
	}
    }
#endif /* HAVE_GETPRPWNAM */
#ifdef HAVE_GETSPNAM
    {
	struct spwd *spw;

	if ((spw = getspnam(pw -> pw_name)) && spw -> sp_pwdp)
	    return(spw -> sp_pwdp);
    }
#endif /* HAVE_GETSPNAM */
#ifdef HAVE_GETSPWUID
    {
	struct s_passwd *spw;

	if ((spw = getspwuid(pw -> pw_uid)) && spw -> pw_passwd)
	    return(spw -> pw_passwd);
    }
#endif /* HAVE_GETSPWUID */
#ifdef HAVE_GETPWANAM
    {
	struct passwd_adjunct *spw;

	if ((spw = getpwanam(pw -> pw_name)) && spw -> pwa_passwd)
	    return(spw -> pwa_passwd);
    }
#endif /* HAVE_GETPWANAM */
#ifdef HAVE_GETAUTHUID
    {
	AUTHORIZATION *spw;

	if ((spw = getauthuid(pw -> pw_uid)) && spw -> a_password)
	    return(spw -> a_password);
    }
#endif /* HAVE_GETAUTHUID */

    /* Fall back on normal passwd */
    return(pw->pw_passwd);
}


/**********************************************************************
 *
 *  sudo_getpwuid()
 *
 *  This function dynamically allocates space for a struct password
 *  and the constituent parts that we care about.  If shadow passwords
 *  are in use, it substitutes the shadow password for pw_passwd.
 */

struct passwd *sudo_getpwuid(uid)
    uid_t uid;
{
    struct passwd *pw, *local_pw;

    if ((pw = getpwuid(uid)) == NULL)
	return(NULL);

    /* allocate space for a local copy of pw */
    local_pw = (struct passwd *) emalloc(sizeof(struct passwd));

    /*
     * Copy the struct passwd and the interesting strings...
     */
    (void) memcpy(local_pw, pw, sizeof(struct passwd));
    local_pw->pw_name = estrdup(pw->pw_name);
    local_pw->pw_dir = estrdup(pw->pw_dir);

    /* pw_shell is a special case since we overide with $SHELL */
    local_pw->pw_shell = estrdup(sudo_getshell(pw));

    /* pw_passwd gets a shadow password if applicable */
    local_pw->pw_passwd = estrdup(sudo_getepw(pw));

    return(local_pw);
}
@


1.10
log
@sudo 1.5.9--fixes some parser bugs
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.9
log
@sudo 1.5.8
@
text
@d4 1
a4 1
 *  CU sudo version 1.5.8
a38 3
#if defined(HAVE_MALLOC_H) && !defined(STDC_HEADERS)
#include <malloc.h>   
#endif /* HAVE_MALLOC_H && !STDC_HEADERS */
d73 1
a73 1
static const char rcsid[] = "$Sudo: getspwuid.c,v 1.43 1999/02/03 04:32:14 millert Exp $";
a76 3
#ifndef __GNUC__                /* gcc has its own malloc */
extern char *malloc     __P((size_t));
#endif /* __GNUC__ */
a77 3
#ifdef HAVE_STRDUP
extern char *strdup     __P((const char *));
#endif /* HAVE_STRDUP */
d214 1
a214 5
    local_pw = (struct passwd *) malloc(sizeof(struct passwd));
    if (local_pw == NULL) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }
d220 2
a221 12

    local_pw->pw_name = (char *) strdup(pw->pw_name);
    if (local_pw->pw_name == NULL) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }

    local_pw->pw_dir = (char *) strdup(pw->pw_dir);
    if (local_pw->pw_dir == NULL) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }
d224 1
a224 5
    local_pw->pw_shell = (char *) strdup(sudo_getshell(pw));
    if (local_pw->pw_shell == NULL) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }
d227 1
a227 5
    local_pw->pw_passwd = (char *) strdup(sudo_getepw(pw));
    if (local_pw->pw_passwd == NULL) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }
@


1.8
log
@sudo 1.5.7
@
text
@d4 2
a5 1
 *  CU sudo version 1.5.7
d76 1
a76 1
static const char rcsid[] = "$From: getspwuid.c,v 1.40 1998/11/18 04:16:13 millert Exp $";
@


1.7
log
@update to sudo 1.5.6p6
@
text
@d1 1
a1 1
/*	$OpenBSD: getspwuid.c,v 1.6 1998/09/15 02:42:44 millert Exp $	*/
d4 1
a4 1
 *  CU sudo version 1.5.6
a31 4
#ifndef lint
static char rcsid[] = "$From: getspwuid.c,v 1.29 1998/04/06 03:35:34 millert Exp $";
#endif /* lint */

d48 1
d52 20
d73 4
a76 22
#include <options.h>
#if (SHADOW_TYPE != SPW_NONE) && (SHADOW_TYPE != SPW_BSD)
#  if (SHADOW_TYPE == SPW_SVR4)
#    include <shadow.h>
#  endif /* SVR4 */
#  if (SHADOW_TYPE == SPW_SECUREWARE)
#    ifdef __hpux
#      include <hpsecurity.h>
#    else
#      include <sys/security.h>
#    endif /* __hpux */
#    include <prot.h>
#  endif /* SECUREWARE */
#  if (SHADOW_TYPE == SPW_ULTRIX4)
#    include <auth.h>
#  endif /* ULTRIX4 */
#  if (SHADOW_TYPE == SPW_SUNOS4)
#    include <sys/label.h>
#    include <sys/audit.h>
#    include <pwdadj.h>
#  endif /* SUNOS4 */
#endif /* SHADOW_TYPE != SPW_NONE && SHADOW_TYPE != SPW_BSD */
d91 3
a93 3
#if (SHADOW_TYPE == SPW_SECUREWARE) && defined(__alpha)
uchar_t crypt_type;
#endif /* SPW_SECUREWARE && __alpha */
d100 1
a100 1
static char *sudo_getspwd	__P((struct passwd *));
d112 2
a113 2
static char *sudo_getshell(pw_ent)
    struct passwd *pw_ent;
d118 1
a118 1
	pw_shell = pw_ent -> pw_shell;
d132 1
a132 1
 *  sudo_getspwd()
d134 3
a136 3
 *  This function returns the shadow password for the user described
 *  by pw_ent.  If there is no shadow password the normal UN*X password
 *  is returned instead.
d139 2
a140 4
static char *sudo_getspwd(pw_ent)
    struct passwd *pw_ent;
#if (SHADOW_TYPE != SPW_NONE) && (SHADOW_TYPE != SPW_BSD)
#  if (SHADOW_TYPE == SPW_SVR4)
a141 1
    struct spwd *spw_ent;
d143 34
a176 9
    if ((spw_ent = getspnam(pw_ent -> pw_name)) && spw_ent -> sp_pwdp)
	return(spw_ent -> sp_pwdp);
    else
	return(pw_ent -> pw_passwd);
}
#  endif /* SVR4 */
#  if (SHADOW_TYPE == SPW_HPUX9)
{
    struct s_passwd *spw_ent;
d178 7
a184 9
    if ((spw_ent = getspwuid(pw_ent -> pw_uid)) && spw_ent -> pw_passwd)
	return(spw_ent -> pw_passwd);
    else
	return(pw_ent -> pw_passwd);
}
#  endif /* HPUX9 */
#  if (SHADOW_TYPE == SPW_SUNOS4)
{
    struct passwd_adjunct *spw_ent;
d186 7
a192 9
    if ((spw_ent = getpwanam(pw_ent -> pw_name)) && spw_ent -> pwa_passwd)
	return(spw_ent -> pwa_passwd);
    else
	return(pw_ent -> pw_passwd);
}
#  endif /* SUNOS4 */
#  if (SHADOW_TYPE == SPW_ULTRIX4)
{
    AUTHORIZATION *spw_ent;
d194 4
a197 9
    if ((spw_ent = getauthuid(pw_ent -> pw_uid)) && spw_ent -> a_password)
	return(spw_ent -> a_password);
    else
	return(pw_ent -> pw_passwd);
}
#  endif /* ULTRIX4 */
#  if (SHADOW_TYPE == SPW_SECUREWARE)
{
    struct pr_passwd *spw_ent;
d199 2
a200 16
    if ((spw_ent = getprpwnam(pw_ent->pw_name)) && spw_ent->ufld.fd_encrypt) {
#    ifdef __alpha
	crypt_type = spw_ent -> ufld.fd_oldcrypt;
#      ifdef AUTH_CRYPT_C1CRYPT
        if (crypt_type == AUTH_CRYPT_C1CRYPT)
	    return(pw_ent -> pw_passwd);
#      endif /* AUTH_CRYPT_C1CRYPT */
#    endif /* __alpha */
	return(spw_ent -> ufld.fd_encrypt);
    } else
	return(pw_ent -> pw_passwd);
}
#  endif /* SECUREWARE */
#else
{
    return(pw_ent->pw_passwd);
a201 1
#endif /* SHADOW_TYPE != SPW_NONE && SHADOW_TYPE != SPW_BSD */
d216 1
a216 1
    struct passwd *pw_ent, *local_pw_ent;
d218 1
a218 1
    if ((pw_ent = getpwuid(uid)) == NULL)
d221 3
a223 4
    /* allocate space for a local copy of pw_ent */
    local_pw_ent = (struct passwd *) malloc(sizeof(struct passwd));
    if (local_pw_ent == NULL) {
	perror("malloc");
d231 1
a231 1
    (void) memcpy(local_pw_ent, pw_ent, sizeof(struct passwd));
d233 2
a234 3
    local_pw_ent->pw_name = (char *) strdup(pw_ent->pw_name);
    if (local_pw_ent->pw_name == NULL) {
	perror("malloc");
d239 2
a240 3
    local_pw_ent->pw_dir = (char *) strdup(pw_ent->pw_dir);
    if (local_pw_ent->pw_dir == NULL) {
	perror("malloc");
d246 2
a247 3
    local_pw_ent->pw_shell = (char *) strdup(sudo_getshell(pw_ent));
    if (local_pw_ent->pw_shell == NULL) {
	perror("malloc");
d253 2
a254 3
    local_pw_ent->pw_passwd = (char *) strdup(sudo_getspwd(pw_ent));
    if (local_pw_ent->pw_passwd == NULL) {
	perror("malloc");
d259 1
a259 1
    return(local_pw_ent);
@


1.6
log
@sudo 1.5.6
@
text
@d1 1
a1 1
/*	$OpenBSD: getspwuid.c,v 1.5 1998/03/31 06:40:54 millert Exp $	*/
d187 1
a187 1
    if ((spw_ent = getprpwuid(pw_ent->pw_uid)) && spw_ent->ufld.fd_encrypt) {
@


1.5
log
@sudo 1.5.5
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 *  CU sudo version 1.5.5
d33 1
a33 1
static char rcsid[] = "Id: getspwuid.c,v 1.28 1998/03/31 05:05:32 millert Exp $";
@


1.4
log
@sudo 1.5.4
@
text
@d4 1
a4 1
 *  CU sudo version 1.5.4
d33 1
a33 1
static char rcsid[] = "Id: getspwuid.c,v 1.22 1998/01/13 04:48:17 millert Exp $";
@


1.3
log
@OpenBSD tags (and preserve sudo tags)
updates from my sudo source tree:
    logging.c: deal with maxfilelen < 0 case
    sudo.c: correct error message if mode/owner wrong and not statable by owner
    compat.h: fix seteuid macro
@
text
@d4 1
a4 1
 *  CU sudo version 1.5.3
d33 1
a33 1
static char rcsid[] = "Id: getspwuid.c,v 1.21 1996/11/14 02:37:16 millert Exp $";
@


1.2
log
@Updated to sudo 1.5.3
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: getspwuid.c,v 1.21 1996/11/14 02:37:16 millert Exp $";
@


1.1
log
@sudo 1.5.2
@
text
@d2 1
a2 1
 *  CU sudo version 1.5.2
d31 1
a31 1
static char rcsid[] = "$Id: getspwuid.c,v 1.20 1996/10/07 05:05:33 millert Exp $";
@
