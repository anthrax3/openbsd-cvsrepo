head	1.11;
access;
symbols
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.11
date	99.11.18.16.39.34;	author millert;	state dead;
branches;
next	1.10;

1.10
date	99.03.29.20.29.02;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.02.19.04.32.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.11.21.01.34.52;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.11.13.22.44.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.09.15.02.42.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.03.31.06.40.53;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.01.13.05.30.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.23.07.15.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.11.17.16.33.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.10.14.05.14.45;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove old GPL'd sudo
@
text
@/*	$OpenBSD: find_path.c,v 1.10 1999/03/29 20:29:02 millert Exp $	*/

/*
 *  CU sudo version 1.5.9
 *  Copyright (c) 1996, 1998, 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 1, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  Please send bugs, changes, problems to sudo-bugs@@courtesan.com
 *
 *******************************************************************
 *
 *  This module contains the find_path() function that returns
 *  TRUE if the command was found and FALSE if not.
 *  If find_path() returns TRUE, the copyin paramters command and
 *  ocommand contain the resolved and unresolved pathnames respectively.
 *  NOTE: if "." or "" exists in PATH it will be searched last.
 *
 *  Todd C. Miller <Todd.Miller@@courtesan.com> Sat Mar 25 21:50:36 MST 1995
 */

#include "config.h"

#include <stdio.h>
#ifdef STDC_HEADERS
#include <stdlib.h>
#endif /* STDC_HEADERS */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* HAVE_UNISTD_H */
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
#include <errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include "sudo.h"

#ifndef STDC_HEADERS
extern char *getenv	__P((const char *));
extern char *strcpy	__P((char *, const char *));
extern int fprintf	__P((FILE *, const char *, ...));
extern ssize_t readlink	__P((const char *, VOID *, size_t));
extern int stat		__P((const char *, struct stat *));
extern int lstat	__P((const char *, struct stat *));
#endif /* !STDC_HEADERS */

#ifndef _S_IFMT
#define _S_IFMT		S_IFMT
#endif /* _S_IFMT */
#ifndef _S_IFLNK
#define _S_IFLNK	S_IFLNK
#endif /* _S_IFLNK */

#ifndef lint
static const char rcsid[] = "$Sudo: find_path.c,v 1.85 1999/03/29 04:05:08 millert Exp $";
#endif /* lint */

/*******************************************************************
 *
 *  find_path()
 *
 *  this function finds the full pathname for a command and
 *  stores it in a statically allocated array, filling in a pointer
 *  to the array.  Returns FOUND if the command was found, NOT_FOUND
 *  if it was not found, or NOT_FOUND_DOT if it would have been found
 *  but it is in '.' and IGNORE_DOT_PATH is in effect.
 */

int find_path(infile, outfile)
    char *infile;		/* file to find */
    char **outfile;		/* result parameter */
{
    static char command[MAXPATHLEN]; /* qualified filename */
    register char *n;		/* for traversing path */
    char *path = NULL;		/* contents of PATH env var */
    char *origpath;		/* so we can free path later */
    char *result = NULL;	/* result of path/file lookup */
    int checkdot = 0;		/* check current dir? */

    command[0] = '\0';

    if (strlen(infile) >= MAXPATHLEN) {
	errno = ENAMETOOLONG;
	(void) fprintf(stderr, "%s: path too long: %s\n", Argv[0], infile);
	exit(1);
    }

    /*
     * If we were given a fully qualified or relative path
     * there is no need to look at PATH.
     */
    if (strchr(infile, '/')) {
	(void) strcpy(command, infile);
	if (sudo_goodpath(command)) {
	    *outfile = command;
	    return(FOUND);
	} else
	    return(NOT_FOUND);
    }

    /*
     * grab PATH out of environment and make a local copy
     */
    if ((path = getenv("PATH")) == NULL)
	return(NOT_FOUND);

    path = estrdup(path);
    origpath = path;

    /* XXX use strtok() */
    do {
	if ((n = strchr(path, ':')))
	    *n = '\0';

	/*
	 * search current dir last if it is in PATH This will miss sneaky
	 * things like using './' or './/' 
	 */
	if (*path == '\0' || (*path == '.' && *(path + 1) == '\0')) {
	    checkdot = 1;
	    path = n + 1;
	    continue;
	}

	/*
	 * resolve the path and exit the loop if found
	 */
	if (strlen(path) + strlen(infile) + 1 >= MAXPATHLEN) {
	    (void) fprintf(stderr, "%s: path too long: %s\n", Argv[0], infile);
	    exit(1);
	}
	(void) sprintf(command, "%s/%s", path, infile);
	if ((result = sudo_goodpath(command)))
	    break;

	path = n + 1;

    } while (n);
    (void) free(origpath);

    /*
     * Check current dir if dot was in the PATH
     */
    if (!result && checkdot) {
	result = sudo_goodpath(infile);
#ifdef IGNORE_DOT_PATH
	if (result)
	    return(NOT_FOUND_DOT);
#endif /* IGNORE_DOT_PATH */
    }

    if (result) {
	*outfile = result;
	return(FOUND);
    } else
	return(NOT_FOUND);
}
@


1.10
log
@sudo 1.5.9--fixes some parser bugs
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.9
log
@sudo 1.5.8
@
text
@d4 1
a4 1
 *  CU sudo version 1.5.8
d31 1
a31 1
 *  Todd C. Miller (millert@@colorado.edu) Sat Mar 25 21:50:36 MST 1995
a48 3
#if defined(HAVE_MALLOC_H) && !defined(STDC_HEADERS)
#include <malloc.h>
#endif /* HAVE_MALLOC_H && !STDC_HEADERS */
a56 3
#ifndef __GNUC__		/* gcc has its own malloc */
extern char *malloc	__P((size_t));
#endif /* __GNUC__ */
a62 3
#ifdef HAVE_STRDUP
extern char *strdup	__P((const char *));
#endif /* HAVE_STRDUP */
d73 1
a73 1
static const char rcsid[] = "$Sudo: find_path.c,v 1.83 1999/02/03 04:32:14 millert Exp $";
d125 1
a125 4
    if ((path = (char *) strdup(path)) == NULL) {
	(void) fprintf(stderr, "%s: out of memory!\n", Argv[0]);
	exit(1);
    }
@


1.8
log
@sudo 1.5.7
@
text
@d4 2
a5 1
 *  CU sudo version 1.5.7
d82 1
a82 1
static const char rcsid[] = "$From: find_path.c,v 1.80 1998/11/18 04:16:13 millert Exp $";
@


1.7
log
@update to sudo 1.5.6p6
@
text
@d1 1
a1 1
/*	$OpenBSD: find_path.c,v 1.6 1998/09/15 02:42:44 millert Exp $	*/
d4 1
a4 1
 *  CU sudo version 1.5.6
a32 4
#ifndef lint
static char rcsid[] = "$From: find_path.c,v 1.74 1998/04/06 03:35:34 millert Exp $";
#endif /* lint */

a56 1
#include <options.h>
a72 1

d80 3
d89 4
a92 2
 *  stores it in a statically allocated array, returning a pointer
 *  to the array.
d95 3
a97 2
char * find_path(file)
    char *file;			/* file to find */
a103 1
#ifndef IGNORE_DOT_PATH
a104 1
#endif /* IGNORE_DOT_PATH */
d108 1
a108 1
    if (strlen(file) >= MAXPATHLEN) {
d110 1
a110 1
	(void) fprintf(stderr, "%s:  path too long:  %s\n", Argv[0], file);
d118 7
a124 3
    if (strchr(file, '/')) {
	(void) strcpy(command, file);
	return(sudo_goodpath(command));
d131 1
a131 1
	return(NULL);
d137 1
a137 1
    origpath=path;
a148 1
#ifndef IGNORE_DOT_PATH
a149 1
#endif /* IGNORE_DOT_PATH */
d157 2
a158 2
	if (strlen(path) + strlen(file) + 1 >= MAXPATHLEN) {
	    (void) fprintf(stderr, "%s:  path too long:  %s\n", Argv[0], file);
d161 1
a161 1
	(void) sprintf(command, "%s/%s", path, file);
d168 1
a169 1
#ifndef IGNORE_DOT_PATH
d171 1
a171 1
     * check current dir if dot was in the PATH
d173 5
a177 2
    if (!result && checkdot)
	result = sudo_goodpath(file);
d179 1
d181 5
a185 3
    (void) free(origpath);

    return(result);
@


1.6
log
@sudo 1.5.6
@
text
@d1 1
a1 1
/*	$OpenBSD: find_path.c,v 1.5 1998/03/31 06:40:53 millert Exp $	*/
a118 2
     * We really want to fall back if !sudo_goodpath() but then
     * the error is "not found" -- this way we get the correct error.
d122 1
a122 7
	if (sudo_goodpath(command)) {
	    return(command);
	} else {
	    (void) fprintf(stderr, "%s: %s: ", Argv[0], command);
	    perror("");
	    exit(1);
	}
@


1.5
log
@sudo 1.5.5
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 *  CU sudo version 1.5.5
d34 1
a34 1
static char rcsid[] = "Id: find_path.c,v 1.72 1998/03/31 05:05:31 millert Exp $";
d99 1
a99 1
    static char command[MAXPATHLEN + 1];	/* qualified filename */
d110 1
a110 1
    if (strlen(file) > MAXPATHLEN) {
@


1.4
log
@sudo 1.5.4
@
text
@d4 1
a4 1
 *  CU sudo version 1.5.4
d34 1
a34 1
static char rcsid[] = "Id: find_path.c,v 1.66 1998/01/13 04:48:17 millert Exp $";
@


1.3
log
@OpenBSD tags (and preserve sudo tags)
updates from my sudo source tree:
    logging.c: deal with maxfilelen < 0 case
    sudo.c: correct error message if mode/owner wrong and not statable by owner
    compat.h: fix seteuid macro
@
text
@d4 1
a4 1
 *  CU sudo version 1.5.3
d34 1
a34 1
static char rcsid[] = "Id: find_path.c,v 1.65 1996/11/14 02:37:16 millert Exp $";
@


1.2
log
@Updated to sudo 1.5.3
@
text
@d1 2
d34 1
a34 1
static char rcsid[] = "$Id: find_path.c,v 1.65 1996/11/14 02:37:16 millert Exp $";
@


1.1
log
@sudo 1.5.2
@
text
@d2 1
a2 1
 *  CU sudo version 1.5.2
d32 1
a32 1
static char rcsid[] = "$Id: find_path.c,v 1.63 1996/10/07 05:05:33 millert Exp $";
d163 1
a163 2
	if (strlen(path) + strlen(file) >= MAXPATHLEN) {
	    errno = ENAMETOOLONG;
@
