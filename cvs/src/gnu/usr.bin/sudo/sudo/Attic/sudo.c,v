head	1.15;
access;
symbols
	OPENBSD_2_6:1.14.0.4
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.15
date	99.11.18.16.39.35;	author millert;	state dead;
branches;
next	1.14;

1.14
date	99.03.30.06.25.25;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.03.29.20.29.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.02.19.04.32.51;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.11.21.01.34.53;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.09.15.02.42.45;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.06.27.20.21.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.03.31.06.41.11;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.01.13.05.30.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.12.21.23.15.06;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.11.23.07.15.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.11.23.06.54.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.04.12.07.18.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.11.17.16.34.04;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.10.14.05.14.54;	author millert;	state Exp;
branches;
next	;


desc
@@


1.15
log
@remove old GPL'd sudo
@
text
@/*	$OpenBSD: sudo.c,v 1.14 1999/03/30 06:25:25 millert Exp $	*/

/*
 * CU sudo version 1.5.9 (based on Root Group sudo version 1.1)
 * Copyright (c) 1994,1996,1998,1999 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * This software comes with no waranty whatsoever, use at your own risk.
 *
 * Please send bugs, changes, problems to sudo-bugs@@courtesan.com
 *
 */

/*
 *  sudo version 1.1 allows users to execute commands as root
 *  Copyright (C) 1991  The Root Group, Inc.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 1, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 **************************************************************************
 *
 *   sudo.c
 *
 *   This is the main() routine for sudo
 *
 *   sudo is a program to allow users to execute commands 
 *   as root.  The commands are defined in a global network-
 *   wide file and can be distributed.
 *
 *   sudo has been hacked far and wide.  Too many people to
 *   know about.  It's about time to come up with a secure
 *   version that will work well in a network.
 *
 *   This most recent version is done by:
 *
 *              Jeff Nieusma <nieusma@@rootgroup.com>
 *              Dave Hieb    <davehieb@@rootgroup.com>
 *
 *   However, due to the fact that both of the above are no longer
 *   working at Root Group, I am maintaining the "CU version" of
 *   sudo.
 *		Todd Miller  <Todd.Miller@@courtesan.com>
 */

#define MAIN

#include "config.h"

#include <stdio.h>
#ifdef STDC_HEADERS
#include <stdlib.h>
#endif /* STDC_HEADERS */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* HAVE_UNISTD_H */
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
#include <pwd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <netinet/in.h>
#include <netdb.h>
#ifdef HAVE_DCE
#include <pthread.h>
#endif /* HAVE_DCE */
#ifdef HAVE_KERB5
#include <krb5.h>
#endif /* HAVE_KERB5 */

#include "sudo.h"
#include "version.h"

#ifndef STDC_HEADERS
extern char *getenv	__P((char *));
#endif /* STDC_HEADERS */

#ifndef lint
static const char rcsid[] = "$Sudo: sudo.c,v 1.223 1999/03/30 06:01:46 millert Exp $";
#endif /* lint */


/*
 * Local type declarations
 */
struct env_table {
    char *name;
    int len;
};


/*
 * Prototypes
 */
static int  parse_args			__P((void));
static void usage			__P((int));
static void usage_excl			__P((int));
static void load_globals		__P((int));
static int check_sudoers		__P((void));
static int load_cmnd			__P((int));
static void add_env			__P((int));
static void clean_env			__P((char **, struct env_table *));
extern int  user_is_exempt		__P((void));
extern struct passwd *sudo_getpwuid	__P((uid_t));
extern void list_matches		__P((void));

/*
 * Globals
 */
int Argc;
char **Argv;
int NewArgc = 0;
char **NewArgv = NULL;
struct passwd *user_pw_ent;
char *runas_user = RUNAS_DEFAULT;
char *cmnd = NULL;
char *cmnd_args = NULL;
char *tty = "unknown";
char *prompt;
char host[MAXHOSTNAMELEN];
char *shost;
char cwd[MAXPATHLEN];
FILE *sudoers_fp = NULL;
struct stat cmnd_st;
static char *runas_homedir = NULL;
extern struct interface *interfaces;
extern int num_interfaces;
extern int printmatches;
int arg_prompt = 0;	/* was -p used? */
#ifdef HAVE_KERB5
krb5_context sudo_context = NULL;
char *realm = NULL;
int xrealm = 0;
#endif /* HAVE_KERB5 */

/*
 * Table of "bad" envariables to remove and len for strncmp()
 */
struct env_table badenv_table[] = {
    { "IFS=", 4 },
    { "LD_", 3 },
    { "_RLD", 4 },
#ifdef __hpux
    { "SHLIB_PATH=", 11 },
#endif /* __hpux */
#ifdef _AIX
    { "LIBPATH=", 8 },
#endif /* _AIX */
#ifdef HAVE_KERB4
    { "KRB_CONF", 8 },
#endif /* HAVE_KERB4 */
#ifdef HAVE_KERB5
    { "KRB5_CONFIG", 11 },
#endif /* HAVE_KERB5 */
    { "ENV=", 4 },
    { "BASH_ENV=", 9 },
    { (char *) NULL, 0 }
};


/********************************************************************
 *
 *  main()
 *
 *  the driving force behind sudo...
 */

int main(argc, argv)
    int argc;
    char **argv;
{
    int rtn, serrno;
    int cmnd_status = FOUND;
    int sudo_mode = MODE_RUN;
    extern char ** environ;

#if defined(HAVE_GETPRPWNAM) && defined(HAVE_SET_AUTH_PARAMETERS)
    (void) set_auth_parameters(argc, argv);
#  ifdef HAVE_INITPRIVS
    initprivs();
#  endif
#endif /* HAVE_GETPRPWNAM && HAVE_SET_AUTH_PARAMETERS */

    Argv = argv;
    Argc = argc;

    if (geteuid() != 0) {
	(void) fprintf(stderr, "Sorry, %s must be setuid root.\n", Argv[0]);
	exit(1);
    }

    /*
     * Close all file descriptors to make sure we have a nice
     * clean slate from which to work.  
     */
#ifdef HAVE_SYSCONF
    for (rtn = sysconf(_SC_OPEN_MAX) - 1; rtn > 2; rtn--)
	(void) close(rtn);
#else
    for (rtn = getdtablesize() - 1; rtn > 2; rtn--)
	(void) close(rtn);
#endif /* HAVE_SYSCONF */

    /*
     * set the prompt based on $SUDO_PROMPT (can be overridden by `-p')
     */
    if ((prompt = getenv("SUDO_PROMPT")) == NULL)
	prompt = PASSPROMPT;

    /*
     * parse our arguments
     */
    sudo_mode = parse_args();
 
    switch (sudo_mode) {
	case MODE_VERSION:
	case MODE_HELP:
	    (void) printf("CU Sudo version %s\n", version);
	    if (sudo_mode == MODE_VERSION)
		exit(0);
	    else
		usage(0);
	    break;
	case MODE_VALIDATE:
	    cmnd = "validate";
	    break;
    	case MODE_KILL:
	    cmnd = "kill";
	    break;
	case MODE_LIST:
	    cmnd = "list";
	    printmatches = 1;
	    break;
    }

    /* must have a command to run unless got -s */
    if (cmnd == NULL && NewArgc == 0 && !(sudo_mode & MODE_SHELL))
	usage(1);

    clean_env(environ, badenv_table);

    load_globals(sudo_mode);	/* load global variables used throughout sudo */

    /*
     * If we got the '-s' option (run shell) we need to redo NewArgv
     * and NewArgc.  This can only be done after load_globals().
     */
    if ((sudo_mode & MODE_SHELL)) {
	char **dst, **src = NewArgv;

	NewArgv = (char **) emalloc (sizeof(char *) * (++NewArgc + 1));

	/* add the shell as argv[0] */
	if (user_shell && *user_shell) {
	    NewArgv[0] = user_shell;
	} else {
	    (void) fprintf(stderr, "%s: Unable to determine shell.", Argv[0]);
	    exit(1);
	}

	/* copy the args from Argv */
	for (dst = NewArgv + 1; (*dst = *src) != NULL; ++src, ++dst)
	    ;
    }

    rtn = check_sudoers();	/* check mode/owner on _PATH_SUDO_SUDOERS */
    if (rtn != ALL_SYSTEMS_GO) {
	serrno = errno;
	log_error(rtn);
	set_perms(PERM_FULL_USER, sudo_mode);
	errno = serrno;
	inform_user(rtn);
	exit(1);
    }

#ifdef SECURE_PATH
    /* replace the PATH envariable with a secure one */
    if (!user_is_exempt() && sudo_setenv("PATH", SECURE_PATH)) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }
#endif /* SECURE_PATH */

    if ((sudo_mode & MODE_RUN)) {
	cmnd_status = load_cmnd(sudo_mode); /* load the cmnd global variable */
    } else if (sudo_mode == MODE_KILL) {
	remove_timestamp();	/* remove the timestamp ticket file */
	exit(0);
    }

    add_env(!(sudo_mode & MODE_SHELL));	/* add in SUDO_* envariables */

    /* validate the user but don't search for pseudo-commands */
    rtn = validate((sudo_mode != MODE_VALIDATE && sudo_mode != MODE_LIST));

    switch (rtn) {

	case VALIDATE_OK:
	    check_user();
	    /* fallthrough */

	case VALIDATE_OK_NOPASS:
	    /* finally tell the user if the command did not exist */
	    if (cmnd_status == NOT_FOUND_DOT) {
		(void) fprintf(stderr, "%s: ignoring `%s' found in '.'\nUse `sudo ./%s' if this is the `%s' you wish to run.\n", Argv[0], cmnd, cmnd, cmnd);
		exit(1);
	    } else if (cmnd_status == NOT_FOUND) {
		(void) fprintf(stderr, "%s: %s: command not found\n", Argv[0],
		    cmnd);
		exit(1);
	    }

	    log_error(ALL_SYSTEMS_GO);
	    if (sudo_mode == MODE_VALIDATE)
		exit(0);
	    else if (sudo_mode == MODE_LIST) {
		list_matches();
		exit(0);
	    }

	    /* become specified user or root */
	    set_perms(PERM_RUNAS, sudo_mode);

	    /* set $HOME for `sudo -H' */
	    if ((sudo_mode & MODE_RESET_HOME) && runas_homedir)
		(void) sudo_setenv("HOME", runas_homedir);

#ifndef PROFILING
	    if ((sudo_mode & MODE_BACKGROUND) && fork() > 0) {
		exit(0);
	    } else {
		/*
		 * Make sure we are not being spoofed.  The stat should
		 * be cheap enough to make this almost bulletproof.
		 */
		if (cmnd_st.st_dev) {
		    struct stat st;

		    if (stat(cmnd, &st) < 0) {
			(void) fprintf(stderr, "%s: unable to stat %s: ",
					Argv[0], cmnd);
			perror("");
			exit(1);
		    }

		    if (st.st_dev != cmnd_st.st_dev ||
			st.st_ino != cmnd_st.st_ino) {
			/* log and send mail, then bitch */
			log_error(SPOOF_ATTEMPT);
			inform_user(SPOOF_ATTEMPT);
			exit(1);
		    }
		}
		EXEC(cmnd, NewArgv);	/* run the command */
	    }
#else
	    exit(0);
#endif /* PROFILING */
	    /*
	     * If we got here then the exec() failed...
	     */
	    (void) fprintf(stderr, "%s: ", Argv[0]);
	    perror(cmnd);
	    exit(-1);
	    break;

	case VALIDATE_NOT_OK:
	    check_user();

#ifndef DONT_LEAK_PATH_INFO
	    log_error(rtn);
	    if (cmnd_status == NOT_FOUND_DOT)
		(void) fprintf(stderr, "%s: ignoring `%s' found in '.'\nUse `sudo ./%s' if this is the `%s' you wish to run.\n", Argv[0], cmnd, cmnd, cmnd);
	    else if (cmnd_status == NOT_FOUND)
		(void) fprintf(stderr, "%s: %s: command not found\n", Argv[0],
		    cmnd);
	    else
		inform_user(rtn);
	    exit(1);
	    break;
#endif /* DONT_LEAK_PATH_INFO */

	default:
	    log_error(rtn);
	    inform_user(rtn);
	    exit(1);
	    break;
    }
}



/**********************************************************************
 *
 *  load_globals()
 *
 *  This function primes these important global variables:
 *  user_pw_ent, host, cwd, interfaces.
 */

static void load_globals(sudo_mode)
    int sudo_mode;
{
    char *p;
#ifdef FQDN
    struct hostent *h_ent;
#endif /* FQDN */
#ifdef HAVE_KERB5 
    krb5_error_code retval;
    char *lrealm;
#endif /* HAVE_KERB5 */

#ifdef HOST_IN_LOG
    /*
     * Logging routines may use shost so set to a dummy value for now.
     */
    shost = strcpy(host, "localhost");
#endif

    /*
     * Get a local copy of the user's struct passwd with the shadow password
     * if necesary.  It is assumed that euid is 0 at this point so we
     * can read the shadow passwd file if necesary.
     */
    if ((user_pw_ent = sudo_getpwuid(getuid())) == NULL) {
	/* need to make a fake user_pw_ent */
	struct passwd pw;
	char pw_name[MAX_UID_T_LEN + 1];

	/* fill in uid and name fields with the uid */
	pw.pw_uid = getuid();
	(void) sprintf(pw_name, "%ld", (long) pw.pw_uid);
	pw.pw_name = pw_name;
	user_pw_ent = &pw;

	/* complain, log, and die */
	log_error(GLOBAL_NO_PW_ENT);
	inform_user(GLOBAL_NO_PW_ENT);
	exit(1);
    }

#ifdef HAVE_KERB5
    if (retval = krb5_init_context(&sudo_context)) {
	log_error(GLOBAL_KRB5_INIT_ERR);
	inform_user(GLOBAL_KRB5_INIT_ERR);
	exit(1);
    }
    krb5_init_ets(sudo_context);

    if (retval = krb5_get_default_realm(sudo_context, &lrealm)) {
	log_error(GLOBAL_KRB5_INIT_ERR);
	inform_user(GLOBAL_KRB5_INIT_ERR);
	exit(1);
    }

    if (realm) {
	if (strcmp(realm, lrealm) != 0)
	    xrealm = 1; /* User supplied realm is not the system default */
	free(lrealm);
    } else
	realm = lrealm;

    if (!arg_prompt) {
	p = emalloc(strlen(user_name) + strlen(realm) + 17);
	sprintf(p, "Password for %s@@%s: ", user_name, realm);
	prompt = p;
    }
#endif /* HAVE_KERB5 */

    /* Set euid == user and ruid == root */
    set_perms(PERM_ROOT, sudo_mode);
    set_perms(PERM_USER, sudo_mode);

#ifdef HAVE_TZSET
    (void) tzset();		/* set the timezone if applicable */
#endif /* HAVE_TZSET */

    /*
     * Need to get tty early since it's used for logging
     */
    if ((p = (char *) ttyname(0)) || (p = (char *) ttyname(1))) {
	if (strncmp(p, _PATH_DEV, sizeof(_PATH_DEV) - 1) == 0)
	    p += sizeof(_PATH_DEV) - 1;
	tty = estrdup(p);
    }

#ifdef SUDO_UMASK
    (void) umask((mode_t)SUDO_UMASK);
#endif /* SUDO_UMASK */

#ifdef NO_ROOT_SUDO
    if (user_uid == 0) {
	(void) fprintf(stderr,
		       "You are already root, you don't need to use sudo.\n");
	exit(1);
    }
#endif

    /*
     * so we know where we are... (do as user)
     */
    if (!getcwd(cwd, sizeof(cwd))) {
	/* try as root... */
	set_perms(PERM_ROOT, sudo_mode);
	if (!getcwd(cwd, sizeof(cwd))) {
	    (void) fprintf(stderr, "%s: Can't get working directory!\n",
			   Argv[0]);
	    (void) strcpy(cwd, "unknown");
	}
	set_perms(PERM_USER, sudo_mode);
    }

    /*
     * load the host global variable from gethostname() and use
     * gethostbyname() if we want to be sure it is fully qualified.
     */
    if ((gethostname(host, sizeof(host)))) {
	strcpy(host, "localhost");
	log_error(GLOBAL_NO_HOSTNAME);
	inform_user(GLOBAL_NO_HOSTNAME);
	exit(2);
    }
#ifdef FQDN
    if ((h_ent = gethostbyname(host)) == NULL)
	log_error(GLOBAL_HOST_UNREGISTERED);
    else
	strcpy(host, h_ent -> h_name);
#endif /* FQDN */

    /*
     * "host" is the (possibly fully-qualified) hostname and
     * "shost" is the unqualified form of the hostname.
     */
    if ((p = strchr(host, '.'))) {
	*p = '\0';
	shost = estrdup(host);
	*p = '.';
    } else {
	shost = &host[0];
    }

    /*
     * load a list of ip addresses and netmasks into
     * the interfaces array.
     */
    load_interfaces();
}



/**********************************************************************
 *
 * parse_args()
 *
 *  this function parses the arguments to sudo
 */

static int parse_args()
{
    int ret = MODE_RUN;			/* what mode is suod to be run in? */
    int excl = 0;			/* exclusive arg, no others allowed */

    NewArgv = Argv + 1;
    NewArgc = Argc - 1;

#ifdef SHELL_IF_NO_ARGS
    if (Argc < 2) {			/* no options and no command */
	ret |= MODE_SHELL;
	return(ret);
    }
#else
    if (Argc < 2)			/* no options and no command */
	usage(1);
#endif /* SHELL_IF_NO_ARGS */

    while (NewArgc > 0 && NewArgv[0][0] == '-') {
	if (NewArgv[0][1] != '\0' && NewArgv[0][2] != '\0') {
	    (void) fprintf(stderr, "%s: Please use single character options\n",
		Argv[0]);
	    usage(1);
	}

	switch (NewArgv[0][1]) {
#ifdef HAVE_KERB5
	    case 'r':
		/* must have an associated realm */
		if (NewArgv[1] == NULL)
		    usage(1);

		realm = NewArgv[1];

		/* shift Argv over and adjust Argc */
		NewArgc--;
		NewArgv++;
		break;
#endif /* HAVE_KERB5 */
	    case 'p':
		/* must have an associated prompt */
		if (NewArgv[1] == NULL)
		    usage(1);

		prompt = NewArgv[1];
		arg_prompt = 1;

		/* shift Argv over and adjust Argc */
		NewArgc--;
		NewArgv++;
		break;
	    case 'u':
		/* must have an associated runas user */
		if (NewArgv[1] == NULL)
		    usage(1);

		runas_user = NewArgv[1];

		/* shift Argv over and adjust Argc */
		NewArgc--;
		NewArgv++;
		break;
	    case 'b':
		ret |= MODE_BACKGROUND;
		break;
	    case 'v':
		ret = MODE_VALIDATE;
		if (excl && excl != 'v')
		    usage_excl(1);
		excl = 'v';
		break;
	    case 'k':
		ret = MODE_KILL;
		if (excl && excl != 'k')
		    usage_excl(1);
		excl = 'k';
		break;
	    case 'l':
		ret = MODE_LIST;
		if (excl && excl != 'l')
		    usage_excl(1);
		excl = 'l';
		break;
	    case 'V':
		ret = MODE_VERSION;
		if (excl && excl != 'V')
		    usage_excl(1);
		excl = 'V';
		break;
	    case 'h':
		ret = MODE_HELP;
		if (excl && excl != 'h')
		    usage_excl(1);
		excl = 'h';
		break;
	    case 's':
		ret |= MODE_SHELL;
#ifdef SHELL_SETS_HOME
		ret |= MODE_RESET_HOME;
#endif /* SHELL_SETS_HOME */
		break;
	    case 'H':
		ret |= MODE_RESET_HOME;
		break;
	    case '-':
		NewArgc--;
		NewArgv++;
#ifdef SHELL_IF_NO_ARGS
		if (ret == MODE_RUN)
		    ret |= MODE_SHELL;
#endif /* SHELL_IF_NO_ARGS */
		return(ret);
	    case '\0':
		(void) fprintf(stderr, "%s: '-' requires an argument\n",
		    Argv[0]);
		usage(1);
	    default:
		(void) fprintf(stderr, "%s: Illegal option %s\n", Argv[0],
		    NewArgv[0]);
		usage(1);
	}
	NewArgc--;
	NewArgv++;
    }

    if (NewArgc > 0 && (ret == MODE_VALIDATE || ret == MODE_KILL ||
			ret == MODE_LIST))
	usage(1);

    return(ret);
}



/**********************************************************************
 *
 * usage_excl()
 *
 *  Tell which options are mutually exclusive and exit
 */

static void usage_excl(exit_val)
    int exit_val;
{
    (void) fprintf(stderr, "Only one of the -v, -k, -l, -V and -h options may be used\n");
    usage(exit_val);
}

/**********************************************************************
 *
 * usage()
 *
 *  this function just gives you instructions and exits
 */

static void usage(exit_val)
    int exit_val;
{
    (void) fprintf(stderr,
		   "usage: %s -V | -h | -l | -v | -k | -H | [-b] [-p prompt] ",
		   Argv[0]);
#ifdef HAVE_KERB5
    (void) fprintf(stderr, "[-r realm] ");
#endif /* HAVE_KERB5 */
    (void) fprintf(stderr, "[-u username/#uid] -s | <command>\n");
    exit(exit_val);
}



/**********************************************************************
 *
 * add_env()
 *
 *  this function adds sudo-specific variables into the environment
 */

static void add_env(contiguous)
    int contiguous;
{
    char idstr[MAX_UID_T_LEN + 1];
    size_t size;
    char *buf;

    /* add the SUDO_COMMAND envariable (cmnd + args) */
    size = strlen(cmnd) + 1;
    if (NewArgc > 1) {
	char *to, **from;

	if (contiguous) {
	    size += (size_t) (NewArgv[NewArgc-1] - NewArgv[1]) +
		    strlen(NewArgv[NewArgc-1]) + 1;
	} else {
	    for (from = &NewArgv[1]; *from; from++)
		size += strlen(*from) + 1;
	}

	buf = (char *) emalloc(size);

	/*
	 * Copy the command and it's arguments info buf
	 */
	(void) strcpy(buf, cmnd);
	to = buf + strlen(cmnd);
	for (from = &NewArgv[1]; *from; from++) {
	    *to++ = ' ';
	    (void) strcpy(to, *from);
	    to += strlen(*from);
	}
    } else {
	buf = cmnd;
    }
    if (sudo_setenv("SUDO_COMMAND", buf)) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }
    if (NewArgc > 1)
	(void) free(buf);

    /* grab a pointer to the flat arg string from the environment */
    if (NewArgc > 1 && (cmnd_args = getenv("SUDO_COMMAND"))) {
	if ((cmnd_args = strchr(cmnd_args, ' ')))
	    cmnd_args++;
	else
	    cmnd_args = NULL;
    }

    /* add the SUDO_USER envariable */
    if (sudo_setenv("SUDO_USER", user_name)) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }

    /* add the SUDO_UID envariable */
    (void) sprintf(idstr, "%ld", (long) user_uid);
    if (sudo_setenv("SUDO_UID", idstr)) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }

    /* add the SUDO_GID envariable */
    (void) sprintf(idstr, "%ld", (long) user_gid);
    if (sudo_setenv("SUDO_GID", idstr)) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }

    /* set PS1 if SUDO_PS1 is set */
    if ((buf = getenv("SUDO_PS1")))
	if (sudo_setenv("PS1", buf)) {
	    (void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	    exit(1);
	}
}



/**********************************************************************
 *
 *  load_cmnd()
 *
 *  This function sets the cmnd global variable
 *  Returns 1 on success, 0 on failure.
 */

static int load_cmnd(sudo_mode)
    int sudo_mode;
{
    int retval;

    if (strlen(NewArgv[0]) >= MAXPATHLEN) {
	errno = ENAMETOOLONG;
	(void) fprintf(stderr, "%s: %s: Pathname too long\n", Argv[0],
		       NewArgv[0]);
	exit(1);
    }

    /*
     * Resolve the path
     */
    if ((retval = find_path(NewArgv[0], &cmnd)) != FOUND)
	cmnd = NewArgv[0];
    return(retval);
}



/**********************************************************************
 *
 *  check_sudoers()
 *
 *  This function check to see that the sudoers file is owned by
 *  uid SUDOERS_UID, gid SUDOERS_GID and is mode SUDOERS_MODE.
 */

static int check_sudoers()
{
    struct stat statbuf;
    int rootstat, i;
    char c;
    int rtn = ALL_SYSTEMS_GO;

    /*
     * Fix the mode and group on sudoers file from old default.
     * Only works if filesystem is readable/writable by root.
     */
    set_perms(PERM_ROOT, 0);
    if ((rootstat = lstat(_PATH_SUDO_SUDOERS, &statbuf)) == 0 &&
	SUDOERS_UID == statbuf.st_uid && SUDOERS_MODE != 0400 &&
	(statbuf.st_mode & 0007777) == 0400) {

	if (chmod(_PATH_SUDO_SUDOERS, SUDOERS_MODE) == 0) {
	    (void) fprintf(stderr, "%s: fixed mode on %s\n",
		Argv[0], _PATH_SUDO_SUDOERS);
	    if (statbuf.st_gid != SUDOERS_GID) {
		if (!chown(_PATH_SUDO_SUDOERS,GID_NO_CHANGE,SUDOERS_GID)) {
		    (void) fprintf(stderr, "%s: set group on %s\n",
			Argv[0], _PATH_SUDO_SUDOERS);
		    statbuf.st_gid = SUDOERS_GID;
		} else {
		    (void) fprintf(stderr,"%s: Unable to set group on %s: ",
			Argv[0], _PATH_SUDO_SUDOERS);
		    perror("");
		}
	    }
	} else {
	    (void) fprintf(stderr, "%s: Unable to fix mode on %s: ",
		Argv[0], _PATH_SUDO_SUDOERS);
	    perror("");
	}
    }

    /*
     * Sanity checks on sudoers file.  Must be done as sudoers
     * file owner.  We already did a stat as root, so use that
     * data if we can't stat as sudoers file owner.
     */
    set_perms(PERM_SUDOERS, 0);

    if (rootstat != 0 && lstat(_PATH_SUDO_SUDOERS, &statbuf) != 0)
	rtn = NO_SUDOERS_FILE;
    else if (!S_ISREG(statbuf.st_mode))
	rtn = SUDOERS_NOT_FILE;
    else if ((statbuf.st_mode & 0007777) != SUDOERS_MODE)
	rtn = SUDOERS_WRONG_MODE;
    else if (statbuf.st_uid != SUDOERS_UID || statbuf.st_gid != SUDOERS_GID)
	rtn = SUDOERS_WRONG_OWNER;
    else {
	/* Solaris sometimes returns EAGAIN so try 10 times */
	for (i = 0; i < 10 ; i++) {
	    errno = 0;
	    if ((sudoers_fp = fopen(_PATH_SUDO_SUDOERS, "r")) == NULL ||
		fread(&c, sizeof(c), 1, sudoers_fp) != 1) {
		sudoers_fp = NULL;
		if (errno != EAGAIN && errno != EWOULDBLOCK)
		    break;
	    } else
		break;
	    sleep(1);
	}
	if (sudoers_fp == NULL) {
	    fprintf(stderr, "%s: cannot open %s: ", Argv[0], _PATH_SUDO_SUDOERS);
	    perror("");
	    rtn = NO_SUDOERS_FILE;
	}
    }

    set_perms(PERM_ROOT, 0);
    set_perms(PERM_USER, 0);

    return(rtn);
}



/**********************************************************************
 *
 * set_perms()
 *
 *  this function sets real and effective uids and gids based on perm.
 */

void set_perms(perm, sudo_mode)
    int perm;
    int sudo_mode;
{
    struct passwd *pw;

    switch (perm) {
	case PERM_ROOT:
				if (setuid(0)) {
				    perror("setuid(0)");
				    exit(1);
				}
			      	break;

	case PERM_USER: 
    	    	    	        (void) setgid(user_gid);

    	    	    	        if (seteuid(user_uid)) {
    	    	    	            perror("seteuid(user_uid)");
    	    	    	            exit(1); 
    	    	    	        }
			      	break;
				
	case PERM_FULL_USER: 
				if (setuid(0)) {
				    perror("setuid(0)");
				    exit(1);
				}

    	    	    	        (void) setgid(user_gid);

				if (setuid(user_uid)) {
				    perror("setuid(user_uid)");
				    exit(1);
				}

			      	break;
	case PERM_RUNAS:
				if (setuid(0)) {
				    perror("setuid(0)");
				    exit(1);
				}
				
				/* XXX - add group/gid support */
				if (*runas_user == '#') {
				    if (setuid(atoi(runas_user + 1))) {
					(void) fprintf(stderr,
					    "%s: cannot set uid to %s: ",
					    Argv[0], runas_user);
					perror("");
					exit(1);
				    }
				} else {
				    if (!(pw = getpwnam(runas_user))) {
					(void) fprintf(stderr,
					    "%s: no passwd entry for %s!\n",
					    Argv[0], runas_user);
					exit(1);
				    }

				    /* Set $USER to match target user */
				    if (sudo_setenv("USER", pw->pw_name)) {
					(void) fprintf(stderr,
					    "%s: cannot allocate memory!\n",
					    Argv[0]);
					exit(1);
				    }

				    if (setgid(pw->pw_gid)) {
					(void) fprintf(stderr,
					    "%s: cannot set gid to %d: ",  
					    Argv[0], pw->pw_gid);
					perror("");
					exit(1);
				    }

				    /*
				     * Initialize group vector only if are
				     * going to run as a non-root user.
				     */
				    if (strcmp(runas_user, "root") != 0 &&
					initgroups(runas_user, pw->pw_gid)
					== -1) {
					(void) fprintf(stderr,
					    "%s: cannot set group vector ",
					    Argv[0]);
					perror("");
					exit(1);
				    }

				    if (setuid(pw->pw_uid)) {
					(void) fprintf(stderr,
					    "%s: cannot set uid to %d: ",  
					    Argv[0], pw->pw_uid);
					perror("");
					exit(1);
				    }
				    if (sudo_mode & MODE_RESET_HOME)
					runas_homedir = pw->pw_dir;
				}

				break;
	case PERM_SUDOERS: 
				if (setuid(0)) {
				    perror("setuid(0)");
				    exit(1);
				}

				if (setgid(SUDOERS_GID)) {
				    perror("setgid(SUDOERS_GID)");
				    exit(1);
				}

				/*
				 * If SUDOERS_UID == 0 and SUDOERS_MODE
				 * is group readable we use a non-zero
				 * uid in order to avoid NFS lossage.
				 * Using uid 1 is a bit bogus but should
				 * work on all OS's.
				 */
				if (SUDOERS_UID == 0) {
				    if ((SUDOERS_MODE & 040) && seteuid(1)) {
					perror("seteuid(1)");
					exit(1);
				    }
				} else {
				    if (seteuid(SUDOERS_UID)) {
					perror("seteuid(SUDOERS_UID)");
					exit(1);
				    }
				}

			      	break;
    }
}



/**********************************************************************
 *
 * clean_env()
 *
 *  This function removes things from the environment that match the
 *  entries in badenv_table.  It would be nice to add in the SUDO_*
 *  variables here as well but cmnd has not been defined at this point.
 */

static void clean_env(envp, badenv_table)
    char **envp;
    struct env_table *badenv_table;
{
    struct env_table *bad;
    char **cur;

    /*
     * Remove any envars that match entries in badenv_table
     */
    for (cur = envp; *cur; cur++) {
	for (bad = badenv_table; bad -> name; bad++) {
	    if (strncmp(*cur, bad -> name, bad -> len) == 0) {
		/* got a match so remove it */
		char **move;

		for (move = cur; *move; move++)
		    *move = *(move + 1);

		cur--;

		break;
	    }
	}
    }
}
@


1.14
log
@Final changes for real 1.5.9 release
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.13
log
@sudo 1.5.9--fixes some parser bugs
@
text
@d96 1
a96 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.222 1999/03/29 04:05:12 millert Exp $";
d114 1
a599 3
	if (excl)
	    usage(1);			/* only one -? option allowed */

d642 3
a644 1
		excl++;
d648 3
a650 1
		excl++;
d654 3
a656 1
		excl++;
d660 3
a662 1
		excl++;
d666 3
a668 1
		excl++;
d708 14
@


1.12
log
@sudo 1.5.8
@
text
@d4 1
a4 1
 * CU sudo version 1.5.8 (based on Root Group sudo version 1.1)
a72 3
#if defined(HAVE_MALLOC_H) && !defined(STDC_HEADERS)
#include <malloc.h>   
#endif /* HAVE_MALLOC_H && !STDC_HEADERS */
a91 6
#ifndef __GNUC__		/* gcc has its own malloc */
extern char *malloc	__P((size_t));
#endif /* __GNUC__ */
#ifdef HAVE_STRDUP
extern char *strdup	__P((const char *));
#endif /* HAVE_STRDUP */
d96 1
a96 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.219 1999/02/11 06:41:31 millert Exp $";
d267 1
a267 5
	NewArgv = (char **) malloc (sizeof(char *) * (++NewArgc + 1));
	if (NewArgv == NULL) {
	    (void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	    exit(1);
	}
d429 7
d480 1
a480 5
	p = malloc(strlen(user_name) + strlen(realm) + 17);
	if (p == NULL) {
	    (void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	    exit(1);
	}
d500 1
a500 4
	if ((tty = (char *) strdup(p)) == NULL) {
	    (void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	    exit(1);
	}
d552 1
a552 4
	if ((shost = (char *) strdup(host)) == NULL) {
	    (void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	    exit(1);
	}
d750 1
a750 4
	if ((buf = (char *) malloc(size)) == NULL) {
	    (void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	    exit(1);
	}
@


1.11
log
@sudo 1.5.7
@
text
@d4 2
a5 1
 * CU sudo version 1.5.7 (based on Root Group sudo version 1.1)
d87 3
d105 1
a105 1
static const char rcsid[] = "$From: sudo.c,v 1.213 1998/11/18 04:16:13 millert Exp $";
d154 6
d176 4
a179 1
#endif
d197 2
a198 1
    int rtn, cmnd_status = FOUND;
d297 1
d300 1
d437 4
d464 32
d565 1
a565 1
	if ((shost = strdup(host)) == NULL) {
d619 13
d638 1
d727 7
a733 1
    (void) fprintf(stderr, "usage: %s -V | -h | -l | -v | -k | -H | [-b] [-p prompt] [-u username/#uid] -s | <command>\n", Argv[0]);
d911 1
a911 1
    if (lstat(_PATH_SUDO_SUDOERS, &statbuf) != 0 && rootstat != 0)
@


1.10
log
@sudo 1.5.6
@
text
@d1 1
a1 1
/*	$OpenBSD: sudo.c,v 1.9 1998/06/27 20:21:55 millert Exp $	*/
d4 1
a4 1
 * CU sudo version 1.5.6 (based on Root Group sudo version 1.1)
a54 4
#ifndef lint
static char rcsid[] = "$From: sudo.c,v 1.197 1998/09/13 19:32:48 millert Exp $";
#endif /* lint */

a79 1
#include <sys/time.h>
a82 8
#if (SHADOW_TYPE == SPW_SECUREWARE)
#  ifdef __hpux
#    include <hpsecurity.h>
#  else
#    include <sys/security.h>
#  endif /* __hpux */
#  include <prot.h>
#endif /* SPW_SECUREWARE */
a87 1
#include <options.h>
d100 4
d184 1
a184 1
    int rtn, found_cmnd;
d188 1
a188 1
#if (SHADOW_TYPE == SPW_SECUREWARE) && defined(HAVE_SET_AUTH_PARAMETERS)
d190 4
a193 1
#endif /* SPW_SECUREWARE */
a263 1
	    perror("malloc");
a291 1
	perror("malloc");
d298 1
a298 1
	found_cmnd = load_cmnd(sudo_mode); /* load the cmnd global variable */
d306 1
a306 1
    /* validate the user but don't search for "validate" */
d312 3
a315 3
	    if (rtn != VALIDATE_OK_NOPASS) 
		check_user();

d317 4
a320 1
	    if ((sudo_mode & MODE_RUN) && !found_cmnd) {
d322 1
a322 1
			       cmnd);
d380 16
a397 1
	    set_perms(PERM_FULL_USER, sudo_mode);
d429 1
a429 1
	struct passwd pw_ent;
d433 4
a436 4
	pw_ent.pw_uid = getuid();
	(void) sprintf(pw_name, "%ld", (long) pw_ent.pw_uid);
	pw_ent.pw_name = pw_name;
	user_pw_ent = &pw_ent;
a458 1
	    perror("malloc");
d464 3
a466 3
#ifdef UMASK
    (void) umask((mode_t)UMASK);
#endif /* UMASK */
d483 1
a483 1
	    (void) fprintf(stderr, "%s:  Can't get working directory!\n",
a513 1
	    perror("malloc");
a694 1
	    perror("malloc");
a712 1
	perror("malloc");
a728 1
	perror("malloc");
a735 1
	perror("malloc");
a742 1
	perror("malloc");
a749 1
	    perror("malloc");
d768 2
d780 1
a780 1
    if ((cmnd = find_path(NewArgv[0])) == NULL) {
d782 1
a782 3
	return(0);
    } else
	return(1);
d886 1
a886 1
    struct passwd *pw_ent;
d935 1
a935 1
				    if (!(pw_ent = getpwnam(runas_user))) {
d942 9
a950 1
				    if (setgid(pw_ent->pw_gid)) {
d953 1
a953 1
					    Argv[0], pw_ent->pw_gid);
d959 2
a960 2
				     * Initialize group vector only if
				     * we are going to be a non-root user.
d963 1
a963 1
					initgroups(runas_user, pw_ent->pw_gid)
d972 1
a972 1
				    if (setuid(pw_ent->pw_uid)) {
d975 1
a975 1
					    Argv[0], pw_ent->pw_uid);
d980 1
a980 1
					runas_homedir = pw_ent->pw_dir;
@


1.9
log
@Require a password before telling user "command not found".
The upshot of this is that a user probing for binaries will be
told "you are not allowed to run this" instead of "that doesn't exist".
@
text
@d1 1
a1 1
/*	$OpenBSD: sudo.c,v 1.8 1998/03/31 06:41:11 millert Exp $	*/
d4 1
a4 1
 * CU sudo version 1.5.5 (based on Root Group sudo version 1.1)
d56 1
a56 1
static char rcsid[] = "Id: sudo.c,v 1.190 1998/03/31 05:05:45 millert Exp $";
d146 1
a146 1
char *runas_user = "root";
d151 1
a151 1
char host[MAXHOSTNAMELEN + 1];
d153 1
a153 1
char cwd[MAXPATHLEN + 1];
d198 1
a198 1
#if (SHADOW_TYPE == SPW_SECUREWARE)
d278 1
a278 2
	    if ((NewArgv[0] = strrchr(user_shell, '/') + 1) == (char *) 1)
		NewArgv[0] = user_shell;
d421 1
a421 1
	char pw_name[MAX_UID_T_LEN+1];
d471 1
a471 1
    if (!getwd(cwd)) {
d474 1
a474 1
	if (!getwd(cwd)) {
d486 1
a486 1
    if ((gethostname(host, MAXHOSTNAMELEN))) {
d767 1
a767 1
    if (strlen(NewArgv[0]) > MAXPATHLEN) {
@


1.8
log
@sudo 1.5.5
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d131 1
a131 1
static void load_cmnd			__P((int));
d194 1
a194 1
    int rtn;
d308 1
a308 1
	load_cmnd(sudo_mode);	/* load the cmnd global variable */
d325 8
d762 1
d765 1
a765 1
static void load_cmnd(sudo_mode)
d779 4
a782 4
	(void) fprintf(stderr, "%s: %s: command not found\n", Argv[0],
		       NewArgv[0]);
	exit(1);
    }
@


1.7
log
@sudo 1.5.4
@
text
@d4 1
a4 1
 * CU sudo version 1.5.4 (based on Root Group sudo version 1.1)
d56 1
a56 1
static char rcsid[] = "Id: sudo.c,v 1.179 1998/01/13 04:48:42 millert Exp $";
d154 1
d167 1
a167 1
    { "_RLD_", 5 },
d211 12
a257 12
    /*
     * Close all file descriptors to make sure we have a nice
     * clean slate from which to work.  
     */
#ifdef HAVE_SYSCONF
    for (rtn = sysconf(_SC_OPEN_MAX) - 1; rtn > 3; rtn--)
	(void) close(rtn);
#else
    for (rtn = getdtablesize() - 1; rtn > 3; rtn--)
	(void) close(rtn);
#endif /* HAVE_SYSCONF */

d673 2
a674 2
	    size += (size_t) NewArgv[NewArgc-1] + strlen(NewArgv[NewArgc-1]) -
		    (size_t) NewArgv[1] + 1;
d789 1
a789 1
    int fd = -1, rootstat;
d838 19
a856 6
    else if ((fd = open(_PATH_SUDO_SUDOERS, O_RDONLY)) == -1 ||
	     read(fd, &c, 1) == -1)
	rtn = NO_SUDOERS_FILE;

    if (fd != -1)
	(void) close(fd);
d937 14
@


1.6
log
@Don't set the tty variable to NULL when we lack a tty, leave it as
"unknown".
@
text
@d1 1
a1 1
/*	$OpenBSD: sudo.c,v 1.5 1997/11/23 07:15:49 millert Exp $	*/
d4 1
a4 1
 * CU sudo version 1.5.3 (based on Root Group sudo version 1.1)
d56 1
a56 1
static char rcsid[] = "Id: sudo.c,v 1.177 1997/11/23 06:53:37 millert Exp $";
@


1.5
log
@OpenBSD tags (and preserve sudo tags)
updates from my sudo source tree:
    logging.c: deal with maxfilelen < 0 case
    sudo.c: correct error message if mode/owner wrong and not statable by owner
    compat.h: fix seteuid macro
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d438 4
a441 4
    if ((tty = (char *) ttyname(0)) || (tty = (char *) ttyname(1))) {
	if (strncmp(tty, _PATH_DEV, sizeof(_PATH_DEV) - 1) == 0)
	    tty += sizeof(_PATH_DEV) - 1;
	if ((tty = (char *) strdup(tty)) == NULL) {
@


1.4
log
@define tty global to an initial value to avoid dumping core in logging
functions when passwd file is unavailable.
@
text
@d1 2
d56 1
a56 1
static char rcsid[] = "$Id: sudo.c,v 1.3 1997/04/12 07:18:56 millert Exp $";
d788 1
a788 1
    int fd = -1;
d797 16
a812 15
    if (!lstat(_PATH_SUDO_SUDOERS, &statbuf) && SUDOERS_UID == statbuf.st_uid) {
	if (SUDOERS_MODE != 0400 && (statbuf.st_mode & 0007777) == 0400) {
	    if (chmod(_PATH_SUDO_SUDOERS, SUDOERS_MODE) == 0) {
		(void) fprintf(stderr, "%s: fixed mode on %s\n",
		    Argv[0], _PATH_SUDO_SUDOERS);
		if (statbuf.st_gid != SUDOERS_GID) {
		    if (!chown(_PATH_SUDO_SUDOERS,GID_NO_CHANGE,SUDOERS_GID)) {
			(void) fprintf(stderr, "%s: set group on %s\n",
			    Argv[0], _PATH_SUDO_SUDOERS);
			statbuf.st_gid = SUDOERS_GID;
		    } else {
			(void) fprintf(stderr,"%s: Unable to set group on %s: ",
			    Argv[0], _PATH_SUDO_SUDOERS);
			perror("");
		    }
a813 4
	    } else {
		(void) fprintf(stderr, "%s: Unable to fix mode on %s: ",
		    Argv[0], _PATH_SUDO_SUDOERS);
		perror("");
d815 4
d822 5
d829 1
a829 3
    if ((fd = open(_PATH_SUDO_SUDOERS, O_RDONLY)) < 0 || read(fd, &c, 1) == -1)
	rtn = NO_SUDOERS_FILE;
    else if (lstat(_PATH_SUDO_SUDOERS, &statbuf))
d837 3
@


1.3
log
@Fixed coredump when passwd file is missing or unavailable.
Reported by Jason Downs <downsj@@teeny.org> and
Klee Dienes <klee@@mit.edu> (via a Debian Linux bug report).
@
text
@d54 1
a54 1
static char rcsid[] = "$Id: sudo.c,v 1.2 1996/11/17 16:34:04 millert Exp $";
d147 1
a147 1
char *tty = NULL;
d444 1
a444 2
    } else
	tty = "none";
@


1.2
log
@Updated to sudo 1.5.3
@
text
@d54 1
a54 1
static char rcsid[] = "$Id: sudo.c,v 1.174 1996/11/14 02:37:16 millert Exp $";
d408 1
a408 4
    user_pw_ent = sudo_getpwuid(getuid());
    set_perms(PERM_ROOT, sudo_mode);
    set_perms(PERM_USER, sudo_mode);
    if (user_pw_ent == NULL) {
d424 4
@


1.1
log
@sudo 1.5.2
@
text
@d2 1
a2 1
 * CU sudo version 1.5.2 (based on Root Group sudo version 1.1)
d54 1
a54 1
static char rcsid[] = "$Id: sudo.c,v 1.172 1996/10/07 04:53:47 millert Exp $";
d942 5
a946 4
				 * If SUDOERS_UID == 0 we need to use
				 * a different uid in order to avoid
				 * NFS lossage.  Using uid 1 is a bit
				 * bogus but should be safe.
d949 1
a949 1
				    if (seteuid(1)) {
@
