head	1.12;
access;
symbols
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.12
date	99.11.18.16.39.34;	author millert;	state dead;
branches;
next	1.11;

1.11
date	99.03.29.20.29.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.03.08.00.17.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.02.19.04.32.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.12.07.21.32.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.11.21.01.34.52;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.09.15.02.42.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.03.31.06.41.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.01.13.05.30.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.23.07.15.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.11.17.16.34.00;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.10.14.05.14.49;	author millert;	state Exp;
branches;
next	;


desc
@@


1.12
log
@remove old GPL'd sudo
@
text
@/*	$OpenBSD: interfaces.c,v 1.11 1999/03/29 20:29:04 millert Exp $	*/

/*
 *  CU sudo version 1.5.9
 *  Copyright (c) 1996, 1998, 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 1, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  Please send bugs, changes, problems to sudo-bugs@@courtesan.com
 *
 *******************************************************************
 *
 *  This module contains load_interfaces() a function that
 *  fills the interfaces global with a list of active ip
 *  addresses and their associated netmasks.
 *
 *  Todd C. Miller  Mon May  1 20:48:43 MDT 1995
 */

#include "config.h"

#include <stdio.h>
#ifdef STDC_HEADERS
#include <stdlib.h>
#endif /* STDC_HEADERS */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* HAVE_UNISTD_H */
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
#include <netdb.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#if defined(HAVE_SYS_SOCKIO_H) && !defined(SIOCGIFCONF)
#include <sys/sockio.h>
#endif
#ifdef _ISC
#include <sys/stream.h>
#include <sys/sioctl.h>
#include <sys/stropts.h>
#include <net/errno.h>
#define STRSET(cmd, param, len)	{strioctl.ic_cmd=(cmd);\
				 strioctl.ic_dp=(param);\
				 strioctl.ic_timout=0;\
				 strioctl.ic_len=(len);}
#endif /* _ISC */
#ifdef _MIPS
#include <net/soioctl.h>
#endif /* _MIPS */
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>

#include "sudo.h"
#include "version.h"

#ifndef lint
static const char rcsid[] = "$Sudo: interfaces.c,v 1.52 1999/03/29 04:05:09 millert Exp $";
#endif /* lint */

/*
 * Globals
 */
struct interface *interfaces;
int num_interfaces = 0;
extern int Argc;
extern char **Argv;


#if defined(SIOCGIFCONF) && !defined(STUB_LOAD_INTERFACES)
/**********************************************************************
 *
 *  load_interfaces()
 *
 *  This function sets the interfaces global variable
 *  and sets the constituent ip addrs and netmasks.
 */

void load_interfaces()
{
    struct ifconf *ifconf;
    struct ifreq *ifr, ifr_tmp;
    struct sockaddr_in *sin;
    int sock, n, i;
    size_t len = sizeof(struct ifconf) + BUFSIZ;
    char *previfname = "", *ifconf_buf = NULL;
#ifdef _ISC
    struct strioctl strioctl;
#endif /* _ISC */

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
	perror("socket");
	exit(1);
    }

    /*
     * get interface configuration or return (leaving interfaces NULL)
     */
    for (;;) {
	ifconf_buf = erealloc(ifconf_buf, len);
	ifconf = (struct ifconf *) ifconf_buf;
	ifconf->ifc_len = len - sizeof(struct ifconf);
	ifconf->ifc_buf = (caddr_t) (ifconf_buf + sizeof(struct ifconf));

	/* networking may not be installed in kernel */
#ifdef _ISC
	STRSET(SIOCGIFCONF, (caddr_t) ifconf, len);
	if (ioctl(sock, I_STR, (caddr_t) &strioctl) < 0) {
#else
	if (ioctl(sock, SIOCGIFCONF, (caddr_t) ifconf) < 0) {
#endif /* _ISC */
	    (void) free(ifconf_buf);
	    (void) close(sock);
	    return;
	}

	/* break out of loop if we have a big enough buffer */
	if (ifconf->ifc_len + sizeof(struct ifreq) < len)
	    break;
	len += BUFSIZ;
    }

    /*
     * get the maximum number of interfaces that *could* exist.
     */
    n = ifconf->ifc_len / sizeof(struct ifreq);

    /*
     * allocate space for interfaces array
     */
    interfaces = (struct interface *) emalloc(sizeof(struct interface) * n);

    /*
     * for each interface, store the ip address and netmask
     */
    for (i = 0; i < ifconf->ifc_len; ) {
	/* get a pointer to the current interface */
	ifr = (struct ifreq *) &ifconf->ifc_buf[i];

	/* set i to the subscript of the next interface */
	i += sizeof(struct ifreq);
#ifdef HAVE_SA_LEN
	if (ifr->ifr_addr.sa_len > sizeof(ifr->ifr_addr))
	    i += ifr->ifr_addr.sa_len - sizeof(struct sockaddr);
#endif /* HAVE_SA_LEN */

	/* skip duplicates and interfaces with NULL addresses */
	sin = (struct sockaddr_in *) &ifr->ifr_addr;
	if (sin->sin_addr.s_addr == 0 ||
	    strncmp(previfname, ifr->ifr_name, sizeof(ifr->ifr_name) - 1) == 0)
	    continue;

	/* skip non-ip things */
	if (ifr->ifr_addr.sa_family != AF_INET)
		continue;

	/*
	 * make sure the interface is up, skip if not.
	 */
#ifdef SIOCGIFFLAGS
	memset(&ifr_tmp, 0, sizeof(ifr_tmp));
	strncpy(ifr_tmp.ifr_name, ifr->ifr_name, sizeof(ifr_tmp.ifr_name) - 1);
	if (ioctl(sock, SIOCGIFFLAGS, (caddr_t) &ifr_tmp) < 0)
#endif
	    ifr_tmp = *ifr;
	
	/* skip interfaces marked "down" and "loopback" */
	if (!(ifr_tmp.ifr_flags & IFF_UP) || (ifr_tmp.ifr_flags & IFF_LOOPBACK))
		continue;

	/* store the ip address */
	sin = (struct sockaddr_in *) &ifr->ifr_addr;
	interfaces[num_interfaces].addr.s_addr = sin->sin_addr.s_addr;

	/* stash the name of the interface we saved */
	previfname = ifr->ifr_name;

	/* get the netmask */
	(void) memset(&ifr_tmp, 0, sizeof(ifr_tmp));
	strncpy(ifr_tmp.ifr_name, ifr->ifr_name, sizeof(ifr_tmp.ifr_name) - 1);
#ifdef SIOCGIFNETMASK
#ifdef _ISC
	STRSET(SIOCGIFNETMASK, (caddr_t) &ifr_tmp, sizeof(ifr_tmp));
	if (ioctl(sock, I_STR, (caddr_t) &strioctl) == 0) {
#else
	if (ioctl(sock, SIOCGIFNETMASK, (caddr_t) &ifr_tmp) == 0) {
#endif /* _ISC */
	    sin = (struct sockaddr_in *) &ifr_tmp.ifr_addr;

	    /* store the netmask */
	    interfaces[num_interfaces].netmask.s_addr = sin->sin_addr.s_addr;
	} else {
#else
	{
#endif /* SIOCGIFNETMASK */
	    if (IN_CLASSC(interfaces[num_interfaces].addr.s_addr))
		interfaces[num_interfaces].netmask.s_addr = htonl(IN_CLASSC_NET);
	    else if (IN_CLASSB(interfaces[num_interfaces].addr.s_addr))
		interfaces[num_interfaces].netmask.s_addr = htonl(IN_CLASSB_NET);
	    else
		interfaces[num_interfaces].netmask.s_addr = htonl(IN_CLASSA_NET);
	}

	/* only now can we be sure it was a good/interesting interface */
	num_interfaces++;
    }

    /* if there were bogus entries, realloc the array */
    if (n != num_interfaces) {
	/* it is unlikely that num_interfaces will be 0 but who knows... */
	if (num_interfaces != 0)
	    interfaces = (struct interface *) erealloc(interfaces,
		sizeof(struct interface) * num_interfaces);
	else
	    (void) free(interfaces);
    }
    (void) free(ifconf_buf);
    (void) close(sock);
}

#else /* !SIOCGIFCONF || STUB_LOAD_INTERFACES */

/**********************************************************************
 *
 *  load_interfaces()
 *
 *  Stub function for those without SIOCGIFCONF
 */

void load_interfaces()
{
    return;
}

#endif /* SIOCGIFCONF && !STUB_LOAD_INTERFACES */
@


1.11
log
@sudo 1.5.9--fixes some parser bugs
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.10
log
@sudo 1.5.8p2
@
text
@d4 1
a4 1
 *  CU sudo version 1.5.8
a46 3
#if defined(HAVE_MALLOC_H) && !defined(STDC_HEADERS)
#include <malloc.h>   
#endif /* HAVE_MALLOC_H && !STDC_HEADERS */
a76 5
#if !defined(STDC_HEADERS) && !defined(__GNUC__)
extern char *malloc	__P((size_t));
extern char *realloc	__P((VOID *, size_t));
#endif /* !STDC_HEADERS && !__GNUC__ */

d78 1
a78 1
static const char rcsid[] = "$Sudo: interfaces.c,v 1.50 1999/02/26 06:19:49 millert Exp $";
d121 1
a121 5
	ifconf_buf = ifconf_buf ? realloc(ifconf_buf, len) : malloc(len);
	if (ifconf_buf == NULL) {
	    (void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	    exit(1);
	}
d150 1
a150 1
     * malloc() space for interfaces array
d152 1
a152 5
    interfaces = (struct interface *) malloc(sizeof(struct interface) * n);
    if (interfaces == NULL) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }
d232 2
a233 2
	if (num_interfaces != 0) {
	    interfaces = (struct interface *) realloc(interfaces,
d235 1
a235 6
	    if (interfaces == NULL) {
		perror("realloc");
		(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
		exit(1);
	    }
	} else {
a236 1
	}
@


1.9
log
@sudo 1.5.8
@
text
@d55 1
d86 1
a86 1
static const char rcsid[] = "$Sudo: interfaces.c,v 1.49 1999/02/03 04:32:15 millert Exp $";
@


1.8
log
@fd leak; oops
@
text
@d4 2
a5 1
 *  CU sudo version 1.5.7
d85 1
a85 1
static const char rcsid[] = "$From: interfaces.c,v 1.46 1998/12/07 21:16:00 millert Exp $";
@


1.7
log
@sudo 1.5.7
@
text
@d84 1
a84 1
static const char rcsid[] = "$From: interfaces.c,v 1.45 1998/11/18 20:31:25 millert Exp $";
d144 1
d259 1
@


1.6
log
@sudo 1.5.6
@
text
@d1 1
a1 1
/*	$OpenBSD: interfaces.c,v 1.5 1998/03/31 06:41:02 millert Exp $	*/
d4 1
a4 1
 *  CU sudo version 1.5.6
a30 4
#ifndef lint
static char rcsid[] = "$From: interfaces.c,v 1.38 1998/09/14 15:48:05 millert Exp $";
#endif /* lint */

d54 2
a55 1
#ifdef HAVE_SYS_SOCKIO_H
d57 1
a57 3
#else
#include <sys/ioctl.h>
#endif /* HAVE_SYS_SOCKIO_H */
a72 1
#include <sys/time.h>
a75 1
#include <options.h>
d83 4
d129 1
a129 1
	    perror("malloc");
a162 1
	perror("malloc");
@


1.5
log
@sudo 1.5.5
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 *  CU sudo version 1.5.5
d32 1
a32 1
static char rcsid[] = "Id: interfaces.c,v 1.34 1998/03/31 05:05:37 millert Exp $";
d111 1
a111 1
    struct ifreq ifreq, *ifr;
a112 1
    unsigned int localhost_mask;
d115 1
a115 1
    char *ifconf_buf = NULL;
a119 3
    /* so we can skip localhost and its ilk */
    localhost_mask = inet_addr("127.0.0.0");

d130 1
a130 4
	if (ifconf_buf == NULL)
	    ifconf_buf = (char *) malloc(len);
	else
	    ifconf_buf = (char *) realloc(ifconf_buf, len);
d172 1
a172 1
     * for each interface, get the ip address and netmask
d174 1
a174 1
    for (ifreq.ifr_name[0] = '\0', i = 0; i < ifconf->ifc_len; ) {
d176 1
a176 1
	ifr = (struct ifreq *) ((caddr_t) ifconf->ifc_req + i);
d179 1
d182 1
a182 2
	    i += sizeof(ifr->ifr_name) + ifr->ifr_addr.sa_len;
	else
a183 1
	    i += sizeof(struct ifreq);
d188 1
a188 1
	    strncmp(ifr->ifr_name, ifreq.ifr_name, sizeof(ifr->ifr_name)) == 0)
d191 3
a193 2
	/* make a working copy... */
	ifreq = *ifr;
d195 12
a206 9
	/* get the ip address */
#ifdef _ISC
	STRSET(SIOCGIFADDR, (caddr_t) &ifreq, sizeof(ifreq));
	if (ioctl(sock, I_STR, (caddr_t) &strioctl) < 0) {
#else
	if (ioctl(sock, SIOCGIFADDR, (caddr_t) &ifreq)) {
#endif /* _ISC */
	    /* non-fatal error if interface is down or not supported */
	    if (errno == EADDRNOTAVAIL || errno == ENXIO || errno == EAFNOSUPPORT)
a208 6
	    (void) fprintf(stderr, "%s: Error, ioctl: SIOCGIFADDR ", Argv[0]);
	    perror("");
	    exit(1);
	}
	sin = (struct sockaddr_in *) &ifreq.ifr_addr;

d210 1
d213 3
d217 2
d221 1
a221 1
	STRSET(SIOCGIFNETMASK, (caddr_t) &ifreq, sizeof(ifreq));
d224 1
a224 1
	if (ioctl(sock, SIOCGIFNETMASK, (caddr_t) &ifreq) == 0) {
d226 1
a226 1
	    sin = (struct sockaddr_in *) &ifreq.ifr_addr;
d242 1
a242 5
	/* avoid localhost and friends */
	if ((interfaces[num_interfaces].addr.s_addr &
	    interfaces[num_interfaces].netmask.s_addr) == localhost_mask)
	    continue;

@


1.4
log
@sudo 1.5.4
@
text
@d4 1
a4 1
 *  CU sudo version 1.5.4
d32 1
a32 1
static char rcsid[] = "Id: interfaces.c,v 1.28 1998/01/13 04:48:17 millert Exp $";
d87 1
a110 1
    char ifconf_buf[sizeof(struct ifconf) + BUFSIZ];
d113 1
a113 1
    unsigned long localhost_mask;
d115 2
d133 12
a144 3
    ifconf = (struct ifconf *) ifconf_buf;
    ifconf->ifc_buf = (caddr_t) (ifconf_buf + sizeof(struct ifconf));
    ifconf->ifc_len = sizeof(ifconf_buf) - sizeof(struct ifconf);
d146 1
a146 1
    /* networking may not be installed in kernel */
d148 2
a149 2
    STRSET(SIOCGIFCONF, (caddr_t) ifconf, sizeof(ifconf_buf));
    if (ioctl(sock, I_STR, (caddr_t) &strioctl) < 0)
d151 1
a151 1
    if (ioctl(sock, SIOCGIFCONF, (caddr_t) ifconf) < 0)
d153 9
a161 1
	return;
d269 1
@


1.3
log
@OpenBSD tags (and preserve sudo tags)
updates from my sudo source tree:
    logging.c: deal with maxfilelen < 0 case
    sudo.c: correct error message if mode/owner wrong and not statable by owner
    compat.h: fix seteuid macro
@
text
@d4 1
a4 1
 *  CU sudo version 1.5.3
d32 1
a32 1
static char rcsid[] = "Id: interfaces.c,v 1.27 1996/11/14 02:37:16 millert Exp $";
@


1.2
log
@Updated to sudo 1.5.3
@
text
@d1 2
d32 1
a32 1
static char rcsid[] = "$Id: interfaces.c,v 1.27 1996/11/14 02:37:16 millert Exp $";
@


1.1
log
@sudo 1.5.2
@
text
@d2 1
a2 1
 *  CU sudo version 1.5.2
d30 1
a30 1
static char rcsid[] = "$Id: interfaces.c,v 1.26 1996/10/07 05:05:33 millert Exp $";
@
