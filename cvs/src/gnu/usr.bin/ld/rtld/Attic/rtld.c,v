head	1.43;
access;
symbols
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.26
	OPENBSD_5_0:1.41.0.24
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.22
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.20
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.16
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.18
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.14
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.12
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.10
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.8
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.41.0.6
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.4
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.39.0.4
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.39.0.2
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.38.0.6
	OPENBSD_3_6_BASE:1.38
	OPENBSD_3_5:1.38.0.4
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	OPENBSD_3_3:1.36.0.2
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.18.0.6
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.18.0.4
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2013.02.02.13.47.17;	author miod;	state dead;
branches;
next	1.42;

1.42
date	2012.04.16.19.40.01;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.21.01.40.22;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.30.20.13.12;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.08.20.47.07;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.15.23.13.06;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.05.08.16.30.52;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.19.23.35.02;	author espie;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2003.01.19.23.33.40;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.19.23.28.46;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.05.09.04.10;	author pvalchev;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.11.23.24.39;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.12.02.23.17.36;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.12.02.09.00.11;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.07.01.25.34;	author marc;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.27.22.06.06;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.19.19.28.12;	author marc;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.17.20.33.29;	author marc;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.15.21.05.57;	author marc;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.10.17.28.16;	author marc;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.03.09.28.07;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.07.17.07.10;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.14.04.25.32;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.08.07.40.25;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.09.21.51.58;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.27.19.33.09;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.24.17.56.34;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.03.17.19.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.11.22.27.07;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.11.21.38.47;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.12.10.00.11.02;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.12.09.18.10.24;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.10.26.22.51.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.08.28.20.45.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.03.26.19.47.29;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.07.01.21.13.34;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.01.19.14.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.28.21.05.24;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.28.18.16.56;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.16.01.25.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.19.57.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.20.07.19.40;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.40.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.40.58;	author deraadt;	state Exp;
branches;
next	;

1.36.2.1
date	2003.05.31.00.53.01;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.43
log
@The a.out rtld is no longer used.
@
text
@/*	$OpenBSD: rtld.c,v 1.42 2012/04/16 19:40:01 miod Exp $	*/
/*	$NetBSD: rtld.c,v 1.43 1996/01/14 00:35:17 pk Exp $	*/
/*
 * Copyright (c) 1993 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/mman.h>
#ifndef MAP_COPY
#define MAP_COPY	MAP_PRIVATE
#endif
#include <err.h>
#include <errno.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <a.out.h>
#include <limits.h>
#include <stab.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#if __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#include "ld.h"

/*
 * Stack protector dummies.
 * Ideally, a scheme to compile these stubs from libc should be used, but
 * this would end up dragging too much code from libc here.
 */
long __guard[8] = {0, 0, 0, 0, 0, 0, 0, 0};
void
__stack_smash_handler(char func[], int damaged)
{
	_exit(127);
}

#ifndef MAP_ANON
#define MAP_ANON	0
#define anon_open() do {					\
	if ((anon_fd = open("/dev/zero", O_RDWR, 0)) == -1)	\
		err("open: %s", "/dev/zero");			\
} while (0)
#define anon_close() do {	\
	(void)close(anon_fd);	\
	anon_fd = -1;		\
} while (0)
#else
#define anon_open()
#define anon_close()
#endif

/*
 * Loader private data, hung off <so_map>->som_spd
 */
struct somap_private {
	int		spd_version;
	struct so_map	*spd_parent;
	int		spd_refcount;
	int		spd_flags;
#define RTLD_MAIN	1
#define RTLD_RTLD	2
#define RTLD_DL		4
#define RTLD_INITED	8
	size_t		spd_size;

#ifdef SUN_COMPAT
	long		spd_offset;	/* Correction for Sun main programs */
#endif
	struct dep_node	*first_child;
	struct dep_node	*last_child;
};

struct dep_node {
	struct dep_node *next_sibling;
	struct so_map *data;
};

#define LM_PRIVATE(smp)	((struct somap_private *)(smp)->som_spd)

#ifdef SUN_COMPAT
#define LM_OFFSET(smp)	(LM_PRIVATE(smp)->spd_offset)
#else
#define LM_OFFSET(smp)	(0)
#endif

/* Base address for section_dispatch_table entries */
#define LM_LDBASE(smp)	(smp->som_addr + LM_OFFSET(smp))

/* Start of text segment */
#define LM_TXTADDR(smp)	(smp->som_addr == (caddr_t)0 ? PAGSIZ : 0)

/* Start of run-time relocation_info */
#define LM_REL(smp)	((struct relocation_info *) \
	(smp->som_addr + LM_OFFSET(smp) + LD_REL((smp)->som_dynamic)))

/* Start of symbols */
#define LM_SYMBOL(smp, i)	((struct nzlist *) \
	(smp->som_addr + LM_OFFSET(smp) + LD_SYMBOL((smp)->som_dynamic) + \
		i * (LD_VERSION_NZLIST_P(smp->som_dynamic->d_version) ? \
			sizeof(struct nzlist) : sizeof(struct nlist))))

/* Start of hash table */
#define LM_HASH(smp)	((struct rrs_hash *) \
	((smp)->som_addr + LM_OFFSET(smp) + LD_HASH((smp)->som_dynamic)))

/* Start of strings */
#define LM_STRINGS(smp)	((char *) \
	((smp)->som_addr + LM_OFFSET(smp) + LD_STRINGS((smp)->som_dynamic)))

/* Start of search paths */
#define LM_PATHS(smp)	((char *) \
	((smp)->som_addr + LM_OFFSET(smp) + LD_PATHS((smp)->som_dynamic)))

/* End of text */
#define LM_ETEXT(smp)	((char *) \
	((smp)->som_addr + LM_TXTADDR(smp) + LD_TEXTSZ((smp)->som_dynamic)))

/* PLT is in data segment, so don't use LM_OFFSET here */
#define LM_PLT(smp)	((jmpslot_t *) \
	((smp)->som_addr + LD_PLT((smp)->som_dynamic)))

/* Parent of link map */
#define LM_PARENT(smp)	(LM_PRIVATE(smp)->spd_parent)

static char		__main_progname[] = "main";
static char		*main_progname = __main_progname;
static char		us[] = "/usr/libexec/ld.so";

char			**environ;
char			*__progname = us;
/* int			errno; */

static int		careful;
static int		anon_fd = -1;

struct so_map		*link_map_head, *main_map;
struct so_map		**link_map_tail = &link_map_head;
struct rt_symbol	*rt_symbol_head;

static char		*ld_library_path;
static char		*ld_preload_path;
static int		no_intern_search;
static int		ld_suppress_warnings;
static int		ld_warn_non_pure_code;

static int		ld_tracing;

static void		*__dlopen(const char *, int);
static int		__dlclose(void *);
static void		*__dlsym(void *, const char *);
static int		__dlctl(void *, int, void *);
static void		__dlexit(void);

static struct ld_entry	ld_entry = {
	__dlopen, __dlclose, __dlsym, __dlctl, __dlexit
};

       void		xprintf(char *, ...);
       int		rtld(int, struct crt_ldso *, struct _dynamic *);
       void		binder_entry(void);
       long		binder(jmpslot_t *);
static int		load_subs(struct so_map *);
static struct so_map	*map_object(struct sod *, struct so_map *);
static void		unmap_object(struct so_map *);
static struct so_map	*alloc_link_map(	char *, struct sod *,
						struct so_map *, caddr_t,
						size_t, struct _dynamic *);
static void		free_link_map(struct so_map *);
static inline void	check_text_reloc(	struct relocation_info *,
						struct so_map *,
						caddr_t);
static void		init_maps(struct so_map *);
static void		reloc_map(struct so_map *);
static void		reloc_copy(struct so_map *);
static void		call_map(struct so_map *, char *);
static char		*rtfindlib(char *, int, int, int *, char *);
static struct nzlist	*lookup(const char *, struct so_map **, int);
static inline struct rt_symbol	*lookup_rts(const char *);
static struct rt_symbol	*enter_rts(const char *, long, int, caddr_t,
				   long, struct so_map *);
static void		maphints(void);
static void		unmaphints(void);

static void		preload(char *);
static void		ld_trace(struct so_map *);

static inline int
strcmp (const char *s1, const char *s2)
{
	while (*s1 == *s2++)
		if (*s1++ == 0)
			return (0);
	return (*(unsigned char *)s1 - *(unsigned char *)--s2);
}

#include "md-static-funcs.c"

/*
 * Called from assembler stub that has set up crtp (passed from crt0)
 * and dp (our __DYNAMIC).
 */
int
rtld(int version, struct crt_ldso *crtp, struct _dynamic *dp)
{
	int			n;
	int			nreloc;		/* # of ld.so relocations */
	struct relocation_info	*reloc;
	struct so_debug		*ddp;
	struct so_map		*smp;

	/* Check version */
	if (		version != CRT_VERSION_BSD_2 &&
			version != CRT_VERSION_BSD_3 &&
			version != CRT_VERSION_BSD_4 &&
			version != CRT_VERSION_SUN)
		return -1;

	/* Fixup __DYNAMIC structure */
	(long)dp->d_un.d_sdt += crtp->crt_ba;

	/* Divide by hand to avoid possible use of library division routine */
	for (	nreloc = 0, n = LD_RELSZ(dp);
		n > 0;
		n -= sizeof(struct relocation_info) ) nreloc++;

	
	/* Relocate ourselves */
	for (reloc = (struct relocation_info *)(LD_REL(dp) + crtp->crt_ba);
	    nreloc; nreloc--, reloc++) {
		long	addr = reloc->r_address + crtp->crt_ba;
		md_relocate_simple(reloc, crtp->crt_ba, (char*)addr);
	}

	if (version >= CRT_VERSION_BSD_4)
		__progname = crtp->crt_ldso;

	if (version >= CRT_VERSION_BSD_3)
		main_progname = crtp->crt_prog;

	/* Setup out (private) environ variable */
	environ = crtp->crt_ep;

	if (issetugid())
		careful = 1;

	if (careful) {
		unsetenv("LD_LIBRARY_PATH");
		unsetenv("LD_PRELOAD");
	}

	/* Setup directory search */
	ld_library_path = getenv("LD_LIBRARY_PATH");
	add_search_path(ld_library_path);
	if (getenv("LD_NOSTD_PATH") == NULL)
		std_search_path();

	ld_suppress_warnings = getenv("LD_SUPPRESS_WARNINGS") != NULL;
	ld_warn_non_pure_code = getenv("LD_WARN_NON_PURE_CODE") != NULL;

	no_intern_search = careful || getenv("LD_NO_INTERN_SEARCH") != 0;

	anon_open();

	/*
	 * Init object administration. We start off with a map description
	 * for `main' and `rtld'.
	 */
	smp = alloc_link_map(main_progname, (struct sod *)0, (struct so_map *)0,
					(caddr_t)0, 0, crtp->crt_dp);
	LM_PRIVATE(smp)->spd_refcount++;
	LM_PRIVATE(smp)->spd_flags |= RTLD_MAIN;
	main_map = smp;

	smp = alloc_link_map(us, (struct sod *)0, (struct so_map *)0,
					(caddr_t)crtp->crt_ba, 0, dp);
	LM_PRIVATE(smp)->spd_refcount++;
	LM_PRIVATE(smp)->spd_flags |= RTLD_RTLD;

	/* Fill in some field in main's __DYNAMIC structure */
	if (version >= CRT_VERSION_BSD_4)
		crtp->crt_ldentry = &ld_entry;
	else
		crtp->crt_dp->d_entry = &ld_entry;

	/* Handle LD_PRELOAD's here */
	ld_preload_path = getenv("LD_PRELOAD");
	if (ld_preload_path != NULL)
		preload(ld_preload_path);

	/* Load subsidiary objects into the process address space */
	ld_tracing = (int)getenv("LD_TRACE_LOADED_OBJECTS");
	load_subs(link_map_head);
	if (ld_tracing) {
		ld_trace(link_map_head);
		exit(0);
	}

	init_maps(link_map_head);

	crtp->crt_dp->d_un.d_sdt->sdt_loaded = link_map_head->som_next;

	ddp = crtp->crt_dp->d_debug;
	ddp->dd_cc = rt_symbol_head;
	if (ddp->dd_in_debugger) {
		caddr_t	addr = (caddr_t)((long)crtp->crt_bp & (~(PAGSIZ - 1)));

		/* Set breakpoint for the benefit of debuggers */
		if (mprotect(addr, PAGSIZ,
		    PROT_READ|PROT_WRITE|PROT_EXEC) == -1) {
			err(1, "Cannot set breakpoint (%s)", main_progname);
		}
		md_set_breakpoint((long)crtp->crt_bp, (long *)&ddp->dd_bpt_shadow);
		if (mprotect(addr, PAGSIZ, PROT_READ|PROT_EXEC) == -1) {
			err(1, "Cannot re-protect breakpoint (%s)",
				main_progname);
		}

		ddp->dd_bpt_addr = crtp->crt_bp;
		if (link_map_head)
			ddp->dd_sym_loaded = 1;
	}

	/* Close the hints file */
	unmaphints();

	/* Close our file descriptor */
	(void)close(crtp->crt_ldfd);
	anon_close();
	return 0;
}

static void
link_sub(struct so_map *dep, struct so_map *p)
{
	struct dep_node *n;
	struct somap_private *pp;

	n = xmalloc(sizeof *n);
	n->data = dep;
	n->next_sibling = NULL;
	pp = LM_PRIVATE(p);
	if (pp->first_child) {
		pp->last_child->next_sibling = n;
		pp->last_child = n;
	} else {
		pp->first_child = pp->last_child = n;
	}
}

static int
load_subs(struct so_map	*smp)
{

	for (; smp; smp = smp->som_next) {
		struct sod	*sodp;
		long		next = 0;

		if (LM_PRIVATE(smp)->spd_flags & RTLD_RTLD)
			continue;

		if (smp->som_dynamic)
			next = LD_NEED(smp->som_dynamic);

		while (next) {
			struct so_map	*newmap;

			sodp = (struct sod *)(LM_LDBASE(smp) + next);

			if ((newmap = map_object(sodp, smp)) == NULL) {
				if (!ld_tracing) {
				    if (smp != main_map)
					if (sodp->sod_library)
					    err(1, "%s(%s): lib%s.so.%d.%d",
						main_progname,
						smp->som_path,
						sodp->sod_name+LM_LDBASE(smp),
						sodp->sod_major,
						sodp->sod_minor);
					else
					    err(1, "%s(%s): %s",
						main_progname,
						smp->som_path,
						sodp->sod_name+LM_LDBASE(smp));
				    else
					if (sodp->sod_library)
					    err(1, "%s: lib%s.so.%d.%d",
						main_progname,
						sodp->sod_name+LM_LDBASE(smp),
						sodp->sod_major,
						sodp->sod_minor);
					else
					    err(1, "%s: %s",
						main_progname,
						sodp->sod_name+LM_LDBASE(smp));
				}
				newmap = alloc_link_map(NULL, sodp, smp,
				    0, 0, 0);
			} else {
				link_sub(newmap, smp);
			}
			LM_PRIVATE(newmap)->spd_refcount++;
			next = sodp->sod_next;
		}
	}
	return 0;
}

void
ld_trace(struct so_map *smp)
{
	char	*fmt1, *fmt2, *fmt, *main_local;
	int	c;

	if ((main_local = getenv("LD_TRACE_LOADED_OBJECTS_PROGNAME")) == NULL)
		main_local = "";

	if ((fmt1 = getenv("LD_TRACE_LOADED_OBJECTS_FMT1")) == NULL)
		fmt1 = "\t-l%o.%m => %p (%x)\n";

	if ((fmt2 = getenv("LD_TRACE_LOADED_OBJECTS_FMT2")) == NULL)
		fmt2 = "\t%o (%x)\n";

	for (; smp; smp = smp->som_next) {
		struct sod	*sodp;
		char		*name, *path;

		if ((sodp = smp->som_sod) == NULL)
			continue;

		name = (char *)sodp->sod_name;
		if (LM_PARENT(smp))
			name += (long)LM_LDBASE(LM_PARENT(smp));

		if ((path = smp->som_path) == NULL)
			path = "not found";

		fmt = sodp->sod_library ? fmt1 : fmt2;
		while ((c = *fmt++) != '\0') {
			switch (c) {
			default:
				putchar(c);
				continue;
			case '\\':
				switch (c = *fmt) {
				case '\0':
					continue;
				case 'n':
					putchar('\n');
					break;
				case 't':
					putchar('\t');
					break;
				}
				break;
			case '%':
				switch (c = *fmt) {
				case '\0':
					continue;
				case '%':
				default:
					putchar(c);
					break;
				case 'A':
					printf("%s", main_local);
					break;
				case 'a':
					printf("%s", main_progname);
					break;
				case 'o':
					printf("%s", name);
					break;
				case 'm':
					printf("%d", sodp->sod_major);
					break;
				case 'n':
					printf("%d", sodp->sod_minor);
					break;
				case 'p':
					printf("%s", path);
					break;
				case 'x':
					printf("%p", smp->som_addr);
					break;
				}
				break;
			}
			++fmt;
		}
	}
}

/*
 * Allocate a new link map for shared object NAME loaded at ADDR as a
 * result of the presence of link object LOP in the link map PARENT.
 */
static struct so_map *
alloc_link_map(char *path, struct sod *sodp, struct so_map *parent,
	       caddr_t addr, size_t size, struct _dynamic *dp)
{
	struct so_map		*smp;
	struct somap_private	*smpp;

	smpp = (struct somap_private *)xmalloc(sizeof(struct somap_private));
	smp = (struct so_map *)xmalloc(sizeof(struct so_map));
	smp->som_next = NULL;
	*link_map_tail = smp;
	link_map_tail = &smp->som_next;

	/*smp->som_sodbase = 0; NOT USED */
	smp->som_write = 0;
	smp->som_addr = addr;
	smp->som_path = path?strdup(path):NULL;
	smp->som_sod = sodp;
	smp->som_dynamic = dp;
	smp->som_spd = (caddr_t)smpp;

	smpp->spd_refcount = 0;
	smpp->spd_flags = 0;
	smpp->spd_parent = parent;
	smpp->spd_size = size;
	smpp->first_child = NULL;
	smpp->last_child = NULL;

#ifdef SUN_COMPAT
	smpp->spd_offset =
		(addr==0 && dp && dp->d_version==LD_VERSION_SUN) ? PAGSIZ : 0;
#endif
	return smp;
}

/*
 * Free the link map for an object being unmapped.  The link map
 * has already been removed from the link map list, so it can't be used
 * after it's been unmapped.
 */
static void
free_link_map(struct so_map *smp)
{

	if ((LM_PRIVATE(smp)->spd_flags & RTLD_DL) != 0) {
		/* free synthetic sod structure allocated in __dlopen() */
		free((char *)smp->som_sod->sod_name);
		free(smp->som_sod);
	}

	/* free the link map structure. */
	free(smp->som_spd);
	if (smp->som_path != NULL)
		free(smp->som_path);
	free(smp);
}

/*
 * Map object identified by link object SODP which was found
 * in link map SMP.
 */
static struct so_map *
map_object(struct sod *sodp, struct so_map *smp)
{
	char		*name;
	struct _dynamic	*dp;
	char		*path, *ipath;
	int		fd, sverrno;
	caddr_t		addr;
	struct exec	hdr;
	int		usehints = 0;
	struct so_map	*p;

	name = (char *)sodp->sod_name;
	if (smp)
		name += (long)LM_LDBASE(smp);

	if (sodp->sod_library) {
		usehints = 1;
again:
		if (smp == NULL || no_intern_search ||
		    LD_PATHS(smp->som_dynamic) == 0) {
			ipath = NULL;
		} else {
			ipath = LM_PATHS(smp);
			add_search_path(ipath);
		}

		path = rtfindlib(name, sodp->sod_major,
				 sodp->sod_minor, &usehints, ipath);
		if (ipath)
			remove_search_path(ipath);

		if (path == NULL && smp != main_map && main_map != NULL &&
		    !no_intern_search && 
		    LD_PATHS(main_map->som_dynamic) != 0) {
		    	ipath = LM_PATHS(main_map);
			add_search_path(ipath);
			path = rtfindlib(name, sodp->sod_major,
			     sodp->sod_minor, &usehints, ipath);
			remove_search_path(ipath);
		}

		if (path == NULL) {
			errno = ENOENT;
			return NULL;
		}
	} else {
		if (careful && *name != '/') {
			errno = EACCES;
			return NULL;
		}
		path = name;
	}

	/* Check if already loaded */
	for (p = link_map_head; p; p = p->som_next)
		if (p->som_path && strcmp(p->som_path, path) == 0)
			break;

	if (p != NULL)
		return p;

	if ((fd = open(path, O_RDONLY, 0)) == -1) {
		if (usehints) {
			usehints = 0;
			goto again;
		}
		return NULL;
	}

	if (read(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {
		sverrno = errno;
		(void)close(fd);
		errno = sverrno;
		return NULL;
	}

	if (N_BADMAG(hdr)) {
		(void)close(fd);
		errno = EFTYPE;
		return NULL;
	}

	if ((addr = mmap(0, hdr.a_text + hdr.a_data + hdr.a_bss,
	    PROT_READ|PROT_EXEC,
	    MAP_COPY, fd, 0)) == (caddr_t)MAP_FAILED) {
		sverrno = errno;
		(void)close(fd);
		errno = sverrno;
		return NULL;
	}

#if DEBUG
	xprintf("map1: 0x%x for 0x%x\n", addr, hdr.a_text + hdr.a_data + hdr.a_bss);
#endif

	if (mprotect(addr + hdr.a_text, hdr.a_data,
	    PROT_READ|PROT_WRITE|PROT_EXEC) != 0) {
		sverrno = errno;
		(void)close(fd);
		errno = sverrno;
		return NULL;
	}

	if (hdr.a_bss && mmap(addr + hdr.a_text + hdr.a_data, hdr.a_bss,
	    PROT_READ|PROT_WRITE,
	    MAP_ANON|MAP_COPY|MAP_FIXED,
	    anon_fd, 0) == (caddr_t)MAP_FAILED) {
		sverrno = errno;
		(void)close(fd);
		errno = sverrno;
		return NULL;
	}

	(void)close(fd);

	/* Assume _DYNAMIC is the first data item */
	dp = (struct _dynamic *)(addr+hdr.a_text);

	/* Fixup __DYNAMIC structure */
	(long)dp->d_un.d_sdt += (long)addr;

	return alloc_link_map(path, sodp, smp, addr,
	    hdr.a_text + hdr.a_data + hdr.a_bss, dp);
}

/*
 * Unmap a mapped object.
 */
static void
unmap_object(struct so_map *smp)
{
	struct so_map *p, **pp;

	/* remove from link map list */
	pp = &link_map_head;
	while ((p = *pp) != NULL) {
		if (p == smp)
			break;
		pp = &p->som_next;
	}
	if (p == NULL) {
		warnx("warning: link map entry for %s not on link map list!",
		    smp->som_path);
		return;
	}

	*pp = smp->som_next;			/* make list skip it */
	if (link_map_tail == &smp->som_next)	/* and readjust tail pointer */
		link_map_tail = pp;

	/* unmap from address space */
	(void)munmap(smp->som_addr, LM_PRIVATE(smp)->spd_size);
}

void init_dependent_before_main(struct so_map *smp)
{
	struct dep_node *n;

	LM_PRIVATE(smp)->spd_flags |= RTLD_INITED;

	for (n = LM_PRIVATE(smp)->first_child; n; n = n->next_sibling) {
		if (LM_PRIVATE(n->data)->spd_flags & RTLD_INITED)
			continue;
		init_dependent_before_main(n->data);
	}

	call_map(smp, ".init");
	call_map(smp, "__init");
	call_map(smp, "__GLOBAL__DI");
}

void
init_maps(struct so_map *head)
{
	struct so_map	*smp;

	/* Relocate all loaded objects according to their RRS segments */
	for (smp = head; smp; smp = smp->som_next) {
		if (LM_PRIVATE(smp)->spd_flags & RTLD_RTLD)
			continue;
		reloc_map(smp);
	}

	/* Copy any relocated initialized data. */
	for (smp = head; smp; smp = smp->som_next) {
		if (LM_PRIVATE(smp)->spd_flags & RTLD_RTLD)
			continue;
		reloc_copy(smp);
	}

	/* Call any object initialization routines. */
	for (smp = head; smp; smp = smp->som_next) {
		if (LM_PRIVATE(smp)->spd_flags & RTLD_RTLD)
			continue;
		if (LM_PRIVATE(smp)->spd_flags & RTLD_INITED)
			continue;
		init_dependent_before_main(smp);
	}
}

static inline void
check_text_reloc(struct relocation_info *r, struct so_map *smp, caddr_t addr)
{
	char	*sym;

	if (addr >= LM_ETEXT(smp))
		return;

	if (RELOC_EXTERN_P(r))
		sym = LM_STRINGS(smp) +
				LM_SYMBOL(smp, RELOC_SYMBOL(r))->nz_strx;
	else
		sym = "";

	if (ld_warn_non_pure_code && !ld_suppress_warnings)
		warnx("warning: non pure code in %s at %x (%s)",
				smp->som_path, r->r_address, sym);

	if (smp->som_write == 0 &&
		mprotect(smp->som_addr + LM_TXTADDR(smp),
		    LD_TEXTSZ(smp->som_dynamic),
		    PROT_READ|PROT_WRITE|PROT_EXEC) == -1) {

		err(1, "Cannot enable writes to %s:%s",
					main_progname, smp->som_path);
	}

	smp->som_write = 1;
}

static void
reloc_map(struct so_map *smp)
{
	struct _dynamic		*dp = smp->som_dynamic;
	struct relocation_info	*r = LM_REL(smp);
	struct relocation_info	*rend = r + LD_RELSZ(dp)/sizeof(*r);
	long			symbolbase = (long)LM_SYMBOL(smp, 0);
	char			*stringbase = LM_STRINGS(smp);
	int symsize		= LD_VERSION_NZLIST_P(dp->d_version) ?
					sizeof(struct nzlist) :
					sizeof(struct nlist);

	if (LD_PLTSZ(dp))
		md_fix_jmpslot(LM_PLT(smp),
				(long)LM_PLT(smp), (long)binder_entry);

	for (; r < rend; r++) {
		char	*sym;
		caddr_t	addr = smp->som_addr + r->r_address;

		check_text_reloc(r, smp, addr);

		if (RELOC_EXTERN_P(r)) {
			struct so_map	*src_map = NULL;
			struct nzlist	*p, *np;
			long	relocation = md_get_addend(r, addr);

			if (RELOC_LAZY_P(r))
				continue;

			p = (struct nzlist *)
				(symbolbase + symsize * RELOC_SYMBOL(r));

			if (p->nz_type == (N_SETV + N_EXT))
				src_map = smp;

			sym = stringbase + p->nz_strx;

			np = lookup(sym, &src_map, 0/*XXX-jumpslots!*/);
			if (np == NULL)
				errx(1, "Undefined symbol \"%s\" in %s:%s",
					sym, main_progname, smp->som_path);

			/*
			 * Found symbol definition.
			 * If it's in a link map, adjust value
			 * according to the load address of that map.
			 * Otherwise it's a run-time allocated common
			 * whose value is already up-to-date.
			 */
			relocation += np->nz_value;
			if (src_map)
				relocation += (long)src_map->som_addr;

			if (RELOC_PCREL_P(r))
				relocation -= (long)smp->som_addr;

			if (RELOC_COPY_P(r) && src_map) {
				(void)enter_rts(sym,
					(long)addr,
					N_DATA + N_EXT,
					src_map->som_addr + np->nz_value,
					np->nz_size, src_map);
				continue;
			}
			md_relocate(r, relocation, addr, 0);

		} else {
			md_relocate(r,
#ifdef SUN_COMPAT
				md_get_rt_segment_addend(r, addr)
#else
				md_get_addend(r, addr)
#endif
					+ (long)smp->som_addr, addr, 0);
		}

	}

	if (smp->som_write) {
		if (mprotect(smp->som_addr + LM_TXTADDR(smp),
		    LD_TEXTSZ(smp->som_dynamic),
		    PROT_READ|PROT_EXEC) == -1) {
			err(1, "Cannot disable writes to %s:%s",
			    main_progname, smp->som_path);
		}
		smp->som_write = 0;
	}
}

static void
reloc_copy(struct so_map *smp)
{
	struct rt_symbol	*rtsp;

	for (rtsp = rt_symbol_head; rtsp; rtsp = rtsp->rt_next)
		if ((rtsp->rt_smp == NULL || rtsp->rt_smp == smp) &&
				rtsp->rt_sp->nz_type == N_DATA + N_EXT) {
			bcopy(rtsp->rt_srcaddr, (caddr_t)rtsp->rt_sp->nz_value,
							rtsp->rt_sp->nz_size);
		}
}

static void
call_map(struct so_map *smp, char *sym)
{
	struct so_map		*src_map = smp;
	struct nzlist		*np;

	np = lookup(sym, &src_map, 1);
	if (np)
		(*(void (*) (void))(src_map->som_addr + np->nz_value))();
}

/*
 * Run-time common symbol table.
 */

#define RTC_TABSIZE		57
static struct rt_symbol 	*rt_symtab[RTC_TABSIZE];

/*
 * Compute hash value for run-time symbol table
 */
static inline int
hash_string(const char *key)
{
	const char *cp;
	int k;

	cp = key;
	k = 0;
	while (*cp)
		k = (((k << 1) + (k >> 14)) ^ (*cp++)) & 0x3fff;

	return k;
}

/*
 * Lookup KEY in the run-time common symbol table.
 */

static inline struct rt_symbol *
lookup_rts(const char *key)
{
	int			hashval;
	struct rt_symbol	*rtsp;

	/* Determine which bucket.  */

	hashval = hash_string(key) % RTC_TABSIZE;

	/* Search the bucket.  */

	for (rtsp = rt_symtab[hashval]; rtsp; rtsp = rtsp->rt_link)
		if (strcmp(key, rtsp->rt_sp->nz_name) == 0)
			return rtsp;

	return NULL;
}

static struct rt_symbol *
enter_rts(const char *name, long value, int type, caddr_t srcaddr, long size,
	  struct so_map *smp)
{
	int			hashval;
	struct rt_symbol	*rtsp, **rpp;

	/* Determine which bucket */
	hashval = hash_string(name) % RTC_TABSIZE;

	/* Find end of bucket */
	for (rpp = &rt_symtab[hashval]; *rpp; rpp = &(*rpp)->rt_link)
		;

	/* Allocate new common symbol */
	rtsp = (struct rt_symbol *)malloc(sizeof(struct rt_symbol));
	rtsp->rt_sp = (struct nzlist *)malloc(sizeof(struct nzlist));
	rtsp->rt_sp->nz_name = strdup(name);
	rtsp->rt_sp->nz_value = value;
	rtsp->rt_sp->nz_type = type;
	rtsp->rt_sp->nz_size = size;
	rtsp->rt_srcaddr = srcaddr;
	rtsp->rt_smp = smp;
	rtsp->rt_link = NULL;

	/* Link onto linear list as well */
	rtsp->rt_next = rt_symbol_head;
	rt_symbol_head = rtsp;

	*rpp = rtsp;

	return rtsp;
}


/*
 * Lookup NAME in the link maps. The link map producing a definition
 * is returned in SRC_MAP. If SRC_MAP is not NULL on entry the search is
 * confined to that map. If STRONG is set, the symbol returned must
 * have a proper type (used by binder()).
 */
static struct nzlist *
lookup(const char *name, struct so_map **src_map, int strong)
{
	long			common_size = 0;
	struct so_map		*smp, *weak_smp;
	struct rt_symbol	*rtsp;
	struct nzlist		*weak_np = 0;

	if ((rtsp = lookup_rts(name)) != NULL) {
		/* Common symbol is not a member of particular shlib. */
		*src_map = NULL;
		return rtsp->rt_sp;
	}

	weak_smp = NULL; /* XXX - gcc! */

	/*
	 * Search all maps for a definition of NAME
	 */
	for (smp = link_map_head; smp; smp = smp->som_next) {
		int		buckets;
		long		hashval;
		struct rrs_hash	*hp;
		const char	*cp;
		struct	nzlist	*np;

		/* Some local caching */
		long		symbolbase;
		struct rrs_hash	*hashbase;
		char		*stringbase;
		int		symsize;

		if (*src_map && smp != *src_map)
			continue;

		if ((buckets = LD_BUCKETS(smp->som_dynamic)) == 0)
			continue; 

		if (LM_PRIVATE(smp)->spd_flags & RTLD_RTLD)
			continue;

restart:
		/*
		 * Compute bucket in which the symbol might be found.
		 */
		for (hashval = 0, cp = name; *cp; cp++)
			hashval = (hashval << 1) + *cp;

		hashval = (hashval & 0x7fffffff) % buckets;

		hashbase = LM_HASH(smp);
		hp = hashbase + hashval;
		if (hp->rh_symbolnum == -1)
			/* Nothing in this bucket */
			continue;

		symbolbase = (long)LM_SYMBOL(smp, 0);
		stringbase = LM_STRINGS(smp);
		symsize	= LD_VERSION_NZLIST_P(smp->som_dynamic->d_version)?
				sizeof(struct nzlist) :
				sizeof(struct nlist);
		while (hp) {
			np = (struct nzlist *)
				(symbolbase + hp->rh_symbolnum * symsize);
			cp = stringbase + np->nz_strx;
			if (strcmp(cp, name) == 0)
				break;
			if (hp->rh_next == 0)
				hp = NULL;
			else
				hp = hashbase + hp->rh_next;
		}
		if (hp == NULL)
			/* Nothing in this bucket */
			continue;

		/*
		 * We have a symbol with the name we're looking for.
		 */
		if (np->nz_type == N_INDR+N_EXT) {
			/*
			 * Next symbol gives the aliased name. Restart
			 * search with new name and confine to this map.
			 */
			name = stringbase + (++np)->nz_strx;
			*src_map = smp;
			goto restart;
		}

		if (np->nz_value == 0)
			/* It's not a definition */
			continue;

		if (np->nz_type == N_UNDF+N_EXT && np->nz_value != 0) {
			if (N_AUX(&np->nlist) == AUX_FUNC) {
				/* It's a weak function definition */
				if (strong)
					continue;
			} else {
				/* It's a common, note value and continue search */
				if (common_size < np->nz_value)
					common_size = np->nz_value;
				continue;
			}
		}
		if (N_BIND(&np->nlist) != BIND_WEAK) {
			*src_map = smp;
			return np;
		}
		if (N_BIND(&np->nlist) == BIND_WEAK && weak_np == 0) {
			weak_np = np;
			weak_smp = smp;
			continue;
		}
	}

	if (weak_np) {
		*src_map = weak_smp;
		return weak_np;
	}

	if (common_size == 0)
		/* Not found */
		return NULL;

	/*
	 * It's a common, enter into run-time common symbol table.
	 */
	rtsp = enter_rts(name, (long)calloc(1, common_size),
					N_UNDF + N_EXT, 0, common_size, NULL);

	/* Common symbol is not a member of particular shlib. */
	*src_map = NULL;

#if DEBUG
xprintf("Allocating common: %s size %d at %#x\n", name, common_size, rtsp->rt_sp->nz_value);
#endif

	return rtsp->rt_sp;
}


/*
 * This routine is called from the jumptable to resolve
 * procedure calls to shared objects.
 */
long
binder(jmpslot_t *jsp)
{
	struct so_map	*smp, *src_map = NULL;
	long		addr;
	char		*sym;
	struct nzlist	*np;
	int		index;

	/*
	 * Find the PLT map that contains JSP.
	 */
	for (smp = link_map_head; smp; smp = smp->som_next) {
		if (LM_PLT(smp) < jsp &&
			jsp < LM_PLT(smp) + LD_PLTSZ(smp->som_dynamic)/sizeof(*jsp))
			break;
	}

	if (smp == NULL)
		errx(1, "Call to binder from unknown location: %p", jsp);

	index = jsp->reloc_index & JMPSLOT_RELOC_MASK;

	/* Get the local symbol this jmpslot refers to */
	sym = LM_STRINGS(smp) +
		LM_SYMBOL(smp,RELOC_SYMBOL(&LM_REL(smp)[index]))->nz_strx;

	np = lookup(sym, &src_map, 1);
	if (np == NULL)
		errx(1, "Undefined symbol \"%s\" called from %s:%s at %p",
				sym, main_progname, smp->som_path, jsp);

	/* Fixup jmpslot so future calls transfer directly to target */
	addr = np->nz_value;
	if (src_map)
		addr += (long)src_map->som_addr;

	md_fix_jmpslot(jsp, (long)jsp, addr);

#if DEBUG
xprintf(" BINDER: %s located at = %#x in %s\n", sym, addr, src_map->som_path);
#endif
	return addr;
}


static int			hfd;
static long			hsize;
static struct hints_header	*hheader;
static struct hints_bucket	*hbuckets;
static char			*hstrtab;
static char			*hint_search_path = "";

#define HINTS_VALID (hheader != NULL && hheader != (struct hints_header *)-1)

static void
maphints(void)
{
	struct stat	sb;
	caddr_t		addr = MAP_FAILED;

	if ((hfd = open(_PATH_LD_HINTS, O_RDONLY, 0)) < 0)
		goto bad_hints;

	if (fstat(hfd, &sb) != 0 || !S_ISREG(sb.st_mode) ||
	    sb.st_size < sizeof(struct hints_header) || sb.st_size > LONG_MAX)
		goto bad_hints;

	hsize = (long)sb.st_size;
	addr = mmap(0, hsize, PROT_READ, MAP_COPY, hfd, 0);
	if (addr == MAP_FAILED)
		goto bad_hints;

	hheader = (struct hints_header *)addr;
	if (HH_BADMAG(*hheader) || hheader->hh_ehints > hsize)
		goto bad_hints;

	if (hheader->hh_version != LD_HINTS_VERSION_1 &&
	    hheader->hh_version != LD_HINTS_VERSION_2)
		goto bad_hints;

	hbuckets = (struct hints_bucket *)(addr + hheader->hh_hashtab);
	hstrtab = (char *)(addr + hheader->hh_strtab);
	if (hheader->hh_version >= LD_HINTS_VERSION_2)
		hint_search_path = hstrtab + hheader->hh_dirlist;

	return;

bad_hints:
	if (addr != MAP_FAILED)
		munmap(addr, hsize);
	if (hfd != -1)
		close(hfd);
	hheader = (struct hints_header *)-1;
}

static void
unmaphints(void)
{

	if (HINTS_VALID) {
		munmap((caddr_t)hheader, hsize);
		close(hfd);
		hheader = NULL;
	}
}

static int
hinthash(char *cp, int vmajor, int vminor)
{
	int	k = 0;

	while (*cp)
		k = (((k << 1) + (k >> 14)) ^ (*cp++)) & 0x3fff;

	k = (((k << 1) + (k >> 14)) ^ (vmajor*257)) & 0x3fff;
	if (hheader->hh_version == LD_HINTS_VERSION_1)
		k = (((k << 1) + (k >> 14)) ^ (vminor*167)) & 0x3fff;

	return k;
}

#undef major
#undef minor

static char *
findhint(char *name, int major, int minor, char *prefered_path)
{
	struct hints_bucket	*bp;

	bp = hbuckets + (hinthash(name, major, minor) % hheader->hh_nbucket);

	while (1) {
		/* Sanity check */
		if (bp->hi_namex >= hheader->hh_strtab_sz) {
			warnx("Bad name index: %#x", bp->hi_namex);
			break;
		}
		if (bp->hi_pathx >= hheader->hh_strtab_sz) {
			warnx("Bad path index: %#x", bp->hi_pathx);
			break;
		}

		if (strcmp(name, hstrtab + bp->hi_namex) == 0) {
			/* It's `name', check version numbers */
			if (bp->hi_major == major &&
				(bp->hi_ndewey < 2 || bp->hi_minor >= minor)) {
					if (prefered_path == NULL ||
					    strncmp(prefered_path,
						hstrtab + bp->hi_pathx,
						strlen(prefered_path)) == 0) {
						return hstrtab + bp->hi_pathx;
					}
			}
		}

		if (bp->hi_next == -1)
			break;

		/* Move on to next in bucket */
		bp = &hbuckets[bp->hi_next];
	}

	/* No hints available for name */
	return NULL;
}

static char *
rtfindlib(char *name, int major, int minor, int *usehints, char *ipath)
{
	char	*cp;
	int	realminor;

	if (hheader == NULL)
		maphints();

	if (!HINTS_VALID || !(*usehints))
		goto lose;

	/* NOTE: `ipath' may reside in a piece of read-only memory */

	if (ld_library_path || ipath) {
		/* Prefer paths from some explicit LD_LIBRARY_PATH */
		char	*lpath;
		char	*dp;

		dp = lpath = concat(ld_library_path ? ld_library_path : "",
				    (ld_library_path && ipath) ? ":" : "",
				    ipath ? ipath : "");

		while ((cp = strsep(&dp, ":")) != NULL) {
			if (*cp) {
				cp = findhint(name, major, minor, cp);
				if (cp) {
					free(lpath);
					return cp;
				}
			}
		}
		free(lpath);

		/*
		 * Not found in hints; try directory search now, before
		 * we get a spurious hint match below (i.e. a match not
		 * on one of the paths we're supposed to search first.
		 */
		realminor = -1;
		cp = (char *)findshlib(name, &major, &realminor, 0);
		if (cp && realminor >= minor)
			return cp;
	}

	/* No LD_LIBRARY_PATH or lib not found in there; check default */
	cp = findhint(name, major, minor, NULL);
	if (cp)
		return cp;

lose:
	/* No hints available for name */
	*usehints = 0;
	realminor = -1;
	add_search_path(hint_search_path);
	cp = (char *)findshlib(name, &major, &realminor, 0);
	remove_search_path(hint_search_path);
	if (cp) {
		if (realminor < minor && !ld_suppress_warnings)
			warnx("warning: lib%s.so.%d.%d: "
			      "minor version >= %d expected, using it anyway",
			      name, major, realminor, minor);
		return cp;
	}
	return NULL;
}

void
preload(char *paths)
{
	struct so_map	*nsmp;
	struct sod	*sodp;
	char		*cp, *dp;

	dp = paths = strdup(paths);
	if (dp == NULL) {
		errx(1, "preload: out of memory");
	}

	while ((cp = strsep(&dp, ":")) != NULL) {
		if ((sodp = (struct sod *)malloc(sizeof(struct sod))) == NULL) {
			errx(1, "preload: %s: out of memory", cp);
			return;
		}

		sodp->sod_name = (long)strdup(cp);
		sodp->sod_library = 0;
		sodp->sod_major = sodp->sod_minor = 0;

		if ((nsmp = map_object(sodp, 0)) == NULL) {
			errx(1, "preload: %s: cannot map object", cp);
		}
		LM_PRIVATE(nsmp)->spd_refcount++;
	}
	free(paths);
	return;
}

static int dlerrno;

/*
 * Populate sod struct for dlopen's call to map_object
 */
static void
build_sod(const char *name, struct sod *sodp)
{
	unsigned int	tuplet;
	int		major, minor;
	char		*realname, *tok, *etok, *cp;

	/* default is an absolute or relative path */
	sodp->sod_name = (long)strdup(name);	/* strtok is destructive */
	sodp->sod_library = 0;
	sodp->sod_major = sodp->sod_minor = 0;

	/* does it look like /^lib/ ? */
	if (strncmp((char *)sodp->sod_name, "lib", 3) != 0)
		return;

	/* is this a filename? */
	if (strchr((char *)sodp->sod_name, '/'))
		return;

	/* skip over 'lib' */
	cp = (char *)sodp->sod_name + 3;

	/* dot guardian */
	if ((strchr(cp, '.') == NULL) || (*(cp+strlen(cp)-1) == '.'))
		return;

	/* default */
	major = minor = -1;

	/* loop through name - parse skipping name */
	for (tuplet = 0; (tok = strsep(&cp, ".")) != NULL; tuplet++) {
		switch (tuplet) {
		case 0:
			/* removed 'lib' and extensions from name */
			realname = tok;
			break;
		case 1:
			/* 'so' extension */
			if (strcmp(tok, "so") != 0)
				goto backout;
			break;
		case 2:
			/* major version extension */
			major = strtol(tok, &etok, 10);
			if (*tok == '\0' || *etok != '\0')
				goto backout;
			break;
		case 3:
			/* minor version extension */
			minor = strtol(tok, &etok, 10);
			if (*tok == '\0' || *etok != '\0')
				goto backout;
			break;
		/* if we get here, it must be weird */
		default:
			goto backout;
		}
	}
	cp = (char *)sodp->sod_name;
	sodp->sod_name = (long)strdup(realname);
	free(cp);
	sodp->sod_library = 1;
	sodp->sod_major = major;
	sodp->sod_minor = minor;
	return;

backout:
	free((char *)sodp->sod_name);
	sodp->sod_name = (long)strdup(name);
}

static void *
__dlopen(const char *name, int mode)
{
	struct sod	*sodp;
	struct so_map	*smp;

	/*
	 * A NULL argument returns the current set of mapped objects.
	 */
	if (name == NULL) {
		LM_PRIVATE(link_map_head)->spd_refcount++;
		return link_map_head;
	}

	if ((sodp = (struct sod *)malloc(sizeof(struct sod))) == NULL) {
		dlerrno = ENOMEM;
		return NULL;
	}

	build_sod(name, sodp);

	if ((smp = map_object(sodp, main_map)) == NULL) {
#ifdef DEBUG
xprintf("%s: %s\n", name, strerror(errno));
#endif
		dlerrno = errno;
		free((char *)sodp->sod_name);
		free(sodp);
		return NULL;
	}

	LM_PRIVATE(smp)->spd_flags |= RTLD_DL;

	if (LM_PRIVATE(smp)->spd_refcount++ > 0) {
		free((char *)sodp->sod_name);
		free(sodp);
		return smp;
	}

	if (load_subs(smp) != 0) {
		if (--LM_PRIVATE(smp)->spd_refcount == 0) {
			unmap_object(smp);
			free_link_map(smp);
		}
		return NULL;
	}

	init_maps(smp);
	return smp;
}

static int
__dlclose(void *fd)
{
	struct so_map	*smp = (struct so_map *)fd;

#ifdef DEBUG
xprintf("dlclose(%s): refcount = %d\n", smp->som_path, LM_PRIVATE(smp)->spd_refcount);
#endif
	if (--LM_PRIVATE(smp)->spd_refcount != 0)
		return 0;

	if ((LM_PRIVATE(smp)->spd_flags & RTLD_DL) == 0)
		return 0;

	/* Dismantle shared object map and descriptor */
	call_map(smp, "__fini");
	call_map(smp, "__GLOBAL__DD");
#if 0
	unload_subs(smp);		/* XXX should unload implied objects */
#endif
	unmap_object(smp);
	free_link_map(smp);
	return 0;
}

static void *
__dlsym(void *fd, const char *sym)
{
	struct so_map	*smp, *src_map = NULL;
	struct nzlist	*np;
	long		addr;

	/*
	 * Restrict search to passed map if dlopen()ed.
	 */
	if (fd == NULL)
		smp = link_map_head;
	else
		src_map = smp = (struct so_map *)fd;

	np = lookup(sym, &src_map, 1);
	if (np == NULL) {
		dlerrno = ENOENT;
		return NULL;
	}

	/* Fixup jmpslot so future calls transfer directly to target */
	addr = np->nz_value;
	if (src_map)
		addr += (long)src_map->som_addr;

	return (void *)addr;
}

static int
__dlctl(void *fd, int cmd, void *arg)
{
	switch (cmd) {
	case DL_GETERRNO:
		*(int *)arg = dlerrno;
		dlerrno = 0;
		return 0;
	default:
		dlerrno = EOPNOTSUPP;
		return -1;
	}
	return 0;
}

static void
__dlexit(void)
{
	struct so_map	*smp;

	/* Call any object initialization routines. */
	for (smp = link_map_head; smp; smp = smp->som_next) {
		if (LM_PRIVATE(smp)->spd_flags & RTLD_RTLD)
			continue;
		call_map(smp, ".fini");
		call_map(smp, "__GLOBAL__DD");
	}
}

void
#if __STDC__
xprintf(char *fmt, ...)
#else
xprintf(fmt, va_alist)
char	*fmt;
#endif
{
	char buf[256];
	va_list	ap;
#if __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif

	vsnprintf(buf, sizeof buf, fmt, ap);
	(void)write(1, buf, strlen(buf));
	va_end(ap);
}
@


1.42
log
@Don't attempt to mmap 0-length bss.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.41 2005/12/21 01:40:22 millert Exp $	*/
@


1.41
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.40 2005/09/30 20:13:12 deraadt Exp $	*/
d699 1
a699 1
	if (mmap(addr + hdr.a_text + hdr.a_data, hdr.a_bss,
@


1.40
log
@rather surprised to find a vsprintf still lying around here..
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.39 2004/11/08 20:47:07 miod Exp $	*/
a39 1
#include <sys/errno.h>
d45 1
@


1.39
log
@Sync the weak symbol logic with the ELF ld.so, and use N_AUX() instead of
rolling our own version; no functional changes.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.38 2003/08/15 23:13:06 deraadt Exp $	*/
d1666 1
a1666 1
	vsprintf(buf, fmt, ap);
@


1.38
log
@remove extra \n in {warn,err}{,x} calls
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.37 2003/05/08 16:30:52 millert Exp $	*/
d169 1
a169 1
int			errno;
d1122 1
a1122 1
			if (np->nz_other == AUX_FUNC) {
d1133 4
a1141 3

		*src_map = smp;
		return np;
@


1.37
log
@Previously, ld.so would use a single page for mapping the hints file
and then, if that was not big enough, map the rest of it contiguously.
However, there is no guarantee that the address space after the
first mmap has not already been used by something else.

Instead, just fstat the file and map up to st_size.  Also reorganized
the code a tad and added some sanity checks for st_size.

Problem tracked down by dhartmei@@ and mickey@@; drahn@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.36 2003/01/19 23:35:02 espie Exp $	*/
d1308 1
a1308 1
			warnx("Bad name index: %#x\n", bp->hi_namex);
d1312 1
a1312 1
			warnx("Bad path index: %#x\n", bp->hi_pathx);
@


1.36
log
@give a second chance for loading dependent modules:
look in the path of the main map before giving up.
ok deraadt@@.

(This fixes a few kde issues, and removes loads of needs for ldconfig)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.35 2003/01/19 23:33:40 espie Exp $	*/
d49 1
d1231 5
a1235 1
	caddr_t		addr;
d1237 3
a1239 4
	if ((hfd = open(_PATH_LD_HINTS, O_RDONLY, 0)) == -1) {
		hheader = (struct hints_header *)-1;
		return;
	}
d1241 1
a1241 1
	hsize = PAGSIZ;
d1243 2
a1244 6

	if (addr == (caddr_t)MAP_FAILED) {
		close(hfd);
		hheader = (struct hints_header *)-1;
		return;
	}
d1247 2
a1248 6
	if (HH_BADMAG(*hheader)) {
		munmap(addr, hsize);
		close(hfd);
		hheader = (struct hints_header *)-1;
		return;
	}
d1251 2
a1252 18
	    hheader->hh_version != LD_HINTS_VERSION_2) {
		munmap(addr, hsize);
		close(hfd);
		hheader = (struct hints_header *)-1;
		return;
	}

	if (hheader->hh_ehints > hsize) {
		if (mmap(addr+hsize, hheader->hh_ehints - hsize,
				PROT_READ, MAP_COPY|MAP_FIXED,
				hfd, hsize) != (caddr_t)(addr+hsize)) {

			munmap((caddr_t)hheader, hsize);
			close(hfd);
			hheader = (struct hints_header *)-1;
			return;
		}
	}
d1258 9
@


1.36.2.1
log
@Pull patch from -current:
Fix by millert@@

Previously, ld.so would use a single page for mapping the hints file
and then, if that was not big enough, map the rest of it contiguously.
However, there is no guarantee that the address space after the
first mmap has not already been used by something else.

Instead, just fstat the file and map up to st_size.  Also reorganized
the code a tad and added some sanity checks for st_size.

Problem tracked down by dhartmei@@ and mickey@@; drahn@@ OK.

Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.37 2003/05/08 16:30:52 millert Exp $	*/
a48 1
#include <limits.h>
d1230 1
a1230 2
	struct stat	sb;
	caddr_t		addr = MAP_FAILED;
d1232 4
a1235 2
	if ((hfd = open(_PATH_LD_HINTS, O_RDONLY, 0)) < 0)
		goto bad_hints;
d1237 2
a1238 3
	if (fstat(hfd, &sb) != 0 || !S_ISREG(sb.st_mode) ||
	    sb.st_size < sizeof(struct hints_header) || sb.st_size > LONG_MAX)
		goto bad_hints;
d1240 5
a1244 4
	hsize = (long)sb.st_size;
	addr = mmap(0, hsize, PROT_READ, MAP_COPY, hfd, 0);
	if (addr == MAP_FAILED)
		goto bad_hints;
d1247 6
a1252 2
	if (HH_BADMAG(*hheader) || hheader->hh_ehints > hsize)
		goto bad_hints;
d1255 18
a1272 2
	    hheader->hh_version != LD_HINTS_VERSION_2)
		goto bad_hints;
a1277 9

	return;

bad_hints:
	if (addr != MAP_FAILED)
		munmap(addr, hsize);
	if (hfd != -1)
		close(hfd);
	hheader = (struct hints_header *)-1;
@


1.35
log
@revamp .init call code to be saner:
- build a tree of modules inter-dependencies.
- make sure dependent modules are .init'ed before depending modules.
- flag initialization so that cycles don't bork ld.so.

okay deraadt@@, drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.34 2003/01/19 23:28:46 espie Exp $	*/
d625 10
@


1.34
log
@In error message from dependent libraries, mention which dependent library
is trying to load another library.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.33 2003/01/05 09:04:10 pvalchev Exp $	*/
d100 1
d106 7
d369 17
d435 2
d558 2
d739 17
d779 3
a781 3
		call_map(smp, ".init");
		call_map(smp, "__init");
		call_map(smp, "__GLOBAL__DI");
@


1.33
log
@fix for PR3053 - NULL deref when fd == NULL in first dlsym() arg
ok miod drahn marc
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.32 2002/12/11 23:24:39 millert Exp $	*/
d383 5
a387 4
					char *fmt = sodp->sod_library ?
						"%s: lib%s.so.%d.%d" :
						"%s: %s";
					err(1, fmt, main_progname,
d391 16
@


1.32
log
@o Check mmap() return value against MAP_FAILED, not -1.
o Prevent close() from clobbering errno.
Patch from Peter Werner; closes PR 2995
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.31 2002/12/02 23:17:36 deraadt Exp $	*/
d1532 1
a1532 1
	struct so_map	*smp = (struct so_map *)fd, *src_map = NULL;
d1539 4
a1542 2
	if (LM_PRIVATE(smp)->spd_flags & RTLD_DL)
		src_map = smp;
@


1.31
log
@KNF; openbsd@@davidkrause.com
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.30 2002/12/02 09:00:11 miod Exp $	*/
d554 1
a554 1
	int		fd;
d609 1
d611 1
a611 1
		/*errno = x;*/
d623 2
a624 1
	    MAP_COPY, fd, 0)) == (caddr_t)-1) {
d626 1
d636 1
d638 1
d645 2
a646 1
	    anon_fd, 0) == (caddr_t)-1) {
d648 1
d1167 1
a1167 1
	if (addr == (caddr_t)-1) {
@


1.30
log
@Import propolice (http://www.trl.ibm.com/projects/security/ssp), a stack
attack protection scheme, into gcc.

This protection is enabled by default. It can be turned off by using the
-fno-stack-protector flag.

Code by Hiroaki Etoh (etoh at jp dot ibm dot com); work on openbsd-specific
integration by fgsch@@, deraadt@@ and myself; tests by fgsch@@, naddy@@ and
myself; beer drinking by myself.

Please note that system upgrades with this new code will require a new
libc and ld.so to be build and installed before the propolice-enabled
compiler can be installed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.29 2002/09/07 01:25:34 marc Exp $	*/
d67 1
a67 1
long __guard[8] = {0,0,0,0,0,0,0,0};
@


1.29
log
@
ansification of ld

* normalized the signatures of the functions passed to each_file()
   and each_full_file().  In most cases that meant adding a void *dummy.
   In one case it changed an int to a void*, but the arg was only checked
   for zero/not-zero so the change was not significant.

 * removes unused code and structures.

 * makes sure printf args match their format.

 * got rid of some of the gcc -Wall warnings

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.28 2002/07/27 22:06:06 deraadt Exp $	*/
d61 12
@


1.28
log
@ask uvm to map the bss of each .so module non-executable.  again, we
cannot do this to the data segments until we know how big the got/plt
zone is... anyone want to track that down?
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.27 2002/07/19 19:28:12 marc Exp $	*/
d1099 1
a1099 1
		errx(1, "Call to binder from unknown location: %#x", jsp);
d1109 1
a1109 1
		errx(1, "Undefined symbol \"%s\" called from %s:%s at %#x",
d1199 1
a1199 1
int
a1356 19
static struct somap_private dlmap_private = {
		0,
		(struct so_map *)0,
		0,
#ifdef SUN_COMPAT
		0,
#endif
};

static struct so_map dlmap = {
	(caddr_t)0,
	"internal",
	(struct so_map *)0,
	(struct sod *)0,
	(caddr_t)0,
	(u_int)0,
	(struct _dynamic *)0,
	(caddr_t)&dlmap_private
};
d1362 1
a1362 1
void
@


1.27
log
@convert functions from K&R style to prototype style.
Function arg types have not yet been fixed.  OK fgs@@, espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.26 2002/07/17 20:33:29 marc Exp $	*/
d326 1
a326 1
				PROT_READ|PROT_WRITE|PROT_EXEC) == -1) {
d609 2
a610 2
		 PROT_READ|PROT_EXEC,
		 MAP_COPY, fd, 0)) == (caddr_t)-1) {
d626 3
a628 3
		 PROT_READ|PROT_WRITE|PROT_EXEC,
		 MAP_ANON|MAP_COPY|MAP_FIXED,
		 anon_fd, 0) == (caddr_t)-1) {
d723 2
a724 2
				LD_TEXTSZ(smp->som_dynamic),
				PROT_READ|PROT_WRITE|PROT_EXEC) == -1) {
d814 2
a815 3
				LD_TEXTSZ(smp->som_dynamic),
				PROT_READ|PROT_EXEC) == -1) {

d817 1
a817 1
						main_progname, smp->som_path);
@


1.26
log
@un-__P the code.   fgs says "looks ok."
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.25 2002/07/15 21:05:57 marc Exp $	*/
d220 1
a220 4
rtld(version, crtp, dp)
	int			version;
	struct crt_ldso		*crtp;
	struct _dynamic		*dp;
d248 1
a248 1
		md_relocate_simple(reloc, crtp->crt_ba, addr);
d351 1
a351 2
load_subs(smp)
	struct so_map	*smp;
d390 1
a390 2
ld_trace(smp)
	struct so_map	*smp;
d478 2
a479 7
alloc_link_map(path, sodp, parent, addr, size, dp)
	char		*path;
	struct sod	*sodp;
	struct so_map	*parent;
	caddr_t		addr;
	size_t		size;
	struct _dynamic	*dp;
d516 1
a516 2
free_link_map(smp)
	struct so_map	*smp;
d537 1
a537 3
map_object(sodp, smp)
	struct sod	*sodp;
	struct so_map	*smp;
d649 1
a649 2
unmap_object(smp)
	struct so_map	*smp;
d675 1
a675 2
init_maps(head)
	struct so_map	*head;
d704 1
a704 4
check_text_reloc(r, smp, addr)
	struct relocation_info	*r;
	struct so_map		*smp;
	caddr_t			addr;
d734 1
a734 2
reloc_map(smp)
	struct so_map		*smp;
d825 1
a825 2
reloc_copy(smp)
	struct so_map		*smp;
d838 1
a838 3
call_map(smp, sym)
	struct so_map		*smp;
	char			*sym;
d859 1
a859 2
hash_string(key)
	const char *key;
d877 1
a877 2
lookup_rts(key)
	const char *key;
d896 2
a897 7
enter_rts(name, value, type, srcaddr, size, smp)
	const char	*name;
	long		value;
	int		type;
	caddr_t		srcaddr;
	long		size;
	struct so_map	*smp;
d937 1
a937 4
lookup(name, src_map, strong)
	const char	*name;
	struct so_map	**src_map;	/* IN/OUT */
	int		strong;
d1082 1
a1082 2
binder(jsp)
	jmpslot_t	*jsp;
d1137 1
a1137 1
maphints()
d1190 1
a1190 1
unmaphints()
d1201 1
a1201 3
hinthash(cp, vmajor, vminor)
	char	*cp;
	int	vmajor, vminor;
d1219 1
a1219 4
findhint(name, major, minor, prefered_path)
	char	*name;
	int	major, minor;
	char	*prefered_path;
d1261 1
a1261 5
rtfindlib(name, major, minor, usehints, ipath)
	char	*name;
	int	major, minor;
	int	*usehints;
	char	*ipath;
d1328 1
a1328 2
preload(paths)
	char		*paths;
d1383 1
a1383 3
build_sod(name, sodp)
	const char	*name;
	struct sod	*sodp;
d1455 1
a1455 3
__dlopen(name, mode)
	const char	*name;
	int		mode;
d1506 1
a1506 2
__dlclose(fd)
	void	*fd;
d1531 1
a1531 3
__dlsym(fd, sym)
	void		*fd;
	const char	*sym;
d1558 1
a1558 3
__dlctl(fd, cmd, arg)
	void	*fd, *arg;
	int	cmd;
d1573 1
a1573 1
__dlexit()
@


1.25
log
@
space to tab cleanup.   Nothing but whitespace changes in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.24 2002/07/10 17:28:16 marc Exp $	*/
d165 5
a169 5
static void		*__dlopen __P((const char *, int));
static int		__dlclose __P((void *));
static void		*__dlsym __P((void *, const char *));
static int		__dlctl __P((void *, int, void *));
static void		__dlexit __P((void));
d175 8
a182 8
       void		xprintf __P((char *, ...));
       int		rtld __P((int, struct crt_ldso *, struct _dynamic *));
       void		binder_entry __P((void));
       long		binder __P((jmpslot_t *));
static int		load_subs __P((struct so_map *));
static struct so_map	*map_object __P((struct sod *, struct so_map *));
static void		unmap_object __P((struct so_map *));
static struct so_map	*alloc_link_map __P((	char *, struct sod *,
d184 3
a186 3
						size_t, struct _dynamic *));
static void		free_link_map __P((struct so_map *));
static inline void	check_text_reloc __P((	struct relocation_info *,
d188 12
a199 12
						caddr_t));
static void		init_maps __P((struct so_map *));
static void		reloc_map __P((struct so_map *));
static void		reloc_copy __P((struct so_map *));
static void		call_map __P((struct so_map *, char *));
static char		*rtfindlib __P((char *, int, int, int *, char *));
static struct nzlist	*lookup __P((const char *, struct so_map **, int));
static inline struct rt_symbol	*lookup_rts __P((const char *));
static struct rt_symbol	*enter_rts __P((const char *, long, int, caddr_t,
						long, struct so_map *));
static void		maphints __P((void));
static void		unmaphints __P((void));
d201 2
a202 2
static void		preload __P((char *));
static void		ld_trace __P((struct so_map *));
d867 1
a867 1
		(*(void (*) __P((void)))(src_map->som_addr + np->nz_value))();
@


1.24
log
@
First of some clean-up commits.  This one only removes use of
register variables.   clean-up concept ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.23 2002/06/03 09:28:07 deraadt Exp $	*/
d17 1
a17 1
 *      This product includes software developed by Paul Kranenburg.
d527 1
a527 1
	struct so_map   *smp;
d622 2
a623 2
	         PROT_READ|PROT_EXEC,
	         MAP_COPY, fd, 0)) == (caddr_t)-1) {
d680 2
a681 2
	*pp = smp->som_next;                    /* make list skip it */
	if (link_map_tail == &smp->som_next)    /* and readjust tail pointer */
d1435 1
a1435 1
	sodp->sod_name = (long)strdup(name);    /* strtok is destructive */
@


1.23
log
@use issetugid() instead of uid/gid comparisons; from drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.22 2002/03/07 17:07:10 fgsch Exp $	*/
d205 1
a205 1
strcmp (register const char *s1, register const char *s2)
d250 1
a250 1
		register long	addr = reloc->r_address + crtp->crt_ba;
d884 2
a885 2
	register const char *cp;
	register int k;
d903 2
a904 2
	register int			hashval;
	register struct rt_symbol	*rtsp;
d928 2
a929 2
	register int			hashval;
	register struct rt_symbol	*rtsp, **rpp;
d1305 2
a1306 2
	register char	*cp;
	int		realminor;
d1318 2
a1319 2
		register char	*lpath;
		char		*dp;
@


1.22
log
@revert changes made in rev. 1.17; closes pr # 1903. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.16 2000/02/03 17:19:07 millert Exp $	*/
a149 2
static uid_t		uid, euid;
static gid_t		gid, egid;
d263 2
a264 5
	/* Get user and group identifiers */
	uid = getuid(); euid = geteuid();
	gid = getgid(); egid = getegid();

	careful = (uid != euid) || (gid != egid);
@


1.21
log
@From NetBSD:
Deal with weak symbols when looking up in shared libraries; tested by marc@@
miod@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.20 2001/11/08 07:40:25 fgsch Exp $	*/
d1122 1
a1122 1
	struct so_map	*smp, *src_map;
d1125 1
a1125 1
	struct nzlist	*np = NULL;
d1146 1
a1146 12
	/*
	 * If this is a call from a dlopen(3) object, try to resolve locally
	 * first
	 */
	if (LM_PRIVATE(smp)->spd_flags & RTLD_DL) {
		src_map = smp;
		np = lookup(sym, &src_map, 1);
	}
	if (np == NULL) {
		src_map = NULL;
		np = lookup(sym, &src_map, 1);
	}
@


1.20
log
@fixes netbsd PR #10940 and also uses main program's library search
path in dlopen(), from netbsd as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.19 2001/06/09 21:51:58 espie Exp $	*/
d977 1
a977 1
	struct so_map		*smp;
d979 1
d987 2
d1078 5
d1086 5
@


1.19
log
@Fill some field earlier, should allow better .init/dlopen interaction.
From NetBSD.

fgsch@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.18 2000/04/27 19:33:09 espie Exp $	*/
d297 1
a512 2
/*XXX*/	if (addr == 0) main_map = smp;

d980 3
a982 1
	if ((rtsp = lookup_rts(name)) != NULL)
d984 1
d1090 3
d1525 1
a1525 1
	if ((smp = map_object(sodp, 0)) == NULL) {
@


1.18
log
@Call ctor/dtor lists generated by collect2 as well.
Since those are properly protected against multiple execution, even
if collect2/ld manages to link them at some point, this won't add
problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.17 2000/04/24 17:56:34 niklas Exp $	*/
d303 6
a322 6

	/* Fill in some field in main's __DYNAMIC structure */
	if (version >= CRT_VERSION_BSD_4)
		crtp->crt_ldentry = &ld_entry;
	else
		crtp->crt_dp->d_entry = &ld_entry;
@


1.17
log
@Make dlopened modules prefer symbols defined locally
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.16 2000/02/03 17:19:07 millert Exp $	*/
d720 1
d1567 1
d1632 1
@


1.16
log
@Deal with empty path element in LD_LIBRARY_PATH.
o Don't try and look up an empty element in the hints file
o Convert "" to "." when adding to the list of search dirs
Perviously, an LD_LIBRARY_PATH that ended in ':' was ignored.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.15 2000/01/11 22:27:07 millert Exp $	*/
d1103 1
a1103 1
	struct so_map	*smp, *src_map = NULL;
d1106 1
a1106 1
	struct nzlist	*np;
d1127 12
a1138 1
	np = lookup(sym, &src_map, 1);
@


1.15
log
@Reverse order of ^lib and '/' checks since ^lib is cheaper; espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.14 2000/01/11 21:38:47 millert Exp $	*/
d1312 6
a1317 4
			cp = findhint(name, major, minor, cp);
			if (cp) {
				free(lpath);
				return cp;
@


1.14
log
@Fix the logic that determines whether or not a dlopen()'d name should
be looked for in the libary search path.  If a name has a '/' in it,
treat it as a pathname, even if it starts with "lib"; gsar@@ActiveState.com
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.13 1999/12/10 00:11:02 deraadt Exp $	*/
d1423 4
a1428 4
		return;

	/* does it look like /^lib/ ? */
	if (strncmp((char *)sodp->sod_name, "lib", 3) != 0)
@


1.13
log
@bad espie, commiting bad patches, with junk in them that should not be there
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.12 1999/12/09 18:10:24 espie Exp $	*/
d1423 5
a1427 1
	/* asking for lookup? */
@


1.12
log
@dlopen and dlsym take const char * parameters.
Fix prototypes, propagate const where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.11 1999/10/26 22:51:46 deraadt Exp $	*/
d1309 1
a1309 1
				    ipath ? ipath : "", 0);
@


1.11
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.10 1998/08/28 20:45:41 deraadt Exp $	*/
d167 1
a167 1
static void		*__dlopen __P((char *, int));
d169 1
a169 1
static void		*__dlsym __P((void *, char *));
d196 3
a198 3
static struct nzlist	*lookup __P((char *, struct so_map **, int));
static inline struct rt_symbol	*lookup_rts __P((char *));
static struct rt_symbol	*enter_rts __P((char *, long, int, caddr_t,
d887 1
a887 1
	char *key;
d889 1
a889 1
	register char *cp;
d906 1
a906 1
	char *key;
d926 1
a926 1
	char		*name;
d972 1
a972 1
	char		*name;
d990 1
a990 1
		char		*cp;
d1309 1
a1309 1
				    ipath ? ipath : "");
d1411 1
a1411 1
	char		*name;
d1481 2
a1482 2
	char	*name;
	int	mode;
d1559 2
a1560 2
	void	*fd;
	char	*sym;
@


1.10
log
@set RTLD_DL flag before refcount++ returns; michaels@@inet.no
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.9 1998/03/26 19:47:29 niklas Exp $	*/
d250 2
a251 4
	for (	reloc = (struct relocation_info *)(LD_REL(dp) + crtp->crt_ba);
		nreloc;
		nreloc--, reloc++) {

a252 1

@


1.9
log
@RCS id cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rtld.c,v 1.43 1996/01/14 00:35:17 pk Exp $	*/
d1515 2
a1521 2

	LM_PRIVATE(smp)->spd_flags |= RTLD_DL;
@


1.8
log
@memory leaks, object leaks. some from pk/cgd.  rearrange *_DL checks for
further safety.
@
text
@d1 1
@


1.7
log
@have DL_GETERRNO clear error state after return; also make dlsym() set error state
@
text
@d87 1
d182 1
d185 2
a186 1
						struct _dynamic *));
d296 1
a296 1
					(caddr_t)0, crtp->crt_dp);
d301 1
a301 1
					(caddr_t)crtp->crt_ba, dp);
d389 2
a390 1
				newmap = alloc_link_map(NULL, sodp, smp, 0, 0);
d489 1
a489 1
alloc_link_map(path, sodp, parent, addr, dp)
d494 1
d519 1
d529 23
d636 4
d662 32
a693 1
	return alloc_link_map(path, sodp, smp, addr, dp);
d1409 1
a1409 1
 * Populate sod struct for dlopen's call to map_obj
d1509 2
d1514 3
a1516 1
	if (LM_PRIVATE(smp)->spd_refcount++ > 0)
d1518 3
d1522 5
a1526 1
	if (load_subs(smp) != 0)
d1528 1
a1529 1
	LM_PRIVATE(smp)->spd_flags |= RTLD_DL;
d1546 3
d1552 2
d1555 1
a1555 5
	free(smp->som_sod->sod_name);
	free(smp->som_sod);
	free(smp);
#endif

@


1.6
log
@do not call err/errx with extra newlines
@
text
@d1499 2
a1500 1
	if (np == NULL)
d1502 1
d1520 1
@


1.5
log
@mark dlopen() modules with RTLD_DL
@
text
@d735 1
a735 1
				errx(1, "Undefined symbol \"%s\" in %s:%s\n",
d779 1
a779 1
			err(1, "Cannot disable writes to %s:%s\n",
d1057 1
a1057 1
		errx(1, "Call to binder from unknown location: %#x\n", jsp);
@


1.4
log
@from netbsd:
Relax checking of minor version number in `findhint()'. Also use the
directories from the hints (v.2) file for directory traversing.
This should take care of PR#1146.
@
text
@d1454 1
@


1.3
log
@from netbsd:
Make dlopen() search for libraries if given a name of the form
`lib<name>.so[.xx[.yy]]' (per Erik M. Theisen; PR#1763; patch from PR
used in simplified form).
Deal with v.2 hint files (hint srch dirs not yet used).
@
text
@d1 1
a1 1
/*	$NetBSD: rtld.c,v 1.42 1996/01/09 00:02:28 pk Exp $	*/
d1089 1
d1142 2
d1201 1
a1201 1
				(bp->hi_ndewey < 2 || bp->hi_minor == minor)) {
d1278 1
d1280 1
@


1.2
log
@make dlopen() use hints database, not just paths; from etheisen@@TECLink.Net; netbsd pr#1763
@
text
@d1 1
a1 1
/*	$NetBSD: rtld.c,v 1.40 1995/10/09 09:24:59 pk Exp $	*/
d180 1
a180 2
static struct so_map	*map_object __P((char *, struct sod *,
					 struct so_map *));
a372 1
			char *name;
a374 1
			name = (char *)(sodp->sod_name + LM_LDBASE(smp));
d376 1
a376 1
			if ((newmap = map_object(name, sodp, smp)) == NULL) {
d381 2
a382 1
					err(1, fmt, main_progname, name,
a388 1
			LM_PARENT(newmap) = smp;
d418 3
a420 1
		name = sodp->sod_name + LM_LDBASE(LM_PARENT(smp));
d527 1
a527 2
map_object(name, sodp, smp)
	char		*name;
d531 1
d540 4
d551 1
a551 1
			ipath =  LM_PATHS(smp);
d1119 2
a1120 1
	if (hheader->hh_version != LD_HINTS_VERSION_1) {
d1165 2
a1166 1
	k = (((k << 1) + (k >> 14)) ^ (vminor*167)) & 0x3fff;
d1309 1
a1309 1
		if ((nsmp = map_object(cp, sodp, 0)) == NULL) {
d1345 1
a1345 1
	struct	sod	*sodp;
a1346 1
	unsigned int	number;
a1347 1
	unsigned int	strange = 0;
d1349 1
a1349 1
	char		*realname, *tok, *tok1;
d1352 1
a1352 1
	sodp->sod_name = (long)strdup(name);	/* strtok is destructive */
d1355 1
d1357 17
a1373 8
	if (strncmp((char *)sodp->sod_name, "lib", 3) == NULL) {
		/* skip over 'lib' */
		tok = (char *)sodp->sod_name + 3;
		/* dot guardian */
		if((strchr(tok, '.') != NULL) && (*(tok+strlen(tok)-1)!='.')) {
			tok = strtok(tok, ".");
			/* default */
			major = minor = -1;
d1376 34
a1409 66
			/* loop through name - parse skipping name */
			for(tuplet=1;((tok=strtok(NULL,"."))!=NULL);tuplet++) {
				switch (tuplet) {
					/* 'so' extension */
					case 1:
						if(strcmp(tok, "so") != NULL)
							strange = 1;
						break;
					/* major ver extension */
					case 2:
						for(tok1=tok;
						    (*tok1 != '\0');
						    tok1++) {
							if(isdigit(*tok1))
								number = 1;
							else {
								number = 0;
								break;
							}
						}
						if(number)
							major = atoi(tok);
						else {
							major = 0;
							strange = 1;
						}
						break;
					/* minor ver extension */
					case 3:
						for(tok1=tok;
						    (*tok1 != '\0');
						    tok1++) {
							if(isdigit(*tok1))
								number = 1;
							else {
								number = 0;
								break;
							}
						}
						if(number)
							minor = atoi(tok);
						else {
							minor = 0;
							strange = 1;
						}
						break;
					/* if we get here, it must be weird */
					default:
						strange = 1;
				} /* end switch */
			} /* end for */
			/* normal */
			if(!strange) {
				free((char *)sodp->sod_name);
				sodp->sod_name = (long)strdup(realname);
				sodp->sod_library = 1;
				sodp->sod_major = major;
				sodp->sod_minor = minor;
			}
			/* strange */
			else {
				free((char *)sodp->sod_name);
				sodp->sod_name = (long)strdup(name);
			}
		} /* end if dots */
	}  /* end if lookup */
d1435 1
a1435 1
	if ((smp = map_object((char *)sodp->sod_name, sodp, 0)) == NULL) {
@


1.1
log
@Initial revision
@
text
@d1334 97
d1452 1
a1452 3
	sodp->sod_name = (long)strdup(name);
	sodp->sod_library = 0;
	sodp->sod_major = sodp->sod_minor = 0;
d1454 1
a1454 1
	if ((smp = map_object(name, sodp, 0)) == NULL) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
