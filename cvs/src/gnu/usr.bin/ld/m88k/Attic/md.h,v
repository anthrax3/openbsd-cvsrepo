head	1.9;
access;
symbols
	OPENBSD_5_3:1.8.0.22
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.20
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.18
	OPENBSD_5_0:1.8.0.16
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.14
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.12
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.8
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.8
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.14
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.12
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2013.07.05.21.31.47;	author miod;	state dead;
branches;
next	1.8;

1.8
date	2007.11.28.12.04.25;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.12.20.04.54;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.17.20.33.29;	author marc;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.15.21.05.57;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.24.03.13.55;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.25.04.20.40;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.01.21.01.40;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	99.02.09.05.35.14;	author smurph;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Put the a.out as and ld to rest in the Attic, finally!
@
text
@/* * $OpenBSD: md.h,v 1.8 2007/11/28 12:04:25 miod Exp $*/
/*
 *	- m88k dependent definitions
 */

#if defined(CROSS_LINKER) 
#include <sys/endian.h>

#if BYTE_ORDER != BIG_ENDIAN
#define NEED_SWAP
#endif

#endif

#define	MAX_ALIGNMENT		(sizeof (double))

#define PAGSIZ			0x1000
#undef  __LDPGSZ
#define __LDPGSZ		0x1000

#define N_SET_FLAG(ex,f)	N_SETMAGIC(ex,N_GETMAGIC(ex), MID_MACHINE, \
						N_GETFLAG(ex)|(f))

#define N_IS_DYNAMIC(ex)	((N_GETFLAG(ex) & EX_DYNAMIC))

#define N_BADMID(ex) \
	(N_GETMID(ex) != 0 && N_GETMID(ex) != MID_MACHINE && \
						!md_midcompat(&(ex)))

/*
 * Should be handled by a.out.h ?
 */
#define N_ADJUST(ex)		(((ex).a_entry < PAGSIZ) ? -PAGSIZ : 0)
/*
#define TEXT_START(ex)		(N_TXTADDR(ex) + N_ADJUST(ex))
*/
#define TEXT_START(ex)		(N_TXTADDR(ex))
#define DATA_START(ex)		(N_DATADDR(ex) + N_ADJUST(ex))

#define RELOC_STATICS_THROUGH_GOT_P(r)	(1)
#define JMPSLOT_NEEDS_RELOC		(0)

#define md_got_reloc(r)			(0)

#define md_get_rt_segment_addend(r,a)	md_get_addend(r,a)

/* Width of a Global Offset Table entry */
#define GOT_ENTRY_SIZE	4
typedef long	got_t;

typedef struct jmpslot {
	u_short	opcode;
	u_short	addr[2];
	u_short	reloc_index;
#define JMPSLOT_RELOC_MASK		0xffff
} jmpslot_t;

#if 1 /* NOT REALLY */
#define NOP	0x4e71
#define BSRL	0x61ff		/* BSR opcode with long offset */
#define BRAL	0x60ff		/* BRA opcode with long offset */
#define BPT	0x4e42		/* breakpoint trap: trap #2 */
#endif

/* m88k */
enum reloc_type {

	RELOC_LO16, /* lo16(sym) */
	RELOC_HI16, /* hi16(sym) */
	RELOC_PC16, /* bb0, bb1, bcnd */
	RELOC_PC26, /* br, bsr */
	RELOC_32, /* jump tables, etc */
	RELOC_IW16, /* global access through linker regs 28 */
	NO_RELOC,
	RELOC_GLOB_DAT,
	RELOC_JMP_SLOT,
	RELOC_RELATIVE
};
#undef relocation_info 
#define relocation_info relocation_info_m88k




/*
 * Byte swap defs for cross linking
 */

#if !defined(NEED_SWAP)

#define md_swapin_exec_hdr(h)
#define md_swapout_exec_hdr(h)
#define md_swapin_symbols(s,n)
#define md_swapout_symbols(s,n)
#define md_swapin_zsymbols(s,n)
#define md_swapout_zsymbols(s,n)
#define md_swapin_reloc(r,n)			md_in_reloc(r,n)
#define md_swapout_reloc(r,n)
#define md_swapin__dynamic(l)
#define md_swapout__dynamic(l)
#define md_swapin_section_dispatch_table(l)
#define md_swapout_section_dispatch_table(l)
#define md_swapin_so_debug(d)
#define md_swapout_so_debug(d)
#define md_swapin_rrs_hash(f,n)
#define md_swapout_rrs_hash(f,n)
#define md_swapin_sod(l,n)
#define md_swapout_sod(l,n)
#define md_swapout_jmpslot(j,n)
#define md_swapout_got(g,n)
#define md_swapin_ranlib_hdr(h,n)
#define md_swapout_ranlib_hdr(h,n)

#endif /* NEED_SWAP */

#ifdef CROSS_LINKER

#define get_byte(p)	( ((unsigned char *)(p))[0] )

#define get_short(p)	( ( ((unsigned char *)(p))[0] << 8) | \
			  ( ((unsigned char *)(p))[1]	  )   \
			)
#define get_long(p)	( ( ((unsigned char *)(p))[0] << 24) | \
			  ( ((unsigned char *)(p))[1] << 16) | \
			  ( ((unsigned char *)(p))[2] << 8 ) | \
			  ( ((unsigned char *)(p))[3]	   )   \
			)

#define put_byte(p, v)	{ ((unsigned char *)(p))[0] = ((unsigned long)(v)); }

#define put_short(p, v)	{ ((unsigned char *)(p))[0] =			\
				((((unsigned long)(v)) >> 8) & 0xff); 	\
			  ((unsigned char *)(p))[1] =			\
				((((unsigned long)(v))	   ) & 0xff); }

#define put_long(p, v)	{ ((unsigned char *)(p))[0] =			\
				((((unsigned long)(v)) >> 24) & 0xff); 	\
			  ((unsigned char *)(p))[1] =			\
				((((unsigned long)(v)) >> 16) & 0xff); 	\
			  ((unsigned char *)(p))[2] =			\
				((((unsigned long)(v)) >>  8) & 0xff); 	\
			  ((unsigned char *)(p))[3] =			\
				((((unsigned long)(v))	    ) & 0xff); }
#define put_b26(p, v)	{ ((unsigned char *)(p))[0] =			\
				((((unsigned long)(v)) >> 24) & 0x03 |  \
				((unsigned char *)(p))[0] & 0xfc);	\
			  ((unsigned char *)(p))[1] =			\
				((((unsigned long)(v)) >> 16) & 0xff); 	\
			  ((unsigned char *)(p))[2] =			\
				((((unsigned long)(v)) >>  8) & 0xff); 	\
			  ((unsigned char *)(p))[3] =			\
				((((unsigned long)(v))	    ) & 0xff); }


#ifdef NEED_SWAP

/* Define IO byte swapping routines */

void	md_swapin_exec_hdr(struct exec *);
void	md_swapout_exec_hdr(struct exec *);
void	md_swapin_reloc(struct relocation_info *, int);
void	md_swapout_reloc(struct relocation_info *, int);
void	md_swapout_jmpslot(jmpslot_t *, int);

#define md_swapin_symbols(s,n)			swap_symbols(s,n)
#define md_swapout_symbols(s,n)			swap_symbols(s,n)
#define md_swapin_zsymbols(s,n)			swap_zsymbols(s,n)
#define md_swapout_zsymbols(s,n)		swap_zsymbols(s,n)
#define md_swapin__dynamic(l)			swap__dynamic(l)
#define md_swapout__dynamic(l)			swap__dynamic(l)
#define md_swapin_section_dispatch_table(l)	swap_section_dispatch_table(l)
#define md_swapout_section_dispatch_table(l)	swap_section_dispatch_table(l)
#define md_swapin_so_debug(d)			swap_so_debug(d)
#define md_swapout_so_debug(d)			swap_so_debug(d)
#define md_swapin_rrs_hash(f,n)			swap_rrs_hash(f,n)
#define md_swapout_rrs_hash(f,n)		swap_rrs_hash(f,n)
#define md_swapin_sod(l,n)			swapin_sod(l,n)
#define md_swapout_sod(l,n)			swapout_sod(l,n)
#define md_swapout_got(g,n)			swap_longs((long*)(g),n)
#define md_swapin_ranlib_hdr(h,n)		swap_ranlib_hdr(h,n)
#define md_swapout_ranlib_hdr(h,n)		swap_ranlib_hdr(h,n)

#define md_swap_short(x) ( (((x) >> 8) & 0xff) | (((x) & 0xff) << 8) )

#define md_swap_long(x) ( (((x) >> 24) & 0xff	 ) | (((x) >> 8 ) & 0xff00   ) | \
			(((x) << 8 ) & 0xff0000) | (((x) << 24) & 0xff000000))

#else	/* We need not swap, but must pay attention to alignment: */

#define md_swap_short(x)	(x)
#define md_swap_long(x)		(x)

#endif /* NEED_SWAP */

#else	/* Not a cross linker: use native */

#define md_swap_short(x)		(x)
#define md_swap_long(x)			(x)

#define get_byte(where)			(*(char *)(where))
#define get_short(where)		(*(short *)(where))
#define get_long(where)			(*(long *)(where))

#define put_byte(where,what)		(*(char *)(where) = (what))
#define put_short(where,what)		(*(short *)(where) = (what))
#define put_long(where,what)		(*(long *)(where) = (what))
#define put_b26(where, what)		(*(long *)(where) = ((*(long *)(where))\
				& ~0x03ffffff) | ((what) & 0x03ffffff))

#endif /* CROSS_LINKER */

#if 0
#define RELOC_ADDRESS(r)		((r)->r_address)
#define RELOC_EXTERN_P(r)		((r)->r_extern)
#define RELOC_TYPE(r)			((r)->r_symbolnum)
#define RELOC_SYMBOL(r)			((r)->r_symbolnum)
#define RELOC_MEMORY_SUB_P(r)		0
#define RELOC_MEMORY_ADD_P(r)		1
#undef RELOC_ADD_EXTRA
#define RELOC_PCREL_P(r)		((r)->r_pcrel)
#define RELOC_VALUE_RIGHTSHIFT(r)	0
#if defined(RTLD) && defined(SUN_COMPAT)
#define RELOC_TARGET_SIZE(r)		(2)	/* !!!!! Sun BUG compatible */
#else
#define RELOC_TARGET_SIZE(r)		((r)->r_length)
#endif
#define RELOC_TARGET_BITPOS(r)		0
#define RELOC_TARGET_BITSIZE(r)		32

#define RELOC_JMPTAB_P(r)		((r)->r_jmptable)
#define RELOC_BASEREL_P(r)		((r)->r_baserel)
#define RELOC_RELATIVE_P(r)		((r)->r_relative)
#define RELOC_COPY_P(r)			((r)->r_copy)
#define RELOC_LAZY_P(r)			((r)->r_jmptable)

#define CHECK_GOT_RELOC(r)		(0)
#endif

@


1.8
log
@Fix md_swap{in,out}_reloc.
@
text
@d1 1
a1 1
/* * $OpenBSD: md.h,v 1.7 2005/09/12 20:04:54 miod Exp $*/
@


1.7
log
@Simplify cross-compilation scenario; native builds unaffected.
Looked at mickey@@ grange@@
@
text
@d1 1
a1 1
/* * $OpenBSD: md.h,v 1.6 2002/07/17 20:33:29 marc Exp $*/
a77 24
};
#if  0
struct relocation_info_m88k {
	unsigned int r_address;		/* offset in text or data segment */
	unsigned int r_symbolnum : 24,  /* ordinal number of add symbol */
			r_extern :  1,  /* 1 if need to add symbol to value */
			r_baserel : 1,
			r_pcrel : 1,
			r_jmptable : 1,
			r_type : 4;
			
	int r_addend;
};
#endif
struct r_relocation_info_m88k {
	unsigned int r_address;		/* offset in text or data segment */
	unsigned int	  r_type : 4,
			r_jmptable : 1,
			r_pcrel : 1,
			r_baserel : 1,
			r_extern :  1,  /* 1 if need to add symbol to value */
		     r_symbolnum : 24;  /* ordinal number of add symbol */
			
	int r_addend;
@


1.6
log
@un-__P the code.   fgs says "looks ok."
@
text
@d1 1
a1 1
/* * $OpenBSD: md.h,v 1.5 2002/07/15 21:05:57 marc Exp $*/
a12 7
#undef __LDPGSZ
#undef ELF_TARG_DATA
#undef ELF_TARG_MACH
#undef relocation_info
#undef MID_MACHINE
#define MID_MACHINE MID_M88K
#include <mvme88k/exec.h>
@


1.5
log
@
space to tab cleanup.   Nothing but whitespace changes in this commit.
@
text
@d1 1
a1 1
/* * $OpenBSD: md.h,v 1.4 2001/12/24 03:13:55 miod Exp $*/
d190 5
a194 5
void	md_swapin_exec_hdr __P((struct exec *));
void	md_swapout_exec_hdr __P((struct exec *));
void	md_swapin_reloc __P((struct relocation_info *, int));
void	md_swapout_reloc __P((struct relocation_info *, int));
void	md_swapout_jmpslot __P((jmpslot_t *, int));
@


1.4
log
@Hooks to enable building a cross-ld for mvme88k.
@
text
@d1 1
a1 1
/* * $OpenBSD: md.h,v 1.3 2001/11/25 04:20:40 miod Exp $*/
d75 7
a81 7
        RELOC_LO16, /* lo16(sym) */
        RELOC_HI16, /* hi16(sym) */
        RELOC_PC16, /* bb0, bb1, bcnd */
        RELOC_PC26, /* br, bsr */
        RELOC_32, /* jump tables, etc */
        RELOC_IW16, /* global access through linker regs 28 */
        NO_RELOC,
d88 3
a90 3
        unsigned int r_address;         /* offset in text or data segment */
        unsigned int r_symbolnum : 24,  /* ordinal number of add symbol */
                        r_extern :  1,  /* 1 if need to add symbol to value */
d100 2
a101 2
        unsigned int r_address;         /* offset in text or data segment */
	unsigned int 	  r_type : 4,
d105 2
a106 2
                        r_extern :  1,  /* 1 if need to add symbol to value */
                     r_symbolnum : 24;  /* ordinal number of add symbol */
d128 1
a128 1
#define md_swapin_reloc(r,n)  			md_in_reloc(r,n)
d152 1
a152 1
			  ( ((unsigned char *)(p))[1]     )   \
d157 1
a157 1
			  ( ((unsigned char *)(p))[3]      )   \
d165 1
a165 1
				((((unsigned long)(v))     ) & 0xff); }
d174 1
a174 1
				((((unsigned long)(v))      ) & 0xff); }
d177 1
a177 1
				((unsigned char *)(p))[0] & 0xfc);  	\
d183 1
a183 1
				((((unsigned long)(v))      ) & 0xff); }
d216 1
a216 1
#define md_swap_long(x) ( (((x) >> 24) & 0xff    ) | (((x) >> 8 ) & 0xff00   ) | \
@


1.3
log
@More MID for m88k updates, grr!
@
text
@d1 1
a1 1
/* * $OpenBSD: md.h,v 1.2 2000/02/01 21:01:40 espie Exp $*/
d3 1
a3 1
 *	- m68k dependent definitions
d13 4
d18 2
a19 2
/* XXX */
#define MID_MACHINE 153
@


1.2
log
@Cross-tools fixes:

* Rely on BYTE_ORDER instead of specific values of XHOST to determine
cross-endianness,

* Link necessary cross-includes to the right location,

* Add some necessary stubs for cross-endian sparc and cross-endian m68k.

This does let i386->m68k work, and probably brings i386->sparc most of the
way there...

Approved by mickey@@, niklas@@ is to busy to answer email as usual...
@
text
@d1 1
a1 1
/* * $OpenBSD: md.h,v 1.1 1999/02/09 05:35:14 smurph Exp $*/
d15 1
a15 1
#define MID_MACHINE 151
@


1.1
log
@Moved from mvme88k
@
text
@d1 1
a1 1
/* * $OpenBSD: md.h,v 1.2 1998/03/26 19:47:09 niklas Exp $*/
d6 4
a9 1
#if defined(CROSS_LINKER) && defined(XHOST) && XHOST==i386
a12 1
#if defined(CROSS_LINKER)
@

