head	1.20;
access;
symbols
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.20
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.16
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.18
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.14
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.12
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.10
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.9.0.8
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.6
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2013.07.05.21.31.47;	author miod;	state dead;
branches;
next	1.19;

1.19
date	2010.12.13.20.52.23;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.29.20.40.35;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.14.03.08.24;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.16.01.45.36;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.08.16.27.17;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.07.01.25.34;	author marc;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.19.19.28.12;	author marc;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.17.20.33.29;	author marc;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.15.21.05.57;	author marc;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.10.17.28.16;	author marc;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.28.15.32.40;	author form;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.30.15.14.34;	author form;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.27.22.14.57;	author form;	state Exp;
branches;
next	1.6;

1.6
date	96.12.18.16.50.07;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.18.04.55.53;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.29.01.01.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.28.22.02.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.12.19.56.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.40.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.40.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Put the a.out as and ld to rest in the Attic, finally!
@
text
@/*	$OpenBSD: ldconfig.c,v 1.19 2010/12/13 20:52:23 espie Exp $	*/

/*
 * Copyright (c) 1993,1995 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <ar.h>
#include <ranlib.h>
#include <a.out.h>
#include <stab.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ld.h"

#undef major
#undef minor

extern char			*__progname;

static int			verbose;
static int			nostd;
static int			justread;
static int			merge;
static int			rescan;
static int			unconfig;

struct shlib_list {
	/* Internal list of shared libraries found */
	char			*name;
	char			*path;
	int			dewey[MAXDEWEY];
	int			ndewey;
#define major dewey[0]
#define minor dewey[1]
	struct shlib_list	*next;
};

static struct shlib_list	*shlib_head = NULL, **shlib_tail = &shlib_head;
static char			*dir_list;

static void	enter(char *, char *, char *, int *, int);
static int	dodir(char *, int);
static int	buildhints(void);
static int	readhints(void);
static void	listhints(void);

int
main(int argc, char *argv[])
{
	int		i, c;
	int		rval = 0;

	while ((c = getopt(argc, argv, "RUmrsv")) != -1) {
		switch (c) {
		case 'R':
			rescan = 1;
			break;
		case 'U':
			rescan = unconfig = 1;
			break;
		case 'm':
			merge = 1;
			break;
		case 'r':
			justread = 1;
			break;
		case 's':
			nostd = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			(void)fprintf(stderr,
				"usage: %s [-RUmrsv] [dir ...]\n", __progname);
			exit(1);
			break;
		}
	}

	if (unconfig && merge)
		errx(1, "cannot use -U with -m");

	dir_list = xmalloc(1);
	*dir_list = '\0';

	if (justread || merge || rescan) {
		if ((rval = readhints()) != 0)
			return rval;
		if (justread) {
			listhints();
			return 0;
		}
		add_search_path(dir_list);
		dir_list = xrealloc(dir_list, 1);
		*dir_list = '\0';
	} else
		if (!nostd)
			std_search_path();

	if (unconfig) {
		if (optind < argc)
			for (i = optind; i < argc; i++)
				remove_search_dir(argv[i]);
		else {
			i = 0;
			while (i < n_search_dirs) {
				if (access(search_dirs[i], R_OK) < 0)
					remove_search_dir(search_dirs[i]);
				else
					i++;
			}
		}
	} else
		for (i = optind; i < argc; i++)
			add_search_dir(argv[i]);

	for (i = 0; i < n_search_dirs; i++) {
		char *cp = concat(dir_list, *dir_list?":":"", search_dirs[i]);
		free(dir_list);
		dir_list = cp;
		rval |= dodir(search_dirs[i], 0);
	}

	rval |= buildhints();

	return rval;
}

int
dodir(char *dir, int silent)
{
	DIR		*dd;
	struct dirent	*dp;
	char		name[MAXPATHLEN];
	int		dewey[MAXDEWEY], ndewey;

	if ((dd = opendir(dir)) == NULL) {
		if (!silent || errno != ENOENT)
			warn("%s", dir);
		return -1;
	}

	while ((dp = readdir(dd)) != NULL) {
		int n;
		char *cp;

		/* Check for `lib' prefix */
		if (dp->d_name[0] != 'l' ||
		    dp->d_name[1] != 'i' ||
		    dp->d_name[2] != 'b')
			continue;

		/* Copy the entry minus prefix */
		(void)strlcpy(name, dp->d_name + 3, sizeof name);
		n = strlen(name);
		if (n < 4)
			continue;

		/* Find ".so." in name */
		for (cp = name + n - 4; cp > name; --cp) {
			if (cp[0] == '.' &&
			    cp[1] == 's' &&
			    cp[2] == 'o' &&
			    cp[3] == '.')
				break;
		}
		if (cp <= name)
			continue;

		*cp = '\0';
		if (!isdigit(*(cp+4)))
			continue;

		bzero((caddr_t)dewey, sizeof(dewey));
		ndewey = getdewey(dewey, cp + 4);
		enter(dir, dp->d_name, name, dewey, ndewey);
	}

	return 0;
}

static void
enter(char *dir, char *file, char *name, int dewey[], int ndewey)
{
	struct shlib_list	*shp;

	for (shp = shlib_head; shp; shp = shp->next) {
		if (strcmp(name, shp->name) != 0 || major != shp->major)
			continue;

		/* Name matches existing entry */
		if (cmpndewey(dewey, ndewey, shp->dewey, shp->ndewey) > 0) {

			/* Update this entry with higher versioned lib */
			if (verbose)
				printf("Updating lib%s.%d.%d to %s/%s\n",
					shp->name, shp->major, shp->minor,
					dir, file);

			free(shp->name);
			shp->name = xstrdup(name);
			free(shp->path);
			shp->path = concat(dir, "/", file);
			bcopy(dewey, shp->dewey, sizeof(shp->dewey));
			shp->ndewey = ndewey;
		}
		break;
	}

	if (shp)
		/* Name exists: older version or just updated */
		return;

	/* Allocate new list element */
	if (verbose)
		printf("Adding %s/%s\n", dir, file);

	shp = (struct shlib_list *)xmalloc(sizeof *shp);
	shp->name = xstrdup(name);
	shp->path = concat(dir, "/", file);
	bcopy(dewey, shp->dewey, MAXDEWEY);
	shp->ndewey = ndewey;
	shp->next = NULL;

	*shlib_tail = shp;
	shlib_tail = &shp->next;
}


#if DEBUG
/* test */
#undef _PATH_LD_HINTS
#define _PATH_LD_HINTS		"./ld.so.hints"
#endif

static int
hinthash(char *cp, int vmajor, int vminor)
{
	int	k = 0;

	while (*cp)
		k = (((k << 1) + (k >> 14)) ^ (*cp++)) & 0x3fff;

	k = (((k << 1) + (k >> 14)) ^ (vmajor*257)) & 0x3fff;
#if 0
	k = (((k << 1) + (k >> 14)) ^ (vminor*167)) & 0x3fff;
#endif

	return k;
}

int
buildhints(void)
{
	struct hints_header	hdr;
	struct hints_bucket	*blist;
	struct shlib_list	*shp;
	char			*strtab;
	int			i, n, str_index = 0;
	int			strtab_sz = 0;	/* Total length of strings */
	int			nhints = 0;	/* Total number of hints */
	int			fd;
	char			*tmpfile;

	for (shp = shlib_head; shp; shp = shp->next) {
		strtab_sz += 1 + strlen(shp->name);
		strtab_sz += 1 + strlen(shp->path);
		nhints++;
	}

	/* Fill hints file header */
	hdr.hh_magic = HH_MAGIC;
	hdr.hh_version = LD_HINTS_VERSION_2;
	hdr.hh_nbucket = 1 * nhints;
	n = hdr.hh_nbucket * sizeof(struct hints_bucket);
	hdr.hh_hashtab = sizeof(struct hints_header);
	hdr.hh_strtab = hdr.hh_hashtab + n;
	hdr.hh_dirlist = strtab_sz;
	strtab_sz += 1 + strlen(dir_list);
	hdr.hh_strtab_sz = strtab_sz;
	hdr.hh_ehints = hdr.hh_strtab + hdr.hh_strtab_sz;

	if (verbose)
		printf("Totals: entries %d, buckets %ld, string size %d\n",
					nhints, hdr.hh_nbucket, strtab_sz);

	/* Allocate buckets and string table */
	blist = (struct hints_bucket *)xmalloc(n);
	bzero((char *)blist, n);
	for (i = 0; i < hdr.hh_nbucket; i++)
		/* Empty all buckets */
		blist[i].hi_next = -1;

	strtab = (char *)xmalloc(strtab_sz);

	/* Enter all */
	for (shp = shlib_head; shp; shp = shp->next) {
		struct hints_bucket	*bp;

		bp = blist +
		  (hinthash(shp->name, shp->major, shp->minor) % hdr.hh_nbucket);

		if (bp->hi_pathx) {
			int	i;

			for (i = 0; i < hdr.hh_nbucket; i++) {
				if (blist[i].hi_pathx == 0)
					break;
			}
			if (i == hdr.hh_nbucket) {
				warnx("Bummer!");
				return -1;
			}
			while (bp->hi_next != -1)
				bp = &blist[bp->hi_next];
			bp->hi_next = i;
			bp = blist + i;
		}

		/* Insert strings in string table */
		bp->hi_namex = str_index;
		strlcpy(strtab + str_index, shp->name, strtab_sz - str_index);
		str_index += 1 + strlen(shp->name);

		bp->hi_pathx = str_index;
		strlcpy(strtab + str_index, shp->path, strtab_sz - str_index);
		str_index += 1 + strlen(shp->path);

		/* Copy versions */
		bcopy(shp->dewey, bp->hi_dewey, sizeof(bp->hi_dewey));
		bp->hi_ndewey = shp->ndewey;
	}

	/* Copy search directories */
	strlcpy(strtab + str_index, dir_list, strtab_sz - str_index);
	str_index += 1 + strlen(dir_list);

	/* Sanity check */
	if (str_index != strtab_sz) {
		errx(1, "str_index(%d) != strtab_sz(%d)", str_index, strtab_sz);
	}

	tmpfile = concat(_PATH_LD_HINTS, ".XXXXXXXXXX", "");
	if ((fd = mkstemp(tmpfile)) == -1) {
		warn("%s", tmpfile);
		return -1;
	}
	fchmod(fd, 0444);

	if (write(fd, &hdr, sizeof(struct hints_header)) !=
	    sizeof(struct hints_header)) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}
	if (write(fd, blist, hdr.hh_nbucket * sizeof(struct hints_bucket)) !=
		  hdr.hh_nbucket * sizeof(struct hints_bucket)) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}
	if (write(fd, strtab, strtab_sz) != strtab_sz) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}
	if (close(fd) != 0) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}

	if (rename(tmpfile, _PATH_LD_HINTS) != 0) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}

	return 0;
}

static int
readhints(void)
{
	struct stat		sb;
	int			fd;
	caddr_t			addr;
	long			msize;
	struct hints_header	*hdr;
	struct hints_bucket	*blist;
	char			*strtab;
	struct shlib_list	*shp;
	int			i;

	if ((fd = open(_PATH_LD_HINTS, O_RDONLY, 0)) == -1) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}

	if (fstat(fd, &sb) != 0 || !S_ISREG(sb.st_mode) ||
	    sb.st_size < sizeof(struct hints_header) || sb.st_size > LONG_MAX) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}

	msize =  (long)sb.st_size;
	addr = mmap(0, msize, PROT_READ, MAP_COPY, fd, 0);

	if (addr == (caddr_t)-1) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}

	hdr = (struct hints_header *)addr;
	if (HH_BADMAG(*hdr)) {
		warnx("%s: Bad magic: %lo",
			_PATH_LD_HINTS, hdr->hh_magic);
		return -1;
	}

	if (hdr->hh_ehints > msize) {
		warnx("%s: hintsize greater than filesize: 0x%x > 0x%x ",
		    _PATH_LD_HINTS, hdr->hh_ehints, msize);
		    return -1;
	}

	if (hdr->hh_version != LD_HINTS_VERSION_2) {
		warnx("Unsupported version: %ld", hdr->hh_version);
		return -1;
	}

	close(fd);

	blist = (struct hints_bucket *)(addr + hdr->hh_hashtab);
	strtab = (char *)(addr + hdr->hh_strtab);

	dir_list = xstrdup(strtab + hdr->hh_dirlist);

	if (rescan)
		return (0);

	for (i = 0; i < hdr->hh_nbucket; i++) {
		struct hints_bucket	*bp = &blist[i];

		/* Sanity check */
		if (bp->hi_namex >= hdr->hh_strtab_sz) {
			warnx("Bad name index: %#x", bp->hi_namex);
			return -1;
		}
		if (bp->hi_pathx >= hdr->hh_strtab_sz) {
			warnx("Bad path index: %#x", bp->hi_pathx);
			return -1;
		}

		/* Allocate new list element */
		shp = (struct shlib_list *)xmalloc(sizeof *shp);
		shp->name = xstrdup(strtab + bp->hi_namex);
		shp->path = xstrdup(strtab + bp->hi_pathx);
		bcopy(bp->hi_dewey, shp->dewey, sizeof(shp->dewey));
		shp->ndewey = bp->hi_ndewey;
		shp->next = NULL;

		*shlib_tail = shp;
		shlib_tail = &shp->next;
	}

	return 0;
}

static void
listhints(void)
{
	struct shlib_list	*shp;
	int			i;

	printf("%s:\n", _PATH_LD_HINTS);
	printf("\tsearch directories: %s\n", dir_list);

	for (i = 0, shp = shlib_head; shp; i++, shp = shp->next)
		printf("\t%d:-l%s.%d.%d => %s\n",
			i, shp->name, shp->major, shp->minor, shp->path);

	return;
}
@


1.19
log
@same bug, should have guessed this would come from gnu portability stupidity.
as noted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.18 2005/09/29 20:40:35 deraadt Exp $	*/
@


1.18
log
@bounded string handlings; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.17 2004/08/14 03:08:24 drahn Exp $	*/
a406 6
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}

	/* Install it */
	if (unlink(_PATH_LD_HINTS) != 0 && errno != ENOENT) {
@


1.17
log
@When reading the ld.so hints file, map the entire file in a single mmap
instead of assuming the region after the first mmap is available. Same
change was made to ELF ld.so previously. ok deraadt miod pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.16 2003/04/16 01:45:36 deraadt Exp $	*/
d364 1
a364 1
		strcpy(strtab + str_index, shp->name);
d368 1
a368 1
		strcpy(strtab + str_index, shp->path);
d377 1
a377 1
	strcpy(strtab + str_index, dir_list);
@


1.16
log
@string cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.15 2002/12/08 16:27:17 millert Exp $	*/
d428 1
d443 7
a449 1
	msize = PAGSIZ;
d464 6
a474 9
	if (hdr->hh_ehints > msize) {
		if (mmap(addr+msize, hdr->hh_ehints - msize,
				PROT_READ, MAP_COPY|MAP_FIXED,
				fd, msize) != (caddr_t)(addr+msize)) {

			warn("%s", _PATH_LD_HINTS);
			return -1;
		}
	}
@


1.15
log
@getopt returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.14 2002/09/07 01:25:34 marc Exp $	*/
d196 1
a196 1
		(void)strcpy(name, dp->d_name + 3);
@


1.14
log
@
ansification of ld

* normalized the signatures of the functions passed to each_file()
   and each_full_file().  In most cases that meant adding a void *dummy.
   In one case it changed an int to a void*, but the arg was only checked
   for zero/not-zero so the change was not significant.

 * removes unused code and structures.

 * makes sure printf args match their format.

 * got rid of some of the gcc -Wall warnings

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.13 2002/07/19 19:28:12 marc Exp $	*/
d94 1
a94 1
	while ((c = getopt(argc, argv, "RUmrsv")) != EOF) {
@


1.13
log
@convert functions from K&R style to prototype style.
Function arg types have not yet been fixed.  OK fgs@@, espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.12 2002/07/17 20:33:29 marc Exp $	*/
d278 1
a278 1
int
@


1.12
log
@un-__P the code.   fgs says "looks ok."
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.11 2002/07/15 21:05:57 marc Exp $	*/
d89 1
a89 3
main(argc, argv)
int	argc;
char	*argv[];
d172 1
a172 3
dodir(dir, silent)
char	*dir;
int	silent;
d225 1
a225 3
enter(dir, file, name, dewey, ndewey)
char	*dir, *file, *name;
int	dewey[], ndewey;
d279 1
a279 3
hinthash(cp, vmajor, vminor)
char	*cp;
int	vmajor, vminor;
d295 1
a295 1
buildhints()
d426 1
a426 1
readhints()
d510 1
a510 1
listhints()
@


1.11
log
@
space to tab cleanup.   Nothing but whitespace changes in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.10 2002/07/10 17:28:16 marc Exp $	*/
d82 5
a86 5
static void	enter __P((char *, char *, char *, int *, int));
static int	dodir __P((char *, int));
static int	buildhints __P((void));
static int	readhints __P((void));
static void	listhints __P((void));
@


1.10
log
@
First of some clean-up commits.  This one only removes use of
register variables.   clean-up concept ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.9 2000/06/28 15:32:40 form Exp $	*/
d17 1
a17 1
 *      This product includes software developed by Paul Kranenburg.
@


1.9
log
@Improve remove_search_dir(), avoid memory leak.
Add support for -U option:
  Unconfigure directories specified on the command line or remove
  inaccessible directories from search path if no directories spec-
  ified. This option cannot be used with -m.
- this option helps to correctly pkg_delete packages like postgresql,
mysql (with shared libs in package's own directory).
ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.8 2000/04/30 15:14:34 form Exp $	*/
d190 2
a191 2
		register int n;
		register char *cp;
@


1.8
log
@- do not miss /usr/lib in search path.
- ldconfig -R: do not add /usr/lib to search path,
  use previously configured dirs instead.
- avoid duplicates in search path

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.7 2000/01/27 22:14:57 form Exp $	*/
d66 1
d96 1
a96 1
	while ((c = getopt(argc, argv, "Rmrsv")) != EOF) {
d101 3
d117 3
a119 2
			errx(1, "Usage: %s [-Rmrsv] [dir ...]",
				__progname);
d124 3
d144 16
a159 2
	for (i = optind; i < argc; i++)
		add_search_dir(argv[i]);
@


1.7
log
@Add `-R' option (rescan previously configured directories) support.
Tested by espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.6 1996/12/18 16:50:07 millert Exp $	*/
d113 1
a113 1
			errx(1, "Usage: %s [-mrsv] [dir ...]",
a128 5
	}

	if (!nostd && !merge)
		std_search_path();
	if (rescan)
d130 5
d136 2
a137 2
	for (i = 0; i < n_search_dirs; i++)
		rval |= dodir(search_dirs[i], 1);
d139 2
a140 3
	for (i = optind; i < argc; i++) {
		/* Check for duplicates? */
		char *cp = concat(dir_list, *dir_list?":":"", argv[i]);
d143 1
a143 1
		rval |= dodir(argv[i], 0);
d227 1
a227 2
			if ((shp->name = strdup(name)) == NULL)
				errx(1, "virtual memory exhausted");
d245 1
a245 2
	if ((shp->name = strdup(name)) == NULL)
		errx(1, "virtual memory exhausted");
d462 4
a465 13
	if (justread || !rescan) {
		for (i = 0; i < hdr->hh_nbucket; i++) {
			struct hints_bucket	*bp = &blist[i];

			/* Sanity check */
			if (bp->hi_namex >= hdr->hh_strtab_sz) {
				warnx("Bad name index: %#x", bp->hi_namex);
				return -1;
			}
			if (bp->hi_pathx >= hdr->hh_strtab_sz) {
				warnx("Bad path index: %#x", bp->hi_pathx);
				return -1;
			}
d467 2
a468 9
			/* Allocate new list element */
			shp = (struct shlib_list *)xmalloc(sizeof *shp);
			if ((shp->name = strdup(strtab + bp->hi_namex)) == NULL)
				errx(1, "virtual memory exhausted");
			if ((shp->path = strdup(strtab + bp->hi_pathx)) == NULL)
				errx(1, "virtual memory exhausted");
			bcopy(bp->hi_dewey, shp->dewey, sizeof(shp->dewey));
			shp->ndewey = bp->hi_ndewey;
			shp->next = NULL;
d470 8
a477 2
			*shlib_tail = shp;
			shlib_tail = &shp->next;
d479 11
a490 3

	if ((dir_list = strdup(strtab + hdr->hh_dirlist)) == NULL)
		errx(1, "virtual memory exhausted");
@


1.6
log
@Back out strcpy() -> strncpy() change.  Not needed as the array is malloc'd
with enough space.  Guess that's why I didn't commit this before ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.5 1996/12/18 04:55:53 millert Exp $	*/
d65 1
d95 1
a95 1
	while ((c = getopt(argc, argv, "mrsv")) != EOF) {
d97 3
d122 1
a122 1
	if (justread || merge) {
d133 2
d465 23
a487 2
	for (i = 0; i < hdr->hh_nbucket; i++) {
		struct hints_bucket	*bp = &blist[i];
d489 2
a490 4
		/* Sanity check */
		if (bp->hi_namex >= hdr->hh_strtab_sz) {
			warnx("Bad name index: %#x", bp->hi_namex);
			return -1;
d492 1
a492 14
		if (bp->hi_pathx >= hdr->hh_strtab_sz) {
			warnx("Bad path index: %#x", bp->hi_pathx);
			return -1;
		}

		/* Allocate new list element */
		shp = (struct shlib_list *)xmalloc(sizeof *shp);
		if ((shp->name = strdup(strtab + bp->hi_namex)) == NULL)
			errx(1, "virtual memory exhausted");
		if ((shp->path = strdup(strtab + bp->hi_pathx)) == NULL)
			errx(1, "virtual memory exhausted");
		bcopy(bp->hi_dewey, shp->dewey, sizeof(shp->dewey));
		shp->ndewey = bp->hi_ndewey;
		shp->next = NULL;
a493 3
		*shlib_tail = shp;
		shlib_tail = &shp->next;
	}
@


1.5
log
@Use strncpy() instead of strcpy() where useful, check strdup()
ret val, and pass -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.4 1996/10/29 01:01:06 deraadt Exp $	*/
d347 1
a347 2
		strncpy(strtab + str_index, shp->name, strtab_sz - str_index - 1);
		strtab[strtab_sz-1] = '\0';
d351 1
a351 2
		strncpy(strtab + str_index, shp->path, strtab_sz - str_index - 1);
		strtab[strtab_sz-1] = '\0';
d360 1
a360 2
	strncpy(strtab + str_index, dir_list, strtab_sz - str_index - 1);
	strtab[strtab_sz-1] = '\0';
@


1.4
log
@mktemp is evil
@
text
@d1 1
a1 1
/*	$OpenBSD: ldconfig.c,v 1.3 1996/06/28 22:02:27 deraadt Exp $	*/
d40 1
d42 1
d123 1
a123 1
			return;
d222 2
a223 1
			shp->name = strdup(name);
d241 2
a242 1
	shp->name = strdup(name);
d309 1
a309 1
		printf("Totals: entries %d, buckets %d, string size %d\n",
d347 2
a348 1
		strcpy(strtab + str_index, shp->name);
d352 2
a353 1
		strcpy(strtab + str_index, shp->path);
d362 2
a363 1
	strcpy(strtab + str_index, dir_list);
d438 1
a438 1
		warnx("%s: Bad magic: %o",
d444 1
a444 1
		warnx("Unsupported version: %d", hdr->hh_version);
d477 4
a480 2
		shp->name = strdup(strtab + bp->hi_namex);
		shp->path = strdup(strtab + bp->hi_pathx);
d488 2
a489 1
	dir_list = strdup(strtab + hdr->hh_dirlist);
@


1.3
log
@fix usage message; netbsd pr#2580; jhawk@@mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d364 2
a365 2
	tmpfile = concat(_PATH_LD_HINTS, ".XXXXXX", "");
	if ((tmpfile = mktemp(tmpfile)) == NULL) {
d369 1
a369 6

	umask(0);	/* Create with exact permissions */
	if ((fd = open(tmpfile, O_RDWR|O_CREAT|O_TRUNC, 0444)) == -1) {
		warn("%s", _PATH_LD_HINTS);
		return -1;
	}
@


1.2
log
@from netbsd:
Create v.2 hint files.
Note: don't bother to understand v.1 files..
@
text
@d1 2
a30 2
 *
 *	$Id: ldconfig.c,v 1.13 1996/01/09 00:04:35 pk Exp $
d107 1
a107 1
			errx(1, "Usage: %s [-r][-s][-v][dir ...]",
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
 *	$Id: ldconfig.c,v 1.12 1995/08/25 11:35:35 pk Exp $
d76 1
d113 3
d131 5
a135 1
	for (i = optind; i < argc; i++)
d137 1
d266 1
d268 1
d294 1
a294 1
	hdr.hh_version = LD_HINTS_VERSION_1;
d299 2
d355 9
d441 1
a441 1
	if (hdr->hh_version != LD_HINTS_VERSION_1) {
d484 1
d496 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
