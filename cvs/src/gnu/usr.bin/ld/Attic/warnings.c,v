head	1.13;
access;
symbols
	OPENBSD_5_3:1.12.0.22
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.20
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.18
	OPENBSD_5_0:1.12.0.16
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.14
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.12
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.8
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.10
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.6
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2013.07.05.21.31.47;	author miod;	state dead;
branches;
next	1.12;

1.12
date	2008.02.12.21.17.53;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.21.01.40.22;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.16.02.15.10;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.07.01.25.34;	author marc;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.19.19.28.12;	author marc;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.17.20.33.29;	author marc;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.15.21.05.56;	author marc;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.10.17.28.16;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.23.14.57.29;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	98.03.26.19.46.29;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.07.08.09.34.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.40.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.40.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Put the a.out as and ld to rest in the Attic, finally!
@
text
@/* * $OpenBSD: warnings.c,v 1.12 2008/02/12 21:17:53 miod Exp $*/
/*
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/time.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <ar.h>
#include <ranlib.h>
#include <a.out.h>
#include <stab.h>
#include <string.h>
#if __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#include "ld.h"

static int reported_undefineds;

/*
 * Print the filename of ENTRY on OUTFILE (a stdio stream),
 * and then a newline.
 */

void
prline_file_name(struct file_entry *entry, FILE *outfile)
{
	print_file_name (entry, outfile);
	fprintf (outfile, "\n");
}

/*
 * Print the filename of ENTRY on OUTFILE (a stdio stream).
 */

void
print_file_name(struct file_entry *entry, FILE *outfile)
{
	if (entry == NULL) {
		fprintf (outfile, "NULL");
	}

	if (entry->superfile) {
		print_file_name (entry->superfile, outfile);
		fprintf (outfile, "(%s)", entry->filename);
	} else
		fprintf (outfile, "%s", entry->filename);
}

/*
 * Return the filename of entry as a string (malloc'd for the purpose)
 */

char *
get_file_name(struct file_entry *entry)
{
	char *result, *supfile;
	size_t len;

	if (entry == NULL) {
		return (char *)strdup("NULL");
	}

	if (entry->superfile) {
		supfile = get_file_name(entry->superfile);
		len = strlen(supfile) + 1 + strlen(entry->filename) + 2;
		result = (char *)
			xmalloc(len);
		(void)snprintf(result, len, "%s(%s)", supfile,
		    entry->filename);
		free(supfile);

	} else {
		result = (char *)xstrdup(entry->filename);
	}
	return result;
}

/* Print a complete or partial map of the output file. */

static void	describe_file_sections(struct file_entry *, void *);
static void	list_file_locals(struct file_entry *, void *);

void
print_symbols(FILE *outfile)
{
	fprintf(outfile, "\nFiles:\n\n");
	each_file(describe_file_sections, (void *)outfile);

	fprintf(outfile, "\nGlobal symbols:\n\n");
	FOR_EACH_SYMBOL(i, sp) {
		fprintf(outfile, "  %s: ", sp->name);
		if (!(sp->flags & GS_REFERENCED))
			fprintf(outfile, "unreferenced");
		else if (sp->so_defined)
			fprintf(outfile, "sodefined");
		else if (!sp->defined)
			fprintf(outfile, "undefined");
		else if (sp->defined == (N_UNDF|N_EXT))
			fprintf(outfile, "common: size %#x", sp->common_size);
		else
			fprintf(outfile, "type %d, value %#lx, size %#x",
				sp->defined, sp->value, sp->size);
		if (sp->alias)
			fprintf(outfile, ", aliased to %s", sp->alias->name);
		fprintf(outfile, "\n");
	} END_EACH_SYMBOL;

	each_file(list_file_locals, (void *)outfile);
}

static void
describe_file_sections(struct file_entry *entry, void *arg)
{
	FILE *outfile = arg;

	fprintf(outfile, "  ");
	print_file_name(entry, outfile);
	if (entry->flags & (E_JUST_SYMS | E_DYNAMIC))
		fprintf(outfile, " symbols only\n");
	else
		fprintf(outfile, " text %x(%x), data %x(%x), bss %x(%x) hex\n",
			entry->text_start_address, entry->header.a_text,
			entry->data_start_address, entry->header.a_data,
			entry->bss_start_address, entry->header.a_bss);
}

static void
list_file_locals(struct file_entry *entry, void *arg)
{
	FILE			*outfile = arg;
	struct localsymbol	*lsp, *lspend;

	entry->strings = (char *)alloca(entry->string_size);
	read_entry_strings (file_open(entry), entry);

	fprintf (outfile, "\nLocal symbols of ");
	print_file_name (entry, outfile);
	fprintf (outfile, ":\n\n");

	lspend = entry->symbols + entry->nsymbols;
	for (lsp = entry->symbols; lsp < lspend; lsp++) {
		struct nlist *p = &lsp->nzlist.nlist;
		/*
		 * If this is a definition,
		 * update it if necessary by this file's start address.
		 */
		if (!(p->n_type & (N_STAB | N_EXT)))
			fprintf(outfile, "  %s: 0x%lx\n",
				entry->strings + p->n_un.n_strx, p->n_value);
	}

	entry->strings = 0;		/* All done with them.  */
}


/* Static vars for do_warnings and subroutines of it */
static int list_unresolved_refs;	/* List unresolved refs */
static int list_multiple_defs;		/* List multiple definitions */

static struct line_debug_entry *init_debug_scan(int, struct file_entry *);
static int	next_debug_entry(int, struct line_debug_entry *);

/*
 * Structure for communication between do_file_warnings and it's
 * helper routines.  Will in practice be an array of three of these:
 * 0) Current line, 1) Next line, 2) Source file info.
 */
struct line_debug_entry
{
	int			line;
	char			*filename;
	struct localsymbol	*sym;
};

/*
 * Helper routines for do_file_warnings.
 */

/*
 * Return an integer less than, equal to, or greater than 0 as per the
 * relation between the two relocation entries.  Used by qsort.
 */

static int
reloc_cmp(const void *arg1, const void *arg2)
{
	const struct relocation_info *rel1 = arg1;
	const struct relocation_info *rel2 = arg2;
	return RELOC_ADDRESS(rel1) - RELOC_ADDRESS(rel2);
}

/*
 * Moves to the next debugging symbol in the file.  USE_DATA_SYMBOLS
 * determines the type of the debugging symbol to look for (DSLINE or
 * SLINE).  STATE_POINTER keeps track of the old and new locatiosn in
 * the file.  It assumes that state_pointer[1] is valid; ie
 * that it.sym points into some entry in the symbol table.  If
 * state_pointer[1].sym == 0, this routine should not be called.
 */

static int
next_debug_entry(int use_data_symbols, struct line_debug_entry state_pointer[3])
{
	struct line_debug_entry	*current = state_pointer,
				*next = state_pointer + 1,
				/* Used to store source file */
				*source = state_pointer + 2;

	struct file_entry	*entry = (struct file_entry *)source->sym;
	struct localsymbol	*lspend = entry->symbols + entry->nsymbols;


	current->sym = next->sym;
	current->line = next->line;
	current->filename = next->filename;

	while (++(next->sym) < lspend) {

		struct nlist	*np = &next->sym->nzlist.nlist;

		/*
		 * n_type is a char, and N_SOL, N_EINCL and N_BINCL are > 0x80,
		 * so may look negative...therefore, must mask to low bits
		 */
		switch (np->n_type & 0xff) {
		case N_SLINE:
			if (use_data_symbols)
				continue;
			next->line = np->n_desc;
			return 1;
		case N_DSLINE:
			if (!use_data_symbols)
				continue;
			next->line = np->n_desc;
			return 1;
#ifdef HAVE_SUN_STABS
		case N_EINCL:
			next->filename = source->filename;
			continue;
#endif
		case N_SO:
			source->filename = np->n_un.n_strx + entry->strings;
			source->line++;
#ifdef HAVE_SUN_STABS
		case N_BINCL:
#endif
		case N_SOL:
			next->filename = np->n_un.n_strx + entry->strings;
		default:
			continue;
		}
	}
	next->sym = (struct localsymbol *)0;
	return 0;
}

/*
 * Create a structure to save the state of a scan through the debug symbols.
 * USE_DATA_SYMBOLS is set if we should be scanning for DSLINE's instead of
 * SLINE's. ENTRY is the file entry which points at the symbols to use.
 */

static struct line_debug_entry *
init_debug_scan(int use_data_symbols, struct file_entry *entry)
{
	struct localsymbol	*lsp, *lspend;
	struct line_debug_entry *state_pointer, *current, *next, *source;

	state_pointer = (struct line_debug_entry *)
		xmalloc(3 * sizeof(*state_pointer));

	current = state_pointer,
	next = state_pointer + 1,
	source = state_pointer + 2;	/* Used to store source file */

	lspend = entry->symbols+entry->nsymbols;

	for (lsp = entry->symbols; lsp < lspend; lsp++)
		if (lsp->nzlist.nlist.n_type == N_SO)
			break;

	if (lsp >= lspend) {
		/* I believe this translates to "We lose" */
		current->filename = next->filename = entry->filename;
		current->line = next->line = -1;
		current->sym = next->sym = (struct localsymbol *)0;
		return state_pointer;
	}
	next->line = source->line = 0;
	next->filename = source->filename
			= (lsp->nzlist.nlist.n_un.n_strx + entry->strings);
	source->sym = (struct localsymbol *)entry;
	next->sym = lsp;

	/* To setup next */
	next_debug_entry(use_data_symbols, state_pointer);

	if (!next->sym) {	/* No line numbers for this section; */
		/* setup output results as appropriate */
		if (source->line) {
			current->filename = source->filename = entry->filename;
			current->line = -1;	/* Don't print lineno */
		} else {
			current->filename = source->filename;
			current->line = 0;
		}
		return state_pointer;
	}
	/* To setup current */
	next_debug_entry(use_data_symbols, state_pointer);

	return state_pointer;
}

/*
 * Takes an ADDRESS (in either text or data space) and a STATE_POINTER which
 * describes the current location in the implied scan through the debug
 * symbols within the file which ADDRESS is within, and returns the source
 * line number which corresponds to ADDRESS.
 */

static int
address_to_line(unsigned long address, struct line_debug_entry state_pointer[3])
{
	struct line_debug_entry	*current, *next, *tmp_pointer;
	int			use_data_symbols;

	current = state_pointer;
	next = state_pointer + 1;

	if (next->sym)
		use_data_symbols =
			(next->sym->nzlist.nlist.n_type & N_TYPE) == N_DATA;
	else
		return current->line;

	/* Go back to the beginning if we've already passed it. */
	if (current->sym->nzlist.nlist.n_value > address) {
		tmp_pointer = init_debug_scan(use_data_symbols,
					      (struct file_entry *)
					      ((state_pointer + 2)->sym));
		state_pointer[0] = tmp_pointer[0];
		state_pointer[1] = tmp_pointer[1];
		state_pointer[2] = tmp_pointer[2];
		free(tmp_pointer);
	}

	/* If we're still in a bad way, return -1, meaning invalid line. */
	if (current->sym->nzlist.nlist.n_value > address)
		return -1;

	while (next->sym
	       && next->sym->nzlist.nlist.n_value <= address
	       && next_debug_entry(use_data_symbols, state_pointer));

	return current->line;
}


/* Macros for manipulating bitvectors.  */
#define	BIT_SET_P(bv, index)	((bv)[(index) >> 3] & 1 << ((index) & 0x7))
#define	SET_BIT(bv, index)	((bv)[(index) >> 3] |= 1 << ((index) & 0x7))

/*
 * This routine will scan through the relocation data of file ENTRY, printing
 * out references to undefined symbols and references to symbols defined in
 * files with N_WARNING symbols.  If DATA_SEGMENT is non-zero, it will scan
 * the data relocation segment (and use N_DSLINE symbols to track line
 * number); otherwise it will scan the text relocation segment.  Warnings
 * will be printed on the output stream OUTFILE.  Eventually, every nlist
 * symbol mapped through will be marked in the NLIST_BITVECTOR, so we don't
 * repeat ourselves when we scan the nlists themselves.
 */

static void
do_relocation_warnings(struct file_entry *entry, int data_segment,
		       FILE *outfile, unsigned char *nlist_bitvector)
{
	struct relocation_info	*rp, *erp;
	int			start_of_segment;
	struct localsymbol	*start_of_syms;
	struct line_debug_entry	*state_pointer, *current;
	/* Assigned to generally static values; should not be written into.  */
	char *errfmt;
	/*
	 * Assigned to alloca'd values cand copied into; should be freed when
	 * done.
	 */
	char *errmsg;
	int  invalidate_line_number;

	rp = data_segment ? entry->datarel : entry->textrel;
	erp = data_segment ? (rp + entry->ndatarel) : (rp + entry->ntextrel);
	start_of_syms = entry->symbols;
	start_of_segment = (data_segment ?
		entry->data_start_address :
		entry->text_start_address);
	state_pointer = init_debug_scan(data_segment != 0, entry);
	current = state_pointer;

	/*
	 * We need to sort the relocation info here.  Sheesh, so much effort
	 * for one lousy error optimization.
	 */
	qsort(rp, erp - rp, sizeof(rp[0]), reloc_cmp);

	for (; rp < erp; rp++) {
		struct localsymbol *lsp;
		symbol *g;

		/*
		 * If the relocation isn't resolved through a symbol, continue.
		 */
		if (!RELOC_EXTERN_P(rp))
			continue;

		lsp = &entry->symbols[RELOC_SYMBOL(rp)];

		/*
		 * Local symbols shouldn't ever be used by relocation info,
		 * so the next should be safe. This is, of course, wrong.
		 * References to local BSS symbols can be the targets of
		 * relocation info, and they can (must) be resolved through
		 * symbols.  However, these must be defined properly, (the
		 * assembler would have caught it otherwise), so we can
		 * ignore these cases.
		 */

		if ((g = lsp->symbol) == NULL)
			continue;

		if (!(lsp->nzlist.nz_type & N_EXT) &&
		    !SET_ELEMENT_P(lsp->nzlist.nz_type)) {
			warnx("internal error: `%s' N_EXT not set", g->name);
			continue;
		}

		errmsg = 0;

		if (!g->defined && !g->so_defined && list_unresolved_refs) {
			/* Mark as being noted by relocation warning pass. */
			SET_BIT(nlist_bitvector, lsp - start_of_syms);

			if (g->undef_refs == 0)
				reported_undefineds++;
			if (g->undef_refs >= MAX_UREFS_PRINTED)
				/* Listed too many */
				continue;
			/* Undefined symbol which we should mention */

			if (++(g->undef_refs) == MAX_UREFS_PRINTED) {
				errfmt = "More undefined symbol %s refs follow";
				invalidate_line_number = 1;
			} else {
				errfmt =
			"Undefined symbol `%s' referenced from %s segment";
				invalidate_line_number = 0;
			}
		} else {	/* Defined */
			/* Potential symbol warning here */
			if (!g->warning)
				continue;

			if (BIT_SET_P(nlist_bitvector, lsp - start_of_syms))
				continue;

			/* Mark as being noted by relocation warning pass.  */
			SET_BIT(nlist_bitvector, lsp - start_of_syms);

			errfmt = 0;
			errmsg = g->warning;
			invalidate_line_number = 0;
		}


		/* If errfmt == 0, errmsg has already been defined.  */
		if (errfmt != 0) {
			char	       *nm;
			size_t		len;

			nm = g->name;
			len = strlen(errfmt) + strlen(nm) + 1;
			errmsg = (char *)
				xmalloc(len);
			snprintf(errmsg, len, errfmt, nm,
			    data_segment?"data":"text");
			if (nm != g->name)
				free(nm);
		}
		address_to_line(RELOC_ADDRESS(rp) + start_of_segment,
				state_pointer);

		if (current->line >= 0)
			fprintf(outfile, "%s:%d: %s\n",
				current->filename,
				invalidate_line_number ? 0 : current->line,
				errmsg);
		else
			fprintf(outfile, "%s: %s\n", current->filename, errmsg);

		if (errfmt != 0)
			free(errmsg);
	}

	free(state_pointer);
}

/*
 * Print on OUTFILE a list of all warnings generated by references and/or
 * definitions in the file ENTRY.  List source file and line number if
 * possible, just the .o file if not.
 */

static void
do_file_warnings(struct file_entry *entry, void *arg)
{
	int	nsym;
	int	i;
	char	*errfmt, *file_name;
	int	line_number;
	int	dont_allow_symbol_name;
	u_char	*nlist_bitvector;
	struct line_debug_entry	*text_scan, *data_scan;
	FILE	*outfile = arg;

	nsym = entry->nsymbols;
	nlist_bitvector = (u_char *)alloca((nsym >> 3) + 1);
	bzero(nlist_bitvector, (nsym >> 3) + 1);

	/* Read in the strings */
	entry->strings = (char *)alloca(entry->string_size);
	read_entry_strings(file_open(entry), entry);

	if (!(entry->flags & E_DYNAMIC)) {
		/* Do text warnings based on a scan through the reloc info. */
		do_relocation_warnings(entry, 0, outfile, nlist_bitvector);

		/* Do data warnings based on a scan through the reloc info. */
		do_relocation_warnings(entry, 1, outfile, nlist_bitvector);
	}

	/*
	 * Scan through all of the nlist entries in this file and pick up
	 * anything that the scan through the relocation stuff didn't.
	 */
	text_scan = init_debug_scan(0, entry);
	data_scan = init_debug_scan(1, entry);

	for (i = 0; i < nsym; i++) {
		struct nlist *np;
		symbol *g;

		g = entry->symbols[i].symbol;
		np = &entry->symbols[i].nzlist.nlist;

		if (g == NULL)
			continue;

		if (!(np->n_type & N_EXT) && !SET_ELEMENT_P(np->n_type)) {
			warnx("internal error: `%s' N_EXT not set", g->name);
			continue;
		}

		if (!(g->flags & GS_REFERENCED)) {
#if 0
			/* Check for undefined shobj symbols */
			struct localsymbol	*lsp;
			int			type;

			for (lsp = g->sorefs; lsp; lsp = lsp->next) {
				type = lsp->nzlist.nz_type;
				if ((type & N_EXT) &&
						type != (N_UNDF | N_EXT)) {
					break;
				}
			}
			if (type == (N_UNDF | N_EXT)) {
				fprintf(stderr,
					"Undefined symbol %s referenced from %s\n",
					g->name,
					get_file_name(entry));
			}
#endif
			continue;
		}

		dont_allow_symbol_name = 0;

		if (list_multiple_defs && g->mult_defs) {

			errfmt = "Definition of symbol `%s' (multiply defined)";
			switch (np->n_type) {
			case N_TEXT | N_EXT:
				line_number =
					address_to_line(np->n_value, text_scan);
				file_name = text_scan[0].filename;
				break;

			case N_DATA | N_EXT:
				line_number =
					address_to_line(np->n_value, data_scan);
				file_name = data_scan[0].filename;
				break;

			case N_SETA | N_EXT:
			case N_SETT | N_EXT:
			case N_SETD | N_EXT:
			case N_SETB | N_EXT:
				if (g->mult_defs == 2)
					continue;
				errfmt =
	"First set element definition of symbol `%s' (multiply defined)";
				line_number = -1;
				break;

			case N_SIZE | N_EXT:
				errfmt =
	"Size element definition of symbol `%s' (multiply defined)";
				line_number = -1;
				break;

			case N_INDR | N_EXT:
				errfmt =
	"Alias definition of symbol `%s' (multiply defined)";
				line_number = -1;
				break;

			case N_UNDF | N_EXT:
				/* Don't print out multiple defs at references.*/
				continue;

			default:
				warnx("%s: unexpected multiple definitions "
				      "of symbol `%s', type %#x",
				      get_file_name(entry),
				      g->name, np->n_type);
				line_number = -1;
				break;
			}

		} else if (BIT_SET_P(nlist_bitvector, i)) {
			continue;
		} else if (list_unresolved_refs &&
			   !g->defined && !g->so_defined) {

			if (g->undef_refs == 0)
				reported_undefineds++;
			if (g->undef_refs >= MAX_UREFS_PRINTED)
				continue;
			if (++(g->undef_refs) == MAX_UREFS_PRINTED)
				errfmt = "More undefined `%s' refs follow";
			else
				errfmt = "Undefined symbol `%s' referenced";
			line_number = -1;
		} else if (g->def_lsp && g->def_lsp->entry != entry &&
			   !(entry->flags & E_DYNAMIC) &&
			   g->def_lsp->entry->flags & E_SECONDCLASS) {
			if (g->undef_refs == 0)
			    reported_undefineds++;
			if (g->undef_refs >= MAX_UREFS_PRINTED)
				continue;
			if (++(g->undef_refs) == MAX_UREFS_PRINTED) {
				errfmt = "More undefined `%s' refs follow";
				line_number = -1;
			} else {
				fprintf(outfile,
			    "%s: Undefined symbol `%s' referenced (use %s ?)\n",
				    get_file_name(entry),
				    g->name,
				    g->def_lsp->entry->local_sym_name);
				continue;
			}
		} else if (g->warning) {
			/*
			 * There are two cases in which we don't want to do
			 * this. The first is if this is a definition instead
			 * of a reference. The second is if it's the reference
			 * used by the warning stabs itself.
			 */
			if (np->n_type != (N_EXT | N_UNDF) ||
			    (entry->symbols[i].flags & LS_WARNING))
				continue;

			errfmt = g->warning;
			line_number = -1;
			dont_allow_symbol_name = 1;
		} else
			continue;

		if (line_number == -1)
			fprintf(outfile, "%s: ", get_file_name(entry));
		else
			fprintf(outfile, "%s:%d: ", file_name, line_number);

		if (dont_allow_symbol_name)
			fprintf(outfile, "%s", errfmt);
		else
			fprintf(outfile, errfmt, g->name);

		fputc('\n', outfile);
	}
	free(text_scan);
	free(data_scan);
	entry->strings = 0;	/* Since it will disappear anyway. */
}

int
do_warnings(FILE *outfile)
{

	list_unresolved_refs = !relocatable_output &&
		( (undefined_global_sym_count - undefined_weak_sym_count) > 0
		   || undefined_shobj_sym_count
		);
	list_multiple_defs = multiple_def_count != 0;

	if (!(list_unresolved_refs ||
	      list_warning_symbols ||
	      list_multiple_defs))
		/* No need to run this routine */
		return 1;

	if (entry_symbol && !entry_symbol->defined)
		fprintf(outfile, "Undefined entry symbol `%s'\n",
			entry_symbol->name);

	each_file(do_file_warnings, (void *)outfile);

	if (list_unresolved_refs &&
	    reported_undefineds !=
	    (undefined_global_sym_count - undefined_weak_sym_count))
		warnx("internal consistency check failure: "
		      "# undefined symbols %d, accounted for %d",
		      (undefined_global_sym_count - undefined_weak_sym_count),
		      reported_undefineds);

	if (list_unresolved_refs || list_multiple_defs)
		return 0;

	return 1;
}

@


1.12
log
@Fix a few warnings, including an uninitialized variable in an error case.
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.11 2005/12/21 01:40:22 millert Exp $*/
@


1.11
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.10 2003/04/16 02:15:10 deraadt Exp $*/
d647 1
@


1.10
log
@string cleanup; ok millert
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.9 2002/09/07 01:25:34 marc Exp $*/
a9 1
#include <sys/errno.h>
@


1.9
log
@
ansification of ld

* normalized the signatures of the functions passed to each_file()
   and each_full_file().  In most cases that meant adding a void *dummy.
   In one case it changed an int to a void*, but the arg was only checked
   for zero/not-zero so the change was not significant.

 * removes unused code and structures.

 * makes sure printf args match their format.

 * got rid of some of the gcc -Wall warnings

OK deraadt@@
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.8 2002/07/19 19:28:12 marc Exp $*/
d68 1
d76 1
d78 3
a80 2
			xmalloc(strlen(supfile) + strlen(entry->filename) + 3);
		(void)sprintf(result, "%s(%s)", supfile, entry->filename);
d84 1
a84 2
		result = (char *)xmalloc(strlen(entry->filename) + 1);
		strcpy(result, entry->filename);
d490 1
d493 1
d495 3
a497 2
				xmalloc(strlen(errfmt) + strlen(nm) + 1);
			sprintf(errmsg, errfmt, nm, data_segment?"data":"text");
@


1.8
log
@convert functions from K&R style to prototype style.
Function arg types have not yet been fixed.  OK fgs@@, espie@@
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.7 2002/07/17 20:33:29 marc Exp $*/
d89 2
a90 2
static void	describe_file_sections(struct file_entry *, FILE *);
static void	list_file_locals(struct file_entry *, FILE *);
d110 1
a110 1
			fprintf(outfile, "type %d, value %#x, size %#x",
d121 1
a121 1
describe_file_sections(struct file_entry *entry, FILE *outfile)
d123 2
d137 1
a137 1
list_file_locals(struct file_entry *entry, FILE *outfile)
d139 1
d157 1
a157 1
			fprintf(outfile, "  %s: 0x%x\n",
d194 1
a194 1
reloc_cmp(struct relocation_info *rel1, struct relocation_info *rel2)
d196 2
d520 2
a521 2
void
do_file_warnings(struct file_entry *entry, FILE *outfile)
d530 1
@


1.7
log
@un-__P the code.   fgs says "looks ok."
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.6 2002/07/15 21:05:56 marc Exp $*/
d36 1
a36 3
prline_file_name (entry, outfile)
     struct file_entry *entry;
     FILE *outfile;
d47 1
a47 3
print_file_name (entry, outfile)
     struct file_entry *entry;
     FILE *outfile;
d65 1
a65 2
get_file_name (entry)
     struct file_entry *entry;
d93 1
a93 2
print_symbols(outfile)
	FILE	       *outfile;
d121 1
a121 3
describe_file_sections(entry, outfile)
	struct file_entry *entry;
	FILE	       *outfile;
d135 1
a135 3
list_file_locals (entry, outfile)
     struct file_entry *entry;
     FILE *outfile;
d191 1
a191 2
reloc_cmp(rel1, rel2)
	struct relocation_info *rel1, *rel2;
d206 1
a206 4
next_debug_entry(use_data_symbols, state_pointer)
	int use_data_symbols;
	/* Next must be passed by reference! */
	struct line_debug_entry state_pointer[3];
d268 1
a268 3
init_debug_scan(use_data_symbols, entry)
	int			use_data_symbols;
	struct file_entry	*entry;
d327 1
a327 4
address_to_line(address, state_pointer)
	unsigned long	address;
/* Next must be passed by reference! */
	struct line_debug_entry state_pointer[3];
d380 2
a381 5
do_relocation_warnings(entry, data_segment, outfile, nlist_bitvector)
	struct file_entry *entry;
	int		data_segment;
	FILE	       *outfile;
	unsigned char  *nlist_bitvector;
d516 1
a516 3
do_file_warnings (entry, outfile)
	struct file_entry	*entry;
	FILE			*outfile;
d707 1
a707 2
do_warnings(outfile)
	FILE	*outfile;
@


1.6
log
@
space to tab cleanup.   Nothing but whitespace changes in this commit.
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.5 2002/07/10 17:28:16 marc Exp $*/
d94 2
a95 2
static void	describe_file_sections __P((struct file_entry *, FILE *));
static void	list_file_locals __P((struct file_entry *, FILE *));
d176 2
a177 2
static struct line_debug_entry *init_debug_scan __P((int, struct file_entry *));
static int	next_debug_entry __P((int, struct line_debug_entry *));
@


1.5
log
@
First of some clean-up commits.  This one only removes use of
register variables.   clean-up concept ok deraadt@@
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.4 2000/01/23 14:57:29 espie Exp $*/
d99 1
a99 1
	FILE           *outfile;
d129 1
a129 1
	FILE           *outfile;
d344 1
a344 1
	unsigned long   address;
d401 2
a402 2
	int             data_segment;
	FILE           *outfile;
d504 1
a504 1
			char           *nm;
d577 1
a577 1
	        g = entry->symbols[i].symbol;
@


1.4
log
@Fix `internal consistency errors': all warnings for undefined symbols MUST
handle reported_undefineds correctly.

Probably unseen before now because this warning only occurred for symbols
that also triggered other warnings ? or maybe no-one cares.
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.3 1998/03/26 19:46:29 niklas Exp $*/
d158 1
a158 1
		register struct nlist *p = &lsp->nzlist.nlist;
d218 1
a218 1
	register int use_data_symbols;
d222 1
a222 2
	register struct line_debug_entry
				*current = state_pointer,
d286 1
a286 1
	register struct localsymbol	*lsp, *lspend;
d434 2
a435 2
		register struct localsymbol *lsp;
		register symbol *g;
d592 1
a592 1
			register int		type;
@


1.3
log
@RCS id cleanup
@
text
@d1 1
a1 1
/* * $OpenBSD: warnings.c,v 1.2 1997/07/08 09:34:58 deraadt Exp $*/
d682 15
a696 6
			fprintf(outfile,
			"%s: Undefined symbol `%s' referenced (use %s ?)\n",
				get_file_name(entry),
				g->name,
				g->def_lsp->entry->local_sym_name);
			continue;
@


1.2
log
@warning msg change; pk
@
text
@d1 1
a2 1
 * $Id: warnings.c,v 1.1.1.1 1995/10/18 08:40:56 deraadt Exp $
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id: warnings.c,v 1.18 1994/12/28 10:37:38 pk Exp $
d748 2
a749 2
		warnx("Spurious undefined symbols: "
		      "# undefined symbols %d, reported %d",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
