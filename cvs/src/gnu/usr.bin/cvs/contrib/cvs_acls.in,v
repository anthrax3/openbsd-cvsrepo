head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.68
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.66
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.62
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.58
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.60
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.52
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.56
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.54
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.50
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.48
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.46
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.44
	OPENBSD_5_0:1.1.1.1.0.42
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.40
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.38
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.34
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.36
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.32
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.30
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.28
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.26
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.24
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.22
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.20
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.18
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.16
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.14
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.12
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.10
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	cvs-1-11-1p1:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2001.09.28.22.45.36;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.09.28.22.45.36;	author tholo;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@#! @@PERL@@
# -*-Perl-*-
#
# Access control lists for CVS.  dgg@@ksr.com (David G. Grubbs)
#
# CVS "commitinfo" for matching repository names, running the program it finds
# on the same line.  More information is available in the CVS man pages.
#
# ==== INSTALLATION:
#
# To use this program as I intended, do the following four things:
#
# 0. Install PERL.  :-)
#
# 1. Put one line, as the *only* non-comment line, in your commitinfo file:
#
#	DEFAULT		/usr/local/bin/cvs_acls
#
# 2. Install this file as /usr/local/bin/cvs_acls and make it executable.
#
# 3. Create a file named $CVSROOT/CVSROOT/avail.
#
# ==== FORMAT OF THE avail FILE:
#
# The avail file determines whether you may commit files.  It contains lines
# read from top to bottom, keeping track of a single "bit".  The "bit"
# defaults to "on".  It can be turned "off" by "unavail" lines and "on" by
# "avail" lines.  ==> Last one counts.
#
# Any line not beginning with "avail" or "unavail" is ignored.
#
# Lines beginning with "avail" or "unavail" are assumed to be '|'-separated
# triples: (All spaces and tabs are ignored in a line.)
#
#   {avail.*,unavail.*} [| user,user,... [| repos,repos,...]]
#
#    1. String starting with "avail" or "unavail".
#    2. Optional, comma-separated list of usernames.
#    3. Optional, comma-separated list of repository pathnames.
#	These are pathnames relative to $CVSROOT.  They can be directories or
#	filenames.  A directory name allows access to all files and
#	directories below it.
#
# Example:  (Text from the ';;' rightward may not appear in the file.)
#
#	unavail			;; Make whole repository unavailable.
#	avail|dgg		;; Except for user "dgg".
#	avail|fred, john|bin/ls	;; Except when "fred" or "john" commit to
#				;; the module whose repository is "bin/ls"
#
# PROGRAM LOGIC:
#
#	CVS passes to @@ARGV an absolute directory pathname (the repository
#	appended to your $CVSROOT variable), followed by a list of filenames
#	within that directory.
#
#	We walk through the avail file looking for a line that matches both
#	the username and repository.
#
#	A username match is simply the user's name appearing in the second
#	column of the avail line in a space-or-comma separate list.
#
#	A repository match is either:
#		- One element of the third column matches $ARGV[0], or some
#		  parent directory of $ARGV[0].
#		- Otherwise *all* file arguments ($ARGV[1..$#ARGV]) must be
#		  in the file list in one avail line.
#	    - In other words, using directory names in the third column of
#	      the avail file allows committing of any file (or group of
#	      files in a single commit) in the tree below that directory.
#	    - If individual file names are used in the third column of
#	      the avail file, then files must be committed individually or
#	      all files specified in a single commit must all appear in
#	      third column of a single avail line.
#

$debug = 0;
$cvsroot = $ENV{'CVSROOT'};
$availfile = $cvsroot . "/CVSROOT/avail";
$myname = $ENV{"USER"} if !($myname = $ENV{"LOGNAME"});

eval "print STDERR \$die='Unknown parameter $1\n' if !defined \$$1; \$$1=\$';"
    while ($ARGV[0] =~ /^(\w+)=/ && shift(@@ARGV));
exit 255 if $die;		# process any variable=value switches

die "Must set CVSROOT\n" if !$cvsroot;
($repos = shift) =~ s:^$cvsroot/::;
grep($_ = $repos . '/' . $_, @@ARGV);

print "$$ Repos: $repos\n","$$ ==== ",join("\n$$ ==== ",@@ARGV),"\n" if $debug;

$exit_val = 0;				# Good Exit value

$universal_off = 0;
open (AVAIL, $availfile) || exit(0);	# It is ok for avail file not to exist
while (<AVAIL>) {
    chop;
    next if /^\s*\#/;
    next if /^\s*$/;
    ($flagstr, $u, $m) = split(/[\s,]*\|[\s,]*/, $_);

    # Skip anything not starting with "avail" or "unavail" and complain.
    (print "Bad avail line: $_\n"), next
	if ($flagstr !~ /^avail/ && $flagstr !~ /^unavail/);

    # Set which bit we are playing with. ('0' is OK == Available).
    $flag = (($& eq "avail") ? 0 : 1);

    # If we find a "universal off" flag (i.e. a simple "unavail") remember it
    $universal_off = 1 if ($flag && !$u && !$m);

    # $myname considered "in user list" if actually in list or is NULL
    $in_user = (!$u || grep ($_ eq $myname, split(/[\s,]+/,$u)));
    print "$$ \$myname($myname) in user list: $_\n" if $debug && $in_user;

    # Module matches if it is a NULL module list in the avail line.  If module
    # list is not null, we check every argument combination.
    if (!($in_repo = !$m)) {
	@@tmp = split(/[\s,]+/,$m);
	for $j (@@tmp) {
	    # If the repos from avail is a parent(or equal) dir of $repos, OK
	    $in_repo = 1, last if ($repos eq $j || $repos =~ /^$j\//);
	}
	if (!$in_repo) {
	    $in_repo = 1;
	    for $j (@@ARGV) {
		last if !($in_repo = grep ($_ eq $j, @@tmp));
	    }
	}
    }
    print "$$ \$repos($repos) in repository list: $_\n" if $debug && $in_repo;

    $exit_val = $flag if ($in_user && $in_repo);
    print "$$ ==== \$exit_val = $exit_val\n$$ ==== \$flag = $flag\n" if $debug;
}
close(AVAIL);
print "$$ ==== \$exit_val = $exit_val\n" if $debug;
print "**** Access denied: Insufficient Karma ($myname|$repos)\n" if $exit_val;
print "**** Access allowed: Personal Karma exceeds Environmental Karma.\n"
	if $universal_off && !$exit_val;
exit($exit_val);
@


1.1.1.1
log
@Latest from Cyclic Software
@
text
@@
