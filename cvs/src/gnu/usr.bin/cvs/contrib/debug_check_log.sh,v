head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.64
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.62
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.58
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.60
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.52
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.56
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.54
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.50
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.48
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.46
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.44
	OPENBSD_5_0:1.1.1.1.0.42
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.40
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.38
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.34
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.36
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.32
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.30
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.28
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.26
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.24
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.22
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.20
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.18
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.16
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.14
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.12
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.10
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	cvs-1-11-1p1:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2001.09.28.22.45.36;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.09.28.22.45.36;	author tholo;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@#!/bin/sh

#
# This program is intended to take a check.log file generated by a failed run of
# sanity.sh as input and run expr line by line on it.  It seems a much easier
# way of spotting a single failed line in a 100 line test result.
#

#
# This script falls under the GNU General Public License and is intended to
# be distributed with CVS.
#

#
# No warranties, express or implied.
#

#
# Contributed by Derek R. Price <derek.price@@openavenue.com>
#



usage ()
{
	echo "\
usage: $0 [-afh] [file...]

       -a          process alternate pattern
       -f          process first pattern (default)
       -h          print this text

     file          files to process (default = check.log)"
}

# Do a line by line match with expr
#
# INPUTS
#    $1 = text file name
#    $2 = pattern file name
expr_line_by_line ()
{
	dcl_line=0
	dcl_wrong=
	# We are assuming a newline at the end of the file.  The way sanity.sh
	# uses echo to create the log message guarantees this newline and since
	# expr ignores the last newline when the anchor is present anyhow, no
	# information is being lost in the transition
	while test $dcl_line -lt `wc -l <$1` -a $dcl_line -lt `wc -l <$2`; do
		dcl_line=`expr $dcl_line + 1`
		if test `sed -ne${dcl_line}p <$1 |wc -c` -eq 1 \
				-a `sed -ne${dcl_line}p <$2 |wc -c` -eq 1; then
			# This is a workaround for what I am calling a bug in GNU
			# expr - it won't match the empty string to the empty
			# string.  In this case the assumption is that a single
			# character is always a newline.  Since we already checked
			# for the end of the file, we know sed will echo the
			# newline.
			: 
		elif expr "`sed -ne${dcl_line}p <$1`" : \
				"`sed -ne${dcl_line}p <$2`\$" >/dev/null; then
			:
		else
			echo "$dcl_line: `sed -ne${dcl_line}p <$1`"
			echo "$dcl_line: `sed -ne${dcl_line}p <$2`\$"
			dcl_wrong="$dcl_wrong $dcl_line"
		fi
	done
	if test `wc -l <$1` -ne `wc -l <$2`; then
		echo "output & pattern contain differing number of lines"
	elif test -z "$dcl_wrong"; then
		echo "no mismatched lines"
	else
		echo "mismatched lines: $dcl_wrong"
	fi
}

# Process a single check.log file
#
# INPUTS
#    $1 = filename
process_check_log ()
{
	# abort if we can't find any expressions
	if grep '^\*\* got: $' <$1 >/dev/null; then
		:
	else
		echo "WARNING:  No expressions in file: $1" >&2
		echo "          Either not a check.log or sanity.sh exited for some other reason," >&2
		echo "          like bad exit status.  Try tail." >&2
		return
	fi

	dcl_exprfiles=""
	if grep '^\*\* or: $' <$1 >/dev/null; then
		# file contains a second regex
		if test $dcl_dofirst -eq 1; then
			# get the first pattern
			sed -ne '/^\*\* expected: $/,/^\*\* or: $/p' <$1 >/tmp/dcle$$
			dcl_exprfiles="$dcl_exprfiles /tmp/dcle$$"
		fi
		if test $dcl_doalternate -eq 1; then
			# get the alternate pattern
			sed -ne '/^\*\* or: $/,/^\*\* got: $/p' <$1 >/tmp/dclo$$
			dcl_exprfiles="$dcl_exprfiles /tmp/dclo$$"
		else
			echo "WARNING:  Ignoring alternate pattern in file: $1" >&2
		fi
	else
		# file doesn't contain a second regex
		if test $dcl_dofirst = 1; then
			# get the only pattern
			sed -ne '/^\*\* expected: $/,/^\*\* got: $/p' <$1 >/tmp/dcle$$
			dcl_exprfiles="$dcl_exprfiles /tmp/dcle$$"
		fi
		if test $dcl_doalternate -eq 1; then
			echo "WARNING:  No alternate pattern in file:  $1" >&2
		fi
	fi

	# and get the actual output
	sed -ne '/^\*\* got: $/,$p' <$1 >/tmp/dclg$$
	sed -ne '1D
$D
p' </tmp/dclg$$ >/tmp/dclh$$
	mv /tmp/dclh$$ /tmp/dclg$$

	# compare the output against each pattern requested
	for dcl_f in $dcl_exprfiles; do
		sed -ne '1D
$D
p' <$dcl_f >/tmp/dclp$$
		mv /tmp/dclp$$ $dcl_f

		case $dcl_f in
			/tmp/dcle*)
				echo "********** $1 : Primary **********"
				;;
			/tmp/dclo*)
				echo "********** $1 : Alternate **********"
				;;
		esac

		expr_line_by_line /tmp/dclg$$ $dcl_f

		rm $dcl_f
	done

	rm /tmp/dclg$$
}

###
### MAIN
###

# set up defaults
dcl_doalternate=0
dcl_dofirst=0

# process options
while getopts afh arg; do
	case $arg in
		a)
			dcl_doalternate=1
			;;
		f)
			dcl_dofirst=1
			;;
		\?|h)
			usage
			exit 1
			;;
	esac
done

# dispose of processed args
shift `expr $OPTIND - 1`
OPTIND=1

# set the default mode
if test $dcl_doalternate -eq 0; then
	dcl_dofirst=1
fi

# set default arg
if test $# -eq 0; then
	dcl_argvar=dcl_default
	dcl_default=check.log
else
	dcl_argvar=@@
fi

eval for file in \"\$$dcl_argvar\"\; do \
	process_check_log \$file\; \
done

exit 0
@


1.1.1.1
log
@Latest from Cyclic Software
@
text
@@
