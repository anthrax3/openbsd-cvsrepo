head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.64
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.66
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.62
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.58
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.60
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.52
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.56
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.54
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.50
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.48
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.46
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.44
	OPENBSD_5_0:1.2.0.42
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.40
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.38
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.34
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.36
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.32
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.30
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.28
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.26
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.24
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.22
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.20
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.18
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.16
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.14
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.12
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.10
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.8
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.6
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	cvs-1-11-1p1:1.1.1.5
	OPENBSD_2_9:1.1.1.5.0.10
	OPENBSD_2_9_BASE:1.1.1.5
	cvs-1-11:1.1.1.5
	OPENBSD_2_8:1.1.1.5.0.8
	OPENBSD_2_8_BASE:1.1.1.5
	OPENBSD_2_7:1.1.1.5.0.6
	OPENBSD_2_7_BASE:1.1.1.5
	OPENBSD_2_6:1.1.1.5.0.4
	OPENBSD_2_6_BASE:1.1.1.5
	cvs-1-10-7:1.1.1.5
	OPENBSD_2_5:1.1.1.5.0.2
	OPENBSD_2_5_BASE:1.1.1.5
	cvs-1-10-5:1.1.1.5
	OPENBSD_2_4:1.1.1.4.0.8
	OPENBSD_2_4_BASE:1.1.1.4
	cvs-1-10:1.1.1.4
	cvs-1-9-28:1.1.1.4
	OPENBSD_2_3:1.1.1.4.0.6
	OPENBSD_2_3_BASE:1.1.1.4
	cvs-1-9-26:1.1.1.4
	cvs-1-9-24:1.1.1.4
	OPENBSD_2_2:1.1.1.4.0.4
	OPENBSD_2_2_BASE:1.1.1.4
	cvs-1-9-10:1.1.1.4
	OPENBSD_2_1:1.1.1.4.0.2
	OPENBSD_2_1_BASE:1.1.1.4
	cvs-1-9-8:1.1.1.4
	cvs-1-9-6:1.1.1.4
	cvs-1-9-4:1.1.1.4
	cvs-1-9-2:1.1.1.3
	cvs-1-9:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	cvs-1-8-1:1.1.1.1
	cvs-1-8:1.1.1.1
	cvs-1-7-2:1.1.1.1
	cvs-1-7-1:1.1.1.1
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2001.08.07.22.00.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.40;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.10.18.03.36.19;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.02.21.06.38.19;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.03.18.01.56.56;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.02.28.21.34.25;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Use mktemp(1) to avoid /tmp race found by terra@@diku.dk.
Fix based on patch from mbing@@nfr.net.
@
text
@#! /bin/sh

# RCS to ChangeLog generator

# Generate a change log prefix from RCS files (perhaps in the CVS repository)
# and the ChangeLog (if any).
# Output the new prefix to standard output.
# You can edit this prefix by hand, and then prepend it to ChangeLog.

# Ignore log entries that start with `#'.
# Clump together log entries that start with `{topic} ',
# where `topic' contains neither white space nor `}'.

Help='The default FILEs are the files registered under the working directory.
Options:

  -c CHANGELOG  Output a change log prefix to CHANGELOG (default ChangeLog).
  -h HOSTNAME  Use HOSTNAME in change log entries (default current host).
  -i INDENT  Indent change log lines by INDENT spaces (default 8).
  -l LENGTH  Try to limit log lines to LENGTH characters (default 79).
  -R  If no FILEs are given and RCS is used, recurse through working directory.
  -r OPTION  Pass OPTION to subsidiary log command.
  -t TABWIDTH  Tab stops are every TABWIDTH characters (default 8).
  -u "LOGIN<tab>FULLNAME<tab>MAILADDR"  Assume LOGIN has FULLNAME and MAILADDR.
  -v  Append RCS revision to file names in log lines.
  --help  Output help.
  --version  Output version number.

Report bugs to <bug-gnu-emacs@@gnu.org>.'

Id='$Id: rcs2log.sh,v 1.1.1.5 1999/02/28 21:34:25 tholo Exp $'

# Copyright 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

Copyright='Copyright 1998 Free Software Foundation, Inc.
This program comes with NO WARRANTY, to the extent permitted by law.
You may redistribute copies of this program
under the terms of the GNU General Public License.
For more information about these matters, see the files named COPYING.
Author: Paul Eggert <eggert@@twinsun.com>'

tab='	'
nl='
'

# Parse options.

# defaults
: ${AWK=awk}
: ${TMPDIR=/tmp}
changelog=ChangeLog # change log file name
datearg= # rlog date option
hostname= # name of local host (if empty, will deduce it later)
indent=8 # indent of log line
length=79 # suggested max width of log line
logins= # login names for people we know fullnames and mailaddrs of
loginFullnameMailaddrs= # login<tab>fullname<tab>mailaddr triplets
logTZ= # time zone for log dates (if empty, use local time)
recursive= # t if we want recursive rlog
revision= # t if we want revision numbers
rlog_options= # options to pass to rlog
tabwidth=8 # width of horizontal tab

while :
do
	case $1 in
	-c)	changelog=${2?}; shift;;
	-i)	indent=${2?}; shift;;
	-h)	hostname=${2?}; shift;;
	-l)	length=${2?}; shift;;
	-[nu])	# -n is obsolescent; it is replaced by -u.
		case $1 in
		-n)	case ${2?}${3?}${4?} in
			*"$tab"* | *"$nl"*)
				echo >&2 "$0: -n '$2' '$3' '$4': tabs, newlines not allowed"
				exit 1
			esac
			case $loginFullnameMailaddrs in
			'') loginFullnameMailaddrs=$2$tab$3$tab$4;;
			?*) loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$2$tab$3$tab$4
			esac
			shift; shift; shift;;
		-u)
			# If $2 is not tab-separated, use colon for separator.
			case ${2?} in
			*"$nl"*)
				echo >&2 "$0: -u '$2': newlines not allowed"
				exit 1;;
			*"$tab"*)
				t=$tab;;
			*)
				t=:
			esac
			case $2 in
			*"$t"*"$t"*"$t"*)
				echo >&2 "$0: -u '$2': too many fields"
				exit 1;;
			*"$t"*"$t"*)
				;;
			*)
				echo >&2 "$0: -u '$2': not enough fields"
				exit 1
			esac
			case $loginFullnameMailaddrs in
			'') loginFullnameMailaddrs=$2;;
			?*) loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$2
			esac
			shift
		esac
		case $logins in
		'') logins=$login;;
		?*) logins=$logins$nl$login
		esac
		;;
	-r)
		case $rlog_options in
		'') rlog_options=${2?};;
		?*) rlog_options=$rlog_options$nl${2?}
		esac
		shift;;
	-R)	recursive=t;;
	-t)	tabwidth=${2?}; shift;;
	-v)	revision=t;;
	--version)
		set $Id
		rcs2logVersion=$3
		echo >&2 "rcs2log (GNU Emacs) $rcs2logVersion$nl$Copyright"
		exit 0;;
	-*)	echo >&2 "Usage: $0 [OPTION]... [FILE ...]$nl$Help"
		case $1 in
		--help) exit 0;;
		*) exit 1
		esac;;
	*)	break
	esac
	shift
done

month_data='
	m[0]="Jan"; m[1]="Feb"; m[2]="Mar"
	m[3]="Apr"; m[4]="May"; m[5]="Jun"
	m[6]="Jul"; m[7]="Aug"; m[8]="Sep"
	m[9]="Oct"; m[10]="Nov"; m[11]="Dec"
'


# Put rlog output into $rlogout.

# If no rlog options are given,
# log the revisions checked in since the first ChangeLog entry.
# Since ChangeLog is only by date, some of these revisions may be duplicates of
# what's already in ChangeLog; it's the user's responsibility to remove them.
case $rlog_options in
'')
	if test -s "$changelog"
	then
		e='
			/^[0-9]+-[0-9][0-9]-[0-9][0-9]/{
				# ISO 8601 date
				print $1
				exit
			}
			/^... ... [ 0-9][0-9] [ 0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9]+ /{
				# old-fashioned date and time (Emacs 19.31 and earlier)
				'"$month_data"'
				year = $5
				for (i=0; i<=11; i++) if (m[i] == $2) break
				dd = $3
				printf "%d-%02d-%02d\n", year, i+1, dd
				exit
			}
		'
		d=`$AWK "$e" <"$changelog"` || exit
		case $d in
		?*) datearg="-d>$d"
		esac
	fi
esac

# Use TZ specified by ChangeLog local variable, if any.
if test -s "$changelog"
then
	extractTZ='
		/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*"\([^"]*\)".*/{
			s//\1/; p; q
		}
		/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*t.*/{
			s//UTC0/; p; q
		}
	'
	logTZ=`tail "$changelog" | sed -n "$extractTZ"`
	case $logTZ in
	?*) TZ=$logTZ; export TZ
	esac
fi

# If CVS is in use, examine its repository, not the normal RCS files.
if test ! -f CVS/Repository
then
	rlog=rlog
	repository=
else
	rlog='cvs -q log'
	repository=`sed 1q <CVS/Repository` || exit
	test ! -f CVS/Root || CVSROOT=`cat <CVS/Root` || exit
	case $CVSROOT in
	*:/*)
		# remote repository
		;;
	*)
		# local repository
		case $repository in
		/*) ;;
		*) repository=${CVSROOT?}/$repository
		esac
		if test ! -d "$repository"
		then
			echo >&2 "$0: $repository: bad repository (see CVS/Repository)"
			exit 1
		fi
	esac
fi

# Use $rlog's -zLT option, if $rlog supports it.
case `$rlog -zLT 2>&1` in
*' option'*) ;;
*)
	case $rlog_options in
	'') rlog_options=-zLT;;
	?*) rlog_options=-zLT$nl$rlog_options
	esac
esac

# With no arguments, examine all files under the RCS directory.
case $# in
0)
	case $repository in
	'')
		oldIFS=$IFS
		IFS=$nl
		case $recursive in
		t)
			RCSdirs=`find . -name RCS -type d -print`
			filesFromRCSfiles='s|,v$||; s|/RCS/|/|; s|^\./||'
			files=`
				{
					case $RCSdirs in
					?*) find $RCSdirs \
							-type f \
							! -name '*_' \
							! -name ',*,' \
							! -name '.*_' \
							! -name .rcsfreeze.log \
							! -name .rcsfreeze.ver \
							-print
					esac
					find . -name '*,v' -print
				} |
				sort -u |
				sed "$filesFromRCSfiles"
			`;;
		*)
			files=
			for file in RCS/.* RCS/* .*,v *,v
			do
				case $file in
				RCS/. | RCS/.. | RCS/,*, | RCS/*_) continue;;
				RCS/.rcsfreeze.log | RCS/.rcsfreeze.ver) continue;;
				RCS/.\* | RCS/\* | .\*,v | \*,v) test -f "$file" || continue;;
				RCS/*,v | RCS/.*,v) ;;
				RCS/* | RCS/.*) test -f "$file" || continue
				esac
				case $files in
				'') files=$file;;
				?*) files=$files$nl$file
				esac
			done
			case $files in
			'') exit 0
			esac
		esac
		set x $files
		shift
		IFS=$oldIFS
	esac
esac

llogout=`mktemp $TMPDIR/rcs2log_l.XXXXXXXXXX` || exit 1
rlogout=`mktemp $TMPDIR/rcs2log_r.XXXXXXXXXX` || {
	rm -f $llogout
	exit 1
}
trap exit 1 2 13 15
trap "rm -f $llogout $rlogout; exit 1" 0

case $datearg in
?*) $rlog $rlog_options "$datearg" ${1+"$@@"} >$rlogout;;
'') $rlog $rlog_options ${1+"$@@"} >$rlogout
esac || exit


# Get the full name of each author the logs mention, and set initialize_fullname
# to awk code that initializes the `fullname' awk associative array.
# Warning: foreign authors (i.e. not known in the passwd file) are mishandled;
# you have to fix the resulting output by hand.

initialize_fullname=
initialize_mailaddr=

case $loginFullnameMailaddrs in
?*)
	case $loginFullnameMailaddrs in
	*\"* | *\\*)
		sed 's/["\\]/\\&/g' >$llogout <<EOF || exit
$loginFullnameMailaddrs
EOF
		loginFullnameMailaddrs=`cat $llogout`
	esac

	oldIFS=$IFS
	IFS=$nl
	for loginFullnameMailaddr in $loginFullnameMailaddrs
	do
		case $loginFullnameMailaddr in
		*"$tab"*) IFS=$tab;;
		*) IFS=:
		esac
		set x $loginFullnameMailaddr
		login=$2
		fullname=$3
		mailaddr=$4
		initialize_fullname="$initialize_fullname
			fullname[\"$login\"] = \"$fullname\""
		initialize_mailaddr="$initialize_mailaddr
			mailaddr[\"$login\"] = \"$mailaddr\""
	done
	IFS=$oldIFS
esac

case $llogout in
?*) sort -u -o $llogout <<EOF || exit
$logins
EOF
esac
output_authors='/^date: / {
	if ($2 ~ /^[0-9]*[-\/][0-9][0-9][-\/][0-9][0-9]$/ && $3 ~ /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9][-+0-9:]*;$/ && $4 == "author:" && $5 ~ /^[^;]*;$/) {
		print substr($5, 1, length($5)-1)
	}
}'
authors=`
	$AWK "$output_authors" <$rlogout |
	case $llogout in
	'') sort -u;;
	?*) sort -u | comm -23 - $llogout
	esac
`
case $authors in
?*)
	cat >$llogout <<EOF || exit
$authors
EOF
	initialize_author_script='s/["\\]/\\&/g; s/.*/author[\"&\"] = 1/'
	initialize_author=`sed -e "$initialize_author_script" <$llogout`
	awkscript='
		BEGIN {
			alphabet = "abcdefghijklmnopqrstuvwxyz"
			ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
			'"$initialize_author"'
		}
		{
			if (author[$1]) {
				fullname = $5
				if (fullname ~ /[0-9]+-[^(]*\([0-9]+\)$/) {
					# Remove the junk from fullnames like "0000-Admin(0000)".
					fullname = substr(fullname, index(fullname, "-") + 1)
					fullname = substr(fullname, 1, index(fullname, "(") - 1)
				}
				if (fullname ~ /,[^ ]/) {
					# Some sites put comma-separated junk after the fullname.
					# Remove it, but leave "Bill Gates, Jr" alone.
					fullname = substr(fullname, 1, index(fullname, ",") - 1)
				}
				abbr = index(fullname, "&")
				if (abbr) {
					a = substr($1, 1, 1)
					A = a
					i = index(alphabet, a)
					if (i) A = substr(ALPHABET, i, 1)
					fullname = substr(fullname, 1, abbr-1) A substr($1, 2) substr(fullname, abbr+1)
				}

				# Quote quotes and backslashes properly in full names.
				# Do not use gsub; traditional awk lacks it.
				quoted = ""
				rest = fullname
				for (;;) {
					p = index(rest, "\\")
					q = index(rest, "\"")
					if (p) {
						if (q && q<p) p = q
					} else {
						if (!q) break
						p = q
					}
					quoted = quoted substr(rest, 1, p-1) "\\" substr(rest, p, 1)
					rest = substr(rest, p+1)
				}

				printf "fullname[\"%s\"] = \"%s%s\"\n", $1, quoted, rest
				author[$1] = 0
			}
		}
	'

	initialize_fullname=`
		{
			(getent passwd $authors) ||
			(
				cat /etc/passwd
				for author in $authors
				do NIS_PATH= nismatch $author passwd.org_dir
				done
				ypmatch $authors passwd
			)
		} 2>/dev/null |
		$AWK -F: "$awkscript"
	`$initialize_fullname
esac


# Function to print a single log line.
# We don't use awk functions, to stay compatible with old awk versions.
# `Log' is the log message (with \n replaced by \001).
# `files' contains the affected files.
printlogline='{

	# Following the GNU coding standards, rewrite
	#	* file: (function): comment
	# to
	#	* file (function): comment
	if (Log ~ /^\([^)]*\): /) {
		i = index(Log, ")")
		files = files " " substr(Log, 1, i)
		Log = substr(Log, i+3)
	}

	# If "label: comment" is too long, break the line after the ":".
	sep = " "
	if ('"$length"' <= '"$indent"' + 1 + length(files) + index(Log, SOH)) sep = "\n" indent_string

	# Print the label.
	printf "%s*%s:", indent_string, files

	# Print each line of the log, transliterating \001 to \n.
	while ((i = index(Log, SOH)) != 0) {
		logline = substr(Log, 1, i-1)
		if (logline ~ /[^'"$tab"' ]/) {
			printf "%s%s\n", sep, logline
		} else {
			print ""
		}
		sep = indent_string
		Log = substr(Log, i+1)
	}
}'

# Pattern to match the `revision' line of rlog output.
rlog_revision_pattern='^revision [0-9]+\.[0-9]+(\.[0-9]+\.[0-9]+)*(['"$tab"' ]+locked by: [^'"$tab"' $,.0-9:;@@]*[^'"$tab"' $,:;@@][^'"$tab"' $,.0-9:;@@]*;)?['"$tab"' ]*$'

case $hostname in
'')
	hostname=`(
		hostname || uname -n || uuname -l || cat /etc/whoami
	) 2>/dev/null` || {
		echo >&2 "$0: cannot deduce hostname"
		exit 1
	}

	case $hostname in
	*.*) ;;
	*)
		domainname=`(domainname) 2>/dev/null` &&
		case $domainname in
		*.*) hostname=$hostname.$domainname
		esac
	esac
esac


# Process the rlog output, generating ChangeLog style entries.

# First, reformat the rlog output so that each line contains one log entry.
# Transliterate \n to \001 so that multiline entries fit on a single line.
# Discard irrelevant rlog output.
$AWK <$rlogout '
	BEGIN { repository = "'"$repository"'" }
	/^RCS file:/ {
		if (repository != "") {
			filename = $3
			if (substr(filename, 1, length(repository) + 1) == repository "/") {
				filename = substr(filename, length(repository) + 2)
			}
			if (filename ~ /,v$/) {
				filename = substr(filename, 1, length(filename) - 2)
			}
			if (filename ~ /(^|\/)Attic\/[^\/]*$/) {
				i = length(filename)
				while (substr(filename, i, 1) != "/") i--
				filename = substr(filename, 1, i - 6) substr(filename, i + 1)
			}
		}
		rev = "?"
	}
	/^Working file:/ { if (repository == "") filename = $3 }
	/'"$rlog_revision_pattern"'/, /^(-----------*|===========*)$/ {
		line = $0
		if (line ~ /'"$rlog_revision_pattern"'/) {
			rev = $2
			next
		}
		if (line ~ /^date: [0-9][- +\/0-9:]*;/) {
			date = $2
			if (date ~ /\//) {
				# This is a traditional RCS format date YYYY/MM/DD.
				# Replace "/"s with "-"s to get ISO format.
				newdate = ""
				while ((i = index(date, "/")) != 0) {
					newdate = newdate substr(date, 1, i-1) "-"
					date = substr(date, i+1)
				}
				date = newdate date
			}
			time = substr($3, 1, length($3) - 1)
			author = substr($5, 1, length($5)-1)
			printf "%s %s %s %s %s %c", filename, rev, date, time, author, 1
			rev = "?"
			next
		}
		if (line ~ /^branches: /) { next }
		if (line ~ /^(-----------*|===========*)$/) { print ""; next }
		if (line == "Initial revision" || line ~ /^file .+ was initially added on branch .+\.$/) {
			line = "New file."
		}
		printf "%s%c", line, 1
	}
' |

# Now each line is of the form
# FILENAME REVISION YYYY-MM-DD HH:MM:SS[+-TIMEZONE] AUTHOR \001LOG
#	where \001 stands for a carriage return,
#	and each line of the log is terminated by \001 instead of \n.
# Sort the log entries, first by date+time (in reverse order),
# then by author, then by log entry, and finally by file name and revision
# (just in case).
sort +2 -4r +4 +0 |

# Finally, reformat the sorted log entries.
$AWK '
	BEGIN {
		logTZ = "'"$logTZ"'"
		revision = "'"$revision"'"

		# Some awk variants do not understand "\001", so we have to
		# put the char directly in the file.
		SOH="" # <-- There is a single SOH (octal code 001) here.

		# Initialize the fullname and mailaddr associative arrays.
		'"$initialize_fullname"'
		'"$initialize_mailaddr"'

		# Initialize indent string.
		indent_string = ""
		i = '"$indent"'
		if (0 < '"$tabwidth"')
			for (;  '"$tabwidth"' <= i;  i -= '"$tabwidth"')
				indent_string = indent_string "\t"
		while (1 <= i--)
			indent_string = indent_string " "
	}

	{
		newlog = substr($0, 1 + index($0, SOH))

		# Ignore log entries prefixed by "#".
		if (newlog ~ /^#/) { next }

		if (Log != newlog || date != $3 || author != $5) {

			# The previous log and this log differ.

			# Print the old log.
			if (date != "") '"$printlogline"'

			# Logs that begin with "{clumpname} " should be grouped together,
			# and the clumpname should be removed.
			# Extract the new clumpname from the log header,
			# and use it to decide whether to output a blank line.
			newclumpname = ""
			sep = "\n"
			if (date == "") sep = ""
			if (newlog ~ /^\{[^'"$tab"' }]*}['"$tab"' ]/) {
				i = index(newlog, "}")
				newclumpname = substr(newlog, 1, i)
				while (substr(newlog, i+1) ~ /^['"$tab"' ]/) i++
				newlog = substr(newlog, i+1)
				if (clumpname == newclumpname) sep = ""
			}
			printf sep
			clumpname = newclumpname

			# Get ready for the next log.
			Log = newlog
			if (files != "")
				for (i in filesknown)
					filesknown[i] = 0
			files = ""
		}
		if (date != $3  ||  author != $5) {
			# The previous date+author and this date+author differ.
			# Print the new one.
			date = $3
			time = $4
			author = $5

			zone = ""
			if (logTZ && ((i = index(time, "-")) || (i = index(time, "+"))))
				zone = " " substr(time, i)

			# Print "date[ timezone]  fullname  <email address>".
			# Get fullname and email address from associative arrays;
			# default to author and author@@hostname if not in arrays.
			if (fullname[author])
				auth = fullname[author]
			else
				auth = author
			printf "%s%s  %s  ", date, zone, auth
			if (mailaddr[author])
				printf "<%s>\n\n", mailaddr[author]
			else
				printf "<%s@@%s>\n\n", author, "'"$hostname"'"
		}
		if (! filesknown[$1]) {
			filesknown[$1] = 1
			if (files == "") files = " " $1
			else files = files ", " $1
			if (revision && $2 != "?") files = files " " $2
		}
	}
	END {
		# Print the last log.
		if (date != "") {
			'"$printlogline"'
			printf "\n"
		}
	}
' &&


# Exit successfully.

exec rm -f $llogout $rlogout

# Local Variables:
# tab-width:4
# End:
@


1.1
log
@Initial revision
@
text
@d5 2
a6 1
# Generate a change log prefix from RCS files and the ChangeLog (if any).
d14 16
a29 1
# Author: Paul Eggert <eggert@@twinsun.com>
d31 1
a31 1
# $Id: rcs2log.sh,v 1.2 1995/07/28 19:48:45 eggert Exp $
d33 1
a33 1
# Copyright 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d39 1
a39 1
# 
d44 1
a44 1
# 
d46 10
a55 2
# along with this program; see the file COPYING.  If not, write to
# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
d66 2
d73 1
d75 1
d82 1
d93 4
a96 1
			loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$2$tab$3$tab$4
d119 4
a122 1
			loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$2
d125 4
a128 1
		logins=$logins$nl$login
d130 6
a135 1
	-r)	rlog_options=$rlog_options$nl${2?}; shift;;
d138 11
a148 5
	-*)	echo >&2 "$0: usage: $0 [options] [file ...]
Options:
	[-h hostname] [-i indent] [-l length] [-R] [-r rlog_option]
	[-t tabwidth] [-u 'login<TAB>fullname<TAB>mailaddr']..."
		exit 1;;
a158 6

	# days in non-leap year thus far, indexed by month (0-12)
	mo[0]=0; mo[1]=31; mo[2]=59; mo[3]=90
	mo[4]=120; mo[5]=151; mo[6]=181; mo[7]=212
	mo[8]=243; mo[9]=273; mo[10]=304; mo[11]=334
	mo[12]=365
d166 2
d170 1
a170 2
	date=1970
	if test -s ChangeLog
a171 1
		# Add 1 to seconds to avoid duplicating most recent log.
d173 5
d179 1
d184 1
a184 28
				hh = substr($0,12,2)
				mm = substr($0,15,2)
				ss = substr($0,18,2)
				ss++
				if (ss == 60) {
					ss = 0
					mm++
					if (mm == 60) {
						mm = 0
						hh++
						if (hh == 24) {
							hh = 0
							dd++
							monthdays = mo[i+1] - mo[i]
							if (i == 1 && year%4 == 0 && (year%100 != 0 || year%400 == 0)) monthdays++
							if (dd == monthdays + 1) {
								dd = 1
								i++
								if (i == 12) {
									i = 0
									year++
								}
							}
						}
					}
				}
				# Output comma instead of space to avoid CVS 1.5 bug.
				printf "%d/%02d/%02d,%02d:%02d:%02d\n", year,i+1,dd,hh,mm,ss
d188 1
a188 1
		d=`$AWK "$e" <ChangeLog` || exit
d190 1
a190 1
		?*) date=$d
a192 1
	datearg="-d>$date"
d195 17
d218 1
a218 1
	rlog='cvs log'
d239 10
d263 8
a270 1
					?*) find $RCSdirs -type f -print
d282 9
a290 2
				RCS/. | RCS/..) continue;;
				RCS/.\* | RCS/\* | .\*,v | \*,v) test -f "$file" || continue
a291 1
				files=$files$nl$file
d303 5
a307 2
llogout=$TMPDIR/rcs2log$$l
rlogout=$TMPDIR/rcs2log$$r
d311 3
a313 3
case $rlog_options in
?*) $rlog $rlog_options ${1+"$@@"} >$rlogout;;
'') $rlog "$datearg" ${1+"$@@"} >$rlogout
d431 10
a440 1
		(cat /etc/passwd; ypmatch $authors passwd) 2>/dev/null |
d448 1
a448 1
# `Log' is the log message (with \n replaced by \r).
d464 1
a464 1
	if ('"$length"' <= '"$indent"' + 1 + length(files) + index(Log, CR)) sep = "\n" indent_string
d469 2
a470 2
	# Print each line of the log, transliterating \r to \n.
	while ((i = index(Log, CR)) != 0) {
d482 3
d493 9
d508 1
a508 1
# Transliterate \n to \r so that multiline entries fit on a single line.
d521 5
d527 1
d530 7
a536 3
	/^date: /, /^(-----------*|===========*)$/ {
		if ($0 ~ /^branches: /) { next }
		if ($0 ~ /^date: [0-9][- +\/0-9:]*;/) {
d538 3
a540 2
			if (date ~ /-/) {
				# An ISO format date.  Replace all "-"s with "/"s.
d542 2
a543 2
				while ((i = index(date, "-")) != 0) {
					newdate = newdate substr(date, 1, i-1) "/"
d548 1
a548 2
			# Ignore any time zone; ChangeLog has no room for it.
			time = substr($3, 1, 8)
d550 2
a551 1
			printf "%s %s %s %s %c", filename, date, time, author, 13
d554 6
a559 2
		if ($0 ~ /^(-----------*|===========*)$/) { print ""; next }
		printf "%s%c", $0, 13
d564 3
a566 3
# FILENAME YYYY/MM/DD HH:MM:SS AUTHOR \rLOG
#	where \r stands for a carriage return,
#	and each line of the log is terminated by \r instead of \n.
d568 3
a570 2
# then by author, then by log entry, and finally by file name (just in case).
sort +1 -3r +3 +0 |
d575 6
a580 3
		# Some awk variants do not understand "\r" or "\013", so we have to
		# put a carriage return directly in the file.
		CR="" # <-- There is a single CR between the " chars here.
a593 13

		# Set up date conversion tables.
		# RCS uses a nice, clean, sortable format,
		# but ChangeLog wants the traditional, ugly ctime format.

		# January 1, 0 AD (Gregorian) was Saturday = 6
		EPOCH_WEEKDAY = 6
		# Of course, there was no 0 AD, but the algorithm works anyway.

		w[0]="Sun"; w[1]="Mon"; w[2]="Tue"; w[3]="Wed"
		w[4]="Thu"; w[5]="Fri"; w[6]="Sat"

		'"$month_data"'
d597 1
a597 1
		newlog = substr($0, 1 + index($0, CR))
d602 1
a602 1
		if (Log != newlog || date != $2 || author != $4) {
d633 1
a633 1
		if (date != $2  ||  author != $4) {
d636 7
a642 2
			date = $2
			author = $4
d644 1
a644 14
			# Convert nice RCS date like "1992/01/03 00:03:44"
			# into ugly ctime date like "Fri Jan  3 00:03:44 1992".
			# Calculate day of week from Gregorian calendar.
			i = index($2, "/")
			year = substr($2, 1, i-1) + 0
			monthday = substr($2, i+1)
			i = index(monthday, "/")
			month = substr(monthday, 1, i-1) + 0
			day = substr(monthday, i+1) + 0
			leap = 0
			if (2 < month && year%4 == 0 && (year%100 != 0 || year%400 == 0)) leap = 1
			days_since_Sunday_before_epoch = EPOCH_WEEKDAY + year * 365 + int((year + 3) / 4) - int((year + 99) / 100) + int((year + 399) / 400) + mo[month-1] + leap + day - 1

			# Print "date  fullname  (email address)".
d651 1
a651 1
			printf "%s %s %2d %s %d  %s  ", w[days_since_Sunday_before_epoch%7], m[month-1], day, $3, year, auth
d661 1
d677 4
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@New release from Cyclic Software
@
text
@d15 1
a15 1
# $Id: rcs2log.sh,v 1.4 1996/09/29 20:38:31 woods Exp $
d30 2
a31 3
# along with this program; see the file COPYING.  If not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.
d125 1
a125 1
	date=1970-01-01
d367 1
a367 7
		(
			cat /etc/passwd
			for author in $authors
			do nismatch $author passwd.org_dir
			done
			ypmatch $authors passwd
		) 2>/dev/null |
a416 9

	case $hostname in
	*.*) ;;
	*)
		domainname=`(domainname) 2>/dev/null` &&
		case $domainname in
		*.*) hostname=$hostname.$domainname
		esac
	esac
@


1.1.1.3
log
@New release from Cyclic Software
@
text
@d15 1
a15 1
# $Id: rcs2log.sh,v 1.5 1996/10/16 15:28:42 jimb Exp $
d162 2
a163 1
				printf "%02d/%02d/%d %02d:%02d:%02d\n", i+1,dd,year,hh,mm,ss
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d15 2
@


1.1.1.5
log
@Latest version from Cyclic
@
text
@d5 1
a5 2
# Generate a change log prefix from RCS files (perhaps in the CVS repository)
# and the ChangeLog (if any).
d13 1
a13 16
Help='The default FILEs are the files registered under the working directory.
Options:

  -c CHANGELOG  Output a change log prefix to CHANGELOG (default ChangeLog).
  -h HOSTNAME  Use HOSTNAME in change log entries (default current host).
  -i INDENT  Indent change log lines by INDENT spaces (default 8).
  -l LENGTH  Try to limit log lines to LENGTH characters (default 79).
  -R  If no FILEs are given and RCS is used, recurse through working directory.
  -r OPTION  Pass OPTION to subsidiary log command.
  -t TABWIDTH  Tab stops are every TABWIDTH characters (default 8).
  -u "LOGIN<tab>FULLNAME<tab>MAILADDR"  Assume LOGIN has FULLNAME and MAILADDR.
  -v  Append RCS revision to file names in log lines.
  --help  Output help.
  --version  Output version number.

Report bugs to <bug-gnu-emacs@@gnu.org>.'
d15 1
a15 3
Id='$Id: rcs2log,v 1.45 1998/08/12 22:33:01 eggert Exp $'

# Copyright 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
d21 1
a21 1
#
d26 1
a26 1
#
a31 7
Copyright='Copyright 1998 Free Software Foundation, Inc.
This program comes with NO WARRANTY, to the extent permitted by law.
You may redistribute copies of this program
under the terms of the GNU General Public License.
For more information about these matters, see the files named COPYING.
Author: Paul Eggert <eggert@@twinsun.com>'

a40 2
changelog=ChangeLog # change log file name
datearg= # rlog date option
a45 1
logTZ= # time zone for log dates (if empty, use local time)
a46 1
revision= # t if we want revision numbers
a52 1
	-c)	changelog=${2?}; shift;;
d63 1
a63 4
			case $loginFullnameMailaddrs in
			'') loginFullnameMailaddrs=$2$tab$3$tab$4;;
			?*) loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$2$tab$3$tab$4
			esac
d86 1
a86 4
			case $loginFullnameMailaddrs in
			'') loginFullnameMailaddrs=$2;;
			?*) loginFullnameMailaddrs=$loginFullnameMailaddrs$nl$2
			esac
d89 1
a89 4
		case $logins in
		'') logins=$login;;
		?*) logins=$logins$nl$login
		esac
d91 1
a91 6
	-r)
		case $rlog_options in
		'') rlog_options=${2?};;
		?*) rlog_options=$rlog_options$nl${2?}
		esac
		shift;;
d94 5
a98 11
	-v)	revision=t;;
	--version)
		set $Id
		rcs2logVersion=$3
		echo >&2 "rcs2log (GNU Emacs) $rcs2logVersion$nl$Copyright"
		exit 0;;
	-*)	echo >&2 "Usage: $0 [OPTION]... [FILE ...]$nl$Help"
		case $1 in
		--help) exit 0;;
		*) exit 1
		esac;;
d109 6
a121 2
# Since ChangeLog is only by date, some of these revisions may be duplicates of
# what's already in ChangeLog; it's the user's responsibility to remove them.
d124 2
a125 1
	if test -s "$changelog"
d127 1
a128 5
			/^[0-9]+-[0-9][0-9]-[0-9][0-9]/{
				# ISO 8601 date
				print $1
				exit
			}
a129 1
				# old-fashioned date and time (Emacs 19.31 and earlier)
d134 27
a160 1
				printf "%d-%02d-%02d\n", year, i+1, dd
d164 1
a164 1
		d=`$AWK "$e" <"$changelog"` || exit
d166 1
a166 1
		?*) datearg="-d>$d"
d169 1
a171 17
# Use TZ specified by ChangeLog local variable, if any.
if test -s "$changelog"
then
	extractTZ='
		/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*"\([^"]*\)".*/{
			s//\1/; p; q
		}
		/^.*change-log-time-zone-rule['"$tab"' ]*:['"$tab"' ]*t.*/{
			s//UTC0/; p; q
		}
	'
	logTZ=`tail "$changelog" | sed -n "$extractTZ"`
	case $logTZ in
	?*) TZ=$logTZ; export TZ
	esac
fi

d178 1
a178 1
	rlog='cvs -q log'
a198 10
# Use $rlog's -zLT option, if $rlog supports it.
case `$rlog -zLT 2>&1` in
*' option'*) ;;
*)
	case $rlog_options in
	'') rlog_options=-zLT;;
	?*) rlog_options=-zLT$nl$rlog_options
	esac
esac

d213 1
a213 8
					?*) find $RCSdirs \
							-type f \
							! -name '*_' \
							! -name ',*,' \
							! -name '.*_' \
							! -name .rcsfreeze.log \
							! -name .rcsfreeze.ver \
							-print
d225 2
a226 9
				RCS/. | RCS/.. | RCS/,*, | RCS/*_) continue;;
				RCS/.rcsfreeze.log | RCS/.rcsfreeze.ver) continue;;
				RCS/.\* | RCS/\* | .\*,v | \*,v) test -f "$file" || continue;;
				RCS/*,v | RCS/.*,v) ;;
				RCS/* | RCS/.*) test -f "$file" || continue
				esac
				case $files in
				'') files=$file;;
				?*) files=$files$nl$file
d228 1
d245 3
a247 3
case $datearg in
?*) $rlog $rlog_options "$datearg" ${1+"$@@"} >$rlogout;;
'') $rlog $rlog_options ${1+"$@@"} >$rlogout
d365 7
a371 10
		{
			(getent passwd $authors) ||
			(
				cat /etc/passwd
				for author in $authors
				do NIS_PATH= nismatch $author passwd.org_dir
				done
				ypmatch $authors passwd
			)
		} 2>/dev/null |
d379 1
a379 1
# `Log' is the log message (with \n replaced by \001).
d395 1
a395 1
	if ('"$length"' <= '"$indent"' + 1 + length(files) + index(Log, SOH)) sep = "\n" indent_string
d400 2
a401 2
	# Print each line of the log, transliterating \001 to \n.
	while ((i = index(Log, SOH)) != 0) {
a412 3
# Pattern to match the `revision' line of rlog output.
rlog_revision_pattern='^revision [0-9]+\.[0-9]+(\.[0-9]+\.[0-9]+)*(['"$tab"' ]+locked by: [^'"$tab"' $,.0-9:;@@]*[^'"$tab"' $,:;@@][^'"$tab"' $,.0-9:;@@]*;)?['"$tab"' ]*$'

d436 1
a436 1
# Transliterate \n to \001 so that multiline entries fit on a single line.
a448 5
			if (filename ~ /(^|\/)Attic\/[^\/]*$/) {
				i = length(filename)
				while (substr(filename, i, 1) != "/") i--
				filename = substr(filename, 1, i - 6) substr(filename, i + 1)
			}
a449 1
		rev = "?"
d452 3
a454 7
	/'"$rlog_revision_pattern"'/, /^(-----------*|===========*)$/ {
		line = $0
		if (line ~ /'"$rlog_revision_pattern"'/) {
			rev = $2
			next
		}
		if (line ~ /^date: [0-9][- +\/0-9:]*;/) {
d456 2
a457 3
			if (date ~ /\//) {
				# This is a traditional RCS format date YYYY/MM/DD.
				# Replace "/"s with "-"s to get ISO format.
d459 2
a460 2
				while ((i = index(date, "/")) != 0) {
					newdate = newdate substr(date, 1, i-1) "-"
d465 2
a466 1
			time = substr($3, 1, length($3) - 1)
d468 1
a468 2
			printf "%s %s %s %s %s %c", filename, rev, date, time, author, 1
			rev = "?"
d471 2
a472 6
		if (line ~ /^branches: /) { next }
		if (line ~ /^(-----------*|===========*)$/) { print ""; next }
		if (line == "Initial revision" || line ~ /^file .+ was initially added on branch .+\.$/) {
			line = "New file."
		}
		printf "%s%c", line, 1
d477 3
a479 3
# FILENAME REVISION YYYY-MM-DD HH:MM:SS[+-TIMEZONE] AUTHOR \001LOG
#	where \001 stands for a carriage return,
#	and each line of the log is terminated by \001 instead of \n.
d481 2
a482 3
# then by author, then by log entry, and finally by file name and revision
# (just in case).
sort +2 -4r +4 +0 |
d487 3
a489 6
		logTZ = "'"$logTZ"'"
		revision = "'"$revision"'"

		# Some awk variants do not understand "\001", so we have to
		# put the char directly in the file.
		SOH="" # <-- There is a single SOH (octal code 001) here.
d503 13
d519 1
a519 1
		newlog = substr($0, 1 + index($0, SOH))
d524 1
a524 1
		if (Log != newlog || date != $3 || author != $5) {
d555 1
a555 1
		if (date != $3  ||  author != $5) {
d558 2
a559 7
			date = $3
			time = $4
			author = $5

			zone = ""
			if (logTZ && ((i = index(time, "-")) || (i = index(time, "+"))))
				zone = " " substr(time, i)
d561 14
a574 1
			# Print "date[ timezone]  fullname  <email address>".
d581 1
a581 1
			printf "%s%s  %s  ", date, zone, auth
a590 1
			if (revision && $2 != "?") files = files " " $2
a605 4

# Local Variables:
# tab-width:4
# End:
@


