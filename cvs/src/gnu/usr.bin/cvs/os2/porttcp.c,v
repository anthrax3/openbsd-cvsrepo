head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.86
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.82
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.78
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.80
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.72
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.76
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.74
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.70
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.68
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.66
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.64
	OPENBSD_5_0:1.1.1.1.0.62
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.60
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.58
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.54
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.56
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.52
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.50
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.48
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.46
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.44
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.42
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.40
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.38
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.36
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.34
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.32
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.30
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.28
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.26
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.24
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.22
	OPENBSD_3_0_BASE:1.1.1.1
	cvs-1-11-1p1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.20
	OPENBSD_2_9_BASE:1.1.1.1
	cvs-1-11:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	cvs-1-10-7:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	cvs-1-10-5:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	cvs-1-10:1.1.1.1
	cvs-1-9-28:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	cvs-1-9-26:1.1.1.1
	cvs-1-9-24:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	cvs-1-9-10:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	cvs-1-9-8:1.1.1.1
	cvs-1-9-6:1.1.1.1
	cvs-1-9-4:1.1.1.1
	cvs-1-9-2:1.1.1.1
	cvs-1-9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	cvs-1-8-1:1.1.1.1
	cvs-1-8:1.1.1.1
	cvs-1-7-2:1.1.1.1
	cvs-1-7-1:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	96.01.30.00.19.38;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.30.00.19.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/****************************************************************
**
**	PORTTCP.C	- Support for portable TCP/IP
**
****************************************************************/

#define TCPIP_IBM_NOHIDE
#include	<stdio.h>
#include	"tcpip.h"

/*
 * Common unknown error buffer
 */
static char ErrUnknownBuf[36];

#ifndef SockStrError

/****************************************************************
 *	Routine: SockStrError
 *	Returns: Pointer to static buffer
 *	Action : Convert SOCK_ERRNO into error text
 ****************************************************************/

const char *
SockStrError(int SockErrno)
{
#if defined (TCPIP_IBM)  && defined (IBM_CPP)
  switch (SockErrno)
    {
    case SOCEPERM:		return "Not owner";
    case SOCESRCH:		return "No such process";
    case SOCEINTR:		return "Interrupted system call";
    case SOCENXIO:		return "No such device or address";
    case SOCEBADF:		return "Bad file number";
    case SOCEACCES:		return "Permission denied";
    case SOCEFAULT:		return "Bad address";
    case SOCEINVAL:		return "Invalid argument";
    case SOCEMFILE:		return "Too many open files";
    case SOCEPIPE:		return "Broken pipe";
    case SOCEOS2ERR:		return "OS/2 Error";
    case SOCEWOULDBLOCK:	return "Operation would block";
    case SOCEINPROGRESS:	return "Operation now in progress";
    case SOCEALREADY:		return "Operation already in progress";
    case SOCENOTSOCK:		return "Socket operation on non-socket";
    case SOCEDESTADDRREQ:	return "Destination address required";
    case SOCEMSGSIZE:		return "Message too long";
    case SOCEPROTOTYPE:		return "Protocol wrong type for socket";
    case SOCENOPROTOOPT:	return "Protocol not available";
    case SOCEPROTONOSUPPORT:    return "Protocol not supported";
    case SOCESOCKTNOSUPPORT:    return "Socket type not supported";
    case SOCEOPNOTSUPP:		return "Operation not supported on socket";
    case SOCEPFNOSUPPORT:	return "Protocol family not supported";
    case SOCEAFNOSUPPORT:
      return "Address family not supported by protocol family";
    case SOCEADDRINUSE:		return "Address already in use";
    case SOCEADDRNOTAVAIL:	return "Can't assign requested address";
    case SOCENETDOWN:		return "Network is down";
    case SOCENETUNREACH:	return "Network is unreachable";
    case SOCENETRESET:		return "Network dropped connection on reset";
    case SOCECONNABORTED:	return "Software caused connection abort";
    case SOCECONNRESET:		return "Connection reset by peer";
    case SOCENOBUFS:		return "No buffer space available";
    case SOCEISCONN:		return "Socket is already connected";
    case SOCENOTCONN:		return "Socket is not connected";
    case SOCESHUTDOWN:		return "Can't send after socket shutdown";
    case SOCETOOMANYREFS:	return "Too many references: can't splice";
    case SOCETIMEDOUT:		return "Connection timed out";
    case SOCECONNREFUSED:	return "Connection refused";
    case SOCELOOP:		return "Too many levels of symbolic links";
    case SOCENAMETOOLONG:	return "File name too long";
    case SOCEHOSTDOWN:		return "Host is down";
    case SOCEHOSTUNREACH:	return "No route to host";
    case SOCENOTEMPTY:		return "Directory not empty";

    default:
      sprintf( ErrUnknownBuf, "SockStrErrno( %d ) unknown", SockErrno );
      return ErrUnknownBuf;
    }
#else
#error	SockStrError not supported for this OS
#endif
}

#endif /* SockStrError */


/****************************************************************
 *	Routine: HostStrError
 *	Returns: Pointer to static buffer
 *	Action : Convert HOST_ERRNO into error text
 ****************************************************************/

const char *
HostStrError(int HostErrno)
{
  switch (HostErrno) 
    {
    case HOST_NOT_FOUND:
      return "Host not found";
    case TRY_AGAIN:
      return "Host not found (suggest try again)";
    case NO_RECOVERY:
      return "Non-recoverable error: FORMERR, REFUSED, NOTIMP";
    case NO_DATA:
      return "No Data (valid name, but no record of requested type)";

    default:
      sprintf( ErrUnknownBuf, "HostStrErrno( %d ) unknown", HostErrno );
      return ErrUnknownBuf;
    }
}


#if defined( TCPIP_IBM )
/****************************************************************
 * Routine: IbmSockSend
 * Returns: same as send
 * Action : Do the right thing for IBM TCP/IP which includes
 *	    the following two stupidities:
 *		1) Never try to send more than 32K
 *		2) Never pass a buffer that crosses a 64K boundary
 *     	 If Flags is non-zero, this function only attempts
 *	 to deal with condition (1) above.
 ****************************************************************/

int
IbmSockSend (int Socket, const void *Buffer, int Len, int Flags)
{
	int Sent, ToSend, TotalSent = 0;

	const char *Tmp = Buffer;

    /*
     * If Flags have been passed in, the 64K boundary optimization
     * can not be performed.  For example, MSG_PEEK would not work
     * correctly.
     */
	if (Flags)
          return send (Socket, (char *) Buffer, min (0x7FFF, Len), Flags);

	do
        {
          /* Never send across a 64K boundary */
          ToSend = min (Len, (int) (0x10000 -  (0xFFFF & (long) Tmp)));

          /* Never send more than 32K */
          if (ToSend > 0x7FFF) 
            ToSend = 0x7FFF;

          Sent = send (Socket, (char *) Tmp, ToSend, 0);
          if (Sent < 0)
            {
              if ((TotalSent > 0) && (SOCK_ERRNO == EWOULDBLOCK))
                return TotalSent;
              if (SOCK_ERRNO == EINTR)
                continue;
              return Sent;
            }
          if (Sent < ToSend)
            return TotalSent + Sent;
          
          Tmp += Sent;
          TotalSent += Sent;
          Len -= Sent;
	} while (Len > 0);
        
	return TotalSent;
}



/****************************************************************
 * Routine: IbmSockRecv
 * Returns: same as recv
 * Action : Do the right thing for IBM TCP/IP which includes
 *          the following two stupidities:
 *			1) Never try to recv more than 32K
 *			2) Never pass a buffer that crosses a 64K boundary
 *		 If Flags is non-zero, this function only attempts
 *		 to deal with condition (1) above.
 ****************************************************************/

int
IbmSockRecv (int Socket, const void *Buffer, int Len, int Flags)
{
  int Recvd, ToRecv, TotalRecvd = 0;

  char *Tmp = Buffer;

  /* If Flags have been passed in, the 64K boundary optimization
     probably can not be performed. */

	if (Flags)
          return recv (Socket, Buffer, min (0x7FFF, Len), Flags);

	do
	{
          /* Never send across a 64K boundary */
          ToRecv = min( Len, (int)( 0x10000 - ( 0xFFFF & (long)Tmp )));
          
          /* Never send more than 32K */
          if( ToRecv > 0x7FFF )
            ToRecv = 0x7FFF;

          Recvd = recv (Socket, Tmp, ToRecv, 0);
          if (Recvd <= 0)
            {
              if ((TotalRecvd > 0)
                  && (Recvd == 0 || (SOCK_ERRNO == EWOULDBLOCK )))
                return TotalRecvd;
              if (SOCK_ERRNO == EINTR)
                continue;
              
              return Recvd;
            }
          if (Recvd < ToRecv)
            return TotalRecvd + Recvd;
          
          Tmp += Recvd;
          TotalRecvd += Recvd;
          Len -= Recvd;
	} while (Len > 0);
        
	return TotalRecvd;
}
#endif /* defined( TCPIP_IBM ) */

@


1.1.1.1
log
@Upgrade to 1.7.1 snapshot
@
text
@@

