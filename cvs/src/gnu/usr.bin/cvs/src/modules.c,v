head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.36
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.32
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.34
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.26
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.30
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.28
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.1.1.14.0.10
	OPENBSD_3_4_BASE:1.1.1.14
	OPENBSD_3_3:1.1.1.14.0.8
	OPENBSD_3_3_BASE:1.1.1.14
	OPENBSD_3_2:1.1.1.14.0.6
	OPENBSD_3_2_BASE:1.1.1.14
	OPENBSD_3_1:1.1.1.14.0.4
	OPENBSD_3_1_BASE:1.1.1.14
	OPENBSD_3_0:1.1.1.14.0.2
	OPENBSD_3_0_BASE:1.1.1.14
	cvs-1-11-1p1:1.1.1.14
	OPENBSD_2_9:1.1.1.13.0.2
	OPENBSD_2_9_BASE:1.1.1.13
	cvs-1-11:1.1.1.13
	OPENBSD_2_8:1.1.1.12.0.6
	OPENBSD_2_8_BASE:1.1.1.12
	OPENBSD_2_7:1.1.1.12.0.4
	OPENBSD_2_7_BASE:1.1.1.12
	OPENBSD_2_6:1.1.1.12.0.2
	OPENBSD_2_6_BASE:1.1.1.12
	cvs-1-10-7:1.1.1.12
	OPENBSD_2_5:1.1.1.11.0.2
	OPENBSD_2_5_BASE:1.1.1.11
	cvs-1-10-5:1.1.1.11
	OPENBSD_2_4:1.1.1.10.0.4
	OPENBSD_2_4_BASE:1.1.1.10
	cvs-1-10:1.1.1.10
	cvs-1-9-28:1.1.1.10
	OPENBSD_2_3:1.1.1.10.0.2
	OPENBSD_2_3_BASE:1.1.1.10
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2008.02.27.18.25.38;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.16.07.03.04;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.12.14.43.56;	author millert;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.16;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.03;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.46;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.43;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.39;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.15;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.30;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.49;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.22;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.02.28.21.33.11;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.09.10.05.06.24;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.02.10.18.57.44;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches
	1.1.1.14.8.1
	1.1.1.14.10.1;
next	;

1.1.1.14.8.1
date	2004.05.01.00.03.03;	author brad;	state Exp;
branches;
next	1.1.1.14.8.2;

1.1.1.14.8.2
date	2004.05.01.00.17.35;	author brad;	state Exp;
branches;
next	;

1.1.1.14.10.1
date	2004.05.01.00.02.22;	author brad;	state Exp;
branches;
next	1.1.1.14.10.2;

1.1.1.14.10.2
date	2004.05.01.00.09.46;	author brad;	state Exp;
branches;
next	;

1.2.2.1
date	2004.05.01.00.19.41;	author brad;	state Exp;
branches;
next	;


desc
@@


1.4
log
@fix a segfault in gnucvs that can occur with "checkout -c" if there is
an unknown flag specified in CVSROOT/modules.

found by tobias@@, ok millert@@
@
text
@/*
 *    Copyright (c) 1992, Brian Berliner and Jeff Polk
 *    Copyright (c) 1989-1992, Brian Berliner
 *
 *    You may distribute under the terms of the GNU General Public License
 *    as specified in the README file that comes with the CVS source distribution.
 *
 * Modules
 *
 *	Functions for accessing the modules file.
 *
 *	The modules file supports basically three formats of lines:
 *		key [options] directory files... [ -x directory [files] ] ...
 *		key [options] directory [ -x directory [files] ] ...
 *		key -a aliases...
 *
 *	The -a option allows an aliasing step in the parsing of the modules
 *	file.  The "aliases" listed on a line following the -a are
 *	processed one-by-one, as if they were specified as arguments on the
 *	command line.
 */

#include <assert.h>
#include "cvs.h"
#include "savecwd.h"


/* Defines related to the syntax of the modules file.  */

/* Options in modules file.  Note that it is OK to use GNU getopt features;
   we already are arranging to make sure we are using the getopt distributed
   with CVS.  */
#define	CVSMODULE_OPTS	"+ad:i:lo:e:s:t:u:"

/* Special delimiter.  */
#define CVSMODULE_SPEC	'&'

struct sortrec
{
    /* Name of the module, malloc'd.  */
    char *modname;
    /* If Status variable is set, this is either def_status or the malloc'd
       name of the status.  If Status is not set, the field is left
       uninitialized.  */
    char *status;
    /* Pointer to a malloc'd array which contains (1) the raw contents
       of the options and arguments, excluding comments, (2) a '\0',
       and (3) the storage for the "comment" field.  */
    char *rest;
    char *comment;
};

static int sort_order PROTO((const PTR l, const PTR r));
static void save_d PROTO((char *k, int ks, char *d, int ds));


/*
 * Open the modules file, and die if the CVSROOT environment variable
 * was not set.  If the modules file does not exist, that's fine, and
 * a warning message is displayed and a NULL is returned.
 */
DBM *
open_module ()
{
    char *mfile;
    DBM *retval;

    if (current_parsed_root == NULL)
    {
	error (0, 0, "must set the CVSROOT environment variable");
	error (1, 0, "or specify the '-d' global option");
    }
    mfile = xmalloc (strlen (current_parsed_root->directory)
		     + sizeof (CVSROOTADM)
		     + sizeof (CVSROOTADM_MODULES) + 3);
    (void) sprintf (mfile, "%s/%s/%s", current_parsed_root->directory,
		    CVSROOTADM, CVSROOTADM_MODULES);
    retval = dbm_open (mfile, O_RDONLY, 0666);
    free (mfile);
    return retval;
}

/*
 * Close the modules file, if the open succeeded, that is
 */
void
close_module (db)
    DBM *db;
{
    if (db != NULL)
	dbm_close (db);
}

/*
 * This is the recursive function that processes a module name.
 * It calls back the passed routine for each directory of a module
 * It runs the post checkout or post tag proc from the modules file
 */
int
do_module (db, mname, m_type, msg, callback_proc, where, shorten,
	   local_specified, run_module_prog, build_dirs, extra_arg)
    DBM *db;
    char *mname;
    enum mtype m_type;
    char *msg;
    CALLBACKPROC callback_proc;
    char *where;
    int shorten;
    int local_specified;
    int run_module_prog;
    int build_dirs;
    char *extra_arg;
{
    char *checkin_prog = NULL;
    char *checkout_prog = NULL;
    char *export_prog = NULL;
    char *tag_prog = NULL;
    char *update_prog = NULL;
    struct saved_cwd cwd;
    int cwd_saved = 0;
    char *line;
    int modargc;
    int xmodargc;
    char **modargv;
    char **xmodargv = NULL;
    /* Found entry from modules file, including options and such.  */
    char *value = NULL;
    char *mwhere = NULL;
    char *mfile = NULL;
    char *spec_opt = NULL;
    char *xvalue = NULL;
    int alias = 0;
    datum key, val;
    char *cp;
    int c, err = 0;
    int nonalias_opt = 0;

#ifdef SERVER_SUPPORT
    int restore_server_dir = 0;
    char *server_dir_to_restore = NULL;
    if (trace)
    {
	char *buf;

	/* We use cvs_outerr, rather than fprintf to stderr, because
	   this may be called by server code with error_use_protocol
	   set.  */
	buf = xmalloc (100
		       + strlen (mname)
		       + strlen (msg)
		       + (where ? strlen (where) : 0)
		       + (extra_arg ? strlen (extra_arg) : 0));
	sprintf (buf, "%s-> do_module (%s, %s, %s, %s)\n",
		 CLIENT_SERVER_STR,
		 mname, msg, where ? where : "",
		 extra_arg ? extra_arg : "");
	cvs_outerr (buf, 0);
	free (buf);
    }
#endif

    /* Don't process absolute directories.  Anything else could be a security
     * problem.  Before this check was put in place:
     *
     *   $ cvs -d:fork:/cvsroot co /foo
     *   cvs server: warning: cannot make directory CVS in /: Permission denied
     *   cvs [server aborted]: cannot make directory /foo: Permission denied
     *   $
     */
    if (isabsolute (mname))
	error (1, 0, "Absolute module reference invalid: `%s'", mname);

    /* Similarly for directories that attempt to step above the root of the
     * repository.
     */
    if (pathname_levels (mname) > 0)
	error (1, 0, "up-level in module reference (`..') invalid: `%s'.",
               mname);

    /* if this is a directory to ignore, add it to that list */
    if (mname[0] == '!' && mname[1] != '\0')
    {
	ign_dir_add (mname+1);
	goto do_module_return;
    }

    /* strip extra stuff from the module name */
    strip_trailing_slashes (mname);

    /*
     * Look up the module using the following scheme:
     *	1) look for mname as a module name
     *	2) look for mname as a directory
     *	3) look for mname as a file
     *  4) take mname up to the first slash and look it up as a module name
     *	   (this is for checking out only part of a module)
     */

    /* look it up as a module name */
    key.dptr = mname;
    key.dsize = strlen (key.dptr);
    if (db != NULL)
	val = dbm_fetch (db, key);
    else
	val.dptr = NULL;
    if (val.dptr != NULL)
    {
	/* copy and null terminate the value */
	value = xmalloc (val.dsize + 1);
	memcpy (value, val.dptr, val.dsize);
	value[val.dsize] = '\0';

	/* If the line ends in a comment, strip it off */
	if ((cp = strchr (value, '#')) != NULL)
	    *cp = '\0';
	else
	    cp = value + val.dsize;

	/* Always strip trailing spaces */
	while (cp > value && isspace ((unsigned char) *--cp))
	    *cp = '\0';

	mwhere = xstrdup (mname);
	goto found;
    }
    else
    {
	char *file;
	char *attic_file;
	char *acp;
	int is_found = 0;

	/* check to see if mname is a directory or file */
	file = xmalloc (strlen (current_parsed_root->directory)
			+ strlen (mname) + sizeof(RCSEXT) + 2);
	(void) sprintf (file, "%s/%s", current_parsed_root->directory, mname);
	attic_file = xmalloc (strlen (current_parsed_root->directory)
			      + strlen (mname)
			      + sizeof (CVSATTIC) + sizeof (RCSEXT) + 3);
	if ((acp = strrchr (mname, '/')) != NULL)
	{
	    *acp = '\0';
	    (void) sprintf (attic_file, "%s/%s/%s/%s%s", current_parsed_root->directory,
			    mname, CVSATTIC, acp + 1, RCSEXT);
	    *acp = '/';
	}
	else
	    (void) sprintf (attic_file, "%s/%s/%s%s", current_parsed_root->directory,
			    CVSATTIC, mname, RCSEXT);

	if (isdir (file))
	{
	    modargv = xmalloc (sizeof (*modargv));
	    modargv[0] = xstrdup (mname);
	    modargc = 1;
	    is_found = 1;
	}
	else
	{
	    (void) strcat (file, RCSEXT);
	    if (isfile (file) || isfile (attic_file))
	    {
		/* if mname was a file, we have to split it into "dir file" */
		if ((cp = strrchr (mname, '/')) != NULL && cp != mname)
		{
		    modargv = xmalloc (2 * sizeof (*modargv));
		    modargv[0] = xmalloc (strlen (mname) + 2);
		    strncpy (modargv[0], mname, cp - mname);
		    modargv[0][cp - mname] = '\0';
		    modargv[1] = xstrdup (cp + 1);
		    modargc = 2;
		}
		else
		{
		    /*
		     * the only '/' at the beginning or no '/' at all
		     * means the file we are interested in is in CVSROOT
		     * itself so the directory should be '.'
		     */
		    if (cp == mname)
		    {
			/* drop the leading / if specified */
			modargv = xmalloc (2 * sizeof (*modargv));
			modargv[0] = xstrdup (".");
			modargv[1] = xstrdup (mname + 1);
			modargc = 2;
		    }
		    else
		    {
			/* otherwise just copy it */
			modargv = xmalloc (2 * sizeof (*modargv));
			modargv[0] = xstrdup (".");
			modargv[1] = xstrdup (mname);
			modargc = 2;
		    }
		}
		is_found = 1;
	    }
	}
	free (attic_file);
	free (file);

	if (is_found)
	{
	    assert (value == NULL);

	    /* OK, we have now set up modargv with the actual
	       file/directory we want to work on.  We duplicate a
	       small amount of code here because the vast majority of
	       the code after the "found" label does not pertain to
	       the case where we found a file/directory rather than
	       finding an entry in the modules file.  */
	    if (save_cwd (&cwd))
		error_exit ();
	    cwd_saved = 1;

	    err += callback_proc (modargc, modargv, where, mwhere, mfile,
				  shorten,
				  local_specified, mname, msg);

	    free_names (&modargc, modargv);

	    /* cd back to where we started.  */
	    if (restore_cwd (&cwd, NULL))
		error_exit ();
	    free_cwd (&cwd);
	    cwd_saved = 0;

	    goto do_module_return;
	}
    }

    /* look up everything to the first / as a module */
    if (mname[0] != '/' && (cp = strchr (mname, '/')) != NULL)
    {
	/* Make the slash the new end of the string temporarily */
	*cp = '\0';
	key.dptr = mname;
	key.dsize = strlen (key.dptr);

	/* do the lookup */
	if (db != NULL)
	    val = dbm_fetch (db, key);
	else
	    val.dptr = NULL;

	/* if we found it, clean up the value and life is good */
	if (val.dptr != NULL)
	{
	    char *cp2;

	    /* copy and null terminate the value */
	    value = xmalloc (val.dsize + 1);
	    memcpy (value, val.dptr, val.dsize);
	    value[val.dsize] = '\0';

	    /* If the line ends in a comment, strip it off */
	    if ((cp2 = strchr (value, '#')) != NULL)
		*cp2 = '\0';
	    else
		cp2 = value + val.dsize;

	    /* Always strip trailing spaces */
	    while (cp2 > value  &&  isspace ((unsigned char) *--cp2))
		*cp2 = '\0';

	    /* mwhere gets just the module name */
	    mwhere = xstrdup (mname);
	    mfile = cp + 1;

	    /* put the / back in mname */
	    *cp = '/';

	    goto found;
	}

	/* put the / back in mname */
	*cp = '/';
    }

    /* if we got here, we couldn't find it using our search, so give up */
    error (0, 0, "cannot find module `%s' - ignored", mname);
    err++;
    goto do_module_return;


    /*
     * At this point, we found what we were looking for in one
     * of the many different forms.
     */
  found:

    /* remember where we start */
    if (save_cwd (&cwd))
	error_exit ();
    cwd_saved = 1;

    assert (value != NULL);

    /* search the value for the special delimiter and save for later */
    if ((cp = strchr (value, CVSMODULE_SPEC)) != NULL)
    {
	*cp = '\0';			/* null out the special char */
	spec_opt = cp + 1;		/* save the options for later */

	/* strip whitespace if necessary */
	while (cp > value  &&  isspace ((unsigned char) *--cp))
	    *cp = '\0';
    }

    /* don't do special options only part of a module was specified */
    if (mfile != NULL)
	spec_opt = NULL;

    /*
     * value now contains one of the following:
     *    1) dir
     *	  2) dir file
     *    3) the value from modules without any special args
     *		    [ args ] dir [file] [file] ...
     *	     or     -a module [ module ] ...
     */

    /* Put the value on a line with XXX prepended for getopt to eat */
    line = xmalloc (strlen (value) + 5);
    strcpy(line, "XXX ");
    strcpy(line + 4, value);

    /* turn the line into an argv[] array */
    line2argv (&xmodargc, &xmodargv, line, " \t");
    free (line);
    modargc = xmodargc;
    modargv = xmodargv;

    /* parse the args */
    optind = 0;
    while ((c = getopt (modargc, modargv, CVSMODULE_OPTS)) != -1)
    {
	switch (c)
	{
	    case 'a':
		alias = 1;
		break;
	    case 'd':
		if (mwhere)
		    free (mwhere);
		mwhere = xstrdup (optarg);
		nonalias_opt = 1;
		break;
	    case 'i':
		if (checkin_prog)
		    free (checkin_prog);
		checkin_prog = xstrdup (optarg);
		nonalias_opt = 1;
		break;
	    case 'l':
		local_specified = 1;
		nonalias_opt = 1;
		break;
	    case 'o':
		if (checkout_prog)
		    free (checkout_prog);
		checkout_prog = xstrdup (optarg);
		nonalias_opt = 1;
		break;
	    case 'e':
		if (export_prog)
		    free (export_prog);
		export_prog = xstrdup (optarg);
		nonalias_opt = 1;
		break;
	    case 't':
		if (tag_prog)
		    free (tag_prog);
		tag_prog = xstrdup (optarg);
		nonalias_opt = 1;
		break;
	    case 'u':
		if (update_prog)
		    free (update_prog);
		update_prog = xstrdup (optarg);
		nonalias_opt = 1;
		break;
	    case '?':
		error (0, 0,
		       "modules file has invalid option for key %s value %s",
		       key.dptr, value);
		err++;
		goto do_module_return;
	}
    }
    modargc -= optind;
    modargv += optind;
    if (modargc == 0  &&  spec_opt == NULL)
    {
	error (0, 0, "modules file missing directory for module %s", mname);
	++err;
	goto do_module_return;
    }

    if (alias && nonalias_opt)
    {
	/* The documentation has never said it is legal to specify
	   -a along with another option.  And I believe that in the past
	   CVS has ignored the options other than -a, more or less, in this
	   situation.  */
	error (0, 0, "\
-a cannot be specified in the modules file along with other options");
	++err;
	goto do_module_return;
    }

    /* if this was an alias, call ourselves recursively for each module */
    if (alias)
    {
	int i;

	for (i = 0; i < modargc; i++)
	{
	    if (strcmp (mname, modargv[i]) == 0)
		error (0, 0,
		       "module `%s' in modules file contains infinite loop",
		       mname);
	    else
		err += do_module (db, modargv[i], m_type, msg, callback_proc,
				  where, shorten, local_specified,
				  run_module_prog, build_dirs, extra_arg);
	}
	goto do_module_return;
    }

    if (mfile != NULL && modargc > 1)
    {
	error (0, 0, "\
module `%s' is a request for a file in a module which is not a directory",
	       mname);
	++err;
	goto do_module_return;
    }

    /* otherwise, process this module */
    if (modargc > 0)
    {
	err += callback_proc (modargc, modargv, where, mwhere, mfile, shorten,
			      local_specified, mname, msg);
    }
    else
    {
	/*
	 * we had nothing but special options, so we must
	 * make the appropriate directory and cd to it
	 */
	char *dir;

	if (!build_dirs)
	    goto do_special;

	dir = where ? where : (mwhere ? mwhere : mname);
	/* XXX - think about making null repositories at each dir here
		 instead of just at the bottom */
	make_directories (dir);
	if ( CVS_CHDIR (dir) < 0)
	{
	    error (0, errno, "cannot chdir to %s", dir);
	    spec_opt = NULL;
	    err++;
	    goto do_special;
	}
	if (!isfile (CVSADM))
	{
	    char *nullrepos;

	    nullrepos = emptydir_name ();

	    Create_Admin (".", dir,
			  nullrepos, (char *) NULL, (char *) NULL, 0, 0, 1);
	    if (!noexec)
	    {
		FILE *fp;

		fp = open_file (CVSADM_ENTSTAT, "w+");
		if (fclose (fp) == EOF)
		    error (1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
		if (server_active)
		    server_set_entstat (dir, nullrepos);
#endif
	    }
	    free (nullrepos);
	}
    }

    /* if there were special include args, process them now */

  do_special:

    free_names (&xmodargc, xmodargv);
    xmodargv = NULL;

    /* blow off special options if -l was specified */
    if (local_specified)
	spec_opt = NULL;

#ifdef SERVER_SUPPORT
    /* We want to check out into the directory named by the module.
       So we set a global variable which tells the server to glom that
       directory name onto the front.  A cleaner approach would be some
       way of passing it down to the recursive call, through the
       callback_proc, to start_recursion, and then into the update_dir in
       the struct file_info.  That way the "Updating foo" message could
       print the actual directory we are checking out into.

       For local CVS, this is handled by the chdir call above
       (directly or via the callback_proc).  */
    if (server_active && spec_opt != NULL)
    {
	char *change_to;

	change_to = where ? where : (mwhere ? mwhere : mname);
	server_dir_to_restore = server_dir;
	restore_server_dir = 1;
	server_dir =
	    xmalloc ((server_dir_to_restore != NULL
		      ? strlen (server_dir_to_restore)
		      : 0)
		     + strlen (change_to)
		     + 5);
	server_dir[0] = '\0';
	if (server_dir_to_restore != NULL)
	{
	    strcat (server_dir, server_dir_to_restore);
	    strcat (server_dir, "/");
	}
	strcat (server_dir, change_to);
    }
#endif

    while (spec_opt != NULL)
    {
	char *next_opt;

	cp = strchr (spec_opt, CVSMODULE_SPEC);
	if (cp != NULL)
	{
	    /* save the beginning of the next arg */
	    next_opt = cp + 1;

	    /* strip whitespace off the end */
	    do
		*cp = '\0';
	    while (cp > spec_opt  &&  isspace ((unsigned char) *--cp));
	}
	else
	    next_opt = NULL;

	/* strip whitespace from front */
	while (isspace ((unsigned char) *spec_opt))
	    spec_opt++;

	if (*spec_opt == '\0')
	    error (0, 0, "Mal-formed %c option for module %s - ignored",
		   CVSMODULE_SPEC, mname);
	else
	    err += do_module (db, spec_opt, m_type, msg, callback_proc,
			      (char *) NULL, 0, local_specified,
			      run_module_prog, build_dirs, extra_arg);
	spec_opt = next_opt;
    }

#ifdef SERVER_SUPPORT
    if (server_active && restore_server_dir)
    {
	free (server_dir);
	server_dir = server_dir_to_restore;
    }
#endif

    /* write out the checkin/update prog files if necessary */
#ifdef SERVER_SUPPORT
    if (err == 0 && !noexec && m_type == CHECKOUT && server_expanding)
    {
	if (checkin_prog != NULL)
	    server_prog (where ? where : mname, checkin_prog, PROG_CHECKIN);
	if (update_prog != NULL)
	    server_prog (where ? where : mname, update_prog, PROG_UPDATE);
    }
    else
#endif
    if (err == 0 && !noexec && m_type == CHECKOUT && run_module_prog)
    {
	FILE *fp;

	if (checkin_prog != NULL)
	{
	    fp = open_file (CVSADM_CIPROG, "w+");
	    (void) fprintf (fp, "%s\n", checkin_prog);
	    if (fclose (fp) == EOF)
		error (1, errno, "cannot close %s", CVSADM_CIPROG);
	}
	if (update_prog != NULL)
	{
	    fp = open_file (CVSADM_UPROG, "w+");
	    (void) fprintf (fp, "%s\n", update_prog);
	    if (fclose (fp) == EOF)
		error (1, errno, "cannot close %s", CVSADM_UPROG);
	}
    }

    /* cd back to where we started */
    if (restore_cwd (&cwd, NULL))
	error_exit ();
    free_cwd (&cwd);
    cwd_saved = 0;

    /* run checkout or tag prog if appropriate */
    if (err == 0 && run_module_prog)
    {
	if ((m_type == TAG && tag_prog != NULL) ||
	    (m_type == CHECKOUT && checkout_prog != NULL) ||
	    (m_type == EXPORT && export_prog != NULL))
	{
	    /*
	     * If a relative pathname is specified as the checkout, tag
	     * or export proc, try to tack on the current "where" value.
	     * if we can't find a matching program, just punt and use
	     * whatever is specified in the modules file.
	     */
	    char *real_prog = NULL;
	    char *prog = (m_type == TAG ? tag_prog :
			  (m_type == CHECKOUT ? checkout_prog : export_prog));
	    char *real_where = (where != NULL ? where : mwhere);
	    char *expanded_path;

	    if ((*prog != '/') && (*prog != '.'))
	    {
		real_prog = xmalloc (strlen (real_where) + strlen (prog)
				     + 10);
		(void) sprintf (real_prog, "%s/%s", real_where, prog);
		if (isfile (real_prog))
		    prog = real_prog;
	    }

	    /* XXX can we determine the line number for this entry??? */
	    expanded_path = expand_path (prog, "modules", 0);
	    if (expanded_path != NULL)
	    {
		run_setup (expanded_path);
		run_arg (real_where);

		if (extra_arg)
		    run_arg (extra_arg);

		if (!quiet)
		{
		    cvs_output (program_name, 0);
		    cvs_output (" ", 1);
		    cvs_output (command_name, 0);
		    cvs_output (": Executing '", 0);
		    run_print (stdout);
		    cvs_output ("'\n", 0);
		    cvs_flushout ();
		}
		err += run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
		free (expanded_path);
	    }
	    free (real_prog);
	}
    }

 do_module_return:
    /* clean up */
    if (xmodargv != NULL)
	free_names (&xmodargc, xmodargv);
    if (mwhere)
	free (mwhere);
    if (checkin_prog)
	free (checkin_prog);
    if (checkout_prog)
	free (checkout_prog);
    if (export_prog)
	free (export_prog);
    if (tag_prog)
	free (tag_prog);
    if (update_prog)
	free (update_prog);
    if (cwd_saved)
	free_cwd (&cwd);
    if (value != NULL)
	free (value);

    if (xvalue != NULL)
	free (xvalue);
    return (err);
}

/* - Read all the records from the modules database into an array.
   - Sort the array depending on what format is desired.
   - Print the array in the format desired.

   Currently, there are only two "desires":

   1. Sort by module name and format the whole entry including switches,
      files and the comment field: (Including aliases)

      modulename	-s switches, one per line, even if
			-i it has many switches.
			Directories and files involved, formatted
			to cover multiple lines if necessary.
			# Comment, also formatted to cover multiple
			# lines if necessary.

   2. Sort by status field string and print:  (*not* including aliases)

      modulename    STATUS	Directories and files involved, formatted
				to cover multiple lines if necessary.
				# Comment, also formatted to cover multiple
				# lines if necessary.
*/

static struct sortrec *s_head;

static int s_max = 0;			/* Number of elements allocated */
static int s_count = 0;			/* Number of elements used */

static int Status;		        /* Nonzero if the user is
					   interested in status
					   information as well as
					   module name */
static char def_status[] = "NONE";

/* Sort routine for qsort:
   - If we want the "Status" field to be sorted, check it first.
   - Then compare the "module name" fields.  Since they are unique, we don't
     have to look further.
*/
static int
sort_order (l, r)
    const PTR l;
    const PTR r;
{
    int i;
    const struct sortrec *left = (const struct sortrec *) l;
    const struct sortrec *right = (const struct sortrec *) r;

    if (Status)
    {
	/* If Sort by status field, compare them. */
	if ((i = strcmp (left->status, right->status)) != 0)
	    return (i);
    }
    return (strcmp (left->modname, right->modname));
}

static void
save_d (k, ks, d, ds)
    char *k;
    int ks;
    char *d;
    int ds;
{
    char *cp, *cp2;
    struct sortrec *s_rec;

    if (Status && *d == '-' && *(d + 1) == 'a')
	return;				/* We want "cvs co -s" and it is an alias! */

    if (s_count == s_max)
    {
	s_max += 64;
	s_head = (struct sortrec *) xrealloc ((char *) s_head, s_max * sizeof (*s_head));
    }
    s_rec = &s_head[s_count];
    s_rec->modname = cp = xmalloc (ks + 1);
    (void) strncpy (cp, k, ks);
    *(cp + ks) = '\0';

    s_rec->rest = cp2 = xmalloc (ds + 1);
    cp = d;
    *(cp + ds) = '\0';	/* Assumes an extra byte at end of static dbm buffer */

    while (isspace ((unsigned char) *cp))
	cp++;
    /* Turn <spaces> into one ' ' -- makes the rest of this routine simpler */
    while (*cp)
    {
	if (isspace ((unsigned char) *cp))
	{
	    *cp2++ = ' ';
	    while (isspace ((unsigned char) *cp))
		cp++;
	}
	else
	    *cp2++ = *cp++;
    }
    *cp2 = '\0';

    /* Look for the "-s statusvalue" text */
    if (Status)
    {
	s_rec->status = def_status;

	for (cp = s_rec->rest; (cp2 = strchr (cp, '-')) != NULL; cp = ++cp2)
	{
	    if (*(cp2 + 1) == 's' && *(cp2 + 2) == ' ')
	    {
		char *status_start;

		cp2 += 3;
		status_start = cp2;
		while (*cp2 != ' ' && *cp2 != '\0')
		    cp2++;
		s_rec->status = xmalloc (cp2 - status_start + 1);
		strncpy (s_rec->status, status_start, cp2 - status_start);
		s_rec->status[cp2 - status_start] = '\0';
		cp = cp2;
		break;
	    }
	}
    }
    else
	cp = s_rec->rest;

    /* Find comment field, clean up on all three sides & compress blanks */
    if ((cp2 = cp = strchr (cp, '#')) != NULL)
    {
	if (*--cp2 == ' ')
	    *cp2 = '\0';
	if (*++cp == ' ')
	    cp++;
	s_rec->comment = cp;
    }
    else
	s_rec->comment = "";

    s_count++;
}

/* Print out the module database as we know it.  If STATUS is
   non-zero, print out status information for each module. */

void
cat_module (status)
    int status;
{
    DBM *db;
    datum key, val;
    int i, c, wid, argc, cols = 80, indent, fill;
    int moduleargc;
    struct sortrec *s_h;
    char *cp, *cp2, **argv;
    char **moduleargv;

    Status = status;

    /* Read the whole modules file into allocated records */
    if (!(db = open_module ()))
	error (1, 0, "failed to open the modules file");

    for (key = dbm_firstkey (db); key.dptr != NULL; key = dbm_nextkey (db))
    {
	val = dbm_fetch (db, key);
	if (val.dptr != NULL)
	    save_d (key.dptr, key.dsize, val.dptr, val.dsize);
    }

    close_module (db);

    /* Sort the list as requested */
    qsort ((PTR) s_head, s_count, sizeof (struct sortrec), sort_order);

    /*
     * Run through the sorted array and format the entries
     * indent = space for modulename + space for status field
     */
    indent = 12 + (status * 12);
    fill = cols - (indent + 2);
    for (s_h = s_head, i = 0; i < s_count; i++, s_h++)
    {
	char *line;

	/* Print module name (and status, if wanted) */
	line = xmalloc (strlen (s_h->modname) + 15);
	sprintf (line, "%-12s", s_h->modname);
	cvs_output (line, 0);
	free (line);
	if (status)
	{
	    line = xmalloc (strlen (s_h->status) + 15);
	    sprintf (line, " %-11s", s_h->status);
	    cvs_output (line, 0);
	    free (line);
	}

	line = xmalloc (strlen (s_h->modname) + strlen (s_h->rest) + 15);
	/* Parse module file entry as command line and print options */
	(void) sprintf (line, "%s %s", s_h->modname, s_h->rest);
	line2argv (&moduleargc, &moduleargv, line, " \t");
	free (line);
	argc = moduleargc;
	argv = moduleargv;

	optind = 0;
	wid = 0;
	while ((c = getopt (argc, argv, CVSMODULE_OPTS)) != -1)
	{
	    if (c == '?') {
		error (0, 0, "invalid module line");
		return;
	    }

	    if (!status)
	    {
		if (c == 'a' || c == 'l')
		{
		    char buf[5];

		    sprintf (buf, " -%c", c);
		    cvs_output (buf, 0);
		    wid += 3;		/* Could just set it to 3 */
		}
		else
		{
		    char buf[10];

		    if (strlen (optarg) + 4 + wid > (unsigned) fill)
		    {
			int j;

			cvs_output ("\n", 1);
			for (j = 0; j < indent; ++j)
			    cvs_output (" ", 1);
			wid = 0;
		    }
		    sprintf (buf, " -%c ", c);
		    cvs_output (buf, 0);
		    cvs_output (optarg, 0);
		    wid += strlen (optarg) + 4;
		}
	    }
	}
	argc -= optind;
	argv += optind;

	/* Format and Print all the files and directories */
	for (; argc--; argv++)
	{
	    if (strlen (*argv) + wid > (unsigned) fill)
	    {
		int j;

		cvs_output ("\n", 1);
		for (j = 0; j < indent; ++j)
		    cvs_output (" ", 1);
		wid = 0;
	    }
	    cvs_output (" ", 1);
	    cvs_output (*argv, 0);
	    wid += strlen (*argv) + 1;
	}
	cvs_output ("\n", 1);

	/* Format the comment field -- save_d (), compressed spaces */
	for (cp2 = cp = s_h->comment; *cp; cp2 = cp)
	{
	    int j;

	    for (j = 0; j < indent; ++j)
		cvs_output (" ", 1);
	    cvs_output (" # ", 0);
	    if (strlen (cp2) < (unsigned) (fill - 2))
	    {
		cvs_output (cp2, 0);
		cvs_output ("\n", 1);
		break;
	    }
	    cp += fill - 2;
	    while (*cp != ' ' && cp > cp2)
		cp--;
	    if (cp == cp2)
	    {
		cvs_output (cp2, 0);
		cvs_output ("\n", 1);
		break;
	    }

	    *cp++ = '\0';
	    cvs_output (cp2, 0);
	    cvs_output ("\n", 1);
	}

	free_names(&moduleargc, moduleargv);
	/* FIXME-leak: here is where we would free s_h->modname, s_h->rest,
	   and if applicable, s_h->status.  Not exactly a memory leak,
	   in the sense that we are about to exit(), but may be worth
	   noting if we ever do a multithreaded server or something of
	   the sort.  */
    }
    /* FIXME-leak: as above, here is where we would free s_head.  */
}
@


1.3
log
@- a malicious server may send path names that translate out of the
local cvs tree on the client, enabling the server to overwrite files
on the client.

- a client may read files outside the repository using the -p flag
with the checkout command.

ok deraadt@@
@
text
@d1006 5
@


1.2
log
@Add a check for absolute pathnames; from cvs 1.11.10; deraadt@@ OK
@
text
@d173 7
@


1.2.2.1
log
@MFC:
Fix by otto@@

- a malicious server may send path names that translate out of the
local cvs tree on the client, enabling the server to overwrite files
on the client.

- a client may read files outside the repository using the -p flag
with the checkout command.

ok deraadt@@ otto@@
@
text
@a172 7
    /* Similarly for directories that attempt to step above the root of the
     * repository.
     */
    if (pathname_levels (mname) > 0)
	error (1, 0, "up-level in module reference (`..') invalid: `%s'.",
               mname);

@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 *    as specified in the README file that comes with the CVS 1.4 kit.
d23 1
d25 1
a25 1
#include "save-cwd.h"
d27 2
a28 4
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)modules.c 1.62 94/09/29 $";
USE(rcsid);
#endif
d30 8
d40 1
d42 3
d46 3
d65 2
a66 1
    char mfile[PATH_MAX];
d68 1
a68 1
    if (CVSroot == NULL)
d70 2
a71 4
	(void) fprintf (stderr, 
			"%s: must set the CVSROOT environment variable\n",
			program_name);
	error (1, 0, "or specify the '-d' option to %s", program_name);
d73 8
a80 2
    (void) sprintf (mfile, "%s/%s/%s", CVSroot, CVSROOTADM, CVSROOTADM_MODULES);
    return (dbm_open (mfile, O_RDONLY, 0666));
d100 2
a101 2
do_module (db, mname, m_type, msg, callback_proc, where,
	   shorten, local_specified, run_module_prog, extra_arg)
d106 1
a106 1
    int (*callback_proc) ();
d111 1
d120 4
a123 2
    char line[MAXLINELEN];
    char *xmodargv[MAXFILEPERDIR];
d125 3
a127 2
    char *value;
    char *zvalue;
d131 2
a132 2
    char xvalue[PATH_MAX];
    int modargc, alias = 0;
d136 1
d139 2
d142 18
a159 6
      {
	fprintf (stderr, "%c-> do_module (%s, %s, %s, %s)\n",
		 (server_active) ? 'S' : ' ',
                mname, msg, where ? where : "",
                extra_arg ? extra_arg : "");
      }
d162 10
a171 3
    /* remember where we start */
    if (save_cwd (&cwd))
	exit (1);
d177 1
a177 1
	return(err);
d181 1
a181 1
    strip_path (mname);
d201 4
a204 2
	/* null terminate the value  XXX - is this space ours? */
	val.dptr[val.dsize] = '\0';
d207 2
a208 6
	if ((cp = strchr (val.dptr, '#')) != NULL)
	{
	    do
		*cp-- = '\0';
	    while (isspace (*cp));
	}
d210 5
a214 6
	{
	    /* Always strip trailing spaces */
	    cp = strchr (val.dptr, '\0');
	    while (cp > val.dptr && isspace(*--cp))
		*cp = '\0';
	}
a215 1
	value = val.dptr;
d221 2
a222 2
	char file[PATH_MAX];
	char attic_file[PATH_MAX];
d224 1
d227 6
a232 2

	(void) sprintf (file, "%s/%s", CVSroot, mname);
d236 2
a237 2
	    (void) sprintf (attic_file, "%s/%s/%s/%s%s", CVSroot, mname,
			    CVSATTIC, acp + 1, RCSEXT);
d241 2
a242 2
	    (void) sprintf (attic_file, "%s/%s/%s%s", CVSroot, CVSATTIC,
			    mname, RCSEXT);
d246 4
a249 2
	    value = mname;
	    goto found;
d259 6
a264 6
		    char *slashp;

		    /* put the ' ' in a copy so we don't mess up the original */
		    value = strcpy (xvalue, mname);
		    slashp = strrchr (value, '/');
		    *slashp = ' ';
d276 4
a279 2
			value = strcpy (xvalue, ". ");
			(void) strcat (xvalue, mname + 1);
d284 4
a287 2
			value = strcpy (xvalue, ". ");
			(void) strcat (xvalue, mname);
d290 1
a290 1
		goto found;
d293 31
d345 4
a348 2
	    /* null terminate the value XXX - is this space ours? */
	    val.dptr[val.dsize] = '\0';
d351 8
a358 7
	    if ((cp2 = strchr (val.dptr, '#')) != NULL)
	    {
		do
		    *cp2-- = '\0';
		while (isspace (*cp2));
	    }
	    value = val.dptr;
d377 1
a377 3
    if (mwhere)
	free (mwhere);
    return (err);
d386 6
a391 4
    /* copy value to our own string since if we go recursive we'll be
       really screwed if we do another dbm lookup */
    zvalue = xstrdup (value);
    value = zvalue;
d399 3
a401 60
	if (cp != value)		/* strip whitespace if necessary */
	    while (isspace (*--cp))
		*cp = '\0';

	if (cp == value)
	{
	    /*
	     * we had nothing but special options, so skip arg
	     * parsing and regular stuff entirely
	     *
	     * If there were only special ones though, we must
	     * make the appropriate directory and cd to it
	     */
	    char *dir;

	    /* XXX - XXX - MAJOR HACK - DO NOT SHIP - this needs to
	       be !pipeout, but we don't know that here yet */
	    if (!run_module_prog)
		goto out;

	    dir = where ? where : mname;
	    /* XXX - think about making null repositories at each dir here
		     instead of just at the bottom */
	    make_directories (dir);
	    if (chdir (dir) < 0)
	    {
		error (0, errno, "cannot chdir to %s", dir);
		spec_opt = NULL;
		err++;
		goto out;
	    }
	    if (!isfile (CVSADM))
	    {
		char nullrepos[PATH_MAX];

		(void) sprintf (nullrepos, "%s/%s/%s", CVSroot,
				CVSROOTADM, CVSNULLREPOS);
		if (!isfile (nullrepos))
		    (void) CVS_MKDIR (nullrepos, 0777);
		if (!isdir (nullrepos))
		    error (1, 0, "there is no repository %s", nullrepos);

		Create_Admin (".", dir,
			      nullrepos, (char *) NULL, (char *) NULL);
		if (!noexec)
		{
		    FILE *fp;

		    fp = open_file (CVSADM_ENTSTAT, "w+");
		    if (fclose (fp) == EOF)
			error (1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
		    if (server_active)
			server_set_entstat (dir, nullrepos);
#endif
		}
	    }
	  out:
	    goto do_special;
	}
d418 3
a420 1
    (void) sprintf (line, "%s %s", "XXX", value);
d423 3
a425 1
    line2argv (&modargc, xmodargv, line);
d429 1
a429 1
    optind = 1;
d441 1
d444 4
a447 1
		checkin_prog = optarg;
d451 2
d454 4
a457 1
		checkout_prog = optarg;
d460 4
a463 1
		export_prog = optarg;
d466 4
a469 1
		tag_prog = optarg;
d472 4
a475 1
		update_prog = optarg;
d480 1
a480 1
		       key.dptr, val.dptr);
d482 1
a482 4
		if (mwhere)
		    free (mwhere);
		free (zvalue);
		return (err);
d487 1
a487 1
    if (modargc == 0)
d490 14
a503 4
	if (mwhere)
	    free (mwhere);
	free (zvalue);
	return (++err);
d520 1
a520 1
				  run_module_prog, extra_arg);
d522 10
a531 4
	if (mwhere)
	    free (mwhere);
	free (zvalue);
	return (err);
d535 30
a564 2
    err += callback_proc (&modargc, modargv, where, mwhere, mfile, shorten,
			  local_specified, mname, msg);
d566 19
a584 2
    /* clean up */
    free_names (&modargc, modargv);
d590 3
d597 34
d644 1
a644 1
	    while (isspace (*--cp));
d650 1
a650 1
	while (isspace (*spec_opt))
d659 1
a659 1
			      run_module_prog, extra_arg);
d663 8
d704 1
a704 1
	exit (1);
d706 1
d721 1
a721 1
	    char real_prog[PATH_MAX];
d725 1
d729 2
d736 9
a744 3
	    run_setup ("%s %s", prog, real_where);
	    if (extra_arg)
		run_arg (extra_arg);
d746 12
a757 6
	    if (!quiet)
	    {
		(void) printf ("%s %s: Executing '", program_name,
			       command_name);
		run_print (stdout);
		(void) printf ("'\n");
d759 1
a759 1
	    err += run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
d763 1
d765 2
d769 14
a782 1
    free (zvalue);
d784 2
d874 1
a874 1
    while (isspace (*cp))
d879 1
a879 1
	if (isspace (*cp))
d882 1
a882 1
	    while (isspace (*cp))
a894 1
	/* Minor kluge, but general enough to maintain */
d899 5
a903 2
		s_rec->status = (cp2 += 3);
		while (*cp2 != ' ')
d905 3
a907 1
		*cp2++ = '\0';
d944 1
a944 17
    char line[MAXLINELEN], *moduleargv[MAXFILEPERDIR];

#ifdef sun
#ifdef TIOCGSIZE
    struct ttysize ts;

    (void) ioctl (0, TIOCGSIZE, &ts);
    cols = ts.ts_cols;
#endif
#else
#ifdef TIOCGWINSZ
    struct winsize ws;

    (void) ioctl (0, TIOCGWINSZ, &ws);
    cols = ws.ws_col;
#endif
#endif
d959 2
d972 2
d975 4
a978 1
	(void) printf ("%-12s", s_h->modname);
d981 4
a984 3
	    (void) printf (" %-11s", s_h->status);
	    if (s_h->status != def_status)
		*(s_h->status + strlen (s_h->status)) = ' ';
d987 1
d990 2
a991 1
	line2argv (&moduleargc, moduleargv, line);
d995 1
a995 1
	optind = 1;
d1003 4
a1006 1
		    (void) printf (" -%c", c);
d1011 2
d1015 5
a1019 1
			(void) printf ("\n%*s", indent, "");
d1022 3
a1024 1
		    (void) printf (" -%c %s", c, optarg);
d1037 5
a1041 1
		(void) printf ("\n%*s", indent, "");
d1044 2
a1045 1
	    (void) printf (" %s", *argv);
d1048 1
a1048 1
	(void) printf ("\n");
d1053 5
a1057 1
	    (void) printf ("%*s # ", indent, "");
d1060 2
a1061 1
		(void) printf ("%s\n", cp2);
d1069 2
a1070 1
		(void) printf ("%s\n", cp2);
d1075 2
a1076 1
	    (void) printf ("%s\n", cp2);
d1078 7
d1086 1
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d87 1
a87 1
    CALLBACKPROC callback_proc;
d100 2
a101 3
    char *line;
    int modargc;
    int xmodargc;
a102 1
    char *xmodargv[MAXFILEPERDIR];
d109 1
a109 1
    int alias = 0;
d117 1
a117 2
	fprintf (stderr, "%s%c-> do_module (%s, %s, %s, %s)\n",
		 error_use_protocol ? "E " : "",
d119 2
a120 2
		 mname, msg, where ? where : "",
		 extra_arg ? extra_arg : "");
a350 3
		{
		    mode_t omask;
		    omask = umask (cvsumask);
a351 2
		    (void) umask (omask);
		}
a388 1
    line = xmalloc (strlen (value) + 10);
d392 1
a392 3
    line2argv (&xmodargc, xmodargv, line);
    free (line);
    modargc = xmodargc;
d474 2
a475 6
#if 0
    /* FIXME: I've fixed this so that the correct arguments are called, 
       but now this fails because there is code below this point that
       uses optarg values extracted from the arg vector. */
    free_names (&xmodargc, xmodargv);
#endif
d752 1
a752 2
    char *line;
    char *moduleargv[MAXFILEPERDIR];
a803 1
	line = xmalloc (strlen (s_h->modname) + strlen (s_h->rest) + 10);
a805 1
	free (line);
a868 2

	free_names(&moduleargc, moduleargv);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d24 6
a29 1
#include "savecwd.h"
d127 4
a304 4
    /* remember where we start */
    if (save_cwd (&cwd))
	exit (1);

a424 1
		break;
a444 1
		free_cwd (&cwd);
a455 1
	free_cwd (&cwd);
a477 1
	free_cwd (&cwd);
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a25 11

/* Defines related to the syntax of the modules file.  */

/* Options in modules file.  Note that it is OK to use GNU getopt features;
   we already are arranging to make sure we are using the getopt distributed
   with CVS.  */
#define	CVSMODULE_OPTS	"+ad:i:lo:e:s:t:u:"

/* Special delimiter.  */
#define CVSMODULE_SPEC	'&'

d298 1
a298 1
	exit (EXIT_FAILURE);
d564 1
a564 1
	exit (EXIT_FAILURE);
d826 1
a826 1
	optind = 0;
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d59 1
a59 1
    if (CVSroot_original == NULL)
d66 1
a66 2
    (void) sprintf (mfile, "%s/%s/%s", CVSroot_directory,
		    CVSROOTADM, CVSROOTADM_MODULES);
d124 3
a126 12
    {
	char *buf;

	/* We use cvs_outerr, rather than fprintf to stderr, because
	   this may be called by server code with error_use_protocol
	   set.  */
	buf = xmalloc (100
		       + strlen (mname)
		       + strlen (msg)
		       + (where ? strlen (where) : 0)
		       + (extra_arg ? strlen (extra_arg) : 0));
	sprintf (buf, "%c-> do_module (%s, %s, %s, %s)\n",
d130 1
a130 3
	cvs_outerr (buf, 0);
	free (buf);
    }
d191 1
a191 1
	(void) sprintf (file, "%s/%s", CVSroot_directory, mname);
d195 2
a196 2
	    (void) sprintf (attic_file, "%s/%s/%s/%s%s", CVSroot_directory,
			    mname, CVSATTIC, acp + 1, RCSEXT);
d200 2
a201 2
	    (void) sprintf (attic_file, "%s/%s/%s%s", CVSroot_directory,
			    CVSATTIC, mname, RCSEXT);
d346 1
a346 1
	    if ( CVS_CHDIR (dir) < 0)
d357 1
a357 1
		(void) sprintf (nullrepos, "%s/%s/%s", CVSroot_directory,
a594 1
	    char *expanded_path;
d603 5
a607 3
	    /* XXX can we determine the line number for this entry??? */
	    expanded_path = expand_path (prog, "modules", 0);
	    if (expanded_path != NULL)
d609 4
a612 14
		run_setup ("%s %s", expanded_path, real_where);

		if (extra_arg)
		    run_arg (extra_arg);

		if (!quiet)
		{
		    (void) printf ("%s %s: Executing '", program_name,
				   command_name);
		    run_print (stdout);
		    (void) printf ("'\n");
		}
		err += run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
		free (expanded_path);
d614 1
d779 16
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d61 4
a64 2
	error (0, 0, "must set the CVSROOT environment variable");
	error (1, 0, "or specify the '-d' global option");
a121 1
    int nonalias_opt = 0;
a123 2
    int restore_server_dir = 0;
    char *server_dir_to_restore;
d153 1
a153 1
    strip_trailing_slashes (mname);
d321 1
a321 1
	error_exit ();
a433 1
		nonalias_opt = 1;
a438 1
		nonalias_opt = 1;
a441 1
		nonalias_opt = 1;
a444 1
		nonalias_opt = 1;
a447 1
		nonalias_opt = 1;
a450 1
		nonalias_opt = 1;
a453 1
		nonalias_opt = 1;
a479 11
    if (alias && nonalias_opt)
    {
	/* The documentation has never said it is legal to specify
	   -a along with another option.  And I believe that in the past
	   CVS has ignored the options other than -a, more or less, in this
	   situation.  */
	error (0, 0, "\
-a cannot be specified in the modules file along with other options");
	return ++err;
    }

a521 34
#ifdef SERVER_SUPPORT
    /* We want to check out into the directory named by the module.
       So we set a global variable which tells the server to glom that
       directory name onto the front.  A cleaner approach would be some
       way of passing it down to the recursive call, through the
       callback_proc, to start_recursion, and then into the update_dir in
       the struct file_info.  That way the "Updating foo" message could
       print the actual directory we are checking out into.

       For local CVS, this is handled by the chdir call above
       (directly or via the callback_proc).  */
    if (server_active && spec_opt != NULL)
    {
	char *change_to;

	change_to = where ? where : (mwhere ? mwhere : mname);
	server_dir_to_restore = server_dir;
	restore_server_dir = 1;
	server_dir =
	    xmalloc ((server_dir_to_restore != NULL
		      ? strlen (server_dir_to_restore)
		      : 0)
		     + strlen (change_to)
		     + 5);
	server_dir[0] = '\0';
	if (server_dir_to_restore != NULL)
	{
	    strcat (server_dir, server_dir_to_restore);
	    strcat (server_dir, "/");
	}
	strcat (server_dir, change_to);
    }
#endif

a553 8
#ifdef SERVER_SUPPORT
    if (server_active && restore_server_dir)
    {
	free (server_dir);
	server_dir = server_dir_to_restore;
    }
#endif

d587 1
a587 1
	error_exit ();
d627 2
a628 4
		    cvs_output (program_name, 0);
		    cvs_output (" ", 1);
		    cvs_output (command_name, 0);
		    cvs_output (": Executing '", 0);
d630 1
a630 1
		    cvs_output ("'\n", 0);
a823 3
	line = xmalloc (strlen (s_h->modname) + strlen (s_h->rest)
			+ strlen (status ? s_h->status : "") + 15);

d825 1
a825 2
	sprintf (line, "%-12s", s_h->modname);
	cvs_output (line, 0);
d828 1
a828 2
	    sprintf (line, " %-11s", s_h->status);
	    cvs_output (line, 0);
d834 1
d849 1
a849 4
		    char buf[5];

		    sprintf (buf, " -%c", c);
		    cvs_output (buf, 0);
a853 2
		    char buf[10];

d856 1
a856 5
			int j;

			cvs_output ("\n", 1);
			for (j = 0; j < indent; ++j)
			    cvs_output (" ", 1);
d859 1
a859 3
		    sprintf (buf, " -%c ", c);
		    cvs_output (buf, 0);
		    cvs_output (optarg, 0);
d872 1
a872 5
		int j;

		cvs_output ("\n", 1);
		for (j = 0; j < indent; ++j)
		    cvs_output (" ", 1);
d875 1
a875 2
	    cvs_output (" ", 1);
	    cvs_output (*argv, 0);
d878 1
a878 1
	cvs_output ("\n", 1);
d883 1
a883 5
	    int j;

	    for (j = 0; j < indent; ++j)
		cvs_output (" ", 1);
	    cvs_output (" # ", 0);
d886 1
a886 2
		cvs_output (cp2, 0);
		cvs_output ("\n", 1);
d894 1
a894 2
		cvs_output (cp2, 0);
		cvs_output ("\n", 1);
d899 1
a899 2
	    cvs_output (cp2, 0);
	    cvs_output ("\n", 1);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d57 1
a57 2
    char *mfile;
    DBM *retval;
a63 2
    mfile = xmalloc (strlen (CVSroot_directory) + sizeof (CVSROOTADM)
		     + sizeof (CVSROOTADM_MODULES) + 20);
d66 1
a66 3
    retval = dbm_open (mfile, O_RDONLY, 0666);
    free (mfile);
    return retval;
a104 1
    int cwd_saved = 0;
d109 1
a109 1
    char **xmodargv;
d111 1
a111 1
    char *zvalue = NULL;
d115 1
a115 1
    char *xvalue = NULL;
d150 1
a150 1
	goto do_module_return;
d198 2
a199 2
	char *file;
	char *attic_file;
a200 1
	int is_found = 0;
d203 1
a203 1
	file = xmalloc (strlen (CVSroot_directory) + strlen (mname) + 10);
a204 2
	attic_file = xmalloc (strlen (CVSroot_directory) + strlen (mname)
			      + sizeof (CVSATTIC) + sizeof (RCSEXT) + 15);
d219 1
a219 1
	    is_found = 1;
d231 1
a231 3
		    /* put the ' ' in a copy so we don't mess up the
		       original */
		    xvalue = xmalloc (strlen (mname) + 2);
a245 1
			xvalue = xmalloc (strlen (mname) + 10);
a251 1
			xvalue = xmalloc (strlen (mname) + 10);
d256 1
a256 1
		is_found = 1;
a258 5
	free (attic_file);
	free (file);

	if (is_found)
	    goto found;
d309 3
a311 1
    goto do_module_return;
a322 1
    cwd_saved = 1;
d368 1
a368 1
		char *nullrepos;
a369 4
		nullrepos = xmalloc (strlen (CVSroot_directory)
				     + sizeof (CVSROOTADM)
				     + sizeof (CVSNULLREPOS)
				     + 10);
a395 1
		free (nullrepos);
d420 1
a420 1
    line2argv (&xmodargc, &xmodargv, line);
d469 5
a473 1
		goto do_module_return;
d481 5
a485 2
	++err;
	goto do_module_return;
d496 1
a496 2
	++err;
	goto do_module_return;
d515 5
a519 1
	goto do_module_return;
a649 1
    cwd_saved = 0;
d664 1
a664 1
	    char *real_prog = NULL;
a671 2
		real_prog = xmalloc (strlen (real_where) + strlen (prog)
				     + 10);
a697 1
	    free (real_prog);
a700 1
 do_module_return:
d704 1
a704 4
    if (cwd_saved)
	free_cwd (&cwd);
    if (zvalue != NULL)
	free (zvalue);
a705 2
    if (xvalue != NULL)
	free (xvalue);
d860 2
a861 1
    char **moduleargv;
d887 2
a888 1
	char *line;
a890 1
	line = xmalloc (strlen (s_h->modname) + 15);
a892 1
	free (line);
a894 1
	    line = xmalloc (strlen (s_h->status) + 15);
a898 1
	    free (line);
a900 1
	line = xmalloc (strlen (s_h->modname) + strlen (s_h->rest) + 15);
d903 1
a903 1
	line2argv (&moduleargc, &moduleargv, line);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d404 1
a404 1
			      nullrepos, (char *) NULL, (char *) NULL, 0);
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d448 1
a448 1
    optind = 0;
d464 1
a464 3
		if (checkin_prog)
		    free (checkin_prog);
		checkin_prog = xstrdup (optarg);
d472 1
a472 3
		if (checkout_prog)
		    free (checkout_prog);
		checkout_prog = xstrdup (optarg);
d476 1
a476 3
		if (export_prog)
		    free (export_prog);
		export_prog = xstrdup (optarg);
d480 1
a480 3
		if (tag_prog)
		    free (tag_prog);
		tag_prog = xstrdup (optarg);
d484 1
a484 3
		if (update_prog)
		    free (update_prog);
		update_prog = xstrdup (optarg);
d538 4
d543 1
a720 10
    if (checkin_prog)
	free (checkin_prog);
    if (checkout_prog)
	free (checkout_prog);
    if (export_prog)
	free (export_prog);
    if (tag_prog)
	free (tag_prog);
    if (update_prog)
	free (update_prog);
a895 2

    close_module (db);
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 *    as specified in the README file that comes with the CVS source distribution.
a38 1
    /* Name of the module, malloc'd.  */
a39 3
    /* If Status variable is set, this is either def_status or the malloc'd
       name of the status.  If Status is not set, the field is left
       uninitialized.  */
a40 3
    /* Pointer to a malloc'd array which contains (1) the raw contents
       of the options and arguments, excluding comments, (2) a '\0',
       and (3) the storage for the "comment" field.  */
d130 1
a130 1
    char *server_dir_to_restore = NULL;
a270 5
	    else
	    {
		/* This initialization suppresses a warning from gcc -Wall.  */
	        value = NULL;
	    }
d387 15
a401 1
		nullrepos = emptydir_name ();
d404 1
a404 1
			      nullrepos, (char *) NULL, (char *) NULL, 0, 0);
d442 1
a442 1
    line2argv (&xmodargc, &xmodargv, line, " \t");
a543 9
    if (mfile != NULL && modargc > 1)
    {
	error (0, 0, "\
module `%s' is a request for a file in a module which is not a directory",
	       mname);
	++err;
	goto do_module_return;
    }

d701 1
a701 2
		run_setup (expanded_path);
		run_arg (real_where);
d852 1
d857 2
a858 5
		char *status_start;

		cp2 += 3;
		status_start = cp2;
		while (*cp2 != ' ' && *cp2 != '\0')
d860 1
a860 3
		s_rec->status = xmalloc (cp2 - status_start + 1);
		strncpy (s_rec->status, status_start, cp2 - status_start);
		s_rec->status[cp2 - status_start] = '\0';
d937 2
d945 1
a945 1
	line2argv (&moduleargc, &moduleargv, line, " \t");
a1034 5
	/* FIXME-leak: here is where we would free s_h->modname, s_h->rest,
	   and if applicable, s_h->status.  Not exactly a memory leak,
	   in the sense that we are about to exit(), but may be worth
	   noting if we ever do a multithreaded server or something of
	   the sort.  */
a1035 1
    /* FIXME-leak: as above, here is where we would free s_head.  */
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d150 2
a151 2
	sprintf (buf, "%s-> do_module (%s, %s, %s, %s)\n",
		 CLIENT_SERVER_STR,
d195 1
a195 1
	    while (isspace ((unsigned char) *cp));
d201 1
a201 1
	    while (cp > val.dptr && isspace ((unsigned char) *--cp))
d318 1
a318 1
		while (isspace ((unsigned char) *cp2));
d365 1
a365 1
	    while (isspace ((unsigned char) *--cp))
d612 1
a612 1
	    while (isspace ((unsigned char) *--cp));
d618 1
a618 1
	while (isspace ((unsigned char) *spec_opt))
d839 1
a839 1
    while (isspace ((unsigned char) *cp))
d844 1
a844 1
	if (isspace ((unsigned char) *cp))
d847 1
a847 1
	    while (isspace ((unsigned char) *cp))
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@a22 1
#include <assert.h>
d123 1
a123 2
    /* Found entry from modules file, including options and such.  */
    char *value = NULL;
d234 1
a234 3
	    modargv = xmalloc (sizeof (*modargv));
	    modargv[0] = xstrdup (mname);
	    modargc = 1;
d245 8
a252 6
		    modargv = xmalloc (2 * sizeof (*modargv));
		    modargv[0] = xmalloc (strlen (mname) + 2);
		    strncpy (modargv[0], mname, cp - mname);
		    modargv[0][cp - mname] = '\0';
		    modargv[1] = xstrdup (cp + 1);
		    modargc = 2;
d264 3
a266 4
			modargv = xmalloc (2 * sizeof (*modargv));
			modargv[0] = xstrdup (".");
			modargv[1] = xstrdup (mname + 1);
			modargc = 2;
d271 3
a273 4
			modargv = xmalloc (2 * sizeof (*modargv));
			modargv[0] = xstrdup (".");
			modargv[1] = xstrdup (mname);
			modargc = 2;
d278 5
d288 1
a288 27
	{
	    assert (value == NULL);

	    /* OK, we have now set up modargv with the actual
	       file/directory we want to work on.  We duplicate a
	       small amount of code here because the vast majority of
	       the code after the "found" label does not pertain to
	       the case where we found a file/directory rather than
	       finding an entry in the modules file.  */
	    if (save_cwd (&cwd))
		error_exit ();
	    cwd_saved = 1;

	    err += callback_proc (&modargc, modargv, where, mwhere, mfile,
				  shorten,
				  local_specified, mname, msg);

	    free_names (&modargc, modargv);

	    /* cd back to where we started.  */
	    if (restore_cwd (&cwd, NULL))
		error_exit ();
	    free_cwd (&cwd);
	    cwd_saved = 0;

	    goto do_module_return;
	}
a354 1
    assert (value != NULL);
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@d123 1
a123 1
    char **xmodargv = NULL;
d126 1
d189 2
a190 4
	/* copy and null terminate the value */
	value = xmalloc (val.dsize + 1);
	memcpy (value, val.dptr, val.dsize);
	value[val.dsize] = '\0';
d193 6
a198 2
	if ((cp = strchr (value, '#')) != NULL)
	    *cp = '\0';
d200 6
a205 5
	    cp = value + val.dsize;

	/* Always strip trailing spaces */
	while (cp > value && isspace ((unsigned char) *--cp))
	    *cp = '\0';
d207 1
d300 1
a300 1
	    err += callback_proc (modargc, modargv, where, mwhere, mfile,
d335 2
a336 4
	    /* copy and null terminate the value */
	    value = xmalloc (val.dsize + 1);
	    memcpy (value, val.dptr, val.dsize);
	    value[val.dsize] = '\0';
d339 7
a345 8
	    if ((cp2 = strchr (value, '#')) != NULL)
		*cp2 = '\0';
	    else
		cp2 = value + val.dsize;

	    /* Always strip trailing spaces */
	    while (cp2 > value  &&  isspace ((unsigned char) *--cp2))
		*cp2 = '\0';
d378 2
d381 2
d390 56
a445 3
	/* strip whitespace if necessary */
	while (cp > value  &&  isspace ((unsigned char) *--cp))
	    *cp = '\0';
d463 1
a463 2
    strcpy(line, "XXX ");
    strcpy(line + 4, value);
d481 1
a484 1
		nonalias_opt = 1;
d487 1
a490 1
		nonalias_opt = 1;
d493 1
a494 1
		nonalias_opt = 1;
d497 1
a500 1
		nonalias_opt = 1;
d503 1
a506 1
		nonalias_opt = 1;
d509 1
a512 1
		nonalias_opt = 1;
d515 1
a518 1
		nonalias_opt = 1;
d523 1
a523 1
		       key.dptr, value);
d530 1
a530 1
    if (modargc == 0  &&  spec_opt == NULL)
d578 2
a579 17
    if (modargc > 0)
    {
	err += callback_proc (modargc, modargv, where, mwhere, mfile, shorten,
			      local_specified, mname, msg);
    }
    else
    {
	/*
	 * we had nothing but special options, so we must
	 * make the appropriate directory and cd to it
	 */
	char *dir;

	/* XXX - XXX - MAJOR HACK - DO NOT SHIP - this needs to
	   be !pipeout, but we don't know that here yet */
	if (!run_module_prog)
	    goto do_special;
d581 1
a581 34
	dir = where ? where : (mwhere ? mwhere : mname);
	/* XXX - think about making null repositories at each dir here
		 instead of just at the bottom */
	make_directories (dir);
	if ( CVS_CHDIR (dir) < 0)
	{
	    error (0, errno, "cannot chdir to %s", dir);
	    spec_opt = NULL;
	    err++;
	    goto do_special;
	}
	if (!isfile (CVSADM))
	{
	    char *nullrepos;

	    nullrepos = emptydir_name ();

	    Create_Admin (".", dir,
			  nullrepos, (char *) NULL, (char *) NULL, 0, 0, 1);
	    if (!noexec)
	    {
		FILE *fp;

		fp = open_file (CVSADM_ENTSTAT, "w+");
		if (fclose (fp) == EOF)
		    error (1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
		if (server_active)
		    server_set_entstat (dir, nullrepos);
#endif
	    }
	    free (nullrepos);
	}
    }
a586 3
    free_names (&xmodargc, xmodargv);
    xmodargv = NULL;

d638 1
a638 1
	    while (cp > spec_opt  &&  isspace ((unsigned char) *--cp));
a747 1
		    cvs_flushout ();
a757 2
    if (xmodargv != NULL)
	free_names (&xmodargc, xmodargv);
d772 2
a773 2
    if (value != NULL)
	free (value);
@


1.1.1.14
log
@Latest from Cyclic Software
@
text
@d68 1
a68 1
    if (current_parsed_root == NULL)
d73 3
a75 4
    mfile = xmalloc (strlen (current_parsed_root->directory)
		     + sizeof (CVSROOTADM)
		     + sizeof (CVSROOTADM_MODULES) + 3);
    (void) sprintf (mfile, "%s/%s/%s", current_parsed_root->directory,
d99 2
a100 2
do_module (db, mname, m_type, msg, callback_proc, where, shorten,
	   local_specified, run_module_prog, build_dirs, extra_arg)
a109 1
    int build_dirs;
d214 4
a217 6
	file = xmalloc (strlen (current_parsed_root->directory)
			+ strlen (mname) + sizeof(RCSEXT) + 2);
	(void) sprintf (file, "%s/%s", current_parsed_root->directory, mname);
	attic_file = xmalloc (strlen (current_parsed_root->directory)
			      + strlen (mname)
			      + sizeof (CVSATTIC) + sizeof (RCSEXT) + 3);
d221 1
a221 1
	    (void) sprintf (attic_file, "%s/%s/%s/%s%s", current_parsed_root->directory,
d226 1
a226 1
	    (void) sprintf (attic_file, "%s/%s/%s%s", current_parsed_root->directory,
d403 1
a403 1
    line = xmalloc (strlen (value) + 5);
d505 1
a505 1
				  run_module_prog, build_dirs, extra_arg);
d533 3
a535 1
	if (!build_dirs)
d646 1
a646 1
			      run_module_prog, build_dirs, extra_arg);
@


1.1.1.14.8.1
log
@MFC:
Fix by millert@@

Add a check for absolute pathnames; from cvs 1.11.10

ok deraadt@@
@
text
@a161 11
    /* Don't process absolute directories.  Anything else could be a security
     * problem.  Before this check was put in place:
     *
     *   $ cvs -d:fork:/cvsroot co /foo
     *   cvs server: warning: cannot make directory CVS in /: Permission denied
     *   cvs [server aborted]: cannot make directory /foo: Permission denied
     *   $
     */
    if (isabsolute (mname))
	error (1, 0, "Absolute module reference invalid: `%s'", mname);

@


1.1.1.14.8.2
log
@MFC:
Fix by otto@@

- a malicious server may send path names that translate out of the
local cvs tree on the client, enabling the server to overwrite files
on the client.

- a client may read files outside the repository using the -p flag
with the checkout command.

ok deraadt@@ otto@@
@
text
@a172 7
    /* Similarly for directories that attempt to step above the root of the
     * repository.
     */
    if (pathname_levels (mname) > 0)
	error (1, 0, "up-level in module reference (`..') invalid: `%s'.",
               mname);

@


1.1.1.14.10.1
log
@MFC:
Fix by millert@@

Add a check for absolute pathnames; from cvs 1.11.10

ok deraadt@@
@
text
@a161 11
    /* Don't process absolute directories.  Anything else could be a security
     * problem.  Before this check was put in place:
     *
     *   $ cvs -d:fork:/cvsroot co /foo
     *   cvs server: warning: cannot make directory CVS in /: Permission denied
     *   cvs [server aborted]: cannot make directory /foo: Permission denied
     *   $
     */
    if (isabsolute (mname))
	error (1, 0, "Absolute module reference invalid: `%s'", mname);

@


1.1.1.14.10.2
log
@MFC:
Fix by otto@@

- a malicious server may send path names that translate out of the
local cvs tree on the client, enabling the server to overwrite files
on the client.

- a client may read files outside the repository using the -p flag
with the checkout command.

ok deraadt@@ otto@@
@
text
@a172 7
    /* Similarly for directories that attempt to step above the root of the
     * repository.
     */
    if (pathname_levels (mname) > 0)
	error (1, 0, "up-level in module reference (`..') invalid: `%s'.",
               mname);

@


