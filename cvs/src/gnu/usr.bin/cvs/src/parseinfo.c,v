head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.20
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.22
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.18
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.14
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.16
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.8
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.12
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.10
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.16
	OPENBSD_5_0:1.9.0.14
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.12
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.10
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.6
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.8
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.22
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.20
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.18
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.16
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.14
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.12
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.10
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	cvs-1-11-1p1:1.1.1.12
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	cvs-1-11:1.1.1.11
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	cvs-1-10-7:1.1.1.10
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	cvs-1-10-5:1.1.1.10
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	cvs-1-10:1.1.1.9
	cvs-1-9-28:1.1.1.8
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	cvs-1-9-26:1.1.1.8
	cvs-1-9-24:1.1.1.7
	OPENBSD_2_2:1.1.1.6.0.2
	OPENBSD_2_2_BASE:1.1.1.6
	cvs-1-9-10:1.1.1.6
	OPENBSD_2_1:1.1.1.5.0.2
	OPENBSD_2_1_BASE:1.1.1.5
	cvs-1-9-8:1.1.1.5
	cvs-1-9-6:1.1.1.5
	cvs-1-9-4:1.1.1.5
	cvs-1-9-2:1.1.1.4
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.11.00.52.43;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.23.20.00.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.10.19.31.35;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	99.02.28.21.57.57;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	98.08.22.21.04.32;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	98.03.12.07.22.36;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	98.02.22.09.27.24;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.18;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.06;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.35.45;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.03.18.01.56.17;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.06.28.03.28.51;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	98.02.22.08.21.25;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	98.03.12.06.59.00;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.08.22.20.53.35;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.02.28.21.33.14;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2001.02.10.18.57.44;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.10
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 */

#include "cvs.h"
#include "getline.h"
#include <assert.h>

extern char *logHistory;

/*
 * Parse the INFOFILE file for the specified REPOSITORY.  Invoke CALLPROC for
 * the first line in the file that matches the REPOSITORY, or if ALL != 0, any lines
 * matching "ALL", or if no lines match, the last line matching "DEFAULT".
 *
 * Return 0 for success, -1 if there was not an INFOFILE, and >0 for failure.
 */
int
Parse_Info (infofile, repository, callproc, all)
    char *infofile;
    char *repository;
    CALLPROC callproc;
    int all;
{
    int err = 0;
    FILE *fp_info;
    char *infopath;
    char *line = NULL;
    size_t line_allocated = 0;
    char *default_value = NULL;
    char *expanded_value= NULL;
    int callback_done, line_number;
    char *cp, *exp, *value, *srepos, bad;
    const char *regex_err;

    if (current_parsed_root == NULL)
    {
	/* XXX - should be error maybe? */
	error (0, 0, "CVSROOT variable not set");
	return (1);
    }

    /* find the info file and open it */
    infopath = xmalloc (strlen (current_parsed_root->directory)
			+ strlen (infofile)
			+ sizeof (CVSROOTADM)
			+ 3);
    (void) sprintf (infopath, "%s/%s/%s", current_parsed_root->directory,
		    CVSROOTADM, infofile);
    fp_info = CVS_FOPEN (infopath, "r");
    if (fp_info == NULL)
    {
	/* If no file, don't do anything special.  */
	if (!existence_error (errno))
	    error (0, errno, "cannot open %s", infopath);
	free (infopath);
	return 0;
    }

    /* strip off the CVSROOT if repository was absolute */
    srepos = Short_Repository (repository);

    if (trace)
	(void) fprintf (stderr, " -> ParseInfo(%s, %s, %s)\n",
			infopath, srepos, all ? "ALL" : "not ALL");

    /* search the info file for lines that match */
    callback_done = line_number = 0;
    while (get_line (&line, &line_allocated, fp_info) >= 0)
    {
	line_number++;

	/* skip lines starting with # */
	if (line[0] == '#')
	    continue;

	/* skip whitespace at beginning of line */
	for (cp = line; *cp && isspace ((unsigned char) *cp); cp++)
	    ;

	/* if *cp is null, the whole line was blank */
	if (*cp == '\0')
	    continue;

	/* the regular expression is everything up to the first space */
	for (exp = cp; *cp && !isspace ((unsigned char) *cp); cp++)
	    ;
	if (*cp != '\0')
	    *cp++ = '\0';

	/* skip whitespace up to the start of the matching value */
	while (*cp && isspace ((unsigned char) *cp))
	    cp++;

	/* no value to match with the regular expression is an error */
	if (*cp == '\0')
	{
	    error (0, 0, "syntax error at line %d file %s; ignored",
		   line_number, infofile);
	    continue;
	}
	value = cp;

	/* strip the newline off the end of the value */
	if ((cp = strrchr (value, '\n')) != NULL)
	    *cp = '\0';

	if (expanded_value != NULL)
	    free (expanded_value);
	expanded_value = expand_path (value, infofile, line_number);

	/*
	 * At this point, exp points to the regular expression, and value
	 * points to the value to call the callback routine with.  Evaluate
	 * the regular expression against srepos and callback with the value
	 * if it matches.
	 */

	/* save the default value so we have it later if we need it */
	if (strcmp (exp, "DEFAULT") == 0)
	{
	    /* Is it OK to silently ignore all but the last DEFAULT
               expression?  */
	    if (default_value != NULL && default_value != &bad)
		free (default_value);
	    default_value = (expanded_value != NULL ?
			     xstrdup (expanded_value) : &bad);
	    continue;
	}

	/*
	 * For a regular expression of "ALL", do the callback always We may
	 * execute lots of ALL callbacks in addition to *one* regular matching
	 * callback or default
	 */
	if (strcmp (exp, "ALL") == 0)
	{
	    if (!all)
		error(0, 0, "Keyword `ALL' is ignored at line %d in %s file",
		      line_number, infofile);
	    else if (expanded_value != NULL)
		err += callproc (repository, expanded_value);
	    else
		err++;
	    continue;
	}

	if (callback_done)
	    /* only first matching, plus "ALL"'s */
	    continue;

	/* see if the repository matched this regular expression */
	if ((regex_err = re_comp (exp)) != NULL)
	{
	    error (0, 0, "bad regular expression at line %d file %s: %s",
		   line_number, infofile, regex_err);
	    continue;
	}
	if (re_exec (srepos) == 0)
	    continue;				/* no match */

	/* it did, so do the callback and note that we did one */
	if (expanded_value != NULL)
	    err += callproc (repository, expanded_value);
	else
	    err++;
	callback_done = 1;
    }
    if (ferror (fp_info))
	error (0, errno, "cannot read %s", infopath);
    if (fclose (fp_info) < 0)
	error (0, errno, "cannot close %s", infopath);

    /* if we fell through and didn't callback at all, do the default */
    if (callback_done == 0 && default_value != NULL)
    {
	if (default_value != &bad)
	    err += callproc (repository, default_value);
	else
	    err++;
    }

    /* free up space if necessary */
    if (default_value != NULL && default_value != &bad)
	free (default_value);
    if (expanded_value != NULL)
	free (expanded_value);
    free (infopath);
    if (line != NULL)
	free (line);

    return (err);
}


/* Parse the CVS config file.  The syntax right now is a bit ad hoc
   but tries to draw on the best or more common features of the other
   *info files and various unix (or non-unix) config file syntaxes.
   Lines starting with # are comments.  Settings are lines of the form
   KEYWORD=VALUE.  There is currently no way to have a multi-line
   VALUE (would be nice if there was, probably).

   CVSROOT is the $CVSROOT directory (current_parsed_root->directory might not be
   set yet).

   Returns 0 for success, negative value for failure.  Call
   error(0, ...) on errors in addition to the return value.  */
int
parse_config (cvsroot)
    char *cvsroot;
{
    char *infopath;
    FILE *fp_info;
    char *line = NULL;
    size_t line_allocated = 0;
    size_t len;
    char *p;
    /* FIXME-reentrancy: If we do a multi-threaded server, this would need
       to go to the per-connection data structures.  */
    static int parsed = 0;

    /* Authentication code and serve_root might both want to call us.
       Let this happen smoothly.  */
    if (parsed)
	return 0;
    parsed = 1;

    infopath = malloc (strlen (cvsroot)
			+ sizeof (CVSROOTADM_CONFIG)
			+ sizeof (CVSROOTADM)
			+ 10);
    if (infopath == NULL)
    {
	error (0, 0, "out of memory; cannot allocate infopath");
	goto error_return;
    }

    strcpy (infopath, cvsroot);
    strcat (infopath, "/");
    strcat (infopath, CVSROOTADM);
    strcat (infopath, "/");
    strcat (infopath, CVSROOTADM_CONFIG);

    fp_info = CVS_FOPEN (infopath, "r");
    if (fp_info == NULL)
    {
	/* If no file, don't do anything special.  */
	if (!existence_error (errno))
	{
	    /* Just a warning message; doesn't affect return
	       value, currently at least.  */
	    error (0, errno, "cannot open %s", infopath);
	}
	free (infopath);
	return 0;
    }

    while (get_line (&line, &line_allocated, fp_info) >= 0)
    {
	/* Skip comments.  */
	if (line[0] == '#')
	    continue;

	/* At least for the moment we don't skip whitespace at the start
	   of the line.  Too picky?  Maybe.  But being insufficiently
	   picky leads to all sorts of confusion, and it is a lot easier
	   to start out picky and relax it than the other way around.

	   Is there any kind of written standard for the syntax of this
	   sort of config file?  Anywhere in POSIX for example (I guess
	   makefiles are sort of close)?  Red Hat Linux has a bunch of
	   these too (with some GUI tools which edit them)...

	   Along the same lines, we might want a table of keywords,
	   with various types (boolean, string, &c), as a mechanism
	   for making sure the syntax is consistent.  Any good examples
	   to follow there (Apache?)?  */

	/* Strip the training newline.  There will be one unless we
	   read a partial line without a newline, and then got end of
	   file (or error?).  */

	len = strlen (line) - 1;
	if (line[len] == '\n')
	    line[len] = '\0';

	/* Skip blank lines.  */
	if (line[0] == '\0')
	    continue;

	/* The first '=' separates keyword from value.  */
	p = strchr (line, '=');
	if (p == NULL)
	{
	    /* Probably should be printing line number.  */
	    error (0, 0, "syntax error in %s: line '%s' is missing '='",
		   infopath, line);
	    goto error_return;
	}

	*p++ = '\0';

	if (strcmp (line, "RCSBIN") == 0)
	{
	    /* This option used to specify the directory for RCS
	       executables.  But since we don't run them any more,
	       this is a noop.  Silently ignore it so that a
	       repository can work with either new or old CVS.  */
	    ;
	}
	else if (strcmp (line, "SystemAuth") == 0)
	{
	    if (strcmp (p, "no") == 0)
#ifdef AUTH_SERVER_SUPPORT
		system_auth = 0;
#else
		/* Still parse the syntax but ignore the
		   option.  That way the same config file can
		   be used for local and server.  */
		;
#endif
	    else if (strcmp (p, "yes") == 0)
#ifdef AUTH_SERVER_SUPPORT
		system_auth = 1;
#else
		;
#endif
	    else
	    {
		error (0, 0, "unrecognized value '%s' for SystemAuth", p);
		goto error_return;
	    }
	}
	else if (strcmp (line, "tag") == 0) {
	    RCS_citag = strdup(p);
	    if (RCS_citag == NULL) {
		error (0, 0, "%s: no memory for local tag '%s'",
		       infopath, p);
		goto error_return;
	    }
	}
	else if (strcmp (line, "umask") == 0) {
	    cvsumask = (mode_t)(strtol(p, NULL, 8) & 0777);
	}
	else if (strcmp (line, "DisableMdocdate") == 0) {
	    if (strcmp (p, "no") == 0)
		disable_mdocdate = 0;
	    else if (strcmp (p, "yes") == 0)
		disable_mdocdate = 1;
	    else 
	    {
		error (0, 0, "unrecognized value '%s' for DisableMdocdate", p);
		goto error_return;
	    }
	}
	else if (strcmp (line, "dlimit") == 0) {
#ifdef BSD
#include <sys/resource.h>
	    struct rlimit rl;

	    if (getrlimit(RLIMIT_DATA, &rl) != -1) {
		rl.rlim_cur = atoi(p);
		rl.rlim_cur *= 1024;

		(void) setrlimit(RLIMIT_DATA, &rl);
	    }
#endif /* BSD */
	}
	else if (strcmp (line, "DisableXProg") == 0)
	{
	    if (strcmp (p, "no") == 0)
#ifdef AUTH_SERVER_SUPPORT
		disable_x_prog = 0;
#else
		/* Still parse the syntax but ignore the
		   option.  That way the same config file can
		   be used for local and server.  */
		;
#endif
	    else if (strcmp (p, "yes") == 0)
#ifdef AUTH_SERVER_SUPPORT
		disable_x_prog = 1;
#else
		;
#endif
	    else
	    {
		error (0, 0, "unrecognized value '%s' for DisableXProg", p);
		goto error_return;
	    }
	}
	else if (strcmp (line, "PreservePermissions") == 0)
	{
	    if (strcmp (p, "no") == 0)
		preserve_perms = 0;
	    else if (strcmp (p, "yes") == 0)
	    {
#ifdef PRESERVE_PERMISSIONS_SUPPORT
		preserve_perms = 1;
#else
		error (0, 0, "\
warning: this CVS does not support PreservePermissions");
#endif
	    }
	    else
	    {
		error (0, 0, "unrecognized value '%s' for PreservePermissions",
		       p);
		goto error_return;
	    }
	}
	else if (strcmp (line, "TopLevelAdmin") == 0)
	{
	    if (strcmp (p, "no") == 0)
		top_level_admin = 0;
	    else if (strcmp (p, "yes") == 0)
		top_level_admin = 1;
	    else
	    {
		error (0, 0, "unrecognized value '%s' for TopLevelAdmin", p);
		goto error_return;
	    }
	}
	else if (strcmp (line, "LockDir") == 0)
	{
	    if (lock_dir != NULL)
		free (lock_dir);
	    lock_dir = xstrdup (p);
	    /* Could try some validity checking, like whether we can
	       opendir it or something, but I don't see any particular
	       reason to do that now rather than waiting until lock.c.  */
	}
	else if (strcmp (line, "LogHistory") == 0)
	{
	    if (strcmp (p, "all") != 0)
	    {
		logHistory=malloc(strlen (p) + 1);
		strcpy (logHistory, p);
	    }
	}
	else
	{
	    /* We may be dealing with a keyword which was added in a
	       subsequent version of CVS.  In that case it is a good idea
	       to complain, as (1) the keyword might enable a behavior like
	       alternate locking behavior, in which it is dangerous and hard
	       to detect if some CVS's have it one way and others have it
	       the other way, (2) in general, having us not do what the user
	       had in mind when they put in the keyword violates the
	       principle of least surprise.  Note that one corollary is
	       adding new keywords to your CVSROOT/config file is not
	       particularly recommended unless you are planning on using
	       the new features.  */
	    error (0, 0, "%s: unrecognized keyword '%s'",
		   infopath, line);
	    goto error_return;
	}
    }
    if (ferror (fp_info))
    {
	error (0, errno, "cannot read %s", infopath);
	goto error_return;
    }
    if (fclose (fp_info) < 0)
    {
	error (0, errno, "cannot close %s", infopath);
	goto error_return;
    }
    free (infopath);
    if (line != NULL)
	free (line);
    return 0;

 error_return:
    if (infopath != NULL)
	free (infopath);
    if (line != NULL)
	free (line);
    return -1;
}
@


1.9
log
@Add a CVSROOT/config option "DisableMdocdate" (default:no) to turn off
the OpenBSD-specific Mdocdate expansion. This is useful to avoid
conflicts that arise between the server's expansion of Mdocdate and
the upstream code when maintaining forked OpenBSD derived code on an
OpenBSD CVS server.

"I must grudgingly agree that this is neccessary" deraadt@@
@
text
@d73 1
a73 1
    while (getline (&line, &line_allocated, fp_info) >= 0)
d262 1
a262 1
    while (getline (&line, &line_allocated, fp_info) >= 0)
@


1.8
log
@Add a "DisableXProg" option to CVSROOT/config that can be used to
disable support for Update-prog and Checkin-prog.  This is a good
idea for anonymouse cvs servers or anyone who doesn't need this
feature.  From Stefan Esser.
@
text
@d349 11
@


1.7
log
@Merge local changes; work in progress
@
text
@d362 23
@


1.6
log
@Integrate local changes
@
text
@d40 1
a40 1
    if (CVSroot_original == NULL)
d48 1
a48 1
    infopath = xmalloc (strlen (CVSroot_directory)
d51 2
a52 2
			+ 10);
    (void) sprintf (infopath, "%s/%s/%s", CVSroot_directory,
d207 1
a207 1
   CVSROOT is the $CVSROOT directory (CVSroot_directory might not be
@


1.5
log
@Integrate local changes
@
text
@d13 2
d37 1
a37 1
    char *cp, *exp, *value, *srepos;
a114 4
	if (!expanded_value)
	{
	    continue;
	}
d128 1
a128 1
	    if (default_value != NULL)
d130 2
a131 1
	    default_value = xstrdup (expanded_value);
d142 4
a145 1
	    if (all)
d148 1
a148 2
		error(0, 0, "Keyword `ALL' is ignored at line %d in %s file",
		      line_number, infofile);
d167 4
a170 1
	err += callproc (repository, expanded_value);
d180 6
a185 1
	err += callproc (repository, default_value);
d188 1
a188 1
    if (default_value != NULL)
d402 8
@


1.4
log
@Integrate local changes
@
text
@d80 1
a80 1
	for (cp = line; *cp && isspace (*cp); cp++)
d88 1
a88 1
	for (exp = cp; *cp && !isspace (*cp); cp++)
d94 1
a94 1
	while (*cp && isspace (*cp))
d384 9
@


1.3
log
@Integrate local changes
@
text
@d373 12
@


1.2
log
@Merge local changes to support a configuration file with Cyclic's scheme
@
text
@d353 20
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d10 2
a11 5

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)parseinfo.c 1.18 94/09/23 $";
USE(rcsid);
#endif
d24 1
a24 1
    int (*callproc) ();
d29 3
a31 2
    char infopath[PATH_MAX];
    char line[MAXLINELEN];
d33 1
d38 1
a38 1
    if (CVSroot == NULL)
d46 5
a50 1
    (void) sprintf (infopath, "%s/%s/%s", CVSroot,
d52 9
a60 2
    if ((fp_info = fopen (infopath, "r")) == NULL)
	return (0);			/* no file -> nothing special done */
d66 1
a66 1
	(void) fprintf (stderr, "-> ParseInfo(%s, %s, %s)\n",
d71 1
a71 1
    while (fgets (line, sizeof (line), fp_info) != NULL)
d110 6
a115 36
	/* FIXME: probably should allow multiple occurrences of CVSROOT.  */
	/* FIXME-maybe: perhaps should allow CVSREAD and other cvs
	   settings (if there is a need for them, which isn't clear).  */
	/* FIXME-maybe: Should there be a way to substitute arbitrary
	   environment variables?  Probably not, because then what gets
	   substituted would depend on who runs cvs.  A better feature might
	   be to allow a file in CVSROOT to specify variables to be
	   substituted.  */
	{
	    char *p, envname[128];

	    strcpy(envname, "$");
	    /* FIXME: I'm not at all sure this should be CVSROOT_ENV as opposed
	       to literal CVSROOT.  The value we subsitute is the cvs root
	       in use which is not the same thing as the environment variable
	       CVSROOT_ENV.  */
	    strcat(envname, CVSROOT_ENV);

	    cp = xstrdup(value);
	    if ((p = strstr(cp, envname))) {
		if (strlen(line) + strlen(CVSroot) + 1 > MAXLINELEN) {
		    /* FIXME: there is no reason for this arbitrary limit.  */
		    error(0, 0,
			  "line %d in %s too long to expand $CVSROOT, ignored",
			  line_number, infofile);
		    continue;
		}
		if (p > cp) {
		    strncpy(value, cp, p - cp);
		    value[p - cp] = '\0';
		    strcat(value, CVSroot);
		} else
		    strcpy(value, CVSroot);
		strcat(value, p + strlen(envname));
	    }
	    free(cp);
d128 5
a132 1
	    default_value = xstrdup (value);
d144 1
a144 1
		err += callproc (repository, value);
d166 1
a166 1
	err += callproc (repository, value);
d169 4
a172 1
    (void) fclose (fp_info);
d181 5
d188 204
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d27 1
a27 1
    CALLPROC callproc;
a34 1
    char *expanded_value= NULL;
d100 8
a107 2
	expanded_value = expand_path (value);
	if (!expanded_value)
d109 1
a109 4
	    error (0, 0,
		   "Invalid environmental variable at line %d in file %s",
		   line_number, infofile);
	    continue;
d111 25
d148 1
a148 1
	    default_value = xstrdup (expanded_value);
d160 1
a160 1
		err += callproc (repository, expanded_value);
d182 1
a182 1
	err += callproc (repository, expanded_value);
a193 2
    if (expanded_value != NULL)
	free (expanded_value);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d11 5
d101 1
a101 1
	expanded_value = expand_path (value, infofile, line_number);
d104 3
d108 1
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d35 1
a35 1
    if (CVSroot_original == NULL)
d43 1
a43 1
    (void) sprintf (infopath, "%s/%s/%s", CVSroot_directory,
d45 1
a45 1
    if ((fp_info = CVS_FOPEN (infopath, "r")) == NULL)
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a9 1
#include "getline.h"
d27 2
a28 3
    char *infopath;
    char *line = NULL;
    size_t line_allocated = 0;
a42 4
    infopath = xmalloc (strlen (CVSroot_directory)
			+ strlen (infofile)
			+ sizeof (CVSROOTADM)
			+ 10);
d45 2
a46 8
    fp_info = CVS_FOPEN (infopath, "r");
    if (fp_info == NULL)
    {
	/* If no file, don't do anything special.  */
	if (!existence_error (errno))
	    error (0, errno, "cannot open %s", infopath);
	return 0;
    }
d57 1
a57 1
    while (getline (&line, &line_allocated, fp_info) >= 0)
d149 1
a149 4
    if (ferror (fp_info))
	error (0, errno, "cannot read %s", infopath);
    if (fclose (fp_info) < 0)
	error (0, errno, "cannot close %s", infopath);
a159 3
    free (infopath);
    if (line != NULL)
	free (line);
@


1.1.1.6
log
@Latest version from Cyclic Software
@
text
@a56 1
	free (infopath);
a107 2
	if (expanded_value != NULL)
	    free (expanded_value);
a123 4
	    /* Is it OK to silently ignore all but the last DEFAULT
               expression?  */
	    if (default_value != NULL)
		free (default_value);
@


1.1.1.7
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
a10 1
#include <assert.h>
d65 1
a65 1
	(void) fprintf (stderr, " -> ParseInfo(%s, %s, %s)\n",
a186 180
}


/* Parse the CVS config file.  The syntax right now is a bit ad hoc
   but tries to draw on the best or more common features of the other
   *info files and various unix (or non-unix) config file syntaxes.
   Lines starting with # are comments.  Settings are lines of the form
   KEYWORD=VALUE.  There is currently no way to have a multi-line
   VALUE (would be nice if there was, probably).

   CVSROOT is the $CVSROOT directory (CVSroot_directory might not be
   set yet).

   Returns 0 for success, negative value for failure.  Call
   error(0, ...) on errors in addition to the return value.  */
int
parse_config (cvsroot)
    char *cvsroot;
{
    char *infopath;
    FILE *fp_info;
    char *line = NULL;
    size_t line_allocated = 0;
    size_t len;
    char *p;
    /* FIXME-reentrancy: If we do a multi-threaded server, this would need
       to go to the per-connection data structures.  */
    static int parsed = 0;

    /* Authentication code and serve_root might both want to call us.
       Let this happen smoothly.  */
    if (parsed)
	return 0;
    parsed = 1;

    infopath = malloc (strlen (cvsroot)
			+ sizeof (CVSROOTADM_CONFIG)
			+ sizeof (CVSROOTADM)
			+ 10);
    if (infopath == NULL)
    {
	error (0, 0, "out of memory; cannot allocate infopath");
	goto error_return;
    }

    strcpy (infopath, cvsroot);
    strcat (infopath, "/");
    strcat (infopath, CVSROOTADM);
    strcat (infopath, "/");
    strcat (infopath, CVSROOTADM_CONFIG);

    fp_info = CVS_FOPEN (infopath, "r");
    if (fp_info == NULL)
    {
	/* If no file, don't do anything special.  */
	if (!existence_error (errno))
	{
	    /* Just a warning message; doesn't affect return
	       value, currently at least.  */
	    error (0, errno, "cannot open %s", infopath);
	}
	free (infopath);
	return 0;
    }

    while (getline (&line, &line_allocated, fp_info) >= 0)
    {
	/* Skip comments.  */
	if (line[0] == '#')
	    continue;

	/* At least for the moment we don't skip whitespace at the start
	   of the line.  Too picky?  Maybe.  But being insufficiently
	   picky leads to all sorts of confusion, and it is a lot easier
	   to start out picky and relax it than the other way around.

	   Is there any kind of written standard for the syntax of this
	   sort of config file?  Anywhere in POSIX for example (I guess
	   makefiles are sort of close)?  Red Hat Linux has a bunch of
	   these too (with some GUI tools which edit them)...

	   Along the same lines, we might want a table of keywords,
	   with various types (boolean, string, &c), as a mechanism
	   for making sure the syntax is consistent.  Any good examples
	   to follow there (Apache?)?  */

	/* Strip the training newline.  There will be one unless we
	   read a partial line without a newline, and then got end of
	   file (or error?).  */

	len = strlen (line) - 1;
	if (line[len] == '\n')
	    line[len] = '\0';

	/* Skip blank lines.  */
	if (line[0] == '\0')
	    continue;

	/* The first '=' separates keyword from value.  */
	p = strchr (line, '=');
	if (p == NULL)
	{
	    /* Probably should be printing line number.  */
	    error (0, 0, "syntax error in %s: line '%s' is missing '='",
		   infopath, line);
	    goto error_return;
	}

	*p++ = '\0';

	if (strcmp (line, "RCSBIN") == 0)
	{
	    /* This option used to specify the directory for RCS
	       executables.  But since we don't run them any more,
	       this is a noop.  Silently ignore it so that a
	       repository can work with either new or old CVS.  */
	    ;
	}
	else if (strcmp (line, "SystemAuth") == 0)
	{
	    if (strcmp (p, "no") == 0)
#ifdef AUTH_SERVER_SUPPORT
		system_auth = 0;
#else
		/* Still parse the syntax but ignore the
		   option.  That way the same config file can
		   be used for local and server.  */
		;
#endif
	    else if (strcmp (p, "yes") == 0)
#ifdef AUTH_SERVER_SUPPORT
		system_auth = 1;
#else
		;
#endif
	    else
	    {
		error (0, 0, "unrecognized value '%s' for SystemAuth", p);
		goto error_return;
	    }
	}
	else
	{
	    /* We may be dealing with a keyword which was added in a
	       subsequent version of CVS.  In that case it is a good idea
	       to complain, as (1) the keyword might enable a behavior like
	       alternate locking behavior, in which it is dangerous and hard
	       to detect if some CVS's have it one way and others have it
	       the other way, (2) in general, having us not do what the user
	       had in mind when they put in the keyword violates the
	       principle of least surprise.  Note that one corollary is
	       adding new keywords to your CVSROOT/config file is not
	       particularly recommended unless you are planning on using
	       the new features.  */
	    error (0, 0, "%s: unrecognized keyword '%s'",
		   infopath, line);
	    goto error_return;
	}
    }
    if (ferror (fp_info))
    {
	error (0, errno, "cannot read %s", infopath);
	goto error_return;
    }
    if (fclose (fp_info) < 0)
    {
	error (0, errno, "cannot close %s", infopath);
	goto error_return;
    }
    free (infopath);
    if (line != NULL)
	free (line);
    return 0;

 error_return:
    if (infopath != NULL)
	free (infopath);
    if (line != NULL)
	free (line);
    return -1;
@


1.1.1.8
log
@Latest version from Cyclic
@
text
@a328 20
	else if (strcmp (line, "PreservePermissions") == 0)
	{
	    if (strcmp (p, "no") == 0)
		preserve_perms = 0;
	    else if (strcmp (p, "yes") == 0)
	    {
#ifdef PRESERVE_PERMISSIONS_SUPPORT
		preserve_perms = 1;
#else
		error (0, 0, "\
warning: this CVS does not support PreservePermissions");
#endif
	    }
	    else
	    {
		error (0, 0, "unrecognized value '%s' for PreservePermissions",
		       p);
		goto error_return;
	    }
	}
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@a348 12
	else if (strcmp (line, "TopLevelAdmin") == 0)
	{
	    if (strcmp (p, "no") == 0)
		top_level_admin = 0;
	    else if (strcmp (p, "yes") == 0)
		top_level_admin = 1;
	    else
	    {
		error (0, 0, "unrecognized value '%s' for TopLevelAdmin", p);
		goto error_return;
	    }
	}
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d80 1
a80 1
	for (cp = line; *cp && isspace ((unsigned char) *cp); cp++)
d88 1
a88 1
	for (exp = cp; *cp && !isspace ((unsigned char) *cp); cp++)
d94 1
a94 1
	while (*cp && isspace ((unsigned char) *cp))
a359 9
	}
	else if (strcmp (line, "LockDir") == 0)
	{
	    if (lock_dir != NULL)
		free (lock_dir);
	    lock_dir = xstrdup (p);
	    /* Could try some validity checking, like whether we can
	       opendir it or something, but I don't see any particular
	       reason to do that now rather than waiting until lock.c.  */
@


1.1.1.11
log
@Latest from Cyclic Software
@
text
@a12 2
extern char *logHistory;

d35 1
a35 1
    char *cp, *exp, *value, *srepos, bad;
d113 4
d130 1
a130 1
	    if (default_value != NULL && default_value != &bad)
d132 1
a132 2
	    default_value = (expanded_value != NULL ?
			     xstrdup (expanded_value) : &bad);
d143 3
a145 1
	    if (!all)
a147 4
	    else if (expanded_value != NULL)
		err += callproc (repository, expanded_value);
	    else
		err++;
d166 1
a166 4
	if (expanded_value != NULL)
	    err += callproc (repository, expanded_value);
	else
	    err++;
d176 1
a176 6
    {
	if (default_value != &bad)
	    err += callproc (repository, default_value);
	else
	    err++;
    }
d179 1
a179 1
    if (default_value != NULL && default_value != &bad)
a368 8
	}
	else if (strcmp (line, "LogHistory") == 0)
	{
	    if (strcmp (p, "all") != 0)
	    {
		logHistory=malloc(strlen (p) + 1);
		strcpy (logHistory, p);
	    }
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d40 1
a40 1
    if (current_parsed_root == NULL)
d48 1
a48 1
    infopath = xmalloc (strlen (current_parsed_root->directory)
d51 2
a52 2
			+ 3);
    (void) sprintf (infopath, "%s/%s/%s", current_parsed_root->directory,
d207 1
a207 1
   CVSROOT is the $CVSROOT directory (current_parsed_root->directory might not be
@


