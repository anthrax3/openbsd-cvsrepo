head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.11
	OPENBSD_6_1:1.1.1.11.0.80
	OPENBSD_6_1_BASE:1.1.1.11
	OPENBSD_6_0:1.1.1.11.0.76
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.72
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.74
	OPENBSD_5_8_BASE:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.66
	OPENBSD_5_7_BASE:1.1.1.11
	OPENBSD_5_6:1.1.1.11.0.70
	OPENBSD_5_6_BASE:1.1.1.11
	OPENBSD_5_5:1.1.1.11.0.68
	OPENBSD_5_5_BASE:1.1.1.11
	OPENBSD_5_4:1.1.1.11.0.64
	OPENBSD_5_4_BASE:1.1.1.11
	OPENBSD_5_3:1.1.1.11.0.62
	OPENBSD_5_3_BASE:1.1.1.11
	OPENBSD_5_2:1.1.1.11.0.60
	OPENBSD_5_2_BASE:1.1.1.11
	OPENBSD_5_1_BASE:1.1.1.11
	OPENBSD_5_1:1.1.1.11.0.58
	OPENBSD_5_0:1.1.1.11.0.56
	OPENBSD_5_0_BASE:1.1.1.11
	OPENBSD_4_9:1.1.1.11.0.54
	OPENBSD_4_9_BASE:1.1.1.11
	OPENBSD_4_8:1.1.1.11.0.52
	OPENBSD_4_8_BASE:1.1.1.11
	OPENBSD_4_7:1.1.1.11.0.48
	OPENBSD_4_7_BASE:1.1.1.11
	OPENBSD_4_6:1.1.1.11.0.50
	OPENBSD_4_6_BASE:1.1.1.11
	OPENBSD_4_5:1.1.1.11.0.46
	OPENBSD_4_5_BASE:1.1.1.11
	OPENBSD_4_4:1.1.1.11.0.44
	OPENBSD_4_4_BASE:1.1.1.11
	OPENBSD_4_3:1.1.1.11.0.42
	OPENBSD_4_3_BASE:1.1.1.11
	OPENBSD_4_2:1.1.1.11.0.40
	OPENBSD_4_2_BASE:1.1.1.11
	OPENBSD_4_1:1.1.1.11.0.38
	OPENBSD_4_1_BASE:1.1.1.11
	OPENBSD_4_0:1.1.1.11.0.36
	OPENBSD_4_0_BASE:1.1.1.11
	OPENBSD_3_9:1.1.1.11.0.34
	OPENBSD_3_9_BASE:1.1.1.11
	OPENBSD_3_8:1.1.1.11.0.32
	OPENBSD_3_8_BASE:1.1.1.11
	OPENBSD_3_7:1.1.1.11.0.30
	OPENBSD_3_7_BASE:1.1.1.11
	OPENBSD_3_6:1.1.1.11.0.28
	OPENBSD_3_6_BASE:1.1.1.11
	OPENBSD_3_5:1.1.1.11.0.26
	OPENBSD_3_5_BASE:1.1.1.11
	OPENBSD_3_4:1.1.1.11.0.24
	OPENBSD_3_4_BASE:1.1.1.11
	OPENBSD_3_3:1.1.1.11.0.22
	OPENBSD_3_3_BASE:1.1.1.11
	OPENBSD_3_2:1.1.1.11.0.20
	OPENBSD_3_2_BASE:1.1.1.11
	OPENBSD_3_1:1.1.1.11.0.18
	OPENBSD_3_1_BASE:1.1.1.11
	OPENBSD_3_0:1.1.1.11.0.16
	OPENBSD_3_0_BASE:1.1.1.11
	cvs-1-11-1p1:1.1.1.11
	OPENBSD_2_9:1.1.1.11.0.14
	OPENBSD_2_9_BASE:1.1.1.11
	cvs-1-11:1.1.1.11
	OPENBSD_2_8:1.1.1.11.0.12
	OPENBSD_2_8_BASE:1.1.1.11
	OPENBSD_2_7:1.1.1.11.0.10
	OPENBSD_2_7_BASE:1.1.1.11
	OPENBSD_2_6:1.1.1.11.0.8
	OPENBSD_2_6_BASE:1.1.1.11
	cvs-1-10-7:1.1.1.11
	OPENBSD_2_5:1.1.1.11.0.6
	OPENBSD_2_5_BASE:1.1.1.11
	cvs-1-10-5:1.1.1.11
	OPENBSD_2_4:1.1.1.11.0.4
	OPENBSD_2_4_BASE:1.1.1.11
	cvs-1-10:1.1.1.11
	cvs-1-9-28:1.1.1.11
	OPENBSD_2_3:1.1.1.11.0.2
	OPENBSD_2_3_BASE:1.1.1.11
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.57;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.38;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.17;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.22;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.19;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.55.55;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.26.54;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.34;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.01;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.28;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS 1.4 kit.
 * 
 * Check In
 * 
 * Does a very careful checkin of the file "user", and tries not to spoil its
 * modification time (to avoid needless recompilations). When RCS ID keywords
 * get expanded on checkout, however, the modification time is updated and
 * there is no good way to get around this.
 * 
 * Returns non-zero on error.
 */

#include "cvs.h"

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)checkin.c 1.48 94/10/07 $";
USE(rcsid);
#endif

int
Checkin (type, file, update_dir, repository,
	 rcs, rev, tag, options, message, entries)
    int type;
    char *file;
    char *update_dir;
    char *repository;
    char *rcs;
    char *rev;
    char *tag;
    char *options;
    char *message;
    List *entries;
{
    char fname[PATH_MAX];
    Vers_TS *vers;
    int set_time;
    char *fullname;

    char *tocvsPath = NULL;

    fullname = xmalloc (strlen (update_dir) + strlen (file) + 10);
    if (update_dir[0] == '\0')
	strcpy (fullname, file);
    else
	sprintf (fullname, "%s/%s", update_dir, file);

    (void) printf ("Checking in %s;\n", fullname);
    (void) sprintf (fname, "%s/%s%s", CVSADM, CVSPREFIX, file);

    /*
     * Move the user file to a backup file, so as to preserve its
     * modification times, then place a copy back in the original file name
     * for the checkin and checkout.
     */

    tocvsPath = wrap_tocvs_process_file (fullname);

    if (!noexec)
    {
        if (tocvsPath)
	{
            copy_file (tocvsPath, fname);
	    if (unlink_file_dir (file) < 0)
		if (errno != ENOENT)
		    error (1, errno, "cannot remove %s", file);
	    copy_file (tocvsPath, file);
	}
	else
	{
	    copy_file (file, fname);
	}
    }

    run_setup ("%s%s -f %s%s", Rcsbin, RCS_CI,
	       rev ? "-r" : "", rev ? rev : "");
    run_args ("-m%s", make_message_rcslegal (message));
    run_arg (rcs);

    switch (run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL))
    {
	case 0:			/* everything normal */

	    /*
	     * The checkin succeeded, so now check the new file back out and
	     * see if it matches exactly with the one we checked in. If it
	     * does, just move the original user file back, thus preserving
	     * the modes; otherwise, we have no recourse but to leave the
	     * newly checkout file as the user file and remove the old
	     * original user file.
	     */

	    if (strcmp (options, "-V4") == 0) /* upgrade to V5 now */
		options[0] = '\0';
	    run_setup ("%s%s -q %s %s%s", Rcsbin, RCS_CO, options,
		       rev ? "-r" : "", rev ? rev : "");
	    run_arg (rcs);
	    (void) run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
	    xchmod (file, 1);
	    if (xcmp (file, fname) == 0)
	    {
		rename_file (fname, file);
		/* the time was correct, so leave it alone */
		set_time = 0;
	    }
	    else
	    {
		if (unlink_file (fname) < 0)
		    error (0, errno, "cannot remove %s", fname);
		/* sync up with the time from the RCS file */
		set_time = 1;
	    }

	    wrap_fromcvs_process_file (file);

	    /*
	     * If we want read-only files, muck the permissions here, before
	     * getting the file time-stamp.
	     */
	    if (cvswrite == FALSE)
		xchmod (file, 0);

#ifndef DEATH_SUPPORT
 /* With death_support, files added with tags go into branches immediately. */

	    /* for added files with symbolic tags, need to add the tag too */
	    if (type == 'A' && tag && !isdigit (*tag))
	    {
		(void) RCS_settag(rcs, tag, rev);
	    }
#endif /* No DEATH_SUPPORT */

	    /* re-register with the new data */
	    vers = Version_TS (repository, (char *) NULL, tag, (char *) NULL,
			       file, 1, set_time, entries, (List *) NULL);
	    if (strcmp (vers->options, "-V4") == 0)
		vers->options[0] = '\0';
	    Register (entries, file, vers->vn_rcs, vers->ts_user,
		      vers->options, vers->tag, vers->date, (char *) 0);
	    history_write (type, (char *) 0, vers->vn_rcs, file, repository);
	    freevers_ts (&vers);

	    if (tocvsPath)
		if (unlink_file_dir (tocvsPath) < 0)
		    error (0, errno, "cannot remove %s", tocvsPath);

	    break;

	case -1:			/* fork failed */
	    if (tocvsPath)
		if (unlink_file_dir (tocvsPath) < 0)
		    error (0, errno, "cannot remove %s", tocvsPath);

	    if (!noexec)
		error (1, errno, "could not check in %s -- fork failed",
		       fullname);
	    return (1);

	default:			/* ci failed */

	    /*
	     * The checkin failed, for some unknown reason, so we restore the
	     * original user file, print an error, and return an error
	     */
	    if (tocvsPath)
		if (unlink_file_dir (tocvsPath) < 0)
		    error (0, errno, "cannot remove %s", tocvsPath);

	    if (!noexec)
	    {
		rename_file (fname, file);
		error (0, 0, "could not check in %s", fullname);
	    }
	    return (1);
    }

    /*
     * When checking in a specific revision, we may have locked the wrong
     * branch, so to be sure, we do an extra unlock here before
     * returning.
     */
    if (rev)
    {
	(void) RCS_unlock (rcs, NULL, 1);
    }

#ifdef SERVER_SUPPORT
    if (server_active)
    {
	if (set_time)
	    /* Need to update the checked out file on the client side.  */
	    server_updated (file, update_dir, repository, SERVER_UPDATED,
			    NULL, NULL);
	else
	    server_checked_in (file, update_dir, repository);
    }
#endif

    return (0);
}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a18 2
#include "fileattr.h"
#include "edit.h"
d69 1
a69 1
		if (! existence_error (errno))
d124 1
a124 1
	    if (cvswrite == FALSE || fileattr_get (file, "_watched"))
a200 1
    else
a201 1
	mark_up_to_date (file);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d22 5
d81 6
a86 1
    switch (RCS_checkin (rcs, NULL, message, rev, 0, 0))
d101 4
a104 4

	    /* FIXME: should be checking for errors.  */
	    (void) RCS_checkout (rcs, "", rev, options, RUN_TTY, 0, 0);

d128 10
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d121 1
a121 1
			       file, 1, set_time, entries, (RCSNode *) NULL);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d23 2
a24 1
Checkin (type, finfo, rcs, rev, tag, options, message)
d26 3
a28 1
    struct file_info *finfo;
d34 1
d39 2
d43 8
a50 2
    (void) printf ("Checking in %s;\n", finfo->fullname);
    (void) sprintf (fname, "%s/%s%s", CVSADM, CVSPREFIX, finfo->file);
d58 1
a58 1
    tocvsPath = wrap_tocvs_process_file (finfo->fullname);
d65 1
a65 1
	    if (unlink_file_dir (finfo->file) < 0)
d67 2
a68 2
		    error (1, errno, "cannot remove %s", finfo->fullname);
	    copy_file (tocvsPath, finfo->file);
d72 1
a72 1
	    copy_file (finfo->file, fname);
d76 1
a76 1
    switch (RCS_checkin (rcs, NULL, message, rev, 0))
a91 6
	    /* Reparse the RCS file, so that we can safely call
               RCS_checkout.  FIXME: We could probably calculate
               all the changes.  */
	    freercsnode (&finfo->rcs);
	    finfo->rcs = RCS_parse (finfo->file, finfo->repository);

d93 1
a93 2
	    (void) RCS_checkout (finfo->rcs, finfo->file, rev,
				 (char *) NULL, options, RUN_TTY);
d95 2
a96 2
	    xchmod (finfo->file, 1);
	    if (xcmp (finfo->file, fname) == 0)
d98 1
a98 1
		rename_file (fname, finfo->file);
d110 1
a110 1
	    wrap_fromcvs_process_file (finfo->file);
d116 2
a117 2
	    if (cvswrite == FALSE || fileattr_get (finfo->file, "_watched"))
		xchmod (finfo->file, 0);
d119 3
a121 2
	    /* Re-register with the new data.  */
	    vers = Version_TS (finfo, NULL, tag, NULL, 1, set_time);
d124 1
a124 1
	    Register (finfo->entries, finfo->file, vers->vn_rcs, vers->ts_user,
d126 2
a127 2
	    history_write (type, NULL, vers->vn_rcs,
			   finfo->file, finfo->repository);
d142 1
a142 1
		       finfo->fullname);
d157 2
a158 2
		rename_file (fname, finfo->file);
		error (0, 0, "could not check in %s", finfo->fullname);
d170 1
a170 1
	(void) RCS_unlock (finfo->rcs, NULL, 1);
d178 1
a178 1
	    server_updated (finfo, vers, SERVER_UPDATED,
d181 1
a181 1
	    server_checked_in (finfo->file, finfo->update_dir, finfo->repository);
d185 1
a185 1
	mark_up_to_date (finfo->file);
a186 1
    freevers_ts (&vers);
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d32 1
a32 1
    char *fname;
a37 1
    fname = xmalloc (strlen (finfo->file) + 80);
a136 1
	    free (fname);
a153 1
	    free (fname);
a181 1
    free (fname);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d37 1
a37 8
    /* Hmm.  This message goes to stdout and the "foo,v  <--  foo"
       message from "ci" goes to stderr.  This doesn't make a whole
       lot of sense, but making everything go to stdout can only be
       gracefully achieved once RCS_checkin is librarified.  */
    cvs_output ("Checking in ", 0);
    cvs_output (finfo->fullname, 0);
    cvs_output (";\n", 0);

@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d96 1
a96 2
				 (char *) NULL, options, RUN_TTY,
				 (RCSCHECKOUTPROC) NULL, (void *) NULL);
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d54 1
a54 1
    tocvsPath = wrap_tocvs_process_file (finfo->file);
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d72 1
a72 4
    if (finfo->rcs == NULL)
	finfo->rcs = RCS_parse (finfo->file, finfo->repository);

    switch (RCS_checkin (finfo->rcs, NULL, message, rev, 0))
d88 6
d120 1
a120 1
	    if (!cvswrite || fileattr_get (finfo->file, "_watched"))
a175 1
	RCS_rewrite (finfo->rcs, NULL, NULL);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d32 1
d45 9
d55 1
d60 1
d64 5
a68 1
	    rename_file (tocvsPath, finfo->file);
d75 1
a75 1
    switch (RCS_checkin (finfo->rcs, NULL, message, rev, RCS_FLAGS_KEEPFILE))
d79 8
a86 8
	    /* The checkin succeeded.  If checking the file out again
               would not cause any changes, we are done.  Otherwise,
               we need to check out the file, which will change the
               modification time of the file.

	       The only way checking out the file could cause any
	       changes is if the file contains RCS keywords.  So we if
	       we are not expanding RCS keywords, we are done.  */
d91 7
a97 11
	    /* FIXME: If PreservePermissions is on, RCS_cmp_file is
               going to call RCS_checkout into a temporary file
               anyhow.  In that case, it would be more efficient to
               call RCS_checkout here, compare the resulting files
               using xcmp, and rename if necessary.  I think this
               should be fixed in RCS_cmp_file.  */
	    if ((! preserve_perms
		 && options != NULL
		 && (strcmp (options, "-ko") == 0
		     || strcmp (options, "-kb") == 0))
		|| RCS_cmp_file (finfo->rcs, rev, options, finfo->file) == 0)
d99 2
a100 2
		/* The existing file is correct.  We don't have to do
                   anything.  */
d105 3
a107 8
		/* The existing file is incorrect.  We need to check
                   out the correct file contents.  */
		if (RCS_checkout (finfo->rcs, finfo->file, rev, (char *) NULL,
				  options, RUN_TTY, (RCSCHECKOUTPROC) NULL,
				  (void *) NULL) != 0)
		    error (1, 0, "failed when checking out new copy of %s",
			   finfo->fullname);
		xchmod (finfo->file, 1);
d143 1
d148 4
a151 3
	    /* The checkin failed, for some unknown reason, so we
	       print an error, and return an error.  We assume that
	       the original file has not been touched.  */
d157 2
d160 2
d182 1
a182 2
			    (mode_t) -1, (unsigned char *) NULL,
			    (struct buffer *) NULL);
d191 1
@

