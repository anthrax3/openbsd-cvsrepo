head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.64
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.62
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.58
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.60
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.52
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.56
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.54
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.50
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.48
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.46
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.44
	OPENBSD_5_0:1.14.0.42
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.40
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.38
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.34
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.36
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.32
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.30
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.28
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.26
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.24
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.22
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.20
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.18
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.16
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.14
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.12
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.10
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.8
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.6
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.4
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	cvs-1-11-1p1:1.1.1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	cvs-1-11:1.1.1.12
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	cvs-1-10-7:1.1.1.11
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	cvs-1-10-5:1.1.1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	cvs-1-10:1.1.1.10
	cvs-1-9-28:1.1.1.10
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.10.19.31.35;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	99.02.28.21.57.53;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	98.03.12.07.22.31;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	98.02.22.08.56.00;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	97.06.28.03.45.29;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	97.03.18.02.09.56;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.02.21.06.54.55;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.10.18.04.19.34;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.05.06.22.51.15;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.04.27.20.26.19;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.30.01.10.43;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.19.10.41.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.12;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.57;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.39;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.38;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.34;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.09;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.28.45;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.21.18;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.03.12.06.58.49;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.02.28.21.33.01;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.02.10.18.57.42;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Merge local changes; work in progress
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Set Lock
 * 
 * Lock file support for CVS.
 */

/* The node Concurrency in doc/cvs.texinfo has a brief introduction to
   how CVS locks function, and some of the user-visible consequences of
   their existence.  Here is a summary of why they exist (and therefore,
   the consequences of hacking CVS to read a repository without creating
   locks):

   There are two uses.  One is the ability to prevent there from being
   two writers at the same time.  This is necessary for any number of
   reasons (fileattr code, probably others).  Commit needs to lock the
   whole tree so that nothing happens between the up-to-date check and
   the actual checkin.

   The second use is the ability to ensure that there is not a writer
   and a reader at the same time (several readers are allowed).  Reasons
   for this are:

   * Readlocks ensure that once CVS has found a collection of rcs
   files using Find_Names, the files will still exist when it reads
   them (they may have moved in or out of the attic).

   * Readlocks provide some modicum of consistency, although this is
   kind of limited--see the node Concurrency in cvs.texinfo.

   * Readlocks ensure that the RCS file does not change between
   RCS_parse and RCS_reparsercsfile time.  This one strikes me as
   important, although I haven't thought up what bad scenarios might
   be.

   * Readlocks ensure that we won't find the file in the state in
   which it is in between the calls to add_rcs_file and RCS_checkin in
   commit.c (when a file is being added).  This state is a state in
   which the RCS file parsing routines in rcs.c cannot parse the file.

   * Readlocks ensure that a reader won't try to look at a
   half-written fileattr file (fileattr is not updated atomically).

   (see also the description of anonymous read-only access in
   "Password authentication security" node in doc/cvs.texinfo).

   While I'm here, I'll try to summarize a few random suggestions
   which periodically get made about how locks might be different:

   1.  Check for EROFS.  Maybe useful, although in the presence of NFS
   EROFS does *not* mean that the file system is unchanging.

   2.  Provide a means to put the cvs locks in some directory apart from
   the repository (CVSROOT/locks; a -l option in modules; etc.).

   3.  Provide an option to disable locks for operations which only
   read (see above for some of the consequences).

   4.  Have a server internally do the locking.  Probably a good
   long-term solution, and many people have been working hard on code
   changes which would eventually make it possible to have a server
   which can handle various connections in one process, but there is
   much, much work still to be done before this is feasible.

   5.  Like #4 but use shared memory or something so that the servers
   merely need to all be on the same machine.  This is a much smaller
   change to CVS (it functions much like #2; shared memory might be an
   unneeded complication although it presumably would be faster).  */

#include "cvs.h"
#include <assert.h>

struct lock {
    /* This is the directory in which we may have a lock named by the
       readlock variable, a lock named by the writelock variable, and/or
       a lock named CVSLCK.  The storage is not allocated along with the
       struct lock; it is allocated by the Reader_Lock caller or in the
       case of writelocks, it is just a pointer to the storage allocated
       for the ->key field.  */
    char *repository;
    /* Do we have a lock named CVSLCK?  */
    int have_lckdir;
    /* Note there is no way of knowing whether the readlock and writelock
       exist.  The code which sets the locks doesn't use SIG_beginCrSect
       to set a flag like we do for CVSLCK.  */
};

static void remove_locks PROTO((void));
static int readers_exist PROTO((char *repository));
static int set_lock PROTO ((struct lock *lock, int will_wait));
static void clear_lock PROTO ((struct lock *lock));
static void set_lockers_name PROTO((struct stat *statp));
static int set_writelock_proc PROTO((Node * p, void *closure));
static int unlock_proc PROTO((Node * p, void *closure));
static int write_lock PROTO ((struct lock *lock));
static void lock_simple_remove PROTO ((struct lock *lock));
static void lock_wait PROTO((char *repository));
static void lock_obtained PROTO((char *repository));

/* Malloc'd array containing the username of the whoever has the lock.
   Will always be non-NULL in the cases where it is needed.  */
static char *lockers_name;
/* Malloc'd array specifying name of a readlock within a directory.
   Or NULL if none.  */
static char *readlock;
/* Malloc'd array specifying name of a writelock within a directory.
   Or NULL if none.  */
static char *writelock;
/* Malloc'd array specifying the name of a CVSLCK file (absolute pathname).
   Will always be non-NULL in the cases where it is used.  */
static char *masterlock;
static List *locklist;

#define L_OK		0		/* success */
#define L_ERROR		1		/* error condition */
#define L_LOCKED	2		/* lock owned by someone else */

/* This is the (single) readlock which is set by Reader_Lock.  The
   repository field is NULL if there is no such lock.  */
static struct lock global_readlock;

/* List of locks set by lock_tree_for_write.  This is redundant
   with locklist, sort of.  */
static List *lock_tree_list;

/* If we set locks with lock_dir_for_write, then locked_dir contains
   the malloc'd name of the repository directory which we have locked.
   locked_list is the same thing packaged into a list and is redundant
   with locklist the same way that lock_tree_list is.  */
static char *locked_dir;
static List *locked_list;

/* LockDir from CVSROOT/config.  */
char *lock_dir;

static char *lock_name PROTO ((char *repository, char *name));

/* Return a newly malloc'd string containing the name of the lock for the
   repository REPOSITORY and the lock file name within that directory
   NAME.  Also create the directories in which to put the lock file
   if needed (if we need to, could save system call(s) by doing
   that only if the actual operation fails.  But for now we'll keep
   things simple).  */
static char *
lock_name (repository, name)
    char *repository;
    char *name;
{
    char *retval;
    char *p;
    char *q;
    char *short_repos;
    mode_t save_umask;
    int saved_umask = 0;

    if (lock_dir == NULL)
    {
	/* This is the easy case.  Because the lock files go directly
	   in the repository, no need to create directories or anything.  */
	retval = xmalloc (strlen (repository) + strlen (name) + 10);
	(void) sprintf (retval, "%s/%s", repository, name);
    }
    else
    {
	struct stat sb;
	mode_t new_mode = 0;

	/* The interesting part of the repository is the part relative
	   to CVSROOT.  */
	assert (current_parsed_root != NULL);
	assert (current_parsed_root->directory != NULL);
	assert (strncmp (repository, current_parsed_root->directory,
			 strlen (current_parsed_root->directory)) == 0);
	short_repos = repository + strlen (current_parsed_root->directory) + 1;

	if (strcmp (repository, current_parsed_root->directory) == 0)
	    short_repos = ".";
	else
	    assert (short_repos[-1] == '/');

	retval = xmalloc (strlen (lock_dir)
			  + strlen (short_repos)
			  + strlen (name)
			  + 10);
	strcpy (retval, lock_dir);
	q = retval + strlen (retval);
	*q++ = '/';

	strcpy (q, short_repos);

	/* In the common case, where the directory already exists, let's
	   keep it to one system call.  */
	if (CVS_STAT (retval, &sb) < 0)
	{
	    /* If we need to be creating more than one directory, we'll
	       get the existence_error here.  */
	    if (!existence_error (errno))
		error (1, errno, "cannot stat directory %s", retval);
	}
	else
	{
	    if (S_ISDIR (sb.st_mode))
		goto created;
	    else
		error (1, 0, "%s is not a directory", retval);
	}

	/* Now add the directories one at a time, so we can create
	   them if needed.

	   The idea behind the new_mode stuff is that the directory we
	   end up creating will inherit permissions from its parent
	   directory (we re-set new_mode with each EEXIST).  CVSUMASK
	   isn't right, because typically the reason for LockDir is to
	   use a different set of permissions.  We probably want to
	   inherit group ownership also (but we don't try to deal with
	   that, some systems do it for us either always or when g+s is on).

	   We don't try to do anything about the permissions on the lock
	   files themselves.  The permissions don't really matter so much
	   because the locks will generally be removed by the process
	   which created them.  */

	if (CVS_STAT (lock_dir, &sb) < 0)
	    error (1, errno, "cannot stat %s", lock_dir);
	new_mode = sb.st_mode;
	save_umask = umask (0000);
	saved_umask = 1;

	p = short_repos;
	while (1)
	{
	    while (!ISDIRSEP (*p) && *p != '\0')
		++p;
	    if (ISDIRSEP (*p))
	    {
		strncpy (q, short_repos, p - short_repos);
		q[p - short_repos] = '\0';
		if (!ISDIRSEP (q[p - short_repos - 1])
		    && CVS_MKDIR (retval, new_mode) < 0)
		{
		    int saved_errno = errno;
		    if (saved_errno != EEXIST)
			error (1, errno, "cannot make directory %s", retval);
		    else
		    {
			if (CVS_STAT (retval, &sb) < 0)
			    error (1, errno, "cannot stat %s", retval);
			new_mode = sb.st_mode;
		    }
		}
		++p;
	    }
	    else
	    {
		strcpy (q, short_repos);
		if (CVS_MKDIR (retval, new_mode) < 0
		    && errno != EEXIST)
		    error (1, errno, "cannot make directory %s", retval);
		goto created;
	    }
	}
    created:;

	strcat (retval, "/");
	strcat (retval, name);

	if (saved_umask)
	{
	    assert (umask (save_umask) == 0000);
	    saved_umask = 0;
	}
    }
    return retval;
}

/*
 * Clean up all outstanding locks
 */
void
Lock_Cleanup ()
{
    /* FIXME: error handling here is kind of bogus; we sometimes will call
       error, which in turn can call us again.  For the moment work around
       this by refusing to reenter this function (this is a kludge).  */
    /* FIXME-reentrancy: the workaround isn't reentrant.  */
    static int in_lock_cleanup = 0;

    if (in_lock_cleanup)
	return;
    in_lock_cleanup = 1;

    remove_locks ();

    dellist (&lock_tree_list);

    if (locked_dir != NULL)
    {
	dellist (&locked_list);
	free (locked_dir);
	locked_dir = NULL;
	locked_list = NULL;
    }
    in_lock_cleanup = 0;
}

/*
 * Remove locks without discarding the lock information
 */
static void
remove_locks ()
{
    /* clean up simple locks (if any) */
    if (global_readlock.repository != NULL)
    {
	lock_simple_remove (&global_readlock);
	global_readlock.repository = NULL;
    }

    /* clean up multiple locks (if any) */
    if (locklist != (List *) NULL)
    {
	(void) walklist (locklist, unlock_proc, NULL);
	locklist = (List *) NULL;
    }
}

/*
 * walklist proc for removing a list of locks
 */
static int
unlock_proc (p, closure)
    Node *p;
    void *closure;
{
    lock_simple_remove ((struct lock *)p->data);
    return (0);
}

/* Remove the lock files.  */
static void
lock_simple_remove (lock)
    struct lock *lock;
{
    char *tmp;

    /* If readlock is set, the lock directory *might* have been created, but
       since Reader_Lock doesn't use SIG_beginCrSect the way that set_lock
       does, we don't know that.  That is why we need to check for
       existence_error here.  */
    if (readlock != NULL)
    {
	tmp = lock_name (lock->repository, readlock);
	if ( CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	free (tmp);
    }

    /* If writelock is set, the lock directory *might* have been created, but
       since write_lock doesn't use SIG_beginCrSect the way that set_lock
       does, we don't know that.  That is why we need to check for
       existence_error here.  */
    if (writelock != NULL)
    {
	tmp = lock_name (lock->repository, writelock);
	if ( CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	free (tmp);
    }

    if (lock->have_lckdir)
    {
	tmp = lock_name (lock->repository, CVSLCK);
	SIG_beginCrSect ();
	if (CVS_RMDIR (tmp) < 0)
	    error (0, errno, "failed to remove lock dir %s", tmp);
	lock->have_lckdir = 0;
	SIG_endCrSect ();
	free (tmp);
    }
}

/*
 * Create a lock file for readers
 */
int
Reader_Lock (xrepository)
    char *xrepository;
{
    int err = 0;
    FILE *fp;
    char *tmp;

    if (noexec || readonlyfs)
	return (0);

    /* we only do one directory at a time for read locks! */
    if (global_readlock.repository != NULL)
    {
	error (0, 0, "Reader_Lock called while read locks set - Help!");
	return (1);
    }

    if (readlock == NULL)
    {
	readlock = xmalloc (strlen (hostname) + sizeof (CVSRFL) + 40);
	(void) sprintf (readlock, 
#ifdef HAVE_LONG_FILE_NAMES
			"%s.%s.%ld", CVSRFL, hostname,
#else
			"%s.%ld", CVSRFL,
#endif
			(long) getpid ());
    }

    /* remember what we're locking (for Lock_Cleanup) */
    global_readlock.repository = xrepository;

    /* get the lock dir for our own */
    if (set_lock (&global_readlock, 1) != L_OK)
    {
	error (0, 0, "failed to obtain dir lock in repository `%s'",
	       xrepository);
	if (readlock != NULL)
	    free (readlock);
	readlock = NULL;
	/* We don't set global_readlock.repository to NULL.  I think this
	   only works because recurse.c will give a fatal error if we return
	   a nonzero value.  */
	return (1);
    }

    /* write a read-lock */
    tmp = lock_name (xrepository, readlock);
    if ((fp = CVS_FOPEN (tmp, "w+")) == NULL || fclose (fp) == EOF)
    {
	error (0, errno, "cannot create read lock in repository `%s'",
	       xrepository);
	if (readlock != NULL)
	    free (readlock);
	readlock = NULL;
	err = 1;
    }
    free (tmp);

    /* free the lock dir */
    clear_lock (&global_readlock);

    return (err);
}

/*
 * Lock a list of directories for writing
 */
static char *lock_error_repos;
static int lock_error;

static int Writer_Lock PROTO ((List * list));

static int
Writer_Lock (list)
    List *list;
{
    char *wait_repos;

    if (noexec)
	return (0);

    /* We only know how to do one list at a time */
    if (locklist != (List *) NULL)
    {
	error (0, 0, "Writer_Lock called while write locks set - Help!");
	return (1);
    }

    wait_repos = NULL;
    for (;;)
    {
	/* try to lock everything on the list */
	lock_error = L_OK;		/* init for set_writelock_proc */
	lock_error_repos = (char *) NULL; /* init for set_writelock_proc */
	locklist = list;		/* init for Lock_Cleanup */
	if (lockers_name != NULL)
	    free (lockers_name);
	lockers_name = xstrdup ("unknown");

	(void) walklist (list, set_writelock_proc, NULL);

	switch (lock_error)
	{
	    case L_ERROR:		/* Real Error */
		if (wait_repos != NULL)
		    free (wait_repos);
		Lock_Cleanup ();	/* clean up any locks we set */
		error (0, 0, "lock failed - giving up");
		return (1);

	    case L_LOCKED:		/* Someone already had a lock */
		remove_locks ();	/* clean up any locks we set */
		lock_wait (lock_error_repos); /* sleep a while and try again */
		wait_repos = xstrdup (lock_error_repos);
		continue;

	    case L_OK:			/* we got the locks set */
	        if (wait_repos != NULL)
		{
		    lock_obtained (wait_repos);
		    free (wait_repos);
		}
		return (0);

	    default:
		if (wait_repos != NULL)
		    free (wait_repos);
		error (0, 0, "unknown lock status %d in Writer_Lock",
		       lock_error);
		return (1);
	}
    }
}

/*
 * walklist proc for setting write locks
 */
static int
set_writelock_proc (p, closure)
    Node *p;
    void *closure;
{
    /* if some lock was not OK, just skip this one */
    if (lock_error != L_OK)
	return (0);

    /* apply the write lock */
    lock_error_repos = p->key;
    lock_error = write_lock ((struct lock *)p->data);
    return (0);
}

/*
 * Create a lock file for writers returns L_OK if lock set ok, L_LOCKED if
 * lock held by someone else or L_ERROR if an error occurred
 */
static int
write_lock (lock)
    struct lock *lock;
{
    int status;
    FILE *fp;
    char *tmp;

    if (writelock == NULL)
    {
	writelock = xmalloc (strlen (hostname) + sizeof (CVSWFL) + 40);
	(void) sprintf (writelock,
#ifdef HAVE_LONG_FILE_NAMES
			"%s.%s.%ld", CVSWFL, hostname,
#else
			"%s.%ld", CVSWFL,
#endif
			(long) getpid());
    }

    /* make sure the lock dir is ours (not necessarily unique to us!) */
    status = set_lock (lock, 0);
    if (status == L_OK)
    {
	/* we now own a writer - make sure there are no readers */
	if (readers_exist (lock->repository))
	{
	    /* clean up the lock dir if we created it */
	    if (status == L_OK)
	    {
		clear_lock (lock);
	    }

	    /* indicate we failed due to read locks instead of error */
	    return (L_LOCKED);
	}

	/* write the write-lock file */
	tmp = lock_name (lock->repository, writelock);
	if ((fp = CVS_FOPEN (tmp, "w+")) == NULL || fclose (fp) == EOF)
	{
	    int xerrno = errno;

	    if ( CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
		error (0, errno, "failed to remove lock %s", tmp);

	    /* free the lock dir if we created it */
	    if (status == L_OK)
	    {
		clear_lock (lock);
	    }

	    /* return the error */
	    error (0, xerrno, "cannot create write lock in repository `%s'",
		   lock->repository);
	    free (tmp);
	    return (L_ERROR);
	}
	free (tmp);
	return (L_OK);
    }
    else
	return (status);
}

/*
 * readers_exist() returns 0 if there are no reader lock files remaining in
 * the repository; else 1 is returned, to indicate that the caller should
 * sleep a while and try again.
 */
static int
readers_exist (repository)
    char *repository;
{
    char *line;
    DIR *dirp;
    struct dirent *dp;
    struct stat sb;
    int ret = 0;

#ifdef CVS_FUDGELOCKS
again:
#endif

    if ((dirp = CVS_OPENDIR (repository)) == NULL)
	error (1, 0, "cannot open directory %s", repository);

    errno = 0;
    while ((dp = CVS_READDIR (dirp)) != NULL)
    {
	if (CVS_FNMATCH (CVSRFLPAT, dp->d_name, 0) == 0)
	{
#ifdef CVS_FUDGELOCKS
	    time_t now;
	    (void) time (&now);
#endif

	    line = xmalloc (strlen (repository) + strlen (dp->d_name) + 5);
	    (void) sprintf (line, "%s/%s", repository, dp->d_name);
	    if ( CVS_STAT (line, &sb) != -1)
	    {
#ifdef CVS_FUDGELOCKS
		/*
		 * If the create time of the file is more than CVSLCKAGE 
		 * seconds ago, try to clean-up the lock file, and if
		 * successful, re-open the directory and try again.
		 */
		if (now >= (sb.st_ctime + CVSLCKAGE) && CVS_UNLINK (line) != -1)
		{
		    (void) CVS_CLOSEDIR (dirp);
		    free (line);
		    goto again;
		}
#endif
		set_lockers_name (&sb);
	    }
	    else
	    {
		/* If the file doesn't exist, it just means that it disappeared
		   between the time we did the readdir and the time we did
		   the stat.  */
		if (!existence_error (errno))
		    error (0, errno, "cannot stat %s", line);
	    }
	    errno = 0;
	    free (line);

	    ret = 1;
	    break;
	}
	errno = 0;
    }
    if (errno != 0)
	error (0, errno, "error reading directory %s", repository);

    CVS_CLOSEDIR (dirp);
    return (ret);
}

/*
 * Set the static variable lockers_name appropriately, based on the stat
 * structure passed in.
 */
static void
set_lockers_name (statp)
    struct stat *statp;
{
    struct passwd *pw;

    if (lockers_name != NULL)
	free (lockers_name);
    if ((pw = (struct passwd *) getpwuid (statp->st_uid)) !=
	(struct passwd *) NULL)
    {
	lockers_name = xstrdup (pw->pw_name);
    }
    else
    {
	lockers_name = xmalloc (20);
	(void) sprintf (lockers_name, "uid%lu", (unsigned long) statp->st_uid);
    }
}

/*
 * Persistently tries to make the directory "lckdir",, which serves as a
 * lock. If the create time on the directory is greater than CVSLCKAGE
 * seconds old, just try to remove the directory.
 */
static int
set_lock (lock, will_wait)
    struct lock *lock;
    int will_wait;
{
    int waited;
    struct stat sb;
    mode_t omask;
#ifdef CVS_FUDGELOCKS
    time_t now;
#endif

    if (masterlock != NULL)
	free (masterlock);
    masterlock = lock_name (lock->repository, CVSLCK);

    /*
     * Note that it is up to the callers of set_lock() to arrange for signal
     * handlers that do the appropriate things, like remove the lock
     * directory before they exit.
     */
    waited = 0;
    lock->have_lckdir = 0;
    for (;;)
    {
	int status = -1;
	omask = umask (cvsumask);
	SIG_beginCrSect ();
	if (CVS_MKDIR (masterlock, 0777) == 0)
	{
	    lock->have_lckdir = 1;
	    SIG_endCrSect ();
	    status = L_OK;
	    if (waited)
	        lock_obtained (lock->repository);
	    goto out;
	}
	SIG_endCrSect ();
      out:
	(void) umask (omask);
	if (status != -1)
	    return status;

	if (errno != EEXIST)
	{
	    error (0, errno,
		   "failed to create lock directory for `%s' (%s)",
		   lock->repository, masterlock);
	    return (L_ERROR);
	}

	/* Find out who owns the lock.  If the lock directory is
	   non-existent, re-try the loop since someone probably just
	   removed it (thus releasing the lock).  */
	if (CVS_STAT (masterlock, &sb) < 0)
	{
	    if (existence_error (errno))
		continue;

	    error (0, errno, "couldn't stat lock directory `%s'", masterlock);
	    return (L_ERROR);
	}

#ifdef CVS_FUDGELOCKS
	/*
	 * If the create time of the directory is more than CVSLCKAGE seconds
	 * ago, try to clean-up the lock directory, and if successful, just
	 * quietly retry to make it.
	 */
	(void) time (&now);
	if (now >= (sb.st_ctime + CVSLCKAGE))
	{
	    if (CVS_RMDIR (masterlock) >= 0)
		continue;
	}
#endif

	/* set the lockers name */
	set_lockers_name (&sb);

	/* if he wasn't willing to wait, return an error */
	if (!will_wait)
	    return (L_LOCKED);
	lock_wait (lock->repository);
	waited = 1;
    }
}

/*
 * Clear master lock.  We don't have to recompute the lock name since
 * clear_lock is never called except after a successful set_lock().
 */
static void
clear_lock (lock)
    struct lock *lock;
{
    SIG_beginCrSect ();
    if (CVS_RMDIR (masterlock) < 0)
	error (0, errno, "failed to remove lock dir `%s'", masterlock);
    lock->have_lckdir = 0;
    SIG_endCrSect ();
}

/*
 * Print out a message that the lock is still held, then sleep a while.
 */
static void
lock_wait (repos)
    char *repos;
{
    time_t now;
    char *msg;

    (void) time (&now);
    msg = xmalloc (100 + strlen (lockers_name) + strlen (repos));
    sprintf (msg, "[%8.8s] waiting for %s's lock in %s", ctime (&now) + 11,
	     lockers_name, repos);
    error (0, 0, "%s", msg);
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
    free (msg);
    (void) sleep (CVSLCKSLEEP);
}

/*
 * Print out a message when we obtain a lock.
 */
static void
lock_obtained (repos)
     char *repos;
{
    time_t now;
    char *msg;

    (void) time (&now);
    msg = xmalloc (100 + strlen (repos));
    sprintf (msg, "[%8.8s] obtained lock in %s", ctime (&now) + 11, repos);
    error (0, 0, "%s", msg);
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
    free (msg);
}

static int lock_filesdoneproc PROTO ((void *callerdat, int err,
				      char *repository, char *update_dir,
				      List *entries));

/*
 * Create a list of repositories to lock
 */
/* ARGSUSED */
static int
lock_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
    int err;
    char *repository;
    char *update_dir;
    List *entries;
{
    Node *p;

    p = getnode ();
    p->type = LOCK;
    p->key = xstrdup (repository);
    p->data = xmalloc (sizeof (struct lock));
    ((struct lock *)p->data)->repository = p->key;
    ((struct lock *)p->data)->have_lckdir = 0;

    /* FIXME-KRP: this error condition should not simply be passed by. */
    if (p->key == NULL || addnode (lock_tree_list, p) != 0)
	freenode (p);
    return (err);
}

void
lock_tree_for_write (argc, argv, local, which, aflag)
    int argc;
    char **argv;
    int local;
    int which;
    int aflag;
{
    int err;
    /*
     * Run the recursion processor to find all the dirs to lock and lock all
     * the dirs
     */
    lock_tree_list = getlist ();
    err = start_recursion ((FILEPROC) NULL, lock_filesdoneproc,
			   (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL, argc,
			   argv, local, which, aflag, 0, (char *) NULL, 0);
    sortlist (lock_tree_list, fsortcmp);
    if (Writer_Lock (lock_tree_list) != 0)
	error (1, 0, "lock failed - giving up");
}

/* Lock a single directory in REPOSITORY.  It is OK to call this if
   a lock has been set with lock_dir_for_write; the new lock will replace
   the old one.  If REPOSITORY is NULL, don't do anything.  */
void
lock_dir_for_write (repository)
     char *repository;
{
    if (repository != NULL
	&& (locked_dir == NULL
	    || strcmp (locked_dir, repository) != 0))
    {
	Node *node;

	if (locked_dir != NULL)
	    Lock_Cleanup ();

	locked_dir = xstrdup (repository);
	locked_list = getlist ();
	node = getnode ();
	node->type = LOCK;
	node->key = xstrdup (repository);
	node->data = xmalloc (sizeof (struct lock));
	((struct lock *)node->data)->repository = node->key;
	((struct lock *)node->data)->have_lckdir = 0;

	(void) addnode (locked_list, node);
	Writer_Lock (locked_list);
    }
}
@


1.13
log
@Integrate local changes
@
text
@d175 5
a179 4
	assert (CVSroot_directory != NULL);
	assert (strncmp (repository, CVSroot_directory,
			 strlen (CVSroot_directory)) == 0);
	short_repos = repository + strlen (CVSroot_directory) + 1;
d181 1
a181 1
	if (strcmp (repository, CVSroot_directory) == 0)
d637 1
a637 1
    while ((dp = readdir (dirp)) != NULL)
d658 1
a658 1
		    (void) closedir (dirp);
d684 1
a684 1
    closedir (dirp);
d894 1
a894 1
lock_tree_for_write (argc, argv, local, aflag)
d898 1
d909 1
a909 1
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 0);
@


1.12
log
@Integrate local changes
@
text
@d178 6
a183 2
	short_repos = repository + strlen (CVSroot_directory);
	assert (*short_repos++ == '/');
d762 2
a763 2
		   "failed to create lock directory in repository `%s'",
		   lock->repository);
@


1.11
log
@Integrate local changes
@
text
@d76 1
d138 139
d283 10
d304 1
d353 1
a353 2
	tmp = xmalloc (strlen (lock->repository) + strlen (readlock) + 10);
	(void) sprintf (tmp, "%s/%s", lock->repository, readlock);
d365 1
a365 2
	tmp = xmalloc (strlen (lock->repository) + strlen (writelock) + 10);
	(void) sprintf (tmp, "%s/%s", lock->repository, writelock);
d373 1
a373 2
	tmp = xmalloc (strlen (lock->repository) + sizeof (CVSLCK) + 10);
	(void) sprintf (tmp, "%s/%s", lock->repository, CVSLCK);
d434 1
a434 2
    tmp = xmalloc (strlen (xrepository) + strlen (readlock) + 10);
    (void) sprintf (tmp, "%s/%s", xrepository, readlock);
d582 1
a582 2
	tmp = xmalloc (strlen (lock->repository) + strlen (writelock) + 10);
	(void) sprintf (tmp, "%s/%s", lock->repository, writelock);
d726 1
a726 2
    masterlock = xmalloc (strlen (lock->repository) + sizeof (CVSLCK) + 10);
    (void) sprintf (masterlock, "%s/%s", lock->repository, CVSLCK);
d823 1
d826 4
a829 2
    error (0, 0, "[%8.8s] waiting for %s's lock in %s", ctime (&now) + 11,
	   lockers_name, repos);
d833 1
d845 1
d848 3
a850 1
    error (0, 0, "[%8.8s] obtained lock in %s", ctime (&now) + 11, repos);
d854 1
@


1.10
log
@Integrate local changes
@
text
@a706 1
static int fsortcmp PROTO((const Node * p, const Node * q));
a732 11
}

/*
 * compare two lock list nodes (for sort)
 */
static int
fsortcmp (p, q)
    const Node *p;
    const Node *q;
{
    return (strcmp (p->key, q->key));
@


1.9
log
@Integrate local changes
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d42 3
a44 3
   which it is in between the "rcs -i" and the RCS_checkin in commit.c
   (when a file is being added).  This state is a state in which the
   RCS file parsing routines in rcs.c cannot parse the file.
@


1.8
log
@Integrate local changes
@
text
@d488 1
a488 1
	if (fnmatch (CVSRFLPAT, dp->d_name, 0) == 0)
@


1.7
log
@Integrate local changes
@
text
@d104 12
a115 2
static char lockers_name[20];
static char readlock[PATH_MAX], writelock[PATH_MAX], masterlock[PATH_MAX];
d194 1
a194 1
    char tmp[PATH_MAX];
d200 1
a200 1
    if (readlock[0] != '\0')
d202 1
d206 1
d213 1
a213 1
    if (writelock[0] != '\0')
d215 1
d219 1
d224 1
d231 1
d244 1
a244 1
    char tmp[PATH_MAX];
d256 4
a259 2
    if (readlock[0] == '\0')
      (void) sprintf (readlock, 
d261 1
a261 1
		"%s.%s.%ld", CVSRFL, hostname,
d263 1
a263 1
		"%s.%ld", CVSRFL,
d265 2
a266 1
		(long) getpid ());
d276 3
a278 1
	readlock[0] = '\0';
d286 1
d292 3
a294 1
	readlock[0] = '\0';
d297 1
d336 3
a338 1
	(void) strcpy (lockers_name, "unknown");
d403 1
a403 1
    char tmp[PATH_MAX];
d405 3
a407 1
    if (writelock[0] == '\0')
d410 1
a410 1
	    "%s.%s.%ld", CVSWFL, hostname,
d412 1
a412 1
	    "%s.%ld", CVSWFL,
d414 2
a415 1
	(long) getpid());
d435 1
d453 1
d456 1
d547 2
d552 1
a552 1
	(void) strcpy (lockers_name, pw->pw_name);
d555 2
d558 1
d578 3
@


1.6
log
@Integrate local changes
@
text
@d77 16
d94 2
a95 2
static int set_lock PROTO((char *repository, int will_wait));
static void clear_lock PROTO((void));
d99 2
a100 2
static int write_lock PROTO((char *repository));
static void lock_simple_remove PROTO((char *repository));
a102 1
static int Check_Owner PROTO((char *lockdir));
a104 1
static char *repository;
a105 1
static int cleanup_lckdir;
d112 15
d133 19
d153 1
a153 1
    if (repository != NULL)
d155 2
a156 2
	lock_simple_remove (repository);
	repository = (char *) NULL;
d175 1
a175 1
    lock_simple_remove (p->key);
d179 1
a179 3
/*
 * Remove the lock files (without complaining if they are not there),
 */
d181 2
a182 2
lock_simple_remove (repository)
    char *repository;
d186 4
d192 1
a192 1
	(void) sprintf (tmp, "%s/%s", repository, readlock);
d197 4
d203 1
a203 1
	(void) sprintf (tmp, "%s/%s", repository, writelock);
d208 1
a208 6
    /*
     * Only remove the lock directory if it is ours, note that this does
     * lead to the limitation that one user ID should not be committing
     * files into the same Repository directory at the same time. Oh well.
     */
    if (writelock[0] != '\0' || (readlock[0] != '\0' && cleanup_lckdir)) 
d210 6
a215 10
	    (void) sprintf (tmp, "%s/%s", repository, CVSLCK);
    	    if (Check_Owner(tmp))
	    {
#ifdef AFSCVS
		char rmuidlock[PATH_MAX];
		sprintf(rmuidlock, "rm -f %s/uidlock%d", tmp, geteuid() );
		system(rmuidlock);
#endif
	    (void) CVS_RMDIR (tmp);
	    }
a216 1
    cleanup_lckdir = 0;
a219 32
 * Check the owner of a lock.  Returns 1 if we own it, 0 otherwise.
 */
static int
Check_Owner(lockdir)
     char *lockdir;
{
  struct stat sb;

#ifdef AFSCVS
  /* In the Andrew File System (AFS), user ids from stat don't match
     those from geteuid().  The AFSCVS code can deal with either AFS or
     non-AFS repositories; the non-AFSCVS code is faster.  */
  char uidlock[PATH_MAX];

  /* Check if the uidlock is in the lock directory */
  sprintf(uidlock, "%s/uidlock%d", lockdir, geteuid() );
  if( stat(uidlock, &sb) != -1)
    return 1;   /* The file exists, therefore we own the lock */
  else
    return 0; 	/* The file didn't exist or some other error.
		 * Assume that we don't own it.
		 */
#else
  if ( CVS_STAT (lockdir, &sb) != -1 && sb.st_uid == geteuid ())
    return 1;
  else
    return 0;
#endif
}  /* end Check_Owner() */


/*
d234 1
a234 1
    if (repository != NULL)
d249 2
a250 2
    /* remember what we're locking (for lock_cleanup) */
    repository = xrepository;
d253 1
a253 1
    if (set_lock (xrepository, 1) != L_OK)
d258 3
d275 1
a275 1
    clear_lock();
d285 4
a288 1
int
d325 1
a325 1
		Lock_Cleanup ();	/* clean up any locks we set */
d362 1
a362 1
    lock_error = write_lock (p->key);
d371 2
a372 2
write_lock (repository)
    char *repository;
d388 1
a388 1
    status = set_lock (repository, 0);
d392 1
a392 1
	if (readers_exist (repository))
d397 1
a397 1
		clear_lock();
d405 1
a405 1
	(void) sprintf (tmp, "%s/%s", repository, writelock);
d416 1
a416 1
		clear_lock();
d421 1
a421 1
		   repository);
d529 2
a530 2
set_lock (repository, will_wait)
    char *repository;
d540 1
a540 1
    (void) sprintf (masterlock, "%s/%s", repository, CVSLCK);
d548 1
a548 1
    cleanup_lckdir = 0;
d556 1
a556 19
#ifdef AFSCVS
	    char uidlock[PATH_MAX];
	    FILE *fp;

	    sprintf(uidlock, "%s/uidlock%d", masterlock, geteuid() );
	    if ((fp = CVS_FOPEN (uidlock, "w+")) == NULL)
	    {
		/* We failed to create the uidlock,
		   so rm masterlock and leave */
		CVS_RMDIR (masterlock);
		SIG_endCrSect ();
		status = L_ERROR;
		goto out;
	    }

	    /* We successfully created the uid lock, so close the file */
	    fclose(fp);
#endif
	    cleanup_lckdir = 1;
d560 1
a560 1
	        lock_obtained (repository);
d573 1
a573 1
		   repository);
a597 6
#ifdef AFSCVS
	  /* Remove the uidlock first */
	  char rmuidlock[PATH_MAX];
	  sprintf(rmuidlock, "rm -f %s/uidlock%d", masterlock, geteuid() );
	  system(rmuidlock);
#endif
d609 1
a609 1
	lock_wait (repository);
d619 2
a620 1
clear_lock()
d622 1
a622 6
#ifdef AFSCVS
  /* Remove the uidlock first */
  char rmuidlock[PATH_MAX];
  sprintf(rmuidlock, "rm -f %s/uidlock%d", masterlock, geteuid() );
  system(rmuidlock);
#endif
d625 2
a626 1
    cleanup_lckdir = 0;
a667 2
static List *lock_tree_list;

d685 4
d726 4
a729 1

d731 2
a732 1
lock_tree_cleanup ()
d734 21
a754 2
    Lock_Cleanup ();
    dellist (&lock_tree_list);
@


1.5
log
@Integrate local changes to CVS; remove files no longer part of the CVS
distribution
@
text
@d13 62
d86 1
d144 1
a144 1
	if (unlink (tmp) < 0 && ! existence_error (errno))
d151 1
a151 1
	if (unlink (tmp) < 0 && ! existence_error (errno))
d170 1
a170 1
	    (void) rmdir (tmp);
d200 1
a200 1
  if (stat (lockdir, &sb) != -1 && sb.st_uid == geteuid ())
d252 1
a252 1
    if ((fp = fopen (tmp, "w+")) == NULL || fclose (fp) == EOF)
d275 2
d287 1
d301 2
d310 1
d314 5
d322 2
d389 1
a389 1
	if ((fp = fopen (tmp, "w+")) == NULL || fclose (fp) == EOF)
d393 1
a393 1
	    if (unlink (tmp) < 0 && ! existence_error (errno))
d432 1
a432 1
    if ((dirp = opendir (repository)) == NULL)
d447 1
a447 1
	    if (stat (line, &sb) != -1)
d455 1
a455 1
		if (now >= (sb.st_ctime + CVSLCKAGE) && unlink (line) != -1)
d516 1
d530 1
d544 1
a544 1
	    if ((fp = fopen(uidlock, "w+")) == NULL)
d548 1
a548 1
		rmdir(masterlock);
d560 2
d578 4
a581 5
	/*
	 * stat the dir - if it is non-existent, re-try the loop since
	 * someone probably just removed it (thus releasing the lock)
	 */
	if (stat (masterlock, &sb) < 0)
d605 1
a605 1
	    if (rmdir (masterlock) >= 0)
d617 1
d634 1
a634 1
    if (rmdir (masterlock) < 0)
d651 3
d656 16
d673 3
a675 2
static int lock_filesdoneproc PROTO ((int err, char *repository,
				      char *update_dir));
d685 2
a686 1
lock_filesdoneproc (err, repository, update_dir)
d690 1
d728 2
a729 3
			   (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, argc,
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 0,
			   0);
@


1.4
log
@Integrate local changes to CVS
@
text
@d22 1
a22 1
static void unlock PROTO((char *repository));
d45 1
a45 1
	unlock (repository);
d65 1
a65 1
    unlock (p->key);
d73 1
a73 1
unlock (repository)
d169 1
a169 1
		"%s.%s.%d", CVSRFL, hostname,
d171 1
a171 1
		"%s.%d", CVSRFL,
d173 1
a173 1
		getpid ());
a177 22
#ifdef BOGUS_UNLESS_PROVEN_OTHERWISE
    /* make sure we can write the repository */
    (void) sprintf (tmp,
#ifdef HAVE_LONG_FILE_NAMES
	"%s/%s.%s.%d", xrepository, CVSTFL, hostname,
#else
	"%s/%s.%d", xrepository, CVSTFL,
#endif
	getpid());
    if ((fp = fopen (tmp, "w+")) == NULL || fclose (fp) == EOF)
    {
	error (0, errno, "cannot create read lock in repository `%s'",
	       xrepository);
	readlock[0] = '\0';
	if (unlink (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	return (1);
    }
    if (unlink (tmp) < 0)
	error (0, errno, "failed to remove lock %s", tmp);
#endif

d288 1
a288 11
	    "%s.%s.%d", CVSWFL, hostname,
#else
	    "%s.%d", CVSWFL,
#endif
	getpid());

#ifdef BOGUS_UNLESS_PROVEN_OTHERWISE
    /* make sure we can write the repository */
    (void) sprintf (tmp,
#ifdef HAVE_LONG_FILE_NAMES
	"%s/%s.%s.%d", repository, CVSTFL, hostname,
d290 1
a290 13
	"%s/%s.%d", repository, CVSTFL,
#endif
	getpid ());
    if ((fp = fopen (tmp, "w+")) == NULL || fclose (fp) == EOF)
    {
	error (0, errno, "cannot create write lock in repository `%s'",
	       repository);
	if (unlink (tmp) < 0 && ! existence_error (errno))
	    error (0, errno, "failed to remove lock %s", tmp);
	return (L_ERROR);
    }
    if (unlink (tmp) < 0)
	error (0, errno, "failed to remove lock %s", tmp);
d292 1
@


1.3
log
@Integrate local changes
@
text
@a14 5
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)lock.c 1.50 94/09/30 $";
USE(rcsid);
#endif

d431 9
@


1.2
log
@CVSREADONLYFS environment variable short-circuits read-only lock requirements
@
text
@a19 2
extern char *ctime ();

d29 1
a81 1
    struct stat sb;
d86 1
a86 1
	if (unlink (tmp) < 0 && errno != ENOENT)
d93 1
a93 1
	if (unlink (tmp) < 0 && errno != ENOENT)
d104 8
a111 3
	(void) sprintf (tmp, "%s/%s", repository, CVSLCK);
	if (stat (tmp, &sb) != -1 && sb.st_uid == geteuid ())
	{
d113 1
a113 1
	}
d119 32
d197 1
a197 1
	if (unlink (tmp) < 0 && errno != ENOENT)
d334 1
a334 1
	if (unlink (tmp) < 0 && errno != ENOENT)
d365 1
a365 1
	    if (unlink (tmp) < 0 && errno != ENOENT)
d394 1
a394 1
    char line[MAXLINELEN];
d417 1
d430 1
d436 1
d480 1
d495 2
d500 18
d520 2
a521 1
	    return (L_OK);
d524 4
d543 1
a543 1
	    if (errno == ENOENT)
d559 6
d587 6
d611 67
@


1.1
log
@Initial revision
@
text
@d126 1
a126 1
    if (noexec)
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d20 2
a30 1
static int Check_Owner PROTO((char *lockdir));
d83 1
d88 1
a88 1
	if (unlink (tmp) < 0 && ! existence_error (errno))
d95 1
a95 1
	if (unlink (tmp) < 0 && ! existence_error (errno))
d106 3
a108 8
	    (void) sprintf (tmp, "%s/%s", repository, CVSLCK);
    	    if (Check_Owner(tmp))
	    {
#ifdef AFSCVS
		char rmuidlock[PATH_MAX];
		sprintf(rmuidlock, "rm -f %s/uidlock%d", tmp, geteuid() );
		system(rmuidlock);
#endif
d110 1
a110 1
	    }
a115 32
 * Check the owner of a lock.  Returns 1 if we own it, 0 otherwise.
 */
static int
Check_Owner(lockdir)
     char *lockdir;
{
  struct stat sb;

#ifdef AFSCVS
  /* In the Andrew File System (AFS), user ids from stat don't match
     those from geteuid().  The AFSCVS code can deal with either AFS or
     non-AFS repositories; the non-AFSCVS code is faster.  */
  char uidlock[PATH_MAX];

  /* Check if the uidlock is in the lock directory */
  sprintf(uidlock, "%s/uidlock%d", lockdir, geteuid() );
  if( stat(uidlock, &sb) != -1)
    return 1;   /* The file exists, therefore we own the lock */
  else
    return 0; 	/* The file didn't exist or some other error.
		 * Assume that we don't own it.
		 */
#else
  if (stat (lockdir, &sb) != -1 && sb.st_uid == geteuid ())
    return 1;
  else
    return 0;
#endif
}  /* end Check_Owner() */


/*
d162 1
a162 1
	if (unlink (tmp) < 0 && ! existence_error (errno))
d299 1
a299 1
	if (unlink (tmp) < 0 && ! existence_error (errno))
d330 1
a330 1
	    if (unlink (tmp) < 0 && ! existence_error (errno))
d359 1
a359 1
    char *line;
a381 1
	    line = xmalloc (strlen (repository) + strlen (dp->d_name) + 5);
a393 1
		    free (line);
a398 1
	    free (line);
a441 1
    mode_t omask;
a455 2
	int status = -1;
	omask = umask (cvsumask);
a458 18
#ifdef AFSCVS
	    char uidlock[PATH_MAX];
	    FILE *fp;

	    sprintf(uidlock, "%s/uidlock%d", masterlock, geteuid() );
	    if ((fp = fopen(uidlock, "w+")) == NULL)
	    {
		/* We failed to create the uidlock,
		   so rm masterlock and leave */
		rmdir(masterlock);
		SIG_endCrSect ();
		status = L_ERROR;
		goto out;
	    }

	    /* We successfully created the uid lock, so close the file */
	    fclose(fp);
#endif
d461 1
a461 2
	    status = L_OK;
	    goto out;
a463 4
      out:
	(void) umask (omask);
	if (status != -1)
	    return status;
d479 1
a479 1
	    if (existence_error (errno))
a494 6
#ifdef AFSCVS
	  /* Remove the uidlock first */
	  char rmuidlock[PATH_MAX];
	  sprintf(rmuidlock, "rm -f %s/uidlock%d", masterlock, geteuid() );
	  system(rmuidlock);
#endif
a516 6
#ifdef AFSCVS
  /* Remove the uidlock first */
  char rmuidlock[PATH_MAX];
  sprintf(rmuidlock, "rm -f %s/uidlock%d", masterlock, geteuid() );
  system(rmuidlock);
#endif
a534 67
}

static int lock_filesdoneproc PROTO ((int err, char *repository,
				      char *update_dir));
static int fsortcmp PROTO((const Node * p, const Node * q));

static List *lock_tree_list;

/*
 * Create a list of repositories to lock
 */
/* ARGSUSED */
static int
lock_filesdoneproc (err, repository, update_dir)
    int err;
    char *repository;
    char *update_dir;
{
    Node *p;

    p = getnode ();
    p->type = LOCK;
    p->key = xstrdup (repository);
    /* FIXME-KRP: this error condition should not simply be passed by. */
    if (p->key == NULL || addnode (lock_tree_list, p) != 0)
	freenode (p);
    return (err);
}

/*
 * compare two lock list nodes (for sort)
 */
static int
fsortcmp (p, q)
    const Node *p;
    const Node *q;
{
    return (strcmp (p->key, q->key));
}

void
lock_tree_for_write (argc, argv, local, aflag)
    int argc;
    char **argv;
    int local;
    int aflag;
{
    int err;
    /*
     * Run the recursion processor to find all the dirs to lock and lock all
     * the dirs
     */
    lock_tree_list = getlist ();
    err = start_recursion ((FILEPROC) NULL, lock_filesdoneproc,
			   (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, argc,
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 0,
			   0);
    sortlist (lock_tree_list, fsortcmp);
    if (Writer_Lock (lock_tree_list) != 0)
	error (1, 0, "lock failed - giving up");
}

void
lock_tree_cleanup ()
{
    Lock_Cleanup ();
    dellist (&lock_tree_list);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d15 5
a435 9
	    else
	    {
		/* If the file doesn't exist, it just means that it disappeared
		   between the time we did the readdir and the time we did
		   the stat.  */
		if (!existence_error (errno))
		    error (0, errno, "cannot stat %s", line);
	    }
	    errno = 0;
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d22 1
a22 1
static void lock_simple_remove PROTO((char *repository));
d45 1
a45 1
	lock_simple_remove (repository);
d65 1
a65 1
    lock_simple_remove (p->key);
d73 1
a73 1
lock_simple_remove (repository)
d169 1
a169 1
		"%s.%s.%ld", CVSRFL, hostname,
d171 1
a171 1
		"%s.%ld", CVSRFL,
d173 1
a173 1
		(long) getpid ());
d178 22
d310 11
a320 1
	    "%s.%s.%ld", CVSWFL, hostname,
d322 13
a334 1
	    "%s.%ld", CVSWFL,
a335 1
	(long) getpid());
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a12 62
/* The node Concurrency in doc/cvs.texinfo has a brief introduction to
   how CVS locks function, and some of the user-visible consequences of
   their existence.  Here is a summary of why they exist (and therefore,
   the consequences of hacking CVS to read a repository without creating
   locks):

   There are two uses.  One is the ability to prevent there from being
   two writers at the same time.  This is necessary for any number of
   reasons (fileattr code, probably others).  Commit needs to lock the
   whole tree so that nothing happens between the up-to-date check and
   the actual checkin.

   The second use is the ability to ensure that there is not a writer
   and a reader at the same time (several readers are allowed).  Reasons
   for this are:

   * Readlocks ensure that once CVS has found a collection of rcs
   files using Find_Names, the files will still exist when it reads
   them (they may have moved in or out of the attic).

   * Readlocks provide some modicum of consistency, although this is
   kind of limited--see the node Concurrency in cvs.texinfo.

   * Readlocks ensure that the RCS file does not change between
   RCS_parse and RCS_reparsercsfile time.  This one strikes me as
   important, although I haven't thought up what bad scenarios might
   be.

   * Readlocks ensure that we won't find the file in the state in
   which it is in between the "rcs -i" and the RCS_checkin in commit.c
   (when a file is being added).  This state is a state in which the
   RCS file parsing routines in rcs.c cannot parse the file.

   * Readlocks ensure that a reader won't try to look at a
   half-written fileattr file (fileattr is not updated atomically).

   (see also the description of anonymous read-only access in
   "Password authentication security" node in doc/cvs.texinfo).

   While I'm here, I'll try to summarize a few random suggestions
   which periodically get made about how locks might be different:

   1.  Check for EROFS.  Maybe useful, although in the presence of NFS
   EROFS does *not* mean that the file system is unchanging.

   2.  Provide a means to put the cvs locks in some directory apart from
   the repository (CVSROOT/locks; a -l option in modules; etc.).

   3.  Provide an option to disable locks for operations which only
   read (see above for some of the consequences).

   4.  Have a server internally do the locking.  Probably a good
   long-term solution, and many people have been working hard on code
   changes which would eventually make it possible to have a server
   which can handle various connections in one process, but there is
   much, much work still to be done before this is feasible.

   5.  Like #4 but use shared memory or something so that the servers
   merely need to all be on the same machine.  This is a much smaller
   change to CVS (it functions much like #2; shared memory might be an
   unneeded complication although it presumably would be faster).  */

a23 1
static void lock_obtained PROTO((char *repository));
d81 1
a81 1
	if ( CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
d88 1
a88 1
	if ( CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
d107 1
a107 1
	    (void) CVS_RMDIR (tmp);
d137 1
a137 1
  if ( CVS_STAT (lockdir, &sb) != -1 && sb.st_uid == geteuid ())
d189 1
a189 1
    if ((fp = CVS_FOPEN (tmp, "w+")) == NULL || fclose (fp) == EOF)
a211 2
    char *wait_repos;

a221 1
    wait_repos = NULL;
a234 2
		if (wait_repos != NULL)
		    free (wait_repos);
a241 1
		wait_repos = xstrdup (lock_error_repos);
a244 5
	        if (wait_repos != NULL)
		{
		    lock_obtained (wait_repos);
		    free (wait_repos);
		}
a247 2
		if (wait_repos != NULL)
		    free (wait_repos);
d313 1
a313 1
	if ((fp = CVS_FOPEN (tmp, "w+")) == NULL || fclose (fp) == EOF)
d317 1
a317 1
	    if ( CVS_UNLINK (tmp) < 0 && ! existence_error (errno))
d356 1
a356 1
    if ((dirp = CVS_OPENDIR (repository)) == NULL)
d371 1
a371 1
	    if ( CVS_STAT (line, &sb) != -1)
d379 1
a379 1
		if (now >= (sb.st_ctime + CVSLCKAGE) && CVS_UNLINK (line) != -1)
a439 1
    int waited;
a452 1
    waited = 0;
d466 1
a466 1
	    if ((fp = CVS_FOPEN (uidlock, "w+")) == NULL)
d470 1
a470 1
		CVS_RMDIR (masterlock);
a481 2
	    if (waited)
	        lock_obtained (repository);
d498 5
a502 4
	/* Find out who owns the lock.  If the lock directory is
	   non-existent, re-try the loop since someone probably just
	   removed it (thus releasing the lock).  */
	if (CVS_STAT (masterlock, &sb) < 0)
d526 1
a526 1
	    if (CVS_RMDIR (masterlock) >= 0)
a537 1
	waited = 1;
d554 1
a554 1
    if (CVS_RMDIR (masterlock) < 0)
a570 3
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
a572 16

/*
 * Print out a message when we obtain a lock.
 */
static void
lock_obtained (repos)
     char *repos;
{
    time_t now;

    (void) time (&now);
    error (0, 0, "[%8.8s] obtained lock in %s", ctime (&now) + 11, repos);
    /* Call cvs_flusherr to ensure that the user sees this message as
       soon as possible.  */
    cvs_flusherr ();
}
d574 2
a575 3
static int lock_filesdoneproc PROTO ((void *callerdat, int err,
				      char *repository, char *update_dir,
				      List *entries));
d585 1
a585 2
lock_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
a588 1
    List *entries;
d626 3
a628 2
			   (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL, argc,
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 0);
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a76 16
struct lock {
    /* This is the directory in which we may have a lock named by the
       readlock variable, a lock named by the writelock variable, and/or
       a lock named CVSLCK.  The storage is not allocated along with the
       struct lock; it is allocated by the Reader_Lock caller or in the
       case of writelocks, it is just a pointer to the storage allocated
       for the ->key field.  */
    char *repository;
    /* Do we have a lock named CVSLCK?  */
    int have_lckdir;
    /* Note there is no way of knowing whether the readlock and writelock
       exist.  The code which sets the locks doesn't use SIG_beginCrSect
       to set a flag like we do for CVSLCK.  */
};

static void remove_locks PROTO((void));
d78 2
a79 2
static int set_lock PROTO ((struct lock *lock, int will_wait));
static void clear_lock PROTO ((struct lock *lock));
d83 2
a84 2
static int write_lock PROTO ((struct lock *lock));
static void lock_simple_remove PROTO ((struct lock *lock));
d87 1
d90 1
d92 1
a98 15
/* This is the (single) readlock which is set by Reader_Lock.  The
   repository field is NULL if there is no such lock.  */
static struct lock global_readlock;

/* List of locks set by lock_tree_for_write.  This is redundant
   with locklist, sort of.  */
static List *lock_tree_list;

/* If we set locks with lock_dir_for_write, then locked_dir contains
   the malloc'd name of the repository directory which we have locked.
   locked_list is the same thing packaged into a list and is redundant
   with locklist the same way that lock_tree_list is.  */
static char *locked_dir;
static List *locked_list;

a104 19
    remove_locks ();

    dellist (&lock_tree_list);

    if (locked_dir != NULL)
    {
	dellist (&locked_list);
	free (locked_dir);
	locked_dir = NULL;
	locked_list = NULL;
    }
}

/*
 * Remove locks without discarding the lock information
 */
static void
remove_locks ()
{
d106 1
a106 1
    if (global_readlock.repository != NULL)
d108 2
a109 2
	lock_simple_remove (&global_readlock);
	global_readlock.repository = NULL;
d128 1
a128 1
    lock_simple_remove ((struct lock *)p->data);
d132 3
a134 1
/* Remove the lock files.  */
d136 2
a137 2
lock_simple_remove (lock)
    struct lock *lock;
a140 4
    /* If readlock is set, the lock directory *might* have been created, but
       since Reader_Lock doesn't use SIG_beginCrSect the way that set_lock
       does, we don't know that.  That is why we need to check for
       existence_error here.  */
d143 1
a143 1
	(void) sprintf (tmp, "%s/%s", lock->repository, readlock);
a147 4
    /* If writelock is set, the lock directory *might* have been created, but
       since write_lock doesn't use SIG_beginCrSect the way that set_lock
       does, we don't know that.  That is why we need to check for
       existence_error here.  */
d150 1
a150 1
	(void) sprintf (tmp, "%s/%s", lock->repository, writelock);
d155 6
a160 1
    if (lock->have_lckdir)
d162 10
a171 6
	(void) sprintf (tmp, "%s/%s", lock->repository, CVSLCK);
	SIG_beginCrSect ();
	if (CVS_RMDIR (tmp) < 0)
	    error (0, errno, "failed to remove lock dir %s", tmp);
	lock->have_lckdir = 0;
	SIG_endCrSect ();
d173 1
d177 32
d223 1
a223 1
    if (global_readlock.repository != NULL)
d238 2
a239 2
    /* remember what we're locking (for Lock_Cleanup) */
    global_readlock.repository = xrepository;
d242 1
a242 1
    if (set_lock (&global_readlock, 1) != L_OK)
a246 3
	/* We don't set global_readlock.repository to NULL.  I think this
	   only works because recurse.c will give a fatal error if we return
	   a nonzero value.  */
d261 1
a261 1
    clear_lock (&global_readlock);
d271 1
a271 4

static int Writer_Lock PROTO ((List * list));

static int
d308 1
a308 1
		remove_locks ();	/* clean up any locks we set */
d345 1
a345 1
    lock_error = write_lock ((struct lock *)p->data);
d354 2
a355 2
write_lock (lock)
    struct lock *lock;
d371 1
a371 1
    status = set_lock (lock, 0);
d375 1
a375 1
	if (readers_exist (lock->repository))
d380 1
a380 1
		clear_lock (lock);
d388 1
a388 1
	(void) sprintf (tmp, "%s/%s", lock->repository, writelock);
d399 1
a399 1
		clear_lock (lock);
d404 1
a404 1
		   lock->repository);
d512 2
a513 2
set_lock (lock, will_wait)
    struct lock *lock;
d523 1
a523 1
    (void) sprintf (masterlock, "%s/%s", lock->repository, CVSLCK);
d531 1
a531 1
    lock->have_lckdir = 0;
d539 19
a557 1
	    lock->have_lckdir = 1;
d561 1
a561 1
	        lock_obtained (lock->repository);
d574 1
a574 1
		   lock->repository);
d599 6
d616 1
a616 1
	lock_wait (lock->repository);
d626 1
a626 2
clear_lock (lock)
    struct lock *lock;
d628 6
a633 1
    SIG_beginCrSect ();
d636 1
a636 2
    lock->have_lckdir = 0;
    SIG_endCrSect ();
d678 2
a696 4
    p->data = xmalloc (sizeof (struct lock));
    ((struct lock *)p->data)->repository = p->key;
    ((struct lock *)p->data)->have_lckdir = 0;

d734 1
a734 4

/* Lock a single directory in REPOSITORY.  It is OK to call this if
   a lock has been set with lock_dir_for_write; the new lock will replace
   the old one.  If REPOSITORY is NULL, don't do anything.  */
d736 1
a736 2
lock_dir_for_write (repository)
     char *repository;
d738 2
a739 21
    if (repository != NULL
	&& (locked_dir == NULL
	    || strcmp (locked_dir, repository) != 0))
    {
	Node *node;

	if (locked_dir != NULL)
	    Lock_Cleanup ();

	locked_dir = xstrdup (repository);
	locked_list = getlist ();
	node = getnode ();
	node->type = LOCK;
	node->key = xstrdup (repository);
	node->data = xmalloc (sizeof (struct lock));
	((struct lock *)node->data)->repository = node->key;
	((struct lock *)node->data)->have_lckdir = 0;

	(void) addnode (locked_list, node);
	Writer_Lock (locked_list);
    }
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d104 2
a105 12
/* Malloc'd array containing the username of the whoever has the lock.
   Will always be non-NULL in the cases where it is needed.  */
static char *lockers_name;
/* Malloc'd array specifying name of a readlock within a directory.
   Or NULL if none.  */
static char *readlock;
/* Malloc'd array specifying name of a writelock within a directory.
   Or NULL if none.  */
static char *writelock;
/* Malloc'd array specifying the name of a CVSLCK file (absolute pathname).
   Will always be non-NULL in the cases where it is used.  */
static char *masterlock;
d184 1
a184 1
    char *tmp;
d190 1
a190 1
    if (readlock != NULL)
a191 1
	tmp = xmalloc (strlen (lock->repository) + strlen (readlock) + 10);
a194 1
	free (tmp);
d201 1
a201 1
    if (writelock != NULL)
a202 1
	tmp = xmalloc (strlen (lock->repository) + strlen (writelock) + 10);
a205 1
	free (tmp);
a209 1
	tmp = xmalloc (strlen (lock->repository) + sizeof (CVSLCK) + 10);
a215 1
	free (tmp);
d228 1
a228 1
    char *tmp;
d240 2
a241 4
    if (readlock == NULL)
    {
	readlock = xmalloc (strlen (hostname) + sizeof (CVSRFL) + 40);
	(void) sprintf (readlock, 
d243 1
a243 1
			"%s.%s.%ld", CVSRFL, hostname,
d245 1
a245 1
			"%s.%ld", CVSRFL,
d247 1
a247 2
			(long) getpid ());
    }
d257 1
a257 3
	if (readlock != NULL)
	    free (readlock);
	readlock = NULL;
a264 1
    tmp = xmalloc (strlen (xrepository) + strlen (readlock) + 10);
d270 1
a270 3
	if (readlock != NULL)
	    free (readlock);
	readlock = NULL;
a272 1
    free (tmp);
d311 1
a311 3
	if (lockers_name != NULL)
	    free (lockers_name);
	lockers_name = xstrdup ("unknown");
d376 1
a376 1
    char *tmp;
d378 1
a378 3
    if (writelock == NULL)
    {
	writelock = xmalloc (strlen (hostname) + sizeof (CVSWFL) + 40);
d381 1
a381 1
			"%s.%s.%ld", CVSWFL, hostname,
d383 1
a383 1
			"%s.%ld", CVSWFL,
d385 1
a385 2
			(long) getpid());
    }
a404 1
	tmp = xmalloc (strlen (lock->repository) + strlen (writelock) + 10);
a421 1
	    free (tmp);
a423 1
	free (tmp);
a513 2
    if (lockers_name != NULL)
	free (lockers_name);
d517 1
a517 1
	lockers_name = xstrdup (pw->pw_name);
a519 2
    {
	lockers_name = xmalloc (20);
a520 1
    }
a539 3
    if (masterlock != NULL)
	free (masterlock);
    masterlock = xmalloc (strlen (lock->repository) + sizeof (CVSLCK) + 10);
@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@d488 1
a488 1
	if (CVS_FNMATCH (CVSRFLPAT, dp->d_name, 0) == 0)
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d42 3
a44 3
   which it is in between the calls to add_rcs_file and RCS_checkin in
   commit.c (when a file is being added).  This state is a state in
   which the RCS file parsing routines in rcs.c cannot parse the file.
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d707 1
d734 11
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a75 1
#include <assert.h>
a136 139
/* LockDir from CVSROOT/config.  */
char *lock_dir;

static char *lock_name PROTO ((char *repository, char *name));

/* Return a newly malloc'd string containing the name of the lock for the
   repository REPOSITORY and the lock file name within that directory
   NAME.  Also create the directories in which to put the lock file
   if needed (if we need to, could save system call(s) by doing
   that only if the actual operation fails.  But for now we'll keep
   things simple).  */
static char *
lock_name (repository, name)
    char *repository;
    char *name;
{
    char *retval;
    char *p;
    char *q;
    char *short_repos;
    mode_t save_umask;
    int saved_umask = 0;

    if (lock_dir == NULL)
    {
	/* This is the easy case.  Because the lock files go directly
	   in the repository, no need to create directories or anything.  */
	retval = xmalloc (strlen (repository) + strlen (name) + 10);
	(void) sprintf (retval, "%s/%s", repository, name);
    }
    else
    {
	struct stat sb;
	mode_t new_mode = 0;

	/* The interesting part of the repository is the part relative
	   to CVSROOT.  */
	assert (CVSroot_directory != NULL);
	assert (strncmp (repository, CVSroot_directory,
			 strlen (CVSroot_directory)) == 0);
	short_repos = repository + strlen (CVSroot_directory);
	assert (*short_repos++ == '/');

	retval = xmalloc (strlen (lock_dir)
			  + strlen (short_repos)
			  + strlen (name)
			  + 10);
	strcpy (retval, lock_dir);
	q = retval + strlen (retval);
	*q++ = '/';

	strcpy (q, short_repos);

	/* In the common case, where the directory already exists, let's
	   keep it to one system call.  */
	if (CVS_STAT (retval, &sb) < 0)
	{
	    /* If we need to be creating more than one directory, we'll
	       get the existence_error here.  */
	    if (!existence_error (errno))
		error (1, errno, "cannot stat directory %s", retval);
	}
	else
	{
	    if (S_ISDIR (sb.st_mode))
		goto created;
	    else
		error (1, 0, "%s is not a directory", retval);
	}

	/* Now add the directories one at a time, so we can create
	   them if needed.

	   The idea behind the new_mode stuff is that the directory we
	   end up creating will inherit permissions from its parent
	   directory (we re-set new_mode with each EEXIST).  CVSUMASK
	   isn't right, because typically the reason for LockDir is to
	   use a different set of permissions.  We probably want to
	   inherit group ownership also (but we don't try to deal with
	   that, some systems do it for us either always or when g+s is on).

	   We don't try to do anything about the permissions on the lock
	   files themselves.  The permissions don't really matter so much
	   because the locks will generally be removed by the process
	   which created them.  */

	if (CVS_STAT (lock_dir, &sb) < 0)
	    error (1, errno, "cannot stat %s", lock_dir);
	new_mode = sb.st_mode;
	save_umask = umask (0000);
	saved_umask = 1;

	p = short_repos;
	while (1)
	{
	    while (!ISDIRSEP (*p) && *p != '\0')
		++p;
	    if (ISDIRSEP (*p))
	    {
		strncpy (q, short_repos, p - short_repos);
		q[p - short_repos] = '\0';
		if (!ISDIRSEP (q[p - short_repos - 1])
		    && CVS_MKDIR (retval, new_mode) < 0)
		{
		    int saved_errno = errno;
		    if (saved_errno != EEXIST)
			error (1, errno, "cannot make directory %s", retval);
		    else
		    {
			if (CVS_STAT (retval, &sb) < 0)
			    error (1, errno, "cannot stat %s", retval);
			new_mode = sb.st_mode;
		    }
		}
		++p;
	    }
	    else
	    {
		strcpy (q, short_repos);
		if (CVS_MKDIR (retval, new_mode) < 0
		    && errno != EEXIST)
		    error (1, errno, "cannot make directory %s", retval);
		goto created;
	    }
	}
    created:;

	strcat (retval, "/");
	strcat (retval, name);

	if (saved_umask)
	{
	    assert (umask (save_umask) == 0000);
	    saved_umask = 0;
	}
    }
    return retval;
}

a142 10
    /* FIXME: error handling here is kind of bogus; we sometimes will call
       error, which in turn can call us again.  For the moment work around
       this by refusing to reenter this function (this is a kludge).  */
    /* FIXME-reentrancy: the workaround isn't reentrant.  */
    static int in_lock_cleanup = 0;

    if (in_lock_cleanup)
	return;
    in_lock_cleanup = 1;

a153 1
    in_lock_cleanup = 0;
d202 2
a203 1
	tmp = lock_name (lock->repository, readlock);
d215 2
a216 1
	tmp = lock_name (lock->repository, writelock);
d224 2
a225 1
	tmp = lock_name (lock->repository, CVSLCK);
d286 2
a287 1
    tmp = lock_name (xrepository, readlock);
d435 2
a436 1
	tmp = lock_name (lock->repository, writelock);
d580 2
a581 1
    masterlock = lock_name (lock->repository, CVSLCK);
a677 1
    char *msg;
d680 2
a681 4
    msg = xmalloc (100 + strlen (lockers_name) + strlen (repos));
    sprintf (msg, "[%8.8s] waiting for %s's lock in %s", ctime (&now) + 11,
	     lockers_name, repos);
    error (0, 0, "%s", msg);
a684 1
    free (msg);
a695 1
    char *msg;
d698 1
a698 3
    msg = xmalloc (100 + strlen (repos));
    sprintf (msg, "[%8.8s] obtained lock in %s", ctime (&now) + 11, repos);
    error (0, 0, "%s", msg);
a701 1
    free (msg);
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d178 2
a179 6
	short_repos = repository + strlen (CVSroot_directory) + 1;

	if (strcmp (repository, CVSroot_directory) == 0)
	    short_repos = ".";
	else
	    assert (short_repos[-1] == '/');
d758 2
a759 2
		   "failed to create lock directory for `%s' (%s)",
		   lock->repository, masterlock);
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@d175 4
a178 5
	assert (current_parsed_root != NULL);
	assert (current_parsed_root->directory != NULL);
	assert (strncmp (repository, current_parsed_root->directory,
			 strlen (current_parsed_root->directory)) == 0);
	short_repos = repository + strlen (current_parsed_root->directory) + 1;
d180 1
a180 1
	if (strcmp (repository, current_parsed_root->directory) == 0)
d636 1
a636 1
    while ((dp = CVS_READDIR (dirp)) != NULL)
d657 1
a657 1
		    (void) CVS_CLOSEDIR (dirp);
d683 1
a683 1
    CVS_CLOSEDIR (dirp);
d893 1
a893 1
lock_tree_for_write (argc, argv, local, which, aflag)
a896 1
    int which;
d907 1
a907 1
			   argv, local, which, aflag, 0, (char *) NULL, 0);
@


