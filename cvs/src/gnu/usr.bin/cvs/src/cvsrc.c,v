head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.20
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.22
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.18
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.14
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.16
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.8
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.54
	OPENBSD_5_0:1.1.1.8.0.52
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.50
	OPENBSD_4_9_BASE:1.1.1.8
	OPENBSD_4_8:1.1.1.8.0.48
	OPENBSD_4_8_BASE:1.1.1.8
	OPENBSD_4_7:1.1.1.8.0.44
	OPENBSD_4_7_BASE:1.1.1.8
	OPENBSD_4_6:1.1.1.8.0.46
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.42
	OPENBSD_4_5_BASE:1.1.1.8
	OPENBSD_4_4:1.1.1.8.0.40
	OPENBSD_4_4_BASE:1.1.1.8
	OPENBSD_4_3:1.1.1.8.0.38
	OPENBSD_4_3_BASE:1.1.1.8
	OPENBSD_4_2:1.1.1.8.0.36
	OPENBSD_4_2_BASE:1.1.1.8
	OPENBSD_4_1:1.1.1.8.0.34
	OPENBSD_4_1_BASE:1.1.1.8
	OPENBSD_4_0:1.1.1.8.0.32
	OPENBSD_4_0_BASE:1.1.1.8
	OPENBSD_3_9:1.1.1.8.0.30
	OPENBSD_3_9_BASE:1.1.1.8
	OPENBSD_3_8:1.1.1.8.0.28
	OPENBSD_3_8_BASE:1.1.1.8
	OPENBSD_3_7:1.1.1.8.0.26
	OPENBSD_3_7_BASE:1.1.1.8
	OPENBSD_3_6:1.1.1.8.0.24
	OPENBSD_3_6_BASE:1.1.1.8
	OPENBSD_3_5:1.1.1.8.0.22
	OPENBSD_3_5_BASE:1.1.1.8
	OPENBSD_3_4:1.1.1.8.0.20
	OPENBSD_3_4_BASE:1.1.1.8
	OPENBSD_3_3:1.1.1.8.0.18
	OPENBSD_3_3_BASE:1.1.1.8
	OPENBSD_3_2:1.1.1.8.0.16
	OPENBSD_3_2_BASE:1.1.1.8
	OPENBSD_3_1:1.1.1.8.0.14
	OPENBSD_3_1_BASE:1.1.1.8
	OPENBSD_3_0:1.1.1.8.0.12
	OPENBSD_3_0_BASE:1.1.1.8
	cvs-1-11-1p1:1.1.1.8
	OPENBSD_2_9:1.1.1.8.0.10
	OPENBSD_2_9_BASE:1.1.1.8
	cvs-1-11:1.1.1.8
	OPENBSD_2_8:1.1.1.8.0.8
	OPENBSD_2_8_BASE:1.1.1.8
	OPENBSD_2_7:1.1.1.8.0.6
	OPENBSD_2_7_BASE:1.1.1.8
	OPENBSD_2_6:1.1.1.8.0.4
	OPENBSD_2_6_BASE:1.1.1.8
	cvs-1-10-7:1.1.1.8
	OPENBSD_2_5:1.1.1.8.0.2
	OPENBSD_2_5_BASE:1.1.1.8
	cvs-1-10-5:1.1.1.8
	OPENBSD_2_4:1.1.1.7.0.4
	OPENBSD_2_4_BASE:1.1.1.7
	cvs-1-10:1.1.1.7
	cvs-1-9-28:1.1.1.7
	OPENBSD_2_3:1.1.1.7.0.2
	OPENBSD_2_3_BASE:1.1.1.7
	cvs-1-9-26:1.1.1.7
	cvs-1-9-24:1.1.1.7
	OPENBSD_2_2:1.1.1.6.0.2
	OPENBSD_2_2_BASE:1.1.1.6
	cvs-1-9-10:1.1.1.6
	OPENBSD_2_1:1.1.1.5.0.2
	OPENBSD_2_1_BASE:1.1.1.5
	cvs-1-9-8:1.1.1.5
	cvs-1-9-6:1.1.1.5
	cvs-1-9-4:1.1.1.5
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.03;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.45;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.26;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.28;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.06.28.03.28.38;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	98.02.22.08.21.07;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.02.28.21.32.49;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/*
 * Copyright (c) 1993 david d zuhn
 * 
 * Written by david d `zoo' zuhn while at Cygnus Support
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 *
 */


#include "cvs.h"
#include "getline.h"

/* this file is to be found in the user's home directory */

#ifndef	CVSRC_FILENAME
#define	CVSRC_FILENAME	".cvsrc"
#endif
char cvsrc[] = CVSRC_FILENAME;

#define	GROW	10

extern char *strtok ();

/* Read cvsrc, processing options matching CMDNAME ("cvs" for global
   options, and update *ARGC and *ARGV accordingly.  */

void
read_cvsrc (argc, argv, cmdname)
    int *argc;
    char ***argv;
    char *cmdname;
{
    char *homedir;
    char *homeinit;
    FILE *cvsrcfile;

    char *line;
    int line_length;
    size_t line_chars_allocated;

    char *optstart;

    int command_len;
    int found = 0;

    int i;

    int new_argc;
    int max_new_argv;
    char **new_argv;

    /* old_argc and old_argv hold the values returned from the
       previous invocation of read_cvsrc and are used to free the
       allocated memory.  The first invocation of read_cvsrc gets argv
       from the system, this memory must not be free'd.  */
    static int old_argc = 0;
    static char **old_argv = NULL;

    /* don't do anything if argc is -1, since that implies "help" mode */
    if (*argc == -1)
	return;

    /* determine filename for ~/.cvsrc */

    homedir = get_homedir ();
    /* If we can't find a home directory, ignore ~/.cvsrc.  This may
       make tracking down problems a bit of a pain, but on the other
       hand it might be obnoxious to complain when CVS will function
       just fine without .cvsrc (and many users won't even know what
       .cvsrc is).  */
    if (!homedir)
	return;

    homeinit = (char *) xmalloc (strlen (homedir) + strlen (cvsrc) + 10);
    strcpy (homeinit, homedir);
    strcat (homeinit, "/");
    strcat (homeinit, cvsrc);

    /* if it can't be read, there's no point to continuing */

    if (!isreadable (homeinit))
    {
	free (homeinit);
	return;
    }

    /* now scan the file until we find the line for the command in question */

    line = NULL;
    line_chars_allocated = 0;
    command_len = strlen (cmdname);
    cvsrcfile = open_file (homeinit, "r");
    while ((line_length = get_line (&line, &line_chars_allocated, cvsrcfile))
	   >= 0)
    {
	/* skip over comment lines */
	if (line[0] == '#')
	    continue;

	/* stop if we match the current command */
	if (!strncmp (line, cmdname, command_len)
	    && isspace ((unsigned char) *(line + command_len)))
	{
	    found = 1;
	    break;
	}
    }

    if (line_length < 0 && !feof (cvsrcfile))
	error (0, errno, "cannot read %s", homeinit);

    fclose (cvsrcfile);

    /* setup the new options list */

    new_argc = 1;
    max_new_argv = (*argc) + GROW;
    new_argv = (char **) xmalloc (max_new_argv * sizeof (char*));
    new_argv[0] = xstrdup ((*argv)[0]);

    if (found)
    {
	/* skip over command in the options line */
	for (optstart = strtok (line + command_len, "\t \n");
	     optstart;
	     optstart = strtok (NULL, "\t \n"))
	{
	    new_argv [new_argc++] = xstrdup (optstart);
	  
	    if (new_argc >= max_new_argv)
	    {
		max_new_argv += GROW;
		new_argv = (char **) xrealloc (new_argv, max_new_argv * sizeof (char*));
	    }
	}
    }

    if (line != NULL)
	free (line);

    /* now copy the remaining arguments */
  
    if (new_argc + *argc > max_new_argv)
    {
	max_new_argv = new_argc + *argc;
	new_argv = (char **) xrealloc (new_argv, max_new_argv * sizeof (char*));
    }
    for (i=1; i < *argc; i++)
    {
	new_argv [new_argc++] = xstrdup ((*argv)[i]);
    }

    if (old_argv != NULL)
    {
	/* Free the memory which was allocated in the previous
           read_cvsrc call.  */
	free_names (&old_argc, old_argv);
    }

    old_argc = *argc = new_argc;
    old_argv = *argv = new_argv;

    free (homeinit);
    return;
}
@


1.1
log
@Initial revision
@
text
@d2 6
a7 6
 *    Copyright (c) 1993 david d zuhn
 *
 *    written by david d `zoo' zuhn while at Cygnus Support
 *
 *    You may distribute under the terms of the GNU General Public License
 *    as specified in the README file that comes with the CVS 1.4 kit.
d13 1
a13 5

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)cvsrc.c 1.9 94/09/30 $";
USE(rcsid);
#endif /* lint */
d26 3
d30 4
a33 3
read_cvsrc (argc, argv)
     int *argc;
     char ***argv;
d39 4
a42 2
    char linebuf [MAXLINELEN];
  
d45 1
d54 7
a64 7
    /* setup the new options list */

    new_argc = 1;
    max_new_argv = (*argc) + GROW;
    new_argv = (char **) xmalloc (max_new_argv * sizeof (char*));
    new_argv[0] = xstrdup ((*argv)[0]);

d67 6
a72 1
    homedir = getenv ("HOME");
d83 1
a83 1
    if (access (homeinit, R_OK) != 0)
d91 3
d95 2
a96 1
    while (fgets (linebuf, MAXLINELEN, cvsrcfile))
d99 1
a99 1
	if (linebuf[0] == '#')
d103 2
a104 1
	if (!strncmp (linebuf, (*argv)[0], strlen ((*argv)[0])))
d111 3
d116 7
d126 3
a128 3
	optstart = strtok(linebuf+strlen((*argv)[0]), "\t \n");
      
	do
d130 1
a130 3
	    new_argv [new_argc] = xstrdup (optstart);
	    new_argv [new_argc+1] = NULL;
	    new_argc += 1;
a133 1
		char **tmp_argv;
d135 1
a135 5
		tmp_argv = (char **) xmalloc (max_new_argv * sizeof (char*));
		for (i = 0; i <= new_argc; i++)
		    tmp_argv[i] = new_argv[i];
		free(new_argv);
		new_argv = tmp_argv;
a136 1
	  
a137 1
	while ((optstart = strtok (NULL, "\t \n")) != NULL);
d140 3
d145 5
d152 8
a159 2
	new_argv [new_argc] = (*argv)[i];
	new_argc += 1;
d162 2
a163 2
    *argc = new_argc;
    *argv = new_argv;
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a12 1
#include "getline.h"
d39 2
a40 4
    char *line;
    int line_length;
    size_t line_chars_allocated;

a42 1
    int command_len;
d75 1
a75 1
    if (!isreadable (homeinit))
a82 3
    line = NULL;
    line_chars_allocated = 0;
    command_len = strlen (command_name);
d84 1
a84 2
    while ((line_length = getline (&line, &line_chars_allocated, cvsrcfile))
	   >= 0)
d87 1
a87 1
	if (line[0] == '#')
d91 1
a91 2
	if (!strncmp (line, command_name, command_len)
	    && isspace (*(line + command_len)))
d103 2
a104 2
	optstart = strtok (line + command_len, "\t \n");

a124 3

    if (line != NULL)
	free (line);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d15 5
d68 1
a68 1
    homedir = get_homedir ();
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a25 3
/* Read cvsrc, processing options matching CMDNAME ("cvs" for global
   options, and update *ARGC and *ARGV accordingly.  */

d27 3
a29 4
read_cvsrc (argc, argv, cmdname)
    int *argc;
    char ***argv;
    char *cmdname;
d84 1
a84 1
    command_len = strlen (cmdname);
d94 1
a94 1
	if (!strncmp (line, cmdname, command_len)
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d113 1
a113 1
	while (optstart)
d129 1
a129 1
	    optstart = strtok (NULL, "\t \n");
d131 1
@


1.1.1.6
log
@Latest version from Cyclic Software
@
text
@a53 7
    /* old_argc and old_argv hold the values returned from the
       previous invocation of read_cvsrc and are used to free the
       allocated memory.  The first invocation of read_cvsrc gets argv
       from the system, this memory must not be free'd.  */
    static int old_argc = 0;
    static char **old_argv = NULL;

d58 7
a107 7
    /* setup the new options list */

    new_argc = 1;
    max_new_argv = (*argc) + GROW;
    new_argv = (char **) xmalloc (max_new_argv * sizeof (char*));
    new_argv[0] = xstrdup ((*argv)[0]);

d111 3
a113 3
	for (optstart = strtok (line + command_len, "\t \n");
	     optstart;
	     optstart = strtok (NULL, "\t \n"))
d115 3
a117 1
	    new_argv [new_argc++] = xstrdup (optstart);
d121 1
d123 5
a127 1
		new_argv = (char **) xrealloc (new_argv, max_new_argv * sizeof (char*));
d129 1
a137 5
    if (new_argc + *argc > max_new_argv)
    {
	max_new_argv = new_argc + *argc;
	new_argv = (char **) xrealloc (new_argv, max_new_argv * sizeof (char*));
    }
d140 2
a141 8
	new_argv [new_argc++] = xstrdup ((*argv)[i]);
    }

    if (old_argv != NULL)
    {
	/* Free the memory which was allocated in the previous
           read_cvsrc call.  */
	free_names (&old_argc, old_argv);
d144 2
a145 2
    old_argc = *argc = new_argc;
    old_argv = *argv = new_argv;
@


1.1.1.7
log
@Latest version from Cyclic
@
text
@d2 6
a7 6
 * Copyright (c) 1993 david d zuhn
 * 
 * Written by david d `zoo' zuhn while at Cygnus Support
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
a104 3

    if (line_length < 0 && !feof (cvsrcfile))
	error (0, errno, "cannot read %s", homeinit);
@


1.1.1.8
log
@Latest version from Cyclic
@
text
@a67 5
    /* If we can't find a home directory, ignore ~/.cvsrc.  This may
       make tracking down problems a bit of a pain, but on the other
       hand it might be obnoxious to complain when CVS will function
       just fine without .cvsrc (and many users won't even know what
       .cvsrc is).  */
d99 1
a99 1
	    && isspace ((unsigned char) *(line + command_len)))
@


