head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.60
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.56
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.58
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.50
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.54
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.52
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.48
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.46
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.44
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.42
	OPENBSD_5_0:1.14.0.40
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.38
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.36
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.32
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.34
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.30
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.28
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.26
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.24
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.22
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.20
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.18
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.16
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.14
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.12
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.10
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.8
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	cvs-1-11-1p1:1.1.1.15
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	cvs-1-11:1.1.1.14
	OPENBSD_2_8:1.11.0.8
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.6
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	cvs-1-10-7:1.1.1.13
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	cvs-1-10-5:1.1.1.13
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	cvs-1-10:1.1.1.12
	cvs-1-9-28:1.1.1.11
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.6
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2002.01.08.08.01.45;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.10.19.31.34;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	99.02.28.21.57.48;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	98.08.22.21.04.22;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	98.07.13.04.16.58;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	98.03.12.07.22.26;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	98.02.22.08.55.54;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.06.28.03.45.26;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.04.21.04.40.59;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	97.02.21.06.54.51;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.10.18.04.19.24;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.05.20.18.14.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.58;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.39;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.18;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.23;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.19;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.04.21.04.26.56;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.28.35;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.21.02;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.03.12.06.58.30;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.07.13.03.53.41;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.08.22.20.52.55;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.02.28.21.32.38;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2001.02.10.18.57.37;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Allow a CVS tagname to be expanded during checkout, export and update to be
specified on the command line; ok niklas@@ pval@@
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Create Version
 * 
 * "checkout" creates a "version" of an RCS repository.  This version is owned
 * totally by the user and is actually an independent copy, to be dealt with
 * as seen fit.  Once "checkout" has been called in a given directory, it
 * never needs to be called again.  The user can keep up-to-date by calling
 * "update" when he feels like it; this will supply him with a merge of his
 * own modifications and the changes made in the RCS original.  See "update"
 * for details.
 * 
 * "checkout" can be given a list of directories or files to be updated and in
 * the case of a directory, will recursivley create any sub-directories that
 * exist in the repository.
 * 
 * When the user is satisfied with his own modifications, the present version
 * can be committed by "commit"; this keeps the present version in tact,
 * usually.
 * 
 * The call is cvs checkout [options] <module-name>...
 * 
 * "checkout" creates a directory ./CVS, in which it keeps its administration,
 * in two files, Repository and Entries. The first contains the name of the
 * repository.  The second contains one line for each registered file,
 * consisting of the version number it derives from, its time stamp at
 * derivation time and its name.  Both files are normal files and can be
 * edited by the user, if necessary (when the repository is moved, e.g.)
 */

#include <assert.h>
#include "cvs.h"

static char *findslash PROTO((char *start, char *p));
static int checkout_proc PROTO((int argc, char **argv, char *where,
		          char *mwhere, char *mfile, int shorten,
		          int local_specified, char *omodule,
		          char *msg));

static const char *const checkout_usage[] =
{
    "Usage:\n  %s %s [-ANPRcflnps] [-t id] [-r rev] [-D date] [-d dir]\n",
    "    [-j rev1] [-j rev2] [-k kopt] modules...\n",
    "\t-A\tReset any sticky tags/date/kopts.\n",
    "\t-N\tDon't shorten module paths if -d specified.\n",
    "\t-P\tPrune empty directories.\n",
    "\t-R\tProcess directories recursively.\n",
    "\t-c\t\"cat\" the module database.\n",
    "\t-f\tForce a head revision match if tag/date not found.\n",
    "\t-l\tLocal directory only, not recursive\n",
    "\t-n\tDo not run module program (if any).\n",
    "\t-p\tCheck out files to standard output (avoids stickiness).\n",
    "\t-s\tLike -c, but include module status.\n",
    "\t-r rev\tCheck out revision or tag. (implies -P) (is sticky)\n",
    "\t-D date\tCheck out revisions as of date. (implies -P) (is sticky)\n",
    "\t-d dir\tCheck out into dir instead of module name.\n",
    "\t-k kopt\tUse RCS kopt -k option on checkout. (is sticky)\n",
    "\t-j rev\tMerge in changes made between current revision and rev.\n",
    "\t-t id\tRCS identifier to expand on checkout.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

static const char *const export_usage[] =
{
    "Usage: %s %s [-NRfln] [-r rev] [-t id] [-D date] [-d dir] [-k kopt] module...\n",
    "\t-N\tDon't shorten module paths if -d specified.\n",
    "\t-f\tForce a head revision match if tag/date not found.\n",
    "\t-l\tLocal directory only, not recursive\n",
    "\t-R\tProcess directories recursively (default).\n",
    "\t-n\tDo not run module program (if any).\n",
    "\t-r rev\tExport revision or tag.\n",
    "\t-D date\tExport revisions as of date.\n",
    "\t-d dir\tExport into dir instead of module name.\n",
    "\t-k kopt\tUse RCS kopt -k option on checkout.\n",
    "\t-t id\tRCS identifier to expand on export.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

static int checkout_prune_dirs;
static int force_tag_match = 1;
static int pipeout;
static int aflag;
static char *options = NULL;
static char *tag = NULL;
static int tag_validated = 0;
static char *date = NULL;
static char *join_rev1 = NULL;
static char *join_rev2 = NULL;
static int join_tags_validated = 0;
static char *preload_update_dir = NULL;
static char *history_name = NULL;
static enum mtype m_type;

int
checkout (argc, argv)
    int argc;
    char **argv;
{
    int i;
    int c;
    DBM *db;
    int cat = 0, err = 0, status = 0;
    int run_module_prog = 1;
    int local = 0;
    int shorten = -1;
    char *where = NULL;
    char *valid_options;
    const char *const *valid_usage;

    /*
     * A smaller subset of options are allowed for the export command, which
     * is essentially like checkout, except that it hard-codes certain
     * options to be default (like -kv) and takes care to remove the CVS
     * directory when it has done its duty
     */
    if (strcmp (command_name, "export") == 0)
    {
        m_type = EXPORT;
	valid_options = "+Nnk:d:flRQqr:t:D:";
	valid_usage = export_usage;
    }
    else
    {
        m_type = CHECKOUT;
	valid_options = "+ANnk:d:flRpQqcsr:t:D:j:P";
	valid_usage = checkout_usage;
    }

    if (argc == -1)
	usage (valid_usage);

    ign_setup ();
    wrap_setup ();

    optind = 0;
    while ((c = getopt (argc, argv, valid_options)) != -1)
    {
	switch (c)
	{
	    case 'A':
		aflag = 1;
		break;
	    case 'N':
		shorten = 0;
		break;
	    case 'k':
		if (options)
		    free (options);
		options = RCS_check_kflag (optarg);
		break;
	    case 'n':
		run_module_prog = 0;
		break;
	    case 'Q':
	    case 'q':
#ifdef SERVER_SUPPORT
		/* The CVS 1.5 client sends these options (in addition to
		   Global_option requests), so we must ignore them.  */
		if (!server_active)
#endif
		    error (1, 0,
			   "-q or -Q must be specified before \"%s\"",
			   command_name);
		break;
	    case 'l':
		local = 1;
		break;
	    case 'R':
		local = 0;
		break;
	    case 'P':
		checkout_prune_dirs = 1;
		break;
	    case 'p':
		pipeout = 1;
		run_module_prog = 0;	/* don't run module prog when piping */
		noexec = 1;		/* so no locks will be created */
		break;
	    case 'c':
		cat = 1;
		break;
	    case 'd':
		where = optarg;
		if (shorten == -1)
		    shorten = 1;
		break;
	    case 's':
		cat = status = 1;
		break;
	    case 'f':
		force_tag_match = 0;
		break;
	    case 'r':
		tag = optarg;
		checkout_prune_dirs = 1;
		break;
	    case 't':
		if (RCS_citag)
		    free(RCS_citag);
		RCS_citag = strdup(optarg);
		break;
	    case 'D':
		date = Make_Date (optarg);
		checkout_prune_dirs = 1;
		break;
	    case 'j':
		if (join_rev2)
		    error (1, 0, "only two -j options can be specified");
		if (join_rev1)
		    join_rev2 = optarg;
		else
		    join_rev1 = optarg;
		break;
	    case '?':
	    default:
		usage (valid_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    if (shorten == -1)
	shorten = 0;

    if (cat && argc != 0)
	error (1, 0, "-c and -s must not get any arguments");

    if (!cat && argc == 0)
	error (1, 0, "must specify at least one module or directory");

    if (where && pipeout)
	error (1, 0, "-d and -p are mutually exclusive");

    if (m_type == EXPORT)
    {
	if (!tag && !date)
	    error (1, 0, "must specify a tag or date");

	if (tag && isdigit ((unsigned char) tag[0]))
	    error (1, 0, "tag `%s' must be a symbolic tag", tag);
    }

#ifdef SERVER_SUPPORT
    if (server_active && where != NULL)
    {
	server_pathname_check (where);
    }
#endif

    if (!cat && !safe_location()) {
        error(1, 0, "Cannot check out files into the repository itself");
    }

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
    {
	int expand_modules;

	start_server ();

	ign_setup ();
	
	/* We have to expand names here because the "expand-modules"
           directive to the server has the side-effect of having the
           server send the check-in and update programs for the
           various modules/dirs requested.  If we turn this off and
           simply request the names of the modules and directories (as
           below in !expand_modules), those files (CVS/Checkin.prog
           or CVS/Update.prog) don't get created.  Grrr.  */
	
	expand_modules = (!cat && !pipeout
			  && supported_request ("expand-modules"));
	
	if (expand_modules)
	{
	    /* This is done here because we need to read responses
               from the server before we send the command checkout or
               export files. */

	    client_expand_modules (argc, argv, local);
	}

	if (!run_module_prog)
	    send_arg ("-n");
	if (local)
	    send_arg ("-l");
	if (pipeout)
	    send_arg ("-p");
	if (!force_tag_match)
	    send_arg ("-f");
	if (aflag)
	    send_arg("-A");
	if (!shorten)
	    send_arg("-N");
	if (checkout_prune_dirs && m_type == CHECKOUT)
	    send_arg("-P");
	client_prune_dirs = checkout_prune_dirs;
	if (cat && !status)
	    send_arg("-c");
	if (where != NULL)
	    option_with_arg ("-d", where);
	if (status)
	    send_arg("-s");
	if (options != NULL && options[0] != '\0')
	    send_arg (options);
	option_with_arg ("-r", tag);
	if (date)
	    client_senddate (date);
	if (join_rev1 != NULL)
	    option_with_arg ("-j", join_rev1);
	if (join_rev2 != NULL)
	    option_with_arg ("-j", join_rev2);

	if (expand_modules)
	{
	    client_send_expansions (local, where, 1);
	}
	else
	{
	    int i;
	    for (i = 0; i < argc; ++i)
		send_arg (argv[i]);
	    client_nonexpanded_setup ();
	}

	send_to_server (m_type == EXPORT ? "export\012" : "co\012", 0);
	return get_responses_and_close ();
    }
#endif /* CLIENT_SUPPORT */

    if (cat)
    {
	cat_module (status);
	if (options)
	    free (options);
	return (0);
    }
    db = open_module ();


    /* If we've specified something like "cvs co foo/bar baz/quux"
       don't try to shorten names.  There are a few cases in which we
       could shorten (e.g. "cvs co foo/bar foo/baz"), but we don't
       handle those yet.  Better to have an extra directory created
       than the thing checked out under the wrong directory name. */

    if (argc > 1)
	shorten = 0;


    /* If we will be calling history_write, work out the name to pass
       it.  */
    if (m_type == CHECKOUT && !pipeout)
    {
	if (tag && date)
	{
	    history_name = xmalloc (strlen (tag) + strlen (date) + 2);
	    sprintf (history_name, "%s:%s", tag, date);
	}
	else if (tag)
	    history_name = tag;
	else
	    history_name = date;
    }


    for (i = 0; i < argc; i++)
	err += do_module (db, argv[i], m_type, "Updating", checkout_proc,
			  where, shorten, local, run_module_prog, !pipeout,
			  (char *) NULL);
    close_module (db);
    if (options)
	free (options);
    return (err);
}

/* FIXME: This is and emptydir_name are in checkout.c for historical
   reasons, probably want to move them.  */

int
safe_location ()
{
    char *current;
    char hardpath[PATH_MAX+5];
    size_t hardpath_len;
    int  x;
    int retval;

#ifdef HAVE_READLINK
    /* FIXME-arbitrary limit: should be retrying this like xgetwd.
       But how does readlink let us know that the buffer was too small?
       (by returning sizeof hardpath - 1?).  */
    x = readlink(current_parsed_root->directory, hardpath, sizeof hardpath - 1);
#else
    x = -1;
#endif
    if (x == -1)
    {
        strcpy(hardpath, current_parsed_root->directory);
    }
    else
    {
        hardpath[x] = '\0';
    }
    current = xgetwd ();
    if (current == NULL)
	error (1, errno, "could not get working directory");
    hardpath_len = strlen (hardpath);
    if (strlen (current) >= hardpath_len
	&& strncmp (current, hardpath, hardpath_len) == 0)
    {
	if (/* Current is a subdirectory of hardpath.  */
	    current[hardpath_len] == '/'

	    /* Current is hardpath itself.  */
	    || current[hardpath_len] == '\0')
	    retval = 0;
	else
	    /* It isn't a problem.  For example, current is
	       "/foo/cvsroot-bar" and hardpath is "/foo/cvsroot".  */
	    retval = 1;
    }
    else
	retval = 1;
    free (current);
    return retval;
}

struct dir_to_build
{
    /* What to put in CVS/Repository.  */
    char *repository;
    /* The path to the directory.  */
    char *dirpath;

    /* If set, don't build the directory, just change to it.
       The caller will also want to set REPOSITORY to NULL.  */
    int just_chdir;

    struct dir_to_build *next;
};

static int build_dirs_and_chdir PROTO ((struct dir_to_build *list,
					int sticky));

static void build_one_dir PROTO ((char *, char *, int));

static void
build_one_dir (repository, dirpath, sticky)
    char *repository;
    char *dirpath;
    int sticky;
{
    FILE *fp;

    if (isfile (CVSADM))
    {
	if (m_type == EXPORT)
	    error (1, 0, "cannot export into a working directory");
    }
    else if (m_type == CHECKOUT)
    {
	/* I suspect that this check could be omitted.  */
	if (!isdir (repository))
	    error (1, 0, "there is no repository %s", repository);

	if (Create_Admin (".", dirpath, repository,
			  sticky ? tag : (char *) NULL,
			  sticky ? date : (char *) NULL,

			  /* FIXME?  This is a guess.  If it is important
			     for nonbranch to be set correctly here I
			     think we need to write it one way now and
			     then rewrite it later via WriteTag, once
			     we've had a chance to call RCS_nodeisbranch
			     on each file.  */
			  0, 1, 1))
	    return;

	if (!noexec)
	{
	    fp = open_file (CVSADM_ENTSTAT, "w+");
	    if (fclose (fp) == EOF)
		error (1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
	    if (server_active)
		server_set_entstat (dirpath, repository);
#endif
	}
    }
}

/*
 * process_module calls us back here so we do the actual checkout stuff
 */
/* ARGSUSED */
static int
checkout_proc (argc, argv, where_orig, mwhere, mfile, shorten,
	       local_specified, omodule, msg)
    int argc;
    char **argv;
    char *where_orig;
    char *mwhere;
    char *mfile;
    int shorten;
    int local_specified;
    char *omodule;
    char *msg;
{
    char *myargv[2];
    int err = 0;
    int which;
    char *cp;
    char *repository;
    char *oldupdate = NULL;
    char *where;

    /*
     * OK, so we're doing the checkout! Our args are as follows: 
     *  argc,argv contain either dir or dir followed by a list of files 
     *  where contains where to put it (if supplied by checkout) 
     *  mwhere contains the module name or -d from module file 
     *  mfile says do only that part of the module
     *  shorten = 1 says shorten as much as possible 
     *  omodule is the original arg to do_module()
     */

    /* Set up the repository (maybe) for the bottom directory.
       Allocate more space than we need so we don't need to keep
       reallocating this string. */
    repository = xmalloc (strlen (current_parsed_root->directory)
			  + strlen (argv[0])
			  + (mfile == NULL ? 0 : strlen (mfile))
			  + 10);
    (void) sprintf (repository, "%s/%s", current_parsed_root->directory, argv[0]);
    Sanitize_Repository_Name (repository);


    /* save the original value of preload_update_dir */
    if (preload_update_dir != NULL)
	oldupdate = xstrdup (preload_update_dir);


    /* Allocate space and set up the where variable.  We allocate more
       space than necessary here so that we don't have to keep
       reallocaing it later on. */
    
    where = xmalloc (strlen (argv[0])
		     + (mfile == NULL ? 0 : strlen (mfile))
		     + (mwhere == NULL ? 0 : strlen (mwhere))
		     + (where_orig == NULL ? 0 : strlen (where_orig))
		     + 10);

    /* Yes, this could be written in a less verbose way, but in this
       form it is quite easy to read.
    
       FIXME?  The following code that sets should probably be moved
       to do_module in modules.c, since there is similar code in
       patch.c and rtag.c. */
    
    if (shorten)
    {
	if (where_orig != NULL)
	{
	    /* If the user has specified a directory with `-d' on the
	       command line, use it preferentially, even over the `-d'
	       flag in the modules file. */
    
	    (void) strcpy (where, where_orig);
	}
	else if (mwhere != NULL)
	{
	    /* Second preference is the value of mwhere, which is from
	       the `-d' flag in the modules file. */

	    (void) strcpy (where, mwhere);
	}
	else
	{
	    /* Third preference is the directory specified in argv[0]
	       which is this module'e directory in the repository. */
	    
	    (void) strcpy (where, argv[0]);
	}
    }
    else
    {
	/* Use the same preferences here, bug don't shorten -- that
           is, tack on where_orig if it exists. */

	*where = '\0';

	if (where_orig != NULL)
	{
	    (void) strcat (where, where_orig);
	    (void) strcat (where, "/");
	}

	/* If the -d flag in the modules file specified an absolute
           directory, let the user override it with the command-line
           -d option. */

	if ((mwhere != NULL) && (! isabsolute (mwhere)))
	    (void) strcat (where, mwhere);
	else
	    (void) strcat (where, argv[0]);
    }
    strip_trailing_slashes (where); /* necessary? */


    /* At this point, the user may have asked for a single file or
       directory from within a module.  In that case, we should modify
       where, repository, and argv as appropriate. */

    if (mfile != NULL)
    {
	/* The mfile variable can have one or more path elements.  If
	   it has multiple elements, we want to tack those onto both
	   repository and where.  The last element may refer to either
	   a file or directory.  Here's what to do:

	   it refers to a directory
	     -> simply tack it on to where and repository
	   it refers to a file
	     -> munge argv to contain `basename mfile` */

	char *cp;
	char *path;


	/* Paranoia check. */

	if (mfile[strlen (mfile) - 1] == '/')
	{
	    error (0, 0, "checkout_proc: trailing slash on mfile (%s)!",
		   mfile);
	}


	/* Does mfile have multiple path elements? */

	cp = strrchr (mfile, '/');
	if (cp != NULL)
	{
	    *cp = '\0';
	    (void) strcat (repository, "/");
	    (void) strcat (repository, mfile);
	    (void) strcat (where, "/");
	    (void) strcat (where, mfile);
	    mfile = cp + 1;
	}
	

	/* Now mfile is a single path element. */

	path = xmalloc (strlen (repository) + strlen (mfile) + 5);
	(void) sprintf (path, "%s/%s", repository, mfile);
	if (isdir (path))
	{
	    /* It's a directory, so tack it on to repository and
               where, as we did above. */

	    (void) strcat (repository, "/");
	    (void) strcat (repository, mfile);
	    (void) strcat (where, "/");
	    (void) strcat (where, mfile);
	}
	else
	{
	    /* It's a file, which means we have to screw around with
               argv. */
	    myargv[0] = argv[0];
	    myargv[1] = mfile;
	    argc = 2;
	    argv = myargv;
	}
	free (path);
    }

    if (preload_update_dir != NULL)
    {
	preload_update_dir =
	    xrealloc (preload_update_dir,
		      strlen (preload_update_dir) + strlen (where) + 5);
	strcat (preload_update_dir, "/");
	strcat (preload_update_dir, where);
    }
    else
	preload_update_dir = xstrdup (where);

    /*
     * At this point, where is the directory we want to build, repository is
     * the repository for the lowest level of the path.
     *
     * We need to tell build_dirs not only the path we want it to
     * build, but also the repositories we want it to populate the
     * path with.  To accomplish this, we walk the path backwards, one
     * pathname component at a time, constucting a linked list of
     * struct dir_to_build.
     */

    /*
     * If we are sending everything to stdout, we can skip a whole bunch of
     * work from here
     */
    if (!pipeout)
    {
	struct dir_to_build *head;
	char *reposcopy;

	if (strncmp (repository, current_parsed_root->directory,
		     strlen (current_parsed_root->directory)) != 0)
	    error (1, 0, "\
internal error: %s doesn't start with %s in checkout_proc",
		   repository, current_parsed_root->directory);

	/* We always create at least one directory, which corresponds to
	   the entire strings for WHERE and REPOSITORY.  */
	head = (struct dir_to_build *) xmalloc (sizeof (struct dir_to_build));
	/* Special marker to indicate that we don't want build_dirs_and_chdir
	   to create the CVSADM directory for us.  */
	head->repository = NULL;
	head->dirpath = xstrdup (where);
	head->next = NULL;
	head->just_chdir = 0;


	/* Make a copy of the repository name to play with. */
	reposcopy = xstrdup (repository);

	/* FIXME: this should be written in terms of last_component
	   instead of hardcoding '/'.  This presumably affects OS/2,
	   NT, &c, if the user specifies '\'.  Likewise for the call
	   to findslash.  */
	cp = where + strlen (where);
	while (cp > where)
	{
	    struct dir_to_build *new;

	    cp = findslash (where, cp - 1);
	    if (cp == NULL)
		break;		/* we're done */

	    new = (struct dir_to_build *)
		xmalloc (sizeof (struct dir_to_build));
	    new->dirpath = xmalloc (strlen (where));

	    /* If the user specified an absolute path for where, the
               last path element we create should be the top-level
               directory. */

	    if (cp > where)
	    {
		strncpy (new->dirpath, where, cp - where);
		new->dirpath[cp - where] = '\0';
	    }
	    else
	    {
		/* where should always be at least one character long. */
		assert (where[0] != '\0');
		strcpy (new->dirpath, "/");
	    }
	    new->next = head;
	    head = new;

	    /* If where consists of multiple pathname components,
	       then we want to just cd into it, without creating
	       directories or modifying CVS directories as we go.
	       In CVS 1.9 and earlier, the code actually does a
	       CVS_CHDIR up-front; I'm not going to try to go back
	       to that exact code but this is somewhat similar
	       in spirit.  */
	    if (where_orig != NULL
		&& cp - where < strlen (where_orig))
	    {
		new->repository = NULL;
		new->just_chdir = 1;
		continue;
	    }

	    new->just_chdir = 0;

	    /* Now figure out what repository directory to generate.
               The most complete case would be something like this:

	       The modules file contains
	         foo -d bar/baz quux

	       The command issued was:
	         cvs co -d what/ever -N foo
	       
	       The results in the CVS/Repository files should be:
	         .     -> (don't touch CVS/Repository)
			  (I think this case might be buggy currently)
		 what  -> (don't touch CVS/Repository)
		 ever  -> .          (same as "cd what/ever; cvs co -N foo")
		 bar   -> Emptydir   (generated dir -- not in repos)
		 baz   -> quux       (finally!) */

	    if (strcmp (reposcopy, current_parsed_root->directory) == 0)
	    {
		/* We can't walk up past CVSROOT.  Instead, the
                   repository should be Emptydir. */
		new->repository = emptydir_name ();
	    }
	    else
	    {
		/* It's a directory in the repository! */
		    
		char *rp;
		    
		/* We'll always be below CVSROOT, but check for
		   paranoia's sake. */
		rp = strrchr (reposcopy, '/');
		if (rp == NULL)
		    error (1, 0,
			   "internal error: %s doesn't contain a slash",
			   reposcopy);
			   
		*rp = '\0';
		new->repository = xmalloc (strlen (reposcopy) + 5);
		(void) strcpy (new->repository, reposcopy);
		    
		if (strcmp (reposcopy, current_parsed_root->directory) == 0)
		{
		    /* Special case -- the repository name needs
		       to be "/path/to/repos/." (the trailing dot
		       is important).  We might be able to get rid
		       of this after the we check out the other
		       code that handles repository names. */
		    (void) strcat (new->repository, "/.");
		}
	    }
	}

	/* clean up */
	free (reposcopy);

	{
	    int where_is_absolute = isabsolute (where);
	    
	    /* The top-level CVSADM directory should always be
	       current_parsed_root->directory.  Create it, but only if WHERE is
	       relative.  If WHERE is absolute, our current directory
	       may not have a thing to do with where the sources are
	       being checked out.  If it does, build_dirs_and_chdir
	       will take care of creating adm files here. */
	    /* FIXME: checking where_is_absolute is a horrid kludge;
	       I suspect we probably can just skip the call to
	       build_one_dir whenever the -d command option was specified
	       to checkout.  */

	    if (! where_is_absolute && top_level_admin)
	    {
		/* It may be argued that we shouldn't set any sticky
		   bits for the top-level repository.  FIXME?  */
		build_one_dir (current_parsed_root->directory, ".", argc <= 1);

#ifdef SERVER_SUPPORT
		/* We _always_ want to have a top-level admin
		   directory.  If we're running in client/server mode,
		   send a "Clear-static-directory" command to make
		   sure it is created on the client side.  (See 5.10
		   in cvsclient.dvi to convince yourself that this is
		   OK.)  If this is a duplicate command being sent, it
		   will be ignored on the client side.  */

		if (server_active)
		    server_clear_entstat (".", current_parsed_root->directory);
#endif
	    }


	    /* Build dirs on the path if necessary and leave us in the
	       bottom directory (where if where was specified) doesn't
	       contain a CVS subdir yet, but all the others contain
	       CVS and Entries.Static files */

	    if (build_dirs_and_chdir (head, argc <= 1) != 0)
	    {
		error (0, 0, "ignoring module %s", omodule);
		err = 1;
		goto out;
	    }
	}

	/* set up the repository (or make sure the old one matches) */
	if (!isfile (CVSADM))
	{
	    FILE *fp;

	    if (!noexec && argc > 1)
	    {
		/* I'm not sure whether this check is redundant.  */
		if (!isdir (repository))
		    error (1, 0, "there is no repository %s", repository);

		Create_Admin (".", preload_update_dir, repository,
			      (char *) NULL, (char *) NULL, 0, 0,
			      m_type == CHECKOUT);
		fp = open_file (CVSADM_ENTSTAT, "w+");
		if (fclose(fp) == EOF)
		    error(1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
		if (server_active)
		    server_set_entstat (where, repository);
#endif
	    }
	    else
	    {
		/* I'm not sure whether this check is redundant.  */
		if (!isdir (repository))
		    error (1, 0, "there is no repository %s", repository);

		Create_Admin (".", preload_update_dir, repository, tag, date,

			      /* FIXME?  This is a guess.  If it is important
				 for nonbranch to be set correctly here I
				 think we need to write it one way now and
				 then rewrite it later via WriteTag, once
				 we've had a chance to call RCS_nodeisbranch
				 on each file.  */
			      0, 0, m_type == CHECKOUT);
	    }
	}
	else
	{
	    char *repos;

	    if (m_type == EXPORT)
		error (1, 0, "cannot export into working directory");

	    /* get the contents of the previously existing repository */
	    repos = Name_Repository ((char *) NULL, preload_update_dir);
	    if (fncmp (repository, repos) != 0)
	    {
		error (0, 0, "existing repository %s does not match %s",
		       repos, repository);
		error (0, 0, "ignoring module %s", omodule);
		free (repos);
		err = 1;
		goto out;
	    }
	    free (repos);
	}
    }

    /*
     * If we are going to be updating to stdout, we need to cd to the
     * repository directory so the recursion processor can use the current
     * directory as the place to find repository information
     */
    if (pipeout)
    {
	if ( CVS_CHDIR (repository) < 0)
	{
	    error (0, errno, "cannot chdir to %s", repository);
	    err = 1;
	    goto out;
	}
	which = W_REPOS;
	if (tag != NULL && !tag_validated)
	{
	    tag_check_valid (tag, argc - 1, argv + 1, 0, aflag, NULL);
	    tag_validated = 1;
	}
    }
    else
    {
	which = W_LOCAL | W_REPOS;
	if (tag != NULL && !tag_validated)
	{
	    tag_check_valid (tag, argc - 1, argv + 1, 0, aflag,
			     repository);
	    tag_validated = 1;
	}
    }

    if (tag != NULL || date != NULL || join_rev1 != NULL)
	which |= W_ATTIC;

    if (! join_tags_validated)
    {
        if (join_rev1 != NULL)
	    tag_check_valid_join (join_rev1, argc - 1, argv + 1, 0, aflag,
				  repository);
	if (join_rev2 != NULL)
	    tag_check_valid_join (join_rev2, argc - 1, argv + 1, 0, aflag,
				  repository);
	join_tags_validated = 1;
    }

    /*
     * if we are going to be recursive (building dirs), go ahead and call the
     * update recursion processor.  We will be recursive unless either local
     * only was specified, or we were passed arguments
     */
    if (!(local_specified || argc > 1))
    {
	if (m_type == CHECKOUT && !pipeout)
	    history_write ('O', preload_update_dir, history_name, where,
			   repository);
	else if (m_type == EXPORT && !pipeout)
	    history_write ('E', preload_update_dir, tag ? tag : date, where,
			   repository);
	err += do_update (0, (char **) NULL, options, tag, date,
			  force_tag_match, 0 /* !local */ ,
			  1 /* update -d */ , aflag, checkout_prune_dirs,
			  pipeout, which, join_rev1, join_rev2,
			  preload_update_dir, m_type == CHECKOUT);
	goto out;
    }

    if (!pipeout)
    {
	int i;
	List *entries;

	/* we are only doing files, so register them */
	entries = Entries_Open (0, NULL);
	for (i = 1; i < argc; i++)
	{
	    char *line;
	    Vers_TS *vers;
	    struct file_info finfo;

	    memset (&finfo, 0, sizeof finfo);
	    finfo.file = argv[i];
	    /* Shouldn't be used, so set to arbitrary value.  */
	    finfo.update_dir = NULL;
	    finfo.fullname = argv[i];
	    finfo.repository = repository;
	    finfo.entries = entries;
	    /* The rcs slot is needed to get the options from the RCS
               file */
	    finfo.rcs = RCS_parse (finfo.file, repository);

	    vers = Version_TS (&finfo, options, tag, date,
			       force_tag_match, 0);
	    if (vers->ts_user == NULL)
	    {
		line = xmalloc (strlen (finfo.file) + 15);
		(void) sprintf (line, "Initial %s", finfo.file);
		Register (entries, finfo.file,
			  vers->vn_rcs ? vers->vn_rcs : "0",
			  line, vers->options, vers->tag,
			  vers->date, (char *) 0);
		free (line);
	    }
	    freevers_ts (&vers);
	    freercsnode (&finfo.rcs);
	}

	Entries_Close (entries);
    }

    /* Don't log "export", just regular "checkouts" */
    if (m_type == CHECKOUT && !pipeout)
	history_write ('O', preload_update_dir, history_name, where,
		       repository);

    /* go ahead and call update now that everything is set */
    err += do_update (argc - 1, argv + 1, options, tag, date,
		      force_tag_match, local_specified, 1 /* update -d */,
		      aflag, checkout_prune_dirs, pipeout, which, join_rev1,
		      join_rev2, preload_update_dir, m_type == CHECKOUT);
out:
    free (preload_update_dir);
    preload_update_dir = oldupdate;
    free (where);
    free (repository);
    return (err);
}

static char *
findslash (start, p)
    char *start;
    char *p;
{
    for (;;)
    {
	if (*p == '/') return p;
	if (p == start) break;
	--p;
    }
    return NULL;
}

/* Return a newly malloc'd string containing a pathname for CVSNULLREPOS,
   and make sure that it exists.  If there is an error creating the
   directory, give a fatal error.  Otherwise, the directory is guaranteed
   to exist when we return.  */
char *
emptydir_name ()
{
    char *repository;

    repository = xmalloc (strlen (current_parsed_root->directory) 
			  + sizeof (CVSROOTADM)
			  + sizeof (CVSNULLREPOS)
			  + 3);
    (void) sprintf (repository, "%s/%s/%s", current_parsed_root->directory,
		    CVSROOTADM, CVSNULLREPOS);
    if (!isfile (repository))
    {
	mode_t omask;
	omask = umask (cvsumask);
	if (CVS_MKDIR (repository, 0777) < 0)
	    error (1, errno, "cannot create %s", repository);
	(void) umask (omask);
    }
    return repository;
}

/* Build all the dirs along the path to DIRS with CVS subdirs with appropriate
   repositories.  If ->repository is NULL, do not create a CVSADM directory
   for that subdirectory; just CVS_CHDIR into it.  */
static int
build_dirs_and_chdir (dirs, sticky)
    struct dir_to_build *dirs;
    int sticky;
{
    int retval = 0;
    struct dir_to_build *nextdir;

    while (dirs != NULL)
    {
	char *dir = last_component (dirs->dirpath);

	if (!dirs->just_chdir)
	{
	    mkdir_if_needed (dir);
	    Subdir_Register (NULL, NULL, dir);
	}

	if (CVS_CHDIR (dir) < 0)
	{
	    error (0, errno, "cannot chdir to %s", dir);
	    retval = 1;
	    goto out;
	}
	if (dirs->repository != NULL)
	{
	    build_one_dir (dirs->repository, dirs->dirpath, sticky);
	    free (dirs->repository);
	}
	nextdir = dirs->next;
	free (dirs->dirpath);
	free (dirs);
	dirs = nextdir;
    }

 out:
    while (dirs != NULL)
    {
	if (dirs->repository != NULL)
	    free (dirs->repository);
	nextdir = dirs->next;
	free (dirs->dirpath);
	free (dirs);
	dirs = nextdir;
    }
    return retval;
}
@


1.13
log
@Merge local changes; work in progress
@
text
@d47 1
a47 1
    "Usage:\n  %s %s [-ANPRcflnps] [-r rev] [-D date] [-d dir]\n",
d64 1
d71 1
a71 1
    "Usage: %s %s [-NRfln] [-r rev] [-D date] [-d dir] [-k kopt] module...\n",
d81 1
d126 1
a126 1
	valid_options = "+Nnk:d:flRQqr:D:";
d132 1
a132 1
	valid_options = "+ANnk:d:flRpQqcsr:D:j:P";
d203 5
@


1.12
log
@Integrate local changes
@
text
@d47 1
a47 1
    "Usage:\n  %s %s [-ANPRcflnps] [-r rev | -D date] [-d dir]\n",
d62 1
a62 1
    "\t-k kopt\tUse RCS kopt -k option on checkout.\n",
d70 1
a70 1
    "Usage: %s %s [-NRfln] [-r rev | -D date] [-d dir] [-k kopt] module...\n",
d193 1
a193 1
		status = 1;
d226 1
a226 1
    if ((cat || status) && argc != 0)
d229 1
a229 1
    if (!(cat || status) && argc == 0)
d251 1
a251 1
    if (!safe_location()) {
d256 1
a256 1
    if (client_active)
d272 1
a272 1
	expand_modules = (!cat && !status && !pipeout
d299 1
a299 1
	if (cat)
d332 1
a332 1
    if (cat || status)
d370 1
a370 1
			  where, shorten, local, run_module_prog,
d394 1
a394 1
    x = readlink(CVSroot_directory, hardpath, sizeof hardpath - 1);
d400 1
a400 1
        strcpy(hardpath, CVSroot_directory);
d469 2
a470 2
			  sticky ? (char *) NULL : tag,
			  sticky ? (char *) NULL : date,
d532 1
a532 1
    repository = xmalloc (strlen (CVSroot_directory)
d536 1
a536 1
    (void) sprintf (repository, "%s/%s", CVSroot_directory, argv[0]);
d712 2
a713 2
	if (strncmp (repository, CVSroot_directory,
		     strlen (CVSroot_directory)) != 0)
d716 1
a716 1
		   repository, CVSroot_directory);
d801 1
a801 1
	    if (strcmp (reposcopy, CVSroot_directory) == 0)
d809 1
a809 23
		if ((where_orig != NULL)
		    && (strcmp (new->dirpath, where_orig) == 0))
		{
		    /* It's the case that the user specified a
		     * destination directory with the "-d" flag.  The
		     * repository in this directory should be "."
		     * since the user's command is equivalent to:
		     *
		     *   cd <dir>; cvs co blah   */

		    strcpy (reposcopy, CVSroot_directory);
		    goto allocate_repos;
		}
		else if (mwhere != NULL)
		{
		    /* This is a generated directory, so point to
                       CVSNULLREPOS. */

		    new->repository = emptydir_name ();
		}
		else
		{
		    /* It's a directory in the repository! */
d811 1
a811 1
		    char *rp;
d813 7
a819 7
		    /* We'll always be below CVSROOT, but check for
		       paranoia's sake. */
		    rp = strrchr (reposcopy, '/');
		    if (rp == NULL)
			error (1, 0,
			       "internal error: %s doesn't contain a slash",
			       reposcopy);
d821 3
a823 5
		    *rp = '\0';
		
		allocate_repos:
		    new->repository = xmalloc (strlen (reposcopy) + 5);
		    (void) strcpy (new->repository, reposcopy);
d825 8
a832 9
		    if (strcmp (reposcopy, CVSroot_directory) == 0)
		    {
			/* Special case -- the repository name needs
			   to be "/path/to/repos/." (the trailing dot
			   is important).  We might be able to get rid
			   of this after the we check out the other
			   code that handles repository names. */
			(void) strcat (new->repository, "/.");
		    }
d844 1
a844 1
	       CVSroot_directory.  Create it, but only if WHERE is
d858 1
a858 1
		build_one_dir (CVSroot_directory, ".", argc <= 1);
d870 1
a870 1
		    server_clear_entstat (".", CVSroot_directory);
d1011 1
a1011 1
			  preload_update_dir);
d1067 1
a1067 1
		      join_rev2, preload_update_dir);
d1099 1
a1099 1
    repository = xmalloc (strlen (CVSroot_directory) 
d1102 2
a1103 2
			  + 10);
    (void) sprintf (repository, "%s/%s/%s", CVSroot_directory,
@


1.11
log
@Integrate local changes
@
text
@d40 1
a40 1
static int checkout_proc PROTO((int *pargc, char **argv, char *where,
a43 1
static int safe_location PROTO((void));
d97 1
a113 1
    enum mtype m_type;
d235 1
a235 1
    if (strcmp (command_name, "export") == 0)
d296 1
a296 1
	if (checkout_prune_dirs && strcmp (command_name, "export") != 0)
d327 1
a327 4
	send_to_server (strcmp (command_name, "export") == 0 ?
                        "export\012" : "co\012",
                        0);

d354 1
a354 1
    if (strcmp (command_name, "export") != 0 && !pipeout)
d378 4
a381 1
static int
d457 6
a462 1
    if (!isfile (CVSADM) && strcmp (command_name, "export") != 0)
d478 1
a478 1
			  0, 1))
d499 1
a499 1
checkout_proc (pargc, argv, where_orig, mwhere, mfile, shorten,
d501 1
a501 1
    int *pargc;
d511 1
d673 4
a676 20

	    int i;


	    /* Paranoia check. */
	    
	    if (*pargc > 1)
	    {
		error (0, 0, "checkout_proc: trashing argv elements!");
		for (i = 1; i < *pargc; i++)
		{
		    error (0, 0, "checkout_proc: argv[%d] `%s'",
			   i, argv[i]);
		}
	    }

	    for (i = 1; i < *pargc; i++)
		free (argv[i]);
	    argv[1] = xstrdup (mfile);
	    (*pargc) = 2;
d737 1
a737 1
	while (1)
d753 1
a753 1
	    if (cp - where)
d761 1
a761 1
		assert (strlen (where));
d833 1
a833 1
		    char *rp = strrchr (reposcopy, '/');
d837 1
d883 1
a883 1
		build_one_dir (CVSroot_directory, ".", *pargc <= 1);
d905 1
a905 1
	    if (build_dirs_and_chdir (head, *pargc <= 1) != 0)
d918 1
a918 1
	    if (!noexec && *pargc > 1)
d925 2
a926 1
			      (char *) NULL, (char *) NULL, 0, 0);
d949 1
a949 1
			      0, 0);
d956 3
d990 1
a990 1
	    tag_check_valid (tag, *pargc - 1, argv + 1, 0, aflag, NULL);
d999 1
a999 1
	    tag_check_valid (tag, *pargc - 1, argv + 1, 0, aflag,
d1011 1
a1011 1
	    tag_check_valid_join (join_rev1, *pargc - 1, argv + 1, 0, aflag,
d1014 1
a1014 1
	    tag_check_valid_join (join_rev2, *pargc - 1, argv + 1, 0, aflag,
d1024 1
a1024 1
    if (!(local_specified || *pargc > 1))
d1026 1
a1026 1
	if (strcmp (command_name, "export") != 0 && !pipeout)
d1029 1
a1029 1
	else if (strcmp (command_name, "export") == 0 && !pipeout)
d1047 1
a1047 1
	for (i = 1; i < *pargc; i++)
d1084 1
a1084 1
    if (strcmp (command_name, "export") != 0 && !pipeout)
d1089 1
a1089 1
    err += do_update (*pargc - 1, argv + 1, options, tag, date,
d1106 7
a1112 9
    while (p >= start && *p != '/')
	p--;
    /* FIXME: indexing off the start of the array like this is *NOT*
       OK according to ANSI, and will break some of the time on certain
       segmented architectures.  */
    if (p < start)
	return (NULL);
    else
	return (p);
d1180 9
@


1.10
log
@Integrate local changes
@
text
@d241 1
a241 1
	if (tag && isdigit (tag[0]))
@


1.9
log
@Integrate local changes
@
text
@d889 1
a889 1
	    if (! where_is_absolute)
d894 13
@


1.8
log
@Integrate local changes
@
text
@d245 7
d438 4
d446 1
a446 1
					int sticky, int check_existing_dirs));
d737 1
d775 20
a794 1
	    
d805 3
a807 2
	         .     -> .          (this is where we executed the cmd)
		 what  -> Emptydir   (generated dir -- not in repos)
d811 1
a811 1
	    
a869 3
	    
	    new->next = head;
	    head = new;
d884 5
a888 1
	       
d902 1
a902 2
	    if (build_dirs_and_chdir (head, *pargc <= 1,
				      where_is_absolute) != 0)
d1136 3
a1138 11

/* Build all the dirs along the path to DIRS with CVS subdirs with
   appropriate repositories.  If ->repository is NULL, do not create a
   CVSADM directory for that subdirectory; just CVS_CHDIR into it.  If
   check_existing_dirs is nonzero, don't create directories if they
   already exist, and don't try to write adm files in directories
   where we don't have write permission.  We use this last option
   primarily when a user has specified an absolute path for checkout
   -- we will often not have permission to top-level directories, so
   we shouldn't complain. */

d1140 1
a1140 1
build_dirs_and_chdir (dirs, sticky, check_existing_dirs)
a1142 1
    int check_existing_dirs;
a1149 1
	int dir_is_writeable;
d1151 2
a1152 1
	if ((! check_existing_dirs) || (! isdir (dir)))
d1154 2
a1155 6

	Subdir_Register (NULL, NULL, dir);

	/* This is an expensive call -- only make it if necessary. */
	if (check_existing_dirs)
	    dir_is_writeable = iswritable (dir);
d1163 1
a1163 3

	if ((dirs->repository != NULL)
	    && ((! check_existing_dirs) || dir_is_writeable))
a1167 1

@


1.7
log
@Integrate local changes
@
text
@d36 1
d435 1
a435 1
					int sticky));
d584 5
a588 1
	if (mwhere != NULL)
d731 6
a736 5
	/* FIXME: this should be written in terms of last_component instead
	   of hardcoding '/'.  This presumably affects OS/2, NT, &c, if
	   the user specifies '\'.  Likewise for the call to findslash.  */
	cp = strrchr (where, '/');
	while (cp != NULL)
d739 5
a746 2
	    strncpy (new->dirpath, where, cp - where);
	    new->dirpath[cp - where] = '\0';
d748 16
a840 2

	    cp = findslash (where, cp - 1);
a845 14
	/* The top-level CVSADM directory should always be
           CVSroot_directory.  Create it.
	
	   It may be argued that we shouldn't set any sticky bits for
	   the top-level repository.  FIXME?  */
	build_one_dir (CVSroot_directory, ".", *pargc <= 1);

	/*
	 * build dirs on the path if necessary and leave us in the bottom
	 * directory (where if where was specified) doesn't contain a CVS
	 * subdir yet, but all the others contain CVS and Entries.Static
	 * files
	 */
	if (build_dirs_and_chdir (head, *pargc <= 1) != 0)
d847 29
a875 3
	    error (0, 0, "ignoring module %s", omodule);
	    err = 1;
	    goto out;
d1007 1
a1007 1
	entries = Entries_Open (0);
d1104 11
a1114 3
/* Build all the dirs along the path to DIRS with CVS subdirs with appropriate
   repositories.  If ->repository is NULL, do not create a CVSADM directory
   for that subdirectory; just CVS_CHDIR into it.  */
d1116 1
a1116 1
build_dirs_and_chdir (dirs, sticky)
d1119 1
d1127 4
a1131 1
	mkdir_if_needed (dir);
d1133 5
d1144 3
a1146 1
	if (dirs->repository != NULL)
d1151 1
@


1.6
log
@Integrate local changes
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d64 1
d80 1
d262 1
a262 1
           below in !expand_modules), those files (CVS/Checking.prog
a336 15
    /*
     * if we have more than one argument and where was specified, we make the
     * where, cd into it, and try to shorten names as much as possible.
     * Otherwise, we pass the where as a single argument to do_module.
     */
    if (argc > 1 && where != NULL)
    {
	(void) CVS_MKDIR (where, 0777);
	if ( CVS_CHDIR (where) < 0)
	    error (1, errno, "cannot chdir to %s", where);
	preload_update_dir = xstrdup (where);
	where = (char *) NULL;
	if (!isfile (CVSADM))
	{
	    char *repository;
d338 5
a342 10
	    repository = xmalloc (strlen (CVSroot_directory) + 80);
	    (void) sprintf (repository, "%s/%s/%s", CVSroot_directory,
			    CVSROOTADM, CVSNULLREPOS);
	    if (!isfile (repository))
	    {
		mode_t omask;
		omask = umask (cvsumask);
		(void) CVS_MKDIR (repository, 0777);
		(void) umask (omask);
	    }
d344 2
a345 9
	    /* I'm not sure whether this check is redundant.  */
	    if (!isdir (repository))
		error (1, 0, "there is no repository %s", repository);

	    Create_Admin (".", preload_update_dir, repository,
			  (char *) NULL, (char *) NULL, 0);
	    if (!noexec)
	    {
		FILE *fp;
a346 11
		fp = open_file (CVSADM_ENTSTAT, "w+");
		if (fclose(fp) == EOF)
		    error(1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
		if (server_active)
		    server_set_entstat (preload_update_dir, repository);
#endif
	    }
	    free (repository);
	}
    }
a362 23
    /*
     * if where was specified (-d) and we have not taken care of it already
     * with the multiple arg stuff, and it was not a simple directory name
     * but rather a path, we strip off everything but the last component and
     * attempt to cd to the indicated place.  where then becomes simply the
     * last component
     */
    if (where != NULL && strchr (where, '/') != NULL)
    {
	char *slash;

	slash = strrchr (where, '/');
	*slash = '\0';

	if ( CVS_CHDIR (where) < 0)
	    error (1, errno, "cannot chdir to %s", where);

	preload_update_dir = xstrdup (where);

	where = slash + 1;
	if (*where == '\0')
	    where = NULL;
    }
d400 2
d452 12
a463 11
	Create_Admin (".", dirpath, repository,
		      sticky ? (char *) NULL : tag,
		      sticky ? (char *) NULL : date,

		      /* FIXME?  This is a guess.  If it is important
			 for nonbranch to be set correctly here I
			 think we need to write it one way now and
			 then rewrite it later via WriteTag, once
			 we've had a chance to call RCS_nodeisbranch
			 on each file.  */
		      0);
d483 1
a483 1
checkout_proc (pargc, argv, where, mwhere, mfile, shorten,
d487 1
a487 1
    char *where;
a497 1
    char *cp2;
a498 1
    char *xwhere = NULL;
d500 1
a500 1
    char *prepath;
d508 1
a508 1
     *  shorten = TRUE says shorten as much as possible 
d512 7
a518 2
    /* set up the repository (maybe) for the bottom directory */
    repository = xmalloc (strlen (CVSroot_directory) + strlen (argv[0]) + 5);
d520 2
d527 19
a545 2
    /* fix up argv[] for the case of partial modules */
    if (mfile != NULL)
d547 1
a547 4
	char *file;

	/* if mfile is really a path, straighten it out first */
	if ((cp = strrchr (mfile, '/')) != NULL)
d549 5
a553 40
	    *cp = 0;
	    repository = xrealloc (repository,
				   strlen (repository) + strlen (mfile) + 10);
	    (void) strcat (repository, "/");
	    (void) strcat (repository, mfile);

	    /*
	     * Now we need to fill in the where correctly. if !shorten, tack
	     * the rest of the path onto where if where is filled in
	     * otherwise tack the rest of the path onto mwhere and make that
	     * the where
	     * 
	     * If shorten is enabled, we might use mwhere to set where if 
	     * nobody set it yet, so we'll need to setup mwhere as the last
	     * component of the path we are tacking onto repository
	     */
	    if (!shorten)
	    {
		if (where != NULL)
		{
		    xwhere = xmalloc (strlen (where) + strlen (mfile) + 5);
		    (void) sprintf (xwhere, "%s/%s", where, mfile);
		}
		else
		{
		    xwhere = xmalloc (strlen (mwhere) + strlen (mfile) + 5);
		    (void) sprintf (xwhere, "%s/%s", mwhere, mfile);
		}
		where = xwhere;
	    }
	    else
	    {
		char *slash;

		if ((slash = strrchr (mfile, '/')) != NULL)
		    mwhere = slash + 1;
		else
		    mwhere = mfile;
	    }
	    mfile = cp + 1;
d555 4
d560 1
a560 36
	file = xmalloc (strlen (repository) + strlen (mfile) + 5);
	(void) sprintf (file, "%s/%s", repository, mfile);
	if (isdir (file))
	{

	    /*
	     * The portion of a module was a directory, so kludge up where to
	     * be the subdir, and fix up repository
	     */
	    free (repository);
	    repository = xstrdup (file);

	    /*
	     * At this point, if shorten is not enabled, we make where either
	     * where with mfile concatenated, or if where hadn't been set we
	     * set it to mwhere with mfile concatenated.
	     * 
	     * If shorten is enabled and where hasn't been set yet, then where
	     * becomes mfile
	     */
	    if (!shorten)
	    {
		if (where != NULL)
		{
		    xwhere = xmalloc (strlen (where) + strlen (mfile) + 5);
		    (void) sprintf (xwhere, "%s/%s", where, mfile);
		}
		else
		{
		    xwhere = xmalloc (strlen (mwhere) + strlen (mfile) + 5);
		    (void) sprintf (xwhere, "%s/%s", mwhere, mfile);
		}
		where = xwhere;
	    }
	    else if (where == NULL)
		where = mfile;
d564 12
a575 1
	    int i;
d577 4
a580 16
	    /*
	     * The portion of a module was a file, so kludge up argv to be
	     * correct
	     */
	    for (i = 1; i < *pargc; i++)/* free the old ones */
		free (argv[i]);
	    /* FIXME: Normally one has to realloc argv to make sure
               argv[1] exists.  But this argv does not points to the
               beginning of an allocated block.  For now we allocate
               at least 4 entries for argv (in line2argv).  */
	    argv[1] = xstrdup (mfile);	/* set up the new one */
	    *pargc = 2;

	    /* where gets mwhere if where isn't set */
	    if (where == NULL)
		where = mwhere;
d582 5
a586 1
	free (file);
d588 6
d595 1
a595 5
    /*
     * if shorten is enabled and where isn't specified yet, we pluck the last
     * directory component of argv[0] and make it the where
     */
    if (shorten && where == NULL)
d597 17
a613 1
	if ((cp = strrchr (argv[0], '/')) != NULL)
d615 2
a616 2
	    xwhere = xstrdup (cp + 1);
	    where = xwhere;
a617 1
    }
d619 29
a647 5
    /* if where is still NULL, use mwhere if set or the argv[0] dir */
    if (where == NULL)
    {
	if (mwhere)
	    where = mwhere;
d650 22
a671 2
	    xwhere = xstrdup (argv[0]);
	    where = xwhere;
d673 1
d690 6
a703 1
	size_t root_len;
d705 1
d707 2
a708 11
	/* We need to tell build_dirs not only the path we want it to
	   build, but also the repositories we want it to populate the
	   path with. To accomplish this, we walk the path backwards,
	   one pathname component at a time, constucting a linked
	   list of struct dir_to_build.  */
	prepath = xstrdup (repository);

	/* We don't want to start stripping elements off prepath after we
	   get to CVSROOT.  */
	root_len = strlen (CVSroot_directory);
	if (strncmp (repository, CVSroot_directory, root_len) != 0)
d722 7
a729 2
	cp2 = strrchr (prepath, '/');

d738 18
a755 1
	    if (cp2 == NULL || cp2 < prepath + root_len)
d757 3
a759 15
		/* Don't walk up past CVSROOT; instead put in CVSNULLREPOS.  */
		new->repository =
		    xmalloc (strlen (CVSroot_directory) + 80);
		(void) sprintf (new->repository, "%s/%s/%s",
				CVSroot_directory,
				CVSROOTADM, CVSNULLREPOS);
		if (!isfile (new->repository))
		{
		    mode_t omask;
		    omask = umask (cvsumask);
		    if (CVS_MKDIR (new->repository, 0777) < 0)
			error (0, errno, "cannot create %s",
			       new->repository);
		    (void) umask (omask);
		}
d763 49
a811 3
		new->repository = xmalloc (strlen (prepath));
		strncpy (new->repository, prepath, cp2 - prepath);
		new->repository[cp2 - prepath] = '\0';
d813 1
a817 1
	    cp2 = findslash (prepath, cp2 - 1);
d820 9
a828 5
	/* First build the top-level CVSADM directory.  The value we
	   pass in here for repository is probably wrong; see modules3-7f
	   in the testsuite.  */
	build_one_dir (head->repository != NULL ? head->repository : prepath,
		       ".", *pargc <= 1);
a838 1
	    free (prepath);
a842 3
	/* clean up */
	free (prepath);

d855 1
a855 1
			      (char *) NULL, (char *) NULL, 0);
d878 1
a878 1
			      0);
d1022 1
a1022 2
    if (xwhere != NULL)
	free (xwhere);
d1041 26
@


1.5
log
@Integrate local changes
@
text
@d47 2
a48 1
    "Usage:\n  %s %s [-ANPcflnps] [-r rev | -D date] [-d dir] [-k kopt] modules...\n",
d52 1
d69 1
a69 1
    "Usage: %s %s [-NPfln] [-r rev | -D date] [-d dir] [-k kopt] module...\n",
d73 1
d75 3
a77 3
    "\t-r rev\tCheck out revision or tag.\n",
    "\t-D date\tCheck out revisions as of date.\n",
    "\t-d dir\tCheck out into dir instead of module name.\n",
d138 1
a138 1
    optind = 1;
d224 5
a228 2
    if ((!(cat + status) && argc == 0) || ((cat + status) && argc != 0))
	usage (valid_usage);
d236 2
a237 4
	{
	    error (0, 0, "must specify a tag or date");
	    usage (valid_usage);
	}
a239 8
/*
 * mhy 950615: -kv doesn't work for binaries with RCS keywords.
 * Instead use the default provided in the RCS file (-ko for binaries).
 */
#if 0
	if (!options)
	  options = RCS_check_kflag ("v");/* -kv is default */
#endif
d275 8
a282 4
	if (!run_module_prog) send_arg ("-n");
	if (local) send_arg ("-l");
	if (pipeout) send_arg ("-p");
	if (!force_tag_match) send_arg ("-f");
a292 1
	{
a293 1
	}
d296 1
a296 5
	/* Why not send -k for export?  This would appear to make
	   remote export differ from local export.  FIXME.  */
	if (strcmp (command_name, "export") != 0
	    && options != NULL
	    && options[0] != '\0')
d329 2
a341 2
	char *repository;

d349 2
d380 1
a381 1
	free (repository);
d428 2
d675 4
d988 1
@


1.4
log
@Integrate local changes
@
text
@a38 2
static int build_dirs_and_chdir PROTO((char *dir, char *prepath, char *realdir,
				 int sticky));
d119 1
a119 1
	valid_options = "Nnk:d:flRQqr:D:";
d125 1
a125 1
	valid_options = "ANnk:d:flRpQqcsr:D:j:P";
d298 2
d371 1
a371 1
			  (char *) NULL, (char *) NULL);
d482 54
a560 1
    char *realdirs;
d734 2
d737 5
a741 7
	/*
	 * We need to tell build_dirs not only the path we want it to build,
	 * but also the repositories we want it to populate the path with. To
	 * accomplish this, we pass build_dirs a ``real path'' with valid
	 * repositories and a string to pre-pend based on how many path
	 * elements exist in where. Big Black Magic
	 */
d743 18
d763 1
d766 33
d802 6
a807 2
	*cp2 = '\0';
	realdirs = cp2 + 1;
d815 1
a815 1
	if (build_dirs_and_chdir (where, prepath, realdirs, *pargc <= 1) != 0)
d838 1
a838 1
			      (char *) NULL, (char *) NULL);
d853 9
a861 1
		Create_Admin (".", preload_update_dir, repository, tag, date);
d1017 3
d1026 3
a1028 4
/*
 * build all the dirs along the path to dir with CVS subdirs with appropriate
 * repositories and Entries.Static files
 */
d1030 2
a1031 4
build_dirs_and_chdir (dir, prepath, realdir, sticky)
    char *dir;
    char *prepath;
    char *realdir;
a1033 7
    FILE *fp;
    char *path;
    char *path2;
    char *slash;
    char *slash2;
    char *cp;
    char *cp2;
d1035 1
d1037 1
a1037 5
    path = xstrdup (dir);
    path2 = xstrdup (realdir);
    for (cp = path, cp2 = path2;
    (slash = strchr (cp, '/')) != NULL && (slash2 = strchr (cp2, '/')) != NULL;
	 cp = slash + 1, cp2 = slash2 + 1)
d1039 1
a1039 5
	*slash = '\0';
	*slash2 = '\0';
	if (!isfile (CVSADM) && strcmp (command_name, "export") != 0)
	{
	    char *repository;
d1041 3
a1043 22
	    repository = xmalloc (strlen (prepath) + strlen (path2) + 5);
	    (void) sprintf (repository, "%s/%s", prepath, path2);
	    /* I'm not sure whether this check is redundant.  */
	    if (!isdir (repository))
		error (1, 0, "there is no repository %s", repository);
	    Create_Admin (".", path, repository, sticky ? (char *) NULL : tag,
			  sticky ? (char *) NULL : date);
	    if (!noexec)
	    {
		fp = open_file (CVSADM_ENTSTAT, "w+");
		if (fclose(fp) == EOF)
		    error(1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
		if (server_active)
		    server_set_entstat (path, repository);
#endif
	    }
	    free (repository);
	}
	mkdir_if_needed (cp);
	Subdir_Register ((List *) NULL, (char *) NULL, cp);
	if ( CVS_CHDIR (cp) < 0)
d1045 1
a1045 1
	    error (0, errno, "cannot chdir to %s", cp);
d1049 1
a1049 1
	if (!isfile (CVSADM) && strcmp (command_name, "export") != 0)
d1051 2
a1052 20
	    char *repository;

	    repository = xmalloc (strlen (prepath) + strlen (path2) + 5);
	    (void) sprintf (repository, "%s/%s", prepath, path2);
	    /* I'm not sure whether this check is redundant.  */
	    if (!isdir (repository))
		error (1, 0, "there is no repository %s", repository);
	    Create_Admin (".", path, repository, sticky ? (char *) NULL : tag,
			  sticky ? (char *) NULL : date);
	    if (!noexec)
	    {
		fp = open_file (CVSADM_ENTSTAT, "w+");
		if (fclose(fp) == EOF)
		    error(1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
		if (server_active)
		    server_set_entstat (path, repository);
#endif
	    }
	    free (repository);
d1054 4
a1057 2
	*slash = '/';
	*slash2 = '/';
a1058 3
    if (!isfile (CVSADM) && strcmp (command_name, "export") != 0)
    {
	char *repository;
d1060 1
a1060 30
	repository = xmalloc (strlen (prepath) + strlen (path2) + 5);
	(void) sprintf (repository, "%s/%s", prepath, path2);
	/* I'm not sure whether this check is redundant.  */
	if (!isdir (repository))
	    error (1, 0, "there is no repository %s", repository);
	Create_Admin (".", path, repository, sticky ? (char *) NULL : tag,
		      sticky ? (char *) NULL : date);
	if (!noexec)
	{
	    fp = open_file (CVSADM_ENTSTAT, "w+");
	    if (fclose(fp) == EOF)
		error(1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
	    if (server_active)
		server_set_entstat (path, repository);
#endif
	}
	free (repository);
    }
    mkdir_if_needed (cp);
    Subdir_Register ((List *) NULL, (char *) NULL, cp);
    if ( CVS_CHDIR (cp) < 0)
    {
	error (0, errno, "cannot chdir to %s", cp);
	retval = 1;
	goto out;
    }
out:
    free (path);
    free (path2);
@


1.3
log
@Integrate local changes
@
text
@d314 1
a314 1
	    client_send_expansions (local, where);
d346 1
a346 1
	char repository[PATH_MAX];
d355 1
d385 1
d438 1
a438 1
    char current[PATH_MAX];
d442 1
d444 4
d449 3
d460 1
a460 1
    getwd (current);
d462 2
a463 1
    if (strncmp (current, hardpath, hardpath_len) == 0)
d470 1
a470 1
	    return 0;
d474 1
a474 1
	    return 1;
d476 4
a479 1
    return (1);
d503 2
a504 2
    char repository[PATH_MAX];
    char xwhere[PATH_MAX];
d520 1
d530 1
a530 1
	char file[PATH_MAX];
d536 2
d554 2
d557 1
d559 2
d562 1
d577 1
d586 2
a587 1
	    (void) strcpy (repository, file);
d600 2
d603 1
d605 2
d608 1
d631 1
d642 1
a642 1
	    (void) strcpy (xwhere, cp + 1);
d654 1
a654 1
	    (void) strcpy (xwhere, argv[0]);
d661 5
a665 5
	char tmp[PATH_MAX];

	(void) sprintf (tmp, "%s/%s", preload_update_dir, where);
	free (preload_update_dir);
	preload_update_dir = xstrdup (tmp);
d710 2
a711 3
	    free (preload_update_dir);
	    preload_update_dir = oldupdate;
	    return (1);
d759 2
a760 3
		free (preload_update_dir);
		preload_update_dir = oldupdate;
		return (1);
d776 2
a777 3
	    free (preload_update_dir);
	    preload_update_dir = oldupdate;
	    return (1);
d821 3
d829 1
a829 3
	free (preload_update_dir);
	preload_update_dir = oldupdate;
	return (err);
d884 1
d887 3
d918 2
a919 3
    char repository[PATH_MAX];
    char path[PATH_MAX];
    char path2[PATH_MAX];
d924 1
d926 2
a927 2
    (void) strcpy (path, dir);
    (void) strcpy (path2, realdir);
d934 24
a958 1
	(void) CVS_MKDIR (cp, 0777);
d962 2
a963 1
	    return (1);
d967 3
d986 1
d991 24
a1015 1
    (void) CVS_MKDIR (cp, 0777);
d1019 2
a1020 1
	return (1);
d1022 4
a1025 1
    return (0);
@


1.2
log
@Checking out in dirs having the repository as its prefix was sometimes
wrongly thought as checking out into the repository.  E.g. checking
out in /cvs.g/hack/foo with CVSROOT set to /cvs was impossible.
@
text
@d57 1
a57 1
    "\t-p\tCheck out files to standard output.\n",
d59 2
a60 2
    "\t-r rev\tCheck out revision or tag. (implies -P)\n",
    "\t-D date\tCheck out revisions as of date. (implies -P)\n",
d91 1
d93 1
d223 1
a223 2
    if ((!(cat + status) && argc == 0) || ((cat + status) && argc != 0)
	|| (tag && date))
d273 1
a273 1
	  {
d279 1
a279 1
	  }
d313 3
a315 3
	  {
	    client_send_expansions (local);
	  }
d317 1
a317 1
	  {
d320 1
a320 1
	      send_arg (argv[i]);
d322 1
a322 1
	  }
d349 1
a349 1
	if (chdir (where) < 0)
d355 2
a356 2
	    (void) sprintf (repository, "%s/%s/%s", CVSroot, CVSROOTADM,
			    CVSNULLREPOS);
d369 1
a369 1
	    Create_Admin (".", where, repository,
d386 15
d415 1
a415 1
	if (chdir (where) < 0)
d438 1
a438 1
    int  hardpathlen;
d441 1
a441 1
    x = readlink(CVSroot, hardpath, sizeof hardpath - 1);
d444 1
a444 1
        strcpy(hardpath, CVSroot);
d451 2
a452 3
    hardpathlen = strlen (hardpath);
    if (strncmp(current, hardpath, hardpathlen) == 0
	&& (current[hardpathlen] == '\0' || current[hardpathlen] == '/'))
d454 10
a463 1
        return (0);
d506 1
a506 1
    (void) sprintf (repository, "%s/%s", CVSroot, argv[0]);
d697 1
a697 1
		Create_Admin (".", where, repository,
d713 1
a713 1
		Create_Admin (".", where, repository, tag, date);
d743 1
a743 1
	if (chdir (repository) < 0)
d768 1
a768 1
    if (tag != NULL || date != NULL)
d771 10
a780 2
    /* FIXME: We don't call tag_check_valid on join_rev1 and join_rev2
       yet (make sure to handle ':' correctly if we do, though).  */
d790 1
a790 1
	    history_write ('O', preload_update_dir, tag ? tag : date, where,
a811 1
	    char *user;
d813 12
d826 2
a827 3
	    user = argv[i];
	    vers = Version_TS (repository, options, tag, date, user,
			       force_tag_match, 0, entries, (RCSNode *) NULL);
d830 4
a833 3
		line = xmalloc (strlen (user) + 15);
		(void) sprintf (line, "Initial %s", user);
		Register (entries, user, vers->vn_rcs ? vers->vn_rcs : "0",
d846 1
a846 1
	history_write ('O', preload_update_dir, (tag ? tag : date), where,
d900 1
d902 1
a902 1
	if (chdir (cp) < 0)
d929 1
d931 1
a931 1
    if (chdir (cp) < 0)
@


1.1
log
@Initial revision
@
text
@a37 5
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)checkout.c 1.78 94/10/07 $";
USE(rcsid);
#endif

d87 1
d323 3
a325 5
	if (fprintf
	    (to_server,
	     strcmp (command_name, "export") == 0 ? "export\n" : "co\n")
	    < 0)
	  error (1, errno, "writing to server");
d329 1
a329 1
#endif
d357 3
d361 2
d422 1
d430 4
a433 1
    hardpath[x] = '\0';
d435 3
a437 1
    if (strncmp(current, hardpath, strlen(hardpath)) == 0)
d727 5
d734 1
d736 7
d747 3
d779 1
a779 1
	    char line[MAXLINELEN];
d785 1
a785 1
			       force_tag_match, 0, entries, (List *) NULL);
d788 1
d793 1
d869 1
a869 1
	    Create_Admin (".", cp, repository, sticky ? (char *) NULL : tag,
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a91 1
static int tag_validated = 0;
d327 5
a331 3
	send_to_server (strcmp (command_name, "export") == 0 ?
                        "export\012" : "co\012",
                        0);
d335 1
a335 1
#endif /* CLIENT_SUPPORT */
a362 3
	    {
		mode_t omask;
		omask = umask (cvsumask);
a363 2
		(void) umask (omask);
	    }
a721 5
	if (tag != NULL && !tag_validated)
	{
	    tag_check_valid (tag, *pargc - 1, argv + 1, 0, aflag, NULL);
	    tag_validated = 1;
	}
a723 1
    {
a724 7
	if (tag != NULL && !tag_validated)
	{
	    tag_check_valid (tag, *pargc - 1, argv + 1, 0, aflag,
			     repository);
	    tag_validated = 1;
	}
    }
a728 3
    /* FIXME: We don't call tag_check_valid on join_rev1 and join_rev2
       yet (make sure to handle ':' correctly if we do, though).  */

d758 1
a758 1
	    char *line;
a766 1
		line = xmalloc (strlen (user) + 15);
a770 1
		free (line);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d38 5
d434 1
a434 4
    else
    {
        hardpath[x] = '\0';
    }
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d782 1
a782 1
			       force_tag_match, 0, entries, (RCSNode *) NULL);
d866 1
a866 1
	    Create_Admin (".", path, repository, sticky ? (char *) NULL : tag,
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d57 1
a57 1
    "\t-p\tCheck out files to standard output (avoids stickiness).\n",
d59 2
a60 2
    "\t-r rev\tCheck out revision or tag. (implies -P) (is sticky)\n",
    "\t-D date\tCheck out revisions as of date. (implies -P) (is sticky)\n",
a90 1
static int join_tags_validated = 0;
a91 1
static char *history_name = NULL;
d221 2
a222 1
    if ((!(cat + status) && argc == 0) || ((cat + status) && argc != 0))
d272 1
a272 1
	{
d278 1
a278 1
	}
d312 3
a314 3
	{
	    client_send_expansions (local, where);
	}
d316 1
a316 1
	{
d319 1
a319 1
		send_arg (argv[i]);
d321 1
a321 1
	}
d348 1
a348 1
	if ( CVS_CHDIR (where) < 0)
d354 2
a355 2
	    (void) sprintf (repository, "%s/%s/%s", CVSroot_directory,
			    CVSROOTADM, CVSNULLREPOS);
d368 1
a368 1
	    Create_Admin (".", preload_update_dir, repository,
a384 15
    /* If we will be calling history_write, work out the name to pass
       it.  */
    if (strcmp (command_name, "export") != 0 && !pipeout)
    {
	if (tag && date)
	{
	    history_name = xmalloc (strlen (tag) + strlen (date) + 2);
	    sprintf (history_name, "%s:%s", tag, date);
	}
	else if (tag)
	    history_name = tag;
	else
	    history_name = date;
    }

d399 1
a399 1
	if ( CVS_CHDIR (where) < 0)
a421 1
    size_t hardpath_len;
d424 1
a424 1
    x = readlink(CVSroot_directory, hardpath, sizeof hardpath - 1);
d427 1
a427 1
        strcpy(hardpath, CVSroot_directory);
d434 1
a434 2
    hardpath_len = strlen (hardpath);
    if (strncmp (current, hardpath, hardpath_len) == 0)
d436 1
a436 10
	if (/* Current is a subdirectory of hardpath.  */
	    current[hardpath_len] == '/'

	    /* Current is hardpath itself.  */
	    || current[hardpath_len] == '\0')
	    return 0;
	else
	    /* It isn't a problem.  For example, current is
	       "/foo/cvsroot-bar" and hardpath is "/foo/cvsroot".  */
	    return 1;
d479 1
a479 1
    (void) sprintf (repository, "%s/%s", CVSroot_directory, argv[0]);
d670 1
a670 1
		Create_Admin (".", preload_update_dir, repository,
d686 1
a686 1
		Create_Admin (".", preload_update_dir, repository, tag, date);
d716 1
a716 1
	if ( CVS_CHDIR (repository) < 0)
d741 1
a741 1
    if (tag != NULL || date != NULL || join_rev1 != NULL)
d744 2
a745 10
    if (! join_tags_validated)
    {
        if (join_rev1 != NULL)
	    tag_check_valid_join (join_rev1, *pargc - 1, argv + 1, 0, aflag,
				  repository);
	if (join_rev2 != NULL)
	    tag_check_valid_join (join_rev2, *pargc - 1, argv + 1, 0, aflag,
				  repository);
	join_tags_validated = 1;
    }
d755 1
a755 1
	    history_write ('O', preload_update_dir, history_name, where,
d777 1
a778 12
	    struct file_info finfo;

	    memset (&finfo, 0, sizeof finfo);
	    finfo.file = argv[i];
	    /* Shouldn't be used, so set to arbitrary value.  */
	    finfo.update_dir = NULL;
	    finfo.fullname = argv[i];
	    finfo.repository = repository;
	    finfo.entries = entries;
	    /* The rcs slot is needed to get the options from the RCS
               file */
	    finfo.rcs = RCS_parse (finfo.file, repository);
d780 3
a782 2
	    vers = Version_TS (&finfo, options, tag, date,
			       force_tag_match, 0);
d785 3
a787 4
		line = xmalloc (strlen (finfo.file) + 15);
		(void) sprintf (line, "Initial %s", finfo.file);
		Register (entries, finfo.file,
			  vers->vn_rcs ? vers->vn_rcs : "0",
d800 1
a800 1
	history_write ('O', preload_update_dir, history_name, where,
a853 1
	Subdir_Register ((List *) NULL, (char *) NULL, cp);
d855 1
a855 1
	if ( CVS_CHDIR (cp) < 0)
a881 1
    Subdir_Register ((List *) NULL, (char *) NULL, cp);
d883 1
a883 1
    if ( CVS_CHDIR (cp) < 0)
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d314 1
a314 1
	    client_send_expansions (local, where, 1);
d346 1
a346 1
	char *repository;
a354 1
	    repository = xmalloc (strlen (CVSroot_directory) + 80);
a383 1
	free (repository);
d436 1
a436 1
    char *current;
a439 1
    int retval;
a440 4
#ifdef HAVE_READLINK
    /* FIXME-arbitrary limit: should be retrying this like xgetwd.
       But how does readlink let us know that the buffer was too small?
       (by returning sizeof hardpath - 1?).  */
a441 3
#else
    x = -1;
#endif
d450 1
a450 1
    current = xgetwd ();
d452 1
a452 2
    if (strlen (current) >= hardpath_len
	&& strncmp (current, hardpath, hardpath_len) == 0)
d459 1
a459 1
	    retval = 0;
d463 1
a463 1
	    retval = 1;
d465 1
a465 4
    else
	retval = 1;
    free (current);
    return retval;
d489 2
a490 2
    char *repository;
    char *xwhere = NULL;
a505 1
    repository = xmalloc (strlen (CVSroot_directory) + strlen (argv[0]) + 5);
d515 1
a515 1
	char *file;
a520 2
	    repository = xrealloc (repository,
				   strlen (repository) + strlen (mfile) + 10);
a536 2
		{
		    xwhere = xmalloc (strlen (where) + strlen (mfile) + 5);
a537 1
		}
a538 2
		{
		    xwhere = xmalloc (strlen (mwhere) + strlen (mfile) + 5);
a539 1
		}
a553 1
	file = xmalloc (strlen (repository) + strlen (mfile) + 5);
d562 1
a562 2
	    free (repository);
	    repository = xstrdup (file);
a574 2
		{
		    xwhere = xmalloc (strlen (where) + strlen (mfile) + 5);
a575 1
		}
a576 2
		{
		    xwhere = xmalloc (strlen (mwhere) + strlen (mfile) + 5);
a577 1
		}
a599 1
	free (file);
d610 1
a610 1
	    xwhere = xstrdup (cp + 1);
d622 1
a622 1
	    xwhere = xstrdup (argv[0]);
d629 5
a633 5
	preload_update_dir =
	    xrealloc (preload_update_dir,
		      strlen (preload_update_dir) + strlen (where) + 5);
	strcat (preload_update_dir, "/");
	strcat (preload_update_dir, where);
d678 3
a680 2
	    err = 1;
	    goto out;
d728 3
a730 2
		err = 1;
		goto out;
d746 3
a748 2
	    err = 1;
	    goto out;
a791 3
	else if (strcmp (command_name, "export") == 0 && !pipeout)
	    history_write ('E', preload_update_dir, tag ? tag : date, where,
			   repository);
d797 3
a799 1
	goto out;
a853 1
out:
a855 3
    if (xwhere != NULL)
	free (xwhere);
    free (repository);
d884 3
a886 2
    char *path;
    char *path2;
a890 1
    int retval = 0;
d892 2
a893 2
    path = xstrdup (dir);
    path2 = xstrdup (realdir);
a899 24
	if (!isfile (CVSADM) && strcmp (command_name, "export") != 0)
	{
	    char *repository;

	    repository = xmalloc (strlen (prepath) + strlen (path2) + 5);
	    (void) sprintf (repository, "%s/%s", prepath, path2);
	    /* I'm not sure whether this check is redundant.  */
	    if (!isdir (repository))
		error (1, 0, "there is no repository %s", repository);
	    Create_Admin (".", path, repository, sticky ? (char *) NULL : tag,
			  sticky ? (char *) NULL : date);
	    if (!noexec)
	    {
		fp = open_file (CVSADM_ENTSTAT, "w+");
		if (fclose(fp) == EOF)
		    error(1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
		if (server_active)
		    server_set_entstat (path, repository);
#endif
	    }
	    free (repository);
	}
	mkdir_if_needed (cp);
d901 1
d905 1
a905 2
	    retval = 1;
	    goto out;
a908 3
	    char *repository;

	    repository = xmalloc (strlen (prepath) + strlen (path2) + 5);
a924 1
	    free (repository);
a928 24
    if (!isfile (CVSADM) && strcmp (command_name, "export") != 0)
    {
	char *repository;

	repository = xmalloc (strlen (prepath) + strlen (path2) + 5);
	(void) sprintf (repository, "%s/%s", prepath, path2);
	/* I'm not sure whether this check is redundant.  */
	if (!isdir (repository))
	    error (1, 0, "there is no repository %s", repository);
	Create_Admin (".", path, repository, sticky ? (char *) NULL : tag,
		      sticky ? (char *) NULL : date);
	if (!noexec)
	{
	    fp = open_file (CVSADM_ENTSTAT, "w+");
	    if (fclose(fp) == EOF)
		error(1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
	    if (server_active)
		server_set_entstat (path, repository);
#endif
	}
	free (repository);
    }
    mkdir_if_needed (cp);
d930 1
d934 1
a934 2
	retval = 1;
	goto out;
d936 1
a936 4
out:
    free (path);
    free (path2);
    return retval;
@


1.1.1.7
log
@Latest release from Cyclic Software
@
text
@d39 2
d121 1
a121 1
	valid_options = "+Nnk:d:flRQqr:D:";
d127 1
a127 1
	valid_options = "+ANnk:d:flRpQqcsr:D:j:P";
a299 2
	/* Why not send -k for export?  This would appear to make
	   remote export differ from local export.  FIXME.  */
d371 1
a371 1
			  (char *) NULL, (char *) NULL, 0);
a481 54
struct dir_to_build
{
    /* What to put in CVS/Repository.  */
    char *repository;
    /* The path to the directory.  */
    char *dirpath;

    struct dir_to_build *next;
};

static int build_dirs_and_chdir PROTO ((struct dir_to_build *list,
					int sticky));

static void build_one_dir PROTO ((char *, char *, int));

static void
build_one_dir (repository, dirpath, sticky)
    char *repository;
    char *dirpath;
    int sticky;
{
    FILE *fp;

    if (!isfile (CVSADM) && strcmp (command_name, "export") != 0)
    {
	/* I suspect that this check could be omitted.  */
	if (!isdir (repository))
	    error (1, 0, "there is no repository %s", repository);

	Create_Admin (".", dirpath, repository,
		      sticky ? (char *) NULL : tag,
		      sticky ? (char *) NULL : date,

		      /* FIXME?  This is a guess.  If it is important
			 for nonbranch to be set correctly here I
			 think we need to write it one way now and
			 then rewrite it later via WriteTag, once
			 we've had a chance to call RCS_nodeisbranch
			 on each file.  */
		      0);

	if (!noexec)
	{
	    fp = open_file (CVSADM_ENTSTAT, "w+");
	    if (fclose (fp) == EOF)
		error (1, errno, "cannot close %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
	    if (server_active)
		server_set_entstat (dirpath, repository);
#endif
	}
    }
}

d507 1
a680 2
	size_t root_len;
	struct dir_to_build *head;
d682 7
a688 5
	/* We need to tell build_dirs not only the path we want it to
	   build, but also the repositories we want it to populate the
	   path with. To accomplish this, we walk the path backwards,
	   one pathname component at a time, constucting a linked
	   list of struct dir_to_build.  */
a689 18

	/* We don't want to start stripping elements off prepath after we
	   get to CVSROOT.  */
	root_len = strlen (CVSroot_directory);
	if (strncmp (repository, CVSroot_directory, root_len) != 0)
	    error (1, 0, "\
internal error: %s doesn't start with %s in checkout_proc",
		   repository, CVSroot_directory);

	/* We always create at least one directory, which corresponds to
	   the entire strings for WHERE and REPOSITORY.  */
	head = (struct dir_to_build *) xmalloc (sizeof (struct dir_to_build));
	/* Special marker to indicate that we don't want build_dirs_and_chdir
	   to create the CVSADM directory for us.  */
	head->repository = NULL;
	head->dirpath = xstrdup (where);
	head->next = NULL;

a691 1

a693 33
	    struct dir_to_build *new;
	    new = (struct dir_to_build *)
		xmalloc (sizeof (struct dir_to_build));
	    new->dirpath = xmalloc (strlen (where));
	    strncpy (new->dirpath, where, cp - where);
	    new->dirpath[cp - where] = '\0';
	    if (cp2 == NULL || cp2 < prepath + root_len)
	    {
		/* Don't walk up past CVSROOT; instead put in CVSNULLREPOS.  */
		new->repository =
		    xmalloc (strlen (CVSroot_directory) + 80);
		(void) sprintf (new->repository, "%s/%s/%s",
				CVSroot_directory,
				CVSROOTADM, CVSNULLREPOS);
		if (!isfile (new->repository))
		{
		    mode_t omask;
		    omask = umask (cvsumask);
		    if (CVS_MKDIR (new->repository, 0777) < 0)
			error (0, errno, "cannot create %s",
			       new->repository);
		    (void) umask (omask);
		}
	    }
	    else
	    {
		new->repository = xmalloc (strlen (prepath));
		strncpy (new->repository, prepath, cp2 - prepath);
		new->repository[cp2 - prepath] = '\0';
	    }
	    new->next = head;
	    head = new;

d697 2
a698 6

	/* First build the top-level CVSADM directory.  The value we
	   pass in here for repository is probably wrong; see modules3-7f
	   in the testsuite.  */
	build_one_dir (head->repository != NULL ? head->repository : prepath,
		       ".", *pargc <= 1);
d706 1
a706 1
	if (build_dirs_and_chdir (head, *pargc <= 1) != 0)
d729 1
a729 1
			      (char *) NULL, (char *) NULL, 0);
d744 1
a744 9
		Create_Admin (".", preload_update_dir, repository, tag, date,

			      /* FIXME?  This is a guess.  If it is important
				 for nonbranch to be set correctly here I
				 think we need to write it one way now and
				 then rewrite it later via WriteTag, once
				 we've had a chance to call RCS_nodeisbranch
				 on each file.  */
			      0);
a899 3
    /* FIXME: indexing off the start of the array like this is *NOT*
       OK according to ANSI, and will break some of the time on certain
       segmented architectures.  */
d906 4
a909 3
/* Build all the dirs along the path to DIRS with CVS subdirs with appropriate
   repositories.  If ->repository is NULL, do not create a CVSADM directory
   for that subdirectory; just CVS_CHDIR into it.  */
d911 4
a914 2
build_dirs_and_chdir (dirs, sticky)
    struct dir_to_build *dirs;
d917 7
a924 1
    struct dir_to_build *nextdir;
d926 5
a930 1
    while (dirs != NULL)
d932 5
a936 1
	char *dir = last_component (dirs->dirpath);
d938 22
a959 3
	mkdir_if_needed (dir);
	Subdir_Register (NULL, NULL, dir);
	if (CVS_CHDIR (dir) < 0)
d961 1
a961 1
	    error (0, errno, "cannot chdir to %s", dir);
d965 1
a965 1
	if (dirs->repository != NULL)
d967 20
a986 2
	    build_one_dir (dirs->repository, dirs->dirpath, sticky);
	    free (dirs->repository);
d988 2
a989 4
	nextdir = dirs->next;
	free (dirs->dirpath);
	free (dirs);
	dirs = nextdir;
d991 3
d995 30
a1024 1
 out:
@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@d47 1
a47 2
    "Usage:\n  %s %s [-ANPRcflnps] [-r rev | -D date] [-d dir]\n",
    "    [-j rev1] [-j rev2] [-k kopt] modules...\n",
a50 1
    "\t-R\tProcess directories recursively.\n",
d67 1
a67 1
    "Usage: %s %s [-NRfln] [-r rev | -D date] [-d dir] [-k kopt] module...\n",
a70 1
    "\t-R\tProcess directories recursively (default).\n",
d72 3
a74 3
    "\t-r rev\tExport revision or tag.\n",
    "\t-D date\tExport revisions as of date.\n",
    "\t-d dir\tExport into dir instead of module name.\n",
d135 1
a135 1
    optind = 0;
d221 2
a222 5
    if ((cat || status) && argc != 0)
	error (1, 0, "-c and -s must not get any arguments");

    if (!(cat || status) && argc == 0)
	error (1, 0, "must specify at least one module or directory");
d230 4
a233 2
	    error (1, 0, "must specify a tag or date");

d236 8
d279 4
a282 8
	if (!run_module_prog)
	    send_arg ("-n");
	if (local)
	    send_arg ("-l");
	if (pipeout)
	    send_arg ("-p");
	if (!force_tag_match)
	    send_arg ("-f");
d293 1
d295 1
d298 5
a302 1
	if (options != NULL && options[0] != '\0')
a334 2
	if (options)
	    free (options);
d346 2
a354 2
	    char *repository;

a383 1
	    free (repository);
d385 1
a431 2
    if (options)
	free (options);
a676 4
	    /* FIXME: Normally one has to realloc argv to make sure
               argv[1] exists.  But this argv does not points to the
               beginning of an allocated block.  For now we allocate
               at least 4 entries for argv (in line2argv).  */
a985 1
	    freercsnode (&finfo.rcs);
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
a63 1
    "(Specify the --help global option for a list of other help options)\n",
a78 1
    "(Specify the --help global option for a list of other help options)\n",
d260 1
a260 1
           below in !expand_modules), those files (CVS/Checkin.prog
d335 15
d351 10
a360 5
    /* If we've specified something like "cvs co foo/bar baz/quux"
       don't try to shorten names.  There are a few cases in which we
       could shorten (e.g. "cvs co foo/bar foo/baz"), but we don't
       handle those yet.  Better to have an extra directory created
       than the thing checked out under the wrong directory name. */
d362 9
a370 2
    if (argc > 1)
	shorten = 0;
d372 11
d399 23
a458 2
    if (current == NULL)
	error (1, errno, "could not get working directory");
d509 11
a519 12
	if (Create_Admin (".", dirpath, repository,
			  sticky ? (char *) NULL : tag,
			  sticky ? (char *) NULL : date,

			  /* FIXME?  This is a guess.  If it is important
			     for nonbranch to be set correctly here I
			     think we need to write it one way now and
			     then rewrite it later via WriteTag, once
			     we've had a chance to call RCS_nodeisbranch
			     on each file.  */
			  0, 1))
	    return;
d539 1
a539 1
checkout_proc (pargc, argv, where_orig, mwhere, mfile, shorten,
d543 1
a543 1
    char *where_orig;
d554 1
d556 1
d558 1
a558 1
    char *where;
d566 1
a566 1
     *  shorten = 1 says shorten as much as possible 
d570 2
a571 7
    /* Set up the repository (maybe) for the bottom directory.
       Allocate more space than we need so we don't need to keep
       reallocating this string. */
    repository = xmalloc (strlen (CVSroot_directory)
			  + strlen (argv[0])
			  + (mfile == NULL ? 0 : strlen (mfile))
			  + 10);
a572 2
    Sanitize_Repository_Name (repository);

d578 4
d583 2
a584 20
    /* Allocate space and set up the where variable.  We allocate more
       space than necessary here so that we don't have to keep
       reallocaing it later on. */
    
    where = xmalloc (strlen (argv[0])
		     + (mfile == NULL ? 0 : strlen (mfile))
		     + (mwhere == NULL ? 0 : strlen (mwhere))
		     + (where_orig == NULL ? 0 : strlen (where_orig))
		     + 10);

    /* Yes, this could be written in a less verbose way, but in this
       form it is quite easy to read.
    
       FIXME?  The following code that sets should probably be moved
       to do_module in modules.c, since there is similar code in
       patch.c and rtag.c. */
    
    if (shorten)
    {
	if (where_orig != NULL)
d586 40
a625 5
	    /* If the user has specified a directory with `-d' on the
	       command line, use it preferentially, even over the `-d'
	       flag in the modules file. */
    
	    (void) strcpy (where, where_orig);
a626 4
	else if (mwhere != NULL)
	{
	    /* Second preference is the value of mwhere, which is from
	       the `-d' flag in the modules file. */
d628 36
a663 1
	    (void) strcpy (where, mwhere);
d667 18
a684 4
	    /* Third preference is the directory specified in argv[0]
	       which is this module'e directory in the repository. */
	    
	    (void) strcpy (where, argv[0]);
d686 1
d688 6
a693 1
    else
d695 1
a695 6
	/* Use the same preferences here, bug don't shorten -- that
           is, tack on where_orig if it exists. */

	*where = '\0';

	if (where_orig != NULL)
d697 2
a698 2
	    (void) strcat (where, where_orig);
	    (void) strcat (where, "/");
a699 5

	if (mwhere != NULL)
	    (void) strcat (where, mwhere);
	else
	    (void) strcat (where, argv[0]);
a700 2
    strip_trailing_slashes (where); /* necessary? */

d702 2
a703 5
    /* At this point, the user may have asked for a single file or
       directory from within a module.  In that case, we should modify
       where, repository, and argv as appropriate. */

    if (mfile != NULL)
d705 2
a706 51
	/* The mfile variable can have one or more path elements.  If
	   it has multiple elements, we want to tack those onto both
	   repository and where.  The last element may refer to either
	   a file or directory.  Here's what to do:

	   it refers to a directory
	     -> simply tack it on to where and repository
	   it refers to a file
	     -> munge argv to contain `basename mfile` */

	char *cp;
	char *path;


	/* Paranoia check. */

	if (mfile[strlen (mfile) - 1] == '/')
	{
	    error (0, 0, "checkout_proc: trailing slash on mfile (%s)!",
		   mfile);
	}


	/* Does mfile have multiple path elements? */

	cp = strrchr (mfile, '/');
	if (cp != NULL)
	{
	    *cp = '\0';
	    (void) strcat (repository, "/");
	    (void) strcat (repository, mfile);
	    (void) strcat (where, "/");
	    (void) strcat (where, mfile);
	    mfile = cp + 1;
	}
	

	/* Now mfile is a single path element. */

	path = xmalloc (strlen (repository) + strlen (mfile) + 5);
	(void) sprintf (path, "%s/%s", repository, mfile);
	if (isdir (path))
	{
	    /* It's a directory, so tack it on to repository and
               where, as we did above. */

	    (void) strcat (repository, "/");
	    (void) strcat (repository, mfile);
	    (void) strcat (where, "/");
	    (void) strcat (where, mfile);
	}
d709 2
a710 22
	    /* It's a file, which means we have to screw around with
               argv. */

	    int i;


	    /* Paranoia check. */
	    
	    if (*pargc > 1)
	    {
		error (0, 0, "checkout_proc: trashing argv elements!");
		for (i = 1; i < *pargc; i++)
		{
		    error (0, 0, "checkout_proc: argv[%d] `%s'",
			   i, argv[i]);
		}
	    }

	    for (i = 1; i < *pargc; i++)
		free (argv[i]);
	    argv[1] = xstrdup (mfile);
	    (*pargc) = 2;
a711 1
	free (path);
a727 6
     *
     * We need to tell build_dirs not only the path we want it to
     * build, but also the repositories we want it to populate the
     * path with.  To accomplish this, we walk the path backwards, one
     * pathname component at a time, constucting a linked list of
     * struct dir_to_build.
d736 1
a737 1
	char *reposcopy;
d739 11
a749 2
	if (strncmp (repository, CVSroot_directory,
		     strlen (CVSroot_directory)) != 0)
d763 2
a765 7
	/* Make a copy of the repository name to play with. */
	reposcopy = xstrdup (repository);

	/* FIXME: this should be written in terms of last_component instead
	   of hardcoding '/'.  This presumably affects OS/2, NT, &c, if
	   the user specifies '\'.  Likewise for the call to findslash.  */
	cp = strrchr (where, '/');
d774 1
a774 18

	    /* Now figure out what repository directory to generate.
               The most complete case would be something like this:

	       The modules file contains
	         foo -d bar/baz quux

	       The command issued was:
	         cvs co -d what/ever -N foo
	       
	       The results in the CVS/Repository files should be:
	         .     -> .          (this is where we executed the cmd)
		 what  -> Emptydir   (generated dir -- not in repos)
		 ever  -> .          (same as "cd what/ever; cvs co -N foo")
		 bar   -> Emptydir   (generated dir -- not in repos)
		 baz   -> quux       (finally!) */
	    
	    if (strcmp (reposcopy, CVSroot_directory) == 0)
d776 15
a790 3
		/* We can't walk up past CVSROOT.  Instead, the
                   repository should be Emptydir. */
		new->repository = emptydir_name ();
d794 3
a796 49
		if ((where_orig != NULL)
		    && (strcmp (new->dirpath, where_orig) == 0))
		{
		    /* It's the case that the user specified a
		     * destination directory with the "-d" flag.  The
		     * repository in this directory should be "."
		     * since the user's command is equivalent to:
		     *
		     *   cd <dir>; cvs co blah   */

		    strcpy (reposcopy, CVSroot_directory);
		    goto allocate_repos;
		}
		else if (mwhere != NULL)
		{
		    /* This is a generated directory, so point to
                       CVSNULLREPOS. */

		    new->repository = emptydir_name ();
		}
		else
		{
		    /* It's a directory in the repository! */
		    
		    char *rp = strrchr (reposcopy, '/');
		    
		    /* We'll always be below CVSROOT, but check for
		       paranoia's sake. */
		    if (rp == NULL)
			error (1, 0,
			       "internal error: %s doesn't contain a slash",
			       reposcopy);
			   
		    *rp = '\0';
		
		allocate_repos:
		    new->repository = xmalloc (strlen (reposcopy) + 5);
		    (void) strcpy (new->repository, reposcopy);
		    
		    if (strcmp (reposcopy, CVSroot_directory) == 0)
		    {
			/* Special case -- the repository name needs
			   to be "/path/to/repos/." (the trailing dot
			   is important).  We might be able to get rid
			   of this after the we check out the other
			   code that handles repository names. */
			(void) strcat (new->repository, "/.");
		    }
		}
a797 1
	    
d802 1
d805 5
a809 9
	/* clean up */
	free (reposcopy);

	/* The top-level CVSADM directory should always be
           CVSroot_directory.  Create it.
	
	   It may be argued that we shouldn't set any sticky bits for
	   the top-level repository.  FIXME?  */
	build_one_dir (CVSroot_directory, ".", *pargc <= 1);
d820 1
d825 3
d840 1
a840 1
			      (char *) NULL, (char *) NULL, 0, 0);
d863 1
a863 1
			      0, 0);
d1007 2
a1008 1
    free (where);
a1026 26
}

/* Return a newly malloc'd string containing a pathname for CVSNULLREPOS,
   and make sure that it exists.  If there is an error creating the
   directory, give a fatal error.  Otherwise, the directory is guaranteed
   to exist when we return.  */
char *
emptydir_name ()
{
    char *repository;

    repository = xmalloc (strlen (CVSroot_directory) 
			  + sizeof (CVSROOTADM)
			  + sizeof (CVSNULLREPOS)
			  + 10);
    (void) sprintf (repository, "%s/%s/%s", CVSroot_directory,
		    CVSROOTADM, CVSNULLREPOS);
    if (!isfile (repository))
    {
	mode_t omask;
	omask = umask (cvsumask);
	if (CVS_MKDIR (repository, 0777) < 0)
	    error (1, errno, "cannot create %s", repository);
	(void) umask (omask);
    }
    return repository;
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@a35 1
#include <assert.h>
d434 1
a434 1
					int sticky, int check_existing_dirs));
d583 1
a583 5
	/* If the -d flag in the modules file specified an absolute
           directory, let the user override it with the command-line
           -d option. */

	if ((mwhere != NULL) && (! isabsolute (mwhere)))
d726 5
a730 6
	/* FIXME: this should be written in terms of last_component
	   instead of hardcoding '/'.  This presumably affects OS/2,
	   NT, &c, if the user specifies '\'.  Likewise for the call
	   to findslash.  */
	cp = where + strlen (where);
	while (1)
a732 5

	    cp = findslash (where, cp - 1);
	    if (cp == NULL)
		break;		/* we're done */

d736 2
a738 16
	    /* If the user specified an absolute path for where, the
               last path element we create should be the top-level
               directory. */

	    if (cp - where)
	    {
		strncpy (new->dirpath, where, cp - where);
		new->dirpath[cp - where] = '\0';
	    }
	    else
	    {
		/* where should always be at least one character long. */
		assert (strlen (where));
		strcpy (new->dirpath, "/");
	    }
	    
d816 2
d823 14
d838 3
a840 29
	    int where_is_absolute = isabsolute (where);
	    
	    /* The top-level CVSADM directory should always be
	       CVSroot_directory.  Create it, but only if WHERE is
	       relative.  If WHERE is absolute, our current directory
	       may not have a thing to do with where the sources are
	       being checked out.  If it does, build_dirs_and_chdir
	       will take care of creating adm files here. */
	       
	    if (! where_is_absolute)
	    {
		/* It may be argued that we shouldn't set any sticky
		   bits for the top-level repository.  FIXME?  */
		build_one_dir (CVSroot_directory, ".", *pargc <= 1);
	    }


	    /* Build dirs on the path if necessary and leave us in the
	       bottom directory (where if where was specified) doesn't
	       contain a CVS subdir yet, but all the others contain
	       CVS and Entries.Static files */

	    if (build_dirs_and_chdir (head, *pargc <= 1,
				      where_is_absolute) != 0)
	    {
		error (0, 0, "ignoring module %s", omodule);
		err = 1;
		goto out;
	    }
d972 1
a972 1
	entries = Entries_Open (0, NULL);
d1069 3
a1071 11

/* Build all the dirs along the path to DIRS with CVS subdirs with
   appropriate repositories.  If ->repository is NULL, do not create a
   CVSADM directory for that subdirectory; just CVS_CHDIR into it.  If
   check_existing_dirs is nonzero, don't create directories if they
   already exist, and don't try to write adm files in directories
   where we don't have write permission.  We use this last option
   primarily when a user has specified an absolute path for checkout
   -- we will often not have permission to top-level directories, so
   we shouldn't complain. */

d1073 1
a1073 1
build_dirs_and_chdir (dirs, sticky, check_existing_dirs)
a1075 1
    int check_existing_dirs;
a1082 4
	int dir_is_writeable;

	if ((! check_existing_dirs) || (! isdir (dir)))
	    mkdir_if_needed (dir);
d1084 1
a1085 5

	/* This is an expensive call -- only make it if necessary. */
	if (check_existing_dirs)
	    dir_is_writeable = iswritable (dir);

d1092 1
a1092 3

	if ((dirs->repository != NULL)
	    && ((! check_existing_dirs) || dir_is_writeable))
a1096 1

@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a244 7
#ifdef SERVER_SUPPORT
    if (server_active && where != NULL)
    {
	server_pathname_check (where);
    }
#endif

a430 4
    /* If set, don't build the directory, just change to it.
       The caller will also want to set REPOSITORY to NULL.  */
    int just_chdir;

d435 1
a435 1
					int sticky));
a725 1
	head->just_chdir = 0;
d763 1
a763 20
	    new->next = head;
	    head = new;

	    /* If where consists of multiple pathname components,
	       then we want to just cd into it, without creating
	       directories or modifying CVS directories as we go.
	       In CVS 1.9 and earlier, the code actually does a
	       CVS_CHDIR up-front; I'm not going to try to go back
	       to that exact code but this is somewhat similar
	       in spirit.  */
	    if (where_orig != NULL
		&& cp - where < strlen (where_orig))
	    {
		new->repository = NULL;
		new->just_chdir = 1;
		continue;
	    }

	    new->just_chdir = 0;

d774 2
a775 3
	         .     -> (don't touch CVS/Repository)
			  (I think this case might be buggy currently)
		 what  -> (don't touch CVS/Repository)
d779 1
a779 1

d838 3
d855 1
a855 5
	    /* FIXME: checking where_is_absolute is a horrid kludge;
	       I suspect we probably can just skip the call to
	       build_one_dir whenever the -d command option was specified
	       to checkout.  */

d869 2
a870 1
	    if (build_dirs_and_chdir (head, *pargc <= 1) != 0)
d1104 11
a1114 3
/* Build all the dirs along the path to DIRS with CVS subdirs with appropriate
   repositories.  If ->repository is NULL, do not create a CVSADM directory
   for that subdirectory; just CVS_CHDIR into it.  */
d1116 1
a1116 1
build_dirs_and_chdir (dirs, sticky)
d1119 1
d1127 1
d1129 1
a1129 2
	if (!dirs->just_chdir)
	{
d1131 6
a1136 2
	    Subdir_Register (NULL, NULL, dir);
	}
d1144 3
a1146 1
	if (dirs->repository != NULL)
d1151 1
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d889 1
a889 1
	    if (! where_is_absolute && top_level_admin)
a893 13

#ifdef SERVER_SUPPORT
		/* We _always_ want to have a top-level admin
		   directory.  If we're running in client/server mode,
		   send a "Clear-static-directory" command to make
		   sure it is created on the client side.  (See 5.10
		   in cvsclient.dvi to convince yourself that this is
		   OK.)  If this is a duplicate command being sent, it
		   will be ignored on the client side.  */

		if (server_active)
		    server_clear_entstat (".", CVSroot_directory);
#endif
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@d241 1
a241 1
	if (tag && isdigit ((unsigned char) tag[0]))
@


1.1.1.14
log
@Latest from Cyclic Software
@
text
@d40 1
a40 1
static int checkout_proc PROTO((int argc, char **argv, char *where,
d44 1
a97 1
static enum mtype m_type;
d114 1
d236 1
a236 1
    if (m_type == EXPORT)
d297 1
a297 1
	if (checkout_prune_dirs && m_type == CHECKOUT)
d328 4
a331 1
	send_to_server (m_type == EXPORT ? "export\012" : "co\012", 0);
d358 1
a358 1
    if (m_type == CHECKOUT && !pipeout)
d382 1
a382 4
/* FIXME: This is and emptydir_name are in checkout.c for historical
   reasons, probably want to move them.  */

int
d458 1
a458 6
    if (isfile (CVSADM))
    {
	if (m_type == EXPORT)
	    error (1, 0, "cannot export into a working directory");
    }
    else if (m_type == CHECKOUT)
d474 1
a474 1
			  0, 1, 1))
d495 1
a495 1
checkout_proc (argc, argv, where_orig, mwhere, mfile, shorten,
d497 1
a497 1
    int argc;
a506 1
    char *myargv[2];
d668 20
a687 4
	    myargv[0] = argv[0];
	    myargv[1] = mfile;
	    argc = 2;
	    argv = myargv;
d748 1
a748 1
	while (cp > where)
d764 1
a764 1
	    if (cp > where)
d772 1
a772 1
		assert (where[0] != '\0');
d844 1
a844 1
		    char *rp;
a847 1
		    rp = strrchr (reposcopy, '/');
d893 1
a893 1
		build_one_dir (CVSroot_directory, ".", argc <= 1);
d915 1
a915 1
	    if (build_dirs_and_chdir (head, argc <= 1) != 0)
d928 1
a928 1
	    if (!noexec && argc > 1)
d935 1
a935 2
			      (char *) NULL, (char *) NULL, 0, 0,
			      m_type == CHECKOUT);
d958 1
a958 1
			      0, 0, m_type == CHECKOUT);
a964 3
	    if (m_type == EXPORT)
		error (1, 0, "cannot export into working directory");

d996 1
a996 1
	    tag_check_valid (tag, argc - 1, argv + 1, 0, aflag, NULL);
d1005 1
a1005 1
	    tag_check_valid (tag, argc - 1, argv + 1, 0, aflag,
d1017 1
a1017 1
	    tag_check_valid_join (join_rev1, argc - 1, argv + 1, 0, aflag,
d1020 1
a1020 1
	    tag_check_valid_join (join_rev2, argc - 1, argv + 1, 0, aflag,
d1030 1
a1030 1
    if (!(local_specified || argc > 1))
d1032 1
a1032 1
	if (m_type == CHECKOUT && !pipeout)
d1035 1
a1035 1
	else if (m_type == EXPORT && !pipeout)
d1053 1
a1053 1
	for (i = 1; i < argc; i++)
d1090 1
a1090 1
    if (m_type == CHECKOUT && !pipeout)
d1095 1
a1095 1
    err += do_update (argc - 1, argv + 1, options, tag, date,
d1112 9
a1120 7
    for (;;)
    {
	if (*p == '/') return p;
	if (p == start) break;
	--p;
    }
    return NULL;
a1187 9
    while (dirs != NULL)
    {
	if (dirs->repository != NULL)
	    free (dirs->repository);
	nextdir = dirs->next;
	free (dirs->dirpath);
	free (dirs);
	dirs = nextdir;
    }
@


1.1.1.15
log
@Latest from Cyclic Software
@
text
@d47 1
a47 1
    "Usage:\n  %s %s [-ANPRcflnps] [-r rev] [-D date] [-d dir]\n",
d62 1
a62 1
    "\t-k kopt\tUse RCS kopt -k option on checkout. (is sticky)\n",
d70 1
a70 1
    "Usage: %s %s [-NRfln] [-r rev] [-D date] [-d dir] [-k kopt] module...\n",
d193 1
a193 1
		cat = status = 1;
d226 1
a226 1
    if (cat && argc != 0)
d229 1
a229 1
    if (!cat && argc == 0)
d251 1
a251 1
    if (!cat && !safe_location()) {
d256 1
a256 1
    if (current_parsed_root->isremote)
d272 1
a272 1
	expand_modules = (!cat && !pipeout
d299 1
a299 1
	if (cat && !status)
d332 1
a332 1
    if (cat)
d370 1
a370 1
			  where, shorten, local, run_module_prog, !pipeout,
d394 1
a394 1
    x = readlink(current_parsed_root->directory, hardpath, sizeof hardpath - 1);
d400 1
a400 1
        strcpy(hardpath, current_parsed_root->directory);
d469 2
a470 2
			  sticky ? tag : (char *) NULL,
			  sticky ? date : (char *) NULL,
d532 1
a532 1
    repository = xmalloc (strlen (current_parsed_root->directory)
d536 1
a536 1
    (void) sprintf (repository, "%s/%s", current_parsed_root->directory, argv[0]);
d712 2
a713 2
	if (strncmp (repository, current_parsed_root->directory,
		     strlen (current_parsed_root->directory)) != 0)
d716 1
a716 1
		   repository, current_parsed_root->directory);
d801 1
a801 1
	    if (strcmp (reposcopy, current_parsed_root->directory) == 0)
d809 23
a831 1
		/* It's a directory in the repository! */
d833 1
a833 1
		char *rp;
d835 7
a841 7
		/* We'll always be below CVSROOT, but check for
		   paranoia's sake. */
		rp = strrchr (reposcopy, '/');
		if (rp == NULL)
		    error (1, 0,
			   "internal error: %s doesn't contain a slash",
			   reposcopy);
d843 5
a847 3
		*rp = '\0';
		new->repository = xmalloc (strlen (reposcopy) + 5);
		(void) strcpy (new->repository, reposcopy);
d849 9
a857 8
		if (strcmp (reposcopy, current_parsed_root->directory) == 0)
		{
		    /* Special case -- the repository name needs
		       to be "/path/to/repos/." (the trailing dot
		       is important).  We might be able to get rid
		       of this after the we check out the other
		       code that handles repository names. */
		    (void) strcat (new->repository, "/.");
d869 1
a869 1
	       current_parsed_root->directory.  Create it, but only if WHERE is
d883 1
a883 1
		build_one_dir (current_parsed_root->directory, ".", argc <= 1);
d895 1
a895 1
		    server_clear_entstat (".", current_parsed_root->directory);
d1036 1
a1036 1
			  preload_update_dir, m_type == CHECKOUT);
d1092 1
a1092 1
		      join_rev2, preload_update_dir, m_type == CHECKOUT);
d1124 1
a1124 1
    repository = xmalloc (strlen (current_parsed_root->directory) 
d1127 2
a1128 2
			  + 3);
    (void) sprintf (repository, "%s/%s/%s", current_parsed_root->directory,
@


