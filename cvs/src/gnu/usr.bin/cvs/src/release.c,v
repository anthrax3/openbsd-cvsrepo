head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.22
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.18
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.14
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.16
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.8
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.12
	OPENBSD_5_1:1.1.1.12.0.44
	OPENBSD_5_0:1.1.1.12.0.42
	OPENBSD_5_0_BASE:1.1.1.12
	OPENBSD_4_9:1.1.1.12.0.40
	OPENBSD_4_9_BASE:1.1.1.12
	OPENBSD_4_8:1.1.1.12.0.38
	OPENBSD_4_8_BASE:1.1.1.12
	OPENBSD_4_7:1.1.1.12.0.34
	OPENBSD_4_7_BASE:1.1.1.12
	OPENBSD_4_6:1.1.1.12.0.36
	OPENBSD_4_6_BASE:1.1.1.12
	OPENBSD_4_5:1.1.1.12.0.32
	OPENBSD_4_5_BASE:1.1.1.12
	OPENBSD_4_4:1.1.1.12.0.30
	OPENBSD_4_4_BASE:1.1.1.12
	OPENBSD_4_3:1.1.1.12.0.28
	OPENBSD_4_3_BASE:1.1.1.12
	OPENBSD_4_2:1.1.1.12.0.26
	OPENBSD_4_2_BASE:1.1.1.12
	OPENBSD_4_1:1.1.1.12.0.24
	OPENBSD_4_1_BASE:1.1.1.12
	OPENBSD_4_0:1.1.1.12.0.22
	OPENBSD_4_0_BASE:1.1.1.12
	OPENBSD_3_9:1.1.1.12.0.20
	OPENBSD_3_9_BASE:1.1.1.12
	OPENBSD_3_8:1.1.1.12.0.18
	OPENBSD_3_8_BASE:1.1.1.12
	OPENBSD_3_7:1.1.1.12.0.16
	OPENBSD_3_7_BASE:1.1.1.12
	OPENBSD_3_6:1.1.1.12.0.14
	OPENBSD_3_6_BASE:1.1.1.12
	OPENBSD_3_5:1.1.1.12.0.12
	OPENBSD_3_5_BASE:1.1.1.12
	OPENBSD_3_4:1.1.1.12.0.10
	OPENBSD_3_4_BASE:1.1.1.12
	OPENBSD_3_3:1.1.1.12.0.8
	OPENBSD_3_3_BASE:1.1.1.12
	OPENBSD_3_2:1.1.1.12.0.6
	OPENBSD_3_2_BASE:1.1.1.12
	OPENBSD_3_1:1.1.1.12.0.4
	OPENBSD_3_1_BASE:1.1.1.12
	OPENBSD_3_0:1.1.1.12.0.2
	OPENBSD_3_0_BASE:1.1.1.12
	cvs-1-11-1p1:1.1.1.12
	OPENBSD_2_9:1.1.1.11.0.2
	OPENBSD_2_9_BASE:1.1.1.11
	cvs-1-11:1.1.1.11
	OPENBSD_2_8:1.1.1.10.0.8
	OPENBSD_2_8_BASE:1.1.1.10
	OPENBSD_2_7:1.1.1.10.0.6
	OPENBSD_2_7_BASE:1.1.1.10
	OPENBSD_2_6:1.1.1.10.0.4
	OPENBSD_2_6_BASE:1.1.1.10
	cvs-1-10-7:1.1.1.10
	OPENBSD_2_5:1.1.1.10.0.2
	OPENBSD_2_5_BASE:1.1.1.10
	cvs-1-10-5:1.1.1.10
	OPENBSD_2_4:1.1.1.9.0.4
	OPENBSD_2_4_BASE:1.1.1.9
	cvs-1-10:1.1.1.9
	cvs-1-9-28:1.1.1.9
	OPENBSD_2_3:1.1.1.9.0.2
	OPENBSD_2_3_BASE:1.1.1.9
	cvs-1-9-26:1.1.1.9
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.1.1.8.0.2
	OPENBSD_2_2_BASE:1.1.1.8
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.1.1.7.0.2
	OPENBSD_2_1_BASE:1.1.1.7
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.6
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.23;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.11;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.35.49;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.02.21.06.37.47;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.03.18.01.56.21;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.04.21.04.27.42;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.28.54;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.21.29;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.02.28.21.33.26;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2001.02.10.18.57.46;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/*
 * Release: "cancel" a checkout in the history log.
 * 
 * - Enter a line in the history log indicating the "release". - If asked to,
 * delete the local working directory.
 */

#include "cvs.h"
#include "savecwd.h"
#include "getline.h"

static const char *const release_usage[] =
{
    "Usage: %s %s [-d] directories...\n",
    "\t-d\tDelete the given directory.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

#ifdef SERVER_SUPPORT
static int release_server PROTO ((int argc, char **argv));

/* This is the server side of cvs release.  */
static int
release_server (argc, argv)
    int argc;
    char **argv;
{
    int i;

    /* Note that we skip argv[0].  */
    for (i = 1; i < argc; ++i)
	history_write ('F', argv[i], "", argv[i], "");
    return 0;
}

#endif /* SERVER_SUPPORT */

/* There are various things to improve about this implementation:

   1.  Using run_popen to run "cvs update" could be replaced by a
   fairly simple start_recursion/classify_file loop--a win for
   portability, performance, and cleanliness.  In particular, there is
   no particularly good way to find the right "cvs".

   2.  The fact that "cvs update" contacts the server slows things down;
   it undermines the case for using "cvs release" rather than "rm -rf".
   However, for correctly printing "? foo" and correctly handling
   CVSROOTADM_IGNORE, we currently need to contact the server.  (One
   idea for how to fix this is to stash a copy of CVSROOTADM_IGNORE in
   the working directories; see comment at base_* in entries.c for a
   few thoughts on that).

   3.  Would be nice to take processing things on the client side one step
   further, and making it like edit/unedit in terms of working well if
   disconnected from the network, and then sending a delayed
   notification.

   4.  Having separate network turnarounds for the "Notify" request
   which we do as part of unedit, and for the "release" itself, is slow
   and unnecessary.  */

int
release (argc, argv)
    int argc;
    char **argv;
{
    FILE *fp;
    int i, c;
    char *repository;
    char *line = NULL;
    size_t line_allocated = 0;
    char *update_cmd;
    char *thisarg;
    int arg_start_idx;
    int err = 0;
    short delete_flag = 0;
    struct saved_cwd cwd;

#ifdef SERVER_SUPPORT
    if (server_active)
	return release_server (argc, argv);
#endif

    /* Everything from here on is client or local.  */
    if (argc == -1)
	usage (release_usage);
    optind = 0;
    while ((c = getopt (argc, argv, "+Qdq")) != -1)
    {
	switch (c)
	{
	    case 'Q':
	    case 'q':
		error (1, 0,
		       "-q or -Q must be specified before \"%s\"",
		       command_name);
		break;
	    case 'd':
		delete_flag++;
		break;
	    case '?':
	    default:
		usage (release_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    /* We're going to run "cvs -n -q update" and check its output; if
     * the output is sufficiently unalarming, then we release with no
     * questions asked.  Else we prompt, then maybe release.
     * (Well, actually we ask no matter what.  Our notion of "sufficiently
     * unalarming" doesn't take into account "? foo.c" files, so it is
     * up to the user to take note of them, at least currently
     * (ignore-193 in testsuite)).
     */
    /* Construct the update command. */
    update_cmd = xmalloc (strlen (program_path)
			  + strlen (current_parsed_root->original)
			  + 20);
    sprintf (update_cmd, "%s -n -q -d %s update",
             program_path, current_parsed_root->original);

#ifdef CLIENT_SUPPORT
    /* Start the server; we'll close it after looping. */
    if (current_parsed_root->isremote)
    {
	start_server ();
	ign_setup ();
    }
#endif /* CLIENT_SUPPORT */

    /* Remember the directory where "cvs release" was invoked because
       all args are relative to this directory and we chdir around.
       */
    if (save_cwd (&cwd))
        error_exit ();

    arg_start_idx = 0;

    for (i = arg_start_idx; i < argc; i++)
    {
	thisarg = argv[i];

        if (isdir (thisarg))
        {
	    if (CVS_CHDIR (thisarg) < 0)
	    {
		if (!really_quiet)
		    error (0, errno, "can't chdir to: %s", thisarg);
		continue;
	    }
	    if (!isdir (CVSADM))
	    {
		if (!really_quiet)
		    error (0, 0, "no repository directory: %s", thisarg);
		if (restore_cwd (&cwd, NULL))
		    error_exit ();
		continue;
	    }
	}
	else
        {
	    if (!really_quiet)
		error (0, 0, "no such directory: %s", thisarg);
	    continue;
	}

	repository = Name_Repository ((char *) NULL, (char *) NULL);

	if (!really_quiet)
	{
	    int line_length;

	    /* The "release" command piggybacks on "update", which
	       does the real work of finding out if anything is not
	       up-to-date with the repository.  Then "release" prompts
	       the user, telling her how many files have been
	       modified, and asking if she still wants to do the
	       release.  */
	    fp = run_popen (update_cmd, "r");
	    if (fp == NULL)
		error (1, 0, "cannot run command %s", update_cmd);

	    c = 0;

	    while ((line_length = get_line (&line, &line_allocated, fp)) >= 0)
	    {
		if (strchr ("MARCZ", *line))
		    c++;
		(void) fputs (line, stdout);
	    }
	    if (line_length < 0 && !feof (fp))
		error (0, errno, "cannot read from subprocess");

	    /* If the update exited with an error, then we just want to
	       complain and go on to the next arg.  Especially, we do
	       not want to delete the local copy, since it's obviously
	       not what the user thinks it is.  */
	    if ((pclose (fp)) != 0)
	    {
		error (0, 0, "unable to release `%s'", thisarg);
		free (repository);
		if (restore_cwd (&cwd, NULL))
		    error_exit ();
		continue;
	    }

	    printf ("You have [%d] altered files in this repository.\n",
		    c);
	    printf ("Are you sure you want to release %sdirectory `%s': ",
		    delete_flag ? "(and delete) " : "", thisarg);
	    c = !yesno ();
	    if (c)			/* "No" */
	    {
		(void) fprintf (stderr, "** `%s' aborted by user choice.\n",
				command_name);
		free (repository);
		if (restore_cwd (&cwd, NULL))
		    error_exit ();
		continue;
	    }
	}

	if (1
#ifdef CLIENT_SUPPORT
	    && !(current_parsed_root->isremote
		 && (!supported_request ("noop")
		     || !supported_request ("Notify")))
#endif
	    )
	{
	    /* We are chdir'ed into the directory in question.  
	       So don't pass args to unedit.  */
	    int argc = 1;
	    char *argv[3];
	    argv[0] = "dummy";
	    argv[1] = NULL;
	    err += unedit (argc, argv);
	}

#ifdef CLIENT_SUPPORT
        if (current_parsed_root->isremote)
        {
	    send_to_server ("Argument ", 0);
	    send_to_server (thisarg, 0);
	    send_to_server ("\012", 1);
	    send_to_server ("release\012", 0);
	}
        else
#endif /* CLIENT_SUPPORT */
        {
	    history_write ('F', thisarg, "", thisarg, ""); /* F == Free */
        }

        free (repository);

	if (restore_cwd (&cwd, NULL))
	    error_exit ();

	if (delete_flag)
	{
	    /* FIXME?  Shouldn't this just delete the CVS-controlled
	       files and, perhaps, the files that would normally be
	       ignored and leave everything else?  */

	    if (unlink_file_dir (thisarg) < 0)
		error (0, errno, "deletion of directory %s failed", thisarg);
	}

#ifdef CLIENT_SUPPORT
        if (current_parsed_root->isremote)
	    err += get_server_responses ();
#endif /* CLIENT_SUPPORT */
    }

    if (restore_cwd (&cwd, NULL))
	error_exit ();
    free_cwd (&cwd);

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
    {
	/* Unfortunately, client.c doesn't offer a way to close
	   the connection without waiting for responses.  The extra
	   network turnaround here is quite unnecessary other than
	   that....  */
	send_to_server ("noop\012", 0);
	err += get_responses_and_close ();
    }
#endif /* CLIENT_SUPPORT */

    free (update_cmd);
    if (line != NULL)
	free (line);
    return err;
}
@


1.1
log
@Initial revision
@
text
@a3 4
 * - Don't allow release if anything is active - Don't allow release if not
 * above or inside repository. - Don't allow release if ./CVS/Repository is
 * not the same as the directory specified in the module database.
 * 
d9 2
a10 7

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)release.c 1.23 94/09/21 $";
USE(rcsid);
#endif

static void release_delete PROTO((char *dir));
d14 1
a14 1
    "Usage: %s %s [-d] modules...\n",
d16 1
d20 42
a61 1
static short delete;
d69 5
a73 3
    register int i, c;
    char *repository, *srepos;
    char line[PATH_MAX], update_cmd[PATH_MAX];
d76 3
d81 2
a82 16
    if (!server_active)
      {
#endif /* SERVER_SUPPORT */
        if (argc == -1)
          usage (release_usage);
        optind = 1;
        while ((c = getopt (argc, argv, "Qdq")) != -1)
          {
            switch (c)
              {
              case 'Q':
              case 'q':
#ifdef SERVER_SUPPORT
		/* The CVS 1.5 client sends these options (in addition to
		   Global_option requests), so we must ignore them.  */
		if (!server_active)
d84 14
a97 3
                  error (1, 0,
                         "-q or -Q must be specified before \"%s\"",
                         command_name);
d99 2
a100 2
              case 'd':
		delete++;
d102 2
a103 2
              case '?':
              default:
d106 4
a109 7
              }
          }
        argc -= optind;
        argv += optind;
#ifdef SERVER_SUPPORT
      }
#endif /* SERVER_SUPPORT */
d114 4
d120 3
d124 1
a124 1
             program_name, CVSroot);
d128 2
a129 2
    if (client_active)
      {
d132 1
a132 1
      }
d135 7
a141 9
    /* If !server_active, we already skipped over argv[0] in the "argc
       -= optind;" statement above.  But if server_active, we need to
       skip it now.  */
#ifdef SERVER_SUPPORT
    if (server_active)
      arg_start_idx = 1;
    else
      arg_start_idx = 0;
#endif /* SERVER_SUPPORT */
d145 2
a146 19
      thisarg = argv[i];
        
#ifdef SERVER_SUPPORT
      if (server_active)
      {
        /* Just log the release -- all the interesting stuff happened
         * on the client.
         */
        history_write ('F', thisarg, "", thisarg, "");	/* F == Free */
      }
      else
      {
#endif /* SERVER_SUPPORT */
        
        /*
         * If we are in a repository, do it.  Else if we are in the parent of
         * a directory with the same name as the module, "cd" into it and
         * look for a repository there.
         */
d149 14
a162 12
          if (chdir (thisarg) < 0)
          {
            if (!really_quiet)
              error (0, 0, "can't chdir to: %s", thisarg);
            continue;
          }
          if (!isdir (CVSADM))
          {
            if (!really_quiet)
              error (0, 0, "no repository module: %s", thisarg);
            continue;
          }
d166 3
a168 3
          if (!really_quiet)
            error (0, 0, "no such directory: %s", thisarg);
          continue;
d172 1
a172 2
	srepos = Short_Repository (repository);
        
d175 67
a241 43
          /* The "release" command piggybacks on "update", which
           * does the real work of finding out if anything is not
           * up-to-date with the repository.  Then "release" prompts
           * the user, telling her how many files have been
           * modified, and asking if she still wants to do the
           * release.
           *
           * This is "popen()" instead of "Popen()" since we
           * wouldn't want the `noexec' flag to stop it.
           */
          fp = popen (update_cmd, "r");
          c = 0;

          while (fgets (line, sizeof (line), fp))
          {
            if (strchr ("MARCZ", *line))
              c++;
            (void) printf (line);
          }

          /* If the update exited with an error, then we just want to
           * complain and go on to the next arg.  Especially, we do
           * not want to delete the local copy, since it's obviously
           * not what the user thinks it is.
           */
          if ((pclose (fp)) != 0)
          {
            error (0, 0, "unable to release `%s'", thisarg);
            continue;
          }

          (void) printf ("You have [%d] altered files in this repository.\n",
                         c);
          (void) printf ("Are you sure you want to release %smodule `%s': ",
                         delete ? "(and delete) " : "", thisarg);
          c = !yesno ();
          if (c)			/* "No" */
          {
            (void) fprintf (stderr, "** `%s' aborted by user choice.\n",
                            command_name);
            free (repository);
            continue;
          }
d245 1
a245 1
        if (client_active)
d247 5
a251 5
          if (fprintf (to_server, "Argument %s\n", thisarg) < 0)
	    error (1, errno, "writing to server");
          if (fprintf (to_server, "release\n") < 0)
	    error (1, errno, "writing to server");
        }
d253 1
d255 3
a257 6
#endif /* CLIENT_SUPPORT */
          history_write ('F', thisarg, "", thisarg, ""); /* F == Free */
#ifdef CLIENT_SUPPORT
        } /* else client not active */
#endif /* CLIENT_SUPPORT */
        
d259 14
a272 2
        if (delete) release_delete (thisarg);
        
d274 2
a275 3
        if (client_active)
          return get_responses_and_close ();
        else
d277 1
a277 7
          return (0);
        
#ifdef SERVER_SUPPORT
      } /* else server not active */
#endif  /* SERVER_SUPPORT */
    }   /* `for' loop */
}
d279 3
d283 2
a284 15
/* We want to "rm -r" the working directory, but let us be a little
   paranoid.  */
static void
release_delete (dir)
    char *dir;
{
    struct stat st;
    ino_t ino;
    int retcode = 0;

    (void) stat (".", &st);
    ino = st.st_ino;
    (void) chdir ("..");
    (void) stat (dir, &st);
    if (ino != st.st_ino)
d286 6
a291 3
	error (0, 0,
	       "Parent dir on a different disk, delete of %s aborted", dir);
	return;
d293 6
a298 9
    /*
     * XXX - shouldn't this just delete the CVS-controlled files and, perhaps,
     * the files that would normally be ignored and leave everything else?
     */
    run_setup ("%s -fr", RM);
    run_arg (dir);
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)
	error (0, retcode == -1 ? errno : 0, 
	       "deletion of module %s failed.", dir);
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a29 15
/* FIXME: This implementation is cheezy in quite a few ways:

   1.  The whole "cvs update" junk could be checked locally with a
   fairly simple start_recursion/classify_file loop--a win for
   portability, performance, and cleanliness.

   2.  Should be like edit/unedit in terms of working well if disconnected
   from the network, and then sending a delayed notification.

   3.  Way too many network turnarounds.  More than one for each argument.
   Puh-leeze.

   4.  Oh, and as a purely stylistic nit, break this out into separate
   functions for client/local and for server.  Those #ifdefs are a mess.  */

a40 1
    int err = 0;
d85 1
a85 1
             program_path, CVSroot);
d103 1
a104 1
      arg_start_idx = 0;
d160 3
d164 1
a164 1
          fp = Popen (update_cmd, "r");
a198 20
	if (1
#ifdef SERVER_SUPPORT
	    && !server_active
#endif
#ifdef CLIENT_SUPPORT
	    && !(client_active
		 && (!supported_request ("noop")
		     || !supported_request ("Notify")))
#endif
	    )
	{
	  /* We are chdir'ed into the directory in question.  
	     So don't pass args to unedit.  */
	  int argc = 1;
	  char *argv[3];
	  argv[0] = "dummy";
	  argv[1] = NULL;
	  err += unedit (argc, argv);
	}

d202 4
a205 4
          send_to_server ("Argument ", 0);
          send_to_server (thisarg, 0);
          send_to_server ("\012", 1);
          send_to_server ("release\012", 0);
a228 1
    return err;
d240 1
d256 5
a260 2
    if (unlink_file_dir (dir) < 0)
	error (0, errno, "deletion of directory %s failed", dir);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d14 5
d28 1
a28 1
static short delete_flag;
d81 1
a81 1
		delete_flag++;
d177 1
a177 1
          fp = run_popen (update_cmd, "r");
d201 1
a201 1
                         delete_flag ? "(and delete) " : "", thisarg);
d249 1
a249 1
        if (delete_flag) release_delete (thisarg);
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d96 1
a96 1
             program_path, CVSroot_original);
d140 1
a140 1
          if ( CVS_CHDIR (thisarg) < 0)
d270 1
a270 1
    (void) CVS_STAT (".", &st);
d272 2
a273 2
    (void) CVS_CHDIR ("..");
    (void) CVS_STAT (dir, &st);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d4 4
d18 1
a18 1
    "Usage: %s %s [-d] directories...\n",
d23 1
a23 2
#ifdef SERVER_SUPPORT
static int release_server PROTO ((int argc, char **argv));
d25 1
a25 7
/* This is the server side of cvs release.  */
static int
release_server (argc, argv)
    int argc;
    char **argv;
{
    int i;
d27 3
a29 5
    /* Note that we skip argv[0].  */
    for (i = 1; i < argc; ++i)
	history_write ('F', argv[i], "", argv[i], "");
    return 0;
}
d31 2
a32 1
#endif /* SERVER_SUPPORT */
d34 2
a35 1
/* There are various things to improve about this implementation:
d37 2
a38 18
   1.  Using run_popen to run "cvs update" could be replaced by a
   fairly simple start_recursion/classify_file loop--a win for
   portability, performance, and cleanliness.  In particular, there is
   no particularly good way to find the right "cvs".

   2.  The fact that "cvs update" contacts the server slows things down;
   it undermines the case for using "cvs release" rather than "rm -rf".
   However, for correctly printing "? foo" and correctly handling
   CVSROOTADM_IGNORE, we currently need to contact the server.

   3.  Would be nice to take processing things on the client side one step
   further, and making it like edit/unedit in terms of working well if
   disconnected from the network, and then sending a delayed
   notification.

   4.  Having separate network turnarounds for the "Notify" request
   which we do as part of unedit, and for the "release" itself, is slow
   and unnecessary.  */
d46 2
a47 2
    int i, c;
    char *repository;
a51 1
    short delete_flag = 0;
d54 16
a69 2
    if (server_active)
	return release_server (argc, argv);
d71 3
a73 14

    /* Everything from here on is client or local.  */
    if (argc == -1)
	usage (release_usage);
    optind = 1;
    while ((c = getopt (argc, argv, "Qdq")) != -1)
    {
	switch (c)
	{
	    case 'Q':
	    case 'q':
		error (1, 0,
		       "-q or -Q must be specified before \"%s\"",
		       command_name);
d75 1
a75 1
	    case 'd':
d78 2
a79 2
	    case '?':
	    default:
d82 7
a88 4
	}
    }
    argc -= optind;
    argv += optind;
d101 1
a101 1
    {
d104 1
a104 1
    }
d107 9
a115 1
    arg_start_idx = 0;
d119 19
a137 2
	thisarg = argv[i];

d140 12
a151 12
	    if (CVS_CHDIR (thisarg) < 0)
	    {
		if (!really_quiet)
		    error (0, errno, "can't chdir to: %s", thisarg);
		continue;
	    }
	    if (!isdir (CVSADM))
	    {
		if (!really_quiet)
		    error (0, 0, "no repository directory: %s", thisarg);
		continue;
	    }
d155 3
a157 3
	    if (!really_quiet)
		error (0, 0, "no such directory: %s", thisarg);
	    continue;
d161 2
a162 1

d165 40
a204 38
	    /* The "release" command piggybacks on "update", which
	       does the real work of finding out if anything is not
	       up-to-date with the repository.  Then "release" prompts
	       the user, telling her how many files have been
	       modified, and asking if she still wants to do the
	       release.  */
	    fp = run_popen (update_cmd, "r");
	    c = 0;

	    while (fgets (line, sizeof (line), fp))
	    {
		if (strchr ("MARCZ", *line))
		    c++;
		(void) printf (line);
	    }

	    /* If the update exited with an error, then we just want to
	       complain and go on to the next arg.  Especially, we do
	       not want to delete the local copy, since it's obviously
	       not what the user thinks it is.  */
	    if ((pclose (fp)) != 0)
	    {
		error (0, 0, "unable to release `%s'", thisarg);
		continue;
	    }

	    printf ("You have [%d] altered files in this repository.\n",
		    c);
	    printf ("Are you sure you want to release %sdirectory `%s': ",
		    delete_flag ? "(and delete) " : "", thisarg);
	    c = !yesno ();
	    if (c)			/* "No" */
	    {
		(void) fprintf (stderr, "** `%s' aborted by user choice.\n",
				command_name);
		free (repository);
		continue;
	    }
d208 3
d218 7
a224 7
	    /* We are chdir'ed into the directory in question.  
	       So don't pass args to unedit.  */
	    int argc = 1;
	    char *argv[3];
	    argv[0] = "dummy";
	    argv[1] = NULL;
	    err += unedit (argc, argv);
d230 5
a234 5
	    send_to_server ("Argument ", 0);
	    send_to_server (thisarg, 0);
	    send_to_server ("\012", 1);
	    send_to_server ("release\012", 0);
	}
d236 1
d238 5
a242 4
        {
	    history_write ('F', thisarg, "", thisarg, ""); /* F == Free */
        }

d245 1
a245 1

d248 2
a249 1
	    err += get_server_responses ();
d251 6
a256 14
    }

#ifdef CLIENT_SUPPORT
    if (client_active)
    {
	/* Unfortunately, client.c doesn't offer a way to close
	   the connection without waiting for responses.  The extra
	   network turnaround here is quite unnecessary other than
	   that....  */
	send_to_server ("noop\012", 0);
	err += get_responses_and_close ();
    }
#endif /* CLIENT_SUPPORT */

@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a8 1
#include "getline.h"
d67 1
a67 3
    char *line = NULL;
    size_t line_allocated = 0;
    char *update_cmd;
a108 3
    update_cmd = xmalloc (strlen (program_path)
			  + strlen (CVSroot_original)
			  + 20);
d162 1
a162 1
	    while (getline (&line, &line_allocated, fp) >= 0)
a244 3
    free (update_cmd);
    if (line != NULL)
	free (line);
@


1.1.1.7
log
@Latest release from Cyclic Software
@
text
@d85 1
a85 1
    while ((c = getopt (argc, argv, "+Qdq")) != -1)
@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@d84 1
a84 1
    optind = 0;
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@a16 1
    "(Specify the --help global option for a list of other help options)\n",
d49 1
a49 4
   CVSROOTADM_IGNORE, we currently need to contact the server.  (One
   idea for how to fix this is to stash a copy of CVSROOTADM_IGNORE in
   the working directories; see comment at base_* in entries.c for a
   few thoughts on that).
a158 2
	    int line_length;

a165 3
	    if (fp == NULL)
		error (1, 0, "cannot run command %s", update_cmd);

d168 1
a168 1
	    while ((line_length = getline (&line, &line_allocated, fp)) >= 0)
a173 2
	    if (line_length < 0 && !feof (fp))
		error (0, errno, "cannot read from subprocess");
a272 5
	/* This test does not work on cygwin32, because under cygwin32
	   the st_ino field is not the same when you refer to a file
	   by a different name.  This is a cygwin32 bug, but then I
	   don't see what the point of this test is anyhow.  */
#ifndef __CYGWIN32__
a275 1
#endif
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@a8 1
#include "savecwd.h"
d11 2
a78 1
    struct saved_cwd cwd;
a113 4
     * (Well, actually we ask no matter what.  Our notion of "sufficiently
     * unalarming" doesn't take into account "? foo.c" files, so it is
     * up to the user to take note of them, at least currently
     * (ignore-193 in testsuite)).
a130 6
    /* Remember the directory where "cvs release" was invoked because
       all args are relative to this directory and we chdir around.
       */
    if (save_cwd (&cwd))
        error_exit ();

a148 2
		if (restore_cwd (&cwd, NULL))
		    error_exit ();
a192 3
		free (repository);
		if (restore_cwd (&cwd, NULL))
		    error_exit ();
a205 2
		if (restore_cwd (&cwd, NULL))
		    error_exit ();
d242 1
a242 13

	if (restore_cwd (&cwd, NULL))
	    error_exit ();

	if (delete_flag)
	{
	    /* FIXME?  Shouldn't this just delete the CVS-controlled
	       files and, perhaps, the files that would normally be
	       ignored and leave everything else?  */

	    if (unlink_file_dir (thisarg) < 0)
		error (0, errno, "deletion of directory %s failed", thisarg);
	}
a249 4
    if (restore_cwd (&cwd, NULL))
	error_exit ();
    free_cwd (&cwd);

d266 34
@


1.1.1.11
log
@Latest from Cyclic Software
@
text
@d193 1
a193 1
		(void) fputs (line, stdout);
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d121 1
a121 1
			  + strlen (current_parsed_root->original)
d124 1
a124 1
             program_path, current_parsed_root->original);
d128 1
a128 1
    if (current_parsed_root->isremote)
d229 1
a229 1
	    && !(current_parsed_root->isremote
d245 1
a245 1
        if (current_parsed_root->isremote)
d274 1
a274 1
        if (current_parsed_root->isremote)
d284 1
a284 1
    if (current_parsed_root->isremote)
@


