head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.12
	OPENBSD_6_0:1.1.1.12.0.62
	OPENBSD_6_0_BASE:1.1.1.12
	OPENBSD_5_9:1.1.1.12.0.58
	OPENBSD_5_9_BASE:1.1.1.12
	OPENBSD_5_8:1.1.1.12.0.60
	OPENBSD_5_8_BASE:1.1.1.12
	OPENBSD_5_7:1.1.1.12.0.52
	OPENBSD_5_7_BASE:1.1.1.12
	OPENBSD_5_6:1.1.1.12.0.56
	OPENBSD_5_6_BASE:1.1.1.12
	OPENBSD_5_5:1.1.1.12.0.54
	OPENBSD_5_5_BASE:1.1.1.12
	OPENBSD_5_4:1.1.1.12.0.50
	OPENBSD_5_4_BASE:1.1.1.12
	OPENBSD_5_3:1.1.1.12.0.48
	OPENBSD_5_3_BASE:1.1.1.12
	OPENBSD_5_2:1.1.1.12.0.46
	OPENBSD_5_2_BASE:1.1.1.12
	OPENBSD_5_1_BASE:1.1.1.12
	OPENBSD_5_1:1.1.1.12.0.44
	OPENBSD_5_0:1.1.1.12.0.42
	OPENBSD_5_0_BASE:1.1.1.12
	OPENBSD_4_9:1.1.1.12.0.40
	OPENBSD_4_9_BASE:1.1.1.12
	OPENBSD_4_8:1.1.1.12.0.38
	OPENBSD_4_8_BASE:1.1.1.12
	OPENBSD_4_7:1.1.1.12.0.34
	OPENBSD_4_7_BASE:1.1.1.12
	OPENBSD_4_6:1.1.1.12.0.36
	OPENBSD_4_6_BASE:1.1.1.12
	OPENBSD_4_5:1.1.1.12.0.32
	OPENBSD_4_5_BASE:1.1.1.12
	OPENBSD_4_4:1.1.1.12.0.30
	OPENBSD_4_4_BASE:1.1.1.12
	OPENBSD_4_3:1.1.1.12.0.28
	OPENBSD_4_3_BASE:1.1.1.12
	OPENBSD_4_2:1.1.1.12.0.26
	OPENBSD_4_2_BASE:1.1.1.12
	OPENBSD_4_1:1.1.1.12.0.24
	OPENBSD_4_1_BASE:1.1.1.12
	OPENBSD_4_0:1.1.1.12.0.22
	OPENBSD_4_0_BASE:1.1.1.12
	OPENBSD_3_9:1.1.1.12.0.20
	OPENBSD_3_9_BASE:1.1.1.12
	OPENBSD_3_8:1.1.1.12.0.18
	OPENBSD_3_8_BASE:1.1.1.12
	OPENBSD_3_7:1.1.1.12.0.16
	OPENBSD_3_7_BASE:1.1.1.12
	OPENBSD_3_6:1.1.1.12.0.14
	OPENBSD_3_6_BASE:1.1.1.12
	OPENBSD_3_5:1.1.1.12.0.12
	OPENBSD_3_5_BASE:1.1.1.12
	OPENBSD_3_4:1.1.1.12.0.10
	OPENBSD_3_4_BASE:1.1.1.12
	OPENBSD_3_3:1.1.1.12.0.8
	OPENBSD_3_3_BASE:1.1.1.12
	OPENBSD_3_2:1.1.1.12.0.6
	OPENBSD_3_2_BASE:1.1.1.12
	OPENBSD_3_1:1.1.1.12.0.4
	OPENBSD_3_1_BASE:1.1.1.12
	OPENBSD_3_0:1.1.1.12.0.2
	OPENBSD_3_0_BASE:1.1.1.12
	cvs-1-11-1p1:1.1.1.12
	OPENBSD_2_9:1.1.1.11.0.2
	OPENBSD_2_9_BASE:1.1.1.11
	cvs-1-11:1.1.1.11
	OPENBSD_2_8:1.1.1.10.0.6
	OPENBSD_2_8_BASE:1.1.1.10
	OPENBSD_2_7:1.1.1.10.0.4
	OPENBSD_2_7_BASE:1.1.1.10
	OPENBSD_2_6:1.1.1.10.0.2
	OPENBSD_2_6_BASE:1.1.1.10
	cvs-1-10-7:1.1.1.10
	OPENBSD_2_5:1.1.1.9.0.2
	OPENBSD_2_5_BASE:1.1.1.9
	cvs-1-10-5:1.1.1.9
	OPENBSD_2_4:1.1.1.8.0.4
	OPENBSD_2_4_BASE:1.1.1.8
	cvs-1-10:1.1.1.8
	cvs-1-9-28:1.1.1.8
	OPENBSD_2_3:1.1.1.8.0.2
	OPENBSD_2_3_BASE:1.1.1.8
	cvs-1-9-26:1.1.1.8
	cvs-1-9-24:1.1.1.8
	OPENBSD_2_2:1.1.1.7.0.2
	OPENBSD_2_2_BASE:1.1.1.7
	cvs-1-9-10:1.1.1.7
	OPENBSD_2_1:1.1.1.6.0.2
	OPENBSD_2_1_BASE:1.1.1.6
	cvs-1-9-8:1.1.1.6
	cvs-1-9-6:1.1.1.6
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.32;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.21;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.20.07;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.02.21.06.37.55;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.03.18.01.56.30;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.06.28.03.29.02;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	98.02.22.08.21.39;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.02.28.21.33.39;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.09.10.05.06.28;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2001.02.10.18.57.48;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* run.c --- routines for executing subprocesses.
   
   This file is part of GNU CVS.

   GNU CVS is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "cvs.h"

#ifdef _MINIX
#undef	POSIX		/* Minix 1.6 doesn't support POSIX.1 sigaction yet */
#endif

#ifdef HAVE_VPRINTF
#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
#include <stdarg.h>
#define VA_START(args, lastarg) va_start(args, lastarg)
#else
#include <varargs.h>
#define VA_START(args, lastarg) va_start(args)
#endif
#else
#define va_alist a1, a2, a3, a4, a5, a6, a7, a8
#define va_dcl char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;
#endif

static void run_add_arg PROTO((const char *s));
static void run_init_prog PROTO((void));

extern char *strtok ();

/*
 * To exec a program under CVS, first call run_setup() to setup any initial
 * arguments.  The options to run_setup are essentially like printf(). The
 * arguments will be parsed into whitespace separated words and added to the
 * global run_argv list.
 * 
 * Then, optionally call run_arg() for each additional argument that you'd like
 * to pass to the executed program.
 * 
 * Finally, call run_exec() to execute the program with the specified arguments.
 * The execvp() syscall will be used, so that the PATH is searched correctly.
 * File redirections can be performed in the call to run_exec().
 */
static char *run_prog;
static char **run_argv;
static int run_argc;
static int run_argc_allocated;

/* VARARGS */
#if defined (HAVE_VPRINTF) && (defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__))
void 
run_setup (const char *fmt,...)
#else
void 
run_setup (fmt, va_alist)
    char *fmt;
    va_dcl
#endif
{
#ifdef HAVE_VPRINTF
    va_list args;
#endif
    char *cp;
    int i;

    run_init_prog ();

    /* clean out any malloc'ed values from run_argv */
    for (i = 0; i < run_argc; i++)
    {
	if (run_argv[i])
	{
	    free (run_argv[i]);
	    run_argv[i] = (char *) 0;
	}
    }
    run_argc = 0;

    /* process the varargs into run_prog */
#ifdef HAVE_VPRINTF
    VA_START (args, fmt);
    (void) vsprintf (run_prog, fmt, args);
    va_end (args);
#else
    (void) sprintf (run_prog, fmt, a1, a2, a3, a4, a5, a6, a7, a8);
#endif

    /* put each word into run_argv, allocating it as we go */
    for (cp = strtok (run_prog, " \t"); cp; cp = strtok ((char *) NULL, " \t"))
	run_add_arg (cp);
}

void
run_arg (s)
    const char *s;
{
    run_add_arg (s);
}

/* VARARGS */
#if defined (HAVE_VPRINTF) && (defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__))
void 
run_args (const char *fmt,...)
#else
void 
run_args (fmt, va_alist)
    char *fmt;
    va_dcl
#endif
{
#ifdef HAVE_VPRINTF
    va_list args;
#endif

    run_init_prog ();

    /* process the varargs into run_prog */
#ifdef HAVE_VPRINTF
    VA_START (args, fmt);
    (void) vsprintf (run_prog, fmt, args);
    va_end (args);
#else
    (void) sprintf (run_prog, fmt, a1, a2, a3, a4, a5, a6, a7, a8);
#endif

    /* and add the (single) argument to the run_argv list */
    run_add_arg (run_prog);
}

static void
run_add_arg (s)
    const char *s;
{
    /* allocate more argv entries if we've run out */
    if (run_argc >= run_argc_allocated)
    {
	run_argc_allocated += 50;
	run_argv = (char **) xrealloc ((char *) run_argv,
				     run_argc_allocated * sizeof (char **));
    }

    if (s)
	run_argv[run_argc++] = xstrdup (s);
    else
	run_argv[run_argc] = (char *) 0;	/* not post-incremented on purpose! */
}

static void
run_init_prog ()
{
    /* make sure that run_prog is allocated once */
    if (run_prog == (char *) 0)
	run_prog = xmalloc (10 * 1024);	/* 10K of args for _setup and _arg */
}

int
run_exec (stin, stout, sterr, flags)
    char *stin;
    char *stout;
    char *sterr;
    int flags;
{
    int shin, shout, sherr;
    int mode_out, mode_err;
    int status;
    int rc = -1;
    int rerrno = 0;
    int pid, w;

#ifdef POSIX
    sigset_t sigset_mask, sigset_omask;
    struct sigaction act, iact, qact;

#else
#ifdef BSD_SIGNALS
    int mask;
    struct sigvec vec, ivec, qvec;

#else
    RETSIGTYPE (*istat) (), (*qstat) ();
#endif
#endif

    if (trace)
    {
#ifdef SERVER_SUPPORT
	(void) fprintf (stderr, "%c-> system(", (server_active) ? 'S' : ' ');
#else
	(void) fprintf (stderr, "-> system(");
#endif
	run_print (stderr);
	(void) fprintf (stderr, ")\n");
    }
    if (noexec && (flags & RUN_REALLY) == 0)
	return (0);

    /* make sure that we are null terminated, since we didn't calloc */
    run_add_arg ((char *) 0);

    /* setup default file descriptor numbers */
    shin = 0;
    shout = 1;
    sherr = 2;

    /* set the file modes for stdout and stderr */
    mode_out = mode_err = O_WRONLY | O_CREAT;
    mode_out |= ((flags & RUN_STDOUT_APPEND) ? O_APPEND : O_TRUNC);
    mode_err |= ((flags & RUN_STDERR_APPEND) ? O_APPEND : O_TRUNC);

    if (stin && (shin = open (stin, O_RDONLY)) == -1)
    {
	rerrno = errno;
	error (0, errno, "cannot open %s for reading (prog %s)",
	       stin, run_argv[0]);
	goto out0;
    }
    if (stout && (shout = open (stout, mode_out, 0666)) == -1)
    {
	rerrno = errno;
	error (0, errno, "cannot open %s for writing (prog %s)",
	       stout, run_argv[0]);
	goto out1;
    }
    if (sterr && (flags & RUN_COMBINED) == 0)
    {
	if ((sherr = open (sterr, mode_err, 0666)) == -1)
	{
	    rerrno = errno;
	    error (0, errno, "cannot open %s for writing (prog %s)",
		   sterr, run_argv[0]);
	    goto out2;
	}
    }

    /* Make sure we don't flush this twice, once in the subprocess.  */
    fflush (stdout);
    fflush (stderr);

    /* The output files, if any, are now created.  Do the fork and dups */
#ifdef HAVE_VFORK
    pid = vfork ();
#else
    pid = fork ();
#endif
    if (pid == 0)
    {
	if (shin != 0)
	{
	    (void) dup2 (shin, 0);
	    (void) close (shin);
	}
	if (shout != 1)
	{
	    (void) dup2 (shout, 1);
	    (void) close (shout);
	}
	if (flags & RUN_COMBINED)
	    (void) dup2 (1, 2);
	else if (sherr != 2)
	{
	    (void) dup2 (sherr, 2);
	    (void) close (sherr);
	}

	/* dup'ing is done.  try to run it now */
	(void) execvp (run_argv[0], run_argv);
	error (0, errno, "cannot exec %s", run_argv[0]);
	_exit (127);
    }
    else if (pid == -1)
    {
	rerrno = errno;
	goto out;
    }

    /* the parent.  Ignore some signals for now */
#ifdef POSIX
    if (flags & RUN_SIGIGNORE)
    {
	act.sa_handler = SIG_IGN;
	(void) sigemptyset (&act.sa_mask);
	act.sa_flags = 0;
	(void) sigaction (SIGINT, &act, &iact);
	(void) sigaction (SIGQUIT, &act, &qact);
    }
    else
    {
	(void) sigemptyset (&sigset_mask);
	(void) sigaddset (&sigset_mask, SIGINT);
	(void) sigaddset (&sigset_mask, SIGQUIT);
	(void) sigprocmask (SIG_SETMASK, &sigset_mask, &sigset_omask);
    }
#else
#ifdef BSD_SIGNALS
    if (flags & RUN_SIGIGNORE)
    {
	memset ((char *) &vec, 0, sizeof (vec));
	vec.sv_handler = SIG_IGN;
	(void) sigvec (SIGINT, &vec, &ivec);
	(void) sigvec (SIGQUIT, &vec, &qvec);
    }
    else
	mask = sigblock (sigmask (SIGINT) | sigmask (SIGQUIT));
#else
    istat = signal (SIGINT, SIG_IGN);
    qstat = signal (SIGQUIT, SIG_IGN);
#endif
#endif

    /* wait for our process to die and munge return status */
#ifdef POSIX
    while ((w = waitpid (pid, &status, 0)) == -1 && errno == EINTR)
	;
#else
    while ((w = wait (&status)) != pid)
    {
	if (w == -1 && errno != EINTR)
	    break;
    }
#endif
    if (w == -1)
    {
	rc = -1;
	rerrno = errno;
    }
    else if (WIFEXITED (status))
	rc = WEXITSTATUS (status);
    else if (WIFSIGNALED (status))
    {
	if (WTERMSIG (status) == SIGPIPE)
	    error (1, 0, "broken pipe");
	rc = 2;
    }
    else
	rc = 1;

    /* restore the signals */
#ifdef POSIX
    if (flags & RUN_SIGIGNORE)
    {
	(void) sigaction (SIGINT, &iact, (struct sigaction *) NULL);
	(void) sigaction (SIGQUIT, &qact, (struct sigaction *) NULL);
    }
    else
	(void) sigprocmask (SIG_SETMASK, &sigset_omask, (sigset_t *) NULL);
#else
#ifdef BSD_SIGNALS
    if (flags & RUN_SIGIGNORE)
    {
	(void) sigvec (SIGINT, &ivec, (struct sigvec *) NULL);
	(void) sigvec (SIGQUIT, &qvec, (struct sigvec *) NULL);
    }
    else
	(void) sigsetmask (mask);
#else
    (void) signal (SIGINT, istat);
    (void) signal (SIGQUIT, qstat);
#endif
#endif

    /* cleanup the open file descriptors */
  out:
    if (sterr)
	(void) close (sherr);
  out2:
    if (stout)
	(void) close (shout);
  out1:
    if (stin)
	(void) close (shin);

  out0:
    if (rerrno)
	errno = rerrno;
    return (rc);
}

void
run_print (fp)
    FILE *fp;
{
    int i;

    for (i = 0; i < run_argc; i++)
    {
	(void) fprintf (fp, "'%s'", run_argv[i]);
	if (i != run_argc - 1)
	    (void) fprintf (fp, " ");
    }
}

FILE *
Popen (cmd, mode)
    const char *cmd;
    const char *mode;
{
    if (trace)
#ifdef SERVER_SUPPORT
	(void) fprintf (stderr, "%c-> Popen(%s,%s)\n",
			(server_active) ? 'S' : ' ', cmd, mode);
#else
	(void) fprintf (stderr, "-> Popen(%s,%s)\n", cmd, mode);
#endif
    if (noexec)
	return (NULL);

    return (popen (cmd, mode));
}

extern int evecvp PROTO((char *file, char **argv));

int
piped_child (command, tofdp, fromfdp)
     char **command;
     int *tofdp;
     int *fromfdp;
{
    int pid;
    int to_child_pipe[2];
    int from_child_pipe[2];

    if (pipe (to_child_pipe) < 0)
	error (1, errno, "cannot create pipe");
    if (pipe (from_child_pipe) < 0)
	error (1, errno, "cannot create pipe");

    pid = fork ();
    if (pid < 0)
	error (1, errno, "cannot fork");
    if (pid == 0)
    {
	if (dup2 (to_child_pipe[0], STDIN_FILENO) < 0)
	    error (1, errno, "cannot dup2");
	if (close (to_child_pipe[1]) < 0)
	    error (1, errno, "cannot close");
	if (close (from_child_pipe[0]) < 0)
	    error (1, errno, "cannot close");
	if (dup2 (from_child_pipe[1], STDOUT_FILENO) < 0)
	    error (1, errno, "cannot dup2");

	execvp (command[0], command);
	error (1, errno, "cannot exec");
    }
    if (close (to_child_pipe[0]) < 0)
	error (1, errno, "cannot close");
    if (close (from_child_pipe[1]) < 0)
	error (1, errno, "cannot close");

    *tofdp = to_child_pipe[1];
    *fromfdp = from_child_pipe[0];
    return pid;
}


void
close_on_exec (fd)
     int fd;
{
#if defined (FD_CLOEXEC) && defined (F_SETFD)
  if (fcntl (fd, F_SETFD, 1))
    error (1, errno, "can't set close-on-exec flag on %d", fd);
#endif
}

/*
 * dir = 0 : main proc writes to new proc, which writes to oldfd
 * dir = 1 : main proc reads from new proc, which reads from oldfd
 */

int
filter_stream_through_program (oldfd, dir, prog, pidp)
     int oldfd, dir;
     char **prog;
     pid_t *pidp;
{
    int p[2], newfd;
    pid_t newpid;

    if (pipe (p))
	error (1, errno, "cannot create pipe");
    newpid = fork ();
    if (pidp)
	*pidp = newpid;
    switch (newpid)
    {
      case -1:
	error (1, errno, "cannot fork");
      case 0:
	/* child */
	if (dir)
	{
	    /* write to new pipe */
	    close (p[0]);
	    dup2 (oldfd, 0);
	    dup2 (p[1], 1);
	}
	else
	{
	    /* read from new pipe */
	    close (p[1]);
	    dup2 (p[0], 0);
	    dup2 (oldfd, 1);
	}
	/* Should I be blocking some signals here?  */
	execvp (prog[0], prog);
	error (1, errno, "couldn't exec %s", prog[0]);
      default:
	/* parent */
	close (oldfd);
	if (dir)
	{
	    /* read from new pipe */
	    close (p[1]);
	    newfd = p[0];
	}
	else
	{
	    /* write to new pipe */
	    close (p[0]);
	    newfd = p[1];
	}
	close_on_exec (newfd);
	return newfd;
    }
}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d21 4
d182 1
a182 1
#ifdef POSIX_SIGNALS
d289 1
a289 1
#ifdef POSIX_SIGNALS
d323 1
a323 1
#ifdef POSIX_SIGNALS
d350 1
a350 1
#ifdef POSIX_SIGNALS
a479 3
 *
 * Returns: a file descriptor.  On failure (i.e., the exec fails),
 * then filter_stream_through_program() complains and dies.
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d401 1
a401 1
run_popen (cmd, mode)
d407 1
a407 1
	(void) fprintf (stderr, "%c-> run_popen(%s,%s)\n",
d410 1
a410 1
	(void) fprintf (stderr, "-> run_popen(%s,%s)\n", cmd, mode);
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a328 1

a333 1
#ifndef VMS /* status is return status */
a343 3
#else /* VMS */
    rc = WEXITSTATUS (status);
#endif /* VMS */
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d13 5
a17 1
   GNU General Public License for more details.  */
d195 3
a197 1
	cvs_outerr (server_active ? "S" : " ", 1);
a198 1
	cvs_outerr ("-> system(", 0);
d200 1
a200 1
	cvs_outerr (")\n", 0);
d247 1
a247 8
    /* The output files, if any, are now created.  Do the fork and dups.

       We use vfork not so much for the sake of unices without
       copy-on-write (such systems are rare these days), but for the
       sake of systems without an MMU, which therefore can't do
       copy-on-write (e.g. Amiga).  The other solution is spawn (see
       windows-NT/run.c).  */

a395 8
    void (*outfn) PROTO ((const char *, size_t));

    if (fp == stderr)
	outfn = cvs_outerr;
    else if (fp == stdout)
	outfn = cvs_output;
    else
	error (1, 0, "internal error: bad argument to run_print");
d399 1
a399 3
	(*outfn) ("'", 1);
	(*outfn) (run_argv[i], 0);
	(*outfn) ("'", 1);
d401 1
a401 1
	    (*outfn) (" ", 1);
a439 3
#ifdef HAVE_VFORK
    pid = vfork ();
#else
a440 1
#endif
a496 3
#ifdef HAVE_VFORK
    newpid = vfork ();
#else
a497 1
#endif
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d31 1
a34 2
extern int vasprintf ();

d48 1
d69 2
a70 1
    char *run_prog;
d86 1
a86 1
    (void) vasprintf (&run_prog, fmt, args);
d89 1
a89 1
    you lose
a90 2
    if (run_prog == NULL)
	error (1, 0, "out of memory");
a94 1
    free (run_prog);
d118 2
a119 1
    char *run_prog;
d124 1
a124 1
    (void) vasprintf (&run_prog, fmt, args);
d127 1
a127 1
    you lose
a128 2
    if (run_prog == NULL)
	error (1, 0, "out of memory");
a131 1
    free (run_prog);
d150 8
@


1.1.1.7
log
@Latest version from Cyclic Software
@
text
@a447 7
#ifdef USE_SETMODE_BINARY
    setmode (to_child_pipe[0], O_BINARY);
    setmode (to_child_pipe[1], O_BINARY);
    setmode (from_child_pipe[0], O_BINARY);
    setmode (from_child_pipe[1], O_BINARY);
#endif

a508 5
#ifdef USE_SETMODE_BINARY
    setmode (p[0], O_BINARY);
    setmode (p[1], O_BINARY);
#endif

@


1.1.1.8
log
@Latest version from Cyclic
@
text
@d17 11
a27 2
#ifndef HAVE_UNISTD_H
extern int execvp PROTO((char *file, char **argv));
d34 2
d37 4
a40 3
 * To exec a program under CVS, first call run_setup() to setup initial
 * arguments.  The argument to run_setup will be parsed into whitespace 
 * separated words and added to the global run_argv list.
d54 1
d56 7
a62 2
run_setup (prog)
    const char *prog;
d64 3
d82 10
a91 1
    run_prog = xstrdup (prog);
d106 32
d158 3
a160 3
    const char *stin;
    const char *stout;
    const char *sterr;
a400 1
    {
a401 5
	/* Solely to placate gcc -Wall.
	   FIXME: it'd be better to use a function named `fatal' that
	   is known never to return.  Then kludges wouldn't be necessary.  */
	outfn = NULL;
    }
a412 5
/* Return value is NULL for error, or if noexec was set.  If there was an
   error, return NULL and I'm not sure whether errno was set (the Red Hat
   Linux 4.1 popen manpage was kind of vague but discouraging; and the noexec
   case complicates this even aside from popen behavior).  */

d430 2
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d178 4
a181 5
       We use vfork not so much for a performance boost (the
       performance boost, if any, is modest on most modern unices),
       but for the sake of systems without a memory management unit,
       which find it difficult or impossible to implement fork at all
       (e.g. Amiga).  The other solution is spawn (see
d368 6
a373 2
	(void) fprintf (stderr, "%s-> run_popen(%s,%s)\n",
			CLIENT_SERVER_STR, cmd, mode);
d442 74
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d409 1
a409 1
	    error (1, errno, "cannot dup2 pipe");
d411 1
a411 1
	    error (1, errno, "cannot close pipe");
d413 1
a413 1
	    error (1, errno, "cannot close pipe");
d415 1
a415 1
	    error (1, errno, "cannot dup2 pipe");
d418 1
a418 1
	error (1, errno, "cannot exec %s", command[0]);
d421 1
a421 1
	error (1, errno, "cannot close pipe");
d423 1
a423 1
	error (1, errno, "cannot close pipe");
d436 2
a437 2
    if (fcntl (fd, F_SETFD, 1))
	error (1, errno, "can't set close-on-exec flag on %d", fd);
@


1.1.1.11
log
@Latest from Cyclic Software
@
text
@a209 12
#ifdef SETXID_SUPPORT
	/*
	** This prevents a user from creating a privileged shell
	** from the text editor when the SETXID_SUPPORT option is selected.
	*/
	if (!strcmp (run_argv[0], Editor) && setegid (getgid ()))
	{
	    error (0, errno, "cannot set egid to gid");
	    _exit (127);
	}
#endif

@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@a326 5
    else
	/* ensure things are received by the parent in the correct order
	 * relative to the protocol pipe
	 */
	cvs_flusherr();
a329 5
    else
	/* ensure things are received by the parent in the correct order
	 * relative to the protocol pipe
	 */
	cvs_flushout();
d447 1
a447 1
#ifdef F_SETFD
@


