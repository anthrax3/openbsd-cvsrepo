head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.11.0.64
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.60
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.62
	OPENBSD_5_8_BASE:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.54
	OPENBSD_5_7_BASE:1.1.1.11
	OPENBSD_5_6:1.1.1.11.0.58
	OPENBSD_5_6_BASE:1.1.1.11
	OPENBSD_5_5:1.1.1.11.0.56
	OPENBSD_5_5_BASE:1.1.1.11
	OPENBSD_5_4:1.1.1.11.0.52
	OPENBSD_5_4_BASE:1.1.1.11
	OPENBSD_5_3:1.1.1.11.0.50
	OPENBSD_5_3_BASE:1.1.1.11
	OPENBSD_5_2:1.1.1.11.0.48
	OPENBSD_5_2_BASE:1.1.1.11
	OPENBSD_5_1_BASE:1.1.1.11
	OPENBSD_5_1:1.1.1.11.0.46
	OPENBSD_5_0:1.1.1.11.0.44
	OPENBSD_5_0_BASE:1.1.1.11
	OPENBSD_4_9:1.1.1.11.0.42
	OPENBSD_4_9_BASE:1.1.1.11
	OPENBSD_4_8:1.1.1.11.0.40
	OPENBSD_4_8_BASE:1.1.1.11
	OPENBSD_4_7:1.1.1.11.0.36
	OPENBSD_4_7_BASE:1.1.1.11
	OPENBSD_4_6:1.1.1.11.0.38
	OPENBSD_4_6_BASE:1.1.1.11
	OPENBSD_4_5:1.1.1.11.0.34
	OPENBSD_4_5_BASE:1.1.1.11
	OPENBSD_4_4:1.1.1.11.0.32
	OPENBSD_4_4_BASE:1.1.1.11
	OPENBSD_4_3:1.1.1.11.0.30
	OPENBSD_4_3_BASE:1.1.1.11
	OPENBSD_4_2:1.1.1.11.0.28
	OPENBSD_4_2_BASE:1.1.1.11
	OPENBSD_4_1:1.1.1.11.0.26
	OPENBSD_4_1_BASE:1.1.1.11
	OPENBSD_4_0:1.1.1.11.0.24
	OPENBSD_4_0_BASE:1.1.1.11
	OPENBSD_3_9:1.1.1.11.0.22
	OPENBSD_3_9_BASE:1.1.1.11
	OPENBSD_3_8:1.1.1.11.0.20
	OPENBSD_3_8_BASE:1.1.1.11
	OPENBSD_3_7:1.1.1.11.0.18
	OPENBSD_3_7_BASE:1.1.1.11
	OPENBSD_3_6:1.1.1.11.0.16
	OPENBSD_3_6_BASE:1.1.1.11
	OPENBSD_3_5:1.1.1.11.0.14
	OPENBSD_3_5_BASE:1.1.1.11
	OPENBSD_3_4:1.1.1.11.0.12
	OPENBSD_3_4_BASE:1.1.1.11
	OPENBSD_3_3:1.1.1.11.0.10
	OPENBSD_3_3_BASE:1.1.1.11
	OPENBSD_3_2:1.1.1.11.0.8
	OPENBSD_3_2_BASE:1.1.1.11
	OPENBSD_3_1:1.1.1.11.0.6
	OPENBSD_3_1_BASE:1.1.1.11
	OPENBSD_3_0:1.1.1.11.0.4
	OPENBSD_3_0_BASE:1.1.1.11
	cvs-1-11-1p1:1.1.1.11
	OPENBSD_2_9:1.1.1.11.0.2
	OPENBSD_2_9_BASE:1.1.1.11
	cvs-1-11:1.1.1.11
	OPENBSD_2_8:1.1.1.10.0.12
	OPENBSD_2_8_BASE:1.1.1.10
	OPENBSD_2_7:1.1.1.10.0.10
	OPENBSD_2_7_BASE:1.1.1.10
	OPENBSD_2_6:1.1.1.10.0.8
	OPENBSD_2_6_BASE:1.1.1.10
	cvs-1-10-7:1.1.1.10
	OPENBSD_2_5:1.1.1.10.0.6
	OPENBSD_2_5_BASE:1.1.1.10
	cvs-1-10-5:1.1.1.10
	OPENBSD_2_4:1.1.1.10.0.4
	OPENBSD_2_4_BASE:1.1.1.10
	cvs-1-10:1.1.1.10
	cvs-1-9-28:1.1.1.10
	OPENBSD_2_3:1.1.1.10.0.2
	OPENBSD_2_3_BASE:1.1.1.10
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.1.1.8.0.2
	OPENBSD_2_2_BASE:1.1.1.8
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.1.1.7.0.2
	OPENBSD_2_1_BASE:1.1.1.7
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.07;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.53;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.34;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.34;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.31;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.06;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.28.42;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.21.14;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.03.12.06.58.45;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2001.02.10.18.57.40;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS 1.4 kit.
 * 
 * Polk's hash list manager.  So cool.
 */

#include "cvs.h"

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)hash.c 1.19 94/09/23 $";
USE(rcsid);
#endif

/* global caches */
static List *listcache = NULL;
static Node *nodecache = NULL;

static void freenode_mem PROTO((Node * p));

/* hash function */
static int
hashp (key)
    const char *key;
{
    unsigned int h = 0;
    unsigned int g;

    while (*key != 0)
    {
	h = (h << 4) + *key++;
	if ((g = h & 0xf0000000) != 0)
	    h = (h ^ (g >> 24)) ^ g;
    }

    return (h % HASHSIZE);
}

/*
 * create a new list (or get an old one from the cache)
 */
List *
getlist ()
{
    int i;
    List *list;
    Node *node;

    if (listcache != NULL)
    {
	/* get a list from the cache and clear it */
	list = listcache;
	listcache = listcache->next;
	list->next = (List *) NULL;
	for (i = 0; i < HASHSIZE; i++)
	    list->hasharray[i] = (Node *) NULL;
    }
    else
    {
	/* make a new list from scratch */
	list = (List *) xmalloc (sizeof (List));
	memset ((char *) list, 0, sizeof (List));
	node = getnode ();
	list->list = node;
	node->type = HEADER;
	node->next = node->prev = node;
    }
    return (list);
}

/*
 * free up a list
 */
void
dellist (listp)
    List **listp;
{
    int i;
    Node *p;

    if (*listp == (List *) NULL)
	return;

    p = (*listp)->list;

    /* free each node in the list (except header) */
    while (p->next != p)
	delnode (p->next);

    /* free any list-private data, without freeing the actual header */
    freenode_mem (p);

    /* free up the header nodes for hash lists (if any) */
    for (i = 0; i < HASHSIZE; i++)
    {
	if ((p = (*listp)->hasharray[i]) != (Node *) NULL)
	{
	    /* put the nodes into the cache */
	    p->type = UNKNOWN;
	    p->next = nodecache;
	    nodecache = p;
	}
    }

    /* put it on the cache */
    (*listp)->next = listcache;
    listcache = *listp;
    *listp = (List *) NULL;
}

/*
 * get a new list node
 */
Node *
getnode ()
{
    Node *p;

    if (nodecache != (Node *) NULL)
    {
	/* get one from the cache */
	p = nodecache;
	nodecache = p->next;
    }
    else
    {
	/* make a new one */
	p = (Node *) xmalloc (sizeof (Node));
    }

    /* always make it clean */
    memset ((char *) p, 0, sizeof (Node));
    p->type = UNKNOWN;

    return (p);
}

/*
 * remove a node from it's list (maybe hash list too) and free it
 */
void
delnode (p)
    Node *p;
{
    if (p == (Node *) NULL)
	return;

    /* take it out of the list */
    p->next->prev = p->prev;
    p->prev->next = p->next;

    /* if it was hashed, remove it from there too */
    if (p->hashnext != (Node *) NULL)
    {
	p->hashnext->hashprev = p->hashprev;
	p->hashprev->hashnext = p->hashnext;
    }

    /* free up the storage */
    freenode (p);
}

/*
 * free up the storage associated with a node
 */
static void
freenode_mem (p)
    Node *p;
{
    if (p->delproc != (void (*) ()) NULL)
	p->delproc (p);			/* call the specified delproc */
    else
    {
	if (p->data != NULL)		/* otherwise free() it if necessary */
	    free (p->data);
    }
    if (p->key != NULL)			/* free the key if necessary */
	free (p->key);

    /* to be safe, re-initialize these */
    p->key = p->data = (char *) NULL;
    p->delproc = (void (*) ()) NULL;
}

/*
 * free up the storage associated with a node and recycle it
 */
void
freenode (p)
    Node *p;
{
    /* first free the memory */
    freenode_mem (p);

    /* then put it in the cache */
    p->type = UNKNOWN;
    p->next = nodecache;
    nodecache = p;
}

/*
 * insert item p at end of list "list" (maybe hash it too) if hashing and it
 * already exists, return -1 and don't actually put it in the list
 * 
 * return 0 on success
 */
int
addnode (list, p)
    List *list;
    Node *p;
{
    int hashval;
    Node *q;

    if (p->key != NULL)			/* hash it too? */
    {
	hashval = hashp (p->key);
	if (list->hasharray[hashval] == NULL)	/* make a header for list? */
	{
	    q = getnode ();
	    q->type = HEADER;
	    list->hasharray[hashval] = q->hashnext = q->hashprev = q;
	}

	/* put it into the hash list if it's not already there */
	for (q = list->hasharray[hashval]->hashnext;
	     q != list->hasharray[hashval]; q = q->hashnext)
	{
	    if (strcmp (p->key, q->key) == 0)
		return (-1);
	}
	q = list->hasharray[hashval];
	p->hashprev = q->hashprev;
	p->hashnext = q;
	p->hashprev->hashnext = p;
	q->hashprev = p;
    }

    /* put it into the regular list */
    p->prev = list->list->prev;
    p->next = list->list;
    list->list->prev->next = p;
    list->list->prev = p;

    return (0);
}

/*
 * look up an entry in hash list table and return a pointer to the
 * node.  Return NULL on error or not found.
 */
Node *
findnode (list, key)
    List *list;
    const char *key;
{
    Node *head, *p;

    if (list == (List *) NULL)
	return ((Node *) NULL);

    head = list->hasharray[hashp (key)];
    if (head == (Node *) NULL)
	return ((Node *) NULL);

    for (p = head->hashnext; p != head; p = p->hashnext)
	if (strcmp (p->key, key) == 0)
	    return (p);
    return ((Node *) NULL);
}

/*
 * walk a list with a specific proc
 */
int
walklist (list, proc, closure)
    List *list;
    int (*proc) PROTO ((Node *, void *));
    void *closure;
{
    Node *head, *p;
    int err = 0;

    if (list == NULL)
	return (0);

    head = list->list;
    for (p = head->next; p != head; p = p->next)
	err += proc (p, closure);
    return (err);
}

/*
 * sort the elements of a list (in place)
 */
void
sortlist (list, comp)
    List *list;
    int (*comp) PROTO ((const Node *, const Node *));
{
    Node *head, *remain, *p, *q;

    /* save the old first element of the list */
    head = list->list;
    remain = head->next;

    /* make the header node into a null list of it's own */
    head->next = head->prev = head;

    /* while there are nodes remaining, do insert sort */
    while (remain != head)
    {
	/* take one from the list */
	p = remain;
	remain = remain->next;

	/* traverse the sorted list looking for the place to insert it */
	for (q = head->next; q != head; q = q->next)
	{
	    if (comp (p, q) < 0)
	    {
		/* p comes before q */
		p->next = q;
		p->prev = q->prev;
		p->prev->next = p;
		q->prev = p;
		break;
	    }
	}
	if (q == head)
	{
	    /* it belongs at the end of the list */
	    p->next = head;
	    p->prev = head->prev;
	    p->prev->next = p;
	    head->prev = p;
	}
    }
}

/* Debugging functions.  Quite useful to call from within gdb. */

char *
nodetypestring (type)
    Ntype type;
{
    switch (type) {
    case UNKNOWN:	return("UNKNOWN");
    case HEADER:	return("HEADER");
    case ENTRIES:	return("ENTRIES");
    case FILES:		return("FILES");
    case LIST:		return("LIST");
    case RCSNODE:	return("RCSNODE");
    case RCSVERS:	return("RCSVERS");
    case DIRS:		return("DIRS");
    case UPDATE:	return("UPDATE");
    case LOCK:		return("LOCK");
    case NDBMNODE:	return("NDBMNODE");
    }

    return("<trash>");
}

static int printnode PROTO ((Node *, void *));
static int
printnode (node, closure)
     Node *node;
     void *closure;
{
    if (node == NULL)
    {
	(void) printf("NULL node.\n");
	return(0);
    }

    (void) printf("Node at 0x%p: type = %s, key = 0x%p = \"%s\", data = 0x%p, next = 0x%p, prev = 0x%p\n",
	   node, nodetypestring(node->type), node->key, node->key, node->data, node->next, node->prev);

    return(0);
}

void
printlist (list)
    List *list;
{
    if (list == NULL)
    {
	(void) printf("NULL list.\n");
	return;
    }

    (void) printf("List at 0x%p: list = 0x%p, HASHSIZE = %d, next = 0x%p\n",
	   list, list->list, HASHSIZE, list->next);
    
    (void) walklist(list, printnode, NULL);

    return;
}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d33 1
a33 3
	unsigned int c = *key++;
	/* The FOLD_FN_CHAR is so that findnode_fn works.  */
	h = (h << 4) + FOLD_FN_CHAR (c);
a274 23
 * Like findnode, but for a filename.
 */
Node *
findnode_fn (list, key)
    List *list;
    const char *key;
{
    Node *head, *p;

    if (list == (List *) NULL)
	return ((Node *) NULL);

    head = list->hasharray[hashp (key)];
    if (head == (Node *) NULL)
	return ((Node *) NULL);

    for (p = head->hashnext; p != head; p = p->hashnext)
	if (fncmp (p->key, key) == 0)
	    return (p);
    return ((Node *) NULL);
}

/*
a294 7
int
list_isempty (list)
    List *list;
{
    return list == NULL || list->list->next == list->list;
}

a360 1
    case FILEATTR:	return("FILEATTR");
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d11 5
a15 1
#include <assert.h>
a30 2
    assert(key != NULL);
    
d263 1
a263 4
    /* This probably should be "assert (list != NULL)" (or if not we
       should document the current behavior), but only if we check all
       the callers to see if any are relying on this behavior.  */
    if ((list == (List *) NULL))
a267 1
	/* Not found.  */
a393 1
    case VARIABLE:	return("VARIABLE");
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d250 4
a253 3
/* Look up an entry in hash list table and return a pointer to the
   node.  Return NULL if not found.  Abort with a fatal error for
   errors.  */
a266 2
    assert (key != NULL);

a287 3
    /* This probably should be "assert (list != NULL)" (or if not we
       should document the current behavior), but only if we check all
       the callers to see if any are relying on this behavior.  */
a289 2

    assert (key != NULL);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a402 1
    case RCSFIELD:	return("RCSFIELD");
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a334 13
static int (*client_comp) PROTO ((const Node *, const Node *));
static int qsort_comp PROTO ((const void *, const void *));

static int
qsort_comp (elem1, elem2)
    const void *elem1;
    const void *elem2;
{
    Node **node1 = (Node **) elem1;
    Node **node2 = (Node **) elem2;
    return client_comp (*node1, *node2);
}

d343 1
a343 2
    Node *head, *remain, *p, **array;
    int i, n;
d349 2
a350 14
    /* count the number of nodes in the list */
    n = 0;
    for (p = remain; p != head; p = p->next)
	n++;

    /* allocate an array of nodes and populate it */
    array = (Node **) xmalloc (sizeof(Node *) * n);
    i = 0;
    for (p = remain; p != head; p = p->next)
	array[i++] = p;

    /* sort the array of nodes */
    client_comp = comp;
    qsort (array, n, sizeof(Node *), qsort_comp);
d352 2
a353 3
    /* rebuild the list from beginning to end */
    head->next = head->prev = head;
    for (i = 0; i < n; i++)
d355 25
a379 5
	p = array[i];
	p->next = head;
	p->prev = head->prev;
	p->prev->next = p;
	head->prev = p;
a380 3

    /* release the array of nodes */
    free (array);
d385 1
a385 3
static char *nodetypestring PROTO ((Ntype));

static char *
a425 5

/* This is global, not static, so that its name is unique and to avoid
   compiler warnings about it not being used.  But it is not used by CVS;
   it exists so one can call it from a debugger.  */
void printlist PROTO ((List *));
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d13 1
a13 4
/* Global caches.  The idea is that we maintain a linked list of "free"d
   nodes or lists, and get new items from there.  It has been suggested
   to use an obstack instead, but off the top of my head, I'm not sure
   that would gain enough to be worth worrying about.  */
@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@a103 1
#ifndef NOCACHE
a106 6
#else
	    /* If NOCACHE is defined we turn off the cache.  This can make
	       it easier to tools to determine where items were allocated
	       and freed, for tracking down memory leaks and the like.  */
	    free (p);
#endif
a110 1
#ifndef NOCACHE
a112 4
#else
    free ((*listp)->list);
    free (*listp);
#endif
a200 1
#ifndef NOCACHE
a203 3
#else
    free (p);
#endif
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d5 1
a5 1
 * specified in the README file that comes with the CVS source distribution.
d223 2
a224 3
 * Link item P into list LIST before item MARKER.  If P->KEY is non-NULL and
 * that key is already in the hash table, return -1 without modifying any
 * parameter.
d229 1
a229 1
insert_before (list, marker, p)
a230 1
    Node *marker;
d233 3
a237 3
	int hashval;
	Node *q;

d260 5
a264 4
    p->next = marker;
    p->prev = marker->prev;
    marker->prev->next = p;
    marker->prev = p;
a266 26
}

/*
 * insert item p at end of list "list" (maybe hash it too) if hashing and it
 * already exists, return -1 and don't actually put it in the list
 * 
 * return 0 on success
 */
int
addnode (list, p)
    List *list;
    Node *p;
{
  return insert_before (list, list->list, p);
}

/*
 * Like addnode, but insert p at the front of `list'.  This bogosity is
 * necessary to preserve last-to-first output order for some RCS functions.
 */
int
addnode_at_front (list, p)
    List *list;
    Node *p;
{
  return insert_before (list, list->list->next, p);
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@a438 11
/*
 * compare two files list node (for sort)
 */
int
fsortcmp (p, q)
    const Node *p;
    const Node *q;
{
    return (strcmp (p->key, q->key));
}

@


1.1.1.11
log
@Latest from Cyclic Software
@
text
@d105 1
a105 1
	    p->type = NT_UNKNOWN;
d150 1
a150 1
    p->type = NT_UNKNOWN;
d214 1
a214 1
    p->type = NT_UNKNOWN;
d459 1
a459 1
    case NT_UNKNOWN:	return("UNKNOWN");
a472 1
    case RCSCMPFLD:	return("RCSCMPFLD");
@


