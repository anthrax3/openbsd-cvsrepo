head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.13.0.16
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.12
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.8
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.10
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.6
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.32
	OPENBSD_5_0:1.11.0.30
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.28
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.26
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.22
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.24
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.20
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.18
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.16
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.14
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.12
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.10
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.8
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.6
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	cvs-1-11-1p1:1.1.1.18
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	cvs-1-11:1.1.1.17
	OPENBSD_2_8:1.1.1.16.0.6
	OPENBSD_2_8_BASE:1.1.1.16
	OPENBSD_2_7:1.1.1.16.0.4
	OPENBSD_2_7_BASE:1.1.1.16
	OPENBSD_2_6:1.1.1.16.0.2
	OPENBSD_2_6_BASE:1.1.1.16
	cvs-1-10-7:1.1.1.16
	OPENBSD_2_5:1.1.1.15.0.2
	OPENBSD_2_5_BASE:1.1.1.15
	cvs-1-10-5:1.1.1.15
	OPENBSD_2_4:1.1.1.14.0.2
	OPENBSD_2_4_BASE:1.1.1.14
	cvs-1-10:1.1.1.14
	cvs-1-9-28:1.1.1.13
	OPENBSD_2_3:1.1.1.12.0.2
	OPENBSD_2_3_BASE:1.1.1.12
	cvs-1-9-26:1.1.1.12
	cvs-1-9-24:1.1.1.11
	OPENBSD_2_2:1.1.1.10.0.2
	OPENBSD_2_2_BASE:1.1.1.10
	cvs-1-9-10:1.1.1.10
	OPENBSD_2_1:1.1.1.9.0.2
	OPENBSD_2_1_BASE:1.1.1.9
	cvs-1-9-8:1.1.1.9
	cvs-1-9-6:1.1.1.8
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.08.21.16.45.13;	author millert;	state Exp;
branches;
next	1.13;
commitid	yyaOHV31VL5ImB71;

1.13
date	2013.12.03.01.32.49;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.16.07.03.04;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.06.04.41.29;	author itojun;	state Exp;
branches
	1.10.4.1
	1.10.6.1
	1.10.8.1;
next	1.9;

1.9
date	2002.06.21.23.37.49;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.29.00.00.39;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.11.01.50.18;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.11.01.04.54;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.10.19.31.34;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.12.07.49.18;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.10.02.29.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.00;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.41;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.21;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.25;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.21;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.55.57;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.03.29.04.38.08;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.04.21.04.26.58;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	97.06.28.03.28.36;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.02.22.08.21.04;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.03.12.06.58.33;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.07.13.03.53.46;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	98.08.22.20.52.59;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.02.28.21.32.41;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.09.10.05.06.21;	author tholo;	state Exp;
branches
	1.1.1.16.6.1;
next	1.1.1.17;

1.1.1.17
date	2001.02.10.18.57.38;	author tholo;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;

1.1.1.16.6.1
date	2001.02.12.15.57.09;	author jason;	state Exp;
branches;
next	;

1.10.4.1
date	2004.05.01.00.17.34;	author brad;	state Exp;
branches;
next	;

1.10.6.1
date	2004.05.01.00.09.46;	author brad;	state Exp;
branches;
next	;

1.10.8.1
date	2004.05.01.00.19.41;	author brad;	state Exp;
branches;
next	;


desc
@@


1.14
log
@When executing ssh, use "--" to indicate end of arguments before the
host name.  Adapted from a MirBSD diff by Thorsten Glaser.
@
text
@/* JT thinks BeOS is worth the trouble. */

/* CVS client-related stuff.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */

#include <assert.h>
#include "cvs.h"
#include "getline.h"
#include "edit.h"
#include "buffer.h"

#ifdef CLIENT_SUPPORT

#include "md5.h"

#if defined(AUTH_CLIENT_SUPPORT) || HAVE_KERBEROS || defined(SOCK_ERRNO) || defined(SOCK_STRERROR)
#  ifdef HAVE_WINSOCK_H
#    include <winsock.h>
#  else /* No winsock.h */
#    include <sys/socket.h>
#    include <netinet/in.h>
#    include <arpa/inet.h>
#    include <netdb.h>
#  endif /* No winsock.h */
#endif

/* If SOCK_ERRNO is defined, then send()/recv() and other socket calls
   do not set errno, but that this macro should be used to obtain an
   error code.  This probably doesn't make sense unless
   NO_SOCKET_TO_FD is also defined. */
#ifndef SOCK_ERRNO
#define SOCK_ERRNO errno
#endif

/* If SOCK_STRERROR is defined, then the error codes returned by
   socket operations are not known to strerror, and this macro must be
   used instead to convert those error codes to strings. */
#ifndef SOCK_STRERROR
#  define SOCK_STRERROR strerror

#  if STDC_HEADERS
#    include <string.h>
#  endif

#  ifndef strerror
extern char *strerror ();
#  endif
#endif /* ! SOCK_STRERROR */

#if HAVE_KERBEROS
#define CVS_PORT 1999

#include <krb.h>

extern char *krb_realmofhost ();
#ifndef HAVE_KRB_GET_ERR_TEXT
#define krb_get_err_text(status) krb_err_txt[status]
#endif /* HAVE_KRB_GET_ERR_TEXT */

/* Information we need if we are going to use Kerberos encryption.  */
static C_Block kblock;
static Key_schedule sched;

#endif /* HAVE_KERBEROS */

#ifdef HAVE_GSSAPI

# include "xgssapi.h"

/* This is needed for GSSAPI encryption.  */
static gss_ctx_id_t gcontext;

static int connect_to_gserver PROTO((int, const char *));

#endif /* HAVE_GSSAPI */

static void add_prune_candidate PROTO((char *));

/* All the commands.  */
int add PROTO((int argc, char **argv));
int admin PROTO((int argc, char **argv));
int checkout PROTO((int argc, char **argv));
int commit PROTO((int argc, char **argv));
int diff PROTO((int argc, char **argv));
int history PROTO((int argc, char **argv));
int import PROTO((int argc, char **argv));
int cvslog PROTO((int argc, char **argv));
int patch PROTO((int argc, char **argv));
int release PROTO((int argc, char **argv));
int cvsremove PROTO((int argc, char **argv));
int rtag PROTO((int argc, char **argv));
int status PROTO((int argc, char **argv));
int tag PROTO((int argc, char **argv));
int update PROTO((int argc, char **argv));

/* All the response handling functions.  */
static void handle_ok PROTO((char *, int));
static void handle_error PROTO((char *, int));
static void handle_valid_requests PROTO((char *, int));
static void handle_checked_in PROTO((char *, int));
static void handle_new_entry PROTO((char *, int));
static void handle_checksum PROTO((char *, int));
static void handle_copy_file PROTO((char *, int));
static void handle_updated PROTO((char *, int));
static void handle_merged PROTO((char *, int));
static void handle_patched PROTO((char *, int));
static void handle_rcs_diff PROTO((char *, int));
static void handle_removed PROTO((char *, int));
static void handle_remove_entry PROTO((char *, int));
static void handle_set_static_directory PROTO((char *, int));
static void handle_clear_static_directory PROTO((char *, int));
static void handle_set_sticky PROTO((char *, int));
static void handle_clear_sticky PROTO((char *, int));
static void handle_set_checkin_prog PROTO((char *, int));
static void handle_set_update_prog PROTO((char *, int));
static void handle_module_expansion PROTO((char *, int));
static void handle_wrapper_rcs_option PROTO((char *, int));
static void handle_m PROTO((char *, int));
static void handle_e PROTO((char *, int));
static void handle_f PROTO((char *, int));
static void handle_notified PROTO((char *, int));

static size_t try_read_from_server PROTO ((char *, size_t));
#endif /* CLIENT_SUPPORT */

#ifdef CLIENT_SUPPORT

/* We need to keep track of the list of directories we've sent to the
   server.  This list, along with the current CVSROOT, will help us
   decide which command-line arguments to send.  */
List *dirs_sent_to_server = NULL;

static int is_arg_a_parent_or_listed_dir PROTO((Node *, void *));

static int
is_arg_a_parent_or_listed_dir (n, d)
    Node *n;
    void *d;
{
    char *directory = n->key;	/* name of the dir sent to server */
    char *this_argv_elem = (char *) d;	/* this argv element */

    /* Say we should send this argument if the argument matches the
       beginning of a directory name sent to the server.  This way,
       the server will know to start at the top of that directory
       hierarchy and descend. */

    if (strncmp (directory, this_argv_elem, strlen (this_argv_elem)) == 0)
	return 1;

    return 0;
}

static int arg_should_not_be_sent_to_server PROTO((char *));

/* Return nonzero if this argument should not be sent to the
   server. */

static int
arg_should_not_be_sent_to_server (arg)
    char *arg;
{
    /* Decide if we should send this directory name to the server.  We
       should always send argv[i] if:

       1) the list of directories sent to the server is empty (as it
       will be for checkout, etc.).

       2) the argument is "."

       3) the argument is a file in the cwd and the cwd is checked out
       from the current root

       4) the argument lies within one of the paths in
       dirs_sent_to_server.

       */

    if (list_isempty (dirs_sent_to_server))
	return 0;		/* always send it */

    if (strcmp (arg, ".") == 0)
	return 0;		/* always send it */

    /* We should send arg if it is one of the directories sent to the
       server or the parent of one; this tells the server to descend
       the hierarchy starting at this level. */
    if (isdir (arg))
    {
	if (walklist (dirs_sent_to_server, is_arg_a_parent_or_listed_dir, arg))
	    return 0;

	/* If arg wasn't a parent, we don't know anything about it (we
	   would have seen something related to it during the
	   send_files phase).  Don't send it.  */
	return 1;
    }

    /* Try to decide whether we should send arg to the server by
       checking the contents of the corresponding CVSADM directory. */
    {
	char *t, *this_root;

	/* Calculate "dirname arg" */
	for (t = arg + strlen (arg) - 1; t >= arg; t--)
	{
	    if (ISDIRSEP(*t))
		break;
	}

	/* Now we're either poiting to the beginning of the
	   string, or we found a path separator. */
	if (t >= arg)
	{
	    /* Found a path separator.  */
	    char c = *t;
	    *t = '\0';
	    
	    /* First, check to see if we sent this directory to the
               server, because it takes less time than actually
               opening the stuff in the CVSADM directory.  */
	    if (walklist (dirs_sent_to_server, is_arg_a_parent_or_listed_dir,
			  arg))
	    {
		*t = c;		/* make sure to un-truncate the arg */
		return 0;
	    }

	    /* Since we didn't find it in the list, check the CVSADM
               files on disk.  */
	    this_root = Name_Root (arg, (char *) NULL);
	    *t = c;
	}
	else
	{
	    /* We're at the beginning of the string.  Look at the
               CVSADM files in cwd.  */
	    this_root = Name_Root ((char *) NULL, (char *) NULL);
	}

	/*
	 * This is so bogus!  Means if you have checked out from
	 * a replica of a repository, and then when you want to
	 * check it in to the real (read/write) repository, the
	 * file will be skipped!
	 */
#if 0
	/* Now check the value for root. */
	if (this_root && current_parsed_root
	    && (strcmp (this_root, current_parsed_root->original) != 0))
	{
	    /* Don't send this, since the CVSROOTs don't match. */
	    free (this_root);
	    return 1;
	}
#endif
	free (this_root);
    }
    
    /* OK, let's send it. */
    return 0;
}


#endif /* CLIENT_SUPPORT */

#if defined(CLIENT_SUPPORT) || defined(SERVER_SUPPORT)

/* Shared with server.  */

/*
 * Return a malloc'd, '\0'-terminated string
 * corresponding to the mode in SB.
 */
char *
#ifdef __STDC__
mode_to_string (mode_t mode)
#else /* ! __STDC__ */
mode_to_string (mode)
	mode_t mode;
#endif /* __STDC__ */
{
    char buf[18], u[4], g[4], o[4];
    int i;

    i = 0;
    if (mode & S_IRUSR) u[i++] = 'r';
    if (mode & S_IWUSR) u[i++] = 'w';
    if (mode & S_IXUSR) u[i++] = 'x';
    u[i] = '\0';

    i = 0;
    if (mode & S_IRGRP) g[i++] = 'r';
    if (mode & S_IWGRP) g[i++] = 'w';
    if (mode & S_IXGRP) g[i++] = 'x';
    g[i] = '\0';

    i = 0;
    if (mode & S_IROTH) o[i++] = 'r';
    if (mode & S_IWOTH) o[i++] = 'w';
    if (mode & S_IXOTH) o[i++] = 'x';
    o[i] = '\0';

    sprintf(buf, "u=%s,g=%s,o=%s", u, g, o);
    return xstrdup(buf);
}

/*
 * Change mode of FILENAME to MODE_STRING.
 * Returns 0 for success or errno code.
 * If RESPECT_UMASK is set, then honor the umask.
 */
int
change_mode (filename, mode_string, respect_umask)
    char *filename;
    char *mode_string;
    int respect_umask;
{
#ifdef CHMOD_BROKEN
    char *p;
    int writeable = 0;

    /* We can only distinguish between
         1) readable
         2) writeable
         3) Picasso's "Blue Period"
       We handle the first two. */
    p = mode_string;
    while (*p != '\0')
    {
	if ((p[0] == 'u' || p[0] == 'g' || p[0] == 'o') && p[1] == '=')
	{
	    char *q = p + 2;
	    while (*q != ',' && *q != '\0')
	    {
		if (*q == 'w')
		    writeable = 1;
		++q;
	    }
	}
	/* Skip to the next field.  */
	while (*p != ',' && *p != '\0')
	    ++p;
	if (*p == ',')
	    ++p;
    }

    /* xchmod honors the umask for us.  In the !respect_umask case, we
       don't try to cope with it (probably to handle that well, the server
       needs to deal with modes in data structures, rather than via the
       modes in temporary files).  */
    xchmod (filename, writeable);
	return 0;

#else /* ! CHMOD_BROKEN */

    char *p;
    mode_t mode = 0;
    mode_t oumask;

    p = mode_string;
    while (*p != '\0')
    {
	if ((p[0] == 'u' || p[0] == 'g' || p[0] == 'o') && p[1] == '=')
	{
	    int can_read = 0, can_write = 0, can_execute = 0;
	    char *q = p + 2;
	    while (*q != ',' && *q != '\0')
	    {
		if (*q == 'r')
		    can_read = 1;
		else if (*q == 'w')
		    can_write = 1;
		else if (*q == 'x')
		    can_execute = 1;
		++q;
	    }
	    if (p[0] == 'u')
	    {
		if (can_read)
		    mode |= S_IRUSR;
		if (can_write)
		    mode |= S_IWUSR;
		if (can_execute)
		    mode |= S_IXUSR;
	    }
	    else if (p[0] == 'g')
	    {
		if (can_read)
		    mode |= S_IRGRP;
		if (can_write)
		    mode |= S_IWGRP;
		if (can_execute)
		    mode |= S_IXGRP;
	    }
	    else if (p[0] == 'o')
	    {
		if (can_read)
		    mode |= S_IROTH;
		if (can_write)
		    mode |= S_IWOTH;
		if (can_execute)
		    mode |= S_IXOTH;
	    }
	}
	/* Skip to the next field.  */
	while (*p != ',' && *p != '\0')
	    ++p;
	if (*p == ',')
	    ++p;
    }

    if (respect_umask)
    {
	oumask = umask (0);
	(void) umask (oumask);
	mode &= ~oumask;
    }

    if (chmod (filename, mode) < 0)
	return errno;
    return 0;
#endif /* ! CHMOD_BROKEN */
}

#endif /* CLIENT_SUPPORT or SERVER_SUPPORT */

#ifdef CLIENT_SUPPORT

int client_prune_dirs;

static List *ignlist = (List *) NULL;

/* Buffer to write to the server.  */
static struct buffer *to_server;
/* The stream underlying to_server, if we are using a stream.  */
static FILE *to_server_fp;

/* Buffer used to read from the server.  */
static struct buffer *from_server;
/* The stream underlying from_server, if we are using a stream.  */
static FILE *from_server_fp;

/* Process ID of rsh subprocess.  */
static int rsh_pid = -1;


/* We want to be able to log data sent between us and the server.  We
   do it using log buffers.  Each log buffer has another buffer which
   handles the actual I/O, and a file to log information to.

   This structure is the closure field of a log buffer.  */

struct log_buffer
{
    /* The underlying buffer.  */
    struct buffer *buf;
    /* The file to log information to.  */
    FILE *log;
};

static struct buffer *log_buffer_initialize
  PROTO((struct buffer *, FILE *, int, void (*) (struct buffer *)));
static int log_buffer_input PROTO((void *, char *, int, int, int *));
static int log_buffer_output PROTO((void *, const char *, int, int *));
static int log_buffer_flush PROTO((void *));
static int log_buffer_block PROTO((void *, int));
static int log_buffer_shutdown PROTO((void *));

/* Create a log buffer.  */

static struct buffer *
log_buffer_initialize (buf, fp, input, memory)
     struct buffer *buf;
     FILE *fp;
     int input;
     void (*memory) PROTO((struct buffer *));
{
    struct log_buffer *n;

    n = (struct log_buffer *) xmalloc (sizeof *n);
    n->buf = buf;
    n->log = fp;
    return buf_initialize (input ? log_buffer_input : NULL,
			   input ? NULL : log_buffer_output,
			   input ? NULL : log_buffer_flush,
			   log_buffer_block,
			   log_buffer_shutdown,
			   memory,
			   n);
}

/* The input function for a log buffer.  */

static int
log_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
{
    struct log_buffer *lb = (struct log_buffer *) closure;
    int status;
    size_t n_to_write;

    if (lb->buf->input == NULL)
	abort ();

    status = (*lb->buf->input) (lb->buf->closure, data, need, size, got);
    if (status != 0)
	return status;

    if (*got > 0)
    {
	n_to_write = *got;
	if (fwrite (data, 1, n_to_write, lb->log) != n_to_write)
	    error (0, errno, "writing to log file");
    }

    return 0;
}

/* The output function for a log buffer.  */

static int
log_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
{
    struct log_buffer *lb = (struct log_buffer *) closure;
    int status;
    size_t n_to_write;

    if (lb->buf->output == NULL)
	abort ();

    status = (*lb->buf->output) (lb->buf->closure, data, have, wrote);
    if (status != 0)
	return status;

    if (*wrote > 0)
    {
	n_to_write = *wrote;
	if (fwrite (data, 1, n_to_write, lb->log) != n_to_write)
	    error (0, errno, "writing to log file");
    }

    return 0;
}

/* The flush function for a log buffer.  */

static int
log_buffer_flush (closure)
     void *closure;
{
    struct log_buffer *lb = (struct log_buffer *) closure;

    if (lb->buf->flush == NULL)
	abort ();

    /* We don't really have to flush the log file here, but doing it
       will let tail -f on the log file show what is sent to the
       network as it is sent.  */
    if (fflush (lb->log) != 0)
        error (0, errno, "flushing log file");

    return (*lb->buf->flush) (lb->buf->closure);
}

/* The block function for a log buffer.  */

static int
log_buffer_block (closure, block)
     void *closure;
     int block;
{
    struct log_buffer *lb = (struct log_buffer *) closure;

    if (block)
	return set_block (lb->buf);
    else
	return set_nonblock (lb->buf);
}

/* The shutdown function for a log buffer.  */

static int
log_buffer_shutdown (closure)
     void *closure;
{
    struct log_buffer *lb = (struct log_buffer *) closure;
    int retval;

    retval = buf_shutdown (lb->buf);
    if (fclose (lb->log) < 0)
	error (0, errno, "closing log file");
    return retval;
}

#ifdef NO_SOCKET_TO_FD

/* Under certain circumstances, we must communicate with the server
   via a socket using send() and recv().  This is because under some
   operating systems (OS/2 and Windows 95 come to mind), a socket
   cannot be converted to a file descriptor -- it must be treated as a
   socket and nothing else.
   
   We may also need to deal with socket routine error codes differently
   in these cases.  This is handled through the SOCK_ERRNO and
   SOCK_STRERROR macros. */

static int use_socket_style = 0;
static int server_sock;

/* These routines implement a buffer structure which uses send and
   recv.  The buffer is always in blocking mode so we don't implement
   the block routine.  */

/* Note that it is important that these routines always handle errors
   internally and never return a positive errno code, since it would in
   general be impossible for the caller to know in general whether any
   error code came from a socket routine (to decide whether to use
   SOCK_STRERROR or simply strerror to print an error message). */

/* We use an instance of this structure as the closure field.  */

struct socket_buffer
{
    /* The socket number.  */
    int socket;
};

static struct buffer *socket_buffer_initialize
  PROTO ((int, int, void (*) (struct buffer *)));
static int socket_buffer_input PROTO((void *, char *, int, int, int *));
static int socket_buffer_output PROTO((void *, const char *, int, int *));
static int socket_buffer_flush PROTO((void *));

/* Create a buffer based on a socket.  */

static struct buffer *
socket_buffer_initialize (socket, input, memory)
     int socket;
     int input;
     void (*memory) PROTO((struct buffer *));
{
    struct socket_buffer *n;

    n = (struct socket_buffer *) xmalloc (sizeof *n);
    n->socket = socket;
    return buf_initialize (input ? socket_buffer_input : NULL,
			   input ? NULL : socket_buffer_output,
			   input ? NULL : socket_buffer_flush,
			   (int (*) PROTO((void *, int))) NULL,
			   (int (*) PROTO((void *))) NULL,
			   memory,
			   n);
}

/* The buffer input function for a buffer built on a socket.  */

static int
socket_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
{
    struct socket_buffer *sb = (struct socket_buffer *) closure;
    int nbytes;

    /* I believe that the recv function gives us exactly the semantics
       we want.  If there is a message, it returns immediately with
       whatever it could get.  If there is no message, it waits until
       one comes in.  In other words, it is not like read, which in
       blocking mode normally waits until all the requested data is
       available.  */

    *got = 0;

    do
    {

	/* Note that for certain (broken?) networking stacks, like
	   VMS's UCX (not sure what version, problem reported with
	   recv() in 1997), and (according to windows-NT/config.h)
	   Windows NT 3.51, we must call recv or send with a
	   moderately sized buffer (say, less than 200K or something),
	   or else there may be network errors (somewhat hard to
	   produce, e.g. WAN not LAN or some such).  buf_read_data
	   makes sure that we only recv() BUFFER_DATA_SIZE bytes at
	   a time.  */

	nbytes = recv (sb->socket, data, size, 0);
	if (nbytes < 0)
	    error (1, 0, "reading from server: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (nbytes == 0)
	{
	    /* End of file (for example, the server has closed
	       the connection).  If we've already read something, we
	       just tell the caller about the data, not about the end of
	       file.  If we've read nothing, we return end of file.  */
	    if (*got == 0)
		return -1;
	    else
		return 0;
	}
	need -= nbytes;
	size -= nbytes;
	data += nbytes;
	*got += nbytes;
    }
    while (need > 0);

    return 0;
}

/* The buffer output function for a buffer built on a socket.  */

static int
socket_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
{
    struct socket_buffer *sb = (struct socket_buffer *) closure;

    *wrote = have;

    /* See comment in socket_buffer_input regarding buffer size we pass
       to send and recv.  */

#ifdef SEND_NEVER_PARTIAL
    /* If send() never will produce a partial write, then just do it.  This
       is needed for systems where its return value is something other than
       the number of bytes written.  */
    if (send (sb->socket, data, have, 0) < 0)
	error (1, 0, "writing to server socket: %s", SOCK_STRERROR (SOCK_ERRNO));
#else
    while (have > 0)
    {
	int nbytes;

	nbytes = send (sb->socket, data, have, 0);
	if (nbytes < 0)
	    error (1, 0, "writing to server socket: %s", SOCK_STRERROR (SOCK_ERRNO));

	have -= nbytes;
	data += nbytes;
    }
#endif

    return 0;
}

/* The buffer flush function for a buffer built on a socket.  */

/*ARGSUSED*/
static int
socket_buffer_flush (closure)
     void *closure;
{
    /* Nothing to do.  Sockets are always flushed.  */
    return 0;
}

#endif /* NO_SOCKET_TO_FD */

/*
 * Read a line from the server.  Result does not include the terminating \n.
 *
 * Space for the result is malloc'd and should be freed by the caller.
 *
 * Returns number of bytes read.
 */
static int
read_line (resultp)
    char **resultp;
{
    int status;
    char *result;
    int len;

    status = buf_flush (to_server, 1);
    if (status != 0)
	error (1, status, "writing to server");

    status = buf_read_line (from_server, &result, &len);
    if (status != 0)
    {
	if (status == -1)
	    error (1, 0, "end of file from server (consult above messages if any)");
	else if (status == -2)
	    error (1, 0, "out of memory");
	else
	    error (1, status, "reading from server");
    }

    if (resultp != NULL)
	*resultp = result;
    else
	free (result);

    return len;
}

#endif /* CLIENT_SUPPORT */


#if defined(CLIENT_SUPPORT) || defined(SERVER_SUPPORT)

/*
 * Zero if compression isn't supported or requested; non-zero to indicate
 * a compression level to request from gzip.
 */
int gzip_level;

/*
 * Level of compression to use when running gzip on a single file.
 */
int file_gzip_level;

#endif /* CLIENT_SUPPORT or SERVER_SUPPORT */

#ifdef CLIENT_SUPPORT

/*
 * The Repository for the top level of this command (not necessarily
 * the CVSROOT, just the current directory at the time we do it).
 */
static char *toplevel_repos = NULL;

/* Working directory when we first started.  Note: we could speed things
   up on some systems by using savecwd.h here instead of just always
   storing a name.  */
char *toplevel_wd;

static void
handle_ok (args, len)
    char *args;
    int len;
{
    return;
}

static void
handle_error (args, len)
    char *args;
    int len;
{
    int something_printed;
    
    /*
     * First there is a symbolic error code followed by a space, which
     * we ignore.
     */
    char *p = strchr (args, ' ');
    if (p == NULL)
    {
	error (0, 0, "invalid data from cvs server");
	return;
    }
    ++p;

    /* Next we print the text of the message from the server.  We
       probably should be prefixing it with "server error" or some
       such, because if it is something like "Out of memory", the
       current behavior doesn't say which machine is out of
       memory.  */

    len -= p - args;
    something_printed = 0;
    for (; len > 0; --len)
    {
	something_printed = 1;
	putc (*p++, stderr);
    }
    if (something_printed)
	putc ('\n', stderr);
}

static void
handle_valid_requests (args, len)
    char *args;
    int len;
{
    char *p = args;
    char *q;
    struct request *rq;
    do
    {
	q = strchr (p, ' ');
	if (q != NULL)
	    *q++ = '\0';
	for (rq = requests; rq->name != NULL; ++rq)
	{
	    if (strcmp (rq->name, p) == 0)
		break;
	}
	if (rq->name == NULL)
	    /*
	     * It is a request we have never heard of (and thus never
	     * will want to use).  So don't worry about it.
	     */
	    ;
	else
	{
	    if (rq->flags & RQ_ENABLEME)
	    {
		/*
		 * Server wants to know if we have this, to enable the
		 * feature.
		 */
		send_to_server (rq->name, 0);
                send_to_server ("\012", 0);
	    }
	    else
		rq->flags |= RQ_SUPPORTED;
	}
	p = q;
    } while (q != NULL);
    for (rq = requests; rq->name != NULL; ++rq)
    {
	if ((rq->flags & RQ_SUPPORTED)
	    || (rq->flags & RQ_ENABLEME))
	    continue;
	if (rq->flags & RQ_ESSENTIAL)
	    error (1, 0, "request `%s' not supported by server", rq->name);
    }
}

/* This variable holds the result of Entries_Open, so that we can
   close Entries_Close on it when we move on to a new directory, or
   when we finish.  */
static List *last_entries;

/*
 * Do all the processing for PATHNAME, where pathname consists of the
 * repository and the filename.  The parameters we pass to FUNC are:
 * DATA is just the DATA parameter which was passed to
 * call_in_directory; ENT_LIST is a pointer to an entries list (which
 * we manage the storage for); SHORT_PATHNAME is the pathname of the
 * file relative to the (overall) directory in which the command is
 * taking place; and FILENAME is the filename portion only of
 * SHORT_PATHNAME.  When we call FUNC, the curent directory points to
 * the directory portion of SHORT_PATHNAME.  */

static char *last_dir_name;

static void
call_in_directory (pathname, func, data)
    char *pathname;
    void (*func) PROTO((char *data, List *ent_list, char *short_pathname,
			  char *filename));
    char *data;
{
    char *dir_name;
    char *filename;
    /* This is what we get when we hook up the directory (working directory
       name) from PATHNAME with the filename from REPOSNAME.  For example:
       pathname: ccvs/src/
       reposname: /u/src/master/ccvs/foo/ChangeLog
       short_pathname: ccvs/src/ChangeLog
       */
    char *short_pathname;
    char *p;

    /*
     * Do the whole descent in parallel for the repositories, so we
     * know what to put in CVS/Repository files.  I'm not sure the
     * full hair is necessary since the server does a similar
     * computation; I suspect that we only end up creating one
     * directory at a time anyway.
     *
     * Also note that we must *only* worry about this stuff when we
     * are creating directories; `cvs co foo/bar; cd foo/bar; cvs co
     * CVSROOT; cvs update' is legitimate, but in this case
     * foo/bar/CVSROOT/CVS/Repository is not a subdirectory of
     * foo/bar/CVS/Repository.
     */
    char *reposname;
    char *short_repos;
    char *reposdirname;
    char *rdirp;
    int reposdirname_absolute;

    /*
     * For security reasons, if PATHNAME is absolute or attempts to
     * ascend outside of the current sandbox, we abort.  The server should not
     * send us anything but relative paths which remain inside the sandbox
     * here.  Anything less means a trojan CVS server could create and edit
     * arbitrary files on the client.
     */
    if (isabsolute (pathname) || pathname_levels (pathname) > 0)
    {
        error (0, 0,
               "Server attempted to update a file via an invalid pathname:");
        error (1, 0, "`%s'.", pathname);
    }

    reposname = NULL;
    read_line (&reposname);
    assert (reposname != NULL);

    reposdirname_absolute = 0;
    if (strncmp (reposname, toplevel_repos, strlen (toplevel_repos)) != 0)
    {
	reposdirname_absolute = 1;
	short_repos = reposname;
    }
    else
    {
	short_repos = reposname + strlen (toplevel_repos) + 1;
	if (short_repos[-1] != '/')
	{
	    reposdirname_absolute = 1;
	    short_repos = reposname;
	}
    }
    reposdirname = xstrdup (short_repos);
    p = strrchr (reposdirname, '/');
    if (p == NULL)
    {
	reposdirname = xrealloc (reposdirname, 2);
	reposdirname[0] = '.'; reposdirname[1] = '\0';
    }
    else
	*p = '\0';

    dir_name = xstrdup (pathname);
    p = strrchr (dir_name, '/');
    if (p == NULL)
    {
	dir_name = xrealloc (dir_name, 2);
	dir_name[0] = '.'; dir_name[1] = '\0';
    }
    else
	*p = '\0';
    if (client_prune_dirs)
	add_prune_candidate (dir_name);

    filename = strrchr (short_repos, '/');
    if (filename == NULL)
	filename = short_repos;
    else
	++filename;

    short_pathname = xmalloc (strlen (pathname) + strlen (filename) + 5);
    strcpy (short_pathname, pathname);
    strcat (short_pathname, filename);

    if (last_dir_name == NULL
	|| strcmp (last_dir_name, dir_name) != 0)
    {
	int newdir;

	if (strcmp (command_name, "export") != 0)
	    if (last_entries)
		Entries_Close (last_entries);

	if (last_dir_name)
	    free (last_dir_name);
	last_dir_name = dir_name;

	if (toplevel_wd == NULL)
	{
	    toplevel_wd = xgetwd ();
	    if (toplevel_wd == NULL)
		error (1, errno, "could not get working directory");
	}

	if (CVS_CHDIR (toplevel_wd) < 0)
	    error (1, errno, "could not chdir to %s", toplevel_wd);
	newdir = 0;

	/* Create the CVS directory at the top level if needed.  The
	   isdir seems like an unneeded system call, but it *does*
	   need to be called both if the CVS_CHDIR below succeeds
	   (e.g.  "cvs co .") or if it fails (e.g. basicb-1a in
	   testsuite).  We only need to do this for the "." case,
	   since the server takes care of forcing this directory to be
	   created in all other cases.  If we don't create CVSADM
	   here, the call to Entries_Open below will fail.  FIXME:
	   perhaps this means that we should change our algorithm
	   below that calls Create_Admin instead of having this code
	   here? */
	if (/* I think the reposdirname_absolute case has to do with
	       things like "cvs update /foo/bar".  In any event, the
	       code below which tries to put toplevel_repos into
	       CVS/Repository is almost surely unsuited to
	       the reposdirname_absolute case.  */
	    !reposdirname_absolute
	    && (strcmp (dir_name, ".") == 0)
	    && ! isdir (CVSADM))
	{
	    char *repo;
	    char *r;

	    newdir = 1;

	    repo = xmalloc (strlen (toplevel_repos)
			    + 10);
	    strcpy (repo, toplevel_repos);
	    r = repo + strlen (repo);
	    if (r[-1] != '.' || r[-2] != '/')
	        strcpy (r, "/.");

	    Create_Admin (".", ".", repo, (char *) NULL,
			  (char *) NULL, 0, 1, 1);

	    free (repo);
	}

	if ( CVS_CHDIR (dir_name) < 0)
	{
	    char *dir;
	    char *dirp;
	    
	    if (! existence_error (errno))
		error (1, errno, "could not chdir to %s", dir_name);
	    
	    /* Directory does not exist, we need to create it.  */
	    newdir = 1;

	    /* Provided we are willing to assume that directories get
	       created one at a time, we could simplify this a lot.
	       Do note that one aspect still would need to walk the
	       dir_name path: the checking for "fncmp (dir, CVSADM)".  */

	    dir = xmalloc (strlen (dir_name) + 1);
	    dirp = dir_name;
	    rdirp = reposdirname;

	    /* This algorithm makes nested directories one at a time
               and create CVS administration files in them.  For
               example, we're checking out foo/bar/baz from the
               repository:

	       1) create foo, point CVS/Repository to <root>/foo
	       2)     .. foo/bar                   .. <root>/foo/bar
	       3)     .. foo/bar/baz               .. <root>/foo/bar/baz
	       
	       As you can see, we're just stepping along DIR_NAME (with
	       DIRP) and REPOSDIRNAME (with RDIRP) respectively.

	       We need to be careful when we are checking out a
	       module, however, since DIR_NAME and REPOSDIRNAME are not
	       going to be the same.  Since modules will not have any
	       slashes in their names, we should watch the output of
	       STRCHR to decide whether or not we should use STRCHR on
	       the RDIRP.  That is, if we're down to a module name,
	       don't keep picking apart the repository directory name.  */

	    do
	    {
		dirp = strchr (dirp, '/');
		if (dirp)
		{
		    strncpy (dir, dir_name, dirp - dir_name);
		    dir[dirp - dir_name] = '\0';
		    /* Skip the slash.  */
		    ++dirp;
		    if (rdirp == NULL)
			/* This just means that the repository string has
			   fewer components than the dir_name string.  But
			   that is OK (e.g. see modules3-8 in testsuite).  */
			;
		    else
			rdirp = strchr (rdirp, '/');
		}
		else
		{
		    /* If there are no more slashes in the dir name,
                       we're down to the most nested directory -OR- to
                       the name of a module.  In the first case, we
                       should be down to a DIRP that has no slashes,
                       so it won't help/hurt to do another STRCHR call
                       on DIRP.  It will definitely hurt, however, if
                       we're down to a module name, since a module
                       name can point to a nested directory (that is,
                       DIRP will still have slashes in it.  Therefore,
                       we should set it to NULL so the routine below
                       copies the contents of REMOTEDIRNAME onto the
                       root repository directory (does this if rdirp
                       is set to NULL, because we used to do an extra
                       STRCHR call here). */

		    rdirp = NULL;
		    strcpy (dir, dir_name);
		}

		if (fncmp (dir, CVSADM) == 0)
		{
		    error (0, 0, "cannot create a directory named %s", dir);
		    error (0, 0, "because CVS uses \"%s\" for its own uses",
			   CVSADM);
		    error (1, 0, "rename the directory and try again");
		}

		if (mkdir_if_needed (dir))
		{
		    /* It already existed, fine.  Just keep going.  */
		}
		else if (strcmp (command_name, "export") == 0)
		    /* Don't create CVSADM directories if this is export.  */
		    ;
		else
		{
		    /*
		     * Put repository in CVS/Repository.  For historical
		     * (pre-CVS/Root) reasons, this is an absolute pathname,
		     * but what really matters is the part of it which is
		     * relative to cvsroot.
		     */
		    char *repo;
		    char *r, *b;

		    repo = xmalloc (strlen (reposdirname)
				    + strlen (toplevel_repos)
				    + 80);
		    if (reposdirname_absolute)
			r = repo;
		    else
		    {
			strcpy (repo, toplevel_repos);
			strcat (repo, "/");
			r = repo + strlen (repo);
		    }

		    if (rdirp)
		    {
			/* See comment near start of function; the only
			   way that the server can put the right thing
			   in each CVS/Repository file is to create the
			   directories one at a time.  I think that the
			   CVS server has been doing this all along.  */
			error (0, 0, "\
warning: server is not creating directories one at a time");
			strncpy (r, reposdirname, rdirp - reposdirname);
			r[rdirp - reposdirname] = '\0';
		    }
		    else
			strcpy (r, reposdirname);

		    Create_Admin (dir, dir, repo,
				  (char *)NULL, (char *)NULL, 0, 0, 1);
		    free (repo);

		    b = strrchr (dir, '/');
		    if (b == NULL)
			Subdir_Register ((List *) NULL, (char *) NULL, dir);
		    else
		    {
			*b = '\0';
			Subdir_Register ((List *) NULL, dir, b + 1);
			*b = '/';
		    }
		}

		if (rdirp != NULL)
		{
		    /* Skip the slash.  */
		    ++rdirp;
		}

	    } while (dirp != NULL);
	    free (dir);
	    /* Now it better work.  */
	    if ( CVS_CHDIR (dir_name) < 0)
		error (1, errno, "could not chdir to %s", dir_name);
	}
	else if (!isdir (CVSADM))
	{
	    /*
	     * Put repository in CVS/Repository.  For historical
	     * (pre-CVS/Root) reasons, this is an absolute pathname,
	     * but what really matters is the part of it which is
	     * relative to cvsroot.
	     */
	    char *repo;

	    if (reposdirname_absolute)
		repo = reposdirname;
	    else
	    {
		repo = xmalloc (strlen (reposdirname)
				+ strlen (toplevel_repos)
				+ 10);
		strcpy (repo, toplevel_repos);
		strcat (repo, "/");
		strcat (repo, reposdirname);
	    }

	    Create_Admin (".", ".", repo, (char *)NULL, (char *)NULL, 0, 1, 1);
	    if (repo != reposdirname)
		free (repo);
	}

	if (strcmp (command_name, "export") != 0)
	{
	    last_entries = Entries_Open (0, dir_name);

	    /* If this is a newly created directory, we will record
	       all subdirectory information, so call Subdirs_Known in
	       case there are no subdirectories.  If this is not a
	       newly created directory, it may be an old working
	       directory from before we recorded subdirectory
	       information in the Entries file.  We force a search for
	       all subdirectories now, to make sure our subdirectory
	       information is up to date.  If the Entries file does
	       record subdirectory information, then this call only
	       does list manipulation.  */
	    if (newdir)
		Subdirs_Known (last_entries);
	    else
	    {
		List *dirlist;

		dirlist = Find_Directories ((char *) NULL, W_LOCAL,
					    last_entries);
		dellist (&dirlist);
	    }
	}
    }
    else
	free (dir_name);
    free (reposdirname);
    (*func) (data, last_entries, short_pathname, filename);
    free (short_pathname);
    free (reposname);
}

static void
copy_a_file (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    char *newname;
#ifdef USE_VMS_FILENAMES
    char *p;
#endif

    read_line (&newname);

#ifdef USE_VMS_FILENAMES
    /* Mogrify the filename so VMS is happy with it. */
    for(p = newname; *p; p++)
       if(*p == '.' || *p == '#') *p = '_';
#endif
    /* cvsclient.texi has said for a long time that newname must be in the
       same directory.  Wouldn't want a malicious or buggy server overwriting
       ~/.profile, /etc/passwd, or anything like that.  */
    if (last_component (newname) != newname)
	error (1, 0, "protocol error: Copy-file tried to specify directory");

    if (unlink_file (newname) && !existence_error (errno))
	error (0, errno, "unable to remove %s", newname);
    copy_file (filename, newname);
    free (newname);
}

static void
handle_copy_file (args, len)
    char *args;
    int len;
{
    call_in_directory (args, copy_a_file, (char *)NULL);
}


static void read_counted_file PROTO ((char *, char *));

/* Read from the server the count for the length of a file, then read
   the contents of that file and write them to FILENAME.  FULLNAME is
   the name of the file for use in error messages.  FIXME-someday:
   extend this to deal with compressed files and make update_entries
   use it.  On error, gives a fatal error.  */
static void
read_counted_file (filename, fullname)
    char *filename;
    char *fullname;
{
    char *size_string;
    size_t size;
    char *buf;

    /* Pointers in buf to the place to put data which will be read,
       and the data which needs to be written, respectively.  */
    char *pread;
    char *pwrite;
    /* Number of bytes left to read and number of bytes in buf waiting to
       be written, respectively.  */
    size_t nread;
    size_t nwrite;

    FILE *fp;

    read_line (&size_string);
    if (size_string[0] == 'z')
	error (1, 0, "\
protocol error: compressed files not supported for that operation");
    /* FIXME: should be doing more error checking, probably.  Like using
       strtoul and making sure we used up the whole line.  */
    size = atoi (size_string);
    free (size_string);

    /* A more sophisticated implementation would use only a limited amount
       of buffer space (8K perhaps), and read that much at a time.  We allocate
       a buffer for the whole file only to make it easy to keep track what
       needs to be read and written.  */
    buf = xmalloc (size);

    /* FIXME-someday: caller should pass in a flag saying whether it
       is binary or not.  I haven't carefully looked into whether
       CVS/Template files should use local text file conventions or
       not.  */
    fp = CVS_FOPEN (filename, "wb");
    if (fp == NULL)
	error (1, errno, "cannot write %s", fullname);
    nread = size;
    nwrite = 0;
    pread = buf;
    pwrite = buf;
    while (nread > 0 || nwrite > 0)
    {
	size_t n;

	if (nread > 0)
	{
	    n = try_read_from_server (pread, nread);
	    nread -= n;
	    pread += n;
	    nwrite += n;
	}

	if (nwrite > 0)
	{
	    n = fwrite (pwrite, 1, nwrite, fp);
	    if (ferror (fp))
		error (1, errno, "cannot write %s", fullname);
	    nwrite -= n;
	    pwrite += n;
	}
    }
    free (buf);
    if (fclose (fp) < 0)
	error (1, errno, "cannot close %s", fullname);
}

/* OK, we want to swallow the "U foo.c" response and then output it only
   if we can update the file.  In the future we probably want some more
   systematic approach to parsing tagged text, but for now we keep it
   ad hoc.  "Why," I hear you cry, "do we not just look at the
   Update-existing and Created responses?"  That is an excellent question,
   and the answer is roughly conservatism/laziness--I haven't read through
   update.c enough to figure out the exact correspondence or lack thereof
   between those responses and a "U foo.c" line (note that Merged, from
   join_file, can be either "C foo" or "U foo" depending on the context).  */
/* Nonzero if we have seen +updated and not -updated.  */
static int updated_seen;
/* Filename from an "fname" tagged response within +updated/-updated.  */
static char *updated_fname;

/* This struct is used to hold data when reading the +importmergecmd
   and -importmergecmd tags.  We put the variables in a struct only
   for namespace issues.  FIXME: As noted above, we need to develop a
   more systematic approach.  */
static struct
{
    /* Nonzero if we have seen +importmergecmd and not -importmergecmd.  */
    int seen;
    /* Number of conflicts, from a "conflicts" tagged response.  */
    int conflicts;
    /* First merge tag, from a "mergetag1" tagged response.  */
    char *mergetag1;
    /* Second merge tag, from a "mergetag2" tagged response.  */
    char *mergetag2;
    /* Repository, from a "repository" tagged response.  */
    char *repository;
} importmergecmd;

/* Nonzero if we should arrange to return with a failure exit status.  */
static int failure_exit;


/*
 * The time stamp of the last file we registered.
 */
static time_t last_register_time;

/*
 * The Checksum response gives the checksum for the file transferred
 * over by the next Updated, Merged or Patch response.  We just store
 * it here, and then check it in update_entries.
 */

static int stored_checksum_valid;
static unsigned char stored_checksum[16];

static void
handle_checksum (args, len)
    char *args;
    int len;
{
    char *s;
    char buf[3];
    int i;

    if (stored_checksum_valid)
        error (1, 0, "Checksum received before last one was used");

    s = args;
    buf[2] = '\0';
    for (i = 0; i < 16; i++)
    {
        char *bufend;

	buf[0] = *s++;
	buf[1] = *s++;
	stored_checksum[i] = (char) strtol (buf, &bufend, 16);
	if (bufend != buf + 2)
	    break;
    }

    if (i < 16 || *s != '\0')
        error (1, 0, "Invalid Checksum response: `%s'", args);

    stored_checksum_valid = 1;
}

/* Mode that we got in a "Mode" response (malloc'd), or NULL if none.  */
static char *stored_mode;

static void handle_mode PROTO ((char *, int));

static void
handle_mode (args, len)
    char *args;
    int len;
{
    if (stored_mode != NULL)
	error (1, 0, "protocol error: duplicate Mode");
    stored_mode = xstrdup (args);
}

/* Nonzero if time was specified in Mod-time.  */
static int stored_modtime_valid;
/* Time specified in Mod-time.  */
static time_t stored_modtime;

static void handle_mod_time PROTO ((char *, int));

static void
handle_mod_time (args, len)
    char *args;
    int len;
{
    if (stored_modtime_valid)
	error (0, 0, "protocol error: duplicate Mod-time");
    stored_modtime = get_date (args);
    if (stored_modtime == (time_t) -1)
	error (0, 0, "protocol error: cannot parse date %s", args);
    else
	stored_modtime_valid = 1;
}

/*
 * If we receive a patch, but the patch program fails to apply it, we
 * want to request the original file.  We keep a list of files whose
 * patches have failed.
 */

char **failed_patches;
int failed_patches_count;

struct update_entries_data
{
    enum {
      /*
       * We are just getting an Entries line; the local file is
       * correct.
       */
      UPDATE_ENTRIES_CHECKIN,
      /* We are getting the file contents as well.  */
      UPDATE_ENTRIES_UPDATE,
      /*
       * We are getting a patch against the existing local file, not
       * an entire new file.
       */
      UPDATE_ENTRIES_PATCH,
      /*
       * We are getting an RCS change text (diff -n output) against
       * the existing local file, not an entire new file.
       */
      UPDATE_ENTRIES_RCS_DIFF
    } contents;

    enum {
	/* We are replacing an existing file.  */
	UPDATE_ENTRIES_EXISTING,
	/* We are creating a new file.  */
	UPDATE_ENTRIES_NEW,
	/* We don't know whether it is existing or new.  */
	UPDATE_ENTRIES_EXISTING_OR_NEW
    } existp;

    /*
     * String to put in the timestamp field or NULL to use the timestamp
     * of the file.
     */
    char *timestamp;
};

/* Update the Entries line for this file.  */
static void
update_entries (data_arg, ent_list, short_pathname, filename)
    char *data_arg;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    char *entries_line;
    struct update_entries_data *data = (struct update_entries_data *)data_arg;

    char *cp;
    char *user;
    char *vn;
    /* Timestamp field.  Always empty according to the protocol.  */
    char *ts;
    char *options = NULL;
    char *tag = NULL;
    char *date = NULL;
    char *tag_or_date;
    char *scratch_entries = NULL;
    int bin;

#ifdef UTIME_EXPECTS_WRITABLE
    int change_it_back = 0;
#endif

    read_line (&entries_line);

    /*
     * Parse the entries line.
     */
    scratch_entries = xstrdup (entries_line);

    if (scratch_entries[0] != '/')
        error (1, 0, "bad entries line `%s' from server", entries_line);
    user = scratch_entries + 1;
    if ((cp = strchr (user, '/')) == NULL)
        error (1, 0, "bad entries line `%s' from server", entries_line);
    *cp++ = '\0';
    vn = cp;
    if ((cp = strchr (vn, '/')) == NULL)
        error (1, 0, "bad entries line `%s' from server", entries_line);
    *cp++ = '\0';
    
    ts = cp;
    if ((cp = strchr (ts, '/')) == NULL)
        error (1, 0, "bad entries line `%s' from server", entries_line);
    *cp++ = '\0';
    options = cp;
    if ((cp = strchr (options, '/')) == NULL)
        error (1, 0, "bad entries line `%s' from server", entries_line);
    *cp++ = '\0';
    tag_or_date = cp;
    
    /* If a slash ends the tag_or_date, ignore everything after it.  */
    cp = strchr (tag_or_date, '/');
    if (cp != NULL)
        *cp = '\0';
    if (*tag_or_date == 'T')
        tag = tag_or_date + 1;
    else if (*tag_or_date == 'D')
        date = tag_or_date + 1;

    /* Done parsing the entries line. */

    if (data->contents == UPDATE_ENTRIES_UPDATE
	|| data->contents == UPDATE_ENTRIES_PATCH
	|| data->contents == UPDATE_ENTRIES_RCS_DIFF)
    {
	char *size_string;
	char *mode_string;
	int size;
	char *buf;
	char *temp_filename;
	int use_gzip;
	int patch_failed;

	read_line (&mode_string);
	
	read_line (&size_string);
	if (size_string[0] == 'z')
	{
	    use_gzip = 1;
	    size = atoi (size_string+1);
	}
	else
	{
	    use_gzip = 0;
	    size = atoi (size_string);
	}
	free (size_string);

	/* Note that checking this separately from writing the file is
	   a race condition: if the existence or lack thereof of the
	   file changes between now and the actual calls which
	   operate on it, we lose.  However (a) there are so many
	   cases, I'm reluctant to try to fix them all, (b) in some
	   cases the system might not even have a system call which
	   does the right thing, and (c) it isn't clear this needs to
	   work.  */
	if (data->existp == UPDATE_ENTRIES_EXISTING
	    && !isfile (filename))
	    /* Emit a warning and update the file anyway.  */
	    error (0, 0, "warning: %s unexpectedly disappeared",
		   short_pathname);

	if (data->existp == UPDATE_ENTRIES_NEW
	    && isfile (filename))
	{
	    /* Emit a warning and refuse to update the file; we don't want
	       to clobber a user's file.  */
	    size_t nread;
	    size_t toread;

	    /* size should be unsigned, but until we get around to fixing
	       that, work around it.  */
	    size_t usize;

	    char buf[8192];

	    /* This error might be confusing; it isn't really clear to
	       the user what to do about it.  Keep in mind that it has
	       several causes: (1) something/someone creates the file
	       during the time that CVS is running, (2) the repository
	       has two files whose names clash for the client because
	       of case-insensitivity or similar causes, (3) a special
	       case of this is that a file gets renamed for example
	       from a.c to A.C.  A "cvs update" on a case-insensitive
	       client will get this error.  Repeating the update takes
	       care of the problem, but is it clear to the user what
	       is going on and what to do about it?, (4) the client
	       has a file which the server doesn't know about (e.g. "?
	       foo" file), and that name clashes with a file the
	       server does know about, (5) classify.c will print the same
	       message for other reasons.

	       I hope the above paragraph makes it clear that making this
	       clearer is not a one-line fix.  */
	    error (0, 0, "move away %s; it is in the way", short_pathname);
	    if (updated_fname != NULL)
	    {
		cvs_output ("C ", 0);
		cvs_output (updated_fname, 0);
		cvs_output ("\n", 1);
	    }
	    failure_exit = 1;

	discard_file_and_return:
	    /* Now read and discard the file contents.  */
	    usize = size;
	    nread = 0;
	    while (nread < usize)
	    {
		toread = usize - nread;
		if (toread > sizeof buf)
		    toread = sizeof buf;

		nread += try_read_from_server (buf, toread);
		if (nread == usize)
		    break;
	    }

	    free (mode_string);
	    free (scratch_entries);
	    free (entries_line);

	    /* The Mode, Mod-time, and Checksum responses should not carry
	       over to a subsequent Created (or whatever) response, even
	       in the error case.  */
	    if (stored_mode != NULL)
	    {
		free (stored_mode);
		stored_mode = NULL;
	    }
	    stored_modtime_valid = 0;
	    stored_checksum_valid = 0;

	    if (updated_fname != NULL)
	    {
		free (updated_fname);
		updated_fname = NULL;
	    }
	    return;
	}

	temp_filename = xmalloc (strlen (filename) + 80);
#ifdef USE_VMS_FILENAMES
        /* A VMS rename of "blah.dat" to "foo" to implies a
           destination of "foo.dat" which is unfortinate for CVS */
       sprintf (temp_filename, "%s_new_", filename);
#else
#ifdef _POSIX_NO_TRUNC
	sprintf (temp_filename, ".new.%.9s", filename);
#else /* _POSIX_NO_TRUNC */
	sprintf (temp_filename, ".new.%s", filename);
#endif /* _POSIX_NO_TRUNC */
#endif /* USE_VMS_FILENAMES */

	buf = xmalloc (size);

        /* Some systems, like OS/2 and Windows NT, end lines with CRLF
           instead of just LF.  Format translation is done in the C
           library I/O funtions.  Here we tell them whether or not to
           convert -- if this file is marked "binary" with the RCS -kb
           flag, then we don't want to convert, else we do (because
           CVS assumes text files by default). */

	if (options)
	    bin = !(strcmp (options, "-kb"));
	else
	    bin = 0;

	if (data->contents == UPDATE_ENTRIES_RCS_DIFF)
	{
	    /* This is an RCS change text.  We just hold the change
	       text in memory.  */

	    if (use_gzip)
		error (1, 0,
		       "server error: gzip invalid with RCS change text");

	    read_from_server (buf, size);
	}
	else
	{
	    int fd;

	    fd = CVS_OPEN (temp_filename,
			   (O_WRONLY | O_CREAT | O_TRUNC
			    | (bin ? OPEN_BINARY : 0)),
			   0777);

	    if (fd < 0)
	    {
		/* I can see a case for making this a fatal error; for
		   a condition like disk full or network unreachable
		   (for a file server), carrying on and giving an
		   error on each file seems unnecessary.  But if it is
		   a permission problem, or some such, then it is
		   entirely possible that future files will not have
		   the same problem.  */
		error (0, errno, "cannot write %s", short_pathname);
		goto discard_file_and_return;
	    }

	    if (size > 0)
	    {
		read_from_server (buf, size);

		if (use_gzip)
		{
		    if (gunzip_and_write (fd, short_pathname, 
					  (unsigned char *) buf, size))
			error (1, 0, "aborting due to compression error");
		}
		else if (write (fd, buf, size) != size)
		    error (1, errno, "writing %s", short_pathname);
	    }

	    if (close (fd) < 0)
		error (1, errno, "writing %s", short_pathname);
	}

	/* This is after we have read the file from the net (a change
	   from previous versions, where the server would send us
	   "M U foo.c" before Update-existing or whatever), but before
	   we finish writing the file (arguably a bug).  The timing
	   affects a user who wants status info about how far we have
	   gotten, and also affects whether "U foo.c" appears in addition
	   to various error messages.  */
	if (updated_fname != NULL)
	{
	    cvs_output ("U ", 0);
	    cvs_output (updated_fname, 0);
	    cvs_output ("\n", 1);
	    free (updated_fname);
	    updated_fname = 0;
	}

	patch_failed = 0;

	if (data->contents == UPDATE_ENTRIES_UPDATE)
	{
	    rename_file (temp_filename, filename);
	}
	else if (data->contents == UPDATE_ENTRIES_PATCH)
	{
	    /* You might think we could just leave Patched out of
	       Valid-responses and not get this response.  However, if
	       memory serves, the CVS 1.9 server bases this on -u
	       (update-patches), and there is no way for us to send -u
	       or not based on whether the server supports "Rcs-diff".  

	       Fall back to transmitting entire files.  */
	    patch_failed = 1;
	}
	else
	{
	    char *filebuf;
	    size_t filebufsize;
	    size_t nread;
	    char *patchedbuf;
	    size_t patchedlen;

	    /* Handle UPDATE_ENTRIES_RCS_DIFF.  */

	    if (!isfile (filename))
	        error (1, 0, "patch original file %s does not exist",
		       short_pathname);
	    filebuf = NULL;
	    filebufsize = 0;
	    nread = 0;

	    get_file (filename, short_pathname, bin ? FOPEN_BINARY_READ : "r",
		      &filebuf, &filebufsize, &nread);
	    /* At this point the contents of the existing file are in
               FILEBUF, and the length of the contents is in NREAD.
               The contents of the patch from the network are in BUF,
               and the length of the patch is in SIZE.  */

	    if (! rcs_change_text (short_pathname, filebuf, nread, buf, size,
				   &patchedbuf, &patchedlen))
		patch_failed = 1;
	    else
	    {
		if (stored_checksum_valid)
		{
		    struct cvs_MD5Context context;
		    unsigned char checksum[16];

		    /* We have a checksum.  Check it before writing
		       the file out, so that we don't have to read it
		       back in again.  */
		    cvs_MD5Init (&context);
		    cvs_MD5Update (&context,
				   (unsigned char *) patchedbuf, patchedlen);
		    cvs_MD5Final (checksum, &context);
		    if (memcmp (checksum, stored_checksum, 16) != 0)
		    {
			error (0, 0,
			       "checksum failure after patch to %s; will refetch",
			       short_pathname);

			patch_failed = 1;
		    }

		    stored_checksum_valid = 0;
		}

		if (! patch_failed)
		{
		    FILE *e;

		    e = open_file (temp_filename,
				   bin ? FOPEN_BINARY_WRITE : "w");
		    if (fwrite (patchedbuf, 1, patchedlen, e) != patchedlen)
			error (1, errno, "cannot write %s", temp_filename);
		    if (fclose (e) == EOF)
			error (1, errno, "cannot close %s", temp_filename);
		    rename_file (temp_filename, filename);
		}

		free (patchedbuf);
	    }

	    free (filebuf);
	}

	free (temp_filename);

	if (stored_checksum_valid && ! patch_failed)
	{
	    FILE *e;
	    struct cvs_MD5Context context;
	    unsigned char buf[8192];
	    unsigned len;
	    unsigned char checksum[16];

	    /*
	     * Compute the MD5 checksum.  This will normally only be
	     * used when receiving a patch, so we always compute it
	     * here on the final file, rather than on the received
	     * data.
	     *
	     * Note that if the file is a text file, we should read it
	     * here using text mode, so its lines will be terminated the same
	     * way they were transmitted.
	     */
	    e = CVS_FOPEN (filename, "r");
	    if (e == NULL)
	        error (1, errno, "could not open %s", short_pathname);

	    cvs_MD5Init (&context);
	    while ((len = fread (buf, 1, sizeof buf, e)) != 0)
		cvs_MD5Update (&context, buf, len);
	    if (ferror (e))
		error (1, errno, "could not read %s", short_pathname);
	    cvs_MD5Final (checksum, &context);

	    fclose (e);

	    stored_checksum_valid = 0;

	    if (memcmp (checksum, stored_checksum, 16) != 0)
	    {
	        if (data->contents != UPDATE_ENTRIES_PATCH)
		    error (1, 0, "checksum failure on %s",
			   short_pathname);

		error (0, 0,
		       "checksum failure after patch to %s; will refetch",
		       short_pathname);

		patch_failed = 1;
	    }
	}

	if (patch_failed)
	{
	    /* Save this file to retrieve later.  */
	    failed_patches = (char **) xrealloc ((char *) failed_patches,
						 ((failed_patches_count + 1)
						  * sizeof (char *)));
	    failed_patches[failed_patches_count] = xstrdup (short_pathname);
	    ++failed_patches_count;

	    stored_checksum_valid = 0;

	    free (mode_string);
	    free (buf);
	    free (scratch_entries);
	    free (entries_line);

	    return;
	}

        {
	    int status = change_mode (filename, mode_string, 1);
	    if (status != 0)
		error (0, status, "cannot change mode of %s", short_pathname);
	}

	free (mode_string);
	free (buf);
    }

    if (stored_mode != NULL)
    {
	change_mode (filename, stored_mode, 1);
	free (stored_mode);
	stored_mode = NULL;
    }
   
    if (stored_modtime_valid)
    {
	struct utimbuf t;

	memset (&t, 0, sizeof (t));
	/* There is probably little point in trying to preserved the
	   actime (or is there? What about Checked-in?).  */
	t.modtime = t.actime = stored_modtime;

#ifdef UTIME_EXPECTS_WRITABLE
	if (!iswritable (filename))
	{
	    xchmod (filename, 1);
	    change_it_back = 1;
	}
#endif  /* UTIME_EXPECTS_WRITABLE  */

	if (utime (filename, &t) < 0)
	    error (0, errno, "cannot set time on %s", filename);

#ifdef UTIME_EXPECTS_WRITABLE
	if (change_it_back == 1)
	{
	    xchmod (filename, 0);
	    change_it_back = 0;
	}
#endif  /*  UTIME_EXPECTS_WRITABLE  */

	stored_modtime_valid = 0;
    }

    /*
     * Process the entries line.  Do this after we've written the file,
     * since we need the timestamp.
     */
    if (strcmp (command_name, "export") != 0)
    {
	char *local_timestamp;
	char *file_timestamp;

	(void) time (&last_register_time);

	local_timestamp = data->timestamp;
	if (local_timestamp == NULL || ts[0] == '+')
	    file_timestamp = time_stamp (filename);
	else
	    file_timestamp = NULL;

	/*
	 * These special version numbers signify that it is not up to
	 * date.  Create a dummy timestamp which will never compare
	 * equal to the timestamp of the file.
	 */
	if (vn[0] == '\0' || vn[0] == '0' || vn[0] == '-')
	    local_timestamp = "dummy timestamp";
	else if (local_timestamp == NULL)
	{
	    local_timestamp = file_timestamp;

	    /* Checking for command_name of "commit" doesn't seem like
	       the cleanest way to handle this, but it seem to roughly
	       parallel what the :local: code which calls
	       mark_up_to_date ends up amounting to.  Some day, should
	       think more about what the Checked-in response means
	       vis-a-vis both Entries and Base and clarify
	       cvsclient.texi accordingly.  */

	    if (!strcmp (command_name, "commit"))
		mark_up_to_date (filename);
	}

	Register (ent_list, filename, vn, local_timestamp,
		  options, tag, date, ts[0] == '+' ? file_timestamp : NULL);

	if (file_timestamp)
	    free (file_timestamp);

    }
    free (scratch_entries);
    free (entries_line);
}

static void
handle_checked_in (args, len)
    char *args;
    int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_CHECKIN;
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
    dat.timestamp = NULL;
    call_in_directory (args, update_entries, (char *)&dat);
}

static void
handle_new_entry (args, len)
    char *args;
    int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_CHECKIN;
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
    dat.timestamp = "dummy timestamp from new-entry";
    call_in_directory (args, update_entries, (char *)&dat);
}

static void
handle_updated (args, len)
    char *args;
    int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_UPDATE;
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
    dat.timestamp = NULL;
    call_in_directory (args, update_entries, (char *)&dat);
}

static void handle_created PROTO((char *, int));

static void
handle_created (args, len)
    char *args;
    int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_UPDATE;
    dat.existp = UPDATE_ENTRIES_NEW;
    dat.timestamp = NULL;
    call_in_directory (args, update_entries, (char *)&dat);
}

static void handle_update_existing PROTO((char *, int));

static void
handle_update_existing (args, len)
    char *args;
    int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_UPDATE;
    dat.existp = UPDATE_ENTRIES_EXISTING;
    dat.timestamp = NULL;
    call_in_directory (args, update_entries, (char *)&dat);
}

static void
handle_merged (args, len)
    char *args;
    int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_UPDATE;
    /* Think this could be UPDATE_ENTRIES_EXISTING, but just in case...  */
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
    dat.timestamp = "Result of merge";
    call_in_directory (args, update_entries, (char *)&dat);
}

static void
handle_patched (args, len)
     char *args;
     int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_PATCH;
    /* Think this could be UPDATE_ENTRIES_EXISTING, but just in case...  */
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
    dat.timestamp = NULL;
    call_in_directory (args, update_entries, (char *)&dat);
}

static void
handle_rcs_diff (args, len)
     char *args;
     int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_RCS_DIFF;
    /* Think this could be UPDATE_ENTRIES_EXISTING, but just in case...  */
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
    dat.timestamp = NULL;
    call_in_directory (args, update_entries, (char *)&dat);
}

static void
remove_entry (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    Scratch_Entry (ent_list, filename);
}

static void
handle_remove_entry (args, len)
    char *args;
    int len;
{
    call_in_directory (args, remove_entry, (char *)NULL);
}

static void
remove_entry_and_file (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    Scratch_Entry (ent_list, filename);
    /* Note that we don't ignore existence_error's here.  The server
       should be sending Remove-entry rather than Removed in cases
       where the file does not exist.  And if the user removes the
       file halfway through a cvs command, we should be printing an
       error.  */
    if (unlink_file (filename) < 0)
	error (0, errno, "unable to remove %s", short_pathname);
}

static void
handle_removed (args, len)
    char *args;
    int len;
{
    call_in_directory (args, remove_entry_and_file, (char *)NULL);
}

/* Is this the top level (directory containing CVSROOT)?  */
static int
is_cvsroot_level (pathname)
    char *pathname;
{
    if (strcmp (toplevel_repos, current_parsed_root->directory) != 0)
	return 0;

    return strchr (pathname, '/') == NULL;
}

static void
set_static (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    FILE *fp;
    fp = open_file (CVSADM_ENTSTAT, "w+");
    if (fclose (fp) == EOF)
        error (1, errno, "cannot close %s", CVSADM_ENTSTAT);
}

static void
handle_set_static_directory (args, len)
    char *args;
    int len;
{
    if (strcmp (command_name, "export") == 0)
    {
	/* Swallow the repository.  */
	read_line (NULL);
	return;
    }
    call_in_directory (args, set_static, (char *)NULL);
}

static void
clear_static (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    if (unlink_file (CVSADM_ENTSTAT) < 0 && ! existence_error (errno))
        error (1, errno, "cannot remove file %s", CVSADM_ENTSTAT);
}

static void
handle_clear_static_directory (pathname, len)
    char *pathname;
    int len;
{
    if (strcmp (command_name, "export") == 0)
    {
	/* Swallow the repository.  */
	read_line (NULL);
	return;
    }

    if (is_cvsroot_level (pathname))
    {
        /*
	 * Top level (directory containing CVSROOT).  This seems to normally
	 * lack a CVS directory, so don't try to create files in it.
	 */
	return;
    }
    call_in_directory (pathname, clear_static, (char *)NULL);
}

static void
set_sticky (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    char *tagspec;
    FILE *f;

    read_line (&tagspec);

    /* FIXME-update-dir: error messages should include the directory.  */
    f = CVS_FOPEN (CVSADM_TAG, "w+");
    if (f == NULL)
    {
	/* Making this non-fatal is a bit of a kludge (see dirs2
	   in testsuite).  A better solution would be to avoid having
	   the server tell us about a directory we shouldn't be doing
	   anything with anyway (e.g. by handling directory
	   addition/removal better).  */
	error (0, errno, "cannot open %s", CVSADM_TAG);
	free (tagspec);
	return;
    }
    if (fprintf (f, "%s\n", tagspec) < 0)
	error (1, errno, "writing %s", CVSADM_TAG);
    if (fclose (f) == EOF)
	error (1, errno, "closing %s", CVSADM_TAG);
    free (tagspec);
}

static void
handle_set_sticky (pathname, len)
    char *pathname;
    int len;
{
    if (strcmp (command_name, "export") == 0)
    {
	/* Swallow the repository.  */
	read_line (NULL);
        /* Swallow the tag line.  */
	read_line (NULL);
	return;
    }
    if (is_cvsroot_level (pathname))
    {
        /*
	 * Top level (directory containing CVSROOT).  This seems to normally
	 * lack a CVS directory, so don't try to create files in it.
	 */

	/* Swallow the repository.  */
	read_line (NULL);
        /* Swallow the tag line.  */
	read_line (NULL);
	return;
    }

    call_in_directory (pathname, set_sticky, (char *)NULL);
}

static void
clear_sticky (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    if (unlink_file (CVSADM_TAG) < 0 && ! existence_error (errno))
	error (1, errno, "cannot remove %s", CVSADM_TAG);
}

static void
handle_clear_sticky (pathname, len)
    char *pathname;
    int len;
{
    if (strcmp (command_name, "export") == 0)
    {
	/* Swallow the repository.  */
	read_line (NULL);
	return;
    }

    if (is_cvsroot_level (pathname))
    {
        /*
	 * Top level (directory containing CVSROOT).  This seems to normally
	 * lack a CVS directory, so don't try to create files in it.
	 */
	return;
    }

    call_in_directory (pathname, clear_sticky, (char *)NULL);
}


static void template PROTO ((char *, List *, char *, char *));

static void
template (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    /* FIXME: should be computing second argument from CVSADM_TEMPLATE
       and short_pathname.  */
    read_counted_file (CVSADM_TEMPLATE, "<CVS/Template file>");
}

static void handle_template PROTO ((char *, int));

static void
handle_template (pathname, len)
    char *pathname;
    int len;
{
    call_in_directory (pathname, template, NULL);
}


struct save_prog {
    char *name;
    char *dir;
    struct save_prog *next;
};

static struct save_prog *checkin_progs;
static struct save_prog *update_progs;

/*
 * Unlike some responses this doesn't include the repository.  So we can't
 * just call call_in_directory and have the right thing happen; we save up
 * the requests and do them at the end.
 */
static void
handle_set_checkin_prog (args, len)
    char *args;
    int len;
{
    char *prog;
    struct save_prog *p;

    read_line (&prog);
    if (strcmp (command_name, "export") == 0)
	return;

    p = (struct save_prog *) xmalloc (sizeof (struct save_prog));
    p->next = checkin_progs;
    p->dir = xstrdup (args);
    p->name = prog;
    checkin_progs = p;
}
    
static void
handle_set_update_prog (args, len)
    char *args;
    int len;
{
    char *prog;
    struct save_prog *p;

    read_line (&prog);
    if (strcmp (command_name, "export") == 0)
	return;

    p = (struct save_prog *) xmalloc (sizeof (struct save_prog));
    p->next = update_progs;
    p->dir = xstrdup (args);
    p->name = prog;
    update_progs = p;
}

static void do_deferred_progs PROTO((void));

static void
do_deferred_progs ()
{
    struct save_prog *p;
    struct save_prog *q;

    char *fname;
    FILE *f;

    if (toplevel_wd != NULL)
    {
	if (CVS_CHDIR (toplevel_wd) < 0)
	    error (1, errno, "could not chdir to %s", toplevel_wd);
    }
    for (p = checkin_progs; p != NULL; )
    {
	fname = xmalloc (strlen (p->dir) + sizeof CVSADM_CIPROG + 10);
	sprintf (fname, "%s/%s", p->dir, CVSADM_CIPROG);
	f = open_file (fname, "w");
	if (fprintf (f, "%s\n", p->name) < 0)
	    error (1, errno, "writing %s", fname);
	if (fclose (f) == EOF)
	    error (1, errno, "closing %s", fname);
	free (p->name);
	free (p->dir);
	q = p->next;
	free (p);
	p = q;
	free (fname);
    }
    checkin_progs = NULL;
    for (p = update_progs; p != NULL; )
    {
	fname = xmalloc (strlen (p->dir) + sizeof CVSADM_UPROG + 10);
	sprintf (fname, "%s/%s", p->dir, CVSADM_UPROG);
	f = open_file (fname, "w");
	if (fprintf (f, "%s\n", p->name) < 0)
	    error (1, errno, "writing %s", fname);
	if (fclose (f) == EOF)
	    error (1, errno, "closing %s", fname);
	free (p->name);
	free (p->dir);
	q = p->next;
	free (p);
	p = q;
	free (fname);
    }
    update_progs = NULL;
}

struct save_dir {
    char *dir;
    struct save_dir *next;
};

struct save_dir *prune_candidates;

static void
add_prune_candidate (dir)
    char *dir;
{
    struct save_dir *p;

    if ((dir[0] == '.' && dir[1] == '\0')
	|| (prune_candidates != NULL
	    && strcmp (dir, prune_candidates->dir) == 0))
	return;
    p = (struct save_dir *) xmalloc (sizeof (struct save_dir));
    p->dir = xstrdup (dir);
    p->next = prune_candidates;
    prune_candidates = p;
}

static void process_prune_candidates PROTO((void));

static void
process_prune_candidates ()
{
    struct save_dir *p;
    struct save_dir *q;

    if (toplevel_wd != NULL)
    {
	if (CVS_CHDIR (toplevel_wd) < 0)
	    error (1, errno, "could not chdir to %s", toplevel_wd);
    }
    for (p = prune_candidates; p != NULL; )
    {
	if (isemptydir (p->dir, 1))
	{
	    char *b;

	    if (unlink_file_dir (p->dir) < 0)
		error (0, errno, "cannot remove %s", p->dir);
	    b = strrchr (p->dir, '/');
	    if (b == NULL)
		Subdir_Deregister ((List *) NULL, (char *) NULL, p->dir);
	    else
	    {
		*b = '\0';
		Subdir_Deregister ((List *) NULL, p->dir, b + 1);
	    }
	}
	free (p->dir);
	q = p->next;
	free (p);
	p = q;
    }
    prune_candidates = NULL;
}

/* Send a Repository line.  */

static char *last_repos;
static char *last_update_dir;

static void send_repository PROTO((char *, char *, char *));

static void
send_repository (dir, repos, update_dir)
    char *dir;
    char *repos;
    char *update_dir;
{
    char *adm_name;

    /* FIXME: this is probably not the best place to check; I wish I
     * knew where in here's callers to really trap this bug.  To
     * reproduce the bug, just do this:
     * 
     *       mkdir junk
     *       cd junk
     *       cvs -d some_repos update foo
     *
     * Poof, CVS seg faults and dies!  It's because it's trying to
     * send a NULL string to the server but dies in send_to_server.
     * That string was supposed to be the repository, but it doesn't
     * get set because there's no CVSADM dir, and somehow it's not
     * getting set from the -d argument either... ?
     */
    if (repos == NULL)
    {
        /* Lame error.  I want a real fix but can't stay up to track
           this down right now. */
        error (1, 0, "no repository");
    }

    if (update_dir == NULL || update_dir[0] == '\0')
	update_dir = ".";

    if (last_repos != NULL
	&& strcmp (repos, last_repos) == 0
	&& last_update_dir != NULL
	&& strcmp (update_dir, last_update_dir) == 0)
	/* We've already sent it.  */
	return;

    if (client_prune_dirs)
	add_prune_candidate (update_dir);

    /* Add a directory name to the list of those sent to the
       server. */
    if (update_dir && (*update_dir != '\0')
	&& (strcmp (update_dir, ".") != 0)
	&& (findnode (dirs_sent_to_server, update_dir) == NULL))
    {
	Node *n;
	n = getnode ();
	n->type = NT_UNKNOWN;
	n->key = xstrdup (update_dir);
	n->data = NULL;

	if (addnode (dirs_sent_to_server, n))
	    error (1, 0, "cannot add directory %s to list", n->key);
    }

    /* 80 is large enough for any of CVSADM_*.  */
    adm_name = xmalloc (strlen (dir) + 80);

    send_to_server ("Directory ", 0);
    {
	/* Send the directory name.  I know that this
	   sort of duplicates code elsewhere, but each
	   case seems slightly different...  */
	char buf[1];
	char *p = update_dir;
	while (*p != '\0')
	{
	    assert (*p != '\012');
	    if (ISDIRSEP (*p))
	    {
		buf[0] = '/';
		send_to_server (buf, 1);
	    }
	    else
	    {
		buf[0] = *p;
		send_to_server (buf, 1);
	    }
	    ++p;
	}
    }
    send_to_server ("\012", 1);
    send_to_server (repos, 0);
    send_to_server ("\012", 1);

    if (supported_request ("Static-directory"))
    {
	adm_name[0] = '\0';
	if (dir[0] != '\0')
	{
	    strcat (adm_name, dir);
	    strcat (adm_name, "/");
	}
	strcat (adm_name, CVSADM_ENTSTAT);
	if (isreadable (adm_name))
	{
	    send_to_server ("Static-directory\012", 0);
	}
    }
    if (supported_request ("Sticky"))
    {
	FILE *f;
	if (dir[0] == '\0')
	    strcpy (adm_name, CVSADM_TAG);
	else
	    sprintf (adm_name, "%s/%s", dir, CVSADM_TAG);

	f = CVS_FOPEN (adm_name, "r");
	if (f == NULL)
	{
	    if (! existence_error (errno))
		error (1, errno, "reading %s", adm_name);
	}
	else
	{
	    char line[80];
	    char *nl = NULL;
	    send_to_server ("Sticky ", 0);
	    while (fgets (line, sizeof (line), f) != NULL)
	    {
		send_to_server (line, 0);
		nl = strchr (line, '\n');
		if (nl != NULL)
		    break;
	    }
	    if (nl == NULL)
                send_to_server ("\012", 1);
	    if (fclose (f) == EOF)
		error (0, errno, "closing %s", adm_name);
	}
    }
    if (supported_request ("Checkin-prog"))
    {
	FILE *f;
	if (dir[0] == '\0')
	    strcpy (adm_name, CVSADM_CIPROG);
	else
	    sprintf (adm_name, "%s/%s", dir, CVSADM_CIPROG);

	f = CVS_FOPEN (adm_name, "r");
	if (f == NULL)
	{
	    if (! existence_error (errno))
		error (1, errno, "reading %s", adm_name);
	}
	else
	{
	    char line[80];
	    char *nl = NULL;

	    send_to_server ("Checkin-prog ", 0);

	    while (fgets (line, sizeof (line), f) != NULL)
	    {
		send_to_server (line, 0);

		nl = strchr (line, '\n');
		if (nl != NULL)
		    break;
	    }
	    if (nl == NULL)
		send_to_server ("\012", 1);
	    if (fclose (f) == EOF)
		error (0, errno, "closing %s", adm_name);
	}
    }
    if (supported_request ("Update-prog"))
    {
	FILE *f;
	if (dir[0] == '\0')
	    strcpy (adm_name, CVSADM_UPROG);
	else
	    sprintf (adm_name, "%s/%s", dir, CVSADM_UPROG);

	f = CVS_FOPEN (adm_name, "r");
	if (f == NULL)
	{
	    if (! existence_error (errno))
		error (1, errno, "reading %s", adm_name);
	}
	else
	{
	    char line[80];
	    char *nl = NULL;

	    send_to_server ("Update-prog ", 0);

	    while (fgets (line, sizeof (line), f) != NULL)
	    {
		send_to_server (line, 0);

		nl = strchr (line, '\n');
		if (nl != NULL)
		    break;
	    }
	    if (nl == NULL)
		send_to_server ("\012", 1);
	    if (fclose (f) == EOF)
		error (0, errno, "closing %s", adm_name);
	}
    }
    free (adm_name);
    if (last_repos != NULL)
	free (last_repos);
    if (last_update_dir != NULL)
	free (last_update_dir);
    last_repos = xstrdup (repos);
    last_update_dir = xstrdup (update_dir);
}

/* Send a Repository line and set toplevel_repos.  */

void
send_a_repository (dir, repository, update_dir)
    char *dir;
    char *repository;
    char *update_dir;
{
    if (toplevel_repos == NULL && repository != NULL)
    {
	if (update_dir[0] == '\0'
	    || (update_dir[0] == '.' && update_dir[1] == '\0'))
	    toplevel_repos = xstrdup (repository);
	else
	{
	    /*
	     * Get the repository from a CVS/Repository file if update_dir
	     * is absolute.  This is not correct in general, because
	     * the CVS/Repository file might not be the top-level one.
	     * This is for cases like "cvs update /foo/bar" (I'm not
	     * sure it matters what toplevel_repos we get, but it does
	     * matter that we don't hit the "internal error" code below).
	     */
	    if (update_dir[0] == '/')
		toplevel_repos = Name_Repository (update_dir, update_dir);
	    else
	    {
		/*
		 * Guess the repository of that directory by looking at a
		 * subdirectory and removing as many pathname components
		 * as are in update_dir.  I think that will always (or at
		 * least almost always) be 1.
		 *
		 * So this deals with directories which have been
		 * renamed, though it doesn't necessarily deal with
		 * directories which have been put inside other
		 * directories (and cvs invoked on the containing
		 * directory).  I'm not sure the latter case needs to
		 * work.
		 *
		 * 21 Aug 1998: Well, Mr. Above-Comment-Writer, it
		 * does need to work after all.  When we are using the
		 * client in a multi-cvsroot environment, it will be
		 * fairly common that we have the above case (e.g.,
		 * cwd checked out from one repository but
		 * subdirectory checked out from another).  We can't
		 * assume that by walking up a directory in our wd we
		 * necessarily walk up a directory in the repository.
		 */
		/*
		 * This gets toplevel_repos wrong for "cvs update ../foo"
		 * but I'm not sure toplevel_repos matters in that case.
		 */

		int repository_len, update_dir_len;

		strip_trailing_slashes (update_dir);

		repository_len = strlen (repository);
		update_dir_len = strlen (update_dir);

		/* Try to remove the path components in UPDATE_DIR
                   from REPOSITORY.  If the path elements don't exist
                   in REPOSITORY, or the removal of those path
                   elements mean that we "step above"
                   current_parsed_root->directory, set toplevel_repos to
                   current_parsed_root->directory. */
		if ((repository_len > update_dir_len)
		    && (strcmp (repository + repository_len - update_dir_len,
				update_dir) == 0)
		    /* TOPLEVEL_REPOS shouldn't be above current_parsed_root->directory */
		    && ((repository_len - update_dir_len)
			> strlen (current_parsed_root->directory)))
		{
		    /* The repository name contains UPDATE_DIR.  Set
                       toplevel_repos to the repository name without
                       UPDATE_DIR. */

		    toplevel_repos = xmalloc (repository_len - update_dir_len);
		    /* Note that we don't copy the trailing '/'.  */
		    strncpy (toplevel_repos, repository,
			     repository_len - update_dir_len - 1);
		    toplevel_repos[repository_len - update_dir_len - 1] = '\0';
		}
		else
		{
		    toplevel_repos = xstrdup (current_parsed_root->directory);
		}
	    }
	}
    }

    send_repository (dir, repository, update_dir);
}

/* The "expanded" modules.  */
static int modules_count;
static int modules_allocated;
static char **modules_vector;

static void
handle_module_expansion (args, len)
    char *args;
    int len;
{
    if (modules_vector == NULL)
    {
	modules_allocated = 1; /* Small for testing */
	modules_vector = (char **) xmalloc
	  (modules_allocated * sizeof (modules_vector[0]));
    }
    else if (modules_count >= modules_allocated)
    {
	modules_allocated *= 2;
	modules_vector = (char **) xrealloc
	  ((char *) modules_vector,
	   modules_allocated * sizeof (modules_vector[0]));
    }
    modules_vector[modules_count] = xmalloc (strlen (args) + 1);
    strcpy (modules_vector[modules_count], args);
    ++modules_count;
}

/* Original, not "expanded" modules.  */
static int module_argc;
static char **module_argv;

void
client_expand_modules (argc, argv, local)
    int argc;
    char **argv;
    int local;
{
    int errs;
    int i;

    module_argc = argc;
    module_argv = (char **) xmalloc ((argc + 1) * sizeof (module_argv[0]));
    for (i = 0; i < argc; ++i)
	module_argv[i] = xstrdup (argv[i]);
    module_argv[argc] = NULL;

    for (i = 0; i < argc; ++i)
	send_arg (argv[i]);
    send_a_repository ("", current_parsed_root->directory, "");

    send_to_server ("expand-modules\012", 0);

    errs = get_server_responses ();
    if (last_repos != NULL)
        free (last_repos);
    last_repos = NULL;
    if (last_update_dir != NULL)
        free (last_update_dir);
    last_update_dir = NULL;
    if (errs)
	error (errs, 0, "cannot expand modules");
}

void
client_send_expansions (local, where, build_dirs)
    int local;
    char *where;
    int build_dirs;
{
    int i;
    char *argv[1];

    /* Send the original module names.  The "expanded" module name might
       not be suitable as an argument to a co request (e.g. it might be
       the result of a -d argument in the modules file).  It might be
       cleaner if we genuinely expanded module names, all the way to a
       local directory and repository, but that isn't the way it works
       now.  */
    send_file_names (module_argc, module_argv, 0);

    for (i = 0; i < modules_count; ++i)
    {
	argv[0] = where ? where : modules_vector[i];
	if (isfile (argv[0]))
	    send_files (1, argv, local, 0, build_dirs ? SEND_BUILD_DIRS : 0);
    }
    send_a_repository ("", current_parsed_root->directory, "");
}

void
client_nonexpanded_setup ()
{
    send_a_repository ("", current_parsed_root->directory, "");
}

/* Receive a cvswrappers line from the server; it must be a line
   containing an RCS option (e.g., "*.exe   -k 'b'").

   Note that this doesn't try to handle -t/-f options (which are a
   whole separate issue which noone has thought much about, as far
   as I know).

   We need to know the keyword expansion mode so we know whether to
   read the file in text or binary mode.  */

static void
handle_wrapper_rcs_option (args, len)
    char *args;
    int len;
{
    char *p;

    /* Enforce the notes in cvsclient.texi about how the response is not
       as free-form as it looks.  */
    p = strchr (args, ' ');
    if (p == NULL)
	goto handle_error;
    if (*++p != '-'
	|| *++p != 'k'
	|| *++p != ' '
	|| *++p != '\'')
	goto handle_error;
    if (strchr (p, '\'') == NULL)
	goto handle_error;

    /* Add server-side cvswrappers line to our wrapper list. */
    wrap_add (args, 0);
    return;
 handle_error:
    error (0, errno, "protocol error: ignoring invalid wrappers %s", args);
}


static void
handle_m (args, len)
    char *args;
    int len;
{
    /* In the case where stdout and stderr point to the same place,
       fflushing stderr will make output happen in the correct order.
       Often stderr will be line-buffered and this won't be needed,
       but not always (is that true?  I think the comment is probably
       based on being confused between default buffering between
       stdout and stderr.  But I'm not sure).  */
    fflush (stderr);
    fwrite (args, len, sizeof (*args), stdout);
    putc ('\n', stdout);
}

static void handle_mbinary PROTO ((char *, int));

static void
handle_mbinary (args, len)
    char *args;
    int len;
{
    char *size_string;
    size_t size;
    size_t totalread;
    size_t nread;
    size_t toread;
    char buf[8192];

    /* See comment at handle_m about (non)flush of stderr.  */

    /* Get the size.  */
    read_line (&size_string);
    size = atoi (size_string);
    free (size_string);

    /* OK, now get all the data.  The algorithm here is that we read
       as much as the network wants to give us in
       try_read_from_server, and then we output it all, and then
       repeat, until we get all the data.  */
    totalread = 0;
    while (totalread < size)
    {
	toread = size - totalread;
	if (toread > sizeof buf)
	    toread = sizeof buf;

	nread = try_read_from_server (buf, toread);
	cvs_output_binary (buf, nread);
	totalread += nread;
    }
}

static void
handle_e (args, len)
    char *args;
    int len;
{
    /* In the case where stdout and stderr point to the same place,
       fflushing stdout will make output happen in the correct order.  */
    fflush (stdout);
    fwrite (args, len, sizeof (*args), stderr);
    putc ('\n', stderr);
}

/*ARGSUSED*/
static void
handle_f (args, len)
    char *args;
    int len;
{
    fflush (stderr);
}

static void handle_mt PROTO ((char *, int));

static void
handle_mt (args, len)
    char *args;
    int len;
{
    char *p;
    char *tag = args;
    char *text;

    /* See comment at handle_m for more details.  */
    fflush (stderr);

    p = strchr (args, ' ');
    if (p == NULL)
	text = NULL;
    else
    {
	*p++ = '\0';
	text = p;
    }

    switch (tag[0])
    {
	case '+':
	    if (strcmp (tag, "+updated") == 0)
		updated_seen = 1;
	    else if (strcmp (tag, "+importmergecmd") == 0)
		importmergecmd.seen = 1;
	    break;
	case '-':
	    if (strcmp (tag, "-updated") == 0)
		updated_seen = 0;
	    else if (strcmp (tag, "-importmergecmd") == 0)
	    {
		char buf[80];

		/* Now that we have gathered the information, we can
                   output the suggested merge command.  */

		if (importmergecmd.conflicts == 0
		    || importmergecmd.mergetag1 == NULL
		    || importmergecmd.mergetag2 == NULL
		    || importmergecmd.repository == NULL)
		{
		    error (0, 0,
			   "invalid server: incomplete importmergecmd tags");
		    break;
		}

		sprintf (buf, "\n%d conflicts created by this import.\n",
			 importmergecmd.conflicts);
		cvs_output (buf, 0);
		cvs_output ("Use the following command to help the merge:\n\n",
			    0);
		cvs_output ("\t", 1);
		cvs_output (program_name, 0);
		if (CVSroot_cmdline != NULL)
		{
		    cvs_output (" -d ", 0);
		    cvs_output (CVSroot_cmdline, 0);
		}
		cvs_output (" checkout -j", 0);
		cvs_output (importmergecmd.mergetag1, 0);
		cvs_output (" -j", 0);
		cvs_output (importmergecmd.mergetag2, 0);
		cvs_output (" ", 1);
		cvs_output (importmergecmd.repository, 0);
		cvs_output ("\n\n", 0);

		/* Clear the static variables so that everything is
                   ready for any subsequent importmergecmd tag.  */
		importmergecmd.conflicts = 0;
		free (importmergecmd.mergetag1);
		importmergecmd.mergetag1 = NULL;
		free (importmergecmd.mergetag2);
		importmergecmd.mergetag2 = NULL;
		free (importmergecmd.repository);
		importmergecmd.repository = NULL;

		importmergecmd.seen = 0;
	    }
	    break;
	default:
	    if (updated_seen)
	    {
		if (strcmp (tag, "fname") == 0)
		{
		    if (updated_fname != NULL)
		    {
			/* Output the previous message now.  This can happen
			   if there was no Update-existing or other such
			   response, due to the -n global option.  */
			cvs_output ("U ", 0);
			cvs_output (updated_fname, 0);
			cvs_output ("\n", 1);
			free (updated_fname);
		    }
		    updated_fname = xstrdup (text);
		}
		/* Swallow all other tags.  Either they are extraneous
		   or they reflect future extensions that we can
		   safely ignore.  */
	    }
	    else if (importmergecmd.seen)
	    {
		if (strcmp (tag, "conflicts") == 0)
		    importmergecmd.conflicts = atoi (text);
		else if (strcmp (tag, "mergetag1") == 0)
		    importmergecmd.mergetag1 = xstrdup (text);
		else if (strcmp (tag, "mergetag2") == 0)
		    importmergecmd.mergetag2 = xstrdup (text);
		else if (strcmp (tag, "repository") == 0)
		    importmergecmd.repository = xstrdup (text);
		/* Swallow all other tags.  Either they are text for
                   which we are going to print our own version when we
                   see -importmergecmd, or they are future extensions
                   we can safely ignore.  */
	    }
	    else if (strcmp (tag, "newline") == 0)
		printf ("\n");
	    else if (text != NULL)
		printf ("%s", text);
    }
}

#endif /* CLIENT_SUPPORT */
#if defined(CLIENT_SUPPORT) || defined(SERVER_SUPPORT)

/* This table must be writeable if the server code is included.  */
struct response responses[] =
{
#ifdef CLIENT_SUPPORT
#define RSP_LINE(n, f, t, s) {n, f, t, s}
#else /* ! CLIENT_SUPPORT */
#define RSP_LINE(n, f, t, s) {n, s}
#endif /* CLIENT_SUPPORT */

    RSP_LINE("ok", handle_ok, response_type_ok, rs_essential),
    RSP_LINE("error", handle_error, response_type_error, rs_essential),
    RSP_LINE("Valid-requests", handle_valid_requests, response_type_normal,
       rs_essential),
    RSP_LINE("Checked-in", handle_checked_in, response_type_normal,
       rs_essential),
    RSP_LINE("New-entry", handle_new_entry, response_type_normal, rs_optional),
    RSP_LINE("Checksum", handle_checksum, response_type_normal, rs_optional),
    RSP_LINE("Copy-file", handle_copy_file, response_type_normal, rs_optional),
    RSP_LINE("Updated", handle_updated, response_type_normal, rs_essential),
    RSP_LINE("Created", handle_created, response_type_normal, rs_optional),
    RSP_LINE("Update-existing", handle_update_existing, response_type_normal,
       rs_optional),
    RSP_LINE("Merged", handle_merged, response_type_normal, rs_essential),
    RSP_LINE("Patched", handle_patched, response_type_normal, rs_optional),
    RSP_LINE("Rcs-diff", handle_rcs_diff, response_type_normal, rs_optional),
    RSP_LINE("Mode", handle_mode, response_type_normal, rs_optional),
    RSP_LINE("Mod-time", handle_mod_time, response_type_normal, rs_optional),
    RSP_LINE("Removed", handle_removed, response_type_normal, rs_essential),
    RSP_LINE("Remove-entry", handle_remove_entry, response_type_normal,
       rs_optional),
    RSP_LINE("Set-static-directory", handle_set_static_directory,
       response_type_normal,
       rs_optional),
    RSP_LINE("Clear-static-directory", handle_clear_static_directory,
       response_type_normal,
       rs_optional),
    RSP_LINE("Set-sticky", handle_set_sticky, response_type_normal,
       rs_optional),
    RSP_LINE("Clear-sticky", handle_clear_sticky, response_type_normal,
       rs_optional),
    RSP_LINE("Template", handle_template, response_type_normal,
       rs_optional),
    RSP_LINE("Set-checkin-prog", handle_set_checkin_prog, response_type_normal,
       rs_optional),
    RSP_LINE("Set-update-prog", handle_set_update_prog, response_type_normal,
       rs_optional),
    RSP_LINE("Notified", handle_notified, response_type_normal, rs_optional),
    RSP_LINE("Module-expansion", handle_module_expansion, response_type_normal,
       rs_optional),
    RSP_LINE("Wrapper-rcsOption", handle_wrapper_rcs_option,
       response_type_normal,
       rs_optional),
    RSP_LINE("M", handle_m, response_type_normal, rs_essential),
    RSP_LINE("Mbinary", handle_mbinary, response_type_normal, rs_optional),
    RSP_LINE("E", handle_e, response_type_normal, rs_essential),
    RSP_LINE("F", handle_f, response_type_normal, rs_optional),
    RSP_LINE("MT", handle_mt, response_type_normal, rs_optional),
    /* Possibly should be response_type_error.  */
    RSP_LINE(NULL, NULL, response_type_normal, rs_essential)

#undef RSP_LINE
};

#endif /* CLIENT_SUPPORT or SERVER_SUPPORT */
#ifdef CLIENT_SUPPORT

/* 
 * If LEN is 0, then send_to_server() computes string's length itself.
 *
 * Therefore, pass the real length when transmitting data that might
 * contain 0's.
 */
void
send_to_server (str, len)
     char *str;
     size_t len;
{
    static int nbytes;

    if (len == 0)
	len = strlen (str);

    buf_output (to_server, str, len);
      
    /* There is no reason not to send data to the server, so do it
       whenever we've accumulated enough information in the buffer to
       make it worth sending.  */
    nbytes += len;
    if (nbytes >= 2 * BUFFER_DATA_SIZE)
    {
	int status;

        status = buf_send_output (to_server);
	if (status != 0)
	    error (1, status, "error writing to server");
	nbytes = 0;
    }
}

/* Read up to LEN bytes from the server.  Returns actual number of
   bytes read, which will always be at least one; blocks if there is
   no data available at all.  Gives a fatal error on EOF or error.  */
static size_t
try_read_from_server (buf, len)
    char *buf;
    size_t len;
{
    int status, nread;
    char *data;

    status = buf_read_data (from_server, len, &data, &nread);
    if (status != 0)
    {
	if (status == -1)
	    error (1, 0,
		   "end of file from server (consult above messages if any)");
	else if (status == -2)
	    error (1, 0, "out of memory");
	else
	    error (1, status, "reading from server");
    }

    memcpy (buf, data, nread);

    return nread;
}

/*
 * Read LEN bytes from the server or die trying.
 */
void
read_from_server (buf, len)
    char *buf;
    size_t len;
{
    size_t red = 0;
    while (red < len)
    {
	red += try_read_from_server (buf + red, len - red);
	if (red == len)
	    break;
    }
}

/*
 * Get some server responses and process them.  Returns nonzero for
 * error, 0 for success.  */
int
get_server_responses ()
{
    struct response *rs;
    do
    {
	char *cmd;
	int len;
	
	len = read_line (&cmd);
	for (rs = responses; rs->name != NULL; ++rs)
	    if (strncmp (cmd, rs->name, strlen (rs->name)) == 0)
	    {
		int cmdlen = strlen (rs->name);
		if (cmd[cmdlen] == '\0')
		    ;
		else if (cmd[cmdlen] == ' ')
		    ++cmdlen;
		else
		    /*
		     * The first len characters match, but it's a different
		     * response.  e.g. the response is "oklahoma" but we
		     * matched "ok".
		     */
		    continue;
		(*rs->func) (cmd + cmdlen, len - cmdlen);
		break;
	    }
	if (rs->name == NULL)
	    /* It's OK to print just to the first '\0'.  */
	    /* We might want to handle control characters and the like
	       in some other way other than just sending them to stdout.
	       One common reason for this error is if people use :ext:
	       with a version of rsh which is doing CRLF translation or
	       something, and so the client gets "ok^M" instead of "ok".
	       Right now that will tend to print part of this error
	       message over the other part of it.  It seems like we could
	       do better (either in general, by quoting or omitting all
	       control characters, and/or specifically, by detecting the CRLF
	       case and printing a specific error message).  */
	    error (0, 0,
		   "warning: unrecognized response `%s' from cvs server",
		   cmd);
	free (cmd);
    } while (rs->type == response_type_normal);

    if (updated_fname != NULL)
    {
	/* Output the previous message now.  This can happen
	   if there was no Update-existing or other such
	   response, due to the -n global option.  */
	cvs_output ("U ", 0);
	cvs_output (updated_fname, 0);
	cvs_output ("\n", 1);
	free (updated_fname);
	updated_fname = NULL;
    }

    if (rs->type == response_type_error)
	return 1;
    if (failure_exit)
	return 1;
    return 0;
}

/* Get the responses and then close the connection.  */
int server_fd = -1;

/*
 * Flag var; we'll set it in start_server() and not one of its
 * callees, such as start_rsh_server().  This means that there might
 * be a small window between the starting of the server and the
 * setting of this var, but all the code in that window shouldn't care
 * because it's busy checking return values to see if the server got
 * started successfully anyway.
 */
int server_started = 0;

int
get_responses_and_close ()
{
    int errs = get_server_responses ();
    int status;

    if (last_entries != NULL)
    {
	Entries_Close (last_entries);
	last_entries = NULL;
    }

    do_deferred_progs ();

    if (client_prune_dirs)
	process_prune_candidates ();

    /* The calls to buf_shutdown are currently only meaningful when we
       are using compression.  First we shut down TO_SERVER.  That
       tells the server that its input is finished.  It then shuts
       down the buffer it is sending to us, at which point our shut
       down of FROM_SERVER will complete.  */

    status = buf_shutdown (to_server);
    if (status != 0)
        error (0, status, "shutting down buffer to server");
    status = buf_shutdown (from_server);
    if (status != 0)
	error (0, status, "shutting down buffer from server");

#ifdef NO_SOCKET_TO_FD
    if (use_socket_style)
    {
	if (shutdown (server_sock, 2) < 0)
	    error (1, 0, "shutting down server socket: %s", SOCK_STRERROR (SOCK_ERRNO));
    }
    else
#endif /* NO_SOCKET_TO_FD */
    {
#if defined(HAVE_KERBEROS) || defined(AUTH_CLIENT_SUPPORT)
	if (server_fd != -1)
	{
	    if (shutdown (server_fd, 1) < 0)
		error (1, 0, "shutting down connection to %s: %s",
		       current_parsed_root->hostname, SOCK_STRERROR (SOCK_ERRNO));
	    server_fd = -1;
            /*
             * This test will always be true because we dup the descriptor
             */
	    if (fileno (from_server_fp) != fileno (to_server_fp))
	    {
		if (fclose (to_server_fp) != 0)
		    error (1, errno,
			   "closing down connection to %s",
			   current_parsed_root->hostname);
	    }
	}
        else
#endif
          
#ifdef SHUTDOWN_SERVER
	    SHUTDOWN_SERVER (fileno (to_server_fp));
#else /* ! SHUTDOWN_SERVER */
	{

#ifdef START_RSH_WITH_POPEN_RW
	    if (pclose (to_server_fp) == EOF)
#else /* ! START_RSH_WITH_POPEN_RW */
		if (fclose (to_server_fp) == EOF)
#endif /* START_RSH_WITH_POPEN_RW */
		{
		    error (1, errno, "closing connection to %s",
			   current_parsed_root->hostname);
		}
        }

	if (! buf_empty_p (from_server)
	    || getc (from_server_fp) != EOF)
	    error (0, 0, "dying gasps from %s unexpected", current_parsed_root->hostname);
	else if (ferror (from_server_fp))
	    error (0, errno, "reading from %s", current_parsed_root->hostname);

	fclose (from_server_fp);
#endif /* SHUTDOWN_SERVER */
    }

    if (rsh_pid != -1
	&& waitpid (rsh_pid, (int *) 0, 0) == -1)
	error (1, errno, "waiting for process %d", rsh_pid);

    buf_free (to_server);
    buf_free (from_server);
    server_started = 0;

    /* see if we need to sleep before returning to avoid time-stamp races */
    if (last_register_time)
    {
	sleep_past (last_register_time);
    }

    return errs;
}
	
#ifndef NO_EXT_METHOD
static void start_rsh_server PROTO((int *, int *));
#endif

int
supported_request (name)
    char *name;
{
    struct request *rq;

    for (rq = requests; rq->name; rq++)
	if (!strcmp (rq->name, name))
	    return (rq->flags & RQ_SUPPORTED) != 0;
    error (1, 0, "internal error: testing support for unknown option?");
    /* NOTREACHED */
    return 0;
}



#if defined (AUTH_CLIENT_SUPPORT) || defined (HAVE_KERBEROS)
static struct hostent *init_sockaddr PROTO ((struct sockaddr_in *, char *,
					     unsigned int));

static struct hostent *
init_sockaddr (name, hostname, port)
    struct sockaddr_in *name;
    char *hostname;
    unsigned int port;
{
    struct hostent *hostinfo;
    unsigned short shortport = port;

    memset (name, 0, sizeof (*name));
    name->sin_family = AF_INET;
    name->sin_port = htons (shortport);
    hostinfo = gethostbyname (hostname);
    if (hostinfo == NULL)
    {
	fprintf (stderr, "Unknown host %s.\n", hostname);
	error_exit ();
    }
    name->sin_addr = *(struct in_addr *) hostinfo->h_addr;
    return hostinfo;
}

#endif /* defined (AUTH_CLIENT_SUPPORT) || defined (HAVE_KERBEROS) */



#ifdef AUTH_CLIENT_SUPPORT

/* Generic function to do port number lookup tasks.
 *
 * In order of precedence, will return:
 * 	getenv (envname), if defined
 * 	getservbyname (portname), if defined
 * 	defaultport
 */
static int
get_port_number (envname, portname, defaultport)
    const char *envname;
    const char *portname;
    int defaultport;
{
    struct servent *s;
    char *port_s;

    if (envname && (port_s = getenv (envname)))
    {
	int port = atoi (port_s);
	if (port <= 0)
	{
	    error (0, 0, "%s must be a positive integer!  If you", envname);
	    error (0, 0, "are trying to force a connection via ssh, please");
	    error (0, 0, "put \":server:\" at the beginning of your CVSROOT");
	    error (1, 0, "variable.");
	}
	return port;
    }
    else if (portname && (s = getservbyname (portname, "tcp")))
	return ntohs (s->s_port);
    else
	return defaultport;
}



/* get the port number for a client to connect to based on the port
 * and method of a cvsroot_t.
 *
 * we do this here instead of in parse_cvsroot so that we can keep network
 * code confined to a localized area and also to delay the lookup until the
 * last possible moment so it remains possible to run cvs client commands that
 * skip opening connections to the server (i.e. skip network operations entirely)
 *
 * and yes, I know none of the the commands do that now, but here's to planning
 * for the future, eh?  cheers.
 *
 * FIXME - We could cache the port lookup safely right now as we never change
 * it for a single root on the fly, but we'd have to un'const some other
 * functions
 */
int
get_cvs_port_number (root)
    const cvsroot_t *root;
{

    if (root->port) return root->port;

    switch (root->method)
    {
	case gserver_method:
	case pserver_method:
	    return get_port_number ("CVS_CLIENT_PORT", "cvspserver", CVS_AUTH_PORT);
#ifdef HAVE_KERBEROS
	case kserver_method:
	    return get_port_number ("CVS_CLIENT_PORT", "cvs", CVS_PORT);
#endif
	default:
	    error(1, EINVAL, "internal error: get_cvs_port_number called for invalid connection method (%s)",
		    method_names[root->method]);
	    break;
    }
}



/* Read a line from socket SOCK.  Result does not include the
   terminating linefeed.  This is only used by the authentication
   protocol, which we call before we set up all the buffering stuff.
   It is possible it should use the buffers too, which would be faster
   (unlike the server, there isn't really a security issue in terms of
   separating authentication from the rest of the code).

   Space for the result is malloc'd and should be freed by the caller.

   Returns number of bytes read.  */
static int
recv_line (sock, resultp)
    int sock;
    char **resultp;
{
    char *result;
    size_t input_index = 0;
    size_t result_size = 80;

    result = (char *) xmalloc (result_size);

    while (1)
    {
	char ch;
	int n;
	n = recv (sock, &ch, 1, 0);
	if (n <= 0)
	    error (1, 0, "recv() from server %s: %s", current_parsed_root->hostname,
		   n == 0 ? "EOF" : SOCK_STRERROR (SOCK_ERRNO));

	if (ch == '\012')
	    break;

	result[input_index++] = ch;
	while (input_index + 1 >= result_size)
	{
	    result_size *= 2;
	    result = (char *) xrealloc (result, result_size);
	}
    }

    if (resultp)
	*resultp = result;

    /* Terminate it just for kicks, but we *can* deal with embedded NULs.  */
    result[input_index] = '\0';

    if (resultp == NULL)
	free (result);
    return input_index;
}

/* Connect to a forked server process. */

void
connect_to_forked_server (tofdp, fromfdp)
     int *tofdp, *fromfdp;
{
    /* This is pretty simple.  All we need to do is choose the correct
       cvs binary and call piped_child. */

    char *command[3];

    command[0] = getenv ("CVS_SERVER");
    if (! command[0])
	command[0] = program_path;
    
    command[1] = "server";
    command[2] = NULL;

    if (trace)
    {
	fprintf (stderr, " -> Forking server: %s %s\n", command[0], command[1]);
    }
    if (! piped_child (command, tofdp, fromfdp))
	error (1, 0, "could not fork server process");
}

/* Connect to the authenticating server.

   If VERIFY_ONLY is non-zero, then just verify that the password is
   correct and then shutdown the connection.

   If VERIFY_ONLY is 0, then really connect to the server.

   If DO_GSSAPI is non-zero, then we use GSSAPI authentication rather
   than the pserver password authentication.

   If we fail to connect or if access is denied, then die with fatal
   error.  */
void
connect_to_pserver (tofdp, fromfdp, verify_only, do_gssapi)
     int *tofdp, *fromfdp;
     int verify_only;
     int do_gssapi;
{
    int sock;
#ifndef NO_SOCKET_TO_FD
    int tofd, fromfd;
#endif
    int port_number;
    char *username;			/* the username we use to connect */
    struct addrinfo hints, *res, *res0 = NULL;
    char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
    char no_passwd = 0;			/* gets set if no password found */
    int e;

    memset(&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_CANONNAME;
    port_number = get_cvs_port_number (current_parsed_root);
    snprintf(sbuf, sizeof(sbuf), "%d", port_number);
    e = getaddrinfo(current_parsed_root->hostname, sbuf, &hints, &res0);
    if (e)
    {
	error (1, 0, "%s", gai_strerror(e));
    }
    sock = -1;
    for (res = res0; res; res = res->ai_next)
    {
	sock = socket (res->ai_family, res->ai_socktype, res->ai_protocol);
	if (sock < 0)
	{
	    continue;
	}

	if (trace)
	{
	    getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, sizeof(hbuf),
		sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);
	    fprintf (stderr, " -> Connecting to %s(%s):%s\n",
		     current_parsed_root->hostname, hbuf, sbuf);
	}
	if (connect(sock, res->ai_addr, res->ai_addrlen) < 0)
	{
	    close(sock);
	    sock = -1;
	    continue;
	}
	break;
    }
    if (sock < 0)
    {
	getnameinfo(res0->ai_addr, res0->ai_addrlen, hbuf, sizeof(hbuf),
	    sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);
	error (1, 0, "connect to %s(%s):%s failed: %s",
	       current_parsed_root->hostname, hbuf, sbuf,
	       SOCK_STRERROR (SOCK_ERRNO));
    }

    /* Run the authorization mini-protocol before anything else. */
    if (do_gssapi)
    {
#ifdef HAVE_GSSAPI
	if (! connect_to_gserver (sock, res0->ai_canonname ?
	    res0->ai_canonname : current_parsed_root->hostname))
	{
	    error (0, 0,
		    "authorization failed: server %s rejected access to %s",
		    current_parsed_root->hostname, current_parsed_root->directory);
	    goto rejected;
	}
#else
	error (1, 0, "This client does not support GSSAPI authentication");
#endif
    }
    else
    {
	char *begin      = NULL;
	char *password   = NULL;
	char *end        = NULL;
	
	if (verify_only)
	{
	    begin = "BEGIN VERIFICATION REQUEST\012";
	    end   = "END VERIFICATION REQUEST\012";
	}
	else
	{
	    begin = "BEGIN AUTH REQUEST\012";
	    end   = "END AUTH REQUEST\012";
	}

	/* Get the password, probably from ~/.cvspass. */
	password = get_cvs_password ();
        username = current_parsed_root->username ? current_parsed_root->username : getcaller();

        /* Send the empty string by default.  This is so anonymous CVS
           access doesn't require client to have done "cvs login". */
        if (password == NULL) 
        {
            no_passwd = 1;
            password = scramble ("");
        }

	/* Announce that we're starting the authorization protocol. */
	if (send (sock, begin, strlen (begin), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));

	/* Send the data the server needs. */
	if (send (sock, current_parsed_root->directory, strlen (current_parsed_root->directory), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, "\012", 1, 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, username, strlen (username), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, "\012", 1, 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, password, strlen (password), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, "\012", 1, 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));

	/* Announce that we're ending the authorization protocol. */
	if (send (sock, end, strlen (end), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));

        /* Paranoia. */
        memset (password, 0, strlen (password));
    }

    {
	char *read_buf;

	/* Loop, getting responses from the server.  */
	while (1)
	{
	    recv_line (sock, &read_buf);

	    if (strcmp (read_buf, "I HATE YOU") == 0)
	    {
		/* Authorization not granted.
		 *
		 * This is a little confusing since we can reach this while loop in GSSAPI
		 * mode, but if GSSAPI authentication failed, we already jumped to the
		 * rejected label (there is no case where the connect_to_gserver function
		 * can return 1 and we will not receive "I LOVE YOU" from the server, barring
		 * broken connections and garbled messages, of course).
		 *
		 * i.e. This is a pserver specific error message and shoiuld be since
		 * GSSAPI doesn't use username.
		 */
		error (0, 0,
			"authorization failed: server %s rejected access to %s for user %s",
			current_parsed_root->hostname, current_parsed_root->directory, username);

		/* Output a special error message if authentication was attempted
		with no password -- the user should be made aware that they may
		have missed a step. */
		if (no_passwd)
		{
		    error (0, 0,
			    "used empty password; try \"cvs login\" with a real password");
		}
		goto rejected;
	    }
	    else if (strncmp (read_buf, "E ", 2) == 0)
	    {
		fprintf (stderr, "%s\n", read_buf + 2);

		/* Continue with the authentication protocol.  */
	    }
	    else if (strncmp (read_buf, "error ", 6) == 0)
	    {
		char *p;

		/* First skip the code.  */
		p = read_buf + 6;
		while (*p != ' ' && *p != '\0')
		    ++p;

		/* Skip the space that follows the code.  */
		if (*p == ' ')
		    ++p;

		/* Now output the text.  */
		fprintf (stderr, "%s\n", p);
		goto rejected;
	    }
	    else if (strcmp (read_buf, "I LOVE YOU") == 0)
	    {
		free (read_buf);
		break;
	    }
	    else
	    {
		/* Unrecognized response from server. */
		if (shutdown (sock, 2) < 0)
		{
		    error (0, 0,
			   "unrecognized auth response from %s: %s", 
			   current_parsed_root->hostname, read_buf);
		    error (1, 0,
			   "shutdown() failed, server %s: %s",
			   current_parsed_root->hostname,
			   SOCK_STRERROR (SOCK_ERRNO));
		}
		error (1, 0, 
		       "unrecognized auth response from %s: %s", 
		       current_parsed_root->hostname, read_buf);
	    }
	    free (read_buf);
	}
    }

    if (verify_only)
    {
	if (shutdown (sock, 2) < 0)
	    error (0, 0, "shutdown() failed, server %s: %s", current_parsed_root->hostname,
		   SOCK_STRERROR (SOCK_ERRNO));
	if (res0)
	    freeaddrinfo(res0);
	return;
    }
    else
    {
#ifdef NO_SOCKET_TO_FD
	use_socket_style = 1;
	server_sock = sock;
	/* Try to break mistaken callers: */
	*tofdp = 0;
	*fromfdp = 0;
#else /* ! NO_SOCKET_TO_FD */
	server_fd = sock;
	close_on_exec (server_fd);
	tofd = fromfd = sock;
	/* Hand them back to the caller. */
	*tofdp   = tofd;
	*fromfdp = fromfd;
#endif /* NO_SOCKET_TO_FD */
    }

    if (res0)
	freeaddrinfo(res0);
    return;

  rejected:
    if (shutdown (sock, 2) < 0)
    {
	error (0, 0,
	       "shutdown() failed (server %s): %s",
	       current_parsed_root->hostname,
	       SOCK_STRERROR (SOCK_ERRNO));
    }

    error_exit();
}
#endif /* AUTH_CLIENT_SUPPORT */



#ifdef HAVE_KERBEROS

/* This function has not been changed to deal with NO_SOCKET_TO_FD
   (i.e., systems on which sockets cannot be converted to file
   descriptors).  The first person to try building a kerberos client
   on such a system (OS/2, Windows 95, and maybe others) will have to
   make take care of this.  */
void
start_tcp_server (tofdp, fromfdp)
    int *tofdp, *fromfdp;
{
    int s;
    const char *portenv;
    int port;
    struct hostent *hp;
    struct sockaddr_in client_sai;
    char *hname;

    s = socket (AF_INET, SOCK_STREAM, 0);
    if (s < 0)
	error (1, 0, "cannot create socket: %s", SOCK_STRERROR (SOCK_ERRNO));

    port = get_cvs_port_number (current_parsed_root);

    hp = init_sockaddr (&client_sai, current_parsed_root->hostname, port);

    hname = xmalloc (strlen (hp->h_name) + 1);
    strcpy (hname, hp->h_name);
  
    if (trace)
    {
	fprintf (stderr, " -> Connecting to %s(%s):%d\n",
		 current_parsed_root->hostname,
		 inet_ntoa (client_sai.sin_addr), port);
    }

    if (connect (s, (struct sockaddr *) &client_sai, sizeof client_sai) < 0)
	error (1, 0, "connect to %s(%s):%d failed: %s",
	       current_parsed_root->hostname,
	       inet_ntoa (client_sai.sin_addr),
	       port, SOCK_STRERROR (SOCK_ERRNO));

    {
	const char *realm;
	struct sockaddr_in laddr;
	int laddrlen;
	KTEXT_ST ticket;
	MSG_DAT msg_data;
	CREDENTIALS cred;
	int status;

	realm = krb_realmofhost (hname);

	laddrlen = sizeof (laddr);
	if (getsockname (s, (struct sockaddr *) &laddr, &laddrlen) < 0)
	    error (1, 0, "getsockname failed: %s", SOCK_STRERROR (SOCK_ERRNO));

	/* We don't care about the checksum, and pass it as zero.  */
	status = krb_sendauth (KOPT_DO_MUTUAL, s, &ticket, "rcmd",
			       hname, realm, (unsigned long) 0, &msg_data,
			       &cred, sched, &laddr, &client_sai, "KCVSV1.0");
	if (status != KSUCCESS)
	    error (1, 0, "kerberos authentication failed: %s",
		   krb_get_err_text (status));
	memcpy (kblock, cred.session, sizeof (C_Block));
    }

    server_fd = s;
    close_on_exec (server_fd);

    free (hname);

    /* Give caller the values it wants. */
    *tofdp   = s;
    *fromfdp = s;
}

#endif /* HAVE_KERBEROS */

#ifdef HAVE_GSSAPI

/* Receive a given number of bytes.  */

static void
recv_bytes (sock, buf, need)
     int sock;
     char *buf;
     int need;
{
    while (need > 0)
    {
	int got;

	got = recv (sock, buf, need, 0);
	if (got <= 0)
	    error (1, 0, "recv() from server %s: %s", current_parsed_root->hostname,
		   got == 0 ? "EOF" : SOCK_STRERROR (SOCK_ERRNO));

	buf += got;
	need -= got;
    }
}

/* Connect to the server using GSSAPI authentication.  */

static int
connect_to_gserver (sock, hostname)
     int sock;
     const char *hostname;
{
    char *str;
    char buf[1024];
    gss_buffer_desc *tok_in_ptr, tok_in, tok_out;
    OM_uint32 stat_min, stat_maj;
    gss_name_t server_name;

    str = "BEGIN GSSAPI REQUEST\012";

    if (send (sock, str, strlen (str), 0) < 0)
	error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));

    sprintf (buf, "cvs@@%s", hostname);
    tok_in.length = strlen (buf);
    tok_in.value = buf;
    gss_import_name (&stat_min, &tok_in, GSS_C_NT_HOSTBASED_SERVICE,
		     &server_name);

    tok_in_ptr = GSS_C_NO_BUFFER;
    gcontext = GSS_C_NO_CONTEXT;

    do
    {
	stat_maj = gss_init_sec_context (&stat_min, GSS_C_NO_CREDENTIAL,
					 &gcontext, server_name,
					 GSS_C_NULL_OID,
					 (GSS_C_MUTUAL_FLAG
					  | GSS_C_REPLAY_FLAG),
					 0, NULL, tok_in_ptr, NULL, &tok_out,
					 NULL, NULL);
	if (stat_maj != GSS_S_COMPLETE && stat_maj != GSS_S_CONTINUE_NEEDED)
	{
	    OM_uint32 message_context;
	    OM_uint32 new_stat_min;

	    message_context = 0;
	    gss_display_status (&new_stat_min, stat_maj, GSS_C_GSS_CODE,
                                GSS_C_NULL_OID, &message_context, &tok_out);
	    error (0, 0, "GSSAPI authentication failed: %s",
		   (char *) tok_out.value);

	    message_context = 0;
	    gss_display_status (&new_stat_min, stat_min, GSS_C_MECH_CODE,
				GSS_C_NULL_OID, &message_context, &tok_out);
	    error (1, 0, "GSSAPI authentication failed: %s",
		   (char *) tok_out.value);
	}

	if (tok_out.length == 0)
	{
	    tok_in.length = 0;
	}
	else
	{
	    char cbuf[2];
	    int need;

	    cbuf[0] = (tok_out.length >> 8) & 0xff;
	    cbuf[1] = tok_out.length & 0xff;
	    if (send (sock, cbuf, 2, 0) < 0)
		error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	    if (send (sock, tok_out.value, tok_out.length, 0) < 0)
		error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));

	    recv_bytes (sock, cbuf, 2);
	    need = ((cbuf[0] & 0xff) << 8) | (cbuf[1] & 0xff);

	    if (need > sizeof buf)
	    {
		int got;

		/* This usually means that the server sent us an error
		   message.  Read it byte by byte and print it out.
		   FIXME: This is a terrible error handling strategy.
		   However, even if we fix the server, we will still
		   want to do this to work with older servers.  */
		buf[0] = cbuf[0];
		buf[1] = cbuf[1];
		got = recv (sock, buf + 2, sizeof buf - 2, 0);
		if (got < 0)
		    error (1, 0, "recv() from server %s: %s",
			   current_parsed_root->hostname, SOCK_STRERROR (SOCK_ERRNO));
		buf[got + 2] = '\0';
		if (buf[got + 1] == '\n')
		    buf[got + 1] = '\0';
		error (1, 0, "error from server %s: %s", current_parsed_root->hostname,
		       buf);
	    }

	    recv_bytes (sock, buf, need);
	    tok_in.length = need;
	}

	tok_in.value = buf;
	tok_in_ptr = &tok_in;
    }
    while (stat_maj == GSS_S_CONTINUE_NEEDED);

    return 1;
}

#endif /* HAVE_GSSAPI */

static int send_variable_proc PROTO ((Node *, void *));

static int
send_variable_proc (node, closure)
    Node *node;
    void *closure;
{
    send_to_server ("Set ", 0);
    send_to_server (node->key, 0);
    send_to_server ("=", 1);
    send_to_server (node->data, 0);
    send_to_server ("\012", 1);
    return 0;
}

/* Contact the server.  */
void
start_server ()
{
    int tofd, fromfd, rootless;
    char *log = getenv ("CVS_CLIENT_LOG");


    /* Clear our static variables for this invocation. */
    if (toplevel_repos != NULL)
	free (toplevel_repos);
    toplevel_repos = NULL;


    /* Note that generally speaking we do *not* fall back to a different
       way of connecting if the first one does not work.  This is slow
       (*really* slow on a 14.4kbps link); the clean way to have a CVS
       which supports several ways of connecting is with access methods.  */

    switch (current_parsed_root->method)
    {

#ifdef AUTH_CLIENT_SUPPORT
	case pserver_method:
	    /* Toss the return value.  It will die with error if anything
	       goes wrong anyway. */
	    connect_to_pserver (&tofd, &fromfd, 0, 0);
	    break;
#endif

#if HAVE_KERBEROS
	case kserver_method:
	    start_tcp_server (&tofd, &fromfd);
	    break;
#endif

#ifdef HAVE_GSSAPI
	case gserver_method:
	    /* GSSAPI authentication is handled by the pserver.  */
	    connect_to_pserver (&tofd, &fromfd, 0, 1);
	    break;
#endif

	case ext_method:
#if defined (NO_EXT_METHOD)
	    error (0, 0, ":ext: method not supported by this port of CVS");
	    error (1, 0, "try :server: instead");
#else
	    start_rsh_server (&tofd, &fromfd);
#endif
	    break;

	case server_method:
#if defined(START_SERVER)
	    START_SERVER (&tofd, &fromfd, getcaller (),
			  current_parsed_root->username, current_parsed_root->hostname,
			  current_parsed_root->directory);
#  if defined (START_SERVER_RETURNS_SOCKET) && defined (NO_SOCKET_TO_FD)
	    /* This is a system on which we can only write to a socket
	       using send/recv.  Therefore its START_SERVER needs to
	       return a socket.  */
	    use_socket_style = 1;
	    server_sock = tofd;
#  endif

#else
	    /* FIXME: It should be possible to implement this portably,
	       like pserver, which would get rid of the duplicated code
	       in {vms,windows-NT,...}/startserver.c.  */
	    error (1, 0, "\
the :server: access method is not supported by this port of CVS");
#endif
	    break;

        case fork_method:
	    connect_to_forked_server (&tofd, &fromfd);
	    break;

	default:
	    error (1, 0, "\
(start_server internal error): unknown access method");
	    break;
    }

    /* "Hi, I'm Darlene and I'll be your server tonight..." */
    server_started = 1;

#ifdef NO_SOCKET_TO_FD
    if (use_socket_style)
    {
	to_server = socket_buffer_initialize (server_sock, 0,
					      (BUFMEMERRPROC) NULL);
	from_server = socket_buffer_initialize (server_sock, 1,
						(BUFMEMERRPROC) NULL);
    }
    else
#endif /* NO_SOCKET_TO_FD */
    {
        /* todo: some OS's don't need these calls... */
        close_on_exec (tofd);
        close_on_exec (fromfd);

	/* SCO 3 and AIX have a nasty bug in the I/O libraries which precludes
	   fdopening the same file descriptor twice, so dup it if it is the
	   same.  */
	if (tofd == fromfd)
	{
	    fromfd = dup (tofd);
	    if (fromfd < 0)
		error (1, errno, "cannot dup net connection");
	}

        /* These will use binary mode on systems which have it.  */
        to_server_fp = fdopen (tofd, FOPEN_BINARY_WRITE);
        if (to_server_fp == NULL)
	    error (1, errno, "cannot fdopen %d for write", tofd);
	to_server = stdio_buffer_initialize (to_server_fp, 0,
					     (BUFMEMERRPROC) NULL);

        from_server_fp = fdopen (fromfd, FOPEN_BINARY_READ);
        if (from_server_fp == NULL)
	    error (1, errno, "cannot fdopen %d for read", fromfd);
	from_server = stdio_buffer_initialize (from_server_fp, 1,
					       (BUFMEMERRPROC) NULL);
    }

    /* Set up logfiles, if any. */
    if (log)
    {
	int len = strlen (log);
	char *buf = xmalloc (len + 5);
	char *p;
	FILE *fp;

	strcpy (buf, log);
	p = buf + len;

	/* Open logfiles in binary mode so that they reflect
	   exactly what was transmitted and received (that is
	   more important than that they be maximally
	   convenient to view).  */
	/* Note that if we create several connections in a single CVS client
	   (currently used by update.c), then the last set of logfiles will
	   overwrite the others.  There is currently no way around this.  */
	strcpy (p, ".in");
	fp = open_file (buf, "wb");
        if (fp == NULL)
	    error (0, errno, "opening to-server logfile %s", buf);
	else
	    to_server = log_buffer_initialize (to_server, fp, 0,
					       (BUFMEMERRPROC) NULL);

	strcpy (p, ".out");
	fp = open_file (buf, "wb");
        if (fp == NULL)
	    error (0, errno, "opening from-server logfile %s", buf);
	else
	    from_server = log_buffer_initialize (from_server, fp, 1,
						 (BUFMEMERRPROC) NULL);

	free (buf);
    }

    /* Clear static variables.  */
    if (toplevel_repos != NULL)
	free (toplevel_repos);
    toplevel_repos = NULL;
    if (last_dir_name != NULL)
	free (last_dir_name);
    last_dir_name = NULL;
    if (last_repos != NULL)
	free (last_repos);
    last_repos = NULL;
    if (last_update_dir != NULL)
	free (last_update_dir);
    last_update_dir = NULL;
    stored_checksum_valid = 0;
    if (stored_mode != NULL)
    {
	free (stored_mode);
	stored_mode = NULL;
    }

    rootless = (strcmp (command_name, "init") == 0);
    if (!rootless)
    {
	send_to_server ("Root ", 0);
	send_to_server (current_parsed_root->directory, 0);
	send_to_server ("\012", 1);
    }

    {
	struct response *rs;

	send_to_server ("Valid-responses", 0);

	for (rs = responses; rs->name != NULL; ++rs)
	{
	    send_to_server (" ", 0);
	    send_to_server (rs->name, 0);
	}
	send_to_server ("\012", 1);
    }
    send_to_server ("valid-requests\012", 0);

    if (get_server_responses ())
	error_exit ();

    /*
     * Now handle global options.
     *
     * -H, -f, -d, -e should be handled OK locally.
     *
     * -b we ignore (treating it as a server installation issue).
     * FIXME: should be an error message.
     *
     * -v we print local version info; FIXME: Add a protocol request to get
     * the version from the server so we can print that too.
     *
     * -l -t -r -w -q -n and -Q need to go to the server.
     */

    {
	int have_global = supported_request ("Global_option");

	if (noexec)
	{
	    if (have_global)
	    {
		send_to_server ("Global_option -n\012", 0);
	    }
	    else
		error (1, 0,
		       "This server does not support the global -n option.");
	}
	if (quiet)
	{
	    if (have_global)
	    {
		send_to_server ("Global_option -q\012", 0);
	    }
	    else
		error (1, 0,
		       "This server does not support the global -q option.");
	}
	if (really_quiet)
	{
	    if (have_global)
	    {
		send_to_server ("Global_option -Q\012", 0);
	    }
	    else
		error (1, 0,
		       "This server does not support the global -Q option.");
	}
	if (!cvswrite)
	{
	    if (have_global)
	    {
		send_to_server ("Global_option -r\012", 0);
	    }
	    else
		error (1, 0,
		       "This server does not support the global -r option.");
	}
	if (trace)
	{
	    if (have_global)
	    {
		send_to_server ("Global_option -t\012", 0);
	    }
	    else
		error (1, 0,
		       "This server does not support the global -t option.");
	}
	if (logoff)
	{
	    if (have_global)
	    {
		send_to_server ("Global_option -l\012", 0);
	    }
	    else
		error (1, 0,
		       "This server does not support the global -l option.");
	}
    }

    /* Find out about server-side cvswrappers.  An extra network
       turnaround for cvs import seems to be unavoidable, unless we
       want to add some kind of client-side place to configure which
       filenames imply binary.  For cvs add, we could avoid the
       problem by keeping a copy of the wrappers in CVSADM (the main
       reason to bother would be so we could make add work without
       contacting the server, I suspect).  */

    if ((strcmp (command_name, "import") == 0)
        || (strcmp (command_name, "add") == 0))
    {
	if (supported_request ("wrapper-sendme-rcsOptions"))
	{
	    int err;
	    send_to_server ("wrapper-sendme-rcsOptions\012", 0);
	    err = get_server_responses ();
	    if (err != 0)
		error (err, 0, "error reading from server");
	}
    }

    if (cvsencrypt && !rootless)
    {
#ifdef ENCRYPTION
	/* Turn on encryption before turning on compression.  We do
           not want to try to compress the encrypted stream.  Instead,
           we want to encrypt the compressed stream.  If we can't turn
           on encryption, bomb out; don't let the user think the data
           is being encrypted when it is not.  */
#ifdef HAVE_KERBEROS
	if (current_parsed_root->method == kserver_method)
	{
	    if (! supported_request ("Kerberos-encrypt"))
		error (1, 0, "This server does not support encryption");
	    send_to_server ("Kerberos-encrypt\012", 0);
	    to_server = krb_encrypt_buffer_initialize (to_server, 0, sched,
						       kblock,
						       (BUFMEMERRPROC) NULL);
	    from_server = krb_encrypt_buffer_initialize (from_server, 1,
							 sched, kblock,
							 (BUFMEMERRPROC) NULL);
	}
	else
#endif /* HAVE_KERBEROS */
#ifdef HAVE_GSSAPI
	if (current_parsed_root->method == gserver_method)
	{
	    if (! supported_request ("Gssapi-encrypt"))
		error (1, 0, "This server does not support encryption");
	    send_to_server ("Gssapi-encrypt\012", 0);
	    to_server = cvs_gssapi_wrap_buffer_initialize (to_server, 0,
							   gcontext,
							   ((BUFMEMERRPROC)
							    NULL));
	    from_server = cvs_gssapi_wrap_buffer_initialize (from_server, 1,
							     gcontext,
							     ((BUFMEMERRPROC)
							      NULL));
	    cvs_gssapi_encrypt = 1;
	}
	else
#endif /* HAVE_GSSAPI */
	    error (1, 0, "Encryption is only supported when using GSSAPI or Kerberos");
#else /* ! ENCRYPTION */
	error (1, 0, "This client does not support encryption");
#endif /* ! ENCRYPTION */
    }

    if (gzip_level && !rootless)
    {
	if (supported_request ("Gzip-stream"))
	{
	    char gzip_level_buf[5];
	    send_to_server ("Gzip-stream ", 0);
	    sprintf (gzip_level_buf, "%d", gzip_level);
	    send_to_server (gzip_level_buf, 0);
	    send_to_server ("\012", 1);

	    /* All further communication with the server will be
               compressed.  */

	    to_server = compress_buffer_initialize (to_server, 0, gzip_level,
						    (BUFMEMERRPROC) NULL);
	    from_server = compress_buffer_initialize (from_server, 1,
						      gzip_level,
						      (BUFMEMERRPROC) NULL);
	}
#ifndef NO_CLIENT_GZIP_PROCESS
	else if (supported_request ("gzip-file-contents"))
	{
            char gzip_level_buf[5];
	    send_to_server ("gzip-file-contents ", 0);
            sprintf (gzip_level_buf, "%d", gzip_level);
	    send_to_server (gzip_level_buf, 0);

	    send_to_server ("\012", 1);

	    file_gzip_level = gzip_level;
	}
#endif
	else
	{
	    fprintf (stderr, "server doesn't support gzip-file-contents\n");
	    /* Setting gzip_level to 0 prevents us from giving the
               error twice if update has to contact the server again
               to fetch unpatchable files.  */
	    gzip_level = 0;
	}
    }

    if (cvsauthenticate && ! cvsencrypt && !rootless)
    {
	/* Turn on authentication after turning on compression, so
	   that we can compress the authentication information.  We
	   assume that encrypted data is always authenticated--the
	   ability to decrypt the data stream is itself a form of
	   authentication.  */
#ifdef HAVE_GSSAPI
	if (current_parsed_root->method == gserver_method)
	{
	    if (! supported_request ("Gssapi-authenticate"))
		error (1, 0,
		       "This server does not support stream authentication");
	    send_to_server ("Gssapi-authenticate\012", 0);
	    to_server = cvs_gssapi_wrap_buffer_initialize (to_server, 0,
							   gcontext,
							   ((BUFMEMERRPROC)
							    NULL));
	    from_server = cvs_gssapi_wrap_buffer_initialize (from_server, 1,
							     gcontext,
							     ((BUFMEMERRPROC)
							      NULL));
	}
	else
	    error (1, 0, "Stream authentication is only supported when using GSSAPI");
#else /* ! HAVE_GSSAPI */
	error (1, 0, "This client does not support stream authentication");
#endif /* ! HAVE_GSSAPI */
    }

#ifdef FILENAMES_CASE_INSENSITIVE
    if (supported_request ("Case") && !rootless)
	send_to_server ("Case\012", 0);
#endif

    /* If "Set" is not supported, just silently fail to send the variables.
       Users with an old server should get a useful error message when it
       fails to recognize the ${=foo} syntax.  This way if someone uses
       several servers, some of which are new and some old, they can still
       set user variables in their .cvsrc without trouble.  */
    if (supported_request ("Set"))
	walklist (variable_list, send_variable_proc, NULL);
}

#ifndef NO_EXT_METHOD

/* Contact the server by starting it with rsh.  */

/* Right now, we have two different definitions for this function,
   depending on whether we start the rsh server using popenRW or not.
   This isn't ideal, and the best thing would probably be to change
   the OS/2 port to be more like the regular Unix client (i.e., by
   implementing piped_child)... but I'm doing something else at the
   moment, and wish to make only one change at a time.  -Karl */

#ifdef START_RSH_WITH_POPEN_RW

/* This is actually a crock -- it's OS/2-specific, for no one else
   uses it.  If I get time, I want to make piped_child and all the
   other stuff in os2/run.c work right.  In the meantime, this gets us
   up and running, and that's most important. */

static void
start_rsh_server (tofdp, fromfdp)
    int *tofdp, *fromfdp;
{
    int pipes[2];

    /* If you're working through firewalls, you can set the
       CVS_RSH environment variable to a script which uses rsh to
       invoke another rsh on a proxy machine.  */
    char *cvs_rsh = getenv ("CVS_RSH");
    char *cvs_server = getenv ("CVS_SERVER");
    int i = 0;
    /* This needs to fit "rsh", "-b", "-l", "USER", "--", "host",
       "cmd (w/ args)", and NULL.  We leave some room to grow. */
    char *rsh_argv[10];

    if (!cvs_rsh)
	/* People sometimes suggest or assume that this should default
	   to "remsh" on systems like HPUX in which that is the
	   system-supplied name for the rsh program.  However, that
	   causes various problems (keep in mind that systems such as
	   HPUX might have non-system-supplied versions of "rsh", like
	   a Kerberized one, which one might want to use).  If we
	   based the name on what is found in the PATH of the person
	   who runs configure, that would make it harder to
	   consistently produce the same result in the face of
	   different people producing binary distributions.  If we
	   based it on "remsh" always being the default for HPUX
	   (e.g. based on uname), that might be slightly better but
	   would require us to keep track of what the defaults are for
	   each system type, and probably would cope poorly if the
	   existence of remsh or rsh varies from OS version to OS
	   version.  Therefore, it seems best to have the default
	   remain "rsh", and tell HPUX users to specify remsh, for
	   example in CVS_RSH or other such mechanisms to be devised,
	   if that is what they want (the manual already tells them
	   that).
	   Nowadays, however, ssh is pretty much everywhere, so we start
	   to default to ssh instead.
        */
	cvs_rsh = "ssh";
    if (!cvs_server)
	cvs_server = "cvs";

    /* The command line starts out with rsh. */
    rsh_argv[i++] = cvs_rsh;

#ifdef RSH_NEEDS_BINARY_FLAG
    /* "-b" for binary, under OS/2. */
    rsh_argv[i++] = "-b";
#endif /* RSH_NEEDS_BINARY_FLAG */

    /* Then we strcat more things on the end one by one. */
    if (current_parsed_root->username != NULL)
    {
	rsh_argv[i++] = "-l";
	rsh_argv[i++] = current_parsed_root->username;
    }

    rsh_argv[i++] = "--";
    rsh_argv[i++] = current_parsed_root->hostname;
    rsh_argv[i++] = cvs_server;
    rsh_argv[i++] = "server";

    /* Mark the end of the arg list. */
    rsh_argv[i]   = (char *) NULL;

    if (trace)
    {
	fprintf (stderr, " -> Starting server: ");
	for (i = 0; rsh_argv[i]; i++)
	    fprintf (stderr, "%s ", rsh_argv[i]);
	putc ('\n', stderr);
    }

    /* Do the deed. */
    rsh_pid = popenRW (rsh_argv, pipes);
    if (rsh_pid < 0)
	error (1, errno, "cannot start server via ssh");

    /* Give caller the file descriptors. */
    *tofdp   = pipes[0];
    *fromfdp = pipes[1];
}

#else /* ! START_RSH_WITH_POPEN_RW */

static void
start_rsh_server (tofdp, fromfdp)
     int *tofdp;
     int *fromfdp;
{
    /* If you're working through firewalls, you can set the
       CVS_RSH environment variable to a script which uses rsh to
       invoke another rsh on a proxy machine.  */
    char *cvs_rsh = getenv ("CVS_RSH");
    char *cvs_server = getenv ("CVS_SERVER");
    char *command;

    if (!cvs_rsh)
	cvs_rsh = "ssh";
    if (!cvs_server)
	cvs_server = "cvs";

    /* Pass the command to rsh as a single string.  This shouldn't
       affect most rsh servers at all, and will pacify some buggy
       versions of rsh that grab switches out of the middle of the
       command (they're calling the GNU getopt routines incorrectly).  */
    command = xmalloc (strlen (cvs_server)
		       + strlen (current_parsed_root->directory)
		       + 50);

    /* If you are running a very old (Nov 3, 1994, before 1.5)
     * version of the server, you need to make sure that your .bashrc
     * on the server machine does not set CVSROOT to something
     * containing a colon (or better yet, upgrade the server).  */
    sprintf (command, "%s server", cvs_server);

    {
        char *argv[10];
	char **p = argv;

	*p++ = cvs_rsh;

	/* If the login names differ between client and server
	 * pass it on to rsh.
	 */
	if (current_parsed_root->username != NULL)
	{
	    *p++ = "-l";
	    *p++ = current_parsed_root->username;
	}

	*p++ = "--";
	*p++ = current_parsed_root->hostname;
	*p++ = command;
	*p++ = NULL;

	if (trace)
        {
	    int i;

            fprintf (stderr, " -> Starting server: ");
	    for (i = 0; argv[i]; i++)
	        fprintf (stderr, "%s ", argv[i]);
	    putc ('\n', stderr);
	}
	rsh_pid = piped_child (argv, tofdp, fromfdp);

	if (rsh_pid < 0)
	    error (1, errno, "cannot start server via ssh");
    }
    free (command);
}

#endif /* START_RSH_WITH_POPEN_RW */

#endif /* NO_EXT_METHOD */



/* Send an argument STRING.  */
void
send_arg (string)
    char *string;
{
    char buf[1];
    char *p = string;

    send_to_server ("Argument ", 0);

    while (*p)
    {
	if (*p == '\n')
	{
	    send_to_server ("\012Argumentx ", 0);
	}
	else
        {
	    buf[0] = *p;
	    send_to_server (buf, 1);
        }
	++p;
    }
    send_to_server ("\012", 1);
}

static void send_modified PROTO ((char *, char *, Vers_TS *));

/* VERS->OPTIONS specifies whether the file is binary or not.  NOTE: BEFORE
   using any other fields of the struct vers, we would need to fix
   client_process_import_file to set them up.  */

static void
send_modified (file, short_pathname, vers)
    char *file;
    char *short_pathname;
    Vers_TS *vers;
{
    /* File was modified, send it.  */
    struct stat sb;
    int fd;
    char *buf;
    char *mode_string;
    size_t bufsize;
    int bin;

    if (trace)
	(void) fprintf (stderr, " -> Sending file `%s' to server\n", file);

    /* Don't think we can assume fstat exists.  */
    if ( CVS_STAT (file, &sb) < 0)
	error (1, errno, "reading %s", short_pathname);

    mode_string = mode_to_string (sb.st_mode);

    /* Beware: on systems using CRLF line termination conventions,
       the read and write functions will convert CRLF to LF, so the
       number of characters read is not the same as sb.st_size.  Text
       files should always be transmitted using the LF convention, so
       we don't want to disable this conversion.  */
    bufsize = sb.st_size;
    buf = xmalloc (bufsize);

    /* Is the file marked as containing binary data by the "-kb" flag?
       If so, make sure to open it in binary mode: */

    if (vers && vers->options)
      bin = !(strcmp (vers->options, "-kb"));
    else
      bin = 0;

#ifdef BROKEN_READWRITE_CONVERSION
    if (!bin)
    {
	/* If only stdio, not open/write/etc., do text/binary
	   conversion, use convert_file which can compensate
	   (FIXME: we could just use stdio instead which would
	   avoid the whole problem).  */
	char tfile[1024]; strcpy(tfile, file); strcat(tfile, ".CVSBFCTMP");
	convert_file (file, O_RDONLY,
		      tfile, O_WRONLY | O_CREAT | O_TRUNC | OPEN_BINARY);
	fd = CVS_OPEN (tfile, O_RDONLY | OPEN_BINARY);
	if (fd < 0)
	    error (1, errno, "reading %s", short_pathname);
    }
    else
	fd = CVS_OPEN (file, O_RDONLY | OPEN_BINARY);
#else
    fd = CVS_OPEN (file, O_RDONLY | (bin ? OPEN_BINARY : 0));
#endif

    if (fd < 0)
	error (1, errno, "reading %s", short_pathname);

    if (file_gzip_level && sb.st_size > 100)
    {
	size_t newsize = 0;

	if (read_and_gzip (fd, short_pathname, (unsigned char **)&buf,
			   &bufsize, &newsize,
			   file_gzip_level))
	    error (1, 0, "aborting due to compression error");

	if (close (fd) < 0)
	    error (0, errno, "warning: can't close %s", short_pathname);

        {
          char tmp[80];

	  send_to_server ("Modified ", 0);
	  send_to_server (file, 0);
	  send_to_server ("\012", 1);
	  send_to_server (mode_string, 0);
	  send_to_server ("\012z", 2);
	  sprintf (tmp, "%lu\n", (unsigned long) newsize);
	  send_to_server (tmp, 0);

          send_to_server (buf, newsize);
        }
    }
    else
    {
    	int newsize;

        {
	    char *bufp = buf;
	    int len;

	    /* FIXME: This is gross.  It assumes that we might read
	       less than st_size bytes (true on NT), but not more.
	       Instead of this we should just be reading a block of
	       data (e.g. 8192 bytes), writing it to the network, and
	       so on until EOF.  */
	    while ((len = read (fd, bufp, (buf + sb.st_size) - bufp)) > 0)
	        bufp += len;

	    if (len < 0)
	        error (1, errno, "reading %s", short_pathname);

	    newsize = bufp - buf;
	}
	if (close (fd) < 0)
	    error (0, errno, "warning: can't close %s", short_pathname);

        {
          char tmp[80];

	  send_to_server ("Modified ", 0);
	  send_to_server (file, 0);
	  send_to_server ("\012", 1);
	  send_to_server (mode_string, 0);
	  send_to_server ("\012", 1);
          sprintf (tmp, "%lu\012", (unsigned long) newsize);
          send_to_server (tmp, 0);
        }
#ifdef BROKEN_READWRITE_CONVERSION
	if (!bin)
	{
	    char tfile[1024]; strcpy(tfile, file); strcat(tfile, ".CVSBFCTMP");
	    if (CVS_UNLINK (tfile) < 0)
		error (0, errno, "warning: can't remove temp file %s", tfile);
	}
#endif

	/*
	 * Note that this only ends with a newline if the file ended with
	 * one.
	 */
	if (newsize > 0)
	    send_to_server (buf, newsize);
    }
    free (buf);
    free (mode_string);
}

/* The address of an instance of this structure is passed to
   send_fileproc, send_filesdoneproc, and send_direntproc, as the
   callerdat parameter.  */

struct send_data
{
    /* Each of the following flags are zero for clear or nonzero for set.  */
    int build_dirs;
    int force;
    int no_contents;
    int backup_modified;
};

static int send_fileproc PROTO ((void *callerdat, struct file_info *finfo));

/* Deal with one file.  */
static int
send_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    struct send_data *args = (struct send_data *) callerdat;
    Vers_TS *vers;
    struct file_info xfinfo;
    /* File name to actually use.  Might differ in case from
       finfo->file.  */
    char *filename;

    send_a_repository ("", finfo->repository, finfo->update_dir);

    xfinfo = *finfo;
    xfinfo.repository = NULL;
    xfinfo.rcs = NULL;
    vers = Version_TS (&xfinfo, NULL, NULL, NULL, 0, 0);

    if (vers->entdata != NULL)
	filename = vers->entdata->user;
    else
	filename = finfo->file;

    if (vers->vn_user != NULL)
    {
	/* The Entries request.  */
	send_to_server ("Entry /", 0);
	send_to_server (filename, 0);
	send_to_server ("/", 0);
	send_to_server (vers->vn_user, 0);
	send_to_server ("/", 0);
	if (vers->ts_conflict != NULL)
	{
	    if (vers->ts_user != NULL &&
		strcmp (vers->ts_conflict, vers->ts_user) == 0)
		send_to_server ("+=", 0);
	    else
		send_to_server ("+modified", 0);
	}
	send_to_server ("/", 0);
	send_to_server (vers->entdata != NULL
			? vers->entdata->options
			: vers->options,
			0);
	send_to_server ("/", 0);
	if (vers->entdata != NULL && vers->entdata->tag)
	{
	    send_to_server ("T", 0);
	    send_to_server (vers->entdata->tag, 0);
	}
	else if (vers->entdata != NULL && vers->entdata->date)
          {
	    send_to_server ("D", 0);
	    send_to_server (vers->entdata->date, 0);
          }
	send_to_server ("\012", 1);
    }
    else
    {
	/* It seems a little silly to re-read this on each file, but
	   send_dirent_proc doesn't get called if filenames are specified
	   explicitly on the command line.  */
	wrap_add_file (CVSDOTWRAPPER, 1);

	if (wrap_name_has (filename, WRAP_RCSOPTION))
	{
	    /* No "Entry", but the wrappers did give us a kopt so we better
	       send it with "Kopt".  As far as I know this only happens
	       for "cvs add".  Question: is there any reason why checking
	       for options from wrappers isn't done in Version_TS?

	       Note: it might have been better to just remember all the
	       kopts on the client side, rather than send them to the server,
	       and have it send us back the same kopts.  But that seemed like
	       a bigger change than I had in mind making now.  */

	    if (supported_request ("Kopt"))
	    {
		char *opt;

		send_to_server ("Kopt ", 0);
		opt = wrap_rcsoption (filename, 1);
		send_to_server (opt, 0);
		send_to_server ("\012", 1);
		free (opt);
	    }
	    else
		error (0, 0,
		       "\
warning: ignoring -k options due to server limitations");
	}
    }

    if (vers->ts_user == NULL)
    {
	/*
	 * Do we want to print "file was lost" like normal CVS?
	 * Would it always be appropriate?
	 */
	/* File no longer exists.  Don't do anything, missing files
	   just happen.  */
    }
    else if (vers->ts_rcs == NULL
	     || args->force
	     || strcmp (vers->ts_user, vers->ts_rcs) != 0)
    {
	if (args->no_contents
	    && supported_request ("Is-modified"))
	{
	    send_to_server ("Is-modified ", 0);
	    send_to_server (filename, 0);
	    send_to_server ("\012", 1);
	}
	else
	    send_modified (filename, finfo->fullname, vers);

        if (args->backup_modified)
        {
            char *bakname;
            bakname = backup_file (filename, vers->vn_user);
            /* This behavior is sufficiently unexpected to
               justify overinformativeness, I think. */
            if (! really_quiet)
                printf ("(Locally modified %s moved to %s)\n",
                        filename, bakname);
            free (bakname);
        }
    }
    else
    {
	send_to_server ("Unchanged ", 0);
	send_to_server (filename, 0);
	send_to_server ("\012", 1);
    }

    /* if this directory has an ignore list, add this file to it */
    if (ignlist)
    {
	Node *p;

	p = getnode ();
	p->type = FILES;
	p->key = xstrdup (finfo->file);
	(void) addnode (ignlist, p);
    }

    freevers_ts (&vers);
    return 0;
}

static void send_ignproc PROTO ((char *, char *));

static void
send_ignproc (file, dir)
    char *file;
    char *dir;
{
    if (ign_inhibit_server || !supported_request ("Questionable"))
    {
	if (dir[0] != '\0')
	    (void) printf ("? %s/%s\n", dir, file);
	else
	    (void) printf ("? %s\n", file);
    }
    else
    {
	send_to_server ("Questionable ", 0);
	send_to_server (file, 0);
	send_to_server ("\012", 1);
    }
}

static int send_filesdoneproc PROTO ((void *, int, char *, char *, List *));

static int
send_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
    int err;
    char *repository;
    char *update_dir;
    List *entries;
{
    /* if this directory has an ignore list, process it then free it */
    if (ignlist)
    {
	ignore_files (ignlist, entries, update_dir, send_ignproc);
	dellist (&ignlist);
    }

    return (err);
}

static Dtype send_dirent_proc PROTO ((void *, char *, char *, char *, List *));

/*
 * send_dirent_proc () is called back by the recursion processor before a
 * sub-directory is processed for update.
 * A return code of 0 indicates the directory should be
 * processed by the recursion code.  A return of non-zero indicates the
 * recursion code should skip this directory.
 *
 */
static Dtype
send_dirent_proc (callerdat, dir, repository, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repository;
    char *update_dir;
    List *entries;
{
    struct send_data *args = (struct send_data *) callerdat;
    int dir_exists;
    char *cvsadm_name;

    if (ignore_directory (update_dir))
    {
	/* print the warm fuzzy message */
	if (!quiet)
	    error (0, 0, "Ignoring %s", update_dir);
        return (R_SKIP_ALL);
    }

    /*
     * If the directory does not exist yet (e.g. "cvs update -d foo"),
     * no need to send any files from it.  If the directory does not
     * have a CVS directory, then we pretend that it does not exist.
     * Otherwise, we will fail when trying to open the Entries file.
     * This case will happen when checking out a module defined as
     * ``-a .''.
     */
    cvsadm_name = xmalloc (strlen (dir) + sizeof (CVSADM) + 10);
    sprintf (cvsadm_name, "%s/%s", dir, CVSADM);
    dir_exists = isdir (cvsadm_name);
    free (cvsadm_name);

    /*
     * If there is an empty directory (e.g. we are doing `cvs add' on a
     * newly-created directory), the server still needs to know about it.
     */

    if (dir_exists)
    {
	/*
	 * Get the repository from a CVS/Repository file whenever possible.
	 * The repository variable is wrong if the names in the local
	 * directory don't match the names in the repository.
	 */
	char *repos = Name_Repository (dir, update_dir);
	send_a_repository (dir, repos, update_dir);
	free (repos);

	/* initialize the ignore list for this directory */
	ignlist = getlist ();
    }
    else
    {
	/* It doesn't make sense to send a non-existent directory,
	   because there is no way to get the correct value for
	   the repository (I suppose maybe via the expand-modules
	   request).  In the case where the "obvious" choice for
	   repository is correct, the server can figure out whether
	   to recreate the directory; in the case where it is wrong
	   (that is, does not match what modules give us), we might as
	   well just fail to recreate it.

	   Checking for noexec is a kludge for "cvs -n add dir".  */
	/* Don't send a non-existent directory unless we are building
           new directories (build_dirs is true).  Otherwise, CVS may
           see a D line in an Entries file, and recreate a directory
           which the user removed by hand.  */
	if (args->build_dirs && noexec)
	    send_a_repository (dir, repository, update_dir);
    }

    return (dir_exists ? R_PROCESS : R_SKIP_ALL);
}

static int send_dirleave_proc PROTO ((void *, char *, int, char *, List *));

/*
 * send_dirleave_proc () is called back by the recursion code upon leaving
 * a directory.  All it does is delete the ignore list if it hasn't already
 * been done (by send_filesdone_proc).
 */
/* ARGSUSED */
static int
send_dirleave_proc (callerdat, dir, err, update_dir, entries)
    void *callerdat;
    char *dir;
    int err;
    char *update_dir;
    List *entries;
{

    /* Delete the ignore list if it hasn't already been done.  */
    if (ignlist)
	dellist (&ignlist);
    return err;
}

/*
 * Send each option in a string to the server, one by one.
 * This assumes that the options are separated by spaces, for example
 * STRING might be "--foo -C5 -y".
 */

void
send_option_string (string)
    char *string;
{
    char *copy;
    char *p;

    copy = xstrdup (string);
    p = copy;
    while (1)
    {
        char *s;
	char l;

	for (s = p; *s != ' ' && *s != '\0'; s++)
	    ;
	l = *s;
	*s = '\0';
	if (s != p)
	    send_arg (p);
	if (l == '\0')
	    break;
	p = s + 1;
    }
    free (copy);
}


/* Send the names of all the argument files to the server.  */

void
send_file_names (argc, argv, flags)
    int argc;
    char **argv;
    unsigned int flags;
{
    int i;
    int level;
    int max_level;
    
    /* The fact that we do this here as well as start_recursion is a bit 
       of a performance hit.  Perhaps worth cleaning up someday.  */
    if (flags & SEND_EXPAND_WILD)
	expand_wild (argc, argv, &argc, &argv);

    /* Send Max-dotdot if needed.  */
    max_level = 0;
    for (i = 0; i < argc; ++i)
    {
	level = pathname_levels (argv[i]);
	if (level > max_level)
	    max_level = level;
    }
    if (max_level > 0)
    {
	if (supported_request ("Max-dotdot"))
	{
            char buf[10];
            sprintf (buf, "%d", max_level);

	    send_to_server ("Max-dotdot ", 0);
	    send_to_server (buf, 0);
	    send_to_server ("\012", 1);
	}
	else
	    /*
	     * "leading .." is not strictly correct, as this also includes
	     * cases like "foo/../..".  But trying to explain that in the
	     * error message would probably just confuse users.
	     */
	    error (1, 0,
		   "leading .. not supported by old (pre-Max-dotdot) servers");
    }

    for (i = 0; i < argc; ++i)
    {
	char buf[1];
	char *p = argv[i];
	char *line = NULL;

	if (arg_should_not_be_sent_to_server (argv[i]))
	    continue;

#ifdef FILENAMES_CASE_INSENSITIVE
	/* We want to send the file name as it appears
	   in CVS/Entries.  We put this inside an ifdef
	   to avoid doing all these system calls in
	   cases where fncmp is just strcmp anyway.  */
	/* For now just do this for files in the local
	   directory.  Would be nice to handle the
	   non-local case too, though.  */
	/* The isdir check could more gracefully be replaced
	   with a way of having Entries_Open report back the
	   error to us and letting us ignore existence_error.
	   Or some such.  */
	if (p == last_component (p) && isdir (CVSADM))
	{
	    List *entries;
	    Node *node;

	    /* If we were doing non-local directory,
	       we would save_cwd, CVS_CHDIR
	       like in update.c:isemptydir.  */
	    /* Note that if we are adding a directory,
	       the following will read the entry
	       that we just wrote there, that is, we
	       will get the case specified on the
	       command line, not the case of the
	       directory in the filesystem.  This
	       is correct behavior.  */
	    entries = Entries_Open (0, NULL);
	    node = findnode_fn (entries, p);
	    if (node != NULL)
	    {
		line = xstrdup (node->key);
		p = line;
		delnode (node);
	    }
	    Entries_Close (entries);
	}
#endif /* FILENAMES_CASE_INSENSITIVE */

	send_to_server ("Argument ", 0);

	while (*p)
	{
	    if (*p == '\n')
	    {
		send_to_server ("\012Argumentx ", 0);
	    }
	    else if (ISDIRSEP (*p))
	    {
		buf[0] = '/';
		send_to_server (buf, 1);
	    }
	    else
	    {
		buf[0] = *p;
		send_to_server (buf, 1);
	    }
	    ++p;
	}
	send_to_server ("\012", 1);
	if (line != NULL)
	    free (line);
    }

    if (flags & SEND_EXPAND_WILD)
    {
	int i;
	for (i = 0; i < argc; ++i)
	    free (argv[i]);
	free (argv);
    }
}


/* Send Repository, Modified and Entry.  argc and argv contain only
  the files to operate on (or empty for everything), not options.
  local is nonzero if we should not recurse (-l option).  flags &
  SEND_BUILD_DIRS is nonzero if nonexistent directories should be
  sent.  flags & SEND_FORCE is nonzero if we should send unmodified
  files to the server as though they were modified.  flags &
  SEND_NO_CONTENTS means that this command only needs to know
  _whether_ a file is modified, not the contents.  Also sends Argument
  lines for argc and argv, so should be called after options are sent.  */
void
send_files (argc, argv, local, aflag, flags)
    int argc;
    char **argv;
    int local;
    int aflag;
    unsigned int flags;
{
    struct send_data args;
    int err;

    /*
     * aflag controls whether the tag/date is copied into the vers_ts.
     * But we don't actually use it, so I don't think it matters what we pass
     * for aflag here.
     */
    args.build_dirs = flags & SEND_BUILD_DIRS;
    args.force = flags & SEND_FORCE;
    args.no_contents = flags & SEND_NO_CONTENTS;
    args.backup_modified = flags & BACKUP_MODIFIED_FILES;
    err = start_recursion
	(send_fileproc, send_filesdoneproc,
	 send_dirent_proc, send_dirleave_proc, (void *) &args,
	 argc, argv, local, W_LOCAL, aflag, 0, (char *)NULL, 0);
    if (err)
	error_exit ();
    if (toplevel_repos == NULL)
	/*
	 * This happens if we are not processing any files,
	 * or for checkouts in directories without any existing stuff
	 * checked out.  The following assignment is correct for the
	 * latter case; I don't think toplevel_repos matters for the
	 * former.
	 */
	toplevel_repos = xstrdup (current_parsed_root->directory);
    send_repository ("", toplevel_repos, ".");
}

void
client_import_setup (repository)
    char *repository;
{
    if (toplevel_repos == NULL)		/* should always be true */
        send_a_repository ("", repository, "");
}

/*
 * Process the argument import file.
 */
int
client_process_import_file (message, vfile, vtag, targc, targv, repository,
                            all_files_binary, modtime)
    char *message;
    char *vfile;
    char *vtag;
    int targc;
    char *targv[];
    char *repository;
    int all_files_binary;

    /* Nonzero for "import -d".  */
    int modtime;
{
    char *update_dir;
    char *fullname;
    Vers_TS vers;

    assert (toplevel_repos != NULL);

    if (strncmp (repository, toplevel_repos, strlen (toplevel_repos)) != 0)
	error (1, 0,
	       "internal error: pathname `%s' doesn't specify file in `%s'",
	       repository, toplevel_repos);

    if (strcmp (repository, toplevel_repos) == 0)
    {
	update_dir = "";
	fullname = xstrdup (vfile);
    }
    else
    {
	update_dir = repository + strlen (toplevel_repos) + 1;

	fullname = xmalloc (strlen (vfile) + strlen (update_dir) + 10);
	strcpy (fullname, update_dir);
	strcat (fullname, "/");
	strcat (fullname, vfile);
    }

    send_a_repository ("", repository, update_dir);
    if (all_files_binary)
    {
	vers.options = xmalloc (4); /* strlen("-kb") + 1 */
	strcpy (vers.options, "-kb");
    }
    else
    {
	vers.options = wrap_rcsoption (vfile, 1);
    }
    if (vers.options != NULL)
    {
	if (supported_request ("Kopt"))
	{
	    send_to_server ("Kopt ", 0);
	    send_to_server (vers.options, 0);
	    send_to_server ("\012", 1);
	}
	else
	    error (0, 0,
		   "warning: ignoring -k options due to server limitations");
    }
    if (modtime)
    {
	if (supported_request ("Checkin-time"))
	{
	    struct stat sb;
	    char *rcsdate;
	    char netdate[MAXDATELEN];

	    if (CVS_STAT (vfile, &sb) < 0)
		error (1, errno, "cannot stat %s", fullname);
	    rcsdate = date_from_time_t (sb.st_mtime);
	    date_to_internet (netdate, rcsdate);
	    free (rcsdate);

	    send_to_server ("Checkin-time ", 0);
	    send_to_server (netdate, 0);
	    send_to_server ("\012", 1);
	}
	else
	    error (0, 0,
		   "warning: ignoring -d option due to server limitations");
    }
    send_modified (vfile, fullname, &vers);
    if (vers.options != NULL)
	free (vers.options);
    free (fullname);
    return 0;
}

void
client_import_done ()
{
    if (toplevel_repos == NULL)
	/*
	 * This happens if we are not processing any files,
	 * or for checkouts in directories without any existing stuff
	 * checked out.  The following assignment is correct for the
	 * latter case; I don't think toplevel_repos matters for the
	 * former.
	 */
        /* FIXME: "can't happen" now that we call client_import_setup
	   at the beginning.  */
	toplevel_repos = xstrdup (current_parsed_root->directory);
    send_repository ("", toplevel_repos, ".");
}

static void
notified_a_file (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    FILE *fp;
    FILE *newf;
    size_t line_len = 8192;
    char *line = xmalloc (line_len);
    char *cp;
    int nread;
    int nwritten;
    char *p;

    fp = open_file (CVSADM_NOTIFY, "r");
    if (get_line (&line, &line_len, fp) < 0)
    {
	if (feof (fp))
	    error (0, 0, "cannot read %s: end of file", CVSADM_NOTIFY);
	else
	    error (0, errno, "cannot read %s", CVSADM_NOTIFY);
	goto error_exit;
    }
    cp = strchr (line, '\t');
    if (cp == NULL)
    {
	error (0, 0, "malformed %s file", CVSADM_NOTIFY);
	goto error_exit;
    }
    *cp = '\0';
    if (strcmp (filename, line + 1) != 0)
    {
	error (0, 0, "protocol error: notified %s, expected %s", filename,
	       line + 1);
    }

    if (get_line (&line, &line_len, fp) < 0)
    {
	if (feof (fp))
	{
	    free (line);
	    if (fclose (fp) < 0)
		error (0, errno, "cannot close %s", CVSADM_NOTIFY);
	    if ( CVS_UNLINK (CVSADM_NOTIFY) < 0)
		error (0, errno, "cannot remove %s", CVSADM_NOTIFY);
	    return;
	}
	else
	{
	    error (0, errno, "cannot read %s", CVSADM_NOTIFY);
	    goto error_exit;
	}
    }
    newf = open_file (CVSADM_NOTIFYTMP, "w");
    if (fputs (line, newf) < 0)
    {
	error (0, errno, "cannot write %s", CVSADM_NOTIFYTMP);
	goto error2;
    }
    while ((nread = fread (line, 1, line_len, fp)) > 0)
    {
	p = line;
	while ((nwritten = fwrite (p, 1, nread, newf)) > 0)
	{
	    nread -= nwritten;
	    p += nwritten;
	}
	if (ferror (newf))
	{
	    error (0, errno, "cannot write %s", CVSADM_NOTIFYTMP);
	    goto error2;
	}
    }
    if (ferror (fp))
    {
	error (0, errno, "cannot read %s", CVSADM_NOTIFY);
	goto error2;
    }
    if (fclose (newf) < 0)
    {
	error (0, errno, "cannot close %s", CVSADM_NOTIFYTMP);
	goto error_exit;
    }
    free (line);
    if (fclose (fp) < 0)
    {
	error (0, errno, "cannot close %s", CVSADM_NOTIFY);
	return;
    }

    {
        /* In this case, we want rename_file() to ignore noexec. */
        int saved_noexec = noexec;
        noexec = 0;
        rename_file (CVSADM_NOTIFYTMP, CVSADM_NOTIFY);
        noexec = saved_noexec;
    }

    return;
  error2:
    (void) fclose (newf);
  error_exit:
    free (line);
    (void) fclose (fp);
}

static void
handle_notified (args, len)
    char *args;
    int len;
{
    call_in_directory (args, notified_a_file, NULL);
}

void
client_notify (repository, update_dir, filename, notif_type, val)
    char *repository;
    char *update_dir;
    char *filename;
    int notif_type;
    char *val;
{
    char buf[2];

    send_a_repository ("", repository, update_dir);
    send_to_server ("Notify ", 0);
    send_to_server (filename, 0);
    send_to_server ("\012", 1);
    buf[0] = notif_type;
    buf[1] = '\0';
    send_to_server (buf, 1);
    send_to_server ("\t", 1);
    send_to_server (val, 0);
}

/*
 * Send an option with an argument, dealing correctly with newlines in
 * the argument.  If ARG is NULL, forget the whole thing.
 */
void
option_with_arg (option, arg)
    char *option;
    char *arg;
{
    if (arg == NULL)
	return;

    send_to_server ("Argument ", 0);
    send_to_server (option, 0);
    send_to_server ("\012", 1);

    send_arg (arg);
}

/* Send a date to the server.  The input DATE is in RCS format.
   The time will be GMT.

   We then convert that to the format required in the protocol
   (including the "-D" option) and send it.  According to
   cvsclient.texi, RFC 822/1123 format is preferred.  */

void
client_senddate (date)
    const char *date;
{
    char buf[MAXDATELEN];

    date_to_internet (buf, (char *)date);
    option_with_arg ("-D", buf);
}

void
send_init_command ()
{
    /* This is here because we need the current_parsed_root->directory variable.  */
    send_to_server ("init ", 0);
    send_to_server (current_parsed_root->directory, 0);
    send_to_server ("\012", 0);
}

#endif /* CLIENT_SUPPORT */
@


1.13
log
@Kill usage of timeb.h for upcoming removal of libcompat.  OK deraadt@@
@
text
@d4836 1
a4836 1
    /* This needs to fit "rsh", "-b", "-l", "USER", "host",
d4883 1
a4946 1
	*p++ = current_parsed_root->hostname;
d4957 2
@


1.12
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1581 1
a1581 1
    stored_modtime = get_date (args, NULL);
@


1.11
log
@- a malicious server may send path names that translate out of the
local cvs tree on the client, enabling the server to overwrite files
on the client.

- a client may read files outside the repository using the -p flag
with the checkout command.

ok deraadt@@
@
text
@d5821 1
a5821 1
    if (getline (&line, &line_len, fp) < 0)
d5842 1
a5842 1
    if (getline (&line, &line_len, fp) < 0)
@


1.10
log
@dont deref NULL pointer in IPv6 pserver client operation.
From: Moritz Jodeit <moritz@@jodeit.org>
@
text
@d1006 14
@


1.10.8.1
log
@MFC:
Fix by otto@@

- a malicious server may send path names that translate out of the
local cvs tree on the client, enabling the server to overwrite files
on the client.

- a client may read files outside the repository using the -p flag
with the checkout command.

ok deraadt@@ otto@@
@
text
@a1005 14
    /*
     * For security reasons, if PATHNAME is absolute or attempts to
     * ascend outside of the current sandbox, we abort.  The server should not
     * send us anything but relative paths which remain inside the sandbox
     * here.  Anything less means a trojan CVS server could create and edit
     * arbitrary files on the client.
     */
    if (isabsolute (pathname) || pathname_levels (pathname) > 0)
    {
        error (0, 0,
               "Server attempted to update a file via an invalid pathname:");
        error (1, 0, "`%s'.", pathname);
    }

@


1.10.4.1
log
@MFC:
Fix by otto@@

- a malicious server may send path names that translate out of the
local cvs tree on the client, enabling the server to overwrite files
on the client.

- a client may read files outside the repository using the -p flag
with the checkout command.

ok deraadt@@ otto@@
@
text
@a1005 14
    /*
     * For security reasons, if PATHNAME is absolute or attempts to
     * ascend outside of the current sandbox, we abort.  The server should not
     * send us anything but relative paths which remain inside the sandbox
     * here.  Anything less means a trojan CVS server could create and edit
     * arbitrary files on the client.
     */
    if (isabsolute (pathname) || pathname_levels (pathname) > 0)
    {
        error (0, 0,
               "Server attempted to update a file via an invalid pathname:");
        error (1, 0, "`%s'.", pathname);
    }

@


1.10.6.1
log
@MFC:
Fix by otto@@

- a malicious server may send path names that translate out of the
local cvs tree on the client, enabling the server to overwrite files
on the client.

- a client may read files outside the repository using the -p flag
with the checkout command.

ok deraadt@@ otto@@
@
text
@a1005 14
    /*
     * For security reasons, if PATHNAME is absolute or attempts to
     * ascend outside of the current sandbox, we abort.  The server should not
     * send us anything but relative paths which remain inside the sandbox
     * here.  Anything less means a trojan CVS server could create and edit
     * arbitrary files on the client.
     */
    if (isabsolute (pathname) || pathname_levels (pathname) > 0)
    {
        error (0, 0,
               "Server attempted to update a file via an invalid pathname:");
        error (1, 0, "`%s'.", pathname);
    }

@


1.9
log
@make pserver code IPv6 ready.  markus ok
@
text
@d3916 1
a3916 1
	getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, sizeof(hbuf),
d3920 1
a3920 1
	       port_number, SOCK_STRERROR (SOCK_ERRNO));
@


1.8
log
@Merge remaining local changes, correct build issues
@
text
@d86 1
a86 1
static int connect_to_gserver PROTO((int, struct hostent *));
d3875 2
a3876 2
    struct sockaddr_in client_sai;
    struct hostent *hostinfo;
d3878 1
d3880 7
a3886 2
    sock = socket (AF_INET, SOCK_STREAM, 0);
    if (sock == -1)
d3888 1
a3888 1
	error (1, 0, "cannot create socket: %s", SOCK_STRERROR (SOCK_ERRNO));
d3890 2
a3891 3
    port_number = get_cvs_port_number (current_parsed_root);
    hostinfo = init_sockaddr (&client_sai, current_parsed_root->hostname, port_number);
    if (trace)
d3893 20
a3912 3
	fprintf (stderr, " -> Connecting to %s(%s):%d\n",
		 current_parsed_root->hostname,
		 inet_ntoa (client_sai.sin_addr), port_number);
d3914 6
a3919 5
    if (connect (sock, (struct sockaddr *) &client_sai, sizeof (client_sai))
	< 0)
	error (1, 0, "connect to %s(%s):%d failed: %s",
	       current_parsed_root->hostname,
	       inet_ntoa (client_sai.sin_addr),
d3921 1
d3927 2
a3928 1
	if (! connect_to_gserver (sock, hostinfo))
d4083 2
d4105 2
d4230 1
a4230 1
connect_to_gserver (sock, hostinfo)
d4232 1
a4232 1
     struct hostent *hostinfo;
d4245 1
a4245 1
    sprintf (buf, "cvs@@%s", hostinfo->h_name);
@


1.7
log
@Merge local changes; work in progress
@
text
@d4110 1
a4110 1
    struct sockaddr_in sin;
d4119 1
a4119 1
    hp = init_sockaddr (&sin, current_parsed_root->hostname, port);
d4131 1
a4131 1
    if (connect (s, (struct sockaddr *) &sin, sizeof sin) < 0)
d4155 1
a4155 1
			       &cred, sched, &laddr, &sin, "KCVSV1.0");
@


1.6
log
@Disable bogus check for whether a file in the current directory (only!)
were checked out of a different CVSROOT -- makes it very hard to have
replicated repositories.
@
text
@d35 1
d81 1
a81 13
#ifdef HAVE_GSSAPI_H
#include <gssapi.h>
#endif
#ifdef HAVE_GSSAPI_GSSAPI_H
#include <gssapi/gssapi.h>
#endif
#ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H
#include <gssapi/gssapi_generic.h>
#endif

#ifndef HAVE_GSS_C_NT_HOSTBASED_SERVICE
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#endif
d89 1
a89 1

d190 1
a190 1
       4) */
d262 2
a263 2
	if (this_root && current_root
	    && (strcmp (this_root, current_root) != 0))
d1277 26
d2308 1
a2308 1
    if (strcmp (toplevel_repos, CVSroot_directory) != 0)
d2948 2
a2949 2
                   CVSroot_directory, set toplevel_repos to
                   CVSroot_directory. */
d2953 1
a2953 1
		    /* TOPLEVEL_REPOS shouldn't be above CVSroot_directory */
d2955 1
a2955 1
			> strlen (CVSroot_directory)))
d2969 1
a2969 1
		    toplevel_repos = xstrdup (CVSroot_directory);
d3027 1
a3027 1
    send_a_repository ("", CVSroot_directory, "");
d3065 1
a3065 1
    send_a_repository ("", CVSroot_directory, "");
d3071 1
a3071 1
    send_a_repository ("", CVSroot_directory, "");
d3586 2
a3587 1
		       CVSroot_hostname, SOCK_STRERROR (SOCK_ERRNO));
d3596 1
a3596 1
			   CVSroot_hostname);
d3614 1
a3614 1
			   CVSroot_hostname);
d3620 1
a3620 1
	    error (0, 0, "dying gasps from %s unexpected", CVSroot_hostname);
d3622 1
a3622 1
	    error (0, errno, "reading from %s", CVSroot_hostname);
d3639 1
a3639 2
	while (time ((time_t *) NULL) == last_register_time)
	    sleep (1);
d3663 2
a3664 1

d3693 2
d3697 7
a3703 2
static int auth_server_port_number PROTO ((void));

d3705 4
a3708 1
auth_server_port_number ()
d3710 2
a3711 1
    struct servent *s = getservbyname ("cvspserver", "tcp");
d3713 13
a3725 1
    if (s)
d3728 1
a3728 1
	return CVS_AUTH_PORT;
d3732 41
d3800 1
a3800 1
	    error (1, 0, "recv() from server %s: %s", CVSroot_hostname,
d3838 1
a3838 1
	command[0] = "cvs";
d3843 4
d3874 1
d3877 1
a3877 1
    char no_passwd = 0;   /* gets set if no password found */
d3884 8
a3891 2
    port_number = auth_server_port_number ();
    hostinfo = init_sockaddr (&client_sai, CVSroot_hostname, port_number);
d3894 3
a3896 1
	error (1, 0, "connect to %s:%d failed: %s", CVSroot_hostname,
d3904 4
d3909 1
a3916 2
	char *repository = CVSroot_directory;
	char *username   = CVSroot_username;
d3919 1
a3919 1

d3933 2
a3934 1
        
d3948 1
a3948 1
	if (send (sock, repository, strlen (repository), 0) < 0)
d3979 23
a4001 1
		/* Authorization not granted. */
d4039 1
a4039 1
			   CVSroot_hostname, read_buf);
d4042 1
a4042 1
			   CVSroot_hostname,
d4047 1
a4047 1
		       CVSroot_hostname, read_buf);
d4056 1
a4056 1
	    error (0, 0, "shutdown() failed, server %s: %s", CVSroot_hostname,
a4080 13
    error (0, 0,
	"authorization failed: server %s rejected access to %s for user %s",
	CVSroot_hostname, CVSroot_directory, CVSroot_username);

    /* Output a special error message if authentication was attempted
       with no password -- the user should be made aware that they may
       have missed a step. */
    if (no_passwd)
    {
        error (0, 0,
               "used empty password; try \"cvs login\" with a real password");
    }

d4085 1
a4085 1
	       CVSroot_hostname,
d4093 3
a4095 2

#if HAVE_KERBEROS
d4117 1
a4117 25
    /* Get CVS_CLIENT_PORT or look up cvs/tcp with CVS_PORT as default */
    portenv = getenv ("CVS_CLIENT_PORT");
    if (portenv != NULL)
    {
	port = atoi (portenv);
	if (port <= 0)
	{
	    error (0, 0, "CVS_CLIENT_PORT must be a positive number!  If you");
	    error (0, 0, "are trying to force a connection via ssh, please");
	    error (0, 0, "put \":server:\" at the beginning of your CVSROOT");
	    error (1, 0, "variable.");
	}
	if (trace)
	    fprintf(stderr, "Using TCP port %d to contact server.\n", port);
    }
    else
    {
	struct servent *sp;

	sp = getservbyname ("cvs", "tcp");
	if (sp == NULL)
	    port = CVS_PORT;
	else
	    port = ntohs (sp->s_port);
    }
d4119 1
a4119 1
    hp = init_sockaddr (&sin, CVSroot_hostname, port);
d4124 7
d4132 3
a4134 1
	error (1, 0, "connect to %s:%d failed: %s", CVSroot_hostname,
a4136 1
#ifdef HAVE_KERBEROS
a4160 1
#endif /* HAVE_KERBEROS */
d4189 4
a4192 3
	if (got < 0)
	    error (1, 0, "recv() from server %s: %s", CVSroot_hostname,
		   SOCK_STRERROR (SOCK_ERRNO));
d4285 1
a4285 1
			   CVSroot_hostname, SOCK_STRERROR (SOCK_ERRNO));
d4289 1
a4289 1
		error (1, 0, "error from server %s: %s", CVSroot_hostname,
d4341 1
a4341 1
    switch (CVSroot_method)
d4358 1
a4358 1
#if HAVE_GSSAPI
d4377 2
a4378 2
			  CVSroot_username, CVSroot_hostname,
			  CVSroot_directory);
d4509 1
a4509 1
	send_to_server (CVSroot_directory, 0);
d4639 1
a4639 1
	if (CVSroot_method == kserver_method)
d4654 1
a4654 1
	if (CVSroot_method == gserver_method)
d4727 1
a4727 1
	if (CVSroot_method == gserver_method)
d4834 1
a4834 1
    if (CVSroot_username != NULL)
d4837 1
a4837 1
	rsh_argv[i++] = CVSroot_username;
d4840 1
a4840 1
    rsh_argv[i++] = CVSroot_hostname;
d4850 2
d4889 1
a4889 1
		       + strlen (CVSroot_directory)
d4903 1
a4903 1
	*p++ = CVSroot_hostname;
d4908 1
a4908 1
	if (CVSroot_username != NULL)
d4911 1
a4911 1
	    *p++ = CVSroot_username;
d5638 1
a5638 1
	toplevel_repos = xstrdup (CVSroot_directory);
d5757 1
a5757 1
	toplevel_repos = xstrdup (CVSroot_directory);
d5937 1
a5937 1
    /* This is here because we need the CVSroot_directory variable.  */
d5939 1
a5939 1
    send_to_server (CVSroot_directory, 0);
@


1.5
log
@Document the fact that the wrong thing is likely to happen in many cases
here, if something is checked out from a (read-only?) replica of a repos,
and then checked in to the master, files will be skipped.

This needs to be resolved, somehow.
@
text
@d265 7
a277 7

	    /*
	     * This is so bogus!  Means if you have checked out from
	     * a replica of a repository, and then when you want to
	     * check it in to the real (read/write) repository, the
	     * file will be skipped!
	     */
d280 1
@


1.4
log
@Integrate local changes
@
text
@d271 7
@


1.3
log
@rsh was changed to ssh. reflect this in error messages.  ok deraadt@@
@
text
@d1 2
a64 1
#if HAVE_KERBEROS
a77 2
#endif /* HAVE_KERBEROS */

d1117 1
a1117 1
			  (char *) NULL, 0, 1);
d1254 1
a1254 1
				  (char *)NULL, (char *)NULL, 0, 0);
d1762 1
d1850 2
a1851 1
		    if (gunzip_and_write (fd, short_pathname, buf, size))
d2029 2
a2128 1
	free (scratch_entries);
d2130 1
d2496 1
d2498 3
d2515 1
d2517 3
d2697 1
a2697 1
	n->type = UNKNOWN;
d3608 2
d3612 1
a3612 1
    /* see if we need to sleep before returning */
d3615 2
a3616 8
	time_t now;

	for (;;)
	{
	    (void) time (&now);
	    if (now != last_register_time) break;
	    sleep (1);			/* to avoid time-stamp races */
	}
d3784 1
d3829 8
d3860 2
a3861 2
	/* Paranoia. */
	memset (password, 0, strlen (password));
d3954 13
d3969 1
a3969 4
	error (0, 0, 
	       "authorization failed: server %s rejected access", 
	       CVSroot_hostname);
	error (1, 0,
d3975 1
a3975 3
    error (1, 0, 
	   "authorization failed: server %s rejected access", 
	   CVSroot_hostname);
d4138 7
d4147 1
a4147 1
	    gss_display_status (&stat_min, stat_maj, GSS_C_GSS_CODE,
d4171 23
a4193 1
	    assert (need <= sizeof buf);
d4227 1
a4227 1
    int tofd, fromfd;
d4406 2
a4407 1
    if (strcmp (command_name, "init") != 0)
d4531 1
a4531 1
    if (cvsencrypt)
d4578 1
a4578 1
    if (gzip_level)
d4620 1
a4620 1
    if (cvsauthenticate && ! cvsencrypt)
d4651 1
a4651 1
    if (supported_request ("Case"))
d5024 1
d5146 12
a5265 3
    /* initialize the ignore list for this directory */
    ignlist = getlist ();

d5281 3
d5308 23
d5522 1
d5525 1
a5525 1
	 send_dirent_proc, (DIRLEAVEPROC)NULL, (void *) &args,
@


1.2
log
@change default connection protocol from "rsh" to "ssh", so that CVS_RSH
no longer needs setting.
@
text
@d3986 1
a3986 1
	    error (0, 0, "are trying to force a connection via rsh, please");
d4703 1
a4703 1
	error (1, errno, "cannot start server via rsh");
d4774 1
a4774 1
	    error (1, errno, "cannot start server via rsh");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* CVS client-related stuff.  */
d3 15
d19 3
a24 1
#include "update.h"		/* Things shared with update.c */
d27 33
d63 1
a63 3
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
d69 14
d84 2
d87 14
d132 1
d142 1
d145 136
d295 1
a295 1
#else
d298 1
a298 1
#endif
d300 2
a301 2
	char buf[18], u[4], g[4], o[4];
	int i;
d303 17
a319 17
	i = 0;
	if (mode & S_IRUSR) u[i++] = 'r';
	if (mode & S_IWUSR) u[i++] = 'w';
	if (mode & S_IXUSR) u[i++] = 'x';
	u[i] = '\0';
	
	i = 0;
	if (mode & S_IRGRP) g[i++] = 'r';
	if (mode & S_IWGRP) g[i++] = 'w';
	if (mode & S_IXGRP) g[i++] = 'x';
	g[i] = '\0';
	
	i = 0;
	if (mode & S_IROTH) o[i++] = 'r';
	if (mode & S_IWOTH) o[i++] = 'w';
	if (mode & S_IXOTH) o[i++] = 'x';
	o[i] = '\0';
d321 2
a322 2
	sprintf(buf, "u=%s,g=%s,o=%s", u, g, o);
	return xstrdup(buf);
d328 1
d331 1
a331 1
change_mode (filename, mode_string)
d334 1
d336 38
d376 1
d429 8
d440 1
d447 175
a621 6
/* The host part of CVSROOT.  */
static char *server_host;
/* The user part of CVSROOT */
static char *server_user;
/* The repository part of CVSROOT.  */
static char *server_cvsroot;
d623 22
a644 1
int client_active;
d646 1
a646 1
int client_prune_dirs;
d648 1
a648 3
/* Set server_host and server_cvsroot.  */
static void
parse_cvsroot ()
d650 116
a765 1
    char *p;
d767 3
a769 21
    server_host = xstrdup (CVSroot);
    server_cvsroot = strchr (server_host, ':');
    *server_cvsroot = '\0';
    ++server_cvsroot;

    if ( (p = strchr (server_host, '@@')) == NULL) {
      server_user = NULL;
    } else {
      server_user = server_host;
      server_host = p;
      ++server_host;
      *p = '\0';
    }
 			
    client_active = 1;
}

/* Stream to write to the server.  */
FILE *to_server;
/* Stream to read from the server.  */
FILE *from_server;
d771 3
a773 3
#if ! RSH_NOT_TRANSPARENT
/* Process ID of rsh subprocess.  */
static int rsh_pid = -1;
d775 16
d793 1
a793 1
 * Read a line from the server.
d797 1
a797 2
 * Returns number of bytes read.  If EOF_OK, then return 0 on end of file,
 * else end of file is an error.
d800 1
a800 1
read_line (resultp, eof_ok)
a801 1
    int eof_ok;
d803 1
a803 1
    int c;
d805 1
a805 2
    int input_index = 0;
    int result_size = 80;
d807 13
a819 28
    fflush (to_server);
    result = (char *) xmalloc (result_size);

    while (1)
    {
	c = getc (from_server);

	if (c == EOF)
	{
	    free (result);
	    if (ferror (from_server))
		error (1, errno, "reading from server");
	    /* It's end of file.  */
	    if (eof_ok)
		return 0;
	    else
		error (1, 0, "premature end of file from server");
	}

	if (c == '\n')
	    break;
	
	result[input_index++] = c;
	while (input_index + 1 >= result_size)
	{
	    result_size *= 2;
	    result = (char *) xrealloc (result, result_size);
	}
d822 1
a822 1
    if (resultp)
d824 2
d827 1
a827 6
    /* Terminate it just for kicks, but we *can* deal with embedded NULs.  */
    result[input_index] = '\0';

    if (resultp == NULL)
	free (result);
    return input_index;
d831 1
d841 4
a844 18
int filter_through_gzip (fd, dir, level, pidp)
     int fd, dir, level;
     pid_t *pidp;
{
  static char buf[5] = "-";
  static char *gzip_argv[3] = { "gzip", buf };

  sprintf (buf+1, "%d", level);
  return filter_stream_through_program (fd, dir, &gzip_argv[0], pidp);
}

int filter_through_gunzip (fd, dir, pidp)
     int fd, dir;
     pid_t *pidp;
{
  static char *gunzip_argv[2] = { "gunzip" };
  return filter_stream_through_program (fd, dir, &gunzip_argv[0], pidp);
}
d854 1
a854 1
static char *toplevel_repos;
d856 4
a859 2
/* Working directory when we first started.  */
char toplevel_wd[PATH_MAX];
d887 7
d931 1
a931 1
	    if (rq->status == rq_enableme)
d937 2
a938 4
		if (fprintf(to_server, "%s\n", rq->name) < 0)
		    error (1, errno, "writing to server");
		if (!strcmp("UseUnchanged",rq->name))
		    use_unchanged = 1;
d941 1
a941 1
		rq->status = rq_supported;
d947 4
a950 1
	if (rq->status == rq_essential)
a951 2
	else if (rq->status == rq_optional)
	    rq->status = rq_not_supported;
d955 4
a958 20
static int use_directory = -1;

static char *get_short_pathname PROTO((const char *));

static char *
get_short_pathname (name)
    const char *name;
{
    const char *retval;
    if (use_directory)
	return (char *) name;
    if (strncmp (name, toplevel_repos, strlen (toplevel_repos)) != 0)
	error (1, 0, "server bug: name `%s' doesn't specify file in `%s'",
	       name, toplevel_repos);
    retval = name + strlen (toplevel_repos) + 1;
    if (retval[-1] != '/')
	error (1, 0, "server bug: name `%s' doesn't specify file in `%s'",
	       name, toplevel_repos);
    return (char *) retval;
}
d971 1
a971 1
static char *last_dirname;
d980 1
a980 3
    static List *last_entries;

    char *dirname;
d982 7
a988 2
    /* Just the part of pathname relative to toplevel_repos.  */
    char *short_pathname = get_short_pathname (pathname);
d1011 2
a1012 2
    if (use_directory)
	read_line (&reposname, 0);
d1015 1
a1015 1
    if (reposname != NULL)
d1017 7
a1023 1
	if (strncmp (reposname, toplevel_repos, strlen (toplevel_repos)) != 0)
a1027 13
	else
	{
	    short_repos = reposname + strlen (toplevel_repos) + 1;
	    if (short_repos[-1] != '/')
	    {
		reposdirname_absolute = 1;
		short_repos = reposname;
	    }
	}
    }
    else
    {
	short_repos = short_pathname;
d1039 2
a1040 2
    dirname = xstrdup (short_pathname);
    p = strrchr (dirname, '/');
d1043 2
a1044 2
	dirname = xrealloc (dirname, 2);
	dirname[0] = '.'; dirname[1] = '\0';
d1049 1
a1049 1
	add_prune_candidate (dirname);
d1057 6
a1062 1
    if (reposname != NULL)
d1064 1
a1064 1
	/* This is the use_directory case.  */
d1066 3
a1068 4
	short_pathname = xmalloc (strlen (pathname) + strlen (filename) + 5);
	strcpy (short_pathname, pathname);
	strcat (short_pathname, filename);
    }
d1070 3
a1072 6
    if (last_dirname == NULL
	|| strcmp (last_dirname, dirname) != 0)
    {
	if (last_dirname)
	    free (last_dirname);
	last_dirname = dirname;
d1074 6
a1079 4
	if (toplevel_wd[0] == '\0')
	    if (getwd (toplevel_wd) == NULL)
		error (1, 0,
		       "could not get working directory: %s", toplevel_wd);
d1081 1
a1081 1
	if (chdir (toplevel_wd) < 0)
d1083 41
a1123 1
	if (chdir (dirname) < 0)
d1128 2
a1129 2
	    if (errno != ENOENT)
		error (1, errno, "could not chdir to %s", dirname);
d1132 9
a1140 2
	    dir = xmalloc (strlen (dirname) + 1);
	    dirp = dirname;
d1152 1
a1152 1
	       As you can see, we're just stepping along DIRNAME (with
d1156 1
a1156 1
	       module, however, since DIRNAME and REPOSDIRNAME are not
d1167 3
a1169 3
		  {
		    strncpy (dir, dirname, dirp - dirname);
		    dir[dirp - dirname] = '\0';
d1173 4
a1176 2
		      error (0, 0,
			     "internal error: repository string too short.");
d1178 2
a1179 2
		      rdirp = strchr (rdirp, '/');
		  }
d1181 1
a1181 1
		  {
d1198 10
a1207 2
		    strcpy (dir, dirname);
		  }
d1209 1
a1209 1
		if (CVS_MKDIR (dir, 0777) < 0)
a1210 3
		    if (errno != EEXIST)
			error (1, errno, "cannot make directory %s", dir);
		    
d1225 1
a1225 1
		    char *r;
d1241 7
d1255 1
a1255 1
				  (char *)NULL, (char *)NULL);
d1257 10
d1278 2
a1279 2
	    if (chdir (dirname) < 0)
		error (1, errno, "could not chdir to %s", dirname);
d1284 22
a1305 3
	    if (last_entries)
		Entries_Close (last_entries);
	    last_entries = Entries_Open (0);
d1309 1
a1309 1
	free (dirname);
d1312 2
a1313 5
    if (reposname != NULL)
    {
	free (short_pathname);
	free (reposname);
    }
d1324 16
d1341 2
a1342 1
    read_line (&newname, 0);
d1349 2
a1350 2
     char *args;
     int len;
d1355 121
d1487 2
a1488 2
     char *args;
     int len;
d1516 36
d1575 6
a1580 1
      UPDATE_ENTRIES_PATCH
d1583 9
d1610 54
a1663 1
    read_line (&entries_line, 0);
d1666 2
a1667 1
	|| data->contents == UPDATE_ENTRIES_PATCH)
a1671 3
	int size_read;
	int size_left;
	int fd;
a1672 1
	char *buf2;
d1674 2
a1675 2
	int use_gzip, gzip_status;
	pid_t gzip_pid = 0;
d1677 1
a1677 1
	read_line (&mode_string, 0);
d1679 1
a1679 1
	read_line (&size_string, 0);
d1692 92
d1785 5
d1792 1
a1792 1
#else
d1794 3
a1796 1
#endif
a1797 3
	fd = open (temp_filename, O_WRONLY | O_CREAT | O_TRUNC, 0777);
	if (fd < 0)
	    error (1, errno, "writing %s", short_pathname);
d1799 20
a1818 2
	if (use_gzip)
	    fd = filter_through_gunzip (fd, 0, &gzip_pid);
d1820 3
a1822 1
	if (size > 0)
d1824 31
a1854 16
	    buf2 = buf;
	    size_left = size;
	    while ((size_read = fread (buf2, 1, size_left, from_server)) != size_left)
	    {
		if (feof (from_server))
		    /* FIXME: Should delete temp_filename.  */
		    error (1, 0, "unexpected end of file from server");
		else if (ferror (from_server))
		    /* FIXME: Should delete temp_filename.  */
		    error (1, errno, "reading from server");
		else
		  {
		    /* short reads are ok if we keep trying */
		    buf2 += size_read;
		    size_left -= size_read;
		  }
d1856 2
a1857 1
	    if (write (fd, buf, size) != size)
d1860 18
a1877 17
	if (close (fd) < 0)
	    error (1, errno, "writing %s", short_pathname);
	if (gzip_pid > 0)
	{
	    if (waitpid (gzip_pid, &gzip_status, 0) == -1)
		error (1, errno, "waiting for gzip process %d", gzip_pid);
	    else if (gzip_status != 0)
		error (1, 0, "gzip process exited %d", gzip_status);
	}

	gzip_pid = -1;

	/* Since gunzip writes files without converting LF to CRLF
	   (a reasonable behavior), we now have a patch file in LF
	   format.  Leave the file as is if we're just going to feed
	   it to patch; patch can handle it.  However, if it's the
	   final source file, convert it.  */
a1880 12
#ifdef LINES_CRLF_TERMINATED
	    if (use_gzip)
	    {
	        convert_file (temp_filename, O_RDONLY | OPEN_BINARY,
	    		      filename, O_WRONLY | O_CREAT | O_TRUNC);
	        if (unlink (temp_filename) < 0)
	            error (0, errno, "warning: couldn't delete %s", temp_filename);
	    }
	    else
		rename_file (temp_filename, filename);
	        
#else
d1882 11
a1892 1
#endif
d1896 7
a1902 3
	    int retcode;
	    char backup[PATH_MAX];
	    struct stat s;
a1903 2
	    (void) sprintf (backup, "%s~", filename);
	    (void) unlink_file (backup);
d1907 14
a1920 4
	    if (stat (temp_filename, &s) < 0)
	        error (1, 1, "can't stat patch file %s", temp_filename);
	    if (s.st_size == 0)
	        retcode = 0;
d1923 23
a1945 15
	        run_setup ("%s -f -s -b ~ %s %s", PATCH_PROGRAM,
			   filename, temp_filename);
		retcode = run_exec (DEVNULL, RUN_TTY, RUN_TTY, RUN_NORMAL);
	    }
	    /* FIXME: should we really be silently ignoring errors?  */
	    (void) unlink_file (temp_filename);
	    if (retcode == 0)
	    {
		/* FIXME: should we really be silently ignoring errors?  */
		(void) unlink_file (backup);
	    }
	    else
	    {
	        int old_errno = errno;
		char *path_tmp;
d1947 3
a1949 23
	        if (isfile (backup))
		    rename_file (backup, filename);
       
		/* Get rid of the patch reject file.  */
		path_tmp = xmalloc (strlen (filename + 10));
		strcpy (path_tmp, filename);
		strcat (path_tmp, ".rej");
		/* FIXME: should we really be silently ignoring errors?  */
		(void) unlink_file (path_tmp);
		free (path_tmp);

		/* Save this file to retrieve later.  */
		failed_patches =
		    (char **) xrealloc ((char *) failed_patches,
					((failed_patches_count + 1)
					 * sizeof (char *)));
		failed_patches[failed_patches_count] =
		    xstrdup (short_pathname);
		++failed_patches_count;

		error (retcode == -1 ? 1 : 0, retcode == -1 ? old_errno : 0,
		       "could not patch %s%s", filename,
		       retcode == -1 ? "" : "; will refetch");
d1951 8
a1958 1
		stored_checksum_valid = 0;
d1960 1
a1960 1
		return;
d1962 2
d1965 1
d1968 1
a1968 1
	if (stored_checksum_valid)
d1971 1
a1971 1
	    struct MD5Context context;
d1986 1
a1986 1
	    e = fopen (filename, "r");
d1990 1
a1990 1
	    MD5Init (&context);
d1992 1
a1992 1
		MD5Update (&context, buf, len);
d1995 1
a1995 1
	    MD5Final (checksum, &context);
d2011 17
a2027 8
		/* Save this file to retrieve later.  */
		failed_patches =
		    (char **) xrealloc ((char *) failed_patches,
					((failed_patches_count + 1)
					 * sizeof (char *)));
		failed_patches[failed_patches_count] =
		    xstrdup (short_pathname);
		++failed_patches_count;
d2029 1
a2029 2
		return;
	    }
d2033 1
a2033 2
	    /* FIXME: we should be respecting the umask.  */
	    int status = change_mode (filename, mode_string);
d2037 2
d2042 38
a2085 9
	char *cp;
	char *user;
	char *vn;
	/* Timestamp field.  Always empty according to the protocol.  */
	char *ts;
	char *options;
	char *tag;
	char *date;
	char *tag_or_date;
d2089 1
a2089 33
	char *scratch_entries = xstrdup (entries_line);

	if (scratch_entries[0] != '/')
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	user = scratch_entries + 1;
	if ((cp = strchr (user, '/')) == NULL)
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	*cp++ = '\0';
	vn = cp;
	if ((cp = strchr (vn, '/')) == NULL)
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	*cp++ = '\0';
	
	ts = cp;
	if ((cp = strchr (ts, '/')) == NULL)
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	*cp++ = '\0';
	options = cp;
	if ((cp = strchr (options, '/')) == NULL)
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	*cp++ = '\0';
	tag_or_date = cp;

	/* If a slash ends the tag_or_date, ignore everything after it.  */
	cp = strchr (tag_or_date, '/');
	if (cp != NULL)
	    *cp = '\0';
	tag = (char *) NULL;
	date = (char *) NULL;
	if (*tag_or_date == 'T')
	    tag = tag_or_date + 1;
	else if (*tag_or_date == 'D')
	    date = tag_or_date + 1;
d2094 2
d2105 1
d2108 12
d2122 4
d2138 1
d2150 1
d2162 29
d2202 2
d2215 15
d2260 5
d2282 1
a2282 3
    char *short_pathname;

    if (strcmp (toplevel_repos, server_cvsroot) != 0)
d2285 1
a2285 17
    if (!use_directory)
    {
	if (strncmp (pathname, server_cvsroot, strlen (server_cvsroot)) != 0)
	    error (1, 0,
		   "server bug: pathname `%s' doesn't specify file in `%s'",
		   pathname, server_cvsroot);
	short_pathname = pathname + strlen (server_cvsroot) + 1;
	if (short_pathname[-1] != '/')
	    error (1, 0,
		   "server bug: pathname `%s' doesn't specify file in `%s'",
		   pathname, server_cvsroot);
	return strchr (short_pathname, '/') == NULL;
    }
    else
    {
	return strchr (pathname, '/') == NULL;
    }
d2309 1
a2309 1
	read_line (NULL, 0);
d2322 1
a2322 1
    if (unlink_file (CVSADM_ENTSTAT) < 0 && errno != ENOENT)
d2334 1
a2334 1
	read_line (NULL, 0);
d2359 15
a2373 2
    read_line (&tagspec, 0);
    f = open_file (CVSADM_TAG, "w+");
d2389 1
a2389 1
	read_line (NULL, 0);
d2391 1
a2391 1
	(void) read_line (NULL, 0);
d2402 1
a2402 1
	read_line (NULL, 0);
d2404 1
a2404 1
	(void) read_line (NULL, 0);
d2418 1
a2418 1
    if (unlink_file (CVSADM_TAG) < 0 && errno != ENOENT)
d2430 1
a2430 1
	read_line (NULL, 0);
a2445 5
struct save_prog {
    char *name;
    char *dir;
    struct save_prog *next;
};
d2447 1
a2447 2
static struct save_prog *checkin_progs;
static struct save_prog *update_progs;
d2449 37
a2485 5
/*
 * Unlike some requests this doesn't include the repository.  So we can't
 * just call call_in_directory and have the right thing happen; we save up
 * the requests and do them at the end.
 */
d2493 1
a2493 1
    read_line (&prog, 0);
d2508 1
a2508 1
    read_line (&prog, 0);
d2524 1
a2524 1
    char fname[PATH_MAX];
d2526 6
a2531 5
    if (toplevel_wd[0] != '\0')
      {
	if (chdir (toplevel_wd) < 0)
	  error (1, errno, "could not chdir to %s", toplevel_wd);
      }
d2534 1
d2546 1
d2549 1
a2549 1
    for (p = update_progs; p != NULL; p = p->next)
d2551 1
d2560 1
d2562 2
a2567 39
static int client_isemptydir PROTO((char *));

/*
 * Returns 1 if the argument directory exists and is completely empty,
 * other than the existence of the CVS directory entry.  Zero otherwise.
 */
static int
client_isemptydir (dir)
    char *dir;
{
    DIR *dirp;
    struct dirent *dp;

    if ((dirp = opendir (dir)) == NULL)
    {
	if (errno != ENOENT)
	    error (0, errno, "cannot open directory %s for empty check", dir);
	return (0);
    }
    errno = 0;
    while ((dp = readdir (dirp)) != NULL)
    {
	if (strcmp (dp->d_name, ".") != 0 && strcmp (dp->d_name, "..") != 0 &&
	    strcmp (dp->d_name, CVSADM) != 0)
	{
	    (void) closedir (dirp);
	    return (0);
	}
    }
    if (errno != 0)
    {
	error (0, errno, "cannot read directory %s", dir);
	(void) closedir (dirp);
	return (0);
    }
    (void) closedir (dirp);
    return (1);
}

d2581 3
a2583 1
    if (dir[0] == '.' && dir[1] == '\0')
d2599 5
a2603 5
    if (toplevel_wd[0] != '\0')
      {
	if (chdir (toplevel_wd) < 0)
	  error (1, errno, "could not chdir to %s", toplevel_wd);
      }
d2606 1
a2606 1
	if (client_isemptydir (p->dir))
d2608 12
a2619 3
	    run_setup ("%s -fr", RM);
	    run_arg (p->dir);
	    (void) run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
d2626 1
d2644 21
d2678 16
d2697 1
a2697 4
    if (use_directory == -1)
	use_directory = supported_request ("Directory");

    if (use_directory)
d2699 24
a2722 4
	if (fprintf (to_server, "Directory ") < 0)
	    error (1, errno, "writing to server");
	if (fprintf (to_server, "%s", update_dir) < 0)
	    error (1, errno, "writing to server");
a2723 9
	if (fprintf (to_server, "\n%s\n", repos)
	    < 0)
	    error (1, errno, "writing to server");
    }
    else
    {
	if (fprintf (to_server, "Repository %s\n", repos) < 0)
	    error (1, errno, "writing to server");
    }
d2735 1
a2735 2
	    if (fprintf (to_server, "Static-directory\n") < 0)
		error (1, errno, "writing to server");
d2746 1
a2746 1
	f = fopen (adm_name, "r");
d2749 1
a2749 1
	    if (errno != ENOENT)
d2755 2
a2756 3
	    char *nl;
	    if (fprintf (to_server, "Sticky ") < 0)
		error (1, errno, "writing to server");
d2759 1
a2759 2
		if (fprintf (to_server, "%s", line) < 0)
		    error (1, errno, "writing to server");
d2765 1
a2765 2
		if (fprintf (to_server, "\n") < 0)
		    error (1, errno, "writing to server");
d2778 1
a2778 1
	f = fopen (adm_name, "r");
d2781 1
a2781 1
	    if (errno != ENOENT)
d2787 4
a2790 3
	    char *nl;
	    if (fprintf (to_server, "Checkin-prog ") < 0)
		error (1, errno, "writing to server");
d2793 2
a2794 2
		if (fprintf (to_server, "%s", line) < 0)
		    error (1, errno, "writing to server");
d2800 1
a2800 2
		if (fprintf (to_server, "\n") < 0)
		    error (1, errno, "writing to server");
d2813 1
a2813 1
	f = fopen (adm_name, "r");
d2816 1
a2816 1
	    if (errno != ENOENT)
d2822 4
a2825 3
	    char *nl;
	    if (fprintf (to_server, "Update-prog ") < 0)
		error (1, errno, "writing to server");
d2828 2
a2829 2
		if (fprintf (to_server, "%s", line) < 0)
		    error (1, errno, "writing to server");
d2835 1
a2835 2
		if (fprintf (to_server, "\n") < 0)
		    error (1, errno, "writing to server");
d2840 1
a2849 1
static void send_a_repository PROTO((char *, char *, char *));
d2851 1
a2851 1
static void
d2888 9
a2901 3
		int slashes_in_update_dir;
		int slashes_skipped;
		char *p;
d2903 31
a2933 8
		slashes_in_update_dir = 0;
		for (p = update_dir; *p != '\0'; ++p)
		    if (*p == '/')
			++slashes_in_update_dir;

		slashes_skipped = 0;
		p = repository + strlen (repository);
		while (1)
d2935 1
a2935 10
		    if (p == repository)
			error (1, 0,
			       "internal error: not enough slashes in %s",
			       repository);
		    if (*p == '/')
			++slashes_skipped;
		    if (slashes_skipped < slashes_in_update_dir + 1)
			--p;
		    else
			break;
a2936 4
		toplevel_repos = xmalloc (p - repository + 1);
		/* Note that we don't copy the trailing '/'.  */
		strncpy (toplevel_repos, repository, p - repository);
		toplevel_repos[p - repository] = '\0';
d2944 1
d2972 4
d2985 6
d2993 4
a2996 3
    send_a_repository ("", server_cvsroot, "");
    if (fprintf (to_server, "expand-modules\n") < 0)
	error (1, errno, "writing to server");
d3005 1
a3005 1
	error (errs, 0, "");
d3009 4
a3012 2
client_send_expansions (local)
     int local;
d3016 9
d3027 1
a3027 1
	argv[0] = modules_vector[i];
d3029 1
a3029 3
	    send_files (1, argv, local, 0);
	else
	    send_file_names (1, argv);
d3031 1
a3031 1
    send_a_repository ("", server_cvsroot, "");
d3037 38
a3074 1
    send_a_repository ("", server_cvsroot, "");
d3076 1
d3083 47
a3129 2
  fwrite (args, len, sizeof (*args), stdout);
  putc ('\n', stdout);
d3137 141
a3277 2
  fwrite (args, len, sizeof (*args), stderr);
  putc ('\n', stderr);
d3288 1
a3288 1
#else
d3290 1
a3290 1
#endif
d3302 3
d3307 3
d3323 2
d3329 1
d3332 3
d3336 1
d3338 2
d3349 78
d3429 1
a3429 2
 * error, 0 for success.
 */
d3439 1
a3439 1
	len = read_line (&cmd, 0);
d3460 10
d3475 18
a3492 1
    return rs->type == response_type_error ? 1 : 0;
d3498 10
d3512 7
d3525 21
a3545 2
#ifdef HAVE_KERBEROS
    if (server_fd != -1)
d3547 2
a3548 7
	if (shutdown (server_fd, 1) < 0)
	    error (1, errno, "shutting down connection to %s", server_host);
	/*
	 * In this case, both sides of the net connection will use the
         * same fd.
	 */
	if (fileno (from_server) != fileno (to_server))
d3550 13
a3562 2
	    if (fclose (to_server) != 0)
		error (1, errno, "closing down connection to %s", server_host);
d3564 1
a3564 2
    }
    else
d3566 1
d3568 14
a3581 6
    SHUTDOWN_SERVER (fileno (to_server));
#else
    {
	if (fclose (to_server) == EOF)
	    error (1, errno, "closing connection to %s", server_host);
    }
d3583 5
a3587 4
    if (getc (from_server) != EOF)
	error (0, 0, "dying gasps from %s unexpected", server_host);
    else if (ferror (from_server))
	error (0, errno, "reading from %s", server_host);
d3589 3
a3591 2
    fclose (from_server);
#endif
a3592 1
#if !RSH_NOT_TRANSPARENT
d3595 16
a3610 2
      error (1, errno, "waiting for process %d", rsh_pid);
#endif
d3615 1
a3615 1
#ifndef RSH_NOT_TRANSPARENT
d3621 1
a3621 1
     char *name;
d3623 1
a3623 1
  struct request *rq;
d3625 6
a3630 4
  for (rq = requests; rq->name; rq++)
    if (!strcmp (rq->name, name))
      return rq->status == rq_supported;
  error (1, 0, "internal error: testing support for unknown option?");
d3633 4
a3636 1
/* Contact the server.  */
d3638 5
a3642 2
void
start_server ()
d3644 2
a3645 2
    int tofd, fromfd;
    char *log = getenv ("CVS_CLIENT_LOG");
d3647 5
a3651 1
#if HAVE_KERBEROS
d3653 45
a3697 9
	struct hostent *hp;
	char *hname;
	const char *realm;
	const char *portenv;
	int port;
	struct sockaddr_in sin;
	int s;
	KTEXT_ST ticket;
	int status;
d3699 8
a3706 13
	/*
	 * We look up the host to give a better error message if it
	 * does not exist.  However, we then pass server_host to
	 * krb_sendauth, rather than the canonical name, because
	 * krb_sendauth is going to do its own canonicalization anyhow
	 * and that lets us not worry about the static storage used by
	 * gethostbyname.
	 */
	hp = gethostbyname (server_host);
	if (hp == NULL)
	    error (1, 0, "%s: unknown host", server_host);
	hname = xmalloc (strlen (hp->h_name) + 1);
	strcpy (hname, hp->h_name);
d3708 2
a3709 1
	realm = krb_realmofhost (hname);
d3711 2
a3712 2
	portenv = getenv ("CVS_CLIENT_PORT");
	if (portenv != NULL)
d3714 2
a3715 4
	    port = atoi (portenv);
	    if (port <= 0)
		goto try_rsh_no_message;
	    port = htons (port);
d3717 34
a3750 3
	else
	{
	    struct servent *sp;
d3752 1
a3752 6
	    sp = getservbyname ("cvs", "tcp");
	    if (sp == NULL)
		port = htons (CVS_PORT);
	    else
		port = sp->s_port;
	}
d3754 2
a3755 3
	s = socket (AF_INET, SOCK_STREAM, 0);
	if (s < 0)
	    error (1, errno, "socket");
d3757 1
a3757 4
	memset (&sin, 0, sizeof sin);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;
	sin.sin_port = 0;
d3759 2
a3760 2
	if (bind (s, (struct sockaddr *) &sin, sizeof sin) < 0)
	    error (1, errno, "bind");
d3762 45
a3806 2
	memcpy (&sin.sin_addr, hp->h_addr, hp->h_length);
	sin.sin_port = port;
d3808 1
a3808 2
	tofd = -1;
	if (connect (s, (struct sockaddr *) &sin, sizeof sin) < 0)
d3810 2
a3811 2
	    error (0, errno, "connect");
	    close (s);
d3815 49
a3863 5
	    struct sockaddr_in laddr;
	    int laddrlen;
	    MSG_DAT msg_data;
	    CREDENTIALS cred;
	    Key_schedule sched;
d3865 5
a3869 3
	    laddrlen = sizeof (laddr);
	    if (getsockname (s, (struct sockaddr *) &laddr, &laddrlen) < 0)
	        error (1, errno, "getsockname");
d3871 14
a3884 5
	    /* We don't care about the checksum, and pass it as zero.  */
	    status = krb_sendauth (KOPT_DO_MUTUAL, s, &ticket, "rcmd",
				   hname, realm, (unsigned long) 0, &msg_data,
				   &cred, sched, &laddr, &sin, "KCVSV1.0");
	    if (status != KSUCCESS)
d3886 2
a3887 2
	        error (0, 0, "kerberos: %s", krb_get_err_text(status));
		close (s);
d3891 2
a3892 8
		server_fd = s;
		close_on_exec (server_fd);
		/*
		 * If we do any filtering, TOFD and FROMFD will be
		 * closed.  So make sure they're copies of SERVER_FD,
		 * and not the same fd number.
		 */
		if (log)
d3894 7
a3900 2
		    tofd = dup (s);
		    fromfd = dup (s);
d3902 3
a3904 2
		else
		    tofd = fromfd = s;
d3906 214
d4122 1
a4122 1
	if (tofd == -1)
d4124 94
a4217 4
	    error (0, 0, "trying to start server using rsh");
	  try_rsh_no_message:
	    server_fd = -1;
#if ! RSH_NOT_TRANSPARENT
d4219 16
d4236 28
a4263 7
#if defined (START_SERVER)
            START_SERVER (&tofd, &fromfd, getcaller (),
                          server_user, server_host, server_cvsroot);
#endif /* START_SERVER */
#endif /* RSH_NOT_TRANSPARENT */
	}
	free (hname);
d4265 16
d4282 6
a4287 13
#else /* ! HAVE_KERBEROS */
#if ! RSH_NOT_TRANSPARENT
    start_rsh_server (&tofd, &fromfd);
#else
#if defined(START_SERVER)
    /* This is all a real mess.  We now have three ways of connecting
       to the server, and there's a fourth on the horizon.  We should
       clean this all up before adding the fourth.  */
    START_SERVER (&tofd, &fromfd, getcaller (),
                  server_user, server_host, server_cvsroot);
#endif /* START_SERVER */
#endif /* RSH_NOT_TRANSPARENT */
#endif /* ! HAVE_KERBEROS */
d4289 6
a4294 2
    close_on_exec (tofd);
    close_on_exec (fromfd);
d4296 1
d4300 1
a4300 1
	char *buf = xmalloc (5 + len);
d4302 1
a4302 1
	static char *teeprog[3] = { "tee" };
a4303 1
	teeprog[1] = buf;
d4307 7
d4315 6
a4320 1
	tofd = filter_stream_through_program (tofd, 0, teeprog, 0);
d4323 6
a4328 1
	fromfd = filter_stream_through_program (fromfd, 1, teeprog, 0);
a4332 9
    /* Should be using binary mode on systems which have it.  */
    to_server = fdopen (tofd, FOPEN_BINARY_WRITE);
    if (to_server == NULL)
	error (1, errno, "cannot fdopen %d for write", tofd);
    /* Should be using binary mode on systems which have it.  */
    from_server = fdopen (fromfd, FOPEN_BINARY_READ);
    if (from_server == NULL)
	error (1, errno, "cannot fdopen %d for read", fromfd);

d4335 1
a4335 1
        free (toplevel_repos);
d4337 3
a4339 3
    if (last_dirname != NULL)
        free (last_dirname);
    last_dirname = NULL;
d4341 1
a4341 1
        free (last_repos);
d4344 1
a4344 1
        free (last_update_dir);
d4347 12
a4359 2
    if (fprintf (to_server, "Root %s\n", server_cvsroot) < 0)
	error (1, errno, "writing to server");
d4362 3
a4364 2
	if (fprintf (to_server, "Valid-responses") < 0)
	    error (1, errno, "writing to server");
d4367 2
a4368 2
	    if (fprintf (to_server, " %s", rs->name) < 0)
		error (1, errno, "writing to server");
d4370 1
a4370 2
	if (fprintf (to_server, "\n") < 0)
	    error (1, errno, "writing to server");
d4372 2
a4373 2
    if (fprintf (to_server, "valid-requests\n") < 0)
	error (1, errno, "writing to server");
d4375 1
a4375 1
	exit (1);
d4398 1
a4398 2
		if (fprintf (to_server, "Global_option -n\n") < 0)
		    error (1, errno, "writing to server");
d4408 1
a4408 2
		if (fprintf (to_server, "Global_option -q\n") < 0)
		    error (1, errno, "writing to server");
d4418 1
a4418 2
		if (fprintf (to_server, "Global_option -Q\n") < 0)
		    error (1, errno, "writing to server");
d4428 1
a4428 2
		if (fprintf (to_server, "Global_option -r\n") < 0)
		    error (1, errno, "writing to server");
d4438 1
a4438 2
		if (fprintf (to_server, "Global_option -t\n") < 0)
		    error (1, errno, "writing to server");
d4448 1
a4448 2
		if (fprintf (to_server, "Global_option -l\n") < 0)
		    error (1, errno, "writing to server");
d4455 69
d4525 31
a4555 6
      {
	if (supported_request ("gzip-file-contents"))
	  {
	    if (fprintf (to_server, "gzip-file-contents %d\n", gzip_level) < 0)
	      error (1, 0, "writing to server");
	  }
d4557 1
a4557 1
	  {
d4559 3
d4563 45
a4607 2
	  }
      }
d4610 2
a4611 1
#ifndef RSH_NOT_TRANSPARENT
d4614 98
d4725 1
a4725 1
	cvs_rsh = "rsh";
d4734 1
a4734 1
		       + strlen (server_cvsroot)
d4748 1
a4748 1
	*p++ = server_host;
d4753 1
a4753 1
	if (server_user != NULL)
d4756 1
a4756 1
	    *p++ = server_user;
d4776 1
d4778 5
a4782 1
#endif
d4790 1
d4792 3
a4794 2
    if (fprintf (to_server, "Argument ") < 0)
	error (1, errno, "writing to server");
d4799 1
a4799 2
	    if (fprintf (to_server, "\nArgumentx ") < 0)
		error (1, errno, "writing to server");
d4801 5
a4805 2
	else if (putc (*p, to_server) == EOF)
	    error (1, errno, "writing to server");
d4808 1
a4808 2
    if (putc ('\n', to_server) == EOF)
	error (1, errno, "writing to server");
d4811 8
a4818 2
void
send_modified (file, short_pathname)
d4821 1
d4828 5
a4832 1
    int bufsize;
d4835 1
a4835 1
    if (stat (file, &sb) < 0)
d4848 28
a4875 1
    fd = open (file, O_RDONLY);
d4879 1
a4879 1
    if (gzip_level && sb.st_size > 100)
d4881 7
a4887 21
	int nread, newsize = 0, gzip_status;
	pid_t gzip_pid;
	char *bufp = buf;
	int readsize = 8192;
#ifdef LINES_CRLF_TERMINATED
	char tempfile[L_tmpnam];
#endif

#ifdef LINES_CRLF_TERMINATED
	/* gzip reads and writes files without munging CRLF sequences, as it
	   should, but files should be transmitted in LF form.  Convert CRLF
	   to LF before gzipping, on systems where this is necessary.

	   If Windows NT supported fork, we could do this by pushing another
	   filter on in front of gzip.  But it doesn't.  I'd have to write a
	   trivial little program to do the conversion and have CVS spawn it
	   off.  But little executables like that always get lost.

	   Alternatively, this cruft could go away if we switched to a gzip
	   library instead of a subprocess; then we could tell gzip to open 
	   the file with CRLF translation enabled.  */
d4891 2
a4892 3
	tmpnam (tempfile);
	convert_file (file, O_RDONLY,
	              tempfile, O_WRONLY | O_CREAT | O_TRUNC | OPEN_BINARY);
d4894 7
a4900 36
	/* This OPEN_BINARY doesn't make any difference, I think, because
	   gzip will deal with the inherited handle as it pleases.  But I
	   do remember something obscure in the manuals about propagating
	   the translation mode to created processes via environment
	   variables, ick.  */
        fd = open (tempfile, O_RDONLY | OPEN_BINARY);
        if (fd < 0)
	    error (1, errno, "reading %s", short_pathname);
#endif

	fd = filter_through_gzip (fd, 1, gzip_level, &gzip_pid);
	while (1)
	{
	    if ((bufp - buf) + readsize >= bufsize)
	    {
		/*
		 * We need to expand the buffer if gzip ends up expanding
		 * the file.
		 */
		newsize = bufp - buf;
		while (newsize + readsize >= bufsize)
		  bufsize *= 2;
		buf = xrealloc (buf, bufsize);
		bufp = buf + newsize;
	    }
	    nread = read (fd, bufp, readsize);
	    if (nread < 0)
		error (1, errno, "reading from gzip pipe");
	    else if (nread == 0)
		/* eof */
		break;
	    bufp += nread;
	}
	newsize = bufp - buf;
	if (close (fd) < 0)
	    error (0, errno, "warning: can't close %s", short_pathname);
d4902 2
a4903 15
	if (waitpid (gzip_pid, &gzip_status, 0) != gzip_pid)
	    error (1, errno, "waiting for gzip proc %d", gzip_pid);
	else if (gzip_status != 0)
	    error (1, errno, "gzip exited %d", gzip_status);

#if LINES_CRLF_TERMINATED
	if (unlink (tempfile) < 0)
	    error (0, errno, "warning: can't remove temp file %s", tempfile);
#endif LINES_CRLF_TERMINATED

	fprintf (to_server, "Modified %s\n%s\nz%lu\n", file, mode_string,
		 (unsigned long) newsize);
	fwrite (buf, newsize, 1, to_server);
	if (feof (to_server) || ferror (to_server))
	    error (1, errno, "writing to server");
d4913 5
d4929 19
a4947 3
	if (fprintf (to_server, "Modified %s\n%s\n%lu\n", file,
		     mode_string, (unsigned long) newsize) < 0)
	    error (1, errno, "writing to server");
d4954 1
a4954 2
	    if (fwrite (buf, newsize, 1, to_server) != 1)
		error (1, errno, "writing to server");
d4960 14
d4976 3
a4978 6
send_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
d4980 1
d4982 4
a4985 6
    int update_dir_len = strlen (update_dir);
    char *short_pathname = xmalloc (update_dir_len + strlen (file) + 40);
    strcpy (short_pathname, update_dir);
    if (update_dir[0] != '\0')
	strcat (short_pathname, "/");
    strcat (short_pathname, file);
d4987 6
a4992 1
    send_a_repository ("", repository, update_dir);
d4994 4
a4997 3
    vers = Version_TS ((char *)NULL, (char *)NULL, (char *)NULL,
		       (char *)NULL,
		       file, 0, 0, entries, (List *)NULL);
d5002 19
a5020 10
	/* Not sure about whether this deals with -k and stuff right.  */
	if (fprintf (to_server, "Entry /%s/%s/%s%s/%s/", file, vers->vn_user,
		     vers->ts_conflict == NULL ? "" : "+",
		     (vers->ts_conflict == NULL ? ""
		      : (vers->ts_user != NULL &&
			 strcmp (vers->ts_conflict, vers->ts_user) == 0
			 ? "="
			 : "modified")),
		     vers->options) < 0)
	    error (1, errno, "writing to server");
d5023 2
a5024 2
	    if (fprintf (to_server, "T%s", vers->entdata->tag) < 0)
		error (1, errno, "writing to server");
d5027 40
a5066 4
	    if (fprintf (to_server, "D%s", vers->entdata->date) < 0)
		error (1, errno, "writing to server");
	if (fprintf (to_server, "\n") < 0)
	    error (1, errno, "writing to server");
d5075 2
a5076 11
	/* File no longer exists.  */
	if (!use_unchanged)
	{
	    /* if the server is old, use the old request... */
	    if (fprintf (to_server, "Lost %s\n", file) < 0)
		error (1, errno, "writing to server");
	    /*
	     * Otherwise, don't do anything for missing files,
	     * they just happen.
	     */
	}
d5079 1
d5082 9
a5090 1
	send_modified (file, short_pathname);
d5094 3
a5096 4
	/* Only use this request if the server supports it... */
	if (use_unchanged)
	    if (fprintf (to_server, "Unchanged %s\n", file) < 0)
		error (1, errno, "writing to server");
d5106 1
a5106 1
	p->key = xstrdup (file);
d5110 1
a5110 1
    free (short_pathname);
d5114 44
d5167 2
a5168 1
send_dirent_proc (dir, repository, update_dir)
d5172 1
d5174 1
d5176 1
a5176 7
    char *cvsadm_repos_name;

    /*
     * If the directory does not exist yet (e.g. "cvs update -d
     * foo"), no need to send any files from it.
     */
    dir_exists = isdir (dir);
d5186 13
d5207 1
a5207 3
    cvsadm_repos_name = xmalloc (strlen (dir) + sizeof (CVSADM_REP) + 80);
    sprintf (cvsadm_repos_name, "%s/%s", dir, CVSADM_REP);
    if (dir_exists && isreadable (cvsadm_repos_name))
d5219 18
a5236 2
	send_a_repository (dir, repository, update_dir);
    free (cvsadm_repos_name);
d5243 2
a5244 2
 * This assumes that the options are single characters.  For
 * more complex parsing, do it yourself.
d5251 1
a5252 1
    char it[3];
d5254 16
a5269 9
    for (p = string; p[0]; p++) {
	if (p[0] == ' ')
	    continue;
	if (p[0] == '-')
	    continue;
	it[0] = '-';
	it[1] = p[0];
	it[2] = '\0';
	send_arg (it);
d5271 1
d5278 1
a5278 1
send_file_names (argc, argv)
d5281 1
a5283 2
    char *p;
    char *q;
d5286 5
d5296 3
a5298 19
	p = argv[i];
	level = 0;
	do
	{
	    q = strchr (p, '/');
	    if (q != NULL)
		++q;
	    if (p[0] == '.' && p[1] == '.' && (p[2] == '\0' || p[2] == '/'))
	    {
		--level;
		if (-level > max_level)
		    max_level = -level;
	    }
	    else if (p[0] == '.' && (p[1] == '\0' || p[1] == '/'))
		;
	    else
		++level;
	    p = q;
	} while (p != NULL);
d5304 6
a5309 2
	    if (fprintf (to_server, "Max-dotdot %d\n", max_level) < 0)
		error (1, errno, "writing to server");
d5322 79
a5400 1
	send_arg (argv[i]);
d5404 9
a5412 7
/*
 * Send Repository, Modified and Entry.  argc and argv contain only
 * the files to operate on (or empty for everything), not options.
 * local is nonzero if we should not recurse (-l option).  Also sends
 * Argument lines for argc and argv, so should be called after options
 * are sent.
 */
d5414 1
a5414 1
send_files (argc, argv, local, aflag)
d5419 1
d5421 1
a5423 2
    send_file_names (argc, argv);

d5429 3
d5433 3
a5435 3
	(send_fileproc, update_filesdone_proc,
	 send_dirent_proc, (int (*) ())NULL,
	 argc, argv, local, W_LOCAL, aflag, 0, (char *)NULL, 0, 0);
d5437 1
a5437 1
	exit (1);
d5446 1
a5446 1
	toplevel_repos = xstrdup (server_cvsroot);
d5462 2
a5463 1
client_process_import_file (message, vfile, vtag, targc, targv, repository)
d5470 4
d5475 3
a5477 2
    char *short_pathname;
    int first_time;
d5479 1
a5479 7
    /* FIXME: I think this is always false now that we call
       client_import_setup at the start.  */

    first_time = toplevel_repos == NULL;

    if (first_time)
	send_a_repository ("", repository, "");
a5484 1
    short_pathname = repository + strlen (toplevel_repos) + 1;
d5486 6
a5491 1
    if (!first_time)
d5493 6
a5498 1
	send_a_repository ("", repository, short_pathname);
d5500 49
a5548 1
    send_modified (vfile, short_pathname);
d5565 1
a5565 1
	toplevel_repos = xstrdup (server_cvsroot);
d5569 6
a5574 8
/*
 * Send an option with an argument, dealing correctly with newlines in
 * the argument.  If ARG is NULL, forget the whole thing.
 */
void
option_with_arg (option, arg)
    char *option;
    char *arg;
d5576 8
a5583 6
    if (arg == NULL)
	return;
    if (fprintf (to_server, "Argument %s\n", option) < 0)
	error (1, errno, "writing to server");
    send_arg (arg);
}
d5585 21
a5605 7
/*
 * Send a date to the server.  This will passed a string which is the
 * result of Make_Date, and looks like YY.MM.DD.HH.MM.SS, where all
 * the letters are single digits.  The time will be GMT.  getdate on
 * the server can't parse that, so we turn it back into something
 * which it can parse.
 */
d5607 53
a5659 6
void
client_senddate (date)
    const char *date;
{
    int year, month, day, hour, minute, second;
    char buf[100];
a5660 2
    if (sscanf (date, DATEFORM, &year, &month, &day, &hour, &minute, &second)
	!= 6)
d5662 5
a5666 1
        error (1, 0, "diff_client_senddate: sscanf failed on date");
d5669 6
a5674 8
#ifndef HAVE_RCS5
    /* We need to fix the timezone in this case; see Make_Date.  */
    abort ();
#endif

    sprintf (buf, "%d/%d/%d %d:%d:%d GMT", month, day, year,
	     hour, minute, second);
    option_with_arg ("-D", buf);
a5675 7

int
client_commit (argc, argv)
    int argc;
    char **argv;
{
    parse_cvsroot ();
d5677 4
a5680 7
    return commit (argc, argv);
}

int
client_update (argc, argv)
    int argc;
    char **argv;
d5682 1
a5682 3
    parse_cvsroot ();

    return update (argc, argv);
d5685 7
a5691 4
int
client_checkout (argc, argv)
    int argc;
    char **argv;
d5693 1
a5693 4
    parse_cvsroot ();
    
    return checkout (argc, argv);
}
d5695 9
a5703 8
int
client_diff (argc, argv)
    int argc;
    char **argv;
{
    parse_cvsroot ();

    return diff (argc, argv);	/* Call real code */
d5705 9
a5713 5

int
client_status (argc, argv)
    int argc;
    char **argv;
d5715 2
a5716 3
    parse_cvsroot ();
    return status (argc, argv);
}
d5718 3
a5720 10
int
client_log (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return cvslog (argc, argv);	/* Call real code */
}
d5722 1
a5722 9
int
client_add (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return add (argc, argv);	/* Call real code */
d5725 2
a5726 10
int
client_remove (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return cvsremove (argc, argv);	/* Call real code */
}
d5728 3
a5730 10
int
client_rdiff (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return patch (argc, argv);	/* Call real code */
}
d5732 3
a5734 4
int
client_tag (argc, argv)
    int argc;
    char **argv;
d5736 1
a5736 5
    
    parse_cvsroot ();
    
    return tag (argc, argv);	/* Call real code */
}
d5738 2
a5739 9
int
client_rtag (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return rtag (argc, argv);	/* Call real code */
d5741 3
a5743 16

int
client_import (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return import (argc, argv);	/* Call real code */
}

int
client_admin (argc, argv)
    int argc;
    char **argv;
d5745 4
a5748 37
    
    parse_cvsroot ();
    
    return admin (argc, argv);	/* Call real code */
}

int
client_export (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return checkout (argc, argv);	/* Call real code */
}

int
client_history (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return history (argc, argv);	/* Call real code */
}

int
client_release (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return release (argc, argv);	/* Call real code */
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a3 1
#include "getline.h"
d7 1
d10 3
a12 1
#if defined(AUTH_CLIENT_SUPPORT) || HAVE_KERBEROS
a15 9
#endif /* defined(AUTH_CLIENT_SUPPORT) || HAVE_KERBEROS */

#ifdef AUTH_CLIENT_SUPPORT
char *get_cvs_password PROTO((char *user, char *host, char *cvsrooot));
#endif /* AUTH_CLIENT_SUPPORT */

#if HAVE_KERBEROS
#define CVS_PORT 1999

d21 2
a22 3
#endif /* HAVE_KRB_GET_ERR_TEXT */
#endif /* HAVE_KERBEROS */

a64 1
static void handle_notified PROTO((char *, int));
d79 1
a79 1
#else /* ! __STDC__ */
d82 1
a82 1
#endif /* __STDC__ */
a117 34
#ifdef CHMOD_BROKEN
    char *p;
    int writeable = 0;

    /* We can only distinguish between
         1) readable
         2) writeable
         3) Picasso's "Blue Period"
       We handle the first two. */
    p = mode_string;
    while (*p != '\0')
    {
	if ((p[0] == 'u' || p[0] == 'g' || p[0] == 'o') && p[1] == '=')
	{
	    char *q = p + 2;
	    while (*q != ',' && *q != '\0')
	    {
		if (*q == 'w')
		    writeable = 1;
		++q;
	    }
	}
	/* Skip to the next field.  */
	while (*p != ',' && *p != '\0')
	    ++p;
	if (*p == ',')
	    ++p;
    }

    xchmod (filename, writeable);
	return 0;

#else /* ! CHMOD_BROKEN */

a171 1

a174 1
#endif /* ! CHMOD_BROKEN */
a191 4
static int cvsroot_parsed = 0;

static List *ignlist = (List *) NULL;

a196 7
#ifdef AUTH_CLIENT_SUPPORT
    static char *access_method;
#endif /* AUTH_CLIENT_SUPPORT */

    /* Don't go through the trouble twice. */
    if (cvsroot_parsed)
      return;
a198 33

#ifdef AUTH_CLIENT_SUPPORT
    if ((server_host[0] == ':'))
    {
      /* Access method specified, as in
       * "cvs -d :pserver:user@@host:/path".
       * We need to get past that part of CVSroot before parsing the
       * rest of it.
       */
      access_method = p = &(server_host[1]);

      if (! *access_method)
        error (1, 0, "bad CVSroot: %s", CVSroot);

      if (! *(p = strchr (access_method, ':')))
        error (1, 0, "bad CVSroot: %s", CVSroot);
      
      *p = '\0';
      p++;

      server_host = p;
      
      if (! *server_host)
        error (1, 0, "bad CVSroot: %s", CVSroot);

      if (strcmp (access_method, "pserver") == 0)
        use_authenticating_server = 1;
      else
        error (1, 0, "unknown access method: %s", access_method);
    }
#endif /* AUTH_CLIENT_SUPPORT */
    
    /* First get just the pathname. */
d202 2
a203 4
    
    /* Then deal with host and possible user. */
    if ( (p = strchr (server_host, '@@')) == NULL)
    {
d205 1
a205 3
    }
    else
    {
a212 1
    cvsroot_parsed = 1;
a214 10
#ifdef NO_SOCKET_TO_FD
/* Under certain circumstances, we must communicate with the server
   via a socket using send() and recv().  This is because under some
   operating systems (OS/2 and Windows 95 come to mind), a socket
   cannot be converted to a file descriptor -- it must be treated as a
   socket and nothing else. */
static int use_socket_style = 0;
static int server_sock;
#endif /* NO_SOCKET_TO_FD */

d216 1
a216 1
static FILE *to_server;
d218 1
a218 5
static FILE *from_server;

/* We might want to log client/server traffic. */
static FILE *from_server_logfile;
static FILE *to_server_logfile;
d223 1
a223 2
#endif /* ! RSH_NOT_TRANSPARENT */

d226 1
a226 1
 * Read a line from the server.  Result does not include the terminating \n.
d240 2
a241 7
    size_t input_index = 0;
    size_t result_size = 80;

#ifdef NO_SOCKET_TO_FD
    if (! use_socket_style)
#endif /* NO_SOCKET_TO_FD */
      fflush (to_server);
d243 1
d248 1
a248 17

#ifdef NO_SOCKET_TO_FD
      if (use_socket_style)
        {
          char ch;
          /* Yes, this sucks performance-wise.  Short of implementing
             our own buffering, I'm not sure how to effect a big
             improvement.  We could at least avoid calling
             read_from_server() for each character if we were willing
             to duplicate a lot of its code, but I'm not sure that's
             worth it. */
          read_from_server (&ch, 1);
          c = ch;
        }
      else
#endif /* NO_SOCKET_TO_FD */
        c = getc (from_server);
d253 2
a254 7

#ifdef NO_SOCKET_TO_FD
            if (! use_socket_style)
#endif /* NO_SOCKET_TO_FD */
              if (ferror (from_server))
                error (1, errno, "reading from server");
            
a278 18
#ifdef NO_SOCKET_TO_FD
    if (! use_socket_style)
#endif /* NO_SOCKET_TO_FD */
    {
	/*
	 * If we're using socket style, then everything has already
	 * been logged because read_from_server() was used to get the
	 * individual chars, and read_from_server() logs already.
	 */
	if (from_server_logfile)
	{
	    if (fwrite (result, 1, input_index, from_server_logfile)
		< input_index)
		error (0, errno, "writing to from-server logfile");
	    putc ('\n', from_server_logfile);
	}
    }
    
a284 1

d309 1
a309 1
  static char *gunzip_argv[3] = { "gunzip", "-d" };
d395 2
a396 3
		send_to_server (rq->name, 0);
                send_to_server ("\012", 0);

d446 1
a446 1
static char *last_dir_name;
d457 1
a457 1
    char *dir_name;
d518 2
a519 2
    dir_name = xstrdup (short_pathname);
    p = strrchr (dir_name, '/');
d522 2
a523 2
	dir_name = xrealloc (dir_name, 2);
	dir_name[0] = '.'; dir_name[1] = '\0';
d528 1
a528 1
	add_prune_candidate (dir_name);
d545 2
a546 2
    if (last_dir_name == NULL
	|| strcmp (last_dir_name, dir_name) != 0)
d548 3
a550 3
	if (last_dir_name)
	    free (last_dir_name);
	last_dir_name = dir_name;
d559 1
a559 1
	if (chdir (dir_name) < 0)
d564 2
a565 2
	    if (! existence_error (errno))
		error (1, errno, "could not chdir to %s", dir_name);
d568 2
a569 2
	    dir = xmalloc (strlen (dir_name) + 1);
	    dirp = dir_name;
d581 1
a581 1
	       As you can see, we're just stepping along DIR_NAME (with
d585 1
a585 1
	       module, however, since DIR_NAME and REPOSDIRNAME are not
d597 2
a598 2
		    strncpy (dir, dir_name, dirp - dir_name);
		    dir[dirp - dir_name] = '\0';
d625 1
a625 1
		    strcpy (dir, dir_name);
d630 4
a633 25
                  /* Now, let me get this straight.  In IBM C/C++
                   * under OS/2, the error string for EEXIST is:
                   *
                   *     "The file already exists",
                   *
                   * and the error string for EACCESS is:
                   *
                   *     "The file or directory specified is read-only".
                   *
                   * Nonetheless, mkdir() will set EACCESS if the
                   * directory *exists*, according both to the
                   * documentation and its actual behavior.
                   *
                   * I'm sure that this made sense, to someone,
                   * somewhere, sometime.  Just not me, here, now.
                   */
#ifdef EACCESS
                  if ((errno != EACCESS) && (errno != EEXIST))
                    error (1, errno, "cannot make directory %s", dir);
#else /* ! defined(EACCESS) */
                  if ((errno != EEXIST))
                    error (1, errno, "cannot make directory %s", dir);
#endif /* defined(EACCESS) */
                  
                  /* It already existed, fine.  Just keep going.  */
d683 2
a684 2
	    if (chdir (dir_name) < 0)
		error (1, errno, "could not chdir to %s", dir_name);
d695 1
a695 1
	free (dir_name);
d721 2
a722 2
    char *args;
    int len;
d738 2
a739 2
    char *args;
    int len;
a766 18
static int stored_mode_valid;
static char *stored_mode;

static void handle_mode PROTO ((char *, int));

static void
handle_mode (args, len)
    char *args;
    int len;
{
    if (stored_mode_valid)
	error (1, 0, "protocol error: duplicate Mode");
    if (stored_mode != NULL)
	free (stored_mode);
    stored_mode = xstrdup (args);
    stored_mode_valid = 1;
}

a810 12
    char *cp;
    char *user;
    char *vn;
    /* Timestamp field.  Always empty according to the protocol.  */
    char *ts;
    char *options;
    char *tag;
    char *date;
    char *tag_or_date;
    char *scratch_entries;
    int bin;

a812 40
    /*
     * Parse the entries line.
     */
    if (strcmp (command_name, "export") != 0)
    {
	scratch_entries = xstrdup (entries_line);

	if (scratch_entries[0] != '/')
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	user = scratch_entries + 1;
	if ((cp = strchr (user, '/')) == NULL)
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	*cp++ = '\0';
	vn = cp;
	if ((cp = strchr (vn, '/')) == NULL)
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	*cp++ = '\0';
	
	ts = cp;
	if ((cp = strchr (ts, '/')) == NULL)
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	*cp++ = '\0';
	options = cp;
	if ((cp = strchr (options, '/')) == NULL)
	    error (1, 0, "bad entries line `%s' from server", entries_line);
	*cp++ = '\0';
	tag_or_date = cp;

	/* If a slash ends the tag_or_date, ignore everything after it.  */
	cp = strchr (tag_or_date, '/');
	if (cp != NULL)
	    *cp = '\0';
	tag = (char *) NULL;
	date = (char *) NULL;
	if (*tag_or_date == 'T')
	    tag = tag_or_date + 1;
	else if (*tag_or_date == 'D')
	    date = tag_or_date + 1;
    }

d819 2
d823 1
d846 1
a846 1
#else /* _POSIX_NO_TRUNC */
d848 1
a848 1
#endif /* _POSIX_NO_TRUNC */
d850 1
a850 19

        /* Some systems, like OS/2 and Windows NT, end lines with CRLF
           instead of just LF.  Format translation is done in the C
           library I/O funtions.  Here we tell them whether or not to
           convert -- if this file is marked "binary" with the RCS -kb
           flag, then we don't want to convert, else we do (because
           CVS assumes text files by default). */

        /* Actually, I don't believe options can be NULL here, but I'm
           not dead certain of that. */
        if (options)
          bin = !(strcmp (options, "-kb"));
        else
          bin = 0;

        fd = open (temp_filename,
                   O_WRONLY | O_CREAT | O_TRUNC | (bin ? OPEN_BINARY : 0),
                   0777);

d859 19
a877 4
          read_from_server (buf, size);
	    
          if (write (fd, buf, size) != size)
            error (1, errno, "writing %s", short_pathname);
a878 1

d900 1
a900 5

            /* `bin' is non-zero iff `options' contains "-kb", meaning
                treat this file as binary. */

	    if (use_gzip && (! bin))
d905 1
a905 2
	            error (0, errno, "warning: couldn't delete %s",
                           temp_filename);
d910 1
a910 1
#else /* ! LINES_CRLF_TERMINATED */
d912 1
a912 1
#endif /* LINES_CRLF_TERMINATED */
d951 1
a951 1
		path_tmp = xmalloc (strlen (filename) + 10);
a1039 2

	free (mode_string);
a1042 4
    if (stored_mode_valid)
	change_mode (filename, stored_mode);
    stored_mode_valid = 0;

d1049 9
d1061 34
a1097 2
	else
	    file_timestamp = NULL;
a1106 1
	{
a1107 2
	    mark_up_to_date (filename);
	}
a1110 4

	if (file_timestamp)
	    free (file_timestamp);

d1272 1
a1272 1
    if (unlink_file (CVSADM_ENTSTAT) < 0 && ! existence_error (errno))
d1355 1
a1355 1
    if (unlink_file (CVSADM_TAG) < 0 && ! existence_error (errno))
d1487 1
a1487 1
	if (! existence_error (errno))
d1549 3
a1551 1
          unlink_file_dir (p->dir);
d1596 8
a1603 5
	send_to_server ("Directory ", 0);
	send_to_server (update_dir, 0);
	send_to_server ("\012", 1);
	send_to_server (repos, 0);
	send_to_server ("\012", 1);
d1607 2
a1608 3
	send_to_server ("Repository ", 0);
	send_to_server (repos, 0);
	send_to_server ("\012", 1);
d1621 2
a1622 1
	    send_to_server ("Static-directory\012", 0);
d1636 1
a1636 1
	    if (! existence_error (errno))
d1643 2
a1644 1
	    send_to_server ("Sticky ", 0);
d1647 2
a1648 1
		send_to_server (line, 0);
d1654 2
a1655 1
                send_to_server ("\012", 1);
d1671 1
a1671 1
	    if (! existence_error (errno))
d1678 2
a1679 3

	    send_to_server ("Checkin-prog ", 0);

d1682 2
a1683 2
		send_to_server (line, 0);

d1689 2
a1690 1
		send_to_server ("\012", 1);
d1706 1
a1706 1
	    if (! existence_error (errno))
d1713 2
a1714 3

	    send_to_server ("Update-prog ", 0);

d1717 2
a1718 2
		send_to_server (line, 0);

d1724 2
a1725 1
		send_to_server ("\012", 1);
a1817 1
/* The "expanded" modules.  */
a1844 4
/* Original, not "expanded" modules.  */
static int module_argc;
static char **module_argv;

a1853 6
    module_argc = argc;
    module_argv = (char **) xmalloc ((argc + 1) * sizeof (module_argv[0]));
    for (i = 0; i < argc; ++i)
	module_argv[i] = xstrdup (argv[i]);
    module_argv[argc] = NULL;

d1857 2
a1858 3

    send_to_server ("expand-modules\012", 0);

d1867 1
a1867 1
	error (errs, 0, "cannot expand modules");
a1875 9

    /* Send the original module names.  The "expanded" module name might
       not be suitable as an argument to a co request (e.g. it might be
       the result of a -d argument in the modules file).  It might be
       cleaner if we genuinely expanded module names, all the way to a
       local directory and repository, but that isn't the way it works
       now.  */
    send_file_names (module_argc, module_argv);

d1881 2
d1919 1
a1919 1
#else /* ! CLIENT_SUPPORT */
d1921 1
a1921 1
#endif /* CLIENT_SUPPORT */
a1934 1
    RSP_LINE("Mode", handle_mode, response_type_normal, rs_optional),
a1951 1
    RSP_LINE("Notified", handle_notified, response_type_normal, rs_optional),
a1964 56
/* 
 * If LEN is 0, then send_to_server() computes string's length itself.
 *
 * Therefore, pass the real length when transmitting data that might
 * contain 0's.
 */
void
send_to_server (str, len)
     char *str;
     size_t len;
{
  if (len == 0)
    len = strlen (str);
  
#ifdef NO_SOCKET_TO_FD
  if (use_socket_style)
    {
      int just_wrtn = 0;
      int wrtn = 0;

      while (wrtn < len)
        {
          just_wrtn = send (server_sock, str + wrtn, len - wrtn, 0);

          if (just_wrtn == -1)
            error (1, errno, "reading from server socket");
          
          wrtn += just_wrtn;
          if (wrtn == len)
            break;
        }
    }
  else
#endif /* NO_SOCKET_TO_FD */
    {
      size_t wrtn = 0;
      
      while (wrtn < len)
        {
          wrtn += fwrite (str + wrtn, 1, len - wrtn, to_server);
          
          if (wrtn == len)
            break;
          
          if (ferror (to_server))
            error (1, errno, "writing to server");
          if (feof (to_server))
            error (1, 0, "premature end-of-file on server");
        }
    }
      
  if (to_server_logfile)
    if (fwrite (str, 1, len, to_server_logfile) < len)
      error (0, errno, "writing to to-server logfile");
}

d1966 2
a1967 1
 * Read LEN bytes from the server or die trying.
a1968 52
void
read_from_server (buf, len)
     char *buf;
     size_t len;
{
#ifdef NO_SOCKET_TO_FD
  if (use_socket_style)
    {
      int just_red = 0;
      int red = 0;

      while (red < len)
        {
          just_red = recv (server_sock, buf + red, len - red, 0);

          if (just_red == -1)
            error (1, errno, "reading from server");

          red += just_red;
          if (red == len)
            break;
        }
    }
  else
#endif /* NO_SOCKET_TO_FD */
    {
      size_t red = 0;
      
      while (red < len)
        {
          red += fread (buf + red, 1, len - red, from_server);
          
          if (red == len)
            break;
          
          if (ferror (from_server))
            error (1, errno, "reading from server");
          if (feof (from_server))
            error (1, 0, "premature end-of-file from server");
        }
    }
  
  /* Log, if that's what we're doing. */
  if (from_server_logfile)
    if (fwrite (buf, 1, len, from_server_logfile) < len)
      error (0, errno, "writing to from-server logfile");
}


/*
 * Get some server responses and process them.  Returns nonzero for
 * error, 0 for success.  */
a2009 10
/*
 * Flag var; we'll set it in start_server() and not one of its
 * callees, such as start_rsh_server().  This means that there might
 * be a small window between the starting of the server and the
 * setting of this var, but all the code in that window shouldn't care
 * because it's busy checking return values to see if the server got
 * started successfully anyway.
 */
int server_started = 0;

d2020 15
a2034 6
#ifdef NO_SOCKET_TO_FD
    if (use_socket_style)
      {
        if (shutdown (server_sock, 2) < 0)
          error (1, errno, "shutting down server socket");
      }
d2036 1
a2036 21
#endif /* NO_SOCKET_TO_FD */
      {
#if defined(HAVE_KERBEROS) || defined(AUTH_CLIENT_SUPPORT)
        if (server_fd != -1)
          {
            if (shutdown (server_fd, 1) < 0)
              error (1, errno, "shutting down connection to %s", server_host);
            /*
             * This test will always be true because we dup the descriptor
             */
            if (fileno (from_server) != fileno (to_server))
              {
                if (fclose (to_server) != 0)
                  error (1, errno,
                         "closing down connection to %s",
                         server_host);
              }
          }
        else
#endif /* HAVE_KERBEROS || AUTH_CLIENT_SUPPORT */
          
d2038 16
a2053 24
          SHUTDOWN_SERVER (fileno (to_server));
#else /* ! SHUTDOWN_SERVER */
        {
          
#ifdef START_RSH_WITH_POPEN_RW
          if (pclose (to_server) == EOF)
#else /* ! START_RSH_WITH_POPEN_RW */
            if (fclose (to_server) == EOF)
#endif /* START_RSH_WITH_POPEN_RW */
              {
                error (1, errno, "closing connection to %s", server_host);
              }
        }

        if (getc (from_server) != EOF)
          error (0, 0, "dying gasps from %s unexpected", server_host);
        else if (ferror (from_server))
          error (0, errno, "reading from %s", server_host);
        
        fclose (from_server);
#endif /* SHUTDOWN_SERVER */
      }
        
#if ! RSH_NOT_TRANSPARENT
d2056 2
a2057 4
	error (1, errno, "waiting for process %d", rsh_pid);
#endif /* ! RSH_NOT_TRANSPARENT */

    server_started = 0;
d2064 1
a2064 1
#endif /* RSH_NOT_TRANSPARENT */
a2075 2
  /* NOTREACHED */
  return 0;
d2078 2
a2079 2

#ifdef AUTH_CLIENT_SUPPORT
d2081 1
a2081 42
init_sockaddr (name, hostname, port)
     struct sockaddr_in *name;
     const char *hostname;
     unsigned short int port;
{
  struct hostent *hostinfo;
  
  memset (name, 0, sizeof (*name));
  name->sin_family = AF_INET;
  name->sin_port = htons (port);
  hostinfo = gethostbyname (hostname);
  if (hostinfo == NULL)
    {
      fprintf (stderr, "Unknown host %s.\n", hostname);
      exit (EXIT_FAILURE);
    }
  name->sin_addr = *(struct in_addr *) hostinfo->h_addr;
}


int
auth_server_port_number ()
{
  return CVS_AUTH_PORT;
}


/*
 * Connect to the authenticating server.
 *
 * If VERIFY_ONLY is non-zero, then just verify that the password is
 * correct and then shutdown the connection.  In this case, the return
 * values is 1 if the password was correct, 0 if not.
 *
 * If VERIFY_ONLY is 0, then really connect to the server.  In this
 * case the return value is 1 on succees, but is probably ignored.  If
 * fail to connect, then die with error.
 */
int
connect_to_pserver (tofdp, fromfdp, verify_only)
     int *tofdp, *fromfdp;
     int verify_only;
a2082 1
    int sock;
d2084 1
a2084 3
    int port_number;
    struct hostent *host;
    struct sockaddr_in client_sai;
d2086 1
a2086 5
    /* Does nothing if already called before now. */
    parse_cvsroot ();

    sock = socket (AF_INET, SOCK_STREAM, 0);
    if (sock == -1)
d2088 9
a2096 9
	fprintf (stderr, "socket() failed\n");
	exit (1);
    }
    port_number = auth_server_port_number ();
    init_sockaddr (&client_sai, server_host, port_number);
    if (connect (sock, (struct sockaddr *) &client_sai, sizeof (client_sai))
	< 0)
	error (1, errno, "connect to %s:%d failed", server_host,
	       CVS_AUTH_PORT);
d2098 23
a2120 14
    /* Run the authorization mini-protocol before anything else. */
    {
	int i;
	char ch, read_buf[PATH_MAX];
	char *begin      = NULL;
	char *repository = server_cvsroot;
	char *username   = server_user;
	char *password   = NULL;
	char *end        = NULL;

	if (verify_only)
	{
	    begin = "BEGIN VERIFICATION REQUEST\n";
	    end   = "END VERIFICATION REQUEST\n";
d2124 7
a2130 2
	    begin = "BEGIN AUTH REQUEST\n";
	    end   = "END AUTH REQUEST\n";
d2133 14
a2146 2
	/* Get the password, probably from ~/.cvspass. */
	password = get_cvs_password (server_user, server_host, server_cvsroot);
d2148 2
a2149 30
	/* Announce that we're starting the authorization protocol. */
	send (sock, begin, strlen (begin), 0);

	/* Send the data the server needs. */
	send (sock, repository, strlen (repository), 0);
	send (sock, "\n", 1, 0);
	send (sock, username, strlen (username), 0);
	send (sock, "\n", 1, 0);
	send (sock, password, strlen (password), 0);
	send (sock, "\n", 1, 0);

	/* Announce that we're ending the authorization protocol. */
	send (sock, end, strlen (end), 0);

	/* Paranoia. */
	memset (password, 0, strlen (password));

	/* Get ACK or NACK from the server. 
	 * 
	 * We could avoid this careful read-char loop by having the ACK
	 * and NACK cookies be of the same length, so we'd simply read
	 * that length and see what we got.  But then there'd be Yet
	 * Another Protocol Requirement floating around, and someday
	 * someone would make a change that breaks it and spend a hellish
	 * day tracking it down.  Therefore, we use "\n" to mark off the
	 * end of both ACK and NACK, and we loop, reading until "\n".
	 */
	ch = 0;
	memset (read_buf, 0, PATH_MAX);
	for (i = 0; (i < (PATH_MAX - 1)) && (ch != '\n'); i++)
d2151 2
a2152 4
	    if (recv (sock, &ch, 1, 0) < 0)
                error (1, errno, "recv() from server %s", server_host);

            read_buf[i] = ch;
d2154 1
a2154 2

	if (strcmp (read_buf, "I HATE YOU\n") == 0)
d2156 15
a2170 2
	    /* Authorization not granted. */
	    if (shutdown (sock, 2) < 0)
d2172 2
a2173 5
		error (0, 0, 
		       "authorization failed: server %s rejected access", 
		       server_host);
		error (1, errno,
		       "shutdown() failed (server %s)", server_host);
a2174 3

	    if (verify_only)
		return 0;
a2175 8
		error (1, 0, 
		       "authorization failed: server %s rejected access", 
		       server_host);
	}
	else if (strcmp (read_buf, "I LOVE YOU\n") != 0)
	{
	    /* Unrecognized response from server. */
	    if (shutdown (sock, 2) < 0)
d2177 14
a2190 4
		error (0, 0,
		       "unrecognized auth response from %s: %s", 
		       server_host, read_buf);
		error (1, errno, "shutdown() failed, server %s", server_host);
a2191 3
	    error (1, 0, 
		   "unrecognized auth response from %s: %s", 
		   server_host, read_buf);
a2192 1
    }
d2194 5
a2198 144
    if (verify_only)
    {
	if (shutdown (sock, 2) < 0)
	    error (0, errno, "shutdown() failed, server %s", server_host);
	return 1;
    }
    else
    {
#ifdef NO_SOCKET_TO_FD
	use_socket_style = 1;
	server_sock = sock;
	/* Try to break mistaken callers: */
	*tofdp = 0;
	*fromfdp = 0;
#else /* ! NO_SOCKET_TO_FD */
	server_fd = sock;
	close_on_exec (server_fd);
	tofd = fromfd = sock;
	/* Hand them back to the caller. */
	*tofdp   = tofd;
	*fromfdp = fromfd;
#endif /* NO_SOCKET_TO_FD */
    }

    return 1;
}
#endif /* AUTH_CLIENT_SUPPORT */


#if HAVE_KERBEROS

/*
 * FIXME: this function has not been changed to deal with
 * NO_SOCKET_TO_FD (i.e., systems on which sockets cannot be converted
 * to file descriptors.  The first person to try building a kerberos
 * client on such a system (OS/2, Windows 95, and maybe others) will
 * have to make take care of this.
 */
void
start_kerberos_server (tofdp, fromfdp)
     int *tofdp, *fromfdp;
{
  int tofd, fromfd;

  struct hostent *hp;
  char *hname;
  const char *realm;
  const char *portenv;
  int port;
  struct sockaddr_in sin;
  int s;
  KTEXT_ST ticket;
  int status;
  
  /*
   * We look up the host to give a better error message if it
   * does not exist.  However, we then pass server_host to
   * krb_sendauth, rather than the canonical name, because
   * krb_sendauth is going to do its own canonicalization anyhow
   * and that lets us not worry about the static storage used by
   * gethostbyname.
   */
  hp = gethostbyname (server_host);
  if (hp == NULL)
    error (1, 0, "%s: unknown host", server_host);
  hname = xmalloc (strlen (hp->h_name) + 1);
  strcpy (hname, hp->h_name);
  
  realm = krb_realmofhost (hname);
  
  portenv = getenv ("CVS_CLIENT_PORT");
  if (portenv != NULL)
    {
      port = atoi (portenv);
      if (port <= 0)
        goto try_rsh_no_message;
      port = htons (port);
    }
  else
    {
      struct servent *sp;
      
      sp = getservbyname ("cvs", "tcp");
      if (sp == NULL)
        port = htons (CVS_PORT);
      else
        port = sp->s_port;
    }
  
  s = socket (AF_INET, SOCK_STREAM, 0);
  if (s < 0)
    error (1, errno, "socket");
  
  memset (&sin, 0, sizeof sin);
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = INADDR_ANY;
  sin.sin_port = 0;
  
  if (bind (s, (struct sockaddr *) &sin, sizeof sin) < 0)
    error (1, errno, "bind");
  
  memcpy (&sin.sin_addr, hp->h_addr, hp->h_length);
  sin.sin_port = port;
  
  tofd = -1;
  if (connect (s, (struct sockaddr *) &sin, sizeof sin) < 0)
    {
      error (0, errno, "kerberos connect");
      close (s);
    }
  else
    {
      struct sockaddr_in laddr;
      int laddrlen;
      MSG_DAT msg_data;
      CREDENTIALS cred;
      Key_schedule sched;
      
      laddrlen = sizeof (laddr);
      if (getsockname (s, (struct sockaddr *) &laddr, &laddrlen) < 0)
        error (1, errno, "getsockname");
      
      /* We don't care about the checksum, and pass it as zero.  */
      status = krb_sendauth (KOPT_DO_MUTUAL, s, &ticket, "rcmd",
                             hname, realm, (unsigned long) 0, &msg_data,
                             &cred, sched, &laddr, &sin, "KCVSV1.0");
      if (status != KSUCCESS)
        {
          error (0, 0, "kerberos: %s", krb_get_err_text(status));
          close (s);
        }
      else
        {
          server_fd = s;
          close_on_exec (server_fd);
          tofd = fromfd = s;
        }
    }
  
  if (tofd == -1)
    {
      error (0, 0, "trying to start server using rsh");
    try_rsh_no_message:
      server_fd = -1;
d2200 2
a2201 2
      start_rsh_server (&tofd, &fromfd);
#else /* RSH_NOT_TRANSPARENT */
d2203 6
a2208 4
      START_SERVER (&tofd, &fromfd, getcaller (),
                    server_user, server_host, server_cvsroot);
#endif /* defined (START_SERVER) */
#endif /* ! RSH_NOT_TRANSPARENT */
a2209 1
  free (hname);
a2210 30
  /* Give caller the values it wants. */
  *tofdp   = tofd;
  *fromfdp = fromfd;
}

#endif /* HAVE_KERBEROS */

/* Contact the server.  */
void
start_server ()
{
  int tofd, fromfd;
  char *log = getenv ("CVS_CLIENT_LOG");

  /* Init these to NULL.  They will be set later if logging is on. */
  from_server_logfile = (FILE *) NULL;
  to_server_logfile   = (FILE *) NULL;

#ifdef AUTH_CLIENT_SUPPORT
    if (use_authenticating_server)
      {
        /* Toss the return value.  It will die with error if anything
           goes wrong anyway. */
        connect_to_pserver (&tofd, &fromfd, 0);
      }
    else
#endif /* AUTH_CLIENT_SUPPORT */
      {
#if HAVE_KERBEROS
        start_kerberos_server (&tofd, &fromfd);
a2211 1

d2213 2
a2214 3
        start_rsh_server (&tofd, &fromfd);
#else /* RSH_NOT_TRANSPARENT */

d2216 8
a2223 7
        START_SERVER (&tofd, &fromfd, getcaller (),
                      server_user, server_host, server_cvsroot);
#endif /* defined(START_SERVER) */

#endif /* ! RSH_NOT_TRANSPARENT */
#endif /* HAVE_KERBEROS */
      }
d2225 2
a2226 2
    /* "Hi, I'm Darlene and I'll be your server tonight..." */
    server_started = 1;
a2227 1
    /* Set up logfiles, if any. */
d2231 1
a2231 1
	char *buf = xmalloc (len + 5);
d2233 1
d2235 1
d2240 1
a2240 3
	to_server_logfile = open_file (buf, "w");
        if (to_server_logfile == NULL)
          error (0, errno, "opening to-server logfile %s", buf);
d2243 1
a2243 3
	from_server_logfile = open_file (buf, "w");
        if (from_server_logfile == NULL)
          error (0, errno, "opening from-server logfile %s", buf);
d2248 8
a2255 26
#ifdef NO_SOCKET_TO_FD
    if (! use_socket_style)
#endif /* NO_SOCKET_TO_FD */
      {
        /* todo: some OS's don't need these calls... */
        close_on_exec (tofd);
        close_on_exec (fromfd);

	/* SCO 3 and AIX have a nasty bug in the I/O libraries which precludes
	   fdopening the same file descriptor twice, so dup it if it is the
	   same.  */
	if (tofd == fromfd)
	{
	    fromfd = dup (tofd);
	    if (fromfd < 0)
		error (1, errno, "cannot dup net connection");
	}

        /* These will use binary mode on systems which have it.  */
        to_server = fdopen (tofd, FOPEN_BINARY_WRITE);
        if (to_server == NULL)
          error (1, errno, "cannot fdopen %d for write", tofd);
        from_server = fdopen (fromfd, FOPEN_BINARY_READ);
        if (from_server == NULL)
          error (1, errno, "cannot fdopen %d for read", fromfd);
      }
d2261 3
a2263 3
    if (last_dir_name != NULL)
        free (last_dir_name);
    last_dir_name = NULL;
a2270 5
    stored_mode_valid = 0;

    send_to_server ("Root ", 0);
    send_to_server (server_cvsroot, 0);
    send_to_server ("\012", 1);
d2272 2
d2276 2
a2277 3

	send_to_server ("Valid-responses", 0);

d2280 2
a2281 2
	    send_to_server (" ", 0);
	    send_to_server (rs->name, 0);
d2283 2
a2284 1
	send_to_server ("\012", 1);
d2286 2
a2287 2
    send_to_server ("valid-requests\012", 0);

d2312 2
a2313 1
		send_to_server ("Global_option -n\012", 0);
d2323 2
a2324 1
		send_to_server ("Global_option -q\012", 0);
d2334 2
a2335 1
		send_to_server ("Global_option -Q\012", 0);
d2345 2
a2346 1
		send_to_server ("Global_option -r\012", 0);
d2356 2
a2357 1
		send_to_server ("Global_option -t\012", 0);
d2367 2
a2368 1
		send_to_server ("Global_option -l\012", 0);
d2379 2
a2380 6
            char gzip_level_buf[5];
	    send_to_server ("gzip-file-contents ", 0);
            sprintf (gzip_level_buf, "%d", gzip_level);
	    send_to_server (gzip_level_buf, 0);

	    send_to_server ("\012", 1);
a2392 82
/* Right now, we have two different definitions for this function,
   depending on whether we start the rsh server using popenRW or not.
   This isn't ideal, and the best thing would probably be to change
   the OS/2 port to be more like the regular Unix client (i.e., by
   implementing piped_child)... but I'm doing something else at the
   moment, and wish to make only one change at a time.  -Karl */

#ifdef START_RSH_WITH_POPEN_RW

/* This is actually a crock -- it's OS/2-specific, for no one else
   uses it.  If I get time, I want to make piped_child and all the
   other stuff in os2/run.c work right.  In the meantime, this gets us
   up and running, and that's most important. */

static void
start_rsh_server (tofdp, fromfdp)
     int *tofdp, *fromfdp;
{
  int pipes[2];
  
  /* If you're working through firewalls, you can set the
     CVS_RSH environment variable to a script which uses rsh to
     invoke another rsh on a proxy machine.  */
  char *cvs_rsh = getenv ("CVS_RSH");
  char *cvs_server = getenv ("CVS_SERVER");
  char command[PATH_MAX];
  int i = 0;
  /* This needs to fit "rsh", "-b", "-l", "USER", "host",
	 "cmd (w/ args)", and NULL.  We leave some room to grow. */
  char *rsh_argv[10];
  
  if (!cvs_rsh)
    cvs_rsh = "rsh";
  if (!cvs_server)
    cvs_server = "cvs";
  
  /* If you are running a very old (Nov 3, 1994, before 1.5)
   * version of the server, you need to make sure that your .bashrc
   * on the server machine does not set CVSROOT to something
   * containing a colon (or better yet, upgrade the server).  */
  
  /* The command line starts out with rsh. */
  rsh_argv[i++] = cvs_rsh;
  
#ifdef RSH_NEEDS_BINARY_FLAG
  /* "-b" for binary, under OS/2. */
  rsh_argv[i++] = "-b";
#endif /* RSH_NEEDS_BINARY_FLAG */

  /* Then we strcat more things on the end one by one. */
  if (server_user != NULL)
    {
      rsh_argv[i++] = "-l";
      rsh_argv[i++] = server_user;
    }
  
  rsh_argv[i++] = server_host;
  rsh_argv[i++] = cvs_server;
  rsh_argv[i++] = "server";

  /* Mark the end of the arg list. */
  rsh_argv[i]   = (char *) NULL;

  if (trace)
    {
      fprintf (stderr, " -> Starting server: ");
      fprintf (stderr, "%s", command);
      putc ('\n', stderr);
    }
  
  /* Do the deed. */
  rsh_pid = popenRW (rsh_argv, pipes);
  if (rsh_pid < 0)
    error (1, errno, "cannot start server via rsh");

  /* Give caller the file descriptors. */
  *tofdp   = pipes[0];
  *fromfdp = pipes[1];
}

#else /* ! START_RSH_WITH_POPEN_RW */

d2458 1
a2458 4

#endif /* START_RSH_WITH_POPEN_RW */
#endif /* ! RSH_NOT_TRANSPARENT */

a2465 1
    char buf[1];
d2467 2
a2468 3

    send_to_server ("Argument ", 0);

d2473 2
a2474 1
	    send_to_server ("\012Argumentx ", 0);
d2476 2
a2477 5
	else
        {
          buf[0] = *p;
          send_to_server (buf, 1);
        }
d2480 2
a2481 1
    send_to_server ("\012", 1);
d2484 2
a2485 4
static void send_modified PROTO ((char *, char *, Vers_TS *));

static void
send_modified (file, short_pathname, vers)
a2487 1
    Vers_TS *vers;
a2494 1
    int bin;
d2510 1
a2510 10
    /* Is the file marked as containing binary data by the "-kb" flag?
       If so, make sure to open it in binary mode: */

    if (vers && vers->options)
      bin = !(strcmp (vers->options, "-kb"));
    else
      bin = 0;

    fd = open (file, O_RDONLY | (bin ? OPEN_BINARY : 0));

d2522 1
a2522 2
	int converting;
#endif /* LINES_CRLF_TERMINATED */
d2525 14
a2538 6
	/* Assume everything in a "cvs import" is text.  */
	if (vers == NULL)
	    converting = 1;
	else
            /* Otherwise, we convert things unless they're binary. */
	    converting = (! bin);
d2540 13
a2552 35
	if (converting)
	{
	    /* gzip reads and writes files without munging CRLF
	       sequences, as it should, but files should be
	       transmitted in LF form.  Convert CRLF to LF before
	       gzipping, on systems where this is necessary.

	       If Windows NT supported fork, we could do this by
	       pushing another filter on in front of gzip.  But it
	       doesn't.  I'd have to write a trivial little program to
	       do the conversion and have CVS spawn it off.  But
	       little executables like that always get lost.

	       Alternatively, this cruft could go away if we switched
	       to a gzip library instead of a subprocess; then we
	       could tell gzip to open the file with CRLF translation
	       enabled.  */
	    if (close (fd) < 0)
		error (0, errno, "warning: can't close %s", short_pathname);

	    tmpnam (tempfile);
	    convert_file (file, O_RDONLY,
			  tempfile,
			  O_WRONLY | O_CREAT | O_TRUNC | OPEN_BINARY);

	    /* This OPEN_BINARY doesn't make any difference, I think, because
	       gzip will deal with the inherited handle as it pleases.  But I
	       do remember something obscure in the manuals about propagating
	       the translation mode to created processes via environment
	       variables, ick.  */
	    fd = open (tempfile, O_RDONLY | OPEN_BINARY);
	    if (fd < 0)
		error (1, errno, "reading %s", short_pathname);
	}
#endif /* LINES_CRLF_TERMINATED */
d2587 9
a2595 21
	if (converting)
	{
	    if (unlink (tempfile) < 0)
		error (0, errno,
		       "warning: can't remove temp file %s", tempfile);
	}
#endif /* LINES_CRLF_TERMINATED */

        {
          char tmp[80];

	  send_to_server ("Modified ", 0);
	  send_to_server (file, 0);
	  send_to_server ("\012", 1);
	  send_to_server (mode_string, 0);
	  send_to_server ("\012z", 2);
	  sprintf (tmp, "%lu\n", (unsigned long) newsize);
	  send_to_server (tmp, 0);

          send_to_server (buf, newsize);
        }
d2616 3
a2618 11
        {
          char tmp[80];

	  send_to_server ("Modified ", 0);
	  send_to_server (file, 0);
	  send_to_server ("\012", 1);
	  send_to_server (mode_string, 0);
	  send_to_server ("\012", 1);
          sprintf (tmp, "%lu\012", (unsigned long) newsize);
          send_to_server (tmp, 0);
        }
d2625 2
a2626 1
          send_to_server (buf, newsize);
a2631 2
static int send_fileproc PROTO ((char *, char *, char *, List *, List *));

a2656 14
      char *tmp;

      tmp = xmalloc (strlen (file) + strlen (vers->vn_user)
		     + strlen (vers->options) + 200);
      sprintf (tmp, "Entry /%s/%s/%s%s/%s/", 
               file, vers->vn_user,
               vers->ts_conflict == NULL ? "" : "+",
               (vers->ts_conflict == NULL ? ""
                : (vers->ts_user != NULL &&
                   strcmp (vers->ts_conflict, vers->ts_user) == 0
                   ? "="
                   : "modified")),
               vers->options);

d2659 9
a2667 2
	send_to_server (tmp, 0);
        free (tmp);
d2670 2
a2671 2
	    send_to_server ("T", 0);
	    send_to_server (vers->entdata->tag, 0);
d2674 4
a2677 5
          {
	    send_to_server ("D", 0);
	    send_to_server (vers->entdata->date, 0);
          }
	send_to_server ("\012", 1);
d2690 2
a2691 3
	    send_to_server ("Lost ", 0);
	    send_to_server (file, 0);
	    send_to_server ("\012", 1);
d2701 1
a2701 1
	send_modified (file, short_pathname, vers);
d2707 2
a2708 5
          {
	    send_to_server ("Unchanged ", 0);
	    send_to_server (file, 0);
	    send_to_server ("\012", 1);
          }
a2721 1
    freevers_ts (&vers);
a2725 42
static void send_ignproc PROTO ((char *, char *));

static void
send_ignproc (file, dir)
    char *file;
    char *dir;
{
    if (ign_inhibit_server || !supported_request ("Questionable"))
    {
	if (dir[0] != '\0')
	    (void) printf ("? %s/%s\n", dir, file);
	else
	    (void) printf ("? %s\n", file);
    }
    else
    {
	send_to_server ("Questionable ", 0);
	send_to_server (file, 0);
	send_to_server ("\012", 1);
    }
}

static int send_filesdoneproc PROTO ((int, char *, char *));

static int
send_filesdoneproc (err, repository, update_dir)
    int err;
    char *repository;
    char *update_dir;
{
    /* if this directory has an ignore list, process it then free it */
    if (ignlist)
    {
	ignore_files (ignlist, update_dir, send_ignproc);
	dellist (&ignlist);
    }

    return (err);
}

static Dtype send_dirent_proc PROTO ((char *, char *, char *));

d2852 2
a2853 6
            char buf[10];
            sprintf (buf, "%d", max_level);

	    send_to_server ("Max-dotdot ", 0);
	    send_to_server (buf, 0);
	    send_to_server ("\012", 1);
d2886 2
d2894 2
a2895 2
	(send_fileproc, send_filesdoneproc,
	 send_dirent_proc, (DIRLEAVEPROC)NULL,
d2952 1
a2952 1
    send_modified (vfile, short_pathname, NULL);
a2972 131
static void
notified_a_file (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    FILE *fp;
    FILE *newf;
    size_t line_len = 8192;
    char *line = xmalloc (line_len);
    char *cp;
    int nread;
    int nwritten;
    char *p;

    fp = open_file (CVSADM_NOTIFY, "r");
    if (getline (&line, &line_len, fp) < 0)
    {
	error (0, errno, "cannot read %s", CVSADM_NOTIFY);
	goto error_exit;
    }
    cp = strchr (line, '\t');
    if (cp == NULL)
    {
	error (0, 0, "malformed %s file", CVSADM_NOTIFY);
	goto error_exit;
    }
    *cp = '\0';
    if (strcmp (filename, line + 1) != 0)
    {
	error (0, 0, "protocol error: notified %s, expected %s", filename,
	       line + 1);
    }

    if (getline (&line, &line_len, fp) < 0)
    {
	if (feof (fp))
	{
	    if (fclose (fp) < 0)
		error (0, errno, "cannot close %s", CVSADM_NOTIFY);
	    if (unlink (CVSADM_NOTIFY) < 0)
		error (0, errno, "cannot remove %s", CVSADM_NOTIFY);
	    return;
	}
	else
	{
	    error (0, errno, "cannot read %s", CVSADM_NOTIFY);
	    goto error_exit;
	}
    }
    newf = open_file (CVSADM_NOTIFYTMP, "w");
    if (fputs (line, newf) < 0)
    {
	error (0, errno, "cannot write %s", CVSADM_NOTIFYTMP);
	goto error2;
    }
    while ((nread = fread (line, 1, line_len, fp)) > 0)
    {
	p = line;
	while ((nwritten = fwrite (p, 1, nread, newf)) > 0)
	{
	    nread -= nwritten;
	    p += nwritten;
	}
	if (ferror (newf))
	{
	    error (0, errno, "cannot write %s", CVSADM_NOTIFYTMP);
	    goto error2;
	}
    }
    if (ferror (fp))
    {
	error (0, errno, "cannot read %s", CVSADM_NOTIFY);
	goto error2;
    }
    if (fclose (newf) < 0)
    {
	error (0, errno, "cannot close %s", CVSADM_NOTIFYTMP);
	goto error_exit;
    }
    if (fclose (fp) < 0)
    {
	error (0, errno, "cannot close %s", CVSADM_NOTIFY);
	return;
    }

    {
        /* In this case, we want rename_file() to ignore noexec. */
        int saved_noexec = noexec;
        noexec = 0;
        rename_file (CVSADM_NOTIFYTMP, CVSADM_NOTIFY);
        noexec = saved_noexec;
    }

    return;
  error2:
    (void) fclose (newf);
  error_exit:
    (void) fclose (fp);
}

static void
handle_notified (args, len)
    char *args;
    int len;
{
    call_in_directory (args, notified_a_file, NULL);
}

void
client_notify (repository, update_dir, filename, notif_type, val)
    char *repository;
    char *update_dir;
    char *filename;
    int notif_type;
    char *val;
{
    char buf[2];

    send_a_repository ("", repository, update_dir);
    send_to_server ("Notify ", 0);
    send_to_server (filename, 0);
    send_to_server ("\012", 1);
    buf[0] = notif_type;
    buf[1] = '\0';
    send_to_server (buf, 1);
    send_to_server ("\t", 1);
    send_to_server (val, 0);
}

d2984 2
a2985 5

    send_to_server ("Argument ", 0);
    send_to_server (option, 0);
    send_to_server ("\012", 1);

d3013 1
a3013 1
#endif /* HAVE_RCS5 */
a3187 55
}

int
client_watch (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return watch (argc, argv);	/* Call real code */
}

int
client_watchers (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return watchers (argc, argv);	/* Call real code */
}

int
client_editors (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return editors (argc, argv);	/* Call real code */
}

int
client_edit (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return edit (argc, argv);	/* Call real code */
}

int
client_unedit (argc, argv)
    int argc;
    char **argv;
{
    
    parse_cvsroot ();
    
    return unedit (argc, argv);	/* Call real code */
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@a4 1
#include "edit.h"
a10 3
#ifdef HAVE_WINSOCK_H
#include <winsock.h>
#else /* No winsock.h */
a13 1
#endif /* No winsock.h */
d393 1
a393 1
		error (1, 0, "end of file from server (consult above messages if any)");
a1795 21
    /* FIXME: this is probably not the best place to check; I wish I
     * knew where in here's callers to really trap this bug.  To
     * reproduce the bug, just do this:
     * 
     *       mkdir junk
     *       cd junk
     *       cvs -d some_repos update foo
     *
     * Poof, CVS seg faults and dies!  It's because it's trying to
     * send a NULL string to the server but dies in send_to_server.
     * That string was supposed to be the repository, but it doesn't
     * get set because there's no CVSADM dir, and somehow it's not
     * getting set from the -d argument either... ?
     */
    if (repos == NULL)
    {
        /* Lame error.  I want a real fix but can't stay up to track
           this down right now. */
        error (1, 0, "no repository");
    }

a1944 1
    free (adm_name);
d2219 1
a2219 1
      size_t wrtn = 0;
d2269 1
a2269 1
      size_t red = 0;
d2298 1
a2298 1
            error (1, 0, "end of file from server (consult above messages if any)");
a2500 1
#ifndef NO_SOCKET_TO_FD
a2501 1
#endif
d2503 1
a2779 15
static int send_variable_proc PROTO ((Node *, void *));

static int
send_variable_proc (node, closure)
    Node *node;
    void *closure;
{
    send_to_server ("Set ", 0);
    send_to_server (node->key, 0);
    send_to_server ("=", 1);
    send_to_server (node->data, 0);
    send_to_server ("\012", 1);
    return 0;
}

d2987 1
a2987 1
    {
d2989 1
a2989 1
	{
d2996 1
a2996 1
	}
d2998 1
a2998 1
	{
d3001 2
a3002 9
	}
    }
    /* If "Set" is not supported, just silently fail to send the variables.
       Users with an old server should get a useful error message when it
       fails to recognize the ${=foo} syntax.  This way if someone uses
       several server, some of which are new and some old, they can still
       set user variables in their .cvsrc without trouble.  */
    if (supported_request ("Set"))
	walklist (variable_list, send_variable_proc, NULL);
d3179 2
a3180 2
	    buf[0] = *p;
	    send_to_server (buf, 1);
d3382 1
a3382 1
static int send_fileproc PROTO ((struct file_info *finfo));
d3386 6
a3391 2
send_fileproc (finfo)
    struct file_info *finfo;
d3394 4
a3397 4
    int update_dir_len = strlen (finfo->update_dir);
    char *short_pathname = xmalloc (update_dir_len + strlen (finfo->file) + 40);
    strcpy (short_pathname, finfo->update_dir);
    if (finfo->update_dir[0] != '\0')
d3399 1
a3399 1
    strcat (short_pathname, finfo->file);
d3401 1
a3401 1
    send_a_repository ("", finfo->repository, finfo->update_dir);
d3405 1
a3405 1
		       finfo->file, 0, 0, finfo->entries, (List *)NULL);
d3411 1
a3411 1
      tmp = xmalloc (strlen (finfo->file) + strlen (vers->vn_user)
d3414 1
a3414 1
               finfo->file, vers->vn_user,
d3451 1
a3451 1
	    send_to_server (finfo->file, 0);
d3462 1
a3462 1
	send_modified (finfo->file, short_pathname, vers);
d3470 1
a3470 1
	    send_to_server (finfo->file, 0);
d3482 1
a3482 1
	p->key = xstrdup (finfo->file);
d3677 1
a3677 26
    {
	char buf[1];
	char *p = argv[i];

	send_to_server ("Argument ", 0);

	while (*p)
	{
	    if (*p == '\n')
	    {
		send_to_server ("\012Argumentx ", 0);
	    }
	    else if (ISDIRSEP (*p))
	    {
		buf[0] = '/';
		send_to_server (buf, 1);
	    }
	    else
	    {
		buf[0] = *p;
		send_to_server (buf, 1);
	    }
	    ++p;
	}
	send_to_server ("\012", 1);
    }
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a2 4
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */

d11 9
a19 9
#if defined(AUTH_CLIENT_SUPPORT) || HAVE_KERBEROS || USE_DIRECT_TCP
#  ifdef HAVE_WINSOCK_H
#    include <winsock.h>
#  else /* No winsock.h */
#    include <sys/socket.h>
#    include <netinet/in.h>
#    include <netdb.h>
#  endif /* No winsock.h */
#endif /* defined(AUTH_CLIENT_SUPPORT) || HAVE_KERBEROS || USE_DIRECT_TCP */
d25 1
a25 1
#if HAVE_KERBEROS || USE_DIRECT_TCP
a27 1
#if HAVE_KERBEROS
a35 1
#endif /* HAVE_KERBEROS || USE_DIRECT_TCP */
a79 1
static size_t try_read_from_server PROTO ((char *, size_t));
a892 3
#ifdef USE_VMS_FILENAMES
    char *p;
#endif
a894 7

#ifdef USE_VMS_FILENAMES
    /* Mogrify the filename so VMS is happy with it. */
    for(p = newname; *p; p++)
       if(*p == '.' || *p == '#') *p = '_';
#endif

a906 80

static void read_counted_file PROTO ((char *, char *));

/* Read from the server the count for the length of a file, then read
   the contents of that file and write them to FILENAME.  FULLNAME is
   the name of the file for use in error messages.  FIXME-someday:
   extend this to deal with compressed files and make update_entries
   use it.  On error, gives a fatal error.  */
static void
read_counted_file (filename, fullname)
    char *filename;
    char *fullname;
{
    char *size_string;
    size_t size;
    char *buf;

    /* Pointers in buf to the place to put data which will be read,
       and the data which needs to be written, respectively.  */
    char *pread;
    char *pwrite;
    /* Number of bytes left to read and number of bytes in buf waiting to
       be written, respectively.  */
    size_t nread;
    size_t nwrite;

    FILE *fp;

    read_line (&size_string, 0);
    if (size_string[0] == 'z')
	error (1, 0, "\
protocol error: compressed files not supported for that operation");
    /* FIXME: should be doing more error checking, probably.  Like using
       strtoul and making sure we used up the whole line.  */
    size = atoi (size_string);
    free (size_string);

    /* A more sophisticated implementation would use only a limited amount
       of buffer space (8K perhaps), and read that much at a time.  We allocate
       a buffer for the whole file only to make it easy to keep track what
       needs to be read and written.  */
    buf = xmalloc (size);

    /* FIXME-someday: caller should pass in a flag saying whether it
       is binary or not.  I haven't carefully looked into whether
       CVS/Template files should use local text file conventions or
       not.  */
    fp = fopen (filename, "wb");
    if (fp == NULL)
	error (1, errno, "cannot write %s", fullname);
    nread = size;
    nwrite = 0;
    pread = buf;
    pwrite = buf;
    while (nread > 0 || nwrite > 0)
    {
	size_t n;

	if (nread > 0)
	{
	    n = try_read_from_server (pread, nread);
	    nread -= n;
	    pread += n;
	    nwrite += n;
	}

	if (nwrite > 0)
	{
	    n = fwrite (pwrite, 1, nwrite, fp);
	    if (ferror (fp))
		error (1, errno, "cannot write %s", fullname);
	    nwrite -= n;
	    pwrite += n;
	}
    }
    free (buf);
    if (fclose (fp) < 0)
	error (1, errno, "cannot close %s", fullname);
}

a1061 9
    else
	/* For cvs export, assume it is a text file.  FIXME: This is
	   broken behavior--we should be having the server tell us
	   whether it is text or binary and dealing accordingly.  I
	   think maybe we can parse the entries line, get the options,
	   and then ignore the entries line otherwise, but I haven't
	   checked to see whether the server sends the entries line
	   correctly in this case.  */
	options = NULL;
a1090 5
#ifdef USE_VMS_FILENAMES
        /* A VMS rename of "blah.dat" to "foo" to implies a
           destination of "foo.dat" which is unfortinate for CVS */
       sprintf (temp_filename, "%s_new_", filename);
#else
a1095 1
#endif /* USE_VMS_FILENAMES */
d1105 6
a1110 4
	if (options)
	    bin = !(strcmp (options, "-kb"));
	else
	    bin = 0;
d1135 1
a1135 2
		error (1, errno, "waiting for gzip process %ld",
		       (long) gzip_pid);
a1610 26

static void template PROTO ((char *, List *, char *, char *));

static void
template (data, ent_list, short_pathname, filename)
    char *data;
    List *ent_list;
    char *short_pathname;
    char *filename;
{
    /* FIXME: should be computing second argument from CVSADM_TEMPLATE
       and short_pathname.  */
    read_counted_file (CVSADM_TEMPLATE, "<CVS/Template file>");
}

static void handle_template PROTO ((char *, int));

static void
handle_template (pathname, len)
    char *pathname;
    int len;
{
    call_in_directory (pathname, template, NULL);
}


d1621 1
a1621 1
 * Unlike some responses this doesn't include the repository.  So we can't
d2137 1
a2137 1
    send_file_names (module_argc, module_argv, 0);
a2209 2
    RSP_LINE("Template", handle_template, response_type_normal,
       rs_optional),
a2247 5
#ifdef VMS
      /* send() blocks under VMS */
      if (send (server_sock, str + wrtn, len - wrtn, 0) < 0)
        error (1, errno, "writing to server socket");
#else /* VMS */
d2253 1
a2253 1
            error (1, errno, "writing to server socket");
a2258 1
#endif  /* VMS */
d2284 7
a2290 6
/* Read up to LEN bytes from the server.  Returns actual number of bytes
   read.  Gives a fatal error on EOF or error.  */
static size_t
try_read_from_server (buf, len)
    char *buf;
    size_t len;
a2291 2
    int nread;

d2293 1
a2293 8
    if (use_socket_style)
    {
	nread = recv (server_sock, buf, len, 0);
	if (nread == -1)
	    error (1, errno, "reading from server");
    }
    else
#endif
d2295 2
a2296 7
	nread = fread (buf, 1, len, from_server);
	if (ferror (from_server))
	    error (1, errno, "reading from server");
	if (feof (from_server))
	    error (1, 0,
		   "end of file from server (consult above messages if any)");
    }
d2298 3
a2300 7
    /* Log, if that's what we're doing. */
    if (from_server_logfile != NULL && nread > 0)
    {
	size_t towrite = nread;
	if (fwrite (buf, 1, towrite, from_server_logfile) < towrite)
	    error (0, errno, "writing to from-server logfile");
    }
d2302 2
a2303 2
    return nread;
}
d2305 7
a2311 10
/*
 * Read LEN bytes from the server or die trying.
 */
void
read_from_server (buf, len)
    char *buf;
    size_t len;
{
    size_t red = 0;
    while (red < len)
d2313 14
a2326 3
	red += try_read_from_server (buf + red, len - red);
	if (red == len)
	    break;
d2328 5
d2335 1
d2409 1
a2409 1
#if defined(HAVE_KERBEROS) || defined(USE_DIRECT_TCP) || defined(AUTH_CLIENT_SUPPORT)
d2426 1
a2426 1
#endif /* HAVE_KERBEROS || USE_DIRECT_TCP || AUTH_CLIENT_SUPPORT */
d2485 11
a2495 11
    struct sockaddr_in *name;
    const char *hostname;
    unsigned short int port;
{
    struct hostent *hostinfo;

    memset (name, 0, sizeof (*name));
    name->sin_family = AF_INET;
    name->sin_port = htons (port);
    hostinfo = gethostbyname (hostname);
    if (hostinfo == NULL)
d2497 2
a2498 2
	fprintf (stderr, "Unknown host %s.\n", hostname);
	exit (EXIT_FAILURE);
d2500 1
a2500 1
    name->sin_addr = *(struct in_addr *) hostinfo->h_addr;
d2541 1
a2541 1
	exit (EXIT_FAILURE);
d2675 1
a2675 1
#if HAVE_KERBEROS || USE_DIRECT_TCP
d2685 1
a2685 1
start_tcp_server (tofdp, fromfdp)
d2692 1
a2696 3


#if HAVE_KERBEROS
a2697 3
  const char *realm;
#endif /* HAVE_KERBEROS */

a2713 1
#if HAVE_KERBEROS
a2714 1
#endif /* HAVE_KERBEROS */
a2715 1
  /* Get CVS_CLIENT_PORT or look up cvs/tcp with CVS_PORT as default */
a2721 2
      if (trace)
        fprintf(stderr, "Using TCP port %d to contact server.\n", port);
d2753 1
a2753 1
      error (0, errno, "connect");
a2757 1
#ifdef HAVE_KERBEROS
a2778 2
#endif /* HAVE_KERBEROS */

a2781 2

#ifdef HAVE_KERBEROS
a2782 1
#endif /* HAVE_KERBEROS */
a2786 4
      /* FIXME: Falling back like this is slow and we should probably
	 just make it a fatal error (so that people use the right
	 environment variables or, when we get around to implementing
	 the right ones, access methods).  */
d2806 1
a2806 1
#endif /* HAVE_KERBEROS || USE_DIRECT_TCP */
a2829 5
  /* Note that generally speaking we do *not* fall back to a different
     way of connecting if the first one does not work.  This is slow
     (*really* slow on a 14.4kbps link); the clean way to have a CVS
     which supports several ways of connecting is with access methods.  */

d2844 3
a2846 3
#if HAVE_KERBEROS || USE_DIRECT_TCP
        start_tcp_server (&tofd, &fromfd);
#else
d2848 1
a2848 1
#  if ! RSH_NOT_TRANSPARENT
d2850 1
a2850 1
#  else
d2852 1
a2852 1
#    if defined(START_SERVER)
d2855 4
a2858 3
#    endif
#  endif
#endif
a2860 6
#if defined(VMS) && defined(NO_SOCKET_TO_FD)
    /* Avoid mixing sockets with stdio */
    use_socket_style = 1;
    server_sock = tofd;
#endif /* VMS && NO_SOCKET_TO_FD */

d2930 3
a2932 6
    if (strcmp (command_name, "init") != 0)
    {
	send_to_server ("Root ", 0);
	send_to_server (server_cvsroot, 0);
	send_to_server ("\012", 1);
    }
d2949 1
a2949 1
	exit (EXIT_FAILURE);
a3045 6

#ifdef FILENAMES_CASE_INSENSITIVE
    if (supported_request ("Case"))
	send_to_server ("Case\012", 0);
#endif

d3049 1
a3049 1
       several servers, some of which are new and some old, they can still
a3335 4

	/* FIXME: is there any reason to go through all this realloc'ing
	   when we could just be writing the data to the network as we read
	   it from gzip?  */
d3363 1
a3363 1
	    error (1, errno, "waiting for gzip proc %ld", (long) gzip_pid);
a3397 5
	    /* FIXME: This is gross.  It assumes that we might read
	       less than st_size bytes (true on NT), but not more.
	       Instead of this we should just be reading a block of
	       data (e.g. 8192 bytes), writing it to the network, and
	       so on until EOF.  */
d3440 6
d3451 1
a3451 1
		       finfo->file, 0, 0, finfo->entries, (RCSNode *)NULL);
d3508 1
a3508 1
	send_modified (finfo->file, finfo->fullname, vers);
d3533 1
d3667 1
a3667 1
send_file_names (argc, argv, flags)
a3669 1
    unsigned int flags;
a3676 5
    /* The fact that we do this here as well as start_recursion is a bit 
       of a performance hit.  Perhaps worth cleaning up someday.  */
    if (flags & SEND_EXPAND_WILD)
	expand_wild (argc, argv, &argc, &argv);

a3748 8

    if (flags & SEND_EXPAND_WILD)
    {
	int i;
	for (i = 0; i < argc; ++i)
	    free (argv[i]);
	free (argv);
    }
d3778 1
a3778 1
	exit (EXIT_FAILURE);
a4258 28
void
send_init_command ()
{
    /* This is here because we need the server_cvsroot variable.  */
    send_to_server ("init ", 0);
    send_to_server (server_cvsroot, 0);
    send_to_server ("\012", 0);
}

int
client_init (argc, argv)
    int argc;
    char **argv;
{
    parse_cvsroot ();

    return init (argc, argv);	/* Call real code */
}

int
client_annotate (argc, argv)
    int argc;
    char **argv;
{
    parse_cvsroot ();

    return annotate (argc, argv);	/* Call real code */
}
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a9 1
#include "buffer.h"
d25 4
a38 5

/* Information we need if we are going to use Kerberos encryption.  */
static C_Block kblock;
static Key_schedule sched;

a83 1
static void handle_f PROTO((char *, int));
a85 1
static void buf_memory_error PROTO((struct buffer *));
d105 2
a106 2
    char buf[18], u[4], g[4], o[4];
    int i;
d108 17
a124 17
    i = 0;
    if (mode & S_IRUSR) u[i++] = 'r';
    if (mode & S_IWUSR) u[i++] = 'w';
    if (mode & S_IXUSR) u[i++] = 'x';
    u[i] = '\0';

    i = 0;
    if (mode & S_IRGRP) g[i++] = 'r';
    if (mode & S_IWGRP) g[i++] = 'w';
    if (mode & S_IXGRP) g[i++] = 'x';
    g[i] = '\0';

    i = 0;
    if (mode & S_IROTH) o[i++] = 'r';
    if (mode & S_IWOTH) o[i++] = 'w';
    if (mode & S_IXOTH) o[i++] = 'x';
    o[i] = '\0';
d126 2
a127 2
    sprintf(buf, "u=%s,g=%s,o=%s", u, g, o);
    return xstrdup(buf);
d238 6
a243 1
int client_prune_dirs;
d245 1
a245 1
static List *ignlist = (List *) NULL;
d247 1
a247 9
/* Buffer to write to the server.  */
static struct buffer *to_server;
/* The stream underlying to_server, if we are using a stream.  */
static FILE *to_server_fp;

/* Buffer used to read from the server.  */
static struct buffer *from_server;
/* The stream underlying from_server, if we are using a stream.  */
static FILE *from_server_fp;
d249 1
a249 2
/* Process ID of rsh subprocess.  */
static int rsh_pid = -1;
d251 1
a251 3

/* This routine is called when one of the buffer routines runs out of
   memory.  */
d253 1
d255 1
a255 2
buf_memory_error (buf)
     struct buffer *buf;
d257 8
a264 16
    error (1, 0, "out of memory");
}

/* We want to be able to log data sent between us and the server.  We
   do it using log buffers.  Each log buffer has another buffer which
   handles the actual I/O, and a file to log information to.

   This structure is the closure field of a log buffer.  */

struct log_buffer
{
    /* The underlying buffer.  */
    struct buffer *buf;
    /* The file to log information to.  */
    FILE *log;
};
d266 1
a266 30
static struct buffer *log_buffer_initialize
  PROTO((struct buffer *, FILE *, int, void (*) (struct buffer *)));
static int log_buffer_input PROTO((void *, char *, int, int, int *));
static int log_buffer_output PROTO((void *, const char *, int, int *));
static int log_buffer_flush PROTO((void *));
static int log_buffer_block PROTO((void *, int));
static int log_buffer_shutdown PROTO((void *));

/* Create a log buffer.  */

static struct buffer *
log_buffer_initialize (buf, fp, input, memory)
     struct buffer *buf;
     FILE *fp;
     int input;
     void (*memory) PROTO((struct buffer *));
{
    struct log_buffer *n;

    n = (struct log_buffer *) xmalloc (sizeof *n);
    n->buf = buf;
    n->log = fp;
    return buf_initialize (input ? log_buffer_input : NULL,
			   input ? NULL : log_buffer_output,
			   input ? NULL : log_buffer_flush,
			   log_buffer_block,
			   log_buffer_shutdown,
			   memory,
			   n);
}
d268 9
a276 1
/* The input function for a log buffer.  */
d278 2
a279 25
static int
log_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
{
    struct log_buffer *lb = (struct log_buffer *) closure;
    int status;
    size_t n_to_write;

    if (lb->buf->input == NULL)
	abort ();

    status = (*lb->buf->input) (lb->buf->closure, data, need, size, got);
    if (status != 0)
	return status;

    if (*got > 0)
    {
	n_to_write = *got;
	if (fwrite (data, 1, n_to_write, lb->log) != n_to_write)
	    error (0, errno, "writing to log file");
    }
d281 5
a285 2
    return 0;
}
d287 4
a290 1
/* The output function for a log buffer.  */
d292 16
a307 23
static int
log_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
{
    struct log_buffer *lb = (struct log_buffer *) closure;
    int status;
    size_t n_to_write;

    if (lb->buf->output == NULL)
	abort ();

    status = (*lb->buf->output) (lb->buf->closure, data, have, wrote);
    if (status != 0)
	return status;

    if (*wrote > 0)
    {
	n_to_write = *wrote;
	if (fwrite (data, 1, n_to_write, lb->log) != n_to_write)
	    error (0, errno, "writing to log file");
a308 35

    return 0;
}

/* The flush function for a log buffer.  */

static int
log_buffer_flush (closure)
     void *closure;
{
    struct log_buffer *lb = (struct log_buffer *) closure;

    if (lb->buf->flush == NULL)
	abort ();

    /* We don't really have to flush the log file here, but doing it
       will let tail -f on the log file show what is sent to the
       network as it is sent.  */
    if (fflush (lb->log) != 0)
        error (0, errno, "flushing log file");

    return (*lb->buf->flush) (lb->buf->closure);
}

/* The block function for a log buffer.  */

static int
log_buffer_block (closure, block)
     void *closure;
     int block;
{
    struct log_buffer *lb = (struct log_buffer *) closure;

    if (block)
	return set_block (lb->buf);
d310 9
a318 12
	return set_nonblock (lb->buf);
}

/* The shutdown function for a log buffer.  */

static int
log_buffer_shutdown (closure)
     void *closure;
{
    struct log_buffer *lb = (struct log_buffer *) closure;

    return buf_shutdown (lb->buf);
a321 1

d326 1
a326 2
   socket and nothing else.  */

d329 1
d331 8
a338 2
/* These routines implement a buffer structure which uses send and
   recv.  We don't need the block routine, so we don't implement it.  */
d340 4
a343 1
/* We use an instance of this structure as the closure field.  */
d345 13
a357 1
struct socket_buffer
d359 4
a362 3
    /* The socket number.  */
    int socket;
};
d364 4
a367 26
static struct buffer *socket_buffer_initialize
  PROTO ((int, int, void (*) (struct buffer *)));
static int socket_buffer_input PROTO((void *, char *, int, int, int *));
static int socket_buffer_output PROTO((void *, const char *, int, int *));
static int socket_buffer_flush PROTO((void *));

/* Create a buffer based on a socket.  */

static struct buffer *
socket_buffer_initialize (socket, input, memory)
     int socket;
     int input;
     void (*memory) PROTO((struct buffer *));
{
    struct socket_buffer *n;

    n = (struct socket_buffer *) xmalloc (sizeof *n);
    n->socket = socket;
    return buf_initialize (input ? socket_buffer_input : NULL,
			   input ? NULL : socket_buffer_output,
			   input ? NULL : socket_buffer_flush,
			   (int (*) PROTO((void *, int))) NULL,
			   (int (*) PROTO((void *))) NULL,
			   memory,
			   n);
}
d369 1
a369 1
/* The buffer input function for a buffer built on a socket.  */
d371 1
a371 21
static int
socket_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
{
    struct socket_buffer *sb = (struct socket_buffer *) closure;
    int nbytes;

    /* I believe that the recv function gives us exactly the semantics
       we want.  If there is a message, it returns immediately with
       whatever it could get.  If there is no message, it waits until
       one comes in.  In other words, it is not like read, which in
       blocking mode normally waits until all the requested data is
       available.  */

    *got = 0;

    while (need > 0)
a372 8
	nbytes = recv (sb->socket, data, size, 0);
	if (nbytes < 0)
	    error (1, errno, "reading from server");
	need -= nbytes;
	size -= nbytes;
	data += nbytes;
	*got += nbytes;
    }
d374 16
a389 2
    return 0;
}
d391 3
a393 1
/* The buffer output function for a buffer built on a socket.  */
d395 12
a406 21
static int
socket_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
{
    struct socket_buffer *sb = (struct socket_buffer *) closure;

    *wrote = have;

#ifdef SEND_NEVER_PARTIAL
    /* If send() never will produce a partial write, then just do it.  This
       is needed for systems where its return value is something other than
       the number of bytes written.  */
    if (send (sb->socket, data, have, 0) < 0)
	error (1, errno, "writing to server socket");
#else
    while (have > 0)
    {
	int nbytes;
d408 9
a416 6
	nbytes = send (sb->socket, data, have, 0);
	if (nbytes < 0)
	    error (1, errno, "writing to server socket");

	have -= nbytes;
	data += nbytes;
a417 1
#endif
d419 2
a420 2
    return 0;
}
d422 2
a423 10
/* The buffer flush function for a buffer built on a socket.  */

/*ARGSUSED*/
static int
socket_buffer_flush (closure)
     void *closure;
{
    /* Nothing to do.  Sockets are always flushed.  */
    return 0;
}
d425 2
d428 13
a440 29

/*
 * Read a line from the server.  Result does not include the terminating \n.
 *
 * Space for the result is malloc'd and should be freed by the caller.
 *
 * Returns number of bytes read.
 */
static int
read_line (resultp)
    char **resultp;
{
    int status;
    char *result;
    int len;

    status = buf_flush (to_server, 1);
    if (status != 0)
	error (1, status, "writing to server");

    status = buf_read_line (from_server, &result, &len);
    if (status != 0)
    {
	if (status == -1)
	    error (1, 0, "end of file from server (consult above messages if any)");
	else if (status == -2)
	    error (1, 0, "out of memory");
	else
	    error (1, status, "reading from server");
d442 2
a443 4

    if (resultp != NULL)
	*resultp = result;
    else
d445 1
a445 2

    return len;
a458 5
/*
 * Level of compression to use when running gzip on a single file.
 */
int file_gzip_level;

d460 2
a461 2
    int fd, dir, level;
    pid_t *pidp;
d463 2
a464 2
    static char buf[5] = "-";
    static char *gzip_argv[3] = { "gzip", buf };
d466 2
a467 2
    sprintf (buf+1, "%d", level);
    return filter_stream_through_program (fd, dir, &gzip_argv[0], pidp);
d471 2
a472 2
    int fd, dir;
    pid_t *pidp;
d474 2
a475 2
    static char *gunzip_argv[3] = { "gzip", "-d" };
    return filter_stream_through_program (fd, dir, &gunzip_argv[0], pidp);
a600 5
/* This variable holds the result of Entries_Open, so that we can
   close Entries_Close on it when we move on to a new directory, or
   when we finish.  */
static List *last_entries;

d621 2
d650 1
a650 1
	read_line (&reposname);
a713 6
	int newdir;

	if (strcmp (command_name, "export") != 0)
	    if (last_entries)
		Entries_Close (last_entries);

d723 1
a723 1
	if ( CVS_CHDIR (toplevel_wd) < 0)
d725 1
a725 2
	newdir = 0;
	if ( CVS_CHDIR (dir_name) < 0)
a733 1
	    newdir = 1;
d762 1
a762 1
		{
d768 2
a769 2
			error (0, 0,
			       "internal error: repository string too short.");
d771 2
a772 2
			rdirp = strchr (rdirp, '/');
		}
d774 1
a774 1
		{
d792 1
a792 1
		}
d794 1
a794 1
		if (mkdir_if_needed (dir))
d796 25
a820 1
		    /* It already existed, fine.  Just keep going.  */
d834 1
a834 1
		    char *r, *b;
a858 10

		    b = strrchr (dir, '/');
		    if (b == NULL)
			Subdir_Register ((List *) NULL, (char *) NULL, dir);
		    else
		    {
			*b = '\0';
			Subdir_Register ((List *) NULL, dir, b + 1);
			*b = '/';
		    }
d870 1
a870 1
	    if ( CVS_CHDIR (dir_name) < 0)
a873 35
	/* If the modules file has an entry for the entire tree (e.g.,
           ``world -a .''), we may need to create the CVS directory
           specially in this working directory.  */
	if (strcmp (dir_name, ".") == 0
	    && ! isdir (CVSADM))
	{
	    char *repo;
	    char *r;

	    newdir = 1;

	    repo = xmalloc (strlen (reposdirname)
			    + strlen (toplevel_repos)
			    + 10);
	    if (reposdirname_absolute)
	        r = repo;
	    else
	    {
	        strcpy (repo, toplevel_repos);
		r = repo + strlen (repo);
		*r++ = '/';
	    }

	    strcpy (r, reposdirname);

	    r += strlen (r);
	    if (r[-1] != '.' || r[-2] != '/')
	        strcpy (r, "/.");

	    Create_Admin (dir_name, dir_name, repo, (char *) NULL,
			  (char *) NULL);

	    free (repo);
	}

d876 2
a878 21

	    /* If this is a newly created directory, we will record
	       all subdirectory information, so call Subdirs_Known in
	       case there are no subdirectories.  If this is not a
	       newly created directory, it may be an old working
	       directory from before we recorded subdirectory
	       information in the Entries file.  We force a search for
	       all subdirectories now, to make sure our subdirectory
	       information is up to date.  If the Entries file does
	       record subdirectory information, then this call only
	       does list manipulation.  */
	    if (newdir)
		Subdirs_Known (last_entries);
	    else
	    {
		List *dirlist;

		dirlist = Find_Directories ((char *) NULL, W_LOCAL,
					    last_entries);
		dellist (&dirlist);
	    }
d904 1
a904 1
    read_line (&newname);
d952 1
a952 1
    read_line (&size_string);
d971 1
a971 1
    fp = CVS_FOPEN (filename, "wb");
a1004 5
 * The time stamp of the last file we registered.
 */
static time_t last_register_time;

/*
a1087 9
    enum {
	/* We are replacing an existing file.  */
	UPDATE_ENTRIES_EXISTING,
	/* We are creating a new file.  */
	UPDATE_ENTRIES_NEW,
	/* We don't know whether it is existing or new.  */
	UPDATE_ENTRIES_EXISTING_OR_NEW
    } existp;

d1118 1
a1118 1
    read_line (&entries_line);
d1181 1
a1181 1
	read_line (&mode_string);
d1183 1
a1183 1
	read_line (&size_string);
a1195 50
	/* Note that checking this separately from writing the file is
	   a race condition: if the existing or lack thereof of the
	   file changes between now and the actually calls which
	   operate on it, we lose.  However (a) there are so many
	   cases, I'm reluctant to try to fix them all, (b) in some
	   cases the system might not even have a system call which
	   does the right thing, and (c) it isn't clear this needs to
	   work.  */
	if (data->existp == UPDATE_ENTRIES_EXISTING
	    && !isfile (filename))
	    /* Emit a warning and update the file anyway.  */
	    error (0, 0, "warning: %s unexpectedly disappeared",
		   short_pathname);

	if (data->existp == UPDATE_ENTRIES_NEW
	    && isfile (filename))
	{
	    /* Emit a warning and refuse to update the file; we don't want
	       to clobber a user's file.  */
	    size_t nread;
	    size_t toread;

	    /* size should be unsigned, but until we get around to fixing
	       that, work around it.  */
	    size_t usize;

	    char buf[8192];

	    error (0, 0, "move away %s; it is in the way", short_pathname);

	discard_file_and_return:
	    /* Now read and discard the file contents.  */
	    usize = size;
	    nread = 0;
	    while (nread < usize)
	    {
		toread = usize - nread;
		if (toread > sizeof buf)
		    toread = sizeof buf;

		nread += try_read_from_server (buf, toread);
		if (nread == usize)
		    break;
	    }

	    free (mode_string);
	    free (entries_line);
	    return;
	}

d1222 1
a1222 1
        fd = CVS_OPEN (temp_filename,
d1227 1
a1227 10
	{
	    /* I can see a case for making this a fatal error; for a condition
	       like disk full or network unreachable (for a file server),
	       carrying on and giving an error on each file seems unnecessary.
	       But if it is a permission problem, or some such, then it is
	       entirely possible that future files will not have the same
	       problem.  */
	    error (0, errno, "cannot write %s", short_pathname);
	    goto discard_file_and_return;
	}
d1234 4
a1237 4
	    read_from_server (buf, size);

	    if (write (fd, buf, size) != size)
		error (1, errno, "writing %s", short_pathname);
d1270 1
a1270 1
	        if ( CVS_UNLINK (temp_filename) < 0)
a1274 18
#ifdef BROKEN_READWRITE_CONVERSION
	    {
		/* If only stdio, not open/write/etc., do text/binary
		   conversion, use convert_file which can compensate
		   (FIXME: we could just use stdio instead which would
		   avoid the whole problem).  */
		if (!bin)
		{
		    convert_file (temp_filename, O_RDONLY | OPEN_BINARY,
				  filename, O_WRONLY | O_CREAT | O_TRUNC);
		    if (CVS_UNLINK (temp_filename) < 0)
			error (0, errno, "warning: couldn't delete %s",
			       temp_filename);
		}
		else
		    rename_file (temp_filename, filename);
	    }
#else
a1275 1
#endif
d1292 1
a1292 1
	    if ( CVS_STAT (temp_filename, &s) < 0)
d1363 1
a1363 1
	    e = CVS_FOPEN (filename, "r");
a1424 2
	(void) time (&last_register_time);

a1461 1
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
a1472 1
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
a1483 29
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
    dat.timestamp = NULL;
    call_in_directory (args, update_entries, (char *)&dat);
}

static void handle_created PROTO((char *, int));

static void
handle_created (args, len)
    char *args;
    int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_UPDATE;
    dat.existp = UPDATE_ENTRIES_NEW;
    dat.timestamp = NULL;
    call_in_directory (args, update_entries, (char *)&dat);
}

static void handle_update_existing PROTO((char *, int));

static void
handle_update_existing (args, len)
    char *args;
    int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_UPDATE;
    dat.existp = UPDATE_ENTRIES_EXISTING;
a1494 2
    /* Think this could be UPDATE_ENTRIES_EXISTING, but just in case...  */
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
a1505 2
    /* Think this could be UPDATE_ENTRIES_EXISTING, but just in case...  */
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
a1535 5
    /* Note that we don't ignore existence_error's here.  The server
       should be sending Remove-entry rather than Removed in cases
       where the file does not exist.  And if the user removes the
       file halfway through a cvs command, we should be printing an
       error.  */
d1555 1
a1555 1
    if (strcmp (toplevel_repos, CVSroot_directory) != 0)
d1560 1
a1560 1
	if (strncmp (pathname, CVSroot_directory, strlen (CVSroot_directory)) != 0)
d1563 2
a1564 2
		   pathname, CVSroot_directory);
	short_pathname = pathname + strlen (CVSroot_directory) + 1;
d1568 1
a1568 1
		   pathname, CVSroot_directory);
d1598 1
a1598 1
	read_line (NULL);
d1623 1
a1623 1
	read_line (NULL);
d1648 1
a1648 1
    read_line (&tagspec);
d1665 1
a1665 1
	read_line (NULL);
d1667 1
a1667 1
	read_line (NULL);
d1678 1
a1678 1
	read_line (NULL);
d1680 1
a1680 1
	read_line (NULL);
d1706 1
a1706 1
	read_line (NULL);
d1769 1
a1769 1
    read_line (&prog);
d1784 1
a1784 1
    read_line (&prog);
d1804 1
a1804 1
	if ( CVS_CHDIR (toplevel_wd) < 0)
d1850 1
a1850 1
    if ((dirp = CVS_OPENDIR (dir)) == NULL)
d1906 2
a1907 2
    {
	if ( CVS_CHDIR (toplevel_wd) < 0)
d1909 1
a1909 1
    }
d1914 1
a1914 11
	    char *b;

	    unlink_file_dir (p->dir);
	    b = strrchr (p->dir, '/');
	    if (b == NULL)
		Subdir_Deregister ((List *) NULL, (char *) NULL, p->dir);
	    else
	    {
		*b = '\0';
		Subdir_Deregister ((List *) NULL, p->dir, b + 1);
	    }
a1920 1
    prune_candidates = NULL;
d2014 1
a2014 1
	f = CVS_FOPEN (adm_name, "r");
d2023 1
a2023 1
	    char *nl = NULL;
d2046 1
a2046 1
	f = CVS_FOPEN (adm_name, "r");
d2055 1
a2055 1
	    char *nl = NULL;
d2081 1
a2081 1
	f = CVS_FOPEN (adm_name, "r");
d2090 1
a2090 1
	    char *nl = NULL;
d2246 1
a2246 1
    send_a_repository ("", CVSroot_directory, "");
d2262 2
a2263 3
client_send_expansions (local, where)
    int local;
    char *where;
d2278 1
a2278 1
	argv[0] = where ? where : modules_vector[i];
d2282 1
a2282 1
    send_a_repository ("", CVSroot_directory, "");
d2288 1
a2288 1
    send_a_repository ("", CVSroot_directory, "");
d2296 2
a2297 7
    /* In the case where stdout and stderr point to the same place,
       fflushing stderr will make output happen in the correct order.
       Often stderr will be line-buffered and this won't be needed,
       but not always.  */
    fflush (stderr);
    fwrite (args, len, sizeof (*args), stdout);
    putc ('\n', stdout);
d2305 2
a2306 14
    /* In the case where stdout and stderr point to the same place,
       fflushing stdout will make output happen in the correct order.  */
    fflush (stdout);
    fwrite (args, len, sizeof (*args), stderr);
    putc ('\n', stderr);
}

/*ARGSUSED*/
static void
handle_f (args, len)
    char *args;
    int len;
{
    fflush (stderr);
a2330 3
    RSP_LINE("Created", handle_created, response_type_normal, rs_optional),
    RSP_LINE("Update-existing", handle_update_existing, response_type_normal,
       rs_optional),
a2357 1
    RSP_LINE("F", handle_f, response_type_normal, rs_optional),
d2378 8
a2385 1
    static int nbytes;
d2387 8
a2394 2
    if (len == 0)
	len = strlen (str);
d2396 13
a2408 1
    buf_output (to_server, str, len);
d2410 12
a2421 12
    /* There is no reason not to send data to the server, so do it
       whenever we've accumulated enough information in the buffer to
       make it worth sending.  */
    nbytes += len;
    if (nbytes >= 2 * BUFFER_DATA_SIZE)
    {
	int status;

        status = buf_send_output (to_server);
	if (status != 0)
	    error (1, status, "error writing to server");
	nbytes = 0;
d2423 4
d2429 2
a2430 3
/* Read up to LEN bytes from the server.  Returns actual number of
   bytes read, which will always be at least one; blocks if there is
   no data available at all.  Gives a fatal error on EOF or error.  */
d2436 1
a2436 2
    int status, nread;
    char *data;
d2438 9
a2446 2
    status = buf_read_data (from_server, len, &data, &nread);
    if (status != 0)
d2448 4
a2451 1
	if (status == -1)
a2453 4
	else if (status == -2)
	    error (1, 0, "out of memory");
	else
	    error (1, status, "reading from server");
d2456 7
a2462 1
    memcpy (buf, data, nread);
d2496 1
a2496 1
	len = read_line (&cmd);
a2541 7
    int status;

    if (last_entries != NULL)
    {
	Entries_Close (last_entries);
	last_entries = NULL;
    }
a2547 13
    /* The calls to buf_shutdown are currently only meaningful when we
       are using compression.  First we shut down TO_SERVER.  That
       tells the server that its input is finished.  It then shuts
       down the buffer it is sending to us, at which point our shut
       down of FROM_SERVER will complete.  */

    status = buf_shutdown (to_server);
    if (status != 0)
        error (0, status, "shutting down buffer to server");
    status = buf_shutdown (from_server);
    if (status != 0)
	error (0, status, "shutting down buffer from server");

d2550 4
a2553 4
    {
	if (shutdown (server_sock, 2) < 0)
	    error (1, errno, "shutting down server socket");
    }
d2556 1
a2556 1
    {
d2558 4
a2561 5
	if (server_fd != -1)
	{
	    if (shutdown (server_fd, 1) < 0)
		error (1, errno, "shutting down connection to %s",
		       CVSroot_hostname);
d2565 8
a2572 8
	    if (fileno (from_server_fp) != fileno (to_server_fp))
	    {
		if (fclose (to_server_fp) != 0)
		    error (1, errno,
			   "closing down connection to %s",
			   CVSroot_hostname);
	    }
	}
d2577 1
a2577 1
	    SHUTDOWN_SERVER (fileno (to_server_fp));
d2579 2
a2580 2
	{

d2582 1
a2582 1
	    if (pclose (to_server_fp) == EOF)
d2584 1
a2584 1
		if (fclose (to_server_fp) == EOF)
d2586 3
a2588 4
		{
		    error (1, errno, "closing connection to %s",
			   CVSroot_hostname);
		}
d2591 6
a2596 7
	if (! buf_empty_p (from_server)
	    || getc (from_server_fp) != EOF)
	    error (0, 0, "dying gasps from %s unexpected", CVSroot_hostname);
	else if (ferror (from_server_fp))
	    error (0, errno, "reading from %s", CVSroot_hostname);

	fclose (from_server_fp);
d2598 3
a2600 2
    }

d2604 1
a2607 10
    /* see if we need to sleep before returning */
    if (last_register_time)
    {
	time_t now;

	(void) time (&now);
	if (now == last_register_time)
	    sleep (1);			/* to avoid time-stamp races */
    }

d2611 1
d2613 1
d2617 1
a2617 1
    char *name;
d2619 1
a2619 1
    struct request *rq;
d2621 6
a2626 6
    for (rq = requests; rq->name; rq++)
	if (!strcmp (rq->name, name))
	    return rq->status == rq_supported;
    error (1, 0, "internal error: testing support for unknown option?");
    /* NOTREACHED */
    return 0;
d2655 1
a2655 6
    struct servent *s = getservbyname ("cvspserver", "tcp");

    if (s)
	return ntohs (s->s_port);
    else
	return CVS_AUTH_PORT;
d2682 3
d2692 1
a2692 1
    init_sockaddr (&client_sai, CVSroot_hostname, port_number);
d2695 2
a2696 2
	error (1, errno, "connect to %s:%d failed", CVSroot_hostname,
	       port_number);
d2703 2
a2704 2
	char *repository = CVSroot_directory;
	char *username   = CVSroot_username;
d2720 1
a2720 1
	password = get_cvs_password ();
d2754 1
a2754 1
                error (1, errno, "recv() from server %s", CVSroot_hostname);
d2766 1
a2766 1
		       CVSroot_hostname);
d2768 1
a2768 1
		       "shutdown() failed (server %s)", CVSroot_hostname);
d2776 1
a2776 1
		       CVSroot_hostname);
d2785 2
a2786 2
		       CVSroot_hostname, read_buf);
		error (1, errno, "shutdown() failed, server %s", CVSroot_hostname);
d2790 1
a2790 1
		   CVSroot_hostname, read_buf);
d2797 1
a2797 1
	    error (0, errno, "shutdown() failed, server %s", CVSroot_hostname);
d2834 1
a2834 1
    int *tofdp, *fromfdp;
d2836 8
a2843 1
    int tofd = -1, fromfd;
a2844 6
    struct hostent *hp;
    char *hname;
    const char *portenv;
    int port;
    struct sockaddr_in sin;
    int s;
d2847 2
a2848 2
    KTEXT_ST ticket;
    const char *realm;
d2851 15
a2865 23
    int status;

#ifndef HAVE_KERBEROS
    /* It is a crock to have :kserver: sometimes mean kerberos,
       and sometimes mean "direct tcp", based on USE_DIRECT_TCP.
       If we need the "direct tcp" stuff, we need a new access method,
       like :direct: or something.  */
    error (1, 0, "this CVS executable does not support kerberos");
#endif

    /*
     * We look up the host to give a better error message if it
     * does not exist.  However, we then pass CVSroot_hostname to
     * krb_sendauth, rather than the canonical name, because
     * krb_sendauth is going to do its own canonicalization anyhow
     * and that lets us not worry about the static storage used by
     * gethostbyname.
     */
    hp = gethostbyname (CVSroot_hostname);
    if (hp == NULL)
	error (1, 0, "%s: unknown host", CVSroot_hostname);
    hname = xmalloc (strlen (hp->h_name) + 1);
    strcpy (hname, hp->h_name);
d2868 1
a2868 1
    realm = krb_realmofhost (hname);
d2870 11
a2880 16

    /* Get CVS_CLIENT_PORT or look up cvs/tcp with CVS_PORT as default */
    portenv = getenv ("CVS_CLIENT_PORT");
    if (portenv != NULL)
    {
	port = atoi (portenv);
	if (port <= 0)
	{
	    error (0, 0, "CVS_CLIENT_PORT must be a positive number!  If you");
	    error (0, 0, "are trying to force a connection via rsh, please");
	    error (0, 0, "put \":server:\" at the beginning of your CVSROOT");
	    error (1, 0, "variable.");
	}
	if (trace)
	    fprintf(stderr, "Using TCP port %d to contact server.\n", port);
	port = htons (port);
d2882 1
a2882 1
    else
d2884 7
a2890 7
	struct servent *sp;

	sp = getservbyname ("cvs", "tcp");
	if (sp == NULL)
	    port = htons (CVS_PORT);
	else
	    port = sp->s_port;
d2892 18
a2909 17

    s = socket (AF_INET, SOCK_STREAM, 0);
    if (s < 0)
	error (1, errno, "socket");

    memset (&sin, 0, sizeof sin);
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = INADDR_ANY;
    sin.sin_port = 0;

    if (bind (s, (struct sockaddr *) &sin, sizeof sin) < 0)
	error (1, errno, "bind");

    memcpy (&sin.sin_addr, hp->h_addr, hp->h_length);
    sin.sin_port = port;

    if (connect (s, (struct sockaddr *) &sin, sizeof sin) < 0)
d2911 2
a2912 2
	error (0, errno, "connect");
	close (s);
d2914 1
a2914 1
    else
d2917 15
a2931 14
	struct sockaddr_in laddr;
	int laddrlen;
	MSG_DAT msg_data;
	CREDENTIALS cred;

	laddrlen = sizeof (laddr);
	if (getsockname (s, (struct sockaddr *) &laddr, &laddrlen) < 0)
	    error (1, errno, "getsockname");

	/* We don't care about the checksum, and pass it as zero.  */
	status = krb_sendauth (KOPT_DO_MUTUAL, s, &ticket, "rcmd",
			       hname, realm, (unsigned long) 0, &msg_data,
			       &cred, sched, &laddr, &sin, "KCVSV1.0");
	if (status != KSUCCESS)
d2933 2
a2934 2
	    error (0, 0, "kerberos: %s", krb_get_err_text(status));
	    close (s);
d2936 1
a2936 1
	else
a2937 2
	    memcpy (kblock, cred.session, sizeof (C_Block));

d2940 3
a2942 3
	    server_fd = s;
	    close_on_exec (server_fd);
	    tofd = fromfd = s;
d2949 1
a2949 1
    if (tofd == -1)
d2951 21
a2971 13
#ifdef HAVE_KERBEROS
	error (0, 0, "Kerberos connect failed");
#else
	error (0, 0, "Direct TCP connect failed");
#endif
	error (1, 0, "couldn't connect to remote host %s", CVSroot_hostname);
    }

    free (hname);

    /* Give caller the values it wants. */
    *tofdp   = tofd;
    *fromfdp = fromfd;
d2995 2
a2996 2
    int tofd, fromfd;
    char *log = getenv ("CVS_CLIENT_LOG");
d2998 8
a3005 7
    /* Note that generally speaking we do *not* fall back to a different
       way of connecting if the first one does not work.  This is slow
       (*really* slow on a 14.4kbps link); the clean way to have a CVS
       which supports several ways of connecting is with access methods.  */

    switch (CVSroot_method)
    {
d3008 9
a3016 7
	case pserver_method:
	    /* Toss the return value.  It will die with error if anything
	       goes wrong anyway. */
	    connect_to_pserver (&tofd, &fromfd, 0);
	    break;
#endif

d3018 2
a3019 4
	case kserver_method:
	    start_tcp_server (&tofd, &fromfd);
	    break;
#endif
d3021 8
a3028 15
	case ext_method:
	    start_rsh_server (&tofd, &fromfd);
	    break;

	case server_method:
#if defined(START_SERVER)
	    START_SERVER (&tofd, &fromfd, getcaller (),
			  CVSroot_username, CVSroot_hostname,
			  CVSroot_directory);
#  if defined (START_SERVER_RETURNS_SOCKET) && defined (NO_SOCKET_TO_FD)
	    /* This is a system on which we can only write to a socket
	       using send/recv.  Therefore its START_SERVER needs to
	       return a socket.  */
	    use_socket_style = 1;
	    server_sock = tofd;
a3029 7

#else
	    /* FIXME: It should be possible to implement this portably,
	       like pserver, which would get rid of the duplicated code
	       in {vms,windows-NT,...}/startserver.c.  */
	    error (1, 0, "\
the :server: access method is not supported by this port of CVS");
d3031 1
a3031 1
	    break;
d3033 5
a3037 5
	default:
	    error (1, 0, "\
(start_server internal error): unknown access method");
	    break;
    }
d3042 2
a3043 2
#ifdef NO_SOCKET_TO_FD
    if (use_socket_style)
d3045 18
a3062 4
	to_server = socket_buffer_initialize (server_sock, 0,
					      buf_memory_error);
	from_server = socket_buffer_initialize (server_sock, 1,
						buf_memory_error);
d3064 3
a3066 1
    else
d3068 1
a3068 1
    {
d3084 7
a3090 46
        to_server_fp = fdopen (tofd, FOPEN_BINARY_WRITE);
        if (to_server_fp == NULL)
	    error (1, errno, "cannot fdopen %d for write", tofd);
	to_server = stdio_buffer_initialize (to_server_fp, 0,
					     buf_memory_error);

        from_server_fp = fdopen (fromfd, FOPEN_BINARY_READ);
        if (from_server_fp == NULL)
	    error (1, errno, "cannot fdopen %d for read", fromfd);
	from_server = stdio_buffer_initialize (from_server_fp, 1,
					       buf_memory_error);
    }

    /* Set up logfiles, if any. */
    if (log)
    {
	int len = strlen (log);
	char *buf = xmalloc (len + 5);
	char *p;
	FILE *fp;

	strcpy (buf, log);
	p = buf + len;

	/* Open logfiles in binary mode so that they reflect
	   exactly what was transmitted and received (that is
	   more important than that they be maximally
	   convenient to view).  */
	strcpy (p, ".in");
	fp = open_file (buf, "wb");
        if (fp == NULL)
	    error (0, errno, "opening to-server logfile %s", buf);
	else
	    to_server = log_buffer_initialize (to_server, fp, 0,
					       buf_memory_error);

	strcpy (p, ".out");
	fp = open_file (buf, "wb");
        if (fp == NULL)
	    error (0, errno, "opening from-server logfile %s", buf);
	else
	    from_server = log_buffer_initialize (from_server, fp, 1,
						 buf_memory_error);

	free (buf);
    }
d3094 1
a3094 1
	free (toplevel_repos);
d3097 1
a3097 1
	free (last_dir_name);
d3100 1
a3100 1
	free (last_repos);
d3103 1
a3103 1
	free (last_update_dir);
d3111 1
a3111 1
	send_to_server (CVSroot_directory, 0);
a3209 28
    if (cvsencrypt)
    {
#ifdef ENCRYPTION
	/* Turn on encryption before turning on compression.  We do
           not want to try to compress the encrypted stream.  Instead,
           we want to encrypt the compressed stream.  If we can't turn
           on encryption, bomb out; don't let the user think the data
           is being encrypted when it is not.  */
#ifdef HAVE_KERBEROS
	if (CVSroot_method == kserver_method)
	{
	    if (! supported_request ("Kerberos-encrypt"))
		error (1, 0, "This server does not support encryption");
	    send_to_server ("Kerberos-encrypt\012", 0);
	    to_server = krb_encrypt_buffer_initialize (to_server, 0, sched,
						       kblock,
						       buf_memory_error);
	    from_server = krb_encrypt_buffer_initialize (from_server, 1,
							 sched, kblock,
							 buf_memory_error);
	}
	else
#endif /* HAVE_KERBEROS */
	    error (1, 0, "Encryption is only supported when using Kerberos");
#else /* ! ENCRYPTION */
	error (1, 0, "This client does not support encryption");
#endif /* ! ENCRYPTION */
    }
d3212 1
a3212 19
	if (supported_request ("Gzip-stream"))
	{
	    char gzip_level_buf[5];
	    send_to_server ("Gzip-stream ", 0);
	    sprintf (gzip_level_buf, "%d", gzip_level);
	    send_to_server (gzip_level_buf, 0);
	    send_to_server ("\012", 1);

	    /* All further communication with the server will be
               compressed.  */

	    to_server = compress_buffer_initialize (to_server, 0, gzip_level,
						    buf_memory_error);
	    from_server = compress_buffer_initialize (from_server, 1,
						      gzip_level,
						      buf_memory_error);
	}
#ifndef NO_CLIENT_GZIP_PROCESS
	else if (supported_request ("gzip-file-contents"))
a3219 2

	    file_gzip_level = gzip_level;
a3220 1
#endif
a3223 3
	    /* Setting gzip_level to 0 prevents us from giving the
               error twice if update has to contact the server again
               to fetch unpatchable files.  */
d3242 1
d3261 1
a3261 1
    int *tofdp, *fromfdp;
d3263 26
a3288 26
    int pipes[2];

    /* If you're working through firewalls, you can set the
       CVS_RSH environment variable to a script which uses rsh to
       invoke another rsh on a proxy machine.  */
    char *cvs_rsh = getenv ("CVS_RSH");
    char *cvs_server = getenv ("CVS_SERVER");
    char command[PATH_MAX];
    int i = 0;
    /* This needs to fit "rsh", "-b", "-l", "USER", "host",
       "cmd (w/ args)", and NULL.  We leave some room to grow. */
    char *rsh_argv[10];

    if (!cvs_rsh)
	cvs_rsh = "rsh";
    if (!cvs_server)
	cvs_server = "cvs";

    /* If you are running a very old (Nov 3, 1994, before 1.5)
     * version of the server, you need to make sure that your .bashrc
     * on the server machine does not set CVSROOT to something
     * containing a colon (or better yet, upgrade the server).  */

    /* The command line starts out with rsh. */
    rsh_argv[i++] = cvs_rsh;

d3290 2
a3291 2
    /* "-b" for binary, under OS/2. */
    rsh_argv[i++] = "-b";
d3294 2
a3295 2
    /* Then we strcat more things on the end one by one. */
    if (CVSroot_username != NULL)
d3297 2
a3298 2
	rsh_argv[i++] = "-l";
	rsh_argv[i++] = CVSroot_username;
d3300 13
a3312 13

    rsh_argv[i++] = CVSroot_hostname;
    rsh_argv[i++] = cvs_server;
    rsh_argv[i++] = "server";

    /* Mark the end of the arg list. */
    rsh_argv[i]   = (char *) NULL;

    if (trace)
    {
	fprintf (stderr, " -> Starting server: ");
	fprintf (stderr, "%s", command);
	putc ('\n', stderr);
d3314 9
a3322 9

    /* Do the deed. */
    rsh_pid = popenRW (rsh_argv, pipes);
    if (rsh_pid < 0)
	error (1, errno, "cannot start server via rsh");

    /* Give caller the file descriptors. */
    *tofdp   = pipes[0];
    *fromfdp = pipes[1];
d3349 1
a3349 1
		       + strlen (CVSroot_directory)
d3363 1
a3363 1
	*p++ = CVSroot_hostname;
d3368 1
a3368 1
	if (CVSroot_username != NULL)
d3371 1
a3371 1
	    *p++ = CVSroot_username;
d3394 1
a3439 3
    if (trace)
	(void) fprintf (stderr, " -> Sending file `%s' to server\n", file);

d3441 1
a3441 1
    if ( CVS_STAT (file, &sb) < 0)
d3462 1
a3462 19
#ifdef BROKEN_READWRITE_CONVERSION
    if (!bin)
    {
	/* If only stdio, not open/write/etc., do text/binary
	   conversion, use convert_file which can compensate
	   (FIXME: we could just use stdio instead which would
	   avoid the whole problem).  */
	char tfile[1024]; strcpy(tfile, file); strcat(tfile, ".CVSBFCTMP");
	convert_file (file, O_RDONLY,
		      tfile, O_WRONLY | O_CREAT | O_TRUNC | OPEN_BINARY);
	fd = CVS_OPEN (tfile, O_RDONLY | OPEN_BINARY);
	if (fd < 0)
	    error (1, errno, "reading %s", short_pathname);
    }
    else
	fd = CVS_OPEN (file, O_RDONLY | OPEN_BINARY);
#else
    fd = CVS_OPEN (file, O_RDONLY | (bin ? OPEN_BINARY : 0));
#endif
d3467 1
a3467 1
    if (file_gzip_level && sb.st_size > 100)
d3474 1
a3474 1
	char *tempfile;
d3506 1
a3506 1
	    tempfile = cvs_temp_name ();
d3516 1
a3516 1
	    fd = CVS_OPEN (tempfile, O_RDONLY | OPEN_BINARY);
d3522 1
a3522 1
	fd = filter_through_gzip (fd, 1, file_gzip_level, &gzip_pid);
d3561 1
a3561 1
	    if ( CVS_UNLINK (tempfile) < 0)
a3563 2
	    free (tempfile);
	    tempfile = NULL;
a3615 8
#ifdef BROKEN_READWRITE_CONVERSION
	if (!bin)
	{
	    char tfile[1024]; strcpy(tfile, file); strcat(tfile, ".CVSBFCTMP");
	    if (CVS_UNLINK (tfile) < 0)
		error (0, errno, "warning: can't remove temp file %s", tfile);
	}
#endif
d3628 1
a3628 1
static int send_fileproc PROTO ((void *callerdat, struct file_info *finfo));
d3632 1
a3632 2
send_fileproc (callerdat, finfo)
    void *callerdat;
a3635 4
    struct file_info xfinfo;
    /* File name to actually use.  Might differ in case from
       finfo->file.  */
    char *filename;
d3639 3
a3641 9
    xfinfo = *finfo;
    xfinfo.repository = NULL;
    xfinfo.rcs = NULL;
    vers = Version_TS (&xfinfo, NULL, NULL, NULL, 0, 0);

    if (vers->entdata != NULL)
	filename = vers->entdata->user;
    else
	filename = finfo->file;
d3647 1
a3647 1
      tmp = xmalloc (strlen (filename) + strlen (vers->vn_user)
d3650 1
a3650 1
               filename, vers->vn_user,
d3687 1
a3687 1
	    send_to_server (filename, 0);
d3698 1
a3698 1
	send_modified (filename, finfo->fullname, vers);
d3706 1
a3706 1
	    send_to_server (filename, 0);
d3748 1
a3748 1
static int send_filesdoneproc PROTO ((void *, int, char *, char *, List *));
d3751 1
a3751 2
send_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
a3754 1
    List *entries;
d3759 1
a3759 1
	ignore_files (ignlist, entries, update_dir, send_ignproc);
d3766 1
a3766 1
static Dtype send_dirent_proc PROTO ((void *, char *, char *, char *, List *));
d3777 1
a3777 2
send_dirent_proc (callerdat, dir, repository, update_dir, entries)
    void *callerdat;
a3780 1
    List *entries;
a3782 1
    char *cvsadm_name;
d3785 6
a3798 13
    /*
     * If the directory does not exist yet (e.g. "cvs update -d foo"),
     * no need to send any files from it.  If the directory does not
     * have a CVS directory, then we pretend that it does not exist.
     * Otherwise, we will fail when trying to open the Entries file.
     * This case will happen when checking out a module defined as
     * ``-a .''.
     */
    cvsadm_name = xmalloc (strlen (dir) + sizeof (CVSADM) + 10);
    sprintf (cvsadm_name, "%s/%s", dir, CVSADM);
    dir_exists = isdir (cvsadm_name);
    free (cvsadm_name);

d3829 2
a3830 2
 * This assumes that the options are separated by spaces, for example
 * STRING might be "--foo -C5 -y".
a3836 1
    char *copy;
d3838 1
d3840 9
a3848 16
    copy = xstrdup (string);
    p = copy;
    while (1)
    {
        char *s;
	char l;

	for (s = p; *s != ' ' && *s != '\0'; s++)
	    ;
	l = *s;
	*s = '\0';
	if (s != p)
	    send_arg (p);
	if (l == '\0')
	    break;
	p = s + 1;
a3849 1
    free (copy);
a3865 5
    char *line;
    size_t line_allocated;

    line = NULL;
    line_allocated = 0;
a3921 46
#ifdef FILENAMES_CASE_INSENSITIVE
	/* We want to send the file name as it appears
	   in CVS/Entries.  We put this inside an ifdef
	   to avoid doing all these system calls in
	   cases where fncmp is just strcmp anyway.  */
	/* For now just do this for files in the local
	   directory.  Would be nice to handle the
	   non-local case too, though.  */
	if (p == last_component (p))
	{
	    FILE *ent;

	    ent = CVS_FOPEN (CVSADM_ENT, "r");
	    if (ent == NULL)
	    {
		if (!existence_error (errno))
		    error (0, errno, "cannot read %s", CVSADM_ENT);
	    }
	    else
	    {
		while (getline (&line, &line_allocated, ent) > 0)
		{
		    char *cp;

		    if (line[0] != '/')
			continue;
		    cp = strchr (line + 1, '/');
		    if (cp == NULL)
			continue;
		    *cp = '\0';
		    if (fncmp (p, line + 1) == 0)
		    {
			p = line + 1;
			break;
		    }
		}
		if (ferror (ent))
		    error (0, errno, "cannot read %s", CVSADM_ENT);
		if (fclose (ent) < 0)
		    error (0, errno, "cannot close %s", CVSADM_ENT);
		/* We don't attempt to look at CVS/Entries.Log.  In a few cases that might
		   lead to strange behaviors, but they should be fairly obscure.  */
	    }
	}
#endif /* FILENAMES_CASE_INSENSITIVE */

a3944 3
    if (line != NULL)
	free (line);

d3978 2
a3979 2
	 send_dirent_proc, (DIRLEAVEPROC)NULL, NULL,
	 argc, argv, local, W_LOCAL, aflag, 0, (char *)NULL, 0);
d3990 1
a3990 1
	toplevel_repos = xstrdup (CVSroot_directory);
d4052 1
a4052 1
	toplevel_repos = xstrdup (CVSroot_directory);
d4097 1
a4097 1
	    if ( CVS_UNLINK (CVSADM_NOTIFY) < 0)
d4237 225
d4465 1
a4465 1
    /* This is here because we need the CVSroot_directory variable.  */
d4467 1
a4467 1
    send_to_server (CVSroot_directory, 0);
d4471 19
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a6 1
#include <assert.h>
d434 1
a434 2
   recv.  The buffer is always in blocking mode so we don't implement
   the block routine.  */
d493 1
a493 1
    do
a497 11
	if (nbytes == 0)
	{
	    /* End of file (for example, the server has closed
	       the connection).  If we've already read something, we
	       just tell the caller about the data, not about the end of
	       file.  If we've read nothing, we return end of file.  */
	    if (*got == 0)
		return -1;
	    else
		return 0;
	}
a502 1
    while (need > 0);
d639 2
a640 4
/* Working directory when we first started.  Note: we could speed things
   up on some systems by using savecwd.h here instead of just always
   storing a name.  */
char *toplevel_wd;
d713 3
d731 21
d780 1
a780 1
    char *short_pathname = pathname;
d803 2
a804 2
    read_line (&reposname);
    assert (reposname != NULL);
d807 1
a807 1
    if (strncmp (reposname, toplevel_repos, strlen (toplevel_repos)) != 0)
d809 1
a809 7
	reposdirname_absolute = 1;
	short_repos = reposname;
    }
    else
    {
	short_repos = reposname + strlen (toplevel_repos) + 1;
	if (short_repos[-1] != '/')
d814 13
d856 8
a863 3
    short_pathname = xmalloc (strlen (pathname) + strlen (filename) + 5);
    strcpy (short_pathname, pathname);
    strcat (short_pathname, filename);
d878 4
a881 6
	if (toplevel_wd == NULL)
	{
	    toplevel_wd = xgetwd ();
	    if (toplevel_wd == NULL)
		error (1, errno, "could not get working directory");
	}
d883 1
a883 1
	if (CVS_CHDIR (toplevel_wd) < 0)
a885 32

	/* Create the CVS directory at the top level if needed.
	   The isdir seems like an unneeded system call, but it *does*
	   need to be called both if the CVS_CHDIR below succeeds (e.g.
	   "cvs co .") or if it fails (e.g. basicb-1a in testsuite).  */
	if (/* I think the reposdirname_absolute case has to do with
	       things like "cvs update /foo/bar".  In any event, the
	       code below which tries to put toplevel_repos into
	       CVS/Repository is almost surely unsuited to
	       the reposdirname_absolute case.  */
	    !reposdirname_absolute

	    && ! isdir (CVSADM))
	{
	    char *repo;
	    char *r;

	    newdir = 1;

	    repo = xmalloc (strlen (toplevel_repos)
			    + 10);
	    strcpy (repo, toplevel_repos);
	    r = repo + strlen (repo);
	    if (r[-1] != '.' || r[-2] != '/')
	        strcpy (r, "/.");

	    Create_Admin (".", ".", repo, (char *) NULL,
			  (char *) NULL);

	    free (repo);
	}

a955 8
		if (fncmp (dir, CVSADM) == 0)
		{
		    error (0, 0, "cannot create a directory named %s", dir);
		    error (0, 0, "because CVS uses \"%s\" for its own uses",
			   CVSADM);
		    error (1, 0, "rename the directory and try again");
		}

d1022 35
d1087 5
a1091 2
    free (short_pathname);
    free (reposname);
d1578 1
a1578 1
	    char *backup;
d1581 1
a1581 3
	    backup = xmalloc (strlen (filename) + 5);
	    strcpy (backup, filename);
	    strcat (backup, "~");
a1633 1
		free (backup);
a1635 1
	    free (backup);
d1889 2
d1894 17
a1910 1
    return strchr (pathname, '/') == NULL;
d2136 1
a2136 1
    char *fname;
d2138 5
a2142 6

    if (toplevel_wd != NULL)
    {
	if (CVS_CHDIR (toplevel_wd) < 0)
	    error (1, errno, "could not chdir to %s", toplevel_wd);
    }
a2144 1
	fname = xmalloc (strlen (p->dir) + sizeof CVSADM_CIPROG + 10);
a2155 1
	free (fname);
d2158 1
a2158 1
    for (p = update_progs; p != NULL; )
a2159 1
	fname = xmalloc (strlen (p->dir) + sizeof CVSADM_UPROG + 10);
a2167 1
	q = p->next;
a2168 2
	p = q;
	free (fname);
d2173 39
d2241 1
a2241 1
    if (toplevel_wd != NULL)
d2243 2
a2244 2
	if (CVS_CHDIR (toplevel_wd) < 0)
	    error (1, errno, "could not chdir to %s", toplevel_wd);
d2248 1
a2248 1
	if (isemptydir (p->dir, 1))
d2252 1
a2252 2
	    if (unlink_file_dir (p->dir) < 0)
		error (0, errno, "cannot remove %s", p->dir);
d2322 2
a2323 5
    send_to_server ("Directory ", 0);
    send_to_server (update_dir, 0);
    send_to_server ("\012", 1);
    send_to_server (repos, 0);
    send_to_server ("\012", 1);
d2325 14
d2609 1
a2609 1
client_send_expansions (local, where, build_dirs)
a2611 1
    int build_dirs;
d2628 1
a2628 1
	    send_files (1, argv, local, 0, build_dirs);
d2990 1
a2990 4
static void init_sockaddr PROTO ((struct sockaddr_in *, char *,
				  unsigned int));

static void
d2993 2
a2994 2
    char *hostname;
    unsigned int port;
a2996 1
	unsigned short shortport = port;
d3000 1
a3000 1
    name->sin_port = htons (shortport);
d3005 1
a3005 1
	error_exit ();
d3011 1
a3011 3
static int auth_server_port_number PROTO ((void));

static int
d3050 1
a3050 1
	error_exit ();
d3062 1
a3062 9
	char ch;

	/* Long enough to hold I LOVE YOU or I HATE YOU.  Using a fixed-size
	   buffer seems better than letting an apeshit server chew up our
	   memory with illegal responses, and the value comes from
	   the protocol itself; it is not an arbitrary limit on data sent.  */
#define LARGEST_RESPONSE 80
	char read_buf[LARGEST_RESPONSE];

d3111 2
a3112 2
	memset (read_buf, 0, LARGEST_RESPONSE);
	for (i = 0; (i < (LARGEST_RESPONSE - 1)) && (ch != '\n'); i++)
d3531 1
a3531 1
	error_exit ();
d3722 1
d3763 1
d4175 12
a4186 2
	/* File no longer exists.  Don't do anything, missing files
	   just happen.  */
d4195 7
a4201 3
	send_to_server ("Unchanged ", 0);
	send_to_server (filename, 0);
	send_to_server ("\012", 1);
a4278 1
    int build_dirs = *(int *) callerdat;
d4326 1
a4326 8
    {
	/* Don't send a non-existent directory unless we are building
           new directories (build_dirs is true).  Otherwise, CVS may
           see a D line in an Entries file, and recreate a directory
           which the user removed by hand.  */
	if (dir_exists || build_dirs)
	    send_a_repository (dir, repository, update_dir);
    }
d4379 5
a4438 1
	char *line = NULL;
d4450 1
a4450 2
	    List *entries;
	    Node *node;
d4452 7
a4458 13
	    /* If we were doing non-local directory,
	       we would save_cwd, CVS_CHDIR
	       like in update.c:isemptydir.  */
	    /* Note that if we are adding a directory,
	       the following will read the entry
	       that we just wrote there, that is, we
	       will get the case specified on the
	       command line, not the case of the
	       directory in the filesystem.  This
	       is correct behavior.  */
	    entries = Entries_Open (0);
	    node = findnode_fn (entries, p);
	    if (node != NULL)
d4460 22
a4481 3
		line = xstrdup (node->key);
		p = line;
		delnode (node);
a4482 1
	    Entries_Close (entries);
a4506 2
	if (line != NULL)
	    free (line);
d4509 3
d4525 1
a4525 2
 * local is nonzero if we should not recurse (-l option).  build_dirs
 * is nonzero if nonexistent directories should be sent.  Also sends
d4530 1
a4530 1
send_files (argc, argv, local, aflag, build_dirs)
a4534 1
    int build_dirs;
d4545 1
a4545 1
	 send_dirent_proc, (DIRLEAVEPROC)NULL, (void *) &build_dirs,
d4548 1
a4548 1
	error_exit ();
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@a1423 18
	    /* This error might be confusing; it isn't really clear to
	       the user what to do about it.  Keep in mind that it has
	       several causes: (1) something/someone creates the file
	       during the time that CVS is running, (2) the repository
	       has two files whose names clash for the client because
	       of case-insensitivity or similar causes, (3) a special
	       case of this is that a file gets renamed for example
	       from a.c to A.C.  A "cvs update" on a case-insensitive
	       client will get this error.  Repeating the update takes
	       care of the problem, but is it clear to the user what
	       is going on and what to do about it?, (4) the client
	       has a file which the server doesn't know about (e.g. "?
	       foo" file), and that name clashes with a file the
	       server does know about, (5) classify.c will print the same
	       message for other reasons.

	       I hope the above paragraph makes it clear that making this
	       clearer is not a one-line fix.  */
d2163 1
a2163 3
    if ((dir[0] == '.' && dir[1] == '\0')
	|| (prune_candidates != NULL
	    && strcmp (dir, prune_candidates->dir) == 0))
d2557 1
a2557 1
	    send_files (1, argv, local, 0, build_dirs, 0);
a3670 20
	/* People sometimes suggest or assume that this should default
	   to "remsh" on systems like HPUX in which that is the
	   system-supplied name for the rsh program.  However, that
	   causes various problems (keep in mind that systems such as
	   HPUX might have non-system-supplied versions of "rsh", like
	   a Kerberized one, which one might want to use).  If we
	   based the name on what is found in the PATH of the person
	   who runs configure, that would make it harder to
	   consistently produce the same result in the face of
	   different people producing binary distributions.  If we
	   based it on "remsh" always being the default for HPUX
	   (e.g. based on uname), that might be slightly better but
	   would require us to keep track of what the defaults are for
	   each system type, and probably would cope poorly if the
	   existence of remsh or rsh varies from OS version to OS
	   version.  Therefore, it seems best to have the default
	   remain "rsh", and tell HPUX users to specify remsh, for
	   example in CVS_RSH or other such mechanisms to be devised,
	   if that is what they want (the manual already tells them
	   that).  */
d3675 5
a4050 10
/* The address of an instance of this structure is passed to
   send_fileproc, send_filesdoneproc, and send_direntproc, as the
   callerdat parameter.  */

struct send_data
{
    int build_dirs;
    int force;
};

a4058 1
    struct send_data *args = (struct send_data *) callerdat;
a4119 1
	     || args->force
d4206 1
a4206 1
    struct send_data *args = (struct send_data *) callerdat;
d4259 1
a4259 1
	if (dir_exists || args->build_dirs)
d4445 3
a4447 4
 * is nonzero if nonexistent directories should be sent.  force is
 * nonzero if we should send unmodified files to the server as though
 * they were modified.  Also sends Argument lines for argc and argv,
 * so should be called after options are sent.
d4450 1
a4450 1
send_files (argc, argv, local, aflag, build_dirs, force)
a4455 1
    int force;
a4456 1
    struct send_data args;
a4463 2
    args.build_dirs = build_dirs;
    args.force = force;
d4466 1
a4466 1
	 send_dirent_proc, (DIRLEAVEPROC)NULL, (void *) &args,
d4502 7
a4508 2
    char *update_dir;
    char *fullname;
d4510 2
a4511 1
    assert (toplevel_repos != NULL);
d4517 1
d4519 1
a4519 1
    if (strcmp (repository, toplevel_repos) == 0)
d4521 1
a4521 2
	update_dir = "";
	fullname = xstrdup (vfile);
d4523 1
a4523 13
    else
    {
	update_dir = repository + strlen (toplevel_repos) + 1;

	fullname = xmalloc (strlen (vfile) + strlen (update_dir) + 10);
	strcpy (fullname, update_dir);
	strcat (fullname, "/");
	strcat (fullname, vfile);
    }

    send_a_repository ("", repository, update_dir);
    send_modified (vfile, fullname, NULL);
    free (fullname);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d2282 1
a2282 22
    {
	/* Send the directory name.  I know that this
	   sort of duplicates code elsewhere, but each
	   case seems slightly different...  */
	char buf[1];
	char *p = update_dir;
	while (*p != '\0')
	{
	    assert (*p != '\012');
	    if (ISDIRSEP (*p))
	    {
		buf[0] = '/';
		send_to_server (buf, 1);
	    }
	    else
	    {
		buf[0] = *p;
		send_to_server (buf, 1);
	    }
	    ++p;
	}
    }
d4426 1
a4426 5
	/* The isdir check could more gracefully be replaced
	   with a way of having Entries_Open report back the
	   error to us and letting us ignore existence_error.
	   Or some such.  */
	if (p == last_component (p) && isdir (CVSADM))
@


1.1.1.9
log
@Latest release from Cyclic Software
@
text
@d17 1
a17 1
#if defined(AUTH_CLIENT_SUPPORT) || HAVE_KERBEROS || USE_DIRECT_TCP || defined(SOCK_ERRNO) || defined(SOCK_STRERROR)
d25 1
a25 25
#endif /* defined(AUTH_CLIENT_SUPPORT) || HAVE_KERBEROS || USE_DIRECT_TCP
	  || defined(SOCK_ERRNO) || defined(SOCK_STRERROR) */

/* If SOCK_ERRNO is defined, then send()/recv() and other socket calls
   do not set errno, but that this macro should be used to obtain an
   error code.  This probably doesn't make sense unless
   NO_SOCKET_TO_FD is also defined. */
#ifndef SOCK_ERRNO
#define SOCK_ERRNO errno
#endif

/* If SOCK_STRERROR is defined, then the error codes returned by
   socket operations are not known to strerror, and this macro must be
   used instead to convert those error codes to strings. */
#ifndef SOCK_STRERROR
#  define SOCK_STRERROR strerror

#  if STDC_HEADERS
#    include <string.h>
#  endif

#  ifndef strerror
extern char *strerror ();
#  endif
#endif /* ! SOCK_STRERROR */
d429 1
a429 5
   socket and nothing else.
   
   We may also need to deal with socket routine error codes differently
   in these cases.  This is handled through the SOCK_ERRNO and
   SOCK_STRERROR macros. */
a437 6
/* Note that it is important that these routines always handle errors
   internally and never return a positive errno code, since it would in
   general be impossible for the caller to know in general whether any
   error code came from a socket routine (to decide whether to use
   SOCK_STRERROR or simply strerror to print an error message). */

d499 1
a499 1
	    error (1, 0, "reading from server: %s", SOCK_STRERROR (SOCK_ERRNO));
d539 1
a539 1
	error (1, 0, "writing to server socket: %s", SOCK_STRERROR (SOCK_ERRNO));
d547 1
a547 1
	    error (1, 0, "writing to server socket: %s", SOCK_STRERROR (SOCK_ERRNO));
d771 2
a772 7
    /* This is what we get when we hook up the directory (working directory
       name) from PATHNAME with the filename from REPOSNAME.  For example:
       pathname: ccvs/src/
       reposname: /u/src/master/ccvs/foo/ChangeLog
       short_pathname: ccvs/src/ChangeLog
       */
    char *short_pathname;
d823 1
a823 1
    dir_name = xstrdup (pathname);
d895 1
a895 1
			  (char *) NULL, 0);
a909 6

	    /* Provided we are willing to assume that directories get
	       created one at a time, we could simplify this a lot.
	       Do note that one aspect still would need to walk the
	       dir_name path: the checking for "fncmp (dir, CVSADM)".  */

d944 2
a945 4
			/* This just means that the repository string has
			   fewer components than the dir_name string.  But
			   that is OK (e.g. see modules3-8 in testsuite).  */
			;
a1009 7
			/* See comment near start of function; the only
			   way that the server can put the right thing
			   in each CVS/Repository file is to create the
			   directories one at a time.  I think that the
			   CVS server has been doing this all along.  */
			error (0, 0, "\
warning: server is not creating directories one at a time");
d1017 1
a1017 1
				  (char *)NULL, (char *)NULL, 0);
d1591 1
a1591 1
	        error (1, errno, "can't stat patch file %s", temp_filename);
d2598 1
a2598 1
	    send_files (1, argv, local, 0, build_dirs ? SEND_BUILD_DIRS : 0);
d2872 1
a2872 1
	    error (1, 0, "shutting down server socket: %s", SOCK_STRERROR (SOCK_ERRNO));
d2881 2
a2882 2
		error (1, 0, "shutting down connection to %s: %s",
		       CVSroot_hostname, SOCK_STRERROR (SOCK_ERRNO));
d3032 2
a3033 2
	error (1, 0, "connect to %s:%d failed: %s", CVSroot_hostname,
	       port_number, SOCK_STRERROR (SOCK_ERRNO));
d3099 1
a3099 2
                error (1, 0, "recv() from server %s: %s", CVSroot_hostname,
		       SOCK_STRERROR (SOCK_ERRNO));
d3112 2
a3113 3
		error (1, 0,
		       "shutdown() failed (server %s): %s", CVSroot_hostname,
		       SOCK_STRERROR (SOCK_ERRNO));
d3131 1
a3131 3
		error (1, 0,
		       "shutdown() failed, server %s: %s", CVSroot_hostname,
		       SOCK_STRERROR (SOCK_ERRNO));
d3142 1
a3142 2
	    error (0, 0, "shutdown() failed, server %s: %s", CVSroot_hostname,
		   SOCK_STRERROR (SOCK_ERRNO));
d3173 3
a3175 3
 * to file descriptors) or with SOCK_ERRNO/SOCK_STRERROR.  The first
 * person to try building a kerberos client on such a system (OS/2,
 * Windows 95, and maybe others) will have to make take care of this.
d4101 1
a4101 1
	    send_to_server (buf, newsize);
a4112 1
    /* Each of the following flags are zero for clear or nonzero for set.  */
a4114 1
    int no_contents;
d4146 1
a4146 1
	char *tmp;
d4148 11
a4158 11
	tmp = xmalloc (strlen (filename) + strlen (vers->vn_user)
		       + strlen (vers->options) + 200);
	sprintf (tmp, "Entry /%s/%s/%s%s/%s/", 
		 filename, vers->vn_user,
		 vers->ts_conflict == NULL ? "" : "+",
		 (vers->ts_conflict == NULL ? ""
		  : (vers->ts_user != NULL &&
		     strcmp (vers->ts_conflict, vers->ts_user) == 0
		     ? "="
		     : "modified")),
		 vers->options);
d4190 1
a4190 9
	if (args->no_contents
	    && supported_request ("Is-modified"))
	{
	    send_to_server ("Is-modified ", 0);
	    send_to_server (filename, 0);
	    send_to_server ("\012", 1);
	}
	else
	    send_modified (filename, finfo->fullname, vers);
d4513 9
a4521 9
/* Send Repository, Modified and Entry.  argc and argv contain only
  the files to operate on (or empty for everything), not options.
  local is nonzero if we should not recurse (-l option).  flags &
  SEND_BUILD_DIRS is nonzero if nonexistent directories should be
  sent.  flags & SEND_FORCE is nonzero if we should send unmodified
  files to the server as though they were modified.  flags &
  SEND_NO_CONTENTS means that this command only needs to know
  _whether_ a file is modified, not the contents.  Also sends Argument
  lines for argc and argv, so should be called after options are sent.  */
d4523 1
a4523 1
send_files (argc, argv, local, aflag, flags)
d4528 2
a4529 1
    unsigned int flags;
d4539 2
a4540 3
    args.build_dirs = flags & SEND_BUILD_DIRS;
    args.force = flags & SEND_FORCE;
    args.no_contents = flags & SEND_NO_CONTENTS;
@


1.1.1.10
log
@Latest version from Cyclic Software
@
text
@d1 1
a1 11
/* CVS client-related stuff.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */
d17 1
a17 1
#if defined(AUTH_CLIENT_SUPPORT) || HAVE_KERBEROS || defined(SOCK_ERRNO) || defined(SOCK_STRERROR)
d25 2
a26 1
#endif
d51 1
a51 1
#if HAVE_KERBEROS
d68 1
a68 1
#endif /* HAVE_KERBEROS */
a99 1
static void handle_rcs_diff PROTO((char *, int));
a1305 5

/* Nonzero if time was specified in Mod-time.  */
static int stored_modtime_valid;
/* Time specified in Mod-time.  */
static time_t stored_modtime;
a1306 16
static void handle_mod_time PROTO ((char *, int));

static void
handle_mod_time (args, len)
    char *args;
    int len;
{
    if (stored_modtime_valid)
	error (0, 0, "protocol error: duplicate Mod-time");
    stored_modtime = get_date (args, NULL);
    if (stored_modtime == (time_t) -1)
	error (0, 0, "protocol error: cannot parse date %s", args);
    else
	stored_modtime_valid = 1;
}

d1330 1
a1330 6
      UPDATE_ENTRIES_PATCH,
      /*
       * We are getting an RCS change text (diff -n output) against
       * the existing local file, not an entire new file.
       */
      UPDATE_ENTRIES_RCS_DIFF
d1366 2
a1367 2
    char *tag = NULL;
    char *date = NULL;
d1369 1
a1369 1
    char *scratch_entries = NULL;
d1406 2
d1424 1
a1424 2
	|| data->contents == UPDATE_ENTRIES_PATCH
	|| data->contents == UPDATE_ENTRIES_RCS_DIFF)
d1429 1
d1432 2
a1433 2
	int use_gzip;
	int patch_failed;
a1529 1

d1544 5
a1548 1
	if (data->contents == UPDATE_ENTRIES_RCS_DIFF)
d1550 9
a1558 2
	    /* This is an RCS change text.  We just hold the change
	       text in memory.  */
d1560 2
a1561 3
	    if (use_gzip)
		error (1, 0,
		       "server error: gzip invalid with RCS change text");
d1563 2
a1565 10
	}
	else
	{
	    int fd;
	    pid_t gzip_pid = 0;

	    fd = CVS_OPEN (temp_filename,
			   (O_WRONLY | O_CREAT | O_TRUNC
			    | (bin ? OPEN_BINARY : 0)),
			   0777);
d1567 1
a1567 25
	    if (fd < 0)
	    {
		/* I can see a case for making this a fatal error; for
		   a condition like disk full or network unreachable
		   (for a file server), carrying on and giving an
		   error on each file seems unnecessary.  But if it is
		   a permission problem, or some such, then it is
		   entirely possible that future files will not have
		   the same problem.  */
		error (0, errno, "cannot write %s", short_pathname);
		goto discard_file_and_return;
	    }

	    if (use_gzip)
		fd = filter_through_gunzip (fd, 0, &gzip_pid);

	    if (size > 0)
	    {
		read_from_server (buf, size);

		if (write (fd, buf, size) != size)
		    error (1, errno, "writing %s", short_pathname);
	    }

	    if (close (fd) < 0)
d1569 1
a1569 3
	    if (gzip_pid > 0)
	    {
		int gzip_status;
d1571 10
a1580 6
		if (waitpid (gzip_pid, &gzip_status, 0) == -1)
		    error (1, errno, "waiting for gzip process %ld",
			   (long) gzip_pid);
		else if (gzip_status != 0)
		    error (1, 0, "gzip process exited %d", gzip_status);
	    }
d1582 1
a1582 2
	    gzip_pid = -1;
	}
a1589 2
	patch_failed = 0;

d1631 1
a1631 1
	else if (data->contents == UPDATE_ENTRIES_PATCH)
d1677 9
d1690 4
a1693 1
		patch_failed = 1;
a1696 109
	else
	{
	    struct stat s;
	    char *filebuf, *tobuf;
	    size_t filebufsize;
	    FILE *e;
	    size_t nread;
	    char *patchedbuf;
	    size_t patchedlen;

	    /* Handle UPDATE_ENTRIES_RCS_DIFF.  */

	    if (!isfile (filename))
	        error (1, 0, "patch original file %s does not exist",
		       short_pathname);
	    if (CVS_STAT (filename, &s) < 0)
	        error (1, errno, "can't stat %s", short_pathname);

	    filebufsize = s.st_size;
	    filebuf = xmalloc (filebufsize);

	    e = open_file (filename, bin ? FOPEN_BINARY_READ : "r");

	    tobuf = filebuf;
	    nread = 0;
	    while (1)
	    {
		size_t got;

		got = fread (tobuf, 1, filebufsize - (tobuf - filebuf), e);
		if (ferror (e))
		    error (1, errno, "can't read %s", short_pathname);
		nread += got;
		tobuf += got;

		if (feof (e))
		  break;

		/* It's probably paranoid to think S.ST_SIZE might be
                   too small to hold the entire file contents, but we
                   handle it just in case.  */
		if (tobuf == filebuf + filebufsize)
		{
		    int c;
		    long off;

		    c = getc (e);
		    if (c == EOF)
			break;
		    off = tobuf - filebuf;
		    expand_string (&filebuf, &filebufsize, filebufsize + 100);
		    tobuf = filebuf + off;
		    *tobuf++ = c;
		    ++nread;
		}
	    }

	    fclose (e);

	    /* At this point the contents of the existing file are in
               FILEBUF, and the length of the contents is in NREAD.
               The contents of the patch from the network are in BUF,
               and the length of the patch is in SIZE.  */

	    if (! rcs_change_text (short_pathname, filebuf, nread, buf, size,
				   &patchedbuf, &patchedlen))
		patch_failed = 1;
	    else
	    {
		if (stored_checksum_valid)
		{
		    struct MD5Context context;
		    unsigned char checksum[16];

		    /* We have a checksum.  Check it before writing
		       the file out, so that we don't have to read it
		       back in again.  */
		    MD5Init (&context);
		    MD5Update (&context, (unsigned char *) patchedbuf, patchedlen);
		    MD5Final (checksum, &context);
		    if (memcmp (checksum, stored_checksum, 16) != 0)
		    {
			error (0, 0,
			       "checksum failure after patch to %s; will refetch",
			       short_pathname);

			patch_failed = 1;
		    }

		    stored_checksum_valid = 0;
		}

		if (! patch_failed)
		{
		    e = open_file (temp_filename,
				   bin ? FOPEN_BINARY_WRITE : "w");
		    if (fwrite (patchedbuf, 1, patchedlen, e) != patchedlen)
			error (1, errno, "cannot write %s", temp_filename);
		    if (fclose (e) == EOF)
			error (1, errno, "cannot close %s", temp_filename);
		    rename_file (temp_filename, filename);
		}

		free (patchedbuf);
	    }

	    free (filebuf);
	}

d1699 1
a1699 1
	if (stored_checksum_valid && ! patch_failed)
d1742 10
a1751 1
		patch_failed = 1;
a1754 17
	if (patch_failed)
	{
	    /* Save this file to retrieve later.  */
	    failed_patches = (char **) xrealloc ((char *) failed_patches,
						 ((failed_patches_count + 1)
						  * sizeof (char *)));
	    failed_patches[failed_patches_count] = xstrdup (short_pathname);
	    ++failed_patches_count;

	    stored_checksum_valid = 0;

	    free (mode_string);
	    free (buf);

	    return;
	}

a1769 13
    if (stored_modtime_valid)
    {
	struct utimbuf t;

	memset (&t, 0, sizeof (t));
	/* There is probably little point in trying to preserved the
	   actime (or is there? What about Checked-in?).  */
	t.modtime = t.actime = stored_modtime;
	if (utime (filename, &t) < 0)
	    error (0, errno, "cannot set time on %s", filename);
	stored_modtime_valid = 0;
    }

a1899 13

static void
handle_rcs_diff (args, len)
     char *args;
     int len;
{
    struct update_entries_data dat;
    dat.contents = UPDATE_ENTRIES_RCS_DIFF;
    /* Think this could be UPDATE_ENTRIES_EXISTING, but just in case...  */
    dat.existp = UPDATE_ENTRIES_EXISTING_OR_NEW;
    dat.timestamp = NULL;
    call_in_directory (args, update_entries, (char *)&dat);
}
a2724 1
    RSP_LINE("Rcs-diff", handle_rcs_diff, response_type_normal, rs_optional),
a2725 1
    RSP_LINE("Mod-time", handle_mod_time, response_type_normal, rs_optional),
d2931 1
a2931 1
#if defined(HAVE_KERBEROS) || defined(AUTH_CLIENT_SUPPORT)
d2949 1
a2949 1
#endif
d3227 1
a3227 1
#if HAVE_KERBEROS
d3256 8
d3382 1
a3382 1
#endif /* HAVE_KERBEROS */
d3422 1
a3422 1
#if HAVE_KERBEROS
a3428 4
#if defined (NO_EXT_METHOD)
	    error (0, 0, ":ext: method not supported by this port of CVS");
	    error (1, 0, "try :server: instead");
#else
a3429 1
#endif
a3737 2
#ifndef NO_EXT_METHOD

a3898 1
    free (command);
a3902 2
#endif /* NO_EXT_METHOD */

a3932 4
/* VERS->OPTIONS specifies whether the file is binary or not.  NOTE: BEFORE
   using any other fields of the struct vers, we would need to fix
   client_process_import_file to set them up.  */

d4007 1
a4008 1
	    /* "Can't happen".  */
d4447 2
d4461 19
a4479 3
	level = pathname_levels (argv[i]);
	if (level > max_level)
	    max_level = level;
d4640 1
a4640 2
client_process_import_file (message, vfile, vtag, targc, targv, repository,
                            all_files_binary)
a4646 1
    int all_files_binary;
a4649 1
    Vers_TS vers;
d4674 1
a4674 12
    if (all_files_binary)
    {
	vers.options = xmalloc (4); /* strlen("-kb") + 1 */
	strcpy (vers.options, "-kb");
    }
    else
    {
	vers.options = wrap_rcsoption (vfile, 1);
    }
    send_modified (vfile, fullname, &vers);
    if (vers.options != NULL)
	free (vers.options);
a4734 1
	    free (line);
a4776 1
    free (line);
a4794 1
    free (line);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a77 12

#ifdef HAVE_GSSAPI

#include <gssapi/gssapi.h>
#include <gssapi/gssapi_generic.h>

/* This is needed for GSSAPI encryption.  */
static gss_ctx_id_t gcontext;

static int connect_to_gserver PROTO((int, struct hostent *));

#endif /* HAVE_GSSAPI */
a118 1
static void handle_wrapper_rcs_option PROTO((char *, int));
a452 1
    int retval;
d454 1
a454 4
    retval = buf_shutdown (lb->buf);
    if (fclose (lb->log) < 0)
	error (0, errno, "closing log file");
    return retval;
a540 11

	/* Note that for certain (broken?) networking stacks, like
	   VMS's UCX (not sure what version, problem reported with
	   recv() in 1997), and (according to windows-NT/config.h)
	   Windows NT 3.51, we must call recv or send with a
	   moderately sized buffer (say, less than 200K or something),
	   or else there may be network errors (somewhat hard to
	   produce, e.g. WAN not LAN or some such).  buf_read_data
	   makes sure that we only recv() BUFFER_DATA_SIZE bytes at
	   a time.  */

a577 3
    /* See comment in socket_buffer_input regarding buffer size we pass
       to send and recv.  */

d944 1
a944 1
			  (char *) NULL, 0, 1);
d1081 1
a1081 1
				  (char *)NULL, (char *)NULL, 0, 0);
a1253 19
/* OK, we want to swallow the "U foo.c" response and then output it only
   if we can update the file.  In the future we probably want some more
   systematic approach to parsing tagged text, but for now we keep it
   ad hoc.  "Why," I hear you cry, "do we not just look at the
   Update-existing and Created responses?"  That is an excellent question,
   and the answer is roughly conservatism/laziness--I haven't read through
   update.c enough to figure out the exact correspondence or lack thereof
   between those responses and a "U foo.c" line (note that Merged, from
   join_file, can be either "C foo" or "U foo" depending on the context).  */
/* Nonzero if we have seen +updated and not -updated.  */
static int updated_seen;
/* Filename from an "fname" tagged response within +updated/-updated.  */
static char *updated_fname;


/* Nonzero if we should arrange to return with a failure exit status.  */
static int failure_exit;


d1401 1
a1401 1
    char *options = NULL;
a1407 4
#ifdef UTIME_EXPECTS_WRITABLE
    int change_it_back = 0;
#endif

d1413 3
a1415 1
    scratch_entries = xstrdup (entries_line);
d1417 39
a1455 31
    if (scratch_entries[0] != '/')
        error (1, 0, "bad entries line `%s' from server", entries_line);
    user = scratch_entries + 1;
    if ((cp = strchr (user, '/')) == NULL)
        error (1, 0, "bad entries line `%s' from server", entries_line);
    *cp++ = '\0';
    vn = cp;
    if ((cp = strchr (vn, '/')) == NULL)
        error (1, 0, "bad entries line `%s' from server", entries_line);
    *cp++ = '\0';
    
    ts = cp;
    if ((cp = strchr (ts, '/')) == NULL)
        error (1, 0, "bad entries line `%s' from server", entries_line);
    *cp++ = '\0';
    options = cp;
    if ((cp = strchr (options, '/')) == NULL)
        error (1, 0, "bad entries line `%s' from server", entries_line);
    *cp++ = '\0';
    tag_or_date = cp;
    
    /* If a slash ends the tag_or_date, ignore everything after it.  */
    cp = strchr (tag_or_date, '/');
    if (cp != NULL)
        *cp = '\0';
    if (*tag_or_date == 'T')
        tag = tag_or_date + 1;
    else if (*tag_or_date == 'D')
        date = tag_or_date + 1;

    /* Done parsing the entries line. */
a1530 7
	    if (updated_fname != NULL)
	    {
		cvs_output ("C ", 0);
		cvs_output (updated_fname, 0);
		cvs_output ("\n", 1);
	    }
	    failure_exit = 1;
a1548 15

	    /* The Mode, Mod-time, and Checksum responses should not carry
	       over to a subsequent Created (or whatever) response, even
	       in the error case.  */
	    stored_mode_valid = 0;
	    if (stored_mode != NULL)
		free (stored_mode);
	    stored_modtime_valid = 0;
	    stored_checksum_valid = 0;

	    if (updated_fname != NULL)
	    {
		free (updated_fname);
		updated_fname = NULL;
	    }
d1593 1
d1613 3
d1620 1
a1620 3
		if (use_gzip)
		    gunzip_and_write (fd, short_pathname, buf, size);
		else if (write (fd, buf, size) != size)
d1626 12
d1640 5
a1644 15
	/* This is after we have read the file from the net (a change
	   from previous versions, where the server would send us
	   "M U foo.c" before Update-existing or whatever), but before
	   we finish writing the file (arguably a bug).  The timing
	   affects a user who wants status info about how far we have
	   gotten, and also affects whether "U foo.c" appears in addition
	   to various error messages.  */
	if (updated_fname != NULL)
	{
	    cvs_output ("U ", 0);
	    cvs_output (updated_fname, 0);
	    cvs_output ("\n", 1);
	    free (updated_fname);
	    updated_fname = 0;
	}
d1650 36
d1687 1
a1690 6
#ifdef DONT_USE_PATCH
	    /* Hmm.  We support only Rcs-diff, and the server supports
	       only Patched (or else it would have sent Rcs-diff instead).
	       Fall back to transmitting entire files.  */
	    patch_failed = 1;
#else /* Use patch.  */
d1708 2
a1709 20
		/* This behavior (in which -b takes an argument) is
		   supported by GNU patch 2.1.  Apparently POSIX.2
		   specifies a -b option without an argument.  GNU
		   patch 2.1.5 implements this and therefore won't
		   work here.  GNU patch versions after 2.1.5 are said
		   to have a kludge which checks if the last 4 args
		   are `-b SUFFIX ORIGFILE PATCHFILE' and if so emit a
		   warning (I think -s suppresses it), and then behave
		   as CVS expects.

		   Of course this is yet one more reason why in the long
		   run we want Rcs-diff to replace Patched.  */

	        run_setup (PATCH_PROGRAM);
		run_arg ("-f");
		run_arg ("-s");
		run_arg ("-b");
		run_arg ("~");
		run_arg (filename);
		run_arg (temp_filename);
a1741 1
#endif /* Use patch.  */
d1745 2
a1746 1
	    char *filebuf;
d1748 1
d1758 9
a1766 2
	    filebuf = NULL;
	    filebufsize = 0;
d1768 33
a1801 2
	    get_file (filename, short_pathname, bin ? FOPEN_BINARY_READ : "r",
		      &filebuf, &filebufsize, &nread);
a1836 2
		    FILE *e;

a1940 9

#ifdef UTIME_EXPECTS_WRITABLE
	if (!iswritable (filename))
	{
	    xchmod (filename, 1);
	    change_it_back = 1;
	}
#endif  /* UTIME_EXPECTS_WRITABLE  */

a1942 9

#ifdef UTIME_EXPECTS_WRITABLE
	if (change_it_back == 1)
	{
	    xchmod (filename, 0);
	    change_it_back = 0;
	}
#endif  /*  UTIME_EXPECTS_WRITABLE  */

d2677 1
d2679 1
a2679 1
void
a2724 8
		/*
		 * Strip trailing slashes from the name of the update directory.
		 * Otherwise, running `cvs update dir/' provokes the failure
		 * `protocol error: illegal directory syntax in dir/' when
		 * running in client/server mode.
		 */
		strip_trailing_slashes (update_dir);

a2851 38
/* Receive a cvswrappers line from the server; it must be a line
   containing an RCS option (e.g., "*.exe   -k 'b'").

   Note that this doesn't try to handle -t/-f options (which are a
   whole separate issue which noone has thought much about, as far
   as I know).

   We need to know the keyword expansion mode so we know whether to
   read the file in text or binary mode.  */

static void
handle_wrapper_rcs_option (args, len)
    char *args;
    int len;
{
    char *p;

    /* Enforce the notes in cvsclient.texi about how the response is not
       as free-form as it looks.  */
    p = strchr (args, ' ');
    if (p == NULL)
	goto error;
    if (*++p != '-'
	|| *++p != 'k'
	|| *++p != ' '
	|| *++p != '\'')
	goto error;
    if (strchr (p, '\'') == NULL)
	goto error;

    /* Add server-side cvswrappers line to our wrapper list. */
    wrap_add (args, 0);
    return;
 error:
    error (0, errno, "protocol error: ignoring invalid wrappers %s", args);
}


d2860 1
a2860 3
       but not always (is that true?  I think the comment is probably
       based on being confused between default buffering between
       stdout and stderr.  But I'm not sure).  */
a2865 38
static void handle_mbinary PROTO ((char *, int));

static void
handle_mbinary (args, len)
    char *args;
    int len;
{
    char *size_string;
    size_t size;
    size_t totalread;
    size_t nread;
    size_t toread;
    char buf[8192];

    /* See comment at handle_m about (non)flush of stderr.  */

    /* Get the size.  */
    read_line (&size_string);
    size = atoi (size_string);
    free (size_string);

    /* OK, now get all the data.  The algorithm here is that we read
       as much as the network wants to give us in
       try_read_from_server, and then we output it all, and then
       repeat, until we get all the data.  */
    totalread = 0;
    while (totalread < size)
    {
	toread = size - totalread;
	if (toread > sizeof buf)
	    toread = sizeof buf;

	nread = try_read_from_server (buf, toread);
	cvs_output_binary (buf, nread);
	totalread += nread;
    }
}

a2886 61
static void handle_mt PROTO ((char *, int));

static void
handle_mt (args, len)
    char *args;
    int len;
{
    char *p;
    char *tag = args;
    char *text;

    /* See comment at handle_m for more details.  */
    fflush (stderr);

    p = strchr (args, ' ');
    if (p == NULL)
	text = NULL;
    else
    {
	*p++ = '\0';
	text = p;
    }

    switch (tag[0])
    {
	case '+':
	    if (strcmp (tag, "+updated") == 0)
		updated_seen = 1;
	    break;
	case '-':
	    if (strcmp (tag, "-updated") == 0)
		updated_seen = 0;
	    break;
	default:
	    if (updated_seen)
	    {
		if (strcmp (tag, "fname") == 0)
		{
		    if (updated_fname != NULL)
		    {
			/* Output the previous message now.  This can happen
			   if there was no Update-existing or other such
			   response, due to the -n global option.  */
			cvs_output ("U ", 0);
			cvs_output (updated_fname, 0);
			cvs_output ("\n", 1);
			free (updated_fname);
		    }
		    updated_fname = xstrdup (text);
		}
		/* Swallow all other tags.  Either they are extraneous
		   or they reflect future extensions that we can
		   safely ignore.  */
	    }
	    else if (strcmp (tag, "newline") == 0)
		printf ("\n");
	    else if (text != NULL)
		printf ("%s", text);
    }
}

a2938 3
    RSP_LINE("Wrapper-rcsOption", handle_wrapper_rcs_option,
       response_type_normal,
       rs_optional),
a2939 1
    RSP_LINE("Mbinary", handle_mbinary, response_type_normal, rs_optional),
a2941 1
    RSP_LINE("MT", handle_mt, response_type_normal, rs_optional),
a3061 10
	    /* We might want to handle control characters and the like
	       in some other way other than just sending them to stdout.
	       One common reason for this error is if people use :ext:
	       with a version of rsh which is doing CRLF translation or
	       something, and so the client gets "ok^M" instead of "ok".
	       Right now that will tend to print part of this error
	       message over the other part of it.  It seems like we could
	       do better (either in general, by quoting or omitting all
	       control characters, and/or specifically, by detecting the CRLF
	       case and printing a specific error message).  */
d3067 1
a3067 18

    if (updated_fname != NULL)
    {
	/* Output the previous message now.  This can happen
	   if there was no Update-existing or other such
	   response, due to the -n global option.  */
	cvs_output ("U ", 0);
	cvs_output (updated_fname, 0);
	cvs_output ("\n", 1);
	free (updated_fname);
	updated_fname = NULL;
    }

    if (rs->type == response_type_error)
	return 1;
    if (failure_exit)
	return 1;
    return 0;
a3186 1
#ifndef NO_EXT_METHOD
a3187 1
#endif
d3204 3
a3206 3
#if defined (AUTH_CLIENT_SUPPORT) || defined (HAVE_KERBEROS)
static struct hostent *init_sockaddr PROTO ((struct sockaddr_in *, char *,
					     unsigned int));
d3208 1
a3208 1
static struct hostent *
d3215 1
a3215 1
    unsigned short shortport = port;
a3226 1
    return hostinfo;
a3228 3
#endif /* defined (AUTH_CLIENT_SUPPORT) || defined (HAVE_KERBEROS) */

#ifdef AUTH_CLIENT_SUPPORT
d3244 13
a3256 74
/* Read a line from socket SOCK.  Result does not include the
   terminating linefeed.  This is only used by the authentication
   protocol, which we call before we set up all the buffering stuff.
   It is possible it should use the buffers too, which would be faster
   (unlike the server, there isn't really a security issue in terms of
   separating authentication from the rest of the code).

   Space for the result is malloc'd and should be freed by the caller.

   Returns number of bytes read.  */
static int
recv_line (sock, resultp)
    int sock;
    char **resultp;
{
    int c;
    char *result;
    size_t input_index = 0;
    size_t result_size = 80;

    result = (char *) xmalloc (result_size);

    while (1)
    {
	char ch;
	if (recv (sock, &ch, 1, 0) < 0)
	    error (1, 0, "recv() from server %s: %s", CVSroot_hostname,
		   SOCK_STRERROR (SOCK_ERRNO));
	c = ch;

	if (c == EOF)
	{
	    free (result);

	    /* It's end of file.  */
	    error (1, 0, "end of file from server");
	}

	if (c == '\012')
	    break;

	result[input_index++] = c;
	while (input_index + 1 >= result_size)
	{
	    result_size *= 2;
	    result = (char *) xrealloc (result, result_size);
	}
    }

    if (resultp)
	*resultp = result;

    /* Terminate it just for kicks, but we *can* deal with embedded NULs.  */
    result[input_index] = '\0';

    if (resultp == NULL)
	free (result);
    return input_index;
}

/* Connect to the authenticating server.

   If VERIFY_ONLY is non-zero, then just verify that the password is
   correct and then shutdown the connection.

   If VERIFY_ONLY is 0, then really connect to the server.

   If DO_GSSAPI is non-zero, then we use GSSAPI authentication rather
   than the pserver password authentication.

   If we fail to connect or if access is denied, then die with fatal
   error.  */
void
connect_to_pserver (tofdp, fromfdp, verify_only, do_gssapi)
a3258 1
     int do_gssapi;
a3265 1
    struct hostent *hostinfo;
d3270 2
a3271 1
	error (1, 0, "cannot create socket: %s", SOCK_STRERROR (SOCK_ERRNO));
d3274 1
a3274 1
    hostinfo = init_sockaddr (&client_sai, CVSroot_hostname, port_number);
a3280 10
    if (do_gssapi)
    {
#ifdef HAVE_GSSAPI
	if (! connect_to_gserver (sock, hostinfo))
	    goto rejected;
#else
	error (1, 0, "This client does not support GSSAPI authentication");
#endif
    }
    else
d3282 10
d3300 2
a3301 2
	    begin = "BEGIN VERIFICATION REQUEST\012";
	    end   = "END VERIFICATION REQUEST\012";
d3305 2
a3306 2
	    begin = "BEGIN AUTH REQUEST\012";
	    end   = "END AUTH REQUEST\012";
d3313 1
a3313 2
	if (send (sock, begin, strlen (begin), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
d3316 6
a3321 12
	if (send (sock, repository, strlen (repository), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, "\012", 1, 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, username, strlen (username), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, "\012", 1, 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, password, strlen (password), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	if (send (sock, "\012", 1, 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
d3324 1
a3324 2
	if (send (sock, end, strlen (end), 0) < 0)
	    error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
a3327 1
    }
d3329 20
a3348 2
    {
	char *read_buf;
d3350 1
a3350 2
	/* Loop, getting responses from the server.  */
	while (1)
d3352 2
a3353 3
	    recv_line (sock, &read_buf);

	    if (strcmp (read_buf, "I HATE YOU") == 0)
d3355 6
a3360 2
		/* Authorization not granted. */
		goto rejected;
a3361 3
	    else if (strncmp (read_buf, "E ", 2) == 0)
	    {
		fprintf (stderr, "%s\n", read_buf + 2);
d3363 2
a3364 24
		/* Continue with the authentication protocol.  */
	    }
	    else if (strncmp (read_buf, "error ", 6) == 0)
	    {
		char *p;

		/* First skip the code.  */
		p = read_buf + 6;
		while (*p != ' ' && *p != '\0')
		    ++p;

		/* Skip the space that follows the code.  */
		if (*p == ' ')
		    ++p;

		/* Now output the text.  */
		fprintf (stderr, "%s\n", p);
		goto rejected;
	    }
	    else if (strcmp (read_buf, "I LOVE YOU") == 0)
	    {
		free (read_buf);
		break;
	    }
d3366 8
d3375 1
a3375 12
		/* Unrecognized response from server. */
		if (shutdown (sock, 2) < 0)
		{
		    error (0, 0,
			   "unrecognized auth response from %s: %s", 
			   CVSroot_hostname, read_buf);
		    error (1, 0,
			   "shutdown() failed, server %s: %s",
			   CVSroot_hostname,
			   SOCK_STRERROR (SOCK_ERRNO));
		}
		error (1, 0, 
d3378 3
d3382 3
a3384 1
	    free (read_buf);
d3393 1
a3393 1
	return;
d3413 1
a3413 17
    return;

  rejected:
    if (shutdown (sock, 2) < 0)
    {
	error (0, 0, 
	       "authorization failed: server %s rejected access", 
	       CVSroot_hostname);
	error (1, 0,
	       "shutdown() failed (server %s): %s",
	       CVSroot_hostname,
	       SOCK_STRERROR (SOCK_ERRNO));
    }

    error (1, 0, 
	   "authorization failed: server %s rejected access", 
	   CVSroot_hostname);
d3420 7
a3426 5
/* This function has not been changed to deal with NO_SOCKET_TO_FD
   (i.e., systems on which sockets cannot be converted to file
   descriptors).  The first person to try building a kerberos client
   on such a system (OS/2, Windows 95, and maybe others) will have to
   make take care of this.  */
d3431 4
a3434 1
    int s;
a3436 1
    struct hostent *hp;
d3438 8
a3445 1
    char *hname;
d3447 17
a3463 3
    s = socket (AF_INET, SOCK_STREAM, 0);
    if (s < 0)
	error (1, 0, "cannot create socket: %s", SOCK_STRERROR (SOCK_ERRNO));
d3479 1
d3487 1
a3487 1
	    port = CVS_PORT;
d3489 1
a3489 1
	    port = ntohs (sp->s_port);
d3492 14
a3505 1
    hp = init_sockaddr (&sin, CVSroot_hostname, port);
a3506 3
    hname = xmalloc (strlen (hp->h_name) + 1);
    strcpy (hname, hp->h_name);
  
d3508 6
a3513 3
	error (1, 0, "connect to %s:%d failed: %s", CVSroot_hostname,
	       port, SOCK_STRERROR (SOCK_ERRNO));

a3514 2
    {
	const char *realm;
a3516 1
	KTEXT_ST ticket;
a3518 3
	int status;

	realm = krb_realmofhost (hname);
d3522 1
a3522 1
	    error (1, 0, "getsockname failed: %s", SOCK_STRERROR (SOCK_ERRNO));
d3529 8
a3536 4
	    error (1, 0, "kerberos authentication failed: %s",
		   krb_get_err_text (status));
	memcpy (kblock, cred.session, sizeof (C_Block));
    }
d3539 3
a3541 9
    server_fd = s;
    close_on_exec (server_fd);

    free (hname);

    /* Give caller the values it wants. */
    *tofdp   = s;
    *fromfdp = s;
}
d3543 2
d3546 3
a3548 12

#ifdef HAVE_GSSAPI

/* Receive a given number of bytes.  */

static void
recv_bytes (sock, buf, need)
     int sock;
     char *buf;
     int need;
{
    while (need > 0)
d3550 6
a3555 8
	int got;

	got = recv (sock, buf, need, 0);
	if (got < 0)
	    error (1, 0, "recv() from server %s: %s", CVSroot_hostname,
		   SOCK_STRERROR (SOCK_ERRNO));
	buf += got;
	need -= got;
a3556 1
}
d3558 1
a3558 1
/* Connect to the server using GSSAPI authentication.  */
d3560 3
a3562 73
static int
connect_to_gserver (sock, hostinfo)
     int sock;
     struct hostent *hostinfo;
{
    char *str;
    char buf[1024];
    gss_buffer_desc *tok_in_ptr, tok_in, tok_out;
    OM_uint32 stat_min, stat_maj;
    gss_name_t server_name;

    str = "BEGIN GSSAPI REQUEST\012";

    if (send (sock, str, strlen (str), 0) < 0)
	error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));

    sprintf (buf, "cvs@@%s", hostinfo->h_name);
    tok_in.length = strlen (buf);
    tok_in.value = buf;
    gss_import_name (&stat_min, &tok_in, gss_nt_service_name, &server_name);

    tok_in_ptr = GSS_C_NO_BUFFER;
    gcontext = GSS_C_NO_CONTEXT;

    do
    {
	stat_maj = gss_init_sec_context (&stat_min, GSS_C_NO_CREDENTIAL,
					 &gcontext, server_name,
					 GSS_C_NULL_OID,
					 (GSS_C_MUTUAL_FLAG
					  | GSS_C_REPLAY_FLAG),
					 0, NULL, tok_in_ptr, NULL, &tok_out,
					 NULL, NULL);
	if (stat_maj != GSS_S_COMPLETE && stat_maj != GSS_S_CONTINUE_NEEDED)
	{
	    OM_uint32 message_context;

	    message_context = 0;
	    gss_display_status (&stat_min, stat_maj, GSS_C_GSS_CODE,
				GSS_C_NULL_OID, &message_context, &tok_out);
	    error (1, 0, "GSSAPI authentication failed: %s",
		   (char *) tok_out.value);
	}

	if (tok_out.length == 0)
	{
	    tok_in.length = 0;
	}
	else
	{
	    char cbuf[2];
	    int need;

	    cbuf[0] = (tok_out.length >> 8) & 0xff;
	    cbuf[1] = tok_out.length & 0xff;
	    if (send (sock, cbuf, 2, 0) < 0)
		error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));
	    if (send (sock, tok_out.value, tok_out.length, 0) < 0)
		error (1, 0, "cannot send: %s", SOCK_STRERROR (SOCK_ERRNO));

	    recv_bytes (sock, cbuf, 2);
	    need = ((cbuf[0] & 0xff) << 8) | (cbuf[1] & 0xff);
	    assert (need <= sizeof buf);
	    recv_bytes (sock, buf, need);
	    tok_in.length = need;
	}

	tok_in.value = buf;
	tok_in_ptr = &tok_in;
    }
    while (stat_maj == GSS_S_CONTINUE_NEEDED);

    return 1;
d3565 1
a3565 1
#endif /* HAVE_GSSAPI */
d3601 1
a3601 1
	    connect_to_pserver (&tofd, &fromfd, 0, 0);
a3610 7
#if HAVE_GSSAPI
	case gserver_method:
	    /* GSSAPI authentication is handled by the pserver.  */
	    connect_to_pserver (&tofd, &fromfd, 0, 1);
	    break;
#endif

a3704 3
	/* Note that if we create several connections in a single CVS client
	   (currently used by update.c), then the last set of logfiles will
	   overwrite the others.  There is currently no way around this.  */
a3841 22

    /* Find out about server-side cvswrappers.  An extra network
       turnaround for cvs import seems to be unavoidable, unless we
       want to add some kind of client-side place to configure which
       filenames imply binary.  For cvs add, we could avoid the
       problem by keeping a copy of the wrappers in CVSADM (the main
       reason to bother would be so we could make add work without
       contacting the server, I suspect).  */

    if ((strcmp (command_name, "import") == 0)
        || (strcmp (command_name, "add") == 0))
    {
	if (supported_request ("wrapper-sendme-rcsOptions"))
	{
	    int err;
	    send_to_server ("wrapper-sendme-rcsOptions\012", 0);
	    err = get_server_responses ();
	    if (err != 0)
		error (err, 0, "error reading from server");
	}
    }

d3865 1
a3865 17
#ifdef HAVE_GSSAPI
	if (CVSroot_method == gserver_method)
	{
	    if (! supported_request ("Gssapi-encrypt"))
		error (1, 0, "This server does not support encryption");
	    send_to_server ("Gssapi-encrypt\012", 0);
	    to_server = cvs_gssapi_wrap_buffer_initialize (to_server, 0,
							   gcontext,
							   buf_memory_error);
	    from_server = cvs_gssapi_wrap_buffer_initialize (from_server, 1,
							     gcontext,
							     buf_memory_error);
	    cvs_gssapi_encrypt = 1;
	}
	else
#endif /* HAVE_GSSAPI */
	    error (1, 0, "Encryption is only supported when using GSSAPI or Kerberos");
a3869 1

a3911 28
    if (cvsauthenticate && ! cvsencrypt)
    {
	/* Turn on authentication after turning on compression, so
	   that we can compress the authentication information.  We
	   assume that encrypted data is always authenticated--the
	   ability to decrypt the data stream is itself a form of
	   authentication.  */
#ifdef HAVE_GSSAPI
	if (CVSroot_method == gserver_method)
	{
	    if (! supported_request ("Gssapi-authenticate"))
		error (1, 0,
		       "This server does not support stream authentication");
	    send_to_server ("Gssapi-authenticate\012", 0);
	    to_server = cvs_gssapi_wrap_buffer_initialize (to_server, 0,
							   gcontext,
							   buf_memory_error);
	    from_server = cvs_gssapi_wrap_buffer_initialize (from_server, 1,
							     gcontext,
							     buf_memory_error);
	}
	else
	    error (1, 0, "Stream authentication is only supported when using GSSAPI");
#else /* ! HAVE_GSSAPI */
	error (1, 0, "This client does not support stream authentication");
#endif /* ! HAVE_GSSAPI */
    }

d4141 1
a4141 1
    size_t bufsize;
d4194 52
a4245 1
	size_t newsize = 0;
d4247 1
a4247 3
	read_and_gzip (fd, short_pathname, (unsigned char **)&buf,
		       &bufsize, &newsize,
		       file_gzip_level);
d4249 26
d4278 16
d4404 14
d4419 3
a4421 19
	send_to_server ("Entry /", 0);
	send_to_server (filename, 0);
	send_to_server ("/", 0);
	send_to_server (vers->vn_user, 0);
	send_to_server ("/", 0);
	if (vers->ts_conflict != NULL)
	{
	    if (vers->ts_user != NULL &&
		strcmp (vers->ts_conflict, vers->ts_user) == 0)
		send_to_server ("+=", 0);
	    else
		send_to_server ("+modified", 0);
	}
	send_to_server ("/", 0);
	send_to_server (vers->entdata != NULL
			? vers->entdata->options
			: vers->options,
			0);
	send_to_server ("/", 0);
a4433 35
    else
    {
	/* It seems a little silly to re-read this on each file, but
	   send_dirent_proc doesn't get called if filenames are specified
	   explicitly on the command line.  */
	wrap_add_file (CVSDOTWRAPPER, 1);

	if (wrap_name_has (filename, WRAP_RCSOPTION))
	{
	    /* No "Entry", but the wrappers did give us a kopt so we better
	       send it with "Kopt".  As far as I know this only happens
	       for "cvs add".  Question: is there any reason why checking
	       for options from wrappers isn't done in Version_TS?

	       Note: it might have been better to just remember all the
	       kopts on the client side, rather than send them to the server,
	       and have it send us back the same kopts.  But that seemed like
	       a bigger change than I had in mind making now.  */

	    if (supported_request ("Kopt"))
	    {
		char *opt;

		send_to_server ("Kopt ", 0);
		opt = wrap_rcsoption (filename, 1);
		send_to_server (opt, 0);
		send_to_server ("\012", 1);
		free (opt);
	    }
	    else
		error (0, 0,
		       "\
warning: ignoring -k options due to server limitations");
	}
    }
d4543 1
d4574 3
a4576 1
    if (dir_exists)
a4588 10
	/* It doesn't make sense to send a non-existent directory,
	   because there is no way to get the correct value for
	   the repository (I suppose maybe via the expand-modules
	   request).  In the case where the "obvious" choice for
	   repository is correct, the server can figure out whether
	   to recreate the directory; in the case where it is wrong
	   (that is, does not match what modules give us), we might as
	   well just fail to recreate it.

	   Checking for noexec is a kludge for "cvs -n add dir".  */
d4593 1
a4593 1
	if (args->build_dirs && noexec)
d4596 1
a4864 12
    if (vers.options != NULL)
    {
	if (supported_request ("Kopt"))
	{
	    send_to_server ("Kopt ", 0);
	    send_to_server (vers.options, 0);
	    send_to_server ("\012", 1);
	}
	else
	    error (0, 0,
		   "warning: ignoring -k options due to server limitations");
    }
d4908 1
a4908 4
	if (feof (fp))
	    error (0, 0, "cannot read %s: end of file", CVSADM_NOTIFY);
	else
	    error (0, errno, "cannot read %s", CVSADM_NOTIFY);
d5062 5
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d137 1
a184 1
 * If RESPECT_UMASK is set, then honor the umask.
d187 1
a187 1
change_mode (filename, mode_string, respect_umask)
a189 1
    int respect_umask;
a219 4
    /* xchmod honors the umask for us.  In the !respect_umask case, we
       don't try to cope with it (probably to handle that well, the server
       needs to deal with modes in data structures, rather than via the
       modes in temporary files).  */
a226 1
    mode_t oumask;
a279 7
    if (respect_umask)
    {
	oumask = umask (0);
	(void) umask (oumask);
	mode &= ~oumask;
    }

d308 10
d1141 1
a1141 1
	    last_entries = Entries_Open (0, dir_name);
d1931 2
a1932 1
	    int status = change_mode (filename, mode_string, 1);
d1942 1
a1942 1
	change_mode (filename, stored_mode, 1);
d4015 1
a4015 1
					      (BUFMEMERRPROC) NULL);
d4017 1
a4017 1
						(BUFMEMERRPROC) NULL);
d4041 1
a4041 1
					     (BUFMEMERRPROC) NULL);
d4047 1
a4047 1
					       (BUFMEMERRPROC) NULL);
d4074 1
a4074 1
					       (BUFMEMERRPROC) NULL);
d4082 1
a4082 1
						 (BUFMEMERRPROC) NULL);
d4243 1
a4243 1
						       (BUFMEMERRPROC) NULL);
d4246 1
a4246 1
							 (BUFMEMERRPROC) NULL);
d4258 1
a4258 2
							   ((BUFMEMERRPROC)
							    NULL));
d4261 1
a4261 2
							     ((BUFMEMERRPROC)
							      NULL));
d4286 1
a4286 1
						    (BUFMEMERRPROC) NULL);
d4289 1
a4289 1
						      (BUFMEMERRPROC) NULL);
d4330 1
a4330 2
							   ((BUFMEMERRPROC)
							    NULL));
d4333 1
a4333 2
							     ((BUFMEMERRPROC)
							      NULL));
d5096 1
a5096 1
	    entries = Entries_Open (0, NULL);
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@d5445 7
a5451 10
/* Send a date to the server.  The input DATE is in RCS format.
   The time will be GMT.

   We then convert that to the format required in the protocol
   (including the "-D" option) and send it.  According to
   cvsclient.texi, RFC 822/1123 format is preferred, but for now we
   use the format that we always have, for
   conservatism/laziness/paranoia.  As far as I know all servers
   support the RFC 822/1123 format, so probably there would be no
   particular danger in switching.  */
d5460 1
a5460 1
    if (sscanf (date, SDATEFORM, &year, &month, &day, &hour, &minute, &second)
d5463 1
a5463 1
        error (1, 0, "client_senddate: sscanf failed on date");
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@a80 4
#ifdef HAVE_GSSAPI_H
#include <gssapi.h>
#endif
#ifdef HAVE_GSSAPI_GSSAPI_H
a81 2
#endif
#ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H
a82 5
#endif

#ifndef HAVE_GSS_C_NT_HOSTBASED_SERVICE
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#endif
d952 4
a955 11
	/* Create the CVS directory at the top level if needed.  The
	   isdir seems like an unneeded system call, but it *does*
	   need to be called both if the CVS_CHDIR below succeeds
	   (e.g.  "cvs co .") or if it fails (e.g. basicb-1a in
	   testsuite).  We only need to do this for the "." case,
	   since the server takes care of forcing this directory to be
	   created in all other cases.  If we don't create CVSADM
	   here, the call to Entries_Open below will fail.  FIXME:
	   perhaps this means that we should change our algorithm
	   below that calls Create_Admin instead of having this code
	   here? */
d962 1
a962 1
	    && (strcmp (dir_name, ".") == 0)
d2912 1
a2912 1
	goto handle_error;
d2917 1
a2917 1
	goto handle_error;
d2919 1
a2919 1
	goto handle_error;
d2924 1
a2924 1
 handle_error:
d3864 1
a3864 2
    gss_import_name (&stat_min, &tok_in, GSS_C_NT_HOSTBASED_SERVICE,
		     &server_name);
@


1.1.1.15
log
@Latest version from Cyclic
@
text
@a150 133
#ifdef CLIENT_SUPPORT

/* We need to keep track of the list of directories we've sent to the
   server.  This list, along with the current CVSROOT, will help us
   decide which command-line arguments to send.  */
List *dirs_sent_to_server = NULL;

static int is_arg_a_parent_or_listed_dir PROTO((Node *, void *));

static int
is_arg_a_parent_or_listed_dir (n, d)
    Node *n;
    void *d;
{
    char *directory = n->key;	/* name of the dir sent to server */
    char *this_argv_elem = (char *) d;	/* this argv element */

    /* Say we should send this argument if the argument matches the
       beginning of a directory name sent to the server.  This way,
       the server will know to start at the top of that directory
       hierarchy and descend. */

    if (strncmp (directory, this_argv_elem, strlen (this_argv_elem)) == 0)
	return 1;

    return 0;
}

static int arg_should_not_be_sent_to_server PROTO((char *));

/* Return nonzero if this argument should not be sent to the
   server. */

static int
arg_should_not_be_sent_to_server (arg)
    char *arg;
{
    /* Decide if we should send this directory name to the server.  We
       should always send argv[i] if:

       1) the list of directories sent to the server is empty (as it
       will be for checkout, etc.).

       2) the argument is "."

       3) the argument is a file in the cwd and the cwd is checked out
       from the current root

       4) the argument lies within one of the paths in
       dirs_sent_to_server.

       4) */

    if (list_isempty (dirs_sent_to_server))
	return 0;		/* always send it */

    if (strcmp (arg, ".") == 0)
	return 0;		/* always send it */

    /* We should send arg if it is one of the directories sent to the
       server or the parent of one; this tells the server to descend
       the hierarchy starting at this level. */
    if (isdir (arg))
    {
	if (walklist (dirs_sent_to_server, is_arg_a_parent_or_listed_dir, arg))
	    return 0;

	/* If arg wasn't a parent, we don't know anything about it (we
	   would have seen something related to it during the
	   send_files phase).  Don't send it.  */
	return 1;
    }

    /* Try to decide whether we should send arg to the server by
       checking the contents of the corresponding CVSADM directory. */
    {
	char *t, *this_root;

	/* Calculate "dirname arg" */
	for (t = arg + strlen (arg) - 1; t >= arg; t--)
	{
	    if (ISDIRSEP(*t))
		break;
	}

	/* Now we're either poiting to the beginning of the
	   string, or we found a path separator. */
	if (t >= arg)
	{
	    /* Found a path separator.  */
	    char c = *t;
	    *t = '\0';
	    
	    /* First, check to see if we sent this directory to the
               server, because it takes less time than actually
               opening the stuff in the CVSADM directory.  */
	    if (walklist (dirs_sent_to_server, is_arg_a_parent_or_listed_dir,
			  arg))
	    {
		*t = c;		/* make sure to un-truncate the arg */
		return 0;
	    }

	    /* Since we didn't find it in the list, check the CVSADM
               files on disk.  */
	    this_root = Name_Root (arg, (char *) NULL);
	    *t = c;
	}
	else
	{
	    /* We're at the beginning of the string.  Look at the
               CVSADM files in cwd.  */
	    this_root = Name_Root ((char *) NULL, (char *) NULL);
	}

	/* Now check the value for root. */
	if (this_root && current_root
	    && (strcmp (this_root, current_root) != 0))
	{
	    /* Don't send this, since the CVSROOTs don't match. */
	    free (this_root);
	    return 1;
	}
	free (this_root);
    }
    
    /* OK, let's send it. */
    return 0;
}


#endif /* CLIENT_SUPPORT */

d713 19
d740 1
a740 1
static char *toplevel_repos = NULL;
a772 7

    /* Next we print the text of the message from the server.  We
       probably should be prefixing it with "server error" or some
       such, because if it is something like "Out of memory", the
       current behavior doesn't say which machine is out of
       memory.  */

d810 1
a810 1
	    if (rq->flags & RQ_ENABLEME)
d820 1
a820 1
		rq->flags |= RQ_SUPPORTED;
d826 1
a826 4
	if ((rq->flags & RQ_SUPPORTED)
	    || (rq->flags & RQ_ENABLEME))
	    continue;
	if (rq->flags & RQ_ESSENTIAL)
d828 2
a1212 5
    /* cvsclient.texi has said for a long time that newname must be in the
       same directory.  Wouldn't want a malicious or buggy server overwriting
       ~/.profile, /etc/passwd, or anything like that.  */
    if (last_component (newname) != newname)
	error (1, 0, "protocol error: Copy-file tried to specify directory");
a1213 2
    if (unlink_file (newname) && !existence_error (errno))
	error (0, errno, "unable to remove %s", newname);
a1319 17
/* This struct is used to hold data when reading the +importmergecmd
   and -importmergecmd tags.  We put the variables in a struct only
   for namespace issues.  FIXME: As noted above, we need to develop a
   more systematic approach.  */
static struct
{
    /* Nonzero if we have seen +importmergecmd and not -importmergecmd.  */
    int seen;
    /* Number of conflicts, from a "conflicts" tagged response.  */
    int conflicts;
    /* First merge tag, from a "mergetag1" tagged response.  */
    char *mergetag1;
    /* Second merge tag, from a "mergetag2" tagged response.  */
    char *mergetag2;
    /* Repository, from a "repository" tagged response.  */
    char *repository;
} importmergecmd;
d1370 1
a1370 1
/* Mode that we got in a "Mode" response (malloc'd), or NULL if none.  */
d1380 2
d1383 1
a1383 1
	error (1, 0, "protocol error: duplicate Mode");
d1385 1
d1625 1
a1626 1
	    {
a1627 2
		stored_mode = NULL;
	    }
d1704 1
a1704 4
		{
		    if (gunzip_and_write (fd, short_pathname, buf, size))
			error (1, 0, "aborting due to compression error");
		}
d1750 1
a1750 5
	    if (unlink_file (backup) < 0
		&& !existence_error (errno))
	    {
		error (0, errno, "cannot remove %s", backup);
	    }
d1782 2
a1783 2
	    if (unlink_file (temp_filename) < 0)
		error (0, errno, "cannot remove %s", temp_filename);
d1786 2
a1787 2
		if (unlink_file (backup) < 0)
		    error (0, errno, "cannot remove %s", backup);
d1801 2
a1802 3
		if (unlink_file (path_tmp) < 0
		    && !existence_error (errno))
		    error (0, errno, "cannot remove %s", path_tmp);
d1845 1
a1845 1
		    struct cvs_MD5Context context;
d1851 3
a1853 4
		    cvs_MD5Init (&context);
		    cvs_MD5Update (&context,
				   (unsigned char *) patchedbuf, patchedlen);
		    cvs_MD5Final (checksum, &context);
d1890 1
a1890 1
	    struct cvs_MD5Context context;
d1909 1
a1909 1
	    cvs_MD5Init (&context);
d1911 1
a1911 1
		cvs_MD5Update (&context, buf, len);
d1914 1
a1914 1
	    cvs_MD5Final (checksum, &context);
d1961 1
a1961 2
    if (stored_mode != NULL)
    {
d1963 2
a1964 4
	free (stored_mode);
	stored_mode = NULL;
    }
   
d2266 1
a2266 14

    /* FIXME-update-dir: error messages should include the directory.  */
    f = CVS_FOPEN (CVSADM_TAG, "w+");
    if (f == NULL)
    {
	/* Making this non-fatal is a bit of a kludge (see dirs2
	   in testsuite).  A better solution would be to avoid having
	   the server tell us about a directory we shouldn't be doing
	   anything with anyway (e.g. by handling directory
	   addition/removal better).  */
	error (0, errno, "cannot open %s", CVSADM_TAG);
	free (tagspec);
	return;
    }
a2570 16
    /* Add a directory name to the list of those sent to the
       server. */
    if (update_dir && (*update_dir != '\0')
	&& (strcmp (update_dir, ".") != 0)
	&& (findnode (dirs_sent_to_server, update_dir) == NULL))
    {
	Node *n;
	n = getnode ();
	n->type = UNKNOWN;
	n->key = xstrdup (update_dir);
	n->data = NULL;

	if (addnode (dirs_sent_to_server, n))
	    error (1, 0, "cannot add directory %s to list", n->key);
    }

a2764 9
		 *
		 * 21 Aug 1998: Well, Mr. Above-Comment-Writer, it
		 * does need to work after all.  When we are using the
		 * client in a multi-cvsroot environment, it will be
		 * fairly common that we have the above case (e.g.,
		 * cwd checked out from one repository but
		 * subdirectory checked out from another).  We can't
		 * assume that by walking up a directory in our wd we
		 * necessarily walk up a directory in the repository.
d2770 3
d2774 6
a2779 2
		int repository_len, update_dir_len;

d2782 8
a2789 15
		repository_len = strlen (repository);
		update_dir_len = strlen (update_dir);

		/* Try to remove the path components in UPDATE_DIR
                   from REPOSITORY.  If the path elements don't exist
                   in REPOSITORY, or the removal of those path
                   elements mean that we "step above"
                   CVSroot_directory, set toplevel_repos to
                   CVSroot_directory. */
		if ((repository_len > update_dir_len)
		    && (strcmp (repository + repository_len - update_dir_len,
				update_dir) == 0)
		    /* TOPLEVEL_REPOS shouldn't be above CVSroot_directory */
		    && ((repository_len - update_dir_len)
			> strlen (CVSroot_directory)))
d2791 10
a2800 13
		    /* The repository name contains UPDATE_DIR.  Set
                       toplevel_repos to the repository name without
                       UPDATE_DIR. */

		    toplevel_repos = xmalloc (repository_len - update_dir_len);
		    /* Note that we don't copy the trailing '/'.  */
		    strncpy (toplevel_repos, repository,
			     repository_len - update_dir_len - 1);
		    toplevel_repos[repository_len - update_dir_len - 1] = '\0';
		}
		else
		{
		    toplevel_repos = xstrdup (CVSroot_directory);
d2802 4
a3049 2
	    else if (strcmp (tag, "+importmergecmd") == 0)
		importmergecmd.seen = 1;
a3053 49
	    else if (strcmp (tag, "-importmergecmd") == 0)
	    {
		char buf[80];

		/* Now that we have gathered the information, we can
                   output the suggested merge command.  */

		if (importmergecmd.conflicts == 0
		    || importmergecmd.mergetag1 == NULL
		    || importmergecmd.mergetag2 == NULL
		    || importmergecmd.repository == NULL)
		{
		    error (0, 0,
			   "invalid server: incomplete importmergecmd tags");
		    break;
		}

		sprintf (buf, "\n%d conflicts created by this import.\n",
			 importmergecmd.conflicts);
		cvs_output (buf, 0);
		cvs_output ("Use the following command to help the merge:\n\n",
			    0);
		cvs_output ("\t", 1);
		cvs_output (program_name, 0);
		if (CVSroot_cmdline != NULL)
		{
		    cvs_output (" -d ", 0);
		    cvs_output (CVSroot_cmdline, 0);
		}
		cvs_output (" checkout -j", 0);
		cvs_output (importmergecmd.mergetag1, 0);
		cvs_output (" -j", 0);
		cvs_output (importmergecmd.mergetag2, 0);
		cvs_output (" ", 1);
		cvs_output (importmergecmd.repository, 0);
		cvs_output ("\n\n", 0);

		/* Clear the static variables so that everything is
                   ready for any subsequent importmergecmd tag.  */
		importmergecmd.conflicts = 0;
		free (importmergecmd.mergetag1);
		importmergecmd.mergetag1 = NULL;
		free (importmergecmd.mergetag2);
		importmergecmd.mergetag2 = NULL;
		free (importmergecmd.repository);
		importmergecmd.repository = NULL;

		importmergecmd.seen = 0;
	    }
a3075 15
	    else if (importmergecmd.seen)
	    {
		if (strcmp (tag, "conflicts") == 0)
		    importmergecmd.conflicts = atoi (text);
		else if (strcmp (tag, "mergetag1") == 0)
		    importmergecmd.mergetag1 = xstrdup (text);
		else if (strcmp (tag, "mergetag2") == 0)
		    importmergecmd.mergetag2 = xstrdup (text);
		else if (strcmp (tag, "repository") == 0)
		    importmergecmd.repository = xstrdup (text);
		/* Swallow all other tags.  Either they are text for
                   which we are going to print our own version when we
                   see -importmergecmd, or they are future extensions
                   we can safely ignore.  */
	    }
d3427 1
a3427 1
	    return (rq->flags & RQ_SUPPORTED) != 0;
d3493 1
d3503 1
a3503 3
	int n;
	n = recv (sock, &ch, 1, 0);
	if (n <= 0)
d3505 10
a3514 1
		   n == 0 ? "EOF" : SOCK_STRERROR (SOCK_ERRNO));
d3516 1
a3516 1
	if (ch == '\012')
d3519 1
a3519 1
	result[input_index++] = ch;
a3537 22
/* Connect to a forked server process. */

void
connect_to_forked_server (tofdp, fromfdp)
     int *tofdp, *fromfdp;
{
    /* This is pretty simple.  All we need to do is choose the correct
       cvs binary and call piped_child. */

    char *command[3];

    command[0] = getenv ("CVS_SERVER");
    if (! command[0])
	command[0] = "cvs";
    
    command[1] = "server";
    command[2] = NULL;

    if (! piped_child (command, tofdp, fromfdp))
	error (1, 0, "could not fork server process");
}

a3962 7

    /* Clear our static variables for this invocation. */
    if (toplevel_repos != NULL)
	free (toplevel_repos);
    toplevel_repos = NULL;


a4022 4
        case fork_method:
	    connect_to_forked_server (&tofd, &fromfd);
	    break;

d4122 1
a4122 5
    if (stored_mode != NULL)
    {
	free (stored_mode);
	stored_mode = NULL;
    }
d4651 3
a4653 4
	if (read_and_gzip (fd, short_pathname, (unsigned char **)&buf,
			   &bufsize, &newsize,
			   file_gzip_level))
	    error (1, 0, "aborting due to compression error");
d5053 1
a5053 1
    
a5093 3
	if (arg_should_not_be_sent_to_server (argv[i]))
	    continue;

d5227 1
a5227 1
                            all_files_binary, modtime)
a5234 3

    /* Nonzero for "import -d".  */
    int modtime;
a5283 22
    if (modtime)
    {
	if (supported_request ("Checkin-time"))
	{
	    struct stat sb;
	    char *rcsdate;
	    char netdate[MAXDATELEN];

	    if (CVS_STAT (vfile, &sb) < 0)
		error (1, errno, "cannot stat %s", fullname);
	    rcsdate = date_from_time_t (sb.st_mtime);
	    date_to_internet (netdate, rcsdate);
	    free (rcsdate);

	    send_to_server ("Checkin-time ", 0);
	    send_to_server (netdate, 0);
	    send_to_server ("\012", 1);
	}
	else
	    error (0, 0,
		   "warning: ignoring -d option due to server limitations");
    }
d5469 5
a5473 1
   cvsclient.texi, RFC 822/1123 format is preferred.  */
d5479 8
a5486 1
    char buf[MAXDATELEN];
d5488 2
a5489 1
    date_to_internet (buf, (char *)date);
@


1.1.1.16
log
@Latest version from Cyclic
@
text
@d1693 2
a1694 2
	   a race condition: if the existence or lack thereof of the
	   file changes between now and the actual calls which
d1885 3
a1887 6
	    /* You might think we could just leave Patched out of
	       Valid-responses and not get this response.  However, if
	       memory serves, the CVS 1.9 server bases this on -u
	       (update-patches), and there is no way for us to send -u
	       or not based on whether the server supports "Rcs-diff".  

d1890 76
d2180 1
a2180 11

	    /* Checking for command_name of "commit" doesn't seem like
	       the cleanest way to handle this, but it seem to roughly
	       parallel what the :local: code which calls
	       mark_up_to_date ends up amounting to.  Some day, should
	       think more about what the Checked-in response means
	       vis-a-vis both Entries and Base and clarify
	       cvsclient.texi accordingly.  */

	    if (!strcmp (command_name, "commit"))
		mark_up_to_date (filename);
d3667 2
a3668 4
	for (;;)
	{
	    (void) time (&now);
	    if (now != last_register_time) break;
a3669 1
	}
@


1.1.1.16.6.1
log
@Pull in patch from current:
Fix (tholo):
- Document the fact that the wrong thing is likely to happen in many cases
here, if something is checked out from a (read-only?) replica of a repos,
and then checked in to the master, files will be skipped.
- Disable bogus check for whether a file in the current directory (only!)
were checked out of a different CVSROOT -- makes it very hard to have
replicated repositories.
@
text
@a265 7
	/*
	 * This is so bogus!  Means if you have checked out from
	 * a replica of a repository, and then when you want to
	 * check it in to the real (read/write) repository, the
	 * file will be skipped!
	 */
#if 0
a273 1
#endif
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@a0 2
/* JT thinks BeOS is worth the trouble. */

d63 1
d77 2
d1118 1
a1118 1
			  (char *) NULL, 0, 1, 1);
d1255 1
a1255 1
				  (char *)NULL, (char *)NULL, 0, 0, 1);
a1762 1
	    free (scratch_entries);
d1850 1
a1850 2
		    if (gunzip_and_write (fd, short_pathname, 
					  (unsigned char *) buf, size))
a2027 2
	    free (scratch_entries);
	    free (entries_line);
d2126 1
a2127 1
    free (scratch_entries);
a2492 1

a2493 3
    if (strcmp (command_name, "export") == 0)
	return;

a2507 1

a2508 3
    if (strcmp (command_name, "export") == 0)
	return;

d2686 1
a2686 1
	n->type = NT_UNKNOWN;
a3596 2
    buf_free (to_server);
    buf_free (from_server);
d3599 1
a3599 1
    /* see if we need to sleep before returning to avoid time-stamp races */
d3602 8
a3609 2
	while (time ((time_t *) NULL) == last_register_time)
	    sleep (1);
a3776 1
    char no_passwd = 0;   /* gets set if no password found */
a3820 8
        
        /* Send the empty string by default.  This is so anonymous CVS
           access doesn't require client to have done "cvs login". */
        if (password == NULL) 
        {
            no_passwd = 1;
            password = scramble ("");
        }
d3844 2
a3845 2
        /* Paranoia. */
        memset (password, 0, strlen (password));
a3937 13
    error (0, 0,
	"authorization failed: server %s rejected access to %s for user %s",
	CVSroot_hostname, CVSroot_directory, CVSroot_username);

    /* Output a special error message if authentication was attempted
       with no password -- the user should be made aware that they may
       have missed a step. */
    if (no_passwd)
    {
        error (0, 0,
               "used empty password; try \"cvs login\" with a real password");
    }

d3940 4
a3943 1
	error (0, 0,
d3949 3
a3951 1
    error_exit();
a4113 7
	    OM_uint32 new_stat_min;

	    message_context = 0;
	    gss_display_status (&new_stat_min, stat_maj, GSS_C_GSS_CODE,
                                GSS_C_NULL_OID, &message_context, &tok_out);
	    error (0, 0, "GSSAPI authentication failed: %s",
		   (char *) tok_out.value);
d4116 1
a4116 1
	    gss_display_status (&new_stat_min, stat_min, GSS_C_MECH_CODE,
d4140 1
a4140 23

	    if (need > sizeof buf)
	    {
		int got;

		/* This usually means that the server sent us an error
		   message.  Read it byte by byte and print it out.
		   FIXME: This is a terrible error handling strategy.
		   However, even if we fix the server, we will still
		   want to do this to work with older servers.  */
		buf[0] = cbuf[0];
		buf[1] = cbuf[1];
		got = recv (sock, buf + 2, sizeof buf - 2, 0);
		if (got < 0)
		    error (1, 0, "recv() from server %s: %s",
			   CVSroot_hostname, SOCK_STRERROR (SOCK_ERRNO));
		buf[got + 2] = '\0';
		if (buf[got + 1] == '\n')
		    buf[got + 1] = '\0';
		error (1, 0, "error from server %s: %s", CVSroot_hostname,
		       buf);
	    }

d4174 1
a4174 1
    int tofd, fromfd, rootless;
d4353 1
a4353 2
    rootless = (strcmp (command_name, "init") == 0);
    if (!rootless)
d4477 1
a4477 1
    if (cvsencrypt && !rootless)
d4524 1
a4524 1
    if (gzip_level && !rootless)
d4566 1
a4566 1
    if (cvsauthenticate && ! cvsencrypt && !rootless)
d4597 1
a4597 1
    if (supported_request ("Case") && !rootless)
a4966 1
    int backup_modified;
a5087 12

        if (args->backup_modified)
        {
            char *bakname;
            bakname = backup_file (filename, vers->vn_user);
            /* This behavior is sufficiently unexpected to
               justify overinformativeness, I think. */
            if (! really_quiet)
                printf ("(Locally modified %s moved to %s)\n",
                        filename, bakname);
            free (bakname);
        }
d5196 3
a5213 3

	/* initialize the ignore list for this directory */
	ignlist = getlist ();
a5237 23
static int send_dirleave_proc PROTO ((void *, char *, int, char *, List *));

/*
 * send_dirleave_proc () is called back by the recursion code upon leaving
 * a directory.  All it does is delete the ignore list if it hasn't already
 * been done (by send_filesdone_proc).
 */
/* ARGSUSED */
static int
send_dirleave_proc (callerdat, dir, err, update_dir, entries)
    void *callerdat;
    char *dir;
    int err;
    char *update_dir;
    List *entries;
{

    /* Delete the ignore list if it hasn't already been done.  */
    if (ignlist)
	dellist (&ignlist);
    return err;
}

a5428 1
    args.backup_modified = flags & BACKUP_MODIFIED_FILES;
d5431 1
a5431 1
	 send_dirent_proc, send_dirleave_proc, (void *) &args,
@


1.1.1.18
log
@Latest from Cyclic Software
@
text
@a34 1
#    include <arpa/inet.h>
d80 13
a92 1
# include "xgssapi.h"
d100 1
a100 1

d201 1
a201 1
       */
d266 2
a267 2
	if (this_root && current_parsed_root
	    && (strcmp (this_root, current_parsed_root->original) != 0))
a1279 26
	else if (!isdir (CVSADM))
	{
	    /*
	     * Put repository in CVS/Repository.  For historical
	     * (pre-CVS/Root) reasons, this is an absolute pathname,
	     * but what really matters is the part of it which is
	     * relative to cvsroot.
	     */
	    char *repo;

	    if (reposdirname_absolute)
		repo = reposdirname;
	    else
	    {
		repo = xmalloc (strlen (reposdirname)
				+ strlen (toplevel_repos)
				+ 10);
		strcpy (repo, toplevel_repos);
		strcat (repo, "/");
		strcat (repo, reposdirname);
	    }

	    Create_Admin (".", ".", repo, (char *)NULL, (char *)NULL, 0, 1, 1);
	    if (repo != reposdirname)
		free (repo);
	}
d2285 1
a2285 1
    if (strcmp (toplevel_repos, current_parsed_root->directory) != 0)
d2925 2
a2926 2
                   current_parsed_root->directory, set toplevel_repos to
                   current_parsed_root->directory. */
d2930 1
a2930 1
		    /* TOPLEVEL_REPOS shouldn't be above current_parsed_root->directory */
d2932 1
a2932 1
			> strlen (current_parsed_root->directory)))
d2946 1
a2946 1
		    toplevel_repos = xstrdup (current_parsed_root->directory);
d3004 1
a3004 1
    send_a_repository ("", current_parsed_root->directory, "");
d3042 1
a3042 1
    send_a_repository ("", current_parsed_root->directory, "");
d3048 1
a3048 1
    send_a_repository ("", current_parsed_root->directory, "");
d3563 1
a3563 2
		       current_parsed_root->hostname, SOCK_STRERROR (SOCK_ERRNO));
	    server_fd = -1;
d3572 1
a3572 1
			   current_parsed_root->hostname);
d3590 1
a3590 1
			   current_parsed_root->hostname);
d3596 1
a3596 1
	    error (0, 0, "dying gasps from %s unexpected", current_parsed_root->hostname);
d3598 1
a3598 1
	    error (0, errno, "reading from %s", current_parsed_root->hostname);
d3615 2
a3616 1
	sleep_past (last_register_time);
d3640 1
a3640 2


d3669 1
d3671 1
a3672 9
#ifdef AUTH_CLIENT_SUPPORT

/* Generic function to do port number lookup tasks.
 *
 * In order of precedence, will return:
 * 	getenv (envname), if defined
 * 	getservbyname (portname), if defined
 * 	defaultport
 */
d3674 1
a3674 4
get_port_number (envname, portname, defaultport)
    const char *envname;
    const char *portname;
    int defaultport;
d3676 1
a3676 2
    struct servent *s;
    char *port_s;
d3678 1
a3678 13
    if (envname && (port_s = getenv (envname)))
    {
	int port = atoi (port_s);
	if (port <= 0)
	{
	    error (0, 0, "%s must be a positive integer!  If you", envname);
	    error (0, 0, "are trying to force a connection via rsh, please");
	    error (0, 0, "put \":server:\" at the beginning of your CVSROOT");
	    error (1, 0, "variable.");
	}
	return port;
    }
    else if (portname && (s = getservbyname (portname, "tcp")))
d3681 1
a3681 1
	return defaultport;
a3684 41

/* get the port number for a client to connect to based on the port
 * and method of a cvsroot_t.
 *
 * we do this here instead of in parse_cvsroot so that we can keep network
 * code confined to a localized area and also to delay the lookup until the
 * last possible moment so it remains possible to run cvs client commands that
 * skip opening connections to the server (i.e. skip network operations entirely)
 *
 * and yes, I know none of the the commands do that now, but here's to planning
 * for the future, eh?  cheers.
 *
 * FIXME - We could cache the port lookup safely right now as we never change
 * it for a single root on the fly, but we'd have to un'const some other
 * functions
 */
int
get_cvs_port_number (root)
    const cvsroot_t *root;
{

    if (root->port) return root->port;

    switch (root->method)
    {
	case gserver_method:
	case pserver_method:
	    return get_port_number ("CVS_CLIENT_PORT", "cvspserver", CVS_AUTH_PORT);
#ifdef HAVE_KERBEROS
	case kserver_method:
	    return get_port_number ("CVS_CLIENT_PORT", "cvs", CVS_PORT);
#endif
	default:
	    error(1, EINVAL, "internal error: get_cvs_port_number called for invalid connection method (%s)",
		    method_names[root->method]);
	    break;
    }
}



d3712 1
a3712 1
	    error (1, 0, "recv() from server %s: %s", current_parsed_root->hostname,
d3750 1
a3750 1
	command[0] = program_path;
a3754 4
    if (trace)
    {
	fprintf (stderr, " -> Forking server: %s %s\n", command[0], command[1]);
    }
a3781 1
    char *username;			/* the username we use to connect */
d3784 1
a3784 1
    char no_passwd = 0;			/* gets set if no password found */
d3791 2
a3792 8
    port_number = get_cvs_port_number (current_parsed_root);
    hostinfo = init_sockaddr (&client_sai, current_parsed_root->hostname, port_number);
    if (trace)
    {
	fprintf (stderr, " -> Connecting to %s(%s):%d\n",
		 current_parsed_root->hostname,
		 inet_ntoa (client_sai.sin_addr), port_number);
    }
d3795 1
a3795 3
	error (1, 0, "connect to %s(%s):%d failed: %s",
	       current_parsed_root->hostname,
	       inet_ntoa (client_sai.sin_addr),
a3802 4
	{
	    error (0, 0,
		    "authorization failed: server %s rejected access to %s",
		    current_parsed_root->hostname, current_parsed_root->directory);
a3803 1
	}
d3811 2
d3815 1
a3815 1
	
d3829 1
a3829 2
        username = current_parsed_root->username ? current_parsed_root->username : getcaller();

d3843 1
a3843 1
	if (send (sock, current_parsed_root->directory, strlen (current_parsed_root->directory), 0) < 0)
d3874 1
a3874 23
		/* Authorization not granted.
		 *
		 * This is a little confusing since we can reach this while loop in GSSAPI
		 * mode, but if GSSAPI authentication failed, we already jumped to the
		 * rejected label (there is no case where the connect_to_gserver function
		 * can return 1 and we will not receive "I LOVE YOU" from the server, barring
		 * broken connections and garbled messages, of course).
		 *
		 * i.e. This is a pserver specific error message and shoiuld be since
		 * GSSAPI doesn't use username.
		 */
		error (0, 0,
			"authorization failed: server %s rejected access to %s for user %s",
			current_parsed_root->hostname, current_parsed_root->directory, username);

		/* Output a special error message if authentication was attempted
		with no password -- the user should be made aware that they may
		have missed a step. */
		if (no_passwd)
		{
		    error (0, 0,
			    "used empty password; try \"cvs login\" with a real password");
		}
d3912 1
a3912 1
			   current_parsed_root->hostname, read_buf);
d3915 1
a3915 1
			   current_parsed_root->hostname,
d3920 1
a3920 1
		       current_parsed_root->hostname, read_buf);
d3929 1
a3929 1
	    error (0, 0, "shutdown() failed, server %s: %s", current_parsed_root->hostname,
d3954 13
d3971 1
a3971 1
	       current_parsed_root->hostname,
d3979 2
a3980 3


#ifdef HAVE_KERBEROS
d4002 25
a4026 1
    port = get_cvs_port_number (current_parsed_root);
d4028 1
a4028 1
    hp = init_sockaddr (&sin, current_parsed_root->hostname, port);
a4032 7
    if (trace)
    {
	fprintf (stderr, " -> Connecting to %s(%s):%d\n",
		 current_parsed_root->hostname,
		 inet_ntoa (client_sai.sin_addr), port);
    }

d4034 1
a4034 3
	error (1, 0, "connect to %s(%s):%d failed: %s",
	       current_parsed_root->hostname,
	       inet_ntoa (client_sai.sin_addr),
d4037 1
d4062 1
d4091 3
a4093 4
	if (got <= 0)
	    error (1, 0, "recv() from server %s: %s", current_parsed_root->hostname,
		   got == 0 ? "EOF" : SOCK_STRERROR (SOCK_ERRNO));

d4186 1
a4186 1
			   current_parsed_root->hostname, SOCK_STRERROR (SOCK_ERRNO));
d4190 1
a4190 1
		error (1, 0, "error from server %s: %s", current_parsed_root->hostname,
d4242 1
a4242 1
    switch (current_parsed_root->method)
d4259 1
a4259 1
#ifdef HAVE_GSSAPI
d4278 2
a4279 2
			  current_parsed_root->username, current_parsed_root->hostname,
			  current_parsed_root->directory);
d4410 1
a4410 1
	send_to_server (current_parsed_root->directory, 0);
d4540 1
a4540 1
	if (current_parsed_root->method == kserver_method)
d4555 1
a4555 1
	if (current_parsed_root->method == gserver_method)
d4628 1
a4628 1
	if (current_parsed_root->method == gserver_method)
d4732 1
a4732 1
    if (current_parsed_root->username != NULL)
d4735 1
a4735 1
	rsh_argv[i++] = current_parsed_root->username;
d4738 1
a4738 1
    rsh_argv[i++] = current_parsed_root->hostname;
a4747 2
	for (i = 0; rsh_argv[i]; i++)
	    fprintf (stderr, "%s ", rsh_argv[i]);
d4785 1
a4785 1
		       + strlen (current_parsed_root->directory)
d4799 1
a4799 1
	*p++ = current_parsed_root->hostname;
d4804 1
a4804 1
	if (current_parsed_root->username != NULL)
d4807 1
a4807 1
	    *p++ = current_parsed_root->username;
d5534 1
a5534 1
	toplevel_repos = xstrdup (current_parsed_root->directory);
d5653 1
a5653 1
	toplevel_repos = xstrdup (current_parsed_root->directory);
d5833 1
a5833 1
    /* This is here because we need the current_parsed_root->directory variable.  */
d5835 1
a5835 1
    send_to_server (current_parsed_root->directory, 0);
@


