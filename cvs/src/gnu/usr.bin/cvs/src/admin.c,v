head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.34
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.30
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.32
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.24
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.28
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.26
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.22
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.20
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.18
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.16
	OPENBSD_5_0:1.2.0.14
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.12
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.8
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.1.1.16.0.28
	OPENBSD_4_3_BASE:1.1.1.16
	OPENBSD_4_2:1.1.1.16.0.26
	OPENBSD_4_2_BASE:1.1.1.16
	OPENBSD_4_1:1.1.1.16.0.24
	OPENBSD_4_1_BASE:1.1.1.16
	OPENBSD_4_0:1.1.1.16.0.22
	OPENBSD_4_0_BASE:1.1.1.16
	OPENBSD_3_9:1.1.1.16.0.20
	OPENBSD_3_9_BASE:1.1.1.16
	OPENBSD_3_8:1.1.1.16.0.18
	OPENBSD_3_8_BASE:1.1.1.16
	OPENBSD_3_7:1.1.1.16.0.16
	OPENBSD_3_7_BASE:1.1.1.16
	OPENBSD_3_6:1.1.1.16.0.14
	OPENBSD_3_6_BASE:1.1.1.16
	OPENBSD_3_5:1.1.1.16.0.12
	OPENBSD_3_5_BASE:1.1.1.16
	OPENBSD_3_4:1.1.1.16.0.10
	OPENBSD_3_4_BASE:1.1.1.16
	OPENBSD_3_3:1.1.1.16.0.8
	OPENBSD_3_3_BASE:1.1.1.16
	OPENBSD_3_2:1.1.1.16.0.6
	OPENBSD_3_2_BASE:1.1.1.16
	OPENBSD_3_1:1.1.1.16.0.4
	OPENBSD_3_1_BASE:1.1.1.16
	OPENBSD_3_0:1.1.1.16.0.2
	OPENBSD_3_0_BASE:1.1.1.16
	cvs-1-11-1p1:1.1.1.16
	OPENBSD_2_9:1.1.1.15.0.2
	OPENBSD_2_9_BASE:1.1.1.15
	cvs-1-11:1.1.1.15
	OPENBSD_2_8:1.1.1.14.0.6
	OPENBSD_2_8_BASE:1.1.1.14
	OPENBSD_2_7:1.1.1.14.0.4
	OPENBSD_2_7_BASE:1.1.1.14
	OPENBSD_2_6:1.1.1.14.0.2
	OPENBSD_2_6_BASE:1.1.1.14
	cvs-1-10-7:1.1.1.14
	OPENBSD_2_5:1.1.1.13.0.2
	OPENBSD_2_5_BASE:1.1.1.13
	cvs-1-10-5:1.1.1.13
	OPENBSD_2_4:1.1.1.12.0.2
	OPENBSD_2_4_BASE:1.1.1.12
	cvs-1-10:1.1.1.12
	cvs-1-9-28:1.1.1.12
	OPENBSD_2_3:1.1.1.11.0.2
	OPENBSD_2_3_BASE:1.1.1.11
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2016.08.31.13.16.47;	author jcs;	state Exp;
branches;
next	1.2;
commitid	yGnF6xEzQYBGZGlU;

1.2
date	2008.05.11.12.16.00;	author tobias;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.56;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.37;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.16;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.21;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.18;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.55.54;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.26.52;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.33;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.00;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.25;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.07.13.03.53.38;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.02.28.21.32.36;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.09.10.05.06.20;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2001.02.10.18.57.37;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.3
log
@admin: add -C option to set a revision's commitid

this version bails out if the revision has a commitid already

ok guenther deraadt tom
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Administration ("cvs admin")
 * 
 */

#include "cvs.h"
#ifdef CVS_ADMIN_GROUP
#include <grp.h>
#endif
#include <assert.h>

static Dtype admin_dirproc PROTO ((void *callerdat, char *dir,
				   char *repos, char *update_dir,
				   List *entries));
static int admin_fileproc PROTO ((void *callerdat, struct file_info *finfo));

static const char *const admin_usage[] =
{
    "Usage: %s %s [options] files...\n",
    "\t-a users   Append (comma-separated) user names to access list.\n",
    "\t-A file    Append another file's access list.\n",
    "\t-b[rev]    Set default branch (highest branch on trunk if omitted).\n",
    "\t-c string  Set comment leader.\n",
    "\t-C rev:id  Set revision's commit id.\n",
    "\t-e[users]  Remove (comma-separated) user names from access list\n",
    "\t           (all names if omitted).\n",
    "\t-I         Run interactively.\n",
    "\t-k subst   Set keyword substitution mode:\n",
    "\t   kv   (Default) Substitue keyword and value.\n",
    "\t   kvl  Substitue keyword, value, and locker (if any).\n",
    "\t   k    Substitue keyword only.\n",
    "\t   o    Preserve original string.\n",
    "\t   b    Like o, but mark file as binary.\n",
    "\t   v    Substitue value only.\n",
    "\t-l[rev]    Lock revision (latest revision on branch,\n",
    "\t           latest revision on trunk if omitted).\n",
    "\t-L         Set strict locking.\n",
    "\t-m rev:msg  Replace revision's log message.\n",
    "\t-n tag[:[rev]]  Tag branch or revision.  If :rev is omitted,\n",
    "\t                delete the tag; if rev is omitted, tag the latest\n",
    "\t                revision on the default branch.\n",
    "\t-N tag[:[rev]]  Same as -n except override existing tag.\n",
    "\t-o range   Delete (outdate) specified range of revisions:\n",
    "\t   rev1:rev2   Between rev1 and rev2, including rev1 and rev2.\n",
    "\t   rev1::rev2  Between rev1 and rev2, excluding rev1 and rev2.\n",
    "\t   rev:        rev and following revisions on the same branch.\n",
    "\t   rev::       After rev on the same branch.\n",
    "\t   :rev        rev and previous revisions on the same branch.\n",
    "\t   ::rev       Before rev on the same branch.\n",
    "\t   rev         Just rev.\n",
    "\t-q         Run quietly.\n",
    "\t-s state[:rev]  Set revision state (latest revision on branch,\n",
    "\t                latest revision on trunk if omitted).\n",
    "\t-t[file]   Get descriptive text from file (stdin if omitted).\n",
    "\t-t-string  Set descriptive text.\n",
    "\t-u[rev]    Unlock the revision (latest revision on branch,\n",
    "\t           latest revision on trunk if omitted).\n",
    "\t-U         Unset strict locking.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

/* This structure is used to pass information through start_recursion.  */
struct admin_data
{
    /* Set default branch (-b).  It is "-b" followed by the value
       given, or NULL if not specified, or merely "-b" if -b is
       specified without a value.  */
    char *branch;

    /* Set comment leader (-c).  It is "-c" followed by the value
       given, or NULL if not specified.  The comment leader is
       relevant only for old versions of RCS, but we let people set it
       anyway.  */
    char *comment;

    /* Set strict locking (-L).  */
    int set_strict;

    /* Set nonstrict locking (-U).  */
    int set_nonstrict;

    /* Delete revisions (-o).  It is "-o" followed by the value specified.  */
    char *delete_revs;

    /* Keyword substitution mode (-k), e.g. "-kb".  */
    char *kflag;

    /* Description (-t).  */
    char *desc;

    /* Interactive (-I).  Problematic with client/server.  */
    int interactive;

    /* This is the cheesy part.  It is a vector with the options which
       we don't deal with above (e.g. "-afoo" "-abar,baz").  In the future
       this presumably will be replaced by other variables which break
       out the data in a more convenient fashion.  AV as well as each of
       the strings it points to is malloc'd.  */
    int ac;
    char **av;
    int av_alloc;
};

/* Add an argument.  OPT is the option letter, e.g. 'a'.  ARG is the
   argument to that option, or NULL if omitted (whether NULL can actually
   happen depends on whether the option was specified as optional to
   getopt).  */
static void
arg_add (dat, opt, arg)
    struct admin_data *dat;
    int opt;
    char *arg;
{
    char *newelt = xmalloc ((arg == NULL ? 0 : strlen (arg)) + 3);
    strcpy (newelt, "-");
    newelt[1] = opt;
    if (arg == NULL)
	newelt[2] = '\0';
    else
	strcpy (newelt + 2, arg);

    if (dat->av_alloc == 0)
    {
	dat->av_alloc = 1;
	dat->av = (char **) xmalloc (dat->av_alloc * sizeof (*dat->av));
    }
    else if (dat->ac >= dat->av_alloc)
    {
	dat->av_alloc *= 2;
	dat->av = (char **) xrealloc (dat->av,
				      dat->av_alloc * sizeof (*dat->av));
    }
    dat->av[dat->ac++] = newelt;
}

int
admin (argc, argv)
    int argc;
    char **argv;
{
    int err;
#ifdef CVS_ADMIN_GROUP
    struct group *grp;
    struct group *getgrnam();
#endif
    struct admin_data admin_data;
    int c;
    int i;
    int only_k_option;

    if (argc <= 1)
	usage (admin_usage);

    wrap_setup ();

    memset (&admin_data, 0, sizeof admin_data);

    /* TODO: get rid of `-' switch notation in admin_data.  For
       example, admin_data->branch should be not `-bfoo' but simply `foo'. */

    optind = 0;
    only_k_option = 1;
    while ((c = getopt (argc, argv,
			"+ib::c:C:a:A:e::l::u::LUn:N:m:o:s:t::IqxV:k:")) != -1)
    {
	if (c != 'k')
	    only_k_option = 0;

	switch (c)
	{
	    case 'i':
		/* This has always been documented as useless in cvs.texinfo
		   and it really is--admin_fileproc silently does nothing
		   if vers->vn_user is NULL. */
		error (0, 0, "the -i option to admin is not supported");
		error (0, 0, "run add or import to create an RCS file");
		goto usage_error;

	    case 'b':
		if (admin_data.branch != NULL)
		{
		    error (0, 0, "duplicate 'b' option");
		    goto usage_error;
		}
		if (optarg == NULL)
		    admin_data.branch = xstrdup ("-b");
		else
		{
		    admin_data.branch = xmalloc (strlen (optarg) + 5);
		    strcpy (admin_data.branch, "-b");
		    strcat (admin_data.branch, optarg);
		}
		break;

	    case 'c':
		if (admin_data.comment != NULL)
		{
		    error (0, 0, "duplicate 'c' option");
		    goto usage_error;
		}
		admin_data.comment = xmalloc (strlen (optarg) + 5);
		strcpy (admin_data.comment, "-c");
		strcat (admin_data.comment, optarg);
		break;

	    case 'C':
		/* Add commitid. */
		arg_add (&admin_data, 'C', optarg);
		break;

	    case 'a':
		arg_add (&admin_data, 'a', optarg);
		break;

	    case 'A':
		/* In the client/server case, this is cheesy because
		   we just pass along the name of the RCS file, which
		   then will want to exist on the server.  This is
		   accidental; having the client specify a pathname on
		   the server is not a design feature of the protocol.  */
		arg_add (&admin_data, 'A', optarg);
		break;

	    case 'e':
		arg_add (&admin_data, 'e', optarg);
		break;

	    case 'l':
		/* Note that multiple -l options are legal.  */
		arg_add (&admin_data, 'l', optarg);
		break;

	    case 'u':
		/* Note that multiple -u options are legal.  */
		arg_add (&admin_data, 'u', optarg);
		break;

	    case 'L':
		/* Probably could also complain if -L is specified multiple
		   times, although RCS doesn't and I suppose it is reasonable
		   just to have it mean the same as a single -L.  */
		if (admin_data.set_nonstrict)
		{
		    error (0, 0, "-U and -L are incompatible");
		    goto usage_error;
		}
		admin_data.set_strict = 1;
		break;

	    case 'U':
		/* Probably could also complain if -U is specified multiple
		   times, although RCS doesn't and I suppose it is reasonable
		   just to have it mean the same as a single -U.  */
		if (admin_data.set_strict)
		{
		    error (0, 0, "-U and -L are incompatible");
		    goto usage_error;
		}
		admin_data.set_nonstrict = 1;
		break;

	    case 'n':
		/* Mostly similar to cvs tag.  Could also be parsing
		   the syntax of optarg, although for now we just pass
		   it to rcs as-is.  Note that multiple -n options are
		   legal.  */
		arg_add (&admin_data, 'n', optarg);
		break;

	    case 'N':
		/* Mostly similar to cvs tag.  Could also be parsing
		   the syntax of optarg, although for now we just pass
		   it to rcs as-is.  Note that multiple -N options are
		   legal.  */
		arg_add (&admin_data, 'N', optarg);
		break;

	    case 'm':
		/* Change log message.  Could also be parsing the syntax
		   of optarg, although for now we just pass it to rcs
		   as-is.  Note that multiple -m options are legal.  */
		arg_add (&admin_data, 'm', optarg);
		break;

	    case 'o':
		/* Delete revisions.  Probably should also be parsing the
		   syntax of optarg, so that the client can give errors
		   rather than making the server take care of that.
		   Other than that I'm not sure whether it matters much
		   whether we parse it here or in admin_fileproc.

		   Note that multiple -o options are illegal, in RCS
		   as well as here.  */

		if (admin_data.delete_revs != NULL)
		{
		    error (0, 0, "duplicate '-o' option");
		    goto usage_error;
		}
		admin_data.delete_revs = xmalloc (strlen (optarg) + 5);
		strcpy (admin_data.delete_revs, "-o");
		strcat (admin_data.delete_revs, optarg);
		break;

	    case 's':
		/* Note that multiple -s options are legal.  */
		arg_add (&admin_data, 's', optarg);
		break;

	    case 't':
		if (admin_data.desc != NULL)
		{
		    error (0, 0, "duplicate 't' option");
		    goto usage_error;
		}
		if (optarg != NULL && optarg[0] == '-')
		    admin_data.desc = xstrdup (optarg + 1);
		else
		{
		    size_t bufsize = 0;
		    size_t len;

		    get_file (optarg, optarg, "r", &admin_data.desc,
			      &bufsize, &len);
		}
		break;

	    case 'I':
		/* At least in RCS this can be specified several times,
		   with the same meaning as being specified once.  */
		admin_data.interactive = 1;
		break;

	    case 'q':
		/* Silently set the global really_quiet flag.  This keeps admin in
		 * sync with the RCS man page and allows us to silently support
		 * older servers when necessary.
		 *
		 * Some logic says we might want to output a deprecation warning
		 * here, but I'm opting not to in order to stay quietly in sync
		 * with the RCS man page.
		 */
		really_quiet = 1;
		break;

	    case 'x':
		error (0, 0, "the -x option has never done anything useful");
		error (0, 0, "RCS files in CVS always end in ,v");
		goto usage_error;

	    case 'V':
		/* No longer supported. */
		error (0, 0, "the `-V' option is obsolete");
		break;

	    case 'k':
		if (admin_data.kflag != NULL)
		{
		    error (0, 0, "duplicate '-k' option");
		    goto usage_error;
		}
		admin_data.kflag = RCS_check_kflag (optarg);
		break;
	    default:
	    case '?':
		/* getopt will have printed an error message.  */

	    usage_error:
		/* Don't use command_name; it might be "server".  */
	        error (1, 0, "specify %s -H admin for usage information",
		       program_name);
	}
    }
    argc -= optind;
    argv += optind;

#ifdef CVS_ADMIN_GROUP
    /* The use of `cvs admin -k' is unrestricted.  However, any other
       option is restricted if the group CVS_ADMIN_GROUP exists.  */
    if (!only_k_option &&
	(grp = getgrnam(CVS_ADMIN_GROUP)) != NULL)
    {
#ifdef HAVE_GETGROUPS
	gid_t *grps;
	int n;

	/* get number of auxiliary groups */
	n = getgroups (0, NULL);
	if (n < 0)
	    error (1, errno, "unable to get number of auxiliary groups");
	grps = (gid_t *) xmalloc((n + 1) * sizeof *grps);
	n = getgroups (n, grps);
	if (n < 0)
	    error (1, errno, "unable to get list of auxiliary groups");
	grps[n] = getgid();
	for (i = 0; i <= n; i++)
	    if (grps[i] == grp->gr_gid) break;
	free (grps);
	if (i > n)
	    error (1, 0, "usage is restricted to members of the group %s",
		   CVS_ADMIN_GROUP);
#else
	char *me = getcaller();
	char **grnam;
	
	for (grnam = grp->gr_mem; *grnam; grnam++)
	    if (strcmp (*grnam, me) == 0) break;
	if (!*grnam && getgid() != grp->gr_gid)
	    error (1, 0, "usage is restricted to members of the group %s",
		   CVS_ADMIN_GROUP);
#endif
    }
#endif

    for (i = 0; i < admin_data.ac; ++i)
    {
	assert (admin_data.av[i][0] == '-');
	switch (admin_data.av[i][1])
	{
	    case 'm':
	    case 'l':
	    case 'u':
		check_numeric (&admin_data.av[i][2], argc, argv);
		break;
	    default:
		break;
	}
    }
    if (admin_data.branch != NULL)
	check_numeric (admin_data.branch + 2, argc, argv);
    if (admin_data.delete_revs != NULL)
    {
	char *p;

	check_numeric (admin_data.delete_revs + 2, argc, argv);
	p = strchr (admin_data.delete_revs + 2, ':');
	if (p != NULL && isdigit ((unsigned char) p[1]))
	    check_numeric (p + 1, argc, argv);
	else if (p != NULL && p[1] == ':' && isdigit ((unsigned char) p[2]))
	    check_numeric (p + 2, argc, argv);
    }

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
    {
	/* We're the client side.  Fire up the remote server.  */
	start_server ();
	
	ign_setup ();

	/* Note that option_with_arg does not work for us, because some
	   of the options must be sent without a space between the option
	   and its argument.  */
	if (admin_data.interactive)
	    error (1, 0, "-I option not useful with client/server");
	if (admin_data.branch != NULL)
	    send_arg (admin_data.branch);
	if (admin_data.comment != NULL)
	    send_arg (admin_data.comment);
	if (admin_data.set_strict)
	    send_arg ("-L");
	if (admin_data.set_nonstrict)
	    send_arg ("-U");
	if (admin_data.delete_revs != NULL)
	    send_arg (admin_data.delete_revs);
	if (admin_data.desc != NULL)
	{
	    char *p = admin_data.desc;
	    send_to_server ("Argument -t-", 0);
	    while (*p)
	    {
		if (*p == '\n')
		{
		    send_to_server ("\012Argumentx ", 0);
		    ++p;
		}
		else
		{
		    char *q = strchr (p, '\n');
		    if (q == NULL) q = p + strlen (p);
		    send_to_server (p, q - p);
		    p = q;
		}
	    }
	    send_to_server ("\012", 1);
	}
	/* Send this for all really_quiets since we know that it will be silently
	 * ignored when unneeded.  This supports old servers.
	 */
	if (really_quiet)
	    send_arg ("-q");
	if (admin_data.kflag != NULL)
	    send_arg (admin_data.kflag);

	for (i = 0; i < admin_data.ac; ++i)
	    send_arg (admin_data.av[i]);

	send_files (argc, argv, 0, 0, SEND_NO_CONTENTS);
	send_file_names (argc, argv, SEND_EXPAND_WILD);
	send_to_server ("admin\012", 0);
        err = get_responses_and_close ();
	goto return_it;
    }
#endif /* CLIENT_SUPPORT */

    lock_tree_for_write (argc, argv, 0, W_LOCAL, 0);

    err = start_recursion (admin_fileproc, (FILESDONEPROC) NULL, admin_dirproc,
			   (DIRLEAVEPROC) NULL, (void *)&admin_data,
			   argc, argv, 0,
			   W_LOCAL, 0, 0, (char *) NULL, 1);
    Lock_Cleanup ();

 return_it:
    if (admin_data.branch != NULL)
	free (admin_data.branch);
    if (admin_data.comment != NULL)
	free (admin_data.comment);
    if (admin_data.delete_revs != NULL)
	free (admin_data.delete_revs);
    if (admin_data.kflag != NULL)
	free (admin_data.kflag);
    if (admin_data.desc != NULL)
	free (admin_data.desc);
    for (i = 0; i < admin_data.ac; ++i)
	free (admin_data.av[i]);
    if (admin_data.av != NULL)
	free (admin_data.av);

    return (err);
}

/*
 * Called to run "rcs" on a particular file.
 */
/* ARGSUSED */
static int
admin_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    struct admin_data *admin_data = (struct admin_data *) callerdat;
    Vers_TS *vers;
    char *version;
    int i;
    int status = 0;
    RCSNode *rcs, *rcs2;

    vers = Version_TS (finfo, NULL, NULL, NULL, 0, 0);

    version = vers->vn_user;
    if (version == NULL)
	goto exitfunc;
    else if (strcmp (version, "0") == 0)
    {
	error (0, 0, "cannot admin newly added file `%s'", finfo->file);
	goto exitfunc;
    }

    rcs = vers->srcfile;
    if (rcs == NULL)
    {
	error (0, 0, "lost revision control file for `%s'", finfo->file);
	goto exitfunc;
    }
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    status = 0;

    if (!really_quiet)
    {
	cvs_output ("RCS file: ", 0);
	cvs_output (rcs->path, 0);
	cvs_output ("\n", 1);
    }

    if (admin_data->branch != NULL)
    {
	char *branch = &admin_data->branch[2];
	if (*branch != '\0' && ! isdigit ((unsigned char) *branch))
	{
	    branch = RCS_whatbranch (rcs, admin_data->branch + 2);
	    if (branch == NULL)
	    {
		error (0, 0, "%s: Symbolic name %s is undefined.",
				rcs->path, admin_data->branch + 2);
		status = 1;
	    }
	}
	if (status == 0)
	    RCS_setbranch (rcs, branch);
	if (branch != NULL && branch != &admin_data->branch[2])
	    free (branch);
    }
    if (admin_data->comment != NULL)
    {
	if (rcs->comment != NULL)
	    free (rcs->comment);
	rcs->comment = xstrdup (admin_data->comment + 2);
    }
    if (admin_data->set_strict)
	rcs->strict_locks = 1;
    if (admin_data->set_nonstrict)
	rcs->strict_locks = 0;
    if (admin_data->delete_revs != NULL)
    {
	char *s, *t, *rev1, *rev2;
	/* Set for :, clear for ::.  */
	int inclusive;
	char *t2;

	s = admin_data->delete_revs + 2;
	inclusive = 1;
	t = strchr (s, ':');
	if (t != NULL)
	{
	    if (t[1] == ':')
	    {
		inclusive = 0;
		t2 = t + 2;
	    }
	    else
		t2 = t + 1;
	}

	/* Note that we don't support '-' for ranges.  RCS considers it
	   obsolete and it is problematic with tags containing '-'.  "cvs log"
	   has made the same decision.  */

	if (t == NULL)
	{
	    /* -orev */
	    rev1 = xstrdup (s);
	    rev2 = xstrdup (s);
	}
	else if (t == s)
	{
	    /* -o:rev2 */
	    rev1 = NULL;
	    rev2 = xstrdup (t2);
	}
	else
	{
	    *t = '\0';
	    rev1 = xstrdup (s);
	    *t = ':';	/* probably unnecessary */
	    if (*t2 == '\0')
		/* -orev1: */
		rev2 = NULL;
	    else
		/* -orev1:rev2 */
		rev2 = xstrdup (t2);
	}

	if (rev1 == NULL && rev2 == NULL)
	{
	    /* RCS segfaults if `-o:' is given */
	    error (0, 0, "no valid revisions specified in `%s' option",
		   admin_data->delete_revs);
	    status = 1;
	}
	else
	{
	    status |= RCS_delete_revs (rcs, rev1, rev2, inclusive);
	    if (rev1)
		free (rev1);
	    if (rev2)
		free (rev2);
	}
    }
    if (admin_data->desc != NULL)
    {
	free (rcs->desc);
	rcs->desc = xstrdup (admin_data->desc);
    }
    if (admin_data->kflag != NULL)
    {
	char *kflag = admin_data->kflag + 2;
	char *oldexpand = RCS_getexpand (rcs);
	if (oldexpand == NULL || strcmp (oldexpand, kflag) != 0)
	    RCS_setexpand (rcs, kflag);
    }

    /* Handle miscellaneous options.  TODO: decide whether any or all
       of these should have their own fields in the admin_data
       structure. */
    for (i = 0; i < admin_data->ac; ++i)
    {
	char *arg;
	char *p, *rev, *revnum, *tag, *msg, *commitid;
	char **users;
	int argc, u;
	Node *n;
	RCSVers *delta;
	
	arg = admin_data->av[i];
	switch (arg[1])
	{
	    case 'a': /* fall through */
	    case 'e':
	        line2argv (&argc, &users, arg + 2, " ,\t\n");
		if (arg[1] == 'a')
		    for (u = 0; u < argc; ++u)
			RCS_addaccess (rcs, users[u]);
		else if (argc == 0)
		    RCS_delaccess (rcs, NULL);
		else
		    for (u = 0; u < argc; ++u)
			RCS_delaccess (rcs, users[u]);
		free_names (&argc, users);
		break;
	    case 'A':

		/* See admin-19a-admin and friends in sanity.sh for
		   relative pathnames.  It makes sense to think in
		   terms of a syntax which give pathnames relative to
		   the repository or repository corresponding to the
		   current directory or some such (and perhaps don't
		   include ,v), but trying to worry about such things
		   is a little pointless unless you first worry about
		   whether "cvs admin -A" as a whole makes any sense
		   (currently probably not, as access lists don't
		   affect the behavior of CVS).  */

		rcs2 = RCS_parsercsfile (arg + 2);
		if (rcs2 == NULL)
		    error (1, 0, "cannot continue");

		p = xstrdup (RCS_getaccess (rcs2));
	        line2argv (&argc, &users, p, " \t\n");
		free (p);
		freercsnode (&rcs2);

		for (u = 0; u < argc; ++u)
		    RCS_addaccess (rcs, users[u]);
		free_names (&argc, users);
		break;
	    case 'C':
	        p = strchr (arg, ':');
		if (p == NULL)
		{
		    error (0, 0, "%s: -C option lacks commitid", rcs->path);
		    status = 1;
		    continue;
		}
		*p = '\0';
		rev = RCS_gettag (rcs, arg + 2, 1, NULL);
		if (rev == NULL)
		{
		    error (0, 0, "%s: no such revision %s", rcs->path, arg + 2);
		    status = 1;
		    continue;
		}
		*p++ = ':';
		commitid = p;

		if (*commitid == '\0')
		{
		    error (0, 0, "%s: -C option lacks commitid", rcs->path);
		    free (rev);
		    status = 1;
		    continue;
		}

		n = findnode (rcs->versions, rev);
		delta = (RCSVers *) n->data;

		if (delta->other_delta == NULL)
    		    delta->other_delta = getlist();

		if (n = findnode (delta->other_delta, "commitid"))
		{
		    error (0, 0, "%s: revision %s already has commitid %s",
		        rcs->path, rev, n->data);
		    free (rev);
		    status = 1;
		    continue;
		}

		n = getnode();
		n->type = RCSFIELD;
		n->key = xstrdup ("commitid");
		n->data = xstrdup(commitid);
		addnode (delta->other_delta, n);

		free (rev);

		break;
	    case 'n': /* fall through */
	    case 'N':
		if (arg[2] == '\0')
		{
		    cvs_outerr ("missing symbolic name after ", 0);
		    cvs_outerr (arg, 0);
		    cvs_outerr ("\n", 1);
		    break;
		}
		p = strchr (arg, ':');
		if (p == NULL)
		{
		    if (RCS_deltag (rcs, arg + 2) != 0)
		    {
			error (0, 0, "%s: Symbolic name %s is undefined.",
			       rcs->path, 
			       arg + 2);
			status = 1;
			continue;
		    }
		    break;
		}
		*p = '\0';
		tag = xstrdup (arg + 2);
		*p++ = ':';

		/* Option `n' signals an error if this tag is already bound. */
		if (arg[1] == 'n')
		{
		    n = findnode (RCS_symbols (rcs), tag);
		    if (n != NULL)
		    {
			error (0, 0,
			       "%s: symbolic name %s already bound to %s",
			       rcs->path,
			       tag, n->data);
			status = 1;
			free (tag);
			continue;
		    }
		}

                /* Attempt to perform the requested tagging.  */

		if ((*p == 0 && (rev = RCS_head (rcs)))
                    || (rev = RCS_tag2rev (rcs, p))) /* tag2rev may exit */
		{
		    RCS_check_tag (tag); /* exit if not a valid tag */
		    RCS_settag (rcs, tag, rev);
		    free (rev);
		}
                else
		{
		    if (!really_quiet)
			error (0, 0,
			       "%s: Symbolic name or revision %s is undefined.",
			       rcs->path, p);
		    status = 1;
		}
		free (tag);
		break;
	    case 's':
	        p = strchr (arg, ':');
		if (p == NULL)
		{
		    tag = xstrdup (arg + 2);
		    rev = RCS_head (rcs);
		}
		else
		{
		    *p = '\0';
		    tag = xstrdup (arg + 2);
		    *p++ = ':';
		    rev = xstrdup (p);
		}
		revnum = RCS_gettag (rcs, rev, 0, NULL);
		if (revnum != NULL)
		{
		    n = findnode (rcs->versions, revnum);
		    free (revnum);
		}
		else
		    n = NULL;
		if (n == NULL)
		{
		    error (0, 0,
			   "%s: can't set state of nonexisting revision %s",
			   rcs->path,
			   rev);
		    free (rev);
		    status = 1;
		    continue;
		}
		free (rev);
		delta = (RCSVers *) n->data;
		free (delta->state);
		delta->state = tag;
		break;

	    case 'm':
	        p = strchr (arg, ':');
		if (p == NULL)
		{
		    error (0, 0, "%s: -m option lacks revision number",
			   rcs->path);
		    status = 1;
		    continue;
		}
		*p = '\0';
		rev = RCS_gettag (rcs, arg + 2, 0, NULL);
		if (rev == NULL)
		{
		    error (0, 0, "%s: no such revision %s", rcs->path, rev);
		    status = 1;
		    continue;
		}
		*p++ = ':';
		msg = p;

		n = findnode (rcs->versions, rev);
		free (rev);
		delta = (RCSVers *) n->data;
		if (delta->text == NULL)
		{
		    delta->text = (Deltatext *) xmalloc (sizeof (Deltatext));
		    memset ((void *) delta->text, 0, sizeof (Deltatext));
		}
		delta->text->version = xstrdup (delta->version);
		delta->text->log = make_message_rcslegal (msg);
		break;

	    case 'l':
	        status |= RCS_lock (rcs, arg[2] ? arg + 2 : NULL, 0);
		break;
	    case 'u':
		status |= RCS_unlock (rcs, arg[2] ? arg + 2 : NULL, 0);
		break;
	    default: assert(0);	/* can't happen */
	}
    }

    if (status == 0)
    {
	RCS_rewrite (rcs, NULL, NULL);
	if (!really_quiet)
	    cvs_output ("done\n", 5);
    }
    else
    {
	/* Note that this message should only occur after another
	   message has given a more specific error.  The point of this
	   additional message is to make it clear that the previous problems
	   caused CVS to forget about the idea of modifying the RCS file.  */
	if (!really_quiet)
	    error (0, 0, "RCS file for `%s' not modified.", finfo->file);
	RCS_abandon (rcs);
    }

  exitfunc:
    freevers_ts (&vers);
    return status;
}

/*
 * Print a warm fuzzy message
 */
/* ARGSUSED */
static Dtype
admin_dirproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repos;
    char *update_dir;
    List *entries;
{
    if (!quiet)
	error (0, 0, "Administrating %s", update_dir);
    return (R_PROCESS);
}
@


1.2
log
@If "cvs admin" encountered an entry in CVS/Entries for a file which has no
(longer an) RCS file in CVSROOT, both -- GNU cvs and OpenCVS -- segfaulted.

ok joris
@
text
@d30 1
d171 1
a171 1
			"+ib::c:a:A:e::l::u::LUn:N:m:o:s:t::IqxV:k:")) != -1)
d213 5
d698 1
a698 1
	char *p, *rev, *revnum, *tag, *msg;
d745 51
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d8 1
a8 1
 * Administration
a9 2
 * For now, this is basically a front end for rcs.  All options are passed
 * directly on.
d13 2
a14 4

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)admin.c 1.20 94/09/30 $";
USE(rcsid);
d16 1
d18 4
a21 4
static Dtype admin_dirproc PROTO((char *dir, char *repos, char *update_dir));
static int admin_fileproc PROTO((char *file, char *update_dir,
			   char *repository, List *entries,
			   List *srcfiles));
d25 40
a64 1
    "Usage: %s %s rcs-options files...\n",
d68 73
a140 2
static int ac;
static char **av;
d148 8
d162 281
a442 10
    /* skip all optional arguments to see if we have any file names */
    for (ac = 1; ac < argc; ac++)
	if (argv[ac][0] != '-')
	    break;
    argc -= ac;
    av = argv + 1;
    argv += ac;
    ac--;
    if (ac == 0 || argc == 0)
	usage (admin_usage);
d445 1
a445 1
    if (client_active)
a446 2
	int i;

d452 52
a503 14
	for (i = 1; i <= ac; ++i)
	    send_arg (av[i]);

#if 0
	/* FIXME:  We shouldn't have to send current files, but I'm not sure
	   whether it works.  So send the files --
	   it's slower but it works.  */
	send_file_names (argc, argv);
#else
	send_files (argc, argv, 0, 0);
#endif
	if (fprintf (to_server, "admin\n") < 0)
	    error (1, errno, "writing to server");
        return get_responses_and_close ();
d507 24
a530 4
    /* start the recursion processor */
    err = start_recursion (admin_fileproc, (int (*) ()) NULL, admin_dirproc,
			   (int (*) ()) NULL, argc, argv, 0,
			   W_LOCAL, 0, 1, (char *) NULL, 1, 0);
d539 3
a541 6
admin_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
d543 1
d546 3
a548 3
    char **argv;
    int argc;
    int retcode = 0;
d550 1
a550 2
    vers = Version_TS (repository, (char *) NULL, (char *) NULL, (char *) NULL,
		       file, 0, 0, entries, srcfiles);
d554 1
a554 1
	return (0);
d557 127
a683 2
	error (0, 0, "cannot admin newly added file `%s'", file);
	return (0);
d686 200
a885 10
    run_setup ("%s%s", Rcsbin, RCS);
    for (argc = ac, argv = av; argc; argc--, argv++)
	run_arg (*argv);
    run_arg (vers->srcfile->path);
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)
    {
	if (!quiet)
	    error (0, retcode == -1 ? errno : 0,
		   "%s failed for `%s'", RCS, file);
	return (1);
d887 14
a900 1
    return (0);
d908 2
a909 1
admin_dirproc (dir, repos, update_dir)
d913 1
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a14 3
#ifdef CVS_ADMIN_GROUP
#include <grp.h>
#endif
d41 1
a41 3
#ifdef CVS_ADMIN_GROUP
    struct group *grp;
#endif
a44 25
#ifdef CVS_ADMIN_GROUP
    grp = getgrnam(CVS_ADMIN_GROUP);
     /* skip usage right check if group CVS_ADMIN_GROUP does not exist */
    if (grp != NULL)
    {
	char *me = getcaller();
	char **grnam = grp->gr_mem;
	int denied = 1;
	
	while (*grnam)
	{
	    if (strcmp(*grnam, me) == 0) 
	    {
		denied = 0;
		break;
	    }
	    grnam++;
	}

	if (denied)
	    error (1, 0, "usage is restricted to members of the group %s",
		   CVS_ADMIN_GROUP);
    }
#endif

d68 1
a68 1
	for (i = 0; i <= ac; ++i)	/* XXX send -ko too with i = 0 */
d71 1
a71 1
	send_file_names (argc, argv);
d75 2
d78 3
a80 1
	send_to_server ("admin\012", 0);
d86 2
a87 2
    err = start_recursion (admin_fileproc, (FILESDONEPROC) NULL, admin_dirproc,
			   (DIRLEAVEPROC) NULL, argc, argv, 0,
a108 1
    int status = 0;
d115 1
a115 1
	goto exitfunc;
d119 1
a119 1
	goto exitfunc;
d131 1
a131 2
	status = 1;
	goto exitfunc;
d133 1
a133 3
  exitfunc:
    freevers_ts (&vers);
    return status;
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d19 5
d25 3
a27 1
static int admin_fileproc PROTO((struct file_info *finfo));
d123 6
a128 2
admin_fileproc (finfo)
    struct file_info *finfo;
d137 2
a138 2
    vers = Version_TS (finfo->repository, (char *) NULL, (char *) NULL, (char *) NULL,
		       finfo->file, 0, 0, finfo->entries, finfo->srcfiles);
d145 1
a145 1
	error (0, 0, "cannot admin newly added file `%s'", finfo->file);
d149 1
a149 1
    run_setup ("%s%s -x,v/", Rcsbin, RCS);
d157 1
a157 1
		   "%s failed for `%s'", RCS, finfo->file);
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d94 1
a94 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
d127 1
a127 1
		       finfo->file, 0, 0, finfo->entries, finfo->rcs);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d19 2
a20 4
static Dtype admin_dirproc PROTO ((void *callerdat, char *dir,
				   char *repos, char *update_dir,
				   List *entries));
static int admin_fileproc PROTO ((void *callerdat, struct file_info *finfo));
d106 2
a107 2
			   (DIRLEAVEPROC) NULL, NULL, argc, argv, 0,
			   W_LOCAL, 0, 1, (char *) NULL, 1);
d116 1
a116 2
admin_fileproc (callerdat, finfo)
    void *callerdat;
d126 2
a127 1
    vers = Version_TS (finfo, NULL, NULL, NULL, 0, 0);
d160 1
a160 2
admin_dirproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
a163 1
    List *entries;
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d100 1
a100 1
	send_files (argc, argv, 0, 0, 0);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@a40 1
    struct group *getgrnam();
d80 2
d100 1
a100 1
	send_files (argc, argv, 0, 0, 0, 0);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d96 4
a99 1
	send_files (argc, argv, 0, 0, SEND_NO_CONTENTS);
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d92 1
a92 1
	for (i = 0; i < ac; ++i)	/* XXX send -ko too with i = 0 */
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d8 1
a8 1
 * Administration ("cvs admin")
d10 2
a17 1
#include <assert.h>
a26 1
    "(Specify the --help global option for a list of other help options)\n",
d30 2
a31 79
/* This structure is used to pass information through start_recursion.  */
struct admin_data
{
    /* Set default branch (-b).  It is "-b" followed by the value
       given, or NULL if not specified, or merely "-b" if -b is
       specified without a value.  */
    char *branch;

    /* Set comment leader (-c).  It is "-c" followed by the value
       given, or NULL if not specified.  The comment leader is
       relevant only for old versions of RCS, but we let people set it
       anyway.  */
    char *comment;

    /* Set strict locking (-L).  */
    int set_strict;

    /* Set nonstrict locking (-U).  */
    int set_nonstrict;

    /* Delete revisions (-o).  It is "-o" followed by the value specified.  */
    char *delete_revs;

    /* Keyword substitution mode (-k), e.g. "-kb".  */
    char *kflag;

    /* Description (-t).  See sanity.sh for various moanings about
       files and stdin and such.  "" if -t specified without an
       argument.  It is "-t" followed by the argument.  */
    char *desc;

    /* Interactive (-I).  Problematic with client/server.  */
    int interactive;

    /* Quiet (-q).  Not the same as the global -q option, which is a bit
       on the confusing side, perhaps.  */
    int quiet;

    /* This is the cheesy part.  It is a vector with the options which
       we don't deal with above (e.g. "-afoo" "-abar,baz").  In the future
       this presumably will be replaced by other variables which break
       out the data in a more convenient fashion.  AV as well as each of
       the strings it points to is malloc'd.  */
    int ac;
    char **av;
    int av_alloc;
};

/* Add an argument.  OPT is the option letter, e.g. 'a'.  ARG is the
   argument to that option, or NULL if omitted (whether NULL can actually
   happen depends on whether the option was specified as optional to
   getopt).  */
static void
arg_add (dat, opt, arg)
    struct admin_data *dat;
    int opt;
    char *arg;
{
    char *newelt = xmalloc ((arg == NULL ? 0 : strlen (arg)) + 3);
    strcpy (newelt, "-");
    newelt[1] = opt;
    if (arg == NULL)
	newelt[2] = '\0';
    else
	strcpy (newelt + 2, arg);

    if (dat->av_alloc == 0)
    {
	dat->av_alloc = 1;
	dat->av = (char **) xmalloc (dat->av_alloc * sizeof (*dat->av));
    }
    else if (dat->ac >= dat->av_alloc)
    {
	dat->av_alloc *= 2;
	dat->av = (char **) xrealloc (dat->av,
				      dat->av_alloc * sizeof (*dat->av));
    }
    dat->av[dat->ac++] = newelt;
}
a42 4
    struct admin_data admin_data;
    int c;
    int i;

d73 8
a80 229
    memset (&admin_data, 0, sizeof admin_data);

    /* TODO: get rid of `-' switch notation in admin_data.  For
       example, admin_data->branch should be not `-bfoo' but simply `foo'. */

    optind = 0;
    while ((c = getopt (argc, argv,
			"+ib::c:a:A:e:l::u::LUn:N:m:o:s:t::IqxV:k:")) != -1)
    {
	switch (c)
	{
	    case 'i':
		/* This has always been documented as useless in cvs.texinfo
		   and it really is--admin_fileproc silently does nothing
		   if vers->vn_user is NULL. */
		error (0, 0, "the -i option to admin is not supported");
		error (0, 0, "run add or import to create an RCS file");
		goto usage_error;

	    case 'b':
		if (admin_data.branch != NULL)
		{
		    error (0, 0, "duplicate 'b' option");
		    goto usage_error;
		}
		if (optarg == NULL)
		    admin_data.branch = xstrdup ("-b");
		else
		{
		    admin_data.branch = xmalloc (strlen (optarg) + 5);
		    strcpy (admin_data.branch, "-b");
		    strcat (admin_data.branch, optarg);
		}
		break;

	    case 'c':
		if (admin_data.comment != NULL)
		{
		    error (0, 0, "duplicate 'c' option");
		    goto usage_error;
		}
		admin_data.comment = xmalloc (strlen (optarg) + 5);
		strcpy (admin_data.comment, "-c");
		strcat (admin_data.comment, optarg);
		break;

	    case 'a':
		arg_add (&admin_data, 'a', optarg);
		break;

	    case 'A':
		/* In the client/server case, this is cheesy because
		   we just pass along the name of the RCS file, which
		   then will want to exist on the server.  This is
		   accidental; having the client specify a pathname on
		   the server is not a design feature of the protocol.  */
		arg_add (&admin_data, 'A', optarg);
		break;

	    case 'e':
		arg_add (&admin_data, 'e', optarg);
		break;

	    case 'l':
		/* Note that multiple -l options are legal.  */
		arg_add (&admin_data, 'l', optarg);
		break;

	    case 'u':
		/* Note that multiple -u options are legal.  */
		arg_add (&admin_data, 'u', optarg);
		break;

	    case 'L':
		/* Probably could also complain if -L is specified multiple
		   times, although RCS doesn't and I suppose it is reasonable
		   just to have it mean the same as a single -L.  */
		if (admin_data.set_nonstrict)
		{
		    error (0, 0, "-U and -L are incompatible");
		    goto usage_error;
		}
		admin_data.set_strict = 1;
		break;

	    case 'U':
		/* Probably could also complain if -U is specified multiple
		   times, although RCS doesn't and I suppose it is reasonable
		   just to have it mean the same as a single -U.  */
		if (admin_data.set_strict)
		{
		    error (0, 0, "-U and -L are incompatible");
		    goto usage_error;
		}
		admin_data.set_nonstrict = 1;
		break;

	    case 'n':
		/* Mostly similar to cvs tag.  Could also be parsing
		   the syntax of optarg, although for now we just pass
		   it to rcs as-is.  Note that multiple -n options are
		   legal.  */
		arg_add (&admin_data, 'n', optarg);
		break;

	    case 'N':
		/* Mostly similar to cvs tag.  Could also be parsing
		   the syntax of optarg, although for now we just pass
		   it to rcs as-is.  Note that multiple -N options are
		   legal.  */
		arg_add (&admin_data, 'N', optarg);
		break;

	    case 'm':
		/* Change log message.  Could also be parsing the syntax
		   of optarg, although for now we just pass it to rcs
		   as-is.  Note that multiple -m options are legal.  */
		arg_add (&admin_data, 'm', optarg);
		break;

	    case 'o':
		/* Delete revisions.  Probably should also be parsing the
		   syntax of optarg, so that the client can give errors
		   rather than making the server take care of that.
		   Other than that I'm not sure whether it matters much
		   whether we parse it here or in admin_fileproc.

		   Note that multiple -o options are illegal, in RCS
		   as well as here.  */

		if (admin_data.delete_revs != NULL)
		{
		    error (0, 0, "duplicate '-o' option");
		    goto usage_error;
		}
		admin_data.delete_revs = xmalloc (strlen (optarg) + 5);
		strcpy (admin_data.delete_revs, "-o");
		strcat (admin_data.delete_revs, optarg);
		break;

	    case 's':
		/* Note that multiple -s options are legal.  */
		arg_add (&admin_data, 's', optarg);
		break;

	    case 't':
		if (admin_data.desc != NULL)
		{
		    error (0, 0, "duplicate 't' option");
		    goto usage_error;
		}
		if (optarg == NULL)
		    admin_data.desc = xstrdup ("-t");
		else
		{
		    admin_data.desc = xmalloc (strlen (optarg) + 5);
		    strcpy (admin_data.desc, "-t");
		    strcat (admin_data.desc, optarg);
		}
		break;

	    case 'I':
		/* At least in RCS this can be specified several times,
		   with the same meaning as being specified once.  */
		admin_data.interactive = 1;
		break;

	    case 'q':
		admin_data.quiet = 1;
		break;

	    case 'x':
		error (0, 0, "the -x option has never done anything useful");
		error (0, 0, "RCS files in CVS always end in ,v");
		goto usage_error;

	    case 'V':
		/* No longer supported. */
		error (0, 0, "the `-V' option is obsolete");
		break;

	    case 'k':
		if (admin_data.kflag != NULL)
		{
		    error (0, 0, "duplicate '-k' option");
		    goto usage_error;
		}
		admin_data.kflag = RCS_check_kflag (optarg);
		break;
	    default:
	    case '?':
		/* getopt will have printed an error message.  */

	    usage_error:
		/* Don't use command_name; it might be "server".  */
	        error (1, 0, "specify %s -H admin for usage information",
		       program_name);
	}
    }
    argc -= optind;
    argv += optind;

    for (i = 0; i < admin_data.ac; ++i)
    {
	assert (admin_data.av[i][0] == '-');
	switch (admin_data.av[i][1])
	{
	    case 'm':
	    case 'l':
	    case 'u':
		check_numeric (&admin_data.av[i][2], argc, argv);
		break;
	    default:
		break;
	}
    }
    if (admin_data.branch != NULL)
	check_numeric (admin_data.branch + 2, argc, argv);
    if (admin_data.delete_revs != NULL)
    {
	char *p;

	check_numeric (admin_data.delete_revs + 2, argc, argv);
	p = strchr (admin_data.delete_revs + 2, ':');
	if (p != NULL && isdigit (p[1]))
	    check_numeric (p + 1, argc, argv);
	else if (p != NULL && p[1] == ':' && isdigit(p[2]))
	    check_numeric (p + 2, argc, argv);
    }
d85 2
d92 2
a93 24
	/* Note that option_with_arg does not work for us, because some
	   of the options must be sent without a space between the option
	   and its argument.  */
	if (admin_data.interactive)
	    error (1, 0, "-I option not useful with client/server");
	if (admin_data.branch != NULL)
	    send_arg (admin_data.branch);
	if (admin_data.comment != NULL)
	    send_arg (admin_data.comment);
	if (admin_data.set_strict)
	    send_arg ("-L");
	if (admin_data.set_nonstrict)
	    send_arg ("-U");
	if (admin_data.delete_revs != NULL)
	    send_arg (admin_data.delete_revs);
	if (admin_data.desc != NULL)
	    send_arg (admin_data.desc);
	if (admin_data.quiet)
	    send_arg ("-q");
	if (admin_data.kflag != NULL)
	    send_arg (admin_data.kflag);

	for (i = 0; i < admin_data.ac; ++i)
	    send_arg (admin_data.av[i]);
d98 1
a98 2
        err = get_responses_and_close ();
	goto return_it;
d102 1
a102 2
    lock_tree_for_write (argc, argv, 0, 0);

d104 2
a105 21
			   (DIRLEAVEPROC) NULL, (void *)&admin_data,
			   argc, argv, 0,
			   W_LOCAL, 0, 0, (char *) NULL, 1);
    Lock_Cleanup ();

 return_it:
    if (admin_data.branch != NULL)
	free (admin_data.branch);
    if (admin_data.comment != NULL)
	free (admin_data.comment);
    if (admin_data.delete_revs != NULL)
	free (admin_data.delete_revs);
    if (admin_data.kflag != NULL)
	free (admin_data.kflag);
    if (admin_data.desc != NULL)
	free (admin_data.desc);
    for (i = 0; i < admin_data.ac; ++i)
	free (admin_data.av[i]);
    if (admin_data.av != NULL)
	free (admin_data.av);

a117 1
    struct admin_data *admin_data = (struct admin_data *) callerdat;
d120 3
a122 1
    int i;
a123 1
    RCSNode *rcs, *rcs2;
d136 11
a146 22
    rcs = vers->srcfile;
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);

    status = 0;

    if (!admin_data->quiet)
    {
	cvs_output ("RCS file: ", 0);
	cvs_output (rcs->path, 0);
	cvs_output ("\n", 1);
    }

    if (admin_data->branch != NULL)
	RCS_setbranch (rcs, (admin_data->branch[2] == '\0'
			     ? NULL
			     : admin_data->branch + 2));
    if (admin_data->comment != NULL)
    {
	if (rcs->comment != NULL)
	    free (rcs->comment);
	rcs->comment = xstrdup (admin_data->comment + 2);
a147 297
    if (admin_data->set_strict)
	rcs->strict_locks = 1;
    if (admin_data->set_nonstrict)
	rcs->strict_locks = 0;
    if (admin_data->delete_revs != NULL)
    {
	char *s, *t, *rev1, *rev2;
	/* Set for :, clear for ::.  */
	int inclusive;
	char *t2;

	s = admin_data->delete_revs + 2;
	inclusive = 1;
	t = strchr (s, ':');
	if (t != NULL)
	{
	    if (t[1] == ':')
	    {
		inclusive = 0;
		t2 = t + 2;
	    }
	    else
		t2 = t + 1;
	}

	/* Note that we don't support '-' for ranges.  RCS considers it
	   obsolete and it is problematic with tags containing '-'.  "cvs log"
	   has made the same decision.  */

	if (t == NULL)
	{
	    /* -orev */
	    rev1 = xstrdup (s);
	    rev2 = xstrdup (s);
	}
	else if (t == s)
	{
	    /* -o:rev2 */
	    rev1 = NULL;
	    rev2 = xstrdup (t2);
	}
	else
	{
	    *t = '\0';
	    rev1 = xstrdup (s);
	    *t = ':';	/* probably unnecessary */
	    if (*t2 == '\0')
		/* -orev1: */
		rev2 = NULL;
	    else
		/* -orev1:rev2 */
		rev2 = xstrdup (t2);
	}

	if (rev1 == NULL && rev2 == NULL)
	{
	    /* RCS segfaults if `-o:' is given */
	    error (0, 0, "no valid revisions specified in `%s' option",
		   admin_data->delete_revs);
	    status = 1;
	}
	else
	{
	    status |= RCS_delete_revs (rcs, rev1, rev2, inclusive);
	    if (rev1)
		free (rev1);
	    if (rev2)
		free (rev2);
	}
    }
    if (admin_data->desc != NULL)
    {
	free (rcs->desc);
	rcs->desc = NULL;
	if (admin_data->desc[2] == '-')
	    rcs->desc = xstrdup (admin_data->desc + 3);
	else
	{
	    char *descfile = admin_data->desc + 2;
	    size_t bufsize = 0;
	    size_t len;

	    /* If -t specified with no argument, read from stdin. */
	    if (*descfile == '\0')
		descfile = NULL;
	    get_file (descfile, descfile, "r", &rcs->desc, &bufsize, &len);
	}
    }
    if (admin_data->kflag != NULL)
    {
	char *kflag = admin_data->kflag + 2;
	if (!rcs->expand || strcmp (rcs->expand, kflag) != 0)
	{
	    if (rcs->expand)
		free (rcs->expand);
	    rcs->expand = xstrdup (kflag);
	}
    }

    /* Handle miscellaneous options.  TODO: decide whether any or all
       of these should have their own fields in the admin_data
       structure. */
    for (i = 0; i < admin_data->ac; ++i)
    {
	char *arg;
	char *p, *rev, *revnum, *tag, *msg;
	char **users;
	int argc, u;
	Node *n;
	RCSVers *delta;
	
	arg = admin_data->av[i];
	switch (arg[1])
	{
	    case 'a': /* fall through */
	    case 'e':
	        line2argv (&argc, &users, arg + 2, " ,\t\n");
		if (arg[1] == 'a')
		    for (u = 0; u < argc; ++u)
			RCS_addaccess (rcs, users[u]);
		else
		    for (u = 0; u < argc; ++u)
			RCS_delaccess (rcs, users[u]);
		free_names (&argc, users);
		break;
	    case 'A':

		/* See admin-19a-admin and friends in sanity.sh for
		   relative pathnames.  It makes sense to think in
		   terms of a syntax which give pathnames relative to
		   the repository or repository corresponding to the
		   current directory or some such (and perhaps don't
		   include ,v), but trying to worry about such things
		   is a little pointless unless you first worry about
		   whether "cvs admin -A" as a whole makes any sense
		   (currently probably not, as access lists don't
		   affect the behavior of CVS).  */

		rcs2 = RCS_parsercsfile (arg + 2);
		if (rcs2 == NULL)
		    error (1, 0, "cannot continue");

		p = xstrdup (RCS_getaccess (rcs2));
	        line2argv (&argc, &users, p, " \t\n");
		free (p);
		freercsnode (&rcs2);

		for (u = 0; u < argc; ++u)
		    RCS_addaccess (rcs, users[u]);
		free_names (&argc, users);
		break;
	    case 'n': /* fall through */
	    case 'N':
		if (arg[2] == '\0')
		{
		    cvs_outerr ("missing symbolic name after ", 0);
		    cvs_outerr (arg, 0);
		    cvs_outerr ("\n", 1);
		    break;
		}
		p = strchr (arg, ':');
		if (p == NULL)
		{
		    if (RCS_deltag (rcs, arg + 2) != 0)
		    {
			error (0, 0, "%s: Symbolic name %s is undefined.",
			       rcs->path, 
			       arg + 2);
			status = 1;
			continue;
		    }
		    break;
		}
		*p = '\0';
		tag = xstrdup (arg + 2);
		*p++ = ':';

		/* Option `n' signals an error if this tag is already bound. */
		if (arg[1] == 'n')
		{
		    n = findnode (RCS_symbols (rcs), tag);
		    if (n != NULL)
		    {
			error (0, 0,
			       "%s: symbolic name %s already bound to %s",
			       rcs->path,
			       tag, n->data);
			status = 1;
			continue;
		    }
		}

		/* Expand rev if necessary. */
		rev = RCS_gettag (rcs, p, 0, NULL);
		RCS_settag (rcs, tag, rev);
		if (rev != NULL)
		    free (rev);
		free (tag);
		break;
	    case 's':
	        p = strchr (arg, ':');
		if (p == NULL)
		{
		    tag = xstrdup (arg + 2);
		    rev = RCS_head (rcs);
		}
		else
		{
		    *p = '\0';
		    tag = xstrdup (arg + 2);
		    *p++ = ':';
		    rev = xstrdup (p);
		}
		revnum = RCS_gettag (rcs, rev, 0, NULL);
		free (rev);
		if (revnum != NULL)
		    n = findnode (rcs->versions, revnum);
		if (revnum == NULL || n == NULL)
		{
		    error (0, 0,
			   "%s: can't set state of nonexisting revision %s",
			   rcs->path,
			   rev);
		    if (revnum != NULL)
			free (revnum);
		    status = 1;
		    continue;
		}
		delta = (RCSVers *) n->data;
		free (delta->state);
		delta->state = tag;
		break;

	    case 'm':
	        p = strchr (arg, ':');
		if (p == NULL)
		{
		    error (0, 0, "%s: -m option lacks revision number",
			   rcs->path);
		    status = 1;
		    continue;
		}
		*p = '\0';
		rev = RCS_gettag (rcs, arg + 2, 0, NULL);
		if (rev == NULL)
		{
		    error (0, 0, "%s: no such revision %s", rcs->path, rev);
		    status = 1;
		    continue;
		}
		*p++ = ':';
		msg = p;

		n = findnode (rcs->versions, rev);
		delta = (RCSVers *) n->data;
		if (delta->text == NULL)
		{
		    delta->text = (Deltatext *) xmalloc (sizeof (Deltatext));
		    memset ((void *) delta->text, 0, sizeof (Deltatext));
		}
		delta->text->version = xstrdup (delta->version);
		delta->text->log = make_message_rcslegal (msg);
		break;

	    case 'l':
	        status |= RCS_lock (rcs, arg[2] ? arg + 2 : NULL, 0);
		break;
	    case 'u':
		status |= RCS_unlock (rcs, arg[2] ? arg + 2 : NULL, 0);
		break;
	    default: assert(0);	/* can't happen */
	}
    }

    /* TODO: reconcile the weird discrepancies between
       admin_data->quiet and quiet. */
    if (status == 0)
    {
	RCS_rewrite (rcs, NULL, NULL);
	if (!admin_data->quiet)
	    cvs_output ("done\n", 5);
    }
    else
    {
	/* Note that this message should only occur after another
	   message has given a more specific error.  The point of this
	   additional message is to make it clear that the previous problems
	   caused CVS to forget about the idea of modifying the RCS file.  */
	error (0, 0, "cannot modify RCS file for `%s'", finfo->file);

	/* Upon failure, we want to abandon any changes made to the
	   RCS data structure.  Forcing a reparse does the trick,
	   but leaks memory and is kludgey.  Should we export
	   free_rcsnode_contents for this purpose? */
	RCS_reparsercsfile (rcs, NULL);
    }

@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d481 1
a481 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d493 3
a495 17
    {
	char *branch = &admin_data->branch[2];
	if (*branch != '\0' && ! isdigit (*branch))
	{
	    branch = RCS_whatbranch (rcs, admin_data->branch + 2);
	    if (branch == NULL)
	    {
		error (0, 0, "%s: Symbolic name %s is undefined.",
				rcs->path, admin_data->branch + 2);
		status = 1;
	    }
	}
	if (status == 0)
	    RCS_setbranch (rcs, branch);
	if (branch != NULL && branch != &admin_data->branch[2])
	    free (branch);
    }
d796 1
a796 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@a703 1
			free (tag);
d708 4
a711 7
                /* Attempt to perform the requested tagging.  */

		if ((*p == 0 && (rev = RCS_head (rcs)))
                    || (rev = RCS_tag2rev (rcs, p))) /* tag2rev may exit */
		{
		    RCS_check_tag (tag); /* exit if not a valid tag */
		    RCS_settag (rcs, tag, rev);
a712 8
		}
                else
		{
		    error (0, 0,
			  "%s: Symbolic name or revision %s is undefined",
			   rcs->path, p);
		    status = 1;
		}
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@d378 1
a378 1
	if (p != NULL && isdigit ((unsigned char) p[1]))
d380 1
a380 1
	else if (p != NULL && p[1] == ':' && isdigit ((unsigned char) p[2]))
d417 1
a418 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
d495 1
a495 1
	if (*branch != '\0' && ! isdigit ((unsigned char) *branch))
d607 6
a612 3
	char *oldexpand = RCS_getexpand (rcs);
	if (oldexpand == NULL || strcmp (oldexpand, kflag) != 0)
	    RCS_setexpand (rcs, kflag);
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@a122 1
    int only_k_option;
d127 25
a159 1
    only_k_option = 1;
d161 1
a161 1
			"+ib::c:a:A:e::l::u::LUn:N:m:o:s:t::IqxV:k:")) != -1)
a162 3
	if (c != 'k')
	    only_k_option = 0;

a213 5
		if (optarg == NULL)
		{
		    error (1, 0,
			   "removing entire access list not yet implemented");
		}
a354 27

#ifdef CVS_ADMIN_GROUP
    grp = getgrnam(CVS_ADMIN_GROUP);
     /* skip usage right check if group CVS_ADMIN_GROUP does not exist */
    if (grp != NULL)
    {
	char *me = getcaller();
	char **grnam = grp->gr_mem;
	/* The use of `cvs admin -k' is unrestricted.  However, any
	   other option is restricted.  */
	int denied = ! only_k_option;
	
	while (*grnam)
	{
	    if (strcmp(*grnam, me) == 0) 
	    {
		denied = 0;
		break;
	    }
	    grnam++;
	}

	if (denied)
	    error (1, 0, "usage is restricted to members of the group %s",
		   CVS_ADMIN_GROUP);
    }
#endif
@


1.1.1.15
log
@Latest from Cyclic Software
@
text
@d25 1
a25 39
    "Usage: %s %s [options] files...\n",
    "\t-a users   Append (comma-separated) user names to access list.\n",
    "\t-A file    Append another file's access list.\n",
    "\t-b[rev]    Set default branch (highest branch on trunk if omitted).\n",
    "\t-c string  Set comment leader.\n",
    "\t-e[users]  Remove (comma-separated) user names from access list\n",
    "\t           (all names if omitted).\n",
    "\t-I         Run interactively.\n",
    "\t-k subst   Set keyword substitution mode:\n",
    "\t   kv   (Default) Substitue keyword and value.\n",
    "\t   kvl  Substitue keyword, value, and locker (if any).\n",
    "\t   k    Substitue keyword only.\n",
    "\t   o    Preserve original string.\n",
    "\t   b    Like o, but mark file as binary.\n",
    "\t   v    Substitue value only.\n",
    "\t-l[rev]    Lock revision (latest revision on branch,\n",
    "\t           latest revision on trunk if omitted).\n",
    "\t-L         Set strict locking.\n",
    "\t-m rev:msg  Replace revision's log message.\n",
    "\t-n tag[:[rev]]  Tag branch or revision.  If :rev is omitted,\n",
    "\t                delete the tag; if rev is omitted, tag the latest\n",
    "\t                revision on the default branch.\n",
    "\t-N tag[:[rev]]  Same as -n except override existing tag.\n",
    "\t-o range   Delete (outdate) specified range of revisions:\n",
    "\t   rev1::rev2  Between rev1 and rev2, excluding rev1 and rev2.\n",
    "\t   rev::       After rev on the same branch.\n",
    "\t   ::rev       Before rev on the same branch.\n",
    "\t   rev         Just rev.\n",
    "\t   rev1:rev2   Between rev1 and rev2, including rev1 and rev2.\n",
    "\t   rev:        rev and following revisions on the same branch.\n",
    "\t   :rev        rev and previous revisions on the same branch.\n",
    "\t-q         Run quietly.\n",
    "\t-s state[:rev]  Set revision state (latest revision on branch,\n",
    "\t                latest revision on trunk if omitted).\n",
    "\t-t[file]   Get descriptive text from file (stdin if omitted).\n",
    "\t-t-string  Set descriptive text.\n",
    "\t-u[rev]    Unlock the revision (latest revision on branch,\n",
    "\t           latest revision on trunk if omitted).\n",
    "\t-U         Unset strict locking.\n",
d56 3
a58 1
    /* Description (-t).  */
d194 5
d290 2
a291 2
		if (optarg != NULL && optarg[0] == '-')
		    admin_data.desc = xstrdup (optarg + 1);
d294 3
a296 5
		    size_t bufsize = 0;
		    size_t len;

		    get_file (optarg, optarg, "r", &admin_data.desc,
			      &bufsize, &len);
d420 1
a420 20
	{
	    char *p = admin_data.desc;
	    send_to_server ("Argument -t-", 0);
	    while (*p)
	    {
		if (*p == '\n')
		{
		    send_to_server ("\012Argumentx ", 0);
		    ++p;
		}
		else
		{
		    char *q = strchr (p, '\n');
		    if (q == NULL) q = p + strlen (p);
		    send_to_server (p, q - p);
		    p = q;
		}
	    }
	    send_to_server ("\012", 1);
	}
d601 14
a614 1
	rcs->desc = xstrdup (admin_data->desc);
a644 2
		else if (argc == 0)
		    RCS_delaccess (rcs, NULL);
d751 1
a752 1
		{
d754 1
a754 5
		    free (revnum);
		}
		else
		    n = NULL;
		if (n == NULL)
d760 2
a761 1
		    free (rev);
a764 1
		free (rev);
a790 1
		free (rev);
d826 6
a831 1
	RCS_abandon (rcs);
@


1.1.1.16
log
@Latest from Cyclic Software
@
text
@a48 1
    "\t   rev1:rev2   Between rev1 and rev2, including rev1 and rev2.\n",
a49 1
    "\t   rev:        rev and following revisions on the same branch.\n",
a50 1
    "\t   :rev        rev and previous revisions on the same branch.\n",
d53 3
d100 4
d340 1
a340 9
		/* Silently set the global really_quiet flag.  This keeps admin in
		 * sync with the RCS man page and allows us to silently support
		 * older servers when necessary.
		 *
		 * Some logic says we might want to output a deprecation warning
		 * here, but I'm opting not to in order to stay quietly in sync
		 * with the RCS man page.
		 */
		really_quiet = 1;
d375 4
a378 25
    /* The use of `cvs admin -k' is unrestricted.  However, any other
       option is restricted if the group CVS_ADMIN_GROUP exists.  */
    if (!only_k_option &&
	(grp = getgrnam(CVS_ADMIN_GROUP)) != NULL)
    {
#ifdef HAVE_GETGROUPS
	gid_t *grps;
	int n;

	/* get number of auxiliary groups */
	n = getgroups (0, NULL);
	if (n < 0)
	    error (1, errno, "unable to get number of auxiliary groups");
	grps = (gid_t *) xmalloc((n + 1) * sizeof *grps);
	n = getgroups (n, grps);
	if (n < 0)
	    error (1, errno, "unable to get list of auxiliary groups");
	grps[n] = getgid();
	for (i = 0; i <= n; i++)
	    if (grps[i] == grp->gr_gid) break;
	free (grps);
	if (i > n)
	    error (1, 0, "usage is restricted to members of the group %s",
		   CVS_ADMIN_GROUP);
#else
d380 4
a383 1
	char **grnam;
d385 11
a395 3
	for (grnam = grp->gr_mem; *grnam; grnam++)
	    if (strcmp (*grnam, me) == 0) break;
	if (!*grnam && getgid() != grp->gr_gid)
a397 1
#endif
d430 1
a430 1
    if (current_parsed_root->isremote)
d473 1
a473 4
	/* Send this for all really_quiets since we know that it will be silently
	 * ignored when unneeded.  This supports old servers.
	 */
	if (really_quiet)
d489 1
a489 1
    lock_tree_for_write (argc, argv, 0, W_LOCAL, 0);
d549 1
a549 1
    if (!really_quiet)
d770 3
a772 4
		    if (!really_quiet)
			error (0, 0,
			       "%s: Symbolic name or revision %s is undefined.",
			       rcs->path, p);
d857 2
d862 1
a862 1
	if (!really_quiet)
d871 1
a871 2
	if (!really_quiet)
	    error (0, 0, "RCS file for `%s' not modified.", finfo->file);
@


