head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.18
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.14
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.16
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.12
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.10
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.28
	OPENBSD_5_0:1.3.0.26
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.24
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.22
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.18
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.20
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.16
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.14
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.12
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.10
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.8
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.6
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.4
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.12
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.10
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.10.0.4
	OPENBSD_3_1_BASE:1.1.1.10
	OPENBSD_3_0:1.1.1.10.0.2
	OPENBSD_3_0_BASE:1.1.1.10
	cvs-1-11-1p1:1.1.1.10
	OPENBSD_2_9:1.1.1.9.0.2
	OPENBSD_2_9_BASE:1.1.1.9
	cvs-1-11:1.1.1.9
	OPENBSD_2_8:1.1.1.8.0.8
	OPENBSD_2_8_BASE:1.1.1.8
	OPENBSD_2_7:1.1.1.8.0.6
	OPENBSD_2_7_BASE:1.1.1.8
	OPENBSD_2_6:1.1.1.8.0.4
	OPENBSD_2_6_BASE:1.1.1.8
	cvs-1-10-7:1.1.1.8
	OPENBSD_2_5:1.1.1.8.0.2
	OPENBSD_2_5_BASE:1.1.1.8
	cvs-1-10-5:1.1.1.8
	OPENBSD_2_4:1.1.1.7.0.4
	OPENBSD_2_4_BASE:1.1.1.7
	cvs-1-10:1.1.1.7
	cvs-1-9-28:1.1.1.7
	OPENBSD_2_3:1.1.1.7.0.2
	OPENBSD_2_3_BASE:1.1.1.7
	cvs-1-9-26:1.1.1.7
	cvs-1-9-24:1.1.1.7
	OPENBSD_2_2:1.1.1.6.0.2
	OPENBSD_2_2_BASE:1.1.1.6
	cvs-1-9-10:1.1.1.6
	OPENBSD_2_1:1.1.1.5.0.2
	OPENBSD_2_1_BASE:1.1.1.5
	cvs-1-9-8:1.1.1.5
	cvs-1-9-6:1.1.1.5
	cvs-1-9-4:1.1.1.5
	cvs-1-9-2:1.1.1.4
	cvs-1-9:1.1.1.3
	OPENBSD_2_0:1.1.1.2.0.2
	OPENBSD_2_0_BASE:1.1.1.2
	cvs-1-8-1:1.1.1.2
	cvs-1-8:1.1.1.2
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.20.19.18.13;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.20.04.22.11;	author fgsch;	state Exp;
branches
	1.2.8.1
	1.2.10.1
	1.2.12.1;
next	1.1;

1.1
date	96.01.30.00.18.13;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.30.00.18.13;	author tholo;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.04.27.19.41.59;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.10.18.03.35.39;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.02.21.06.37.36;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.03.18.01.56.11;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.06.28.03.28.46;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	98.02.22.08.21.19;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.02.28.21.33.04;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2001.02.10.18.57.43;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;

1.2.8.1
date	2005.04.23.03.00.21;	author brad;	state Exp;
branches;
next	;

1.2.10.1
date	2005.04.23.02.42.18;	author brad;	state Exp;
branches;
next	;

1.2.12.1
date	2005.05.23.06.37.21;	author brad;	state Exp;
branches;
next	;


desc
@@


1.4
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/*
 * Copyright (c) 1995, Cyclic Software, Bloomington, IN, USA
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with CVS.
 * 
 * Allow user to log in for an authenticating server.
 */

#include "cvs.h"
#include "getline.h"

#ifdef AUTH_CLIENT_SUPPORT   /* This covers the rest of the file. */

#ifdef HAVE_GETPASSPHRASE
#define GETPASS getpassphrase
#else
#define GETPASS getpass
#endif

/* There seems to be very little agreement on which system header
   getpass is declared in.  With a lot of fancy autoconfiscation,
   we could perhaps detect this, but for now we'll just rely on
   _CRAY, since Cray is perhaps the only system on which our own
   declaration won't work (some Crays declare the 2#$@@% thing as
   varadic, believe it or not).  On Cray, getpass will be declared
   in either stdlib.h or unistd.h.  */
#ifndef _CRAY
extern char *GETPASS ();
#endif

#ifndef CVS_PASSWORD_FILE 
#define CVS_PASSWORD_FILE ".cvspass"
#endif

/* If non-NULL, get_cvs_password() will just return this. */
static char *cvs_password = NULL;

static char *construct_cvspass_filename PROTO ((void));

/* The return value will need to be freed. */
static char *
construct_cvspass_filename ()
{
    char *homedir;
    char *passfile;

    /* Environment should override file. */
    if ((passfile = getenv ("CVS_PASSFILE")) != NULL)
	return xstrdup (passfile);

    /* Construct absolute pathname to user's password file. */
    /* todo: does this work under OS/2 ? */
    homedir = get_homedir ();
    if (! homedir)
    {
	/* FIXME?  This message confuses a lot of users, at least
	   on Win95 (which doesn't set HOMEDRIVE and HOMEPATH like
	   NT does).  I suppose the answer for Win95 is to store the
	   passwords in the registry or something (??).  And .cvsrc
	   and such too?  Wonder what WinCVS does (about .cvsrc, the
	   right thing for a GUI is to just store the password in
	   memory only)...  */
	error (1, 0, "could not find out home directory");
	return (char *) NULL;
    }

    passfile =
	(char *) xmalloc (strlen (homedir) + strlen (CVS_PASSWORD_FILE) + 3);
    strcpy (passfile, homedir);
#ifndef NO_SLASH_AFTER_HOME
    /* NO_SLASH_AFTER_HOME is defined for VMS, where foo:[bar]/.cvspass is not
       a legal filename but foo:[bar].cvspass is.  A more clean solution would
       be something more along the lines of a "join a directory to a filename"
       kind of thing....  */
    strcat (passfile, "/");
#endif
    strcat (passfile, CVS_PASSWORD_FILE);

    /* Safety first and last, Scouts. */
    if (isfile (passfile))
	/* xchmod() is too polite. */
	chmod (passfile, 0600);

    return passfile;
}



/*
 * static char *
 * password_entry_parseline (
 *			      const char *cvsroot_canonical,
 *			      const unsigned char warn,
 *			      const int linenumber,
 *			      char *linebuf
 *			     );
 *
 * Internal function used by password_entry_operation.  Parse a single line
 * from a ~/.cvsroot password file and return a pointer to the password if the
 * line refers to the same cvsroot as cvsroot_canonical
 *
 * INPUTS
 *	cvsroot_canonical	the root we are looking for
 *	warn			Boolean: print warnings for invalid lines?
 *	linenumber		the line number for error messages
 *	linebuf			the current line
 *
 * RETURNS
 * 	NULL			if the line doesn't match
 * 	char *password		as a pointer into linebuf
 *
 * NOTES
 *	This function temporarily alters linebuf, so it isn't thread safe when
 *	called on the same linebuf
 */
static char *
password_entry_parseline (cvsroot_canonical, warn, linenumber, linebuf)
    const char *cvsroot_canonical;
    const unsigned char warn;
    const int linenumber;
    char *linebuf;
{
    char *password = NULL;
    char *p;

    /* look for '^/' */
    if (*linebuf == '/')
    {
	/* Yes: slurp '^/\d+\D' and parse the rest of the line according to version number */
	char *q;
	unsigned long int entry_version;

	if (isspace(*(linebuf + 1)))
	    /* special case since strtoul ignores leading white space */
	    q = linebuf + 1;
	else
	    entry_version = strtoul (linebuf + 1, &q, 10);

	if (q == linebuf + 1)
	    /* no valid digits found by strtoul */
	    entry_version = 0;
	else
	    /* assume a delimiting seperator */
	    q++;

	switch (entry_version)
	{
	    case 1:
		/* this means the same normalize_cvsroot we are using was
		 * used to create this entry.  strcmp is good enough for
		 * us.
		 */
		p = strchr (q, ' ');
		if (p == NULL)
		{
		    if (warn && !really_quiet)
			error (0, 0, "warning: skipping invalid entry in password file at line %d",
				linenumber);
		}
		else
		{
		    *p = '\0';
		    if (strcmp (cvsroot_canonical, q) == 0)
			password = p + 1;
		    *p = ' ';
		}
		break;
	    case ULONG_MAX:
		if (warn && !really_quiet)
		{
		    error (0, errno, "warning: unable to convert version number in password file at line %d",
			    linenumber);
		    error (0, 0, "skipping entry");
		}
		break;
	    case 0:
		if (warn && !really_quiet)
		    error (0, 0, "warning: skipping entry with invalid version string in password file at line %d",
			    linenumber);
		break;
	    default:
		if (warn && !really_quiet)
		    error (0, 0, "warning: skipping entry with unknown version (%lu) in password file at line %d",
			    entry_version, linenumber);
		break;
	}
    }
    else
    {
	/* No: assume:
	 *
	 *	^cvsroot Aencoded_password$
	 *
	 * as header comment specifies and parse accordingly
	 */
	cvsroot_t *tmp_root;
	char *tmp_root_canonical;

	p = strchr (linebuf, ' ');
	if (p == NULL)
	{
	    if (warn && !really_quiet)
		error (0, 0, "warning: skipping invalid entry in password file at line %d", linenumber);
	    return NULL;;
	}

	*p = '\0';
	if ((tmp_root = parse_cvsroot (linebuf)) == NULL)
	{
	    if (warn && !really_quiet)
		error (0, 0, "warning: skipping invalid entry in password file at line %d", linenumber);
	    *p = ' ';
	    return NULL;
	}
	*p = ' ';
	tmp_root_canonical = normalize_cvsroot (tmp_root);
	if (strcmp (cvsroot_canonical, tmp_root_canonical) == 0)
	    password = p + 1;

	free (tmp_root_canonical);
	free_cvsroot_t (tmp_root);
    }

    return password;
}



/*
 * static char *
 * password_entry_operation (
 * 			     password_entry_operation_t operation,
 * 			     cvsroot_t *root,
 * 			     char *newpassword
 * 			    );
 *
 * Search the password file and depending on the value of operation:
 *
 *	Mode				Action
 *	password_entry_lookup		Return the password
 *	password_entry_delete		Delete the entry from the file, if it exists
 *	password_entry_add		Replace the line with the new one, else append it
 *
 * Because the user might be accessing multiple repositories, with
 * different passwords for each one, the format of ~/.cvspass is:
 *
 * [user@@]host:[port]/path Aencoded_password
 * [user@@]host:[port]/path Aencoded_password
 * ...
 *
 * New entries are always of the form:
 *
 * /1 user@@host:port/path Aencoded_password
 *
 * but the old format is supported for backwards compatibility.
 * The entry version string wasn't strictly necessary, but it avoids the
 * overhead of parsing some entries since we know it is already in canonical
 * form and allows room for expansion later, say, if we want to allow spaces
 * and/or other characters to be escaped in the string.  Also, the new entries
 * would have been ignored by old versions of CVS anyhow since those versions
 * didn't know how to parse a port number.
 *
 * The "A" before "encoded_password" is a literal capital A.  It's a
 * version number indicating which form of scrambling we're doing on
 * the password -- someday we might provide something more secure than
 * the trivial encoding we do now, and when that day comes, it would
 * be nice to remain backward-compatible.
 *
 * Like .netrc, the file's permissions are the only thing preventing
 * it from being read by others.  Unlike .netrc, we will not be
 * fascist about it, at most issuing a warning, and never refusing to
 * work.
 *
 * INPUTS
 * 	operation	operation to perform
 * 	root		cvsroot_t to look up
 * 	newpassword	prescrambled new password, for password_entry_add_mode
 *
 * RETURNS
 * 	-1	if password_entry_lookup_mode not specified
 * 	NULL	on failed lookup
 * 	pointer to a copy of the password string otherwise, which the caller is
 * 		responsible for disposing of
 */

typedef enum password_entry_operation_e {
    password_entry_lookup,
    password_entry_delete,
    password_entry_add
} password_entry_operation_t;

static char *
password_entry_operation (operation, root, newpassword)
    password_entry_operation_t operation;
    cvsroot_t *root;
    char *newpassword;
{
    char *passfile;
    FILE *fp;
    char *cvsroot_canonical = NULL;
    char *password = NULL;
    int line_length;
    long line;
    char *linebuf = NULL;
    size_t linebuf_len;
    char *p;
    int save_errno = 0;

    if (root->method != pserver_method)
    {
	error (0, 0, "internal error: can only call password_entry_operation with pserver method");
	error (1, 0, "CVSROOT: %s", root->original);
    }

    cvsroot_canonical = normalize_cvsroot (root);

    /* Yes, the method below reads the user's password file twice when we have
     * to delete an entry.  It's inefficient, but we're not talking about a gig of
     * data here.
     */

    passfile = construct_cvspass_filename ();
    fp = CVS_FOPEN (passfile, "r");
    if (fp == NULL)
    {
	if (operation != password_entry_add )
	    error (0, errno, "failed to open %s for reading", passfile);
	goto process;
    }

    /* Check each line to see if we have this entry already. */
    line = 0;
    while ((line_length = get_line (&linebuf, &linebuf_len, fp)) >= 0)
    {
	line++;
	password = password_entry_parseline(cvsroot_canonical, 1, line, linebuf);
	if (password != NULL)
	    /* this is it!  break out and deal with linebuf */
	    break;
    }
    if (line_length < 0 && !feof (fp))
    {
	error (0, errno, "cannot read %s", passfile);
	goto error_exit;
    }
    if (fclose (fp) < 0)
	/* not fatal, unless it cascades */
	error (0, errno, "cannot close %s", passfile);
    fp = NULL;

    /* Utter, total, raving paranoia, I know. */
    chmod (passfile, 0600);

    /* a copy to return or keep around so we can reuse linebuf */
    if (password != NULL)
    {
	/* chomp the EOL */
	p = strchr (password, '\n');
	if (p != NULL)
	    *p = '\0';
	password = xstrdup (password);
    }

process:

    /* might as well return now */
    if (operation == password_entry_lookup)
	goto out;

    /* same here */
    if (operation == password_entry_delete && password == NULL)
    {
	error (0, 0, "Entry not found.");
	goto out;
    }

    /* okay, file errors can simply be fatal from now on since we don't do
     * anything else if we're in lookup mode
     */

    /* copy the file with the entry deleted unless we're in add
     * mode and the line we found contains the same password we're supposed to
     * add
     */
    if (!noexec && password != NULL && (operation == password_entry_delete
	    || (operation == password_entry_add && strcmp (password, newpassword))))
    {
	long found_at = line;
	char *tmp_name;
	FILE *tmp_fp;

	/* open the original file again */
	fp = CVS_FOPEN (passfile, "r");
	if (fp == NULL)
	    error (1, errno, "failed to open %s for reading", passfile);

	/* create and open a temp file */
	if ((tmp_fp = cvs_temp_file (&tmp_name)) == NULL)
	    error (1, errno, "unable to open temp file %s", tmp_name);

	line = 0;
	while ((line_length = get_line (&linebuf, &linebuf_len, fp)) >= 0)
	{
	    line++;
	    if (line < found_at
		|| (line != found_at
		    && !password_entry_parseline(cvsroot_canonical, 0, line, linebuf)))
	    {
		if (fprintf (tmp_fp, "%s", linebuf) == EOF)
		{
		    /* try and clean up anyhow */
		    error (0, errno, "fatal error: cannot write %s", tmp_name);
		    if (fclose (tmp_fp) == EOF)
			error (0, errno, "cannot close %s", tmp_name);
		    /* call CVS_UNLINK instead of unlink_file since the file
		     * got created in noexec mode
		     */
		    if (CVS_UNLINK (tmp_name) < 0)
			error (0, errno, "cannot remove %s", tmp_name);
		    /* but quit so we don't remove all the entries from a
		     * user's password file accidentally
		     */
		    error (1, 0, "exiting");
		}
	    }
	}
	if (line_length < 0 && !feof (fp))
	{
	    error (0, errno, "cannot read %s", passfile);
	    goto error_exit;
	}
	if (fclose (fp) < 0)
	    /* not fatal, unless it cascades */
	    error (0, errno, "cannot close %s", passfile);
	if (fclose (tmp_fp) < 0)
	    /* not fatal, unless it cascades */
	    /* FIXME - does copy_file return correct results if the file wasn't
	     * closed? should this be fatal?
	     */
	    error (0, errno, "cannot close %s", tmp_name);

	/* FIXME: rename_file would make more sense (e.g. almost
	 * always faster).
	 *
	 * I don't think so, unless we change the way rename_file works to
	 * attempt a cp/rm sequence when rename fails since rename doesn't
	 * work across file systems and it isn't uncommon to have /tmp
	 * on its own partition.
	 *
	 * For that matter, it's probably not uncommon to have a home
	 * directory on an NFS mount.
	 */
	copy_file (tmp_name, passfile);
	if (CVS_UNLINK (tmp_name) < 0)
	    error (0, errno, "cannot remove %s", tmp_name);
	free (tmp_name);
    }

    /* in add mode, if we didn't find an entry or found an entry with a
     * different password, append the new line
     */
    if (!noexec && operation == password_entry_add
	    && (password == NULL || strcmp (password, newpassword)))
    {
	if ((fp = CVS_FOPEN (passfile, "a")) == NULL)
	    error (1, errno, "could not open %s for writing", passfile);

	if (fprintf (fp, "/1 %s %s\n", cvsroot_canonical, newpassword) == EOF)
	    error (1, errno, "cannot write %s", passfile);
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", passfile);
    }

    /* Utter, total, raving paranoia, I know. */
    chmod (passfile, 0600);

    if (password)
    {
	free (password);
	password = NULL;
    }
    if (linebuf)
	free (linebuf);

out:
    free (cvsroot_canonical);
    free (passfile);
    return password;

error_exit:
    /* just exit when we're not in lookup mode */
    if (operation != password_entry_lookup)
	error (1, 0, "fatal error: exiting");
    /* clean up and exit in lookup mode so we can try a login with a NULL
     * password anyhow in case that's what we would have found
     */
    save_errno = errno;
    if (fp != NULL)
    {
	/* Utter, total, raving paranoia, I know. */
	chmod (passfile, 0600);
	if(fclose (fp) < 0)
	    error (0, errno, "cannot close %s", passfile);
    }
    if (linebuf)
	free (linebuf);
    if (cvsroot_canonical)
	free (cvsroot_canonical);
    free (passfile);
    errno = save_errno;
    return NULL;
}



/* Prompt for a password, and store it in the file "CVS/.cvspass".
 */

static const char *const login_usage[] =
{
    "Usage: %s %s\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

int
login (argc, argv)
    int argc;
    char **argv;
{
    char *typed_password;
    char *cvsroot_canonical;

    if (argc < 0)
	usage (login_usage);

    if (current_parsed_root->method != pserver_method)
    {
	error (0, 0, "can only use `login' command with the 'pserver' method");
	error (1, 0, "CVSROOT: %s", current_parsed_root->original);
    }

    cvsroot_canonical = normalize_cvsroot(current_parsed_root);
    printf ("Logging in to %s\n", cvsroot_canonical);
    fflush (stdout);

    if (current_parsed_root->password)
    {
	typed_password = scramble (current_parsed_root->password);
    }
    else
    {
	char *tmp;
	tmp = GETPASS ("CVS password: ");
	typed_password = scramble (tmp);
	memset (tmp, 0, strlen (tmp));
    }

    /* Force get_cvs_password() to use this one (when the client
     * confirms the new password with the server), instead of
     * consulting the file.  We make a new copy because cvs_password
     * will get zeroed by connect_to_server().  */
    cvs_password = xstrdup (typed_password);

    connect_to_pserver (NULL, NULL, 1, 0);

    password_entry_operation (password_entry_add, current_parsed_root, typed_password);

    memset (typed_password, 0, strlen (typed_password));
    free (typed_password);

    free (cvs_password);
    free (cvsroot_canonical);
    cvs_password = NULL;

    return 0;
}

/* Returns the _scrambled_ password.  The server must descramble
   before hashing and comparing.  If password file not found, or
   password not found in the file, just return NULL. */
char *
get_cvs_password ()
{
    if (current_parsed_root->password)
	return (scramble(current_parsed_root->password));
 
    /* If someone (i.e., login()) is calling connect_to_pserver() out of
       context, then assume they have supplied the correct, scrambled
       password. */
    if (cvs_password)
	return cvs_password;

    if (getenv ("CVS_PASSWORD") != NULL)
    {
	/* In previous versions of CVS one could specify a password in
	 * CVS_PASSWORD.  This is a bad idea, because in BSD variants
	 * of unix anyone can see the environment variable with 'ps'.
	 * But for users who were using that feature we want to at
	 * least let them know what is going on.  After printing this
	 * warning, we should fall through to the regular error where
	 * we tell them to run "cvs login" (unless they already ran
	 * it, of course).
	 */
	 error (0, 0, "CVS_PASSWORD is no longer supported; ignored");
    }

    if (current_parsed_root->method != pserver_method)
    {
	error (0, 0, "can only call get_cvs_password with pserver method");
	error (1, 0, "CVSROOT: %s", current_parsed_root->original);
    }

    return password_entry_operation (password_entry_lookup, current_parsed_root, NULL);
}

static const char *const logout_usage[] =
{
    "Usage: %s %s\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

/* Remove any entry for the CVSRoot repository found in .cvspass. */
int
logout (argc, argv)
    int argc;
    char **argv;
{
    char *cvsroot_canonical;

    if (argc < 0)
	usage (logout_usage);

    if (current_parsed_root->method != pserver_method)
    {
	error (0, 0, "can only use pserver method with `logout' command");
	error (1, 0, "CVSROOT: %s", current_parsed_root->original);
    }

    /* Hmm.  Do we want a variant of this command which deletes _all_
       the entries from the current .cvspass?  Might be easier to
       remember than "rm ~/.cvspass" but then again if people are
       mucking with HOME (common in Win95 as the system doesn't set
       it), then this variant of "cvs logout" might give a false sense
       of security, in that it wouldn't delete entries from any
       .cvspass files but the current one.  */

    if (!quiet)
    {
	cvsroot_canonical = normalize_cvsroot(current_parsed_root);
	printf ("Logging out of %s\n", cvsroot_canonical);
	fflush (stdout);
	free (cvsroot_canonical);
    }

    password_entry_operation (password_entry_delete, current_parsed_root, NULL);

    return 0;
}

#endif /* AUTH_CLIENT_SUPPORT from beginning of file. */
@


1.3
log
@Fixes from Derek Price, CAN-2005-0753. ok deraadt@@
@
text
@d334 1
a334 1
    while ((line_length = getline (&linebuf, &linebuf_len, fp)) >= 0)
d403 1
a403 1
	while ((line_length = getline (&linebuf, &linebuf_len, fp)) >= 0)
@


1.2
log
@If $HOME/.cvspass does not exist and we're login, don't abort but create
the file.
Based on a similar diff commited to cvs repository, except we don't warn
if the file doesn't exist and we set cvsroot correctly in all the cases.
tholo@@ ok.
@
text
@d136 1
a136 1
	    entry_version = 0;
@


1.2.12.1
log
@MFC:
Fix by otto@@

Fixes from Derek Price, CAN-2005-0753.
@
text
@d136 1
a136 1
	    q = linebuf + 1;
@


1.2.8.1
log
@MFC:
Fix by otto@@

Fixes from Derek Price, CAN-2005-0753.
@
text
@d136 1
a136 1
	    q = linebuf + 1;
@


1.2.10.1
log
@MFC:
Fix by otto@@

Fixes from Derek Price, CAN-2005-0753.
@
text
@d136 1
a136 1
	    q = linebuf + 1;
@


1.1
log
@Initial revision
@
text
@d11 1
d15 15
a29 7
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)login.c 1.1 95/10/01 $";
USE(rcsid);
d39 2
d42 1
a42 1
char *
d45 39
a83 2
  char *homedir;
  char *passfile;
d85 139
a223 23
  /* Environment should override file. */
  if ((passfile = getenv ("CVS_PASSFILE")) != NULL)
    return xstrdup (passfile);

  /* Construct absolute pathname to user's password file. */
  /* todo: does this work under Win-NT and OS/2 ? */
  homedir = getenv ("HOME");
  if (! homedir)
    {
      error (1, errno, "could not find out home directory");
      return (char *) NULL;
    }
  
  passfile =
    (char *) xmalloc (strlen (homedir) + strlen (CVS_PASSWORD_FILE) + 3);
  strcpy (passfile, homedir);
  strcat (passfile, "/");
  strcat (passfile, CVS_PASSWORD_FILE);
  
  /* Safety first and last, Scouts. */
  if (isfile (passfile))
    /* xchmod() is too polite. */
    chmod (passfile, 0600);
d225 1
a225 1
  return passfile;
d229 15
a243 1
/* Prompt for a password, and store it in the file "CVS/.cvspass".
d248 2
a249 2
 * user@@host:/path Acleartext_password
 * user@@host:/path Acleartext_password
d252 3
a254 2
 * Of course, the "user@@" might be left off -- it's just based on the
 * value of CVSroot.
d256 9
a264 1
 * The "A" before "cleartext_password" is a literal capital A.  It's a
d274 244
d519 8
d532 46
a577 197
  char *username;
  int i;
  char *passfile;
  FILE *fp;
  char *typed_password, *found_password;
  char *linebuf = (char *) NULL;
  size_t linebuf_len;
  int root_len, already_entered = 0;

  /* Make this a "fully-qualified" CVSroot if necessary. */
  if (! strchr (CVSroot, '@@'))
    {
      /* We need to prepend "user@@host:". */
      char *tmp;

      printf ("Repository \"%s\" not fully-qualified.\n", CVSroot);
      printf ("Please enter \"user@@host:/path\": ");
      fflush (stdout);
      getline (&linebuf, &linebuf_len, stdin);

      tmp = xmalloc (strlen (linebuf) + 1);

      /* Give it some permanent storage. */
      strcpy (tmp, linebuf);
      tmp[strlen (linebuf) - 1] = '\0';
      CVSroot = tmp;

      /* Reset. */
      free (linebuf);
      linebuf = (char *) NULL;
    }

  if (CVSroot[0] != ':')
    {
      /* Then we need to prepend ":pserver:". */
      char *tmp;

      tmp = xmalloc (strlen (":pserver:") + strlen (CVSroot) + 1);
      strcpy (tmp, ":pserver:");
      strcat (tmp, CVSroot);
      CVSroot = tmp;
    }

  /* Check to make sure it's fully-qualified before going on. 
   * Fully qualified in this context means it has both a user and a
   * host:repos portion.
   */
  {
    char *r;

    /* After confirming that CVSroot is non-NULL, we skip past the
       initial ":pserver:" to test the rest of it. */

    if (! CVSroot)
      error (1, 0, "CVSroot is NULL");
    else if (! strchr ((r = (CVSroot + strlen (":pserver:"))), '@@'))
      goto not_fqrn;
    else if (! strchr (r, ':'))
      goto not_fqrn;
    
    if (0)        /* Lovely. */
      {
      not_fqrn:
        error (0, 0, "CVSroot not fully-qualified: %s", CVSroot);
        error (1, 0, "should be format user@@host:/path/to/repository");
      }
  }
    
  passfile = construct_cvspass_filename ();
  typed_password = getpass ("CVS password: ");
  typed_password = scramble (typed_password);

  /* Force get_cvs_password() to use this one (when the client
   * confirms the new password with the server), instead of consulting
   * the file.  We make a new copy because cvs_password will get
   * zeroed by connect_to_server().
   */
  cvs_password = xstrdup (typed_password);

  if (connect_to_pserver (NULL, NULL, 1) == 0)
    {
      /* The password is wrong, according to the server. */
      error (1, 0, "incorrect password");
    }

  /* IF we have a password for this "[user@@]host:/path" already
   *  THEN
   *    IF it's the same as the password we read from the prompt
   *     THEN 
   *       do nothing
   *     ELSE
   *       replace the old password with the new one
   *  ELSE
   *    append new entry to the end of the file.
   */

  root_len = strlen (CVSroot);

  /* Yes, the method below reads the user's password file twice.  It's
     inefficient, but we're not talking about a gig of data here. */

  fp = fopen (passfile, "r");
  if (fp != NULL)
    {
      /* Check each line to see if we have this entry already. */
      while (getline (&linebuf, &linebuf_len, fp) >= 0)
        {
          if (strncmp (CVSroot, linebuf, root_len) == 0)
            {
              already_entered = 1;
              break;
            }
          else
            {
              free (linebuf);
              linebuf = (char *) NULL;
            }
        }
    }
  fclose (fp);

      
  if (already_entered)
    {
      /* This user/host has a password in the file already. */

      strtok (linebuf, " ");
      found_password = strtok (NULL, "\n");
      if (strcmp (found_password, typed_password))
        {
          /* typed_password and found_password don't match, so we'll
           * have to update passfile.  We replace the old password
           * with the new one by writing a tmp file whose contents are
           * exactly the same as passfile except that this one entry
           * gets typed_password instead of found_password.  Then we
           * rename the tmp file on top of passfile.
           */
          char *tmp_name;
          FILE *tmp_fp;

          tmp_name = tmpnam (NULL);
          if ((tmp_fp = fopen (tmp_name, "w")) == NULL)
            {
              error (1, errno, "unable to open temp file %s", tmp_name);
              return 1;
            }
          chmod (tmp_name, 0600);

          fp = fopen (passfile, "r");
          if (fp == NULL)
            {
              error (1, errno, "unable to open %s", passfile);
              return 1;
            }
          /* I'm not paranoid, they really ARE out to get me: */
          chmod (passfile, 0600);

          free (linebuf);
          linebuf = (char *) NULL;
          while (getline (&linebuf, &linebuf_len, fp) >= 0)
            {
              if (strncmp (CVSroot, linebuf, root_len))
                fprintf (tmp_fp, "%s", linebuf);
              else
                fprintf (tmp_fp, "%s %s\n", CVSroot, typed_password);

              free (linebuf);
              linebuf = (char *) NULL;
            }
          fclose (tmp_fp);
          fclose (fp);
          rename_file (tmp_name, passfile);
          chmod (passfile, 0600);
        }
    }
  else
    {
      if ((fp = fopen (passfile, "a")) == NULL)
        {
          error (1, errno, "could not open %s", passfile);
          free (passfile);
          return 1;
        }

      fprintf (fp, "%s %s\n", CVSroot, typed_password);
      fclose (fp);
    }

  /* Utter, total, raving paranoia, I know. */
  chmod (passfile, 0600);
  memset (typed_password, 0, strlen (typed_password));
  free (typed_password);

  free (passfile);
  free (cvs_password);
  cvs_password = NULL;
  return 0;
a579 4
/* todo: "cvs logout" could erase an entry from the file.
 * But to what purpose?
 */

d581 2
a582 1
   before hashing and comparing. */
d586 54
a639 74
  int found_it = 0;
  int root_len;
  char *password;
  char *linebuf = (char *) NULL;
  size_t linebuf_len;
  FILE *fp;
  char *passfile;

  /* If someone (i.e., login()) is calling connect_to_pserver() out of
     context, then assume they have supplied the correct, scrambled
     password. */
  if (cvs_password)
    return cvs_password;

  /* Environment should override file. */
  if ((password = getenv ("CVS_PASSWORD")) != NULL)
    {
      char *p;
      p = xstrdup (password);
      /* If we got it from the environment, then it wasn't properly
         scrambled.  Since unscrambling is done on the server side, we
         need to transmit it scrambled. */
      p = scramble (p);
      return p;
    }

  /* Else get it from the file. */
  passfile = construct_cvspass_filename ();
  fp = fopen (passfile, "r");
  if (fp == NULL)
    {
      error (0, errno, "could not open %s", passfile);
      free (passfile);
      error (1, 0, "use \"cvs login\" to log in first");
    }

  root_len = strlen (CVSroot);

  /* Check each line to see if we have this entry already. */
  while (getline (&linebuf, &linebuf_len, fp) >= 0)
    {
      if (strncmp (CVSroot, linebuf, root_len) == 0)
        {
          /* This is it!  So break out and deal with linebuf. */
          found_it = 1;
          break;
        }
      else
        {
          free (linebuf);
          linebuf = (char *) NULL;
        }
    }

  if (found_it)
    {
      /* linebuf now contains the line with the password. */
      char *tmp;
      
      strtok (linebuf, " ");
      password = strtok (NULL, "\n");
      
      /* Give it permanent storage. */
      tmp = xmalloc (strlen (password) + 1);
      strcpy (tmp, password);
      tmp[strlen (password)] = '\0';
      memset (password, 0, strlen (password));
      return tmp;
    }
  else
    {
      error (0, 0, "cannot find password");
      error (0, 0, "use \"cvs login\" to log in first");
      error (1, 0, "or set the CVS_PASSWORD environment variable");
d641 20
a660 1
  free (linebuf);
a663 1

@


1.1.1.1
log
@Upgrade to 1.7.1 snapshot
@
text
@@


1.1.1.2
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@a10 1
#include "getline.h"
d14 8
a21 1
extern char *getpass ();
d42 2
a43 2
  /* todo: does this work under OS/2 ? */
  homedir = get_homedir ();
d93 2
a160 17
  /* CVSroot is now fully qualified and has ":pserver:" prepended.
     We'll print out most of it so user knows exactly what is being
     dealt with here. */
  {
    char *s;
    s = strchr (CVSroot, ':');
    s++;
    s = strchr (s, ':');
    s++;

    if (s == NULL)
      error (1, 0, "NULL CVSroot");

    printf ("(Logging in to %s)\n", s);
    fflush (stdout);
  }

a194 2
  /* FIXME: should be printing a message if fp == NULL and not
     existence_error (errno).  */
a210 1
      fclose (fp);
d212 2
a367 1
      free (linebuf);
d376 1
a376 2
  /* NOTREACHED */
  return NULL;
@


1.1.1.3
log
@New release from Cyclic Software
@
text
@d28 2
a29 2
    char *homedir;
    char *passfile;
d31 3
a33 12
    /* Environment should override file. */
    if ((passfile = getenv ("CVS_PASSFILE")) != NULL)
	return xstrdup (passfile);

    /* Construct absolute pathname to user's password file. */
    /* todo: does this work under OS/2 ? */
    homedir = get_homedir ();
    if (! homedir)
    {
	error (1, errno, "could not find out home directory");
	return (char *) NULL;
    }
d35 19
a53 16
    passfile =
	(char *) xmalloc (strlen (homedir) + strlen (CVS_PASSWORD_FILE) + 3);
    strcpy (passfile, homedir);
#ifndef NO_SLASH_AFTER_HOME
    /* NO_SLASH_AFTER_HOME is defined for VMS, where foo:[bar]/.cvspass is not
       a legal filename but foo:[bar].cvspass is.  A more clean solution would
       be something more along the lines of a "join a directory to a filename"
       kind of thing....  */
    strcat (passfile, "/");
#endif
    strcat (passfile, CVS_PASSWORD_FILE);

    /* Safety first and last, Scouts. */
    if (isfile (passfile))
	/* xchmod() is too polite. */
	chmod (passfile, 0600);
d55 1
a55 1
    return passfile;
a57 5
static const char *const login_usage[] =
{
    "Usage: %s %s\n",
    NULL
};
d87 6
a92 6
    char *passfile;
    FILE *fp;
    char *typed_password, *found_password;
    char *linebuf = (char *) NULL;
    size_t linebuf_len;
    int root_len, already_entered = 0;
d94 12
a105 2
    if (argc < 0)
	usage (login_usage);
d107 8
a114 4
    if (CVSroot_method != pserver_method)
    {
	error (0, 0, "can only use pserver method with `login' command");
	error (1, 0, "CVSROOT: %s", CVSroot_original);
d116 2
a117 2
    
    if (! CVSroot_username)
d119 7
a125 3
	error (0, 0, "CVSROOT \"%s\" is not fully-qualified.",
	       CVSroot_original);
	error (1, 0, "Please make sure to specify \"user@@host\"!");
d128 34
a161 2
    printf ("(Logging in to %s@@%s)\n", CVSroot_username, CVSroot_hostname);
    fflush (stdout);
d163 2
a164 8
    passfile = construct_cvspass_filename ();
    typed_password = getpass ("CVS password: ");
    typed_password = scramble (typed_password);

    /* Force get_cvs_password() to use this one (when the client
     * confirms the new password with the server), instead of
     * consulting the file.  We make a new copy because cvs_password
     * will get zeroed by connect_to_server().  */
d166 3
a168 1
    cvs_password = xstrdup (typed_password);
d170 3
a172 5
    if (connect_to_pserver (NULL, NULL, 1) == 0)
    {
	/* The password is wrong, according to the server. */
	error (1, 0, "incorrect password");
    }
d174 33
a206 20
    /* IF we have a password for this "[user@@]host:/path" already
     *  THEN
     *    IF it's the same as the password we read from the prompt
     *     THEN 
     *       do nothing
     *     ELSE
     *       replace the old password with the new one
     *  ELSE
     *    append new entry to the end of the file.
     */

    root_len = strlen (CVSroot_original);

    /* Yes, the method below reads the user's password file twice.  It's
       inefficient, but we're not talking about a gig of data here. */

    fp = CVS_FOPEN (passfile, "r");
    /* FIXME: should be printing a message if fp == NULL and not
       existence_error (errno).  */
    if (fp != NULL)
d208 2
a209 2
	/* Check each line to see if we have this entry already. */
	while (getline (&linebuf, &linebuf_len, fp) >= 0)
d211 1
a211 1
          if (strncmp (CVSroot_original, linebuf, root_len) == 0)
d213 2
a214 2
		already_entered = 1;
		break;
d216 1
a216 1
	    else
d218 2
a219 2
		free (linebuf);
		linebuf = (char *) NULL;
d222 1
a222 1
	fclose (fp);
d224 2
a225 2

    if (already_entered)
d227 1
a227 1
	/* This user/host has a password in the file already. */
d229 3
a231 3
	strtok (linebuf, " ");
	found_password = strtok (NULL, "\n");
	if (strcmp (found_password, typed_password))
d233 9
a241 9
	    /* typed_password and found_password don't match, so we'll
	     * have to update passfile.  We replace the old password
	     * with the new one by writing a tmp file whose contents are
	     * exactly the same as passfile except that this one entry
	     * gets typed_password instead of found_password.  Then we
	     * rename the tmp file on top of passfile.
	     */
	    char *tmp_name;
	    FILE *tmp_fp;
d243 2
a244 2
	    tmp_name = cvs_temp_name ();
	    if ((tmp_fp = CVS_FOPEN (tmp_name, "w")) == NULL)
d246 2
a247 2
		error (1, errno, "unable to open temp file %s", tmp_name);
		return 1;
d249 1
a249 1
	    chmod (tmp_name, 0600);
d251 2
a252 2
	    fp = CVS_FOPEN (passfile, "r");
	    if (fp == NULL)
d254 2
a255 2
		error (1, errno, "unable to open %s", passfile);
		return 1;
d257 2
a258 2
	    /* I'm not paranoid, they really ARE out to get me: */
	    chmod (passfile, 0600);
d260 3
a262 3
	    free (linebuf);
	    linebuf = (char *) NULL;
	    while (getline (&linebuf, &linebuf_len, fp) >= 0)
d264 1
a264 1
              if (strncmp (CVSroot_original, linebuf, root_len))
d267 1
a267 1
                fprintf (tmp_fp, "%s %s\n", CVSroot_original, typed_password);
d269 2
a270 2
		free (linebuf);
		linebuf = (char *) NULL;
d272 4
a275 6
	    fclose (tmp_fp);
	    fclose (fp);
	    copy_file (tmp_name, passfile);
	    unlink_file (tmp_name);
	    chmod (passfile, 0600);
	    free (tmp_name);
d278 1
a278 1
    else
d280 1
a280 1
	if ((fp = CVS_FOPEN (passfile, "a")) == NULL)
d282 3
a284 3
	    error (1, errno, "could not open %s", passfile);
	    free (passfile);
	    return 1;
d287 1
a287 1
      fprintf (fp, "%s %s\n", CVSroot_original, typed_password);
d291 9
a299 9
    /* Utter, total, raving paranoia, I know. */
    chmod (passfile, 0600);
    memset (typed_password, 0, strlen (typed_password));
    free (typed_password);

    free (passfile);
    free (cvs_password);
    cvs_password = NULL;
    return 0;
d337 1
a337 15
  /* Else get it from the file.  First make sure that the CVSROOT
   * variable has the appropriate fields filled in. */

  if (CVSroot_method != pserver_method)
    {
      error (0, 0, "can only call GET_CVS_PASSWORD  with pserver method");
      error (1, 0, "CVSROOT: %s", CVSroot_original);
    }
    
  if (! CVSroot_username)
    {
      error (0, 0, "CVSROOT \"%s\" is not fully-qualified.", CVSroot_original);
      error (1, 0, "Please make sure to specify \"user@@host\"!");
    }

d339 1
a339 1
  fp = CVS_FOPEN (passfile, "r");
d347 1
a347 1
  root_len = strlen (CVSroot_original);
d352 1
a352 1
      if (strncmp (CVSroot_original, linebuf, root_len) == 0)
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@a23 2
static char *construct_cvspass_filename PROTO ((void));

d25 1
a25 1
static char *
d218 4
a221 5
		if (strncmp (CVSroot_original, linebuf, root_len))
		    fprintf (tmp_fp, "%s", linebuf);
		else
		    fprintf (tmp_fp, "%s %s\n", CVSroot_original,
			     typed_password);
d243 2
a244 2
	fprintf (fp, "%s %s\n", CVSroot_original, typed_password);
	fclose (fp);
d267 24
a290 25
    int found_it = 0;
    int root_len;
    char *password;
    char *linebuf = (char *) NULL;
    size_t linebuf_len;
    FILE *fp;
    char *passfile;

    /* If someone (i.e., login()) is calling connect_to_pserver() out of
       context, then assume they have supplied the correct, scrambled
       password. */
    if (cvs_password)
	return cvs_password;

    if (getenv ("CVS_PASSWORD") != NULL)
    {
	/* In previous versions of CVS one could specify a password in
	   CVS_PASSWORD.  This is a bad idea, because in BSD variants
	   of unix anyone can see the environment variable with 'ps'.
	   But for users who were using that feature we want to at
	   least let them know what is going on.  After printing this
	   warning, we should fall through to the regular error where
	   we tell them to run "cvs login" (unless they already ran
	   it, of course).  */
	error (0, 0, "CVS_PASSWORD is no longer supported; ignored");
d293 2
a294 2
    /* Else get it from the file.  First make sure that the CVSROOT
       variable has the appropriate fields filled in. */
d296 1
a296 1
    if (CVSroot_method != pserver_method)
d298 2
a299 2
	error (0, 0, "can only call GET_CVS_PASSWORD  with pserver method");
	error (1, 0, "CVSROOT: %s", CVSroot_original);
d301 2
a302 2

    if (! CVSroot_username)
d304 2
a305 3
	error (0, 0, "CVSROOT \"%s\" is not fully-qualified.",
	       CVSroot_original);
	error (1, 0, "Please make sure to specify \"user@@host\"!");
d308 3
a310 3
    passfile = construct_cvspass_filename ();
    fp = CVS_FOPEN (passfile, "r");
    if (fp == NULL)
d312 3
a314 3
	error (0, errno, "could not open %s", passfile);
	free (passfile);
	error (1, 0, "use \"cvs login\" to log in first");
d317 1
a317 1
    root_len = strlen (CVSroot_original);
d319 2
a320 2
    /* Check each line to see if we have this entry already. */
    while (getline (&linebuf, &linebuf_len, fp) >= 0)
d322 1
a322 1
	if (strncmp (CVSroot_original, linebuf, root_len) == 0)
d324 3
a326 3
	    /* This is it!  So break out and deal with linebuf. */
	    found_it = 1;
	    break;
d328 1
a328 1
	else
d330 2
a331 2
	    free (linebuf);
	    linebuf = (char *) NULL;
d335 1
a335 1
    if (found_it)
d337 19
a355 13
	/* linebuf now contains the line with the password. */
	char *tmp;

	strtok (linebuf, " ");
	password = strtok (NULL, "\n");

	/* Give it permanent storage. */
	tmp = xmalloc (strlen (password) + 1);
	strcpy (tmp, password);
	tmp[strlen (password)] = '\0';
	memset (password, 0, strlen (password));
	free (linebuf);
	return tmp;
d357 2
a358 7
    else
    {
	error (0, 0, "cannot find password");
	error (1, 0, "use \"cvs login\" to log in first");
    }
    /* NOTREACHED */
    return NULL;
d362 1
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a14 8
/* There seems to be very little agreement on which system header
   getpass is declared in.  With a lot of fancy autoconfiscation,
   we could perhaps detect this, but for now we'll just rely on
   _CRAY, since Cray is perhaps the only system on which our own
   declaration won't work (some Crays declare the 2#$@@% thing as
   varadic, believe it or not).  On Cray, getpass will be declared
   in either stdlib.h or unistd.h.  */
#ifndef _CRAY
a15 1
#endif
d261 4
a362 95
}

static const char *const logout_usage[] =
{
    "Usage: %s %s\n",
    NULL
};

/* Remove any entry for the CVSRoot repository found in "CVS/.cvspass". */
int
logout (argc, argv)
    int argc;
    char **argv;
{
    char *passfile;
    FILE *fp;
    char *tmp_name;
    FILE *tmp_fp;
    char *linebuf = (char *) NULL;
    size_t linebuf_len;
    int root_len, found = 0;

    if (argc < 0)
	usage (logout_usage);

    if (CVSroot_method != pserver_method)
    {
	error (0, 0, "can only use pserver method with `logout' command");
	error (1, 0, "CVSROOT: %s", CVSroot_original);
    }
    
    if (! CVSroot_username)
    {
	error (0, 0, "CVSROOT \"%s\" is not fully-qualified.",
	       CVSroot_original);
	error (1, 0, "Please make sure to specify \"user@@host\"!");
    }

    /* Hmm.  Do we want a variant of this command which deletes _all_
       the entries from the current .cvspass?  Might be easier to
       remember than "rm ~/.cvspass" but then again if people are
       mucking with HOME (common in Win95 as the system doesn't set
       it), then this variant of "cvs logout" might give a false sense
       of security, in that it wouldn't delete entries from any
       .cvspass files but the current one.  */

    printf ("(Logging out of %s@@%s)\n", CVSroot_username, CVSroot_hostname);
    fflush (stdout);

    /* IF we have a password for this "[user@@]host:/path" already
     *  THEN
     *    drop the entry
     *  ELSE
     *    do nothing
     */

    passfile = construct_cvspass_filename ();
    tmp_name = cvs_temp_name ();
    if ((tmp_fp = CVS_FOPEN (tmp_name, "w")) == NULL)
    {
	error (1, errno, "unable to open temp file %s", tmp_name);
	return 1;
    }
    chmod (tmp_name, 0600);

    root_len = strlen (CVSroot_original);

    fp = CVS_FOPEN (passfile, "r");
    if (fp == NULL)
        error (1, errno, "Error opening %s", passfile);

    /* Check each line to see if we have this entry. */
    /* Copy only those lines that do not match this entry */
    while (getline (&linebuf, &linebuf_len, fp) >= 0)
    {
	if (strncmp (CVSroot_original, linebuf, root_len)) 
	    fprintf (tmp_fp, "%s", linebuf);
	else
	    found = TRUE;
    }
    fclose (fp);
    fclose (tmp_fp);

    if (! found) 
    {
	printf ("Entry not found for %s\n", CVSroot_original);
	unlink_file (tmp_name);
    }
    else
    {
	copy_file (tmp_name, passfile);
	unlink_file (tmp_name);
	chmod (passfile, 0600);
    }
    return 0;
@


1.1.1.6
log
@Latest version from Cyclic Software
@
text
@d181 5
a219 2
		if (linebuf)
		    free (linebuf);
d225 2
d235 2
a237 2
            if (linebuf)
                free (linebuf);
a247 2
	if (linebuf)
	    free (linebuf);
d338 5
d354 3
a356 1
	tmp = xstrdup (password);
a362 2
        if (linebuf)
            free (linebuf);
a447 2
    if (linebuf)
        free (linebuf);
@


1.1.1.7
log
@Latest version from Cyclic
@
text
@a77 1
    "(Specify the --help global option for a list of other help options)\n",
a114 1
    int line_length;
d124 1
a124 1

d146 5
a150 1
    connect_to_pserver (NULL, NULL, 1, 0);
d174 1
a174 1
	while ((line_length = getline (&linebuf, &linebuf_len, fp)) >= 0)
d182 1
a182 2
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", passfile);
a183 2
    else if (!existence_error (errno))
	error (0, errno, "cannot open %s", passfile);
d222 1
a222 1
	    while ((line_length = getline (&linebuf, &linebuf_len, fp)) >= 0)
d225 1
a225 4
		{
		    if (fprintf (tmp_fp, "%s", linebuf) == EOF)
			error (0, errno, "cannot write %s", tmp_name);
		}
d227 3
a229 5
		{
		    if (fprintf (tmp_fp, "%s %s\n", CVSroot_original,
				 typed_password) == EOF)
			error (0, errno, "cannot write %s", tmp_name);
		}
a230 2
	    if (line_length < 0 && !feof (fp))
		error (0, errno, "cannot read %s", passfile);
d233 2
a234 7
	    if (fclose (tmp_fp) < 0)
		error (0, errno, "cannot close %s", tmp_name);
	    if (fclose (fp) < 0)
		error (0, errno, "cannot close %s", passfile);

	    /* FIXME: rename_file would make more sense (e.g. almost
	       always faster).  */
a237 1

d252 2
a253 4
	if (fprintf (fp, "%s %s\n", CVSroot_original, typed_password) == EOF)
	    error (0, errno, "cannot write %s", passfile);
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", passfile);
a278 1
    int line_length;
d327 1
a327 1
    while ((line_length = getline (&linebuf, &linebuf_len, fp)) >= 0)
a335 4
    if (line_length < 0 && !feof (fp))
	error (0, errno, "cannot read %s", passfile);
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", passfile);
a364 1
    "(Specify the --help global option for a list of other help options)\n",
a380 1
    int line_length;
d433 1
a433 1
    while ((line_length = getline (&linebuf, &linebuf_len, fp)) >= 0)
d435 2
a436 5
	if (strncmp (CVSroot_original, linebuf, root_len))
	{
	    if (fprintf (tmp_fp, "%s", linebuf) == EOF)
		error (0, errno, "cannot write %s", tmp_name);
	}
d438 1
a438 1
	    found = 1;
a439 3
    if (line_length < 0 && !feof (fp))
	error (0, errno, "cannot read %s", passfile);

d442 2
a443 4
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", passfile);
    if (fclose (tmp_fp) < 0)
	error (0, errno, "cannot close %s", tmp_name);
a451 2
	/* FIXME: rename_file would make more sense (e.g. almost
	   always faster).  */
@


1.1.1.8
log
@Latest version from Cyclic
@
text
@d51 1
a51 8
	/* FIXME?  This message confuses a lot of users, at least
	   on Win95 (which doesn't set HOMEDRIVE and HOMEPATH like
	   NT does).  I suppose the answer for Win95 is to store the
	   passwords in the registry or something (??).  And .cvsrc
	   and such too?  Wonder what WinCVS does (about .cvsrc, the
	   right thing for a GUI is to just store the password in
	   memory only)...  */
	error (1, 0, "could not find out home directory");
d249 1
a249 2
	    if (unlink_file (tmp_name) < 0)
		error (0, errno, "cannot remove %s", tmp_name);
a439 2
    /* FIXME: This should not be in /tmp; that is almost surely a security
       hole.  Probably should just keep it in memory.  */
d479 1
a479 2
	if (unlink_file (tmp_name) < 0)
	    error (0, errno, "cannot remove %s", tmp_name);
d486 1
a486 2
	if (unlink_file (tmp_name) < 0)
	    error (0, errno, "cannot remove %s", tmp_name);
@


1.1.1.9
log
@Latest from Cyclic Software
@
text
@a14 6
#ifdef HAVE_GETPASSPHRASE
#define GETPASS getpassphrase
#else
#define GETPASS getpass
#endif

d23 1
a23 1
extern char *GETPASS ();
d145 1
a145 1
    typed_password = GETPASS ("CVS password: ");
d292 1
a292 2
   before hashing and comparing.  If password file not found, or
   password not found in the file, just return NULL. */  
d298 2
a299 2
    char *password = NULL;
    char *linebuf = NULL;
d342 1
a342 1
    if (fp == NULL) 
d344 1
d346 1
a346 1
	return NULL;
d372 1
a372 3
	tmp = strtok (NULL, "\n");
	if (tmp == NULL)
	    error (1, 0, "bad entry in %s for %s", passfile, CVSroot_original);
d375 11
a385 2
	password = xstrdup (tmp);
	memset (tmp, 0, strlen (password));
d387 2
a388 5

    if (linebuf)
        free (linebuf);
    free (passfile);
    return password;
d398 1
a398 1
/* Remove any entry for the CVSRoot repository found in .cvspass. */
d406 1
a406 1
    char *tmp_name = NULL;
a500 4

    if (tmp_name)
        free (tmp_name);

@


1.1.1.10
log
@Latest from Cyclic Software
@
text
@d88 1
a88 35


/*
 * static char *
 * password_entry_parseline (
 *			      const char *cvsroot_canonical,
 *			      const unsigned char warn,
 *			      const int linenumber,
 *			      char *linebuf
 *			     );
 *
 * Internal function used by password_entry_operation.  Parse a single line
 * from a ~/.cvsroot password file and return a pointer to the password if the
 * line refers to the same cvsroot as cvsroot_canonical
 *
 * INPUTS
 *	cvsroot_canonical	the root we are looking for
 *	warn			Boolean: print warnings for invalid lines?
 *	linenumber		the line number for error messages
 *	linebuf			the current line
 *
 * RETURNS
 * 	NULL			if the line doesn't match
 * 	char *password		as a pointer into linebuf
 *
 * NOTES
 *	This function temporarily alters linebuf, so it isn't thread safe when
 *	called on the same linebuf
 */
static char *
password_entry_parseline (cvsroot_canonical, warn, linenumber, linebuf)
    const char *cvsroot_canonical;
    const unsigned char warn;
    const int linenumber;
    char *linebuf;
d90 4
a93 2
    char *password = NULL;
    char *p;
d95 1
a95 117
    /* look for '^/' */
    if (*linebuf == '/')
    {
	/* Yes: slurp '^/\d+\D' and parse the rest of the line according to version number */
	char *q;
	unsigned long int entry_version;

	if (isspace(*(linebuf + 1)))
	    /* special case since strtoul ignores leading white space */
	    entry_version = 0;
	else
	    entry_version = strtoul (linebuf + 1, &q, 10);

	if (q == linebuf + 1)
	    /* no valid digits found by strtoul */
	    entry_version = 0;
	else
	    /* assume a delimiting seperator */
	    q++;

	switch (entry_version)
	{
	    case 1:
		/* this means the same normalize_cvsroot we are using was
		 * used to create this entry.  strcmp is good enough for
		 * us.
		 */
		p = strchr (q, ' ');
		if (p == NULL)
		{
		    if (warn && !really_quiet)
			error (0, 0, "warning: skipping invalid entry in password file at line %d",
				linenumber);
		}
		else
		{
		    *p = '\0';
		    if (strcmp (cvsroot_canonical, q) == 0)
			password = p + 1;
		    *p = ' ';
		}
		break;
	    case ULONG_MAX:
		if (warn && !really_quiet)
		{
		    error (0, errno, "warning: unable to convert version number in password file at line %d",
			    linenumber);
		    error (0, 0, "skipping entry");
		}
		break;
	    case 0:
		if (warn && !really_quiet)
		    error (0, 0, "warning: skipping entry with invalid version string in password file at line %d",
			    linenumber);
		break;
	    default:
		if (warn && !really_quiet)
		    error (0, 0, "warning: skipping entry with unknown version (%lu) in password file at line %d",
			    entry_version, linenumber);
		break;
	}
    }
    else
    {
	/* No: assume:
	 *
	 *	^cvsroot Aencoded_password$
	 *
	 * as header comment specifies and parse accordingly
	 */
	cvsroot_t *tmp_root;
	char *tmp_root_canonical;

	p = strchr (linebuf, ' ');
	if (p == NULL)
	{
	    if (warn && !really_quiet)
		error (0, 0, "warning: skipping invalid entry in password file at line %d", linenumber);
	    return NULL;;
	}

	*p = '\0';
	if ((tmp_root = parse_cvsroot (linebuf)) == NULL)
	{
	    if (warn && !really_quiet)
		error (0, 0, "warning: skipping invalid entry in password file at line %d", linenumber);
	    *p = ' ';
	    return NULL;
	}
	*p = ' ';
	tmp_root_canonical = normalize_cvsroot (tmp_root);
	if (strcmp (cvsroot_canonical, tmp_root_canonical) == 0)
	    password = p + 1;

	free (tmp_root_canonical);
	free_cvsroot_t (tmp_root);
    }

    return password;
}



/*
 * static char *
 * password_entry_operation (
 * 			     password_entry_operation_t operation,
 * 			     cvsroot_t *root,
 * 			     char *newpassword
 * 			    );
 *
 * Search the password file and depending on the value of operation:
 *
 *	Mode				Action
 *	password_entry_lookup		Return the password
 *	password_entry_delete		Delete the entry from the file, if it exists
 *	password_entry_add		Replace the line with the new one, else append it
d100 2
a101 2
 * [user@@]host:[port]/path Aencoded_password
 * [user@@]host:[port]/path Aencoded_password
d104 2
a105 3
 * New entries are always of the form:
 *
 * /1 user@@host:port/path Aencoded_password
d107 1
a107 9
 * but the old format is supported for backwards compatibility.
 * The entry version string wasn't strictly necessary, but it avoids the
 * overhead of parsing some entries since we know it is already in canonical
 * form and allows room for expansion later, say, if we want to allow spaces
 * and/or other characters to be escaped in the string.  Also, the new entries
 * would have been ignored by old versions of CVS anyhow since those versions
 * didn't know how to parse a port number.
 *
 * The "A" before "encoded_password" is a literal capital A.  It's a
a116 11
 *
 * INPUTS
 * 	operation	operation to perform
 * 	root		cvsroot_t to look up
 * 	newpassword	prescrambled new password, for password_entry_add_mode
 *
 * RETURNS
 * 	-1	if password_entry_lookup_mode not specified
 * 	NULL	on failed lookup
 * 	pointer to a copy of the password string otherwise, which the caller is
 * 		responsible for disposing of
d118 4
a121 12

typedef enum password_entry_operation_e {
    password_entry_lookup,
    password_entry_delete,
    password_entry_add
} password_entry_operation_t;

static char *
password_entry_operation (operation, root, newpassword)
    password_entry_operation_t operation;
    cvsroot_t *root;
    char *newpassword;
d125 4
a128 2
    char *cvsroot_canonical = NULL;
    char *password = NULL;
a129 5
    long line;
    char *linebuf = NULL;
    size_t linebuf_len;
    char *p;
    int save_errno = 0;
d131 2
a132 5
    if (root->method != pserver_method)
    {
	error (0, 0, "internal error: can only call password_entry_operation with pserver method");
	error (1, 0, "CVSROOT: %s", root->original);
    }
d134 1
a134 8
    /* Yes, the method below reads the user's password file twice when we have
     * to delete an entry.  It's inefficient, but we're not talking about a gig of
     * data here.
     */

    passfile = construct_cvspass_filename ();
    fp = CVS_FOPEN (passfile, "r");
    if (fp == NULL)
d136 2
a137 2
	error (0, errno, "failed to open %s for reading", passfile);
	goto error_exit;
d140 1
a140 13
    cvsroot_canonical = normalize_cvsroot (root);

    /* Check each line to see if we have this entry already. */
    line = 0;
    while ((line_length = getline (&linebuf, &linebuf_len, fp)) >= 0)
    {
	line++;
	password = password_entry_parseline(cvsroot_canonical, 1, line, linebuf);
	if (password != NULL)
	    /* this is it!  break out and deal with linebuf */
	    break;
    }
    if (line_length < 0 && !feof (fp))
d142 3
a144 2
	error (0, errno, "cannot read %s", passfile);
	goto error_exit;
a145 4
    if (fclose (fp) < 0)
	/* not fatal, unless it cascades */
	error (0, errno, "cannot close %s", passfile);
    fp = NULL;
d147 2
a148 2
    /* Utter, total, raving paranoia, I know. */
    chmod (passfile, 0600);
d150 3
a152 9
    /* a copy to return or keep around so we can reuse linebuf */
    if (password != NULL)
    {
	/* chomp the EOL */
	p = strchr (password, '\n');
	if (p != NULL)
	    *p = '\0';
	password = xstrdup (password);
    }
d154 4
a157 3
    /* might as well return now */
    if (operation == password_entry_lookup)
	goto out;
d159 1
a159 6
    /* same here */
    if (operation == password_entry_delete && password == NULL)
    {
	error (0, 0, "Entry not found.");
	goto out;
    }
d161 1
a161 3
    /* okay, file errors can simply be fatal from now on since we don't do
     * anything else if we're in lookup mode
     */
d163 9
a171 3
    /* copy the file with the entry deleted unless we're in add
     * mode and the line we found contains the same password we're supposed to
     * add
a172 15
    if (!noexec && password != NULL && (operation == password_entry_delete
	    || (operation == password_entry_add && strcmp (password, newpassword))))
    {
	long found_at = line;
	char *tmp_name;
	FILE *tmp_fp;

	/* open the original file again */
	fp = CVS_FOPEN (passfile, "r");
	if (fp == NULL)
	    error (1, errno, "failed to open %s for reading", passfile);

	/* create and open a temp file */
	if ((tmp_fp = cvs_temp_file (&tmp_name)) == NULL)
	    error (1, errno, "unable to open temp file %s", tmp_name);
d174 1
a174 40
	line = 0;
	while ((line_length = getline (&linebuf, &linebuf_len, fp)) >= 0)
	{
	    line++;
	    if (line < found_at
		|| (line != found_at
		    && !password_entry_parseline(cvsroot_canonical, 0, line, linebuf)))
	    {
		if (fprintf (tmp_fp, "%s", linebuf) == EOF)
		{
		    /* try and clean up anyhow */
		    error (0, errno, "fatal error: cannot write %s", tmp_name);
		    if (fclose (tmp_fp) == EOF)
			error (0, errno, "cannot close %s", tmp_name);
		    /* call CVS_UNLINK instead of unlink_file since the file
		     * got created in noexec mode
		     */
		    if (CVS_UNLINK (tmp_name) < 0)
			error (0, errno, "cannot remove %s", tmp_name);
		    /* but quit so we don't remove all the entries from a
		     * user's password file accidentally
		     */
		    error (1, 0, "exiting");
		}
	    }
	}
	if (line_length < 0 && !feof (fp))
	{
	    error (0, errno, "cannot read %s", passfile);
	    goto error_exit;
	}
	if (fclose (fp) < 0)
	    /* not fatal, unless it cascades */
	    error (0, errno, "cannot close %s", passfile);
	if (fclose (tmp_fp) < 0)
	    /* not fatal, unless it cascades */
	    /* FIXME - does copy_file return correct results if the file wasn't
	     * closed? should this be fatal?
	     */
	    error (0, errno, "cannot close %s", tmp_name);
d176 2
a177 16
	/* FIXME: rename_file would make more sense (e.g. almost
	 * always faster).
	 *
	 * I don't think so, unless we change the way rename_file works to
	 * attempt a cp/rm sequence when rename fails since rename doesn't
	 * work across file systems and it isn't uncommon to have /tmp
	 * on its own partition.
	 *
	 * For that matter, it's probably not uncommon to have a home
	 * directory on an NFS mount.
	 */
	copy_file (tmp_name, passfile);
	if (CVS_UNLINK (tmp_name) < 0)
	    error (0, errno, "cannot remove %s", tmp_name);
	free (tmp_name);
    }
d179 4
a182 5
    /* in add mode, if we didn't find an entry or found an entry with a
     * different password, append the new line
     */
    if (!noexec && operation == password_entry_add
	    && (password == NULL || strcmp (password, newpassword)))
d184 9
a192 5
	if ((fp = CVS_FOPEN (passfile, "a")) == NULL)
	    error (1, errno, "could not open %s for writing", passfile);

	if (fprintf (fp, "/1 %s %s\n", cvsroot_canonical, newpassword) == EOF)
	    error (1, errno, "cannot write %s", passfile);
d196 2
d199 1
a199 4
    /* Utter, total, raving paranoia, I know. */
    chmod (passfile, 0600);

    if (password)
d201 1
a201 34
	free (password);
	password = NULL;
    }
    if (linebuf)
	free (linebuf);

out:
    free (cvsroot_canonical);
    free (passfile);
    return password;

error_exit:
    /* just exit when we're not in lookup mode */
    if (operation != password_entry_lookup)
	error (1, 0, "fatal error: exiting");
    /* clean up and exit in lookup mode so we can try a login with a NULL
     * password anyhow in case that's what we would have found
     */
    save_errno = errno;
    if (fp != NULL)
    {
	/* Utter, total, raving paranoia, I know. */
	chmod (passfile, 0600);
	if(fclose (fp) < 0)
	    error (0, errno, "cannot close %s", passfile);
    }
    if (linebuf)
	free (linebuf);
    if (cvsroot_canonical)
	free (cvsroot_canonical);
    free (passfile);
    errno = save_errno;
    return NULL;
}
d203 13
d217 48
d266 2
a267 34
/* Prompt for a password, and store it in the file "CVS/.cvspass".
 */

static const char *const login_usage[] =
{
    "Usage: %s %s\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

int
login (argc, argv)
    int argc;
    char **argv;
{
    char *typed_password;
    char *cvsroot_canonical;

    if (argc < 0)
	usage (login_usage);

    if (current_parsed_root->method != pserver_method)
    {
	error (0, 0, "can only use `login' command with the 'pserver' method");
	error (1, 0, "CVSROOT: %s", current_parsed_root->original);
    }

    cvsroot_canonical = normalize_cvsroot(current_parsed_root);
    printf ("Logging in to %s\n", cvsroot_canonical);
    fflush (stdout);

    if (current_parsed_root->password)
    {
	typed_password = scramble (current_parsed_root->password);
d271 13
a283 4
	char *tmp;
	tmp = GETPASS ("CVS password: ");
	typed_password = scramble (tmp);
	memset (tmp, 0, strlen (tmp));
d286 2
a287 10
    /* Force get_cvs_password() to use this one (when the client
     * confirms the new password with the server), instead of
     * consulting the file.  We make a new copy because cvs_password
     * will get zeroed by connect_to_server().  */
    cvs_password = xstrdup (typed_password);

    connect_to_pserver (NULL, NULL, 1, 0);

    password_entry_operation (password_entry_add, current_parsed_root, typed_password);

d291 1
a292 1
    free (cvsroot_canonical);
a293 1

d299 1
a299 1
   password not found in the file, just return NULL. */
d303 9
a311 3
    if (current_parsed_root->password)
	return (scramble(current_parsed_root->password));
 
d321 17
a337 9
	 * CVS_PASSWORD.  This is a bad idea, because in BSD variants
	 * of unix anyone can see the environment variable with 'ps'.
	 * But for users who were using that feature we want to at
	 * least let them know what is going on.  After printing this
	 * warning, we should fall through to the regular error where
	 * we tell them to run "cvs login" (unless they already ran
	 * it, of course).
	 */
	 error (0, 0, "CVS_PASSWORD is no longer supported; ignored");
d340 1
a340 1
    if (current_parsed_root->method != pserver_method)
d342 3
a344 2
	error (0, 0, "can only call get_cvs_password with pserver method");
	error (1, 0, "CVSROOT: %s", current_parsed_root->original);
d347 44
a390 1
    return password_entry_operation (password_entry_lookup, current_parsed_root, NULL);
d406 8
a413 1
    char *cvsroot_canonical;
d418 1
a418 1
    if (current_parsed_root->method != pserver_method)
d421 8
a428 1
	error (1, 0, "CVSROOT: %s", current_parsed_root->original);
d439 50
a488 1
    if (!quiet)
d490 12
a501 4
	cvsroot_canonical = normalize_cvsroot(current_parsed_root);
	printf ("Logging out of %s\n", cvsroot_canonical);
	fflush (stdout);
	free (cvsroot_canonical);
d504 2
a505 1
    password_entry_operation (password_entry_delete, current_parsed_root, NULL);
@


